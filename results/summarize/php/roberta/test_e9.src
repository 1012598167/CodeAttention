4619	public static function fromString ( $ location_string ) { preg_match ( '/^\/types\/([^\/]+)\/buckets\/([^\/]+)\/keys\/([^\/]+)$/' , $ location_string , $ matches ) ; return new self ( $ matches [ 3 ] , new Bucket ( $ matches [ 2 ] , $ matches [ 1 ] ) ) ; }
4055	private function convertLegends ( array $ properties , IMetaModel $ metaModel , array $ conditions ) : array { $ result = [ ] ; $ label = [ ] ; if ( $ trans = $ metaModel -> isTranslated ( ) ) { foreach ( $ metaModel -> getAvailableLanguages ( ) as $ availableLanguage ) { $ label [ $ availableLanguage ] = $ metaModel -> getName ( ) ; } } else { $ label [ $ metaModel -> getActiveLanguage ( ) ] = $ metaModel -> getName ( ) ; } $ legend = [ 'label' => $ label , 'hide' => false , 'properties' => [ ] ] ; $ condition = function ( $ property ) use ( $ conditions ) { if ( ! isset ( $ conditions [ $ property [ 'id' ] ] ) ) { return null ; } return [ 'type' => 'conditionand' , 'children' => $ conditions [ $ property [ 'id' ] ] ] ; } ; foreach ( $ properties as $ property ) { switch ( $ property [ 'dcatype' ] ) { case 'legend' : $ this -> convertLegend ( $ property , $ trans , $ condition , $ legend , $ result ) ; break ; case 'attribute' : $ this -> convertAttribute ( $ property , $ condition , $ legend ) ; break ; default : break ; } } if ( ! empty ( $ legend [ 'properties' ] ) ) { $ result [ 'legend' . ( \ count ( $ result ) + 1 ) ] = $ legend ; } return $ result ; }
779	public function get ( $ name ) { return isset ( $ this -> _cookies [ $ name ] ) ? $ this -> _cookies [ $ name ] : null ; }
11551	public function saveConsignment ( ConsignmentInterface $ consignment ) { $ adapter = $ this -> getAdapter ( $ consignment ) ; $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENT_SAVE , $ event ) ; if ( ! $ consignment -> getStatus ( ) ) { $ consignment -> setStatus ( ConsignmentStatusList :: STATUS_NEW ) ; } try { $ adapter -> saveConsignment ( $ consignment ) ; $ this -> consignmentRepository -> saveConsignment ( $ consignment ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignment saving.' , null , $ e ) ; } $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENT_SAVE , $ event ) ; }
2488	protected function getSortFieldName ( SortClause $ sortClause , $ contentTypeIdentifier , $ fieldDefinitionIdentifier ) { return $ this -> fieldNameResolver -> getSortFieldName ( $ sortClause , $ contentTypeIdentifier , $ fieldDefinitionIdentifier ) ; }
9354	public function subMatrix ( $ int_m , $ int_n ) { $ sm = new self ( $ this -> size -> rows - 1 , $ this -> size -> cols - 1 ) ; foreach ( $ this -> arr as $ m => $ row ) { if ( $ m != $ int_m ) { $ arr_row = array ( ) ; foreach ( $ row as $ n => $ v ) { if ( $ n != $ int_n ) { $ arr_row [ ] = $ v ; } } $ sm -> addRow ( $ arr_row ) ; } } return $ sm ; }
11796	public function setSubject ( $ subject = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'subject' ) ; } $ this -> subject = $ subject ; return $ this ; }
4746	public function isReviewOptInError ( ) { $ review = oxNew ( \ OxidEsales \ Eshop \ Application \ Controller \ ReviewController :: class ) ; return $ review -> isReviewOptInError ( ) ; }
7101	static public function getClasses ( $ type ) { switch ( $ type ) { case static :: TYPE_FORM : return [ CartInterface :: class ] ; case static :: TYPE_QUOTE : return [ QuoteInterface :: class ] ; case static :: TYPE_PROFORMA : return [ QuoteInterface :: class , OrderInterface :: class ] ; case static :: TYPE_CONFIRMATION : return [ OrderInterface :: class ] ; case static :: TYPE_VOUCHER : return [ ] ; default : throw new InvalidArgumentException ( "Unexpected type '$type'." ) ; } }
11748	public function page ( ) { if ( is_null ( $ this -> page ) ) { $ this -> page = new Page ( $ this -> accessToken ) ; } return $ this -> page ; }
12456	public function installAssets ( $ targetFolder = "web" , $ force = false ) { $ sourceDir = $ this -> pluginDir . '/Resources/public' ; $ targetDir = $ this -> rootDir . '/' . $ targetFolder . '/plugins/' . strtolower ( $ this -> name ) ; if ( is_dir ( $ targetDir ) && ! $ force ) { return ; } $ this -> filesystem -> symlink ( $ sourceDir , $ targetDir , true ) ; }
1230	public function resolve ( array $ configuration ) { foreach ( $ this -> definitions as $ key => $ def ) { if ( ! isset ( $ configuration [ $ key ] ) ) { if ( isset ( $ def [ 'default' ] ) ) { $ configuration [ $ key ] = is_callable ( $ def [ 'default' ] ) ? $ def [ 'default' ] ( $ configuration ) : $ def [ 'default' ] ; } elseif ( empty ( $ def [ 'required' ] ) ) { continue ; } else { $ this -> throwRequired ( $ configuration ) ; } } $ this -> checkType ( $ def [ 'valid' ] , $ key , $ configuration [ $ key ] ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ configuration [ $ key ] , $ configuration ) ; } } return $ configuration ; }
3982	private function extractUserRights ( TokenInterface $ token ) { $ beUser = $ token -> getUser ( ) ; if ( ! ( $ beUser instanceof BackendUser ) ) { return [ ] ; } $ allowedModules = $ beUser -> modules ; switch ( true ) { case \ is_string ( $ allowedModules ) : $ allowedModules = unserialize ( $ allowedModules , [ 'allowed_classes' => false ] ) ; break ; case null === $ allowedModules : $ allowedModules = [ ] ; break ; default : } return array_flip ( $ allowedModules ) ; }
12241	public function addClass ( $ class ) { if ( ! $ this -> hasClass ( $ class ) ) { $ current = ( string ) $ this [ 'class' ] ; if ( $ current !== '' && substr ( $ current , - 1 ) !== ' ' ) { $ this [ 'class' ] .= ' ' ; } $ this [ 'class' ] .= $ class ; } return $ this ; }
5843	public function validateAdditionalFields ( array & $ submittedData , \ TYPO3 \ CMS \ Scheduler \ Controller \ SchedulerModuleController $ parentObject ) { $ result = true ; $ directories = GeneralUtility :: trimExplode ( LF , $ submittedData [ 'scheduler_batchResize_directories' ] , true ) ; foreach ( $ directories as $ directory ) { $ absoluteDirectory = GeneralUtility :: getFileAbsFileName ( $ directory ) ; if ( ! @ is_dir ( $ absoluteDirectory ) ) { $ result = false ; $ parentObject -> addMessage ( sprintf ( $ GLOBALS [ 'LANG' ] -> sL ( 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:msg.invalidDirectories' ) , $ directory ) , \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: ERROR ) ; } } $ directories = GeneralUtility :: trimExplode ( LF , $ submittedData [ 'scheduler_batchResize_excludeDirectories' ] , true ) ; foreach ( $ directories as $ directory ) { $ absoluteDirectory = GeneralUtility :: getFileAbsFileName ( $ directory ) ; if ( ! @ is_dir ( $ absoluteDirectory ) ) { $ result = false ; $ parentObject -> addMessage ( sprintf ( $ GLOBALS [ 'LANG' ] -> sL ( 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:msg.invalidExcludeDirectories' ) , $ directory ) , \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: ERROR ) ; } } return $ result ; }
9493	private function getFolderSize ( $ path ) { $ size = 0 ; foreach ( new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ path ) ) as $ directory ) { $ size += $ directory -> getSize ( ) ; } return $ size ; }
953	public function authenticate ( AuthShop $ request ) { $ validated = $ request -> validated ( ) ; $ shopDomain = ShopifyApp :: sanitizeShopDomain ( $ validated [ 'shop' ] ) ; $ shop = ShopifyApp :: shop ( $ shopDomain ) ; $ auth = new AuthShopHandler ( $ shop ) ; $ session = new ShopSession ( $ shop ) ; if ( ! $ request -> has ( 'code' ) ) { $ authUrl = $ auth -> buildAuthUrl ( $ shop -> hasOfflineAccess ( ) ? Config :: get ( 'shopify-app.api_grant_mode' ) : ShopSession :: GRANT_OFFLINE ) ; return View :: make ( 'shopify-app::auth.fullpage_redirect' , compact ( 'authUrl' , 'shopDomain' ) ) ; } $ access = $ auth -> getAccess ( $ validated [ 'code' ] ) ; $ session -> setDomain ( $ shopDomain ) ; $ session -> setAccess ( $ access ) ; $ auth -> postProcess ( ) ; $ auth -> dispatchJobs ( $ session ) ; return $ this -> returnTo ( ) ; }
12240	public function getElementsByClassName ( $ class ) { if ( strpos ( $ class , '"' ) !== false || strpos ( $ class , "'" ) !== false ) { return array ( ) ; } $ xpath = './/*[contains(concat(" ", @class, " "), " ' . htmlspecialchars ( $ class ) . ' ")]' ; return $ this -> xpath ( $ xpath ) ; }
2358	public function getBackendUsername ( ) : ? string { $ token = $ this -> getToken ( BackendUser :: SECURITY_SESSION_KEY ) ; if ( null === $ token || ! $ token -> getUser ( ) instanceof BackendUser ) { return null ; } return $ token -> getUser ( ) -> getUsername ( ) ; }
11869	public function clearOld ( int $ maxLife ) : void { $ limit = microtime ( true ) - $ maxLife / 1000000 ; foreach ( self :: $ files as & $ file ) { if ( $ file [ 'time' ] <= $ limit ) { $ file = null ; } } self :: $ files = array_filter ( self :: $ files ) ; }
5304	public function getPath ( $ scale = 1 , $ roundPrecision = null , $ flip = 'none' , $ onlyFilled = true , $ xOffset = 0 , $ yOffset = 0 ) { $ path = $ this -> getPathPart ( $ this -> xmlDocument , $ onlyFilled ) ; if ( $ scale !== 1 || $ roundPrecision !== null || $ flip !== 'none' || $ xOffset !== 0 || $ yOffset !== 0 ) { $ path = $ this -> transformPath ( $ path , $ scale , $ roundPrecision , $ flip , $ xOffset / $ scale , $ yOffset / $ scale ) ; } return trim ( $ path ) ; }
1679	public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } switch ( Contao \ Input :: get ( 'act' ) ) { case 'create' : case 'select' : case 'show' : break ; case 'delete' : if ( Contao \ Input :: get ( 'id' ) == $ this -> User -> id ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Attempt to delete own account ID ' . Contao \ Input :: get ( 'id' ) . '.' ) ; } case 'edit' : case 'copy' : case 'toggle' : default : $ objUser = $ this -> Database -> prepare ( "SELECT `admin` FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( Contao \ Input :: get ( 'id' ) ) ; if ( $ objUser -> admin && Contao \ Input :: get ( 'act' ) != '' ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not enough permissions to ' . Contao \ Input :: get ( 'act' ) . ' administrator account ID ' . Contao \ Input :: get ( 'id' ) . '.' ) ; } break ; case 'editAll' : case 'deleteAll' : case 'overrideAll' : $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ objUser = $ this -> Database -> execute ( "SELECT id FROM tl_user WHERE `admin`=1" ) ; $ session [ 'CURRENT' ] [ 'IDS' ] = array_diff ( $ session [ 'CURRENT' ] [ 'IDS' ] , $ objUser -> fetchEach ( 'id' ) ) ; $ objSession -> replace ( $ session ) ; break ; } }
1377	protected function validateIdMember ( $ value , string $ path ) : bool { if ( ! is_string ( $ value ) ) { $ this -> memberNotString ( $ path , 'id' ) ; return false ; } if ( empty ( $ value ) ) { $ this -> memberEmpty ( $ path , 'id' ) ; return false ; } return true ; }
7942	public function addSecondaryDnsDomains ( $ domain , $ domain2add , $ ip ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ domain2add = ( string ) $ domain2add ; if ( ! $ domain2add ) throw new BadMethodCallException ( 'Parameter $domain2add is missing.' ) ; $ ip = ( string ) $ ip ; if ( ! $ ip ) throw new BadMethodCallException ( 'Parameter $ip is missing.' ) ; $ payload = array ( "domain" => $ domain2add , "ip" => $ ip ) ; try { $ r = $ this -> post ( 'dedicated/server/' . $ domain . '/secondaryDnsDomains' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
2904	public function send ( $ email , $ name = null , array $ variables = array ( ) ) { $ zendMail = $ this -> getMail ( ) ; $ result = $ this -> parentSend ( $ email , $ name , $ variables ) ; try { $ this -> addEmailToProfile ( $ email , $ name , $ variables , $ result , $ zendMail ) ; } catch ( Exception $ e ) { Mage :: logException ( $ e ) ; } return $ result ; }
10359	protected static function formatBacktrace ( array $ backtrace ) : array { if ( is_array ( $ backtrace ) === false || count ( $ backtrace ) === 0 ) { return $ backtrace ; } if ( $ backtrace [ 0 ] [ 'function' ] == '{closure}' ) { unset ( $ backtrace [ 0 ] ) ; } $ trace = [ ] ; foreach ( $ backtrace as $ entry ) { $ function = '' ; if ( isset ( $ entry [ 'class' ] ) ) { $ function .= $ entry [ 'class' ] . $ entry [ 'type' ] ; } $ function .= $ entry [ 'function' ] . '()' ; $ arguments = [ ] ; if ( isset ( $ entry [ 'args' ] ) && count ( $ entry [ 'args' ] ) > 0 ) { foreach ( $ entry [ 'args' ] as $ arg ) { ob_start ( ) ; var_dump ( $ arg ) ; $ arg = htmlspecialchars ( ob_get_contents ( ) ) ; ob_end_clean ( ) ; $ arguments [ ] = $ arg ; } } $ location = [ ] ; if ( isset ( $ entry [ 'file' ] ) ) { $ location [ 'file' ] = $ entry [ 'file' ] ; $ location [ 'line' ] = $ entry [ 'line' ] ; $ location [ 'code' ] = self :: highlightCode ( $ entry [ 'file' ] , $ entry [ 'line' ] ) ; } $ trace [ ] = array ( 'function' => $ function , 'arguments' => $ arguments , 'location' => $ location , ) ; } return $ trace ; }
1404	public function add ( $ record , array $ relationship , EncodingParametersInterface $ parameters ) { $ related = $ this -> findRelated ( $ record , $ relationship ) ; $ relation = $ this -> getRelation ( $ record , $ this -> key ) ; $ existing = $ relation -> getQuery ( ) -> whereKey ( $ related -> modelKeys ( ) ) -> get ( ) ; $ relation -> saveMany ( $ related -> diff ( $ existing ) ) ; $ record -> refresh ( ) ; return $ record ; }
4775	private function loadUserConfig ( ) { if ( ! $ this -> widgetConfig ) { $ this -> widgetConfig = $ this -> entityManager -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> tokenStorage -> getToken ( ) -> getUser ( ) , ] ) ; if ( null !== $ this -> widgetConfig ) { $ this -> widgetConfig = $ this -> widgetConfig -> getConfig ( ) ; } } }
1734	public function validateCode ( User $ user , string $ code ) : bool { $ totp = TOTP :: create ( $ this -> getUpperUnpaddedSecretForUser ( $ user ) ) ; return $ totp -> verify ( $ code ) ; }
10884	public function report ( ErrorStreamReport $ report ) { $ report -> tags = $ this -> tags ; $ report -> context = $ this -> context ; return $ this -> makeRequest ( $ report ) ; }
3652	public function parse ( $ strOutputFormat , $ blnFailIfNotFound = false ) { if ( $ this -> strTemplate == '' ) { return '' ; } $ this -> strFormat = $ strOutputFormat ; $ this -> callParseTemplateHook ( ) ; $ strBuffer = '' ; $ this -> strParent = $ this -> strTemplate ; while ( $ this -> strParent !== null ) { $ strCurrent = $ this -> strParent ; $ strParent = $ this -> strDefault ? : $ this -> getTemplate ( $ this -> strParent , $ this -> strFormat , $ blnFailIfNotFound ) ; if ( empty ( $ strParent ) ) { return sprintf ( 'Template %s not found (it is maybe within a unreachable theme folder?).' , $ this -> strParent ) ; } $ this -> strParent = null ; $ this -> strDefault = null ; ob_start ( ) ; include ( $ strParent ) ; if ( $ this -> strParent === null ) { $ strBuffer = ob_get_contents ( ) ; } elseif ( $ this -> strParent == $ strCurrent ) { $ this -> strDefault = $ this -> getTemplate ( $ this -> strParent , $ this -> strFormat , $ blnFailIfNotFound ) ; } ob_end_clean ( ) ; } $ this -> arrBlocks = array ( ) ; if ( \ Config :: get ( 'debugMode' ) && in_array ( $ this -> strFormat , [ 'html5' , 'xhtml' ] ) ) { $ strRelPath = str_replace ( TL_ROOT . '/' , '' , $ this -> getTemplate ( $ this -> strTemplate , $ this -> strFormat ) ) ; $ strBuffer = <<<EOF<!-- TEMPLATE START: $strRelPath ; } return $ strBuffer ; }
764	private function splitStatements ( $ sql , $ params ) { $ semicolonIndex = strpos ( $ sql , ';' ) ; if ( $ semicolonIndex === false || $ semicolonIndex === StringHelper :: byteLength ( $ sql ) - 1 ) { return false ; } $ tokenizer = new SqlTokenizer ( $ sql ) ; $ codeToken = $ tokenizer -> tokenize ( ) ; if ( count ( $ codeToken -> getChildren ( ) ) === 1 ) { return false ; } $ statements = [ ] ; foreach ( $ codeToken -> getChildren ( ) as $ statement ) { $ statements [ ] = [ $ statement -> getSql ( ) , $ this -> extractUsedParams ( $ statement , $ params ) ] ; } return $ statements ; }
7977	public function deleteSecondaryDnsDomains ( $ domain2delete ) { json_decode ( self :: getClient ( ) -> deleteSecondaryDnsDomains ( $ this -> getDomain ( ) , $ domain2delete ) ) ; return true ; }
7766	public function getContextAction ( $ type ) { $ context = $ this -> get ( 'hydra.api' ) -> getContext ( $ type ) ; if ( null === $ context ) { $ this -> createNotFoundException ( ) ; } return new JsonLdResponse ( $ context ) ; }
10886	protected function startSession ( Request $ request , $ sessionId ) { return tap ( $ this -> getSession ( $ sessionId ) , function ( $ session ) use ( $ request ) { $ session -> setRequestOnHandler ( $ request ) ; $ session -> start ( ) ; } ) ; }
4001	protected function getMetaModelDataFrom ( $ strTable , $ intID ) { if ( ! $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ strTable ] ) ) { return null ; } $ statement = $ this -> connection -> prepare ( 'SELECT metamodel, metamodel_filtering FROM ' . $ strTable . ' WHERE id=? LIMIT 0,1' ) ; $ statement -> bindValue ( 1 , $ intID ) ; $ statement -> execute ( ) ; if ( $ statement -> rowCount ( ) < 1 ) { return null ; } return $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ; }
12807	public static function where ( string $ column , string $ operator , $ value ) : Collection { $ pdo = Database :: connect ( ) ; $ class = self :: getStaticChildClass ( ) ; $ tableName = self :: getTableName ( ) ; $ column = self :: getColumnName ( $ column ) ; if ( $ column === null ) throw new ModelMissingPropertyException ( "Could not find a property '$column' of class '$class'. " . "Are you missing a '@ColumnNameAnnotation' on a property?" ) ; $ sql = "SELECT * FROM \"$tableName\" WHERE \"$column\" $operator " . ( gettype ( $ value ) === "string" ? "'$value'" : "$value" ) ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; $ collection = new Collection ( $ class , [ ] ) ; foreach ( $ results as $ result ) { $ object = new $ class ( $ result ) ; $ collection -> push ( $ object ) ; } return $ collection ; }
9891	protected function createHint ( ) { if ( $ this -> getElement ( ) -> getHint ( ) ) { $ this -> hint = $ this -> builder -> make ( 'hint' , $ this -> getElement ( ) -> getHintAttributes ( ) , $ this -> getElement ( ) -> getHint ( ) ) ; } }
10263	public function getCreditCard ( $ weighted = true ) { if ( $ weighted ) { $ weight [ ] = [ 'American Express' , 1 ] ; $ weight [ ] = [ 'Discover' , 2 ] ; $ weight [ ] = [ 'MasterCard' , 10 ] ; $ weight [ ] = [ 'Visa' , 10 ] ; foreach ( $ weight as $ w ) { $ type = $ w [ 0 ] ; $ count = $ w [ 1 ] ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ card_types [ ] = $ type ; } } } else { $ card_types = [ 'American Express' , 'Discover' , 'MasterCard' , 'Visa' ] ; } $ cc = new Entities \ CreditCard ; $ cc -> type = $ this -> fromArray ( $ card_types ) ; $ cc -> number = $ this -> getBankNumber ( $ cc -> type ) ; $ cc -> expiration = $ this -> getExpiration ( ) ; return $ cc ; }
1542	protected function query ( $ query ) { return new CursorBuilder ( $ query , $ this -> column , $ this -> identifier , $ this -> descending ) ; }
5132	protected function hasStandardPort ( ) : bool { return ( $ this -> scheme === 'http' && $ this -> port === 80 ) || ( $ this -> scheme === 'https' && $ this -> port === 443 ) ; }
9120	public function registerRouter ( AbstractRouter $ router ) { $ this -> router = $ router ; $ this -> router -> setApplication ( $ this ) ; return $ this ; }
5423	public function invoke ( $ method ) { $ trap = SimpleTest :: getContext ( ) -> get ( 'SimpleExceptionTrap' ) ; $ trap -> clear ( ) ; try { $ has_thrown = false ; parent :: invoke ( $ method ) ; } catch ( Exception $ exception ) { $ has_thrown = true ; if ( ! $ trap -> isExpected ( $ this -> getTestCase ( ) , $ exception ) ) { $ this -> getTestCase ( ) -> exception ( $ exception ) ; } $ trap -> clear ( ) ; } if ( $ message = $ trap -> getOutstanding ( ) ) { $ this -> getTestCase ( ) -> fail ( $ message ) ; } if ( $ has_thrown ) { try { parent :: getTestCase ( ) -> tearDown ( ) ; } catch ( Exception $ e ) { } } }
9275	public function onBootstrap ( MvcEvent $ event ) { $ eventManager = $ event -> getApplication ( ) -> getEventManager ( ) ; $ sharedEventManager = $ eventManager -> getSharedManager ( ) ; }
10118	private function writeMarginLeft ( ) { $ record = 0x0026 ; $ length = 0x0008 ; $ margin = $ this -> phpSheet -> getPageMargins ( ) -> getLeft ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'd' , $ margin ) ; if ( self :: getByteOrder ( ) ) { $ data = strrev ( $ data ) ; } $ this -> append ( $ header . $ data ) ; }
4085	public function createStore ( ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; return new BreadcrumbStore ( $ this -> iconBuilder , $ this -> translator , $ request ? $ request -> getUri ( ) : '' ) ; }
696	public function afterSend ( $ message , $ isSuccessful ) { $ event = new MailEvent ( [ 'message' => $ message , 'isSuccessful' => $ isSuccessful ] ) ; $ this -> trigger ( self :: EVENT_AFTER_SEND , $ event ) ; }
5571	public function back ( ) { if ( ! $ this -> history -> back ( ) ) { return false ; } $ content = $ this -> retry ( ) ; if ( ! $ content ) { $ this -> history -> forward ( ) ; } return $ content ; }
3517	public function getShowUnpublished ( ) { if ( ! $ this -> cookiesLoaded ) { $ key = $ this -> cookiePrefix . 'show_unpublished' ; $ queuedCookie = \ Cookie :: queued ( $ key , null ) ; $ showUnpublished = $ queuedCookie != null ? $ queuedCookie -> getValue ( ) : \ Cookie :: get ( $ key , false ) ; $ this -> useDB = $ showUnpublished ? 2 : 1 ; $ this -> cookiesLoaded = true ; } return $ this -> useDB === 2 ; }
2206	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'logout' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> redirectBack ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ this -> getReferer ( ) ; } $ strLogoutUrl = System :: getContainer ( ) -> get ( 'security.logout_url_generator' ) -> getLogoutUrl ( ) ; $ strRedirect = Environment :: get ( 'base' ) ; if ( $ this -> redirectBack && ! empty ( $ _SESSION [ 'LAST_PAGE_VISITED' ] ) ) { $ strRedirect = $ _SESSION [ 'LAST_PAGE_VISITED' ] ; } elseif ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ strRedirect = $ objTarget -> getAbsoluteUrl ( ) ; } $ uri = Http :: createFromString ( $ strLogoutUrl ) ; $ query = new Query ( $ uri -> getQuery ( ) ) ; $ query = $ query -> merge ( 'redirect=' . $ strRedirect ) ; $ this -> redirect ( ( string ) $ uri -> withQuery ( ( string ) $ query ) ) ; return '' ; }
10248	public function getGuid ( ) { return sprintf ( '%04x%04x-%04x-%03x4-%04x-%04x%04x%04x' , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 4095 ) , bindec ( substr_replace ( sprintf ( '%016b' , mt_rand ( 0 , 65535 ) ) , '01' , 6 , 2 ) ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) ) ; }
6471	public function parseContentTypeHeader ( HttpHeaders $ headers ) : ? ContentTypeHeaderValue { if ( ! $ headers -> containsKey ( 'Content-Type' ) ) { return null ; } $ contentTypeHeaderParameters = $ this -> parseParameters ( $ headers , 'Content-Type' ) ; $ contentType = $ contentTypeHeaderParameters -> getKeys ( ) [ 0 ] ; return new ContentTypeHeaderValue ( $ contentType , $ contentTypeHeaderParameters ) ; }
8472	public function error ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'error' , $ scope , $ message , $ context , $ config ) ; }
12138	public function destroy ( QuestionRequest $ request , Question $ question ) { try { $ question -> delete ( ) ; return $ this -> response -> message ( trans ( 'messages.success.deleted' , [ 'Module' => trans ( 'forum::question.name' ) ] ) ) -> code ( 202 ) -> status ( 'success' ) -> url ( guard_url ( 'forum/question' ) ) -> redirect ( ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/question/' . $ question -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
11689	public function isAccompanyingPeriodValid ( ExecutionContextInterface $ context ) { $ r = $ this -> checkAccompanyingPeriodsAreNotCollapsing ( ) ; if ( $ r !== true ) { if ( $ r [ 'result' ] === self :: ERROR_PERIODS_ARE_COLLAPSING ) { $ context -> addViolationAt ( 'accompanyingPeriods' , 'Two accompanying periods have days in commun' , array ( ) ) ; } if ( $ r [ 'result' ] === self :: ERROR_ADDIND_PERIOD_AFTER_AN_OPEN_PERIOD ) { $ context -> addViolationAt ( 'accompanyingPeriods' , 'A period is opened and a period is added after it' , array ( ) ) ; } } }
8642	public function getReportRequestListByNextToken ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_GetReportRequestListByNextTokenRequest ) { $ request = new MarketplaceWebService_Model_GetReportRequestListByNextTokenRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertGetReportRequestListByNextToken ( $ request ) ) ; $ response = MarketplaceWebService_Model_GetReportRequestListByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5030	public function findPageBy ( $ repository , $ conditions ) { $ ret = $ this -> em -> getRepository ( $ repository ) -> findOneBy ( $ conditions ) ; if ( ! $ ret ) { throw new NotFoundHttpException ; } return $ ret ; }
12974	protected function autoLoadMappingInfo ( ) { $ mappings = array ( ) ; foreach ( \ Package :: loaded ( ) as $ package => $ path ) { $ mappings [ ] = $ package . '::package' ; } foreach ( \ Module :: loaded ( ) as $ module => $ path ) { $ mappings [ ] = $ module . '::module' ; } $ mappings [ ] = 'app' ; $ mappings = array_fill_keys ( $ mappings , array ( 'is_component' => true ) ) ; $ this -> setMappings ( $ mappings ) ; }
7911	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; SemanticUiPluginAsset :: register ( $ view ) ; $ selector = $ this -> selector ? : '#' . $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('$selector').$name($options);" ; $ view -> registerJs ( $ js ) ; } if ( ! empty ( $ this -> clientEvents ) ) { $ js = [ ] ; foreach ( $ this -> clientEvents as $ event => $ handler ) { $ handler = $ handler instanceof JsExpression ? $ handler : new JsExpression ( $ handler ) ; $ js [ ] = "jQuery('$selector').$name('setting', '$event', $handler);" ; } $ view -> registerJs ( implode ( "\n" , $ js ) ) ; } }
12815	private static function isNullable ( string $ table , string $ column ) : bool { if ( self :: $ nullablesCache === null || ! array_key_exists ( $ table , self :: $ nullablesCache ) ) self :: getNullables ( $ table ) ; return array_key_exists ( $ column , self :: $ nullablesCache [ $ table ] ) ; }
5867	public static function getOrientation ( $ fileName ) { $ orientation = 1 ; $ metadata = static :: getMetadata ( $ fileName ) ; if ( isset ( $ metadata [ 'Orientation' ] ) ) { $ orientation = $ metadata [ 'Orientation' ] ; } return $ orientation ; }
9113	public function setUp ( ) { $ this -> controllers = array ( ) ; $ this -> views = array ( ) ; $ this -> viewControls = array ( ) ; $ this -> setDefaults ( ) ; $ this -> init ( ) ; $ this -> setLogger ( new NullLogger ( ) ) ; return $ this ; }
957	public function remainingTrialDays ( ) { if ( ! $ this -> isTrial ( ) ) { return ; } return $ this -> isActiveTrial ( ) ? Carbon :: today ( ) -> diffInDays ( $ this -> trial_ends_on ) : 0 ; }
300	protected function refreshInternal ( $ record ) { if ( $ record === null ) { return false ; } foreach ( $ this -> attributes ( ) as $ name ) { $ this -> _attributes [ $ name ] = isset ( $ record -> _attributes [ $ name ] ) ? $ record -> _attributes [ $ name ] : null ; } $ this -> _oldAttributes = $ record -> _oldAttributes ; $ this -> _related = [ ] ; $ this -> _relationsDependencies = [ ] ; $ this -> afterRefresh ( ) ; return true ; }
2187	public function fetchByAlias ( $ strTable , $ strAlias , $ varValue ) { if ( isset ( $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ) ) { $ strPk = $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ; if ( isset ( $ this -> arrRegistry [ $ strTable ] [ $ strPk ] ) ) { return $ this -> arrRegistry [ $ strTable ] [ $ strPk ] ; } } return null ; }
2941	public static function getUnit ( $ unit ) { if ( ! is_array ( static :: $ unitDefinitions ) ) { static :: $ unitDefinitions = [ ] ; static :: initialize ( ) ; } $ key = static :: buildUnitCacheKey ( $ unit ) ; if ( isset ( self :: $ unitCache [ $ key ] ) ) { return self :: $ unitCache [ $ key ] ; } foreach ( static :: $ unitDefinitions as $ unitOfMeasure ) { if ( $ unit === $ unitOfMeasure -> getName ( ) || $ unitOfMeasure -> isAliasOf ( $ unit ) ) { return self :: $ unitCache [ $ key ] = $ unitOfMeasure ; } } throw new Exception \ UnknownUnitOfMeasure ( [ ':unit' => $ unit ] ) ; }
8514	public function listInboundShipmentsByNextToken ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentsByNextTokenRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipmentsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8810	public function destroy ( ) { foreach ( $ _COOKIE as $ key => $ value ) { setcookie ( $ key , null , - 1 , '/' ) ; unset ( $ _COOKIE [ $ key ] ) ; } return ; }
3400	protected function makeRequest ( $ arguments = [ ] ) { $ defaults = $ this -> getDefaultOptions ( ) ; $ arguments = array_merge ( $ defaults , $ arguments ) ; $ client = $ this -> resource -> getGuzzle ( ) ; $ request = $ client -> createRequest ( $ this -> getMethod ( ) , $ this -> url , $ arguments ) ; $ response = $ client -> send ( $ request ) ; $ this -> setResponse ( $ response ) ; $ this -> setContent ( ( string ) $ response -> getBody ( ) ) ; }
9906	public static function map ( $ color , $ palette , $ version ) { if ( $ color <= 0x07 || $ color >= 0x40 ) { return Color \ BuiltIn :: lookup ( $ color ) ; } elseif ( isset ( $ palette , $ palette [ $ color - 8 ] ) ) { return $ palette [ $ color - 8 ] ; } if ( $ version == Xls :: XLS_BIFF8 ) { return Color \ BIFF8 :: lookup ( $ color ) ; } return Color \ BIFF5 :: lookup ( $ color ) ; }
10034	function unsubscribeContactById ( $ id , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( 'id' => $ id ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } return $ this -> delete ( "contacts/contact/unsubscribe" , $ queryParameters ) ; }
12828	protected function registerCustomFunctions ( ) { $ functionList = $ this -> functionGenerator -> getFunctionList ( ) ; foreach ( $ functionList as $ function ) { if ( isset ( $ function [ 'name' ] ) && isset ( $ function [ 'callable' ] ) ) { $ twigFunction = new Twig_SimpleFunction ( $ function [ 'name' ] , $ function [ 'callable' ] ) ; $ this -> engine -> addFunction ( $ twigFunction ) ; } } }
334	protected function getTableSequenceName ( $ tableName ) { $ sequenceNameSql = <<<'SQL'SELECT UD.REFERENCED_NAME AS SEQUENCE_NAMEFROM USER_DEPENDENCIES UD JOIN USER_TRIGGERS UT ON (UT.TRIGGER_NAME = UD.NAME)WHERE UT.TABLE_NAME = :tableName AND UD.TYPE = 'TRIGGER' AND UD.REFERENCED_TYPE = 'SEQUENCE'SQL ; $ sequenceName = $ this -> db -> createCommand ( $ sequenceNameSql , [ ':tableName' => $ tableName ] ) -> queryScalar ( ) ; return $ sequenceName === false ? null : $ sequenceName ; }
11103	public function filter ( ScopeInterface $ scope ) { $ filtered = new self ; foreach ( $ this as $ eachResult ) { if ( $ eachResult -> getScope ( ) -> isEqualTo ( $ scope ) ) { $ filtered -> add ( $ eachResult ) ; } } return $ filtered ; }
8495	public function getFulfillmentOrder ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetFulfillmentOrderRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetFulfillmentOrderRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetFulfillmentOrder' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetFulfillmentOrderResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10801	public function renderPageHistoricContentFiltersActionsAction ( ) { $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPagehistoricTable' ) ; $ actions = $ melisPageHistoricTable -> getPageHistoricListOfActions ( ) -> toArray ( ) ; $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ options = '<option value="">' . $ translator -> translate ( 'tr_melispagehistoric_filter_action_select' ) . '</option>' ; foreach ( $ actions as $ action ) { $ options .= '<option value="' . $ action [ 'action' ] . '">' . $ action [ 'action' ] . '</option>' ; } $ view = new ViewModel ( ) ; $ view -> options = $ options ; return $ view ; }
4895	public function render ( $ type = null , $ content = true , array $ options = array ( ) ) { if ( is_array ( $ type ) ) { $ options = $ type ; $ type = self :: TYPE_INFO ; $ content = true ; } elseif ( is_array ( $ content ) ) { $ options = $ content ; $ content = true ; } if ( true === $ content ) { return $ this -> start ( $ type , $ options ) ; } $ id = isset ( $ options [ 'id' ] ) ? ' id="' . $ options [ 'id' ] . '"' : '' ; $ class = isset ( $ options [ 'class' ] ) ? ' ' . $ options [ 'class' ] : '' ; if ( ( isset ( $ options [ 'dismissable' ] ) && $ options [ 'dismissable' ] ) || ! isset ( $ options [ 'dismissable' ] ) ) { $ class .= ' alert-dismissable' ; $ content = '<button type="button" class="close" data-dismiss="alert">&times;</button>' . '<span class="notification-content">' . $ content . '</span>' ; } $ target = array_key_exists ( 'target' , $ options ) ? ' target="' . $ options [ 'target' ] . '"' : '' ; $ markup = '<div ' . $ id . ' class="alert alert-' . $ type . $ class . '" ' . $ target . '>' . $ content . '</div>' . PHP_EOL ; return $ markup ; }
867	private function getPreviousBlock ( Tokens $ tokens , $ index ) { $ close = $ previous = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ close ] -> equals ( '}' ) ) { $ previous = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ close ) ; } $ open = $ tokens -> getPrevTokenOfKind ( $ previous , [ [ T_IF ] , [ T_ELSE ] , [ T_ELSEIF ] ] ) ; if ( $ tokens [ $ open ] -> isGivenKind ( T_IF ) ) { $ elseCandidate = $ tokens -> getPrevMeaningfulToken ( $ open ) ; if ( $ tokens [ $ elseCandidate ] -> isGivenKind ( T_ELSE ) ) { $ open = $ elseCandidate ; } } return [ $ open , $ close ] ; }
4154	protected function getBearerTokenCredentials ( ) { $ signingKey = rawurlencode ( $ this -> getConsumerKey ( ) ) . ':' . rawurlencode ( $ this -> getConsumerSecret ( ) ) ; return base64_encode ( $ signingKey ) ; }
1109	protected function groupRootsByScope ( $ roots ) { $ rootsGroupedByScope = array ( ) ; foreach ( $ roots as $ root ) { $ key = $ this -> keyForScope ( $ root ) ; if ( ! isset ( $ rootsGroupedByScope [ $ key ] ) ) $ rootsGroupedByScope [ $ key ] = array ( ) ; $ rootsGroupedByScope [ $ key ] [ ] = $ root ; } return $ rootsGroupedByScope ; }
5534	public function paintFooter ( $ group ) { $ aspect = 1 ; $ this -> paintResultsHeader ( ) ; $ this -> paintRectangleStart ( $ this -> _reporter -> getGraph ( ) , 100 , 100 ) ; $ this -> divideMapNodes ( $ this -> _reporter -> getGraph ( ) , $ aspect ) ; $ this -> paintRectangleEnd ( ) ; $ this -> paintResultsFooter ( ) ; }
5967	public function tempPasswordList ( $ resolve = false ) { $ passwords = $ this -> request ( "servertemppasswordlist" ) -> toAssocArray ( "pw_clear" ) ; if ( $ resolve ) { foreach ( $ passwords as $ password => $ array ) { try { $ channel = $ this -> channelGetById ( $ array [ "tcid" ] ) ; $ passwords [ $ password ] [ "tcname" ] = $ channel -> toString ( ) ; $ passwords [ $ password ] [ "tcpath" ] = $ channel -> getPathway ( ) ; } catch ( Ts3Exception $ e ) { if ( $ e -> getCode ( ) != 0xA00 ) { throw $ e ; } } } } return $ passwords ; }
12159	public function getTitle ( ) { if ( ! is_object ( $ this -> _title ) ) { $ this -> _title = new Noun ( $ this -> _title ) ; } return $ this -> _title ; }
12708	public static function runCommand ( string $ command , array $ arguments = null , array $ options = null ) : void { $ commandObject = new $ command ( $ arguments , $ options ) ; $ commandObject -> update ( $ arguments , $ options ) ; $ commandObject -> handle ( ) ; }
1030	private function completeValueCatchingError ( Type $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , $ result ) { $ exeContext = $ this -> exeContext ; if ( $ returnType instanceof NonNull ) { return $ this -> completeValueWithLocatedError ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } try { $ completed = $ this -> completeValueWithLocatedError ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; $ promise = $ this -> getPromise ( $ completed ) ; if ( $ promise ) { return $ promise -> then ( null , function ( $ error ) use ( $ exeContext ) { $ exeContext -> addError ( $ error ) ; return $ this -> exeContext -> promises -> createFulfilled ( null ) ; } ) ; } return $ completed ; } catch ( Error $ err ) { $ exeContext -> addError ( $ err ) ; return null ; } }
12631	public function prepare ( Order $ order ) { $ order -> notify_url = $ order -> get ( 'notify_url' , $ this -> merchant -> notify_url ) ; if ( is_null ( $ order -> spbill_create_ip ) ) { $ order -> spbill_create_ip = ( $ order -> trade_type === Order :: NATIVE ) ? get_server_ip ( ) : get_client_ip ( ) ; } return $ this -> request ( $ this -> wrapApi ( self :: API_PREPARE_ORDER ) , $ order -> all ( ) ) ; }
7802	protected function statement ( $ text ) { $ text = trim ( $ text ) ; if ( ( $ pos = strpos ( $ text , ':20:' ) ) === false ) { throw new \ RuntimeException ( 'Not an MT940 statement' ) ; } $ this -> statementHeader ( substr ( $ text , 0 , $ pos ) ) ; return $ this -> statementBody ( substr ( $ text , $ pos ) ) ; }
5202	public function open ( ) { try { $ additionalConnectionOptions = array ( ) ; foreach ( array ( 'connection_timeout' , 'read_write_timeout' , 'keepalive' , 'heartbeat' ) as $ option ) { if ( isset ( $ this -> $ option ) ) { $ additionalConnectionOptions [ $ option ] = $ this -> $ option ; } } $ this -> AMQPConnection = new AMQPSSLConnection ( $ this -> host , $ this -> port , $ this -> username , $ this -> password , $ this -> vhost , $ this -> ssl_context_options , $ additionalConnectionOptions ) ; $ this -> channel = $ this -> AMQPConnection -> channel ( ) ; $ this -> channel -> queue_declare ( $ this -> queue_name , false , false , false , false ) ; $ this -> channel -> exchange_declare ( $ this -> exchange , $ this -> exchange_type , false , true , false ) ; $ this -> channel -> queue_bind ( $ this -> queue_name , $ this -> exchange ) ; } catch ( Exception $ e ) { throw new Exception ( $ e ) ; } }
10682	public static function quoteWith ( $ o , $ quote = '\'' ) { if ( strlen ( $ quote ) !== 1 ) { throw new InvalidArgumentException ( '2nd parameter must be single character, two or more characters are given' ) ; } if ( is_array ( $ o ) ) { $ len = count ( $ o ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ tmp [ $ i ] = $ quote . $ o [ $ i ] . $ quote ; } return $ tmp ; } return $ quote . $ o . $ quote ; }
7976	public function addSecondaryDnsDomains ( $ domain2add , $ ip ) { self :: getClient ( ) -> addSecondaryDnsDomains ( $ this -> getDomain ( ) , $ domain2add , $ ip ) ; return true ; }
6882	public static function format ( $ number , $ places , $ monetary = FALSE ) { $ info = localeconv ( ) ; if ( $ monetary ) { $ decimal = $ info [ 'mon_decimal_point' ] ; $ thousands = $ info [ 'mon_thousands_sep' ] ; } else { $ decimal = $ info [ 'decimal_point' ] ; $ thousands = $ info [ 'thousands_sep' ] ; } return number_format ( $ number , $ places , $ decimal , $ thousands ) ; }
12243	public function XSLT ( $ filepath , $ use_xslcache = true ) { if ( $ use_xslcache && extension_loaded ( 'xslcache' ) ) { $ xslt = new XSLTCache ; $ xslt -> importStylesheet ( $ filepath ) ; } else { $ xsl = new DOMDocument ; $ xsl -> load ( $ filepath ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; } return $ xslt -> transformToXML ( dom_import_simplexml ( $ this ) ) ; }
4521	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ user = $ event -> getUser ( ) ; if ( $ user instanceof User ) { $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getIdentity ( ) -> getType ( ) ) ; } else { $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getIdentity ( ) ) ; } $ event -> setData ( $ data ) ; }
1015	public function setValidationRules ( $ validationRules ) { if ( ! is_callable ( $ validationRules ) && ! is_array ( $ validationRules ) && $ validationRules !== null ) { throw new InvariantViolation ( 'Server config expects array of validation rules or callable returning such array, but got ' . Utils :: printSafe ( $ validationRules ) ) ; } $ this -> validationRules = $ validationRules ; return $ this ; }
6251	protected function createGroupPresence ( $ id , $ label , array $ children = [ ] ) { return new AclPresence ( [ 'type' => AclPresenceType :: GROUP , 'id' => $ id , 'label' => $ label , 'children' => $ children , ] ) ; }
8110	public static function start ( ) { $ compatibility = [ self :: SUBSITES => null , ] ; if ( ClassInfo :: exists ( Subsite :: class ) ) { $ compatibility [ self :: SUBSITES ] = Subsite :: $ disable_subsite_filter ; Subsite :: disable_subsite_filter ( true ) ; } return $ compatibility ; }
11015	public static function sec2time ( $ seconds ) { $ sec = intval ( $ seconds ) ; $ dtF = new \ DateTime ( "@0" ) ; $ dtT = new \ DateTime ( "@$sec" ) ; return $ dtF -> diff ( $ dtT ) -> format ( '%a days, %h hours, %i minutes and %s seconds' ) ; }
12837	public function build ( ) { $ this -> appDir = $ this -> rootDir . '/app' ; $ siteDir = $ this -> appDir . '/data/' . $ this -> siteName ; $ siteConfigDir = $ siteDir . '/config' ; $ pagesDir = $ siteDir . '/pages/pages' ; $ rolesDir = $ siteDir . '/roles' ; $ slotsDir = $ siteDir . '/slots' ; $ usersDir = $ siteDir . '/users' ; $ folders = array ( $ siteConfigDir , $ pagesDir , $ rolesDir , $ slotsDir , $ usersDir , ) ; $ this -> filesystem -> mkdir ( $ folders ) ; $ this -> createConfiguration ( $ siteDir ) ; $ this -> createSite ( $ siteDir ) ; $ this -> createRoles ( $ rolesDir ) ; $ this -> createUsers ( $ usersDir ) ; $ this -> filesystem -> touch ( $ siteDir . '/incomplete.json' ) ; return $ this ; }
3588	protected function getMetaBetweenConstraint ( $ column , array $ values ) { $ min = $ values [ 0 ] ; $ max = $ values [ 1 ] ; return function ( $ query ) use ( $ column , $ min , $ max ) { $ query -> where ( 'meta_key' , $ column ) -> where ( 'meta_value' , '>=' , $ min ) -> where ( 'meta_value' , '<=' , $ max ) ; } ; }
8500	protected function setSSLCurlOptions ( $ ch ) { curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , $ this -> _config [ 'SSL_VerifyPeer' ] ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , $ this -> _config [ 'SSL_VerifyHost' ] ) ; }
1274	private function createRequestLandedCost ( LandedCostRequest $ landedCostRequest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ tradeabilityRequest = $ xml -> appendChild ( $ xml -> createElement ( 'LandedCostRequest' ) ) ; $ tradeabilityRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ tradeabilityRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LandedCost' ) ) ; if ( $ landedCostRequest -> getQueryRequest ( ) !== null ) { $ tradeabilityRequest -> appendChild ( $ landedCostRequest -> getQueryRequest ( ) -> toNode ( $ xml ) ) ; } return $ xml -> saveXML ( ) ; }
1194	public function setRequest ( Request $ request ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 2.3 and will be removed in 3.0. Pass a RequestStack in the constructor instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ this -> request = $ request ; }
12878	public function setValue ( $ value ) { $ this -> value = $ value ; if ( is_array ( $ value ) && array_key_exists ( 'start' , $ value ) && array_key_exists ( 'end' , $ value ) ) { $ start = ( float ) $ value [ 'start' ] ; $ end = ( float ) $ value [ 'end' ] ; if ( $ start <= $ end ) { $ this -> startElement -> setValue ( $ start ) ; $ this -> endElement -> setValue ( $ end ) ; } } return $ this ; }
3280	protected function normalizeConfig ( array $ config ) : array { $ defaultConfig = [ 'dir' => getcwd ( ) , 'ext' => '.dat' , 'gzip' => false , 'cache' => true , 'formatter' => null , 'swap_memory_limit' => 2097152 , ] ; return array_replace ( $ defaultConfig , $ config ) ; }
12842	static public function removeFiles ( $ directory ) { $ scan = glob ( rtrim ( $ directory , '/' ) . '/*' ) ; foreach ( $ scan as $ file ) { if ( is_file ( $ file ) ) { unlink ( $ file ) ; } } return true ; }
229	public function getPdoType ( $ data ) { static $ typeMap = [ 'boolean' => \ PDO :: PARAM_BOOL , 'integer' => \ PDO :: PARAM_INT , 'string' => \ PDO :: PARAM_STR , 'resource' => \ PDO :: PARAM_LOB , 'NULL' => \ PDO :: PARAM_NULL , ] ; $ type = gettype ( $ data ) ; return isset ( $ typeMap [ $ type ] ) ? $ typeMap [ $ type ] : \ PDO :: PARAM_STR ; }
11218	public static function dispatch ( ) { self :: routeValidator ( ) ; self :: $ routes = str_replace ( '//' , '/' , self :: $ routes ) ; if ( in_array ( self :: $ uri , self :: $ routes , true ) ) { return self :: checkRoutes ( ) ; } if ( self :: checkRegexRoutes ( ) !== false ) { return self :: checkRegexRoutes ( ) ; } return self :: getErrorCallback ( ) ; }
5596	public function invoke ( $ method ) { $ queue = $ this -> createErrorQueue ( ) ; set_error_handler ( 'SimpleTestErrorHandler' ) ; parent :: invoke ( $ method ) ; restore_error_handler ( ) ; $ queue -> tally ( ) ; }
4004	public function getMetaModelNameFromId ( GetMetaModelNameFromIdEvent $ event ) { $ metaModelId = $ event -> getMetaModelId ( ) ; if ( array_key_exists ( $ metaModelId , $ this -> instancesById ) ) { $ event -> setMetaModelName ( $ this -> instancesById [ $ metaModelId ] -> getTableName ( ) ) ; return ; } if ( isset ( $ this -> tableNames [ $ metaModelId ] ) ) { $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; return ; } if ( ! $ this -> tableNamesCollected ) { $ table = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ metaModelId ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( $ table ) { $ this -> tableNames [ $ metaModelId ] = $ table [ 'tableName' ] ; $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; } } }
1307	private static function replaceUrlParameter ( $ url , $ source ) { $ parameter = static :: urlParameter ( $ url ) ; return str_replace ( '{' . $ parameter . '}' , $ source [ $ parameter ] , $ url ) ; }
252	public function removeAllFlashes ( ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; foreach ( array_keys ( $ counters ) as $ key ) { unset ( $ _SESSION [ $ key ] ) ; } unset ( $ _SESSION [ $ this -> flashParam ] ) ; }
131	protected function updateLocalRepo ( ) { $ fs = new Filesystem ( ) ; $ fs -> ensureDirectoryExists ( $ this -> checkoutDir ) ; if ( ! is_writable ( dirname ( $ this -> checkoutDir ) ) ) { throw new \ RuntimeException ( 'Can not clone ' . $ this -> url . ' to access package information. The "' . $ this -> checkoutDir . '" directory is not writable by the current user.' ) ; } if ( is_file ( $ this -> repoFile ) && is_dir ( $ this -> checkoutDir ) && 0 === $ this -> process -> execute ( 'fossil info' , $ output , $ this -> checkoutDir ) ) { if ( 0 !== $ this -> process -> execute ( 'fossil pull' , $ output , $ this -> checkoutDir ) ) { $ this -> io -> writeError ( '<error>Failed to update ' . $ this -> url . ', package information from this repository may be outdated (' . $ this -> process -> getErrorOutput ( ) . ')</error>' ) ; } } else { $ fs -> removeDirectory ( $ this -> checkoutDir ) ; $ fs -> remove ( $ this -> repoFile ) ; $ fs -> ensureDirectoryExists ( $ this -> checkoutDir ) ; if ( 0 !== $ this -> process -> execute ( sprintf ( 'fossil clone %s %s' , ProcessExecutor :: escape ( $ this -> url ) , ProcessExecutor :: escape ( $ this -> repoFile ) ) , $ output ) ) { $ output = $ this -> process -> getErrorOutput ( ) ; throw new \ RuntimeException ( 'Failed to clone ' . $ this -> url . ' to repository ' . $ this -> repoFile . "\n\n" . $ output ) ; } if ( 0 !== $ this -> process -> execute ( sprintf ( 'fossil open %s --nested' , ProcessExecutor :: escape ( $ this -> repoFile ) ) , $ output , $ this -> checkoutDir ) ) { $ output = $ this -> process -> getErrorOutput ( ) ; throw new \ RuntimeException ( 'Failed to open repository ' . $ this -> repoFile . ' in ' . $ this -> checkoutDir . "\n\n" . $ output ) ; } } }
7788	public function setContraAccountClass ( $ contraAccountClass ) { if ( ! is_callable ( $ contraAccountClass ) && ! class_exists ( $ contraAccountClass ) ) { throw new \ InvalidArgumentException ( '$contraAccountClass must be a valid classname or a PHP callable' ) ; } $ this -> contraAccountClass = $ contraAccountClass ; return $ this ; }
80	public static function suppress ( $ mask = null ) { if ( ! isset ( $ mask ) ) { $ mask = E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE | E_DEPRECATED | E_USER_DEPRECATED | E_STRICT ; } $ old = error_reporting ( ) ; self :: $ stack [ ] = $ old ; error_reporting ( $ old & ~ $ mask ) ; return $ old ; }
4595	public function getPermissions ( User $ user ) { $ permissions = new ArrayCollection ; $ accesses = $ this -> repository -> findBy ( [ 'assignee' => $ user -> getIdentity ( ) -> getType ( ) , 'assigneeUuid' => null ] ) ; foreach ( $ accesses as $ access ) { foreach ( $ access -> getPermissions ( ) as $ permission ) { $ permissions -> add ( $ permission ) ; } } $ accesses = $ this -> repository -> findBy ( [ 'assignee' => $ user -> getIdentity ( ) -> getType ( ) , 'assigneeUuid' => $ user -> getIdentity ( ) -> getUuid ( ) ] ) ; foreach ( $ accesses as $ access ) { foreach ( $ access -> getPermissions ( ) as $ permission ) { $ permissions -> add ( $ permission ) ; } } $ accesses = $ this -> repository -> findBy ( [ 'assignee' => 'Role' , 'assigneeUuid' => $ user -> getIdentity ( ) -> getRoles ( ) ] ) ; foreach ( $ accesses as $ access ) { foreach ( $ access -> getPermissions ( ) as $ permission ) { $ permissions -> add ( $ permission ) ; } } return $ permissions ; }
10280	public static function absoluteReference ( $ pCoordinateString ) { if ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } $ worksheet = '' ; $ cellAddress = explode ( '!' , $ pCoordinateString ) ; if ( count ( $ cellAddress ) > 1 ) { list ( $ worksheet , $ pCoordinateString ) = $ cellAddress ; } if ( $ worksheet > '' ) { $ worksheet .= '!' ; } if ( ctype_digit ( $ pCoordinateString ) ) { return $ worksheet . '$' . $ pCoordinateString ; } elseif ( ctype_alpha ( $ pCoordinateString ) ) { return $ worksheet . '$' . strtoupper ( $ pCoordinateString ) ; } return $ worksheet . self :: absoluteCoordinate ( $ pCoordinateString ) ; }
8253	protected function handleAccountPage ( Request $ httpRequest ) { $ user = $ this -> picoAuth -> getUser ( ) ; if ( ! $ user -> getAuthenticated ( ) ) { $ this -> session -> addFlash ( "error" , "Login to access this page." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; return ; } if ( $ user -> getAuthenticator ( ) !== $ this -> getName ( ) ) { $ this -> picoAuth -> redirectToPage ( "index" ) ; return ; } $ editAccount = $ this -> picoAuth -> getContainer ( ) -> get ( 'EditAccount' ) ; $ editAccount -> setConfig ( $ this -> config ) -> handleAccountPage ( $ httpRequest ) ; }
7959	public function getPairsNumber ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> pairsNumber ; }
3870	protected function getView ( $ identifier , $ view ) { $ metaModels = $ this -> getMetaModel ( $ identifier , false ) ; return $ metaModels -> getView ( $ view ) ; }
4898	private static function checkCache ( array $ configuration ) { $ config = $ configuration [ 'module_listener_options' ] ; $ options = new ListenerOptions ( $ config ) ; $ cache = new ClearCacheService ( $ options ) ; $ cache -> checkCache ( ) ; }
968	protected function cancelCharge ( ) { $ planCharge = $ this -> shop -> planCharge ( ) ; if ( $ planCharge && ! $ planCharge -> isDeclined ( ) && ! $ planCharge -> isCancelled ( ) ) { $ planCharge -> cancel ( ) ; } }
10019	public function addCellXf ( Style $ style ) { $ this -> cellXfCollection [ ] = $ style ; $ style -> setIndex ( count ( $ this -> cellXfCollection ) - 1 ) ; }
8527	private function _convertListFinancialEventGroups ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroups' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMaxResultsPerPage ( ) ) { $ parameters [ 'MaxResultsPerPage' ] = $ request -> getMaxResultsPerPage ( ) ; } if ( $ request -> isSetFinancialEventGroupStartedAfter ( ) ) { $ parameters [ 'FinancialEventGroupStartedAfter' ] = $ request -> getFinancialEventGroupStartedAfter ( ) ; } if ( $ request -> isSetFinancialEventGroupStartedBefore ( ) ) { $ parameters [ 'FinancialEventGroupStartedBefore' ] = $ request -> getFinancialEventGroupStartedBefore ( ) ; } return $ parameters ; }
444	public function trigger ( $ name , Event $ event = null ) { $ this -> ensureBehaviors ( ) ; $ eventHandlers = [ ] ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ handlers ) ; } } if ( ! empty ( $ this -> _events [ $ name ] ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ this -> _events [ $ name ] ) ; } if ( ! empty ( $ eventHandlers ) ) { if ( $ event === null ) { $ event = new Event ( ) ; } if ( $ event -> sender === null ) { $ event -> sender = $ this ; } $ event -> handled = false ; $ event -> name = $ name ; foreach ( $ eventHandlers as $ handler ) { $ event -> data = $ handler [ 1 ] ; call_user_func ( $ handler [ 0 ] , $ event ) ; if ( $ event -> handled ) { return ; } } } Event :: trigger ( $ this , $ name , $ event ) ; }
1119	public function scopeLimitDepth ( $ query , $ limit ) { $ depth = $ this -> exists ? $ this -> getDepth ( ) : $ this -> getLevel ( ) ; $ max = $ depth + $ limit ; $ scopes = array ( $ depth , $ max ) ; return $ query -> whereBetween ( $ this -> getDepthColumnName ( ) , array ( min ( $ scopes ) , max ( $ scopes ) ) ) ; }
4893	protected function array_compare ( $ array1 , $ array2 , $ maxDepth = 2 ) { $ result = array ( ) ; $ arraykeys = array_unique ( array_merge ( array_keys ( $ array1 ) , array_keys ( $ array2 ) ) ) ; foreach ( $ arraykeys as $ key ) { if ( ! empty ( $ key ) && is_string ( $ key ) && $ key [ 0 ] != "\0" && substr ( $ key , 0 , 8 ) != 'Doctrine' ) { if ( array_key_exists ( $ key , $ array1 ) && ! array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , '' ) ; } if ( ! array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( '' , $ array2 [ $ key ] ) ; } if ( array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ subResult = null ; if ( is_array ( $ array1 [ $ key ] ) && is_array ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ subResult = $ this -> array_compare ( $ array1 [ $ key ] , $ array2 [ $ key ] , $ maxDepth - 1 ) ; } } elseif ( is_object ( $ array1 [ $ key ] ) && is_object ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ hydrator = new EntityHydrator ( ) ; $ a1 = $ hydrator -> extract ( $ array1 [ $ key ] ) ; $ a2 = $ hydrator -> extract ( $ array2 [ $ key ] ) ; $ subResult = $ this -> array_compare ( $ a1 , $ a2 , $ maxDepth - 1 ) ; } } else { if ( $ array1 [ $ key ] != $ array2 [ $ key ] ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , $ array2 [ $ key ] ) ; } } if ( ! empty ( $ subResult ) ) { foreach ( $ subResult as $ subKey => $ subValue ) { if ( ! empty ( $ subKey ) && is_string ( $ subKey ) ) { $ result [ $ key . '.' . $ subKey ] = $ subValue ; } } } } } } return $ result ; }
2237	public function generatePdf ( ) { $ this -> headline = $ this -> title ; $ this -> printable = false ; $ strArticle = $ this -> replaceInsertTags ( $ this -> generate ( ) , false ) ; $ strArticle = html_entity_decode ( $ strArticle , ENT_QUOTES , Config :: get ( 'characterSet' ) ) ; $ strArticle = $ this -> convertRelativeUrls ( $ strArticle , '' , true ) ; $ arrSearch = array ( '@<form.*</form>@Us' , '@<a [^>]*href="[^"]*javascript:[^>]+>.*</a>@Us' ) ; $ strArticle = preg_replace ( $ arrSearch , '' , $ strArticle ) ; if ( empty ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] ) ) { throw new \ Exception ( 'No PDF extension found. Did you forget to install contao/tcpdf-bundle?' ) ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strArticle , $ this ) ; } } }
5656	private function walkChildren ( $ node ) { if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ this -> walkTree ( $ child ) ; } } }
3904	public function handle ( GetOptionsEvent $ event ) { if ( ( 'tl_metamodel_dca_combine' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rows' !== $ event -> getPropertyName ( ) ) || ( 'dca_id' !== $ event -> getSubPropertyName ( ) ) ) { return ; } $ screens = $ this -> connection -> createQueryBuilder ( ) -> select ( 'id' ) -> addSelect ( 'name' ) -> from ( 'tl_metamodel_dca' ) -> where ( 'pid=:pid' ) -> setParameter ( 'pid' , $ event -> getModel ( ) -> getProperty ( 'id' ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; foreach ( $ screens as $ screen ) { $ result [ $ screen [ 'id' ] ] = $ screen [ 'name' ] ; } $ event -> setOptions ( $ result ) ; }
3087	public function validateAdaptiveAssessmentSection ( SectionPartCollection $ sectionsParts , $ ref , $ testAdminId ) { $ engine = $ this -> getEngine ( $ ref ) ; $ adaptSection = $ engine -> setupSection ( $ testAdminId ) ; if ( method_exists ( $ adaptSection , 'getItemReferences' ) ) { $ itemReferences = $ adaptSection -> getItemReferences ( ) ; $ dependencies = $ sectionsParts -> getKeys ( ) ; if ( $ catDiff = array_diff ( $ dependencies , $ itemReferences ) ) { throw new AdaptiveSectionInjectionException ( 'Missed some CAT service items: ' . implode ( ', ' , $ catDiff ) , $ catDiff ) ; } if ( $ packageDiff = array_diff ( $ dependencies , $ itemReferences ) ) { throw new AdaptiveSectionInjectionException ( 'Missed some package items: ' . implode ( ', ' , $ packageDiff ) , $ packageDiff ) ; } } }
11439	public function getErrors ( $ echoable = false ) { if ( true === $ echoable ) { return join ( "\n<br />" , $ this -> errors ) ; } else { return $ this -> errors ; } }
9909	public function setPositionXL ( $ positionXL ) { if ( ! isset ( self :: $ positionXLref [ $ positionXL ] ) ) { return false ; } $ this -> position = self :: $ positionXLref [ $ positionXL ] ; return true ; }
1437	public static function classify ( $ value ) { if ( isset ( self :: $ classified [ $ value ] ) ) { return self :: $ classified [ $ value ] ; } $ converted = ucwords ( str_replace ( [ '-' , '_' ] , ' ' , $ value ) ) ; return self :: $ classified [ $ value ] = str_replace ( ' ' , '' , $ converted ) ; }
8582	public function setAny ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Any' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3016	public function reblogPost ( $ blogName , $ postId , $ reblogKey , $ options = null ) { $ params = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; $ params = array_merge ( $ options ? : array ( ) , $ params ) ; $ path = $ this -> blogPath ( $ blogName , '/post/reblog' ) ; return $ this -> postRequest ( $ path , $ params , false ) ; }
1758	public static function getFormattedNumber ( $ varNumber , $ intDecimals = 2 ) { return number_format ( round ( $ varNumber , $ intDecimals ) , $ intDecimals , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'decimalSeparator' ] , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'thousandsSeparator' ] ) ; }
10848	protected function getTableName ( $ returnAlias = false ) { $ result = '' ; foreach ( $ this -> clause_table as $ k => $ v ) { if ( ! is_int ( $ k ) && $ returnAlias ) { return $ k ; } else { return $ v ; } } return $ result ; }
191	public function setStatusCodeByException ( $ e ) { if ( $ e instanceof HttpException ) { $ this -> setStatusCode ( $ e -> statusCode ) ; } else { $ this -> setStatusCode ( 500 ) ; } return $ this ; }
3495	public function add ( HttpProtocolVisitorInterface $ visitor , int $ priority = 0 ) : void { $ this -> visitors -> insert ( $ visitor , $ priority ) ; }
3187	public function end ( $ tags , $ timestamp ) { if ( ! is_numeric ( $ timestamp ) || $ timestamp < 0 ) { throw new InvalidDataException ( 'end() needs a valid timestamp!' ) ; } $ range = $ this -> getRange ( $ tags ) ; if ( $ this -> isRangeOpen ( $ range ) ) { $ this -> checkTimestampCoherence ( $ range , $ timestamp ) ; $ point = new TimePoint ( $ tags , $ timestamp , TimePoint :: TYPE_END , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; } else { \ common_Logger :: t ( 'Range already closed, or missing START TimePoint in QtiTimer, continue anyway' ) ; } return $ this ; }
12110	public function deletePage ( $ id ) { $ this -> getPage ( $ id ) ; unset ( $ this -> pages [ $ id ] ) ; $ this -> persist ( ) ; }
932	public function clearChanged ( ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ this -> changed = false ; }
327	public function send ( MailerInterface $ mailer = null ) { if ( $ mailer === null && $ this -> mailer === null ) { $ mailer = Yii :: $ app -> getMailer ( ) ; } elseif ( $ mailer === null ) { $ mailer = $ this -> mailer ; } return $ mailer -> send ( $ this ) ; }
9182	public function remember ( $ value , $ memoryDuration = null ) { if ( is_null ( $ memoryDuration ) ) { $ memoryDuration = $ this -> memoryDuration ; } $ key = $ this -> getRememberKey ( ) ; if ( Cache :: has ( $ key ) ) { $ value = Cache :: get ( $ key ) ; } else { $ expiresAt = Carbon :: now ( ) -> addMinutes ( $ memoryDuration ) ; if ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } Cache :: put ( $ key , $ value , $ expiresAt ) ; } return $ value ; }
10825	public static function choice ( $ question , array $ choices , $ defaultValue = null ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( ( string ) $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( count ( $ choices ) > 0 ) { foreach ( $ choices as $ index => $ choice ) { self :: write ( ' [' ) ; self :: write ( ( string ) ( $ index + 1 ) , 'comment' ) ; self :: writeln ( '] ' . $ choice ) ; } } if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( ! isset ( $ choices [ intval ( $ value ) - 1 ] ) ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] Value "' . $ value . '" is invalid' , 'error' ) ; $ value = '' ; } elseif ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
11919	public function attr ( $ keys = [ ] ) { if ( ! is_array ( $ keys ) ) { $ keys = [ $ keys ] ; } $ out = '' ; foreach ( $ keys as $ key ) { $ value = $ this -> getValue ( $ key ) -> attr ( ) ; if ( ! empty ( $ value ) ) { $ out .= ' ' . $ value ; } } return ltrim ( $ out , ' ' ) ; }
464	public function buildNotCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
2667	public function getSingleDictionary ( $ version , $ dictionaryName ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/dictionary/' . $ dictionaryName ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
3670	private function determineFragments ( Request $ request ) : ? array { if ( null === $ requestUri = $ this -> strippedUri ( $ request ) ) { return null ; } $ fragments = null ; if ( Config :: get ( 'folderUrl' ) && false !== strpos ( $ requestUri , '/' ) ) { $ fragments = $ this -> getFolderUrlFragments ( $ requestUri , $ request -> getHost ( ) , $ request -> attributes -> get ( '_locale' ) ) ; } if ( null === $ fragments ) { if ( '/' === $ requestUri ) { return null ; } $ fragments = explode ( '/' , $ requestUri ) ; } if ( Config :: get ( 'useAutoItem' ) && 0 === ( \ count ( $ fragments ) % 2 ) ) { array_insert ( $ fragments , 1 , [ 'auto_item' ] ) ; } $ fragments = $ this -> getPageIdFromUrlHook ( $ fragments ) ; if ( null === $ fragments || ( '' === $ fragments [ 0 ] && \ count ( $ fragments ) > 1 ) ) { return null ; } return $ fragments ; }
203	protected function createQuery ( $ targetClass , $ condition ) { $ query = $ targetClass :: find ( ) -> andWhere ( $ condition ) ; if ( $ this -> filter instanceof \ Closure ) { call_user_func ( $ this -> filter , $ query ) ; } elseif ( $ this -> filter !== null ) { $ query -> andWhere ( $ this -> filter ) ; } return $ query ; }
107	public function prohibitUrlByConfig ( $ url , IOInterface $ io = null ) { if ( false === filter_var ( $ url , FILTER_VALIDATE_URL ) ) { return ; } $ scheme = parse_url ( $ url , PHP_URL_SCHEME ) ; if ( in_array ( $ scheme , array ( 'http' , 'git' , 'ftp' , 'svn' ) ) ) { if ( $ this -> get ( 'secure-http' ) ) { throw new TransportException ( "Your configuration does not allow connections to $url. See https://getcomposer.org/doc/06-config.md#secure-http for details." ) ; } elseif ( $ io ) { $ host = parse_url ( $ url , PHP_URL_HOST ) ; if ( ! isset ( $ this -> warnedHosts [ $ host ] ) ) { $ io -> writeError ( "<warning>Warning: Accessing $host over $scheme which is an insecure protocol.</warning>" ) ; } $ this -> warnedHosts [ $ host ] = true ; } } }
840	public function setSize ( $ size ) { if ( $ this -> getSize ( ) !== $ size ) { $ this -> changed = true ; parent :: setSize ( $ size ) ; } }
7137	private function readNumber ( ) { if ( false === $ this -> handle = fopen ( $ this -> filePath , 'c+' ) ) { throw new RuntimeException ( "Failed to open file {$this->filePath}." ) ; } if ( ! flock ( $ this -> handle , LOCK_EX ) ) { throw new RuntimeException ( "Failed to lock file {$this->filePath}." ) ; } return fread ( $ this -> handle , $ this -> length ) ; }
9879	private function writeBookViews ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { $ objWriter -> startElement ( 'bookViews' ) ; $ objWriter -> startElement ( 'workbookView' ) ; $ objWriter -> writeAttribute ( 'activeTab' , $ spreadsheet -> getActiveSheetIndex ( ) ) ; $ objWriter -> writeAttribute ( 'autoFilterDateGrouping' , '1' ) ; $ objWriter -> writeAttribute ( 'firstSheet' , '0' ) ; $ objWriter -> writeAttribute ( 'minimized' , '0' ) ; $ objWriter -> writeAttribute ( 'showHorizontalScroll' , '1' ) ; $ objWriter -> writeAttribute ( 'showSheetTabs' , '1' ) ; $ objWriter -> writeAttribute ( 'showVerticalScroll' , '1' ) ; $ objWriter -> writeAttribute ( 'tabRatio' , '600' ) ; $ objWriter -> writeAttribute ( 'visibility' , 'visible' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
8999	public function fileExists ( $ fileName ) : bool { if ( ! $ this -> exists ( ) ) { return false ; } $ file = sprintf ( "%s/%s" , $ this -> path , $ fileName ) ; return file_exists ( $ file ) ; }
9907	public function setBlocSize ( $ size ) { if ( null !== $ this -> memory ) { throw new Exception \ RuntimeException ( 'You can not change the segment size because memory is already allocated.' . ' Use realloc() function to create new memory segment.' ) ; } $ this -> blocSize = ( integer ) $ size ; return $ this ; }
6601	protected function buildUrl ( $ url , $ params = [ ] ) { if ( $ this -> useOauth ) { $ params [ 'access_token' ] = $ this -> getAccessToken ( ) ; } $ params = http_build_query ( $ params ) ; return $ this -> baseUrl . $ url . '?' . $ params ; }
11529	public function replaceVariables ( $ string , $ replaces = [ ] ) { $ callback = function ( $ match ) use ( $ replaces ) { $ variable = trim ( $ match [ 0 ] , '{}' ) ; if ( array_key_exists ( $ variable , $ replaces ) ) { return $ replaces [ $ variable ] ; } return $ variable ; } ; return preg_replace_callback ( '/{.*?}/' , $ callback , $ string ) ; }
2052	public static function create ( $ file , $ size = null ) { if ( \ is_string ( $ file ) ) { $ file = new File ( rawurldecode ( $ file ) ) ; } $ imageSize = null ; $ picture = new static ( $ file ) ; if ( \ is_array ( $ size ) && ! empty ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ size = ( int ) $ size [ 2 ] ; } $ imageSize = null ; if ( ! \ is_array ( $ size ) ) { $ imageSize = ImageSizeModel :: findByPk ( $ size ) ; if ( $ imageSize === null ) { $ size = array ( ) ; } } if ( \ is_array ( $ size ) ) { $ size += array ( 0 , 0 , 'crop' ) ; $ imageSize = new \ stdClass ( ) ; $ imageSize -> width = $ size [ 0 ] ; $ imageSize -> height = $ size [ 1 ] ; $ imageSize -> resizeMode = $ size [ 2 ] ; $ imageSize -> zoom = 0 ; } $ picture -> setImageSize ( $ imageSize ) ; if ( $ imageSize !== null && ! empty ( $ imageSize -> id ) ) { $ picture -> setImageSizeItems ( ImageSizeItemModel :: findVisibleByPid ( $ imageSize -> id , array ( 'order' => 'sorting ASC' ) ) ) ; } $ fileRecord = FilesModel :: findByPath ( $ file -> path ) ; if ( $ fileRecord !== null && $ fileRecord -> importantPartWidth && $ fileRecord -> importantPartHeight ) { $ picture -> setImportantPart ( array ( 'x' => ( int ) $ fileRecord -> importantPartX , 'y' => ( int ) $ fileRecord -> importantPartY , 'width' => ( int ) $ fileRecord -> importantPartWidth , 'height' => ( int ) $ fileRecord -> importantPartHeight , ) ) ; } return $ picture ; }
2475	public function deleteContent ( $ contentId , $ versionId = null ) { $ idPrefix = $ this -> mapper -> generateContentDocumentId ( $ contentId ) ; $ this -> gateway -> deleteByQuery ( "_root_:{$idPrefix}*" ) ; }
754	public function run ( ) { if ( Yii :: $ app -> request -> getQueryParam ( self :: REFRESH_GET_VAR ) !== null ) { $ code = $ this -> getVerifyCode ( true ) ; Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; return [ 'hash1' => $ this -> generateValidationHash ( $ code ) , 'hash2' => $ this -> generateValidationHash ( strtolower ( $ code ) ) , 'url' => Url :: to ( [ $ this -> id , 'v' => uniqid ( '' , true ) ] ) , ] ; } $ this -> setHttpHeaders ( ) ; Yii :: $ app -> response -> format = Response :: FORMAT_RAW ; return $ this -> renderImage ( $ this -> getVerifyCode ( ) ) ; }
2552	private function getStringBetween ( $ string , $ start , $ end ) { $ startPos = strpos ( $ string , $ start ) + strlen ( $ start ) ; $ endPos = strlen ( $ string ) - strpos ( $ string , $ end ) ; return substr ( $ string , $ startPos , - $ endPos ) ; }
3527	private function fetch ( ) { $ data = FortniteClient :: sendFortnitePostRequest ( FortniteClient :: FORTNITE_API . 'game/v2/profile/' . $ this -> account_id . '/client/QueryProfile?profileId=athena&rvn=-1' , $ this -> access_token , new \ StdClass ( ) ) ; return $ data -> profileChanges [ 0 ] -> profile ; }
7728	public function quickReplies ( $ text , $ quickReplies ) { $ this -> setText ( $ text ) ; foreach ( $ quickReplies as $ quickReplie ) { $ this -> setQuickReplies ( $ quickReplie ) ; } return $ this ; }
1608	public function bulk ( $ redirects , $ separator , $ type , $ siteId ) { $ rawRedirects = array_map ( function ( $ line ) use ( $ separator ) { return str_getcsv ( $ line , $ separator ) ; } , explode ( PHP_EOL , $ redirects ) ) ; $ newFormatted = [ ] ; foreach ( $ rawRedirects as $ redirect ) { $ record = new RedirectRecord ( ) ; $ record -> uri = $ redirect [ 0 ] ; $ record -> to = $ redirect [ 1 ] ; $ record -> type = array_key_exists ( 2 , $ redirect ) ? $ redirect [ 2 ] : $ type ; $ record -> siteId = $ siteId ; $ record -> save ( ) ; $ newFormatted [ ] = [ 'id' => $ record -> id , 'uri' => $ record -> uri , 'to' => $ record -> to , 'type' => $ record -> type , 'siteId' => $ record -> siteId , ] ; } return [ $ newFormatted , false ] ; }
12050	public function initClient ( $ headers ) { try { $ this -> request = new Client ( $ headers ) ; } catch ( Exception $ e ) { echo 'Unable to initialise http client because ' . $ e -> getMessage ( ) . "\n" ; } }
4529	public function kernelRequest ( GetResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ content = $ request -> getContent ( ) ; if ( '' === $ content ) { return ; } try { $ filters = json_decode ( $ content , true ) ; } catch ( Exception $ exception ) { throw new BadRequestHttpException ( 'Request body should be an object.' , $ exception ) ; } if ( ! is_array ( $ filters ) ) { throw new BadRequestHttpException ( 'Request body should be an object.' ) ; } $ current = $ request -> attributes -> get ( '_api_filters' , [ ] ) ; $ query = $ request -> query -> all ( ) ; $ filters = array_merge ( $ current , $ query , $ filters ) ; $ request -> attributes -> set ( '_api_filters' , $ filters ) ; }
8285	protected function sessionTimeoutCheck ( $ configKey , $ sessKey , $ clear , $ alwaysUpdate = false ) { if ( $ this -> config [ $ configKey ] !== false ) { $ t = time ( ) ; if ( $ this -> session -> has ( $ sessKey ) ) { if ( $ this -> session -> get ( $ sessKey ) < $ t - $ this -> config [ $ configKey ] ) { if ( $ clear ) { $ this -> session -> invalidate ( ) ; } else { $ this -> session -> migrate ( true ) ; } $ this -> session -> set ( $ sessKey , $ t ) ; } elseif ( $ alwaysUpdate ) { $ this -> session -> set ( $ sessKey , $ t ) ; } } else { $ this -> session -> set ( $ sessKey , $ t ) ; } } }
7237	protected function fixInvoiceDefault ( CustomerAddressInterface $ address ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ address , [ 'invoiceDefault' ] ) ) { return ; } $ customer = $ address -> getCustomer ( ) ; if ( $ address -> isInvoiceDefault ( ) ) { foreach ( $ customer -> getAddresses ( ) as $ a ) { if ( $ a === $ address ) { continue ; } if ( $ a -> isInvoiceDefault ( ) ) { $ a -> setInvoiceDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ a , false ) ; } } } elseif ( null === $ customer -> getDefaultInvoiceAddress ( true ) ) { $ address -> setInvoiceDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } }
12162	public function getForm ( $ primaryModel = false , $ settings = [ ] ) { if ( ! $ primaryModel ) { return false ; } $ formSegments = [ $ this -> getFormSegment ( $ primaryModel , $ settings ) ] ; $ config = [ 'class' => $ this -> formGeneratorClass , 'models' => $ primaryModel -> collectModels ( ) , 'items' => $ formSegments ] ; return Yii :: createObject ( $ config ) ; }
2015	public static function load ( $ class ) { if ( class_exists ( $ class , false ) || interface_exists ( $ class , false ) || trait_exists ( $ class , false ) ) { return ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ classes [ $ class ] ) ) { if ( Config :: get ( 'debugMode' ) ) { $ GLOBALS [ 'TL_DEBUG' ] [ 'classes_set' ] [ $ class ] = $ class ; } include $ rootDir . '/' . self :: $ classes [ $ class ] ; } elseif ( ( $ namespaced = self :: findClass ( $ class ) ) !== null ) { if ( ! class_exists ( $ namespaced , false ) && ! interface_exists ( $ namespaced , false ) && ! trait_exists ( $ namespaced , false ) ) { if ( Config :: get ( 'debugMode' ) ) { $ GLOBALS [ 'TL_DEBUG' ] [ 'classes_aliased' ] [ $ class ] = $ namespaced ; } include $ rootDir . '/' . self :: $ classes [ $ namespaced ] ; } class_alias ( $ namespaced , $ class ) ; } elseif ( strncmp ( $ class , 'Contao\\' , 7 ) !== 0 ) { $ namespaced = 'Contao\\' . $ class ; if ( class_exists ( $ namespaced ) || interface_exists ( $ namespaced ) || trait_exists ( $ namespaced ) ) { if ( Config :: get ( 'debugMode' ) ) { $ GLOBALS [ 'TL_DEBUG' ] [ 'classes_composerized' ] [ $ class ] = $ namespaced ; } if ( ! class_exists ( $ class , false ) && ! interface_exists ( $ class , false ) && ! trait_exists ( $ class , false ) ) { class_alias ( $ namespaced , $ class ) ; } } } }
9899	private function convertError ( $ errorCode ) { switch ( $ errorCode ) { case '#NULL!' : return pack ( 'C' , 0x00 ) ; case '#DIV/0!' : return pack ( 'C' , 0x07 ) ; case '#VALUE!' : return pack ( 'C' , 0x0F ) ; case '#REF!' : return pack ( 'C' , 0x17 ) ; case '#NAME?' : return pack ( 'C' , 0x1D ) ; case '#NUM!' : return pack ( 'C' , 0x24 ) ; case '#N/A' : return pack ( 'C' , 0x2A ) ; } return pack ( 'C' , 0xFF ) ; }
5381	public function getValue ( ) { if ( $ this -> choice === false ) { return $ this -> getDefault ( ) ; } return $ this -> options [ $ this -> choice ] -> getValue ( ) ; }
7375	public function clear ( ) { while ( ! $ this -> queue -> isEmpty ( ) ) { $ this -> queue -> pop ( ) ; } $ this -> queue = null ; }
8982	private function filter ( $ configurations , array $ criteria ) { $ result = array ( ) ; foreach ( $ configurations as $ configuration ) { if ( ConfigurationFilterUtil :: matches ( $ configuration , $ criteria ) ) { $ result [ ] = $ configuration ; } } return $ result ; }
4060	public static function compare ( $ expected , $ actual , $ strict = true ) { try { self :: calculateDiff ( $ expected , $ actual , $ strict ) ; } catch ( \ Exception $ exception ) { $ instance = new DifferentValuesException ( $ expected , $ actual , $ strict , 'The values differ.' , 0 , $ exception ) ; throw $ instance ; } }
4186	public function search ( ) { $ url = self :: PACKAGIST_URL . 'search.json?q=' . $ this -> getPackageName ( ) ; $ response = $ this -> client -> get ( $ url ) -> getBody ( ) -> getContents ( ) ; $ this -> rawPackages = collect ( json_decode ( $ response , true ) ) ; return collect ( $ this -> rawPackages -> get ( 'results' ) ) ; }
4533	public function getList ( $ task , Parameters $ parameters = null ) { $ resource = str_replace ( '{id}' , $ task , static :: VARIABLE_LIST ) ; $ options = [ 'headers' => [ 'Accept' => 'application/json' ] , 'query' => ( array ) $ parameters -> toObject ( true ) ] ; $ objects = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ list = [ ] ; foreach ( $ objects as $ name => $ object ) { $ object -> name = $ name ; $ model = static :: toModel ( $ object ) ; $ list [ $ name ] = $ model ; } return $ list ; }
4716	public function on ( $ event , callable $ callback , $ priority = 10 ) { if ( ! isset ( $ this -> callbacks [ $ event ] ) ) { $ this -> callbacks [ $ event ] = [ true , [ ] ] ; } $ this -> callbacks [ $ event ] [ 0 ] = false ; $ this -> callbacks [ $ event ] [ 1 ] [ ] = array ( $ priority , $ callback ) ; return $ this ; }
12143	public static function user ( ) { if ( ! static :: $ user and static :: $ factory ) { $ id = static :: provider ( ) -> get ( 'id' ) ; static :: $ user = call_user_func ( static :: $ factory , $ id ) ; } return static :: $ user ; }
7761	protected function validateMappingConfiguration ( array $ mappingConfig , $ mappingName ) { if ( ! $ mappingConfig [ 'type' ] || ! $ mappingConfig [ 'dir' ] || ! $ mappingConfig [ 'prefix' ] ) { throw new \ InvalidArgumentException ( sprintf ( 'Hydra mapping definitions for "%s" require at least the "type", "dir" and "prefix" options.' , $ mappingName ) ) ; } if ( ! is_dir ( $ mappingConfig [ 'dir' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Specified non-existing directory "%s" as Hydra mapping source.' , $ mappingConfig [ 'dir' ] ) ) ; } if ( ! in_array ( $ mappingConfig [ 'type' ] , array ( 'xml' , 'yml' , 'annotation' , 'php' , 'staticphp' ) ) ) { throw new \ InvalidArgumentException ( 'Can only configure "xml", "yml", "annotation", "php" or ' . '"staticphp" through the HydraBundle. Use your own bundle to configure other metadata drivers. ' . 'You can register them by adding a new driver to the ' . '"hydra.metadata_driver" service definition.' ) ; } }
7483	public function startsWith ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; return $ string === $ this -> substring ( 0 , ( mb_strlen ( $ string , $ this -> encoding ) - 1 ) ) -> __toString ( ) ; }
7058	protected function getStockAdjustmentFromEvent ( ResourceEventInterface $ event ) { $ stockAdjustment = $ event -> getResource ( ) ; if ( ! $ stockAdjustment instanceof StockAdjustmentInterface ) { throw new InvalidArgumentException ( "Expected instance of " . StockAdjustmentInterface :: class ) ; } return $ stockAdjustment ; }
5235	public function withEntryFromProvider ( $ key , $ provider ) { $ this -> bindings [ $ key ] = $ this -> getProviderCreator ( $ provider ) ; return $ this ; }
7589	protected function configureType ( ) { switch ( $ this -> type ) { case 'POST' : $ this -> setOption ( CURLOPT_POST , true ) ; break ; case 'DELETE' : case 'PUT' : $ this -> setOption ( CURLOPT_CUSTOMREQUEST , $ this -> type ) ; break ; } }
9274	public function getServiceConfig ( ) { return array ( 'factories' => array ( 'CronHelper\Service\CronService' => function ( $ serviceManager ) { $ mainConfig = $ serviceManager -> get ( 'config' ) ; $ serviceConfig = array ( ) ; if ( is_array ( $ mainConfig ) ) { if ( array_key_exists ( 'cron_helper' , $ mainConfig ) ) { $ serviceConfig = $ mainConfig [ 'cron_helper' ] ; } } $ cronService = new CronService ( $ serviceConfig ) ; return $ cronService ; } , ) , ) ; }
11845	private function getRandomAddress ( ) { return ( new Address ( ) ) -> setStreetAddress1 ( $ this -> faker -> streetAddress ) -> setStreetAddress2 ( rand ( 0 , 9 ) > 5 ? $ this -> faker -> streetAddress : '' ) -> setPostcode ( $ this -> getReference ( LoadPostalCodes :: $ refs [ array_rand ( LoadPostalCodes :: $ refs ) ] ) ) -> setValidFrom ( $ this -> faker -> dateTimeBetween ( '-5 years' ) ) ; }
1574	public function defaultApi ( $ apiName = null ) { if ( is_null ( $ apiName ) ) { return LaravelJsonApi :: $ defaultApi ; } LaravelJsonApi :: defaultApi ( $ apiName ) ; return $ apiName ; }
5760	public function getObjects ( array $ whereColumnsInfo = null , string $ orderBy = null ) : array { $ permissions = [ ] ; foreach ( $ this -> selectArray ( null , $ whereColumnsInfo , $ orderBy ) as $ permissionArray ) { $ permissions [ ] = $ this -> buildPermission ( $ permissionArray [ 'id' ] , $ permissionArray [ 'title' ] , $ permissionArray [ 'description' ] , $ permissionArray [ 'active' ] , $ permissionArray [ 'created' ] , $ permissionArray [ 'roles' ] ) ; } return $ permissions ; }
118	protected function getCredentialString ( ) { if ( ! $ this -> hasAuth ( ) ) { return '' ; } return sprintf ( ' %s--username %s --password %s ' , $ this -> getAuthCache ( ) , ProcessExecutor :: escape ( $ this -> getUsername ( ) ) , ProcessExecutor :: escape ( $ this -> getPassword ( ) ) ) ; }
4316	private function getDefaultServices ( ) { return array ( 'abstracter' => function ( Debug $ debug ) { return new Debug \ Abstracter ( $ debug , $ debug -> config -> getCfgLazy ( 'abstracter' ) ) ; } , 'config' => function ( Debug $ debug ) { return new Debug \ Config ( $ debug , $ debug -> cfg ) ; } , 'errorEmailer' => function ( Debug $ debug ) { return new ErrorEmailer ( $ debug -> config -> getCfgLazy ( 'errorEmailer' ) ) ; } , 'errorHandler' => function ( Debug $ debug ) { if ( ErrorHandler :: getInstance ( ) ) { return ErrorHandler :: getInstance ( ) ; } else { $ errorHandler = new ErrorHandler ( $ debug -> eventManager ) ; $ errorHandler -> setCfg ( 'onEUserError' , 'log' ) ; return $ errorHandler ; } } , 'eventManager' => function ( ) { return new EventManager ( ) ; } , 'internal' => function ( Debug $ debug ) { return new Debug \ Internal ( $ debug ) ; } , 'logger' => function ( Debug $ debug ) { return new Debug \ Logger ( $ debug ) ; } , 'methodClear' => function ( Debug $ debug ) { return new Debug \ MethodClear ( $ debug , $ debug -> data ) ; } , 'methodTable' => function ( ) { return new Debug \ MethodTable ( ) ; } , 'output' => function ( Debug $ debug ) { $ output = new Debug \ Output ( $ debug , $ debug -> config -> getCfgLazy ( 'output' ) ) ; $ debug -> eventManager -> addSubscriberInterface ( $ output ) ; return $ output ; } , 'utf8' => function ( ) { return new Debug \ Utf8 ( ) ; } , 'utilities' => function ( ) { return new Debug \ Utilities ( ) ; } , ) ; }
11425	public function remark ( $ openId , $ remark ) { $ params = [ 'openid' => $ openId , 'remark' => $ remark , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_REMARK , $ params ] ) ; }
6283	protected static function buildHttpClient04 ( LoopInterface $ loop , $ dns = null ) { if ( null === $ dns ) { $ dns = static :: buildDnsResolver ( $ loop ) ; } if ( ! $ dns instanceof DnsResolver ) { throw new \ InvalidArgumentException ( 'For react http client v0.4, $dns must be an instance of DnsResolver' ) ; } $ factory = new HttpClientFactory ( ) ; return $ factory -> create ( $ loop , $ dns ) ; }
5724	protected function getToplevelController ( ) { $ c = $ this -> owner -> getController ( ) ; while ( $ c && $ c instanceof GridFieldDetailForm_ItemRequest ) { $ c = $ c -> getController ( ) ; } return $ c ; }
11456	public function batchDeviceSummary ( $ timestamp , $ pageIndex ) { $ params = [ 'date' => $ timestamp , 'page_index' => $ pageIndex , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_LIST , $ params ] ) ; }
2296	public static function addToUrl ( $ strRequest , $ blnAddRef = true , $ arrUnset = array ( ) ) { $ arrUnset [ ] = 'nb' ; return parent :: addToUrl ( $ strRequest . ( ( $ strRequest != '' ) ? '&amp;' : '' ) . 'rt=' . REQUEST_TOKEN , $ blnAddRef , $ arrUnset ) ; }
4729	public function isSingular ( $ word ) { $ inflection = $ this -> getCachedPlural ( $ word ) ; if ( $ inflection !== false ) { return true ; } $ pluralWord = $ this -> toPlural ( $ word ) ; if ( $ pluralWord === false ) { return false ; } return $ this -> toSingular ( $ pluralWord ) == $ word ; }
347	public static function removeCssClass ( & $ options , $ class ) { if ( isset ( $ options [ 'class' ] ) ) { if ( is_array ( $ options [ 'class' ] ) ) { $ classes = array_diff ( $ options [ 'class' ] , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = $ classes ; } } else { $ classes = preg_split ( '/\s+/' , $ options [ 'class' ] , - 1 , PREG_SPLIT_NO_EMPTY ) ; $ classes = array_diff ( $ classes , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = implode ( ' ' , $ classes ) ; } } } }
318	public function registerCssFile ( $ url , $ options = [ ] , $ key = null ) { $ url = Yii :: getAlias ( $ url ) ; $ key = $ key ? : $ url ; $ depends = ArrayHelper :: remove ( $ options , 'depends' , [ ] ) ; if ( empty ( $ depends ) ) { $ this -> cssFiles [ $ key ] = Html :: cssFile ( $ url , $ options ) ; } else { $ this -> getAssetManager ( ) -> bundles [ $ key ] = Yii :: createObject ( [ 'class' => AssetBundle :: className ( ) , 'baseUrl' => '' , 'css' => [ strncmp ( $ url , '//' , 2 ) === 0 ? $ url : ltrim ( $ url , '/' ) ] , 'cssOptions' => $ options , 'depends' => ( array ) $ depends , ] ) ; $ this -> registerAssetBundle ( $ key ) ; } }
2897	public function replaceProfiler ( ) { $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ currentProfile = $ connection -> getProfiler ( ) ; if ( $ currentProfile ) { $ this -> _queryProfiles = $ currentProfile -> _queryProfiles ; } $ this -> setEnabled ( $ currentProfile -> getEnabled ( ) ) ; $ connection -> setProfiler ( $ this ) ; }
4651	public function clean ( $ projectPath , $ keep = 1 , $ force = false ) { $ builds = $ this -> getJobsToRemove ( $ projectPath , $ keep ) ; $ this -> cleanDirectories ( $ builds ) ; $ this -> cleanContainers ( $ builds ) ; $ this -> cleanImages ( $ builds , $ force ) ; }
553	public function actionFlushSchema ( $ db = 'db' ) { $ connection = Yii :: $ app -> get ( $ db , false ) ; if ( $ connection === null ) { $ this -> stdout ( "Unknown component \"$db\".\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } if ( ! $ connection instanceof \ yii \ db \ Connection ) { $ this -> stdout ( "\"$db\" component doesn't inherit \\yii\\db\\Connection.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } elseif ( ! $ this -> confirm ( "Flush cache schema for \"$db\" connection?" ) ) { return ExitCode :: OK ; } try { $ schema = $ connection -> getSchema ( ) ; $ schema -> refresh ( ) ; $ this -> stdout ( "Schema cache for component \"$db\", was flushed.\n\n" , Console :: FG_GREEN ) ; } catch ( \ Exception $ e ) { $ this -> stdout ( $ e -> getMessage ( ) . "\n\n" , Console :: FG_RED ) ; } }
277	public function notifyNothingToUnload ( $ foundFixtures , $ except ) { $ this -> stdout ( "Fixtures to unload could not be found according to given conditions:\n\n" , Console :: FG_RED ) ; $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n" , Console :: FG_GREEN ) ; if ( count ( $ foundFixtures ) ) { $ this -> stdout ( "\nFixtures found under the namespace:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ foundFixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be unloaded: \n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } }
3564	public function castToString ( ) { if ( $ this -> attributes [ 'meta_type' ] == 'array' ) { return $ this -> attributes [ 'meta_value' ] ; } $ value = $ this -> getValue ( ) ; if ( $ this -> isStringable ( $ value ) || is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) { return ( string ) $ value ; } return '' ; }
835	protected function find ( $ functionNameToSearch , Tokens $ tokens , $ start = 0 , $ end = null ) { $ end = null === $ end ? $ tokens -> count ( ) : $ end ; $ candidateSequence = [ [ T_STRING , $ functionNameToSearch ] , '(' ] ; $ matches = $ tokens -> findSequence ( $ candidateSequence , $ start , $ end , false ) ; if ( null === $ matches ) { return null ; } list ( $ functionName , $ openParenthesis ) = array_keys ( $ matches ) ; $ functionsAnalyzer = new FunctionsAnalyzer ( ) ; if ( ! $ functionsAnalyzer -> isGlobalFunctionCall ( $ tokens , $ functionName ) ) { return $ this -> find ( $ functionNameToSearch , $ tokens , $ openParenthesis , $ end ) ; } return [ $ functionName , $ openParenthesis , $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ openParenthesis ) ] ; }
1196	protected function renderHtmlAttribute ( $ name , $ value ) { if ( true === $ value ) { return sprintf ( '%s="%s"' , $ name , $ this -> escape ( $ name ) ) ; } return sprintf ( '%s="%s"' , $ name , $ this -> escape ( $ value ) ) ; }
9688	public function det ( ) { if ( $ this -> m == $ this -> n ) { $ d = $ this -> pivsign ; for ( $ j = 0 ; $ j < $ this -> n ; ++ $ j ) { $ d *= $ this -> LU [ $ j ] [ $ j ] ; } return $ d ; } throw new CalculationException ( Matrix :: MATRIX_DIMENSION_EXCEPTION ) ; }
1792	private function addHostToContext ( RequestContext $ context , array $ parameters , int & $ referenceType ) : void { [ $ host , $ port ] = $ this -> getHostAndPort ( $ parameters [ '_domain' ] ) ; if ( $ context -> getHost ( ) === $ host ) { return ; } $ context -> setHost ( $ host ) ; $ referenceType = UrlGeneratorInterface :: ABSOLUTE_URL ; if ( ! $ port ) { return ; } if ( isset ( $ parameters [ '_ssl' ] ) && true === $ parameters [ '_ssl' ] ) { $ context -> setHttpsPort ( $ port ) ; } else { $ context -> setHttpPort ( $ port ) ; } }
980	public function api ( ) { if ( ! $ this -> api ) { $ shopDomain = $ this -> shopify_domain ; $ token = $ this -> session ( ) -> getToken ( ) ; $ this -> api = ShopifyApp :: api ( ) ; $ this -> api -> setSession ( $ shopDomain , $ token ) ; } return $ this -> api ; }
5826	public function setJson ( $ toggle ) { $ this -> setEncoding ( $ toggle ? Request :: ENCODING_JSON : Request :: ENCODING_QUERY ) ; return $ this ; }
7750	public function getMetadataFor ( $ className ) { if ( isset ( $ this -> loadedMetadata [ $ className ] ) ) { return $ this -> loadedMetadata [ $ className ] ; } $ realClassName = ClassUtils :: getRealClass ( $ className ) ; if ( isset ( $ this -> loadedMetadata [ $ realClassName ] ) ) { $ this -> loadedMetadata [ $ className ] = $ this -> loadedMetadata [ $ realClassName ] ; return $ this -> loadedMetadata [ $ realClassName ] ; } if ( $ this -> cacheDriver ) { if ( ( $ cached = $ this -> cacheDriver -> fetch ( $ realClassName . $ this -> cacheSalt ) ) !== false ) { $ this -> loadedMetadata [ $ realClassName ] = $ cached ; } else { $ this -> cacheDriver -> save ( $ realClassName . $ this -> cacheSalt , $ this -> loadMetadata ( $ realClassName ) , null ) ; } } else { $ this -> loadMetadata ( $ realClassName ) ; } if ( $ className != $ realClassName ) { $ this -> loadedMetadata [ $ className ] = $ this -> loadedMetadata [ $ realClassName ] ; } return $ this -> loadedMetadata [ $ className ] ; }
1778	public static function optionChecked ( $ strOption , $ varValues ) { if ( $ strOption === '' ) { return '' ; } return ( \ is_array ( $ varValues ) ? \ in_array ( $ strOption , $ varValues ) : $ strOption == $ varValues ) ? ' checked' : '' ; }
7003	public function match ( $ test ) { $ isArray = [ ] ; $ pattern = preg_replace_callback ( "~/\{(?<arg>\w+)(?<arr>\[\])?\}(?<num>\?|\+|\*|\{[0-9,]+\})?~" , function ( $ matches ) use ( & $ isArray ) { $ name = $ matches [ "arg" ] ; $ num = $ matches [ "num" ] ?? "" ; $ isArray [ $ name ] = ! empty ( $ matches [ 2 ] ) ; return "(?<$name>(?:/[^\\s/?]+)$num)" ; } , $ this -> url ) ; if ( ! $ pattern || empty ( $ pattern ) ) { error_log ( "pattern error: found in route with pattern: {$this->url}" ) ; return false ; } $ pattern = "^$pattern/?(?:\?.*)?$" ; if ( preg_match ( "~$pattern~" , $ test , $ matches ) ) { foreach ( $ matches as $ name => $ val ) { $ val = urldecode ( $ val ) ; if ( is_int ( $ name ) ) { if ( $ name === 0 ) $ this -> args [ $ name ] = $ val ; } else { $ val = ltrim ( $ val , "/" ) ; $ this -> args [ $ name ] = $ isArray [ $ name ] ? explode ( "/" , $ val ) : $ val ; } } return true ; } return false ; }
6128	protected function getCorpusClass ( ) { $ extras = "" ; if ( $ this -> currObj instanceof Channel && $ this -> currObj -> isSpacer ( ) ) { switch ( $ this -> currObj -> spacerGetType ( ) ) { case ( string ) TeamSpeak3 :: SPACER_SOLIDLINE : $ extras .= " solidline" ; break ; case ( string ) TeamSpeak3 :: SPACER_DASHLINE : $ extras .= " dashline" ; break ; case ( string ) TeamSpeak3 :: SPACER_DASHDOTLINE : $ extras .= " dashdotline" ; break ; case ( string ) TeamSpeak3 :: SPACER_DASHDOTDOTLINE : $ extras .= " dashdotdotline" ; break ; case ( string ) TeamSpeak3 :: SPACER_DOTLINE : $ extras .= " dotline" ; break ; } switch ( $ this -> currObj -> spacerGetAlign ( ) ) { case TeamSpeak3 :: SPACER_ALIGN_CENTER : $ extras .= " center" ; break ; case TeamSpeak3 :: SPACER_ALIGN_RIGHT : $ extras .= " right" ; break ; case TeamSpeak3 :: SPACER_ALIGN_LEFT : $ extras .= " left" ; break ; } } return "corpus " . $ this -> currObj -> getClass ( null ) . $ extras ; }
8960	public function sendRequest ( $ path , $ method = 'GET' , $ headers = array ( ) , $ data = '' ) { switch ( $ method ) { case 'GET' : $ response = $ this -> client -> get ( $ path , $ headers ) ; break ; case 'POST' : $ response = $ this -> client -> post ( $ path , $ data , $ headers ) ; break ; } if ( $ response -> code != 200 ) { $ error = htmlspecialchars ( $ response -> body ) ; throw new \ DomainException ( $ error , $ response -> code ) ; } return simplexml_load_string ( $ response -> body ) ; }
11202	public function toArray ( ) { $ collection = $ this -> getIterator ( ) ; $ plainArray = [ ] ; foreach ( $ collection as $ prop => $ result ) { if ( is_object ( $ result ) && method_exists ( $ result , 'toArray' ) ) { $ plainArray [ ] = $ result -> toArray ( ) ; } else { $ plainArray [ ] = $ result ; } } return $ plainArray ; }
3170	protected function hasItemHrefIndexFile ( QtiRunnerServiceContext $ context , $ itemIdentifier ) { if ( $ context -> isAdaptive ( ) ) { return true ; } else { $ indexFile = $ this -> getItemHrefIndexFile ( $ context , $ itemIdentifier ) ; return $ indexFile -> exists ( ) ; } }
9187	public static function embedCampaigns ( $ html , $ campaign = [ ] , $ additionalCampaigns = [ ] ) { $ pattern = '/<a(\s[^>]*)href="([^"]*)"([^>]*)>/si' ; $ html = preg_replace_callback ( $ pattern , function ( $ matches ) use ( $ campaign , $ additionalCampaigns ) { $ href = GoogleCampaignPlugin :: replaceLink ( $ matches [ 2 ] , $ campaign , $ additionalCampaigns ) ; return "<a{$matches[1]}href=\"{$href}\"{$matches[3]}>" ; } , $ html ) ; return $ html ; }
9727	public function logRead ( $ format , $ path , $ callStartTime ) { $ callEndTime = microtime ( true ) ; $ callTime = $ callEndTime - $ callStartTime ; $ message = "Read {$format} format from <code>{$path}</code> in " . sprintf ( '%.4f' , $ callTime ) . ' seconds' ; $ this -> log ( $ message ) ; }
5627	public function asString ( ) { $ path = $ this -> path ; $ scheme = $ identity = $ host = $ port = $ encoded = $ fragment = '' ; if ( $ this -> username && $ this -> password ) { $ identity = $ this -> username . ':' . $ this -> password . '@' ; } if ( $ this -> getHost ( ) ) { $ scheme = $ this -> getScheme ( ) ? $ this -> getScheme ( ) : 'http' ; $ scheme .= '://' ; $ host = $ this -> getHost ( ) ; } elseif ( $ this -> getScheme ( ) === 'file' ) { $ scheme = 'file://' ; } if ( $ this -> getPort ( ) && $ this -> getPort ( ) != 80 ) { $ port = ':' . $ this -> getPort ( ) ; } if ( substr ( $ this -> path , 0 , 1 ) == '/' ) { $ path = $ this -> normalisePath ( $ this -> path ) ; } $ encoded = $ this -> getEncodedRequest ( ) ; $ fragment = $ this -> getFragment ( ) ? '#' . $ this -> getFragment ( ) : '' ; $ coords = $ this -> getX ( ) === false ? '' : '?' . $ this -> getX ( ) . ',' . $ this -> getY ( ) ; return "$scheme$identity$host$port$path$encoded$fragment$coords" ; }
7486	public function indexOf ( $ string , $ offset = null ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ offset = $ offset !== null ? ( int ) $ offset : null ; if ( $ offset !== null && ( $ offset < 0 || $ offset >= $ this -> length ( ) ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_strpos ( $ this -> string , $ string , $ offset , $ this -> encoding ) ; }
4704	public function get ( $ name ) { if ( ! $ this -> exists ( $ name ) ) { throw new \ OutOfBoundsException ( sprintf ( 'Undefined offset "%s"' , $ name ) ) ; } return $ this -> objects [ ( string ) $ name ] ; }
4629	protected function prepareRequestParameters ( ) { if ( $ this -> command -> hasParameters ( ) ) { $ this -> query = http_build_query ( $ this -> command -> getParameters ( ) , '' , '&' , PHP_QUERY_RFC3986 ) ; } return $ this ; }
691	protected function isActive ( $ action ) { $ id = $ this -> getActionId ( $ action ) ; if ( empty ( $ this -> only ) ) { $ onlyMatch = true ; } else { $ onlyMatch = false ; foreach ( $ this -> only as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { $ onlyMatch = true ; break ; } } } $ exceptMatch = false ; foreach ( $ this -> except as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { $ exceptMatch = true ; break ; } } return ! $ exceptMatch && $ onlyMatch ; }
4061	public function getLongMessage ( $ glue = ' ' ) { $ messages = array ( ) ; $ exception = $ this ; do { $ messages [ ] = $ exception -> getMessage ( ) ; } while ( null !== ( $ exception = $ exception -> getPrevious ( ) ) ) ; return implode ( $ glue , $ messages ) ; }
10202	public function setHorizontal ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: HORIZONTAL_GENERAL ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'horizontal' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> horizontal = $ pValue ; } return $ this ; }
10690	public static function handleException ( \ Throwable $ e ) { $ app = self :: getInstance ( ) ; if ( $ app -> request === null ) $ app -> request = Request :: createFromGlobals ( ) ; $ req = $ app -> request ; try { if ( ! Request :: cli ( ) ) { $ mgr = $ app -> resolver ; $ res = $ mgr -> getResolver ( 'template' ) ; $ assets = $ mgr -> getResolver ( 'assets' ) ; $ amgr = new AssetManager ( $ assets ) ; $ tpl = new Template ( $ res , $ amgr , $ req ) ; $ tpl -> setExceptionTemplate ( $ e ) ; $ tpl -> assign ( 'exception' , $ e ) ; $ tpl -> assign ( 'request' , $ req ) ; $ tpl -> assign ( 'dev' , $ app -> dev ) ; $ app -> i18n ; $ response = $ tpl -> renderReturn ( ) ; $ responder = new \ Wedeto \ HTTP \ Responder ( ) ; $ result = new \ Wedeto \ HTTP \ Result ( ) ; $ result -> setResponse ( $ response ) ; $ responder -> setRequest ( $ req ) ; $ responder -> setResult ( $ result ) ; $ params = new Dictionary ( [ 'responder' => $ responder , 'mime' => 'text/html' ] ) ; $ amgr -> executeHook ( $ params ) ; $ responder -> respond ( ) ; } } catch ( \ Throwable $ e2 ) { echo "<h1>Error while showing error template:</h1>\n\n" ; echo "<pre>" . WF :: html ( $ e2 ) . "</pre>\n" ; } if ( Request :: cli ( ) ) { fprintf ( STDERR , \ Wedeto \ Application \ CLI \ ANSI :: bright ( "An uncaught exception has occurred:" ) . "\n\n" ) ; WF :: debug ( WF :: str ( $ e ) ) ; } else { echo "<h2>Original error:</h2>\n\n" ; echo "<pre>" . WF :: html ( $ e ) . "</pre>\n" ; } }
4538	public function setTenantId ( ? string $ tenantId ) { $ this -> tenantId = $ tenantId ; $ this -> _tenantId = null !== $ tenantId ; return $ this ; }
2525	public function getConsumerId ( $ generate = false ) { if ( is_null ( $ this -> consumerId ) && $ generate ) { $ this -> consumerId = $ this -> generateGuid ( ) ; } return $ this -> consumerId ; }
9189	public function present ( ) { $ presenterClass = $ this -> getPresenterClass ( ) ; if ( ! class_exists ( $ presenterClass ) ) { throw new Exceptions \ PresenterException ( 'The specified presenter does not exist.' ) ; } if ( ! $ this -> presenterInstance ) { $ this -> presenterInstance = new $ presenterClass ( $ this ) ; } return $ this -> presenterInstance ; }
1766	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_GET ) ) { return ; } $ response = $ event -> getResponse ( ) ; if ( 200 !== $ response -> getStatusCode ( ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ this -> storeBackendReferer ( $ request ) ; } else { $ this -> storeFrontendReferer ( $ request ) ; } }
9729	function toDateTime ( ) { return $ this -> date . " " . str_pad ( $ this -> hours , 2 , '0' , STR_PAD_LEFT ) . ":" . str_pad ( $ this -> minutes , 2 , '0' , STR_PAD_LEFT ) ; }
9333	public function scaffoldFormField ( $ title = null , $ params = null ) { return FontIconField :: create ( $ this -> name , $ title ) ; }
12492	public static function orderBy ( $ field , $ order ) { if ( ! $ order ) { $ order = 'DESC' ; } $ order = strtoupper ( $ order ) ; if ( ! ( $ order == 'ASC' || $ order == 'DESC' ) ) { throw new ClusterpointException ( "\"->order()\" function: ordering should be DESC or ASC." , 9002 ) ; } if ( ! ( gettype ( $ field ) == "string" || $ field instanceof Key || $ field instanceof Raw ) ) { throw new ClusterpointException ( "\"->order()\" function: passed field selector is not in valid format." , 9002 ) ; } if ( $ field instanceof Key ) { $ field = self :: field ( "{$field}" ) ; } return "{$field} {$order}" ; }
4854	protected function profiling ( $ signal = true ) { static $ timeStart ; if ( $ signal ) { $ timeStart = microtime ( true ) ; } if ( ! $ signal ) { $ this -> timeExecution = ( microtime ( true ) - $ timeStart ) / 60 ; return $ this -> timeExecution ; } }
5154	public function configure ( ) { $ configuration = $ this -> getConfiguration ( ) ; if ( $ configuration instanceof ConfigurationInterface ) { $ this -> configuration -> configure ( $ this ) ; } }
8865	public function run ( PayloadInterface $ payload ) { $ tasks = $ this -> getTaskCollection ( ) -> getTasks ( ) ; $ tasksCount = $ tasks -> count ( ) ; if ( 0 === $ tasksCount ) { throw new LogicException ( 'Can\'t invoke task run. Empty task collection set.' ) ; } $ this -> log ( LogLevel :: INFO , sprintf ( 'Starting runner with %s tasks ready for execution.' , $ tasksCount ) ) ; $ this -> dispatch ( 'runner.start' , null , $ payload ) ; foreach ( $ tasks as $ task ) { try { $ task -> setPayload ( $ payload ) ; $ this -> runTask ( $ task , $ payload ) ; } catch ( \ Exception $ e ) { $ this -> logTask ( $ task , LogLevel :: ERROR , sprintf ( 'An exception was thrown. Message: %s' , $ e -> getMessage ( ) ) ) ; $ this -> dispatch ( 'runner.failure' , null , null , null , $ e ) ; throw new RunFailedException ( 'Complete run failed: ' . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } } $ this -> log ( LogLevel :: INFO , 'All tasks were processed.' ) ; $ this -> log ( LogLevel :: INFO , 'Calling attached runners.' ) ; $ this -> notify ( $ payload ) ; $ this -> log ( LogLevel :: INFO , 'Execution successful.' ) ; $ this -> dispatch ( 'runner.success' , null , $ payload ) ; return $ payload ; }
8411	public function disconnect ( ) { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { unset ( $ this -> servers [ 'all' ] [ 'link' ] ) ; } else { unset ( $ this -> servers [ 'read' ] [ 'link' ] ) ; unset ( $ this -> servers [ 'write' ] [ 'link' ] ) ; } }
8942	public function queryChangeset ( $ param ) { $ base = 'changesets/' . $ param ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xmlString = $ this -> sendRequest ( $ path ) ; return $ xmlString -> osm ; }
12712	public function getResolvedConcreteFlag ( $ abstract ) { if ( ! $ this -> hasResolvedConcrete ( $ abstract ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be an abstract class name which exists in resolved concrete stack." , __METHOD__ ) ) ; } return explode ( '|' , $ this -> resolved [ $ abstract ] [ 'flag' ] ) ; }
8963	private static function extractDateCriteria ( $ key , array $ criteria ) { $ date = ( ! empty ( $ criteria [ $ key ] ) ) ? $ criteria [ $ key ] : null ; if ( is_string ( $ date ) ) { $ date = \ DateTime :: createFromFormat ( 'Y-m-d' , $ date ) ; } if ( false === $ date ) { throw new InvalidArgumentException ( sprintf ( 'Invalid date/time format provided "%s", expected "%s", or instance of \DateTime class.' , $ criteria [ $ key ] , 'Y-m-d' ) ) ; } return $ date ; }
9452	public function query ( $ index , array $ filters = null , array $ queries = null , array $ fieldWeights = null , $ limit = 20 , $ offset = 0 ) { $ sphinxClient = $ this -> getSphinxClient ( ) ; $ sphinxClient -> SetLimits ( $ offset , $ limit ) ; if ( null !== $ filters ) { foreach ( $ filters as $ filter ) { if ( ! isset ( $ filter [ 'key' ] ) ) { } if ( array_key_exists ( 'min' , $ filter ) && array_key_exists ( 'max' , $ filter ) ) { $ sphinxClient -> SetFilterRange ( $ filter [ 'key' ] , ( integer ) $ filter [ 'min' ] , ( integer ) $ filter [ 'max' ] ) ; } else { if ( ! isset ( $ filter [ 'values' ] ) || ! is_array ( $ filter [ 'values' ] ) ) { } $ sphinxClient -> SetFilter ( $ filter [ 'key' ] , $ filter [ 'values' ] ) ; } } } if ( null !== $ queries ) { foreach ( $ queries as $ key => $ queryInfo ) { $ query = $ this -> implodeQueryValues ( $ queryInfo ) ; if ( array_key_exists ( 'countableAttributes' , $ queryInfo ) ) { $ array = $ queryInfo [ 'countableAttributes' ] ; if ( ! is_array ( $ array ) ) { $ array = [ $ array ] ; } $ sphinxClient -> addFacetedQuery ( $ query , $ index , $ array ) ; } else { $ sphinxClient -> AddQuery ( $ query , $ index ) ; } } } if ( null !== $ fieldWeights ) { $ sphinxClient -> SetFieldWeights ( $ fieldWeights ) ; } $ result = $ this -> getResult ( $ sphinxClient ) ; return $ result ; }
5427	public function getInterfaces ( ) { $ reflection = new ReflectionClass ( $ this -> interface ) ; if ( $ reflection -> isInterface ( ) ) { return array ( $ this -> interface ) ; } return $ this -> onlyParents ( $ reflection -> getInterfaces ( ) ) ; }
6274	public function get ( $ key ) { if ( $ this -> find ( strval ( $ key ) ) ) { return $ this -> read ( $ this -> dataPos , $ this -> dataLen ) ; } return false ; }
7665	function EncodeFile ( $ path , $ encoding = "base64" ) { if ( ! @ $ fd = fopen ( $ path , "rb" ) ) { $ this -> SetError ( $ this -> Lang ( "file_open" ) . $ path ) ; return "" ; } $ magic_quotes = get_magic_quotes_runtime ( ) ; set_magic_quotes_runtime ( 0 ) ; $ file_buffer = fread ( $ fd , filesize ( $ path ) ) ; $ file_buffer = $ this -> EncodeString ( $ file_buffer , $ encoding ) ; fclose ( $ fd ) ; set_magic_quotes_runtime ( $ magic_quotes ) ; return $ file_buffer ; }
1562	protected function deserializeAttribute ( $ value , $ field , $ record ) { if ( $ this -> isDateAttribute ( $ field , $ record ) ) { return $ this -> deserializeDate ( $ value , $ field , $ record ) ; } $ method = 'deserialize' . Str :: classify ( $ field ) . 'Field' ; if ( method_exists ( $ this , $ method ) ) { return $ this -> { $ method } ( $ value , $ record ) ; } return $ value ; }
7993	public function getDiskUsage ( $ diskId , $ type ) { return json_decode ( self :: getClient ( ) -> getDiskUsage ( $ this -> getDomain ( ) , $ diskId , $ type ) ) ; }
5023	public function allowSelectMultipleItems ( ) { $ flagOrCallback = $ this -> allowSelectMultipleItems ; return is_callable ( $ flagOrCallback ) ? ( bool ) $ flagOrCallback ( ) : ( bool ) $ flagOrCallback ; }
676	public function setPage ( $ value , $ validatePage = false ) { if ( $ value === null ) { $ this -> _page = null ; } else { $ value = ( int ) $ value ; if ( $ validatePage && $ this -> validatePage ) { $ pageCount = $ this -> getPageCount ( ) ; if ( $ value >= $ pageCount ) { $ value = $ pageCount - 1 ; } } if ( $ value < 0 ) { $ value = 0 ; } $ this -> _page = $ value ; } }
8870	public function detach ( Runner $ runner ) { if ( ! $ this -> runners -> contains ( $ runner ) ) { throw new LogicException ( 'Can\'t detach not attached runner.' ) ; } $ this -> runners -> detach ( $ runner ) ; return $ this ; }
10945	public function onPrerenderPost ( PrerenderEvent $ events ) { $ cache = $ this -> getServiceLocator ( ) -> get ( $ this -> moduleOptions -> getCacheKey ( ) ) ; $ response = $ events -> getResponse ( ) ; $ key = $ this -> getCacheEntryKey ( $ events -> getRequest ( ) ) ; $ cache -> setItem ( $ key , $ events -> getResponse ( ) ) ; return $ this ; }
9724	public function getFilename ( $ filename , $ extension = 'xlsx' ) { $ originalExtension = pathinfo ( $ filename , PATHINFO_EXTENSION ) ; return $ this -> getTemporaryFolder ( ) . '/' . str_replace ( '.' . $ originalExtension , '.' . $ extension , basename ( $ filename ) ) ; }
824	public function getName ( ) { if ( null === $ this -> name ) { Preg :: matchAll ( '/@[a-zA-Z0-9_-]+(?=\s|$)/' , $ this -> line -> getContent ( ) , $ matches ) ; if ( isset ( $ matches [ 0 ] [ 0 ] ) ) { $ this -> name = ltrim ( $ matches [ 0 ] [ 0 ] , '@' ) ; } else { $ this -> name = 'other' ; } } return $ this -> name ; }
3686	protected function getAndOrFilter ( IFilter $ filter , $ operation ) { if ( ! $ operation [ 'children' ] ) { return ; } if ( $ operation [ 'operation' ] == 'AND' ) { $ filterRule = new ConditionAnd ( ) ; } else { $ filterRule = new ConditionOr ( ) ; } $ filter -> addFilterRule ( $ filterRule ) ; $ children = $ this -> optimizedFilter ( $ filterRule , $ operation [ 'children' ] , $ operation [ 'operation' ] ) ; foreach ( $ children as $ child ) { $ subFilter = $ this -> getMetaModel ( ) -> getEmptyFilter ( ) ; $ filterRule -> addChild ( $ subFilter ) ; $ this -> calculateSubfilter ( $ child , $ subFilter ) ; } }
6446	public function completeLogin ( $ extrainputs = array ( ) ) { $ linkedin = $ this -> getClient ( ) ; $ this -> token = $ linkedin -> getAccessToken ( $ extrainputs [ 'code' ] ) ; return $ this -> getUserProfile ( ) ; }
6347	public static function all ( Iterator $ iterator , callable $ predicate ) : bool { while ( $ iterator -> valid ( ) ) { if ( ! Predicates :: call ( $ predicate , $ iterator -> current ( ) ) ) { return false ; } $ iterator -> next ( ) ; } return true ; }
7061	private function setClasses ( array $ classes ) { if ( ! empty ( $ classes ) ) { $ this -> vars [ 'attr' ] [ 'class' ] = ' ' . trim ( implode ( ' ' , $ classes ) ) ; } else { unset ( $ this -> vars [ 'attr' ] [ 'class' ] ) ; } }
6117	public function serverGetByUid ( $ uid ) { foreach ( $ this -> serverList ( ) as $ server ) { if ( $ server [ "virtualserver_unique_identifier" ] == $ uid ) { return $ server ; } } throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; }
4801	public function injectSpecialBindings ( string $ sql , array $ bindings ) : string { foreach ( self :: SPECIAL_BINDINGS as $ special ) { $ specialPlaceholder = ":" . $ special ; if ( ! array_key_exists ( $ special , $ bindings ) ) { continue ; } $ replacement = $ this -> escapeSpecialBinding ( $ bindings [ $ special ] , $ special ) ; $ sql = str_replace ( $ specialPlaceholder , $ replacement , $ sql ) ; unset ( $ bindings [ $ special ] ) ; } foreach ( $ bindings as $ key => $ value ) { if ( is_array ( $ value ) ) { $ inString = "" ; foreach ( $ value as $ i => $ innerValue ) { $ newKey = $ key . "__" . $ i ; $ keyParamString = ":$newKey" ; $ inString .= "$keyParamString, " ; } $ inString = rtrim ( $ inString , " ," ) ; $ sql = str_replace ( ":$key" , $ inString , $ sql ) ; } } return $ sql ; }
3849	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'tableName' ) ) { return ; } $ tableName = strtolower ( $ event -> getValue ( ) ) ; if ( ! strlen ( $ tableName ) ) { throw new \ RuntimeException ( 'Table name not given' ) ; } if ( substr ( $ tableName , 0 , 3 ) !== 'mm_' ) { $ tableName = 'mm_' . $ tableName ; } $ dataProvider = $ event -> getEnvironment ( ) -> getDataProvider ( 'tl_metamodel' ) ; try { if ( ! $ event -> getModel ( ) -> getId ( ) ) { $ this -> tableManipulator -> checkTableDoesNotExist ( $ tableName ) ; } else { $ oldVersion = $ dataProvider -> fetch ( $ dataProvider -> getEmptyConfig ( ) -> setId ( $ event -> getModel ( ) -> getId ( ) ) ) ; if ( $ oldVersion -> getProperty ( 'tableName' ) !== $ event -> getModel ( ) -> getProperty ( 'tableName' ) ) { $ this -> tableManipulator -> checkTableDoesNotExist ( $ tableName ) ; } } } catch ( \ Exception $ exception ) { throw new \ RuntimeException ( $ exception -> getMessage ( ) , $ exception -> getCode ( ) , $ exception ) ; } $ event -> setValue ( $ tableName ) ; }
9876	public function writeWorkbook ( Spreadsheet $ spreadsheet , $ recalcRequired = false ) { if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'workbook' ) ; $ objWriter -> writeAttribute ( 'xml:space' , 'preserve' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> writeAttribute ( 'xmlns:r' , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships' ) ; $ this -> writeFileVersion ( $ objWriter ) ; $ this -> writeWorkbookPr ( $ objWriter ) ; $ this -> writeWorkbookProtection ( $ objWriter , $ spreadsheet ) ; if ( $ this -> getParentWriter ( ) -> getOffice2003Compatibility ( ) === false ) { $ this -> writeBookViews ( $ objWriter , $ spreadsheet ) ; } $ this -> writeSheets ( $ objWriter , $ spreadsheet ) ; $ this -> writeDefinedNames ( $ objWriter , $ spreadsheet ) ; $ this -> writeCalcPr ( $ objWriter , $ recalcRequired ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
7597	public function render ( $ sFontAwesome , array $ aFontAwesomeAttributes = null ) { if ( ! is_scalar ( $ sFontAwesome ) ) { throw new \ InvalidArgumentException ( sprintf ( 'FontAwesome expects a scalar value, "%s" given' , gettype ( $ sFontAwesome ) ) ) ; } if ( empty ( $ aFontAwesomeAttributes ) ) { $ aFontAwesomeAttributes = array ( 'class' => 'fa' ) ; } else { if ( empty ( $ aFontAwesomeAttributes [ 'class' ] ) ) { $ aFontAwesomeAttributes [ 'class' ] = 'fa' ; } elseif ( ! preg_match ( '/(\s|^)fa(\s|$)/' , $ aFontAwesomeAttributes [ 'class' ] ) ) { $ aFontAwesomeAttributes [ 'class' ] .= ' fa' ; } } if ( strpos ( 'fa-' , $ sFontAwesome ) !== 0 ) { $ sFontAwesome = 'fa-' . $ sFontAwesome ; } if ( ! preg_match ( '/(\s|^)' . preg_quote ( $ sFontAwesome , '/' ) . '(\s|$)/' , $ aFontAwesomeAttributes [ 'class' ] ) ) { $ aFontAwesomeAttributes [ 'class' ] .= ' ' . $ sFontAwesome ; } return sprintf ( static :: $ faFormat , $ this -> createAttributesString ( $ aFontAwesomeAttributes ) ) ; }
6199	protected function transformParam ( $ param , $ k ) { if ( isset ( $ this -> routeMapParse [ $ k ] [ $ param ] ) and ! is_array ( $ this -> routeMapParse [ $ k ] [ $ param ] ) ) { return $ this -> routeMapParse [ $ k ] [ $ param ] ; } else { return '(.+?)' ; } }
4227	public function unregister ( ) { if ( ! $ this -> registered ) { return ; } $ errHandlerCur = \ set_error_handler ( array ( $ this , 'handleError' ) ) ; \ restore_error_handler ( ) ; if ( $ errHandlerCur == array ( $ this , 'handleError' ) ) { \ restore_error_handler ( ) ; } $ exHandlerCur = \ set_exception_handler ( array ( $ this , 'handleException' ) ) ; \ restore_exception_handler ( ) ; if ( $ exHandlerCur == array ( $ this , 'handleException' ) ) { \ restore_exception_handler ( ) ; } \ ini_set ( 'display_errors' , $ this -> prevDisplayErrors ) ; $ this -> prevErrorHandler = null ; $ this -> prevExceptionHandler = null ; $ this -> registered = false ; return ; }
2754	public static function plainText ( $ value ) { $ element = render ( $ value ) ; $ element = strip_tags ( $ element ) ; $ element = html_entity_decode ( $ element , ENT_QUOTES ) ; return $ element ; }
12380	public static function fromReflectionParam ( ReflectionParameter $ param , ReflectionFunctionAbstract $ func = null , Exception $ previous = null , $ afterMessage = null ) { $ message = static :: makeMessage ( $ param , $ func ) ; if ( $ previous ) { $ message .= ' - ' . $ previous -> getMessage ( ) ; } if ( $ afterMessage ) { $ message .= ' - ' . $ afterMessage ; } return new static ( $ message , 0 , $ previous ) ; }
2795	public function getTempDirectory ( ) { if ( is_null ( $ this -> tempDirectory ) ) { $ root = sys_get_temp_dir ( ) ; if ( ! is_dir ( $ root . '/humbug' ) ) { mkdir ( $ root . '/humbug' , 0777 , true ) ; } $ this -> tempDirectory = $ root . '/humbug' ; } return $ this -> tempDirectory ; }
11543	public function changePassword ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangePasswordForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ password = $ user -> getPassword ( ) ; $ passwordService = $ this -> getMapper ( ) -> getPasswordService ( ) ; $ user -> setPassword ( $ passwordService -> create ( $ password ) ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
1177	public function make ( array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] , $ selector = null ) { $ validator = $ this -> getValidatorInstance ( $ rules , $ messages , $ customAttributes ) ; return $ this -> validator ( $ validator , $ selector ) ; }
5399	public function setHost ( $ host ) { if ( $ host = $ this -> truncateHost ( $ host ) ) { $ this -> host = $ host ; return true ; } return false ; }
69	public function removeJunction ( $ junction ) { if ( ! Platform :: isWindows ( ) ) { return false ; } $ junction = rtrim ( str_replace ( '/' , DIRECTORY_SEPARATOR , $ junction ) , DIRECTORY_SEPARATOR ) ; if ( ! $ this -> isJunction ( $ junction ) ) { throw new IOException ( sprintf ( '%s is not a junction and thus cannot be removed as one' , $ junction ) ) ; } return $ this -> rmdir ( $ junction ) ; }
6717	protected function setParameters ( $ newParameters ) { if ( is_scalar ( $ newParameters ) ) { if ( ! is_string ( $ newParameters ) ) { throw new \ Exception ( 'newParameters can not be scalar' ) ; } $ newParameters = $ this -> stringToArray ( $ newParameters ) ; } foreach ( $ newParameters as $ field => $ value ) { $ this -> setParameter ( $ field , $ value ) ; } return $ this ; }
28	public static function register ( IOInterface $ io = null ) { set_error_handler ( array ( __CLASS__ , 'handle' ) ) ; error_reporting ( E_ALL | E_STRICT ) ; self :: $ io = $ io ; }
4345	public function getCfgLazy ( $ name ) { if ( ! isset ( $ this -> cfgLazy [ $ name ] ) ) { return array ( ) ; } $ return = $ this -> cfgLazy [ $ name ] ; unset ( $ this -> cfgLazy [ $ name ] ) ; return $ return ; }
8122	public function getReviewContentForm ( $ id ) { $ page = $ this -> findRecord ( [ 'ID' => $ id ] ) ; $ user = Security :: getCurrentUser ( ) ; if ( ! $ page -> canEdit ( ) || ( $ page -> hasMethod ( 'canBeReviewedBy' ) && ! $ page -> canBeReviewedBy ( $ user ) ) ) { $ this -> owner -> httpError ( 403 , _t ( __CLASS__ . '.ErrorItemPermissionDenied' , 'It seems you don\'t have the necessary permissions to review this content' ) ) ; return null ; } $ form = $ this -> getReviewContentHandler ( ) -> Form ( $ page ) ; $ form -> setValidationResponseCallback ( function ( ValidationResult $ errors ) use ( $ form , $ id ) { $ schemaId = $ this -> owner -> join_links ( $ this -> owner -> Link ( 'schema/ReviewContentForm' ) , $ id ) ; return $ this -> getSchemaResponse ( $ schemaId , $ form , $ errors ) ; } ) ; return $ form ; }
9159	protected function redirect ( $ controller = null , $ action = null ) { if ( null === $ controller ) { $ controller = Application :: getInstance ( ) -> getDefaultController ( ) ; } if ( null === $ action ) { $ action = Application :: getInstance ( ) -> getDefaultAction ( ) ; } $ destination = sprintf ( "Location: %s%s/%s" , $ this -> request -> getContextPrefix ( ) , $ controller , $ action ) ; header ( $ destination ) ; exit ( ) ; }
5721	public function doSaveAndPrev ( $ data , $ form ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; $ link = $ this -> getEditLink ( $ this -> getPreviousRecordID ( ) ) ; return $ this -> saveAndRedirect ( $ data , $ form , $ link ) ; }
7150	public function clear ( ) { $ this -> provider = null ; $ this -> identifier = null ; $ this -> subject = null ; }
1412	public function resourceDoesNotSupportClientIds ( string $ type , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_FORBIDDEN , $ this -> trans ( 'resource_client_ids_not_supported' , 'code' ) , $ this -> trans ( 'resource_client_ids_not_supported' , 'title' ) , $ this -> trans ( 'resource_client_ids_not_supported' , 'detail' , compact ( 'type' ) ) , $ this -> pointer ( $ path , 'id' ) ) ; }
5471	private function getProperty ( $ name , $ object ) { $ reflection = new ReflectionObject ( $ object ) ; $ property = $ reflection -> getProperty ( $ name ) ; if ( method_exists ( $ property , 'setAccessible' ) ) { $ property -> setAccessible ( true ) ; } try { return $ property -> getValue ( $ object ) ; } catch ( ReflectionException $ e ) { return $ this -> getPrivatePropertyNoMatterWhat ( $ name , $ object ) ; } }
7873	public function credit ( ) : ? array { $ this -> checkConfig ( ) ; $ query = http_build_query ( [ 'userkey' => $ this -> userkey , 'passkey' => $ this -> passkey , ] ) ; $ response = Request :: get ( $ this -> baseUrl . '/smsapibalance.php?' . $ query ) ; $ xml = simplexml_load_string ( $ response -> body ) ; $ body = json_decode ( json_encode ( $ xml ) , true ) ; return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ body [ 'message' ] [ 'text' ] ?? '' , 'data' => $ body , ] ; }
1577	protected function validateDocumentCompliance ( $ document , ? ValidatorFactoryInterface $ validators ) : void { $ this -> passes ( $ this -> factory -> createNewResourceDocumentValidator ( $ document , $ this -> getResourceType ( ) , $ validators && $ validators -> supportsClientIds ( ) ) ) ; }
3131	public function persist ( QtiRunnerServiceContext $ context ) { $ testSession = $ context -> getTestSession ( ) ; $ sessionId = $ testSession -> getSessionId ( ) ; \ common_Logger :: d ( "Persisting QTI Assessment Test Session '${sessionId}'..." ) ; $ context -> getStorage ( ) -> persist ( $ testSession ) ; if ( $ this -> isTerminated ( $ context ) ) { $ userId = \ common_session_SessionManager :: getSession ( ) -> getUser ( ) -> getIdentifier ( ) ; $ eventManager = $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) ; $ eventManager -> trigger ( new AfterAssessmentTestSessionClosedEvent ( $ testSession , $ userId ) ) ; } }
10360	public static function fatal ( ) { $ e = error_get_last ( ) ; if ( $ e !== null && ( error_reporting ( ) & $ e [ 'type' ] ) !== 0 ) { ErrorHandler :: exception ( new \ ErrorException ( $ e [ 'message' ] , $ e [ 'type' ] , 0 , $ e [ 'file' ] , $ e [ 'line' ] ) ) ; exit ( 1 ) ; } }
11717	public static function load ( string $ dir ) : void { self :: initialize ( ) ; $ commandDir = $ _SERVER [ 'DOCUMENT_ROOT' ] . $ dir ; $ files = scandir ( $ commandDir ) ; foreach ( $ files as $ file ) { if ( $ file == '.' || $ file == '..' ) { continue ; } require_once $ _SERVER [ 'DOCUMENT_ROOT' ] . $ dir . '/' . $ file ; } }
1524	protected function doRead ( StoreInterface $ store , FetchResource $ request ) { $ record = $ request -> getRecord ( ) ; if ( $ result = $ this -> invoke ( 'reading' , $ record , $ request ) ) { return $ result ; } $ record = $ store -> readRecord ( $ record , $ request -> getParameters ( ) ) ; if ( $ result = $ this -> invoke ( 'didRead' , $ record , $ request ) ) { return $ result ; } return $ record ; }
12717	protected function getMethodParameters ( Internal \ ReflectionClassFactory $ refl , $ method ) { return ( $ refl -> hasMethod ( $ method ) ? $ refl -> getMethod ( $ method ) -> getParameters ( ) : null ) ; }
7408	public function merge ( $ ta ) : self { $ this -> _massageBlockInput ( $ in ) ; $ ret = clone $ this ; foreach ( $ ta as $ k => $ v ) { if ( is_int ( $ k ) ) { $ ret [ ] = $ v ; } else { $ ret [ $ k ] = $ v ; } } return $ ret ; }
7023	private function formatZ ( & $ str ) { if ( strstr ( $ str , '%Z' ) ) $ str = str_replace ( '%Z' , $ this -> timezone -> offset * 3600 , $ str ) ; }
1564	public function setResource ( $ resource ) : ClientJob { $ schema = $ this -> getApi ( ) -> getContainer ( ) -> getSchema ( $ resource ) ; $ this -> fill ( [ 'resource_type' => $ schema -> getResourceType ( ) , 'resource_id' => $ schema -> getId ( $ resource ) , ] ) ; return $ this ; }
11785	public function pagination ( $ begin , $ count ) { $ params = [ 'type' => 2 , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , $ params ] ) ; }
2837	public function getInfoAsArray ( ) { return array ( 'design_area' => $ this -> getArea ( ) , 'package_name' => $ this -> getPackageName ( ) , 'layout_theme' => $ this -> getThemeLayout ( ) , 'template_theme' => $ this -> getThemeTemplate ( ) , 'locale' => $ this -> getThemeLocale ( ) , 'skin' => $ this -> getThemeSkin ( ) ) ; }
5081	public function putRemap ( $ sMethod ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sMethod = 'put' . ucfirst ( $ oUri -> segment ( 4 ) ) ; if ( method_exists ( $ this , $ sMethod ) ) { return $ this -> $ sMethod ( ) ; } $ oItem = $ this -> lookUpResource ( ) ; if ( ! $ oItem ) { throw new ApiException ( 'Resource not found' , 404 ) ; } $ this -> userCan ( static :: ACTION_UPDATE , $ oItem ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ sData = stream_get_contents ( fopen ( 'php://input' , 'r' ) ) ; $ aData = json_decode ( $ sData , JSON_OBJECT_AS_ARRAY ) ? : [ ] ; $ aData = $ this -> validateUserInput ( $ aData , $ oItem ) ; if ( ! $ this -> oModel -> update ( $ oItem -> id , $ aData ) ) { throw new ApiException ( 'Failed to update resource. ' . $ this -> oModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } return Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; }
7005	private function format_d ( & $ str ) { if ( strstr ( $ str , '%d' ) ) $ str = str_replace ( '%d' , sprintf ( '%02d' , $ this -> day ) , $ str ) ; }
5230	public static function forValue ( $ value ) { $ enumClass = new \ ReflectionClass ( get_called_class ( ) ) ; foreach ( $ enumClass -> getStaticProperties ( ) as $ instance ) { if ( $ instance -> value ( ) === $ value ) { return $ instance ; } } throw new \ InvalidArgumentException ( 'Enum ' . $ enumClass -> getName ( ) . ' for value ' . $ value . ' does not exist.' ) ; }
7934	public function alreadyLoaded ( $ name ) { foreach ( $ this -> loaded as $ item ) { if ( $ item [ 'name' ] === $ name ) { return true ; } } return false ; }
7752	protected function completeMetadata ( ClassMetadata $ class ) { $ className = $ class -> getName ( ) ; if ( null === $ class -> getIri ( ) ) { $ class -> setIri ( $ this -> namingStrategy -> classIriFragment ( $ className ) ) ; } if ( null === $ class -> getExposeAs ( ) ) { $ class -> setExposeAs ( $ this -> namingStrategy -> classShortName ( $ className ) ) ; } if ( null === $ class -> getTitle ( ) ) { $ class -> setTitle ( $ this -> namingStrategy -> classShortName ( $ className ) ) ; } foreach ( $ class -> getProperties ( ) as $ property ) { $ propertyName = $ property -> getName ( ) ; if ( null === $ property -> getIri ( ) ) { $ property -> setIri ( $ this -> namingStrategy -> propertyIriFragment ( $ className , $ propertyName ) ) ; } if ( null === $ property -> getExposeAs ( ) ) { $ property -> setExposeAs ( $ this -> namingStrategy -> propertyShortName ( $ className , $ propertyName ) ) ; } if ( null === $ property -> getTitle ( ) ) { $ property -> setTitle ( $ this -> namingStrategy -> propertyShortName ( $ className , $ propertyName ) ) ; } } }
12117	public static function displayConsoleException ( \ Throwable $ Throwable ) { ob_start ( ) ; echo PHP_EOL . ' ' ; echo ( ( $ Throwable instanceof PHPAssertionFailed ) ? 'Assertion Failed' : 'Uncaught ' . self :: getShortName ( get_class ( $ Throwable ) ) ) ; echo ' <' . basename ( $ Throwable -> getFile ( ) ) . ':' . $ Throwable -> getLine ( ) . '>' ; echo PHP_EOL . PHP_EOL . ' ' ; if ( $ Throwable instanceof PHPAssertionFailed ) { $ message = $ Throwable -> getExpression ( ) ; if ( $ message == '' ) { $ message = 'false' ; } } else { $ message = $ Throwable -> getMessage ( ) ; } echo wordwrap ( $ message , self :: CONSOLE_WIDTH - 2 , PHP_EOL . ' ' ) ; echo PHP_EOL . PHP_EOL . ' Stack Trace:' . PHP_EOL . PHP_EOL ; if ( $ Throwable instanceof BaseException || $ Throwable instanceof PHPErrorException ) { $ trace = $ Throwable -> getStackTrace ( ) ; } else { $ trace = array_reverse ( $ Throwable -> getTrace ( ) ) ; } $ trace_empty = [ 'class' => '' , 'type' => '' , 'function' => '' , 'file' => '{unknown}' , 'line' => 0 ] ; foreach ( $ trace as $ key => $ trace_item ) { $ trace_item = array_merge ( $ trace_empty , $ trace_item ) ; $ trace_item [ 'file' ] = basename ( $ trace_item [ 'file' ] ) ; if ( $ trace_item [ 'function' ] != '{closure}' ) { $ trace_item [ 'function' ] .= '()' ; } $ key ++ ; echo str_pad ( " $key. " , 6 , ' ' ) ; echo self :: getShortName ( $ trace_item [ 'class' ] ) . $ trace_item [ 'type' ] . $ trace_item [ 'function' ] ; echo " <{$trace_item['file']}:{$trace_item['line']}>" . PHP_EOL ; } return ob_get_clean ( ) ; }
6280	public function nextkey ( ) { if ( $ this -> keyIterPos >= $ this -> keyIterStop ) { return false ; } $ keyLen = $ this -> readInt31 ( $ this -> keyIterPos ) ; $ dataLen = $ this -> readInt31 ( $ this -> keyIterPos + 4 ) ; $ key = $ this -> read ( $ this -> keyIterPos + 8 , $ keyLen ) ; $ this -> keyIterPos += 8 + $ keyLen + $ dataLen ; return $ key ; }
6393	public static function run ( callable $ tryBlock , array $ exceptions = [ ] , callable $ finallyBlock = null ) : TryTo { try { return Success :: of ( Functions :: call ( $ tryBlock ) ) ; } catch ( Exception $ e ) { if ( count ( $ exceptions ) === 0 ) { return Failure :: of ( $ e ) ; } $ error = FluentIterable :: of ( $ exceptions ) -> filter ( Predicates :: assignableFrom ( get_class ( $ e ) ) ) -> first ( ) ; if ( $ error -> isPresent ( ) ) { return Failure :: of ( $ e ) ; } throw $ e ; } finally { if ( $ finallyBlock !== null ) { Functions :: call ( $ finallyBlock ) ; } } }
1197	private function htmlAttributesCallback ( $ name , $ value ) { if ( false === $ value || null === $ value ) { return '' ; } return ' ' . $ this -> renderHtmlAttribute ( $ name , $ value ) ; }
4743	public function validateOptIn ( ) { $ optInValue = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'rvw_oegdproptin' ) ; if ( $ this -> isReviewOptInValidationRequired ( ) && ! $ optInValue ) { return false ; } return true ; }
4402	protected function getProvider ( ) { $ config = $ this -> getServiceItem ( ) -> getConfig ( ) ; $ config [ 'apiKey' ] = $ this -> getServiceItem ( ) -> getConfigValue ( 'stripe.apiKey' ) ; if ( ! isset ( $ this -> provider ) ) { $ this -> provider = OPay :: create ( 'Stripe' ) ; $ this -> provider -> setTestMode ( ( bool ) $ this -> getValue ( 'testmode' , false ) ) ; $ this -> provider -> initialize ( $ config ) ; } return $ this -> provider ; }
12465	private function getOptionsAvailable ( $ entity ) { $ options = $ this -> getParameter ( 'chill_custom_fields.' . 'customizables_entities' ) ; foreach ( $ options as $ key => $ definition ) { if ( $ definition [ 'class' ] == $ entity ) { foreach ( $ definition [ 'options' ] as $ key => $ value ) { yield $ key ; } } } }
7713	function FindEndTag ( $ Encaps = false ) { if ( is_null ( $ this -> SelfClosing ) ) { $ pe = $ this -> PosEnd ; $ SelfClosing = ( substr ( $ this -> Txt , $ pe - 1 , 1 ) == '/' ) ; if ( ! $ SelfClosing ) { if ( $ Encaps ) { $ loc = clsTinyButStrong :: f_Xml_FindTag ( $ this -> Txt , $ this -> FindName ( ) , null , $ pe , true , - 1 , false , false ) ; if ( $ loc === false ) return false ; $ this -> pET_PosBeg = $ loc -> PosBeg ; $ this -> PosEnd = $ loc -> PosEnd ; } else { $ pe = clsTinyButStrong :: f_Xml_FindTagStart ( $ this -> Txt , $ this -> FindName ( ) , false , $ pe , true , true ) ; if ( $ pe === false ) return false ; $ this -> pET_PosBeg = $ pe ; $ pe = strpos ( $ this -> Txt , '>' , $ pe ) ; if ( $ pe === false ) return false ; $ this -> PosEnd = $ pe ; } } $ this -> SelfClosing = $ SelfClosing ; } return true ; }
9800	public static function setChartRenderer ( $ rendererClass ) { if ( ! is_a ( $ rendererClass , IRenderer :: class , true ) ) { throw new Exception ( 'Chart renderer must implement ' . IRenderer :: class ) ; } self :: $ chartRenderer = $ rendererClass ; }
4937	protected function createNestedOptions ( $ className , $ options ) { $ class = new $ className ( ) ; foreach ( $ options as $ key => $ spec ) { if ( is_array ( $ spec ) && array_key_exists ( '__class__' , $ spec ) ) { $ nestedClassName = $ spec [ '__class__' ] ; unset ( $ spec [ '__class__' ] ) ; $ spec = $ this -> createNestedOptions ( $ nestedClassName , $ spec ) ; } $ class -> { $ key } = $ spec ; } return $ class ; }
3219	function getDelta ( $ cursor = null , $ pathPrefix = null ) { Checker :: argStringNonEmptyOrNull ( "cursor" , $ cursor ) ; Path :: checkArgOrNull ( "pathPrefix" , $ pathPrefix ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/delta" , array ( "cursor" => $ cursor , "path_prefix" => $ pathPrefix ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
7006	private function formatD ( & $ str ) { if ( strstr ( $ str , '%D' ) ) $ str = str_replace ( '%D' , $ this -> dayName ( false ) , $ str ) ; }
2643	private function _purge ( $ uri , $ type , $ method = \ Zend_Http_Client :: POST , $ payload = null ) { if ( $ method == 'PURGE' ) { $ expiration = time ( ) + self :: PURGE_TOKEN_LIFETIME ; $ zendUri = \ Zend_Uri :: factory ( $ uri ) ; $ path = $ zendUri -> getPath ( ) ; $ stringToSign = $ path . $ expiration ; $ signature = hash_hmac ( 'sha1' , $ stringToSign , $ this -> config -> getServiceId ( ) ) ; $ token = $ expiration . '_' . urlencode ( $ signature ) ; $ headers = [ self :: FASTLY_HEADER_TOKEN . ': ' . $ token ] ; } else { $ headers = [ self :: FASTLY_HEADER_AUTH . ': ' . $ this -> config -> getApiKey ( ) ] ; } if ( $ this -> config -> canUseSoftPurge ( ) ) { array_push ( $ headers , self :: FASTLY_HEADER_SOFT_PURGE . ': 1' ) ; } $ result [ 'status' ] = true ; try { $ client = $ this -> curlFactory -> create ( ) ; $ client -> setConfig ( [ 'timeout' => self :: PURGE_TIMEOUT ] ) ; if ( $ method == 'PURGE' ) { $ client -> addOption ( CURLOPT_CUSTOMREQUEST , 'PURGE' ) ; } $ client -> write ( $ method , $ uri , '1.1' , $ headers , $ payload ) ; $ responseBody = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ responseBody ) ; $ responseMessage = \ Zend_Http_Response :: extractMessage ( $ responseBody ) ; $ client -> close ( ) ; if ( $ responseCode == '429' ) { throw new LocalizedException ( __ ( $ responseMessage ) ) ; } elseif ( $ responseCode != '200' ) { throw new LocalizedException ( __ ( $ responseCode . ': ' . $ responseMessage ) ) ; } } catch ( \ Exception $ e ) { $ this -> logger -> critical ( $ e -> getMessage ( ) , $ uri ) ; $ result [ 'status' ] = false ; $ result [ 'msg' ] = $ e -> getMessage ( ) ; } if ( empty ( $ type ) ) { return $ result ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishPurgeChanges ( ) ) { $ this -> sendWebHook ( '*initiated ' . $ type . '*' ) ; if ( $ this -> config -> canPublishPurgeDebugBacktrace ( ) == false ) { return $ result ; } $ this -> stackTrace ( $ type ) ; } return $ result ; }
10821	public static function title ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'title' , $ length , $ separator ) ; }
9679	function fromXML ( $ xmlElement ) { $ this -> contact = new ReportContact ( ) ; $ this -> contact -> fromXML ( $ xmlElement -> contact ) ; if ( isset ( $ xmlElement -> mailing_id ) ) $ this -> mailingId = $ xmlElement -> mailing_id ; if ( isset ( $ xmlElement -> source ) ) $ this -> source = $ xmlElement -> source ; if ( isset ( $ xmlElement -> timestamp ) ) $ this -> timestamp = $ xmlElement -> timestamp ; }
8245	protected function abortIfExpired ( $ id , $ userData ) { if ( isset ( $ userData [ 'pwreset' ] ) && $ userData [ 'pwreset' ] ) { $ this -> session -> addFlash ( "error" , "Please set a new password." ) ; $ this -> picoAuth -> getContainer ( ) -> get ( 'PasswordReset' ) -> startPasswordResetSession ( $ id ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } }
10480	private function isTrackedFieldModified ( AbstractDiffItem $ item , ExtractionDescriptorInterface $ relation ) { if ( ! $ item instanceof UpdateDiffItem ) { throw new \ InvalidArgumentException ( 'Wrong diff item type. Got: ' . get_class ( $ item ) ) ; } $ trackedFields = $ relation -> getUpdateFields ( ) ; if ( empty ( $ trackedFields ) ) { return true ; } $ itemRow = $ item -> getItem ( ) ; $ oldItemRow = $ item -> getOldItem ( ) ; foreach ( array_keys ( $ trackedFields ) as $ key ) { if ( array_key_exists ( $ key , $ itemRow ) && $ itemRow [ $ key ] !== $ oldItemRow [ $ key ] ) { return true ; } } return false ; }
12783	protected function createIntersections ( ) { $ totalNumberOfCombinations = min ( pow ( 2 , $ this -> arraysSize ) , $ this -> maxNumberOfCombinations ) ; $ maskGenerator = new BitMaskGenerator ( $ this -> arraysSize , 2 ) ; $ i = 0 ; $ noresult = 0 ; while ( $ i < $ totalNumberOfCombinations && $ noresult < $ totalNumberOfCombinations && $ mask = $ maskGenerator -> getNextMask ( ) ) { if ( ! $ this -> isNoResultMask ( $ mask ) ) { $ i ++ ; $ this -> generateIntersection ( $ mask ) ; continue ; } $ noresult ++ ; } if ( ! is_null ( $ this -> intersections ) ) { uasort ( $ this -> intersections , function ( $ a , $ b ) { return count ( $ b ) - count ( $ a ) ; } ) ; } }
9218	protected function pageNumberToKey ( $ pageNumber ) { if ( isset ( $ this -> pagination [ CanvasPageLink :: CURRENT ] ) ) { return ( $ pageNumber - 1 ) * $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getPerPage ( ) ; } return false ; }
9338	public function isSupplementary ( Angle $ angle ) { $ out = new self ( $ this -> float_rad + $ angle -> rad ) ; return $ out -> isStraight ( ) ; }
10199	private function writeCellSpan ( XMLWriter $ objWriter , $ curColumn , $ prevColumn ) { $ diff = $ curColumn - $ prevColumn - 1 ; if ( 1 === $ diff ) { $ objWriter -> writeElement ( 'table:table-cell' ) ; } elseif ( $ diff > 1 ) { $ objWriter -> startElement ( 'table:table-cell' ) ; $ objWriter -> writeAttribute ( 'table:number-columns-repeated' , $ diff ) ; $ objWriter -> endElement ( ) ; } }
278	private function notifyUnloaded ( $ fixtures ) { $ this -> stdout ( "\nFixtures were successfully unloaded from namespace: " , Console :: FG_YELLOW ) ; $ this -> stdout ( Yii :: getAlias ( $ this -> namespace ) . "\"\n\n" , Console :: FG_GREEN ) ; $ this -> outputList ( $ fixtures ) ; }
7839	public function info ( int $ id ) : ? array { $ response = Request :: get ( $ this -> baseUrl . 'contact/' . $ id ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
10702	public static function getPasswordComplexity ( $ password , $ minLength ) { $ group = [ 'upper' => '/[A-Z]/' , 'lower' => '/[a-z]/' , 'number' => '/[0-9]/' , 'special' => '/[^A-Za-z0-9]/' , ] ; $ score = 0 ; $ length = \ strlen ( $ password ) ; if ( $ length < $ minLength ) { return 0 ; } foreach ( $ group as $ pattern ) { if ( preg_match ( $ pattern , $ password ) ) { $ score ++ ; } } if ( $ score < 3 ) { $ score -- ; } if ( $ length > $ minLength ) { $ score += ( int ) floor ( ( $ length - $ minLength ) / 2 ) ; } return $ score ; }
10824	public static function confirm ( $ question , $ allowShort , $ defaultValue = false ) { $ value = $ defaultValue ? 'yes' : 'no' ; $ value = self :: ask ( $ question . ' (yes/no)' , $ value ) ; return $ value == 'yes' || ( $ value == 'y' && $ allowShort ) ; }
8725	public function translationModel ( ) { $ translation = new TranslationModel ( ) ; $ translation -> setConnection ( $ this -> getI18nConnection ( ) ) ; $ translation -> setTable ( $ this -> getI18nTable ( ) ) ; $ translation -> setKeyName ( $ this -> getForeignKey ( ) ) ; $ translation -> setLocaleKey ( $ this -> getLocaleKey ( ) ) ; if ( $ attributes = $ this -> translatableAttributes ( ) ) { $ translation -> fillable ( array_intersect ( $ attributes , $ this -> getFillable ( ) ) ) ; } return $ translation ; }
12555	public function showAction ( Tag $ tag ) { $ deleteForm = $ this -> createDeleteForm ( $ tag ) ; return array ( 'entity' => $ tag , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
7660	function AddrFormat ( $ addr ) { if ( empty ( $ addr [ 1 ] ) ) $ formatted = $ addr [ 0 ] ; else { $ formatted = $ this -> EncodeHeader ( $ addr [ 1 ] , 'phrase' ) . " <" . $ addr [ 0 ] . ">" ; } return $ formatted ; }
8329	public function whereExists ( Closure $ callback , $ boolean = 'and' , $ not = false ) { $ type = $ not ? 'NotExists' : 'Exists' ; $ this -> wheres [ ] = compact ( 'type' , 'callback' , 'boolean' ) ; return $ this ; }
10904	public function isEmpty ( ) { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE ) === false ) { throw new \ RuntimeException ( "failed to determine if a directory is empty; " . $ this -> getError ( ) ) ; } return count ( scandir ( $ this -> path ) ) === 2 ; }
9892	protected function createError ( ) { $ error = $ this -> getForm ( ) -> getValidator ( ) -> getMessages ( $ this -> getElement ( ) -> getName ( ) ) ; if ( $ error ) { $ this -> error = $ this -> builder -> make ( 'error' , [ ] , $ error ) ; } }
531	protected function splitChangelog ( $ file , $ version ) { $ lines = explode ( "\n" , file_get_contents ( $ file ) ) ; $ start = [ ] ; $ changelog = [ ] ; $ end = [ ] ; $ state = 'start' ; foreach ( $ lines as $ l => $ line ) { if ( isset ( $ lines [ $ l - 2 ] ) && strpos ( $ lines [ $ l - 2 ] , $ version ) !== false && isset ( $ lines [ $ l - 1 ] ) && strncmp ( $ lines [ $ l - 1 ] , '---' , 3 ) === 0 ) { $ state = 'changelog' ; } if ( $ state === 'changelog' && isset ( $ lines [ $ l + 1 ] ) && strncmp ( $ lines [ $ l + 1 ] , '---' , 3 ) === 0 ) { $ state = 'end' ; } if ( ! empty ( $ { $ state } ) && trim ( $ line ) !== '' && strncmp ( $ line , '- ' , 2 ) !== 0 ) { end ( $ { $ state } ) ; $ { $ state } [ key ( $ { $ state } ) ] .= "\n" . $ line ; } else { $ { $ state } [ ] = $ line ; } } return [ $ start , $ changelog , $ end ] ; }
7957	public function getProperties ( ) { $ this -> properties = json_decode ( self :: getClient ( ) -> getProperties ( $ this -> id ) ) ; return $ this -> properties ; }
6610	public static function getByCreatedDateRange ( $ startDate , $ endDate , $ createdAtColumn = 'created_at' ) { $ model = get_called_class ( ) ; $ model = new $ model ; return self :: find ( ) -> andWhere ( $ model :: tableName ( ) . '.' . $ createdAtColumn . ' BETWEEN :start_date AND :end_date' , [ 'start_date' => $ startDate , 'end_date' => $ endDate ] ) ; }
7538	function getRoot ( ) { $ r = $ this -> parent ; $ n = ( $ r === null ) ? null : $ r -> parent ; while ( $ n !== null ) { $ r = $ n ; $ n = $ r -> parent ; } return $ r ; }
47	public function addSubscriber ( EventSubscriberInterface $ subscriber ) { foreach ( $ subscriber -> getSubscribedEvents ( ) as $ eventName => $ params ) { if ( is_string ( $ params ) ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ params ) ) ; } elseif ( is_string ( $ params [ 0 ] ) ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ params [ 0 ] ) , isset ( $ params [ 1 ] ) ? $ params [ 1 ] : 0 ) ; } else { foreach ( $ params as $ listener ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ listener [ 0 ] ) , isset ( $ listener [ 1 ] ) ? $ listener [ 1 ] : 0 ) ; } } } }
5146	public function accessInboxFor ( $ address ) { $ inbox = array ( ) ; $ addressPlusDelimiters = '<' . $ address . '>' ; foreach ( $ this -> fetchedEmails as & $ email ) { $ email -> Headers = $ this -> getHeaders ( $ email -> id ) -> headers ; if ( ! isset ( $ email -> Headers -> bcc ) ) { if ( strpos ( $ email -> Headers -> to , $ addressPlusDelimiters ) || strpos ( $ email -> Headers -> cc , $ addressPlusDelimiters ) ) { array_push ( $ inbox , $ email ) ; } } else if ( strpos ( $ email -> Headers -> bcc , $ addressPlusDelimiters ) ) { array_push ( $ inbox , $ email ) ; } } $ this -> setCurrentInbox ( $ inbox ) ; }
3413	public function refreshFields ( ) { if ( $ this -> id === null ) { $ this -> original = [ ] ; return $ this -> fields = [ ] ; } $ this -> fields = static :: query ( ) -> getById ( $ this -> id ) -> fields ; $ this -> original = $ this -> fields ; $ this -> fieldsAreFetched = true ; return $ this -> fields ; }
1068	private function collectConflictsBetween ( ValidationContext $ context , array & $ conflicts , $ parentFieldsAreMutuallyExclusive , array $ fieldMap1 , array $ fieldMap2 ) { foreach ( $ fieldMap1 as $ responseName => $ fields1 ) { if ( ! isset ( $ fieldMap2 [ $ responseName ] ) ) { continue ; } $ fields2 = $ fieldMap2 [ $ responseName ] ; $ fields1Length = count ( $ fields1 ) ; $ fields2Length = count ( $ fields2 ) ; for ( $ i = 0 ; $ i < $ fields1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fields2Length ; $ j ++ ) { $ conflict = $ this -> findConflict ( $ context , $ parentFieldsAreMutuallyExclusive , $ responseName , $ fields1 [ $ i ] , $ fields2 [ $ j ] ) ; if ( ! $ conflict ) { continue ; } $ conflicts [ ] = $ conflict ; } } } }
7751	protected function loadMetadata ( $ className ) { if ( false === isset ( $ this -> loadedMetadata [ $ className ] ) ) { if ( null === ( $ class = $ this -> driver -> loadMetadataForClass ( $ className ) ) ) { throw new \ Exception ( "Can't load metadata for $className" ) ; } $ this -> completeMetadata ( $ class ) ; $ this -> loadedMetadata [ $ className ] = $ class ; } return $ this -> loadedMetadata [ $ className ] ; }
9974	public function setBuiltInFormatCode ( $ pValue ) { if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'formatCode' => self :: builtInFormatCode ( $ pValue ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> builtInFormatCode = $ pValue ; $ this -> formatCode = self :: builtInFormatCode ( $ pValue ) ; } return $ this ; }
9016	public function markAllNotificationsAsRead ( ) { $ object = Auth :: user ( ) ; $ object -> unreadNotifications -> markAsRead ( ) ; \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
6802	public function installTaxGroups ( $ codes = [ 'US' ] ) { $ codes = ( array ) $ codes ; if ( empty ( $ codes ) ) { return ; } $ taxGroupRepository = $ this -> manager -> getRepository ( TaxGroup :: class ) ; $ taxRepository = $ this -> manager -> getRepository ( Tax :: class ) ; foreach ( $ codes as $ code ) { $ path = __DIR__ . '/data/' . $ code . '_tax_groups.yml' ; if ( ! ( file_exists ( $ path ) && is_readable ( $ path ) ) ) { call_user_func ( $ this -> log , 'Tax groups data' , 'not found' ) ; continue ; } $ data = Yaml :: parse ( file_get_contents ( $ path ) ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { continue ; } foreach ( $ data as $ datum ) { $ name = $ datum [ 'name' ] ; $ result = 'already exists' ; if ( $ datum [ 'default' ] ) { $ taxGroup = $ this -> manager -> getRepository ( TaxGroup :: class ) -> findOneBy ( [ 'default' => true ] ) ; if ( null !== $ taxGroup ) { call_user_func ( $ this -> log , $ name , 'skipped' ) ; continue ; } } if ( null === $ taxGroupRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ taxGroup = new TaxGroup ( ) ; $ taxGroup -> setName ( $ name ) -> setDefault ( $ datum [ 'default' ] ) ; if ( ! empty ( $ taxNames = $ datum [ 'taxes' ] ) ) { $ taxGroup -> setTaxes ( $ taxRepository -> findBy ( [ 'name' => $ taxNames ] ) ) ; } $ this -> manager -> persist ( $ taxGroup ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } } $ this -> manager -> flush ( ) ; }
12071	private function getCfgParamsByRanks ( ) { $ asParams = 'pbhcp' ; $ asRank = 'pbhr' ; $ tblParams = $ this -> resource -> getTableName ( CfgParam :: ENTITY_NAME ) ; $ tblRank = $ this -> resource -> getTableName ( Rank :: ENTITY_NAME ) ; $ query = $ this -> conn -> select ( ) ; $ query -> from ( [ $ asParams => $ tblParams ] ) ; $ on = "$asParams." . CfgParam :: A_RANK_ID . "=$asRank." . Rank :: A_ID ; $ cols = [ Rank :: A_CODE ] ; $ query -> joinLeft ( [ $ asRank => $ tblRank ] , $ on , $ cols ) ; $ entries = $ this -> conn -> fetchAll ( $ query ) ; $ result = [ ] ; foreach ( $ entries as $ entry ) { $ rankCode = $ entry [ Rank :: A_CODE ] ; $ rankScheme = $ entry [ CfgParam :: A_SCHEME ] ; $ result [ $ rankCode ] [ $ rankScheme ] = $ entry ; } return $ result ; }
12809	private static function isPrimaryKey ( string $ table , string $ column ) : bool { return self :: getPrimaryKey ( $ table ) [ "column_name" ] === $ column ; }
2292	public static function getTheme ( ) { $ theme = Config :: get ( 'backendTheme' ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( $ theme != '' && $ theme != 'flexible' && is_dir ( $ rootDir . '/system/themes/' . $ theme ) ) { return $ theme ; } return 'flexible' ; }
11239	public function run ( ) { if ( count ( $ this -> errors ) == 0 ) { return true ; } else { $ this -> controller -> setData ( 'errors' , $ this -> errors ) ; return false ; } }
1171	protected function getProtected ( $ instance , $ property ) { $ closure = function ( $ property ) { return $ this -> $ property ; } ; $ callback = $ closure -> bindTo ( $ instance , $ instance ) ; return $ callback ( $ property ) ; }
2608	public function getCurrentVersion ( array $ versions ) { if ( ! empty ( $ versions ) ) { foreach ( $ versions as $ version ) { if ( $ version -> active ) { return $ activeVersion = $ version -> number ; } } } throw new LocalizedException ( __ ( 'Error fetching current version.' ) ) ; }
11631	private function getTransitions ( $ dsBegin , $ dsEnd ) { $ assetTypeId = $ this -> daoTypeAsset -> getIdByCode ( Cfg :: CODE_TYPE_ASSET_PV ) ; $ dateFrom = $ this -> hlpPeriod -> getTimestampFrom ( $ dsBegin ) ; $ dateTo = $ this -> hlpPeriod -> getTimestampNextFrom ( $ dsEnd ) ; $ query = $ this -> aQGetData -> build ( ) ; $ bind = [ $ this -> aQGetData :: BND_ASSET_TYPE_ID => $ assetTypeId , $ this -> aQGetData :: BND_DATE_FROM => $ dateFrom , $ this -> aQGetData :: BND_DATE_TO => $ dateTo ] ; $ conn = $ query -> getConnection ( ) ; $ rs = $ conn -> fetchAll ( $ query , $ bind ) ; $ result = [ ] ; foreach ( $ rs as $ one ) { $ item = new \ Praxigento \ BonusHybrid \ Service \ Calc \ PvWriteOff \ A \ Data \ Trans ( $ one ) ; $ result [ ] = $ item ; } return $ result ; }
1038	private function executeFields ( ObjectType $ parentType , $ source , $ path , $ fields ) { $ containsPromise = false ; $ finalResults = [ ] ; foreach ( $ fields as $ responseName => $ fieldNodes ) { $ fieldPath = $ path ; $ fieldPath [ ] = $ responseName ; $ result = $ this -> resolveField ( $ parentType , $ source , $ fieldNodes , $ fieldPath ) ; if ( $ result === self :: $ UNDEFINED ) { continue ; } if ( ! $ containsPromise && $ this -> getPromise ( $ result ) ) { $ containsPromise = true ; } $ finalResults [ $ responseName ] = $ result ; } if ( ! $ containsPromise ) { return self :: fixResultsIfEmptyArray ( $ finalResults ) ; } return $ this -> promiseForAssocArray ( $ finalResults ) ; }
7224	public function exec ( $ keepAlive = false ) { $ this -> lastResult = curl_exec ( $ this -> curl ) ; $ this -> info = curl_getinfo ( $ this -> curl ) ; if ( ! $ keepAlive ) curl_close ( $ this -> curl ) ; return $ this -> lastResult !== false ; }
12228	public function removeSelf ( ) { $ tmp = dom_import_simplexml ( $ this ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { throw new BadMethodCallException ( 'removeSelf() cannot be used to remove the root node' ) ; } $ node = $ tmp -> parentNode -> removeChild ( $ tmp ) ; return simplexml_import_dom ( $ node , get_class ( $ this ) ) ; }
7444	public function createAction ( ) { $ group = new Group ( ) ; $ form = $ this -> createForm ( GroupType :: class , $ group ) ; $ form -> bindRequest ( $ this -> getRequest ( ) ) ; if ( $ form -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ em -> persist ( $ group ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The group has been created.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_group_show' , array ( 'id' => $ group -> getId ( ) ) ) ) ; } return array ( 'group' => $ group , 'form' => $ form -> createView ( ) ) ; }
9558	public function getUsage ( $ showRequiredFirst = true , $ customBinary = null , $ customScript = null ) { $ fullUsage = '' ; if ( $ customBinary == null ) { $ fullUsage = 'php ' ; } else { $ fullUsage = $ customBinary . ' ' ; } if ( $ customScript == null ) { $ fullUsage .= basename ( $ _SERVER [ 'SCRIPT_NAME' ] ) . ' ' ; } else { $ fullUsage .= $ customScript . ' ' ; } foreach ( $ this -> prefixes as $ prefix => $ parameters ) { if ( $ showRequiredFirst ) { usort ( $ parameters , function ( $ p1 , $ p2 ) { if ( $ p1 -> required && $ p2 -> required ) { return 0 ; } if ( $ p1 -> required && ! $ p2 -> required ) { return - 1 ; } if ( $ p2 -> required && ! $ p1 -> required ) { return 1 ; } } ) ; } foreach ( $ parameters as $ parameter ) { if ( $ parameter -> parent == null ) { $ fullUsage .= $ parameter -> getUsage ( ) . ' ' ; } } } return $ fullUsage ; }
6643	public static function decodeId ( $ hash , $ salt , $ hashLength = self :: MIN_HASH_LENGTH ) { $ hashIds = new Hashids ( $ salt , $ hashLength ) ; return ArrayHelper :: getValue ( $ hashIds -> decode ( $ hash ) , '0' ) ; }
1032	private function completeValue ( Type $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ promise = $ this -> getPromise ( $ result ) ; if ( $ promise ) { return $ promise -> then ( function ( & $ resolved ) use ( $ returnType , $ fieldNodes , $ info , $ path ) { return $ this -> completeValue ( $ returnType , $ fieldNodes , $ info , $ path , $ resolved ) ; } ) ; } if ( $ result instanceof Exception || $ result instanceof Throwable ) { throw $ result ; } if ( $ returnType instanceof NonNull ) { $ completed = $ this -> completeValue ( $ returnType -> getWrappedType ( ) , $ fieldNodes , $ info , $ path , $ result ) ; if ( $ completed === null ) { throw new InvariantViolation ( 'Cannot return null for non-nullable field ' . $ info -> parentType . '.' . $ info -> fieldName . '.' ) ; } return $ completed ; } if ( $ result === null ) { return null ; } if ( $ returnType instanceof ListOfType ) { return $ this -> completeListValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } if ( $ returnType !== $ this -> exeContext -> schema -> getType ( $ returnType -> name ) ) { $ hint = '' ; if ( $ this -> exeContext -> schema -> getConfig ( ) -> typeLoader ) { $ hint = sprintf ( 'Make sure that type loader returns the same instance as defined in %s.%s' , $ info -> parentType , $ info -> fieldName ) ; } throw new InvariantViolation ( sprintf ( 'Schema must contain unique named types but contains multiple types named "%s". %s ' . '(see http://webonyx.github.io/graphql-php/type-system/#type-registry).' , $ returnType , $ hint ) ) ; } if ( $ returnType instanceof LeafType ) { return $ this -> completeLeafValue ( $ returnType , $ result ) ; } if ( $ returnType instanceof AbstractType ) { return $ this -> completeAbstractValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } if ( $ returnType instanceof ObjectType ) { return $ this -> completeObjectValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } throw new RuntimeException ( sprintf ( 'Cannot complete value of unexpected type "%s".' , $ returnType ) ) ; }
4707	public function processMultipleUnderScore ( Text $ text ) { $ text -> replace ( '{<pre>.*?</pre>}m' , function ( Text $ w ) { $ md5 = md5 ( $ w ) ; $ this -> hashes [ $ md5 ] = $ w ; return "{gfm-extraction-$md5}" ; } ) ; $ text -> replace ( '/^(?! {4}|\t)(\[?\w+_\w+_\w[\w_]*\]?)/' , function ( Text $ w , Text $ word ) { $ underscores = $ word -> split ( '//' ) -> filter ( function ( Text $ item ) { return $ item == '_' ; } ) ; if ( count ( $ underscores ) >= 2 ) { $ word -> replaceString ( '_' , '\\_' ) ; } return $ word ; } ) ; $ text -> replace ( '/\{gfm-extraction-([0-9a-f]{32})\}/m' , function ( Text $ w , Text $ md5 ) { return "\n\n" . $ this -> hashes [ ( string ) $ md5 ] ; } ) ; }
4202	private function addMethodsPhpDoc ( Event $ abs ) { $ inheritedFrom = null ; if ( empty ( $ abs [ 'phpDoc' ] [ 'method' ] ) ) { if ( \ array_intersect_key ( $ abs [ 'methods' ] , \ array_flip ( array ( '__call' , '__callStatic' ) ) ) ) { $ reflector = $ abs [ 'reflector' ] ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ parsed = $ this -> phpDoc -> getParsed ( $ reflector ) ; if ( isset ( $ parsed [ 'method' ] ) ) { $ inheritedFrom = $ reflector -> getName ( ) ; $ abs [ 'phpDoc' ] [ 'method' ] = $ parsed [ 'method' ] ; break ; } } } if ( empty ( $ abs [ 'phpDoc' ] [ 'method' ] ) ) { return ; } } foreach ( $ abs [ 'phpDoc' ] [ 'method' ] as $ phpDocMethod ) { $ className = $ inheritedFrom ? $ inheritedFrom : $ abs [ 'className' ] ; $ abs [ 'methods' ] [ $ phpDocMethod [ 'name' ] ] = array ( 'implements' => null , 'inheritedFrom' => $ inheritedFrom , 'isAbstract' => false , 'isDeprecated' => false , 'isFinal' => false , 'isStatic' => $ phpDocMethod [ 'static' ] , 'params' => \ array_map ( function ( $ param ) use ( $ className ) { $ info = $ this -> phpDocParam ( $ param , $ className ) ; return array ( 'constantName' => $ info [ 'constantName' ] , 'defaultValue' => $ info [ 'defaultValue' ] , 'desc' => null , 'name' => $ param [ 'name' ] , 'optional' => false , 'type' => $ param [ 'type' ] , ) ; } , $ phpDocMethod [ 'param' ] ) , 'phpDoc' => array ( 'summary' => $ phpDocMethod [ 'desc' ] , 'description' => null , 'return' => array ( 'type' => $ phpDocMethod [ 'type' ] , 'desc' => null , ) ) , 'visibility' => 'magic' , ) ; } unset ( $ abs [ 'phpDoc' ] [ 'method' ] ) ; return ; }
7922	private function isValidPath ( $ path ) { $ pathParts = explode ( '/' , $ path ) ; if ( ! strncmp ( $ path , '/' , 1 ) || array_search ( '..' , $ pathParts ) !== false || strpos ( $ path , ':' ) !== false ) { return false ; } return true ; }
5291	public static function simpleDetect ( $ text ) { $ detections = self :: detect ( $ text ) ; if ( count ( $ detections ) > 0 ) return $ detections [ 0 ] -> language ; else return null ; }
12059	public function setTarget ( $ value ) { if ( in_array ( $ value , $ this -> possibleTargets ) ) { $ this -> _target = $ value ; } else { throw new Exception ( 'Unknown deletion target ' . $ value ) ; } }
5020	public function getFieldFlags ( $ field ) { if ( ! $ this -> hasField ( $ field ) ) { return [ ] ; } if ( ! isset ( $ this -> fields [ $ field ] [ '__flags__' ] ) ) { $ this -> fields [ $ field ] [ '__flags__' ] = $ this -> copyArrayValues ( $ this -> fields [ $ field ] , [ 'flags' => [ ] , 'order' => [ 'priority' ] , 'priority' ] ) ; } return $ this -> fields [ $ field ] [ '__flags__' ] ; }
8562	public function createShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_CreateShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CreateShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_CreateShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CreateShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_CreateShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5803	public function whitelist ( array $ whitelist ) { $ this -> _definitions = array ( ) ; foreach ( $ whitelist as $ definition ) { if ( is_object ( $ definition ) ) { if ( $ definition instanceof Definition \ IDefinition ) $ definitionObject = $ definition ; else throw new \ InvalidArgumentException ( 'Definition objects must implement IDefinition' ) ; } elseif ( preg_match ( '/[a-z:\/]/' , $ definition ) === 0 ) $ definitionObject = new Definition \ IPv4Address ( $ definition ) ; elseif ( preg_match ( '/[a-z:]/' , $ definition ) === 0 ) $ definitionObject = new Definition \ IPv4CIDR ( $ definition ) ; elseif ( preg_match ( '/^[0-9a-f:]+$/' , $ definition ) ) $ definitionObject = new Definition \ IPv6Address ( $ definition ) ; elseif ( preg_match ( '/^[0-9a-f:\/]+$/' , $ definition ) ) $ definitionObject = new Definition \ IPv6CIDR ( $ definition ) ; elseif ( preg_match ( '/^\*\.[\w\.\-]+$/' , $ definition ) ) $ definitionObject = new Definition \ WildcardDomain ( $ definition ) ; elseif ( preg_match ( '/^[\w\.\-]+$/' , $ definition ) ) $ definitionObject = new Definition \ Domain ( $ definition ) ; else throw new \ InvalidArgumentException ( 'Unable to parse definition "' . $ definition . '"' ) ; $ this -> _definitions [ ] = $ definitionObject ; } }
5780	private function setNav ( ) { $ this -> nav = [ 'System' => [ 'subSections' => [ 'Administrators' => [ 'route' => ROUTE_ADMINISTRATORS , 'authorization' => ADMINISTRATORS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_INSERT , 'authorization' => ADMINISTRATORS_INSERT_RESOURCE , ] , ] ] , 'Roles' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES , 'authorization' => ROLES_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES_INSERT , 'authorization' => ROLES_INSERT_RESOURCE , ] , ] , ] , 'Permissions' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS , 'authorization' => PERMISSIONS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS_INSERT , 'authorization' => PERMISSIONS_INSERT_RESOURCE , ] , ] ] , 'Events' => [ 'route' => ROUTE_EVENTS , 'authorization' => EVENTS_VIEW_RESOURCE , 'subSections' => [ 'Types' => [ 'route' => ROUTE_DATABASE_TABLES , 'args' => [ ROUTEARG_DATABASE_TABLE_NAME => 'event_types' ] , 'authorization' => EVENTS_VIEW_RESOURCE , ] , ] ] , 'Database' => [ 'authorization' => DATABASE_TABLES_VIEW_RESOURCE , 'subSections' => $ this -> getDatabaseTablesSection ( ) ] , ] ] , 'Logout' => [ 'route' => ROUTE_LOGOUT , ] , ] ; if ( isset ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { if ( ! is_array ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { throw new \ Exception ( "adminNav config must be array" ) ; } $ this -> nav = array_merge ( $ this -> container [ 'settings' ] [ 'adminNav' ] , $ this -> nav ) ; } }
6356	public static function convert ( $ style = TS_UNIX , $ ts ) { try { $ ct = new static ( $ ts ) ; return $ ct -> getTimestamp ( $ style ) ; } catch ( TimestampException $ e ) { return false ; } }
5049	public function __isset ( $ property ) { trigger_error ( sprintf ( 'Using isset() with entity properties is deprecated. Use %s::notEmpty("%s") instead.' , get_class ( $ this ) , $ property ) , E_USER_DEPRECATED ) ; return $ this -> notEmpty ( $ property ) ; }
4390	protected function getXmlProvider ( ) { $ provider = OPay :: create ( 'Datatrans\Xml' ) ; $ provider -> initialize ( $ this -> getServiceItem ( ) -> getConfig ( ) ) ; return $ provider ; }
6541	public function fetchOne ( $ tableName , array $ identifier , $ shardingKey = null , $ forceFromMaster = true ) { return $ this -> fetch ( $ tableName , $ identifier , $ shardingKey , array ( '*' ) , false , $ forceFromMaster ) ; }
9999	private function setShadowColor ( $ color , $ alpha , $ type ) { if ( $ color !== null ) { $ this -> shadowProperties [ 'color' ] [ 'value' ] = ( string ) $ color ; } if ( $ alpha !== null ) { $ this -> shadowProperties [ 'color' ] [ 'alpha' ] = $ this -> getTrueAlpha ( ( int ) $ alpha ) ; } if ( $ type !== null ) { $ this -> shadowProperties [ 'color' ] [ 'type' ] = ( string ) $ type ; } return $ this ; }
770	public function getIterator ( ) { $ value = $ this -> getValue ( ) ; if ( $ value instanceof QueryInterface ) { throw new InvalidConfigException ( 'The ArrayExpression class can not be iterated when the value is a QueryInterface object' ) ; } if ( $ value === null ) { $ value = [ ] ; } return new \ ArrayIterator ( $ value ) ; }
35	protected function printVersions ( CompletePackageInterface $ package , array $ versions , RepositoryInterface $ installedRepo ) { uasort ( $ versions , 'version_compare' ) ; $ versions = array_keys ( array_reverse ( $ versions ) ) ; if ( $ installedRepo -> hasPackage ( $ package ) ) { $ installedVersion = $ package -> getPrettyVersion ( ) ; $ key = array_search ( $ installedVersion , $ versions ) ; if ( false !== $ key ) { $ versions [ $ key ] = '<info>* ' . $ installedVersion . '</info>' ; } } $ versions = implode ( ', ' , $ versions ) ; $ this -> getIO ( ) -> write ( '<info>versions</info> : ' . $ versions ) ; }
9856	private function addContinue ( $ data ) { $ limit = $ this -> limit ; $ record = 0x003C ; $ tmp = substr ( $ data , 0 , 2 ) . pack ( 'v' , $ limit ) . substr ( $ data , 4 , $ limit ) ; $ header = pack ( 'vv' , $ record , $ limit ) ; $ data_length = strlen ( $ data ) ; for ( $ i = $ limit + 4 ; $ i < ( $ data_length - $ limit ) ; $ i += $ limit ) { $ tmp .= $ header ; $ tmp .= substr ( $ data , $ i , $ limit ) ; } $ header = pack ( 'vv' , $ record , strlen ( $ data ) - $ i ) ; $ tmp .= $ header ; $ tmp .= substr ( $ data , $ i ) ; return $ tmp ; }
8124	protected function findRecord ( $ data ) { if ( empty ( $ data [ "ID" ] ) ) { throw new HTTPResponse_Exception ( "No record ID" , 404 ) ; } $ page = null ; $ id = $ data [ "ID" ] ; if ( is_numeric ( $ id ) ) { $ page = SiteTree :: get ( ) -> byID ( $ id ) ; } if ( ! $ page || ! $ page -> ID ) { throw new HTTPResponse_Exception ( "Bad record ID #{$id}" , 404 ) ; } return $ page ; }
7742	public function supportsOperation ( $ operationName ) { foreach ( $ this -> operations as $ operation ) { if ( $ operation -> getName ( ) === $ operationName ) { return true ; } } return false ; }
9445	public function getEntityMappings ( Container $ app ) { static $ mappings = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ mappings [ $ me ] ) ) { $ subns = $ this -> packOptions [ 'entity_subnamespace' ] ; $ subns = trim ( $ subns , '\\' ) ; $ simple = $ this -> packOptions [ 'entity_use_simple_annotation' ] ; $ ns = $ this -> getReflector ( ) -> getNamespaceName ( ) . '\\' . $ subns ; $ subpath = str_replace ( '\\' , '/' , $ subns ) ; $ path = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) . '/' . $ subpath ; if ( is_dir ( $ path ) ) { $ mappings [ $ me ] = [ 'type' => 'annotation' , 'namespace' => $ ns , 'path' => $ path , 'use_simple_annotation_reader' => $ simple , ] ; } } if ( empty ( $ mappings [ $ me ] ) ) { return [ ] ; } return [ $ mappings [ $ me ] ] ; }
8594	public function listOrdersByNextToken ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenRequest ) ) { $ request = new MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListOrdersByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1417	public function failedValidator ( ValidatorContract $ validator , \ Closure $ closure = null ) : ErrorCollection { $ failed = $ this -> doesIncludeFailed ( ) ? $ validator -> failed ( ) : [ ] ; $ errors = new ErrorCollection ( ) ; foreach ( $ validator -> errors ( ) -> messages ( ) as $ key => $ messages ) { $ failures = $ this -> createValidationFailures ( $ failed [ $ key ] ?? [ ] ) ; foreach ( $ messages as $ detail ) { $ failed = $ failures -> shift ( ) ? : [ ] ; if ( $ closure ) { $ errors -> add ( $ this -> call ( $ closure , $ key , $ detail , $ failed ) ) ; continue ; } $ errors -> add ( new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'failed_validator' , 'code' ) , $ this -> trans ( 'failed_validator' , 'title' ) , $ detail ? : $ this -> trans ( 'failed_validator' , 'detail' ) ) ) ; } } return $ errors ; }
3590	public function allowsMeta ( $ key ) { $ allowed = $ this -> getAllowedMeta ( ) ; return empty ( $ allowed ) || in_array ( $ key , $ allowed ) ; }
8655	private function convertGetReportCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetAvailableFromDate ( ) ) { $ parameters [ 'AvailableFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableFromDate ( ) ) ; } if ( $ request -> isSetAvailableToDate ( ) ) { $ parameters [ 'AvailableToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
656	public function init ( ) { if ( $ this -> autoRelease ) { $ locks = & $ this -> _locks ; register_shutdown_function ( function ( ) use ( & $ locks ) { foreach ( $ locks as $ lock ) { $ this -> release ( $ lock ) ; } } ) ; } }
3093	public function process ( $ data , $ serviceContext ) { if ( empty ( $ data ) ) { throw new \ common_exception_InconsistentData ( 'No action to check. Processing action requires data.' ) ; } $ actions = [ ] ; $ duration = 0 ; foreach ( $ data as $ entry ) { $ action = $ this -> resolve ( $ entry ) ; $ actions [ ] = $ action ; if ( $ action -> hasRequestParameter ( 'itemDuration' ) ) { $ duration += $ action -> getRequestParameter ( 'itemDuration' ) + self :: TIMEPOINT_INTERVAL ; } } $ now = microtime ( true ) ; $ last = $ serviceContext -> getTestSession ( ) -> getTimer ( ) -> getLastRegisteredTimestamp ( ) ; $ elapsed = $ now - $ last ; if ( $ duration > $ elapsed ) { \ common_Logger :: t ( 'Ignoring the last timestamp to take into account the actual duration to sync. Could introduce TimeLine inconsistency!' ) ; $ last = $ now - $ duration ; } usort ( $ actions , function ( $ a , $ b ) { return $ a -> getTimestamp ( ) - $ b -> getTimestamp ( ) ; } ) ; $ response = [ ] ; foreach ( $ actions as $ action ) { try { $ serviceContext -> setSyncingMode ( $ action -> getRequestParameter ( 'offline' ) ) ; if ( $ action -> hasRequestParameter ( 'itemDuration' ) && $ serviceContext -> isSyncingMode ( ) ) { $ last += $ action -> getRequestParameter ( 'itemDuration' ) + self :: TIMEPOINT_INTERVAL ; $ action -> setTime ( $ last ) ; } else { $ action -> setTime ( $ now ) ; } $ action -> setServiceContext ( $ serviceContext ) ; if ( $ serviceContext instanceof QtiRunnerServiceContext ) { } $ responseAction = $ action -> process ( ) ; } catch ( \ common_Exception $ e ) { $ responseAction = [ 'error' => $ e -> getMessage ( ) ] ; $ responseAction [ 'success' ] = false ; } $ responseAction [ 'name' ] = $ action -> getName ( ) ; $ responseAction [ 'timestamp' ] = $ action -> getTimeStamp ( ) ; $ responseAction [ 'requestParameters' ] = $ action -> getRequestParameters ( ) ; $ response [ ] = $ responseAction ; if ( $ responseAction [ 'success' ] === false ) { break ; } } $ this -> getRunnerService ( ) -> persist ( $ serviceContext ) ; return $ response ; }
399	protected function deleteInternal ( ) { if ( ! $ this -> beforeDelete ( ) ) { return false ; } $ condition = $ this -> getOldPrimaryKey ( true ) ; $ lock = $ this -> optimisticLock ( ) ; if ( $ lock !== null ) { $ condition [ $ lock ] = $ this -> $ lock ; } $ result = static :: deleteAll ( $ condition ) ; if ( $ lock !== null && ! $ result ) { throw new StaleObjectException ( 'The object being deleted is outdated.' ) ; } $ this -> setOldAttributes ( null ) ; $ this -> afterDelete ( ) ; return $ result ; }
4360	public static function dump ( $ str , $ useHtml = false , $ sanitizeNonBinary = false ) { self :: $ useHtml = $ useHtml ; self :: $ sanitizeNonBinary = $ sanitizeNonBinary ; self :: setStr ( $ str ) ; $ controlCharAs = 'other' ; $ curBlockType = 'utf8' ; $ newBlockType = null ; $ curBlockStart = 0 ; $ strNew = '' ; while ( self :: $ curI < self :: $ stats [ 'strLen' ] ) { $ curI = self :: $ curI ; $ isUtf8 = self :: isOffsetUtf8 ( $ isSpecial , true ) ; if ( $ isUtf8 && $ isSpecial && $ controlCharAs !== 'utf8special' && \ ord ( $ str [ $ curI ] ) < 0x80 ) { if ( $ controlCharAs == 'other' ) { $ isUtf8 = false ; } elseif ( $ controlCharAs == 'utf8' ) { $ isSpecial = false ; } } if ( $ isUtf8 ) { if ( $ isSpecial ) { if ( $ curBlockType !== 'utf8special' ) { $ newBlockType = 'utf8special' ; } } else { if ( $ curBlockType !== 'utf8' ) { $ newBlockType = 'utf8' ; } } } else { if ( $ curBlockType !== 'other' ) { $ newBlockType = 'other' ; } } if ( $ newBlockType ) { $ len = $ curI - $ curBlockStart ; self :: incStat ( $ curBlockType , $ len ) ; $ subStr = \ substr ( self :: $ str , $ curBlockStart , $ len ) ; $ strNew .= self :: dumpBlock ( $ subStr , $ curBlockType ) ; $ curBlockStart = $ curI ; $ curBlockType = $ newBlockType ; $ newBlockType = null ; } } $ len = self :: $ stats [ 'strLen' ] - $ curBlockStart ; self :: incStat ( $ curBlockType , $ len ) ; if ( self :: $ stats [ 'strLen' ] ) { $ percentOther = ( self :: $ stats [ 'bytesOther' ] ) / self :: $ stats [ 'strLen' ] * 100 ; if ( $ percentOther > 33 ) { $ strNew = self :: dumpBlock ( $ str , 'other' , array ( 'prefix' => false ) ) ; } else { $ subStr = \ substr ( self :: $ str , $ curBlockStart , $ len ) ; $ strNew .= self :: dumpBlock ( $ subStr , $ curBlockType ) ; } } return $ strNew ; }
11401	public function startAt ( $ startAt = 0 ) { if ( ! is_numeric ( $ startAt ) || $ startAt < 0 ) { throw new Exception ( "startAt: bad value" , 10 ) ; } $ this -> startAt = $ startAt ; return $ this ; }
10623	public static function synchronizeMigrations ( CommandEvent $ event ) { $ packages = $ event -> getComposer ( ) -> getRepositoryManager ( ) -> getLocalRepository ( ) -> getPackages ( ) ; $ installer = $ event -> getComposer ( ) -> getInstallationManager ( ) ; $ appMigrationDir = self :: getDestinationDir ( $ event -> getComposer ( ) ) ; $ io = $ event -> getIO ( ) ; $ areFileMigrated = array ( ) ; $ areFileMigrated [ ] = self :: handlePackage ( '.' , $ event -> getComposer ( ) -> getPackage ( ) , $ io , $ appMigrationDir ) ; foreach ( $ packages as $ package ) { $ areFileMigrated [ ] = self :: handlePackage ( $ installer -> getInstallPath ( $ package ) , $ package , $ io , $ appMigrationDir ) ; } if ( in_array ( true , $ areFileMigrated ) ) { $ io -> write ( "<warning>Some migration files have been imported. " . "You should run `php app/console doctrine:migrations:status` and/or " . "`php app/console doctrine:migrations:migrate` to apply them to your DB." ) ; } }
7364	protected function updateInvoiceTotal ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return false ; } $ changed = false ; $ invoice = $ this -> invoiceCalculator -> calculateInvoiceTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ invoice , $ sale -> getInvoiceTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setInvoiceTotal ( $ invoice ) ; $ changed = true ; } $ credit = $ this -> invoiceCalculator -> calculateCreditTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ credit , $ sale -> getCreditTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setCreditTotal ( $ credit ) ; $ changed = true ; } return $ changed ; }
1788	public function editArticle ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ objPage = Contao \ PageModel :: findById ( $ row [ 'pid' ] ) ; return $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLES , $ objPage -> row ( ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
10098	public function setOutline ( $ visible = true , $ symbols_below = true , $ symbols_right = true , $ auto_style = false ) { $ this -> outlineOn = $ visible ; $ this -> outlineBelow = $ symbols_below ; $ this -> outlineRight = $ symbols_right ; $ this -> outlineStyle = $ auto_style ; if ( $ this -> outlineOn ) { $ this -> outlineOn = 1 ; } }
8884	private function buildPackages ( $ number , $ weight , $ measurement = 'LBS' ) { $ packages = array ( ) ; if ( $ number > 1 ) { $ individual_weight = $ weight / $ number ; for ( $ i = 0 ; $ i < $ number ; $ i ++ ) { $ packages [ ] = '<Package> <PackagingType> <Code>02</Code> </PackagingType> <PackageWeight> <UnitOfMeasurement> <Code>' . $ measurement . '</Code> </UnitOfMeasurement> <Weight>' . $ individual_weight . '</Weight> </PackageWeight> </Package>' ; } } else { $ packages [ ] = '<Package> <PackagingType> <Code>02</Code> </PackagingType> <PackageWeight> <UnitOfMeasurement> <Code>' . $ measurement . '</Code> </UnitOfMeasurement> <Weight>' . $ weight . '</Weight> </PackageWeight> </Package>' ; } return implode ( '' , $ packages ) ; }
2814	public function getBlock ( $ blockName ) { if ( ! array_key_exists ( $ blockName , $ this -> blocks ) ) { throw new Exception ( 'Unable to find block with name ' . $ blockName ) ; } return $ this -> blocks [ $ blockName ] ; }
2747	public function getGeoIpMappingForCountry ( $ countryCode ) { if ( $ mapping = $ this -> _scopeConfig -> getValue ( self :: XML_FASTLY_GEOIP_COUNTRY_MAPPING ) ) { return $ this -> extractMapping ( $ mapping , $ countryCode ) ; } return null ; }
2006	protected function removeRecipient ( $ strEmail , $ arrRemove ) { if ( ( $ objRemove = NewsletterRecipientsModel :: findByEmailAndPids ( $ strEmail , $ arrRemove ) ) !== null ) { while ( $ objRemove -> next ( ) ) { $ strHash = md5 ( $ objRemove -> email ) ; if ( ( $ objBlacklist = NewsletterBlacklistModel :: findByHashAndPid ( $ strHash , $ objRemove -> pid ) ) === null ) { $ objBlacklist = new NewsletterBlacklistModel ( ) ; $ objBlacklist -> pid = $ objRemove -> pid ; $ objBlacklist -> hash = $ strHash ; $ objBlacklist -> save ( ) ; } $ objRemove -> delete ( ) ; } } $ objChannels = NewsletterChannelModel :: findByIds ( $ arrRemove ) ; $ arrChannels = $ objChannels -> fetchEach ( 'title' ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strEmail , $ arrRemove ) ; } } $ arrData = array ( ) ; $ arrData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrData [ 'channel' ] = $ arrData [ 'channels' ] = implode ( "\n" , $ arrChannels ) ; $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_subject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ this -> nl_unsubscribe , $ arrData ) ; $ objEmail -> sendTo ( $ strEmail ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'nl_removed' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_removed' ] ) ; $ this -> reload ( ) ; }
6526	public static function resolveId ( SchemaId $ id ) : string { $ curieMajor = $ id -> getCurieMajor ( ) ; if ( isset ( self :: $ curies [ $ curieMajor ] ) ) { return self :: $ classes [ self :: $ curies [ $ curieMajor ] ] ; } $ curie = $ id -> getCurie ( ) -> toString ( ) ; if ( isset ( self :: $ curies [ $ curie ] ) ) { return self :: $ classes [ self :: $ curies [ $ curie ] ] ; } throw new NoMessageForSchemaId ( $ id ) ; }
8226	protected function validateRegistration ( array $ reg ) { $ isValid = true ; try { $ this -> storage -> checkValidName ( $ reg [ "username" ] ) ; } catch ( \ RuntimeException $ e ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , $ e -> getMessage ( ) ) ; } $ min = $ this -> config [ "nameLenMin" ] ; $ max = $ this -> config [ "nameLenMax" ] ; if ( strlen ( $ reg [ "username" ] ) < $ min || strlen ( $ reg [ "username" ] ) > $ max ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , sprintf ( "Length of a username must be between %d-%d characters." , $ min , $ max ) ) ; } if ( ! filter_var ( $ reg [ "email" ] , FILTER_VALIDATE_EMAIL ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "Email address does not have a valid format." ) ; } if ( null !== $ this -> storage -> getUserByEmail ( $ reg [ "email" ] ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "This email is already in use." ) ; } if ( $ reg [ "password" ] -> get ( ) !== $ reg [ "passwordRepeat" ] -> get ( ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> checkPasswordPolicy ( $ reg [ "password" ] ) ) { $ isValid = false ; } if ( $ this -> storage -> getUserByName ( $ reg [ "username" ] ) !== null ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "The username is already taken." ) ; } return $ isValid ; }
8568	public function setCategoryQueryList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'CategoryQueryList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3884	private function createSetting ( $ dbResult , $ filterSettings ) { $ factory = $ this -> getTypeFactory ( $ dbResult [ 'type' ] ) ; if ( $ factory ) { $ setting = $ factory -> createInstance ( $ dbResult , $ filterSettings ) ; if ( ! $ setting ) { return null ; } if ( $ factory -> isNestedType ( ) ) { $ this -> collectRulesFor ( $ setting , $ filterSettings ) ; } return $ setting ; } return null ; }
6155	protected function convertValue ( $ value ) { switch ( $ this -> propertyType -> getDataTypeId ( ) ) { case PropertyType :: DATATYPE_BOOLEAN : return ( bool ) $ value ; break ; case PropertyType :: DATATYPE_DATETIME : if ( $ value instanceof \ DateTime ) { return $ value ; } try { return new \ DateTime ( $ value ) ; } catch ( \ Exception $ e ) { return null ; } break ; case PropertyType :: DATATYPE_FLOAT : return ( float ) $ value ; break ; case PropertyType :: DATATYPE_INTEGER : return ( int ) $ value ; break ; case PropertyType :: DATATYPE_STRING : return ( string ) $ value ; break ; default : return $ value ; break ; } }
8932	public function loadDependencies ( ) { $ config = ConfigService :: fetch ( dirname ( __DIR__ ) ) ; $ config = array_merge ( $ config , ConfigService :: fetch ( ) ) ; $ moduleService = new ModuleService ; if ( ! array_key_exists ( 'slim-api' , $ config ) ) { $ config [ 'slim-api' ] = [ 'modules' => [ 'SlimApi\Phinx' , 'SlimApi\Mvc' ] ] ; } else { require 'vendor/autoload.php' ; } foreach ( $ config [ 'slim-api' ] [ 'modules' ] as $ moduleNamespace ) { $ config = array_merge ( $ config , $ moduleService -> load ( $ moduleNamespace ) ) ; } return $ config ; }
10704	public function getModel ( ) { if ( null === $ this -> model ) { $ mainService = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ this -> model = $ mainService -> getUserEntityRepository ( ) ; } return $ this -> model ; }
534	protected function fixFileDoc ( & $ lines ) { $ namespace = false ; $ namespaceLine = '' ; $ contentAfterNamespace = false ; foreach ( $ lines as $ i => $ line ) { $ line = trim ( $ line ) ; if ( ! empty ( $ line ) ) { if ( strncmp ( $ line , 'namespace' , 9 ) === 0 ) { $ namespace = $ i ; $ namespaceLine = $ line ; } elseif ( $ namespace !== false ) { $ contentAfterNamespace = $ i ; break ; } } } if ( $ namespace !== false && $ contentAfterNamespace !== false ) { while ( $ contentAfterNamespace > 0 ) { array_shift ( $ lines ) ; $ contentAfterNamespace -- ; } $ lines = array_merge ( [ '<?php' , '/**' , ' * @link http://www.yiiframework.com/' , ' * @copyright Copyright (c) 2008 Yii Software LLC' , ' * @license http://www.yiiframework.com/license/' , ' */' , '' , $ namespaceLine , '' , ] , $ lines ) ; } }
4690	public function addGroupBy ( $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> group [ ] = $ expression ; $ this -> pushArgs ( 'group' , $ args ) ; return $ this ; }
11474	public function setObject ( $ object ) { if ( is_null ( $ this -> _objectType ) ) { $ this -> objectType = $ object -> objectType ; } $ this -> _object = $ object ; }
10198	private function writeRows ( XMLWriter $ objWriter , Worksheet $ sheet ) { $ numberRowsRepeated = self :: NUMBER_ROWS_REPEATED_MAX ; $ span_row = 0 ; $ rows = $ sheet -> getRowIterator ( ) ; while ( $ rows -> valid ( ) ) { -- $ numberRowsRepeated ; $ row = $ rows -> current ( ) ; if ( $ row -> getCellIterator ( ) -> valid ( ) ) { if ( $ span_row ) { $ objWriter -> startElement ( 'table:table-row' ) ; if ( $ span_row > 1 ) { $ objWriter -> writeAttribute ( 'table:number-rows-repeated' , $ span_row ) ; } $ objWriter -> startElement ( 'table:table-cell' ) ; $ objWriter -> writeAttribute ( 'table:number-columns-repeated' , self :: NUMBER_COLS_REPEATED_MAX ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ span_row = 0 ; } $ objWriter -> startElement ( 'table:table-row' ) ; $ this -> writeCells ( $ objWriter , $ row ) ; $ objWriter -> endElement ( ) ; } else { ++ $ span_row ; } $ rows -> next ( ) ; } }
1386	protected function memberFieldsNotAllowed ( string $ path , string $ member , iterable $ fields ) : void { foreach ( $ fields as $ field ) { $ this -> errors -> add ( $ this -> translator -> memberFieldNotAllowed ( $ path , $ member , $ field ) ) ; } }
11422	public function get ( $ openId , $ lang = 'zh_CN' ) { $ params = [ 'openid' => $ openId , 'lang' => $ lang , ] ; return $ this -> parseJSON ( 'get' , [ self :: API_GET , $ params ] ) ; }
7621	public function permissionMatchesRequest ( $ permissionUrl = '' , $ requestUrl = '' , $ resourceType = Storage :: RESOURCE_UNKNOWN , $ requiredPermission = CredentialsAbstract :: PERMISSION_READ ) { $ requiredResourceType = $ resourceType ; if ( $ requiredResourceType == Storage :: RESOURCE_BLOB ) { $ requiredResourceType .= Storage :: RESOURCE_CONTAINER ; } $ parsedPermissionUrl = parse_url ( $ permissionUrl ) ; $ permissionParts = explode ( '&' , $ parsedPermissionUrl [ 'query' ] ) ; $ parsedRequestUrl = parse_url ( $ requestUrl ) ; $ matches = true ; foreach ( $ permissionParts as $ part ) { list ( $ property , $ value ) = explode ( '=' , $ part , 2 ) ; if ( $ property == 'sr' ) { $ matches = $ matches && ( strpbrk ( $ value , $ requiredResourceType ) !== false ) ; } if ( $ property == 'sp' ) { $ matches = $ matches && ( strpbrk ( $ value , $ requiredPermission ) !== false ) ; } } $ matches = $ matches && ( strpos ( $ parsedRequestUrl [ 'path' ] , $ parsedPermissionUrl [ 'path' ] ) !== false ) ; return $ matches ; }
5965	public function channelGroupPermList ( $ cgid , $ permsid = false ) { return $ this -> execute ( "channelgrouppermlist" , array ( "cgid" => $ cgid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
3970	protected function attributeIdToName ( IMetaModel $ metaModel , $ attributeId ) { if ( null === $ attribute = $ metaModel -> getAttributeById ( $ attributeId ) ) { throw new \ RuntimeException ( sprintf ( 'Could not retrieve attribute %s from MetaModel %s.' , $ attributeId , $ metaModel -> getTableName ( ) ) ) ; } return $ attribute -> getColName ( ) ; }
2850	public function setTemplateHints ( $ status ) { $ this -> deleteTemplateHintsDbConfigs ( ) ; $ config = $ this -> getConfig ( ) ; $ config -> saveConfig ( 'dev/debug/template_hints' , ( int ) $ status ) ; $ config -> saveConfig ( 'dev/debug/template_hints_blocks' , ( int ) $ status ) ; }
216	public function asNtext ( $ value ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return nl2br ( Html :: encode ( $ value ) ) ; }
7670	function ServerHostname ( ) { if ( $ this -> Hostname != "" ) $ result = $ this -> Hostname ; elseif ( $ this -> ServerVar ( 'SERVER_NAME' ) != "" ) $ result = $ this -> ServerVar ( 'SERVER_NAME' ) ; else $ result = "localhost.localdomain" ; return $ result ; }
6962	public static function B ( $ year ) { $ jd = static :: B1900 ( ) -> jd + ( $ year - 1900 ) * static :: DaysBesselianYear ; $ epoch = new static ( $ jd ) ; $ epoch -> type = YearType :: Besselian ( ) ; return $ epoch ; }
10588	public function buildChargeFromTransaction ( $ sTxnID ) { $ oCharge = new Freeagent \ DataWrapper \ ChargeVO ( ) ; try { $ oDets = $ this -> getTxnChargeDetails ( $ sTxnID ) ; $ oCharge -> setId ( $ sTxnID ) -> setGateway ( 'paypalexpress' ) -> setPaymentTerms ( 1 ) -> setAmount_Gross ( $ oDets -> GrossAmount -> value ) -> setAmount_Fee ( $ oDets -> FeeAmount -> value ) -> setAmount_Net ( $ oDets -> GrossAmount -> value - $ oDets -> FeeAmount -> value ) -> setDate ( strtotime ( $ oDets -> PaymentDate ) ) -> setCurrency ( $ oDets -> GrossAmount -> currencyID ) ; } catch ( \ Exception $ oE ) { } return $ oCharge ; }
6749	public function transformCollection ( $ collection ) { if ( is_object ( $ collection ) ) $ collection = $ collection -> toArray ( ) [ "data" ] ; return array_map ( [ $ this , "transform" ] , $ collection ) ; }
9695	private function applyInlineStyle ( & $ sheet , $ row , $ column , $ attributeArray ) { if ( ! isset ( $ attributeArray [ 'style' ] ) ) { return ; } $ supported_styles = [ 'background-color' , 'color' ] ; $ styles = explode ( ';' , $ attributeArray [ 'style' ] ) ; foreach ( $ styles as $ st ) { $ value = explode ( ':' , $ st ) ; if ( empty ( trim ( $ value [ 0 ] ) ) || ! in_array ( trim ( $ value [ 0 ] ) , $ supported_styles ) ) { continue ; } if ( substr ( trim ( $ value [ 1 ] ) , 0 , 1 ) == '#' ) { $ style_color = substr ( trim ( $ value [ 1 ] ) , 1 ) ; } if ( empty ( $ style_color ) ) { continue ; } switch ( trim ( $ value [ 0 ] ) ) { case 'background-color' : $ sheet -> getStyle ( $ column . $ row ) -> applyFromArray ( [ 'fill' => [ 'fillType' => Fill :: FILL_SOLID , 'color' => [ 'rgb' => "{$style_color}" ] ] ] ) ; break ; case 'color' : $ sheet -> getStyle ( $ column . $ row ) -> applyFromArray ( [ 'font' => [ 'color' => [ 'rgb' => "$style_color}" ] ] ] ) ; break ; } } }
280	private function confirmLoad ( $ fixtures , $ except ) { $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n\n" , Console :: FG_GREEN ) ; if ( count ( $ this -> globalFixtures ) ) { $ this -> stdout ( "Global fixtures will be used:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ this -> globalFixtures ) ; } if ( count ( $ fixtures ) ) { $ this -> stdout ( "\nFixtures below will be loaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ fixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be loaded: \n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } $ this -> stdout ( "\nBe aware that:\n" , Console :: BOLD ) ; $ this -> stdout ( "Applying leads to purging of certain data in the database!\n" , Console :: FG_RED ) ; return $ this -> confirm ( "\nLoad above fixtures?" ) ; }
5961	public function serverGroupGetByName ( $ name , $ type = TeamSpeak3 :: GROUP_DBTYPE_REGULAR ) { foreach ( $ this -> serverGroupList ( ) as $ group ) { if ( $ group [ "name" ] == $ name && $ group [ "type" ] == $ type ) { return $ group ; } } throw new Ts3Exception ( "invalid groupID" , 0xA00 ) ; }
4112	public function searchFullPath ( $ filename ) { $ paths = explode ( PATH_SEPARATOR , get_include_path ( ) ) ; foreach ( $ paths as $ path ) { $ fullPath = $ path . DIRECTORY_SEPARATOR . $ filename ; if ( file_exists ( $ fullPath ) ) { return $ fullPath ; } } return false ; }
10328	public function getNestingLevel ( ) { $ nestingLevel = 0 ; $ parent = $ this -> getParent ( ) ; while ( $ parent instanceof SpgrContainer ) { ++ $ nestingLevel ; $ parent = $ parent -> getParent ( ) ; } return $ nestingLevel ; }
3135	public function getItemState ( RunnerServiceContext $ context , $ itemRef ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ serviceService = $ this -> getServiceManager ( ) -> get ( StorageManager :: SERVICE_ID ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ stateId = $ this -> getStateId ( $ context , $ itemRef ) ; $ state = is_null ( $ userUri ) ? null : $ serviceService -> get ( $ userUri , $ stateId ) ; if ( $ state ) { $ state = json_decode ( $ state , true ) ; if ( is_null ( $ state ) ) { throw new \ common_exception_InconsistentData ( 'Unable to decode the state for the item ' . $ itemRef ) ; } } return $ state ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getItemState' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
3538	public function queryLdapUserObject ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'queryLdapUserObject' , static :: YII2_PROFILE_NAME . 'queryLdapUserObject' ) ; } if ( $ this -> ldapUserObject == null ) { if ( $ this -> username == null ) { throw new \ yii \ base \ Exception ( 'Please set username attribute before calling queryLdapUserObject() function.' ) ; } $ userObjectsFound = static :: getAdldapProvider ( ) -> search ( ) -> where ( 'sAMAccountname' , '=' , $ this -> username ) -> get ( ) ; if ( count ( $ userObjectsFound ) != 1 ) { $ this -> ldapUserObject = null ; } else { $ this -> ldapUserObject = $ userObjectsFound [ 0 ] ; } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'queryLdapUserObject' , static :: YII2_PROFILE_NAME . 'queryLdapUserObject' ) ; } return $ this -> ldapUserObject ; }
3003	public function attachFile ( $ path , $ alias = null , $ cid = null ) { $ this -> smtp -> attach ( $ path , $ alias , $ cid ) ; }
9386	public function retrieve ( $ httpMethod , $ uri ) { $ route = array ( $ httpMethod , $ uri ) ; $ routes = array_map ( function ( $ route ) { return array ( $ route [ 0 ] , $ route [ 1 ] ) ; } , $ this -> routes ) ; $ key = array_search ( $ route , $ routes ) ; return $ key !== false ? $ this -> routes [ $ key ] : null ; }
3819	private function checkboxCaption ( $ key , $ table , IAttribute $ attribute ) { return $ this -> translator -> trans ( $ table . '.' . $ key , [ $ attribute -> getName ( ) ] , 'contao_' . $ table ) ; }
5364	protected function fix ( $ directory ) { if ( ! class_exists ( 'PhpCsFixer\Config' ) ) { return ; } $ fixerConfig = $ this -> fixerConfig ; if ( null === $ fixerConfig ) { $ fixerConfig = Config :: create ( ) -> setRiskyAllowed ( true ) -> setRules ( array ( '@Symfony' => true , 'array_syntax' => array ( 'syntax' => 'short' ) , 'simplified_null_return' => false , 'ordered_imports' => true , 'phpdoc_order' => true , 'binary_operator_spaces' => array ( 'align_equals' => true ) , 'concat_space' => false , 'yoda_style' => false , 'header_comment' => [ 'header' => <<<EOHThis file has been auto generated by Jane,Do no edit it directly.EOH , ] ) ) ; } $ resolverOptions = array ( 'allow-risky' => true ) ; $ resolver = new ConfigurationResolver ( $ fixerConfig , $ resolverOptions , $ directory , new ToolInfo ( ) ) ; $ finder = new Finder ( ) ; $ finder -> in ( $ directory ) ; $ fixerConfig -> setFinder ( $ finder ) ; $ runner = new Runner ( $ resolver -> getConfig ( ) -> getFinder ( ) , $ resolver -> getFixers ( ) , new NullDiffer ( ) , null , new ErrorsManager ( ) , new Linter ( ) , false , new NullCacheManager ( ) ) ; return $ runner -> fix ( ) ; }
11971	public function handleCommand ( Event $ event , Queue $ queue ) { if ( $ this -> validateParams ( $ event ) ) { $ params = $ event -> getCustomParams ( ) ; $ results = array ( ) ; $ total = 0 ; $ count = $ params [ 0 ] ; $ sides = ( isset ( $ params [ 1 ] ) ) ? $ params [ 1 ] : $ this -> defaultDieSides ; for ( $ roll = 1 ; $ roll <= $ count ; $ roll ++ ) { $ rollResult = $ this -> doRoll ( $ sides ) ; $ results [ ] = $ rollResult ; $ total += $ rollResult ; } $ response = $ this -> generateResponse ( $ event , $ total , $ results ) ; $ this -> sendIrcResponseLine ( $ event , $ queue , $ response ) ; } else { $ this -> handleCommandHelp ( $ event , $ queue ) ; } }
8118	public function Form ( $ object ) { $ placeholder = _t ( __CLASS__ . '.Placeholder' , 'Add comments (optional)' ) ; $ title = _t ( __CLASS__ . '.MarkAsReviewedAction' , 'Mark as reviewed' ) ; $ fields = FieldList :: create ( [ HiddenField :: create ( 'ID' , null , $ object -> ID ) , HiddenField :: create ( 'ClassName' , null , $ object -> baseClass ( ) ) , TextareaField :: create ( 'Review' , '' ) -> setAttribute ( 'placeholder' , $ placeholder ) -> setSchemaData ( [ 'attributes' => [ 'placeholder' => $ placeholder ] ] ) ] ) ; $ action = FormAction :: create ( 'savereview' , $ title ) -> setTitle ( $ title ) -> setUseButtonTag ( false ) -> addExtraClass ( 'review-content__action btn btn-primary' ) ; $ actions = FieldList :: create ( [ $ action ] ) ; $ form = Form :: create ( $ this -> controller , $ this -> name , $ fields , $ actions ) -> setHTMLID ( 'Form_EditForm_ReviewContent' ) -> addExtraClass ( 'form--no-dividers review-content__form' ) ; return $ form ; }
9403	public static function get ( ContainerInterface $ container , array $ components = array ( ) , & $ globals = null ) { $ configuration = new Configuration ; $ collection = new Collection ; foreach ( ( array ) $ components as $ component ) { $ instance = self :: prepare ( $ collection , $ component ) ; $ container = $ instance -> define ( $ container , $ configuration ) ; } $ collection -> setContainer ( $ container ) ; $ globals === null || $ globals [ 'container' ] = $ container ; return $ collection ; }
5577	public function clickImage ( $ label , $ x = 1 , $ y = 1 , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormByImage ( new SelectByLabel ( $ label ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitImage ( new SelectByLabel ( $ label ) , $ x , $ y , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
3518	public function setShowUnpublished ( $ showUnpublished ) { if ( $ this -> useCookies ) { Cookie :: queue ( $ this -> cookiePrefix . 'show_unpublished' , $ showUnpublished ) ; } $ this -> useDB = $ showUnpublished ? 2 : 1 ; }
4199	public function addConstants ( Event $ abs ) { if ( ! $ this -> abstracter -> getCfg ( 'collectConstants' ) ) { return ; } $ reflector = $ abs [ 'reflector' ] ; $ constants = $ reflector -> getConstants ( ) ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ constants = \ array_merge ( $ reflector -> getConstants ( ) , $ constants ) ; } if ( $ this -> abstracter -> getCfg ( 'objectSort' ) == 'name' ) { \ ksort ( $ constants ) ; } $ abs [ 'constants' ] = $ constants ; }
5168	private function convertNonAscii ( string $ string ) : string { $ search = $ replace = [ ] ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 152 ) ; $ replace [ ] = "'" ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 153 ) ; $ replace [ ] = "'" ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 156 ) ; $ replace [ ] = '"' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 157 ) ; $ replace [ ] = '"' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 147 ) ; $ replace [ ] = '--' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 148 ) ; $ replace [ ] = '---' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 162 ) ; $ replace [ ] = '*' ; $ search [ ] = chr ( 194 ) . chr ( 183 ) ; $ replace [ ] = '*' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 166 ) ; $ replace [ ] = '...' ; $ string = str_replace ( $ search , $ replace , $ string ) ; return preg_replace ( "/[^\x01-\x7F]/" , '' , $ string ) ; }
5211	public function convert ( Node $ node , $ parentPrecedence , $ parentAssociativity , $ childPosition ) { $ type = $ node -> getType ( ) ; if ( $ this -> dispatcher -> issetPrecedenceMap ( $ type ) === true ) { $ childPrecedences = $ this -> dispatcher -> getPrecedenceMap ( $ type ) ; $ childPrecedence = $ childPrecedences [ 0 ] ; if ( $ childPrecedence > $ parentPrecedence || ( $ parentPrecedence == $ childPrecedence && $ parentAssociativity != $ childPosition ) ) { return '(' . $ this -> dispatcher -> { 'p' . $ type } ( $ node ) . ')' ; } } return $ this -> dispatcher -> { 'p' . $ type } ( $ node ) ; }
3874	protected function removeEmptyDetailPages ( $ jumpTos ) { foreach ( $ jumpTos as $ jumpTo ) { $ event = new GetPageDetailsEvent ( $ jumpTo [ 'value' ] ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; $ pageDetails = $ event -> getPageDetails ( ) ; if ( $ pageDetails === null ) { continue ; } $ baseUrl = $ this -> getBaseUrl ( $ pageDetails ) ; if ( ( $ strKey = array_search ( $ baseUrl -> getUrl ( ) , $ this -> foundPages ) ) !== false ) { unset ( $ this -> foundPages [ $ strKey ] ) ; } $ baseUrl = $ this -> getBaseUrl ( $ pageDetails , null , true ) ; if ( ( $ strKey = array_search ( $ baseUrl -> getUrl ( ) , $ this -> foundPages ) ) !== false ) { unset ( $ this -> foundPages [ $ strKey ] ) ; } } }
562	public static function debug ( $ message , $ category = 'application' ) { if ( YII_DEBUG ) { static :: getLogger ( ) -> log ( $ message , Logger :: LEVEL_TRACE , $ category ) ; } }
6354	public static function setFakeTime ( $ fakeTime ) { if ( is_string ( $ fakeTime ) ) { $ fakeTime = ( int ) static :: convert ( TS_UNIX , $ fakeTime ) ; } if ( is_int ( $ fakeTime ) ) { $ fakeTime = function ( ) use ( $ fakeTime ) { return $ fakeTime ; } ; } $ old = static :: $ fakeTimeCallback ; static :: $ fakeTimeCallback = $ fakeTime ? $ fakeTime : null ; return $ old ; }
441	public function hasMethod ( $ name , $ checkBehaviors = true ) { if ( method_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> hasMethod ( $ name ) ) { return true ; } } } return false ; }
9994	public function formatColor ( $ pValue , $ pFormat ) { $ color = null ; $ matches = [ ] ; $ color_regex = '/^\\[[a-zA-Z]+\\]/' ; if ( preg_match ( $ color_regex , $ pFormat , $ matches ) ) { $ color = str_replace ( [ '[' , ']' ] , '' , $ matches [ 0 ] ) ; $ color = strtolower ( $ color ) ; } $ value = htmlspecialchars ( $ pValue ) ; if ( $ color !== null ) { $ value = '<span style="color:' . $ color . '">' . $ value . '</span>' ; } return $ value ; }
6100	protected function delete ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_DELETE , null , $ fireAndForget ) ; }
3396	public function toMail ( $ notifiable ) { return ( new MailMessage ) -> subject ( __ ( 'confirmation::confirmation.confirmation_subject' ) ) -> line ( __ ( 'confirmation::confirmation.confirmation_subject_title' ) ) -> line ( __ ( 'confirmation::confirmation.confirmation_body' ) ) -> action ( __ ( 'confirmation::confirmation.confirmation_button' ) , url ( "register/confirm/$notifiable->confirmation_code" ) ) ; }
3464	public function get ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: get ( $ route ) ) ; }
12064	public function setFlashBag ( $ sName , $ sValue ) { if ( ! isset ( $ _SESSION [ 'flashbag' ] ) ) { $ _SESSION [ 'flashbag' ] = array ( ) ; } $ _SESSION [ 'flashbag' ] [ $ sName ] = $ sValue ; return $ this ; }
4696	public static function getToken ( $ token_name = self :: TOKEN_NAME ) { if ( empty ( $ _SESSION [ $ token_name ] ) ) { static :: generateToken ( $ token_name ) ; } return $ _SESSION [ $ token_name ] ; }
12869	public function bind ( $ sUser , $ sPassword ) : Ldap { return $ this -> _bConnected = ldap_bind ( $ this -> _rConnect , $ sUser , $ sPassword ) ; return $ this ; }
7789	public function setTransactionClass ( $ transactionClass ) { if ( ! is_callable ( $ transactionClass ) && ! class_exists ( $ transactionClass ) ) { throw new \ InvalidArgumentException ( '$transactionClass must be a valid classname or a PHP callable' ) ; } $ this -> transactionClass = $ transactionClass ; return $ this ; }
8651	private function convertGetReport ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReport' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportId ( ) ) { $ parameters [ 'ReportId' ] = $ request -> getReportId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
9046	public function registerType ( $ type , $ classname , $ options = array ( ) ) { if ( ! class_exists ( $ classname ) || ! is_callable ( array ( $ classname , 'getDataType' ) ) ) { return ; } $ data_type = call_user_func ( array ( $ classname , 'getDataType' ) ) ; $ options = ( array ) $ options ; $ options [ 'type' ] = $ type ; $ options [ 'class_name' ] = $ classname ; $ options [ 'data_type' ] = $ data_type ; $ this -> types [ $ data_type ] [ $ type ] = $ options ; }
5589	public function getBaseCookieValue ( $ name , $ base ) { if ( ! $ base ) { return ; } return $ this -> getCookieValue ( $ base -> getHost ( ) , $ base -> getPath ( ) , $ name ) ; }
7849	public function dispatchFrom ( $ command , ArrayAccess $ source , array $ extras = [ ] ) { $ this -> command = $ command ; $ this -> values = array_merge ( ( array ) $ source , $ extras ) ; return $ this -> dispatcher -> dispatch ( $ this -> marshal ( ) ) ; }
9916	public function configure ( array $ modelConfigurations ) { if ( empty ( $ modelConfigurations ) ) { throw new \ LogicException ( 'Supply at least one model or model configuration!' ) ; } foreach ( $ modelConfigurations as $ className ) { $ modelClass = $ className ; if ( is_subclass_of ( $ className , 'Illuminate\Database\Eloquent\Model' ) ) { $ config = new ModelConfig ( ) ; $ config -> setModelClass ( $ modelClass ) ; } else if ( is_subclass_of ( $ className , 'Label305\AujaLaravel\Config\ModelConfig' ) ) { $ config = new $ className ( ) ; $ modelClass = $ config -> getModelClass ( ) ; } else { throw new \ InvalidArgumentException ( "Model configuration should be class name string of either a ModelConfig or Eloquent subclass." ) ; } $ model = new Model ( $ modelClass ) ; $ this -> models [ $ modelClass ] = $ model ; $ this -> relations [ $ modelClass ] = [ ] ; $ configResolver = new ConfigResolver ( $ config , $ model ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; $ this -> findColumns ( $ this -> models [ $ modelClass ] ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; } $ this -> findRelations ( array_values ( $ this -> models ) ) ; }
3674	private function extractPostData ( FilterUrl $ filterUrl , $ options , Request $ request ) : void { if ( empty ( $ options [ 'postAsSlug' ] ) && empty ( $ options [ 'postAsGet' ] ) ) { return ; } foreach ( $ request -> request -> all ( ) as $ name => $ value ) { if ( is_array ( $ value ) ) { $ value = implode ( ',' , $ value ) ; } if ( in_array ( $ name , $ options [ 'postAsSlug' ] ) ) { $ filterUrl -> setSlug ( $ name , $ value ) ; } if ( in_array ( $ name , $ options [ 'postAsGet' ] ) ) { $ filterUrl -> setGet ( $ name , $ value ) ; } } }
2061	public function generateAlias ( $ varValue , Contao \ DataContainer $ dc ) { $ objPage = Contao \ PageModel :: findWithDetails ( $ dc -> id ) ; $ aliasExists = function ( string $ alias ) use ( $ dc , $ objPage ) : bool { $ objAliasIds = $ this -> Database -> prepare ( "SELECT id FROM tl_page WHERE alias=? AND id!=?" ) -> execute ( $ alias , $ dc -> id ) ; if ( ! $ objAliasIds -> numRows ) { return false ; } $ strCurrentDomain = $ objPage -> domain ; $ strCurrentLanguage = $ objPage -> rootLanguage ; if ( $ objPage -> type == 'root' ) { $ strCurrentDomain = Contao \ Input :: post ( 'dns' ) ; $ strCurrentLanguage = Contao \ Input :: post ( 'language' ) ; } while ( $ objAliasIds -> next ( ) ) { $ objAliasPage = Contao \ PageModel :: findWithDetails ( $ objAliasIds -> id ) ; if ( $ objAliasPage -> domain != $ strCurrentDomain ) { continue ; } if ( Contao \ Config :: get ( 'addLanguageToUrl' ) && $ objAliasPage -> rootLanguage != $ strCurrentLanguage ) { continue ; } return true ; } return false ; } ; if ( $ varValue == '' ) { $ varValue = Contao \ System :: getContainer ( ) -> get ( 'contao.slug' ) -> generate ( $ dc -> activeRecord -> title , $ dc -> activeRecord -> id , function ( $ alias ) use ( $ objPage , $ aliasExists ) { return $ aliasExists ( ( Contao \ Config :: get ( 'folderUrl' ) ? $ objPage -> folderUrl : '' ) . $ alias ) ; } ) ; if ( Contao \ Config :: get ( 'folderUrl' ) && $ objPage -> folderUrl != '' ) { $ varValue = $ objPage -> folderUrl . $ varValue ; } } elseif ( $ aliasExists ( $ varValue ) ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'aliasExists' ] , $ varValue ) ) ; } return $ varValue ; }
8663	private function convertGetReportRequestList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportRequestList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportRequestIdList ( ) ) { $ reportRequestIdList = $ request -> getReportRequestIdList ( ) ; foreach ( $ reportRequestIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportRequestIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetReportProcessingStatusList ( ) ) { $ reportProcessingStatusList = $ request -> getReportProcessingStatusList ( ) ; foreach ( $ reportProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'ReportProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetRequestedFromDate ( ) ) { $ parameters [ 'RequestedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedFromDate ( ) ) ; } if ( $ request -> isSetRequestedToDate ( ) ) { $ parameters [ 'RequestedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
11052	public static function sprintt ( $ datatree , $ containers , $ entry = 'main' , $ hsr = _ETS_SOURCE_READ , $ hcr = _ETS_CACHE_READ , $ hcw = _ETS_CACHE_WRITE ) { $ ets = new _ets ( $ containers , $ hsr , $ hcr , $ hcw ) ; return $ ets -> build_all ( $ datatree , $ entry ) ; }
3548	public function create ( $ request ) { $ model = $ this -> repository -> create ( $ request -> all ( ) ) ; $ model -> { $ this -> getShortRelationName ( ) } ( ) -> sync ( $ request -> get ( $ this -> getRelationName ( ) , [ ] ) ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ model ) ) ; return $ model ; }
9309	public function show ( $ id , $ params = [ ] ) { $ data = [ 'id' => $ id ] + $ params ; return $ this -> query ( __FUNCTION__ , $ data ) ; }
1301	public function parseJson ( string $ json ) { return $ this -> builder -> build ( $ this -> scopedJsonDecoder -> decode ( $ json ) ) ; }
1814	public function listImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=list' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a>' ; }
9202	public function createBearerToken ( ) { $ bearerCredentials = $ this -> createBearerCredentials ( ) ; $ headers = array ( 'Authorization' => 'Basic ' . $ bearerCredentials , 'Content-Type' => 'application/x-www-form-urlencoded;charset=UTF-8' ) ; $ body = 'grant_type=client_credentials' ; $ data = $ this -> guzzleClient -> post ( Config :: get ( 'oauth2_token' ) , array ( 'headers' => $ headers , 'body' => $ body ) ) -> json ( ) ; $ this -> credentials -> setBearerToken ( $ data [ 'access_token' ] ) ; return $ this ; }
8581	public function setPrepInstruction ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PrepInstruction' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12285	public function end ( ) : string { $ property = static :: END_ASSETS_NAME . static :: BLOCK_PROPERTY_SUFFIX ; return isset ( $ this -> $ property ) ? trim ( $ this -> make ( static :: END_ASSETS_NAME ) ) . PHP_EOL : PHP_EOL ; }
12743	public function buildSlotMap ( ) { $ this -> slotmap -> reset ( ) ; foreach ( $ this -> pool as $ connectionID => $ connection ) { $ parameters = $ connection -> getParameters ( ) ; if ( ! isset ( $ parameters -> slots ) ) { continue ; } foreach ( explode ( ',' , $ parameters -> slots ) as $ slotRange ) { $ slots = explode ( '-' , $ slotRange , 2 ) ; if ( ! isset ( $ slots [ 1 ] ) ) { $ slots [ 1 ] = $ slots [ 0 ] ; } $ this -> slotmap -> setSlots ( $ slots [ 0 ] , $ slots [ 1 ] , $ connectionID ) ; } } }
3141	public function move ( RunnerServiceContext $ context , $ direction , $ scope , $ ref ) { $ result = true ; if ( $ context instanceof QtiRunnerServiceContext ) { try { $ result = QtiRunnerNavigation :: move ( $ direction , $ scope , $ context , $ ref ) ; if ( $ result ) { $ this -> continueInteraction ( $ context ) ; } } catch ( AssessmentTestSessionException $ e ) { switch ( $ e -> getCode ( ) ) { case AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW : case AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW : case AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW : case AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW : $ this -> onTimeout ( $ context , $ e ) ; break ; } } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'move' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return $ result ; }
8138	public function getTemplateClass ( $ name , $ index = null ) { $ key = $ this -> getLoader ( ) -> getCacheKey ( $ name ) . $ this -> optionsHash ; return $ this -> templateClassPrefix . hash ( 'sha256' , $ key ) . ( null === $ index ? '' : '_' . $ index ) ; }
1790	private function prepareAlias ( string $ alias , array & $ parameters ) : void { if ( 'index' === $ alias ) { return ; } $ hasAutoItem = false ; $ autoItems = $ this -> getAutoItems ( $ parameters ) ; $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ parameters [ 'alias' ] = preg_replace_callback ( '/\{([^\}]+)\}/' , static function ( array $ matches ) use ( $ alias , & $ parameters , $ autoItems , & $ hasAutoItem , $ config ) : string { $ param = $ matches [ 1 ] ; if ( ! isset ( $ parameters [ $ param ] ) ) { throw new MissingMandatoryParametersException ( sprintf ( 'Parameters "%s" is missing to generate a URL for "%s"' , $ param , $ alias ) ) ; } $ value = $ parameters [ $ param ] ; unset ( $ parameters [ $ param ] ) ; if ( $ hasAutoItem || ! $ config -> get ( 'useAutoItem' ) || ! \ in_array ( $ param , $ autoItems , true ) ) { return $ param . '/' . $ value ; } $ hasAutoItem = true ; return $ value ; } , $ alias ) ; }
1896	private function purgeOldFiles ( string $ webDir ) : void { if ( file_exists ( $ webDir . '/app_dev.php' ) ) { $ this -> fs -> remove ( $ webDir . '/app_dev.php' ) ; $ this -> io -> writeln ( 'Deleted the <comment>web/app_dev.php</comment> file.' ) ; } if ( file_exists ( $ webDir . '/install.php' ) ) { $ this -> fs -> remove ( $ webDir . '/install.php' ) ; $ this -> io -> writeln ( 'Deleted the <comment>web/install.php</comment> file.' ) ; } }
9374	protected function dispatcher ( ResponseInterface $ response , $ stack ) { $ dispatcher = new Dispatcher ( $ stack , $ response ) ; if ( class_exists ( 'Zend\Stratigility\MiddlewarePipe' ) ) { $ pipe = new MiddlewarePipe ; $ dispatcher = new StratigilityDispatcher ( $ pipe , $ stack , $ response ) ; } return $ dispatcher ; }
9904	private function updateCellRange ( $ pCellRange = 'A1:A1' , $ pBefore = 'A1' , $ pNumCols = 0 , $ pNumRows = 0 ) { if ( ! Coordinate :: coordinateIsRange ( $ pCellRange ) ) { throw new Exception ( 'Only cell ranges may be passed to this method.' ) ; } $ range = Coordinate :: splitRange ( $ pCellRange ) ; $ ic = count ( $ range ) ; for ( $ i = 0 ; $ i < $ ic ; ++ $ i ) { $ jc = count ( $ range [ $ i ] ) ; for ( $ j = 0 ; $ j < $ jc ; ++ $ j ) { if ( ctype_alpha ( $ range [ $ i ] [ $ j ] ) ) { $ r = Coordinate :: coordinateFromString ( $ this -> updateSingleCellReference ( $ range [ $ i ] [ $ j ] . '1' , $ pBefore , $ pNumCols , $ pNumRows ) ) ; $ range [ $ i ] [ $ j ] = $ r [ 0 ] ; } elseif ( ctype_digit ( $ range [ $ i ] [ $ j ] ) ) { $ r = Coordinate :: coordinateFromString ( $ this -> updateSingleCellReference ( 'A' . $ range [ $ i ] [ $ j ] , $ pBefore , $ pNumCols , $ pNumRows ) ) ; $ range [ $ i ] [ $ j ] = $ r [ 1 ] ; } else { $ range [ $ i ] [ $ j ] = $ this -> updateSingleCellReference ( $ range [ $ i ] [ $ j ] , $ pBefore , $ pNumCols , $ pNumRows ) ; } } } return Coordinate :: buildRange ( $ range ) ; }
5593	protected function fetch ( $ url , $ encoding ) { $ request = $ this -> createRequest ( $ url , $ encoding ) ; return $ request -> fetch ( $ this -> connection_timeout ) ; }
12105	public function exception ( Exception $ exception ) { if ( $ this -> stopPropagation ) { return false ; } $ this -> fireHandlers ( $ exception ) ; $ this -> stopPropagation = true ; return false ; }
5781	private function getSectionForAdministrator ( array $ section , string $ sectionName ) : array { if ( isset ( $ section [ 'authorization' ] ) && ! $ this -> container -> authorization -> isAuthorized ( $ section [ 'authorization' ] ) ) { return [ ] ; } $ updatedSection = [ ] ; foreach ( $ section as $ key => $ value ) { if ( $ key != 'subSections' ) { $ updatedSection [ $ key ] = $ value ; } } $ updatedSubSections = [ ] ; if ( isset ( $ section [ 'subSections' ] ) ) { foreach ( $ section [ 'subSections' ] as $ subSectionName => $ subSection ) { $ updatedSubSection = $ this -> getSectionForAdministrator ( $ subSection , $ subSectionName ) ; if ( count ( $ updatedSubSection ) > 0 ) { $ updatedSubSections [ $ subSectionName ] = $ updatedSubSection ; } } } if ( count ( $ updatedSubSections ) > 0 ) { $ updatedSection [ 'subSections' ] = $ updatedSubSections ; } return $ updatedSection ; }
945	private function setOption ( $ name , $ value ) { if ( ! \ array_key_exists ( $ name , $ this -> options ) ) { throw new InvalidConfigurationException ( sprintf ( 'Unknown option name: "%s".' , $ name ) ) ; } $ this -> options [ $ name ] = $ value ; }
5628	public function makeAbsolute ( $ base ) { if ( ! is_object ( $ base ) ) { $ base = new self ( $ base ) ; } if ( $ this -> getHost ( ) ) { $ scheme = $ this -> getScheme ( ) ; $ host = $ this -> getHost ( ) ; $ port = $ this -> getPort ( ) ? ':' . $ this -> getPort ( ) : '' ; $ identity = $ this -> getIdentity ( ) ? $ this -> getIdentity ( ) . '@' : '' ; if ( ! $ identity ) { $ identity = $ base -> getIdentity ( ) ? $ base -> getIdentity ( ) . '@' : '' ; } } else { $ scheme = $ base -> getScheme ( ) ; $ host = $ base -> getHost ( ) ; $ port = $ base -> getPort ( ) ? ':' . $ base -> getPort ( ) : '' ; $ identity = $ base -> getIdentity ( ) ? $ base -> getIdentity ( ) . '@' : '' ; } $ path = $ this -> normalisePath ( $ this -> extractAbsolutePath ( $ base ) ) ; $ encoded = $ this -> getEncodedRequest ( ) ; $ fragment = $ this -> getFragment ( ) ? '#' . $ this -> getFragment ( ) : '' ; $ coords = $ this -> getX ( ) === false ? '' : '?' . $ this -> getX ( ) . ',' . $ this -> getY ( ) ; return new self ( "$scheme://$identity$host$port$path$encoded$fragment$coords" ) ; }
9282	public function getRunning ( array $ options = array ( ) ) { $ where = new Where ( ) ; $ where -> equalTo ( "{$this->tableName}.status" , JobEntity :: STATUS_RUNNING ) ; return $ this -> fetchByWhere ( $ where , $ options ) ; }
39	protected function generatePackageTree ( PackageInterface $ package , RepositoryInterface $ installedRepo , RepositoryInterface $ distantRepos ) { $ requires = $ package -> getRequires ( ) ; ksort ( $ requires ) ; $ children = array ( ) ; foreach ( $ requires as $ requireName => $ require ) { $ packagesInTree = array ( $ package -> getName ( ) , $ requireName ) ; $ treeChildDesc = array ( 'name' => $ requireName , 'version' => $ require -> getPrettyConstraint ( ) , ) ; $ deepChildren = $ this -> addTree ( $ requireName , $ require , $ installedRepo , $ distantRepos , $ packagesInTree ) ; if ( $ deepChildren ) { $ treeChildDesc [ 'requires' ] = $ deepChildren ; } $ children [ ] = $ treeChildDesc ; } $ tree = array ( 'name' => $ package -> getPrettyName ( ) , 'version' => $ package -> getPrettyVersion ( ) , 'description' => $ package -> getDescription ( ) , ) ; if ( $ children ) { $ tree [ 'requires' ] = $ children ; } return $ tree ; }
8220	protected function getSubnet ( $ ip , $ netmask ) { $ binString = @ inet_pton ( $ ip ) ; if ( $ binString === false ) { throw new \ InvalidArgumentException ( "Not a valid IP address." ) ; } $ byteLen = mb_strlen ( $ binString , "8bit" ) ; if ( ! is_int ( $ netmask ) || $ netmask < 0 || $ netmask > $ byteLen * 8 ) { throw new \ InvalidArgumentException ( "Not a valid netmask." ) ; } for ( $ byte = $ byteLen - 1 ; ( $ byte + 1 ) * 8 > $ netmask ; -- $ byte ) { $ maskLen = min ( 8 , ( $ byte + 1 ) * 8 - $ netmask ) ; $ mask = ( ~ ( ( 1 << $ maskLen ) - 1 ) ) & 0xff ; $ maskedByte = $ mask & unpack ( 'C' , $ binString [ $ byte ] ) [ 1 ] ; $ binString [ $ byte ] = pack ( 'C' , $ maskedByte ) ; } return inet_ntop ( $ binString ) . '/' . $ netmask ; }
10286	public static function stringFromColumnIndex ( $ columnIndex ) { static $ indexCache = [ ] ; if ( ! isset ( $ indexCache [ $ columnIndex ] ) ) { $ indexValue = $ columnIndex ; $ base26 = null ; do { $ characterValue = ( $ indexValue % 26 ) ? : 26 ; $ indexValue = ( $ indexValue - $ characterValue ) / 26 ; $ base26 = chr ( $ characterValue + 64 ) . ( $ base26 ? : '' ) ; } while ( $ indexValue > 0 ) ; $ indexCache [ $ columnIndex ] = $ base26 ; } return $ indexCache [ $ columnIndex ] ; }
2349	public function renameTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new Folder ( $ strParent ) ; } $ return = $ this -> Files -> rename ( $ this -> strFile , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { $ this -> objModel = Dbafs :: moveResource ( $ this -> strFile , $ strNewName ) ; } elseif ( $ syncSource ) { $ this -> objModel = Dbafs :: deleteResource ( $ this -> strFile ) ; } elseif ( $ syncTarget ) { $ this -> objModel = Dbafs :: addResource ( $ strNewName ) ; } if ( $ return != false ) { $ this -> strFile = $ strNewName ; $ this -> arrImageSize = array ( ) ; $ this -> arrPathinfo = array ( ) ; } return $ return ; }
834	private function getFunctionyTokenKinds ( ) { static $ tokens = [ T_ARRAY , T_ECHO , T_EMPTY , T_EVAL , T_EXIT , T_INCLUDE , T_INCLUDE_ONCE , T_ISSET , T_LIST , T_PRINT , T_REQUIRE , T_REQUIRE_ONCE , T_UNSET , T_VARIABLE , ] ; return $ tokens ; }
4858	public function getList ( $ namespace , $ callback ) { $ session = new Container ( $ namespace ) ; $ params = $ session -> params ? : array ( ) ; if ( ! $ session -> list ) { $ session -> list = is_array ( $ callback ) ? call_user_func ( $ callback , $ session -> params ) : $ callback -> getPaginationList ( $ session -> params ) ; } return $ session -> list ; }
1256	public static function search ( $ expression , $ data ) { static $ runtime ; if ( ! $ runtime ) { $ runtime = Env :: createRuntime ( ) ; } return $ runtime ( $ expression , $ data ) ; }
4583	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! array_key_exists ( $ this -> attribute , $ payload ) ) { $ event -> markAsInvalid ( ) ; } $ uuid = $ payload [ $ this -> attribute ] ; $ tenant = $ this -> tenantService -> getRepository ( ) -> findBy ( [ 'uuid' => $ uuid ] ) ; if ( ! $ tenant ) { $ event -> markAsInvalid ( ) ; } }
9364	public function substract ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return $ this -> add ( $ z -> negative ( ) ) ; }
5100	public function values ( $ values ) { if ( isset ( $ values [ 0 ] ) ) return $ this -> appendByPosition ( $ values ) ; $ this -> fixDefaultValues ( $ values ) ; if ( ! $ this -> fields ) { $ this -> placeholder = false ; $ this -> fields = array_keys ( $ values ) ; return $ this -> appendByPosition ( array_values ( $ values ) ) ; } return $ this -> appendByField ( $ values ) ; }
11438	public function getDefault ( $ name ) { return isset ( $ this -> options [ 'defaults' ] [ $ name ] ) ? $ this -> options [ 'defaults' ] [ $ name ] : null ; }
417	public function getETags ( ) { if ( $ this -> headers -> has ( 'If-None-Match' ) ) { return preg_split ( '/[\s,]+/' , str_replace ( '-gzip' , '' , $ this -> headers -> get ( 'If-None-Match' ) ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } return [ ] ; }
11697	public function __ ( $ key , array $ parameters = [ ] , $ locale = null , $ default = null , $ parseBBCode = true ) { return $ this -> translate ( $ key , $ parameters , $ locale , $ default , $ parseBBCode ) ; }
3147	public function check ( RunnerServiceContext $ context ) { $ state = $ context -> getTestSession ( ) -> getState ( ) ; if ( $ state == AssessmentTestSessionState :: CLOSED ) { throw new QtiRunnerClosedException ( ) ; } return true ; }
7047	protected function buildAddressData ( Common \ AddressInterface $ address , string $ locale ) { $ country = Intl :: getRegionBundle ( ) -> getCountryName ( $ address -> getCountry ( ) -> getCode ( ) , $ locale ) ; $ fullName = trim ( $ address -> getFirstName ( ) . ' ' . $ address -> getLastName ( ) ) ; $ data = [ 'company' => $ address -> getCompany ( ) , 'full_name' => $ fullName , 'street' => $ address -> getStreet ( ) , 'complement' => $ address -> getComplement ( ) , 'supplement' => $ address -> getSupplement ( ) , 'postal_code' => $ address -> getPostalCode ( ) , 'city' => $ address -> getCity ( ) , 'country' => $ country , 'state' => '' , 'phone' => $ this -> formatPhoneNumber ( $ address -> getPhone ( ) ) , 'mobile' => $ this -> formatPhoneNumber ( $ address -> getMobile ( ) ) , ] ; if ( $ address instanceof RelayPointInterface ) { $ data [ 'number' ] = $ address -> getNumber ( ) ; } return $ data ; }
4920	public function setForm ( $ key , $ spec , $ enabled = true ) { if ( is_object ( $ spec ) ) { if ( ! $ spec instanceof Container ) { throw new \ InvalidArgumentException ( 'Tab container must be of the type \Core\Form\Container' ) ; } if ( ! $ spec -> getLabel ( ) ) { throw new \ InvalidArgumentException ( 'Container instances must have a label.' ) ; } } if ( is_array ( $ spec ) ) { if ( ! isset ( $ spec [ 'type' ] ) ) { $ spec [ 'type' ] = 'Core/Container' ; } if ( ! isset ( $ spec [ 'options' ] [ 'forms' ] ) && isset ( $ spec [ 'forms' ] ) ) { $ spec [ 'options' ] [ 'forms' ] = $ spec [ 'forms' ] ; unset ( $ spec [ 'forms' ] ) ; } } return parent :: setForm ( $ key , $ spec , $ enabled ) ; }
2774	public function setPrivateKey ( string $ privateKey , int $ port = 22 , ? string $ wrapper = null ) : void { if ( $ wrapper === null ) { $ wrapper = __DIR__ . '/../bin/git-ssh-wrapper.sh' ; } if ( ! $ wrapperPath = realpath ( $ wrapper ) ) { throw new GitException ( 'Path to GIT_SSH wrapper script could not be resolved: ' . $ wrapper ) ; } if ( ! $ privateKeyPath = realpath ( $ privateKey ) ) { throw new GitException ( 'Path private key could not be resolved: ' . $ privateKey ) ; } $ this -> setEnvVar ( 'GIT_SSH' , $ wrapperPath ) ; $ this -> setEnvVar ( 'GIT_SSH_KEY' , $ privateKeyPath ) ; $ this -> setEnvVar ( 'GIT_SSH_PORT' , $ port ) ; }
8219	protected function getIp ( $ config ) { $ remoteAddr = $ _SERVER [ 'REMOTE_ADDR' ] ; if ( filter_var ( $ remoteAddr , FILTER_VALIDATE_IP , FILTER_FLAG_IPV4 ) ) { $ netmask = ( isset ( $ config [ "netmask_IPv4" ] ) ) ? $ config [ "netmask_IPv4" ] : self :: DEFAULT_NETMASK_IPV4 ; } else { $ netmask = ( isset ( $ config [ "netmask_IPv6" ] ) ) ? $ config [ "netmask_IPv6" ] : self :: DEFAULT_NETMASK_IPV6 ; } $ ipSubnet = $ this -> getSubnet ( $ remoteAddr , $ netmask ) ; return $ ipSubnet ; }
5974	public function filters ( ) { if ( ! $ this -> filters instanceof FiltersController ) { $ this -> filters = new FiltersController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> filters -> setLogger ( $ this -> logger ) ; } return $ this -> filters ; }
9717	private function writeRecalcId ( ) { $ record = 0x01C1 ; $ length = 8 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'VV' , 0x000001C1 , 0x00001E667 ) ; return $ this -> writeData ( $ header . $ data ) ; }
7971	public function getIncoming ( $ domain , $ id ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( $ id !== 0 && ! $ id ) throw new BadMethodCallException ( 'Parameter $id is missing.' ) ; $ id = intval ( $ id ) ; try { $ r = $ this -> get ( 'sms/' . $ domain . '/incoming/' . $ id ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
7022	private function formatO ( & $ str ) { if ( strstr ( $ str , '%O' ) ) { $ o = $ this -> timezone -> offset ; $ os = $ o >= 0 ? '+' : '-' ; $ oh = sprintf ( '%02d' , abs ( intval ( $ o ) ) ) ; $ om = sprintf ( '%02d' , abs ( $ o - intval ( $ o ) ) * 60 ) ; $ ofs = "{$os}{$oh}{$om}" ; $ str = str_replace ( '%O' , $ ofs , $ str ) ; } }
5470	protected function describePatternMatch ( $ pattern , $ subject ) { preg_match ( $ pattern , $ subject , $ matches ) ; $ position = strpos ( $ subject , $ matches [ 0 ] ) ; $ dumper = $ this -> getDumper ( ) ; return "Pattern [$pattern] detected at character [$position] in [" . $ dumper -> describeValue ( $ subject ) . '] as [' . $ matches [ 0 ] . '] in region [' . $ dumper -> clipString ( $ subject , 100 , $ position ) . ']' ; }
7555	function match ( $ conditions , $ match = true , $ custom_filters = array ( ) ) { $ t = isset ( $ conditions [ 'tags' ] ) ; $ a = isset ( $ conditions [ 'attributes' ] ) ; $ f = isset ( $ conditions [ 'filters' ] ) ; if ( ! ( $ t || $ a || $ f ) ) { if ( is_array ( $ conditions ) && $ conditions ) { foreach ( $ conditions as $ c ) { if ( $ this -> match ( $ c , $ match ) ) { return true ; } } } return false ; } else { if ( ( $ t && ( ! $ this -> match_tags ( $ conditions [ 'tags' ] ) ) ) === $ match ) { return false ; } if ( ( $ a && ( ! $ this -> match_attributes ( $ conditions [ 'attributes' ] ) ) ) === $ match ) { return false ; } if ( ( $ f && ( ! $ this -> match_filters ( $ conditions [ 'filters' ] , $ custom_filters ) ) ) === $ match ) { return false ; } return true ; } }
3650	protected function getTemplate ( $ strTemplate , $ strFormat = 'html5' , $ blnFailIfNotFound = false ) { $ strTemplate = basename ( $ strTemplate ) ; $ strCustom = 'templates' ; if ( TL_MODE == 'FE' ) { $ tmpDir = str_replace ( '../' , '' , $ GLOBALS [ 'objPage' ] -> templateGroup ) ; if ( ! empty ( $ tmpDir ) ) { $ strCustom = $ tmpDir ; } } try { return \ TemplateLoader :: getPath ( $ strTemplate , $ strFormat , $ strCustom ) ; } catch ( \ Exception $ exception ) { if ( $ blnFailIfNotFound ) { throw new \ RuntimeException ( sprintf ( 'Could not find template %s.%s' , $ strTemplate , $ strFormat ) , 1 , $ exception ) ; } } return null ; }
5365	public function paintPass ( $ message ) { parent :: paintPass ( $ message ) ; $ this -> results [ ] = new SimpleResultOfPass ( parent :: getTestList ( ) , $ message ) ; }
3878	public function addChild ( $ child ) { if ( ! \ is_array ( $ child ) ) { throw new \ RuntimeException ( 'Error Processing sub filter: ' . var_export ( $ child , true ) , 1 ) ; } switch ( strtoupper ( $ child [ 'operation' ] ) ) { case '=' : case '>' : case '<' : return $ this -> getFilterForComparingOperator ( $ child ) ; case 'IN' : return $ this -> getFilterForInList ( $ child ) ; case 'LIKE' : return $ this -> getFilterForLike ( $ child ) ; default : } throw new \ RuntimeException ( 'Error processing filter array ' . var_export ( $ child , true ) , 1 ) ; }
5370	public function add ( $ key , $ value ) { if ( $ value === false ) { return ; } if ( is_array ( $ value ) ) { foreach ( $ value as $ item ) { $ this -> addPair ( $ key , $ item ) ; } } else { $ this -> addPair ( $ key , $ value ) ; } }
91	public static function parseJson ( $ json , $ file = null ) { if ( null === $ json ) { return ; } $ data = json_decode ( $ json , true ) ; if ( null === $ data && JSON_ERROR_NONE !== json_last_error ( ) ) { self :: validateSyntax ( $ json , $ file ) ; } return $ data ; }
1284	private function resolveLinksForResourceType ( string $ type , array $ links , string $ locale = null ) : array { $ resourceIds = \ array_map ( function ( Link $ link ) : string { return $ link -> getId ( ) ; } , \ array_filter ( $ links , function ( Link $ link ) use ( $ type ) : bool { return $ link -> getLinkType ( ) === $ type ; } ) ) ; $ resources = [ ] ; $ collection = $ this -> fetchResourcesForGivenIds ( $ resourceIds , $ type , $ locale ) ; foreach ( $ collection as $ resource ) { $ resources [ $ type . '.' . $ resource -> getId ( ) ] = $ resource ; } return $ resources ; }
3635	public function httpMiddles ( Request $ request ) : array { $ dispatcher = \ bean ( 'serverDispatcher' ) ; $ middleType = ( int ) $ request -> query ( 'type' ) ; if ( $ middleType === 1 ) { return $ dispatcher -> getMiddlewares ( ) ; } return $ dispatcher -> requestMiddleware ( ) ; }
7895	public function extend ( $ provider , Closure $ callback ) { if ( $ this -> isProviderAliasExists ( $ provider ) ) { throw new InvalidArgumentException ( "Alias provider is already reserved [{$provider}]" ) ; } $ this -> customProviders [ $ provider ] = $ callback ; return $ this ; }
6041	public function search ( $ sessionId , Search $ search , $ hits ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'search' => $ search , 'hits' => $ hits ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/search' , $ parameters , true ) ; return $ result ; }
12049	public static function showImageInSize ( int $ iImageUri , int $ iWidth , int $ iHeight , bool $ bKeepDimension = false ) { $ aSize = getimagesize ( $ iImageUri ) ; $ rActualImage = imagecreatefromjpeg ( $ iImageUri ) ; $ ImageChoisie = imagecreatefromjpeg ( $ _FILES [ 'ImageNews' ] [ 'tmp_name' ] ) ; $ TailleImageChoisie = getimagesize ( $ _FILES [ 'ImageNews' ] [ 'tmp_name' ] ) ; $ rNewImage = imagecreatetruecolor ( $ iWidth , $ iHeight ) ; if ( $ bKeepDimension === false ) { imagecopyresampled ( $ rNewImage , $ rActualImage , 0 , 0 , 0 , 0 , $ iWidth , $ iHeight , $ aSize [ 0 ] , $ aSize [ 1 ] ) ; } else { if ( $ aSize [ 0 ] > $ aSize [ 1 ] ) { $ rWhite = imagecolorallocate ( $ rNewImage , 255 , 255 , 255 ) ; imagefilledrectangle ( $ rNewImage , 0 , 0 , $ iWidth , $ iHeight , $ rWhite ) ; $ fCoef = $ aSize [ 1 ] / $ aSize [ 0 ] ; $ iHeight = round ( $ iWidth * $ fCoef ) ; $ iDestY = round ( ( $ iWidth - $ iHeight ) / 2 ) ; $ iDestX = 0 ; } else { $ rWhite = imagecolorallocate ( $ rNewImage , 255 , 255 , 255 ) ; imagefilledrectangle ( $ rNewImage , 0 , 0 , $ iWidth , $ iHeight , $ rWhite ) ; $ fCoef = $ aSize [ 0 ] / $ aSize [ 1 ] ; $ iWidth = round ( $ iHeight * $ fCoef ) ; $ iDestX = round ( ( $ iHeight - $ iWidth ) / 2 ) ; $ iDestY = 0 ; } $ rWhite = imagecolorallocate ( $ rNewImage , 255 , 255 , 255 ) ; imagefilledrectangle ( $ rNewImage , 0 , 0 , $ iWidth , $ iHeight , $ rWhite ) ; imagecopyresampled ( $ rNewImage , $ rActualImage , $ iDestX , $ iDestY , 0 , 0 , $ iWidth , $ iHeight , $ aSize [ 0 ] , $ aSize [ 1 ] ) ; } imagedestroy ( $ rActualImage ) ; $ NomImageChoisie = explode ( '.' , $ rNewImage ) ; $ NomImageExploitable = time ( ) ; header ( 'Content-Type: image/jpeg' ) ; imagejpeg ( $ rNewImage , null , 100 ) ; }
1808	public function getContentElements ( ) { $ groups = array ( ) ; foreach ( $ GLOBALS [ 'TL_CTE' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { $ groups [ $ k ] [ ] = $ kk ; } } return $ groups ; }
863	private function changeCodeHash ( $ codeHash ) { if ( null !== $ this -> codeHash ) { self :: clearCache ( $ this -> codeHash ) ; } $ this -> codeHash = $ codeHash ; self :: setCache ( $ this -> codeHash , $ this ) ; }
4902	private static function getDockerEnv ( $ configuration ) { $ cacheDir = $ configuration [ 'module_listener_options' ] [ 'cache_dir' ] . '/docker' ; $ configDir = static :: getConfigDir ( ) ; $ hydratorDir = $ cacheDir . '/Doctrine/Hydrator' ; $ proxyDir = $ cacheDir . '/Doctrine/Proxy' ; if ( ! is_dir ( $ hydratorDir ) ) { mkdir ( $ hydratorDir , 0777 , true ) ; } if ( ! is_dir ( $ proxyDir ) ) { mkdir ( $ proxyDir , 0777 , true ) ; } return [ 'module_listener_options' => [ 'cache_dir' => $ cacheDir , 'config_glob_paths' => [ $ configDir . '/autoload/*.docker.php' , ] ] , 'doctrine' => [ 'configuration' => [ 'odm_default' => [ 'hydrator_dir' => $ hydratorDir , 'proxy_dir' => $ proxyDir , ] ] ] ] ; }
3156	public function getOutcomeVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_OutcomeVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setValue ( $ variableValue ) ; return $ metaVariable ; }
12608	public function getChild ( $ type ) { if ( isset ( $ this -> _children [ $ type ] ) ) { return $ this -> _children [ $ type ] ; } return false ; }
10608	public function passwordRecoveredAction ( ) { $ this -> getResponse ( ) -> setStatusCode ( Response :: STATUS_CODE_201 ) ; $ userService = $ this -> getServiceLocator ( ) -> get ( 'user.service.user' ) ; $ id = $ this -> params ( ) -> fromRoute ( 'id' ) ; try { $ userService -> passwordRecovered ( $ id ) ; $ returnData = array ( 'status' => 'success' , 'message' => 'Ti abbiamo inviato un\'email con la nuova password per il tuo account. Se vorrai potrai modificarla una volta connesso.' ) ; } catch ( \ Exception $ e ) { $ this -> getResponse ( ) -> setStatusCode ( Response :: STATUS_CODE_500 ) ; $ returnData = @ unserialize ( $ e -> getMessage ( ) ) ; if ( ! is_array ( $ returnData ) ) { $ returnData = array ( 'status' => 'danger' , 'message' => $ e -> getMessage ( ) ) ; } } return new JsonModel ( $ returnData ) ; }
10041	function toString ( ) { return "Rule [isCustomfield=" . ( $ this -> isCustomfield ) ? "true" : "false" . ", field=" . $ this -> field . ", operator=" . $ this -> operator . ", value=" . $ this -> value . " (type = " . $ this -> type . ")" ; }
5253	public static function findOrFail ( $ id , array $ columns = [ '*' ] , $ parent = null ) { $ model = static :: find ( $ id , $ columns , [ 'parent' => $ parent ] ) ; if ( is_null ( $ model ) ) { throw new ModelNotFoundException ( get_called_class ( ) , $ id ) ; } return $ model ; }
12641	public function add ( $ key , $ value ) { try { $ this -> getRecursive ( $ key , $ this -> data ) ; } catch ( ElementNotFoundException $ e ) { $ this -> set ( $ key , $ value ) ; } }
4878	public function setUser ( UserInterface $ user ) { if ( $ this -> user ) { $ this -> getPermissions ( ) -> revoke ( $ this -> user , Permissions :: PERMISSION_ALL , false ) ; } $ this -> user = $ user ; $ this -> getPermissions ( ) -> grant ( $ user , Permissions :: PERMISSION_ALL ) ; return $ this ; }
5384	public function setValue ( $ value ) { if ( $ value === false ) { return parent :: setValue ( $ value ) ; } if ( $ value != $ this -> getAttribute ( 'value' ) ) { return false ; } return parent :: setValue ( $ value ) ; }
406	public function getIsFlash ( ) { $ userAgent = $ this -> headers -> get ( 'User-Agent' , '' ) ; return stripos ( $ userAgent , 'Shockwave' ) !== false || stripos ( $ userAgent , 'Flash' ) !== false ; }
738	protected function saveItems ( ) { $ items = [ ] ; foreach ( $ this -> items as $ name => $ item ) { $ items [ $ name ] = array_filter ( [ 'type' => $ item -> type , 'description' => $ item -> description , 'ruleName' => $ item -> ruleName , 'data' => $ item -> data , ] ) ; if ( isset ( $ this -> children [ $ name ] ) ) { foreach ( $ this -> children [ $ name ] as $ child ) { $ items [ $ name ] [ 'children' ] [ ] = $ child -> name ; } } } $ this -> saveToFile ( $ items , $ this -> itemFile ) ; }
3619	public function cancelFanModeOnWithTimer ( $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'fan_timer_timeout' => 0 ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
6517	public function setParameterType ( $ method , $ name , $ type ) { if ( ! isset ( $ this -> parameterTypes [ $ method ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'A method with name "%s" is not defined' , $ name , $ method ) ) ; } if ( ! array_key_exists ( $ name , $ this -> parameterTypes [ $ method ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'A parameter with name "%s" for method "%s" is not defined' , $ name , $ method ) ) ; } $ this -> parameterTypes [ $ method ] [ $ name ] = $ type ; }
4981	public function convertToPhpValue ( $ value ) { if ( ! is_array ( $ value ) || ! isset ( $ value [ 'date' ] ) || ! $ value [ 'date' ] instanceof \ MongoDate || ! isset ( $ value [ 'tz' ] ) ) { return null ; } $ timestamp = $ value [ 'date' ] -> sec ; $ date = new \ DateTime ( '@' . $ timestamp ) ; $ date -> setTimezone ( new \ DateTimeZone ( $ value [ 'tz' ] ) ) ; return $ date ; }
3768	private function resolvePath ( $ value ) { $ path = Path :: canonicalize ( $ value ) ; if ( '\\' === DIRECTORY_SEPARATOR ) { $ path = str_replace ( '/' , '\\' , $ path ) ; } return $ path ; }
3624	public function temperatureInUserScale ( $ temperature_in_celsius , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature_in_celsius * 1.8 ) + 32 ; } return $ temperature_in_celsius ; }
6069	public function listComments ( $ mediaId , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ mediaId . '/comments' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new CommentResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
9299	public function postAction ( Request $ request ) { try { $ data = $ this -> get ( 'ongr_api.batch_request_handler' ) -> handleRequest ( $ request , $ repository = $ this -> getRequestRepository ( $ request ) , 'create' ) ; return $ this -> renderRest ( $ request , $ data , Response :: HTTP_OK ) ; } catch ( \ Exception $ e ) { return $ this -> renderError ( $ request , $ e -> getMessage ( ) , Response :: HTTP_BAD_REQUEST ) ; } }
9419	public function samples ( $ amount ) { if ( ! is_numeric ( $ amount ) || $ amount < 1 ) { throw new \ InvalidArgumentException ( 'Amount of samples must be greater or equal to one' ) ; } $ arr = array ( ) ; for ( $ i = 1 ; $ i <= $ amount ; $ i ++ ) { $ r = new Random ( ) ; $ float_u = $ r -> get ( ) ; $ float_v = $ r -> get ( ) ; $ double_x = $ this -> float_sigma * sqrt ( - 2 * log ( $ float_u ) ) * cos ( 2 * pi ( ) * $ float_v ) + $ this -> float_mu ; if ( $ this -> int_precision ) { $ arr [ ] = round ( $ double_x , $ this -> int_precision ) ; } else { $ arr [ ] = $ double_x ; } } return $ arr ; }
9149	public function markAsUnread ( $ uid ) { if ( ! $ object = $ this -> model -> find ( $ uid ) ) { abort ( 404 ) ; } $ this -> authorize ( 'update' , $ object ) ; if ( ! is_null ( $ object -> read_at ) ) { $ object -> forceFill ( [ 'read_at' => null ] ) -> save ( ) ; } \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
3109	public function getCatValue ( $ assessmentSectionId , $ key ) { return ( isset ( $ this -> state [ self :: VAR_CAT ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ) ? $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] : null ; }
6792	public function build ( Notify $ notify ) { $ event = new NotifyEvent ( $ notify ) ; $ this -> eventDispatcher -> dispatch ( NotifyEvents :: BUILD , $ event ) ; return ! $ event -> isAbort ( ) ; }
7257	public function urlAllowed ( $ url ) { if ( $ this -> _viewAuth ) { return $ this -> _viewAuth [ 'AuthActions' ] -> urlAllowed ( $ this -> user ( ) , $ url ) ; } return false ; }
10224	private function buildComplexIndexMenu ( $ modelName , $ modelId , ModelConfig $ config = null ) { $ model = $ this -> aujaConfigurator -> getModel ( $ modelName ) ; $ relations = $ this -> aujaConfigurator -> getRelationsForModel ( $ model ) ; $ associationRelations = array ( ) ; foreach ( $ relations as $ relation ) { if ( $ relation -> getType ( ) == Relation :: HAS_MANY || $ relation -> getType ( ) == Relation :: HAS_AND_BELONGS_TO ) { $ associationRelations [ ] = $ relation ; } } switch ( count ( $ associationRelations ) ) { case 0 : $ menu = $ this -> noAssociationsMenuFor ( $ modelName , $ config ) ; break ; case 1 : $ menu = $ this -> singleAssociationMenuFor ( $ modelName , $ modelId , $ associationRelations [ 0 ] , $ config ) ; break ; default : $ menu = $ this -> multipleAssociationsMenuFor ( $ modelName , $ modelId , $ associationRelations , $ config ) ; break ; } return $ menu ; }
6227	public function removeOnFree ( bool $ activate = true ) : self { $ this -> storage -> removeOnFree ( $ activate ) ; return $ this ; }
12663	static public function getMessage ( $ code = self :: CODE_INTERNAL_SERVER_ERROR ) { if ( isset ( self :: $ messages [ $ code ] ) ) { return self :: $ messages [ $ code ] ; } return self :: $ messages [ self :: CODE_INTERNAL_SERVER_ERROR ] ; }
7393	public function unserialize ( $ serialized ) : void { $ this -> _initMetaData ( ) ; $ data = unserialize ( $ serialized ) ; foreach ( $ data as $ k => $ v ) { $ this -> { $ k } = $ v ; } }
9504	private function listen ( ) { $ this -> emitter -> on ( 'peridot.configure' , [ $ this , 'onPeridotConfigure' ] ) ; $ this -> emitter -> on ( 'peridot.start' , [ $ this , 'onPeridotStart' ] ) ; $ this -> emitter -> on ( 'peridot.end' , [ $ this , 'onPeridotEnd' ] ) ; }
1304	public function show ( $ category , $ slug = null ) { if ( ! isset ( $ category ) || ! isset ( $ slug ) ) { return redirect ( config ( 'chatter.routes.home' ) ) ; } $ discussion = Models :: discussion ( ) -> where ( 'slug' , '=' , $ slug ) -> first ( ) ; if ( is_null ( $ discussion ) ) { abort ( 404 ) ; } $ discussion_category = Models :: category ( ) -> find ( $ discussion -> chatter_category_id ) ; if ( $ category != $ discussion_category -> slug ) { return redirect ( config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.discussion' ) . '/' . $ discussion_category -> slug . '/' . $ discussion -> slug ) ; } $ posts = Models :: post ( ) -> with ( 'user' ) -> where ( 'chatter_discussion_id' , '=' , $ discussion -> id ) -> orderBy ( config ( 'chatter.order_by.posts.order' ) , config ( 'chatter.order_by.posts.by' ) ) -> paginate ( 10 ) ; $ chatter_editor = config ( 'chatter.editor' ) ; if ( $ chatter_editor == 'simplemde' ) { \ App :: register ( 'GrahamCampbell\Markdown\MarkdownServiceProvider' ) ; } $ discussion -> increment ( 'views' ) ; return view ( 'chatter::discussion' , compact ( 'discussion' , 'posts' , 'chatter_editor' ) ) ; }
7720	static function f_Misc_UpdateArray ( & $ array , $ numerical , $ v , $ d ) { if ( ! is_array ( $ v ) ) { if ( is_null ( $ v ) ) { $ array = array ( ) ; return ; } else { $ v = array ( $ v => $ d ) ; } } foreach ( $ v as $ p => $ a ) { if ( $ numerical === true ) { if ( is_string ( $ p ) ) { $ i = array_search ( $ p , $ array , true ) ; if ( $ i === false ) { if ( ! is_null ( $ a ) ) $ array [ ] = $ p ; } else { if ( is_null ( $ a ) ) array_splice ( $ array , $ i , 1 ) ; } } else { $ i = array_search ( $ a , $ array , true ) ; if ( $ i == false ) $ array [ ] = $ a ; } } else { if ( is_null ( $ a ) ) { unset ( $ array [ $ p ] ) ; } elseif ( $ numerical === 'frm' ) { self :: f_Misc_FormatSave ( $ a , $ p ) ; } else { $ array [ $ p ] = $ a ; } } } }
11263	protected function isUnique ( $ instance ) { foreach ( $ this -> getCollection ( ) as $ entry ) { if ( $ entry -> getAnnotatedName ( ) === $ instance -> getAnnotatedName ( ) ) { return false ; } } return true ; }
8211	protected function buildCommandSignature ( ) { $ this -> signature = $ this -> namespace . ':' . $ this -> commandName . ' ' . $ this -> commandArguments . $ this -> commandOptions . $ this -> commonOptions ; }
1518	public function replaceRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doReplaceRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; }
1272	public function isValid ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { return $ this -> response -> AddressClassification -> Code > 0 ; } return isset ( $ this -> response -> ValidAddressIndicator ) ; }
11111	public function migrate ( array $ options = [ ] ) : void { $ files = $ this -> getMigrationFiles ( M :: TYPE_UP ) ; $ migrations = $ this -> pendingMigrations ( $ files , $ this -> repository -> getRan ( ) ) ; $ this -> runPending ( $ migrations , $ options ) ; }
7779	protected function extractRules ( array $ data ) { $ rules = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ rules [ $ field ] = $ fieldData [ 1 ] ; } return $ rules ; }
2523	protected function makeMessageOptions ( array $ incoming , $ endSession = false ) { $ options = [ 'endSession' => $ endSession , 'returnXml' => $ this -> returnResultXml ] ; if ( array_key_exists ( 'endSession' , $ incoming ) ) { $ options [ 'endSession' ] = $ incoming [ 'endSession' ] ; } if ( array_key_exists ( 'returnXml' , $ incoming ) ) { $ options [ 'returnXml' ] = $ incoming [ 'returnXml' ] ; } return $ options ; }
4587	public function setStaffUuid ( ? string $ staffUuid ) { $ this -> staffUuid = $ staffUuid ; $ this -> _staffUuid = true ; return $ this ; }
1346	public function isDeleteResource ( ) : bool { return $ this -> isMethod ( 'delete' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; }
569	protected function encrypt ( $ data , $ passwordBased , $ secret , $ info ) { if ( ! extension_loaded ( 'openssl' ) ) { throw new InvalidConfigException ( 'Encryption requires the OpenSSL PHP extension' ) ; } if ( ! isset ( $ this -> allowedCiphers [ $ this -> cipher ] [ 0 ] , $ this -> allowedCiphers [ $ this -> cipher ] [ 1 ] ) ) { throw new InvalidConfigException ( $ this -> cipher . ' is not an allowed cipher' ) ; } list ( $ blockSize , $ keySize ) = $ this -> allowedCiphers [ $ this -> cipher ] ; $ keySalt = $ this -> generateRandomKey ( $ keySize ) ; if ( $ passwordBased ) { $ key = $ this -> pbkdf2 ( $ this -> kdfHash , $ secret , $ keySalt , $ this -> derivationIterations , $ keySize ) ; } else { $ key = $ this -> hkdf ( $ this -> kdfHash , $ secret , $ keySalt , $ info , $ keySize ) ; } $ iv = $ this -> generateRandomKey ( $ blockSize ) ; $ encrypted = openssl_encrypt ( $ data , $ this -> cipher , $ key , OPENSSL_RAW_DATA , $ iv ) ; if ( $ encrypted === false ) { throw new \ yii \ base \ Exception ( 'OpenSSL failure on encryption: ' . openssl_error_string ( ) ) ; } $ authKey = $ this -> hkdf ( $ this -> kdfHash , $ key , null , $ this -> authKeyInfo , $ keySize ) ; $ hashed = $ this -> hashData ( $ iv . $ encrypted , $ authKey ) ; return $ keySalt . $ hashed ; }
3338	public static function dateTimeString ( $ datetime ) { if ( $ datetime === null ) { return null ; } if ( is_object ( $ datetime ) && ! ( $ datetime instanceof \ DateTime ) ) { throw new \ Exception ( 'Only \DateTime objects allowed' ) ; } if ( is_string ( $ datetime ) ) { $ datetime = new \ DateTime ( $ datetime ) ; } return $ datetime -> format ( "Y-m-d\TH:i:s.uP" ) ; }
10998	public function getLineCount ( ) : int { $ ret = 0 ; $ fh = fopen ( $ this -> path , "r" ) ; while ( ! feof ( $ fh ) ) { $ buffer = fread ( $ fh , 8192 ) ; $ ret += substr_count ( $ buffer , PHP_EOL ) ; } fclose ( $ fh ) ; return $ ret ; }
8747	public function select ( ) { $ read = [ $ this -> stream ] ; $ write = null ; $ except = null ; $ this -> selected = @ stream_select ( $ read , $ write , $ except , 0 , $ this -> timeout ) ; return $ this ; }
1050	public static function getDirectiveValues ( Directive $ directiveDef , $ node , $ variableValues = null ) { if ( isset ( $ node -> directives ) && $ node -> directives instanceof NodeList ) { $ directiveNode = Utils :: find ( $ node -> directives , static function ( DirectiveNode $ directive ) use ( $ directiveDef ) { return $ directive -> name -> value === $ directiveDef -> name ; } ) ; if ( $ directiveNode !== null ) { return self :: getArgumentValues ( $ directiveDef , $ directiveNode , $ variableValues ) ; } } return null ; }
10403	public function onConsume ( ItemPipelineEvent $ event ) { if ( $ event -> getItemSkip ( ) ) { $ this -> skip ( $ event ) ; } else { $ this -> consume ( $ event ) ; } }
12204	public function makeEmojiAccessible ( $ text ) { return preg_replace_callback ( $ this -> search , function ( $ matches ) { $ desc = $ this -> emoji [ $ this -> utf8ToUnicode ( $ matches [ 0 ] ) ] ; return sprintf ( $ this -> output , $ desc , $ matches [ 0 ] ) ; } , $ text ) ; }
5842	public function getAdditionalFields ( array & $ taskInfo , $ task , \ TYPO3 \ CMS \ Scheduler \ Controller \ SchedulerModuleController $ parentObject ) { $ editCommand = version_compare ( TYPO3_branch , '9.5' , '>=' ) ? $ parentObject -> getCurrentAction ( ) === Action :: EDIT : $ parentObject -> CMD === 'edit' ; if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ this -> defaultDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ task -> directories ; } } if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ this -> defaultExcludeDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ task -> excludeDirectories ; } } $ additionalFields = [ ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_directories]' ; $ fieldId = 'scheduler_batchResize_directories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.directories' , ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_excludeDirectories]' ; $ fieldId = 'scheduler_batchResize_excludeDirectories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.excludeDirectories' , ] ; return $ additionalFields ; }
173	private static function firstWildcardInPattern ( $ pattern ) { $ wildcards = [ '*' , '?' , '[' , '\\' ] ; $ wildcardSearch = function ( $ r , $ c ) use ( $ pattern ) { $ p = strpos ( $ pattern , $ c ) ; return $ r === false ? $ p : ( $ p === false ? $ r : min ( $ r , $ p ) ) ; } ; return array_reduce ( $ wildcards , $ wildcardSearch , false ) ; }
3105	public function getStoreId ( ) { return isset ( $ this -> state [ self :: VAR_STORE_ID ] ) ? $ this -> state [ self :: VAR_STORE_ID ] : false ; }
4241	public function onError ( Event $ error ) { if ( $ this -> debug -> getCfg ( 'collect' ) ) { $ this -> error = $ error ; $ errInfo = $ error [ 'typeStr' ] . ': ' . $ error [ 'file' ] . ' (line ' . $ error [ 'line' ] . ')' ; $ errMsg = $ error [ 'message' ] ; if ( $ error [ 'type' ] & $ this -> debug -> getCfg ( 'errorMask' ) ) { $ this -> debug -> error ( $ errInfo . ': ' , $ errMsg ) ; } else { $ this -> debug -> warn ( $ errInfo . ': ' , $ errMsg ) ; } $ error [ 'continueToNormal' ] = false ; $ error [ 'inConsole' ] = true ; $ error [ 'email' ] = false ; $ this -> error = null ; } elseif ( $ this -> debug -> getCfg ( 'output' ) ) { $ error [ 'email' ] = false ; $ error [ 'inConsole' ] = false ; } else { $ error [ 'inConsole' ] = false ; } }
7091	protected function match ( Request $ request ) { foreach ( $ this -> routes as $ route ) { if ( $ route -> method ( ) === $ request -> method ( ) && $ route -> match ( $ request -> url ( ) ) ) { if ( $ action = $ route -> action ( ) ) { try { $ response = $ action ( $ request , $ route -> args ( ) ) ; if ( $ response !== false ) return $ response ; } catch ( AbortRouteException $ abort ) { return $ abort -> response ( ) ; } } else return null ; } } return false ; }
3569	public function __issetHook ( ) { return function ( $ next , $ isset , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( ! $ isset ) { $ isset = ( bool ) $ this -> hasMeta ( $ key ) ; } return $ next ( $ isset , $ args ) ; } ; }
8662	private function convertGetFeedSubmissionList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionIdList ( ) ) { $ feedSubmissionIdList = $ request -> getFeedSubmissionIdList ( ) ; foreach ( $ feedSubmissionIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'FeedSubmissionIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetFeedProcessingStatusList ( ) ) { $ feedProcessingStatusList = $ request -> getFeedProcessingStatusList ( ) ; foreach ( $ feedProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'FeedProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
11843	private function getCalcId ( $ dsBegin , $ treeType ) { $ codeRegular = $ codeForecast = '' ; if ( $ treeType == OptionTreeType :: VAL_PLAIN ) { $ codeRegular = Cfg :: CODE_TYPE_CALC_PV_WRITE_OFF ; $ codeForecast = Cfg :: CODE_TYPE_CALC_FORECAST_PLAIN ; } elseif ( $ treeType == OptionTreeType :: VAL_COMPRESS ) { $ codeRegular = Cfg :: CODE_TYPE_CALC_COMPRESS_PHASE1 ; $ codeForecast = Cfg :: CODE_TYPE_CALC_FORECAST_PHASE1 ; } $ query = $ this -> qGetId -> build ( ) ; $ conn = $ query -> getConnection ( ) ; $ bind = [ QGetId :: BND_DS_BEGIN => $ dsBegin , QGetId :: BND_TYPE_CODE_REGULAR => $ codeRegular , QGetId :: BND_TYPE_CODE_FORECAST => $ codeForecast ] ; $ result = $ conn -> fetchOne ( $ query , $ bind ) ; return $ result ; }
7493	public function trimLeft ( $ characters = null ) { $ this -> string = ltrim ( $ this -> string , $ characters ) ; return $ this ; }
10541	public function getFiltroConfiguration ( $ filtroName ) { if ( ! isset ( $ this -> config [ 'filtros' ] [ $ filtroName ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Filtro "%s" is not managed.' , $ filtroName ) ) ; } return $ this -> config [ 'filtros' ] [ $ filtroName ] ; }
8104	public function query ( $ sql , $ arguments = false ) { if ( ! $ stmt = $ this -> getStatement ( $ sql , $ arguments ) ) { return false ; } else { return $ stmt ; } }
3806	private function isAttributeNameOrTypeChanged ( ModelInterface $ new , ModelInterface $ old ) { return ( $ old -> getProperty ( 'type' ) !== $ new -> getProperty ( 'type' ) ) || ( $ old -> getProperty ( 'colname' ) !== $ new -> getProperty ( 'colname' ) ) ; }
9670	private function writeBorder ( XMLWriter $ objWriter , Borders $ pBorders ) { $ objWriter -> startElement ( 'border' ) ; switch ( $ pBorders -> getDiagonalDirection ( ) ) { case Borders :: DIAGONAL_UP : $ objWriter -> writeAttribute ( 'diagonalUp' , 'true' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'false' ) ; break ; case Borders :: DIAGONAL_DOWN : $ objWriter -> writeAttribute ( 'diagonalUp' , 'false' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'true' ) ; break ; case Borders :: DIAGONAL_BOTH : $ objWriter -> writeAttribute ( 'diagonalUp' , 'true' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'true' ) ; break ; } $ this -> writeBorderPr ( $ objWriter , 'left' , $ pBorders -> getLeft ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'right' , $ pBorders -> getRight ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'top' , $ pBorders -> getTop ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'bottom' , $ pBorders -> getBottom ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'diagonal' , $ pBorders -> getDiagonal ( ) ) ; $ objWriter -> endElement ( ) ; }
9164	protected function parseNode ( RuleCollection $ collection , \ DOMElement $ node , $ path , $ file ) { if ( self :: NAMESPACE_URI !== $ node -> namespaceURI ) { return ; } switch ( $ node -> localName ) { case 'rule' : $ this -> parseRule ( $ collection , $ node , $ path ) ; break ; case 'import' : $ this -> parseImport ( $ collection , $ node , $ path , $ file ) ; break ; default : throw new \ InvalidArgumentException ( sprintf ( 'Unknown tag "%s" used in file "%s". Expected "rule" or "import".' , $ node -> localName , $ path ) ) ; } }
619	public static function validateData ( array $ data , $ rules = [ ] ) { $ model = new static ( $ data ) ; if ( ! empty ( $ rules ) ) { $ validators = $ model -> getValidators ( ) ; foreach ( $ rules as $ rule ) { if ( $ rule instanceof Validator ) { $ validators -> append ( $ rule ) ; } elseif ( is_array ( $ rule ) && isset ( $ rule [ 0 ] , $ rule [ 1 ] ) ) { $ validator = Validator :: createValidator ( $ rule [ 1 ] , $ model , ( array ) $ rule [ 0 ] , array_slice ( $ rule , 2 ) ) ; $ validators -> append ( $ validator ) ; } else { throw new InvalidConfigException ( 'Invalid validation rule: a rule must specify both attribute names and validator type.' ) ; } } } $ model -> validate ( ) ; return $ model ; }
632	public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> update ( $ table , $ columns , $ condition , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
8126	protected function getSchemaResponse ( $ schemaID , $ form = null , ValidationResult $ errors = null , $ extraData = [ ] ) { $ parts = $ this -> owner -> getRequest ( ) -> getHeader ( LeftAndMain :: SCHEMA_HEADER ) ; $ data = $ this -> owner -> getFormSchema ( ) -> getMultipartSchema ( $ parts , $ schemaID , $ form , $ errors ) ; if ( $ extraData ) { $ data = array_merge ( $ data , $ extraData ) ; } $ response = HTTPResponse :: create ( Convert :: raw2json ( $ data ) ) ; $ response -> addHeader ( 'Content-Type' , 'application/json' ) ; return $ response ; }
12487	public static function enableLogging ( $ writePath ) { if ( is_file ( $ writePath ) ) { self :: $ enabled = true ; self :: $ logFilePath = $ writePath ; return true ; } throw new \ Exception ( 'Impossible d\'activer les logs dans le fichier ' . $ writePath . ' : celui ci n\'existe pas.' ) ; return false ; }
12673	public function setSourceFiles ( $ value ) { foreach ( $ value as $ key => $ settings ) { if ( $ settings === false ) { $ this -> _sourceFiles [ $ key ] = false ; continue ; } if ( ! isset ( $ settings [ 'class' ] ) ) { $ settings [ 'class' ] = $ this -> sourceFileClass ; } $ settings [ 'id' ] = $ key ; $ this -> _sourceFiles [ $ key ] = Yii :: createObject ( $ settings ) ; } }
1657	public function get ( $ name ) { foreach ( $ this -> arguments as $ argument ) { if ( $ argument [ 'name' ] == $ name ) { if ( isset ( $ this -> mapArgumentName [ $ name ] ) ) { return $ this -> { $ this -> mapArgumentName [ $ name ] } ( $ argument ) ; } else { return $ argument ; } } } }
8052	public function getAllEventsAsJson ( ) { $ cache = $ this -> cache ; if ( $ cache :: has ( self :: ALL_EVENTS_TO_JSON_KEY ) ) { return $ cache :: get ( self :: ALL_EVENTS_TO_JSON_KEY ) ; } $ allEvents = $ this -> calendarEventsEngine -> formatEventsToJson ( $ this -> getAllEvents ( ) ) ; $ allEventsToJson = json_encode ( $ allEvents ) ; $ cache :: put ( self :: ALL_EVENTS_TO_JSON_KEY , $ allEventsToJson , $ this -> cacheTimeToLive ) ; return $ allEventsToJson ; }
3333	public function createGroup ( $ files ) { $ data = array ( 'pub_key' => $ this -> api -> getPublicKey ( ) , ) ; foreach ( $ files as $ i => $ file ) { $ data [ "files[$i]" ] = $ file -> getUrl ( ) ; } $ ch = $ this -> __initRequest ( 'group' ) ; $ this -> __setRequestType ( $ ch ) ; $ this -> __setData ( $ ch , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ resp = $ this -> __runRequest ( $ ch ) ; $ group = $ this -> api -> getGroup ( $ resp -> id ) ; return $ group ; }
3111	public function getStorageService ( ) { if ( ! $ this -> storageService ) { $ this -> storageService = $ this -> getServiceLocator ( ) -> get ( StorageManager :: SERVICE_ID ) ; } return $ this -> storageService ; }
2421	public static function copyResource ( $ strSource , $ strDestination ) { $ objDatabase = Database :: getInstance ( ) ; $ objFile = FilesModel :: findByPath ( $ strSource ) ; if ( $ objFile === null ) { $ objFile = static :: addResource ( $ strSource ) ; } $ strFolder = \ dirname ( $ strDestination ) ; $ objNewFile = clone $ objFile -> current ( ) ; if ( $ strFolder == Config :: get ( 'uploadPath' ) ) { $ objNewFile -> pid = null ; } else { $ objFolder = FilesModel :: findByPath ( $ strFolder ) ; if ( $ objFolder === null ) { $ objFolder = static :: addResource ( $ strFolder ) ; } $ objNewFile -> pid = $ objFolder -> uuid ; } $ objNewFile -> tstamp = time ( ) ; $ objNewFile -> uuid = $ objDatabase -> getUuid ( ) ; $ objNewFile -> path = $ strDestination ; $ objNewFile -> name = basename ( $ strDestination ) ; $ objNewFile -> save ( ) ; if ( $ objFile -> type == 'folder' ) { $ objFiles = FilesModel :: findMultipleByBasepath ( $ strSource . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objNew = clone $ objFiles -> current ( ) ; $ objNew -> pid = $ objNewFile -> uuid ; $ objNew -> tstamp = time ( ) ; $ objNew -> uuid = $ objDatabase -> getUuid ( ) ; $ objNew -> path = str_replace ( $ strSource . '/' , $ strDestination . '/' , $ objFiles -> path ) ; $ objNew -> save ( ) ; } } } if ( ( $ strPath = \ dirname ( $ strSource ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } if ( ( $ strPath = \ dirname ( $ strDestination ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } return $ objNewFile ; }
5783	private function enterEventAndNotice ( string $ action , $ primaryKeyValue = null ) { if ( $ action != 'insert' && $ action != 'update' ) { throw new \ InvalidArgumentException ( "Action must be either insert or update" ) ; } $ actionPastTense = ( $ action == 'insert' ) ? 'inserted' : 'updated' ; $ tableNameSingular = $ this -> tableMapper -> getFormalTableName ( false ) ; $ noteStart = "$actionPastTense $tableNameSingular" ; $ eventTitle = @ constant ( "EVENT_" . strtoupper ( $ tableNameSingular ) . "_" . strtoupper ( $ action ) ) ?? $ noteStart ; $ adminNotification = $ noteStart ; $ eventPayload = [ ] ; if ( null !== $ primaryKeyColumnName = $ this -> tableMapper -> getPrimaryKeyColumnName ( ) ) { $ adminNotification .= " $primaryKeyValue" ; $ eventPayload = [ $ primaryKeyColumnName => $ primaryKeyValue ] ; } $ eventPayload = array_merge ( $ eventPayload , $ this -> requestInput ) ; $ this -> events -> insertInfo ( $ eventTitle , $ eventPayload ) ; SlimPostgres :: setAdminNotice ( $ adminNotification ) ; }
9102	protected function build_sql ( ) { $ builder = new Builder ( ) ; $ select = $ this -> parse_select ( ) ; $ from = new From ( $ this -> table -> get_table_name ( $ GLOBALS [ 'wpdb' ] ) , 'q' ) ; $ where = new Where ( 1 , true , 1 ) ; if ( ( $ message = $ this -> parse_message ( ) ) !== null ) { $ where -> qAnd ( $ message ) ; } if ( ( $ level = $ this -> parse_level ( ) ) !== null ) { $ where -> qAnd ( $ level ) ; } if ( ( $ user = $ this -> parse_user ( ) ) !== null ) { $ where -> qAnd ( $ user ) ; } if ( ( $ group = $ this -> parse_group ( ) ) !== null ) { $ where -> qAnd ( $ group ) ; } if ( ( $ time = $ this -> parse_time ( ) ) !== null ) { $ where -> qAnd ( $ time ) ; } $ order = $ this -> parse_order ( ) ; $ limit = $ this -> parse_pagination ( ) ; $ builder -> append ( $ select ) -> append ( $ from ) ; $ builder -> append ( $ where ) ; $ builder -> append ( $ order ) ; if ( $ limit !== null ) { $ builder -> append ( $ limit ) ; } return $ builder -> build ( ) ; }
343	protected function renderSortLinks ( ) { $ attributes = empty ( $ this -> attributes ) ? array_keys ( $ this -> sort -> attributes ) : $ this -> attributes ; $ links = [ ] ; foreach ( $ attributes as $ name ) { $ links [ ] = $ this -> sort -> link ( $ name , $ this -> linkOptions ) ; } return Html :: ul ( $ links , array_merge ( $ this -> options , [ 'encode' => false ] ) ) ; }
8638	public function setOrderFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3493	public function withCertificate ( string $ certificate ) : Request { $ cloned = clone $ this ; $ cloned -> certificate = $ certificate ; return $ cloned ; }
8873	private function buildHeaders ( $ required_headers = [ ] ) { $ build_headers = array_merge ( $ this -> headers , $ required_headers ) ; $ headers = [ ] ; foreach ( $ build_headers as $ name => $ value ) { $ headers [ ] = "{$name}: {$value}" ; } return implode ( "\r\n" , $ headers ) . "\nThis is a multi-part message in MIME format.\n" ; }
2626	protected function _construct ( ) { $ this -> addColumn ( 'backend_name' , [ 'label' => __ ( 'Name' ) ] ) ; $ this -> _addAfter = false ; $ this -> _template = 'Fastly_Cdn::system/config/form/field/acl.phtml' ; parent :: _construct ( ) ; }
2433	public function get ( $ strKey ) { if ( \ in_array ( $ strKey , $ this -> mappedKeys ) ) { return $ this -> session -> get ( $ strKey ) ; } return $ this -> sessionBag -> get ( $ strKey ) ; }
2054	protected function getConfigurationItem ( $ imageSize ) { $ configItem = new PictureConfigurationItem ( ) ; $ resizeConfig = new ResizeConfiguration ( ) ; $ mode = $ imageSize -> resizeMode ; if ( substr_count ( $ mode , '_' ) === 1 ) { $ importantPart = $ this -> image -> setImportantPart ( null ) -> getImportantPart ( ) ; $ mode = explode ( '_' , $ mode ) ; if ( $ mode [ 0 ] === 'left' ) { $ importantPart [ 'width' ] = 1 ; } elseif ( $ mode [ 0 ] === 'right' ) { $ importantPart [ 'x' ] = $ importantPart [ 'width' ] - 1 ; $ importantPart [ 'width' ] = 1 ; } if ( $ mode [ 1 ] === 'top' ) { $ importantPart [ 'height' ] = 1 ; } elseif ( $ mode [ 1 ] === 'bottom' ) { $ importantPart [ 'y' ] = $ importantPart [ 'height' ] - 1 ; $ importantPart [ 'height' ] = 1 ; } $ this -> image -> setImportantPart ( $ importantPart ) ; $ mode = ResizeConfiguration :: MODE_CROP ; } $ resizeConfig -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setZoomLevel ( $ imageSize -> zoom ) ; if ( $ mode ) { $ resizeConfig -> setMode ( $ mode ) ; } $ configItem -> setResizeConfig ( $ resizeConfig ) ; if ( isset ( $ imageSize -> sizes ) ) { $ configItem -> setSizes ( $ imageSize -> sizes ) ; } if ( isset ( $ imageSize -> densities ) ) { $ configItem -> setDensities ( $ imageSize -> densities ) ; } if ( isset ( $ imageSize -> media ) ) { $ configItem -> setMedia ( $ imageSize -> media ) ; } return $ configItem ; }
892	public function getNormalizedTypes ( ) { $ normalized = array_map ( static function ( $ type ) { return strtolower ( $ type ) ; } , $ this -> getTypes ( ) ) ; sort ( $ normalized ) ; return $ normalized ; }
7799	protected function getLine ( $ id , $ text , $ offset = 0 , & $ position = null , & $ length = null ) { $ pcre = '/(?:^|\r?\n)\:(' . $ id . ')\:' . '(.+)' . '(:?$|\r?\n\:[[:alnum:]]{2,3}\:)' . '/Us' ; if ( preg_match ( $ pcre , substr ( $ text , $ offset ) , $ match , PREG_OFFSET_CAPTURE ) ) { $ position = $ offset + $ match [ 1 ] [ 1 ] - 1 ; $ length = strlen ( $ match [ 2 ] [ 0 ] ) ; return rtrim ( $ match [ 2 ] [ 0 ] ) ; } return '' ; }
6257	public function authorize ( $ user , Request $ request ) { $ roleField = $ this -> _config [ 'roleField' ] ; if ( ! isset ( $ user [ $ roleField ] ) ) { throw new RuntimeException ( sprintf ( 'The role field `%s` does not exist!' , $ roleField ) ) ; } if ( is_string ( $ user [ $ roleField ] ) ) { $ user [ $ roleField ] = array ( $ user [ $ roleField ] ) ; } if ( $ this -> authorizeByPrefix ( $ user [ $ roleField ] , $ request ) ) { return true ; } if ( $ this -> authorizeByControllerAndAction ( $ user , $ request ) ) { return true ; } return false ; }
483	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ time = $ this -> beginCommand ( 'create' . ( $ unique ? ' unique' : '' ) . " index $name on $table (" . implode ( ',' , ( array ) $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
3473	public function set ( string $ key , $ value ) : void { $ key = explode ( '.' , $ key ) ; $ last = array_pop ( $ key ) ; $ result = & $ this -> config ; foreach ( $ key as $ part ) { if ( ! isset ( $ result [ $ part ] ) || ! is_array ( $ result [ $ part ] ) ) { $ result [ $ part ] = [ ] ; } $ result = & $ result [ $ part ] ; } $ result [ $ last ] = $ value ; }
21	private function revert ( $ level ) { while ( ! $ this -> decisions -> isEmpty ( ) ) { $ literal = $ this -> decisions -> lastLiteral ( ) ; if ( $ this -> decisions -> undecided ( $ literal ) ) { break ; } $ decisionLevel = $ this -> decisions -> decisionLevel ( $ literal ) ; if ( $ decisionLevel <= $ level ) { break ; } $ this -> decisions -> revertLast ( ) ; $ this -> propagateIndex = count ( $ this -> decisions ) ; } while ( ! empty ( $ this -> branches ) && $ this -> branches [ count ( $ this -> branches ) - 1 ] [ self :: BRANCH_LEVEL ] >= $ level ) { array_pop ( $ this -> branches ) ; } }
9060	public function setPrimaryKey ( string ... $ key ) : self { $ this -> primaryKey = new PrimaryKey ( $ this , ... $ key ) ; return $ this ; }
6012	public function addCommentResponse ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate CommentResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "CommentResponse"!' , E_USER_WARNING ) ; } } $ this -> replies [ ] = $ item ; return $ this ; }
578	public static function to ( $ url = '' , $ scheme = false ) { if ( is_array ( $ url ) ) { return static :: toRoute ( $ url , $ scheme ) ; } $ url = Yii :: getAlias ( $ url ) ; if ( $ url === '' ) { $ url = Yii :: $ app -> getRequest ( ) -> getUrl ( ) ; } if ( $ scheme === false ) { return $ url ; } if ( static :: isRelative ( $ url ) ) { $ url = static :: getUrlManager ( ) -> getHostInfo ( ) . '/' . ltrim ( $ url , '/' ) ; } return static :: ensureScheme ( $ url , $ scheme ) ; }
10552	public function resolveApp ( ) { $ this -> determineVirtualHost ( ) ; $ path = $ this -> vhost -> getPath ( $ this -> request -> url ) ; $ resolved = $ this -> resolver -> resolve ( "app" , $ path ) ; if ( $ resolved !== null ) { if ( $ resolved [ 'ext' ] ) { $ mime = new FileType ( $ resolved [ 'ext' ] , "" ) ; if ( ! empty ( $ mime ) ) { $ str = $ mime -> getMimeType ( ) . ";q=1.5," . ( string ) $ this -> request -> accept ; $ this -> request -> setAccept ( new Accept ( $ str ) ) ; } $ this -> suffix = $ resolved [ 'ext' ] ; } $ this -> route = $ resolved [ 'route' ] ; $ this -> app = $ resolved [ 'path' ] ; $ this -> arguments = new Dictionary ( $ resolved [ 'remainder' ] ) ; } else { $ this -> route = null ; $ this -> app = null ; $ this -> arguments = new Dictionary ( ) ; } }
4877	public static function factory ( ContainerInterface $ container ) { $ config = $ container -> get ( 'ApplicationConfig' ) ; $ options = new ListenerOptions ( $ config [ 'module_listener_options' ] ) ; return new static ( $ options ) ; }
9725	public function getTemporaryFilename ( $ extension = 'xlsx' ) { $ temporaryFilename = tempnam ( $ this -> getTemporaryFolder ( ) , 'phpspreadsheet-' ) ; unlink ( $ temporaryFilename ) ; return $ temporaryFilename . '.' . $ extension ; }
6079	public function combineSlides ( array $ structure ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'structure' => $ structure ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/slides/combine' , $ parameters ) ; return $ result ; }
5768	public function addColumn ( string $ name , $ value ) { $ this -> args [ ] = $ value ; if ( count ( $ this -> args ) > 1 ) { $ this -> setColumnsValues .= ", " ; } $ argNum = count ( $ this -> args ) ; $ this -> setColumnsValues .= "$name = \$" . $ argNum ; }
5603	public function paintException ( $ exception ) { if ( ! $ this -> fail && ! $ this -> error ) { $ this -> error = true ; $ message = 'Unexpected exception of type[' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; $ this -> message = self :: escapeVal ( $ message ) ; $ this -> listener -> write ( '{status:"error",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
6722	public function fetchAccessToken ( $ code ) { $ this -> validateTokenParams ( ) ; $ this -> oauth2 -> tokenUrl = $ this -> tokenUrl ; $ this -> oauth2 -> clientId = $ this -> clientId ; $ this -> oauth2 -> clientSecret = $ this -> clientSecret ; try { $ response = $ this -> oauth2 -> fetchAccessToken ( $ code ) ; } catch ( Exception $ ex ) { throw new Oauth2ClientException ( $ ex -> getMessage ( ) ) ; } return $ this -> handleTokenResponse ( $ response ) ; }
7706	function _ApplyDiffFromStart ( $ Diff ) { $ this -> pST_PosEnd += $ Diff ; $ this -> pST_Src = false ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ Diff ; $ this -> PosEnd += $ Diff ; }
10324	private function createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source ) { $ queryParameters = array ( ) ; if ( isset ( $ fromDate ) ) $ queryParameters [ 'from_date' ] = $ fromDate ; if ( isset ( $ toDate ) ) $ queryParameters [ 'to_date' ] = $ toDate ; if ( isset ( $ source ) ) $ queryParameters [ 'source' ] = $ source ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "ids" , $ contactIds ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "emails" , $ contactEmails ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "eids" , $ contactExternalIds ) ; if ( isset ( $ mailingIds ) ) { $ queryParameters [ 'mailing_id' ] = array ( ) ; foreach ( $ mailingIds as $ mailingId ) { $ queryParameters [ 'mailing_id' ] [ ] = $ mailingId ; } } return $ queryParameters ; }
1873	private function addBundles ( ContainerBuilder $ container ) : void { $ packages = $ container -> getDefinition ( 'assets.packages' ) ; $ context = new Reference ( 'contao.assets.assets_context' ) ; if ( $ container -> hasDefinition ( 'assets._version_default' ) ) { $ version = new Reference ( 'assets._version_default' ) ; } else { $ version = new Reference ( 'assets.empty_version_strategy' ) ; } $ bundles = $ container -> getParameter ( 'kernel.bundles' ) ; $ meta = $ container -> getParameter ( 'kernel.bundles_metadata' ) ; foreach ( $ bundles as $ name => $ class ) { if ( ! is_dir ( $ meta [ $ name ] [ 'path' ] . '/Resources/public' ) ) { continue ; } $ packageVersion = $ version ; $ packageName = $ this -> getBundlePackageName ( $ name ) ; $ serviceId = 'assets._package_' . $ packageName ; $ basePath = 'bundles/' . preg_replace ( '/bundle$/' , '' , strtolower ( $ name ) ) ; if ( is_file ( $ meta [ $ name ] [ 'path' ] . '/Resources/public/manifest.json' ) ) { $ def = new ChildDefinition ( 'assets.json_manifest_version_strategy' ) ; $ def -> replaceArgument ( 0 , $ meta [ $ name ] [ 'path' ] . '/Resources/public/manifest.json' ) ; $ container -> setDefinition ( 'assets._version_' . $ packageName , $ def ) ; $ packageVersion = new Reference ( 'assets._version_' . $ packageName ) ; } $ container -> setDefinition ( $ serviceId , $ this -> createPackageDefinition ( $ basePath , $ packageVersion , $ context ) ) ; $ packages -> addMethodCall ( 'addPackage' , [ $ packageName , new Reference ( $ serviceId ) ] ) ; } }
9768	function lengthOf ( int $ value = null ) : self { if ( $ value === null ) return $ this -> setFlag ( 'length' ) ; if ( is_string ( $ this -> target ) ) { $ constraint = equalTo ( $ value ) ; $ target = mb_strlen ( $ this -> target ) ; } else { $ constraint = countOf ( $ value ) ; $ target = $ this -> target ; } return $ this -> expect ( $ target , $ constraint ) ; }
10709	public function getManyPaginated ( $ perPage = null , $ columns = [ '*' ] ) { $ query = $ this -> getQuery ( ) ; $ results = $ query -> paginate ( $ perPage , $ columns ) ; return $ this -> returnResults ( $ results ) ; }
11617	public function records ( $ startTime , $ endTime , $ page = 1 , $ pageSize = 10 ) { $ params = [ 'starttime' => is_numeric ( $ startTime ) ? $ startTime : strtotime ( $ startTime ) , 'endtime' => is_numeric ( $ endTime ) ? $ endTime : strtotime ( $ endTime ) , 'pageindex' => $ page , 'pagesize' => $ pageSize , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_RECORDS , $ params ] ) ; }
6750	public function getTransformer ( ) { if ( ! property_exists ( $ this , 'transformer' ) || ! $ this -> transformer ) { if ( ! $ this -> _defaultTransformer ) { $ this -> createQualifiedTransformerClass ( ) ; } return $ this -> _defaultTransformer ; } return $ this -> transformer ; }
2977	public function unserialize ( $ serialized ) { $ this -> data = unserialize ( $ serialized ) ; $ this -> closure = __reconstruct_closure ( $ this -> data ) ; if ( ! $ this -> closure instanceof Closure ) { throw new ClosureUnserializationException ( 'The closure is corrupted and cannot be unserialized.' ) ; } if ( $ this -> data [ 'binding' ] || $ this -> data [ 'isStatic' ] ) { $ this -> closure = $ this -> closure -> bindTo ( $ this -> data [ 'binding' ] , $ this -> data [ 'scope' ] ) ; } }
8075	private function handle ( Response $ response ) { $ stream = stream_for ( $ response -> getBody ( ) ) ; $ data = json_decode ( $ stream -> getContents ( ) ) ; return $ data ; }
7723	public function objectToArray ( $ object , $ array = [ ] ) { $ reflectionClass = new \ ReflectionClass ( get_class ( $ object ) ) ; foreach ( $ reflectionClass -> getProperties ( ) as $ property ) { $ property -> setAccessible ( true ) ; $ name = trim ( strtolower ( preg_replace ( '/[A-Z]([A-Z](?![a-z]))*/' , '_$0' , $ property -> getName ( ) ) ) , '_' ) ; if ( empty ( $ property -> getValue ( $ object ) ) ) { continue ; } else if ( is_object ( $ property -> getValue ( $ object ) ) ) { $ array [ $ name ] = $ this -> objectToArray ( $ property -> getValue ( $ object ) ) ; } else if ( is_array ( $ property -> getValue ( $ object ) ) ) { foreach ( $ property -> getValue ( $ object ) as $ key => $ value ) { if ( is_object ( $ value ) ) { $ array [ $ name ] [ ] = $ this -> objectToArray ( $ value ) ; } } } else { $ array [ $ name ] = $ property -> getValue ( $ object ) ; } $ property -> setAccessible ( false ) ; } return $ array ; }
5436	protected function getParameterSignatures ( $ method ) { $ signatures = [ ] ; $ parameters = $ method -> getParameters ( ) ; foreach ( $ parameters as $ parameter ) { $ signature = '' ; $ signature .= $ this -> getParameterTypeHint ( $ parameter ) ; if ( $ parameter -> isPassedByReference ( ) ) { $ signature .= '&' ; } $ isVariadic = ( PHP_VERSION_ID >= 50600 ) && $ parameter -> isVariadic ( ) ; if ( $ isVariadic ) { $ signature .= '...' ; } $ signature .= '$' . $ parameter -> getName ( ) ; if ( ! $ isVariadic ) { if ( $ parameter -> isDefaultValueAvailable ( ) ) { $ signature .= ' = ' . var_export ( $ parameter -> getDefaultValue ( ) , true ) ; } elseif ( $ parameter -> isOptional ( ) ) { $ signature .= ' = null' ; } } $ signatures [ ] = $ signature ; } return implode ( ', ' , $ signatures ) ; }
10922	public function setRows ( array $ rows ) { foreach ( $ rows as $ row ) { $ columnNumber = 0 ; if ( ! is_array ( $ row ) ) { $ row = [ $ row ] ; } foreach ( $ row as $ column => $ value ) { $ this -> updateWidth ( $ columnNumber , $ this -> length ( $ column ) ) ; $ this -> updateWidth ( $ columnNumber , $ this -> length ( $ value ) ) ; if ( ! in_array ( $ column , $ this -> columns ) ) { $ this -> columns [ ] = $ column ; } $ columnNumber ++ ; } $ this -> rows [ ] = $ row ; } }
12073	public function getForcedQualificationCustomers ( ) { if ( is_null ( $ this -> cacheForcedRanks ) ) { $ custIds = $ this -> getForcedCustomersIds ( ) ; $ ranks = $ this -> getCfgParamsByRanks ( ) ; $ this -> cacheForcedRanks = [ ] ; foreach ( $ custIds as $ item ) { $ custId = $ item [ Customer :: A_CUSTOMER_REF ] ; $ ref = $ item [ Customer :: A_MLM_ID ] ; $ rankCode = $ this -> QUALIFIED_CUSTOMERS [ $ ref ] [ 1 ] ; $ cfgParamsWithSchemes = $ ranks [ $ rankCode ] ; $ this -> cacheForcedRanks [ $ custId ] = $ cfgParamsWithSchemes ; } $ this -> cacheForcedCustomerIds = array_keys ( $ this -> cacheForcedRanks ) ; } return $ this -> cacheForcedRanks ; }
6119	public function serverDelete ( $ sid ) { $ this -> serverListReset ( ) ; $ this -> execute ( "serverdelete" , array ( "sid" => $ sid ) ) ; Signal :: getInstance ( ) -> emit ( "notifyServerdeleted" , $ this , $ sid ) ; }
5031	public function setLoadedPage ( $ loadedPage ) { $ this -> dispatch ( Event \ PageEvents :: PAGE_VIEW , new Event \ PageViewEvent ( $ loadedPage ) ) ; $ this -> loadedPage = $ loadedPage ; }
7567	protected function parse_adjacent ( ) { $ tmp = $ this -> result ; $ this -> result = array ( ) ; if ( ( $ c = $ this -> parse_conditions ( ) ) === false ) { return false ; } foreach ( $ tmp as $ t ) { if ( ( $ sibling = $ t -> getNextSibling ( ) ) !== false ) { if ( $ sibling -> match ( $ c , true , $ this -> custom_filter_map ) ) { $ this -> result [ ] = $ sibling ; } } } return true ; }
10177	public function cloneCellCollection ( Worksheet $ parent ) { $ this -> storeCurrentCell ( ) ; $ newCollection = clone $ this ; $ newCollection -> parent = $ parent ; if ( ( $ newCollection -> currentCell !== null ) && ( is_object ( $ newCollection -> currentCell ) ) ) { $ newCollection -> currentCell -> attach ( $ this ) ; } $ oldKeys = $ newCollection -> getAllCacheKeys ( ) ; $ oldValues = $ newCollection -> cache -> getMultiple ( $ oldKeys ) ; $ newValues = [ ] ; $ oldCachePrefix = $ newCollection -> cachePrefix ; $ newCollection -> cachePrefix = $ newCollection -> getUniqueID ( ) ; foreach ( $ oldValues as $ oldKey => $ value ) { $ newValues [ str_replace ( $ oldCachePrefix , $ newCollection -> cachePrefix , $ oldKey ) ] = clone $ value ; } $ stored = $ newCollection -> cache -> setMultiple ( $ newValues ) ; if ( ! $ stored ) { $ newCollection -> __destruct ( ) ; throw new PhpSpreadsheetException ( 'Failed to copy cells in cache' ) ; } return $ newCollection ; }
316	public function renderAjax ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; $ this -> beginPage ( ) ; $ this -> head ( ) ; $ this -> beginBody ( ) ; echo $ this -> renderFile ( $ viewFile , $ params , $ context ) ; $ this -> endBody ( ) ; $ this -> endPage ( true ) ; return ob_get_clean ( ) ; }
12107	public function getPage ( $ name ) { if ( ! isset ( $ this -> pages [ $ name ] ) ) { throw new InvalidParameterException ( "Page not found" ) ; } return $ this -> pages [ $ name ] ; }
4188	public function boot ( Factory $ validator ) { $ passwordStrength = app ( 'passwordStrength' ) ; $ translator = app ( 'passwordStrength.translationProvider' ) -> get ( $ validator ) ; foreach ( [ 'letters' , 'numbers' , 'caseDiff' , 'symbols' ] as $ rule ) { $ snakeCasedRule = snake_case ( $ rule ) ; $ validator -> extend ( $ rule , function ( $ _ , $ value , $ __ ) use ( $ passwordStrength , $ rule ) { $ capitalizedRule = ucfirst ( $ rule ) ; return call_user_func ( [ $ passwordStrength , "validate{$capitalizedRule}" ] , $ value ) ; } , $ translator -> get ( "password-strength::validation.{$snakeCasedRule}" ) ) ; } }
5069	public function infoRead ( int & $ msgsInQueue = null ) : ? CurlMultiInfoInterface { $ info = curl_multi_info_read ( $ this -> mh , $ msgsInQueue ) ; if ( ! $ info ) { return null ; } return new CurlMultiInfo ( $ info ) ; }
8670	public static function fromRecursive ( $ collection ) { $ arr = Arr :: from ( $ collection ) ; foreach ( $ arr as $ key => $ value ) { if ( $ value instanceof stdClass || \ is_iterable ( $ value ) ) { $ value = static :: fromRecursive ( $ value ) ; } $ arr [ $ key ] = $ value ; } return new static ( $ arr ) ; }
5948	protected function waitForReadyRead ( $ time = 0 ) { if ( ! $ this -> isConnected ( ) || $ this -> config [ "blocking" ] ) { return ; } do { $ read = array ( $ this -> stream ) ; $ null = null ; if ( $ time ) { Signal :: getInstance ( ) -> emit ( strtolower ( $ this -> getAdapterType ( ) ) . "WaitTimeout" , $ time , $ this -> getAdapter ( ) ) ; } $ time = $ time + $ this -> config [ "timeout" ] ; } while ( @ stream_select ( $ read , $ null , $ null , $ this -> config [ "timeout" ] ) == 0 ) ; }
5472	private function getPrivatePropertyNoMatterWhat ( $ name , $ object ) { foreach ( ( array ) $ object as $ mangled_name => $ value ) { if ( $ this -> unmangle ( $ mangled_name ) == $ name ) { return $ value ; } } }
12876	private function setNamespace ( $ serviceName = null ) { if ( $ serviceName === null ) { $ this -> storage -> getOptions ( ) -> setNamespace ( $ this -> defaultNamespace ) ; } else { $ this -> storage -> getOptions ( ) -> setNamespace ( $ serviceName ) ; } }
12239	public function innerXML ( ) { $ xml = $ this -> outerXML ( ) ; $ pos = 1 + strpos ( $ xml , '>' ) ; $ len = strrpos ( $ xml , '<' ) - $ pos ; return substr ( $ xml , $ pos , $ len ) ; }
3885	private function collectRulesFor ( $ parentSetting , $ filterSettings ) { $ childInformation = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_filtersetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' , 'ASC' ) -> setParameter ( 'pid' , $ parentSetting -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ childInformation -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ childSetting = $ this -> createSetting ( $ item , $ filterSettings ) ; if ( $ childSetting ) { $ parentSetting -> addChild ( $ childSetting ) ; } } }
1268	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ avRequest = $ xml -> appendChild ( $ xml -> createElement ( 'AddressValidationRequest' ) ) ; $ avRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ avRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'AV' ) ) ; if ( null !== $ this -> address ) { $ addressNode = $ avRequest -> appendChild ( $ xml -> createElement ( 'Address' ) ) ; if ( $ this -> address -> getStateProvinceCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'StateProvinceCode' , $ this -> address -> getStateProvinceCode ( ) ) ) ; } if ( $ this -> address -> getCity ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'City' , $ this -> address -> getCity ( ) ) ) ; } if ( $ this -> address -> getCountryCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'CountryCode' , $ this -> address -> getCountryCode ( ) ) ) ; } if ( $ this -> address -> getPostalCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'PostalCode' , $ this -> address -> getPostalCode ( ) ) ) ; } } return $ xml -> saveXML ( ) ; }
6785	public function buildFormDataString ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ formOptions = [ ] ; foreach ( $ this -> formParameters as $ key => $ isFormParameter ) { if ( $ isFormParameter && isset ( $ options [ $ key ] ) ) { $ formOptions [ $ key ] = $ options [ $ key ] ; } } return http_build_query ( $ formOptions ) ; }
3004	public function save ( $ filename ) { $ f3 = \ Base :: instance ( ) ; $ lines = explode ( "\n" , $ this -> smtp -> log ( ) ) ; $ start = false ; $ out = '' ; for ( $ i = 0 , $ max = count ( $ lines ) ; $ i < $ max ; $ i ++ ) { if ( ! $ start && preg_match ( '/^354.*?$/' , $ lines [ $ i ] , $ matches ) ) { $ start = true ; continue ; } elseif ( preg_match ( '/^250.*?$\s^QUIT/m' , $ lines [ $ i ] . ( $ i + 1 < $ max ? "\n" . $ lines [ $ i + 1 ] : '' ) , $ matches ) ) break ; if ( $ start ) $ out .= $ lines [ $ i ] . "\n" ; } if ( $ out ) { $ path = $ f3 -> get ( 'mailer.storage_path' ) ; if ( ! is_dir ( $ path ) ) mkdir ( $ path , 0777 , true ) ; $ f3 -> write ( $ path . $ filename , $ out ) ; } }
3562	protected function hasMutator ( $ value , $ dir = 'setter' , $ type = null ) { return ( bool ) $ this -> getMutator ( $ value , $ dir , $ type ) ; }
2782	public function renderShadowMark ( $ count , $ current , $ eolInterval = 60 ) { $ this -> progressCount ++ ; $ this -> write ( '<fg=blue;options=bold>S</fg=blue;options=bold>' , false ) ; if ( ( $ this -> progressCount % $ eolInterval ) == 0 ) { $ counter = str_pad ( $ this -> progressCount , 5 , ' ' , STR_PAD_LEFT ) ; $ this -> write ( ' |' . $ counter . ' (' . str_pad ( $ current , strlen ( $ count ) , ' ' , STR_PAD_LEFT ) . '/' . $ count . ')' . PHP_EOL , false ) ; } }
2405	public function minifyHtml ( $ strHtml ) { if ( Config :: get ( 'debugMode' ) ) { return $ strHtml ; } $ arrChunks = preg_split ( '@(</?pre[^>]*>)|(</?script[^>]*>)|(</?style[^>]*>)|( ?</?textarea[^>]*>)@i' , $ strHtml , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; $ strHtml = '' ; $ blnPreserveNext = false ; $ blnOptimizeNext = false ; $ strType = null ; $ isJavaScript = function ( $ strChunk ) { $ typeMatch = array ( ) ; if ( preg_match ( '/\stype\s*=\s*(?:(?J)(["\'])\s*(?<type>.*?)\s*\1|(?<type>[^\s>]+))/i' , $ strChunk , $ typeMatch ) && ! \ in_array ( strtolower ( $ typeMatch [ 'type' ] ) , static :: $ validJavaScriptTypes ) ) { return false ; } if ( preg_match ( '/\slanguage\s*=\s*(?:(?J)(["\'])\s*(?<type>.*?)\s*\1|(?<type>[^\s>]+))/i' , $ strChunk , $ typeMatch ) && ! \ in_array ( 'text/' . strtolower ( $ typeMatch [ 'type' ] ) , static :: $ validJavaScriptTypes ) ) { return false ; } return true ; } ; foreach ( $ arrChunks as $ strChunk ) { if ( strncasecmp ( $ strChunk , '<pre' , 4 ) === 0 || strncasecmp ( ltrim ( $ strChunk ) , '<textarea' , 9 ) === 0 ) { $ blnPreserveNext = true ; } elseif ( strncasecmp ( $ strChunk , '<script' , 7 ) === 0 ) { if ( $ isJavaScript ( $ strChunk ) ) { $ blnOptimizeNext = true ; $ strType = 'js' ; } else { $ blnPreserveNext = true ; } } elseif ( strncasecmp ( $ strChunk , '<style' , 6 ) === 0 ) { $ blnOptimizeNext = true ; $ strType = 'css' ; } elseif ( $ blnPreserveNext ) { $ blnPreserveNext = false ; } elseif ( $ blnOptimizeNext ) { $ blnOptimizeNext = false ; if ( $ strType == 'js' ) { $ objMinify = new Minify \ JS ( ) ; $ objMinify -> add ( $ strChunk ) ; $ strChunk = $ objMinify -> minify ( ) ; } elseif ( $ strType == 'css' ) { $ objMinify = new Minify \ CSS ( ) ; $ objMinify -> add ( $ strChunk ) ; $ strChunk = $ objMinify -> minify ( ) ; } } else { $ strChunk = str_replace ( "\r" , '' , $ strChunk ) ; $ strChunk = preg_replace ( array ( '/^[\t ]+/m' , '/[\t ]+$/m' , '/\n\n+/' ) , array ( '' , '' , "\n" ) , $ strChunk ) ; } $ strHtml .= $ strChunk ; } return trim ( $ strHtml ) ; }
6829	protected function prioritizeAssignment ( Stock \ StockAssignmentInterface $ assignment ) { if ( $ assignment -> isFullyShipped ( ) || $ assignment -> isFullyShippable ( ) ) { return false ; } if ( 0 >= $ quantity = $ assignment -> getSoldQuantity ( ) - $ assignment -> getShippableQuantity ( ) ) { return false ; } $ changed = false ; $ helper = new PrioritizeHelper ( $ this -> unitResolver ) ; $ sourceUnit = $ assignment -> getStockUnit ( ) ; $ candidates = $ helper -> getUnitCandidates ( $ assignment , $ quantity ) ; foreach ( $ candidates as $ candidate ) { $ targetUnit = $ candidate -> unit ; if ( ( 0 < $ quantity - $ targetUnit -> getReservableQuantity ( ) ) && ( $ combination = $ candidate -> combination ) ) { foreach ( $ combination -> map as $ id => $ qty ) { if ( null === $ a = $ candidate -> getAssignmentById ( $ id ) ) { throw new StockLogicException ( "Assignment not found." ) ; } $ this -> moveAssignment ( $ a , $ sourceUnit , min ( $ qty , $ quantity ) ) ; } } $ delta = min ( $ quantity , $ targetUnit -> getReservableQuantity ( ) ) ; $ quantity -= $ this -> moveAssignment ( $ assignment , $ targetUnit , $ delta ) ; $ changed = true ; if ( 0 >= $ quantity ) { break ; } } return $ changed ; }
2222	public static function countPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; }
4344	protected function pushStack ( $ funcName ) { $ this -> funcStack [ ] = array ( 'function' => $ funcName , 'tsStart' => $ this -> timeLastTick , 'subTime' => 0 , ) ; if ( ! isset ( $ this -> data [ $ funcName ] ) ) { $ this -> data [ $ funcName ] = array ( 'calls' => 0 , 'totalTime' => 0 , 'ownTime' => 0 , ) ; } $ this -> data [ $ funcName ] [ 'calls' ] ++ ; }
1568	public function getResourceId ( ) : ? string { if ( is_null ( $ this -> resourceId ) ) { return $ this -> parameter ( ResourceRegistrar :: PARAM_RESOURCE_ID ) ; } return $ this -> resourceId ? : null ; }
2491	private function configureSearchServices ( ContainerBuilder $ container , $ connectionName , $ connectionParams ) { $ alias = $ this -> getAlias ( ) ; $ endpointResolverDefinition = new DefinitionDecorator ( self :: ENDPOINT_RESOLVER_ID ) ; $ endpointResolverDefinition -> replaceArgument ( 0 , $ connectionParams [ 'entry_endpoints' ] ) ; $ endpointResolverDefinition -> replaceArgument ( 1 , $ connectionParams [ 'mapping' ] [ 'translations' ] ) ; $ endpointResolverDefinition -> replaceArgument ( 2 , $ connectionParams [ 'mapping' ] [ 'default' ] ) ; $ endpointResolverDefinition -> replaceArgument ( 3 , $ connectionParams [ 'mapping' ] [ 'main_translations' ] ) ; $ endpointResolverId = "$alias.connection.$connectionName.endpoint_resolver_id" ; $ container -> setDefinition ( $ endpointResolverId , $ endpointResolverDefinition ) ; $ coreFilterDefinition = new DefinitionDecorator ( self :: CORE_FILTER_ID ) ; $ coreFilterDefinition -> replaceArgument ( 0 , new Reference ( $ endpointResolverId ) ) ; $ coreFilterId = "$alias.connection.$connectionName.core_filter_id" ; $ container -> setDefinition ( $ coreFilterId , $ coreFilterDefinition ) ; $ gatewayDefinition = new DefinitionDecorator ( self :: GATEWAY_ID ) ; $ gatewayDefinition -> replaceArgument ( 1 , new Reference ( $ endpointResolverId ) ) ; $ gatewayId = "$alias.connection.$connectionName.gateway_id" ; $ container -> setDefinition ( $ gatewayId , $ gatewayDefinition ) ; }
12827	protected function removeBlockFromSlotFile ( array $ options , $ targetDir = null ) { $ targetDir = $ this -> workDirectory ( $ targetDir ) ; $ slot = $ this -> getSlotDefinition ( $ targetDir ) ; $ blockName = $ options [ "blockname" ] ; $ tmp = array_flip ( $ slot [ "blocks" ] ) ; unset ( $ tmp [ $ blockName ] ) ; $ slot [ "blocks" ] = array_keys ( $ tmp ) ; $ this -> saveSlotDefinition ( $ targetDir , $ slot ) ; return $ blockName ; }
7662	function CreateBody ( ) { $ result = "" ; $ this -> SetWordWrap ( ) ; switch ( $ this -> message_type ) { case "alt" : $ result .= $ this -> GetBoundary ( $ this -> boundary [ 1 ] , "" , "text/plain" , "" ) ; $ result .= $ this -> EncodeString ( $ this -> AltBody , $ this -> Encoding ) ; $ result .= $ this -> LE . $ this -> LE ; $ result .= $ this -> GetBoundary ( $ this -> boundary [ 1 ] , "" , "text/html" , "" ) ; $ result .= $ this -> EncodeString ( $ this -> Body , $ this -> Encoding ) ; $ result .= $ this -> LE . $ this -> LE ; $ result .= $ this -> EndBoundary ( $ this -> boundary [ 1 ] ) ; break ; case "plain" : $ result .= $ this -> EncodeString ( $ this -> Body , $ this -> Encoding ) ; break ; case "attachments" : $ result .= $ this -> GetBoundary ( $ this -> boundary [ 1 ] , "" , "" , "" ) ; $ result .= $ this -> EncodeString ( $ this -> Body , $ this -> Encoding ) ; $ result .= $ this -> LE ; $ result .= $ this -> AttachAll ( ) ; break ; case "alt_attachments" : $ result .= sprintf ( "--%s%s" , $ this -> boundary [ 1 ] , $ this -> LE ) ; $ result .= sprintf ( "Content-Type: %s;%s" . "\tboundary=\"%s\"%s" , "multipart/alternative" , $ this -> LE , $ this -> boundary [ 2 ] , $ this -> LE . $ this -> LE ) ; $ result .= $ this -> GetBoundary ( $ this -> boundary [ 2 ] , "" , "text/plain" , "" ) . $ this -> LE ; $ result .= $ this -> EncodeString ( $ this -> AltBody , $ this -> Encoding ) ; $ result .= $ this -> LE . $ this -> LE ; $ result .= $ this -> GetBoundary ( $ this -> boundary [ 2 ] , "" , "text/html" , "" ) . $ this -> LE ; $ result .= $ this -> EncodeString ( $ this -> Body , $ this -> Encoding ) ; $ result .= $ this -> LE . $ this -> LE ; $ result .= $ this -> EndBoundary ( $ this -> boundary [ 2 ] ) ; $ result .= $ this -> AttachAll ( ) ; break ; } if ( $ this -> IsError ( ) ) $ result = "" ; return $ result ; }
4321	public static function arrayPathGet ( $ array , $ path ) { if ( ! \ is_array ( $ path ) ) { $ path = \ array_filter ( \ preg_split ( '#[\./]#' , $ path ) , 'strlen' ) ; } $ path = \ array_reverse ( $ path ) ; while ( $ path ) { $ key = \ array_pop ( $ path ) ; $ arrayAccess = \ is_array ( $ array ) || $ array instanceof \ ArrayAccess ; if ( ! $ arrayAccess ) { return null ; } elseif ( isset ( $ array [ $ key ] ) ) { $ array = $ array [ $ key ] ; } elseif ( $ key == '__count__' ) { return \ count ( $ array ) ; } elseif ( $ key == '__end__' ) { \ end ( $ array ) ; $ path [ ] = \ key ( $ array ) ; } elseif ( $ key == '__reset__' ) { \ reset ( $ array ) ; $ path [ ] = \ key ( $ array ) ; } else { return null ; } } return $ array ; }
6305	public function getDistance ( Point $ point , DistanceInterface $ calculator = null ) { $ calculator = $ calculator ? : static :: getCalculator ( ) ; return $ calculator -> getDistance ( new Coordinate ( $ this -> latitude , $ this -> longitude ) , new Coordinate ( $ point -> latitude , $ point -> longitude ) ) ; }
12045	public function destroy ( UserPolicy $ user , Question $ question ) { return $ question -> user_id == user_id ( ) && $ question -> user_type == user_type ( ) ; }
4063	private static function calculateArrayDiff ( $ expected , $ actual , $ strict ) { if ( count ( $ expected ) !== count ( $ actual ) ) { throw new \ LogicException ( sprintf ( 'Array element count mismatch. Found %s, expected %s.' , count ( $ actual ) , count ( $ expected ) ) , self :: ARRAY_COUNT_MISMATCH ) ; } reset ( $ actual ) ; foreach ( $ expected as $ key => $ value ) { if ( $ key !== key ( $ actual ) ) { throw new \ LogicException ( sprintf ( 'Array key mismatch. Found %s, expected %s.' , key ( $ actual ) , $ key ) , self :: ARRAY_KEY_MISMATCH ) ; } try { self :: calculateDiff ( $ value , current ( $ actual ) , $ strict ) ; } catch ( \ Exception $ exception ) { throw new \ LogicException ( sprintf ( 'Array value mismatch for key %s.' , key ( $ actual ) ) , self :: ARRAY_VALUE_MISMATCH , $ exception ) ; } next ( $ actual ) ; } }
5528	protected function createCodeForMethods ( $ methods ) { $ code = '' ; $ methods = array_merge ( $ methods , $ this -> reflection -> getMethods ( ) ) ; foreach ( $ methods as $ method ) { if ( $ this -> isConstructorOrDeconstructor ( $ method ) ) { continue ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_base ) ; if ( in_array ( $ method , $ mock_reflection -> getMethods ( ) ) ) { continue ; } $ code .= ' ' . $ this -> reflection -> getSignature ( $ method ) ; if ( $ mock_reflection -> isAbstract ( ) ) { $ code .= ";\n" ; } else { $ code .= " {\n" ; $ code .= " return \$this->invoke(\"$method\", func_get_args());\n" ; $ code .= " }\n" ; } } return $ code ; }
6849	public static function months ( $ format = null ) { $ months = array ( ) ; if ( $ format === static :: MONTHS_LONG || $ format === static :: MONTHS_SHORT ) { for ( $ i = 1 ; $ i <= 12 ; ++ $ i ) { $ months [ $ i ] = strftime ( $ format , mktime ( 0 , 0 , 0 , $ i , 1 ) ) ; } } else { $ months = static :: hours ( ) ; } return $ months ; }
6096	public function memberOf ( ) { $ groups = array ( $ this -> getParent ( ) -> channelGroupGetById ( $ this [ "client_channel_group_id" ] ) ) ; foreach ( explode ( "," , $ this [ "client_servergroups" ] ) as $ sgid ) { $ groups [ ] = $ this -> getParent ( ) -> serverGroupGetById ( $ sgid ) ; } return $ groups ; }
5870	protected static function getBasicMetadata ( $ fileName ) { $ extension = strtolower ( substr ( $ fileName , strrpos ( $ fileName , '.' ) + 1 ) ) ; $ metadata = [ ] ; if ( GeneralUtility :: inList ( 'jpg,jpeg,tif,tiff' , $ extension ) && function_exists ( 'exif_read_data' ) ) { $ exif = @ exif_read_data ( $ fileName ) ; if ( $ exif ) { $ metadata = $ exif ; $ metadata [ 'ImageDescription' ] = static :: safeUtf8Encode ( $ metadata [ 'ImageDescription' ] ) ; if ( isset ( $ metadata [ 'GPSLatitude' ] ) && is_array ( $ metadata [ 'GPSLatitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLatitudeRef' ] ) ? $ metadata [ 'GPSLatitudeRef' ] : 'N' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLatitude' ] ) ; $ decimal *= $ reference === 'N' ? 1 : - 1 ; $ metadata [ 'GPSLatitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSLongitude' ] ) && is_array ( $ metadata [ 'GPSLongitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLongitudeRef' ] ) ? $ metadata [ 'GPSLongitudeRef' ] : 'E' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLongitude' ] ) ; $ decimal *= $ reference === 'E' ? 1 : - 1 ; $ metadata [ 'GPSLongitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSAltitude' ] ) ) { $ rationalParts = explode ( '/' , $ metadata [ 'GPSAltitude' ] ) ; if ( ! empty ( $ rationalParts [ 1 ] ) ) { $ metadata [ 'GPSAltitudeDecimal' ] = $ rationalParts [ 0 ] / $ rationalParts [ 1 ] ; } else { $ metadata [ 'GPSAltitudeDecimal' ] = 0 ; } } } $ imageinfo = [ ] ; if ( function_exists ( 'iptcparse' ) && getimagesize ( $ fileName , $ imageinfo ) ) { if ( isset ( $ imageinfo [ 'APP13' ] ) ) { $ data = iptcparse ( $ imageinfo [ 'APP13' ] ) ; $ mapping = [ '2#005' => 'Title' , '2#025' => 'Keywords' , '2#040' => 'Instructions' , '2#080' => 'Creator' , '2#085' => 'CreatorFunction' , '2#090' => 'City' , '2#092' => 'Location' , '2#095' => 'Region' , '2#100' => 'CountryCode' , '2#101' => 'Country' , '2#103' => 'IdentifierWork' , '2#105' => 'CreatorTitle' , '2#110' => 'Credit' , '2#115' => 'Source' , '2#116' => 'Copyright' , '2#120' => 'Description' , '2#122' => 'DescriptionAuthor' , ] ; foreach ( $ mapping as $ iptcKey => $ metadataKey ) { if ( isset ( $ data [ $ iptcKey ] ) ) { $ metadata [ 'IPTC' . $ metadataKey ] = static :: safeUtf8Encode ( $ data [ $ iptcKey ] [ 0 ] ) ; } } } } } return $ metadata ; }
905	public function isUnaryPredecessorOperator ( $ index ) { static $ potentialSuccessorOperator = [ T_INC , T_DEC ] ; static $ potentialBinaryOperator = [ '+' , '-' , '&' , [ CT :: T_RETURN_REF ] ] ; static $ otherOperators ; if ( null === $ otherOperators ) { $ otherOperators = [ '!' , '~' , '@' , [ T_ELLIPSIS ] ] ; } static $ disallowedPrevTokens ; if ( null === $ disallowedPrevTokens ) { $ disallowedPrevTokens = [ ']' , '}' , ')' , '"' , '`' , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , [ T_CLASS_C ] , [ T_CONSTANT_ENCAPSED_STRING ] , [ T_DEC ] , [ T_DIR ] , [ T_DNUMBER ] , [ T_FILE ] , [ T_FUNC_C ] , [ T_INC ] , [ T_LINE ] , [ T_LNUMBER ] , [ T_METHOD_C ] , [ T_NS_C ] , [ T_STRING ] , [ T_TRAIT_C ] , [ T_VARIABLE ] , ] ; } $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( $ potentialSuccessorOperator ) ) { return ! $ this -> isUnarySuccessorOperator ( $ index ) ; } if ( $ token -> equalsAny ( $ otherOperators ) ) { return true ; } if ( ! $ token -> equalsAny ( $ potentialBinaryOperator ) ) { return false ; } $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( ! $ prevToken -> equalsAny ( $ disallowedPrevTokens ) ) { return true ; } if ( ! $ token -> equals ( '&' ) || ! $ prevToken -> isGivenKind ( T_STRING ) ) { return false ; } static $ searchTokens = [ ';' , '{' , '}' , [ T_FUNCTION ] , [ T_OPEN_TAG ] , [ T_OPEN_TAG_WITH_ECHO ] , ] ; $ prevToken = $ tokens [ $ tokens -> getPrevTokenOfKind ( $ index , $ searchTokens ) ] ; return $ prevToken -> isGivenKind ( T_FUNCTION ) ; }
7784	public function addParser ( $ name , $ class , $ before = null ) { if ( $ before === null ) { $ this -> parsers [ $ name ] = $ class ; return $ this ; } if ( ( $ offset = array_search ( $ before , array_keys ( $ this -> parsers ) ) ) !== false ) { $ this -> parsers = array_slice ( $ this -> parsers , 0 , $ offset , true ) + array ( $ name => $ class ) + array_slice ( $ this -> parsers , $ offset , null , true ) ; return $ this ; } throw new \ RuntimeException ( sprintf ( 'Parser "%s" does not exist.' , $ before ) ) ; }
3138	public function emptyResponse ( RunnerServiceContext $ context , $ responses ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ similar = 0 ; foreach ( $ responses as $ responseVariable ) { $ value = $ responseVariable -> getValue ( ) ; $ default = $ responseVariable -> getDefaultValue ( ) ; if ( TestRunnerUtils :: isQtiValueNull ( $ value ) === true ) { if ( TestRunnerUtils :: isQtiValueNull ( $ default ) === true ) { $ similar ++ ; } } elseif ( $ value -> equals ( $ default ) === true ) { $ similar ++ ; } } $ respCount = count ( $ responses ) ; return $ respCount > 0 && $ similar == $ respCount ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
5309	protected function getPathFromCircle ( SimpleXMLElement $ circle ) { $ mult = 0.55228475 ; return 'M' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . $ circle [ 'cy' ] . 'C' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] ) . ' ' . $ circle [ 'cx' ] . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] ) . 'C' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] ) . ' ' . $ circle [ 'cy' ] . 'C' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] ) . ' ' . $ circle [ 'cx' ] . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] ) . 'C' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . $ circle [ 'cy' ] . 'Z' ; }
9489	public function getFileData ( $ sFieldName ) { if ( empty ( $ sFieldName ) ) { return null ; } $ obFile = $ this -> $ sFieldName ; if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { return null ; } return $ this -> getFileDataValue ( $ obFile ) ; }
6451	public function isLoggedIn ( ) { $ cookieName = session_name ( ) ; $ cookie = $ this -> getSession ( ) -> getCookie ( $ cookieName ) ; if ( null !== $ cookie ) { $ this -> getSession ( 'goutte' ) -> setCookie ( $ cookieName , $ cookie ) ; return true ; } return false ; }
1912	public function pickerAction ( Request $ request ) : RedirectResponse { $ extras = [ ] ; if ( $ request -> query -> has ( 'extras' ) ) { $ extras = $ request -> query -> get ( 'extras' ) ; if ( ! \ is_array ( $ extras ) ) { throw new BadRequestHttpException ( 'Invalid picker extras' ) ; } } $ config = new PickerConfig ( $ request -> query -> get ( 'context' ) , $ extras , $ request -> query -> get ( 'value' ) ) ; $ picker = $ this -> get ( 'contao.picker.builder' ) -> create ( $ config ) ; if ( null === $ picker ) { throw new BadRequestHttpException ( 'Unsupported picker context' ) ; } return new RedirectResponse ( $ picker -> getCurrentUrl ( ) ) ; }
2810	public function initLogging ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ this -> logging = Mage :: getModel ( 'sheep_debug/logging' ) ; $ this -> logging -> addFile ( $ helper -> getLogFilename ( $ this -> getStoreId ( ) ) ) ; $ this -> logging -> addFile ( $ helper -> getExceptionLogFilename ( $ this -> getStoreId ( ) ) ) ; Mage :: dispatchEvent ( 'sheep_debug_init_logging' , array ( 'logging' => $ this -> logging ) ) ; $ this -> logging -> startRequest ( ) ; }
3956	public function getSiblings ( $ objFilter ) { if ( ! $ this -> getMetaModel ( ) -> hasVariants ( ) ) { return null ; } return $ this -> getMetaModel ( ) -> findVariantsWithBase ( array ( $ this -> get ( 'id' ) ) , $ objFilter ) ; }
9676	public function allFonts ( Spreadsheet $ spreadsheet ) { $ aFonts = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aFonts [ $ style -> getFont ( ) -> getHashCode ( ) ] ) ) { $ aFonts [ $ style -> getFont ( ) -> getHashCode ( ) ] = $ style -> getFont ( ) ; } } return $ aFonts ; }
219	public function asBoolean ( $ value ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return $ value ? $ this -> booleanFormat [ 1 ] : $ this -> booleanFormat [ 0 ] ; }
6463	public function tryGetFirst ( $ name , & $ value ) : bool { try { $ value = $ this -> get ( $ name ) [ 0 ] ; return true ; } catch ( OutOfBoundsException $ ex ) { return false ; } }
6250	protected function filterNestedEmptyGroups ( AclPresenceInterface $ presence ) { if ( $ presence [ 'type' ] !== AclPresenceType :: GROUP ) { return 1 ; } $ permissions = $ presence -> permissions ( ) ; if ( ! $ permissions ) { return 0 ; } if ( is_string ( $ permissions ) ) { return 1 ; } return count ( $ permissions ) ; }
337	protected function extractColumnType ( $ column , $ dbType , $ precision , $ scale , $ length ) { $ column -> dbType = $ dbType ; if ( strpos ( $ dbType , 'FLOAT' ) !== false || strpos ( $ dbType , 'DOUBLE' ) !== false ) { $ column -> type = 'double' ; } elseif ( strpos ( $ dbType , 'NUMBER' ) !== false ) { if ( $ scale === null || $ scale > 0 ) { $ column -> type = 'decimal' ; } else { $ column -> type = 'integer' ; } } elseif ( strpos ( $ dbType , 'INTEGER' ) !== false ) { $ column -> type = 'integer' ; } elseif ( strpos ( $ dbType , 'BLOB' ) !== false ) { $ column -> type = 'binary' ; } elseif ( strpos ( $ dbType , 'CLOB' ) !== false ) { $ column -> type = 'text' ; } elseif ( strpos ( $ dbType , 'TIMESTAMP' ) !== false ) { $ column -> type = 'timestamp' ; } else { $ column -> type = 'string' ; } }
5225	private function resolve ( Injector $ injector , $ type ) { $ resolved = [ ] ; foreach ( $ this -> getBindings ( ) as $ key => $ bindingValue ) { $ value = $ bindingValue ( $ injector , $ this -> name , $ key ) ; if ( $ this -> isTypeMismatch ( $ type , $ value ) ) { $ valueType = ( ( is_object ( $ value ) ) ? ( get_class ( $ value ) ) : ( gettype ( $ value ) ) ) ; throw new BindingException ( 'Value of type ' . $ valueType . ' for ' . ( ( is_int ( $ key ) ) ? ( 'list' ) : ( 'map' ) ) . ' named ' . $ this -> name . ' at position ' . $ key . ' is not of type ' . $ type -> getName ( ) ) ; } $ resolved [ $ key ] = $ value ; } return $ resolved ; }
4038	public function getMatchingIds ( ) { $ arrIds = array ( ) ; foreach ( $ this -> arrChildFilters as $ objChildFilter ) { $ arrChildMatches = $ objChildFilter -> getMatchingIds ( ) ; if ( $ arrChildMatches === null ) { return null ; } if ( $ arrChildMatches && $ this -> stopAfterMatch ) { return $ arrChildMatches ; } if ( $ arrChildMatches ) { $ arrIds = array_merge ( $ arrIds , $ arrChildMatches ) ; } } return array_unique ( $ arrIds ) ; }
6460	public function radioAction ( $ customized , $ selector ) { $ field = $ this -> getWorkingElement ( ) -> findField ( $ selector ) ; $ customized = ( bool ) $ customized ; if ( $ field !== null && ! $ customized ) { $ field -> selectOption ( $ field -> getAttribute ( 'value' ) ) ; return ; } foreach ( $ this -> findLabels ( $ selector ) as $ label ) { if ( $ customized && ! $ label -> isVisible ( ) ) { continue ; } $ label -> click ( ) ; return ; } $ this -> throwNoSuchElementException ( $ selector , $ field ) ; }
600	public function andOnCondition ( $ condition , $ params = [ ] ) { if ( $ this -> on === null ) { $ this -> on = $ condition ; } else { $ this -> on = [ 'and' , $ this -> on , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
7344	protected function preventForbiddenChange ( ShipmentInterface $ shipment ) { if ( $ this -> persistenceHelper -> isChanged ( $ shipment , 'return' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ shipment , 'return' ) ; if ( $ old != $ new ) { throw new RuntimeException ( "Changing the shipment type is not yet supported." ) ; } } }
8911	protected function apply_soft_delete_filter ( ) { if ( $ this -> soft_delete && $ this -> _temporary_with_deleted !== TRUE ) { if ( $ this -> _temporary_only_deleted ) { $ where = "`{$this->deleted_at_key}` <= NOW()" ; } else { $ where = sprintf ( '(%1$s > NOW() OR %1$s IS NULL OR %1$s = \'0000-00-00 00:00:00\')' , $ this -> deleted_at_key ) ; } $ this -> _database -> where ( $ where ) ; } }
11737	public function getDomain ( $ scheme = false ) { if ( $ scheme ) { return sprintf ( '%s.%s' , $ this -> get ( self :: PARSE_SCHEME ) , $ this -> get ( self :: PARSE_HOST ) ) ; } return $ this -> get ( self :: PARSE_HOST ) ; }
9109	public function getResolverObject ( $ state = null , array $ options = array ( ) ) { if ( $ state == null && isset ( $ this -> resolverObject [ 'last_resolver' ] ) ) { return $ this -> resolverObject [ 'last_resolver' ] ; } if ( $ state != 'resolver_adapter_service' && $ state != 'mvclayout_resolver_adapter' ) throw new \ Exception ( 'Invalid state name provided.' ) ; $ config = $ this -> getConfig ( ) ; if ( isset ( $ config [ 'theme_locator' ] ) ) $ config = $ config [ 'theme_locator' ] ; else $ config = array ( ) ; if ( ! isset ( $ config [ $ state ] ) ) throw new \ Exception ( "Theme Resolver Service not present in config[$state]." ) ; $ config = $ config [ $ state ] ; if ( is_string ( $ config ) ) { $ config = array ( "{$config}" => 1 ) ; } if ( isset ( $ this -> resolverObject [ $ state ] ) ) { $ resolver = $ this -> resolverObject [ $ state ] ; $ this -> resolverObject [ 'last_resolver' ] = $ resolver ; return $ resolver ; } else $ resolver = new Resolvers \ Aggregate ( ) ; foreach ( $ config as $ service => $ priority ) { if ( $ this -> getServiceLocator ( ) -> has ( $ service ) ) { $ service = $ this -> getServiceLocator ( ) -> get ( $ service ) ; } else { if ( ! class_exists ( $ service ) ) throw new \ Exception ( "Resolver '$service' not found for yimaTheme as Service either Class." ) ; $ service = new $ service ( ) ; } if ( $ service instanceof Resolvers \ LocatorResolverAwareInterface ) { $ service -> setThemeLocator ( $ this ) ; } if ( $ service instanceof Resolvers \ ConfigResolverAwareInterface ) { $ service -> setConfig ( $ this -> getConfig ( ) ) ; } if ( isset ( $ options [ 'event_mvc' ] ) ) if ( $ service instanceof Resolvers \ MvcResolverAwareInterface ) $ service -> setMvcEvent ( $ options [ 'event_mvc' ] ) ; $ resolver -> attach ( $ service , $ priority ) ; } $ this -> resolverObject [ $ state ] = $ resolver ; $ this -> resolverObject [ 'last_resolver' ] = $ resolver ; return $ resolver ; }
5564	protected function loadFrame ( $ frames , $ url , $ parameters ) { $ page = $ this -> fetch ( $ url , $ parameters ) ; $ this -> page -> setFrame ( $ frames , $ page ) ; return $ page -> getRaw ( ) ; }
12595	protected function getMinifier ( SplFileInfo $ file , string $ source ) : Minifier { $ minifier = '\Gears\Asset\Minifiers\\' ; $ minifier .= ucfirst ( $ this -> destination -> getExtension ( ) ) ; if ( ! class_exists ( $ minifier ) ) { throw new RuntimeException ( 'Minification is not supported for type: ' . $ this -> destination -> getExtension ( ) ) ; } return new $ minifier ( $ file , $ source ) ; }
10568	public function create ( \ Psr \ Http \ Message \ ServerRequestInterface $ request , string $ sortParameter = self :: SORT , array $ defaultSort = [ ] ) : Pagination { $ offset = 0 ; $ max = PHP_INT_MAX ; $ params = $ request -> getQueryParams ( ) ; $ range = $ request -> getHeaderLine ( self :: RANGE ) ; if ( $ range !== null && preg_match ( self :: REGEX_RANGE , $ range , $ rm ) ) { $ offset = ( int ) $ rm [ 1 ] ; $ max = ( int ) $ rm [ 2 ] - $ offset + 1 ; } else { $ max = $ this -> parse ( self :: $ maxAlias , $ params , PHP_INT_MAX ) ; $ offVal = $ this -> parse ( self :: $ offsetAlias , $ params , 0 ) ; if ( $ offVal > 0 ) { $ offset = $ offVal ; } elseif ( isset ( $ params [ self :: START_INDEX ] ) ) { $ startIdx = isset ( $ params [ self :: START_INDEX ] ) ? ( int ) $ params [ self :: START_INDEX ] : 0 ; if ( $ startIdx > 0 ) { $ offset = $ startIdx - 1 ; } } elseif ( isset ( $ params [ self :: START_PAGE ] ) || isset ( $ params [ self :: PAGE ] ) ) { $ startPage = $ this -> parse ( self :: $ pageAlias , $ params , 0 ) ; if ( $ startPage > 0 ) { $ offset = ( $ max * ( $ startPage - 1 ) ) ; } } } return new Pagination ( $ max , $ offset , $ this -> getOrder ( $ request , $ sortParameter , $ defaultSort ) ) ; }
2879	public function enableTemplateHintsAction ( ) { try { $ this -> getService ( ) -> setTemplateHints ( 1 ) ; $ this -> getService ( ) -> flushCache ( ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'Template hints cannot be enabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
11232	public function getLocation ( $ ip = '' , $ baseCurrency = '' , $ renameArrayKeys = false ) { $ params = [ 'ip' => ! $ ip ? $ _SERVER [ 'REMOTE_ADDR' ] : $ ip , 'base_currency' => $ baseCurrency , ] ; $ response = $ this -> client -> get ( 'json.gp' , $ params ) ; $ data = $ this -> handleResponseContent ( $ response , 'json' ) ; if ( $ renameArrayKeys ) { $ tmpData = [ ] ; foreach ( $ data as $ key => $ value ) { $ tmpData [ str_replace ( 'geoplugin_' , '' , $ key ) ] = $ value ; } $ data = $ tmpData ; } return $ data ; }
178	public static function filter ( $ array , $ filters ) { $ result = [ ] ; $ forbiddenVars = [ ] ; foreach ( $ filters as $ var ) { $ keys = explode ( '.' , $ var ) ; $ globalKey = $ keys [ 0 ] ; $ localKey = isset ( $ keys [ 1 ] ) ? $ keys [ 1 ] : null ; if ( $ globalKey [ 0 ] === '!' ) { $ forbiddenVars [ ] = [ substr ( $ globalKey , 1 ) , $ localKey , ] ; continue ; } if ( ! array_key_exists ( $ globalKey , $ array ) ) { continue ; } if ( $ localKey === null ) { $ result [ $ globalKey ] = $ array [ $ globalKey ] ; continue ; } if ( ! isset ( $ array [ $ globalKey ] [ $ localKey ] ) ) { continue ; } if ( ! array_key_exists ( $ globalKey , $ result ) ) { $ result [ $ globalKey ] = [ ] ; } $ result [ $ globalKey ] [ $ localKey ] = $ array [ $ globalKey ] [ $ localKey ] ; } foreach ( $ forbiddenVars as $ var ) { list ( $ globalKey , $ localKey ) = $ var ; if ( array_key_exists ( $ globalKey , $ result ) ) { unset ( $ result [ $ globalKey ] [ $ localKey ] ) ; } } return $ result ; }
2063	public function purgeSearchIndex ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> id ) { return ; } $ objResult = $ this -> Database -> prepare ( "SELECT id FROM tl_search WHERE pid=?" ) -> execute ( $ dc -> id ) ; while ( $ objResult -> next ( ) ) { $ this -> Database -> prepare ( "DELETE FROM tl_search WHERE id=?" ) -> execute ( $ objResult -> id ) ; $ this -> Database -> prepare ( "DELETE FROM tl_search_index WHERE pid=?" ) -> execute ( $ objResult -> id ) ; } }
9760	function containOnly ( string $ type ) : self { return $ this -> expect ( $ this -> target , containsOnly ( $ type ) ) ; }
12173	protected static function addReflectionArguments ( Definition $ factory , ReflectionFunctionAbstract $ reflectionFunction = null ) { if ( ! $ reflectionFunction ) { $ callable = $ factory -> getCallable ( ) ; if ( is_array ( $ callable ) ) { $ reflectionFunction = new ReflectionMethod ( $ callable [ 0 ] , $ callable [ 1 ] ) ; } else { $ reflectionFunction = new ReflectionFunction ( $ callable ) ; } } foreach ( $ reflectionFunction -> getParameters ( ) as $ arg ) { try { $ name = $ arg -> getName ( ) ; $ required = ! $ arg -> isOptional ( ) ; if ( $ argClass = $ arg -> getClass ( ) ) { $ factory -> addClassArgument ( $ name , $ argClass -> getName ( ) , $ required ) ; } else { $ default = ( $ required ? null : $ arg -> getDefaultValue ( ) ) ; $ factory -> addScalarArgument ( $ name , null , $ required , $ default ) ; } } catch ( ReflectionException $ re ) { throw UnresolvableArgumentException :: fromReflectionParam ( $ arg , $ reflectionFunction , $ re ) ; } } }
8282	public function onPageRendering ( & $ templateName , array & $ twigVariables ) { $ twigVariables [ 'auth' ] [ 'plugin' ] = $ this ; $ twigVariables [ 'auth' ] [ 'vars' ] = $ this -> output ; if ( ! $ this -> errorOccurred ) { $ twigVariables [ 'auth' ] [ 'user' ] = $ this -> user ; $ old = $ this -> session -> getFlash ( 'old' ) ; if ( count ( $ old ) && isset ( $ old [ 0 ] ) ) { $ twigVariables [ 'auth' ] [ 'old' ] = $ old [ 0 ] ; } } }
12144	public static function login ( $ rank = 1 , $ id = null ) { static :: provider ( ) -> set ( 'valid' , true ) ; static :: provider ( ) -> set ( 'rank' , $ rank ) ; static :: provider ( ) -> set ( 'id' , $ id ) ; return static :: user ( ) ; }
9115	public function setDefaults ( $ defaultController = 'Index' , $ defaultAction = 'index' ) { $ this -> defaultController = $ defaultController ; $ this -> defaultAction = $ defaultAction ; return $ this ; }
2295	public static function getTinyTemplates ( ) { $ strDir = Config :: get ( 'uploadPath' ) . '/tiny_templates' ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ! is_dir ( $ rootDir . '/' . $ strDir ) ) { return '' ; } $ arrFiles = array ( ) ; $ arrTemplates = scan ( $ rootDir . '/' . $ strDir ) ; foreach ( $ arrTemplates as $ strFile ) { if ( strncmp ( '.' , $ strFile , 1 ) !== 0 && is_file ( $ rootDir . '/' . $ strDir . '/' . $ strFile ) ) { $ arrFiles [ ] = '{ title: "' . $ strFile . '", url: "' . $ strDir . '/' . $ strFile . '" }' ; } } return implode ( ",\n" , $ arrFiles ) . "\n" ; }
5774	public function isDeletable ( ) : bool { if ( is_null ( $ this -> authorization ) ) { throw new \ Exception ( "Authorization must be set" ) ; } $ id = $ this -> getId ( ) ; if ( $ this -> isLoggedIn ( ) ) { $ this -> notDeletableReason = "Administrator cannot delete own account: id $id" ; return false ; } if ( ! $ this -> getAuthorization ( ) -> hasTopRole ( ) && $ this -> hasTopRole ( ) ) { $ this -> notDeletableReason = "Not authorized to delete administrator: id $id" ; return false ; } if ( ( EventsTableMapper :: getInstance ( ) ) -> existForAdministrator ( $ id ) ) { $ this -> notDeletableReason = "Events exist for administrator: id $id" ; return false ; } return true ; }
4482	public function setBacklog ( int $ backlog ) : void { if ( $ this -> client -> call ( 'recur.update' , $ this -> jid , 'backlog' , $ backlog ) ) { $ this -> backlog = $ backlog ; } }
11279	public static function applyDataToView ( $ view , $ data ) { if ( ! empty ( $ data ) ) { foreach ( $ data as $ name => $ value ) { if ( is_string ( $ value ) ) { $ view = str_replace ( '{' . $ name . '}' , $ value , $ view ) ; } } } return $ view ; }
12455	public function hasToolbar ( ) { $ fileSkeleton = '/Resources/views/Editor/Toolbar/_toolbar_%s_buttons.html.twig' ; return file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'left' ) ) || file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'right' ) ) ; }
5277	public function where ( $ column , $ param1 = null , $ param2 = null , $ type = 'and' ) { if ( ! in_array ( $ type , array ( 'and' , 'or' , 'where' ) ) ) { throw new \ Exception ( 'Invalid where type "' . $ type . '"' ) ; } $ sub_type = is_null ( $ param1 ) ? $ type : $ param1 ; if ( empty ( $ this -> statements [ 'wheres' ] ) ) { $ type = 'where' ; } if ( is_array ( $ column ) ) { $ subquery = array ( ) ; foreach ( $ column as $ value ) { if ( ! isset ( $ value [ 2 ] ) ) { $ value [ 2 ] = $ value [ 1 ] ; $ value [ 1 ] = '=' ; } $ subquery [ ] = $ this -> generateWhere ( $ value [ 0 ] , $ value [ 1 ] , $ value [ 2 ] , empty ( $ subquery ) ? '' : $ sub_type ) ; } $ this -> statements [ 'wheres' ] [ ] = $ type . ' ( ' . trim ( join ( ' ' , $ subquery ) ) . ' )' ; return $ this ; } $ this -> statements [ 'wheres' ] [ ] = $ this -> generateWhere ( $ column , $ param1 , $ param2 , $ type ) ; return $ this ; }
1854	public static function findCurrentByPid ( $ intPid , $ intStart , $ intEnd , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ intStart = ( int ) $ intStart ; $ intEnd = ( int ) $ intEnd ; $ arrColumns = array ( "$t.pid=? AND (($t.startTime>=$intStart AND $t.startTime<=$intEnd) OR ($t.endTime>=$intStart AND $t.endTime<=$intEnd) OR ($t.startTime<=$intStart AND $t.endTime>=$intEnd) OR ($t.recurring='1' AND ($t.recurrences=0 OR $t.repeatEnd>=$intStart) AND $t.startTime<=$intEnd))" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.startTime" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
11367	public static function getMimeType ( $ filename = '' ) { $ ext = strtolower ( substr ( $ filename , strrpos ( $ filename , '.' ) ) ) ; switch ( $ ext ) { case '.jpeg' : case '.jpg' : $ mimetype = 'image/jpeg' ; break ; case '.gif' : $ mimetype = 'image/gif' ; break ; case '.png' : $ mimetype = 'image/png' ; break ; case '.txt' : $ mimetype = 'text/plain' ; break ; case '.html' : case '.htm' : $ mimetype = 'text/html' ; break ; case '.zip' : $ mimetype = 'application/x-zip-compressed' ; break ; default : $ mimetype = 'application/octet-stream' ; } return $ mimetype ; }
10312	function getRecipientsCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeDeletedRecipients = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeDeletedRecipients ) ) $ params [ 'exclude_deleted_recipients' ] = ( $ excludeDeletedRecipients == true ) ? "true" : "false" ; return $ this -> get ( 'reports/recipients/count' , $ params ) ; }
10573	protected function registerSessionHandler ( ) { if ( $ this -> handler !== null ) { if ( ! is_object ( $ this -> handler ) ) { $ this -> handler = Yii :: createObject ( $ this -> handler ) ; } if ( ! $ this -> handler instanceof \ SessionHandlerInterface ) { throw new InvalidConfigException ( '"' . get_class ( $ this ) . '::handler" must implement the SessionHandlerInterface.' ) ; } @ session_set_save_handler ( $ this -> handler , false ) ; } elseif ( $ this -> getUseCustomStorage ( ) ) { @ session_set_save_handler ( [ $ this , 'openSession' ] , [ $ this , 'closeSession' ] , [ $ this , 'readSession' ] , [ $ this , 'writeSession' ] , [ $ this , 'destroySession' ] , [ $ this , 'gcSession' ] ) ; } }
1360	public static function custom ( $ mediaType ) : self { if ( ! $ mediaType instanceof MediaTypeInterface ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } return new self ( $ mediaType , null ) ; }
12791	public static function createLayout ( string $ layoutName , View $ view ) : ? Layout { $ layoutsRoot = AppHelper :: getInstance ( ) -> getComponentRoot ( 'layouts' ) ; $ layoutFile = $ layoutsRoot . \ DIRECTORY_SEPARATOR . strtolower ( $ layoutName ) . '.php' ; if ( is_readable ( $ layoutFile ) ) { return new Layout ( $ layoutFile , $ view ) ; } return null ; }
5983	protected function withOAuth2MiddleWare ( HandlerStack $ stack ) { if ( ! ( $ this -> oauth2Middleware instanceof OAuthMiddleware ) ) { $ oauthClient = new Client ( [ 'base_uri' => $ this -> basepath , 'verify' => $ this -> verifyCertificates , 'headers' => [ 'User-Agent' => 'qbank3api-phpwrapper/2 (qbankapi: 1; swagger: 1.1)' , ] , ] ) ; $ config = [ PasswordCredentials :: CONFIG_USERNAME => $ this -> credentials -> getUsername ( ) , PasswordCredentials :: CONFIG_PASSWORD => $ this -> credentials -> getPassword ( ) , PasswordCredentials :: CONFIG_CLIENT_ID => $ this -> credentials -> getClientId ( ) , PasswordCredentials :: CONFIG_TOKEN_URL => 'oauth2/token' , ] ; $ this -> oauth2Middleware = new OAuthMiddleware ( $ oauthClient , new PasswordCredentials ( $ oauthClient , $ config ) , new RefreshToken ( $ oauthClient , $ config ) ) ; $ tokens = $ this -> getTokens ( ) ; if ( ! empty ( $ tokens [ 'accessTokens' ] ) ) { $ this -> oauth2Middleware -> setAccessToken ( $ tokens [ 'accessTokens' ] ) ; } if ( ! empty ( $ tokens [ 'refreshTokens' ] ) ) { $ this -> oauth2Middleware -> setRefreshToken ( $ tokens [ 'refreshTokens' ] ) ; } } $ stack -> push ( $ this -> oauth2Middleware -> onBefore ( ) ) ; $ stack -> push ( $ this -> oauth2Middleware -> onFailure ( 3 ) ) ; return $ stack ; }
10489	public static function unbufferConnection ( Connection $ connection ) { $ wrappedConnection = $ connection -> getWrappedConnection ( ) ; if ( ! $ wrappedConnection instanceof PDOConnection ) { throw new InvalidArgumentException ( 'unbufferConection can only be used with pdo_mysql Doctrine driver.' ) ; } if ( $ wrappedConnection -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) != 'mysql' ) { throw new InvalidArgumentException ( 'unbufferConection can only be used with PDO mysql driver, got "' . $ wrappedConnection -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) . '" instead.' ) ; } if ( $ connection -> isConnected ( ) ) { $ connection -> close ( ) ; } $ connection -> getWrappedConnection ( ) -> setAttribute ( PDO :: MYSQL_ATTR_USE_BUFFERED_QUERY , false ) ; $ connection -> connect ( ) ; }
5921	public function getProperty ( $ systemName ) { foreach ( $ this -> propertySets as $ propertySet ) { foreach ( $ propertySet -> getProperties ( ) as $ property ) { if ( $ property -> getPropertyType ( ) -> getSystemName ( ) == $ systemName ) { return $ property ; } } } throw new PropertyNotFoundException ( 'No Property with the system name "' . $ systemName . '" exists.' ) ; }
5670	protected function describeGenericDifference ( $ first , $ second ) { return sprintf ( 'as [%s] does not match [%s]' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) ) ; }
2163	public function run40Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `scripts` text NULL" ) ; $ objLayout = $ this -> Database -> query ( "SELECT id, addJQuery, jquery, addMooTools, mootools FROM tl_layout WHERE framework!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrScripts = array ( ) ; if ( $ objLayout -> addJQuery ) { $ jquery = StringUtil :: deserialize ( $ objLayout -> jquery ) ; if ( ! empty ( $ jquery ) && \ is_array ( $ jquery ) ) { if ( ( $ key = array_search ( 'j_slider' , $ jquery ) ) !== false ) { $ arrScripts [ ] = 'js_slider' ; unset ( $ jquery [ $ key ] ) ; $ this -> Database -> prepare ( "UPDATE tl_layout SET jquery=? WHERE id=?" ) -> execute ( serialize ( array_values ( $ jquery ) ) , $ objLayout -> id ) ; } } } if ( $ objLayout -> addMooTools ) { $ mootools = StringUtil :: deserialize ( $ objLayout -> mootools ) ; if ( ! empty ( $ mootools ) && \ is_array ( $ mootools ) ) { if ( ( $ key = array_search ( 'moo_slider' , $ mootools ) ) !== false ) { $ arrScripts [ ] = 'js_slider' ; unset ( $ mootools [ $ key ] ) ; $ this -> Database -> prepare ( "UPDATE tl_layout SET mootools=? WHERE id=?" ) -> execute ( serialize ( array_values ( $ mootools ) ) , $ objLayout -> id ) ; } } } if ( ! empty ( $ arrScripts ) ) { $ this -> Database -> prepare ( "UPDATE tl_layout SET scripts=? WHERE id=?" ) -> execute ( serialize ( array_values ( array_unique ( $ arrScripts ) ) ) , $ objLayout -> id ) ; } } }
7040	protected function hasDifferentCurrencies ( PaymentSubjectInterface $ subject ) { $ currency = $ subject -> getCurrency ( ) -> getCode ( ) ; foreach ( $ subject -> getPayments ( ) as $ payment ) { if ( $ payment -> getCurrency ( ) -> getCode ( ) !== $ currency ) { return true ; } } return false ; }
0	public static function supports ( IOInterface $ io , Config $ config , $ url , $ deep = false ) { if ( ! preg_match ( self :: URL_REGEX , $ url , $ match ) ) { return false ; } $ scheme = ! empty ( $ match [ 'scheme' ] ) ? $ match [ 'scheme' ] : null ; $ guessedDomain = ! empty ( $ match [ 'domain' ] ) ? $ match [ 'domain' ] : $ match [ 'domain2' ] ; $ urlParts = explode ( '/' , $ match [ 'parts' ] ) ; if ( false === self :: determineOrigin ( ( array ) $ config -> get ( 'gitlab-domains' ) , $ guessedDomain , $ urlParts ) ) { return false ; } if ( 'https' === $ scheme && ! extension_loaded ( 'openssl' ) ) { $ io -> writeError ( 'Skipping GitLab driver for ' . $ url . ' because the OpenSSL PHP extension is missing.' , true , IOInterface :: VERBOSE ) ; return false ; } return true ; }
3825	protected function compile ( ) { $ objItemRenderer = new ItemList ( ) ; $ this -> Template -> searchable = ! $ this -> metamodel_donotindex ; $ sorting = $ this -> metamodel_sortby ; $ direction = $ this -> metamodel_sortby_direction ; if ( $ this -> metamodel_sort_override ) { if ( \ Input :: get ( 'orderBy' ) ) { $ sorting = \ Input :: get ( 'orderBy' ) ; } if ( \ Input :: get ( 'orderDir' ) ) { $ direction = \ Input :: get ( 'orderDir' ) ; } } $ objItemRenderer -> setServiceContainerFallback ( function ( ) { return $ this -> getServiceContainer ( ) ; } ) -> setFactory ( System :: getContainer ( ) -> get ( 'metamodels.factory' ) ) -> setFilterFactory ( System :: getContainer ( ) -> get ( 'metamodels.filter_setting_factory' ) ) -> setRenderSettingFactory ( System :: getContainer ( ) -> get ( 'metamodels.render_setting_factory' ) ) -> setEventDispatcher ( System :: getContainer ( ) -> get ( 'event_dispatcher' ) ) -> setMetaModel ( $ this -> metamodel , $ this -> metamodel_rendersettings ) -> setLimit ( $ this -> metamodel_use_limit , $ this -> metamodel_offset , $ this -> metamodel_limit ) -> setPageBreak ( $ this -> perPage ) -> setSorting ( $ sorting , $ direction ) -> setFilterSettings ( $ this -> metamodel_filtering ) -> setFilterParameters ( StringUtil :: deserialize ( $ this -> metamodel_filterparams , true ) , $ this -> getFilterParameters ( $ objItemRenderer ) ) -> setMetaTags ( $ this -> metamodel_meta_title , $ this -> metamodel_meta_description ) ; $ this -> Template -> items = \ StringUtil :: encodeEmail ( $ objItemRenderer -> render ( $ this -> metamodel_noparsing , $ this ) ) ; $ this -> Template -> numberOfItems = $ objItemRenderer -> getItems ( ) -> getCount ( ) ; $ this -> Template -> pagination = $ objItemRenderer -> getPagination ( ) ; }
10712	public function create ( array $ attributes = [ ] ) { $ model = $ this -> newModel ( ) ; $ model -> fill ( $ attributes ) ; $ this -> save ( $ model ) ; return $ model ; }
6667	public function prepareResponse ( ) { if ( ! $ this -> writer ) { $ this -> writer = $ this -> writerFactory -> getWriterFor ( $ this -> request -> getFormats ( ) ) ; } $ this -> preparedResponse = $ this -> writer -> format ( $ this -> getBody ( ) , $ this -> responseName ) ; return $ this ; }
7200	protected function detachSaleItemRecursively ( SaleItemInterface $ item ) { $ this -> stockAssigner -> detachSaleItem ( $ item ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> detachSaleItemRecursively ( $ child ) ; } }
4848	public function destinationsFor ( string $ filePath ) : array { $ filePath = Path :: canonicalize ( $ filePath ) ; $ source = $ this -> matchingSource ( $ filePath ) ; return $ this -> resolveDestinations ( $ filePath , $ source ) ; }
5683	public function getUrls ( ) { $ all = array ( ) ; foreach ( $ this -> links as $ link ) { $ url = $ this -> getUrlFromLink ( $ link ) ; $ all [ ] = $ url -> asString ( ) ; } return $ all ; }
3922	private function resizeImage ( $ fileName ) { list ( $ width , $ height , $ mode ) = $ this -> getResizeImages ( ) ; if ( $ this -> getShowImages ( ) && ( $ width || $ height || $ mode ) ) { if ( $ this -> imageFactory ) { $ image = $ this -> imageFactory -> create ( $ this -> rootDir . '/' . $ fileName , [ $ width , $ height , $ mode ] ) ; return $ image -> getUrl ( $ this -> rootDir ) ; } $ event = new ResizeImageEvent ( $ fileName , $ width , $ height , $ mode ) ; $ this -> dispatcher -> dispatch ( ContaoEvents :: IMAGE_RESIZE , $ event ) ; return $ event -> getResultImage ( ) ; } return $ fileName ; }
2155	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objNewsletter = NewsletterChannelModel :: findAll ( ) ; if ( $ objNewsletter !== null ) { while ( $ objNewsletter -> next ( ) ) { if ( ! $ objNewsletter -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objNewsletter -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objNewsletter -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objNewsletter -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objNewsletter -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objNewsletter -> jumpTo ] ; $ objItem = NewsletterModel :: findSentByPid ( $ objNewsletter -> id ) ; if ( $ objItem !== null ) { while ( $ objItem -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItem -> alias ? : $ objItem -> id ) ) ; } } } } return $ arrPages ; }
1086	private function parseDocument ( ) { $ start = $ this -> lexer -> token ; $ this -> expect ( Token :: SOF ) ; $ definitions = [ ] ; do { $ definitions [ ] = $ this -> parseDefinition ( ) ; } while ( ! $ this -> skip ( Token :: EOF ) ) ; return new DocumentNode ( [ 'definitions' => new NodeList ( $ definitions ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; }
11854	public function getHeader ( string $ name ) : ? string { $ name = strtolower ( $ name ) ; foreach ( $ this -> getAllHeaders ( ) as $ key => $ value ) { if ( strtolower ( $ key ) === $ name ) { return $ value ; } } return null ; }
11419	protected function getValues ( $ fields , $ preCalculatedResult = false ) { if ( $ preCalculatedResult ) { return $ preCalculatedResult ; } $ app = App :: getInstance ( ) ; $ sql = $ this -> constructSelectSQL ( $ fields ) ; $ item = $ this -> getCache ( $ fields [ $ this -> pk ] ) ; $ results = $ item -> get ( \ Stash \ Invalidation :: PRECOMPUTE , 300 ) ; if ( $ item -> isMiss ( ) ) { $ results = $ this -> runGetRow ( $ sql ) ; if ( $ app [ 'db' ] -> last_error ) { throw new SQLException ( $ app [ 'db' ] -> last_error , $ app [ 'db' ] -> captured_errors ) ; } if ( is_null ( $ results ) ) { throw new ModelNotFoundException ( 'No model in database' , $ this -> dbtable , $ this -> constructorId ) ; } $ app [ 'cache' ] -> save ( $ item -> set ( $ results ) ) ; } return $ results ; }
3696	protected function extractIdFrom ( EnvironmentInterface $ environment , $ parameterName = 'pid' ) { $ parameter = $ environment -> getInputProvider ( ) -> getParameter ( $ parameterName ) ; return ModelId :: fromSerialized ( $ parameter ) -> getId ( ) ; }
6789	protected function assertShipmentPlatform ( ShipmentInterface $ shipment ) { if ( $ shipment -> getPlatformName ( ) !== $ this -> getName ( ) ) { throw new InvalidArgumentException ( sprintf ( "Platform %s does not support shipment %s." , $ this -> getName ( ) , $ shipment -> getNumber ( ) ) ) ; } }
10606	public function addHeader ( string $ header , $ value ) : void { if ( is_iterable ( $ value ) || is_array ( $ value ) ) { $ iterable = $ value ; $ value = [ ] ; foreach ( $ iterable as $ key => $ entry ) { $ value [ $ key ] = ( string ) $ entry ; } } else { $ value = ( string ) $ value ; } $ this -> headers [ ] = [ $ header , $ value ] ; }
4892	protected function getGenerator ( ) { if ( isset ( $ this -> generator ) ) { return $ this -> generator ; } if ( $ this -> entity instanceof SnapshotGeneratorProviderInterface ) { $ serviceLocator = $ this -> getServicelocator ( ) ; $ className = get_class ( $ this -> entity ) ; if ( $ serviceLocator -> has ( 'snapshotgenerator' . $ className ) ) { $ generator = $ this -> serviceLocator -> get ( 'snapshotgenerator' . $ className ) ; if ( is_array ( $ generator ) ) { $ this -> options = ArrayUtils :: merge ( $ generator , $ this -> options ) ; $ generator = null ; } } if ( ! isset ( $ generator ) ) { $ generator = $ this -> entity -> getSnapshotGenerator ( ) ; if ( is_array ( $ generator ) ) { $ this -> options = ArrayUtils :: merge ( $ generator , $ this -> options ) ; if ( array_key_exists ( 'generator' , $ generator ) ) { $ generator = $ this -> options [ 'generator' ] ; unset ( $ this -> options [ 'generator' ] ) ; } else { $ generator = null ; } } if ( is_string ( $ generator ) ) { $ generator = $ serviceLocator -> get ( $ generator ) ; } } if ( ! isset ( $ generator ) ) { $ generator = new SnapshotGenerator ( ) ; } if ( array_key_exists ( 'hydrator' , $ this -> options ) ) { $ hydrator = $ this -> options [ 'hydrator' ] ; if ( is_string ( $ hydrator ) && ! empty ( $ hydrator ) ) { $ hydrator = $ serviceLocator -> get ( 'HydratorManager' ) -> get ( $ hydrator ) ; } $ generator -> setHydrator ( $ hydrator ) ; } if ( array_key_exists ( 'exclude' , $ this -> options ) ) { $ hydrator = $ generator -> getHydrator ( ) ; $ exclude = $ this -> options [ 'exclude' ] ; if ( is_array ( $ exclude ) ) { $ hydrator -> setExcludeMethods ( $ exclude ) ; } } $ generator -> setSource ( $ this -> entity ) ; $ this -> generator = $ generator ; } return $ this -> generator ; }
7267	public function has ( $ forClass , $ forColumn = null ) { $ refTable = static :: tableName ( ) ; $ forTable = $ forClass :: tableName ( ) ; $ refColumn = static :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( static :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select F.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and R.$refColumn = :id " , [ "id" => $ this -> $ refColumn ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ forModel = new $ forClass ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ forModel -> $ col = $ forModel -> decodeValue ( $ val , $ col ) ; return $ forModel ; }
487	public function dropCommentFromTable ( $ table ) { $ time = $ this -> beginCommand ( "drop comment from table $table" ) ; $ this -> db -> createCommand ( ) -> dropCommentFromTable ( $ table ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
6377	public function toArray ( ) : array { $ res = [ ] ; Iterators :: each ( $ this -> iterator ( ) , function ( $ element ) use ( & $ res ) { $ res [ ] = $ element ; } ) ; return $ res ; }
6507	public function deserializeReturnValue ( $ type , $ data ) { $ jobType = $ this -> registry -> get ( $ type ) ; return $ this -> serializer -> deserialize ( $ data , $ jobType -> getReturnType ( ) , 'json' , $ this -> getResponseDeserializationContext ( $ jobType ) ) ; }
12160	public function getDetailsWidget ( $ objectModel = null ) { if ( is_null ( $ objectModel ) && isset ( Yii :: $ app -> request -> object ) ) { $ objectModel = Yii :: $ app -> request -> object ; } elseif ( is_null ( $ objectModel ) ) { $ objectModel = $ this -> dummyModel ; } $ detailsSection = $ this -> getDetailsSection ( ) ; if ( $ detailsSection === false ) { return false ; } if ( $ detailsSection === true ) { $ detailsSection = '_self' ; } $ detailsWidgetClass = self :: classNamespace ( ) . '\widgets\\' . 'Details' ; $ widgetClass = $ this -> fallbackDetailsWidgetClass ; @ class_exists ( $ detailsWidgetClass ) ; if ( class_exists ( $ detailsWidgetClass , false ) ) { $ widgetClass = $ detailsWidgetClass ; } $ widget = [ 'class' => $ widgetClass ] ; $ widget [ 'owner' ] = $ this ; $ widgetItem = [ 'widget' => $ widget , 'locations' => [ 'self' ] , 'priority' => 1 ] ; $ widgetItem [ 'section' ] = Yii :: $ app -> collectors [ 'sections' ] -> getOne ( $ detailsSection ) ; return $ widgetItem ; }
11276	public function getMessage ( ) { $ response = [ ] ; if ( $ messages = $ this -> data -> query ( '/Message/Body/Errors' ) -> array ( ) ) { foreach ( $ messages as $ message ) { $ response [ ] = $ message -> textContent ; } } return count ( $ response ) ? implode ( ', ' , $ response ) : null ; }
5052	public function getContentType ( ) { if ( ! $ this -> contentType ) { $ this -> setContentType ( $ this -> getParam ( 'contentType' ) ? : static :: TYPE_JSON ) ; } return $ this -> contentType ; }
4592	public function submit ( $ id , array $ variables ) { foreach ( $ variables as $ variable ) { if ( ! $ variable instanceof Variable ) { throw new InvalidArgumentException ( 'Array of variables is not valid.' ) ; } } $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_SUBMIT ) ; $ options = [ 'headers' => [ 'Accept' => 'application/json' , 'Content-Type' => 'application/json' ] ] ; foreach ( $ variables as $ variable ) { $ options [ 'json' ] [ 'variables' ] [ $ variable -> getName ( ) ] = [ 'value' => Variable :: TYPE_JSON === $ variable -> getType ( ) ? json_encode ( $ variable -> getValue ( ) ) : $ variable -> getValue ( ) , 'type' => $ variable -> getType ( ) ] ; } $ this -> execute ( 'POST' , $ resource , $ options ) ; }
4115	public function getRemoteCallUrlTemplate ( ) { if ( is_null ( $ this -> remoteCallUrlTemplate ) ) { $ this -> remoteCallUrlTemplate = Mage :: getStoreConfig ( 'dev/aoe_templatehints/remoteCallUrlTemplate' ) ; } return $ this -> remoteCallUrlTemplate ; }
12862	public function parseBehaviour ( \ stdClass $ block , $ search ) { if ( ! isset ( $ block -> behaviour ) ) { return false ; } $ behaviours = array ( ) ; foreach ( explode ( ' ' , trim ( $ block -> behaviour ) ) as $ b ) { if ( strstr ( $ b , ':' ) ) { list ( $ name , $ prop ) = explode ( ':' , $ b , 2 ) ; $ behaviours [ $ name ] = $ prop ; } else { $ behaviours [ $ b ] = true ; } } return isset ( $ behaviours [ $ search ] ) ? $ behaviours [ $ search ] : false ; }
7256	public function user ( $ key = null ) { if ( $ this -> sessionKey && $ this -> request -> session ( ) -> check ( $ this -> sessionKey ) ) { $ user = $ this -> request -> session ( ) -> read ( $ this -> sessionKey ) ; } else { return null ; } if ( $ key === null ) { return $ user ; } return Hash :: get ( $ user , $ key ) ; }
8128	public static function findByPasswordResetToken ( $ id , $ code ) { if ( ! static :: isPasswordResetTokenValid ( $ code ) ) { return NULL ; } return static :: findOne ( [ 'id' => $ id , 'password_reset_token' => $ code , 'status' => self :: STATUS_ACTIVE , ] ) ; }
4627	protected function prepareRequestData ( ) { if ( in_array ( $ this -> command -> getMethod ( ) , [ 'POST' , 'PUT' ] ) ) { $ this -> requestBody = $ this -> command -> getEncodedData ( ) ; $ this -> options [ CURLOPT_POSTFIELDS ] = $ this -> requestBody ; } return $ this ; }
8037	public static function revert ( $ input , $ inputFormat = Code :: FORMAT_ALNUM , $ minLength = null ) { $ number = self :: convertBase ( $ input , $ inputFormat , Code :: FORMAT_NUMBER ) ; if ( is_int ( $ minLength ) ) { $ number -= self :: getMinForlength ( $ inputFormat , $ minLength ) ; } return $ number ; }
2761	public function getLogLevelMapping ( string $ eventName ) : string { if ( ! isset ( $ this -> logLevelMappings [ $ eventName ] ) ) { throw new GitException ( sprintf ( 'Unknown event "%s"' , $ eventName ) ) ; } return $ this -> logLevelMappings [ $ eventName ] ; }
7522	function parse_style ( ) { if ( $ this -> parse_attributes ( ) && ( $ this -> token === self :: TOK_TAG_CLOSE ) && ( $ start = $ this -> pos ) && ( $ this -> next_pos ( '</style>' , false ) === self :: TOK_UNKNOWN ) ) { $ len = $ this -> pos - 1 - $ start ; $ this -> status [ 'text' ] = ( ( $ len > 0 ) ? substr ( $ this -> doc , $ start + 1 , $ len ) : '' ) ; $ this -> pos += 7 ; $ this -> status [ 'last_pos' ] = $ this -> pos ; return true ; } else { $ this -> addError ( 'No end for style tag found' ) ; return false ; } }
12976	public function parseMappingInfo ( ) { $ mappings = array ( ) ; foreach ( $ this -> getMappings ( ) as $ mappingName => $ mappingConfig ) { if ( is_array ( $ mappingConfig ) === false or \ Arr :: get ( $ mappingConfig , 'mapping' , true ) === false ) { continue ; } $ mappingConfig = array_replace ( array ( 'dir' => false , 'type' => false , 'prefix' => false , ) , $ mappingConfig ) ; if ( isset ( $ mappingConfig [ 'is_component' ] ) === false ) { $ mappingConfig [ 'is_component' ] = false ; if ( is_dir ( $ mappingConfig [ 'dir' ] ) === false ) { $ mappingConfig [ 'is_component' ] = ( \ Package :: loaded ( $ mappingName ) or \ Module :: loaded ( $ mappingName ) ) ; } } if ( $ mappingConfig [ 'is_component' ] ) { $ mappingConfig = $ this -> getComponentDefaults ( $ mappingName , $ mappingConfig ) ; } if ( empty ( $ mappingConfig ) ) { continue ; } $ mappings [ $ mappingName ] = $ mappingConfig ; } $ this -> config [ 'mappings' ] = $ mappings ; }
105	public function watch2OnHighest ( Decisions $ decisions ) { $ literals = $ this -> rule -> getLiterals ( ) ; if ( count ( $ literals ) < 3 ) { return ; } $ watchLevel = 0 ; foreach ( $ literals as $ literal ) { $ level = $ decisions -> decisionLevel ( $ literal ) ; if ( $ level > $ watchLevel ) { $ this -> watch2 = $ literal ; $ watchLevel = $ level ; } } }
9225	private function preprocessData ( $ data ) { if ( is_array ( $ data ) && ! array_key_exists ( self :: PARAM_PER_PAGE , $ data ) ) { $ data [ self :: PARAM_PER_PAGE ] = CanvasArray :: MAXIMUM_PER_PAGE ; } return $ data ; }
4080	protected function isInputScreenStandalone ( $ metaModel ) { $ information = $ this -> information [ $ metaModel ] ; $ inputScreen = isset ( $ information [ self :: INPUTSCREEN ] ) ? $ information [ self :: INPUTSCREEN ] : null ; if ( ! is_object ( $ inputScreen ) ) { return ( $ inputScreen [ 'row' ] [ 'rendertype' ] == 'standalone' ) ; } return $ inputScreen -> isStandalone ( ) ; }
2885	public function saveProfiling ( ) { if ( ! $ this -> canCollect ( ) || ! Mage :: helper ( 'sheep_debug' ) -> canPersist ( ) ) { return ; } if ( Mage :: helper ( 'sheep_debug' ) -> hasDisablePersistenceCookie ( ) ) { return ; } if ( ! $ this -> getRequestInfo ( ) -> getIsStarted ( ) ) { return ; } $ this -> getRequestInfo ( ) -> save ( ) ; }
11599	public function run ( ) : void { if ( ! $ this -> isAppRootSet ( ) ) { throw new Exception ( "The application root wasn't defined." ) ; } if ( ! $ this -> isConfigFileSet ( ) ) { throw new Exception ( "The main config file wasn't defined." ) ; } $ configPath = $ this -> getAppRoot ( ) . $ this -> getConfigFile ( ) ; if ( ! is_readable ( $ configPath ) ) { throw new Exception ( "It's unable to load " . $ configPath . 'as main config file.' ) ; } $ config = require_once $ configPath ; if ( ! is_array ( $ config ) ) { throw new Exception ( 'The main config must be an array.' ) ; } $ this -> configSet = $ config ; }
806	private function findReturnAnnotations ( Tokens $ tokens , $ index ) { do { $ index = $ tokens -> getPrevNonWhitespace ( $ index ) ; } while ( $ tokens [ $ index ] -> isGivenKind ( [ T_ABSTRACT , T_FINAL , T_PRIVATE , T_PROTECTED , T_PUBLIC , T_STATIC , ] ) ) ; if ( ! $ tokens [ $ index ] -> isGivenKind ( T_DOC_COMMENT ) ) { return [ ] ; } $ doc = new DocBlock ( $ tokens [ $ index ] -> getContent ( ) ) ; return $ doc -> getAnnotationsOfType ( 'return' ) ; }
7708	function ReplaceSrc ( $ new ) { $ len = $ this -> GetLen ( ) ; $ this -> Txt = substr_replace ( $ this -> Txt , $ new , $ this -> PosBeg , $ len ) ; $ diff = strlen ( $ new ) - $ len ; $ this -> PosEnd += $ diff ; $ this -> pST_Src = false ; if ( $ new === '' ) { $ this -> pST_PosBeg = false ; $ this -> pST_PosEnd = false ; $ this -> pET_PosBeg = false ; } else { $ this -> pST_PosEnd += $ diff ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ diff ; } }
6698	public function compareTo ( $ version ) { $ major = $ version -> getMajor ( ) ; $ minor = $ version -> getMinor ( ) ; $ patch = $ version -> getPatch ( ) ; $ pre = $ version -> getPreRelease ( ) ; $ build = $ version -> getBuild ( ) ; switch ( true ) { case ( $ this -> major < $ major ) : return 1 ; case ( $ this -> major > $ major ) : return - 1 ; case ( $ this -> minor > $ minor ) : return - 1 ; case ( $ this -> minor < $ minor ) : return 1 ; case ( $ this -> patch > $ patch ) : return - 1 ; case ( $ this -> patch < $ patch ) : return 1 ; } if ( $ pre || $ this -> pre ) { if ( empty ( $ this -> pre ) && $ pre ) { return - 1 ; } if ( $ this -> pre && empty ( $ pre ) ) { return 1 ; } if ( 0 !== ( $ weight = $ this -> precedence ( $ this -> pre , $ pre ) ) ) { return $ weight ; } } if ( $ build || $ this -> build ) { if ( ( null === $ this -> build ) && $ build ) { return 1 ; } if ( $ this -> build && ( null === $ build ) ) { return - 1 ; } return $ this -> precedence ( $ this -> build , $ build ) ; } return 0 ; }
5667	public function getType ( $ value ) { if ( ! isset ( $ value ) ) { return 'Null' ; } elseif ( is_bool ( $ value ) ) { return 'Boolean' ; } elseif ( is_string ( $ value ) ) { return 'String' ; } elseif ( is_integer ( $ value ) ) { return 'Integer' ; } elseif ( is_float ( $ value ) ) { return 'Float' ; } elseif ( is_array ( $ value ) ) { return 'Array' ; } elseif ( is_resource ( $ value ) ) { return 'Resource' ; } elseif ( is_object ( $ value ) ) { return 'Object' ; } return 'Unknown' ; }
10240	public function calculateCellValue ( Cell $ pCell = null , $ resetLog = true ) { if ( $ pCell === null ) { return null ; } $ returnArrayAsType = self :: $ returnArrayAsType ; if ( $ resetLog ) { $ this -> formulaError = null ; $ this -> debugLog -> clearLog ( ) ; $ this -> cyclicReferenceStack -> clear ( ) ; $ this -> cyclicFormulaCounter = 1 ; self :: $ returnArrayAsType = self :: RETURN_ARRAY_AS_ARRAY ; } $ this -> cellStack [ ] = [ 'sheet' => $ pCell -> getWorksheet ( ) -> getTitle ( ) , 'cell' => $ pCell -> getCoordinate ( ) , ] ; try { $ result = self :: unwrapResult ( $ this -> _calculateFormulaValue ( $ pCell -> getValue ( ) , $ pCell -> getCoordinate ( ) , $ pCell ) ) ; $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; } catch ( \ Exception $ e ) { $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; throw new Exception ( $ e -> getMessage ( ) ) ; } if ( ( is_array ( $ result ) ) && ( self :: $ returnArrayAsType != self :: RETURN_ARRAY_AS_ARRAY ) ) { self :: $ returnArrayAsType = $ returnArrayAsType ; $ testResult = Functions :: flattenArray ( $ result ) ; if ( self :: $ returnArrayAsType == self :: RETURN_ARRAY_AS_ERROR ) { return Functions :: VALUE ( ) ; } if ( count ( $ testResult ) != 1 ) { $ r = array_keys ( $ result ) ; $ r = array_shift ( $ r ) ; if ( ! is_numeric ( $ r ) ) { return Functions :: VALUE ( ) ; } if ( is_array ( $ result [ $ r ] ) ) { $ c = array_keys ( $ result [ $ r ] ) ; $ c = array_shift ( $ c ) ; if ( ! is_numeric ( $ c ) ) { return Functions :: VALUE ( ) ; } } } $ result = array_shift ( $ testResult ) ; } self :: $ returnArrayAsType = $ returnArrayAsType ; if ( $ result === null ) { return 0 ; } elseif ( ( is_float ( $ result ) ) && ( ( is_nan ( $ result ) ) || ( is_infinite ( $ result ) ) ) ) { return Functions :: NAN ( ) ; } return $ result ; }
8237	protected function configGenerationAction ( ParameterBag $ post ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> addOutput ( "installer_step" , 1 ) ; return ; } $ this -> picoAuth -> addOutput ( "installer_step" , 2 ) ; $ this -> outputModulesConfiguration ( $ post ) ; }
2263	public function listTables ( $ strDatabase = null , $ blnNoCache = false ) { if ( $ blnNoCache || ! isset ( $ this -> arrCache [ $ strDatabase ] ) ) { $ strOldDatabase = $ this -> resConnection -> getDatabase ( ) ; if ( $ strDatabase !== null && $ strDatabase != $ strOldDatabase ) { $ this -> setDatabase ( $ strDatabase ) ; } $ this -> arrCache [ $ strDatabase ] = $ this -> resConnection -> getSchemaManager ( ) -> listTableNames ( ) ; if ( $ strDatabase !== null && $ strDatabase != $ strOldDatabase ) { $ this -> setDatabase ( $ strOldDatabase ) ; } } return $ this -> arrCache [ $ strDatabase ] ; }
7648	public function stream_close ( ) { @ fclose ( $ this -> temporaryFileHandle ) ; if ( $ this -> writeMode ) { $ containerExists = $ this -> getStorageClient ( $ this -> fileName ) -> containerExists ( $ this -> getContainerName ( $ this -> fileName ) ) ; if ( ! $ containerExists ) { $ this -> getStorageClient ( $ this -> fileName ) -> createContainer ( $ this -> getContainerName ( $ this -> fileName ) ) ; } try { $ this -> getStorageClient ( $ this -> fileName ) -> putBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } catch ( BlobException $ ex ) { @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; throw $ ex ; } } @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; }
11839	public static function convert2Jpeg ( $ inputImg , $ savePath = null , $ quality = null , array $ exifData = null ) { $ retval = false ; $ img = self :: imgCreate ( $ inputImg ) ; $ imgSize = self :: size ( $ img ) ; $ jpegImg = imagecreatetruecolor ( $ imgSize [ 0 ] , $ imgSize [ 1 ] ) ; imagecopy ( $ jpegImg , $ img , 0 , 0 , 0 , 0 , $ imgSize [ 0 ] , $ imgSize [ 1 ] ) ; if ( null === $ quality ) $ quality = self :: IMG_QUALITY ; if ( null !== $ exifData && array_key_exists ( 'Orientation' , $ exifData ) ) { $ ort = $ exifData [ 'Orientation' ] ; switch ( $ ort ) { default : case 1 : break ; case 2 : $ jpegImg = self :: flipImage ( $ jpegImg , 1 ) ; break ; case 3 : $ jpegImg = self :: rotateImage ( $ jpegImg , 180 ) ; break ; case 4 : $ jpegImg = self :: flipImage ( $ jpegImg , 2 ) ; break ; case 5 : $ jpegImg = self :: flipImage ( $ jpegImg , 2 ) ; $ jpegImg = self :: rotateImage ( $ jpegImg , 90 ) ; break ; case 6 : $ jpegImg = self :: rotateImage ( $ jpegImg , 90 ) ; break ; case 7 : $ jpegImg = self :: flipImage ( $ jpegImg , 1 ) ; $ jpegImg = self :: rotateImage ( $ jpegImg , 90 ) ; break ; case 8 : $ jpegImg = self :: rotateImage ( $ jpegImg , 270 ) ; break ; } } if ( null === $ savePath ) $ retval = $ jpegImg ; else $ retval = imagejpeg ( $ jpegImg , $ savePath , $ quality ) ; return $ retval ; }
10912	public function convertDateTimeToUtcTimeZone ( $ inStrictIso8601DtTm ) { $ tmpDateTimeIn = $ this -> convertTimeFromFormatSafely ( $ inStrictIso8601DtTm ) ; $ tmpDateTimeIn -> setTimezone ( new \ DateTimeZone ( 'UTC' ) ) ; return $ tmpDateTimeIn -> format ( 'Y-m-d H:i:s' ) ; }
12367	protected function getOption ( $ name ) { if ( ! isset ( $ this -> options [ $ name ] ) ) { throw new ValueNotFoundException ( $ name ) ; } return $ this -> options [ $ name ] ; }
2748	private function extractMapping ( $ mapping , $ countryCode ) { $ final = null ; $ extractMapping = json_decode ( $ mapping , true ) ; if ( ! $ extractMapping ) { try { $ extractMapping = unserialize ( $ mapping ) ; } catch ( \ Exception $ e ) { $ extractMapping = [ ] ; } } if ( is_array ( $ extractMapping ) ) { $ countryId = 'country_id' ; $ key = 'store_id' ; foreach ( $ extractMapping as $ map ) { if ( is_array ( $ map ) && isset ( $ map [ $ countryId ] ) && strtolower ( str_replace ( ' ' , '' , $ map [ $ countryId ] ) ) == strtolower ( $ countryCode ) ) { if ( isset ( $ map [ $ key ] ) ) { return ( int ) $ map [ $ key ] ; } } elseif ( is_array ( $ map ) && isset ( $ map [ $ countryId ] ) && $ map [ $ countryId ] == '*' && isset ( $ map [ $ key ] ) && $ final === null ) { $ final = ( int ) $ map [ $ key ] ; } } } return $ final ; }
6083	public function uploadFile ( $ pathname , $ name , $ categoryId , $ progress = null , $ chunkSize = 10485760 ) { $ chunk = 0 ; $ chunksTotal = ceil ( filesize ( $ pathname ) / $ chunkSize ) ; $ fileId = sha1 ( uniqid ( 'upload' , true ) ) ; $ fp = fopen ( $ pathname , 'rb' ) ; if ( false === $ fp ) { throw new UploadException ( 'Could not open file "' . $ pathname . '" for reading.' ) ; } if ( $ chunkSize > 10485760 ) { $ this -> logger -> warning ( 'Using a chunk size larger then 10MB is not recommended. Uploading is not guaranteed to work properly.' ) ; } while ( $ chunkData = fread ( $ fp , $ chunkSize ) ) { $ result = $ this -> uploadFileChunked ( $ chunkData , $ name , $ chunk , $ chunksTotal , $ fileId , $ categoryId ) ; if ( is_callable ( $ progress ) ) { try { call_user_func ( $ progress , $ chunk + 1 , $ chunksTotal ) ; } catch ( \ Exception $ e ) { $ this -> logger -> warning ( 'Could not report progress due to callback error.' , [ 'message' => $ e -> getMessage ( ) ] ) ; } } $ this -> logger -> info ( 'Upload progress!' , [ 'part' => $ chunk + 1 , 'total' => $ chunksTotal ] ) ; if ( isset ( $ result [ 'mediaId' ] ) ) { return new MediaResponse ( $ result ) ; } if ( isset ( $ result [ 'success' ] ) && false == $ result [ 'success' ] ) { throw new UploadException ( $ result [ 'error' ] [ 'message' ] , $ result [ 'error' ] [ 'code' ] ) ; } if ( isset ( $ result [ 'fileId' ] ) ) { $ fileId = $ result [ 'fileId' ] ; } ++ $ chunk ; } if ( $ chunk == $ chunksTotal - 1 ) { throw new UploadException ( 'Uploaded all chunks, but something went wrong.' ) ; } if ( false === $ chunkData ) { throw new UploadException ( 'Could not read chunk ' . $ chunk . ' from file "' . $ pathname . '".' ) ; } throw new UploadException ( 'Unknown upload error!' ) ; }
5860	public function getAllFileTypes ( ) { $ fileTypes = [ ] ; foreach ( $ this -> rulesets as $ ruleset ) { if ( is_array ( $ ruleset [ 'file_types' ] ) ) { $ fileTypes = array_merge ( $ fileTypes , $ ruleset [ 'file_types' ] ) ; } } $ fileTypes = array_unique ( $ fileTypes ) ; return $ fileTypes ; }
9766	function instanceOf ( string $ className ) : self { return $ this -> expect ( $ this -> target , isInstanceOf ( $ className ) ) ; }
5744	public static function getDatabaseColumnValidationValue ( ColumnMapper $ databaseColumnMapper , string $ validationType ) { foreach ( self :: getDatabaseColumnValidation ( $ databaseColumnMapper ) as $ validation ) { if ( ! is_array ( $ validation ) && $ validation == $ validationType ) { return true ; } elseif ( is_array ( $ validation ) && $ validation [ 0 ] == $ validationType ) { return $ validation [ 1 ] ; } } return false ; }
822	private function fixSemicolonAfterCurlyBraceClose ( Tokens $ tokens , $ index , $ curlyCloseIndex ) { static $ beforeCurlyOpeningKinds = null ; if ( null === $ beforeCurlyOpeningKinds ) { $ beforeCurlyOpeningKinds = [ T_ELSE , T_FINALLY , T_NAMESPACE , T_OPEN_TAG ] ; } $ curlyOpeningIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ curlyCloseIndex ) ; $ beforeCurlyOpening = $ tokens -> getPrevMeaningfulToken ( $ curlyOpeningIndex ) ; if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( $ beforeCurlyOpeningKinds ) || $ tokens [ $ beforeCurlyOpening ] -> equalsAny ( [ ';' , '{' , '}' ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( T_STRING ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ beforeCurlyOpening ) ; while ( $ tokens [ $ classyTest ] -> equals ( ',' ) || $ tokens [ $ classyTest ] -> isGivenKind ( [ T_STRING , T_NS_SEPARATOR , T_EXTENDS , T_IMPLEMENTS ] ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ classyTest ) ; } $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; if ( $ tokens [ $ classyTest ] -> isGivenKind ( T_NAMESPACE ) || ( $ tokens [ $ classyTest ] -> isClassy ( ) && ! $ tokensAnalyzer -> isAnonymousClass ( $ classyTest ) ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } return ; } if ( ! $ tokens [ $ beforeCurlyOpening ] -> equals ( ')' ) ) { return ; } $ openingBrace = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ beforeCurlyOpening ) ; $ beforeOpeningBrace = $ tokens -> getPrevMeaningfulToken ( $ openingBrace ) ; if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( [ T_IF , T_ELSEIF , T_FOR , T_FOREACH , T_WHILE , T_SWITCH , T_CATCH , T_DECLARE ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( T_STRING ) ) { $ beforeString = $ tokens -> getPrevMeaningfulToken ( $ beforeOpeningBrace ) ; if ( $ tokens [ $ beforeString ] -> isGivenKind ( T_FUNCTION ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } } }
3277	public function getKeys ( ) : array { $ keys = [ ] ; $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; foreach ( $ file as $ line ) { $ keys [ ] = $ line -> getKey ( ) ; } return $ keys ; }
2596	public static function decodeProcessingLevel ( $ level ) { $ decoded = null ; $ map = [ 0 => 'system' , 1 => 'application' ] ; if ( array_key_exists ( $ level , $ map ) ) { $ decoded = $ map [ $ level ] ; } return $ decoded ; }
6475	public function readAsFormInput ( ? IHttpBody $ body ) : IDictionary { if ( $ body === null ) { return new HashTable ( ) ; } $ parsedFormInputCacheKey = spl_object_hash ( $ body ) ; if ( isset ( $ this -> parsedFormInputCache [ $ parsedFormInputCacheKey ] ) ) { return $ this -> parsedFormInputCache [ $ parsedFormInputCacheKey ] ; } $ formInputArray = [ ] ; parse_str ( $ body -> readAsString ( ) , $ formInputArray ) ; $ kvps = [ ] ; foreach ( $ formInputArray as $ key => $ value ) { $ kvps [ ] = new KeyValuePair ( $ key , $ value ) ; } $ formInputs = new HashTable ( $ kvps ) ; $ this -> parsedFormInputCache [ $ parsedFormInputCacheKey ] = $ formInputs ; return $ formInputs ; }
102	public function findFile ( $ class ) { if ( isset ( $ this -> classMap [ $ class ] ) ) { return $ this -> classMap [ $ class ] ; } if ( $ this -> classMapAuthoritative || isset ( $ this -> missingClasses [ $ class ] ) ) { return false ; } if ( null !== $ this -> apcuPrefix ) { $ file = apcu_fetch ( $ this -> apcuPrefix . $ class , $ hit ) ; if ( $ hit ) { return $ file ; } } $ file = $ this -> findFileWithExtension ( $ class , '.php' ) ; if ( false === $ file && defined ( 'HHVM_VERSION' ) ) { $ file = $ this -> findFileWithExtension ( $ class , '.hh' ) ; } if ( null !== $ this -> apcuPrefix ) { apcu_add ( $ this -> apcuPrefix . $ class , $ file ) ; } if ( false === $ file ) { $ this -> missingClasses [ $ class ] = true ; } return $ file ; }
5194	public function addRoutes ( RouteCollector $ routeCollector ) : void { foreach ( $ this -> routes as $ index => $ route ) { $ routeCollector -> addRoute ( $ route -> getMethods ( ) , $ route -> getPath ( ) , $ index ) ; } }
4293	public function getAbstraction ( & $ mixed , $ method = null , $ hist = array ( ) ) { if ( \ is_array ( $ mixed ) ) { return $ this -> abstractArray -> getAbstraction ( $ mixed , $ method , $ hist ) ; } elseif ( \ is_object ( $ mixed ) ) { return $ this -> abstractObject -> getAbstraction ( $ mixed , $ method , $ hist ) ; } elseif ( \ is_resource ( $ mixed ) || \ strpos ( \ print_r ( $ mixed , true ) , 'Resource' ) === 0 ) { return array ( 'debug' => self :: ABSTRACTION , 'type' => 'resource' , 'value' => \ print_r ( $ mixed , true ) . ': ' . \ get_resource_type ( $ mixed ) , ) ; } }
2159	public function run210Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_style` ADD `positioning` char(1) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE `tl_style` SET `positioning`=`size`" ) ; $ this -> Database -> query ( "UPDATE `tl_module` SET `guests`=1 WHERE `type`='lostPassword' OR `type`='registration'" ) ; $ this -> Database -> query ( "UPDATE `tl_news` SET `teaser`=CONCAT('<p>', teaser, '</p>') WHERE `teaser`!='' AND `teaser` NOT LIKE '<p>%'" ) ; }
855	public function insertAt ( $ index , $ items ) { $ items = \ is_array ( $ items ) || $ items instanceof self ? $ items : [ $ items ] ; $ itemsCnt = \ count ( $ items ) ; if ( 0 === $ itemsCnt ) { return ; } $ oldSize = \ count ( $ this ) ; $ this -> changed = true ; $ this -> blockEndCache = [ ] ; $ this -> setSize ( $ oldSize + $ itemsCnt ) ; for ( $ i = $ oldSize + $ itemsCnt - 1 ; $ i >= $ index ; -- $ i ) { $ oldItem = parent :: offsetExists ( $ i - $ itemsCnt ) ? parent :: offsetGet ( $ i - $ itemsCnt ) : new Token ( '' ) ; parent :: offsetSet ( $ i , $ oldItem ) ; } for ( $ i = 0 ; $ i < $ itemsCnt ; ++ $ i ) { if ( '' === $ items [ $ i ] -> getContent ( ) ) { throw new \ InvalidArgumentException ( 'Must not add empty token to collection.' ) ; } $ this -> registerFoundToken ( $ items [ $ i ] ) ; parent :: offsetSet ( $ i + $ index , $ items [ $ i ] ) ; } }
5893	public function listAudioTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/audio' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new AudioTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5487	public function submitImage ( SelectorInterface $ selector , $ x , $ y , $ additional = false ) { $ additional = $ additional ? $ additional : array ( ) ; foreach ( $ this -> images as $ image ) { if ( $ selector -> isMatch ( $ image ) ) { $ encoding = $ this -> encode ( ) ; $ image -> write ( $ encoding , $ x , $ y ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; } } return false ; }
12957	public function authenticate ( ) { $ identity = $ this -> getIdentity ( ) ; $ results = $ this -> model -> findByIdentity ( $ identity ) ; $ identityObject = null ; $ count = 0 ; foreach ( $ results as $ identityObject ) { if ( $ count > 1 ) { return new Result ( Result :: FAILURE_IDENTITY_AMBIGUOUS , $ identity , [ 'More than one record matches the supplied identity.' ] ) ; } $ count ++ ; } if ( $ count == 0 ) { return new Result ( Result :: FAILURE_IDENTITY_NOT_FOUND , $ identity , [ 'A record with the supplied identity could not be found.' ] ) ; } if ( $ identityObject instanceof ObjectInterface ) { if ( $ identityObject -> validateCredential ( $ this -> getCredential ( ) ) ) { return new Result ( Result :: SUCCESS , $ identity ) ; } return new Result ( Result :: FAILURE_CREDENTIAL_INVALID , $ identity , [ 'wrong password' ] ) ; } return new Result ( Result :: FAILURE_UNCATEGORIZED , $ identity , [ 'generic error' ] ) ; }
9752	public function set_posts_to_review ( ) { $ total_posts = wp_count_posts ( ) ; $ total_posts = isset ( $ total_posts -> publish ) ? $ total_posts -> publish : 0 ; $ posts = get_posts ( [ 'post_type' => 'post' , 'numberposts' => $ total_posts , 'post_status' => 'publish' , ] ) ; foreach ( $ posts as $ post ) { if ( isset ( $ post -> ID ) ) { add_post_meta ( $ post -> ID , 'custom_images_grifus' , 'false' , true ) ; } } }
10062	public function update ( $ key , $ value ) { try { $ meta = $ this -> metaModel :: where ( 'key' , $ key ) -> firstOrFail ( ) ; } catch ( \ Exception $ e ) { $ message = "Can't update meta (key: $key). " ; $ message .= "Meta doesn't exist" ; throw new \ Exception ( $ message ) ; } $ meta -> value = $ value ; $ meta -> save ( ) ; }
3182	public function getMinimumRemainingTime ( ) { if ( ( $ timeLimits = $ this -> getSource ( ) -> getTimeLimits ( ) ) !== null && ( $ minTime = $ timeLimits -> getMinTime ( ) ) !== null ) { return $ this -> getRemainingTimeFrom ( $ minTime ) ; } return false ; }
11328	public function setFormField ( $ value ) { if ( is_array ( $ value ) ) { if ( is_null ( $ this -> formFieldClass ) ) { throw new Exception ( "DB Field incorrectly set up. What is the form class?" ) ; } if ( is_null ( $ this -> _formField ) ) { $ config = $ value ; $ config [ 'class' ] = $ this -> formFieldClass ; $ config [ 'modelField' ] = $ this ; $ value = Yii :: createObject ( $ config ) ; } else { $ settings = $ value ; $ value = $ this -> _formField ; unset ( $ settings [ 'class' ] ) ; Yii :: configure ( $ value , $ settings ) ; } } $ this -> _formField = $ value ; return true ; }
12554	public function createTable ( ) { $ stmt = $ this -> pdoConnection -> prepare ( sprintf ( self :: $ CREATE_TABLE , $ this -> tableName ) ) ; return $ stmt -> execute ( ) ; }
8593	public function listOrders ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceOrders_Model_ListOrdersRequest ) ) { $ request = new MarketplaceWebServiceOrders_Model_ListOrdersRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListOrders' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceOrders_Model_ListOrdersResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7462	public function getContent ( string $ name , array $ data = [ ] ) : string { $ cacheName = $ name ; if ( '' == $ name ) { $ this -> isRouteView = true ; $ stack = debug_backtrace ( ) ; foreach ( $ stack as $ item ) { if ( false !== stripos ( $ item [ 'file' ] , DIRECTORY_SEPARATOR . 'Route' . DIRECTORY_SEPARATOR ) ) { $ cacheName = pathinfo ( $ item [ 'file' ] , PATHINFO_DIRNAME ) . '/' . $ name ; $ cacheName = explode ( 'Route' . DIRECTORY_SEPARATOR , $ cacheName ) [ 1 ] ; $ cacheName = 'route_' . str_replace ( [ '/' , '\\' ] , '_' , $ cacheName ) ; break ; } } } $ cacheName .= '_' . $ this -> language . '.html.php' ; $ path = $ this -> packageRoot . '/view/_cache/' . str_replace ( '/' , '_' , $ cacheName ) ; $ exist = file_exists ( $ path ) ; if ( ! $ this -> cache || ! $ exist ) { $ code = $ this -> compile ( $ name . '/view.html.php' , true , true , true ) ; $ code = preg_replace ( [ '/\>[^\S ]+/s' , '/[^\S ]+\</s' , '/(\s)+/s' ] , [ '>' , '<' , '\\1' ] , $ code ) ; if ( $ exist ) { $ fh = fopen ( $ path , 'r+b' ) ; } else { $ fh = fopen ( $ path , 'wb' ) ; } if ( flock ( $ fh , LOCK_EX ) ) { ftruncate ( $ fh , 0 ) ; fwrite ( $ fh , $ code ) ; flock ( $ fh , LOCK_UN ) ; } fclose ( $ fh ) ; } $ fh = fopen ( $ path , 'rb' ) ; if ( flock ( $ fh , LOCK_SH ) ) { $ html = self :: renderTemplate ( $ path , $ data ) ; flock ( $ fh , LOCK_UN ) ; fclose ( $ fh ) ; return $ html ; } throw new \ RuntimeException ( 'Can\'t render template' ) ; }
10524	protected function _unsetData ( $ key ) { $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerUnset ( $ store , $ key ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ key ) ; } }
9391	public function getSortValAfterAll ( $ groupingId = null ) { if ( ! $ groupingId === null && $ this -> grpColumn ) { throw new SortableException ( 'groupingId may be omitted only when grpColumn is not configured.' ) ; } $ query = ( new Query ( ) ) -> select ( $ this -> srtColumn ) -> from ( $ this -> targetTable ) -> where ( [ 'and' , $ this -> grpColumn ? [ '=' , $ this -> grpColumn , $ groupingId ] : [ ] , $ this -> skipRowsClause ( ) ] ) -> orderBy ( $ this -> srtColumn . ' DESC' ) -> limit ( 1 ) ; $ result = $ query -> one ( $ this -> db ) ; if ( $ result ) { $ result = array_values ( $ result ) ; $ sortVal = $ result [ 0 ] + $ this -> sortGap ; } else $ sortVal = $ this -> getIniSortVal ( ) ; return ( int ) $ sortVal ; }
5133	public static function create ( string $ string = '' ) : \ One \ Uri { if ( empty ( $ string ) ) { $ string = '/' ; } return self :: createFromString ( $ string ) ; }
1422	protected function createModelIdentity ( $ modelClass , $ id , $ keyName = null ) { if ( is_null ( $ id ) ) { return null ; } $ model = new $ modelClass ( ) ; if ( ! $ model instanceof Model ) { throw new RuntimeException ( sprintf ( 'Expecting a model class, got %s.' , $ modelClass ) ) ; } $ model -> setAttribute ( $ keyName ? : $ model -> getRouteKeyName ( ) , $ id ) ; return $ model ; }
5549	public function getBaseUrl ( ) { if ( is_integer ( $ this -> focus ) ) { $ url = $ this -> frames [ $ this -> focus ] -> getBaseUrl ( ) ; } else { $ url = $ this -> frameset -> getBaseUrl ( ) ; } return $ url ; }
12282	private function stopCustomProcess ( ) : void { if ( $ this -> isCustomProcessSet ( ) ) { $ this -> getCustomProcess ( ) -> stop ( ) ; } elseif ( class_exists ( '\extensions\core\Process' ) ) { \ extensions \ core \ Process :: getInstance ( ) -> stop ( ) ; } }
6292	private function findThemeByDirectory ( $ directory ) { if ( isset ( $ this -> themes [ $ directory ] ) ) { return $ this -> themes [ $ directory ] ; } return null ; }
1482	public function encoder ( $ options = 0 , $ depth = 512 ) { if ( $ options instanceof Encoding ) { $ options = $ options -> getOptions ( ) ; } if ( ! $ options instanceof EncoderOptions ) { $ options = new EncoderOptions ( $ options , $ this -> getUrl ( ) -> toString ( ) , $ depth ) ; } return $ this -> factory -> createEncoder ( $ this -> getContainer ( ) , $ options ) ; }
5333	public function setSignature ( $ parameters , $ privateKey , $ service , $ endpoint , $ timestamp , $ nonce ) { $ this -> __setCookie ( 'signature' , rawurlencode ( $ this -> sign ( $ privateKey , array_merge ( $ parameters , [ '__service' => $ service , '__hostname' => $ endpoint , '__timestamp' => $ timestamp , '__nonce' => $ nonce , ] ) ) ) ) ; }
3005	static public function ping ( \ Base $ f3 , $ params ) { $ hash = $ params [ 'hash' ] ; if ( $ f3 -> exists ( 'mailer.on.ping' , $ ping_handler ) ) $ f3 -> call ( $ ping_handler , array ( $ hash ) ) ; $ img = new \ Image ( ) ; $ img -> load ( base64_decode ( 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMA' . 'AAAl21bKAAAABGdBTUEAALGPC/xhBQAAAANQTFRFAAAAp3o92gAAAAF0U' . 'k5TAEDm2GYAAAAKSURBVAjXY2AAAAACAAHiIbwzAAAAAElFTkSuQmCC' ) ) ; $ img -> render ( ) ; }
6623	public function parseResponse ( Response $ response ) { $ json = $ response -> json ( ) ; if ( ! is_null ( $ json ) ) { if ( isset ( $ json -> error ) ) { $ error = $ json -> error ; throw new AccessTokenException ( $ error -> type . ': ' . $ error -> message , $ error -> code ) ; } } $ token = $ response -> content ( ) ; return $ this -> parseToken ( $ token ) ; }
2356	public function hasBackendUser ( ) : bool { $ token = $ this -> getToken ( BackendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof BackendUser ; }
12902	private function addVirtualizationWorker ( $ arguments = array ( ) ) { $ this -> builder -> addWorker ( new VirtualizationWorker ( $ this -> registry , $ this -> virtualProperties , $ this -> deserialization , $ arguments ) ) ; }
1037	private function completeObjectValue ( ObjectType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ isTypeOf = $ returnType -> isTypeOf ( $ result , $ this -> exeContext -> contextValue , $ info ) ; if ( $ isTypeOf !== null ) { $ promise = $ this -> getPromise ( $ isTypeOf ) ; if ( $ promise ) { return $ promise -> then ( function ( $ isTypeOfResult ) use ( $ returnType , $ fieldNodes , $ path , & $ result ) { if ( ! $ isTypeOfResult ) { throw $ this -> invalidReturnTypeError ( $ returnType , $ result , $ fieldNodes ) ; } return $ this -> collectAndExecuteSubfields ( $ returnType , $ fieldNodes , $ path , $ result ) ; } ) ; } if ( ! $ isTypeOf ) { throw $ this -> invalidReturnTypeError ( $ returnType , $ result , $ fieldNodes ) ; } } return $ this -> collectAndExecuteSubfields ( $ returnType , $ fieldNodes , $ path , $ result ) ; }
711	public function smallInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_SMALLINT , $ length ) ; }
7293	public function save_transit_posts ( $ new_status , $ old_status , $ post ) { $ this -> transit_posts [ $ post -> ID ] = array ( 'old_status' => $ old_status , 'new_status' => $ new_status ) ; }
2659	public function createRequest ( $ version , $ request ) { $ checkIfExists = $ this -> getRequest ( $ version , $ request [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/request_settings' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ request [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ request ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create the REQUEST object.' ) ) ; } }
12852	protected static function symbol ( $ symbol ) { if ( $ symbol instanceof Symbol ) return [ $ symbol -> symbol , $ symbol -> package ] ; throw new \ UnexpectedValueException ( sprintf ( "Unexpected value of type '%s'." , is_object ( $ symbol ) ? get_class ( $ symbol ) : gettype ( $ symbol ) ) ) ; }
8316	public function startPasswordResetSession ( $ user ) { $ this -> session -> migrate ( true ) ; $ this -> session -> set ( "pwreset" , array ( 'user' => $ user , 'validity' => time ( ) + $ this -> config [ "resetTimeout" ] ) ) ; }
7735	private function documentRouteAndOperations ( $ metadata , Reflector $ element ) { if ( ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Id' ) ) ) || ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Route' ) ) ) ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; } $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Operations' ) ; if ( null !== $ annotation ) { $ operations = array_unique ( $ annotation -> operations ) ; $ operationsMetadata = array_map ( array ( $ this , 'getRouteMetadata' ) , $ operations ) ; $ metadata -> setOperations ( $ operationsMetadata ) ; } if ( null !== ( $ route = $ metadata -> getRoute ( ) ) ) { $ metadata -> addOperation ( $ this -> getRouteMetadata ( $ route -> getName ( ) ) ) ; } elseif ( null !== $ annotation ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( reset ( $ annotation -> operations ) ) ) ; } if ( ( $ metadata instanceof PropertyDefinition ) && ( count ( $ operations = $ metadata -> getOperations ( ) ) > 0 ) ) { foreach ( $ operations as $ operation ) { if ( ( 'GET' === $ operation -> getMethod ( ) ) && ( null !== $ operation -> getReturns ( ) ) ) { $ metadata -> setType ( $ operation -> getReturns ( ) ) ; return ; } } $ metadata -> setType ( 'ML\HydraBundle\Entity\Resource' ) ; } }
1769	public function __isset ( $ strKey ) { switch ( $ strKey ) { case 'id' : return isset ( $ this -> strId ) ; break ; case 'name' : return isset ( $ this -> strName ) ; break ; case 'label' : return isset ( $ this -> strLabel ) ; break ; case 'value' : return isset ( $ this -> varValue ) ; break ; case 'class' : return isset ( $ this -> strClass ) ; break ; case 'template' : return isset ( $ this -> strTemplate ) ; break ; case 'wizard' : return isset ( $ this -> strWizard ) ; break ; case 'required' : return isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; case 'forAttribute' : return isset ( $ this -> blnForAttribute ) ; break ; case 'dataContainer' : return isset ( $ this -> objDca ) ; break ; case 'activeRecord' : return isset ( $ this -> objDca -> activeRecord ) ; break ; default : return isset ( $ this -> arrAttributes [ $ strKey ] ) || isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; } }
5804	public function check ( $ value ) { foreach ( $ this -> _definitions as $ definition ) if ( $ definition -> match ( $ value ) ) return true ; return false ; }
4392	public function checkConfigBE ( array $ attributes ) { return array_merge ( parent :: checkConfigBE ( $ attributes ) , $ this -> checkConfig ( $ this -> beConfig , $ attributes ) ) ; }
7161	private function initialize ( Model \ SaleInterface $ sale , array $ options = [ ] ) { $ this -> lineNumber = 1 ; $ this -> view = new SaleView ( ) ; $ this -> types = $ this -> registry -> getTypesForSale ( $ sale ) ; foreach ( $ this -> types as $ type ) { $ type -> configureOptions ( $ sale , $ this -> view , $ options ) ; } $ this -> options = $ this -> getOptionsResolver ( ) -> resolve ( $ options ) ; $ this -> view -> setTemplate ( $ this -> options [ 'template' ] ) ; if ( ! is_null ( $ this -> options [ 'ati' ] ) ) { $ this -> view -> setAti ( $ this -> options [ 'ati' ] ) ; } else { $ this -> view -> setAti ( $ sale -> isAtiDisplayMode ( ) ) ; } $ this -> formatter = $ this -> formatterFactory -> create ( $ this -> options [ 'locale' ] , $ sale -> getCurrency ( ) -> getCode ( ) ) ; foreach ( $ this -> types as $ type ) { $ type -> setFormatter ( $ this -> formatter ) ; } }
1530	public function resource ( string $ resourceType , array $ options = [ ] ) : ResourceRegistration { return new ResourceRegistration ( $ this -> router , $ resourceType , array_merge ( $ this -> options , $ options ) ) ; }
1508	public static function fromArray ( array $ url ) : self { return new self ( isset ( $ url [ 'host' ] ) ? $ url [ 'host' ] : '' , isset ( $ url [ 'namespace' ] ) ? $ url [ 'namespace' ] : '' , isset ( $ url [ 'name' ] ) ? $ url [ 'name' ] : '' ) ; }
522	protected function createMigration ( $ class ) { $ this -> includeMigrationFile ( $ class ) ; $ migration = Yii :: createObject ( $ class ) ; if ( $ migration instanceof BaseObject && $ migration -> canSetProperty ( 'compact' ) ) { $ migration -> compact = $ this -> compact ; } return $ migration ; }
7912	protected function renderToggleButton ( ) { if ( $ this -> toggleButton !== false ) { $ tag = ArrayHelper :: remove ( $ this -> toggleButton , 'tag' , 'div' ) ; $ label = ArrayHelper :: remove ( $ this -> toggleButton , 'label' , 'Show' ) ; if ( $ tag === 'button' && ! isset ( $ this -> toggleButton [ 'type' ] ) ) { $ this -> toggleButton [ 'type' ] = 'button' ; } if ( $ tag === 'div' ) { Html :: addCssClass ( $ this -> toggleButton , 'ui' ) ; Html :: addCssClass ( $ this -> toggleButton , 'button' ) ; } $ view = $ this -> getView ( ) ; DosAmigosAsset :: register ( $ view ) ; $ view -> registerJs ( 'dosamigos.semantic.init();' ) ; return Html :: tag ( $ tag , $ label , $ this -> toggleButton ) ; } else { return null ; } }
4491	public function registerDeviceOnTopic ( string $ deviceArn , string $ topicArn ) { $ this -> sns -> subscribe ( [ 'TopicArn' => $ topicArn , 'Protocol' => 'application' , 'Endpoint' => $ deviceArn , ] ) ; }
1324	public static function decode ( $ string , $ asArray ) { if ( version_compare ( PHP_VERSION , '5.4.0' , '>=' ) && ! ( defined ( 'JSON_C_VERSION' ) && PHP_INT_SIZE > 4 ) ) { return json_decode ( $ string , $ asArray , 512 , JSON_BIGINT_AS_STRING ) ; } return json_decode ( $ string , $ asArray ) ; }
6123	public function login ( $ username , $ password ) { $ this -> execute ( "login" , array ( "client_login_name" => $ username , "client_login_password" => $ password ) ) ; $ this -> whoamiReset ( ) ; $ crypt = new Crypt ( $ username ) ; $ this -> setStorage ( "_login_user" , $ username ) ; $ this -> setStorage ( "_login_pass" , $ crypt -> encrypt ( $ password ) ) ; Signal :: getInstance ( ) -> emit ( "notifyLogin" , $ this ) ; }
9715	private function writeNumberFormat ( $ format , $ ifmt ) { $ record = 0x041E ; $ numberFormatString = StringHelper :: UTF8toBIFF8UnicodeLong ( $ format ) ; $ length = 2 + strlen ( $ numberFormatString ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ ifmt ) . $ numberFormatString ; $ this -> append ( $ header . $ data ) ; }
149	public function isActive ( $ scenario ) { return ! in_array ( $ scenario , $ this -> except , true ) && ( empty ( $ this -> on ) || in_array ( $ scenario , $ this -> on , true ) ) ; }
7077	static public function getSaleEditableDocumentTypes ( SaleInterface $ sale ) { $ types = [ ] ; foreach ( DocumentTypes :: getTypes ( ) as $ type ) { if ( ! static :: isSaleSupportsDocumentType ( $ sale , $ type ) ) { continue ; } foreach ( $ sale -> getAttachments ( ) as $ attachment ) { if ( $ attachment -> getType ( ) === $ type ) { continue 2 ; } } $ types [ ] = $ type ; } return $ types ; }
2791	public function hasOks ( $ output ) { $ result = preg_match_all ( "%##teamcity\[testFinished%" , $ output ) ; if ( $ result ) { $ this -> okCount += $ result ; return $ this -> okCount ; } return false ; }
8031	public function getProcessDetails ( $ pid ) { if ( $ this -> hasProcess ( $ pid ) === FALSE ) { return NULL ; } return $ this -> processDetails [ $ pid ] ; }
8672	private function iterateFromIndex ( $ fromIndex ) { Assert :: integer ( $ fromIndex ) ; $ count = count ( $ this -> items ) ; if ( $ count === 0 ) { return ; } $ last = $ count - 2 ; $ index = $ fromIndex < 0 ? max ( $ last + $ fromIndex , - 1 ) : min ( $ fromIndex - 1 , $ last ) ; $ keys = array_keys ( $ this -> items ) ; while ( ++ $ index < $ count ) { $ key = $ keys [ $ index ] ; yield $ key => $ this -> items [ $ key ] ; } }
6680	public static function getDateTime ( $ format , $ timestamp = 'now' ) { $ date = strtotime ( $ timestamp ) ; if ( ! $ date ) { return $ timestamp ; } return date ( $ format , $ date ) ; }
5295	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ fontFile = realpath ( $ input -> getArgument ( 'font-file' ) ) ; if ( $ fontFile === false || ! file_exists ( $ fontFile ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'font-file' ) . '" does not exist' ) ; } $ outputDirectory = realpath ( $ input -> getArgument ( 'output-directory' ) ) ; if ( $ outputDirectory === false || ! file_exists ( $ outputDirectory ) || ! is_dir ( $ outputDirectory ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'output-directory' ) . '" is no directory' ) ; } $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading font file from "' . $ fontFile . '" ...' ) ; $ generator -> generateFromFont ( new Font ( array ( ) , file_get_contents ( $ fontFile ) ) ) ; $ output -> writeln ( 'writing SVG files to "' . $ outputDirectory . '" ...' ) ; $ generator -> saveGlyphsToDir ( $ outputDirectory ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created SVG files successfully</success>' ) ; }
2957	public function confCharacterLength ( $ int ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set length of a character : the device " . "is either not set or opened" , E_USER_WARNING ) ; return false ; } $ int = ( int ) $ int ; if ( $ int < 5 ) { $ int = 5 ; } elseif ( $ int > 8 ) { $ int = 8 ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " cs" . $ int , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " cs" . $ int , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " DATA=" . $ int , $ out ) ; } if ( $ ret === 0 ) { return true ; } trigger_error ( "Unable to set character length : " . $ out [ 1 ] , E_USER_WARNING ) ; return false ; }
387	public function setAttributeOrders ( $ attributeOrders , $ validate = true ) { if ( $ attributeOrders === null || ! $ validate ) { $ this -> _attributeOrders = $ attributeOrders ; } else { $ this -> _attributeOrders = [ ] ; foreach ( $ attributeOrders as $ attribute => $ order ) { if ( isset ( $ this -> attributes [ $ attribute ] ) ) { $ this -> _attributeOrders [ $ attribute ] = $ order ; if ( ! $ this -> enableMultiSort ) { break ; } } } } }
9719	private function writeMsoDrawingGroup ( ) { if ( isset ( $ this -> escher ) ) { $ writer = new Escher ( $ this -> escher ) ; $ data = $ writer -> close ( ) ; $ record = 0x00EB ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ this -> writeData ( $ header . $ data ) ; } return '' ; }
6688	public function isPostCheck ( $ redirectUrl = null ) { if ( $ this -> getRequest ( ) -> isPost ) { return true ; } if ( is_null ( $ redirectUrl ) ) { return false ; } $ this -> sendTerminalResponse ( $ redirectUrl ) ; }
9674	public function allConditionalStyles ( Spreadsheet $ spreadsheet ) { $ aStyles = [ ] ; $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { foreach ( $ spreadsheet -> getSheet ( $ i ) -> getConditionalStylesCollection ( ) as $ conditionalStyles ) { foreach ( $ conditionalStyles as $ conditionalStyle ) { $ aStyles [ ] = $ conditionalStyle ; } } } return $ aStyles ; }
6776	protected function updateInformation ( SaleInterface $ sale , $ persistence = false ) { $ changed = false ; if ( null !== $ customer = $ sale -> getCustomer ( ) ) { if ( null === $ sale -> getCustomerGroup ( ) ) { $ sale -> setCustomerGroup ( $ customer -> getCustomerGroup ( ) ) ; $ changed = true ; } if ( 0 == strlen ( $ sale -> getEmail ( ) ) ) { $ sale -> setEmail ( $ customer -> getEmail ( ) ) ; $ changed = true ; } if ( 0 == strlen ( $ sale -> getGender ( ) ) ) { $ sale -> setGender ( $ customer -> getGender ( ) ) ; $ changed = true ; } if ( 0 == strlen ( $ sale -> getFirstName ( ) ) ) { $ sale -> setFirstName ( $ customer -> getFirstName ( ) ) ; $ changed = true ; } if ( 0 == strlen ( $ sale -> getLastName ( ) ) ) { $ sale -> setLastName ( $ customer -> getLastName ( ) ) ; $ changed = true ; } if ( 0 == strlen ( $ sale -> getCompany ( ) ) && 0 < strlen ( $ customer -> getCompany ( ) ) ) { $ sale -> setCompany ( $ customer -> getCompany ( ) ) ; $ changed = true ; } $ changed |= $ this -> updateVatData ( $ sale ) ; if ( null === $ sale -> getInvoiceAddress ( ) && null !== $ address = $ customer -> getDefaultInvoiceAddress ( true ) ) { $ changed |= $ this -> saleUpdater -> updateInvoiceAddressFromAddress ( $ sale , $ address , $ persistence ) ; } if ( $ sale -> isSameAddress ( ) ) { if ( null !== $ address = $ sale -> getDeliveryAddress ( ) ) { $ sale -> setDeliveryAddress ( null ) ; if ( $ persistence ) { $ this -> persistenceHelper -> remove ( $ address , true ) ; } } } else if ( null === $ sale -> getDeliveryAddress ( ) && null !== $ address = $ customer -> getDefaultDeliveryAddress ( ) ) { $ changed |= $ this -> saleUpdater -> updateDeliveryAddressFromAddress ( $ sale , $ address , $ persistence ) ; } } $ changed |= $ this -> updateVatDisplayMode ( $ sale ) ; return $ changed ; }
4383	protected function buildArgString ( $ args ) { $ numArgs = \ count ( $ args ) ; if ( $ numArgs == 1 && \ is_string ( $ args [ 0 ] ) ) { $ args [ 0 ] = \ strip_tags ( $ args [ 0 ] ) ; } foreach ( $ args as $ k => $ v ) { if ( $ k > 0 || ! \ is_string ( $ v ) ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ this -> valDepth = 0 ; } $ glue = ', ' ; $ glueAfterFirst = true ; if ( $ numArgs && \ is_string ( $ args [ 0 ] ) ) { if ( \ preg_match ( '/[=:] ?$/' , $ args [ 0 ] ) ) { $ glueAfterFirst = false ; } elseif ( \ count ( $ args ) == 2 ) { $ glue = ' = ' ; } } if ( ! $ glueAfterFirst ) { return $ args [ 0 ] . \ implode ( $ glue , \ array_slice ( $ args , 1 ) ) ; } else { return \ implode ( $ glue , $ args ) ; } }
2717	public function render ( AbstractElement $ element ) { $ element -> unsScope ( ) -> unsCanUseWebsiteValue ( ) -> unsCanUseDefaultValue ( ) ; return parent :: render ( $ element ) ; }
8824	protected function errorMessage ( $ filter , $ field , $ params = null ) { $ text = ( isset ( $ this -> texts [ $ field ] [ $ filter ] ) && ! is_null ( $ this -> texts [ $ field ] [ $ filter ] ) ? $ this -> texts [ $ field ] [ $ filter ] : $ this -> msg ) ; $ text = str_replace ( [ ':label:' , ':value:' ] , '%s' , $ text ) ; if ( ! isset ( $ this -> data [ $ field ] ) ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } elseif ( ! is_null ( $ params ) ) { if ( $ filter == 'matches' ) { if ( $ this -> matches ( $ this -> data [ $ field ] , $ this -> data [ $ params ] ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } else { if ( $ this -> $ filter ( $ this -> data [ $ field ] , $ params ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } } else { if ( $ this -> $ filter ( $ this -> data [ $ field ] ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } }
2536	protected function getWsdlIdFor ( $ messageName ) { $ msgAndVer = $ this -> getMessagesAndVersions ( ) ; if ( isset ( $ msgAndVer [ $ messageName ] ) && isset ( $ msgAndVer [ $ messageName ] [ 'wsdl' ] ) ) { return $ msgAndVer [ $ messageName ] [ 'wsdl' ] ; } return null ; }
2857	public function viewHandleAction ( ) { $ area = $ this -> getRequest ( ) -> getParam ( 'area' ) ; $ storeId = ( int ) $ this -> getRequest ( ) -> getParam ( 'store' ) ; $ handle = $ this -> getRequest ( ) -> getParam ( 'handle' ) ; $ updatesByFile = $ this -> getService ( ) -> getFileUpdatesWithHandle ( $ handle , $ storeId , $ area ) ; $ databaseUpdates = $ this -> getService ( ) -> getDatabaseUpdatesWithHandle ( $ handle , $ storeId , $ area ) ; $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' , '' , array ( 'template' => 'sheep_debug/view/panel/_layout_updates.phtml' , 'file_updates' => $ updatesByFile , 'db_updates' => $ databaseUpdates ) ) ; $ this -> getResponse ( ) -> setBody ( $ block -> toHtml ( ) ) ; }
12206	public function createPagination ( $ currentPage , $ total , $ perPage = null , $ baseUrl = null , $ neighbours = null ) { if ( isset ( $ this -> container ) && $ this -> container instanceof \ League \ Container \ ContainerInterface ) { return $ this -> getContainer ( ) -> get ( 'Laasti\Pagination\Pagination' , [ $ currentPage , $ total , $ perPage , $ baseUrl , $ neighbours ] ) ; } $ perPage = $ perPage ? : 10 ; $ baseUrl = $ baseUrl ? : '' ; $ neighbours = $ neighbours ? : 3 ; return new Pagination ( $ currentPage , $ total , $ perPage , $ baseUrl , $ neighbours ) ; }
9081	private static function parseParameters ( Request & $ req , $ serverVars ) { self :: parseElement ( $ req , $ serverVars , 'HTTP_ACCEPT' , 'Accept' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_ACCEPT_LANGUAGE' , 'Accept-Language' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_ACCEPT_ENCODING' , 'Accept-Encoding' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_UA_CPU' , 'User-Agent-CPU' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_USER_AGENT' , 'User-Agent' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_HOST' , 'Host' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_CACHE_COTROL' , 'Cache-Control' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_CONNECTION' , 'Connection' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_X_FORWARDED_FOR' , 'X-Forwarded-For' ) ; if ( isset ( $ req -> params [ 'Accept-Language' ] ) ) { $ accepted = explode ( ',' , $ req -> params [ 'Accept-Language' ] ) ; $ req -> params [ 'Accept-Language-Best' ] = $ accepted [ 0 ] ; foreach ( $ accepted as $ acceptedLang ) { $ matches = array ( ) ; if ( preg_match ( "/^((?i)[a-z]{2}[-_](?:[a-z]{2}){1,2}(?:_[a-z]{2})?).*/" , $ acceptedLang , $ matches ) ) { $ req -> params [ 'Accept-Language-Best' ] = $ matches [ 1 ] ; break ; } } } }
11243	public function setDirection ( Neuron_GameServer_Map_Vector3 $ start , Neuron_GameServer_Map_Vector3 $ end ) { $ this -> startRotation = $ start ; $ this -> endRotation = $ end ; }
9211	protected function getFile ( ) { $ file = ( $ this -> params [ 'dev' ] ? $ this -> seedDevFile : $ this -> seedFile ) ; if ( ! empty ( $ this -> params [ 'file' ] ) ) { $ file = $ this -> params [ 'file' ] ; } return $ file ; }
5245	private function replace ( string $ pattern , string $ replacement , string $ targetFile ) { $ this -> filesystem -> put ( $ targetFile , preg_replace ( $ pattern , $ replacement , $ this -> filesystem -> get ( $ targetFile ) ) ) ; }
9041	public function getEnvValue ( array $ expectedEnv , array $ actualEnv ) { $ actualValue = '' ; $ isStarted = false ; foreach ( $ expectedEnv as $ key => $ defaultValue ) { if ( array_key_exists ( $ key , $ actualEnv ) ) { if ( $ this -> option ( 'force' ) ) { $ defaultValue = $ actualEnv [ $ key ] ; } else { $ actualValue .= sprintf ( "%s=%s\n" , $ key , $ actualEnv [ $ key ] ) ; continue ; } } if ( ! $ isStarted ) { $ isStarted = true ; if ( $ this -> option ( 'force' ) ) { $ this -> comment ( 'Update all parameters. Please provide them.' ) ; } else { $ this -> comment ( 'Some parameters are missing. Please provide them.' ) ; } } $ value = $ this -> ask ( $ key , $ defaultValue ) ; $ actualValue .= sprintf ( "%s=%s\n" , $ key , $ value ) ; } return $ actualValue ; }
3649	public static function get ( ? string $ key = null ) { self :: init ( ) ; if ( $ key === null ) { return self :: $ utmCookie ; } else { if ( mb_strpos ( $ key , 'utm_' ) !== 0 ) { $ key = 'utm_' . $ key ; } if ( false === array_key_exists ( $ key , self :: $ utmCookie ) ) { throw new UnexpectedValueException ( sprintf ( 'Argument $key has unexpecte value "%s". Utm value with key "%s" does not exists.' , $ key , $ key ) ) ; } else { return self :: $ utmCookie [ $ key ] ; } } }
4653	public function getJobsToRemove ( $ projectPath , $ keep = 1 ) { $ currentJobs = $ this -> strategy -> getJobs ( $ projectPath ) ; $ existingJobs = $ this -> getJobs ( $ projectPath ) ; $ uniqList = array ( ) ; $ removes = array ( ) ; $ ordered = array ( ) ; foreach ( $ currentJobs as $ job ) { $ uniqList [ ] = $ job -> getUniq ( ) ; } foreach ( $ existingJobs as $ job ) { if ( ! in_array ( $ job -> getUniq ( ) , $ uniqList ) ) { $ removes [ ] = $ job ; } else { $ ordered [ $ job -> getUniq ( ) ] [ $ job -> getCreated ( ) -> format ( 'U' ) ] = $ job ; } } foreach ( $ ordered as $ jobs ) { ksort ( $ jobs ) ; $ keeped = count ( $ jobs ) ; while ( $ keeped > $ keep ) { $ removes [ ] = array_shift ( $ jobs ) ; $ keeped -- ; } } return $ removes ; }
5473	public function isMatch ( $ widget ) { if ( method_exists ( $ widget , 'isLabel' ) ) { if ( $ widget -> isLabel ( $ this -> label ) ) { return true ; } } return ( $ widget -> getName ( ) == $ this -> label ) ; }
9069	public function purge ( $ days_older_than = 60 , \ wpdb $ wpdb ) { $ days_older_than = absint ( $ days_older_than ) ; $ tn = $ this -> table -> get_table_name ( $ wpdb ) ; $ sql = "DELETE FROM {$tn} WHERE time < DATE_SUB(NOW(), INTERVAL $days_older_than DAY)" ; $ wpdb -> query ( $ sql ) ; }
1332	protected function readWithFilters ( $ record , EncodingParametersInterface $ parameters ) { $ query = $ this -> newQuery ( ) -> whereKey ( $ record -> getKey ( ) ) ; $ this -> applyFilters ( $ query , collect ( $ parameters -> getFilteringParameters ( ) ) ) ; return $ query -> exists ( ) ? $ record : null ; }
12398	public function select ( $ select = null ) { $ this -> scope -> select = Parser :: select ( $ select ) ; return $ this ; }
5934	public function setLastLogin ( $ lastLogin ) { if ( $ lastLogin instanceof DateTime ) { $ this -> lastLogin = $ lastLogin ; } else { try { $ this -> lastLogin = new DateTime ( $ lastLogin ) ; } catch ( \ Exception $ e ) { $ this -> lastLogin = null ; } } return $ this ; }
12771	public function authorizeWithEmail ( $ hashedEmail , $ hashedPassword , $ remember = null , & $ user = null ) { $ result = new EmailStatus ( 0 ) ; if ( dbQuery ( $ this -> dbTable ) -> where ( $ this -> dbHashEmailField , $ hashedEmail ) -> first ( $ user ) ) { $ dbTable = $ this -> dbTable ; $ hashPasswordField = $ dbTable :: $ _attributes [ $ this -> dbHashPasswordField ] ; if ( $ user [ $ hashPasswordField ] === $ hashedPassword ) { $ result = new EmailStatus ( EmailStatus :: SUCCESS_EMAIL_AUTHORIZE ) ; $ this -> authorize ( $ user , $ remember ) ; } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_AUTHORIZE_WRONGPWD ) ; } } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_AUTHORIZE_NOTFOUND ) ; } if ( is_callable ( $ this -> authorizeHandler ) ) { if ( ! call_user_func_array ( $ this -> authorizeHandler , array ( & $ user , & $ result ) ) ) { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_AUTHORIZE_HANDLER ) ; } } return $ result ; }
9356	public function withUri ( UriInterface $ uri , $ preserve = false ) { $ static = clone $ this ; $ static -> uri = $ uri ; if ( ! $ preserve && $ host = $ uri -> getHost ( ) ) { $ port = $ host . ':' . $ uri -> getPort ( ) ; $ host = $ uri -> getPort ( ) ? $ port : $ host ; $ static -> headers [ 'Host' ] = ( array ) $ host ; } return $ static ; }
12421	public function dn ( $ domain , $ singular , $ plural , $ number ) { $ singular = ( string ) $ singular ; $ plural = ( string ) $ plural ; $ number = ( int ) $ number ; try { $ locale = $ this -> getLocale ( ) ; foreach ( $ this -> getTranslations ( $ domain ) as $ object ) { if ( ( $ string = $ object -> translatePlural ( $ singular , $ plural , $ number , $ domain , $ locale ) ) != $ singular ) { return $ string ; } } } catch ( \ Exception $ e ) { ; } if ( $ this -> getPluralIndex ( $ number , $ this -> getLocale ( ) ) > 0 ) { return ( string ) $ plural ; } return ( string ) $ singular ; }
4363	public static function toUtf8 ( $ str ) { if ( \ extension_loaded ( 'mbstring' ) && \ function_exists ( 'iconv' ) ) { $ encoding = \ mb_detect_encoding ( $ str , \ mb_detect_order ( ) , true ) ; if ( ! $ encoding ) { $ str_conv = false ; if ( \ function_exists ( 'iconv' ) ) { $ str_conv = \ iconv ( 'cp1252' , 'UTF-8' , $ str ) ; } if ( $ str_conv === false ) { $ str_conv = \ htmlentities ( $ str , ENT_COMPAT ) ; $ str_conv = \ html_entity_decode ( $ str_conv , ENT_COMPAT , 'UTF-8' ) ; } $ str = $ str_conv ; } elseif ( ! \ in_array ( $ encoding , array ( 'ASCII' , 'UTF-8' ) ) ) { $ str_new = \ iconv ( $ encoding , 'UTF-8' , $ str ) ; if ( $ str_new !== false ) { $ str = $ str_new ; } } } return $ str ; }
1585	public function withLinks ( $ links ) : self { $ copy = clone $ this ; $ copy -> links = collect ( $ links ) -> all ( ) ; return $ copy ; }
4972	private function flattenTree ( $ tree , & $ data , $ curId = '1' ) { $ data [ ] = new \ ArrayObject ( [ 'id' => $ tree -> getId ( ) , 'current' => $ curId , 'name' => $ tree -> getName ( ) , 'value' => $ tree -> getValue ( ) , 'priority' => $ tree -> getPriority ( ) , 'do' => 'nothing' , ] ) ; if ( $ tree -> hasChildren ( ) ) { foreach ( $ tree -> getChildren ( ) as $ i => $ child ) { $ this -> flattenTree ( $ child , $ data , $ curId . '-' . ( $ i + 1 ) ) ; } } }
6723	protected function validateAuthParams ( ) { if ( empty ( $ this -> authUrl ) || filter_var ( $ this -> authUrl , FILTER_VALIDATE_URL ) === false ) { throw new Oauth2ClientException ( sprintf ( self :: INVALID_AUTH_URL , $ this -> authUrl ) ) ; } if ( empty ( $ this -> clientId ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_ID ) ; } if ( empty ( $ this -> clientSecret ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_SECRET ) ; } return true ; }
9265	public function setProviders ( ) { $ services = $ this -> container [ 'services' ] ?? null ; if ( is_array ( $ services ) ) { foreach ( $ services as $ service ) { $ service :: register ( $ this -> container ) ; $ service :: boot ( $ this -> container ) ; } } }
3334	private function __initRequest ( $ type , $ data = null ) { $ url = sprintf ( 'https://%s/%s/' , $ this -> host , $ type ) ; if ( is_array ( $ data ) ) { $ url = sprintf ( '%s?%s' , $ url , http_build_query ( $ data ) ) ; } $ ch = curl_init ( $ url ) ; return $ ch ; }
7637	public function getBlobProperties ( $ containerName = '' , $ blobName = '' , $ snapshotId = null , $ leaseId = null ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; return $ this -> getBlobInstance ( $ containerName , $ blobName , $ snapshotId , $ leaseId ) ; }
8248	public function checkPasswordPolicy ( Password $ password ) { $ result = true ; $ policy = $ this -> picoAuth -> getContainer ( ) -> get ( "PasswordPolicy" ) ; $ maxAllowedLen = $ this -> getPasswordEncoder ( ) -> getMaxAllowedLen ( ) ; if ( is_int ( $ maxAllowedLen ) && strlen ( $ password ) > $ maxAllowedLen ) { $ this -> session -> addFlash ( "error" , "Maximum length is {$maxAllowedLen}." ) ; $ result = false ; } if ( ! $ policy -> check ( $ password ) ) { $ errors = $ policy -> getErrors ( ) ; foreach ( $ errors as $ error ) { $ this -> session -> addFlash ( "error" , $ error ) ; } return false ; } return $ result ; }
3154	public function getTraceVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_TraceVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setTrace ( $ variableValue ) ; return $ metaVariable ; }
7272	public static function deleteWhere ( $ condition = "" , array $ conditionParams = [ ] ) { $ tableName = static :: tableName ( ) ; if ( empty ( $ condition ) ) return Db :: query ( "delete from $tableName" , [ ] , static :: getDbName ( ) , false ) ; else return Db :: query ( " delete from $tableName where $condition " , $ conditionParams , static :: getDbName ( ) , false ) ; }
9256	public function set ( $ id , $ service , $ scope = ContainerInterface :: SCOPE_CONTAINER ) { if ( ! $ this -> booted ) { $ this -> boot ( ) ; } $ this -> container -> set ( $ id , $ service , $ scope ) ; }
8708	public function select ( $ columns = [ '*' ] ) { parent :: select ( $ columns ) ; $ this -> columns = $ this -> qualifyColumns ( $ this -> columns ) ; return $ this ; }
2628	protected function getOptions ( $ label = false ) { $ options = [ ] ; foreach ( $ this -> _storeManager -> getStores ( ) as $ store ) { $ options [ ] = [ 'value' => $ store -> getId ( ) , 'label' => $ store -> getName ( ) ] ; } if ( $ label ) { array_unshift ( $ options , [ 'value' => '' , 'label' => $ label ] ) ; } return $ options ; }
12111	private function persist ( ) { $ bootstrap = Bootstrap :: getInstance ( ) ; $ config = $ bootstrap -> getConfiguration ( ) ; $ config [ 'pages' ] = array ( ) ; foreach ( $ this -> pages as $ page ) { $ page -> appendConfig ( $ config [ 'pages' ] ) ; } $ bootstrap -> setConfiguration ( $ config ) ; }
2201	public static function initialize ( ) { $ _GET = static :: cleanKey ( $ _GET ) ; $ _POST = static :: cleanKey ( $ _POST ) ; $ _COOKIE = static :: cleanKey ( $ _COOKIE ) ; }
7038	public function getShipments ( $ filter = null ) { if ( null === $ filter ) { return $ this -> shipments ; } return $ this -> shipments -> filter ( function ( ShipmentInterface $ shipment ) use ( $ filter ) { return $ filter xor $ shipment -> isReturn ( ) ; } ) ; }
9753	public static function sysGetTempDir ( ) { if ( self :: $ useUploadTempDirectory ) { if ( ini_get ( 'upload_tmp_dir' ) !== false ) { if ( $ temp = ini_get ( 'upload_tmp_dir' ) ) { if ( file_exists ( $ temp ) ) { return realpath ( $ temp ) ; } } } } return realpath ( sys_get_temp_dir ( ) ) ; }
5022	protected function copyArrayValues ( array $ source , array $ keys ) { $ target = [ ] ; foreach ( $ keys as $ key => $ spec ) { if ( is_int ( $ key ) ) { $ key = $ spec ; $ spec = null ; } if ( ! array_key_exists ( $ key , $ source ) ) { continue ; } if ( null === $ spec ) { $ target [ $ key ] = $ source [ $ key ] ; continue ; } if ( is_string ( $ spec ) ) { $ target [ $ spec ] [ $ key ] = $ source [ $ key ] ; continue ; } if ( isset ( $ spec [ 'if' ] ) && $ source [ $ key ] !== $ spec [ 'if' ] ) { continue ; } if ( isset ( $ spec [ 'key' ] ) ) { $ targetKeys = is_array ( $ spec [ 'key' ] ) ? $ spec [ 'key' ] : [ $ spec [ 'key' ] ] ; $ value = isset ( $ spec [ 'value' ] ) ? $ spec [ 'value' ] : $ source [ $ key ] ; } else { $ targetKeys = $ spec ; $ value = $ source [ $ key ] ; } $ tmpTarget = & $ target ; foreach ( $ targetKeys as $ targetKey ) { if ( '*' == $ targetKey ) { $ targetKey = $ key ; } if ( ! isset ( $ tmpTarget [ $ targetKey ] ) ) { $ tmpTarget [ $ targetKey ] = [ ] ; } $ tmpTarget = & $ tmpTarget [ $ targetKey ] ; } $ tmpTarget = $ value ; } return $ target ; }
1904	public function execute ( ) { $ arrParams = \ func_get_args ( ) ; if ( ! empty ( $ arrParams ) && \ is_array ( $ arrParams [ 0 ] ) ) { $ arrParams = array_values ( $ arrParams [ 0 ] ) ; } $ this -> replaceWildcards ( $ arrParams ) ; return $ this -> query ( ) ; }
10564	public function variant ( array $ attrs ) { return new self ( $ this -> id , $ attrs , null , $ this -> info -> all ( ) ) ; }
11713	private function getCalcData ( ) { $ req = new AGetPeriodRequest ( ) ; $ req -> setBaseCalcTypeCode ( Cfg :: CODE_TYPE_CALC_PV_WRITE_OFF ) ; $ req -> setDepCalcTypeCode ( Cfg :: CODE_TYPE_CALC_UNQUALIFIED_PROCESS ) ; $ resp = $ this -> servPeriodGet -> exec ( $ req ) ; $ writeOffCalc = $ resp -> getBaseCalcData ( ) ; $ processCalc = $ resp -> getDepCalcData ( ) ; $ result = [ $ writeOffCalc , $ processCalc ] ; return $ result ; }
621	protected function splitCondition ( InCondition $ condition , & $ params ) { $ operator = $ condition -> getOperator ( ) ; $ values = $ condition -> getValues ( ) ; $ column = $ condition -> getColumn ( ) ; if ( $ values instanceof \ Traversable ) { $ values = iterator_to_array ( $ values ) ; } if ( ! is_array ( $ values ) ) { return null ; } $ maxParameters = 1000 ; $ count = count ( $ values ) ; if ( $ count <= $ maxParameters ) { return null ; } $ slices = [ ] ; for ( $ i = 0 ; $ i < $ count ; $ i += $ maxParameters ) { $ slices [ ] = $ this -> queryBuilder -> createConditionFromArray ( [ $ operator , $ column , array_slice ( $ values , $ i , $ maxParameters ) ] ) ; } array_unshift ( $ slices , ( $ operator === 'IN' ) ? 'OR' : 'AND' ) ; return $ this -> queryBuilder -> buildCondition ( $ slices , $ params ) ; }
4258	public function addSubscriberInterface ( SubscriberInterface $ interface ) { $ subscribers = $ this -> getInterfaceSubscribers ( $ interface ) ; foreach ( $ subscribers as $ row ) { $ this -> subscribe ( $ row [ 0 ] , $ row [ 1 ] , $ row [ 2 ] ) ; } return $ subscribers ; }
10668	public static function build ( $ input , array $ options = [ ] ) { if ( ! \ is_array ( $ options ) ) { $ options = [ 'return' => ( string ) $ options ] ; } $ defaults = [ 'return' => 'simplexml' , ] ; $ options = array_merge ( $ defaults , $ options ) ; if ( is_array ( $ input ) || is_object ( $ input ) ) { return self :: fromArray ( ( array ) $ input , $ options ) ; } if ( strpos ( $ input , '<' ) !== false ) { if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ input , LIBXML_NOCDATA ) ; } $ dom = new \ DOMDocument ( ) ; $ dom -> loadXML ( $ input ) ; return $ dom ; } if ( file_exists ( $ input ) || strpos ( $ input , 'http://' ) === 0 || strpos ( $ input , 'https://' ) === 0 ) { if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ input , LIBXML_NOCDATA , true ) ; } $ dom = new \ DOMDocument ( ) ; $ dom -> load ( $ input ) ; return $ dom ; } if ( ! \ is_string ( $ input ) ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid input.' ) ) ; } throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'XML cannot be read.' ) ) ; }
583	public function actionCompress ( $ configFile , $ bundleFile ) { $ this -> loadConfiguration ( $ configFile ) ; $ bundles = $ this -> loadBundles ( $ this -> bundles ) ; $ targets = $ this -> loadTargets ( $ this -> targets , $ bundles ) ; foreach ( $ targets as $ name => $ target ) { $ this -> stdout ( "Creating output bundle '{$name}':\n" ) ; if ( ! empty ( $ target -> js ) ) { $ this -> buildTarget ( $ target , 'js' , $ bundles ) ; } if ( ! empty ( $ target -> css ) ) { $ this -> buildTarget ( $ target , 'css' , $ bundles ) ; } $ this -> stdout ( "\n" ) ; } $ targets = $ this -> adjustDependency ( $ targets , $ bundles ) ; $ this -> saveTargets ( $ targets , $ bundleFile ) ; if ( $ this -> deleteSource ) { $ this -> deletePublishedAssets ( $ bundles ) ; } }
11356	public function getInputFilter ( ) { if ( $ this -> filter ) { return $ this -> filter ; } $ specifications = [ ] ; if ( $ this -> object && $ this -> object instanceof InputFilterProviderInterface ) { $ specifications = $ this -> object -> getInputFilterSpecification ( ) ; } if ( $ this instanceof InputFilterProviderInterface ) { $ specifications = ArrayUtils :: merge ( $ specifications , $ this -> getInputFilterSpecification ( ) ) ; } $ this -> addRequiredAttributeToFields ( $ specifications ) ; if ( ! empty ( $ specifications ) && null === $ this -> baseFieldset ) { $ formFactory = $ this -> getFormFactory ( ) ; $ inputFactory = $ formFactory -> getInputFilterFactory ( ) ; if ( ! ( $ this -> filter instanceof InputFilterInterface ) ) { $ this -> filter = new InputFilter ( ) ; $ this -> filter -> setFactory ( $ inputFactory ) ; } foreach ( $ specifications as $ name => $ specification ) { $ input = $ inputFactory -> createInput ( $ specification ) ; $ this -> filter -> add ( $ input , $ name ) ; } } return parent :: getInputFilter ( ) ; }
853	public function getNonEmptySibling ( $ index , $ direction ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } if ( ! $ this -> isEmptyAt ( $ index ) ) { return $ index ; } } }
6718	protected function setParameter ( $ name , $ value ) { if ( ! is_scalar ( $ name ) ) { throw new \ Exception ( 'Parameter name must be scalar' ) ; } $ this -> parameters [ $ name ] = $ value ; return $ this ; }
4419	protected function checkPermissions ( ) { if ( $ this -> isGranted ( 'ROLE_NGBM_EDITOR' ) ) { return ; } if ( $ this -> isGranted ( 'nglayouts:ui:access' ) ) { return ; } $ exception = $ this -> createAccessDeniedException ( ) ; $ exception -> setAttributes ( 'nglayouts:ui:access' ) ; throw $ exception ; }
4526	protected function createZoneMemberZoneFromDefinition ( array $ definition ) { $ zone = $ this -> get ( $ definition [ 'zone' ] ) ; $ zoneMember = new ZoneMemberZone ( ) ; $ zoneMember -> setZone ( $ zone ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; } , $ zoneMember , '\CommerceGuys\Zone\Model\ZoneMemberZone' ) ; $ setValues ( $ definition ) ; return $ zoneMember ; }
4669	protected function beforeGeneration ( ) { $ this -> config -> getLogger ( ) -> startBreak ( 'XSD Parsing' ) ; $ this -> XSDMap = XSDMapGenerator :: buildXSDMap ( $ this -> config ) ; $ this -> config -> getLogger ( ) -> endBreak ( 'XSD Parsing' ) ; $ this -> config -> getLogger ( ) -> startBreak ( 'Generator Class Initialization' ) ; self :: _initializeClasses ( $ this -> config ) ; $ this -> autoloadMap = new AutoloaderTemplate ( $ this -> config ) ; $ this -> mapTemplate = new ParserMapTemplate ( $ this -> config ) ; $ this -> autoloadMap -> addEntry ( $ this -> mapTemplate -> getClassName ( ) , $ this -> mapTemplate -> getClassPath ( ) ) ; $ helperTemplate = new HelperTemplate ( $ this -> config ) ; $ helperTemplate -> writeToFile ( ) ; $ this -> autoloadMap -> addEntry ( $ helperTemplate -> getClassName ( ) , $ helperTemplate -> getClassPath ( ) ) ; $ this -> config -> getLogger ( ) -> endBreak ( 'Generator Class Initialization' ) ; }
12908	public function update ( FilterRequest $ request , $ id ) { $ this -> fieldManager = $ this -> getFieldManager ( ) ; $ this -> validate ( $ request -> request , $ this -> fieldManager -> update ( ) ) ; $ id = $ this -> getRealId ( $ id ) ; $ resource = $ this -> repository -> update ( $ request -> all ( ) , $ id ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
4955	public function listenToRenderer ( ) { if ( $ this -> ListenersUnaware ) { $ this -> ListenersUnaware = false ; $ view = $ this -> serviceManager -> get ( 'View' ) ; $ viewEvents = $ view -> getEventManager ( ) ; $ viewEvents -> attach ( ViewEvent :: EVENT_RESPONSE , array ( $ this , 'anounceAttachedFiles' ) , 1000 ) ; } }
11993	public function orderBy ( $ key , $ direction = 'asc' ) { return $ this -> sort ( function ( $ a , $ b ) use ( $ key , $ direction ) { $ valueA = is_object ( $ a ) ? $ a -> { $ key } : $ a [ $ key ] ; $ valueB = is_object ( $ b ) ? $ b -> { $ key } : $ b [ $ key ] ; if ( $ valueA == $ valueB ) return 0 ; $ result = ( $ valueA < $ valueB ) ? - 1 : 1 ; return $ direction === 'desc' ? - ( $ result ) : $ result ; } ) ; }
4844	public static function singularize ( $ string ) { if ( substr ( $ string , - 1 ) == 's' ) { return substr ( $ string , 0 , - 1 ) ; } elseif ( substr ( $ string , - 1 ) == 'i' ) { return substr ( $ string , 0 , - 1 ) . 'us' ; } else { return $ string ; } }
9157	final public function call ( $ action , Request $ request , View $ view ) { $ this -> request = $ request ; ob_start ( ) ; $ rf = new \ ReflectionMethod ( $ this , $ action ) ; $ anno = $ rf -> getDocComment ( ) ; $ matches = array ( ) ; if ( preg_match ( '#@responseType ([\w\/]+)#' , $ anno , $ matches ) ) { $ this -> response -> setType ( $ matches [ 1 ] ) ; } if ( preg_match ( '#@title ([^\\n]+)#' , $ anno , $ matches ) ) { $ this -> response -> setTitle ( $ matches [ 1 ] ) ; } $ rf -> invoke ( $ this , $ this -> request ) ; $ this -> response -> appendBody ( ob_get_clean ( ) ) ; $ view -> render ( $ this -> response , $ request , $ this -> viewParams ) ; $ this -> addControls ( $ this -> response , $ request , $ view ) ; return $ this -> response ; }
4300	public function groupEnd ( $ value = \ bdk \ Debug \ Abstracter :: UNDEFINED ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'value' => \ bdk \ Debug \ Abstracter :: UNDEFINED ) ) ; \ extract ( $ args ) ; $ groupStackWas = $ this -> rootInstance -> groupStackRef ; $ appendLog = false ; if ( $ groupStackWas && \ end ( $ groupStackWas ) [ 'collect' ] == $ this -> cfg [ 'collect' ] ) { \ array_pop ( $ this -> rootInstance -> groupStackRef ) ; $ appendLog = $ this -> cfg [ 'collect' ] ; } if ( $ appendLog && $ value !== \ bdk \ Debug \ Abstracter :: UNDEFINED ) { $ this -> appendLog ( 'groupEndValue' , array ( 'return' , $ value ) , $ meta ) ; } if ( $ this -> data [ 'groupPriorityStack' ] && ! $ groupStackWas ) { $ priorityClosing = \ array_pop ( $ this -> data [ 'groupPriorityStack' ] ) ; unset ( $ this -> data [ 'groupStacks' ] [ $ priorityClosing ] ) ; $ this -> setLogDest ( 'auto' ) ; $ meta [ 'closesSummary' ] = true ; $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; } elseif ( $ appendLog ) { $ this -> appendLog ( 'groupEnd' , array ( ) , $ meta ) ; } $ errorCaller = $ this -> errorHandler -> get ( 'errorCaller' ) ; if ( $ errorCaller && isset ( $ errorCaller [ 'groupDepth' ] ) && $ this -> getGroupDepth ( ) < $ errorCaller [ 'groupDepth' ] ) { $ this -> errorHandler -> setErrorCaller ( false ) ; } }
3679	private function buildBackendModules ( & $ localMenu ) { foreach ( $ this -> viewCombination -> getStandalone ( ) as $ metaModelName => $ screen ) { $ section = $ screen [ 'meta' ] [ 'backendsection' ] ; if ( ! isset ( $ localMenu [ $ section ] ) ) { $ localMenu [ $ section ] = [ ] ; } if ( ! isset ( $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] ) ) { $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] = [ 'tables' => [ ] ] ; } $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] [ 'callback' ] = Module :: class ; array_unshift ( $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] [ 'tables' ] , $ metaModelName ) ; } }
4326	public static function getInterface ( ) { $ return = 'http' ; $ isCliOrCron = \ count ( \ array_filter ( array ( \ defined ( 'STDIN' ) , isset ( $ _SERVER [ 'argv' ] ) , ! \ array_key_exists ( 'REQUEST_METHOD' , $ _SERVER ) , ) ) ) > 0 ; if ( $ isCliOrCron ) { $ return = isset ( $ _SERVER [ 'TERM' ] ) || \ array_key_exists ( 'PATH' , $ _SERVER ) ? 'cli' : 'cron' ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_REQUESTED_WITH' ] ) && $ _SERVER [ 'HTTP_X_REQUESTED_WITH' ] == 'XMLHttpRequest' ) { $ return = 'ajax' ; } return $ return ; }
9499	public function processRequest ( RequestInterface $ request ) { $ response = $ request -> send ( ) ; $ attempt = 0 ; while ( $ response -> getStatusCode ( ) == 429 && $ attempt < 5 ) { $ wait = $ response -> getHeader ( 'Retry-After' ) ; if ( $ wait > 0 ) { sleep ( $ wait ) ; } $ attempt ++ ; $ response = $ request -> send ( ) ; } if ( $ response -> getStatusCode ( ) >= 500 ) { throw new ZendeskException ( 'Zendesk Server Error Detected.' ) ; } if ( $ response -> getStatusCode ( ) >= 400 ) { if ( $ response -> getContentType ( ) == 'application/json' ) { $ result = $ response -> json ( ) ; $ description = array_key_exists ( $ result , 'description' ) ? $ result [ 'description' ] : 'Invalid Request' ; $ value = array_key_exists ( $ result , 'value' ) ? $ result [ 'value' ] : array ( ) ; $ exception = new ZendeskException ( $ description ) ; $ exception -> setError ( $ value ) ; throw $ exception ; } else { throw new ZendeskException ( 'Invalid API Request' ) ; } } return $ response ; }
2985	protected function generateIndexView ( $ dir ) { $ this -> renderFile ( 'crud/views/index.html.twig.twig' , $ dir . '/index.html.twig' , array ( 'bundle' => $ this -> bundle -> getName ( ) , 'entity' => $ this -> entity , 'entity_pluralized' => $ this -> entityPluralized , 'entity_singularized' => $ this -> entitySingularized , 'identifier' => $ this -> metadata -> identifier [ 0 ] , 'fields' => $ this -> metadata -> fieldMappings , 'actions' => $ this -> actions , 'record_actions' => $ this -> getRecordActions ( ) , 'route_prefix' => $ this -> routePrefix , 'route_name_prefix' => $ this -> routeNamePrefix , ) ) ; }
12444	public static function run ( $ source , $ destination , $ width , $ height = "" ) { $ mime = exif_imagetype ( $ source ) ; switch ( $ mime ) { case IMAGETYPE_JPEG : $ source = imagecreatefromjpeg ( $ source ) ; break ; case IMAGETYPE_PNG : $ source = imagecreatefrompng ( $ source ) ; break ; case IMAGETYPE_GIF : $ source = imagecreatefromgif ( $ source ) ; break ; default : return ; } $ width_src = imagesx ( $ source ) ; $ height_src = imagesy ( $ source ) ; $ width_dest = 0 ; $ height_dest = 0 ; if ( ! $ height ) { $ ratio = ( $ width * 100 ) / $ width_src ; if ( $ ratio > 100 ) { imagejpeg ( $ source , $ destination , 70 ) ; imagedestroy ( $ source ) ; return ; } $ width_dest = $ width ; $ height_dest = $ height_src * $ ratio / 100 ; } else { if ( $ height_src >= $ width_src ) { $ height_dest = ( $ height_src * $ width ) / $ width_src ; $ width_dest = $ width ; } elseif ( $ height_src < $ width_src ) { $ width_dest = ( $ width_src * $ height ) / $ height_src ; $ height_dest = $ height ; } } $ emptyPicture = imagecreatetruecolor ( $ width , ( $ height ) ? $ height : $ height_dest ) ; imagecopyresampled ( $ emptyPicture , $ source , 0 , 0 , 0 , 0 , $ width_dest , $ height_dest , $ width_src , $ height_src ) ; imagejpeg ( $ emptyPicture , $ destination , 70 ) ; imagedestroy ( $ source ) ; imagedestroy ( $ emptyPicture ) ; return ; }
6071	public function uploadFileChunked ( $ fileData , $ name , $ chunk , $ chunks , $ fileId , $ categoryId , $ title = null ) { $ parameters = [ 'query' => [ 'name' => $ name , 'chunk' => $ chunk , 'chunks' => $ chunks , 'fileId' => $ fileId , 'categoryId' => $ categoryId , 'title' => $ title , ] , 'multipart' => [ [ 'name' => 'file' , 'contents' => \ GuzzleHttp \ Psr7 \ stream_for ( $ fileData ) , 'filename' => $ name , ] , ] , 'headers' => null , ] ; $ result = $ this -> post ( 'v1/media.json' , $ parameters ) ; return $ result ; }
3611	public function getNextScheduledEvent ( $ serial_number = NULL ) { $ schedule = $ this -> getDeviceSchedule ( $ serial_number ) ; $ next_event = FALSE ; $ time = date ( 'H' ) * 60 + date ( 'i' ) ; for ( $ i = 0 , $ day = date ( 'D' ) ; $ i ++ < 7 ; $ day = date ( 'D' , strtotime ( "+ $i days" ) ) ) { if ( isset ( $ schedule [ $ day ] ) ) { foreach ( $ schedule [ $ day ] as $ event ) { if ( $ event -> time > $ time ) { return $ event ; } } } $ time = 0 ; } return $ next_event ; }
10384	protected static function set_new_params ( $ type , $ hash , $ url , $ extension ) { $ data = [ 'name' => self :: $ id , 'url' => $ url . $ hash . $ extension , 'deps' => self :: unify_params ( $ type , 'deps' ) , 'version' => self :: unify_params ( $ type , 'version' , '1.0.0' ) , ] ; switch ( $ type ) { case 'style' : $ data [ 'media' ] = self :: unify_params ( $ type , 'media' , 'all' ) ; break ; case 'script' : $ data [ 'params' ] = self :: unify_params ( $ type , 'params' ) ; $ data [ 'footer' ] = self :: unify_params ( $ type , 'footer' , false ) ; $ data [ 'params' ] [ 'nonce' ] = wp_create_nonce ( self :: $ id ) ; break ; default : } self :: $ data [ $ type ] = [ $ data [ 'name' ] => $ data ] ; return true ; }
6264	public function then ( callable $ onFulfilled = null , callable $ onRejected = null ) { $ newPromise = new self ( $ this -> loop ) ; $ onFulfilled = null !== $ onFulfilled ? $ onFulfilled : function ( ResponseInterface $ response ) { return $ response ; } ; $ onRejected = null !== $ onRejected ? $ onRejected : function ( Exception $ exception ) { throw $ exception ; } ; $ this -> onFulfilled = function ( ResponseInterface $ response ) use ( $ onFulfilled , $ newPromise ) { try { $ return = $ onFulfilled ( $ response ) ; $ newPromise -> resolve ( null !== $ return ? $ return : $ response ) ; } catch ( Exception $ exception ) { $ newPromise -> reject ( $ exception ) ; } } ; $ this -> onRejected = function ( Exception $ exception ) use ( $ onRejected , $ newPromise ) { try { $ newPromise -> resolve ( $ onRejected ( $ exception ) ) ; } catch ( Exception $ exception ) { $ newPromise -> reject ( $ exception ) ; } } ; if ( HttpPromise :: FULFILLED === $ this -> state ) { $ this -> doResolve ( $ this -> response ) ; } if ( HttpPromise :: REJECTED === $ this -> state ) { $ this -> doReject ( $ this -> exception ) ; } return $ newPromise ; }
12747	public function getInputSpecification ( ) { $ dateValidator = $ this -> getDateValidator ( ) ; $ dateValidatorName = get_class ( $ dateValidator ) ; return [ 'name' => $ this -> getName ( ) , 'required' => true , 'filters' => [ Filter \ StringTrim :: class => [ 'name' => Filter \ StringTrim :: class ] , Filter \ StripNewlines :: class => [ 'name' => Filter \ StripNewlines :: class ] , Filter \ StripTags :: class => [ 'name' => Filter \ StripTags :: class ] , TimeToDateTime :: class => [ 'name' => TimeToDateTime :: class , 'options' => [ 'time_format' => $ this -> getFormat ( ) ] ] ] , 'validators' => [ $ dateValidatorName => $ dateValidator ] ] ; }
7840	public function addNumber ( int $ id , string $ number ) : ? array { $ response = Request :: put ( $ this -> baseUrl . sprintf ( 'contact/%d/phone-number/%s' , $ id , $ number ) ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
4109	public function toOptionArray ( ) { $ options = array ( ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_comment' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Comments' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_opentip' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_tipOnly' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups (border initially invisible)' ) ) ; Mage :: dispatchEvent ( 'aoetemplatehints_hintrenderer_options' , array ( 'options' => & $ options ) ) ; return $ options ; }
4180	protected function notifyUser ( ) { $ this -> console -> line ( '' ) ; $ this -> console -> line ( "{$this->isDone($this->getProviders()->isRegistered())} " . "{$this->getProviders()->count()} service provider registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getFacades()->isRegistered())} " . "{$this->getFacades()->count()} facade registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getMigration()->isRegistered())} " . "{$this->getMigration()->count()} migration file ran." ) ; $ this -> console -> line ( "{$this->isDone($this->getResources()->isRegistered())} " . '- ' . $ this -> console -> tokenizePackageInfo ( ) [ 'name' ] . ' file publish.' ) ; return true ; }
111	public function addPlugin ( PluginInterface $ plugin ) { $ this -> io -> writeError ( 'Loading plugin ' . get_class ( $ plugin ) , true , IOInterface :: DEBUG ) ; $ this -> plugins [ ] = $ plugin ; $ plugin -> activate ( $ this -> composer , $ this -> io ) ; if ( $ plugin instanceof EventSubscriberInterface ) { $ this -> composer -> getEventDispatcher ( ) -> addSubscriber ( $ plugin ) ; } }
5513	public function expectMinimumCallCount ( $ method , $ count , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set minimum call count' ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_counts [ strtolower ( $ method ) ] = new MinimumCallCountExpectation ( $ method , $ count , $ message ) ; }
1914	protected function generateHashes ( $ sum ) { $ time = ( int ) round ( time ( ) / 60 / 30 ) ; return array_map ( function ( $ hashTime ) use ( $ sum ) { return hash_hmac ( 'sha256' , $ sum . "\0" . $ hashTime , System :: getContainer ( ) -> getParameter ( 'kernel.secret' ) ) ; } , array ( $ time , $ time - 1 ) ) ; }
2279	public static function get ( $ strKey ) { if ( isset ( static :: $ arrCache [ $ strKey ] ) ) { return static :: $ arrCache [ $ strKey ] ; } if ( \ in_array ( $ strKey , get_class_methods ( __CLASS__ ) ) ) { static :: $ arrCache [ $ strKey ] = static :: $ strKey ( ) ; } else { $ arrChunks = preg_split ( '/([A-Z][a-z]*)/' , $ strKey , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; $ strServerKey = strtoupper ( implode ( '_' , $ arrChunks ) ) ; static :: $ arrCache [ $ strKey ] = $ _SERVER [ $ strServerKey ] ; } return static :: $ arrCache [ $ strKey ] ; }
8717	public static function forceCreate ( array $ attributes , $ translations = [ ] ) { $ model = new static ; return static :: unguarded ( function ( ) use ( $ model , $ attributes , $ translations ) { return $ model -> create ( $ attributes , $ translations ) ; } ) ; }
6390	public function readFacetofaceSessionSignups ( $ sessionid , $ timecreated ) { $ signups = $ this -> readStoreRecords ( 'facetoface_signups' , [ 'sessionid' => $ sessionid ] ) ; foreach ( $ signups as $ index => $ signup ) { $ signups [ $ index ] -> statuses = $ this -> readStoreRecords ( 'facetoface_signups_status' , [ 'signupid' => $ signup -> id ] ) ; $ signups [ $ index ] -> attendee = $ this -> readUser ( $ signup -> userid ) ; } return $ signups ; }
4262	public function subscribe ( $ eventName , $ callable , $ priority = 0 ) { unset ( $ this -> sorted [ $ eventName ] ) ; $ this -> subscribers [ $ eventName ] [ $ priority ] [ ] = $ callable ; }
10951	private function validateCsrfTokenInternal ( $ token , $ trueToken ) { $ token = base64_decode ( str_replace ( '.' , '+' , $ token ) ) ; $ n = StringHelper :: byteLength ( $ token ) ; if ( $ n <= static :: CSRF_MASK_LENGTH ) { return false ; } $ mask = StringHelper :: byteSubstr ( $ token , 0 , static :: CSRF_MASK_LENGTH ) ; $ token = StringHelper :: byteSubstr ( $ token , static :: CSRF_MASK_LENGTH , $ n - static :: CSRF_MASK_LENGTH ) ; $ token = $ this -> xorTokens ( $ mask , $ token ) ; return $ token === $ trueToken ; }
12437	public function addFormField ( IFormField $ field , $ isExtra = false ) { $ fieldId = $ field -> getId ( ) ; if ( empty ( $ fieldId ) ) { throw new \ LogicException ( 'The access path of a form field must not be empty' ) ; } $ field -> setParent ( $ this ) ; $ this -> children [ $ fieldId ] = $ field ; if ( $ isExtra === false ) { $ mappingContext = new MappingContext ( $ this , $ field , $ this -> accessorChain ) ; $ this -> mappingContexts [ $ fieldId ] = $ mappingContext ; } return $ field ; }
11669	protected function createAggregateConnection ( $ parameters , $ option ) { $ options = $ this -> getOptions ( ) ; $ initializer = $ options -> $ option ; $ connection = $ initializer ( $ parameters ) ; if ( $ option !== 'aggregate' && ! $ connection instanceof SentinelReplication ) { $ options -> connections -> aggregate ( $ connection , $ parameters ) ; } return $ connection ; }
2555	protected static function loadCorpNegoFare ( $ corporateNegoFare ) { $ opt = [ ] ; if ( $ corporateNegoFare !== null ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_CORPORATE_NEGOTIATED_FARES ) ; $ po -> optionDetail = new OptionDetail ( $ corporateNegoFare ) ; $ opt [ ] = $ po ; } return $ opt ; }
8732	public function challenge ( string $ hydroAddressId ) : ChallengeResponse { try { $ response = $ this -> callHydroApi ( 'post' , 'challenge' , [ 'json' => [ 'hydro_address_id' => $ hydroAddressId ] ] ) ; $ data = \ GuzzleHttp \ json_decode ( $ response -> getBody ( ) -> getContents ( ) , true , 512 , JSON_BIGINT_AS_STRING ) ; } catch ( RuntimeException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( InvalidArgumentException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( GuzzleException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( ApiRequestFailed $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } return new ChallengeResponse ( $ data [ 'amount' ] , ( int ) $ data [ 'challenge' ] , ( int ) $ data [ 'partner_id' ] , $ data [ 'transaction_hash' ] ) ; }
5491	protected function describeDifference ( $ expected , $ parameters ) { if ( count ( $ expected ) != count ( $ parameters ) ) { return sprintf ( 'Expected %s arguments of [%s], but got %s arguments of [%s]' , count ( $ expected ) , $ this -> renderArguments ( $ expected ) , count ( $ parameters ) , $ this -> renderArguments ( $ parameters ) ) ; } $ messages = array ( ) ; for ( $ i = 0 ; $ i < count ( $ expected ) ; $ i ++ ) { $ comparison = $ this -> forceToExpectation ( $ expected [ $ i ] ) ; if ( ! $ comparison -> test ( $ parameters [ $ i ] ) ) { $ messages [ ] = 'parameter ' . ( $ i + 1 ) . ' with [' . $ comparison -> overlayMessage ( $ parameters [ $ i ] , $ this -> getDumper ( ) ) . ']' ; } } return 'Parameter expectation differs at ' . implode ( ' and ' , $ messages ) ; }
2161	public function run33Update ( ) { $ objLayout = $ this -> Database -> query ( "SELECT id, framework FROM tl_layout WHERE framework!=''" ) ; while ( $ objLayout -> next ( ) ) { $ strFramework = '' ; $ tmp = StringUtil :: deserialize ( $ objLayout -> framework ) ; if ( ! empty ( $ tmp ) && \ is_array ( $ tmp ) ) { if ( ( $ key = array_search ( 'layout.css' , $ tmp ) ) !== false ) { array_insert ( $ tmp , $ key + 1 , 'responsive.css' ) ; } $ strFramework = serialize ( array_values ( array_unique ( $ tmp ) ) ) ; } $ this -> Database -> prepare ( "UPDATE tl_layout SET framework=? WHERE id=?" ) -> execute ( $ strFramework , $ objLayout -> id ) ; } $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `viewport` varchar(64) NOT NULL default ''" ) ; }
5751	public function deleteByPrimaryKey ( $ primaryKeyValue , ? string $ returnField = null ) : ? string { if ( null === $ role = $ this -> getObjectById ( ( int ) $ primaryKeyValue ) ) { throw new Exceptions \ QueryResultsNotFoundException ( "Role not found: id $primaryKeyValue" ) ; } if ( ! $ role -> isDeletable ( ( int ) $ primaryKeyValue ) ) { throw new Exceptions \ UnallowedActionException ( "Role in use: id $primaryKeyValue" ) ; } return parent :: deleteByPrimaryKey ( $ primaryKeyValue , $ returnField ) ; }
11360	public function setSortBy ( $ sortKeys ) { if ( $ sortKeys == null ) { $ sortKeys = [ ] ; } if ( ! is_array ( $ sortKeys ) ) { $ sortKeys = [ $ sortKeys ] ; } $ this -> sortKeys = $ sortKeys ; }
2544	protected function analyzeWithErrCodeCategoryMsgNodeName ( SendResult $ response , $ nodeErr , $ nodeCat , $ nodeMsg ) { $ analyzeResponse = new Result ( $ response ) ; $ domDoc = $ this -> loadDomDocument ( $ response -> responseXml ) ; $ errorCodeNode = $ domDoc -> getElementsByTagName ( $ nodeErr ) -> item ( 0 ) ; if ( ! is_null ( $ errorCodeNode ) ) { $ errorCatNode = $ domDoc -> getElementsByTagName ( $ nodeCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } else { $ analyzeResponse -> status = Result :: STATUS_ERROR ; } $ errorCode = $ errorCodeNode -> nodeValue ; $ errorTextNodeList = $ domDoc -> getElementsByTagName ( $ nodeMsg ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCode , $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ) ; } return $ analyzeResponse ; }
8089	static protected function encode ( $ number ) { $ k = self :: $ encoder ; preg_match_all ( "/[1-9][0-9]|[0-9]/" , $ number , $ a ) ; $ n = '' ; $ o = count ( $ k ) ; foreach ( $ a [ 0 ] as $ i ) { if ( $ i < $ o ) { $ n .= $ k [ $ i ] ; } else { $ n .= '1' . $ k [ $ i - $ o ] ; } } return $ n ; }
2262	public function query ( $ strQuery ) { $ objStatement = new Statement ( $ this -> resConnection , $ this -> blnDisableAutocommit ) ; return $ objStatement -> query ( $ strQuery ) ; }
7612	public function getIsSuperAdmin ( ) { if ( $ this -> _isSuperAdmin !== null ) { return $ this -> _isSuperAdmin ; } $ this -> _isSuperAdmin = in_array ( $ this -> username , Yii :: $ app -> getModule ( 'auth' ) -> superAdmins ) ; return $ this -> _isSuperAdmin ; }
8044	public static function setProcessTitle ( $ title , array $ replacements = array ( ) ) { if ( trim ( $ title ) == '' || PHP_OS == 'Darwin' ) { return ; } $ title = preg_replace_callback ( '/\%([a-z0-9]+)\%/i' , function ( $ match ) use ( $ replacements ) { if ( isset ( $ replacements [ $ match [ 1 ] ] ) ) { return $ replacements [ $ match [ 1 ] ] ; } return $ match [ 0 ] ; } , $ title ) ; $ title = preg_replace ( '/[^a-z0-9-_.: \\\\\\]\\[]/i' , '' , $ title ) ; if ( function_exists ( 'cli_set_process_title' ) ) { cli_set_process_title ( $ title ) ; } elseif ( function_exists ( 'setproctitle' ) ) { setproctitle ( $ title ) ; } }
12711	public function register ( $ alias , $ abstract ) { if ( ! is_string ( $ alias ) || ! is_string ( $ abstract ) ) { throw new \ InvalidArgumentException ( sprintf ( "Parameter 1 and 2 of %s must be a string." , __METHOD__ ) ) ; } if ( ! isset ( $ this -> aliases [ $ alias ] ) ) { $ this -> aliases [ $ alias ] = $ this -> make ( $ abstract ) ; } return $ this ; }
5713	public function updateItemEditForm ( $ form ) { if ( $ this -> owner -> record -> stat ( 'better_buttons_enabled' ) !== true ) { return false ; } Requirements :: css ( BETTER_BUTTONS_DIR . '/css/gridfield_betterbuttons.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/gridfield_betterbuttons.js' ) ; $ actions = $ this -> owner -> record -> getBetterButtonsActions ( ) ; $ form -> setActions ( $ this -> filterFieldList ( $ form , $ actions ) ) ; if ( $ form -> Fields ( ) -> hasTabSet ( ) ) { $ form -> Fields ( ) -> findOrMakeTab ( 'Root' ) -> setTemplate ( TabSet :: class ) ; $ form -> addExtraClass ( 'cms-tabset' ) ; } $ utils = $ this -> owner -> record -> getBetterButtonsUtils ( ) ; $ form -> Utils = $ this -> filterFieldList ( $ form , $ utils ) ; $ form -> setTemplate ( [ 'type' => 'Includes' , 'BetterButtons_EditForm' , ] ) ; $ form -> addExtraClass ( 'better-buttons-form' ) ; }
8078	protected function buildUri ( $ endpoint , $ options = [ ] ) { if ( $ this -> token !== '' ) { $ options [ 'auth' ] = $ this -> token ; } return $ this -> base . '/' . ltrim ( $ endpoint , '/' ) . '.json?' . http_build_query ( $ options , '' , '&' ) ; }
10804	public function getBackOfficeUsersAction ( ) { $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ users = $ melisPageHistoricTable -> getUsers ( ) -> toArray ( ) ; return new JsonModel ( array ( 'users' => $ users , ) ) ; }
8491	public static function getCpuCores ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT NumberOfLogicalProcessors FROM Win32_Processor" ) ; $ cores = 0 ; foreach ( $ object as $ obj ) { $ cores = $ obj -> NumberOfLogicalProcessors ; } return $ cores ; }
11532	public static function cascade ( array $ folders ) { $ result = null ; foreach ( $ folders as $ folder ) { if ( is_dir ( $ folder ) ) { $ result = $ folder ; break ; } } return $ result ; }
10289	protected function executeTasks ( array $ tasks ) { foreach ( $ tasks as $ scheduled => $ taskList ) { foreach ( $ taskList as $ cronjob ) { if ( ( $ task = $ this -> taskFactory -> factory ( $ cronjob -> task , $ scheduled , $ this -> logger ) ) !== false ) { $ this -> logger -> setTask ( $ task -> getId ( ) ) ; $ this -> logger -> log ( 'Start task execution.' ) ; $ status = $ task -> execute ( ) ; switch ( $ status ) { case Executor :: SUCCESS : $ this -> logger -> log ( 'Finished task execution.' ) ; break ; case Executor :: ERROR : $ this -> logger -> log ( 'Error occured during task execution.' , Logger :: WARNING ) ; break ; case Executor :: RESCHEDULE : $ this -> logger -> log ( 'Task will be rescheduled for ' . $ task -> reScheduleTime . ' seconds.' ) ; $ this -> rescheduled [ $ scheduled + $ task -> reScheduleTime ] = $ cronjob ; break ; default : $ this -> logger -> log ( 'Invalid status returned by task.' , Logger :: ERROR ) ; break ; } $ this -> logger -> setTask ( ) ; } } } }
3343	public function createLocalCopy ( $ source , $ store = true ) { $ data = $ this -> __preparedRequest ( 'file_copy' , 'POST' , array ( ) , array ( 'source' => $ source , 'store' => $ store ) ) ; if ( array_key_exists ( 'result' , ( array ) $ data ) == true ) { if ( $ data -> type == 'file' ) { return new File ( ( string ) $ data -> result -> uuid , $ this ) ; } else { return ( string ) $ data -> result ; } } else { return ( string ) $ data -> detail ; } }
6276	protected function readInt31 ( $ pos = 0 ) { $ uint31 = $ this -> readInt32 ( $ pos ) ; if ( $ uint31 > 0x7fffffff ) { throw new Exception ( 'Error in CDB file "' . $ this -> fileName . '", integer too big.' ) ; } return $ uint31 ; }
10134	public function positionImage ( $ col_start , $ row_start , $ x1 , $ y1 , $ width , $ height ) { $ col_end = $ col_start ; $ row_end = $ row_start ; if ( $ x1 >= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) ) { $ x1 = 0 ; } if ( $ y1 >= Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) ) { $ y1 = 0 ; } $ width = $ width + $ x1 - 1 ; $ height = $ height + $ y1 - 1 ; while ( $ width >= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) ) { $ width -= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) ; ++ $ col_end ; } while ( $ height >= Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) ) { $ height -= Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) ; ++ $ row_end ; } if ( Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) == 0 ) { return ; } if ( Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) == 0 ) { return ; } if ( Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) == 0 ) { return ; } if ( Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) == 0 ) { return ; } $ x1 = $ x1 / Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) * 1024 ; $ y1 = $ y1 / Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) * 256 ; $ x2 = $ width / Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) * 1024 ; $ y2 = $ height / Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) * 256 ; $ this -> writeObjPicture ( $ col_start , $ x1 , $ row_start , $ y1 , $ col_end , $ x2 , $ row_end , $ y2 ) ; }
12146	public function get ( $ name ) { if ( $ this -> exists ( $ name ) ) { $ value = $ this -> settings [ $ name ] ; return $ value ; } return false ; }
6851	public static function fuzzySpan ( $ timestamp , $ local_timestamp = null ) { $ local_timestamp = ( $ local_timestamp === null ) ? time ( ) : ( int ) $ local_timestamp ; $ offset = abs ( $ local_timestamp - $ timestamp ) ; if ( $ offset <= static :: MINUTE ) { $ span = 'moments' ; } elseif ( $ offset < ( static :: MINUTE * 20 ) ) { $ span = 'a few minutes' ; } elseif ( $ offset < static :: HOUR ) { $ span = 'less than an hour' ; } elseif ( $ offset < ( static :: HOUR * 4 ) ) { $ span = 'a couple of hours' ; } elseif ( $ offset < static :: DAY ) { $ span = 'less than a day' ; } elseif ( $ offset < ( static :: DAY * 2 ) ) { $ span = 'about a day' ; } elseif ( $ offset < ( static :: DAY * 4 ) ) { $ span = 'a couple of days' ; } elseif ( $ offset < static :: WEEK ) { $ span = 'less than a week' ; } elseif ( $ offset < ( static :: WEEK * 2 ) ) { $ span = 'about a week' ; } elseif ( $ offset < static :: MONTH ) { $ span = 'less than a month' ; } elseif ( $ offset < ( static :: MONTH * 2 ) ) { $ span = 'about a month' ; } elseif ( $ offset < ( static :: MONTH * 4 ) ) { $ span = 'a couple of months' ; } elseif ( $ offset < static :: YEAR ) { $ span = 'less than a year' ; } elseif ( $ offset < ( static :: YEAR * 2 ) ) { $ span = 'about a year' ; } elseif ( $ offset < ( static :: YEAR * 4 ) ) { $ span = 'a couple of years' ; } elseif ( $ offset < ( static :: YEAR * 8 ) ) { $ span = 'a few years' ; } elseif ( $ offset < ( static :: YEAR * 12 ) ) { $ span = 'about a decade' ; } elseif ( $ offset < ( static :: YEAR * 24 ) ) { $ span = 'a couple of decades' ; } elseif ( $ offset < ( static :: YEAR * 64 ) ) { $ span = 'several decades' ; } else { $ span = 'a long time' ; } if ( $ timestamp <= $ local_timestamp ) { return $ span . ' ago' ; } else { return 'in ' . $ span ; } }
10232	private function writeLine ( $ pFileHandle , array $ pValues ) { $ writeDelimiter = false ; $ line = '' ; foreach ( $ pValues as $ element ) { $ element = str_replace ( $ this -> enclosure , $ this -> enclosure . $ this -> enclosure , $ element ) ; if ( $ writeDelimiter ) { $ line .= $ this -> delimiter ; } else { $ writeDelimiter = true ; } $ line .= $ this -> enclosure . $ element . $ this -> enclosure ; } $ line .= $ this -> lineEnding ; fwrite ( $ pFileHandle , $ line ) ; }
9561	protected function makeResponse ( $ response , Exception $ exception ) { if ( ! $ response instanceof Response ) { $ response = new Response ( $ response ) ; } if ( ! $ response -> isClientError ( ) && ! $ response -> isServerError ( ) && ! $ response -> isRedirect ( ) ) { if ( $ exception instanceof HttpExceptionInterface ) { $ response -> setStatusCode ( $ exception -> getStatusCode ( ) ) ; $ response -> headers -> add ( $ exception -> getHeaders ( ) ) ; } else { $ response -> setStatusCode ( 500 ) ; } } return $ response ; }
1994	public static function indexPageIfApplicable ( Response $ objResponse ) { global $ objPage ; if ( $ objPage === null ) { return ; } if ( Config :: get ( 'enableSearch' ) && $ objResponse -> getStatusCode ( ) == 200 && ! BE_USER_LOGGED_IN && ! $ objPage -> noSearch ) { if ( Config :: get ( 'indexProtected' ) || ( ! FE_USER_LOGGED_IN && ! $ objPage -> protected ) ) { $ blnIndex = true ; foreach ( array_keys ( $ _GET ) as $ key ) { if ( \ in_array ( $ key , $ GLOBALS [ 'TL_NOINDEX_KEYS' ] ) || strncmp ( $ key , 'page_' , 5 ) === 0 ) { $ blnIndex = false ; break ; } } if ( $ blnIndex ) { $ arrData = array ( 'url' => Environment :: get ( 'base' ) . Environment :: get ( 'relativeRequest' ) , 'content' => $ objResponse -> getContent ( ) , 'title' => $ objPage -> pageTitle ? : $ objPage -> title , 'protected' => ( $ objPage -> protected ? '1' : '' ) , 'groups' => $ objPage -> groups , 'pid' => $ objPage -> id , 'language' => $ objPage -> language ) ; Search :: indexPage ( $ arrData ) ; } } } }
6689	public function setSessionAndRedirect ( $ key , $ value , $ redirectUrl ) { $ this -> getSession ( ) -> set ( $ key , $ value ) ; return $ this -> redirect ( $ redirectUrl ) ; }
10428	private function initSyncStorage ( ContainerBuilder $ container , array $ config ) { $ availableStorages = array_keys ( $ config [ 'sync' ] [ 'sync_storage' ] ) ; $ syncStorageStorage = current ( $ availableStorages ) ; if ( empty ( $ syncStorageStorage ) ) { throw new LogicException ( 'Data synchronization storage must be set.' ) ; } $ syncStorageStorageConfig = $ config [ 'sync' ] [ 'sync_storage' ] [ $ syncStorageStorage ] ; switch ( $ syncStorageStorage ) { case SyncStorage :: STORAGE_MYSQL : $ this -> initSyncStorageForMysql ( $ container , $ syncStorageStorageConfig ) ; break ; default : throw new LogicException ( "Unknown storage is set: {$syncStorageStorage}" ) ; } }
1474	public function createResourceValidator ( ResourceObject $ resource , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ resource -> all ( ) , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) use ( $ resource ) { return $ this -> invalidResource ( $ resource -> pointer ( $ key , '/data' ) , $ detail , $ failed ) ; } ) ; }
3719	protected function wantToHandle ( AbstractEnvironmentAwareEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) ) { return false ; } if ( $ event -> getPropertyName ( ) !== 'type' ) { return false ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ request -> request -> get ( 'act' , null ) === 'select' && ! $ event -> getModel ( ) -> getId ( ) ) { return false ; } return true ; }
4712	public function escapeHtml ( $ option = ENT_QUOTES ) { $ this -> text = htmlspecialchars ( $ this -> text , $ option , 'UTF-8' , false ) ; return $ this ; }
3966	public function getInputScreen ( ) { return new InputScreen ( \ System :: getContainer ( ) -> get ( 'cca.legacy_dic' ) -> getService ( 'metamodels-service-container' ) , $ this -> inputScreen [ 'meta' ] , $ this -> inputScreen [ 'properties' ] , $ this -> inputScreen [ 'conditions' ] , $ this -> inputScreen [ 'groupSort' ] ) ; }
3110	public function removeCatValue ( $ assessmentSectionId , $ key ) { if ( isset ( $ this -> state [ self :: VAR_CAT ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ) { unset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ; } return $ this ; }
3837	private function getBaseDefinition ( ) { $ this -> setLanguageStrings ( ) ; $ tableName = $ this -> getMetaModel ( ) -> getTableName ( ) ; $ definition = array ( ) ; if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] [ 'fields' ] [ $ this -> getColName ( ) ] ) ) { $ definition = $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] [ 'fields' ] [ $ this -> getColName ( ) ] ; } return array_replace_recursive ( array ( 'label' => & $ GLOBALS [ 'TL_LANG' ] [ $ tableName ] [ $ this -> getColName ( ) ] , 'eval' => array ( ) ) , $ definition ) ; }
72	public function authorizeOAuth ( $ originUrl ) { if ( $ originUrl !== 'bitbucket.org' ) { return false ; } if ( 0 === $ this -> process -> execute ( 'git config bitbucket.accesstoken' , $ output ) ) { $ this -> io -> setAuthentication ( $ originUrl , 'x-token-auth' , trim ( $ output ) ) ; return true ; } return false ; }
2917	protected function ensureFileIsWritable ( $ filePath ) { if ( ( is_file ( $ filePath ) && ! is_writable ( $ filePath ) ) || ( ! is_file ( $ filePath ) && ! is_writable ( dirname ( $ filePath ) ) ) ) { throw new UnableWriteToFileException ( sprintf ( 'Unable to write to the file at %s.' , $ filePath ) ) ; } }
2900	public function initFromAction ( $ action ) { if ( ! $ action ) { return ; } $ request = $ action -> getRequest ( ) ; $ this -> httpMethod = $ request -> getMethod ( ) ; $ this -> requestOriginalPath = $ request -> getOriginalPathInfo ( ) ; $ this -> requestPath = $ request -> getPathInfo ( ) ; $ this -> remoteIp = Mage :: helper ( 'core/http' ) -> getRemoteAddr ( ) ; $ this -> routeName = $ request -> getRouteName ( ) ; $ this -> module = $ request -> getControllerModule ( ) ; $ this -> class = get_class ( $ action ) ; $ this -> action = $ action -> getActionMethodName ( $ request -> getActionName ( ) ) ; }
9690	public function render ( $ file , $ env = array ( ) ) { $ file = $ this -> views_path . '/' . $ file ; if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } $ cacheHash = md5 ( $ file . serialize ( $ env ) ) ; $ cache_file = $ this -> views_cache . "/$cacheHash.cache" ; if ( ! $ this -> debug && ( file_exists ( $ cache_file ) && filemtime ( $ cache_file ) > filemtime ( $ file ) ) ) { return file_get_contents ( $ cache_file ) ; } $ this -> currFile = $ file ; $ hash = md5 ( $ file ) ; $ this -> compile ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; set_error_handler ( array ( $ this , 'onTemplateError' ) ) ; require_once ( $ compiled_file ) ; $ output = call_user_func ( 'katar_' . $ hash , $ env ) ; restore_error_handler ( ) ; file_put_contents ( $ cache_file , $ output ) ; return $ output ; }
2357	public function getFrontendUsername ( ) : ? string { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; if ( null === $ token || ! $ token -> getUser ( ) instanceof FrontendUser ) { return null ; } return $ token -> getUser ( ) -> getUsername ( ) ; }
1470	public function createResolver ( $ apiName , array $ config ) { $ factoryName = isset ( $ config [ 'resolver' ] ) ? $ config [ 'resolver' ] : ResolverFactory :: class ; $ factory = $ this -> container -> make ( $ factoryName ) ; if ( $ factory instanceof ResolverInterface ) { return $ factory ; } if ( ! is_callable ( $ factory ) ) { throw new RuntimeException ( "Factory {$factoryName} cannot be invoked." ) ; } $ resolver = $ factory ( $ apiName , $ config ) ; if ( ! $ resolver instanceof ResolverInterface ) { throw new RuntimeException ( "Factory {$factoryName} did not create a resolver instance." ) ; } return $ resolver ; }
7443	public function newAction ( ) { $ group = new Group ( ) ; $ form = $ this -> createForm ( GroupType :: class , $ group ) ; return array ( 'group' => $ group , 'form' => $ form -> createView ( ) ) ; }
5205	public function isActiveMatch ( $ string , $ output = "active" ) { if ( strpos ( $ this -> url -> current ( ) , $ string ) !== false ) { return $ output ; } return null ; }
5477	public function addWidget ( $ tag ) { if ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'submit' ) { $ this -> buttons [ ] = $ tag ; } elseif ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'image' ) { $ this -> images [ ] = $ tag ; } elseif ( $ tag -> getName ( ) ) { $ this -> setWidget ( $ tag ) ; } }
3940	private function setEmptyValue ( PropertyInterface $ property , array $ propInfo ) { if ( ! array_key_exists ( 'empty_value' , $ propInfo ) || ! ( $ property instanceof EmptyValueAwarePropertyInterface ) ) { return ; } $ property -> setEmptyValue ( $ propInfo [ 'empty_value' ] ) ; }
8918	public function messages ( $ options ) { $ params = [ 'query' => [ 'apikey' => $ this -> apikey , 'limit' => 100 , 'page' => 1 ] ] ; if ( array_key_exists ( 'limit' , $ options ) ) { $ params [ 'query' ] [ 'limit' ] = $ options [ 'limit' ] ; } if ( array_key_exists ( 'page' , $ options ) ) { $ params [ 'query' ] [ 'page' ] = $ options [ 'page' ] ; } if ( array_key_exists ( 'startDate' , $ options ) ) { $ params [ 'query' ] [ 'startDate' ] = $ options [ 'startDate' ] ; } if ( array_key_exists ( 'endDate' , $ options ) ) { $ params [ 'query' ] [ 'endDate' ] = $ options [ 'endDate' ] ; } if ( array_key_exists ( 'status' , $ options ) ) { $ params [ 'query' ] [ 'status' ] = $ options [ 'status' ] ; } if ( array_key_exists ( 'network' , $ options ) ) { $ params [ 'query' ] [ 'network' ] = $ options [ 'network' ] ; } if ( array_key_exists ( 'sendername' , $ options ) ) { $ params [ 'query' ] [ 'sendername' ] = $ options [ 'sendername' ] ; } $ response = $ this -> client -> get ( 'messages' , $ params ) ; return $ response -> getBody ( ) ; }
7859	private function registerWorkflowRunnersHook ( ) { $ this -> app -> afterResolving ( function ( WorkflowRunner $ runner , $ app ) { $ runner -> setWorkflow ( $ app [ 'cerbero.workflow' ] ) ; } ) ; }
5349	public function installOperatingSystemUnattended ( $ vpsName , $ operatingSystemName , $ base64InstallText ) { return $ this -> call ( self :: SERVICE , 'installOperatingSystemUnattended' , [ $ vpsName , $ operatingSystemName , $ base64InstallText ] ) ; }
6520	private function populateDefault ( Field $ field ) { if ( $ this -> has ( $ field -> getName ( ) ) ) { return true ; } $ default = $ field -> getDefault ( $ this ) ; if ( null === $ default ) { return false ; } if ( $ field -> isASingleValue ( ) ) { $ this -> data [ $ field -> getName ( ) ] = $ default ; unset ( $ this -> clearedFields [ $ field -> getName ( ) ] ) ; return true ; } if ( empty ( $ default ) ) { return false ; } if ( $ field -> isASet ( ) ) { $ this -> addToSet ( $ field -> getName ( ) , $ default ) ; return true ; } $ this -> data [ $ field -> getName ( ) ] = $ default ; unset ( $ this -> clearedFields [ $ field -> getName ( ) ] ) ; return true ; }
875	private function convertToNowdoc ( Token $ token ) { return new Token ( [ $ token -> getId ( ) , Preg :: replace ( '/^([Bb]?<<<)([ \t]*)"?([^\s"]+)"?/' , '$1$2\'$3\'' , $ token -> getContent ( ) ) , ] ) ; }
8764	private function createUniqueFilename ( $ filename ) { $ full_size_dir = config ( 'dropzoner.upload-path' ) ; $ full_image_path = $ full_size_dir . $ filename . '.jpg' ; if ( \ File :: exists ( $ full_image_path ) ) { $ image_token = substr ( sha1 ( mt_rand ( ) ) , 0 , 5 ) ; return $ filename . '-' . $ image_token ; } return $ filename ; }
6136	public function folderSearch ( FolderSearch $ search ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'search' => $ search ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/search/folder' , $ parameters ) ; $ result = new SearchResult ( $ result ) ; return $ result ; }
6612	public static function getDropdownMap ( $ keyAttribute , $ valueAttribute , array $ default = [ ] ) { $ map = ArrayHelper :: map ( self :: getActive ( ) , $ keyAttribute , $ valueAttribute ) ; if ( $ default ) { $ map = array_merge ( $ default , $ map ) ; } return $ map ; }
12348	protected function getConnectionInitializer ( OptionsInterface $ options , $ callable ) { if ( ! is_callable ( $ callable ) ) { $ class = get_called_class ( ) ; throw new \ InvalidArgumentException ( "$class expects a valid callable" ) ; } $ option = $ this ; return function ( $ parameters = null ) use ( $ callable , $ options , $ option ) { $ connection = call_user_func ( $ callable , $ options , $ parameters ) ; if ( ! $ connection instanceof AggregateConnectionInterface ) { $ class = get_class ( $ option ) ; throw new \ InvalidArgumentException ( "$class expects a valid connection type returned by callable initializer" ) ; } return $ connection ; } ; }
10076	public static function controlCharacterPHP2OOXML ( $ value ) { self :: buildCharacterSets ( ) ; return str_replace ( array_values ( self :: $ controlCharacters ) , array_keys ( self :: $ controlCharacters ) , $ value ) ; }
1971	public static function findMultipleByUuids ( $ arrUuids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrUuids ) || ! \ is_array ( $ arrUuids ) ) { return null ; } $ t = static :: $ strTable ; foreach ( $ arrUuids as $ k => $ v ) { if ( Validator :: isStringUuid ( $ v ) ) { $ v = StringUtil :: uuidToBin ( $ v ) ; } $ arrUuids [ $ k ] = "UNHEX('" . bin2hex ( $ v ) . "')" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.uuid!=" . implode ( ", $t.uuid!=" , $ arrUuids ) ; } return static :: findBy ( array ( "$t.uuid IN(" . implode ( "," , $ arrUuids ) . ")" ) , null , $ arrOptions ) ; }
984	public function usageCharge ( StoreUsageCharge $ request ) { $ validated = $ request -> validated ( ) ; $ uc = new UsageCharge ( ShopifyApp :: shop ( ) , $ validated ) ; $ uc -> activate ( ) ; $ uc -> save ( ) ; return isset ( $ validated [ 'redirect' ] ) ? Redirect :: to ( $ validated [ 'redirect' ] ) -> with ( 'success' , 'usage_charge' ) : Redirect :: back ( ) -> with ( 'success' , 'usage_charge' ) ; }
1250	public function parse ( $ xml ) { $ parser = xml_parser_create_ns ( 'UTF-8' , '@' ) ; xml_parser_set_option ( $ parser , XML_OPTION_CASE_FOLDING , 0 ) ; xml_parser_set_option ( $ parser , XML_OPTION_SKIP_WHITE , 1 ) ; xml_set_object ( $ parser , $ this ) ; xml_set_element_handler ( $ parser , 'startElement' , 'endElement' ) ; xml_set_character_data_handler ( $ parser , 'cdata' ) ; xml_parse ( $ parser , $ xml , true ) ; xml_parser_free ( $ parser ) ; return $ this -> rootObject ; }
7774	protected function canSkipRule ( $ ruleToCall , $ value ) { return ( ( is_array ( $ ruleToCall ) && method_exists ( $ ruleToCall [ 0 ] , 'canSkip' ) && $ ruleToCall [ 0 ] -> canSkip ( ) ) || empty ( $ value ) && ! is_array ( $ value ) ) ; }
8466	public static function setUrlParams ( $ url = false ) { $ url = $ url !== false ? $ url : self :: getCurrentPage ( ) ; if ( strpos ( $ url , '?' ) == false && strpos ( $ url , '&' ) != false ) { $ url = preg_replace ( '/&/' , '?' , $ url , 1 ) ; $ parts = parse_url ( $ url ) ; $ query = isset ( $ parts [ 'query' ] ) ? $ parts [ 'query' ] : '' ; parse_str ( $ query , $ query ) ; } foreach ( isset ( $ query ) ? $ query : [ ] as $ key => $ value ) { $ _GET [ $ key ] = $ value ; } return explode ( '?' , $ url ) [ 0 ] ; }
2962	public function serialflush ( ) { if ( ! $ this -> _ckOpened ( ) ) { return false ; } if ( fwrite ( $ this -> _dHandle , $ this -> _buffer ) !== false ) { $ this -> _buffer = "" ; return true ; } else { $ this -> _buffer = "" ; trigger_error ( "Error while sending message" , E_USER_WARNING ) ; return false ; } }
12589	protected function sendEmails ( ContactInquiry $ inquiry ) { $ recipients = $ this -> container -> getParameter ( 'c33s_contact_form.email.recipients' ) ; if ( $ this -> container -> getParameter ( 'c33s_contact_form.email.send_copy_to_user' ) && $ inquiry -> hasSenderEmail ( ) ) { $ recipients [ ] = $ inquiry -> getSenderEmail ( ) ; } if ( empty ( $ recipients ) ) { return ; } $ translator = $ this -> get ( 'translator' ) ; $ subject = $ this -> container -> getParameter ( 'c33s_contact_form.email.subject' ) ; $ message = \ Swift_Message :: newInstance ( ) -> setSubject ( $ translator -> trans ( $ subject , array ( ) , 'C33sContactForm' ) ) -> setFrom ( $ this -> container -> getParameter ( 'c33s_contact_form.email.sender_email' ) ) -> setTo ( $ recipients ) -> setBody ( $ this -> renderView ( 'C33sContactFormBundle:ContactForm:email.txt.twig' , array ( 'inquiry' => $ inquiry ) ) ) ; $ this -> get ( 'mailer' ) -> send ( $ message ) ; }
5969	protected static function sortFileList ( array $ a , array $ b ) { if ( ! array_key_exists ( "src" , $ a ) || ! array_key_exists ( "src" , $ b ) || ! array_key_exists ( "type" , $ a ) || ! array_key_exists ( "type" , $ b ) ) { return 0 ; throw new Ts3Exception ( "invalid parameter" , 0x602 ) ; } if ( $ a [ "type" ] != $ b [ "type" ] ) { return ( $ a [ "type" ] < $ b [ "type" ] ) ? - 1 : 1 ; } return strcmp ( strtolower ( $ a [ "src" ] ) , strtolower ( $ b [ "src" ] ) ) ; }
2853	public function purgeAllProfiles ( ) { $ table = Mage :: getResourceModel ( 'sheep_debug/requestInfo' ) -> getMainTable ( ) ; $ deleteSql = "DELETE FROM {$table}" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return $ result -> rowCount ( ) ; }
10643	public function getParent ( ) { if ( $ this -> path === "/" || ( $ path = dirname ( $ this -> path ) ) === "." ) { return null ; } return new DirEntity ( $ path ) ; }
6906	public function addExtraRecipient ( Recipient $ recipient ) { if ( ! $ this -> extraRecipients -> contains ( $ recipient ) ) { $ this -> extraRecipients -> add ( $ recipient ) ; } return $ this ; }
4017	protected function handleLoadCallback ( $ field , $ value ) { if ( isset ( $ field [ 'load_callback' ] ) && is_array ( $ field [ 'load_callback' ] ) ) { foreach ( $ field [ 'load_callback' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ value = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ value , $ this ) ; } } return $ value ; }
4794	function group ( $ columns , $ having = "" ) { $ this -> __destruct ( ) ; $ this -> group = $ columns ; $ this -> having = $ having ; return $ this ; }
12611	public function getChecked ( ) { if ( is_null ( $ this -> object ) || ! $ this -> object ) { return false ; } if ( is_null ( $ this -> _checked ) ) { $ this -> _checked = true ; foreach ( $ this -> object -> dependencies ( ) as $ dep ) { if ( ! $ this -> collector -> has ( $ dep , false ) ) { $ this -> _checked = false ; } } } return $ this -> _checked ; }
9622	public function getPdo ( $ connection = null ) { if ( $ connection === null ) { $ connection = $ this -> defaultConnection ; } if ( isset ( $ this -> instances [ $ connection ] ) ) { return $ this -> instances [ $ connection ] ; } $ config = $ this -> getConnectionConfig ( $ connection ) ; return $ this -> instances [ $ connection ] = $ this -> factory -> makePdo ( $ config , $ connection ) ; }
4717	public function emit ( $ event , $ parameters ) { if ( ! isset ( $ this -> callbacks [ $ event ] ) ) { return ; } if ( ! $ this -> callbacks [ $ event ] [ 0 ] ) { usort ( $ this -> callbacks [ $ event ] [ 1 ] , function ( $ A , $ B ) { if ( $ A [ 0 ] == $ B [ 0 ] ) { return 0 ; } return ( $ A [ 0 ] > $ B [ 0 ] ) ? 1 : - 1 ; } ) ; $ this -> callbacks [ $ event ] [ 0 ] = true ; } foreach ( $ this -> callbacks [ $ event ] [ 1 ] as $ item ) { call_user_func_array ( $ item [ 1 ] , $ this -> buildParameters ( $ parameters ) ) ; } }
4221	public function getAbstraction ( & $ array , $ method = null , & $ hist = array ( ) ) { if ( \ in_array ( $ array , $ hist , true ) ) { return $ this -> abstracter -> RECURSION ; } if ( self :: isCallable ( $ array ) ) { return array ( 'debug' => $ this -> abstracter -> ABSTRACTION , 'type' => 'callable' , 'values' => array ( \ get_class ( $ array [ 0 ] ) , $ array [ 1 ] ) , ) ; } $ return = array ( ) ; $ hist [ ] = $ array ; foreach ( $ array as $ k => $ v ) { if ( $ this -> abstracter -> needsAbstraction ( $ v ) ) { $ v = $ this -> abstracter -> getAbstraction ( $ array [ $ k ] , $ method , $ hist ) ; } $ return [ $ k ] = $ v ; } return $ return ; }
10778	private function create_image ( ) { $ total = $ this -> total_size ( ) ; $ sprite = imagecreatetruecolor ( $ total [ "width" ] , $ total [ "height" ] ) ; imagesavealpha ( $ sprite , true ) ; $ transparent = imagecolorallocatealpha ( $ sprite , 0 , 0 , 0 , 127 ) ; imagefill ( $ sprite , 0 , 0 , $ transparent ) ; $ top = 0 ; foreach ( $ this -> images as $ image ) { $ func = "imagecreatefrom" . $ image [ 'type' ] ; $ img = $ func ( $ image [ "path" ] ) ; imagecopy ( $ sprite , $ img , ( $ total [ "width" ] - $ image [ "width" ] ) , $ top , 0 , 0 , $ image [ "width" ] , $ image [ "height" ] ) ; $ top += $ image [ "height" ] ; } return $ sprite ; }
5706	public function shouldDisplay ( ) { return $ this -> gridFieldRequest -> record -> stagesDiffer ( 'Stage' , 'Live' ) && $ this -> gridFieldRequest -> recordIsPublished ( ) && $ this -> gridFieldRequest -> record -> canEdit ( ) ; }
12194	public function instantiate ( $ className , array $ data = [ ] ) { $ refl = new \ ReflectionClass ( $ className ) ; $ instanceArgs = [ ] ; if ( $ data ) { $ instanceArgs = $ this -> extractArguments ( $ refl -> getConstructor ( ) -> getParameters ( ) , $ data ) ; } return $ refl -> newInstanceArgs ( $ instanceArgs ) ; }
10830	public static function file ( string $ path ) : fs \ entity \ FileEntity { return ( new fs \ entity \ FileEntity ( $ path ) ) -> normalize ( ) ; }
4196	private function getAbstractionDetails ( Event $ abs ) { $ reflector = $ abs [ 'reflector' ] ; $ abs [ 'phpDoc' ] = $ this -> phpDoc -> getParsed ( $ reflector ) ; $ traversed = false ; if ( $ abs [ 'debugMethod' ] === 'table' && \ count ( $ abs [ 'hist' ] ) < 2 ) { $ obj = $ abs -> getSubject ( ) ; if ( $ obj instanceof \ Traversable && ! $ abs [ 'traverseValues' ] ) { $ traversed = true ; $ abs [ 'hist' ] [ ] = $ obj ; foreach ( $ obj as $ k => $ v ) { $ abs [ 'traverseValues' ] [ $ k ] = $ this -> abstracter -> needsAbstraction ( $ v ) ? $ this -> abstracter -> getAbstraction ( $ v , $ abs [ 'debugMethod' ] , $ abs [ 'hist' ] ) : $ v ; } } } if ( ! $ traversed ) { $ this -> addConstants ( $ abs ) ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ abs [ 'extends' ] [ ] = $ reflector -> getName ( ) ; } $ this -> addProperties ( $ abs ) ; $ this -> addMethods ( $ abs ) ; } }
360	function normalizeRequirement ( $ requirement , $ requirementKey = 0 ) { if ( ! is_array ( $ requirement ) ) { $ this -> usageError ( 'Requirement must be an array!' ) ; } if ( ! array_key_exists ( 'condition' , $ requirement ) ) { $ this -> usageError ( "Requirement '{$requirementKey}' has no condition!" ) ; } else { $ evalPrefix = 'eval:' ; if ( is_string ( $ requirement [ 'condition' ] ) && strpos ( $ requirement [ 'condition' ] , $ evalPrefix ) === 0 ) { $ expression = substr ( $ requirement [ 'condition' ] , strlen ( $ evalPrefix ) ) ; $ requirement [ 'condition' ] = $ this -> evaluateExpression ( $ expression ) ; } } if ( ! array_key_exists ( 'name' , $ requirement ) ) { $ requirement [ 'name' ] = is_numeric ( $ requirementKey ) ? 'Requirement #' . $ requirementKey : $ requirementKey ; } if ( ! array_key_exists ( 'mandatory' , $ requirement ) ) { if ( array_key_exists ( 'required' , $ requirement ) ) { $ requirement [ 'mandatory' ] = $ requirement [ 'required' ] ; } else { $ requirement [ 'mandatory' ] = false ; } } if ( ! array_key_exists ( 'by' , $ requirement ) ) { $ requirement [ 'by' ] = 'Unknown' ; } if ( ! array_key_exists ( 'memo' , $ requirement ) ) { $ requirement [ 'memo' ] = '' ; } return $ requirement ; }
4505	public function getList ( Parameters $ parameters = null ) : array { $ options = [ ] ; if ( $ parameters ) { $ options [ 'query' ] = ( array ) $ parameters -> toObject ( true ) ; if ( array_key_exists ( 'organizationUuid' , $ options [ 'query' ] ) ) { $ options [ 'query' ] [ 'organization.uuid' ] = $ options [ 'query' ] [ 'organizationUuid' ] ; unset ( $ options [ 'query' ] [ 'organizationUuid' ] ) ; } } $ objects = $ this -> execute ( 'GET' , static :: RESOURCE_LIST , $ options ) ; $ list = [ ] ; foreach ( $ objects as $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
11076	public function getHttpClient ( ) { if ( null === $ this -> httpClient ) { $ this -> httpClient = new HttpClient ( ) ; $ this -> httpClient -> setAdapter ( $ this -> getHttpAdapter ( ) ) ; } return $ this -> httpClient ; }
5182	private function fillSource ( $ source , $ photo ) : string { if ( ! empty ( $ source ) ) { return $ this -> filterUriInstance ( $ source ) ; } return ( string ) $ photo ; }
1100	protected function guardAgainstImpossibleMove ( ) { if ( ! $ this -> node -> exists ) throw new MoveNotPossibleException ( 'A new node cannot be moved.' ) ; if ( array_search ( $ this -> position , array ( 'child' , 'left' , 'right' , 'root' ) ) === FALSE ) throw new MoveNotPossibleException ( "Position should be one of ['child', 'left', 'right'] but is {$this->position}." ) ; if ( ! $ this -> promotingToRoot ( ) ) { if ( is_null ( $ this -> target ) ) { if ( $ this -> position === 'left' || $ this -> position === 'right' ) throw new MoveNotPossibleException ( "Could not resolve target node. This node cannot move any further to the {$this->position}." ) ; else throw new MoveNotPossibleException ( 'Could not resolve target node.' ) ; } if ( $ this -> node -> equals ( $ this -> target ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to itself.' ) ; if ( $ this -> target -> insideSubtree ( $ this -> node ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to a descendant of itself (inside moved tree).' ) ; if ( ! $ this -> node -> inSameScope ( $ this -> target ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to a different scope.' ) ; } }
3485	public static function resolve ( ) : SignatureGeneratorInterface { self :: addDefaultResolvers ( ) ; foreach ( self :: $ resolvers as $ resolver ) { if ( $ generator = $ resolver ( ) ) { return $ generator ; } } throw new \ LogicException ( 'Cannot resolve available JWT Signature Generator.' ) ; }
3578	protected function metaSelect ( Builder $ query , ArgumentBag $ args ) { $ columns = $ args -> get ( 'columns' ) ; foreach ( $ columns as $ key => $ column ) { list ( $ column , $ alias ) = $ this -> extractColumnAlias ( $ column ) ; if ( $ this -> hasColumn ( $ column ) ) { $ select = "{$this->getTable()}.{$column}" ; if ( $ column !== $ alias ) { $ select .= " as {$alias}" ; } $ columns [ $ key ] = $ select ; } elseif ( is_string ( $ column ) && $ column != '*' && strpos ( $ column , '.' ) === false ) { $ table = $ this -> joinMeta ( $ query , $ column ) ; $ columns [ $ key ] = "{$table}.meta_value as {$alias}" ; } } $ args -> set ( 'columns' , $ columns ) ; }
10000	public function setSoftEdgesSize ( $ size ) { if ( $ size !== null ) { $ this -> activateObject ( ) ; $ softEdges [ 'size' ] = ( string ) $ this -> getExcelPointsWidth ( $ size ) ; } }
8542	public function setPluralForm ( $ key , $ plural ) { if ( ! is_array ( $ plural ) ) $ plural = [ $ plural ] ; if ( ! $ this -> msgstr_plural ) $ this -> msgstr_plural = [ ] ; $ this -> msgstr_plural [ $ key ] = $ plural ; }
2482	protected function generateQueryString ( array $ parameters ) { $ removedArrayCharacters = preg_replace ( '/%5B[0-9]+%5D=/' , '=' , http_build_query ( $ parameters ) ) ; $ removedDuplicatedEscapingForUrlPath = str_replace ( '%5C%5C%2F' , '%5C%2F' , $ removedArrayCharacters ) ; return $ removedDuplicatedEscapingForUrlPath ; }
4762	protected function send ( $ data ) { if ( $ this -> doNotTrack ) { return ; } try { $ fp = fsockopen ( "udp://$this->host" , $ this -> port , $ errno , $ errstr ) ; if ( ! $ fp ) { return ; } fwrite ( $ fp , $ data ) ; fclose ( $ fp ) ; } catch ( \ Exception $ e ) { } }
12431	protected function generateContentTypeFilter ( $ contentType ) { $ filter = null ; if ( ! is_null ( $ contentType ) && '' != $ contentType ) { $ filter = array ( 'contentType' => $ contentType ) ; } return $ filter ; }
12089	public function destroy ( UserPolicy $ user , Response $ response ) { return $ response -> user_id == user_id ( ) && $ response -> user_type == user_type ( ) ; }
11457	public function pageSummary ( $ pageId , $ beginDate , $ endDate ) { $ params = [ 'page_id' => $ pageId , 'begin_date' => $ beginDate , 'end_date' => $ endDate , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_PAGE , $ params ] ) ; }
2	private function buildDependency10Info ( $ depArray ) { static $ dep10toOperatorMap = array ( 'has' => '==' , 'eq' => '==' , 'ge' => '>=' , 'gt' => '>' , 'le' => '<=' , 'lt' => '<' , 'not' => '!=' ) ; $ result = array ( ) ; foreach ( $ depArray as $ depItem ) { if ( empty ( $ depItem [ 'rel' ] ) || ! array_key_exists ( $ depItem [ 'rel' ] , $ dep10toOperatorMap ) ) { continue ; } $ depType = ! empty ( $ depItem [ 'optional' ] ) && 'yes' == $ depItem [ 'optional' ] ? 'optional' : 'required' ; $ depType = 'not' == $ depItem [ 'rel' ] ? 'conflicts' : $ depType ; $ depVersion = ! empty ( $ depItem [ 'version' ] ) ? $ this -> parseVersion ( $ depItem [ 'version' ] ) : '*' ; $ depVersionConstraint = ( 'has' == $ depItem [ 'rel' ] || 'not' == $ depItem [ 'rel' ] ) && '*' == $ depVersion ? '*' : $ dep10toOperatorMap [ $ depItem [ 'rel' ] ] . $ depVersion ; switch ( $ depItem [ 'type' ] ) { case 'php' : $ depChannelName = 'php' ; $ depPackageName = '' ; break ; case 'pkg' : $ depChannelName = ! empty ( $ depItem [ 'channel' ] ) ? $ depItem [ 'channel' ] : 'pear.php.net' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'ext' : $ depChannelName = 'ext' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'os' : case 'sapi' : $ depChannelName = '' ; $ depPackageName = '' ; break ; default : $ depChannelName = '' ; $ depPackageName = '' ; break ; } if ( '' != $ depChannelName ) { $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } } return $ result ; }
1195	private function getExtensions ( ) { if ( null === $ this -> sorted ) { krsort ( $ this -> extensions ) ; $ this -> sorted = ! empty ( $ this -> extensions ) ? call_user_func_array ( 'array_merge' , $ this -> extensions ) : array ( ) ; } return $ this -> sorted ; }
418	public function getCookies ( ) { if ( $ this -> _cookies === null ) { $ this -> _cookies = new CookieCollection ( $ this -> loadCookies ( ) , [ 'readOnly' => true , ] ) ; } return $ this -> _cookies ; }
3482	public function withContentAvailable ( bool $ contentAvailable ) : Aps { $ cloned = clone $ this ; $ cloned -> contentAvailable = $ contentAvailable ; return $ cloned ; }
7818	public function create ( ) : ? array { $ body = Body :: json ( [ 'name' => $ this -> name , 'event' => $ this -> event , 'device_id' => $ this -> device , 'filter_type' => '' , 'filter' => '' , 'method' => 'http' , 'action' => $ this -> url , 'secret' => $ this -> secret , ] ) ; $ response = Request :: post ( $ this -> baseUrl . 'callback' , [ ] , $ body ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
725	public function render ( $ view , $ params = [ ] ) { $ content = $ this -> getView ( ) -> render ( $ view , $ params , $ this ) ; return $ this -> renderContent ( $ content ) ; }
147	protected function processUrl ( PackageInterface $ package , $ url ) { if ( ! extension_loaded ( 'openssl' ) && 0 === strpos ( $ url , 'https:' ) ) { throw new \ RuntimeException ( 'You must enable the openssl extension to download files via https' ) ; } if ( $ package -> getDistReference ( ) ) { $ url = UrlUtil :: updateDistReference ( $ this -> config , $ url , $ package -> getDistReference ( ) ) ; } return $ url ; }
6099	protected function put ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_PUT , null , $ fireAndForget ) ; }
10780	private function addCacheLimiterHeaders ( ResponseInterface $ response ) : ResponseInterface { $ cache = new CacheUtil ( ) ; switch ( session_cache_limiter ( ) ) { case 'public' : $ response = $ cache -> withExpires ( $ response , time ( ) + session_cache_limiter ( ) * 60 ) ; $ response = $ cache -> withCacheControl ( $ response , ( new ResponseCacheControl ( ) ) -> withPublic ( ) -> withMaxAge ( session_cache_limiter ( ) * 60 ) ) ; break ; case 'private_no_expire' : $ response = $ cache -> withCacheControl ( $ response , ( new ResponseCacheControl ( ) ) -> withPrivate ( ) -> withMaxAge ( session_cache_limiter ( ) * 60 ) ) ; break ; case 'private' : $ response = $ cache -> withExpires ( $ response , 'Thu, 19 Nov 1981 08:52:00 GMT' ) ; $ response = $ cache -> withCacheControl ( $ response , ( new ResponseCacheControl ( ) ) -> withPrivate ( ) -> withMaxAge ( session_cache_limiter ( ) * 60 ) ) ; break ; case 'nocache' : $ response = $ cache -> withExpires ( $ response , 'Thu, 19 Nov 1981 08:52:00 GMT' ) ; $ response = $ cache -> withCacheControl ( $ response , ( new ResponseCacheControl ( ) ) -> withPrivate ( ) -> withCachePrevention ( ) ) ; $ response = $ response -> withHeader ( "Pragma" , "no-cache" ) ; break ; } return $ response ; }
8709	protected function qualifyColumns ( $ columns ) { foreach ( $ columns as & $ column ) { if ( ! in_array ( $ column , $ this -> model -> translatableAttributes ( ) ) ) { continue ; } $ primary = $ this -> qualifyTranslationColumn ( $ column ) ; $ fallback = $ this -> qualifyTranslationColumn ( $ column , true ) ; if ( $ this -> model -> shouldFallback ( ) ) { $ column = new Expression ( $ this -> compileIfNull ( $ primary , $ fallback , $ column ) ) ; } else { $ column = $ primary ; } } return $ columns ; }
9050	private static function checkLevel ( $ level ) { if ( $ level != LogLevel :: ALERT && $ level != LogLevel :: CRITICAL && $ level != LogLevel :: DEBUG && $ level != LogLevel :: EMERGENCY && $ level != LogLevel :: ERROR && $ level != LogLevel :: INFO && $ level != LogLevel :: NOTICE && $ level != LogLevel :: WARNING ) { throw new \ Psr \ Log \ InvalidArgumentException ( "Invalid log level provided!" ) ; } }
7096	public function get ( string $ name ) : Block { if ( isset ( $ this -> _blocks [ $ name ] ) ) return $ this -> _blocks [ $ name ] ; $ this -> _blocks [ $ name ] = new $ this -> block_class ( $ name ) ; return $ this -> _blocks [ $ name ] ; }
11662	public static function saveToString ( $ properties ) { $ xn = new \ SimpleXMLElement ( self :: XML_ROOT_OPEN . self :: XML_ROOT_CLOSE , LIBXML_NOXMLDECL ) ; foreach ( $ properties as $ key => $ value ) { $ xn -> addChild ( "entry" , htmlspecialchars ( $ value , ENT_XML1 ) ) -> addAttribute ( "key" , htmlspecialchars ( $ key , ENT_XML1 ) ) ; } return preg_replace ( '/\<\?.*\?\>/' , self :: XML_PRELUDE , $ xn -> asXML ( ) ) ; }
4337	private function getDefaultOutputAs ( ) { $ ret = 'html' ; $ interface = $ this -> debug -> utilities -> getInterface ( ) ; if ( $ interface == 'ajax' ) { $ ret = $ this -> cfg [ 'outputAsDefaultNonHtml' ] ; } elseif ( $ interface == 'http' ) { $ contentType = $ this -> debug -> utilities -> getResponseHeader ( ) ; if ( $ contentType && $ contentType !== 'text/html' ) { $ ret = $ this -> cfg [ 'outputAsDefaultNonHtml' ] ; } } else { $ ret = 'text' ; } return $ ret ; }
7885	public function getData ( $ date , $ level = null ) { if ( ! is_string ( $ level ) ) { $ level = 'all' ; } $ data = LogViewer :: data ( $ date , $ level ) ; $ paginator = new Paginator ( $ data , $ this -> perPage ) ; $ path = ( new \ ReflectionClass ( $ paginator ) ) -> getProperty ( 'path' ) ; $ path -> setAccessible ( true ) ; $ path -> setValue ( $ paginator , URL :: route ( 'logviewer.index' ) . '/' . $ date . '/' . $ level ) ; if ( count ( $ data ) > $ paginator -> perPage ( ) ) { $ log = array_slice ( $ data , $ paginator -> firstItem ( ) - 1 , $ paginator -> perPage ( ) ) ; } else { $ log = $ data ; } return View :: make ( 'logviewer::data' , compact ( 'paginator' , 'log' ) ) ; }
9216	public function actionDelete ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> isdel = 1 ; $ model -> save ( ) ; return $ this -> redirect ( [ 'index' ] ) ; }
3638	public function env ( Output $ output ) : void { $ info = [ 'OS' => \ PHP_OS , 'Php version' => \ PHP_VERSION , 'Swoole version' => \ SWOOLE_VERSION , 'Swoft version' => \ Swoft :: VERSION , 'App Name' => \ config ( 'name' , 'unknown' ) , 'Base Path' => \ BASE_PATH , ] ; Show :: aList ( $ info , 'System Environment Info' ) ; }
10571	protected function validateCache ( $ lastModified , $ etag ) { if ( isset ( $ _SERVER [ 'HTTP_IF_NONE_MATCH' ] ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getEtags ( ) , true ) ; } elseif ( isset ( $ _SERVER [ 'HTTP_IF_MODIFIED_SINCE' ] ) ) { return $ lastModified !== null && @ strtotime ( $ _SERVER [ 'HTTP_IF_MODIFIED_SINCE' ] ) >= $ lastModified ; } else { return $ etag === null && $ lastModified === null ; } }
10317	function getUniqueBouncesCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeAnonymousBounces = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousBounces ) ) $ params [ 'exclude_anonymous_bounces' ] = ( $ excludeAnonymousBounces == true ) ? "true" : "false" ; return $ this -> get ( 'reports/bounces/unique/count' , $ params ) ; }
292	public function hasAttribute ( $ name ) { return isset ( $ this -> _attributes [ $ name ] ) || in_array ( $ name , $ this -> attributes ( ) , true ) ; }
9166	public function getValidationStatus ( $ action = '' ) { $ validation_status = null ; if ( isset ( $ _SESSION [ 'prototyper_validation' ] [ $ action ] ) ) { $ validation_status = $ _SESSION [ 'prototyper_validation' ] [ $ action ] ; } return $ validation_status ; }
10080	public static function getCurrencyCode ( ) { if ( ! empty ( self :: $ currencyCode ) ) { return self :: $ currencyCode ; } self :: $ currencyCode = '$' ; $ localeconv = localeconv ( ) ; if ( ! empty ( $ localeconv [ 'currency_symbol' ] ) ) { self :: $ currencyCode = $ localeconv [ 'currency_symbol' ] ; return self :: $ currencyCode ; } if ( ! empty ( $ localeconv [ 'int_curr_symbol' ] ) ) { self :: $ currencyCode = $ localeconv [ 'int_curr_symbol' ] ; return self :: $ currencyCode ; } return self :: $ currencyCode ; }
4752	public function send ( ) { $ optInValue = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'c_oegdproptin' ) ; if ( $ this -> isOptInValidationRequired ( ) && ! $ optInValue ) { \ OxidEsales \ Eshop \ Core \ Registry :: get ( \ OxidEsales \ Eshop \ Core \ UtilsView :: class ) -> addErrorToDisplay ( 'OEGDPROPTIN_CONTACT_FORM_ERROR_MESSAGE' ) ; $ this -> optInError = true ; return false ; } return parent :: send ( ) ; }
10530	public function toJson ( $ prettyPrint = false ) { $ options = 0 ; if ( $ prettyPrint ) { $ options += JSON_PRETTY_PRINT ; } return json_encode ( $ this -> items , $ options ) ; }
9642	public function resolve ( $ path ) { $ paths = [ ] ; foreach ( $ this -> paths as $ configuredPath ) { $ paths [ ] = $ configuredPath . '/' . $ path ; } $ parts = explode ( '/' , $ path ) ; if ( count ( $ parts ) == 1 ) { return $ paths ; } $ current = '' ; $ mountPaths = [ ] ; foreach ( $ parts as $ part ) { if ( $ current ) { $ current .= '/' . $ part ; } else { $ current = $ part ; } if ( isset ( $ this -> mounts [ $ current ] ) ) { foreach ( $ this -> mounts [ $ current ] as $ mount ) { $ relativePath = str_replace ( $ current , '' , $ path ) ; $ mountPaths [ ] = $ mount . $ relativePath ; } } } return array_merge ( $ mountPaths , $ paths ) ; }
1719	public function getNewsArchives ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> news ) ) { return array ( ) ; } $ arrArchives = array ( ) ; $ objArchives = $ this -> Database -> execute ( "SELECT id, title FROM tl_news_archive ORDER BY title" ) ; while ( $ objArchives -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objArchives -> id , 'news' ) ) { $ arrArchives [ $ objArchives -> id ] = $ objArchives -> title ; } } return $ arrArchives ; }
6590	public function put ( $ url , $ data = null , $ len = null , $ method = "PUT" ) { return $ this -> request ( [ CURLOPT_PUT => true , CURLOPT_CUSTOMREQUEST => $ method ? : "PUT" , CURLOPT_URL => "$url" , CURLOPT_INFILE => $ data , CURLOPT_INFILESIZE => $ len , ] ) ; }
7619	public function setPermissionSet ( $ value = array ( ) ) { foreach ( $ value as $ url ) { if ( strpos ( $ url , $ this -> accountName ) === false ) { throw new Exception ( 'The permission set can only contain URLs for the account name specified in the Credentials_SharedAccessSignature instance.' ) ; } } $ this -> permissionSet = $ value ; }
11109	public function getExtensions ( Container $ app ) { $ directories = $ this -> findExtensionsDirectories ( $ app ) ; foreach ( $ directories as $ directory ) { $ extensionName = $ directory -> getRelativePathname ( ) ; $ this -> extensions [ $ extensionName ] [ 'name' ] = $ extensionName ; $ this -> extensions [ $ extensionName ] [ 'pathName' ] = $ directory -> getPathName ( ) ; } return $ this -> extensions ; }
864	private function registerFoundToken ( $ token ) { $ tokenKind = $ token instanceof Token ? ( $ token -> isArray ( ) ? $ token -> getId ( ) : $ token -> getContent ( ) ) : ( \ is_array ( $ token ) ? $ token [ 0 ] : $ token ) ; if ( ! isset ( $ this -> foundTokenKinds [ $ tokenKind ] ) ) { $ this -> foundTokenKinds [ $ tokenKind ] = 0 ; } ++ $ this -> foundTokenKinds [ $ tokenKind ] ; }
5898	public function retrieveVideoTemplate ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/videos/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new VideoTemplate ( $ result ) ; return $ result ; }
2066	public function getPageTypes ( Contao \ DataContainer $ dc ) { $ arrOptions = array ( ) ; foreach ( array_keys ( $ GLOBALS [ 'TL_PTY' ] ) as $ pty ) { if ( $ pty == 'root' && $ dc -> activeRecord && $ dc -> activeRecord -> pid > 0 ) { continue ; } if ( $ pty == $ dc -> value || $ this -> User -> hasAccess ( $ pty , 'alpty' ) ) { $ arrOptions [ ] = $ pty ; } } return $ arrOptions ; }
6652	public function addExtraData ( array $ extraData = [ ] ) { foreach ( $ extraData as $ key => $ data ) { $ this -> extraData [ $ key ] = $ data ; } }
11952	protected function substituteSQLOperationPlaceholders ( $ sqloperation ) { $ sql_value = $ sqloperation -> toSQLString ( ) ; if ( count ( $ sqloperation -> getPlaceholderValues ( ) ) > 0 ) { $ startpos = 0 ; $ sql_value_replaced = '' ; foreach ( $ sqloperation -> getPlaceholderValues ( ) as $ avalue ) { $ qpos = strpos ( $ sql_value , '?' , $ startpos ) ; $ sql_value_replaced .= substr ( $ sql_value , $ startpos , $ qpos ) ; $ sql_value_replaced .= $ this -> db -> Quote ( $ avalue ) ; $ startpos = $ qpos + 1 ; } $ sql_value_replaced .= substr ( $ sql_value , $ startpos ) ; $ sql_value = $ sql_value_replaced ; } return $ sql_value ; }
12338	public function changeSecurityQuestionAction ( ) { if ( ! $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getLoginRoute ( ) ) ; } $ url = $ this -> url ( ) -> fromRoute ( null , [ 'action' => 'change-security-question' ] ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getChangeSecurityQuestionForm ( ) ; $ form -> setObject ( $ this -> cmsAuthentication ( ) -> getIdentity ( ) ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post ) { $ identity = $ this -> getUserService ( ) -> changeSecurityQuestion ( $ post ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/index/change-security-question-success' ) ; return $ viewModel ; } } return new ViewModel ( compact ( 'form' ) ) ; }
8020	public function set ( string $ content ) { $ parsed = $ this -> parseContent ( $ content ) ; $ this -> id = $ parsed -> id ; $ this -> infoUri = $ parsed -> infoUri ; $ this -> partialCancelUri = $ parsed -> partialCancelUri ?? null ; $ this -> nextUri = $ parsed -> nextUri ?? null ; $ this -> columns = [ ] ; if ( isset ( $ parsed -> columns ) ) { $ this -> columnTransfer ( $ parsed -> columns ) ; } $ this -> data = $ parsed -> data ?? [ ] ; $ this -> stats = isset ( $ parsed -> stats ) ? $ this -> statsTransfer ( $ parsed -> stats ) : null ; $ this -> error = isset ( $ parsed -> error ) ? $ this -> errorTransfer ( $ parsed -> error ) : null ; }
8758	public function tick ( $ status = Tick :: SUCCESS , $ msg = null , array $ extraInfo = [ ] , $ incrementBy = 1 ) { if ( ! $ this -> isRunning ( ) ) { $ this -> start ( ) ; } $ tick = new Tick ( $ this , $ status , $ msg , $ extraInfo , $ incrementBy ) ; if ( array_key_exists ( $ tick -> getStatus ( ) , $ this -> numProcessedItems ) ) { $ this -> numProcessedItems [ $ tick -> getStatus ( ) ] += $ tick -> getIncrementBy ( ) ; } else { $ this -> numProcessedItems [ $ tick -> getStatus ( ) ] = $ tick -> getIncrementBy ( ) ; } $ this -> dispatcher -> dispatch ( Events :: TRACKER_TICK , $ tick ) ; $ this -> lastTick = $ tick ; return $ tick -> getReport ( ) ; }
887	private function needFixing ( Tokens $ tokens , $ index ) { if ( $ this -> isStrictOrNullableReturnTypeFunction ( $ tokens , $ index ) ) { return false ; } $ content = '' ; while ( ! $ tokens [ $ index ] -> equals ( ';' ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ content .= $ tokens [ $ index ] -> getContent ( ) ; } $ content = ltrim ( $ content , '(' ) ; $ content = rtrim ( $ content , ');' ) ; return 'null' === strtolower ( $ content ) ; }
1633	protected function fireLogEvent ( $ level , $ message , array $ context = [ ] ) { if ( ! isset ( $ this -> dispatcher ) ) { return ; } if ( class_exists ( MessageLogged :: class ) ) { $ this -> dispatcher -> dispatch ( new MessageLogged ( $ level , $ message , $ context ) ) ; } else { $ this -> dispatcher -> fire ( 'illuminate.log' , compact ( 'level' , 'message' , 'context' ) ) ; } }
7190	private function copyAttachment ( Model \ SaleAttachmentInterface $ source , Model \ SaleAttachmentInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'path' , 'title' , 'type' , 'size' , 'internal' , 'createdAt' , 'updatedAt' , ] ) ; }
726	public function getAttribute ( $ attribute ) { try { return parent :: getAttribute ( $ attribute ) ; } catch ( \ PDOException $ e ) { switch ( $ attribute ) { case self :: ATTR_SERVER_VERSION : return $ this -> query ( "SELECT CAST(SERVERPROPERTY('productversion') AS VARCHAR)" ) -> fetchColumn ( ) ; default : throw $ e ; } } }
2128	public function endblock ( ) { if ( empty ( $ this -> arrBlockNames ) ) { throw new \ Exception ( 'You must start a block before you can end it' ) ; } $ name = array_pop ( $ this -> arrBlockNames ) ; if ( $ this -> strParent === null ) { if ( $ this -> arrBlocks [ $ name ] != '[[TL_PARENT]]' ) { if ( strpos ( $ this -> arrBlocks [ $ name ] , '[[TL_PARENT]]' ) !== false ) { list ( , $ content ) = explode ( '[[TL_PARENT]]' , $ this -> arrBlocks [ $ name ] , 2 ) ; echo $ content ; } else { ob_end_clean ( ) ; -- $ this -> intBufferLevel ; } } } else { $ this -> arrBlocks [ $ name ] [ ] = ob_get_clean ( ) ; ob_start ( ) ; } }
433	public function setModules ( $ modules ) { foreach ( $ modules as $ id => $ module ) { $ this -> _modules [ $ id ] = $ module ; } }
5700	protected function getDefaultButtonList ( $ config ) { $ new = ( $ this -> owner -> ID == 0 ) ; $ list = $ new ? Config :: inst ( ) -> get ( $ config , $ this -> checkVersioned ( ) ? "versioned_create" : "create" ) : Config :: inst ( ) -> get ( $ config , $ this -> checkVersioned ( ) ? "versioned_edit" : "edit" ) ; return $ list ? : array ( ) ; }
9011	public function tinytext ( string $ charset = null ) : self { $ this -> type = 'tinytext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
7215	protected function fixDefault ( TaxGroupInterface $ taxGroup ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ taxGroup , [ 'default' ] ) ) { return ; } if ( $ taxGroup -> isDefault ( ) ) { try { $ previousTaxGroup = $ this -> taxGroupRepository -> findDefault ( ) ; } catch ( RuntimeException $ e ) { return ; } if ( null === $ previousTaxGroup || $ previousTaxGroup === $ taxGroup ) { return ; } $ previousTaxGroup -> setDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ previousTaxGroup , false ) ; } }
5910	public function createSetting ( $ key , $ value ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'key' => $ key , 'value' => $ value ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/settings' , $ parameters ) ; return $ result ; }
3028	public function setConsumer ( $ key , $ secret ) { $ this -> consumer = new \ Eher \ OAuth \ Consumer ( $ key , $ secret ) ; }
5074	public function outputSetFormat ( $ sFormat ) { if ( static :: isValidFormat ( $ sFormat ) ) { $ this -> sOutputFormat = strtoupper ( $ sFormat ) ; return true ; } return false ; }
6334	private function attachHandlers ( $ parser ) { $ onElementStart = \ Closure :: bind ( function ( $ parser , $ name , $ attributes ) { $ name = $ this -> normalize ( $ name ) ; $ this -> currentElement = $ name ; $ this -> dataBuffer = null ; $ this -> stackSize ++ ; $ this -> onElementStart ( $ parser , $ name , $ attributes ) ; } , $ this ) ; $ onElementEnd = \ Closure :: bind ( function ( $ parser , $ name ) { $ name = $ this -> normalize ( $ name ) ; $ this -> currentElement = null ; $ this -> stackSize -- ; if ( null !== $ this -> dataBuffer ) { $ this -> onElementData ( $ parser , $ this -> dataBuffer ) ; } $ this -> dataBuffer = null ; $ this -> onElementEnd ( $ parser , $ name ) ; } , $ this ) ; $ onElementData = \ Closure :: bind ( function ( $ parser , $ data ) { $ this -> dataBuffer .= $ data ; } , $ this ) ; $ onNamespaceDeclarationStart = \ Closure :: bind ( function ( $ parser , $ prefix , $ uri ) { $ this -> namespaces [ $ prefix ] = rtrim ( $ uri , '/' ) ; $ this -> onNamespaceDeclarationStart ( $ parser , $ prefix , $ uri ) ; } , $ this ) ; $ onNamespaceDeclarationEnd = \ Closure :: bind ( function ( $ parser , $ prefix ) { $ this -> onNamespaceDeclarationEnd ( $ parser , $ prefix ) ; } , $ this ) ; xml_set_element_handler ( $ parser , $ onElementStart , $ onElementEnd ) ; xml_set_character_data_handler ( $ parser , $ onElementData ) ; xml_set_start_namespace_decl_handler ( $ parser , $ onNamespaceDeclarationStart ) ; xml_set_end_namespace_decl_handler ( $ parser , $ onNamespaceDeclarationEnd ) ; return $ this ; }
10529	protected function normalizeProxyHeader ( $ header ) { $ header = strtoupper ( $ header ) ; $ header = str_replace ( '-' , '_' , $ header ) ; if ( 0 !== strpos ( $ header , 'HTTP_' ) ) { $ header = 'HTTP_' . $ header ; } return $ header ; }
604	protected function substring ( $ length , $ caseSensitive = true , $ offset = null ) { if ( $ offset === null ) { $ offset = $ this -> offset ; } if ( $ offset + $ length > $ this -> length ) { return '' ; } $ cacheKey = $ offset . ',' . $ length ; if ( ! isset ( $ this -> _substrings [ $ cacheKey . ',1' ] ) ) { $ this -> _substrings [ $ cacheKey . ',1' ] = mb_substr ( $ this -> sql , $ offset , $ length , 'UTF-8' ) ; } if ( ! $ caseSensitive && ! isset ( $ this -> _substrings [ $ cacheKey . ',0' ] ) ) { $ this -> _substrings [ $ cacheKey . ',0' ] = mb_strtoupper ( $ this -> _substrings [ $ cacheKey . ',1' ] , 'UTF-8' ) ; } return $ this -> _substrings [ $ cacheKey . ',' . ( int ) $ caseSensitive ] ; }
4572	public function setIdentityUuid ( ? string $ identityUuid ) { if ( null !== $ identityUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ identityUuid ) ) { throw new InvalidArgumentException ( 'Identity uuid is not valid.' ) ; } } $ this -> identityUuid = $ identityUuid ; return $ this ; }
9227	public function post ( $ path , $ data = array ( ) , $ headers = array ( ) ) { return $ this -> postprocessResponse ( parent :: post ( $ path , $ this -> preprocessData ( $ data ) , $ headers ) ) ; }
5938	public function addFunctionality ( $ item ) { if ( ! ( $ item instanceof Functionality ) ) { if ( is_array ( $ item ) ) { try { $ item = new Functionality ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Functionality. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Functionality"!' , E_USER_WARNING ) ; } } $ this -> functionalities [ ] = $ item ; return $ this ; }
783	public function actionReport ( $ sourcePath , $ translationPath , $ title = 'Translation report' ) { $ sourcePath = trim ( $ sourcePath , '/\\' ) ; $ translationPath = trim ( $ translationPath , '/\\' ) ; $ results = [ ] ; $ dir = new DirectoryIterator ( $ sourcePath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ sourceFilePath = $ sourcePath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( $ translatedFilePath ) ; $ diff = empty ( $ errors ) ? $ this -> getDiff ( $ translatedFilePath , $ sourceFilePath ) : '' ; if ( ! empty ( $ diff ) ) { $ errors [ ] = 'Translation outdated.' ; } $ result = [ 'errors' => $ errors , 'diff' => $ diff , ] ; $ results [ $ fileinfo -> getFilename ( ) ] = $ result ; } } $ dir = new DirectoryIterator ( $ translationPath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( null , $ translatedFilePath ) ; if ( ! empty ( $ errors ) ) { $ results [ $ fileinfo -> getFilename ( ) ] [ 'errors' ] = $ errors ; } } } echo $ this -> renderFile ( __DIR__ . '/views/translation/report_html.php' , [ 'results' => $ results , 'sourcePath' => $ sourcePath , 'translationPath' => $ translationPath , 'title' => $ title , ] ) ; }
5668	public function describeDifference ( $ first , $ second , $ identical = false ) { if ( $ identical ) { if ( ! $ this -> isTypeMatch ( $ first , $ second ) ) { return sprintf ( 'with type mismatch as [%s] does not match [%s]' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) ) ; } } $ type = $ this -> getType ( $ first ) ; if ( $ type === 'Unknown' ) { return 'with unknown type' ; } $ method = 'describe' . $ type . 'Difference' ; return $ this -> $ method ( $ first , $ second , $ identical ) ; }
2678	public function updateAclItem ( $ aclId , $ aclItemId , $ itemValue , $ negated , $ comment = '' , $ subnet = false ) { $ body = [ 'ip' => $ itemValue , 'negated' => $ negated , 'comment' => $ comment ] ; if ( $ subnet ) { $ body [ 'subnet' ] = $ subnet ; } $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry/' . $ aclItemId ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PATCH , json_encode ( $ body ) ) ; return $ result ; }
2898	public function queryEnd ( $ queryId ) { $ result = $ this -> parentQueryEnd ( $ queryId ) ; if ( $ this -> captureStacktraces ) { $ this -> stackTraces [ $ queryId ] = $ this -> getStackTrace ( ) ; } return $ result ; }
6873	protected function buildItem ( SaleItemInterface $ saleItem , ShipmentInterface $ shipment ) { if ( $ saleItem -> isCompound ( ) ) { $ available = $ expected = null ; foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { if ( null !== $ child = $ this -> buildItem ( $ childSaleItem , $ shipment ) ) { $ saleItemQty = $ childSaleItem -> getQuantity ( ) ; $ e = $ child -> getExpected ( ) / $ saleItemQty ; if ( null === $ expected || $ expected > $ e ) { $ expected = $ e ; } $ a = $ child -> getAvailable ( ) / $ saleItemQty ; if ( null === $ available || $ available > $ a ) { $ available = $ a ; } } } if ( 0 < $ expected ) { return $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected , $ available ) ; } return null ; } $ item = null ; if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ expected = $ shipment -> isReturn ( ) ? $ this -> calculator -> calculateReturnableQuantity ( $ saleItem , $ shipment ) : $ this -> calculator -> calculateShippableQuantity ( $ saleItem , $ shipment ) ; if ( 0 < $ expected ) { $ item = $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected ) ; } } if ( $ saleItem -> hasChildren ( ) ) { foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { $ this -> buildItem ( $ childSaleItem , $ shipment ) ; } } return $ item ; }
10135	public function processBitmapGd ( $ image ) { $ width = imagesx ( $ image ) ; $ height = imagesy ( $ image ) ; $ data = pack ( 'Vvvvv' , 0x000c , $ width , $ height , 0x01 , 0x18 ) ; for ( $ j = $ height ; -- $ j ; ) { for ( $ i = 0 ; $ i < $ width ; ++ $ i ) { $ color = imagecolorsforindex ( $ image , imagecolorat ( $ image , $ i , $ j ) ) ; foreach ( [ 'red' , 'green' , 'blue' ] as $ key ) { $ color [ $ key ] = $ color [ $ key ] + round ( ( 255 - $ color [ $ key ] ) * $ color [ 'alpha' ] / 127 ) ; } $ data .= chr ( $ color [ 'blue' ] ) . chr ( $ color [ 'green' ] ) . chr ( $ color [ 'red' ] ) ; } if ( 3 * $ width % 4 ) { $ data .= str_repeat ( "\x00" , 4 - 3 * $ width % 4 ) ; } } return [ $ width , $ height , strlen ( $ data ) , $ data ] ; }
1193	private function addCustomElements ( array $ elements , HTMLPurifier_HTMLDefinition $ definition ) { foreach ( $ elements as $ element ) { $ name = $ element [ 0 ] ; $ contentSet = $ element [ 1 ] ; $ allowedChildren = $ element [ 2 ] ; $ attributeCollection = $ element [ 3 ] ; $ attributes = isset ( $ element [ 4 ] ) ? $ element [ 4 ] : null ; if ( ! empty ( $ attributes ) ) { $ definition -> addElement ( $ name , $ contentSet , $ allowedChildren , $ attributeCollection , $ attributes ) ; } else { $ definition -> addElement ( $ name , $ contentSet , $ allowedChildren , $ attributeCollection ) ; } } }
7446	public function updateAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } $ form = $ this -> createForm ( GroupType :: class , $ group ) ; $ form -> bindRequest ( $ this -> getRequest ( ) ) ; if ( $ form -> isValid ( ) ) { $ em -> persist ( $ group ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_group_show' , array ( 'id' => $ id ) ) ) ; } return array ( 'group' => $ group , 'form' => $ form -> createView ( ) , ) ; }
2465	public function checkPermission ( ) { $ bundles = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( ! isset ( $ bundles [ 'ContaoCommentsBundle' ] ) ) { $ key = array_search ( 'allowComments' , $ GLOBALS [ 'TL_DCA' ] [ 'tl_faq' ] [ 'list' ] [ 'sorting' ] [ 'headerFields' ] ) ; unset ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_faq' ] [ 'list' ] [ 'sorting' ] [ 'headerFields' ] [ $ key ] ) ; } }
7811	private static function filterArray ( $ needle , $ heystack , $ always = array ( ) ) { foreach ( $ heystack as $ k => $ v ) { if ( ! in_array ( $ v , $ needle ) && ! in_array ( $ v , $ always ) ) unset ( $ heystack [ $ k ] ) ; } return $ heystack ; }
12269	protected function generateEventNames ( $ baseEventName , Page $ page ) { $ pageName = $ page -> getPageName ( ) ; $ language = $ page -> getCurrentLanguage ( ) ; return array ( $ baseEventName , $ baseEventName . '.' . $ language , $ baseEventName . '.' . $ pageName , $ baseEventName . '.' . $ language . '.' . $ pageName , ) ; }
12639	protected function rethrowExceptions ( callable $ callable ) { try { return $ callable ( ) ; } catch ( ImplementationNotFoundException $ ex ) { throw new ImplementationNotFoundException ( $ ex -> getMessage ( ) ) ; } catch ( TypeMismatchException $ ex ) { throw new TypeMismatchException ( $ ex -> getMessage ( ) ) ; } catch ( UnresolveableArgumentException $ ex ) { throw new UnresolveableArgumentException ( $ ex -> getMessage ( ) ) ; } catch ( ValueNotFoundException $ ex ) { throw new ValueNotFoundException ( $ ex -> getMessage ( ) ) ; } catch ( InvalidCallableFormatException $ ex ) { throw new InvalidCallableFormatException ( $ ex -> getMessage ( ) ) ; } catch ( MissingDefinitionIdentifierException $ ex ) { throw new MissingDefinitionIdentifierException ( $ ex -> getMessage ( ) ) ; } catch ( MissingDefinitionValueException $ ex ) { throw new MissingDefinitionValueException ( $ ex -> getMessage ( ) ) ; } catch ( ClassNotFoundException $ ex ) { throw new ClassNotFoundException ( $ ex -> getMessage ( ) ) ; } }
9376	protected function check ( array $ files , $ path , $ source , $ template ) { $ file = null ; foreach ( ( array ) $ files as $ key => $ value ) { $ filepath = ( string ) str_replace ( $ path , $ source , $ value ) ; $ filepath = str_replace ( '\\' , '/' , ( string ) $ filepath ) ; $ filepath = ( string ) preg_replace ( '/^\d\//i' , '' , $ filepath ) ; $ exists = ( string ) $ filepath === $ template ; $ lowercase = strtolower ( $ filepath ) === $ template ; ( $ exists || $ lowercase ) && $ file = $ value ; } return $ file ; }
10781	public function assetFunction ( $ asset , $ serverPath = false ) { $ request = isset ( $ this -> container [ 'request' ] ) ? $ this -> container [ 'request' ] : null ; $ path = \ ltrim ( $ asset , '/\\' ) ; $ assetPath = Utils :: fixPath ( $ this -> container -> getRootDir ( ) . '/' . $ path ) ; if ( ! $ serverPath ) if ( $ request instanceof Request ) $ assetPath = $ request -> getSchemeAndHttpHost ( ) . '/' . $ path ; else $ assetPath = '/' . $ path ; return $ assetPath ; }
366	public function renderTableFooter ( ) { $ cells = [ ] ; foreach ( $ this -> columns as $ column ) { $ cells [ ] = $ column -> renderFooterCell ( ) ; } $ content = Html :: tag ( 'tr' , implode ( '' , $ cells ) , $ this -> footerRowOptions ) ; if ( $ this -> filterPosition === self :: FILTER_POS_FOOTER ) { $ content .= $ this -> renderFilters ( ) ; } return "<tfoot>\n" . $ content . "\n</tfoot>" ; }
10028	function getContactsByExternalId ( $ externalId , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/externalid/' . utf8_encode ( $ externalId ) , $ queryParameters ) ; }
12464	public function showAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ entity = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> find ( $ id ) ; if ( ! $ entity ) { throw $ this -> createNotFoundException ( 'Unable to find CustomFieldsGroup entity.' ) ; } $ options = $ this -> getOptionsAvailable ( $ entity -> getEntity ( ) ) ; return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:show.html.twig' , array ( 'entity' => $ entity , 'create_field_form' => $ this -> createCreateFieldForm ( $ entity ) -> createView ( ) , 'options' => $ options ) ) ; }
12776	protected function write ( $ namespace , array $ data ) { $ file = $ this -> adapter -> getFileName ( $ namespace ) ; $ contents = $ this -> adapter -> prepareForWriting ( $ data ) ; if ( ! $ this -> fileSystem -> has ( $ file ) ) { $ this -> fileSystem -> write ( $ file , $ contents ) ; } $ this -> fileSystem -> update ( $ file , $ contents ) ; }
8243	public function loginAttempt ( $ username , Password $ password ) { $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ encoder = $ this -> getPasswordEncoder ( $ userData ) ; $ dummy = bin2hex ( \ random_bytes ( 32 ) ) ; $ dummyHash = $ encoder -> encode ( $ dummy ) ; if ( ! $ userData ) { $ encoder -> isValid ( $ dummyHash , $ password ) ; return false ; } return $ encoder -> isValid ( $ userData [ 'pwhash' ] , $ password -> get ( ) ) ; }
2568	protected function checkAllIntegers ( ) { $ foundNonInt = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( ! is_int ( $ arg ) ) { $ foundNonInt = true ; break ; } } return ! $ foundNonInt ; }
8563	private function _convertCreateShipment ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CreateShipment' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentRequestDetails ( ) ) { $ ShipmentRequestDetailsCreateShipmentRequest = $ request -> getShipmentRequestDetails ( ) ; foreach ( $ ShipmentRequestDetailsCreateShipmentRequest -> getAmazonOrderId ( ) as $ AmazonOrderIdShipmentRequestDetailsIndex => $ AmazonOrderIdShipmentRequestDetails ) { $ parameters [ 'ShipmentRequestDetails' . '.' . 'AmazonOrderId' . '.' . ( $ AmazonOrderIdShipmentRequestDetailsIndex + 1 ) ] = $ AmazonOrderIdShipmentRequestDetails ; } } if ( $ request -> isSetShippingServiceId ( ) ) { $ parameters [ 'ShippingServiceId' ] = $ request -> getShippingServiceId ( ) ; } if ( $ request -> isSetShippingServiceOfferId ( ) ) { $ parameters [ 'ShippingServiceOfferId' ] = $ request -> getShippingServiceOfferId ( ) ; } return $ parameters ; }
1273	public function isAmbiguous ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { throw new \ BadMethodCallException ( __METHOD__ . ' should not be called on Address Classification only requests.' ) ; } return isset ( $ this -> response -> AmbiguousAddressIndicator ) ; }
5662	private function mergeAttribute ( $ attributes , $ raw ) { $ parts = explode ( '=' , $ raw ) ; list ( $ name , $ value ) = count ( $ parts ) === 1 ? array ( $ parts [ 0 ] , $ parts [ 0 ] ) : $ parts ; $ attributes [ trim ( $ name ) ] = html_entity_decode ( $ this -> dequote ( trim ( $ value ) ) , ENT_QUOTES ) ; return $ attributes ; }
12723	public function getContent ( ) { if ( ! isset ( $ this -> _content ) ) { $ this -> _content = $ this -> sourceFile -> readLine ( $ this -> lineNumber ) ; } return $ this -> _content ; }
1394	public function withMediaType ( string $ mediaType ) : self { if ( ! $ encoding = $ this -> api -> getEncodings ( ) -> find ( $ mediaType ) ) { throw new \ InvalidArgumentException ( "Media type {$mediaType} is not valid for API {$this->api->getName()}." ) ; } $ codec = $ this -> factory -> createCodec ( $ this -> api -> getContainer ( ) , $ encoding , null ) ; return $ this -> withCodec ( $ codec ) ; }
10731	public function getMinute ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'minute' ] ; } }
3178	public function getItemClasses ( ) { $ itemClass = $ this -> getClass ( self :: ITEM_ROOT_CLASS_URI ) ; return $ this -> getResourceService ( ) -> getAllClasses ( $ itemClass ) ; }
9401	public function setHttp ( ServerRequestInterface $ request , ResponseInterface $ response ) { $ this -> set ( 'Psr\Http\Message\ServerRequestInterface' , $ request ) ; return $ this -> set ( 'Psr\Http\Message\ResponseInterface' , $ response ) ; }
10724	public function getNumRows ( ) { $ builtSql = SqlBuilder :: buildRowCountSql ( $ this ) ; if ( is_array ( $ builtSql ) ) { $ preparedSth = $ this -> connect ( ) -> prepare ( $ builtSql [ 0 ] ) ; $ boundSth = StatementBuilder :: bindValues ( $ preparedSth , $ builtSql [ 1 ] ) ; $ boundSth -> execute ( ) ; } else { $ boundSth = $ this -> connect ( ) -> query ( $ builtSql ) ; } $ result = $ boundSth -> fetch ( PDO :: FETCH_ASSOC ) ; return ( int ) $ result [ 'total_count' ] ; }
12447	static function run_build_dependencies ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; $ current = $ opts [ 'extension' ] [ 'name' ] ; foreach ( $ opts [ 'dependencies' ] [ 'extensions' ] as $ ext => $ source ) { if ( $ ext != $ current ) { foreach ( $ source as $ type => $ def ) { break ; } $ tempconf = array ( 'extension' => array ( 'name' => $ ext ) , 'version' => array ( 'major' => 0 , 'minor' => 0 , 'release' => 0 ) , $ type => $ def ) ; $ tempconffile = self :: getOptionsDir ( ) . "/options-tmp_$ext.yaml" ; pakeYaml :: emitfile ( $ tempconf , $ tempconffile ) ; $ task = pakeTask :: get ( 'init' ) ; $ task -> execute ( array ( "tmp_$ext" ) , array_merge ( $ cliopts , array ( 'skip-init' => false , 'skip-init-fetch' => false , 'skip-init-clean' => true ) ) ) ; if ( is_file ( self :: getBuildDir ( $ opts ) . "/$ext/pake/options-$ext.yaml" ) ) { pake_copy ( self :: getBuildDir ( $ opts ) . "/$ext/pake/options-$ext.yaml" , self :: getOptionsDir ( ) . "/options-$ext.yaml" ) ; } else { throw new pakeException ( "Missing pake/options.yaml extension in dependent extension $ext" ) ; } $ task -> execute ( array ( "tmp_$ext" ) , array_merge ( $ cliopts , array ( 'skip-init' => false , 'skip-init-fetch' => true , 'skip-init-clean' => false ) ) ) ; pake_remove ( $ tempconffile , '' ) ; $ task = pakeTask :: get ( 'build' ) ; foreach ( $ task -> get_prerequisites ( ) as $ pretask ) { $ pretask = pakeTask :: get ( $ pretask ) ; $ pretask -> execute ( array ( $ ext ) , array_merge ( $ opts , array ( 'skip-init' => true ) ) ) ; } $ task -> execute ( array ( $ ext ) , array_merge ( $ opts , array ( 'skip-init' => true ) ) ) ; } } }
994	private function getDescription ( $ node ) { if ( $ node -> description ) { return $ node -> description -> value ; } if ( isset ( $ this -> options [ 'commentDescriptions' ] ) ) { $ rawValue = $ this -> getLeadingCommentBlock ( $ node ) ; if ( $ rawValue !== null ) { return BlockString :: value ( "\n" . $ rawValue ) ; } } return null ; }
4255	protected function buildFatal ( ) { $ haveFatal = isset ( $ this -> stats [ 'counts' ] [ 'fatal' ] ) ; if ( ! $ haveFatal ) { return '' ; } $ lastError = $ this -> errorHandler -> get ( 'lastError' ) ; $ isHtml = $ lastError [ 'isHtml' ] ; $ backtrace = $ lastError [ 'backtrace' ] ; $ html = '<h3>Fatal Error</h3>' ; $ html .= '<ul class="list-unstyled indent">' ; if ( \ count ( $ backtrace ) > 1 ) { $ table = $ this -> outputHtml -> buildTable ( $ backtrace , array ( 'attribs' => 'trace table-bordered' , 'caption' => 'trace' , 'columns' => array ( 'file' , 'line' , 'function' ) , ) ) ; $ html .= '<li>' . $ lastError [ 'message' ] . '</li>' ; $ html .= '<li>' . $ table . '</li>' ; if ( ! $ isHtml ) { $ html = \ str_replace ( $ lastError [ 'message' ] , \ htmlspecialchars ( $ lastError [ 'message' ] ) , $ html ) ; } } else { $ keysKeep = array ( 'typeStr' , 'message' , 'file' , 'line' ) ; $ lastError = \ array_intersect_key ( $ lastError , \ array_flip ( $ keysKeep ) ) ; $ html .= '<li>' . $ this -> outputHtml -> dump ( $ lastError ) . '</li>' ; if ( $ isHtml ) { $ html = \ str_replace ( \ htmlspecialchars ( $ lastError [ 'message' ] ) , $ lastError [ 'message' ] , $ html ) ; } } if ( ! \ extension_loaded ( 'xdebug' ) ) { $ html .= '<li>Want to see a backtrace here? Install <a target="_blank" href="https://xdebug.org/docs/install">xdebug</a> PHP extension.</li>' ; } $ html .= '</ul>' ; return $ html ; }
11754	public function lists ( $ msgId , $ index , $ begin , $ count , $ type = 0 ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'begin' => $ begin , 'count' => $ count , 'type' => $ type , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_LIST_COMMENT , $ params ] ) ; }
9250	public function boot ( ) { if ( $ this -> booted ) { return ; } $ this -> container = $ this -> initializeContainer ( ) ; $ this -> kernel = $ this -> container -> get ( 'http_kernel' ) ; $ this -> booted = true ; }
1207	public function moveToPosition ( ItemInterface $ item , $ position ) { $ this -> moveChildToPosition ( $ item -> getParent ( ) , $ item , $ position ) ; }
4172	public function run ( ) { if ( $ this -> search ( ) ) { $ this -> registered = true ; return $ this -> console -> call ( 'migrate' ) ; } return false ; }
9005	protected function get_levels ( ) { return array ( LogLevel :: EMERGENCY => 'Emergency' , LogLevel :: ALERT => 'Alert' , LogLevel :: CRITICAL => 'Critical' , LogLevel :: ERROR => 'Error' , LogLevel :: WARNING => 'Warning' , LogLevel :: NOTICE => 'Notice' , LogLevel :: INFO => 'Info' , LogLevel :: DEBUG => 'Debug' ) ; }
126	protected function createRemoveRule ( PackageInterface $ package , $ reason , $ job ) { return new GenericRule ( array ( - $ package -> id ) , $ reason , $ job [ 'packageName' ] , $ job ) ; }
6637	protected function initParams ( ) { Yii :: $ app -> view -> params [ 'h1' ] = Yii :: t ( 'wavecms/main' , '<i>Not set</i>' ) ; Yii :: $ app -> view -> params [ 'buttons_top' ] = [ ] ; Yii :: $ app -> view -> params [ 'buttons_btm' ] = [ ] ; Yii :: $ app -> view -> params [ 'buttons_sublist' ] = [ ] ; }
4313	protected function autoloader ( $ className ) { $ className = \ ltrim ( $ className , '\\' ) ; if ( ! \ strpos ( $ className , '\\' ) ) { return ; } $ psr4Map = array ( 'bdk\\Debug\\' => __DIR__ , 'bdk\\PubSub\\' => __DIR__ . '/../PubSub' , 'bdk\\ErrorHandler\\' => __DIR__ . '/../ErrorHandler' , ) ; foreach ( $ psr4Map as $ namespace => $ dir ) { if ( \ strpos ( $ className , $ namespace ) === 0 ) { $ rel = \ substr ( $ className , \ strlen ( $ namespace ) ) ; $ rel = \ str_replace ( '\\' , '/' , $ rel ) ; require $ dir . '/' . $ rel . '.php' ; return ; } } $ classMap = array ( 'bdk\\ErrorHandler' => __DIR__ . '/../ErrorHandler/ErrorHandler.php' , ) ; if ( isset ( $ classMap [ $ className ] ) ) { require $ classMap [ $ className ] ; } }
2199	public static function findPublishedByIdOrAliasAndPid ( $ varId , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrValues = array ( $ varId ) ; if ( $ intPid ) { $ arrColumns [ ] = "$t.pid=?" ; $ arrValues [ ] = $ intPid ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
2562	protected function loadGeoCode ( PointOfRefSearchOptions $ params ) { if ( $ this -> checkAllNotEmpty ( $ params -> latitude , $ params -> longitude ) ) { $ this -> porFndQryParams -> geoCode = new GeoCode ( $ params -> longitude , $ params -> latitude ) ; } }
8607	private function _convertListSubscriptions ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListSubscriptions' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } return $ parameters ; }
7716	static function FindElement ( & $ TxtOrObj , $ Tag , $ PosBeg , $ Forward = true ) { $ XmlLoc = clsTbsXmlLoc :: FindStartTag ( $ TxtOrObj , $ Tag , $ PosBeg , $ Forward ) ; if ( $ XmlLoc === false ) return false ; $ XmlLoc -> FindEndTag ( ) ; return $ XmlLoc ; }
1935	public function generate ( $ objPage ) { $ this -> redirect ( $ this -> getForwardUrl ( $ objPage ) , $ this -> getRedirectStatusCode ( $ objPage ) ) ; }
9492	private function getApplicationSize ( ) { $ size = cache ( ) -> remember ( 'foundation.app.size' , 5 , function ( ) { return $ this -> getFolderSize ( base_path ( ) ) ; } ) ; return $ this -> formatSize ( $ size ) ; }
11966	public function renderSlots ( Page $ page , array $ slots , array $ options = array ( ) ) { $ renderedSlots = array ( ) ; $ slots = $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERING , $ page , $ slots ) ; foreach ( $ slots as $ slotName => $ slot ) { if ( is_string ( $ slot ) ) { $ renderedSlots [ $ slotName ] = $ slot ; continue ; } if ( ! $ slot instanceof Slot ) { continue ; } $ renderedSlots [ $ slotName ] = implode ( "" , $ this -> renderSlot ( $ slot ) ) ; } $ this -> mediaFiles = array_unique ( $ this -> mediaFiles ) ; return $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERED , $ page , $ renderedSlots ) ; }
1411	public function resourceIdNotSupported ( string $ id , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_CONFLICT , $ this -> trans ( 'resource_id_not_supported' , 'code' ) , $ this -> trans ( 'resource_id_not_supported' , 'title' ) , $ this -> trans ( 'resource_id_not_supported' , 'detail' , compact ( 'id' ) ) , $ this -> pointer ( $ path , 'id' ) ) ; }
1641	protected function setupSessionTracking ( Client $ client , $ endpoint , $ events ) { $ client -> setAutoCaptureSessions ( true ) ; if ( ! is_null ( $ endpoint ) ) { $ client -> setSessionEndpoint ( $ endpoint ) ; } $ sessionTracker = $ client -> getSessionTracker ( ) ; $ sessionStorage = function ( $ session = null ) { if ( is_null ( $ session ) ) { return session ( 'bugsnag-session' , [ ] ) ; } else { session ( [ 'bugsnag-session' => $ session ] ) ; } } ; $ sessionTracker -> setSessionFunction ( $ sessionStorage ) ; $ cache = $ this -> app -> cache ; $ genericStorage = function ( $ key , $ value = null ) use ( $ cache ) { if ( is_null ( $ value ) ) { return $ cache -> get ( $ key , null ) ; } else { $ cache -> put ( $ key , $ value , 60 ) ; } } ; $ sessionTracker -> setStorageFunction ( $ genericStorage ) ; }
1216	public static function stableSort ( array $ data , callable $ sortFn ) { array_walk ( $ data , function ( & $ v , $ k ) { $ v = [ $ v , $ k ] ; } ) ; uasort ( $ data , function ( $ a , $ b ) use ( $ sortFn ) { return $ sortFn ( $ a [ 0 ] , $ b [ 0 ] ) ? : ( $ a [ 1 ] < $ b [ 1 ] ? - 1 : 1 ) ; } ) ; return array_map ( function ( $ v ) { return $ v [ 0 ] ; } , array_values ( $ data ) ) ; }
2542	protected function analyzeWithErrorCodeMsgQueryLevel ( SendResult $ response , $ qErr , $ qMsg , $ qLvl , $ lvlToText ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ lvlNodeList = $ domXpath -> query ( $ qLvl ) ; $ level = null ; if ( $ lvlNodeList -> length > 0 ) { if ( array_key_exists ( $ lvlNodeList -> item ( 0 ) -> nodeValue , $ lvlToText ) ) { $ level = $ lvlToText [ $ lvlNodeList -> item ( 0 ) -> nodeValue ] ; } } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ level ) ; } return $ analyzeResponse ; }
2888	public function onBlockToHtml ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ block = $ observer -> getData ( 'block' ) ; if ( $ block -> getNameInLayout ( ) == 'debug_panels' ) { $ this -> updateProfiling ( ) ; } if ( ! $ this -> canCaptureBlock ( $ block ) ) { return ; } $ blockName = Mage :: helper ( 'sheep_debug' ) -> getBlockName ( $ block ) ; $ requestInfo = $ this -> getRequestInfo ( ) ; try { $ blockInfo = $ requestInfo -> getBlock ( $ blockName ) ; } catch ( Exception $ e ) { $ blockInfo = $ requestInfo -> addBlock ( $ block ) ; } $ blockInfo -> startRendering ( $ block ) ; }
11513	public function actionReset ( $ id , $ code ) { if ( ! $ this -> module -> enablePasswordRecovery ) { throw new NotFoundHttpException ; } $ token = $ this -> finder -> findToken ( [ 'user_id' => $ id , 'code' => $ code , 'type' => Token :: TYPE_RECOVERY ] ) -> one ( ) ; if ( $ token === null || $ token -> isExpired || $ token -> user === null ) { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'Recovery link is invalid or expired. Please try requesting a new one.' ) ) ; return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Invalid or expired link' ) , 'module' => $ this -> module , ] ) ; } $ model = \ Yii :: createObject ( [ 'class' => RecoveryForm :: className ( ) , 'scenario' => 'reset' , ] ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> getRequest ( ) -> post ( ) ) && $ model -> resetPassword ( $ token ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Password has been changed' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'reset' , [ 'model' => $ model , ] ) ; }
11678	protected function load ( $ locale , $ fileName ) { if ( $ this -> isFileLoaded ( $ locale , $ fileName ) === true ) { return true ; } $ startTime = microtime ( true ) ; $ file = $ this -> getPath ( ) . '/' . $ locale . '/' . $ fileName . '.php' ; if ( file_exists ( $ file ) === false ) { throw new FileNotFound ( $ this -> getPath ( ) , $ locale , $ fileName ) ; } $ translationKeys = include $ file ; if ( $ translationKeys === null || is_array ( $ translationKeys ) === false ) { throw new InvalidTranslationFile ( $ this -> getPath ( ) , $ locale , $ fileName ) ; } if ( array_key_exists ( $ locale , $ this -> translations ) === false ) { $ this -> translations [ $ locale ] = [ ] ; } $ this -> translations [ $ locale ] [ $ fileName ] = $ translationKeys ; $ this -> log ( 'Language loaded: ' . $ locale . '/' . $ fileName . ' (' . number_format ( microtime ( true ) - $ startTime , 2 , ',' , '.' ) . ')' ) ; return true ; }
10389	public static function loadFile ( $ xmlFile ) { if ( ! is_file ( $ xmlFile ) || ! is_readable ( $ xmlFile ) ) { throw new NoSuchFileException ( $ xmlFile ) ; } return self :: parseXml ( $ xmlFile ) ; }
10874	public function getEncodeHash ( int $ id , string $ slug , string $ linkValidate = null ) : string { return base64_encode ( uniqid ( ( $ linkValidate ? strtotime ( $ linkValidate ) : self :: NO_TIME ) . self :: TIME_SEPARATOR , true ) . self :: PART_SEPARATOR . $ this -> getHash ( $ id . $ slug ) . self :: ID_SEPARATOR . $ id ) ; }
4863	public function retry ( JobInterface $ job , array $ options = [ ] ) { $ tried = $ job -> getMetadata ( 'mongoqueue.tries' , 0 ) + 1 ; $ job -> setMetaData ( 'mongoqueue.tries' , $ tried ) ; $ options [ 'tried' ] = $ tried ; $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; unset ( $ envelope [ 'created' ] ) ; $ this -> mongoCollection -> findOneAndUpdate ( [ '_id' => new \ MongoDB \ BSON \ ObjectID ( $ job -> getId ( ) ) ] , [ '$set' => $ envelope ] ) ; }
1364	public function register ( ) { $ this -> bindNeomerx ( ) ; $ this -> bindService ( ) ; $ this -> bindInboundRequest ( ) ; $ this -> bindRouteRegistrar ( ) ; $ this -> bindApiRepository ( ) ; $ this -> bindExceptionParser ( ) ; $ this -> bindRenderer ( ) ; $ this -> mergePackageConfig ( ) ; }
2971	public static function processAttachments ( array $ attachments ) { $ processed = [ ] ; foreach ( $ attachments as $ attachment ) { if ( ! ( $ attachment instanceof Attachment ) ) { throw new \ InvalidArgumentException ( 'Attachments must implement Stampie\\Attachment' ) ; } $ name = $ attachment -> getName ( ) ; if ( isset ( $ processed [ $ name ] ) ) { $ name = static :: findUniqueName ( $ name , array_keys ( $ processed ) ) ; } $ processed [ $ name ] = $ attachment ; } return $ processed ; }
6470	public function parseAcceptLanguageHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept-Language' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept-Language' , $ i ) ; $ language = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptLanguageHeaderValue ( $ language , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
1977	public function onPreviewUrlCreate ( PreviewUrlCreateEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) || 'news' !== $ event -> getKey ( ) ) { return ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_news' === $ request -> query -> get ( 'table' ) && ! $ request -> query -> has ( 'act' ) ) { return ; } if ( null === ( $ newsModel = $ this -> getNewsModel ( $ this -> getId ( $ event , $ request ) ) ) ) { return ; } $ event -> setQuery ( 'news=' . $ newsModel -> id ) ; }
8627	public function setGetCompetitivePricingForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetCompetitivePricingForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6627	public function getData ( $ defaultValue = null ) { return ArrayHelper :: getValue ( $ this -> parsedResponse , self :: RESPONSE_DATA_PARAM , $ defaultValue ) ; }
1881	protected function isValid ( $ strFile ) { $ strFolder = Input :: get ( 'pid' , true ) ; if ( Validator :: isInsecurePath ( $ strFile ) ) { throw new AccessDeniedException ( 'Invalid file name "' . $ strFile . '" (hacking attempt).' ) ; } elseif ( Validator :: isInsecurePath ( $ strFolder ) ) { throw new AccessDeniedException ( 'Invalid folder name "' . $ strFolder . '" (hacking attempt).' ) ; } if ( ! empty ( $ this -> arrValidFileTypes ) && is_file ( $ this -> strRootDir . '/' . $ strFile ) ) { $ fileinfo = preg_replace ( '/.*\.(.*)$/u' , '$1' , $ strFile ) ; if ( ! \ in_array ( strtolower ( $ fileinfo ) , $ this -> arrValidFileTypes ) ) { throw new AccessDeniedException ( 'File "' . $ strFile . '" is not an allowed file type.' ) ; } } if ( ! preg_match ( '/^' . preg_quote ( Config :: get ( 'uploadPath' ) , '/' ) . '/i' , $ strFile ) ) { throw new AccessDeniedException ( 'File or folder "' . $ strFile . '" is not within the files directory.' ) ; } if ( $ strFolder && ! preg_match ( '/^' . preg_quote ( Config :: get ( 'uploadPath' ) , '/' ) . '/i' , $ strFolder ) ) { throw new AccessDeniedException ( 'Parent folder "' . $ strFolder . '" is not within the files directory.' ) ; } if ( Input :: get ( 'act' ) == 'edit' || Input :: get ( 'act' ) == 'paste' || Input :: get ( 'act' ) == 'delete' ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( ! $ this -> User -> isAdmin && \ in_array ( $ strFile , $ this -> User -> filemounts ) ) { throw new AccessDeniedException ( 'Attempt to edit, copy, move or delete the root folder "' . $ strFile . '".' ) ; } } return true ; }
10747	protected function sendItems ( Response $ response , iterable $ items , ? Pagination $ pagination = null , ? int $ total = null ) : Response { $ items = is_array ( $ items ) ? $ items : ( $ items instanceof \ Traversable ? iterator_to_array ( $ items , false ) : [ ] ) ; $ total = $ total ?? count ( $ items ) ; $ start = $ pagination === null ? 0 : $ pagination -> getOffset ( ) ; $ max = $ pagination === null ? 0 : $ pagination -> getMax ( ) ; $ end = max ( min ( ( PHP_INT_MAX - $ max < $ start ? PHP_INT_MAX : $ start + $ max ) , $ total ) - 1 , 0 ) ; return $ this -> sendJson ( $ response -> withHeader ( 'Content-Range' , "items $start-$end/$total" ) , $ items ) ; }
826	public function isBeforeStructuralElement ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( [ T_COMMENT , T_DOC_COMMENT ] ) ) { throw new \ InvalidArgumentException ( 'Given index must point to a comment.' ) ; } $ nextIndex = $ index ; do { $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ nextIndex ) ; } while ( null !== $ nextIndex && $ tokens [ $ nextIndex ] -> equals ( '(' ) ) ; if ( null === $ nextIndex || $ tokens [ $ nextIndex ] -> equals ( '}' ) ) { return false ; } $ nextToken = $ tokens [ $ nextIndex ] ; if ( $ this -> isStructuralElement ( $ nextToken ) ) { return true ; } if ( $ this -> isValidControl ( $ tokens , $ token , $ nextIndex ) ) { return true ; } if ( $ this -> isValidVariable ( $ tokens , $ nextIndex ) ) { return true ; } if ( $ this -> isValidLanguageConstruct ( $ tokens , $ token , $ nextIndex ) ) { return true ; } return false ; }
4309	public function getChannel ( $ channelName , $ config = array ( ) ) { if ( \ strpos ( $ channelName , '.' ) !== false ) { $ this -> error ( 'getChannel(): channelName should not contain period (.)' ) ; return $ this ; } if ( ! isset ( $ this -> channels [ $ channelName ] ) ) { $ cfg = $ this -> getCfg ( ) ; $ cfg = \ array_diff_key ( $ cfg , \ array_flip ( array ( 'errorEmailer' , 'errorHandler' , 'output' , ) ) ) ; unset ( $ cfg [ 'debug' ] [ 'onBootstrap' ] ) ; $ cfg [ 'debug' ] [ 'channel' ] = $ this -> parentInstance ? $ this -> cfg [ 'channel' ] . '.' . $ channelName : $ channelName ; $ cfg [ 'debug' ] [ 'parent' ] = $ this ; $ this -> channels [ $ channelName ] = new static ( $ cfg ) ; if ( $ config ) { $ this -> channels [ $ channelName ] -> setCfg ( $ config ) ; } } return $ this -> channels [ $ channelName ] ; }
11081	public static function GUIDv4 ( ) { return sprintf ( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x' , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0x0fff ) | 0x4000 , mt_rand ( 0 , 0x3fff ) | 0x8000 , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) ) ; }
7680	function TbsSheetSlide_DeleteDisplay ( $ id_or_name , $ ok , $ delete ) { if ( is_null ( $ ok ) ) $ ok = true ; $ ext = $ this -> ExtEquiv ; $ ok = ( boolean ) $ ok ; if ( ! is_array ( $ id_or_name ) ) $ id_or_name = array ( $ id_or_name ) ; foreach ( $ id_or_name as $ item => $ action ) { if ( ! is_bool ( $ action ) ) { $ item = $ action ; $ action = $ ok ; } $ item_ref = ( is_string ( $ item ) ) ? 'n:' . htmlspecialchars ( $ item ) : 'i:' . $ item ; if ( $ delete ) { if ( $ ok ) { $ this -> OtbsSheetSlidesDelete [ $ item_ref ] = $ item ; } else { unset ( $ this -> OtbsSheetSlidesVisible [ $ item_ref ] ) ; } } else { $ this -> OtbsSheetSlidesVisible [ $ item_ref ] = $ ok ; } } }
2183	public function create ( ) : ItemInterface { $ tree = $ this -> factory -> createItem ( 'root' ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: BACKEND_MENU_BUILD , new MenuEvent ( $ this -> factory , $ tree ) ) ; return $ tree ; }
9707	private function writeDefinedNameBiff8 ( $ name , $ formulaData , $ sheetIndex = 0 , $ isBuiltIn = false ) { $ record = 0x0018 ; $ options = $ isBuiltIn ? 0x20 : 0x00 ; $ nlen = StringHelper :: countCharacters ( $ name ) ; $ name = substr ( StringHelper :: UTF8toBIFF8UnicodeLong ( $ name ) , 2 ) ; $ sz = strlen ( $ formulaData ) ; $ data = pack ( 'vCCvvvCCCC' , $ options , 0 , $ nlen , $ sz , 0 , $ sheetIndex , 0 , 0 , 0 , 0 ) . $ name . $ formulaData ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
1052	public static function build ( $ source , ? callable $ typeConfigDecorator = null , array $ options = [ ] ) { $ doc = $ source instanceof DocumentNode ? $ source : Parser :: parse ( $ source ) ; return self :: buildAST ( $ doc , $ typeConfigDecorator , $ options ) ; }
6286	public static function hash ( $ s ) { $ h = 5381 ; $ len = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ h5 = ( $ h << 5 ) & 0xffffffff ; $ sum = ( $ h & 0x3fffffff ) + ( $ h5 & 0x3fffffff ) ; $ h = ( ( $ sum & 0x40000000 ? 1 : 0 ) + ( $ h & 0x80000000 ? 2 : 0 ) + ( $ h & 0x40000000 ? 1 : 0 ) + ( $ h5 & 0x80000000 ? 2 : 0 ) + ( $ h5 & 0x40000000 ? 1 : 0 ) ) << 30 | ( $ sum & 0x3fffffff ) ; $ h ^= ord ( $ s [ $ i ] ) ; $ h &= 0xffffffff ; } return $ h ; }
9235	public function actionCreate ( ) { $ model = new Banner ( ) ; $ model -> time = date ( "Y-m-d H:i:s" ) ; $ model -> position = $ model -> getLast ( ) ; $ model -> isdel = 0 ; $ post = Yii :: $ app -> request -> post ( ) ; if ( isset ( $ post [ 'Banner' ] [ 'tags' ] ) ) { if ( is_array ( $ post [ 'Banner' ] [ 'tags' ] ) ) { $ post [ 'Banner' ] [ 'tags' ] = implode ( "," , $ post [ 'Banner' ] [ 'tags' ] ) ; } } $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> load ( $ post ) && $ model -> save ( ) ) { $ model -> updatePosition ( $ model -> position ) ; $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; }
2224	public function editCss ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> User -> hasAccess ( 'css' , 'themes' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
11594	public function postAction ( ) { $ request = $ this -> environment -> getRequestHelper ( ) ; $ id = $ request -> getIdentifierParam ( 'name' ) ; try { $ this -> pageList -> getPage ( $ id ) ; } catch ( InvalidParameterException $ e ) { $ page = $ this -> pageList -> addPageFromRequest ( $ id , $ request ) ; $ this -> environment -> sendJSONResult ( $ page -> getJSON ( ) ) ; return ; } throw new InvalidParameterException ( "Page already exists" ) ; }
6036	public function addCommand ( $ item ) { if ( ! ( $ item instanceof Command ) ) { if ( is_array ( $ item ) ) { try { $ item = new Command ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Command. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Command"!' , E_USER_WARNING ) ; } } $ this -> commands [ ] = $ item ; return $ this ; }
3301	public function request ( $ method , $ url , $ options = [ ] ) { $ method = strtoupper ( $ method ) ; $ options = array_merge ( self :: $ defaults , [ 'headers' => $ this -> headers ] , $ options ) ; return $ this -> getClient ( ) -> request ( $ method , $ url , $ options ) ; }
2883	public function getRequestInfo ( ) { if ( $ this -> requestInfo === null ) { $ this -> requestInfo = Mage :: getModel ( 'sheep_debug/requestInfo' ) ; } return $ this -> requestInfo ; }
959	public function cancel ( ) { if ( ! $ this -> isType ( self :: CHARGE_ONETIME ) && ! $ this -> isType ( self :: CHARGE_RECURRING ) ) { throw new Exception ( 'Cancel may only be called for single and recurring charges.' ) ; } $ this -> status = self :: STATUS_CANCELLED ; $ this -> cancelled_on = Carbon :: today ( ) -> format ( 'Y-m-d' ) ; return $ this -> save ( ) ; }
6483	private static function filterPath ( ? string $ path ) : ? string { if ( $ path === null ) { return null ; } return preg_replace_callback ( '/(?:[^a-zA-Z0-9_\-\.~:@&=\+\$,\/;%]+|%(?![A-Fa-f0-9]{2}))/' , function ( $ match ) { return rawurlencode ( $ match [ 0 ] ) ; } , $ path ) ; }
10401	private function countSourceItems ( $ sources ) { $ count = 0 ; foreach ( $ sources as $ source ) { $ count += count ( $ source ) ; } return $ count ; }
11959	public function splice ( $ offset = 0 , $ length = 0 , $ replacement = [ ] ) { return new static ( array_splice ( $ this -> elements , $ offset , $ length , $ replacement ) ) ; }
10545	public function setVirtualHost ( VirtualHost $ vhost ) { $ this -> vhost = $ vhost ; $ this -> setVariable ( 'vhost' , $ vhost ) ; return $ this ; }
1686	public function updateCurrentUser ( Contao \ DataContainer $ dc ) { if ( $ this -> User -> id == $ dc -> id ) { $ this -> User -> findBy ( 'id' , $ this -> User -> id ) ; } }
8554	public function setLoanServicingEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LoanServicingEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6355	public function setTimestamp ( $ ts = false ) { $ m = [ ] ; $ da = [ ] ; $ strtime = '' ; if ( ! $ ts || $ ts === "\0\0\0\0\0\0\0\0\0\0\0\0\0\0" ) { $ uts = self :: time ( ) ; $ strtime = "@$uts" ; } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4}):(\d\d):(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(-?\d{1,13})$/D' , $ ts , $ m ) ) { $ strtime = "@{$m[1]}" ; } elseif ( preg_match ( '/^(-?\d{1,13})(\.\d+)$/D' , $ ts , $ m ) ) { $ strtime = 'unixmicro' ; } elseif ( preg_match ( '/^\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2}.\d{6}$/' , $ ts ) ) { $ strtime = preg_replace ( '/(\d\d)\.(\d\d)\.(\d\d)(\.(\d+))?/' , "$1:$2:$3" , str_replace ( '+00:00' , 'UTC' , $ ts ) ) ; } elseif ( preg_match ( '/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d*[\+\- ](\d\d)$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d* GMT$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^[ \t\r\n]*([A-Z][a-z]{2},[ \t\r\n]*)?' . '\d\d?[ \t\r\n]*[A-Z][a-z]{2}[ \t\r\n]*\d{2}(?:\d{2})?' . '[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d/S' , $ ts ) ) { $ strtime = strtok ( $ ts , ';' ) ; } elseif ( preg_match ( '/^[A-Z][a-z]{5,8}, \d\d-[A-Z][a-z]{2}-\d{2} \d\d:\d\d:\d\d/' , $ ts ) ) { $ strtime = $ ts ; } elseif ( preg_match ( '/^[A-Z][a-z]{2} [A-Z][a-z]{2} +\d{1,2} \d\d:\d\d:\d\d \d{4}/' , $ ts ) ) { $ strtime = $ ts ; } else { throw new TimestampException ( __METHOD__ . ": Invalid timestamp - $ts" ) ; } if ( ! $ strtime ) { $ da = array_map ( 'intval' , $ da ) ; $ da [ 0 ] = "%04d-%02d-%02dT%02d:%02d:%02d.00+00:00" ; $ strtime = call_user_func_array ( "sprintf" , $ da ) ; } try { if ( $ strtime === 'unixmicro' ) { $ final = DateTime :: createFromFormat ( 'U.u' , $ ts , new DateTimeZone ( 'GMT' ) ) ; } else { $ final = new DateTime ( $ strtime , new DateTimeZone ( 'GMT' ) ) ; } } catch ( Exception $ e ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' , $ e -> getCode ( ) , $ e ) ; } if ( $ final === false ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' ) ; } $ this -> timestamp = $ final ; }
11517	protected function GenerateIOSPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata , Image $ IOSPinicon ) { $ metadata .= $ this -> owner -> MarkupComment ( 'iOS Pinned Icon' ) ; if ( $ config -> fetchPiniconTitle ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'apple-mobile-web-app-title' , $ config -> fetchPiniconTitle ( ) ) ; } $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 57 , 57 ) -> getAbsoluteURL ( ) , 'image/png' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 60 , 60 ) -> getAbsoluteURL ( ) , 'image/png' , '60x60' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 72 , 72 ) -> getAbsoluteURL ( ) , 'image/png' , '72x72' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 76 , 76 ) -> getAbsoluteURL ( ) , 'image/png' , '76x76' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 114 , 114 ) -> getAbsoluteURL ( ) , 'image/png' , '114x114' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 120 , 120 ) -> getAbsoluteURL ( ) , 'image/png' , '120x120' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 144 , 144 ) -> getAbsoluteURL ( ) , 'image/png' , '144x144' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 152 , 152 ) -> getAbsoluteURL ( ) , 'image/png' , '152x152' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 180 , 180 ) -> getAbsoluteURL ( ) , 'image/png' , '180x180' ) ; }
7677	function TbsSearchInFiles ( $ files , $ str , $ returnFirstFound = true ) { $ keys_ok = array ( ) ; $ keys_todo = array ( ) ; $ idx_keys = array ( ) ; foreach ( $ files as $ k => $ f ) { $ idx = $ this -> FileGetIdx ( $ f ) ; if ( $ idx !== false ) { $ keys_todo [ $ k ] = $ idx ; $ idx_keys [ $ idx ] = $ k ; } } if ( ( $ this -> TbsCurrIdx !== false ) && isset ( $ idx_keys [ $ this -> TbsCurrIdx ] ) ) { $ key = $ idx_keys [ $ this -> TbsCurrIdx ] ; $ p = strpos ( $ this -> TBS -> Source , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ this -> TbsCurrIdx , 'src' => & $ this -> TBS -> Source , 'pos' => $ p , 'curr' => true ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } unset ( $ keys_todo [ $ key ] ) ; } foreach ( $ this -> TbsStoreLst as $ idx => $ s ) { if ( ( $ idx !== $ this -> TbsCurrIdx ) && isset ( $ idx_keys [ $ idx ] ) ) { $ key = $ idx_keys [ $ idx ] ; $ p = strpos ( $ s [ 'src' ] , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ idx , 'src' => & $ s [ 'src' ] , 'pos' => $ p , 'curr' => false ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } unset ( $ keys_todo [ $ key ] ) ; } } foreach ( $ keys_todo as $ key => $ idx ) { $ txt = $ this -> FileRead ( $ idx ) ; $ p = strpos ( $ txt , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ idx , 'src' => $ txt , 'pos' => $ p , 'curr' => false ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } } if ( $ returnFirstFound ) { return array ( 'key' => false , 'idx' => false , 'src' => false , 'pos' => false , 'curr' => false ) ; } else { return $ keys_ok ; } }
8958	public function validateResponse ( $ url , $ response ) { if ( $ response -> code != 200 ) { $ error = htmlspecialchars ( $ response -> body ) ; throw new \ DomainException ( $ error , $ response -> code ) ; } }
377	private function getByteSize ( $ verboseSize ) { if ( empty ( $ verboseSize ) ) { return 0 ; } if ( is_numeric ( $ verboseSize ) ) { return ( int ) $ verboseSize ; } $ sizeUnit = trim ( $ verboseSize , '0123456789' ) ; $ size = trim ( str_replace ( $ sizeUnit , '' , $ verboseSize ) ) ; if ( ! is_numeric ( $ size ) ) { return 0 ; } switch ( strtolower ( $ sizeUnit ) ) { case 'kb' : case 'k' : return $ size * 1024 ; case 'mb' : case 'm' : return $ size * 1024 * 1024 ; case 'gb' : case 'g' : return $ size * 1024 * 1024 * 1024 ; default : return 0 ; } }
533	public function actionFix ( $ root = null ) { $ files = $ this -> findFiles ( $ root , false ) ; $ nFilesTotal = 0 ; $ nFilesUpdated = 0 ; foreach ( $ files as $ file ) { $ contents = file_get_contents ( $ file ) ; $ hash = $ this -> hash ( $ contents ) ; $ lines = preg_split ( '/(\r\n|\n|\r)/' , $ contents ) ; if ( ! $ this -> skipFrameworkRequirements ) { $ this -> fixFileDoc ( $ lines ) ; } $ this -> fixDocBlockIndentation ( $ lines ) ; $ lines = array_values ( $ this -> fixLineSpacing ( $ lines ) ) ; $ newContent = implode ( "\n" , $ lines ) ; if ( $ hash !== $ this -> hash ( $ newContent ) ) { file_put_contents ( $ file , $ newContent ) ; $ nFilesUpdated ++ ; } $ nFilesTotal ++ ; } $ this -> stdout ( "\nParsed $nFilesTotal files.\n" ) ; $ this -> stdout ( "Updated $nFilesUpdated files.\n" ) ; }
8868	public function notify ( PayloadInterface $ payload ) { foreach ( $ this -> runners as $ runner ) { $ runner -> run ( $ payload ) ; } return $ this ; }
289	protected function isLanguageSupported ( $ requested , $ supported ) { $ supported = str_replace ( '_' , '-' , strtolower ( $ supported ) ) ; $ requested = str_replace ( '_' , '-' , strtolower ( $ requested ) ) ; return strpos ( $ requested . '-' , $ supported . '-' ) === 0 ; }
7305	protected function scheduleParentChangeEvents ( CustomerInterface $ customer ) { if ( ! $ customer -> hasChildren ( ) ) { return ; } foreach ( $ customer -> getChildren ( ) as $ child ) { $ this -> persistenceHelper -> scheduleEvent ( CustomerEvents :: PARENT_CHANGE , $ child ) ; } }
2513	protected function isWorseStatus ( $ newStatus , $ currentStatus ) { $ levels = [ self :: STATUS_UNKNOWN => - 1 , self :: STATUS_OK => 0 , self :: STATUS_INFO => 2 , self :: STATUS_WARN => 5 , self :: STATUS_ERROR => 10 , self :: STATUS_FATAL => 20 , ] ; return ( $ currentStatus === null || $ levels [ $ newStatus ] > $ levels [ $ currentStatus ] ) ; }
5878	protected static function updateIndex ( \ TYPO3 \ CMS \ Core \ Resource \ File $ file = null , $ width , $ height , array $ metadata = [ ] ) { if ( count ( $ metadata ) > 0 ) { $ metadataRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ Index \ MetaDataRepository :: class ) ; $ currentMetadata = $ metadataRepository -> findByFile ( $ file ) ; $ newMetadata = [ ] ; foreach ( $ currentMetadata as $ key => $ value ) { if ( ! empty ( $ metadata [ $ key ] ) ) { if ( $ key === 'creator_tool' && MathUtility :: canBeInterpretedAsFloat ( $ metadata [ $ key ] ) ) { continue ; } $ newMetadata [ $ key ] = $ metadata [ $ key ] ; } } unset ( $ newMetadata [ 'width' ] ) ; unset ( $ newMetadata [ 'height' ] ) ; $ newMetadata [ 'unit' ] = 'px' ; $ mapping = [ 'color_space' => 'ColorSpace' , 'content_creation_date' => 'DateTimeOriginal' , 'creator' => 'IPTCCreator|Company' , 'creator_tool' => 'Model|Make|Software' , 'description' => 'ImageDescription' , 'keywords' => 'IPTCKeywords' , 'latitude' => 'GPSLatitudeDecimal' , 'longitude' => 'GPSLongitudeDecimal' , 'location_city' => 'IPTCCity' , 'location_country' => 'IPTCCountry' , 'location_region' => 'IPTCRegion' , 'note' => 'IPTCLocation' , 'publisher' => 'IPTCCredit' , 'source' => 'IPTCSource' , 'title' => 'IPTCTitle' , ] ; foreach ( $ mapping as $ falKey => $ metadataKeyMapping ) { if ( ! empty ( $ newMetadata [ $ falKey ] ) ) { continue ; } $ metatadaKeys = explode ( '|' , $ metadataKeyMapping ) ; foreach ( $ metatadaKeys as $ metadataKey ) { $ value = null ; if ( isset ( $ metadata [ $ metadataKey ] ) ) { $ value = trim ( $ metadata [ $ metadataKey ] ) ; if ( ord ( $ value ) === 1 ) $ value = null ; switch ( $ metadataKey ) { case 'ColorSpace' : if ( $ value == 1 ) { $ value = 'RGB' ; } else { $ value = null ; } break ; case 'DateTimeOriginal' : $ value = strtotime ( $ value ) ; break ; } } if ( ! empty ( $ value ) ) { $ newMetadata [ $ falKey ] = $ value ; break ; } } } $ metadataRepository -> update ( $ file -> getUid ( ) , $ newMetadata ) ; } }
5891	public static function permissionType ( $ type ) { if ( $ type == TeamSpeak3 :: PERM_TYPE_SERVERGROUP ) { return "Server Group" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CLIENT ) { return "Client" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CHANNEL ) { return "Channel" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CHANNELGROUP ) { return "Channel Group" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CHANNELCLIENT ) { return "Channel Client" ; } return "Unknown" ; }
2368	public static function extractEmail ( $ strString , $ strAllowedTags = '' ) { $ arrEmails = array ( ) ; if ( strpos ( $ strString , '@' ) === false ) { return $ arrEmails ; } preg_match_all ( '/mailto:(?:[^\x00-\x20\x22\x40\x7F]{1,64}+|\x22[^\x00-\x1F\x7F]{1,64}?\x22)@(?:\[(?:IPv)?[a-f0-9.:]{1,47}\]|[\w.-]{1,252}\.[a-z]{2,63}\b)/u' , $ strString , $ matches ) ; foreach ( $ matches [ 0 ] as & $ strEmail ) { $ strEmail = str_replace ( 'mailto:' , '' , $ strEmail ) ; if ( Validator :: isEmail ( $ strEmail ) ) { $ arrEmails [ ] = $ strEmail ; } } unset ( $ strEmail ) ; $ strString = preg_replace_callback ( '@</?([^\s<>/]*)@' , function ( $ matches ) use ( $ strAllowedTags ) { if ( $ matches [ 1 ] == '' || stripos ( $ strAllowedTags , '<' . strtolower ( $ matches [ 1 ] ) . '>' ) === false ) { $ matches [ 0 ] = str_replace ( '<' , '&lt;' , $ matches [ 0 ] ) ; } return $ matches [ 0 ] ; } , $ strString ) ; preg_match_all ( '/(?:[^\x00-\x20\x22\x40\x7F]{1,64}|\x22[^\x00-\x1F\x7F]{1,64}?\x22)@(?:\[(?:IPv)?[a-f0-9.:]{1,47}\]|[\w.-]{1,252}\.[a-z]{2,63}\b)/u' , strip_tags ( $ strString ) , $ matches ) ; foreach ( $ matches [ 0 ] as & $ strEmail ) { $ strEmail = str_replace ( '&lt;' , '<' , $ strEmail ) ; if ( Validator :: isEmail ( $ strEmail ) ) { $ arrEmails [ ] = $ strEmail ; } } return array_unique ( $ arrEmails ) ; }
4194	private function magicMethodInfo ( $ methods ) { if ( ! $ methods ) { return '' ; } foreach ( $ methods as $ i => $ method ) { $ methods [ $ i ] = '<code>' . $ method . '</code>' ; } $ methods = $ i == 0 ? 'a ' . $ methods [ 0 ] . ' method' : \ implode ( ' and ' , $ methods ) . ' methods' ; return '<dd class="magic info">This object has ' . $ methods . '</dd>' . "\n" ; }
6489	private function addHeaderValue ( HttpHeaders $ headers , string $ name , $ value , bool $ append ) : void { $ decodedValue = trim ( ( string ) ( isset ( self :: $ headersToUrlDecode [ $ name ] ) ? urldecode ( $ value ) : $ value ) ) ; if ( isset ( self :: $ specialCaseHeaders [ $ name ] ) ) { $ headers -> add ( $ name , $ decodedValue , $ append ) ; } elseif ( strpos ( $ name , 'HTTP_' ) === 0 ) { $ normalizedName = substr ( $ name , 5 ) ; $ headers -> add ( $ normalizedName , $ decodedValue , $ append ) ; } }
6035	public function setCommands ( array $ commands ) { $ this -> commands = [ ] ; foreach ( $ commands as $ item ) { $ this -> addCommand ( $ item ) ; } return $ this ; }
2029	public static function findPublishedFallbackByHostname ( $ strHost , array $ arrOptions = array ( ) ) { if ( empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ strHost , 'contao.dns-fallback' ) ; if ( $ objModel !== null ) { return $ objModel ; } } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.dns=? AND $t.fallback='1'" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ strHost , $ arrOptions ) ; }
3202	protected function process_css_style ( $ stackPtr ) { if ( ! isset ( $ this -> target_css_properties [ $ this -> tokens [ $ stackPtr ] [ 'content' ] ] ) ) { return ; } $ css_property = $ this -> target_css_properties [ $ this -> tokens [ $ stackPtr ] [ 'content' ] ] ; $ opener = $ this -> phpcsFile -> findPrevious ( \ T_OPEN_CURLY_BRACKET , $ stackPtr ) ; if ( false !== $ opener ) { for ( $ i = ( $ opener - 1 ) ; $ i >= 0 ; $ i -- ) { if ( isset ( Tokens :: $ commentTokens [ $ this -> tokens [ $ i ] [ 'code' ] ] ) || \ T_CLOSE_CURLY_BRACKET === $ this -> tokens [ $ i ] [ 'code' ] ) { break ; } } $ start = ( $ i + 1 ) ; $ selector = trim ( $ this -> phpcsFile -> getTokensAsString ( $ start , ( $ opener - $ start ) ) ) ; unset ( $ i ) ; foreach ( $ this -> target_css_selectors as $ target_selector ) { if ( false !== strpos ( $ selector , $ target_selector ) ) { $ error = true ; if ( true === $ this -> remove_only ) { $ valuePtr = $ this -> phpcsFile -> findNext ( array ( \ T_COLON , \ T_WHITESPACE ) , ( $ stackPtr + 1 ) , null , true ) ; $ value = $ this -> tokens [ $ valuePtr ] [ 'content' ] ; $ valid = $ this -> validate_css_property_value ( $ value , $ css_property [ 'type' ] , $ css_property [ 'value' ] ) ; if ( true === $ valid ) { $ error = false ; } } if ( true === $ error ) { $ this -> phpcsFile -> addError ( 'Hiding of the admin bar is not allowed.' , $ stackPtr , 'HidingDetected' ) ; } } } } }
9877	private function writeFileVersion ( XMLWriter $ objWriter ) { $ objWriter -> startElement ( 'fileVersion' ) ; $ objWriter -> writeAttribute ( 'appName' , 'xl' ) ; $ objWriter -> writeAttribute ( 'lastEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'lowestEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'rupBuild' , '4505' ) ; $ objWriter -> endElement ( ) ; }
2783	public function renderSummaryReport ( Collector $ collector ) { $ pkills = str_pad ( $ collector -> getKilledCount ( ) , 8 , ' ' , STR_PAD_LEFT ) ; $ pescapes = str_pad ( $ collector -> getEscapeCount ( ) , 8 , ' ' , STR_PAD_LEFT ) ; $ perrors = str_pad ( $ collector -> getErrorCount ( ) , 8 , ' ' , STR_PAD_LEFT ) ; $ ptimeouts = str_pad ( $ collector -> getTimeoutCount ( ) , 8 , ' ' , STR_PAD_LEFT ) ; $ pshadows = str_pad ( $ collector -> getShadowCount ( ) , 8 , ' ' , STR_PAD_LEFT ) ; $ this -> write ( PHP_EOL , false ) ; $ this -> write ( $ collector -> getTotalCount ( ) . ' mutations were generated:' ) ; $ this -> write ( $ pkills . ' mutants were killed' ) ; $ this -> write ( $ pshadows . ' mutants were not covered by tests' ) ; $ this -> write ( $ pescapes . ' covered mutants were not detected' ) ; $ this -> write ( $ perrors . ' fatal errors were encountered' ) ; $ this -> write ( $ ptimeouts . ' time outs were encountered' ) ; $ this -> write ( PHP_EOL , false ) ; $ vanquishedTotal = $ collector -> getVanquishedTotal ( ) ; $ measurableTotal = $ collector -> getMeasurableTotal ( ) ; if ( $ measurableTotal !== 0 ) { $ detectionRateTested = round ( 100 * ( $ vanquishedTotal / $ measurableTotal ) ) ; } else { $ detectionRateTested = 0 ; } if ( $ collector -> getTotalCount ( ) !== 0 ) { $ coveredRate = round ( 100 * ( ( $ measurableTotal ) / $ collector -> getTotalCount ( ) ) ) ; $ detectionRateAll = round ( 100 * ( $ vanquishedTotal / $ collector -> getTotalCount ( ) ) ) ; } else { $ coveredRate = 0 ; $ detectionRateAll = 0 ; } $ this -> write ( 'Metrics:' ) ; $ this -> write ( ' Mutation Score Indicator (MSI): <options=bold>' . $ detectionRateAll . '%</options=bold>' ) ; $ this -> write ( ' Mutation Code Coverage: <options=bold>' . $ coveredRate . '%</options=bold>' ) ; $ this -> write ( ' Covered Code MSI: <options=bold>' . $ detectionRateTested . '%</options=bold>' ) ; $ this -> write ( PHP_EOL , false ) ; $ this -> write ( 'Remember that some mutants will inevitably be harmless (i.e. false positives).' ) ; }
1413	public function resourceDoesNotExist ( string $ path ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_NOT_FOUND , $ this -> trans ( 'resource_not_found' , 'code' ) , $ this -> trans ( 'resource_not_found' , 'title' ) , $ this -> trans ( 'resource_not_found' , 'detail' ) , $ this -> pointer ( $ path ) ) ; }
10578	public function multipleToAPIResponseData ( ? array $ resources ) : APIResponseData { if ( is_null ( $ resources ) ) { return $ this -> toAPIResponseData ( null ) ; } return new APIResponseData ( array_map ( function ( Resource $ resource ) { return $ this -> toAPIResponseData ( $ resource ) -> getData ( ) ; } , $ resources ) ) ; }
6401	public function getResource ( $ resource ) : ? string { Preconditions :: checkState ( $ this -> isPsr0Compatible ( ) , "Class '%s' must be PSR-0 compatible!" , $ this -> getName ( ) ) ; $ slashedFileName = $ this -> getSlashedFileName ( ) ; $ filePath = $ resource [ 0 ] == '/' ? str_replace ( "/{$this->getSlashedName()}.php" , '' , $ slashedFileName ) . $ resource : dirname ( $ slashedFileName ) . '/' . $ resource ; return is_file ( $ filePath ) ? $ filePath : null ; }
12511	private function buildGroup ( $ group ) { if ( is_null ( $ group ) ) { $ group = [ 'filter' => [ 'is_to_all' => true , ] , ] ; } elseif ( is_array ( $ group ) ) { $ group = [ 'touser' => $ group , ] ; } else { $ group = [ 'filter' => [ 'is_to_all' => false , 'group_id' => $ group , ] , ] ; } return $ group ; }
8442	public function render ( array $ args , bool $ prettyPrint = null ) { header ( 'Content-type: application/json' ) ; if ( ( constant ( 'STRAY_ENV' ) === 'development' && $ prettyPrint !== false ) || $ prettyPrint === true ) { return ( string ) json_encode ( $ args , JSON_PRETTY_PRINT ) ; } return ( string ) json_encode ( $ args ) ; }
3036	protected function persistCacheEntry ( $ key ) { $ success = true ; if ( isset ( $ this -> cache [ $ key ] ) ) { $ cache = $ this -> cache [ $ key ] ; switch ( $ cache [ 'state' ] ) { case self :: STATE_PENDING_WRITE : $ success = $ this -> getStorage ( ) -> set ( $ cache [ 'userId' ] , $ cache [ 'callId' ] , $ cache [ 'data' ] ) ; if ( ! $ success ) { throw new \ common_exception_Error ( 'Can\'t write into test runner state storage at ' . static :: class ) ; } $ this -> cache [ $ key ] [ 'state' ] = self :: STATE_ALIGNED ; break ; case self :: STATE_PENDING_DELETE : $ success = $ this -> getStorage ( ) -> del ( $ cache [ 'userId' ] , $ cache [ 'callId' ] ) ; if ( $ success ) { unset ( $ this -> cache [ $ key ] ) ; } break ; } } return $ success ; }
2435	public function remove ( $ strKey ) { if ( \ in_array ( $ strKey , $ this -> mappedKeys ) ) { $ this -> session -> remove ( $ strKey ) ; } else { $ this -> sessionBag -> remove ( $ strKey ) ; } }
7703	function OpenDoc_ChartInit ( ) { $ this -> OpenDocCharts = array ( ) ; $ idx = $ this -> Ext_GetMainIdx ( ) ; $ Txt = $ this -> TbsStoreGet ( $ idx , 'OpenDoc_ChartInit' ) ; $ p = 0 ; while ( $ drEl = clsTbsXmlLoc :: FindElement ( $ Txt , 'draw:frame' , $ p ) ) { $ src = $ drEl -> GetInnerSrc ( ) ; $ objEl = clsTbsXmlLoc :: FindStartTag ( $ src , 'draw:object' , 0 ) ; if ( $ objEl ) { $ href = $ objEl -> GetAttLazy ( 'xlink:href' ) ; if ( $ href ) { $ imgEl = clsTbsXmlLoc :: FindElement ( $ src , 'draw:image' , 0 ) ; $ img_href = ( $ imgEl ) ? $ imgEl -> GetAttLazy ( 'xlink:href' ) : false ; $ img_src = ( $ imgEl ) ? $ imgEl -> GetSrc ( 'xlink:href' ) : false ; $ titEl = clsTbsXmlLoc :: FindElement ( $ src , 'svg:title' , 0 ) ; $ title = ( $ titEl ) ? $ titEl -> GetInnerSrc ( ) : '' ; if ( substr ( $ href , 0 , 2 ) == './' ) $ href = substr ( $ href , 2 ) ; if ( is_string ( $ img_href ) && ( substr ( $ img_href , 0 , 2 ) == './' ) ) $ img_href = substr ( $ img_href , 2 ) ; $ this -> OpenDocCharts [ ] = array ( 'href' => $ href , 'title' => $ title , 'img_href' => $ img_href , 'img_src' => $ img_src , 'to_clear' => ( $ img_href !== false ) ) ; } } $ p = $ drEl -> PosEnd ; } }
10745	public function getObjectArray ( $ keys ) : array { return array_map ( function ( $ value ) { return $ this -> createObject ( $ value ) ; } , $ this -> getArray ( $ keys ) ) ; }
11841	private function extractInput ( ) { $ params = $ this -> request -> getParams ( ) ; $ period = $ params [ self :: REQ_PERIOD ] ?? '' ; if ( empty ( $ period ) ) { $ period = $ this -> hlpPeriod -> getPeriodCurrent ( null , 0 , HPeriod :: TYPE_MONTH ) ; } else { $ period = $ this -> hlpPeriod -> normalizePeriod ( $ period , HPeriod :: TYPE_MONTH ) ; } $ dsBegin = $ this -> hlpPeriod -> getPeriodFirstDate ( $ period ) ; $ treeType = $ params [ self :: REQ_TREE_TYPE ] ?? '' ; if ( $ treeType != OptionTreeType :: VAL_PLAIN ) { $ treeType = OptionTreeType :: VAL_COMPRESS ; } return [ $ dsBegin , $ treeType ] ; }
3827	protected function getFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) { if ( $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ) { return '' ; } return $ strKeyOption ; }
8879	private function isValidHomeDirectory ( string $ path ) : bool { $ valid = false ; if ( '~/' === substr ( $ path , 0 , 2 ) ) { $ valid = $ this -> isValidFullPath ( $ this -> expandHomeDirectory ( $ path ) ) ; } return $ valid ; }
5546	public function getTransportError ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getTransportError ( ) ; } return $ this -> frameset -> getTransportError ( ) ; }
8625	public function setTemporarilyUnavailableCarrierList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'TemporarilyUnavailableCarrierList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4468	public function setPriority ( int $ priority ) : void { if ( $ this -> client -> call ( 'priority' , $ this -> jid , $ priority ) ) { parent :: setPriority ( $ priority ) ; } }
7525	function select ( $ query = '*' , $ index = false , $ recursive = true , $ check_self = false ) { return $ this -> root -> select ( $ query , $ index , $ recursive , $ check_self ) ; }
200	private function checkTargetRelationExistence ( $ model , $ attribute ) { $ exists = false ; $ relationQuery = $ model -> { 'get' . ucfirst ( $ this -> targetRelation ) } ( ) ; if ( $ this -> filter instanceof \ Closure ) { call_user_func ( $ this -> filter , $ relationQuery ) ; } elseif ( $ this -> filter !== null ) { $ relationQuery -> andWhere ( $ this -> filter ) ; } if ( $ this -> forceMasterDb && method_exists ( $ model :: getDb ( ) , 'useMaster' ) ) { $ model :: getDb ( ) -> useMaster ( function ( ) use ( $ relationQuery , & $ exists ) { $ exists = $ relationQuery -> exists ( ) ; } ) ; } else { $ exists = $ relationQuery -> exists ( ) ; } if ( ! $ exists ) { $ this -> addError ( $ model , $ attribute , $ this -> message ) ; } }
4921	public function region ( $ region , $ reset = false ) { $ this -> currentRegion = $ region ; if ( $ reset ) { $ this -> matrix [ $ this -> currentRegion ] = [ ] ; } return $ this ; }
5466	public function setIdentityForRealm ( $ host , $ realm , $ username , $ password ) { if ( isset ( $ this -> realms [ $ host ] [ $ realm ] ) ) { $ this -> realms [ $ host ] [ $ realm ] -> setIdentity ( $ username , $ password ) ; } }
6272	public static function open ( $ fileName ) { return self :: haveExtension ( ) ? new Reader \ DBA ( $ fileName ) : new Reader \ PHP ( $ fileName ) ; }
7989	public function getTemplateProperties ( $ domain , $ templateId ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ templateId = ( string ) $ templateId ; if ( ! $ templateId ) throw new BadMethodCallException ( "Parameter $templateId is missing" ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/templates/' . $ templateId ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( ) ; }
3523	public function id ( $ id ) { foreach ( $ this -> items as $ item ) { if ( $ item -> itemId == $ id ) return $ item ; } return null ; }
3681	public function getJumpTo ( ) { if ( ! isset ( $ this -> arrJumpTo ) ) { $ page = $ GLOBALS [ 'objPage' ] ; $ this -> setJumpTo ( $ page -> row ( ) ) ; if ( $ this -> metamodel_jumpTo ) { $ statement = $ this -> getConnection ( ) -> prepare ( 'SELECT id, alias FROM tl_page WHERE id=? LIMIT 0,1' ) ; $ statement -> bindValue ( 1 , $ this -> metamodel_jumpTo ) ; $ statement -> execute ( ) ; if ( $ statement -> rowCount ( ) ) { $ this -> setJumpTo ( $ statement -> fetch ( \ PDO :: FETCH_ASSOC ) ) ; } } } return $ this -> arrJumpTo ; }
12939	public function setMax ( $ value ) { $ this -> setTag ( 'max' , $ value ) ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'max' , $ value ) ; } }
9087	public function attach ( ResolverInterface $ detector , $ priority = 1 ) { $ this -> queue -> insert ( $ detector , $ priority ) ; return $ this ; }
2549	protected function loadClientParams ( Params $ params , $ receivedFromIdentifier , $ version ) { if ( $ params -> authParams instanceof Params \ AuthParams ) { $ this -> authParams = $ params -> authParams ; if ( isset ( $ params -> sessionHandlerParams ) && $ params -> sessionHandlerParams instanceof Params \ SessionHandlerParams ) { $ params -> sessionHandlerParams -> authParams = $ this -> authParams ; } } elseif ( isset ( $ params -> sessionHandlerParams ) && $ params -> sessionHandlerParams -> authParams instanceof Params \ AuthParams ) { $ this -> authParams = $ params -> sessionHandlerParams -> authParams ; } $ this -> sessionHandler = $ this -> loadSessionHandler ( $ params -> sessionHandler , $ params -> sessionHandlerParams ) ; $ this -> requestCreator = $ this -> loadRequestCreator ( $ params -> requestCreator , $ params -> requestCreatorParams , $ receivedFromIdentifier . "-" . $ version , $ this -> sessionHandler -> getOriginatorOffice ( ) , $ this -> sessionHandler -> getMessagesAndVersions ( ) ) ; $ this -> responseHandler = $ this -> loadResponseHandler ( $ params -> responseHandler ) ; $ this -> returnResultXml = $ params -> returnXml ; }
2094	private function isScope ( string $ scope ) : bool { if ( null === $ this -> container || null === ( $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ) ) { return false ; } $ matcher = $ this -> container -> get ( 'contao.routing.scope_matcher' ) ; if ( ContaoCoreBundle :: SCOPE_BACKEND === $ scope ) { return $ matcher -> isBackendRequest ( $ request ) ; } if ( ContaoCoreBundle :: SCOPE_FRONTEND === $ scope ) { return $ matcher -> isFrontendRequest ( $ request ) ; } return false ; }
1817	public function deleteElement ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ objElement = $ this -> Database -> prepare ( "SELECT id FROM tl_content WHERE cteAlias=? AND type='alias'" ) -> limit ( 1 ) -> execute ( $ row [ 'id' ] ) ; return $ objElement -> numRows ? Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' : '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; }
773	public function actionExtract ( $ configFile = null ) { $ this -> initConfig ( $ configFile ) ; $ files = FileHelper :: findFiles ( realpath ( $ this -> config [ 'sourcePath' ] ) , $ this -> config ) ; $ messages = [ ] ; foreach ( $ files as $ file ) { $ messages = array_merge_recursive ( $ messages , $ this -> extractMessages ( $ file , $ this -> config [ 'translator' ] , $ this -> config [ 'ignoreCategories' ] ) ) ; } $ catalog = isset ( $ this -> config [ 'catalog' ] ) ? $ this -> config [ 'catalog' ] : 'messages' ; if ( in_array ( $ this -> config [ 'format' ] , [ 'php' , 'po' ] ) ) { foreach ( $ this -> config [ 'languages' ] as $ language ) { $ dir = $ this -> config [ 'messagePath' ] . DIRECTORY_SEPARATOR . $ language ; if ( ! is_dir ( $ dir ) && ! @ mkdir ( $ dir ) ) { throw new Exception ( "Directory '{$dir}' can not be created." ) ; } if ( $ this -> config [ 'format' ] === 'po' ) { $ this -> saveMessagesToPO ( $ messages , $ dir , $ this -> config [ 'overwrite' ] , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'sort' ] , $ catalog , $ this -> config [ 'markUnused' ] ) ; } else { $ this -> saveMessagesToPHP ( $ messages , $ dir , $ this -> config [ 'overwrite' ] , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'sort' ] , $ this -> config [ 'markUnused' ] ) ; } } } elseif ( $ this -> config [ 'format' ] === 'db' ) { $ db = Instance :: ensure ( $ this -> config [ 'db' ] , Connection :: className ( ) ) ; $ sourceMessageTable = isset ( $ this -> config [ 'sourceMessageTable' ] ) ? $ this -> config [ 'sourceMessageTable' ] : '{{%source_message}}' ; $ messageTable = isset ( $ this -> config [ 'messageTable' ] ) ? $ this -> config [ 'messageTable' ] : '{{%message}}' ; $ this -> saveMessagesToDb ( $ messages , $ db , $ sourceMessageTable , $ messageTable , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'languages' ] , $ this -> config [ 'markUnused' ] ) ; } elseif ( $ this -> config [ 'format' ] === 'pot' ) { $ this -> saveMessagesToPOT ( $ messages , $ this -> config [ 'messagePath' ] , $ catalog ) ; } }
127	public function ensureBinariesPresence ( PackageInterface $ package ) { $ this -> binaryInstaller -> installBinaries ( $ package , $ this -> getInstallPath ( $ package ) , false ) ; }
291	public function populateRelation ( $ name , $ records ) { foreach ( $ this -> _relationsDependencies as & $ relationNames ) { unset ( $ relationNames [ $ name ] ) ; } $ this -> _related [ $ name ] = $ records ; }
12218	public function shutdownHandler ( ) { $ error = error_get_last ( ) ; if ( $ error && $ error [ 'type' ] & $ this -> fatalErrors ) { $ this -> errorHandler ( $ error [ 'type' ] , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ; } }
7990	public function getPcaServices ( $ pp ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (passport).' ) ; try { $ r = $ this -> get ( 'cloud/' . $ pp . '/pca' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
9639	public function setValue ( $ url ) { if ( $ url ) { $ url = $ this -> rebuildURL ( $ url ) ; } parent :: setValue ( $ url ) ; }
5503	protected function addCall ( $ method , $ args ) { if ( ! isset ( $ this -> call_counts [ $ method ] ) ) { $ this -> call_counts [ $ method ] = 0 ; } $ this -> call_counts [ $ method ] ++ ; }
7197	protected function setIsFirst ( OrderInterface $ order ) { if ( null !== $ customer = $ order -> getCustomer ( ) ) { if ( $ customer -> hasParent ( ) ) { $ customer = $ customer -> getParent ( ) ; } $ first = ! $ this -> orderRepository -> existsForCustomer ( $ customer ) ; } else { $ first = ! $ this -> orderRepository -> existsForEmail ( $ order -> getEmail ( ) ) ; } if ( $ first != $ order -> isFirst ( ) ) { $ order -> setFirst ( $ first ) ; return true ; } return false ; }
7582	protected function verifyRequiredData ( ) { $ errors = array ( ) ; foreach ( $ this -> _REQUIRED_DATA as $ property => $ defaultValue ) { if ( ( ! isset ( $ this -> Data [ $ property ] ) ) && empty ( $ defaultValue ) ) { $ errors [ ] = $ property ; } } if ( count ( $ errors ) > 0 ) { throw new RequiredDataException ( get_called_class ( ) , "Missing data for " . implode ( "," , $ errors ) ) ; } return true ; }
6098	protected function post ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_POST , null , $ fireAndForget ) ; }
590	protected function compressJsFiles ( $ inputFiles , $ outputFile ) { if ( empty ( $ inputFiles ) ) { return ; } $ this -> stdout ( " Compressing JavaScript files...\n" ) ; if ( is_string ( $ this -> jsCompressor ) ) { $ tmpFile = $ outputFile . '.tmp' ; $ this -> combineJsFiles ( $ inputFiles , $ tmpFile ) ; $ this -> stdout ( shell_exec ( strtr ( $ this -> jsCompressor , [ '{from}' => escapeshellarg ( $ tmpFile ) , '{to}' => escapeshellarg ( $ outputFile ) , ] ) ) ) ; @ unlink ( $ tmpFile ) ; } else { call_user_func ( $ this -> jsCompressor , $ this , $ inputFiles , $ outputFile ) ; } if ( ! file_exists ( $ outputFile ) ) { throw new Exception ( "Unable to compress JavaScript files into '{$outputFile}'." ) ; } $ this -> stdout ( " JavaScript files compressed into '{$outputFile}'.\n" ) ; }
12340	protected function print ( string $ msg , bool $ withTime = true ) : void { $ preMsg = '' ; if ( $ withTime ) { $ preMsg = ( new \ DateTime ( 'now' ) ) -> format ( 'H:i:s' ) . "\t" ; } echo "{$preMsg}{$msg}" . \ PHP_EOL ; }
6219	public function getPeriodEnd ( ) { if ( is_null ( $ this -> parsedPeriodEnd ) ) { $ this -> parsedPeriodEnd = strtotime ( $ this -> periodEnd ) ; } return $ this -> parsedPeriodEnd ; }
352	public static function getInputId ( $ model , $ attribute ) { $ charset = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; $ name = mb_strtolower ( static :: getInputName ( $ model , $ attribute ) , $ charset ) ; return str_replace ( [ '[]' , '][' , '[' , ']' , ' ' , '.' ] , [ '' , '-' , '-' , '' , '-' , '-' ] , $ name ) ; }
6428	protected function getFacebookObject ( ) { if ( is_object ( $ this -> fb ) ) { return $ this -> fb ; } $ fb = new \ Facebook \ Facebook ( [ 'app_id' => $ this -> options [ 'api_key' ] , 'app_secret' => $ this -> options [ 'secret_key' ] , 'default_graph_version' => 'v3.0' , ] ) ; $ this -> fb = $ fb ; return $ fb ; }
8829	protected function option ( $ display , $ value , $ selected , array $ attributes = [ ] ) { $ selected = $ this -> getSelectedValue ( $ value , $ selected ) ; $ options = array_merge ( [ 'value' => $ value , 'selected' => $ selected ] , $ attributes ) ; return $ this -> toHtmlString ( '<option' . $ this -> html -> attributes ( $ options ) . '>' . e ( $ display ) . '</option>' ) ; }
3847	protected static function upgradeClosed ( ) { $ objDB = self :: DB ( ) ; if ( $ objDB -> tableExists ( 'tl_metamodel_dca' , null , true ) && ! $ objDB -> fieldExists ( 'iseditable' , 'tl_metamodel_dca' ) ) { TableManipulation :: createColumn ( 'tl_metamodel_dca' , 'iseditable' , 'char(1) NOT NULL default \'\'' ) ; TableManipulation :: createColumn ( 'tl_metamodel_dca' , 'iscreatable' , 'char(1) NOT NULL default \'\'' ) ; TableManipulation :: createColumn ( 'tl_metamodel_dca' , 'isdeleteable' , 'char(1) NOT NULL default \'\'' ) ; $ objDB -> execute ( ' UPDATE tl_metamodel_dca SET iseditable=isclosed^1, iscreatable=isclosed^1, isdeleteable=isclosed^1 ' ) ; TableManipulation :: dropColumn ( 'tl_metamodel_dca' , 'isclosed' , true ) ; } }
6911	public function removeExtraCopy ( Recipient $ copy ) { if ( $ this -> extraCopies -> contains ( $ copy ) ) { $ this -> extraCopies -> removeElement ( $ copy ) ; } return $ this ; }
9774	function satisfy ( callable $ predicate ) : self { return $ this -> expect ( call_user_func ( $ predicate , $ this -> target ) , isTrue ( ) ) ; }
4477	public function untrack ( ) : void { if ( $ this -> client -> call ( 'track' , 'untrack' , $ this -> jid ) ) { $ this -> tracked = false ; } }
11863	public function setHandledDataItem ( $ value ) { if ( isset ( $ this -> _pairedDataItem ) ) { $ this -> pairedDataItem -> handledDataItem = $ value ; } if ( ! $ this -> _handledDataItem && $ value ) { $ this -> dataSource -> reduceRemaining ( $ this ) ; } $ this -> clean ( ) ; return $ this -> _handledDataItem = $ value ; }
4557	public function generateCustomId ( CustomIdentifiable $ entity , bool $ overwrite = false ) { if ( null === $ entity -> getCustomId ( ) || $ overwrite ) { $ customId = uniqid ( ) ; $ entity -> setCustomId ( $ customId ) ; } return $ this ; }
6777	protected function updateVatData ( SaleInterface $ sale ) { $ changed = false ; if ( null !== $ customer = $ sale -> getCustomer ( ) ) { if ( 0 == strlen ( $ sale -> getVatNumber ( ) ) && 0 < strlen ( $ customer -> getVatNumber ( ) ) ) { $ sale -> setVatNumber ( $ customer -> getVatNumber ( ) ) ; $ changed = true ; } if ( empty ( $ sale -> getVatDetails ( ) ) && ! empty ( $ customer -> getVatDetails ( ) ) ) { $ sale -> setVatDetails ( $ customer -> getVatDetails ( ) ) ; $ changed = true ; } if ( ! $ sale -> isVatValid ( ) && $ customer -> isVatValid ( ) ) { $ sale -> setVatValid ( true ) ; $ changed = true ; } } return $ changed ; }
4793	function order ( $ columns ) { $ this -> rows = null ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { if ( $ this -> union ) { $ this -> unionOrder [ ] = $ columns ; } else { $ this -> order [ ] = $ columns ; } } } elseif ( $ this -> union ) { $ this -> unionOrder = array ( ) ; } else { $ this -> order = array ( ) ; } return $ this ; }
6237	private static function getOptions ( ) { return [ '1/6' => Craft :: t ( 'width-fieldtype' , '1/6' ) , '1/5' => Craft :: t ( 'width-fieldtype' , '1/5' ) , '1/4' => Craft :: t ( 'width-fieldtype' , '1/4' ) , '1/3' => Craft :: t ( 'width-fieldtype' , '1/3' ) , '2/5' => Craft :: t ( 'width-fieldtype' , '2/5' ) , '1/2' => Craft :: t ( 'width-fieldtype' , '1/2' ) , '3/5' => Craft :: t ( 'width-fieldtype' , '3/5' ) , '2/3' => Craft :: t ( 'width-fieldtype' , '2/3' ) , '3/4' => Craft :: t ( 'width-fieldtype' , '3/4' ) , '4/5' => Craft :: t ( 'width-fieldtype' , '4/5' ) , '5/6' => Craft :: t ( 'width-fieldtype' , '5/6' ) , 'full' => Craft :: t ( 'width-fieldtype' , 'Full' ) , ] ; }
11822	public function render_admin_header ( ) { $ page = filter_input ( INPUT_GET , 'page' ) ; if ( $ this -> page != $ page ) { return ; } echo '<style type="text/css">' ; echo $ this -> twig -> render ( 'list_table.css.twig' , array ( ) ) ; echo '</style>' ; }
10313	function getClicks ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ formatFilter = null , $ linkIdFilter = null , $ linkUrlFilter = null , $ linkTagFilter = null , $ socialNetworkFilter = null , $ deviceTypeFilter = null , $ embedEmailClientInfos = false , $ excludeAnonymousClicks = false , $ standardFields = null , $ customFields = null , $ embedFieldBackups = false , $ pageIndex = 1 , $ pageSize = 100 , $ embedLinkTags = false ) { $ params = $ this -> createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null , $ embedFieldBackups ) ; $ params = $ this -> appendArrayFields ( $ params , "standard_field" , $ standardFields ) ; $ params = $ this -> appendArrayFields ( $ params , "custom_field" , $ customFields ) ; if ( isset ( $ embedEmailClientInfos ) ) $ params [ 'embed_email_client_infos' ] = ( $ embedEmailClientInfos == true ) ? "true" : "false" ; if ( isset ( $ embedLinkTags ) ) $ params [ 'embed_link_tags' ] = ( $ embedLinkTags == true ) ? "true" : "false" ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; if ( isset ( $ formatFilter ) ) $ params [ 'format' ] = $ formatFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_id" , $ linkIdFilter ) ; if ( isset ( $ linkUrlFilter ) ) $ params [ 'link_url' ] = $ linkUrlFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_tag" , $ linkTagFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "social_network" , $ socialNetworkFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "device_type" , $ deviceTypeFilter ) ; return $ this -> get ( 'reports/clicks' , $ params ) ; }
2016	public function generateMarkup ( ) { $ return = ' <div> <input type="file" name="' . $ this -> strName . '[]" class="tl_upload_field" onfocus="Backend.getScrollOffset()" multiple required> </div>' ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] ) ) { $ return .= ' <p class="tl_help tl_tip">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] , System :: getReadableSize ( static :: getMaxUploadSize ( ) ) , Config :: get ( 'gdMaxImgWidth' ) . 'x' . Config :: get ( 'gdMaxImgHeight' ) ) . '</p>' ; } return $ return ; }
8155	public function addGlobal ( $ name , $ value ) { if ( $ this -> extensionInitialized || $ this -> runtimeInitialized ) { if ( null === $ this -> globals ) { $ this -> globals = $ this -> initGlobals ( ) ; } if ( ! array_key_exists ( $ name , $ this -> globals ) ) { @ trigger_error ( sprintf ( 'Registering global variable "%s" at runtime or when the extensions have already been initialized is deprecated since version 1.21.' , $ name ) , E_USER_DEPRECATED ) ; } } if ( $ this -> extensionInitialized || $ this -> runtimeInitialized ) { $ this -> globals [ $ name ] = $ value ; } else { $ this -> staging -> addGlobal ( $ name , $ value ) ; } }
1877	public function delete ( $ source = null ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ blnDoNotRedirect = ( $ source !== null ) ; if ( $ source === null ) { $ source = $ this -> intId ; } $ this -> isValid ( $ source ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ source ) || ! $ this -> isMounted ( $ source ) ) { throw new AccessDeniedException ( 'File or folder "' . $ source . '" is not mounted or cannot be found.' ) ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'ondelete_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'ondelete_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ source , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ source , $ this ) ; } } } $ this -> import ( Files :: class , 'Files' ) ; if ( is_dir ( $ this -> strRootDir . '/' . $ source ) ) { $ this -> Files -> rrdir ( $ source ) ; $ strWebDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'contao.web_dir' ) ) ; if ( is_link ( $ this -> strRootDir . '/' . $ strWebDir . '/' . $ source ) ) { $ this -> Files -> delete ( $ strWebDir . '/' . $ source ) ; } } else { $ this -> Files -> delete ( $ source ) ; } if ( $ this -> blnIsDbAssisted && Dbafs :: shouldBeSynchronized ( $ source ) ) { Dbafs :: deleteResource ( $ source ) ; } $ this -> log ( 'File or folder "' . $ source . '" has been deleted' , __METHOD__ , TL_FILES ) ; if ( ! $ blnDoNotRedirect ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } }
279	private function notifyNotFound ( $ fixtures ) { $ this -> stdout ( "Some fixtures were not found under path:\n" , Console :: BG_RED ) ; $ this -> stdout ( "\t" . $ this -> getFixturePath ( ) . "\n\n" , Console :: FG_GREEN ) ; $ this -> stdout ( "Check that they have correct namespace \"{$this->namespace}\" \n" , Console :: BG_RED ) ; $ this -> outputList ( $ fixtures ) ; $ this -> stdout ( "\n" ) ; }
7778	protected function extractInput ( array $ data ) { $ input = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ input [ $ field ] = $ fieldData [ 0 ] ; } return $ input ; }
4646	public function compute ( ) { $ dimensions = $ this -> dimensions ; if ( empty ( $ dimensions ) ) { return array ( ) ; } $ values = reset ( $ dimensions ) ; $ name = key ( $ dimensions ) ; unset ( $ dimensions [ $ name ] ) ; $ posibilities = array ( ) ; foreach ( $ values as $ v ) { $ posibilities [ ] = array ( $ name => $ v ) ; } if ( empty ( $ dimensions ) ) { return $ posibilities ; } $ matrix = new Matrix ( ) ; foreach ( $ dimensions as $ name => $ values ) { $ matrix -> setDimension ( $ name , $ values ) ; } $ result = $ matrix -> compute ( ) ; $ newResult = array ( ) ; foreach ( $ result as $ value ) { foreach ( $ posibilities as $ possiblity ) { $ newResult [ ] = $ value + $ possiblity ; } } return $ newResult ; }
1233	private function ensurePropertyType ( $ value ) { $ actualType = gettype ( $ value ) ; if ( 'object' === $ actualType ) { $ actualType = get_class ( $ value ) ; } $ valid = explode ( '|' , $ this -> expectedType ) ; $ isValid = false ; foreach ( $ valid as $ check ) { if ( $ check !== 'any' && \ DTS \ eBaySDK \ checkPropertyType ( $ check ) ) { if ( $ check === $ actualType ) { return ; } $ isValid = false ; } else { $ isValid = true ; } } if ( ! $ isValid ) { throw new Exceptions \ InvalidPropertyTypeException ( $ this -> property , $ this -> expectedType , $ actualType ) ; } }
7495	private static function convertString ( $ string , $ outputEncoding ) { if ( $ string instanceof StringBuilder ) { $ inputEncoding = $ string -> getEncoding ( ) ; } else { $ inputEncoding = mb_detect_encoding ( ( string ) $ string ) ; } $ string = ( string ) $ string ; if ( $ inputEncoding != $ outputEncoding ) { $ string = iconv ( $ inputEncoding , $ outputEncoding , $ string ) ; } return $ string ; }
4723	public function setAttribute ( $ attribute , $ value = null ) { $ this -> attributes -> set ( $ attribute , $ value ) ; return $ this ; }
5468	public function addHeaders ( $ request , $ url ) { if ( $ url -> getUsername ( ) && $ url -> getPassword ( ) ) { $ username = $ url -> getUsername ( ) ; $ password = $ url -> getPassword ( ) ; } elseif ( $ realm = $ this -> findRealmFromUrl ( $ url ) ) { $ username = $ realm -> getUsername ( ) ; $ password = $ realm -> getPassword ( ) ; } else { return ; } $ this -> addBasicHeaders ( $ request , $ username , $ password ) ; }
7608	public function renderListItems ( array $ aDropdownOptions ) { if ( ! isset ( $ aDropdownOptions [ 'items' ] ) ) { throw new LogicException ( __METHOD__ . ' expects "items" option' ) ; } if ( ! is_array ( $ aDropdownOptions [ 'items' ] ) ) { throw new LogicException ( '"items" option expects an array, "' . gettype ( $ aDropdownOptions [ 'items' ] ) . '" given' ) ; } if ( empty ( $ aDropdownOptions [ 'list_attributes' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] = array ( 'class' => 'dropdown-menu' ) ; } else { if ( ! is_array ( $ aDropdownOptions [ 'list_attributes' ] ) ) { throw new \ LogicException ( '"list_attributes" option expects an array, "' . gettype ( $ aDropdownOptions [ 'list_attributes' ] ) . '" given' ) ; } if ( empty ( $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] = 'dropdown-menu' ; } elseif ( ! preg_match ( '/(\s|^)dropdown-menu(\s|$)/' , $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] .= ' dropdown-menu' ; } } if ( empty ( $ aDropdownOptions [ 'list_attributes' ] [ 'role' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'role' ] = 'menu' ; } if ( ! empty ( $ aDropdownOptions [ 'name' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'aria-labelledby' ] = $ aDropdownOptions [ 'name' ] ; } $ sItems = '' ; foreach ( $ aDropdownOptions [ 'items' ] as $ sKey => $ aItemOptions ) { if ( ! is_array ( $ aItemOptions ) ) { if ( ! is_scalar ( $ aItemOptions ) ) { throw new \ LogicException ( 'item option expects an array or a scalar value, "' . gettype ( $ aItemOptions ) . '" given' ) ; } $ aItemOptions = $ aItemOptions === self :: TYPE_ITEM_DIVIDER ? array ( 'type' => self :: TYPE_ITEM_DIVIDER ) : array ( 'label' => $ aItemOptions , 'type' => self :: TYPE_ITEM_LINK , 'item_attributes' => array ( 'href' => is_string ( $ sKey ) ? $ sKey : null ) ) ; } else { if ( ! isset ( $ aItemOptions [ 'label' ] ) ) { $ aItemOptions [ 'label' ] = is_string ( $ sKey ) ? $ sKey : null ; } if ( ! isset ( $ aItemOptions [ 'type' ] ) ) { $ aItemOptions [ 'type' ] = self :: TYPE_ITEM_LINK ; } } $ sItems .= $ this -> renderItem ( $ aItemOptions ) . "\n" ; } return sprintf ( static :: $ dropdownListFormat , $ this -> createAttributesString ( $ aDropdownOptions [ 'list_attributes' ] ) , $ sItems ) ; }
8943	public function diffUploadChangeset ( $ xml , $ id ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/upload' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'POST' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> diffResult ; }
3774	public function getTypeNames ( ) { $ names = $ this -> factories -> ids ( ) ; if ( [ ] !== $ fallback = $ this -> fallbackFactory -> getIds ( ) ) { $ names = array_unique ( array_merge ( $ fallback , $ names ) ) ; } return $ names ; }
8510	public function getTransportContent ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetTransportContentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetTransportContentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetTransportContent' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetTransportContentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6002	public function setVideotemplates ( array $ videotemplates ) { $ this -> videotemplates = [ ] ; foreach ( $ videotemplates as $ item ) { $ this -> addVideoTemplate ( $ item ) ; } return $ this ; }
4350	private function setCopyValues ( $ values ) { if ( isset ( $ values [ 'debug' ] [ 'emailLog' ] ) && $ values [ 'debug' ] [ 'emailLog' ] === true ) { $ values [ 'debug' ] [ 'emailLog' ] = 'onError' ; } foreach ( array ( 'emailFrom' , 'emailFunc' , 'emailTo' ) as $ key ) { if ( isset ( $ values [ 'debug' ] [ $ key ] ) && ! isset ( $ values [ 'errorEmailer' ] [ $ key ] ) ) { $ values [ 'errorEmailer' ] [ $ key ] = $ values [ 'debug' ] [ $ key ] ; } } return $ values ; }
5703	public function bindGridField ( Form $ form , GridFieldDetailForm_ItemRequest $ request ) { $ this -> setForm ( $ form ) ; $ this -> gridFieldRequest = $ request ; return $ this ; }
8631	public function setReportInfoList ( $ reportInfo ) { if ( ! $ this -> _isNumericArray ( $ reportInfo ) ) { $ reportInfo = array ( $ reportInfo ) ; } $ this -> fields [ 'ReportInfo' ] [ 'FieldValue' ] = $ reportInfo ; return $ this ; }
2234	public function showDeletedRecords ( $ data , $ row ) { $ arrData = Contao \ StringUtil :: deserialize ( $ row [ 'data' ] ) ; foreach ( $ arrData as $ strTable => $ arrTableData ) { Contao \ System :: loadLanguageFile ( $ strTable ) ; Contao \ Controller :: loadDataContainer ( $ strTable ) ; foreach ( $ arrTableData as $ arrRow ) { $ arrBuffer = array ( ) ; foreach ( $ arrRow as $ i => $ v ) { if ( \ is_array ( Contao \ StringUtil :: deserialize ( $ v ) ) ) { continue ; } if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ) { $ label = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ; } else { $ label = \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] [ 0 ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ; } if ( ! $ label ) { $ label = $ i ; } $ arrBuffer [ $ label ] = $ v ; } $ data [ $ strTable ] [ ] = $ arrBuffer ; } } return $ data ; }
6587	public function setOpt ( $ name , $ value = null ) { if ( is_array ( $ name ) ) { try { $ i = 0 ; foreach ( $ name as $ opt => $ value ) { $ this -> setOpt ( $ opt , $ value ) ; ++ $ i ; } } catch ( CurlException $ e ) { throw $ e -> getCode ( ) ? $ e : new CurlException ( "Set failed at #$i: " . $ e -> getMessage ( ) ) ; } } else { try { set_error_handler ( function ( $ s , $ m , $ f , $ l , $ c = null ) use ( $ name ) { throw new CurlException ( "$m (" . CurlOptions :: name ( $ name ) . ")." ) ; } , \ E_WARNING ) ; $ this -> perform ( 'curl_setopt' , $ name , $ value ) ; } finally { restore_error_handler ( ) ; } } }
3377	public function postRemind ( ) { \ App :: make ( 'route' ) ; \ Config :: set ( 'auth.defaults.passwords' , 'panel' ) ; $ response = \ Password :: sendResetLink ( Input :: only ( 'email' ) , function ( $ message ) { $ message -> subject ( 'Password Reminder' ) ; } ) ; switch ( $ response ) { case PasswordBrokerContract :: INVALID_USER : return \ Redirect :: back ( ) -> with ( 'message' , \ Lang :: get ( $ response ) ) -> with ( 'mesType' , 'error' ) ; case PasswordBrokerContract :: RESET_LINK_SENT : return \ Redirect :: back ( ) -> with ( 'message' , \ Lang :: get ( $ response ) ) -> with ( 'mesType' , 'info' ) ; } }
3217	function chunkedUploadContinue ( $ uploadId , $ byteOffset , $ data ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Checker :: argNat ( "byteOffset" , $ byteOffset ) ; Checker :: argString ( "data" , $ data ) ; $ response = $ this -> _chunkedUpload ( array ( "upload_id" => $ uploadId , "offset" => $ byteOffset ) , $ data ) ; if ( $ response -> statusCode === 404 ) { return false ; } $ correction = self :: _chunkedUploadCheckForOffsetCorrection ( $ response ) ; if ( $ correction !== null ) { list ( $ correctedUploadId , $ correctedByteOffset ) = $ correction ; if ( $ correctedUploadId !== $ uploadId ) throw new Exception_BadResponse ( "Corrective 400 upload_id mismatch: us=" . Util :: q ( $ uploadId ) . " server=" . Util :: q ( $ correctedUploadId ) ) ; if ( $ correctedByteOffset === $ byteOffset ) throw new Exception_BadResponse ( "Corrective 400 offset is the same as ours: $byteOffset" ) ; return $ correctedByteOffset ; } if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; list ( $ retUploadId , $ retByteOffset ) = self :: _chunkedUploadParse200Response ( $ response -> body ) ; $ nextByteOffset = $ byteOffset + strlen ( $ data ) ; if ( $ uploadId !== $ retUploadId ) throw new Exception_BadResponse ( "upload_id mismatch: us=" . Util :: q ( $ uploadId ) . ", server=" . Util :: q ( $ uploadId ) ) ; if ( $ nextByteOffset !== $ retByteOffset ) throw new Exception_BadResponse ( "next-offset mismatch: us=$nextByteOffset, server=$retByteOffset" ) ; return true ; }
746	protected function buildDefaultString ( ) { if ( $ this -> default === null ) { return $ this -> isNotNull === false ? ' DEFAULT NULL' : '' ; } $ string = ' DEFAULT ' ; switch ( gettype ( $ this -> default ) ) { case 'integer' : $ string .= ( string ) $ this -> default ; break ; case 'double' : $ string .= StringHelper :: floatToString ( $ this -> default ) ; break ; case 'boolean' : $ string .= $ this -> default ? 'TRUE' : 'FALSE' ; break ; case 'object' : $ string .= ( string ) $ this -> default ; break ; default : $ string .= "'{$this->default}'" ; } return $ string ; }
4931	public function updateValues ( ) { $ values = [ ] ; foreach ( $ this -> getItems ( ) as $ item ) { if ( ! is_null ( $ item ) ) { $ values [ ] = $ item -> getValueWithParents ( ) ; } } $ this -> values = $ values ; }
11708	public function actionCreate ( ) { $ user = \ Yii :: createObject ( [ 'class' => User :: className ( ) , 'scenario' => 'create' , ] ) ; $ this -> performAjaxValidation ( $ user ) ; if ( $ user -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ user -> create ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been created' ) ) ; return $ this -> redirect ( [ 'index' ] ) ; } return $ this -> render ( 'create' , [ 'user' => $ user ] ) ; }
7997	public static function getSpecificationString ( $ reversed = false ) { $ reflection = new ReflectionClass ( get_class ( ) ) ; $ constants = $ reflection -> getConstants ( ) ; if ( $ reversed ) { $ constants = array_reverse ( $ constants ) ; } $ string = '' ; foreach ( $ constants as $ name => $ int_val ) { $ binary_val_string = base_convert ( ( string ) $ int_val , '10' , '2' ) ; $ string .= sprintf ( '0b%s : %s' , str_pad ( $ binary_val_string , 32 , '0' , STR_PAD_LEFT ) , $ name ) ; $ string .= PHP_EOL ; } return $ string ; }
2334	public function onSwitchUser ( SwitchUserEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { throw new \ RuntimeException ( 'The token storage did not contain a token.' ) ; } $ sourceUser = $ token -> getUser ( ) ; if ( $ sourceUser instanceof UserInterface ) { $ sourceUser = $ sourceUser -> getUsername ( ) ; } $ targetUser = $ event -> getTargetUser ( ) ; if ( $ targetUser instanceof UserInterface ) { $ targetUser = $ targetUser -> getUsername ( ) ; } $ this -> logger -> info ( sprintf ( 'User "%s" has switched to user "%s"' , $ sourceUser , $ targetUser ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ sourceUser ) ] ) ; }
1703	protected function getLink ( $ objItem , $ strUrl , $ strBase = '' ) { switch ( $ objItem -> source ) { case 'external' : return $ objItem -> url ; break ; case 'internal' : if ( ( $ objTarget = $ objItem -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { return $ objTarget -> getAbsoluteUrl ( ) ; } break ; case 'article' : if ( ( $ objArticle = ArticleModel :: findByPk ( $ objItem -> articleId ) ) instanceof ArticleModel && ( $ objPid = $ objArticle -> getRelated ( 'pid' ) ) instanceof PageModel ) { return ampersand ( $ objPid -> getAbsoluteUrl ( '/articles/' . ( $ objArticle -> alias ? : $ objArticle -> id ) ) ) ; } break ; } if ( $ strBase != '' && ! preg_match ( '#^https?://#' , $ strUrl ) ) { $ strUrl = $ strBase . $ strUrl ; } return sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItem -> alias ? : $ objItem -> id ) ) ; }
5086	public function startTransaction ( ) : bool { if ( $ this -> isInTransaction ) throw new AlreadyInTransactionException ( ) ; $ this -> isInTransaction = $ this -> executeDirect ( 'START TRANSACTION' ) ; return $ this -> isInTransaction ; }
8045	public static function select ( array $ readSockets = array ( ) , array $ writeSockets = array ( ) , array $ exceptSockets = array ( ) , $ sec = 0 , $ usec = 0 ) { $ out = array ( ) ; $ out [ 'read' ] = array ( ) ; $ out [ 'write' ] = array ( ) ; $ out [ 'except' ] = array ( ) ; if ( count ( $ readSockets ) === 0 ) { return $ out ; } $ readSocketsResources = array ( ) ; $ writeSocketsResources = array ( ) ; $ exceptSocketsResources = array ( ) ; $ readSockets = self :: createSocketsIndex ( $ readSockets , $ readSocketsResources ) ; $ writeSockets = self :: createSocketsIndex ( $ writeSockets , $ writeSocketsResources ) ; $ exceptSockets = self :: createSocketsIndex ( $ exceptSockets , $ exceptSocketsResources ) ; $ socketsSelected = @ socket_select ( $ readSocketsResources , $ writeSocketsResources , $ exceptSocketsResources , $ sec , $ usec ) ; if ( $ socketsSelected === FALSE ) { $ socketError = socket_last_error ( ) ; if ( $ socketError === SOCKET_EINTR ) { socket_clear_error ( ) ; $ socketsSelected = socket_select ( $ readSocketsResources , $ writeSocketsResources , $ exceptSocketsResources , $ sec , $ usec ) ; if ( $ socketsSelected === FALSE ) { return $ out ; } } else { trigger_error ( sprintf ( 'socket_select(): unable to select [%d]: %s' , $ socketError , socket_strerror ( $ socketError ) ) , E_USER_WARNING ) ; return $ out ; } } foreach ( $ readSocketsResources as $ socketResource ) { $ out [ 'read' ] [ ] = $ readSockets [ intval ( $ socketResource ) ] ; } foreach ( $ writeSocketsResources as $ socketResource ) { $ out [ 'write' ] [ ] = $ writeSockets [ intval ( $ socketResource ) ] ; } foreach ( $ exceptSocketsResources as $ socketResource ) { $ out [ 'except' ] [ ] = $ exceptSockets [ intval ( $ socketResource ) ] ; } return $ out ; }
2480	protected function mapSearchFieldValue ( $ value , FieldType $ searchFieldType = null ) { if ( null === $ searchFieldType ) { return $ value ; } $ searchField = new SearchField ( 'field' , $ value , $ searchFieldType ) ; $ value = ( array ) $ this -> fieldValueMapper -> map ( $ searchField ) ; return current ( $ value ) ; }
11121	protected function pendingMigrations ( array $ files , array $ ran ) : array { $ array = [ ] ; foreach ( $ files as $ file ) { if ( ! in_array ( $ this -> getMigrationName ( $ file ) , $ ran , true ) ) { $ array [ ] = $ file ; } } return $ array ; }
9730	public function setMaxParcelDimensions ( $ value = null ) { if ( is_array ( $ value ) ) { $ value = new ParcelDimensions ( $ value ) ; } elseif ( ! ( $ value instanceof ParcelDimensions ) ) { $ value = null ; } return $ this -> setParameter ( 'max_parcel_dimensions' , $ value ) ; }
8754	public function start ( $ block = true , $ interval = 100 ) { $ loop = $ this -> loop ; $ this -> pool = new ParallelPool ( function ( ) use ( $ loop ) { $ loop -> run ( ) ; } , $ this -> count ) ; $ this -> pool -> start ( ) ; $ this -> pool -> keep ( $ block , $ interval ) ; }
5345	public function requestAccess ( $ when , $ duration , array $ visitors , $ phoneNumber ) { return $ this -> call ( self :: SERVICE , 'requestAccess' , [ $ when , $ duration , $ visitors , $ phoneNumber ] ) ; }
9929	protected function handleUnpermittedParam ( $ key , $ params ) { if ( $ this -> getThrowExceptions ( ) ) { $ message = "Parameter '$key' is not allowed" ; throw new UnpermittedParameterException ( $ message ) ; } $ params -> delete ( $ key ) ; }
2778	public function cloneRepository ( string $ repository , ? string $ directory = null , array $ options = [ ] ) : GitWorkingCopy { if ( $ directory === null ) { $ directory = self :: parseRepositoryName ( $ repository ) ; } $ git = $ this -> workingCopy ( $ directory ) ; $ git -> cloneRepository ( $ repository , $ options ) ; $ git -> setCloned ( true ) ; return $ git ; }
10300	private function writeBubbles ( $ plotSeriesValues , $ objWriter ) { if ( $ plotSeriesValues === null ) { return ; } $ objWriter -> startElement ( 'c:bubbleSize' ) ; $ objWriter -> startElement ( 'c:numLit' ) ; $ objWriter -> startElement ( 'c:formatCode' ) ; $ objWriter -> writeRawData ( 'General' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:ptCount' ) ; $ objWriter -> writeAttribute ( 'val' , $ plotSeriesValues -> getPointCount ( ) ) ; $ objWriter -> endElement ( ) ; $ dataValues = $ plotSeriesValues -> getDataValues ( ) ; if ( ! empty ( $ dataValues ) ) { if ( is_array ( $ dataValues ) ) { foreach ( $ dataValues as $ plotSeriesKey => $ plotSeriesValue ) { $ objWriter -> startElement ( 'c:pt' ) ; $ objWriter -> writeAttribute ( 'idx' , $ plotSeriesKey ) ; $ objWriter -> startElement ( 'c:v' ) ; $ objWriter -> writeRawData ( 1 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; } } } $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:bubble3D' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; }
11812	public static function setPointInLog ( string $ sName = 'default' ) { $ oLogger = Debug :: getInstance ( ) ; $ oLogger -> info ( 'BENCHMARK: Time at this point ' . ( microtime ( true ) - self :: $ _fStart ) . ' - ' . $ sName ) ; }
9233	public function actionCreate ( ) { $ model = new Post ( ) ; $ model -> time = date ( "Y-m-d H:i:s" ) ; $ model -> author_id = Yii :: $ app -> user -> id ; $ model -> isdel = 0 ; if ( Yii :: $ app -> request -> post ( ) ) { $ post = Yii :: $ app -> request -> post ( ) ; $ category = [ ] ; if ( isset ( $ post [ 'Post' ] [ 'category' ] ) ) { $ category = $ post [ 'Post' ] [ 'category' ] ; } if ( is_array ( $ post [ 'Post' ] [ 'tags' ] ) ) { $ post [ 'Post' ] [ 'tags' ] = implode ( "," , $ post [ 'Post' ] [ 'tags' ] ) ; } $ model -> load ( $ post ) ; $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> save ( ) ) { $ cs = BlogCatPos :: deleteAll ( "post_id = :id" , [ "id" => $ model -> id ] ) ; foreach ( $ category as $ d ) { $ c = new BlogCatPos ( ) ; $ c -> post_id = $ model -> id ; $ c -> category_id = $ d ; $ c -> isdel = 0 ; $ c -> save ( ) ; } $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ model -> id = array_merge ( $ category , [ ] ) ; $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } } return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; }
4983	public function getIterator ( ) { $ iterator = new PriorityList ( ) ; $ iterator -> isLIFO ( false ) ; foreach ( $ this -> activeForms as $ key ) { $ spec = $ this -> forms [ $ key ] ; $ priority = isset ( $ spec [ 'priority' ] ) ? $ spec [ 'priority' ] : 0 ; $ iterator -> insert ( $ key , $ this -> getForm ( $ key ) , $ priority ) ; } return $ iterator ; }
9104	protected function parse_user ( ) { if ( ! empty ( $ this -> args [ 'user' ] ) ) { $ this -> args [ 'user__in' ] = array ( $ this -> args [ 'user' ] ) ; } return $ this -> parse_in_or_not_in_query ( 'user' , $ this -> args [ 'user__in' ] , $ this -> args [ 'user__not_in' ] ) ; }
430	public function getBasePath ( ) { if ( $ this -> _basePath === null ) { $ class = new \ ReflectionClass ( $ this ) ; $ this -> _basePath = dirname ( $ class -> getFileName ( ) ) ; } return $ this -> _basePath ; }
7452	protected function renderRTL ( ) : string { $ trail = '' ; if ( $ this -> after ) { $ trail .= '<span class="after">' . $ this -> after . '</span> ' ; } $ trail .= \ join ( ' <span class="sep delimiter">' . $ this -> delimiter . '</span> ' , \ array_reverse ( $ this -> links ) ) ; if ( $ this -> before ) { $ trail .= ' <span class="before">' . $ this -> before . '</span>' ; } return $ trail ; }
11461	public static function enable ( $ state = true , $ enable_assert = false ) { $ state = ( bool ) $ state ; self :: enableAssert ( ( bool ) $ enable_assert ) ; if ( $ state && self :: $ _enabled || ! $ state && ! self :: $ _enabled ) { return ; } if ( $ state ) { set_exception_handler ( __CLASS__ . '::exception' ) ; set_error_handler ( __CLASS__ . '::error' , error_reporting ( ) ) ; assert_options ( ASSERT_CALLBACK , __CLASS__ . '::assert' ) ; self :: $ _enabled = true ; } else { restore_exception_handler ( ) ; restore_error_handler ( ) ; assert_options ( ASSERT_CALLBACK , function ( ) { } ) ; self :: $ _enabled = false ; } }
5833	protected function headerToArray ( $ header ) { $ tmp = explode ( "\r\n" , $ header ) ; $ headers = array ( ) ; foreach ( $ tmp as $ singleHeader ) { $ delimiter = strpos ( $ singleHeader , ': ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 2 ) ; $ headers [ $ key ] = $ val ; } else { $ delimiter = strpos ( $ singleHeader , ' ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 1 ) ; $ headers [ $ key ] = $ val ; } } } return $ headers ; }
1493	public function index ( $ resourceType , $ meta = null , array $ queryParams = [ ] ) { return $ this -> factory -> createLink ( $ this -> urls -> index ( $ resourceType , $ queryParams ) , $ meta , true ) ; }
5659	private function indexWidgetById ( $ widget ) { $ id = $ widget -> getAttribute ( 'id' ) ; if ( ! $ id ) { return ; } if ( ! isset ( $ this -> widgets_by_id [ $ id ] ) ) { $ this -> widgets_by_id [ $ id ] = array ( ) ; } $ this -> widgets_by_id [ $ id ] [ ] = $ widget ; }
2604	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ checkIfSettingExists = $ this -> api -> hasSnippet ( $ activeVersion , Config :: WAF_SETTING_NAME ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> config -> getWafAllowByAcl ( ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; if ( ! $ checkIfSettingExists ) { foreach ( $ snippet as $ key => $ value ) { if ( $ strippedAllowedItems === '' ) { $ value = '' ; } else { $ value = str_replace ( '####WAF_ALLOWLIST####' , $ strippedAllowedItems , $ value ) ; } $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key , 'type' => $ key , 'dynamic' => 1 , 'priority' => 10 , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } } else { foreach ( $ snippet as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key ; if ( $ this -> api -> hasSnippet ( $ clone -> number , $ name ) == true ) { $ this -> api -> removeSnippet ( $ clone -> number , $ name ) ; } } } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ this -> sendWebhook ( $ checkIfSettingExists , $ clone ) ; $ comment = [ 'comment' => 'Magento Module turned ON WAF ACL Bypass' ] ; if ( $ checkIfSettingExists ) { $ comment = [ 'comment' => 'Magento Module turned OFF WAF ACL Bypass' ] ; } $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
3038	public function get ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; if ( ! isset ( $ this -> cache [ $ key ] ) ) { $ data = $ this -> getStorage ( ) -> get ( $ userId , $ callId ) ; $ state = is_null ( $ data ) ? self :: STATE_NOT_FOUND : self :: STATE_ALIGNED ; $ this -> putInCache ( $ key , $ userId , $ callId , $ data , $ state ) ; } return $ this -> getFromCache ( $ key ) ; }
4569	protected function cast ( $ element ) { if ( $ element instanceof Permission ) { return $ element ; } if ( ! is_array ( $ element ) ) { throw new InvalidArgumentException ( 'Element is not an array.' ) ; } foreach ( [ 'attributes' , 'type' , 'value' , 'title' ] as $ key ) { if ( ! array_key_exists ( $ key , $ element ) ) { throw new InvalidArgumentException ( 'Element is missing key "' . $ key . '".' ) ; } } $ permission = new Permission ( $ element [ 'key' ] , $ element [ 'attributes' ] , $ element [ 'type' ] , $ element [ 'value' ] , $ element [ 'title' ] ) ; return $ permission ; }
2328	public function save ( ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } $ this -> arrModels [ $ this -> intIndex ] -> save ( ) ; return $ this ; }
4041	public function render ( ModelToLabelEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ viewSection = $ definition -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; $ listing = $ viewSection -> getListingConfig ( ) ; $ model = $ event -> getModel ( ) ; if ( ! ( $ model instanceof Model ) ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; if ( ! $ renderSetting ) { return ; } $ data = array ( $ nativeItem -> parseValue ( 'html5' , $ renderSetting ) ) ; if ( $ listing -> getShowColumns ( ) ) { $ event -> setArgs ( $ data [ 0 ] [ 'html5' ] ) ; return ; } $ template = new Template ( $ renderSetting -> get ( 'template' ) ) ; $ renderSetting = self :: removeInvariantAttributes ( $ nativeItem , $ renderSetting ) ; $ template -> setData ( array ( 'settings' => $ renderSetting , 'items' => new Items ( array ( $ nativeItem ) ) , 'view' => $ renderSetting , 'data' => $ data ) ) ; $ event -> setLabel ( '%s' ) -> setArgs ( array ( $ template -> parse ( 'html5' ) ) ) ; }
8085	public function addPredefinedError ( $ id , $ message = '' ) { if ( is_array ( $ id ) ) { $ this -> errorList = array_diff_key ( $ this -> errorList , $ id ) + $ id ; } else { $ this -> errorList [ $ id ] = $ message ; } }
8452	protected function checkUrlExistsAndSize ( $ fileUri , array $ mediaFileInfo ) { $ mediaFileInfo [ 'url' ] = $ fileUri ; $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , "$fileUri" ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11" ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_HEADER , false ) ; curl_setopt ( $ curl , CURLOPT_NOBODY , true ) ; if ( curl_exec ( $ curl ) === false ) { return false ; } $ info = curl_getinfo ( $ curl ) ; $ mediaFileInfo [ 'filesize' ] = $ info [ 'download_content_length' ] ; $ mediaFileInfo [ 'filemimetype' ] = $ info [ 'content_type' ] ; $ mediaFileInfo [ 'fileextension' ] = pathinfo ( parse_url ( $ mediaFileInfo [ 'url' ] , PHP_URL_PATH ) , PATHINFO_EXTENSION ) ; curl_close ( $ curl ) ; return $ mediaFileInfo ; }
7987	public function setSnapshotProperties ( $ domain , array $ properties ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ properties || ! is_array ( $ properties ) || count ( $ properties ) == 0 ) throw new BadMethodCallException ( 'Parameter $properties must be a non empty array.' ) ; $ qr = '' ; foreach ( $ properties as $ k => $ v ) { $ qr .= $ k . '=' . $ v . '&' ; } $ qr = substr ( $ qr , 0 , strlen ( $ qr ) - 1 ) ; try { $ r = $ this -> put ( 'vps/' . $ domain . '/snapshot/?' . $ qr ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r ; }
2332	public function validator ( $ varInput ) { if ( ! \ is_array ( $ varInput ) ) { return null ; } foreach ( $ varInput as $ k => $ v ) { if ( $ k != 'language' ) { $ varInput [ $ k ] = array_map ( 'trim' , $ v ) ; } else { if ( $ v != '' ) { $ varInput [ $ v ] = array_combine ( array_keys ( $ this -> metaFields ) , array_fill ( 0 , \ count ( $ this -> metaFields ) , '' ) ) ; } unset ( $ varInput [ $ k ] ) ; } } return $ varInput ; }
10233	public function edit ( $ id ) { $ user = User :: findOrFail ( $ id ) ; $ roles = Role :: lists ( 'name' , 'id' ) ; return view ( 'intothesource.usersmanager.users.edit' , compact ( 'user' , 'roles' ) ) ; }
8741	protected function i18nDeleteQuery ( $ withGlobalScopes = true ) { $ subQuery = $ withGlobalScopes ? $ this -> toBase ( ) : $ this -> getQuery ( ) ; $ subQuery -> select ( $ this -> model -> getQualifiedKeyName ( ) ) ; return $ this -> i18nQuery ( ) -> whereIn ( $ this -> model -> getForeignKey ( ) , $ subQuery -> pluck ( $ this -> model -> getKeyName ( ) ) ) ; }
9773	function readable ( ) : self { if ( ! $ this -> hasFlag ( 'directory' ) && ! $ this -> hasFlag ( 'file' ) ) throw new \ BadMethodCallException ( 'This assertion is not a file or directory one.' ) ; return $ this -> expect ( $ this -> target , isReadable ( ) ) ; }
550	public function actionIndex ( ) { $ caches = $ this -> findCaches ( ) ; if ( ! empty ( $ caches ) ) { $ this -> notifyCachesCanBeFlushed ( $ caches ) ; } else { $ this -> notifyNoCachesFound ( ) ; } }
2815	public function addCollection ( Varien_Data_Collection_Db $ collection ) { $ info = Mage :: getModel ( 'sheep_debug/collection' ) ; $ info -> init ( $ collection ) ; $ key = $ info -> getClass ( ) ; if ( ! array_key_exists ( $ key , $ this -> collections ) ) { $ this -> collections [ $ key ] = $ info ; } $ this -> collections [ $ key ] -> incrementCount ( ) ; }
11049	function parse_info ( $ info ) { $ elements = explode ( ':' , $ info ) ; $ count = count ( $ elements ) ; if ( $ count > 4 ) { for ( $ i = 4 ; $ i < $ count ; ++ $ i ) { $ elements [ 3 ] .= ':' . $ elements [ $ i ] ; } } else { $ elements = array_pad ( $ elements , 4 , '' ) ; } return array ( $ elements [ 0 ] , $ elements [ 2 ] , $ elements [ 3 ] ) ; }
2976	public function serialize ( ) { try { $ this -> data = $ this -> data ? : $ this -> serializer -> getData ( $ this -> closure , true ) ; return serialize ( $ this -> data ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Serialization of closure failed: ' . $ e -> getMessage ( ) , E_USER_NOTICE ) ; return null ; } }
5228	public static function createInjector ( callable ... $ applyBindings ) { $ self = new self ( ) ; foreach ( $ applyBindings as $ applyBinding ) { $ applyBinding ( $ self ) ; } return $ self -> getInjector ( ) ; }
7214	public function debit ( $ account , $ amount , \ DateTime $ date ) { $ data = [ $ this -> date , $ account , $ this -> identity , null , $ amount , $ this -> number , $ date -> format ( 'Y-m-d' ) , ] ; if ( false === fputcsv ( $ this -> handle , $ data , ';' , '"' ) ) { throw new RuntimeException ( "Failed to write line." ) ; } }
2320	public static function create ( $ image , $ size = null ) { @ trigger_error ( 'Using Image::create() has been deprecated and will no longer work in Contao 5.0. Use the contao.image.image_factory service instead.' , E_USER_DEPRECATED ) ; if ( \ is_string ( $ image ) ) { $ image = new File ( rawurldecode ( $ image ) ) ; } $ imageObj = new static ( $ image ) ; if ( \ is_array ( $ size ) && ! empty ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ size = ( int ) $ size [ 2 ] ; } if ( \ is_array ( $ size ) ) { $ size += array ( 0 , 0 , 'crop' ) ; $ imageObj -> setTargetWidth ( $ size [ 0 ] ) -> setTargetHeight ( $ size [ 1 ] ) -> setResizeMode ( $ size [ 2 ] ) ; } elseif ( ( $ imageSize = ImageSizeModel :: findByPk ( $ size ) ) !== null ) { $ imageObj -> setTargetWidth ( $ imageSize -> width ) -> setTargetHeight ( $ imageSize -> height ) -> setResizeMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; } $ fileRecord = FilesModel :: findByPath ( $ image -> path ) ; if ( $ fileRecord !== null && $ fileRecord -> importantPartWidth && $ fileRecord -> importantPartHeight ) { $ imageObj -> setImportantPart ( array ( 'x' => ( int ) $ fileRecord -> importantPartX , 'y' => ( int ) $ fileRecord -> importantPartY , 'width' => ( int ) $ fileRecord -> importantPartWidth , 'height' => ( int ) $ fileRecord -> importantPartHeight , ) ) ; } return $ imageObj ; }
8371	protected function shutdown ( ) { $ this -> shutdown = true ; $ this -> args [ 'messages' ] = array_filter ( $ this -> messages , function ( $ message ) { if ( ! isset ( $ message [ 'sent' ] ) || $ message [ 'sent' ] === false ) { return $ message ; } } ) ; $ redis = new Redis ; $ client = new Client ( $ redis ) ; $ client -> push ( static :: class , $ this -> args , 1 , 100 ) ; return true ; }
2322	public static function getPixelValue ( $ size ) { @ trigger_error ( 'Using Image::getPixelValue() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ value = preg_replace ( '/[^0-9.-]+/' , '' , $ size ) ; $ unit = preg_replace ( '/[^acehimnprtvwx%]/' , '' , $ size ) ; switch ( $ unit ) { case '' : case 'px' : return ( int ) round ( $ value ) ; break ; case 'em' : return ( int ) round ( $ value * 16 ) ; break ; case 'ex' : return ( int ) round ( $ value * 16 / 2 ) ; break ; case 'pt' : return ( int ) round ( $ value * 16 / 12 ) ; break ; case 'pc' : return ( int ) round ( $ value * 16 ) ; break ; case 'in' : return ( int ) round ( $ value * 16 * 6 ) ; break ; case 'cm' : return ( int ) round ( $ value * 16 / ( 2.54 / 6 ) ) ; break ; case 'mm' : return ( int ) round ( $ value * 16 / ( 25.4 / 6 ) ) ; break ; case '%' : return ( int ) round ( $ value * 16 / 100 ) ; break ; } return 0 ; }
989	public function save ( ) { if ( ! $ this -> response ) { throw new Exception ( 'No activation response was recieved.' ) ; } $ planCharge = $ this -> shop -> planCharge ( ) ; if ( $ planCharge && ! $ planCharge -> isDeclined ( ) && ! $ planCharge -> isCancelled ( ) ) { $ planCharge -> cancel ( ) ; } $ charge = Charge :: firstOrNew ( [ 'charge_id' => $ this -> chargeId , 'shop_id' => $ this -> shop -> id , ] ) ; $ charge -> plan_id = $ this -> plan -> id ; $ charge -> type = $ this -> plan -> type ; $ charge -> status = $ this -> response -> status ; if ( $ this -> plan -> isType ( Plan :: PLAN_RECURRING ) ) { $ charge -> billing_on = $ this -> response -> billing_on ; $ charge -> trial_ends_on = $ this -> response -> trial_ends_on ; } $ charge -> activated_on = $ this -> response -> activated_on ?? Carbon :: today ( ) -> format ( 'Y-m-d' ) ; $ planDetails = $ this -> chargeParams ( ) ; unset ( $ planDetails [ 'return_url' ] ) ; foreach ( $ planDetails as $ key => $ value ) { $ charge -> { $ key } = $ value ; } return $ charge -> save ( ) ; }
6320	public function getColumn ( $ name ) { foreach ( $ this -> columns as $ column ) { if ( $ column -> getName ( ) == $ name ) { return $ column ; } } return null ; }
12366	public function getNextVideoToConvert ( ) { $ query = $ this -> createQueryBuilder ( 'v' ) ; $ this -> onlyUploaded ( $ query ) ; return $ query -> getQuery ( ) -> getOneOrNullResult ( ) ; }
2983	protected function makePathRelative ( $ absolutePath ) { $ projectRootDir = dirname ( $ this -> getContainer ( ) -> getParameter ( 'kernel.root_dir' ) ) ; return str_replace ( $ projectRootDir . '/' , '' , realpath ( $ absolutePath ) ? : $ absolutePath ) ; }
9413	public static function instance ( array $ server ) { $ secure = isset ( $ server [ 'HTTPS' ] ) ? $ server [ 'HTTPS' ] : 'off' ; $ http = $ secure === 'off' ? 'http' : 'https' ; $ url = $ http . '://' . $ server [ 'SERVER_NAME' ] ; $ url .= ( string ) $ server [ 'SERVER_PORT' ] ; return new Uri ( $ url . $ server [ 'REQUEST_URI' ] ) ; }
7169	public function resolveSaleTaxRule ( SaleInterface $ sale ) : ? TaxRuleInterface { return $ this -> resolveTaxRule ( $ this -> resolveTargetCountry ( $ sale ) , $ sale -> isBusiness ( ) ) ; }
7650	public function unlink ( $ path ) { $ this -> getStorageClient ( $ path ) -> deleteBlob ( $ this -> getContainerName ( $ path ) , $ this -> getFileName ( $ path ) ) ; clearstatcache ( true , $ path ) ; return true ; }
679	protected function validateCondition ( $ condition ) { if ( ! is_array ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'invalidFilter' ) ) ; return ; } if ( empty ( $ condition ) ) { return ; } foreach ( $ condition as $ key => $ value ) { $ method = 'validateAttributeCondition' ; if ( isset ( $ this -> filterControls [ $ key ] ) ) { $ controlKey = $ this -> filterControls [ $ key ] ; if ( isset ( $ this -> conditionValidators [ $ controlKey ] ) ) { $ method = $ this -> conditionValidators [ $ controlKey ] ; } } $ this -> $ method ( $ key , $ value ) ; } }
11490	public function destroyWithCookie ( ) : ? bool { if ( $ this -> isStarted ( ) ) { $ this -> destroy ( ) ; return setcookie ( $ this -> getName ( ) , '' , time ( ) - 1 , '/' ) ; } return null ; }
8296	public function write ( $ data ) { if ( ! is_string ( $ data ) ) { throw new \ InvalidArgumentException ( "The data is not a string." ) ; } $ this -> open ( ) ; if ( ! ftruncate ( $ this -> handle , 0 ) ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not truncate file " . $ this -> filePath ) ; } fseek ( $ this -> handle , 0 ) ; $ res = fwrite ( $ this -> handle , $ data ) ; if ( strlen ( $ data ) !== $ res ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not write to file " . $ this -> filePath ) ; } }
1708	public static function removeEntry ( $ strUrl ) { $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT id FROM tl_search WHERE url=?" ) -> execute ( $ strUrl ) ; while ( $ objResult -> next ( ) ) { $ objDatabase -> prepare ( "DELETE FROM tl_search WHERE id=?" ) -> execute ( $ objResult -> id ) ; $ objDatabase -> prepare ( "DELETE FROM tl_search_index WHERE pid=?" ) -> execute ( $ objResult -> id ) ; } }
5256	public function setParent ( ElasticsearchModel $ parent ) { $ this -> _parent = $ parent ; $ this -> setParentId ( $ parent -> getId ( ) ) ; }
4975	private function findOrCreateChild ( $ tree , $ id ) { foreach ( $ tree -> getChildren ( ) as $ node ) { if ( $ id && $ node -> getId ( ) == $ id ) { return $ node ; } } $ nodeClass = get_class ( $ tree ) ; $ node = new $ nodeClass ( ) ; $ tree -> addChild ( $ node ) ; return $ node ; }
3157	public function storeResponseVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getResponseVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
3183	private function durationToMs ( $ duration ) { if ( ! is_null ( $ duration ) && $ duration instanceof QtiDuration ) { return TestRunnerUtils :: getDurationWithMicroseconds ( $ duration ) ; } return false ; }
5486	public function submitButton ( SelectorInterface $ selector , $ additional = false ) { $ additional = $ additional ? $ additional : array ( ) ; foreach ( $ this -> buttons as $ button ) { if ( $ selector -> isMatch ( $ button ) ) { $ encoding = $ this -> encode ( ) ; $ button -> write ( $ encoding ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; } } return false ; }
11374	private function getInjectHint ( \ ReflectionMethod $ method , \ ReflectionParameter $ parameter ) { $ hint = Psi :: it ( $ this -> reader -> getMethodAnnotations ( $ method ) ) -> filter ( new IsInstanceOf ( Di \ DiInjectHintAnnotation :: class ) ) -> filter ( function ( Di \ DiInjectHintAnnotation $ i ) use ( $ parameter ) { return $ i -> getParameter ( ) === $ parameter -> getName ( ) ; } ) -> getFirst ( ) ; if ( $ hint !== null ) { return $ hint ; } try { if ( $ parameter -> getClass ( ) === null ) { throw new \ InvalidArgumentException ( "Cannot inject constructor-param '{$parameter->getName()}' into {$method->getDeclaringClass()->getName()}. " . 'The parameter does not have a an @Inject hint and it has no type-hint.' ) ; } } catch ( \ ReflectionException $ e ) { } return Di \ Inject \ ByType :: create ( $ parameter -> getName ( ) , Util :: normalizeFqcn ( ( string ) $ parameter -> getType ( ) ) ) ; }
5794	private function addBooleanColumnFalse ( array $ columnValues ) : array { foreach ( $ this -> getBooleanColumnNames ( ) as $ booleanColumnName ) { if ( ! isset ( $ columnValues [ $ booleanColumnName ] ) ) { $ columnValues [ $ booleanColumnName ] = Postgres :: BOOLEAN_FALSE ; } } return $ columnValues ; }
312	public function run ( ) { try { $ this -> state = self :: STATE_BEFORE_REQUEST ; $ this -> trigger ( self :: EVENT_BEFORE_REQUEST ) ; $ this -> state = self :: STATE_HANDLING_REQUEST ; $ response = $ this -> handleRequest ( $ this -> getRequest ( ) ) ; $ this -> state = self :: STATE_AFTER_REQUEST ; $ this -> trigger ( self :: EVENT_AFTER_REQUEST ) ; $ this -> state = self :: STATE_SENDING_RESPONSE ; $ response -> send ( ) ; $ this -> state = self :: STATE_END ; return $ response -> exitStatus ; } catch ( ExitException $ e ) { $ this -> end ( $ e -> statusCode , isset ( $ response ) ? $ response : null ) ; return $ e -> statusCode ; } }
9708	private function writeShortNameBiff8 ( $ name , $ sheetIndex , $ rangeBounds , $ isHidden = false ) { $ record = 0x0018 ; $ options = ( $ isHidden ? 0x21 : 0x00 ) ; $ extra = pack ( 'Cvvvvv' , 0x3B , $ sheetIndex - 1 , $ rangeBounds [ 0 ] [ 1 ] - 1 , $ rangeBounds [ 1 ] [ 1 ] - 1 , $ rangeBounds [ 0 ] [ 0 ] - 1 , $ rangeBounds [ 1 ] [ 0 ] - 1 ) ; $ sz = strlen ( $ extra ) ; $ data = pack ( 'vCCvvvCCCCC' , $ options , 0 , 1 , $ sz , 0 , $ sheetIndex , 0 , 0 , 0 , 0 , 0 ) . $ name . $ extra ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
2801	protected static function generateNonLazyBeanCode ( string $ padding , string $ beanId , string $ beanType , Bean $ beanMetadata , string $ methodParams , ForceLazyInitProperty $ forceLazyInitProperty , SessionBeansProperty $ sessionBeansProperty , BeanPostProcessorsProperty $ postProcessorsProperty , WrapBeanAsLazy $ wrapBeanAsLazy ) : string { $ content = $ padding . '$backupForceLazyInit = $this->' . $ forceLazyInitProperty -> getName ( ) . ';' . PHP_EOL ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . 'if($this->' . $ sessionBeansProperty -> getName ( ) . '->has("' . $ beanId . '")) {' . PHP_EOL ; if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . ' $sessionInstance = clone $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } else { $ content .= $ padding . ' $sessionInstance = $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } $ content .= $ padding . ' return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $sessionInstance) : $sessionInstance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . 'static $instance = null;' . PHP_EOL ; $ content .= $ padding . 'if ($instance !== null) {' . PHP_EOL ; $ content .= $ padding . ' return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $instance) : $instance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . '$this->' . $ forceLazyInitProperty -> getName ( ) . ' = true;' . PHP_EOL ; } $ content .= self :: generateBeanCreationCode ( $ padding , $ beanId , $ methodParams , $ postProcessorsProperty ) ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . '$this->' . $ forceLazyInitProperty -> getName ( ) . ' = $backupForceLazyInit;' . PHP_EOL ; $ content .= $ padding . '$this->' . $ sessionBeansProperty -> getName ( ) . '->add("' . $ beanId . '", $instance);' . PHP_EOL ; } $ content .= $ padding . 'return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $instance) : $instance;' . PHP_EOL ; return $ content ; }
1473	public function createValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] , \ Closure $ callback = null ) : ValidatorInterface { $ translator = $ this -> createErrorTranslator ( ) ; return new Validation \ Validator ( $ this -> makeValidator ( $ data , $ rules , $ messages , $ customAttributes ) , $ translator , $ callback ) ; }
829	private function isStringPartToken ( Token $ token ) { return $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) || $ token -> isGivenKind ( T_START_HEREDOC ) || '"' === $ token -> getContent ( ) || 'b"' === strtolower ( $ token -> getContent ( ) ) ; }
11710	public function actionConfirm ( $ id , $ back = 'index' ) { $ this -> findModel ( $ id ) -> confirm ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been confirmed' ) ) ; $ url = $ back == 'index' ? [ 'index' ] : [ 'update' , 'id' => $ id ] ; return $ this -> redirect ( $ url ) ; }
11612	protected function _resolveContainer ( BaseContainerInterface $ container ) { $ parent = null ; while ( $ container instanceof ContainerAwareInterface ) { $ parent = $ container -> getContainer ( ) ; if ( ! ( $ parent instanceof BaseContainerInterface ) ) { break ; } $ container = $ parent ; } return $ container ; }
10423	public function setTriggerType ( $ type ) { if ( ! array_key_exists ( $ type , $ this -> validTypes ) ) { throw new \ InvalidArgumentException ( 'The type MUST be one of:' . implode ( ',' , $ this -> validTypes ) ) ; } $ this -> type = $ this -> validTypes [ $ type ] ; $ this -> typeAlias = $ type ; }
1066	private function doTypesConflict ( OutputType $ type1 , OutputType $ type2 ) { if ( $ type1 instanceof ListOfType ) { return $ type2 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof ListOfType ) { return $ type1 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type1 instanceof NonNull ) { return $ type2 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof NonNull ) { return $ type1 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( Type :: isLeafType ( $ type1 ) || Type :: isLeafType ( $ type2 ) ) { return $ type1 !== $ type2 ; } return false ; }
2950	private function failedDispatch ( $ queue , \ Exception $ error ) { foreach ( $ queue as $ index => $ data ) { $ this -> clear ( $ data [ 'key' ] ) ; $ data [ 'reject' ] ( $ error ) ; } }
5868	public static function getMetadata ( $ fileName , $ fullExtract = false ) { $ metadata = static :: getBasicMetadata ( $ fileName ) ; if ( $ fullExtract && ! empty ( $ metadata ) ) { $ virtualFileObject = static :: getVirtualFileObject ( $ fileName , $ metadata ) ; $ extractorRegistry = \ TYPO3 \ CMS \ Core \ Resource \ Index \ ExtractorRegistry :: getInstance ( ) ; $ extractionServices = $ extractorRegistry -> getExtractorsWithDriverSupport ( 'Local' ) ; $ newMetadata = [ 0 => $ metadata , ] ; foreach ( $ extractionServices as $ service ) { if ( $ service -> canProcess ( $ virtualFileObject ) ) { $ newMetadata [ $ service -> getPriority ( ) ] = $ service -> extractMetaData ( $ virtualFileObject , $ newMetadata ) ; } } ksort ( $ newMetadata ) ; foreach ( $ newMetadata as $ data ) { $ metadata = array_merge ( $ metadata , $ data ) ; } } return $ metadata ; }
1809	public function getContentElementGroup ( $ element ) { foreach ( $ GLOBALS [ 'TL_CTE' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { if ( $ kk == $ element ) { return $ k ; } } } return null ; }
8080	public function & getReports ( $ channel = null ) { $ channel = $ this -> namespaceChannel ( $ channel ) ; if ( ! isset ( $ this -> console [ 'reports' ] [ $ channel ] ) ) { $ this -> console [ 'reports' ] [ $ channel ] = array ( ) ; } return $ this -> console [ 'reports' ] [ $ channel ] ; }
6328	private function getColumnsSql ( ) { $ columnTypeMapper = new ColumnTypeMapper ( ) ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { if ( $ constraint instanceof PrimaryKey ) { $ primaryKey = $ constraint ; } } if ( ! isset ( $ primaryKey ) ) { $ primaryKey = new PrimaryKey ( ) ; $ primaryKey -> setTable ( $ this -> table ) ; $ this -> table -> addConstraint ( $ primaryKey ) ; } $ sql = '' ; if ( ! $ primaryKey -> isMulti ( ) && $ primaryKey -> isAutoCreateColumn ( ) ) { $ sql = sprintf ( '%s %s NOT NULL,' , $ primaryKey -> getColumns ( ) , $ primaryKey -> isAutoIncrement ( ) ? 'serial' : 'integer' ) ; } foreach ( $ this -> table -> getColumns ( ) as $ column ) { if ( $ column instanceof CustomColumn ) { $ columnType = $ column -> getType ( ) ; } else { $ columnType = $ columnTypeMapper -> getNative ( $ column -> getType ( ) ) ; } $ sql .= sprintf ( '%s %s%s %s %s,' , $ column -> getName ( ) , $ columnType , $ this -> getTypeConstraints ( $ column ) , $ column -> isNotNull ( ) ? 'NOT NULL' : '' , null === $ column -> getDefault ( ) ? '' : 'DEFAULT' . ' ' . $ this -> addQuotesIfNeeded ( $ column , $ column -> getDefault ( ) ) ) ; } return rtrim ( $ sql , ',' ) ; }
2645	public function checkServiceDetails ( $ test = false , $ serviceId = null , $ apiKey = null ) { if ( ! $ test ) { $ uri = rtrim ( $ this -> _getApiServiceUri ( ) , '/' ) ; $ result = $ this -> _fetch ( $ uri ) ; } else { $ uri = $ this -> config -> getApiEndpoint ( ) . 'service/' . $ serviceId ; $ result = $ this -> _fetch ( $ uri , \ Zend_Http_Client :: GET , null , true , $ apiKey ) ; } if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to check Service details.' ) ) ; } return $ result ; }
3079	public static function getCatInfo ( AssessmentTest $ test , $ namespace = '' ) { if ( $ namespace === '' ) { $ namespace = CatService :: QTI_2X_ADAPTIVE_XML_NAMESPACE ; } $ info = [ ] ; foreach ( $ test -> getComponentsByClassName ( 'assessmentSection' ) as $ assessmentSection ) { if ( ( $ selection = $ assessmentSection -> getSelection ( ) ) !== null && ( ( $ xmlExtension = $ selection -> getXml ( ) ) ) !== null ) { $ xpath = new \ DOMXPath ( $ xmlExtension ) ; $ xpath -> registerNamespace ( 'ais' , $ namespace ) ; $ sectionIdentifier = $ assessmentSection -> getIdentifier ( ) ; $ sectionInfo = [ ] ; foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:adaptiveEngineRef' , $ xmlExtension ) as $ adaptiveEngineRef ) { $ sectionInfo [ 'adaptiveEngineRef' ] = $ adaptiveEngineRef -> getAttribute ( 'href' ) ; } foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:adaptiveSettingsRef' , $ xmlExtension ) as $ adaptiveSettingsRef ) { $ sectionInfo [ 'adaptiveSettingsRef' ] = $ adaptiveSettingsRef -> getAttribute ( 'href' ) ; } foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:qtiUsagedataRef' , $ xmlExtension ) as $ qtiUsagedataRef ) { $ sectionInfo [ 'qtiUsagedataRef' ] = $ qtiUsagedataRef -> getAttribute ( 'href' ) ; } foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:qtiMetadataRef' , $ xmlExtension ) as $ qtiMetadataRef ) { $ sectionInfo [ 'qtiMetadataRef' ] = $ qtiMetadataRef -> getAttribute ( 'href' ) ; } if ( ! empty ( $ sectionInfo ) ) { $ info [ $ sectionIdentifier ] = $ sectionInfo ; } } } return $ info ; }
12006	final public function getAuthorityTree ( ) { $ database = $ this -> database ; $ statement = $ database -> select ( ) -> from ( '?authority' ) -> between ( "lft" , '1' , '6' ) -> prepare ( ) ; $ results = $ statement -> execute ( ) ; $ right = array ( ) ; }
5732	public function getLeague ( int $ leagueID , array $ filter = [ 'areas' => '' ] ) { $ league = $ this -> run ( "v2/competitions/{$leagueID}" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ league ) ; }
3029	public function setToken ( $ token , $ secret ) { $ this -> token = new \ Eher \ OAuth \ Token ( $ token , $ secret ) ; }
307	private function sizeToBytes ( $ sizeStr ) { switch ( substr ( $ sizeStr , - 1 ) ) { case 'M' : case 'm' : return ( int ) $ sizeStr * 1048576 ; case 'K' : case 'k' : return ( int ) $ sizeStr * 1024 ; case 'G' : case 'g' : return ( int ) $ sizeStr * 1073741824 ; default : return ( int ) $ sizeStr ; } }
8181	public function getDefaultStrategy ( $ name ) { if ( ! is_string ( $ this -> defaultStrategy ) && false !== $ this -> defaultStrategy ) { return call_user_func ( $ this -> defaultStrategy , $ name ) ; } return $ this -> defaultStrategy ; }
6215	public function getParameters ( ) { $ parameters = $ this -> getUnfilteredParameters ( ) ; foreach ( $ this -> parameterFilters as $ filter ) { $ filter -> filter ( $ parameters ) ; } return $ parameters ; }
772	public function actionConfigTemplate ( $ filePath ) { $ filePath = Yii :: getAlias ( $ filePath ) ; if ( file_exists ( $ filePath ) ) { if ( ! $ this -> confirm ( "File '{$filePath}' already exists. Do you wish to overwrite it?" ) ) { return ExitCode :: OK ; } } if ( ! copy ( Yii :: getAlias ( '@yii/views/messageConfig.php' ) , $ filePath ) ) { $ this -> stdout ( "Configuration file template was NOT created at '{$filePath}'.\n\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "Configuration file template created at '{$filePath}'.\n\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; }
678	protected function detectSearchAttributeType ( Validator $ validator ) { if ( $ validator instanceof BooleanValidator ) { return self :: TYPE_BOOLEAN ; } if ( $ validator instanceof NumberValidator ) { return $ validator -> integerOnly ? self :: TYPE_INTEGER : self :: TYPE_FLOAT ; } if ( $ validator instanceof StringValidator ) { return self :: TYPE_STRING ; } if ( $ validator instanceof EachValidator ) { return self :: TYPE_ARRAY ; } if ( $ validator instanceof DateValidator ) { if ( $ validator -> type == DateValidator :: TYPE_DATETIME ) { return self :: TYPE_DATETIME ; } if ( $ validator -> type == DateValidator :: TYPE_TIME ) { return self :: TYPE_TIME ; } return self :: TYPE_DATE ; } }
5945	public function freetext ( $ freetext , $ deploymentSiteIds = null , $ mode = self :: FREETEXT_OR , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'mode' => $ mode , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/freetext/' . $ freetext . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
3469	public function options ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: options ( $ route ) ) ; }
12789	protected function loadForeignObject ( ) { if ( $ this -> _isLoadingForeignObject ) { throw new RecursionException ( 'Ran into recursion while loading foreign object' ) ; } $ this -> _isLoadingForeignObject = true ; if ( isset ( $ this -> foreignPrimaryKey ) ) { $ foreignObject = $ this -> dataSource -> getForeignDataModel ( $ this -> foreignPrimaryKey ) ; if ( $ foreignObject ) { $ this -> foreignObject = $ foreignObject ; } } if ( empty ( $ this -> _foreignObject ) ) { \ d ( $ this -> foreignPrimaryKey ) ; \ d ( $ this -> dataSource -> name ) ; throw new MissingItemException ( 'Foreign item could not be found: ' . $ this -> foreignPrimaryKey ) ; } $ this -> _isLoadingForeignObject = false ; }
8137	public function getCacheFilename ( $ name ) { @ trigger_error ( sprintf ( 'The %s method is deprecated since version 1.22 and will be removed in Twig 2.0.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ key = $ this -> cache -> generateKey ( $ name , $ this -> getTemplateClass ( $ name ) ) ; return ! $ key ? false : $ key ; }
7379	public function fetchFilter ( string $ key , $ default = null , $ filter = FILTER_DEFAULT , $ options = [ ] ) { $ value = $ this -> fetch ( $ key , $ default ) ; if ( ! is_array ( $ options ) && $ options ) { $ options = [ 'flags' => $ options ] ; } if ( is_array ( $ value ) && ! isset ( $ options [ 'flags' ] ) ) { $ options [ 'flags' ] = FILTER_REQUIRE_ARRAY ; } return filter_var ( $ value , $ filter , $ options ) ; }
7734	private function isHydraOperation ( \ ReflectionMethod $ method ) { $ annotation = $ this -> annotationReader -> getMethodAnnotation ( $ method , 'ML\HydraBundle\Mapping\Operation' ) ; return null !== $ annotation ; }
10793	public function delete ( $ idOrUser , $ forceLogout = true ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ em = $ main -> getEntityManager ( ) ; $ user = $ this -> getEntity ( $ idOrUser ) ; $ classifiedService = $ this -> getServiceLocator ( ) -> get ( 'document.service.classified' ) ; if ( ! $ this -> checkIfOwnerOrAdmin ( $ user ) ) { throw new \ Exception ( 'Non possiedi i permessi per agire su questo documento' ) ; } $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ , $ this , array ( 'user' => $ user ) ) ; $ user -> setState ( UserEntity :: USER_STATE_DELETED ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ documents = $ user -> getDocument ( ) ; foreach ( $ documents as $ document ) { try { $ classifiedService -> delete ( $ document ) ; } catch ( \ Exception $ e ) { } } $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , array ( 'user' => $ user ) ) ; if ( $ forceLogout ) { $ this -> logout ( ) ; } return $ user ; }
12424	public function getAuthorizationInfo ( $ authCode = null ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorization_code' => $ authCode ? : $ this -> request -> get ( 'auth_code' ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTH_INFO , $ params ] ) ; }
12646	public function setTrue ( $ obData = null ) { $ this -> bStatus = true ; $ this -> obData = $ obData ; return $ this ; }
7491	public function setLength ( $ newLength , $ padding = ' ' ) { $ newLength = ( int ) $ newLength ; $ currentLength = $ this -> length ( ) ; if ( $ newLength != $ currentLength ) { while ( $ newLength > $ this -> length ( ) ) { $ this -> string .= $ padding ; } if ( $ newLength < $ this -> length ( ) ) { $ this -> string = mb_substr ( $ this -> string , 0 , $ newLength , $ this -> encoding ) ; } } return $ this ; }
6242	public function reload ( ) : self { if ( $ this -> loaded === false ) { return $ this ; } clearstatcache ( false , $ this -> raw ) ; $ this -> loaded = false ; return $ this ; }
10928	public function executeInstruction ( string $ strSQL , ? array $ parans = null ) : bool { $ this -> dbPreparedStatment = $ this -> dbConnection -> prepare ( $ strSQL ) ; $ this -> pdoLastError = null ; if ( $ parans !== null ) { foreach ( $ parans as $ key => $ value ) { $ val = $ value ; if ( is_bool ( $ value ) === true ) { if ( $ value === true ) { $ val = 1 ; } else { $ val = 0 ; } } else if ( is_a ( $ value , "\DateTime" ) === true ) { $ val = $ value -> format ( "Y-m-d H:i:s" ) ; } $ this -> dbPreparedStatment -> bindValue ( ":" . $ key , $ val ) ; } } try { $ this -> dbPreparedStatment -> execute ( ) ; } catch ( \ Exception $ ex ) { $ this -> pdoLastError = $ ex -> getMessage ( ) ; } return $ this -> isExecuted ( ) ; }
12544	public function setLink ( string $ link = null ) : \ TheCMSThread \ Core \ Main \ View { $ this -> link = $ link ; return $ this ; }
6188	public function render ( $ data , $ type = null ) { if ( empty ( $ type ) or $ type === 'html' ) { return Response :: Create ( $ this -> renderInclude ( $ data ) ) ; } elseif ( $ type === 'jsonp' ) { return $ this -> renderJSONP ( $ data ) ; } else { return $ this -> renderJSON ( $ data ) ; } }
1538	public function willSeeOne ( $ request ) : bool { if ( $ this -> route -> isRelationship ( ) ) { return false ; } if ( $ this -> route -> isResource ( ) ) { return true ; } return $ request -> isMethod ( 'POST' ) ; }
7891	protected function triggerDeploy ( $ project ) { if ( ! $ project ) { throw new InvalidArgumentException ( 'Incorrect project hook.' ) ; } file_get_contents ( sprintf ( self :: DEPLOY_URL , $ project ) ) ; $ this -> info ( 'Deployment request successful!' ) ; }
8972	protected function paginate ( array $ rates , $ criteria ) { if ( ! array_key_exists ( 'offset' , $ criteria ) && ! array_key_exists ( 'limit' , $ criteria ) ) { return $ rates ; } $ range = array ( ) ; $ offset = array_key_exists ( 'offset' , $ criteria ) ? $ criteria [ 'offset' ] : 0 ; $ limit = min ( ( array_key_exists ( 'limit' , $ criteria ) ? $ criteria [ 'limit' ] : count ( $ rates ) ) + $ offset , count ( $ rates ) ) ; for ( $ i = $ offset ; $ i < $ limit ; $ i ++ ) { $ range [ ] = $ rates [ $ i ] ; } return $ range ; }
5397	public function paintMessage ( $ message ) { parent :: paintMessage ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'message>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "message>\n" ; }
12969	public function transformFromFront ( array $ array ) { $ transformation = $ this -> getTransformation ( ) ; $ fillables = $ this -> getFillable ( ) ; $ transformed = [ ] ; foreach ( $ fillables as $ name ) { if ( ! key_exists ( $ name , $ array ) ) { continue ; } $ transformed [ $ name ] = $ array [ $ name ] ; } foreach ( $ transformation as $ name => $ new_name ) { if ( ! key_exists ( $ new_name , $ array ) ) { continue ; } $ transformed [ $ name ] = $ array [ $ new_name ] ; } return $ transformed ; }
5067	public function setOpt ( int $ option , $ value ) : bool { return curl_setopt ( $ this -> ch , $ option , $ value ) ; }
9643	public static function getDriver ( MappingDriver $ originalDriver , $ namespace ) { if ( $ originalDriver instanceof MappingDriverChain ) { $ driver = new Driver \ Chain ( ) ; foreach ( $ originalDriver -> getDrivers ( ) as $ nestedNamespace => $ nestedDriver ) { $ driver -> addDriver ( static :: getDriver ( $ nestedDriver , $ namespace ) , $ nestedNamespace ) ; } if ( $ originalDriver -> getDefaultDriver ( ) !== null ) { $ driver -> setDefaultDriver ( static :: getDriver ( $ originalDriver -> getDefaultDriver ( ) , $ namespace ) ) ; } return $ driver ; } preg_match ( '/(?P<type>Xml|Yaml|Annotation)Driver$/' , get_class ( $ originalDriver ) , $ m ) ; $ type = isset ( $ m [ 'type' ] ) ? $ m [ 'type' ] : null ; $ driverClass = sprintf ( '%s\Mapping\Driver\%s' , $ namespace , $ type ) ; if ( ! $ type || ! class_exists ( $ driverClass ) ) { $ driverClass = sprintf ( '%s\Mapping\Driver\Annotation' , $ namespace ) ; if ( ! class_exists ( $ driverClass ) ) { throw new \ RuntimeException ( sprintf ( 'Failed to fallback to annotation driver: (%s), extension driver was not found.' , $ driverClass ) ) ; } } $ driver = new $ driverClass ( ) ; $ driver -> setOriginalDriver ( $ originalDriver ) ; if ( $ driver instanceof Driver \ File ) { $ driver -> setLocator ( $ originalDriver -> getLocator ( ) ) ; } elseif ( $ driver instanceof AnnotationDriverInterface ) { $ reader = static :: getAnnotationReader ( ) ; $ driver -> setAnnotationReader ( $ reader ) ; } return $ driver ; }
2636	public function getLastVersion ( ) { try { $ url = self :: CHECK_VERSION_URL ; $ client = $ this -> curlFactory -> create ( ) ; $ client -> write ( \ Zend_Http_Client :: GET , $ url , '1.1' ) ; $ responseBody = $ client -> read ( ) ; $ client -> close ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ responseBody ) ; if ( $ responseCode !== 200 ) { return false ; } $ body = \ Zend_Http_Response :: extractBody ( $ responseBody ) ; $ json = json_decode ( $ body ) ; $ version = ! empty ( $ json -> version ) ? $ json -> version : false ; return $ version ; } catch ( \ Exception $ e ) { $ this -> _logger -> log ( 100 , $ e -> getMessage ( ) . $ url ) ; return false ; } }
2481	protected function internalFind ( array $ parameters , array $ languageSettings = array ( ) ) { $ searchTargets = $ this -> getSearchTargets ( $ languageSettings ) ; if ( ! empty ( $ searchTargets ) ) { $ parameters [ 'shards' ] = $ searchTargets ; } return $ this -> search ( $ parameters ) ; }
6505	public function deserializeParameters ( $ type , $ data ) { $ jobType = $ this -> registry -> get ( $ type ) ; $ indices = $ jobType -> getIndicesOfSerializableParameters ( ) ; $ serializedParameters = json_decode ( $ data , 1 ) ; if ( false === $ serializedParameters ) { throw new \ RuntimeException ( sprintf ( 'Deserialization failed with error "%s"' , json_last_error_msg ( ) ) ) ; } if ( count ( $ indices ) < count ( $ serializedParameters ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The serialized data contains more parameters than defined for job "%s"' , $ type ) ) ; } $ parameters = array ( ) ; foreach ( $ serializedParameters as $ index => $ data ) { if ( null === $ data ) { $ parameters [ ] = null ; } else { $ parameters [ ] = $ this -> serializer -> deserialize ( $ data , $ jobType -> getParameterType ( $ indices [ $ index ] ) , 'json' , $ this -> getParamDeserializationContext ( $ jobType , $ indices [ $ index ] ) ) ; } } return $ parameters ; }
10932	public function hasRowsWith ( string $ tablename , string $ colName , $ colValue ) : bool { return ( $ this -> countRowsWith ( $ tablename , $ colName , $ colValue ) > 0 ) ; }
6367	public function min ( Traversable $ traversable ) { $ array = iterator_to_array ( $ traversable , false ) ; Arrays :: sort ( $ array , $ this ) ; return Preconditions :: checkElementExists ( $ array , 0 ) ; }
9079	private static function parseUri ( Request & $ request , $ uri , $ defaultController , $ defaultAction ) { $ contextUri = $ uri ; if ( null != $ request -> getContextPrefix ( ) && '/' != $ request -> getContextPrefix ( ) ) { $ contextUri = str_replace ( $ request -> getContextPrefix ( ) , '' , $ uri ) ; } $ parts = array ( ) ; if ( $ contextUri != '' ) { while ( isset ( $ contextUri [ 0 ] ) && $ contextUri [ 0 ] == '/' ) { $ contextUri = substr ( $ contextUri , 1 ) ; } $ parts = explode ( '/' , $ contextUri ) ; } if ( count ( $ parts ) > 0 ) { $ request -> setController ( ucfirst ( trim ( $ parts [ 0 ] ) ) ) ; array_shift ( $ parts ) ; if ( ! $ request -> getController ( ) ) { $ request -> setController ( $ defaultController ) ; } } if ( count ( $ parts ) > 0 ) { $ request -> setAction ( trim ( $ parts [ 0 ] ) ) ; array_shift ( $ parts ) ; if ( ! $ request -> getAction ( ) ) { $ request -> setAction ( $ defaultAction ) ; } } return $ parts ; }
12709	public static function parse ( string $ word ) : array { $ word = ltrim ( rtrim ( trim ( $ word ) , '}' ) , '{' ) ; if ( $ separatorPosition = strpos ( $ word , '=' ) ) { $ key = substr ( $ word , 0 , $ separatorPosition ) ; $ defaultValue = substr ( $ word , $ separatorPosition + 1 ) ; return [ $ key , $ defaultValue ] ; } return [ $ word , null ] ; }
7928	public function unregisterNamespace ( $ ns ) { list ( $ ns ) = $ this -> fireEvent ( 'namespace.unregister' , [ $ ns ] ) ; unset ( $ this -> namespaces [ $ ns ] ) ; return $ this ; }
10743	public function getDateTime ( $ keys , DateTime $ default = null ) { $ value = $ this -> getString ( $ keys ) ; if ( empty ( $ value ) ) { $ result = $ default ; } elseif ( $ value === ( string ) ( int ) $ value ) { $ result = new DateTime ( ) ; $ result -> setTimestamp ( ( int ) $ value ) ; } else { $ result = new DateTime ( $ value ) ; } return $ result ; }
9720	public function setEscher ( \ PhpOffice \ PhpSpreadsheet \ Shared \ Escher $ pValue = null ) { $ this -> escher = $ pValue ; }
804	private function hasReturnTypeHint ( Tokens $ tokens , $ index ) { $ endFuncIndex = $ tokens -> getPrevTokenOfKind ( $ index , [ ')' ] ) ; $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ endFuncIndex ) ; return $ tokens [ $ nextIndex ] -> isGivenKind ( CT :: T_TYPE_COLON ) ; }
9535	private function parseVariadicParameter ( & $ i , & $ results , $ closure , & $ closure_arguments , $ prefix , $ parameter ) { $ i ++ ; while ( isset ( $ this -> argv [ $ i ] ) && ( $ argument = $ this -> argv [ $ i ] ) != null && ! $ this -> prefixExists ( $ argument ) ) { $ closure_arguments [ ] = $ argument ; $ i ++ ; } $ parameterClosure = $ this -> getParameterClosure ( $ parameter ) ; if ( $ parameterClosure -> parent != null ) { if ( count ( $ closure_arguments ) > 0 ) { $ results [ $ parameterClosure -> parent -> parameterName ] = $ closure ( ... $ closure_arguments ) ; } else { $ this -> valid = false ; if ( $ this -> errorHandler != null ) { $ this -> errorHandler -> call ( $ this , $ parameterClosure , 'Missing argument for parameter closure.' ) ; } } } else { if ( count ( $ closure_arguments ) > 0 ) { $ results [ substr ( $ parameter , strlen ( $ prefix ) , strlen ( $ parameter ) - strlen ( $ prefix ) ) ] = $ closure ( ... $ closure_arguments ) ; } else { $ this -> valid = false ; if ( $ this -> errorHandler != null ) { $ this -> errorHandler -> call ( $ this , $ parameterClosure , 'Missing argument for parameter closure.' ) ; } } } }
7435	public function scan ( ) { $ files = $ this -> extensionsFile ( $ this -> files ) ; foreach ( $ files as $ file ) { $ content = file_get_contents ( $ file ) ; if ( str_contains ( $ file , '.php' ) && ! str_contains ( $ file , $ this -> exceptionsValid ) && ! $ this -> checkForValidPhp ( $ content ) ) { $ this -> notValid [ ] = $ file ; } if ( str_contains ( $ content , $ this -> signatures ) ) { $ this -> dangerFiles [ ] = $ file ; } } return $ this ; }
10567	public function newAction ( ) { $ entity = new Media ( ) ; $ form = $ this -> createCreateForm ( $ entity ) ; return $ this -> render ( 'MMMediaBundle:Media:new.html.twig' , array ( 'entity' => $ entity , 'form' => $ form -> createView ( ) , ) ) ; }
8558	public function setFinancialEventGroupList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FinancialEventGroupList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3691	public function presetVariantBase ( PreEditModelEvent $ event ) { $ model = $ event -> getModel ( ) ; if ( ! $ model instanceof Model ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; if ( $ metaModel -> hasVariants ( ) && ( ! $ nativeItem -> get ( 'vargroup' ) ) ) { $ nativeItem -> set ( 'varbase' , '1' ) ; } }
683	private function normalizeComplexFilter ( array $ filter ) { $ result = [ ] ; foreach ( $ filter as $ key => $ value ) { if ( isset ( $ this -> filterControls [ $ key ] ) ) { $ key = $ this -> filterControls [ $ key ] ; } elseif ( isset ( $ this -> attributeMap [ $ key ] ) ) { $ key = $ this -> attributeMap [ $ key ] ; } if ( is_array ( $ value ) ) { $ result [ $ key ] = $ this -> normalizeComplexFilter ( $ value ) ; } else { $ result [ $ key ] = $ value ; } } return $ result ; }
1678	protected function getSize ( ) { $ intSize = 0 ; foreach ( scan ( $ this -> strRootDir . '/' . $ this -> strFolder , true ) as $ strFile ) { if ( strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } if ( is_dir ( $ this -> strRootDir . '/' . $ this -> strFolder . '/' . $ strFile ) ) { $ objFolder = new self ( $ this -> strFolder . '/' . $ strFile ) ; $ intSize += $ objFolder -> size ; } else { $ objFile = new File ( $ this -> strFolder . '/' . $ strFile ) ; $ intSize += $ objFile -> size ; } } return $ intSize ; }
5604	public function paintMethodStart ( $ method ) { $ this -> pass = false ; $ this -> fail = false ; $ this -> error = false ; $ this -> method = self :: escapeVal ( $ method ) ; }
3291	public function signal ( int $ signo ) { if ( ! $ this -> isRunning ( ) ) { throw new StatusError ( "Process is not running." ) ; } $ this -> processRunner -> signal ( $ this -> handle , $ signo ) ; }
10125	private function writeAutoFilterInfo ( ) { $ record = 0x009D ; $ length = 0x0002 ; $ rangeBounds = Coordinate :: rangeBoundaries ( $ this -> phpSheet -> getAutoFilter ( ) -> getRange ( ) ) ; $ iNumFilters = 1 + $ rangeBounds [ 1 ] [ 0 ] - $ rangeBounds [ 0 ] [ 0 ] ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ iNumFilters ) ; $ this -> append ( $ header . $ data ) ; }
9139	public static function parse ( $ uri , $ serverVars = array ( ) , $ defaultController = 'Index' , $ defaultAction = 'index' ) { $ req = new self ( $ defaultController , $ defaultAction ) ; $ req -> origin = $ uri ; self :: parseRemoteHost ( $ req , $ serverVars ) ; self :: parseGetPostSessionCookie ( $ req ) ; $ savedRequestParams = array ( ) ; if ( strpos ( $ uri , '?' ) ) { parse_str ( substr ( $ uri , strpos ( $ uri , '?' ) + 1 ) , $ savedRequestParams ) ; $ uri = substr ( $ uri , 0 , strpos ( $ uri , '?' ) ) ; } self :: parseContextPrefix ( $ req , $ serverVars ) ; $ parts = self :: parseUri ( $ req , $ uri , $ defaultController , $ defaultAction ) ; $ numParts = count ( $ parts ) ; for ( $ i = 0 ; $ i < $ numParts ; $ i = $ i + 2 ) { $ paramName = trim ( $ parts [ $ i ] ) ; $ paramValue = isset ( $ parts [ $ i + 1 ] ) ? trim ( $ parts [ $ i + 1 ] ) : '' ; if ( $ paramName && $ paramValue ) { $ req -> params [ $ paramName ] = $ paramValue ; } } $ req -> params = array_merge ( $ req -> params , $ savedRequestParams ) ; self :: parseParameters ( $ req , $ serverVars ) ; return $ req ; }
3048	public function init ( ) { $ sessionStateService = $ this -> getServiceManager ( ) -> get ( SessionStateService :: SERVICE_ID ) ; $ sessionStateService -> resumeSession ( $ this -> getTestSession ( ) ) ; $ this -> retrieveItemIndex ( ) ; }
10182	public function unsetWorksheetCells ( ) { if ( $ this -> currentCell !== null ) { $ this -> currentCell -> detach ( ) ; $ this -> currentCell = null ; $ this -> currentCoordinate = null ; } $ this -> __destruct ( ) ; $ this -> index = [ ] ; $ this -> parent = null ; }
2619	public function generateCid ( ) { return sprintf ( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x' , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0x0fff ) | 0x4000 , mt_rand ( 0 , 0x3fff ) | 0x8000 , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) ) ; }
6597	protected function getDescription ( array $ lines ) { $ description = '' ; $ summaryFound = false ; $ summaryPassed = false ; foreach ( $ lines as $ line ) { if ( $ line && ! $ summaryPassed ) { $ summaryFound = true ; if ( substr ( trim ( $ line ) , - 1 ) == '.' ) { $ summaryPassed = true ; } continue ; } if ( ! $ line && $ summaryFound && ! $ summaryPassed ) { $ summaryPassed = true ; continue ; } if ( $ line && $ line [ 0 ] == '@' ) { break ; } if ( $ line && $ summaryPassed ) { $ description .= $ line . "\n" ; } } return trim ( $ description ) ; }
207	public static function confirm ( $ message , $ default = false ) { while ( true ) { static :: stdout ( $ message . ' (yes|no) [' . ( $ default ? 'yes' : 'no' ) . ']:' ) ; $ input = trim ( static :: stdin ( ) ) ; if ( empty ( $ input ) ) { return $ default ; } if ( ! strcasecmp ( $ input , 'y' ) || ! strcasecmp ( $ input , 'yes' ) ) { return true ; } if ( ! strcasecmp ( $ input , 'n' ) || ! strcasecmp ( $ input , 'no' ) ) { return false ; } } }
1181	protected function createFormRequest ( $ class ) { list ( $ class , $ params ) = $ this -> parseFormRequestName ( $ class ) ; $ request = $ this -> app -> __get ( 'request' ) ; $ formRequest = $ this -> app -> build ( $ class , $ params ) ; if ( $ session = $ request -> getSession ( ) ) { $ formRequest -> setLaravelSession ( $ session ) ; } $ formRequest -> setUserResolver ( $ request -> getUserResolver ( ) ) ; $ formRequest -> setRouteResolver ( $ request -> getRouteResolver ( ) ) ; $ formRequest -> setContainer ( $ this -> app ) ; $ formRequest -> query = $ request -> query ; return $ formRequest ; }
7514	function next_search ( $ characters , $ callback = true ) { $ this -> token_start = $ this -> pos ; if ( ! is_array ( $ characters ) ) { $ characters = array_fill_keys ( str_split ( $ characters ) , true ) ; } while ( ++ $ this -> pos < $ this -> size ) { if ( isset ( $ characters [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( $ callback && isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> parse_linebreak ( ) ; } } return ( $ this -> token = self :: TOK_NULL ) ; }
7035	protected function createMigrationTable ( ) { $ migrations = new Table ( "migrations" , true ) ; $ migrations -> string ( "host" ) -> notNullable ( ) -> primaryComposite ( ) ; $ migrations -> timestamp ( "created_at" ) -> notNullable ( ) -> primaryComposite ( true ) ; $ migrations -> blob ( "tables" ) ; try { return $ migrations -> create ( $ this -> dbName ) ; } catch ( PDOException $ e ) { error_log ( $ e -> getMessage ( ) ) ; return false ; } }
6008	protected function init ( $ ftkey ) { if ( strlen ( $ ftkey ) != 32 ) { throw new Ts3Exception ( "invalid file transfer key format" ) ; } $ this -> getProfiler ( ) -> start ( ) ; $ this -> getTransport ( ) -> send ( $ ftkey ) ; Signal :: getInstance ( ) -> emit ( "filetransferHandshake" , $ this ) ; }
4901	public static function loadConfig ( $ configuration = [ ] ) { $ configDir = static :: getConfigDir ( ) ; if ( empty ( $ configuration ) ) { $ configFile = $ configDir . '/config.php' ; if ( ! is_file ( $ configFile ) ) { throw new InvalidArgumentException ( sprintf ( 'Can not load config file "%s". Please be sure that this file exists and readable' , $ configFile ) ) ; } $ configuration = include $ configFile ; } $ isCli = php_sapi_name ( ) === 'cli' ; $ modules = $ configuration [ 'modules' ] ; $ modules = static :: generateModuleConfiguration ( $ modules ) ; $ yawikConfig = $ configDir . '/autoload/yawik.config.global.php' ; $ installMode = false ; if ( ! $ isCli && ! file_exists ( $ yawikConfig ) ) { $ modules = static :: generateModuleConfiguration ( [ 'Install' ] ) ; $ installMode = true ; } elseif ( in_array ( 'Install' , $ modules ) ) { $ modules = array_diff ( $ modules , [ 'Install' ] ) ; } static :: $ env = $ env = getenv ( 'APPLICATION_ENV' ) ? : 'production' ; $ defaults = [ 'module_listener_options' => [ 'module_paths' => [ './module' , './vendor' , './modules' ] , 'config_glob_paths' => [ sprintf ( $ configDir . '/autoload/{,*.}{global,%s,local}.php' , $ env ) ] , 'config_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_key' => 'module_map' , 'check_dependencies' => ( $ env != 'production' ) , 'cache_dir' => getcwd ( ) . "/var/cache" , ] , ] ; $ envConfig = [ ] ; $ envConfigFile = $ configDir . '/config.' . $ env . '.php' ; if ( file_exists ( $ envConfigFile ) ) { if ( is_readable ( $ envConfigFile ) ) { $ envConfig = include $ envConfigFile ; } else { \ trigger_error ( sprintf ( 'Environment config file "%s" is not readable.' , $ envConfigFile ) , E_USER_NOTICE ) ; } } $ configuration = ArrayUtils :: merge ( $ defaults , $ configuration ) ; $ configuration = ArrayUtils :: merge ( $ configuration , $ envConfig ) ; $ configuration [ 'modules' ] = $ modules ; if ( $ installMode ) { $ configuration [ 'module_listener_options' ] [ 'config_cache_enabled' ] = false ; $ configuration [ 'module_listener_options' ] [ 'module_map_cache_enabled' ] = false ; } if ( getenv ( 'DOCKER_ENV' ) == 'yes' ) { $ configuration = ArrayUtils :: merge ( $ configuration , static :: getDockerEnv ( $ configuration ) ) ; } return $ configuration ; }
2429	public static function initializeApplication ( Event $ event ) : void { $ webDir = self :: getWebDir ( $ event ) ; static :: purgeCacheFolder ( ) ; static :: addAppDirectory ( ) ; static :: executeCommand ( 'contao:install-web-dir' , $ event ) ; static :: executeCommand ( 'cache:clear --no-warmup' , $ event ) ; static :: executeCommand ( 'cache:warmup' , $ event ) ; static :: executeCommand ( sprintf ( 'assets:install %s --symlink --relative' , $ webDir ) , $ event ) ; static :: executeCommand ( sprintf ( 'contao:install %s' , $ webDir ) , $ event ) ; static :: executeCommand ( sprintf ( 'contao:symlinks %s' , $ webDir ) , $ event ) ; $ event -> getIO ( ) -> write ( '<info>Done! Please open the Contao install tool and make sure the database is up-to-date.</info>' ) ; }
3002	public function setContent ( $ data , $ mime , $ charset = NULL ) { if ( ! $ charset ) $ charset = $ this -> charset ; $ this -> message [ $ mime ] = [ 'content' => $ data , 'type' => $ mime . '; ' . $ charset ] ; }
7487	public function lastIndexOf ( $ string , $ offset = null ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ offset = $ offset !== null ? ( int ) $ offset : null ; if ( $ offset !== null && ( $ offset < 0 || $ offset >= $ this -> length ( ) ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_strrpos ( $ this -> string , $ string , $ offset , $ this -> encoding ) ; }
8565	private function _convertGetEligibleShippingServices ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetEligibleShippingServices' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentRequestDetails ( ) ) { $ ShipmentRequestDetailsGetEligibleShippingServicesRequest = $ request -> getShipmentRequestDetails ( ) ; foreach ( $ ShipmentRequestDetailsGetEligibleShippingServicesRequest -> getAmazonOrderId ( ) as $ AmazonOrderIdShipmentRequestDetailsIndex => $ AmazonOrderIdShipmentRequestDetails ) { $ parameters [ 'ShipmentRequestDetails' . '.' . 'AmazonOrderId' . '.' . ( $ AmazonOrderIdShipmentRequestDetailsIndex + 1 ) ] = $ AmazonOrderIdShipmentRequestDetails ; } } return $ parameters ; }
10203	public function setVertical ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: VERTICAL_BOTTOM ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'vertical' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> vertical = $ pValue ; } return $ this ; }
12930	public function attemptConfirmation ( $ code ) { $ token = $ this -> finder -> findToken ( [ 'user_id' => $ this -> id , 'code' => $ code , 'type' => Token :: TYPE_CONFIRMATION , ] ) -> one ( ) ; if ( $ token === null || $ token -> isExpired ) { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'The confirmation link is invalid or expired. Please try requesting a new one.' ) ) ; } else { $ token -> delete ( ) ; $ this -> confirmed_at = time ( ) ; \ Yii :: $ app -> user -> login ( $ this ) ; \ Yii :: getLogger ( ) -> log ( 'User has been confirmed' , Logger :: LEVEL_INFO ) ; if ( $ this -> save ( false ) ) { \ Yii :: $ app -> session -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'Thank you, registration is now complete.' ) ) ; } else { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'Something went wrong and your account has not been confirmed.' ) ) ; } } }
8203	protected function peekJob ( $ tube , $ state ) { $ peekMethod = 'peek' . ucfirst ( $ state ) ; try { return $ this -> getPheanstalk ( ) -> $ peekMethod ( $ tube ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
4537	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Uuidentifiable ) { return ; } $ this -> idService -> generateUuid ( $ entity ) ; }
9449	protected function allowed ( $ method ) { if ( in_array ( $ method , $ this -> allowed ) === false ) { $ message = 'Used method is not allowed' ; throw new \ UnexpectedValueException ( $ message ) ; } return true ; }
404	public function prepareHeaders ( $ requestHeaders ) { $ responseHeaders = [ ] ; if ( isset ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] ) ) { if ( in_array ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] , true ) ) { $ responseHeaders [ 'Access-Control-Allow-Origin' ] = $ requestHeaders [ 'Origin' ] ; } if ( in_array ( '*' , $ this -> cors [ 'Origin' ] , true ) ) { if ( isset ( $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) && $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) { if ( YII_DEBUG ) { throw new InvalidConfigException ( "Allowing credentials for wildcard origins is insecure. Please specify more restrictive origins or set 'credentials' to false in your CORS configuration." ) ; } else { Yii :: error ( "Allowing credentials for wildcard origins is insecure. Please specify more restrictive origins or set 'credentials' to false in your CORS configuration." , __METHOD__ ) ; } } else { $ responseHeaders [ 'Access-Control-Allow-Origin' ] = '*' ; } } } $ this -> prepareAllowHeaders ( 'Headers' , $ requestHeaders , $ responseHeaders ) ; if ( isset ( $ requestHeaders [ 'Access-Control-Request-Method' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Methods' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Request-Method' ] ) ; } if ( isset ( $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Credentials' ] = $ this -> cors [ 'Access-Control-Allow-Credentials' ] ? 'true' : 'false' ; } if ( isset ( $ this -> cors [ 'Access-Control-Max-Age' ] ) && $ this -> request -> getIsOptions ( ) ) { $ responseHeaders [ 'Access-Control-Max-Age' ] = $ this -> cors [ 'Access-Control-Max-Age' ] ; } if ( isset ( $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ) { $ responseHeaders [ 'Access-Control-Expose-Headers' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ; } if ( isset ( $ this -> cors [ 'Access-Control-Allow-Headers' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Headers' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Allow-Headers' ] ) ; } return $ responseHeaders ; }
11970	public function extendExpiration ( ) { if ( null === $ this -> ttl ) { throw new DomainException ( 'There is no TTL set for this Lock.' ) ; } if ( ! $ this -> expiresAt ) { $ this -> expiresAt = new \ DateTime ( ) ; $ this -> expiresAt -> setTimestamp ( time ( ) ) ; } $ this -> expiresAt -> add ( $ this -> ttl ) ; }
5904	public function listRoles ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/roles' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Role ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
11867	public function unlock ( string $ sessionIdentifier ) : void { $ index = array_search ( $ sessionIdentifier , self :: $ lockedIdentifiers ) ; if ( $ index !== false ) { unset ( self :: $ lockedIdentifiers [ $ index ] ) ; } }
3376	private function createInstance ( $ file , $ w = null , $ h = null ) { $ container = $ this -> container ; $ webDir = $ container -> getParameter ( 'gregwar_image.web_dir' ) ; $ handlerClass = $ this -> handlerClass ; $ image = new $ handlerClass ( $ file , $ w , $ h , $ this -> throwException , $ this -> fallbackImage ) ; $ image -> setCacheDir ( $ this -> cacheDirectory ) ; $ image -> setCacheDirMode ( $ this -> cacheDirMode ) ; $ image -> setActualCacheDir ( $ webDir . '/' . $ this -> cacheDirectory ) ; if ( $ container -> has ( 'templating.helper.assets' ) ) { $ image -> setFileCallback ( function ( $ file ) use ( $ container ) { return $ container -> get ( 'templating.helper.assets' ) -> getUrl ( $ file ) ; } ) ; } else { $ image -> setFileCallback ( function ( $ file ) use ( $ container ) { return $ this -> assetsPackages -> getUrl ( $ file ) ; } ) ; } return $ image ; }
8494	public function createFulfillmentOrder ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_CreateFulfillmentOrderRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_CreateFulfillmentOrderRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateFulfillmentOrder' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_CreateFulfillmentOrderResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
2378	public static function specialchars ( $ strString , $ blnStripInsertTags = false , $ blnDoubleEncode = false ) { if ( $ blnStripInsertTags ) { $ strString = static :: stripInsertTags ( $ strString ) ; } return htmlspecialchars ( $ strString , ENT_COMPAT , Config :: get ( 'characterSet' ) , $ blnDoubleEncode ) ; }
2160	public function run32Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_layout` CHANGE `sections` `sections` varchar(1022) NOT NULL default ''" ) ; $ objLayout = $ this -> Database -> query ( "SELECT id, sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ strSections = '' ; $ tmp = StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ tmp ) && \ is_array ( $ tmp ) ) { $ strSections = implode ( ', ' , $ tmp ) ; } $ this -> Database -> prepare ( "UPDATE tl_layout SET sections=? WHERE id=?" ) -> execute ( $ strSections , $ objLayout -> id ) ; } if ( ! $ this -> Database -> fieldExists ( 'uuid' , 'tl_files' ) ) { $ this -> Database -> query ( "ALTER TABLE `tl_files` ADD `uuid` binary(16) NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_files` ADD UNIQUE KEY `uuid` (`uuid`)" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_files` ADD `pid_backup` int(10) unsigned NOT NULL default 0" ) ; $ this -> Database -> query ( "UPDATE `tl_files` SET `pid_backup`=`pid`" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_files` CHANGE `pid` `pid` binary(16) NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_files` SET `pid`=NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_files` SET `pid`=NULL WHERE `pid_backup`=0" ) ; $ objFiles = $ this -> Database -> query ( "SELECT id FROM tl_files" ) ; while ( $ objFiles -> next ( ) ) { $ this -> Database -> prepare ( "UPDATE tl_files SET uuid=? WHERE id=?" ) -> execute ( $ this -> Database -> getUuid ( ) , $ objFiles -> id ) ; } $ objFiles = $ this -> Database -> query ( "SELECT pid_backup FROM tl_files WHERE pid_backup>0 GROUP BY pid_backup" ) ; while ( $ objFiles -> next ( ) ) { $ objParent = $ this -> Database -> prepare ( "SELECT uuid FROM tl_files WHERE id=?" ) -> execute ( $ objFiles -> pid_backup ) ; if ( $ objParent -> numRows < 1 ) { throw new \ Exception ( 'Invalid parent ID ' . $ objFiles -> pid_backup ) ; } $ this -> Database -> prepare ( "UPDATE tl_files SET pid=? WHERE pid_backup=?" ) -> execute ( $ objParent -> uuid , $ objFiles -> pid_backup ) ; } $ this -> Database -> query ( "ALTER TABLE `tl_files` DROP `pid_backup`" ) ; } $ this -> updateFileTreeFields ( ) ; }
6415	public static function get ( IteratorAggregate $ iterable , int $ position ) { return Iterators :: get ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ position ) ; }
5545	public function getText ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getText ( ) ; } $ raw = '' ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ raw .= ' ' . $ this -> frames [ $ i ] -> getText ( ) ; } return trim ( $ raw ) ; }
9863	private function writeCols ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getColumnDimensions ( ) ) > 0 ) { $ objWriter -> startElement ( 'cols' ) ; $ pSheet -> calculateColumnWidths ( ) ; foreach ( $ pSheet -> getColumnDimensions ( ) as $ colDimension ) { $ objWriter -> startElement ( 'col' ) ; $ objWriter -> writeAttribute ( 'min' , Coordinate :: columnIndexFromString ( $ colDimension -> getColumnIndex ( ) ) ) ; $ objWriter -> writeAttribute ( 'max' , Coordinate :: columnIndexFromString ( $ colDimension -> getColumnIndex ( ) ) ) ; if ( $ colDimension -> getWidth ( ) < 0 ) { $ objWriter -> writeAttribute ( 'width' , '9.10' ) ; } else { $ objWriter -> writeAttribute ( 'width' , StringHelper :: formatNumber ( $ colDimension -> getWidth ( ) ) ) ; } if ( $ colDimension -> getVisible ( ) == false ) { $ objWriter -> writeAttribute ( 'hidden' , 'true' ) ; } if ( $ colDimension -> getAutoSize ( ) ) { $ objWriter -> writeAttribute ( 'bestFit' , 'true' ) ; } if ( $ colDimension -> getWidth ( ) != $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) ) { $ objWriter -> writeAttribute ( 'customWidth' , 'true' ) ; } if ( $ colDimension -> getCollapsed ( ) == true ) { $ objWriter -> writeAttribute ( 'collapsed' , 'true' ) ; } if ( $ colDimension -> getOutlineLevel ( ) > 0 ) { $ objWriter -> writeAttribute ( 'outlineLevel' , $ colDimension -> getOutlineLevel ( ) ) ; } $ objWriter -> writeAttribute ( 'style' , $ colDimension -> getXfIndex ( ) ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
850	public function getTokenOfKindSibling ( $ index , $ direction , array $ tokens = [ ] , $ caseSensitive = true ) { if ( ! self :: isLegacyMode ( ) ) { $ tokens = array_filter ( $ tokens , function ( $ token ) { return $ this -> isTokenKindFound ( $ this -> extractTokenKind ( $ token ) ) ; } ) ; } if ( ! \ count ( $ tokens ) ) { return null ; } while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } $ token = $ this [ $ index ] ; if ( $ token -> equalsAny ( $ tokens , $ caseSensitive ) ) { return $ index ; } } }
2294	public static function getTinyMceLanguage ( ) { $ lang = $ GLOBALS [ 'TL_LANGUAGE' ] ; if ( $ lang == '' ) { return 'en' ; } $ lang = str_replace ( '-' , '_' , $ lang ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/assets/tinymce4/js/langs/' . $ lang . '.js' ) ) { return $ lang ; } if ( ( $ short = substr ( $ GLOBALS [ 'TL_LANGUAGE' ] , 0 , 2 ) ) != $ lang ) { if ( file_exists ( $ rootDir . '/assets/tinymce4/js/langs/' . $ short . '.js' ) ) { return $ short ; } } elseif ( ( $ long = $ short . '_' . strtoupper ( $ short ) ) != $ lang ) { if ( file_exists ( $ rootDir . '/assets/tinymce4/js/langs/' . $ long . '.js' ) ) { return $ long ; } } return 'en' ; }
8954	public function createWay ( $ changeset , $ tags , $ nds ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'way/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ ndList = '' ; if ( ! empty ( $ nds ) ) { foreach ( $ nds as $ value ) { $ ndList .= '<nd ref="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <way changeset="' . $ changeset . '">' . $ tagList . $ ndList . '</way> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
6896	public function set ( $ key , $ value ) { $ this -> open ( ) ; $ this -> _data [ $ key ] = $ value ; return $ this ; }
11501	protected function loadContainer ( array $ config = [ ] , $ environment = null ) { $ containerConfigs = $ this -> provideContainerConfigs ( $ config , $ environment ) ; array_unshift ( $ containerConfigs , new WeaveConfig ( function ( $ pipelineName ) { return $ this -> provideMiddlewarePipeline ( $ pipelineName ) ; } , function ( $ router ) { return $ this -> provideRouteConfiguration ( $ router ) ; } ) ) ; $ this -> container = ( new ContainerBuilder ) -> newConfiguredInstance ( $ containerConfigs , ContainerBuilder :: AUTO_RESOLVE ) ; return $ this -> container -> get ( 'instantiator' ) ; }
10477	protected function displayExceptions ( Exception $ e ) { $ this -> display [ ] = 'Cerbero\Auth\Exceptions\DisplayException' ; foreach ( $ this -> display as $ exception ) { if ( $ e instanceof $ exception ) { return back ( ) -> withInput ( ) -> withError ( $ e -> getMessage ( ) ) ; } } }
11676	protected function get ( $ locale , $ file , $ key ) { $ this -> load ( $ locale , $ file ) ; if ( array_key_exists ( $ key , $ this -> translations [ $ locale ] [ $ file ] ) === false ) { throw new TranslationKeyNotFound ( $ key , $ this -> getPath ( ) , $ locale , $ file ) ; } $ result = $ this -> translations [ $ locale ] [ $ file ] [ $ key ] ; if ( is_string ( $ result ) === false ) { throw new TranslationKeyIsNotAString ( $ result , $ key , $ this -> getPath ( ) , $ locale , $ file ) ; } return $ result ; }
5797	public static function getRouteName ( bool $ isAdmin = true , string $ routePrefix = null , string $ routeType = null , string $ requestMethod = null ) : string { $ routeName = '' ; if ( $ isAdmin ) { $ routeName .= ROUTEPREFIX_ADMIN ; } if ( $ routePrefix !== null ) { $ routeName .= '.' . $ routePrefix ; } if ( $ requestMethod !== null ) { $ validActionMethods = [ 'put' , 'post' ] ; if ( ! in_array ( $ requestMethod , $ validActionMethods ) ) { throw new \ Exception ( "Invalid request method $requestMethod. Only post and put accepted in route names." ) ; } $ routeName .= '.' . $ requestMethod ; } if ( $ routeType !== null ) { if ( ! in_array ( $ routeType , self :: VALID_ROUTE_TYPES ) ) { throw new \ Exception ( "Invalid route type $routeType" ) ; } $ routeName .= '.' . $ routeType ; } return $ routeName ; }
4378	protected function buildTableRow ( $ row , $ keys , $ rowKey ) { $ str = '' ; $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; $ parsed = $ this -> debug -> utilities -> parseTag ( $ this -> dump ( $ rowKey ) ) ; $ str .= '<tr>' ; $ str .= $ this -> debug -> utilities -> buildTag ( 'th' , array ( 'class' => 't_key text-right ' . $ parsed [ 'attribs' ] [ 'class' ] , 'scope' => 'row' , ) , $ parsed [ 'innerhtml' ] ) ; if ( $ objInfo [ 'row' ] ) { $ str .= $ this -> markupClassname ( $ objInfo [ 'row' ] [ 'className' ] , 'td' , array ( 'title' => $ objInfo [ 'row' ] [ 'phpDoc' ] [ 'summary' ] ? : null , ) ) ; $ this -> tableInfo [ 'haveObjRow' ] = true ; } else { $ str .= '<td class="t_classname"></td>' ; } foreach ( $ values as $ v ) { $ str .= $ this -> dump ( $ v , true , 'td' ) ; } $ str .= '</tr>' . "\n" ; $ str = \ str_replace ( ' title=""' , '' , $ str ) ; foreach ( \ array_keys ( $ this -> tableInfo [ 'totals' ] ) as $ k ) { $ this -> tableInfo [ 'totals' ] [ $ k ] += $ values [ $ k ] ; } foreach ( $ objInfo [ 'cols' ] as $ k2 => $ classname ) { if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] === false ) { continue ; } if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] === null ) { $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] = $ classname ; } if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] !== $ classname ) { $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] = false ; } } return $ str ; }
2531	private function getStatefulStatusCode ( $ messageName , array $ messageOptions ) { if ( 'Security_Authenticate' === $ messageName ) { return self :: TRANSACTION_STATUS_CODE_START ; } if ( isset ( $ messageOptions [ 'endSession' ] ) && $ messageOptions [ 'endSession' ] === true ) { return self :: TRANSACTION_STATUS_CODE_END ; } return self :: TRANSACTION_STATUS_CODE_INSERIES ; }
9078	private static function parseContextPrefix ( Request & $ request , $ serverVars = array ( ) ) { if ( isset ( $ serverVars [ 'CONTEXT_PREFIX' ] ) && $ serverVars [ 'CONTEXT_PREFIX' ] != '' ) { $ request -> setContextPrefix ( $ serverVars [ 'CONTEXT_PREFIX' ] . '/' ) ; } elseif ( isset ( $ serverVars [ 'REDIRECT_BASE' ] ) ) { $ request -> setContextPrefix ( $ serverVars [ 'REDIRECT_BASE' ] ) ; } elseif ( isset ( $ serverVars [ 'SCRIPT_FILENAME' ] ) && isset ( $ serverVars [ 'SCRIPT_NAME' ] ) ) { if ( isset ( $ serverVars [ 'HTTP_HOST' ] ) ) { $ scriptName = preg_replace ( '/^.+[\\\\\\/]/' , '' , $ serverVars [ 'SCRIPT_FILENAME' ] ) ; $ request -> contextPrefix = str_replace ( $ scriptName , '' , $ serverVars [ 'SCRIPT_NAME' ] ) ; } } }
2084	public function rotateLogs ( ) { @ trigger_error ( 'Using Automator::rotateLogs() has been deprecated and will no longer work in Contao 5.0. Use the logger service instead, which rotates its log files automatically.' , E_USER_DEPRECATED ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrFiles = preg_grep ( '/\.log$/' , scan ( $ rootDir . '/system/logs' ) ) ; foreach ( $ arrFiles as $ strFile ) { $ objFile = new File ( 'system/logs/' . $ strFile . '.9' ) ; if ( $ objFile -> exists ( ) ) { $ objFile -> delete ( ) ; } for ( $ i = 8 ; $ i > 0 ; $ i -- ) { $ strGzName = 'system/logs/' . $ strFile . '.' . $ i ; if ( file_exists ( $ rootDir . '/' . $ strGzName ) ) { $ objFile = new File ( $ strGzName ) ; $ objFile -> renameTo ( 'system/logs/' . $ strFile . '.' . ( $ i + 1 ) ) ; } } $ objFile = new File ( 'system/logs/' . $ strFile ) ; $ objFile -> renameTo ( 'system/logs/' . $ strFile . '.1' ) ; } }
4391	public function getConfigBE ( ) { $ list = [ ] ; foreach ( $ this -> beConfig as $ key => $ config ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( $ config ) ; } return $ list ; }
10663	public function setParamType ( $ type ) { if ( ! is_string ( $ type ) || ! in_array ( $ type , [ self :: PARAM_MULTIPART , self :: PARAM_FORM ] ) ) { throw new InvalidArgumentException ( sprintf ( "Invalid parameter form type, form type only allowed $1s and $2s" , self :: PARAM_FORM , self :: PARAM_MULTIPART ) , E_USER_ERROR ) ; } $ this -> currentParamType = $ type ; $ reverse_params = $ type == self :: PARAM_FORM ? self :: PARAM_MULTIPART : self :: PARAM_FORM ; $ reverse_params_value = isset ( $ this -> configs [ $ reverse_params ] ) ? $ this -> configs [ $ reverse_params ] : null ; $ params_value = isset ( $ this -> configs [ $ type ] ) ? $ this -> configs [ $ type ] : null ; unset ( $ this -> configs [ self :: PARAM_FORM ] , $ this -> configs [ self :: PARAM_MULTIPART ] ) ; $ this -> configs [ $ type ] = is_array ( $ reverse_params_value ) ? $ reverse_params_value : ( is_array ( $ params_value ) ? $ params_value : [ ] ) ; return $ this -> buildConfigClient ( ) ; }
647	public function addCommentOnColumn ( $ table , $ column , $ comment ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addCommentOnColumn ( $ table , $ column , $ comment ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
7651	public function rename ( $ path_from , $ path_to ) { if ( $ this -> getContainerName ( $ path_from ) != $ this -> getContainerName ( $ path_to ) ) { throw new BlobException ( 'Container name can not be changed.' ) ; } if ( $ this -> getFileName ( $ path_from ) == $ this -> getContainerName ( $ path_to ) ) { return true ; } $ this -> getStorageClient ( $ path_from ) -> copyBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) , $ this -> getContainerName ( $ path_to ) , $ this -> getFileName ( $ path_to ) ) ; $ this -> getStorageClient ( $ path_from ) -> deleteBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) ) ; clearstatcache ( true , $ path_from ) ; clearstatcache ( true , $ path_to ) ; return true ; }
3893	private function renderEditButton ( $ caption , $ title , UrlBuilder $ url ) { $ icon = $ this -> iconBuilder -> getBackendIconImageTag ( 'system/themes/flexible/icons/alias.svg' , $ caption , 'style="vertical-align:top"' ) ; return sprintf ( '<a href="%s" title="%s" style="padding-left:3px">%s</a>' , $ url -> getUrl ( ) , $ title , $ icon ) ; }
2097	public static function getRegexp ( $ strFormat = null ) { if ( $ strFormat === null ) { $ strFormat = static :: getNumericDateFormat ( ) ; } if ( ! static :: isNumericFormat ( $ strFormat ) ) { throw new \ Exception ( sprintf ( 'Invalid date format "%s"' , $ strFormat ) ) ; } return preg_replace_callback ( '/[a-zA-Z]/' , function ( $ matches ) { $ arrRegexp = array ( 'a' => '(?P<a>am|pm)' , 'A' => '(?P<A>AM|PM)' , 'd' => '(?P<d>0[1-9]|[12][0-9]|3[01])' , 'g' => '(?P<g>[1-9]|1[0-2])' , 'G' => '(?P<G>[0-9]|1[0-9]|2[0-3])' , 'h' => '(?P<h>0[1-9]|1[0-2])' , 'H' => '(?P<H>[01][0-9]|2[0-3])' , 'i' => '(?P<i>[0-5][0-9])' , 'j' => '(?P<j>[1-9]|[12][0-9]|3[01])' , 'm' => '(?P<m>0[1-9]|1[0-2])' , 'n' => '(?P<n>[1-9]|1[0-2])' , 's' => '(?P<s>[0-5][0-9])' , 'Y' => '(?P<Y>[0-9]{4})' , 'y' => '(?P<y>[0-9]{2})' , ) ; return $ arrRegexp [ $ matches [ 0 ] ] ?? $ matches [ 0 ] ; } , preg_quote ( $ strFormat ) ) ; }
1732	public function generate ( ) { $ objArticle = ArticleModel :: findPublishedById ( $ this -> article ) ; if ( $ objArticle === null ) { return '' ; } $ objParent = PageModel :: findPublishedById ( $ objArticle -> pid ) ; if ( $ objParent === null ) { return '' ; } $ this -> objArticle = $ objArticle ; $ this -> objParent = $ objParent ; return parent :: generate ( ) ; }
11981	public function isAccessible ( AcquirerInterface $ acquirer , ResourceInterface $ resource ) { if ( ! $ resource -> isLocked ( ) ) { return true ; } $ lock = $ resource -> getLock ( ) ; if ( $ lock instanceof ExpiringLockInterface and $ this -> isLockExpired ( $ lock ) ) { $ this -> release ( $ lock ) ; return true ; } return $ lock -> getAcquirer ( ) -> getIdentifier ( ) === $ acquirer -> getIdentifier ( ) ; }
11129	protected function stringize ( array & $ arguments ) { array_walk ( $ arguments , function ( & $ value ) { if ( is_object ( $ value ) ) { $ value = get_class ( $ value ) ; } elseif ( is_scalar ( $ value ) ) { $ value = ( string ) $ value ; } else { $ value = json_encode ( $ value , 0 ) ; } } ) ; return $ this ; }
4354	protected function setFile ( $ file ) { if ( $ file == $ this -> file ) { return ; } if ( $ this -> fileHandle ) { \ fclose ( $ this -> fileHandle ) ; $ this -> fileHandle = null ; } $ this -> file = $ file ; if ( empty ( $ file ) ) { return ; } $ fileExists = \ file_exists ( $ file ) ; $ this -> fileHandle = \ fopen ( $ file , 'a' ) ; if ( $ this -> fileHandle ) { \ fwrite ( $ this -> fileHandle , '***** ' . \ date ( 'Y-m-d H:i:s' ) . ' *****' . "\n" ) ; if ( ! $ fileExists ) { \ chmod ( $ file , 0660 ) ; } } }
9075	public function add ( $ name , Rule $ rule ) { unset ( $ this -> rules [ $ name ] ) ; $ this -> rules [ $ name ] = $ rule ; }
8712	public function whereTranslated ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { if ( func_num_args ( ) == 2 ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } elseif ( $ this -> invalidOperatorAndValue ( $ operator , $ value ) ) { throw new InvalidArgumentException ( 'Illegal operator and value combination.' ) ; } if ( ! in_array ( strtolower ( $ operator ) , $ this -> operators , true ) ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } $ fallbackColumn = $ this -> qualifyTranslationColumn ( $ column , true ) ; $ column = $ this -> qualifyTranslationColumn ( $ column ) ; if ( ! $ this -> model -> shouldFallback ( ) || $ column instanceof Closure ) { return $ this -> where ( $ column , $ operator , $ value , $ boolean ) ; } $ condition = $ this -> compileIfNull ( $ column , $ fallbackColumn ) ; return $ this -> whereRaw ( "$condition $operator ?" , [ $ value ] , $ boolean ) ; }
10749	protected function sendDeleted ( Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { return $ this -> sendVerb ( 'deleted' , $ response , $ type , $ ids , $ extra ) ; }
11148	public function getMultipleDisplayObjects ( $ areas ) { $ out = array ( ) ; foreach ( $ areas as $ v ) { if ( ! ( $ v instanceof Neuron_GameServer_Map_Area ) ) { throw new Neuron_Exceptions_InvalidParameter ( "Parameters must be an array of area objects." ) ; } foreach ( $ this -> getDisplayObjects ( $ v ) as $ v ) { if ( ! $ v instanceof Neuron_GameServer_Map_MapObject ) { throw new Neuron_Core_Error ( "All map objects MUST implement Neuron_GameServer_Map_MapObject" ) ; } $ out [ ] = $ v ; } } return $ out ; }
816	private function getMeaningfulSequence ( Tokens $ tokens , $ start , $ end ) { $ sequence = [ ] ; $ index = $ start ; while ( $ index < $ end ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( $ index >= $ end || null === $ index ) { break ; } $ sequence [ ] = $ tokens [ $ index ] ; } return Tokens :: fromArray ( $ sequence ) ; }
413	public function setPort ( $ value ) { if ( $ value != $ this -> _port ) { $ this -> _port = ( int ) $ value ; $ this -> _hostInfo = null ; } }
7996	protected function validateHashContext ( $ context ) { if ( ! ( $ context instanceof HashContext ) && ( false === $ context || ! is_resource ( $ context ) || ( is_resource ( $ context ) && static :: HASH_CONTEXT_RESOURCE_TYPE !== get_resource_type ( $ context ) ) ) ) { throw new InvalidArgumentException ( 'Unable to initialize hashing context. Your system might not support the supplied algorithm.' ) ; } return $ context ; }
6646	public function authenticate ( ) { $ request_token = $ this -> oauth -> getRequestToken ( $ this -> settings , $ this -> consumer , $ this -> token ) ; $ auth_url = $ this -> settings ( 'auth_api_url' ) . $ this -> settings ( 'authentication_uri' ) ; $ auth_url .= '?' . http_build_query ( [ 'oauth_token' => $ request_token -> key ] ) ; return $ this -> redirect -> to ( $ auth_url ) ; }
8643	public function cancelReportRequests ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_CancelReportRequestsRequest ) { $ request = new MarketplaceWebService_Model_CancelReportRequestsRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertCancelReportRequests ( $ request ) ) ; $ response = MarketplaceWebService_Model_CancelReportRequestsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1259	private function write ( $ str ) { $ this -> source .= $ this -> indentation ; if ( func_num_args ( ) == 1 ) { $ this -> source .= $ str . "\n" ; return $ this ; } $ this -> source .= vsprintf ( $ str , array_slice ( func_get_args ( ) , 1 ) ) . "\n" ; return $ this ; }
1767	private function getRelativeRequestUri ( Request $ request ) : string { return ( string ) substr ( $ request -> getRequestUri ( ) , \ strlen ( $ request -> getBasePath ( ) ) + 1 ) ; }
8231	public static function getItemByUrl ( $ items , $ url ) { if ( ! isset ( $ items ) ) { return null ; } if ( array_key_exists ( "/" . $ url , $ items ) ) { return $ items [ "/" . $ url ] ; } $ urlParts = explode ( "/" , trim ( $ url , "/" ) ) ; $ urlPartsLen = count ( $ urlParts ) ; while ( $ urlPartsLen > 0 ) { unset ( $ urlParts [ -- $ urlPartsLen ] ) ; $ subUrl = "/" . join ( "/" , $ urlParts ) ; if ( array_key_exists ( $ subUrl , $ items ) && ( ! isset ( $ items [ $ subUrl ] [ "recursive" ] ) || $ items [ $ subUrl ] [ "recursive" ] === true ) ) { return $ items [ $ subUrl ] ; } } return null ; }
7960	public function canChangeDslamProfile ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> capabilities -> canChangeDslamProfile ; }
9678	public function allNumberFormats ( Spreadsheet $ spreadsheet ) { $ aNumFmts = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) === false && ! isset ( $ aNumFmts [ $ style -> getNumberFormat ( ) -> getHashCode ( ) ] ) ) { $ aNumFmts [ $ style -> getNumberFormat ( ) -> getHashCode ( ) ] = $ style -> getNumberFormat ( ) ; } } return $ aNumFmts ; }
10981	public function tree ( $ trans = false ) { $ tree = [ ] ; foreach ( $ this -> items as $ date => $ log ) { $ tree [ $ date ] = $ log -> tree ( $ trans ) ; } return $ tree ; }
6745	private function applyResponseEncoding ( Request $ request , Response $ response ) { $ allowedCompressionAsString = $ request -> headers -> get ( 'Accept-Encoding' ) ; if ( ! $ allowedCompressionAsString ) { return ; } $ allowedCompression = explode ( ',' , $ allowedCompressionAsString ) ; $ allowedCompression = array_map ( 'trim' , $ allowedCompression ) ; if ( in_array ( 'gzip' , $ allowedCompression ) ) { $ response -> setContent ( gzencode ( $ response -> getContent ( ) ) ) ; $ response -> headers -> set ( 'Content-Encoding' , 'gzip' ) ; return ; } if ( in_array ( 'deflate' , $ allowedCompression ) ) { $ response -> setContent ( gzdeflate ( $ response -> getContent ( ) ) ) ; $ response -> headers -> set ( 'Content-Encoding' , 'deflate' ) ; return ; } }
1199	public function addVoter ( VoterInterface $ voter ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 2.3 and will be removed in 3.0. Pass voters in the constructor instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( $ this -> voters instanceof \ Traversable ) { $ this -> voters = iterator_to_array ( $ this -> voters ) ; } $ this -> voters [ ] = $ voter ; }
253	protected function freeze ( ) { if ( $ this -> getIsActive ( ) ) { if ( isset ( $ _SESSION ) ) { $ this -> frozenSessionData = $ _SESSION ; } $ this -> close ( ) ; Yii :: info ( 'Session frozen' , __METHOD__ ) ; } }
12347	public function add ( array $ assets ) { foreach ( $ assets as $ type => $ asset ) { if ( $ asset instanceof Plugin ) { $ this -> parse ( $ asset ) ; continue ; } $ this -> assets [ $ type ] = array_merge ( $ this -> assets [ $ type ] , $ asset ) ; } }
12178	public function getIndividual ( ) { if ( ! isset ( $ this -> _individual ) && ! empty ( $ this -> object_individual_id ) ) { $ this -> _individual = false ; $ individualType = Yii :: $ app -> collectors [ 'types' ] -> getOne ( 'Individual' ) ; if ( ! empty ( $ individualType -> object ) ) { $ individualClass = $ individualType -> object -> primaryModel ; $ this -> _individual = $ individualClass :: get ( $ this -> object_individual_id ) ; } } return $ this -> _individual ; }
10746	protected function sendJson ( Response $ response , $ payload ) : Response { $ response -> getBody ( ) -> write ( json_encode ( $ payload ) ) ; return $ response -> withHeader ( 'Content-Type' , 'application/json' ) ; }
8766	protected function loadConfigFiles ( ) { try { if ( file_exists ( $ this -> cachePath ( 'config.php' ) ) ) { $ this -> config = require $ this -> cachePath ( 'config.php' ) ; } else { $ dotenv = new \ Dotenv \ Dotenv ( $ this -> root ) ; $ dotenv -> load ( ) ; foreach ( glob ( $ this -> root . '/config/*.php' ) as $ file ) { $ keyName = strtolower ( str_replace ( [ $ this -> root . '/config/' , '.php' ] , '' , $ file ) ) ; $ this -> config [ $ keyName ] = require $ file ; } } } catch ( Exception $ e ) { die ( printf ( "Configuration information could not be retrieved properly.\nError Message: %s" , $ e -> getMessage ( ) ) ) ; } }
8880	private function isValidFullPath ( string $ path ) : bool { $ valid = false ; if ( '/' === substr ( $ path , 0 , 1 ) && is_executable ( $ path ) ) { $ valid = true ; } return $ valid ; }
1325	public static function fromConsumerAndToken ( Consumer $ consumer , Token $ token = null , $ httpMethod , $ httpUrl , array $ parameters = [ ] , $ json = false ) { $ defaults = [ "oauth_version" => Request :: $ version , "oauth_nonce" => Request :: generateNonce ( ) , "oauth_timestamp" => time ( ) , "oauth_consumer_key" => $ consumer -> key ] ; if ( null !== $ token ) { $ defaults [ 'oauth_token' ] = $ token -> key ; } if ( $ json ) { $ parameters = $ defaults ; } else { $ parameters = array_merge ( $ defaults , $ parameters ) ; } return new Request ( $ httpMethod , $ httpUrl , $ parameters ) ; }
4426	protected function askForData ( $ optionIdentifier , $ optionName , $ defaultValue , $ validator = null ) { $ optionValue = $ this -> input -> getOption ( $ optionIdentifier ) ; $ optionValue = ! empty ( $ optionValue ) ? $ optionValue : $ defaultValue ; $ question = $ this -> getQuestion ( $ optionName , $ optionValue , $ validator ) ; $ optionValue = $ this -> questionHelper -> ask ( $ this -> input , $ this -> output , $ question ) ; $ this -> input -> setOption ( $ optionIdentifier , $ optionValue ) ; return $ optionValue ; }
6151	public function redirect ( string $ url ) : object { $ this -> addHeader ( "Location: " . $ url ) ; $ this -> body = null ; return $ this ; }
4544	public function kernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( $ exception instanceof ValidationException ) { return ; } $ data = [ 'type' => 'https://tools.ietf.org/html/rfc2616#section-10' , 'title' => 'An error occurred' ] ; if ( in_array ( $ this -> environment , [ 'dev' , 'test' ] , true ) ) { $ data [ 'detail' ] = $ exception -> getMessage ( ) ; $ data [ 'trace' ] = $ exception -> getTrace ( ) ; } $ request = $ event -> getRequest ( ) ; $ contentTypes = $ request -> getAcceptableContentTypes ( ) ; $ accept = array_shift ( $ contentTypes ) ; switch ( $ accept ) { case 'application/json' : case 'application/ld+json' : $ code = Response :: HTTP_INTERNAL_SERVER_ERROR ; if ( $ exception instanceof HttpException ) { $ code = $ exception -> getStatusCode ( ) ; } $ response = new JsonResponse ( $ data , $ code ) ; $ event -> setResponse ( $ response ) ; break ; } }
4590	public function exists ( $ form , Parameters $ parameters = null ) : bool { $ object = $ this -> execute ( 'GET' , 'http://www.mocky.io/v2/592c6f7311000029066df850' ) ; if ( $ object && property_exists ( $ object , '_id' ) && $ object -> _id ) { return true ; } return false ; }
3189	public function getLastTimestamp ( $ tags ) { $ range = $ this -> getRange ( $ tags ) ; $ length = count ( $ range ) ; $ last = false ; if ( $ length ) { $ last = $ range [ $ length - 1 ] -> getTimestamp ( ) ; } return $ last ; }
1136	public function setDepth ( ) { $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ level = $ self -> getLevel ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ self -> getKeyName ( ) , '=' , $ self -> getKey ( ) ) -> update ( array ( $ self -> getDepthColumnName ( ) => $ level ) ) ; $ self -> setAttribute ( $ self -> getDepthColumnName ( ) , $ level ) ; } ) ; return $ this ; }
3981	private function getChildModelCaption ( $ metaModel , $ screen ) { $ caption = [ '' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodel_edit_as_child' ] [ 'label' ] , $ metaModel -> getName ( ) ) ] ; foreach ( $ screen [ 'label' ] as $ langCode => $ label ) { if ( ! empty ( $ label ) && $ langCode === $ GLOBALS [ 'TL_LANGUAGE' ] ) { $ caption = [ $ screen [ 'description' ] [ $ langCode ] , $ label ] ; } } return $ caption ; }
4900	public static function loadDotEnv ( ) { $ dotenv = new Dotenv ( ) ; if ( is_file ( getcwd ( ) . '/.env.dist' ) ) { $ dotenv -> load ( getcwd ( ) . '/.env.dist' ) ; } if ( is_file ( $ file = getcwd ( ) . '/.env' ) ) { $ dotenv -> load ( $ file ) ; } if ( false === getenv ( 'TIMEZONE' ) ) { putenv ( 'TIMEZONE=Europe/Berlin' ) ; } date_default_timezone_set ( getenv ( 'TIMEZONE' ) ) ; }
1759	public static function getSessionHash ( $ strCookie ) { @ trigger_error ( 'Using System::getSessionHash() has been deprecated and will no longer work in Contao 5.0. Use Symfony authentication instead.' , E_USER_DEPRECATED ) ; $ session = static :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { $ session -> start ( ) ; } return sha1 ( $ session -> getId ( ) . $ strCookie ) ; }
335	protected function createColumn ( $ column ) { $ c = $ this -> createColumnSchema ( ) ; $ c -> name = $ column [ 'COLUMN_NAME' ] ; $ c -> allowNull = $ column [ 'NULLABLE' ] === 'Y' ; $ c -> comment = $ column [ 'COLUMN_COMMENT' ] === null ? '' : $ column [ 'COLUMN_COMMENT' ] ; $ c -> isPrimaryKey = false ; $ this -> extractColumnType ( $ c , $ column [ 'DATA_TYPE' ] , $ column [ 'DATA_PRECISION' ] , $ column [ 'DATA_SCALE' ] , $ column [ 'DATA_LENGTH' ] ) ; $ this -> extractColumnSize ( $ c , $ column [ 'DATA_TYPE' ] , $ column [ 'DATA_PRECISION' ] , $ column [ 'DATA_SCALE' ] , $ column [ 'DATA_LENGTH' ] ) ; $ c -> phpType = $ this -> getColumnPhpType ( $ c ) ; if ( ! $ c -> isPrimaryKey ) { if ( stripos ( $ column [ 'DATA_DEFAULT' ] , 'timestamp' ) !== false ) { $ c -> defaultValue = null ; } else { $ defaultValue = $ column [ 'DATA_DEFAULT' ] ; if ( $ c -> type === 'timestamp' && $ defaultValue === 'CURRENT_TIMESTAMP' ) { $ c -> defaultValue = new Expression ( 'CURRENT_TIMESTAMP' ) ; } else { if ( $ defaultValue !== null ) { if ( ( $ len = strlen ( $ defaultValue ) ) > 2 && $ defaultValue [ 0 ] === "'" && $ defaultValue [ $ len - 1 ] === "'" ) { $ defaultValue = substr ( $ column [ 'DATA_DEFAULT' ] , 1 , - 1 ) ; } else { $ defaultValue = trim ( $ defaultValue ) ; } } $ c -> defaultValue = $ c -> phpTypecast ( $ defaultValue ) ; } } } return $ c ; }
6613	public function settings ( $ setting = null ) { if ( ! is_null ( $ setting ) ) { return isset ( $ this -> settings [ $ setting ] ) ? $ this -> settings [ $ setting ] : null ; } return $ this -> settings ; }
1946	public function getCustomSections ( $ strKey = null ) { @ trigger_error ( 'Using FrontendTemplate::getCustomSections() has been deprecated and will no longer work in Contao 5.0. Use FrontendTemplate::sections() instead.' , E_USER_DEPRECATED ) ; if ( $ strKey != '' && ! isset ( $ this -> positions [ $ strKey ] ) ) { return '' ; } $ tag = 'div' ; if ( $ strKey == 'main' ) { $ tag = 'section' ; } $ sections = '' ; foreach ( $ this -> positions [ $ strKey ] as $ sect ) { if ( isset ( $ this -> sections [ $ sect [ 'id' ] ] ) ) { $ sections .= "\n" . '<' . $ tag . ' id="' . StringUtil :: standardize ( $ sect [ 'id' ] , true ) . '">' . "\n" . '<div class="inside">' . "\n" . $ this -> sections [ $ sect [ 'id' ] ] . "\n" . '</div>' . "\n" . '</' . $ tag . '>' . "\n" ; } } if ( $ sections == '' ) { return '' ; } return '<div class="custom">' . "\n" . $ sections . "\n" . '</div>' . "\n" ; }
11179	protected function get ( $ key ) { $ cache = apc_fetch ( $ this -> getKey ( ) ) ; if ( ! is_array ( $ cache ) ) { return false ; } else { if ( isset ( $ cache [ $ key ] ) ) { return $ cache [ $ key ] ; } return false ; } }
4637	private function createMailEvent ( Email $ email , string $ name , ResultInterface $ result = null ) : MailEvent { $ event = new MailEvent ( $ email , $ name ) ; if ( $ result !== null ) { $ event -> setResult ( $ result ) ; } return $ event ; }
3977	private function addEditMultipleCommand ( Contao2BackendViewDefinitionInterface $ view ) { $ definition = $ this -> container -> getBasicDefinition ( ) ; if ( ! $ definition -> isEditable ( ) && ! $ definition -> isDeletable ( ) && ! $ definition -> isCreatable ( ) ) { return ; } $ commands = $ view -> getGlobalCommands ( ) ; $ command = new SelectCommand ( ) ; $ command -> setName ( 'all' ) -> setLabel ( 'MSC.all.0' ) -> setDescription ( 'MSC.all.1' ) ; $ parameters = $ command -> getParameters ( ) ; $ parameters [ 'act' ] = 'select' ; $ extra = $ command -> getExtra ( ) ; $ extra [ 'class' ] = 'header_edit_all' ; $ commands -> addCommand ( $ command ) ; }
1289	public function setType ( string $ type = null ) { $ validTypes = [ 'all' , 'Asset' , 'Entry' , 'Deletion' , 'DeletedAsset' , 'DeletedEntry' ] ; if ( ! \ in_array ( $ type , $ validTypes , true ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Unexpected type "%s".' , $ type ) ) ; } $ this -> type = $ type ; return $ this ; }
4464	public function childPerform ( BaseJob $ job ) : void { $ loggerContext = [ 'job' => $ job -> jid , 'type' => $ this -> who ] ; try { if ( $ this -> jobPerformHandler ) { if ( $ this -> jobPerformHandler instanceof EventsManagerAwareInterface ) { $ this -> jobPerformHandler -> setEventsManager ( $ this -> client -> getEventsManager ( ) ) ; } if ( method_exists ( $ this -> jobPerformHandler , 'setUp' ) ) { $ this -> jobPerformHandler -> setUp ( ) ; } $ this -> getEventsManager ( ) -> fire ( new JobEvent \ BeforePerform ( $ this -> jobPerformHandler , $ job ) ) ; $ this -> jobPerformHandler -> perform ( $ job ) ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ AfterPerform ( $ this -> jobPerformHandler , $ job ) ) ; if ( method_exists ( $ this -> jobPerformHandler , 'tearDown' ) ) { $ this -> jobPerformHandler -> tearDown ( ) ; } } else { $ job -> perform ( ) ; } $ this -> logger -> notice ( '{type}: job {job} has finished' , $ loggerContext ) ; } catch ( \ Throwable $ e ) { $ loggerContext [ 'stack' ] = $ e -> getMessage ( ) ; $ this -> logger -> critical ( '{type}: job {job} has failed {stack}' , $ loggerContext ) ; $ job -> fail ( 'system:fatal' , sprintf ( '%s: %s in %s on line %d' , get_class ( $ e ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) ) ) ; } }
6799	public function installCountries ( $ code = 'US' ) { $ countryNames = Intl :: getRegionBundle ( ) -> getCountryNames ( ) ; if ( ! isset ( $ countryNames [ $ code ] ) ) { throw new InvalidArgumentException ( "Invalid default country code '$code'." ) ; } asort ( $ countryNames ) ; $ this -> generate ( Country :: class , $ countryNames , $ code ) ; }
12973	public function setMappings ( $ mappingName , array $ mappingConfig = null ) { if ( is_array ( $ mappingName ) === false ) { $ mappingName = array ( $ mappingName => $ mappingConfig ) ; } \ Arr :: set ( $ this -> config [ 'mappings' ] , $ mappingName ) ; return $ this ; }
7254	static public function isBetterState ( $ stateA , $ stateB ) { if ( $ stateA === static :: STATE_IN_STOCK ) { return $ stateB !== static :: STATE_IN_STOCK ; } elseif ( $ stateA === static :: STATE_PRE_ORDER ) { return $ stateB === static :: STATE_OUT_OF_STOCK ; } return false ; }
4919	public function attachInputFilterDefaults ( InputFilterInterface $ inputFilter , FieldsetInterface $ fieldset ) { parent :: attachInputFilterDefaults ( $ inputFilter , $ fieldset ) ; foreach ( $ inputFilter -> getInputs ( ) as $ name => $ input ) { if ( ! $ input instanceof InputFilterInterface ) { $ required = $ input -> isRequired ( ) ; $ inputExists = $ fieldset -> has ( $ name ) ; if ( ! $ inputExists && $ required ) { $ fieldsetName = '' ; if ( $ fieldset -> hasAttribute ( 'name' ) ) { $ fieldsetName = 'in Fieldset "' . $ fieldset -> getAttribute ( 'name' ) . '" ' ; } throw new \ RuntimeException ( 'input for "' . $ name . '" ' . $ fieldsetName . 'is required but a input-field with this name is not defined' ) ; } } } }
3364	public function flush ( $ args , $ assoc_args ) { self :: apache_modules ( ) ; if ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) && ! in_array ( 'mod_rewrite' , ( array ) WP_CLI :: get_config ( 'apache_modules' ) , true ) ) { WP_CLI :: warning ( 'Regenerating a .htaccess file requires special configuration. See usage docs.' ) ; } if ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) && is_multisite ( ) ) { WP_CLI :: warning ( "WordPress can't generate .htaccess file for a multisite install." ) ; } self :: check_skip_plugins_themes ( ) ; flush_rewrite_rules ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) ) ; if ( ! get_option ( 'rewrite_rules' ) ) { WP_CLI :: warning ( "Rewrite rules are empty, possibly because of a missing permalink_structure option. Use 'wp rewrite list' to verify, or 'wp rewrite structure' to update permalink_structure." ) ; } else { WP_CLI :: success ( 'Rewrite rules flushed.' ) ; } }
4846	public static function register ( array $ aliases ) { if ( ! $ aliases ) { return ; } if ( ! isset ( self :: $ autoloadFn ) ) { $ classAliases = & self :: $ aliases ; self :: $ autoloadFn = function ( $ className ) use ( & $ classAliases ) { if ( isset ( $ classAliases [ $ className ] ) ) { if ( strtolower ( $ classAliases [ $ className ] ) === strtolower ( $ className ) ) { throw new \ LogicException ( "Class alias is referencing the alias itself" ) ; } $ facadeClass = $ classAliases [ $ className ] ; class_alias ( $ facadeClass , $ className ) ; } } ; spl_autoload_register ( self :: $ autoloadFn ) ; } self :: $ aliases = array_merge ( self :: $ aliases , $ aliases ) ; }
12157	public function getObjectTypeModel ( ) { if ( ! isset ( $ this -> _objectTypeModel ) && isset ( Yii :: $ app -> collectors [ 'types' ] -> tableRegistry [ $ this -> systemId ] ) ) { $ this -> _objectTypeModel = Yii :: $ app -> collectors [ 'types' ] -> tableRegistry [ $ this -> systemId ] ; } return $ this -> _objectTypeModel ; }
12522	public function renderWidget ( array $ fields , $ customFieldOrClass , $ documentType = 'html' , $ slug = null ) { return $ this -> container -> get ( 'chill.custom_field.helper' ) -> renderCustomField ( $ fields , $ customFieldOrClass , $ documentType , $ slug ) ; }
4285	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ this -> processAlerts ( ) ; $ this -> processSummary ( ) ; $ this -> processLog ( ) ; if ( $ this -> json [ 'rows' ] ) { \ array_unshift ( $ this -> json [ 'rows' ] , array ( array ( 'PHP' , isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ) , null , 'groupCollapsed' , ) ) ; \ array_push ( $ this -> json [ 'rows' ] , array ( array ( ) , null , 'groupEnd' , ) ) ; $ encoded = $ this -> encode ( $ this -> json ) ; if ( \ strlen ( $ encoded ) > 250000 ) { $ this -> debug -> warn ( 'chromeLogger: output limit exceeded' ) ; } else { $ event [ 'headers' ] [ ] = array ( self :: HEADER_NAME , $ encoded ) ; } } $ this -> data = array ( ) ; $ this -> json [ 'rows' ] = array ( ) ; }
10326	function addRule ( $ rule ) { if ( ! $ this -> rules ) $ this -> rules = array ( ) ; array_push ( $ this -> rules , $ rule ) ; }
11968	public static function GetAuthClass ( ) { if ( self :: $ authClass === NULL ) { if ( class_exists ( self :: AUTH_CLASS_FULL ) ) { self :: $ authClass = self :: AUTH_CLASS_FULL ; } else { self :: $ authClass = self :: AUTH_CLASS_BASIC ; } } return self :: $ authClass ; }
9930	public function setFilterType ( $ pFilterType ) { if ( ! in_array ( $ pFilterType , self :: $ filterTypes ) ) { throw new PhpSpreadsheetException ( 'Invalid filter type for column AutoFilter.' ) ; } $ this -> filterType = $ pFilterType ; return $ this ; }
11621	public function view ( ) : \ TheCMSThread \ Core \ Main \ View { static $ view ; if ( $ view === null ) { $ view = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\View" ) ; } $ view -> __construct ( $ this -> auth ( ) ) ; return $ view ; }
5722	public function save ( $ data , $ form ) { $ origStage = Versioned :: get_stage ( ) ; Versioned :: set_stage ( 'Stage' ) ; $ action = $ this -> owner -> doSave ( $ data , $ form ) ; Versioned :: set_stage ( $ origStage ) ; return $ action ; }
10699	public static function isBirthDate ( $ date ) { if ( $ date === null || $ date === '0000-00-00' ) { return true ; } if ( preg_match ( '/^(\d{4})-((?:0?[1-9])|(?:1[0-2]))-((?:0?[1-9])|(?:[1-2]\d)|(?:3[01]))(\d{2}:\d{2}:\d{2})?$/' , $ date , $ birth_date ) ) { return ! ( ( $ birth_date [ 1 ] > date ( 'Y' ) && $ birth_date [ 2 ] > date ( 'm' ) && $ birth_date [ 3 ] > date ( 'd' ) ) || ( $ birth_date [ 1 ] === date ( 'Y' ) && $ birth_date [ 2 ] === date ( 'm' ) && $ birth_date [ 3 ] > date ( 'd' ) ) || ( $ birth_date [ 1 ] === date ( 'Y' ) && $ birth_date [ 2 ] > date ( 'm' ) ) ) ; } return false ; }
3561	protected function getMutatedType ( $ value , $ dir = 'setter' ) { foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ this -> getValueType ( $ value ) == $ mutated || $ value instanceof $ mutated ) { return $ mutated ; } } }
3418	public static function registerEloquent ( ) { $ capsule = self :: bootstrapIlluminateDatabase ( ) ; class_alias ( Capsule :: class , 'DB' ) ; if ( $ _COOKIE [ "show_sql_stat" ] == "Y" ) { Capsule :: enableQueryLog ( ) ; $ em = \ Bitrix \ Main \ EventManager :: getInstance ( ) ; $ em -> addEventHandler ( 'main' , 'OnAfterEpilog' , [ IlluminateQueryDebugger :: class , 'onAfterEpilogHandler' ] ) ; } static :: addEventListenersForHelpersHighloadblockTables ( $ capsule ) ; }
7108	static public function getPrecision ( $ currency ) { if ( isset ( static :: $ precisions [ $ currency ] ) ) { return static :: $ precisions [ $ currency ] ; } return static :: $ precisions [ $ currency ] = static :: getCurrencyBundle ( ) -> getFractionDigits ( $ currency ) ; }
8993	public function expecting ( ) { $ possibilities = count ( $ this -> samples ) ; $ orderedByOccurance = array_count_values ( $ this -> samples ) ; array_multisort ( $ orderedByOccurance , SORT_DESC ) ; $ probabilities = [ ] ; foreach ( $ orderedByOccurance as $ item => $ value ) { $ probabilities [ $ item ] = $ value / $ possibilities ; } return $ probabilities ; }
6018	public function addMediaToDeploymentSite ( $ id , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/deployment/' . $ id . '/media' , $ parameters ) ; return $ result ; }
7144	public static function remove_author_meta_values ( ) { global $ blog_id ; if ( isset ( $ blog_id ) && ! empty ( $ blog_id ) ) { $ blogusers = get_users ( array ( 'blog_id' => $ blog_id ) ) ; foreach ( $ blogusers as $ user_object ) { delete_user_meta ( $ user_object -> ID , 'post_subscription' ) ; delete_user_meta ( $ user_object -> ID , 'comment_subscription' ) ; } } }
7583	protected function extractInfo ( ) { $ this -> info = curl_getinfo ( $ this -> CurlRequest ) ; $ this -> status = $ this -> info [ 'http_code' ] ; if ( curl_errno ( $ this -> CurlRequest ) !== CURLE_OK ) { $ this -> error = curl_error ( $ this -> CurlRequest ) ; } else { $ this -> error = false ; } }
12346	private function createDeleteForm ( Post $ post ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_category_delete' , array ( 'id' => $ post -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
4138	public function postMedia ( $ call , $ filename ) { $ this -> resetCallState ( ) ; $ this -> call = $ call ; $ this -> method = 'POST' ; $ this -> withMedia = true ; $ mimeBoundary = sha1 ( $ call . microtime ( ) ) ; $ params = array ( 'post' => $ this -> buildMultipart ( $ mimeBoundary , $ filename ) , 'headers' => $ this -> buildUploadMediaHeader ( $ mimeBoundary ) , ) ; $ response = $ this -> curl -> send ( $ this -> getUrl ( ) , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> token_type ) || $ obj -> token_type != 'bearer' ) { $ this -> findExceptions ( $ response ) ; } $ this -> headers = $ response [ 'headers' ] ; $ this -> withMedia = null ; unset ( $ call , $ filename , $ mimeBoundary , $ params , $ obj ) ; return $ this -> serializer -> format ( $ response [ 'body' ] ) ; }
8681	public function set ( $ key , $ value ) { Deprecated :: method ( 1.1 , MutableBag :: class ) ; $ this -> items [ $ key ] = $ value ; }
11361	public function isClicked ( string $ sType ) : bool { if ( $ this -> getType ( ) === 'submit' || $ this -> getType ( ) === 'button' ) { if ( isset ( $ _POST [ $ this -> getName ( ) ] ) ) { return true ; } } return false ; }
4469	public function cancel ( $ dependents = false ) : array { if ( $ dependents && ! empty ( $ this -> rawData [ 'dependents' ] ) ) { return call_user_func_array ( [ $ this -> client , 'cancel' ] , array_merge ( [ $ this -> jid ] , $ this -> rawData [ 'dependents' ] ) ) ; } return $ this -> client -> cancel ( $ this -> jid ) ; }
5539	protected function getPublicNameFromIndex ( $ subject ) { foreach ( $ this -> names as $ name => $ index ) { if ( $ subject == $ index ) { return $ name ; } } return $ subject + 1 ; }
3203	protected function validate_css_property_value ( $ value , $ compare_type , $ compare_value ) { switch ( $ compare_type ) { case '!=' : return $ value !== $ compare_value ; case '>' : return $ value > $ compare_value ; default : return false ; } }
10988	public function getConfigTreeBuilder ( ) { $ tree_builder = new TreeBuilder ( ) ; $ tree_builder -> root ( 'anime_db_cache_time_keeper' ) -> children ( ) -> booleanNode ( 'enable' ) -> defaultTrue ( ) -> end ( ) -> scalarNode ( 'use_driver' ) -> cannotBeEmpty ( ) -> defaultValue ( 'file' ) -> end ( ) -> arrayNode ( 'private_headers' ) -> treatNullLike ( [ ] ) -> prototype ( 'scalar' ) -> end ( ) -> defaultValue ( [ 'Authorization' , 'Cookie' ] ) -> end ( ) -> append ( $ this -> getEtagHasher ( ) ) -> append ( $ this -> getTrack ( ) ) -> arrayNode ( 'drivers' ) -> append ( $ this -> getDriverFile ( ) ) -> append ( $ this -> getDriverMemcache ( ) ) -> append ( $ this -> getDriverMulti ( ) ) -> append ( $ this -> getDriverShmop ( ) ) -> end ( ) -> end ( ) ; return $ tree_builder ; }
11364	public static function headerTagger ( $ name = '' , $ value = '' , $ adds = array ( ) ) { $ str = $ name . ': ' . $ value ; if ( count ( $ adds ) ) { foreach ( $ adds as $ n => $ v ) { $ str .= Mailer :: $ HEADERS_SEPARATOR . ( $ n == 'boundary' ? "\n\t" : '' ) . $ n . "=\"" . $ v . "\"" ; } } return ( trim ( $ str , Mailer :: $ HEADERS_SEPARATOR ) ) ; }
1629	public function getMonolog ( ) { foreach ( $ this -> loggers as $ logger ) { if ( is_callable ( [ $ logger , 'getMonolog' ] ) ) { $ monolog = $ logger -> getMonolog ( ) ; if ( $ monolog === null ) { continue ; } return $ monolog ; } } }
1662	public function reply ( $ message ) { if ( is_string ( $ message ) ) { $ this -> messages [ ] = Text :: create ( ) -> text ( $ message ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message ; } } elseif ( $ message instanceof RichMessage ) { if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message -> getFallbackText ( ) ; } $ message -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; $ this -> messages [ ] = $ message ; } elseif ( $ message instanceof Conversation ) { $ this -> messages [ ] = Payload :: create ( $ message -> render ( ) ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; } return $ this ; }
8995	protected function addActions ( SymfonyController $ controller , Resource $ resource , $ chainName = '' ) { $ actions = array ( ) ; $ chainName = $ chainName . '_' . strtolower ( str_replace ( array ( '{' , '}' ) , '' , $ resource -> getDisplayName ( ) ) ) ; foreach ( $ resource -> getMethods ( ) as $ method ) { $ actionName = strtolower ( $ method -> getType ( ) ) . str_replace ( ' ' , '' , ucwords ( str_replace ( '_' , ' ' , $ chainName ) ) ) . 'Action' ; $ route = new SymfonyRoute ( $ resource -> getUri ( ) , strtolower ( $ method -> getType ( ) . $ chainName ) ) ; $ action = new SymfonyAction ( $ actionName , $ route , $ method -> getType ( ) , $ method -> getDescription ( ) ) ; preg_match_all ( '/\{[a-zA-Z]+\}/' , $ resource -> getUri ( ) , $ parameters ) ; foreach ( $ parameters [ 0 ] as $ parameter ) { $ action -> addParameter ( substr ( $ parameter , 1 , strlen ( $ parameter ) - 2 ) ) ; } if ( $ method -> getResponses ( ) ) { foreach ( $ method -> getResponses ( ) as $ code => $ response ) { $ headers = array ( ) ; foreach ( $ response -> getHeaders ( ) as $ key => $ value ) { if ( isset ( $ value [ 'required' ] ) && $ value [ 'required' ] ) { $ headers [ $ key ] = isset ( $ value [ 'example' ] ) ? $ value [ 'example' ] : '' ; } } $ _response = new SymfonyResponse ( $ code , $ headers ) ; foreach ( $ this -> config [ 'allowed_response_types' ] as $ allowedResponsetype ) { if ( null !== $ example = $ response -> getExampleByType ( $ allowedResponsetype ) ) { $ _response -> addContent ( new SymfonyResponseContent ( $ allowedResponsetype , str_replace ( array ( "\r\n" , "\n" , "\r" , "\t" , " " ) , '' , $ example ) ) ) ; } } $ action -> addResponse ( $ _response ) ; } } $ controller -> addAction ( $ action ) ; } foreach ( $ resource -> getResources ( ) as $ subresource ) { $ this -> addActions ( $ controller , $ subresource , $ chainName ) ; } }
7041	protected function setState ( PaymentSubjectInterface $ subject , $ state ) { if ( $ state !== $ subject -> getPaymentState ( ) ) { $ subject -> setPaymentState ( $ state ) ; return true ; } return false ; }
3401	public function getValue ( ApistMethod $ method , Crawler $ rootNode = null ) { if ( is_null ( $ rootNode ) ) { $ rootNode = $ method -> getCrawler ( ) ; } $ result = $ rootNode -> filter ( $ this -> selector ) ; return $ this -> applyResultCallbackChain ( $ result , $ method ) ; }
6349	public static function limit ( Iterator $ iterator , int $ limitSize ) : Iterator { Preconditions :: checkArgument ( 0 <= $ limitSize ) ; return new NoRewindNecessaryLimitIterator ( $ iterator , $ limitSize ) ; }
2267	public function getFieldNames ( $ strTable , $ blnNoCache = false ) { $ arrNames = array ( ) ; $ arrFields = $ this -> listFields ( $ strTable , $ blnNoCache ) ; foreach ( $ arrFields as $ arrField ) { if ( $ arrField [ 'type' ] != 'index' ) { $ arrNames [ ] = $ arrField [ 'name' ] ; } } return $ arrNames ; }
7739	public function deserialize ( $ data , $ entity ) { if ( ! $ this -> container -> has ( 'hydra.serializer' ) ) { throw new \ LogicException ( 'The HydraBundle is not registered in your application.' ) ; } $ serializer = $ this -> container -> get ( 'hydra.serializer' ) ; if ( is_object ( $ entity ) ) { return $ serializer -> deserializeIntoEntity ( $ data , $ entity ) ; } return $ serializer -> deserialize ( $ data , $ entity , self :: FORMAT ) ; }
2451	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoRequest ( $ event -> getRequest ( ) ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> attributes -> set ( '_locale' , $ this -> getLocale ( $ request ) ) ; }
6208	public function load ( $ data ) { if ( ! is_array ( $ data ) && ! $ data instanceof \ stdClass ) { return ; } foreach ( $ data as $ key => $ value ) { $ this -> set ( $ key , $ value ) ; } }
12745	protected function move ( NodeConnectionInterface $ connection , $ slot ) { $ this -> pool [ ( string ) $ connection ] = $ connection ; $ this -> slots [ ( int ) $ slot ] = $ connection ; $ this -> slotmap [ ( int ) $ slot ] = $ connection ; }
6848	public static function days ( $ month , $ year = null ) { static $ months ; if ( ! isset ( $ year ) ) { $ year = date ( 'Y' ) ; } $ month = ( int ) $ month ; $ year = ( int ) $ year ; if ( empty ( $ months [ $ year ] [ $ month ] ) ) { $ total = date ( 't' , mktime ( 1 , 0 , 0 , $ month , 1 , $ year ) ) + 1 ; $ months [ $ year ] [ $ month ] = array ( ) ; for ( $ i = 1 ; $ i < $ total ; $ i ++ ) { $ months [ $ year ] [ $ month ] [ $ i ] = ( string ) $ i ; } } return $ months [ $ year ] [ $ month ] ; }
2171	private function login ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_login' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'login.html.twig' ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ verified = password_verify ( $ request -> request -> get ( 'password' ) , $ installTool -> getConfig ( 'installPassword' ) ) ; if ( ! $ verified ) { $ installTool -> increaseLoginCount ( ) ; return $ this -> render ( 'login.html.twig' , [ 'error' => $ this -> trans ( 'invalid_password' ) , ] ) ; } $ installTool -> resetLoginCount ( ) ; $ this -> container -> get ( 'contao.install_tool_user' ) -> setAuthenticated ( true ) ; return $ this -> getRedirectResponse ( ) ; }
11046	function parse_containers ( $ containers ) { if ( ! is_array ( $ containers ) ) { $ containers = explode ( ',' , $ containers ) ; } foreach ( $ containers as $ container ) { $ masktree = $ this -> read_container ( $ container , _ETS_ROOT ) ; if ( $ masktree === FALSE ) { $ this -> error ( 11 , 52 , $ this -> container ) ; } else { $ this -> masktree = $ this -> masktree_merge ( $ this -> masktree , $ masktree , $ container ) ; } } }
5292	public function buildGravatarURL ( $ email , $ hash_email = true ) { if ( $ this -> usingSecureImages ( ) ) { $ url = static :: HTTPS_URL ; } else { $ url = static :: HTTP_URL ; } if ( $ hash_email == true && ! empty ( $ email ) ) { $ url .= $ this -> getEmailHash ( $ email ) ; } elseif ( ! empty ( $ email ) ) { $ url .= $ email ; } else { $ url .= str_repeat ( '0' , 32 ) ; } if ( $ this -> param_cache === NULL ) { $ params = array ( ) ; $ params [ ] = 's=' . $ this -> getAvatarSize ( ) ; $ params [ ] = 'r=' . $ this -> getMaxRating ( ) ; if ( $ this -> getDefaultImage ( ) ) { $ params [ ] = 'd=' . $ this -> getDefaultImage ( ) ; } $ this -> params_cache = ( ! empty ( $ params ) ) ? '?' . implode ( '&' , $ params ) : '' ; } $ tail = '' ; if ( empty ( $ email ) ) { $ tail = ! empty ( $ this -> params_cache ) ? '&f=y' : '?f=y' ; } return $ url . $ this -> params_cache . $ tail ; }
9806	private function readBSE ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ BSE = new BSE ( ) ; $ this -> object -> addBSE ( $ BSE ) ; $ BSE -> setBLIPType ( $ recInstance ) ; $ btWin32 = ord ( $ recordData [ 0 ] ) ; $ btMacOS = ord ( $ recordData [ 1 ] ) ; $ rgbUid = substr ( $ recordData , 2 , 16 ) ; $ tag = Xls :: getUInt2d ( $ recordData , 18 ) ; $ size = Xls :: getInt4d ( $ recordData , 20 ) ; $ cRef = Xls :: getInt4d ( $ recordData , 24 ) ; $ foDelay = Xls :: getInt4d ( $ recordData , 28 ) ; $ unused1 = ord ( $ recordData [ 32 ] ) ; $ cbName = ord ( $ recordData [ 33 ] ) ; $ unused2 = ord ( $ recordData [ 34 ] ) ; $ unused3 = ord ( $ recordData [ 35 ] ) ; $ nameData = substr ( $ recordData , 36 , $ cbName ) ; $ blipData = substr ( $ recordData , 36 + $ cbName ) ; $ reader = new self ( $ BSE ) ; $ reader -> load ( $ blipData ) ; }
7217	public function getDocumentationClassesList ( ) : array { $ classNames = $ this -> getCmfConfig ( ) -> config ( 'api_documentation.classes' , [ ] ) ; if ( empty ( $ classNames ) ) { $ classNames = $ this -> loadClassesFromFileSystem ( ) ; } return $ classNames ; }
5828	public function newRequest ( $ method , $ url , $ data = array ( ) , $ encoding = Request :: ENCODING_QUERY ) { $ class = $ this -> requestClass ; $ request = new $ class ( $ this ) ; $ request -> setMethod ( $ method ) ; $ request -> setUrl ( $ url ) ; $ request -> setData ( $ data ) ; $ request -> setEncoding ( $ encoding ) ; return $ request ; }
11870	public function hideAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "page_manager" => $ app [ "red_kite_cms.page_manager" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , ) ; return parent :: hide ( $ options ) ; }
7890	protected function getDefaultProjectHook ( ) { $ default = $ this -> config -> get ( self :: CONFIG_DEFAULT ) ; return $ this -> config -> get ( sprintf ( self :: CONFIG_PROJECT , $ default ) ) ; }
3449	public function setAttribute ( $ key , $ value ) { if ( in_array ( $ key , $ this -> multipleHighloadBlockFields ) ) { $ this -> attributes [ $ key ] = serialize ( $ value ) ; return $ this ; } parent :: setAttribute ( $ key , $ value ) ; return $ this ; }
9942	public function setProtection ( Protection $ pValue ) { $ this -> protection = $ pValue ; $ this -> dirty = true ; return $ this ; }
7647	public function stream_open ( $ path , $ mode , $ options , & $ opened_path ) { $ this -> fileName = $ path ; $ this -> temporaryFileName = tempnam ( sys_get_temp_dir ( ) , 'azure' ) ; $ fh = @ fopen ( $ this -> temporaryFileName , $ mode ) ; if ( $ fh === false ) { return false ; } fclose ( $ fh ) ; if ( strpbrk ( $ mode , 'wax+' ) ) { $ this -> writeMode = true ; } else { $ this -> writeMode = false ; } if ( ! $ this -> writeMode || strpbrk ( $ mode , 'ra+' ) ) { $ this -> getStorageClient ( $ this -> fileName ) -> getBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } $ this -> temporaryFileHandle = fopen ( $ this -> temporaryFileName , $ mode ) ; return true ; }
8990	public function getTemplates ( ) { $ templates = array ( ) ; $ types = $ this -> config -> getTypes ( ) ; foreach ( $ types as $ type => $ type_options ) { foreach ( $ type_options as $ subtype => $ subtype_options ) { $ templates [ $ type ] [ $ subtype ] = ( array ) $ subtype_options ; } } return $ templates ; }
5747	protected function validateWhere ( array $ whereColumnsInfo ) { foreach ( $ whereColumnsInfo as $ columnNameSql => $ columnWhereInfo ) { if ( ! in_array ( $ columnNameSql , static :: SELECT_COLUMNS ) ) { throw new \ Exception ( "Invalid where column $columnNameSql" ) ; } } }
8479	public function bootstrap ( $ app ) { $ app -> i18n -> translations [ 'devgroup.events-system' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => 'en-US' , 'basePath' => '@DevGroup/EventsSystem/messages' , ] ; $ error = [ ] ; try { foreach ( EventHelper :: getActiveHandlersList ( ) as $ handler ) { Event :: on ( $ handler [ 'class' ] , $ handler [ 'name' ] , $ handler [ 'callable' ] , $ handler [ 'data' ] ) ; } } catch ( \ yii \ db \ Exception $ e ) { $ error = [ 'message' => '`DevGroup\EventsSystem` extension is not fully installed yet.' , 'hint' => 'Please run the `./yii migrate --migrationPath=@DevGroup/EventsSystem/migrations` command from your application directory to finish the installation process.' , ] ; } catch ( \ Exception $ e ) { $ error = [ 'message' => $ e -> getCode ( ) , 'hint' => $ e -> getMessage ( ) , ] ; } if ( empty ( $ error ) === false ) { if ( $ app instanceof \ yii \ console \ Application ) { $ app -> on ( Application :: EVENT_BEFORE_ACTION , function ( $ event ) use ( $ app , $ error ) { $ app -> controller -> stdout ( PHP_EOL . str_repeat ( '=' , 80 ) . PHP_EOL . PHP_EOL ) ; $ app -> controller -> stderr ( $ error [ 'message' ] . PHP_EOL ) ; $ app -> controller -> stdout ( $ error [ 'hint' ] . PHP_EOL ) ; $ app -> controller -> stdout ( PHP_EOL . str_repeat ( '=' , 80 ) . PHP_EOL ) ; } ) ; } elseif ( $ app instanceof \ yii \ web \ Application && YII_DEBUG === true ) { $ app -> session -> setFlash ( 'warning' , Html :: tag ( 'h4' , $ error [ 'message' ] ) . Html :: tag ( 'p' , $ error [ 'hint' ] ) ) ; } } }
2759	protected function getStorageKey ( $ key , $ limit , $ milliseconds ) { $ window = $ milliseconds * ( floor ( ( microtime ( 1 ) * 1000 ) / $ milliseconds ) ) ; $ date = date ( 'YmdHis' , $ window / 1000 ) ; return $ date . '::' . $ key . '::' . $ limit . '::' . $ milliseconds . '::COUNT' ; }
12718	protected function markAsResolved ( $ abstract , $ resolvedInstance , $ flag = [ ] ) { if ( ! is_array ( $ flag ) ) { $ flag = array_slice ( func_get_args ( ) , 2 ) ; } if ( $ this -> isAbstractExists ( $ abstract ) ) { $ this -> resolved [ $ abstract ] = [ 'concrete' => $ resolvedInstance , 'resolved' => true , 'flag' => join ( '|' , $ flag ) ] ; } }
6858	protected static function solsticeJune ( $ year , $ vsop = true ) { $ month = 6 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
10765	public function generateImage ( $ filename = false , $ level = Constants :: QR_ECLEVEL_L , $ size = 3 , $ margin = 4 ) { $ result = 'SPD' . self :: DELIMITER . $ this -> version . self :: DELIMITER . $ this -> implodeContent ( ) ; if ( $ this -> appendCRC32 ) { $ result .= self :: DELIMITER . 'CRC32:' . sprintf ( '%x' , crc32 ( $ result ) ) ; } QRcode :: png ( $ result , $ filename , $ level , $ size , $ margin ) ; die ( ) ; }
6905	public function removeRecipient ( Recipient $ recipient ) { if ( $ this -> recipients -> contains ( $ recipient ) ) { $ this -> recipients -> removeElement ( $ recipient ) ; } return $ this ; }
5003	protected function getConfig ( $ services , $ name ) { $ defaults = [ 'service' => 'EventManager' , 'configure' => true , 'identifiers' => [ $ name ] , 'event' => '\Zend\EventManager\Event' , 'listeners' => [ ] , ] ; $ config = $ services -> get ( 'Config' ) ; $ config = isset ( $ config [ 'event_manager' ] [ $ name ] ) ? $ config [ 'event_manager' ] [ $ name ] : [ ] ; $ config = array_replace_recursive ( $ defaults , $ config ) ; return $ config ; }
11122	public function getEndLocation ( ) { $ lastLocation = $ this -> getLocation ( ) ; $ lastDate = NOW ; foreach ( $ this -> movements as $ v ) { if ( $ v -> getEndTime ( ) > $ lastDate ) { $ lastDate = $ v -> getEndTime ( ) ; $ lastLocation = $ v -> getEndLocation ( ) ; } } return $ lastLocation ; }
745	public function unsigned ( ) { switch ( $ this -> type ) { case Schema :: TYPE_PK : $ this -> type = Schema :: TYPE_UPK ; break ; case Schema :: TYPE_BIGPK : $ this -> type = Schema :: TYPE_UBIGPK ; break ; } $ this -> isUnsigned = true ; return $ this ; }
3227	function buildUrlForGetOrPut ( $ host , $ path , $ params = null ) { return RequestUtil :: buildUrlForGetOrPut ( $ this -> userLocale , $ host , $ path , $ params ) ; }
26	protected function getRemoteContents ( $ originUrl , $ fileUrl , $ context , array & $ responseHeaders = null ) { try { $ e = null ; $ result = file_get_contents ( $ fileUrl , false , $ context ) ; } catch ( \ Throwable $ e ) { } catch ( \ Exception $ e ) { } $ responseHeaders = isset ( $ http_response_header ) ? $ http_response_header : array ( ) ; if ( null !== $ e ) { throw $ e ; } return $ result ; }
4780	public function clearWidgetCache ( ) { $ widgets = $ this -> getWidgets ( false ) ; $ userId = $ this -> token -> getToken ( ) -> getUser ( ) -> getId ( ) ; foreach ( $ widgets as $ widget ) { $ this -> cache -> deleteItem ( $ widget -> getId ( ) . $ userId ) ; } }
11795	public function setAttachment ( $ file = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } if ( is_array ( $ file ) ) { foreach ( $ file as $ _f ) { if ( file_exists ( $ _f ) ) { $ this -> attachment [ ] = $ _f ; } } } else { if ( file_exists ( $ file ) ) { $ this -> attachment [ ] = $ file ; } } return $ this ; }
12249	public function xpathByAttribute ( $ strXpathQuery , $ strIndexAttribute = 'name' ) { $ arrOut = array ( ) ; $ objResult = $ this -> xpath ( $ strXpathQuery ) ; foreach ( $ objResult as $ intIndex => $ objNode ) { $ strIndex = ( string ) $ objNode -> attributes ( ) -> $ strIndexAttribute ; $ arrOut [ $ strIndex ] = $ objResult [ $ intIndex ] ; } return $ arrOut ; }
3633	public function pools ( Request $ request ) : array { if ( $ name = $ request -> query ( 'name' ) ) { if ( ! App :: hasPool ( $ name ) ) { return [ ] ; } $ poolConfig = App :: getPool ( $ name ) -> getPoolConfig ( ) ; return $ poolConfig -> toArray ( ) ; } return PoolCollector :: getCollector ( ) ; }
5408	protected function isMatch ( $ cookie , $ host , $ path , $ name ) { if ( $ cookie -> getName ( ) != $ name ) { return false ; } if ( $ host && $ cookie -> getHost ( ) && ! $ cookie -> isValidHost ( $ host ) ) { return false ; } if ( ! $ cookie -> isValidPath ( $ path ) ) { return false ; } return true ; }
8525	public function setSellerSKU ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SellerSKU' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1755	public static function getTimeZones ( ) { $ arrReturn = array ( ) ; $ timezones = array ( ) ; require __DIR__ . '/../../config/timezones.php' ; foreach ( $ timezones as $ strGroup => $ arrTimezones ) { foreach ( $ arrTimezones as $ strTimezone ) { $ arrReturn [ $ strGroup ] [ ] = $ strTimezone ; } } return $ arrReturn ; }
12630	public function pay ( Order $ order ) { return $ this -> request ( $ this -> wrapApi ( self :: API_PAY_ORDER ) , $ order -> all ( ) ) ; }
2848	public function setModuleStatus ( $ moduleName , $ isActive ) { $ moduleConfigFile = $ this -> getModuleConfigFilePath ( $ moduleName ) ; $ configXml = $ this -> loadXmlFile ( $ moduleConfigFile ) ; if ( $ configXml === false ) { throw new Exception ( "Unable to parse module configuration file {$moduleConfigFile}" ) ; } $ configXml -> modules -> { $ moduleName } -> active = $ isActive ? 'true' : 'false' ; if ( $ this -> saveXml ( $ configXml , $ moduleConfigFile ) === false ) { throw new Exception ( "Unable to save module configuration file {$moduleConfigFile}. Check to see if web server user has write permissions." ) ; } }
5971	public function categories ( ) { if ( ! $ this -> categories instanceof CategoriesController ) { $ this -> categories = new CategoriesController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> categories -> setLogger ( $ this -> logger ) ; } return $ this -> categories ; }
9689	static function getDataType ( $ value ) { switch ( $ value ) { case "string" : return self :: $ STRING ; case "double" : return self :: $ DOUBLE ; case "float" : return self :: $ FLOAT ; case "integer" : return self :: $ INTEGER ; case "boolean" : return self :: $ BOOLEAN ; case "timestamp" : return self :: $ TIMESTAMP ; case "json" : return self :: $ JSON ; default : return null ; } }
324	public static function camel2words ( $ name , $ ucwords = true ) { $ label = mb_strtolower ( trim ( str_replace ( [ '-' , '_' , '.' , ] , ' ' , preg_replace ( '/(?<!\p{Lu})(\p{Lu})|(\p{Lu})(?=\p{Ll})/u' , ' \0' , $ name ) ) ) , self :: encoding ( ) ) ; return $ ucwords ? StringHelper :: mb_ucwords ( $ label , self :: encoding ( ) ) : $ label ; }
11377	public function getAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)(\/(\w+))?$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } $ pageName = $ matches [ 1 ] ; $ language = $ matches [ 2 ] ; $ pageTexts = $ this -> getTextModel ( $ pageName ) ; if ( empty ( $ matches [ 4 ] ) ) { $ result = array_values ( $ pageTexts -> getTextsWithBaseTexts ( $ language ) ) ; } else { $ result = $ pageTexts -> getText ( $ matches [ 4 ] , $ language ) ; } $ this -> environment -> sendJSONResult ( $ result ) ; }
5025	protected function renderMarkup ( FileUpload $ element ) { $ markup = '<div class="%s" id="%s-dropzone"> %s __input__</div>' ; return sprintf ( $ markup , $ this -> getDropZoneClass ( $ element ) , $ element -> getAttribute ( 'id' ) , $ this -> renderFileList ( $ element ) ) ; }
4431	protected function writeSection ( $ text , $ style = 'bg=blue;fg=white' ) { $ this -> output -> writeln ( array ( '' , $ this -> getHelper ( 'formatter' ) -> formatBlock ( $ text , $ style , true ) , '' , ) ) ; }
6404	public static function propagateIfInstanceOf ( Exception $ exception , string $ exceptionClass ) : void { if ( is_a ( $ exception , $ exceptionClass ) ) { throw $ exception ; } }
12896	public function isClosingAfterOpening ( ) { $ diff = $ this -> getOpeningDate ( ) -> diff ( $ this -> getClosingDate ( ) ) ; if ( $ diff -> invert === 0 ) { return true ; } else { return false ; } }
4655	protected function getJobFromImage ( ImageItem $ image , $ imageName , $ strategy , $ project ) { $ tag = explode ( ':' , $ imageName ) [ 1 ] ; list ( $ uniq , $ timestamp ) = explode ( '-' , $ tag ) ; return new Job ( $ project , $ strategy , $ uniq , array ( 'image' => $ image ) , "" , \ DateTime :: createFromFormat ( 'U' , $ timestamp ) ) ; }
3545	protected function write ( $ file , $ file_path ) { if ( ! is_dir ( dirname ( $ file_path ) ) ) { mkdir ( dirname ( $ file_path ) , 0755 , true ) ; } file_put_contents ( $ file_path , file_get_contents ( dirname ( __FILE__ ) . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'templates' . DIRECTORY_SEPARATOR . $ file . '.txt' ) ) ; }
3912	protected function remapSorting ( $ arrFiles , $ arrSource ) { $ files = array ( ) ; $ source = array ( ) ; foreach ( array_keys ( $ arrFiles ) as $ k ) { $ files [ ] = $ arrFiles [ $ k ] ; $ source [ ] = $ arrSource [ $ k ] ; } $ this -> addClasses ( $ source ) ; return array ( 'files' => $ files , 'source' => $ source ) ; }
8802	public function get ( $ key = null ) { return ( is_null ( $ key ) ? $ _SESSION : ( $ this -> has ( $ key ) ? $ _SESSION [ $ key ] : null ) ) ; }
7902	protected function getFullFileName ( Provider $ provider ) { $ folder = $ this -> folder ? rtrim ( $ this -> folder , '/' ) . '/' : '' ; if ( $ this -> filename ) { $ filename = $ this -> filename ; } else { $ filename = md5 ( uniqid ( microtime ( true ) , true ) ) ; } return $ folder . $ filename . '.' . $ provider -> getExtension ( ) ; }
10881	public function checkPaths ( ) { if ( $ this -> path_checked ) return true ; foreach ( array ( 'root' , 'webroot' ) as $ type ) { $ path = $ this -> $ type ; if ( ! file_exists ( $ path ) || ! is_dir ( $ path ) ) throw new IOException ( "Path '$type' does not exist: " . $ path ) ; if ( ! is_readable ( $ path ) ) throw new PermissionError ( $ path , "Path '$type' cannot be read" ) ; } if ( ! is_dir ( $ this -> config ) || is_readable ( $ this -> config ) ) $ this -> config = null ; foreach ( array ( 'var' , 'cache' , 'log' , 'uploads' ) as $ write_dir ) { $ path = $ this -> $ write_dir ; if ( ! is_dir ( $ path ) ) { $ dn = dirname ( $ path ) ; if ( ! file_exists ( $ path ) && $ dn === $ this -> var ) { Path :: mkdir ( $ path ) ; } else { if ( file_exists ( $ path ) ) throw new IOException ( "Path '$write_dir' exists but is not a directory: " . $ path ) ; $ this -> $ write_dir = null ; continue ; } } if ( ! is_writable ( $ path ) ) { try { Path :: makeWritable ( $ path ) ; } catch ( PermissionError $ e ) { $ this -> $ write_dir = null ; if ( $ this -> cli ) WF :: debug ( "Failed to get write access to: %s" , $ e -> getMessage ( ) ) ; } } } $ this -> path_checked = true ; return true ; }
8165	public function compile ( Twig_NodeInterface $ node , $ indentation = 0 ) { $ this -> lastLine = null ; $ this -> source = '' ; $ this -> debugInfo = array ( ) ; $ this -> sourceOffset = 0 ; $ this -> sourceLine = 1 ; $ this -> indentation = $ indentation ; $ this -> varNameSalt = 0 ; if ( $ node instanceof Twig_Node_Module ) { $ this -> filename = $ node -> getTemplateName ( ) ; } $ node -> compile ( $ this ) ; return $ this ; }
2713	public function getValues ( ) { $ values = [ ] ; $ ratios = $ this -> pixelRatios -> toOptionArray ( ) ; foreach ( $ ratios as $ value ) { $ values [ $ value [ 'value' ] ] = $ value [ 'label' ] ; } return $ values ; }
3957	public function save ( $ timestamp = null ) { if ( null === $ timestamp ) { @ \ trigger_error ( 'Not passing a timestamp has been deprecated and will cause an error in MetaModels 3' , E_USER_DEPRECATED ) ; } $ objMetaModel = $ this -> getMetaModel ( ) ; $ objMetaModel -> saveItem ( $ this , $ timestamp ) ; }
3996	protected function jumpTo ( $ mixMetaModel , $ mixDataId , $ intIdRenderSetting , $ strParam = 'url' ) { if ( empty ( $ strParam ) ) { $ strParam = 'url' ; } $ objMetaModel = $ this -> loadMetaModel ( $ mixMetaModel ) ; if ( $ objMetaModel == null ) { return false ; } $ objRenderSettings = $ this -> getServiceContainer ( ) -> getRenderSettingFactory ( ) -> createCollection ( $ objMetaModel , $ intIdRenderSetting ) ; if ( $ objRenderSettings == null ) { return false ; } $ objItem = $ objMetaModel -> findById ( $ mixDataId ) ; if ( $ objItem == null ) { return false ; } $ arrRenderedItem = $ objItem -> parseValue ( 'text' , $ objRenderSettings ) ; if ( ! isset ( $ arrRenderedItem [ 'jumpTo' ] ) ) { return false ; } if ( stripos ( $ strParam , 'params.' ) !== false ) { $ mixAttName = StringUtil :: trimsplit ( '.' , $ strParam ) ; $ mixAttName = array_pop ( $ mixAttName ) ; if ( isset ( $ arrRenderedItem [ 'jumpTo' ] [ 'params' ] [ $ mixAttName ] ) ) { return $ arrRenderedItem [ 'jumpTo' ] [ 'params' ] [ $ mixAttName ] ; } } elseif ( isset ( $ arrRenderedItem [ 'jumpTo' ] [ $ strParam ] ) ) { return $ arrRenderedItem [ 'jumpTo' ] [ $ strParam ] ; } return false ; }
11180	protected function set ( $ key , $ value ) { $ cache = apc_fetch ( $ this -> getKey ( ) ) ; $ cache [ $ key ] = $ value ; apc_store ( $ this -> getKey ( ) , $ cache ) ; }
1403	private function parse ( ) { if ( ! $ this -> response ) { return [ ] ; } $ body = json_decode ( ( string ) $ this -> response -> getBody ( ) , true ) ; return isset ( $ body [ 'errors' ] ) ? $ body [ 'errors' ] : [ ] ; }
3791	protected function fetchExistingIdsFor ( $ idList , $ langCode ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) -> select ( 'item_id' ) -> from ( $ this -> getValueTable ( ) ) ; $ this -> buildWhere ( $ queryBuilder , $ idList , $ langCode ) ; $ statement = $ queryBuilder -> execute ( ) ; return $ statement -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; }
12736	public function mapModelToLangName ( $ modelName , $ langName ) { $ modelName = $ this -> getClassName ( $ modelName ) ; $ this -> modelToLangName [ $ modelName ] = $ langName ; }
10212	function toCsvString ( ) { $ standard_fields = "{" ; if ( isset ( $ this -> standard_fields ) ) { foreach ( $ this -> standard_fields as $ index => $ value ) { $ standard_fields .= $ index . "=" . $ value . "," ; } $ standard_fields = rtrim ( $ standard_fields , ',' ) ; } $ standard_fields .= "}" ; $ customfields = "{" ; if ( isset ( $ this -> custom_fields ) ) { foreach ( $ this -> custom_fields as $ index => $ value ) { $ customfields .= $ index . "=" . $ value . "," ; } $ customfields = rtrim ( $ customfields , ',' ) ; } $ customfields .= "}" ; $ permission = "" ; if ( isset ( $ this -> permission ) ) { $ permission = $ this -> permission -> getCode ( ) ; } return $ this -> id . ";" . $ this -> email . ";" . $ permission . ";" . $ this -> external_id . ";" . ( ( $ this -> anonymous == true ) ? "true" : "false" ) . ";" . $ this -> created . ";" . $ this -> updated . ";\"" . $ standard_fields . "\"" . ";\"" . $ customfields . "\"" ; }
6339	private function getDocumentStream ( $ xmlDocument ) { foreach ( $ this -> streamAdapters as $ streamAdapter ) { if ( $ streamAdapter -> supports ( $ xmlDocument ) ) { return $ streamAdapter -> convert ( $ xmlDocument ) ; } } throw new RuntimeException ( sprintf ( 'Suitable XML document stream adapter is not registered for XML document of type "%s".' , is_object ( $ xmlDocument ) ? get_class ( $ xmlDocument ) : gettype ( $ xmlDocument ) ) ) ; }
11918	public function register ( callable $ inject ) : void { $ reflection = new ReflectionFunction ( $ inject ) ; $ parameters = $ reflection -> getParameters ( ) ; foreach ( $ parameters as $ parameter ) { $ key = $ parameter -> name ; $ getter = function ( $ c ) use ( $ reflection , $ parameters , $ key ) { if ( isset ( $ c -> delegate ) ) { try { return $ c -> delegate -> get ( $ key ) ; } catch ( NotFoundExceptionInterface $ e ) { } } $ args = [ ] ; foreach ( $ parameters as $ param ) { if ( ! $ param -> isPassedByReference ( ) ) { $ args [ ] = $ c -> get ( $ param -> name ) ; } else { $ { $ param -> name } = null ; $ args [ $ param -> name ] = & $ { $ param -> name } ; } } $ reflection -> invokeArgs ( $ args ) ; foreach ( $ args as $ found => $ value ) { if ( ! is_numeric ( $ found ) && $ found == $ key ) { $ c :: $ map [ $ found ] = $ value ; } } if ( array_key_exists ( $ key , $ args ) ) { return $ args [ $ key ] ; } throw new NotFoundException ( $ key ) ; } ; static :: $ map [ $ key ] = new ReflectionFunction ( $ getter ) ; } }
9847	public function createSealedResponse ( int $ status , string $ body , SealingPublicKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { return new Response ( $ status , new Headers ( $ headers ) , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: seal ( $ body , $ key ) ) ) ) ; }
6665	public function parseFb ( $ raw_profile ) { $ profile = $ raw_profile ; $ profile -> avatar = sprintf ( 'http://graph.facebook.com/%s/picture' , $ profile -> id ) ; return ( array ) $ profile ; }
12038	public function drop ( $ key ) { if ( $ this -> has ( $ key ) ) { unset ( $ _SESSION [ $ this -> root ] [ $ key ] ) ; return true ; } return false ; }
11663	public static function saveToFile ( $ file , $ properties ) { $ prop_string = self :: saveToString ( $ properties ) ; $ real_file = File :: asFile ( $ file ) ; if ( ! $ real_file -> exists ( ) ) { $ real_file -> touch ( ) ; } $ real_file -> setContent ( $ prop_string ) ; }
11245	public function getRan ( ) : array { $ stmt = $ this -> pdo -> query ( "select migration from {$this->table} order by batch, migration" ) ; $ stmt -> execute ( ) ; $ results = $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; return $ results ; }
3230	static function loadFromJson ( $ jsonObj ) { $ authHost = null ; if ( array_key_exists ( 'auth_host' , $ jsonObj ) ) { $ authHost = $ jsonObj [ "auth_host" ] ; if ( ! is_string ( $ authHost ) ) { throw new HostLoadException ( "Optional field \"auth_host\" must be a string" ) ; } } $ hostSuffix = null ; if ( array_key_exists ( 'host_suffix' , $ jsonObj ) ) { $ hostSuffix = $ jsonObj [ "host_suffix" ] ; if ( ! is_string ( $ hostSuffix ) ) { throw new HostLoadException ( "Optional field \"host_suffix\" must be a string" ) ; } } if ( $ authHost === null && $ hostSuffix === null ) return null ; if ( $ authHost === null ) { throw new HostLoadException ( "Can't provide \"host_suffix\" without providing \"auth_host\"." ) ; } if ( $ hostSuffix === null ) { throw new HostLoadException ( "Can't provide \"auth_host\" without providing \"host_suffix\"." ) ; } $ api = "api" . $ hostSuffix ; $ content = "content" . $ hostSuffix ; $ web = $ authHost ; return new Host ( $ api , $ content , $ web ) ; }
12212	public function getSnippet ( string $ snptName = '' ) { if ( empty ( $ snptName ) ) { return $ this -> snippets ; } else { return isset ( $ this -> snippets [ $ snptName ] ) ? $ this -> snippets [ $ snptName ] : null ; } }
10579	private function codesEqual ( string $ known , string $ given ) : bool { if ( strlen ( $ given ) !== strlen ( $ known ) ) { return false ; } $ res = 0 ; $ knownLen = strlen ( $ known ) ; for ( $ i = 0 ; $ i < $ knownLen ; ++ $ i ) { $ res |= ( ord ( $ known [ $ i ] ) ^ ord ( $ given [ $ i ] ) ) ; } return $ res === 0 ; }
1334	protected function fillRelated ( $ record , ResourceObject $ resource , EncodingParametersInterface $ parameters ) { $ relationships = $ resource -> getRelationships ( ) ; $ changed = false ; foreach ( $ relationships as $ field => $ value ) { if ( $ this -> isNotFillable ( $ field , $ record ) ) { continue ; } if ( ! $ this -> isRelation ( $ field ) ) { continue ; } $ relation = $ this -> getRelated ( $ field ) ; if ( $ this -> requiresPrimaryRecordPersistence ( $ relation ) ) { $ relation -> update ( $ record , $ value , $ parameters ) ; $ changed = true ; } } if ( $ changed ) { $ record -> refresh ( ) ; } }
12800	public function getHeaders ( ) { if ( ! isset ( $ this -> _headers ) ) { $ this -> _headers = $ this -> readLine ( 1 ) ; if ( ! $ this -> _headers ) { $ this -> _headers = [ ] ; } } return $ this -> _headers ; }
4156	function every ( $ interval , Job $ job ) { $ expression = new SimpleExpression ( $ interval ) ; $ this -> add ( $ expression , $ job ) ; return $ this ; }
6433	protected function getSerializeVars ( $ skip = array ( ) ) { $ vars = get_object_vars ( $ this ) ; $ servars = array ( ) ; foreach ( $ vars as $ k => $ v ) { if ( in_array ( $ k , $ skip ) ) { continue ; } if ( $ k == 'options' || $ k == 'logger' ) { continue ; } $ servars [ ] = $ k ; } return $ servars ; }
11308	public function entityFromBody ( $ body , $ entity ) { $ json = $ this -> decodeJson ( $ body ) ; return $ entity -> populate ( $ json ) ; }
12847	private function _loadController ( $ oControllerName , string $ sActionName , array $ aParams = array ( ) ) { $ aPhpDoc = PhpDoc :: getPhpDocOfMethod ( $ oControllerName , $ sActionName ) ; if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { if ( ! isset ( $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ) { $ aPhpDoc [ 'Cache' ] [ 'maxage' ] = 0 ; } $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } $ mCacheReturn = Cache :: get ( $ sActionName . $ sCacheExt , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; if ( $ mCacheReturn !== false ) { return $ mCacheReturn ; } } if ( isset ( $ aPhpDoc [ 'Secure' ] ) ) { if ( isset ( $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) && $ this -> _oSecurity -> getUserRole ( ) != $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) { $ this -> _getPage403 ( ) ; } } $ oController = new $ oControllerName ; ob_start ( ) ; if ( ! defined ( 'PORTAL' ) ) { define ( 'PORTAL' , 'Batch' ) ; } if ( method_exists ( $ oController , 'beforeExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'beforeExecuteRoute' ) , array ( ) ) ; } $ mReturnController = call_user_func_array ( array ( $ oController , $ sActionName ) , $ aParams ) ; if ( method_exists ( $ oController , 'afterExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'afterExecuteRoute' ) , array ( ) ) ; } $ mReturn = ob_get_clean ( ) ; if ( $ mReturn == '' ) { $ mReturn = $ mReturnController ; } if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } if ( defined ( 'COMPRESS_HTML' ) && COMPRESS_HTML ) { $ mReturn = str_replace ( array ( "\t" , "\r" , " " ) , array ( "" , "" , "" , " " ) , $ mReturn ) ; } Cache :: set ( $ sActionName . $ sCacheExt , $ mReturn , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; } return $ mReturn ; }
8933	private function addDependency ( $ name , $ template ) { $ this -> commands [ ] = strtr ( $ template , [ '$namespace' => $ this -> namespaceRoot , '$name' => $ name ] ) ; }
1983	public static function hasMessages ( $ strScope = TL_MODE ) { return static :: hasError ( $ strScope ) || static :: hasConfirmation ( $ strScope ) || static :: hasNew ( $ strScope ) || static :: hasInfo ( $ strScope ) || static :: hasRaw ( $ strScope ) ; }
6413	public static function transform ( IteratorAggregate $ fromIterable , callable $ transformer ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ fromIterable , $ transformer ) { return Iterators :: transform ( Iterators :: from ( $ fromIterable -> getIterator ( ) ) , $ transformer ) ; } ) ; }
103	protected function pruneToHighestPriorityOrInstalled ( Pool $ pool , array $ installedMap , array $ literals ) { $ selected = array ( ) ; $ priority = null ; foreach ( $ literals as $ literal ) { $ package = $ pool -> literalToPackage ( $ literal ) ; if ( isset ( $ installedMap [ $ package -> id ] ) ) { $ selected [ ] = $ literal ; continue ; } if ( null === $ priority ) { $ priority = $ this -> getPriority ( $ pool , $ package ) ; } if ( $ this -> getPriority ( $ pool , $ package ) != $ priority ) { break ; } $ selected [ ] = $ literal ; } return $ selected ; }
1459	protected function whereId ( $ id , $ operator ) { if ( $ this -> isPagingOnKey ( ) ) { $ this -> query -> where ( $ this -> key , $ operator , $ id ) ; return $ this ; } $ value = $ this -> getColumnValue ( $ id ) ; $ this -> query -> where ( $ this -> column , $ operator . '=' , $ value ) -> where ( function ( $ query ) use ( $ id , $ value , $ operator ) { $ query -> where ( $ this -> column , $ operator , $ value ) -> orWhere ( $ this -> key , $ operator , $ id ) ; } ) ; return $ this ; }
12417	static function run_copy_paste_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcpd = self :: getTool ( 'phpcpd' , $ opts , true ) ; try { $ out = pake_sh ( "$phpcpd " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcpd.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
12136	public function edit ( QuestionRequest $ request , Question $ question ) { return $ this -> response -> title ( trans ( 'forum::question.name' ) ) -> view ( 'forum::public.question.newdiscussion' ) -> data ( compact ( 'question' ) ) -> output ( ) ; }
2104	public function getTemplates ( ) : array { $ finder = Finder :: create ( ) -> files ( ) -> name ( '*.sql' ) -> in ( $ this -> rootDir . '/templates' ) ; $ templates = [ ] ; foreach ( $ finder as $ file ) { $ templates [ ] = $ file -> getRelativePathname ( ) ; } return $ templates ; }
1886	public function getItemsAsArray ( ) { $ arrLinks = array ( ) ; $ intNumberOfLinks = floor ( $ this -> intNumberOfLinks / 2 ) ; $ intFirstOffset = $ this -> intPage - $ intNumberOfLinks - 1 ; if ( $ intFirstOffset > 0 ) { $ intFirstOffset = 0 ; } $ intLastOffset = $ this -> intPage + $ intNumberOfLinks - $ this -> intTotalPages ; if ( $ intLastOffset < 0 ) { $ intLastOffset = 0 ; } $ intFirstLink = $ this -> intPage - $ intNumberOfLinks - $ intLastOffset ; if ( $ intFirstLink < 1 ) { $ intFirstLink = 1 ; } $ intLastLink = $ this -> intPage + $ intNumberOfLinks - $ intFirstOffset ; if ( $ intLastLink > $ this -> intTotalPages ) { $ intLastLink = $ this -> intTotalPages ; } for ( $ i = $ intFirstLink ; $ i <= $ intLastLink ; $ i ++ ) { if ( $ i == $ this -> intPage ) { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => null , 'title' => null ) ; } else { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => $ this -> linkToPage ( $ i ) , 'title' => StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goToPage' ] , $ i ) ) ) ; } } return $ arrLinks ; }
236	protected function getCacheKey ( $ name ) { return [ __CLASS__ , $ this -> db -> dsn , $ this -> db -> username , $ this -> getRawTableName ( $ name ) , ] ; }
618	private function parseString ( $ value , & $ i ) { $ isQuoted = $ value [ $ i ] === '"' ; $ stringEndChars = $ isQuoted ? [ '"' ] : [ $ this -> delimiter , '}' ] ; $ result = '' ; $ len = strlen ( $ value ) ; for ( $ i += $ isQuoted ? 1 : 0 ; $ i < $ len ; ++ $ i ) { if ( in_array ( $ value [ $ i ] , [ '\\' , '"' ] , true ) && in_array ( $ value [ $ i + 1 ] , [ $ value [ $ i ] , '"' ] , true ) ) { ++ $ i ; } elseif ( in_array ( $ value [ $ i ] , $ stringEndChars , true ) ) { break ; } $ result .= $ value [ $ i ] ; } $ i -= $ isQuoted ? 0 : 1 ; if ( ! $ isQuoted && $ result === 'NULL' ) { $ result = null ; } return $ result ; }
2142	private function getSessionBag ( Request $ request ) : SessionBagInterface { if ( ! $ request -> hasSession ( ) || null === ( $ session = $ request -> getSession ( ) ) ) { throw new \ RuntimeException ( 'The request did not contain a session.' ) ; } $ name = 'contao_frontend' ; if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ name = 'contao_backend' ; } return $ session -> getBag ( $ name ) ; }
1810	public function adjustDcaByType ( $ dc ) { $ objCte = Contao \ ContentModel :: findByPk ( $ dc -> id ) ; if ( $ objCte === null ) { return ; } switch ( $ objCte -> type ) { case 'hyperlink' : unset ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imageUrl' ] ) ; break ; case 'image' : $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imagemargin' ] [ 'eval' ] [ 'tl_class' ] .= ' clr' ; break ; } }
6677	public static function toRelativeTime ( $ fromTime , $ toTime = 'now' , $ format = 'days' ) { $ startTime = new DateTime ( $ fromTime ) ; $ endTime = new DateTime ( $ toTime ) ; return $ startTime -> diff ( $ endTime ) -> $ format ; }
5474	protected function createAction ( $ action , $ page ) { if ( ( $ action === '' ) || ( $ action === false ) ) { return $ page -> expandUrl ( $ page -> getUrl ( ) ) ; } return $ page -> expandUrl ( new SimpleUrl ( $ action ) ) ; }
3341	public function getFileList ( $ options = array ( ) ) { $ options = array_replace ( array ( 'from' => null , 'to' => null , 'limit' => null , 'request_limit' => null , 'stored' => $ this -> defaultFilters [ 'file' ] [ 'stored' ] , 'removed' => $ this -> defaultFilters [ 'file' ] [ 'removed' ] , 'reversed' => false , ) , $ options ) ; if ( ! empty ( $ options [ 'from' ] ) && ! empty ( $ options [ 'to' ] ) ) { throw new \ Exception ( 'Only one of "from" and "to" arguments is allowed' ) ; } $ options [ 'from' ] = self :: dateTimeString ( $ options [ 'from' ] ) ; $ options [ 'to' ] = self :: dateTimeString ( $ options [ 'to' ] ) ; foreach ( $ this -> defaultFilters [ 'file' ] as $ k => $ v ) { if ( ! is_null ( $ options [ $ k ] ) ) { $ options [ $ k ] = self :: booleanString ( $ options [ $ k ] ) ; } } return new FileIterator ( $ this , $ options ) ; }
3188	public function getFirstTimestamp ( $ tags ) { $ range = $ this -> getRange ( $ tags ) ; $ last = false ; if ( count ( $ range ) ) { $ last = $ range [ 0 ] -> getTimestamp ( ) ; } return $ last ; }
7547	function getEncoding ( ) { $ root = $ this -> getRoot ( ) ; if ( $ root !== null ) { if ( $ enc = $ root -> select ( 'meta[charset]' , 0 , true , true ) ) { return $ enc -> getAttribute ( "charset" ) ; } elseif ( $ enc = $ root -> select ( '"?xml"[encoding]' , 0 , true , true ) ) { return $ enc -> getAttribute ( "encoding" ) ; } elseif ( $ enc = $ root -> select ( 'meta[content*="charset="]' , 0 , true , true ) ) { $ enc = $ enc -> getAttribute ( "content" ) ; return substr ( $ enc , strpos ( $ enc , "charset=" ) + 8 ) ; } } return false ; }
12079	public function childDissociate ( $ request , $ idParent , $ idChild , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; if ( ! $ this -> repository -> detach ( $ idParent , $ idChild , $ relation ) ) { } return $ this -> success ( [ ] ) ; }
8886	private function parseResult ( ) { if ( $ this -> xml_result -> Response -> ResponseStatusCode != '1' ) { return array ( 'Error' => array ( 'ErrorSeverity' => "{$this->xml_result->Response->Error->ErrorSeverity}" , 'ErrorCode' => "{$this->xml_result->Response->Error->ErrorCode}" , 'ErrorDescription' => "{$this->xml_result->Response->Error->ErrorDescription}" ) ) ; return $ this -> xml_result ; } $ simplified = array ( ) ; $ shipping_choices = array ( ) ; foreach ( $ this -> xml_result -> RatedShipment as $ service ) { $ simplified [ ] = '{' . $ service -> TotalCharges -> MonetaryValue . '}' ; } foreach ( $ simplified as $ key => $ value ) { $ service = $ this -> xml_result -> RatedShipment [ $ key ] -> children ( ) ; if ( $ this -> negotiated_rates && $ service -> NegotiatedRates -> NetSummaryCharges -> GrandTotal -> MonetaryValue ) { $ rate = number_format ( ( double ) ( $ service -> NegotiatedRates -> NetSummaryCharges -> GrandTotal -> MonetaryValue ) , 2 ) ; } else { $ rate = number_format ( ( double ) ( $ service -> TransportationCharges -> MonetaryValue ) , 2 ) ; } $ shipping_choices [ "{$service->Service->Code}" ] = array ( 'service' => $ this -> shipperCodes ( "{$service->Service->Code}" ) , 'rate' => "{$rate}" ) ; } return $ shipping_choices ; }
5288	protected static function getRequestMethodName ( ) { $ request_engine = self :: $ requestEngine ; if ( $ request_engine == 'curl' && ! function_exists ( 'curl_init' ) ) { trigger_error ( "DetectLanguage::Client - CURL not found, switching to stream" ) ; $ request_engine = self :: $ requestEngine = 'stream' ; } switch ( $ request_engine ) { case 'curl' : return 'requestCurl' ; case 'stream' : return 'requestStream' ; default : throw new Error ( "Invalid request engine: " . $ request_engine ) ; } }
2600	public function peek ( ) { if ( isset ( $ this -> tokens [ $ this -> position + $ this -> peek ] ) ) { return $ this -> tokens [ $ this -> position + $ this -> peek ++ ] ; } else { return null ; } }
12259	public function compile ( callable $ validator = NULL ) { if ( ! ( $ project = $ this -> getProject ( ) ) ) { $ project = CC :: get ( $ this -> getConfiguration ( ) , CC :: COMPILER_PROJECT ) ; if ( ! $ project ) throw new CompilerException ( "Compilation without project settings is not possible" ) ; } $ this -> project = $ project ; try { set_error_handler ( function ( $ code , $ msg , $ file , $ line ) { switch ( AbstractErrorHandlerService :: detectErrorLevel ( $ code ) ) { case AbstractErrorHandlerService :: NOTICE_ERROR_LEVEL : return $ this -> getLogger ( ) -> logNotice ( $ msg , [ $ file , $ line ] ) ; case AbstractErrorHandlerService :: DEPRECATED_ERROR_LEVEL : case AbstractErrorHandlerService :: WARNING_ERROR_LEVEL : return $ this -> getLogger ( ) -> logWarning ( $ msg , [ $ file , $ line ] ) ; default : return $ this -> getLogger ( ) -> logError ( $ msg , [ $ file , $ line ] ) ; } } ) ; foreach ( $ this -> getOrganizedCompilers ( ) as $ compiler ) { if ( ! $ validator || $ validator ( $ compiler ) ) $ compiler -> compile ( $ this ) ; } } catch ( Throwable $ throwable ) { $ this -> getLogger ( ) -> logException ( $ throwable ) ; } finally { restore_error_handler ( ) ; } }
6392	public static function reverseOrder ( Comparator $ comparator = null ) : Comparator { if ( $ comparator === null ) { $ comparator = ComparableComparator :: instance ( ) ; } return new ReverseComparator ( $ comparator ) ; }
12193	public function onKernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( $ exception instanceof AuthenticationCredentialsNotFoundException ) { return new RedirectResponse ( "/login" ) ; } $ message = $ exception -> getMessage ( ) ; if ( $ exception instanceof NotFoundHttpException || $ exception instanceof PageNotPublishedException ) { $ this -> render404page ( $ event , $ message ) ; return ; } if ( ! $ exception instanceof RedKiteCmsExceptionInterface ) { DataLogger :: log ( $ message , DataLogger :: CRITICAL ) ; if ( $ this -> debug ) { return $ event ; } $ this -> setUpResponse ( $ event , $ message ) ; return ; } $ message = Utils :: translateException ( $ message , $ exception ) ; $ this -> setUpResponse ( $ event , $ message ) ; DataLogger :: log ( $ message , DataLogger :: ERROR ) ; }
9292	public function getEndpointNode ( ) { $ builder = new TreeBuilder ( ) ; $ node = $ builder -> root ( 'endpoints' ) ; $ node -> info ( 'Defines version endpoints.' ) -> useAttributeAsKey ( 'endpoint' ) -> prototype ( 'array' ) -> children ( ) -> scalarNode ( 'endpoint' ) -> info ( 'Endpoint name (will be included in url (e.g. products))' ) -> example ( 'products' ) -> end ( ) -> scalarNode ( 'repository' ) -> isRequired ( ) -> info ( 'Document service from Elasticsearch bundle which will be used for data fetching' ) -> example ( 'es.manager.default.products' ) -> end ( ) -> arrayNode ( 'methods' ) -> defaultValue ( [ Request :: METHOD_POST , Request :: METHOD_GET , Request :: METHOD_PUT , Request :: METHOD_DELETE ] ) -> prototype ( 'scalar' ) -> validate ( ) -> ifNotInArray ( [ Request :: METHOD_HEAD , Request :: METHOD_POST , Request :: METHOD_PATCH , Request :: METHOD_GET , Request :: METHOD_PUT , Request :: METHOD_DELETE ] ) -> thenInvalid ( 'Invalid HTTP method used! Please check your ongr_api endpoint configuration.' ) -> end ( ) -> end ( ) -> end ( ) -> booleanNode ( 'allow_extra_fields' ) -> defaultFalse ( ) -> info ( 'Allows to pass unknown fields to an api. ' . 'Make sure you have configured elasticsearch respectively.' ) -> end ( ) -> arrayNode ( 'allow_fields' ) -> defaultValue ( [ ] ) -> info ( 'A list off a allowed fields to operate through api for a document.' ) -> prototype ( 'scalar' ) -> end ( ) -> end ( ) -> booleanNode ( 'allow_get_all' ) -> defaultTrue ( ) -> info ( 'Allows to use `_all` elasticsearch api to get all documents from a type.' ) -> end ( ) -> booleanNode ( 'allow_batch' ) -> defaultTrue ( ) -> info ( 'Allows to use `_batch` elasticsearch api to pass multiple documents in single API request.' ) -> end ( ) -> booleanNode ( 'variants' ) -> defaultFalse ( ) -> info ( 'If set to true user can manipulate document variants over API.' ) -> end ( ) -> booleanNode ( 'batch' ) -> defaultTrue ( ) -> info ( 'If set to true user can sent documents in batch\'s.' ) -> end ( ) -> end ( ) -> end ( ) ; return $ node ; }
660	public function createCommand ( $ sql = null , $ params = [ ] ) { $ driver = $ this -> getDriverName ( ) ; $ config = [ 'class' => 'yii\db\Command' ] ; if ( $ this -> commandClass !== $ config [ 'class' ] ) { $ config [ 'class' ] = $ this -> commandClass ; } elseif ( isset ( $ this -> commandMap [ $ driver ] ) ) { $ config = ! is_array ( $ this -> commandMap [ $ driver ] ) ? [ 'class' => $ this -> commandMap [ $ driver ] ] : $ this -> commandMap [ $ driver ] ; } $ config [ 'db' ] = $ this ; $ config [ 'sql' ] = $ sql ; $ command = Yii :: createObject ( $ config ) ; return $ command -> bindValues ( $ params ) ; }
8353	private function shutdown ( $ signal = 9 ) { foreach ( $ this -> dispatcher -> getProcesses ( ) as $ pid => $ process ) { $ this -> logger -> debug ( 'Sending signal to process' , [ 'signal' => $ signal , 'pid' => $ pid , 'jobId' => $ process [ 'id' ] , 'queue' => $ this -> queue -> getName ( ) ] ) ; \ posix_kill ( $ pid , $ signal ) ; if ( $ signal !== 9 ) { if ( $ this -> config [ 'deadline_timeout' ] !== null ) { Loop :: delay ( ( ( int ) $ this -> config [ 'deadline_timeout' ] * 1000 ) , function ( $ watcherId , $ callback ) use ( $ process , $ pid ) { if ( $ process [ 'process' ] -> isRunning ( ) ) { $ this -> logger -> info ( 'Process has exceeded deadline timeout. Killing' , [ 'pid' => $ pid , 'jobId' => $ process [ 'id' ] , 'queue' => $ this -> queue -> getName ( ) ] ) ; \ posix_kill ( $ pid , SIGKILL ) ; } } ) ; } } } }
7122	protected function detectAndApplyLanguage ( ) { if ( $ this -> config ( 'autodetect' , true ) ) { $ detector = $ this -> getLanguageDetector ( ) ; $ language = $ detector -> getLanguageFromCookie ( ) ; if ( ! $ language || strlen ( $ language ) > 5 || ! in_array ( $ language , $ this -> getSupportedLanguages ( ) , true ) ) { $ language = $ detector -> getDriver ( ) -> detect ( ) ; if ( ! $ language || strlen ( $ language ) > 5 ) { $ language = $ this -> request -> getDefaultLocale ( ) ; } } $ this -> applyNewLanguage ( $ language , true ) ; } }
4532	public function setFirstResult ( ? int $ firstResult ) { $ this -> firstResult = $ firstResult ; $ this -> _firstResult = null !== $ firstResult ; return $ this ; }
12923	public function getLocalDataItems ( ) { if ( ! isset ( $ this -> _localDataItems ) ) { $ this -> trigger ( self :: EVENT_LOAD_LOCAL_DATA_ITEMS ) ; } return $ this -> _localDataItems ; }
5006	protected function normalizeListenerOptions ( $ name , $ options ) { $ normalized = [ 'service' => $ name , 'attach' => null , 'priority' => 1 , 'lazy' => false , ] ; if ( is_int ( $ name ) ) { $ normalized [ 'service' ] = $ options ; return $ normalized ; } if ( is_int ( $ options ) ) { $ normalized [ 'priority' ] = $ options ; return $ normalized ; } if ( is_string ( $ options ) ) { $ normalized [ 'attach' ] = [ [ 'event' => $ options , 'method' => null , 'priority' => 1 ] ] ; return $ normalized ; } if ( ArrayUtils :: isHashTable ( $ options ) ) { $ normalized [ 'attach' ] = $ this -> normalizeEventsSpec ( $ options ) ; if ( isset ( $ options [ 'lazy' ] ) ) { $ normalized [ 'lazy' ] = $ options [ 'lazy' ] ; } return $ normalized ; } $ event = $ method = null ; $ priority = 1 ; $ lazy = false ; foreach ( $ options as $ opt ) { if ( is_array ( $ opt ) ) { $ event = $ opt ; } elseif ( is_string ( $ opt ) ) { if ( null === $ event ) { $ event = [ $ opt ] ; } else { $ method = $ opt ; } } elseif ( is_int ( $ opt ) ) { $ priority = $ opt ; } elseif ( is_bool ( $ opt ) ) { $ lazy = $ opt ; } } foreach ( $ event as & $ eventSpec ) { $ eventSpec = [ 'event' => $ eventSpec , 'method' => $ method , 'priority' => $ priority ] ; } $ normalized [ 'attach' ] = $ event ; $ normalized [ 'lazy' ] = $ lazy ; return $ normalized ; }
2149	public function createNewUser ( $ intUser , $ arrData ) { $ arrNewsletters = StringUtil :: deserialize ( $ arrData [ 'newsletter' ] , true ) ; if ( ! \ is_array ( $ arrNewsletters ) ) { return ; } $ time = time ( ) ; foreach ( $ arrNewsletters as $ intNewsletter ) { $ intNewsletter = ( int ) $ intNewsletter ; if ( $ intNewsletter < 1 ) { continue ; } $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE pid=? AND email=?" ) -> execute ( $ intNewsletter , $ arrData [ 'email' ] ) ; if ( $ objRecipient -> count < 1 ) { $ this -> Database -> prepare ( "INSERT INTO tl_newsletter_recipients SET pid=?, tstamp=$time, email=?, addedOn=$time" ) -> execute ( $ intNewsletter , $ arrData [ 'email' ] ) ; } } }
12307	public function getDatePeriod ( ) { $ intervaloDiario = DateInterval :: createFromDateString ( '1 day' ) ; $ dataFim = clone $ this -> endDate ; $ dataFim -> add ( $ intervaloDiario ) ; return new DatePeriod ( $ this -> startDate , $ intervaloDiario , $ dataFim ) ; }
469	public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } return $ model ; }
1834	public static function findByPk ( $ varValue , array $ arrOptions = array ( ) ) { if ( empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varValue ) ; if ( $ objModel !== null ) { return $ objModel ; } } $ arrOptions = array_merge ( array ( 'limit' => 1 , 'column' => static :: $ strPk , 'value' => $ varValue , 'return' => 'Model' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
4649	protected function getServices ( $ config ) { $ services = array ( ) ; $ travisServices = isset ( $ config [ 'services' ] ) && is_array ( $ config [ 'services' ] ) ? $ config [ 'services' ] : array ( ) ; foreach ( $ travisServices as $ service ) { if ( isset ( $ this -> servicesMapping [ $ service ] ) ) { $ services [ ] = new Service ( $ service , $ this -> servicesMapping [ $ service ] [ 'repository' ] , $ this -> servicesMapping [ $ service ] [ 'tag' ] , $ this -> servicesMapping [ $ service ] [ 'config' ] ) ; } } return $ services ; }
507	public function getMessageSource ( $ category ) { if ( isset ( $ this -> translations [ $ category ] ) ) { $ source = $ this -> translations [ $ category ] ; if ( $ source instanceof MessageSource ) { return $ source ; } return $ this -> translations [ $ category ] = Yii :: createObject ( $ source ) ; } foreach ( $ this -> translations as $ pattern => $ source ) { if ( strpos ( $ pattern , '*' ) > 0 && strpos ( $ category , rtrim ( $ pattern , '*' ) ) === 0 ) { if ( $ source instanceof MessageSource ) { return $ source ; } return $ this -> translations [ $ category ] = $ this -> translations [ $ pattern ] = Yii :: createObject ( $ source ) ; } } if ( isset ( $ this -> translations [ '*' ] ) ) { $ source = $ this -> translations [ '*' ] ; if ( $ source instanceof MessageSource ) { return $ source ; } return $ this -> translations [ $ category ] = $ this -> translations [ '*' ] = Yii :: createObject ( $ source ) ; } throw new InvalidConfigException ( "Unable to locate message source for category '$category'." ) ; }
7654	public function dir_readdir ( ) { $ object = current ( $ this -> blobs ) ; if ( $ object !== false ) { next ( $ this -> blobs ) ; return $ object -> Name ; } return false ; }
2784	private function indent ( $ output , $ asArray = false ) { $ lines = explode ( "\n" , $ output ) ; $ out = [ ] ; foreach ( $ lines as $ line ) { $ out [ ] = ' > ' . $ line ; } if ( $ asArray ) { return $ out ; } $ return = implode ( "\n" , $ out ) ; return $ return ; }
8328	public function getCaptchaResult ( $ captchaId ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=get&id={$captchaId}&json=1" ) ; $ responseData = json_decode ( $ response -> getBody ( ) -> __toString ( ) , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new InvalidArgumentException ( 'json_decode error: ' . json_last_error_msg ( ) ) ; } if ( $ responseData [ 'status' ] === self :: STATUS_CODE_CAPCHA_NOT_READY ) { return false ; } if ( $ responseData [ 'status' ] === self :: STATUS_CODE_OK ) { $ this -> getLogger ( ) -> info ( "Got OK response: `{$responseData['request']}`." ) ; return $ responseData [ 'request' ] ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseData [ 'request' ] ) ? : $ responseData [ 'request' ] , $ responseData [ 'status' ] ) ; }
2907	public function getPartDecodedContent ( Zend_Mime_Part $ mimePart ) { if ( method_exists ( $ mimePart , 'getRawContent' ) ) { return $ mimePart -> getRawContent ( ) ; } $ content = '' ; if ( method_exists ( $ mimePart , 'getContent' ) ) { $ encoding = $ mimePart -> encoding ; $ mimePart -> encoding = 'none' ; $ content = $ mimePart -> getContent ( ) ; $ mimePart -> encoding = $ encoding ; } return $ content ; }
9922	private function defineManyToManyRelation ( Model $ model1 , Model $ model2 ) { $ this -> relations [ $ model1 -> getName ( ) ] [ ] = new Relation ( $ model1 , $ model2 , Relation :: HAS_AND_BELONGS_TO ) ; $ this -> relations [ $ model2 -> getName ( ) ] [ ] = new Relation ( $ model2 , $ model1 , Relation :: HAS_AND_BELONGS_TO ) ; }
9439	public function alias ( $ id , $ original ) { $ this -> instances [ $ id ] = $ this -> get ( $ original ) ; return $ this ; }
1699	public function getFile ( $ strName ) { foreach ( $ this -> arrFiles as $ k => $ v ) { if ( $ strName == $ v [ 'file_name' ] ) { $ this -> intIndex = $ k ; return true ; } } return false ; }
3777	protected function getParamName ( ) { if ( $ this -> get ( 'urlparam' ) ) { return $ this -> get ( 'urlparam' ) ; } $ objAttribute = $ this -> getFilteredAttribute ( ) ; if ( $ objAttribute ) { return $ objAttribute -> getColName ( ) ; } return null ; }
2497	private function getCoreCriterion ( array $ languageCodes , $ useAlwaysAvailable ) { if ( ! empty ( $ languageCodes ) ) { $ filter = $ this -> getLanguageFilter ( $ languageCodes ) ; if ( $ useAlwaysAvailable ) { $ filter = new LogicalOr ( array ( $ filter , $ this -> getAlwaysAvailableFilter ( $ languageCodes ) , ) ) ; } return $ filter ; } return new CustomField ( self :: FIELD_IS_MAIN_LANGUAGE , Operator :: EQ , true ) ; }
3555	protected function castValue ( ) { $ value = $ this -> attributes [ 'meta_value' ] ; $ validTypes = [ 'boolean' , 'integer' , 'float' , 'double' , 'array' , 'object' , 'null' ] ; if ( in_array ( $ this -> attributes [ 'meta_type' ] , $ validTypes ) ) { settype ( $ value , $ this -> attributes [ 'meta_type' ] ) ; } return $ value ; }
12802	public function getPage ( $ page = null ) { if ( is_null ( $ page ) ) { $ page = $ this -> page ; } list ( $ offset , $ size ) = $ this -> getLimts ( $ page ) ; $ this -> manager -> limit ( $ offset , $ size ) ; return $ this -> manager -> values ( ) ; }
12287	public function insetIf ( bool $ condition , string $ block , array $ vars = null ) : string { return $ condition ? trim ( $ this -> make ( $ block , $ vars ) ) . PHP_EOL : PHP_EOL ; }
10376	protected static function look_if_process_files ( $ type ) { if ( is_string ( self :: $ unify ) || isset ( self :: $ unify [ "{$type}s" ] ) ) { return self :: unify_files ( self :: prepare_files ( $ type ) ) ; } }
3307	protected function buildRequestParam ( $ images , $ options = [ ] ) { if ( is_array ( $ images ) && ! empty ( $ images [ 0 ] ) ) { $ images = $ images [ 0 ] ; } if ( $ this -> supportUrl && FileConverter :: isUrl ( $ images ) ) { $ options [ 'url' ] = $ images ; } else { $ options [ 'image' ] = FileConverter :: toBase64Encode ( $ images ) ; } return $ options ; }
6704	public function baseURL ( $ httpverb , $ url , $ params ) { uksort ( $ params , 'strcmp' ) ; return strtoupper ( $ httpverb ) . '&' . rawurlencode ( $ url ) . '&' . rawurlencode ( http_build_query ( $ params ) ) ; }
12677	public function approveRemoval ( $ sourceDir , array $ options , $ username ) { $ this -> init ( $ sourceDir , $ options , $ username ) ; $ targetFilename = sprintf ( '%s/blocks/%s.json' , $ this -> productionDir , $ options [ 'blockname' ] ) ; if ( ! file_exists ( $ targetFilename ) ) { return ; } Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVING_REMOVAL , new BlockApprovingRemovalEvent ( $ this -> serializer , $ targetFilename ) ) ; $ this -> filesystem -> remove ( $ targetFilename ) ; $ slotDefinition = $ this -> getSlotDefinition ( $ this -> productionDir ) ; $ blocks = $ slotDefinition [ "blocks" ] ; $ key = array_search ( $ options [ 'blockname' ] , $ blocks ) ; unset ( $ blocks [ $ key ] ) ; $ slotDefinition [ "blocks" ] = $ blocks ; $ this -> saveSlotDefinition ( $ this -> productionDir , $ slotDefinition , $ username ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVED_REMOVAL , new BlockApprovedRemovalEvent ( $ this -> serializer , $ targetFilename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been approved for removal on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
11958	public function remove ( $ element ) { if ( ! $ this -> contains ( $ element ) ) { return false ; } $ this -> offsetUnset ( $ this -> indexOf ( $ element ) ) ; return true ; }
7478	public function getFormFor ( $ entity , $ className = null , array $ options = array ( ) ) { if ( empty ( $ this -> _formHelper ) && ( $ this -> _formHelper = $ this -> get ( 'orkestra.application.helper.form' ) ) == null ) { throw new \ RuntimeException ( 'Orkestra FormHelper is not registered as a service' ) ; } $ type = $ this -> container -> get ( 'orkestra.application.helper.form' ) -> getType ( $ entity , $ className ) ; return $ this -> createForm ( $ type , $ entity , $ options ) ; }
8288	protected function loadModules ( ) { foreach ( $ this -> config [ "authModules" ] as $ name ) { try { $ instance = $ this -> container -> get ( $ name ) ; } catch ( \ League \ Container \ Exception \ NotFoundException $ e ) { if ( ! class_exists ( $ name ) ) { throw new \ RuntimeException ( "PicoAuth module not found: " . $ name ) ; } $ instance = new $ name ; } if ( ! is_subclass_of ( $ instance , Module \ AbstractAuthModule :: class , false ) ) { throw new \ RuntimeException ( "PicoAuth module class must inherit from AbstractAuthModule." ) ; } $ name = $ instance -> getName ( ) ; $ this -> modules [ $ name ] = $ instance ; } }
12481	public function registerServices ( ServicesFactory $ servicesFactory , array $ entityManagers ) { foreach ( $ entityManagers as $ name => $ entityManager ) { $ emConfig = Setup :: createAnnotationMetadataConfiguration ( ( array ) $ entityManager -> getEntities ( ) , true , null , null , true ) ; $ emConfig -> setNamingStrategy ( new UnderscoreNamingStrategy ( ) ) ; $ em = $ this -> createEntityManager ( $ entityManager -> toArray ( ) , $ emConfig ) ; $ emServiceId = 'doctrine.em.' . Str :: cast ( $ name ) -> lower ( ) ; $ servicesFactory -> registerService ( [ 'id' => $ emServiceId , 'instance' => $ em ] ) ; $ servicesFactory -> registerService ( [ 'id' => 'db.connection.' . $ name , 'instance' => $ em -> getConnection ( ) -> getWrappedConnection ( ) ] ) ; } }
3311	protected function getTokenFormApi ( ) { $ http = $ this -> getHttp ( ) ; $ token = $ http -> parseJson ( $ http -> post ( self :: API_TOKEN_URI , [ 'grant_type' => 'client_credentials' , 'client_id' => $ this -> getAppKey ( ) , 'client_secret' => $ this -> getSecretKey ( ) ] ) ) ; if ( empty ( $ token [ $ this -> tokenSucessKey ] ) ) { throw new RuntimeException ( 'Request AccessToken fail. response: ' . json_encode ( $ token , JSON_UNESCAPED_UNICODE ) ) ; } return $ token ; }
1167	protected function validateJsRemoteRequest ( $ attribute , $ parameters ) { $ this -> setRemoteValidation ( $ attribute , $ parameters [ 'validate_all' ] ) ; $ validator = $ this -> validator ; if ( $ validator -> passes ( ) ) { return true ; } return $ validator -> messages ( ) -> get ( $ attribute ) ; }
4450	public function popByJid ( string $ jid , ? string $ worker = null ) : ? BaseJob { $ workerName = $ worker ? : $ this -> client -> getWorkerName ( ) ; $ data = json_decode ( $ this -> client -> popByJid ( $ this -> name , $ jid , $ workerName ) , true ) ; $ jobData = array_reduce ( $ data , 'array_merge' , [ ] ) ; if ( isset ( $ jobData [ 'jid' ] ) === false ) { return null ; } if ( $ jobData [ 'jid' ] === $ jid ) { $ job = new BaseJob ( $ this -> client , $ jobData ) ; $ job -> setEventsManager ( $ this -> getEventsManager ( ) ) ; } return $ job ?? null ; }
11827	public function getBom ( $ encoding = 'UTF-8' ) { $ boms = array ( 'UTF-8' => pack ( 'CCC' , 0xef , 0xbb , 0xbf ) , 'UTF-16 Big Endian' => pack ( 'CC' , 0xfe , 0xff ) , 'UTF-16 Little Endian' => pack ( 'CC' , 0xff , 0xfe ) , 'UTF-32 Big Endian' => pack ( 'CCCC' , 0x00 , 0x00 , 0xfe , 0xff ) , 'UTF-32 Little Endian' => pack ( 'CCCC' , 0xff , 0xfe , 0x00 , 0x00 ) , 'SCSU' => pack ( 'CCC' , 0x0e , 0xfe , 0xff ) , 'UTF-7 (1)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x38 ) , 'UTF-7 (2)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x39 ) , 'UTF-7 (3)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x2b ) , 'UTF-7 (4)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x2f ) , 'UTF-7 (5)' => pack ( 'CCCCC' , 0x2b , 0x2f , 0x76 , 0x38 , 0x2d ) , 'UTF-1' => pack ( 'CCC' , 0xF7 , 0x64 , 0x4c ) , 'UTF-EBCDIC' => pack ( 'CCCC' , 0xdd , 0x73 , 0x66 , 0x73 ) , 'BOCU-1' => pack ( 'CCC' , 0xfb , 0xee , 0x28 ) , 'GB-18030' => pack ( 'CCCC' , 0x84 , 0x31 , 0x95 , 0x33 ) , ) ; if ( 'all' == $ encoding ) { return $ boms ; } return $ boms [ $ encoding ] ; }
4871	public function setEventPrototype ( EventInterface $ prototype ) { if ( ! $ prototype instanceof DependencyResultEvent ) { throw new \ InvalidArgumentException ( 'This event manager only accepts events of the type ' . DependencyResultEvent :: class ) ; } parent :: setEventPrototype ( $ prototype ) ; }
852	public function getMeaningfulTokenSibling ( $ index , $ direction ) { return $ this -> getTokenNotOfKindSibling ( $ index , $ direction , [ [ T_WHITESPACE ] , [ T_COMMENT ] , [ T_DOC_COMMENT ] ] ) ; }
11186	public function setPrivateChatUpdateRead ( Neuron_GameServer_Player $ from , Neuron_GameServer_Player $ target ) { $ db = Neuron_DB_Database :: getInstance ( ) ; $ db -> query ( " UPDATE n_privatechat_updates SET pu_read = '1' WHERE pu_to = {$target->getId ()} AND pu_from = {$from->getId ()} " ) ; }
12839	static public function generateFilename ( $ directory , $ extension , $ length = 16 ) { do { $ name = \ Extlib \ Generator :: generate ( $ length ) ; $ filepath = rtrim ( $ directory , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . sprintf ( '%s.%s' , $ name , $ extension ) ; } while ( file_exists ( $ filepath ) ) ; return $ name ; }
9517	public function recreate ( $ file ) { if ( is_file ( $ file ) ) { return ; } $ virtual = $ tables = $ indexes = array ( ) ; if ( $ result = $ this -> query ( 'SELECT type, name, sql FROM sqlite_master' ) ) { while ( list ( $ type , $ name , $ sql ) = $ this -> fetch ( $ result ) ) { if ( ! empty ( $ sql ) ) { switch ( $ type ) { case 'table' : $ tables [ $ name ] = $ sql ; break ; case 'index' : $ indexes [ ] = $ sql ; break ; } } } $ this -> close ( $ result ) ; } foreach ( $ tables as $ name => $ sql ) { if ( strpos ( $ sql , 'VIRTUAL TABLE' ) ) { $ virtual [ ] = $ name ; } } foreach ( $ virtual as $ table ) { foreach ( $ tables as $ name => $ sql ) { if ( strpos ( $ name , "{$table}_" ) === 0 ) { unset ( $ tables [ $ name ] ) ; } } } $ db = new self ( $ file ) ; $ this -> exec ( 'ATTACH DATABASE ' . $ this -> dbEscape ( $ file ) . ' AS recreate' ) ; foreach ( $ tables as $ table => $ sql ) { $ db -> connection ( ) -> exec ( $ sql ) ; if ( $ fields = $ this -> row ( 'SELECT * FROM ' . $ table . ' LIMIT 1' , '' , 'assoc' ) ) { $ fields = implode ( ', ' , array_keys ( $ fields ) ) ; $ this -> exec ( "INSERT INTO recreate.{$table} ({$fields}) SELECT * FROM {$table}" ) ; } } foreach ( $ indexes as $ sql ) { $ db -> connection ( ) -> exec ( $ sql ) ; } $ db -> connection ( ) -> close ( ) ; }
6357	public function getTimestamp ( $ style = TS_UNIX ) { if ( ! isset ( self :: $ formats [ $ style ] ) ) { throw new TimestampException ( __METHOD__ . ': Illegal timestamp output type.' ) ; } $ output = $ this -> timestamp -> format ( self :: $ formats [ $ style ] ) ; if ( $ style == TS_RFC2822 ) { $ output .= ' GMT' ; } if ( $ style == TS_MW && strlen ( $ output ) !== 14 ) { throw new TimestampException ( __METHOD__ . ': The timestamp cannot be represented in ' . 'the specified format' ) ; } return $ output ; }
12606	public static function getPath ( string $ file ) { $ parts = explode ( '/' , $ file ) ; array_pop ( $ parts ) ; return implode ( '/' , $ parts ) ; }
617	private function parseArray ( $ value , & $ i = 0 ) { $ result = [ ] ; $ len = strlen ( $ value ) ; for ( ++ $ i ; $ i < $ len ; ++ $ i ) { switch ( $ value [ $ i ] ) { case '{' : $ result [ ] = $ this -> parseArray ( $ value , $ i ) ; break ; case '}' : break 2 ; case $ this -> delimiter : if ( empty ( $ result ) ) { $ result [ ] = null ; } if ( in_array ( $ value [ $ i + 1 ] , [ $ this -> delimiter , '}' ] , true ) ) { $ result [ ] = null ; } break ; default : $ result [ ] = $ this -> parseString ( $ value , $ i ) ; } } return $ result ; }
5856	public function initializeRulesets ( array $ configuration ) { $ general = $ configuration ; $ general [ 'usergroup' ] = '' ; unset ( $ general [ 'rulesets' ] ) ; $ general = $ this -> expandValuesInRuleset ( $ general ) ; if ( $ general [ 'conversion_mapping' ] === '' ) { $ general [ 'conversion_mapping' ] = [ ] ; } if ( isset ( $ configuration [ 'rulesets' ] ) ) { $ rulesets = $ this -> compileRuleSets ( $ configuration [ 'rulesets' ] ) ; } else { $ rulesets = [ ] ; } foreach ( $ rulesets as $ k => & $ ruleset ) { foreach ( $ general as $ key => $ value ) { if ( ! isset ( $ ruleset [ $ key ] ) ) { $ ruleset [ $ key ] = $ value ; } elseif ( $ ruleset [ $ key ] === '' ) { $ ruleset [ $ key ] = $ value ; } } if ( count ( $ ruleset [ 'usergroup' ] ) == 0 ) { $ ruleset [ 'directories' ] = array_diff ( $ ruleset [ 'directories' ] , $ general [ 'directories' ] ) ; if ( count ( $ ruleset [ 'directories' ] ) == 0 ) { unset ( $ rulesets [ $ k ] ) ; } } } $ rulesets [ ] = $ general ; $ this -> rulesets = $ rulesets ; }
12000	static protected function doctrineQuery ( $ tableName , $ field , $ generate ) { return \ Doctrine_Query :: create ( ) -> select ( $ field ) -> from ( $ tableName ) -> where ( "$field = ?" , $ generate ) -> execute ( array ( ) , \ Doctrine_Core :: HYDRATE_SINGLE_SCALAR ) ; }
10894	public function get ( $ name ) { return isset ( $ this -> uris [ $ name ] ) ? $ this -> uris [ $ name ] : null ; }
996	public function offsetExists ( $ offset ) { if ( $ offset === false ) { return $ this -> falseValueIsSet ; } if ( $ offset === true ) { return $ this -> trueValueIsSet ; } if ( is_int ( $ offset ) || is_string ( $ offset ) ) { return array_key_exists ( $ offset , $ this -> standardStore ) ; } if ( is_float ( $ offset ) ) { return array_key_exists ( ( string ) $ offset , $ this -> floatStore ) ; } if ( is_object ( $ offset ) ) { return $ this -> objectStore -> offsetExists ( $ offset ) ; } if ( is_array ( $ offset ) ) { foreach ( $ this -> arrayKeys as $ index => $ entry ) { if ( $ entry === $ offset ) { $ this -> lastArrayKey = $ offset ; $ this -> lastArrayValue = $ this -> arrayValues [ $ index ] ; return true ; } } } if ( $ offset === null ) { return $ this -> nullValueIsSet ; } return false ; }
4709	public function initialize ( Text $ text ) { $ text -> replaceString ( "\r\n" , "\n" ) ; $ text -> replaceString ( "\r" , "\n" ) ; $ text -> append ( "\n\n" ) ; $ this -> markdown -> emit ( 'detab' , array ( $ text ) ) ; $ text -> replace ( '/^[ \t]+$/m' , '' ) ; }
11515	public function getNamedParam ( string $ category , string $ key ) { $ params = $ this -> getNamedParams ( $ category ) ; return $ params [ $ key ] ?? '' ; }
12647	public function setFalse ( $ obData = null ) { $ this -> bStatus = false ; $ this -> obData = $ obData ; return $ this ; }
11639	public function getColumnSettings ( ) { if ( is_null ( $ this -> _columnSettings ) ) { $ this -> _columnSettings = [ ] ; foreach ( $ this -> columns as $ key => $ c ) { if ( ! $ c -> visible ) { continue ; } $ this -> _columnSettings [ $ key ] = [ 'label' => $ c -> getDataLabel ( ) ] ; if ( ! isset ( $ c -> htmlOptions ) ) { $ c -> htmlOptions = [ ] ; } $ this -> _columnSettings [ $ key ] [ 'htmlOptions' ] = $ c -> htmlOptions ; $ sortableResolve = $ this -> dataProvider -> sort -> resolveAttribute ( $ c -> name ) ; $ this -> _columnSettings [ $ key ] [ 'sortable' ] = ! empty ( $ sortableResolve ) ; } } return $ this -> _columnSettings ; }
5148	protected function getMostRecentUnreadEmail ( ) { if ( empty ( $ this -> unreadInbox ) ) { $ this -> fail ( 'Unread Inbox is Empty' ) ; } $ email = array_shift ( $ this -> unreadInbox ) ; $ content = $ this -> getFullEmail ( $ email -> id ) ; $ content -> Headers = $ this -> getHeaders ( $ email -> id ) -> headers ; return $ content ; }
11728	private function _fetch ( $ attrName , $ default = NULL ) { return $ this -> hasAttribute ( $ attrName ) ? $ this -> getAttribute ( $ attrName ) -> getValue ( ) : $ default ; }
8919	protected function parseAuthority ( $ authority , & $ out ) { if ( ! empty ( $ authority ) ) { $ out [ 'id' ] = $ authority ; if ( preg_match ( '/\((.*?)\)(.*)/' , $ authority , $ matches ) ) { $ out [ 'vocabulary' ] = $ matches [ 1 ] ; $ out [ 'id' ] = $ matches [ 2 ] ; } } }
8836	public function setMaxRetries ( $ retries ) { switch ( gettype ( $ retries ) ) { case 'integer' : $ this -> maxRetries = new Retries ( $ retries ) ; break ; case 'object' : $ this -> maxRetries = $ retries ; break ; default : throw new InvalidArgumentException ( 'Invalid type for max retries given.' ) ; break ; } }
5525	protected function createCodeForClass ( $ methods ) { $ implements = '' ; $ interfaces = $ this -> reflection -> getInterfaces ( ) ; $ interfaces = array_diff ( $ interfaces , [ 'Traversable' , 'Throwable' ] ) ; if ( count ( $ interfaces ) > 0 ) { $ implements = 'implements ' . implode ( ', ' , $ interfaces ) ; } $ code = 'class ' . $ this -> mock_class . ' extends ' . $ this -> mock_base . ' ' . $ implements . " {\n" ; $ code .= " function __construct() {\n" ; $ code .= " parent::__construct();\n" ; $ code .= " }\n" ; $ code .= $ this -> createCodeForConstructor ( ) ; $ code .= $ this -> createCodeForMethods ( $ methods ) ; $ code .= "}\n" ; return $ code ; }
8099	protected function validateAll ( $ includeAllRules = false ) { if ( $ includeAllRules ) { $ fieldData = new Collection ( array_fill_keys ( array_keys ( $ this -> _validations -> toArray ( ) ) , null ) ) ; $ fieldData -> update ( $ this -> _updates -> toArray ( ) ) ; } else { $ fieldData = clone $ this -> _updates ; } foreach ( $ fieldData -> toArray ( ) as $ field => $ val ) { $ field2 = $ field . '2' ; if ( ! is_null ( $ fieldData -> $ field2 ) ) { if ( $ val != $ fieldData -> $ field2 ) { $ this -> log -> formError ( $ field , ucfirst ( $ field ) . 's did not match' ) ; } else { $ this -> log -> report ( ucfirst ( $ field ) . 's matched' ) ; } } if ( $ this -> _updates -> $ field ) { $ this -> _updates -> $ field = trim ( $ val ) ; } if ( $ validation = $ this -> _validations -> $ field ) { $ this -> validate ( $ field , $ validation -> limit , $ validation -> regEx ) ; } } return ! $ this -> log -> hasError ( ) ; }
10281	public static function absoluteCoordinate ( $ pCoordinateString ) { if ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } $ worksheet = '' ; $ cellAddress = explode ( '!' , $ pCoordinateString ) ; if ( count ( $ cellAddress ) > 1 ) { list ( $ worksheet , $ pCoordinateString ) = $ cellAddress ; } if ( $ worksheet > '' ) { $ worksheet .= '!' ; } list ( $ column , $ row ) = self :: coordinateFromString ( $ pCoordinateString ) ; $ column = ltrim ( $ column , '$' ) ; $ row = ltrim ( $ row , '$' ) ; return $ worksheet . '$' . $ column . '$' . $ row ; }
12122	public function setLastModified ( Request $ request , \ DateTime $ lastModified ) { $ this -> cache -> save ( $ this -> getCacheKeyRequest ( sha1 ( $ request -> getUri ( ) ) , 'lastmodified' ) , $ lastModified -> format ( 'r' ) ) ; foreach ( $ this -> itemIds as $ itemId => $ bool ) { $ key = $ this -> getCacheKeyItem ( $ itemId , 'uri' ) ; $ urisForItem = Option :: fromValue ( $ this -> cache -> fetch ( $ key ) , false ) -> getOrElse ( array ( ) ) ; $ urisForItem [ $ request -> getUri ( ) ] = $ bool ; $ this -> cache -> save ( $ key , $ urisForItem ) ; Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ request , $ itemId ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] "%s" is used on "%s".' , $ itemId , $ request -> getUri ( ) ) ) ; } ) ; } }
10513	private function checkIfObserverMustBeUpdate ( \ StdClass $ observer ) { if ( $ observer -> eventName == $ this -> event -> name ) { return true ; } return false ; }
4247	private function logRequestHeaders ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.headers' ) ) { return ; } if ( ! empty ( $ _SERVER [ 'argv' ] ) ) { return ; } $ headers = $ this -> debug -> utilities -> getAllHeaders ( ) ; \ ksort ( $ headers , SORT_NATURAL ) ; $ this -> debug -> log ( 'request headers' , $ headers ) ; }
1667	protected function disableTwoFactor ( BackendUser $ user , $ return ) { if ( ! $ user -> useTwoFactor ) { return ; } $ user -> secret = null ; $ user -> useTwoFactor = '' ; $ user -> save ( ) ; throw new RedirectResponseException ( $ return ) ; }
1333	protected function applyFilters ( $ query , Collection $ filters ) { if ( $ this -> isFindMany ( $ filters ) ) { $ this -> filterByIds ( $ query , $ filters ) ; } $ this -> filter ( $ query , $ filters ) ; }
1396	public function updated ( $ resource = null , array $ links = [ ] , $ meta = null , array $ headers = [ ] ) { return $ this -> getResourceResponse ( $ resource , $ links , $ meta , $ headers ) ; }
8019	public function getClient ( ) { if ( $ this -> _client === null ) { $ settings = [ 'key' => $ this -> key , 'secret' => $ this -> secret ] ; if ( $ this -> enableV4 ) $ settings [ 'signature' ] = 'v4' ; $ this -> _client = S3Client :: factory ( $ settings ) ; } return $ this -> _client ; }
6657	protected function createFailSafeResponse ( ) { $ status = new Status ( 500 ) ; $ response = new Response ( ) ; $ response -> setRequest ( new Request ( ) ) ; $ response -> setWriter ( new Json ( ) ) ; $ response -> setStatus ( $ status ) ; $ response -> setBodyData ( $ status -> getMessage ( ) ) ; return $ response ; }
10418	public static function extract ( $ yamlArray , $ key , $ needed = false ) { if ( ! empty ( $ yamlArray ) && array_key_exists ( $ key , $ yamlArray ) ) return $ yamlArray [ $ key ] ; if ( $ needed ) { throw new \ Deployer \ Exception \ Exception ( 'Cannot find the setting: ' . $ key . '. This key needs to be given!' ) ; } return null ; }
7826	protected function getLongestPipeLength ( ) { if ( empty ( $ this -> pipes ) ) return 0 ; return array_reduce ( $ this -> pipes , function ( $ carry , $ pipe ) { return strlen ( $ pipe ) > $ carry ? strlen ( $ pipe ) : $ carry ; } , static :: MIN_PIPE_LENGTH ) ; }
6168	protected function writeAssertionFailure ( $ assertionFailure ) { $ this -> writeNewLine ( ) ; foreach ( explode ( "\n" , $ assertionFailure ) as $ line ) { $ this -> writeWithColor ( 'fg-red' , $ line ) ; } }
4588	public function setMaxResults ( ? int $ maxResults ) { $ this -> maxResults = $ maxResults ; $ this -> _maxResults = null !== $ maxResults ; return $ this ; }
9682	function fromXML ( $ xmlElement ) { $ this -> contact = new ReportContact ( ) ; $ this -> contact -> fromXML ( $ xmlElement -> contact ) ; if ( isset ( $ xmlElement -> mailing_id ) ) $ this -> mailingId = $ xmlElement -> mailing_id ; if ( isset ( $ xmlElement -> timestamp ) ) $ this -> timestamp = $ xmlElement -> timestamp ; if ( isset ( $ xmlElement -> link_id ) ) $ this -> linkId = $ xmlElement -> link_id ; if ( isset ( $ xmlElement -> link_url ) ) $ this -> linkUrl = $ xmlElement -> link_url ; if ( isset ( $ xmlElement -> link_tags ) ) { $ this -> linkTags = array ( ) ; foreach ( $ xmlElement -> link_tags -> children ( ) as $ field ) { array_push ( $ this -> linkTags , $ field [ 0 ] ) ; } } }
6897	public function bind ( $ key , & $ value ) { $ this -> open ( ) ; $ this -> _data [ $ key ] = & $ value ; return $ this ; }
1067	private function findConflictsBetweenSubSelectionSets ( ValidationContext $ context , $ areMutuallyExclusive , $ parentType1 , SelectionSetNode $ selectionSet1 , $ parentType2 , SelectionSetNode $ selectionSet2 ) { $ conflicts = [ ] ; [ $ fieldMap1 , $ fragmentNames1 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType1 , $ selectionSet1 ) ; [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType2 , $ selectionSet2 ) ; $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap1 , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; if ( $ fragmentNames2Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap1 , $ fragmentNames2 [ $ j ] ) ; } } $ fragmentNames1Length = count ( $ fragmentNames1 ) ; if ( $ fragmentNames1Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap2 , $ fragmentNames1 [ $ i ] ) ; } } for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentNames1 [ $ i ] , $ fragmentNames2 [ $ j ] ) ; } } return $ conflicts ; }
12262	public function getCustomField ( $ class , $ slug = null ) { if ( ! $ slug ) { throw CustomFieldsHelperException :: slugIsMissing ( ) ; } $ resolveClass = ( is_string ( $ class ) ) ? $ class : get_class ( $ class ) ; if ( ! $ this -> cache [ $ resolveClass ] [ $ slug ] ) { $ this -> _cacheCustomFields ( $ resolveClass ) ; } return $ this -> cache [ $ resolveClass ] [ $ slug ] ; }
4610	public function geo ( $ sLat , $ sLon , $ iHeight ) { $ this -> sData .= 'GEO:' . $ sLat . ',' . $ sLon . ',' . $ iHeight . "\n" ; return $ this ; }
3484	public function withThreadId ( string $ threadId ) : Aps { $ cloned = clone $ this ; $ cloned -> threadId = $ threadId ; return $ cloned ; }
1392	public function isJsonApi ( $ request , Exception $ e ) { if ( Helpers :: wantsJsonApi ( $ request ) ) { return true ; } $ route = app ( JsonApiService :: class ) -> currentRoute ( ) ; return $ route -> hasCodec ( ) && $ route -> getCodec ( ) -> willEncode ( ) ; }
4081	public function getRenderSetting ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; return isset ( $ this -> information [ $ metaModelName ] [ self :: COMBINATION ] [ 'view_id' ] ) ? $ this -> information [ $ metaModelName ] [ self :: COMBINATION ] [ 'view_id' ] : null ; }
2014	public static function addClasses ( $ classes ) { @ trigger_error ( 'Using ClassLoader::addClasses() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; foreach ( $ classes as $ class => $ file ) { self :: addClass ( $ class , $ file ) ; } }
8077	public function delete ( $ endpoint , $ query = [ ] ) { $ endpoint = $ this -> buildUri ( $ endpoint , $ query ) ; $ headers = $ this -> buildHeaders ( ) ; $ this -> response = $ this -> client -> delete ( $ endpoint , $ headers ) ; return $ this -> response ; }
10166	private function readBIFF8CellAddressB ( $ cellAddressStructure , $ baseCell = 'A1' ) { list ( $ baseCol , $ baseRow ) = Coordinate :: coordinateFromString ( $ baseCell ) ; $ baseCol = Coordinate :: columnIndexFromString ( $ baseCol ) - 1 ; $ rowIndex = self :: getUInt2d ( $ cellAddressStructure , 0 ) ; $ row = self :: getUInt2d ( $ cellAddressStructure , 0 ) + 1 ; if ( ! ( 0x4000 & self :: getUInt2d ( $ cellAddressStructure , 2 ) ) ) { $ colIndex = 0x00FF & self :: getUInt2d ( $ cellAddressStructure , 2 ) ; $ column = Coordinate :: stringFromColumnIndex ( $ colIndex + 1 ) ; $ column = '$' . $ column ; } else { $ relativeColIndex = 0x00FF & self :: getInt2d ( $ cellAddressStructure , 2 ) ; $ colIndex = $ baseCol + $ relativeColIndex ; $ colIndex = ( $ colIndex < 256 ) ? $ colIndex : $ colIndex - 256 ; $ colIndex = ( $ colIndex >= 0 ) ? $ colIndex : $ colIndex + 256 ; $ column = Coordinate :: stringFromColumnIndex ( $ colIndex + 1 ) ; } if ( ! ( 0x8000 & self :: getUInt2d ( $ cellAddressStructure , 2 ) ) ) { $ row = '$' . $ row ; } else { $ rowIndex = ( $ rowIndex <= 32767 ) ? $ rowIndex : $ rowIndex - 65536 ; $ row = $ baseRow + $ rowIndex ; } return $ column . $ row ; }
7280	public function validateInput ( array $ rules ) { foreach ( $ rules as $ rule ) if ( empty ( $ this -> inputs [ $ rule ] ) ) return false ; return true ; }
1089	protected function getStub ( $ name ) { if ( stripos ( $ name , '.php' ) === FALSE ) $ name = $ name . '.php' ; return $ this -> files -> get ( $ this -> getStubPath ( ) . '/' . $ name ) ; }
11587	public function end ( $ taskName ) { if ( ! isset ( $ this -> _tasks [ $ taskName ] ) ) { throw new Exception ( "Undefined task name: `'{$taskName}`." ) ; } $ task = $ this -> _tasks [ $ taskName ] ; $ task -> end ( ) ; return $ task ; }
12940	private function assertClient ( ClientInterface $ client ) { if ( $ client -> getConnection ( ) instanceof AggregateConnectionInterface ) { throw new NotSupportedException ( 'Cannot initialize a monitor consumer over aggregate connections.' ) ; } if ( $ client -> getCommandFactory ( ) -> supportsCommand ( 'MONITOR' ) === false ) { throw new NotSupportedException ( "'MONITOR' is not supported by the current command factory." ) ; } }
5389	public function setValue ( $ value ) { if ( ! $ this -> valueIsPossible ( $ value ) ) { return false ; } $ index = false ; $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { if ( ! $ widgets [ $ i ] -> setValue ( $ value ) ) { $ widgets [ $ i ] -> setValue ( false ) ; } } return true ; }
12360	public static function encodeHashId ( $ id ) { if ( ! config ( 'odin.hashid.active' ) ) { return $ id ; } $ hashids = App :: make ( 'Hashids' ) ; return $ hashids -> encode ( $ id , date ( 'd' ) ) ; }
7508	function setWhitespace ( $ ws ) { if ( is_array ( $ ws ) ) { $ this -> whitespace = array_fill_keys ( array_values ( $ ws ) , true ) ; $ this -> buildCharMap ( ) ; } else { $ this -> setWhiteSpace ( str_split ( $ ws ) ) ; } }
5033	public function extract ( $ value ) { if ( ! $ value instanceof FileInterface ) { return null ; } $ tmp = tempnam ( sys_get_temp_dir ( ) , 'yk-copy.' ) ; $ out = fopen ( $ tmp , 'w' ) ; $ in = $ value -> getResource ( ) ; register_shutdown_function ( function ( $ filename ) { @ unlink ( $ filename ) ; } , $ tmp ) ; while ( ! feof ( $ in ) ) { fputs ( $ out , fgets ( $ in , 1024 ) ) ; } fclose ( $ in ) ; fclose ( $ out ) ; $ return = [ "file" => $ tmp ] ; foreach ( [ 'user' , 'name' , 'type' ] as $ key ) { $ v = $ value -> { "get$key" } ( ) ; if ( $ v ) { $ return [ $ key ] = $ v ; } } return $ return ; }
3960	public function parseAttribute ( $ strAttributeName , $ strOutputFormat = 'text' , $ objSettings = null ) { return $ this -> internalParseAttribute ( $ this -> getAttribute ( $ strAttributeName ) , $ strOutputFormat , $ objSettings ) ; }
11790	public function clear ( $ name = null ) { if ( ! is_null ( $ name ) ) { $ name = strtolower ( $ name ) ; if ( array_key_exists ( $ name , self :: $ clearings ) ) { $ this -> { $ name } = self :: $ clearings [ $ self :: $ clearings ] ; } } else { foreach ( self :: $ clearings as $ n => $ v ) { $ this -> { $ n } = $ v ; } } return $ this ; }
6258	public function authorizeByControllerAndAction ( $ user , Request $ request ) { $ roleField = $ this -> _config [ 'roleField' ] ; extract ( $ this -> getControllerNameAndAction ( $ request ) ) ; $ actionMap = $ this -> getActionMap ( ) ; if ( isset ( $ actionMap [ $ name ] [ '*' ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ '*' ] ) ) { return true ; } } if ( isset ( $ actionMap [ $ name ] [ $ action ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ $ action ] ) ) { return true ; } } if ( $ this -> config ( 'undefinedActionsAreAllowed' ) === true ) { return true ; } return false ; }
11752	public function open ( $ msgId , $ index ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_OPEN_COMMENT , $ params ] ) ; }
12119	private function getCustomersMap ( ) { $ customers = $ this -> daoCustDwnl -> get ( ) ; $ result = $ this -> hlpTree -> mapById ( $ customers , ECustomer :: A_CUSTOMER_REF ) ; return $ result ; }
5105	public function limit ( $ from , $ count ) : IWithLimit { return $ this -> setPart ( CmdUpdate :: PART_LIMIT , true , ( $ from ? array ( $ from , $ count ) : $ count ) ) ; }
616	public function setDefinitions ( array $ definitions ) { foreach ( $ definitions as $ class => $ definition ) { if ( is_array ( $ definition ) && count ( $ definition ) === 2 && array_values ( $ definition ) === $ definition ) { $ this -> set ( $ class , $ definition [ 0 ] , $ definition [ 1 ] ) ; continue ; } $ this -> set ( $ class , $ definition ) ; } }
3077	public function processOutput ( QtiRunnerServiceContext $ context ) { $ messages = [ ] ; $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; if ( is_array ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] ) ) { foreach ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] as $ outputChannelName => $ outputChannelClass ) { $ channel = $ this -> getChannel ( $ outputChannelName , self :: CHANNEL_TYPE_OUTPUT ) ; $ message = $ this -> processChannel ( $ channel , $ context ) ; if ( $ message !== null ) { $ messages [ ] = [ 'channel' => $ channel -> getName ( ) , 'message' => $ message , ] ; } } } return $ messages ; }
7219	public function up ( $ limit = null ) { $ applied = 0 ; $ migrations = $ this -> migrations_list ; $ limit = ( int ) $ limit ; if ( $ limit > 0 ) { $ migrations = array_slice ( $ migrations , 0 , $ limit ) ; } foreach ( $ migrations as $ migration ) { if ( $ migration [ 'applied' ] ) continue ; $ name = $ migration [ 'name' ] ; $ this -> info ( 'Loading migration #:name' , [ ':name' => $ name ] ) ; $ obj = $ this -> load_migration ( $ migration ) ; $ obj -> init ( ) ; if ( $ obj -> up ( ) === false ) { $ this -> error ( 'Migration #:name failed. Stop.' , [ ':name' => $ name ] ) ; return ; } ; DB :: begin ( ) ; try { $ obj -> safe_up ( ) ; DB :: commit ( ) ; } catch ( \ Throwable $ e ) { DB :: rollback ( ) ; } DB :: insert ( 'INSERT INTO`' . $ this -> migrate_table . '`(`name`, `date`) VALUES(:name, :date)' , [ ':name' => $ name , ':date' => time ( ) ] ) ; $ this -> info ( 'Migration up successfully' , [ ':name' => $ name ] ) ; $ applied ++ ; } if ( ! $ applied ) { $ this -> warning ( 'No new migration found' ) ; } }
8576	public function setItemChargeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemChargeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3210	function disableOAuth1AccessToken ( $ oauth1AccessToken ) { OAuth1AccessToken :: checkArg ( "oauth1AccessToken" , $ oauth1AccessToken ) ; $ response = self :: doPost ( $ oauth1AccessToken , "1/disable_access_token" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; }
364	public function renderCaption ( ) { if ( ! empty ( $ this -> caption ) ) { return Html :: tag ( 'caption' , $ this -> caption , $ this -> captionOptions ) ; } return false ; }
6893	protected function sortAssignments ( array $ assignments ) { usort ( $ assignments , function ( StockAssignmentInterface $ a1 , StockAssignmentInterface $ a2 ) { $ u1 = $ a1 -> getStockUnit ( ) ; $ u2 = $ a2 -> getStockUnit ( ) ; return $ this -> compareStockUnit ( $ u1 , $ u2 ) ; } ) ; return $ assignments ; }
2548	private function findHandlerForMessage ( $ messageName ) { $ handler = null ; if ( array_key_exists ( $ messageName , $ this -> responseHandlers ) && $ this -> responseHandlers [ $ messageName ] instanceof MessageResponseHandler ) { $ handler = $ this -> responseHandlers [ $ messageName ] ; } else { $ section = substr ( $ messageName , 0 , strpos ( $ messageName , '_' ) ) ; $ message = substr ( $ messageName , strpos ( $ messageName , '_' ) + 1 ) ; $ handlerClass = __NAMESPACE__ . '\\' . $ section . '\\Handler' . $ message ; if ( class_exists ( $ handlerClass ) ) { $ handler = new $ handlerClass ( ) ; $ this -> responseHandlers [ $ messageName ] = $ handler ; } } return $ handler ; }
1902	public function prepare ( $ strQuery ) { if ( $ strQuery == '' ) { throw new \ Exception ( 'Empty query string' ) ; } $ this -> strQuery = trim ( $ strQuery ) ; if ( strncasecmp ( $ this -> strQuery , 'INSERT' , 6 ) === 0 || strncasecmp ( $ this -> strQuery , 'UPDATE' , 6 ) === 0 ) { $ this -> strQuery = str_replace ( '%s' , '%p' , $ this -> strQuery ) ; } $ arrChunks = preg_split ( "/('[^']*')/" , $ this -> strQuery , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; foreach ( $ arrChunks as $ k => $ v ) { if ( substr ( $ v , 0 , 1 ) == "'" ) { continue ; } $ arrChunks [ $ k ] = str_replace ( '?' , '%s' , $ v ) ; } $ this -> strQuery = implode ( '' , $ arrChunks ) ; return $ this ; }
1381	protected function validateToMany ( array $ value , ? string $ field = null ) : bool { $ path = $ field ? "/data/relationships/{$field}/data" : "/data" ; $ valid = true ; foreach ( $ value as $ index => $ item ) { if ( ! $ this -> validateIdentifier ( $ item , $ path , $ index ) ) { $ valid = false ; continue ; } if ( $ this -> isNotFound ( $ item -> type , $ item -> id ) ) { $ this -> resourceDoesNotExist ( "{$path}/{$index}" ) ; $ valid = false ; } } return $ valid ; }
1152	public function selector ( $ selector ) { $ this -> selector = is_null ( $ selector ) ? $ this -> selector : $ selector ; return $ this ; }
4675	public function addString ( $ content , $ region = "main" , $ sort = 0 ) { $ view = new View ( ) ; $ view -> set ( $ content , [ ] , $ sort , "string" ) ; $ this -> views [ $ region ] [ ] = $ view ; return $ this ; }
7961	public function canResetDslamPort ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> capabilities -> canResetDslamPort ; }
9755	function a ( string $ type = '' ) : self { return mb_strlen ( $ type ) ? $ this -> expect ( $ this -> target , isType ( $ type ) ) : $ this ; }
2714	public function getCheckedValues ( ) { if ( $ this -> values === null ) { $ data = $ this -> config -> getImageOptimizationRatios ( ) ; if ( ! isset ( $ data ) ) { $ data = '' ; } $ this -> values = explode ( ',' , $ data ) ; } return $ this -> values ; }
4923	public function removeTypeFromRegion ( $ type , $ region ) { if ( array_key_exists ( $ region , $ this -> matrix ) ) { array_walk ( $ this -> matrix [ $ region ] , function ( $ value , $ idx , $ matrix ) use ( $ type , $ region ) { $ class = explode ( '\\' , $ value ) ; $ className = array_pop ( $ class ) ; if ( $ className === $ type ) { unset ( $ matrix [ $ region ] [ $ idx ] ) ; } } , $ this -> matrix ) ; } return $ this ; }
9735	public static function indexedColor ( $ pIndex , $ background = false ) { $ pIndex = ( int ) $ pIndex ; if ( self :: $ indexedColors === null ) { self :: $ indexedColors = [ 1 => 'FF000000' , 2 => 'FFFFFFFF' , 3 => 'FFFF0000' , 4 => 'FF00FF00' , 5 => 'FF0000FF' , 6 => 'FFFFFF00' , 7 => 'FFFF00FF' , 8 => 'FF00FFFF' , 9 => 'FF800000' , 10 => 'FF008000' , 11 => 'FF000080' , 12 => 'FF808000' , 13 => 'FF800080' , 14 => 'FF008080' , 15 => 'FFC0C0C0' , 16 => 'FF808080' , 17 => 'FF9999FF' , 18 => 'FF993366' , 19 => 'FFFFFFCC' , 20 => 'FFCCFFFF' , 21 => 'FF660066' , 22 => 'FFFF8080' , 23 => 'FF0066CC' , 24 => 'FFCCCCFF' , 25 => 'FF000080' , 26 => 'FFFF00FF' , 27 => 'FFFFFF00' , 28 => 'FF00FFFF' , 29 => 'FF800080' , 30 => 'FF800000' , 31 => 'FF008080' , 32 => 'FF0000FF' , 33 => 'FF00CCFF' , 34 => 'FFCCFFFF' , 35 => 'FFCCFFCC' , 36 => 'FFFFFF99' , 37 => 'FF99CCFF' , 38 => 'FFFF99CC' , 39 => 'FFCC99FF' , 40 => 'FFFFCC99' , 41 => 'FF3366FF' , 42 => 'FF33CCCC' , 43 => 'FF99CC00' , 44 => 'FFFFCC00' , 45 => 'FFFF9900' , 46 => 'FFFF6600' , 47 => 'FF666699' , 48 => 'FF969696' , 49 => 'FF003366' , 50 => 'FF339966' , 51 => 'FF003300' , 52 => 'FF333300' , 53 => 'FF993300' , 54 => 'FF993366' , 55 => 'FF333399' , 56 => 'FF333333' , ] ; } if ( isset ( self :: $ indexedColors [ $ pIndex ] ) ) { return new self ( self :: $ indexedColors [ $ pIndex ] ) ; } if ( $ background ) { return new self ( self :: COLOR_WHITE ) ; } return new self ( self :: COLOR_BLACK ) ; }
4229	protected function errorHash ( $ errorValues ) { $ errMsg = $ errorValues [ 'message' ] ; $ errMsg = \ preg_replace ( '/(\(.*?)\d+(.*?\))/' , '\1x\2' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\b([a-z]+\d+)+\b/' , 'xxx' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\b[\d.-]{4,}\b/' , 'xxx' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\s*##.+$/' , '' , $ errMsg ) ; $ hash = \ md5 ( $ errorValues [ 'file' ] . $ errorValues [ 'line' ] . $ errorValues [ 'type' ] . $ errMsg ) ; return $ hash ; }
4971	public static function convert ( ContentItemInterface $ from , ContentItemInterface $ to ) { $ reflectionFrom = new \ ReflectionClass ( $ from ) ; $ reflectionTo = new \ ReflectionClass ( $ to ) ; foreach ( $ reflectionFrom -> getProperties ( ) as $ property ) { $ property -> setAccessible ( true ) ; $ method = 'set' . ucfirst ( $ property -> getName ( ) ) ; if ( $ reflectionTo -> hasMethod ( $ method ) ) { $ to -> $ method ( $ property -> getValue ( $ from ) ) ; } } return $ to ; }
124	protected function getErrorMessage ( $ retval , $ file ) { switch ( $ retval ) { case ZipArchive :: ER_EXISTS : return sprintf ( "File '%s' already exists." , $ file ) ; case ZipArchive :: ER_INCONS : return sprintf ( "Zip archive '%s' is inconsistent." , $ file ) ; case ZipArchive :: ER_INVAL : return sprintf ( "Invalid argument (%s)" , $ file ) ; case ZipArchive :: ER_MEMORY : return sprintf ( "Malloc failure (%s)" , $ file ) ; case ZipArchive :: ER_NOENT : return sprintf ( "No such zip file: '%s'" , $ file ) ; case ZipArchive :: ER_NOZIP : return sprintf ( "'%s' is not a zip archive." , $ file ) ; case ZipArchive :: ER_OPEN : return sprintf ( "Can't open zip file: %s" , $ file ) ; case ZipArchive :: ER_READ : return sprintf ( "Zip read error (%s)" , $ file ) ; case ZipArchive :: ER_SEEK : return sprintf ( "Zip seek error (%s)" , $ file ) ; default : return sprintf ( "'%s' is not a valid zip archive, got error code: %s" , $ file , $ retval ) ; } }
4509	public function getContext ( ) : string { $ tenant = $ this -> parameterService -> get ( 'ds_tenant.tenant.default' ) ; $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ request -> request -> has ( 'tenant' ) && $ request -> request -> get ( 'tenant' ) ) { $ tenant = $ request -> request -> get ( 'tenant' ) ; } if ( $ request -> query -> has ( 'tenant' ) && $ request -> query -> get ( 'tenant' ) ) { $ tenant = $ request -> query -> get ( 'tenant' ) ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( $ token ) { $ user = $ token -> getUser ( ) ; if ( $ user instanceof User ) { $ tenant = $ user -> getTenant ( ) ; } } return $ tenant ; }
8592	public function setFilterOptions ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FilterOptions' ] [ 'FieldValue' ] = $ value ; return $ this ; }
560	protected function buildOperatorCondition ( $ operator , $ condition , $ attribute ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } return [ $ operator , $ attribute , $ this -> filterAttributeValue ( $ attribute , $ condition ) ] ; }
6959	protected function updateExpiresAt ( CartInterface $ cart ) { $ date = new \ DateTime ( ) ; $ date -> modify ( $ this -> expirationDelay ) ; $ cart -> setExpiresAt ( $ date ) ; return true ; }
10357	protected static function highlightCode ( string $ file , int $ line , int $ padding = 6 ) : array { if ( ! is_readable ( $ file ) ) { return false ; } $ handle = fopen ( $ file , 'r' ) ; $ lines = array ( ) ; $ currentLine = 0 ; while ( ! feof ( $ handle ) ) { $ currentLine ++ ; $ temp = fgets ( $ handle ) ; if ( $ currentLine > $ line + $ padding ) { break ; } if ( $ currentLine >= ( $ line - $ padding ) && $ currentLine <= ( $ line + $ padding ) ) { $ lines [ ] = array ( 'number' => str_pad ( $ currentLine , 4 , ' ' , STR_PAD_LEFT ) , 'highlighted' => ( $ currentLine === $ line ) , 'code' => ErrorHandler :: highlightString ( $ temp ) , ) ; } } fclose ( $ handle ) ; return $ lines ; }
11905	public function getType ( ) { if ( is_null ( $ this -> _type ) ) { $ this -> _type = FieldTypeDetector :: detect ( $ this -> modelField ) ; } return $ this -> _type ; }
11393	public static function activateError ( $ iLevel ) { if ( self :: $ _bFirstActivation === true ) { self :: _setFileNameInErrorFile ( ) ; self :: $ _bFirstActivation = false ; } self :: _initLogFile ( ) ; self :: $ _bActivateError = true ; error_reporting ( $ iLevel ) ; set_error_handler ( function ( $ iErrNo , $ sErrStr , $ sErrFile , $ iErrLine ) { $ aContext = array ( 'file' => $ sErrFile , 'line' => $ iErrLine ) ; $ sType = self :: getTranslateErrorCode ( $ iErrNo ) ; self :: getInstance ( ) -> $ sType ( $ sErrStr , $ aContext ) ; return true ; } , $ iLevel ) ; register_shutdown_function ( function ( ) { if ( null !== ( $ aLastError = error_get_last ( ) ) ) { $ aContext = array ( 'file' => $ aLastError [ 'file' ] , 'line' => $ aLastError [ 'line' ] ) ; $ sType = self :: getTranslateErrorCode ( $ aLastError [ 'type' ] ) ; self :: getInstance ( ) -> $ sType ( $ aLastError [ 'message' ] , $ aContext ) ; } } ) ; }
4091	public function createPayload ( ) { $ payloads = array ( ) ; foreach ( $ this -> operations as $ operation ) { foreach ( $ operation as $ partial ) { $ payloads [ ] = json_encode ( $ partial ) ; } } return join ( "\n" , $ payloads ) . "\n" ; }
4317	private static function getMethodDefaultArgs ( $ methodName ) { $ defaultArgs = array ( ) ; if ( isset ( self :: $ methodDefaultArgs [ $ methodName ] ) ) { $ defaultArgs = self :: $ methodDefaultArgs [ $ methodName ] ; } elseif ( \ method_exists ( self :: $ instance , $ methodName ) ) { $ reflectionMethod = new ReflectionMethod ( self :: $ instance , $ methodName ) ; $ params = $ reflectionMethod -> getParameters ( ) ; foreach ( $ params as $ reflectionParameter ) { $ defaultArgs [ ] = $ reflectionParameter -> isOptional ( ) ? $ reflectionParameter -> getDefaultValue ( ) : null ; } self :: $ methodDefaultArgs [ $ methodName ] = $ defaultArgs ; } return $ defaultArgs ; }
12965	public function getIcon ( ) { if ( is_null ( $ this -> _icon ) && isset ( $ this -> object ) ) { $ this -> _icon = [ 'class' => $ this -> object -> objectType -> icon , 'title' => $ this -> objectTypeDescriptor ] ; } return $ this -> _icon ; }
8784	protected function log ( $ level , $ message ) { if ( is_array ( $ message ) || is_object ( $ message ) ) { $ message = print_r ( $ message , true ) ; } $ text = '[' . date ( $ this -> timeFormat , time ( ) ) . '] - [' . strtoupper ( $ level ) . '] - [' . http ( ) -> getClientIP ( ) . '] . $ message ; $ this -> save ( $ text ) ; }
2197	public function onAuthenticationSuccess ( Request $ request , TokenInterface $ token ) : RedirectResponse { $ this -> user = $ token -> getUser ( ) ; if ( ! $ this -> user instanceof User ) { return $ this -> getRedirectResponse ( $ request ) ; } $ this -> user -> lastLogin = $ this -> user -> currentLogin ; $ this -> user -> currentLogin = time ( ) ; $ this -> user -> save ( ) ; if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has logged in' , $ this -> user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ this -> user -> username ) ] ) ; } $ this -> triggerPostLoginHook ( ) ; return $ this -> getRedirectResponse ( $ request ) ; }
9796	public function hasHyperlink ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot check for hyperlink when cell is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> hyperlinkExists ( $ this -> getCoordinate ( ) ) ; }
6030	public function setChildMedias ( array $ childMedias ) { $ this -> childMedias = [ ] ; foreach ( $ childMedias as $ item ) { $ this -> addself ( $ item ) ; } return $ this ; }
53	public function setDownloader ( $ type , DownloaderInterface $ downloader ) { $ type = strtolower ( $ type ) ; $ this -> downloaders [ $ type ] = $ downloader ; return $ this ; }
8909	public function serialize_row ( $ row ) { foreach ( $ this -> callback_parameters as $ column ) { $ row [ $ column ] = serialize ( $ row [ $ column ] ) ; } return $ row ; }
6946	private function getRegularDueQueryBuilder ( ) { $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ ex = $ qb -> expr ( ) ; return $ qb -> where ( $ ex -> andX ( $ ex -> eq ( 'o.sample' , ':not_sample' ) , $ ex -> lt ( 'o.paidTotal' , 'o.grandTotal' ) , $ ex -> notIn ( 'o.invoiceState' , ':canceled_or_refunded' ) , $ ex -> eq ( 'o.shipmentState' , ':shipped' ) , $ ex -> isNull ( 'o.paymentTerm' ) ) ) -> addOrderBy ( 'o.createdAt' , 'ASC' ) -> setParameter ( 'not_sample' , false ) -> setParameter ( 'shipped' , ShipmentStates :: STATE_COMPLETED ) -> setParameter ( 'canceled_or_refunded' , [ InvoiceStates :: STATE_CANCELED , InvoiceStates :: STATE_CREDITED ] ) ; }
5055	protected function getEntityClassName ( $ name ) { $ repositoryName = str_replace ( 'Repository/' , '' , $ name ) ; $ nameParts = explode ( '/' , $ repositoryName ) ; $ namespace = $ nameParts [ 0 ] ; $ entity = isset ( $ nameParts [ 1 ] ) ? $ nameParts [ 1 ] : substr ( $ namespace , 0 , - 1 ) ; $ class = "\\$namespace\\Entity\\$entity" ; return $ class ; }
10646	public function execute ( ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ this -> getURI ( ) ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ ch , CURLOPT_POST , true ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ this -> data ) ; $ response = curl_exec ( $ ch ) ; $ result = json_decode ( $ response ) ; curl_close ( $ ch ) ; if ( empty ( $ result ) || ! $ result -> success ) { throw new \ Exception ( "Pipedrive API error!" ) ; } return $ result ; }
4143	public function getHeaders ( $ key = null ) { if ( $ key === null ) { return $ this -> headers ; } if ( isset ( $ this -> headers [ $ key ] ) ) { return $ this -> headers [ $ key ] ; } return false ; }
10787	public function onlineHelpAction ( Request $ request ) { $ template = $ this -> searchService -> getOnlineHelp ( $ request -> getLocale ( ) , $ this -> getDefaultLocale ( ) ) ; return $ this -> render ( $ template ? : 'StingerSoftEntitySearchBundle:Help:no_help.html.twig' ) ; }
4246	private function logRequest ( ) { $ this -> logRequestHeaders ( ) ; if ( $ this -> debug -> getCfg ( 'logEnvInfo.cookies' ) ) { $ cookieVals = $ _COOKIE ; \ ksort ( $ cookieVals , SORT_NATURAL ) ; $ this -> debug -> log ( '$_COOKIE' , $ cookieVals ) ; } $ noBody = ! isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) || \ in_array ( $ _SERVER [ 'REQUEST_METHOD' ] , array ( 'CONNECT' , 'GET' , 'HEAD' , 'OPTIONS' , 'TRACE' ) ) ; if ( $ this -> debug -> getCfg ( 'logEnvInfo.post' ) && ! $ noBody ) { if ( $ _POST ) { $ this -> debug -> log ( '$_POST' , $ _POST ) ; } else { $ input = \ file_get_contents ( 'php://input' ) ; if ( $ input ) { $ this -> debug -> log ( 'php://input' , $ input ) ; } elseif ( isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) && empty ( $ _FILES ) ) { $ this -> debug -> warn ( $ _SERVER [ 'REQUEST_METHOD' ] . ' request with no body' ) ; } } if ( ! empty ( $ _FILES ) ) { $ this -> debug -> log ( '$_FILES' , $ _FILES ) ; } } }
766	public function setIdentity ( $ identity ) { if ( $ identity instanceof IdentityInterface ) { $ this -> _identity = $ identity ; } elseif ( $ identity === null ) { $ this -> _identity = null ; } else { throw new InvalidValueException ( 'The identity object must implement IdentityInterface.' ) ; } $ this -> _access = [ ] ; }
4382	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ str = '' ; $ str .= $ this -> processAlerts ( ) ; $ str .= $ this -> processSummary ( ) ; $ str .= $ this -> processLog ( ) ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
10237	public static function getInstance ( Spreadsheet $ spreadsheet = null ) { if ( $ spreadsheet !== null ) { $ instance = $ spreadsheet -> getCalculationEngine ( ) ; if ( isset ( $ instance ) ) { return $ instance ; } } if ( ! isset ( self :: $ instance ) || ( self :: $ instance === null ) ) { self :: $ instance = new self ( ) ; } return self :: $ instance ; }
2269	public function lockTables ( $ arrTables ) { $ arrLocks = array ( ) ; foreach ( $ arrTables as $ table => $ mode ) { $ arrLocks [ ] = $ this -> resConnection -> quoteIdentifier ( $ table ) . ' ' . $ mode ; } $ this -> resConnection -> exec ( 'LOCK TABLES ' . implode ( ', ' , $ arrLocks ) . ';' ) ; }
12468	public function getStream ( $ mediaId ) { $ response = $ this -> getHttp ( ) -> get ( self :: API_GET , [ 'media_id' => $ mediaId ] ) ; $ response -> getBody ( ) -> rewind ( ) ; $ body = $ response -> getBody ( ) -> getContents ( ) ; $ json = json_decode ( $ body , true ) ; if ( JSON_ERROR_NONE === json_last_error ( ) ) { $ this -> checkAndThrow ( $ json ) ; } return $ body ; }
949	public function sanitizeShopDomain ( $ domain ) { if ( empty ( $ domain ) ) { return ; } $ configEndDomain = Config :: get ( 'shopify-app.myshopify_domain' ) ; $ domain = strtolower ( preg_replace ( '/https?:\/\//i' , '' , trim ( $ domain ) ) ) ; if ( strpos ( $ domain , $ configEndDomain ) === false && strpos ( $ domain , '.' ) === false ) { $ domain .= ".{$configEndDomain}" ; } return parse_url ( "http://{$domain}" , PHP_URL_HOST ) ; }
4568	public function getParent ( $ permission ) { $ permission = $ this -> cast ( $ permission ) ; foreach ( $ this -> toArray ( ) as $ element ) { if ( Permission :: ENTITY === $ element -> getType ( ) && 0 === strpos ( $ permission -> getValue ( ) , $ element -> getValue ( ) ) ) { return $ element ; } } }
12577	public function previewNewsByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_NEWS , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
9415	public function precision ( $ n ) { if ( ! is_numeric ( $ n ) || $ n < 0 ) { throw new \ InvalidArgumentException ( 'Precision must be positive number' ) ; } $ this -> int_precision = ( integer ) $ n ; }
3255	public function scopeWhereUser ( $ query , $ userId ) { return $ query -> join ( Config :: get ( 'shop.order_table' ) , Config :: get ( 'shop.order_table' ) . '.id' , '=' , Config :: get ( 'shop.transaction_table' ) . '.order_id' ) -> where ( Config :: get ( 'shop.order_table' ) . '.user_id' , $ userId ) ; }
9908	public function setPosition ( $ position ) { if ( ! in_array ( $ position , self :: $ positionXLref ) ) { return false ; } $ this -> position = $ position ; return true ; }
93	public function filter ( $ relativePath , $ exclude ) { foreach ( $ this -> excludePatterns as $ patternData ) { list ( $ pattern , $ negate , $ stripLeadingSlash ) = $ patternData ; if ( $ stripLeadingSlash ) { $ path = substr ( $ relativePath , 1 ) ; } else { $ path = $ relativePath ; } if ( preg_match ( $ pattern , $ path ) ) { $ exclude = ! $ negate ; } } return $ exclude ; }
3488	private static function tryResolveBySpomkyLabsJoseSystem ( ) : ? SpomkyLabsJoseSignatureGenerator { $ requiredClasses = [ JWKFactory :: class , JWSFactory :: class , ] ; foreach ( $ requiredClasses as $ requiredClass ) { if ( ! class_exists ( $ requiredClass ) ) { return null ; } } return new SpomkyLabsJoseSignatureGenerator ( ) ; }
1866	public function addSenderNamePlaceholder ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> pid ) { $ objChannel = $ this -> Database -> prepare ( "SELECT senderName FROM tl_newsletter_channel WHERE id=?" ) -> execute ( $ dc -> activeRecord -> pid ) ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'placeholder' ] = $ objChannel -> senderName ; } return $ varValue ; }
5521	public static function generate ( $ class , $ mock_class = false , $ methods = false ) { $ generator = new MockGenerator ( $ class , $ mock_class ) ; return $ generator -> generateSubclass ( $ methods ) ; }
12655	public function addTextContainer ( $ name , $ content , $ language ) { $ allTexts = $ this -> getPageTexts ( $ language ) ; if ( isset ( $ allTexts [ $ name ] ) ) { throw new \ Exception ( "Text container name already used." ) ; } $ this -> contents [ $ language ] [ $ name ] = array ( 'id' => $ name , 'name' => $ name , 'content' => $ content , 'outdated' => false ) ; $ this -> writeTextsToFile ( $ language ) ; if ( $ language === $ this -> baseLang ) { $ this -> setExtraLanguagesOutdated ( $ name , $ content ) ; } return $ this -> contents [ $ language ] [ $ name ] ; }
9732	public function writeFont ( ) { $ font_outline = 0 ; $ font_shadow = 0 ; $ icv = $ this -> colorIndex ; if ( $ this -> font -> getSuperscript ( ) ) { $ sss = 1 ; } elseif ( $ this -> font -> getSubscript ( ) ) { $ sss = 2 ; } else { $ sss = 0 ; } $ bFamily = 0 ; $ bCharSet = \ PhpOffice \ PhpSpreadsheet \ Shared \ Font :: getCharsetFromFontName ( $ this -> font -> getName ( ) ) ; $ record = 0x31 ; $ reserved = 0x00 ; $ grbit = 0x00 ; if ( $ this -> font -> getItalic ( ) ) { $ grbit |= 0x02 ; } if ( $ this -> font -> getStrikethrough ( ) ) { $ grbit |= 0x08 ; } if ( $ font_outline ) { $ grbit |= 0x10 ; } if ( $ font_shadow ) { $ grbit |= 0x20 ; } $ data = pack ( 'vvvvvCCCC' , $ this -> font -> getSize ( ) * 20 , $ grbit , $ icv , self :: mapBold ( $ this -> font -> getBold ( ) ) , $ sss , self :: mapUnderline ( $ this -> font -> getUnderline ( ) ) , $ bFamily , $ bCharSet , $ reserved ) ; $ data .= StringHelper :: UTF8toBIFF8UnicodeShort ( $ this -> font -> getName ( ) ) ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
3703	protected function getProperty ( $ name , $ legend ) { foreach ( $ legend -> getProperties ( ) as $ property ) { if ( $ property -> getName ( ) === $ name ) { return $ property ; } } $ property = new Property ( $ name ) ; $ legend -> addProperty ( $ property ) ; return $ property ; }
12732	public function handle ( $ signal ) { if ( isset ( $ this -> _bySignal [ $ signal ] ) ) { foreach ( $ this -> _bySignal [ $ signal ] as $ reg ) { $ reg -> interrupt = $ signal ; } } else { return SIG_DFL ; } }
7809	public static function toDebugReport ( ) { $ report = 'PHP SDK (zipMoney) Debug Report:' . PHP_EOL ; $ report .= ' OS: ' . php_uname ( ) . PHP_EOL ; $ report .= ' PHP Version: ' . phpversion ( ) . PHP_EOL ; $ report .= ' OpenAPI Spec Version: 2017-03-01' . PHP_EOL ; $ report .= ' Temp Folder Path: ' . self :: getDefaultConfiguration ( ) -> getTempFolderPath ( ) . PHP_EOL ; return $ report ; }
8603	private function _convertDeregisterDestination ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'DeregisterDestination' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationDeregisterDestinationInput = $ request -> getDestination ( ) ; foreach ( $ DestinationDeregisterDestinationInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
7841	public function removeNumber ( int $ id , string $ number ) : ? array { $ response = Request :: delete ( $ this -> baseUrl . sprintf ( 'contact/%d/phone-number/%s' , $ id , $ number ) ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
973	public function creating ( $ shop ) { if ( ! isset ( $ shop -> namespace ) ) { $ shop -> namespace = Config :: get ( 'shopify-app.namespace' ) ; } if ( Config :: get ( 'shopify-app.billing_freemium_enabled' ) === true && ! isset ( $ shop -> freemium ) ) { $ shop -> freemium = true ; } }
7499	protected function renderStringTemplate ( $ template , $ parameters = array ( ) ) { $ template = $ this -> environment -> createTemplate ( $ template ) ; return $ template -> render ( $ parameters ) ; }
1536	protected function fillRelationships ( $ record , Collection $ relationships , EncodingParametersInterface $ parameters ) { $ relationships -> filter ( function ( $ value , $ field ) use ( $ record ) { return $ this -> isFillableRelation ( $ field , $ record ) ; } ) -> each ( function ( $ value , $ field ) use ( $ record , $ parameters ) { $ this -> fillRelationship ( $ record , $ field , $ value , $ parameters ) ; } ) ; }
308	protected function createRule ( $ pattern , $ prefix , $ action ) { $ verbs = 'GET|HEAD|POST|PUT|PATCH|DELETE|OPTIONS' ; if ( preg_match ( "/^((?:($verbs),)*($verbs))(?:\\s+(.*))?$/" , $ pattern , $ matches ) ) { $ verbs = explode ( ',' , $ matches [ 1 ] ) ; $ pattern = isset ( $ matches [ 4 ] ) ? $ matches [ 4 ] : '' ; } else { $ verbs = [ ] ; } $ config = $ this -> ruleConfig ; $ config [ 'verb' ] = $ verbs ; $ config [ 'pattern' ] = rtrim ( $ prefix . '/' . strtr ( $ pattern , $ this -> tokens ) , '/' ) ; $ config [ 'route' ] = $ action ; if ( ! empty ( $ verbs ) && ! in_array ( 'GET' , $ verbs ) ) { $ config [ 'mode' ] = WebUrlRule :: PARSING_ONLY ; } $ config [ 'suffix' ] = $ this -> suffix ; return Yii :: createObject ( $ config ) ; }
6642	public static function encodeId ( $ id , $ salt , $ hashLength = self :: MIN_HASH_LENGTH ) { $ hashIds = new Hashids ( $ salt , $ hashLength ) ; return $ hashIds -> encode ( $ id ) ; }
12266	public function renderCmsBlocks ( array $ blocks , $ username , array $ options = array ( ) ) { $ tmp = array ( ) ; foreach ( $ blocks as $ block ) { $ tmp [ ] = $ this -> renderCmsBlock ( $ block , $ username , $ options ) ; } return implode ( "\n" , $ tmp ) ; }
7730	public function api ( $ url , $ body = null , $ type = self :: TYPE_POST ) { $ body [ 'access_token' ] = $ this -> accessToken ; $ this -> setBody ( $ body ) ; $ headers = [ 'Content-Type: application/json' , ] ; if ( $ type == self :: TYPE_GET ) { $ url .= '?' . http_build_query ( $ body ) ; } $ curl = curl_init ( $ this -> url . $ url ) ; if ( $ type == self :: TYPE_POST ) { curl_setopt ( $ curl , CURLOPT_POST , 1 ) ; curl_setopt ( $ curl , CURLOPT_POSTFIELDS , http_build_query ( $ body ) ) ; } curl_setopt ( $ curl , CURLOPT_HTTPHEADER , $ headers ) ; curl_setopt ( $ curl , CURLOPT_SSL_VERIFYPEER , false ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; $ response = curl_exec ( $ curl ) ; curl_close ( $ curl ) ; return json_decode ( $ response , true ) ; }
8684	public static function fromRecursive ( $ iterable ) { $ arr = static :: from ( $ iterable ) ; foreach ( $ arr as $ key => $ value ) { if ( $ value instanceof \ stdClass || \ is_iterable ( $ value ) ) { $ value = static :: fromRecursive ( $ value ) ; } $ arr [ $ key ] = $ value ; } return $ arr ; }
8777	public function assets ( $ data = null , $ secure = false ) { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . ASSETS_FOLDER . '/' . $ data : $ this -> url . '/' . ASSETS_FOLDER . '/' ; return $ this -> getUrl ( $ data , $ secure ) ; }
5445	protected function addSkipping ( ) { $ this -> mapHandler ( 'css' , 'ignore' ) ; $ this -> addEntryPattern ( '<style' , 'text' , 'css' ) ; $ this -> addExitPattern ( '</style>' , 'css' ) ; $ this -> mapHandler ( 'js' , 'ignore' ) ; $ this -> addEntryPattern ( '<script' , 'text' , 'js' ) ; $ this -> addExitPattern ( '</script>' , 'js' ) ; $ this -> mapHandler ( 'comment' , 'ignore' ) ; $ this -> addEntryPattern ( '<!--' , 'text' , 'comment' ) ; $ this -> addExitPattern ( ' , 'comment' ) ; }
1092	public function reload ( ) { if ( $ this -> exists || ( $ this -> areSoftDeletesEnabled ( ) && $ this -> trashed ( ) ) ) { $ fresh = $ this -> getFreshInstance ( ) ; if ( is_null ( $ fresh ) ) throw with ( new ModelNotFoundException ) -> setModel ( get_called_class ( ) ) ; $ this -> setRawAttributes ( $ fresh -> getAttributes ( ) , true ) ; $ this -> setRelations ( $ fresh -> getRelations ( ) ) ; $ this -> exists = $ fresh -> exists ; } else { $ this -> attributes = $ this -> original ; } return $ this ; }
10694	protected function startOrRestart ( ) { if ( session_status ( ) == PHP_SESSION_ACTIVE ) return ; if ( $ this -> SessionDir ) { if ( ! file_exists ( $ this -> SessionDir ) ) { mkdir ( $ this -> SessionDir , 0777 , true ) ; } session_save_path ( $ this -> SessionDir ) ; } session_start ( ) ; $ FingerPrint = "" ; if ( $ this -> IpAddress ) { if ( ! $ this -> IpAddress -> isValid ( ) ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: Invalid IP " . $ this -> IpAddress -> getValue ( ) . " detected" , 403 ) ; } else $ FingerPrint = $ this -> IpAddress -> getValue ( ) ; } if ( $ this -> Browser ) { if ( ! $ this -> Browser -> isKnownBrowser ( ) ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: Invalid Browser " . $ this -> Browser -> getSignature ( ) . " detected." , 403 ) ; } else $ FingerPrint .= $ this -> Browser -> getSignature ( ) ; } $ currFp = md5 ( $ FingerPrint ) ; $ prevFp = isset ( $ _SESSION [ "FingerPrint" ] ) ? $ _SESSION [ "FingerPrint" ] : null ; if ( $ prevFp ) { if ( $ prevFp != $ currFp ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: IP changed. Current is $currFp, previous was: $prevFp" , Interfaces \ HttpResponder :: EXIT_CODE_UNAUTHORIZED ) ; } } $ currTime = time ( ) ; $ prevTime = isset ( $ _SESSION [ "LastSessionStart" ] ) ? $ _SESSION [ "LastSessionStart" ] : null ; $ timeOutSecs = isset ( $ _SESSION [ "TimeOutSecs" ] ) ? $ _SESSION [ "TimeOutSecs" ] : null ; if ( $ prevTime && $ timeOutSecs ) { if ( $ prevTime + $ timeOutSecs < $ currTime ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Session timeout" , Interfaces \ HttpResponder :: EXIT_CODE_UNAUTHORIZED ) ; } } $ _SESSION [ "FingerPrint" ] = $ currFp ; $ _SESSION [ "LastSessionStart" ] = $ currTime ; }
10314	function getClicksCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ formatFilter = null , $ linkIdFilter = null , $ linkUrlFilter = null , $ linkTagFilter = null , $ socialNetworkFilter = null , $ deviceTypeFilter = null , $ excludeAnonymousClicks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; if ( isset ( $ formatFilter ) ) $ params [ 'format' ] = $ formatFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_id" , $ linkIdFilter ) ; if ( isset ( $ linkUrlFilter ) ) $ params [ 'link_url' ] = $ linkUrlFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_tag" , $ linkTagFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "social_network" , $ socialNetworkFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "device_type" , $ deviceTypeFilter ) ; return $ this -> get ( 'reports/clicks/count' , $ params ) ; }
11787	public static function getAgeByDate ( string $ sBirthday ) : int { list ( $ iYear , $ iMonth , $ iDay ) = preg_split ( '/[-.]/' , $ sBirthday ) ; $ aToday = array ( ) ; $ aToday [ 'mois' ] = date ( 'n' ) ; $ aToday [ 'jour' ] = date ( 'j' ) ; $ aToday [ 'annee' ] = date ( 'Y' ) ; $ iYears = $ aToday [ 'annee' ] - $ iYear ; if ( $ aToday [ 'mois' ] <= $ iMonth ) { if ( $ iMonth == $ aToday [ 'mois' ] ) { if ( $ iDay > $ aToday [ 'jour' ] ) { $ iYears -- ; } } else { $ iYears -- ; } } return $ iYears ; }
4953	public function call ( $ method , $ args = [ ] , $ expect = self :: EXPECT_SELF ) { if ( ! is_array ( $ args ) ) { $ expect = $ args ; $ args = [ ] ; } if ( ! $ this -> helper ) { return $ this -> expected ( $ expect ) ; } return call_user_func_array ( [ $ this -> helper , $ method ] , $ args ) ; }
202	private function queryValueExists ( $ query , $ value ) { if ( is_array ( $ value ) ) { return $ query -> count ( "DISTINCT [[$this->targetAttribute]]" ) == count ( $ value ) ; } return $ query -> exists ( ) ; }
3300	public function post ( $ url , $ params = [ ] ) { $ key = is_array ( $ params ) ? 'form_params' : 'body' ; return $ this -> request ( 'POST' , $ url , [ $ key => $ params ] ) ; }
9344	public function addCol ( $ arr_col ) { if ( isset ( $ this -> arr [ 0 ] ) && ( count ( $ this -> arr [ 0 ] ) == $ this -> size -> cols ) ) { throw new \ OutOfRangeException ( sprintf ( 'You cannot add another column! Max number of columns is %d' , $ this -> size -> cols ) ) ; } if ( count ( $ arr_col ) != $ this -> size -> rows ) { throw new \ InvalidArgumentException ( 'New column must have same amout of rows than previous columns.' ) ; } $ arr_col = array_values ( $ arr_col ) ; foreach ( $ arr_col as $ k => $ v ) { $ this -> arr [ $ k ] [ ] = $ arr_col [ $ k ] ; } return $ this ; }
5982	protected function getClient ( ) { if ( ! ( $ this -> client instanceof Client ) ) { $ handlerStack = HandlerStack :: create ( ) ; $ handlerStack = $ this -> withOAuth2MiddleWare ( $ handlerStack ) ; $ this -> client = new Client ( [ 'handler' => $ handlerStack , 'auth' => 'oauth2' , 'base_uri' => $ this -> basepath , 'headers' => [ 'Accept' => 'application/json' , 'Content-type' => 'application/json' , 'User-Agent' => 'qbank3api-phpwrapper/2 (qbankapi: 1; swagger: 1.1)' , ] , 'verify' => $ this -> verifyCertificates , ] ) ; $ this -> logger -> debug ( 'Guzzle client instantiated.' , [ 'basepath' => $ this -> basepath ] ) ; } return $ this -> client ; }
12297	public function getRules ( array $ fields = [ ] ) { $ default_rules = $ this -> model -> getRules ( ) ; if ( count ( $ fields ) < 1 ) { return $ default_rules ; } foreach ( $ fields as $ field => $ rule ) { if ( is_int ( $ field ) ) { $ rules [ $ rule ] = $ default_rules [ $ rule ] ; continue ; } if ( ! key_exists ( $ field , $ default_rules ) ) { continue ; } $ default_rules [ $ field ] .= '|' . $ rule ; } $ rules = [ ] ; $ transformation = $ this -> model -> getTransformation ( ) ; foreach ( $ transformation as $ original => $ transformed ) { $ rules [ $ transformed ] = $ default_rules [ $ original ] ; } foreach ( $ fields as $ field => $ rule ) { if ( ! key_exists ( $ field , $ rules ) ) { continue ; } $ rules [ $ field ] .= '|' . $ rule ; } return $ rules ; }
9478	protected function getCalendarDayDownloads ( $ limit = 30 ) { $ arrCalendarDayDownloads = array ( ) ; $ CalendarDays = date ( 'Y-m-d' , mktime ( 0 , 0 , 0 , date ( "m" ) , date ( "d" ) - $ limit , date ( "Y" ) ) ) ; $ objCalendarDayDownloads = \ Database :: getInstance ( ) -> prepare ( "SELECT dl.`id` , FROM_UNIXTIME(det.`tstamp`,GET_FORMAT(DATE,'ISO')) as datum , count(dl.`filename`) as downloads , dl.`filename` FROM `tl_dlstats` dl INNER JOIN `tl_dlstatdets` det on dl.id = det.pid WHERE FROM_UNIXTIME(det.`tstamp`,GET_FORMAT(DATE,'ISO')) >=? GROUP BY dl.`id`, datum ORDER BY datum DESC, `filename`" ) -> execute ( $ CalendarDays ) ; while ( $ objCalendarDayDownloads -> next ( ) ) { $ viewDate = $ this -> parseDate ( $ GLOBALS [ 'TL_CONFIG' ] [ 'dateFormat' ] , strtotime ( $ objCalendarDayDownloads -> datum ) ) ; $ c4d = $ this -> check4details ( $ objCalendarDayDownloads -> id ) ; $ arrCalendarDayDownloads [ ] = array ( $ viewDate , $ objCalendarDayDownloads -> filename , $ this -> getFormattedNumber ( $ objCalendarDayDownloads -> downloads , 0 ) , $ objCalendarDayDownloads -> id , $ c4d , $ objCalendarDayDownloads -> downloads , strtotime ( $ objCalendarDayDownloads -> datum ) ) ; } return $ arrCalendarDayDownloads ; }
8871	public function on ( $ eventName , callable $ callable ) { \ Assert \ that ( $ eventName ) -> string ( ) -> notEmpty ( ) ; $ this -> eventDispatcher -> addListener ( $ eventName , $ callable ) ; return $ this ; }
11504	public function setSlots ( $ first , $ last , $ connection ) { if ( ! static :: isValidRange ( $ first , $ last ) ) { throw new \ OutOfBoundsException ( "Invalid slot range $first-$last for `$connection`" ) ; } $ this -> slots += array_fill ( $ first , $ last - $ first + 1 , ( string ) $ connection ) ; }
7827	public function getSpacedPipe ( $ pipe , $ arrow , $ method ) { $ left = $ this -> getSpacesByWord ( $ pipe ) ; $ arrow = $ this -> addSpacesToArrow ( $ arrow ) ; $ right = $ this -> getSpacesByWord ( $ method ) ; return $ left . $ pipe . $ arrow . $ method . $ right ; }
3221	function searchFileNames ( $ basePath , $ query , $ limit = null , $ includeDeleted = false ) { Path :: checkArg ( "basePath" , $ basePath ) ; Checker :: argStringNonEmpty ( "query" , $ query ) ; Checker :: argNatOrNull ( "limit" , $ limit ) ; Checker :: argBool ( "includeDeleted" , $ includeDeleted ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/search" , $ basePath ) , array ( "query" => $ query , "file_limit" => $ limit , "include_deleted" => $ includeDeleted , ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
2682	public function getServiceDetails ( ) { $ url = $ this -> _getApiServiceUri ( ) . 'details' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
11063	public function getRealEncoding ( $ encoding ) { if ( static :: isEncodingSupported ( $ encoding ) === false ) { throw new \ Exception ( 'Encoding is not supported: "' . $ encoding . '"' ) ; } return static :: supportedEncodings ( ) [ strtolower ( $ encoding ) ] ; }
10974	public function saveLocation ( $ runValidation = true , $ attributeNames = null ) { $ location = $ this -> location ; if ( $ location === null ) { $ location = new Location ( ) ; } $ location -> country_id = $ this -> country_id ; $ location -> region_id = $ this -> region_id ; $ location -> city_id = $ this -> city_id ; $ location -> state_id = $ this -> state_id ; $ location -> address = $ this -> address ; $ location -> postal_code = $ this -> postal_code ; $ location -> latitude = $ this -> latitude ; $ location -> longitude = $ this -> longitude ; if ( is_array ( $ attributeNames ) ) { $ attributesNames = array_intersect ( [ 'country_id' , 'region_id' , 'city_id' , 'state_id' , 'address' , 'postal_code' , 'latitude' , 'longitude' ] , $ attributesNames ) ; } if ( empty ( $ attributeNames ) ) { $ attributeNames = null ; } if ( $ location -> save ( $ runValidation , $ attributeNames ) === false ) { $ this -> addErrors ( $ location -> getErrors ( ) ) ; return false ; } $ this -> location_id = $ location -> id ; return true ; }
9536	private function prefixExists ( $ parameter ) { $ prefixExists = false ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { $ prefixExists = true ; break ; } } return $ prefixExists ; }
3435	public function substituteGroup ( $ old , $ new ) { $ groups = $ this -> getGroups ( ) ; if ( ( $ key = array_search ( $ old , $ groups ) ) !== false ) { unset ( $ groups [ $ key ] ) ; } if ( ! in_array ( $ new , $ groups ) ) { $ groups [ ] = $ new ; } $ this -> fields [ 'GROUP_ID' ] = $ groups ; }
8690	protected function validateElementValues ( ) { foreach ( self :: $ mandatoryFields as $ field ) { if ( array_key_exists ( $ field , $ this -> attributes ) ) { $ value = ( int ) $ this -> attributes [ $ field ] ; if ( $ value < 0 ) { throw new \ SVGCreator \ SVGException ( "The " . $ field . " value is lesser than 0, in element " . self :: TYPE , 1 ) ; } } } }
11116	public function drop ( ) : void { $ dropped = $ this -> repository -> drop ( ) ; if ( count ( $ dropped ) === 0 ) { return ; } $ this -> notify -> note ( '' ) ; foreach ( $ dropped as [ $ type , $ value ] ) { $ type = ucfirst ( $ type ) ; $ this -> notify -> note ( "<comment>{$type}</comment> \"{$value}\" <comment>dropped</comment>" ) ; } }
7399	public function redirect ( string $ url = '' , int $ statusCode = 302 ) { $ this -> is404 = false ; $ server = filter_input_array ( INPUT_SERVER ) ; if ( '' == $ url && isset ( $ server [ 'REQUEST_URI' ] ) ) { $ url = '/' . trim ( $ server [ 'REQUEST_URI' ] , '/' ) ; preg_match ( '/^[\\a-zA-Z0-9-\._~:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=%]*$/iD' , $ url , $ match ) ; $ url = $ match [ 1 ] ?? '' ; } if ( ! headers_sent ( ) ) { header ( 'Location: ' . $ url , true , $ statusCode ) ; } echo sprintf ( '<!DOCTYPE html><html> <head> <meta charset="UTF-8" /> <meta http-equiv="refresh" content="0;url=%1$s" /> <title>Redirecting to %1$s</title> </head> <body> <script type="text/javascript"> window.location.href = "%1$s"; </script> Redirecting to <a href="%1$s">%1$s</a>. </body></html>' , htmlspecialchars ( $ url , ENT_QUOTES , 'UTF-8' ) ) ; }
3799	private function checkModelWithoutVariants ( $ containedModel ) { $ parentDefinition = $ this -> environment -> getDataDefinition ( ) -> getBasicDefinition ( ) -> getParentDataProvider ( ) ; $ this -> disablePA = ( $ this -> currentModel -> getId ( ) == $ containedModel -> getId ( ) ) || ( $ parentDefinition && $ this -> currentModel -> getProperty ( 'pid' ) == $ containedModel -> getProperty ( 'pid' ) ) ; $ this -> disablePI = ( $ this -> circularReference ) || ( $ this -> currentModel -> getId ( ) == $ containedModel -> getId ( ) ) || ( $ parentDefinition && $ this -> currentModel -> getProperty ( 'pid' ) == $ containedModel -> getId ( ) ) ; }
393	protected static function filterValidColumnNames ( $ db , array $ aliases ) { $ columnNames = [ ] ; $ tableName = static :: tableName ( ) ; $ quotedTableName = $ db -> quoteTableName ( $ tableName ) ; foreach ( static :: getTableSchema ( ) -> getColumnNames ( ) as $ columnName ) { $ columnNames [ ] = $ columnName ; $ columnNames [ ] = $ db -> quoteColumnName ( $ columnName ) ; $ columnNames [ ] = "$tableName.$columnName" ; $ columnNames [ ] = $ db -> quoteSql ( "$quotedTableName.[[$columnName]]" ) ; foreach ( $ aliases as $ tableAlias ) { $ columnNames [ ] = "$tableAlias.$columnName" ; $ quotedTableAlias = $ db -> quoteTableName ( $ tableAlias ) ; $ columnNames [ ] = $ db -> quoteSql ( "$quotedTableAlias.[[$columnName]]" ) ; } } return $ columnNames ; }
11656	public function getShortName ( ) { preg_match ( '/Widget([A-Za-z]+)\\\Module/' , get_class ( $ this ) , $ matches ) ; if ( ! isset ( $ matches [ 1 ] ) ) { throw new Exception ( get_class ( $ this ) . " is not set up correctly!" ) ; } return $ matches [ 1 ] ; }
7067	protected function getAccountingFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof AccountingInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . AccountingInterface :: class ) ; } return $ resource ; }
2955	public function PhpSerial ( ) { setlocale ( LC_ALL , "en_US" ) ; $ sysName = php_uname ( ) ; if ( substr ( $ sysName , 0 , 5 ) === "Linux" ) { $ this -> _os = "linux" ; if ( $ this -> _exec ( "stty" ) === 0 ) { register_shutdown_function ( array ( $ this , "deviceClose" ) ) ; } else { trigger_error ( "No stty availible, unable to run." , E_USER_ERROR ) ; } } elseif ( substr ( $ sysName , 0 , 6 ) === "Darwin" ) { $ this -> _os = "osx" ; register_shutdown_function ( array ( $ this , "deviceClose" ) ) ; } elseif ( substr ( $ sysName , 0 , 7 ) === "Windows" ) { $ this -> _os = "windows" ; register_shutdown_function ( array ( $ this , "deviceClose" ) ) ; } else { trigger_error ( "Host OS is neither osx, linux nor windows, unable " . "to run." , E_USER_ERROR ) ; exit ( ) ; } }
6812	private function getDateTimeFormatter ( ) { if ( $ this -> dateTimeFormatter ) { return $ this -> dateTimeFormatter ; } return $ this -> dateTimeFormatter = IntlDateFormatter :: create ( $ this -> locale , IntlDateFormatter :: SHORT , IntlDateFormatter :: SHORT , ini_get ( 'date.timezone' ) , IntlDateFormatter :: GREGORIAN ) ; }
1255	private function getValueToAssignToValue ( \ stdClass $ meta ) { if ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\Base64BinaryType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\BooleanType' , false ) ) { return strtolower ( $ meta -> strData ) === 'true' ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\DecimalType' , false ) ) { return is_int ( 0 + $ meta -> strData ) ? ( integer ) $ meta -> strData : ( double ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\DoubleType' , false ) ) { return ( double ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\IntegerType' , false ) ) { return ( integer ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\StringType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\TokenType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\URIType' , false ) ) { return $ meta -> strData ; } return $ meta -> strData ; }
10040	public function load ( $ pFilename ) { $ spreadsheet = new Spreadsheet ( ) ; $ spreadsheet -> removeSheetByIndex ( 0 ) ; return $ this -> loadIntoExisting ( $ pFilename , $ spreadsheet ) ; }
10640	protected function createUniquePath ( UploadedFile $ file ) { $ dir = 'mmmb/' . mb_substr ( mb_strtolower ( ( string ) $ file -> getClientOriginalName ( ) ) , 0 , 2 ) ; $ filename = str_replace ( array ( ' ' , $ file -> getClientOriginalExtension ( ) ) , '-' , $ file -> getClientOriginalName ( ) ) ; $ name = mb_strtolower ( $ filename . uniqid ( ) . '.' . $ file -> getClientOriginalExtension ( ) ) ; return array ( 'dir' => $ dir , 'filename' => $ name , 'path' => $ dir . '/' . $ name , ) ; }
1512	public function read ( StoreInterface $ store , FetchResource $ request ) { $ result = $ this -> doRead ( $ store , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ result ) ; }
11489	public function start ( ? string $ name = null , ? string $ sessionId = null ) : string { if ( ! $ this -> isStarted ( ) ) { if ( ! is_null ( $ name ) ) { $ this -> setName ( $ name ) ; } @ session_start ( $ sessionId ) ; } ; return $ this -> getId ( ) ; }
8028	public function registerFreeProcess ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; if ( $ this -> hasProcess ( $ pid ) === FALSE ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not register free process. Process (%d) not in list.' , $ processDetails -> getPid ( ) ) , 1400761296 ) ; } $ this -> freeProcessIds [ $ pid ] = $ pid ; return $ this ; }
11155	public function getValueByPowers ( array $ values , array $ powers ) { if ( empty ( $ values ) || empty ( $ powers ) || \ count ( $ values ) !== \ count ( $ powers ) ) { throw new InvalidArgumentException ( 'Empty parameter or count not equal' ) ; } $ values = \ array_values ( $ values ) ; $ powers = \ array_values ( $ powers ) ; $ rolledIndex = $ this -> getArrayKeyByPowers ( $ powers ) ; return $ values [ $ rolledIndex ] ; }
2290	protected function addRecipient ( $ strEmail , $ arrNew ) { if ( ( $ objOld = NewsletterRecipientsModel :: findOldSubscriptionsByEmailAndPids ( $ strEmail , $ arrNew ) ) !== null ) { while ( $ objOld -> next ( ) ) { $ objOld -> delete ( ) ; } } $ time = time ( ) ; $ arrRelated = array ( ) ; foreach ( $ arrNew as $ id ) { $ objRecipient = new NewsletterRecipientsModel ( ) ; $ objRecipient -> pid = $ id ; $ objRecipient -> tstamp = $ time ; $ objRecipient -> email = $ strEmail ; $ objRecipient -> active = '' ; $ objRecipient -> addedOn = $ time ; $ objRecipient -> save ( ) ; if ( ( $ objBlacklist = NewsletterBlacklistModel :: findByHashAndPid ( md5 ( $ strEmail ) , $ id ) ) !== null ) { $ objBlacklist -> delete ( ) ; } $ arrRelated [ 'tl_newsletter_recipients' ] [ ] = $ objRecipient -> id ; } $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = $ optIn -> create ( 'nl' , $ strEmail , $ arrRelated ) ; $ objChannel = NewsletterChannelModel :: findByIds ( $ arrNew ) ; $ arrData = array ( ) ; $ arrData [ 'token' ] = $ optInToken -> getIdentifier ( ) ; $ arrData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrData [ 'link' ] = Idna :: decode ( Environment :: get ( 'base' ) ) . Environment :: get ( 'request' ) . ( ( strpos ( Environment :: get ( 'request' ) , '?' ) !== false ) ? '&' : '?' ) . 'token=' . $ optInToken -> getIdentifier ( ) ; $ arrData [ 'channel' ] = $ arrData [ 'channels' ] = implode ( "\n" , $ objChannel -> fetchEach ( 'title' ) ) ; $ optInToken -> send ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_subject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) , StringUtil :: parseSimpleTokens ( $ this -> nl_subscribe , $ arrData ) ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'nl_confirm' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_confirm' ] ) ; $ this -> reload ( ) ; }
6709	protected function useActualParameters ( ) { $ this -> setParameters ( $ this -> urlToParameters ( $ this -> getRequestedUri ( ) ) ) ; $ this -> setParameters ( $ _REQUEST ) ; $ this -> setParameters ( $ this -> parseHeader ( $ _SERVER ) ) ; $ this -> setParameters ( $ this -> stringToArray ( $ this -> readBody ( ) ) ) ; return $ this -> getParameters ( ) ; }
7404	private function convertFileInformation ( $ file ) { if ( $ file instanceof FileUpload ) { return $ file ; } $ file = $ this -> fixPhpFilesArray ( $ file ) ; if ( is_array ( $ file ) ) { $ keys = array_keys ( $ file ) ; sort ( $ keys ) ; if ( $ keys == [ 'error' , 'name' , 'size' , 'tmp_name' , 'type' ] ) { if ( UPLOAD_ERR_NO_FILE == $ file [ 'error' ] ) { $ file = null ; } else { $ file = new FileUpload ( $ file [ 'tmp_name' ] , $ file [ 'name' ] , $ file [ 'size' ] , $ file [ 'type' ] , $ file [ 'error' ] ) ; } } else { $ file = array_map ( [ $ this , 'convertFileInformation' ] , $ file ) ; } } return $ file ; }
7951	public function orderCacheRule ( $ nbCacheRule , $ duration ) { return json_decode ( self :: getClient ( ) -> orderCacheRule ( $ this -> sn , $ nbCacheRule , $ duration ) ) ; }
9975	private static function fillBuiltInFormatCodes ( ) { if ( self :: $ builtInFormats === null ) { self :: $ builtInFormats = [ ] ; self :: $ builtInFormats [ 0 ] = self :: FORMAT_GENERAL ; self :: $ builtInFormats [ 1 ] = '0' ; self :: $ builtInFormats [ 2 ] = '0.00' ; self :: $ builtInFormats [ 3 ] = '#,##0' ; self :: $ builtInFormats [ 4 ] = '#,##0.00' ; self :: $ builtInFormats [ 9 ] = '0%' ; self :: $ builtInFormats [ 10 ] = '0.00%' ; self :: $ builtInFormats [ 11 ] = '0.00E+00' ; self :: $ builtInFormats [ 12 ] = '# ?/?' ; self :: $ builtInFormats [ 13 ] = '# ??/??' ; self :: $ builtInFormats [ 14 ] = 'm/d/yyyy' ; self :: $ builtInFormats [ 15 ] = 'd-mmm-yy' ; self :: $ builtInFormats [ 16 ] = 'd-mmm' ; self :: $ builtInFormats [ 17 ] = 'mmm-yy' ; self :: $ builtInFormats [ 18 ] = 'h:mm AM/PM' ; self :: $ builtInFormats [ 19 ] = 'h:mm:ss AM/PM' ; self :: $ builtInFormats [ 20 ] = 'h:mm' ; self :: $ builtInFormats [ 21 ] = 'h:mm:ss' ; self :: $ builtInFormats [ 22 ] = 'm/d/yyyy h:mm' ; self :: $ builtInFormats [ 37 ] = '#,##0_);(#,##0)' ; self :: $ builtInFormats [ 38 ] = '#,##0_);[Red](#,##0)' ; self :: $ builtInFormats [ 39 ] = '#,##0.00_);(#,##0.00)' ; self :: $ builtInFormats [ 40 ] = '#,##0.00_);[Red](#,##0.00)' ; self :: $ builtInFormats [ 44 ] = '_("$"* #,##0.00_);_("$"* \(#,##0.00\);_("$"* "-"??_);_(@_)' ; self :: $ builtInFormats [ 45 ] = 'mm:ss' ; self :: $ builtInFormats [ 46 ] = '[h]:mm:ss' ; self :: $ builtInFormats [ 47 ] = 'mm:ss.0' ; self :: $ builtInFormats [ 48 ] = '##0.0E+0' ; self :: $ builtInFormats [ 49 ] = '@' ; self :: $ builtInFormats [ 27 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 30 ] = 'm/d/yy' ; self :: $ builtInFormats [ 36 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 50 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 57 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 59 ] = 't0' ; self :: $ builtInFormats [ 60 ] = 't0.00' ; self :: $ builtInFormats [ 61 ] = 't#,##0' ; self :: $ builtInFormats [ 62 ] = 't#,##0.00' ; self :: $ builtInFormats [ 67 ] = 't0%' ; self :: $ builtInFormats [ 68 ] = 't0.00%' ; self :: $ builtInFormats [ 69 ] = 't# ?/?' ; self :: $ builtInFormats [ 70 ] = 't# ??/??' ; self :: $ flippedBuiltInFormats = array_flip ( self :: $ builtInFormats ) ; } }
8721	protected function getTranslatableAttributesFromSchema ( ) { if ( ( ! $ con = $ this -> getConnection ( ) ) || ( ! $ builder = $ con -> getSchemaBuilder ( ) ) ) { return [ ] ; } if ( $ columns = TranslatableConfig :: cacheGet ( $ this -> getI18nTable ( ) ) ) { return $ columns ; } $ columns = $ builder -> getColumnListing ( $ this -> getI18nTable ( ) ) ; unset ( $ columns [ array_search ( $ this -> getForeignKey ( ) , $ columns ) ] ) ; TranslatableConfig :: cacheSet ( $ this -> getI18nTable ( ) , $ columns ) ; return $ columns ; }
4501	public function getElementsByClassName ( string $ names ) : HTMLCollection { $ namesArray = explode ( " " , $ names ) ; $ dots = "." . implode ( "." , $ namesArray ) ; return $ this -> css ( $ dots ) ; }
5719	public function cancel ( ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return Controller :: curr ( ) -> redirect ( $ this -> getBackLink ( ) ) ; }
5660	private function collectSelectOptions ( $ node ) { $ options = array ( ) ; if ( $ node -> name === 'option' ) { $ options [ ] = $ this -> tags ( ) -> createTag ( $ node -> name , $ this -> attributes ( $ node ) ) -> addContent ( $ this -> innerHtml ( $ node ) ) ; } if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ options = array_merge ( $ options , $ this -> collectSelectOptions ( $ child ) ) ; } } return $ options ; }
8088	public function generateUserPassword ( User $ user , $ password , $ generateOld = false ) { $ registrationDate = $ user -> RegDate ; $ pre = $ this -> encode ( $ registrationDate ) ; $ pos = substr ( $ registrationDate , 5 , 1 ) ; $ post = $ this -> encode ( $ registrationDate * ( substr ( $ registrationDate , $ pos , 1 ) ) ) ; $ finalString = $ pre . $ password . $ post ; return $ generateOld ? md5 ( $ finalString ) : sha1 ( $ finalString ) ; }
1046	public static function toSafeTrace ( $ error ) { $ trace = $ error -> getTrace ( ) ; if ( isset ( $ trace [ 0 ] [ 'function' ] ) && isset ( $ trace [ 0 ] [ 'class' ] ) && ( $ trace [ 0 ] [ 'class' ] . '::' . $ trace [ 0 ] [ 'function' ] === 'GraphQL\Utils\Utils::invariant' ) ) { array_shift ( $ trace ) ; } elseif ( ! isset ( $ trace [ 0 ] [ 'file' ] ) ) { array_shift ( $ trace ) ; } return array_map ( static function ( $ err ) { $ safeErr = array_intersect_key ( $ err , [ 'file' => true , 'line' => true ] ) ; if ( isset ( $ err [ 'function' ] ) ) { $ func = $ err [ 'function' ] ; $ args = ! empty ( $ err [ 'args' ] ) ? array_map ( [ self :: class , 'printVar' ] , $ err [ 'args' ] ) : [ ] ; $ funcStr = $ func . '(' . implode ( ', ' , $ args ) . ')' ; if ( isset ( $ err [ 'class' ] ) ) { $ safeErr [ 'call' ] = $ err [ 'class' ] . '::' . $ funcStr ; } else { $ safeErr [ 'function' ] = $ funcStr ; } } return $ safeErr ; } , $ trace ) ; }
12268	protected function renderSlots ( Page $ page , array $ slots , array $ options = array ( ) ) { $ renderedSlots = array ( ) ; $ slots = $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERING , $ page , $ slots ) ; foreach ( $ slots as $ slotName => $ slot ) { if ( is_string ( $ slot ) ) { $ renderedSlots [ $ slotName ] = $ slot ; continue ; } if ( ! $ slot instanceof Slot ) { continue ; } $ blocks = $ slot -> getEntitiesInUse ( ) ; $ renderedSlots [ $ slotName ] = $ this -> templating -> render ( 'RedKiteCms/Resources/views/Slot/slot.html.twig' , array ( 'options' => $ options , 'slotname' => $ slotName , 'data' => rawurlencode ( "[" . implode ( "," , $ blocks ) ) . "]" , 'next' => $ slot -> getNext ( ) , ) ) ; } return $ slots = $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERED , $ page , $ renderedSlots ) ; }
6183	public function add ( $ type , $ message , $ redirect = null ) { if ( ! isset ( $ type ) or ! isset ( $ message [ 0 ] ) ) { return false ; } if ( strlen ( trim ( $ type ) ) === 1 ) { $ type = str_replace ( [ 'h' , 'i' , 'w' , 'e' , 's' ] , [ 'help' , 'info' , 'warning' , 'error' , 'success' ] , $ type ) ; } $ router = new Router ( ) ; try { if ( ! in_array ( $ type , $ this -> msgTypes ) ) { throw new BaseException ( '"' . strip_tags ( $ type ) . '" is not a valid message type!' , 501 ) ; } } catch ( BaseException $ e ) { $ msg = null ; if ( ini_get ( 'display_errors' ) === "on" ) { $ msg .= '<pre>' ; $ msg .= 'Message: <b>' . $ e -> getMessage ( ) . '</b><br><br>' ; $ msg .= 'Accept: ' . $ _SERVER [ 'HTTP_ACCEPT' ] . '<br>' ; if ( isset ( $ _SERVER [ 'HTTP_REFERER' ] ) ) { $ msg .= 'Referer: ' . $ _SERVER [ 'HTTP_REFERER' ] . '<br><br>' ; } $ msg .= 'Request Method: ' . $ _SERVER [ 'REQUEST_METHOD' ] . '<br><br>' ; $ msg .= 'Current file Path: <b>' . $ this -> router -> currentPath ( ) . '</b><br>' ; $ msg .= 'File Exception: ' . $ e -> getFile ( ) . ':' . $ e -> getLine ( ) . '<br><br>' ; $ msg .= 'Trace: <br>' . $ e -> getTraceAsString ( ) . '<br>' ; $ msg .= '</pre>' ; return Response :: create ( $ msg ) -> display ( ) ; } return Response :: create ( $ e -> getMessage ( ) ) -> status ( 501 ) -> display ( ) ; } $ get = $ this -> driver -> get ( 'flash_messages' ) ; $ get [ $ type ] [ ] = $ message ; $ this -> driver -> set ( 'flash_messages' , $ get ) ; if ( ! is_null ( $ redirect ) ) { return $ router -> redirect ( $ redirect , 301 ) ; } return true ; }
7124	protected function getMessageFromEvent ( ResourceEventInterface $ event ) { $ message = $ event -> getResource ( ) ; if ( ! $ message instanceof TicketMessageInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketMessageInterface :: class ) ; } return $ message ; }
2873	public function getRequestFilters ( Mage_Core_Controller_Request_Http $ request ) { if ( ! $ this -> requestFilterValues ) { $ filters = $ this -> getFilterParams ( ) ; $ this -> requestFilterValues = array ( ) ; foreach ( $ filters as $ filter ) { $ param = $ request -> getParam ( $ filter , null ) ; if ( $ param !== null ) { $ this -> requestFilterValues [ $ filter ] = $ param ; } } } return $ this -> requestFilterValues ; }
9487	private function installModules ( ) { $ this -> frame ( 'Installing the modules' ) ; $ this -> line ( '' ) ; foreach ( $ this -> config ( ) -> get ( 'arcanesoft.foundation.modules.commands.install' , [ ] ) as $ command ) { $ this -> call ( $ command ) ; } $ this -> call ( 'db:seed' , [ '--class' => DatabaseSeeder :: class ] ) ; $ this -> line ( '' ) ; $ this -> comment ( 'Modules installed !' ) ; $ this -> line ( '' ) ; }
6427	public function getUserProfile ( ) { $ client = $ this -> getClient ( ) ; $ client -> setAccessToken ( $ this -> access_token ) ; $ plus = new \ Google_Service_Plus ( $ client ) ; $ oauth2 = new \ Google_Service_Oauth2 ( $ client ) ; if ( $ client -> getAccessToken ( ) ) { $ user = $ oauth2 -> userinfo -> get ( ) ; if ( isset ( $ user -> id ) ) { $ name = $ user -> givenName ; if ( ! empty ( $ user -> familyName ) ) { $ name = $ user -> familyName . ' ' . $ user -> givenName ; } $ profile = array ( 'userid' => $ user -> id , 'name' => $ name , 'imageurl' => $ user -> picture , 'email' => $ user -> email ) ; return $ profile ; } } throw new \ Exception ( 'Can not get google profile' ) ; }
2641	public function cleanBySurrogateKey ( $ keys ) { $ type = 'clean by key on ' ; $ uri = $ this -> _getApiServiceUri ( ) . 'purge' ; $ num = count ( $ keys ) ; $ result = false ; if ( $ num >= self :: FASTLY_MAX_HEADER_KEY_SIZE ) { $ parts = $ num / self :: FASTLY_MAX_HEADER_KEY_SIZE ; $ additional = ( $ parts > ( int ) $ parts ) ? 1 : 0 ; $ parts = ( int ) $ parts + ( int ) $ additional ; $ chunks = ceil ( $ num / $ parts ) ; $ collection = array_chunk ( $ keys , $ chunks ) ; } else { $ collection = [ $ keys ] ; } foreach ( $ collection as $ keys ) { $ payload = json_encode ( [ 'surrogate_keys' => $ keys ] ) ; $ result = $ this -> _purge ( $ uri , null , \ Zend_Http_Client :: POST , $ payload ) ; if ( $ result [ 'status' ] ) { foreach ( $ keys as $ key ) { $ this -> logger -> execute ( 'surrogate key: ' . $ key ) ; } } $ canPublishKeyUrlChanges = $ this -> config -> canPublishKeyUrlChanges ( ) ; $ canPublishPurgeChanges = $ this -> config -> canPublishPurgeChanges ( ) ; if ( $ this -> config -> areWebHooksEnabled ( ) && ( $ canPublishKeyUrlChanges || $ canPublishPurgeChanges ) ) { $ status = $ result [ 'status' ] ? '' : 'FAILED ' ; $ this -> sendWebHook ( $ status . '*clean by key on ' . join ( " " , $ keys ) . '*' ) ; $ canPublishPurgeByKeyDebugBacktrace = $ this -> config -> canPublishPurgeByKeyDebugBacktrace ( ) ; $ canPublishPurgeDebugBacktrace = $ this -> config -> canPublishPurgeDebugBacktrace ( ) ; if ( $ canPublishPurgeByKeyDebugBacktrace == false && $ canPublishPurgeDebugBacktrace == false ) { return $ result [ 'status' ] ; } $ this -> stackTrace ( $ type . join ( " " , $ keys ) ) ; } } return $ result [ 'status' ] ; }
9663	public static function registerWriter ( $ writerType , $ writerClass ) { if ( ! is_a ( $ writerClass , Writer \ IWriter :: class , true ) ) { throw new Writer \ Exception ( 'Registered writers must implement ' . Writer \ IWriter :: class ) ; } self :: $ writers [ $ writerType ] = $ writerClass ; }
9826	private function writeRelationship ( XMLWriter $ objWriter , $ pId , $ pType , $ pTarget , $ pTargetMode = '' ) { if ( $ pType != '' && $ pTarget != '' ) { $ objWriter -> startElement ( 'Relationship' ) ; $ objWriter -> writeAttribute ( 'Id' , 'rId' . $ pId ) ; $ objWriter -> writeAttribute ( 'Type' , $ pType ) ; $ objWriter -> writeAttribute ( 'Target' , $ pTarget ) ; if ( $ pTargetMode != '' ) { $ objWriter -> writeAttribute ( 'TargetMode' , $ pTargetMode ) ; } $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
7095	private function throwIllegalOperationIfItemIsImmutable ( ResourceEventInterface $ event ) { if ( $ event -> getHard ( ) ) { return ; } $ item = $ this -> getSaleItemFromEvent ( $ event ) ; if ( $ item -> isImmutable ( ) ) { throw new IllegalOperationException ( 'ekyna_commerce.sale.message.immutable_element' ) ; } }
5352	public function getSupportedNamespaces ( ) { if ( empty ( $ this -> data -> namespaces ) || ! is_array ( $ this -> data -> namespaces ) ) { return array ( ) ; } return $ this -> data -> namespaces ; }
3319	public function isa ( $ type , $ option = null ) { if ( $ type === 'bool' ) { $ type = 'boolean' ; } $ this -> isa = $ type ; $ this -> isaOption = $ option ; return $ this ; }
2522	protected function callMessage ( $ messageName , $ options , $ messageOptions , $ endSession = false ) { $ messageOptions = $ this -> makeMessageOptions ( $ messageOptions , $ endSession ) ; $ this -> lastMessage = $ messageName ; $ sendResult = $ this -> sessionHandler -> sendMessage ( $ messageName , $ this -> requestCreator -> createRequest ( $ messageName , $ options ) , $ messageOptions ) ; $ response = $ this -> responseHandler -> analyzeResponse ( $ sendResult , $ messageName ) ; if ( $ messageOptions [ 'returnXml' ] === false ) { $ response -> responseXml = null ; } return $ response ; }
8928	public function add ( $ name , GeneratorInterface $ class ) { if ( array_key_exists ( $ name , $ this -> generators ) ) { throw new \ InvalidArgumentException ( 'Generator already exists.' ) ; } $ this -> generators [ $ name ] = $ class ; }
12664	public function requirePackage ( string $ package_class ) : ApplicationInterface { if ( ! in_array ( PackageInterface :: class , class_implements ( $ package_class ) ) ) { throw new PackageRequireException ( 'Specified package does not implements PackageInterface: ' . $ package_class , $ package_class ) ; } $ module_list = call_user_func ( [ $ package_class , 'getModuleList' ] ) ; if ( ! is_array ( $ module_list ) ) { throw new PackageRequireException ( 'Failed to call getModuleList: ' . $ package_class , $ package_class ) ; } $ this -> required_modules = array_merge ( $ this -> required_modules , $ module_list ) ; return $ this ; }
570	public function validateData ( $ data , $ key , $ rawHash = false ) { $ test = @ hash_hmac ( $ this -> macHash , '' , '' , $ rawHash ) ; if ( ! $ test ) { throw new InvalidConfigException ( 'Failed to generate HMAC with hash algorithm: ' . $ this -> macHash ) ; } $ hashLength = StringHelper :: byteLength ( $ test ) ; if ( StringHelper :: byteLength ( $ data ) >= $ hashLength ) { $ hash = StringHelper :: byteSubstr ( $ data , 0 , $ hashLength ) ; $ pureData = StringHelper :: byteSubstr ( $ data , $ hashLength , null ) ; $ calculatedHash = hash_hmac ( $ this -> macHash , $ pureData , $ key , $ rawHash ) ; if ( $ this -> compareString ( $ hash , $ calculatedHash ) ) { return $ pureData ; } } return false ; }
12947	protected function ownerHasTagAttribute ( ) { if ( $ this -> _hasTagAttribute === null ) { $ this -> _hasTagAttribute = $ this -> owner -> hasAttribute ( 'tags' ) ; } return $ this -> _hasTagAttribute ; }
437	protected function compareValues ( $ operator , $ type , $ value , $ compareValue ) { if ( $ type === self :: TYPE_NUMBER ) { $ value = ( float ) $ value ; $ compareValue = ( float ) $ compareValue ; } else { $ value = ( string ) $ value ; $ compareValue = ( string ) $ compareValue ; } switch ( $ operator ) { case '==' : return $ value == $ compareValue ; case '===' : return $ value === $ compareValue ; case '!=' : return $ value != $ compareValue ; case '!==' : return $ value !== $ compareValue ; case '>' : return $ value > $ compareValue ; case '>=' : return $ value >= $ compareValue ; case '<' : return $ value < $ compareValue ; case '<=' : return $ value <= $ compareValue ; default : return false ; } }
3701	private function convertRenderGroupType ( $ type ) { $ lookup = [ 'char' => GroupAndSortingInformationInterface :: GROUP_CHAR , 'digit' => GroupAndSortingInformationInterface :: GROUP_DIGIT , 'day' => GroupAndSortingInformationInterface :: GROUP_DAY , 'weekday' => GroupAndSortingInformationInterface :: GROUP_WEEKDAY , 'week' => GroupAndSortingInformationInterface :: GROUP_WEEK , 'month' => GroupAndSortingInformationInterface :: GROUP_MONTH , 'year' => GroupAndSortingInformationInterface :: GROUP_YEAR , ] ; if ( array_key_exists ( $ type , $ lookup ) ) { return $ lookup [ $ type ] ; } return GroupAndSortingInformationInterface :: GROUP_NONE ; }
2867	public function getContent ( $ filePath , $ startPosition , $ endPosition ) { if ( ! file_exists ( $ filePath ) ) { return '' ; } if ( ! $ endPosition ) { return trim ( file_get_contents ( $ filePath , null , null , $ startPosition ) ) ; } if ( $ endPosition <= $ startPosition ) { return '' ; } return trim ( file_get_contents ( $ filePath , null , null , $ startPosition , $ endPosition - $ startPosition ) ) ; }
1054	private function varTypeAllowedForType ( $ varType , $ expectedType ) { if ( $ expectedType instanceof NonNull ) { if ( $ varType instanceof NonNull ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType -> getWrappedType ( ) ) ; } return false ; } if ( $ varType instanceof NonNull ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType ) ; } if ( $ varType instanceof ListOfType && $ expectedType instanceof ListOfType ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType -> getWrappedType ( ) ) ; } return $ varType === $ expectedType ; }
8689	private static function doFlatten ( $ iterable , $ depth , callable $ predicate , array $ result = [ ] ) { foreach ( $ iterable as $ item ) { if ( $ depth >= 1 && $ predicate ( $ item ) ) { $ result = static :: doFlatten ( $ item , $ depth - 1 , $ predicate , $ result ) ; } else { $ result [ ] = $ item ; } } return $ result ; }
9659	public static function createReader ( $ readerType ) { if ( ! isset ( self :: $ readers [ $ readerType ] ) ) { throw new Reader \ Exception ( "No reader found for type $readerType" ) ; } $ className = self :: $ readers [ $ readerType ] ; $ reader = new $ className ( ) ; return $ reader ; }
2257	public static function addStaticUrlTo ( $ script , ContaoContext $ context = null ) { if ( preg_match ( '@^https?://@' , $ script ) ) { return $ script ; } if ( $ context === null ) { $ context = System :: getContainer ( ) -> get ( 'contao.assets.assets_context' ) ; } if ( $ strStaticUrl = $ context -> getStaticUrl ( ) ) { return $ strStaticUrl . $ script ; } return $ script ; }
796	public function getAnnotationEnd ( $ index ) { $ currentIndex = null ; if ( isset ( $ this [ $ index + 2 ] ) ) { if ( $ this [ $ index + 2 ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) ) { $ currentIndex = $ index + 2 ; } elseif ( isset ( $ this [ $ index + 3 ] ) && $ this [ $ index + 2 ] -> isType ( DocLexer :: T_NONE ) && $ this [ $ index + 3 ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) && Preg :: match ( '/^(\R\s*\*\s*)*\s*$/' , $ this [ $ index + 2 ] -> getContent ( ) ) ) { $ currentIndex = $ index + 3 ; } } if ( null !== $ currentIndex ) { $ level = 0 ; for ( $ max = \ count ( $ this ) ; $ currentIndex < $ max ; ++ $ currentIndex ) { if ( $ this [ $ currentIndex ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) ) { ++ $ level ; } elseif ( $ this [ $ currentIndex ] -> isType ( DocLexer :: T_CLOSE_PARENTHESIS ) ) { -- $ level ; } if ( 0 === $ level ) { return $ currentIndex ; } } return null ; } return $ index + 1 ; }
1801	protected function switchToEdit ( $ id ) { $ arrKeys = array ( ) ; $ arrUnset = array ( 'act' , 'id' , 'table' ) ; foreach ( array_keys ( $ _GET ) as $ strKey ) { if ( ! \ in_array ( $ strKey , $ arrUnset ) ) { $ arrKeys [ $ strKey ] = $ strKey . '=' . Input :: get ( $ strKey ) ; } } $ strUrl = TL_SCRIPT . '?' . implode ( '&' , $ arrKeys ) ; return $ strUrl . ( ! empty ( $ arrKeys ) ? '&' : '' ) . ( Input :: get ( 'table' ) ? 'table=' . Input :: get ( 'table' ) . '&amp;' : '' ) . 'act=edit&amp;id=' . rawurlencode ( $ id ) ; }
6922	public function set ( TaxGroupInterface $ taxGroup , CountryInterface $ country , $ business = false , array $ taxes ) { $ key = $ this -> buildKey ( $ taxGroup , $ country , $ business ) ; $ this -> taxes [ $ key ] = $ taxes ; }
5886	public function resolve ( $ tsdns ) { $ this -> getTransport ( ) -> sendLine ( $ tsdns ) ; $ repl = $ this -> getTransport ( ) -> readLine ( ) ; $ this -> getTransport ( ) -> disconnect ( ) ; if ( $ repl -> section ( ":" , 0 ) -> toInt ( ) == 404 ) { throw new Ts3Exception ( "unable to resolve TSDNS hostname (" . $ tsdns . ")" ) ; } Signal :: getInstance ( ) -> emit ( "tsdnsResolved" , $ tsdns , $ repl ) ; return $ repl ; }
338	protected function extractColumnSize ( $ column , $ dbType , $ precision , $ scale , $ length ) { $ column -> size = trim ( $ length ) === '' ? null : ( int ) $ length ; $ column -> precision = trim ( $ precision ) === '' ? null : ( int ) $ precision ; $ column -> scale = trim ( $ scale ) === '' ? null : ( int ) $ scale ; }
6106	private function getGridClass ( ) { $ class = [ ] ; foreach ( $ this -> grid as $ grid ) { if ( ! isset ( $ grid [ 'type' ] ) || ! isset ( $ grid [ 'size' ] ) ) { throw new InvalidConfigException ( get_called_class ( ) . ' must have type and size.' ) ; } if ( ! isset ( $ grid [ 'positiontype' ] ) ) $ class [ ] = $ grid [ 'type' ] . $ grid [ 'size' ] ; else $ class [ ] = $ grid [ 'type' ] . $ grid [ 'positiontype' ] . '-' . $ grid [ 'size' ] ; } return implode ( ' ' , $ class ) ; }
6699	public function setBuild ( $ build ) { $ this -> build = array_values ( ( array ) $ build ) ; array_walk ( $ this -> build , function ( & $ v ) { if ( preg_match ( '/^[0-9]+$/' , $ v ) ) { $ v = ( int ) $ v ; } } ) ; }
7887	protected function parse ( ) { $ log = [ ] ; $ pattern = "/\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\].*/" ; preg_match_all ( $ pattern , $ this -> raw , $ headings ) ; $ data = preg_split ( $ pattern , $ this -> raw ) ; if ( $ data [ 0 ] < 1 ) { $ trash = array_shift ( $ data ) ; unset ( $ trash ) ; } foreach ( $ headings as $ heading ) { for ( $ i = 0 , $ j = count ( $ heading ) ; $ i < $ j ; $ i ++ ) { foreach ( $ this -> levels as $ level ) { if ( $ this -> level == $ level || $ this -> level == 'all' ) { if ( strpos ( strtolower ( $ heading [ $ i ] ) , strtolower ( '.' . $ level ) ) ) { $ log [ ] = [ 'level' => $ level , 'header' => $ heading [ $ i ] , 'stack' => $ data [ $ i ] ] ; } } } } } unset ( $ headings ) ; unset ( $ data ) ; return array_reverse ( $ log ) ; }
7020	private function format_i ( & $ str ) { if ( strstr ( $ str , '%i' ) ) $ str = str_replace ( '%i' , sprintf ( '%02d' , $ this -> min ) , $ str ) ; }
8076	public function post ( $ endpoint , $ data , $ query = [ ] ) { $ endpoint = $ this -> buildUri ( $ endpoint , $ query ) ; $ headers = $ this -> buildHeaders ( ) ; $ data = $ this -> prepareData ( $ data ) ; $ this -> response = $ this -> client -> post ( $ endpoint , $ data , $ headers ) ; return $ this -> response ; }
9183	protected function forgetByKey ( $ key ) { $ result = false ; if ( Cache :: has ( $ key ) ) { $ result = Cache :: forget ( $ key ) ; } return $ result ; }
5621	protected function chompScheme ( & $ url ) { if ( preg_match ( '#^([^/:]*):(//)(.*)#' , $ url , $ matches ) ) { $ url = $ matches [ 2 ] . $ matches [ 3 ] ; return $ matches [ 1 ] ; } return false ; }
7586	public function setDestinationPath ( $ destination = null ) { if ( empty ( $ destination ) ) { $ destination = sys_get_temp_dir ( ) . '/SugarAPI' ; } $ this -> destinationPath = $ destination ; return $ this ; }
4153	public function invalidateBearerToken ( ) { $ url = $ this -> getInvalidateBearerTokenUrl ( ) ; $ bearerToken = $ this -> bearerToken ; if ( $ bearerToken === null ) { $ bearerToken = $ this -> getBearerToken ( ) ; } $ params = array ( 'post' => array ( 'access_token' => $ bearerToken ) , 'headers' => $ this -> buildBearerTokenHeader ( ) , ) ; $ response = $ this -> curl -> send ( $ url , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> access_token ) || $ obj -> access_token != $ bearerToken ) { $ this -> findExceptions ( $ response ) ; } unset ( $ url , $ bearerToken , $ params , $ response , $ obj ) ; return true ; }
548	protected function addMemcachedServers ( $ cache , $ servers ) { $ existingServers = [ ] ; if ( $ this -> persistentId !== null ) { foreach ( $ cache -> getServerList ( ) as $ s ) { $ existingServers [ $ s [ 'host' ] . ':' . $ s [ 'port' ] ] = true ; } } foreach ( $ servers as $ server ) { if ( empty ( $ existingServers ) || ! isset ( $ existingServers [ $ server -> host . ':' . $ server -> port ] ) ) { $ cache -> addServer ( $ server -> host , $ server -> port , $ server -> weight ) ; } } }
2598	public function moveNext ( ) { $ this -> peek = 0 ; $ this -> token = $ this -> lookahead ; $ this -> lookahead = ( isset ( $ this -> tokens [ $ this -> position ] ) ) ? $ this -> tokens [ $ this -> position ++ ] : null ; return $ this -> lookahead !== null ; }
11980	protected function query ( $ api , $ from , $ to ) { $ params = [ 'begin_date' => $ from , 'end_date' => $ to , ] ; return $ this -> parseJSON ( 'json' , [ $ api , $ params ] ) ; }
7831	public function getSpacedCore ( ) { $ left = $ this -> getSpacesByCore ( ) ; $ right = $ this -> getSpacesByCore ( true ) ; return $ left . $ this -> core . $ right ; }
1865	public function addSenderPlaceholder ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> pid ) { $ objChannel = $ this -> Database -> prepare ( "SELECT sender FROM tl_newsletter_channel WHERE id=?" ) -> execute ( $ dc -> activeRecord -> pid ) ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'placeholder' ] = $ objChannel -> sender ; } return $ varValue ; }
1384	protected function isNotFound ( string $ type , string $ id ) : bool { return ! $ this -> store -> exists ( ResourceIdentifier :: create ( $ type , $ id ) ) ; }
12040	public function getCurrentUser ( ) { $ this -> authenticated = false ; $ authenticate = $ this -> session -> get ( "handler" , "auth" ) ; if ( is_a ( $ authenticate , Authenticate :: class ) ) { if ( $ authenticate -> authenticated ) { $ this -> authenticated = true ; $ this -> authority = $ this -> session -> getAuthority ( ) ; return $ this -> loadObjectByURI ( $ authenticate -> get ( "user_name_id" ) , [ ] , true ) ; } } return $ this ; }
8418	public static function registerDatabase ( string $ alias ) { if ( isset ( self :: $ databases [ $ alias ] ) === false ) { self :: $ databases [ $ alias ] = new static ( $ alias ) ; } }
8139	public function load ( $ name ) { if ( $ name instanceof Twig_TemplateWrapper ) { return $ name ; } if ( $ name instanceof Twig_Template ) { return new Twig_TemplateWrapper ( $ this , $ name ) ; } return new Twig_TemplateWrapper ( $ this , $ this -> loadTemplate ( $ name ) ) ; }
11170	private function refreshSession ( ) { $ mapper = Neuron_GameServer_Mappers_UpdateMapper :: getInstance ( ) ; if ( ! isset ( $ _SESSION [ 'ngpu_lastlog' ] ) ) { $ _SESSION [ 'ngpu_lastlog' ] = $ mapper -> getLastLogId ( $ this -> objProfile ) ; $ _SESSION [ 'ngpu_data' ] = array ( ) ; } else { $ lastLogId = $ _SESSION [ 'ngpu_lastlog' ] ; $ updates = $ mapper -> getUpdates ( $ this -> objProfile , $ lastLogId ) ; foreach ( $ updates as $ v ) { $ _SESSION [ 'ngpu_data' ] [ $ v [ 'key' ] ] = $ v [ 'value' ] ; $ lastLogId = max ( $ v [ 'id' ] , $ lastLogId ) ; } $ _SESSION [ 'ngpu_lastlog' ] = $ lastLogId ; } }
8746	public function getListenerInstance ( EventDispatcher $ eventDispatcher = null , StreamableInterface $ stream = null ) { $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Matcher' ) ; $ matcher = $ reflection -> newInstance ( ) ; $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Listener' ) ; if ( null === $ eventDispatcher ) { $ eventDispatcher = new EventDispatcher ( ) ; } if ( null === $ stream ) { $ stream = new Stream ( ) ; } $ listener = $ reflection -> newInstance ( $ matcher , $ eventDispatcher , $ stream ) ; return $ listener ; }
3130	public function getServiceContext ( $ testDefinitionUri , $ testCompilationUri , $ testExecutionUri , $ userUri = null ) { $ serviceContext = new QtiRunnerServiceContext ( $ testDefinitionUri , $ testCompilationUri , $ testExecutionUri ) ; $ serviceContext -> setServiceManager ( $ this -> getServiceManager ( ) ) ; $ serviceContext -> setTestConfig ( $ this -> getTestConfig ( ) ) ; $ serviceContext -> setUserUri ( $ userUri ) ; $ sessionService = $ this -> getServiceManager ( ) -> get ( TestSessionService :: SERVICE_ID ) ; $ sessionService -> registerTestSession ( $ serviceContext -> getTestSession ( ) , $ serviceContext -> getStorage ( ) , $ serviceContext -> getCompilationDirectory ( ) ) ; return $ serviceContext ; }
3934	private function setExcluded ( PropertyInterface $ property , $ propInfo ) { if ( ! isset ( $ propInfo [ 'exclude' ] ) ) { return ; } $ property -> setExcluded ( ( bool ) $ propInfo [ 'exclude' ] ) ; }
10071	public function render ( InputFilter $ inputFilter ) { $ inputFilter -> prepare ( ) ; $ props = $ inputFilter -> getAttributes ( ) ; $ treeBuilder = new TreeBuilder ( $ inputFilter ) ; $ props = array_merge ( $ props , $ treeBuilder -> getTree ( ) ) ; return $ this -> make ( 'widget-form' , $ props ) ; }
11205	public function merge ( $ data , $ key = false , $ dataKey = false ) { if ( $ data != false && ( is_array ( $ data ) || is_object ( $ data ) ) ) { foreach ( $ data as $ item ) { $ this -> add ( $ item , $ key , $ dataKey , true ) ; } } else { $ this -> add ( $ data , $ key , $ dataKey ) ; } return $ this ; }
6595	protected function getMethodComment ( \ ReflectionMethod $ method ) { $ lines = preg_split ( "/((\r?\n)|(\r\n?))/" , $ method -> getDocComment ( ) ) ; $ count = count ( $ lines ) ; foreach ( $ lines as $ i => $ line ) { $ line = preg_replace ( '/^\s*(\/\*\*|\*\/?)\s*/' , '' , $ line ) ; $ line = trim ( $ line ) ; $ lines [ $ i ] = $ line ; if ( ! $ line && ( $ i == 0 || $ i == $ count - 1 ) ) { unset ( $ lines [ $ i ] ) ; } } return array_values ( $ lines ) ; }
1210	public function split ( ItemInterface $ item , $ length ) { return array ( 'primary' => $ this -> slice ( $ item , 0 , $ length ) , 'secondary' => $ this -> slice ( $ item , $ length ) , ) ; }
12427	public function getAuthorizerOption ( $ authorizerAppId , $ optionName ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ authorizerAppId , 'option_name' => $ optionName , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_OPTION , $ params ] ) ; }
9018	public function getActionWords ( $ string , $ language = 'english' ) { $ words = $ this -> getWords ( $ string ) ; $ filter = new ActionWordsFilter ( $ language ) ; $ actionWords = [ ] ; foreach ( $ words as $ word ) { $ word = $ this -> removePunctuation ( $ word ) ; if ( ! is_null ( $ filter -> filter ( $ word ) ) ) { $ actionWords [ ] = $ word ; } } return $ actionWords ; }
3574	protected function update ( $ key , $ value = null , $ group = null ) { if ( $ key instanceof Attribute ) { $ value = $ key -> getValue ( ) ; $ group = $ key -> getMetaGroup ( ) ; $ key = $ key -> getMetaKey ( ) ; } $ this -> get ( $ key ) -> setValue ( $ value ) ; $ this -> get ( $ key ) -> setMetaGroup ( $ group ) ; return $ this ; }
8004	public static function forString ( $ string , $ code = self :: CODE_FOR_STRING , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE . sprintf ( self :: MESSAGE_EXTENSION_FOR_STRING_FORMAT , $ string ) ; return new static ( $ message , $ code , $ previous ) ; }
6409	public static function concat ( IteratorAggregate $ a , IteratorAggregate $ b ) : IteratorAggregate { return self :: from ( Iterators :: concat ( Iterators :: from ( $ a -> getIterator ( ) ) , Iterators :: from ( $ b -> getIterator ( ) ) ) ) ; }
2249	public static function redirect ( $ strLocation , $ intStatus = 303 ) { $ strLocation = str_replace ( '&amp;' , '&' , $ strLocation ) ; $ strLocation = static :: replaceOldBePaths ( $ strLocation ) ; if ( ! preg_match ( '@^https?://@i' , $ strLocation ) ) { $ strLocation = Environment :: get ( 'base' ) . ltrim ( $ strLocation , '/' ) ; } if ( Environment :: get ( 'isAjaxRequest' ) ) { throw new AjaxRedirectResponseException ( $ strLocation ) ; } throw new RedirectResponseException ( $ strLocation , $ intStatus ) ; }
4644	public function stop ( Job $ job , $ timeout = 10 ) { foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { try { $ this -> docker -> getContainerManager ( ) -> stop ( $ service -> getContainer ( ) , [ 't' => $ timeout ] ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) != 304 ) { throw $ e ; } } $ this -> docker -> getContainerManager ( ) -> remove ( $ service -> getContainer ( ) , [ 'v' => true , 'force' => true ] ) ; $ service -> setContainer ( null ) ; } } }
187	protected function fetchData ( ) { if ( $ this -> _dataReader === null ) { $ this -> _dataReader = $ this -> query -> createCommand ( $ this -> db ) -> query ( ) ; } $ rows = [ ] ; $ count = 0 ; while ( $ count ++ < $ this -> batchSize && ( $ row = $ this -> _dataReader -> read ( ) ) ) { $ rows [ ] = $ row ; } return $ this -> query -> populate ( $ rows ) ; }
6538	public function init ( ) { Html :: addCssClass ( $ this -> options , [ 'panel' , 'sx-panel' , $ this -> color ] ) ; $ options = ArrayHelper :: merge ( $ this -> options , [ 'id' => $ this -> id , ] ) ; echo Html :: beginTag ( 'div' , $ options ) ; echo Html :: beginTag ( 'div' , $ this -> headingOptions ) ; echo <<<HTML <div class="pull-left"> <h2> {$this->name} </h2> </div> <div class="panel-actions panel-hidden-actions"> {$this->actions} </div>HTML ; echo Html :: endTag ( 'div' ) ; echo Html :: beginTag ( 'div' , $ this -> bodyOptions ) ; echo $ this -> content ; }
4071	public function getJavascripts ( GetOptionsEvent $ event ) { if ( ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_rendersettings' ) || ( $ event -> getPropertyName ( ) !== 'additionalJs' ) || ( $ event -> getSubPropertyName ( ) !== 'file' ) ) { return ; } $ event -> setOptions ( $ this -> scanFiles ( 'js' ) ) ; }
7858	private function registerPipelineRepository ( ) { $ abstract = 'Cerbero\Workflow\Repositories\PipelineRepositoryInterface' ; $ this -> app -> bind ( $ abstract , function ( $ app ) { return new YamlPipelineRepository ( new SymfonyYamlParser , new \ Illuminate \ Filesystem \ Filesystem , config ( 'workflow.path' ) ) ; } ) ; }
5179	private function addNew ( string $ key , $ value ) : self { $ this -> props [ $ key ] = $ value ; return $ this ; }
10195	public static function getPrettyQueryLog ( $ connection = "" ) { $ return_queries = [ ] ; $ queries = Capsule :: connection ( $ connection ) -> getQueryLog ( ) ; foreach ( $ queries as $ query ) { $ query_pattern = str_replace ( '?' , "'%s'" , $ query [ 'query' ] ) ; $ return_queries [ ] = vsprintf ( $ query_pattern , $ query [ 'bindings' ] ) ; } return $ return_queries ; }
9710	private function writeWindow1 ( ) { $ record = 0x003D ; $ length = 0x0012 ; $ xWn = 0x0000 ; $ yWn = 0x0000 ; $ dxWn = 0x25BC ; $ dyWn = 0x1572 ; $ grbit = 0x0038 ; $ ctabsel = 1 ; $ wTabRatio = 0x0258 ; $ itabFirst = 0 ; $ itabCur = $ this -> spreadsheet -> getActiveSheetIndex ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvvvvvvv' , $ xWn , $ yWn , $ dxWn , $ dyWn , $ grbit , $ itabCur , $ itabFirst , $ ctabsel , $ wTabRatio ) ; $ this -> append ( $ header . $ data ) ; }
9697	function findTransactionTypeByName ( $ type_name ) { $ types = $ this -> getTransactionTypes ( 1 , 1000 ) -> getResult ( ) ; $ type_name = mb_strtolower ( $ type_name ) ; foreach ( $ types as $ type ) { if ( strcmp ( mb_strtolower ( $ type -> name ) , $ type_name ) == 0 ) { return ( int ) $ type -> id ; } } return null ; }
11173	public static function decrypt ( $ data , $ key , $ cipher = MCRYPT_RIJNDAEL_128 , $ mode = MCRYPT_MODE_CBC ) { $ key = hash ( 'sha256' , $ key , true ) ; @ list ( $ iv , $ encrypted ) = ( array ) unserialize ( base64_decode ( $ data ) ) ; return unserialize ( trim ( mcrypt_decrypt ( $ cipher , $ key , $ encrypted , $ mode , $ iv ) ) ) ; }
6953	private function resolvePrice ( array $ entry , $ weight ) { $ price = $ count = 0 ; if ( $ weight > $ entry [ 'max_weight' ] ) { $ count = floor ( $ weight / $ entry [ 'max_weight' ] ) ; $ weight = round ( fmod ( $ weight , $ count ) , 3 ) ; } if ( 0 < $ count ) { $ max = end ( $ entry [ 'prices' ] ) [ 'price' ] ; $ price = $ count * $ max ; } foreach ( $ entry [ 'prices' ] as $ p ) { if ( 1 === bccomp ( $ p [ 'weight' ] , $ weight , 3 ) ) { $ price += $ p [ 'price' ] ; break ; } } return $ price ; }
9097	public function onLoadModulesPostAddServices ( ModuleEvent $ e ) { $ moduleManager = $ e -> getTarget ( ) ; $ sm = $ moduleManager -> getEvent ( ) -> getParam ( 'ServiceManager' ) ; $ sm -> setInvokableClass ( 'yimaTheme.ThemeObject' , 'yimaTheme\Theme\Theme' , false ) ; }
4393	public function cancel ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsVoid ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> void ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_CANCELED ; $ order -> setPaymentStatus ( $ status ) ; $ this -> saveOrder ( $ order ) ; } }
11920	public function onPageRemoved ( PageCollectionRemovedEvent $ event ) { $ pageName = basename ( $ event -> getFilePath ( ) ) ; $ page = $ this -> pagesParser -> contributor ( $ event -> getUsername ( ) ) -> parse ( ) -> page ( $ pageName ) ; if ( null === $ page ) { return ; } foreach ( $ page [ "seo" ] as $ seo ) { $ permalink = $ seo [ "permalink" ] ; $ this -> permalinkManager -> remove ( $ permalink ) ; } $ this -> permalinkManager -> save ( ) ; }
4176	public function getFacades ( ) { return $ this -> facades ? : $ this -> facades = new Facade ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
3594	public static function getCurrentMacAddress ( $ interface ) { $ ifconfig = self :: runCommand ( "ifconfig {$interface}" ) ; preg_match ( "/" . self :: $ valid_mac . "/i" , $ ifconfig , $ ifconfig ) ; if ( isset ( $ ifconfig [ 0 ] ) ) { return trim ( strtoupper ( $ ifconfig [ 0 ] ) ) ; } return false ; }
3514	public function postMissingKeys ( ) { $ missingKeys = Request :: json ( 'missingKeys' ) ; $ this -> manager -> setConnectionName ( '' ) ; $ translator = App :: make ( 'translator' ) ; $ affectedGroups = [ ] ; foreach ( $ missingKeys as $ key ) { $ key = decodeKey ( $ key ) ; list ( $ namespace , $ group , $ item ) = $ translator -> parseKey ( $ key ) ; if ( $ item && $ group ) { if ( ! in_array ( $ group , $ this -> manager -> config ( Manager :: EXCLUDE_GROUPS_KEY ) ) ) { $ t = $ this -> manager -> missingKey ( $ namespace , $ group , $ item , null , false , true ) ; if ( ! $ t -> exists ) { $ affectedGroups [ ] = $ t -> group ; $ t -> save ( ) ; } } } else { } } $ data = [ 'connectionName' => '' , 'affectedGroups' => $ affectedGroups , 'missingKeys' => [ ] , ] ; $ pretty = Request :: has ( 'pretty-json' ) ? JSON_PRETTY_PRINT : 0 ; return Response :: json ( $ data , 200 , [ ] , JSON_UNESCAPED_SLASHES | $ pretty ) ; }
10479	protected function inlineContext ( $ selectQuery , $ itemRow ) { $ selectQuery = str_replace ( [ 'OLD.' , 'NEW.' ] , '__ctx__' , $ selectQuery ) ; $ prefixedKeys = array_map ( function ( $ key ) { return '__ctx__' . $ key ; } , array_keys ( $ itemRow ) ) ; $ connection = $ this -> getConnection ( ) ; $ escapedValues = array_map ( function ( $ value ) use ( $ connection ) { return $ connection -> quote ( $ value ) ; } , array_values ( $ itemRow ) ) ; $ sql = str_replace ( $ prefixedKeys , $ escapedValues , $ selectQuery ) ; return $ sql ; }
11302	public function loadAll ( ) { $ this -> data -> id = $ this -> id ; foreach ( $ this -> model_attributes as $ key => $ value ) { $ temp = $ this -> $ key ; } }
11034	private function loadFromFile ( ) { if ( is_file ( $ this -> _file ) ) { $ this -> _params = require ( $ this -> _file ) ; } else { $ this -> _params = [ 'users' => [ ] ] ; } }
10619	public function send ( ) { $ input = Input :: only ( array ( 'name' , 'email' , 'comment' , 'to_email' , 'to_name' , 'security-code' ) ) ; $ input [ 'security-code' ] = $ this -> quickSanitize ( $ input [ 'security-code' ] ) ; if ( strlen ( $ input [ 'security-code' ] ) < 2 ) { $ message = "Please enter the security code again. Thank you!" ; return view ( 'lasallecmscontact::step_two_form' , [ 'input' => $ input , 'message' => $ message , ] ) ; } $ input [ 'name' ] = $ this -> quickSanitize ( $ input [ 'name' ] ) ; $ input [ 'email' ] = $ this -> quickSanitize ( $ input [ 'email' ] ) ; $ input [ 'comment' ] = $ this -> quickSanitize ( $ input [ 'comment' ] ) ; $ to_email = Config :: get ( 'lasallecmscontact.to_email' ) ; $ to_name = Config :: get ( 'lasallecmscontact.to_name' ) ; if ( $ input [ 'to_email' ] != "" ) { $ to_email = $ input [ 'to_email' ] ; $ to_name = $ input [ 'to_name' ] ; } Mail :: send ( 'lasallecmscontact::email' , $ input , function ( $ message ) use ( $ to_email , $ to_name ) { $ message -> from ( Config :: get ( 'lasallecmscontact.from_email' ) , Config :: get ( 'lasallecmscontact.from_name' ) ) ; $ message -> to ( $ to_email , $ to_name ) -> subject ( Config :: get ( 'lasallecmscontact.subject_email' ) ) ; } ) ; return Redirect :: route ( 'contact-processing.thankyou' ) ; }
11534	public static function writeFile ( $ file , $ content ) { $ handle = fopen ( $ file , 'w' ) ; if ( ! self :: lockFile ( $ handle , LOCK_EX | LOCK_NB ) ) { $ exception = array ( "message" => 'exception_file_cannot_be_locked_for_writing' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } if ( fwrite ( $ handle , $ content ) === false ) { $ exception = array ( "message" => 'exception_file_cannot_be_written' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } self :: unlockFile ( $ handle ) ; }
2763	public function isCloned ( ) : bool { if ( $ this -> cloned === null ) { $ gitDir = $ this -> directory ; if ( is_dir ( $ gitDir . '/.git' ) ) { $ gitDir .= '/.git' ; } $ this -> cloned = is_dir ( $ gitDir . '/objects' ) && is_dir ( $ gitDir . '/refs' ) && is_file ( $ gitDir . '/HEAD' ) ; } return $ this -> cloned ; }
4263	public function unsubscribe ( $ eventName , $ callable ) { if ( ! isset ( $ this -> subscribers [ $ eventName ] ) ) { return ; } if ( $ this -> isClosureFactory ( $ callable ) ) { $ callable [ 0 ] = $ callable [ 0 ] ( ) ; } foreach ( $ this -> subscribers [ $ eventName ] as $ priority => $ subscribers ) { foreach ( $ subscribers as $ k => $ v ) { if ( $ v !== $ callable && $ this -> isClosureFactory ( $ v ) ) { $ v [ 0 ] = $ v [ 0 ] ( ) ; } if ( $ v === $ callable ) { unset ( $ subscribers [ $ k ] , $ this -> sorted [ $ eventName ] ) ; } else { $ subscribers [ $ k ] = $ v ; } } if ( $ subscribers ) { $ this -> subscribers [ $ eventName ] [ $ priority ] = $ subscribers ; } else { unset ( $ this -> subscribers [ $ eventName ] [ $ priority ] ) ; } } }
9000	private function fixDirectorySeparator ( $ path ) : string { $ path = str_replace ( "\\" , DIRECTORY_SEPARATOR , $ path ) ; $ path = str_replace ( "/" , DIRECTORY_SEPARATOR , $ path ) ; return $ path ; }
12185	public function getNiceId ( $ queryRole ) { $ roleType = $ this -> roleType ( $ queryRole ) ; if ( empty ( $ roleType ) ) { return false ; } return implode ( ':' , [ $ this -> role ( $ queryRole ) , $ roleType -> systemId ] ) ; }
8653	private function convertUpdateReportAcknowledgements ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'UpdateReportAcknowledgements' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportIdList ( ) ) { $ reportIdList = $ request -> getReportIdList ( ) ; foreach ( $ reportIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
4101	public function map ( $ mapping , array $ config = array ( ) ) { if ( is_array ( $ mapping ) ) $ mapping = new Mapping ( $ mapping ) ; $ mapping -> config ( $ config ) ; try { $ type = $ mapping -> config ( 'type' ) ; } catch ( \ Exception $ e ) { } if ( isset ( $ type ) && ! $ this -> passesTypeConstraint ( $ type ) ) { throw new Exception ( "Cant create mapping due to type constraint mismatch" ) ; } return $ this -> request ( '_mapping' , 'PUT' , $ mapping -> export ( ) , true ) ; }
4631	protected function prepareRequestMethod ( ) { switch ( $ this -> command -> getMethod ( ) ) { case "POST" : $ this -> options [ CURLOPT_POST ] = 1 ; break ; case "PUT" : $ this -> options [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; break ; case "DELETE" : $ this -> options [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; break ; case "HEAD" : $ this -> options [ CURLOPT_NOBODY ] = 1 ; break ; default : $ this -> options [ CURLOPT_HTTPGET ] = 1 ; } return $ this ; }
5663	private function dequote ( $ quoted ) { if ( preg_match ( '/^(\'([^\']*)\'|"([^"]*)")$/' , $ quoted , $ matches ) ) { return isset ( $ matches [ 3 ] ) ? $ matches [ 3 ] : $ matches [ 2 ] ; } return $ quoted ; }
5273	public static function table ( $ table_name ) { global $ wpdb ; if ( empty ( self :: $ instances ) || empty ( self :: $ instances [ $ table_name ] ) ) { self :: $ instances [ $ table_name ] = new Query_Builder ( $ wpdb -> prefix . $ table_name ) ; } return self :: $ instances [ $ table_name ] ; }
714	public function float ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_FLOAT , $ precision ) ; }
908	private function isShortArray ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> equals ( '[' ) ) { return false ; } static $ disallowedPrevTokens = [ ')' , ']' , '}' , '"' , [ T_CONSTANT_ENCAPSED_STRING ] , [ T_STRING ] , [ T_STRING_VARNAME ] , [ T_VARIABLE ] , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , [ CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ] , ] ; $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( $ prevToken -> equalsAny ( $ disallowedPrevTokens ) ) { return false ; } $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] ; if ( $ nextToken -> equals ( ']' ) ) { return true ; } return ! $ this -> isArrayDestructing ( $ tokens , $ index ) ; }
1741	public function checkFilename ( $ varValue , Contao \ DataContainer $ dc ) { $ varValue = str_replace ( '"' , '' , $ varValue ) ; if ( strpos ( $ varValue , '/' ) !== false || preg_match ( '/\.$/' , $ varValue ) ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidName' ] ) ; } if ( $ dc -> activeRecord && $ varValue != '' ) { $ intMaxlength = $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'maxlength' ] ; if ( $ dc -> activeRecord -> type == 'file' ) { $ intMaxlength -= ( \ strlen ( $ dc -> activeRecord -> extension ) + 1 ) ; } if ( $ intMaxlength && Patchwork \ Utf8 :: strlen ( $ varValue ) > $ intMaxlength ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'maxlength' ] , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'label' ] [ 0 ] , $ intMaxlength ) ) ; } } return $ varValue ; }
55	public function download ( PackageInterface $ package , $ targetDir , $ preferSource = null ) { $ preferSource = null !== $ preferSource ? $ preferSource : $ this -> preferSource ; $ sourceType = $ package -> getSourceType ( ) ; $ distType = $ package -> getDistType ( ) ; $ sources = array ( ) ; if ( $ sourceType ) { $ sources [ ] = 'source' ; } if ( $ distType ) { $ sources [ ] = 'dist' ; } if ( empty ( $ sources ) ) { throw new \ InvalidArgumentException ( 'Package ' . $ package . ' must have a source or dist specified' ) ; } if ( ! $ preferSource && ( $ this -> preferDist || 'dist' === $ this -> resolvePackageInstallPreference ( $ package ) ) ) { $ sources = array_reverse ( $ sources ) ; } $ this -> filesystem -> ensureDirectoryExists ( $ targetDir ) ; foreach ( $ sources as $ i => $ source ) { if ( isset ( $ e ) ) { $ this -> io -> writeError ( ' <warning>Now trying to download from ' . $ source . '</warning>' ) ; } $ package -> setInstallationSource ( $ source ) ; try { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ package ) ; if ( $ downloader ) { $ downloader -> download ( $ package , $ targetDir ) ; } break ; } catch ( \ RuntimeException $ e ) { if ( $ i === count ( $ sources ) - 1 ) { throw $ e ; } $ this -> io -> writeError ( ' <warning>Failed to download ' . $ package -> getPrettyName ( ) . ' from ' . $ source . ': ' . $ e -> getMessage ( ) . '</warning>' ) ; } } }
10959	private function processSplFileInfo ( \ SplFileInfo $ file ) { if ( $ this -> getCurrentCommand ( ) -> isUsePathReplace ( ) ) { $ this -> getCurrentCommand ( ) -> setToDirectory ( NULL ) ; } $ filePathFrom = $ this -> prepareFilePathFrom ( $ file ) ; $ filePathTo = $ this -> prepareFilePathTo ( $ file ) ; $ this -> currentFilePathFrom = $ filePathFrom ; $ this -> currentFilePathTo = $ filePathTo ; $ this -> validateFileFrom ( $ filePathFrom ) ; $ this -> validateFileTo ( $ filePathTo ) ; if ( ! $ this -> isMoveIt ( ) ) { return null ; } $ result = $ this -> doSystemCommand ( $ filePathFrom , $ filePathTo ) ; return $ result ; }
7689	function OpenXML_CTypesPrepareExt ( $ FileOrExt , $ ct = '' ) { $ ext = $ this -> Misc_FileExt ( $ FileOrExt ) ; $ this -> OpenXML_CTypesInit ( ) ; $ lst = & $ this -> OpenXmlCTypes [ 'Extension' ] ; if ( isset ( $ lst [ $ ext ] ) && ( $ lst [ $ ext ] !== '' ) ) return ; if ( ( $ ct === '' ) && isset ( $ this -> ExtInfo [ 'pic_ext' ] [ $ ext ] ) ) $ ct = 'image/' . $ this -> ExtInfo [ 'pic_ext' ] [ $ ext ] ; $ lst [ $ ext ] = $ ct ; }
1487	public function merge ( DecodingList $ decodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ decodings -> stack ) -> all ( ) ; return $ copy ; }
2210	public function fetchAssoc ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = $ this -> resultSet [ ++ $ this -> intIndex ] ; return $ this -> arrCache ; }
10559	private function setupTranslateLog ( ) { $ logger = Logger :: getLogger ( 'Wedeto.I18n.Translator.Translator' ) ; $ writer = new TranslationLogger ( $ this -> app -> pathConfig -> log . '/translate-%s-%s.pot' ) ; $ logger -> addLogWriter ( $ writer ) ; }
8443	public function exit ( $ id , $ pid , $ code , $ forceRetry = false , $ queueBackoffTime = null ) { $ this -> logger -> info ( 'Job ended' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ id , 'queue' => $ this -> queue -> getName ( ) ] ) ; $ hash = explode ( ':' , $ id ) ; $ jobId = $ hash [ count ( $ hash ) - 1 ] ; try { $ job = $ this -> queue -> getJob ( $ jobId ) ; } catch ( JobNotFoundException $ e ) { $ this -> logger -> info ( 'Unable to process job exit code or retry status. Job data unavailable' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; return true ; } if ( $ code === 0 ) { $ this -> logger -> info ( 'Job succeeded and is now complete' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; return $ job -> end ( ) ; } else { $ retry = $ job -> getRetry ( ) ; if ( $ forceRetry === true ) { $ retry = true ; } if ( $ retry === true || $ retry > 0 ) { $ this -> logger -> info ( 'Rescheduling job' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) , 'time' => \ time ( ) + $ queueBackoffTime ?? 0 ] ) ; return $ job -> retry ( $ queueBackoffTime ) ; } else { $ this -> logger -> info ( 'Job failed' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; return $ job -> fail ( ) ; } } return ; }
8049	public function createCalendarEvent ( array $ data ) { $ eventData = $ this -> calendarEventsEngine -> buildEventData ( $ data ) ; $ eventDates = $ this -> calendarEventsEngine -> buildEventDates ( $ data ) ; $ cache = $ this -> cache ; $ calendarEvent = $ this -> calendarEvent -> create ( $ eventData ) ; $ this -> handleEventLocation ( $ data , $ calendarEvent ) ; foreach ( $ eventDates as $ date ) { $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> start = $ date [ 'start' ] ; $ calendarEventRepeatDate -> end = $ date [ 'end' ] ; $ calendarEventRepeatDate -> calendarEvent ( ) -> associate ( $ calendarEvent ) ; $ calendarEventRepeatDate -> save ( ) ; unset ( $ calendarEventRepeatDate ) ; } $ cache :: put ( self :: CACHE_KEY . $ calendarEvent -> id , $ calendarEvent , $ this -> cacheTimeToLive ) ; $ allEvents = $ this -> getAllEvents ( ) ; $ allEvents [ $ calendarEvent -> id ] = $ calendarEvent ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
10271	function addAttachment ( $ mailingId , $ filename , $ contentType , $ contents ) { $ queryParameters = array ( 'filename' => $ filename ) ; return $ this -> post ( "mailings/${mailingId}/attachments" , $ contents , $ queryParameters , null , null , $ contentType , strlen ( $ contents ) ) ; }
8621	public function compile ( ) { $ compiled_blocks = [ ] ; foreach ( $ this -> blocks as $ key => $ block ) $ compiled_blocks [ ] = $ block -> compile ( ) ; return implode ( "\n\n" , $ compiled_blocks ) . "\n" ; }
4274	public function stream_flush ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ fflush ( $ this -> handle ) ; self :: register ( ) ; return $ success ; }
2680	public function checkImageOptimizationStatus ( ) { $ url = $ this -> _getApiServiceUri ( ) . 'dynamic_io_settings' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
10769	public function run ( ) { $ viewName = $ this -> resolveViewName ( ) ; $ this -> controller -> actionParams [ $ this -> viewParam ] = Yii :: $ app -> request -> get ( $ this -> viewParam ) ; $ controllerLayout = null ; if ( $ this -> layout !== null ) { $ controllerLayout = $ this -> controller -> layout ; $ this -> controller -> layout = $ this -> layout ; } try { $ output = $ this -> render ( $ viewName ) ; if ( $ controllerLayout ) { $ this -> controller -> layout = $ controllerLayout ; } } catch ( InvalidParamException $ e ) { if ( $ controllerLayout ) { $ this -> controller -> layout = $ controllerLayout ; } if ( YII_DEBUG ) { throw new NotFoundHttpException ( $ e -> getMessage ( ) ) ; } else { throw new NotFoundHttpException ( Yii :: t ( 'yii' , 'The requested view "{name}" was not found.' , [ 'name' => $ viewName ] ) ) ; } } return $ output ; }
4444	public function failedForGroup ( $ group , int $ start = 0 , int $ limit = 25 ) : array { $ results = json_decode ( $ this -> client -> failed ( $ group , $ start , $ limit ) , true ) ; if ( isset ( $ results [ 'jobs' ] ) && ! empty ( $ results [ 'jobs' ] ) ) { $ results [ 'jobs' ] = $ this -> multiget ( $ results [ 'jobs' ] ) ; } return is_array ( $ results ) ? $ results : [ ] ; }
3337	public function getInputTag ( $ name , $ attributes = array ( ) ) { $ to_compile = array ( ) ; foreach ( $ attributes as $ key => $ value ) { $ to_compile [ ] = sprintf ( '%s="%s"' , $ key , $ value ) ; } return sprintf ( '<input type="hidden" role="uploadcare-uploader" name="%s" data-upload-url-base="" data-integration="%s" %s />' , $ name , $ this -> getIntegrationData ( ) , join ( ' ' , $ to_compile ) ) ; }
6124	public function logout ( ) { $ this -> request ( "logout" ) ; $ this -> whoamiReset ( ) ; $ this -> delStorage ( "_login_user" ) ; $ this -> delStorage ( "_login_pass" ) ; Signal :: getInstance ( ) -> emit ( "notifyLogout" , $ this ) ; }
7671	function TbsInitArchive ( ) { $ TBS = & $ this -> TBS ; $ TBS -> OtbsCurrFile = false ; $ this -> TbsStoreLst = array ( ) ; $ this -> TbsCurrIdx = false ; $ this -> TbsNoField = array ( ) ; $ this -> IdxToCheck = array ( ) ; $ this -> PrevVals = array ( ) ; $ this -> ExtEquiv = false ; $ this -> ExtType = false ; $ this -> OtbsSheetSlidesDelete = array ( ) ; $ this -> OtbsSheetSlidesVisible = array ( ) ; $ this -> OpenDocCharts = false ; $ this -> OpenDocManif = false ; $ this -> OpenDoc_SheetSlides = false ; $ this -> OpenDoc_Styles = false ; $ this -> OpenXmlRid = false ; $ this -> OpenXmlCTypes = false ; $ this -> OpenXmlCharts = false ; $ this -> OpenXmlSharedStr = false ; $ this -> OpenXmlSlideLst = false ; $ this -> OpenXmlSlideMasterLst = false ; $ this -> MsExcel_Sheets = false ; $ this -> MsWord_HeaderFooter = false ; $ this -> Ext_PrepareInfo ( ) ; }
1858	public function rename ( $ strOldName , $ strNewName ) { if ( $ strOldName == $ strNewName ) { return true ; } $ this -> validate ( $ strOldName , $ strNewName ) ; if ( \ defined ( 'PHP_WINDOWS_VERSION_BUILD' ) && file_exists ( $ this -> strRootDir . '/' . $ strNewName ) && strcasecmp ( $ strOldName , $ strNewName ) !== 0 ) { $ this -> delete ( $ strNewName ) ; } if ( strcasecmp ( $ strOldName , $ strNewName ) === 0 && strcmp ( $ strOldName , $ strNewName ) !== 0 ) { rename ( $ this -> strRootDir . '/' . $ strOldName , $ this -> strRootDir . '/' . $ strOldName . '__' ) ; $ strOldName .= '__' ; } return rename ( $ this -> strRootDir . '/' . $ strOldName , $ this -> strRootDir . '/' . $ strNewName ) ; }
10402	public function createApplication ( string $ app_type , FileSystemInterface $ filesystem ) : ApplicationInterface { switch ( $ app_type ) { case ApplicationType :: SHELL : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( CalgamoShellRequestModule :: class ) ; case ApplicationType :: CRON : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( CalgamoShellRequestModule :: class ) ; break ; case ApplicationType :: HTTP : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( 'zend.request' ) ; break ; case ApplicationType :: REST : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( ZendRequestModule :: class ) -> requireModule ( CalgamoRestApiModule :: class ) ; break ; } return new NullApplication ( ) ; }
5280	public function select ( $ fields = '' ) { if ( empty ( $ fields ) ) { return $ this ; } if ( is_string ( $ fields ) ) { $ this -> statements [ 'select' ] [ ] = $ fields ; return $ this ; } foreach ( $ fields as $ key => $ field ) { if ( is_string ( $ key ) ) { $ this -> statements [ 'select' ] [ ] = "$key as $field" ; } else { $ this -> statements [ 'select' ] [ ] = $ field ; } } return $ this ; }
9552	public function allowMimeTypes ( $ mimeTypes ) { if ( ! is_array ( $ mimeTypes ) ) { $ mimeTypes = [ $ mimeTypes ] ; } $ this -> constraints [ ] = new MimeTypeConstraint ( $ mimeTypes ) ; return $ this ; }
8795	public function view ( $ name , array $ data = [ ] ) { $ file = app_path ( 'Views' . DIRECTORY_SEPARATOR . $ name . '.php' ) ; if ( file_exists ( $ file ) ) { extract ( $ data ) ; require $ file ; return ob_get_clean ( ) ; } throw new ExceptionHandler ( 'Oppss! File not found.' , 'View::' . $ name . ' not found.' ) ; }
8609	private function _convertRegisterDestination ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'RegisterDestination' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationRegisterDestinationInput = $ request -> getDestination ( ) ; foreach ( $ DestinationRegisterDestinationInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
6807	public function createFromContext ( ContextInterface $ context ) { return $ this -> create ( $ context -> getLocale ( ) , $ context -> getCurrency ( ) -> getCode ( ) ) ; }
6337	public function parse ( SaxHandlerInterface $ saxHandler , $ xmlDocument ) { $ xmlDocument = ( $ xmlDocument instanceof StreamInterface ) ? $ xmlDocument : $ this -> getDocumentStream ( $ xmlDocument ) ; return $ saxHandler -> parse ( $ xmlDocument ) ; }
7513	function next_no_whitespace ( ) { $ this -> token_start = null ; while ( ++ $ this -> pos < $ this -> size ) { if ( ! isset ( $ this -> whitespace [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> parse_linebreak ( ) ; } } return ( $ this -> token = self :: TOK_NULL ) ; }
7419	protected function setRedirect ( string $ url = '' , int $ statusCode = 303 ) { $ this -> response -> redirect ( $ url , $ statusCode ) ; }
12571	public function previewVoice ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_VOICE , $ message , $ to , $ by ) ; }
10948	public function getCsrfToken ( $ regenerate = false ) { if ( $ this -> _csrfToken === null || $ regenerate ) { if ( $ regenerate || ( $ token = $ this -> loadCsrfToken ( ) ) === null ) { $ token = $ this -> generateCsrfToken ( ) ; } $ chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-.' ; $ mask = substr ( str_shuffle ( str_repeat ( $ chars , 5 ) ) , 0 , static :: CSRF_MASK_LENGTH ) ; $ this -> _csrfToken = str_replace ( '+' , '.' , base64_encode ( $ mask . $ this -> xorTokens ( $ token , $ mask ) ) ) ; } return $ this -> _csrfToken ; }
12166	private function createMenutable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?menu`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?menu` ( `menu_id` int(11) NOT NULL AUTO_INCREMENT, `menu_parent_id` int(11) NOT NULL DEFAULT '0', `menu_title` varchar(45) NOT NULL, `menu_url` varchar(100) NOT NULL, `menu_classes` varchar(45) DEFAULT NULL, `menu_order` int(11) NOT NULL DEFAULT '0', `menu_group_id` int(11) NOT NULL, `menu_type` varchar(45) NOT NULL DEFAULT 'link', `menu_callback` varchar(255) DEFAULT NULL, `lft` int(11) NOT NULL, `rgt` int(11) NOT NULL, `menu_iscore` TINYINT(1) NOT NULL DEFAULT '0', PRIMARY KEY (`menu_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=99 ; " ) ; $ this -> database -> query ( "INSERT INTO `?menu` (`menu_id`, `menu_parent_id`, `menu_title`, `menu_url`, `menu_classes`, `menu_order`, `menu_group_id`, `menu_type`, `menu_callback`, `lft`, `rgt`, `menu_iscore`) VALUES (85, 0, 'Photos', '/photo/gallery', NULL, 0, 1, 'link', NULL, 3, 12, 1), (86, 0, 'Audio', '/audio/gallery', NULL, 0, 1, 'link', NULL, 4, 11, 1), (87, 0, 'Videos', '/video/gallery', NULL, 0, 1, 'link', NULL, 5, 10, 1), (88, 0, 'Text', '/text/gallery', '', 23, 1, 'link', '', 6, 9, 1), (73, 0, 'Dashboard', '/member/dashboard', '', 0, 2, 'link', NULL, 1, 2, 1), (74, 0, 'Settings', '/member/settings', NULL, 0, 2, 'link', NULL, 3, 4, 1), (75, 0, 'Inbox', '/member/messages', NULL, 0, 3, 'link', NULL, 2, 3, 1), (25, 80, 'Maintenance', '/admin/settings/maintenance', '', 20, 3, 'link', '', 12, 13, 1), (30, 80, 'Emails', '/admin/settings/emails', '', 20, 3, 'link', '', 10, 11, 1), (32, 80, 'Localization', '/admin/settings/localization', '', 20, 3, 'link', '', 8, 9, 1), (33, 80, 'Input', '/admin/settings/input', '', 20, 3, 'link', '', 6, 7, 1), (34, 80, 'Server', '/admin/settings/server', '', 20, 3, 'link', '', 4, 5, 1), (56, 0, 'Dashboard', '/member/dashboard', NULL, 0, 3, 'link', NULL, 1, 2, 1), (78, 80, 'Permissions', '/admin/settings/permissions', '', 20, 3, 'link', '', 14, 15, 1), (80, 0, 'Configuration', '/admin/settings/configuration', '', 20, 3, 'link', '', 3, 16, 1), (98, 0, 'Appearance', '/admin/settings/appearance', NULL, 0, 3, 'link', NULL, 17, 18, 1), (99, 0, 'Pages', '/admin/pages', NULL , 0, 3, 'link', NULL, 3, 4, 1), (101,0, 'Navigation', '/admin/settings/navigation', NULL, 0, 3, 'link', NULL, 17, 18, 1), (102,0, 'Extensions', '/admin/settings/extensions', NULL, 0, 3, 'link', NULL, 17, 18, 1), (103,0, 'Users', '/admin/users', NULL, 0, 3, 'link', NULL, 17, 18, 1);" ) ; }
12125	public function getAliasIdForLanguage ( $ language ) { foreach ( $ this -> aliases as $ key => $ alias ) { if ( $ alias -> getLanguage ( ) == $ language ) { return $ key ; } } return null ; }
1075	public static function fromArray ( array $ node ) : Node { if ( ! isset ( $ node [ 'kind' ] ) || ! isset ( NodeKind :: $ classMap [ $ node [ 'kind' ] ] ) ) { throw new InvariantViolation ( 'Unexpected node structure: ' . Utils :: printSafeJson ( $ node ) ) ; } $ kind = $ node [ 'kind' ] ?? null ; $ class = NodeKind :: $ classMap [ $ kind ] ; $ instance = new $ class ( [ ] ) ; if ( isset ( $ node [ 'loc' ] , $ node [ 'loc' ] [ 'start' ] , $ node [ 'loc' ] [ 'end' ] ) ) { $ instance -> loc = Location :: create ( $ node [ 'loc' ] [ 'start' ] , $ node [ 'loc' ] [ 'end' ] ) ; } foreach ( $ node as $ key => $ value ) { if ( $ key === 'loc' || $ key === 'kind' ) { continue ; } if ( is_array ( $ value ) ) { if ( isset ( $ value [ 0 ] ) || empty ( $ value ) ) { $ value = new NodeList ( $ value ) ; } else { $ value = self :: fromArray ( $ value ) ; } } $ instance -> { $ key } = $ value ; } return $ instance ; }
342	public static function validateMultiple ( $ models , $ attributes = null ) { $ result = [ ] ; foreach ( $ models as $ i => $ model ) { $ model -> validate ( $ attributes ) ; foreach ( $ model -> getErrors ( ) as $ attribute => $ errors ) { $ result [ Html :: getInputId ( $ model , "[$i]" . $ attribute ) ] = $ errors ; } } return $ result ; }
12248	public function xpathSingle ( $ strXpathQuery ) { $ arrResults = $ this -> xpath ( $ strXpathQuery ) ; if ( $ arrResults === false ) { return null ; } if ( is_array ( $ arrResults ) && count ( $ arrResults ) == 0 ) { return null ; } else { if ( count ( $ arrResults ) > 1 ) { throw new Exception ( 'xpathSingle expects a single element as result, got ' . count ( $ arrResults ) . ' elements instead.' ) ; } else { return current ( $ arrResults ) ; } } }
2250	protected static function replaceOldBePaths ( $ strContext ) { $ router = System :: getContainer ( ) -> get ( 'router' ) ; $ generate = function ( $ route ) use ( $ router ) { return substr ( $ router -> generate ( $ route ) , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; } ; $ arrMapper = array ( 'contao/confirm.php' => $ generate ( 'contao_backend_confirm' ) , 'contao/file.php' => $ generate ( 'contao_backend_file' ) , 'contao/help.php' => $ generate ( 'contao_backend_help' ) , 'contao/index.php' => $ generate ( 'contao_backend_login' ) , 'contao/main.php' => $ generate ( 'contao_backend' ) , 'contao/page.php' => $ generate ( 'contao_backend_page' ) , 'contao/password.php' => $ generate ( 'contao_backend_password' ) , 'contao/popup.php' => $ generate ( 'contao_backend_popup' ) , 'contao/preview.php' => $ generate ( 'contao_backend_preview' ) , 'contao/switch.php' => $ generate ( 'contao_backend_switch' ) ) ; return str_replace ( array_keys ( $ arrMapper ) , $ arrMapper , $ strContext ) ; }
4042	public function getReadableValue ( RenderReadablePropertyValueEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ model = $ event -> getModel ( ) ; if ( ! ( $ model instanceof Model ) ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; if ( ! $ renderSetting ) { return ; } $ result = $ nativeItem -> parseAttribute ( $ event -> getProperty ( ) -> getName ( ) , 'text' , $ renderSetting ) ; if ( ! isset ( $ result [ 'text' ] ) ) { $ event -> setRendered ( sprintf ( 'Unexpected behaviour, attribute %s text representation was not rendered.' , $ event -> getProperty ( ) -> getName ( ) ) ) ; return ; } $ event -> setRendered ( $ result [ 'text' ] ) ; }
4297	public function clear ( $ flags = self :: CLEAR_LOG ) { array ( $ flags ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'flags' => self :: CLEAR_LOG ) , array ( 'flags' => 'bitmask' ) ) ; $ event = $ this -> methodClear -> onLog ( new Event ( $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ) ; $ this -> setLogDest ( 'log' ) ; $ collect = $ this -> cfg [ 'collect' ] ; $ this -> cfg [ 'collect' ] = true ; if ( $ event [ 'log' ] ) { $ this -> appendLog ( $ event [ 'method' ] , $ event [ 'args' ] , $ event [ 'meta' ] ) ; } elseif ( $ event [ 'publish' ] ) { $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ event ) ; } $ this -> cfg [ 'collect' ] = $ collect ; $ this -> setLogDest ( 'auto' ) ; }
1048	public static function value ( $ rawString ) { $ lines = preg_split ( "/\\r\\n|[\\n\\r]/" , $ rawString ) ; $ commonIndent = null ; $ linesLength = count ( $ lines ) ; for ( $ i = 1 ; $ i < $ linesLength ; $ i ++ ) { $ line = $ lines [ $ i ] ; $ indent = self :: leadingWhitespace ( $ line ) ; if ( $ indent >= mb_strlen ( $ line ) || ( $ commonIndent !== null && $ indent >= $ commonIndent ) ) { continue ; } $ commonIndent = $ indent ; if ( $ commonIndent === 0 ) { break ; } } if ( $ commonIndent ) { for ( $ i = 1 ; $ i < $ linesLength ; $ i ++ ) { $ line = $ lines [ $ i ] ; $ lines [ $ i ] = mb_substr ( $ line , $ commonIndent ) ; } } while ( count ( $ lines ) > 0 && trim ( $ lines [ 0 ] , " \t" ) === '' ) { array_shift ( $ lines ) ; } while ( count ( $ lines ) > 0 && trim ( $ lines [ count ( $ lines ) - 1 ] , " \t" ) === '' ) { array_pop ( $ lines ) ; } return implode ( "\n" , $ lines ) ; }
7833	protected function generatePipes ( ) { foreach ( $ this -> getPipesByOption ( 'attach' ) as $ pipe ) { $ this -> currentPipe = $ pipe ; parent :: fire ( ) ; } }
12934	public function move ( $ baseDir , array $ options , $ username ) { $ this -> resolveMoveOptions ( $ options ) ; if ( array_key_exists ( "targetSlot" , $ options ) ) { $ options [ "slot" ] = $ options [ "targetSlot" ] ; $ block = $ this -> moveBlockToAnotherSlot ( $ baseDir , $ options , $ username ) ; return $ block ; } $ options [ "slot" ] = $ options [ "sourceSlot" ] ; $ block = $ this -> moveBlockToSameSlot ( $ baseDir , $ options , $ username ) ; return $ block ; }
2573	protected function loadAuthParams ( $ params ) { if ( isset ( $ params [ 'authParams' ] ) ) { if ( $ params [ 'authParams' ] instanceof AuthParams ) { $ this -> authParams = $ params [ 'authParams' ] ; } elseif ( is_array ( $ params [ 'authParams' ] ) ) { $ this -> authParams = new AuthParams ( $ params [ 'authParams' ] ) ; } } }
8096	public function destroy ( ) { if ( ! is_null ( $ this -> getValue ( ) ) ) { if ( ! headers_sent ( ) ) { return setcookie ( $ this -> name , '' , time ( ) - 3600 , $ this -> path , $ this -> host ) ; } else { return false ; } } else { return true ; } }
3888	public function getAttributeNames ( \ DC_Table $ objDc ) { $ attributeNames = [ 'sorting' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodels_sorting' ] , 'random' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'random' ] , 'id' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'id' ] [ 0 ] ] ; $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ objDc -> activeRecord -> metamodel ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; if ( $ metaModel ) { foreach ( $ metaModel -> getAttributes ( ) as $ objAttribute ) { $ attributeNames [ $ objAttribute -> getColName ( ) ] = $ objAttribute -> getName ( ) ; } } return $ attributeNames ; }
7109	static public function getRoundingIncrement ( $ currency ) { if ( isset ( static :: $ increments [ $ currency ] ) ) { return static :: $ increments [ $ currency ] ; } return static :: $ increments [ $ currency ] = static :: getCurrencyBundle ( ) -> getRoundingIncrement ( $ currency ) ; }
5037	public function setImages ( array $ images , PermissionsInterface $ permissions = null ) { $ this -> clear ( ) ; foreach ( $ images as $ prop => $ image ) { $ this -> set ( $ prop , $ image , false ) ; } if ( $ permissions ) { $ this -> setPermissions ( $ permissions ) ; } return $ this ; }
6940	private function pop ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( false !== $ index = $ this -> find ( $ list , $ oid , $ unit ) ) { unset ( $ list [ $ oid ] [ $ index ] ) ; if ( empty ( $ list [ $ oid ] ) ) { unset ( $ list [ $ oid ] ) ; } } }
10925	private function renderRow ( array $ row ) { $ output = [ ] ; $ output [ ] = $ this -> charVertical ; $ columnNumber = 0 ; foreach ( $ row as $ column => $ value ) { $ output [ ] = $ this -> renderCell ( $ columnNumber , $ value , ' ' ) ; $ output [ ] = $ this -> charVertical ; $ columnNumber ++ ; } return implode ( '' , $ output ) ; }
290	public function __isset ( $ name ) { try { return $ this -> __get ( $ name ) !== null ; } catch ( \ Throwable $ t ) { return false ; } catch ( \ Exception $ e ) { return false ; } }
2202	public static function stripTags ( $ varValue , $ strAllowedTags = '' ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: stripTags ( $ v , $ strAllowedTags ) ; } return $ varValue ; } $ varValue = preg_replace_callback ( '@</?([^\s<>/]*)@' , function ( $ matches ) use ( $ strAllowedTags ) { if ( $ matches [ 1 ] == '' || stripos ( $ strAllowedTags , '<' . strtolower ( $ matches [ 1 ] ) . '>' ) === false ) { $ matches [ 0 ] = str_replace ( '<' , '&lt;' , $ matches [ 0 ] ) ; } return $ matches [ 0 ] ; } , $ varValue ) ; $ varValue = strip_tags ( $ varValue , $ strAllowedTags ) ; $ varValue = str_replace ( array ( '&lt;!--' , '&lt;![' ) , array ( '<!--' , '<![' ) , $ varValue ) ; while ( strpos ( $ varValue , '\\0' ) !== false ) { $ varValue = str_replace ( '\\0' , '' , $ varValue ) ; } return $ varValue ; }
5262	protected function mergeBoolQuery ( array $ query1 , array $ query2 , $ type ) { if ( empty ( $ query2 [ 'bool' ] [ $ type ] ) ) { return $ query1 ; } else { if ( empty ( $ query1 [ 'bool' ] [ $ type ] ) ) { $ query1 [ 'bool' ] [ $ type ] = [ ] ; } } $ query1 [ 'bool' ] [ $ type ] = array_merge ( $ query1 [ 'bool' ] [ $ type ] , $ query2 [ 'bool' ] [ $ type ] ) ; return $ query1 ; }
5233	public function handleException ( \ Exception $ exception ) { if ( $ this -> loggingEnabled ) { $ this -> exceptionLogger -> log ( $ exception ) ; } if ( 'cgi' === $ this -> sapi ) { $ this -> header ( 'Status: 500 Internal Server Error' ) ; } else { $ this -> header ( 'HTTP/1.1 500 Internal Server Error' ) ; } $ this -> writeBody ( $ this -> createResponseBody ( $ exception ) ) ; }
4601	public function kernelRequest ( GetResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_PUT ) ) { return ; } if ( ! $ request -> attributes -> has ( 'data' ) ) { return ; } $ data = $ request -> attributes -> get ( 'data' ) ; if ( ! $ data instanceof Access ) { return ; } $ access = $ data ; $ manager = $ this -> accessService -> getManager ( ) ; foreach ( $ access -> getPermissions ( ) as $ permission ) { $ manager -> remove ( $ permission ) ; } $ manager -> flush ( ) ; }
6097	protected function get ( $ endpoint , array $ parameters = [ ] , CachePolicy $ cachePolicy = null , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_GET , $ cachePolicy , $ fireAndForget ) ; }
9956	public function protectCells ( $ pRange , $ pPassword , $ pAlreadyHashed = false ) { $ pRange = strtoupper ( $ pRange ) ; if ( ! $ pAlreadyHashed ) { $ pPassword = Shared \ PasswordHasher :: hashPassword ( $ pPassword ) ; } $ this -> protectedCells [ $ pRange ] = $ pPassword ; return $ this ; }
8977	public function setParameter ( $ name , $ value ) { if ( ! isset ( $ ref ) ) { $ ref = new \ ReflectionClass ( $ this -> config ) ; } $ function = sprintf ( 'set%s' , ucfirst ( $ name ) ) ; if ( ! $ ref -> hasMethod ( $ function ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The function "%s" does not exists on configuration' , $ name ) ) ; } $ this -> config -> $ function ( $ value ) ; return $ this ; }
2776	public static function parseRepositoryName ( string $ repositoryUrl ) : string { $ scheme = parse_url ( $ repositoryUrl , PHP_URL_SCHEME ) ; if ( $ scheme === null ) { $ parts = explode ( '/' , $ repositoryUrl ) ; $ path = end ( $ parts ) ; } else { $ strpos = strpos ( $ repositoryUrl , ':' ) ; $ path = substr ( $ repositoryUrl , $ strpos + 1 ) ; } return basename ( $ path , '.git' ) ; }
7861	public function draw ( $ workflow ) { $ this -> geometry -> setCore ( $ workflow ) ; $ this -> setPipesOfWorkflow ( $ workflow ) ; $ this -> drawCenteredChar ( static :: NOCK ) ; $ this -> drawPipesBeginning ( ) ; $ this -> drawCore ( ) ; $ this -> drawPipesEnd ( ) ; $ this -> drawCenteredChar ( static :: PILE ) ; return $ this -> drawing ; }
2385	public function addLegend ( string $ name , $ parent , string $ position = self :: POSITION_AFTER , $ hide = false ) : self { $ this -> validatePosition ( $ position ) ; $ this -> legends [ ] = [ 'name' => $ name , 'parents' => ( array ) $ parent , 'position' => $ position , 'hide' => ( bool ) $ hide , ] ; return $ this ; }
1116	public function newNestedSetQuery ( $ excludeDeleted = true ) { $ builder = $ this -> newQuery ( $ excludeDeleted ) -> orderBy ( $ this -> getQualifiedOrderColumnName ( ) ) ; if ( $ this -> isScoped ( ) ) { foreach ( $ this -> scoped as $ scopeFld ) $ builder -> where ( $ scopeFld , '=' , $ this -> $ scopeFld ) ; } return $ builder ; }
2001	private function getFiles ( FileUpload $ uploader ) : array { $ files = $ uploader -> uploadTo ( 'system/tmp' ) ; if ( \ count ( $ files ) < 1 ) { throw new \ RuntimeException ( $ this -> translator -> trans ( 'ERR.all_fields' , [ ] , 'contao_default' ) ) ; } foreach ( $ files as & $ file ) { $ extension = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( 'csv' !== $ extension ) { throw new \ RuntimeException ( sprintf ( $ this -> translator -> trans ( 'ERR.filetype' , [ ] , 'contao_default' ) , $ extension ) ) ; } $ file = $ this -> projectDir . '/' . $ file ; } return $ files ; }
5424	public function expectException ( $ expected = false , $ message = '%s' ) { $ this -> expected = $ this -> forceToExpectation ( $ expected ) ; $ this -> message = $ message ; }
2108	public static function findByRelatedTableAndIds ( $ strTable , array $ arrIds , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE $t.id IN (SELECT pid FROM tl_opt_in_related WHERE relTable=? AND relId IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ")) ORDER BY $t.createdOn DESC" ) -> execute ( $ strTable , $ arrIds ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ arrModels = array ( ) ; $ objRegistry = Registry :: getInstance ( ) ; while ( $ objResult -> next ( ) ) { if ( $ objOptIn = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { $ arrModels [ ] = $ objOptIn ; } else { $ arrModels [ ] = new static ( $ objResult -> row ( ) ) ; } } return static :: createCollection ( $ arrModels , $ t ) ; }
5079	public function postRemap ( ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sMethod = 'post' . ucfirst ( $ oUri -> segment ( 4 ) ) ; if ( method_exists ( $ this , $ sMethod ) ) { return $ this -> $ sMethod ( ) ; } $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; $ aFields = $ oItemModel -> describeFields ( ) ; $ aValid = [ ] ; $ aInvalid = [ ] ; foreach ( $ aFields as $ oField ) { if ( in_array ( $ oField -> key , static :: CONFIG_POST_IGNORE_FIELDS ) ) { continue ; } $ aValid [ ] = $ oField -> key ; } $ aPost = $ oInput -> post ( ) ; foreach ( $ aPost as $ sKey => $ sValue ) { if ( ! in_array ( $ sKey , $ aValid ) ) { $ aInvalid [ ] = $ sKey ; } } if ( ! empty ( $ aInvalid ) ) { throw new ApiException ( 'The following arguments are invalid: ' . implode ( ', ' , $ aInvalid ) , $ oHttpCodes :: STATUS_BAD_REQUEST ) ; } $ iItemId = ( int ) $ oUri -> segment ( 4 ) ; if ( $ iItemId ) { $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( empty ( $ oItem ) ) { throw new ApiException ( 'Item does not exist' , $ oHttpCodes :: STATUS_NOT_FOUND ) ; } elseif ( ! $ oItemModel -> update ( $ iItemId , $ aPost ) ) { throw new ApiException ( 'Failed to update item. ' . $ oItemModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } elseif ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> disableCache ( ) ; } $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> enableCache ( ) ; } } else { $ oItem = $ oItemModel -> create ( $ aPost , true ) ; } $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( $ this -> formatObject ( $ oItem ) ) ; return $ oResponse ; }
1348	public function allow ( string $ resourceType , array $ fields = null ) : self { $ this -> all = false ; $ this -> allowed [ $ resourceType ] = $ fields ; return $ this ; }
2156	protected function validator ( $ varInput ) { if ( $ varInput == '*****' ) { $ this -> blnSubmitInput = false ; return true ; } return parent :: validator ( $ varInput ) ; }
3261	public static function placeOrder ( $ cart = null ) { try { if ( empty ( static :: $ gatewayKey ) ) throw new ShopException ( 'Payment gateway not selected.' ) ; if ( empty ( $ cart ) ) $ cart = Auth :: user ( ) -> cart ; $ order = $ cart -> placeOrder ( ) ; $ statusCode = $ order -> statusCode ; \ event ( new OrderPlaced ( $ order -> id ) ) ; static :: $ gateway -> setCallbacks ( $ order ) ; if ( static :: $ gateway -> onCharge ( $ order ) ) { $ order -> statusCode = static :: $ gateway -> getTransactionStatusCode ( ) ; $ order -> save ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , static :: $ gateway -> getTransactionId ( ) , static :: $ gateway -> getTransactionDetail ( ) , static :: $ gateway -> getTransactionToken ( ) ) ; if ( $ order -> isCompleted ) \ event ( new OrderCompleted ( $ order -> id ) ) ; } else { $ order -> statusCode = 'failed' ; $ order -> save ( ) ; } } catch ( ShopException $ e ) { static :: setException ( $ e ) ; if ( isset ( $ order ) ) { $ order -> statusCode = 'failed' ; $ order -> save ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , uniqid ( ) , static :: $ exception -> getMessage ( ) , $ order -> statusCode ) ; } } catch ( GatewayException $ e ) { static :: $ exception = $ e ; if ( isset ( $ order ) ) { $ order -> statusCode = 'failed' ; $ order -> save ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , uniqid ( ) , static :: $ exception -> getMessage ( ) , $ order -> statusCode ) ; } } if ( $ order ) { static :: checkStatusChange ( $ order , $ statusCode ) ; return $ order ; } else { return ; } }
5123	private function getAttachmentEndPoint ( string $ idArticle , string $ field ) : string { return $ this -> replaceEndPointId ( $ idArticle , $ this -> attachmentUrl [ $ field ] ) ; }
11395	public static function getTranslateErrorCode ( int $ iCode ) : string { if ( $ iCode === 1 && $ iCode === 16 && $ iCode === 256 && $ iCode === 4096 ) { return LogLevel :: ERROR ; } else if ( $ iCode === 2 && $ iCode === 32 && $ iCode === 128 && $ iCode === 512 ) { return LogLevel :: WARNING ; } else if ( $ iCode === 4 && $ iCode === 64 ) { return LogLevel :: EMERGENCY ; } else if ( $ iCode === 8 && $ iCode === 1024 ) { return LogLevel :: NOTICE ; } else if ( $ iCode === 2048 && $ iCode === 8192 && $ iCode === 16384 ) { return LogLevel :: INFO ; } else return LogLevel :: DEBUG ; }
9784	public function parseHTML ( ) { $ token = $ this -> pop ( 'HTML' ) ; $ value = $ this -> stripQuotes ( $ token [ 1 ] ) ; $ this -> currLine += substr_count ( $ value , "\n" ) ; return '$output .= \'' . $ value . "';\n" ; }
1149	protected function setDefaults ( $ options ) { $ this -> selector = empty ( $ options [ 'selector' ] ) ? 'form' : $ options [ 'selector' ] ; $ this -> view = empty ( $ options [ 'view' ] ) ? 'jsvalidation::bootstrap' : $ options [ 'view' ] ; $ this -> remote = isset ( $ options [ 'remote' ] ) ? $ options [ 'remote' ] : true ; }
10476	public function push ( string $ event , $ event_args = null ) : EventChannelInterface { try { $ this -> channel -> push ( $ event , $ event_args ) ; } catch ( EventSourceIsNotPushableException $ e ) { throw new EventStreamException ( 'Event is not pushable.' ) ; } return $ this ; }
4007	public function createMetaModel ( CreateMetaModelEvent $ event ) { if ( $ event -> getMetaModel ( ) !== null ) { return ; } if ( isset ( $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] ) ) { $ event -> setMetaModel ( $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] ) ; return ; } $ table = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> where ( 'tableName=:tableName' ) -> setParameter ( 'tableName' , $ event -> getMetaModelName ( ) ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( $ table ) { $ table [ 'system_columns' ] = $ this -> systemColumns ; $ this -> createInstance ( $ event , $ table ) ; } }
5792	private function setConstraints ( ) { $ q = new QueryBuilder ( "SELECT ccu.column_name, tc.constraint_type FROM INFORMATION_SCHEMA.constraint_column_usage ccu JOIN information_schema.table_constraints tc ON ccu.constraint_name = tc.constraint_name WHERE tc.table_name = ccu.table_name AND ccu.table_name = $1" , $ this -> tableName ) ; $ qResult = $ q -> execute ( ) ; while ( $ qRow = pg_fetch_assoc ( $ qResult ) ) { switch ( $ qRow [ 'constraint_type' ] ) { case 'PRIMARY KEY' : $ this -> primaryKeyColumnName = $ qRow [ 'column_name' ] ; break ; case 'UNIQUE' : $ this -> uniqueColumnNames [ ] = $ qRow [ 'column_name' ] ; } } }
1101	protected function parentId ( ) { switch ( $ this -> position ) { case 'root' : return NULL ; case 'child' : return $ this -> target -> getKey ( ) ; default : return $ this -> target -> getParentId ( ) ; } }
11257	private function all ( ? string $ name ) : array { $ array = [ ] ; foreach ( $ this -> filesystem -> listContents ( ) as $ file ) { if ( is_null ( $ name ) ) { $ array [ ] = [ $ file , $ this -> filesystem -> read ( $ file [ 'path' ] ) ] ; } else { if ( $ file [ 'filename' ] === ( $ name ? : Seed :: DEFAULT_SEED ) ) { $ array [ ] = [ $ file , $ this -> filesystem -> read ( $ file [ 'path' ] ) ] ; break ; } } } return $ array ; }
6999	public function getCssClassesForContainer ( ) { $ colsXl = $ this -> getWidth ( ) >= 100 ? 12 : ceil ( 12 * ( $ this -> getWidth ( ) / 100 ) ) ; $ colsXlLeft = floor ( ( 12 - $ colsXl ) / 2 ) ; $ colsLg = $ colsXl >= 10 ? 12 : $ colsXl + 2 ; $ colsLgLeft = floor ( ( 12 - $ colsLg ) / 2 ) ; return "col-xs-12 col-xl-{$colsXl} col-lg-{$colsLg} col-xl-offset-{$colsXlLeft} col-lg-offset-{$colsLgLeft}" ; }
5608	public function after ( $ method ) { $ this -> invoker -> after ( $ method ) ; $ output = ob_get_contents ( ) ; ob_end_clean ( ) ; if ( $ output !== '' ) { $ result = $ this -> listener -> write ( '{status:"info",message:"' . EclipseReporter :: escapeVal ( $ output ) . '"}' ) ; } }
8404	public static function registerApp ( string $ namespace , string $ path = null ) { $ namespace = rtrim ( $ namespace , '\\' ) ; if ( $ path == null ) { $ path = constant ( 'STRAY_PATH_APPS' ) . str_replace ( '_' , DIRECTORY_SEPARATOR , str_replace ( '\\' , DIRECTORY_SEPARATOR , $ namespace ) ) ; } self :: $ namespaces [ $ namespace ] = $ path ; self :: $ applications [ ] = $ namespace ; }
1000	public function getDirective ( $ name ) { foreach ( $ this -> getDirectives ( ) as $ directive ) { if ( $ directive -> name === $ name ) { return $ directive ; } } return null ; }
2918	public function appendSetter ( $ key , $ value = null , $ comment = null , $ export = false ) { $ line = $ this -> formatter -> formatSetterLine ( $ key , $ value , $ comment , $ export ) ; return $ this -> appendLine ( $ line ) ; }
11680	public function setPath ( $ path ) { if ( $ path === null ) { throw new PathCanNotBeNull ( ) ; } $ this -> path = rtrim ( $ path , '\\/' ) . '/' ; return $ this ; }
11172	public static function encrypt ( $ data , $ key , $ cipher = MCRYPT_RIJNDAEL_128 , $ mode = MCRYPT_MODE_CBC ) { $ data = serialize ( $ data ) ; $ key = hash ( 'sha256' , $ key , true ) ; $ iv_size = mcrypt_get_iv_size ( $ cipher , $ mode ) ; $ iv = mcrypt_create_iv ( $ iv_size , MCRYPT_RAND ) ; return base64_encode ( serialize ( array ( $ iv , mcrypt_encrypt ( $ cipher , $ key , $ data , $ mode , $ iv ) ) ) ) ; }
12689	public function get ( $ namespace , $ name , $ default = null , $ require = false ) { $ configuration = $ this -> load ( $ namespace , $ require ) ; return array_key_exists ( $ name , $ configuration ) ? $ configuration [ $ name ] : $ default ; }
11864	public function save ( string $ sessionIdentifier , string $ sessionData ) : void { self :: $ files [ $ sessionIdentifier ] = [ 'data' => $ sessionData , 'time' => microtime ( true ) ] ; }
542	protected function serializeModels ( array $ models ) { list ( $ fields , $ expand ) = $ this -> getRequestedFields ( ) ; foreach ( $ models as $ i => $ model ) { if ( $ model instanceof Arrayable ) { $ models [ $ i ] = $ model -> toArray ( $ fields , $ expand ) ; } elseif ( is_array ( $ model ) ) { $ models [ $ i ] = ArrayHelper :: toArray ( $ model ) ; } } return $ models ; }
386	public function getAttributeOrders ( $ recalculate = false ) { if ( $ this -> _attributeOrders === null || $ recalculate ) { $ this -> _attributeOrders = [ ] ; if ( ( $ params = $ this -> params ) === null ) { $ request = Yii :: $ app -> getRequest ( ) ; $ params = $ request instanceof Request ? $ request -> getQueryParams ( ) : [ ] ; } if ( isset ( $ params [ $ this -> sortParam ] ) ) { foreach ( $ this -> parseSortParam ( $ params [ $ this -> sortParam ] ) as $ attribute ) { $ descending = false ; if ( strncmp ( $ attribute , '-' , 1 ) === 0 ) { $ descending = true ; $ attribute = substr ( $ attribute , 1 ) ; } if ( isset ( $ this -> attributes [ $ attribute ] ) ) { $ this -> _attributeOrders [ $ attribute ] = $ descending ? SORT_DESC : SORT_ASC ; if ( ! $ this -> enableMultiSort ) { return $ this -> _attributeOrders ; } } } } if ( empty ( $ this -> _attributeOrders ) && is_array ( $ this -> defaultOrder ) ) { $ this -> _attributeOrders = $ this -> defaultOrder ; } } return $ this -> _attributeOrders ; }
10156	private function readSharedFmla ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ cellRange = substr ( $ recordData , 0 , 6 ) ; $ cellRange = $ this -> readBIFF5CellRangeAddressFixed ( $ cellRange ) ; $ no = ord ( $ recordData [ 7 ] ) ; $ formula = substr ( $ recordData , 8 ) ; $ this -> sharedFormulas [ $ this -> baseCell ] = $ formula ; }
10714	public function updateById ( $ id , array $ newAttributes ) { $ model = $ this -> getById ( $ id ) ; $ results = $ model -> update ( $ newAttributes ) ; if ( ! $ results ) { throw new UpdateFailedRepositoryException ( ) ; } return $ model ; }
8502	public function setMarketplaceIdList ( $ value ) { $ marketplaceIdList = new MarketplaceWebService_Model_IdList ( ) ; $ marketplaceIdList -> setId ( $ value [ 'Id' ] ) ; $ this -> fields [ 'MarketplaceIdList' ] [ 'FieldValue' ] = $ marketplaceIdList ; return ; }
6582	public static function getSession ( ServerRequestInterface $ request ) : SessionDataHolder { $ session = $ request -> getAttribute ( static :: REQ_ATTR ) ; if ( ! $ session instanceof SessionDataHolder ) { throw new SessionMiddlewareException ( "No session object is available in the request attributes" ) ; } return $ session ; }
8658	private function convertRequestReport ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'RequestReport' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMarketplaceIdList ( ) ) { $ marketplaceIdList = $ request -> getMarketplaceIdList ( ) ; foreach ( $ marketplaceIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'MarketplaceIdList.Id.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetReportType ( ) ) { $ parameters [ 'ReportType' ] = $ request -> getReportType ( ) ; } if ( $ request -> isSetStartDate ( ) ) { $ parameters [ 'StartDate' ] = $ this -> getFormattedTimestamp ( $ request -> getStartDate ( ) ) ; } if ( $ request -> isSetEndDate ( ) ) { $ parameters [ 'EndDate' ] = $ this -> getFormattedTimestamp ( $ request -> getEndDate ( ) ) ; } if ( $ request -> isSetReportOptions ( ) ) { $ parameters [ 'ReportOptions' ] = $ request -> getReportOptions ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
7434	private function getDirContents ( $ dir , & $ results = [ ] ) { $ files = scandir ( $ dir ) ; foreach ( $ files as $ value ) { $ path = realpath ( $ dir . DIRECTORY_SEPARATOR . $ value ) ; if ( ! is_dir ( $ path ) ) { $ results [ ] = $ path ; continue ; } if ( $ value != '.' && $ value != '..' ) { $ this -> getDirContents ( $ path , $ results ) ; $ results [ ] = $ path ; } } return $ results ; }
11903	public function getDescriptor ( ) { $ logModel = $ this -> getLogModel ( true ) ; if ( empty ( $ logModel ) || ! isset ( $ logModel -> dataInterface ) ) { return 'Unknown Data Interface' ; } return 'Interface: ' . $ logModel -> dataInterface -> name ; }
5377	public function getAttribute ( $ label ) { $ label = strtolower ( $ label ) ; if ( ! isset ( $ this -> attributes [ $ label ] ) ) { return false ; } return ( string ) $ this -> attributes [ $ label ] ; }
2620	public function sendInstalledReq ( ) { $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . self :: FASTLY_INSTALLED_FLAG , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . self :: FASTLY_INSTALLED_FLAG , 'dt' => ucfirst ( self :: FASTLY_INSTALLED_FLAG ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams , self :: GA_HITTYPE_PAGEVIEW ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . self :: FASTLY_INSTALLED_FLAG , 'el' => $ this -> getWebsiteName ( ) , 'ev' => 0 , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
3159	public function storeVariables ( QtiRunnerServiceContext $ context , $ itemUri , $ metaVariables , $ itemId = null ) { $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; $ testUri = $ context -> getTestDefinitionUri ( ) ; if ( ! is_null ( $ itemUri ) ) { $ resultStore -> storeItemVariables ( $ testUri , $ itemUri , $ metaVariables , $ this -> getTransmissionId ( $ context , $ itemId ) ) ; } else { $ resultStore -> storeTestVariables ( $ testUri , $ metaVariables , $ sessionId ) ; } return true ; }
4714	public function replaceString ( $ search , $ replace ) { $ this -> text = str_replace ( $ search , $ replace , $ this -> text ) ; return $ this ; }
6783	public function setHeaderParameters ( $ optionNames ) { foreach ( ( array ) $ optionNames as $ option ) { $ this -> headerParameters [ $ option ] = true ; } return $ this ; }
12879	public function render ( ) { $ plugins = $ this -> pluginManager -> getBlockPlugins ( ) ; $ toolbar = array ( ) ; $ left [ ] = $ this -> twig -> render ( "RedKiteCms/Resources/views/Editor/Toolbar/_toolbar_left_buttons.html.twig" ) ; $ right [ ] = $ this -> twig -> render ( "RedKiteCms/Resources/views/Editor/Toolbar/_toolbar_right_buttons.html.twig" ) ; foreach ( $ plugins as $ plugin ) { if ( ! $ plugin -> hasToolbar ( ) ) { continue ; } $ left [ ] = $ this -> addButtons ( $ plugin , 'left' ) ; $ right [ ] = $ this -> addButtons ( $ plugin , 'right' ) ; } $ toolbar [ "left" ] = implode ( "\n" , $ left ) ; $ toolbar [ "right" ] = implode ( "\n" , $ right ) ; return $ toolbar ; }
7291	private function getByMethodAndStatesFromDateQuery ( ) { if ( null !== $ this -> byMethodAndStatesFromDateQuery ) { return $ this -> byMethodAndStatesFromDateQuery ; } $ qb = $ this -> createQueryBuilder ( 'p' ) ; $ query = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( 'p.method' , ':method' ) ) -> andWhere ( $ qb -> expr ( ) -> in ( 'p.state' , ':states' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'p.createdAt' , ':date' ) ) -> addOrderBy ( 'p.createdAt' , 'ASC' ) -> getQuery ( ) -> useQueryCache ( true ) ; return $ this -> byMethodAndStatesFromDateQuery = $ query ; }
638	public function addColumn ( $ table , $ column , $ type ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addColumn ( $ table , $ column , $ type ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
5883	public function beforeFind ( Event $ event , Query $ query , ArrayObject $ options , $ primary ) { $ orders = $ this -> _config [ 'orders' ] ; $ args = [ $ query , $ options , $ primary ] ; foreach ( $ orders as $ config ) { if ( ( ! empty ( $ config [ 'callback' ] ) && call_user_func_array ( $ config [ 'callback' ] , $ args ) ) || ! $ query -> clause ( 'order' ) ) { $ query -> order ( $ config [ 'order' ] ) ; break ; } } }
645	public function resetSequence ( $ table , $ value = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> resetSequence ( $ table , $ value ) ; return $ this -> setSql ( $ sql ) ; }
4806	protected function processMemberVar ( File $ phpcsFile , $ stackPtr ) { $ tokens = $ phpcsFile -> getTokens ( ) ; $ commentToken = [ T_COMMENT , T_DOC_COMMENT_CLOSE_TAG , ] ; $ commentEnd = $ phpcsFile -> findPrevious ( $ commentToken , $ stackPtr ) ; $ commentStart = $ tokens [ $ commentEnd ] [ 'comment_opener' ] ; if ( $ tokens [ $ commentEnd ] [ 'line' ] === $ tokens [ $ commentStart ] [ 'line' ] ) { $ phpcsFile -> addError ( 'Member variable comment should not be inline' , $ stackPtr , static :: ERROR_CODE ) ; } }
5096	public function queryExists ( ) { foreach ( $ this -> selects as $ select ) { $ result = $ select -> queryExists ( ) ; if ( is_null ( $ result ) || $ result ) { return $ result ; } } return false ; }
1669	public function delete ( ) { $ this -> Files -> rrdir ( $ this -> strFolder ) ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ) { Dbafs :: deleteResource ( $ this -> strFolder ) ; } }
10346	protected function getNextFutureTimestamp ( ) { if ( $ this -> yearOffset === 0 ) { $ currentHour = ( int ) date ( 'H' , $ this -> getCurrentTime ( ) ) ; $ currentMinute = ( int ) date ( 'i' , $ this -> getCurrentTime ( ) ) ; $ currentDay = ( int ) date ( 'd' , $ this -> getCurrentTime ( ) ) ; $ currentMonth = ( int ) date ( 'm' , $ this -> getCurrentTime ( ) ) ; } do { $ minute = current ( $ this -> minutes ) ; $ hour = current ( $ this -> hours ) ; $ monthAndDay = current ( $ this -> monthAndDays ) ; $ minute = next ( $ this -> minutes ) ; if ( $ minute === false ) { $ minute = reset ( $ this -> minutes ) ; $ hour = next ( $ this -> hours ) ; if ( $ hour === false ) { $ hour = reset ( $ this -> hours ) ; $ monthAndDay = next ( $ this -> monthAndDays ) ; if ( $ monthAndDay === false ) { $ this -> generateTimetable ( $ this -> yearOffset + 1 ) ; $ minute = reset ( $ this -> minutes ) ; $ hour = reset ( $ this -> hours ) ; $ monthAndDay = reset ( $ this -> monthAndDays ) ; } } } if ( $ this -> yearOffset === 0 ) { if ( ( $ month = ( int ) substr ( $ monthAndDay , 0 , 2 ) ) === $ currentMonth ) { if ( ( $ day = ( int ) substr ( $ monthAndDay , 3 , 2 ) ) < $ currentDay ) { continue ; } if ( $ day === $ currentDay ) { if ( $ hour < $ currentHour ) { continue ; } if ( $ hour === $ currentHour ) { if ( $ minute < $ currentMinute ) { continue ; } } } } } $ nextElement = strtotime ( sprintf ( '%d-%s %02d:%02d:00' , $ this -> year + $ this -> yearOffset , $ monthAndDay , $ hour , $ minute ) ) ; break ; } while ( true ) ; return $ nextElement ; }
3403	protected function loadFromYml ( $ file ) { $ this -> parser = new Parser ( $ file ) ; $ this -> parser -> load ( $ this ) ; }
4647	public function copy ( $ originFile , $ targetFile , $ override = false ) { parent :: copy ( $ originFile , $ targetFile , $ override ) ; $ this -> chmod ( $ targetFile , fileperms ( $ originFile ) ) ; }
4239	public function onBootstrap ( ) { if ( $ this -> debug -> parentInstance ) { return ; } $ collectWas = $ this -> debug -> setCfg ( 'collect' , true ) ; $ this -> debug -> groupSummary ( ) ; $ this -> debug -> group ( 'environment' , $ this -> debug -> meta ( array ( 'hideIfEmpty' => true , 'level' => 'info' , ) ) ) ; $ this -> logPhpInfo ( ) ; $ this -> logServerVals ( ) ; $ this -> logRequest ( ) ; $ this -> debug -> groupEnd ( ) ; $ this -> debug -> groupEnd ( ) ; $ this -> debug -> setCfg ( 'collect' , $ collectWas ) ; }
7018	private function format_h ( & $ str ) { if ( strstr ( $ str , '%h' ) ) { $ h = $ this -> hour > 12 ? $ this -> hour - 12 : $ this -> hour ; $ str = str_replace ( '%h' , sprintf ( '%02d' , $ h ) , $ str ) ; } }
2946	public function setRolesById ( $ roles ) { $ roles = is_array ( $ roles ) ? $ roles : [ $ roles ] ; return $ this -> roles ( ) -> sync ( $ roles ) ; }
4779	public function removeWidget ( string $ widgetId ) { if ( isset ( $ this -> widgets [ $ widgetId ] ) ) { unset ( $ this -> widgets [ $ widgetId ] ) ; } return $ this ; }
1310	public static function categoriesMenu ( $ categories ) { $ menu = '<ul class="nav nav-pills nav-stacked">' ; foreach ( $ categories as $ category ) { $ menu .= '<li>' ; $ menu .= '<a href="/' . config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.category' ) . '/' . $ category [ 'slug' ] . '">' ; $ menu .= '<div class="chatter-box" style="background-color:' . $ category [ 'color' ] . '"></div>' ; $ menu .= $ category [ 'name' ] . '</a>' ; if ( count ( $ category [ 'parents' ] ) ) { $ menu .= static :: categoriesMenu ( $ category [ 'parents' ] ) ; } $ menu .= '</li>' ; } $ menu .= '</ul>' ; return $ menu ; }
2928	public function getKeys ( $ keys = [ ] ) { $ allKeys = $ this -> reader -> keys ( ) ; return array_filter ( $ allKeys , function ( $ key ) use ( $ keys ) { if ( ! empty ( $ keys ) ) { return in_array ( $ key , $ keys ) ; } return true ; } , ARRAY_FILTER_USE_KEY ) ; }
11260	public static function snake2pascal ( string $ snake ) : string { $ nameParts = explode ( "_" , $ snake ) ; $ nameParts = array_map ( "ucfirst" , $ nameParts ) ; return implode ( "" , $ nameParts ) ; }
4622	protected function pickNode ( ) { $ nodes = $ this -> getNodes ( ) ; $ index = mt_rand ( 0 , count ( $ nodes ) - 1 ) ; return array_keys ( $ nodes ) [ $ index ] ; }
10287	protected function parseCrontab ( $ crontab ) { $ lines = preg_split ( '(\r\n|\r|\n)' , $ crontab ) ; $ this -> crontab = array ( ) ; foreach ( $ lines as $ line ) { $ line = trim ( $ line ) ; if ( ! empty ( $ line ) && ( $ line [ 0 ] !== '#' ) && ( $ line [ 0 ] !== ';' ) ) { $ this -> crontab [ ] = new Cronjob ( $ line ) ; } } }
12495	public static function get ( Scope $ scope , $ connection , $ multiple , $ return = false ) { $ from = $ connection -> db ; if ( strpos ( $ from , '.' ) !== false ) { $ tmp = explode ( '.' , $ connection -> db ) ; $ from = end ( $ tmp ) ; } if ( ! is_null ( $ scope -> listWordsField ) ) { if ( $ scope -> listWordsField === '' ) { $ from = 'LIST_WORDS(' . $ from . ')' ; } else { $ from = 'LIST_WORDS(' . $ from . '.' . $ scope -> listWordsField . ')' ; } } if ( ! is_null ( $ scope -> alternativesField ) ) { if ( $ scope -> alternativesField === '' ) { $ from = 'ALTERNATIVES(' . $ from . ')' ; } else { $ from = 'ALTERNATIVES(' . $ from . '.' . $ scope -> alternativesField . ')' ; } } $ connection -> query = $ scope -> prepend . 'SELECT ' . $ scope -> select . ' FROM ' . $ from . ' ' ; if ( ! is_null ( $ scope -> join ) ) { $ connection -> query .= $ scope -> join . ' ' ; } if ( $ scope -> where != '' ) { $ connection -> query .= 'WHERE' . $ scope -> where ; } if ( count ( $ scope -> groupBy ) ) { $ connection -> query .= 'GROUP BY ' . implode ( ", " , $ scope -> groupBy ) . ' ' ; } if ( count ( $ scope -> orderBy ) ) { $ connection -> query .= 'ORDER BY ' . implode ( ", " , $ scope -> orderBy ) . ' ' ; } $ connection -> query .= 'LIMIT ' . $ scope -> offset . ', ' . $ scope -> limit ; if ( $ return ) { return $ connection -> query ; } $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; $ connection -> multiple = $ multiple ; $ scope -> resetSelf ( ) ; return self :: sendQuery ( $ connection ) ; }
5859	public function getAllDirectories ( ) { $ directories = [ ] ; foreach ( $ this -> rulesets as $ ruleset ) { $ dirs = GeneralUtility :: trimExplode ( ',' , $ ruleset [ 'directories_config' ] , true ) ; $ directories = array_merge ( $ directories , $ dirs ) ; } $ directories = array_unique ( $ directories ) ; asort ( $ directories ) ; return $ directories ; }
5711	public function FieldHolder ( $ attributes = array ( ) ) { if ( $ this -> shouldDisplay ( ) ) { $ this -> setContent ( $ this -> getButtonHTML ( ) ) ; return parent :: FieldHolder ( $ attributes ) ; } }
5166	protected function filterUriInstance ( $ uri ) : string { if ( $ uri instanceof UriInterface ) { return ( string ) $ uri ; } if ( is_string ( $ uri ) ) { return ( string ) \ One \ createUriFromString ( $ uri ) ; } return '' ; }
6614	protected function validateSettings ( $ settings ) { if ( ! is_array ( $ settings ) ) { throw new InvalidProviderSettingsException ( ) ; } $ intersection = array_intersect ( array_keys ( $ settings ) , $ this -> mandatory ) ; return count ( $ intersection ) === count ( $ this -> mandatory ) ; }
8419	public static function get ( string $ alias ) { if ( isset ( self :: $ databases [ $ alias ] ) === false ) { throw new DatabaseNotFound ( 'database "' . $ alias . '" doesn\'t seem to be registered' ) ; } return self :: $ databases [ $ alias ] ; }
10866	protected function createNewInst ( ) { $ classReflection = new \ ReflectionClass ( $ this -> instClass ) ; if ( $ this -> constructorArgs === null ) { return $ classReflection -> newInstance ( ) ; } else { return $ classReflection -> newInstanceArgs ( $ this -> concstructorArgs ) ; } }
11188	public static function set ( array $ arr , $ k , $ v ) { $ nested = ! is_array ( $ k ) ? explode ( '.' , $ k ) : $ k ; $ count = count ( $ nested ) ; if ( $ count == 1 ) { return $ arr [ $ k ] = $ v ; } elseif ( $ count > 1 ) { $ prev = '' ; $ loop = 1 ; $ unshift = $ nested ; foreach ( $ nested as $ part ) { if ( isset ( $ arr [ $ part ] ) && $ count > $ loop ) { $ prev = $ part ; array_shift ( $ unshift ) ; $ loop ++ ; continue ; } else { if ( $ loop > 1 && $ loop < $ count ) { if ( ! isset ( $ arr [ $ prev ] [ $ part ] ) ) $ arr [ $ prev ] [ $ part ] = [ ] ; $ arr [ $ prev ] = static :: set ( $ arr [ $ prev ] , $ unshift , $ v ) ; $ loop ++ ; break ; } elseif ( $ loop >= 1 && $ loop == $ count ) { if ( ! is_array ( $ arr [ $ prev ] ) ) $ arr [ $ prev ] = [ ] ; if ( $ part == '' ) $ arr [ $ prev ] [ ] = $ v ; else $ arr [ $ prev ] [ $ part ] = $ v ; } else { $ arr [ $ part ] = [ ] ; $ prev = $ part ; array_shift ( $ unshift ) ; $ loop ++ ; } } } } return $ arr ; }
2877	public function searchGroupClassAction ( ) { if ( ! $ this -> getRequest ( ) -> isPost ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 405 ) ; return ; } $ uri = ( string ) $ this -> getRequest ( ) -> getPost ( 'uri' ) ; $ groupType = $ this -> getRequest ( ) -> getPost ( 'group' ) ; $ groupTypes = array ( $ groupType ) ; if ( $ groupType == 'all' ) { $ groupTypes = array ( 'model' , 'block' , 'helper' ) ; } $ items = array ( ) ; if ( $ uri ) { foreach ( $ groupTypes as $ type ) { $ items [ $ type ] [ 'class' ] = Mage :: getConfig ( ) -> getGroupedClassName ( $ type , $ uri ) ; $ items [ $ type ] [ 'filepath' ] = mageFindClassFile ( $ items [ $ type ] [ 'class' ] ) ; } $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/array' ) ; $ block -> setTemplate ( 'sheep_debug/grouped_class_search.phtml' ) ; $ block -> assign ( 'items' , $ items ) ; $ this -> getResponse ( ) -> setBody ( $ block -> toHtml ( ) ) ; } else { $ this -> getResponse ( ) -> setBody ( $ this -> __ ( 'Please fill in a search query' ) ) ; } }
12715	protected function circularDependencyResolver ( $ class ) { if ( ! is_string ( $ class ) && ! class_exists ( $ class ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be a string of valid class name." , __METHOD__ ) ) ; } $ reflector = Internal \ ReflectionClassFactory :: create ( $ class ) ; if ( ! $ this -> hasConstructor ( $ reflector ) ) { return $ this -> resolveInstanceWithoutConstructor ( $ reflector ) ; } else { $ param = $ this -> getMethodParameters ( $ reflector , '__construct' ) ; if ( empty ( $ param ) ) { return $ reflector -> newInstance ( ) ; } else { foreach ( $ param as $ key => $ value ) { $ class = $ value -> getClass ( ) ; if ( $ class instanceof \ ReflectionClass ) { if ( $ class -> isInterface ( ) ) { $ param [ $ key ] = $ this -> getConcreteFromInterface ( $ class -> getName ( ) ) ; } else { $ param [ $ key ] = $ this -> circularDependencyResolver ( $ class -> getName ( ) ) ; } } } return $ reflector -> newInstanceArgs ( $ param ) ; } } }
9686	public function implode ( $ value , $ glue = null ) { $ new_collection = new Collection ( $ this -> toArray ( ) ) ; $ first = $ new_collection -> first ( ) ; if ( is_array ( $ first ) || is_object ( $ first ) ) { return implode ( $ glue , $ new_collection -> pluck ( $ value ) -> all ( ) ) ; } return implode ( $ value , $ new_collection -> all ( ) ) ; }
1204	protected function renderChildren ( ItemInterface $ item , array $ options ) { if ( null !== $ options [ 'depth' ] ) { $ options [ 'depth' ] = $ options [ 'depth' ] - 1 ; } if ( null !== $ options [ 'matchingDepth' ] && $ options [ 'matchingDepth' ] > 0 ) { $ options [ 'matchingDepth' ] = $ options [ 'matchingDepth' ] - 1 ; } $ html = '' ; foreach ( $ item -> getChildren ( ) as $ child ) { $ html .= $ this -> renderItem ( $ child , $ options ) ; } return $ html ; }
2812	public function getObservers ( ) { if ( $ this -> observers === null ) { $ this -> observers = array ( ) ; foreach ( $ this -> getTimers ( ) as $ timerName => $ timer ) { if ( strpos ( $ timerName , 'OBSERVER' ) === 0 ) { $ this -> observers [ ] = array ( 'name' => $ timerName , 'count' => $ timer [ 'count' ] , 'sum' => round ( $ timer [ 'sum' ] * 1000 , 2 ) , 'mem_diff' => $ timer [ 'realmem' ] / pow ( 1024 , 2 ) , ) ; } } } return $ this -> observers ; }
3833	protected function getLangValue ( $ arrValues , $ strLangCode = null ) { if ( ! ( $ this -> getMetaModel ( ) -> isTranslated ( ) && is_array ( $ arrValues ) ) ) { return $ arrValues ; } if ( $ strLangCode === null ) { return $ this -> getLangValue ( $ arrValues , $ this -> getMetaModel ( ) -> getActiveLanguage ( ) ) ; } if ( array_key_exists ( $ strLangCode , $ arrValues ) ) { return $ arrValues [ $ strLangCode ] ; } return $ arrValues [ $ this -> getMetaModel ( ) -> getFallbackLanguage ( ) ] ; }
6556	public function log ( $ msg , $ logLevel = null ) { $ helper = new FormatterHelper ( ) ; $ style = $ this -> mapLogLevelToStyle ( $ logLevel ) ; $ this -> getOutput ( ) -> writeln ( $ logLevel ? $ helper -> formatBlock ( $ msg , $ style ) : $ msg ) ; if ( $ logLevel && $ systemLogger = $ this -> getSystemLogger ( ) ) { $ systemLogger -> log ( $ logLevel , $ msg ) ; } }
5016	public function logJobStart ( ProcessJobEvent $ event ) : void { $ queue = $ event -> getQueue ( ) ; $ job = $ event -> getJob ( ) ; $ logger = $ this -> getLogger ( ) ; $ logger -> info ( sprintf ( $ this -> tmpl [ 'job' ] , $ queue -> getName ( ) , 'START' , $ this -> formatJob ( $ job ) , '' ) ) ; $ this -> injectLoggerInObject ( $ job ) ; $ this -> injectLoggerInEvent ( $ event ) ; }
6091	public function removeMoodboard ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/moodboards/' . $ id . '' , $ parameters ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
7667	function InlineImageExists ( ) { $ result = false ; for ( $ i = 0 ; $ i < count ( $ this -> attachment ) ; $ i ++ ) { if ( $ this -> attachment [ $ i ] [ 6 ] == "inline" ) { $ result = true ; break ; } } return $ result ; }
4388	public function setConfigFE ( \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Iface $ orderServiceItem , array $ attributes ) { $ this -> setAttributes ( $ orderServiceItem , $ attributes , 'session' ) ; }
8700	public function append ( $ element ) { if ( true === $ element instanceof \ SVGCreator \ Element ) { $ this -> childElements [ ] = $ element ; return $ element ; } else { $ elementCreated = $ this -> factoryElement ( $ element ) ; $ this -> childElements [ ] = $ elementCreated ; return $ elementCreated ; } }
3596	protected function createTables ( ) { $ tablesCreated = false ; $ tableSchema = Craft :: $ app -> db -> schema -> getTableSchema ( '{{%dolphiq_sitemap_entries}}' ) ; if ( $ tableSchema === null ) { $ tablesCreated = true ; $ this -> createTable ( '{{%dolphiq_sitemap_entries}}' , [ 'id' => $ this -> primaryKey ( ) , 'dateCreated' => $ this -> dateTime ( ) -> notNull ( ) , 'dateUpdated' => $ this -> dateTime ( ) -> notNull ( ) , 'uid' => $ this -> uid ( ) , 'linkId' => $ this -> integer ( ) -> notNull ( ) , 'type' => $ this -> string ( 30 ) -> notNull ( ) -> defaultValue ( '' ) , 'priority' => $ this -> double ( 2 ) -> notNull ( ) -> defaultValue ( 0.5 ) , 'changefreq' => $ this -> string ( 30 ) -> notNull ( ) -> defaultValue ( '' ) , ] ) ; } return $ tablesCreated ; }
975	public function shopWebhooks ( ) { if ( ! $ this -> shopWebhooks ) { $ this -> shopWebhooks = $ this -> api -> rest ( 'GET' , '/admin/webhooks.json' , [ 'limit' => 250 , 'fields' => 'id,address' , ] ) -> body -> webhooks ; } return $ this -> shopWebhooks ; }
12442	public function detach ( $ key ) { if ( isset ( $ this -> instances [ $ key ] ) ) { unset ( $ this -> instances [ $ key ] ) ; } return $ this ; }
9980	private function writeComment ( XMLWriter $ objWriter , $ pCellReference , Comment $ pComment , array $ pAuthors ) { $ objWriter -> startElement ( 'comment' ) ; $ objWriter -> writeAttribute ( 'ref' , $ pCellReference ) ; $ objWriter -> writeAttribute ( 'authorId' , $ pAuthors [ $ pComment -> getAuthor ( ) ] ) ; $ objWriter -> startElement ( 'text' ) ; $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> writeRichText ( $ objWriter , $ pComment -> getText ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
2690	public function getResizedImageInfo ( ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { return parent :: getResizedImageInfo ( ) ; } if ( $ this -> getBaseFile ( ) !== null ) { return [ 0 => $ this -> getWidth ( ) , 1 => $ this -> getHeight ( ) ] ; } $ asset = $ this -> _assetRepo -> createAsset ( "Magento_Catalog::images/product/placeholder/{$this->getDestinationSubdir()}.jpg" ) ; $ img = $ asset -> getSourceFile ( ) ; $ imageInfo = getimagesize ( $ img ) ; $ this -> setWidth ( $ imageInfo [ 0 ] ) ; $ this -> setHeight ( $ imageInfo [ 1 ] ) ; return $ imageInfo ; }
1370	protected function bindExceptionParser ( ) { $ this -> app -> singleton ( ExceptionParserInterface :: class , ExceptionParser :: class ) ; $ this -> app -> alias ( ExceptionParserInterface :: class , 'json-api.exceptions' ) ; }
6238	public function write ( string $ content , bool $ append = false , int $ mode = LOCK_EX ) : self { $ this -> checkFileWritePermissions ( ) ; if ( ! $ this -> storage -> writeFile ( $ content , $ append , $ mode ) ) { throw new AccessDeniedException ( 'unable to write file-content' , 403 ) ; } return $ this ; }
205	public static function wrapText ( $ text , $ indent = 0 , $ refresh = false ) { $ size = static :: getScreenSize ( $ refresh ) ; if ( $ size === false || $ size [ 0 ] <= $ indent ) { return $ text ; } $ pad = str_repeat ( ' ' , $ indent ) ; $ lines = explode ( "\n" , wordwrap ( $ text , $ size [ 0 ] - $ indent , "\n" , true ) ) ; $ first = true ; foreach ( $ lines as $ i => $ line ) { if ( $ first ) { $ first = false ; continue ; } $ lines [ $ i ] = $ pad . $ line ; } return implode ( "\n" , $ lines ) ; }
9205	public function init ( ) { $ path = $ this -> absolutePath ( $ this -> getFile ( ) ) ; $ this -> quiet ( 'Initializing seed file: ' . $ this -> shortPath ( $ path ) ) ; $ this -> existsOrCreate ( $ path ) ; }
8387	public function distinct ( $ distinct ) { if ( is_array ( $ distinct ) === true ) { $ this -> distinct = implode ( ', ' , $ distinct ) ; } else { $ this -> distinct = $ distinct ; } return $ this ; }
435	public function beforeAction ( $ action ) { $ event = new ActionEvent ( $ action ) ; $ this -> trigger ( self :: EVENT_BEFORE_ACTION , $ event ) ; return $ event -> isValid ; }
7760	protected function detectMetadataDriver ( $ dir , ContainerBuilder $ container ) { $ configPath = $ this -> getMappingResourceConfigDirectory ( ) ; $ resource = $ dir . '/' . $ configPath ; while ( ! is_dir ( $ resource ) ) { $ resource = dirname ( $ resource ) ; } $ container -> addResource ( new FileResource ( $ resource ) ) ; $ extension = $ this -> getMappingResourceExtension ( ) ; if ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.xml' ) ) && count ( $ files ) ) { return 'xml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.yml' ) ) && count ( $ files ) ) { return 'yml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.php' ) ) && count ( $ files ) ) { return 'php' ; } $ container -> addResource ( new FileResource ( $ dir ) ) ; if ( is_dir ( $ dir . '/' . $ this -> getMappingObjectDefaultName ( ) ) ) { return 'annotation' ; } return null ; }
10689	private function setupLogging ( ) { $ test = defined ( 'WEDETO_TEST' ) && WEDETO_TEST === 1 ? 'test' : '' ; $ root_logger = Logger :: getLogger ( ) ; $ root_logger -> setLevel ( LogLevel :: INFO ) ; if ( $ this -> path_config -> log ) { $ logfile = $ this -> path_config -> log . '/wedeto' . $ test . '.log' ; $ root_logger -> addLogWriter ( new FileWriter ( $ logfile , LogLevel :: DEBUG ) ) ; } if ( $ this -> config -> has ( 'log' , Type :: ARRAY ) ) { foreach ( $ this -> config [ 'log' ] as $ logname => $ level ) { if ( $ logname === "writer" ) { foreach ( $ level as $ logname => $ parameters ) { $ logger = Logger :: getLogger ( $ logname ) ; $ parameters = str_replace ( '{LOGDIR}' , $ this -> path_config -> log , $ parameters ) ; $ parameters = explode ( ';' , $ parameters ) ; $ class = array_shift ( $ parameters ) ; if ( ! class_exists ( $ class ) ) throw new \ DomainException ( "Invalid logger class: $class" ) ; $ refl = new \ ReflectionClass ( $ class ) ; $ writer = $ refl -> newInstanceArgs ( $ parameters ) ; if ( ! ( $ writer instanceof AbstractWriter ) ) throw new \ DomainException ( "Class $class is not a log writer" ) ; $ logger -> addLogWriter ( $ writer ) ; } continue ; } $ logger = Logger :: getLogger ( $ logname ) ; $ level = strtolower ( $ level ) ; try { $ logger -> setLevel ( $ level ) ; } catch ( \ DomainException $ e ) { self :: $ logger -> error ( "Failed to set log level for {0} to {1}: {2}" , [ $ logname , $ level , $ e -> getMessage ( ) ] ) ; } } } if ( $ this -> dev ) { $ devlogger = new MemLogWriter ( LogLevel :: DEBUG ) ; $ root_logger -> addLogWriter ( $ devlogger ) ; } if ( isset ( $ _SERVER [ 'REQUEST_URI' ] ) ) { self :: $ logger -> debug ( "*** Starting processing for {0} request to {1}" , [ $ _SERVER [ 'REQUEST_METHOD' ] , $ _SERVER [ 'REQUEST_URI' ] ] ) ; } if ( Request :: cli ( ) ) { $ limit = ( int ) $ this -> config -> dget ( 'cli' , 'memory_limit' , 1024 ) ; ini_set ( 'memory_limit' , $ limit . 'M' ) ; ini_set ( 'max_execution_time' , 0 ) ; ini_set ( 'display_errors' , 1 ) ; } else ini_set ( 'display_errors' , 0 ) ; }
8794	protected function writeNewEnvironmentFileWith ( $ key ) { file_put_contents ( base_path ( '.env' ) , preg_replace ( $ this -> keyReplacementPattern ( ) , 'APP_KEY=' . $ key , file_get_contents ( base_path ( '.env' ) ) ) ) ; }
12557	private static function init ( ) : void { static $ inited = false ; if ( ! $ inited ) { if ( ! isset ( $ _SESSION [ 'Booby' ] ) || ! $ _SESSION [ 'Booby' ] ) { $ _SESSION [ 'Booby' ] = [ ] ; } self :: $ store = & $ _SESSION [ 'Booby' ] ; $ inited = true ; } }
11022	public function listTasks ( $ ostr = STDOUT ) { $ this -> findTasks ( ) ; if ( count ( $ this -> task_list ) === 0 ) { fprintf ( $ ostr , "No tasks available\n" ) ; } else { fprintf ( $ ostr , "Listing available tasks: \n" ) ; foreach ( $ this -> task_list as $ task => $ desc ) { $ task = str_replace ( '\\' , ':' , $ task ) ; fprintf ( $ ostr , "- %-30s" , $ task ) ; CLI :: formatText ( 32 , CLI :: MAX_LINE_LENGTH , ' ' . $ desc , $ ostr ) ; } printf ( "\n" ) ; } }
8499	public function updateFulfillmentOrder ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_UpdateFulfillmentOrderRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_UpdateFulfillmentOrderRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateFulfillmentOrder' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_UpdateFulfillmentOrderResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11542	public function confirmEmail ( $ token ) { $ user = $ this -> getMapper ( ) -> findOneBy ( [ 'registrationToken' => $ token ] ) ; if ( ! $ user instanceof UserInterface ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setRegistrationToken ( $ this -> getRegistrationToken ( ) ) ; $ user -> setEmailConfirmed ( true ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
7584	protected function extractResponse ( $ curlResponse ) { $ this -> headers = substr ( $ curlResponse , 0 , $ this -> info [ 'header_size' ] ) ; $ this -> body = substr ( $ curlResponse , $ this -> info [ 'header_size' ] ) ; }
5118	public function deleteAttachment ( string $ idArticle , string $ field , string $ order ) : string { return $ this -> delete ( $ this -> getAttachmentEndPoint ( $ idArticle , $ field ) . "/${order}" ) ; }
7395	protected function _getByName ( $ propName ) { if ( array_key_exists ( $ propName , $ this -> _map ) ) { $ propName = $ this -> _map [ $ propName ] ; } if ( $ this -> { $ propName } instanceof AtomicInterface ) { return $ this -> { $ propName } -> get ( ) ; } $ getter = '_get_' . $ propName ; if ( method_exists ( $ this -> _calledClass , $ getter ) ) { return $ this -> { $ getter } ( ) ; } return $ this -> { $ propName } ; }
8117	public function onBeforeWrite ( ) { $ changedFields = $ this -> owner -> getChangedFields ( true , 2 ) ; if ( $ changedFields ) { $ this -> owner -> LastEditedByName = $ this -> owner -> getEditorName ( ) ; $ this -> owner -> OwnerNames = $ this -> owner -> getOwnerNames ( ) ; } if ( $ this -> owner -> isChanged ( "ContentReviewType" , 2 ) ) { if ( $ this -> owner -> ContentReviewType == "Disabled" ) { $ this -> setDefaultReviewDateForDisabled ( ) ; } elseif ( $ this -> owner -> ContentReviewType == "Custom" ) { $ this -> setDefaultReviewDateForCustom ( ) ; } else { $ this -> setDefaultReviewDateForInherited ( ) ; } } if ( $ this -> owner -> ContentReviewType == "Inherit" && ! $ this -> owner -> NextReviewDate ) { $ this -> setDefaultReviewDateForInherited ( ) ; } if ( ! $ this -> owner -> exists ( ) ) { return ; } if ( $ this -> owner -> isChanged ( 'ReviewPeriodDays' , 2 ) ) { $ nextReviewUnixSec = strtotime ( ' + ' . $ this -> owner -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ this -> owner -> NextReviewDate = DBDate :: create ( ) -> setValue ( $ nextReviewUnixSec ) -> Format ( 'y-MM-dd' ) ; } }
9718	private function writePalette ( ) { $ aref = $ this -> palette ; $ record = 0x0092 ; $ length = 2 + 4 * count ( $ aref ) ; $ ccv = count ( $ aref ) ; $ data = '' ; foreach ( $ aref as $ color ) { foreach ( $ color as $ byte ) { $ data .= pack ( 'C' , $ byte ) ; } } $ header = pack ( 'vvv' , $ record , $ length , $ ccv ) ; $ this -> append ( $ header . $ data ) ; }
7191	private function copyNotification ( Model \ SaleNotificationInterface $ source , Model \ SaleNotificationInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'type' , 'data' , 'sentAt' , 'details' ] ) ; }
3021	public function getBlogAvatar ( $ blogName , $ size = null ) { $ path = $ this -> blogPath ( $ blogName , '/avatar' ) ; if ( $ size ) { $ path .= "/$size" ; } return $ this -> getRedirect ( $ path , null , true ) ; }
5294	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ fontFile = realpath ( $ input -> getArgument ( 'font-file' ) ) ; if ( $ fontFile === false || ! file_exists ( $ fontFile ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'font-file' ) . '" does not exist' ) ; } $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading font file from "' . $ fontFile . '" ...' ) ; $ generator -> generateFromFont ( new Font ( array ( ) , file_get_contents ( $ fontFile ) ) ) ; $ output -> writeln ( 'writing CSS file to "' . $ outputFile . '" ...' ) ; file_put_contents ( $ outputFile , $ generator -> getCss ( ) ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created CSS file successfully</success>' ) ; }
12924	public function getHandledLocalDataItems ( ) { $ handled = [ ] ; foreach ( $ this -> localDataItems as $ local ) { if ( $ local -> handled ) { $ handled [ ] = $ local ; } } return $ handled ; }
2796	public function setAdapterOptionsFromString ( $ optionString ) { $ this -> adapterOptions = array_merge ( $ this -> adapterOptions , explode ( ' ' , $ optionString ) ) ; return $ this ; }
6511	public function onPreDeserialize ( PreDeserializeEvent $ event ) { $ type = $ event -> getType ( ) ; if ( isset ( $ type [ 'name' ] ) && ( $ type [ 'name' ] == Job :: class || is_subclass_of ( $ type [ 'name' ] , Job :: class ) ) ) { $ data = $ event -> getData ( ) ; if ( isset ( $ data [ 'type' ] ) && isset ( $ data [ 'parameters' ] ) && is_array ( $ data [ 'parameters' ] ) && count ( $ data [ 'parameters' ] ) > 0 ) { array_push ( $ data [ 'parameters' ] , [ 'abc.job.type' => $ data [ 'type' ] ] ) ; $ event -> setData ( $ data ) ; } } }
6210	public function notifyOnException ( Exception $ e , $ extraParams = null ) { $ notice = new Notice ; $ notice -> load ( array ( 'errorClass' => get_class ( $ e ) , 'backtrace' => $ this -> cleanBacktrace ( $ e -> getTrace ( ) ? : debug_backtrace ( ) ) , 'errorMessage' => $ e -> getMessage ( ) . ' in ' . $ this -> cleanFilePath ( $ e -> getFile ( ) ) . ' on line ' . $ e -> getLine ( ) , 'extraParameters' => $ extraParams , ) ) ; return $ this -> notify ( $ notice ) ; }
559	protected function buildAttributeCondition ( $ attribute , $ condition ) { if ( is_array ( $ condition ) ) { $ parts = [ ] ; foreach ( $ condition as $ operator => $ value ) { if ( isset ( $ this -> operatorTypes [ $ operator ] ) ) { if ( isset ( $ this -> conditionBuilders [ $ operator ] ) ) { $ method = $ this -> conditionBuilders [ $ operator ] ; if ( is_string ( $ method ) ) { $ callback = [ $ this , $ method ] ; } else { $ callback = $ method ; } $ parts [ ] = $ callback ( $ operator , $ value , $ attribute ) ; } else { $ parts [ ] = $ this -> buildOperatorCondition ( $ operator , $ value , $ attribute ) ; } } } if ( ! empty ( $ parts ) ) { if ( count ( $ parts ) > 1 ) { return array_merge ( [ 'AND' ] , $ parts ) ; } return array_shift ( $ parts ) ; } } return [ $ attribute => $ this -> filterAttributeValue ( $ attribute , $ condition ) ] ; }
5951	public function addFolderResponse ( $ item ) { if ( ! ( $ item instanceof FolderResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new FolderResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate FolderResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } elseif ( ! is_numeric ( $ item ) ) { trigger_error ( 'Array parameter item is not of expected type "FolderResponse"!' , E_USER_WARNING ) ; } } $ this -> results [ ] = $ item ; return $ this ; }
2864	public function getLastFilePosition ( $ filePath ) { if ( ! file_exists ( $ filePath ) ) { return 0 ; } $ f = fopen ( $ filePath , 'r' ) ; fseek ( $ f , - 1 , SEEK_END ) ; return ftell ( $ f ) ; }
6811	private function getDateFormatter ( ) { if ( $ this -> dateFormatter ) { return $ this -> dateFormatter ; } return $ this -> dateFormatter = IntlDateFormatter :: create ( $ this -> locale , IntlDateFormatter :: SHORT , IntlDateFormatter :: NONE , ini_get ( 'date.timezone' ) , IntlDateFormatter :: GREGORIAN ) ; }
12254	public function addCompiler ( $ compiler ) { if ( $ compiler instanceof CompilerFactoryInterface || $ compiler instanceof CompilerInterface ) { $ this -> compilers [ ] = $ compiler ; $ this -> orderedCompilers = NULL ; } else throw new CompilerException ( "Can only add objects that implement CompilerInterface or CompilerFactoryInterface to context" ) ; }
8686	public static function remove ( & $ data , $ path , $ default = null ) { if ( ! static :: $ unsetMarker ) { static :: $ unsetMarker = new \ stdClass ( ) ; } $ value = static :: get ( $ data , $ path , static :: $ unsetMarker ) ; if ( $ value === static :: $ unsetMarker ) { return $ default ; } static :: set ( $ data , $ path , static :: $ unsetMarker ) ; return $ value ; }
2613	private function prepareGAReqData ( ) { if ( ! empty ( $ this -> GAReqData ) ) { return $ this -> GAReqData ; } $ mandatoryReqData = [ ] ; $ mandatoryReqData [ 'v' ] = 1 ; $ mandatoryReqData [ 'tid' ] = $ this -> getGATrackingId ( ) ; $ cid = $ this -> config -> getCID ( ) ; $ mandatoryReqData [ 'cid' ] = $ cid ; $ mandatoryReqData [ 'uid' ] = $ cid ; $ mandatoryReqData [ 'ua' ] = $ this -> metaData -> getVersion ( ) ; $ mandatoryReqData [ 'geoid' ] = $ this -> getCountry ( ) ; $ mandatoryReqData [ 'ds' ] = 'Fastly' ; $ customVars = $ this -> prepareCustomVariables ( ) ; $ this -> GAReqData = array_merge ( $ mandatoryReqData , $ customVars ) ; return $ this -> GAReqData ; }
9469	private function registerLogViewerRoutes ( ) { $ this -> prefix ( 'log-viewer' ) -> name ( 'log-viewer.' ) -> group ( function ( ) { $ this -> get ( '/' , 'LogViewerController@index' ) -> name ( 'index' ) ; $ this -> prefix ( 'logs' ) -> name ( 'logs.' ) -> group ( function ( ) { $ this -> get ( '/' , 'LogViewerController@listLogs' ) -> name ( 'list' ) ; $ this -> prefix ( '{logviewer_log_date}' ) -> group ( function ( ) { $ this -> get ( '/' , 'LogViewerController@show' ) -> name ( 'show' ) ; $ this -> get ( 'download' , 'LogViewerController@download' ) -> name ( 'download' ) ; $ this -> get ( '{level}' , 'LogViewerController@showByLevel' ) -> name ( 'filter' ) ; $ this -> get ( '{level}/search' , 'LogViewerController@search' ) -> name ( 'search' ) ; $ this -> delete ( 'delete' , 'LogViewerController@delete' ) -> middleware ( 'ajax' ) -> name ( 'delete' ) ; } ) ; } ) ; } ) ; }
4635	private function attachMailListeners ( EventsCapableInterface $ service , ContainerInterface $ container , array $ mailOptions ) : void { $ listeners = ( array ) ( $ mailOptions [ 'mail_listeners' ] ?? [ ] ) ; if ( empty ( $ listeners ) ) { return ; } $ definitions = [ ] ; $ eventManager = $ service -> getEventManager ( ) ; foreach ( $ listeners as $ listener ) { $ this -> addDefinitions ( $ definitions , $ listener , $ eventManager ) ; } if ( ! empty ( $ definitions ) ) { ( new LazyListenerAggregate ( $ definitions , $ container ) ) -> attach ( $ eventManager ) ; } }
5155	public function setConfiguration ( $ configuration , $ configure = true ) { if ( ! $ configuration instanceof ConfigurationInterface ) { $ configuration = new Configuration ( $ configuration ) ; } unset ( $ this -> configuration ) ; $ this -> configuration = $ configuration ; if ( $ configure ) { $ this -> configure ( ) ; } }
4082	public function getInputScreen ( $ metaModel ) { $ inputScreen = $ this -> getInputScreenDetails ( $ metaModel ) ; return $ inputScreen ? $ inputScreen -> getId ( ) : null ; }
10649	private function buildUniqueRules ( ) { $ rulescopes = $ this -> rules ; foreach ( $ rulescopes as $ scope => & $ rules ) { foreach ( $ rules as $ field => & $ ruleset ) { $ ruleset = ( is_string ( $ ruleset ) ) ? explode ( '|' , $ ruleset ) : $ ruleset ; foreach ( $ ruleset as & $ rule ) { if ( str_contains ( $ rule , 'unique' ) && str_contains ( $ rule , '{id}' ) == false ) { $ params = explode ( ',' , $ rule ) ; $ uniqueRules = array ( ) ; $ table = explode ( ':' , $ params [ 0 ] ) ; if ( count ( $ table ) == 1 ) $ uniqueRules [ 1 ] = $ this -> table ; else $ uniqueRules [ 1 ] = $ table [ 1 ] ; if ( count ( $ params ) == 1 ) $ uniqueRules [ 2 ] = $ field ; else $ uniqueRules [ 2 ] = $ params [ 1 ] ; $ uniqueRules [ 3 ] = $ this -> getKey ( ) ; $ uniqueRules [ 4 ] = $ this -> getKeyName ( ) ; $ rule = 'unique:' . implode ( ',' , $ uniqueRules ) ; } elseif ( str_contains ( $ rule , 'unique' ) && str_contains ( $ rule , '{id}' ) ) { $ rule = str_replace ( '{id}' , $ this -> getKey ( ) , $ rule ) ; } } } } $ this -> rules = $ rulescopes ; }
11584	public function exec ( $ calcId ) { $ result = [ ] ; $ bonusPercent = Cfg :: TEAM_BONUS_EU_PERCENT ; $ dwnlCompress = $ this -> daoBonDwnl -> getByCalcId ( $ calcId ) ; $ dwnlCurrent = $ this -> daoDwnl -> get ( ) ; $ mapDwnlById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCompress , EBonDwnl :: A_CUST_REF ) ; $ mapCustById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCurrent , ECustomer :: A_CUSTOMER_REF ) ; foreach ( $ mapDwnlById as $ custId => $ custDwnl ) { $ custData = $ mapCustById [ $ custId ] ; $ custMlmId = $ custData -> getMlmId ( ) ; $ pv = $ custDwnl -> getPv ( ) ; $ parentId = $ custDwnl -> getParentRef ( ) ; $ parentDwnl = $ mapDwnlById [ $ parentId ] ; $ parentData = $ mapCustById [ $ parentId ] ; $ parentMlmId = $ parentData -> getMlmId ( ) ; $ scheme = $ this -> hlpScheme -> getSchemeByCustomer ( $ parentData ) ; if ( $ scheme == Cfg :: SCHEMA_EU ) { $ pvParent = $ parentDwnl -> getPv ( ) ; if ( $ pvParent > ( Cfg :: PV_QUALIFICATION_LEVEL_EU - Cfg :: DEF_ZERO ) ) { $ bonus = $ this -> hlpFormat -> roundBonus ( $ pv * $ bonusPercent ) ; if ( $ bonus > Cfg :: DEF_ZERO ) { $ entry = new DBonus ( ) ; $ entry -> setCustomerRef ( $ parentId ) ; $ entry -> setDonatorRef ( $ custId ) ; $ entry -> setValue ( $ bonus ) ; $ result [ ] = $ entry ; } $ this -> logger -> debug ( "parent #$parentId (ref. #$parentMlmId) has '$bonus' as EU Team Bonus from downline customer #$custId (ref. #$custMlmId )." ) ; } else { $ this -> logger -> debug ( "parent #$parentId (ref. #$parentMlmId) does not qualified t oget EU Team Bonus from downline customer #$custId (ref. #$custMlmId )." ) ; } } else { $ this -> logger -> debug ( "Parent #$parentId (ref. #$parentMlmId) has incompatible scheme '$scheme' for EU Team Bonus." ) ; } } unset ( $ mapCustById ) ; unset ( $ mapDwnlById ) ; return $ result ; }
12620	public function createModel ( $ id , $ attributes ) { return Yii :: createObject ( [ 'class' => $ this -> foreignModelClass , 'tableName' => $ this -> fileSource -> id , 'interface' => $ this -> module , 'id' => $ id , 'attributes' => $ attributes ] ) ; }
6919	public function getAdjustments ( $ type = null ) { if ( null !== $ type ) { AdjustmentTypes :: isValidType ( $ type ) ; return $ this -> adjustments -> filter ( function ( AdjustmentInterface $ a ) use ( $ type ) { return $ a -> getType ( ) === $ type ; } ) ; } return $ this -> adjustments ; }
10800	public function renderPageHistoricTableAction ( ) { $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ melisKey = $ this -> params ( ) -> fromRoute ( 'melisKey' , '' ) ; $ melisTool = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreTool' ) ; $ melisTool -> setMelisToolKey ( self :: PLUGIN_INDEX , self :: TOOL_KEY ) ; $ columns = $ melisTool -> getColumns ( ) ; $ idPage = $ this -> params ( ) -> fromRoute ( 'idPage' , $ this -> params ( ) -> fromQuery ( 'idPage' , '' ) ) ; $ container = new Container ( 'meliscore' ) ; $ locale = $ container [ 'melis-lang-locale' ] ; $ view = new ViewModel ( ) ; $ view -> melisKey = $ melisKey ; $ view -> tableColumns = $ columns ; $ view -> getToolDataTableConfig = $ melisTool -> getDataTableConfiguration ( '#tableHistoricPageId' . $ idPage , true ) ; $ view -> idPage = $ idPage ; $ view -> tableId = 'tableHistoricPageId' . $ idPage ; return $ view ; }
5379	protected function wrap ( $ text ) { $ text = str_replace ( "\r\r\n" , "\r\n" , str_replace ( "\n" , "\r\n" , $ text ) ) ; $ text = str_replace ( "\r\n\n" , "\r\n" , str_replace ( "\r" , "\r\n" , $ text ) ) ; if ( strncmp ( $ text , "\r\n" , strlen ( "\r\n" ) ) == 0 ) { $ text = substr ( $ text , strlen ( "\r\n" ) ) ; } if ( $ this -> wrapIsEnabled ( ) ) { return wordwrap ( $ text , ( integer ) $ this -> getAttribute ( 'cols' ) , "\r\n" ) ; } return $ text ; }
4051	private function buildConditionTree ( array $ conditions ) : array { $ conditionMap = [ ] ; $ bySetting = [ ] ; foreach ( $ conditions as $ condition ) { unset ( $ converted ) ; if ( array_key_exists ( $ condition [ 'id' ] , $ conditionMap ) ) { $ converted = & $ conditionMap [ $ condition [ 'id' ] ] ; foreach ( $ condition as $ key => $ value ) { $ converted [ $ key ] = $ value ; } } else { $ converted = \ array_slice ( $ condition , 0 ) ; $ conditionMap [ $ condition [ 'id' ] ] = & $ converted ; } if ( empty ( $ condition [ 'pid' ] ) ) { $ bySetting [ $ condition [ 'settingId' ] ] [ ] = & $ converted ; continue ; } if ( ! isset ( $ conditionMap [ $ condition [ 'pid' ] ] ) ) { $ temp = [ 'children' => [ ] ] ; $ conditionMap [ $ condition [ 'pid' ] ] = & $ temp ; } $ conditionMap [ $ condition [ 'pid' ] ] [ 'children' ] [ ] = & $ converted ; } return $ bySetting ; }
3295	protected function getFingers ( Lead $ lead ) { $ fingers = [ ] ; if ( $ lead -> getEmail ( ) ) { $ fingers [ 'email' ] = strtolower ( $ lead -> getEmail ( ) ) ; } if ( $ lead -> getPhone ( ) ) { $ fingers [ 'phone' ] = preg_replace ( '/\D/' , '' , $ lead -> getPhone ( ) ) ; } if ( $ lead -> getMobile ( ) ) { $ fingers [ 'mobile' ] = preg_replace ( '/\D/' , '' , $ lead -> getMobile ( ) ) ; } return $ fingers ; }
8277	public function onConfigLoaded ( array & $ config ) { $ config [ self :: PLUGIN_NAME ] = $ this -> loadDefaultConfig ( $ config ) ; $ this -> config = $ config [ self :: PLUGIN_NAME ] ; $ this -> createContainer ( ) ; $ this -> initLogger ( ) ; }
4745	public function isReviewOptInValidationRequired ( ) { $ review = oxNew ( \ OxidEsales \ Eshop \ Application \ Controller \ ReviewController :: class ) ; return $ review -> isReviewOptInValidationRequired ( ) ; }
3113	public function setStoreId ( $ testSessionId , $ storeId ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setStoreId ( $ storeId ) ; $ extendedState -> save ( ) ; }
9207	public function importTable ( Table $ Table , $ records , array $ options = [ ] ) { $ defaultOptions = [ 'checkRules' => true , 'checkExisting' => true , ] ; $ options = $ options + $ defaultOptions ; foreach ( $ records as $ record ) { $ action = ( $ record -> isNew ( ) ? 'Create' : 'Update' ) ; $ result = $ Table -> save ( $ record , $ options ) ; $ key = $ this -> findKey ( $ Table , $ record ) ; if ( $ result ) { $ this -> verbose ( "<success>{$Table->alias()} ({$key}): {$action} successful.</success>" ) ; } else { $ this -> quiet ( "<warning>{$Table->alias()} ({$key}): {$action} failed.</warning>" ) ; $ this -> printValidationErrors ( $ Table -> alias ( ) , $ this -> findKey ( $ Table , $ record ) , $ record -> errors ( ) ) ; } } }
7048	protected function formatPhoneNumber ( PhoneNumber $ number = null ) { if ( $ number ) { return $ this -> phoneNumberUtil -> format ( $ number , PhoneNumberFormat :: INTERNATIONAL ) ; } return null ; }
1504	protected function bindApi ( string $ namespace , string $ host ) : Api { $ repository = $ this -> container -> make ( Repository :: class ) ; $ api = $ repository -> createApi ( $ namespace , $ host ) ; $ this -> container -> instance ( Api :: class , $ api ) ; $ this -> container -> alias ( Api :: class , 'json-api.inbound' ) ; return $ api ; }
4141	protected function getSignatureBaseString ( ) { $ method = strtoupper ( $ this -> method ) ; $ url = rawurlencode ( $ this -> getUrl ( ) ) ; return $ method . '&' . $ url . '&' . $ this -> getRequestString ( ) ; }
2231	protected function hasUser ( ) : bool { $ user = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ user ) { return false ; } return ! ( $ user instanceof AnonymousToken ) ; }
8436	public static function fetchArray ( array $ conditions , array $ orderBy = null , bool $ critical = false ) { $ entity = new static ( ) ; $ selectQuery = new Select ( $ entity -> getDatabaseName ( ) , $ critical ) ; $ selectQuery -> select ( $ entity -> getAllFieldsRealNames ( ) ) ; $ selectQuery -> from ( $ entity -> getTableName ( ) ) ; if ( count ( $ conditions ) > 0 ) { $ where = array ( ) ; foreach ( $ conditions as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ where [ $ realName ] = ':where' . ucfirst ( $ key ) ; $ selectQuery -> bind ( 'where' . ucfirst ( $ key ) , $ value ) ; } $ selectQuery -> where ( $ where ) ; } if ( is_array ( $ orderBy ) && count ( $ orderBy ) > 0 ) { $ orders = array ( ) ; foreach ( $ orderBy as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ orders [ $ realName ] = strtoupper ( ucfirst ( $ value ) ) ; } $ selectQuery -> orderBy ( $ orders ) ; } $ selectQuery -> limit ( 1 ) ; if ( $ selectQuery -> execute ( ) === false ) { return false ; } $ data = $ selectQuery -> fetch ( ) ; if ( is_array ( $ data ) === false ) { return false ; } return $ data ; }
1358	public static function create ( $ mediaType , int $ options = 0 , string $ urlPrefix = null , int $ depth = 512 ) : self { if ( ! $ mediaType instanceof MediaTypeInterface ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } return new self ( $ mediaType , new EncoderOptions ( $ options , $ urlPrefix , $ depth ) ) ; }
3357	public function getImgTag ( $ postfix = null , $ attributes = array ( ) ) { $ to_compile = array ( ) ; foreach ( $ attributes as $ key => $ value ) { $ to_compile [ ] = sprintf ( '%s="%s"' , $ key , $ value ) ; } return sprintf ( '<img src="%s" %s />' , $ this -> getUrl ( ) , join ( ' ' , $ to_compile ) ) ; }
10601	public function editQuery ( $ name , $ value ) { $ parts = explode ( '&' , $ this -> _urlParts [ 'query' ] ) ; $ return = [ ] ; foreach ( $ parts as $ p ) { $ paramData = explode ( '=' , $ p ) ; if ( $ paramData [ 0 ] === $ name ) { $ paramData [ 1 ] = $ value ; } $ return [ ] = implode ( '=' , $ paramData ) ; } $ this -> _urlParts [ 'query' ] = implode ( '&' , $ return ) ; return $ this ; }
7941	public function setBootDevice ( $ domain , $ currentState , $ bootDevice ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ domain = ( string ) $ domain ; if ( ! $ bootDevice ) throw new BadMethodCallException ( 'Parameter $bootDevice is missing.' ) ; $ bootDevice = ( string ) $ bootDevice ; $ payload = array ( 'bootId' => $ bootDevice , 'monitoring' => $ currentState -> monitoring , 'rootDevice' => $ currentState -> rootDevice ) ; try { $ r = $ this -> put ( 'dedicated/server/' . $ domain , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
5959	public function clientGetByUid ( $ uid ) { foreach ( $ this -> clientList ( ) as $ client ) { if ( $ client [ "client_unique_identifier" ] == $ uid ) { return $ client ; } } throw new Ts3Exception ( "invalid clientID" , 0x200 ) ; }
5915	public function sendPasswordReset ( $ id , $ link = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'link' => $ link ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/resetpassword' , $ parameters ) ; return $ result ; }
7673	function TbsStorePark ( ) { if ( $ this -> TbsCurrIdx !== false ) { $ this -> TbsStoreLst [ $ this -> TbsCurrIdx ] = array ( 'src' => $ this -> TBS -> Source , 'onshow' => true ) ; $ this -> TBS -> Source = '' ; $ this -> TbsCurrIdx = false ; } }
9985	private function mapVAlign ( $ vAlign ) { switch ( $ vAlign ) { case Alignment :: VERTICAL_BOTTOM : return 'bottom' ; case Alignment :: VERTICAL_TOP : return 'top' ; case Alignment :: VERTICAL_CENTER : case Alignment :: VERTICAL_JUSTIFY : return 'middle' ; default : return 'baseline' ; } }
909	private function getHeaderAsComment ( ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ comment = ( self :: HEADER_COMMENT === $ this -> configuration [ 'comment_type' ] ? '/*' : '/**' ) . $ lineEnding ; $ lines = explode ( "\n" , str_replace ( "\r" , '' , $ this -> configuration [ 'header' ] ) ) ; foreach ( $ lines as $ line ) { $ comment .= rtrim ( ' * ' . $ line ) . $ lineEnding ; } return $ comment . ' */' ; }
6490	public function getDrupalSelector ( $ name ) { $ selectors = $ this -> getDrupalParameter ( 'selectors' ) ; if ( ! isset ( $ selectors [ $ name ] ) ) { throw new \ Exception ( sprintf ( 'No such selector configured: %s' , $ name ) ) ; } return $ selectors [ $ name ] ; }
4778	public function addWidget ( ItemInterface $ item ) { if ( $ this -> checkRole ) { if ( $ item -> getRole ( ) && ! $ this -> security -> isGranted ( $ item -> getRole ( ) ) ) { return $ this ; } } $ this -> widgets [ $ item -> getId ( ) ] = $ item ; return $ this ; }
4417	public function showLocationLayouts ( $ locationId ) { $ repository = $ this -> getRepository ( ) ; $ location = $ repository -> getLocationService ( ) -> loadLocation ( $ locationId ) ; $ content = $ repository -> getContentService ( ) -> loadContent ( $ location -> contentInfo -> id ) ; $ request = $ this -> createRequest ( $ content , $ location ) ; return $ this -> render ( '@NetgenAdminUI/layouts/location_layouts.html.twig' , array ( 'rules' => $ this -> layoutResolver -> resolveRules ( $ request , array ( 'ez_content_type' ) ) , 'related_layouts' => $ this -> relatedLayoutsLoader -> loadRelatedLayouts ( $ location ) , 'location' => $ location , ) ) ; }
8176	public function actionRecoverPassword ( ) { $ model = new AccountRecoverPasswordForm ( ) ; if ( $ model -> load ( Yii :: $ app -> request -> post ( ) ) ) { if ( $ model -> validate ( ) ) { $ model -> recoverPassword ( ) ; } } return $ this -> render ( 'recoverPassword' , [ 'model' => $ model ] ) ; }
5682	public function getFrameset ( ) { if ( ! $ this -> hasFrames ( ) ) { return false ; } $ urls = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ name = $ this -> frames [ $ i ] -> getAttribute ( 'name' ) ; $ url = new SimpleUrl ( $ this -> frames [ $ i ] -> getAttribute ( 'src' ) ) ; $ key = $ name ? $ name : $ i + 1 ; $ urls [ $ key ] = $ this -> expandUrl ( $ url ) ; } return $ urls ; }
8047	public function send ( $ data ) { $ serialized = serialize ( $ data ) ; $ hdr = pack ( 'N' , strlen ( $ serialized ) ) ; $ buffer = $ hdr . $ serialized ; unset ( $ serialized ) ; unset ( $ hdr ) ; $ total = strlen ( $ buffer ) ; while ( $ total > 0 ) { $ sent = socket_write ( $ this -> socket , $ buffer ) ; if ( $ sent === FALSE ) { throw new SimpleSocketException ( 'Sending failed with: ' . socket_strerror ( socket_last_error ( $ this -> socket ) ) ) ; } $ total -= $ sent ; $ buffer = substr ( $ buffer , $ sent ) ; } }
5638	public function shouldInvoke ( $ test_case , $ method ) { if ( $ this -> shouldRunTest ( $ test_case , $ method ) ) { return $ this -> reporter -> shouldInvoke ( $ test_case , $ method ) ; } return false ; }
7577	protected function setFileFieldValue ( $ value ) { if ( version_compare ( PHP_VERSION , '5.5.0' ) >= 0 ) { if ( ! ( $ value instanceof \ CURLFile ) ) { $ value = ltrim ( $ value , "@" ) ; $ value = new \ CURLFile ( $ value ) ; } } else { if ( strpos ( $ value , '@' ) !== 0 ) { $ value = '@' . $ value ; } } return $ value ; }
907	private function findClassyElements ( $ index ) { $ elements = [ ] ; $ curlyBracesLevel = 0 ; $ bracesLevel = 0 ; $ classIndex = $ index ; ++ $ index ; for ( $ count = \ count ( $ this -> tokens ) ; $ index < $ count ; ++ $ index ) { $ token = $ this -> tokens [ $ index ] ; if ( $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) ) { continue ; } if ( $ token -> isClassy ( ) ) { list ( $ index , $ newElements ) = $ this -> findClassyElements ( $ index ) ; $ elements += $ newElements ; continue ; } if ( $ token -> equals ( '(' ) ) { ++ $ bracesLevel ; continue ; } if ( $ token -> equals ( ')' ) ) { -- $ bracesLevel ; continue ; } if ( $ token -> equals ( '{' ) ) { ++ $ curlyBracesLevel ; continue ; } if ( $ token -> equals ( '}' ) ) { -- $ curlyBracesLevel ; if ( 0 === $ curlyBracesLevel ) { break ; } continue ; } if ( 1 !== $ curlyBracesLevel || ! $ token -> isArray ( ) ) { continue ; } if ( 0 === $ bracesLevel && $ token -> isGivenKind ( T_VARIABLE ) ) { $ elements [ $ index ] = [ 'token' => $ token , 'type' => 'property' , 'classIndex' => $ classIndex , ] ; continue ; } if ( $ token -> isGivenKind ( T_FUNCTION ) ) { $ elements [ $ index ] = [ 'token' => $ token , 'type' => 'method' , 'classIndex' => $ classIndex , ] ; } elseif ( $ token -> isGivenKind ( T_CONST ) ) { $ elements [ $ index ] = [ 'token' => $ token , 'type' => 'const' , 'classIndex' => $ classIndex , ] ; } } return [ $ index , $ elements ] ; }
3608	public function getResourceOwnerDetailsUrl ( AccessToken $ token ) { $ uri = new Uri ( $ this -> urlResourceOwnerDetails ) ; return ( string ) Uri :: withQueryValue ( $ uri , 'access_token' , ( string ) $ token ) ; }
1055	public static function findBreakingChanges ( Schema $ oldSchema , Schema $ newSchema ) { return array_merge ( self :: findRemovedTypes ( $ oldSchema , $ newSchema ) , self :: findTypesThatChangedKind ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnObjectOrInterfaceTypes ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnInputObjectTypes ( $ oldSchema , $ newSchema ) [ 'breakingChanges' ] , self :: findTypesRemovedFromUnions ( $ oldSchema , $ newSchema ) , self :: findValuesRemovedFromEnums ( $ oldSchema , $ newSchema ) , self :: findArgChanges ( $ oldSchema , $ newSchema ) [ 'breakingChanges' ] , self :: findInterfacesRemovedFromObjectTypes ( $ oldSchema , $ newSchema ) , self :: findRemovedDirectives ( $ oldSchema , $ newSchema ) , self :: findRemovedDirectiveArgs ( $ oldSchema , $ newSchema ) , self :: findAddedNonNullDirectiveArgs ( $ oldSchema , $ newSchema ) , self :: findRemovedDirectiveLocations ( $ oldSchema , $ newSchema ) ) ; }
912	private function moveParamAnnotations ( $ content ) { $ doc = new DocBlock ( $ content ) ; $ params = $ doc -> getAnnotationsOfType ( 'param' ) ; if ( empty ( $ params ) ) { return $ content ; } $ others = $ doc -> getAnnotationsOfType ( [ 'throws' , 'return' ] ) ; if ( empty ( $ others ) ) { return $ content ; } $ end = end ( $ params ) -> getEnd ( ) ; $ line = $ doc -> getLine ( $ end ) ; foreach ( $ others as $ other ) { if ( $ other -> getStart ( ) < $ end ) { $ line -> setContent ( $ line -> getContent ( ) . $ other -> getContent ( ) ) ; $ other -> remove ( ) ; } } return $ doc -> getContent ( ) ; }
8300	public function handleEvent ( $ eventName , array $ params ) { parent :: handleEvent ( $ eventName , $ params ) ; if ( $ this -> isEnabled ( ) ) { $ this -> picoAuthPlugin -> handleEvent ( $ eventName , $ params ) ; } }
9255	public function getRootDir ( ) { if ( ! $ this -> rootDir ) { $ refl = new \ ReflectionObject ( $ this ) ; $ filename = $ refl -> getFileName ( ) ; if ( false !== ( $ pos = strrpos ( $ filename , '/vendor/' ) ) ) { $ filename = substr ( $ filename , 0 , $ pos ) ; } else { $ filename = dirname ( $ filename ) . '/..' ; } $ this -> rootDir = str_replace ( '\\' , '/' , $ filename ) ; } return $ this -> rootDir ; }
5728	public function Field ( $ properties = array ( ) ) { Requirements :: css ( BETTER_BUTTONS_DIR . '/css/dropdown_form_action.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/dropdown_form_action.js' ) ; $ this -> setAttribute ( 'data-form-action-dropdown' , '#' . $ this -> DropdownID ( ) ) ; return parent :: Field ( ) ; }
12319	public function redirect ( string $ shortURLKey ) { $ record = HCShortURL :: where ( 'short_url_key' , $ shortURLKey ) -> first ( ) ; if ( ! $ record ) abort ( 404 ) ; $ record -> increment ( 'clicks' ) ; return redirect ( $ record -> url ) ; }
12163	public function getFormSegment ( $ primaryModel = null , $ settings = [ ] ) { if ( empty ( $ primaryModel ) ) { return false ; } return $ primaryModel -> form ( $ settings ) ; }
2312	public function getCacheName ( ) { $ importantPart = $ this -> getImportantPart ( ) ; $ strCacheKey = substr ( md5 ( '-w' . $ this -> getTargetWidth ( ) . '-h' . $ this -> getTargetHeight ( ) . '-o' . $ this -> getOriginalPath ( ) . '-m' . $ this -> getResizeMode ( ) . '-z' . $ this -> getZoomLevel ( ) . '-x' . $ importantPart [ 'x' ] . '-y' . $ importantPart [ 'y' ] . '-i' . $ importantPart [ 'width' ] . '-e' . $ importantPart [ 'height' ] . '-t' . $ this -> fileObj -> mtime ) , 0 , 8 ) ; return StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'contao.image.target_dir' ) ) . '/' . substr ( $ strCacheKey , - 1 ) . '/' . $ this -> fileObj -> filename . '-' . $ strCacheKey . '.' . $ this -> fileObj -> extension ; }
8263	protected function onStateMismatch ( ) { $ this -> logger -> warning ( "OAuth2 response state mismatch: provider: {provider} from {addr}" , array ( "provider" => get_class ( $ this -> provider ) , "addr" => $ _SERVER [ 'REMOTE_ADDR' ] ) ) ; $ this -> session -> remove ( "oauth2state" ) ; $ this -> session -> addFlash ( "error" , "Invalid OAuth response." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
9900	private function advance ( ) { $ i = $ this -> currentCharacter ; $ formula_length = strlen ( $ this -> formula ) ; if ( $ i < $ formula_length ) { while ( $ this -> formula [ $ i ] == ' ' ) { ++ $ i ; } if ( $ i < ( $ formula_length - 1 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 1 ] ; } $ token = '' ; } while ( $ i < $ formula_length ) { $ token .= $ this -> formula [ $ i ] ; if ( $ i < ( $ formula_length - 1 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 1 ] ; } else { $ this -> lookAhead = '' ; } if ( $ this -> match ( $ token ) != '' ) { $ this -> currentCharacter = $ i + 1 ; $ this -> currentToken = $ token ; return 1 ; } if ( $ i < ( $ formula_length - 2 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 2 ] ; } else { $ this -> lookAhead = '' ; } ++ $ i ; } }
2884	public function startProfiling ( ) { $ this -> canCapture = Mage :: helper ( 'sheep_debug' ) -> canCapture ( ) ; if ( ! $ this -> canCapture ) { return ; } $ requestInfo = $ this -> getRequestInfo ( ) ; $ requestInfo -> setIsStarted ( true ) ; $ this -> registerShutdown ( ) ; $ requestInfo -> setStoreId ( $ this -> getCurrentStore ( ) -> getId ( ) ) ; $ requestInfo -> setDate ( date ( 'Y-m-d H:i:s' ) ) ; $ requestInfo -> initController ( ) ; $ requestInfo -> initLogging ( ) ; if ( Mage :: helper ( 'sheep_debug' ) -> canEnableVarienProfiler ( ) ) { Varien_Profiler :: enable ( ) ; } $ stackTraceProfiler = Mage :: getModel ( 'sheep_debug/db_profiler' ) ; $ stackTraceProfiler -> setCaptureStacktraces ( Mage :: helper ( 'sheep_debug' ) -> canEnableSqlStacktrace ( ) ) ; $ stackTraceProfiler -> replaceProfiler ( ) ; }
7546	function setNamespace ( $ ns ) { if ( $ this -> getNamespace ( ) !== $ ns ) { $ this -> tag_ns [ 0 ] = $ ns ; $ this -> tag = $ ns . ':' . $ this -> tag_ns [ 1 ] ; } }
7204	public function getDiscount ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> discount ) : $ this -> discount ; }
7738	public function serialize ( $ entity ) { if ( ! $ this -> container -> has ( 'hydra.serializer' ) ) { throw new \ LogicException ( 'The HydraBundle is not registered in your application.' ) ; } return $ this -> container -> get ( 'hydra.serializer' ) -> serialize ( $ entity , self :: FORMAT ) ; }
740	protected function saveRules ( ) { $ rules = [ ] ; foreach ( $ this -> rules as $ name => $ rule ) { $ rules [ $ name ] = serialize ( $ rule ) ; } $ this -> saveToFile ( $ rules , $ this -> ruleFile ) ; }
1567	public function getType ( ) : string { if ( $ resource = $ this -> getResource ( ) ) { return get_class ( $ resource ) ; } $ resourceType = $ this -> getResourceType ( ) ; if ( ! $ type = $ this -> resolver -> getType ( $ resourceType ) ) { throw new RuntimeException ( "JSON API resource type {$resourceType} is not registered." ) ; } return $ type ; }
10181	public function add ( $ pCoord , Cell $ cell ) { if ( $ pCoord !== $ this -> currentCoordinate ) { $ this -> storeCurrentCell ( ) ; } $ this -> index [ $ pCoord ] = true ; $ this -> currentCoordinate = $ pCoord ; $ this -> currentCell = $ cell ; $ this -> currentCellIsDirty = true ; return $ cell ; }
7064	protected function supports ( PaymentInterface $ payment ) { if ( null === $ method = $ payment -> getMethod ( ) ) { throw new RuntimeException ( "Payment method must be set." ) ; } if ( $ method -> isCredit ( ) || $ method -> isOutstanding ( ) ) { return true ; } return false ; }
3483	public function withMutableContent ( bool $ mutableContent ) : Aps { $ cloned = clone $ this ; $ cloned -> mutableContent = $ mutableContent ; return $ cloned ; }
11546	public function changeSecurityQuestion ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangeSecurityQuestionForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
12232	public function cloneChildrenFrom ( SimpleXMLElement $ src , $ deep = true ) { $ src = dom_import_simplexml ( $ src ) ; $ dst = dom_import_simplexml ( $ this ) ; $ doc = $ dst -> ownerDocument ; $ fragment = $ doc -> createDocumentFragment ( ) ; foreach ( $ src -> childNodes as $ child ) { $ fragment -> appendChild ( $ doc -> importNode ( $ child -> cloneNode ( $ deep ) , $ deep ) ) ; } $ dst -> appendChild ( $ fragment ) ; return $ this ; }
74	public function requestToken ( $ originUrl , $ consumerKey , $ consumerSecret ) { if ( ! empty ( $ this -> token ) || $ this -> getTokenFromConfig ( $ originUrl ) ) { return $ this -> token [ 'access_token' ] ; } $ this -> io -> setAuthentication ( $ originUrl , $ consumerKey , $ consumerSecret ) ; if ( ! $ this -> requestAccessToken ( $ originUrl ) ) { return '' ; } $ this -> storeInAuthConfig ( $ originUrl , $ consumerKey , $ consumerSecret ) ; return $ this -> token [ 'access_token' ] ; }
10478	protected function resolveItemAction ( AbstractDiffItem $ item ) { if ( $ item instanceof CreateDiffItem ) { $ action = ActionTypes :: CREATE ; return $ action ; } elseif ( $ item instanceof DeleteDiffItem ) { $ action = ActionTypes :: DELETE ; return $ action ; } elseif ( $ item instanceof UpdateDiffItem ) { $ action = ActionTypes :: UPDATE ; return $ action ; } else { throw new \ InvalidArgumentException ( 'Unsupported diff item type. Got: ' . get_class ( $ item ) ) ; } }
3504	private function createByReason ( string $ reason , array $ json ) : SendNotificationException { $ reason = strtolower ( $ reason ) ; switch ( $ reason ) { case 'badcollapseid' : return new BadCollapseIdException ( ) ; case 'baddevicetoken' : return new BadDeviceTokenException ( ) ; case 'badexpirationdate' : return new BadExpirationDateException ( ) ; case 'badmessageid' : return new BadMessageIdException ( ) ; case 'badpriority' : return new BadPriorityException ( ) ; case 'badtopic' : return new BadTopicException ( ) ; case 'devicetokennotfortopic' : return new DeviceTokenNotForTopicException ( ) ; case 'duplicateheaders' : return new DuplicateHeadersException ( ) ; case 'idletimeout' : return new IdleTimeoutException ( ) ; case 'missingdevicetoken' : return new MissingDeviceTokenException ( ) ; case 'missingtopic' : return new MissingTopicException ( ) ; case 'payloadempty' : return new PayloadEmptyException ( ) ; case 'topicdisallowed' : return new TopicDisallowedException ( ) ; case 'badcertificate' : return new BadCertificateException ( ) ; case 'badcertificateenvironment' : return new BadCertificateEnvironmentException ( ) ; case 'expiredprovidertoken' : return new ExpiredProviderTokenException ( ) ; case 'forbidden' : return new ForbiddenException ( ) ; case 'invalidprovidertoken' : return new InvalidProviderTokenException ( ) ; case 'missingprovidertoken' : return new MissingProviderTokenException ( ) ; case 'badpath' : return new BadPathException ( ) ; case 'methodnotallowed' : return new MethodNotAllowedException ( ) ; case 'unregistered' : $ timestamp = array_key_exists ( 'timestamp' , $ json ) ? $ json [ 'timestamp' ] : 0 ; $ lastConfirmed = new \ DateTime ( 'now' , new \ DateTimeZone ( 'UTC' ) ) ; $ lastConfirmed -> setTimestamp ( $ timestamp ) ; return new UnregisteredException ( $ lastConfirmed ) ; case 'payloadtoolarge' : return new PayloadTooLargeException ( ) ; case 'toomanyprovidertokenupdates' : return new TooManyProviderTokenUpdatesException ( ) ; case 'toomanyrequests' : return new TooManyRequestsException ( ) ; case 'internalservererror' : return new InternalServerErrorException ( ) ; case 'serviceunavailable' : return new ServiceUnavailableException ( ) ; case 'shutdown' : return new ShutdownException ( ) ; default : return new UndefinedErrorException ( ) ; } }
1995	public function generateRss ( ) { $ this -> adjustPublicationDate ( ) ; $ xml = '<?xml version="1.0" encoding="' . Config :: get ( 'characterSet' ) . '"?>' ; $ xml .= '<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/" xmlns:atom="http://www.w3.org/2005/Atom">' ; $ xml .= '<channel>' ; $ xml .= '<title>' . StringUtil :: specialchars ( $ this -> title ) . '</title>' ; $ xml .= '<description>' . StringUtil :: specialchars ( $ this -> description ) . '</description>' ; $ xml .= '<link>' . StringUtil :: specialchars ( $ this -> link ) . '</link>' ; $ xml .= '<language>' . $ this -> language . '</language>' ; $ xml .= '<pubDate>' . date ( 'r' , $ this -> published ) . '</pubDate>' ; $ xml .= '<generator>Contao Open Source CMS</generator>' ; $ xml .= '<atom:link href="' . StringUtil :: specialchars ( Environment :: get ( 'base' ) . 'share/' . $ this -> strName ) . '.xml" rel="self" type="application/rss+xml" />' ; foreach ( $ this -> arrItems as $ objItem ) { $ xml .= '<item>' ; $ xml .= '<title>' . StringUtil :: specialchars ( strip_tags ( StringUtil :: stripInsertTags ( $ objItem -> title ) ) ) . '</title>' ; $ xml .= '<description><![CDATA[' . preg_replace ( '/[\n\r]+/' , ' ' , $ objItem -> description ) . ']]></description>' ; $ xml .= '<link>' . StringUtil :: specialchars ( $ objItem -> link ) . '</link>' ; $ xml .= '<pubDate>' . date ( 'r' , $ objItem -> published ) . '</pubDate>' ; if ( $ objItem -> guid ) { if ( strncmp ( $ objItem -> guid , 'http://' , 7 ) !== 0 && strncmp ( $ objItem -> guid , 'https://' , 8 ) !== 0 ) { $ xml .= '<guid isPermaLink="false">' . $ objItem -> guid . '</guid>' ; } else { $ xml .= '<guid>' . $ objItem -> guid . '</guid>' ; } } else { $ xml .= '<guid>' . StringUtil :: specialchars ( $ objItem -> link ) . '</guid>' ; } if ( \ is_array ( $ objItem -> enclosure ) ) { foreach ( $ objItem -> enclosure as $ arrEnclosure ) { if ( ! empty ( $ arrEnclosure [ 'media' ] ) && $ arrEnclosure [ 'media' ] == 'media:content' ) { $ xml .= '<media:content url="' . $ arrEnclosure [ 'url' ] . '" type="' . $ arrEnclosure [ 'type' ] . '" />' ; } else { $ xml .= '<enclosure url="' . $ arrEnclosure [ 'url' ] . '" length="' . $ arrEnclosure [ 'length' ] . '" type="' . $ arrEnclosure [ 'type' ] . '" />' ; } } } $ xml .= '</item>' ; } $ xml .= '</channel>' ; $ xml .= '</rss>' ; return $ xml ; }
12542	public function get ( ) : \ TheCMSThread \ Core \ Main \ View { if ( $ this -> getLink ( ) == '/' ) { $ this -> details = Model \ Page :: find ( 1 ) ; } else { $ this -> details = Model \ Page :: where ( 'link' , $ this -> getLink ( ) ) ; if ( $ this -> auth -> allow ( [ "min" => 3 , "max" => 1 ] ) === false ) { $ this -> details -> where ( 'status' , true ) ; } $ this -> details = $ this -> details -> first ( ) ; } if ( $ this -> details === null ) { $ this -> details = false ; } return $ this ; }
5861	protected function compileRulesets ( array $ rulesets ) { $ out = [ ] ; $ elements = $ rulesets [ 'data' ] [ 'sDEF' ] [ 'lDEF' ] [ 'ruleset' ] [ 'el' ] ; foreach ( $ elements as $ container ) { if ( isset ( $ container [ 'container' ] [ 'el' ] ) ) { $ values = [ ] ; foreach ( $ container [ 'container' ] [ 'el' ] as $ key => $ value ) { if ( $ key === 'title' ) { continue ; } $ values [ $ key ] = $ value [ 'vDEF' ] ; } $ out [ ] = $ this -> expandValuesInRuleset ( $ values ) ; } } return $ out ; }
9981	public function writeVMLComments ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ comments = $ pWorksheet -> getComments ( ) ; $ objWriter -> startElement ( 'xml' ) ; $ objWriter -> writeAttribute ( 'xmlns:v' , 'urn:schemas-microsoft-com:vml' ) ; $ objWriter -> writeAttribute ( 'xmlns:o' , 'urn:schemas-microsoft-com:office:office' ) ; $ objWriter -> writeAttribute ( 'xmlns:x' , 'urn:schemas-microsoft-com:office:excel' ) ; $ objWriter -> startElement ( 'o:shapelayout' ) ; $ objWriter -> writeAttribute ( 'v:ext' , 'edit' ) ; $ objWriter -> startElement ( 'o:idmap' ) ; $ objWriter -> writeAttribute ( 'v:ext' , 'edit' ) ; $ objWriter -> writeAttribute ( 'data' , '1' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:shapetype' ) ; $ objWriter -> writeAttribute ( 'id' , '_x0000_t202' ) ; $ objWriter -> writeAttribute ( 'coordsize' , '21600,21600' ) ; $ objWriter -> writeAttribute ( 'o:spt' , '202' ) ; $ objWriter -> writeAttribute ( 'path' , 'm,l,21600r21600,l21600,xe' ) ; $ objWriter -> startElement ( 'v:stroke' ) ; $ objWriter -> writeAttribute ( 'joinstyle' , 'miter' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:path' ) ; $ objWriter -> writeAttribute ( 'gradientshapeok' , 't' ) ; $ objWriter -> writeAttribute ( 'o:connecttype' , 'rect' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; foreach ( $ comments as $ key => $ value ) { $ this -> writeVMLComment ( $ objWriter , $ key , $ value ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
1887	protected function linkToPage ( $ intPage ) { if ( $ intPage <= 1 && ! $ this -> blnForceParam ) { return ampersand ( $ this -> strUrl ) ; } else { return ampersand ( $ this -> strUrl ) . $ this -> strVarConnector . $ this -> strParameter . '=' . $ intPage ; } }
1660	public function reply ( $ reply ) { if ( is_string ( $ reply ) ) { $ this -> replies = [ $ reply ] ; } elseif ( is_array ( $ reply ) ) { $ this -> replies = $ reply ; } return $ this ; }
1861	public function chmod ( $ strFile , $ varMode ) { $ this -> validate ( $ strFile ) ; return chmod ( $ this -> strRootDir . '/' . $ strFile , $ varMode ) ; }
9308	public function register ( ) { $ app = $ this -> app ; $ app -> bind ( 'Germanazo\CkanApi\CkanApiClient' , function ( ) { $ config = [ 'base_uri' => config ( 'ckan_api.url' ) , 'headers' => [ 'Authorization' => config ( 'ckan_api.api_key' ) ] , ] ; return new CkanApiClient ( new Client ( $ config ) ) ; } ) ; $ app -> alias ( 'Germanazo\CkanApi\CkanApiClient' , 'CkanApi' ) ; }
4543	public function addFilterConstraint ( ClassMetadata $ targetEntity , $ targetTableAlias ) { if ( ! $ targetEntity -> reflClass -> implementsInterface ( Tenantable :: class ) ) { return '' ; } $ tenant = trim ( $ this -> getParameter ( 'tenant' ) , '\'' ) ; if ( '' === $ tenant ) { $ constraint = sprintf ( '%s.tenant is NULL' , $ targetTableAlias ) ; } else { $ constraint = sprintf ( '%s.tenant = \'%s\'' , $ targetTableAlias , $ tenant ) ; } return $ constraint ; }
10899	public function save ( bool $ validate = true ) : self { if ( $ validate && $ this -> validate ( ) ) { throw new Exception ( 'Entity ' . $ this -> __getEntityName ( ) . ' data is not valid' ) ; } $ scheme = \ array_keys ( $ this -> getScheme ( ) ) ; foreach ( $ this -> data as $ key => $ value ) { if ( ! \ in_array ( $ key , $ scheme , true ) ) { unset ( $ this -> data [ $ key ] ) ; } } if ( $ this -> getId ( ) ) { $ this -> medoo -> update ( $ this -> getTable ( ) , $ this -> data , [ 'id' => $ this -> getId ( ) ] ) ; } else { $ this -> medoo -> insert ( $ this -> getTable ( ) , $ this -> data ) ; $ this -> setId ( $ this -> medoo -> id ( ) ) ; } $ this -> sentry -> breadcrumbs -> record ( [ 'message' => 'Entity ' . $ this -> __getEntityName ( ) . '::save()' , 'data' => [ 'query' => $ this -> medoo -> last ( ) ] , 'category' => 'Database' , 'level' => 'info' , ] ) ; return $ this ; }
86	public function archive ( PackageInterface $ package , $ format , $ targetDir , $ fileName = null , $ ignoreFilters = false ) { if ( empty ( $ format ) ) { throw new \ InvalidArgumentException ( 'Format must be specified' ) ; } $ usableArchiver = null ; foreach ( $ this -> archivers as $ archiver ) { if ( $ archiver -> supports ( $ format , $ package -> getSourceType ( ) ) ) { $ usableArchiver = $ archiver ; break ; } } if ( null === $ usableArchiver ) { throw new \ RuntimeException ( sprintf ( 'No archiver found to support %s format' , $ format ) ) ; } $ filesystem = new Filesystem ( ) ; if ( null === $ fileName ) { $ packageName = $ this -> getPackageFilename ( $ package ) ; } else { $ packageName = $ fileName ; } $ filesystem -> ensureDirectoryExists ( $ targetDir ) ; $ target = realpath ( $ targetDir ) . '/' . $ packageName . '.' . $ format ; $ filesystem -> ensureDirectoryExists ( dirname ( $ target ) ) ; if ( ! $ this -> overwriteFiles && file_exists ( $ target ) ) { return $ target ; } if ( $ package instanceof RootPackageInterface ) { $ sourcePath = realpath ( '.' ) ; } else { $ sourcePath = sys_get_temp_dir ( ) . '/composer_archive' . uniqid ( ) ; $ filesystem -> ensureDirectoryExists ( $ sourcePath ) ; try { $ this -> downloadManager -> download ( $ package , $ sourcePath ) ; } catch ( \ Exception $ e ) { $ filesystem -> removeDirectory ( $ sourcePath ) ; throw $ e ; } if ( file_exists ( $ composerJsonPath = $ sourcePath . '/composer.json' ) ) { $ jsonFile = new JsonFile ( $ composerJsonPath ) ; $ jsonData = $ jsonFile -> read ( ) ; if ( ! empty ( $ jsonData [ 'archive' ] [ 'exclude' ] ) ) { $ package -> setArchiveExcludes ( $ jsonData [ 'archive' ] [ 'exclude' ] ) ; } } } $ tempTarget = sys_get_temp_dir ( ) . '/composer_archive' . uniqid ( ) . '.' . $ format ; $ filesystem -> ensureDirectoryExists ( dirname ( $ tempTarget ) ) ; $ archivePath = $ usableArchiver -> archive ( $ sourcePath , $ tempTarget , $ format , $ package -> getArchiveExcludes ( ) , $ ignoreFilters ) ; $ filesystem -> rename ( $ archivePath , $ target ) ; if ( ! $ package instanceof RootPackageInterface ) { $ filesystem -> removeDirectory ( $ sourcePath ) ; } $ filesystem -> remove ( $ tempTarget ) ; return $ target ; }
5306	protected function transformPath ( $ path , $ scale , $ roundPrecision , $ flip , $ xOffset , $ yOffset ) { if ( $ flip === 'horizontal' || $ flip === 'vertical' ) { $ viewBox = $ this -> getViewBox ( ) ; } return preg_replace_callback ( '([m,l,h,v,c,s,q,t,a,z](?:[\\s,]*-?(?=\\.?\\d)\\d*(?:\\.\\d+)?)*)i' , function ( $ maches ) use ( $ scale , $ roundPrecision , $ flip , $ xOffset , $ yOffset , $ viewBox ) { $ command = substr ( $ maches [ 0 ] , 0 , 1 ) ; $ absoluteCommand = strtoupper ( $ command ) === $ command ; $ xyCommand = in_array ( strtolower ( $ command ) , array ( 'm' , 'l' , 'c' , 's' , 'q' , 't' ) ) ; $ xCommand = strtolower ( $ command ) === 'h' ; $ yCommand = strtolower ( $ command ) === 'v' ; if ( strtolower ( $ command ) === 'z' ) { return $ command ; } if ( strtolower ( $ command ) === 'a' ) { throw new \ Exception ( 'Path command "A" is currently not supportet!' ) ; } $ values = $ this -> getValuesFromList ( substr ( $ maches [ 0 ] , 1 ) ) ; foreach ( $ values as $ key => $ value ) { if ( $ flip === 'horizontal' && ( ( ! ( $ key % 2 ) && $ xyCommand ) || $ xCommand ) ) { $ values [ $ key ] *= - 1 ; if ( $ absoluteCommand ) { $ values [ $ key ] += $ viewBox [ 'width' ] ; } } if ( $ flip === 'vertical' && ( ( $ key % 2 && $ xyCommand ) || $ yCommand ) ) { $ values [ $ key ] *= - 1 ; if ( $ absoluteCommand ) { $ values [ $ key ] += $ viewBox [ 'height' ] ; } } if ( $ absoluteCommand && ( ( ! ( $ key % 2 ) && $ xyCommand ) || $ xCommand ) ) { $ values [ $ key ] += $ xOffset ; } if ( $ absoluteCommand && ( ( $ key % 2 && $ xyCommand ) || $ yCommand ) ) { $ values [ $ key ] += $ yOffset ; } $ values [ $ key ] *= $ scale ; if ( $ roundPrecision !== null ) { $ values [ $ key ] = round ( $ values [ $ key ] , $ roundPrecision ) ; } } return $ command . implode ( ' ' , $ values ) ; } , $ path ) ; }
11275	protected function buildResponse ( ) { $ res = array ( ) ; $ res [ 'type' ] = $ this -> getParameters ( ) -> getType ( ) ; $ res [ 'tid' ] = $ this -> getParameters ( ) -> getTid ( ) ; $ res [ 'action' ] = $ this -> getParameters ( ) -> getAction ( ) ; $ res [ 'method' ] = $ this -> getParameters ( ) -> getMethod ( ) ; $ res [ 'result' ] = $ this -> getResult ( ) ; return $ res ; }
1943	public function onReplaceInsertTags ( string $ tag ) { $ chunks = explode ( '::' , $ tag ) ; if ( 'asset' !== $ chunks [ 0 ] ) { return false ; } $ url = $ this -> packages -> getUrl ( $ chunks [ 1 ] , $ chunks [ 2 ] ?? null ) ; return ltrim ( $ url , '/' ) ; }
6543	public function current ( ) { $ this -> prepareQuery ( ) ; if ( false !== current ( $ this -> idsArray ) ) { return current ( $ this -> idsArray ) ; } else { throw new PointerException ( 'Can\'t retrieve the current element' ) ; } }
2919	public function updateSetter ( $ key , $ value = null , $ comment = null , $ export = false ) { $ pattern = "/^(export\h)?\h*{$key}=.*/m" ; $ line = $ this -> formatter -> formatSetterLine ( $ key , $ value , $ comment , $ export ) ; $ this -> buffer = preg_replace ( $ pattern , $ line , $ this -> buffer ) ; return $ this ; }
3479	public function withActionLocalized ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> actionLocalized = $ localized ; return $ cloned ; }
1852	protected function getNextPage ( $ rootPageId ) { $ objNextPage = PageModel :: findFirstPublishedByPid ( $ rootPageId ) ; if ( null === $ objNextPage ) { $ this -> log ( 'No active page found under root page "' . $ rootPageId . '")' , __METHOD__ , TL_ERROR ) ; throw new NoActivePageFoundException ( 'No active page found under root page.' ) ; } return $ objNextPage ; }
4465	public function run ( string $ command , array $ args ) { if ( empty ( $ this -> sha ) ) { $ this -> reload ( ) ; } $ arguments = $ this -> normalizeCommandArgs ( $ command , $ args ) ; try { return call_user_func_array ( [ $ this -> redis , 'evalsha' ] , $ arguments ) ; } catch ( \ Exception $ exception ) { throw ExceptionFactory :: fromErrorMessage ( $ exception -> getMessage ( ) ) ; } }
10661	public function withoutCookie ( $ cookieName = null ) { $ object = clone $ this ; if ( ! $ this -> configs [ 'cookies' ] instanceof CookieJarInterface ) { return $ object ; } if ( ! $ cookieName ) { unset ( $ object -> configs [ 'cookies' ] ) ; } else { if ( ! is_array ( $ cookieName ) ) { $ cookieName = [ $ cookieName ] ; } $ cookies = $ this -> configs [ 'cookies' ] -> toArray ( ) ; foreach ( $ cookieName as $ cookie ) { if ( ! is_string ( $ cookie ) || ! $ cookie ) { continue ; } unset ( $ cookies [ $ cookie ] ) ; } $ this -> configs [ 'cookies' ] = new CookieJar ( $ cookies ) ; } return $ object -> buildConfigClient ( ) ; }
11086	public static function getOctets ( $ option ) { if ( preg_match ( '/\d+k/i' , $ option ) ) { return 1024 * ( int ) $ option ; } if ( preg_match ( '/\d+m/i' , $ option ) ) { return 1024 * 1024 * ( int ) $ option ; } if ( preg_match ( '/\d+g/i' , $ option ) ) { return 1024 * 1024 * 1024 * ( int ) $ option ; } return $ option ; }
1692	protected function shortenHexColor ( $ color ) { if ( $ color [ 0 ] == $ color [ 1 ] && $ color [ 2 ] == $ color [ 3 ] && $ color [ 4 ] == $ color [ 5 ] ) { return $ color [ 0 ] . $ color [ 2 ] . $ color [ 4 ] ; } return $ color ; }
5634	protected function handle ( & $ test , $ filename ) { if ( preg_match ( $ this -> pattern , $ filename ) ) { parent :: handle ( $ test , $ filename ) ; } }
3519	public function getWebUITranslations ( ) { $ TITLE_SAVE_CHANGES = $ this -> get ( $ this -> package . '::messages.title-save-changes' ) ; $ TITLE_CANCEL_CHANGES = $ this -> get ( $ this -> package . '::messages.title-cancel-changes' ) ; $ TITLE_TRANSLATE = $ this -> get ( $ this -> package . '::messages.title-translate' ) ; $ TITLE_CONVERT_KEY = $ this -> get ( $ this -> package . '::messages.title-convert-key' ) ; $ TITLE_GENERATE_PLURALS = $ this -> get ( $ this -> package . '::messages.title-generate-plurals' ) ; $ TITLE_CLEAN_HTML_MARKDOWN = $ this -> get ( $ this -> package . '::messages.title-clean-html-markdown' ) ; $ TITLE_CAPITALIZE = $ this -> get ( $ this -> package . '::messages.title-capitalize' ) ; $ TITLE_LOWERCASE = $ this -> get ( $ this -> package . '::messages.title-lowercase' ) ; $ TITLE_CAPITALIZE_FIRST_WORD = $ this -> get ( $ this -> package . '::messages.title-capitalize-first-word' ) ; $ TITLE_SIMULATED_COPY = $ this -> get ( $ this -> package . '::messages.title-simulated-copy' ) ; $ TITLE_SIMULATED_PASTE = $ this -> get ( $ this -> package . '::messages.title-simulated-paste' ) ; $ TITLE_RESET_EDITOR = $ this -> get ( $ this -> package . '::messages.title-reset-editor' ) ; $ TITLE_LOAD_LAST = $ this -> get ( $ this -> package . '::messages.title-load-last' ) ; return <<<HTML<script>var TITLE_SAVE_CHANGES = "$TITLE_SAVE_CHANGES";var TITLE_CANCEL_CHANGES = "$TITLE_CANCEL_CHANGES";var TITLE_TRANSLATE = "$TITLE_TRANSLATE";var TITLE_CONVERT_KEY = "$TITLE_CONVERT_KEY";var TITLE_GENERATE_PLURALS = "$TITLE_GENERATE_PLURALS";var TITLE_CLEAN_HTML_MARKDOWN = "$TITLE_CLEAN_HTML_MARKDOWN";var TITLE_CAPITALIZE = "$TITLE_CAPITALIZE";var TITLE_LOWERCASE = "$TITLE_LOWERCASE";var TITLE_CAPITALIZE_FIRST_WORD = "$TITLE_CAPITALIZE_FIRST_WORD";var TITLE_SIMULATED_COPY = "$TITLE_SIMULATED_COPY";var TITLE_SIMULATED_PASTE = "$TITLE_SIMULATED_PASTE";var TITLE_RESET_EDITOR = "$TITLE_RESET_EDITOR";var TITLE_LOAD_LAST = "$TITLE_LOAD_LAST";</script>HTML ; }
1362	public function accept ( AcceptMediaTypeInterface $ mediaType ) : bool { if ( 0 === $ mediaType -> getQuality ( ) ) { return false ; } return $ this -> matchesTo ( $ mediaType ) ; }
3743	protected function setLanguage ( $ language = '' ) { $ previousLanguage = $ GLOBALS [ 'TL_LANGUAGE' ] ; if ( ! empty ( $ language ) && ( $ GLOBALS [ 'TL_LANGUAGE' ] !== $ language ) ) { $ GLOBALS [ 'TL_LANGUAGE' ] = $ language ; } return $ previousLanguage ; }
1879	public function protect ( ) { @ trigger_error ( 'Using DC_Folder::protect() has been deprecated and will no longer work in Contao 5.0. Use Contao\Folder::protect() and Contao\Folder::unprotect() instead.' , E_USER_DEPRECATED ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ this -> intId ) ) { throw new InternalServerErrorException ( 'Resource "' . $ this -> intId . '" is not a directory.' ) ; } if ( file_exists ( $ this -> strRootDir . '/' . $ this -> intId . '/.public' ) ) { $ objFolder = new Folder ( $ this -> intId ) ; $ objFolder -> protect ( ) ; $ this -> import ( Automator :: class , 'Automator' ) ; $ this -> Automator -> generateSymlinks ( ) ; $ this -> log ( 'Folder "' . $ this -> intId . '" has been protected' , __METHOD__ , TL_FILES ) ; } else { $ objFolder = new Folder ( $ this -> intId ) ; $ objFolder -> unprotect ( ) ; $ this -> import ( Automator :: class , 'Automator' ) ; $ this -> Automator -> generateSymlinks ( ) ; $ this -> log ( 'The protection from folder "' . $ this -> intId . '" has been removed' , __METHOD__ , TL_FILES ) ; } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
7132	protected function updateExchangeRate ( SupplierOrderInterface $ order ) { if ( null !== $ order -> getExchangeRate ( ) ) { return false ; } if ( ! SupplierOrderStates :: isStockableState ( $ order -> getState ( ) ) ) { return false ; } $ date = new \ DateTime ( ) ; $ rate = $ this -> currencyConverter -> getRate ( $ this -> currencyConverter -> getDefaultCurrency ( ) , $ order -> getCurrency ( ) -> getCode ( ) , $ date ) ; $ order -> setExchangeRate ( $ rate ) -> setExchangeDate ( $ date ) ; return true ; }
4365	public function onErrorHighPri ( Event $ error ) { $ this -> throttleDataRead ( ) ; $ hash = $ error [ 'hash' ] ; $ error [ 'email' ] = ( $ error [ 'type' ] & $ this -> cfg [ 'emailMask' ] ) && $ error [ 'isFirstOccur' ] && $ this -> cfg [ 'emailTo' ] ; $ error [ 'stats' ] = array ( 'tsEmailed' => 0 , 'countSince' => 0 , 'emailedTo' => '' , ) ; if ( isset ( $ this -> throttleData [ 'errors' ] [ $ hash ] ) ) { $ stats = \ array_intersect_key ( $ this -> throttleData [ 'errors' ] [ $ hash ] , $ error [ 'stats' ] ) ; $ error [ 'stats' ] = \ array_merge ( $ error [ 'stats' ] , $ stats ) ; } return ; }
1820	public function extractVimeoId ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> vimeo != $ varValue ) { $ matches = array ( ) ; if ( preg_match ( '%vimeo\.com/(?:channels/(?:\w+/)?|groups/(?:[^/]+)/videos/|album/(?:\d+)/video/)?(\d+)(?:$|/|\?)%i' , $ varValue , $ matches ) ) { $ varValue = $ matches [ 1 ] ; } } return $ varValue ; }
12395	abstract public function __construct ( ConnectionInterface $ connection ) ;
2241	public static function getArticle ( $ varId , $ blnMultiMode = false , $ blnIsInsertTag = false , $ strColumn = 'main' ) { global $ objPage ; if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( ! $ varId ) { return '' ; } $ objRow = ArticleModel :: findByIdOrAliasAndPid ( $ varId , ( ! $ blnIsInsertTag ? $ objPage -> id : null ) ) ; if ( $ objRow === null ) { return false ; } } if ( ! static :: isVisibleElement ( $ objRow ) ) { return '' ; } if ( isset ( $ _GET [ 'pdf' ] ) && Input :: get ( 'pdf' ) == $ objRow -> id ) { if ( $ objRow -> printable == 1 ) { @ trigger_error ( 'Setting tl_article.printable to "1" has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ objArticle = new ModuleArticle ( $ objRow ) ; $ objArticle -> generatePdf ( ) ; } elseif ( $ objRow -> printable != '' ) { $ options = StringUtil :: deserialize ( $ objRow -> printable ) ; if ( \ is_array ( $ options ) && \ in_array ( 'pdf' , $ options ) ) { $ objArticle = new ModuleArticle ( $ objRow ) ; $ objArticle -> generatePdf ( ) ; } } } $ objRow -> headline = $ objRow -> title ; $ objRow -> multiMode = $ blnMultiMode ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] as $ callback ) { static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow ) ; } } $ objArticle = new ModuleArticle ( $ objRow , $ strColumn ) ; $ strBuffer = $ objArticle -> generate ( $ blnIsInsertTag ) ; if ( $ objArticle -> protected && ! preg_match ( '/^\s*<!-- indexer::stop/' , $ strBuffer ) ) { $ strBuffer = "\n<!-- indexer::stop . $ strBuffer . "<!-- indexer::continue ; } return $ strBuffer ; }
11416	private function saveLog ( $ operId , $ calcId ) { $ entity = new ELogOper ( ) ; $ entity -> setOperId ( $ operId ) ; $ entity -> setCalcId ( $ calcId ) ; $ this -> daoLogOper -> create ( $ entity ) ; }
2311	public function getResizedPath ( ) { $ path = $ this -> resizedPath ; $ webDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'contao.web_dir' ) ) ; if ( strncmp ( $ path , $ webDir . '/' , \ strlen ( $ webDir ) + 1 ) === 0 ) { $ path = substr ( $ path , \ strlen ( $ webDir ) + 1 ) ; } return $ path ; }
10266	public function setRotation ( $ pValue ) { if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'rotation' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> rotation = $ pValue ; } return $ this ; }
11254	public function drop ( ) : array { $ touched = [ ] ; $ this -> pdo -> beginTransaction ( ) ; foreach ( $ this -> getViews ( ) as $ view ) { $ this -> pdo -> exec ( "drop view if exists {$view} cascade" ) ; $ touched [ ] = [ 'view' , $ view ] ; } foreach ( $ this -> getTables ( ) as $ table ) { $ this -> pdo -> exec ( "drop table if exists {$table} cascade" ) ; $ touched [ ] = [ 'table' , $ table ] ; } $ this -> pdo -> commit ( ) ; return $ touched ; }
6793	protected function getTagSortSourceColumn ( $ prefix = null ) { $ column = $ this -> get ( 'tag_srcsorting' ) ; if ( ! $ column ) { return null ; } if ( null !== $ prefix ) { return $ prefix . '.' . $ column ; } return $ column ; }
8792	public function tag ( $ tag , $ content , array $ attributes = [ ] ) { $ content = is_array ( $ content ) ? implode ( PHP_EOL , $ content ) : $ content ; return $ this -> toHtmlString ( '<' . $ tag . $ this -> attributes ( $ attributes ) . '>' . PHP_EOL . $ this -> toHtmlString ( $ content ) . PHP_EOL . '</' . $ tag . '>' . PHP_EOL ) ; }
11973	private function genericParamValidation ( Event $ event ) { $ params = $ event -> getCustomParams ( ) ; return ( count ( $ params ) >= 1 && count ( $ params ) <= 2 ) ; }
10546	public function setRequest ( Request $ request ) { $ this -> request = $ request ; $ this -> app = null ; $ this -> vhost = null ; $ this -> route = null ; $ this -> setVariable ( 'request' , $ request ) ; return $ this ; }
717	public function dateTime ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DATETIME , $ precision ) ; }
8344	public static function run ( ) { if ( self :: $ isInit === true ) { if ( ( self :: $ rawRequest instanceof RawRequest ) === false ) { throw new RuntimeException ( 'Raw request was not specified!' ) ; } self :: $ request = new Request ( self :: $ rawRequest , self :: $ routes ) ; self :: $ controllers = array ( ) ; self :: $ response = new Response ( ) ; try { ob_start ( ) ; $ before = self :: $ request -> getBefore ( ) ; foreach ( $ before as $ b ) { $ controller = Controllers :: get ( $ b [ 'class' ] ) ; $ action = $ b [ 'action' ] ; $ controller -> $ action ( self :: $ request , self :: $ response ) ; if ( self :: $ request -> hasEnded ( ) === true ) { break ; } } if ( self :: $ request -> hasEnded ( ) === false ) { $ controller = Controllers :: get ( self :: $ request -> getClass ( ) ) ; $ action = self :: $ request -> getAction ( ) ; $ controller -> $ action ( self :: $ request , self :: $ response ) ; if ( self :: $ request -> hasEnded ( ) === false ) { $ after = self :: $ request -> getAfter ( ) ; foreach ( $ after as $ a ) { $ controller = Controllers :: get ( $ a [ 'class' ] ) ; $ action = $ a [ 'action' ] ; $ controller -> $ action ( self :: $ request , self :: $ response ) ; } } } $ render = self :: $ response -> getRender ( ) ; if ( ! ( $ render instanceof RenderInterface ) ) { throw new NotARender ( 'response->render is a non RenderInterface implementing object' ) ; } echo $ render -> render ( self :: $ response -> data ) ; ob_end_flush ( ) ; } catch ( \ Exception $ e ) { ob_end_clean ( ) ; throw $ e ; } } }
10014	public function getIndex ( Worksheet $ pSheet ) { foreach ( $ this -> workSheetCollection as $ key => $ value ) { if ( $ value -> getHashCode ( ) == $ pSheet -> getHashCode ( ) ) { return $ key ; } } throw new Exception ( 'Sheet does not exist.' ) ; }
1846	public static function unixToJd ( $ tstamp ) { list ( $ year , $ month , $ day ) = explode ( ',' , date ( 'Y,m,d' , $ tstamp ) ) ; $ year += ( $ year < 0 ? 4801 : 4800 ) ; if ( $ month > 2 ) { $ month -= 3 ; } else { $ month += 9 ; -- $ year ; } $ sdn = floor ( ( floor ( $ year / 100 ) * 146097 ) / 4 ) ; $ sdn += floor ( ( ( $ year % 100 ) * 1461 ) / 4 ) ; $ sdn += floor ( ( $ month * 153 + 2 ) / 5 ) ; $ sdn += $ day - 32045 ; return $ sdn ; }
1942	public function listRecipient ( $ row ) { $ label = Contao \ Idna :: decodeEmail ( $ row [ 'email' ] ) ; if ( $ row [ 'addedOn' ] ) { $ label .= ' <span style="color:#999;padding-left:3px">(' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'subscribed' ] , Contao \ Date :: parse ( Contao \ Config :: get ( 'datimFormat' ) , $ row [ 'addedOn' ] ) ) . ')</span>' ; } else { $ label .= ' <span style="color:#999;padding-left:3px">(' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'manually' ] . ')</span>' ; } return sprintf ( '<div class="tl_content_left"><div class="list_icon" style="background-image:url(\'%ssystem/themes/%s/icons/%s.svg\')" data-icon="member.svg" data-icon-disabled="member_.svg">%s</div></div>' , Contao \ System :: getContainer ( ) -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) , Contao \ Backend :: getTheme ( ) , ( $ row [ 'active' ] ? 'member' : 'member_' ) , $ label ) . "\n" ; }
1702	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objArchive = NewsArchiveModel :: findByProtected ( '' ) ; if ( $ objArchive !== null ) { while ( $ objArchive -> next ( ) ) { if ( ! $ objArchive -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objArchive -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objArchive -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objArchive -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objArchive -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objArchive -> jumpTo ] ; $ objArticle = NewsModel :: findPublishedDefaultByPid ( $ objArchive -> id ) ; if ( $ objArticle !== null ) { while ( $ objArticle -> next ( ) ) { $ arrPages [ ] = $ this -> getLink ( $ objArticle , $ strUrl ) ; } } } } return $ arrPages ; }
2547	public function analyzeResponse ( $ sendResult , $ messageName ) { if ( ! empty ( $ sendResult -> exception ) ) { return $ this -> makeResultForException ( $ sendResult ) ; } $ handler = $ this -> findHandlerForMessage ( $ messageName ) ; if ( $ handler instanceof MessageResponseHandler ) { return $ handler -> analyze ( $ sendResult ) ; } else { return new Result ( $ sendResult , Result :: STATUS_UNKNOWN ) ; } }
8372	public function help ( Request $ request ) { $ routes = Console :: getRoutes ( ) ; echo 'strayFw console help screen' . PHP_EOL . 'Available actions :' . PHP_EOL . PHP_EOL ; $ namespace = null ; foreach ( $ routes as $ route ) { if ( $ namespace != $ route [ 'namespace' ] ) { $ namespace = $ route [ 'namespace' ] ; echo $ namespace . PHP_EOL . PHP_EOL ; } echo ' ' . $ route [ 'usage' ] . PHP_EOL ; if ( isset ( $ route [ 'help' ] ) != null ) { echo ' ' . $ route [ 'help' ] ; } echo PHP_EOL . PHP_EOL ; } }
7579	protected function configureDefaultData ( array $ data ) { foreach ( $ this -> _REQUIRED_DATA as $ property => $ value ) { if ( ! isset ( $ data [ $ property ] ) && $ value !== null ) { $ data [ $ property ] = $ value ; } } return $ data ; }
7463	private static function renderTemplate ( string $ __file__ , array $ data ) : string { ob_start ( ) ; extract ( $ data ) ; include $ __file__ ; return ob_get_clean ( ) ; }
475	public function delete ( $ table , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "delete from $table" ) ; $ this -> db -> createCommand ( ) -> delete ( $ table , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
6157	public function redirectSelf ( ) : object { $ url = $ this -> di -> get ( "request" ) -> getCurrentUrl ( ) ; return parent :: redirect ( $ this -> di -> get ( "url" ) -> create ( $ url ) ) ; }
11054	public static function printts ( $ datatree , $ containers , $ entry = 'main' ) { $ this -> printt ( $ datatree , $ containers , $ entry , _ETS_STRING_READ , '' , '' ) ; }
8986	public function get_columns ( ) { return array ( 'id' => new IntegerBased ( 'BIGINT' , 'id' , array ( 'NOT NULL' , 'auto_increment' ) , array ( 20 ) ) , 'message' => new StringBased ( 'VARCHAR' , 'message' , array ( ) , array ( 255 ) ) , 'level' => new StringBased ( 'VARCHAR' , 'level' , array ( ) , array ( 20 ) ) , 'lgroup' => new StringBased ( 'VARCHAR' , 'lgroup' , array ( ) , array ( 20 ) ) , 'time' => new DateTime ( 'time' ) , 'user' => new ForeignUser ( 'user' ) , 'ip' => new StringBased ( 'VARCHAR' , 'ip' , array ( ) , array ( 45 ) ) , 'exception' => new StringBased ( 'VARCHAR' , 'exception' , array ( ) , array ( 255 ) ) , 'trace' => new StringBased ( 'LONGTEXT' , 'trace' ) , 'context' => new StringBased ( 'LONGTEXT' , 'context' ) , ) ; }
4894	public function end ( ) { if ( ! $ this -> captureLock ) { throw new \ RuntimeException ( 'Cannot end capture, there is no capture running.' ) ; } $ type = $ this -> captureType ; $ content = ob_get_clean ( ) ; $ options = $ this -> captureOptions ; $ this -> captureLock = false ; $ this -> captureType = null ; $ this -> captureOptions = null ; return $ this -> render ( $ type , $ content , $ options ) ; }
6545	public function create ( $ name ) { $ sheet = $ this -> container -> createSheet ( ) ; $ sheet -> setTitle ( $ name ) ; return new \ Aimeos \ MW \ Container \ Content \ PHPExcel ( $ sheet , $ name , $ this -> getOptions ( ) ) ; }
6661	protected function getControllerMethod ( $ methodName ) { $ reflectionMethod = $ this -> reflectedController -> getMethod ( $ methodName ) ; $ reflectionMethod -> setAccessible ( true ) ; return function ( ) use ( $ reflectionMethod ) { return $ reflectionMethod -> invokeArgs ( $ this -> controller , func_get_args ( ) ) ; } ; }
12058	public function getPossibleTargets ( ) { if ( is_null ( $ this -> _possibleTargets ) ) { $ this -> _possibleTargets = [ ] ; if ( $ this -> canEndRelation ( ) ) { $ this -> _possibleTargets [ ] = 'end_relationship' ; } if ( $ this -> canDeleteRelation ( ) ) { $ this -> _possibleTargets [ ] = 'delete_relationship' ; } if ( $ this -> canArchiveObject ( ) ) { if ( $ this -> object -> archived ) { $ this -> _possibleTargets [ ] = 'unarchive_object' ; } else { $ this -> _possibleTargets [ ] = 'archive_object' ; } } if ( $ this -> canDeleteObject ( ) ) { $ this -> _possibleTargets [ ] = 'delete_object' ; } } return $ this -> _possibleTargets ; }
986	public function confirmationUrl ( ) { $ charge = $ this -> api -> rest ( 'POST' , "/admin/{$this->plan->typeAsString(true)}.json" , [ "{$this->plan->typeAsString()}" => $ this -> chargeParams ( ) ] ) -> body -> { $ this -> plan -> typeAsString ( ) } ; return $ charge -> confirmation_url ; }
6729	public function set_movie_rating ( $ post_id , $ rating ) { if ( ! add_post_meta ( $ post_id , 'imdbRating' , $ rating , true ) ) { update_post_meta ( $ post_id , 'imdbRating' , $ rating ) ; } }
8394	public static function before ( string $ path , string $ usage , string $ help , string $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'before' , 'path' => $ path , 'usage' => $ usage , 'help' => $ help , 'action' => $ action , 'namespace' => self :: $ namespace ) ; } }
6880	public function transform ( $ data ) { $ address = new ShipmentAddress ( ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { return $ address ; } foreach ( $ this -> fields as $ field ) { if ( isset ( $ data [ $ field ] ) ) { $ value = $ data [ $ field ] ; if ( $ field === 'country' ) { if ( 0 >= $ value ) { throw new InvalidArgumentException ( "Invalid country id." ) ; } $ value = $ this -> countryRepository -> find ( $ value ) ; if ( null === $ value ) { throw new InvalidArgumentException ( "Country not found." ) ; } } elseif ( $ field === 'phone' || $ field === 'mobile' ) { $ value = unserialize ( $ value ) ; if ( ! $ value instanceof PhoneNumber ) { throw new InvalidArgumentException ( "Invalid phone number." ) ; } } $ this -> accessor -> setValue ( $ address , $ field , $ value ) ; } } return $ address ; }
6524	public function getHandlerMethodName ( $ withMajor = true ) { if ( true === $ withMajor ) { return lcfirst ( $ this -> classShortName ) ; } return lcfirst ( str_replace ( 'V' . $ this -> id -> getVersion ( ) -> getMajor ( ) , '' , $ this -> classShortName ) ) ; }
12922	public function getForeignDataItems ( ) { if ( ! isset ( $ this -> _foreignDataItems ) ) { $ this -> _foreignDataItems = [ ] ; $ this -> trigger ( self :: EVENT_LOAD_FOREIGN_DATA_ITEMS ) ; } return $ this -> _foreignDataItems ; }
3491	public function withHeader ( string $ name , string $ value ) : Request { $ cloned = clone $ this ; $ cloned -> headers [ $ name ] = $ value ; return $ cloned ; }
1138	public function destroyDescendants ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> select ( $ self -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>' , $ lft ) -> where ( $ rgtCol , '<' , $ rgt ) -> delete ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>' , $ rgt ) -> decrement ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>' , $ rgt ) -> decrement ( $ rgtCol , $ diff ) ; } ) ; }
5303	protected static function hexToUnicode ( $ char ) { if ( ! is_string ( $ char ) || ! preg_match ( '(^[0-9a-f]{2,6}$)i' , $ char ) ) { throw new \ InvalidArgumentException ( '$char must be one single unicode character as hex string' ) ; } return mb_convert_encoding ( '&#x' . strtolower ( $ char ) . ';' , 'UTF-8' , 'HTML-ENTITIES' ) ; }
11386	public function exec ( $ calcId = null ) { if ( is_null ( $ calcId ) ) { $ calcId = $ this -> queryGetCalcId -> exec ( ) ; } if ( ! isset ( $ this -> cachedIds [ $ calcId ] ) ) { $ ids = [ ] ; $ where = \ Praxigento \ BonusHybrid \ Repo \ Data \ Registry \ SignUpDebit :: A_CALC_REF . '=' . ( int ) $ calcId ; $ rs = $ this -> daoRegistry -> get ( $ where ) ; foreach ( $ rs as $ one ) { $ ids [ ] = $ one -> getCustomerRef ( ) ; } $ this -> cachedIds [ $ calcId ] = $ ids ; } return $ this -> cachedIds [ $ calcId ] ; }
557	protected function buildConjunctionCondition ( $ operator , $ condition ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } $ result = [ $ operator ] ; foreach ( $ condition as $ part ) { $ result [ ] = $ this -> buildCondition ( $ part ) ; } return $ result ; }
8051	public function getAllEvents ( ) : array { $ calendarEvents = null ; $ cache = $ this -> cache ; if ( $ cache :: has ( self :: ALL_EVENTS_KEY ) ) { return $ cache :: get ( self :: ALL_EVENTS_KEY ) ; } $ allEvents = $ this -> calendarEvent -> with ( [ 'calendarEventRepeatDates' ] ) -> get ( ) ; $ calendarEvents = $ allEvents -> keyBy ( 'id' ) -> toArray ( ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ calendarEvents , $ this -> cacheTimeToLive ) ; return $ calendarEvents ; }
7460	public function lookup ( $ hash , $ className = 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) { try { return $ this -> hashedEntityHelper -> lookup ( $ hash , $ className ) ; } catch ( \ RuntimeException $ e ) { return null ; } }
3984	private function addMenu ( & $ modules , $ section , $ name , $ module , Request $ request ) { if ( ! isset ( $ modules [ $ section ] ) ) { $ modules [ $ section ] = $ this -> buildBackendMenuSection ( $ section , $ request ) ; } $ active = $ this -> isActive ( $ module [ 'route' ] , $ module [ 'param' ] , $ request ) ; $ class = 'navigation ' . $ name ; if ( isset ( $ module [ 'class' ] ) ) { $ class .= ' ' . $ module [ 'class' ] ; } if ( $ active ) { $ class .= ' active' ; } if ( $ request -> query -> has ( 'ref' ) ) { $ module [ 'param' ] [ 'ref' ] = $ request -> query -> get ( 'ref' ) ; } $ modules [ $ section ] [ 'modules' ] [ $ name ] = [ 'label' => $ module [ 'label' ] , 'title' => $ module [ 'title' ] , 'class' => $ class , 'isActive' => $ active , 'href' => $ this -> urlGenerator -> generate ( $ module [ 'route' ] , $ module [ 'param' ] ) , ] ; }
5099	public function into ( $ table , array $ fields = null ) { $ this -> setPart ( CmdInsert :: PART_INTO , $ table ) ; if ( ! is_null ( $ fields ) ) { $ this -> placeholder = false ; $ this -> fields = $ fields ; } return $ this ; }
4242	public function onOutput ( ) { if ( $ this -> debug -> parentInstance ) { return ; } $ vals = $ this -> runtimeVals ( ) ; $ this -> debug -> groupSummary ( 1 ) ; $ this -> debug -> info ( 'Built In ' . $ vals [ 'runtime' ] . ' sec' ) ; $ this -> debug -> info ( 'Peak Memory Usage' . ( $ this -> debug -> getCfg ( 'output/outputAs' ) == 'html' ? ' <span title="Includes debug overhead">?&#x20dd;</span>' : '' ) . ': ' . $ this -> debug -> utilities -> getBytes ( $ vals [ 'memoryPeakUsage' ] ) . ' / ' . $ this -> debug -> utilities -> getBytes ( $ vals [ 'memoryLimit' ] ) ) ; $ this -> debug -> groupEnd ( ) ; }
2578	protected function loadArnk ( Segment \ ArrivalUnknown $ segment ) { $ this -> travelProduct = new TravelProduct ( ) ; $ this -> travelProduct -> productDetails = new ProductDetails ( $ segment -> identification ) ; $ this -> messageAction = new MessageAction ( Business :: FUNC_ARNK ) ; }
5268	public function esc_like ( $ value , $ start = '%' , $ end = '%' ) { global $ wpdb ; return $ start . $ wpdb -> esc_like ( $ value ) . $ end ; }
5746	public function getForm ( string $ csrfNameKey , string $ csrfNameValue , string $ csrfValueKey , string $ csrfValueValue , string $ action , ? string $ usernameValue = null ) { $ administratorsTableMapper = AdministratorsTableMapper :: getInstance ( ) ; $ fields = [ ] ; $ fields [ ] = DatabaseTableForm :: getFieldFromDatabaseColumn ( $ administratorsTableMapper -> getColumnByName ( self :: USERNAME_FIELD ) , null , $ usernameValue ) ; $ fields [ ] = DatabaseTableForm :: getFieldFromDatabaseColumn ( $ administratorsTableMapper -> getColumnByName ( self :: PASSWORD_FIELD ) , null , null , 'Password' , 'password' ) ; $ fields [ ] = FormHelper :: getCsrfNameField ( $ csrfNameKey , $ csrfNameValue ) ; $ fields [ ] = FormHelper :: getCsrfValueField ( $ csrfValueKey , $ csrfValueValue ) ; $ fields [ ] = FormHelper :: getSubmitField ( ) ; return new Form ( $ fields , [ 'method' => 'post' , 'action' => $ action , 'novalidate' => 'novalidate' ] , FormHelper :: getGeneralError ( ) ) ; }
3918	private function checkDownloads ( ) { if ( $ this -> getShowImages ( ) ) { return ; } if ( ( $ file = Input :: get ( 'file' ) ) && ( $ key = Input :: get ( 'fileKey' ) ) ) { if ( ! ( array_key_exists ( $ file , $ _SESSION [ 'metaModels_downloads' ] ) && $ _SESSION [ 'metaModels_downloads' ] [ $ file ] === $ key ) ) { $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'error_403' ] ( ) ; $ objHandler -> generate ( $ file ) ; } Controller :: sendFileToBrowser ( $ file ) ; } }
9531	private function respondDefault ( & $ i , & $ results , $ parameter ) { $ defaultResult = $ this -> parameterCluster -> default -> call ( $ this , $ parameter ) ; if ( $ defaultResult === - 1 ) { $ this -> valid = false ; } $ results [ $ parameter ] = $ defaultResult ; $ i ++ ; }
7535	function delete ( ) { if ( ( $ p = $ this -> parent ) !== null ) { $ this -> parent = null ; $ p -> deleteChild ( $ this ) ; } else { $ this -> clear ( ) ; } }
6763	public function append ( Collection $ collection ) { if ( ! $ collection ) return $ this ; $ this -> models = array_merge ( $ this -> array ( ) , $ collection -> array ( ) ) ; return $ this ; }
3308	protected function signature ( ) { $ signatureKey = $ this -> buildSignatureKey ( ) ; $ sing = hash_hmac ( 'SHA1' , $ signatureKey , $ this -> secretKey , true ) ; return base64_encode ( $ sing . $ signatureKey ) ; }
4278	public function stream_read ( $ count ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ buffer = \ fread ( $ this -> handle , $ count ) ; $ bufferLen = \ strlen ( $ buffer ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS , 2 ) ; $ isRequire = ! \ in_array ( $ backtrace [ 1 ] [ 'function' ] , array ( 'file_get_contents' ) ) ; if ( ! $ this -> declaredTicks && $ isRequire ) { foreach ( self :: $ pathsExclude as $ excludePath ) { if ( \ strpos ( $ this -> filepath , $ excludePath . DIRECTORY_SEPARATOR ) === 0 ) { $ this -> declaredTicks = true ; } } } if ( ! $ this -> declaredTicks && $ isRequire ) { $ buffer = \ preg_replace ( '/^(<\?php\s*)$/m' , '$0 declare(ticks=1);' , $ buffer , 1 ) ; $ this -> declaredTicks = true ; self :: $ filesModified [ ] = $ this -> filepath ; } $ buffer = $ this -> bufferPrepend . $ buffer ; $ bufferLenAfter = \ strlen ( $ buffer ) ; $ diff = $ bufferLenAfter - $ bufferLen ; $ this -> bufferPrepend = '' ; if ( $ diff ) { $ this -> bufferPrepend = \ substr ( $ buffer , $ count ) ; $ buffer = \ substr ( $ buffer , 0 , $ count ) ; } self :: register ( ) ; return $ buffer ; }
3121	public function filter ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = null ; if ( isset ( $ tag ) ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; } $ subset = new static ( ) ; foreach ( $ this -> points as $ idx => $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { $ subset -> add ( $ point ) ; } } return $ subset ; }
2204	public static function encodeSpecialChars ( $ varValue ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: encodeSpecialChars ( $ v ) ; } return $ varValue ; } $ arrSearch = array ( '#' , '<' , '>' , '(' , ')' , '\\' , '=' ) ; $ arrReplace = array ( '&#35;' , '&#60;' , '&#62;' , '&#40;' , '&#41;' , '&#92;' , '&#61;' ) ; return str_replace ( $ arrSearch , $ arrReplace , $ varValue ) ; }
2804	public function searchAction ( ) { $ requests = $ this -> _getFilteredRequests ( ) ; $ this -> loadLayout ( 'sheep_debug' ) ; $ rootBlock = $ this -> getLayout ( ) -> getBlock ( 'root' ) ; $ rootBlock -> setHeaderTitle ( $ this -> __ ( 'Request profiles' ) ) ; $ profileListBlock = $ this -> getLayout ( ) -> getBlock ( 'sheep_debug_list' ) ; $ profileListBlock -> setData ( 'results' , $ requests ) ; $ this -> renderLayout ( ) ; }
10196	public function createStringTable ( Worksheet $ pSheet , $ pExistingTable = null ) { $ aStringTable = [ ] ; $ cellCollection = null ; $ aFlippedStringTable = null ; if ( ( $ pExistingTable !== null ) && is_array ( $ pExistingTable ) ) { $ aStringTable = $ pExistingTable ; } $ aFlippedStringTable = $ this -> flipStringTable ( $ aStringTable ) ; foreach ( $ pSheet -> getCoordinates ( ) as $ coordinate ) { $ cell = $ pSheet -> getCell ( $ coordinate ) ; $ cellValue = $ cell -> getValue ( ) ; if ( ! is_object ( $ cellValue ) && ( $ cellValue !== null ) && $ cellValue !== '' && ! isset ( $ aFlippedStringTable [ $ cellValue ] ) && ( $ cell -> getDataType ( ) == DataType :: TYPE_STRING || $ cell -> getDataType ( ) == DataType :: TYPE_STRING2 || $ cell -> getDataType ( ) == DataType :: TYPE_NULL ) ) { $ aStringTable [ ] = $ cellValue ; $ aFlippedStringTable [ $ cellValue ] = true ; } elseif ( $ cellValue instanceof RichText && ( $ cellValue !== null ) && ! isset ( $ aFlippedStringTable [ $ cellValue -> getHashCode ( ) ] ) ) { $ aStringTable [ ] = $ cellValue ; $ aFlippedStringTable [ $ cellValue -> getHashCode ( ) ] = true ; } } return $ aStringTable ; }
5745	private function getDebugBacktraceString ( ) : string { $ out = "" ; $ dbt = debug_backtrace ( ~ DEBUG_BACKTRACE_PROVIDE_OBJECT & ~ DEBUG_BACKTRACE_IGNORE_ARGS ) ; array_shift ( $ dbt ) ; array_shift ( $ dbt ) ; $ showVendorCalls = true ; $ showFullFilePath = true ; $ startFilePath = '/Src' ; $ showClassNamespace = false ; foreach ( $ dbt as $ index => $ call ) { $ outLine = "#$index:" ; if ( isset ( $ call [ 'file' ] ) ) { if ( ! $ showVendorCalls && strstr ( $ call [ 'file' ] , '/vendor/' ) ) { break ; } $ outLine .= " " ; if ( $ showFullFilePath ) { $ outLine .= $ call [ 'file' ] ; } else { $ fileParts = explode ( $ startFilePath , $ call [ 'file' ] ) ; $ outLine .= ( isset ( $ fileParts [ 1 ] ) ) ? $ fileParts [ 1 ] : $ call [ 'file' ] ; } } if ( isset ( $ call [ 'line' ] ) ) { $ outLine .= " [" . $ call [ 'line' ] . "] " ; } if ( isset ( $ call [ 'class' ] ) ) { $ classParts = explode ( "\\" , $ call [ 'class' ] ) ; $ outLine .= " " ; $ outLine .= ( $ showClassNamespace ) ? $ call [ 'class' ] : $ classParts [ count ( $ classParts ) - 1 ] ; } if ( isset ( $ call [ 'type' ] ) ) { $ outLine .= $ call [ 'type' ] ; } if ( isset ( $ call [ 'function' ] ) ) { $ outLine .= $ call [ 'function' ] . "()" ; } if ( isset ( $ call [ 'args' ] ) ) { $ outLine .= " {" . Functions :: arrayWalkToStringRecursive ( $ call [ 'args' ] , 0 , 1000 , PHP_EOL ) . "}" ; } $ out .= "$outLine" . PHP_EOL ; } return $ out ; }
11380	public function deleteAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/..\/(\w+)$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } list ( $ dummy , $ pageName , $ containerName ) = $ matches ; $ pageTexts = $ this -> getTextModel ( $ pageName ) ; $ pageTexts -> deleteTextContainer ( $ containerName ) ; $ this -> environment -> sendJSONResult ( 'ok' ) ; }
2496	private function getIndexFieldName ( int $ depth ) : string { if ( $ depth === 0 ) { return self :: $ fieldName ; } return sprintf ( self :: $ relatedContentFieldName , $ depth ) ; }
2592	public static function createRequestCreator ( $ params , $ libIdentifier ) { $ params -> receivedFrom = self :: makeReceivedFrom ( $ params -> receivedFrom , $ libIdentifier ) ; $ theRequestCreator = new Base ( $ params ) ; return $ theRequestCreator ; }
11744	public function register ( $ name , $ tel , $ email , $ industryId , array $ certUrls , $ reason = '' ) { $ params = [ 'name' => $ name , 'phone_number' => strval ( $ tel ) , 'email' => $ email , 'industry_id' => $ industryId , 'qualification_cert_urls' => $ certUrls , ] ; if ( $ reason !== '' ) { $ params [ 'apply_reason' ] = $ reason ; } return $ this -> parseJSON ( 'json' , [ self :: API_ACCOUNT_REGISTER , $ params ] ) ; }
3605	private function isCacheSupport ( JsonRequest $ jsonRequest ) { try { return $ jsonRequest -> getId ( ) && null !== $ this -> getMethod ( $ jsonRequest ) -> getCache ( ) && ! $ this -> isDebug ( ) && $ this -> getCache ( ) ; } catch ( \ Exception $ e ) { return false ; } }
2330	public function next ( ) { if ( ! isset ( $ this -> arrModels [ $ this -> intIndex + 1 ] ) ) { return false ; } ++ $ this -> intIndex ; return $ this ; }
1418	public function failedValidatorException ( ValidatorContract $ validator , \ Closure $ closure = null ) : JsonApiException { return new ValidationException ( $ this -> failedValidator ( $ validator , $ closure ) ) ; }
10589	public function buildPayoutFromId ( $ sPayoutId ) { $ oPayout = new Freeagent \ DataWrapper \ PayoutVO ( ) ; $ oPayout -> setId ( $ sPayoutId ) ; try { $ oDets = $ this -> getTxnChargeDetails ( $ sPayoutId ) ; $ oPayout -> setDateArrival ( strtotime ( $ oDets -> PaymentDate ) ) -> setCurrency ( $ oDets -> GrossAmount -> currencyID ) ; $ oPayout -> addCharge ( $ this -> buildChargeFromTransaction ( $ sPayoutId ) ) ; } catch ( \ Exception $ oE ) { } return $ oPayout ; }
11852	protected function setLayout ( string $ layoutName ) : void { if ( is_null ( $ this -> view ) ) { throw new Exception ( "It's unable to set Layout without View." ) ; } $ this -> layout = ViewFactory :: createLayout ( $ layoutName , $ this -> view ) ; }
10206	public function setReadOrder ( $ pValue ) { if ( $ pValue < 0 || $ pValue > 2 ) { $ pValue = 0 ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'readOrder' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> readOrder = $ pValue ; } return $ this ; }
4173	public function hasMigrationFile ( ) { $ this -> count = $ this -> fileHas ( '/class [A-Z]\w+ extends Migration/i' ) -> getClasses ( ) -> count ( ) ; return $ this -> hasMigrationFile = $ this -> count > 0 ; }
7339	public function sendMessage ( Chat $ chat , User $ recipient , string $ text , Template $ template = null ) : void { $ sendMessage = new SendMessage ( ) ; if ( $ template !== null ) { $ sendMessage -> reply_markup = $ this -> templateCompiler -> compile ( $ template ) ; } $ sendMessage -> chat_id = $ chat -> getId ( ) ; $ sendMessage -> text = $ text ; $ this -> client -> performApiRequest ( $ sendMessage ) ; $ this -> loop -> run ( ) ; }
5496	public function register ( $ method , $ args , $ action ) { $ args = $ this -> replaceWildcards ( $ args ) ; $ method = strtolower ( $ method ) ; if ( ! isset ( $ this -> always [ $ method ] ) ) { $ this -> always [ $ method ] = new SimpleSignatureMap ( ) ; } $ this -> always [ $ method ] -> add ( $ args , $ action ) ; }
11492	public function remove ( string $ key ) { if ( $ this -> contains ( $ key ) ) { $ res = $ _SESSION [ $ key ] ; unset ( $ _SESSION [ $ key ] ) ; return $ res ; } else { return null ; } }
5679	protected function noResponse ( ) { $ this -> transport_error = 'No page fetched yet' ; $ this -> raw = false ; $ this -> sent = false ; $ this -> headers = false ; $ this -> method = 'GET' ; $ this -> url = false ; $ this -> request_data = false ; }
9147	private function open ( ) { $ this -> handle = @ socket_create ( AF_INET , SOCK_STREAM , SOL_TCP ) ; if ( ! is_resource ( $ this -> handle ) ) { $ code = socket_last_error ( ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } }
11842	private function getBind ( ) { [ $ dsBegin , $ treeType ] = $ this -> extractInput ( ) ; $ calcId = $ this -> getCalcId ( $ dsBegin , $ treeType ) ; $ bind = [ QGrid :: BND_CALC_ID => $ calcId ] ; return $ bind ; }
8261	protected function saveAfterLogin ( Request $ httpRequest ) { $ referer = $ httpRequest -> headers -> get ( "referer" , null , true ) ; $ afterLogin = Utils :: getRefererQueryParam ( $ referer , "afterLogin" ) ; if ( $ afterLogin && Utils :: isValidPageId ( $ afterLogin ) ) { $ this -> session -> set ( "afterLogin" , $ afterLogin ) ; } }
5838	public function transform ( $ orig , $ transformation = null , $ overrides = array ( ) ) { $ url = $ this -> factory -> url ( $ orig ) ; if ( is_null ( $ transformation ) && count ( $ overrides ) == 0 ) { return $ url ; } if ( ! isset ( $ this -> transformations [ $ transformation ] ) && count ( $ overrides ) == 0 ) { throw new Exception \ UnknownTransformationException ( "Unknown transformation $transformation. Use on of " . "the following " . implode ( ', ' , array_keys ( $ this -> transformations ) ) ) ; } $ configuration = array ( ) ; if ( isset ( $ this -> transformations [ $ transformation ] ) ) { $ configuration = $ this -> transformations [ $ transformation ] ; } $ configuration = array_merge ( $ configuration , $ overrides ) ; foreach ( $ configuration as $ filter => $ arguments ) { $ method = self :: $ filterMethod [ $ filter ] ; $ this -> $ method ( $ url , $ arguments ) ; } return $ url ; }
8310	public function standardizeUrlFormat ( & $ rules , $ pageUrl ) { if ( ! is_string ( $ pageUrl ) || $ pageUrl === "" || ! is_array ( $ rules ) || ! array_key_exists ( $ pageUrl , $ rules ) ) { return ; } $ oldIndex = $ pageUrl ; if ( $ pageUrl [ 0 ] !== '/' ) { $ pageUrl = '/' . $ pageUrl ; } $ len = strlen ( $ pageUrl ) ; if ( $ len > 1 && $ pageUrl [ $ len - 1 ] === '/' ) { $ pageUrl = rtrim ( $ pageUrl , '/' ) ; } if ( $ oldIndex !== $ pageUrl ) { $ rules [ $ pageUrl ] = $ rules [ $ oldIndex ] ; unset ( $ rules [ $ oldIndex ] ) ; } }
7626	public function containerExists ( $ containerName = '' ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ containers = $ this -> listContainers ( $ containerName , 1 ) ; foreach ( $ containers as $ container ) { if ( $ container -> Name == $ containerName ) { return true ; } } return false ; }
4693	public function orderBy ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> order = $ expression === null ? null : [ $ expression ] ; $ this -> args [ 'order' ] = $ args ; return $ this ; }
12726	public function getContent ( array $ contentData ) { foreach ( $ this -> mandatoryFields as $ mandatoryField ) { if ( ! array_key_exists ( $ mandatoryField , $ contentData ) ) { throw new ContentException ( "The field '$mandatoryField' is missing in the given content data" ) ; } } try { $ title = "" ; if ( isset ( $ contentData [ self :: FIELD_TITLE ] ) ) { $ title = $ contentData [ self :: FIELD_TITLE ] ; } $ summary = "" ; if ( isset ( $ contentData [ self :: FIELD_SUMMARY ] ) ) { $ summary = $ contentData [ self :: FIELD_SUMMARY ] ; } $ description = "" ; if ( isset ( $ contentData [ self :: FIELD_DESCRIPTION ] ) ) { $ description = $ contentData [ self :: FIELD_DESCRIPTION ] ; } $ content = new Content ( $ title , $ summary , $ description ) ; return $ content ; } catch ( \ Exception $ contentException ) { throw new ContentException ( sprintf ( "Failed to create a content model from the given data: %s" , $ contentException -> getMessage ( ) ) , $ contentException ) ; } }
9705	private function calcSheetOffsets ( ) { $ boundsheet_length = 10 ; $ offset = $ this -> _datasize ; $ total_worksheets = count ( $ this -> spreadsheet -> getAllSheets ( ) ) ; foreach ( $ this -> spreadsheet -> getWorksheetIterator ( ) as $ sheet ) { $ offset += $ boundsheet_length + strlen ( StringHelper :: UTF8toBIFF8UnicodeShort ( $ sheet -> getTitle ( ) ) ) ; } for ( $ i = 0 ; $ i < $ total_worksheets ; ++ $ i ) { $ this -> worksheetOffsets [ $ i ] = $ offset ; $ offset += $ this -> worksheetSizes [ $ i ] ; } $ this -> biffSize = $ offset ; }
3441	protected function normalizePropertyFormat ( ) { if ( empty ( $ this -> fields [ 'PROPERTIES' ] ) ) { return ; } foreach ( $ this -> fields [ 'PROPERTIES' ] as $ code => $ prop ) { $ this -> fields [ 'PROPERTY_' . $ code . '_VALUE' ] = $ prop [ 'VALUE' ] ; $ this -> fields [ '~PROPERTY_' . $ code . '_VALUE' ] = $ prop [ '~VALUE' ] ; $ this -> fields [ 'PROPERTY_' . $ code . '_DESCRIPTION' ] = $ prop [ 'DESCRIPTION' ] ; $ this -> fields [ '~PROPERTY_' . $ code . '_DESCRIPTION' ] = $ prop [ '~DESCRIPTION' ] ; $ this -> fields [ 'PROPERTY_' . $ code . '_VALUE_ID' ] = $ prop [ 'PROPERTY_VALUE_ID' ] ; } }
8360	private function startProcessQueue ( ) { $ this -> logger -> info ( 'Starting queue in process mode' ) ; $ dispatcher = new ProcessDispatcher ( $ this -> client , $ this -> logger , $ this -> queue , \ array_merge ( $ this -> queueConfig , [ 'process' => $ this -> config [ 'process' ] ] ) , [ 'configFile' => $ this -> configName ] ) ; $ dispatcher -> start ( ) ; }
2136	protected static function loadParameters ( ) { $ container = System :: getContainer ( ) ; if ( $ container === null ) { return ; } if ( $ container -> hasParameter ( 'contao.localconfig' ) && \ is_array ( $ params = $ container -> getParameter ( 'contao.localconfig' ) ) ) { foreach ( $ params as $ key => $ value ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ key ] = $ value ; } } $ arrMap = array ( 'dbHost' => 'database_host' , 'dbPort' => 'database_port' , 'dbUser' => 'database_user' , 'dbPass' => 'database_password' , 'dbDatabase' => 'database_name' , 'smtpHost' => 'mailer_host' , 'smtpUser' => 'mailer_user' , 'smtpPass' => 'mailer_password' , 'smtpPort' => 'mailer_port' , 'smtpEnc' => 'mailer_encryption' , 'addLanguageToUrl' => 'contao.prepend_locale' , 'encryptionKey' => 'contao.encryption_key' , 'urlSuffix' => 'contao.url_suffix' , 'uploadPath' => 'contao.upload_path' , 'debugMode' => 'kernel.debug' , ) ; foreach ( $ arrMap as $ strKey => $ strParam ) { if ( $ container -> hasParameter ( $ strParam ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ strKey ] = $ container -> getParameter ( $ strParam ) ; } } if ( $ container -> hasParameter ( 'contao.image.valid_extensions' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'validImageTypes' ] = implode ( ',' , $ container -> getParameter ( 'contao.image.valid_extensions' ) ) ; } if ( $ container -> hasParameter ( 'contao.image.imagine_options' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'jpgQuality' ] = $ container -> getParameter ( 'contao.image.imagine_options' ) [ 'jpeg_quality' ] ; } }
282	private function outputList ( $ data ) { foreach ( $ data as $ index => $ item ) { $ this -> stdout ( "\t" . ( $ index + 1 ) . ". {$item}\n" , Console :: FG_GREEN ) ; } }
2945	public function removeRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles ( ) -> detach ( Role :: where ( 'slug' , $ role ) -> first ( ) ) ; } return $ this -> roles ( ) -> detach ( $ role ) ; }
2737	private function setServiceID ( $ serviceId ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_SERVICE_ID , $ serviceId ) ; $ this -> output -> writeln ( '<info>Service ID updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; }
648	public function addCommentOnTable ( $ table , $ comment ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addCommentOnTable ( $ table , $ comment ) ; return $ this -> setSql ( $ sql ) ; }
5884	protected function _normalizeConfig ( $ orders ) { if ( empty ( $ orders ) ) { $ orders = [ [ ] ] ; } elseif ( isset ( $ orders [ 'order' ] ) || isset ( $ orders [ 'callback' ] ) ) { $ orders = [ $ orders ] ; } $ default = [ 'order' => $ this -> _table -> aliasField ( $ this -> _table -> getDisplayField ( ) ) , 'callback' => null , ] ; foreach ( $ orders as $ key => $ value ) { $ orders [ $ key ] = $ orders [ $ key ] + $ default ; } $ this -> _config = [ 'orders' => $ orders , ] ; }
3055	public function getLastCatItemOutput ( ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ itemOutput = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> getCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-item-output' ) ; $ output = [ ] ; if ( ! is_null ( $ itemOutput ) ) { $ rawData = json_decode ( $ itemOutput , true ) ; foreach ( $ rawData as $ result ) { $ itemResult = ItemResult :: restore ( $ result ) ; $ output [ $ itemResult -> getItemRefId ( ) ] = $ itemResult ; } } return $ output ; }
117	protected function getCommand ( $ cmd , $ url , $ path = null ) { $ cmd = sprintf ( '%s %s%s %s' , $ cmd , '--non-interactive ' , $ this -> getCredentialString ( ) , ProcessExecutor :: escape ( $ url ) ) ; if ( $ path ) { $ cmd .= ' ' . ProcessExecutor :: escape ( $ path ) ; } return $ cmd ; }
4831	public function retry ( ) { $ endpoint = self :: $ endpoint . '/' . $ this -> id . '/retry' ; return new self ( $ this -> client , $ this -> client -> request ( 'post' , $ endpoint ) ) ; }
7572	public function post ( Array $ postVars , Array $ headers , $ url = null ) { try { $ this -> guzzleResponse = $ this -> _client -> request ( 'POST' , $ url , array ( 'multipart' => $ postVars , 'headers' => $ headers ) ) ; } catch ( RequestException $ e ) { throw new GreenhouseAPIResponseException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return ( string ) $ this -> guzzleResponse -> getBody ( ) ; }
5531	protected function chainThrowMethods ( ) { $ code = " function throwOn(\$method, \$exception = false, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->throwOn(\$method, \$exception, \$args);\n" ; $ code .= " }\n" ; $ code .= " function throwAt(\$timing, \$method, \$exception = false, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->throwAt(\$timing, \$method, \$exception, \$args);\n" ; $ code .= " }\n" ; $ code .= " function errorOn(\$method, \$error = 'A mock error', \$args = false, \$severity = E_USER_ERROR) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->errorOn(\$method, \$error, \$args, \$severity);\n" ; $ code .= " }\n" ; $ code .= " function errorAt(\$timing, \$method, \$error = 'A mock error', \$args = false, \$severity = E_USER_ERROR) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->errorAt(\$timing, \$method, \$error, \$args, \$severity);\n" ; $ code .= " }\n" ; return $ code ; }
10897	public function setScheme ( $ scheme ) { foreach ( $ this -> uris as $ name => $ uri ) { $ this -> add ( $ name , $ uri -> withScheme ( $ scheme ) ) ; } }
720	public function binary ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BINARY , $ length ) ; }
11880	protected function getRunner ( ) { if ( null === $ this -> runner ) { $ this -> runner = new ConsoleApplication ( $ this -> name , $ this -> version , $ this -> description , $ this -> alias ) ; } return $ this -> runner ; }
11427	public function toObject ( ) { $ groups = $ this -> groups ; foreach ( $ groups as & $ group ) { $ group = $ group -> toObject ( ) ; } $ items = $ this -> items ; foreach ( $ items as & $ item ) { $ item = $ item -> toObject ( ) ; } return ( object ) [ 'type' => $ this -> type , 'value' => $ this -> value , 'text' => $ this -> text , 'groups' => $ groups , 'items' => $ items , ] ; }
7798	public function parse ( $ text ) { $ statements = array ( ) ; foreach ( $ this -> splitStatements ( $ text ) as $ chunk ) { if ( $ statement = $ this -> statement ( $ chunk ) ) { $ statements [ ] = $ statement ; } } return $ statements ; }
8738	protected function filterValues ( array $ values ) { $ attributes = $ this -> model -> translatableAttributes ( ) ; $ translatable = [ ] ; foreach ( $ attributes as $ key ) { if ( array_key_exists ( $ key , $ values ) ) { $ translatable [ $ key ] = $ values [ $ key ] ; unset ( $ values [ $ key ] ) ; } } return [ $ values , $ translatable ] ; }
2317	public function computeResize ( ) { $ resizeCoordinates = System :: getContainer ( ) -> get ( 'contao.image.resize_calculator' ) -> calculate ( $ this -> prepareResizeConfig ( ) , new ImageDimensions ( new Box ( $ this -> fileObj -> viewWidth , $ this -> fileObj -> viewHeight ) , $ this -> fileObj -> viewWidth !== $ this -> fileObj -> width ) , $ this -> prepareImportantPart ( ) ) ; return array ( 'width' => $ resizeCoordinates -> getCropSize ( ) -> getWidth ( ) , 'height' => $ resizeCoordinates -> getCropSize ( ) -> getHeight ( ) , 'target_x' => - $ resizeCoordinates -> getCropStart ( ) -> getX ( ) , 'target_y' => - $ resizeCoordinates -> getCropStart ( ) -> getY ( ) , 'target_width' => $ resizeCoordinates -> getSize ( ) -> getWidth ( ) , 'target_height' => $ resizeCoordinates -> getSize ( ) -> getHeight ( ) , ) ; }
10366	public function logout ( ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'logout' ) ) -> dispatchNow ( new LogoutJob ) ; return redirect ( ) -> route ( config ( '_auth.logout.redirect' ) ) ; }
8198	public function next ( ) { if ( ! isset ( $ this -> tokens [ ++ $ this -> current ] ) ) { throw new Twig_Error_Syntax ( 'Unexpected end of template.' , $ this -> tokens [ $ this -> current - 1 ] -> getLine ( ) , $ this -> source ) ; } return $ this -> tokens [ $ this -> current - 1 ] ; }
664	public function useMaster ( callable $ callback ) { if ( $ this -> enableSlaves ) { $ this -> enableSlaves = false ; try { $ result = call_user_func ( $ callback , $ this ) ; } catch ( \ Exception $ e ) { $ this -> enableSlaves = true ; throw $ e ; } catch ( \ Throwable $ e ) { $ this -> enableSlaves = true ; throw $ e ; } $ this -> enableSlaves = true ; } else { $ result = call_user_func ( $ callback , $ this ) ; } return $ result ; }
11848	private function checkReadOnly ( ) { if ( true === $ this -> _readOnly ) { $ this -> _pushError ( '' , self :: ERR_READ_ONLY , 'This row has been marked read-only' ) ; return false ; } return true ; }
420	public function run ( ) { $ block = ob_get_clean ( ) ; if ( $ this -> renderInPlace ) { echo $ block ; } $ this -> view -> blocks [ $ this -> getId ( ) ] = $ block ; }
11029	protected function geolocation ( ) { $ this -> parts [ '{geolocation}' ] = $ this -> form -> field ( $ this -> model , 'latitude' ) -> textInput ( [ 'name' => $ this -> getSubmitModelName ( 'latitude' ) , 'id' => $ this -> fieldIds [ 'latitude' ] ] ) . "\n" . $ this -> form -> field ( $ this -> model , 'longitude' ) -> textInput ( [ 'name' => $ this -> getSubmitModelName ( 'longitude' ) , 'id' => $ this -> fieldIds [ 'longitude' ] ] ) ; }
11876	public static function getDump ( $ var , $ maxSize = null ) { $ trace = debug_backtrace ( ) ; $ dump = '' ; $ dump .= static :: getHeader ( 'Dump de variable' ) ; $ dump .= '<div class="dump_segment">Contexte</div>' ; if ( count ( $ trace ) > 2 ) { $ dump .= static :: getContext ( $ trace [ 1 ] , $ trace [ 2 ] ) ; } else { $ dump .= static :: getContext ( $ trace [ 1 ] ) ; } if ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\common\sgbd\Query' ) { $ dump .= '<div class="dump_segment">Requête SQL</div>'; $ dump .= '<div class="dump_segment_content"><pre>' . $ var -> getSql ( ) . '</pre></div>' ; } $ dump .= '<div class="dump_segment">Exploration de la variable</div>' ; $ dump .= '<div class="dump_segment_content"><pre>' ; if ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\framework\query\Query' ) { $ dump .= static :: getDumpQueryResult ( $ var -> getQueryResults ( ) ) ; } elseif ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\framework\query\QueryResult' ) { $ dump .= static :: getDumpQueryResult ( $ var ) ; } else { $ dump .= static :: getDumpContent ( $ var , $ maxSize ) ; } $ dump .= '</pre></div>' ; $ dump .= static :: getFooter ( ) ; return $ dump ; }
2316	protected function prepareResizeConfig ( ) { $ resizeConfig = new ResizeConfiguration ( ) ; $ resizeConfig -> setWidth ( $ this -> targetWidth ) ; $ resizeConfig -> setHeight ( $ this -> targetHeight ) ; $ resizeConfig -> setZoomLevel ( $ this -> zoomLevel ) ; if ( substr_count ( $ this -> resizeMode , '_' ) === 1 ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; $ resizeConfig -> setZoomLevel ( 0 ) ; } else { try { $ resizeConfig -> setMode ( $ this -> resizeMode ) ; } catch ( \ InvalidArgumentException $ exception ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; } } return $ resizeConfig ; }
8540	public function setmember ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'member' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5517	public function errorAt ( $ timing , $ method , $ error = 'A mock error' , $ args = false , $ severity = E_USER_ERROR ) { $ this -> dieOnNoMethod ( $ method , 'error at' ) ; $ this -> actions -> registerAt ( $ timing , $ method , $ args , new SimpleErrorThrower ( $ error , $ severity ) ) ; }
4959	public function detach ( EventManagerInterface $ events ) { foreach ( $ this -> listeners as $ index => $ listener ) { if ( $ events -> detach ( $ listener ) ) { unset ( $ this -> listeners [ $ index ] ) ; } } $ sharedEvents = $ events -> getSharedManager ( ) ; foreach ( $ this -> sharedListeners as $ index => $ listener ) { if ( $ sharedEvents -> detach ( $ listener ) ) { unset ( $ this -> sharedListeners [ $ index ] ) ; } } }
3025	public function postRequest ( $ path , $ options , $ addApiKey ) { if ( isset ( $ options [ 'source' ] ) && is_array ( $ options [ 'source' ] ) ) { $ sources = $ options [ 'source' ] ; unset ( $ options [ 'source' ] ) ; foreach ( $ sources as $ i => $ source ) { $ options [ "source[$i]" ] = $ source ; } } $ response = $ this -> makeRequest ( 'POST' , $ path , $ options , $ addApiKey ) ; return $ this -> parseResponse ( $ response ) ; }
12086	public function save ( ) { $ this -> checkPermission ( "special" , "/admin" ) ; $ referer = $ this -> application -> input -> getReferer ( ) ; if ( ! $ this -> application -> input -> methodIs ( "post" ) ) { $ this -> response -> addAlert ( "No configuration data recieved" , 'error' ) ; } else { if ( ( $ data = $ this -> application -> input -> getArray ( "options" , array ( ) , "post" ) ) == FALSE ) { $ this -> response -> addAlert ( "No input data recieved, Something went wrong" , 'error' ) ; } else { $ namespace = $ this -> application -> input -> getString ( "options_namespace" , "" , "post" ) ; $ this -> application -> config -> mergeParams ( $ namespace , $ data ) ; if ( ! $ this -> application -> config -> saveParams ( ) ) { $ this -> response -> addAlert ( 'Something went wrong, Did not save the parameters' , 'error' ) ; } else { $ this -> response -> addAlert ( "Your configuration settings have now been saved" , "success" ) ; } } } $ this -> application -> dispatcher -> redirect ( $ referer , HTTP_FOUND , null , $ this -> response -> getAlerts ( ) ) ; return true ; }
12540	public static function camelize ( $ str , $ ucfirst = false ) { $ replace = str_replace ( ' ' , '' , ucwords ( str_replace ( [ '_' , '-' ] , ' ' , strtolower ( $ str ) ) ) ) ; if ( ! $ ucfirst ) { return lcfirst ( $ replace ) ; } return $ replace ; }
7173	protected function resolveCustomerTargetCountry ( CustomerInterface $ customer ) : ? CountryInterface { if ( null !== $ address = $ customer -> getDefaultDeliveryAddress ( ) ) { return $ address -> getCountry ( ) ; } return null ; }
7847	public function info ( int $ id ) : ? array { $ this -> checkConfig ( ) ; $ key = sprintf ( 'smsgatewayme.info.%s' , $ id ) ; if ( $ this -> cache === true and Cache :: has ( $ key ) ) { $ message = [ 'code' => 200 , 'message' => 'OK' , 'data' => Cache :: get ( $ key ) , ] ; } else { $ response = Request :: get ( $ this -> baseUrl . 'message/' . $ id ) ; if ( $ response -> code == 200 ) { Cache :: put ( $ key , $ response -> body , 3600 * 24 ) ; } else { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } $ message = [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; } return $ message ; }
423	public function hiddenInput ( $ options = [ ] ) { $ options = array_merge ( $ this -> inputOptions , $ options ) ; $ this -> adjustLabelFor ( $ options ) ; $ this -> parts [ '{input}' ] = Html :: activeHiddenInput ( $ this -> model , $ this -> attribute , $ options ) ; return $ this ; }
8731	public function whitelist ( string $ address ) : WhitelistResponse { try { $ response = $ this -> callHydroApi ( 'post' , 'whitelist' , [ 'timeout' => 60 , 'json' => [ 'address' => $ address ] ] ) ; $ data = \ GuzzleHttp \ json_decode ( $ response -> getBody ( ) -> getContents ( ) , true ) ; } catch ( RuntimeException $ e ) { throw AddressWhitelistingFailed :: forAddress ( $ address , $ e -> getMessage ( ) ) ; } catch ( InvalidArgumentException $ e ) { throw AddressWhitelistingFailed :: forAddress ( $ address , $ e -> getMessage ( ) ) ; } catch ( GuzzleException $ e ) { throw AddressWhitelistingFailed :: forAddress ( $ address , $ e -> getMessage ( ) ) ; } catch ( ApiRequestFailed $ e ) { throw AddressWhitelistingFailed :: forAddress ( $ address , $ e -> getMessage ( ) ) ; } return new WhitelistResponse ( $ data [ 'hydro_address_id' ] , $ data [ 'transaction_hash' ] ) ; }
10554	public static function handleUnknownHost ( URL $ webroot , URL $ request , array $ sites , Dictionary $ cfg ) { $ on_unknown = strtoupper ( $ cfg -> dget ( 'unknown_host_policy' , "IGNORE" ) ) ; $ best_matching = self :: findBestMatching ( $ webroot , $ sites ) ; if ( $ on_unknown === "ERROR" || ( $ best_matching === null && $ on_unknown === "REDIRECT" ) ) return null ; if ( $ on_unknown === "REDIRECT" ) { $ redir = $ best_matching -> URL ( $ request -> path ) ; return $ redir ; } $ url = new URL ( $ webroot ) ; $ url -> fragment = null ; $ url -> query = null ; $ lang = $ cfg -> dget ( 'default_language' , 'en' ) ; $ vhost = new VirtualHost ( $ url , $ lang ) ; if ( $ best_matching === null ) { $ site = new Site ( ) ; $ site -> addVirtualHost ( $ vhost ) ; } else $ best_matching -> getSite ( ) -> addVirtualHost ( $ vhost ) ; return $ vhost ; }
10575	public static function apply ( $ text , $ foreground = '' , $ background = '' ) { try { $ style = new OutputFormatterStyle ( ) ; if ( $ foreground != '' ) { $ style -> setForeground ( $ foreground ) ; } if ( $ background != '' ) { $ style -> setBackground ( $ background ) ; } return $ style -> apply ( $ text ) ; } catch ( \ Exception $ e ) { return $ text ; } }
1011	private function readNumber ( $ line , $ col , Token $ prev ) { $ value = '' ; $ start = $ this -> position ; [ $ char , $ code ] = $ this -> readChar ( ) ; $ isFloat = false ; if ( $ code === 45 ) { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; } if ( $ code === 48 ) { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; if ( $ code >= 48 && $ code <= 57 ) { throw new SyntaxError ( $ this -> source , $ this -> position , 'Invalid number, unexpected digit after 0: ' . Utils :: printCharCode ( $ code ) ) ; } } else { $ value .= $ this -> readDigits ( ) ; [ $ char , $ code ] = $ this -> readChar ( ) ; } if ( $ code === 46 ) { $ isFloat = true ; $ this -> moveStringCursor ( 1 , 1 ) ; $ value .= $ char ; $ value .= $ this -> readDigits ( ) ; [ $ char , $ code ] = $ this -> readChar ( ) ; } if ( $ code === 69 || $ code === 101 ) { $ isFloat = true ; $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; if ( $ code === 43 || $ code === 45 ) { $ value .= $ char ; $ this -> moveStringCursor ( 1 , 1 ) ; } $ value .= $ this -> readDigits ( ) ; } return new Token ( $ isFloat ? Token :: FLOAT : Token :: INT , $ start , $ this -> position , $ line , $ col , $ prev , $ value ) ; }
10323	private function createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source , $ embedFieldBackups ) { $ queryParameters = array ( 'page_index' => $ pageIndex , 'page_size' => $ pageSize ) ; if ( isset ( $ fromDate ) ) $ queryParameters [ 'from_date' ] = $ fromDate ; if ( isset ( $ toDate ) ) $ queryParameters [ 'to_date' ] = $ toDate ; if ( isset ( $ source ) ) $ queryParameters [ 'source' ] = $ source ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "ids" , $ contactIds ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "emails" , $ contactEmails ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "eids" , $ contactExternalIds ) ; if ( isset ( $ embedFieldBackups ) ) $ queryParameters [ 'embed_field_backups' ] = ( $ embedFieldBackups == true ) ? "true" : "false" ; if ( isset ( $ mailingIds ) ) { $ queryParameters [ 'mailing_id' ] = array ( ) ; foreach ( $ mailingIds as $ mailingId ) { $ queryParameters [ 'mailing_id' ] [ ] = $ mailingId ; } } return $ queryParameters ; }
1526	protected function doUpdate ( StoreInterface $ store , UpdateResource $ request ) { if ( $ response = $ this -> beforeCommit ( $ request ) ) { return $ response ; } $ record = $ store -> updateRecord ( $ request -> getRecord ( ) , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> afterCommit ( $ request , $ record , true ) ? : $ record ; }
2256	public static function setStaticUrls ( ) { if ( \ defined ( 'TL_FILES_URL' ) ) { return ; } if ( \ func_num_args ( ) > 0 ) { @ trigger_error ( 'Using Controller::setStaticUrls() has been deprecated and will no longer work in Contao 5.0. Use the asset contexts instead.' , E_USER_DEPRECATED ) ; if ( ! isset ( $ GLOBALS [ 'objPage' ] ) ) { $ GLOBALS [ 'objPage' ] = func_get_arg ( 0 ) ; } } \ define ( 'TL_ASSETS_URL' , System :: getContainer ( ) -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) ) ; \ define ( 'TL_FILES_URL' , System :: getContainer ( ) -> get ( 'contao.assets.files_context' ) -> getStaticUrl ( ) ) ; \ define ( 'TL_SCRIPT_URL' , TL_ASSETS_URL ) ; \ define ( 'TL_PLUGINS_URL' , TL_ASSETS_URL ) ; }
3062	public function canMoveBackward ( ) { $ moveBack = false ; $ session = $ this -> getTestSession ( ) ; if ( $ this -> isAdaptive ( ) ) { $ positionInCatSession = array_search ( $ this -> getCurrentCatItemId ( ) , $ this -> getShadowTest ( ) ) ; if ( $ positionInCatSession === 0 ) { if ( $ session -> getRoute ( ) -> getPosition ( ) !== 0 ) { $ moveBack = $ session -> getPreviousRouteItem ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> getRoute ( ) -> current ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> canMoveBackward ( ) ; if ( $ moveBack ) { $ moveBack = $ this -> getServiceManager ( ) -> get ( SectionPauseService :: SERVICE_ID ) -> canMoveBackward ( $ session ) ; } } return $ moveBack ; }
12330	public function get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug = null ) { $ source_file = $ filename ; if ( defined ( 'SCRIPT_DEBUG' ) && true === SCRIPT_DEBUG && ! empty ( $ filename_debug ) ) { $ source_file = $ filename_debug ; } $ path = realpath ( trailingslashit ( $ relative_path ) . $ source_file ) ; return WP_Url_Util :: get_instance ( ) -> convert_absolute_path_to_url ( $ path ) ; }
10942	private function reset ( ) { $ time = new \ DateTime ( ) ; $ this -> driver -> set ( self :: LAST_UPDATE_KEY , $ time ) ; return $ time ; }
1064	private function collectConflictsWithin ( ValidationContext $ context , array & $ conflicts , array $ fieldMap ) { foreach ( $ fieldMap as $ responseName => $ fields ) { $ fieldsLength = count ( $ fields ) ; if ( $ fieldsLength <= 1 ) { continue ; } for ( $ i = 0 ; $ i < $ fieldsLength ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ fieldsLength ; $ j ++ ) { $ conflict = $ this -> findConflict ( $ context , false , $ responseName , $ fields [ $ i ] , $ fields [ $ j ] ) ; if ( ! $ conflict ) { continue ; } $ conflicts [ ] = $ conflict ; } } } }
1028	private function resolveField ( ObjectType $ parentType , $ source , $ fieldNodes , $ path ) { $ exeContext = $ this -> exeContext ; $ fieldNode = $ fieldNodes [ 0 ] ; $ fieldName = $ fieldNode -> name -> value ; $ fieldDef = $ this -> getFieldDef ( $ exeContext -> schema , $ parentType , $ fieldName ) ; if ( ! $ fieldDef ) { return self :: $ UNDEFINED ; } $ returnType = $ fieldDef -> getType ( ) ; $ info = new ResolveInfo ( $ fieldName , $ fieldNodes , $ returnType , $ parentType , $ path , $ exeContext -> schema , $ exeContext -> fragments , $ exeContext -> rootValue , $ exeContext -> operation , $ exeContext -> variableValues ) ; if ( $ fieldDef -> resolveFn !== null ) { $ resolveFn = $ fieldDef -> resolveFn ; } elseif ( $ parentType -> resolveFieldFn !== null ) { $ resolveFn = $ parentType -> resolveFieldFn ; } else { $ resolveFn = $ this -> exeContext -> fieldResolver ; } $ context = $ exeContext -> contextValue ; $ result = $ this -> resolveOrError ( $ fieldDef , $ fieldNode , $ resolveFn , $ source , $ context , $ info ) ; $ result = $ this -> completeValueCatchingError ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; return $ result ; }
12892	public function render ( ElementInterface $ element ) { $ renderer = $ this -> getView ( ) ; if ( ! method_exists ( $ renderer , 'plugin' ) ) { return '' ; } $ wrapperClass = '' ; $ elementMarkup = '' ; $ templateMarkup = '' ; $ attributesString = '' ; $ label = '' ; if ( $ element instanceof CollectionElement && $ element -> shouldCreateTemplate ( ) ) { $ templateMarkup = $ this -> renderTemplate ( $ element ) ; } foreach ( $ element -> getIterator ( ) as $ elementOrFieldset ) { $ elementMarkup .= $ this -> renderElement ( $ elementOrFieldset ) ; } $ helperFormButtonIcon = $ this -> getFormButtonIconHelper ( ) ; $ helperLabel = $ this -> getLabelHelper ( ) ; $ elementMarkup .= sprintf ( $ this -> elementWrap , '' , $ helperFormButtonIcon ( new Button ( null , [ 'label' => 'Add New' , 'icon' => 'fa fa-plus-circle' ] ) ) , '' ) ; if ( $ this -> shouldWrap ) { $ attributes = $ element -> getAttributes ( ) ; if ( isset ( $ attributes [ 'class' ] ) ) { $ wrapperClass = $ attributes [ 'class' ] ; unset ( $ attributes [ 'class' ] ) ; } unset ( $ attributes [ 'name' ] ) ; $ attributesString = count ( $ attributes ) ? ' ' . $ this -> createAttributesString ( $ attributes ) : '' ; if ( ! empty ( $ element -> getLabel ( ) ) ) { $ label = $ helperLabel ( $ element ) ; } } return sprintf ( $ this -> wrapper , $ wrapperClass , $ attributesString , $ label , $ this -> horizontalWrapClass , $ elementMarkup , $ templateMarkup ) ; }
10840	protected function getRaw ( $ Key ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; if ( ! file_exists ( $ CacheFile ) ) { return false ; } return unserialize ( file_get_contents ( $ CacheFile ) ) ; }
592	public function combineJsFiles ( $ inputFiles , $ outputFile ) { $ content = '' ; foreach ( $ inputFiles as $ file ) { $ fileContent = rtrim ( file_get_contents ( $ file ) ) ; if ( substr ( $ fileContent , - 1 ) !== ';' ) { $ fileContent .= "\n;" ; } $ content .= "/*** BEGIN FILE: $file ***/\n" . $ fileContent . "\n" . "/*** END FILE: $file ***/\n" ; } if ( ! file_put_contents ( $ outputFile , $ content ) ) { throw new Exception ( "Unable to write output JavaScript file '{$outputFile}'." ) ; } }
2472	public function findSingle ( Criterion $ filter , array $ languageFilter = array ( ) ) { $ query = new Query ( ) ; $ query -> filter = $ filter ; $ query -> query = new Criterion \ MatchAll ( ) ; $ query -> offset = 0 ; $ query -> limit = 1 ; $ this -> coreFilter -> apply ( $ query , $ languageFilter , DocumentMapper :: DOCUMENT_TYPE_IDENTIFIER_CONTENT ) ; $ result = $ this -> resultExtractor -> extract ( $ this -> gateway -> findContent ( $ query , $ languageFilter ) ) ; if ( ! $ result -> totalCount ) { throw new NotFoundException ( 'Content' , 'findSingle() found no content for given $filter' ) ; } elseif ( $ result -> totalCount > 1 ) { throw new InvalidArgumentException ( 'totalCount' , 'findSingle() found more then one item for given $filter' ) ; } $ first = reset ( $ result -> searchHits ) ; return $ first -> valueObject ; }
10148	private function readMsoDrawingGroup ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ recordData = $ splicedRecordData [ 'recordData' ] ; $ this -> drawingGroupData .= $ recordData ; }
10310	function getUniqueOpensCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeAnonymousOpens = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousOpens ) ) $ params [ 'exclude_anonymous_opens' ] = ( $ excludeAnonymousOpens == true ) ? "true" : "false" ; return $ this -> get ( 'reports/opens/unique/count' , $ params ) ; }
1580	public function withId ( ? string $ id ) : self { $ copy = clone $ this ; $ copy -> id = $ id ? : null ; $ copy -> normalize ( ) ; return $ copy ; }
4711	public function wrap ( $ start , $ end ) { $ this -> text = $ start . $ this -> text . $ end ; return $ this ; }
8048	public function receive ( ) { $ hdr = '' ; do { $ read = socket_read ( $ this -> socket , 4 - strlen ( $ hdr ) ) ; if ( $ read === FALSE ) { throw new SimpleSocketException ( 'Reception failed with: ' . socket_strerror ( socket_last_error ( $ this -> socket ) ) ) ; } elseif ( $ read === '' || $ read === NULL ) { return NULL ; } $ hdr .= $ read ; } while ( strlen ( $ hdr ) < 4 ) ; list ( $ len ) = array_values ( unpack ( "N" , $ hdr ) ) ; $ buffer = '' ; do { $ read = socket_read ( $ this -> socket , $ len - strlen ( $ buffer ) ) ; if ( $ read === FALSE || $ read == '' ) { throw new SimpleSocketException ( 'Reception failed with: ' . socket_strerror ( socket_last_error ( $ this -> socket ) ) ) ; } elseif ( $ read == '' ) { return NULL ; } $ buffer .= $ read ; } while ( strlen ( $ buffer ) < $ len ) ; $ data = unserialize ( $ buffer ) ; return $ data ; }
1220	private function validateSeq ( $ from , array $ types , $ a , $ b ) { $ ta = Utils :: type ( $ a ) ; $ tb = Utils :: type ( $ b ) ; if ( $ ta !== $ tb ) { $ msg = "encountered a type mismatch in sequence: {$ta}, {$tb}" ; $ this -> typeError ( $ from , $ msg ) ; } $ typeMatch = ( $ types && $ types [ 0 ] == 'any' ) || in_array ( $ ta , $ types ) ; if ( ! $ typeMatch ) { $ msg = 'encountered a type error in sequence. The argument must be ' . 'an array of ' . implode ( '|' , $ types ) . ' types. ' . "Found {$ta}, {$tb}." ; $ this -> typeError ( $ from , $ msg ) ; } }
5684	public function getUrlById ( $ id ) { foreach ( $ this -> links as $ link ) { if ( $ link -> getAttribute ( 'id' ) === ( string ) $ id ) { return $ this -> getUrlFromLink ( $ link ) ; } } return false ; }
1176	public function sometimes ( $ attribute , $ rules = [ ] ) { $ callback = function ( ) { return true ; } ; $ this -> validator -> sometimes ( $ attribute , $ rules , $ callback ) ; $ this -> rules -> addConditionalRules ( $ attribute , ( array ) $ rules ) ; }
2139	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) ) { return ; } $ this -> fetchHttpHeaders ( ) ; $ this -> setResponseHeaders ( $ event -> getResponse ( ) ) ; }
1251	private function startElement ( $ parser , $ name , array $ attributes ) { $ this -> metaStack -> push ( $ this -> getPhpMeta ( $ this -> normalizeElementName ( $ name ) , $ attributes ) ) ; }
12794	public function delete ( $ id ) { try { $ response = $ this -> client -> request -> delete ( $ this -> apiEndpoint . "/droplets/$id" ) ; $ status = $ this -> client -> getStatus ( $ response ) ; if ( 204 != $ status ) { throw new Exception ( 'Digital Ocean responded that it could not delete it.' ) ; } return $ status ; } catch ( Exception $ e ) { echo 'Unable to delete server because ' . $ e -> getMessage ( ) ; } }
6768	protected function handleContentChange ( SaleInterface $ sale ) { $ changed = $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; if ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed = $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } $ changed |= $ this -> saleUpdater -> updateTotals ( $ sale ) ; $ changed |= $ this -> updateState ( $ sale ) ; $ changed |= $ this -> saleUpdater -> updateOutstandingDate ( $ sale ) ; return $ changed ; }
12384	public static function perDay ( $ days = 1 , $ date_format = "m-d" ) { $ hits_per_day = [ ] ; for ( $ i = 1 ; $ i <= $ days ; $ i ++ ) { $ hits_count = self :: interval ( Carbon :: now ( ) -> subDays ( $ i ) , Carbon :: now ( ) -> subDays ( $ i - 1 ) ) ; $ hits_per_day [ Carbon :: now ( ) -> subDays ( $ i ) -> format ( $ date_format ) ] = $ hits_count ; } return $ hits_per_day ; }
7700	function MsWord_InitHeaderFooter ( ) { if ( $ this -> MsWord_HeaderFooter !== false ) return ; $ types_ok = array ( 'default' => true , 'first' => false , 'even' => false ) ; $ idx = $ this -> FileGetIdx ( 'word/settings.xml' ) ; if ( $ idx !== false ) { $ Txt = $ this -> TbsStoreGet ( $ idx , 'GetHeaderFooterFile' ) ; $ types_ok [ 'even' ] = ( strpos ( $ Txt , '<w:evenAndOddHeaders/>' ) !== false ) ; unset ( $ Txt ) ; } $ idx = $ this -> FileGetIdx ( 'word/document.xml' ) ; if ( $ idx === false ) return false ; $ Txt = $ this -> TbsStoreGet ( $ idx , 'GetHeaderFooterFile' ) ; $ types_ok [ 'first' ] = ( strpos ( $ Txt , '<w:titlePg/>' ) !== false ) ; $ places = array ( 'header' , 'footer' ) ; $ files = array ( ) ; $ rels = $ this -> OpenXML_Rels_GetObj ( 'word/document.xml' , '' ) ; foreach ( $ places as $ place ) { $ p = 0 ; $ entity = 'w:' . $ place . 'Reference' ; while ( $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , $ entity , $ p ) ) { $ p = $ loc -> PosEnd ; $ type = $ loc -> GetAttLazy ( 'w:type' ) ; if ( isset ( $ types_ok [ $ type ] ) && $ types_ok [ $ type ] ) { $ rid = $ loc -> GetAttLazy ( 'r:id' ) ; if ( isset ( $ rels -> TargetLst [ $ rid ] ) ) { $ target = $ rels -> TargetLst [ $ rid ] ; $ files [ ] = array ( 'file' => ( 'word/' . $ target ) , 'type' => $ type , 'place' => $ place ) ; } } } } $ this -> MsWord_HeaderFooter = $ files ; }
10984	public static function getHostId ( ) { if ( self :: isWindows ( ) ) { $ uuid = explode ( "\r\n" , trim ( shell_exec ( 'wmic csproduct get UUID' ) ) ) ; return ( \ count ( $ uuid ) === 2 ? $ uuid [ 1 ] : false ) ; } $ uuid = trim ( shell_exec ( 'hostid' ) ) ; return $ uuid === null ? false : $ uuid ; }
3356	public function getPath ( $ postfix = null ) { $ url = sprintf ( '/%s/' , $ this -> uuid ) ; if ( $ this -> default_effects ) { $ url = sprintf ( '%s-/%s' , $ url , $ this -> default_effects ) ; } if ( $ this -> filename && $ postfix === null ) { $ postfix = $ this -> filename ; } $ operations = array ( ) ; foreach ( $ this -> operations as $ i => $ operation_item ) { $ part = array ( ) ; foreach ( array_keys ( $ operation_item ) as $ operation_type ) { $ operation_params = $ operation_item [ $ operation_type ] ; $ part [ ] = $ operation_type ; switch ( $ operation_type ) { case 'crop' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; $ part = $ this -> __addPartCenter ( $ part , $ operation_params ) ; $ part = $ this -> __addPartFillColor ( $ part , $ operation_params ) ; break ; case 'resize' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; break ; case 'scale_crop' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; $ part = $ this -> __addPartCenter ( $ part , $ operation_params ) ; break ; case 'effect' : $ part = $ this -> __addPartEffect ( $ part , $ operation_params ) ; break ; case 'preview' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; break ; case 'custom' : $ part = array ( $ operation_params ) ; break ; } $ part_str = join ( '/' , $ part ) ; $ operations [ ] = $ part_str ; } } if ( count ( $ operations ) ) { $ operations_part = join ( '/-/' , $ operations ) ; return $ url . '-/' . $ operations_part . '/' . $ postfix ; } else { return $ url . $ postfix ; } }
143	private static function fixHttpHeaderField ( $ header ) { if ( ! is_array ( $ header ) ) { $ header = explode ( "\r\n" , $ header ) ; } uasort ( $ header , function ( $ el ) { return stripos ( $ el , 'content-type' ) === 0 ? 1 : - 1 ; } ) ; return $ header ; }
4684	public function setValueNormalization ( bool $ enabled = false ) { if ( $ enabled === true ) { $ this -> initColumnConversions ( ) ; } else { $ this -> toIntColumns = [ ] ; $ this -> toFloatColumns = [ ] ; $ this -> toStringColumns = [ ] ; $ this -> toBoolColumns = [ ] ; $ this -> toDateTimeColumns = [ ] ; $ this -> toDriverColumns = [ ] ; } }
7884	public function getShow ( $ date , $ level = null ) { $ logs = LogViewer :: logs ( ) ; if ( ! is_string ( $ level ) ) { $ level = 'all' ; } $ page = Input :: get ( 'page' ) ; if ( empty ( $ page ) ) { $ page = '1' ; } $ data = [ 'logs' => $ logs , 'date' => $ date , 'url' => 'logviewer' , 'data_url' => URL :: route ( 'logviewer.index' ) . '/data/' . $ date . '/' . $ level . '?page=' . $ page , 'levels' => LogViewer :: levels ( ) , 'current' => $ level , ] ; return View :: make ( 'logviewer::show' , $ data ) ; }
1997	public function dump ( ) : void { if ( empty ( $ this -> parameters [ 'parameters' ] [ 'secret' ] ) || 'ThisTokenIsNotSoSecretChangeIt' === $ this -> parameters [ 'parameters' ] [ 'secret' ] ) { $ this -> parameters [ 'parameters' ] [ 'secret' ] = bin2hex ( random_bytes ( 32 ) ) ; } if ( isset ( $ this -> parameters [ 'parameters' ] [ 'database_port' ] ) ) { $ this -> parameters [ 'parameters' ] [ 'database_port' ] = ( int ) $ this -> parameters [ 'parameters' ] [ 'database_port' ] ; } $ this -> filesystem -> dumpFile ( $ this -> rootDir . '/app/config/parameters.yml' , "# This file has been auto-generated during installation\n" . Yaml :: dump ( $ this -> getEscapedValues ( ) ) ) ; }
5395	public function paintException ( $ exception ) { parent :: paintException ( $ exception ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'exception>' ; $ message = 'Unexpected exception of type [' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "exception>\n" ; }
6976	protected function scheduleSaleContentChangeEvent ( Model \ AdjustmentInterface $ adjustment ) { if ( $ adjustment instanceof Model \ SaleAdjustmentInterface ) { if ( null === $ sale = $ this -> getSaleFromAdjustment ( $ adjustment ) ) { return ; } } elseif ( $ adjustment instanceof Model \ SaleItemAdjustmentInterface ) { if ( null === $ item = $ this -> getItemFromAdjustment ( $ adjustment ) ) { return ; } if ( null === $ sale = $ this -> getSaleFromItem ( $ item ) ) { return ; } } else { throw new InvalidArgumentException ( "Unexpected adjustment type." ) ; } $ this -> persistenceHelper -> scheduleEvent ( $ this -> getSaleChangeEvent ( ) , $ sale ) ; }
7634	public function putBlockList ( $ containerName = '' , $ blobName = '' , $ blockList = array ( ) , $ metadata = array ( ) , $ leaseId = null , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; Assertion :: notEmpty ( $ blockList , 'Block list does not contain any elements.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; $ blocks = '' ; foreach ( $ blockList as $ block ) { $ blocks .= ' <Latest>' . base64_encode ( $ block ) . '</Latest>' . "\n" ; } $ fileContents = utf8_encode ( implode ( "\n" , array ( '<?xml version="1.0" encoding="utf-8"?>' , '<BlockList>' , $ blocks , '</BlockList>' ) ) ) ; $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ headers = array_merge ( $ headers , $ this -> generateMetadataHeaders ( $ metadata ) ) ; foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , array ( 'comp' => 'blocklist' ) , 'PUT' , $ headers , false , $ fileContents , self :: RESOURCE_BLOB , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
3481	private static function includeConfigurationFile ( ) { static $ included = false ; if ( $ included ) { return ; } $ file = __DIR__ . '/config.php' ; if ( ! file_exists ( $ file ) ) { print sprintf ( 'The configuration file "%s" was not found.%sPlease copy %s/config.php.dist to %s/config.php and modify new file for set own parameters.%s' , $ file , PHP_EOL , __DIR__ , __DIR__ , PHP_EOL ) ; exit ( 1 ) ; } $ included = true ; include_once $ file ; }
7815	public static function uploadImgFile ( $ path ) { try { if ( Request :: hasFile ( 'image' ) ) { $ pic = Request :: file ( 'image' ) ; if ( $ pic -> isValid ( ) ) { $ newName = md5 ( rand ( 1 , 1000 ) . $ pic -> getClientOriginalName ( ) ) . "." . $ pic -> getClientOriginalExtension ( ) ; $ pic -> move ( $ path , $ newName ) ; $ url = asset ( $ path . '/' . $ newName ) ; } else { self :: addError ( 'The file is invalid' ) ; } } else { self :: addError ( 'Not File' ) ; } } catch ( \ Exception $ e ) { self :: addError ( $ e -> getMessage ( ) ) ; } $ data = array ( 'status' => empty ( $ message ) ? 0 : 1 , 'message' => self :: getLastError ( ) , 'url' => ! empty ( $ url ) ? $ url : '' ) ; return $ data ; }
9328	protected function registerMarkdownPhpEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.php.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownPhpCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown.php' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.php.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md.php' , 'markdown.php' ) ; }
8619	public function getBlockWithKey ( $ key ) { if ( isset ( $ this -> blocks [ $ key ] ) ) return $ this -> blocks [ $ key ] ; return null ; }
9611	public function getAssetUrl ( $ path , $ relative = false ) { if ( substr ( $ path , 0 , 1 ) !== '/' ) { $ path = '/' . $ path ; } if ( $ this -> assetRoot !== null ) { $ base = $ this -> assetRoot ; } else if ( $ relative ) { $ base = $ this -> requests -> getCurrentRequest ( ) -> getBaseUrl ( ) ; } else { $ base = $ this -> getRootUrl ( ) ; } return $ base . $ path ; }
854	public function findSequence ( array $ sequence , $ start = 0 , $ end = null , $ caseSensitive = true ) { $ sequenceCount = \ count ( $ sequence ) ; if ( 0 === $ sequenceCount ) { throw new \ InvalidArgumentException ( 'Invalid sequence.' ) ; } $ end = null === $ end ? \ count ( $ this ) - 1 : min ( $ end , \ count ( $ this ) - 1 ) ; if ( $ start + $ sequenceCount - 1 > $ end ) { return null ; } foreach ( $ sequence as $ key => $ token ) { if ( ! $ token instanceof Token ) { if ( \ is_array ( $ token ) && ! isset ( $ token [ 1 ] ) ) { $ token [ 1 ] = 'DUMMY' ; } $ token = new Token ( $ token ) ; } if ( $ token -> isWhitespace ( ) || $ token -> isComment ( ) || '' === $ token -> getContent ( ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Non-meaningful token at position: %s.' , $ key ) ) ; } } if ( ! self :: isLegacyMode ( ) ) { foreach ( $ sequence as $ token ) { if ( ! $ this -> isTokenKindFound ( $ this -> extractTokenKind ( $ token ) ) ) { return null ; } } } $ key = key ( $ sequence ) ; $ firstCs = Token :: isKeyCaseSensitive ( $ caseSensitive , $ key ) ; $ firstToken = $ sequence [ $ key ] ; unset ( $ sequence [ $ key ] ) ; $ index = $ start - 1 ; while ( null !== $ index && $ index <= $ end ) { $ index = $ this -> getNextTokenOfKind ( $ index , [ $ firstToken ] , $ firstCs ) ; if ( null === $ index || $ index > $ end ) { return null ; } $ result = [ $ index => $ this [ $ index ] ] ; $ currIdx = $ index ; foreach ( $ sequence as $ key => $ token ) { $ currIdx = $ this -> getNextMeaningfulToken ( $ currIdx ) ; if ( null === $ currIdx || $ currIdx > $ end ) { return null ; } if ( ! $ this [ $ currIdx ] -> equals ( $ token , Token :: isKeyCaseSensitive ( $ caseSensitive , $ key ) ) ) { continue 2 ; } $ result [ $ currIdx ] = $ this [ $ currIdx ] ; } if ( \ count ( $ sequence ) < \ count ( $ result ) ) { return $ result ; } } }
7530	protected function toString_attributes ( ) { $ s = '' ; foreach ( $ this -> attributes as $ a => $ v ) { $ s .= ' ' . $ a ; if ( ( ! $ this -> attribute_shorttag ) || ( $ v !== $ a ) ) { $ quote = ( strpos ( $ v , '"' ) === false ) ? '"' : "'" ; $ s .= '=' . $ quote . $ v . $ quote ; } } return $ s ; }
12336	public function changePasswordAction ( ) { if ( ! $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getLoginRoute ( ) ) ; } $ url = $ this -> url ( ) -> fromRoute ( null , [ 'action' => 'change-password' ] ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getChangePasswordForm ( ) ; $ form -> setObject ( $ this -> cmsAuthentication ( ) -> getIdentity ( ) ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ identity = $ this -> getUserService ( ) -> changePassword ( $ post ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/index/change-password-success' ) ; return $ viewModel ; } } return new ViewModel ( compact ( 'form' ) ) ; }
1979	public static function generate ( $ strScope = TL_MODE ) { $ strMessages = static :: generateUnwrapped ( $ strScope ) ; if ( $ strMessages != '' ) { $ strMessages = '<div class="tl_message">' . $ strMessages . '</div>' ; } return $ strMessages ; }
11405	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ cacheManager = new CacheManager ( $ serviceLocator -> get ( 'HtSettingsModule\Options\ModuleOptions' ) -> getCacheOptions ( ) ) ; $ cacheManager -> setServiceLocator ( $ serviceLocator ) ; return $ cacheManager ; }
6189	public function renderJSONP ( $ data ) { $ callback = null ; if ( isset ( $ _GET [ 'callback' ] ) ) { $ callback = $ _GET [ 'callback' ] ; } exit ( Response :: Create ( $ callback . '(' . json_encode ( $ data ) . ')' ) -> headers ( [ 'Content-Type' => 'application/jsonp' ] ) -> display ( ) ) ; }
5613	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ node = new TreemapNode ( 'Assertion' , $ message , false ) ; $ current = $ this -> _stack -> peek ( ) ; $ current -> putChild ( $ node ) ; $ current -> fail ( ) ; }
1478	public function delete ( $ resourceType , $ id , array $ queryParams = [ ] ) { return $ this -> resource ( RouteName :: delete ( $ resourceType ) , $ id , $ queryParams ) ; }
12859	public function addRoute ( string $ verb , string $ path , array $ callback ) : Router { $ this -> routeCollector -> addRoute ( $ verb , $ path , $ callback ) ; return $ this ; }
6923	private function buildKey ( TaxGroupInterface $ taxGroup , CountryInterface $ country , $ business = false ) { return sprintf ( '%s-%s-%s' , $ taxGroup -> getId ( ) , $ country -> getId ( ) , ( int ) $ business ) ; }
5785	public function addColumn ( string $ name , $ value ) { $ this -> args [ ] = $ value ; if ( mb_strlen ( $ this -> columns ) > 0 ) { $ this -> columns .= ", " ; } $ this -> columns .= $ name ; if ( mb_strlen ( $ this -> values ) > 0 ) { $ this -> values .= ", " ; } $ argNum = count ( $ this -> args ) ; $ this -> values .= "$" . $ argNum ; }
4165	private function mergeScope ( array $ scope ) { if ( empty ( $ scope ) ) return $ this -> _scope ; $ scope = array_merge ( $ scope , $ this -> _defaulScope ) ; $ scope = array_unique ( $ scope ) ; $ intersectingScope = array_intersect ( $ scope , $ this -> _availableScope ) ; if ( count ( $ intersectingScope ) !== count ( $ scope ) ) { throw new InvalidParameterException ( 'Error: mergeScope() - Invalid permission scope parameter used.' ) ; } return $ intersectingScope ; }
10917	private function isCmsActive ( ) { $ melisCms = 'MelisCms' ; $ moduleSvc = $ this -> getServiceLocator ( ) -> get ( 'ModulesService' ) ; $ modules = $ moduleSvc -> getActiveModules ( ) ; if ( in_array ( $ melisCms , $ modules ) ) { return true ; } return false ; }
11684	protected function registerCommands ( ) { $ this -> commands ( \ Lab123 \ Odin \ Command \ AppRestart :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ AppStart :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ GeneratePasswordCommand :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenAppNameCommand :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenRouteList :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenVendorPublish :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenModelMake :: class ) ; }
5153	public function addConfiguration ( $ configuration , $ configure = true ) { if ( ! $ configuration instanceof ConfigurationInterface ) { $ configuration = new Configuration ( $ configuration ) ; } $ config = $ this -> getConfiguration ( ) ; if ( $ config instanceof ConfigurationInterface ) { $ config -> merge ( $ configuration ) ; } if ( $ config === null ) { $ config = $ configuration ; } $ this -> setConfiguration ( $ config , $ configure ) ; }
4311	public function output ( $ options = array ( ) ) { $ cfgRestore = $ this -> config -> setCfg ( $ options ) ; if ( ! $ this -> cfg [ 'output' ] ) { $ this -> config -> setCfg ( $ cfgRestore ) ; return null ; } $ outputAs = $ this -> output -> getCfg ( 'outputAs' ) ; if ( \ is_string ( $ outputAs ) ) { $ this -> output -> setCfg ( 'outputAs' , $ outputAs ) ; } $ channels = $ this -> getChannels ( true ) ; $ channels [ ] = $ this ; $ headers = array ( ) ; foreach ( $ channels as $ channel ) { $ event = $ channel -> eventManager -> publish ( 'debug.output' , $ channel , array ( 'headers' => array ( ) , 'return' => '' , 'isTarget' => $ channel === $ this , ) ) ; $ headers = \ array_merge ( $ headers , $ event [ 'headers' ] ) ; } if ( ! $ this -> getCfg ( 'outputHeaders' ) || ! $ headers ) { $ this -> data [ 'headers' ] = \ array_merge ( $ this -> data [ 'headers' ] , $ event [ 'headers' ] ) ; } elseif ( \ headers_sent ( $ file , $ line ) ) { \ trigger_error ( 'PHPDebugConsole: headers already sent: ' . $ file . ', line ' . $ line , E_USER_NOTICE ) ; } else { foreach ( $ headers as $ nameVal ) { \ header ( $ nameVal [ 0 ] . ': ' . $ nameVal [ 1 ] ) ; } } if ( ! $ this -> parentInstance ) { $ this -> data [ 'outputSent' ] = true ; } $ this -> config -> setCfg ( $ cfgRestore ) ; return $ event [ 'return' ] ; }
7685	function XML_DeleteColumnElements ( & $ Txt , $ Tag , $ SpanAtt , $ ColLst , $ ColMax ) { $ ColNum = 0 ; $ ColPos = 0 ; $ ColQty = 1 ; $ Continue = true ; $ ModifNbr = 0 ; while ( $ Continue && ( $ Loc = clsTbsXmlLoc :: FindElement ( $ Txt , $ Tag , $ ColPos , true ) ) ) { if ( $ SpanAtt !== false ) { $ ColQty = $ Loc -> GetAttLazy ( $ SpanAtt ) ; $ ColQty = ( $ ColQty === false ) ? 1 : intval ( $ ColQty ) ; } $ KeepQty = 0 ; for ( $ i = 1 ; $ i <= $ ColQty ; $ i ++ ) { if ( array_search ( $ ColNum + $ i , $ ColLst ) === false ) $ KeepQty ++ ; } if ( $ KeepQty == 0 ) { $ Loc -> ReplaceSrc ( '' ) ; $ ModifNbr ++ ; } else { if ( $ KeepQty != $ ColQty ) { $ Loc -> ReplaceAtt ( $ SpanAtt , $ KeepQty ) ; $ ModifNbr ++ ; } $ ColPos = $ Loc -> PosEnd + 1 ; } $ ColNum += $ ColQty ; if ( $ ColNum > $ ColMax ) $ Continue = false ; } return $ ModifNbr ; }
8065	protected function getNextFreeWorker ( ) { $ sec = 0 ; while ( TRUE ) { $ this -> collectWorkerResults ( $ sec ) ; $ freeProcess = $ this -> workerProcesses -> takeFreeProcess ( ) ; if ( $ freeProcess !== NULL ) { return $ freeProcess ; } $ sec = $ this -> child_timeout_sec ; if ( $ this -> workerPoolSize <= 0 ) { throw new WorkerPoolException ( 'All workers were gone.' ) ; } } return NULL ; }
5196	public function addSearchResult ( $ index , $ type , array $ documents ) { $ result = [ 'took' => 5 , 'timed_out' => false , '_shards' => [ 'total' => 5 , 'successful' => 5 , 'failed' => 0 ] , 'hits' => [ 'total' => count ( $ documents ) , 'max_score' => 1 , 'hits' => [ ] ] ] ; foreach ( $ documents as $ document ) { $ result [ 'hits' ] [ 'hits' ] [ ] = [ '_index' => $ index , '_type' => $ type , '_id' => $ document [ 'id' ] , '_score' => 1 , '_source' => $ document ] ; } return $ this -> addResult ( 'search' , $ result ) ; }
12412	public function getDetails ( $ groupId , $ begin , $ count ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_DETAIL , $ params ] ) ; }
8716	public static function createInLocale ( $ locale , array $ attributes = [ ] , $ translations = [ ] ) { $ model = ( new static ( $ attributes ) ) -> setLocale ( $ locale ) ; if ( $ model -> save ( ) && is_array ( $ translations ) ) { $ model -> saveTranslations ( $ translations ) ; } return $ model ; }
268	protected function getContextMessage ( ) { $ context = ArrayHelper :: filter ( $ GLOBALS , $ this -> logVars ) ; foreach ( $ this -> maskVars as $ var ) { if ( ArrayHelper :: getValue ( $ context , $ var ) !== null ) { ArrayHelper :: setValue ( $ context , $ var , '***' ) ; } } $ result = [ ] ; foreach ( $ context as $ key => $ value ) { $ result [ ] = "\${$key} = " . VarDumper :: dumpAsString ( $ value ) ; } return implode ( "\n\n" , $ result ) ; }
2756	public function configDelete ( ConfigCrudEvent $ event ) { $ config = $ event -> getConfig ( ) ; if ( $ config -> getName ( ) === 'views.view.thunder_media' && ( $ media_view = View :: load ( 'media' ) ) ) { $ media_view -> setStatus ( TRUE ) -> save ( ) ; } }
5773	public function isUpdatable ( ) : bool { if ( is_null ( $ this -> authorization ) ) { throw new \ Exception ( "Authorization must be set" ) ; } if ( $ this -> authorization -> hasTopRole ( ) ) { return true ; } if ( ! $ this -> hasTopRole ( ) ) { return true ; } return false ; }
3303	public function getClient ( ) { if ( empty ( $ this -> client ) || ! ( $ this -> client instanceof HttpClient ) ) { $ this -> client = new HttpClient ( ) ; } return $ this -> client ; }
8160	public function confirm ( ) { $ this -> status = User :: STATUS_ACTIVE ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
10128	private function writeBreaks ( ) { $ vbreaks = [ ] ; $ hbreaks = [ ] ; foreach ( $ this -> phpSheet -> getBreaks ( ) as $ cell => $ breakType ) { $ coordinates = Coordinate :: coordinateFromString ( $ cell ) ; switch ( $ breakType ) { case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_COLUMN : $ vbreaks [ ] = Coordinate :: columnIndexFromString ( $ coordinates [ 0 ] ) - 1 ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_ROW : $ hbreaks [ ] = $ coordinates [ 1 ] ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_NONE : default : break ; } } if ( ! empty ( $ hbreaks ) ) { sort ( $ hbreaks , SORT_NUMERIC ) ; if ( $ hbreaks [ 0 ] == 0 ) { array_shift ( $ hbreaks ) ; } $ record = 0x001b ; $ cbrk = count ( $ hbreaks ) ; $ length = 2 + 6 * $ cbrk ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cbrk ) ; foreach ( $ hbreaks as $ hbreak ) { $ data .= pack ( 'vvv' , $ hbreak , 0x0000 , 0x00ff ) ; } $ this -> append ( $ header . $ data ) ; } if ( ! empty ( $ vbreaks ) ) { $ vbreaks = array_slice ( $ vbreaks , 0 , 1000 ) ; sort ( $ vbreaks , SORT_NUMERIC ) ; if ( $ vbreaks [ 0 ] == 0 ) { array_shift ( $ vbreaks ) ; } $ record = 0x001a ; $ cbrk = count ( $ vbreaks ) ; $ length = 2 + 6 * $ cbrk ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cbrk ) ; foreach ( $ vbreaks as $ vbreak ) { $ data .= pack ( 'vvv' , $ vbreak , 0x0000 , 0xffff ) ; } $ this -> append ( $ header . $ data ) ; } }
11908	private function getChangedAt ( string $ filename ) : float { clearstatcache ( true , $ filename ) ; return file_exists ( $ filename ) ? ( float ) file_get_contents ( $ filename ) : - 1 ; }
11932	protected function generateOption ( $ key , $ value ) { $ option = new FieldOption ( ) ; $ option -> setKey ( $ key ) ; $ option -> setValue ( $ value ) ; return $ option ; }
275	protected function renderDataCellContent ( $ model , $ key , $ index ) { if ( $ this -> content !== null ) { return call_user_func ( $ this -> content , $ model , $ key , $ index , $ this ) ; } return $ this -> grid -> emptyCell ; }
6957	private function _getRenderedToc ( $ list , $ depth = 1 ) { if ( ! isset ( $ list ) || empty ( $ list ) ) return ( '' ) ; $ html = "<ul class=\"toc-list\">\n" ; foreach ( $ list as $ entry ) { $ html .= "<li class=\"toc-entry\">\n" ; $ html .= '<a href="#' . $ this -> getParam ( 'anchorsPrefix' ) . $ this -> titleToIdentifier ( $ depth , $ entry [ 'value' ] ) . '">' . $ entry [ 'value' ] . "</a>\n" ; if ( isset ( $ entry [ 'sub' ] ) ) $ html .= $ this -> _getRenderedToc ( $ entry [ 'sub' ] , ( $ depth + 1 ) ) ; $ html .= "</li>\n" ; } $ html .= "</ul>\n" ; return ( $ html ) ; }
12913	public function cache ( $ flag , $ expiry = null ) { $ this -> cache = ( boolean ) $ flag ; if ( ! is_null ( $ expiry ) ) { $ this -> cacheExpiry = $ expiry ; } return $ this ; }
4818	public function addField ( $ name , $ value ) { if ( $ this -> currentRow < 0 ) { $ this -> appendRow ( ) ; } $ this -> collection [ $ this -> currentRow ] -> addField ( $ name , $ value ) ; }
9940	public function calculateColumnWidths ( ) { $ autoSizes = [ ] ; foreach ( $ this -> getColumnDimensions ( ) as $ colDimension ) { if ( $ colDimension -> getAutoSize ( ) ) { $ autoSizes [ $ colDimension -> getColumnIndex ( ) ] = - 1 ; } } if ( ! empty ( $ autoSizes ) ) { $ isMergeCell = [ ] ; foreach ( $ this -> getMergeCells ( ) as $ cells ) { foreach ( Coordinate :: extractAllCellReferencesInRange ( $ cells ) as $ cellReference ) { $ isMergeCell [ $ cellReference ] = true ; } } foreach ( $ this -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ this -> getCell ( $ coordinate , false ) ; if ( $ cell !== null && isset ( $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] ) ) { $ isMerged = isset ( $ isMergeCell [ $ this -> cellCollection -> getCurrentCoordinate ( ) ] ) ; $ isMergedButProceed = false ; if ( $ isMerged && $ cell -> isMergeRangeValueCell ( ) ) { $ range = $ cell -> getMergeRange ( ) ; $ rangeBoundaries = Coordinate :: rangeDimension ( $ range ) ; if ( $ rangeBoundaries [ 0 ] == 1 ) { $ isMergedButProceed = true ; } } if ( ! $ isMerged || $ isMergedButProceed ) { $ cellValue = NumberFormat :: toFormattedString ( $ cell -> getCalculatedValue ( ) , $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getNumberFormat ( ) -> getFormatCode ( ) ) ; $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] = max ( ( float ) $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] , ( float ) Shared \ Font :: calculateColumnWidth ( $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getFont ( ) , $ cellValue , $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getAlignment ( ) -> getTextRotation ( ) , $ this -> getParent ( ) -> getDefaultStyle ( ) -> getFont ( ) ) ) ; } } } foreach ( $ autoSizes as $ columnIndex => $ width ) { if ( $ width == - 1 ) { $ width = $ this -> getDefaultColumnDimension ( ) -> getWidth ( ) ; } $ this -> getColumnDimension ( $ columnIndex ) -> setWidth ( $ width ) ; } } return $ this ; }
1751	public static function getReferer ( $ blnEncodeAmpersands = false , $ strTable = null ) { $ objSession = static :: getContainer ( ) -> get ( 'session' ) ; $ ref = Input :: get ( 'ref' ) ; $ key = Input :: get ( 'popup' ) ? 'popupReferer' : 'referer' ; $ session = $ objSession -> get ( $ key ) ; if ( $ ref && isset ( $ session [ $ ref ] ) ) { $ session = $ session [ $ ref ] ; } elseif ( \ defined ( 'TL_MODE' ) && TL_MODE == 'BE' && \ is_array ( $ session ) ) { $ session = end ( $ session ) ; } if ( $ strTable != '' && isset ( $ session [ $ strTable ] ) && Input :: get ( 'act' ) != 'select' ) { $ session [ 'current' ] = $ session [ $ strTable ] ; } $ cleanUrl = function ( $ url , $ params = array ( 'rt' , 'ref' ) ) { if ( $ url == '' || strpos ( $ url , '?' ) === false ) { return $ url ; } list ( $ path , $ query ) = explode ( '?' , $ url , 2 ) ; $ queryObj = new Query ( $ query ) ; $ queryObj = $ queryObj -> withoutPairs ( $ params ) ; return $ path . $ queryObj -> getUriComponent ( ) ; } ; $ strUrl = ( $ cleanUrl ( $ session [ 'current' ] ) != $ cleanUrl ( Environment :: get ( 'request' ) ) ) ? $ session [ 'current' ] : $ session [ 'last' ] ; $ return = $ cleanUrl ( $ strUrl , array ( 'tg' , 'ptg' ) ) ; if ( $ return == '' && \ defined ( 'TL_MODE' ) && TL_MODE == 'FE' ) { $ return = Environment :: get ( 'httpReferer' ) ; } if ( $ return == '' ) { $ return = ( \ defined ( 'TL_MODE' ) && TL_MODE == 'BE' ) ? 'contao/main.php' : Environment :: get ( 'url' ) ; } return preg_replace ( '/&(amp;)?/i' , ( $ blnEncodeAmpersands ? '&amp;' : '&' ) , $ return ) ; }
12132	static public function addParams ( $ url , $ params ) { $ query = parse_url ( $ url , PHP_URL_QUERY ) ; $ separator = ( Text :: isEmpty ( $ query ) ? "?" : "&" ) ; return Text :: concat ( $ separator , $ url , http_build_query ( $ params ) ) ; }
11825	public function add ( $ encoding = 'UTF-8' ) { $ str = file_get_contents ( $ this -> uri ) ; return file_put_contents ( $ this -> uri , $ this -> getBom ( $ encoding ) . $ str ) ; }
6700	public function setPreRelease ( $ pre ) { $ this -> pre = array_values ( ( array ) $ pre ) ; array_walk ( $ this -> pre , function ( & $ v ) { if ( preg_match ( '/^[0-9]+$/' , $ v ) ) { $ v = ( int ) $ v ; } } ) ; }
2082	public function generateXmlFiles ( ) { $ this -> generateSitemap ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateXmlFiles' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateXmlFiles' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateXmlFiles' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( ) ; } } $ this -> purgePageCache ( ) ; $ this -> log ( 'Regenerated the XML files' , __METHOD__ , TL_CRON ) ; }
1569	public function getResourceIdentifier ( ) : ? ResourceIdentifierInterface { if ( ! $ resourceId = $ this -> getResourceId ( ) ) { return null ; } return ResourceIdentifier :: create ( $ this -> getResourceType ( ) , $ resourceId ) ; }
6894	protected function compareStockUnitByPrice ( StockUnitInterface $ u1 , StockUnitInterface $ u2 ) { $ u1HasPrice = 0 < $ u1 -> getNetPrice ( ) ; $ u2HasPrice = 0 < $ u2 -> getNetPrice ( ) ; if ( ! $ u1HasPrice && $ u2HasPrice ) { return 1 ; } if ( $ u1HasPrice && ! $ u2HasPrice ) { return - 1 ; } if ( $ u1 -> getNetPrice ( ) != $ u2 -> getNetPrice ( ) ) { return $ u1 -> getNetPrice ( ) > $ u2 -> getNetPrice ( ) ? 1 : - 1 ; } return 0 ; }
9530	private function initialize ( $ argv , $ parameterCluster ) { $ this -> valid = true ; $ this -> haltedBy = null ; if ( $ parameterCluster != null ) { $ this -> parameterCluster = $ parameterCluster ; if ( $ argv != null ) { $ this -> preloadAliases ( $ argv ) ; } } if ( $ argv != null ) { $ this -> preloadParameters ( $ argv ) ; } }
9645	public function makePdo ( array $ config , $ connection = null ) { if ( ! isset ( $ config [ 'driver' ] ) && ! isset ( $ config [ 'dsn' ] ) ) { throw new InvalidArgumentException ( 'DSN or driver must be set' ) ; } $ options = isset ( $ config [ 'pdo_options' ] ) ? $ config [ 'pdo_options' ] : [ ] ; unset ( $ config [ 'pdo_options' ] ) ; $ options = array_replace ( $ this -> defaultPdoOptions , $ options ) ; $ initCommands = isset ( $ config [ 'pdo_init_commands' ] ) ? $ config [ 'pdo_init_commands' ] : [ ] ; unset ( $ config [ 'pdo_init_commands' ] ) ; if ( isset ( $ config [ 'driver' ] ) && $ config [ 'driver' ] == 'sqlite' ) { $ this -> validate ( $ config , 'path' , $ connection ) ; $ dsn = $ this -> makeSqliteDsn ( $ config [ 'path' ] ) ; return $ this -> makePdoInner ( $ dsn , null , null , $ options , $ initCommands ) ; } elseif ( isset ( $ config [ 'dsn' ] ) && strpos ( $ config [ 'dsn' ] , 'sqlite:' ) === 0 ) { return $ this -> makePdoInner ( $ config [ 'dsn' ] , null , null , $ options , $ initCommands ) ; } $ this -> validate ( $ config , 'username' , $ connection , false ) ; $ username = $ config [ 'username' ] ; unset ( $ config [ 'username' ] ) ; $ this -> validate ( $ config , 'password' , $ connection , true ) ; $ password = $ config [ 'password' ] ; unset ( $ config [ 'password' ] ) ; if ( isset ( $ config [ 'dsn' ] ) ) { $ dsn = $ config [ 'dsn' ] ; } else { $ driver = $ config [ 'driver' ] ; unset ( $ config [ 'driver' ] ) ; $ this -> validate ( $ config , 'host' , $ connection ) ; $ this -> validate ( $ config , 'dbname' , $ connection ) ; $ dsn = $ this -> makeDsn ( $ driver , $ config ) ; } return $ this -> makePdoInner ( $ dsn , $ username , $ password , $ options , $ initCommands ) ; }
10045	private function createFromType ( Model $ model , Column $ column , $ item ) { $ result = null ; switch ( $ column -> getType ( ) ) { case Type :: TEXT : case Type :: TARRAY : case Type :: SIMPLE_ARRAY : case Type :: JSON_ARRAY : case Type :: OBJECT : case Type :: BLOB : $ result = new TextAreaFormItem ( ) ; break ; case Type :: INTEGER : case Type :: SMALLINT : case Type :: BIGINT : $ result = new IntegerFormItem ( ) ; break ; case Type :: DECIMAL : case Type :: FLOAT : $ result = new NumberFormItem ( ) ; break ; case Type :: BOOLEAN : $ result = new CheckboxFormItem ( ) ; break ; case Type :: DATE : $ result = new DateFormItem ( ) ; break ; case Type :: DATETIME : case Type :: DATETIMETZ : $ result = new DateTimeFormItem ( ) ; break ; case Type :: TIME : $ result = new TimeFormItem ( ) ; break ; case Type :: STRING : case Type :: GUID : default : $ result = new TextFormItem ( ) ; break ; } $ columnName = $ column -> getName ( ) ; $ result -> setName ( $ columnName ) ; $ result -> setLabel ( Lang :: trans ( $ this -> aujaConfigurator -> getColumnDisplayName ( $ model , $ columnName ) ) ) ; if ( $ item != null && isset ( $ item -> $ columnName ) ) { $ result -> setValue ( $ item -> $ columnName ) ; } return $ result ; }
10027	function getContactByEmail ( $ email , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/email/' . utf8_encode ( $ email ) , $ queryParameters ) ; }
10129	private function writeProtect ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) ) { return ; } $ record = 0x0012 ; $ length = 0x0002 ; $ fLock = 1 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fLock ) ; $ this -> append ( $ header . $ data ) ; }
2538	protected function initSoapClient ( $ wsdlId ) { $ wsdlPath = WsdlAnalyser :: $ wsdlIds [ $ wsdlId ] ; $ client = new Client \ SoapClient ( $ wsdlPath , $ this -> makeSoapClientOptions ( ) , $ this -> params -> logger ) ; return $ client ; }
5984	public function updateCredentials ( $ user , $ password ) { $ oldUser = $ this -> credentials -> getUsername ( ) ; $ this -> credentials = new Credentials ( $ this -> credentials -> getClientId ( ) , $ user , $ password ) ; unset ( $ password ) ; if ( $ this -> client instanceof Client ) { $ this -> client = $ this -> oauth2Middleware = null ; $ this -> client = $ this -> getClient ( ) ; } if ( $ this -> cache instanceof CacheProvider ) { $ this -> cache -> setNamespace ( md5 ( $ this -> basepath . $ this -> credentials -> getUsername ( ) . $ this -> credentials -> getPassword ( ) ) ) ; } $ this -> logger -> notice ( 'Updated user!' , [ 'old' => $ oldUser , 'new' => $ user ] ) ; }
8752	public function addDefinition ( $ identifier , DefinitionInterface $ definition ) { $ this -> definitions [ $ identifier ] = $ definition ; unset ( $ this -> dumpableDefinitions [ $ identifier ] ) ; }
5014	public function logBootstrap ( BootstrapEvent $ event ) : void { $ this -> getLogger ( ) -> info ( sprintf ( $ this -> tmpl [ 'queue' ] , 'Start' , $ event -> getQueue ( ) -> getName ( ) ) ) ; $ this -> injectLoggerInObject ( $ event -> getWorker ( ) ) ; $ this -> injectLoggerInEvent ( $ event ) ; }
4145	protected function validateCredentials ( $ credentials ) { $ credentials = array_filter ( $ credentials ) ; $ keys = array_keys ( $ credentials ) ; $ diff = array_diff ( $ this -> requiredCredentials , $ keys ) ; if ( ! empty ( $ diff ) ) { throw new MissingCredentialsException ( 'Missing Credentials: ' . implode ( $ diff , ', ' ) ) ; } unset ( $ credentials , $ keys , $ diff ) ; }
326	public static function sentence ( array $ words , $ twoWordsConnector = null , $ lastWordConnector = null , $ connector = ', ' ) { if ( $ twoWordsConnector === null ) { $ twoWordsConnector = Yii :: t ( 'yii' , ' and ' ) ; } if ( $ lastWordConnector === null ) { $ lastWordConnector = $ twoWordsConnector ; } switch ( count ( $ words ) ) { case 0 : return '' ; case 1 : return reset ( $ words ) ; case 2 : return implode ( $ twoWordsConnector , $ words ) ; default : return implode ( $ connector , array_slice ( $ words , 0 , - 1 ) ) . $ lastWordConnector . end ( $ words ) ; } }
5912	public function updateUser ( $ id , User $ user , $ password = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'user' => $ user , 'password' => $ password ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
1276	private function isMailInnovations ( ) { $ patterns = [ '/^MI\d{6}\d{1,22}$/' , '/^94071\d{17}$/' , '/^7\d{19}$/' , '/^93033\d{17}$/' , '/^M\d{9}$/' , '/^82\d{10}$/' , '/^EC\d{9}US$/' , '/^927\d{23}$/' , '/^927\d{19}$/' , '/^EA\d{9}US$/' , '/^CP\d{9}US$/' , '/^92055\d{17}$/' , '/^14\d{18}$/' , '/^92088\d{17}$/' , '/^RA\d{9}US$/' , '/^9202\d{16}US$/' , '/^23\d{16}US$/' , '/^94\d{20}$/' , '/^03\d{18}$/' ] ; foreach ( $ patterns as $ pattern ) { if ( preg_match ( $ pattern , $ this -> trackingNumber ) ) { return true ; } } return false ; }
8744	protected function runLoop ( ) { while ( $ this -> isListening ) { $ this -> stream -> select ( ) ; if ( true === $ this -> charSequenceEnabled && null !== $ this -> escapePressedAt ) { if ( $ this -> escapeKeyHasExpired ( ) ) { $ this -> disableKeySequence ( ) ; $ this -> setCurrentKey ( $ this -> matcher -> getKey ( $ this -> matcher -> getEscapeKey ( ) ) ) ; $ this -> dispatchKeyPressEvents ( $ this -> getCurrentKey ( ) ) ; } } if ( $ this -> stream -> isAvailable ( ) ) { $ char = $ this -> stream -> getChar ( ) ; if ( $ this -> matcher -> getEscapeKey ( ) === $ char ) { $ this -> enableKeySequence ( ) ; $ this -> setCurrentKey ( $ char ) ; } else { $ this -> escapePressedAt = null ; if ( $ this -> charSequenceEnabled ) { $ this -> concatCurrentKey ( $ char ) ; $ mapped = $ this -> matcher -> getKey ( $ this -> getCurrentKey ( ) ) ; if ( $ mapped ) { $ this -> setCurrentKey ( $ mapped ) ; $ this -> disableKeySequence ( ) ; } else { continue ; } } else { if ( $ this -> matcher -> isBasicLatin ( $ char ) ) { continue ; } else { $ this -> setCurrentKey ( $ this -> matcher -> getKey ( $ char ) ? : $ char ) ; } } $ this -> dispatchKeyPressEvents ( $ this -> getCurrentKey ( ) ) ; } } } return $ this ; }
4238	public function hasLog ( ) { $ entryCountInitial = $ this -> debug -> getData ( 'entryCountInitial' ) ; $ entryCountCurrent = $ this -> debug -> getData ( 'log/__count__' ) ; $ haveLog = $ entryCountCurrent > $ entryCountInitial ; $ lastEntryMethod = $ this -> debug -> getData ( 'log/__end__/0' ) ; return $ haveLog && $ lastEntryMethod !== 'clear' ; }
1144	protected function bootstrapConfigs ( ) { $ configFile = realpath ( __DIR__ . '/../config/jsvalidation.php' ) ; $ this -> mergeConfigFrom ( $ configFile , 'jsvalidation' ) ; $ this -> publishes ( [ $ configFile => $ this -> app [ 'path.config' ] . '/jsvalidation.php' ] , 'config' ) ; }
12084	public function getObject ( Entity $ subject ) { $ object = NULL ; $ mediaObjectURI = $ subject -> getObjectURI ( ) ; if ( ! empty ( $ mediaObjectURI ) ) : $ mediaSubject = new Object ( ) ; $ mediaObjectType = $ subject -> getObjectType ( ) ; if ( is_object ( $ mediaSubject ) && method_exists ( $ mediaSubject , "getArray" ) ) : $ object = $ mediaSubject :: getArray ( ) ; endif ; else : endif ; return $ object ; }
3812	protected function transformConditions ( $ conditions ) { $ sorted = array ( ) ; $ byPid = array ( ) ; foreach ( $ conditions as $ i => $ condition ) { $ sorted [ $ condition [ 'id' ] ] = $ conditions [ $ i ] ; $ byPid [ $ condition [ 'pid' ] ] [ ] = $ condition [ 'id' ] ; } $ instances = array ( ) ; foreach ( $ sorted as $ id => $ condition ) { $ instances [ $ id ] = $ this -> transformCondition ( $ condition ) ; } foreach ( $ byPid as $ pid => $ ids ) { foreach ( $ ids as $ id ) { $ settingId = $ sorted [ $ id ] [ 'settingId' ] ; if ( ! isset ( $ this -> conditions [ $ settingId ] ) ) { $ this -> conditions [ $ settingId ] = new PropertyConditionChain ( ) ; } $ result = $ this -> conditions [ $ settingId ] ; $ condition = $ instances [ $ id ] ; $ parent = ( $ pid == 0 ) ? $ result : $ instances [ $ pid ] ; if ( $ parent instanceof ConditionChainInterface ) { $ parent -> addCondition ( $ condition ) ; } elseif ( $ parent instanceof NotCondition ) { $ parent -> setCondition ( $ condition ) ; } } } }
3522	public static function refresh ( $ refresh_token ) { $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , [ 'grant_type' => 'refresh_token' , 'refresh_token' => $ refresh_token , 'includePerms' => "false" , 'token_type' => 'eg1' , ] , FortniteClient :: FORTNITE_AUTHORIZATION ) ; if ( ! $ data -> access_token ) { throw new \ Exception ( $ data -> errorMessage ) ; } return new self ( $ data -> access_token , $ data -> in_app_id , $ data -> refresh_token , $ data -> account_id , $ data -> expires_in ) ; }
4555	protected function addJoinTranslation ( QueryBuilder $ queryBuilder , string $ resourceClass ) { $ rootAlias = $ queryBuilder -> getRootAliases ( ) [ 0 ] ; $ translationAlias = $ rootAlias . '_t' ; $ translationClass = call_user_func ( $ resourceClass . '::getTranslationEntityClass' ) ; $ parts = $ queryBuilder -> getDQLParts ( ) [ 'join' ] ; foreach ( $ parts as $ joins ) { foreach ( $ joins as $ join ) { if ( $ translationAlias === $ join -> getAlias ( ) ) { return $ translationAlias ; } } } $ queryBuilder -> leftJoin ( $ translationClass , $ translationAlias , Join :: WITH , $ rootAlias . '.id = ' . $ translationAlias . '.translatable' ) ; return $ translationAlias ; }
2120	public function getFromFile ( ) { $ return = array ( ) ; $ files = System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'config' ) -> depth ( 0 ) -> files ( ) -> name ( 'database.sql' ) ; foreach ( $ files as $ file ) { $ return = array_replace_recursive ( $ return , SqlFileParser :: parse ( $ file ) ) ; } ksort ( $ return ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ return = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ return ) ; } } return $ return ; }
11242	protected function _call ( $ fieldData , $ controller , $ method , $ passing , $ arguments ) { $ fieldData = array ( $ fieldData , $ arguments ) ; $ result = call_user_func_array ( array ( $ controller , $ method ) , $ fieldData ) ; return $ result == $ passing ? true : false ; }
5214	private function findBinding ( $ type , $ name ) { $ bindingName = $ this -> bindingName ( $ name ) ; if ( null !== $ bindingName && isset ( $ this -> index [ $ type . '#' . $ bindingName ] ) ) { return $ this -> index [ $ type . '#' . $ bindingName ] ; } if ( isset ( $ this -> index [ $ type ] ) ) { return $ this -> index [ $ type ] ; } if ( ! in_array ( $ type , [ PropertyBinding :: TYPE , ConstantBinding :: TYPE , ListBinding :: TYPE , MapBinding :: TYPE ] ) ) { $ this -> index [ $ type ] = $ this -> getAnnotatedBinding ( new \ ReflectionClass ( $ type ) ) ; return $ this -> index [ $ type ] ; } return null ; }
5197	protected function version ( ) { $ version = explode ( '(' , $ this -> app -> version ( ) ) ; if ( isset ( $ version [ 1 ] ) ) { return substr ( $ version [ 1 ] , 0 , 3 ) ; } return null ; }
10838	protected function setRaw ( $ Key , $ Val , $ expire = 0 ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; return file_put_contents ( $ CacheFile , serialize ( $ Val ) ) > 0 ; }
10216	public function addFromSource ( array $ pSource = null ) { if ( $ pSource == null ) { return ; } foreach ( $ pSource as $ item ) { $ this -> add ( $ item ) ; } }
4816	public function appendRow ( $ singleRow = null ) { if ( ! is_null ( $ singleRow ) ) { if ( $ singleRow instanceof Row ) { $ this -> collection [ ] = $ singleRow ; $ singleRow -> acceptChanges ( ) ; } elseif ( is_array ( $ singleRow ) ) { $ this -> collection [ ] = new Row ( $ singleRow ) ; } else { throw new InvalidArgumentException ( "You must pass an array or a Row object" ) ; } } else { $ singleRow = new Row ( ) ; $ this -> collection [ ] = $ singleRow ; $ singleRow -> acceptChanges ( ) ; } $ this -> currentRow = count ( $ this -> collection ) - 1 ; }
6224	public function removeDir ( ) : bool { if ( ! $ this -> isDir ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to remove directory for path: "%s"' , $ this -> path -> raw ) , 500 ) ; } try { $ iterator = $ this -> getIterator ( true , \ RecursiveIteratorIterator :: CHILD_FIRST ) ; foreach ( $ iterator as $ splFile ) { if ( ! $ splFile -> isReadable ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to access file for path: "%s"' , $ splFile -> getPathname ( ) ) , 500 ) ; } switch ( $ splFile -> getType ( ) ) { case 'dir' : rmdir ( $ splFile -> getRealPath ( ) ) ; break ; case 'link' : unlink ( $ splFile -> getPathname ( ) ) ; break ; default : unlink ( $ splFile -> getRealPath ( ) ) ; } } return rmdir ( $ this -> path -> raw ) ; } finally { $ this -> selfdestruct = false ; $ this -> path -> reload ( ) ; } }
1717	public function canEditFieldsOf ( $ table ) { if ( $ this -> isAdmin ) { return true ; } return \ count ( preg_grep ( '/^' . preg_quote ( $ table , '/' ) . '::/' , $ this -> alexf ) ) > 0 ; }
4705	public function slice ( $ offset , $ length = null ) { return new Collection ( array_slice ( $ this -> objects , $ offset , $ length ) ) ; }
1312	public function setTimeouts ( $ connectionTimeout , $ timeout ) { $ this -> connectionTimeout = ( int ) $ connectionTimeout ; $ this -> timeout = ( int ) $ timeout ; }
2039	private function createConfig ( $ size ) : array { if ( ! \ is_array ( $ size ) ) { $ size = [ 0 , 0 , $ size ] ; } $ config = new PictureConfiguration ( ) ; $ attributes = [ ] ; if ( ! isset ( $ size [ 2 ] ) || ! is_numeric ( $ size [ 2 ] ) ) { $ resizeConfig = new ResizeConfiguration ( ) ; if ( ! empty ( $ size [ 0 ] ) ) { $ resizeConfig -> setWidth ( ( int ) $ size [ 0 ] ) ; } if ( ! empty ( $ size [ 1 ] ) ) { $ resizeConfig -> setHeight ( ( int ) $ size [ 1 ] ) ; } if ( ! empty ( $ size [ 2 ] ) ) { $ resizeConfig -> setMode ( $ size [ 2 ] ) ; } $ configItem = new PictureConfigurationItem ( ) ; $ configItem -> setResizeConfig ( $ resizeConfig ) ; if ( $ this -> defaultDensities ) { $ configItem -> setDensities ( $ this -> defaultDensities ) ; } $ config -> setSize ( $ configItem ) ; return [ $ config , $ attributes ] ; } $ imageSizeModel = $ this -> framework -> getAdapter ( ImageSizeModel :: class ) ; $ imageSizes = $ imageSizeModel -> findByPk ( $ size [ 2 ] ) ; $ config -> setSize ( $ this -> createConfigItem ( $ imageSizes ) ) ; if ( $ imageSizes && $ imageSizes -> cssClass ) { $ attributes [ 'class' ] = $ imageSizes -> cssClass ; } $ imageSizeItemModel = $ this -> framework -> getAdapter ( ImageSizeItemModel :: class ) ; $ imageSizeItems = $ imageSizeItemModel -> findVisibleByPid ( $ size [ 2 ] , [ 'order' => 'sorting ASC' ] ) ; if ( null !== $ imageSizeItems ) { $ configItems = [ ] ; foreach ( $ imageSizeItems as $ imageSizeItem ) { $ configItems [ ] = $ this -> createConfigItem ( $ imageSizeItem ) ; } $ config -> setSizeItems ( $ configItems ) ; } return [ $ config , $ attributes ] ; }
4073	public function getUser ( ) { static $ authenticated ; if ( ! isset ( $ authenticated ) ) { $ authenticated = true ; $ this -> authenticateUser ( ) ; } return $ this -> user ; }
3056	public function persistLastCatItemOutput ( array $ lastCatItemOutput ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> setCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-item-output' , json_encode ( $ lastCatItemOutput ) ) ; }
12966	public function getObjectTypeDescriptor ( ) { if ( is_null ( $ this -> _objectTypeDescriptor ) && isset ( $ this -> object ) ) { $ this -> _objectTypeDescriptor = $ this -> object -> objectType -> title -> upperSingular ; } return $ this -> _objectTypeDescriptor ; }
2096	public function getWeekBegin ( $ intStartDay = 0 ) { $ intOffset = date ( 'w' , $ this -> strDate ) - $ intStartDay ; if ( $ intOffset < 0 ) { $ intOffset += 7 ; } return strtotime ( '-' . $ intOffset . ' days' , $ this -> strDate ) ; }
12817	public function fetchAll ( ) { $ list = [ ] ; foreach ( $ this -> cache as $ domain => $ values ) { foreach ( $ values as $ key => $ value ) $ list [ sprintf ( "%s.%s" , $ domain != '<NULL>' ? $ domain : '' , $ key ) ] = $ value ; } return $ list ; }
2699	private function upgrade108 ( $ oldConfigPaths , $ newConfigPaths ) { foreach ( $ oldConfigPaths as $ key => $ value ) { $ oldValue = $ this -> scopeConfig -> getValue ( $ value ) ; if ( $ oldValue != null ) { $ this -> configWriter -> save ( $ newConfigPaths [ $ key ] , $ oldValue ) ; } } }
2065	public function checkJumpTo ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == $ dc -> id ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'circularReference' ] ) ; } return $ varValue ; }
1599	protected function authenticate ( ) { if ( empty ( $ this -> guards ) && Auth :: check ( ) ) { return ; } foreach ( $ this -> guards as $ guard ) { if ( Auth :: guard ( $ guard ) -> check ( ) ) { Auth :: shouldUse ( $ guard ) ; return ; } } throw new AuthenticationException ( 'Unauthenticated.' , $ this -> guards ) ; }
2273	public function getModules ( ) { $ groups = array ( ) ; foreach ( $ GLOBALS [ 'FE_MOD' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { $ groups [ $ k ] [ ] = $ kk ; } } return $ groups ; }
12027	function addExecuteMethod ( ) { $ body = $ this -> generateCreateFragment ( ) ; $ body .= 'return $this->dispatch($request);' ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Execute the operation, returning the parsed response' ) ; $ methodGenerator = new MethodGenerator ( 'execute' ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
7471	public function createAction ( Request $ request ) { $ user = new User ( ) ; $ form = $ this -> createForm ( UserType :: class , $ user ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ factory = $ this -> get ( 'security.encoder_factory' ) ; $ encoder = $ factory -> getEncoder ( $ user ) ; $ user -> setPassword ( $ encoder -> encodePassword ( $ user -> getPassword ( ) , $ user -> getSalt ( ) ) ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The user has been created.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ user -> getId ( ) ) ) ) ; } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) ) ; }
7010	private function formatN ( & $ str ) { if ( strstr ( $ str , '%N' ) ) { $ wdn = $ this -> weekDayNum ( ) ; $ str = str_replace ( '%N' , $ wdn == 0 ? 7 : $ wdn , $ str ) ; } }
11073	public function setString ( string $ key , $ value , string $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( string ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
1931	public function attachFileFromString ( $ strContent , $ strFilename , $ strMime = 'application/octet-stream' ) { $ this -> objMessage -> attach ( new \ Swift_Attachment ( $ strContent , $ strFilename , $ strMime ) ) ; }
10641	public function andWhere ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "AND" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
6310	private function getCommand ( DatabaseObjectInterface $ databaseObject , $ isCreate = true ) { if ( $ databaseObject instanceof Column ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.add_column' : 'rentgen.drop_column' ) -> setColumn ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof ConstraintInterface ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.add_constraint' : 'rentgen.drop_constraint' ) -> setConstraint ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof Index ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.create_index' : 'rentgen.drop_index' ) -> setIndex ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof Schema ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.create_schema' : 'rentgen.drop_schema' ) -> setSchema ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof Table ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.create_table' : 'rentgen.drop_table' ) -> setTable ( $ databaseObject ) ; } else { throw new \ Exception ( sprintf ( "Class %s is not supported" , get_class ( $ databaseObject ) ) ) ; } return $ command ; }
2723	public function execute ( Observer $ observer ) { if ( $ this -> fastlyConfig -> isFastlyEnabled ( ) != true ) { return ; } $ event = $ observer -> getEvent ( ) ; $ name = $ event -> getElementName ( ) ; $ layout = $ event -> getLayout ( ) ; $ block = $ layout -> getBlock ( $ name ) ; if ( $ block instanceof AbstractBlock ) { $ blockTtl = $ block -> getTtl ( ) ; if ( isset ( $ blockTtl ) ) { $ this -> response -> setHeader ( "x-esi" , "1" ) ; } } }
5041	public function onBootstrap ( MvcEvent $ e ) { if ( ! DoctrineType :: hasType ( 'tz_date' ) ) { DoctrineType :: addType ( 'tz_date' , '\Core\Repository\DoctrineMongoODM\Types\TimezoneAwareDate' ) ; } $ sm = $ e -> getApplication ( ) -> getServiceManager ( ) ; $ translator = $ sm -> get ( 'translator' ) ; \ Zend \ Validator \ AbstractValidator :: setDefaultTranslator ( $ translator ) ; $ eventManager = $ e -> getApplication ( ) -> getEventManager ( ) ; $ sharedManager = $ eventManager -> getSharedManager ( ) ; if ( ! \ Zend \ Console \ Console :: isConsole ( ) ) { ( new ErrorHandlerListener ( ) ) -> attach ( $ eventManager ) ; $ languageRouteListener = new LanguageRouteListener ( $ sm -> get ( 'Core/Locale' ) , $ sm -> get ( 'Core/Options' ) ) ; $ languageRouteListener -> attach ( $ eventManager ) ; $ ajaxRenderListener = new AjaxRenderListener ( ) ; $ ajaxRenderListener -> attach ( $ eventManager ) ; $ ajaxRouteListener = $ sm -> get ( AjaxRouteListener :: class ) ; $ ajaxRouteListener -> attach ( $ eventManager ) ; $ xmlRenderListener = new XmlRenderListener ( ) ; $ xmlRenderListener -> attach ( $ eventManager ) ; $ enforceJsonResponseListener = new EnforceJsonResponseListener ( ) ; $ enforceJsonResponseListener -> attach ( $ eventManager ) ; $ stringListener = new StringListener ( ) ; $ stringListener -> attach ( $ eventManager ) ; } $ notificationListener = $ sm -> get ( 'Core/Listener/Notification' ) ; $ notificationListener -> attachShared ( $ sharedManager ) ; $ notificationAjaxHandler = new NotificationAjaxHandler ( ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH , array ( $ notificationAjaxHandler , 'injectView' ) , - 20 ) ; $ notificationListener -> attach ( NotificationEvent :: EVENT_NOTIFICATION_HTML , array ( $ notificationAjaxHandler , 'render' ) , - 20 ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH_ERROR , function ( $ event ) { if ( $ event instanceof MvcEvent ) { $ application = $ event -> getApplication ( ) ; if ( $ application :: ERROR_EXCEPTION == $ event -> getError ( ) ) { $ ex = $ event -> getParam ( 'exception' ) ; if ( 404 == $ ex -> getCode ( ) ) { $ event -> setError ( $ application :: ERROR_CONTROLLER_NOT_FOUND ) ; } } } } , 500 ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH , function ( $ event ) use ( $ eventManager ) { $ eventManager -> trigger ( 'postDispatch' , $ event ) ; } , - 150 ) ; $ sm -> get ( 'Tracy' ) -> startDebug ( ) ; }
11942	private function validateArgument ( Request $ request , ConfigContainer $ config , $ position ) { $ value = null ; switch ( $ config -> getValue ( 'storage' ) ) { case 'url' : $ value = $ this -> validateUrl ( $ request , $ config , $ position ) ; break ; case 'post' : $ value = $ this -> validateGetPost ( $ request -> getData ( ) , $ config , $ position ) ; break ; case 'get' : $ value = $ this -> validateGetPost ( $ request -> getQuery ( ) , $ config , $ position ) ; break ; default : throw new InvalidConfigValueException ( 'storage' , $ config -> getValue ( 'storage' ) ) ; } $ validatorName = $ config -> getValue ( 'validator' ) ; if ( $ validatorName !== '' ) { $ validatorObject = new $ validatorName ( ) ; $ error = $ validatorObject -> validate ( $ value ) ; if ( $ error ) { throw new InvalidArgumentException ( $ position , $ config -> getValue ( 'name' ) , $ error ) ; } } $ mapperName = $ config -> getValue ( 'mapper' ) ; if ( $ mapperName !== '' ) { $ mapper = new $ mapperName ( $ this -> container ) ; $ value = $ mapper -> cast ( $ value ) ; } $ request -> setArgument ( $ config -> getValue ( 'name' ) , $ value ) ; }
4708	public function initialize ( Text $ text , array $ options = array ( ) ) { $ text -> replace ( '{ ^[ ]{0,' . $ options [ 'tabWidth' ] . '}\[(.+)\]: # id = $1 [ \t]* \n? # maybe *one* newline [ \t]* <?(\S+?)>? # url = $2 [ \t]* \n? # maybe one newline [ \t]* (?: (?<=\s) # lookbehind for whitespace ["\'(] (.+?) # title = $3 ["\')] [ \t]* )? # title is optional (?:\n+|\Z) }xm' , function ( Text $ whole , Text $ id , Text $ url , Text $ title = null ) { $ id -> lower ( ) ; $ this -> markdown -> emit ( 'escape.special_chars' , [ $ url -> replace ( '/(?<!\\\\)_/' , '\\\\_' ) ] ) ; $ this -> markdown -> getUrlRegistry ( ) -> set ( $ id , htmlspecialchars ( $ url , ENT_QUOTES , 'UTF-8' , false ) ) ; if ( $ title ) { $ this -> markdown -> getTitleRegistry ( ) -> set ( $ id , preg_replace ( '/"/' , '&quot;' , $ title ) ) ; } return '' ; } ) ; }
3644	public function map ( array $ keys , bool $ trim = true , bool $ clean = true ) { $ values = $ this -> only ( array_keys ( $ keys ) , $ trim , $ clean ) ; $ new = [ ] ; foreach ( $ keys as $ key => $ value ) { $ new [ $ value ] = array_get ( $ values , $ key ) ; } return $ new ; }
8538	public function setOffer ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Offer' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3794	private function checkForAction ( $ clipboard , $ action ) { $ filter = new Filter ( ) ; $ filter -> andActionIs ( $ action ) ; $ items = $ clipboard -> fetch ( $ filter ) ; if ( $ items === null ) { return ; } foreach ( $ items as $ item ) { $ itemProviderName = $ item -> getDataProviderName ( ) ; $ modelId = $ item -> getModelId ( ) ; if ( $ this -> providerName !== $ itemProviderName ) { continue ; } if ( ! $ modelId ) { $ this -> checkEmpty ( $ action ) ; continue ; } $ containedModel = $ this -> getModelById ( $ modelId -> getId ( ) ) ; if ( $ this -> currentModel == null ) { $ this -> checkForRoot ( $ containedModel , $ action ) ; } elseif ( $ containedModel ) { $ this -> checkForModel ( $ containedModel , $ action ) ; } else { $ this -> checkEmpty ( $ action ) ; } } }
1356	protected function getSortColumn ( $ field , Model $ model ) { if ( isset ( $ this -> sortColumns [ $ field ] ) ) { return $ this -> sortColumns [ $ field ] ; } return $ model :: $ snakeAttributes ? Str :: underscore ( $ field ) : Str :: camelize ( $ field ) ; }
293	public function getAttribute ( $ name ) { return isset ( $ this -> _attributes [ $ name ] ) ? $ this -> _attributes [ $ name ] : null ; }
8475	public function debug ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'debug' , $ scope , $ message , $ context , $ config ) ; }
5321	public function remove ( ) { if ( is_resource ( $ this -> mutex ) ) { sem_remove ( $ this -> mutex ) ; } if ( file_exists ( $ this -> file ) ) { unlink ( $ this -> file ) ; } }
11749	public function material ( ) { if ( is_null ( $ this -> material ) ) { $ this -> material = new Material ( $ this -> accessToken ) ; } return $ this -> material ; }
5258	public static function map ( $ query = [ ] , callable $ callback = null , $ limit = - 1 ) { if ( $ query instanceof QueryBuilder ) { $ query = $ query -> build ( ) ; } $ query [ 'from' ] = Arr :: get ( $ query , 'from' , 0 ) ; $ query [ 'size' ] = Arr :: get ( $ query , 'size' , 50 ) ; $ i = 0 ; $ models = static :: search ( $ query ) ; $ total = $ models -> getTotal ( ) ; while ( $ models ) { foreach ( $ models as $ model ) { if ( $ callback ) { $ callback ( $ model ) ; } $ i ++ ; } $ query [ 'from' ] += $ query [ 'size' ] ; if ( $ i >= $ total || ( $ limit > 0 && $ i >= $ limit ) ) { break ; } $ models = static :: search ( $ query ) ; } return $ total ; }
1008	public static function suggestionList ( $ input , array $ options ) { $ optionsByDistance = [ ] ; $ inputThreshold = mb_strlen ( $ input ) / 2 ; foreach ( $ options as $ option ) { if ( $ input === $ option ) { $ distance = 0 ; } else { $ distance = ( strtolower ( $ input ) === strtolower ( $ option ) ? 1 : levenshtein ( $ input , $ option ) ) ; } $ threshold = max ( $ inputThreshold , mb_strlen ( $ option ) / 2 , 1 ) ; if ( $ distance > $ threshold ) { continue ; } $ optionsByDistance [ $ option ] = $ distance ; } asort ( $ optionsByDistance ) ; return array_keys ( $ optionsByDistance ) ; }
9835	public static function imagecreatefrombmp ( $ p_sFile ) { $ file = fopen ( $ p_sFile , 'rb' ) ; $ read = fread ( $ file , 10 ) ; while ( ! feof ( $ file ) && ( $ read != '' ) ) { $ read .= fread ( $ file , 1024 ) ; } $ temp = unpack ( 'H*' , $ read ) ; $ hex = $ temp [ 1 ] ; $ header = substr ( $ hex , 0 , 108 ) ; if ( substr ( $ header , 0 , 4 ) == '424d' ) { $ header_parts = str_split ( $ header , 2 ) ; $ width = hexdec ( $ header_parts [ 19 ] . $ header_parts [ 18 ] ) ; $ height = hexdec ( $ header_parts [ 23 ] . $ header_parts [ 22 ] ) ; unset ( $ header_parts ) ; } $ x = 0 ; $ y = 1 ; $ image = imagecreatetruecolor ( $ width , $ height ) ; $ body = substr ( $ hex , 108 ) ; $ body_size = ( strlen ( $ body ) / 2 ) ; $ header_size = ( $ width * $ height ) ; $ usePadding = ( $ body_size > ( $ header_size * 3 ) + 4 ) ; for ( $ i = 0 ; $ i < $ body_size ; $ i += 3 ) { if ( $ x >= $ width ) { if ( $ usePadding ) { $ i += $ width % 4 ; } $ x = 0 ; ++ $ y ; if ( $ y > $ height ) { break ; } } $ i_pos = $ i * 2 ; $ r = hexdec ( $ body [ $ i_pos + 4 ] . $ body [ $ i_pos + 5 ] ) ; $ g = hexdec ( $ body [ $ i_pos + 2 ] . $ body [ $ i_pos + 3 ] ) ; $ b = hexdec ( $ body [ $ i_pos ] . $ body [ $ i_pos + 1 ] ) ; $ color = imagecolorallocate ( $ image , $ r , $ g , $ b ) ; imagesetpixel ( $ image , $ x , $ height - $ y , $ color ) ; ++ $ x ; } unset ( $ body ) ; return $ image ; }
3509	private static function renderToTextFromOpcode ( $ opcode , $ from , $ from_offset , $ from_len ) { if ( $ opcode === 'c' || $ opcode === 'i' ) { echo substr ( $ from , $ from_offset , $ from_len ) ; } }
322	public static function pluralize ( $ word ) { if ( isset ( static :: $ specials [ $ word ] ) ) { return static :: $ specials [ $ word ] ; } foreach ( static :: $ plurals as $ rule => $ replacement ) { if ( preg_match ( $ rule , $ word ) ) { return preg_replace ( $ rule , $ replacement , $ word ) ; } } return $ word ; }
10407	private function save ( Pair $ pair ) { $ this -> manager -> persist ( $ pair ) ; $ this -> manager -> commit ( ) ; $ this -> manager -> refresh ( ) ; }
3279	protected function replace ( string $ key , $ data ) { $ tmpFile = $ this -> getDatabase ( ) -> openTempFile ( ) ; $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; foreach ( $ file as $ line ) { if ( $ line -> getKey ( ) == $ key ) { if ( $ data !== false ) { $ tmpFile -> fwrite ( $ this -> getLineString ( $ key , $ data ) ) ; } } else { $ tmpFile -> fwrite ( $ line -> getLine ( ) . "\n" ) ; } } $ tmpFile -> rewind ( ) ; $ this -> getDatabase ( ) -> writeTempToFile ( $ tmpFile ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { $ cache -> delete ( $ key ) ; } }
9630	public function verifyAndMoveUploadedFile ( $ originSize , $ tmpDestination , $ publicDestination ) { $ remoteTempSize = $ this -> getSize ( $ tmpDestination ) ; $ this -> logger -> debug ( 'Temp size: ' . $ remoteTempSize ) ; $ this -> logger -> debug ( 'Origin size: ' . $ originSize ) ; if ( $ remoteTempSize <= 0 ) { throw new VerifySizeException ( 'Uploaded file has size ' . $ remoteTempSize ) ; } if ( $ remoteTempSize !== $ originSize ) { throw new VerifySizeException ( sprintf ( 'Uploaded file has wrong size. Expected %s, got %s.' , $ originSize , $ remoteTempSize ) ) ; } $ this -> logger -> info ( 'OK: Uploaded temp file has right size.' ) ; if ( ! $ this -> move ( $ tmpDestination , $ publicDestination ) ) { throw new FtpException ( 'Error renaming uploaded file from temp to public.' ) ; } $ remotePublicSize = $ this -> getSize ( $ publicDestination ) ; $ this -> logger -> debug ( 'Renamed size: ' . $ remotePublicSize ) ; if ( $ remotePublicSize <= 0 ) { throw new VerifySizeException ( 'Renamed file has size ' . $ remotePublicSize ) ; } if ( $ remotePublicSize !== $ originSize ) { throw new VerifySizeException ( sprintf ( 'Renamed file has wrong size. Expected %s, got %s.' , $ originSize , $ remotePublicSize ) ) ; } $ this -> logger -> info ( 'OK: Renamed file has right size.' ) ; return true ; }
4361	public static function isUtf8 ( $ str , & $ special = false ) { self :: setStr ( $ str ) ; $ special = false ; while ( self :: $ curI < self :: $ stats [ 'strLen' ] ) { $ isUtf8 = self :: isOffsetUtf8 ( $ isSpecial ) ; if ( ! $ isUtf8 ) { return false ; } if ( $ isSpecial ) { $ special = true ; } } $ special = $ special || self :: hasSpecial ( $ str ) ; return true ; }
8281	public function onTwigRegistered ( & $ twig ) { $ twig -> getLoader ( ) -> addPath ( $ this -> pluginDir . '/theme' ) ; $ this_instance = $ this ; $ twig -> addFunction ( new \ Twig_SimpleFunction ( 'csrf_token' , function ( $ action = null ) use ( & $ this_instance ) { return $ this_instance -> csrf -> getToken ( $ action ) ; } , array ( 'is_safe' => array ( 'html' ) ) ) ) ; $ twig -> addFunction ( new \ Twig_SimpleFunction ( 'csrf_field' , function ( $ action = null ) use ( & $ this_instance ) { return '<input type="hidden" name="csrf_token" value="' . $ this_instance -> csrf -> getToken ( $ action ) . '">' ; } , array ( 'is_safe' => array ( 'html' ) ) ) ) ; }
4935	private function triggerEvent ( $ name , EntityInterface $ entity ) { $ params = $ this -> options ; $ params [ 'entity' ] = $ entity ; $ params [ 'repositories' ] = $ this -> repositories ; $ event = $ this -> entityEraserEvents -> getEvent ( $ name , $ this , $ params ) ; $ this -> entityEraserEvents -> triggerEvent ( $ event ) ; $ dependencies = $ event -> getDependencyResultCollection ( ) ; return $ dependencies ; }
11623	public function close ( ) { if ( $ this -> id == null ) { throw new InternalException ( 'Session not loaded' ) ; } if ( ! $ this -> cli ) { session_write_close ( ) ; } $ this -> id = null ; }
10711	public function getManyByIds ( array $ ids , $ columns = [ '*' ] ) { $ results = $ this -> getQuery ( ) -> findMany ( $ ids , $ columns ) ; return $ this -> returnResults ( $ results ) ; }
11158	protected function getVideoId ( $ url ) { $ logger = $ this -> getLogger ( ) ; $ parsed = parse_url ( $ url ) ; $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'parsed' => $ parsed ) ) ; switch ( $ parsed [ 'host' ] ) { case 'youtu.be' : return ltrim ( $ parsed [ 'path' ] , '/' ) ; case 'www.youtube.com' : case 'youtube.com' : if ( ! empty ( $ parsed [ 'query' ] ) ) { parse_str ( $ parsed [ 'query' ] , $ query ) ; $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'query' => $ query ) ) ; if ( ! empty ( $ query [ 'v' ] ) ) { return $ query [ 'v' ] ; } } elseif ( isset ( $ parsed [ 'path' ] ) && substr ( $ parsed [ 'path' ] , 0 , 7 ) == '/embed/' ) { $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'path' => $ parsed [ 'path' ] ) ) ; $ vId = substr ( $ parsed [ 'path' ] , 7 ) ; if ( ! empty ( $ vId ) ) { return $ vId ; } } } return null ; }
8869	public function attach ( Runner $ runner ) { if ( $ this -> runners -> contains ( $ runner ) ) { throw new LogicException ( 'Can\'t attach already attached runner.' ) ; } $ this -> runners -> attach ( $ runner ) ; return $ this ; }
1298	public function getReferences ( Query $ query = null ) : ResourceArray { $ query = $ query ? : new Query ( ) ; $ query -> linksToEntry ( $ this -> getId ( ) ) ; return $ this -> client -> getEntries ( $ query ) ; }
12970	private function getReflectionAndClassObject ( ) { if ( $ this -> isCalledAfterOn ) { $ this -> isCalledAfterOn = false ; $ classObj = $ this -> classObjOn ; $ reflection = $ this -> reflectionOn ; unset ( $ this -> classObjOn ) ; unset ( $ this -> reflectionOn ) ; return [ $ reflection , $ classObj ] ; } return [ $ this -> reflection , $ this -> classObj ] ; }
6574	private function isSessionValid ( SessionDataHolder $ session , ServerRequestInterface $ request ) : bool { if ( ( $ lastReq = $ session -> getLastRequestTime ( ) ) && ( $ lastReq + $ this -> getExpire ( ) * 60 ) < time ( ) ) { return false ; } if ( $ this -> getValidateClientIp ( ) && ( $ clientIp = $ session -> getClientIp ( ) ) && isset ( $ request -> getServerParams ( ) [ 'REMOTE_ADDR' ] ) && $ clientIp != $ request -> getServerParams ( ) [ 'REMOTE_ADDR' ] ) { return false ; } return true ; }
12312	private function writeToWebDir ( $ file , $ contents ) { if ( ! $ this -> webDir ) { return ; } if ( ! is_writable ( $ this -> webDir ) ) { trigger_error ( sprintf ( 'Directory %s is not writeable' , $ this -> webDir ) ) ; return ; } $ destFile = $ this -> webDir . $ file ; $ destDir = dirname ( $ destFile ) ; if ( ! is_dir ( $ destDir ) ) { mkdir ( $ destDir , 0777 , true ) ; } file_put_contents ( $ destFile , $ contents ) ; }
4079	protected function buildInputScreen ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; $ inputScreen = $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] ; if ( ! is_object ( $ inputScreen ) ) { $ inputScreen = $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] = new InputScreen ( $ this -> container , $ inputScreen [ 'row' ] , $ inputScreen [ 'properties' ] , $ inputScreen [ 'conditions' ] , $ inputScreen [ 'groupSort' ] ) ; } return $ inputScreen ; }
6456	public function selectable ( ) { $ this -> restrictElements ( [ 'select' => [ ] ] ) ; $ data = [ $ this -> value , $ this -> element -> find ( 'xpath' , "//option[@value='$this->value']" ) -> getText ( ) ] ; self :: debug ( [ 'Expected: %s' , 'Value: %s' , 'Tag: %s' , ] , [ $ this -> expected , implode ( ' => ' , $ data ) , $ this -> tag , ] ) ; $ this -> assert ( in_array ( $ this -> expected , $ data ) , 'selected' ) ; }
2668	public function getAuthDictionary ( $ version ) { $ name = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> getSingleDictionary ( $ version , $ name ) ; return $ dictionary ; }
11042	function store_text ( & $ elts , & $ i , $ ptype , $ ntext , $ ctext ) { if ( $ ntext == 1 && $ ptype != _ETS_ROOT ) { $ elts [ _ETS_TEXT . ':' . $ i ] = $ ctext ; } }
2739	private function uploadVcl ( $ activate ) { try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'priority' => 50 , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_pass' , 'statement' => 'req.http.x-pass' , 'type' => 'REQUEST' , 'priority' => 90 ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ request = [ 'action' => 'pass' , 'max_stale_age' => 3600 , 'name' => Config :: FASTLY_MAGENTO_MODULE . '_request' , 'request_condition' => $ createCondition -> name , 'service_id' => $ service -> id , 'version' => $ currActiveVersion ] ; $ this -> api -> createRequest ( $ clone -> number , $ request ) ; $ this -> api -> validateServiceVersion ( $ clone -> number ) ; $ msg = 'Successfully uploaded VCL. ' ; if ( $ activate ) { $ this -> api -> activateVersion ( $ clone -> number ) ; $ msg .= 'Activated Version ' . $ clone -> number ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Upload VCL has been initiated and activated in version ' . $ clone -> number . '*' ) ; } $ this -> output -> writeln ( '<info>' . $ msg . '</info>' , OutputInterface :: OUTPUT_NORMAL ) ; } catch ( \ Exception $ e ) { $ msg = $ e -> getMessage ( ) ; $ this -> output -> writeln ( "<error>$msg</error>" , OutputInterface :: OUTPUT_NORMAL ) ; return ; } }
9780	private function getLength ( $ value ) : int { if ( is_array ( $ value ) || $ value instanceof \ Countable ) return count ( $ value ) ; if ( $ value instanceof \ Traversable ) return iterator_count ( $ value ) ; if ( is_string ( $ value ) ) return mb_strlen ( $ value ) ; throw new \ InvalidArgumentException ( "The specified value is not iterable: $value" ) ; }
3680	private function injectChildTables ( & $ localMenu ) { $ parented = $ this -> viewCombination -> getParented ( ) ; $ lastCount = count ( $ parented ) ; while ( $ parented ) { foreach ( $ parented as $ metaModelName => $ child ) { foreach ( $ localMenu as $ groupName => $ modules ) { foreach ( $ modules as $ moduleName => $ module ) { if ( isset ( $ module [ 'tables' ] ) && in_array ( $ child [ 'meta' ] [ 'ptable' ] , $ module [ 'tables' ] ) ) { $ localMenu [ $ groupName ] [ $ moduleName ] [ 'tables' ] [ ] = $ metaModelName ; unset ( $ parented [ $ metaModelName ] ) ; break ; } } } } if ( count ( $ parented ) == $ lastCount ) { break ; } $ lastCount = count ( $ parented ) ; } }
11195	public function asArray ( ) { $ result = array ( ) ; foreach ( $ this -> collection as $ response ) { $ result [ ] = $ response -> getResultAsArray ( ) ; } return $ result ; }
9380	protected function retrieve ( array $ routes , $ uri ) { $ routes = array_values ( array_filter ( $ routes ) ) ; if ( empty ( $ routes ) ) { $ message = 'Route "' . $ uri . '" not found' ; throw new \ UnexpectedValueException ( $ message ) ; } $ route = current ( $ routes ) ; $ route [ 1 ] = ( count ( $ route [ 1 ] ) > 0 ) ? array_combine ( $ route [ 3 ] , $ route [ 1 ] ) : $ route [ 1 ] ; return $ route ; }
5171	private function getAvailableRatios ( ) : array { return [ self :: RATIO_SQUARE , self :: RATIO_RECTANGLE , self :: RATIO_HEADLINE , self :: RATIO_VERTICAL , self :: RATIO_COVER , ] ; }
9228	public function put ( $ path , $ data = array ( ) , $ headers = array ( ) ) { return $ this -> postprocessResponse ( parent :: put ( $ path , $ this -> preprocessData ( $ data ) , $ headers ) ) ; }
4248	public function onOutput ( Event $ event ) { $ this -> outputEvent = $ event ; $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-Protocol-1' , 'http://meta.wildfirehq.org/Protocol/JsonStream/0.2' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Plugin-1' , 'http://meta.firephp.org/Wildfire/Plugin/FirePHP/Library-FirePHPCore/' . self :: FIREPHP_PROTO_VER ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Structure-1' , 'http://meta.firephp.org/Wildfire/Structure/FirePHP/FirebugConsole/0.1' ) ; $ heading = isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ; $ this -> processLogEntryWEvent ( 'groupCollapsed' , array ( 'PHP: ' . $ heading ) ) ; $ this -> processAlerts ( ) ; $ this -> processSummary ( ) ; $ this -> processLog ( ) ; $ this -> processLogEntryWEvent ( 'groupEnd' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Index' , $ this -> messageIndex ) ; $ this -> data = array ( ) ; return ; }
6127	public function setExpireDate ( $ expireDate ) { if ( $ expireDate instanceof DateTime ) { $ this -> expireDate = $ expireDate ; } else { try { $ this -> expireDate = new DateTime ( $ expireDate ) ; } catch ( \ Exception $ e ) { $ this -> expireDate = null ; } } return $ this ; }
457	public function dropUnique ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
12871	public function search ( string $ sFilter , array $ aAttributes ) { return ldap_search ( $ this -> _rConnect , $ this -> _sBase , $ sFilter , $ aAttributes ) ; }
1572	public function getProcess ( ) : ? AsynchronousProcess { $ process = $ this -> parameter ( ResourceRegistrar :: PARAM_PROCESS_ID ) ; return ( $ process instanceof AsynchronousProcess ) ? $ process : null ; }
11312	public static function buildAuthString ( array $ data ) { $ str = array ( ) ; foreach ( $ data as $ k => $ v ) { $ str [ ] = self :: urlEncode ( $ k ) . '="' . self :: urlEncode ( $ v ) . '"' ; } return implode ( ', ' , $ str ) ; }
116	public function executeLocal ( $ command , $ path , $ cwd = null , $ verbose = false ) { return $ this -> executeWithAuthRetry ( $ command , $ cwd , '' , $ path , $ verbose ) ; }
11324	public static function convertCase ( $ string , $ toCase ) { $ str = strtolower ( ltrim ( preg_replace ( [ '/[A-Z]/' , '/[_]/' ] , [ ' $0' , ' ' ] , $ string ) ) ) ; switch ( strtoupper ( $ toCase ) ) { case 'PASCAL' : return str_replace ( ' ' , '' , ucwords ( $ str ) ) ; case 'CAMEL' : return lcfirst ( str_replace ( ' ' , '' , ucwords ( $ str ) ) ) ; default : return str_replace ( ' ' , '_' , $ str ) ; } }
1421	protected function createBelongsToIdentity ( Model $ model , $ relationshipKey ) { $ relation = $ model -> { $ relationshipKey } ( ) ; if ( ! $ relation instanceof BelongsTo ) { throw new RuntimeException ( sprintf ( 'Expecting %s on %s to be a belongs-to relationship.' , $ relationshipKey , get_class ( $ model ) ) ) ; } $ foreignKey = method_exists ( $ relation , 'getForeignKeyName' ) ? $ relation -> getForeignKeyName ( ) : $ relation -> getForeignKey ( ) ; $ id = $ model -> { $ foreignKey } ; if ( is_null ( $ id ) ) { return null ; } $ ownerKey = method_exists ( $ relation , 'getOwnerKeyName' ) ? $ relation -> getOwnerKeyName ( ) : $ relation -> getOwnerKey ( ) ; $ related = $ relation -> getRelated ( ) -> replicate ( ) ; $ related -> { $ ownerKey } = $ id ; return $ related ; }
158	public function andFilterCompare ( $ name , $ value , $ defaultOperator = '=' ) { if ( preg_match ( '/^(<>|>=|>|<=|<|=)/' , $ value , $ matches ) ) { $ operator = $ matches [ 1 ] ; $ value = substr ( $ value , strlen ( $ operator ) ) ; } else { $ operator = $ defaultOperator ; } return $ this -> andFilterWhere ( [ $ operator , $ name , $ value ] ) ; }
6944	protected function registerClassInstanceSingleton ( $ singletonName , $ classNameOrInstance = null ) { if ( empty ( $ classNameOrInstance ) ) { $ classNameOrInstance = $ singletonName ; } $ this -> app -> singleton ( $ singletonName , function ( ) use ( $ classNameOrInstance ) { return is_string ( $ classNameOrInstance ) ? $ classNameOrInstance :: getInstance ( ) : $ classNameOrInstance ; } ) ; }
7377	public function fetchFloat ( string $ key , float $ default = 0.0 , int $ precision = 2 ) : float { return round ( floatval ( $ this -> fetch ( $ key , $ default ) ) , $ precision ) ; }
12021	private function generateParameterSetBlock ( $ indent , \ ArtaxServiceBuilder \ Parameter $ operationParameter ) { switch ( $ operationParameter -> getLocation ( ) ) { case 'absoluteURL' : { return $ indent . '$url = $value;' . PHP_EOL ; break ; } case 'postField' : { return sprintf ( $ indent . '$formBody->addField(\'%s\', $value);' . PHP_EOL , $ operationParameter -> getSentAs ( ) ) ; } case 'postFile' : { return sprintf ( $ indent . '$formBody->addFileField(\'%s\', $value);' . PHP_EOL , $ operationParameter -> getSentAs ( ) ) ; break ; } case 'json' : { return sprintf ( $ indent . '$jsonParams[\'%s\'] = $value;' . PHP_EOL , $ operationParameter -> getSentAs ( ) ) ; } case ( 'header' ) : { return sprintf ( $ indent . '$request->setHeader(\'%s\', $value);' . PHP_EOL , $ operationParameter -> getSentAs ( ) , $ operationParameter -> getName ( ) ) ; } default : case 'query' : { return sprintf ( $ indent . '$queryParameters[\'%s\'] = $value;' . PHP_EOL , $ operationParameter -> getSentAs ( ) , $ operationParameter -> getName ( ) ) ; } } }
11802	public static function import ( $ name ) { $ importPath = FOREVERPHP_ROOT . DS . $ name . '.php' ; if ( file_exists ( $ importPath ) ) { include_once $ importPath ; } else { throw new SetupException ( "The object to import ($name) not exists." ) ; } }
8422	public function addNoticeBoardItem ( ProductionMenuCollectionEvent $ event ) : void { $ menu = $ event -> getMenu ( ) ; $ group = $ event -> getGroup ( ) ; $ board = $ this -> factory -> createItem ( 'menu_item.notice_board' , [ 'route' => 'bkstg_board_show' , 'routeParameters' => [ 'production_slug' => $ group -> getSlug ( ) ] , 'extras' => [ 'icon' => 'comment' , 'translation_domain' => BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN , ] , ] ) ; $ menu -> addChild ( $ board ) ; if ( $ this -> auth -> isGranted ( 'GROUP_ROLE_EDITOR' , $ group ) ) { $ posts = $ this -> factory -> createItem ( 'menu_item.notice_board_posts' , [ 'route' => 'bkstg_board_show' , 'routeParameters' => [ 'production_slug' => $ group -> getSlug ( ) ] , 'extras' => [ 'translation_domain' => BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ] , ] ) ; $ board -> addChild ( $ posts ) ; $ archive = $ this -> factory -> createItem ( 'menu_item.notice_board_archive' , [ 'route' => 'bkstg_board_archive' , 'routeParameters' => [ 'production_slug' => $ group -> getSlug ( ) ] , 'extras' => [ 'translation_domain' => BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ] , ] ) ; $ board -> addChild ( $ archive ) ; } }
7948	public function getPppLoginByMail ( $ id ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; try { $ this -> post ( 'xdsl/' . $ id . '/requestPPPLoginMail' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return ; }
2746	public function isImageOptimizationPixelRatioEnabled ( ) { if ( $ this -> isImageOptimizationEnabled ( ) !== true ) { return false ; } return $ this -> _scopeConfig -> isSetFlag ( self :: XML_FASTLY_IMAGE_OPTIMIZATIONS_PIXEL_RATIO ) ; }
12387	private static function showErrors ( ) { if ( count ( static :: $ errors ) > 0 ) { $ errorsList = '' ; foreach ( static :: $ errors as $ error ) { $ errorsList .= 'Tipo: ' . $ error [ 'type' ] . '<br>' ; $ errorsList .= 'Mensaje: ' . $ error [ 'message' ] . '<br>' ; $ errorsList .= 'Archivo: ' . $ error [ 'file' ] . '<br>' ; $ errorsList .= 'Line: ' . $ error [ 'line' ] . '<br><br>' ; } static :: viewException ( 1 , $ errorsList ) ; } }
5885	protected function renderDropdown ( ) { $ config = $ this -> dropdown ; $ config [ 'clientOptions' ] = false ; $ config [ 'view' ] = $ this -> getView ( ) ; return Dropdown :: widget ( $ config ) ; }
12580	public function previewVideoByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_VIDEO , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
3471	public function merge ( Config $ config ) : Config { $ this -> config = array_merge_recursive ( $ this -> config , $ config -> config ) ; return $ this ; }
2213	public function first ( ) { $ this -> intIndex = 0 ; $ this -> blnDone = false ; $ this -> arrCache = $ this -> resultSet [ $ this -> intIndex ] ; return $ this ; }
1311	public function checkSignature ( Request $ request , Consumer $ consumer , Token $ token , $ signature ) { $ built = $ this -> buildSignature ( $ request , $ consumer , $ token ) ; if ( strlen ( $ built ) == 0 || strlen ( $ signature ) == 0 ) { return false ; } if ( strlen ( $ built ) != strlen ( $ signature ) ) { return false ; } $ result = 0 ; for ( $ i = 0 ; $ i < strlen ( $ signature ) ; $ i ++ ) { $ result |= ord ( $ built { $ i } ) ^ ord ( $ signature { $ i } ) ; } return $ result == 0 ; }
11685	public function getCachePath ( ) { if ( empty ( $ this -> basePath ) ) { return false ; } $ cachePath = $ this -> basePath . DIRECTORY_SEPARATOR . 'cache' ; if ( ! is_dir ( $ cachePath ) ) { @ mkdir ( $ cachePath , 0777 , true ) ; } if ( ! is_dir ( $ cachePath ) ) { return false ; } return $ cachePath ; }
11701	public function get ( $ component ) { $ parts = explode ( '.' , $ component ) ; if ( count ( $ parts ) == 1 ) { return $ this -> getService ( $ parts [ 0 ] ) ; } elseif ( count ( $ parts ) == 2 ) { return $ this -> getService ( $ parts [ 0 ] ) -> getGroup ( $ parts [ 1 ] ) ; } elseif ( count ( $ parts ) == 3 ) { return $ this -> getService ( $ parts [ 0 ] ) -> getGroup ( $ parts [ 1 ] ) -> getAction ( $ parts [ 2 ] ) ; } throw new \ LogicException ( 'Malformed component path. Please use a dot-notated path (e.g. service.group.action)' ) ; }
6506	public function serializeReturnValue ( $ type , $ value ) { $ jobType = $ this -> registry -> get ( $ type ) ; return $ this -> serializer -> serialize ( $ value , 'json' , $ this -> getResponseSerializationContext ( $ jobType ) ) ; }
2890	public function onModelLoad ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ model = $ observer -> getData ( 'object' ) ; $ this -> getRequestInfo ( ) -> addModel ( $ model ) ; }
11765	public function remove ( ExpressionContract $ e ) { unset ( $ this -> expressions [ $ this -> indexOf ( $ e ) ] ) ; $ this -> expressions = array_values ( $ this -> expressions ) ; return $ this ; }
11491	public function getAll ( ) : array { $ res = [ ] ; foreach ( $ this -> getKeys ( ) as $ key ) { $ res [ $ key ] = $ this -> get ( $ key ) ; } return $ res ; }
9084	public function add ( string $ id , $ concrete = null , bool $ shared = null ) : DefinitionInterface { if ( is_string ( $ concrete ) && class_exists ( $ concrete ) ) { $ this -> alias ( $ concrete , $ id ) ; } $ concrete = $ concrete ?? $ id ; $ shared = $ shared ?? $ this -> defaultToShared ; if ( ! $ concrete instanceof DefinitionInterface ) { $ concrete = new Definition ( $ id , $ concrete ) ; } $ this -> definitions [ $ id ] = $ concrete -> setAlias ( $ id ) -> setShared ( $ shared ) ; return $ concrete ; }
5500	protected function replaceWildcards ( $ args ) { if ( $ args === false ) { return false ; } for ( $ i = 0 ; $ i < count ( $ args ) ; $ i ++ ) { if ( $ args [ $ i ] === $ this -> wildcard ) { $ args [ $ i ] = new AnythingExpectation ( ) ; } } return $ args ; }
2970	private function doSend ( MessageInterface $ message ) { $ content = $ this -> format ( $ message ) ; $ headers = $ this -> getHeaders ( ) ; $ files = $ this -> getFiles ( $ message ) ; if ( ! empty ( $ files ) ) { parse_str ( $ content , $ fields ) ; $ builder = new MultipartStreamBuilder ( ) ; foreach ( $ fields as $ name => $ value ) { if ( is_array ( $ value ) ) { foreach ( $ value as $ c ) { $ builder -> addResource ( $ name . '[]' , $ c ) ; } continue ; } $ builder -> addResource ( $ name , $ value ) ; } foreach ( $ files as $ key => $ items ) { foreach ( $ items as $ name => $ path ) { $ options = [ ] ; if ( ! is_numeric ( $ name ) ) { $ options [ 'filename' ] = $ name ; } $ value = fopen ( $ path , 'r' ) ; $ builder -> addResource ( $ key , $ value , $ options ) ; } } $ content = $ builder -> build ( ) ; $ headers [ 'Content-Type' ] = 'multipart/form-data; boundary="' . $ builder -> getBoundary ( ) . '"' ; } $ request = $ this -> getMessageFactory ( ) -> createRequest ( 'POST' , $ this -> getEndpoint ( ) , $ headers , $ content ) ; return $ this -> getHttpClient ( ) -> sendRequest ( $ request ) ; }
41	public static function checkCertificateHost ( $ certificate , $ hostname , & $ cn = null ) { $ names = self :: getCertificateNames ( $ certificate ) ; if ( empty ( $ names ) ) { return false ; } $ combinedNames = array_merge ( $ names [ 'san' ] , array ( $ names [ 'cn' ] ) ) ; $ hostname = strtolower ( $ hostname ) ; foreach ( $ combinedNames as $ certName ) { $ matcher = self :: certNameMatcher ( $ certName ) ; if ( $ matcher && $ matcher ( $ hostname ) ) { $ cn = $ names [ 'cn' ] ; return true ; } } return false ; }
6438	public function completeLogin ( $ extrainputs = array ( ) ) { $ request_token = [ ] ; $ request_token [ 'oauth_token' ] = $ this -> request_token [ 'oauth_token' ] ; $ request_token [ 'oauth_token_secret' ] = $ this -> request_token [ 'oauth_token_secret' ] ; $ this -> logQ ( 'session token ' . print_r ( $ request_token , true ) , 'twitter' ) ; $ this -> logQ ( 'extra options ' . print_r ( $ extrainputs , true ) , 'twitter' ) ; if ( isset ( $ extrainputs [ 'oauth_token' ] ) && $ request_token [ 'oauth_token' ] !== $ extrainputs [ 'oauth_token' ] ) { throw new \ Exception ( 'Twitter oauth. Somethign went wrong. No token in the session' ) ; } $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] , $ request_token [ 'oauth_token' ] , $ request_token [ 'oauth_token_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ access_token = $ connection -> oauth ( "oauth/access_token" , array ( "oauth_verifier" => $ extrainputs [ 'oauth_verifier' ] ) ) ; $ this -> access_token = $ access_token ; return $ this -> getUserProfile ( ) ; }
12081	public function deleteChild ( $ idParent , FilterRequest $ filters , $ idChild , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> deleteChild ( $ idParent , $ relation , $ idChild ) ; if ( $ resource == null ) { } return $ this -> success ( ) ; }
1529	public function route ( ) : RouteRegistration { $ route = new RouteRegistration ( $ this -> router , $ this , $ this -> defaults ) ; $ route -> controller ( $ this -> options [ 'controller' ] ?? '' ) ; return $ route ; }
2331	public function fetchEach ( $ strKey ) { $ this -> reset ( ) ; $ return = array ( ) ; while ( $ this -> next ( ) ) { $ strPk = $ this -> current ( ) -> getPk ( ) ; if ( $ strKey != 'id' && isset ( $ this -> $ strPk ) ) { $ return [ $ this -> $ strPk ] = $ this -> $ strKey ; } else { $ return [ ] = $ this -> $ strKey ; } } return $ return ; }
3969	protected function deleteConditionSettings ( PreDeleteModelEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ model = $ event -> getModel ( ) ; $ dataProvider = $ environment -> getDataProvider ( 'tl_metamodel_dcasetting_condition' ) ; $ conditions = $ dataProvider -> fetchAll ( $ dataProvider -> getEmptyConfig ( ) -> setFilter ( [ [ 'operation' => '=' , 'property' => 'attr_id' , 'value' => $ model -> getId ( ) ] ] ) ) ; if ( $ conditions -> count ( ) < 1 ) { return ; } $ conditionsGeneral = new \ DC_General ( $ dataProvider -> getEmptyModel ( ) -> getProviderName ( ) ) ; $ conditionsEnvironment = $ conditionsGeneral -> getEnvironment ( ) ; $ conditionsDataDefinition = $ conditionsEnvironment -> getDataDefinition ( ) ; $ conditionsPalettesDefinition = $ conditionsDataDefinition -> getPalettesDefinition ( ) ; $ conditionsIterator = $ conditions -> getIterator ( ) ; while ( $ currentCondition = $ conditionsIterator -> current ( ) ) { $ conditionPalette = $ conditionsPalettesDefinition -> getPaletteByName ( $ currentCondition -> getProperty ( 'type' ) ) ; $ conditionProperties = $ conditionPalette -> getVisibleProperties ( $ currentCondition ) ; foreach ( $ conditionProperties as $ conditionProperty ) { if ( $ conditionProperty -> getName ( ) !== 'attr_id' ) { continue ; } $ dataProvider -> delete ( $ currentCondition ) ; } $ conditionsIterator -> next ( ) ; } }
5798	public function routeIndex ( Request $ request , Response $ response , $ args ) { $ this -> tableName = $ args [ ROUTEARG_DATABASE_TABLE_NAME ] ; $ this -> tableMapper = new TableMapper ( $ this -> tableName ) ; parent :: __construct ( $ this -> container , $ this -> tableMapper , ROUTEPREFIX_ROLES ) ; return $ this -> indexView ( $ response ) ; }
7615	private function encodeBearer ( $ consumer_key , $ consumer_secret ) { $ consumer_key = rawurlencode ( $ consumer_key ) ; $ consumer_secret = rawurlencode ( $ consumer_secret ) ; return base64_encode ( $ consumer_key . ':' . $ consumer_secret ) ; }
3104	public function save ( ) { $ storage = $ this -> getStorage ( ) ; if ( $ storage ) { $ success = $ storage -> set ( $ this -> userId , $ this -> getStorageKey ( ) , json_encode ( $ this -> state ) ) ; } else { $ success = false ; } return $ success ; }
12060	public function getTargetLabel ( ) { if ( ! isset ( $ this -> labels [ $ this -> target ] ) ) { return [ 'long' => 'unknown' , 'short' => 'unknown' ] ; } return $ this -> labels [ $ this -> target ] ; }
2085	public static function addFiles ( $ files ) { foreach ( $ files as $ name => $ file ) { self :: addFile ( $ name , $ file ) ; } }
12261	private function _cacheCustomFieldsGroup ( CustomFieldsGroup $ group ) { foreach ( $ group -> getCustomFields ( ) as $ field ) { $ this -> cache [ $ group -> getEntity ( ) ] [ $ field -> getSlug ( ) ] = $ field ; } }
12018	protected function setup ( \ AMQPQueue $ queue ) { $ queue -> declareQueue ( ) ; foreach ( $ this -> binds as $ exchange => $ params ) { $ queue -> bind ( $ exchange , $ params [ 'routing_key' ] , $ params [ 'arguments' ] ) ; } }
501	protected function getHeaderCheckBoxName ( ) { $ name = $ this -> name ; if ( substr_compare ( $ name , '[]' , - 2 , 2 ) === 0 ) { $ name = substr ( $ name , 0 , - 2 ) ; } if ( substr_compare ( $ name , ']' , - 1 , 1 ) === 0 ) { $ name = substr ( $ name , 0 , - 1 ) . '_all]' ; } else { $ name .= '_all' ; } return $ name ; }
489	protected function findTableConstraints ( $ table , $ type ) { $ keyColumnUsageTableName = 'INFORMATION_SCHEMA.KEY_COLUMN_USAGE' ; $ tableConstraintsTableName = 'INFORMATION_SCHEMA.TABLE_CONSTRAINTS' ; if ( $ table -> catalogName !== null ) { $ keyColumnUsageTableName = $ table -> catalogName . '.' . $ keyColumnUsageTableName ; $ tableConstraintsTableName = $ table -> catalogName . '.' . $ tableConstraintsTableName ; } $ keyColumnUsageTableName = $ this -> quoteTableName ( $ keyColumnUsageTableName ) ; $ tableConstraintsTableName = $ this -> quoteTableName ( $ tableConstraintsTableName ) ; $ sql = <<<SQLSELECT [kcu].[constraint_name] AS [index_name], [kcu].[column_name] AS [field_name]FROM {$keyColumnUsageTableName} AS [kcu]LEFT JOIN {$tableConstraintsTableName} AS [tc] ON [kcu].[table_schema] = [tc].[table_schema] AND [kcu].[table_name] = [tc].[table_name] AND [kcu].[constraint_name] = [tc].[constraint_name]WHERE [tc].[constraint_type] = :type AND [kcu].[table_name] = :tableName AND [kcu].[table_schema] = :schemaNameSQL ; return $ this -> db -> createCommand ( $ sql , [ ':tableName' => $ table -> name , ':schemaName' => $ table -> schemaName , ':type' => $ type , ] ) -> queryAll ( ) ; }
7382	public static function toInsert ( $ input , array $ include = [ ] ) { if ( is_object ( $ input ) ) { if ( method_exists ( $ input , 'toArray' ) ) { $ input = $ input -> toArray ( ) ; } elseif ( $ input instanceof \ Traversable ) { $ input = iterator_to_array ( $ input ) ; } else { $ input = ( array ) $ input ; } } elseif ( ! is_array ( $ input ) ) { throw new InvalidArgumentException ( 'input must be an associative array or traversable object' ) ; } if ( count ( $ include ) ) { $ arr = [ ] ; foreach ( $ include as $ i ) { if ( isset ( $ input [ $ i ] ) ) { $ arr [ $ i ] &= $ input [ $ i ] ; } } } else { $ arr = & $ input ; } $ sqlStrs = [ ] ; foreach ( $ arr as $ k => & $ v ) { $ kEq = '`' . $ k . '` = ' ; switch ( gettype ( $ v ) ) { case 'bool' : case 'boolean' : $ sqlStrs [ ] = $ kEq . ( $ v ? '1' : '0' ) ; break ; case 'int' : case 'integer' : case 'float' : case 'double' : $ sqlStrs [ ] = $ kEq . $ v ; break ; case 'string' : if ( $ v === 'NULL' ) { $ sqlStrs [ ] = $ kEq . 'NULL' ; } else { $ sqlStrs [ ] = $ kEq . '"' . addslashes ( $ v ) . '"' ; } break ; case 'null' : case 'NULL' : $ sqlStrs [ ] = $ kEq . 'NULL' ; break ; case 'object' : if ( $ v instanceof DateTime ) { $ sqlStrs [ ] = $ kEq . '"' . $ v . '"' ; break ; } case 'array' : $ sqlStrs [ ] = $ kEq . '"' . addslashes ( json_encode ( $ v ) ) . '"' ; $ jsonLastErr = json_last_error ( ) ; if ( $ jsonLastErr !== JSON_ERROR_NONE ) { throw new UnexpectedValueException ( json_last_error_msg ( ) , $ jsonLastErr ) ; } break ; default : break ; } } return implode ( ",\n" , $ sqlStrs ) ; }
2736	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ countries = $ this -> countryHelper -> toOptionArray ( ) ; if ( ! $ countries ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Could not fetch list countries.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'countries' => $ countries ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
2543	public function analyzeWithErrCodeAndMsgQueryFixedCat ( SendResult $ response , $ qErr , $ qMsg , $ category ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; $ errorMsgNodeList = $ domXpath -> query ( $ qMsg ) ; if ( $ errorCodeNodeList -> length > 0 || $ errorMsgNodeList -> length > 0 ) { $ analyzeResponse -> status = $ category ; $ errorCode = ( $ errorCodeNodeList -> length > 0 ) ? $ errorCodeNodeList -> item ( 0 ) -> nodeValue : null ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCode , $ this -> makeMessageFromMessagesNodeList ( $ errorMsgNodeList ) ) ; } return $ analyzeResponse ; }
963	public function postProcess ( ) { if ( ! $ this -> shop -> trashed ( ) ) { return ; } $ this -> shop -> restore ( ) ; $ this -> shop -> charges ( ) -> restore ( ) ; $ this -> shop -> save ( ) ; }
4560	public function translate ( Translatable $ model ) { $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ get = 'get' . $ property -> getName ( ) ; $ set = 'set' . $ property -> getName ( ) ; $ values = [ ] ; foreach ( $ model -> getTranslations ( ) as $ translation ) { $ values [ $ translation -> getLocale ( ) ] = $ translation -> $ get ( ) ; } $ model -> $ set ( $ values ) ; } }
7465	public static function createFromUploadedFile ( UploadedFile $ upload , $ uploadPath , $ filename = null ) { if ( ! $ upload -> isValid ( ) ) { throw new UploadException ( sprintf ( 'An error occurred during file upload. Error code: %s' , $ upload -> getError ( ) ) ) ; } elseif ( ( $ uploadPath = realpath ( $ uploadPath . '/' ) ) === false ) { throw new UploadException ( 'An error occurred during file upload. The specified upload path is invalid.' ) ; } if ( ! $ filename ) { $ fullPath = sprintf ( '%s%s%s.%s' , rtrim ( $ uploadPath , DIRECTORY_SEPARATOR ) , DIRECTORY_SEPARATOR , uniqid ( ) , ( $ upload -> getExtension ( ) ? : ( $ upload -> guessExtension ( ) ? : 'file' ) ) ) ; } else { $ fullPath = rtrim ( $ uploadPath , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . $ filename ; } $ file = new self ( $ fullPath , $ upload -> getClientOriginalName ( ) , $ upload -> getMimeType ( ) , $ upload -> getClientSize ( ) , md5_file ( $ upload -> getRealPath ( ) ) ) ; $ file -> _uploadedFile = $ upload ; return $ file ; }
3151	protected function continueInteraction ( RunnerServiceContext $ context ) { $ continue = false ; $ session = $ context -> getTestSession ( ) ; if ( $ session -> isRunning ( ) === true && $ session -> isTimeout ( ) === false ) { $ event = new QtiContinueInteractionEvent ( $ context , $ this ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; TestRunnerUtils :: beginCandidateInteraction ( $ session ) ; $ continue = true ; } else { $ this -> finish ( $ context ) ; } return $ continue ; }
6996	public static function parseApplePriceMatrixAll ( $ file , $ directory = null ) { $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTMLFile ( $ file ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ currencies = array ( ) ; $ currencyElements = $ xpath -> query ( '//table[1]//tr[2]//td[position() > 1]' ) ; foreach ( $ currencyElements as $ currencyElement ) { $ currency = trim ( $ currencyElement -> textContent ) ; if ( 'Euro' == $ currency ) { $ currency = 'EUR' ; } $ currencies [ ] = $ currency ; } if ( ! count ( $ currencies ) ) { throw new \ RuntimeException ( sprintf ( 'Not found currencies in ApplePriceMatrix in file "%s".' , $ file ) ) ; } $ currencies = array_flip ( $ currencies ) ; foreach ( $ currencies as $ currency => $ null ) { $ currencies [ $ currency ] = static :: parseApplePriceMatrix ( $ dom , $ currency , $ directory ) ; } return $ currencies ; }
4643	public function start ( Job $ build ) { foreach ( $ build -> getServices ( ) as $ service ) { try { $ this -> docker -> getImageManager ( ) -> find ( sprintf ( '%s:%s' , $ service -> getRepository ( ) , $ service -> getTag ( ) ) ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) { $ buildStream = $ this -> docker -> getImageManager ( ) -> create ( null , [ 'fromImage' => sprintf ( '%s:%s' , $ service -> getRepository ( ) , $ service -> getTag ( ) ) ] , ImageManager :: FETCH_STREAM ) ; $ buildStream -> onFrame ( $ this -> logger -> getBuildCallback ( ) ) ; $ buildStream -> wait ( ) ; } else { throw $ e ; } } $ serviceConfig = $ service -> getConfig ( ) ; $ containerConfig = new ContainerConfig ( ) ; $ containerConfig -> setImage ( sprintf ( '%s:%s' , $ service -> getRepository ( ) , $ service -> getTag ( ) ) ) ; $ containerConfig -> setLabels ( [ 'com.jolici.container=true' ] ) ; if ( isset ( $ serviceConfig [ 'Env' ] ) ) { $ containerConfig -> setEnv ( $ serviceConfig [ 'Env' ] ) ; } $ containerCreateResult = $ this -> docker -> getContainerManager ( ) -> create ( $ containerConfig ) ; $ this -> docker -> getContainerManager ( ) -> start ( $ containerCreateResult -> getId ( ) ) ; $ service -> setContainer ( $ containerCreateResult -> getId ( ) ) ; } }
9454	protected function doParse ( StringReader $ string ) { $ val = null ; $ type = substr ( $ string -> read ( 2 ) , 0 , 1 ) ; switch ( $ type ) { case 'a' : $ count = ( int ) $ string -> readUntil ( ':' ) ; $ string -> read ( 1 ) ; $ val = [ ] ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ array_key = $ this -> doParse ( $ string ) ; $ array_value = $ this -> doParse ( $ string ) ; $ val [ $ array_key ] = $ array_value ; } $ string -> read ( 1 ) ; break ; case 'O' : $ len = ( int ) $ string -> readUntil ( ':' ) ; $ class = $ string -> read ( 2 + $ len ) ; $ string -> read ( 1 ) ; $ properties = [ '__class_name' => $ class ] ; $ len = ( int ) $ string -> readUntil ( ':' ) ; $ string -> read ( 1 ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ prop_key = $ this -> doParse ( $ string ) ; $ prop_value = $ this -> doParse ( $ string ) ; if ( substr ( $ prop_key , 0 , strlen ( self :: PROTECTED_PREFIX ) ) == self :: PROTECTED_PREFIX ) { $ prop_key = substr ( $ prop_key , strlen ( self :: PROTECTED_PREFIX ) ) ; } if ( substr ( $ prop_key , 0 , 1 ) == "\0" ) { list ( , $ private_class , $ private_property_name ) = explode ( "\0" , $ prop_key ) ; $ prop_key = $ private_property_name ; } $ properties [ $ prop_key ] = $ prop_value ; } $ string -> read ( 1 ) ; $ val = ( object ) $ properties ; break ; case 's' : $ len = ( int ) $ string -> readUntil ( ':' ) ; $ val = $ string -> read ( $ len + 2 ) ; $ string -> read ( 1 ) ; break ; case 'i' : $ val = ( int ) $ string -> readUntil ( ';' ) ; break ; case 'd' : $ val = ( float ) $ string -> readUntil ( ';' ) ; break ; case 'b' : $ bool = $ string -> read ( 2 ) ; $ val = substr ( $ bool , 0 , 1 ) == '1' ; break ; case 'N' : $ val = null ; break ; default : throw new \ Exception ( sprintf ( 'Unable to unserialize type "%s"' , $ type ) ) ; } return $ val ; }
6743	public function supports ( ParamConverter $ configuration ) { return $ configuration -> getClass ( ) && is_a ( $ configuration -> getClass ( ) , $ this -> getClass ( ) , true ) ; }
2863	public function getLogging ( ) { $ logging = array ( ) ; foreach ( $ this -> files as $ logFile ) { $ logging [ $ logFile ] = $ this -> getLoggedContent ( $ logFile ) ; } return $ logging ; }
5625	public function getEncodedRequest ( ) { if ( $ this -> raw ) { $ encoded = $ this -> raw ; } else { $ encoded = $ this -> request -> asUrlRequest ( ) ; } if ( $ encoded ) { return '?' . preg_replace ( '/^\?/' , '' , $ encoded ) ; } return '' ; }
2474	public function bulkIndexContent ( array $ contentObjects ) { $ documents = array ( ) ; foreach ( $ contentObjects as $ content ) { try { $ documents [ ] = $ this -> mapper -> mapContentBlock ( $ content ) ; } catch ( NotFoundException $ ex ) { } } if ( ! empty ( $ documents ) ) { $ this -> gateway -> bulkIndexDocuments ( $ documents ) ; } }
2994	protected function encode ( $ str ) { if ( empty ( $ str ) || $ this -> charset == 'UTF-8' ) return $ str ; if ( extension_loaded ( 'iconv' ) ) $ out = @ iconv ( "UTF-8" , $ this -> charset . "//IGNORE" , $ str ) ; if ( ! isset ( $ out ) || ! $ out ) $ out = extension_loaded ( 'mbstring' ) ? mb_convert_encoding ( $ str , $ this -> charset , "UTF-8" ) : utf8_decode ( $ str ) ; return $ out ? : $ str ; }
6102	public function listPropertyTypes ( $ systemName = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/propertysets/propertytypes' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new PropertyType ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; if ( null !== $ systemName ) { foreach ( $ result as $ entry ) { if ( $ entry -> getSystemName ( ) === $ systemName ) { return $ entry ; } } return null ; } return $ result ; }
9252	protected function initializeContainer ( ) { $ this -> registerDefaultExtensions ( ) ; $ initializer = $ this -> getContainerInitializer ( ) ; $ this -> container = $ initializer -> initializeContainer ( $ this , $ this -> extensions , $ this -> compilerPasses ) ; $ this -> container -> set ( 'app' , $ this ) ; return $ this -> container ; }
11506	public function offsetSet ( $ slot , $ connection ) { if ( ! static :: isValid ( $ slot ) ) { throw new \ OutOfBoundsException ( "Invalid slot $slot for `$connection`" ) ; } $ this -> slots [ ( int ) $ slot ] = ( string ) $ connection ; }
8235	protected function ivalidateToken ( $ index , array & $ tokenStorage ) { unset ( $ tokenStorage [ $ index ] ) ; $ this -> session -> set ( self :: SESSION_KEY , $ tokenStorage ) ; }
8406	private function getModelName ( ) { if ( isset ( $ this -> class ) ) { return $ this -> class ; } if ( isset ( $ this -> model ) ) { $ rClass = new \ ReflectionClass ( $ this -> model ) ; return $ rClass -> getShortName ( ) ; } return 'Icon' ; }
8209	protected function parseArguments ( ) { $ this -> parseConnection ( $ this -> option ( 'connection' ) ) ; if ( $ this -> option ( 'host' ) ) { $ this -> host = $ this -> option ( 'host' ) ; } if ( $ this -> option ( 'port' ) ) { $ this -> port = ( int ) $ this -> option ( 'port' ) ; } $ this -> parseCommandArguments ( ) ; }
10905	public function getList ( $ asStrings = false ) { $ list = scandir ( $ this -> path ) ; if ( $ asStrings === true ) { return array_diff ( $ list , [ "." , ".." ] ) ; } $ ret = [ ] ; foreach ( $ list as $ name ) { if ( $ name === "." || $ name === ".." ) { continue ; } $ path = $ this -> path . DIRECTORY_SEPARATOR . $ name ; $ ret [ ] = ( is_dir ( $ path ) ) ? new static ( $ path ) : new FileEntity ( $ path ) ; } return $ ret ; }
6382	public function readQuestions ( $ quizId ) { $ quizSlots = $ this -> readStoreRecords ( 'quiz_slots' , [ 'quizid' => $ quizId ] ) ; $ questions = [ ] ; foreach ( $ quizSlots as $ index => $ quizSlot ) { try { $ question = $ this -> readStoreRecord ( 'question' , [ 'id' => $ quizSlot -> questionid ] ) ; $ question -> answers = $ this -> readStoreRecords ( 'question_answers' , [ 'question' => $ question -> id ] ) ; $ question -> url = $ this -> cfg -> wwwroot . '/mod/question/question.php?id=' . $ question -> id ; if ( $ question -> qtype == 'numerical' ) { $ question -> numerical = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_numerical' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_numerical_options' , [ 'question' => $ question -> id ] ) , 'units' => $ this -> readStoreRecords ( 'question_numerical_units' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'match' ) { $ question -> match = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_match_options' , [ 'questionid' => $ question -> id ] ) , 'subquestions' => $ this -> readStoreRecords ( 'qtype_match_subquestions' , [ 'questionid' => $ question -> id ] ) ] ; } else if ( strpos ( $ question -> qtype , 'calculated' ) === 0 ) { $ question -> calculated = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_calculated' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_calculated_options' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'shortanswer' ) { $ question -> shortanswer = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_shortanswer_options' , [ 'questionid' => $ question -> id ] ) ] ; } $ questions [ $ question -> id ] = $ question ; } catch ( \ Exception $ e ) { } } return $ questions ; }
4139	protected function getOauthParameters ( ) { $ time = time ( ) ; return array ( 'oauth_consumer_key' => $ this -> getConsumerKey ( ) , 'oauth_nonce' => trim ( base64_encode ( $ time ) , '=' ) , 'oauth_signature_method' => 'HMAC-SHA1' , 'oauth_timestamp' => $ time , 'oauth_token' => $ this -> getAccessToken ( ) , 'oauth_version' => '1.0' ) ; }
3259	public function placeTransaction ( $ gateway , $ transactionId , $ detail = null , $ token = null ) { return call_user_func ( Config :: get ( 'shop.transaction' ) . '::create' , [ 'order_id' => $ this -> attributes [ 'id' ] , 'gateway' => $ gateway , 'transaction_id' => $ transactionId , 'detail' => $ detail , 'token' => $ token , ] ) ; }
10347	public function current ( ) { $ minute = current ( $ this -> minutes ) ; $ hour = current ( $ this -> hours ) ; $ monthAndDay = current ( $ this -> monthAndDays ) ; $ currentElement = strtotime ( sprintf ( '%d-%s %02d:%02d:00' , $ this -> year + $ this -> yearOffset , $ monthAndDay , $ hour , $ minute ) ) ; if ( $ currentElement < $ this -> getCurrentTime ( ) ) { $ currentElement = $ this -> getNextFutureTimestamp ( ) ; } return $ currentElement ; }
6412	public static function all ( IteratorAggregate $ iterable , callable $ predicate ) : bool { return Iterators :: all ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ predicate ) ; }
9743	public function setCountry ( $ country ) { if ( ! ( $ country instanceof Country ) ) { $ country = new Country ( $ country ) ; } if ( $ country -> isEmpty ( ) ) { $ this -> invalidArguments ( '10001' ) ; } return $ this -> setParameter ( 'country' , $ country ) ; }
1860	public function rcopy ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; $ this -> mkdir ( $ strDestination ) ; $ arrFiles = scan ( $ this -> strRootDir . '/' . $ strSource , true ) ; foreach ( $ arrFiles as $ strFile ) { if ( is_dir ( $ this -> strRootDir . '/' . $ strSource . '/' . $ strFile ) ) { $ this -> rcopy ( $ strSource . '/' . $ strFile , $ strDestination . '/' . $ strFile ) ; } else { $ this -> copy ( $ strSource . '/' . $ strFile , $ strDestination . '/' . $ strFile ) ; } } }
9098	public function initThemeManager ( ModuleEvent $ e ) { $ moduleManager = $ e -> getTarget ( ) ; $ sm = $ moduleManager -> getEvent ( ) -> getParam ( 'ServiceManager' ) ; $ themManager = $ sm -> get ( 'yimaTheme.Manager' ) ; if ( ! $ themManager instanceof ManagerInterface ) { throw new \ Exception ( sprintf ( 'yimaTheme theme manager most instance of "ManagerInterface" but "%s" given.' , get_class ( $ themManager ) ) ) ; } $ themManager -> init ( ) ; }
165	public static function serialize ( array $ links ) { foreach ( $ links as $ rel => $ link ) { if ( is_array ( $ link ) ) { foreach ( $ link as $ i => $ l ) { $ link [ $ i ] = $ l instanceof self ? array_filter ( ( array ) $ l ) : [ 'href' => $ l ] ; } $ links [ $ rel ] = $ link ; } elseif ( ! $ link instanceof self ) { $ links [ $ rel ] = [ 'href' => $ link ] ; } } return $ links ; }
3771	public function fixupModules ( DataContainer $ dataContainer ) { if ( ! class_exists ( 'tl_user_group' , false ) ) { throw new \ RuntimeException ( 'data container is not loaded!' ) ; } $ original = new \ tl_user_group ( ) ; $ modules = $ original -> getModules ( ) ; foreach ( array_keys ( $ modules ) as $ group ) { foreach ( $ modules [ $ group ] as $ key => $ module ) { if ( strpos ( $ module , 'metamodel_' ) === 0 ) { unset ( $ modules [ $ group ] [ $ key ] ) ; } } $ modules [ $ group ] = array_values ( $ modules [ $ group ] ) ; } $ modules [ 'metamodels' ] [ ] = 'support_metamodels' ; if ( false !== $ index = array_search ( 'metamodels' , $ modules [ 'metamodels' ] , true ) ) { unset ( $ modules [ 'metamodels' ] [ $ index ] ) ; $ modules [ 'metamodels' ] = array_values ( $ modules [ 'metamodels' ] ) ; } $ combinations = $ this -> combinationBuilder -> getCombinationsForUser ( [ $ dataContainer -> activeRecord -> id ] , 'be' ) ; $ screenIds = array_map ( function ( $ combination ) { return $ combination [ 'dca_id' ] ; } , $ combinations [ 'byName' ] ) ; $ screens = $ this -> inputScreens -> fetchInputScreens ( $ screenIds ) ; $ locale = $ this -> requestStack -> getCurrentRequest ( ) -> getLocale ( ) ; foreach ( $ screens as $ metaModel => $ screen ) { if ( 'standalone' === $ screen [ 'meta' ] [ 'rendertype' ] ) { $ modules [ $ screen [ 'meta' ] [ 'backendsection' ] ] [ ] = 'metamodel_' . $ metaModel ; $ this -> buildLanguageString ( 'metamodel_' . $ metaModel , $ screen , $ locale ) ; } } return $ modules ; }
8108	public function getReviewFrom ( ) { $ from = $ this -> owner -> getField ( 'ReviewFrom' ) ; if ( $ from ) { return $ from ; } return Config :: inst ( ) -> get ( Email :: class , 'admin_email' ) ; }
5382	public function setValue ( $ desired ) { $ achieved = array ( ) ; foreach ( $ desired as $ value ) { $ success = false ; for ( $ i = 0 , $ count = count ( $ this -> options ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> options [ $ i ] -> isValue ( $ value ) ) { $ achieved [ ] = $ this -> options [ $ i ] -> getValue ( ) ; $ success = true ; break ; } } if ( ! $ success ) { return false ; } } $ this -> values = $ achieved ; return true ; }
6013	public function listProtocols ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/protocols' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Protocol ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
12585	static function run_convert_configuration ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; $ extname = @ $ args [ 0 ] ; if ( $ extname == '' ) { $ extname = dirname ( __FILE__ ) ; } while ( ! is_file ( "ant/$extname.properties" ) ) { $ extname = pake_input ( 'What is the name of the current extension?' ) ; if ( ! is_file ( "ant/$extname.properties" ) ) { pake_echo ( "File ant/$extname.properties not found" ) ; } } self :: convertPropertyFileToYamlFile ( "ant/$extname.properties" , self :: getConfigDir ( ) . "/options-$extname.yaml" , array ( $ extname => '' , 'external' => 'dependencies' , 'dependency' => 'extensions' , 'repository' => array ( 'svn' , 'url' ) ) , "extension:\n name: $extname\n\n" ) ; foreach ( array ( 'files.to.parse.txt' => 'to_parse' , 'files.to.exclude.txt' => 'to_exclude' ) as $ file => $ option ) { $ src = "ant/$file" ; if ( file_exists ( $ src ) ) { if ( count ( $ in = file ( $ src , FILE_SKIP_EMPTY_LINES | FILE_IGNORE_NEW_LINES ) ) ) { $ in = "\n\nfiles:\n $option: [" . implode ( ', ' , $ in ) . "]\n" ; file_put_contents ( self :: getConfigDir ( ) . "options-$extname.yaml" , $ in , FILE_APPEND ) ; } } } }
3685	protected function optimizedFilter ( $ filterRule , $ children , $ operation ) { $ procedure = new FilterBuilderSql ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ operation , $ this -> connection ) ; $ skipped = $ this -> buildNativeSqlProcedure ( $ procedure , $ children ) ; if ( ! $ procedure -> isEmpty ( ) ) { $ filterRule -> addChild ( $ this -> getMetaModel ( ) -> getEmptyFilter ( ) -> addFilterRule ( $ procedure -> build ( ) ) ) ; } return $ skipped ; }
11370	public static function charAscii ( $ char ) { if ( self :: isAscii ( $ char ) ) { return $ char ; } $ char = htmlentities ( $ char ) ; return $ char ; }
6061	public function listDeploymentSites ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/deployment/sites' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new DeploymentSiteResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5431	protected function onlyParents ( $ interfaces ) { $ parents = array ( ) ; $ blacklist = array ( ) ; foreach ( $ interfaces as $ interface ) { foreach ( $ interfaces as $ possible_parent ) { if ( $ interface -> getName ( ) == $ possible_parent -> getName ( ) ) { continue ; } if ( $ interface -> isSubClassOf ( $ possible_parent ) ) { $ blacklist [ $ possible_parent -> getName ( ) ] = true ; } } if ( ! isset ( $ blacklist [ $ interface -> getName ( ) ] ) ) { $ parents [ ] = $ interface -> getName ( ) ; } } return $ parents ; }
5598	public function add ( $ severity , $ content , $ filename , $ line ) { $ content = str_replace ( '%' , '%%' , $ content ) ; $ this -> testLatestError ( $ severity , $ content , $ filename , $ line ) ; }
11105	public function join ( $ table , $ type = null ) { $ this -> join -> addJoin ( $ table , $ type ) ; return $ this ; }
3431	public function count ( ) { if ( $ this -> queryShouldBeStopped ) { return 0 ; } $ queryType = 'SectionQuery::count' ; $ filter = $ this -> normalizeFilter ( ) ; $ callback = function ( ) use ( $ filter ) { return ( int ) $ this -> bxObject -> getCount ( $ filter ) ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'filter' ) , $ callback ) ; }
4689	public function groupBy ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> group = $ expression === null ? null : [ $ expression ] ; $ this -> args [ 'group' ] = $ args ; return $ this ; }
1172	protected function callProtected ( $ instance , $ method , $ args = [ ] ) { if ( ! ( $ instance instanceof Closure ) ) { $ instance = $ this -> createProtectedCaller ( $ instance ) ; } return call_user_func ( $ instance , $ method , $ args ) ; }
4814	private function createFrom ( $ filepath ) { if ( file_exists ( $ filepath ) ) { $ anyDataSet = XmlUtil :: createXmlDocumentFromFile ( $ filepath ) ; $ this -> collection = array ( ) ; $ rows = $ anyDataSet -> getElementsByTagName ( "row" ) ; foreach ( $ rows as $ row ) { $ sr = new Row ( ) ; $ fields = $ row -> getElementsByTagName ( "field" ) ; foreach ( $ fields as $ field ) { $ attr = $ field -> attributes -> getNamedItem ( "name" ) ; if ( is_null ( $ attr ) ) { throw new \ InvalidArgumentException ( 'Malformed anydataset file ' . basename ( $ filepath ) ) ; } $ sr -> addField ( $ attr -> nodeValue , $ field -> nodeValue ) ; } $ sr -> acceptChanges ( ) ; $ this -> collection [ ] = $ sr ; } $ this -> currentRow = count ( $ this -> collection ) - 1 ; } }
10145	private function makeKey ( $ block , $ valContext ) { $ pwarray = str_repeat ( "\0" , 64 ) ; for ( $ i = 0 ; $ i < 5 ; ++ $ i ) { $ pwarray [ $ i ] = $ valContext [ $ i ] ; } $ pwarray [ 5 ] = chr ( $ block & 0xff ) ; $ pwarray [ 6 ] = chr ( ( $ block >> 8 ) & 0xff ) ; $ pwarray [ 7 ] = chr ( ( $ block >> 16 ) & 0xff ) ; $ pwarray [ 8 ] = chr ( ( $ block >> 24 ) & 0xff ) ; $ pwarray [ 9 ] = "\x80" ; $ pwarray [ 56 ] = "\x48" ; $ md5 = new Xls \ MD5 ( ) ; $ md5 -> add ( $ pwarray ) ; $ s = $ md5 -> getContext ( ) ; return new Xls \ RC4 ( $ s ) ; }
8492	public static function getTotalMemory ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT TotalPhysicalMemory FROM Win32_ComputerSystem" ) as $ mem ) { return $ mem -> TotalPhysicalMemory ; } return NULL ; }
12352	public function allow ( array $ level_select = [ "min" => 4 , "max" => 4 ] ) : bool { if ( $ this -> details !== false ) { if ( is_array ( $ level_select ) === true && isset ( $ level_select [ "min" ] ) === true && isset ( $ level_select [ "max" ] ) === true ) { $ level_select [ "min" ] = Model \ Role :: find ( $ level_select [ "min" ] ) -> priority ; $ level_select [ "max" ] = Model \ Role :: find ( $ level_select [ "max" ] ) -> priority ; $ level_select = [ "min" => $ level_select [ "min" ] , "max" => $ level_select [ "max" ] ] ; } else { return false ; } $ current_priority = $ this -> details -> role -> priority ; if ( is_numeric ( $ level_select [ "min" ] ) === true && is_numeric ( $ level_select [ "max" ] ) === true ) { if ( $ level_select [ "min" ] >= $ current_priority && $ level_select [ "max" ] <= $ current_priority ) { return true ; } else { return false ; } } else { return false ; } } else { return false ; } }
1963	public static function encodeUrl ( $ strUrl ) { if ( $ strUrl == '' ) { return '' ; } if ( $ strUrl == '#' || strncmp ( $ strUrl , '{{' , 2 ) === 0 ) { return $ strUrl ; } if ( strncmp ( $ strUrl , 'mailto:' , 7 ) === 0 ) { return static :: encodeEmail ( $ strUrl ) ; } $ arrUrl = parse_url ( $ strUrl ) ; if ( ! isset ( $ arrUrl [ 'scheme' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Expected a FQDN, got "%s"' , $ strUrl ) ) ; } if ( isset ( $ arrUrl [ 'scheme' ] ) ) { $ arrUrl [ 'scheme' ] .= ( ( substr ( $ strUrl , \ strlen ( $ arrUrl [ 'scheme' ] ) , 3 ) == '://' ) ? '://' : ':' ) ; } if ( isset ( $ arrUrl [ 'user' ] ) ) { $ arrUrl [ 'user' ] .= isset ( $ arrUrl [ 'pass' ] ) ? ':' : '@' ; } if ( isset ( $ arrUrl [ 'pass' ] ) ) { $ arrUrl [ 'pass' ] .= '@' ; } if ( isset ( $ arrUrl [ 'host' ] ) ) { $ arrUrl [ 'host' ] = static :: encode ( $ arrUrl [ 'host' ] ) ; } if ( isset ( $ arrUrl [ 'port' ] ) ) { $ arrUrl [ 'port' ] = ':' . $ arrUrl [ 'port' ] ; } if ( isset ( $ arrUrl [ 'query' ] ) ) { $ arrUrl [ 'query' ] = '?' . $ arrUrl [ 'query' ] ; } if ( isset ( $ arrUrl [ 'fragment' ] ) ) { $ arrUrl [ 'fragment' ] = '#' . $ arrUrl [ 'fragment' ] ; } $ strReturn = '' ; foreach ( array ( 'scheme' , 'user' , 'pass' , 'host' , 'port' , 'path' , 'query' , 'fragment' ) as $ key ) { if ( isset ( $ arrUrl [ $ key ] ) ) { $ strReturn .= $ arrUrl [ $ key ] ; } } return $ strReturn ; }
8223	protected function incrementCounter ( $ actionName , $ blockType , $ entityId , $ config ) { $ this -> storage -> transaction ( $ actionName , $ blockType , RateLimitStorageInterface :: TRANSACTION_BEGIN ) ; $ limit = $ this -> getLimitFor ( $ actionName , $ blockType , $ entityId ) ; $ time = time ( ) ; $ resetCounter = ( $ time > $ limit [ "ts" ] + $ config [ "counterTimeout" ] ) || ( $ limit [ "cnt" ] >= $ config [ "count" ] && $ time > $ limit [ "ts" ] + $ config [ "blockDuration" ] ) ; if ( $ resetCounter ) { $ limit [ "cnt" ] = 0 ; } $ limitBeforeIncrement = $ limit ; if ( $ limit [ "cnt" ] === $ config [ "count" ] - 1 ) { $ this -> logRateLimitReached ( $ actionName , $ blockType , $ entityId , $ config ) ; } ++ $ limit [ "cnt" ] ; $ limit [ "ts" ] = $ time ; if ( $ limit [ "cnt" ] <= $ config [ "count" ] ) { $ this -> storage -> updateLimitFor ( $ actionName , $ blockType , $ entityId , $ limit ) ; if ( rand ( 0 , 100 ) <= $ this -> config [ "cleanupProbability" ] ) { $ this -> storage -> cleanup ( $ actionName , $ blockType , $ config ) ; } $ this -> storage -> save ( $ actionName , $ blockType ) ; } $ this -> storage -> transaction ( $ actionName , $ blockType , RateLimitStorageInterface :: TRANSACTION_END ) ; return $ limitBeforeIncrement ; }
2528	protected function getActionFromWsdl ( $ wsdlFilePath , $ messageName ) { $ wsdlId = $ this -> getWsdlIdFor ( $ messageName ) ; return WsdlAnalyser :: exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , sprintf ( self :: XPATH_OPERATION_ACTION , $ messageName ) ) ; }
3802	private function getOrCreatePaletteDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasDefinition ( PalettesDefinitionInterface :: NAME ) ) { return $ container -> getDefinition ( PalettesDefinitionInterface :: NAME ) ; } $ container -> setDefinition ( PalettesDefinitionInterface :: NAME , $ palettesDefinition = new DefaultPalettesDefinition ( ) ) ; return $ palettesDefinition ; }
7874	private function checkConfig ( ) : void { if ( empty ( $ this -> userkey ) ) { Log :: warning ( 'Config "message.zenziva.userkey" is not defined.' ) ; } if ( empty ( $ this -> passkey ) ) { Log :: warning ( 'Config "message.zenziva.passkey" is not defined.' ) ; } }
2468	public function getOptions ( ) : array { $ options = [ ] ; foreach ( self :: DEFAULT_OPTIONS as $ option => $ label ) { $ options [ $ option ] = $ this -> translator -> trans ( 'MSC.validCharacters.' . $ label , [ ] , 'contao_default' ) ; } $ event = new SlugValidCharactersEvent ( $ options ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: SLUG_VALID_CHARACTERS , $ event ) ; return $ event -> getOptions ( ) ; }
5944	public function categories ( $ categoryIds , $ deploymentSiteIds = null , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/categories/' . $ categoryIds . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
359	function checkUploadMaxFileSize ( $ min = null , $ max = null ) { $ postMaxSize = ini_get ( 'post_max_size' ) ; $ uploadMaxFileSize = ini_get ( 'upload_max_filesize' ) ; if ( $ min !== null ) { $ minCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ min , '>=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ min , '>=' ) ; } else { $ minCheckResult = true ; } if ( $ max !== null ) { $ maxCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ max , '<=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ max , '<=' ) ; } else { $ maxCheckResult = true ; } return ( $ minCheckResult && $ maxCheckResult ) ; }
1645	public function getDistance ( Coordinate $ coordinate , DistanceInterface $ calculator ) : float { return $ calculator -> getDistance ( $ this , $ coordinate ) ; }
4291	private function publishMeta ( ) { $ debugClass = \ get_class ( $ this -> debug ) ; $ metaVals = array ( 'debug_version' => $ debugClass :: VERSION , ) ; $ keys = array ( 'HTTP_HOST' , 'HTTPS' , 'REMOTE_ADDR' , 'REQUEST_METHOD' , 'REQUEST_TIME' , 'REQUEST_URI' , 'SERVER_ADDR' , 'SERVER_NAME' , ) ; foreach ( $ keys as $ k ) { $ metaVals [ $ k ] = isset ( $ _SERVER [ $ k ] ) ? $ _SERVER [ $ k ] : null ; } if ( ! isset ( $ metaVals [ 'REQUEST_URI' ] ) && ! empty ( $ _SERVER [ 'argv' ] ) ) { $ metaVals [ 'REQUEST_URI' ] = '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ; } $ this -> processLogEntry ( 'meta' , array ( $ metaVals , ) , array ( 'channel' => $ this -> debug -> getCfg ( 'channel' ) , ) ) ; }
4319	protected function interpolate ( $ message , array & $ context = array ( ) ) { \ preg_match_all ( '/\{([a-z0-9_.]+)\}/' , $ message , $ matches ) ; $ placeholders = \ array_unique ( $ matches [ 1 ] ) ; $ replace = array ( ) ; foreach ( $ placeholders as $ key ) { if ( ! isset ( $ context [ $ key ] ) ) { continue ; } $ val = $ context [ $ key ] ; if ( ! \ is_array ( $ val ) && ( ! \ is_object ( $ val ) || \ method_exists ( $ val , '__toString' ) ) ) { $ replace [ '{' . $ key . '}' ] = $ val ; } } $ context = \ array_diff_key ( $ context , \ array_flip ( $ placeholders ) ) ; if ( ! $ context ) { $ context = $ this -> debug -> meta ( ) ; } return \ strtr ( $ message , $ replace ) ; }
7797	protected function statementNumber ( $ text ) { if ( $ line = $ this -> getLine ( '60F' , $ text ) ) { if ( preg_match ( '/(C|D)(\d{6})([A-Z]{3})([0-9,]{1,15})/' , $ line , $ match ) ) { return $ match [ 2 ] ; } } return null ; }
6550	public function current ( ) { if ( $ this -> iterator -> valid ( ) === false ) { return null ; } $ iterator = $ this -> iterator -> current ( ) -> getCellIterator ( ) ; $ iterator -> setIterateOnlyExistingCells ( false ) ; $ result = [ ] ; foreach ( $ iterator as $ cell ) { $ result [ ] = $ cell -> getValue ( ) ; } return $ result ; }
12524	public function deserializeJSON ( $ jsonString ) { $ data = json_decode ( $ jsonString ) ; $ this -> setContent ( $ data -> content ) ; $ this -> setContext ( $ data -> context ) ; }
7641	protected function getErrorMessage ( $ response , $ alternativeError = 'Unknown error.' ) { $ xml = $ this -> parseResponse ( $ response ) ; if ( $ xml && $ xml -> Message ) { return "[" . $ response -> getStatusCode ( ) . "] " . ( string ) $ xml -> Message . "\n" . ( string ) $ xml -> AuthenticationErrorDetail ; } else { return $ alternativeError ; } }
11130	protected function matchTemplate ( & $ template , array & $ arguments ) { $ count = substr_count ( $ template , '%s' ) ; $ size = sizeof ( $ arguments ) ; if ( $ count > $ size ) { $ arguments = $ arguments + array_fill ( $ size , $ count - $ size , '' ) ; } else { $ template .= str_repeat ( ' %s' , $ size - $ count ) ; } return $ this ; }
1115	public function getQualifiedScopedColumns ( ) { if ( ! $ this -> isScoped ( ) ) return $ this -> getScopedColumns ( ) ; $ prefix = $ this -> getTable ( ) . '.' ; return array_map ( function ( $ c ) use ( $ prefix ) { return $ prefix . $ c ; } , $ this -> getScopedColumns ( ) ) ; }
6606	public function validateAccessTokenResponse ( $ params ) { if ( ! isset ( $ params [ 'oauth_token' ] ) || ! isset ( $ params [ 'oauth_token_secret' ] ) || empty ( $ params [ 'oauth_token' ] ) || empty ( $ params [ 'oauth_token_secret' ] ) ) { throw new InvalidOAuthTokenException ( 'access token' ) ; } return true ; }
9311	protected function query ( $ uri , $ data = [ ] ) { $ this -> setActionUri ( $ uri ) ; try { $ response = $ this -> client -> get ( $ this -> uri , [ 'query' => $ data ] ) ; } catch ( ClientException $ e ) { $ response = $ e -> getResponse ( ) ; } catch ( ServerException $ e ) { $ response = $ e -> getResponse ( ) ; } return $ this -> responseToJson ( $ response ) ; }
11246	public function getMigrations ( int $ steps ) : array { $ sql = "select migration from {$this->table} where batch >= 1 order by batch, migration desc limit ?" ; $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> bindParam ( 1 , $ steps , PDO :: PARAM_INT ) ; $ stmt -> execute ( ) ; return $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; }
8915	public function encode ( $ value , $ b = 62 ) { $ r = ( int ) $ value % $ b ; $ result = $ this -> base [ $ r ] ; $ q = floor ( ( int ) $ value / $ b ) ; while ( $ q ) { $ r = $ q % $ b ; $ q = floor ( $ q / $ b ) ; $ result = $ this -> base [ $ r ] . $ result ; } return $ result ; }
12304	public function adminIndex ( ) { $ config = [ 'title' => trans ( 'HCLanguages::languages.page_title' ) , 'listURL' => route ( 'admin.api.languages' ) , 'newFormUrl' => route ( 'admin.api.form-manager' , [ 'languages-new' ] ) , 'editFormUrl' => route ( 'admin.api.form-manager' , [ 'languages-edit' ] ) , 'imagesUrl' => route ( 'resource.get' , [ '/' ] ) , 'headers' => $ this -> getAdminListHeader ( ) , ] ; $ config [ 'actions' ] [ ] = 'search' ; return hcview ( 'HCCoreUI::admin.content.list' , [ 'config' => $ config ] ) ; }
582	public function setAssetManager ( $ assetManager ) { if ( is_scalar ( $ assetManager ) ) { throw new Exception ( '"' . get_class ( $ this ) . '::assetManager" should be either object or array - "' . gettype ( $ assetManager ) . '" given.' ) ; } $ this -> _assetManager = $ assetManager ; }
8957	public function redaction ( $ element , $ id , $ version , $ redactionId ) { if ( $ element != 'node' && $ element != 'way' && $ element != 'relation' ) { throw new \ DomainException ( 'Element should be a node, a way or a relation' ) ; } $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = $ element . '/' . $ id . '/' . $ version . '/redact?redaction=' . $ redactionId ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters ) ; return simplexml_load_string ( $ response -> body ) ; }
10980	public function preRemove ( LifecycleEventArgs $ args ) : void { if ( ! $ this -> enableIndexing ) { return ; } $ this -> removeEntity ( $ args -> getObject ( ) , $ args -> getObjectManager ( ) ) ; }
4754	public function startProfiling ( ) { if ( PHP_SAPI == 'cli' ) { $ _SERVER [ 'REMOTE_ADDR' ] = null ; $ _SERVER [ 'REQUEST_URI' ] = $ _SERVER [ 'SCRIPT_NAME' ] ; } if ( function_exists ( 'xhprof_enable' ) && count ( $ this -> probes ) > 0 ) { $ this -> profiling = true ; xhprof_enable ( $ this -> memory ? XHPROF_FLAGS_MEMORY : null ) ; } }
6245	public function storages ( ) : \ Generator { foreach ( $ this -> storage -> list ( $ this -> recursive ) as $ storage ) { foreach ( $ this -> storageFilters as $ filter ) { if ( ! call_user_func ( $ filter , $ storage ) ) { continue 2 ; } } yield $ storage ; } }
8564	public function getEligibleShippingServices ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_GetEligibleShippingServicesRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetEligibleShippingServicesRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_GetEligibleShippingServicesRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetEligibleShippingServices' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetEligibleShippingServicesResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_GetEligibleShippingServicesResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1760	public static function anonymizeIp ( $ strIp ) { if ( $ strIp == '127.0.0.1' || $ strIp == '::1' ) { return $ strIp ; } if ( strpos ( $ strIp , ':' ) !== false ) { return substr_replace ( $ strIp , ':0000' , strrpos ( $ strIp , ':' ) ) ; } else { return substr_replace ( $ strIp , '.0' , strrpos ( $ strIp , '.' ) ) ; } }
8274	public function assertUsername ( $ username , $ config ) { if ( ! is_string ( $ username ) ) { throw new ConfigurationException ( "Username $username must be a string." ) ; } $ len = strlen ( $ username ) ; $ minLen = $ config [ "registration" ] [ "nameLenMin" ] ; $ maxLen = $ config [ "registration" ] [ "nameLenMax" ] ; if ( $ len < $ minLen || $ len > $ maxLen ) { throw new ConfigurationException ( sprintf ( "Length of a username $username must be between %d-%d characters." , $ minLen , $ maxLen ) ) ; } if ( ! $ this -> checkValidNameFormat ( $ username ) ) { throw new ConfigurationException ( "Username $username contains invalid character/s." ) ; } }
5236	public function get ( $ name = null ) { $ constructor = $ this -> class -> getConstructor ( ) ; if ( null === $ constructor || $ this -> class -> isInternal ( ) ) { return $ this -> class -> newInstance ( ) ; } $ params = $ this -> injectionValuesForMethod ( $ constructor ) ; if ( count ( $ params ) === 0 ) { return $ this -> class -> newInstance ( ) ; } return $ this -> class -> newInstanceArgs ( $ params ) ; }
4217	private function clearErrorsHelper ( & $ log , $ clear = true ) { $ errorsNotCleared = array ( ) ; foreach ( $ log as $ k => $ entry ) { if ( ! \ in_array ( $ entry [ 0 ] , array ( 'error' , 'warn' ) ) ) { continue ; } $ clear2 = $ clear ; if ( $ this -> channelName ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; $ clear2 = $ clear && $ channel === $ this -> channelName ; } if ( $ clear2 ) { unset ( $ log [ $ k ] ) ; } elseif ( isset ( $ entry [ 2 ] [ 'errorHash' ] ) ) { $ errorsNotCleared [ ] = $ entry [ 2 ] [ 'errorHash' ] ; } } $ log = \ array_values ( $ log ) ; return $ errorsNotCleared ; }
5852	protected function processData ( ) { $ close = GeneralUtility :: _GP ( 'closeDoc' ) ; $ save = GeneralUtility :: _GP ( '_savedok' ) ; $ saveAndClose = GeneralUtility :: _GP ( '_saveandclosedok' ) ; if ( $ save || $ saveAndClose ) { $ table = static :: virtualTable ; $ id = static :: virtualRecordId ; $ field = 'rulesets' ; $ inputData_tmp = GeneralUtility :: _GP ( 'data' ) ; $ data = $ inputData_tmp [ $ table ] [ $ id ] ; if ( count ( $ inputData_tmp [ $ table ] ) > 1 ) { foreach ( $ inputData_tmp [ $ table ] as $ key => $ values ) { if ( $ key === $ id ) continue ; ArrayUtility :: mergeRecursiveWithOverrule ( $ data , $ values ) ; } } $ newConfig = $ this -> config ; ArrayUtility :: mergeRecursiveWithOverrule ( $ newConfig , $ data ) ; $ ffValue = & $ data [ $ field ] ; if ( $ ffValue ) { $ actionCMDs = GeneralUtility :: _GP ( '_ACTION_FLEX_FORMdata' ) ; if ( is_array ( $ actionCMDs [ $ table ] [ $ id ] [ $ field ] [ 'data' ] ) ) { $ dataHandler = new CustomDataHandler ( ) ; $ dataHandler -> _ACTION_FLEX_FORMdata ( $ ffValue [ 'data' ] , $ actionCMDs [ $ table ] [ $ id ] [ $ field ] [ 'data' ] ) ; } $ this -> persistFlexForm ( $ ffValue [ 'data' ] ) ; $ newConfig [ $ field ] = $ ffValue ; } $ localconfConfig = $ newConfig ; $ localconfConfig [ 'conversion_mapping' ] = implode ( ',' , GeneralUtility :: trimExplode ( LF , $ localconfConfig [ 'conversion_mapping' ] , true ) ) ; if ( $ this -> persistConfiguration ( $ localconfConfig ) ) { $ this -> config = $ newConfig ; } } if ( $ close || $ saveAndClose ) { $ closeUrl = BackendUtility :: getModuleUrl ( 'tools_ExtensionmanagerExtensionmanager' ) ; \ TYPO3 \ CMS \ Core \ Utility \ HttpUtility :: redirect ( $ closeUrl ) ; } }
6497	public function iSwitchToWindow ( ) { $ windows = $ this -> getWindowNames ( ) ; if ( empty ( $ this -> mainWindow ) ) { $ this -> mainWindow [ 'name' ] = array_shift ( $ windows ) ; $ this -> mainWindow [ 'element' ] = $ this -> getWorkingElement ( ) ; $ window = reset ( $ windows ) ; } else { $ window = $ this -> mainWindow [ 'name' ] ; $ element = $ this -> mainWindow [ 'element' ] ; $ this -> mainWindow = [ ] ; } $ this -> getSession ( ) -> switchToWindow ( $ window ) ; $ this -> setWorkingElement ( isset ( $ element ) ? $ element : $ this -> getBodyElement ( ) ) ; }
7638	public function generateSharedAccessUrl ( $ containerName = '' , $ blobName = '' , $ resource = 'b' , $ permissions = 'r' , $ start = '' , $ expiry = '' , $ identifier = '' ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; return $ this -> getBaseUrl ( ) . '/' . $ resourceName . '?' . $ this -> sharedAccessSignatureCredentials -> createSignedQueryString ( $ resourceName , '' , $ resource , $ permissions , $ start , $ expiry , $ identifier ) ; }
3831	protected function prepareFrontendFilterWidget ( $ arrWidget , $ arrFilterUrl , $ arrJumpTo , FrontendFilterOptions $ objFrontendFilterOptions ) { $ strClass = $ GLOBALS [ 'TL_FFL' ] [ $ arrWidget [ 'inputType' ] ] ; if ( ! $ strClass ) { return array ( ) ; } $ arrWidget [ 'value' ] = isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) ? $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] : null ; $ event = new GetAttributesFromDcaEvent ( $ arrWidget , $ arrWidget [ 'eval' ] [ 'urlparam' ] ) ; $ this -> eventDispatcher -> dispatch ( ContaoEvents :: WIDGET_GET_ATTRIBUTES_FROM_DCA , $ event ) ; if ( $ objFrontendFilterOptions -> isAutoSubmit ( ) && TL_MODE == 'FE' ) { $ GLOBALS [ 'TL_JAVASCRIPT' ] [ 'metamodels' ] = 'bundles/metamodelscore/js/metamodels.js' ; } $ objWidget = new $ strClass ( $ event -> getResult ( ) ) ; $ this -> validateWidget ( $ objWidget , $ arrWidget [ 'value' ] ) ; $ strField = $ objWidget -> generateWithError ( ) ; return array ( 'class' => sprintf ( 'mm_%s %s%s%s' , $ arrWidget [ 'inputType' ] , $ arrWidget [ 'eval' ] [ 'urlparam' ] , ( ( $ arrWidget [ 'value' ] !== null ) ? ' used' : ' unused' ) , ( $ objFrontendFilterOptions -> isAutoSubmit ( ) ? ' submitonchange' : '' ) ) , 'label' => $ objWidget -> generateLabel ( ) , 'formfield' => $ strField , 'raw' => $ arrWidget , 'urlparam' => $ arrWidget [ 'eval' ] [ 'urlparam' ] , 'options' => $ this -> prepareFrontendFilterOptions ( $ arrWidget , $ arrFilterUrl , $ arrJumpTo , $ objFrontendFilterOptions -> isAutoSubmit ( ) ) , 'count' => isset ( $ arrWidget [ 'count' ] ) ? $ arrWidget [ 'count' ] : null , 'showCount' => $ objFrontendFilterOptions -> isShowCountValues ( ) , 'autosubmit' => $ objFrontendFilterOptions -> isAutoSubmit ( ) , 'urlvalue' => array_key_exists ( 'urlvalue' , $ arrWidget ) ? $ arrWidget [ 'urlvalue' ] : $ arrWidget [ 'value' ] , 'errors' => $ objWidget -> hasErrors ( ) ? $ objWidget -> getErrors ( ) : array ( ) ) ; }
11899	public function getDuration ( ) { $ ended = microtime ( true ) ; if ( $ this -> ended ) { $ ended = strtotime ( $ this -> ended ) ; } $ started = strtotime ( $ this -> started ) ; return Date :: niceDuration ( $ ended - $ started ) ; }
76	public function remove ( ) { $ offset = $ this -> key ( ) ; $ this -> offsetUnset ( $ offset ) ; $ this -> seek ( $ offset ) ; }
9911	function fromArray ( $ object_vars ) { foreach ( $ object_vars as $ key => $ value ) { if ( class_exists ( 'AbstractJSONWrapper' ) && is_subclass_of ( $ this -> { $ key } , 'AbstractJSONWrapper' ) ) { $ this -> { $ key } -> fromArray ( $ value ) ; } else { $ this -> { $ key } = $ value ; } } }
286	public function remove ( $ name ) { $ name = strtolower ( $ name ) ; if ( isset ( $ this -> _headers [ $ name ] ) ) { $ value = $ this -> _headers [ $ name ] ; unset ( $ this -> _headers [ $ name ] ) ; return $ value ; } return null ; }
10853	public function setLimit ( $ num , $ offset = 0 ) { $ this -> limit = ( int ) $ num ; $ this -> offset = ( int ) $ offset ; }
4140	protected function getRequestString ( ) { $ params = array_merge ( $ this -> getParams , $ this -> postParams , $ this -> getOauthParameters ( ) ) ; $ params = $ this -> curl -> getParams ( $ params ) ; return rawurlencode ( $ params ) ; }
4575	public function getCount ( Parameters $ parameters = null ) { $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ result = $ this -> execute ( 'GET' , static :: RESOURCE_COUNT , $ options ) ; return $ result -> count ; }
5328	public function getCpuinfoByLsCpu ( ) { if ( ! $ this -> cpuInfoByLsCpu ) { $ lscpu = shell_exec ( 'lscpu' ) ; $ lscpu = explode ( "\n" , $ lscpu ) ; $ values = [ ] ; foreach ( $ lscpu as $ v ) { $ v = array_map ( 'trim' , explode ( ':' , $ v ) ) ; if ( isset ( $ v [ 0 ] , $ v [ 1 ] ) ) { $ values [ $ v [ 0 ] ] = $ v [ 1 ] ; } } $ this -> cpuInfoByLsCpu = $ values ; } return $ this -> cpuInfoByLsCpu ; }
10210	public function createAction ( ) { $ request = $ this -> getRequest ( ) ; $ prg = $ this -> prg ( $ request -> getRequestUri ( ) , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } elseif ( $ prg === false ) { return $ this -> viewModel ; } if ( $ this -> contactForm -> setData ( $ prg ) -> isValid ( ) ) { $ contact = $ this -> contactForm -> getData ( ) ; $ this -> commandService -> persist ( $ contact ) ; $ this -> viewModel -> setVariable ( 'contact' , $ contact ) ; } return $ this -> viewModel ; }
2838	public function getRequestInfo ( ) { if ( $ this -> requestInfo === null ) { $ this -> requestInfo = Mage :: registry ( 'sheep_debug_request_info' ) ; } return $ this -> requestInfo ; }
2118	public function generateSqlForm ( ) { @ trigger_error ( 'Using the Installer::generateSqlForm() method has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ count = 0 ; $ return = '' ; $ sql_command = $ this -> compileCommands ( ) ; if ( empty ( $ sql_command ) ) { return '' ; } $ _SESSION [ 'sql_commands' ] = array ( ) ; $ arrOperations = array ( 'CREATE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'CREATE' ] , 'ALTER_ADD' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_ADD' ] , 'ALTER_CHANGE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_CHANGE' ] , 'ALTER_DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_DROP' ] , 'DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'DROP' ] ) ; foreach ( $ arrOperations as $ command => $ label ) { if ( \ is_array ( $ sql_command [ $ command ] ) ) { $ return .= ' <tr> <td colspan="2" class="tl_col_0">' . $ label . '</td> </tr>' ; $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" id="check_all_' . $ count . '" class="tl_checkbox" onclick="Backend.toggleCheckboxElements(this, \'' . strtolower ( $ command ) . '\')"></td> <td class="tl_col_2"><label for="check_all_' . $ count . '" style="color:#a6a6a6"><em>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</em></label></td> </tr>' ; foreach ( $ sql_command [ $ command ] as $ vv ) { $ key = md5 ( $ vv ) ; $ _SESSION [ 'sql_commands' ] [ $ key ] = $ vv ; $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" name="sql[]" id="sql_' . $ count . '" class="tl_checkbox ' . strtolower ( $ command ) . '" value="' . $ key . '"' . ( ( stripos ( $ command , 'DROP' ) === false ) ? ' checked="checked"' : '' ) . '></td> <td class="tl_col_2"><pre><label for="sql_' . $ count ++ . '">' . $ vv . '</label></pre></td> </tr>' ; } } } return '<div id="sql_wrapper"> <table id="sql_table">' . $ return . ' </table></div>' ; }
5630	public function getIdentity ( ) { if ( $ this -> username && $ this -> password ) { return $ this -> username . ':' . $ this -> password ; } return false ; }
11463	public static function exception ( $ Throwable ) { while ( @ ob_end_clean ( ) ) ; try { if ( PHP_SAPI == 'cli' ) { $ message = BaseException :: displayConsoleException ( $ Throwable ) ; if ( @ fwrite ( STDERR , $ message ) === false ) echo $ message ; } else { @ header ( "HTTP/1.1 500 Internal Server Error" ) ; @ header ( 'Content-Type: text/html' ) ; echo BaseException :: displayException ( $ Throwable ) ; } } catch ( \ Throwable $ e ) { $ class = get_class ( $ e ) ; $ message = $ e -> getMessage ( ) ; echo "Uncaught $class inside exception-handler: \"$message\"" ; } exit ( 1 ) ; }
11272	protected function handleResponseContent ( ResponseInterface $ response , $ contentType = null ) { $ contents = $ response -> getBody ( ) -> getContents ( ) ; if ( ! $ contentType ) { $ contentTypeHeaderLine = $ response -> getHeaderLine ( 'Content-Type' ) ; if ( stripos ( $ contentTypeHeaderLine , 'application/json' ) !== false ) { $ contentType = 'json' ; } elseif ( stripos ( $ contentTypeHeaderLine , 'application/xml' ) !== false ) { $ contentType = 'xml' ; } } if ( $ contentType ) { return Parser :: data ( $ contents ) -> from ( $ contentType ) -> toArray ( ) ; } return $ contents ; }
6528	public static function registerMap ( array $ map ) { @ trigger_error ( sprintf ( '"%s" is deprecated. Use "registerManifest" instead.' , __CLASS__ ) , E_USER_DEPRECATED ) ; $ nextId = count ( self :: $ curies ) + 30000 ; foreach ( $ map as $ curie => $ class ) { ++ $ nextId ; self :: $ curies [ $ curie ] = $ nextId ; self :: $ classes [ $ nextId ] = $ class ; } }
3297	public function doAutoRunEnhancements ( LeadEvent $ event ) { $ lead = $ event -> getLead ( ) ; if ( $ lead && ( null !== $ lead -> getDateIdentified ( ) || ! $ lead -> isAnonymous ( ) ) ) { $ leadKey = strtolower ( implode ( '|' , [ $ lead -> getFirstname ( ) , ( $ lead -> getLastActive ( ) ? $ lead -> getLastActive ( ) -> format ( 'c' ) : '' ) , $ lead -> getEmail ( ) , $ lead -> getPhone ( ) , $ lead -> getMobile ( ) , ] ) ) ; if ( strlen ( $ leadKey ) > 3 ) { if ( isset ( $ this -> leadsEnhanced [ $ leadKey ] ) ) { return ; } else { $ this -> leadsEnhanced [ $ leadKey ] = true ; } } $ integrations = $ this -> enhancerHelper -> getEnhancerIntegrations ( ) ; foreach ( $ integrations as $ integration ) { $ settings = $ integration -> getIntegrationSettings ( ) ; if ( $ settings -> getIsPublished ( ) ) { $ features = $ settings -> getFeatureSettings ( ) ; if ( isset ( $ features [ 'autorun_enabled' ] ) && $ features [ 'autorun_enabled' ] ) { try { $ integration -> doEnhancement ( $ lead ) ; } catch ( \ Exception $ exception ) { $ e = new ApiErrorException ( 'There was an issue using enhancer: ' . $ integration -> getName ( ) , 0 , $ exception ) ; if ( ! empty ( $ lead ) ) { $ e -> setContact ( $ lead ) ; } throw $ e ; } } } } $ this -> logger -> info ( 'doAutoRunEnhancements complete' ) ; } }
606	private function tokenizeDelimitedString ( & $ length ) { $ isIdentifier = $ this -> isIdentifier ( $ length , $ content ) ; $ isStringLiteral = ! $ isIdentifier && $ this -> isStringLiteral ( $ length , $ content ) ; if ( ! $ isIdentifier && ! $ isStringLiteral ) { return false ; } $ this -> addTokenFromBuffer ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => $ isIdentifier ? SqlToken :: TYPE_IDENTIFIER : SqlToken :: TYPE_STRING_LITERAL , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; return true ; }
4744	public function isReviewOptInError ( ) { $ formSent = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'rvw_oegdproptin' ) !== null ; $ review = oxNew ( \ OxidEsales \ Eshop \ Application \ Controller \ ReviewController :: class ) ; $ result = false ; if ( $ formSent && ! $ review -> validateOptIn ( ) ) { $ result = true ; } return $ result ; }
7551	function hasAttribute ( $ attr , $ compare = 'total' , $ case_sensitive = false ) { return ( ( bool ) $ this -> findAttribute ( $ attr , $ compare , $ case_sensitive ) ) ; }
2792	public function get ( $ option ) { if ( ! array_key_exists ( $ option , $ this -> inputOptions ) ) { throw new \ InvalidArgumentException ( 'Option "' . $ option . ' not exists' ) ; } return $ this -> inputOptions [ $ option ] ; }
12593	public function setOperator ( $ operator ) { $ this -> checkParams ( $ this -> operation , $ operator ) ; $ this -> operator = $ operator ; }
3659	public static function getSubscribedServices ( ) { return [ Connection :: class => Connection :: class , Input :: class => Input :: class , InsertTags :: class => InsertTags :: class , Session :: class => Session :: class , IMetaModelsServiceContainer :: class => IMetaModelsServiceContainer :: class ] ; }
11004	public function getPath ( $ url ) { $ url = new URL ( $ url ) ; $ to_replace = $ this -> url -> path ; $ path = $ url -> path ; if ( strpos ( $ path , $ to_replace ) === 0 ) $ path = substr ( $ path , strlen ( $ to_replace ) ) ; $ path = '/' . urldecode ( $ path ) ; return $ path ; }
5512	public function expectMaximumCallCount ( $ method , $ count , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set maximum call count' ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> max_counts [ strtolower ( $ method ) ] = new MaximumCallCountExpectation ( $ method , $ count , $ message ) ; }
8163	static public function register ( ) { if ( static :: $ registered === true ) { return true ; } $ kirby = kirby ( ) ; if ( ! class_exists ( 'Kirby\Component\Template' ) ) { throw new Exception ( 'The Kirby Twig plugin requires Kirby 2.3 or higher. Current version: ' . $ kirby -> version ( ) ) ; } if ( ! class_exists ( 'Twig_Environment' ) ) { require_once __DIR__ . '/../lib/Twig/lib/Twig/Autoloader.php' ; \ Twig_Autoloader :: register ( ) ; } $ kirby -> set ( 'component' , 'template' , 'Kirby\Twig\TwigComponent' ) ; if ( is_executable ( 'twig' ) === false ) { require_once __DIR__ . '/helpers.php' ; } return static :: $ registered = true ; }
1414	public function resourceCannotBeDeleted ( string $ detail = null ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'resource_cannot_be_deleted' , 'code' ) , $ this -> trans ( 'resource_cannot_be_deleted' , 'title' ) , $ detail ? : $ this -> trans ( 'resource_cannot_be_deleted' , 'detail' ) ) ; }
4628	protected function prepareRequestUrl ( ) { $ protocol = $ this -> node -> useTls ( ) ? 'https' : 'http' ; $ this -> requestURL = sprintf ( '%s://%s%s?%s' , $ protocol , $ this -> node -> getUri ( ) , $ this -> path , $ this -> query ) ; $ this -> options [ CURLOPT_URL ] = $ this -> requestURL ; return $ this ; }
9310	protected function doPostAction ( $ uri , array $ data = [ ] ) { $ this -> setActionUri ( $ uri ) ; try { $ response = $ this -> client -> post ( $ this -> uri , [ 'json' => $ data ] ) ; } catch ( ClientException $ e ) { $ response = $ e -> getResponse ( ) ; } catch ( ServerException $ e ) { $ response = $ e -> getResponse ( ) ; } return $ this -> responseToJson ( $ response ) ; }
3961	private function variantCssClass ( ) { if ( $ this -> isVariant ( ) ) { return 'variant' ; } if ( $ this -> isVariantBase ( ) ) { $ result = 'varbase' ; if ( 0 !== $ this -> getVariants ( null ) -> getCount ( ) ) { $ result .= ' varbase-with-variants' ; } return $ result ; } return '' ; }
1389	protected function resourceExists ( string $ type , string $ id , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceExists ( $ type , $ id , $ path ) ) ; }
6902	public function url ( $ page = 1 ) { $ page = max ( 1 , ( int ) $ page ) ; if ( $ page === 1 AND ! $ this -> first_page_in_url ) { $ page = NULL ; } switch ( $ this -> current_page_source ) { case 'query_string' : case 'mixed' : return URL :: site ( $ this -> request -> uri ( ) . $ this -> query ( [ $ this -> current_page_source_key => $ page ] ) ) ; case 'route' : return URL :: site ( $ this -> route -> url ( array_merge ( $ this -> route_params , array ( $ this -> current_page_source_key => $ page ) ) ) . $ this -> query ( ) ) ; } return '#' ; }
285	public function setDefault ( $ name , $ value ) { $ name = strtolower ( $ name ) ; if ( empty ( $ this -> _headers [ $ name ] ) ) { $ this -> _headers [ $ name ] [ ] = $ value ; } return $ this ; }
1382	protected function dataHas ( $ key ) : bool { if ( ! isset ( $ this -> document -> data ) ) { return false ; } return property_exists ( $ this -> document -> data , $ key ) ; }
781	public function has ( $ name ) { return isset ( $ this -> _cookies [ $ name ] ) && $ this -> _cookies [ $ name ] -> value !== '' && ( $ this -> _cookies [ $ name ] -> expire === null || $ this -> _cookies [ $ name ] -> expire === 0 || $ this -> _cookies [ $ name ] -> expire >= time ( ) ) ; }
1985	public function getOptionsForUser ( BackendUser $ user ) : array { $ this -> loadOptions ( ) ; if ( $ user -> isAdmin ) { $ event = new ImageSizesEvent ( $ this -> options , $ user ) ; } else { $ options = array_map ( static function ( $ val ) { return is_numeric ( $ val ) ? ( int ) $ val : $ val ; } , StringUtil :: deserialize ( $ user -> imageSizes , true ) ) ; $ event = new ImageSizesEvent ( $ this -> filterOptions ( $ options ) , $ user ) ; } $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: IMAGE_SIZES_USER , $ event ) ; return $ event -> getImageSizes ( ) ; }
12523	public function update ( array $ arguments = null , array $ options = null ) : void { if ( $ arguments ) { $ keys = array_keys ( $ this -> arguments ) ; for ( $ index = 0 ; $ index < count ( $ keys ) ; $ index ++ ) { $ this -> arguments [ $ keys [ $ index ] ] = $ arguments [ $ index ] ; } } if ( $ options ) { foreach ( $ options as $ option => $ value ) { $ this -> options [ $ option ] = $ value ; } } }
1556	protected function queryRulesWithoutSearch ( ) { return collect ( $ this -> queryRules ( ) ) -> reject ( function ( $ value , $ key ) { return Str :: startsWith ( $ key , [ 'filter.' , 'sort.' , 'page.' ] ) ; } ) -> all ( ) ; }
9429	public function getFontIconClassNames ( ) { $ classes = [ ] ; if ( $ this -> owner -> FontIcon ) { if ( $ this -> owner -> FontIconListItem ) { $ classes [ ] = $ this -> backend -> getClassName ( 'list-item' ) ; } if ( $ this -> owner -> FontIconFixedWidth ) { $ classes [ ] = $ this -> backend -> getClassName ( 'fixed-width' ) ; } $ classes [ ] = $ this -> backend -> getClassName ( 'icon' , [ $ this -> owner -> FontIcon ] ) ; } return $ classes ; }
5641	public function paintCaseStart ( $ test_name ) { if ( ! isset ( $ this -> size ) ) { $ this -> size = 1 ; } if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintHeader ( $ test_name ) ; } $ this -> test_stack [ ] = $ test_name ; }
1436	public static function camelize ( $ value ) { if ( isset ( self :: $ camelized [ $ value ] ) ) { return self :: $ camelized [ $ value ] ; } return self :: $ camelized [ $ value ] = lcfirst ( self :: classify ( $ value ) ) ; }
9506	public function listLogs ( Request $ request ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_LIST ) ; $ stats = $ this -> logViewer -> statsTable ( ) ; $ headers = $ stats -> header ( ) ; $ page = $ request -> get ( 'page' , 1 ) ; $ offset = ( $ page * $ this -> perPage ) - $ this -> perPage ; $ rows = new LengthAwarePaginator ( array_slice ( $ stats -> rows ( ) , $ offset , $ this -> perPage , true ) , count ( $ stats -> rows ( ) ) , $ this -> perPage , $ page ) ; $ rows -> setPath ( $ request -> url ( ) ) ; $ this -> setTitle ( $ title = trans ( 'foundation::log-viewer.titles.logs-list' ) ) ; $ this -> addBreadcrumb ( $ title ) ; return $ this -> view ( 'admin.system.log-viewer.list' , compact ( 'headers' , 'rows' , 'footer' ) ) ; }
7985	public function getAvailableOptions ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/availableOptions' ) -> send ( ) ; } catch ( ClientErrorResponseException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == '404' && json_decode ( $ e -> getResponse ( ) -> getBody ( ) ) -> message == "No options found" ) return "[]" ; else throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
11641	public function getColumns ( ) { if ( is_null ( $ this -> _columns ) ) { $ this -> columns = $ this -> dataProvider -> model -> attributeNames ( ) ; } return $ this -> _columns ; }
11893	private function createEditForm ( CustomField $ entity , $ type ) { $ form = $ this -> createForm ( 'custom_field_choice' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfield_update' , array ( 'id' => $ entity -> getId ( ) ) ) , 'method' => 'PUT' , 'type' => $ type , 'group_widget' => 'hidden' ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Update' ) ) ; return $ form ; }
896	private function findComparisonStart ( Tokens $ tokens , $ index ) { -- $ index ; $ nonBlockFound = false ; while ( 0 <= $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_WHITESPACE , T_COMMENT , T_DOC_COMMENT ] ) ) { -- $ index ; continue ; } if ( $ this -> isOfLowerPrecedence ( $ token ) ) { break ; } $ block = Tokens :: detectBlockType ( $ token ) ; if ( null === $ block ) { -- $ index ; $ nonBlockFound = true ; continue ; } if ( $ block [ 'isStart' ] || ( $ nonBlockFound && Tokens :: BLOCK_TYPE_CURLY_BRACE === $ block [ 'type' ] ) ) { break ; } $ index = $ tokens -> findBlockStart ( $ block [ 'type' ] , $ index ) - 1 ; } return $ tokens -> getNextMeaningfulToken ( $ index ) ; }
6137	public function searchtotal ( Search $ search ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'search' => $ search ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/search/total' , $ parameters ) ; return $ result ; }
5584	public function click ( $ label ) { $ raw = $ this -> clickSubmit ( $ label ) ; if ( ! $ raw ) { $ raw = $ this -> clickLink ( $ label ) ; } if ( ! $ raw ) { $ raw = $ this -> clickImage ( $ label ) ; } return $ raw ; }
814	private function getNewLineIndex ( $ index , Tokens $ tokens ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; for ( $ index , $ count = \ count ( $ tokens ) ; $ index < $ count ; ++ $ index ) { if ( false !== strstr ( $ tokens [ $ index ] -> getContent ( ) , $ lineEnding ) ) { return $ index ; } } return $ index ; }
4110	protected function arrayToTabList ( array $ array , array $ skipKeys = array ( ) , $ indentationLevel = 1 ) { $ output = '' ; foreach ( $ array as $ key => $ value ) { if ( in_array ( $ key , $ skipKeys , true ) ) { continue ; } $ output .= $ this -> tabsForIndentation ( $ indentationLevel ) ; if ( ! is_array ( $ value ) ) { if ( ! is_int ( $ key ) ) { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> tabsForIndentation ( $ indentationLevel + 1 ) ; } $ output .= $ value . "\n" ; } else { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> arrayToTabList ( $ value , $ skipKeys , $ indentationLevel + 1 ) ; } } return $ output ; }
9220	protected function requestAllPages ( $ forceRefresh = false ) { $ _page = $ this -> page ; $ _key = $ this -> key ; $ nextPageNumber = false ; if ( isset ( $ this -> pagination [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> pagination [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } while ( $ nextPageNumber !== false ) { $ this -> requestPageNumber ( $ nextPageNumber , $ forceRefresh ) ; if ( isset ( $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } else { $ nextPageNumber = false ; } } $ this -> page = $ _page ; $ this -> key = $ _key ; }
5733	public function getLeagueTeams ( int $ leagueID , array $ filter = [ 'stage' => '' ] ) { $ leagueTeams = $ this -> run ( "v2/competitions/{$leagueID}/teams" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ leagueTeams -> teams ) ; }
1845	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objCalendar = CalendarModel :: findByProtected ( '' ) ; if ( $ objCalendar !== null ) { while ( $ objCalendar -> next ( ) ) { if ( ! $ objCalendar -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objCalendar -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objCalendar -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objCalendar -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objCalendar -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/events/%s' ) ; } $ strUrl = $ arrProcessed [ $ objCalendar -> jumpTo ] ; $ objEvents = CalendarEventsModel :: findPublishedDefaultByPid ( $ objCalendar -> id ) ; if ( $ objEvents !== null ) { while ( $ objEvents -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objEvents -> alias ? : $ objEvents -> id ) ) ; } } } } return $ arrPages ; }
2803	public function setProxyTargetDir ( string $ proxyTargetDir ) : void { if ( ! is_dir ( $ proxyTargetDir ) ) { throw new InvalidArgumentException ( sprintf ( 'Proxy target directory "%s" does not exist!' , $ proxyTargetDir ) , 10 ) ; } if ( ! is_writable ( $ proxyTargetDir ) ) { throw new InvalidArgumentException ( sprintf ( 'Proxy target directory "%s" is not writable!' , $ proxyTargetDir ) , 20 ) ; } $ this -> proxyTargetDir = $ proxyTargetDir ; }
5455	public function addContent ( $ text ) { if ( isset ( $ this -> private_content_tag ) ) { $ this -> private_content_tag -> addContent ( $ text ) ; } else { $ this -> addContentToAllOpenTags ( $ text ) ; } return true ; }
3384	private function findUser ( ) { $ sql = sprintf ( 'SELECT * FROM %s WHERE %s = :identity' , $ this -> getTableName ( ) , $ this -> getIdentityColumn ( ) ) ; $ stmt = $ this -> db -> prepare ( $ sql ) ; $ stmt -> execute ( array ( 'identity' => $ this -> getIdentity ( ) ) ) ; return $ stmt -> fetch ( PDO :: FETCH_ASSOC ) ; }
472	public function insert ( $ table , $ columns ) { $ time = $ this -> beginCommand ( "insert into $table" ) ; $ this -> db -> createCommand ( ) -> insert ( $ table , $ columns ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
4245	private function logPhpInfo ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.phpInfo' ) ) { return ; } $ this -> debug -> log ( 'PHP Version' , PHP_VERSION ) ; $ this -> debug -> log ( 'ini location' , \ php_ini_loaded_file ( ) ) ; $ this -> debug -> log ( 'memory_limit' , $ this -> debug -> utilities -> getBytes ( $ this -> debug -> utilities -> memoryLimit ( ) ) ) ; $ this -> debug -> log ( 'session.cache_limiter' , \ ini_get ( 'session.cache_limiter' ) ) ; if ( \ session_module_name ( ) === 'files' ) { $ this -> debug -> log ( 'session_save_path' , \ session_save_path ( ) ? : \ sys_get_temp_dir ( ) ) ; } $ extensionsCheck = array ( 'curl' , 'mbstring' ) ; $ extensionsCheck = \ array_filter ( $ extensionsCheck , function ( $ extension ) { return ! \ extension_loaded ( $ extension ) ; } ) ; if ( $ extensionsCheck ) { $ this -> debug -> warn ( 'These common extensions are not loaded:' , $ extensionsCheck ) ; } $ this -> logPhpInfoEr ( ) ; }
7875	protected function settleRepositoryIfNotExists ( ) { $ source = $ this -> pipelines -> getSource ( ) ; if ( ! $ this -> files -> exists ( $ source ) ) { $ this -> pipelines -> settle ( ) ; } }
10235	private function getImageMimeType ( $ pFile ) { if ( File :: fileExists ( $ pFile ) ) { $ image = getimagesize ( $ pFile ) ; return image_type_to_mime_type ( $ image [ 2 ] ) ; } throw new WriterException ( "File $pFile does not exist" ) ; }
12692	public function synchronize ( Page $ page , array $ pages ) { if ( ! $ this -> configurationHandler -> isTheme ( ) ) { return ; } foreach ( $ pages as $ pageValues ) { $ tokens = explode ( "_" , $ pageValues [ "seo" ] [ 0 ] [ "language" ] ) ; $ pageOptions = array ( 'page' => $ pageValues [ "name" ] , 'language' => $ tokens [ 0 ] , 'country' => $ tokens [ 1 ] , ) ; $ page -> render ( $ this -> configurationHandler -> siteDir ( ) , $ pageOptions ) ; $ this -> saveTemplateSlots ( $ page -> getPageSlots ( ) , $ pageValues [ "template" ] ) ; } $ this -> saveTemplateSlots ( $ page -> getCommonSlots ( ) , 'base' ) ; }
7808	public function setCurlNumRetries ( $ retries ) { if ( ! is_numeric ( $ retries ) || $ retries < 0 ) { throw new \ InvalidArgumentException ( 'Retries value must be numeric and a non-negative number.' ) ; } $ this -> curlNumRetries = $ retries ; return $ this ; }
4803	public function renderRichText ( $ richText ) { if ( strlen ( $ richText ) < 1 ) { return '' ; } $ templatePath = $ this -> getTemplatePathAndFilename ( 'RichText' ) ; $ view = $ this -> createView ( $ templatePath ) ; $ view -> assign ( 'richText' , $ richText ) ; return $ view -> render ( $ templatePath ) ; }
2424	public static function getFolderHash ( $ strPath ) { $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; $ arrHash = array ( ) ; $ objChildren = Database :: getInstance ( ) -> prepare ( "SELECT hash, name FROM tl_files WHERE path LIKE ? AND path NOT LIKE ? ORDER BY name" ) -> execute ( $ strPath . '/%' , $ strPath . '/%/%' ) ; if ( $ objChildren !== null ) { while ( $ objChildren -> next ( ) ) { $ arrHash [ ] = $ objChildren -> hash . $ objChildren -> name ; } } return md5 ( implode ( "\0" , $ arrHash ) ) ; }
3688	private function calculateSubfilter ( $ operation , IFilter $ filter ) { if ( ! is_array ( $ operation ) ) { throw new \ RuntimeException ( 'Error Processing subfilter: ' . var_export ( $ operation , true ) , 1 ) ; } switch ( $ operation [ 'operation' ] ) { case 'AND' : case 'OR' : $ this -> getAndOrFilter ( $ filter , $ operation ) ; break ; case '=' : case '>' : case '<' : $ this -> getFilterForComparingOperator ( $ this -> getAttributeFromFilterOperation ( $ operation ) , $ filter , $ operation ) ; break ; case 'IN' : $ this -> getFilterForInList ( $ filter , $ operation ) ; break ; case 'LIKE' : $ this -> getFilterForLike ( $ this -> getAttributeFromFilterOperation ( $ operation ) , $ filter , $ operation ) ; break ; default : throw new \ RuntimeException ( 'Error processing filter array - unknown operation ' . var_export ( $ operation , true ) , 1 ) ; } }
576	public function run ( $ id = null ) { if ( Yii :: $ app -> getRequest ( ) -> getMethod ( ) !== 'OPTIONS' ) { Yii :: $ app -> getResponse ( ) -> setStatusCode ( 405 ) ; } $ options = $ id === null ? $ this -> collectionOptions : $ this -> resourceOptions ; $ headers = Yii :: $ app -> getResponse ( ) -> getHeaders ( ) ; $ headers -> set ( 'Allow' , implode ( ', ' , $ options ) ) ; $ headers -> set ( 'Access-Control-Allow-Methods' , implode ( ', ' , $ options ) ) ; }
778	public static function checkRequirements ( ) { if ( extension_loaded ( 'imagick' ) ) { $ imagickFormats = ( new \ Imagick ( ) ) -> queryFormats ( 'PNG' ) ; if ( in_array ( 'PNG' , $ imagickFormats , true ) ) { return 'imagick' ; } } if ( extension_loaded ( 'gd' ) ) { $ gdInfo = gd_info ( ) ; if ( ! empty ( $ gdInfo [ 'FreeType Support' ] ) ) { return 'gd' ; } } throw new InvalidConfigException ( 'Either GD PHP extension with FreeType support or ImageMagick PHP extension with PNG support is required.' ) ; }
12855	function goWait ( $ maxExecution = null ) { $ jobExecution = 0 ; $ sleep = 0 ; while ( 1 ) { if ( 0 == $ executed = $ this -> goUntilEmpty ( ) ) { $ sleep += 100000 ; usleep ( $ sleep ) ; if ( $ sleep > 2 * 1000000 ) $ sleep = 100000 ; continue ; } $ jobExecution += $ executed ; if ( $ jobExecution >= $ maxExecution ) break ; if ( $ sleep = $ this -> getSleep ( ) ) usleep ( $ sleep ) ; $ sleep = 0 ; } }
9287	public function drop ( ) { $ adapter = $ this -> dbAdapter ; $ ddl = new Ddl \ DropTable ( self :: TABLE_NAME ) ; $ sql = ( new Sql ( $ adapter ) ) -> getSqlStringForSqlObject ( $ ddl ) ; $ adapter -> query ( $ sql , $ adapter :: QUERY_MODE_EXECUTE ) ; }
9103	protected function parse_message ( ) { if ( empty ( $ this -> args [ 'message' ] ) ) { return null ; } $ like = esc_sql ( $ this -> args [ 'message' ] ) ; return new Where ( 'message' , 'LIKE' , "%{$like}%" ) ; }
11261	public function add ( MethodInterface $ method ) { if ( $ this -> isUnique ( $ method ) ) { $ this -> collection [ ] = $ method ; } else { throw new ExtDirectException ( "Remotable methodname {$method->getAnnotatedName()} already exists, but have to be unique" ) ; } }
3132	public function init ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ session -> getState ( ) === AssessmentTestSessionState :: INITIAL ) { $ session -> beginTestSession ( ) ; $ event = new TestInitEvent ( $ session ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; \ common_Logger :: i ( "Assessment Test Session begun." ) ; if ( $ context -> isAdaptive ( ) ) { \ common_Logger :: t ( "Very first item is adaptive." ) ; $ nextCatItemId = $ context -> selectAdaptiveNextItem ( ) ; $ context -> persistCurrentCatItemId ( $ nextCatItemId ) ; $ context -> persistSeenCatItemIds ( $ nextCatItemId ) ; } } elseif ( $ session -> getState ( ) === AssessmentTestSessionState :: SUSPENDED ) { $ session -> resume ( ) ; } $ session -> initItemTimer ( ) ; if ( $ session -> isTimeout ( ) === false ) { TestRunnerUtils :: beginCandidateInteraction ( $ session ) ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> clearEvents ( $ session -> getSessionId ( ) ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'init' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
11965	public static function hash ( $ password ) { return \ Yii :: $ app -> security -> generatePasswordHash ( $ password , \ Yii :: $ app -> getModule ( 'user' ) -> cost ) ; }
9453	public function getCollection ( $ index , array $ filters = null , array $ queries = null , array $ fieldWeights = null , $ limit = 20 , $ offset = 0 , $ countableAttributes = null ) { $ result = $ this -> query ( $ index , $ filters , $ queries , $ fieldWeights , $ limit , $ offset ) ; if ( is_array ( $ result ) ) { $ i = 0 ; if ( $ countableAttributes ) { foreach ( $ countableAttributes as $ attributeName ) { $ i ++ ; $ result [ 0 ] [ 'attributes' ] [ 'countable' ] [ $ attributeName ] = new CountableCollection ( $ result [ $ i ] , $ attributeName ) ; } } for ( $ l = 1 ; $ l <= $ i ; $ l ++ ) { unset ( $ result [ $ l ] ) ; } $ collection = $ this -> factoryCollection ( $ result ) ; return $ collection ; } }
2507	protected static function loopOperationsWithQuery ( $ operations , $ query , $ wsdlIdentifier , $ domXpath ) { $ msgAndVer = [ ] ; foreach ( $ operations as $ operation ) { if ( ! empty ( $ operation -> value ) ) { $ fullVersion = $ domXpath -> evaluate ( sprintf ( $ query , $ operation -> value ) ) ; if ( ! empty ( $ fullVersion ) ) { $ extractedVersion = self :: extractMessageVersion ( $ fullVersion ) ; $ msgAndVer [ $ operation -> value ] = [ 'version' => $ extractedVersion , 'wsdl' => $ wsdlIdentifier ] ; } } } return $ msgAndVer ; }
4867	public function fail ( JobInterface $ job , array $ options = [ ] ) { $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; unset ( $ envelope [ 'created' ] ) ; unset ( $ envelope [ 'scheduled' ] ) ; $ envelope [ 'status' ] = self :: STATUS_FAILED ; $ this -> mongoCollection -> findOneAndUpdate ( [ '_id' => new \ MongoDB \ BSON \ ObjectId ( $ job -> getId ( ) ) ] , [ '$set' => $ envelope ] ) ; }
12256	public function getSkylineAppDirectory ( string $ dirName ) { $ name = CC :: get ( [ ] , $ dirName ) ; if ( $ name ) { return $ this -> getSkylineAppDataDirectory ( ) . "/$name" ; } return NULL ; }
11884	public function getModuleHandler ( ) { if ( is_null ( $ this -> _moduleHandler ) ) { $ stem = $ this -> field ; if ( ! isset ( self :: $ _moduleHandlers [ $ stem ] ) ) { self :: $ _moduleHandlers [ $ stem ] = [ ] ; } $ n = count ( self :: $ _moduleHandlers [ $ stem ] ) ; $ this -> _moduleHandler = $ this -> field . ':_' . $ n ; self :: $ _moduleHandlers [ $ stem ] [ ] = $ this -> _moduleHandler ; } return $ this -> _moduleHandler ; }
12257	public function getProjectSearchPaths ( string $ name ) : array { $ srcPaths = $ this -> getProject ( ) -> getAttribute ( AttributeInterface :: SEARCH_PATHS_ATTR_NAME ) ; if ( $ srcPaths instanceof SearchPathCollection ) { return $ srcPaths -> getSearchPaths ( $ name ) ?? [ ] ; } return [ ] ; }
3779	protected function getParameterFilterOptions ( $ objAttribute , $ arrIds , & $ arrCount = null ) { $ arrOptions = $ objAttribute -> getFilterOptions ( $ this -> get ( 'onlypossible' ) ? $ arrIds : null , ( bool ) $ this -> get ( 'onlyused' ) , $ arrCount ) ; foreach ( $ arrOptions as $ mixOptionKey => $ mixOptions ) { $ mixOptions = strip_tags ( $ mixOptions ) ; $ mixOptions = trim ( $ mixOptions ) ; if ( $ mixOptions === '' || $ mixOptions === null ) { unset ( $ arrOptions [ $ mixOptionKey ] ) ; } } return $ arrOptions ; }
3275	public function delete ( string $ key ) { Validation :: validateKey ( $ key ) ; if ( $ this -> get ( $ key ) !== false ) { $ this -> replace ( $ key , false ) ; } }
12949	public function afterSave ( ) { if ( $ this -> _tagsList === null ) { return ; } $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( ! ( $ relation instanceof ActiveQuery ) ) { return ; } if ( ! $ this -> owner -> getIsNewRecord ( ) ) { $ this -> beforeDelete ( ) ; $ this -> afterDelete ( ) ; } $ relationClass = $ relation -> modelClass ; $ ownerTagsList = [ ] ; foreach ( $ this -> _tagsList as $ tagText ) { $ tag = $ relationClass :: findOne ( [ 'text' => $ tagText ] ) ; if ( $ tag === null ) { $ tag = new $ relationClass ( ) ; $ tag -> setAttribute ( 'text' , $ tagText ) ; } $ tag -> setAttribute ( 'count' , $ tag -> getAttribute ( 'count' ) + 1 ) ; if ( $ tag -> save ( ) ) { $ ownerTagsList [ ] = [ $ this -> owner -> getPrimaryKey ( ) , $ tag -> getPrimaryKey ( ) ] ; } } if ( ! empty ( $ ownerTagsList ) ) { $ this -> owner -> getDb ( ) -> createCommand ( ) -> batchInsert ( $ relation -> via -> from [ 0 ] , [ key ( $ relation -> via -> link ) , current ( $ relation -> link ) ] , $ ownerTagsList ) -> execute ( ) ; } }
11310	public static function setMappings ( array $ messages , $ manual = true ) { $ class = get_called_class ( ) ; if ( $ manual ) { static :: $ messages = $ messages ; self :: setStatus ( ) ; } else { self :: $ mappings [ $ class ] = array_replace ( $ class :: getMappings ( ) , $ messages ) ; } }
12002	static public function generate ( $ length = 16 , $ algorithm = 'sha256' ) { if ( ! in_array ( $ algorithm , self :: $ allowedAlgorithm ) ) { throw new Exception ( "Hash algorithm $algorithm doesn't exists!" ) ; } $ salt = hash ( $ algorithm , time ( ) ) ; return substr ( hash ( $ algorithm , ( mt_rand ( self :: RAND_MIN , self :: RAND_MAX ) % $ length ) . $ salt . mt_rand ( self :: RAND_MIN , self :: RAND_MAX ) ) , self :: CUT_LEN , $ length ) ; }
2034	public function onRegister ( Registry $ registry ) { parent :: onRegister ( $ registry ) ; if ( $ this -> fallback && $ this -> type == 'root' && ! $ registry -> isRegisteredAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ) { $ registry -> registerAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ; } }
6885	public function lookupPostcodeAddresses ( $ postcode ) { $ path = self :: PATH_LOOKUP_POSTCODE ; $ response = $ this -> httpGet ( $ path , [ 'postcode' => $ postcode ] ) ; return Response \ AddressList :: buildFromResponse ( $ response ) ; }
4164	public function setAccessToken ( $ data ) { ( true === is_object ( $ data ) ) ? $ token = $ data -> access_token : $ token = $ data ; $ this -> _accesstoken = $ token ; }
1856	protected function getPageLayout ( $ objPage ) { $ objLayout = LayoutModel :: findByPk ( $ objPage -> layout ) ; if ( null === $ objLayout ) { $ this -> log ( 'Could not find layout ID "' . $ objPage -> layout . '"' , __METHOD__ , TL_ERROR ) ; throw new NoLayoutSpecifiedException ( 'No layout specified' ) ; } $ objPage -> hasJQuery = $ objLayout -> addJQuery ; $ objPage -> hasMooTools = $ objLayout -> addMooTools ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageLayout' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageLayout' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageLayout' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objPage , $ objLayout , $ this ) ; } } return $ objLayout ; }
6054	public function createFolder ( Folder $ folder , $ parentId = 0 , $ inheritAccess = null ) { $ parameters = [ 'query' => [ 'parentId' => $ parentId ] , 'body' => json_encode ( [ 'folder' => $ folder , 'inheritAccess' => $ inheritAccess ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders' , $ parameters ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
3991	public function acceptsAnotherChild ( ModelInterface $ model , ModelCollector $ collector ) { $ conditionType = $ model -> getProperty ( 'type' ) ; if ( ! $ this -> conditionFactory -> supportsNesting ( $ conditionType ) ) { return false ; } if ( - 1 === ( $ max = $ this -> conditionFactory -> maxChildren ( $ conditionType ) ) ) { return true ; } return \ count ( $ collector -> collectDirectChildrenOf ( $ model ) ) < $ max ; }
10835	private function compileOn ( array $ join ) { $ sql = array ( ) ; list ( $ on , $ table , $ type , $ c1 , $ op , $ c2 ) = $ join ; if ( $ type !== null ) { $ sql [ ] = $ type ; } array_push ( $ sql , "JOIN" , $ table , "ON" , $ c1 , $ op , $ c2 ) ; return join ( ' ' , $ sql ) ; }
1110	protected function keyForScope ( $ node ) { return implode ( '-' , array_map ( function ( $ column ) use ( $ node ) { $ value = $ node -> getAttribute ( $ column ) ; if ( is_null ( $ value ) ) return 'NULL' ; return $ value ; } , $ node -> getScopedColumns ( ) ) ) ; }
3554	public function getValue ( ) { if ( $ this -> hasMutator ( $ this -> attributes [ 'meta_value' ] , 'getter' , $ this -> attributes [ 'meta_type' ] ) ) { return $ this -> mutateValue ( $ this -> attributes [ 'meta_value' ] , 'getter' ) ; } return $ this -> castValue ( ) ; }
10967	public static function isSsl ( ) { $ isSecure = false ; if ( isset ( $ _SERVER [ 'HTTPS' ] ) && in_array ( $ _SERVER [ 'HTTPS' ] , [ 'on' , '1' ] ) ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] == 'https' ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] == 'on' ) { $ isSecure = true ; } return $ isSecure ; }
6249	protected function prepareForPresentation ( ) { if ( $ this -> prepared ) { return ; } $ this -> permissionGroups = new Collection ; $ this -> ungroupedPermissions = [ ] ; $ this -> groupedPermissionIndex = [ ] ; $ this -> loadPermissionsFromModules ( ) -> loadCustomPermissions ( ) -> loadCustomPermissionGroups ( ) -> addUngroupedPermissionGroup ( ) -> filterEmptyGroups ( ) ; }
5819	private function createAlertsForType ( $ type , array $ messages ) { $ alerts = array ( ) ; foreach ( $ messages as $ msg ) { $ alerts [ ] = new Alert ( $ type , $ msg ) ; } return $ alerts ; }
7878	protected function registerLogFilesystem ( ) { $ this -> app -> singleton ( 'logviewer.filesystem' , function ( $ app ) { $ files = $ app [ 'files' ] ; $ path = $ app [ 'path.storage' ] . '/logs' ; return new Filesystem ( $ files , $ path ) ; } ) ; $ this -> app -> alias ( 'logviewer.filesystem' , Filesystem :: class ) ; }
4304	public function profileEnd ( $ name = null ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'name' => null ) , array ( 'name' ) ) ; if ( $ meta [ 'name' ] === null ) { \ end ( $ this -> data [ 'profileInstances' ] ) ; $ meta [ 'name' ] = \ key ( $ this -> data [ 'profileInstances' ] ) ; } $ name = $ meta [ 'name' ] ; if ( isset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ) { $ instance = $ this -> data [ 'profileInstances' ] [ $ name ] ; $ data = $ instance -> end ( ) ; $ caption = 'Profile \'' . $ name . '\' Results' ; if ( $ data ) { $ args = array ( $ data ) ; $ meta [ 'sortable' ] = true ; $ meta [ 'caption' ] = $ caption ; $ meta [ 'totalCols' ] = array ( 'ownTime' ) ; $ meta [ 'columns' ] = array ( ) ; } else { $ args = array ( $ caption , 'no data' ) ; } unset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ; } else { $ args = array ( $ name !== null ? 'profileEnd: No such Profile: ' . $ name : 'profileEnd: Not currently profiling' ) ; } $ this -> appendLog ( __FUNCTION__ , $ args , $ meta ) ; }
11493	public function removeAll ( ) : array { $ res = [ ] ; foreach ( $ this -> getKeys ( ) as $ key ) { $ res [ $ key ] = $ this -> remove ( $ key ) ; } return $ res ; }
2676	public function upsertAclItem ( $ aclId , $ itemValue , $ negated , $ comment = 'Added by Magento Module' , $ subnet = false ) { $ body = [ 'ip' => $ itemValue , 'negated' => $ negated , 'comment' => $ comment ] ; if ( $ subnet ) { $ body [ 'subnet' ] = $ subnet ; } $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: POST , $ body ) ; return $ result ; }
10512	private function orderObserversForPriority ( $ a , $ b ) { if ( $ a -> order > $ b -> order ) { return + 1 ; } elseif ( $ a -> order == $ b -> order ) { return 0 ; } return - 1 ; }
9267	public function recipe ( string $ string , string $ method , callable $ callback = null ) : string { return preg_replace_callback ( RegEx :: REGEX_SPACE , [ $ this , $ method ] , $ this -> callback ( $ string , $ callback ) ) ; }
10398	protected function doReplacement ( $ inputString ) { if ( is_string ( $ inputString ) ) { $ inputString = str_replace ( array_keys ( $ this -> replacements ) , array_values ( $ this -> replacements ) , $ inputString ) ; } return $ inputString ; }
11784	public function update ( $ pageId , $ title , $ description , $ pageUrl , $ iconUrl , $ comment = '' ) { $ params = [ 'page_id' => intval ( $ pageId ) , 'title' => $ title , 'description' => $ description , 'page_url' => $ pageUrl , 'icon_url' => $ iconUrl , ] ; if ( $ comment !== '' ) { $ params [ 'comment' ] = $ comment ; } return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
11033	public function init ( ) { $ this -> _file = \ Yii :: getAlias ( $ this -> path . '/config/' . self :: FILENAME ) ; $ this -> loadFromFile ( ) ; }
2563	protected function loadBusinessId ( PointOfRefSearchOptions $ params ) { if ( $ this -> checkAnyNotEmpty ( $ params -> businessCategory , $ params -> businessForeignKey ) ) { $ this -> porFndQryParams -> businessId = new BusinessId ( $ params -> businessCategory , $ params -> businessForeignKey ) ; } }
8571	public function listRecommendations ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_ListRecommendationsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_ListRecommendationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRecommendations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_ListRecommendationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8976	public static function typeOf ( $ arg ) { if ( null === $ arg ) { return 'NULL' ; } if ( is_object ( $ arg ) ) { return get_class ( $ arg ) ; } return gettype ( $ arg ) ; }
1889	protected function getPathNodes ( ) { if ( ! $ this -> varValue ) { return ; } if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( $ this -> varValue ) ; } foreach ( $ this -> varValue as $ id ) { $ arrPids = $ this -> Database -> getParentRecords ( $ id , 'tl_page' ) ; array_shift ( $ arrPids ) ; $ this -> arrNodes = array_merge ( $ this -> arrNodes , $ arrPids ) ; } }
8113	public function getReviewDate ( SiteTree $ page = null ) { if ( $ page === null ) { $ page = $ this -> owner ; } if ( $ page -> obj ( 'NextReviewDate' ) -> exists ( ) ) { return $ page -> obj ( 'NextReviewDate' ) ; } $ options = $ this -> owner -> getOptions ( ) ; if ( ! $ options ) { return false ; } if ( ! $ options -> ReviewPeriodDays ) { return false ; } $ nextReviewUnixSec = strtotime ( ' + ' . $ options -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ date = DBDate :: create ( 'NextReviewDate' ) ; $ date -> setValue ( $ nextReviewUnixSec ) ; return $ date ; }
12130	public function clear ( ) { $ this -> _repeat = 1 ; $ this -> _startTime = 0 ; $ this -> _duration = 0 ; $ this -> _average = 0 ; $ this -> _rate = 0 ; $ this -> _startMem = 0 ; $ this -> _memory = 0 ; }
8693	public static function createSymlink ( $ symlinkTarget , $ symlinkName ) { if ( false === @ symlink ( $ symlinkTarget , $ symlinkName ) ) { throw new \ UnexpectedValueException ( "An error occurred while creating symlink '{$symlinkName}'" ) ; } if ( false === $ target = readlink ( $ symlinkName ) ) { throw new \ UnexpectedValueException ( "Symlink {$symlinkName} points to target {$target}" ) ; } }
795	public function load ( $ data , $ formName = null ) { $ scope = $ formName === null ? $ this -> formName ( ) : $ formName ; if ( $ scope === '' && ! empty ( $ data ) ) { $ this -> setAttributes ( $ data ) ; return true ; } elseif ( isset ( $ data [ $ scope ] ) ) { $ this -> setAttributes ( $ data [ $ scope ] ) ; return true ; } return false ; }
1616	public function count ( $ q = '*' , $ db = null ) { if ( $ this -> emulateExecution ) { return 0 ; } if ( $ this -> where === null ) { $ modelClass = $ this -> modelClass ; if ( $ db === null ) { $ db = $ modelClass :: getDb ( ) ; } return $ db -> executeCommand ( 'LLEN' , [ $ modelClass :: keyPrefix ( ) ] ) ; } else { return $ this -> executeScript ( $ db , 'Count' ) ; } }
8771	public function registerConfiguredProviders ( ) { $ providers = Collection :: make ( $ this -> config [ 'app.providers' ] ) -> partition ( function ( $ provider ) { return Str :: startsWith ( $ provider , 'Nur\\' ) ; } ) ; $ providers -> splice ( 1 , 0 , [ $ this -> make ( PackageManifest :: class ) -> providers ( ) ] ) ; ( new ProviderRepository ( $ this , new Filesystem , $ this -> getCachedServicesPath ( ) ) ) -> load ( $ providers -> collapse ( ) -> toArray ( ) ) ; }
3854	public function setMetaModel ( $ intMetaModel , $ intView ) { $ this -> intMetaModel = $ intMetaModel ; $ this -> intView = $ intView ; $ this -> prepareMetaModel ( ) ; $ this -> prepareView ( ) ; return $ this ; }
3417	protected function getValueFromLanguageField ( $ field ) { $ key = $ field . '_' . $ this -> getCurrentLanguage ( ) ; return isset ( $ this -> fields [ $ key ] ) ? $ this -> fields [ $ key ] : null ; }
6081	public function removeMedia ( $ id , $ hardDelete = false ) { $ parameters = [ 'query' => [ 'hardDelete' => $ hardDelete ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/media/' . $ id . '' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
10815	public function authenticate ( $ authMethod , $ options ) { $ sm = $ this -> getServiceManager ( ) ; $ authListener = $ sm -> get ( $ authMethod ) ; $ authListener -> setOptions ( $ options ) ; $ this -> getHttpClient ( ) -> getEventManager ( ) -> attachAggregate ( $ authListener ) ; }
8336	public function setValueMutator ( callable $ callback ) : self { $ this -> valueMutator = $ callback ; $ this -> value = ( $ this -> valueMutator ) ( $ this -> value ) ; return $ this ; }
3741	protected function getLabelParameters ( EnvironmentInterface $ environment , ModelInterface $ model ) { if ( $ model -> getProperty ( 'type' ) == 'simplelookup' ) { return $ this -> getLabelParametersWithAttributeAndUrlParam ( $ environment , $ model ) ; } return $ this -> getLabelParametersNormal ( $ environment , $ model ) ; }
5784	public function routePutUpdate ( Request $ request , Response $ response , $ args ) { if ( ! $ this -> authorization -> isAuthorized ( constant ( strtoupper ( $ this -> routePrefix ) . "_UPDATE_RESOURCE" ) ) ) { throw new \ Exception ( 'No permission.' ) ; } $ primaryKeyValue = $ args [ ROUTEARG_PRIMARY_KEY ] ; $ this -> setRequestInput ( $ request , DatabaseTableForm :: getFieldNames ( $ this -> tableMapper ) , $ this -> tableMapper -> getBooleanColumnNames ( ) ) ; $ redirectRoute = SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ; if ( null === $ record = $ this -> tableMapper -> selectForPrimaryKey ( $ primaryKeyValue ) ) { return $ this -> databaseRecordNotFound ( $ response , $ primaryKeyValue , $ this -> tableMapper , 'update' ) ; } $ changedColumnsValues = $ this -> getMapper ( ) -> getChangedColumnsValues ( $ this -> requestInput , $ record ) ; if ( count ( $ changedColumnsValues ) == 0 ) { SlimPostgres :: setAdminNotice ( "No changes made" , 'failure' ) ; return $ this -> view -> updateView ( $ request , $ response , $ args ) ; } $ validator = new DatabaseTableUpdateFormValidator ( $ this -> requestInput , $ this -> tableMapper , $ record ) ; if ( ! $ validator -> validate ( ) ) { FormHelper :: setFieldErrors ( $ validator -> getFirstErrors ( ) ) ; $ args [ SlimPostgres :: USER_INPUT_KEY ] = $ this -> requestInput ; return $ this -> view -> updateView ( $ request , $ response , $ args ) ; } $ this -> tableMapper -> updateByPrimaryKey ( $ changedColumnsValues , $ primaryKeyValue ) ; $ this -> enterEventAndNotice ( 'update' , $ primaryKeyValue ) ; return $ response -> withRedirect ( $ this -> router -> pathFor ( $ redirectRoute ) ) ; }
9825	public function writeDrawingRelationships ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet , & $ chartRef , $ includeCharts = false ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ i = 1 ; $ iterator = $ pWorksheet -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { if ( $ iterator -> current ( ) instanceof \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Drawing || $ iterator -> current ( ) instanceof MemoryDrawing ) { $ this -> writeRelationship ( $ objWriter , $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image' , '../media/' . str_replace ( ' ' , '' , $ iterator -> current ( ) -> getIndexedFilename ( ) ) ) ; } $ iterator -> next ( ) ; ++ $ i ; } if ( $ includeCharts ) { $ chartCount = $ pWorksheet -> getChartCount ( ) ; if ( $ chartCount > 0 ) { for ( $ c = 0 ; $ c < $ chartCount ; ++ $ c ) { $ this -> writeRelationship ( $ objWriter , $ i ++ , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart' , '../charts/chart' . ++ $ chartRef . '.xml' ) ; } } } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
9132	protected function validate ( $ config , $ name , $ path ) { if ( ! is_array ( $ config ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The definition of "%s" in "%s" must be a YAML array.' , $ name , $ path ) ) ; } if ( $ extraKeys = array_diff ( array_keys ( $ config ) , self :: $ availableKeys ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The routing file "%s" contains unsupported keys for "%s": "%s". Expected one of: "%s".' , $ path , $ name , implode ( '", "' , $ extraKeys ) , implode ( '", "' , self :: $ availableKeys ) ) ) ; } if ( isset ( $ config [ 'resource' ] ) && isset ( $ config [ 'expression' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The business rule file "%s" must not specify both the "resource" key and the "expression" key for "%s". Choose between an import and a rule definition.' , $ path , $ name ) ) ; } if ( ! isset ( $ config [ 'resource' ] ) && isset ( $ config [ 'type' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "type" key for the rule definition "%s" in "%s" is unsupported. It is only available for imports in combination with the "resource" key.' , $ name , $ path ) ) ; } if ( ! isset ( $ config [ 'resource' ] ) && ! isset ( $ config [ 'expression' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'You must define an "expression" for the rule "%s" in file "%s".' , $ name , $ path ) ) ; } if ( isset ( $ config [ 'tags' ] ) && ! is_array ( $ config [ 'tags' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "tags" key for the rule definition "%s" in "%s" contains unsupported data. Each tag defined must be an array with at least the "name" element set to a string.' , $ name , $ path ) ) ; } elseif ( isset ( $ config [ 'tags' ] ) ) { foreach ( $ config [ 'tags' ] as $ tag ) { if ( ! isset ( $ tag [ 'name' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "tags" key for the rule definition "%s" in "%s" contains unsupported data. Each tag defined must be an array with at least the "name" element set to a string.' , $ name , $ path ) ) ; } } } }
1689	public function updateStyleSheets ( ) { $ objStyleSheets = $ this -> Database -> execute ( "SELECT * FROM tl_style_sheet" ) ; $ arrStyleSheets = $ objStyleSheets -> fetchEach ( 'name' ) ; if ( file_exists ( $ this -> strRootDir . '/system/config/dcaconfig.php' ) ) { @ trigger_error ( 'Using the dcaconfig.php file has been deprecated and will no longer work in Contao 5.0. Create one or more DCA files in app/Resources/contao/dca instead.' , E_USER_DEPRECATED ) ; include $ this -> strRootDir . '/system/config/dcaconfig.php' ; } foreach ( scan ( $ this -> strRootDir . '/assets/css' , true ) as $ file ) { if ( is_dir ( $ this -> strRootDir . '/assets/css/' . $ file ) ) { continue ; } if ( \ is_array ( Config :: get ( 'rootFiles' ) ) && \ in_array ( $ file , Config :: get ( 'rootFiles' ) ) ) { continue ; } if ( preg_match ( '/^[a-f0-9]{12}\.css$/' , $ file ) ) { continue ; } $ objFile = new File ( 'assets/css/' . $ file ) ; if ( $ objFile -> extension == 'css' && ! \ in_array ( $ objFile -> filename , $ arrStyleSheets ) ) { $ objFile -> delete ( ) ; } } $ objStyleSheets -> reset ( ) ; while ( $ objStyleSheets -> next ( ) ) { $ this -> writeStyleSheet ( $ objStyleSheets -> row ( ) ) ; $ this -> log ( 'Generated style sheet "' . $ objStyleSheets -> name . '.css"' , __METHOD__ , TL_CRON ) ; } }
9444	public function getName ( ) { static $ names = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ names [ $ me ] ) ) { $ names [ $ me ] = $ this -> getReflector ( ) -> getShortName ( ) ; $ suffix = defined ( 'static::PACK_SUFFIX' ) ? static :: PACK_SUFFIX : 'Pack' ; if ( strrpos ( $ names [ $ me ] , $ suffix ) == ( strlen ( $ names [ $ me ] ) - strlen ( $ suffix ) ) ) { $ names [ $ me ] = substr ( $ names [ $ me ] , 0 , strlen ( $ names [ $ me ] ) - strlen ( $ suffix ) ) ; } } return $ names [ $ me ] ; }
11379	public function putAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)\/(\w+)$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } list ( $ dummy , $ pageName , $ language , $ oldName ) = $ matches ; $ request = $ this -> environment -> getRequestHelper ( ) ; $ newName = $ request -> getIdentifierParam ( 'name' ) ; $ content = $ request -> getParam ( 'content' , '' ) ; try { $ pageTexts = $ this -> getTextModel ( $ pageName ) ; $ text = $ pageTexts -> modifyTextContainer ( $ oldName , $ newName , $ this -> filter ( $ content ) , $ language ) ; $ this -> environment -> sendJSONResult ( $ text ) ; } catch ( \ Exception $ e ) { throw new InvalidParameterException ( $ e -> getMessage ( ) ) ; } }
2414	protected function addTableTlModule ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_module' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_module' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_module' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; $ objModule = $ this -> Database -> prepare ( "SELECT * FROM tl_module WHERE pid=? ORDER BY name" ) -> execute ( $ objTheme -> id ) ; while ( $ objModule -> next ( ) ) { $ this -> addDataRow ( $ xml , $ table , $ objModule -> row ( ) , $ arrOrder ) ; } }
3927	public function setValueOptionsMultiple ( ManipulateWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( $ event -> getModel ( ) -> getProperty ( 'type' ) !== 'conditionpropertycontainanyof' ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ attribute = $ metaModel -> getAttributeById ( $ event -> getModel ( ) -> getProperty ( 'attr_id' ) ) ; if ( ! ( $ attribute && ( $ attribute -> get ( 'type' ) == 'tags' ) ) ) { return ; } $ event -> getWidget ( ) -> multiple = true ; }
1485	public function prepend ( Decoding ... $ decodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ decodings ) ; return $ copy ; }
5192	public function map ( array $ methods , string $ path , RequestHandlerInterface $ handler ) : Route { return $ this -> routes [ ] = new Route ( $ methods , $ path , $ handler ) ; }
10517	private function getMediaIdentifiers ( $ values ) { $ identifiers = [ ] ; foreach ( $ values as $ key => $ id ) { if ( is_int ( $ key ) ) { $ identifiers [ ] = $ id ; } } return $ identifiers ; }
1076	private static function isMissingVariable ( $ valueNode , $ variables ) { return $ valueNode instanceof VariableNode && ( count ( $ variables ) === 0 || ! array_key_exists ( $ valueNode -> name -> value , $ variables ) ) ; }
3272	public function setConfig ( Config $ config ) { $ this -> config = $ config ; $ this -> getDatabase ( ) -> setConfig ( $ config ) ; }
5134	private static function createUri ( string $ scheme , string $ host , ? int $ port , string $ user , string $ password , string $ path , string $ query , string $ fragment ) : \ One \ Uri { return new Uri ( $ scheme , $ host , $ port , $ path , $ query , $ fragment , $ user , $ password ) ; }
5988	public function setUpdatedRange ( $ updatedRange ) { if ( $ updatedRange instanceof DateTimeRange ) { $ this -> updatedRange = $ updatedRange ; } elseif ( is_array ( $ updatedRange ) ) { $ this -> updatedRange = new DateTimeRange ( $ updatedRange ) ; } else { $ this -> updatedRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
6429	public function getLoginStartUrl ( $ redirecturl ) { $ facebook = $ this -> getFacebookObject ( ) ; $ helper = $ facebook -> getRedirectLoginHelper ( ) ; $ permissions = [ 'email' ] ; $ loginUrl = $ helper -> getLoginUrl ( $ redirecturl , $ permissions ) ; return $ loginUrl ; }
1012	private function readDigits ( ) { [ $ char , $ code ] = $ this -> readChar ( ) ; if ( $ code >= 48 && $ code <= 57 ) { $ value = '' ; do { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; } while ( $ code >= 48 && $ code <= 57 ) ; return $ value ; } if ( $ this -> position > $ this -> source -> length - 1 ) { $ code = null ; } throw new SyntaxError ( $ this -> source , $ this -> position , 'Invalid number, expected digit but got: ' . Utils :: printCharCode ( $ code ) ) ; }
5386	public function isLabel ( $ label ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> widgets [ $ i ] -> isLabel ( $ label ) ) { return true ; } } return false ; }
7527	private function nest ( $ x , $ node , $ end = false ) { array_push ( $ x -> stmtStack , $ node ) ; $ n = $ this -> statement ( $ x ) ; array_pop ( $ x -> stmtStack ) ; if ( $ end ) $ this -> t -> mustMatch ( $ end ) ; return $ n ; }
8474	public function notice ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'notice' , $ scope , $ message , $ context , $ config ) ; }
4487	public function send ( $ message , string $ endpointArn ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $endpointArn" , [ 'Message' => $ message , ] ) ; return ; } if ( ! ( $ message instanceof Message ) ) { $ message = new Message ( $ message ) ; } $ this -> sns -> publish ( [ 'TargetArn' => $ endpointArn , 'Message' => $ this -> encodeMessage ( $ message ) , 'MessageStructure' => 'json' , ] ) ; }
3575	public function forget ( $ key ) { if ( $ attribute = $ this -> get ( $ key ) ) { $ attribute -> setValue ( null ) ; } return $ this ; }
831	private function fixConstructor ( Tokens $ tokens , $ className , $ classStart , $ classEnd ) { $ php4 = $ this -> findFunction ( $ tokens , $ className , $ classStart , $ classEnd ) ; if ( null === $ php4 ) { return ; } if ( ! empty ( $ php4 [ 'modifiers' ] [ T_ABSTRACT ] ) || ! empty ( $ php4 [ 'modifiers' ] [ T_STATIC ] ) ) { return ; } $ php5 = $ this -> findFunction ( $ tokens , '__construct' , $ classStart , $ classEnd ) ; if ( null === $ php5 ) { $ tokens [ $ php4 [ 'nameIndex' ] ] = new Token ( [ T_STRING , '__construct' ] ) ; $ this -> fixInfiniteRecursion ( $ tokens , $ php4 [ 'bodyIndex' ] , $ php4 [ 'endIndex' ] ) ; return ; } list ( $ seq , $ case ) = $ this -> getWrapperMethodSequence ( $ tokens , '__construct' , $ php4 [ 'startIndex' ] , $ php4 [ 'bodyIndex' ] ) ; if ( null !== $ tokens -> findSequence ( $ seq , $ php4 [ 'bodyIndex' ] - 1 , $ php4 [ 'endIndex' ] , $ case ) ) { for ( $ i = $ php4 [ 'startIndex' ] ; $ i <= $ php4 [ 'endIndex' ] ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } return ; } list ( $ seq , $ case ) = $ this -> getWrapperMethodSequence ( $ tokens , $ className , $ php4 [ 'startIndex' ] , $ php4 [ 'bodyIndex' ] ) ; if ( null !== $ tokens -> findSequence ( $ seq , $ php5 [ 'bodyIndex' ] - 1 , $ php5 [ 'endIndex' ] , $ case ) ) { for ( $ i = $ php5 [ 'startIndex' ] ; $ i <= $ php5 [ 'endIndex' ] ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ tokens [ $ php4 [ 'nameIndex' ] ] = new Token ( [ T_STRING , '__construct' ] ) ; } }
9502	public function runPeridot ( InputInterface $ input , OutputInterface $ output ) { global $ argv ; $ command = $ this -> joinCommand ( $ argv ) ; $ process = new Process ( $ command ) ; $ process -> run ( function ( $ type , $ buffer ) use ( $ output ) { $ buffer = preg_replace ( '/\[([\d]{1,2})m/' , "\033[$1m" , $ buffer ) ; $ output -> write ( $ buffer ) ; } ) ; }
5160	public function getAttachmentByField ( string $ field ) : array { if ( isset ( $ this -> attachment [ $ field ] ) ) { return $ this -> attachment [ $ field ] ; } return [ ] ; }
2389	private function applyFallback ( array & $ config , array $ action , bool $ skipLegends = false ) : void { if ( \ is_callable ( $ action [ 'fallback' ] ) ) { $ action [ 'fallback' ] ( $ config , $ action , $ skipLegends ) ; } else { $ this -> applyFallbackPalette ( $ config , $ action ) ; } }
8946	public function changePreference ( $ key , $ preference ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/preferences/' . $ key ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ preference ) ; return $ response -> body ; }
7397	public function header ( string $ name , string $ value ) : bool { if ( ! empty ( $ name ) && ! empty ( $ value ) && ! headers_sent ( ) ) { header ( $ name . ': ' . $ value ) ; return true ; } return false ; }
5924	public function setFilterItems ( array $ filterItems ) { $ this -> filterItems = [ ] ; foreach ( $ filterItems as $ item ) { $ this -> addFilterItem ( $ item ) ; } return $ this ; }
4497	private function getAndroidJsonInner ( ? string $ text ) : array { $ data = [ ] ; if ( null !== $ text ) { $ data [ 'message' ] = $ text ; } if ( null !== $ this -> localizedKey ) { $ data [ 'message-loc-key' ] = $ this -> localizedKey ; if ( $ this -> localizedArguments ) { $ data [ 'message-loc-args' ] = $ this -> localizedArguments ; } } return $ data ; }
748	protected function buildCompleteString ( $ format ) { $ placeholderValues = [ '{type}' => $ this -> type , '{length}' => $ this -> buildLengthString ( ) , '{unsigned}' => $ this -> buildUnsignedString ( ) , '{notnull}' => $ this -> buildNotNullString ( ) , '{unique}' => $ this -> buildUniqueString ( ) , '{default}' => $ this -> buildDefaultString ( ) , '{check}' => $ this -> buildCheckString ( ) , '{comment}' => $ this -> buildCommentString ( ) , '{pos}' => $ this -> isFirst ? $ this -> buildFirstString ( ) : $ this -> buildAfterString ( ) , '{append}' => $ this -> buildAppendString ( ) , ] ; return strtr ( $ format , $ placeholderValues ) ; }
12449	static function run_check_gnu_files ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; if ( $ opts [ 'files' ] [ 'gnu_dir' ] ) { $ destdir .= '/' . $ opts [ 'files' ] [ 'gnu_dir' ] ; } $ files = pakeFinder :: type ( 'file' ) -> name ( array ( 'README' , 'LICENSE' ) ) -> maxdepth ( 0 ) -> in ( $ destdir ) ; if ( count ( $ files ) != 2 ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "README and/or LICENSE files missing. Please fix" ) ; } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
197	public function setDownloadHeaders ( $ attachmentName , $ mimeType = null , $ inline = false , $ contentLength = null ) { $ headers = $ this -> getHeaders ( ) ; $ disposition = $ inline ? 'inline' : 'attachment' ; $ headers -> setDefault ( 'Pragma' , 'public' ) -> setDefault ( 'Accept-Ranges' , 'bytes' ) -> setDefault ( 'Expires' , '0' ) -> setDefault ( 'Cache-Control' , 'must-revalidate, post-check=0, pre-check=0' ) -> setDefault ( 'Content-Disposition' , $ this -> getDispositionHeaderValue ( $ disposition , $ attachmentName ) ) ; if ( $ mimeType !== null ) { $ headers -> setDefault ( 'Content-Type' , $ mimeType ) ; } if ( $ contentLength !== null ) { $ headers -> setDefault ( 'Content-Length' , $ contentLength ) ; } return $ this ; }
4458	public function fire ( AbstractUserEvent $ event ) { $ status = null ; $ type = $ event :: getEntityName ( ) ; if ( isset ( $ this -> events [ $ type ] ) ) { $ queue = $ this -> events [ $ type ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } $ eventName = $ event -> getName ( ) ; if ( isset ( $ this -> events [ $ eventName ] ) ) { $ queue = $ this -> events [ $ eventName ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } return $ status ; }
1287	private function fetchCollectionFromApi ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , $ resourceIds ) ; if ( 'Asset' === $ type || 'Entry' === $ type ) { $ query -> setLocale ( $ locale ) ; } switch ( $ type ) { case 'Asset' : return $ this -> client -> getAssets ( $ query ) -> getItems ( ) ; case 'ContentType' : return $ this -> client -> getContentTypes ( $ query ) -> getItems ( ) ; case 'Entry' : return $ this -> client -> getEntries ( $ query ) -> getItems ( ) ; case 'Environment' : return [ $ this -> client -> getEnvironment ( ) ] ; case 'Space' : return [ $ this -> client -> getSpace ( ) ] ; default : throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to resolve link for unknown type "%s".' , $ type ) ) ; } }
5690	public static function normalise ( $ html ) { $ rules = array ( '#<!--.*? , '#<(script|option|textarea)[^>]*>.*?</\1>#si' , '#<img[^>]*alt\s*=\s*("([^"]*)"|\'([^\']*)\'|([a-zA-Z_]+))[^>]*>#' , '#<[^>]*>#' , ) ; $ replace = array ( '' , '' , ' \2\3\4 ' , '' , ) ; $ text = preg_replace ( $ rules , $ replace , $ html ) ; $ text = html_entity_decode ( $ text , ENT_QUOTES ) ; $ text = preg_replace ( '#\s+#' , ' ' , $ text ) ; return trim ( trim ( $ text ) , "\xA0" ) ; }
5936	public function addGroup ( $ item ) { if ( ! ( $ item instanceof Group ) ) { if ( is_array ( $ item ) ) { try { $ item = new Group ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Group. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Group"!' , E_USER_WARNING ) ; } } $ this -> groups [ ] = $ item ; return $ this ; }
5535	public function divideMapNodes ( $ map , $ aspect ) { $ aspect = ! $ aspect ; $ divisions = $ map -> getSize ( ) ; $ total = $ map -> getTotalSize ( ) ; foreach ( $ map -> getChildren ( ) as $ node ) { if ( ! $ node -> isLeaf ( ) ) { $ dist = $ node -> getTotalSize ( ) / $ total * 100 ; } else { $ dist = 1 / $ total * 100 ; } if ( $ aspect ) { $ horiz = $ dist ; $ vert = 100 ; } else { $ horiz = 100 ; $ vert = $ dist ; } $ this -> paintRectangleStart ( $ node , $ horiz , $ vert ) ; $ this -> divideMapNodes ( $ node , $ aspect ) ; $ this -> paintRectangleEnd ( ) ; } }
4282	public function stream_truncate ( $ size ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ ftruncate ( $ this -> handle , $ size ) ; self :: register ( ) ; return $ success ; }
4559	protected function execute ( LifecycleEventArgs $ args , $ action ) { $ this -> tokenStorage = $ this -> container -> get ( 'security.token_storage' ) ; $ this -> configService = $ this -> container -> get ( 'ds_config.service.config' ) ; $ this -> auditService = $ this -> container -> get ( 'ds_audit.service.audit' ) ; $ entity = $ args -> getEntity ( ) ; if ( $ entity instanceof Audit ) { return ; } if ( ! $ entity instanceof Auditable ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( ! $ token ) { return ; } $ user = $ token -> getUser ( ) ; $ edits = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getEntityChangeSet ( $ entity ) ; $ properties = $ this -> auditService -> getProperties ( $ entity ) ; foreach ( array_keys ( $ edits ) as $ key ) { if ( ! in_array ( $ key , $ properties ) ) { unset ( $ edits [ $ key ] ) ; } } $ audit = $ this -> auditService -> createInstance ( ) ; $ audit -> setOwner ( $ this -> configService -> get ( 'ds_audit.audit.owner' ) ) -> setOwnerUuid ( $ this -> configService -> get ( 'ds_audit.audit.owner_uuid' ) ) -> setUserUuid ( $ user -> getUuid ( ) ) -> setIdentity ( $ user -> getIdentity ( ) -> getType ( ) ) -> setIdentityUuid ( $ user -> getIdentity ( ) -> getUuid ( ) ) -> setAction ( $ action ) -> setData ( [ 'entity' => basename ( str_replace ( '\\' , '/' , get_class ( $ entity ) ) ) , 'entityUuid' => $ entity -> getUuid ( ) , 'edits' => $ edits ] ) ; $ manager = $ this -> auditService -> getManager ( ) ; $ manager -> persist ( $ audit ) ; $ manager -> flush ( ) ; }
4504	public function item ( $ index ) { $ count = 0 ; foreach ( $ this as $ element ) { if ( $ index === $ count ) { return $ element ; } $ count ++ ; } return null ; }
6518	public static function fromDateTime ( \ DateTimeInterface $ date ) { $ str = $ date -> format ( 'U' ) . str_pad ( $ date -> format ( 'u' ) , 6 , '0' ) ; $ m = new self ( ) ; $ m -> int = ( int ) $ str ; $ m -> sec = ( int ) substr ( $ str , 0 , 10 ) ; $ m -> usec = ( int ) substr ( $ str , - 6 ) ; return $ m ; }
7523	function parse_tag_default ( ) { if ( $ this -> status [ 'closing_tag' ] ) { $ this -> status [ 'attributes' ] = array ( ) ; $ this -> next_no_whitespace ( ) ; } else { if ( ! $ this -> parse_attributes ( ) ) { return false ; } } if ( $ this -> token !== self :: TOK_TAG_CLOSE ) { if ( $ this -> token === self :: TOK_SLASH_FORWARD ) { $ this -> status [ 'self_close' ] = true ; $ this -> next ( ) ; } elseif ( ( ( $ this -> status [ 'tag_name' ] [ 0 ] === '?' ) && ( $ this -> doc [ $ this -> pos ] === '?' ) ) || ( ( $ this -> status [ 'tag_name' ] [ 0 ] === '%' ) && ( $ this -> doc [ $ this -> pos ] === '%' ) ) ) { $ this -> status [ 'self_close' ] = true ; $ this -> pos ++ ; if ( isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) && ( ! is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) ) { $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ; } else { $ this -> token = self :: TOK_UNKNOWN ; } } } if ( $ this -> token !== self :: TOK_TAG_CLOSE ) { $ this -> addError ( 'Expected ">", but found "' . $ this -> getTokenString ( ) . '"' ) ; if ( $ this -> next_pos ( '>' , false ) !== self :: TOK_UNKNOWN ) { $ this -> addError ( 'No ">" tag found for "' . $ this -> status [ 'tag_name' ] . '" tag' ) ; return false ; } } return true ; }
8464	public static function getDomain ( $ url = false ) { if ( $ url ) { preg_match ( '/([\w]+[.]){1,}[a-z]+/' , $ url , $ matches ) ; return isset ( $ matches [ 0 ] ) ? $ matches [ 0 ] : false ; } return $ _SERVER [ 'SERVER_NAME' ] ; }
2252	protected function redirectToFrontendPage ( $ intPage , $ strArticle = null , $ blnReturn = false ) { if ( ( $ intPage = ( int ) $ intPage ) <= 0 ) { return '' ; } $ objPage = PageModel :: findWithDetails ( $ intPage ) ; if ( $ objPage === null ) { return '' ; } $ strParams = null ; if ( $ strArticle !== null && ( $ objArticle = ArticleModel :: findByAlias ( $ strArticle ) ) !== null ) { $ strParams = '/articles/' . ( ( $ objArticle -> inColumn != 'main' ) ? $ objArticle -> inColumn . ':' : '' ) . $ strArticle ; } $ strUrl = $ objPage -> getFrontendUrl ( $ strParams ) ; if ( strncmp ( $ strUrl , 'http://' , 7 ) !== 0 && strncmp ( $ strUrl , 'https://' , 8 ) !== 0 ) { $ strUrl = Environment :: get ( 'base' ) . $ strUrl ; } if ( ! $ blnReturn ) { $ this -> redirect ( $ strUrl ) ; } return $ strUrl ; }
5330	public function getEmojiPattern ( ) { if ( null === self :: $ emojiPattern ) { $ codeString = '' ; foreach ( $ this -> getEmojiCodeList ( ) as $ code ) { if ( is_array ( $ code ) ) { $ first = dechex ( array_shift ( $ code ) ) ; $ last = dechex ( array_pop ( $ code ) ) ; $ codeString .= '\x{' . $ first . '}-\x{' . $ last . '}' ; } else { $ codeString .= '\x{' . dechex ( $ code ) . '}' ; } } self :: $ emojiPattern = "/[$codeString]/u" ; } return self :: $ emojiPattern ; }
6022	public function request ( $ endPoint , $ httpVerb = 'GET' , $ data = array ( ) ) { if ( ! $ this -> apiKey ) { throw new \ Exception ( 'MailChimp API Key must be set before making request!' ) ; } $ endPoint = ltrim ( $ endPoint , '/' ) ; $ httpVerb = strtoupper ( $ httpVerb ) ; $ requestUrl = $ this -> apiUrl . $ endPoint ; return $ this -> curlRequest ( $ requestUrl , $ httpVerb , $ data ) ; }
356	public function init ( ) { parent :: init ( ) ; if ( $ this -> enableCoreCommands ) { foreach ( $ this -> coreCommands ( ) as $ id => $ command ) { if ( ! isset ( $ this -> controllerMap [ $ id ] ) ) { $ this -> controllerMap [ $ id ] = $ command ; } } } if ( ! isset ( $ this -> controllerMap [ 'help' ] ) ) { $ this -> controllerMap [ 'help' ] = 'yii\console\controllers\HelpController' ; } }
1087	public static function extractTypes ( $ type , ? array $ typeMap = null ) { if ( ! $ typeMap ) { $ typeMap = [ ] ; } if ( ! $ type ) { return $ typeMap ; } if ( $ type instanceof WrappingType ) { return self :: extractTypes ( $ type -> getWrappedType ( true ) , $ typeMap ) ; } if ( ! $ type instanceof Type ) { $ i = 0 ; $ alreadyInMap = false ; while ( isset ( $ typeMap [ $ i ] ) ) { $ alreadyInMap = $ alreadyInMap || $ typeMap [ $ i ] === $ type ; $ i ++ ; } if ( ! $ alreadyInMap ) { $ typeMap [ $ i ] = $ type ; } return $ typeMap ; } if ( ! empty ( $ typeMap [ $ type -> name ] ) ) { Utils :: invariant ( $ typeMap [ $ type -> name ] === $ type , sprintf ( 'Schema must contain unique named types but contains multiple types named "%s" ' , $ type ) . '(see http://webonyx.github.io/graphql-php/type-system/#type-registry).' ) ; return $ typeMap ; } $ typeMap [ $ type -> name ] = $ type ; $ nestedTypes = [ ] ; if ( $ type instanceof UnionType ) { $ nestedTypes = $ type -> getTypes ( ) ; } if ( $ type instanceof ObjectType ) { $ nestedTypes = array_merge ( $ nestedTypes , $ type -> getInterfaces ( ) ) ; } if ( $ type instanceof ObjectType || $ type instanceof InterfaceType ) { foreach ( $ type -> getFields ( ) as $ fieldName => $ field ) { if ( ! empty ( $ field -> args ) ) { $ fieldArgTypes = array_map ( static function ( FieldArgument $ arg ) { return $ arg -> getType ( ) ; } , $ field -> args ) ; $ nestedTypes = array_merge ( $ nestedTypes , $ fieldArgTypes ) ; } $ nestedTypes [ ] = $ field -> getType ( ) ; } } if ( $ type instanceof InputObjectType ) { foreach ( $ type -> getFields ( ) as $ fieldName => $ field ) { $ nestedTypes [ ] = $ field -> getType ( ) ; } } foreach ( $ nestedTypes as $ nestedType ) { $ typeMap = self :: extractTypes ( $ nestedType , $ typeMap ) ; } return $ typeMap ; }
7304	protected function updateFromParent ( CustomerInterface $ customer ) { if ( ! $ customer -> hasParent ( ) ) { if ( null === $ customer -> getDefaultInvoiceAddress ( ) ) { if ( false !== $ address = $ customer -> getAddresses ( ) -> first ( ) ) { $ address -> setInvoiceDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } } if ( null === $ customer -> getDefaultDeliveryAddress ( ) ) { if ( false !== $ address = $ customer -> getAddresses ( ) -> first ( ) ) { $ address -> setDeliveryDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } } return false ; } $ parent = $ customer -> getParent ( ) ; $ changed = false ; if ( empty ( $ customer -> getCompany ( ) ) ) { $ company = $ parent -> getCompany ( ) ; if ( $ company != $ customer -> getCompany ( ) ) { $ customer -> setCompany ( $ company ) ; $ changed = true ; } } $ group = $ parent -> getCustomerGroup ( ) ; if ( $ group !== $ customer -> getCustomerGroup ( ) ) { $ customer -> setCustomerGroup ( $ group ) ; $ changed = true ; } if ( ! empty ( $ customer -> getVatNumber ( ) ) ) { $ customer -> setVatNumber ( null ) ; $ changed = true ; } if ( ! empty ( $ customer -> getVatDetails ( ) ) ) { $ customer -> setVatDetails ( [ ] ) ; $ changed = true ; } if ( $ customer -> isVatValid ( ) ) { $ customer -> setVatValid ( false ) ; $ changed = true ; } if ( null !== $ customer -> getPaymentTerm ( ) ) { $ customer -> setPaymentTerm ( null ) ; $ changed = true ; } if ( 0 !== $ customer -> getOutstandingLimit ( ) ) { $ customer -> setOutstandingLimit ( 0 ) ; $ changed = true ; } return $ changed ; }
7181	protected function generateNumber ( PaymentInterface $ payment ) { if ( 0 == strlen ( $ payment -> getNumber ( ) ) ) { $ this -> numberGenerator -> generate ( $ payment ) ; return true ; } return false ; }
2020	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objFaq = FaqCategoryModel :: findAll ( ) ; if ( $ objFaq !== null ) { while ( $ objFaq -> next ( ) ) { if ( ! $ objFaq -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objFaq -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objFaq -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objFaq -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objFaq -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objFaq -> jumpTo ] ; $ objItems = FaqModel :: findPublishedByPid ( $ objFaq -> id ) ; if ( $ objItems !== null ) { while ( $ objItems -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItems -> alias ? : $ objItems -> id ) ) ; } } } } return $ arrPages ; }
10923	public function render ( ) { $ output = [ ] ; if ( count ( $ this -> rows ) > 0 ) { $ output [ ] = $ this -> renderLine ( ) ; } if ( count ( $ this -> columns ) > 0 ) { $ line = [ ] ; $ line [ ] = $ this -> charVertical ; $ columnNumber = 0 ; foreach ( $ this -> columns as $ index => $ column ) { $ title = $ column ; if ( isset ( $ this -> headers [ $ index ] ) ) { $ title = $ this -> headers [ $ index ] ; } $ line [ ] = $ this -> renderCell ( $ columnNumber , $ title , ' ' , 'info' ) ; $ line [ ] = $ this -> charVertical ; $ columnNumber ++ ; } $ output [ ] = implode ( '' , $ line ) ; } if ( count ( $ this -> rows ) > 0 ) { $ output [ ] = $ this -> renderLine ( ) ; foreach ( $ this -> rows as $ row ) { $ output [ ] = $ this -> renderRow ( $ row ) ; } $ output [ ] = $ this -> renderLine ( ) ; } return implode ( "\n" , $ output ) ; }
11675	public function homepageTemplate ( ) { if ( null === $ this -> homepageTemplate ) { $ homepageFile = $ this -> pagesDir . "/" . $ this -> homepage ( ) . '/page.json' ; $ page = json_decode ( FilesystemTools :: readFile ( $ homepageFile ) , true ) ; $ this -> homepageTemplate = $ page [ "template" ] ; } return $ this -> homepageTemplate ; }
11450	public function getParentUri ( ) { if ( $ this -> getParentName ( ) ) { $ func = $ this -> getParentName ( ) ; if ( ! is_string ( $ func ) ) { return ; } $ relat = $ this -> $ func ( ) ; $ parentResourceName = $ relat -> getRelated ( ) -> getResourceName ( ) ; $ field = $ relat -> getForeignKey ( ) ; if ( ! $ this -> $ field ) { return Api :: url ( ) ; } return Api :: url ( ) . '/' . $ parentResourceName . '/' . Api :: encodeHashId ( $ this -> $ field ) ; } return Api :: url ( ) ; }
12688	protected function load ( $ namespace , $ require = false ) { if ( isset ( $ this -> cache [ $ namespace ] ) ) { return $ this -> cache [ $ namespace ] ; } $ file = $ this -> getConfigFile ( $ namespace ) ; $ configuration = null ; try { $ configFile = new YamlConfiguration ( $ file ) ; $ configuration = $ configFile -> get ( ) ; if ( is_array ( $ configuration ) && ! empty ( $ configuration [ 'inherits' ] ) ) { $ allConfiguration = [ ] ; foreach ( $ configuration [ 'inherits' ] as $ parentNamespace ) { $ allConfiguration [ ] = $ this -> load ( $ parentNamespace ) ; } $ allConfiguration [ ] = $ configuration ; $ configuration = $ this -> merge ( $ allConfiguration ) ; unset ( $ allConfiguration , $ configuration [ 'inherits' ] ) ; } unset ( $ configFile ) ; } catch ( FileNotFoundException $ e ) { if ( $ require ) { throw new FileNotFoundException ( 'Could not find settings file for ' . $ namespace ) ; } } return $ this -> cache [ $ namespace ] = $ configuration ; }
7783	public function registerTimezoneScript ( $ actionRoute ) { Yii :: $ app -> on ( Controller :: EVENT_BEFORE_ACTION , function ( $ event ) use ( $ actionRoute ) { $ view = $ event -> sender -> view ; $ js = <<<JS var timezone = ''; var timezoneAbbr = ''; try { var timezone = Intl.DateTimeFormat().resolvedOptions().timeZone; var timezoneAbbr = /\((.*)\)/.exec(new Date().toString())[1]; } catch(err) { console.log(err); } $.post("$actionRoute", { timezone: timezone, timezoneAbbr: timezoneAbbr, timezoneOffset: -new Date().getTimezoneOffset() / 60 });JS ; $ view -> registerJs ( $ js ) ; } ) ; }
9464	private function registerLogViewerPackage ( ) { $ this -> registerProvider ( LogViewerServiceProvider :: class ) ; $ config = $ this -> config ( ) ; $ config -> set ( 'log-viewer.route.enabled' , false ) ; $ config -> set ( 'log-viewer.menu.filter-route' , $ config -> get ( 'arcanesoft.foundation.log-viewer.filter-route' ) ) ; }
10852	public function echo ( $ type , $ content ) { if ( $ this -> option ( 'debug' ) == false ) { return ; } if ( trim ( $ content ) ) { $ this -> { $ type } ( $ content ) ; } }
8194	public function render ( $ template , $ data = [ ] , $ return = true ) { if ( $ template instanceof Page ) { $ page = $ template ; $ file = $ page -> templateFile ( ) ; $ data = $ this -> data ( $ page , $ data ) ; } else { $ file = $ template ; $ data = $ this -> data ( null , $ data ) ; } if ( ! file_exists ( $ file ) ) { throw new Exception ( 'The template could not be found' ) ; } $ startData = Tpl :: $ data ; Tpl :: $ data = array_merge ( Tpl :: $ data , $ data ) ; if ( pathinfo ( $ file , PATHINFO_EXTENSION ) === 'twig' ) { $ twig = TwigEnv :: instance ( ) ; $ result = $ twig -> renderPath ( $ file , Tpl :: $ data , $ return , true ) ; } else { $ result = Tpl :: load ( $ file , [ ] , $ return ) ; } Tpl :: $ data = $ startData ; return $ result ; }
2362	public static function findFirstActiveWithJumpToByIds ( $ arrIds ) { @ trigger_error ( 'Using MemberGroupModel::findFirstActiveWithJumpToByIds() has been deprecated and will no longer work in Contao 5.0. Use PageModel::findFirstActiveByMemberGroups() instead.' , E_USER_DEPRECATED ) ; if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ time = Date :: floorToMinute ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> prepare ( "SELECT p.* FROM tl_member_group g LEFT JOIN tl_page p ON g.jumpTo=p.id WHERE g.id IN(" . implode ( ',' , $ arrIds ) . ") AND g.jumpTo>0 AND g.redirect='1' AND g.disable!='1' AND (g.start='' OR g.start<='$time') AND (g.stop='' OR g.stop>'" . ( $ time + 60 ) . "') AND p.published='1' AND (p.start='' OR p.start<='$time') AND (p.stop='' OR p.stop>'" . ( $ time + 60 ) . "') ORDER BY " . $ objDatabase -> findInSet ( 'g.id' , $ arrIds ) ) -> limit ( 1 ) -> execute ( ) ; if ( $ objResult -> numRows < 1 ) { return null ; } return new static ( $ objResult ) ; }
10373	public static function unify ( $ id , $ params , $ minify = '' ) { self :: $ id = $ id ; self :: $ unify = $ params ; self :: $ minify = $ minify ; return true ; }
8615	public function setSalesRank ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SalesRank' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9634	public function getFormField ( ) { if ( null === $ this -> field ) { $ this -> field = $ this -> initFormField ( ) ; } return $ this -> field ; }
9648	protected function getConstantValues ( string $ classIdentifier , string $ regex ) : array { $ reflectionClass = new \ ReflectionClass ( $ classIdentifier ) ; $ constants = $ reflectionClass -> getConstants ( ) ; $ validValues = array_filter ( $ constants , function ( $ constantName ) use ( $ regex ) { return preg_match ( $ regex , $ constantName ) ; } , ARRAY_FILTER_USE_KEY ) ; return $ validValues ; }
12556	private function createDeleteForm ( Tag $ tag ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_tag_delete' , array ( 'id' => $ tag -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
670	public function gc ( $ force = false ) { if ( $ force || mt_rand ( 0 , 1000000 ) < $ this -> gcProbability ) { $ this -> db -> createCommand ( ) -> delete ( $ this -> cacheTable , '[[expire]] > 0 AND [[expire]] < ' . time ( ) ) -> execute ( ) ; } }
2333	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> tokenChecker -> hasBackendUser ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> attributes -> set ( $ this -> requestAttribute , true ) ; }
12328	public function enqueue_script ( WP_Enqueue_Options $ options ) { if ( ! $ options -> have_required_properties ( ) ) { trigger_error ( 'Trying to enqueue script, but required properties are missing.' ) ; return ; } $ handle = $ options -> get_handle ( ) ; $ relative_path = $ options -> get_relative_path ( ) ; $ filename = $ options -> get_filename ( ) ; $ filename_debug = $ options -> get_filename_debug ( ) ; $ dependencies = $ options -> get_dependencies ( ) ; $ version = $ options -> get_version ( ) ; $ in_footer = $ options -> get_in_footer ( ) ; $ localization_name = $ options -> get_localization_name ( ) ; $ data = $ options -> get_data ( ) ; $ source = $ this -> get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug ) ; wp_register_script ( $ handle , $ source , $ dependencies , $ version , $ in_footer ) ; if ( ! empty ( $ localization_name ) && ! empty ( $ data ) ) { wp_localize_script ( $ handle , $ localization_name , $ data ) ; } wp_enqueue_script ( $ handle ) ; }
2038	private function applyLegacyLogic ( $ strUrl , $ strParams ) { if ( strpos ( $ strParams , '%' ) !== false ) { @ trigger_error ( 'Using sprintf placeholders in URLs has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ arrMatches = array ( ) ; preg_match_all ( '/%([sducoxXbgGeEfF])/' , $ strParams , $ arrMatches ) ; foreach ( array_unique ( $ arrMatches [ 1 ] ) as $ v ) { $ strUrl = str_replace ( '%25' . $ v , '%' . $ v , $ strUrl ) ; } } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateFrontendUrl' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateFrontendUrl' ] ) ) { @ trigger_error ( 'Using the "generateFrontendUrl" hook has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateFrontendUrl' ] as $ callback ) { $ strUrl = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ this -> row ( ) , $ strParams , $ strUrl ) ; } return $ strUrl ; } return $ strUrl ; }
12332	public function add ( $ key , $ object ) { if ( $ this -> repository -> containsKey ( $ key ) ) throw new ReferenceExistsException ( ) ; $ this -> repository -> set ( $ key , $ object ) ; }
12950	public function beforeDelete ( ) { $ this -> _tagsForDelete = [ ] ; $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ this -> _tagsForDelete = ( new Query ( ) ) -> select ( current ( $ relation -> link ) ) -> from ( $ relation -> via -> from [ 0 ] ) -> where ( [ key ( $ relation -> via -> link ) => $ this -> owner -> getPrimaryKey ( ) ] ) -> column ( $ this -> owner -> getDb ( ) ) ; } }
9627	protected function matchParams ( Route $ route , array $ params ) : bool { $ matchers = $ route -> getMatchers ( ) ; foreach ( $ params as $ name => $ value ) { if ( ! isset ( $ matchers [ $ name ] ) ) { continue ; } $ valueMatchers = $ matchers [ $ name ] ; foreach ( $ valueMatchers as $ matcher ) { if ( ! $ matcher ( $ value ) ) { $ this -> logger -> debug ( sprintf ( 'Value "%s" for param "%s" did not match criteria of matcher "%s"' , $ value , $ name , get_class ( $ matcher ) ) ) ; return false ; } } } return true ; }
12290	public function countTotal ( $ categoryId = null ) { $ qb = $ this -> getQueryBuilder ( ) -> select ( 'COUNT(p)' ) ; if ( ! is_null ( $ categoryId ) ) { $ qb -> join ( 'p.categories' , 'c' ) -> where ( 'c.id = :categoryId' ) -> setParameter ( 'categoryId' , $ categoryId ) ; } return $ qb -> getQuery ( ) -> getSingleScalarResult ( ) ; }
9410	protected function collect ( ) { $ collector = new RouteCollector ; foreach ( $ this -> router -> routes ( ) as $ route ) { $ collector -> addRoute ( $ route [ 0 ] , $ route [ 1 ] , $ route [ 2 ] ) ; } return $ collector -> getData ( ) ; }
12653	public function getTextsWithBaseTexts ( $ language ) { $ texts = $ this -> getPageTexts ( $ language ) ; if ( $ language !== $ this -> baseLang ) { $ baseTexts = $ this -> getPageTexts ( $ this -> baseLang ) ; $ texts = array_map ( function ( $ text , $ baseText ) { return $ text + array ( "basecontent" => $ baseText [ 'content' ] ) ; } , $ texts , $ baseTexts ) ; } return $ texts ; }
4031	private function updateImageWithDisabled ( ModelInterface $ model , $ image ) { $ this -> preCreateInverseImage ( $ model , $ image ) ; if ( $ model -> getProperty ( 'enabled' ) ) { return $ image ; } if ( false === $ intPos = strrpos ( $ image , '.' ) ) { return $ image ; } return substr_replace ( $ image , '_1' , $ intPos , 0 ) ; }
11402	public function getAppCode ( $ path , $ width = 430 , $ autoColor = false , $ lineColor = [ 'r' => 0 , 'g' => 0 , 'b' => 0 ] ) { $ params = [ 'path' => $ path , 'width' => $ width , 'auto_color' => $ autoColor , 'line_color' => $ lineColor , ] ; return $ this -> getStream ( self :: API_GET_WXACODE , $ params ) ; }
11859	public static function getHandlingObject ( $ a , $ b ) { $ handlingA = $ a -> handlingComparison ; $ handlingB = $ b -> handlingComparison ; if ( ! $ handlingB ) { return $ a ; } if ( $ handlingA !== false && $ handlingB !== false ) { if ( $ handlingA > $ handlingB ) { return $ a ; } else { return $ b ; } } return $ a ; }
11823	public function replace ( $ middleware , $ with ) { $ this -> pipeline = $ this -> pipeline -> replace ( $ middleware , $ with ) ; return $ this ; }
3480	public function withLaunchImage ( string $ launchImage ) : Alert { $ cloned = clone $ this ; $ cloned -> launchImage = $ launchImage ; return $ cloned ; }
12010	public function addLink ( string $ name , string $ link = null , array $ arguments = [ ] ) : Link { $ name = $ this -> translator !== null ? $ this -> translator -> translate ( $ name ) : $ name ; return $ this -> addLinkUntranslated ( $ name , $ link , $ arguments ) ; }
1071	private function subfieldConflicts ( array $ conflicts , $ responseName , FieldNode $ ast1 , FieldNode $ ast2 ) { if ( count ( $ conflicts ) === 0 ) { return null ; } return [ [ $ responseName , array_map ( static function ( $ conflict ) { return $ conflict [ 0 ] ; } , $ conflicts ) , ] , array_reduce ( $ conflicts , static function ( $ allFields , $ conflict ) { return array_merge ( $ allFields , $ conflict [ 1 ] ) ; } , [ $ ast1 ] ) , array_reduce ( $ conflicts , static function ( $ allFields , $ conflict ) { return array_merge ( $ allFields , $ conflict [ 2 ] ) ; } , [ $ ast2 ] ) , ] ; }
7611	public function actionCreate ( ) { $ model = new User ; if ( $ model -> load ( $ _POST ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; } }
6850	public static function years ( $ start = false , $ end = false ) { $ start = ( $ start === false ) ? ( date ( 'Y' ) - 5 ) : ( int ) $ start ; $ end = ( $ end === false ) ? ( date ( 'Y' ) + 5 ) : ( int ) $ end ; $ years = array ( ) ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) { $ years [ $ i ] = ( string ) $ i ; } return $ years ; }
8676	public function flip ( ) { if ( ! $ this -> items ) { return $ this -> createFrom ( [ ] ) ; } try { return $ this -> createFrom ( Thrower :: call ( 'array_flip' , $ this -> items ) ) ; } catch ( ErrorException $ e ) { throw new LogicException ( 'Only string and integer values can be flipped' ) ; } }
9246	private function replaceOnce ( $ search , $ replace , $ subject ) { $ pos = strpos ( $ subject , $ search ) ; if ( $ pos !== false ) { $ subject = substr_replace ( $ subject , $ replace , $ pos , strlen ( $ search ) ) ; } return $ subject ; }
4888	public function gotoAction ( Request $ r ) { return $ this -> redirect ( $ this -> get ( 'zicht_url.provider' ) -> url ( $ this -> getPageManager ( ) -> findForView ( $ r -> get ( 'id' ) ) ) ) ; }
348	public static function cssStyleFromArray ( array $ style ) { $ result = '' ; foreach ( $ style as $ name => $ value ) { $ result .= "$name: $value; " ; } return $ result === '' ? null : rtrim ( $ result ) ; }
6813	private function getNumberFormatter ( ) { if ( $ this -> numberFormatter ) { return $ this -> numberFormatter ; } return $ this -> numberFormatter = NumberFormatter :: create ( $ this -> locale , NumberFormatter :: DECIMAL ) ; }
12184	public static function getById ( $ relationshipId ) { $ key = md5 ( $ relationshipId ) ; if ( isset ( self :: $ _relationships [ $ key ] ) ) { return self :: $ _relationships [ $ key ] ; } return false ; }
3120	public function remove ( $ tag , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; $ removed = 0 ; foreach ( $ this -> points as $ idx => $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { unset ( $ this -> points [ $ idx ] ) ; $ removed ++ ; } } return $ removed ; }
10507	private function registerFilesystem ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ Filesystem :: class , function ( $ app ) { $ files = $ app [ 'files' ] ; $ filesystem = new Utilities \ Filesystem ( $ files , storage_path ( 'logs' ) ) ; $ filesystem -> setPattern ( Utilities \ Filesystem :: PATTERN_PREFIX , Utilities \ Filesystem :: PATTERN_DATE , Utilities \ Filesystem :: PATTERN_EXTENSION ) ; return $ filesystem ; } ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.filesystem' , Contracts \ Utilities \ Filesystem :: class ) ; }
58	protected function resolvePackageInstallPreference ( PackageInterface $ package ) { foreach ( $ this -> packagePreferences as $ pattern => $ preference ) { $ pattern = '{^' . str_replace ( '\\*' , '.*' , preg_quote ( $ pattern ) ) . '$}i' ; if ( preg_match ( $ pattern , $ package -> getName ( ) ) ) { if ( 'dist' === $ preference || ( ! $ package -> isDev ( ) && 'auto' === $ preference ) ) { return 'dist' ; } return 'source' ; } } return $ package -> isDev ( ) ? 'source' : 'dist' ; }
7430	public function addRegion ( RegionInterface $ region ) { $ region -> setCountry ( $ this ) ; $ this -> regions -> add ( $ region ) ; }
1503	public function handle ( $ request , Closure $ next , string $ namespace ) { $ api = $ this -> bindApi ( $ namespace , $ request -> getSchemeAndHttpHost ( ) . $ request -> getBaseUrl ( ) ) ; $ this -> substituteBindings ( $ api ) ; $ this -> bindPageResolver ( ) ; return $ next ( $ request ) ; }
12389	protected function updateCredentialHash ( PasswordableInterface $ identityObject , $ password ) { $ cryptoService = $ this -> getMapper ( ) -> getPasswordService ( ) ; if ( ! $ cryptoService instanceof Bcrypt ) { return $ this ; } $ hash = explode ( '$' , $ identityObject -> getPassword ( ) ) ; if ( $ hash [ 2 ] === $ cryptoService -> getCost ( ) ) { return $ this ; } $ identityObject -> setPassword ( $ cryptoService -> create ( $ password ) ) ; return $ this ; }
2545	protected function makeDomXpath ( $ response ) { $ domDoc = $ this -> loadDomDocument ( $ response ) ; $ domXpath = new \ DOMXPath ( $ domDoc ) ; $ domXpath -> registerNamespace ( self :: XMLNS_PREFIX , $ domDoc -> documentElement -> lookupNamespaceUri ( null ) ) ; return $ domXpath ; }
11398	public function remove ( $ sourceDir , array $ options , $ username ) { $ dir = $ this -> init ( $ sourceDir , $ options , $ username ) -> getDirInUse ( ) ; $ blockName = $ options [ "blockname" ] ; $ blocksDir = $ dir . '/blocks' ; $ filename = sprintf ( '%s/%s.json' , $ blocksDir , $ blockName ) ; $ options [ "block" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_REMOVING , new BlockRemovingEvent ( $ this -> serializer , $ filename ) ) ; $ this -> filesystem -> remove ( $ filename ) ; $ this -> removeBlockFromSlotFile ( $ options , $ dir ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_REMOVED , new BlockRemovedEvent ( $ this -> serializer , $ filename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been removed from the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
967	protected function cleanShop ( ) { $ this -> shop -> shopify_token = null ; $ this -> shop -> plan_id = null ; $ this -> shop -> save ( ) ; }
6480	private function getSetCookieHeaderValue ( Cookie $ cookie ) : string { $ headerValue = "{$cookie->getName()}=" . urlencode ( $ cookie -> getValue ( ) ) ; if ( ( $ expiration = $ cookie -> getExpiration ( ) ) !== null ) { $ headerValue .= '; Expires=' . $ expiration -> format ( self :: EXPIRATION_DATE_FORMAT ) ; } if ( ( $ maxAge = $ cookie -> getMaxAge ( ) ) !== null ) { $ headerValue .= "; Max-Age=$maxAge" ; } if ( ( $ domain = $ cookie -> getDomain ( ) ) !== null ) { $ headerValue .= '; Domain=' . urlencode ( $ domain ) ; } if ( ( $ path = $ cookie -> getPath ( ) ) !== null ) { $ headerValue .= '; Path=' . urlencode ( $ path ) ; } if ( $ cookie -> isSecure ( ) ) { $ headerValue .= '; Secure' ; } if ( $ cookie -> isHttpOnly ( ) ) { $ headerValue .= '; HttpOnly' ; } if ( ( $ sameSite = $ cookie -> getSameSite ( ) ) !== null ) { $ headerValue .= '; SameSite=' . urlencode ( $ sameSite ) ; } return $ headerValue ; }
5917	public function updateSetting ( $ key , $ value ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'value' => $ value ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> put ( 'v1/accounts/settings/' . $ key . '' , $ parameters ) ; return $ result ; }
281	private function confirmUnload ( $ fixtures , $ except ) { $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n\n" , Console :: FG_GREEN ) ; if ( count ( $ this -> globalFixtures ) ) { $ this -> stdout ( "Global fixtures will be used:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ this -> globalFixtures ) ; } if ( count ( $ fixtures ) ) { $ this -> stdout ( "\nFixtures below will be unloaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ fixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be unloaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } return $ this -> confirm ( "\nUnload fixtures?" ) ; }
630	public function insert ( $ table , $ columns ) { $ params = [ ] ; $ sql = $ this -> db -> getQueryBuilder ( ) -> insert ( $ table , $ columns , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
8668	public function setSelf ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Self' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8895	protected function _initialize_event_listeners ( ) { foreach ( $ this -> event_listeners as $ event_listener => $ e ) { if ( isset ( $ this -> $ event_listener ) && ! empty ( $ this -> $ event_listener ) ) { foreach ( $ this -> $ event_listener as $ event ) { $ this -> subscribe ( $ event_listener , $ event ) ; } } } $ this -> subscribe ( 'before_update' , 'protect_attributes' , TRUE ) ; }
2081	public function purgeOptInTokens ( ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optIn -> purgeTokens ( ) ; $ this -> log ( 'Purged the expired double opt-in tokens' , __METHOD__ , TL_CRON ) ; }
586	protected function loadDependency ( $ bundle , & $ result ) { $ am = $ this -> getAssetManager ( ) ; foreach ( $ bundle -> depends as $ name ) { if ( ! isset ( $ result [ $ name ] ) ) { $ dependencyBundle = $ am -> getBundle ( $ name ) ; $ result [ $ name ] = false ; $ this -> loadDependency ( $ dependencyBundle , $ result ) ; $ result [ $ name ] = $ dependencyBundle ; } elseif ( $ result [ $ name ] === false ) { throw new Exception ( "A circular dependency is detected for bundle '{$name}': " . $ this -> composeCircularDependencyTrace ( $ name , $ result ) . '.' ) ; } } }
9523	private function getConfig ( ) { $ yaml = new Parser ( ) ; $ configFile = getenv ( 'TRAVIS_BUILD_DIR' ) . '/.travis.yml' ; $ config = $ yaml -> parse ( file_get_contents ( $ configFile ) ) ; $ config = $ config [ 'travisdeployer' ] ; $ this -> branches = $ config [ 'branches' ] ; if ( count ( $ this -> branches ) === 0 ) { die ( 'No branches are configured to deploy to.' . PHP_EOL ) ; } $ this -> verbose = filter_input ( FILTER_VALIDATE_BOOLEAN , $ config [ 'verbose' ] ) ; }
11660	public static function readFromString ( $ string ) { $ xml = new \ DOMDocument ( ) ; $ xml -> loadXML ( $ string ) ; $ result = [ ] ; $ props = $ xml -> childNodes -> item ( $ xml -> childNodes -> length - 1 ) -> childNodes ; for ( $ i = 0 ; $ i < $ props -> length ; $ i ++ ) { $ entry = $ props -> item ( $ i ) ; if ( $ entry -> nodeName == "entry" ) $ result [ $ entry -> attributes -> getNamedItem ( "key" ) -> nodeValue ] = $ entry -> textContent ; } return $ result ; }
7851	protected function grabParameter ( ReflectionParameter $ parameter ) { if ( isset ( $ this -> values [ $ parameter -> name ] ) ) { return $ this -> values [ $ parameter -> name ] ; } if ( $ parameter -> isDefaultValueAvailable ( ) ) { return $ parameter -> getDefaultValue ( ) ; } throw new Exception ( "Unable to map parameter [{$parameter->name}] to command [{$this->command}]" ) ; }
1053	public static function buildAST ( DocumentNode $ ast , ? callable $ typeConfigDecorator = null , array $ options = [ ] ) { $ builder = new self ( $ ast , $ typeConfigDecorator , $ options ) ; return $ builder -> buildSchema ( ) ; }
6344	public static function from ( Traversable $ traversable ) : Iterator { Preconditions :: checkArgument ( $ traversable instanceof Iterator || $ traversable instanceof IteratorAggregate ) ; return $ traversable instanceof Iterator ? $ traversable : Iterators :: from ( $ traversable -> getIterator ( ) ) ; }
10410	public function createUrlsTempFile ( ) { $ hash = md5 ( microtime ( true ) ) ; $ links = array_merge ( $ this -> getUrls ( ) , $ this -> getUrlsByDocumentParameter ( ) ) ; $ urlsFile = "/tmp/urls_{$hash}.txt" ; $ urls = [ ] ; foreach ( $ links as $ url ) { $ separator = ( $ url [ 0 ] !== '/' ) ? '/' : '' ; $ urls [ ] = $ this -> baseUrl . $ separator . $ url ; } file_put_contents ( $ urlsFile , implode ( PHP_EOL , $ urls ) ) ; return $ urlsFile ; }
10721	public function getLabel ( ) { $ label = $ this -> label ; $ title = $ this -> title ; if ( $ label ) { return $ label ; } else { return $ title ; } }
11761	public static function set ( $ property , $ value = NULL ) { $ object = new \ ReflectionClass ( Collection :: class ) ; $ object -> setStaticPropertyValue ( $ property , $ value ) ; return true ; }
6669	public function set_movie_params ( ) { $ post_id = get_the_ID ( ) ; $ is_active = $ this -> get_rating_state ( $ post_id ) ; $ options = $ this -> model -> get_theme_options ( ) ; $ params = [ 'postID' => $ post_id , 'dark' => $ options [ 'enable-dark' ] , 'imdb_button' => __ ( 'TOTAL' , 'extensions-for-grifus-rating' ) , 'is_active' => $ is_active , ] ; return $ params ; }
7905	public function renderToggleButton ( ) { if ( $ this -> toggleButton !== false ) { $ tag = ArrayHelper :: remove ( $ this -> toggleButton , 'tag' , 'div' ) ; $ label = ArrayHelper :: remove ( $ this -> toggleButton , 'label' , Html :: tag ( 'i' , '' , [ 'class' => 'content icon' ] ) ) ; Html :: addCssClass ( $ this -> toggleButton , 'ui' ) ; Html :: addCssClass ( $ this -> toggleButton , 'launch-sidebar icon' ) ; Html :: addCssClass ( $ this -> toggleButton , 'button' ) ; Html :: addCssClass ( $ this -> toggleButton , 'fixed' ) ; Html :: addCssClass ( $ this -> toggleButton , 'attached' ) ; if ( $ this -> position === static :: POS_LEFT ) { $ position = static :: POS_RIGHT ; } else { $ position = static :: POS_LEFT ; } Html :: addCssClass ( $ this -> toggleButton , $ position ) ; $ view = $ this -> getView ( ) ; DosAmigosAsset :: register ( $ view ) ; $ view -> registerJs ( 'dosamigos.semantic.init();' ) ; return Html :: tag ( $ tag , $ label , $ this -> toggleButton ) ; } else { return null ; } }
5705	public function shouldDisplay ( ) { if ( $ this -> gridFieldRequest -> getRequest ( ) -> param ( 'ID' ) == 'new' ) { return false ; } return $ this -> gridFieldRequest -> record -> canCreate ( ) ; }
6913	public function addShipment ( ShipmentInterface $ shipment ) { if ( ! $ this -> shipments -> contains ( $ shipment ) ) { $ this -> shipments -> add ( $ shipment ) ; } return $ this ; }
4660	public function getConsoleLogger ( $ verbose = false ) { $ logger = new Logger ( "standalone-logger" ) ; $ handler = new StreamHandler ( "php://stdout" , $ verbose ? Logger :: DEBUG : Logger :: INFO ) ; $ simpleFormatter = new SimpleFormatter ( ) ; $ handler -> setFormatter ( $ simpleFormatter ) ; $ logger -> pushHandler ( $ handler ) ; if ( ! $ verbose ) { $ stdErrHandler = new StreamHandler ( "php://stderr" , Logger :: DEBUG ) ; $ fingerCrossedHandler = new FingersCrossedHandler ( $ stdErrHandler , new ErrorLevelActivationStrategy ( Logger :: ERROR ) , 10 ) ; $ logger -> pushHandler ( $ fingerCrossedHandler ) ; $ stdErrHandler -> setFormatter ( $ simpleFormatter ) ; } return $ logger ; }
12147	public function hasException ( \ Exception $ exception ) { $ class = get_class ( $ exception ) ; $ exceptions = $ this -> getExceptions ( ) ; return isset ( $ exceptions [ $ class ] ) ; }
7679	function TbsMergeVarFields ( $ PrmVal , $ FldVal ) { $ this -> TBS -> meth_Merge_AutoVar ( $ PrmVal , true ) ; $ PrmVal = str_replace ( $ this -> TBS -> _ChrVal , $ FldVal , $ PrmVal ) ; return $ PrmVal ; }
2129	protected function initialize ( ) { if ( static :: $ blnHasLcf === null ) { static :: preload ( ) ; } $ strCacheDir = System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ; if ( file_exists ( $ strCacheDir . '/contao/config/config.php' ) ) { include $ strCacheDir . '/contao/config/config.php' ; } else { try { $ files = System :: getContainer ( ) -> get ( 'contao.resource_locator' ) -> locate ( 'config/config.php' , null , false ) ; } catch ( \ InvalidArgumentException $ e ) { $ files = array ( ) ; } foreach ( $ files as $ file ) { include $ file ; } } if ( static :: $ blnHasLcf ) { include $ this -> strRootDir . '/system/config/localconfig.php' ; } static :: loadParameters ( ) ; }
12679	public static function boot ( ConfigurationHandler $ configurationHandler ) { $ pluginDirs = $ configurationHandler -> pluginFolders ( ) ; foreach ( $ pluginDirs as $ pluginDir ) { self :: $ blocks += self :: parse ( $ pluginDir ) ; } }
12572	public function previewImage ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_IMAGE , $ message , $ to , $ by ) ; }
3968	protected function createAttributeInstance ( ModelInterface $ model = null ) { if ( null === $ model ) { return null ; } return $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ this -> getMetaModelByModelPid ( $ model ) ) ; }
1182	protected function jsValidator ( Validator $ validator , $ selector = null ) { $ remote = ! $ this -> options [ 'disable_remote_validation' ] ; $ view = $ this -> options [ 'view' ] ; $ selector = is_null ( $ selector ) ? $ this -> options [ 'form_selector' ] : $ selector ; $ delegated = new DelegatedValidator ( $ validator , new ValidationRuleParserProxy ( ) ) ; $ rules = new RuleParser ( $ delegated , $ this -> getSessionToken ( ) ) ; $ messages = new MessageParser ( $ delegated ) ; $ jsValidator = new ValidatorHandler ( $ rules , $ messages ) ; $ manager = new JavascriptValidator ( $ jsValidator , compact ( 'view' , 'selector' , 'remote' ) ) ; return $ manager ; }
11079	public static function getMonthName ( $ month ) { if ( $ month < 1 || $ month > 12 ) { return '' ; } $ monthNames = [ 1 => self :: poorManTranslate ( 'fts-shared' , 'January' ) , 2 => self :: poorManTranslate ( 'fts-shared' , 'February' ) , 3 => self :: poorManTranslate ( 'fts-shared' , 'March' ) , 4 => self :: poorManTranslate ( 'fts-shared' , 'April' ) , 5 => self :: poorManTranslate ( 'fts-shared' , 'May' ) , 6 => self :: poorManTranslate ( 'fts-shared' , 'June' ) , 7 => self :: poorManTranslate ( 'fts-shared' , 'July' ) , 8 => self :: poorManTranslate ( 'fts-shared' , 'August' ) , 9 => self :: poorManTranslate ( 'fts-shared' , 'September' ) , 10 => self :: poorManTranslate ( 'fts-shared' , 'October' ) , 11 => self :: poorManTranslate ( 'fts-shared' , 'November' ) , 12 => self :: poorManTranslate ( 'fts-shared' , 'December' ) , ] ; return $ monthNames [ $ month ] ; }
10864	protected function generateHashes ( ) : array { $ dirLength = strlen ( $ this -> dir ) ; foreach ( $ this -> createIterator ( ) as $ file ) { if ( ! $ file -> isFile ( ) ) { continue ; } $ realpath = $ file -> getRealPath ( ) ; $ path = $ file -> getPath ( ) . DIRECTORY_SEPARATOR . $ file -> getFilename ( ) ; if ( $ realpath !== $ path ) { continue ; } $ path = substr ( $ realpath , $ dirLength ) ; $ lowerPath = strtolower ( $ path ) ; if ( isset ( $ this -> hashes [ $ lowerPath ] ) ) { $ message = "duplicate file encountered: $path ($lowerPath)" ; throw new \ RuntimeException ( $ message ) ; } $ this -> hashes [ $ lowerPath ] = sha1_file ( $ realpath ) ; } ksort ( $ this -> hashes ) ; return $ this -> hashes ; }
10378	protected static function get_routes_to_folder ( $ type ) { $ url = isset ( self :: $ unify [ "{$type}s" ] ) ? self :: $ unify [ "{$type}s" ] : self :: $ unify ; return [ 'url' => $ url , 'path' => self :: get_path_from_url ( $ url ) , ] ; }
6921	public function get ( TaxGroupInterface $ taxGroup , CountryInterface $ country , $ business = false ) { $ key = $ this -> buildKey ( $ taxGroup , $ country , $ business ) ; if ( isset ( $ this -> taxes [ $ key ] ) ) { return $ this -> taxes [ $ key ] ; } return null ; }
424	protected function adjustLabelFor ( $ options ) { if ( ! isset ( $ options [ 'id' ] ) ) { return ; } $ this -> _inputId = $ options [ 'id' ] ; if ( ! isset ( $ this -> labelOptions [ 'for' ] ) ) { $ this -> labelOptions [ 'for' ] = $ options [ 'id' ] ; } }
1938	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> newsletters ) || ! \ is_array ( $ this -> User -> newsletters ) ) { $ root = array ( 0 ) ; } else { $ root = $ this -> User -> newsletters ; } if ( \ in_array ( $ insertId , $ root ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_newsletter_channel' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_newsletter_channel' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, newsletters, newsletterp FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrNewsletterp = Contao \ StringUtil :: deserialize ( $ objGroup -> newsletterp ) ; if ( \ is_array ( $ arrNewsletterp ) && \ in_array ( 'create' , $ arrNewsletterp ) ) { $ arrNewsletters = Contao \ StringUtil :: deserialize ( $ objGroup -> newsletters , true ) ; $ arrNewsletters [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET newsletters=? WHERE id=?" ) -> execute ( serialize ( $ arrNewsletters ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT newsletters, newsletterp FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrNewsletterp = Contao \ StringUtil :: deserialize ( $ objUser -> newsletterp ) ; if ( \ is_array ( $ arrNewsletterp ) && \ in_array ( 'create' , $ arrNewsletterp ) ) { $ arrNewsletters = Contao \ StringUtil :: deserialize ( $ objUser -> newsletters , true ) ; $ arrNewsletters [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET newsletters=? WHERE id=?" ) -> execute ( serialize ( $ arrNewsletters ) , $ this -> User -> id ) ; } } $ root [ ] = $ insertId ; $ this -> User -> newsletter = $ root ; } }
12453	static function run_generate_sample_package_xml ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { pake_copy ( self :: getResourceDir ( ) . '/package_master.xml' , 'package.xml' ) ; $ tokens = array ( '$summary' => '[Summary]' , '$description' => '[Description]' , '$vendor' => '' , '$maintainers' => '' , '$documents' => '' , '$changelog' => '' , '$simple-files' => '' , '$state' => '[State]' , '$requires' => '' ) ; pake_replace_tokens ( 'package.xml' , '.' , '{' , '}' , $ tokens ) ; pake_echo ( "File package.xml generated. Please replace all tokens in square brackets in it (but do not replace values in curly brackets) then commit it to sources in the top dir of the extension" ) ; }
8439	protected static function completeFilesCountsAndEditorLinks ( ) { if ( ! static :: $ files ) { $ rawList = get_included_files ( ) ; $ list = [ ] ; $ docRoot = str_replace ( '\\' , '/' , $ _SERVER [ 'DOCUMENT_ROOT' ] ) ; $ docRootLength = mb_strlen ( $ docRoot ) ; $ tracyFileDetectionSubstr = '/tracy' ; foreach ( $ rawList as & $ file ) { $ file = str_replace ( '\\' , '/' , $ file ) ; $ text = mb_substr ( $ file , $ docRootLength ) ; $ tracyFile = mb_stripos ( $ text , $ tracyFileDetectionSubstr ) !== FALSE ; if ( ! $ tracyFile ) static :: $ appFilesCount += 1 ; static :: $ allFilesCount += 1 ; $ href = \ Tracy \ Helpers :: editorUri ( $ file , 1 ) ; $ list [ ] = '<a ' . ( $ tracyFile ? 'class="tracy" ' : '' ) . 'href="' . $ href . '"><nobr>' . $ text . '</nobr></a><br />' ; } static :: $ files = & $ list ; } }
655	protected function reset ( ) { $ this -> _sql = null ; $ this -> _pendingParams = [ ] ; $ this -> params = [ ] ; $ this -> _refreshTableName = null ; $ this -> _isolationLevel = false ; $ this -> _retryHandler = null ; }
5180	private function addArray ( string $ key , $ value ) : self { $ this -> props [ $ key ] [ ] = $ value ; return $ this ; }
10969	public static function getQuery ( $ name = '' , $ defaultValue = null ) { $ queryStringParts = [ ] ; if ( isset ( $ _SERVER [ 'QUERY_STRING' ] ) ) { parse_str ( $ _SERVER [ 'QUERY_STRING' ] , $ queryStringParts ) ; } if ( $ name != '' ) { if ( isset ( $ queryStringParts [ $ name ] ) ) { return $ queryStringParts [ $ name ] ; } else { return $ defaultValue ; } } return $ queryStringParts ; }
11917	public function newInstanceQuery ( array $ data = [ ] , array $ selectable = [ '*' ] ) { $ tm = new TextGenerator ( ) ; $ r = $ this -> newInstanceRepository ( ) ; $ query = $ r -> newQuery ( ) ; if ( ! empty ( $ this -> filter ) ) { $ filter = new Filter ( $ r -> getTableName ( ) , $ selectable ) ; $ filter -> build ( $ query , $ tm -> generateAndRender ( $ this -> filter , $ data ) ) ; } return $ query ; }
6542	public function current ( ) { if ( true === $ this -> wantNewModel ) { return $ this -> entityManager -> load ( $ this -> modelClassName , $ this -> selector -> current ( ) ) ; } else { $ this -> initializeModel ( $ this -> selector -> current ( ) , $ this -> selector -> currentShardingKey ( ) ) ; $ this -> entityManager -> resetModel ( $ this -> model , $ this -> selector -> current ( ) ) ; return $ this -> model ; } }
5919	public function setCreated ( $ created ) { if ( $ created instanceof DateTime ) { $ this -> created = $ created ; } else { try { $ this -> created = new DateTime ( $ created ) ; } catch ( \ Exception $ e ) { $ this -> created = null ; } } return $ this ; }
4570	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Encryptable ) { return ; } $ entity -> setEncrypted ( true ) ; $ this -> encryptionService -> decrypt ( $ entity ) ; }
7769	public function passes ( ) { foreach ( $ this -> after as $ after ) { call_user_func_array ( $ after , [ $ this ] ) ; } return empty ( $ this -> errors ) ; }
12376	public function equals ( ) { foreach ( $ this -> comparisonList as $ valuePair ) { $ a = $ valuePair [ 0 ] ; $ b = $ valuePair [ 1 ] ; $ callback = $ valuePair [ 2 ] ; if ( ! is_null ( $ callback ) ) { if ( ! is_callable ( $ callback ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Provided callback of type %s is not callable!' , is_object ( $ callback ) ? get_class ( $ callback ) : gettype ( $ callback ) ) ) ; } if ( is_array ( $ a ) && is_array ( $ b ) && $ this -> isList ( $ a ) && $ this -> isList ( $ b ) ) { $ result = $ this -> compareListsWithCallback ( $ a , $ b , $ callback ) ; } else { $ result = call_user_func ( $ callback , $ a , $ b ) ; } if ( ! is_bool ( $ result ) ) { throw new \ RuntimeException ( sprintf ( 'Provided callback of type %s does not return a boolean value!' , is_object ( $ callback ) ? get_class ( $ callback ) : gettype ( $ callback ) ) ) ; } return $ result ; } if ( ! ( ( $ this -> strict ) ? $ a === $ b : $ a == $ b ) ) { return false ; } } return true ; }
7231	public function loadResult ( array $ result ) { $ changed = false ; foreach ( [ 'revenue' , 'shipping' , 'margin' , 'orders' , 'items' , 'average' , 'details' ] as $ property ) { if ( $ this -> { $ property } != $ result [ $ property ] ) { $ this -> { $ property } = $ result [ $ property ] ; $ changed = true ; } } return $ changed ; }
3476	protected function request ( $ verb , $ endpoint , array $ data ) { $ url = rtrim ( $ this -> baseUrl , '/' ) . '/' . ltrim ( $ endpoint , '/' ) ; try { $ response = $ this -> httpClient -> request ( $ verb , $ url , [ 'headers' => [ 'Authorization' => 'Bot ' . $ this -> token , ] , 'json' => $ data , ] ) ; } catch ( RequestException $ exception ) { if ( $ response = $ exception -> getResponse ( ) ) { throw CouldNotSendNotification :: serviceRespondedWithAnHttpError ( $ response ) ; } throw CouldNotSendNotification :: serviceCommunicationError ( $ exception ) ; } catch ( Exception $ exception ) { throw CouldNotSendNotification :: serviceCommunicationError ( $ exception ) ; } $ body = json_decode ( $ response -> getBody ( ) , true ) ; if ( Arr :: get ( $ body , 'code' , 0 ) > 0 ) { throw CouldNotSendNotification :: serviceRespondedWithAnApiError ( $ body ) ; } return $ body ; }
1320	private function curlOptions ( ) { $ options = [ CURLOPT_CONNECTTIMEOUT => $ this -> connectionTimeout , CURLOPT_HEADER => true , CURLOPT_RETURNTRANSFER => true , CURLOPT_SSL_VERIFYHOST => 2 , CURLOPT_SSL_VERIFYPEER => true , CURLOPT_TIMEOUT => $ this -> timeout , CURLOPT_USERAGENT => $ this -> userAgent , ] ; if ( $ this -> useCAFile ( ) ) { $ options [ CURLOPT_CAINFO ] = __DIR__ . DIRECTORY_SEPARATOR . 'cacert.pem' ; } if ( $ this -> gzipEncoding ) { $ options [ CURLOPT_ENCODING ] = 'gzip' ; } if ( ! empty ( $ this -> proxy ) ) { $ options [ CURLOPT_PROXY ] = $ this -> proxy [ 'CURLOPT_PROXY' ] ; $ options [ CURLOPT_PROXYUSERPWD ] = $ this -> proxy [ 'CURLOPT_PROXYUSERPWD' ] ; $ options [ CURLOPT_PROXYPORT ] = $ this -> proxy [ 'CURLOPT_PROXYPORT' ] ; $ options [ CURLOPT_PROXYAUTH ] = CURLAUTH_BASIC ; $ options [ CURLOPT_PROXYTYPE ] = CURLPROXY_HTTP ; } return $ options ; }
10056	public function getItem ( $ key ) { if ( $ this -> hasItem ( $ key ) !== true ) { $ this -> data [ $ key ] = new CacheItem ( $ key , null , false ) ; } return $ this -> data [ $ key ] ; }
10068	protected function registerDecorators ( ) { $ decorators = array ( 'AutoId' ) ; foreach ( $ decorators as $ decoratorClass ) { $ decoratorClass = '\\Sirius\FormRenderer\\Decorator\\' . $ decoratorClass ; $ this -> addDecorator ( new $ decoratorClass ) ; } }
8057	public function setParentProcessTitleFormat ( $ string ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Children\'s Process Title Format for a created pool.' ) ; } $ this -> parentProcessTitleFormat = ProcessDetails :: sanitizeProcessTitleFormat ( $ string ) ; return $ this ; }
9864	private function writeDataValidations ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ dataValidationCollection = $ pSheet -> getDataValidationCollection ( ) ; if ( ! empty ( $ dataValidationCollection ) ) { $ dataValidationCollection = Coordinate :: mergeRangesInCollection ( $ dataValidationCollection ) ; $ objWriter -> startElement ( 'dataValidations' ) ; $ objWriter -> writeAttribute ( 'count' , count ( $ dataValidationCollection ) ) ; foreach ( $ dataValidationCollection as $ coordinate => $ dv ) { $ objWriter -> startElement ( 'dataValidation' ) ; if ( $ dv -> getType ( ) != '' ) { $ objWriter -> writeAttribute ( 'type' , $ dv -> getType ( ) ) ; } if ( $ dv -> getErrorStyle ( ) != '' ) { $ objWriter -> writeAttribute ( 'errorStyle' , $ dv -> getErrorStyle ( ) ) ; } if ( $ dv -> getOperator ( ) != '' ) { $ objWriter -> writeAttribute ( 'operator' , $ dv -> getOperator ( ) ) ; } $ objWriter -> writeAttribute ( 'allowBlank' , ( $ dv -> getAllowBlank ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showDropDown' , ( ! $ dv -> getShowDropDown ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showInputMessage' , ( $ dv -> getShowInputMessage ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showErrorMessage' , ( $ dv -> getShowErrorMessage ( ) ? '1' : '0' ) ) ; if ( $ dv -> getErrorTitle ( ) !== '' ) { $ objWriter -> writeAttribute ( 'errorTitle' , $ dv -> getErrorTitle ( ) ) ; } if ( $ dv -> getError ( ) !== '' ) { $ objWriter -> writeAttribute ( 'error' , $ dv -> getError ( ) ) ; } if ( $ dv -> getPromptTitle ( ) !== '' ) { $ objWriter -> writeAttribute ( 'promptTitle' , $ dv -> getPromptTitle ( ) ) ; } if ( $ dv -> getPrompt ( ) !== '' ) { $ objWriter -> writeAttribute ( 'prompt' , $ dv -> getPrompt ( ) ) ; } $ objWriter -> writeAttribute ( 'sqref' , $ coordinate ) ; if ( $ dv -> getFormula1 ( ) !== '' ) { $ objWriter -> writeElement ( 'formula1' , $ dv -> getFormula1 ( ) ) ; } if ( $ dv -> getFormula2 ( ) !== '' ) { $ objWriter -> writeElement ( 'formula2' , $ dv -> getFormula2 ( ) ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
11512	public function actionRequest ( ) { if ( ! $ this -> module -> enablePasswordRecovery ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( [ 'class' => RecoveryForm :: className ( ) , 'scenario' => 'request' , ] ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> sendRecoveryMessage ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Recovery message sent' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'request' , [ 'model' => $ model , ] ) ; }
8257	protected function startAuthentication ( ) { $ authorizationUrl = $ this -> provider -> getAuthorizationUrl ( ) ; $ this -> session -> migrate ( true ) ; $ this -> session -> set ( "oauth2state" , $ this -> provider -> getState ( ) ) ; $ this -> picoAuth -> redirectToPage ( $ authorizationUrl , null , false ) ; }
11731	protected function generateSlot ( $ path , $ blocks = array ( ) , $ username = null ) { if ( is_dir ( $ path ) && ! $ this -> override ) { return ; } $ folders = array ( ) ; $ activeDir = $ path . '/active' ; $ contributorsDir = $ path . '/contributors' ; $ folders [ ] = $ activeDir . '/blocks' ; $ folders [ ] = $ activeDir . '/archive' ; $ folders [ ] = $ contributorsDir ; $ targetDir = $ activeDir ; $ blocksDir = $ activeDir . '/blocks' ; if ( null !== $ username ) { $ targetDir = $ contributorsDir . '/' . $ username ; $ blocksDir = $ targetDir . '/blocks' ; $ folders [ ] = $ targetDir ; $ folders [ ] = $ targetDir . '/archive' ; $ folders [ ] = $ blocksDir ; } $ this -> filesystem -> mkdir ( $ folders ) ; $ this -> generateBlocks ( $ blocks , $ blocksDir , $ targetDir ) ; }
8195	protected function checkConstantExpression ( Twig_NodeInterface $ node ) { if ( ! ( $ node instanceof Twig_Node_Expression_Constant || $ node instanceof Twig_Node_Expression_Array || $ node instanceof Twig_Node_Expression_Unary_Neg || $ node instanceof Twig_Node_Expression_Unary_Pos ) ) { return false ; } foreach ( $ node as $ n ) { if ( ! $ this -> checkConstantExpression ( $ n ) ) { return false ; } } return true ; }
2344	protected function createIfNotExists ( ) { if ( file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { return ; } if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } if ( ! $ this -> resFile = $ this -> Files -> fopen ( $ this -> strFile , 'wb' ) ) { throw new \ Exception ( sprintf ( 'Cannot create file "%s"' , $ this -> strFile ) ) ; } }
7569	public function getJobApiService ( ) { $ apiService = new \ Greenhouse \ GreenhouseToolsPhp \ Services \ JobApiService ( $ this -> _boardToken ) ; $ apiClient = new GuzzleClient ( array ( 'base_uri' => ApiService :: jobBoardBaseUrl ( $ this -> _boardToken ) ) ) ; $ apiService -> setClient ( $ apiClient ) ; return $ apiService ; }
10751	public function init ( UserEntity $ user , ServiceManager $ sm ) { $ main = $ sm -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; $ this -> hashId = $ userRepository -> getEncryptedId ( $ user -> getUserId ( ) ) ; $ this -> name = $ user -> getName ( ) ; $ this -> surname = $ user -> getSurname ( ) ; $ this -> email = $ user -> getEmail ( ) ; $ this -> gender = $ user -> getGender ( ) ; $ this -> dateBorn = $ this -> getDateBorn ( $ user , $ sm ) ; $ this -> nicename = $ user -> getNicename ( ) ; $ this -> mobile = $ this -> getMobile ( $ user ) ; $ this -> isAdmin = 'god' == $ user -> getRole ( ) ; $ this -> fullname = $ this -> getFullname ( $ user ) ; $ this -> role = $ user -> getRole ( ) ; $ this -> state = $ user -> getState ( ) ; $ this -> stateFormatted = $ this -> getStateFormatted ( $ user ) ; $ this -> editAddress = '/#/edituseerrr' ; $ this -> isActive = $ user -> getState ( ) == UserEntity :: USER_STATE_ACTIVE ; $ this -> isDeactive = $ user -> getState ( ) == UserEntity :: USER_STATE_DEACTIVE ; $ this -> isDeleted = $ user -> getState ( ) == UserEntity :: USER_STATE_DELETED ; $ this -> isBanned = $ user -> getState ( ) == UserEntity :: USER_STATE_BANNED ; $ this -> count = 'disabled' ; return $ this ; }
10296	public function writeChart ( \ PhpOffice \ PhpSpreadsheet \ Chart \ Chart $ pChart , $ calculateCellValues = true ) { $ this -> calculateCellValues = $ calculateCellValues ; $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } if ( $ this -> calculateCellValues ) { $ pChart -> refresh ( ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'c:chartSpace' ) ; $ objWriter -> writeAttribute ( 'xmlns:c' , 'http://schemas.openxmlformats.org/drawingml/2006/chart' ) ; $ objWriter -> writeAttribute ( 'xmlns:a' , 'http://schemas.openxmlformats.org/drawingml/2006/main' ) ; $ objWriter -> writeAttribute ( 'xmlns:r' , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships' ) ; $ objWriter -> startElement ( 'c:date1904' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:lang' ) ; $ objWriter -> writeAttribute ( 'val' , 'en-GB' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:roundedCorners' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ this -> writeAlternateContent ( $ objWriter ) ; $ objWriter -> startElement ( 'c:chart' ) ; $ this -> writeTitle ( $ objWriter , $ pChart -> getTitle ( ) ) ; $ objWriter -> startElement ( 'c:autoTitleDeleted' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ this -> writePlotArea ( $ objWriter , $ pChart -> getWorksheet ( ) , $ pChart -> getPlotArea ( ) , $ pChart -> getXAxisLabel ( ) , $ pChart -> getYAxisLabel ( ) , $ pChart -> getChartAxisX ( ) , $ pChart -> getChartAxisY ( ) , $ pChart -> getMajorGridlines ( ) , $ pChart -> getMinorGridlines ( ) ) ; $ this -> writeLegend ( $ objWriter , $ pChart -> getLegend ( ) ) ; $ objWriter -> startElement ( 'c:plotVisOnly' ) ; $ objWriter -> writeAttribute ( 'val' , 1 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:dispBlanksAs' ) ; $ objWriter -> writeAttribute ( 'val' , 'gap' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showDLblsOverMax' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ this -> writePrintSettings ( $ objWriter ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
7053	public static function get_instance ( ) { if ( ! self :: $ instance instanceof self ) { $ new = new self ; $ new -> init ( ) ; self :: $ instance = $ new ; } return self :: $ instance ; }
9258	protected function dumpContainer ( ConfigCache $ cache , ContainerBuilder $ container , $ class , $ baseClass ) { $ dumper = new PhpDumper ( $ container ) ; $ content = $ dumper -> dump ( array ( 'class' => $ class , 'base_class' => $ baseClass ) ) ; $ cache -> write ( $ content , $ container -> getResources ( ) ) ; }
7427	public function renderEmbed ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> embedDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
30	public function appendPackages ( array $ packages , array $ bucket ) { foreach ( $ packages as $ package ) { $ bucket [ $ package -> getName ( ) ] = $ package ; } return $ bucket ; }
11169	public static function boot ( ) { parent :: boot ( ) ; static :: addGlobalScope ( 'type' , function ( $ query ) { return $ query -> when ( static :: class !== StripeObject :: class , function ( $ query ) { $ query -> where ( 'type' , class_basename ( ( new static ( ) ) -> objectClass ) ) ; } ) ; } ) ; static :: created ( function ( StripeObject $ object ) { if ( $ object -> relatesWith ) { list ( $ related , $ tag ) = $ object -> relatesWith ; $ object -> relations ( get_class ( $ related ) ) -> attach ( $ related -> id , [ 'tag' => $ tag ] ) ; } } ) ; }
7011	private function formatS ( & $ str ) { if ( strstr ( $ str , '%S' ) ) $ str = str_replace ( '%S' , static :: ordinal ( $ this -> day ) , $ str ) ; }
2131	public function save ( ) { if ( $ this -> strTop == '' ) { $ this -> strTop = '<?php' ; } $ strFile = trim ( $ this -> strTop ) . "\n\n" ; $ strFile .= "### INSTALL SCRIPT START ###\n" ; foreach ( $ this -> arrData as $ k => $ v ) { $ strFile .= "$k = $v\n" ; } $ strFile .= "### INSTALL SCRIPT STOP ###\n" ; $ this -> strBottom = trim ( $ this -> strBottom ) ; if ( $ this -> strBottom != '' ) { $ strFile .= "\n" . $ this -> strBottom . "\n" ; } $ strTemp = md5 ( uniqid ( mt_rand ( ) , true ) ) ; $ objFile = fopen ( $ this -> strRootDir . '/system/tmp/' . $ strTemp , 'wb' ) ; fwrite ( $ objFile , $ strFile ) ; fclose ( $ objFile ) ; if ( ! filesize ( $ this -> strRootDir . '/system/tmp/' . $ strTemp ) ) { System :: log ( 'The local configuration file could not be written. Have your reached your quota limit?' , __METHOD__ , TL_ERROR ) ; return ; } $ this -> Files -> chmod ( 'system/tmp/' . $ strTemp , 0666 & ~ umask ( ) ) ; $ this -> Files -> rename ( 'system/tmp/' . $ strTemp , 'system/config/localconfig.php' ) ; if ( \ function_exists ( 'opcache_invalidate' ) ) { opcache_invalidate ( $ this -> strRootDir . '/system/config/localconfig.php' , true ) ; } if ( \ function_exists ( 'apc_compile_file' ) && ! ini_get ( 'apc.stat' ) ) { apc_compile_file ( $ this -> strRootDir . '/system/config/localconfig.php' ) ; } $ this -> blnIsModified = false ; }
4962	public function addViewModel ( $ name , $ model , $ priority = 0 ) { $ this -> models -> insert ( $ name , $ model , $ priority ) ; return $ this ; }
10257	public function getAddress ( $ state_code = null , $ zip = null ) { $ address = new Entities \ Address ; if ( ! empty ( $ zip ) && ! empty ( $ state_code ) ) { $ result = Zipcode :: where ( 'zip' , $ zip ) -> where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } elseif ( ! empty ( $ zip ) ) { $ result = Zipcode :: where ( 'zip' , $ zip ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } elseif ( ! empty ( $ state_code ) ) { $ result = Zipcode :: where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } else { $ result = Zipcode :: orderByRaw ( Database :: random ( ) ) -> first ( ) ; } $ address -> line_1 = $ this -> getStreet ( ) ; if ( $ this -> getBool ( true , false ) ) { $ address -> line_2 = $ this -> getApartment ( ) ; } else { $ address -> line_2 = null ; } $ address -> city = $ result -> city ; $ address -> zip = $ result -> zip ; $ address -> county = $ result -> county ; $ address -> state = new Entities \ State ; $ address -> state -> code = $ result -> state_code ; $ address -> state -> name = $ result -> state ; return $ address ; }
7467	public function addColor ( $ color , $ code = null ) { $ newColors = $ this -> parseColor ( $ color , $ code ) ; $ this -> colors = array_merge ( $ this -> colors , $ newColors ) ; return $ this ; }
4947	protected function checkPermission ( $ permission ) { $ perms = array ( self :: PERMISSION_ALL , self :: PERMISSION_CHANGE , self :: PERMISSION_NONE , self :: PERMISSION_VIEW , ) ; if ( ! in_array ( $ permission , $ perms ) ) { throw new \ InvalidArgumentException ( 'Invalid permission. Must be one of ' . implode ( ', ' , $ perms ) ) ; } }
10685	public function get ( $ parameter ) { switch ( $ parameter ) { case "dev" : return $ this -> dev ?? true ; case "config" : return $ this -> config ; case "injector" : return $ this -> injector ; case "pathConfig" : return $ this -> path_config ; case "request" : return $ this -> request ; case "resolver" : return $ this -> resolver ; case "moduleManager" : return $ this -> module_manager ; case "auth" : return $ this -> injector -> getInstance ( Authentication :: class ) ; case "db" : return $ this -> injector -> getInstance ( DB :: class ) ; case "dispatcher" : return $ this -> injector -> getInstance ( Dispatcher :: class ) ; case "template" : return $ this -> injector -> getInstance ( Template :: class ) ; case "mailer" : return $ this -> injector -> getInstance ( SMTPSender :: class ) ; case "i18n" : return $ this -> injector -> getInstance ( I18n :: class ) ; case "processChain" : return $ this -> injector -> getInstance ( ProcessChain :: class ) ; } throw new InvalidArgumentException ( "No such object: $parameter" ) ; }
2540	protected function makeSegmentNameForRequestElement ( $ elementType , $ element ) { $ elementName = '' ; $ sourceArray = [ 'Contact' => ElementManagementData :: SEGNAME_CONTACT_ELEMENT , 'FormOfPayment' => ElementManagementData :: SEGNAME_FORM_OF_PAYMENT , 'MiscellaneousRemark' => ElementManagementData :: SEGNAME_GENERAL_REMARK , 'ReceivedFrom' => ElementManagementData :: SEGNAME_RECEIVE_FROM , 'ServiceRequest' => ElementManagementData :: SEGNAME_SPECIAL_SERVICE_REQUEST , 'Ticketing' => ElementManagementData :: SEGNAME_TICKETING_ELEMENT , 'AccountingInfo' => ElementManagementData :: SEGNAME_ACCOUNTING_INFORMATION , 'Address' => null , 'FrequentFlyer' => ElementManagementData :: SEGNAME_SPECIAL_SERVICE_REQUEST , 'OtherServiceInfo' => ElementManagementData :: SEGNAME_OTHER_SERVICE_INFORMATION , 'ManualCommission' => ElementManagementData :: SEGNAME_COMMISSION , 'SeatRequest' => ElementManagementData :: SEGNAME_SEAT_REQUEST , 'TourCode' => ElementManagementData :: SEGNAME_TOUR_CODE , 'ManualIssuedTicket' => ElementManagementData :: SEGNAME_MANUAL_DOCUMENT_REGISTRATION_WITH_ET_NUMBER ] ; if ( array_key_exists ( $ elementType , $ sourceArray ) ) { $ elementName = $ sourceArray [ $ elementType ] ; if ( $ elementType === 'Address' ) { $ elementName = $ element -> type ; } } return $ elementName ; }
9052	public function getMenuItemsJson ( Collection $ menuItems , $ currentOwner ) { $ this -> alreadySetIds = [ ] ; $ this -> position = 0 ; $ this -> currentOwner = $ currentOwner ; return json_encode ( $ this -> recursiveMenuItemHandling ( $ menuItems ) ) ; }
11431	protected function get ( $ path , array $ parameters = array ( ) , $ requestHeaders = array ( ) ) { if ( array_key_exists ( 'ref' , $ parameters ) && is_null ( $ parameters [ 'ref' ] ) ) { unset ( $ parameters [ 'ref' ] ) ; } $ response = $ this -> client -> getHttpClient ( ) -> get ( $ path , $ parameters , $ requestHeaders ) ; return ResponseMediator :: getContent ( $ response ) ; }
10915	protected function findController ( $ object ) { $ urlargs = $ this -> arguments ; $ arg = $ urlargs -> shift ( ) ; $ controller = $ arg ; if ( ( $ pos = strpos ( $ controller , '.' ) ) !== false ) $ controller = substr ( $ controller , 0 , $ pos ) ; if ( ! method_exists ( $ object , $ controller ) ) { if ( method_exists ( $ object , "index" ) ) { if ( $ controller !== null ) $ urlargs -> unshift ( $ arg ) ; $ controller = "index" ; } else throw new HTTPError ( 404 , "Unknown controller: " . $ controller ) ; } return $ controller ; }
75	public function seek ( $ offset ) { $ this -> rewind ( ) ; for ( $ i = 0 ; $ i < $ offset ; $ i ++ , $ this -> next ( ) ) ; }
1639	protected function setupCallbacks ( Client $ client , Container $ app , array $ config ) { if ( ! isset ( $ config [ 'callbacks' ] ) || $ config [ 'callbacks' ] ) { $ client -> registerDefaultCallbacks ( ) ; $ client -> registerCallback ( function ( Report $ report ) use ( $ app ) { $ tracker = $ app -> make ( Tracker :: class ) ; if ( $ context = $ tracker -> context ( ) ) { $ report -> setContext ( $ context ) ; } if ( $ job = $ tracker -> get ( ) ) { $ report -> setMetaData ( [ 'job' => $ job ] ) ; } } ) ; } if ( ! isset ( $ config [ 'user' ] ) || $ config [ 'user' ] ) { $ client -> registerCallback ( new CustomUser ( function ( ) use ( $ app ) { if ( $ user = $ app -> auth -> user ( ) ) { if ( method_exists ( $ user , 'attributesToArray' ) && is_callable ( [ $ user , 'attributesToArray' ] ) ) { return $ user -> attributesToArray ( ) ; } if ( $ user instanceof GenericUser ) { $ reflection = new ReflectionClass ( $ user ) ; $ property = $ reflection -> getProperty ( 'attributes' ) ; $ property -> setAccessible ( true ) ; return $ property -> getValue ( $ user ) ; } } } ) ) ; } }
6980	protected function findOneAddressBy ( $ expression ) { if ( 0 < $ this -> addresses -> count ( ) ) { $ criteria = Criteria :: create ( ) -> where ( $ expression ) -> setMaxResults ( 1 ) ; $ matches = $ this -> addresses -> matching ( $ criteria ) ; if ( $ matches -> count ( ) == 1 ) { return $ matches -> first ( ) ; } } return null ; }
1882	protected function getMD5Folders ( $ strPath ) { $ arrFiles = array ( ) ; foreach ( scan ( $ this -> strRootDir . '/' . $ strPath ) as $ strFile ) { if ( ! is_dir ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) ) { continue ; } $ arrFiles [ substr ( md5 ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) , 0 , 8 ) ] = 1 ; foreach ( $ this -> getMD5Folders ( $ strPath . '/' . $ strFile ) as $ k => $ v ) { $ arrFiles [ $ k ] = $ v ; } } return $ arrFiles ; }
92	protected static function validateSyntax ( $ json , $ file = null ) { $ parser = new JsonParser ( ) ; $ result = $ parser -> lint ( $ json ) ; if ( null === $ result ) { if ( defined ( 'JSON_ERROR_UTF8' ) && JSON_ERROR_UTF8 === json_last_error ( ) ) { throw new \ UnexpectedValueException ( '"' . $ file . '" is not UTF-8, could not parse as JSON' ) ; } return true ; } throw new ParsingException ( '"' . $ file . '" does not contain valid JSON' . "\n" . $ result -> getMessage ( ) , $ result -> getDetails ( ) ) ; }
12882	public function getUnmappedKeys ( ) { $ u = [ ] ; $ f = $ this -> unmappedForeignKeys ; $ l = $ this -> unmappedLocalKeys ; if ( ! empty ( $ f ) ) { $ u [ 'foreign' ] = $ f ; } if ( ! empty ( $ l ) ) { $ u [ 'local' ] = $ l ; } return $ u ; }
11637	public function getTableRegistry ( ) { if ( is_null ( $ this -> _tableRegistry ) ) { $ objectTypeClass = Yii :: $ app -> classes [ 'ObjectTypeRegistry' ] ; $ this -> _tableRegistry = [ ] ; if ( $ objectTypeClass :: tableExists ( ) ) { $ om = $ objectTypeClass :: find ( ) -> all ( ) ; $ this -> _tableRegistry = ArrayHelper :: index ( $ om , 'name' ) ; } } return $ this -> _tableRegistry ; }
9446	public function getConfigsPath ( Container $ app ) { static $ paths = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ paths [ $ me ] ) ) { $ subpath = $ this -> packOptions [ 'configs_subpath' ] ; $ paths [ $ me ] = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) . '/' . $ subpath ; } return $ paths [ $ me ] ; }
12626	public function post ( $ url , $ data = array ( ) ) { $ client = $ this -> getClient ( ) ; return $ client -> request ( 'POST' , $ url , array ( 'form_params' => $ data ) ) ; }
5562	protected function parse ( $ response , $ depth = 0 ) { $ page = $ this -> buildPage ( $ response ) ; if ( $ this -> ignore_frames || ! $ page -> hasFrames ( ) || ( $ depth > $ this -> maximum_nested_frames ) ) { return $ page ; } $ frameset = new SimpleFrameset ( $ page ) ; foreach ( $ page -> getFrameset ( ) as $ key => $ url ) { $ frame = $ this -> fetch ( $ url , new SimpleGetEncoding ( ) , $ depth + 1 ) ; $ frameset -> addFrame ( $ frame , $ key ) ; } return $ frameset ; }
11499	public static function bulkInsert ( array $ batch ) { $ table = new static ( ) ; if ( 1 === sizeof ( $ batch ) ) { return $ table -> insert ( array_shift ( $ batch ) ) ; } $ adapter = $ table -> getAdapter ( ) ; $ counter = 0 ; $ sqlBinds = [ ] ; $ values = [ ] ; foreach ( $ batch as $ i => $ row ) { $ placeholders = [ ] ; foreach ( $ row as $ column => $ value ) { ++ $ counter ; if ( $ adapter -> supportsParameters ( 'positional' ) ) { $ placeholders [ ] = '?' ; $ values [ ] = $ value ; } elseif ( $ adapter -> supportsParameters ( 'named' ) ) { $ name = ":col{$i}{$counter}" ; $ placeholders [ ] = $ name ; $ values [ $ name ] = $ value ; } else { throw new Zend_Db_Adapter_Exception ( sprintf ( '%s doesn\'t support positional or named binding' , get_class ( $ table ) ) ) ; } } $ sqlBinds [ ] = '(' . implode ( ',' , $ placeholders ) . ')' ; } $ columns = array_keys ( $ row ) ; array_walk ( $ columns , function ( & $ index ) use ( $ adapter ) { $ index = $ adapter -> quoteIdentifier ( $ index , true ) ; } ) ; $ spec = $ adapter -> quoteIdentifier ( ( $ table -> _schema ? "{$table->_schema}." : '' ) . $ table -> _name ) ; $ sql = sprintf ( 'INSERT INTO %s (%s) VALUES %s' , $ spec , implode ( ',' , $ columns ) , implode ( ',' , $ sqlBinds ) ) ; $ stmt = $ adapter -> prepare ( $ sql ) ; $ stmt -> execute ( $ values ) ; return $ stmt -> rowCount ( ) ; }
1316	public function post ( $ path , array $ parameters = [ ] , $ json = false ) { return $ this -> http ( 'POST' , self :: API_HOST , $ path , $ parameters , $ json ) ; }
8330	public function connect ( array $ params , $ username = null , $ password = null , array $ driverOptions = [ ] ) { if ( PlatformHelper :: isWindows ( ) ) { return $ this -> connectWindows ( $ params , $ username , $ password , $ driverOptions ) ; } return $ this -> connectUnix ( $ params , $ username , $ password , $ driverOptions ) ; }
8877	public static function formatDate ( $ timestamp , $ type = 'full_sort' , $ format = '' , $ timezone = null ) { switch ( $ type ) { case 'date_sort' : $ format = 'Y-m-d' ; break ; case 'date_long' : $ format = 'l, F j, Y' ; break ; case 'date_med' : $ format = 'j M Y' ; break ; case 'date_short' : $ format = 'n/d/Y' ; break ; case 'time_sort' : $ format = 'H:i T' ; break ; case 'time_long' : $ format = 'g:i:s A T' ; break ; case 'time_med' : $ format = 'g:i:s A' ; break ; case 'time_short' : $ format = 'g:i A' ; break ; case 'full_sort' : $ format = 'Y-m-d H:i T' ; break ; case 'full_long' : $ format = 'l, F j, Y g:i A T' ; break ; case 'full_med' : $ format = 'j M Y g:i A T' ; break ; case 'full_short' : $ format = 'n/d/Y g:i A T' ; break ; case 'custom' : default : break ; } try { $ date = new \ DateTime ( gmdate ( 'c' , ( int ) $ timestamp ) ) ; if ( isset ( $ timezone ) ) { if ( ! is_object ( $ timezone ) ) { $ timezone = new \ DateTimeZone ( $ timezone ) ; } $ date -> setTimezone ( $ timezone ) ; } else { $ date -> setTimezone ( new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; } } catch ( \ Exception $ e ) { throw new \ Exception ( "Error formatting date: $e" ) ; } return $ date -> format ( $ format ) ; }
6141	public function checkPass ( $ password = null ) { if ( $ password === null ) { $ password = $ this -> pass ; } if ( strlen ( $ password ) == 0 ) { return true ; } $ pattern = "/^(" . $ this -> regex [ "alphanum" ] . "|" . $ this -> regex [ "mark" ] . "|" . $ this -> regex [ "escaped" ] . "|[;:&=+$,])+$/" ; $ status = @ preg_match ( $ pattern , $ password ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI password validation failed" ) ; } return ( $ status == 1 ) ; }
12581	public function previewCardByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_CARD , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
11271	public function render ( $ template , array $ vars = array ( ) ) { ob_start ( ) ; try { $ this -> display ( $ template , $ vars ) ; } catch ( Exception $ exception ) { ob_end_clean ( ) ; throw $ exception ; } return ob_get_clean ( ) ; }
12103	private function phpSizeToBytes ( $ size ) { if ( is_numeric ( $ size ) ) { return $ size ; } $ suffix = substr ( $ size , - 1 ) ; $ value = substr ( $ size , 0 , - 1 ) ; switch ( strtolower ( $ suffix ) ) { case 'p' : $ value *= 1024 ; case 't' : $ value *= 1024 ; case 'g' : $ value *= 1024 ; case 'm' : $ value *= 1024 ; case 'k' : $ value *= 1024 ; break ; } return $ value ; }
11448	public function actionOne ( $ option = null ) { $ fixtures = Yii :: createObject ( Fixtures :: className ( ) ) ; $ option = Question :: displayWithQuit ( 'Select operation' , [ 'Export' , 'Import' ] , $ option ) ; if ( $ option == 'e' ) { $ table = Enter :: display ( 'Enter table name for export' ) ; $ tables = $ fixtures -> export ( [ $ table ] ) ; Output :: items ( $ tables , 'Exported tables' ) ; } elseif ( $ option == 'i' ) { $ table = Enter :: display ( 'Enter table name for import' ) ; $ tables = $ fixtures -> import ( [ $ table ] ) ; Output :: items ( $ tables , 'Imported tables' ) ; } }
9589	public function dropDownListDefault ( $ items , $ options = [ ] ) { Html :: addCssClass ( $ options , 'browser-default' ) ; return parent :: dropDownList ( $ items , $ options ) ; }
1598	protected function validateAllFields ( ) : bool { $ duplicates = collect ( ( array ) $ this -> dataGet ( 'attributes' , [ ] ) ) -> intersectByKeys ( ( array ) $ this -> dataGet ( 'relationships' , [ ] ) ) -> keys ( ) ; $ this -> resourceFieldsExistInAttributesAndRelationships ( $ duplicates ) ; return $ duplicates -> isEmpty ( ) ; }
7550	function wrapInner ( $ node , $ start = 0 , $ end = - 1 , $ wrap_index = - 1 , $ node_index = null ) { if ( $ end < 0 ) { $ end += count ( $ this -> children ) ; } if ( $ node_index === null ) { $ node_index = $ end + 1 ; } if ( ! is_object ( $ node ) ) { $ node = $ this -> addChild ( $ node , $ node_index ) ; } elseif ( $ node -> parent !== $ this ) { $ node -> changeParent ( $ this -> parent , $ node_index ) ; } $ this -> moveChildren ( $ node , $ wrap_index , $ start , $ end ) ; return $ node ; }
7335	private function addMappings ( ClassMetadata $ metadata , array $ mappings ) { foreach ( $ mappings as $ mapping ) { if ( ! $ metadata -> hasField ( $ mapping [ 'fieldName' ] ) ) { $ metadata -> mapField ( $ mapping ) ; } } }
5675	protected function describeObjectDifference ( $ first , $ second , $ identical ) { if ( ! is_object ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } return $ this -> describeArrayDifference ( $ this -> getMembers ( $ first ) , $ this -> getMembers ( $ second ) , $ identical ) ; }
5899	public function listFunctionalities ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/functionalities' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Functionality ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
8250	protected function passwordRehash ( $ username , Password $ password ) { $ userData = $ this -> storage -> getUserByName ( $ username ) ; try { $ this -> userDataEncodePassword ( $ userData , $ password ) ; } catch ( \ PicoAuth \ Security \ Password \ Encoder \ EncoderException $ e ) { $ this -> session -> addFlash ( "error" , "Please set a new password." ) ; $ this -> picoAuth -> getContainer ( ) -> get ( 'PasswordReset' ) -> startPasswordResetSession ( $ username ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ this -> storage -> saveUser ( $ username , $ userData ) ; }
4695	public function limitBy ( ? int $ limit , int $ offset = null ) : self { $ this -> dirty ( ) ; $ this -> limit = $ limit || $ offset ? [ $ limit , $ offset ] : null ; return $ this ; }
167	protected static function loadMimeTypes ( $ magicFile ) { if ( $ magicFile === null ) { $ magicFile = static :: $ mimeMagicFile ; } $ magicFile = Yii :: getAlias ( $ magicFile ) ; if ( ! isset ( self :: $ _mimeTypes [ $ magicFile ] ) ) { self :: $ _mimeTypes [ $ magicFile ] = require $ magicFile ; } return self :: $ _mimeTypes [ $ magicFile ] ; }
3772	private function buildLanguageString ( $ name , $ screen , $ locale ) { if ( isset ( $ screen [ 'label' ] [ $ locale ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ $ locale ] ; return ; } $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ '' ] ; }
4170	public function prettify ( Collection $ packages ) { $ summary = [ ] ; foreach ( $ packages as $ key => $ package ) { $ summary [ ] = [ 'id' => $ key + 1 , 'name' => $ this -> prettifyPackageInfo ( $ package ) , ] ; } return $ packages [ $ this -> askPackageKey ( $ summary ) ] [ 'name' ] ; }
5336	protected function encodeParameters ( $ parameters , $ keyPrefix = null ) { if ( ! is_array ( $ parameters ) && ! is_object ( $ parameters ) ) { return rawurlencode ( $ parameters ) ; } $ encodedData = [ ] ; foreach ( $ parameters as $ key => $ value ) { $ encodedKey = is_null ( $ keyPrefix ) ? rawurlencode ( $ key ) : $ keyPrefix . '[' . rawurlencode ( $ key ) . ']' ; if ( is_array ( $ value ) || is_object ( $ value ) ) { $ encodedData [ ] = $ this -> encodeParameters ( $ value , $ encodedKey ) ; } else { $ encodedData [ ] = $ encodedKey . '=' . rawurlencode ( $ value ) ; } } return implode ( '&' , $ encodedData ) ; }
8735	public function decrement ( $ column , $ amount = 1 , array $ extra = [ ] ) { $ extra = $ this -> addUpdatedAtColumn ( $ extra ) ; return $ this -> noTranslationsQuery ( ) -> decrement ( $ column , $ amount , $ extra ) ; }
6311	public function getTable ( Table $ table ) { return $ this -> container -> get ( 'rentgen.get_table' ) -> setTableName ( $ table -> getName ( ) ) -> execute ( ) ; }
10548	public function setTemplate ( Template $ template ) { $ this -> template = $ template ; $ this -> setVariable ( 'template' , $ template ) ; $ this -> setVariable ( 'tpl' , $ template ) ; return $ this ; }
10294	public static function excelToTimestamp ( $ excelTimestamp , $ timeZone = null ) { return ( int ) self :: excelToDateTimeObject ( $ excelTimestamp , $ timeZone ) -> format ( 'U' ) ; }
3477	public function withLocalizedTitle ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> title = '' ; $ cloned -> titleLocalized = $ localized ; return $ cloned ; }
3220	function restoreFile ( $ path , $ rev ) { Path :: checkArgNonRoot ( "path" , $ path ) ; Checker :: argStringNonEmpty ( "rev" , $ rev ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/restore" , $ path ) , array ( "rev" => $ rev ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
3936	private function setWidgetType ( PropertyInterface $ property , $ propInfo ) { if ( null !== $ property -> getWidgetType ( ) || ! isset ( $ propInfo [ 'inputType' ] ) ) { return ; } $ property -> setWidgetType ( $ propInfo [ 'inputType' ] ) ; }
11775	protected function getIsEnabled ( ) : \ Illuminate \ Database \ Eloquent \ Model { $ result = Model \ Setting :: find ( 1 ) ; $ result -> value = ( bool ) $ result -> value ; return $ result ; }
12528	public function getLocalDataSource ( $ localModelClass ) { foreach ( $ this -> dataSources as $ dataSource ) { if ( $ dataSource -> localModel === $ localModelClass ) { return $ dataSource ; } } return false ; }
4150	protected function getBinaryFile ( $ filename ) { if ( ! file_exists ( $ filename ) ) { throw new FileNotFoundException ; } if ( ! is_readable ( $ filename ) ) { throw new FileNotReadableException ; } ob_start ( ) ; readfile ( $ filename ) ; $ binary = ob_get_contents ( ) ; ob_end_clean ( ) ; unset ( $ filename ) ; return $ binary ; }
11528	public function registerCustomHelpers ( ) { foreach ( glob ( app_path ( $ this -> namespace . '/*' ) ) as $ helper ) { $ helperName = last ( explode ( '/' , $ helper ) ) ; if ( ! in_array ( $ helperName , $ this -> customExclude ) ) { if ( in_array ( '*' , $ this -> customInclude ) || in_array ( $ helperName , $ this -> customInclude ) ) { require_once $ helper ; } } } }
11642	public function getTotalItems ( ) { if ( is_null ( $ this -> _totalItems ) ) { $ this -> _totalItems = $ this -> dataProvider -> totalItemCount ; } return $ this -> _totalItems ; }
7381	public function route ( bool $ dropIndex = false ) : string { if ( $ dropIndex ) { if ( 'index' == $ this -> route ) { return '' ; } } return $ this -> route ; }
2146	protected function generateEmailObject ( Result $ objNewsletter , $ arrAttachments ) { $ objEmail = new Email ( ) ; $ objEmail -> from = $ objNewsletter -> sender ; $ objEmail -> subject = $ objNewsletter -> subject ; if ( $ objNewsletter -> senderName != '' ) { $ objEmail -> fromName = $ objNewsletter -> senderName ; } $ objEmail -> embedImages = ! $ objNewsletter -> externalImages ; $ objEmail -> logFile = TL_NEWSLETTER . '_' . $ objNewsletter -> id ; if ( ! empty ( $ arrAttachments ) && \ is_array ( $ arrAttachments ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( $ arrAttachments as $ strAttachment ) { $ objEmail -> attachFile ( $ rootDir . '/' . $ strAttachment ) ; } } return $ objEmail ; }
8039	public function buildEventData ( array $ data ) { $ start = strtotime ( $ data [ 'start' ] [ 'date' ] . ' ' . $ data [ 'start' ] [ 'time' ] ) ; $ start = date ( 'Y-m-d H:i:s' , $ start ) ; $ end = null ; if ( array_key_exists ( 'end' , $ data ) ) { $ end = strtotime ( $ data [ 'end' ] [ 'date' ] . ' ' . $ data [ 'end' ] [ 'time' ] ) ; $ end = date ( 'Y-m-d H:i:s' , $ end ) ; if ( strtotime ( $ end ) < strtotime ( $ start ) ) { throw new DateDifferenceException ( 'Start date bigger then end date!' ) ; } } $ event = [ 'title' => $ data [ 'title' ] , 'description' => $ data [ 'description' ] , 'start' => $ start , 'end' => $ end , 'all_day' => array_key_exists ( 'all_day' , $ data ) , 'border_color' => $ data [ 'border_color' ] , 'background_color' => $ data [ 'background_color' ] , 'text_color' => $ data [ 'text_color' ] , ] ; return $ event ; }
11705	public function synchronizeEntity ( $ sSynchronizeEntity , $ iId = null ) { if ( $ iId !== null ) { $ this -> _iIdEntity = $ iId ; } $ this -> _sSynchronizeEntity = $ sSynchronizeEntity ; return $ this ; }
5999	public function setProtocol ( $ protocol ) { if ( $ protocol instanceof Protocol ) { $ this -> protocol = $ protocol ; } elseif ( is_array ( $ protocol ) ) { $ this -> protocol = new Protocol ( $ protocol ) ; } else { $ this -> protocol = null ; trigger_error ( 'Argument must be an object of class Protocol. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
11065	public function icon ( $ level , $ default = null ) { if ( array_key_exists ( $ level , $ this -> icons ) ) { return $ this -> icons [ $ level ] ; } return $ default ; }
5588	public function setCookies ( array $ lstCookies ) { foreach ( $ lstCookies as $ aCookies ) { $ this -> cookie_jar -> setCookie ( $ aCookies [ 'name' ] , $ aCookies [ 'value' ] , $ aCookies [ 'host' ] , $ aCookies [ 'path' ] , $ aCookies [ 'expiry' ] ) ; } }
4964	public function addViewVariables ( $ name , $ data = [ ] , $ priority = 0 ) { if ( is_array ( $ name ) ) { if ( ! isset ( $ name [ 'name' ] ) ) { throw new \ DomainException ( 'Key "name" must be specified, if array is passed as first parameter.' ) ; } if ( is_int ( $ data ) ) { $ priority = $ data ; } $ data = $ name ; $ name = $ data [ 'name' ] ; } elseif ( is_int ( $ data ) ) { $ priority = $ data ; $ data = [ ] ; } if ( ! isset ( $ data [ 'name' ] ) ) { $ data [ 'name' ] = $ name ; } return $ this -> addViewTemplate ( $ name , "core/admin/dashboard-widget" , $ data , $ priority ) ; }
10282	public static function splitRange ( $ pRange ) { if ( empty ( $ pRange ) ) { $ pRange = self :: DEFAULT_RANGE ; } $ exploded = explode ( ',' , $ pRange ) ; $ counter = count ( $ exploded ) ; for ( $ i = 0 ; $ i < $ counter ; ++ $ i ) { $ exploded [ $ i ] = explode ( ':' , $ exploded [ $ i ] ) ; } return $ exploded ; }
10299	private function writeDataLabels ( XMLWriter $ objWriter , Layout $ chartLayout = null ) { $ objWriter -> startElement ( 'c:dLbls' ) ; $ objWriter -> startElement ( 'c:showLegendKey' ) ; $ showLegendKey = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowLegendKey ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showLegendKey ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showVal' ) ; $ showVal = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowVal ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showVal ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showCatName' ) ; $ showCatName = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowCatName ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showCatName ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showSerName' ) ; $ showSerName = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowSerName ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showSerName ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showPercent' ) ; $ showPercent = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowPercent ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showPercent ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showBubbleSize' ) ; $ showBubbleSize = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowBubbleSize ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showBubbleSize ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showLeaderLines' ) ; $ showLeaderLines = ( empty ( $ chartLayout ) ) ? 1 : $ chartLayout -> getShowLeaderLines ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showLeaderLines ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
1288	private function buildContentTypeCollection ( array $ data ) { $ items = \ array_merge ( $ data [ 'items' ] , $ data [ 'includes' ] [ 'Entry' ] ?? [ ] ) ; $ ids = \ array_map ( function ( array $ item ) { return 'Entry' === $ item [ 'sys' ] [ 'type' ] ? $ item [ 'sys' ] [ 'contentType' ] [ 'sys' ] [ 'id' ] : null ; } , $ items ) ; $ ids = \ array_filter ( \ array_unique ( $ ids ) , function ( $ id ) : bool { return $ id && ! $ this -> resourcePool -> has ( 'ContentType' , $ id ) ; } ) ; if ( $ ids ) { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , \ implode ( ',' , $ ids ) ) ; $ this -> client -> getContentTypes ( $ query ) ; } }
9375	public function render ( $ template , array $ data = array ( ) ) { list ( $ file , $ name ) = array ( null , str_replace ( '.' , '/' , $ template ) ) ; foreach ( ( array ) $ this -> paths as $ key => $ path ) { $ files = ( array ) $ this -> files ( $ path ) ; $ item = $ this -> check ( $ files , $ path , $ key , $ name . '.php' ) ; $ item !== null && $ file = $ item ; } if ( is_null ( $ file ) === true ) { $ message = 'Template file "' . $ name . '" not found.' ; throw new \ InvalidArgumentException ( ( string ) $ message ) ; } return $ this -> extract ( $ file , $ data ) ; }
2623	public function daysFromInstallation ( ) { $ stat = $ this -> statisticRepository -> getStatByAction ( self :: FASTLY_INSTALLED_FLAG ) ; if ( ! $ stat -> getCreatedAt ( ) ) { return null ; } $ installDate = date_create ( $ stat -> getCreatedAt ( ) ) ; $ currentDate = date_create ( $ this -> dateTime -> gmtDate ( ) ) ; $ dateDiff = date_diff ( $ installDate , $ currentDate ) ; return $ dateDiff -> days ; }
12278	public function moveUser ( $ openId , $ groupId ) { $ params = [ 'openid' => $ openId , 'to_groupid' => $ groupId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_UPDATE , $ params ] ) ; }
10405	public function set ( $ key , $ value ) { $ pair = $ this -> repository -> find ( $ key ) ; if ( $ pair === null ) { $ pair = new Pair ( ) ; $ pair -> setId ( $ key ) ; } $ pair -> setValue ( $ value ) ; $ this -> save ( $ pair ) ; return $ pair ; }
2377	public static function convertEncoding ( $ str , $ to , $ from = null ) { if ( $ str == '' ) { return '' ; } if ( ! $ from ) { $ from = mb_detect_encoding ( $ str , 'ASCII,ISO-2022-JP,UTF-8,EUC-JP,ISO-8859-1' ) ; } if ( $ from == $ to ) { return $ str ; } if ( $ from == 'UTF-8' && $ to == 'ISO-8859-1' ) { return utf8_decode ( $ str ) ; } if ( $ from == 'ISO-8859-1' && $ to == 'UTF-8' ) { return utf8_encode ( $ str ) ; } return mb_convert_encoding ( $ str , $ to , $ from ) ; }
1532	protected function deserialize ( array $ document , $ record = null ) : ResourceObject { $ data = $ document [ 'data' ] ?? [ ] ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { throw new \ InvalidArgumentException ( 'Expecting a JSON API document with a data member.' ) ; } return ResourceObject :: create ( $ data ) ; }
1464	private function guessKey ( ) { if ( $ this -> query instanceof EloquentBuilder || $ this -> query instanceof Relation ) { return $ this -> query -> getModel ( ) -> getRouteKeyName ( ) ; } return 'id' ; }
1145	public function getRule ( $ attribute , $ rule , $ parameters , $ rawRule ) { $ isConditional = $ this -> isConditionalRule ( $ attribute , $ rawRule ) ; $ isRemote = $ this -> isRemoteRule ( $ rule ) ; if ( $ isConditional || $ isRemote ) { list ( $ attribute , $ parameters ) = $ this -> remoteRule ( $ attribute , $ isConditional ) ; $ jsRule = self :: REMOTE_RULE ; } else { list ( $ jsRule , $ attribute , $ parameters ) = $ this -> clientRule ( $ attribute , $ rule , $ parameters ) ; } $ attribute = $ this -> getAttributeName ( $ attribute ) ; return [ $ attribute , $ jsRule , $ parameters ] ; }
4761	public function flush ( ) { if ( $ this -> doNotTrack ) { return ; } if ( empty ( $ this -> queue ) ) { return ; } if ( $ this -> mergePackets ) { $ this -> send ( implode ( "\n" , $ this -> queue ) ) ; } else { foreach ( $ this -> queue as $ data ) { $ this -> send ( $ data ) ; } } $ this -> queue = array ( ) ; $ this -> queueSize = 0 ; }
6728	public function set_total_votes ( $ post_id , $ votes ) { $ votes = json_encode ( $ votes , true ) ; if ( ! add_post_meta ( $ post_id , 'imdbTotalVotes' , $ votes , true ) ) { update_post_meta ( $ post_id , 'imdbTotalVotes' , $ votes ) ; } }
993	public static function isValidLiteralValue ( Type $ type , $ valueNode ) { $ emptySchema = new Schema ( [ ] ) ; $ emptyDoc = new DocumentNode ( [ 'definitions' => [ ] ] ) ; $ typeInfo = new TypeInfo ( $ emptySchema , $ type ) ; $ context = new ValidationContext ( $ emptySchema , $ emptyDoc , $ typeInfo ) ; $ validator = new ValuesOfCorrectType ( ) ; $ visitor = $ validator -> getVisitor ( $ context ) ; Visitor :: visit ( $ valueNode , Visitor :: visitWithTypeInfo ( $ typeInfo , $ visitor ) ) ; return $ context -> getErrors ( ) ; }
12575	public function previewByName ( $ msgType , $ message , $ to ) { return $ this -> preview ( $ msgType , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
2462	public function generateMarkup ( ) { $ intMaxSize = round ( static :: getMaxUploadSize ( ) / 1024 / 1024 ) ; $ strAccepted = implode ( ',' , array_map ( function ( $ a ) { return '.' . $ a ; } , StringUtil :: trimsplit ( ',' , strtolower ( Config :: get ( 'uploadTypes' ) ) ) ) ) ; $ GLOBALS [ 'TL_CSS' ] [ ] = 'assets/dropzone/css/dropzone.min.css' ; $ GLOBALS [ 'TL_JAVASCRIPT' ] [ ] = 'assets/dropzone/js/dropzone.min.js' ; $ return = ' <input type="hidden" name="action" value="fileupload"> <div class="fallback"> <input type="file" name="' . $ this -> strName . '[]" class="tl_upload_field" onfocus="Backend.getScrollOffset()" multiple> </div> <div class="dropzone"> <div class="dz-default dz-message"> <span>' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzone' ] . '</span> </div> <span class="dropzone-previews"></span> </div> <script> Dropzone.autoDiscover = false; window.addEvent("domready", function() { new Dropzone("#tl_files", { paramName: "' . $ this -> strName . '", maxFilesize: ' . $ intMaxSize . ', acceptedFiles: "' . $ strAccepted . '", timeout: 0, previewsContainer: ".dropzone-previews", clickable: ".dropzone", dictFileTooBig: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneFileTooBig' ] ) . ', dictInvalidFileType: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneInvalidType' ] ) . ' }).on("addedfile", function() { $$(".dz-message").setStyle("display", "none"); }).on("success", function(file, message) { if (!message) return; var container = $("tl_message"); if (!container) { container = new Element("div", { "id": "tl_message", "class": "tl_message" }).inject($("tl_buttons"), "before"); } container.appendHTML(message); }); $$("div.tl_formbody_submit").setStyle("display", "none"); }); </script>' ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] ) ) { $ return .= ' <p class="tl_help tl_tip">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] , System :: getReadableSize ( static :: getMaxUploadSize ( ) ) , Config :: get ( 'gdMaxImgWidth' ) . 'x' . Config :: get ( 'gdMaxImgHeight' ) ) . '</p>' ; } return $ return ; }
3905	protected function getPropertyNames ( ) { $ propertyNames = array ( 'id' , 'pid' , 'tstamp' , 'sorting' ) ; if ( $ this -> getItem ( ) -> getMetaModel ( ) -> hasVariants ( ) ) { $ propertyNames [ ] = 'varbase' ; $ propertyNames [ ] = 'vargroup' ; } return array_merge ( $ propertyNames , array_keys ( $ this -> getItem ( ) -> getMetaModel ( ) -> getAttributes ( ) ) ) ; }
11773	private function findComponentModuleByType ( array $ module_list , string $ find_component_type ) { foreach ( $ module_list as $ m ) { $ component_type = call_user_func ( [ $ m , 'declareComponentType' ] ) ; if ( $ component_type == $ find_component_type ) { return $ m ; } } return null ; }
3628	protected static function getCURLCerts ( ) { $ url = 'https://curl.haxx.se/ca/cacert.pem' ; $ certs = @ file_get_contents ( $ url ) ; if ( ! $ certs ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , TRUE ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , TRUE ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , 2 ) ; $ response = curl_exec ( $ ch ) ; $ info = curl_getinfo ( $ ch ) ; curl_close ( $ ch ) ; if ( $ info [ 'http_code' ] == 200 ) { $ certs = $ response ; } } return $ certs ; }
9243	private function __setCookieAndLocale ( $ locale ) { if ( PHP_SAPI !== 'cli' ) { $ time = $ this -> __getCookieExpireTime ( ) ; I18n :: locale ( $ locale ) ; setcookie ( $ this -> __getCookieName ( ) , $ locale , $ time , '/' , $ this -> config ( 'Cookie.domain' ) ) ; } }
10249	public function getDate ( $ params = [ ] , $ format = 'Y-m-d' ) { foreach ( $ params as $ k => $ v ) { $ $ k = $ v ; } if ( ! isset ( $ min_year ) ) { $ min_year = date ( 'Y' ) - 2 ; } if ( ! isset ( $ max_year ) ) { $ max_year = date ( 'Y' ) ; } if ( ! isset ( $ min_month ) ) { $ min_month = 1 ; } if ( ! isset ( $ max_month ) ) { $ max_month = 12 ; } $ rand_year = rand ( $ min_year , $ max_year ) ; $ rand_month = rand ( $ min_month , $ max_month ) ; $ date = DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , '01' ] ) ) ; $ days_in_month = $ date -> format ( 't' ) ; $ rand_day = rand ( 1 , $ days_in_month ) ; return DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , $ rand_day ] ) ) -> format ( $ format ) ; }
12244	public function sortedXPath ( $ xpath ) { $ nodes = $ this -> xpath ( $ xpath ) ; $ args = func_get_args ( ) ; $ args [ 0 ] = & $ nodes ; call_user_func_array ( array ( get_class ( $ this ) , 'sort' ) , $ args ) ; return $ nodes ; }
2732	public function execute ( ) { $ types = $ this -> cacheManager -> getAvailableTypes ( ) ; $ types = array_diff ( $ types , [ 'full_page' ] ) ; $ this -> cacheManager -> clean ( $ types ) ; $ result = $ this -> api -> cleanAll ( ) ; if ( $ result === true ) { $ this -> messageManager -> addSuccessMessage ( __ ( 'Full Magento & Fastly Cache has been cleaned.' ) ) ; } else { $ this -> getMessageManager ( ) -> addErrorMessage ( __ ( 'Full Magento & Fastly Cache was not cleaned successfully.' ) ) ; } return $ this -> _redirect ( '*/cache/index' ) ; }
8125	protected function getSchemaRequested ( ) { $ parts = $ this -> owner -> getRequest ( ) -> getHeader ( LeftAndMain :: SCHEMA_HEADER ) ; return ! empty ( $ parts ) ; }
9993	private function createCSSStyle ( Style $ pStyle ) { $ css = array_merge ( $ this -> createCSSStyleAlignment ( $ pStyle -> getAlignment ( ) ) , $ this -> createCSSStyleBorders ( $ pStyle -> getBorders ( ) ) , $ this -> createCSSStyleFont ( $ pStyle -> getFont ( ) ) , $ this -> createCSSStyleFill ( $ pStyle -> getFill ( ) ) ) ; return $ css ; }
2339	public function renderDropdown ( ) { $ objVersion = $ this -> Database -> prepare ( "SELECT tstamp, version, username, active FROM tl_version WHERE fromTable=? AND pid=? ORDER BY version DESC" ) -> execute ( $ this -> strTable , $ this -> intPid ) ; if ( $ objVersion -> numRows < 2 ) { return '' ; } $ versions = '' ; while ( $ objVersion -> next ( ) ) { $ versions .= ' <option value="' . $ objVersion -> version . '"' . ( $ objVersion -> active ? ' selected="selected"' : '' ) . '>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'version' ] . ' ' . $ objVersion -> version . ' (' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ objVersion -> tstamp ) . ') ' . $ objVersion -> username . '</option>' ; } return '<div class="tl_version_panel"><form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_version" class="tl_form" method="post" aria-label="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'versioning' ] ) . '"><div class="tl_formbody"><input type="hidden" name="FORM_SUBMIT" value="tl_version"><input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"><select name="version" class="tl_select">' . $ versions . '</select><button type="submit" name="showVersion" id="showVersion" class="tl_submit">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'restore' ] . '</button><a href="' . Backend :: addToUrl ( 'versions=1&amp;popup=1' ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) . '" onclick="Backend.openModalIframe({\'title\':\'' . StringUtil :: specialchars ( str_replace ( "'" , "\\'" , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] , $ this -> intPid , $ this -> strTable ) ) ) . '\',\'url\':this.href});return false">' . Image :: getHtml ( 'diff.svg' ) . '</a></div></form></div>' ; }
12757	public function routeStartup ( Zend_Controller_Request_Abstract $ request ) { if ( ! $ request -> getHeader ( 'User-Agent' ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 403 ) -> setHeader ( 'Content-Type' , 'text/plain; charset=utf-8' ) -> setBody ( implode ( "\n" , self :: $ _errMessage ) ) -> sendResponse ( ) ; exit ( 403 ) ; } }
2304	public function createPageList ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( $ this -> User -> isAdmin ) { return $ this -> doCreatePageList ( ) ; } $ return = '' ; $ processed = array ( ) ; foreach ( $ this -> eliminateNestedPages ( $ this -> User -> pagemounts ) as $ page ) { $ objPage = PageModel :: findWithDetails ( $ page ) ; if ( $ objPage -> type == 'root' ) { $ title = $ objPage -> title ; $ start = $ objPage -> id ; } else { $ title = $ objPage -> rootTitle ; $ start = $ objPage -> rootId ; } if ( \ in_array ( $ start , $ processed ) ) { continue ; } if ( $ objPage -> domain && $ objPage -> domain != Environment :: get ( 'host' ) ) { continue ; } $ processed [ ] = $ start ; $ return .= '<optgroup label="' . $ title . '">' . $ this -> doCreatePageList ( $ start ) . '</optgroup>' ; } return $ return ; }
11280	public static function getErrorString ( int $ errno ) { $ errno = intval ( $ errno ) ; $ errors = array ( E_ERROR => 'E_ERROR' , E_WARNING => 'E_WARNING' , E_PARSE => 'E_PARSE' , E_NOTICE => 'E_NOTICE' , E_CORE_ERROR => 'E_CORE_ERROR' , E_CORE_WARNING => 'E_CORE_WARNING' , E_COMPILE_ERROR => 'E_COMPILE_ERROR' , E_COMPILE_WARNING => 'E_COMPILE_WARNING' , E_USER_ERROR => 'E_USER_ERROR' , E_USER_NOTICE => 'E_USER_NOTICE' , E_STRICT => 'E_STRICT' , E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR' , ) ; $ errors [ 8192 ] = 'E_DEPRECATED' ; $ errors [ 16384 ] = 'E_USER_DEPRECATED' ; $ errors_desc = array ( ) ; foreach ( $ errors as $ key => $ value ) { if ( ( $ errno & $ key ) != 0 ) { $ errors_desc [ ] = $ value ; } } return implode ( '|' , $ errors_desc ) ; }
10256	public function getState ( $ state_code = null ) { if ( ! empty ( $ state_code ) ) { $ res = Zipcode :: where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } else { $ res = Zipcode :: orderByRaw ( Database :: random ( ) ) -> first ( ) ; } $ State = new Entities \ State ; $ State -> code = $ res -> state_code ; $ State -> name = $ res -> state ; return $ State ; }
4148	protected function findExceptions ( $ response ) { $ response = $ response [ 'body' ] ; $ data = json_decode ( $ response , true ) ; if ( isset ( $ response [ 0 ] ) && $ response [ 0 ] !== '{' && $ response [ 0 ] !== '[' && ! $ data ) { if ( strpos ( $ response , 'oauth_token=' ) !== false ) { parse_str ( $ response , $ data ) ; } if ( empty ( $ data ) || ! is_array ( $ data ) ) { throw new TwitterException ( $ response , 0 ) ; } return json_encode ( $ data ) ; } if ( ! empty ( $ data [ 'errors' ] ) || ! empty ( $ data [ 'error' ] ) ) { if ( ! empty ( $ data [ 'errors' ] ) ) { $ data = current ( $ data [ 'errors' ] ) ; } if ( empty ( $ data [ 'message' ] ) && ! empty ( $ data [ 'error' ] ) ) { $ data [ 'message' ] = $ data [ 'error' ] ; } if ( ! isset ( $ data [ 'code' ] ) || empty ( $ data [ 'code' ] ) ) { $ data [ 'code' ] = 0 ; } throw new TwitterException ( $ data [ 'message' ] , $ data [ 'code' ] ) ; } unset ( $ data ) ; return $ response ; }
5151	protected function textAfterString ( $ haystack , $ needle ) { $ result = "" ; $ needleLength = strlen ( $ needle ) ; if ( $ needleLength > 0 && preg_match ( "#$needle([^\r\n]+)#i" , $ haystack , $ match ) ) { $ result = trim ( substr ( $ match [ 0 ] , - ( strlen ( $ match [ 0 ] ) - $ needleLength ) ) ) ; } return $ result ; }
9217	protected function parsePageLinks ( $ headers = false ) { $ pagination = [ ] ; if ( ! $ headers ) { $ headers = $ this -> api -> lastHeader ( 'link' ) ; } if ( preg_match_all ( '%<([^>]*)>\s*;\s*rel="([^"]+)"%' , $ headers , $ links , PREG_SET_ORDER ) ) { foreach ( $ links as $ link ) { $ pagination [ $ link [ 2 ] ] = new CanvasPageLink ( $ link [ 1 ] , $ link [ 2 ] ) ; } } return $ pagination ; }
9045	protected function getConfig ( ) { if ( $ this -> config === null ) { if ( file_exists ( $ this -> filename ) ) { $ this -> filename = realpath ( $ this -> filename ) ; $ this -> config = new Config ( include $ this -> filename , true ) ; } else { $ this -> filename = getcwd ( ) . $ this -> filename ; $ this -> config = new Config ( [ ] , true ) ; } } return $ this -> config ; }
7188	private function buildCombinations ( $ quantity ) { if ( empty ( $ this -> map ) ) { return [ ] ; } $ combinations = [ ] ; foreach ( $ this -> map as $ id => $ qty ) { $ combinations [ ] = new AssignmentCombination ( [ $ id => $ qty ] , $ diff = $ qty - $ quantity ) ; if ( $ diff == 0 ) { return $ combinations ; } } for ( $ length = 2 ; $ length < count ( $ this -> map ) ; $ length ++ ) { foreach ( combine_assoc ( $ this -> map , $ length ) as $ map ) { $ combinations [ ] = new AssignmentCombination ( $ map , $ diff = array_sum ( $ map ) - $ quantity ) ; if ( $ diff == 0 ) { return $ combinations ; } } } $ combinations [ ] = new AssignmentCombination ( $ this -> map , array_sum ( $ this -> map ) - $ quantity ) ; return $ combinations ; }
8228	protected function assertLimits ( ) { if ( $ this -> storage -> getUsersCount ( ) >= $ this -> config [ "maxUsers" ] ) { $ this -> session -> addFlash ( "error" , "New registrations are currently disabled." ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } }
3597	protected function createIndexes ( ) { $ this -> createIndex ( $ this -> db -> getIndexName ( '{{%dolphiq_sitemap_entries}}' , [ 'type' , 'linkId' ] , true ) , '{{%dolphiq_sitemap_entries}}' , [ 'type' , 'linkId' ] , true ) ; switch ( $ this -> driver ) { case DbConfig :: DRIVER_MYSQL : break ; case DbConfig :: DRIVER_PGSQL : break ; } }
4299	public function countReset ( $ label = 'default' , $ flags = null ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; if ( \ count ( $ args ) == 1 && \ is_int ( $ args [ 0 ] ) ) { $ label = 'default' ; $ flags = $ args [ 0 ] ; } else { $ args = \ array_combine ( array ( 'label' , 'flags' ) , \ array_replace ( array ( 'default' , 0 ) , $ args ) ) ; \ extract ( $ args ) ; } if ( isset ( $ this -> data [ 'counts' ] [ $ label ] ) ) { $ this -> data [ 'counts' ] [ $ label ] = 0 ; $ args = array ( ( string ) $ label , 0 , ) ; } else { $ args = array ( 'Counter \'' . $ label . '\' doesn\'t exist.' ) ; } if ( ! ( $ flags & self :: COUNT_NO_OUT ) ) { $ this -> appendLog ( 'countReset' , $ args , $ meta ) ; } }
8825	protected function valid_cc ( $ data ) { $ number = preg_replace ( '/\D/' , '' , $ data ) ; if ( function_exists ( 'mb_strlen' ) ) { $ number_length = mb_strlen ( $ number ) ; } else { $ number_length = strlen ( $ number ) ; } $ parity = $ number_length % 2 ; $ total = 0 ; for ( $ i = 0 ; $ i < $ number_length ; $ i ++ ) { $ digit = $ number [ $ i ] ; if ( $ i % 2 == $ parity ) { $ digit *= 2 ; if ( $ digit > 9 ) { $ digit -= 9 ; } } $ total += $ digit ; } return ( $ total % 10 == 0 ) ? true : false ; }
8462	public static function getBaseUrl ( ) { $ uri = self :: addBackSlash ( self :: getUriMethods ( ) , 'both' ) ; $ url = self :: addBackSlash ( self :: getCurrentPage ( ) ) ; if ( $ uri !== '/' ) { $ url = trim ( str_replace ( $ uri , '' , $ url ) , '/' ) ; } return self :: addBackSlash ( $ url ) ; }
6464	public function isJson ( HttpHeaders $ headers ) : bool { $ contentType = null ; $ headers -> tryGetFirst ( 'Content-Type' , $ contentType ) ; return preg_match ( "/application\/json/i" , $ contentType ) === 1 ; }
4368	public function & offsetGet ( $ key ) { if ( $ this -> hasValue ( $ key ) ) { return $ this -> values [ $ key ] ; } $ null = null ; return $ null ; }
3654	public function purge ( ) { foreach ( $ GLOBALS [ 'TL_PURGE' ] [ 'folders' ] [ 'metamodels_assets' ] [ 'affected' ] as $ folderName ) { $ folder = new \ Folder ( $ folderName ) ; $ folder -> purge ( ) ; } $ dispatcher = $ GLOBALS [ 'container' ] [ 'event-dispatcher' ] ; $ dispatcher -> dispatch ( ContaoEvents :: SYSTEM_LOG , new LogEvent ( 'Purged the MetaModels assets' , __METHOD__ , TL_CRON ) ) ; }
8490	public static function getUpTime ( ) { $ wmi = Windows :: getInstance ( ) ; $ booted_str = '' ; foreach ( $ wmi -> ExecQuery ( "SELECT LastBootUpTime FROM Win32_OperatingSystem" ) as $ os ) { $ booted_str = $ os -> LastBootUpTime ; } $ booted = [ 'year' => substr ( $ booted_str , 0 , 4 ) , 'month' => substr ( $ booted_str , 4 , 2 ) , 'day' => substr ( $ booted_str , 6 , 2 ) , 'hour' => substr ( $ booted_str , 8 , 2 ) , 'minute' => substr ( $ booted_str , 10 , 2 ) , 'second' => substr ( $ booted_str , 12 , 2 ) ] ; $ booted_ts = mktime ( $ booted [ 'hour' ] , $ booted [ 'minute' ] , $ booted [ 'second' ] , $ booted [ 'month' ] , $ booted [ 'day' ] , $ booted [ 'year' ] ) ; return date ( 'm/d/y h:i A (T)' , $ booted_ts ) ; }
3247	public function add ( $ item , $ quantity = 1 , $ quantityReset = false ) { if ( ! is_array ( $ item ) && ! $ item -> isShoppable ) return ; $ cartItem = $ this -> getItem ( is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku ) ; if ( empty ( $ cartItem ) ) { $ reflection = null ; if ( is_object ( $ item ) ) { $ reflection = new \ ReflectionClass ( $ item ) ; } $ cartItem = call_user_func ( Config :: get ( 'shop.item' ) . '::create' , [ 'user_id' => $ this -> user -> shopId , 'cart_id' => $ this -> attributes [ 'id' ] , 'sku' => is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku , 'price' => is_array ( $ item ) ? $ item [ 'price' ] : $ item -> price , 'tax' => is_array ( $ item ) ? ( array_key_exists ( 'tax' , $ item ) ? $ item [ 'tax' ] : 0 ) : ( isset ( $ item -> tax ) && ! empty ( $ item -> tax ) ? $ item -> tax : 0 ) , 'shipping' => is_array ( $ item ) ? ( array_key_exists ( 'shipping' , $ item ) ? $ item [ 'shipping' ] : 0 ) : ( isset ( $ item -> shipping ) && ! empty ( $ item -> shipping ) ? $ item -> shipping : 0 ) , 'currency' => Config :: get ( 'shop.currency' ) , 'quantity' => $ quantity , 'class' => is_array ( $ item ) ? null : $ reflection -> getName ( ) , 'reference_id' => is_array ( $ item ) ? null : $ item -> shopId , ] ) ; } else { $ cartItem -> quantity = $ quantityReset ? $ quantity : $ cartItem -> quantity + $ quantity ; $ cartItem -> save ( ) ; } $ this -> resetCalculations ( ) ; return $ this ; }
7709	function GetInnerSrc ( ) { return ( $ this -> pET_PosBeg === false ) ? false : substr ( $ this -> Txt , $ this -> pST_PosEnd + 1 , $ this -> pET_PosBeg - $ this -> pST_PosEnd - 1 ) ; }
8722	public function translate ( $ locale ) { $ found = $ this -> translations -> where ( $ this -> getLocaleKey ( ) , $ locale ) -> first ( ) ; if ( ! $ found && $ this -> shouldFallback ( $ locale ) ) { return $ this -> translate ( $ this -> getFallbackLocale ( ) ) ; } return $ found ; }
1060	public static function findDangerousChanges ( Schema $ oldSchema , Schema $ newSchema ) { return array_merge ( self :: findArgChanges ( $ oldSchema , $ newSchema ) [ 'dangerousChanges' ] , self :: findValuesAddedToEnums ( $ oldSchema , $ newSchema ) , self :: findInterfacesAddedToObjectTypes ( $ oldSchema , $ newSchema ) , self :: findTypesAddedToUnions ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnInputObjectTypes ( $ oldSchema , $ newSchema ) [ 'dangerousChanges' ] ) ; }
5035	public function setFrom ( $ email , $ name = null ) { if ( is_array ( $ email ) ) { $ this -> from = [ $ email [ 'email' ] => $ email [ 'name' ] ] ; } else { $ this -> from = is_object ( $ email ) || null === $ name ? $ email : array ( $ email => $ name ) ; } return $ this ; }
11736	public function setAddress ( $ address ) { $ address = trim ( $ address , self :: SEPARATOR ) ; if ( ! filter_var ( $ address , FILTER_VALIDATE_URL ) ) { throw new \ InvalidArgumentException ( "$address is not valid format of url address." ) ; } $ this -> address = $ address ; $ this -> parse = parse_url ( $ address ) ; return $ this ; }
3793	private function hasVariants ( ) { $ metaModel = $ this -> factory -> getMetaModel ( $ this -> providerName ) ; if ( $ metaModel === null ) { throw new \ RuntimeException ( sprintf ( 'Could not find a MetaModels with the name %s' , $ this -> providerName ) ) ; } return $ metaModel -> hasVariants ( ) ; }
12484	protected function getDefaultOptionIds ( ) { $ optionIds = [ ] ; $ defaultDefinition = $ this -> getDefaultInputDefinition ( ) ; foreach ( $ defaultDefinition -> getOptions ( ) as $ option ) { $ optionIds [ ] = $ option -> getName ( ) ; } ; return $ optionIds ; }
6410	public static function concatIterables ( IteratorAggregate $ iterables ) : IteratorAggregate { return self :: from ( Iterators :: concatIterators ( FluentIterable :: from ( $ iterables ) -> transform ( function ( Traversable $ element ) { return Iterators :: from ( $ element ) ; } ) -> iterator ( ) ) ) ; }
771	public function actionConfig ( $ filePath ) { $ filePath = Yii :: getAlias ( $ filePath ) ; $ dir = dirname ( $ filePath ) ; if ( file_exists ( $ filePath ) ) { if ( ! $ this -> confirm ( "File '{$filePath}' already exists. Do you wish to overwrite it?" ) ) { return ExitCode :: OK ; } } $ array = VarDumper :: export ( $ this -> getOptionValues ( $ this -> action -> id ) ) ; $ content = <<<EOD<?php/** * Configuration file for 'yii {$this->id}/{$this->defaultAction}' command. * * This file is automatically generated by 'yii {$this->id}/{$this->action->id}' command. * It contains parameters for source code messages extraction. * You may modify this file to suit your needs. * * You can use 'yii {$this->id}/{$this->action->id}-template' command to create * template configuration file with detailed description for each parameter. */return $array;EOD ; if ( FileHelper :: createDirectory ( $ dir ) === false || file_put_contents ( $ filePath , $ content , LOCK_EX ) === false ) { $ this -> stdout ( "Configuration file was NOT created: '{$filePath}'.\n\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "Configuration file created: '{$filePath}'.\n\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; }
8921	protected function parseRelationship ( $ node ) { $ rel = array ( ) ; $ x = preg_replace ( '/\(.*?\)/' , '' , $ node -> text ( 'marc:subfield[@code="w"]' ) ) ; if ( ! empty ( $ x ) ) { $ rel [ 'id' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="t"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'title' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="g"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'parts' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="x"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'issn' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="z"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'isbn' ] = $ x ; } return $ rel ; }
12403	public function replace ( $ id , $ document = null ) { return Parser :: replace ( $ id , $ document , $ this -> connection ) ; }
11538	public function setItems ( $ items ) { $ this -> _items = $ items ; if ( isset ( $ this -> _items [ 0 ] ) && is_array ( $ this -> _items [ 0 ] ) ) { $ this -> _items = $ this -> _items [ 0 ] ; } foreach ( $ this -> _items as $ item ) { $ item -> owner = $ this ; if ( ! $ item -> isValid ) { $ this -> isValid = false ; } } }
10540	protected function typeModification ( $ type , array $ args ) { if ( is_int ( $ args [ 1 ] ) ) { $ type .= '(' . $ args [ 1 ] ; if ( isset ( $ args [ 2 ] ) ) { $ type .= ',' . $ args [ 2 ] ; } $ type .= ')' ; } elseif ( is_array ( $ args [ 1 ] ) ) { if ( isset ( $ args [ 1 ] [ 'size' ] ) ) { $ type .= '(' . $ args [ 1 ] [ 'size' ] . ')' ; } foreach ( $ args [ 1 ] as $ key => $ val ) { if ( 'size' === $ key ) { continue ; } $ type .= ' ' . strtoupper ( $ key ) ; } } else { $ type .= $ args [ 1 ] ; } return $ type ; }
5802	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ permissions = $ this -> permissionsEntityMapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) ) ; } catch ( QueryFailureException $ e ) { $ permissions = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ permissions ) ; }
6074	public function restoreMedia ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '/restore' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
5775	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ roles = $ this -> mapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) ) ; } catch ( QueryFailureException $ e ) { $ roles = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ roles ) ; }
5952	public function setTransition ( $ transition ) { if ( $ transition instanceof SlideTransition ) { $ this -> transition = $ transition ; } elseif ( is_array ( $ transition ) ) { $ this -> transition = new SlideTransition ( $ transition ) ; } else { $ this -> transition = null ; trigger_error ( 'Argument must be an object of class SlideTransition. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
7307	public static function create ( $ year = null , $ month = null , $ day = null , $ hour = null , $ min = null , $ sec = null , $ timezone = null , $ timescale = null ) { return new static ( $ year , $ month , $ day , $ hour , $ min , $ sec , $ timezone , $ timescale ) ; }
12508	public function msgType ( $ msgType ) { if ( ! in_array ( $ msgType , $ this -> msgTypes , true ) ) { throw new InvalidArgumentException ( 'This message type not exist.' ) ; } $ this -> msgType = $ msgType ; return $ this ; }
11214	public function count ( $ coraDbQuery = false ) { if ( ! $ coraDbQuery ) { $ coraDbQuery = $ this -> gateway -> getDb ( ) ; } $ coraDbQuery = $ this -> model :: model_constraints ( $ coraDbQuery ) ; return $ this -> gateway -> count ( $ coraDbQuery ) ; }
11690	protected function processAuth ( string $ actionName , array $ actionArgs ) : void { $ callAction = function ( string $ actionName , array $ actionArgs ) { if ( empty ( $ actionArgs ) ) { $ this -> ctrl -> { $ actionName } ( ) ; } else { ( new \ ReflectionMethod ( $ this -> ctrl , $ actionName ) ) -> invokeArgs ( $ this -> ctrl , $ actionArgs ) ; } } ; if ( class_exists ( '\extensions\core\Auth' ) ) { $ auth = new \ extensions \ core \ Auth ( $ this -> ctrl -> getRequest ( ) ) ; $ auth -> run ( ) ; if ( $ auth -> isValid ( ) ) { $ callAction ( $ actionName , $ actionArgs ) ; } else { $ auth -> onFail ( ) ; } } else { $ callAction ( $ actionName , $ actionArgs ) ; } }
5175	public function set ( string $ key , $ value ) : self { if ( ! isset ( $ this -> props [ $ key ] ) ) { throw new \ Exception ( 'Cannot add new property from set. Use add()' ) ; } $ this -> props [ $ key ] = $ value ; return $ this ; }
2245	public static function getPageStatusIcon ( $ objPage ) { $ sub = 0 ; $ image = $ objPage -> type . '.svg' ; if ( ! $ objPage -> published || ( $ objPage -> start != '' && $ objPage -> start > time ( ) ) || ( $ objPage -> stop != '' && $ objPage -> stop < time ( ) ) ) { ++ $ sub ; } if ( $ objPage -> hide && ! \ in_array ( $ objPage -> type , array ( 'root' , 'error_401' , 'error_403' , 'error_404' ) ) ) { $ sub += 2 ; } if ( $ objPage -> protected && ! \ in_array ( $ objPage -> type , array ( 'root' , 'error_401' , 'error_403' , 'error_404' ) ) ) { $ sub += 4 ; } if ( $ sub > 0 ) { $ image = $ objPage -> type . '_' . $ sub . '.svg' ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] as $ callback ) { $ image = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objPage , $ image ) ; } } return $ image ; }
2367	public static function encodeEmail ( $ strString ) { if ( strpos ( $ strString , '@' ) === false ) { return $ strString ; } $ arrEmails = static :: extractEmail ( $ strString , Config :: get ( 'allowedTags' ) ) ; foreach ( $ arrEmails as $ strEmail ) { $ strEncoded = '' ; $ arrCharacters = Utf8 :: str_split ( $ strEmail ) ; foreach ( $ arrCharacters as $ strCharacter ) { $ strEncoded .= sprintf ( ( random_int ( 0 , 1 ) ? '&#x%X;' : '&#%s;' ) , Utf8 :: ord ( $ strCharacter ) ) ; } $ strString = str_replace ( $ strEmail , $ strEncoded , $ strString ) ; } return str_replace ( 'mailto:' , '&#109;&#97;&#105;&#108;&#116;&#111;&#58;' , $ strString ) ; }
2043	public static function findByEmailAndPids ( $ strEmail , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.email=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) , $ strEmail , $ arrOptions ) ; }
10771	public function registerMediaType ( $ mediaType ) { if ( $ this -> check ( $ mediaType ) ) { $ this -> mediaTypes [ ( new \ ReflectionClass ( $ mediaType ) ) -> getConstant ( 'NAME' ) ] = $ mediaType ; return $ this ; } else { throw new \ Exception ( 'registered MediaType must implement \MandarinMedien\MMMediaBundle\Model\MediaTypeInterface' ) ; } }
4030	protected function getLabelPattern ( EnvironmentInterface $ environment , ModelInterface $ model ) { $ translator = $ environment -> getTranslator ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ combined = 'typedesc.' . $ type ; if ( ( $ resultPattern = $ translator -> translate ( $ combined , 'tl_metamodel_filtersetting' ) ) == $ combined ) { $ resultPattern = $ translator -> translate ( 'typedesc._default_' , 'tl_metamodel_filtersetting' ) ; } return $ resultPattern ; }
5484	public function hasSubmit ( SelectorInterface $ selector ) { foreach ( $ this -> buttons as $ button ) { if ( $ selector -> isMatch ( $ button ) ) { return true ; } } return false ; }
9701	public function addXfWriter ( Style $ style , $ isStyleXf = false ) { $ xfWriter = new Xf ( $ style ) ; $ xfWriter -> setIsStyleXf ( $ isStyleXf ) ; $ fontIndex = $ this -> addFont ( $ style -> getFont ( ) ) ; $ xfWriter -> setFontIndex ( $ fontIndex ) ; $ xfWriter -> setFgColor ( $ this -> addColor ( $ style -> getFill ( ) -> getStartColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setBgColor ( $ this -> addColor ( $ style -> getFill ( ) -> getEndColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setBottomColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getBottom ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setTopColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getTop ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setRightColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getRight ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setLeftColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getLeft ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setDiagColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getDiagonal ( ) -> getColor ( ) -> getRGB ( ) ) ) ; if ( $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) === false ) { $ numberFormatHashCode = $ style -> getNumberFormat ( ) -> getHashCode ( ) ; if ( isset ( $ this -> addedNumberFormats [ $ numberFormatHashCode ] ) ) { $ numberFormatIndex = $ this -> addedNumberFormats [ $ numberFormatHashCode ] ; } else { $ numberFormatIndex = 164 + count ( $ this -> numberFormats ) ; $ this -> numberFormats [ $ numberFormatIndex ] = $ style -> getNumberFormat ( ) ; $ this -> addedNumberFormats [ $ numberFormatHashCode ] = $ numberFormatIndex ; } } else { $ numberFormatIndex = ( int ) $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) ; } $ xfWriter -> setNumberFormatIndex ( $ numberFormatIndex ) ; $ this -> xfWriters [ ] = $ xfWriter ; $ xfIndex = count ( $ this -> xfWriters ) - 1 ; return $ xfIndex ; }
8262	protected function isValidCallback ( Request $ httpRequest ) { return $ this -> session -> has ( "provider" ) && $ httpRequest -> query -> has ( "state" ) && $ this -> session -> has ( "oauth2state" ) && is_string ( $ this -> session -> get ( "oauth2state" ) ) && ( strlen ( $ this -> session -> get ( "oauth2state" ) ) > 0 ) ; }
9770	function matchFormat ( string $ format ) : self { return $ this -> expect ( $ this -> target , matches ( $ format ) ) ; }
9832	public function setRevisionsPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> revisionsPassword = $ pValue ; return $ this ; }
10419	public static function parse ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new Exception ( 'The give file ' . $ path . ' doesn\'t exist.' ) ; } return Yaml :: parse ( file_get_contents ( $ path ) ) ; }
5808	public function onAfterDelete ( ) { parent :: onAfterDelete ( ) ; $ fusion = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ; $ types = unserialize ( $ fusion -> TagTypes ) ; unset ( $ types [ $ this -> owner -> ClassName ] ) ; $ fusion -> TagTypes = ! empty ( $ types ) ? serialize ( $ types ) : null ; $ fusion -> write ( ) ; }
3816	protected function render ( $ table , $ metaModel , Request $ request ) { $ fields = $ this -> generateForm ( $ table , $ metaModel , $ request ) ; return [ 'action' => '' , 'requestToken' => REQUEST_TOKEN , 'href' => $ this -> getReferer ( $ request , $ table , true ) , 'backBt' => $ this -> translator -> trans ( 'MSC.backBT' , [ ] , 'contao_default' ) , 'add' => $ this -> translator -> trans ( 'MSC.continue' , [ ] , 'contao_default' ) , 'saveNclose' => $ this -> translator -> trans ( 'MSC.saveNclose' , [ ] , 'contao_default' ) , 'activate' => $ this -> translator -> trans ( $ table . '.addAll_activate' , [ ] , 'contao_' . $ table ) , 'headline' => $ this -> translator -> trans ( $ table . '.addall.1' , [ ] , 'contao_' . $ table ) , 'selectAll' => $ this -> translator -> trans ( 'MSC.selectAll' , [ ] , 'contao_default' ) , 'cacheMessage' => '' , 'updateMessage' => '' , 'hasCheckbox' => count ( $ fields ) > 0 , 'fields' => $ fields , ] ; }
5741	protected static function prefixData ( $ data ) { $ prefixedData = array ( ) ; foreach ( $ data as $ stat => $ value ) { $ prefixedKey = self :: prefix ( $ stat ) ; $ prefixedData [ $ prefixedKey ] = $ value ; } return $ prefixedData ; }
800	private function findStart ( Tokens $ tokens , $ index ) { while ( ! $ tokens [ $ index ] -> equalsAny ( [ '$' , [ T_VARIABLE ] ] ) ) { if ( $ tokens [ $ index ] -> equals ( ']' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_INDEX_SQUARE_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_PROP_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_PROP_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_VAR_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_VAR_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_ARRAY_INDEX_CURLY_BRACE , $ index ) ; } else { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } } while ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> equals ( '$' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } if ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_OBJECT_OPERATOR ) ) { return $ this -> findStart ( $ tokens , $ tokens -> getPrevMeaningfulToken ( $ index ) ) ; } return $ index ; }
3843	private function parsePanelSearch ( PanelRowInterface $ row ) { if ( $ row -> hasElement ( 'search' ) ) { $ element = $ row -> getElement ( 'search' ) ; } else { $ element = new DefaultSearchElementInformation ( ) ; } if ( ! $ element instanceof SearchElementInformationInterface ) { throw new \ InvalidArgumentException ( 'Search element does not implement the correct interface.' ) ; } foreach ( $ this -> inputScreen [ 'properties' ] as $ value ) { if ( ! empty ( $ value [ 'search' ] ) ) { $ element -> addProperty ( $ value [ 'col_name' ] ) ; } } if ( $ element -> getPropertyNames ( ) && ! $ row -> hasElement ( 'search' ) ) { $ row -> addElement ( $ element ) ; } }
3630	protected function validateItems ( array $ items , $ type ) { foreach ( $ items as $ item ) { $ this -> validateItem ( $ item , $ type ) ; } }
10624	private static function checkAndMoveFile ( $ sourceMigrationFile , $ appMigrationDir , IOInterface $ io ) { $ explodedPath = explode ( '/' , $ sourceMigrationFile ) ; $ filename = array_pop ( $ explodedPath ) ; if ( file_exists ( $ appMigrationDir . '/' . $ filename ) ) { if ( md5_file ( $ appMigrationDir . '/' . $ filename ) === md5_file ( $ sourceMigrationFile ) ) { if ( $ io -> isVeryVerbose ( ) ) { $ io -> write ( "<info>found that $sourceMigrationFile is equal" . " to $appMigrationDir/$filename</info>" ) ; } $ doTheMove = false ; } else { $ doTheMove = $ io -> askConfirmation ( "<question>The file \n" . " \t$sourceMigrationFile\n has the same name than the previous " . "migrated file located at \n\t$appMigrationDir/$filename\n " . "but the content is not equal.\n Overwrite the file ?[y,N]" , false ) ; } } else { $ doTheMove = true ; } if ( $ doTheMove ) { $ fs = new Filesystem ( ) ; $ fs -> copy ( $ sourceMigrationFile , $ appMigrationDir . '/' . $ filename ) ; $ io -> write ( "<info>Importing '$filename' migration file</info>" ) ; return true ; } return false ; }
9901	public function parse ( $ formula ) { $ this -> currentCharacter = 0 ; $ this -> formula = $ formula ; $ this -> lookAhead = isset ( $ formula [ 1 ] ) ? $ formula [ 1 ] : '' ; $ this -> advance ( ) ; $ this -> parseTree = $ this -> condition ( ) ; return true ; }
3285	public function getSourceContext ( $ name ) : Source { if ( ! $ this -> exists ( $ name ) ) { throw new LoaderError ( sprintf ( 'Unable to find template "%s" from template map' , $ name ) ) ; } if ( ! file_exists ( $ this -> map [ $ name ] ) ) { throw new LoaderError ( sprintf ( 'Unable to open file "%s" from template map' , $ this -> map [ $ name ] ) ) ; } $ content = file_get_contents ( $ this -> map [ $ name ] ) ; $ source = new Source ( $ content , $ name , $ this -> map [ $ name ] ) ; return $ source ; }
1831	public function detach ( $ blnKeepClone = true ) { $ registry = Registry :: getInstance ( ) ; if ( ! $ registry -> isRegistered ( $ this ) ) { return ; } $ registry -> unregister ( $ this ) ; if ( $ blnKeepClone ) { $ this -> cloneOriginal ( ) -> attach ( ) ; } }
3547	public function boot ( ) { $ this -> loadViewsFrom ( realpath ( __DIR__ . '/../views' ) , 'entrust-gui' ) ; $ this -> setupRoutes ( $ this -> app -> router ) ; $ this -> loadTranslationsFrom ( realpath ( __DIR__ . '/../translations' ) , 'entrust-gui' ) ; $ this -> publishes ( [ __DIR__ . '/../config/entrust-gui.php' => config_path ( 'entrust-gui.php' ) ] , 'config' ) ; $ this -> publishes ( [ __DIR__ . '/../views' => base_path ( 'resources/views/vendor/entrust-gui' ) ] , 'views' ) ; $ this -> publishes ( [ __DIR__ . '/../translations' => base_path ( 'resources/lang/vendor/entrust-gui' ) ] , 'translations' ) ; $ this -> commands ( 'command.entrust-gui.models' ) ; }
1903	public function limit ( $ intRows , $ intOffset = 0 ) { if ( $ intRows <= 0 ) { $ intRows = 30 ; } if ( $ intOffset < 0 ) { $ intOffset = 0 ; } if ( strncasecmp ( $ this -> strQuery , 'SELECT' , 6 ) === 0 ) { $ this -> strQuery .= ' LIMIT ' . $ intOffset . ',' . $ intRows ; } else { $ this -> strQuery .= ' LIMIT ' . $ intRows ; } return $ this ; }
6703	public function get ( OAuthConsumerInterface $ consumer , OAuthTokenInterface $ token , $ httpverb , $ url , $ params = [ ] ) { uksort ( $ params , 'strcmp' ) ; $ base_url = $ this -> baseURL ( $ httpverb , $ url , $ params ) ; $ key = $ consumer -> secret . '&' . $ token -> secret ; return base64_encode ( hash_hmac ( 'sha1' , $ base_url , $ key , true ) ) ; }
1547	public function registerCustom ( ) : void { if ( ! $ fn = $ this -> group ) { return ; } $ this -> router -> group ( [ ] , function ( ) use ( $ fn ) { $ fn ( new RouteRegistrar ( $ this -> router , [ 'controller' => $ this -> controller ( ) ] , [ self :: PARAM_RESOURCE_TYPE => $ this -> resourceType ] ) ) ; } ) ; }
5849	protected function moduleContent ( array $ row ) { $ this -> formResultCompiler = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormResultCompiler :: class ) ; $ wizard = $ this -> formResultCompiler -> addCssFiles ( ) ; $ wizard .= $ this -> buildForm ( $ row ) ; $ wizard .= $ this -> formResultCompiler -> printNeededJSFunctions ( ) ; $ this -> content .= $ wizard ; }
12854	public function process ( Pipeline \ Pipeline $ pipeline , $ payload ) { $ runner = clone ( $ this ) ; $ runner -> stages = $ pipeline -> getIterator ( ) ; return $ runner -> handle ( $ payload ) ; }
8183	public function getMemoryUsage ( ) { return isset ( $ this -> ends [ 'mu' ] ) && isset ( $ this -> starts [ 'mu' ] ) ? $ this -> ends [ 'mu' ] - $ this -> starts [ 'mu' ] : 0 ; }
2166	public static function convertOrderField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field LIKE '%,%'" ) ; while ( $ objRow -> next ( ) ) { $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( serialize ( explode ( ',' , $ objRow -> $ field ) ) , $ objRow -> id ) ; } static :: convertMultiField ( $ table , $ field ) ; }
3942	private static function buildLanguageArray ( IMetaModel $ metaModel , TranslatorInterface $ translator ) { $ languages = array ( ) ; foreach ( ( array ) $ metaModel -> getAvailableLanguages ( ) as $ langCode ) { $ languages [ $ langCode ] = $ translator -> translate ( 'LNG.' . $ langCode , 'languages' ) ; } asort ( $ languages ) ; return $ languages ; }
10858	public function eachMarked ( callable $ callback , $ result = null ) { $ ref = new \ ReflectionFunction ( $ callback ) ; $ params = $ ref -> getParameters ( ) ; if ( \ count ( $ params ) < 2 ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Callback for marker processing must declare at least 2 arguments (object and marker)' ) ) ; } try { $ markerType = $ params [ 1 ] -> getClass ( ) ; } catch ( \ ReflectionException $ e ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker class not found: %s' , $ params [ 1 ] -> getType ( ) ) , 0 , $ e ) ; } if ( $ markerType === null ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Argument #2 of marker callback needs to declare a type-hint for the marker' ) ) ; } $ marker = $ markerType -> getName ( ) ; if ( ! $ markerType -> isSubclassOf ( Marker :: class ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker implementation %s must extend %s' , $ marker , Marker :: class ) ) ; } if ( ! isset ( $ this -> marked [ $ marker ] ) ) { $ this -> cacheMarkers ( $ marker ) ; } foreach ( $ this -> marked [ $ marker ] as list ( $ definition , $ registration ) ) { $ result = $ callback ( $ this -> shared [ $ definition -> typeName ] ?? $ this -> get ( $ definition -> typeName ) , clone $ registration , $ result ) ; } return $ result ; }
7376	public function fetch ( string $ key , $ default = null ) { $ val = $ this -> bag [ $ key ] ?? $ default ; if ( ! is_array ( $ val ) ) { return trim ( $ val ) ; } else { return $ val ; } }
2757	public function permissions ( ) { $ permissions = [ ] ; foreach ( $ this -> entityTypeManager -> getStorage ( 'taxonomy_vocabulary' ) -> loadMultiple ( ) as $ vocabulary ) { $ permissions += [ 'view published terms in ' . $ vocabulary -> id ( ) => [ 'title' => $ this -> t ( 'View published terms in %vocabulary' , [ '%vocabulary' => $ vocabulary -> label ( ) ] ) , ] , 'view unpublished terms in ' . $ vocabulary -> id ( ) => [ 'title' => $ this -> t ( 'View unpublished terms in %vocabulary' , [ '%vocabulary' => $ vocabulary -> label ( ) ] ) , ] , ] ; } return $ permissions ; }
12954	public static function priceStringToInt ( string $ str , string $ propertyPath = '' ) : int { $ str = trim ( $ str ) ; if ( ! preg_match ( '/(\.|,)[0-9]{2}$/' , $ str ) ) { throw new \ InvalidArgumentException ( ( $ propertyPath ? $ propertyPath . ' (value: "' . $ str . '")' : $ str ) . ' does not match the currency string format' ) ; } $ str = preg_replace ( '/[^0-9]+/' , '' , $ str ) ; return intval ( $ str ) ; }
4330	public static function serializeLog ( $ data ) { $ str = \ serialize ( $ data ) ; if ( \ function_exists ( 'gzdeflate' ) ) { $ str = \ gzdeflate ( $ str ) ; } $ str = \ chunk_split ( \ base64_encode ( $ str ) , 124 ) ; return "START DEBUG\n" . $ str . 'END DEBUG' ; }
7663	function AddAttachment ( $ path , $ name = "" , $ encoding = "base64" , $ type = "application/octet-stream" ) { if ( ! @ is_file ( $ path ) ) { $ this -> SetError ( $ this -> Lang ( "file_access" ) . $ path ) ; return false ; } $ filename = basename ( $ path ) ; if ( $ name == "" ) $ name = $ filename ; $ cur = count ( $ this -> attachment ) ; $ this -> attachment [ $ cur ] [ 0 ] = $ path ; $ this -> attachment [ $ cur ] [ 1 ] = $ filename ; $ this -> attachment [ $ cur ] [ 2 ] = $ name ; $ this -> attachment [ $ cur ] [ 3 ] = $ encoding ; $ this -> attachment [ $ cur ] [ 4 ] = $ type ; $ this -> attachment [ $ cur ] [ 5 ] = false ; $ this -> attachment [ $ cur ] [ 6 ] = "attachment" ; $ this -> attachment [ $ cur ] [ 7 ] = 0 ; return true ; }
8985	public function isComparable ( TableNode $ expected , TableNode $ actual , array $ diff_options , $ message = NULL ) { $ this -> doAssert ( 'Failed comparing two tables: ' , $ diff_options , $ expected , $ actual , $ message ) ; }
6031	public function addself ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate self. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "self"!' , E_USER_WARNING ) ; } } $ this -> childMedias [ ] = $ item ; return $ this ; }
9330	static function filter ( $ width , $ height ) { return array ( new ezcImageFilter ( 'scale' , array ( 'width' => intval ( $ width ) , 'height' => intval ( $ height ) , 'direction' => ezcImageGeometryFilters :: SCALE_BOTH ) ) ) ; }
7606	public function render ( array $ aDropdownOptions ) { if ( empty ( $ aDropdownOptions [ 'attributes' ] ) ) { $ aDropdownOptions [ 'attributes' ] = array ( 'class' => 'dropdown' ) ; } else { if ( ! is_array ( $ aDropdownOptions [ 'attributes' ] ) ) { throw new LogicException ( '"attributes" option expects an array, "' . gettype ( $ aDropdownOptions [ 'attributes' ] ) . '" given' ) ; } if ( empty ( $ aDropdownOptions [ 'attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'attributes' ] [ 'class' ] = 'dropdown' ; } elseif ( ! preg_match ( '/(\s|^)dropdown(\s|$)/' , $ aDropdownOptions [ 'attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'attributes' ] [ 'class' ] .= ' dropdown' ; } } return sprintf ( static :: $ dropdownContainerFormat , $ this -> createAttributesString ( $ aDropdownOptions [ 'attributes' ] ) , $ this -> renderToggle ( $ aDropdownOptions ) . $ this -> renderListItems ( $ aDropdownOptions ) ) ; }
6875	public static function query ( $ queryString , array $ queryParams = [ ] , $ dbName = "master" , $ fetchResults = true ) { $ query = static :: instance ( $ dbName ) -> prepare ( $ queryString ) ; foreach ( $ queryParams as $ column => $ val ) $ query -> bindValue ( is_int ( $ column ) ? $ column + 1 : ":" . $ column , $ val ) ; if ( $ query -> execute ( ) ) return $ fetchResults ? $ query -> fetchAll ( PDO :: FETCH_ASSOC ) : $ query -> rowCount ( ) ; return false ; }
12429	public function getAuthorizerList ( $ offset = 0 , $ count = 500 ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'offset' => $ offset , 'count' => $ count , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_LIST , $ params ] ) ; }
7505	public function assignNamespace ( string $ namespace , $ prepend = false ) { if ( $ prepend ) { array_unshift ( $ this -> namespaces , $ namespace ) ; return ; } array_push ( $ this -> namespaces , $ namespace ) ; }
12795	public function images ( $ params ) { try { $ response = $ this -> client -> request -> get ( $ this -> apiEndpoint . '/images' . $ this -> paramsToString ( $ params ) ) ; $ status = $ this -> client -> getStatus ( $ response ) ; if ( 200 != $ status ) { throw new Exception ( 'Digital Ocean was not able to successfully provide a list of snapshots.' ) ; } return $ this -> client -> getBody ( $ response ) ; } catch ( Exception $ e ) { echo 'Unable to list snapshots because ' . $ e -> getMessage ( ) ; } }
763	private function updateCollectionOffsets ( ) { if ( ! empty ( $ this -> _children ) ) { $ this -> startOffset = reset ( $ this -> _children ) -> startOffset ; $ this -> endOffset = end ( $ this -> _children ) -> endOffset ; } if ( $ this -> parent !== null ) { $ this -> parent -> updateCollectionOffsets ( ) ; } }
1244	public static function memoize ( callable $ provider ) { return function ( ) use ( $ provider ) { static $ result ; static $ isConstant ; if ( $ isConstant ) { return $ result ; } $ isConstant = true ; return $ result = $ provider ( ) ; } ; }
868	private function isInConditionWithoutBraces ( Tokens $ tokens , $ index , $ lowerLimitIndex ) { do { if ( $ tokens [ $ index ] -> isComment ( ) || $ tokens [ $ index ] -> isWhitespace ( ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_IF , T_ELSEIF , T_ELSE ] ) ) { return true ; } if ( $ token -> equals ( ';' , '}' ) ) { return false ; } if ( $ token -> equals ( '{' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ index ] -> isGivenKind ( T_DO ) ) { -- $ index ; continue ; } if ( ! $ tokens [ $ index ] -> equals ( ')' ) ) { return false ; } $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ index ] -> isGivenKind ( [ T_IF , T_ELSEIF ] ) ) { return false ; } } elseif ( $ token -> equals ( ')' ) ) { $ type = Tokens :: detectBlockType ( $ token ) ; $ index = $ tokens -> findBlockStart ( $ type [ 'type' ] , $ index ) ; $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } else { -- $ index ; } } while ( $ index > $ lowerLimitIndex ) ; return false ; }
2996	public function set ( $ key , $ val ) { $ this -> smtp -> set ( $ key , $ this -> encode ( $ val ) ) ; }
4386	protected function dumpMethods ( $ methods ) { $ str = '' ; if ( ! empty ( $ methods ) ) { $ counts = array ( 'public' => 0 , 'protected' => 0 , 'private' => 0 , 'magic' => 0 , ) ; foreach ( $ methods as $ info ) { $ counts [ $ info [ 'visibility' ] ] ++ ; } $ str .= ' Methods:' . "\n" ; foreach ( $ counts as $ vis => $ count ) { if ( $ count ) { $ str .= ' ' . $ vis . ': ' . $ count . "\n" ; } } } else { $ str .= ' Methods: none!' . "\n" ; } return $ str ; }
8251	protected function isValidUsername ( $ name ) { if ( ! is_string ( $ name ) || ! $ this -> storage -> checkValidName ( $ name ) || strlen ( $ name ) < $ this -> config [ "registration" ] [ "nameLenMin" ] || strlen ( $ name ) > $ this -> config [ "registration" ] [ "nameLenMax" ] ) { return false ; } return true ; }
2729	public function beforeToHtml ( Image $ subject ) { if ( $ this -> config -> isImageOptimizationPixelRatioEnabled ( ) !== true ) { return ; } $ srcSet = [ ] ; $ imageUrl = $ subject -> getData ( 'image_url' ) ; $ pixelRatios = $ this -> config -> getImageOptimizationRatios ( ) ; $ pixelRatiosArray = explode ( ',' , $ pixelRatios ) ; $ glue = ( strpos ( $ imageUrl , '?' ) !== false ) ? '&' : '?' ; foreach ( $ pixelRatiosArray as $ pr ) { $ ratio = 'dpr=' . $ pr . ' ' . $ pr . 'x' ; $ srcSet [ ] = $ imageUrl . $ glue . $ ratio ; } $ subject -> setData ( 'custom_attributes' , 'srcset="' . implode ( ',' , $ srcSet ) . '"' ) ; }
11420	protected function getCache ( $ pk ) { $ app = App :: getInstance ( ) ; return $ app [ 'cache' ] -> getItem ( $ this -> dbtable . '/' . $ pk -> getValue ( ) ) ; }
7135	public function getPercent ( ) : float { $ amount = $ this -> getAmount ( ) ; if ( 0 < $ this -> sellingPrice ) { return round ( $ amount * 100 / $ this -> sellingPrice , 2 ) ; } return 0 ; }
6965	public function isIdentityEmpty ( ) { return empty ( $ this -> gender ) && empty ( $ this -> firstName ) && empty ( $ this -> lastName ) ; }
8989	public function getTemplate ( $ data_type , $ type ) { $ options = ( array ) $ this -> config -> getType ( $ data_type , $ type ) ; return new UI \ Template ( $ data_type , $ type , $ options ) ; }
3137	public function parsesItemResponse ( RunnerServiceContext $ context , $ itemRef , $ response ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ currentItem = $ context -> getCurrentAssessmentItemRef ( ) ; $ responses = new State ( ) ; if ( $ currentItem === false ) { $ msg = "Trying to store item variables but the state of the test session is INITIAL or CLOSED.\n" ; $ msg .= "Session state value: " . $ session -> getState ( ) . "\n" ; $ msg .= "Session ID: " . $ session -> getSessionId ( ) . "\n" ; $ msg .= "JSON Payload: " . mb_substr ( json_encode ( $ response ) , 0 , 1000 ) ; \ common_Logger :: e ( $ msg ) ; } $ filler = new \ taoQtiCommon_helpers_PciVariableFiller ( $ currentItem , $ this -> getServiceManager ( ) -> get ( QtiFlysystemFileManager :: SERVICE_ID ) ) ; if ( is_array ( $ response ) ) { foreach ( $ response as $ id => $ responseData ) { try { $ var = $ filler -> fill ( $ id , $ responseData ) ; if ( \ taoQtiCommon_helpers_Utils :: isQtiFilePlaceHolder ( $ var ) === false ) { $ responses -> setVariable ( $ var ) ; } } catch ( \ OutOfRangeException $ e ) { \ common_Logger :: d ( "Could not convert client-side value for variable '${id}'." ) ; } catch ( \ OutOfBoundsException $ e ) { \ common_Logger :: d ( "Could not find variable with identifier '${id}' in current item." ) ; } } } else { \ common_Logger :: e ( 'Invalid json payload' ) ; } return $ responses ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
2650	public function validateServiceVersion ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/validate' ; $ result = $ this -> _fetch ( $ url , 'GET' ) ; if ( $ result -> status == 'error' ) { throw new LocalizedException ( __ ( 'Failed to validate service version: ' . $ result -> msg ) ) ; } }
11582	private function getPublicRequireDefinition ( ContainerBuilder $ container , $ id , $ type ) { $ serviceDefinition = $ container -> getDefinition ( $ id ) ; if ( ! $ serviceDefinition -> isPublic ( ) ) { throw new InvalidArgumentException ( sprintf ( 'The service "%s" must be public as block %s are lazy-loaded.' , $ id , $ type ) ) ; } return $ serviceDefinition ; }
5736	private function getShowParameters ( Request $ request ) { $ showingAll = FALSE ; $ start = - 100 ; $ count = - 1 ; if ( $ request -> query -> has ( 'all' ) ) { $ start = 0 ; $ count = - 1 ; $ showingAll = TRUE ; } return [ $ start , $ count , $ showingAll ] ; }
121	private function createAuthFromConfig ( ) { if ( ! $ this -> config -> has ( 'http-basic' ) ) { return $ this -> hasAuth = false ; } $ authConfig = $ this -> config -> get ( 'http-basic' ) ; $ host = parse_url ( $ this -> url , PHP_URL_HOST ) ; if ( isset ( $ authConfig [ $ host ] ) ) { $ this -> credentials [ 'username' ] = $ authConfig [ $ host ] [ 'username' ] ; $ this -> credentials [ 'password' ] = $ authConfig [ $ host ] [ 'password' ] ; return $ this -> hasAuth = true ; } return $ this -> hasAuth = false ; }
5378	public function wrapIsEnabled ( ) { if ( $ this -> getAttribute ( 'cols' ) ) { $ wrap = $ this -> getAttribute ( 'wrap' ) ; if ( ( $ wrap === 'physical' ) || ( $ wrap === 'hard' ) ) { return true ; } } return false ; }
11601	private static function getBaseUrl ( ) : ? string { $ serverName = filter_input ( \ INPUT_SERVER , 'SERVER_NAME' , \ FILTER_SANITIZE_STRING ) ; if ( ! empty ( $ serverName ) ) { $ https = filter_input ( \ INPUT_SERVER , 'HTTPS' , \ FILTER_SANITIZE_STRING ) ; $ protocol = ! empty ( $ https ) && strtolower ( $ https ) === 'on' ? 'https' : 'http' ; return $ protocol . '://' . $ serverName ; } return null ; }
4823	public function removeField ( $ fieldName ) { if ( array_key_exists ( $ fieldName , $ this -> row ) ) { unset ( $ this -> row [ $ fieldName ] ) ; $ this -> informChanges ( ) ; } }
3190	public function getLastRegisteredTimestamp ( ) { $ points = $ this -> timeLine -> getPoints ( ) ; $ length = count ( $ points ) ; $ last = false ; if ( $ length ) { $ last = end ( $ points ) -> getTimestamp ( ) ; } return $ last ; }
7770	public function errors ( ) { $ messages = [ ] ; foreach ( $ this -> errors as $ rule => $ items ) { foreach ( $ items as $ item ) { $ field = $ item [ 'field' ] ; $ message = $ this -> fetchMessage ( $ field , $ rule ) ; if ( isset ( $ this -> fieldAliases [ $ field ] ) ) { $ item [ 'field' ] = $ this -> fieldAliases [ $ field ] ; } $ messages [ $ field ] [ ] = $ this -> replaceMessageFormat ( $ message , $ item ) ; } } return new MessageBag ( $ messages ) ; }
142	public function getInstallPath ( PackageInterface $ package ) { $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; return $ installer -> getInstallPath ( $ package ) ; }
12560	public function fixFileSlashes ( $ file , & $ contents ) { $ changed = false ; foreach ( $ contents as $ lineNumber => $ line ) { if ( preg_match ( '/(psesd|canis|cascade)\\\\\\\/' , $ line ) === 1 ) { $ fixedLine = preg_replace ( '/\\\\\\\/' , '\\' , $ line ) ; if ( $ fixedLine !== $ line ) { $ contents [ $ lineNumber ] = $ fixedLine ; $ changed = true ; } } } return $ changed ; }
7657	function Send ( ) { $ header = "" ; $ body = "" ; $ result = true ; if ( ( count ( $ this -> to ) + count ( $ this -> cc ) + count ( $ this -> bcc ) ) < 1 ) { $ this -> SetError ( $ this -> Lang ( "provide_address" ) ) ; return false ; } if ( ! empty ( $ this -> AltBody ) ) $ this -> ContentType = "multipart/alternative" ; $ this -> error_count = 0 ; $ this -> SetMessageType ( ) ; $ header .= $ this -> CreateHeader ( ) ; $ body = $ this -> CreateBody ( ) ; if ( $ body == "" ) { return false ; } switch ( $ this -> Mailer ) { case "sendmail" : $ result = $ this -> SendmailSend ( $ header , $ body ) ; break ; case "mail" : $ result = $ this -> MailSend ( $ header , $ body ) ; break ; case "smtp" : $ result = $ this -> SmtpSend ( $ header , $ body ) ; break ; default : $ this -> SetError ( $ this -> Mailer . $ this -> Lang ( "mailer_not_supported" ) ) ; $ result = false ; break ; } return $ result ; }
2130	protected function markModified ( ) { if ( $ this -> blnIsModified === true ) { return ; } $ this -> blnIsModified = true ; $ this -> strTop = '' ; $ this -> strBottom = '' ; $ this -> Files = Files :: getInstance ( ) ; if ( static :: $ blnHasLcf ) { $ strMode = 'top' ; $ resFile = fopen ( $ this -> strRootDir . '/system/config/localconfig.php' , 'rb' ) ; while ( ! feof ( $ resFile ) ) { $ strLine = fgets ( $ resFile ) ; $ strTrim = trim ( $ strLine ) ; if ( $ strTrim == '?>' ) { continue ; } if ( $ strTrim == '### INSTALL SCRIPT START ###' ) { $ strMode = 'data' ; continue ; } if ( $ strTrim == '### INSTALL SCRIPT STOP ###' ) { $ strMode = 'bottom' ; continue ; } if ( $ strMode == 'top' ) { $ this -> strTop .= $ strLine ; } elseif ( $ strMode == 'bottom' ) { $ this -> strBottom .= $ strLine ; } elseif ( $ strTrim != '' ) { $ arrChunks = array_map ( 'trim' , explode ( '=' , $ strLine , 2 ) ) ; $ this -> arrData [ $ arrChunks [ 0 ] ] = $ arrChunks [ 1 ] ; } } fclose ( $ resFile ) ; } }
260	public function renderFile ( $ viewFile , $ params = [ ] , $ context = null ) { $ viewFile = $ requestedFile = Yii :: getAlias ( $ viewFile ) ; if ( $ this -> theme !== null ) { $ viewFile = $ this -> theme -> applyTo ( $ viewFile ) ; } if ( is_file ( $ viewFile ) ) { $ viewFile = FileHelper :: localize ( $ viewFile ) ; } else { throw new ViewNotFoundException ( "The view file does not exist: $viewFile" ) ; } $ oldContext = $ this -> context ; if ( $ context !== null ) { $ this -> context = $ context ; } $ output = '' ; $ this -> _viewFiles [ ] = [ 'resolved' => $ viewFile , 'requested' => $ requestedFile ] ; if ( $ this -> beforeRender ( $ viewFile , $ params ) ) { Yii :: debug ( "Rendering view file: $viewFile" , __METHOD__ ) ; $ ext = pathinfo ( $ viewFile , PATHINFO_EXTENSION ) ; if ( isset ( $ this -> renderers [ $ ext ] ) ) { if ( is_array ( $ this -> renderers [ $ ext ] ) || is_string ( $ this -> renderers [ $ ext ] ) ) { $ this -> renderers [ $ ext ] = Yii :: createObject ( $ this -> renderers [ $ ext ] ) ; } $ renderer = $ this -> renderers [ $ ext ] ; $ output = $ renderer -> render ( $ this , $ viewFile , $ params ) ; } else { $ output = $ this -> renderPhpFile ( $ viewFile , $ params ) ; } $ this -> afterRender ( $ viewFile , $ params , $ output ) ; } array_pop ( $ this -> _viewFiles ) ; $ this -> context = $ oldContext ; return $ output ; }
10596	protected function initViewPanelTableRow ( \ MvcCore \ IRoute & $ route , $ matched ) { $ route -> InitAll ( ) ; $ row = new \ stdClass ; $ row -> matched = $ matched ; $ row -> method = $ route -> GetMethod ( ) ; $ row -> method = $ row -> method === NULL ? '*' : $ row -> method ; $ row -> className = htmlSpecialChars ( '\\' . get_class ( $ route ) , ENT_QUOTES , 'UTF-8' ) ; $ routeMatch = $ this -> getRouteLocalizedRecord ( $ route , 'GetMatch' ) ; $ routeMatch = rtrim ( $ routeMatch , 'imsxeADSUXJu' ) ; $ routeReverse = $ this -> getRouteLocalizedRecord ( $ route , 'GetReverse' ) ; $ routeDefaults = $ this -> getRouteLocalizedRecord ( $ route , 'GetDefaults' ) ; $ row -> match = $ this -> completeFormatedPatternCharGroups ( $ routeMatch , [ '(' , ')' ] ) ; if ( $ routeReverse !== NULL ) { $ row -> reverse = $ this -> completeFormatedPatternCharGroups ( $ routeReverse , [ '<' , '>' ] ) ; } else { $ row -> reverse = NULL ; } $ row -> routeName = $ route -> GetName ( ) ; $ row -> ctrlActionName = $ route -> GetControllerAction ( ) ; if ( $ row -> ctrlActionName !== ':' ) { $ row -> ctrlActionLink = $ this -> completeCtrlActionLink ( $ route -> GetController ( ) , $ route -> GetAction ( ) ) ; } else { $ row -> ctrlActionName = NULL ; $ row -> ctrlActionLink = NULL ; } $ routeReverseParams = $ route -> GetReverseParams ( ) ? : [ ] ; $ paramsKeys = array_unique ( array_merge ( $ routeReverseParams , array_keys ( $ routeDefaults ) ) ) ; $ row -> defaults = $ this -> completeParams ( $ route , $ paramsKeys , TRUE ) ; $ row -> params = [ ] ; if ( $ matched ) { $ paramsAndReqestParams = array_merge ( $ routeDefaults , $ this -> requestParams ) ; $ row -> params = $ this -> completeParams ( $ route , array_keys ( $ paramsAndReqestParams ) , FALSE ) ; } return $ row ; }
5045	public function paginator ( $ paginatorName , $ defaultParams = [ ] , $ as = 'paginator' ) { if ( is_string ( $ defaultParams ) ) { $ as = $ defaultParams ; $ defaultParams = [ ] ; } $ this -> stack [ 'paginator' ] = [ 'as' => $ as , $ paginatorName , $ defaultParams ] ; return $ this ; }
11629	private function createOperation ( $ trans , $ dsBegin ) { $ datePerformed = $ this -> hlpDate -> getUtcNowForDb ( ) ; $ req = new \ Praxigento \ Accounting \ Api \ Service \ Operation \ Create \ Request ( ) ; $ req -> setOperationTypeCode ( Cfg :: CODE_TYPE_OPER_PV_WRITE_OFF ) ; $ req -> setDatePerformed ( $ datePerformed ) ; $ req -> setTransactions ( $ trans ) ; $ period = substr ( $ dsBegin , 0 , 6 ) ; $ note = "PV Write Off ($period)" ; $ req -> setOperationNote ( $ note ) ; $ resp = $ this -> servOperation -> exec ( $ req ) ; $ result = $ resp -> getOperationId ( ) ; return $ result ; }
6478	protected function encodingIsSupported ( string $ encoding ) : bool { $ lowercaseSupportedEncodings = array_map ( 'strtolower' , $ this -> getSupportedEncodings ( ) ) ; $ lowercaseEncoding = strtolower ( $ encoding ) ; return in_array ( $ lowercaseEncoding , $ lowercaseSupportedEncodings , true ) ; }
11626	private function isrunning ( ) { $ pids = explode ( PHP_EOL , `ps -e | awk '{print $1}'` ) ; if ( in_array ( $ this -> pid , $ pids ) ) return true ; return false ; }
468	public function buildSimpleCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
9793	public function hasDataValidation ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot check for data validation when cell is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> dataValidationExists ( $ this -> getCoordinate ( ) ) ; }
11323	protected function getAnnotationMethodForMethod ( ClassInterface $ class , $ requestMethod ) { foreach ( $ class -> getMethods ( ) as $ method ) { if ( $ method -> getAnnotatedName ( ) === $ requestMethod ) { return $ method ; } } throw new ExtDirectException ( "extjs method name '{$requestMethod}' does not exist'" ) ; }
2662	public function getBackends ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/backend' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
5530	protected function chainMockExpectations ( ) { $ code = " function expect(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expect(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectAt(\$timing, \$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectAt(\$timing, \$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectCallCount(\$method, \$count) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectMaximumCallCount(\$method, \$count, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectMaximumCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectMinimumCallCount(\$method, \$count, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectMinimumCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectNever(\$method) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectNever(\$method);\n" ; $ code .= " }\n" ; $ code .= " function expectOnce(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectOnce(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectAtLeastOnce(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectAtLeastOnce(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; return $ code ; }
10582	protected function buildResponse ( APIResponse $ APIResponse , ResponseInterface $ response ) : ResponseInterface { $ response = $ response -> withStatus ( 200 , "200 OK" ) ; $ response = $ response -> withAddedHeader ( "Content-Type" , $ APIResponse -> getMIMEType ( ) ) ; $ response = $ response -> withAddedHeader ( "Content-Length" , $ APIResponse -> getAsDataStream ( ) -> getSize ( ) ) ; $ this -> logger -> debug ( "Responding to request successfully" ) ; return $ response -> withBody ( $ APIResponse -> getAsDataStream ( ) ) ; }
9505	public function index ( ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DASHBOARD ) ; $ stats = $ this -> logViewer -> statsTable ( ) ; $ percents = $ this -> calcPercentages ( $ stats -> footer ( ) , $ stats -> header ( ) ) ; $ this -> setTitle ( 'LogViewer Dashboard' ) ; $ this -> addBreadcrumb ( 'Dashboard' ) ; return $ this -> view ( 'admin.system.log-viewer.dashboard' , compact ( 'percents' ) ) ; }
6253	protected function normalizeAclPresence ( $ data ) { if ( $ data instanceof AclPresenceInterface ) { $ data = [ $ data ] ; } elseif ( is_array ( $ data ) && ! Arr :: isAssoc ( $ data ) ) { $ presences = [ ] ; foreach ( $ data as $ nestedData ) { if ( is_string ( $ nestedData ) ) { $ presences [ ] = $ nestedData ; } else { $ presences [ ] = new AclPresence ( $ nestedData ) ; } } $ data = $ presences ; } else { $ data = [ new AclPresence ( $ data ) ] ; } return $ data ; }
4903	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ select = $ this ( $ serviceLocator , self :: class , $ this -> options ) ; $ this -> options = [ ] ; return $ select ; }
3122	public function find ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = null ; if ( isset ( $ tag ) ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; } $ points = [ ] ; foreach ( $ this -> points as $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { $ points [ ] = $ point ; } } return $ points ; }
4574	public function getProperties ( Localizable $ model ) : array { $ class = get_class ( $ model ) ; if ( substr ( $ class , 0 , 15 ) === 'Proxies\\__CG__\\' ) { $ class = substr ( $ class , 15 ) ; } $ properties = [ ] ; $ reflection = new ReflectionClass ( $ class ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { $ annotation = $ this -> annotationReader -> getPropertyAnnotation ( $ property , Locale :: class ) ; if ( ! $ annotation ) { continue ; } $ properties [ ] = $ property ; } return $ properties ; }
1615	public function readSession ( $ id ) { $ data = $ this -> redis -> executeCommand ( 'GET' , [ $ this -> calculateKey ( $ id ) ] ) ; return $ data === false || $ data === null ? '' : $ data ; }
10092	protected function identifierHash ( $ identifier , $ hash = 'md5' ) { if ( filter_var ( $ identifier , FILTER_VALIDATE_EMAIL ) || $ identifier === null ) { return hash ( $ hash , $ identifier ) ; } return hash ( 'sha256' , $ identifier ) ; }
7148	public function getTotal ( $ discounted = true ) { $ base = $ this -> base ; if ( $ discounted && $ this -> hasDiscounts ( ) ) { foreach ( $ this -> discounts as $ discount ) { $ base -= $ this -> calculateAdjustment ( $ discount , $ base ) ; } } $ total = $ base ; if ( ! empty ( $ this -> taxes ) && $ this -> mode === VatDisplayModes :: MODE_ATI ) { foreach ( $ this -> taxes as $ tax ) { $ total += $ this -> calculateAdjustment ( $ tax , $ base ) ; } } return $ total ; }
4682	private static function formatTime ( float $ value , $ format ) : string { switch ( $ format ) { case static :: FORMAT_PRECISE : return ( string ) ( $ value * 1000 ) ; case static :: FORMAT_MILLISECONDS : return ( string ) round ( $ value * 1000 , 2 ) ; case static :: FORMAT_SECONDS : return ( string ) round ( $ value , 3 ) ; default : return ( string ) ( $ value * 1000 ) ; } }
1006	public function resolveType ( $ objectValue , $ context , ResolveInfo $ info ) { if ( isset ( $ this -> config [ 'resolveType' ] ) ) { $ fn = $ this -> config [ 'resolveType' ] ; return $ fn ( $ objectValue , $ context , $ info ) ; } return null ; }
7269	public function belongsTo ( $ refClass , $ forColumn = null ) { $ refTable = $ refClass :: tableName ( ) ; $ forTable = static :: tableName ( ) ; $ refColumn = $ refClass :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( $ refClass :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select R.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and F.$forColumn = :id " , [ "id" => $ this -> $ forColumn ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ refModel = new $ refClass ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ refModel -> $ col = $ refModel -> decodeValue ( $ val , $ col ) ; return $ refModel ; }
914	public static function calculateBitmask ( array $ options ) { $ bitmask = 0 ; foreach ( $ options as $ optionName ) { if ( \ defined ( $ optionName ) ) { $ bitmask |= \ constant ( $ optionName ) ; } } return $ bitmask ; }
4048	private function getFilterSettings ( ModelInterface $ model ) { $ filters = $ this -> connection -> createQueryBuilder ( ) -> select ( 'id' , 'name' ) -> from ( 'tl_metamodel_filter' ) -> where ( 'pid=:id' ) -> setParameter ( 'id' , $ model -> getProperty ( 'pid' ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; foreach ( $ filters as $ filter ) { $ result [ $ filter [ 'id' ] ] = $ filter [ 'name' ] ; } return $ result ; }
3734	protected function saveSimpleColumn ( $ strColumn , $ arrIds , $ varData ) { if ( is_array ( $ varData ) ) { $ varData = serialize ( $ varData ) ; } $ builder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ builder -> update ( $ this -> getTableName ( ) , 'v2' ) -> set ( 'v2.' . $ strColumn , is_array ( $ varData ) ? serialize ( $ varData ) : $ varData ) -> where ( $ builder -> expr ( ) -> in ( 'v2.id' , ':ids' ) ) -> setParameter ( 'ids' , $ arrIds , Connection :: PARAM_STR_ARRAY ) -> execute ( ) ; }
2229	public function dragFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return '<button type="button" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" ' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</button> ' ; }
4489	public function registerDevice ( string $ deviceId , string $ platform , ? string $ userData = null ) : string { if ( ! isset ( $ this -> arns [ $ platform ] ) ) { throw new PlatformNotConfiguredException ( "There is no configured ARN for $platform" ) ; } try { $ args = [ 'PlatformApplicationArn' => $ this -> arns [ $ platform ] , 'Token' => $ deviceId , 'Attributes' => [ 'Enabled' => 'true' , ] , ] ; if ( $ userData ) { $ args [ 'CustomUserData' ] = $ userData ; } $ res = $ this -> sns -> createPlatformEndpoint ( $ args ) ; } catch ( SnsException $ e ) { preg_match ( '/Endpoint (.+?) already/' , $ e -> getMessage ( ) , $ matches ) ; if ( isset ( $ matches [ 1 ] ) ) { $ this -> sns -> setEndpointAttributes ( [ 'EndpointArn' => $ matches [ 1 ] , 'Attributes' => [ 'Enabled' => 'true' , ] , ] ) ; return $ matches [ 1 ] ; } else { throw $ e ; } } return $ res [ 'EndpointArn' ] ; }
8882	private function isValidGlobalCommand ( string $ command ) : bool { $ valid = false ; if ( strlen ( $ command ) ) { foreach ( $ this -> paths as $ pathDir ) { $ tmpPath = $ pathDir . DIRECTORY_SEPARATOR . $ command ; if ( $ this -> isValidFullPath ( $ tmpPath ) ) { $ valid = true ; break ; } } } return $ valid ; }
3387	public function sendResetLinkEmail ( Request $ request ) { $ this -> validateEmail ( $ request ) ; $ user = $ this -> broker ( ) -> getUser ( $ request -> only ( 'email' ) ) ; if ( $ user && is_null ( $ user -> confirmed_at ) ) { session ( [ 'confirmation_user_id' => $ user -> getKey ( ) ] ) ; throw ValidationException :: withMessages ( [ 'confirmation' => [ __ ( 'confirmation::confirmation.not_confirmed_reset_password' , [ 'resend_link' => route ( 'auth.resend_confirmation' ) ] ) ] ] ) ; } $ response = $ this -> broker ( ) -> sendResetLink ( $ request -> only ( 'email' ) ) ; return $ response == Password :: RESET_LINK_SENT ? $ this -> sendResetLinkResponse ( $ response ) : $ this -> sendResetLinkFailedResponse ( $ request , $ response ) ; }
3422	public function count ( ) { if ( $ this -> queryShouldBeStopped ) { return 0 ; } $ queryType = 'UserQuery::count' ; $ filter = $ this -> normalizeFilter ( ) ; $ callback = function ( ) use ( $ filter ) { return ( int ) $ this -> bxObject -> getList ( $ order = 'ID' , $ by = 'ASC' , $ filter , [ 'NAV_PARAMS' => [ 'nTopCount' => 0 , ] , ] ) -> NavRecordCount ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'filter' ) , $ callback ) ; }
3374	protected function getFilename ( $ filename ) { $ callback = $ this -> fileCallback ; if ( null === $ callback || substr ( $ filename , 0 , 1 ) == '/' ) { return $ filename ; } return $ callback ( $ filename ) ; }
11369	public static function checkPeopleArgs ( ) { $ args = func_get_args ( ) ; if ( empty ( $ args ) ) { return array ( ) ; } if ( count ( $ args ) == 1 && is_string ( $ args [ 0 ] ) && self :: isEmail ( $ args [ 0 ] ) ) { return array ( array ( $ args [ 0 ] ) ) ; } if ( count ( $ args ) == 2 && ( isset ( $ args [ 0 ] ) && true === self :: isEmail ( $ args [ 0 ] ) ) && ( isset ( $ args [ 1 ] ) && false === self :: isEmail ( $ args [ 1 ] ) ) ) { return array ( array ( $ args [ 1 ] => $ args [ 0 ] ) ) ; } if ( count ( $ args ) == 1 ) { $ args = $ args [ 0 ] ; } $ result = array ( ) ; foreach ( $ args as $ name => $ email ) { if ( is_string ( $ name ) && true === self :: isEmail ( $ email ) ) { $ result [ ] = array ( $ name => $ email ) ; } elseif ( is_numeric ( $ name ) && true === self :: isEmail ( $ email ) ) { $ result [ ] = array ( $ email ) ; } } return $ result ; }
8980	private function buildRateFromTableRowData ( array $ row ) { return new Rate ( $ row [ 'source_name' ] , ( float ) $ row [ 'rate_value' ] , $ row [ 'currency_code' ] , $ row [ 'rate_type' ] , \ DateTime :: createFromFormat ( 'Y-m-d' , $ row [ 'rate_date' ] ) , $ row [ 'base_currency_code' ] , \ DateTime :: createFromFormat ( 'Y-m-d H:i:s' , $ row [ 'created_at' ] ) , \ DateTime :: createFromFormat ( 'Y-m-d H:i:s' , $ row [ 'modified_at' ] ) ) ; }
7485	public function charAt ( $ index ) { $ index = ( int ) $ index ; if ( $ index < 0 || $ index >= $ this -> length ( ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_substr ( $ this -> string , $ index , 1 , $ this -> encoding ) ; }
12863	protected function getCachedIdentityService ( Cache $ cache , array $ options ) : CachedIdentityService { if ( ! isset ( $ options [ 'authUrl' ] ) ) { throw new \ InvalidArgumentException ( "'authUrl' is a required option" ) ; } $ stack = HandlerStack :: create ( ) ; if ( ! empty ( $ options [ 'debugLog' ] ) && ! empty ( $ options [ 'logger' ] ) && ! empty ( $ options [ 'messageFormatter' ] ) ) { $ stack -> push ( GuzzleMiddleware :: log ( $ options [ 'logger' ] , $ options [ 'messageFormatter' ] ) ) ; } $ clientOptions = [ 'base_uri' => Utils :: normalizeUrl ( $ options [ 'authUrl' ] ) , 'handler' => $ stack , ] ; if ( isset ( $ options [ 'requestOptions' ] ) ) { $ clientOptions = array_merge ( $ options [ 'requestOptions' ] , $ clientOptions ) ; } $ service = CachedIdentityService :: factory ( new Client ( $ clientOptions ) ) ; $ service -> setCache ( $ cache ) ; return $ service ; }
9417	public function fwhm ( ) { $ float_fwhm = 2 * sqrt ( 2 * log ( 2 ) ) * $ this -> float_sigma ; if ( $ this -> int_precision ) { return round ( $ float_fwhm , $ this -> int_precision ) ; } return $ float_fwhm ; }
2738	private function setToken ( $ token ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_API_KEY , $ token ) ; $ this -> output -> writeln ( '<info>Token updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; }
7992	public function setPassword ( $ pp , $ pca , $ passwd ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (OVH cloud passport).' ) ; if ( ! $ pca ) throw new BadMethodCallException ( 'Missing parameter $pca (PCA ServiceName).' ) ; if ( ! $ passwd ) throw new BadMethodCallException ( 'Missing parameter $passwd (Password for this pca).' ) ; $ payload = array ( 'password' => $ passwd ) ; try { $ this -> put ( 'cloud/' . $ pp . '/pca/' . $ pca , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
3899	public function setDataFor ( $ arrValues ) { $ strTable = $ this -> getMetaModel ( ) -> getTableName ( ) ; $ strColName = $ this -> getColName ( ) ; foreach ( $ arrValues as $ intId => $ varData ) { if ( is_array ( $ varData ) ) { $ varData = serialize ( $ varData ) ; } $ this -> connection -> update ( $ strTable , [ $ strColName => $ varData ] , [ 'id' => $ intId ] ) ; } }
3931	private function getOrCreateProperty ( PropertiesDefinitionInterface $ definition , $ propName ) { if ( $ definition -> hasProperty ( $ propName ) ) { return $ definition -> getProperty ( $ propName ) ; } $ property = new DefaultProperty ( $ propName ) ; $ definition -> addProperty ( $ property ) ; return $ property ; }
4233	private static function getHash ( $ what ) { $ str = null ; if ( ! ( $ what instanceof \ Reflector ) ) { $ str = \ get_class ( $ what ) ; } elseif ( $ what instanceof \ ReflectionClass ) { $ str = $ what -> getName ( ) ; } elseif ( $ what instanceof \ ReflectionMethod ) { $ str = $ what -> getDeclaringClass ( ) -> getName ( ) . '::' . $ what -> getName ( ) . '()' ; } elseif ( $ what instanceof \ ReflectionFunction ) { $ str = $ what -> getName ( ) . '()' ; } elseif ( $ what instanceof \ ReflectionProperty ) { $ str = $ what -> getDeclaringClass ( ) -> getName ( ) . '::' . $ what -> getName ( ) ; } return $ str ? \ md5 ( $ str ) : null ; }
12393	public function onSiteSaved ( SiteSavedEvent $ event ) { $ fs = new Filesystem ( ) ; $ fs -> mirror ( $ this -> configurationHandler -> uploadAssetsDir ( ) , $ this -> configurationHandler -> uploadAssetsDirProduction ( ) ) ; }
12551	public function isSerialized ( ) { if ( ! is_string ( $ this -> serialized ) ) { return false ; } $ this -> serialized = trim ( $ this -> serialized ) ; if ( 'N;' == $ this -> serialized ) { return true ; } $ length = strlen ( $ this -> serialized ) ; if ( $ length < 4 ) { return false ; } if ( ':' !== $ this -> serialized [ 1 ] ) { return false ; } $ lastc = $ this -> serialized [ $ length - 1 ] ; if ( ';' !== $ lastc && '}' !== $ lastc ) { return false ; } $ token = $ this -> serialized [ 0 ] ; switch ( $ token ) { case 's' : if ( '"' !== $ this -> serialized [ $ length - 2 ] ) { return false ; } case 'a' : case 'O' : return ( bool ) preg_match ( "/^{$token}:[0-9]+:/s" , $ this -> serialized ) ; case 'b' : case 'i' : case 'd' : return ( bool ) preg_match ( "/^{$token}:[0-9.E-]+;\$/" , $ this -> serialized ) ; } return false ; }
7810	public function getPackageVersion ( ) { $ package_config = file_get_contents ( dirname ( __FILE__ ) . "./../composer.json" ) ; if ( $ package_config ) { $ package_config_object = json_decode ( $ package_config ) ; if ( is_object ( $ package_config_object ) && isset ( $ package_config_object -> version ) ) { return $ package_config_object -> version ; } } return null ; }
376	protected function parseDocCommentDetail ( $ reflection ) { $ comment = strtr ( trim ( preg_replace ( '/^\s*\**( |\t)?/m' , '' , trim ( $ reflection -> getDocComment ( ) , '/' ) ) ) , "\r" , '' ) ; if ( preg_match ( '/^\s*@\w+/m' , $ comment , $ matches , PREG_OFFSET_CAPTURE ) ) { $ comment = trim ( substr ( $ comment , 0 , $ matches [ 0 ] [ 1 ] ) ) ; } if ( $ comment !== '' ) { return rtrim ( Console :: renderColoredString ( Console :: markdownToAnsi ( $ comment ) ) ) ; } return '' ; }
11509	protected function parseMessageFromRequest ( $ content ) { $ content = strval ( $ content ) ; $ dataSet = json_decode ( $ content , true ) ; if ( $ dataSet && ( JSON_ERROR_NONE === json_last_error ( ) ) ) { $ content = XML :: build ( $ dataSet ) ; } if ( $ this -> isSafeMode ( ) ) { if ( ! $ this -> encryptor ) { throw new RuntimeException ( 'Safe mode Encryptor is necessary, please use Guard::setEncryptor(Encryptor $encryptor) set the encryptor instance.' ) ; } $ message = $ this -> encryptor -> decryptMsg ( $ this -> request -> get ( 'msg_signature' ) , $ this -> request -> get ( 'nonce' ) , $ this -> request -> get ( 'timestamp' ) , $ content ) ; } else { $ message = XML :: parse ( $ content ) ; } return $ message ; }
10836	private function compileUsing ( array $ join ) { $ sql = array ( ) ; list ( $ using , $ table , $ type , $ column ) = $ join ; if ( $ type !== null ) { $ sql [ ] = $ type ; } array_push ( $ sql , "JOIN" , $ table , "USING({$column})" ) ; return join ( ' ' , $ sql ) ; }
64	public function size ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new \ RuntimeException ( "$path does not exist." ) ; } if ( is_dir ( $ path ) ) { return $ this -> directorySize ( $ path ) ; } return filesize ( $ path ) ; }
7919	protected function renderInput ( $ options = [ ] , $ resultsOptions = [ ] ) { Html :: addCssClass ( $ options , 'prompt' ) ; $ lines = [ ] ; $ input = $ this -> hasModel ( ) ? Html :: activeTextInput ( $ this -> model , $ this -> attribute , $ options ) : Html :: textInput ( $ this -> name , $ this -> value , $ options ) ; if ( ! empty ( $ this -> displayIcon ) ) { $ lines [ ] = Html :: beginTag ( 'div' , [ 'class' => 'ui icon input' ] ) ; $ lines [ ] = $ input ; $ lines [ ] = Html :: tag ( 'i' , '' , [ 'class' => 'icon search' ] ) ; $ lines [ ] = Html :: endTag ( 'div' ) ; } else { $ lines [ ] = $ input ; } $ lines [ ] = Html :: tag ( 'div' , '' , $ resultsOptions ) ; return implode ( "\n" , $ lines ) ; }
9431	public function routes ( ) { $ routes = array_merge ( $ this -> routes , $ this -> collector -> getData ( ) ) ; return function ( RouteCollector $ collector ) use ( $ routes ) { foreach ( array_filter ( $ routes ) as $ route ) { list ( $ method , $ uri , $ handler ) = ( array ) $ route ; $ collector -> addRoute ( $ method , $ uri , $ handler ) ; } } ; }
3577	protected function metaQuery ( Builder $ query , $ method , ArgumentBag $ args ) { if ( in_array ( $ method , [ 'pluck' , 'value' , 'aggregate' , 'orderBy' , 'lists' ] ) ) { return $ this -> metaJoinQuery ( $ query , $ method , $ args ) ; } return $ this -> metaHasQuery ( $ query , $ method , $ args ) ; }
7139	protected function getGroupsForStep ( $ step ) { $ groups = [ 'Default' ] ; if ( $ step === static :: CHECKOUT_STEP ) { $ groups [ ] = 'Checkout' ; $ groups [ ] = 'Identity' ; $ groups [ ] = 'Availability' ; } elseif ( $ step === static :: SHIPMENT_STEP ) { $ groups [ ] = 'Availability' ; } return $ groups ; }
3907	public function handle ( BuildDataDefinitionEvent $ event ) { $ container = $ event -> getContainer ( ) ; if ( $ container instanceof IMetaModelDataDefinition ) { $ this -> build ( $ container ) ; } }
12135	public function show ( QuestionRequest $ request , Question $ question ) { if ( $ question -> exists ) { $ view = 'forum::question.show' ; } else { $ view = 'forum::question.new' ; } return $ this -> response -> title ( trans ( 'app.view' ) . ' ' . trans ( 'forum::question.name' ) ) -> data ( compact ( 'question' ) ) -> view ( $ view , true ) -> output ( ) ; }
1004	public function parseRequestParams ( $ method , array $ bodyParams , array $ queryParams ) { if ( $ method === 'GET' ) { $ result = OperationParams :: create ( $ queryParams , true ) ; } elseif ( $ method === 'POST' ) { if ( isset ( $ bodyParams [ 0 ] ) ) { $ result = [ ] ; foreach ( $ bodyParams as $ index => $ entry ) { $ op = OperationParams :: create ( $ entry ) ; $ result [ ] = $ op ; } } else { $ result = OperationParams :: create ( $ bodyParams ) ; } } else { throw new RequestError ( 'HTTP Method "' . $ method . '" is not supported' ) ; } return $ result ; }
12514	public static function create ( $ path = '' , $ mode = 0777 ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; try { $ fs -> mkdir ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_CREATING' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
900	public function isArrayMultiLine ( $ index ) { if ( ! $ this -> isArray ( $ index ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Not an array at given index %d.' , $ index ) ) ; } $ tokens = $ this -> tokens ; if ( $ tokens [ $ index ] -> isGivenKind ( T_ARRAY ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; } $ endIndex = $ tokens [ $ index ] -> equals ( '(' ) ? $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) : $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_ARRAY_SQUARE_BRACE , $ index ) ; for ( ++ $ index ; $ index < $ endIndex ; ++ $ index ) { $ token = $ tokens [ $ index ] ; $ blockType = Tokens :: detectBlockType ( $ token ) ; if ( $ blockType && $ blockType [ 'isStart' ] ) { $ index = $ tokens -> findBlockEnd ( $ blockType [ 'type' ] , $ index ) ; continue ; } if ( $ token -> isWhitespace ( ) && ! $ tokens [ $ index - 1 ] -> isGivenKind ( T_END_HEREDOC ) && false !== strpos ( $ token -> getContent ( ) , "\n" ) ) { return true ; } } return false ; }
12302	public function getChild ( $ id , $ relation , $ idChild , $ filters = null ) { $ parent = $ this -> model -> find ( $ id ) ; if ( ! $ parent ) { return null ; } if ( count ( $ filters -> request -> all ( ) ) > 0 ) { $ child = $ parent -> $ relation ( ) -> getRelated ( ) ; $ search = new Search ( $ child , $ filters , $ parent -> $ relation ( ) ) ; $ this -> builder = $ search -> getBuilder ( ) ; $ this -> builder -> select ( "{$child->getTable()}.*" ) ; if ( $ parent -> $ relation ( ) instanceof \ Illuminate \ Database \ Eloquent \ Relations \ BelongsToMany ) { $ this -> builder -> where ( $ parent -> $ relation ( ) -> getOtherKey ( ) , $ idChild ) ; } $ resource = $ this -> builder -> get ( ) ; } else { $ resource = $ parent -> $ relation ( ) -> find ( $ idChild ) ; } return $ resource ; }
5800	public function delete ( int $ id , AuthenticationService $ authentication , AuthorizationService $ authorization ) : string { if ( null === $ administrator = $ this -> getObjectById ( $ id ) ) { throw new Exceptions \ QueryResultsNotFoundException ( ) ; } $ administrator -> setAuth ( $ authentication , $ authorization ) ; if ( ! $ administrator -> isDeletable ( ) ) { throw new Exceptions \ UnallowedActionException ( $ administrator -> getNotDeletableReason ( ) ) ; } $ this -> doDeleteTransaction ( $ id ) ; $ username = $ administrator -> getUsername ( ) ; unset ( $ administrator ) ; return $ username ; }
12414	public function removeDevice ( $ groupId , array $ deviceIdentifiers ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'device_identifiers' => $ deviceIdentifiers , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_DEVICE , $ params ] ) ; }
4269	public function dir_readdir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ readdir ( $ this -> handle ) ; self :: register ( ) ; return $ success ; }
4851	protected function applyId ( & $ row , $ id , $ identifierField ) { $ ids = ( array ) $ id ; $ findId = function ( $ row ) use ( $ ids , $ identifierField ) { foreach ( $ ids as $ id ) { $ bool = true ; $ identifierField = $ this -> flatten ( $ identifierField ) ; foreach ( $ identifierField as $ identifier ) { $ bool = $ bool && ( mb_strtolower ( $ id [ $ identifier ] ) === mb_strtolower ( $ row [ $ identifier ] ) ) ; } if ( $ bool ) { return $ id [ 'id' ] ; } } return 0 ; } ; $ isDeep = $ this -> isDeep ( $ row ) ; if ( $ isDeep ) { foreach ( $ row as $ i => & $ r ) { $ r [ 'id' ] = $ findId ( $ r ) ; } } else { $ row [ 'id' ] = $ findId ( $ row ) ; } }
2422	public static function deleteResource ( $ strResource ) { $ objModel = FilesModel :: findByPath ( $ strResource ) ; if ( $ objModel !== null ) { $ objModel -> delete ( ) ; } $ objFiles = FilesModel :: findMultipleByBasepath ( $ strResource . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objFiles -> delete ( ) ; } } static :: updateFolderHashes ( \ dirname ( $ strResource ) ) ; return null ; }
8340	public static function set ( string $ fileName , array $ content ) { try { $ json = Yaml :: dump ( $ content , 2 ) ; if ( file_put_contents ( $ fileName , $ json ) === false ) { throw new FileNotWritable ( 'can\'t write to "' . $ fileName . '"' ) ; } } catch ( DumpException $ e ) { throw new BadUse ( 'Config::set() content parameter can\'t be dump to YAML' ) ; } self :: $ files [ $ fileName ] = $ content ; }
1045	public static function createFromException ( $ e , $ debug = false , $ internalErrorMessage = null ) { Utils :: invariant ( $ e instanceof Exception || $ e instanceof Throwable , 'Expected exception, got %s' , Utils :: getVariableType ( $ e ) ) ; $ internalErrorMessage = $ internalErrorMessage ? : self :: $ internalErrorMessage ; if ( $ e instanceof ClientAware ) { $ formattedError = [ 'message' => $ e -> isClientSafe ( ) ? $ e -> getMessage ( ) : $ internalErrorMessage , 'extensions' => [ 'category' => $ e -> getCategory ( ) , ] , ] ; } else { $ formattedError = [ 'message' => $ internalErrorMessage , 'extensions' => [ 'category' => Error :: CATEGORY_INTERNAL , ] , ] ; } if ( $ e instanceof Error ) { $ locations = Utils :: map ( $ e -> getLocations ( ) , static function ( SourceLocation $ loc ) { return $ loc -> toSerializableArray ( ) ; } ) ; if ( ! empty ( $ locations ) ) { $ formattedError [ 'locations' ] = $ locations ; } if ( ! empty ( $ e -> path ) ) { $ formattedError [ 'path' ] = $ e -> path ; } if ( ! empty ( $ e -> getExtensions ( ) ) ) { $ formattedError [ 'extensions' ] = $ e -> getExtensions ( ) + $ formattedError [ 'extensions' ] ; } } if ( $ debug ) { $ formattedError = self :: addDebugEntries ( $ formattedError , $ e , $ debug ) ; } return $ formattedError ; }
3373	public function indexAction ( ) { $ request = $ this -> getRequest ( ) ; $ this -> httpClient -> setMethod ( Request :: METHOD_POST ) ; $ this -> httpClient -> setParameterPost ( [ 'dsl_text' => $ request -> getPost ( 'dsl_text' ) ] ) ; $ response = $ this -> httpClient -> send ( ) ; if ( ! $ response -> isSuccess ( ) ) { throw new \ UnexpectedValueException ( 'HTTP Request failed' ) ; } $ redirect = $ this -> plugin ( 'redirect' ) ; return $ redirect -> toUrl ( 'https://yuml.me/' . $ response -> getBody ( ) ) ; }
12777	public function render ( ) { $ sort = 0 ; $ query = $ this -> request -> getQuery ( ) ; if ( isset ( $ query [ 'sort' ] ) && isset ( $ this -> columns [ $ query [ 'sort' ] ] ) ) { $ sort = $ query [ 'sort' ] ; } return $ this -> formatter -> render ( $ this -> columns , $ this -> getRecords ( ) , $ this -> dataManager -> getTotalCount ( ) , $ this -> limit , $ this -> page , $ sort ) ; }
12749	private function validateSKU ( string $ sku ) { if ( strlen ( $ sku ) == 0 ) { throw new SKUException ( "A SKU cannot be empty" ) ; } $ containsWhitespace = preg_match ( $ this -> whiteSpacePattern , $ sku ) == 1 ; if ( $ containsWhitespace ) { throw new SKUException ( sprintf ( "A SKU cannot contain white space characters: \"%s\"" , $ sku ) ) ; } $ containsUppercaseCharacters = preg_match ( $ this -> uppercaseCharactersPattern , $ sku ) == 1 ; if ( $ containsUppercaseCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot contain uppercase characters: \"%s\"" , $ sku ) ) ; } $ containsInvalidCharacters = preg_match ( $ this -> invalidCharactersPattern , $ sku ) == 1 ; if ( $ containsInvalidCharacters ) { throw new SKUException ( sprintf ( "The SKU \"%s\" contains invalid characters. A SKU can only contain the following characters: a-z, 0-9 and -" , $ sku ) ) ; } $ prefixMatches = [ ] ; $ prefixContainsInvalidCharacters = preg_match ( $ this -> invalidPrefixCharacters , $ sku , $ prefixMatches ) == 1 ; if ( $ prefixContainsInvalidCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot start with the given characters: \"%s\"" , implode ( "" , $ prefixMatches ) ) ) ; } $ suffixMatches = [ ] ; $ suffixContainsInvalidCharacters = preg_match ( $ this -> invalidSuffixCharacters , $ sku , $ suffixMatches ) == 1 ; if ( $ suffixContainsInvalidCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot end with the given characters: \"%s\"" , implode ( "" , $ suffixMatches ) ) ) ; } if ( strlen ( $ sku ) < $ this -> minLength ) { throw new SKUException ( sprintf ( "The given SKU \"%s\" is too short. The minimum length for a SKU is: %s" , $ sku , $ this -> minLength ) ) ; } if ( strlen ( $ sku ) > $ this -> maxLength ) { throw new SKUException ( sprintf ( "The given SKU \"%s\" is too long (%s character). The maximum length for a SKU is: %s" , strlen ( $ sku ) , $ sku , $ this -> maxLength ) ) ; } }
1933	protected function getLocaleString ( ) { $ container = System :: getContainer ( ) ; return 'var Contao={' . 'theme:"' . Backend :: getTheme ( ) . '",' . 'lang:{' . 'close:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'close' ] . '",' . 'collapse:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'collapseNode' ] . '",' . 'expand:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'expandNode' ] . '",' . 'loading:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'loadingData' ] . '",' . 'apply:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'apply' ] . '"' . '},' . 'script_url:"' . $ container -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) . '",' . 'path:"' . Environment :: get ( 'path' ) . '",' . 'request_token:"' . REQUEST_TOKEN . '",' . 'referer_id:"' . $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> attributes -> get ( '_contao_referer_id' ) . '"' . '};' ; }
12219	public function errorHandler ( $ errno , $ errstr , $ errfile , $ errline , array $ errcontext = [ ] ) { $ codes = array ( 256 => 'E_USER_ERROR' , 512 => 'E_USER_WARNING' , 1024 => 'E_USER_NOTICE' , 2048 => 'E_STRICT' , 4096 => 'E_RECOVERABLE_ERROR' , 8192 => 'E_DEPRECATED' , 16384 => 'E_USER_DEPRECATED' , 8 => 'E_NOTICE' , 2 => 'E_WARNING' ) ; $ message = 'Error of level ' ; if ( array_key_exists ( $ errno , $ codes ) ) { $ message .= $ codes [ $ errno ] ; } else { $ message .= sprintf ( 'Unknown error level, code of %d passed' , $ errno ) ; } $ message .= sprintf ( '. Error message was "%s" in file %s at line %d.' , $ errstr , $ errfile , $ errline ) ; $ this -> container [ 'log' ] -> error ( $ message , $ errcontext ) ; $ this -> exceptionHandler ( new InternalServerError ( 'An unexpected error occurred.' ) ) ; }
5702	public function isCustomActionAllowed ( $ action ) { $ actions = $ this -> owner -> config ( ) -> better_buttons_actions ; if ( $ actions ) { return in_array ( $ action , $ actions ) ; } return false ; }
2366	public static function censor ( $ strString , $ varWords , $ strReplace = '' ) { foreach ( ( array ) $ varWords as $ strWord ) { $ strString = preg_replace ( '/\b(' . str_replace ( '\*' , '\w*?' , preg_quote ( $ strWord , '/' ) ) . ')\b/i' , $ strReplace , $ strString ) ; } return $ strString ; }
9882	private function writeSheet ( XMLWriter $ objWriter , $ pSheetname , $ pSheetId = 1 , $ pRelId = 1 , $ sheetState = 'visible' ) { if ( $ pSheetname != '' ) { $ objWriter -> startElement ( 'sheet' ) ; $ objWriter -> writeAttribute ( 'name' , $ pSheetname ) ; $ objWriter -> writeAttribute ( 'sheetId' , $ pSheetId ) ; if ( $ sheetState != 'visible' && $ sheetState != '' ) { $ objWriter -> writeAttribute ( 'state' , $ sheetState ) ; } $ objWriter -> writeAttribute ( 'r:id' , 'rId' . $ pRelId ) ; $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
7541	function setIndex ( $ index ) { if ( $ this -> parent ) { if ( $ index > $ this -> index ( ) ) { -- $ index ; } $ this -> delete ( ) ; $ this -> parent -> addChild ( $ this , $ index ) ; } }
12699	static function pake_antpattern ( $ files , $ rootdir ) { $ results = array ( ) ; foreach ( $ files as $ file ) { $ file = str_replace ( '/**/**/' , '/**/' , $ file ) ; $ type = 'any' ; if ( substr ( $ file , - 1 ) == '/' ) { $ type = 'dir' ; $ file = substr ( $ file , 0 , - 1 ) ; } if ( strlen ( $ file ) >= 3 && substr ( $ file , - 3 ) == '/**' ) { $ file .= '/*' ; } $ dir = dirname ( $ file ) ; $ file = basename ( $ file ) ; if ( strpos ( $ dir , '**' ) !== false ) { $ split = explode ( '/' , $ dir ) ; $ path = '' ; foreach ( $ split as $ i => $ part ) { if ( $ part != '**' ) { $ path .= "/$part" ; } else { $ newfile = implode ( '/' , array_slice ( $ split , $ i + 1 ) ) . "/$file" . ( $ type == 'dir' ? '/' : '' ) ; $ dirs = pakeFinder :: type ( 'dir' ) -> in ( $ rootdir . $ path ) ; $ dirs [ ] = $ rootdir . $ path ; foreach ( $ dirs as $ newdir ) { $ found = self :: pake_antpattern ( array ( $ newfile ) , $ newdir ) ; $ results = array_merge ( $ results , $ found ) ; } break ; } } } else { $ found = pakeFinder :: type ( $ type ) -> name ( $ file ) -> maxdepth ( 0 ) -> in ( $ rootdir . '/' . $ dir ) ; $ results = array_merge ( $ results , $ found ) ; } } return $ results ; }
1103	protected function fireMoveEvent ( $ event , $ halt = true ) { if ( ! isset ( static :: $ dispatcher ) ) return true ; $ event = "eloquent.{$event}: " . get_class ( $ this -> node ) ; $ method = $ halt ? 'until' : 'fire' ; return static :: $ dispatcher -> $ method ( $ event , $ this -> node ) ; }
11291	protected function _getAttributeDataWhenSet ( $ attributeName , $ query = false , $ loadMap = false , $ record = false ) { if ( is_numeric ( $ this -> model_data [ $ attributeName ] ) ) { if ( $ this -> _isRelation ( $ attributeName ) && ! isset ( $ this -> model_dynamicOff ) ) { $ this -> $ attributeName = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap , $ record ) ; } } $ this -> beforeGet ( $ attributeName ) ; $ returnValue = $ this -> model_data [ $ attributeName ] ; $ this -> afterGet ( $ attributeName , $ returnValue ) ; return $ returnValue ; }
11768	public function updateSentinels ( ) { SENTINEL_QUERY : { $ sentinel = $ this -> getSentinelConnection ( ) ; try { $ payload = $ sentinel -> executeCommand ( RawCommand :: create ( 'SENTINEL' , 'sentinels' , $ this -> service ) ) ; $ this -> sentinels = array ( ) ; $ this -> sentinels [ ] = $ sentinel -> getParameters ( ) -> toArray ( ) ; foreach ( $ payload as $ sentinel ) { $ this -> sentinels [ ] = array ( 'host' => $ sentinel [ 3 ] , 'port' => $ sentinel [ 5 ] , 'role' => 'sentinel' , ) ; } } catch ( ConnectionException $ exception ) { $ this -> sentinelConnection = null ; goto SENTINEL_QUERY ; } } }
6599	protected function getReturnType ( array $ lines ) { foreach ( $ lines as $ line ) { if ( strpos ( $ line , '@return' ) === 0 ) { $ type = trim ( str_replace ( '@return' , '' , $ line ) ) ; $ type = str_replace ( '$this' , 'self' , $ type ) ; $ type = explode ( '|' , $ type ) ; return $ type ; } } return [ ] ; }
258	public function render ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; return $ this -> renderFile ( $ viewFile , $ params , $ context ) ; }
8067	public function run ( $ input ) { while ( $ this -> workerPoolSize > 0 ) { try { $ processDetailsOfFreeWorker = $ this -> getNextFreeWorker ( ) ; $ processDetailsOfFreeWorker -> getSocket ( ) -> send ( array ( 'cmd' => 'run' , 'data' => $ input ) ) ; return $ processDetailsOfFreeWorker -> getPid ( ) ; } catch ( \ Exception $ e ) { pcntl_signal_dispatch ( ) ; } } throw new WorkerPoolException ( 'Unable to run the task.' ) ; }
8652	private function convertGetReportScheduleCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportScheduleCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
6479	public function getClientIPAddress ( IHttpRequestMessage $ request ) : ? string { $ clientIPAddress = null ; $ request -> getProperties ( ) -> tryGet ( self :: CLIENT_IP_ADDRESS_PROPERTY , $ clientIPAddress ) ; return $ clientIPAddress ; }
380	public function renderCallStack ( $ exception ) { $ out = '<ul>' ; $ out .= $ this -> renderCallStackItem ( $ exception -> getFile ( ) , $ exception -> getLine ( ) , null , null , [ ] , 1 ) ; for ( $ i = 0 , $ trace = $ exception -> getTrace ( ) , $ length = count ( $ trace ) ; $ i < $ length ; ++ $ i ) { $ file = ! empty ( $ trace [ $ i ] [ 'file' ] ) ? $ trace [ $ i ] [ 'file' ] : null ; $ line = ! empty ( $ trace [ $ i ] [ 'line' ] ) ? $ trace [ $ i ] [ 'line' ] : null ; $ class = ! empty ( $ trace [ $ i ] [ 'class' ] ) ? $ trace [ $ i ] [ 'class' ] : null ; $ function = null ; if ( ! empty ( $ trace [ $ i ] [ 'function' ] ) && $ trace [ $ i ] [ 'function' ] !== 'unknown' ) { $ function = $ trace [ $ i ] [ 'function' ] ; } $ args = ! empty ( $ trace [ $ i ] [ 'args' ] ) ? $ trace [ $ i ] [ 'args' ] : [ ] ; $ out .= $ this -> renderCallStackItem ( $ file , $ line , $ class , $ function , $ args , $ i + 2 ) ; } $ out .= '</ul>' ; return $ out ; }
3144	public function finish ( RunnerServiceContext $ context , $ finalState = DeliveryExecution :: STATE_FINISHED ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ executionUri = $ context -> getTestExecutionUri ( ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ executionService = ServiceProxy :: singleton ( ) ; $ deliveryExecution = $ executionService -> getDeliveryExecution ( $ executionUri ) ; if ( $ deliveryExecution -> getUserIdentifier ( ) == $ userUri ) { \ common_Logger :: i ( "Finishing the delivery execution {$executionUri}" ) ; $ result = $ deliveryExecution -> setState ( $ finalState ) ; } else { \ common_Logger :: w ( "Non owner {$userUri} tried to finish deliveryExecution {$executionUri}" ) ; $ result = false ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> clearEvents ( $ executionUri ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'finish' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return $ result ; }
10368	public function recover ( RecoverRequest $ request ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'recover' ) ) -> dispatchFrom ( RecoverJob :: class , $ request ) ; return back ( ) -> withSuccess ( trans ( 'auth::recover.success' ) ) ; }
11537	public function get ( $ name , $ default = "" ) { $ param = Arr :: get ( $ _REQUEST , $ name , $ default ) ; if ( $ _SERVER [ "REQUEST_METHOD" ] == "GET" && is_string ( $ param ) ) { $ param = urldecode ( $ param ) ; } return $ param ; }
2310	public function setZoomLevel ( $ zoomLevel ) { $ zoomLevel = ( int ) $ zoomLevel ; if ( $ zoomLevel < 0 || $ zoomLevel > 100 ) { throw new \ InvalidArgumentException ( 'Zoom level must be between 0 and 100!' ) ; } $ this -> zoomLevel = $ zoomLevel ; return $ this ; }
4097	public function field ( $ field , $ config = array ( ) ) { if ( is_string ( $ config ) ) $ config = array ( 'type' => $ config ) ; $ this -> properties [ $ field ] = $ config ; return $ this ; }
10938	private static function populateEntries ( $ heading , $ data , $ key ) { foreach ( LogLevels :: all ( ) as $ level ) { if ( self :: hasLogLevel ( $ heading [ $ key ] , $ level ) ) { self :: $ parsed [ ] = [ 'level' => $ level , 'header' => $ heading [ $ key ] , 'stack' => $ data [ $ key ] , ] ; } } }
792	public function clearErrors ( $ attribute = null ) { if ( $ attribute === null ) { $ this -> _errors = [ ] ; } else { unset ( $ this -> _errors [ $ attribute ] ) ; } }
12407	public function set ( $ key , $ value ) { try { $ filenameCache = $ this -> location . DS . $ key ; file_put_contents ( $ filenameCache , $ value ) ; } catch ( \ Exception $ e ) { return false ; } return true ; }
4405	public function generate ( InputInterface $ input , OutputInterface $ output ) { $ fileSystem = $ this -> container -> get ( 'filesystem' ) ; $ configResolver = $ this -> container -> get ( 'ezpublish.config.resolver' ) ; $ kernelRootDir = $ this -> container -> getParameter ( 'kernel.root_dir' ) ; $ siteAccessGroup = $ input -> getOption ( 'site-access-group' ) ; $ varDir = $ configResolver -> getParameter ( 'var_dir' , null , $ siteAccessGroup ) ; $ repository = $ configResolver -> getParameter ( 'repository' , null , $ siteAccessGroup ) ; $ configFile = $ kernelRootDir . '/config/ngadminui.yml' ; if ( $ fileSystem -> exists ( $ configFile ) ) { if ( ! $ this -> questionHelper -> ask ( $ input , $ output , new ConfirmationQuestion ( '<info><comment>ngadminui.yml</comment> configuration file already exists. Do you want to overwrite it?</info> [<comment>no</comment>] ' , false ) ) ) { return ; } } $ siteAccessName = $ input -> getOption ( 'site-access-name' ) ; $ languageService = $ this -> container -> get ( 'ezpublish.api.repository' ) -> getContentLanguageService ( ) ; $ languages = $ languageService -> loadLanguages ( ) ; $ settings = array ( 'parameters' => array ( 'netgen_admin_ui.' . $ siteAccessName . '.is_admin_ui_siteaccess' => true , 'eztags.' . $ siteAccessName . '.routing.enable_tag_router' => false , 'ezsettings.' . $ siteAccessName . '.treemenu.http_cache' => false , ) , 'ezpublish' => array ( 'siteaccess' => array ( 'list' => array ( $ siteAccessName , ) , 'groups' => array ( 'ngadminui' => array ( $ siteAccessName , ) , ) , 'match' => array ( 'Map\URI' => array ( $ siteAccessName => $ siteAccessName , ) , ) , ) , 'system' => array ( $ siteAccessName => array ( 'user' => array ( 'layout' => '@NetgenAdminUI/pagelayout_login.html.twig' , 'login_template' => '@NetgenAdminUI/user/login.html.twig' , ) , 'languages' => array_map ( function ( Language $ language ) { return $ language -> languageCode ; } , $ languages ) , 'var_dir' => $ varDir , 'repository' => $ repository , ) , ) , ) , 'ez_publish_legacy' => array ( 'system' => array ( $ siteAccessName => array ( 'templating' => array ( 'view_layout' => '@NetgenAdminUI/pagelayout_legacy.html.twig' , 'module_layout' => '@NetgenAdminUI/pagelayout_module.html.twig' , ) , ) , ) , ) , ) ; file_put_contents ( $ configFile , Yaml :: dump ( $ settings , 7 ) ) ; $ output -> writeln ( array ( '' , 'Generated <comment>ngadminui.yml</comment> configuration file!' , '' , ) ) ; }
261	protected function typecastValue ( $ value , $ type ) { if ( is_scalar ( $ type ) ) { if ( is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) { $ value = $ value -> __toString ( ) ; } switch ( $ type ) { case self :: TYPE_INTEGER : return ( int ) $ value ; case self :: TYPE_FLOAT : return ( float ) $ value ; case self :: TYPE_BOOLEAN : return ( bool ) $ value ; case self :: TYPE_STRING : if ( is_float ( $ value ) ) { return StringHelper :: floatToString ( $ value ) ; } return ( string ) $ value ; default : throw new InvalidArgumentException ( "Unsupported type '{$type}'" ) ; } } return call_user_func ( $ type , $ value ) ; }
12310	private function findFile ( $ uriPath ) { return array_reduce ( $ this -> paths , function ( $ file , $ path ) use ( $ uriPath ) { if ( false !== $ file ) { return $ file ; } $ file = $ path . $ uriPath ; if ( is_file ( $ file ) && is_readable ( $ file ) ) { return $ file ; } return false ; } , false ) ; }
10613	protected function authenticateUser ( UserInterface $ user , Response $ response ) { try { $ this -> get ( 'fos_user.security.login_manager' ) -> loginUser ( $ this -> container -> getParameter ( 'fos_user.firewall_name' ) , $ user , $ response ) ; } catch ( AccountStatusException $ ex ) { } }
12227	public function deleteSelf ( ) { $ tmp = dom_import_simplexml ( $ this ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { throw new BadMethodCallException ( 'deleteSelf() cannot be used to delete the root node' ) ; } $ tmp -> parentNode -> removeChild ( $ tmp ) ; }
2605	public function aroundSetHeader ( Http $ subject , callable $ proceed , ... $ args ) { if ( $ this -> config -> getType ( ) !== Config :: FASTLY ) { return $ proceed ( ... $ args ) ; } if ( isset ( $ args [ 0 ] ) == true && $ args [ 0 ] !== 'X-Magento-Tags' ) { return $ proceed ( ... $ args ) ; } $ args [ 1 ] = $ this -> cacheTags -> convertCacheTags ( str_replace ( ',' , ' ' , $ args [ 1 ] ) ) ; $ tagsSize = $ this -> config -> getXMagentoTagsSize ( ) ; if ( strlen ( $ args [ 1 ] ) > $ tagsSize ) { $ trimmedArgs = substr ( $ args [ 1 ] , 0 , $ tagsSize ) ; $ args [ 1 ] = substr ( $ trimmedArgs , 0 , strrpos ( $ trimmedArgs , ' ' , - 1 ) ) ; } return $ proceed ( ... $ args ) ; }
12402	public function update ( $ id , $ document = null ) { return Parser :: update ( $ id , $ document , $ this -> connection ) ; }
9352	public function cofactor ( ) { $ c = new self ( $ this -> size -> rows , $ this -> size -> cols ) ; for ( $ m = 0 ; $ m < $ this -> size -> rows ; $ m ++ ) { $ arr_row = array ( ) ; for ( $ n = 0 ; $ n < $ this -> size -> cols ; $ n ++ ) { if ( $ this -> size -> cols == 2 ) { $ arr_row [ ] = pow ( - 1 , $ m + $ n ) * $ this -> subMatrix ( $ m , $ n ) -> get ( 0 , 0 ) ; } else { $ arr_row [ ] = pow ( - 1 , $ m + $ n ) * $ this -> subMatrix ( $ m , $ n ) -> det ( ) ; } } $ c -> addRow ( $ arr_row ) ; } return $ c ; }
7165	private function buildDiscountLine ( Model \ SaleAdjustmentInterface $ adjustment , $ level = 0 ) { if ( Model \ AdjustmentTypes :: TYPE_DISCOUNT !== $ adjustment -> getType ( ) ) { throw new InvalidArgumentException ( "Unexpected adjustment type." ) ; } $ lineNumber = $ this -> lineNumber ++ ; $ view = new LineView ( 'adjustment_' . ( $ lineNumber - 1 ) , 'adjustment_' . $ adjustment -> getId ( ) , $ lineNumber , $ level ) ; if ( empty ( $ designation = $ adjustment -> getDesignation ( ) ) ) { $ designation = 'Discount ' ; if ( $ adjustment -> getMode ( ) === Model \ AdjustmentModes :: MODE_PERCENT ) { $ designation .= $ this -> formatter -> percent ( $ adjustment -> getAmount ( ) ) ; } } $ result = $ adjustment -> getResult ( ) ; $ view -> setDesignation ( $ designation ) -> setBase ( $ this -> formatter -> currency ( $ result -> getBase ( ) ) ) -> setTaxAmount ( $ this -> formatter -> currency ( $ result -> getTax ( ) ) ) -> setTotal ( $ this -> formatter -> currency ( $ result -> getTotal ( ) ) ) ; foreach ( $ this -> types as $ type ) { $ type -> buildAdjustmentView ( $ adjustment , $ view , $ this -> options ) ; } return $ view ; }
3930	private function buildProperty ( PropertiesDefinitionInterface $ definition , IAttribute $ attribute , array $ propInfo ) { if ( ! $ attribute ) { return ; } $ property = $ this -> getOrCreateProperty ( $ definition , $ attribute -> getColName ( ) ) ; $ this -> setLabel ( $ property , $ propInfo , $ attribute ) ; $ this -> setDescription ( $ property , $ propInfo ) ; $ this -> setDefaultValue ( $ property , $ propInfo ) ; $ this -> setExcluded ( $ property , $ propInfo ) ; $ this -> setSearchable ( $ property , $ propInfo ) ; $ this -> setFilterable ( $ property , $ propInfo ) ; $ this -> setWidgetType ( $ property , $ propInfo ) ; $ this -> setOptions ( $ property , $ propInfo ) ; $ this -> setExplanation ( $ property , $ propInfo ) ; $ this -> setEval ( $ property , $ propInfo , ( $ attribute instanceof ITranslated ) ) ; $ this -> setEmptyValue ( $ property , $ propInfo ) ; }
4993	public function getActiveFormActual ( $ setDefault = true ) { $ key = null ; if ( ! empty ( $ this -> activeForms ) ) { $ key = $ this -> activeForms [ 0 ] ; } if ( ! isset ( $ key ) && $ setDefault ) { $ formsAvailable = array_keys ( $ this -> forms ) ; $ key = array_shift ( $ formsAvailable ) ; } return $ key ; }
4447	public function fromWorker ( string $ worker , string $ subTimeInterval = '' ) : array { try { $ now = new \ DateTime ( ) ; $ interval = date_interval_create_from_date_string ( $ subTimeInterval ) ; $ timestamp = $ now -> sub ( $ interval ) -> getTimestamp ( ) ; } catch ( \ Exception $ e ) { $ timestamp = - 1 ; } if ( $ subTimeInterval === '' || $ timestamp === - 1 ) { $ jids = json_decode ( $ this -> client -> workerJobs ( $ worker ) , true ) ? : [ ] ; } else { $ jids = json_decode ( $ this -> client -> workerJobs ( $ worker , $ timestamp ) , true ) ? : [ ] ; } return $ this -> multiget ( $ jids ) ; }
4098	public function config ( $ key , $ value = null ) { if ( is_array ( $ key ) ) $ this -> config = $ key + $ this -> config ; else { if ( $ value !== null ) $ this -> config [ $ key ] = $ value ; if ( ! isset ( $ this -> config [ $ key ] ) ) throw new \ Exception ( "Configuration key `type` is not set" ) ; return $ this -> config [ $ key ] ; } }
1650	public function getLngs ( ) : array { $ lngs = [ ] ; foreach ( $ this -> points as $ point ) { $ lngs [ ] = $ point -> getLng ( ) ; } return $ lngs ; }
12579	public function previewImageByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_IMAGE , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
10488	public function run ( \ de \ codenamephp \ platform \ cli \ command \ iCommand $ command ) { if ( $ this -> getDirectory ( ) !== '' && is_dir ( $ this -> getDirectory ( ) ) ) { $ currentDir = getcwd ( ) ; chdir ( $ this -> getDirectory ( ) ) ; } $ returnValue = $ this -> getActualPassthru ( ) -> run ( $ command ) ; if ( isset ( $ currentDir ) ) { chdir ( $ currentDir ) ; } return $ returnValue ; }
5054	public function init ( ) { $ this -> setLabel ( 'general settings' ) ; $ this -> add ( array ( 'type' => 'Core\Form\Element\Select' , 'name' => 'language' , 'options' => array ( 'label' => 'choose your language' , 'value_options' => array ( 'en' => 'English' , 'fr' => 'French' , 'de' => 'German' , 'it' => 'Italian' , 'po' => 'Polish' , 'ru' => 'Russian' , 'tr' => 'Turkish' , 'es' => 'Spanish' , ) , 'description' => 'defines the languages of this frontend.' ) , ) ) ; $ timezones = array_merge ( \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: AFRICA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: AMERICA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: ASIA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: ATLANTIC ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: AUSTRALIA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: EUROPE ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: INDIAN ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: PACIFIC ) ) ; $ this -> add ( array ( 'type' => 'Core\Form\Element\Select' , 'name' => 'timezone' , 'options' => array ( 'label' => 'choose your timzone' , 'value_options' => $ timezones , 'description' => 'defines your local timezone.' ) , ) ) ; }
11011	public function getHeaderValue ( ) : ? string { $ headerValue = [ ] ; foreach ( $ this -> tags as $ name => $ tagValue ) { if ( is_array ( $ tagValue ) && ! empty ( $ tagValue ) ) { $ headerValue [ ] = $ name . ' ' . implode ( ' ' , $ tagValue ) . ';' ; } elseif ( is_string ( $ tagValue ) && ! empty ( $ tagValue ) ) { $ headerValue [ ] = $ name . ' ' . $ tagValue . ';' ; } elseif ( is_bool ( $ tagValue ) && $ tagValue ) { $ headerValue [ ] = $ name . ';' ; } } return $ headerValue ? implode ( ' ' , $ headerValue ) : null ; }
10750	protected function sendVerb ( string $ verb , Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { $ send = array_merge ( [ ] , $ extra ) ; $ send [ 'success' ] = true ; $ send [ 'message' ] = "Objects $verb successfully" ; $ send [ 'objects' ] = array_map ( function ( $ id ) use ( $ type ) { return [ 'type' => $ type , 'id' => $ id ] ; } , $ ids ) ; return $ this -> sendJson ( $ response , $ send ) ; }
7825	protected function getTotalWidth ( ) { $ borders = ( static :: BORDER_WIDTH + static :: MIN_SPACE_FROM_BORDER_X ) * 2 ; if ( empty ( $ this -> pipes ) ) { return $ borders + $ this -> getCoreLength ( ) ; } $ borders *= count ( $ this -> pipes ) ; $ name = ( $ this -> getLongestPipeLength ( ) + static :: SPACE_FROM_ARROW ) * 2 ; return $ borders + $ name + static :: ARROW_WIDTH ; }
790	public function getErrorSummary ( $ showAllErrors ) { $ lines = [ ] ; $ errors = $ showAllErrors ? $ this -> getErrors ( ) : $ this -> getFirstErrors ( ) ; foreach ( $ errors as $ es ) { $ lines = array_merge ( ( array ) $ es , $ lines ) ; } return $ lines ; }
9623	public function getConnectionConfig ( $ connection = null ) { if ( $ connection === null ) { $ connection = $ this -> defaultConnection ; } $ config = $ this -> config -> get ( "database.connections.$connection" ) ; if ( ! $ config ) { if ( ! is_string ( $ connection ) ) { $ connection = gettype ( $ connection ) ; } throw new \ InvalidArgumentException ( "No config found for connection: $connection" ) ; } return $ config ; }
4389	public function repay ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; if ( ( $ cfg = $ this -> getCustomerData ( $ base -> getCustomerId ( ) , 'repay' ) ) === null ) { $ msg = sprintf ( 'No reoccurring payment data available for customer ID "%1$s"' , $ base -> getCustomerId ( ) ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( $ msg ) ; } if ( ! isset ( $ cfg [ 'token' ] ) ) { $ msg = sprintf ( 'No payment token available for customer ID "%1$s"' , $ base -> getCustomerId ( ) ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( $ msg ) ; } $ data = array ( 'transactionId' => $ order -> getId ( ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'cardReference' => $ cfg [ 'token' ] , 'paymentPage' => false , ) ; if ( isset ( $ cfg [ 'month' ] ) && isset ( $ cfg [ 'year' ] ) ) { $ data [ 'card' ] = new \ Omnipay \ Common \ CreditCard ( [ 'expiryMonth' => $ cfg [ 'month' ] , 'expiryYear' => $ cfg [ 'year' ] , ] ) ; } $ response = $ this -> getXmlProvider ( ) -> purchase ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ this -> saveTransationRef ( $ base , $ response -> getTransactionReference ( ) ) ; $ order -> setPaymentStatus ( \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_RECEIVED ) ; $ this -> saveOrder ( $ order ) ; } else { $ msg = ( method_exists ( $ response , 'getMessage' ) ? $ response -> getMessage ( ) : '' ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( sprintf ( 'Token based payment failed: %1$s' , $ msg ) ) ; } }
4286	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( $ method === 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; } elseif ( $ method == 'assert' ) { \ array_unshift ( $ args , false ) ; } elseif ( \ in_array ( $ method , array ( 'count' , 'time' ) ) ) { $ method = 'log' ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ method = 'log' ; if ( \ is_array ( $ args [ 0 ] ) ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ) ; } elseif ( $ meta [ 'caption' ] ) { \ array_unshift ( $ args , $ meta [ 'caption' ] ) ; } } elseif ( $ method === 'trace' ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ) ; } if ( ! \ in_array ( $ method , $ this -> consoleMethods ) ) { $ method = 'log' ; } foreach ( $ args as $ i => $ arg ) { $ args [ $ i ] = $ this -> dump ( $ arg ) ; } $ this -> json [ 'rows' ] [ ] = array ( $ args , isset ( $ meta [ 'file' ] ) ? $ meta [ 'file' ] . ': ' . $ meta [ 'line' ] : null , $ method === 'log' ? '' : $ method , ) ; }
2209	public function fetchRow ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = array_values ( $ this -> resultSet [ ++ $ this -> intIndex ] ) ; return $ this -> arrCache ; }
10896	public function setHost ( $ host ) { foreach ( $ this -> uris as $ name => $ uri ) { $ this -> add ( $ name , $ uri -> withHost ( $ host ) ) ; } }
1964	public static function decodeUrl ( $ strUrl ) { if ( $ strUrl == '' ) { return '' ; } if ( $ strUrl == '#' || strncmp ( $ strUrl , '{{' , 2 ) === 0 ) { return $ strUrl ; } if ( strncmp ( $ strUrl , 'mailto:' , 7 ) === 0 ) { return static :: decodeEmail ( $ strUrl ) ; } $ arrUrl = parse_url ( $ strUrl ) ; if ( ! isset ( $ arrUrl [ 'scheme' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Expected a FQDN, got "%s"' , $ strUrl ) ) ; } if ( isset ( $ arrUrl [ 'scheme' ] ) ) { $ arrUrl [ 'scheme' ] .= ( ( substr ( $ strUrl , \ strlen ( $ arrUrl [ 'scheme' ] ) , 3 ) == '://' ) ? '://' : ':' ) ; } if ( isset ( $ arrUrl [ 'user' ] ) ) { $ arrUrl [ 'user' ] .= isset ( $ arrUrl [ 'pass' ] ) ? ':' : '@' ; } if ( isset ( $ arrUrl [ 'pass' ] ) ) { $ arrUrl [ 'pass' ] .= '@' ; } if ( isset ( $ arrUrl [ 'host' ] ) ) { $ arrUrl [ 'host' ] = static :: decode ( $ arrUrl [ 'host' ] ) ; } if ( isset ( $ arrUrl [ 'port' ] ) ) { $ arrUrl [ 'port' ] = ':' . $ arrUrl [ 'port' ] ; } if ( isset ( $ arrUrl [ 'query' ] ) ) { $ arrUrl [ 'query' ] = '?' . $ arrUrl [ 'query' ] ; } if ( isset ( $ arrUrl [ 'fragment' ] ) ) { $ arrUrl [ 'fragment' ] = '#' . $ arrUrl [ 'fragment' ] ; } $ strReturn = '' ; foreach ( array ( 'scheme' , 'user' , 'pass' , 'host' , 'port' , 'path' , 'query' , 'fragment' ) as $ key ) { if ( isset ( $ arrUrl [ $ key ] ) ) { $ strReturn .= $ arrUrl [ $ key ] ; } } return $ strReturn ; }
4198	public function onEnd ( Event $ event ) { $ obj = $ event -> getSubject ( ) ; if ( $ obj instanceof \ DOMNodeList ) { $ event [ 'properties' ] [ 'length' ] = \ array_merge ( static :: $ basePropInfo , array ( 'type' => 'integer' , 'value' => $ obj -> length , ) ) ; } elseif ( $ obj instanceof \ Exception ) { if ( isset ( $ event [ 'properties' ] [ 'xdebug_message' ] ) ) { $ event [ 'properties' ] [ 'xdebug_message' ] [ 'isExcluded' ] = true ; } } elseif ( $ obj instanceof \ mysqli && ! $ event [ 'collectPropertyValues' ] ) { $ propsAlwaysAvail = array ( 'client_info' , 'client_version' , 'connect_errno' , 'connect_error' , 'errno' , 'error' , 'stat' ) ; $ reflectionObject = $ event [ 'reflector' ] ; foreach ( $ propsAlwaysAvail as $ name ) { $ reflectionProperty = $ reflectionObject -> getProperty ( $ name ) ; $ event [ 'properties' ] [ $ name ] [ 'value' ] = $ reflectionProperty -> getValue ( $ obj ) ; } } }
11630	private function getTransactions ( $ turnover , $ dsEnd ) { $ dateApplied = $ this -> hlpPeriod -> getTimestampUpTo ( $ dsEnd ) ; $ result = $ this -> aPrepareTrans -> exec ( $ turnover , $ dateApplied ) ; return $ result ; }
11595	private function getPageId ( ) { if ( preg_match ( '/\/page\/(\w+)$/' , $ this -> name , $ matches ) ) { $ id = $ matches [ 1 ] ; } else { $ id = $ this -> environment -> getRequestHelper ( ) -> getIdentifierParam ( 'id' , null , true ) ; } return $ id ; }
10031	function synchronizeContacts ( $ contacts , $ permission = null , $ syncMode = null , $ useExternalId = false , $ ignoreInvalidContacts = false , $ reimportUnsubscribedContacts = true , $ overridePermission = true , $ updateOnly = false , $ preferMaileonId = false ) { $ queryParameters = array ( 'permission' => ( $ permission == null ) ? 1 : $ permission -> getCode ( ) , 'sync_mode' => ( $ syncMode == null ) ? 2 : $ syncMode -> getCode ( ) , 'use_external_id' => ( $ useExternalId == TRUE ) ? "true" : "false" , 'ignore_invalid_contacts' => ( $ ignoreInvalidContacts == TRUE ) ? "true" : "false" , 'reimport_unsubscribed_contacts' => ( $ reimportUnsubscribedContacts == TRUE ) ? "true" : "false" , 'override_permission' => ( $ overridePermission == TRUE ) ? "true" : "false" , 'update_only' => ( $ updateOnly == TRUE ) ? "true" : "false" , 'prefer_maileon_id' => ( $ preferMaileonId == TRUE ) ? "true" : "false" ) ; $ cleanedContacts = new Contacts ( ) ; foreach ( $ contacts as $ contact ) { $ cleanedContact = new Contact ( $ contact -> id , $ contact -> email , null , $ contact -> external_id , null , $ contact -> standard_fields , $ contact -> custom_fields ) ; $ cleanedContacts -> addContact ( $ cleanedContact ) ; } return $ this -> post ( "contacts" , $ cleanedContacts -> toXMLString ( ) , $ queryParameters ) ; }
9395	public function buildCommand ( ) { if ( $ this -> escape !== false ) { $ this -> options = $ this -> escape ( $ this -> options ) ; } if ( $ this -> builder !== null ) { $ this -> command = $ this -> builder -> build ( $ this -> options ) ; } return $ this ; }
9516	public function settings ( $ name = null , $ value = null ) { switch ( func_num_args ( ) ) { case 0 : return $ this -> info ( 'settings' ) ; break ; case 1 : return $ this -> info ( 'settings' , func_get_arg ( 0 ) ) ; break ; case 2 : $ update = false ; list ( $ name , $ value ) = func_get_args ( ) ; $ current = $ this -> info ( 'settings' , $ name ) ; if ( is_null ( $ value ) ) { if ( ! is_null ( $ current ) ) { unset ( $ this -> info [ 'settings' ] [ $ name ] ) ; $ update = true ; } } elseif ( $ current !== $ value ) { $ this -> info [ 'settings' ] [ $ name ] = $ value ; $ update = true ; } if ( $ update ) { $ this -> exec ( 'UPDATE config SET settings = ?' , serialize ( $ this -> info [ 'settings' ] ) ) ; } break ; } }
1693	protected function convertHexColor ( $ color , $ blnWriteToFile = false , $ vars = array ( ) ) { if ( strncmp ( $ color , '$' , 1 ) === 0 ) { if ( ! $ blnWriteToFile ) { return array ( $ color ) ; } else { $ color = str_replace ( array_keys ( $ vars ) , $ vars , $ color ) ; } } $ rgb = array ( ) ; if ( \ strlen ( $ color ) == 6 ) { $ dec = hexdec ( $ color ) ; $ rgb [ 'red' ] = 0xFF & ( $ dec >> 0x10 ) ; $ rgb [ 'green' ] = 0xFF & ( $ dec >> 0x8 ) ; $ rgb [ 'blue' ] = 0xFF & $ dec ; } elseif ( \ strlen ( $ color ) == 3 ) { $ rgb [ 'red' ] = hexdec ( str_repeat ( substr ( $ color , 0 , 1 ) , 2 ) ) ; $ rgb [ 'green' ] = hexdec ( str_repeat ( substr ( $ color , 1 , 1 ) , 2 ) ) ; $ rgb [ 'blue' ] = hexdec ( str_repeat ( substr ( $ color , 2 , 1 ) , 2 ) ) ; } return $ rgb ; }
12758	public static function getNew ( ) { $ class = new MediaLink ; $ medialink = get_class_vars ( get_class ( $ class ) ) ; foreach ( $ medialink as $ name => $ default ) : $ class :: set ( $ name , null ) ; $ class :: set ( "objectType" , "medialink" ) ; endforeach ; return $ class ; }
6342	final public static function valueOf ( $ name ) : self { $ className = static :: class ; Preconditions :: checkArgument ( array_key_exists ( $ className , self :: $ cache ) && array_key_exists ( $ name , self :: $ cache [ $ className ] ) , "The enum '%s' type has no constant with name '%s'" , $ className , $ name ) ; return self :: $ cache [ $ className ] [ $ name ] ; }
6705	public function getWriterFactory ( ) { if ( ! $ this -> writerFactory ) { $ xmlFormatter = new Xml ( ) ; $ jsonFormatter = new Json ( ) ; $ this -> writerFactory = new WriterFactory ( [ 'xml' => $ xmlFormatter , 'text/xml' => $ xmlFormatter , 'application/xml' => $ xmlFormatter , 'json' => $ jsonFormatter , 'application/json' => $ jsonFormatter , ] ) ; } return $ this -> writerFactory ; }
11064	public function upperFirst ( ) { $ this -> value = mb_strtoupper ( mb_substr ( $ this -> value , 0 , 1 , 'UTF-8' ) , 'UTF-8' ) . mb_substr ( $ this -> value , 1 , null , 'UTF-8' ) ; return $ this ; }
11984	public function boot ( ) { if ( $ this -> booted ) { return $ this ; } if ( extension_loaded ( 'pinba' ) ) { ini_set ( 'pinba.enabled' , false ) ; } if ( extension_loaded ( 'newrelic' ) ) { ini_set ( 'newrelic.enabled' , false ) ; } if ( ! empty ( $ this -> settings [ 'timezone' ] ) ) { date_default_timezone_set ( $ this -> settings [ 'timezone' ] ) ; } $ this -> booted = true ; return $ this ; }
10510	public function detach ( \ SplObserver $ observer ) { foreach ( $ this -> _observers as $ observerItem ) { if ( $ observerItem -> observer === $ observer ) { $ this -> _observers -> detach ( $ observerItem ) ; } } }
1154	public function makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'makeReplacements' , [ $ message , $ attribute , $ rule , $ parameters ] ) ; }
12914	protected function getWhereAsArray ( ) { $ filters = [ ] ; if ( ! empty ( $ this -> filters ) ) { $ filters = $ this -> filters ; } if ( ! $ this -> allowDeleted ) { $ filters [ ] = "(`" . $ this -> table . "`.deleted = 0 OR `" . $ this -> table . "`.deleted IS NULL)" ; } if ( ! empty ( $ this -> joins ) ) { foreach ( $ this -> joins as $ join ) { $ manager = $ join [ 'manager' ] ; $ filters = array_merge ( $ filters , $ manager -> getWhereAsArray ( ) ) ; } } return $ filters ; }
9442	public function getManyWithoutReplacement ( $ n ) { if ( ! is_integer ( $ n ) || $ n < 2 ) { throw new \ InvalidArgumentException ( 'You must take 2 or more items in this case.' ) ; } if ( $ this -> range -> as_integer ) { $ arr_range = range ( $ this -> range -> min , $ this -> range -> max ) ; $ max_takable = count ( $ arr_range ) ; shuffle ( $ arr_range ) ; if ( $ n > $ max_takable ) { throw new \ OutOfRangeException ( sprintf ( 'Cannot take without replacement more than available items into range [%d;%d]' , $ this -> range -> min , $ this -> range -> max ) ) ; } elseif ( $ n == $ max_takable ) { return array_values ( $ arr_range ) ; } else { return array_slice ( $ arr_range , 0 , $ n ) ; } } else { $ arr_out = array ( ) ; while ( count ( $ arr_out ) < $ n ) { $ r = $ this -> get ( ) ; if ( ! in_array ( $ r , $ arr_out ) ) { $ arr_out [ ] = $ r ; } } return $ arr_out ; } }
6461	public function shouldSeeThumbnail ( ) { $ thumb = false ; foreach ( [ '.upload-preview' , '.media-thumbnail img' , '.image-preview img' ] as $ selector ) { if ( $ thumb ) { break ; } $ thumb = $ this -> findByCss ( $ selector ) ; } if ( null === $ thumb ) { throw new \ Exception ( 'An expected image tag was not found.' ) ; } $ file = explode ( '?' , $ thumb -> getAttribute ( 'src' ) ) ; $ file = reset ( $ file ) ; $ curl = new CurlService ( ) ; list ( , $ info ) = $ curl -> execute ( 'GET' , $ file ) ; if ( empty ( $ info ) || strpos ( $ info [ 'content_type' ] , 'image/' ) === false ) { throw new FileNotFoundException ( sprintf ( '%s did not return an image' , $ file ) ) ; } }
6874	private function findOrCreateItem ( ShipmentInterface $ shipment , SaleItemInterface $ saleItem , $ expected , $ available = null ) { $ item = null ; if ( 0 >= $ expected ) { return $ item ; } foreach ( $ shipment -> getItems ( ) as $ i ) { if ( $ i -> getSaleItem ( ) === $ saleItem ) { $ item = $ i ; break ; } } if ( null === $ item ) { $ item = $ this -> factory -> createItemForShipment ( $ shipment ) ; $ item -> setShipment ( $ shipment ) ; $ item -> setSaleItem ( $ saleItem ) ; } $ item -> setExpected ( $ expected ) ; if ( $ shipment -> isReturn ( ) ) { $ item -> setAvailable ( $ expected ) ; } else { if ( null === $ available ) { $ available = $ this -> calculator -> calculateAvailableQuantity ( $ saleItem , $ shipment ) ; } $ item -> setAvailable ( $ available ) ; if ( null === $ shipment -> getId ( ) ) { $ item -> setQuantity ( min ( $ expected , $ available ) ) ; } } return $ item ; }
3012	public function unfollow ( $ blogName ) { $ options = array ( 'url' => $ this -> blogUrl ( $ blogName ) ) ; return $ this -> postRequest ( 'v2/user/unfollow' , $ options , false ) ; }
8333	private function getSelectSql ( ) { if ( self :: LOCK_TRANSACTIONAL === $ this -> lockMode ) { $ this -> beginTransaction ( ) ; switch ( $ this -> driver ) { case 'mysql' : case 'oci' : case 'pgsql' : return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WHERE $this->idCol = :id FOR UPDATE" ; case 'sqlsrv' : return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WITH (UPDLOCK, ROWLOCK) WHERE $this->idCol = :id" ; case 'sqlite' : break ; default : throw new \ DomainException ( sprintf ( 'Transactional locks are currently not implemented for PDO driver "%s".' , $ this -> driver ) ) ; } } return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WHERE $this->idCol = :id" ; }
9756	function above ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , greaterThan ( $ value ) ) ; }
7129	public function hasNotifications ( $ type = null ) { if ( null !== $ type ) { NotificationTypes :: isValidType ( $ type ) ; return $ this -> getNotifications ( $ type ) -> count ( ) ; } return 0 < $ this -> notifications -> count ( ) ; }
71	protected function filterPackageMap ( array $ packageMap , PackageInterface $ mainPackage ) { $ packages = array ( ) ; $ include = array ( ) ; foreach ( $ packageMap as $ item ) { $ package = $ item [ 0 ] ; $ name = $ package -> getName ( ) ; $ packages [ $ name ] = $ package ; } $ add = function ( PackageInterface $ package ) use ( & $ add , $ packages , & $ include ) { foreach ( $ package -> getRequires ( ) as $ link ) { $ target = $ link -> getTarget ( ) ; if ( ! isset ( $ include [ $ target ] ) ) { $ include [ $ target ] = true ; if ( isset ( $ packages [ $ target ] ) ) { $ add ( $ packages [ $ target ] ) ; } } } } ; $ add ( $ mainPackage ) ; return array_filter ( $ packageMap , function ( $ item ) use ( $ include ) { $ package = $ item [ 0 ] ; foreach ( $ package -> getNames ( ) as $ name ) { if ( isset ( $ include [ $ name ] ) ) { return true ; } } return false ; } ) ; }
3751	public function isUniqueValue ( $ strField , $ varNew , $ intId = null ) { $ attribute = $ this -> getMetaModel ( ) -> getAttribute ( $ strField ) ; if ( $ attribute ) { $ matchingIds = $ this -> prepareFilter ( $ this -> getEmptyConfig ( ) -> setFilter ( array ( array ( 'operation' => '=' , 'property' => $ attribute -> getColName ( ) , 'value' => $ varNew ) ) ) ) -> getMatchingIds ( ) ; return ( count ( $ matchingIds ) == 0 ) || ( $ matchingIds == array ( $ intId ) ) ; } return false ; }
5672	protected function describeFloatDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } return sprintf ( 'because [%s] differs from [%s] by %s' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) , abs ( $ first - $ second ) ) ; }
4861	public function pushLazy ( $ service , $ payload = null , array $ options = [ ] ) { $ manager = $ this -> getJobPluginManager ( ) ; $ serviceOptions = [ ] ; if ( is_array ( $ service ) ) { $ serviceOptions = $ service [ 'options' ] ?? $ service [ 1 ] ?? [ ] ; $ service = $ service [ 'name' ] ?? $ service [ 0 ] ?? null ; } if ( ! $ manager -> has ( $ service ) && ! class_exists ( $ service ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Service name "%s" is not a known job service or existent class' , $ service ) ) ; } $ lazyOptions = [ 'name' => $ service , 'options' => $ serviceOptions , 'content' => $ payload , ] ; $ job = $ this -> getJobPluginManager ( ) -> build ( 'lazy' , $ lazyOptions ) ; $ this -> push ( $ job , $ options ) ; }
8601	private function _convertDeleteSubscription ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'DeleteSubscription' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetNotificationType ( ) ) { $ parameters [ 'NotificationType' ] = $ request -> getNotificationType ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationDeleteSubscriptionInput = $ request -> getDestination ( ) ; foreach ( $ DestinationDeleteSubscriptionInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
11014	public function set ( $ value ) { if ( $ value !== null ) { $ value = $ this -> check ( $ value ) ; } if ( $ value !== $ this -> value ) { $ this -> value = $ value ; $ this -> notify ( ) ; } return $ this ; }
4359	public static function addSpecial ( $ special ) { $ special = ( array ) $ special ; foreach ( $ special as $ char ) { self :: $ special [ ] = $ char ; } }
2924	public function formatSetterLine ( $ key , $ value = null , $ comment = null , $ export = false ) { $ forceQuotes = ( strlen ( $ comment ) > 0 && strlen ( trim ( $ value ) ) == 0 ) ; $ value = $ this -> formatValue ( $ value , $ forceQuotes ) ; $ key = $ this -> formatKey ( $ key ) ; $ comment = $ this -> formatComment ( $ comment ) ; $ export = $ export ? 'export ' : '' ; $ line = "{$export}{$key}={$value}{$comment}" ; return $ line ; }
11262	public static function main ( $ argv , ContainerInterface $ container = null ) { $ output = self :: cyanLine ( $ argv ) ; $ app = new Application ( '' ) ; $ app -> add ( new MigrateMakeCommand ( ) ) ; $ app -> add ( new MigrateUpCommand ( $ container ) ) ; $ app -> add ( new MigrateDownCommand ( ) ) ; $ app -> add ( new MigrateResetCommand ( ) ) ; $ app -> add ( new MigrateStatusCommand ( ) ) ; $ app -> add ( new MigrateRefreshCommand ( ) ) ; $ app -> add ( new MigrateFreshCommand ( $ container ) ) ; $ app -> add ( new MigrateDropCommand ( ) ) ; $ app -> add ( new SeedRunCommand ( $ container ) ) ; $ app -> add ( new SeedMakeCommand ( ) ) ; $ app -> add ( new BinMakeCommand ( ) ) ; $ app -> run ( null , $ output ) ; }
1604	public function onException ( ExceptionEvent $ event ) { $ exception = $ event -> exception ; $ craft = \ Craft :: $ app ; if ( ! ( $ exception instanceof HttpException ) || $ exception -> statusCode !== 404 ) return ; $ path = $ craft -> request -> getFullPath ( ) ; $ query = $ craft -> request -> getQueryStringWithoutPath ( ) ; if ( $ query ) $ path .= '?' . $ query ; if ( $ redirect = $ this -> findRedirectByPath ( $ path ) ) { $ event -> handled = true ; $ craft -> response -> redirect ( $ redirect [ 'to' ] , $ redirect [ 'type' ] ) -> send ( ) ; $ craft -> end ( ) ; } }
3726	public static function createFromQueryBuilder ( QueryBuilder $ builder , $ columnName = 'id' ) { return new self ( $ builder -> getSQL ( ) , $ builder -> getParameters ( ) , $ columnName , $ builder -> getConnection ( ) , $ builder -> getParameterTypes ( ) ) ; }
9051	protected function getMessage ( $ level , $ message , array $ context = array ( ) ) : MemoryStream { self :: checkLevel ( $ level ) ; $ ms = new MemoryStream ( ) ; $ ms -> write ( strftime ( "%Y-%m-%d %H:%M:%S" , time ( ) ) ) ; $ ms -> interpolate ( "\t[{level}]: " , array ( 'level' => sprintf ( "%6.6s" , $ level ) ) ) ; $ ms -> interpolate ( $ message , $ context ) ; $ ms -> write ( "\n" ) ; return $ ms ; }
6187	public function assign ( $ name , $ value ) { if ( ! isset ( $ this -> view ) ) { throw new ViewException ( 'Please Define view engine in app/View.php' , 500 ) ; } return $ this -> view -> assign ( $ name , $ value ) ; }
10157	private function readBoolErr ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ row = self :: getUInt2d ( $ recordData , 0 ) ; $ column = self :: getUInt2d ( $ recordData , 2 ) ; $ columnString = Coordinate :: stringFromColumnIndex ( $ column + 1 ) ; if ( ( $ this -> getReadFilter ( ) !== null ) && $ this -> getReadFilter ( ) -> readCell ( $ columnString , $ row + 1 , $ this -> phpSheet -> getTitle ( ) ) ) { $ xfIndex = self :: getUInt2d ( $ recordData , 4 ) ; $ boolErr = ord ( $ recordData [ 6 ] ) ; $ isError = ord ( $ recordData [ 7 ] ) ; $ cell = $ this -> phpSheet -> getCell ( $ columnString . ( $ row + 1 ) ) ; switch ( $ isError ) { case 0 : $ value = ( bool ) $ boolErr ; $ cell -> setValueExplicit ( $ value , DataType :: TYPE_BOOL ) ; break ; case 1 : $ value = Xls \ ErrorCode :: lookup ( $ boolErr ) ; $ cell -> setValueExplicit ( $ value , DataType :: TYPE_ERROR ) ; break ; } if ( ! $ this -> readDataOnly ) { $ cell -> setXfIndex ( $ this -> mapCellXfIndex [ $ xfIndex ] ) ; } } }
7982	public function addDeleteTask ( $ sessionId ) { return json_decode ( self :: getClient ( ) -> createPcaDeleteTask ( $ this -> pp , $ this -> sn , $ sessionId ) ) ; }
2565	public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ queryAllErrorCodes = "//m:generalErrorGroup//m:errorNumber/m:errorDetails/m:errorCode" ; $ queryAllErrorMsg = "//m:generalErrorGroup/m:genrealErrorText/m:freeText" ; $ errorCodeNodeList = $ domXpath -> query ( $ queryAllErrorCodes ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( $ queryAllErrorMsg ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) ) ; } return $ analyzeResponse ; }
3972	public function decodeAttributeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ value = $ event -> getValue ( ) ; if ( ! ( $ metaModel && $ value ) ) { return ; } $ attribute = $ metaModel -> getAttributeById ( $ value ) ; if ( $ attribute ) { $ event -> setValue ( $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ) ; } }
3971	public function getAttributeOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ result = [ ] ; $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ conditionType = $ event -> getModel ( ) -> getProperty ( 'type' ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( ! $ this -> conditionFactory -> supportsAttribute ( $ conditionType , $ attribute -> get ( 'type' ) ) ) { continue ; } $ typeName = $ attribute -> get ( 'type' ) ; $ strSelectVal = $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ; $ result [ $ strSelectVal ] = $ attribute -> getName ( ) . ' [' . $ typeName . ']' ; } $ event -> setOptions ( $ result ) ; }
7988	public function deleteSnapshot ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> delete ( 'vps/' . $ domain . '/snapshot' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r ; }
8355	private function buildModel ( string $ modelName , array $ modelDefinition ) { $ mapping = Mapping :: get ( $ this -> mapping ) ; $ definition = $ this -> getDefinition ( ) ; $ database = GlobalDatabase :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ tableName = null ; if ( isset ( $ modelDefinition [ 'name' ] ) === true ) { $ tableName = $ modelDefinition [ 'name' ] ; } else { $ tableName = Helper :: codifyName ( $ this -> mapping ) . '_' . Helper :: codifyName ( $ modelName ) ; } if ( isset ( $ modelDefinition [ 'fields' ] ) === false ) { throw new InvalidSchemaDefinition ( 'model "' . $ modelName . '" has no field' ) ; } $ statement = Mutation \ AddTable :: statement ( $ database , $ this -> getDefinition ( ) , $ this -> mapping , $ tableName , $ modelName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } if ( isset ( $ modelDefinition [ 'indexes' ] ) === true ) { foreach ( $ modelDefinition [ 'indexes' ] as $ indexName => $ indexDefinition ) { $ statement = Mutation \ AddIndex :: statement ( $ database , $ modelName , $ tableName , $ modelDefinition , $ indexName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } } } if ( isset ( $ modelDefinition [ 'uniques' ] ) === true ) { foreach ( $ modelDefinition [ 'uniques' ] as $ uniqueName => $ uniqueDefinition ) { $ statement = Mutation \ AddUnique :: statement ( $ database , $ modelName , $ tableName , $ modelDefinition , $ uniqueName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } } } echo $ modelName . ' - Done' . PHP_EOL ; }
4883	public function generatePublicAlias ( $ subject , $ currentAlias = '' ) { $ alias = $ this -> strategyWrapper -> generatePublicAlias ( $ subject , $ currentAlias ) ; if ( $ alias !== null && method_exists ( $ subject , 'getLanguage' ) ) { if ( in_array ( $ subject -> getLanguage ( ) , $ this -> localesToPrefix ) ) { $ alias = sprintf ( '%s%s%s' , $ this -> basePath , $ subject -> getLanguage ( ) , $ alias ) ; } } return $ alias ; }
6571	private function getIdPath ( string $ id ) : string { if ( ! preg_match ( "/^[a-z0-9]$/ui" , $ id ) ) { throw new HandlerException ( sprintf ( "The session id %s is invalid" , $ id ) , $ this ) ; } return $ this -> savePath . "/$id.session" ; }
3704	public function handle ( PreDuplicateModelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ model -> getProviderName ( ) ) ; if ( ! $ metaModel || ! $ metaModel -> hasVariants ( ) ) { return ; } if ( $ model -> getProperty ( 'varbase' ) == 1 ) { $ model -> setProperty ( 'vargroup' , null ) ; } }
1226	private function inside ( array & $ chars , $ delim , $ type ) { $ position = key ( $ chars ) ; $ current = next ( $ chars ) ; $ buffer = '' ; while ( $ current !== $ delim ) { if ( $ current === '\\' ) { $ buffer .= '\\' ; $ current = next ( $ chars ) ; } if ( $ current === false ) { return [ 'type' => self :: T_UNKNOWN , 'value' => $ buffer , 'pos' => $ position ] ; } $ buffer .= $ current ; $ current = next ( $ chars ) ; } next ( $ chars ) ; return [ 'type' => $ type , 'value' => $ buffer , 'pos' => $ position ] ; }
4710	public function detab ( Text $ text , array $ options = array ( ) ) { $ text -> replace ( '/(.*?)\t/' , function ( Text $ whole , Text $ string ) use ( $ options ) { return $ string . str_repeat ( ' ' , $ options [ 'tabWidth' ] - $ string -> getLength ( ) % $ options [ 'tabWidth' ] ) ; } ) ; }
9741	public function isPrintAreaSet ( $ index = 0 ) { if ( $ index == 0 ) { return $ this -> printArea !== null ; } $ printAreas = explode ( ',' , $ this -> printArea ) ; return isset ( $ printAreas [ $ index - 1 ] ) ; }
3844	protected static function upgradeJumpTo ( ) { $ objDB = self :: DB ( ) ; if ( $ objDB -> tableExists ( 'tl_content' , null , true ) && ! $ objDB -> fieldExists ( 'metamodel_jumpTo' , 'tl_content' , true ) ) { TableManipulation :: createColumn ( 'tl_content' , 'metamodel_jumpTo' , 'int(10) unsigned NOT NULL default \'0\'' ) ; if ( $ objDB -> fieldExists ( 'jumpTo' , 'tl_content' , true ) ) { $ objDB -> execute ( 'UPDATE tl_content SET metamodel_jumpTo=jumpTo;' ) ; } } if ( $ objDB -> tableExists ( 'tl_module' , null , true ) && ! $ objDB -> fieldExists ( 'metamodel_jumpTo' , 'tl_module' , true ) ) { TableManipulation :: createColumn ( 'tl_module' , 'metamodel_jumpTo' , 'int(10) unsigned NOT NULL default \'0\'' ) ; if ( $ objDB -> fieldExists ( 'jumpTo' , 'tl_module' , true ) ) { $ objDB -> execute ( 'UPDATE tl_module SET metamodel_jumpTo=jumpTo;' ) ; } } }
10914	public function execute ( ) { try { $ this -> output_buffer_level = ob_get_level ( ) ; ob_start ( ) ; $ response = $ this -> doExecute ( ) ; if ( ( is_object ( $ response ) && ! ( $ response instanceof Response ) ) || ( is_string ( $ response ) && class_exists ( $ response ) ) ) { $ response = $ this -> reflect ( $ response ) ; } if ( $ response instanceof Response ) throw $ response ; throw new HTTPError ( 500 , "App did not produce any response" ) ; } catch ( Response $ response ) { self :: $ logger -> debug ( "Response type {0} returned from controller: {1}" , [ get_class ( $ response ) , $ this -> app ] ) ; throw $ response ; } catch ( Throwable $ e ) { self :: $ logger -> debug ( "While executing controller: {0}" , [ $ this -> app ] ) ; self :: $ logger -> notice ( "Unexpected exception of type {0} thrown while processing request: {1}" , [ get_class ( $ e ) , $ e ] ) ; throw $ e ; } finally { $ this -> logScriptOutput ( ) ; } }
684	public function mergeRules ( array $ rules ) { $ this -> setRules ( ArrayHelper :: merge ( $ this -> getRules ( ) , $ rules ) ) ; return $ this ; }
9285	protected function compileFile ( $ lessPath , $ cssPath ) { $ options = array ( ) ; if ( $ this -> strictImports === true ) $ options [ ] = '--strict-imports' ; if ( $ this -> compression === self :: COMPRESSION_WHITESPACE ) $ options [ ] = '--compress' ; else if ( $ this -> compression === self :: COMPRESSION_YUI ) $ options [ ] = '--yui-compress' ; if ( $ this -> optimizationLevel !== false ) $ options [ ] = '-O' . $ this -> optimizationLevel ; if ( isset ( $ this -> rootPath ) ) $ options [ ] = '--rootpath ' . $ this -> rootPath ; if ( $ this -> relativeUrls === true ) $ options [ ] = '--relative-urls' ; $ nodePath = $ this -> nodePath ? '"' . $ this -> nodePath . '" ' : '' ; $ command = $ nodePath . '"' . $ this -> compilerPath . '" ' . implode ( ' ' , $ options ) . ' "' . $ lessPath . '" "' . $ cssPath . '" 2>&1' ; $ return = 0 ; $ output = array ( ) ; @ exec ( $ command , $ output , $ return ) ; switch ( $ return ) { case 2 : case 1 : $ output = preg_replace ( '/\[[0-9]+m/i' , '' , implode ( "\n" , $ output ) ) ; throw new CException ( 'Failed to compile file "' . $ lessPath . '" using command: ' . $ command . '. The error was: ' . $ output ) ; } }
11204	public function where ( $ key = false , $ desiredValue , $ op = "==" ) { $ collection = $ this -> getIterator ( ) ; $ subset = new Collection ( ) ; foreach ( $ collection as $ prop => $ result ) { $ realValue = $ result ; if ( is_object ( $ result ) ) { $ realValue = $ result -> $ key ; } else if ( is_array ( $ result ) ) { $ realValue = $ result [ $ key ] ; } $ add = false ; if ( $ op == '==' && $ realValue == $ desiredValue ) { $ add = true ; } else if ( $ op == '>=' && $ realValue >= $ desiredValue ) { $ add = true ; } else if ( $ op == '<=' && $ realValue <= $ desiredValue ) { $ add = true ; } else if ( $ op == '>' && $ realValue > $ desiredValue ) { $ add = true ; } else if ( $ op == '<' && $ realValue < $ desiredValue ) { $ add = true ; } else if ( $ op == '===' && $ realValue === $ desiredValue ) { $ add = true ; } else if ( $ op == '!=' && $ realValue != $ desiredValue ) { $ add = true ; } if ( $ add ) { $ subset -> add ( $ result , $ prop ) ; } } return $ subset ; }
12141	public function SignupUser ( $ moniker , $ mailer_id = null ) { $ endpoint = '/user/signup' ; $ postdata = array ( "moniker" => $ moniker , "mailer_id" => $ mailer_id ) ; return $ this -> executePostRequest ( $ endpoint , $ postdata ) ; }
9383	public function getClassName ( $ identifier , $ args = [ ] ) { if ( isset ( $ this -> classes [ $ identifier ] ) ) { return $ args ? vsprintf ( $ this -> classes [ $ identifier ] , $ args ) : $ this -> classes [ $ identifier ] ; } }
11231	public function post ( $ section , $ body = null , array $ headers = [ ] ) { if ( is_array ( $ body ) ) { $ body = array_merge ( $ this -> parameters , $ body , $ this -> defaultParameters ) ; $ body = http_build_query ( $ body ) ; } return $ this -> client -> post ( $ this -> getUrl ( $ section ) , $ headers , $ body ) ; }
5665	private function innerHtml ( $ node ) { $ raw = '' ; if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ raw .= $ child -> value ; } } return $ this -> stripGuards ( $ raw ) ; }
3892	public function getFilterParameterNames ( \ DC_Table $ objDc ) { $ return = array ( ) ; $ filter = $ objDc -> activeRecord -> metamodel_filtering ; if ( ! $ filter ) { return $ return ; } $ collection = $ this -> filterFactory -> createCollection ( $ filter ) ; return $ collection -> getParameterFilterNames ( ) ; }
8522	public function setGlobalSellingRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GlobalSellingRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4225	public function onShutdown ( Event $ event ) { if ( ! $ this -> registered ) { return ; } $ error = $ event [ 'error' ] ? : \ error_get_last ( ) ; if ( ! $ error ) { return ; } if ( \ in_array ( $ error [ 'type' ] , $ this -> errCategories [ 'fatal' ] ) ) { \ error_reporting ( E_ALL | E_STRICT ) ; $ this -> handleError ( $ error [ 'type' ] , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ; } foreach ( $ this -> data [ 'errors' ] as $ error ) { if ( $ error [ 'category' ] === 'fatal' ) { $ event [ 'error' ] = $ error ; break ; } } return ; }
6779	protected function configureAcceptedSale ( SaleInterface $ sale ) { if ( null === $ date = $ sale -> getAcceptedAt ( ) ) { return false ; } $ changed = $ this -> updateExchangeRate ( $ sale ) ; $ changed |= $ this -> updateLocale ( $ sale ) ; return $ changed ; }
8757	public function run ( \ Traversable $ items , callable $ itemCallback ) { $ this -> start ( ) ; foreach ( $ items as $ item ) { call_user_func ( $ itemCallback , $ this , $ item ) ; } return $ this -> finish ( ) ; }
1093	protected function getFreshInstance ( ) { if ( $ this -> areSoftDeletesEnabled ( ) ) return static :: withTrashed ( ) -> find ( $ this -> getKey ( ) ) ; return static :: find ( $ this -> getKey ( ) ) ; }
4120	public static function overrideType ( $ name , $ className ) { if ( ! isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: typeNotFound ( $ name ) ; } self :: $ _typesMap [ $ name ] = $ className ; }
1062	public static function findTypesAddedToUnions ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ typesAddedToUnion = [ ] ; foreach ( $ newTypeMap as $ typeName => $ newType ) { $ oldType = $ oldTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof UnionType ) || ! ( $ newType instanceof UnionType ) ) { continue ; } $ typeNamesInOldUnion = [ ] ; foreach ( $ oldType -> getTypes ( ) as $ type ) { $ typeNamesInOldUnion [ $ type -> name ] = true ; } foreach ( $ newType -> getTypes ( ) as $ type ) { if ( isset ( $ typeNamesInOldUnion [ $ type -> name ] ) ) { continue ; } $ typesAddedToUnion [ ] = [ 'type' => self :: DANGEROUS_CHANGE_TYPE_ADDED_TO_UNION , 'description' => sprintf ( '%s was added to union type %s.' , $ type -> name , $ typeName ) , ] ; } } return $ typesAddedToUnion ; }
445	public function getBehavior ( $ name ) { $ this -> ensureBehaviors ( ) ; return isset ( $ this -> _behaviors [ $ name ] ) ? $ this -> _behaviors [ $ name ] : null ; }
12885	public function getReverseKeyTranslation ( $ localObject ) { $ key = is_object ( $ localObject ) ? $ localObject -> primaryKey : $ localObject ; if ( $ this -> settings [ 'universalKey' ] ) { return KeyTranslation :: find ( ) -> where ( [ 'registry_id' => $ key ] ) -> one ( ) ; } else { return KeyTranslation :: find ( ) -> where ( [ 'registry_id' => $ key , 'data_interface_id' => $ this -> module -> collectorItem -> interfaceObject -> primaryKey ] ) -> one ( ) ; } }
6268	public function isAcademic ( $ text ) { if ( empty ( $ text ) ) { return false ; } $ domain = $ this -> getDomain ( $ text ) ; if ( $ domain === null ) { return false ; } foreach ( $ this -> getBlacklistedTopLevelDomains ( ) as $ blacklistedDomain ) { $ name = ( string ) $ domain [ 'host' ] ; if ( preg_match ( '/' . preg_quote ( $ blacklistedDomain ) . '$/' , $ name ) ) { return false ; } } if ( in_array ( $ domain [ 'tld' ] , $ this -> getAcademicTopLevelDomains ( ) ) ) { return true ; } if ( $ this -> matchesAcademicDomain ( $ domain ) ) { return true ; } return false ; }
11149	protected function process ( array $ requestParams ) { $ request = new ExtDirectRequest ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; $ response = new ExtDirectResponse ( ) ; $ requestParameters = new Parameters ( ) ; try { $ request -> setApplicationPath ( $ this -> getApplicationPath ( ) ) ; $ requestParameters -> setParameters ( $ requestParams ) ; $ request -> injectParameters ( $ requestParameters ) ; $ response -> injectParameters ( $ requestParameters ) ; $ request -> injectResponse ( $ response ) ; $ request -> setParamMethod ( $ this -> getParamMethod ( ) ) ; $ request -> setMethodCalls ( $ this -> getMethodsToCall ( ) ) ; $ request -> run ( ) ; } catch ( ExtDirectApplicationException $ e ) { $ result = $ e -> getResponse ( ) ; if ( ! empty ( $ result ) ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) , "actions" => $ result ) ) ; } else { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } } catch ( \ Exception $ e ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } return $ response ; }
847	public function getNextTokenOfKind ( $ index , array $ tokens = [ ] , $ caseSensitive = true ) { return $ this -> getTokenOfKindSibling ( $ index , 1 , $ tokens , $ caseSensitive ) ; }
5587	public function getCookies ( ) { $ lstCookies = $ this -> cookie_jar -> getCookies ( ) ; $ aCookies = [ ] ; foreach ( $ lstCookies as $ oCookies ) { $ aCookies [ ] = [ 'name' => $ oCookies -> getName ( ) , 'value' => $ oCookies -> getValue ( ) , 'host' => $ oCookies -> getHost ( ) , 'path' => $ oCookies -> getPath ( ) , 'expiry' => $ oCookies -> getExpiry ( ) , ] ; } return $ aCookies ; }
9703	private function addColor ( $ rgb ) { if ( ! isset ( $ this -> colors [ $ rgb ] ) ) { $ color = [ hexdec ( substr ( $ rgb , 0 , 2 ) ) , hexdec ( substr ( $ rgb , 2 , 2 ) ) , hexdec ( substr ( $ rgb , 4 ) ) , 0 , ] ; $ colorIndex = array_search ( $ color , $ this -> palette ) ; if ( $ colorIndex ) { $ this -> colors [ $ rgb ] = $ colorIndex ; } else { if ( count ( $ this -> colors ) == 0 ) { $ lastColor = 7 ; } else { $ lastColor = end ( $ this -> colors ) ; } if ( $ lastColor < 57 ) { $ colorIndex = $ lastColor + 1 ; $ this -> palette [ $ colorIndex ] = $ color ; $ this -> colors [ $ rgb ] = $ colorIndex ; } else { $ colorIndex = 0 ; } } } else { $ colorIndex = $ this -> colors [ $ rgb ] ; } return $ colorIndex ; }
12516	public static function delete ( $ path ) { if ( ! Folder :: exists ( $ path ) ) { return true ; } $ path = Path :: clean ( $ path ) ; if ( trim ( $ path ) === '' ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' : Cannot delete root path' ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> remove ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
12351	public function invalidate ( string $ api_session = null ) { if ( empty ( $ api_session ) === false && is_string ( $ api_session ) === true ) { $ session = Model \ Session :: where ( 'code' , $ api_session ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } elseif ( empty ( $ _SESSION [ 'api_session' ] ) === false && is_string ( $ _SESSION [ 'api_session' ] ) === true ) { $ session = Model \ Session :: where ( 'code' , $ _SESSION [ 'api_session' ] ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } elseif ( empty ( $ _GET [ 'api_session' ] ) === false && is_string ( $ _GET [ 'api_session' ] ) === true ) { $ session = Model \ Session :: where ( 'code' , $ _GET [ 'api_session' ] ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } $ this -> details = false ; $ _SESSION [ 'api_session' ] = null ; $ _GET [ 'api_session' ] = null ; }
6126	public function addRole ( $ item ) { if ( ! ( $ item instanceof Role ) ) { if ( is_array ( $ item ) ) { try { $ item = new Role ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Role. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Role"!' , E_USER_WARNING ) ; } } $ this -> roles [ ] = $ item ; return $ this ; }
6932	private function isShipmentAmountInvoiced ( Invoice \ InvoiceInterface $ invoice ) { $ sale = $ invoice -> getSale ( ) ; foreach ( $ sale -> getInvoices ( ) as $ i ) { if ( $ i === $ invoice ) { continue ; } if ( $ i -> hasLineByType ( Document \ DocumentLineTypes :: TYPE_SHIPMENT ) ) { return true ; } } return false ; }
4058	private function drawAttribute ( ModelToLabelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( $ attribute ) { $ type = $ attribute -> get ( 'type' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( $ this -> attributeFactory -> getIconForType ( $ type ) , $ type , '' , 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = $ attribute -> getName ( ) ; $ colName = $ attribute -> getColName ( ) ; $ isUnique = $ attribute -> get ( 'isunique' ) ; } else { $ type = 'unknown ID: ' . $ model -> getProperty ( 'attr_id' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = 'unknown attribute' ; $ colName = 'unknown column' ; $ isUnique = false ; } $ event -> setLabel ( '<div class="field_heading cte_type %s"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong><span class="mandatory">%s</span> <span class="tl_class">%s</span> </div>' ) -> setArgs ( [ $ model -> getProperty ( 'published' ) ? 'published' : 'unpublished' , $ colName , $ type , $ image , $ name , $ model -> getProperty ( 'mandatory' ) || $ isUnique ? ' [' . $ this -> trans ( 'mandatory.0' ) . ']' : '' , $ model -> getProperty ( 'tl_class' ) ? sprintf ( '[%s]' , $ model -> getProperty ( 'tl_class' ) ) : '' ] ) ; }
3738	private function getConnection ( ) { if ( $ this -> connection ) { return $ this -> connection ; } $ reflection = new \ ReflectionProperty ( \ Contao \ Database :: class , 'resConnection' ) ; $ reflection -> setAccessible ( true ) ; return $ this -> connection = $ reflection -> getValue ( $ this -> getDatabase ( ) ) ; }
4351	private function setDebugCfg ( $ cfg ) { if ( isset ( $ cfg [ 'key' ] ) ) { $ cfg = \ array_merge ( $ cfg , $ this -> debugKeyValues ( $ cfg [ 'key' ] ) ) ; } if ( isset ( $ cfg [ 'logEnvInfo' ] ) && \ is_bool ( $ cfg [ 'logEnvInfo' ] ) ) { $ keys = \ array_keys ( $ this -> cfg [ 'logEnvInfo' ] ) ; $ cfg [ 'logEnvInfo' ] = \ array_fill_keys ( $ keys , $ cfg [ 'logEnvInfo' ] ) ; } if ( isset ( $ cfg [ 'logServerKeys' ] ) ) { $ this -> cfg [ 'logServerKeys' ] = array ( ) ; } $ this -> cfg = $ this -> debug -> utilities -> arrayMergeDeep ( $ this -> cfg , $ cfg ) ; }
2217	public function getChannels ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> newsletters ) ) { return array ( ) ; } $ arrChannels = array ( ) ; $ objChannels = $ this -> Database -> execute ( "SELECT id, title FROM tl_newsletter_channel ORDER BY title" ) ; while ( $ objChannels -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objChannels -> id , 'newsletters' ) ) { $ arrChannels [ $ objChannels -> id ] = $ objChannels -> title ; } } return $ arrChannels ; }
3796	private function checkForRoot ( $ containedModel , $ action ) { if ( $ this -> hasVariants ( ) && $ action == 'cut' && $ containedModel -> getProperty ( 'varbase' ) == 0 ) { $ this -> disablePI = true ; } }
5916	public function resetPassword ( $ hash , $ password ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'hash' => $ hash , 'password' => $ password ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/resetpassword' , $ parameters ) ; return $ result ; }
12153	public function getPossibleRoles ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = true ; switch ( $ roleItem -> systemId ) { case 'owner' : $ test = $ this -> isOwnable ; break ; } if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
6702	protected function precedence ( $ a , $ b ) { if ( count ( $ a ) > count ( $ b ) ) { $ l = - 1 ; $ r = 1 ; $ x = $ a ; $ y = $ b ; } else { $ l = 1 ; $ r = - 1 ; $ x = $ b ; $ y = $ a ; } foreach ( array_keys ( $ x ) as $ i ) { if ( false === isset ( $ y [ $ i ] ) ) { return $ l ; } if ( $ x [ $ i ] === $ y [ $ i ] ) { continue ; } $ xi = is_integer ( $ x [ $ i ] ) ; $ yi = is_integer ( $ y [ $ i ] ) ; if ( $ xi && $ yi ) { return ( $ x [ $ i ] > $ y [ $ i ] ) ? $ l : $ r ; } elseif ( ( false === $ xi ) && ( false === $ yi ) ) { return ( max ( $ x [ $ i ] , $ y [ $ i ] ) == $ x [ $ i ] ) ? $ l : $ r ; } else { return $ xi ? $ r : $ l ; } } return 0 ; }
3462	public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ next ) : ResponseInterface { $ route = $ this -> router -> find ( $ request -> getMethod ( ) , $ request -> getUri ( ) -> getPath ( ) ) ; $ controller = $ route -> getController ( ) ; if ( $ request instanceof ServerRequest ) { $ request = $ request -> withAttributes ( $ route -> getAttributes ( ) ) ; } if ( is_string ( $ controller ) && class_exists ( $ controller ) && is_subclass_of ( $ controller , Controller :: class ) ) { $ instance = $ this -> resolver -> resolve ( $ controller ) ; return $ instance ( $ request ) ; } if ( is_callable ( $ controller ) ) { $ response = $ controller ( $ request ) ; if ( ! $ response instanceof ResponseInterface ) { throw ControllerException :: forInvalidReturnValue ( ) ; } return $ response ; } throw ControllerException :: forMissingController ( $ route -> getPath ( ) ) ; }
23	public function removePackage ( PackageInterface $ package ) { $ packageId = $ package -> getUniqueName ( ) ; foreach ( $ this -> getPackages ( ) as $ key => $ repoPackage ) { if ( $ packageId === $ repoPackage -> getUniqueName ( ) ) { array_splice ( $ this -> packages , $ key , 1 ) ; return ; } } }
4333	private static function buildAttribBoolVal ( $ key , $ value = true ) { if ( $ key == 'autocomplete' ) { $ value = $ value ? 'on' : 'off' ; } elseif ( $ key == 'spellcheck' ) { $ value = $ value ? 'true' : 'false' ; } elseif ( $ key == 'translate' ) { $ value = $ value ? 'yes' : 'no' ; } elseif ( $ value ) { $ value = $ key ; } else { $ value = null ; } return $ value ; }
11803	public static function importFromApp ( $ path ) { $ importPath = APPS_ROOT . DS . $ path . '.php' ; if ( file_exists ( $ importPath ) ) { include_once $ importPath ; } else { throw new SetupException ( "The object to import ($path) not exists." ) ; } }
6580	public static function fromPolar ( $ length , $ ap , $ av ) { return new static ( $ length * cos ( $ ap ) * cos ( $ av ) , $ length * sin ( $ ap ) * cos ( $ av ) , $ length * sin ( $ av ) ) ; }
5212	public function getConstant ( $ name ) { return $ this -> getBinding ( ConstantBinding :: TYPE , $ name ) -> getInstance ( $ this , $ name ) ; }
1523	protected function doSearch ( StoreInterface $ store , FetchResources $ request ) { if ( $ result = $ this -> invoke ( 'searching' , $ request ) ) { return $ result ; } $ found = $ store -> queryRecords ( $ request -> getResourceType ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ found instanceof PageInterface ) ? $ found -> getData ( ) : $ found ; if ( $ result = $ this -> invoke ( 'searched' , $ records , $ request ) ) { return $ result ; } return $ found ; }
5017	public function logJobEnd ( ProcessJobEvent $ event ) : void { $ result = $ event -> getResult ( ) ; $ job = $ event -> getJob ( ) ; $ queue = $ event -> getQueue ( ) -> getName ( ) ; $ logger = $ this -> getLogger ( ) ; switch ( $ result ) { default : $ logger -> info ( sprintf ( $ this -> tmpl [ 'job' ] , $ queue , 'SUCCESS' , $ this -> formatJob ( $ job ) ) ) ; break ; case ProcessJobEvent :: JOB_STATUS_FAILURE_RECOVERABLE : $ logger -> warn ( sprintf ( $ this -> tmpl [ 'job' ] , $ queue , 'RECOVERABLE' , $ this -> formatJob ( $ job ) ) ) ; break ; case ProcessJobEvent :: JOB_STATUS_FAILURE : $ logger -> err ( sprintf ( $ this -> tmpl [ 'job' ] , $ queue , 'FAILURE' , $ this -> formatJob ( $ job ) ) ) ; break ; } }
9291	public function addGrid16CSS ( \ PageModel $ objPage , \ LayoutModel $ objLayout , \ PageRegular $ objPageRegular ) { $ arrFrameworkGrid16 = \ StringUtil :: deserialize ( $ objLayout -> frameworkGrid16 ) ; if ( is_array ( $ arrFrameworkGrid16 ) ) { foreach ( $ arrFrameworkGrid16 as $ strFile ) { if ( $ objLayout -> loadingOrderGrid16 == 'before_framework' ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/bugbustergrid16/' . basename ( $ strFile , '.css' ) . '.min.css' ; } else { $ GLOBALS [ 'TL_HEAD' ] [ ] = '<link rel="stylesheet" href="bundles/bugbustergrid16/' . basename ( $ strFile , '.css' ) . '.min.css">' ; } } } return ; }
7767	public function loadMetadataForClass ( $ className ) { foreach ( $ this -> drivers as $ namespace => $ driver ) { if ( strpos ( $ className , $ namespace ) === 0 ) { return $ driver -> loadMetadataForClass ( $ className ) ; } } return null ; }
2051	public function save ( ) { $ groups = $ this -> groups ; $ this -> arrData [ 'groups' ] = $ this -> arrGroups ; parent :: save ( ) ; $ this -> groups = $ groups ; }
11442	public function getRegistry ( $ var = null , $ section = false , $ default = false ) { if ( is_null ( $ var ) ) { return ; } if ( $ section && isset ( $ this -> registry [ $ section ] ) ) { if ( isset ( $ this -> registry [ $ section ] [ $ var ] ) ) { return $ this -> registry [ $ section ] [ $ var ] ; } else { return $ default ; } } if ( isset ( $ this -> registry [ $ var ] ) ) { return $ this -> registry [ $ var ] ; } return $ default ; }
6	private function parse20VersionConstraint ( array $ data ) { static $ dep20toOperatorMap = array ( 'has' => '==' , 'min' => '>=' , 'max' => '<=' , 'exclude' => '!=' ) ; $ versions = array ( ) ; $ values = array_intersect_key ( $ data , $ dep20toOperatorMap ) ; if ( 0 == count ( $ values ) ) { return '*' ; } if ( isset ( $ values [ 'min' ] ) && isset ( $ values [ 'exclude' ] ) && $ data [ 'min' ] == $ data [ 'exclude' ] ) { $ versions [ ] = '>' . $ this -> parseVersion ( $ values [ 'min' ] ) ; } elseif ( isset ( $ values [ 'max' ] ) && isset ( $ values [ 'exclude' ] ) && $ data [ 'max' ] == $ data [ 'exclude' ] ) { $ versions [ ] = '<' . $ this -> parseVersion ( $ values [ 'max' ] ) ; } else { foreach ( $ values as $ op => $ version ) { if ( 'exclude' == $ op && is_array ( $ version ) ) { foreach ( $ version as $ versionPart ) { $ versions [ ] = $ dep20toOperatorMap [ $ op ] . $ this -> parseVersion ( $ versionPart ) ; } } else { $ versions [ ] = $ dep20toOperatorMap [ $ op ] . $ this -> parseVersion ( $ version ) ; } } } return implode ( ',' , $ versions ) ; }
8969	protected function initialize ( ) { if ( ! file_exists ( dirname ( $ this -> pathToFile ) ) && ! mkdir ( dirname ( $ this -> pathToFile ) , 0777 , true ) ) { throw new RuntimeException ( sprintf ( 'Could not create storage file on path "%s".' , $ this -> pathToFile ) ) ; } if ( ! file_exists ( $ this -> pathToFile ) && ! ( touch ( $ this -> pathToFile ) && chmod ( $ this -> pathToFile , 0777 ) ) ) { throw new RuntimeException ( sprintf ( 'Could not create storage file on path "%s".' , $ this -> pathToFile ) ) ; } if ( ! is_readable ( $ this -> pathToFile ) ) { throw new RuntimeException ( sprintf ( 'File on path "%s" for storing rates must be readable.' , $ this -> pathToFile ) ) ; } if ( ! is_writable ( $ this -> pathToFile ) ) { throw new RuntimeException ( sprintf ( 'File on path "%s" for storing rates must be writeable.' , $ this -> pathToFile ) ) ; } }
10693	protected function fixTable ( $ table , $ tableAlias = '' ) { if ( empty ( $ table ) ) { $ table = [ ] ; } else { if ( ! is_array ( $ table ) ) { $ table = empty ( $ tableAlias ) ? [ $ table ] : [ $ table => $ tableAlias ] ; } } return $ table ; }
12113	public function getUnmappedForeignKeys ( ) { $ mappedForeign = ArrayHelper :: getColumn ( $ this -> _map , 'foreignKey' ) ; $ u = array_diff ( array_keys ( $ this -> foreignModel -> meta -> schema -> columns ) , $ mappedForeign ) ; unset ( $ u [ $ this -> foreignPrimaryKeyName ] ) ; return $ u ; }
29	private function filterRequiredPackages ( RepositoryInterface $ repo , PackageInterface $ package , $ bucket = array ( ) ) { $ requires = array_keys ( $ package -> getRequires ( ) ) ; $ packageListNames = array_keys ( $ bucket ) ; $ packages = array_filter ( $ repo -> getPackages ( ) , function ( $ package ) use ( $ requires , $ packageListNames ) { return in_array ( $ package -> getName ( ) , $ requires ) && ! in_array ( $ package -> getName ( ) , $ packageListNames ) ; } ) ; $ bucket = $ this -> appendPackages ( $ packages , $ bucket ) ; foreach ( $ packages as $ package ) { $ bucket = $ this -> filterRequiredPackages ( $ repo , $ package , $ bucket ) ; } return $ bucket ; }
2318	public static function getPath ( $ src ) { if ( $ src == '' ) { return '' ; } $ src = rawurldecode ( $ src ) ; if ( strpos ( $ src , '/' ) !== false ) { return $ src ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strncmp ( $ src , 'icon' , 4 ) === 0 ) { if ( pathinfo ( $ src , PATHINFO_EXTENSION ) == 'svg' ) { return 'assets/contao/images/' . $ src ; } $ filename = pathinfo ( $ src , PATHINFO_FILENAME ) ; if ( file_exists ( $ rootDir . '/assets/contao/images/' . $ filename . '.svg' ) ) { return 'assets/contao/images/' . $ filename . '.svg' ; } return 'assets/contao/images/' . $ src ; } else { $ theme = Backend :: getTheme ( ) ; if ( pathinfo ( $ src , PATHINFO_EXTENSION ) == 'svg' ) { return 'system/themes/' . $ theme . '/icons/' . $ src ; } $ filename = pathinfo ( $ src , PATHINFO_FILENAME ) ; if ( file_exists ( $ rootDir . '/system/themes/' . $ theme . '/icons/' . $ filename . '.svg' ) ) { return 'system/themes/' . $ theme . '/icons/' . $ filename . '.svg' ; } return 'system/themes/' . $ theme . '/images/' . $ src ; } }
9555	public function getHandler ( ) { if ( $ this -> namer === null ) { $ this -> namer = new GenericNamer ( ) ; } if ( $ this -> filesystem === null ) { throw new \ LogicException ( sprintf ( 'You should set a filesystem for the builder.' ) ) ; } $ handler = new UploadHandler ( $ this -> filesystem , $ this -> namer , $ this -> overwrite ) ; $ validator = $ handler -> getValidator ( ) ; foreach ( $ this -> constraints as $ constraint ) { $ validator -> addConstraint ( $ constraint ) ; } return $ handler ; }
9020	public function getUniqueWords ( $ string ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ words = $ analysis -> getKeyValuesByFrequency ( ) ; return array_unique ( array_keys ( $ words ) ) ; }
4168	public function handle ( ) { $ packageInfo = $ this -> tokenizePackageInfo ( ) ; $ packages = $ this -> getPackages ( ) ; $ total = $ packages -> count ( ) ; if ( ! $ total ) { $ this -> warn ( ' No package found. Make sure you spell it correct as specified on github or packagist.' ) ; } if ( $ packages -> first ( ) [ 'name' ] !== $ packageInfo [ 'name' ] ) { $ this -> warn ( $ total . ' package' . ( $ total > 1 ? 's' : '' ) . ' found by given name.' ) ; return $ this -> call ( 'add' , [ 'package' => $ this -> prettify ( $ packages ) ] ) ; } $ this -> downloadPackage ( ) -> runConfiguration ( ) ; }
6313	private function loadConstraints ( Table $ table ) { foreach ( $ this -> getConstraints ( ) as $ constraint ) { switch ( $ constraint [ 'constraint_type' ] ) { case 'FOREIGN KEY' : $ foreignKey = new ForeignKey ( new Table ( $ constraint [ 'table_name' ] ) , new Table ( $ constraint [ 'column_name' ] ) ) ; $ foreignKey -> setColumns ( $ constraint [ 'references_table' ] ) ; $ foreignKey -> setReferencedColumns ( $ constraint [ 'references_field' ] ) ; $ table -> addConstraint ( $ foreignKey ) ; break ; case 'PRIMARY KEY' : $ table -> addConstraint ( new PrimaryKey ( $ constraint [ 'column_name' ] , $ table ) ) ; break ; case 'UNIQUE' : $ table -> addConstraint ( new Unique ( $ constraint [ 'column_name' ] , new Table ( $ constraint [ 'table_name' ] ) ) ) ; break ; } } }
11358	public function removeBlock ( $ blockFile ) { foreach ( $ this -> permalinks as $ permalink => $ associatedBlocks ) { $ tmp = array_flip ( $ associatedBlocks ) ; unset ( $ tmp [ $ blockFile ] ) ; if ( empty ( $ tmp ) ) { unset ( $ this -> permalinks [ $ permalink ] ) ; continue ; } $ this -> permalinks [ $ permalink ] = array_flip ( $ tmp ) ; } return $ this ; }
3637	public function initApp ( ) : void { $ tmpDir = \ Swoft :: getAlias ( '@runtime' ) ; $ names = [ 'logs' , 'uploadfiles' ] ; \ output ( ) -> writeln ( 'Create runtime directories: ' . \ implode ( ',' , $ names ) ) ; foreach ( $ names as $ name ) { DirHelper :: make ( $ tmpDir . '/' . $ name ) ; } \ output ( ) -> writeln ( '<success>OK</success>' ) ; }
12566	public function sendVideo ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_VIDEO , $ message , $ to ) ; }
5027	public function getTemplate ( $ page ) { $ bundle = $ this -> getBundleName ( ClassUtils :: getRealClass ( get_class ( $ page ) ) ) ; return sprintf ( '%s:Page:%s.html.twig' , $ bundle , $ page -> getTemplateName ( ) ) ; }
1040	public function processPsrRequest ( ServerRequestInterface $ request , ResponseInterface $ response , StreamInterface $ writableBodyStream ) { $ result = $ this -> executePsrRequest ( $ request ) ; return $ this -> helper -> toPsrResponse ( $ result , $ response , $ writableBodyStream ) ; }
4490	public function createTopic ( string $ name ) : string { $ res = $ this -> sns -> createTopic ( [ 'Name' => $ name , ] ) ; return $ res [ 'TopicArn' ] ; }
4989	public function enableForm ( $ key = null ) { if ( null === $ key ) { $ this -> activeForms = array_keys ( $ this -> forms ) ; return $ this ; } if ( ! is_array ( $ key ) ) { $ key = array ( $ key ) ; } foreach ( $ key as $ k ) { if ( false !== strpos ( $ k , '.' ) ) { list ( $ childKey , $ childForm ) = explode ( '.' , $ k , 2 ) ; $ child = $ this -> getForm ( $ childKey ) ; $ child -> enableForm ( $ childForm ) ; } else { if ( isset ( $ this -> forms [ $ k ] ) && ! in_array ( $ k , $ this -> activeForms ) ) { $ this -> activeForms [ ] = $ k ; } } } return $ this ; }
2591	public function loadPaymentData ( MopInfo $ options ) { if ( $ this -> checkAnyNotEmpty ( $ options -> payMerchant , $ options -> transactionDate , $ options -> payments , $ options -> installmentsInfo , $ options -> fraudScreening , $ options -> payIds ) ) { $ this -> paymentData = new PaymentData ( $ options -> payMerchant , $ options -> transactionDate , $ options -> payments , $ options -> installmentsInfo , $ options -> fraudScreening , $ options -> payIds ) ; } }
2905	public function addEmailToProfile ( $ email , $ name , $ variables , $ result , Zend_Mail $ mail ) { $ emailCapture = Mage :: getModel ( 'sheep_debug/email' ) ; $ subject = $ this -> decodeSubject ( $ mail -> getSubject ( ) ) ; $ body = $ this -> getContent ( $ mail ) ; $ emailCapture -> setFromName ( $ this -> getSenderName ( ) ) ; $ emailCapture -> setFromEmail ( $ this -> getSenderEmail ( ) ) ; $ emailCapture -> setToEmail ( $ email ) ; $ emailCapture -> setToName ( $ name ) ; $ emailCapture -> setSubject ( $ subject ) ; $ emailCapture -> setIsPlain ( $ this -> isPlain ( ) ) ; $ emailCapture -> setBody ( $ body ) ; $ emailCapture -> setIsAccepted ( $ result ) ; $ emailCapture -> setVariables ( $ variables ) ; $ emailCapture -> setIsSmtpDisabled ( ( bool ) Mage :: getStoreConfigFlag ( 'system/smtp/disable' ) ) ; Mage :: getSingleton ( 'sheep_debug/observer' ) -> getRequestInfo ( ) -> addEmail ( $ emailCapture ) ; }
1996	protected function adjustPublicationDate ( ) { if ( ! empty ( $ this -> arrItems ) && $ this -> arrItems [ 0 ] -> published > $ this -> published ) { $ this -> published = $ this -> arrItems [ 0 ] -> published ; } }
4496	private function getGcmJson ( ) : string { return json_encode ( [ 'collapse_key' => $ this -> collapseKey , 'time_to_live' => $ this -> ttl , 'delay_while_idle' => $ this -> delayWhileIdle , 'priority' => $ this -> priority , 'data' => $ this -> getTrimmedJson ( [ $ this , 'getGcmJsonInner' ] , static :: GCM_MAX_LENGTH , 'You message for GCM is too long' ) , ] , JSON_UNESCAPED_UNICODE ) ; }
5752	public function getObjects ( array $ whereColumnsInfo = null ) : array { $ roles = [ ] ; if ( null !== $ records = $ this -> select ( "*" , $ whereColumnsInfo ) ) { foreach ( $ records as $ record ) { $ roles [ ] = $ this -> buildRole ( ( int ) $ record [ 'id' ] , $ record [ 'role' ] , new \ DateTimeImmutable ( $ record [ 'created' ] ) ) ; } } return $ roles ; }
4362	public static function ordUtf8 ( $ str , & $ offset = 0 , & $ char = null ) { $ code = \ ord ( $ str [ $ offset ] ) ; $ numBytes = 1 ; if ( $ code >= 0x80 ) { if ( $ code < 0xe0 ) { $ numBytes = 2 ; $ code -= 0xC0 ; } elseif ( $ code < 0xf0 ) { $ numBytes = 3 ; $ code -= 0xE0 ; } elseif ( $ code < 0xf8 ) { $ numBytes = 4 ; $ code -= 0xF0 ; } for ( $ i = 1 ; $ i < $ numBytes ; $ i ++ ) { $ code2 = \ ord ( $ str [ $ offset + $ i ] ) - 0x80 ; $ code = $ code * 64 + $ code2 ; } } $ char = \ substr ( $ str , $ offset , $ numBytes ) ; $ offset = $ offset + $ numBytes ; return $ code ; }
11798	public function setHtml ( $ html = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } $ this -> html .= Helper :: formatText ( $ html , 'ascii' ) ; return $ this ; }
6443	public function httpRequest ( $ url ) { if ( DEBUG ) echo "HTTP request: $url\n" ; $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , $ url ) ; curl_setopt ( $ curl , CURLOPT_HEADER , 0 ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_TIMEOUT , CURL_TIMEOUT ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , SPIDER_NAME ) ; curl_setopt ( $ curl , CURLOPT_VERBOSE , false ) ; curl_setopt ( $ curl , CURLOPT_MAXREDIRS , 4 ) ; curl_setopt ( $ curl , CURLOPT_FOLLOWLOCATION , true ) ; $ response [ 'file' ] = curl_exec ( $ curl ) ; $ response [ 'status' ] = curl_getinfo ( $ curl ) ; $ response [ 'error' ] = curl_error ( $ curl ) ; curl_exec ( $ curl ) ; curl_close ( $ curl ) ; if ( DEBUG === 'verbose' ) { echo "Retrieved HTTP:\n" ; var_dump ( $ response [ 'status' ] ) ; var_dump ( $ response [ 'error' ] ) ; } if ( $ response [ 'file' ] == '' ) die ( "Error while making the HTTP request: no HTML retrieved." ) ; return $ response ; }
1898	private function checkIfAccountIsActive ( User $ user ) : void { $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ start = ( int ) $ user -> start ; $ stop = ( int ) $ user -> stop ; $ time = Date :: floorToMinute ( time ( ) ) ; $ notActiveYet = $ start && $ start > $ time ; $ notActiveAnymore = $ stop && $ stop <= ( $ time + 60 ) ; $ logMessage = '' ; if ( $ notActiveYet ) { $ logMessage = sprintf ( 'The account is not active yet (activation date: %s)' , Date :: parse ( $ config -> get ( 'dateFormat' ) , $ start ) ) ; } if ( $ notActiveAnymore ) { $ logMessage = sprintf ( 'The account is not active anymore (deactivation date: %s)' , Date :: parse ( $ config -> get ( 'dateFormat' ) , $ stop ) ) ; } if ( '' === $ logMessage ) { return ; } $ ex = new DisabledException ( $ logMessage ) ; $ ex -> setUser ( $ user ) ; throw $ ex ; }
10976	public function sendVerification ( ) { $ this -> setVerificationCode ( $ this -> createVerificationCode ( ) ) ; $ user = & $ this ; return Mail :: queue ( Config :: get ( 'verifier.template' ) , [ 'user' => $ this ] , function ( $ message ) use ( $ user ) { $ message -> to ( $ user -> email , $ user -> getVerificationEmailName ( ) ) -> subject ( $ user -> getVerificationEmailSubject ( ) ) ; } ) ; }
756	protected function renderImage ( $ code ) { if ( isset ( $ this -> imageLibrary ) ) { $ imageLibrary = $ this -> imageLibrary ; } else { $ imageLibrary = Captcha :: checkRequirements ( ) ; } if ( $ imageLibrary === 'gd' ) { return $ this -> renderImageByGD ( $ code ) ; } elseif ( $ imageLibrary === 'imagick' ) { return $ this -> renderImageByImagick ( $ code ) ; } throw new InvalidConfigException ( "Defined library '{$imageLibrary}' is not supported" ) ; }
12446	protected function _setContainer ( $ container ) { if ( ! is_null ( $ container ) && ! ( $ container instanceof BaseContainerInterface ) ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Not a valid container' ) , 0 , null , $ container ) ; } $ this -> container = $ container ; return $ this ; }
4277	public function stream_open ( $ path , $ mode , $ options , & $ openedPath ) { if ( $ this -> handle ) { return false ; } $ useIncludePath = ( bool ) $ options & STREAM_USE_PATH ; $ context = $ this -> context ; if ( $ context === null ) { $ context = \ stream_context_get_default ( ) ; } self :: restorePrev ( ) ; if ( \ strpos ( $ mode , 'r' ) !== false && ! \ file_exists ( $ path ) ) { return false ; } elseif ( \ strpos ( $ mode , 'x' ) !== false && \ file_exists ( $ path ) ) { return false ; } $ handle = \ fopen ( $ path , $ mode , $ useIncludePath , $ context ) ; self :: register ( ) ; if ( $ handle === false ) { return false ; } $ meta = \ stream_get_meta_data ( $ handle ) ; if ( ! isset ( $ meta [ 'uri' ] ) ) { throw new \ UnexpectedValueException ( 'Uri not in meta data' ) ; } $ this -> filepath = $ openedPath = $ meta [ 'uri' ] ; $ this -> handle = $ handle ; return true ; }
6454	private function createNotAcceptableException ( string $ type ) : HttpException { $ headers = new HttpHeaders ( ) ; $ headers -> add ( 'Content-Type' , 'application/json' ) ; $ body = new StringBody ( json_encode ( $ this -> contentNegotiator -> getAcceptableResponseMediaTypes ( $ type ) ) ) ; $ response = new Response ( HttpStatusCodes :: HTTP_NOT_ACCEPTABLE , $ headers , $ body ) ; return new HttpException ( $ response ) ; }
8465	public static function getUriMethods ( ) { $ root = str_replace ( $ _SERVER [ 'DOCUMENT_ROOT' ] , '' , getcwd ( ) ) ; $ subfolder = trim ( $ root , '/' ) ; return trim ( str_replace ( $ subfolder , '' , self :: getUri ( ) ) , '/' ) ; }
2074	public function purgeSearchTables ( ) { $ objDatabase = Database :: getInstance ( ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_search" ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_search_index" ) ; $ strCachePath = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCachePath . '/contao/search' ) ; $ objFolder -> purge ( ) ; $ this -> log ( 'Purged the search tables' , __METHOD__ , TL_CRON ) ; }
2012	public static function addNamespace ( $ name ) { @ trigger_error ( 'Using ClassLoader::addNamespace() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ in_array ( $ name , self :: $ namespaces ) ) { return ; } array_unshift ( self :: $ namespaces , $ name ) ; }
5585	public function isClickable ( $ label ) { return $ this -> isSubmit ( $ label ) || ( $ this -> getLink ( $ label ) !== false ) || $ this -> isImage ( $ label ) ; }
9924	public function filter ( Parameters $ params , array $ permitted = array ( ) ) { $ this -> cleanUnwanted ( $ params , $ permitted ) ; $ this -> handleArrays ( $ params , $ permitted ) ; $ this -> handleCollections ( $ params , $ permitted ) ; }
12371	public function addItem ( array $ item ) : self { if ( count ( $ item ) < 2 ) { throw new Exception ( 'Invalid count of item elements.' ) ; } $ this -> items [ ] = $ item ; return $ this ; }
2388	private function implode ( array $ config ) : string { $ palette = '' ; foreach ( $ config as $ legend => $ group ) { if ( \ count ( $ group [ 'fields' ] ) < 1 ) { continue ; } if ( '' !== $ palette ) { $ palette .= ';' ; } if ( ! \ is_int ( $ legend ) ) { $ palette .= sprintf ( '{%s%s},' , $ legend , ( $ group [ 'hide' ] ? ':hide' : '' ) ) ; } $ palette .= implode ( ',' , $ group [ 'fields' ] ) ; } return $ palette ; }
10077	public static function sanitizeUTF8 ( $ value ) { if ( self :: getIsIconvEnabled ( ) ) { $ value = @ iconv ( 'UTF-8' , 'UTF-8' , $ value ) ; return $ value ; } $ value = mb_convert_encoding ( $ value , 'UTF-8' , 'UTF-8' ) ; return $ value ; }
7776	protected function getRuleArgs ( $ rule ) { if ( ! $ this -> ruleHasArgs ( $ rule ) ) { return [ ] ; } list ( $ ruleName , $ argsWithBracketAtTheEnd ) = explode ( '(' , $ rule ) ; $ args = rtrim ( $ argsWithBracketAtTheEnd , ')' ) ; $ args = preg_replace ( '/\s+/' , '' , $ args ) ; $ args = explode ( ',' , $ args ) ; return $ args ; }
2420	public static function moveResource ( $ strSource , $ strDestination ) { $ objFile = FilesModel :: findByPath ( $ strSource ) ; if ( $ objFile === null ) { $ objFile = static :: addResource ( $ strDestination ) ; } $ strFolder = \ dirname ( $ strDestination ) ; if ( $ strFolder == Config :: get ( 'uploadPath' ) ) { $ objFile -> pid = null ; } else { $ objFolder = FilesModel :: findByPath ( $ strFolder ) ; if ( $ objFolder === null ) { $ objFolder = static :: addResource ( $ strFolder ) ; } $ objFile -> pid = $ objFolder -> uuid ; } $ objFile -> path = $ strDestination ; $ objFile -> name = basename ( $ strDestination ) ; $ objFile -> save ( ) ; if ( $ objFile -> type == 'folder' ) { $ objFiles = FilesModel :: findMultipleByBasepath ( $ strSource . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objFiles -> path = preg_replace ( '@^' . preg_quote ( $ strSource , '@' ) . '/@' , $ strDestination . '/' , $ objFiles -> path ) ; $ objFiles -> save ( ) ; } } } if ( ( $ strPath = \ dirname ( $ strSource ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } if ( ( $ strPath = \ dirname ( $ strDestination ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } return $ objFile ; }
7624	protected function performRequest ( $ path = '/' , $ query = array ( ) , $ httpVerb = 'GET' , $ headers = array ( ) , $ forTableStorage = false , $ rawData = null , $ resourceType = self :: RESOURCE_UNKNOWN , $ requiredPermission = self :: PERMISSION_READ ) { if ( strpos ( $ path , '/' ) !== 0 ) { $ path = '/' . $ path ; } if ( ! isset ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = '' ; } if ( ! isset ( $ headers [ 'content-length' ] ) && ( $ rawData !== null || $ httpVerb == "PUT" ) ) { $ headers [ 'Content-Length' ] = strlen ( ( string ) $ rawData ) ; } $ headers [ 'Expect' ] = '' ; $ headers [ 'x-ms-version' ] = $ this -> apiVersion ; $ path = str_replace ( ' ' , '%20' , $ path ) ; $ requestUrl = $ this -> getBaseUrl ( ) . $ path ; if ( count ( $ query ) > 0 ) { $ queryString = '' ; foreach ( $ query as $ key => $ value ) { $ queryString .= ( $ queryString ? '&' : '?' ) . rawurlencode ( $ key ) . '=' . rawurlencode ( $ value ) ; } $ requestUrl .= $ queryString ; } $ requestUrl = $ this -> credentials -> signRequestUrl ( $ requestUrl , $ resourceType , $ requiredPermission ) ; $ headers = $ this -> credentials -> signRequestHeaders ( $ httpVerb , $ path , $ query , $ headers , $ forTableStorage , $ resourceType , $ requiredPermission , $ rawData ) ; return $ this -> httpClient -> request ( $ httpVerb , $ requestUrl , $ rawData , $ headers ) ; }
3598	public function parserHttpRequest ( HttpRequest $ httpRequest ) { $ json = \ json_decode ( $ httpRequest -> getContent ( ) , true ) ; if ( JSON_ERROR_NONE !== \ json_last_error ( ) ) { throw new Exceptions \ ParseException ( ) ; } $ createJsonRequest = function ( $ json ) use ( $ httpRequest ) { $ id = null ; $ method = null ; $ params = [ ] ; if ( \ is_array ( $ json ) ) { $ id = \ array_key_exists ( 'id' , $ json ) ? $ json [ 'id' ] : null ; $ method = \ array_key_exists ( 'method' , $ json ) ? $ json [ 'method' ] : null ; $ params = \ array_key_exists ( 'params' , $ json ) ? $ json [ 'params' ] : [ ] ; } $ request = new JsonRequest ( $ method , $ params , $ id ) ; $ request -> headers ( ) -> add ( $ httpRequest -> headers -> all ( ) ) ; return $ request ; } ; if ( \ array_keys ( $ json ) === \ range ( 0 , \ count ( $ json ) - 1 ) ) { $ requests = [ ] ; foreach ( $ json as $ part ) { $ requests [ ] = $ createJsonRequest ( $ part ) ; } } else { $ requests = $ createJsonRequest ( $ json ) ; } return $ requests ; }
4853	public function getCurrentRealRows ( $ table = null ) { $ table = $ table ? : $ this -> getCurrentTable ( ) ; if ( ! isset ( $ this -> currentRealRows [ $ table ] ) || ! $ this -> currentRealRows [ $ table ] ) { $ fields = $ this -> getPreparedFields ( ) [ $ table ] ; $ this -> currentRealRows [ $ table ] = $ this -> getRealRow ( $ fields , $ table ) ; } return $ this -> currentRealRows [ $ table ] ; }
3506	private function convertAlertToArray ( Alert $ alert ) : array { $ data = [ ] ; if ( $ alert -> getBodyLocalized ( ) -> getKey ( ) ) { $ data [ 'loc-key' ] = $ alert -> getBodyLocalized ( ) -> getKey ( ) ; $ data [ 'loc-args' ] = $ alert -> getBodyLocalized ( ) -> getArgs ( ) ; } else { $ data [ 'body' ] = $ alert -> getBody ( ) ; } if ( $ alert -> getTitleLocalized ( ) -> getKey ( ) ) { $ data [ 'title-loc-key' ] = $ alert -> getTitleLocalized ( ) -> getKey ( ) ; $ data [ 'title-loc-args' ] = $ alert -> getTitleLocalized ( ) -> getArgs ( ) ; } elseif ( $ alert -> getTitle ( ) ) { $ data [ 'title' ] = $ alert -> getTitle ( ) ; } if ( $ alert -> getActionLocalized ( ) -> getKey ( ) ) { $ data [ 'action-loc-key' ] = $ alert -> getActionLocalized ( ) -> getKey ( ) ; } if ( $ alert -> getLaunchImage ( ) ) { $ data [ 'launch-image' ] = $ alert -> getLaunchImage ( ) ; } return $ data ; }
4999	protected function fixOneToMany ( PageInterface $ object ) { $ items = $ object -> getContentItems ( ) ; if ( $ items ) { foreach ( $ object -> getContentItems ( ) as $ item ) { $ item -> setPage ( $ object ) ; } } if ( $ this -> menuManager ) { $ this -> menuManager -> flush ( ) ; } }
5558	protected function findForm ( $ method , $ attribute ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> findFormInFrame ( $ this -> frames [ $ this -> focus ] , $ this -> focus , $ method , $ attribute ) ; } for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ form = $ this -> findFormInFrame ( $ this -> frames [ $ i ] , $ i , $ method , $ attribute ) ; if ( $ form ) { return $ form ; } } return ; }
8046	public function hasData ( $ sec = 0 , $ usec = 0 ) { $ sec = ( int ) $ sec ; $ usec = ( int ) $ usec ; if ( $ sec < 0 ) { $ sec = 0 ; } if ( $ usec < 0 ) { $ usec = 0 ; } $ read = array ( $ this -> socket ) ; $ write = array ( ) ; $ except = array ( ) ; $ sockets = socket_select ( $ read , $ write , $ except , $ sec , $ usec ) ; if ( $ sockets === FALSE ) { return FALSE ; } return $ sockets > 0 ; }
12180	public function getTaxonomyPackage ( ) { if ( empty ( $ this -> taxonomy ) ) { return false ; } $ taxonomySettings = $ this -> taxonomy ; if ( ! is_array ( $ taxonomySettings ) ) { $ taxonomySettings = [ 'id' => $ taxonomySettings ] ; } $ taxonomy = Yii :: $ app -> collectors [ 'taxonomies' ] -> getOne ( $ taxonomySettings [ 'id' ] ) ; if ( empty ( $ taxonomy ) || empty ( $ taxonomy -> object ) ) { return false ; } return $ taxonomy -> package ( $ taxonomySettings ) ; }
7442	public function showAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } return array ( 'group' => $ group , ) ; }
12515	public static function exists ( $ path ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; return $ fs -> exists ( $ path ) ; }
5767	private function create ( ) { $ m = new \ PHPMailer ( ) ; switch ( $ this -> protocol ) { case 'sendmail' : $ m -> isSendmail ( ) ; break ; case 'smtp' : $ m -> isSMTP ( ) ; $ m -> Host = $ this -> smtpHost ; $ m -> SMTPAuth = false ; $ m -> SMTPAutoTLS = false ; $ m -> Port = $ this -> smtpPort ; break ; case 'mail' : $ m -> isMail ( ) ; break ; case 'qmail' : $ m -> isQmail ( ) ; break ; default : throw new \ Exception ( 'bad phpmailerType: ' . $ this -> protocol ) ; } return $ m ; }
9035	public function persist ( TopicInterface $ thread ) { if ( $ thread -> getId ( ) > 0 ) { $ this -> update ( $ thread , null , null , new TopicHydrator ( ) ) ; } else { $ this -> insert ( $ thread , null , new TopicHydrator ( ) ) ; } return $ thread ; }
5058	public function generate ( $ subject , $ status , $ color , $ format ) { $ badge = new Badge ( $ subject , $ status , $ color , $ format ) ; return $ this -> getRenderFor ( $ badge -> getFormat ( ) ) -> render ( $ badge ) ; }
7692	function MsExcel_ConvertToExplicit_Item ( & $ Txt , $ Tag , $ Att , $ CellRow ) { $ tag_pc = strlen ( $ Tag ) + 1 ; $ rpl = '<' . $ Tag . ' ' . $ Att . '="' ; $ rpl_len = strlen ( $ rpl ) ; $ rpl_nbr = 0 ; $ p = 0 ; $ empty_first_pos = false ; $ empty_nbr = 0 ; $ item_num = 0 ; $ rpl_nbr = 0 ; while ( ( $ p = clsTinyButStrong :: f_Xml_FindTagStart ( $ Txt , $ Tag , true , $ p , true , true ) ) !== false ) { $ item_num ++ ; if ( $ empty_first_pos === false ) $ empty_first_pos = $ p ; $ p = $ p + $ tag_pc ; if ( substr ( $ Txt , $ p , 1 ) == '/' ) { $ empty_nbr ++ ; } else { $ ref = ( $ CellRow === false ) ? $ item_num : $ this -> Misc_CellRef ( $ item_num , $ CellRow ) ; $ x = $ rpl . $ ref . '"' ; $ len = $ p - $ empty_first_pos ; $ Txt = substr_replace ( $ Txt , $ x , $ empty_first_pos , $ len ) ; $ rpl_nbr ++ ; if ( $ CellRow === false ) { $ loc = new clsTbsXmlLoc ( $ Txt , $ Tag , $ p ) ; $ loc -> FindEndTag ( ) ; $ src = $ loc -> GetSrc ( ) ; $ nbr = $ this -> MsExcel_ConvertToExplicit_Item ( $ src , 'c' , 'r' , $ item_num ) ; if ( $ nbr > 0 ) { $ loc -> ReplaceSrc ( $ src ) ; } $ p = $ loc -> PosEnd ; } else { $ p = $ empty_first_pos + $ tag_pc ; } $ empty_nbr = 0 ; $ empty_first_pos = false ; } } return $ rpl_nbr ; }
1352	protected function notAllowed ( string $ resourceType , string $ fields ) : Collection { $ fields = collect ( explode ( ',' , $ fields ) ) ; if ( ! $ this -> allowed -> has ( $ resourceType ) ) { return $ fields ; } $ allowed = $ this -> allowed -> get ( $ resourceType ) ; if ( is_null ( $ allowed ) ) { return collect ( ) ; } $ allowed = collect ( ( array ) $ allowed ) ; return $ fields -> reject ( function ( $ value ) use ( $ allowed ) { return $ allowed -> contains ( $ value ) ; } ) ; }
2805	public function viewAction ( ) { $ token = ( string ) $ this -> getRequest ( ) -> getParam ( 'token' ) ; if ( ! $ token ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) ; return $ this -> _getRefererUrl ( ) ; } $ requestInfo = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestInfo -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) ; return $ this -> _getRefererUrl ( ) ; } $ section = $ this -> getRequest ( ) -> getParam ( 'panel' , 'request' ) ; if ( ! in_array ( $ section , array ( 'request' , 'performance' , 'events' , 'db' , 'logging' , 'email' , 'layout' , 'config' ) ) ) { $ section = 'request' ; } Mage :: register ( 'sheep_debug_request_info' , $ requestInfo ) ; $ blockName = 'sheep_debug_' . $ section ; $ blockTemplate = "sheep_debug/view/panel/{$section}.phtml" ; $ this -> loadLayout ( ) ; $ layout = $ this -> getLayout ( ) ; $ sectionBlock = $ layout -> createBlock ( 'sheep_debug/view' , $ blockName , array ( 'template' => $ blockTemplate ) ) ; $ layout -> getBlock ( 'sheep_debug_content' ) -> insert ( $ sectionBlock ) ; $ layout -> getBlock ( 'root' ) -> setHeaderTitle ( $ this -> __ ( 'Profile for request %s (%s)' , $ requestInfo -> getRequestPath ( ) , $ requestInfo -> getToken ( ) ) ) ; $ this -> renderLayout ( ) ; }
10617	protected function setEtag ( Response $ response ) { if ( ! $ response -> getEtag ( ) ) { $ response -> setEtag ( $ this -> key_builder -> getEtag ( $ response ) ) ; } return $ this ; }
2141	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof User ) { return ; } $ sessionBag = $ this -> getSessionBag ( $ event -> getRequest ( ) ) ; $ data = $ sessionBag -> all ( ) ; $ this -> connection -> update ( $ user -> getTable ( ) , [ 'session' => serialize ( $ data ) ] , [ 'id' => $ user -> id ] ) ; }
12918	protected function findContentType ( $ spaceId , $ contentTypeName ) { $ contentTypes = $ this -> contentTypeRepo -> findNewestByName ( $ spaceId , $ contentTypeName ) ; if ( $ contentTypes -> isEmpty ( ) ) { throw new InvalidArgumentException ( sprintf ( 'Content type "%s" in space "%s" not found!' , $ contentTypeName , $ spaceId ) ) ; } if ( $ contentTypes -> count ( ) > 1 ) { throw new InvalidArgumentException ( sprintf ( 'Multiple content types with name "%s" found in space "%s"!' , $ contentTypeName , $ spaceId ) ) ; } $ contentType = $ contentTypes -> first ( ) ; return $ contentType ; }
4008	public function collectMetaModelTableNames ( CollectMetaModelTableNamesEvent $ event ) { if ( $ this -> tableNamesCollected ) { $ event -> addMetaModelNames ( $ this -> tableNames ) ; return ; } $ tables = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; foreach ( $ tables as $ table ) { $ this -> tableNames [ $ table [ 'id' ] ] = $ table [ 'tableName' ] ; } $ event -> addMetaModelNames ( $ this -> tableNames ) ; $ this -> tableNamesCollected = true ; }
6945	protected function watch ( OrderPaymentInterface $ payment ) { $ order = $ payment -> getOrder ( ) ; if ( ! $ order -> isAutoNotify ( ) || $ order -> isSample ( ) ) { return ; } if ( ! $ payment -> getMethod ( ) -> isManual ( ) ) { return ; } if ( ! $ this -> didStateChangeTo ( $ payment , PaymentStates :: STATE_CAPTURED ) ) { return ; } foreach ( $ order -> getNotifications ( ) as $ n ) { if ( $ n -> getType ( ) !== NotificationTypes :: PAYMENT_CAPTURED ) { continue ; } if ( $ n -> hasData ( 'payment' ) && $ n -> getData ( 'payment' ) === $ payment -> getNumber ( ) ) { return ; } } $ this -> notify ( NotificationTypes :: PAYMENT_CAPTURED , $ payment ) ; }
11437	protected function init ( array $ options = null ) { $ this -> boot ( ) ; if ( ! is_null ( $ options ) ) { $ this -> setOptions ( array_merge ( $ this -> getOptions ( ) , $ options ) ) ; } }
8485	public static function getCpuModel ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT Name FROM Win32_Processor" ) ; foreach ( $ object as $ cpu ) { return $ cpu -> Name ; } return 'Unknown' ; }
8302	public function assertArray ( $ config , $ key ) { if ( array_key_exists ( $ key , $ config ) && ! is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " section must be an array." ) ; } return $ this ; }
5947	public function getAdapterType ( ) { if ( $ this -> adapter instanceof AbstractAdapter ) { $ string = StringHelper :: factory ( get_class ( $ this -> adapter ) ) ; return $ string -> substr ( $ string -> findLast ( "\\" ) ) -> replace ( array ( "\\" , " " ) , "" ) -> toString ( ) ; } return "Unknown" ; }
12005	public function archive ( $ sourceDir , array $ options , $ username , $ block ) { $ this -> resolveOptions ( $ options ) ; $ block = json_decode ( $ block , true ) ; $ block [ "history" ] = array ( ) ; $ this -> init ( $ sourceDir , $ options , $ username ) ; $ historyDirName = sprintf ( '%s/archive/%s' , $ this -> getDirInUse ( ) , $ options [ "blockname" ] ) ; $ historyFileName = $ historyDirName . '/history.json' ; if ( ! is_dir ( $ historyDirName ) ) { mkdir ( $ historyDirName ) ; } $ history = array ( ) ; if ( file_exists ( $ historyFileName ) ) { $ history = json_decode ( file_get_contents ( $ historyFileName ) , true ) ; } $ history = array_merge ( $ history , array ( $ block [ "history_name" ] => $ block ) ) ; FilesystemTools :: writeFile ( $ historyFileName , json_encode ( $ history ) ) ; }
2031	public static function findParentsById ( $ intId ) { $ arrModels = array ( ) ; while ( $ intId > 0 && ( $ objPage = static :: findByPk ( $ intId ) ) !== null ) { $ intId = $ objPage -> pid ; $ arrModels [ ] = $ objPage ; } if ( empty ( $ arrModels ) ) { return null ; } return static :: createCollection ( $ arrModels , 'tl_page' ) ; }
4502	public function after ( DOMNode $ node ) : void { $ this -> parentNode -> insertBefore ( $ node , $ this -> nextSibling ) ; }
4430	protected function writeInstallerSummary ( $ errors ) { if ( ! $ errors ) { $ this -> writeSection ( 'You can now continue installation as per instructions in the README.md file!' ) ; return ; } $ this -> writeSection ( array ( 'The command was not able to install everything automatically.' , 'You must do the following changes manually.' , ) , 'error' ) ; $ this -> output -> writeln ( $ errors ) ; }
5110	private function appendBind ( $ part , $ bind ) { if ( $ bind === false ) return $ this ; if ( ! is_array ( $ bind ) ) $ bind = [ $ bind ] ; if ( ! $ this -> bind [ $ part ] ) { $ this -> bind [ $ part ] = $ bind ; } else { $ this -> bind [ $ part ] = array_merge ( $ this -> bind [ $ part ] , $ bind ) ; } return $ this ; }
12638	public static function select ( string $ table , array $ columns = [ ] , string $ orderBy = "" ) : array { $ pdo = self :: connect ( ) ; $ sql = "SELECT " . ( $ columns === [ ] ? "*" : "\"" . implode ( "\", \"" , $ columns ) . "\"" ) . " FROM \"$table\"" . ( $ orderBy !== "" ? " ORDER BY $orderBy" : "" ) ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; return $ results ; }
6495	public function visitPage ( $ path , $ code = 200 ) { if ( ! $ this -> assertStatusCode ( $ path , $ code ) ) { throw new \ Exception ( sprintf ( 'The page "%s" is not accessible!' , $ path ) ) ; } self :: debug ( [ 'Visited page: %s' ] , [ $ path ] ) ; $ this -> visitPath ( $ path ) ; }
10495	public function mod ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ value == 0 ) { throw new InvalidArgumentException ( 'Division by zero' ) ; } if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value % $ value ) ; }
11446	public function getSpooler ( ) { if ( empty ( $ this -> spooler ) ) { $ spool_class = $ this -> getDefault ( 'spooler' ) ; if ( class_exists ( $ spool_class ) ) { $ this -> setSpooler ( new $ spool_class ) ; } else { throw new \ Exception ( sprintf ( 'Default spool class "%s" not found!' , $ spool_class ) ) ; } } return $ this -> spooler ; }
5097	private function appendByField ( $ values ) { $ fixed = array ( ) ; foreach ( $ this -> fields as $ field ) { $ fixed [ ] = $ values [ $ field ] ; } return $ this -> appendByPosition ( $ fixed ) ; }
7140	protected function handleQuantityChange ( SupplierDeliveryItemInterface $ item ) { $ changeSet = $ this -> persistenceHelper -> getChangeSet ( $ item ) ; if ( null === $ orderItem = $ item -> getOrderItem ( ) ) { throw new RuntimeException ( "Failed to retrieve order item." ) ; } if ( null !== $ stockUnit = $ orderItem -> getStockUnit ( ) ) { if ( 0 != $ deltaQuantity = floatval ( $ changeSet [ 'quantity' ] [ 1 ] ) - floatval ( $ changeSet [ 'quantity' ] [ 0 ] ) ) { $ this -> stockUnitUpdater -> updateReceived ( $ stockUnit , $ deltaQuantity , true ) ; } } elseif ( $ orderItem -> hasSubjectIdentity ( ) ) { throw new RuntimeException ( "Failed to retrieve stock unit." ) ; } if ( null === $ order = $ orderItem -> getOrder ( ) ) { throw new RuntimeException ( "Failed to retrieve order." ) ; } $ this -> scheduleSupplierOrderContentChangeEvent ( $ order ) ; }
4748	public function getPlan ( string $ planCode ) : array { $ cacheKey = sprintf ( 'plan_%s' , $ planCode ) ; $ hit = $ this -> getFromCache ( $ cacheKey ) ; if ( false === $ hit ) { $ response = $ this -> sendRequest ( 'GET' , sprintf ( 'plans/%s' , $ planCode ) ) ; $ data = $ this -> processResponse ( $ response ) ; $ plan = $ data [ 'plan' ] ; $ this -> saveToCache ( $ cacheKey , $ plan ) ; return $ plan ; } return $ hit ; }
5426	private function forceToExpectation ( $ exception ) { if ( $ exception === false ) { return new AnythingExpectation ( ) ; } if ( ! SimpleExpectation :: isExpectation ( $ exception ) ) { return new ExceptionExpectation ( $ exception ) ; } return $ exception ; }
4961	public function setForm ( $ form ) { if ( ! $ form instanceof FormInterface && ! $ form instanceof Container ) { throw new \ InvalidArgumentException ( 'Form must either implement \Zend\Form\FormInterface or extend from \Core\Form\Container' ) ; } $ this -> form = $ form ; return $ this ; }
4123	public function generateProxyClasses ( array $ classes , $ toDir = null ) { $ proxyDir = $ toDir ? : $ this -> proxyDir ; $ proxyDir = rtrim ( $ proxyDir , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR ; foreach ( $ classes as $ class ) { if ( $ class -> isMappedSuperclass ) { continue ; } $ proxyFileName = $ this -> getProxyFileName ( $ class -> name , $ toDir ) ; $ this -> generateProxyClass ( $ class , $ proxyFileName , self :: $ proxyClassTemplate ) ; } }
1517	public function readRelationship ( StoreInterface $ store , FetchRelationship $ request ) { $ record = $ request -> getRecord ( ) ; $ result = $ this -> beforeReadingRelationship ( $ record , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } $ related = $ store -> queryRelationship ( $ record , $ request -> getRelationshipName ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ related instanceof PageInterface ) ? $ related -> getData ( ) : $ related ; $ result = $ this -> afterReadingRelationship ( $ record , $ records , $ request ) ; if ( $ this -> isInvokedResult ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> relationship ( $ related ) ; }
3397	public function urlDecodeUnreservedChars ( $ string ) { $ string = rawurldecode ( $ string ) ; $ string = rawurlencode ( $ string ) ; $ string = str_replace ( array ( '%2F' , '%3A' , '%40' ) , array ( '/' , ':' , '@' ) , $ string ) ; return $ string ; }
12895	public function setPerson ( \ Chill \ PersonBundle \ Entity \ Person $ person = null ) { $ this -> person = $ person ; return $ this ; }
10201	private function writeCellMerge ( XMLWriter $ objWriter , Cell $ cell ) { if ( ! $ cell -> isMergeRangeValueCell ( ) ) { return ; } $ mergeRange = Coordinate :: splitRange ( $ cell -> getMergeRange ( ) ) ; list ( $ startCell , $ endCell ) = $ mergeRange [ 0 ] ; $ start = Coordinate :: coordinateFromString ( $ startCell ) ; $ end = Coordinate :: coordinateFromString ( $ endCell ) ; $ columnSpan = Coordinate :: columnIndexFromString ( $ end [ 0 ] ) - Coordinate :: columnIndexFromString ( $ start [ 0 ] ) + 1 ; $ rowSpan = $ end [ 1 ] - $ start [ 1 ] + 1 ; $ objWriter -> writeAttribute ( 'table:number-columns-spanned' , $ columnSpan ) ; $ objWriter -> writeAttribute ( 'table:number-rows-spanned' , $ rowSpan ) ; }
4179	public function hasManagerFile ( ) { if ( app ( 'filesystem' ) -> exists ( $ this -> directory . 'manager.yml' ) ) { return true ; } $ this -> console -> warn ( "No manager.yml file found in {$this->name} package." ) ; return false ; }
5375	protected function createInputTag ( $ attributes ) { if ( ! isset ( $ attributes [ 'type' ] ) ) { return new SimpleTextTag ( $ attributes ) ; } $ type = strtolower ( trim ( $ attributes [ 'type' ] ) ) ; $ map = array ( 'submit' => 'SimpleSubmitTag' , 'image' => 'SimpleImageSubmitTag' , 'checkbox' => 'SimpleCheckboxTag' , 'radio' => 'SimpleRadioButtonTag' , 'text' => 'SimpleTextTag' , 'hidden' => 'SimpleTextTag' , 'password' => 'SimpleTextTag' , 'file' => 'SimpleUploadTag' ) ; if ( array_key_exists ( $ type , $ map ) ) { $ tag_class = $ map [ $ type ] ; return new $ tag_class ( $ attributes ) ; } return false ; }
7640	public static function isValidContainerName ( $ containerName = '' ) { if ( $ containerName == '$root' ) { return true ; } if ( preg_match ( "/^[a-z0-9][a-z0-9-]*$/" , $ containerName ) === 0 ) { return false ; } if ( strpos ( $ containerName , '--' ) !== false ) { return false ; } if ( strtolower ( $ containerName ) != $ containerName ) { return false ; } if ( strlen ( $ containerName ) < 3 || strlen ( $ containerName ) > 63 ) { return false ; } if ( substr ( $ containerName , - 1 ) == '-' ) { return false ; } return true ; }
10889	public function parse ( ) { list ( $ opt_str , $ long_opts , $ mapping ) = $ this -> getOptString ( ) ; $ opts = \ getopt ( $ opt_str , $ long_opts ) ; $ options = $ this -> mapOptions ( $ opts , $ mapping ) ; return new Dictionary ( $ options ) ; }
10861	protected function createObjectUsingFactory ( string $ typeName , Factory $ factory , ? bool $ nullable = false ) : ? object { $ this -> underConstruction [ $ typeName ] = true ; try { $ object = ( $ factory -> callback ) ( ... $ this -> populateArguments ( $ factory -> getReflection ( ) , null , $ typeName ) ) ; if ( ! $ object instanceof $ typeName ) { if ( $ object === null && $ nullable ) { return null ; } $ type = \ is_object ( $ object ) ? \ get_class ( $ object ) : \ gettype ( $ object ) ; throw new ContainerException ( \ sprintf ( 'Factory must return an instance of %s, returned value is %s' , $ typeName , $ type ) ) ; } } finally { unset ( $ this -> underConstruction [ $ typeName ] ) ; } return $ object ; }
7310	public static function solsticeSummer ( $ year ) { $ jd = static :: solsticeJune ( ( int ) $ year , false ) ; return AstroDate :: jd ( $ jd , TimeScale :: TT ( ) ) ; }
3260	protected function process ( Request $ request ) { $ validator = Validator :: make ( [ 'order_id' => $ request -> get ( 'order_id' ) , 'status' => $ request -> get ( 'status' ) , 'shoptoken' => $ request -> get ( 'shoptoken' ) , ] , [ 'order_id' => 'required|exists:' . config ( 'shop.order_table' ) . ',id' , 'status' => 'required|in:success,fail' , 'shoptoken' => 'required|exists:' . config ( 'shop.transaction_table' ) . ',token,order_id,' . $ request -> get ( 'order_id' ) , ] ) ; if ( $ validator -> fails ( ) ) { abort ( 404 ) ; } $ order = call_user_func ( config ( 'shop.order' ) . '::find' , $ request -> get ( 'order_id' ) ) ; $ transaction = $ order -> transactions ( ) -> where ( 'token' , $ request -> get ( 'shoptoken' ) ) -> first ( ) ; Shop :: callback ( $ order , $ transaction , $ request -> get ( 'status' ) , $ request -> all ( ) ) ; $ transaction -> token = null ; $ transaction -> save ( ) ; return redirect ( ) -> route ( config ( 'shop.callback_redirect_route' ) , [ 'orderId' => $ order -> id ] ) ; }
5139	public function add ( $ middleware , string $ pathConstraint = null ) : void { if ( is_string ( $ middleware ) ) { $ middleware = $ this -> getContainer ( ) -> get ( $ middleware ) ; } if ( ! $ middleware instanceof MiddlewareInterface ) { throw new InvalidArgumentException ( 'Middleware must be an instance of ' . MiddlewareInterface :: class ) ; } $ this -> middleware [ ] = new Middleware ( $ middleware , $ pathConstraint ) ; }
869	private function createProcessForSource ( $ source ) { if ( null === $ this -> temporaryFile ) { $ this -> temporaryFile = tempnam ( '.' , 'cs_fixer_tmp_' ) ; $ this -> fileRemoval -> observe ( $ this -> temporaryFile ) ; } if ( false === @ file_put_contents ( $ this -> temporaryFile , $ source ) ) { throw new IOException ( sprintf ( 'Failed to write file "%s".' , $ this -> temporaryFile ) , 0 , null , $ this -> temporaryFile ) ; } return $ this -> createProcessForFile ( $ this -> temporaryFile ) ; }
10355	public function incrementAttempts ( ) { $ this -> cache -> add ( $ this -> key , 0 , $ this -> getExpiry ( ) ) ; $ this -> cache -> increment ( $ this -> key ) ; }
3642	public function only ( $ keys , bool $ trim = true , bool $ clean = true ) { $ values = [ ] ; foreach ( ( array ) $ keys as $ key ) { $ values [ $ key ] = $ this -> get ( $ key , null , $ trim , $ clean ) ; } return $ values ; }
11502	public function showAction ( Comment $ comment ) { $ deleteForm = $ this -> createDeleteForm ( $ comment ) ; return array ( 'entity' => $ comment , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
2047	public function onSchemaIndexDefinition ( SchemaIndexDefinitionEventArgs $ event ) : void { if ( method_exists ( AbstractPlatform :: class , 'supportsColumnLengthIndexes' ) ) { return ; } $ connection = $ event -> getConnection ( ) ; if ( ! $ connection -> getDatabasePlatform ( ) instanceof MySqlPlatform ) { return ; } $ data = $ event -> getTableIndex ( ) ; if ( 'PRIMARY' === $ data [ 'name' ] ) { return ; } $ columns = [ ] ; $ query = sprintf ( "SHOW INDEX FROM %s WHERE Key_name='%s'" , $ event -> getTable ( ) , $ data [ 'name' ] ) ; $ result = $ connection -> executeQuery ( $ query ) ; while ( $ row = $ result -> fetch ( ) ) { if ( null !== $ row [ 'Sub_part' ] ) { $ columns [ ] = sprintf ( '%s(%s)' , $ row [ 'Column_name' ] , $ row [ 'Sub_part' ] ) ; } else { $ columns [ ] = $ row [ 'Column_name' ] ; } } $ event -> setIndex ( new Index ( $ data [ 'name' ] , $ columns , $ data [ 'unique' ] , $ data [ 'primary' ] , $ data [ 'flags' ] , $ data [ 'options' ] ) ) ; $ event -> preventDefault ( ) ; }
2302	public static function getDcaPickerWizard ( $ extras , $ table , $ field , $ inputName ) { $ context = 'link' ; $ extras = \ is_array ( $ extras ) ? $ extras : array ( ) ; $ providers = ( isset ( $ extras [ 'providers' ] ) && \ is_array ( $ extras [ 'providers' ] ) ) ? $ extras [ 'providers' ] : null ; if ( isset ( $ extras [ 'context' ] ) ) { $ context = $ extras [ 'context' ] ; unset ( $ extras [ 'context' ] ) ; } $ factory = System :: getContainer ( ) -> get ( 'contao.picker.builder' ) ; if ( ! $ factory -> supportsContext ( $ context , $ providers ) ) { return '' ; } return ' <a href="' . ampersand ( $ factory -> getUrl ( $ context , $ extras ) ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'pagepicker' ] ) . '" id="pp_' . $ inputName . '">' . Image :: getHtml ( ( \ is_array ( $ extras ) && isset ( $ extras [ 'icon' ] ) ? $ extras [ 'icon' ] : 'pickpage.svg' ) , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'pagepicker' ] ) . '</a> <script> $("pp_' . $ inputName . '").addEvent("click", function(e) { e.preventDefault(); Backend.openModalSelector({ "id": "tl_listing", "title": ' . json_encode ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ field ] [ 'label' ] [ 0 ] ) . ', "url": this.href + "&value=" + document.getElementById("ctrl_' . $ inputName . '").value, "callback": function(picker, value) { $("ctrl_' . $ inputName . '").value = value.join(","); }.bind(this) }); }); </script>' ; }
4236	public function emailLog ( ) { $ errorStr = $ this -> buildErrorList ( ) ; $ subject = 'Debug Log' ; $ subjectMore = '' ; if ( ! empty ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ subjectMore .= ' ' . $ _SERVER [ 'HTTP_HOST' ] ; } if ( $ errorStr ) { $ subjectMore .= ' ' . ( $ subjectMore ? '(Error)' : 'Error' ) ; } $ subject = \ rtrim ( $ subject . ':' . $ subjectMore , ':' ) ; $ body = ( ! isset ( $ _SERVER [ 'REQUEST_URI' ] ) && ! empty ( $ _SERVER [ 'argv' ] ) ? 'Command: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) : 'Request: ' . $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] ) . "\n\n" ; if ( $ errorStr ) { $ body .= 'Error(s):' . "\n" . $ errorStr . "\n" ; } $ data = \ array_intersect_key ( $ this -> debug -> getData ( ) , \ array_flip ( array ( 'alerts' , 'log' , 'logSummary' , 'requestId' , 'runtime' , ) ) ) ; $ data [ 'rootChannel' ] = $ this -> debug -> getCfg ( 'channel' ) ; $ body .= $ this -> debug -> utilities -> serializeLog ( $ data ) ; $ this -> email ( $ this -> debug -> getCfg ( 'emailTo' ) , $ subject , $ body ) ; return ; }
2901	public function addResponseInfo ( Mage_Core_Controller_Response_Http $ httpResponse ) { $ this -> responseCode = $ httpResponse -> getHttpResponseCode ( ) ; $ this -> responseHeaders = array ( ) ; $ headers = $ httpResponse -> getHeaders ( ) ; foreach ( $ headers as $ header ) { $ this -> responseHeaders [ $ header [ 'name' ] ] = $ header [ 'value' ] ; } }
7652	public function url_stat ( $ path , $ flags ) { $ stat = array ( ) ; $ stat [ 'dev' ] = 0 ; $ stat [ 'ino' ] = 0 ; $ stat [ 'mode' ] = 0 ; $ stat [ 'nlink' ] = 0 ; $ stat [ 'uid' ] = 0 ; $ stat [ 'gid' ] = 0 ; $ stat [ 'rdev' ] = 0 ; $ stat [ 'size' ] = 0 ; $ stat [ 'atime' ] = 0 ; $ stat [ 'mtime' ] = 0 ; $ stat [ 'ctime' ] = 0 ; $ stat [ 'blksize' ] = 0 ; $ stat [ 'blocks' ] = 0 ; $ info = null ; try { $ info = $ this -> getStorageClient ( $ path ) -> getBlobInstance ( $ this -> getContainerName ( $ path ) , $ this -> getFileName ( $ path ) ) ; $ stat [ 'size' ] = $ info -> Size ; $ lastmodified = strtotime ( $ info -> LastModified ) ; $ stat [ 'mtime' ] = $ lastmodified ; $ stat [ 'ctime' ] = $ lastmodified ; $ stat [ 'mode' ] = 0100000 ; return array_values ( $ stat ) + $ stat ; } catch ( BlobException $ ex ) { return false ; } }
5428	public function getInterfaceMethods ( ) { $ methods = array ( ) ; $ interfaces = $ this -> getInterfaces ( ) ; foreach ( $ interfaces as $ interface ) { $ methods = array_merge ( $ methods , get_class_methods ( $ interface ) ) ; } return array_unique ( $ methods ) ; }
7027	public function autoLogin ( EntityInterface $ user ) : ? Response { $ controller = $ this -> getController ( ) ; $ request = $ controller -> request ; $ token = $ request -> getQuery ( 't' ) ; if ( empty ( $ token ) ) { return null ; } $ this -> Auth -> logout ( ) ; $ tokenData = $ user -> validateLoginToken ( $ token , $ user -> getKey ( ) , $ user -> getSalt ( ) ) ; if ( ! is_array ( $ tokenData ) ) { return null ; } if ( ! empty ( $ tokenData [ 'addRememberMeCookie' ] ) && $ tokenData [ 'addRememberMeCookie' ] ) { $ this -> addRememberMeCookie ( ( string ) $ user -> id ) ; } $ userData = $ user -> toArray ( ) ; $ userData [ 'user' ] = $ user ; $ this -> Auth -> setUser ( $ userData ) ; if ( ! empty ( $ tokenData [ 'url' ] ) ) { return $ controller -> redirect ( $ tokenData [ 'url' ] ) ; } return $ controller -> redirect ( $ this -> getConfig ( 'defaultRedirect' ) ) ; }
11349	public function setData ( $ data ) { $ data = $ this -> transformer -> encode ( $ data ) ; foreach ( $ this -> fields as $ field ) { if ( isset ( $ data [ $ field -> getName ( ) ] ) ) { $ field -> setData ( $ data [ $ field -> getName ( ) ] ) ; } } }
5353	public function getSupportedAuthentication ( ) { if ( empty ( $ this -> data -> authentication ) || empty ( $ this -> data -> authentication ) ) { return array ( ) ; } return ( array ) $ this -> data -> authentication ; }
6120	public function serverStart ( $ sid ) { if ( $ sid == $ this -> serverSelectedId ( ) ) { $ this -> serverDeselect ( ) ; } $ this -> execute ( "serverstart" , array ( "sid" => $ sid ) ) ; $ this -> serverListReset ( ) ; Signal :: getInstance ( ) -> emit ( "notifyServerstarted" , $ this , $ sid ) ; }
9938	private static function checkSheetTitle ( $ pValue ) { if ( str_replace ( self :: $ invalidCharacters , '' , $ pValue ) !== $ pValue ) { throw new Exception ( 'Invalid character found in sheet title' ) ; } if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 31 ) { throw new Exception ( 'Maximum 31 characters allowed in sheet title.' ) ; } return $ pValue ; }
1897	private function isExistingOptionalFile ( SplFileInfo $ file , string $ webDir ) : bool { $ path = $ file -> getRelativePathname ( ) ; return 'robots.txt' === $ path && $ this -> fs -> exists ( $ webDir . '/' . $ path ) ; }
2169	private function acceptLicense ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_license' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'license.html.twig' ) ; } $ this -> container -> get ( 'contao.install_tool' ) -> persistConfig ( 'licenseAccepted' , true ) ; return $ this -> getRedirectResponse ( ) ; }
7160	public function buildSaleView ( Model \ SaleInterface $ sale , array $ options = [ ] ) { $ this -> initialize ( $ sale , $ options ) ; $ this -> amountCalculator -> calculateSale ( $ sale ) ; $ grossResult = $ sale -> getGrossResult ( ) ; $ this -> view -> setGross ( new TotalView ( $ this -> formatter -> currency ( $ grossResult -> getGross ( $ this -> view -> isAti ( ) ) ) , $ this -> formatter -> currency ( $ grossResult -> getDiscount ( $ this -> view -> isAti ( ) ) ) , $ this -> formatter -> currency ( $ grossResult -> getBase ( $ this -> view -> isAti ( ) ) ) ) ) ; $ finalResult = $ sale -> getFinalResult ( ) ; $ this -> view -> setFinal ( new TotalView ( $ this -> formatter -> currency ( $ finalResult -> getBase ( ) ) , $ this -> formatter -> currency ( $ finalResult -> getTax ( ) ) , $ this -> formatter -> currency ( $ finalResult -> getTotal ( ) ) ) ) ; if ( $ this -> options [ 'private' ] && null !== $ margin = $ this -> marginCalculator -> calculateSale ( $ sale ) ) { $ prefix = $ margin -> isAverage ( ) ? '~' : '' ; $ this -> view -> setMargin ( new MarginView ( $ prefix . $ this -> formatter -> currency ( $ margin -> getAmount ( ) ) , $ prefix . $ this -> formatter -> percent ( $ margin -> getPercent ( ) ) ) ) ; $ this -> view -> vars [ 'show_margin' ] = true ; } $ this -> buildSaleItemsLinesViews ( $ sale ) ; $ this -> buildSaleDiscountsLinesViews ( $ sale ) ; $ this -> buildShipmentLine ( $ sale ) ; $ this -> buildSaleTaxesViews ( $ sale ) ; foreach ( $ this -> types as $ type ) { $ type -> buildSaleView ( $ sale , $ this -> view , $ this -> options ) ; } $ columnsCount = 6 ; if ( $ this -> view -> vars [ 'show_availability' ] ) { $ columnsCount ++ ; } if ( $ this -> view -> vars [ 'show_discounts' ] = 0 < count ( $ grossResult -> getDiscountAdjustments ( ) ) ) { $ columnsCount += 3 ; } if ( $ this -> view -> vars [ 'show_taxes' ] = 1 < count ( $ finalResult -> getTaxAdjustments ( ) ) ) { $ columnsCount ++ ; } if ( $ this -> view -> vars [ 'show_margin' ] ) { $ columnsCount ++ ; } if ( $ this -> options [ 'editable' ] ) { $ columnsCount ++ ; } $ this -> view -> vars [ 'columns_count' ] = $ columnsCount ; return $ this -> view ; }
5606	public function paintGroupStart ( $ group , $ size ) { $ this -> group = self :: escapeVal ( $ group ) ; if ( $ this -> cc ) { if ( extension_loaded ( 'xdebug' ) ) { xdebug_start_code_coverage ( XDEBUG_CC_UNUSED | XDEBUG_CC_DEAD_CODE ) ; } } }
1229	private function expr ( $ rbp = 0 ) { $ left = $ this -> { "nud_{$this->token['type']}" } ( ) ; while ( $ rbp < self :: $ bp [ $ this -> token [ 'type' ] ] ) { $ left = $ this -> { "led_{$this->token['type']}" } ( $ left ) ; } return $ left ; }
4907	public function onRoute ( MvcEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ ajax = $ request -> getQuery ( ) -> get ( 'ajax' ) ; if ( ! $ request -> isXmlHttpRequest ( ) || ! $ ajax ) { return ; } $ response = $ event -> getResponse ( ) ; $ ajaxEvent = $ this -> ajaxEventManager -> getEvent ( $ ajax , $ this ) ; $ ajaxEvent -> setRequest ( $ request ) ; $ ajaxEvent -> setResponse ( $ response ) ; $ results = $ this -> ajaxEventManager -> triggerEventUntil ( function ( $ r ) { return null !== $ r ; } , $ ajaxEvent ) ; $ result = $ results -> last ( ) ? : $ ajaxEvent -> getResult ( ) ; if ( ! $ result ) { throw new \ UnexpectedValueException ( 'No listener returned anything. Do not know what to do...' ) ; } if ( is_array ( $ result ) || $ result instanceof \ Traversable ) { $ result = Json :: encode ( $ result , true , [ 'enableJsonExprFinder' => true ] ) ; } $ contentType = $ ajaxEvent -> getContentType ( ) ; $ response -> getHeaders ( ) -> addHeaderLine ( 'Content-Type' , $ contentType ) ; $ response -> setContent ( $ result ) ; return $ response ; }
231	public function insert ( $ table , $ columns ) { $ command = $ this -> db -> createCommand ( ) -> insert ( $ table , $ columns ) ; if ( ! $ command -> execute ( ) ) { return false ; } $ tableSchema = $ this -> getTableSchema ( $ table ) ; $ result = [ ] ; foreach ( $ tableSchema -> primaryKey as $ name ) { if ( $ tableSchema -> columns [ $ name ] -> autoIncrement ) { $ result [ $ name ] = $ this -> getLastInsertID ( $ tableSchema -> sequenceName ) ; break ; } $ result [ $ name ] = isset ( $ columns [ $ name ] ) ? $ columns [ $ name ] : $ tableSchema -> columns [ $ name ] -> defaultValue ; } return $ result ; }
5547	public function getMethod ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getMethod ( ) ; } return $ this -> frameset -> getMethod ( ) ; }
7337	public function createClient ( ) : TgLog { $ this -> loop = Factory :: create ( ) ; $ handler = new HttpClientRequestHandler ( $ this -> loop ) ; return new TgLog ( $ this -> token , $ handler ) ; }
4958	public function attach ( EventManagerInterface $ events , $ priority = 1 ) { $ callback = array ( $ this , 'injectXmlTemplate' ) ; $ this -> sharedListeners [ ] = $ events -> getSharedManager ( ) -> attach ( 'Zend\Stdlib\DispatchableInterface' , MvcEvent :: EVENT_DISPATCH , $ callback , - 96 ) ; $ this -> listeners [ ] = $ events -> attach ( MvcEvent :: EVENT_DISPATCH_ERROR , $ callback , - 96 ) ; $ this -> listeners [ ] = $ events -> attach ( MvcEvent :: EVENT_RENDER_ERROR , $ callback , - 96 ) ; }
10084	protected function write ( $ stream , $ text ) { $ fp = fopen ( $ stream , 'a' ) ; fwrite ( $ fp , $ text ) ; fclose ( $ fp ) ; }
10634	public function getArrayFromJsonFile ( $ strFilePath , $ strFileName ) { $ jSonContent = $ this -> getFileJsonContent ( $ strFilePath , $ strFileName ) ; $ arrayToReturn = json_decode ( $ jSonContent , true ) ; if ( json_last_error ( ) != JSON_ERROR_NONE ) { $ fName = $ this -> gluePathWithFileName ( $ strFilePath , $ strFileName ) ; throw new \ RuntimeException ( sprintf ( 'Unable to interpret JSON from %s file...' , $ fName ) ) ; } return $ arrayToReturn ; }
3075	public function process ( ) { $ this -> validate ( ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> pause ( $ serviceContext ) ; $ response = [ 'success' => $ result ] ; } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
9803	public function setCreated ( $ time ) { if ( $ time === null ) { $ time = time ( ) ; } elseif ( is_string ( $ time ) ) { if ( is_numeric ( $ time ) ) { $ time = ( int ) $ time ; } else { $ time = strtotime ( $ time ) ; } } $ this -> created = $ time ; return $ this ; }
10797	public function getCryptedPassword ( $ password ) { $ bcrypt = new Bcrypt ; $ bcrypt -> setCost ( $ this -> getOptions ( ) -> getPasswordCost ( ) ) ; return $ bcrypt -> create ( $ password ) ; }
5104	public function execute ( ) { if ( is_null ( $ this -> conn ) ) throw new SquidException ( "Can't execute query, implicitly created without connection!" ) ; $ cmd = $ this -> assemble ( ) ; $ bind = $ this -> bind ( ) ; return $ this -> conn -> execute ( $ cmd , $ bind ) ; }
5082	public function deleteRemap ( $ sMethod ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sMethod = 'put' . ucfirst ( $ oUri -> segment ( 4 ) ) ; if ( method_exists ( $ this , $ sMethod ) ) { return $ this -> $ sMethod ( ) ; } $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ oItem = $ this -> lookUpResource ( ) ; if ( ! $ oItem ) { throw new ApiException ( 'Resource not found' , $ oHttpCodes :: STATUS_NOT_FOUND ) ; } $ this -> userCan ( static :: ACTION_DELETE , $ oItem ) ; if ( ! $ this -> oModel -> delete ( $ oItem -> id ) ) { throw new ApiException ( 'Failed to delete resource. ' . $ this -> oModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } return Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; }
5195	protected function getMethodResult ( $ method , array $ arguments ) { if ( ! is_callable ( [ 'Elasticsearch\Client' , $ method ] ) ) { trigger_error ( sprintf ( 'Call to undefined or protected/private method %s::%s()' , get_called_class ( ) , $ method ) , E_USER_ERROR ) ; } if ( empty ( $ this -> results [ $ method ] ) ) { throw new \ Exception ( sprintf ( "ElasticsearchMock results is empty for %s" , $ method ) ) ; } $ this -> calls [ $ method ] [ ] = $ arguments ; return array_shift ( $ this -> results [ $ method ] ) ; }
10585	public static function createFile ( string $ name , int $ maxAttempts = 10 ) : entity \ FileEntity { $ tmpdir = static :: getDir ( ) ; $ name = \ sndsgd \ Fs :: sanitizeName ( $ name ) ; $ pos = strrpos ( $ name , "." ) ; if ( $ pos === false ) { $ extension = "" ; } else { $ extension = substr ( $ name , $ pos ) ; $ name = substr ( $ name , 0 , $ pos ) ; } $ attempts = 1 ; do { if ( $ attempts > $ maxAttempts ) { throw new \ RuntimeException ( "failed to create temp file; " . "reached max number ($maxAttempts) of attempts" ) ; } $ rand = \ sndsgd \ Str :: random ( 10 ) ; $ path = "$tmpdir/$name-$rand$extension" ; $ attempts ++ ; } while ( file_exists ( $ path ) ) ; touch ( $ path ) ; $ file = new entity \ FileEntity ( $ path ) ; static :: registerEntity ( $ file ) ; return $ file ; }
3139	public function storeItemResponse ( RunnerServiceContext $ context , $ itemRef , $ responses ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ this -> getCurrentAssessmentSession ( $ context ) ; try { \ common_Logger :: t ( 'Responses sent from the client-side. The Response Processing will take place.' ) ; if ( $ context -> isAdaptive ( ) ) { $ session -> beginItemSession ( ) ; $ session -> beginAttempt ( ) ; $ session -> endAttempt ( $ responses ) ; $ assessmentItem = $ session -> getAssessmentItem ( ) ; $ assessmentItemIdentifier = $ assessmentItem -> getIdentifier ( ) ; $ score = $ session -> getVariable ( 'SCORE' ) ; $ output = $ context -> getLastCatItemOutput ( ) ; if ( $ score !== null ) { $ output [ $ assessmentItemIdentifier ] = new ItemResult ( $ assessmentItemIdentifier , new ResultVariable ( $ score -> getIdentifier ( ) , BaseType :: getNameByConstant ( $ score -> getBaseType ( ) ) , $ score -> getValue ( ) -> getValue ( ) , null , $ score -> getCardinality ( ) ) , microtime ( true ) ) ; } else { \ common_Logger :: i ( "No 'SCORE' outcome variable for item '${assessmentItemIdentifier}' involved in an adaptive section." ) ; } $ context -> persistLastCatItemOutput ( $ output ) ; $ resultTransmitter = new \ taoQtiCommon_helpers_ResultTransmitter ( $ context -> getSessionManager ( ) -> getResultServer ( ) ) ; $ outcomeVariables = [ ] ; $ hrefParts = explode ( '|' , $ assessmentItem -> getHref ( ) ) ; $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ itemIdentifier = $ assessmentItem -> getIdentifier ( ) ; $ attempt = $ context -> getCatAttempts ( $ itemIdentifier ) ; $ transmissionId = "${sessionId}.${itemIdentifier}.${attempt}" ; $ attempt ++ ; foreach ( $ session -> getAllVariables ( ) as $ var ) { if ( $ var -> getIdentifier ( ) === 'numAttempts' ) { $ var -> setValue ( new \ qtism \ common \ datatypes \ QtiInteger ( $ attempt ) ) ; } $ variables [ ] = $ var ; } $ resultTransmitter -> transmitItemVariable ( $ variables , $ transmissionId , $ hrefParts [ 0 ] , $ hrefParts [ 2 ] ) ; $ context -> persistCatAttempts ( $ itemIdentifier , $ attempt ) ; $ context -> getTestSession ( ) -> endAttempt ( new State ( ) , true ) ; } else { $ session -> endAttempt ( $ responses , true ) ; } return true ; } catch ( AssessmentTestSessionException $ e ) { \ common_Logger :: w ( $ e -> getMessage ( ) ) ; return false ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
473	public function batchInsert ( $ table , $ columns , $ rows ) { $ time = $ this -> beginCommand ( "insert into $table" ) ; $ this -> db -> createCommand ( ) -> batchInsert ( $ table , $ columns , $ rows ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
5568	public function put ( $ url , $ parameters = false , $ content_type = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } return $ this -> load ( $ url , new SimplePutEncoding ( $ parameters , $ content_type ) ) ; }
4442	public function completed ( int $ offset = 0 , int $ count = 25 ) { return $ this -> client -> jobs ( 'complete' , null , $ offset , $ count ) ; }
8388	public function addInnerJoin ( $ table , $ on ) { $ this -> innerJoins [ ] = array ( 'table' => $ table , 'on' => ( $ on instanceof Condition ? $ on : new Condition ( $ on ) ) ) ; return $ this ; }
1601	public function injectRobots ( ) { $ headers = \ Craft :: $ app -> getResponse ( ) -> getHeaders ( ) ; if ( \ Craft :: $ app -> config -> general -> devMode ) { $ headers -> set ( 'x-robots-tag' , 'none, noimageindex' ) ; return ; } list ( $ field , $ element ) = $ this -> _getElementAndSeoFields ( ) ; $ robots = $ field -> robots ; if ( $ robots !== null ) $ headers -> set ( 'x-robots-tag' , $ robots ) ; if ( isset ( $ element -> expiryDate ) ) $ expiry = $ element -> expiryDate -> format ( \ DATE_RFC850 ) ; else $ expiry = null ; if ( $ expiry ) $ headers -> add ( 'x-robots-tag' , 'unavailable_after: ' . $ expiry ) ; }
5056	public function attachEvents ( EventManagerInterface $ events , array $ eventsSpec = null ) { if ( null === $ eventsSpec ) { $ eventsSpec = $ this -> eventsProvider ( ) ; } foreach ( $ eventsSpec as $ spec ) { if ( ! is_array ( $ spec ) || 2 > count ( $ spec ) ) { throw new \ UnexpectedValueException ( 'Event specification must be an array with at least two entries: event name and method name.' ) ; } $ event = $ spec [ 0 ] ; $ method = $ spec [ 1 ] ; $ priority = isset ( $ spec [ 2 ] ) ? $ spec [ 2 ] : 0 ; $ this -> listeners [ ] = $ events -> attach ( $ event , [ $ this , $ method ] , $ priority ) ; } return $ this ; }
2964	public function performRequest ( $ method , $ path , array $ params = [ ] ) { $ request = $ this -> buildRequest ( $ method , $ path , $ params ) ; try { $ response = $ this -> httpClient -> send ( $ request ) ; $ content = json_decode ( $ response -> getBody ( ) -> getContents ( ) , true ) ; } catch ( ClientException $ ex ) { if ( $ ex -> getResponse ( ) -> getStatusCode ( ) == 401 ) { if ( $ this -> isPsr7Version ( ) ) { $ uri = $ request -> getUri ( ) ; } else { $ uri = $ request -> getUrl ( ) ; } $ message = sprintf ( 'Unauthorized %s Request to %s' , $ request -> getMethod ( ) , $ uri ) ; throw new UnauthorizedRequestException ( $ message ) ; } throw $ ex ; } return $ this -> createResponseFromData ( $ content ) ; }
6900	public function close ( ) : void { if ( $ this -> is_active ( ) ) { $ this -> _data [ 'last_active' ] = time ( ) ; config ( 'debug' ) ? session_write_close ( ) : @ session_write_close ( ) ; } }
8544	public function setRefundEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RefundEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12614	public function have_required_properties ( ) { return ( ! empty ( $ this -> handle ) && ! empty ( $ this -> relative_path ) && ! empty ( $ this -> filename ) ) ; }
7899	protected function isProviderAliasExists ( $ provider ) { return array_key_exists ( $ provider , $ this -> providers ) || array_key_exists ( $ provider , $ this -> customProviders ) ; }
9450	protected function pathExtract ( ) : array { $ regExp = [ ] ; $ path = $ this -> path ; if ( \ is_array ( $ this -> path ) ) { $ regExp = \ array_pop ( $ this -> path ) ; $ path = \ array_pop ( $ this -> path ) ; } return [ $ path , $ regExp ] ; }
2696	public function afterGetType ( Config $ config , $ result ) { if ( ! ( $ config instanceof \ Fastly \ Cdn \ Model \ Config ) ) { if ( $ result == \ Fastly \ Cdn \ Model \ Config :: FASTLY ) { return Config :: VARNISH ; } } return $ result ; }
1684	public function checkAdminStatus ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == '' && $ this -> User -> id == $ dc -> id ) { $ varValue = 1 ; } return $ varValue ; }
9080	private static function parseElement ( Request & $ req , $ serverVars , $ elementName , $ paramName ) { if ( isset ( $ serverVars [ $ elementName ] ) ) { $ req -> setParam ( $ paramName , $ serverVars [ $ elementName ] ) ; } }
2716	public function addTextInput ( $ id , $ label , $ comment , $ required = true ) { $ this -> children [ $ id ] = [ 'id' => $ id , 'type' => 'text' , 'translate' => 'label comment' , 'showInDefault' => 1 , 'showInWebsite' => 0 , 'showInStore' => 0 , 'sortOrder' => count ( $ this -> children ) , 'label' => $ label , 'comment' => $ comment , 'validate' => ( $ required == true ) ? 'required-entry' : '' , '_elementType' => 'field' , 'path' => self :: BASE_CONFIG_PATH . '/' . $ this -> id ] ; }
4968	public function fromQuery ( $ param = null , $ default = null ) { if ( $ param === null ) { return $ this -> event -> getRequest ( ) -> getQuery ( $ param , $ default ) -> toArray ( ) ; } return $ this -> event -> getRequest ( ) -> getQuery ( $ param , $ default ) ; }
3945	public function onLoadDataContainer ( $ tableName ) { static $ tableExists ; if ( null === $ tableExists ) { $ tableExists = \ System :: getContainer ( ) -> get ( 'database_connection' ) -> getSchemaManager ( ) -> tablesExist ( [ 'tl_metamodel' ] ) ; } if ( false === $ tableExists ) { return ; } $ this -> handleMetaModelTable ( $ tableName ) ; $ this -> handleNonMetaModelTable ( $ tableName ) ; }
11635	public function getPageByDeviceId ( array $ deviceIdentifier , $ raw = false ) { $ params = [ 'type' => 1 , 'device_identifier' => $ deviceIdentifier , ] ; $ result = $ this -> parseJSON ( 'json' , [ self :: API_RELATION_SEARCH , $ params ] ) ; if ( $ raw === true ) { return $ result ; } $ page_ids = [ ] ; if ( ! empty ( $ result -> data [ 'relations' ] ) ) { foreach ( $ result -> data [ 'relations' ] as $ item ) { $ page_ids [ ] = $ item [ 'page_id' ] ; } } return $ page_ids ; }
5255	public function makePagination ( QueryBuilder $ query = null ) { if ( is_null ( $ this -> _position ) ) { throw new Exception ( 'To use Paginationable trait you must fill _position property in your model' ) ; } $ model = static :: createInstance ( ) ; $ query = $ query ? : new QueryBuilder ( ) ; $ prevDoc = null ; $ nextDoc = null ; $ query -> fields ( ) ; $ prevPos = $ this -> _position - 1 ; if ( $ prevPos >= 0 ) { $ items = $ model -> search ( $ query -> from ( $ prevPos ) -> size ( 3 ) ) ; $ prevDoc = $ items -> first ( ) ; $ items = array_values ( $ items -> toArray ( ) ) ; if ( array_key_exists ( 2 , $ items ) ) { $ nextDoc = $ items [ 2 ] ; } } else { $ items = $ model -> search ( $ query -> from ( $ this -> _position ) -> size ( 2 ) ) ; $ total = $ items -> getTotal ( ) ; $ nextDoc = $ items -> last ( ) ; $ last = $ total - 1 ; $ items = $ model -> search ( $ query -> from ( $ last ) -> size ( 1 ) ) ; $ prevDoc = $ items -> first ( ) ; } if ( ! $ nextDoc ) { $ items = $ model -> search ( $ query -> from ( 0 ) -> size ( 1 ) ) ; $ nextDoc = $ items -> first ( ) ; } $ this -> _previous = $ prevDoc ; $ this -> _next = $ nextDoc ; }
6928	private function persistInvoice ( Invoice \ InvoiceInterface $ invoice ) { $ this -> persistenceHelper -> persistAndRecompute ( $ invoice , true ) ; foreach ( $ invoice -> getLines ( ) as $ line ) { $ this -> persistenceHelper -> persistAndRecompute ( $ line , true ) ; } $ this -> persistenceHelper -> persistAndRecompute ( $ invoice -> getShipment ( ) , false ) ; }
3595	public function registerCpUrlRules ( RegisterUrlRulesEvent $ event ) { if ( ! \ Craft :: $ app -> user -> identity ) return ; $ rules = [ 'settings/sitemap' => [ 'route' => 'sitemap/settings' , 'params' => [ 'source' => 'CpSettings' ] ] , 'settings/sitemap/save-sitemap' => [ 'route' => 'sitemap/settings/save-sitemap' , 'params' => [ 'source' => 'CpSettings' ] ] , ] ; $ event -> rules = array_merge ( $ event -> rules , $ rules ) ; }
7631	public function setContainerMetadata ( $ containerName = '' , $ metadata = array ( ) , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: isArray ( $ metadata , 'Meta data should be an array of key and value pairs.' ) ; if ( count ( $ metadata ) == 0 ) { return ; } $ headers = array ( ) ; $ headers = array_merge ( $ headers , $ this -> generateMetadataHeaders ( $ metadata ) ) ; foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'metadata' ) , 'PUT' , $ headers , false , null , self :: RESOURCE_CONTAINER , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
8762	public function upload ( $ input ) { $ validator = \ Validator :: make ( $ input , config ( 'dropzoner.validator' ) , config ( 'dropzoner.validator-messages' ) ) ; if ( $ validator -> fails ( ) ) { return response ( ) -> json ( [ 'error' => true , 'message' => $ validator -> messages ( ) -> first ( ) , 'code' => 400 ] , 400 ) ; } $ photo = $ input [ 'file' ] ; $ original_name = $ photo -> getClientOriginalName ( ) ; $ extension = $ photo -> getClientOriginalExtension ( ) ; $ original_name_without_extension = substr ( $ original_name , 0 , strlen ( $ original_name ) - strlen ( $ extension ) - 1 ) ; $ filename = $ this -> sanitize ( $ original_name_without_extension ) ; $ allowed_filename = $ this -> createUniqueFilename ( $ filename ) ; $ filename_with_extension = $ allowed_filename . '.' . $ extension ; $ manager = new ImageManager ( ) ; $ image = $ manager -> make ( $ photo ) -> save ( config ( 'dropzoner.upload-path' ) . $ filename_with_extension ) ; if ( ! $ image ) { return response ( ) -> json ( [ 'error' => true , 'message' => 'Server error while uploading' , 'code' => 500 ] , 500 ) ; } event ( new ImageWasUploaded ( $ original_name , $ filename_with_extension ) ) ; return response ( ) -> json ( [ 'error' => false , 'code' => 200 , 'filename' => $ filename_with_extension ] , 200 ) ; }
12680	public function hasFlag ( $ name ) { $ option = $ this -> definition -> getOption ( $ name ) ; if ( ! $ option -> isFlag ( ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "--%s" option is not a flag.' , $ name ) ) ; } return ! empty ( $ this -> options [ $ name ] ) ; }
9576	protected function resolveKernel ( ) { if ( $ this -> kernel !== null ) { return $ this -> kernel ; } $ class = 'Symfony\Component\EventDispatcher\EventDispatcherInterface' ; $ eventDispatcher = $ this -> container -> isBound ( $ class ) ? $ this -> container -> resolve ( $ class ) : null ; $ kernel = new Kernel ( $ this -> getRouter ( ) , $ this -> requests , $ this -> errorHandler , $ eventDispatcher ) ; return $ this -> kernel = $ this -> resolveStack ( ) -> resolve ( $ kernel ) ; }
3204	protected function detect_manual_editing ( $ version ) { if ( false === $ version || true === version_compare ( $ version , '2.2.0' , '<' ) ) { return ; } $ checkTokens = array ( T_FUNCTION => true , T_CLASS => true , T_ARRAY => true , T_OPEN_SHORT_ARRAY => true , ) ; for ( $ ptr = 0 ; $ ptr < $ this -> phpcsFile -> numTokens ; $ ptr ++ ) { if ( ! isset ( $ checkTokens [ $ this -> tokens [ $ ptr ] [ 'code' ] ] ) ) { continue ; } if ( T_CLASS === $ this -> tokens [ $ ptr ] [ 'code' ] && isset ( $ this -> tokens [ $ ptr ] [ 'scope_closer' ] ) ) { $ ptr = $ this -> tokens [ $ ptr ] [ 'scope_closer' ] ; continue ; } elseif ( T_OPEN_SHORT_ARRAY === $ this -> tokens [ $ ptr ] [ 'code' ] && isset ( $ this -> tokens [ $ ptr ] [ 'bracket_closer' ] ) ) { $ ptr = $ this -> tokens [ $ ptr ] [ 'bracket_closer' ] ; continue ; } elseif ( T_ARRAY === $ this -> tokens [ $ ptr ] [ 'code' ] && isset ( $ this -> tokens [ $ ptr ] [ 'parenthesis_closer' ] ) ) { $ ptr = $ this -> tokens [ $ ptr ] [ 'parenthesis_closer' ] ; continue ; } if ( T_FUNCTION === $ this -> tokens [ $ ptr ] [ 'code' ] ) { $ function_name = $ this -> phpcsFile -> getDeclarationName ( $ ptr ) ; if ( 'tgmpa' !== $ function_name ) { if ( isset ( $ this -> tokens [ $ ptr ] [ 'scope_closer' ] ) ) { $ ptr = $ this -> tokens [ $ ptr ] [ 'scope_closer' ] ; } continue ; } $ function_exists = $ this -> phpcsFile -> findPrevious ( T_STRING , ( $ ptr - 1 ) , null , false , 'function_exists' ) ; $ param = false ; if ( false !== $ function_exists ) { $ param = $ this -> get_function_call_parameter ( $ function_exists , 1 ) ; $ param = $ this -> strip_quotes ( $ param [ 'raw' ] ) ; } if ( false === $ function_exists || 'tgmpa' !== $ param ) { $ this -> phpcsFile -> recordMetric ( 0 , 'Manual editing detected' , 'yes' ) ; $ this -> phpcsFile -> addError ( 'Manual editing of the TGM Plugin Activation file detected. Your edit will cause fatal errors for end-users. Download an official copy using the Custom TGMPA Generator. http://tgmpluginactivation.com/download/' , 0 , 'ManualEditDetected' , array ( ) , 9 ) ; } else { $ this -> phpcsFile -> recordMetric ( 0 , 'Manual editing detected' , 'no' ) ; } break ; } } }
10920	public static function getString ( $ language , $ separator = ',' ) { $ fileName = __DIR__ . '/stop-words/' . $ language . '.txt' ; if ( file_exists ( $ fileName ) ) { return implode ( $ separator , array_map ( 'trim' , file ( $ fileName ) ) ) ; } return '' ; }
2927	protected function resetContent ( ) { $ this -> filePath = null ; $ this -> reader -> load ( null ) ; $ this -> writer -> setBuffer ( null ) ; }
5620	protected function chompCoordinates ( & $ url ) { if ( preg_match ( '/(.*)\?(\d+),(\d+)$/' , $ url , $ matches ) ) { $ url = $ matches [ 1 ] ; return array ( ( integer ) $ matches [ 2 ] , ( integer ) $ matches [ 3 ] ) ; } return array ( false , false ) ; }
2572	protected function loadSessionHandler ( $ params ) { if ( isset ( $ params [ 'sessionHandler' ] ) && $ params [ 'sessionHandler' ] instanceof Session \ Handler \ HandlerInterface ) { $ this -> sessionHandler = $ params [ 'sessionHandler' ] ; } }
9014	public function longtext ( string $ charset = null ) : self { $ this -> type = 'longtext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
10557	public function dispatchNextJobInChain ( ) { if ( ! empty ( $ this -> chained ) ) { new PendingDispatch ( tap ( unserialize ( array_shift ( $ this -> chained ) ) , function ( $ next ) { $ next -> chained = $ this -> chained ; } ) ) ; } }
145	public function propagateLiteral ( $ decidedLiteral , $ level , $ decisions ) { $ literal = - $ decidedLiteral ; if ( ! isset ( $ this -> watchChains [ $ literal ] ) ) { return null ; } $ chain = $ this -> watchChains [ $ literal ] ; $ chain -> rewind ( ) ; while ( $ chain -> valid ( ) ) { $ node = $ chain -> current ( ) ; $ otherWatch = $ node -> getOtherWatch ( $ literal ) ; if ( ! $ node -> getRule ( ) -> isDisabled ( ) && ! $ decisions -> satisfy ( $ otherWatch ) ) { $ ruleLiterals = $ node -> getRule ( ) -> getLiterals ( ) ; $ alternativeLiterals = array_filter ( $ ruleLiterals , function ( $ ruleLiteral ) use ( $ literal , $ otherWatch , $ decisions ) { return $ literal !== $ ruleLiteral && $ otherWatch !== $ ruleLiteral && ! $ decisions -> conflict ( $ ruleLiteral ) ; } ) ; if ( $ alternativeLiterals ) { reset ( $ alternativeLiterals ) ; $ this -> moveWatch ( $ literal , current ( $ alternativeLiterals ) , $ node ) ; continue ; } if ( $ decisions -> conflict ( $ otherWatch ) ) { return $ node -> getRule ( ) ; } $ decisions -> decide ( $ otherWatch , $ level , $ node -> getRule ( ) ) ; } $ chain -> next ( ) ; } return null ; }
412	public function getPort ( ) { if ( $ this -> _port === null ) { $ serverPort = $ this -> getServerPort ( ) ; $ this -> _port = ! $ this -> getIsSecureConnection ( ) && $ serverPort !== null ? $ serverPort : 80 ; } return $ this -> _port ; }
9681	function fromXML ( $ xmlElement ) { if ( $ xmlElement -> getName ( ) == "contacts" ) { foreach ( $ xmlElement -> children ( ) as $ contactXml ) { $ contact = new Contact ( ) ; $ contact -> fromXML ( $ contactXml ) ; $ this -> contacts [ ] = $ contact ; } } }
2090	public static function countPublishedBySourceAndParent ( $ strSource , $ intParent , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.source=? AND $t.parent=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } return static :: countBy ( $ arrColumns , array ( $ strSource , ( int ) $ intParent ) ) ; }
10611	public function confirmAction ( $ token ) { $ user = $ this -> get ( 'fos_user.user_manager' ) -> findUserByConfirmationToken ( $ token ) ; if ( null === $ user ) { throw new NotFoundHttpException ( sprintf ( 'The user with confirmation token "%s" does not exist' , $ token ) ) ; } $ user -> setConfirmationToken ( null ) ; $ user -> setEnabled ( true ) ; $ user -> setLastLogin ( new \ DateTime ( ) ) ; $ this -> get ( 'fos_user.user_manager' ) -> updateUser ( $ user ) ; $ response = $ this -> redirect ( $ this -> generateUrl ( 'miky_app_customer_registration_confirmed' ) ) ; $ this -> authenticateUser ( $ user , $ response ) ; return $ response ; }
9368	protected function globals ( Configuration $ config ) { $ cookies = $ config -> get ( 'app.http.cookies' , array ( ) ) ; $ files = $ config -> get ( 'app.http.files' , array ( ) ) ; $ get = $ config -> get ( 'app.http.get' , array ( ) ) ; $ post = $ config -> get ( 'app.http.post' , array ( ) ) ; $ server = $ config -> get ( 'app.http.server' , $ this -> server ( ) ) ; return array ( $ server , $ cookies , $ get , $ files , $ post ) ; }
4203	private function addProperties ( Event $ abs ) { if ( $ abs [ 'debugMethod' ] === 'table' && $ abs [ 'traverseValues' ] ) { return ; } $ obj = $ abs -> getSubject ( ) ; $ reflectionObject = $ abs [ 'reflector' ] ; while ( $ reflectionObject ) { $ className = $ reflectionObject -> getName ( ) ; $ properties = $ reflectionObject -> getProperties ( ) ; $ isDebugObj = $ className == __NAMESPACE__ ; while ( $ properties ) { $ reflectionProperty = \ array_shift ( $ properties ) ; $ name = $ reflectionProperty -> getName ( ) ; if ( isset ( $ abs [ 'properties' ] [ $ name ] ) ) { $ abs [ 'properties' ] [ $ name ] [ 'overrides' ] = $ this -> propOverrides ( $ reflectionProperty , $ abs [ 'properties' ] [ $ name ] , $ className ) ; $ abs [ 'properties' ] [ $ name ] [ 'originallyDeclared' ] = $ className ; continue ; } if ( $ isDebugObj && $ name == 'data' ) { $ abs [ 'properties' ] [ 'data' ] = \ array_merge ( self :: $ basePropInfo , array ( 'value' => array ( 'NOT INSPECTED' ) , 'visibility' => 'protected' , ) ) ; continue ; } $ abs [ 'properties' ] [ $ name ] = $ this -> getPropInfo ( $ abs , $ reflectionProperty ) ; } $ reflectionObject = $ reflectionObject -> getParentClass ( ) ; } $ this -> addPropertiesPhpDoc ( $ abs ) ; $ this -> addPropertiesDebug ( $ abs ) ; $ properties = $ abs [ 'properties' ] ; $ abs [ 'hist' ] [ ] = $ obj ; foreach ( $ properties as $ name => $ info ) { if ( $ this -> abstracter -> needsAbstraction ( $ info [ 'value' ] ) ) { $ properties [ $ name ] [ 'value' ] = $ this -> abstracter -> getAbstraction ( $ info [ 'value' ] , $ abs [ 'debugMethod' ] , $ abs [ 'hist' ] ) ; } } $ abs [ 'properties' ] = $ properties ; return ; }
9990	private function writeImageInCell ( Worksheet $ pSheet , $ coordinates ) { $ html = '' ; foreach ( $ pSheet -> getDrawingCollection ( ) as $ drawing ) { if ( $ drawing instanceof Drawing ) { if ( $ drawing -> getCoordinates ( ) == $ coordinates ) { $ filename = $ drawing -> getPath ( ) ; if ( substr ( $ filename , 0 , 1 ) == '.' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = $ this -> getImagesRoot ( ) . $ filename ; if ( substr ( $ filename , 0 , 1 ) == '.' && substr ( $ filename , 0 , 2 ) != './' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = htmlspecialchars ( $ filename ) ; $ html .= PHP_EOL ; if ( ( ! $ this -> embedImages ) || ( $ this -> isPdf ) ) { $ imageData = $ filename ; } else { $ imageDetails = getimagesize ( $ filename ) ; if ( $ fp = fopen ( $ filename , 'rb' , 0 ) ) { $ picture = fread ( $ fp , filesize ( $ filename ) ) ; fclose ( $ fp ) ; $ base64 = chunk_split ( base64_encode ( $ picture ) ) ; $ imageData = 'data:' . $ imageDetails [ 'mime' ] . ';base64,' . $ base64 ; } else { $ imageData = $ filename ; } } $ html .= '<div style="position: relative;">' ; $ html .= '<img style="position: absolute; z-index: 1; left: ' . $ drawing -> getOffsetX ( ) . 'px; top: ' . $ drawing -> getOffsetY ( ) . 'px; width: ' . $ drawing -> getWidth ( ) . 'px; height: ' . $ drawing -> getHeight ( ) . 'px;" src="' . $ imageData . '" border="0" />' ; $ html .= '</div>' ; } } elseif ( $ drawing instanceof MemoryDrawing ) { if ( $ drawing -> getCoordinates ( ) != $ coordinates ) { continue ; } ob_start ( ) ; imagepng ( $ drawing -> getImageResource ( ) ) ; $ contents = ob_get_contents ( ) ; ob_end_clean ( ) ; $ dataUri = 'data:image/jpeg;base64,' . base64_encode ( $ contents ) ; $ html .= '<img src="' . $ dataUri . '" style="max-width:100%;width:' . $ drawing -> getWidth ( ) . 'px;" />' ; } } return $ html ; }
5009	public function setSubject ( $ subject , $ translate = true ) { if ( false !== $ translate ) { $ translator = $ this -> getTranslator ( ) ; $ domain = $ this -> getTranslatorTextDomain ( ) ; if ( true === $ translate ) { $ subject = $ translator -> translate ( $ subject , $ domain ) ; } else { $ args = func_get_args ( ) ; $ args [ 0 ] = $ translator -> translate ( $ args [ 0 ] , $ domain ) ; $ subject = call_user_func_array ( 'sprintf' , $ args ) ; } } return parent :: setSubject ( $ subject ) ; }
1874	private function addComponents ( ContainerBuilder $ container ) : void { $ packages = $ container -> getDefinition ( 'assets.packages' ) ; $ context = new Reference ( 'contao.assets.assets_context' ) ; foreach ( Versions :: VERSIONS as $ name => $ version ) { if ( 0 !== strncmp ( 'contao-components/' , $ name , 18 ) ) { continue ; } $ serviceId = 'assets._package_' . $ name ; $ basePath = 'assets/' . substr ( $ name , 18 ) ; $ version = $ this -> createVersionStrategy ( $ container , $ version , $ name ) ; $ container -> setDefinition ( $ serviceId , $ this -> createPackageDefinition ( $ basePath , $ version , $ context ) ) ; $ packages -> addMethodCall ( 'addPackage' , [ $ name , new Reference ( $ serviceId ) ] ) ; } }
3155	public function storeOutcomeVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getOutcomeVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
5543	public function getFrames ( ) { $ report = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ report [ $ this -> getPublicNameFromIndex ( $ i ) ] = $ this -> frames [ $ i ] -> getFrames ( ) ; } return $ report ; }
238	protected function normalizePdoRowKeyCase ( array $ row , $ multiple ) { if ( $ this -> db -> getSlavePdo ( ) -> getAttribute ( \ PDO :: ATTR_CASE ) !== \ PDO :: CASE_UPPER ) { return $ row ; } if ( $ multiple ) { return array_map ( function ( array $ row ) { return array_change_key_case ( $ row , CASE_LOWER ) ; } , $ row ) ; } return array_change_key_case ( $ row , CASE_LOWER ) ; }
6645	public static function formatPhoneNumberToInternationalFormat ( $ countryCode , $ number , $ numberLength ) { $ actualNumber = substr ( $ number , - ( $ numberLength ) , $ numberLength ) ; if ( ! $ actualNumber ) { return $ number ; } return '+' . $ countryCode . $ actualNumber ; }
4511	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! $ this -> accessor -> isReadable ( $ payload , $ this -> property ) ) { $ event -> markAsInvalid ( ) ; } }
9153	public function getUrlString ( ) : string { $ query = "" ; if ( strlen ( $ this -> queryString ) > 0 ) { $ query = sprintf ( "?%s" , $ this -> queryString ) ; } if ( ( $ this -> scheme == 'http' && $ this -> getPort ( ) == 80 ) || ( $ this -> scheme == 'ftp' && $ this -> getPort ( ) == 21 ) || ( $ this -> scheme == 'https' && $ this -> getPort ( ) == 443 ) ) { return sprintf ( "%s://%s%s%s" , $ this -> scheme , $ this -> getAddress ( ) , $ this -> path , $ query ) ; } return sprintf ( "%s://%s:%d%s%s" , $ this -> scheme , $ this -> getAddress ( ) , $ this -> getPort ( ) , $ this -> path , $ query ) ; }
9937	private static function checkSheetCodeName ( $ pValue ) { $ CharCount = Shared \ StringHelper :: countCharacters ( $ pValue ) ; if ( $ CharCount == 0 ) { throw new Exception ( 'Sheet code name cannot be empty.' ) ; } if ( ( str_replace ( self :: $ invalidCharacters , '' , $ pValue ) !== $ pValue ) || ( Shared \ StringHelper :: substring ( $ pValue , - 1 , 1 ) == '\'' ) || ( Shared \ StringHelper :: substring ( $ pValue , 0 , 1 ) == '\'' ) ) { throw new Exception ( 'Invalid character found in sheet code name' ) ; } if ( $ CharCount > 31 ) { throw new Exception ( 'Maximum 31 characters allowed in sheet code name.' ) ; } return $ pValue ; }
10701	public static function isBirthNumber ( $ no ) { if ( ! preg_match ( '#^\s*(\d\d)(\d\d)(\d\d)[ /]*(\d\d\d)(\d?)\s*$#' , $ no , $ matches ) ) { return false ; } list ( , $ year , $ month , $ day , $ ext , $ c ) = $ matches ; if ( $ c === '' ) { $ year += $ year < 54 ? 1900 : 1800 ; } else { $ mod = ( $ year . $ month . $ day . $ ext ) % 11 ; if ( $ mod === 10 ) { $ mod = 0 ; } if ( $ mod !== ( int ) $ c ) { return false ; } $ year += $ year < 54 ? 2000 : 1900 ; } if ( $ year > 2003 ) { if ( $ month > 70 ) { $ month -= 70 ; } if ( $ month > 20 && $ month < 50 ) { $ month -= 20 ; } } if ( $ month > 50 ) { $ month -= 50 ; } return checkdate ( $ month , $ day , $ year ) ; }
2040	private function createConfigItem ( $ imageSize ) : PictureConfigurationItem { $ configItem = new PictureConfigurationItem ( ) ; $ resizeConfig = new ResizeConfiguration ( ) ; if ( null !== $ imageSize ) { $ resizeConfig -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; $ configItem -> setResizeConfig ( $ resizeConfig ) -> setSizes ( $ imageSize -> sizes ) -> setDensities ( $ imageSize -> densities ) ; if ( isset ( $ imageSize -> media ) ) { $ configItem -> setMedia ( $ imageSize -> media ) ; } } return $ configItem ; }
4230	public static function getParsed ( $ what ) { $ hash = null ; if ( \ is_object ( $ what ) ) { $ hash = self :: getHash ( $ what ) ; if ( isset ( self :: $ cache [ $ hash ] ) ) { return self :: $ cache [ $ hash ] ; } } $ comment = self :: getCommentContent ( $ what ) ; if ( \ is_array ( $ comment ) ) { return $ comment ; } $ return = array ( 'summary' => null , 'description' => null , ) ; if ( \ preg_match ( '/^@/m' , $ comment , $ matches , PREG_OFFSET_CAPTURE ) ) { $ pos = $ matches [ 0 ] [ 1 ] ; $ strTags = \ substr ( $ comment , $ pos ) ; $ return = \ array_merge ( $ return , self :: parseTags ( $ strTags ) ) ; $ comment = $ pos > 0 ? \ substr ( $ comment , 0 , $ pos - 1 ) : '' ; } $ comment = \ preg_replace ( '/^\\\@/m' , '@' , $ comment ) ; $ comment = \ str_replace ( '{@*}' , '*/' , $ comment ) ; $ split = \ preg_split ( '/(\.[\r\n]+|[\r\n]{2})/' , $ comment , 2 , PREG_SPLIT_DELIM_CAPTURE ) ; $ split = \ array_replace ( array ( '' , '' , '' ) , $ split ) ; $ return = \ array_merge ( $ return , \ array_filter ( array ( 'summary' => \ trim ( $ split [ 0 ] . $ split [ 1 ] ) , 'desc' => \ trim ( $ split [ 2 ] ) , ) ) ) ; if ( $ hash ) { self :: $ cache [ $ hash ] = $ return ; } return $ return ; }
1466	public static function doesRequestHaveBody ( $ request ) { if ( self :: hasHeader ( $ request , 'Transfer-Encoding' ) ) { return true ; } ; if ( 1 > self :: getHeader ( $ request , 'Content-Length' ) ) { return false ; } return true ; }
5061	public function calculateWidth ( $ text , $ size = self :: TEXT_SIZE ) { $ size = $ this -> convertToPt ( $ size ) ; $ box = imagettfbbox ( $ size , 0 , $ this -> fontPath , $ text ) ; return round ( abs ( $ box [ 2 ] - $ box [ 0 ] ) + self :: SHIELD_PADDING_EXTERNAL + self :: SHIELD_PADDING_INTERNAL , 1 ) ; }
6734	protected function handleException ( \ Throwable $ e , Request $ request ) : Response { if ( ! $ e instanceof Exception \ Exception ) { $ e = new Exception \ UncaughtException ( $ e ) ; } $ code = $ e -> getStatusCode ( ) ; if ( $ this -> exceptionHandlers [ $ code ] instanceof ExceptionHandler ) { return $ this -> exceptionHandlers [ $ code ] -> handle ( $ e , $ request ) ; } elseif ( $ this -> defaultExceptionHandler instanceof ExceptionHandler ) { return $ this -> defaultExceptionHandler -> handle ( $ e , $ request ) ; } else { return ( new \ Circuit \ ExceptionHandler \ DefaultHandler ) -> handle ( $ e , $ request ) ; } }
2858	public function layoutUpdatesAction ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; if ( ! $ token ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; } $ layoutUpdates = $ requestProfile -> getDesign ( ) -> getLayoutUpdates ( ) ; $ this -> renderArray ( $ layoutUpdates , 'No Data' , array ( '#' , 'XML' ) ) ; }
206	public static function stdin ( $ raw = false ) { return $ raw ? fgets ( \ STDIN ) : rtrim ( fgets ( \ STDIN ) , PHP_EOL ) ; }
2492	protected function defineEndpoint ( ContainerBuilder $ container , $ alias , $ params ) { $ definition = new Definition ( self :: ENDPOINT_CLASS , array ( $ params ) ) ; $ definition -> addTag ( self :: ENDPOINT_TAG , array ( 'alias' => $ alias ) ) ; $ container -> setDefinition ( sprintf ( $ this -> getAlias ( ) . '.endpoints.%s' , $ alias ) , $ definition ) ; }
2466	protected function welcomeScreen ( ) { System :: loadLanguageFile ( 'explain' ) ; $ objTemplate = new BackendTemplate ( 'be_welcome' ) ; $ objTemplate -> messages = Message :: generateUnwrapped ( ) . Backend :: getSystemMessages ( ) ; $ objTemplate -> loginMsg = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'firstLogin' ] ; if ( $ this -> User -> lastLogin > 0 ) { $ formatter = new DateTimeFormatter ( System :: getContainer ( ) -> get ( 'translator' ) ) ; $ diff = $ formatter -> formatDiff ( new \ DateTime ( date ( 'Y-m-d H:i:s' , $ this -> User -> lastLogin ) ) , new \ DateTime ( ) ) ; $ objTemplate -> loginMsg = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lastLogin' ] [ 1 ] , '<time title="' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ this -> User -> lastLogin ) . '">' . $ diff . '</time>' ) ; } Versions :: addToTemplate ( $ objTemplate ) ; $ objTemplate -> showDifferences = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) ) ; $ objTemplate -> recordOfTable = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] ) ) ; $ objTemplate -> systemMessages = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'systemMessages' ] ; $ objTemplate -> shortcuts = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 0 ] ; $ objTemplate -> shortcutsLink = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 1 ] ; $ objTemplate -> editElement = StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'editElement' ] ) ; return $ objTemplate -> parse ( ) ; }
12203	public function subscribe ( $ events ) { $ events -> listen ( 'Neonbug\\Common\\Events\\AdminAddEditPrepareField' , function ( $ event ) { if ( $ event -> field [ 'type' ] != 'user_admin::add_fields.role' ) return ; $ roles = \ Neonbug \ Common \ Models \ Role :: all ( ) ; $ roles_by_key = [ ] ; foreach ( $ roles as $ role ) { if ( $ role -> id_role == 'admin' ) continue ; $ roles_by_key [ $ role -> id_role ] = $ role -> name ; } $ event -> field [ 'values' ] = $ roles_by_key ; $ selected_roles = [ ] ; if ( $ event -> item != null ) { foreach ( $ event -> item -> roles as $ role ) { $ selected_roles [ ] = $ role -> id_role ; } } $ event -> field [ 'selected_roles' ] = $ selected_roles ; } ) ; }
10910	public function decorate ( callable $ decorator ) : Binding { if ( empty ( $ this -> definition -> decorators ) ) { $ this -> definition -> decorators = [ ] ; } $ this -> definition -> decorators [ ] = new Decorator ( $ decorator ) ; return $ this ; }
8801	public function set ( $ key , $ value ) { if ( is_array ( $ key ) ) { foreach ( $ key as $ k => $ v ) { $ _SESSION [ $ k ] = $ v ; } } else { $ _SESSION [ $ key ] = $ value ; } return ; }
34	protected function jobToText ( $ job ) { $ packageName = $ job [ 'packageName' ] ; $ constraint = $ job [ 'constraint' ] ; switch ( $ job [ 'cmd' ] ) { case 'install' : $ packages = $ this -> pool -> whatProvides ( $ packageName , $ constraint ) ; if ( ! $ packages ) { return 'No package found to satisfy install request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) ; } return 'Installation request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . ' -> satisfiable by ' . $ this -> getPackageList ( $ packages ) . '.' ; case 'update' : return 'Update request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . '.' ; case 'remove' : return 'Removal request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . '' ; } if ( isset ( $ constraint ) ) { $ packages = $ this -> pool -> whatProvides ( $ packageName , $ constraint ) ; } else { $ packages = array ( ) ; } return 'Job(cmd=' . $ job [ 'cmd' ] . ', target=' . $ packageName . ', packages=[' . $ this -> getPackageList ( $ packages ) . '])' ; }
480	public function alterColumn ( $ table , $ column , $ type ) { $ time = $ this -> beginCommand ( "alter column $column in table $table to $type" ) ; $ this -> db -> createCommand ( ) -> alterColumn ( $ table , $ column , $ type ) -> execute ( ) ; if ( $ type instanceof ColumnSchemaBuilder && $ type -> comment !== null ) { $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ type -> comment ) -> execute ( ) ; } $ this -> endCommand ( $ time ) ; }
10515	public function inc ( $ key , $ expire = 0 ) { $ this -> getLock ( $ key ) ; $ this -> set ( $ key , ( int ) $ this -> get ( $ key ) + 1 ) ; $ this -> releaseLock ( $ key ) ; return true ; }
10595	protected function initViewPanelTableData ( ) { $ items = [ ] ; $ currentRouteName = $ this -> currentRoute ? $ this -> currentRoute -> GetName ( ) : NULL ; foreach ( $ this -> routes as & $ route ) { $ matched = FALSE ; if ( $ currentRouteName !== NULL && $ route -> GetName ( ) === $ currentRouteName ) { $ matched = TRUE ; } $ items [ ] = $ this -> initViewPanelTableRow ( $ route , $ matched ) ; } $ this -> view -> items = $ items ; }
10035	function unsubscribeContactByExternalId ( $ externalId , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } $ encodedExternalId = utf8_encode ( $ externalId ) ; return $ this -> delete ( "contacts/externalid/${encodedExternalId}/unsubscribe" , $ queryParameters ) ; }
3766	private function addInputScreenTranslations ( StaticTranslator $ translator , $ inputScreen , $ containerName ) { $ currentLocale = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ inputScreen [ 'legends' ] as $ legendName => $ legendInfo ) { foreach ( $ legendInfo [ 'label' ] as $ langCode => $ label ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName , $ langCode ) ; if ( $ currentLocale === $ langCode ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName ) ; } } } }
6333	public function validateChecksum ( $ string ) { $ xml = new \ SimpleXMLElement ( $ string ) ; $ checksum = ( string ) $ xml -> Authentication -> Checksum ; $ original = str_replace ( $ checksum , $ this -> getMerchantPassword ( ) , $ string ) ; return md5 ( $ original ) == $ checksum ; }
8059	public function setSemaphore ( Semaphore $ semaphore ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Worker Pool Size for a created pool.' ) ; } if ( ! $ semaphore -> isCreated ( ) ) { throw new \ InvalidArgumentException ( 'The Semaphore hasn\'t yet been created.' ) ; } $ this -> semaphore = $ semaphore ; return $ this ; }
9099	public function serve ( ServiceCallback $ callback ) { $ this -> bind ( ) ; $ this -> listen ( ) ; $ runOn = true ; while ( $ runOn ) { $ clientHandle = @ socket_accept ( $ this -> handle ) ; if ( ! is_resource ( $ clientHandle ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ address = null ; $ port = 0 ; if ( ! @ socket_getpeername ( $ clientHandle , $ address , $ port ) ) { $ code = socket_last_error ( $ clientHandle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ client = new ClientSocket ( new Endpoint ( $ address , $ port ) , $ clientHandle ) ; $ runOn = boolval ( $ callback -> callback ( $ client ) ) ; } }
7130	public function getNotifications ( $ type = null ) { if ( null !== $ type ) { NotificationTypes :: isValidType ( $ type ) ; return $ this -> notifications -> filter ( function ( NotificationInterface $ n ) use ( $ type ) { return $ n -> getType ( ) === $ type ; } ) ; } return $ this -> notifications ; }
4790	function insert_update ( array $ unique , array $ insert , array $ update = array ( ) ) { if ( ! $ update ) { $ update = $ insert ; } $ insert = $ unique + $ insert ; $ values = "(" . implode ( ", " , array_keys ( $ insert ) ) . ") VALUES " . $ this -> quote ( $ insert ) ; if ( $ this -> notORM -> driver == "mysql" ) { $ set = array ( ) ; if ( ! $ update ) { $ update = $ unique ; } $ quoteChar = $ this -> getQuoteChar ( ) ; foreach ( $ update as $ key => $ val ) { $ set [ ] = "{$quoteChar}{$key}{$quoteChar} = " . $ this -> quote ( $ val ) ; } return $ this -> insert ( "$values ON DUPLICATE KEY UPDATE " . implode ( ", " , $ set ) ) ; } else { $ connection = $ this -> notORM -> connection ; $ errorMode = $ connection -> getAttribute ( PDO :: ATTR_ERRMODE ) ; $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , PDO :: ERRMODE_EXCEPTION ) ; try { $ return = $ this -> insert ( $ values ) ; $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , $ errorMode ) ; return $ return ; } catch ( PDOException $ e ) { $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , $ errorMode ) ; if ( $ e -> getCode ( ) == "23000" || $ e -> getCode ( ) == "23505" ) { if ( ! $ update ) { return 0 ; } $ clone = clone $ this ; $ return = $ clone -> where ( $ unique ) -> update ( $ update ) ; return ( $ return ? $ return + 1 : $ return ) ; } if ( $ errorMode == PDO :: ERRMODE_EXCEPTION ) { throw $ e ; } elseif ( $ errorMode == PDO :: ERRMODE_WARNING ) { trigger_error ( "PDOStatement::execute(): " . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } } return 0 ; }
6891	protected function createAssignmentsForQuantity ( SaleItemInterface $ item , $ quantity ) { if ( 0 >= $ quantity ) { return ; } $ stockUnits = $ this -> sortStockUnits ( $ this -> unitResolver -> findAssignable ( $ item ) ) ; foreach ( $ stockUnits as $ stockUnit ) { $ assignment = $ this -> saleFactory -> createStockAssignmentForItem ( $ item ) ; $ assignment -> setSaleItem ( $ item ) -> setStockUnit ( $ stockUnit ) ; $ quantity -= $ this -> assignmentUpdater -> updateSold ( $ assignment , $ quantity ) ; if ( 0 == $ quantity ) { return ; } } if ( 0 < $ quantity ) { $ stockUnit = $ this -> unitResolver -> createBySubjectRelative ( $ item ) ; $ assignment = $ this -> saleFactory -> createStockAssignmentForItem ( $ item ) ; $ assignment -> setSaleItem ( $ item ) -> setStockUnit ( $ stockUnit ) ; $ quantity -= $ this -> assignmentUpdater -> updateSold ( $ assignment , $ quantity ) ; } if ( 0 < $ quantity ) { throw new StockLogicException ( sprintf ( 'Failed to create assignments for item "%s".' , $ item -> getDesignation ( ) ) ) ; } }
7756	public function setPropertyValue ( $ entity , $ property , $ value ) { $ this -> reflFields [ $ property ] -> setValue ( $ entity , $ value ) ; }
5462	public function stretch ( $ url ) { $ this -> root = $ this -> getCommonPath ( $ this -> root , $ url -> getPath ( ) ) ; }
3010	public function setConsumer ( $ consumerKey , $ consumerSecret ) { $ this -> apiKey = $ consumerKey ; $ this -> requestHandler -> setConsumer ( $ consumerKey , $ consumerSecret ) ; }
7060	public function removeClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( false !== $ index = array_search ( $ class , $ classes ) ) { unset ( $ classes [ $ index ] ) ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
9181	public function forget ( $ args = [ ] ) { if ( ! empty ( $ args ) ) { if ( is_array ( $ args ) ) { $ args = implode ( '_' , $ args ) ; } if ( empty ( $ this -> forgetful ) ) { $ this -> forgetful = get_class_methods ( $ this ) ; } foreach ( $ this -> forgetful as $ method ) { $ cacheKey = str_replace ( '\\' , '_' , get_class ( $ this ) . '_' . $ method . '_' ) ; $ this -> forgetByKey ( $ cacheKey ) ; $ cacheKey = str_replace ( '\\' , '_' , get_class ( $ this ) . '_' . $ method . '_' . $ args ) ; $ this -> forgetByKey ( $ cacheKey ) ; } } else { $ key = $ this -> getRememberKey ( ) ; $ this -> forgetByKey ( $ key ) ; } return $ this ; }
3722	public function handleUpdate ( PostPersistModelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ old = $ event -> getOriginalModel ( ) ; $ new = $ event -> getModel ( ) ; $ oldTable = $ old ? $ old -> getProperty ( 'tableName' ) : null ; $ newTable = $ new -> getProperty ( 'tableName' ) ; if ( $ oldTable !== $ newTable ) { if ( ! empty ( $ oldTable ) ) { $ this -> tableManipulator -> renameTable ( $ oldTable , $ newTable ) ; } else { $ this -> tableManipulator -> createTable ( $ newTable ) ; } } $ this -> tableManipulator -> setVariantSupport ( $ newTable , $ new -> getProperty ( 'varsupport' ) ) ; }
2554	protected static function makePricingOptionFareFamilyOverride ( $ fareFamily ) { $ opt = [ ] ; if ( $ fareFamily !== null ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_FARE_FAMILY ) ; $ po -> optionDetail = new OptionDetail ( [ [ 'FF' => $ fareFamily ] ] ) ; $ opt [ ] = $ po ; } return $ opt ; }
8578	public function setItemFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3887	public function editRenderSettingButton ( \ DC_Table $ dataContainer ) { if ( $ dataContainer -> value < 1 ) { return '' ; } $ url = $ this -> urlBuilderFactory -> create ( 'contao/main.php?do=metamodels&table=tl_metamodel_rendersetting' ) -> setQueryParameter ( 'pid' , ModelId :: fromValues ( 'tl_metamodel_rendersettings' , $ dataContainer -> value ) -> getSerialized ( ) ) ; return $ this -> renderEditButton ( $ GLOBALS [ 'TL_LANG' ] [ static :: $ tableName ] [ 'editrendersetting' ] [ 0 ] , sprintf ( StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ static :: $ tableName ] [ 'editrendersetting' ] [ 1 ] ) , $ dataContainer -> value ) , $ url ) ; }
1655	public function handleConnectedSocks ( ConnectionInterface $ stream , $ host , $ port , Deferred $ deferred , $ uri ) { $ reader = new StreamReader ( ) ; $ stream -> on ( 'data' , array ( $ reader , 'write' ) ) ; $ stream -> on ( 'error' , $ onError = function ( Exception $ e ) use ( $ deferred , $ uri ) { $ deferred -> reject ( new RuntimeException ( 'Connection to ' . $ uri . ' failed because connection to proxy caused a stream error (EIO)' , defined ( 'SOCKET_EIO' ) ? SOCKET_EIO : 5 , $ e ) ) ; } ) ; $ stream -> on ( 'close' , $ onClose = function ( ) use ( $ deferred , $ uri ) { $ deferred -> reject ( new RuntimeException ( 'Connection to ' . $ uri . ' failed because connection to proxy was lost while waiting for response from proxy (ECONNRESET)' , defined ( 'SOCKET_ECONNRESET' ) ? SOCKET_ECONNRESET : 104 ) ) ; } ) ; if ( $ this -> protocolVersion === 5 ) { $ promise = $ this -> handleSocks5 ( $ stream , $ host , $ port , $ reader , $ uri ) ; } else { $ promise = $ this -> handleSocks4 ( $ stream , $ host , $ port , $ reader , $ uri ) ; } $ promise -> then ( function ( ) use ( $ deferred , $ stream , $ reader , $ onError , $ onClose ) { $ stream -> removeListener ( 'data' , array ( $ reader , 'write' ) ) ; $ stream -> removeListener ( 'error' , $ onError ) ; $ stream -> removeListener ( 'close' , $ onClose ) ; $ deferred -> resolve ( $ stream ) ; } , function ( Exception $ error ) use ( $ deferred , $ stream , $ uri ) { if ( ! $ error instanceof RuntimeException ) { $ error = new RuntimeException ( 'Connection to ' . $ uri . ' failed because proxy returned invalid response (EBADMSG)' , defined ( 'SOCKET_EBADMSG' ) ? SOCKET_EBADMSG : 71 , $ error ) ; } $ deferred -> reject ( $ error ) ; $ stream -> close ( ) ; } ) ; }
3167	private function isThemeSwitcherEnabled ( ) { $ extensionsManager = $ this -> getServiceLocator ( ) -> get ( \ common_ext_ExtensionsManager :: SERVICE_ID ) ; $ config = $ extensionsManager -> getExtensionById ( "taoTests" ) -> getConfig ( "test_runner_plugin_registry" ) ; return array_key_exists ( self :: TOOL_ITEM_THEME_SWITCHER_KEY , $ config ) && $ config [ self :: TOOL_ITEM_THEME_SWITCHER_KEY ] [ "active" ] === true ; }
7349	protected function hasNotification ( SaleInterface $ sale , $ type , $ number ) { foreach ( $ sale -> getNotifications ( ) as $ n ) { if ( $ n -> getType ( ) !== $ type ) { continue ; } if ( $ n -> hasData ( 'shipment' ) && $ n -> getData ( 'shipment' ) === $ number ) { return true ; } } return false ; }
10504	private function registerLogLevels ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogLevels :: class , function ( $ app ) { $ translator = $ app [ 'translator' ] ; return new Utilities \ LogLevels ( $ translator , 'en' ) ; } ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.levels' , Contracts \ Utilities \ LogLevels :: class ) ; }
3828	protected function addUrlParameter ( $ url , $ name , $ value ) { @ trigger_error ( sprintf ( '"%1$s" has been deprecated in favor of the "FilterUrlBuilder"' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( is_array ( $ value ) ) { $ value = implode ( ',' , array_filter ( $ value ) ) ; } $ value = str_replace ( '%' , '%%' , urlencode ( $ value ) ) ; if ( empty ( $ value ) ) { return $ url ; } if ( $ name !== 'auto_item' ) { $ url .= '/' . $ name . '/' . $ value ; } else { $ url = '/' . $ value . $ url ; } return $ url ; }
12797	public function mb_str_pad ( $ input , $ length , $ string = ' ' , $ type = STR_PAD_LEFT ) { return str_pad ( $ input , $ length + strlen ( $ input ) - mb_strlen ( $ input ) , $ string , $ type ) ; }
511	protected function formatOptionHelp ( $ name , $ required , $ type , $ defaultValue , $ comment ) { $ comment = trim ( $ comment ) ; $ type = trim ( $ type ) ; if ( strncmp ( $ type , 'bool' , 4 ) === 0 ) { $ type = 'boolean, 0 or 1' ; } if ( $ defaultValue !== null && ! is_array ( $ defaultValue ) ) { if ( $ type === null ) { $ type = gettype ( $ defaultValue ) ; } if ( is_bool ( $ defaultValue ) ) { $ defaultValue = ( int ) $ defaultValue ; } if ( is_string ( $ defaultValue ) ) { $ defaultValue = "'" . $ defaultValue . "'" ; } else { $ defaultValue = var_export ( $ defaultValue , true ) ; } $ doc = "$type (defaults to $defaultValue)" ; } else { $ doc = $ type ; } if ( $ doc === '' ) { $ doc = $ comment ; } elseif ( $ comment !== '' ) { $ doc .= "\n" . preg_replace ( '/^/m' , ' ' , $ comment ) ; } $ name = $ required ? "$name (required)" : $ name ; return $ doc === '' ? $ name : "$name: $doc" ; }
8470	public function alert ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'alert' , $ scope , $ message , $ context , $ config ) ; }
6800	public function installCurrencies ( $ code = 'USD' ) { $ currencyNames = Intl :: getCurrencyBundle ( ) -> getCurrencyNames ( ) ; if ( ! isset ( $ currencyNames [ $ code ] ) ) { throw new InvalidArgumentException ( "Invalid default currency code '$code'." ) ; } asort ( $ currencyNames ) ; $ this -> generate ( Currency :: class , $ currencyNames , $ code ) ; }
4184	public function getFile ( $ class ) { if ( is_null ( $ this -> count ) ) { return $ this -> fileHas ( $ class ) -> getFile ( $ class ) ; } if ( isset ( $ this -> files [ $ class ] ) ) { return $ this -> files [ $ class ] ; } throw new FileException ( "File does not exists with given `{$class}` class." ) ; }
9289	public function getDuration ( ) { $ executed = $ this -> getExecuted ( ) ; $ finished = $ this -> getFinished ( ) ; if ( is_null ( $ executed ) || is_null ( $ finished ) ) { return 0 ; } return strtotime ( $ finished ) - strtotime ( $ executed ) ; }
4585	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! $ this -> accessor -> isReadable ( $ payload , $ this -> property ) ) { $ event -> markAsInvalid ( ) ; } elseif ( $ this -> validate && $ this -> accessor -> getValue ( $ payload , $ this -> property ) !== $ this -> getSignature ( ) ) { $ event -> markAsInvalid ( ) ; } }
11898	public function getEstimateTimeRemaining ( ) { $ estimatedDuration = $ this -> dataInterface -> estimateDuration ( ) ; if ( $ estimatedDuration ) { $ startedTime = strtotime ( $ this -> started ) ; $ estimatedEndTime = $ startedTime + $ estimatedDuration ; if ( time ( ) > $ estimatedEndTime ) { return false ; } return $ estimatedEndTime - time ( ) ; } return false ; }
6635	public function bootstrap ( $ app ) { Yii :: setAlias ( '@wavecms' , '@vendor/mrstroz/yii2-wavecms' ) ; if ( $ app -> id === 'app-backend' || $ app -> id === 'app-frontend' ) { Yii :: setAlias ( '@frontWeb' , str_replace ( '/admin' , '' , Yii :: getAlias ( '@web' ) ) ) ; Yii :: setAlias ( '@frontWebroot' , str_replace ( '/public/admin' , '/public' , Yii :: getAlias ( '@webroot' ) ) ) ; } if ( $ app -> id === 'app-backend' ) { if ( ! Yii :: $ app -> user -> isGuest ) { Yii :: $ app -> language = Yii :: $ app -> user -> identity -> lang ; } } $ this -> initTranslations ( ) ; if ( $ app -> hasModule ( 'wavecms' ) && ( $ module = $ app -> getModule ( 'wavecms' ) ) instanceof Module ) { if ( $ app instanceof ConsoleApplication ) { $ module -> controllerNamespace = 'mrstroz\wavecms\commands' ; } else { $ module -> controllerNamespace = 'mrstroz\wavecms\controllers' ; if ( $ app -> id === 'app-backend' ) { Yii :: $ app -> errorHandler -> errorAction = $ module -> errorAction ; $ app -> set ( 'wavecms' , [ 'class' => 'mrstroz\wavecms\WavecmsComponent' , 'languages' => $ module -> languages ] ) ; $ app -> set ( 'cacheFrontend' , [ 'class' => 'yii\caching\FileCache' , 'cachePath' => Yii :: getAlias ( '@frontend' ) . '/runtime/cache' ] ) ; $ app -> set ( 'settings' , [ 'class' => 'yii2mod\settings\components\Settings' , ] ) ; Yii :: $ app -> assetManager -> appendTimestamp = true ; Yii :: $ app -> i18n -> translations [ 'yii2mod.settings' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'basePath' => '@yii2mod/settings/messages' ] ; $ this -> initContainer ( $ module ) ; $ this -> initLanguages ( ) ; $ this -> initParams ( ) ; $ this -> initRoutes ( $ app , $ module ) ; $ this -> initNavigation ( ) ; } } } }
1725	private static function canGenerateSecret ( array $ config ) : bool { if ( isset ( $ config [ 'file' ] ) ) { return ! is_file ( $ config [ 'file' ] ) ; } foreach ( $ config as $ v ) { if ( \ is_array ( $ v ) && isset ( $ v [ 'file' ] ) && is_file ( $ v [ 'file' ] ) ) { return false ; } } return ! empty ( $ config ) ; }
3107	public function getItemHrefIndex ( ) { if ( isset ( $ this -> state [ self :: VAR_HREF_INDEX ] ) ) { $ table = $ this -> state [ self :: VAR_HREF_INDEX ] ; } else { $ table = [ ] ; } return $ table ; }
10839	protected function deleteRaw ( $ Key ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; if ( file_exists ( $ CacheFile ) ) { return unlink ( $ CacheFile ) ; } return true ; }
9830	public function getAssociationMenuName ( $ modelName , $ otherModelName ) { return sprintf ( 'auja.%s.%s.menu' , $ this -> toUrlName ( $ modelName ) , $ this -> toUrlName ( $ otherModelName ) ) ; }
5977	public function moodboards ( ) { if ( ! $ this -> moodboards instanceof MoodboardsController ) { $ this -> moodboards = new MoodboardsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> moodboards -> setLogger ( $ this -> logger ) ; } return $ this -> moodboards ; }
846	public function generatePartialCode ( $ start , $ end ) { $ code = '' ; for ( $ i = $ start ; $ i <= $ end ; ++ $ i ) { $ code .= $ this [ $ i ] -> getContent ( ) ; } return $ code ; }
5567	public function post ( $ url , $ parameters = false , $ content_type = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } if ( $ this -> getUrl ( ) ) { $ url = $ url -> makeAbsolute ( $ this -> getUrl ( ) ) ; } return $ this -> load ( $ url , new SimplePostEncoding ( $ parameters , $ content_type ) ) ; }
11578	public function actionResend ( ) { if ( $ this -> module -> enableConfirmation == false ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( ResendForm :: className ( ) ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> resend ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'A new confirmation link has been sent' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'resend' , [ 'model' => $ model ] ) ; }
12853	public function import ( Package $ package , $ id = null ) { $ id = is_null ( $ id ) ? $ package -> id : $ id ; $ this -> symbols = array_merge ( $ package -> symbols , $ this -> symbols ) ; $ this -> macros = array_merge ( $ package -> macros , $ this -> macros ) ; $ this -> packages [ $ id ] = $ package ; }
12235	public function insertXML ( $ xml , $ mode = 'append' ) { $ tmp = dom_import_simplexml ( $ this ) ; $ fragment = $ tmp -> ownerDocument -> createDocumentFragment ( ) ; $ use_errors = libxml_use_internal_errors ( true ) ; if ( ! $ fragment -> appendXML ( $ xml ) ) { libxml_use_internal_errors ( $ use_errors ) ; throw new InvalidArgumentException ( libxml_get_last_error ( ) -> message ) ; } libxml_use_internal_errors ( $ use_errors ) ; $ this -> insertNode ( $ tmp , $ fragment , $ mode ) ; return $ this ; }
11742	public function add ( Theme $ theme , array $ pageValues ) { $ pageName = $ pageValues [ "name" ] ; $ pageDir = $ this -> pagesDir . '/' . $ pageName ; $ this -> pageExists ( $ pageDir ) ; if ( ! @ mkdir ( $ pageDir ) ) { $ this -> folderNotCreated ( $ pageDir ) ; } $ seoValues = $ pageValues [ "seo" ] ; unset ( $ pageValues [ "seo" ] ) ; $ encodedPage = json_encode ( $ pageValues ) ; $ pageFile = $ pageDir . '/' . $ this -> pageFile ; $ event = Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDING , new PageCollectionAddingEvent ( $ pageFile , $ encodedPage ) ) ; $ encodedPage = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ pageFile , $ encodedPage ) ; if ( $ this -> pageFile != 'page.json' ) { FilesystemTools :: writeFile ( $ pageDir . '/page.json' , $ encodedPage ) ; } foreach ( $ seoValues as $ seoValue ) { $ languageName = $ seoValue [ "language" ] ; unset ( $ seoValue [ "language" ] ) ; $ languageDir = $ pageDir . '/' . $ languageName ; @ mkdir ( $ languageDir ) ; FilesystemTools :: writeFile ( $ languageDir . '/' . $ this -> seoFile , json_encode ( $ seoValue ) ) ; $ theme -> addTemplateSlots ( $ pageValues [ "template" ] , $ this -> username ) ; } Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDED , new PageCollectionAddedEvent ( $ pageFile , $ encodedPage ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully added to the website' , $ pageName ) ) ; return $ pageValues ; }
2381	public static function stripRootDir ( $ path ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ length = \ strlen ( $ rootDir ) ; if ( strncmp ( $ path , $ rootDir , $ length ) !== 0 || \ strlen ( $ path ) <= $ length || ( $ path [ $ length ] !== '/' && $ path [ $ length ] !== '\\' ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Path "%s" is not inside the Contao root dir "%s"' , $ path , $ rootDir ) ) ; } return ( string ) substr ( $ path , $ length + 1 ) ; }
492	public function findFor ( $ name , $ model ) { if ( method_exists ( $ model , 'get' . $ name ) ) { $ method = new \ ReflectionMethod ( $ model , 'get' . $ name ) ; $ realName = lcfirst ( substr ( $ method -> getName ( ) , 3 ) ) ; if ( $ realName !== $ name ) { throw new InvalidArgumentException ( 'Relation names are case sensitive. ' . get_class ( $ model ) . " has a relation named \"$realName\" instead of \"$name\"." ) ; } } return $ this -> multiple ? $ this -> all ( ) : $ this -> one ( ) ; }
12134	public function index ( QuestionRequest $ request ) { $ view = $ this -> response -> theme -> listView ( ) ; if ( $ this -> response -> typeIs ( 'json' ) ) { $ function = camel_case ( 'get-' . $ view ) ; return $ this -> repository -> setPresenter ( \ Litecms \ Forum \ Repositories \ Presenter \ QuestionPresenter :: class ) -> $ function ( ) ; } $ user_id = user_id ( ) ; $ questions = $ this -> repository -> questions ( $ user_id ) ; return $ this -> response -> title ( trans ( 'forum::question.names' ) ) -> view ( 'forum::question.index' , true ) -> data ( compact ( 'questions' , 'view' ) ) -> output ( ) ; }
2769	public function addRemote ( string $ name , string $ url , array $ options = [ ] ) : string { $ this -> ensureAddRemoveArgsAreValid ( $ name , $ url ) ; $ args = [ 'add' ] ; foreach ( [ '-f' , '--tags' , '--no-tags' ] as $ option ) { if ( ! empty ( $ options [ $ option ] ) ) { $ args [ ] = $ option ; } } if ( ! empty ( $ options [ '-t' ] ) ) { foreach ( $ options [ '-t' ] as $ branch ) { array_push ( $ args , '-t' , $ branch ) ; } } if ( ! empty ( $ options [ '-m' ] ) ) { array_push ( $ args , '-m' , $ options [ '-m' ] ) ; } array_push ( $ args , $ name , $ url ) ; return $ this -> remote ( ... $ args ) ; }
10186	private static function fromArray ( $ object , $ type = null , $ innerType = null ) { if ( $ type == 'array' ) { foreach ( $ object as $ element ) { $ result [ ] = self :: fromArray ( $ element , $ innerType ) ; } return $ result ; } else if ( class_exists ( $ type ) ) { $ class = new $ type ( ) ; if ( is_subclass_of ( $ class , 'AbstractJSONWrapper' ) ) { $ class -> fromArray ( $ object ) ; return $ class ; } else { trigger_error ( __CLASS__ . ": Trying to deserialize " . get_class ( $ class ) ) ; return $ object ; } } else { return $ object ; } }
11618	private function compressPhase2 ( $ calcIdWriteOff , $ calcIdPhase1 , $ calcIdPhase2 , $ scheme ) { $ pv = $ this -> rouGetPv -> exec ( $ calcIdWriteOff ) ; $ dwnlPlain = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdWriteOff ) ; $ dwnlPhase1 = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdPhase1 ) ; $ ctx = new \ Praxigento \ Core \ Data ( ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_CALC_ID_PHASE2 , $ calcIdPhase2 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_SCHEME , $ scheme ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PLAIN , $ dwnlPlain ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PHASE1 , $ dwnlPhase1 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_MAP_PV , $ pv ) ; $ out = $ this -> procCmprsPhase2 -> exec ( $ ctx ) ; $ dwnlPhase2 = $ out -> get ( PCpmrsPhase2 :: OUT_DWNL_PHASE2 ) ; $ legs = $ out -> get ( PCpmrsPhase2 :: OUT_LEGS ) ; $ result = [ $ dwnlPhase2 , $ legs ] ; return $ result ; }
3177	public static function checkTimedSectionExit ( RunnerServiceContext $ context , $ nextPosition ) { $ timerConfig = $ context -> getTestConfig ( ) -> getConfigValue ( 'timer' ) ; if ( empty ( $ timerConfig [ 'keepUpToTimeout' ] ) ) { $ session = $ context -> getTestSession ( ) ; $ route = $ session -> getRoute ( ) ; $ section = $ session -> getCurrentAssessmentSection ( ) ; $ limits = $ section -> getTimeLimits ( ) ; if ( ! ( $ context instanceof QtiRunnerServiceContext ) || ! $ context -> isAdaptive ( ) ) { $ isJumpOutOfSection = false ; if ( ( $ nextPosition >= 0 ) && ( $ nextPosition < $ route -> count ( ) ) ) { $ nextSection = $ route -> getRouteItemAt ( $ nextPosition ) ; $ isJumpOutOfSection = ( $ section -> getIdentifier ( ) !== $ nextSection -> getAssessmentSection ( ) -> getIdentifier ( ) ) ; } if ( $ isJumpOutOfSection && $ limits != null && $ limits -> hasMaxTime ( ) ) { $ assessmentItemRefs = $ section -> getComponentsByClassName ( 'assessmentItemRef' ) ; foreach ( $ assessmentItemRefs as $ assessmentItemRef ) { $ itemSessions = $ session -> getAssessmentItemSessions ( $ assessmentItemRef -> getIdentifier ( ) ) ; if ( $ itemSessions !== false ) { foreach ( $ itemSessions as $ itemSession ) { $ itemSession -> endItemSession ( ) ; } } } } } } }
394	public static function updateAll ( $ attributes , $ condition = '' , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> update ( static :: tableName ( ) , $ attributes , $ condition , $ params ) ; return $ command -> execute ( ) ; }
5497	public function registerAt ( $ step , $ method , $ args , $ action ) { $ args = $ this -> replaceWildcards ( $ args ) ; $ method = strtolower ( $ method ) ; if ( ! isset ( $ this -> at [ $ method ] ) ) { $ this -> at [ $ method ] = array ( ) ; } if ( ! isset ( $ this -> at [ $ method ] [ $ step ] ) ) { $ this -> at [ $ method ] [ $ step ] = new SimpleSignatureMap ( ) ; } $ this -> at [ $ method ] [ $ step ] -> add ( $ args , $ action ) ; }
12733	public function register ( array $ signals , $ callableArray = null ) { foreach ( $ signals as $ signal ) { if ( ! in_array ( $ signal , $ this -> _signals , true ) ) { $ signalName = static :: getSignalName ( $ signal ) ; throw new InvalidArgumentException ( "Signal [{$signalName}] is not supported. Use setSignals() to add support." , $ signal ) ; } } $ reg = new Listener ( $ signals ) ; $ reg -> setNotification ( $ callableArray ) ; $ this -> _byId [ $ reg -> id ] = $ reg ; foreach ( $ signals as $ signal ) { $ this -> _bySignal [ $ signal ] [ $ reg -> id ] = $ reg ; } return $ reg ; }
3745	public function fetch ( ConfigInterface $ objConfig ) { $ backupLanguage = $ this -> setLanguage ( $ this -> getCurrentLanguage ( ) ) ; if ( $ objConfig -> getId ( ) !== null ) { $ modelId = $ objConfig -> getId ( ) ; } else { $ filter = $ this -> prepareFilter ( $ objConfig ) ; $ ids = $ this -> getIdsFromFilter ( $ filter , $ objConfig ) ; $ modelId = reset ( $ ids ) ; } $ objItem = $ modelId ? $ this -> getMetaModel ( ) -> findById ( $ modelId , $ objConfig -> getFields ( ) ? : array ( ) ) : null ; $ this -> setLanguage ( $ backupLanguage ) ; if ( ! $ objItem ) { return null ; } return new Model ( $ objItem ) ; }
1867	private function validateSessionLifetime ( User $ user ) : void { if ( ! $ this -> session -> isStarted ( ) ) { return ; } $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ timeout = ( int ) $ config -> get ( 'sessionTimeout' ) ; if ( $ timeout > 0 && ( time ( ) - $ this -> session -> getMetadataBag ( ) -> getLastUsed ( ) ) < $ timeout ) { return ; } if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has been logged out automatically due to inactivity' , $ user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ user -> username ) ] ) ; } throw new UsernameNotFoundException ( sprintf ( 'User "%s" has been logged out automatically due to inactivity.' , $ user -> username ) ) ; }
11554	public function cancelConsignment ( ConsignmentInterface $ consignment ) { $ adapter = $ this -> getAdapter ( $ consignment ) ; $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENT_CANCEL , $ event ) ; try { $ adapter -> cancelConsignment ( $ consignment ) ; foreach ( $ consignment -> getParcels ( ) as $ parcel ) { $ parcel -> setStatus ( ConsignmentStatusList :: STATUS_CANCELED ) ; } $ consignment -> setStatus ( ConsignmentStatusList :: STATUS_CANCELED ) ; $ this -> consignmentRepository -> saveConsignment ( $ consignment ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignment cancel.' , null , $ e ) ; } $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENT_CANCEL , $ event ) ; }
5905	public function retrieveRole ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/roles/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Role ( $ result ) ; return $ result ; }
2588	protected function addItineraries ( $ itineraries , $ legacySegments , & $ tattooCounter ) { if ( ! empty ( $ legacySegments ) ) { $ this -> addSegments ( $ legacySegments , $ tattooCounter ) ; } foreach ( $ itineraries as $ itinerary ) { $ this -> addSegments ( $ itinerary -> segments , $ tattooCounter , $ itinerary -> origin , $ itinerary -> destination ) ; } }
705	public function getDefaultRoleInstances ( ) { $ result = [ ] ; foreach ( $ this -> defaultRoles as $ roleName ) { $ result [ $ roleName ] = $ this -> createRole ( $ roleName ) ; } return $ result ; }
7033	protected function lastMigration ( ) { try { $ migration = Db :: query ( "select * from migrations order by created_at desc limit 1" , [ ] , $ this -> dbName ) ; return $ migration [ 0 ] ; } catch ( PDOException $ e ) { if ( $ e -> getCode ( ) === "42S02" ) return null ; } return false ; }
10638	protected function processUploadedFiles ( FileBag $ filebag ) { $ adapter = new LocalAdapter ( $ this -> get ( 'kernel' ) -> getRootDir ( ) . '/../web/media' ) ; $ filesystem = new Filesystem ( $ adapter ) ; $ processed = array ( ) ; if ( $ filebag -> get ( 'files' ) ) { foreach ( $ filebag -> get ( 'files' ) as $ file ) { $ dest = $ this -> createUniquePath ( $ file ) ; if ( $ filesystem -> write ( $ dest [ 'path' ] , file_get_contents ( $ file -> getPathname ( ) ) ) ) { $ processed [ ] = $ dest [ 'path' ] ; } ; } } return $ processed ; }
5875	public function containerAdd ( ServerRequestInterface $ request , ResponseInterface $ response ) : ResponseInterface { $ GLOBALS [ 'TCA' ] [ 'tx_imageautoresize' ] = include ( ExtensionManagementUtility :: extPath ( 'image_autoresize' ) . 'Configuration/TCA/Module/Options.php' ) ; $ GLOBALS [ 'TCA' ] [ 'tx_imageautoresize' ] [ 'ajax' ] = true ; $ dataProviders = & $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'SYS' ] [ 'formEngine' ] [ 'formDataGroup' ] [ 'tcaDatabaseRecord' ] ; $ dataProviders [ \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: class ] = [ 'before' => [ \ TYPO3 \ CMS \ Backend \ Form \ FormDataProvider \ DatabaseEditRow :: class , ] ] ; $ record = [ 'uid' => \ Causal \ ImageAutoresize \ Controller \ ConfigurationController :: virtualRecordId , 'pid' => 0 , ] ; \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: initialize ( $ record ) ; $ response = parent :: containerAdd ( $ request , $ response ) ; return $ response -> withHeader ( 'Content-Type' , 'application/json; charset=utf-8' ) ; }
3241	protected function createSeeder ( $ data ) { $ seederFile = base_path ( '/database/seeds' ) . '/LaravelShopSeeder.php' ; $ output = $ this -> laravel -> view -> make ( 'laravel-shop::generators.seeder' ) -> with ( $ data ) -> render ( ) ; if ( ! file_exists ( $ seederFile ) && $ fs = fopen ( $ seederFile , 'x' ) ) { fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; return true ; } return false ; }
4845	protected static function call ( $ method , $ url , $ params = array ( ) ) { $ ch = curl_init ( ) ; $ curl_options = array ( CURLOPT_CONNECTTIMEOUT => 10 , CURLOPT_RETURNTRANSFER => true , CURLOPT_TIMEOUT => 60 , CURLOPT_USERAGENT => 'gocardless-php/v' . GoCardless :: VERSION , ) ; if ( isset ( $ params [ 'ua_tag' ] ) ) { $ curl_options [ CURLOPT_USERAGENT ] .= ' ' . $ params [ 'ua_tag' ] ; unset ( $ params [ 'ua_tag' ] ) ; } $ curl_options [ CURLOPT_HTTPHEADER ] [ ] = 'Accept: application/json' ; $ curl_options [ CURLOPT_SSL_VERIFYPEER ] = true ; if ( isset ( $ params [ 'http_authorization' ] ) ) { $ curl_options [ CURLOPT_USERPWD ] = $ params [ 'http_authorization' ] ; unset ( $ params [ 'http_authorization' ] ) ; } else { if ( ! isset ( $ params [ 'http_bearer' ] ) ) { throw new GoCardless_ClientException ( 'Access token missing' ) ; } $ curl_options [ CURLOPT_HTTPHEADER ] [ ] = 'Authorization: Bearer ' . $ params [ 'http_bearer' ] ; unset ( $ params [ 'http_bearer' ] ) ; } if ( $ method == 'post' ) { $ curl_options [ CURLOPT_POST ] = 1 ; if ( ! empty ( $ params ) ) { $ curl_options [ CURLOPT_POSTFIELDS ] = http_build_query ( $ params , null , '&' ) ; } } elseif ( $ method == 'get' ) { $ curl_options [ CURLOPT_HTTPGET ] = 1 ; if ( ! empty ( $ params ) ) { $ url .= '?' . http_build_query ( $ params , null , '&' ) ; } } elseif ( $ method == 'put' ) { $ curl_options [ CURLOPT_PUT ] = 1 ; $ fh = fopen ( 'php://memory' , 'rw+' ) ; $ curl_options [ CURLOPT_INFILE ] = $ fh ; $ curl_options [ CURLOPT_INFILESIZE ] = 0 ; } curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt_array ( $ ch , $ curl_options ) ; $ result = curl_exec ( $ ch ) ; $ error = curl_errno ( $ ch ) ; if ( $ error == CURLE_SSL_PEER_CERTIFICATE || $ error == CURLE_SSL_CACERT || $ error == 77 ) { curl_setopt ( $ ch , CURLOPT_CAINFO , dirname ( __FILE__ ) . '/cert-bundle.crt' ) ; $ result = curl_exec ( $ ch ) ; } $ http_response_code = curl_getinfo ( $ ch , CURLINFO_HTTP_CODE ) ; if ( $ http_response_code < 200 || $ http_response_code > 300 ) { $ message = print_r ( json_decode ( $ result , true ) , true ) ; throw new GoCardless_ApiException ( $ message , $ http_response_code , $ result ) ; } curl_close ( $ ch ) ; if ( isset ( $ fh ) ) { fclose ( $ fh ) ; } return json_decode ( $ result , true ) ; }
11008	public function addReportUri ( string $ reportUri ) : bool { if ( ! filter_var ( $ reportUri , FILTER_VALIDATE_URL ) ) { throw new MiddlewareException ( $ this , sprintf ( "'%s' is not a valid URI and can not be set as the CSP report URI" , $ reportUri ) ) ; } if ( ! in_array ( $ reportUri , $ this -> tags [ 'report-uri' ] ) ) { $ this -> tags [ 'report-uri' ] [ ] = $ reportUri ; return true ; } return false ; }
5011	public function getLogger ( ) : LoggerInterface { if ( ! $ this -> logger ) { $ logger = new class implements LoggerInterface { public function emerg ( $ message , $ extra = [ ] ) : void { } public function alert ( $ message , $ extra = [ ] ) : void { } public function crit ( $ message , $ extra = [ ] ) : void { } public function err ( $ message , $ extra = [ ] ) : void { } public function warn ( $ message , $ extra = [ ] ) : void { } public function notice ( $ message , $ extra = [ ] ) : void { } public function info ( $ message , $ extra = [ ] ) : void { } public function debug ( $ message , $ extra = [ ] ) : void { } } ; $ this -> setLogger ( $ logger ) ; } return $ this -> logger ; }
12866	public function init_locales ( ) { if ( ! empty ( $ this -> textdomain ) && $ this -> locales_initialized !== true ) { load_plugin_textdomain ( $ this -> textdomain , true , $ this -> get_id ( ) ) ; $ this -> locales_initialized = true ; } }
2891	public function onControllerFrontSendResponseAfter ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ front = $ observer -> getData ( 'front' ) ; $ this -> updateProfiling ( ) ; $ this -> getRequestInfo ( ) -> getController ( ) -> addResponseInfo ( $ front -> getResponse ( ) ) ; }
3834	public function hookAdditionalFormatters ( $ arrBaseFormatted , $ arrRowData , $ strOutputFormat , $ objSettings ) { $ arrResult = $ arrBaseFormatted ; if ( isset ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) && is_array ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) ) { foreach ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] as $ callback ) { list ( $ strClass , $ strMethod ) = $ callback ; $ objCallback = ( in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) ? call_user_func ( array ( $ strClass , 'getInstance' ) ) : new $ strClass ( ) ; $ arrResult = $ objCallback -> $ strMethod ( $ this , $ arrResult , $ arrRowData , $ strOutputFormat , $ objSettings ) ; } } return $ arrResult ; }
1258	private function makeVar ( $ prefix ) { if ( ! isset ( $ this -> vars [ $ prefix ] ) ) { $ this -> vars [ $ prefix ] = 0 ; return '$' . $ prefix ; } return '$' . $ prefix . ++ $ this -> vars [ $ prefix ] ; }
7755	private function doDeserialize ( $ data , $ entity ) { $ metadata = $ this -> hydraApi -> getMetadataFor ( get_class ( $ entity ) ) ; if ( null === $ metadata ) { throw new \ Exception ( sprintf ( '"%s" cannot be serialized as it is not documented.' , get_class ( $ data ) ) ) ; } $ vocabPrefix = $ this -> router -> generate ( 'hydra_vocab' , array ( ) , true ) . '#' ; $ typeIri = ( $ metadata -> isExternalReference ( ) ) ? $ metadata -> getIri ( ) : $ vocabPrefix . $ metadata -> getIri ( ) ; $ graph = JsonLD :: getDocument ( $ data ) -> getGraph ( ) ; $ node = $ graph -> getNodesByType ( $ typeIri ) ; if ( 1 !== count ( $ node ) ) { throw new RuntimeException ( 'The passed data contains ' . count ( $ node ) . ' nodes of the type ' . $ typeIri . '; expected 1.' ) ; } $ node = reset ( $ node ) ; foreach ( $ metadata -> getProperties ( ) as $ property ) { if ( $ property -> isReadOnly ( ) ) { continue ; } if ( null !== ( $ route = $ property -> getRoute ( ) ) ) { continue ; } $ propertyIri = ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : $ vocabPrefix . $ property -> getIri ( ) ; $ value = $ node -> getProperty ( $ propertyIri ) ; if ( $ value instanceof \ ML \ JsonLD \ Value ) { $ value = $ value -> getValue ( ) ; } if ( ! is_null ( $ value ) && $ this -> hydraApi -> hasNormalizer ( $ property -> getType ( ) ) ) { $ normalizer = $ this -> hydraApi -> getNormalizer ( $ property -> getType ( ) ) ; $ value = $ normalizer -> denormalize ( $ value , $ property -> getType ( ) ) ; } $ property -> setValue ( $ entity , $ value ) ; } return $ entity ; }
10147	private function readPalette ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ nm = self :: getUInt2d ( $ recordData , 0 ) ; for ( $ i = 0 ; $ i < $ nm ; ++ $ i ) { $ rgb = substr ( $ recordData , 2 + 4 * $ i , 4 ) ; $ this -> palette [ ] = self :: readRGB ( $ rgb ) ; } } }
2727	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> determineVersions ( $ service -> versions ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> request -> getParam ( 'acls' ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; foreach ( $ snippet as $ key => $ value ) { if ( $ strippedAllowedItems === '' ) { $ value = '' ; } else { $ value = str_replace ( '####WAF_ALLOWLIST####' , $ strippedAllowedItems , $ value ) ; } $ snippetName = Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key ; $ snippetId = $ this -> api -> getSnippet ( $ currActiveVersion [ 'active_version' ] , $ snippetName ) -> id ; $ params = [ 'name' => $ snippetId , 'content' => $ value ] ; $ this -> api -> updateSnippet ( $ params ) ; } $ this -> cacheTypeList -> cleanType ( 'config' ) ; $ this -> systemConfig -> clean ( ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1387	protected function resourceTypeNotSupported ( string $ actual , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceTypeNotSupported ( $ actual , $ path ) ) ; }
11670	public function getClientBy ( $ selector , $ value , $ callable = null ) { $ selector = strtolower ( $ selector ) ; if ( ! in_array ( $ selector , array ( 'id' , 'key' , 'slot' , 'role' , 'alias' , 'command' ) ) ) { throw new \ InvalidArgumentException ( "Invalid selector type: `$selector`" ) ; } if ( ! method_exists ( $ this -> connection , $ method = "getConnectionBy$selector" ) ) { $ class = get_class ( $ this -> connection ) ; throw new \ InvalidArgumentException ( "Selecting connection by $selector is not supported by $class" ) ; } if ( ! $ connection = $ this -> connection -> $ method ( $ value ) ) { throw new \ InvalidArgumentException ( "Cannot find a connection by $selector matching `$value`" ) ; } $ client = new static ( $ connection , $ this -> getOptions ( ) ) ; if ( $ callable ) { return call_user_func ( $ callable , $ client ) ; } else { return $ client ; } }
9070	protected static function parseEachPart ( array $ parts , $ format ) { $ lastPartKey = count ( $ parts ) - 1 ; for ( $ p = 0 ; $ p <= $ lastPartKey ; $ p ++ ) { $ parsedPart = static :: parse ( $ parts [ $ p ] , $ format ) ; $ numNewParts = count ( $ parsedPart ) ; if ( $ numNewParts > 1 ) { array_splice ( $ parts , $ p , 1 , $ parsedPart ) ; $ p += $ numNewParts ; $ lastPartKey += $ numNewParts - 1 ; } } return $ parts ; }
470	public function up ( ) { $ transaction = $ this -> db -> beginTransaction ( ) ; try { if ( $ this -> safeUp ( ) === false ) { $ transaction -> rollBack ( ) ; return false ; } $ transaction -> commit ( ) ; } catch ( \ Exception $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } catch ( \ Throwable $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } return null ; }
2753	protected function getRequestForPath ( $ path , array $ exclude ) { if ( ! empty ( $ exclude [ $ path ] ) ) { return NULL ; } $ request = Request :: create ( $ path ) ; $ request -> headers -> set ( 'Accept' , 'text/html' ) ; $ processed = $ this -> pathProcessor -> processInbound ( $ path , $ request ) ; if ( empty ( $ processed ) || ! empty ( $ exclude [ $ processed ] ) ) { return NULL ; } $ this -> currentPath -> setPath ( $ processed , $ request ) ; try { $ request -> attributes -> add ( $ this -> router -> matchRequest ( $ request ) ) ; return $ request ; } catch ( ParamNotConvertedException $ e ) { return NULL ; } catch ( ResourceNotFoundException $ e ) { return NULL ; } catch ( MethodNotAllowedException $ e ) { return NULL ; } catch ( AccessDeniedHttpException $ e ) { return NULL ; } }
9795	public function setDataValidation ( DataValidation $ pDataValidation = null ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot set data validation for cell that is not bound to a worksheet' ) ; } $ this -> getWorksheet ( ) -> setDataValidation ( $ this -> getCoordinate ( ) , $ pDataValidation ) ; return $ this -> updateInCollection ( ) ; }
10399	protected function start ( InputInterface $ input , OutputInterface $ output , $ serviceClass , $ prefix ) { $ benchmark = new CommandBenchmark ( $ output ) ; $ benchmark -> start ( ) ; $ service = $ this -> getContainer ( ) -> get ( $ serviceClass ) ; $ factory = $ service -> getPipelineFactory ( ) ; $ factory -> setProgressBar ( new ProgressBar ( $ output ) ) ; $ service -> startPipeline ( $ prefix , $ input -> getArgument ( 'target' ) ) ; $ benchmark -> finish ( ) ; }
4987	public function setForm ( $ key , $ spec , $ enabled = true ) { if ( is_object ( $ spec ) ) { if ( $ spec instanceof FormParentInterface ) { $ spec -> setParent ( $ this ) ; } $ spec = [ '__instance__' => $ spec , 'name' => $ key , 'entity' => '*' ] ; } if ( ! is_array ( $ spec ) ) { $ spec = array ( 'type' => $ spec , 'name' => $ key ) ; } if ( ! isset ( $ spec [ 'name' ] ) ) { $ spec [ 'name' ] = $ key ; } if ( ! isset ( $ spec [ 'entity' ] ) ) { $ spec [ 'entity' ] = '*' ; } $ this -> forms [ $ key ] = $ spec ; if ( $ enabled ) { $ this -> enableForm ( $ key ) ; } elseif ( true === $ this -> activeForms ) { $ this -> activeForms = false ; } return $ this ; }
11213	protected function removeFromLookup ( $ registry ) { foreach ( $ this -> lookup_pool as $ idx => $ reg ) { if ( $ registry === $ reg ) { if ( $ reg instanceof DelegatorAwareInterface ) { $ reg -> setDelegator ( ) ; } unset ( $ this -> lookup_pool [ $ idx ] ) ; } } return $ this ; }
3296	protected function domDocumentArray ( $ root ) { $ result = [ ] ; if ( $ root -> hasAttributes ( ) ) { foreach ( $ root -> attributes as $ attribute ) { $ result [ '@attributes' ] [ $ attribute -> name ] = $ attribute -> value ; } } if ( $ root -> hasChildNodes ( ) ) { if ( 1 == $ root -> childNodes -> length ) { $ child = $ root -> childNodes -> item ( 0 ) ; if ( in_array ( $ child -> nodeType , [ XML_TEXT_NODE , XML_CDATA_SECTION_NODE ] ) && ! empty ( $ child -> nodeValue ) ) { $ result [ '_value' ] = $ child -> nodeValue ; return 1 == count ( $ result ) ? $ result [ '_value' ] : $ result ; } } $ groups = [ ] ; foreach ( $ root -> childNodes as $ child ) { if ( ! isset ( $ result [ $ child -> nodeName ] ) ) { $ result [ $ child -> nodeName ] = $ this -> domDocumentArray ( $ child ) ; } else { if ( ! isset ( $ groups [ $ child -> nodeName ] ) ) { $ result [ $ child -> nodeName ] = [ $ result [ $ child -> nodeName ] ] ; $ groups [ $ child -> nodeName ] = 1 ; } $ result [ $ child -> nodeName ] [ ] = $ this -> domDocumentArray ( $ child ) ; } } } return $ result ; }
4694	public function addOrderBy ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> order [ ] = $ expression ; $ this -> pushArgs ( 'order' , $ args ) ; return $ this ; }
1118	public static function allLeaves ( ) { $ instance = new static ; $ grammar = $ instance -> getConnection ( ) -> getQueryGrammar ( ) ; $ rgtCol = $ grammar -> wrap ( $ instance -> getQualifiedRightColumnName ( ) ) ; $ lftCol = $ grammar -> wrap ( $ instance -> getQualifiedLeftColumnName ( ) ) ; return $ instance -> newQuery ( ) -> whereRaw ( $ rgtCol . ' - ' . $ lftCol . ' = 1' ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; }
12840	static public function getMimeType ( $ filePath , $ default = 'application/octet-stream' ) { $ mimeType = finfo_file ( finfo_open ( FILEINFO_MIME_TYPE ) , $ filePath ) ; if ( $ mimeType === false ) { $ mimeType = $ default ; } return $ mimeType ; }
7426	private function isValid ( $ source = '' ) { if ( empty ( $ source ) ) { return false ; } else { $ extension = substr ( $ source , - 3 ) ; if ( strtolower ( $ extension ) !== 'swf' ) { return false ; } } return true ; }
8905	function dropdown ( ) { $ args = func_get_args ( ) ; if ( count ( $ args ) == 2 ) { list ( $ key , $ value ) = $ args ; } else { $ key = $ this -> primary_key ; $ value = $ args [ 0 ] ; } $ this -> trigger ( 'before_dropdown' , array ( $ key , $ value ) ) ; $ this -> apply_soft_delete_filter ( ) ; $ result = $ this -> _database -> select ( array ( $ key , $ value ) ) -> get ( $ this -> _table ) -> result ( ) ; $ options = array ( ) ; foreach ( $ result as $ row ) { $ options [ $ row -> { $ key } ] = $ row -> { $ value } ; } $ options = $ this -> trigger ( 'after_dropdown' , $ options ) ; return $ options ; }
2825	public function __ ( ) { $ args = func_get_args ( ) ; return $ this -> helper -> useStoreLocale ( ) ? $ this -> parentTranslate ( $ args ) : $ this -> dummyTranslate ( $ args ) ; }
12354	public function setFilePath ( string $ viewFilePath ) : void { if ( ! is_readable ( $ viewFilePath ) ) { throw new Exception ( "The View file {$viewFilePath} isn't readable." ) ; } $ this -> filePath = $ viewFilePath ; }
4771	public function status ( Request $ request , WidgetInterface $ widget , string $ widgetId , bool $ status = true ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; $ widgetConfig -> addWidgetConfig ( $ widgetId , [ 'status' => $ status ] ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; } return $ this -> redirect ( $ request -> headers -> get ( 'referer' ) ?? $ this -> generateUrl ( $ this -> getParameter ( 'pd_widget.return_route' ) ) ) ; }
11472	public function update ( ResponseRequest $ request , Response $ response ) { try { $ attributes = $ request -> all ( ) ; $ id = $ attributes [ 'question_id' ] ; $ question = $ this -> question -> selectquestion ( $ id ) ; $ response -> update ( $ attributes ) ; return redirect ( '/discussion/' . $ question [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/response/' . $ response -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
6233	public function addChild ( $ key , $ value = null , $ namespace = null ) { if ( $ value != null ) { $ value = htmlspecialchars ( $ value , ENT_XML1 ) ; } return parent :: addChild ( $ key , $ value , $ namespace ) ; }
12075	public function childShow ( FilterRequest $ filters , $ id , $ idChild , $ relation ) { $ id = $ this -> getRealId ( $ id ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> getChild ( $ id , $ relation , $ idChild , $ filters ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
6416	public static function skip ( IteratorAggregate $ iterable , int $ numberToSkip ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ iterable , $ numberToSkip ) { $ iterator = Iterators :: from ( $ iterable -> getIterator ( ) ) ; Iterators :: advance ( $ iterator , $ numberToSkip ) ; return $ iterator ; } ) ; }
8557	public function setType ( $ type ) { if ( ! $ this -> isNumericArray ( $ type ) ) { $ type = array ( $ type ) ; } $ this -> fields [ 'Type' ] [ 'FieldValue' ] = $ type ; return $ this ; }
11484	protected function getFunctionArguments ( ReflectionFunctionAbstract $ func , array $ params = array ( ) ) { $ args = [ ] ; foreach ( $ func -> getParameters ( ) as $ param ) { $ class = $ param -> getClass ( ) ; if ( $ class ) { $ args [ ] = $ this -> resolveClassArg ( $ class , $ param , $ params ) ; } else { $ args [ ] = $ this -> resolveNonClassArg ( $ param , $ params , $ func ) ; } } return $ args ; }
8055	public static function get ( $ length = 8 , $ outputFormat = Code :: FORMAT_ALNUM ) { static :: throwUnlessAcceptable ( $ outputFormat , $ length ) ; $ number = rand ( 100 , 900 ) . str_replace ( '.' , '' , microtime ( true ) ) ; $ output = self :: convertBase ( $ number , self :: FORMAT_NUMBER , $ outputFormat ) ; if ( strlen ( $ output ) < $ length ) { $ output .= substr ( str_shuffle ( $ outputFormat . $ outputFormat ) , 0 , ( $ length - strlen ( $ output ) ) ) ; } if ( strlen ( $ output ) > $ length ) { $ output = substr ( $ output , 0 , $ length ) ; } return $ output ; }
11098	public static function secondsBetweenWorkingDays ( $ dateFrom , $ dateTo , $ workDayFrom , $ workDayTo , $ weekends = false , $ holidays = false , $ timeZone = 'Europe/Prague' ) { $ timeZoneObj = new \ DateTimeZone ( $ timeZone ) ; $ dateFromObj = new DateTime ( $ dateFrom , $ timeZoneObj ) ; $ dateToObj = new DateTime ( $ dateTo , $ timeZoneObj ) ; $ workDayFromObj = new DateTime ( $ workDayFrom , $ timeZoneObj ) ; $ workDayToObj = new DateTime ( $ workDayTo , $ timeZoneObj ) ; $ workDayLength = self :: secondsBetweenDates ( $ workDayFrom , $ workDayTo , true , $ timeZone ) ; $ period = new \ DatePeriod ( new DateTime ( $ dateFromObj -> format ( 'Y-m-d 00:00:00' ) , $ timeZoneObj ) , new \ DateInterval ( 'P1D' ) , new DateTime ( $ dateToObj -> format ( 'Y-m-d 23:59:59' ) , $ timeZoneObj ) ) ; $ workedTime = 0 ; foreach ( $ period as $ date ) { if ( ( ! $ weekends && ( int ) $ date -> format ( 'N' ) > 5 ) || ( ! $ holidays && self :: isCzechHoliday ( $ date ) ) ) { continue ; } if ( $ date -> format ( 'Y-m-d' ) === $ dateFromObj -> format ( 'Y-m-d' ) ) { $ endOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayToObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateFromObj < $ endOfDay && $ dateFromObj -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ diff = $ dateToObj -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } else { $ diff = $ endOfDay -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } elseif ( $ date -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ startOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayFromObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateToObj > $ startOfDay ) { $ diff = $ startOfDay -> diff ( $ dateToObj ) -> format ( '%H:%I:%S' ) ; $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } } else { $ workedTime += $ workDayLength ; } } return $ workedTime ; }
9873	private function writeDrawings ( XMLWriter $ objWriter = null , PhpspreadsheetWorksheet $ pSheet = null , $ includeCharts = false ) { $ chartCount = ( $ includeCharts ) ? $ pSheet -> getChartCollection ( ) -> count ( ) : 0 ; if ( ( $ pSheet -> getDrawingCollection ( ) -> count ( ) > 0 ) || ( $ chartCount > 0 ) ) { $ objWriter -> startElement ( 'drawing' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId1' ) ; $ objWriter -> endElement ( ) ; } }
1416	public function invalidQueryParameter ( string $ param , ? string $ detail = null , array $ failed = [ ] ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_BAD_REQUEST , $ this -> trans ( 'query_invalid' , 'code' ) , $ this -> trans ( 'query_invalid' , 'title' ) , $ detail ? : $ this -> trans ( 'query_invalid' , 'detail' ) , [ Error :: SOURCE_PARAMETER => $ param ] , $ failed ? compact ( 'failed' ) : null ) ; }
4531	public function process ( ContainerBuilder $ container ) { $ definition = $ container -> findDefinition ( LoaderCollection :: class ) ; $ services = $ container -> findTaggedServiceIds ( 'ds_tenant.loader' ) ; $ items = [ ] ; foreach ( $ services as $ id => $ tags ) { foreach ( $ tags as $ tag ) { $ items [ ] = [ 'id' => $ id , 'priority' => array_key_exists ( 'priority' , $ tag ) ? $ tag [ 'priority' ] : 0 , 'alias' => array_key_exists ( 'alias' , $ tag ) ? $ tag [ 'alias' ] : null ] ; } } usort ( $ items , function ( $ a , $ b ) { return $ a [ 'priority' ] === $ b [ 'priority' ] ? 0 : $ a [ 'priority' ] < $ b [ 'priority' ] ? - 1 : 1 ; } ) ; foreach ( $ items as $ item ) { if ( null !== $ item [ 'alias' ] ) { $ definition -> addMethodCall ( 'set' , [ $ item [ 'alias' ] , new Reference ( $ item [ 'id' ] ) ] ) ; } else { $ definition -> addMethodCall ( 'add' , [ new Reference ( $ item [ 'id' ] ) ] ) ; } } }
6576	public function stop ( ) : void { if ( $ this -> isStarted ( ) ) { $ this -> getHandler ( ) -> destroy ( $ this -> getDataHolder ( ) -> getId ( ) ) ; $ this -> dataHolder = null ; } }
6589	public function post ( $ url , $ data = null , $ method = "POST" ) { return $ this -> request ( [ CURLOPT_POST => true , CURLOPT_CUSTOMREQUEST => $ method ? : "POST" , CURLOPT_URL => "$url" , CURLOPT_POSTFIELDS => $ data ? : '' , ] ) ; }
9465	public function getSummary ( ) { $ string = "---\n" ; foreach ( $ this -> getWords ( ) as $ k => $ v ) { $ string .= '[' . $ k . ']: Docs:' . $ v [ 'docs' ] . ' | Hits:' . $ v [ 'hits' ] . "\n" ; } return $ string ; }
9192	public function init ( ) { if ( $ this -> isInitialized ( ) ) return true ; $ sm = $ this -> getServiceManager ( ) ; $ defaultListeners = $ sm -> get ( 'yimaTheme.Manager.ListenerAggregate' ) ; if ( $ defaultListeners instanceof self ) $ defaultListeners -> manager = $ this ; $ sharedEvents = $ this -> getEventManager ( ) -> getSharedManager ( ) ; $ sharedEvents -> attachAggregate ( $ defaultListeners ) ; $ this -> isInitialized = true ; return $ this ; }
10676	private function _rightStr ( $ n , $ txt ) { $ rv = '' ; $ length = mb_strlen ( $ txt , 'UTF-8' ) ; for ( $ i = $ n ; $ i < $ length ; $ i ++ ) { $ rv .= mb_substr ( $ txt , $ i , 1 , 'UTF-8' ) ; } return $ rv ; }
8925	public function mapJson ( $ json , $ targetClass ) { if ( ! is_array ( $ data = json_decode ( $ json , true ) ) ) { throw new InvalidJsonException ( ) ; } $ result = null ; if ( substr ( $ targetClass , - 2 ) == '[]' ) { $ result = [ ] ; foreach ( $ data as $ key => $ entryData ) { $ result [ ] = $ this -> mapDataToObject ( $ entryData , substr ( $ targetClass , 0 , - 2 ) ) ; } } else { $ result = $ this -> mapDataToObject ( $ data , $ targetClass ) ; } return $ result ; }
995	private function getDeprecationReason ( $ node ) { $ deprecated = Values :: getDirectiveValues ( Directive :: deprecatedDirective ( ) , $ node ) ; return $ deprecated [ 'reason' ] ?? null ; }
9226	public function get ( $ path , $ data = array ( ) , $ headers = array ( ) ) { return $ this -> postprocessResponse ( parent :: get ( $ path , $ this -> preprocessData ( $ data ) , $ headers ) ) ; }
9463	public function compose ( View $ view ) { $ this -> sidebar -> loadItemsFromConfig ( 'arcanesoft.foundation.sidebar.items' ) ; $ this -> sidebar -> setCurrent ( Arr :: get ( $ view -> getData ( ) , 'current_page' , '' ) ) ; }
2564	public static function generateSomewhatRandomString ( $ length = 22 ) { $ chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz" ; srand ( ( double ) microtime ( ) * 1000000 ) ; $ i = 0 ; $ somewhatRandom = '' ; while ( $ i < $ length ) { $ num = rand ( ) % 60 ; $ tmp = substr ( $ chars , $ num , 1 ) ; $ somewhatRandom = $ somewhatRandom . $ tmp ; $ i ++ ; } return $ somewhatRandom ; }
10223	public function menuFor ( $ model , $ modelId = 0 , ModelConfig $ config = null ) { if ( is_null ( $ this -> aujaConfigurator ) ) { throw new \ LogicException ( 'Auja not initialized. Call Auja::init first.' ) ; } $ modelName = $ this -> resolveModelName ( $ model ) ; if ( $ modelId == 0 ) { $ menu = $ this -> noAssociationsMenuFor ( $ modelName , $ config ) ; } else { $ menu = $ this -> buildComplexIndexMenu ( $ modelName , $ modelId , $ config ) ; } return $ menu ; }
2342	protected function getUserId ( ) { if ( $ this -> intUserId !== null ) { return $ this -> intUserId ; } $ this -> import ( BackendUser :: class , 'User' ) ; return $ this -> User -> id ; }
5913	public function addUserToGroup ( $ id , array $ groupIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'groupIds' => $ groupIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/groups' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
3602	public function isDebug ( ) { if ( null !== $ this -> container && $ this -> container -> has ( 'kernel' ) ) { return $ this -> container -> get ( 'kernel' ) -> isDebug ( ) ; } return true ; }
10461	public function initialize ( $ filePath , $ params ) { copy ( __DIR__ . '/../../../recipe/releaz.php' , $ filePath ) ; $ exampleFile = $ this -> getExamplePath ( ) ; $ projectFile = dirname ( $ filePath ) . '/' . $ this -> getExample ( ) ; copy ( $ exampleFile , $ projectFile ) ; $ this -> setParamsInExample ( $ projectFile , $ params ) ; }
12705	public function getContentAttribute ( $ value ) { if ( $ value === null ) { $ value = '' ; } if ( getenv ( "BYPASS_HOOKS" ) != true ) { global $ hooks , $ codes ; return markdown_interpreter ( $ hooks -> apply_filters ( "TCT-Core-Main-Model-Page-Content" , $ codes -> do_shortcode ( $ value ) ) ) ; } else { return $ value ; } }
4078	protected function fetchInputScreenDetails ( ) { $ inputScreenIds = array ( ) ; foreach ( $ this -> information as $ info ) { $ inputScreenIds [ ] = $ info [ self :: COMBINATION ] [ 'dca_id' ] ; } if ( ! $ inputScreenIds ) { return ; } $ statement = $ this -> connection -> query ( sprintf ( 'SELECT * FROM tl_metamodel_dca WHERE id IN (%s)' , implode ( ',' , $ inputScreenIds ) ) ) ; while ( $ inputScreens = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ screenId = $ inputScreens -> id ; $ metaModelId = $ inputScreens -> pid ; $ metaModelName = $ this -> tableNameFromId ( $ metaModelId ) ; $ propertyRows = $ this -> connection -> prepare ( 'SELECT * FROM tl_metamodel_dcasetting WHERE pid=? AND published=1 ORDER BY sorting ASC' ) ; $ propertyRows -> bindValue ( 1 , $ screenId ) ; $ propertyRows -> execute ( ) ; $ conditions = $ this -> connection -> prepare ( ' SELECT cond.*, setting.attr_id AS setting_attr_id FROM tl_metamodel_dcasetting_condition AS cond LEFT JOIN tl_metamodel_dcasetting AS setting ON (cond.settingId=setting.id) LEFT JOIN tl_metamodel_dca AS dca ON (setting.pid=dca.id) WHERE dca.id=? AND setting.published=1 AND cond.enabled=1 ORDER BY sorting ASC ' ) ; $ conditions -> bindValue ( 1 , $ screenId ) ; $ conditions -> execute ( ) ; $ groupSort = $ this -> connection -> prepare ( ' SELECT * FROM tl_metamodel_dca_sortgroup WHERE pid=? ORDER BY sorting ASC ' ) ; $ groupSort -> bindValue ( 1 , $ screenId ) ; $ groupSort -> execute ( ) ; $ inputScreen = array ( 'row' => $ inputScreens -> row ( ) , 'properties' => $ propertyRows -> fetchAll ( \ PDO :: FETCH_ASSOC ) , 'conditions' => $ conditions -> fetchAll ( \ PDO :: FETCH_ASSOC ) , 'groupSort' => $ groupSort -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] = $ inputScreen ; $ this -> information [ $ metaModelName ] [ self :: MODELID ] = $ metaModelId ; $ parentTable = $ inputScreen [ 'row' ] [ 'ptable' ] ; if ( $ parentTable && ! $ this -> isInputScreenStandalone ( $ metaModelName ) ) { $ this -> parentMap [ $ parentTable ] [ ] = $ this -> information [ $ metaModelName ] [ self :: MODELID ] ; $ this -> childMap [ $ metaModelName ] = $ parentTable ; } } }
5864	public function getDirectoryPattern ( $ directory ) { $ pattern = '/^' . str_replace ( '/' , '\\/' , $ directory ) . '/' ; $ pattern = str_replace ( '\\/**\\/' , '\\/([^\/]+\\/)*' , $ pattern ) ; $ pattern = str_replace ( '\\/*\\/' , '\\/[^\/]+\\/' , $ pattern ) ; return $ pattern ; }
10735	public function setUpper ( $ upper ) : self { if ( ! is_numeric ( $ upper ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, upper, to be a number" ) ; } $ this -> upper = $ upper ; return $ this ; }
6140	public function checkUser ( $ username = null ) { if ( $ username === null ) { $ username = $ this -> user ; } if ( strlen ( $ username ) == 0 ) { return true ; } $ pattern = "/^(" . $ this -> regex [ "alphanum" ] . "|" . $ this -> regex [ "mark" ] . "|" . $ this -> regex [ "escaped" ] . "|[;:&=+$,])+$/" ; $ status = @ preg_match ( $ pattern , $ username ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI username validation failed" ) ; } return ( $ status == 1 ) ; }
4011	public function getPaginationString ( ) { $ this -> calculate ( ) ; if ( $ this -> getPerPage ( ) == 0 ) { return '' ; } $ objPagination = new \ Pagination ( $ this -> calculatedTotal , $ this -> getPerPage ( ) , $ this -> getMaxPaginationLinks ( ) ) ; return $ objPagination -> generate ( "\n " ) ; }
11336	public function getBaseNamespace ( ) { if ( ! empty ( $ this -> moduleSet ) && isset ( Yii :: $ app -> extensions [ $ this -> moduleSet ] ) ) { $ bsClass = Yii :: $ app -> extensions [ $ this -> moduleSet ] [ 'bootstrap' ] ; $ bsReflector = new \ ReflectionClass ( new $ bsClass ( ) ) ; return $ bsReflector -> getNamespaceName ( ) ; } return 'cascade\modules' ; }
3489	private function createTemporaryFile ( ) : string { $ tmpDir = $ this -> tmpDir ; $ tmpFileName = md5 ( uniqid ( ( string ) mt_rand ( ) , true ) ) . '.p8' ; $ tmpFilePath = $ tmpDir . '/' . $ tmpFileName ; $ errorCode = $ errorMessage = null ; set_error_handler ( function ( $ errCode , $ errMessage ) use ( & $ errorCode , & $ errorMessage ) { $ errorCode = $ errCode ; $ errorMessage = $ errMessage ; } ) ; if ( ! file_exists ( $ tmpDir ) ) { mkdir ( $ tmpDir , 0600 , true ) ; if ( $ errorCode || $ errorMessage ) { restore_error_handler ( ) ; throw new \ RuntimeException ( sprintf ( 'Can not create temporary directory "%s". Error: %s [%d].' , $ tmpDir , $ errorMessage ? : 'Undefined' , $ errorCode ? : '0' ) ) ; } } touch ( $ tmpFilePath ) ; if ( $ errorCode || $ errorMessage ) { restore_error_handler ( ) ; throw new \ RuntimeException ( sprintf ( 'Can not create temporary certificate file "%s". Error: %s [%d].' , $ tmpFilePath , $ errorMessage ? : 'Undefined' , $ errorCode ? : '0' ) ) ; } restore_error_handler ( ) ; return $ tmpFilePath ; }
12190	public function getActive ( ) { return ( isset ( $ this -> _child ) and $ this -> _child -> active ) and ( isset ( $ this -> _parent ) and $ this -> _parent -> active ) ; }
10829	public static function dir ( string $ path ) : fs \ entity \ DirEntity { return ( new fs \ entity \ DirEntity ( $ path ) ) -> normalize ( ) ; }
7255	public function loggedIn ( ) { if ( $ this -> _viewAuth ) { return $ this -> sessionKey && $ this -> request -> session ( ) -> check ( $ this -> sessionKey ) ; } return false ; }
365	public function renderColumnGroup ( ) { foreach ( $ this -> columns as $ column ) { if ( ! empty ( $ column -> options ) ) { $ cols = [ ] ; foreach ( $ this -> columns as $ col ) { $ cols [ ] = Html :: tag ( 'col' , '' , $ col -> options ) ; } return Html :: tag ( 'colgroup' , implode ( "\n" , $ cols ) ) ; } } return false ; }
12796	public function clear ( $ queue ) { $ this -> client -> request -> post ( $ this -> apiEndpoint . '/projects/' . $ this -> params [ 'project' ] . '/queues/' . $ queue . '/clear' ) ; }
7203	public function addDiscountAdjustment ( Adjustment $ discount ) : void { foreach ( $ this -> discounts as $ d ) { if ( $ d -> isSameAs ( $ discount ) ) { $ d -> addAmount ( $ discount -> getAmount ( ) ) ; return ; } } $ this -> discounts [ ] = clone $ discount ; }
5636	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; print $ this -> getFailCount ( ) . ") $message\n" ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print "\tin " . implode ( "\n\tin " , array_reverse ( $ breadcrumb ) ) ; print "\n" ; }
3224	function getThumbnail ( $ path , $ format , $ size ) { Path :: checkArgNonRoot ( "path" , $ path ) ; Checker :: argString ( "format" , $ format ) ; Checker :: argString ( "size" , $ size ) ; if ( ! in_array ( $ format , array ( "jpeg" , "png" ) ) ) { throw new \ InvalidArgumentException ( "Invalid 'format': " . Util :: q ( $ format ) ) ; } if ( ! in_array ( $ size , array ( "xs" , "s" , "m" , "l" , "xl" ) ) ) { throw new \ InvalidArgumentException ( "Invalid 'size': " . Util :: q ( $ size ) ) ; } $ url = $ this -> buildUrlForGetOrPut ( $ this -> contentHost , $ this -> appendFilePath ( "1/thumbnails" , $ path ) , array ( "size" => $ size , "format" => $ format ) ) ; $ curl = $ this -> mkCurl ( $ url ) ; $ metadataCatcher = new DropboxMetadataHeaderCatcher ( $ curl -> handle ) ; $ curl -> set ( CURLOPT_RETURNTRANSFER , true ) ; $ response = $ curl -> exec ( ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ metadata = $ metadataCatcher -> getMetadata ( ) ; return array ( $ metadata , $ response -> body ) ; }
8206	protected function buryJob ( $ job , $ priority = null ) { if ( is_null ( $ priority ) ) { $ priority = Pheanstalk :: DEFAULT_PRIORITY ; } $ this -> getPheanstalk ( ) -> bury ( $ job , $ priority ) ; }
10776	public function fromArray ( array $ array ) { $ root = new Node ( null ) ; $ map = array ( ) ; $ map [ 0 ] = $ root ; foreach ( $ array as $ element ) { if ( 3 !== count ( $ element ) ) { throw new Exception ( 'Each array must have 3 elements.' ) ; } $ map [ $ element [ 0 ] ] = new Node ( $ element [ 2 ] ) ; } foreach ( $ array as $ element ) { if ( empty ( $ element [ 1 ] ) ) { $ element [ 1 ] = 0 ; } $ found = false ; $ i = 0 ; $ keys = array_keys ( $ map ) ; $ cnt = count ( $ keys ) ; while ( ! $ found && $ i < $ cnt ) { if ( $ keys [ $ i ] === $ element [ 1 ] ) { $ map [ $ keys [ $ i ] ] -> addChild ( $ map [ $ element [ 0 ] ] ) ; $ found = true ; } else { $ i ++ ; } } if ( ! $ found ) { throw new Exception ( 'Data structure does not seem to be consistent. ' . 'Key "' . $ element [ 1 ] . '" could not be found.' ) ; } } return $ root ; }
8515	public function putTransportContent ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_PutTransportContentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_PutTransportContentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'PutTransportContent' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_PutTransportContentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7715	static function FindStartTagByPrefix ( & $ Txt , $ TagPrefix , $ PosBeg , $ Forward = true ) { $ x = '<' . $ TagPrefix ; $ xl = strlen ( $ x ) ; if ( $ Forward ) { $ PosBeg = strpos ( $ Txt , $ x , $ PosBeg ) ; } else { $ PosBeg = strrpos ( substr ( $ Txt , 0 , $ PosBeg + 2 ) , $ x ) ; } if ( $ PosBeg === false ) return false ; $ Tag = $ TagPrefix ; $ p = $ PosBeg + $ xl ; do { $ z = substr ( $ Txt , $ p , 1 ) ; if ( ( $ z !== ' ' ) && ( $ z !== "\r" ) && ( $ z !== "\n" ) && ( $ z !== '>' ) && ( $ z !== '/' ) ) { $ Tag .= $ z ; $ p ++ ; } else { $ p = false ; } } while ( $ p !== false ) ; return new clsTbsXmlLoc ( $ Txt , $ Tag , $ PosBeg ) ; }
11858	public function getHandler ( ) { if ( $ this -> pairedDataItem ) { if ( ! isset ( $ this -> primaryObject ) ) { return $ this -> pairedDataItem ; } elseif ( isset ( $ this -> companionObject ) ) { return static :: getHandlingObject ( $ this , $ this -> pairedDataItem ) ; } } return $ this ; }
3136	public function setItemState ( RunnerServiceContext $ context , $ itemRef , $ state ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ serviceService = $ this -> getServiceManager ( ) -> get ( StorageManager :: SERVICE_ID ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ stateId = $ this -> getStateId ( $ context , $ itemRef ) ; if ( ! isset ( $ state ) ) { $ state = '' ; } return is_null ( $ userUri ) ? false : $ serviceService -> set ( $ userUri , $ stateId , json_encode ( $ state ) ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'setItemState' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
11048	function add_system_var ( & $ datatree , $ index , $ last , $ key ) { $ datatree -> _key = $ key ; $ datatree -> _index = $ index ; $ datatree -> _rank = $ index + 1 ; $ datatree -> _odd = $ datatree -> _not_even = ( 1 == $ datatree -> _rank % 2 ) ; $ datatree -> _even = $ datatree -> _not_odd = ( 0 == $ datatree -> _rank % 2 ) ; $ datatree -> _first = ( 0 == $ index ) ; $ datatree -> _middle = ! $ datatree -> _first && ! $ last ; $ datatree -> _last = $ last ; $ datatree -> _not_first = ! $ datatree -> _first ; $ datatree -> _not_last = ! $ last ; $ datatree -> _not_middle = ! $ datatree -> _middle ; }
4552	public function exists ( UserParameters $ parameters = null ) { $ object = $ this -> execute ( 'GET' , 'http://www.mocky.io/v2/592c6f7311000029066df850' ) ; if ( $ object && property_exists ( $ object , '_id' ) && $ object -> _id ) { return true ; } return false ; }
3006	static public function jump ( \ Base $ f3 , $ params ) { $ target = $ f3 -> get ( 'GET.target' ) ; if ( $ f3 -> exists ( 'mailer.on.jump' , $ jump_handler ) ) $ f3 -> call ( $ jump_handler , array ( $ target , $ params ) ) ; $ f3 -> reroute ( urldecode ( $ target ) ) ; }
7071	protected function updateMessage ( TicketMessageInterface $ message ) { $ message -> setUpdatedAt ( new \ DateTime ( ) ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ message , true ) ; }
5177	public function map ( \ Closure $ callback , $ context = [ ] ) : self { $ collection = new static ( ) ; foreach ( $ this -> props as $ key => $ value ) { $ collection -> add ( $ key , $ callback ( $ value , $ key , $ context ) ) ; } return $ collection ; }
9819	public function setSegmentSize ( $ size ) { if ( null !== $ this -> memory ) { throw new Exception \ RuntimeException ( 'You can not change the segment size because memory is already allocated.' . ' Use realloc() function to create new memory segment.' ) ; } $ this -> segmentSize = ( integer ) $ size ; return $ this ; }
12760	public static function dispatch ( $ eventName , Event $ event ) { if ( null === self :: $ dispatcher ) { return $ event ; } self :: $ dispatcher -> dispatch ( $ eventName , $ event ) ; DataLogger :: log ( sprintf ( 'The "%s" event was dispatched' , $ eventName ) ) ; if ( $ event -> getAbort ( ) ) { DataLogger :: log ( sprintf ( 'The "%s" event was aborted' , $ eventName ) , DataLogger :: ERROR ) ; throw new EventAbortedException ( $ event -> getAbortMessage ( ) ) ; } return $ event ; }
3876	private function getMetaModelsPages ( $ config , $ rootPage = null , $ language = null ) { $ metaModelsIdentifier = $ config [ 'pid' ] ; $ filterIdentifier = $ config [ 'filter' ] ; $ presetParams = StringUtil :: deserialize ( $ config [ 'filterparams' ] , true ) ; $ renderSettingId = $ config [ 'rendersetting' ] ; $ metaModels = $ this -> getMetaModel ( $ metaModelsIdentifier , false ) ; $ availableLanguages = $ this -> getLanguage ( $ language , $ metaModels ) ; $ currentLanguage = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ availableLanguages as $ newLanguage ) { $ GLOBALS [ 'TL_LANGUAGE' ] = $ newLanguage ; $ view = $ this -> getView ( $ metaModelsIdentifier , $ renderSettingId ) ; $ jumpTos = $ view -> get ( 'jumpTo' ) ; $ processed = $ this -> setFilterParameters ( $ filterIdentifier , $ presetParams , array ( ) ) ; $ filter = $ metaModels -> getEmptyFilter ( ) ; $ filterSetting = $ this -> getFilterSettings ( $ filterIdentifier ) ; $ filterSetting -> addRules ( $ filter , $ processed ) ; $ newEntries = $ this -> getJumpTosFor ( $ metaModels , $ filter , $ view , $ rootPage ) ; $ this -> removeEmptyDetailPages ( $ jumpTos ) ; $ GLOBALS [ 'TL_LANGUAGE' ] = $ currentLanguage ; $ this -> foundPages = array_merge ( $ this -> foundPages , $ newEntries ) ; } $ GLOBALS [ 'TL_LANGUAGE' ] = $ currentLanguage ; }
11005	public function setSandbox ( string $ sandbox ) : void { if ( ! in_array ( $ sandbox , self :: SANDBOX_VALUES ) ) { throw new MiddlewareException ( $ this , sprintf ( "%s is not a correct value for the CSP sandbox, correct values are: %s (see %s)" , $ sandbox , implode ( ', ' , self :: SANDBOX_VALUES ) , 'https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/sandbox' ) ) ; } $ this -> tags [ 'sandbox' ] = $ sandbox ; }
7049	protected function buildGoodsLines ( Document \ DocumentInterface $ document ) { foreach ( $ document -> getSale ( ) -> getItems ( ) as $ item ) { $ this -> buildGoodLine ( $ item , $ document ) ; } }
11070	public function setBoolean ( string $ key , $ value , bool $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( bool ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
4886	public function plugin ( $ plugin , $ options = null ) { $ renderer = $ this -> getView ( ) ; if ( ! method_exists ( $ renderer , 'getHelperPluginManager' ) ) { return true === $ options ? false : new HelperProxy ( false ) ; } $ manager = $ renderer -> getHelperPluginManager ( ) ; $ hasPlugin = $ manager -> has ( $ plugin ) ; if ( true === $ options ) { return $ hasPlugin ; } if ( $ hasPlugin ) { $ pluginInstance = $ manager -> get ( $ plugin , $ options ) ; } else { $ pluginInstance = false ; } return new HelperProxy ( $ pluginInstance ) ; }
2439	public function cloneForCurrent ( string $ current ) : self { return new self ( $ this -> context , $ this -> extras , $ this -> value , $ current ) ; }
1191	private function addCustomDefinition ( array $ definitionConfig , HTMLPurifier_Config $ configObject = null ) { if ( ! $ configObject ) { $ configObject = HTMLPurifier_Config :: createDefault ( ) ; $ configObject -> loadArray ( $ this -> getConfig ( ) ) ; } $ configObject -> set ( 'HTML.DefinitionID' , $ definitionConfig [ 'id' ] ) ; $ configObject -> set ( 'HTML.DefinitionRev' , $ definitionConfig [ 'rev' ] ) ; if ( ! isset ( $ definitionConfig [ 'debug' ] ) || $ definitionConfig [ 'debug' ] ) { $ configObject -> set ( 'Cache.DefinitionImpl' , null ) ; } if ( $ def = $ configObject -> maybeGetRawHTMLDefinition ( ) ) { if ( ! empty ( $ definitionConfig [ 'attributes' ] ) ) { $ this -> addCustomAttributes ( $ definitionConfig [ 'attributes' ] , $ def ) ; } if ( ! empty ( $ definitionConfig [ 'elements' ] ) ) { $ this -> addCustomElements ( $ definitionConfig [ 'elements' ] , $ def ) ; } } return $ configObject ; }
9905	private function updateSingleCellReference ( $ pCellReference = 'A1' , $ pBefore = 'A1' , $ pNumCols = 0 , $ pNumRows = 0 ) { if ( Coordinate :: coordinateIsRange ( $ pCellReference ) ) { throw new Exception ( 'Only single cell references may be passed to this method.' ) ; } list ( $ beforeColumn , $ beforeRow ) = Coordinate :: coordinateFromString ( $ pBefore ) ; list ( $ newColumn , $ newRow ) = Coordinate :: coordinateFromString ( $ pCellReference ) ; $ updateColumn = ( ( $ newColumn [ 0 ] != '$' ) && ( $ beforeColumn [ 0 ] != '$' ) && ( Coordinate :: columnIndexFromString ( $ newColumn ) >= Coordinate :: columnIndexFromString ( $ beforeColumn ) ) ) ; $ updateRow = ( ( $ newRow [ 0 ] != '$' ) && ( $ beforeRow [ 0 ] != '$' ) && $ newRow >= $ beforeRow ) ; if ( $ updateColumn ) { $ newColumn = Coordinate :: stringFromColumnIndex ( Coordinate :: columnIndexFromString ( $ newColumn ) + $ pNumCols ) ; } if ( $ updateRow ) { $ newRow = $ newRow + $ pNumRows ; } return $ newColumn . $ newRow ; }
1785	private function isRequestPrivate ( Request $ request ) : bool { if ( $ request -> headers -> has ( 'Authorization' ) ) { return true ; } if ( \ count ( $ request -> cookies -> all ( ) ) ) { return true ; } return false ; }
4676	public function render ( $ region = "main" ) { if ( ! isset ( $ this -> views [ $ region ] ) ) { return $ this ; } mergesort ( $ this -> views [ $ region ] , function ( $ viewA , $ viewB ) { $ sortA = $ viewA -> sortOrder ( ) ; $ sortB = $ viewB -> sortOrder ( ) ; if ( $ sortA == $ sortB ) { return 0 ; } return $ sortA < $ sortB ? - 1 : 1 ; } ) ; foreach ( $ this -> views [ $ region ] as $ view ) { $ view -> render ( $ this -> di ) ; } }
4335	public function onOutput ( Event $ event ) { if ( ! $ event [ 'isTarget' ] ) { return ; } $ this -> data = $ this -> debug -> getData ( ) ; $ this -> closeOpenGroups ( ) ; foreach ( $ this -> data [ 'logSummary' ] as & $ log ) { $ this -> removeHideIfEmptyGroups ( $ log ) ; $ this -> uncollapseErrors ( $ log ) ; } $ this -> removeHideIfEmptyGroups ( $ this -> data [ 'log' ] ) ; $ this -> uncollapseErrors ( $ this -> data [ 'log' ] ) ; $ this -> debug -> setData ( $ this -> data ) ; }
4381	protected function visualWhiteSpaceCallback ( $ matches ) { $ strBr = $ this -> debug -> getCfg ( 'addBR' ) ? '<br />' : '' ; $ search = array ( "\r" , "\n" ) ; $ replace = array ( '<span class="ws_r"></span>' , '<span class="ws_n"></span>' . $ strBr . "\n" ) ; return \ str_replace ( $ search , $ replace , $ matches [ 1 ] ) ; }
8680	public function sortKeys ( $ order = SORT_ASC , $ flags = SORT_REGULAR ) { $ this -> validateSortArgs ( $ order , $ flags ) ; $ items = $ this -> items ; if ( $ order === SORT_ASC ) { ksort ( $ items , $ flags ) ; } else { krsort ( $ items , $ flags ) ; } return $ this -> createFrom ( $ items ) ; }
7474	public function updateAction ( Request $ request , $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( UserType :: class , $ user , array ( 'include_password' => false ) ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ id ) ) ) ; } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
6101	public function listPropertySets ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/propertysets' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new PropertySet ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
3537	public function getGroupsAssignedInLdap ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'getGroupsAssignedInLdap' , static :: YII2_PROFILE_NAME . 'getGroupsAssignedInLdap' ) ; } $ ldapUser = $ this -> queryLdapUserObject ( ) ; $ ldapGroupsConverted = [ ] ; if ( $ ldapUser != null ) { if ( static :: getGroupAssigmentOptions ( 'SEARCH_NESTED_GROUPS' , $ this -> individualGroupAssignmentOptions ) == true ) { $ ldapGroups = static :: getAdldapProvider ( ) -> search ( ) -> rawFilter ( '(member:1.2.840.113556.1.4.1941:=' . $ ldapUser -> getDn ( ) . ')' ) -> select ( 'cn' ) -> raw ( ) -> get ( ) ; if ( $ ldapGroups == null ) { $ ldapGroups = [ ] ; } foreach ( $ ldapGroups as $ groupDn ) { if ( is_array ( $ groupDn ) && array_key_exists ( 'cn' , $ groupDn ) ) { array_push ( $ ldapGroupsConverted , $ groupDn [ 'cn' ] [ 0 ] ) ; } } } else { $ ldapGroups = $ ldapUser -> getAttribute ( 'memberof' ) ; if ( $ ldapGroups == null ) { $ ldapGroups = [ ] ; } foreach ( $ ldapGroups as $ groupDn ) { $ n = Utilities :: explodeDn ( $ groupDn ) [ 0 ] ; array_push ( $ ldapGroupsConverted , $ n ) ; } } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'getGroupsAssignedInLdap' , static :: YII2_PROFILE_NAME . 'getGroupsAssignedInLdap' ) ; } return $ ldapGroupsConverted ; }
2413	protected function addTableTlStyleSheet ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_style_sheet' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_style_sheet' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_style_sheet' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; $ objStyleSheet = $ this -> Database -> prepare ( "SELECT * FROM tl_style_sheet WHERE pid=? ORDER BY name" ) -> execute ( $ objTheme -> id ) ; while ( $ objStyleSheet -> next ( ) ) { $ this -> addDataRow ( $ xml , $ table , $ objStyleSheet -> row ( ) , $ arrOrder ) ; } $ objStyleSheet -> reset ( ) ; $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_style' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_style' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_style' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; while ( $ objStyleSheet -> next ( ) ) { $ objStyle = $ this -> Database -> prepare ( "SELECT * FROM tl_style WHERE pid=? ORDER BY sorting" ) -> execute ( $ objStyleSheet -> id ) ; while ( $ objStyle -> next ( ) ) { $ this -> addDataRow ( $ xml , $ table , $ objStyle -> row ( ) , $ arrOrder ) ; } } }
3336	public function getIntegrationData ( ) { $ integrationData = '' ; $ framework = $ this -> api -> getFramework ( ) ; if ( $ framework ) { $ integrationData .= $ framework ; } $ extension = $ this -> api -> getExtension ( ) ; if ( $ extension ) { $ integrationData .= '; ' . $ extension ; } return $ integrationData ; }
11269	public function getPath ( Neuron_GameServer_Map_Location $ start , Neuron_GameServer_Map_Location $ end ) { $ x1 = $ start [ 0 ] ; $ y1 = $ start [ 1 ] ; $ x2 = $ end [ 0 ] ; $ y2 = $ end [ 1 ] ; if ( ! $ this -> isPassable ( $ x2 , $ y2 ) ) { return false ; } $ astar = $ this -> astar ( $ start , $ end ) ; return $ astar ; }
12430	public function sort ( $ key , $ order = Sortable :: ASC ) { $ this -> criteria -> sort ( $ key , $ order ) ; return $ this ; }
6003	public function addVideoTemplate ( $ item ) { if ( ! ( $ item instanceof VideoTemplate ) ) { if ( is_array ( $ item ) ) { try { $ item = new VideoTemplate ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate VideoTemplate. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "VideoTemplate"!' , E_USER_WARNING ) ; } } $ this -> videotemplates [ ] = $ item ; return $ this ; }
7548	function childCount ( $ ignore_text_comments = false ) { if ( ! $ ignore_text_comments ) { return count ( $ this -> children ) ; } else { $ count = 0 ; foreach ( array_keys ( $ this -> children ) as $ k ) { if ( ! $ this -> children [ $ k ] -> isTextOrComment ( ) ) { ++ $ count ; } } return $ count ; } }
1958	private function getTaskFromInput ( InputInterface $ input , OutputInterface $ output ) : string { $ commands = $ this -> getCommands ( ) ; $ task = $ input -> getArgument ( 'task' ) ; if ( null !== $ task ) { if ( ! \ in_array ( $ task , $ commands , true ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid task "%s"' , $ task ) ) ; } return $ task ; } $ question = new ChoiceQuestion ( 'Please select a task:' , $ commands ) ; $ question -> setMaxAttempts ( 1 ) ; $ helper = $ this -> getHelper ( 'question' ) ; return $ helper -> ask ( $ input , $ output , $ question ) ; }
9635	public function read ( $ path , $ blocking = false ) { $ size = filesize ( $ path ) ; if ( $ size === 0 ) { return '' ; } $ flockFlags = $ blocking ? LOCK_SH : LOCK_SH | LOCK_NB ; $ file = fopen ( $ path , 'r' ) ; if ( ! flock ( $ file , $ flockFlags ) ) { fclose ( $ file ) ; throw new IOException ( "Could not aquire file lock for file: $path" ) ; } $ contents = fread ( $ file , $ size ) ; flock ( $ file , LOCK_UN | LOCK_NB ) ; fclose ( $ file ) ; return $ contents ; }
11357	public function add ( $ blockFile , $ blockContent ) { $ this -> removeBlock ( $ blockFile ) ; $ blockPermalinks = $ this -> fetchPermalinksFromBlock ( $ blockContent , $ blockFile ) ; if ( ! empty ( $ blockPermalinks ) ) { $ this -> permalinks = array_merge_recursive ( $ this -> permalinks , $ blockPermalinks ) ; } return $ this ; }
3826	protected function isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) { if ( empty ( $ strKeyOption ) && ! isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) ) { return true ; } $ blnIsActive = isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) && ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] == $ strKeyOption ) ; if ( ! $ blnIsActive && $ this -> get ( 'defaultid' ) ) { $ blnIsActive = ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] == $ this -> get ( 'defaultid' ) ) ; } return $ blnIsActive ; }
2132	public function add ( $ strKey , $ varValue ) { $ this -> markModified ( ) ; $ this -> arrData [ $ strKey ] = $ this -> escape ( $ varValue ) . ';' ; }
11762	public static function get ( $ property , $ default = NULL ) { $ object = new \ ReflectionClass ( Collection :: class ) ; $ value = $ object -> getStaticPropertyValue ( $ property ) ; return ( empty ( $ value ) ) ? $ default : $ value ; }
2959	public function confFlowControl ( $ mode ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set flow control mode : the device is " . "either not set or opened" , E_USER_WARNING ) ; return false ; } $ linuxModes = array ( "none" => "clocal -crtscts -ixon -ixoff" , "rts/cts" => "-clocal crtscts -ixon -ixoff" , "xon/xoff" => "-clocal -crtscts ixon ixoff" ) ; $ windowsModes = array ( "none" => "xon=off octs=off rts=on" , "rts/cts" => "xon=off octs=on rts=hs" , "xon/xoff" => "xon=on octs=off rts=on" , ) ; if ( $ mode !== "none" and $ mode !== "rts/cts" and $ mode !== "xon/xoff" ) { trigger_error ( "Invalid flow control mode specified" , E_USER_ERROR ) ; return false ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " " . $ linuxModes [ $ mode ] , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " " . $ linuxModes [ $ mode ] , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " " . $ windowsModes [ $ mode ] , $ out ) ; } if ( $ ret === 0 ) { return true ; } else { trigger_error ( "Unable to set flow control : " . $ out [ 1 ] , E_USER_ERROR ) ; return false ; } }
9637	public function handle ( GetResponseEvent $ event ) { $ apiKey = $ this -> getApiKeyFromQueryOrHeader ( $ event -> getRequest ( ) ) ; if ( false === $ apiKey ) { return ; } try { $ token = $ this -> authenticationManager -> authenticate ( new ApiKeyToken ( $ apiKey ) ) ; $ this -> tokenStorage -> setToken ( $ token ) ; } catch ( AuthenticationException $ failed ) { $ this -> tokenStorage -> setToken ( null ) ; $ this -> doFailureResponse ( $ event ) ; } }
4534	public function setCandidateGroup ( ? string $ candidateGroup ) { $ this -> candidateGroup = $ candidateGroup ; $ this -> _candidateGroup = null !== $ candidateGroup ; return $ this ; }
599	private function joinWithRelation ( $ parent , $ child , $ joinType ) { $ via = $ child -> via ; $ child -> via = null ; if ( $ via instanceof self ) { $ this -> joinWithRelation ( $ parent , $ via , $ joinType ) ; $ this -> joinWithRelation ( $ via , $ child , $ joinType ) ; return ; } elseif ( is_array ( $ via ) ) { $ this -> joinWithRelation ( $ parent , $ via [ 1 ] , $ joinType ) ; $ this -> joinWithRelation ( $ via [ 1 ] , $ child , $ joinType ) ; return ; } list ( $ parentTable , $ parentAlias ) = $ parent -> getTableNameAndAlias ( ) ; list ( $ childTable , $ childAlias ) = $ child -> getTableNameAndAlias ( ) ; if ( ! empty ( $ child -> link ) ) { if ( strpos ( $ parentAlias , '{{' ) === false ) { $ parentAlias = '{{' . $ parentAlias . '}}' ; } if ( strpos ( $ childAlias , '{{' ) === false ) { $ childAlias = '{{' . $ childAlias . '}}' ; } $ on = [ ] ; foreach ( $ child -> link as $ childColumn => $ parentColumn ) { $ on [ ] = "$parentAlias.[[$parentColumn]] = $childAlias.[[$childColumn]]" ; } $ on = implode ( ' AND ' , $ on ) ; if ( ! empty ( $ child -> on ) ) { $ on = [ 'and' , $ on , $ child -> on ] ; } } else { $ on = $ child -> on ; } $ this -> join ( $ joinType , empty ( $ child -> from ) ? $ childTable : $ child -> from , $ on ) ; if ( ! empty ( $ child -> where ) ) { $ this -> andWhere ( $ child -> where ) ; } if ( ! empty ( $ child -> having ) ) { $ this -> andHaving ( $ child -> having ) ; } if ( ! empty ( $ child -> orderBy ) ) { $ this -> addOrderBy ( $ child -> orderBy ) ; } if ( ! empty ( $ child -> groupBy ) ) { $ this -> addGroupBy ( $ child -> groupBy ) ; } if ( ! empty ( $ child -> params ) ) { $ this -> addParams ( $ child -> params ) ; } if ( ! empty ( $ child -> join ) ) { foreach ( $ child -> join as $ join ) { $ this -> join [ ] = $ join ; } } if ( ! empty ( $ child -> union ) ) { foreach ( $ child -> union as $ union ) { $ this -> union [ ] = $ union ; } } }
12121	public function getLastModified ( Request $ request ) { $ minModified = $ this -> getLastMinModifiedDate ( ) ; $ optionalLastModified = Option :: fromValue ( $ this -> cache -> fetch ( $ this -> getCacheKeyRequest ( sha1 ( $ request -> getUri ( ) ) , 'lastmodified' ) ) , false ) ; if ( $ optionalLastModified -> isEmpty ( ) ) { return $ minModified ; } return max ( $ minModified , new \ DateTime ( $ optionalLastModified -> get ( ) ) ) ; }
12042	public function update ( $ usernameId , $ data = array ( ) ) { if ( empty ( $ usernameId ) ) return false ; $ existing = ( array ) $ this -> getPropertyData ( ) ; $ data = empty ( $ data ) ? $ existing : array_merge ( $ data , $ existing ) ; $ profile = $ this -> loadObjectByURI ( $ usernameId , array_keys ( $ this -> getPropertyModel ( ) ) ) ; $ this -> setObjectId ( $ profile -> getObjectId ( ) ) ; $ this -> setObjectURI ( $ profile -> getObjectURI ( ) ) ; $ profileData = $ profile -> getPropertyData ( ) ; $ updatedProfile = array_merge ( $ profileData , $ data ) ; foreach ( $ updatedProfile as $ property => $ value ) : $ this -> setPropertyValue ( $ property , $ value ) ; endforeach ; $ this -> defineValueGroup ( "user" ) ; if ( ! $ this -> saveObject ( $ this -> getPropertyValue ( "user_name_id" ) , "user" , $ this -> getObjectId ( ) ) ) { $ profile -> setError ( "Could not save the profile data" ) ; return false ; } return true ; }
11655	private function _parseDsn ( $ dsn ) { $ dsn = parse_url ( $ dsn ) ; $ cfg = [ ] ; if ( isset ( $ dsn [ 'port' ] ) ) { $ cfg [ 'port' ] = $ dsn [ 'port' ] ; } return $ cfg + [ 'dbname' => isset ( $ dsn [ 'path' ] ) ? trim ( $ dsn [ 'path' ] , '/' ) : null , 'host' => isset ( $ dsn [ 'host' ] ) ? $ dsn [ 'host' ] : null , 'password' => isset ( $ dsn [ 'pass' ] ) ? $ dsn [ 'pass' ] : null , 'username' => isset ( $ dsn [ 'user' ] ) ? $ dsn [ 'user' ] : null , ] ; }
3208	public static function encode ( $ string ) { if ( strlen ( $ string ) == 0 ) { return '' ; } $ binaryString = '' ; foreach ( str_split ( $ string ) as $ s ) { $ binaryString .= sprintf ( '%08b' , ord ( $ s ) ) ; } $ binaryArray = self :: chunk ( $ binaryString , 5 ) ; while ( count ( $ binaryArray ) % 8 !== 0 ) { $ binaryArray [ ] = null ; } $ base32String = '' ; foreach ( $ binaryArray as $ bin ) { $ char = 32 ; if ( ! is_null ( $ bin ) ) { $ bin = str_pad ( $ bin , 5 , 0 , STR_PAD_RIGHT ) ; $ char = bindec ( $ bin ) ; } $ base32String .= self :: $ alphabet [ $ char ] ; } return $ base32String ; }
4057	private function convertAttribute ( array $ property , $ condition , array & $ legend ) { if ( ! isset ( $ property [ 'col_name' ] ) ) { return ; } $ legend [ 'properties' ] [ ] = [ 'name' => $ property [ 'col_name' ] , 'condition' => $ condition ( $ property ) ] ; }
4427	protected function askForChoiceData ( $ optionIdentifier , $ optionName , array $ choices , $ defaultValue ) { $ optionValue = $ this -> input -> getOption ( $ optionIdentifier ) ; $ optionValue = ! empty ( $ optionValue ) ? $ optionValue : $ defaultValue ; $ question = $ this -> getChoiceQuestion ( $ optionName , $ optionValue , $ choices ) ; $ optionValue = $ this -> questionHelper -> ask ( $ this -> input , $ this -> output , $ question ) ; $ this -> input -> setOption ( $ optionIdentifier , $ optionValue ) ; return $ optionValue ; }
96	public function read ( $ url ) { $ xml = $ this -> requestXml ( $ url , "/channel.xml" ) ; $ channelName = ( string ) $ xml -> name ; $ channelAlias = ( string ) $ xml -> suggestedalias ; $ supportedVersions = array_keys ( $ this -> readerMap ) ; $ selectedRestVersion = $ this -> selectRestVersion ( $ xml , $ supportedVersions ) ; if ( ! $ selectedRestVersion ) { throw new \ UnexpectedValueException ( sprintf ( 'PEAR repository %s does not supports any of %s protocols.' , $ url , implode ( ', ' , $ supportedVersions ) ) ) ; } $ reader = $ this -> readerMap [ $ selectedRestVersion [ 'version' ] ] ; $ packageDefinitions = $ reader -> read ( $ selectedRestVersion [ 'baseUrl' ] ) ; return new ChannelInfo ( $ channelName , $ channelAlias , $ packageDefinitions ) ; }
6033	public function getMetadata ( $ section = null , $ key = null ) { if ( null === $ section ) { return $ this -> metadata ; } foreach ( $ this -> metadata as $ md ) { if ( $ section != $ md -> getSection ( ) ) { continue ; } if ( null === $ key ) { return $ md ; } foreach ( $ md -> getData ( ) as $ k => $ data ) { if ( $ key == $ k ) { return $ data ; } } throw new NotFoundException ( 'No metadata with section "' . $ section . '" and key "' . $ key . '" exists.' ) ; } throw new NotFoundException ( 'No metadata with section "' . $ section . '" exists.' ) ; }
5582	public function clickLink ( $ label , $ index = 0 ) { $ url = $ this -> getLink ( $ label , $ index ) ; if ( $ url === false ) { return false ; } $ this -> load ( $ url , new SimpleGetEncoding ( ) ) ; return ( bool ) $ this -> getContent ( ) ; }
11330	public function getMultiline ( ) { if ( is_null ( $ this -> _multiline ) ) { $ this -> _multiline = MultilineDetector :: test ( $ this -> fieldSchema ) ; } return $ this -> _multiline ; }
1205	protected function renderItem ( ItemInterface $ item , array $ options ) { if ( ! $ item -> isDisplayed ( ) ) { return '' ; } $ class = ( array ) $ item -> getAttribute ( 'class' ) ; if ( $ this -> matcher -> isCurrent ( $ item ) ) { $ class [ ] = $ options [ 'currentClass' ] ; } elseif ( $ this -> matcher -> isAncestor ( $ item , $ options [ 'matchingDepth' ] ) ) { $ class [ ] = $ options [ 'ancestorClass' ] ; } if ( $ item -> actsLikeFirst ( ) ) { $ class [ ] = $ options [ 'firstClass' ] ; } if ( $ item -> actsLikeLast ( ) ) { $ class [ ] = $ options [ 'lastClass' ] ; } if ( $ item -> hasChildren ( ) && $ options [ 'depth' ] !== 0 ) { if ( null !== $ options [ 'branch_class' ] && $ item -> getDisplayChildren ( ) ) { $ class [ ] = $ options [ 'branch_class' ] ; } } elseif ( null !== $ options [ 'leaf_class' ] ) { $ class [ ] = $ options [ 'leaf_class' ] ; } $ attributes = $ item -> getAttributes ( ) ; if ( ! empty ( $ class ) ) { $ attributes [ 'class' ] = implode ( ' ' , $ class ) ; } $ html = $ this -> format ( '<li' . $ this -> renderHtmlAttributes ( $ attributes ) . '>' , 'li' , $ item -> getLevel ( ) , $ options ) ; $ html .= $ this -> renderLink ( $ item , $ options ) ; $ childrenClass = ( array ) $ item -> getChildrenAttribute ( 'class' ) ; $ childrenClass [ ] = 'menu_level_' . $ item -> getLevel ( ) ; $ childrenAttributes = $ item -> getChildrenAttributes ( ) ; $ childrenAttributes [ 'class' ] = implode ( ' ' , $ childrenClass ) ; $ html .= $ this -> renderList ( $ item , $ childrenAttributes , $ options ) ; $ html .= $ this -> format ( '</li>' , 'li' , $ item -> getLevel ( ) , $ options ) ; return $ html ; }
7516	protected function expect ( $ token , $ do_next = true , $ try_next = false , $ next_on_match = 1 ) { if ( $ do_next ) { if ( $ do_next === 1 ) { $ this -> next ( ) ; } else { $ this -> next_no_whitespace ( ) ; } } if ( is_int ( $ token ) ) { if ( ( $ this -> token !== $ token ) && ( ( ! $ try_next ) || ( ( ( $ try_next === 1 ) && ( $ this -> next ( ) !== $ token ) ) || ( ( $ try_next === true ) && ( $ this -> next_no_whitespace ( ) !== $ token ) ) ) ) ) { $ this -> addError ( 'Unexpected "' . $ this -> getTokenString ( ) . '"' ) ; return false ; } } else { if ( ( $ this -> doc [ $ this -> pos ] !== $ token ) && ( ( ! $ try_next ) || ( ( ( ( $ try_next === 1 ) && ( $ this -> next ( ) !== self :: TOK_NULL ) ) || ( ( $ try_next === true ) && ( $ this -> next_no_whitespace ( ) !== self :: TOK_NULL ) ) ) && ( $ this -> doc [ $ this -> pos ] !== $ token ) ) ) ) { $ this -> addError ( 'Expected "' . $ token . '", but found "' . $ this -> getTokenString ( ) . '"' ) ; return false ; } } if ( $ next_on_match ) { if ( $ next_on_match === 1 ) { $ this -> next ( ) ; } else { $ this -> next_no_whitespace ( ) ; } } return true ; }
8617	public function setInvalidSKU ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'InvalidSKU' ] [ 'FieldValue' ] = $ value ; return $ this ; }
663	public function getMaster ( ) { if ( $ this -> _master === false ) { $ this -> _master = $ this -> shuffleMasters ? $ this -> openFromPool ( $ this -> masters , $ this -> masterConfig ) : $ this -> openFromPoolSequentially ( $ this -> masters , $ this -> masterConfig ) ; } return $ this -> _master ; }
9058	public function addForeignKey ( string $ name , $ mapperClass , $ onDelete = true , $ onUpdate = false ) : Column { $ table = $ this -> getTableData ( $ mapperClass ) ; $ constrait = new Constrait ( $ name , $ this , $ table , $ onDelete , $ onUpdate ) ; $ this -> constraints [ $ constrait -> name ] = $ constrait ; return $ constrait -> column ; }
9867	private function writeMergeCells ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getMergeCells ( ) ) > 0 ) { $ objWriter -> startElement ( 'mergeCells' ) ; foreach ( $ pSheet -> getMergeCells ( ) as $ mergeCell ) { $ objWriter -> startElement ( 'mergeCell' ) ; $ objWriter -> writeAttribute ( 'ref' , $ mergeCell ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
12139	public function renderWidget ( array $ fields , $ customFielsGroup , $ documentType = 'html' , array $ params = array ( ) ) { $ resolvedParams = array_merge ( $ this -> defaultParams , $ params ) ; return $ this -> container -> get ( 'templating' ) -> render ( $ resolvedParams [ 'layout' ] , array ( 'cFGroup' => $ customFielsGroup , 'cFData' => $ fields , 'show_empty' => $ resolvedParams [ 'show_empty' ] ) ) ; }
8781	public function save ( $ content = null , $ time = 30 ) { $ fileName = md5 ( $ this -> prefix . http ( ) -> server ( 'REQUEST_URI' ) ) . $ this -> extension ; $ this -> file = cache_path ( 'html' . DIRECTORY_SEPARATOR . $ fileName ) ; $ this -> start ( $ time ) ; return $ this -> finish ( $ content ) ; }
8660	private function convertGetReportList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetAvailableFromDate ( ) ) { $ parameters [ 'AvailableFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableFromDate ( ) ) ; } if ( $ request -> isSetAvailableToDate ( ) ) { $ parameters [ 'AvailableToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableToDate ( ) ) ; } if ( $ request -> isSetReportRequestIdList ( ) ) { $ reportRequestIdList = $ request -> getReportRequestIdList ( ) ; foreach ( $ reportRequestIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportRequestIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
5422	protected function readAll ( $ socket ) { $ all = '' ; while ( ! $ this -> isLastPacket ( $ next = $ socket -> read ( ) ) ) { $ all .= $ next ; } return $ all ; }
5302	public static function unicodeToHex ( $ char ) { if ( ! is_string ( $ char ) || mb_strlen ( $ char , 'utf-8' ) !== 1 ) { throw new \ InvalidArgumentException ( '$char must be one single character' ) ; } $ unicode = unpack ( 'N' , mb_convert_encoding ( $ char , 'UCS-4BE' , 'UTF-8' ) ) ; return dechex ( $ unicode [ 1 ] ) ; }
8173	private function addCallable ( $ type = 'function' , $ name , $ func ) { if ( ! is_string ( $ name ) || ! is_callable ( $ func ) ) { return ; } $ twname = trim ( $ name , '*' ) ; $ params = [ ] ; if ( strpos ( $ name , '*' ) === 0 ) { $ params [ 'is_safe' ] = [ 'html' ] ; } if ( $ type === 'function' ) { $ this -> twig -> addFunction ( new Twig_SimpleFunction ( $ twname , $ func , $ params ) ) ; } if ( $ type === 'filter' ) { $ this -> twig -> addFilter ( new Twig_SimpleFilter ( $ twname , $ func , $ params ) ) ; } }
7588	public function setFileName ( $ fileName ) { $ fileName = preg_replace ( "([^\w\s\d\-_~,;\[\]\(\).])" , '' , $ fileName ) ; $ fileName = preg_replace ( "([\.]{2,})" , '' , $ fileName ) ; $ this -> fileName = $ fileName ; return $ this ; }
6630	public function callback ( $ input ) { if ( isset ( $ input [ 'error' ] ) ) { throw new AuthenticationException ( $ input [ 'error' ] . ':' . $ input [ 'error_description' ] ) ; } if ( ! isset ( $ input [ 'code' ] ) || empty ( $ input [ 'code' ] ) ) { throw new AuthenticationException ( 'invalid code' ) ; } if ( ! isset ( $ input [ 'state' ] ) || empty ( $ input [ 'state' ] ) ) { throw new AuthenticationException ( 'invalid state' ) ; } if ( ! $ this -> store -> has ( $ input [ 'state' ] ) ) { throw new AuthenticationException ( 'state expired' ) ; } $ access_token = $ this -> requestAccessToken ( $ input [ 'code' ] ) ; return $ this -> requestProfile ( $ access_token ) ; }
11127	protected function renderView ( $ view , $ data ) { try { return parent :: renderView ( $ view , $ data ) ; } catch ( \ InvalidArgumentException $ e ) { return static :: applyDataToView ( $ view , $ data ) ; } }
11677	protected function isFileLoaded ( $ locale , $ file ) { if ( array_key_exists ( $ locale , $ this -> translations ) === false ) { return false ; } if ( array_key_exists ( $ file , $ this -> translations [ $ locale ] ) === false ) { return false ; } return true ; }
11468	public function index ( ResponseRequest $ request ) { $ view = $ this -> response -> theme -> listView ( ) ; if ( $ this -> response -> typeIs ( 'json' ) ) { $ function = camel_case ( 'get-' . $ view ) ; return $ this -> repository -> setPresenter ( \ Litecms \ Forum \ Repositories \ Presenter \ ResponsePresenter :: class ) -> $ function ( ) ; } $ responses = $ this -> repository -> paginate ( ) ; return $ this -> response -> title ( trans ( 'forum::response.names' ) ) -> view ( 'forum::response.index' , true ) -> data ( compact ( 'responses' ) ) -> output ( ) ; }
2521	public function pnrIgnore ( RequestOptions \ PnrIgnoreOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_Ignore' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
6861	public function doDefaultValueConversionByType ( $ value , $ type , array $ record ) { switch ( $ type ) { case static :: TYPE_DATETIME : return date ( static :: FORMAT_DATETIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_DATE : return date ( static :: FORMAT_DATE , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_TIME : return date ( static :: FORMAT_TIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_MULTILINE : return '<pre class="multiline-text">' . $ value . '</pre>' ; case static :: TYPE_JSON : case static :: TYPE_JSONB : if ( ! is_array ( $ value ) && $ value !== null ) { if ( is_string ( $ value ) || is_numeric ( $ value ) || is_bool ( $ value ) ) { $ value = json_decode ( $ value , true ) ; if ( $ value === null && strtolower ( $ value ) !== 'null' ) { $ value = 'Failed to decode JSON: ' . print_r ( $ value , true ) ; } } else { $ value = 'Invalid value for JSON: ' . print_r ( $ value , true ) ; } } return '<pre class="json-text">' . htmlentities ( stripslashes ( json_encode ( $ value , JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE ) ) ) . '</pre>' ; break ; } return $ value ; }
12782	public function getAll ( ) { if ( is_null ( $ this -> intersections ) ) { $ this -> intersections = [ ] ; if ( $ this -> arraysSize >= 2 ) { $ this -> createIntersections ( ) ; } } return $ this -> intersections ; }
6842	public function produce ( $ key , $ params = array ( ) , $ enable_reflect = true ) { if ( isset ( $ this -> data [ $ key ] ) ) return $ this -> data [ $ key ] ; if ( isset ( $ this -> caches [ $ key ] ) ) return $ this -> caches [ $ key ] ; if ( isset ( $ this -> objects [ $ key ] ) ) { $ obj = $ this -> get ( $ key ) ; $ concrete = $ obj [ self :: INDEX_CONCRETE ] ; } else { if ( $ this -> MUST_REG || ! $ enable_reflect ) { throw new InjectorException ( "$key not registered" ) ; } else { $ concrete = $ key ; $ not_reg = true ; } } $ result = $ this -> build ( $ concrete , $ params ) ; if ( $ not_reg === true || $ obj [ self :: INDEX_CACHED ] === true ) { $ this -> caches [ $ key ] = $ result ; } return $ result ; }
9283	private function needsCompilation ( $ lessPath , $ cssPath ) { $ isNewer = function ( $ subject , $ reference ) { return filemtime ( $ subject ) > filemtime ( $ reference ) ; } ; if ( $ this -> forceCompile || ! file_exists ( $ lessPath ) || ! file_exists ( $ cssPath ) || $ isNewer ( $ lessPath , $ cssPath ) ) { return true ; } return $ this -> checkImports ( $ lessPath , $ cssPath , $ isNewer ) ; }
1367	protected function bootBladeDirectives ( ) { $ compiler = $ this -> app -> make ( BladeCompiler :: class ) ; $ compiler -> directive ( 'jsonapi' , Renderer :: class . '::compileWith' ) ; $ compiler -> directive ( 'encode' , Renderer :: class . '::compileEncode' ) ; }
7159	protected function compileKeyboard ( Keyboard $ keyboard ) { $ firstButton = collect ( $ keyboard -> getButtons ( ) ) -> first ( ) ; if ( $ firstButton instanceof PayloadButton || $ firstButton instanceof UrlButton ) { return $ this -> compileInlineKeyboard ( $ keyboard ) ; } return $ this -> compileReplyKeyboard ( $ keyboard ) ; }
11203	public function max ( $ key = false ) { $ collection = $ this -> getIterator ( ) ; $ max = 0 ; $ valueToReturn = 0 ; foreach ( $ collection as $ result ) { if ( $ key && isset ( $ result -> $ key ) ) { if ( $ result -> $ key > $ max ) { $ max = $ result -> $ key ; $ valueToReturn = $ result ; } } else if ( $ key && isset ( $ result [ $ key ] ) ) { if ( $ result [ $ key ] > $ max ) { $ max = $ result [ $ key ] ; $ valueToReturn = $ result ; } } else { if ( $ result > $ max ) { $ max = $ result ; $ valueToReturn = $ result ; } } } return $ valueToReturn ; }
8218	protected function isAllowed ( $ limit , $ config ) { if ( $ limit [ "cnt" ] >= $ config [ "count" ] ) { if ( time ( ) > $ limit [ "ts" ] + $ config [ "blockDuration" ] ) { return true ; } else { return false ; } } else { return true ; } }
6519	private function unFreeze ( ) { $ this -> isFrozen = false ; $ this -> isReplay = null ; foreach ( static :: schema ( ) -> getFields ( ) as $ field ) { if ( $ field -> getType ( ) -> isMessage ( ) ) { $ value = $ this -> get ( $ field -> getName ( ) ) ; if ( empty ( $ value ) ) { continue ; } if ( $ value instanceof Message ) { $ value -> unFreeze ( ) ; continue ; } foreach ( $ value as $ v ) { $ v -> unFreeze ( ) ; } } } }
2899	public function getQueryModels ( ) { $ queries = array ( ) ; foreach ( $ this -> _queryProfiles as $ queryId => $ queryProfile ) { $ queryModel = Mage :: getModel ( 'sheep_debug/query' ) ; $ stacktrace = array_key_exists ( $ queryId , $ this -> stackTraces ) ? $ this -> stackTraces [ $ queryId ] : '' ; $ queryModel -> init ( $ queryProfile , $ stacktrace ) ; $ queries [ ] = $ queryModel ; } return $ queries ; }
2384	public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; if ( ! $ exception instanceof ResponseException ) { return ; } $ event -> allowCustomResponseCode ( ) ; $ event -> setResponse ( $ exception -> getResponse ( ) ) ; }
10978	protected function setVerificationCode ( $ code = null ) { $ this -> { Config :: get ( 'verifier.store_column' ) } = $ code ; if ( $ code ) { $ this -> { Config :: get ( 'verifier.flag_column' ) } = false ; } else { $ this -> { Config :: get ( 'verifier.flag_column' ) } = true ; } $ this -> save ( ) ; }
12633	public function close ( $ tradeNo ) { $ params = [ 'out_trade_no' => $ tradeNo , ] ; return $ this -> request ( $ this -> wrapApi ( self :: API_CLOSE ) , $ params ) ; }
2170	private function setPassword ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_password' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'password.html.twig' ) ; } $ password = $ request -> request -> get ( 'password' ) ; $ confirmation = $ request -> request -> get ( 'confirmation' ) ; if ( $ password !== $ confirmation ) { return $ this -> render ( 'password.html.twig' , [ 'error' => $ this -> trans ( 'password_confirmation_mismatch' ) , ] ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ minlength = $ installTool -> getConfig ( 'minPasswordLength' ) ; if ( Utf8 :: strlen ( $ password ) < $ minlength ) { return $ this -> render ( 'password.html.twig' , [ 'error' => sprintf ( $ this -> trans ( 'password_too_short' ) , $ minlength ) , ] ) ; } $ installTool -> persistConfig ( 'installPassword' , password_hash ( $ password , PASSWORD_DEFAULT ) ) ; $ this -> container -> get ( 'contao.install_tool_user' ) -> setAuthenticated ( true ) ; return $ this -> getRedirectResponse ( ) ; }
5107	public function createConnector ( $ name ) { $ connector = new MySqlConnector ( $ name ) ; $ connector -> setConnection ( $ this -> getNewConnection ( $ name ) ) ; return $ connector ; }
1155	public function getMessage ( $ attribute , $ rule ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'getMessage' , [ $ attribute , $ rule ] ) ; }
10169	public function write ( Spreadsheet $ spreadsheet = null ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-settings' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:config' , 'urn:oasis:names:tc:opendocument:xmlns:config:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> startElement ( 'office:settings' ) ; $ objWriter -> startElement ( 'config:config-item-set' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'ooo:view-settings' ) ; $ objWriter -> startElement ( 'config:config-item-map-indexed' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'Views' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'config:config-item-set' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'ooo:configuration-settings' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
8992	public function getAttributeNames ( $ entity ) { if ( ! $ entity instanceof \ ElggEntity ) { return array ( ) ; } $ default = array ( 'guid' , 'type' , 'subtype' , 'owner_guid' , 'container_guid' , 'site_guid' , 'access_id' , 'time_created' , 'time_updated' , 'last_action' , 'enabled' , ) ; switch ( $ entity -> getType ( ) ) { case 'user' ; $ attributes = array ( 'name' , 'username' , 'email' , 'language' , 'banned' , 'admin' , 'password' , 'salt' ) ; break ; case 'group' : $ attributes = array ( 'name' , 'description' , ) ; break ; case 'object' : $ attributes = array ( 'title' , 'description' , ) ; break ; } return array_merge ( $ default , $ attributes ) ; }
1329	public function set ( $ key , $ value = null ) { $ keys = is_array ( $ key ) ? $ key : [ $ key => $ value ] ; foreach ( $ keys as $ key => $ value ) { self :: updateOrCreate ( [ 'key' => $ key ] , [ 'value' => $ value ] ) ; } }
3134	public function getItemData ( RunnerServiceContext $ context , $ itemRef ) { if ( $ context instanceof QtiRunnerServiceContext ) { return $ this -> loadItemData ( $ itemRef , QtiJsonItemCompiler :: ITEM_FILE_NAME ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getItemData' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
4725	private function addRule ( $ data , $ ruleType ) { if ( \ is_string ( $ data ) ) { $ data = array ( $ data ) ; } elseif ( ! \ is_array ( $ data ) ) { throw new InvalidArgumentException ( 'Invalid inflector rule data.' ) ; } foreach ( $ data as $ rule ) { array_push ( $ this -> rules [ $ ruleType ] , ( string ) $ rule ) ; } }
10744	public function getArray ( $ keys , array $ default = [ ] ) : array { $ result = $ this -> get ( $ keys , $ default ) ; if ( ! is_array ( $ result ) ) { $ result = $ default ; } return $ result ; }
9560	protected function renderCloseButton ( ) { if ( ( $ closeButton = $ this -> closeButton ) !== false ) { $ tag = ArrayHelper :: remove ( $ closeButton , 'tag' , 'button' ) ; $ label = ArrayHelper :: remove ( $ closeButton , 'label' , 'Close' ) ; if ( $ tag === 'button' && ! isset ( $ closeButton [ 'type' ] ) ) { $ closeButton [ 'type' ] = 'button' ; } return Html :: tag ( $ tag , $ label , $ closeButton ) ; } else { return null ; } }
11561	public function SetUnits ( $ units ) { if ( is_array ( $ units ) ) { $ this -> units = $ units ; } else { $ this -> units = explode ( ',' , ( string ) $ units ) ; } return $ this ; }
3925	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( is_array ( $ event -> getValue ( ) ) ) { $ values = [ ] ; foreach ( $ event -> getValue ( ) as $ value ) { $ values [ ] = 'value_' . $ value ; } $ event -> setValue ( $ values ) ; } else { $ event -> setValue ( 'value_' . $ event -> getValue ( ) ) ; } }
7409	public function & offsetGet ( $ offset ) { if ( ! $ this -> offsetExists ( $ offset ) ) { $ this -> offsetSet ( $ offset , null ) ; if ( null === $ offset ) { end ( $ this -> _container ) ; $ offset = key ( $ this -> _container ) ; } } return $ this -> _container [ $ offset ] ; }
8579	public function setPromotionList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PromotionList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9359	protected function finalize ( $ function ) { $ response = $ this -> container -> get ( self :: RESPONSE ) ; if ( is_string ( $ function ) === true ) { $ stream = $ response -> getBody ( ) ; $ stream -> write ( ( string ) $ function ) ; } $ instanceof = $ function instanceof ResponseInterface ; return $ instanceof ? $ function : $ response ; }
9955	public function unmergeCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> unmergeCells ( $ cellRange ) ; }
5708	public function transformToButton ( ) { parent :: transformToButton ( ) ; if ( $ this -> gridFieldRequest -> recordIsPublished ( ) ) { $ this -> setTitle ( _t ( 'SiteTree.BUTTONPUBLISHED' , 'Published' ) ) ; } if ( $ this -> gridFieldRequest -> record -> stagesDiffer ( 'Stage' , 'Live' ) && $ this -> gridFieldRequest -> recordIsDeletedFromStage ( ) ) { $ this -> addExtraClass ( 'ss-ui-alternate' ) ; } return $ this ; }
751	protected function validateSlug ( $ slug ) { $ validator = Yii :: createObject ( array_merge ( [ 'class' => UniqueValidator :: className ( ) , ] , $ this -> uniqueValidator ) ) ; $ model = clone $ this -> owner ; $ model -> clearErrors ( ) ; $ model -> { $ this -> slugAttribute } = $ slug ; $ validator -> validateAttribute ( $ model , $ this -> slugAttribute ) ; return ! $ model -> hasErrors ( ) ; }
10653	protected function __propertyTraitHasProperty ( $ propertyName ) { if ( method_exists ( $ this , 'get' . $ propertyName ) || method_exists ( $ this , 'set' . $ propertyName ) ) { return true ; } try { $ classReflection = new \ ReflectionProperty ( get_class ( $ this ) , $ propertyName ) ; return $ classReflection -> isPublic ( ) ; } catch ( \ ReflectionException $ ex ) { return false ; } }
12055	public function get ( $ name ) { if ( ! isset ( $ this -> container [ $ name ] ) ) { throw new RuntimeException ( sprintf ( 'Module "%s" is not found' , $ name ) ) ; } return $ this -> container [ $ name ] ; }
5876	public function getImageFileExtensions ( array $ settings ) { $ languageService = $ this -> getLanguageService ( ) ; $ extensions = GeneralUtility :: trimExplode ( ',' , strtolower ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'imagefile_ext' ] ) , true ) ; if ( $ key = array_search ( 'pdf' , $ extensions ) ) { unset ( $ extensions [ $ key ] ) ; } if ( $ key = array_search ( 'svg' , $ extensions ) ) { unset ( $ extensions [ $ key ] ) ; } asort ( $ extensions ) ; $ elements = [ ] ; foreach ( $ extensions as $ extension ) { $ label = $ languageService -> sL ( 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang.xlf:extension.' . $ extension ) ; $ label = $ label ? $ label : '.' . $ extension ; $ elements [ ] = [ $ label , $ extension ] ; } $ settings [ 'items' ] = array_merge ( $ settings [ 'items' ] , $ elements ) ; }
10809	protected function __templates ( $ customTemplate = null , $ customTemplateSuffix = null ) { $ templates = SSViewer :: get_templates_by_class ( $ this -> class , $ customTemplateSuffix , \ FormField :: class ) ; if ( ! $ templates ) { throw new \ Exception ( "No template found for {$this->class}" ) ; } if ( $ customTemplate ) { array_unshift ( $ templates , $ customTemplate ) ; } return $ templates ; }
10211	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; $ this -> email = ( string ) $ xmlElement -> email ; if ( isset ( $ xmlElement -> permission ) ) $ this -> permission = Permission :: getPermission ( ( string ) $ xmlElement -> permission ) ; if ( isset ( $ xmlElement -> external_id ) ) ( string ) $ this -> external_id = $ xmlElement -> external_id ; if ( isset ( $ xmlElement -> anonymous ) ) ( string ) $ this -> anonymous = $ xmlElement -> anonymous ; if ( isset ( $ xmlElement [ 'anonymous' ] ) ) $ this -> anonymous = $ xmlElement [ 'anonymous' ] ; if ( isset ( $ xmlElement -> created ) ) $ this -> created = $ xmlElement -> created ; if ( isset ( $ xmlElement -> updated ) ) $ this -> updated = $ xmlElement -> updated ; if ( isset ( $ xmlElement -> standard_fields ) ) { $ this -> standard_fields = array ( ) ; foreach ( $ xmlElement -> standard_fields -> children ( ) as $ field ) { $ this -> standard_fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } if ( isset ( $ xmlElement -> custom_fields ) ) { foreach ( $ xmlElement -> custom_fields -> children ( ) as $ field ) { $ this -> custom_fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } }
3306	protected function request ( $ url , array $ options = [ ] ) { $ httpClient = new Http ; try { $ response = $ httpClient -> request ( 'POST' , $ url , [ 'form_params' => $ options , 'query' => [ $ this -> accessToken -> getQueryName ( ) => $ this -> accessToken -> getAccessToken ( true ) ] ] ) ; } catch ( \ GuzzleHttp \ Exception \ ClientException $ e ) { if ( $ e -> hasResponse ( ) ) { $ response = $ e -> getResponse ( ) ; } else { throw $ e ; } } return $ httpClient -> parseJson ( $ response ) ; }
10345	protected function applyStepping ( $ range , $ step ) { if ( $ step === false || $ step === 1 ) { return $ range ; } foreach ( $ range as $ value => $ tmp ) { if ( ( $ value % $ step ) !== 0 ) { unset ( $ range [ $ value ] ) ; } } return array_values ( $ range ) ; }
10943	public function encode ( $ rawString ) { $ bytes = unpack ( 'C*' , $ rawString ) ; $ byteCount = count ( $ bytes ) ; $ encodedString = '' ; $ byte = array_shift ( $ bytes ) ; $ bitsRead = 0 ; $ chars = $ this -> chars ; $ bitsPerCharacter = $ this -> bitsPerCharacter ; $ rightPadFinalBits = $ this -> rightPadFinalBits ; $ padFinalGroup = $ this -> padFinalGroup ; $ padCharacter = $ this -> padCharacter ; for ( $ c = 0 ; $ c < $ byteCount * 8 / $ bitsPerCharacter ; ++ $ c ) { if ( $ bitsRead + $ bitsPerCharacter > 8 ) { $ oldBitCount = 8 - $ bitsRead ; $ oldBits = $ byte ^ ( $ byte >> $ oldBitCount << $ oldBitCount ) ; $ newBitCount = $ bitsPerCharacter - $ oldBitCount ; if ( ! $ bytes ) { if ( $ rightPadFinalBits ) { $ oldBits <<= $ newBitCount ; } $ encodedString .= $ chars [ $ oldBits ] ; if ( $ padFinalGroup ) { $ lcmMap = array ( 1 => 1 , 2 => 1 , 3 => 3 , 4 => 1 , 5 => 5 , 6 => 3 , 7 => 7 , 8 => 1 ) ; $ bytesPerGroup = $ lcmMap [ $ bitsPerCharacter ] ; $ pads = $ bytesPerGroup * 8 / $ bitsPerCharacter - ceil ( ( strlen ( $ rawString ) % $ bytesPerGroup ) * 8 / $ bitsPerCharacter ) ; $ encodedString .= str_repeat ( $ padCharacter [ 0 ] , $ pads ) ; } break ; } $ byte = array_shift ( $ bytes ) ; $ bitsRead = 0 ; } else { $ oldBitCount = 0 ; $ newBitCount = $ bitsPerCharacter ; } $ bits = $ byte >> 8 - ( $ bitsRead + ( $ newBitCount ) ) ; $ bits ^= $ bits >> $ newBitCount << $ newBitCount ; $ bitsRead += $ newBitCount ; if ( $ oldBitCount ) { $ bits = ( $ oldBits << $ newBitCount ) | $ bits ; } $ encodedString .= $ chars [ $ bits ] ; } return $ encodedString ; }
6801	public function installTaxes ( $ codes = [ 'US' ] ) { $ codes = ( array ) $ codes ; if ( empty ( $ codes ) ) { return ; } $ taxRepository = $ this -> manager -> getRepository ( Tax :: class ) ; foreach ( $ codes as $ code ) { $ path = __DIR__ . '/data/' . $ code . '_taxes.yml' ; if ( ! ( file_exists ( $ path ) && is_readable ( $ path ) ) ) { call_user_func ( $ this -> log , 'Taxes data' , 'not found' ) ; continue ; } $ data = Yaml :: parse ( file_get_contents ( $ path ) ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { continue ; } $ country = $ this -> manager -> getRepository ( Country :: class ) -> findOneBy ( [ 'code' => $ code ] ) ; if ( null === $ country ) { continue ; } foreach ( $ data as $ datum ) { $ name = $ datum [ 'name' ] ; $ result = 'already exists' ; if ( null === $ taxRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ tax = new Tax ( ) ; $ tax -> setName ( $ name ) -> setRate ( $ datum [ 'rate' ] ) -> setCountry ( $ country ) ; $ this -> manager -> persist ( $ tax ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } } $ this -> manager -> flush ( ) ; }
12189	public function getPrimaryRelation ( $ baseObject , $ baseRole , $ relationOptions = [ ] ) { $ companionRole = $ this -> companionRole ( $ baseRole ) ; $ companionType = $ this -> companionRoleType ( $ baseRole ) ; $ companionModel = $ companionType -> primaryModel ; if ( ! isset ( $ relationOptions [ 'order' ] ) ) { $ relationOptions [ 'order' ] = [ ] ; } if ( $ companionRole === 'child' ) { array_unshift ( $ relationOptions [ 'order' ] , [ 'primary_child' , SORT_DESC ] ) ; $ relation = $ baseObject -> queryParentRelations ( $ companionModel , $ relationOptions ) -> one ( ) ; } else { array_unshift ( $ relationOptions [ 'order' ] , [ 'primary_parent' , SORT_DESC ] ) ; $ relation = $ baseObject -> queryParentRelations ( $ companionModel , $ relationOptions ) -> one ( ) ; } if ( empty ( $ relation ) ) { return false ; } else { return $ relation ; } }
2669	public function checkAuthDictionaryPopulation ( $ version ) { $ dictionary = $ this -> getAuthDictionary ( $ version ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { throw new LocalizedException ( __ ( 'You must add users in order to enable Basic Authentication.' ) ) ; } $ authItems = $ this -> dictionaryItemsList ( $ dictionary -> id ) ; if ( is_array ( $ authItems ) && empty ( $ authItems ) ) { throw new LocalizedException ( __ ( 'You must add users in order to enable Basic Authentication.' ) ) ; } }
11855	public function getUrlPath ( ) : ? string { $ uri = $ this -> getServerParam ( 'REQUEST_URI' , \ FILTER_SANITIZE_URL ) ; if ( ! is_null ( $ uri ) ) { return parse_url ( $ uri , \ PHP_URL_PATH ) ; } return null ; }
1031	public function completeValueWithLocatedError ( Type $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , $ result ) { try { $ completed = $ this -> completeValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; $ promise = $ this -> getPromise ( $ completed ) ; if ( $ promise ) { return $ promise -> then ( null , function ( $ error ) use ( $ fieldNodes , $ path ) { return $ this -> exeContext -> promises -> createRejected ( Error :: createLocatedError ( $ error , $ fieldNodes , $ path ) ) ; } ) ; } return $ completed ; } catch ( Exception $ error ) { throw Error :: createLocatedError ( $ error , $ fieldNodes , $ path ) ; } catch ( Throwable $ error ) { throw Error :: createLocatedError ( $ error , $ fieldNodes , $ path ) ; } }
2798	public function toArray ( ) { return [ 'file' => $ this -> getMutationFileRelativePath ( ) , 'mutator' => $ this -> mutation -> getMutator ( ) , 'class' => $ this -> mutation -> getClass ( ) , 'method' => $ this -> mutation -> getMethod ( ) , 'line' => $ this -> mutation -> getLine ( ) , 'diff' => $ this -> getDiff ( ) , 'tests' => $ this -> testMethods ] ; }
8312	public function handlePasswordReset ( Request $ httpRequest ) { $ this -> httpRequest = $ httpRequest ; $ this -> checkResetLink ( ) ; $ resetData = $ this -> session -> get ( "pwreset" ) ; if ( $ resetData === null ) { $ this -> beginPasswordReset ( ) ; } else { $ this -> finishPasswordReset ( $ resetData ) ; } }
1804	protected function invalidateCacheTags ( self $ dc ) { if ( ! System :: getContainer ( ) -> has ( 'fos_http_cache.cache_manager' ) ) { return ; } $ ns = 'contao.db.' ; $ tags = array ( $ ns . $ dc -> table , $ ns . $ dc -> table . '.' . $ dc -> id ) ; if ( $ dc -> ptable && $ dc -> activeRecord && $ dc -> activeRecord -> pid > 0 ) { $ tags [ ] = $ ns . $ dc -> ptable ; $ tags [ ] = $ ns . $ dc -> ptable . '.' . $ dc -> activeRecord -> pid ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'oninvalidate_cache_tags_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'oninvalidate_cache_tags_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ tags = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ dc , $ tags ) ; } elseif ( \ is_callable ( $ callback ) ) { $ tags = $ callback ( $ dc , $ tags ) ; } } } $ tags = array_filter ( array_unique ( $ tags ) ) ; $ cacheManager = System :: getContainer ( ) -> get ( 'fos_http_cache.cache_manager' ) ; $ cacheManager -> invalidateTags ( $ tags ) ; }
6943	protected function localizedDayOfWeek ( $ dayOfWeek ) { if ( class_exists ( '\IntlDateFormatter' ) ) { $ date = new \ DateTime ( '2017-01-01' ) ; $ date -> modify ( '+' . $ dayOfWeek . ' days' ) ; $ formatter = \ IntlDateFormatter :: create ( $ this -> localeProvider -> getCurrentLocale ( ) , \ IntlDateFormatter :: NONE , \ IntlDateFormatter :: NONE , $ date -> getTimezone ( ) , null , 'eeee' ) ; return $ formatter -> format ( $ date -> getTimestamp ( ) ) ; } return [ 1 => 'Monday' , 2 => 'Tuesday' , 3 => 'Wednesday' , 4 => 'Thursday' , 5 => 'Friday' , 6 => 'Saturday' , 7 => 'Sunday' , ] [ $ dayOfWeek ] ; }
266	protected function loadMessages ( $ category , $ language ) { if ( $ this -> enableCaching ) { $ key = [ __CLASS__ , $ category , $ language , ] ; $ messages = $ this -> cache -> get ( $ key ) ; if ( $ messages === false ) { $ messages = $ this -> loadMessagesFromDb ( $ category , $ language ) ; $ this -> cache -> set ( $ key , $ messages , $ this -> cachingDuration ) ; } return $ messages ; } return $ this -> loadMessagesFromDb ( $ category , $ language ) ; }
3425	public function getById ( $ id ) { if ( ! $ id || $ this -> queryShouldBeStopped ) { return false ; } $ this -> sort = [ ] ; $ this -> filter [ 'ID' ] = $ id ; return $ this -> getList ( ) -> first ( null , false ) ; }
10365	public function login ( LoginRequest $ request ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'login' ) ) -> dispatchFrom ( LoginJob :: class , $ request ) ; return redirect ( ) -> route ( config ( '_auth.login.redirect' ) ) ; }
9232	public function actionView ( $ id , $ format = false ) { $ model = $ this -> findModel ( $ id ) ; if ( $ format == 'json' ) { return \ yii \ helpers \ Json :: encode ( $ model ) ; } else { return $ this -> render ( 'view' , [ 'model' => $ model , ] ) ; } }
6951	private function getBaseQueryBuilder ( ) { $ qb = $ this -> getQueryBuilder ( 'r' , 'r.id' ) ; return $ qb -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'r.countries' ) , 'r.countries IS EMPTY' ) ) -> addOrderBy ( 'r.priority' , 'DESC' ) ; }
83	private function copyFiles ( $ files , $ source , $ target , $ roles , $ vars ) { foreach ( $ files as $ file ) { $ from = $ this -> combine ( $ source , $ file [ 'from' ] ) ; $ to = $ this -> combine ( $ target , $ roles [ $ file [ 'role' ] ] ) ; $ to = $ this -> combine ( $ to , $ file [ 'to' ] ) ; $ tasks = $ file [ 'tasks' ] ; $ this -> copyFile ( $ from , $ to , $ tasks , $ vars ) ; } }
6819	protected function writeInvoiceShipmentLine ( ) { $ amount = $ this -> invoice -> getShipmentBase ( ) ; if ( 0 === $ this -> compare ( $ amount , 0 ) ) { return ; } $ amount = $ this -> round ( $ amount ) ; $ sale = $ this -> invoice -> getSale ( ) ; $ date = $ sale -> getCreatedAt ( ) ; $ taxRule = $ this -> taxResolver -> resolveSaleTaxRule ( $ sale ) ; $ account = $ this -> getShipmentAccountNumber ( $ taxRule , $ this -> invoice -> getNumber ( ) ) ; if ( $ this -> invoice -> getType ( ) === InvoiceTypes :: TYPE_CREDIT ) { $ this -> writer -> credit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance -= $ amount ; } else { $ this -> writer -> debit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance += $ amount ; } }
2839	public function getFilteredRequestListUrl ( $ filters = array ( ) ) { $ currentFilters = Mage :: helper ( 'sheep_debug/filter' ) -> getRequestFilters ( $ this -> getRequest ( ) ) ; $ filters = array_merge ( $ currentFilters , $ filters ) ; return $ this -> getRequestListUrl ( $ filters ) ; }
10390	public static function loadString ( $ xmlString ) { $ xmlFile = tempnam ( self :: getSysTempDir ( ) , 'xml_' ) ; file_put_contents ( $ xmlFile , $ xmlString ) ; $ xml = self :: parseXml ( $ xmlFile ) ; unlink ( $ xmlFile ) ; return $ xml ; }
11212	protected function getFromLookup ( $ key ) { if ( $ key === $ this -> cache_key || $ this -> hasInLookup ( $ key ) ) { return $ this -> getFromRegistry ( $ this -> cache_reg , $ key ) ; } return null ; }
3570	public function __unsetHook ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( $ this -> hasMeta ( $ key ) ) { return $ this -> setMeta ( $ key , null ) ; } return $ next ( $ value , $ args ) ; } ; }
6092	public function removeMediaFromMoodboard ( $ moodboardId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/moodboards/' . $ moodboardId . '/media/' . $ mediaId . '' , $ parameters ) ; return $ result ; }
3730	protected function getMatchingIds ( $ objFilter ) { if ( $ objFilter ) { $ arrFilteredIds = $ objFilter -> getMatchingIds ( ) ; if ( $ arrFilteredIds !== null ) { return $ arrFilteredIds ; } } return $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'id' ) -> from ( $ this -> getTableName ( ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; }
950	public function createHmac ( array $ opts ) { $ data = $ opts [ 'data' ] ; $ raw = $ opts [ 'raw' ] ?? false ; $ buildQuery = $ opts [ 'buildQuery' ] ?? false ; $ buildQueryWithJoin = $ opts [ 'buildQueryWithJoin' ] ?? false ; $ encode = $ opts [ 'encode' ] ?? false ; $ secret = $ opts [ 'secret' ] ?? Config :: get ( 'shopify-app.api_secret' ) ; if ( $ buildQuery ) { ksort ( $ data ) ; $ queryCompiled = [ ] ; foreach ( $ data as $ key => $ value ) { $ queryCompiled [ ] = "{$key}=" . ( is_array ( $ value ) ? implode ( $ value , ',' ) : $ value ) ; } $ data = implode ( $ queryCompiled , ( $ buildQueryWithJoin ? '&' : '' ) ) ; } $ hmac = hash_hmac ( 'sha256' , $ data , $ secret , $ raw ) ; return $ encode ? base64_encode ( $ hmac ) : $ hmac ; }
7896	public function from ( $ provider = null ) { $ provider = $ provider ? : $ this -> getDefaultProvider ( ) ; return new Uploader ( $ this -> app -> make ( 'config' ) , $ this -> app -> make ( 'filesystem' ) , $ this -> createProviderInstance ( $ provider ) ) ; }
11747	public function group ( ) { if ( is_null ( $ this -> group ) ) { $ this -> group = new Group ( $ this -> accessToken ) ; } return $ this -> group ; }
1047	public static function create ( array $ params , bool $ readonly = false ) : OperationParams { $ instance = new static ( ) ; $ params = array_change_key_case ( $ params , CASE_LOWER ) ; $ instance -> originalInput = $ params ; $ params += [ 'query' => null , 'queryid' => null , 'documentid' => null , 'id' => null , 'operationname' => null , 'variables' => null , 'extensions' => null , ] ; if ( $ params [ 'variables' ] === '' ) { $ params [ 'variables' ] = null ; } foreach ( [ 'extensions' , 'variables' ] as $ param ) { if ( ! is_string ( $ params [ $ param ] ) ) { continue ; } $ tmp = json_decode ( $ params [ $ param ] , true ) ; if ( json_last_error ( ) ) { continue ; } $ params [ $ param ] = $ tmp ; } $ instance -> query = $ params [ 'query' ] ; $ instance -> queryId = $ params [ 'queryid' ] ? : $ params [ 'documentid' ] ? : $ params [ 'id' ] ; $ instance -> operation = $ params [ 'operationname' ] ; $ instance -> variables = $ params [ 'variables' ] ; $ instance -> extensions = $ params [ 'extensions' ] ; $ instance -> readOnly = $ readonly ; if ( isset ( $ instance -> extensions [ 'persistedQuery' ] [ 'sha256Hash' ] ) && empty ( $ instance -> query ) && empty ( $ instance -> queryId ) ) { $ instance -> queryId = $ instance -> extensions [ 'persistedQuery' ] [ 'sha256Hash' ] ; } return $ instance ; }
11443	public function getMessage ( $ id = null ) { if ( ! is_null ( $ id ) ) { return array_key_exists ( $ id , $ this -> messages ) ? $ this -> messages [ $ id ] : null ; } elseif ( count ( $ this -> messages ) > 0 ) { return current ( $ this -> messages ) ; } else { $ message_class = $ this -> getDefault ( 'messager' ) ; if ( class_exists ( $ message_class ) ) { $ this -> addMessage ( new $ message_class ) ; return current ( $ this -> messages ) ; } else { throw new \ Exception ( sprintf ( 'Default message class "%s" not found!' , $ message_class ) ) ; } } }
8769	public function bootstrap ( ) { $ this -> hasBeenBootstrapped = true ; $ this [ 'events' ] -> dispatch ( 'bootstrapping' , [ $ this ] ) ; $ this -> boot ( ) ; $ this [ 'events' ] -> dispatch ( 'bootstrapped' , [ $ this ] ) ; }
5494	public function findFirstAction ( $ parameters ) { $ slot = $ this -> findFirstSlot ( $ parameters ) ; if ( isset ( $ slot ) && isset ( $ slot [ 'content' ] ) ) { return $ slot [ 'content' ] ; } return ; }
12722	protected function turnIntoResolvableClosure ( $ abstract , $ concrete ) { return function ( Container $ container , $ parameters = [ ] ) use ( $ abstract , $ concrete ) { return ( $ abstract == $ concrete ? $ container -> resolve ( $ abstract ) : $ container -> resolve ( $ concrete , $ parameters ) ) ; } ; }
7192	private function copyItem ( Model \ SaleItemInterface $ source , Model \ SaleItemInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'designation' , 'description' , 'reference' , 'taxGroup' , 'netPrice' , 'weight' , 'quantity' , 'position' , 'compound' , 'immutable' , 'configurable' , 'private' , 'data' , ] ) ; $ this -> copy ( $ source -> getSubjectIdentity ( ) , $ target -> getSubjectIdentity ( ) , [ 'provider' , 'identifier' , ] ) ; foreach ( $ source -> getAdjustments ( ) as $ sourceAdjustment ) { $ targetAdjustment = $ this -> saleFactory -> createAdjustmentForItem ( $ target ) ; $ target -> addAdjustment ( $ targetAdjustment ) ; $ this -> copyAdjustment ( $ sourceAdjustment , $ targetAdjustment ) ; } foreach ( $ source -> getChildren ( ) as $ sourceChild ) { $ targetChild = $ this -> saleFactory -> createItemForSale ( $ target -> getSale ( ) ) ; $ target -> addChild ( $ targetChild ) ; $ this -> copyItem ( $ sourceChild , $ targetChild ) ; } }
2276	public function getActivationDefault ( $ varValue ) { if ( ! trim ( $ varValue ) ) { $ varValue = ( \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] [ 1 ] : $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] ) ; } return $ varValue ; }
4530	public function setUserUuid ( ? string $ userUuid ) { if ( null !== $ userUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ userUuid ) ) { throw new InvalidArgumentException ( 'Uuid is not valid.' ) ; } } $ this -> userUuid = $ userUuid ; return $ this ; }
6889	protected function getAssignments ( $ item ) { if ( $ item instanceof ShipmentItemInterface ) { $ item = $ item -> getSaleItem ( ) ; } elseif ( $ item instanceof InvoiceLineInterface ) { if ( ! $ item = $ item -> getSaleItem ( ) ) { return null ; } } if ( ! $ this -> supportsAssignment ( $ item ) ) { return null ; } return $ item -> getStockAssignments ( ) -> toArray ( ) ; }
9726	public function logWrite ( IWriter $ writer , $ path , $ callStartTime ) { $ callEndTime = microtime ( true ) ; $ callTime = $ callEndTime - $ callStartTime ; $ reflection = new ReflectionClass ( $ writer ) ; $ format = $ reflection -> getShortName ( ) ; $ message = "Write {$format} format to <code>{$path}</code> in " . sprintf ( '%.4f' , $ callTime ) . ' seconds' ; $ this -> log ( $ message ) ; }
10052	private function resolvePath ( $ path_alias , $ file_name ) { $ path = \ Yii :: getAlias ( $ path_alias , false ) ; $ path = $ path ? realpath ( $ path ) : $ path ; $ file_name = ! preg_match ( '/\.php$/i' , $ file_name ) ? $ file_name . '.php' : $ file_name ; if ( ! $ path || ! is_dir ( $ path ) || ! file_exists ( $ path . '/' . $ file_name ) ) { throw new Exception ( "Faker template \"{$path}/{$file_name}\" not found" ) ; } return $ path . '/' . $ file_name ; }
3240	public function setCallbacks ( $ order ) { $ this -> callbackSuccess = route ( config ( 'shop.callback_route' ) , [ 'status' => 'success' , 'id' => $ order -> id , 'token' => $ this -> token , ] ) ; $ this -> callbackFail = route ( config ( 'shop.callback_route' ) , [ 'status' => 'fail' , 'id' => $ order -> id , 'token' => $ this -> token , ] ) ; }
6104	public function wait ( ) { if ( $ this -> getTransport ( ) -> getConfig ( "blocking" ) ) { throw new Ts3Exception ( "only available in non-blocking mode" ) ; } do { $ evt = $ this -> getTransport ( ) -> readLine ( ) ; var_dump ( $ evt ) ; } while ( $ evt instanceof StringHelper && ! $ evt -> section ( TeamSpeak3 :: SEPARATOR_CELL ) -> startsWith ( TeamSpeak3 :: EVENT ) ) ; return new Event ( $ evt , $ this -> getHost ( ) ) ; }
4353	public function onLog ( Event $ event ) { if ( ! $ this -> fileHandle ) { return ; } $ method = $ event [ 'method' ] ; if ( $ method == 'groupUncollapse' ) { return ; } $ args = $ event [ 'args' ] ; $ meta = $ event [ 'meta' ] ; $ isSummaryBookend = $ method == 'groupSummary' || ! empty ( $ meta [ 'closesSummary' ] ) ; if ( $ isSummaryBookend ) { \ fwrite ( $ this -> fileHandle , "=========\n" ) ; return ; } if ( $ args ) { $ str = $ this -> processLogEntryWEvent ( $ method , $ args , $ meta ) ; \ fwrite ( $ this -> fileHandle , $ str ) ; } elseif ( $ method == 'groupEnd' && $ this -> depth > 0 ) { $ this -> depth -- ; } }
1043	public static function printError ( Error $ error ) { $ printedLocations = [ ] ; if ( $ error -> nodes ) { foreach ( $ error -> nodes as $ node ) { if ( ! $ node -> loc ) { continue ; } if ( $ node -> loc -> source === null ) { continue ; } $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ node -> loc -> source , $ node -> loc -> source -> getLocation ( $ node -> loc -> start ) ) ; } } elseif ( $ error -> getSource ( ) && $ error -> getLocations ( ) ) { $ source = $ error -> getSource ( ) ; foreach ( $ error -> getLocations ( ) as $ location ) { $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ source , $ location ) ; } } return ! $ printedLocations ? $ error -> getMessage ( ) : implode ( "\n\n" , array_merge ( [ $ error -> getMessage ( ) ] , $ printedLocations ) ) . "\n" ; }
4147	protected function getResponse ( ) { $ url = $ this -> getUrl ( ) ; $ params = array ( 'get' => $ this -> getParams , 'post' => $ this -> postParams , 'headers' => $ this -> buildRequestHeader ( ) , ) ; return $ this -> curl -> send ( $ url , $ params ) ; }
10935	public function checkEmailAction ( ) { $ session = $ this -> get ( 'session' ) ; $ email = $ session -> get ( static :: SESSION_EMAIL ) ; $ session -> remove ( static :: SESSION_EMAIL ) ; if ( empty ( $ email ) ) { return new RedirectResponse ( $ this -> get ( 'router' ) -> generate ( 'miky_app_customer_resetting_request' ) ) ; } return $ this -> render ( 'MikyUserBundle:Frontend/Resetting:checkEmail.html.twig' , array ( 'email' => $ email , ) ) ; }
3091	public function store ( $ data ) { $ this -> cache [ $ this -> testSessionId ] = & $ data ; $ encodedData = $ this -> getStorageFormat ( ) -> encode ( $ data ) ; $ this -> getStorageService ( ) -> set ( $ this -> getUserKey ( ) , $ this -> getStorageKey ( ) , $ encodedData ) ; \ common_Logger :: d ( sprintf ( 'QtiTimer: Stored %d bytes into state storage' , strlen ( $ encodedData ) ) ) ; return $ this ; }
12231	public function copyAttributesFrom ( SimpleXMLElement $ src , $ overwrite = true ) { $ dom = dom_import_simplexml ( $ this ) ; foreach ( dom_import_simplexml ( $ src ) -> attributes as $ attr ) { if ( $ overwrite || ! $ dom -> hasAttributeNS ( $ attr -> namespaceURI , $ attr -> nodeName ) ) { $ dom -> setAttributeNS ( $ attr -> namespaceURI , $ attr -> nodeName , $ attr -> nodeValue ) ; } } return $ this ; }
6955	private function getTaxesRates ( ShipmentMethodInterface $ method , CountryInterface $ country ) { return array_map ( function ( TaxInterface $ tax ) { return $ tax -> getRate ( ) ; } , $ this -> taxResolver -> resolveTaxes ( $ method , $ country ) ) ; }
2868	public function preDispatch ( ) { parent :: preDispatch ( ) ; if ( ! Mage :: helper ( 'sheep_debug' ) -> isAllowed ( ) ) { $ this -> setFlag ( '' , 'no-dispatch' , true ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) ; } }
3895	protected function getMetaModel ( $ metaModelId ) { if ( null === $ this -> factory ) { throw new \ RuntimeException ( 'No factory set.' ) ; } $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; return $ metaModel ; }
9437	public function getMany ( $ n ) { if ( ! is_integer ( $ n ) || $ n < 2 ) { throw new \ InvalidArgumentException ( 'You must take 2 or more items in this case.' ) ; } $ arr_out = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr_out [ ] = $ this -> get ( ) ; } return $ arr_out ; }
2768	public function checkoutNewBranch ( string $ branch , array $ options = [ ] ) : string { $ options [ 'b' ] = true ; return $ this -> checkout ( $ branch , $ options ) ; }
4519	public function get ( string $ key ) { $ parameter = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ parameter ) { throw new OutOfRangeException ( 'Parameter "' . $ key . '" does not exist.' ) ; } $ this -> manager -> detach ( $ parameter ) ; return $ parameter -> getValue ( ) ; }
3666	public function convertParameter ( $ arrMatch ) { list ( $ strSource , $ strQuery ) = explode ( '?' , $ arrMatch [ 1 ] , 2 ) ; parse_str ( $ strQuery , $ arrArgs ) ; $ arrName = ( array ) $ arrArgs [ 'name' ] ; $ var = $ this -> getValueFromSource ( $ strSource , array_shift ( $ arrName ) , $ arrArgs ) ; $ index = 0 ; $ count = count ( $ arrName ) ; while ( $ index < $ count && is_array ( $ var ) ) { $ var = $ var [ $ arrName [ $ index ++ ] ] ; } if ( $ index != $ count || $ var === null ) { if ( array_key_exists ( 'default' , $ arrArgs ) && ( null !== $ arrArgs [ 'default' ] ) ) { $ this -> addParameter ( $ arrArgs [ 'default' ] ) ; return '?' ; } else { return 'NULL' ; } } if ( ! isset ( $ arrArgs [ 'aggregate' ] ) ) { $ this -> addParameter ( $ var ) ; return '?' ; } return $ this -> convertParameterAggregate ( $ var , $ arrArgs ) ; }
6496	public function getCurrentId ( ) { $ args = arg ( ) ; return count ( $ args ) > 1 && $ this -> entityType ( ) === $ args [ 0 ] && $ args [ 1 ] > 0 ? ( int ) $ args [ 1 ] : 0 ; }
11143	public function run ( ) { $ list = $ this -> getClassList ( ) ; $ directCollection = new DirectCollection ( ) ; foreach ( $ list as $ class ) { $ cl = $ this -> processClass ( $ class ) ; if ( $ cl !== false ) { $ directCollection -> add ( $ cl ) ; } } return $ directCollection ; }
2454	public function showAll ( ) { $ return = '' ; $ this -> limit = '' ; $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ undoPeriod = ( int ) Config :: get ( 'undoPeriod' ) ; $ logPeriod = ( int ) Config :: get ( 'logPeriod' ) ; if ( $ this -> strTable == 'tl_undo' && $ undoPeriod > 0 ) { $ this -> Database -> prepare ( "DELETE FROM tl_undo WHERE tstamp<?" ) -> execute ( time ( ) - $ undoPeriod ) ; } elseif ( $ this -> strTable == 'tl_log' && $ logPeriod > 0 ) { $ this -> Database -> prepare ( "DELETE FROM tl_log WHERE tstamp<?" ) -> execute ( time ( ) - $ logPeriod ) ; } $ this -> reviseTable ( ) ; if ( Input :: get ( 'act' ) == 'paste' ) { $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; $ arrClipboard [ $ this -> strTable ] = array ( 'id' => Input :: get ( 'id' ) , 'childs' => Input :: get ( 'childs' ) , 'mode' => Input :: get ( 'mode' ) ) ; $ objSession -> set ( 'CLIPBOARD' , $ arrClipboard ) ; } if ( ! empty ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'filter' ] ) && \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'filter' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'filter' ] as $ filter ) { $ this -> procedure [ ] = $ filter [ 0 ] ; $ this -> values [ ] = $ filter [ 1 ] ; } } if ( $ this -> treeView ) { $ return .= $ this -> panel ( ) ; $ return .= $ this -> treeView ( ) ; } else { if ( Input :: get ( 'table' ) && $ this -> ptable && $ this -> Database -> fieldExists ( 'pid' , $ this -> strTable ) ) { $ this -> procedure [ ] = 'pid=?' ; $ this -> values [ ] = CURRENT_ID ; } $ return .= $ this -> panel ( ) ; $ return .= ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 4 ) ? $ this -> parentView ( ) : $ this -> listView ( ) ; if ( strpos ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'panelLayout' ] , 'limit' ) !== false ) { $ return .= $ this -> paginationMenu ( ) ; } } return $ return ; }
11683	protected function _pushMessage ( $ message , $ type = 'error' , array $ interpolateParams = [ ] ) { $ this -> _messages [ ] = [ 'message' => vsprintf ( $ message , $ interpolateParams ) , 'type' => $ type , ] ; return $ this ; }
2745	public function isImageOptimizationEnabled ( ) { if ( $ this -> isFastlyEnabled ( ) !== true ) { return false ; } return $ this -> _scopeConfig -> isSetFlag ( self :: XML_FASTLY_IMAGE_OPTIMIZATIONS ) ; }
3770	protected function internalCreateRenderSetting ( IMetaModel $ metaModel , $ settingId ) { $ row = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_rendersettings' ) -> where ( 'pid=:pid' ) -> andWhere ( 'id=:id' ) -> setParameter ( 'pid' , $ metaModel -> get ( 'id' ) ) -> setParameter ( 'id' , $ settingId ? : 0 ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( ! $ row ) { $ row = [ ] ; } $ renderSetting = new Collection ( $ metaModel , $ row , $ this -> eventDispatcher , $ this -> filterFactory , $ this -> filterUrlBuilder ) ; if ( $ renderSetting -> get ( 'id' ) ) { $ this -> collectAttributeSettings ( $ metaModel , $ renderSetting ) ; } return $ renderSetting ; }
2032	public static function findFirstActiveByMemberGroups ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ time = Date :: floorToMinute ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> prepare ( "SELECT p.* FROM tl_member_group g LEFT JOIN tl_page p ON g.jumpTo=p.id WHERE g.id IN(" . implode ( ',' , $ arrIds ) . ") AND g.jumpTo>0 AND g.redirect='1' AND g.disable!='1' AND (g.start='' OR g.start<='$time') AND (g.stop='' OR g.stop>'" . ( $ time + 60 ) . "') AND p.published='1' AND (p.start='' OR p.start<='$time') AND (p.stop='' OR p.stop>'" . ( $ time + 60 ) . "') ORDER BY " . $ objDatabase -> findInSet ( 'g.id' , $ arrIds ) ) -> limit ( 1 ) -> execute ( ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objPage = $ objRegistry -> fetch ( 'tl_page' , $ objResult -> id ) ) { return $ objPage ; } return new static ( $ objResult ) ; }
12779	public function getState ( $ key , $ default = null ) { return Yii :: $ app -> webState -> get ( $ this -> stateKeyName ( $ key ) , $ default ) ; }
8421	private function getTexture ( ) { if ( isset ( $ this -> model ) ) { $ texture = $ this -> attribute ; if ( isset ( $ this -> model -> $ texture ) ) { return $ this -> model -> $ texture ; } } if ( isset ( $ this -> texture ) ) { return $ this -> texture ; } return $ this -> default ; }
6887	private function httpGet ( $ path , array $ query = array ( ) ) { $ url = new Uri ( $ this -> baseUrl . $ path ) ; foreach ( $ query as $ name => $ value ) { $ url = Uri :: withQueryValue ( $ url , $ name , $ value ) ; } $ request = new Request ( 'GET' , $ url , $ this -> buildHeaders ( ) ) ; try { $ response = $ this -> getHttpClient ( ) -> sendRequest ( $ request ) ; } catch ( \ RuntimeException $ e ) { throw new Exception \ PostcodeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } if ( $ response -> getStatusCode ( ) != 200 ) { throw $ this -> createErrorException ( $ response ) ; } return $ response ; }
5259	public static function all ( $ query = [ ] ) { if ( $ query instanceof QueryBuilder ) { $ query = $ query -> build ( ) ; } $ collection = collect ( ) ; static :: map ( $ query , function ( ElasticsearchModel $ document ) use ( $ collection ) { $ collection -> put ( $ document -> getId ( ) , $ document ) ; } ) ; return $ collection ; }
653	protected function getCacheKey ( $ method , $ fetchMode , $ rawSql ) { return [ __CLASS__ , $ method , $ fetchMode , $ this -> db -> dsn , $ this -> db -> username , $ rawSql , ] ; }
7246	private function hasStockableSubject ( Common \ SaleItemInterface $ saleItem ) { if ( ! $ saleItem instanceof Stock \ StockAssignmentsInterface ) { return false ; } if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ saleItem ) ) { return false ; } if ( ! $ subject instanceof Stock \ StockSubjectInterface ) { return false ; } if ( $ subject -> isStockCompound ( ) ) { return false ; } if ( $ subject -> getStockMode ( ) === Stock \ StockSubjectModes :: MODE_DISABLED ) { return false ; } return true ; }
8432	public function getDsn ( array $ info ) : string { $ dsn = 'pgsql:host=' ; $ dsn .= ( isset ( $ info [ 'host' ] ) === true ? $ info [ 'host' ] : 'localhost' ) . ';' ; if ( isset ( $ info [ 'port' ] ) === true ) { $ dsn .= 'port=' . $ info [ 'port' ] . ';' ; } $ dsn .= 'dbname=' . $ info [ 'name' ] . ';' ; return $ dsn ; }
7380	public function fetchEscape ( string $ key , \ mysqli $ db , string $ default = '' ) : string { return $ db -> real_escape_string ( $ this -> fetch ( $ key , $ default ) ) ; }
2726	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , 'magentomodule_basic_auth' ) ; if ( ! $ dictionary || ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) ) { return $ result -> setData ( [ 'status' => 'none' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ authItems = false ; if ( isset ( $ dictionary -> id ) ) { $ authItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; } if ( is_array ( $ authItems ) && empty ( $ authItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'There are no dictionary items.' ] ) ; } if ( ! $ authItems ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch dictionary items.' ] ) ; } foreach ( $ authItems as $ key => $ item ) { $ userData = explode ( ':' , base64_decode ( $ item -> item_key ) ) ; $ username = $ userData [ 0 ] ; $ item -> item_key_id = $ item -> item_key ; $ item -> item_key = $ username ; $ authItems [ $ key ] = $ item ; } return $ result -> setData ( [ 'status' => true , 'auths' => $ authItems ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
693	public function compose ( $ view = null , array $ params = [ ] ) { $ message = $ this -> createMessage ( ) ; if ( $ view === null ) { return $ message ; } if ( ! array_key_exists ( 'message' , $ params ) ) { $ params [ 'message' ] = $ message ; } $ this -> _message = $ message ; if ( is_array ( $ view ) ) { if ( isset ( $ view [ 'html' ] ) ) { $ html = $ this -> render ( $ view [ 'html' ] , $ params , $ this -> htmlLayout ) ; } if ( isset ( $ view [ 'text' ] ) ) { $ text = $ this -> render ( $ view [ 'text' ] , $ params , $ this -> textLayout ) ; } } else { $ html = $ this -> render ( $ view , $ params , $ this -> htmlLayout ) ; } $ this -> _message = null ; if ( isset ( $ html ) ) { $ message -> setHtmlBody ( $ html ) ; } if ( isset ( $ text ) ) { $ message -> setTextBody ( $ text ) ; } elseif ( isset ( $ html ) ) { if ( preg_match ( '~<body[^>]*>(.*?)</body>~is' , $ html , $ match ) ) { $ html = $ match [ 1 ] ; } $ html = preg_replace ( '~<((style|script))[^>]*>(.*?)</\1>~is' , '' , $ html ) ; $ text = html_entity_decode ( strip_tags ( $ html ) , ENT_QUOTES | ENT_HTML5 , Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ) ; $ text = preg_replace ( "~^[ \t]+~m" , '' , trim ( $ text ) ) ; $ text = preg_replace ( '~\R\R+~mu' , "\n\n" , $ text ) ; $ message -> setTextBody ( $ text ) ; } return $ message ; }
3450	public function getDirectChildren ( array $ filter = [ ] ) { return static :: query ( ) -> filter ( $ filter ) -> filter ( [ 'SECTION_ID' => $ this -> id ] ) -> select ( 'ID' ) -> getList ( ) -> transform ( function ( $ section ) { return ( int ) $ section [ 'ID' ] ; } ) -> all ( ) ; }
598	public function joinWith ( $ with , $ eagerLoading = true , $ joinType = 'LEFT JOIN' ) { $ relations = [ ] ; foreach ( ( array ) $ with as $ name => $ callback ) { if ( is_int ( $ name ) ) { $ name = $ callback ; $ callback = null ; } if ( preg_match ( '/^(.*?)(?:\s+AS\s+|\s+)(\w+)$/i' , $ name , $ matches ) ) { list ( , $ relation , $ alias ) = $ matches ; $ name = $ relation ; $ callback = function ( $ query ) use ( $ callback , $ alias ) { $ query -> alias ( $ alias ) ; if ( $ callback !== null ) { call_user_func ( $ callback , $ query ) ; } } ; } if ( $ callback === null ) { $ relations [ ] = $ name ; } else { $ relations [ $ name ] = $ callback ; } } $ this -> joinWith [ ] = [ $ relations , $ eagerLoading , $ joinType ] ; return $ this ; }
7600	public function render ( array $ aButtons , array $ aButtonGroupOptions = null ) { if ( empty ( $ aButtonGroupOptions [ 'attributes' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] = array ( 'class' => 'btn-group' ) ; } else { if ( ! is_array ( $ aButtonGroupOptions [ 'attributes' ] ) ) { throw new LogicException ( '"attributes" option expects an array, "' . gettype ( $ aButtonGroupOptions [ 'attributes' ] ) . '" given' ) ; } if ( empty ( $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] = 'btn-group' ; } elseif ( ! preg_match ( '/(\s|^)(?:btn-group|btn-group-vertical)(\s|$)/' , $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] .= ' btn-group' ; } } return sprintf ( static :: $ buttonGroupContainerFormat , $ this -> createAttributesString ( $ aButtonGroupOptions [ 'attributes' ] ) , $ this -> renderButtons ( $ aButtons , strpos ( $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] , 'btn-group-justified' ) !== false ) ) ; }
9553	public function allowExtensions ( $ extensions ) { if ( ! is_array ( $ extensions ) ) { $ extensions = [ $ extensions ] ; } $ this -> constraints [ ] = new ExtensionConstraint ( $ extensions ) ; return $ this ; }
3581	protected function pluckMeta ( Builder $ query , ArgumentBag $ args , $ alias ) { list ( $ column , $ key ) = [ $ args -> get ( 'column' ) , $ args -> get ( 'key' ) ] ; $ query -> select ( "{$alias}.meta_value as {$column}" ) ; if ( ! is_null ( $ key ) ) { $ this -> metaSelectListsKey ( $ query , $ key ) ; } return $ query -> callParent ( 'pluck' , $ args -> all ( ) ) ; }
6579	public function setParts ( array $ parts ) { $ parts = array_intersect_key ( $ parts , $ this -> params ) ; if ( isset ( $ parts [ 'port' ] ) ) $ parts [ 'port' ] = ( int ) $ parts [ 'port' ] ; if ( isset ( $ parts [ 'query' ] ) ) { $ query = $ this -> _parse_str ( $ parts [ 'query' ] ) ; $ this -> _rksort ( $ query ) ; $ parts [ 'query' ] = $ query ; } array_walk ( $ parts , function ( & $ part , $ key ) { if ( is_string ( $ part ) ) { $ part = strlen ( $ part ) ? $ part : null ; } else { $ part = $ part ? : null ; } } ) ; $ self = clone $ this ; $ self -> params = array_replace ( $ this -> params , $ parts ) ; return $ self ; }
7498	public function createAndSendMessageFromTemplate ( ) { $ args = func_get_args ( ) ; if ( empty ( $ args [ 0 ] ) ) { throw new \ RuntimeException ( 'First parameter must be a template filename or EmailTemplate entity' ) ; } elseif ( $ args [ 0 ] instanceof EmailTemplate ) { $ method = 'createMessageFromTemplateEntity' ; } else { $ method = 'createMessageFromTemplateFile' ; } $ message = call_user_func_array ( array ( $ this , $ method ) , $ args ) ; $ this -> mailer -> send ( $ message ) ; return true ; }
4652	public function cleanDirectories ( $ jobs = array ( ) ) { foreach ( $ jobs as $ job ) { $ this -> filesystem -> remove ( $ job -> getDirectory ( ) ) ; } }
4661	public function send ( ) { $ eventManager = $ this -> getManager ( ) -> getEventsManager ( ) ; if ( $ eventManager ) { $ result = $ eventManager -> fire ( 'mailer:beforeSend' , $ this ) ; } else { $ result = true ; } if ( $ result === false ) { return false ; } $ this -> failedRecipients = [ ] ; $ queue = $ this -> getManager ( ) -> getQueue ( ) ; if ( $ this -> auth ) { $ queue -> putInTube ( $ this -> queueName , [ 'message' => $ this -> getMessage ( ) , 'auth' => $ this -> smtp , ] ) ; } else { $ queue -> putInTube ( $ this -> queueName , $ this -> getMessage ( ) ) ; } }
12325	protected function execute ( InputInterface $ input , OutputInterface $ output ) { try { $ this -> doPreExecute ( $ input , $ output ) ; $ this -> returnCode = $ this -> doExecute ( $ input , $ output ) ; $ this -> doPostExecute ( $ input , $ output ) ; } catch ( Exception $ e ) { $ this -> returnCode = static :: RETURN_ERROR ; throw $ e ; } return $ this -> returnCode ; }
5465	public function addRealm ( $ url , $ type , $ realm ) { $ this -> realms [ $ url -> getHost ( ) ] [ $ realm ] = new SimpleRealm ( $ type , $ url ) ; }
924	public function getInvalidErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_INVALID === $ error -> getType ( ) ; } ) ; }
6562	public static function joinPath ( $ base , $ path ) { if ( substr ( $ path , 0 , 1 ) === '/' ) { return $ path ; } if ( substr ( $ base , 0 , 1 ) !== '/' ) { return false ; } $ pathParts = self :: splitPath ( $ path ) ; $ resultParts = self :: splitPath ( $ base ) ; while ( ( $ part = array_shift ( $ pathParts ) ) !== null ) { switch ( $ part ) { case '.' : break ; case '..' : if ( count ( $ resultParts ) > 1 ) { array_pop ( $ resultParts ) ; } break ; default : $ resultParts [ ] = $ part ; break ; } } return implode ( '/' , $ resultParts ) ; }
9935	public function setOperator ( $ pOperator ) { if ( empty ( $ pOperator ) ) { $ pOperator = self :: AUTOFILTER_COLUMN_RULE_EQUAL ; } if ( ( ! in_array ( $ pOperator , self :: $ operators ) ) && ( ! in_array ( $ pOperator , self :: $ topTenValue ) ) ) { throw new PhpSpreadsheetException ( 'Invalid operator for column AutoFilter Rule.' ) ; } $ this -> operator = $ pOperator ; return $ this ; }
2147	protected function sendNewsletter ( Email $ objEmail , Result $ objNewsletter , $ arrRecipient , $ text , $ html , $ css = null ) { $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ text , $ arrRecipient ) ; if ( ! $ objNewsletter -> sendText ) { if ( $ objNewsletter -> template == '' ) { $ objNewsletter -> template = 'mail_default' ; } $ objTemplate = new BackendTemplate ( $ objNewsletter -> template ) ; $ objTemplate -> setData ( $ objNewsletter -> row ( ) ) ; $ objTemplate -> title = $ objNewsletter -> subject ; $ objTemplate -> body = StringUtil :: parseSimpleTokens ( $ html , $ arrRecipient ) ; $ objTemplate -> charset = Config :: get ( 'characterSet' ) ; $ objTemplate -> recipient = $ arrRecipient [ 'email' ] ; $ objTemplate -> css = $ css ; $ objEmail -> html = $ objTemplate -> parse ( ) ; $ objEmail -> imageDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' ; } try { $ objEmail -> sendTo ( $ arrRecipient [ 'email' ] ) ; } catch ( \ Swift_RfcComplianceException $ e ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( $ objEmail -> hasFailures ( ) ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objEmail , $ objNewsletter , $ arrRecipient , $ text , $ html ) ; } } }
6055	public function addMediaToFolder ( $ folderId , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders/' . $ folderId . '/media' , $ parameters ) ; return $ result ; }
7570	public function getApplicationApiService ( ) { $ applicationService = new \ Greenhouse \ GreenhouseToolsPhp \ Services \ ApplicationService ( $ this -> _apiKey , $ this -> _boardToken ) ; $ apiClient = new GuzzleClient ( array ( 'base_uri' => ApiService :: APPLICATION_URL ) ) ; $ applicationService -> setClient ( $ apiClient ) ; return $ applicationService ; }
3085	public function getAssessmentItemRefsByPlaceholder ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , AssessmentItemRef $ placeholder ) { $ urlinfo = parse_url ( $ placeholder -> getHref ( ) ) ; $ adaptiveSectionId = ltrim ( $ urlinfo [ 'path' ] , '/' ) ; $ compilationDataService = $ this -> getServiceLocator ( ) -> get ( CompilationDataService :: SERVICE_ID ) ; $ filename = "adaptive-assessment-section-${adaptiveSectionId}" ; $ component = $ compilationDataService -> readPhpCompilationData ( $ privateCompilationDirectory , "${filename}.php" , $ filename ) ; return $ component -> getComponentsByClassName ( 'assessmentItemRef' ) -> getArrayCopy ( ) ; }
5347	public function revertSnapshotToOtherVps ( $ sourceVpsName , $ snapshotName , $ destinationVpsName ) { return $ this -> call ( self :: SERVICE , 'revertSnapshotToOtherVps' , [ $ sourceVpsName , $ snapshotName , $ destinationVpsName ] ) ; }
8026	public function remove ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; if ( $ this -> hasProcess ( $ pid ) === FALSE ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not remove process. Process (%d) not in list.' , $ processDetails -> getPid ( ) ) , 1400761297 ) ; } if ( isset ( $ this -> freeProcessIds [ $ pid ] ) ) { unset ( $ this -> freeProcessIds [ $ pid ] ) ; } if ( isset ( $ this -> sockets [ $ pid ] ) ) { unset ( $ this -> sockets [ $ pid ] ) ; } unset ( $ this -> processDetails [ $ pid ] ) ; return $ this ; }
2300	public static function getSystemMessages ( ) { $ strMessages = '' ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] ) ) { $ arrMessages = array ( ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] as $ callback ) { $ strBuffer = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( ) ; if ( $ strBuffer != '' ) { $ arrMessages [ ] = $ strBuffer ; } } if ( ! empty ( $ arrMessages ) ) { $ strMessages .= implode ( "\n" , $ arrMessages ) ; } } return $ strMessages ; }
12725	public function format ( $ event ) { $ output = $ this -> format ; if ( array_key_exists ( 'extra' , $ event ) === true ) { $ this -> formatExtra ( $ event , $ event [ 'extra' ] ) ; $ event [ 'message' ] = 'Missing Key:' ; } else { $ event [ 'extra' ] = [ ] ; } foreach ( $ event as $ name => $ value ) { if ( is_array ( $ value ) === true && count ( $ value ) === 0 ) { $ value = '' ; } else { $ value = $ this -> normalize ( $ value ) ; } $ output = str_replace ( '%' . $ name . '%' , $ value , $ output ) ; } return trim ( $ output ) ; }
4843	public static function sortPairs ( $ a , $ b ) { $ keys = strcmp ( $ a [ 0 ] , $ b [ 0 ] ) ; if ( $ keys !== 0 ) { return $ keys ; } return strcmp ( $ a [ 1 ] , $ b [ 1 ] ) ; }
4755	public function stopProfiling ( ) { if ( ! $ this -> profiling ) { return false ; } $ this -> profiling = false ; $ xhprof_data = xhprof_disable ( ) ; if ( is_array ( $ xhprof_data ) ) { $ this -> parser -> parse ( $ xhprof_data ) ; } foreach ( $ this -> probes as $ probe ) { $ name = $ probe -> getName ( ) ; if ( $ probe -> isTimingProbe ( ) ) { $ this -> timers [ $ name ] = $ probe -> getTime ( ) ; } if ( $ probe -> isCallsProbe ( ) ) { $ this -> counters [ $ name ] = $ probe -> getCount ( ) ; } } return true ; }
4503	public function replaceWith ( DOMNode $ replacement ) : void { $ this -> parentNode -> insertBefore ( $ replacement , $ this ) ; $ this -> remove ( ) ; }
2942	protected static function unitNameOrAliasesAlreadyRegistered ( UnitOfMeasureInterface $ unit ) { if ( ! is_array ( static :: $ unitDefinitions ) ) { static :: $ unitDefinitions = [ ] ; static :: initialize ( ) ; } $ currentUnitNamesAndAliases = [ ] ; foreach ( static :: $ unitDefinitions as $ unitOfMeasure ) { $ currentUnitNamesAndAliases [ ] = $ unitOfMeasure -> getName ( ) ; $ currentUnitNamesAndAliases = array_merge ( $ currentUnitNamesAndAliases , $ unitOfMeasure -> getAliases ( ) ) ; } $ newUnitNamesAndAliases = array_merge ( [ $ unit -> getName ( ) ] , $ unit -> getAliases ( ) ) ; return count ( array_intersect ( $ currentUnitNamesAndAliases , $ newUnitNamesAndAliases ) ) > 0 ; }
6584	public function sum ( $ n , $ m = 0 ) { if ( $ m > 0 ) return $ this -> sum ( $ n + $ m ) - $ this -> sum ( $ m ) ; static :: ensureValid ( $ n ) ; return $ this -> b * ( 1 - pow ( $ this -> q , $ n ) ) / ( 1 - $ this -> q ) ; }
7999	public function identifyTargetName ( $ username , $ nt_domain , ServerChallenge $ server_challenge ) { $ target_name = $ nt_domain ? : $ server_challenge -> getTargetName ( ) ; if ( false !== strpos ( $ username , static :: USER_PRINCIPAL_NAME_SEPARATOR ) ) { $ target_name = '' ; } return $ target_name ; }
12274	public static function createFromFormat ( $ format , $ time , $ object = null ) { if ( empty ( $ object ) ) { $ object = new DateTimeZone ( 'America/Sao_Paulo' ) ; } return self :: cast ( parent :: createFromFormat ( $ format , $ time , $ object ) ) ; }
6502	public function parseQueryString ( Uri $ uri ) : IImmutableDictionary { if ( ( $ queryString = $ uri -> getQueryString ( ) ) === null ) { return new ImmutableHashTable ( [ ] ) ; } if ( ! isset ( $ this -> parsedQueryStringCache [ $ queryString ] ) ) { $ parsedQueryString = [ ] ; parse_str ( $ queryString , $ parsedQueryString ) ; $ kvps = [ ] ; foreach ( $ parsedQueryString as $ key => $ value ) { $ kvps [ ] = new KeyValuePair ( $ key , $ value ) ; } $ this -> parsedQueryStringCache [ $ queryString ] = new ImmutableHashTable ( $ kvps ) ; } return $ this -> parsedQueryStringCache [ $ queryString ] ; }
3	private function buildDependency20Info ( $ depArray ) { $ result = array ( ) ; $ optionals = array ( ) ; $ defaultOptionals = array ( ) ; foreach ( $ depArray as $ depType => $ depTypeGroup ) { if ( ! is_array ( $ depTypeGroup ) ) { continue ; } if ( 'required' == $ depType || 'optional' == $ depType ) { foreach ( $ depTypeGroup as $ depItemType => $ depItem ) { switch ( $ depItemType ) { case 'php' : $ result [ ] = new DependencyConstraint ( $ depType , $ this -> parse20VersionConstraint ( $ depItem ) , 'php' , '' ) ; break ; case 'package' : $ deps = $ this -> buildDepPackageConstraints ( $ depItem , $ depType ) ; $ result = array_merge ( $ result , $ deps ) ; break ; case 'extension' : $ deps = $ this -> buildDepExtensionConstraints ( $ depItem , $ depType ) ; $ result = array_merge ( $ result , $ deps ) ; break ; case 'subpackage' : $ deps = $ this -> buildDepPackageConstraints ( $ depItem , 'replaces' ) ; $ defaultOptionals += $ deps ; break ; case 'os' : case 'pearinstaller' : break ; default : break ; } } } elseif ( 'group' == $ depType ) { if ( $ this -> isHash ( $ depTypeGroup ) ) { $ depTypeGroup = array ( $ depTypeGroup ) ; } foreach ( $ depTypeGroup as $ depItem ) { $ groupName = $ depItem [ 'attribs' ] [ 'name' ] ; if ( ! isset ( $ optionals [ $ groupName ] ) ) { $ optionals [ $ groupName ] = array ( ) ; } if ( isset ( $ depItem [ 'subpackage' ] ) ) { $ optionals [ $ groupName ] += $ this -> buildDepPackageConstraints ( $ depItem [ 'subpackage' ] , 'replaces' ) ; } else { $ result += $ this -> buildDepPackageConstraints ( $ depItem [ 'package' ] , 'optional' ) ; } } } } if ( count ( $ defaultOptionals ) > 0 ) { $ optionals [ '*' ] = $ defaultOptionals ; } return new DependencyInfo ( $ result , $ optionals ) ; }
2679	public function queryHistoricStats ( array $ parameters ) { $ uri = $ this -> _getHistoricalEndpoint ( ) . '?region=' . $ parameters [ 'region' ] . '&from=' . $ parameters [ 'from' ] . '&to=' . $ parameters [ 'to' ] . '&by=' . $ parameters [ 'sample_rate' ] ; $ result = $ this -> _fetch ( $ uri ) ; return $ result ; }
4409	protected function render ( $ template , $ parameters ) { $ twig = new Twig_Environment ( new Twig_Loader_Filesystem ( $ this -> skeletonDirs ) , array ( 'debug' => true , 'cache' => false , 'strict_variables' => true , 'autoescape' => false , ) ) ; return $ twig -> render ( $ template , $ parameters ) ; }
2376	public static function sanitizeFileName ( $ strName ) { $ strName = preg_replace ( '/[\pC]/u' , '' , $ strName ) ; if ( $ strName === null ) { throw new \ InvalidArgumentException ( 'The file name could not be sanitzied' ) ; } $ strName = str_replace ( array ( '\\' , '/' , ':' , '*' , '?' , '"' , '<' , '>' , '|' ) , '-' , $ strName ) ; return $ strName ; }
992	public static function visitUsingRules ( Schema $ schema , TypeInfo $ typeInfo , DocumentNode $ documentNode , array $ rules ) { $ context = new ValidationContext ( $ schema , $ documentNode , $ typeInfo ) ; $ visitors = [ ] ; foreach ( $ rules as $ rule ) { $ visitors [ ] = $ rule -> getVisitor ( $ context ) ; } Visitor :: visit ( $ documentNode , Visitor :: visitWithTypeInfo ( $ typeInfo , Visitor :: visitInParallel ( $ visitors ) ) ) ; return $ context -> getErrors ( ) ; }
499	protected function writeInteger ( $ fileHandle , $ integer ) { return $ this -> writeBytes ( $ fileHandle , pack ( $ this -> useBigEndian ? 'N' : 'V' , ( int ) $ integer ) ) ; }
11650	protected function _authenticateValidateResult ( $ resultIdentity ) { $ code = Zend_Auth_Result :: FAILURE_CREDENTIAL_INVALID ; $ message = 'Supplied credential is invalid.' ; if ( Benri_Util_String :: verifyPassword ( $ this -> _credential , $ resultIdentity [ $ this -> _credentialColumn ] ) ) { $ code = Zend_Auth_Result :: SUCCESS ; $ message = 'Authentication successful.' ; $ this -> _resultRow = $ resultIdentity ; } $ this -> _authenticateResultInfo [ 'code' ] = $ code ; $ this -> _authenticateResultInfo [ 'messages' ] [ ] = $ message ; return $ this -> _authenticateCreateAuthResult ( ) ; }
1647	public function calculateBearing ( Coordinate $ point1 , Coordinate $ point2 ) : float { $ lat1 = deg2rad ( $ point1 -> getLat ( ) ) ; $ lat2 = deg2rad ( $ point2 -> getLat ( ) ) ; $ lng1 = deg2rad ( $ point1 -> getLng ( ) ) ; $ lng2 = deg2rad ( $ point2 -> getLng ( ) ) ; $ y = sin ( $ lng2 - $ lng1 ) * cos ( $ lat2 ) ; $ x = cos ( $ lat1 ) * sin ( $ lat2 ) - sin ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lng2 - $ lng1 ) ; $ bearing = rad2deg ( atan2 ( $ y , $ x ) ) ; if ( $ bearing < 0 ) { $ bearing = fmod ( $ bearing + 360 , 360 ) ; } return $ bearing ; }
1223	public function resolve ( $ uri , $ version , $ resource , array $ paramDefs , array $ paramValues ) { foreach ( $ paramValues as $ param => $ value ) { if ( ! array_key_exists ( $ param , $ paramDefs ) ) { throw new \ InvalidArgumentException ( "Unknown uri parameter \"$param\" provided" ) ; } } foreach ( $ paramDefs as $ key => $ def ) { if ( ! isset ( $ paramValues [ $ key ] ) ) { if ( isset ( $ def [ 'default' ] ) ) { $ paramValues [ $ key ] = is_callable ( $ def [ 'default' ] ) ? $ def [ 'default' ] ( $ paramValues ) : $ def [ 'default' ] ; } elseif ( empty ( $ def [ 'required' ] ) ) { continue ; } else { $ this -> throwRequired ( $ paramDefs , $ paramValues ) ; } } $ this -> checkType ( $ def [ 'valid' ] , $ key , $ paramValues [ $ key ] ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ paramValues [ $ key ] , $ paramValues ) ; } } return ( "$uri/" . "$version/" . $ this -> fillPathParams ( $ resource , $ paramValues ) . $ this -> buildQueryParameters ( $ paramValues ) ) ; }
12083	public function getAllMedia ( $ objectType = 'media' , $ objectURI = NULL , $ objectId = NULL ) { $ objects = $ this -> getMediaObjectsList ( $ objectType , $ objectURI , $ objectId ) -> fetchAll ( ) ; $ items = array ( ) ; foreach ( $ objects as $ i => $ object ) { $ object = $ this -> getOwner ( $ object , $ object [ 'media_owner' ] ) ; if ( $ object [ 'object_type' ] === "attachment" ) : $ object [ 'media_object' ] = $ object [ 'object_uri' ] ; if ( empty ( $ object [ 'media_title' ] ) ) : $ object [ 'media_title' ] = $ object [ 'attachment_name' ] ; endif ; endif ; $ object [ 'media_comment_target' ] = $ object [ 'object_uri' ] ; $ object [ 'media_published' ] = $ object [ 'object_created_on' ] ; $ items [ ] = $ object ; } $ mediacollections = new Collection ( ) ; $ mediacollections :: set ( "items" , $ items ) ; $ mediacollections :: set ( "totalItems" , count ( $ items ) ) ; $ collection = $ mediacollections :: getArray ( ) ; return $ collection ; }
3367	protected function prepareEvent ( EventInterface $ event ) { foreach ( [ 'elementSpec' , 'inputSpec' ] as $ type ) { if ( ! $ event -> getParam ( $ type ) ) { $ event -> setParam ( $ type , new ArrayObject ( ) ) ; } } $ elementSpec = $ event -> getParam ( 'elementSpec' ) ; $ inputSpec = $ event -> getParam ( 'inputSpec' ) ; if ( ! isset ( $ elementSpec [ 'spec' ] ) ) { $ elementSpec [ 'spec' ] = [ ] ; } if ( ! isset ( $ inputSpec [ 'filters' ] ) ) { $ inputSpec [ 'filters' ] = [ ] ; } if ( ! isset ( $ inputSpec [ 'validators' ] ) ) { $ inputSpec [ 'validators' ] = [ ] ; } }
5498	public function expectArguments ( $ method , $ args , $ message ) { $ args = $ this -> replaceWildcards ( $ args ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args [ strtolower ( $ method ) ] = new ParametersExpectation ( $ args , $ message ) ; }
969	public function getType ( ) { $ config = Config :: get ( 'shopify-app.api_grant_mode' ) ; if ( $ config === self :: GRANT_PERUSER ) { return self :: GRANT_PERUSER ; } return self :: GRANT_OFFLINE ; }
10975	public function populateLocationOwner ( ) { $ location = $ this -> location ; if ( $ location !== null ) { $ this -> country_id = $ location -> country_id ; $ this -> region_id = $ location -> region_id ; $ this -> city_id = $ location -> city_id ; $ this -> state_id = $ location -> state_id ; $ this -> address = $ location -> address ; $ this -> postal_code = $ location -> postal_code ; $ this -> latitude = $ location -> latitude ; $ this -> longitude = $ location -> longitude ; } }
6786	public function buildHeaders ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ headerOptions = [ ] ; foreach ( $ this -> headerParameters as $ key => $ isHeaderParameter ) { if ( $ isHeaderParameter && isset ( $ options [ $ key ] ) ) { $ headerOptions [ $ key ] = $ options [ $ key ] ; } } return $ headerOptions ; }
981	public function planCharge ( ) { return $ this -> charges ( ) -> whereIn ( 'type' , [ Charge :: CHARGE_RECURRING , Charge :: CHARGE_ONETIME ] ) -> where ( 'plan_id' , $ this -> plan_id ) -> orderBy ( 'created_at' , 'desc' ) -> first ( ) ; }
1540	public function withQualifiedColumn ( $ column ) { $ parts = explode ( '.' , $ column ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withColumn ( $ parts [ 1 ] ) ; return $ this ; }
1003	public function parseHttpRequest ( ? callable $ readRawBodyFn = null ) { $ method = $ _SERVER [ 'REQUEST_METHOD' ] ?? null ; $ bodyParams = [ ] ; $ urlParams = $ _GET ; if ( $ method === 'POST' ) { $ contentType = $ _SERVER [ 'CONTENT_TYPE' ] ?? null ; if ( $ contentType === null ) { throw new RequestError ( 'Missing "Content-Type" header' ) ; } if ( stripos ( $ contentType , 'application/graphql' ) !== false ) { $ rawBody = $ readRawBodyFn ? $ readRawBodyFn ( ) : $ this -> readRawBody ( ) ; $ bodyParams = [ 'query' => $ rawBody ? : '' ] ; } elseif ( stripos ( $ contentType , 'application/json' ) !== false ) { $ rawBody = $ readRawBodyFn ? $ readRawBodyFn ( ) : $ this -> readRawBody ( ) ; $ bodyParams = json_decode ( $ rawBody ? : '' , true ) ; if ( json_last_error ( ) ) { throw new RequestError ( 'Could not parse JSON: ' . json_last_error_msg ( ) ) ; } if ( ! is_array ( $ bodyParams ) ) { throw new RequestError ( 'GraphQL Server expects JSON object or array, but got ' . Utils :: printSafeJson ( $ bodyParams ) ) ; } } elseif ( stripos ( $ contentType , 'application/x-www-form-urlencoded' ) !== false ) { $ bodyParams = $ _POST ; } elseif ( stripos ( $ contentType , 'multipart/form-data' ) !== false ) { $ bodyParams = $ _POST ; } else { throw new RequestError ( 'Unexpected content type: ' . Utils :: printSafeJson ( $ contentType ) ) ; } } return $ this -> parseRequestParams ( $ method , $ bodyParams , $ urlParams ) ; }
6465	public function isMultipart ( HttpHeaders $ headers ) : bool { $ contentType = null ; $ headers -> tryGetFirst ( 'Content-Type' , $ contentType ) ; return preg_match ( "/multipart\//i" , $ contentType ) === 1 ; }
724	public function getUniqueId ( ) { return $ this -> module instanceof Application ? $ this -> id : $ this -> module -> getUniqueId ( ) . '/' . $ this -> id ; }
3067	public function process ( ) { $ this -> validate ( ) ; $ ref = ( $ this -> getRequestParameter ( 'ref' ) === false ) ? null : $ this -> getRequestParameter ( 'ref' ) ; $ direction = $ this -> getRequestParameter ( 'direction' ) ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = ( $ this -> getRequestParameter ( 'start' ) !== false ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( ! $ this -> getRunnerService ( ) -> isTerminated ( $ serviceContext ) ) { $ this -> endItemTimer ( $ this -> getTime ( ) ) ; $ this -> saveItemState ( ) ; } $ this -> initServiceContext ( ) ; $ this -> saveItemResponses ( false ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ serviceContext -> getTestSession ( ) -> initItemTimer ( $ this -> getTime ( ) ) ; $ result = $ this -> getRunnerService ( ) -> move ( $ serviceContext , $ direction , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } common_Logger :: d ( 'Test session state : ' . $ serviceContext -> getTestSession ( ) -> getState ( ) ) ; if ( $ start === true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { common_Logger :: e ( $ e -> getMessage ( ) ) ; $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
4862	private function createEnvelope ( JobInterface $ job , array $ options = [ ] ) { $ scheduled = $ this -> parseOptionsToDateTime ( $ options ) ; $ tried = isset ( $ options [ 'tried' ] ) ? ( int ) $ options [ 'tried' ] : null ; $ message = isset ( $ options [ 'message' ] ) ? $ options [ 'message' ] : null ; $ trace = isset ( $ options [ 'trace' ] ) ? $ options [ 'trace' ] : null ; $ envelope = [ 'queue' => $ this -> getName ( ) , 'status' => self :: STATUS_PENDING , 'tried' => $ tried , 'message' => $ message , 'trace' => $ trace , 'created' => $ this -> dateTimeToUTCDateTime ( $ this -> now ) , 'data' => $ this -> serializeJob ( $ job ) , 'scheduled' => $ this -> dateTimeToUTCDateTime ( $ scheduled ) , 'priority' => isset ( $ options [ 'priority' ] ) ? $ options [ 'priority' ] : self :: DEFAULT_PRIORITY , ] ; return $ envelope ; }
3731	protected function fetchRows ( $ arrIds , $ arrAttrOnly = array ( ) ) { $ builder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ query = $ builder -> select ( '*' ) -> from ( $ this -> getTableName ( ) ) -> where ( $ builder -> expr ( ) -> in ( 'id' , ':values' ) ) -> setParameter ( 'values' , $ arrIds , Connection :: PARAM_STR_ARRAY ) -> orderBy ( 'FIELD(id, :values)' ) -> execute ( ) ; if ( $ arrAttrOnly ) { $ arrAttrOnly = array_merge ( $ this -> systemColumns , $ arrAttrOnly ) ; } $ result = [ ] ; while ( $ row = $ query -> fetch ( \ PDO :: FETCH_ASSOC ) ) { $ data = [ ] ; foreach ( $ row as $ attribute => $ value ) { if ( ( ! $ arrAttrOnly ) || ( in_array ( $ attribute , $ arrAttrOnly , true ) ) ) { $ data [ $ attribute ] = $ value ; } } $ result [ $ row [ 'id' ] ] = $ data ; } return $ result ; }
8106	protected function getEmailBody ( $ config , $ variables ) { $ template = SSViewer :: fromString ( $ config -> ReviewBody ) ; $ value = $ template -> process ( ArrayData :: create ( $ variables ) ) ; return DBField :: create_field ( 'HTMLText' , ( string ) $ value ) ; }
8707	public function getLastFolderID ( ) { $ request = Controller :: curr ( ) -> getRequest ( ) ; $ session = $ request -> getSession ( ) ; return $ session -> get ( self :: class . '.FolderID' ) ; }
12937	private function changeBlockSlotAndName ( $ targetFile , $ blockName , $ slotName ) { $ block = json_decode ( FilesystemTools :: readFile ( $ targetFile ) , true ) ; $ block [ "name" ] = $ blockName ; $ block [ "slot_name" ] = $ slotName ; $ json = json_encode ( $ block ) ; FilesystemTools :: writeFile ( $ targetFile , $ json ) ; return $ block ; }
10592	public function display ( $ level = 0 ) { $ value = $ this -> getContent ( ) ; if ( null === $ value ) { $ value = 'null' ; } elseif ( is_object ( $ value ) ) { $ value = get_class ( $ value ) ; } elseif ( is_array ( $ value ) ) { $ value = 'Array' ; } $ ret = str_repeat ( ' ' , $ level * 4 ) . $ value . "\n" ; $ children = $ this -> getChildren ( ) ; foreach ( $ children as $ child ) { $ ret .= $ child -> display ( $ level + 1 ) ; } return $ ret ; }
7043	public function handleSrcTableNames ( GetPropertyOptionsEvent $ event ) { if ( ( $ event -> getPropertyName ( ) !== 'tag_srctable' ) || ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_attribute' ) ) { return ; } $ sqlTable = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.sql-table' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ translated = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.translated' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ untranslated = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.untranslated' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ result = $ this -> getMetaModelTableNames ( $ translated , $ untranslated ) ; foreach ( $ this -> connection -> getSchemaManager ( ) -> listTableNames ( ) as $ table ) { if ( 0 !== \ strpos ( $ table , 'mm_' ) ) { $ result [ $ sqlTable ] [ $ table ] = $ table ; } } if ( \ is_array ( $ result [ $ translated ] ) ) { \ asort ( $ result [ $ translated ] ) ; } if ( \ is_array ( $ result [ $ untranslated ] ) ) { \ asort ( $ result [ $ untranslated ] ) ; } if ( \ is_array ( $ result [ $ sqlTable ] ) ) { \ asort ( $ result [ $ sqlTable ] ) ; } $ event -> setOptions ( $ result ) ; }
8380	protected function applyFilters ( $ value , $ key ) { foreach ( $ this -> filters as $ filter ) { $ value = $ filter ( $ value , $ key ) ; } return $ value ; }
1553	protected function resourceAttributes ( $ record = null ) { return $ this -> validatorFactory ( ) -> attributes ( $ this -> attributeRules ( $ record ) , $ this -> attributeMessages ( $ record ) , $ this -> attributeCustomAttributes ( $ record ) , function ( Validator $ validator ) use ( $ record ) { return $ this -> conditionalAttributes ( $ validator , $ record ) ; } , function ( ResourceObjectInterface $ resource , $ record ) { return $ this -> extractAttributes ( $ resource , $ record ) ; } ) ; }
1998	public function getLocale ( ) : string { foreach ( $ this -> getAcceptedLocales ( ) as $ locale ) { if ( file_exists ( $ this -> translationsDir . '/messages.' . $ locale . '.xlf' ) ) { return $ locale ; } } return 'en' ; }
3803	private function createProperty ( PropertyInterface $ property , $ propertyName , $ variantHandling , ConditionInterface $ condition = null , ConditionInterface $ legendCondition = null ) { $ paletteProperty = new Property ( $ propertyName ) ; $ extra = $ property -> getExtra ( ) ; $ chain = new PropertyConditionChain ( ) ; $ paletteProperty -> setEditableCondition ( $ chain ) ; if ( isset ( $ extra [ 'readonly' ] ) ) { $ chain -> addCondition ( new BooleanCondition ( $ extra [ 'readonly' ] ) ) ; } $ chain = new PropertyConditionChain ( ) ; $ paletteProperty -> setVisibleCondition ( $ chain ) ; if ( $ variantHandling ) { $ chain -> addCondition ( new IsVariantAttribute ( ) ) ; } $ chain -> addCondition ( new BooleanCondition ( ! ( ( isset ( $ extra [ 'doNotShow' ] ) && $ extra [ 'doNotShow' ] ) || ( isset ( $ extra [ 'hideInput' ] ) && $ extra [ 'hideInput' ] ) ) ) ) ; if ( null !== $ condition ) { $ chain -> addCondition ( $ condition ) ; } if ( null !== $ legendCondition ) { $ chain -> addCondition ( $ legendCondition ) ; } return $ paletteProperty ; }
7325	protected function cachingIsPossible ( ) { if ( static :: $ _cachingIsPossible === null ) { $ storeClass = '\AlternativeLaravelCache\Core\AlternativeCacheStore' ; $ poolInterface = '\Cache\Taggable\TaggablePoolInterface' ; $ cache = app ( 'cache.store' ) -> getStore ( ) ; static :: $ _cachingIsPossible = ( $ cache instanceof $ storeClass && $ cache -> getWrappedConnection ( ) instanceof $ poolInterface ) ; } return static :: $ _cachingIsPossible ; }
2606	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ aclItemId = $ this -> getRequest ( ) -> getParam ( 'acl_item_id' ) ; $ deleteItem = $ this -> api -> deleteAclItem ( $ aclId , $ aclItemId ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11643	public function getFormatter ( ) { if ( $ this -> _formatter === null ) { $ this -> _formatter = Yii :: $ app -> format ; } return $ this -> _formatter ; }
9204	public static function get ( $ item ) { $ item = strtoupper ( $ item ) ; $ config = json_decode ( file_get_contents ( dirname ( __FILE__ ) . "/Config.json" ) , true ) ; if ( ! isset ( $ config [ $ item ] ) ) { throw new InvalidConfigItemException ( "Invalid Endpoint Requested!" ) ; } return $ config [ $ item ] ; }
12341	protected function printError ( \ Throwable $ error , bool $ withTime = true , ? string $ fontColor = null , ? string $ bgColor = self :: BG_COLOR_MAP [ 'red' ] ) : void { $ shift = $ withTime ? "\t\t" : '' ; $ this -> print ( $ this -> getColoredMsg ( 'Error: ' . $ error -> getMessage ( ) , $ fontColor , $ bgColor ) . \ PHP_EOL . $ shift . $ this -> getColoredMsg ( 'File: ' . $ error -> getFile ( ) , $ fontColor , $ bgColor ) . \ PHP_EOL . $ shift . $ this -> getColoredMsg ( 'Line: ' . $ error -> getLine ( ) , $ fontColor , $ bgColor ) , $ withTime ) ; }
10632	private function getFiles ( $ pattern ) { $ files = $ this -> filesystem -> glob ( $ this -> storagePath . DIRECTORY_SEPARATOR . $ pattern , GLOB_BRACE ) ; return array_filter ( array_map ( 'realpath' , $ files ) ) ; }
7772	protected function replaceMessageFormat ( $ message , array $ item ) { $ keys = array_keys ( $ item ) ; if ( ! empty ( $ item [ 'args' ] ) ) { $ args = $ item [ 'args' ] ; $ argReplace = array_map ( function ( $ i ) { return "{\${$i}}" ; } , array_keys ( $ args ) ) ; $ args [ ] = count ( $ item [ 'args' ] ) ; $ argReplace [ ] = '{$#}' ; $ args [ ] = implode ( ', ' , $ item [ 'args' ] ) ; $ argReplace [ ] = '{$*}' ; $ message = str_replace ( $ argReplace , $ args , $ message ) ; } $ message = str_replace ( [ '{field}' , '{value}' ] , [ $ item [ 'field' ] , $ item [ 'value' ] ] , $ message ) ; return $ message ; }
4613	public function withScalarValue ( $ value ) { $ this -> match = $ value ; $ this -> lowerBound = null ; $ this -> upperBound = null ; return $ this ; }
6468	public function parseAcceptCharsetHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept-Charset' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept-Charset' , $ i ) ; $ charset = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptCharsetHeaderValue ( $ charset , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
1513	public function create ( StoreInterface $ store , CreateResource $ request ) { $ record = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doCreate ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ record ) ) { return $ record ; } return $ this -> reply ( ) -> created ( $ record ) ; }
7384	private function generateString ( ) { $ this -> generateNumbers ( ) ; $ this -> adjective = $ this -> adjectives [ $ this -> first ] ; $ this -> animal = $ this -> animals [ $ this -> second ] ; switch ( $ this -> case ) { case 'ucfirst' : $ this -> string = ucfirst ( $ this -> adjective . $ this -> animal . $ this -> number ) ; break ; case 'ucwords' : case 'sentence' : $ this -> string = ucfirst ( $ this -> adjective ) . ucfirst ( $ this -> animal ) . ucfirst ( $ this -> number ) ; break ; case 'camel' : $ this -> string = $ this -> adjective . ucfirst ( $ this -> animal ) . $ this -> number ; break ; default : $ this -> string = $ this -> adjective . $ this -> animal . $ this -> number ; break ; } }
5815	public function onBeforeWrite ( ) { parent :: onBeforeWrite ( ) ; $ types = $ this -> Types ? explode ( ',' , $ this -> Types ) : array ( ) ; if ( is_string ( $ this -> TagTypes ) ) { $ types = array_merge ( $ types , array_keys ( unserialize ( $ this -> TagTypes ) ) ) ; } if ( ! empty ( $ types ) ) { sort ( $ types ) ; $ formatted = array ( ) ; $ existing = $ this -> service -> getFusionTagTypes ( ) ; foreach ( $ types as $ type ) { if ( isset ( $ existing [ $ type ] ) ) { $ formatted [ $ type ] = $ type ; } } $ this -> TagTypes = ! empty ( $ formatted ) ? serialize ( $ formatted ) : null ; $ this -> Types = implode ( ',' , $ formatted ) ; } }
609	public function convert ( $ asset , $ basePath ) { $ pos = strrpos ( $ asset , '.' ) ; if ( $ pos !== false ) { $ ext = substr ( $ asset , $ pos + 1 ) ; if ( isset ( $ this -> commands [ $ ext ] ) ) { list ( $ ext , $ command ) = $ this -> commands [ $ ext ] ; $ result = substr ( $ asset , 0 , $ pos + 1 ) . $ ext ; if ( $ this -> forceConvert || @ filemtime ( "$basePath/$result" ) < @ filemtime ( "$basePath/$asset" ) ) { $ this -> runCommand ( $ command , $ basePath , $ asset , $ result ) ; } return $ result ; } } return $ asset ; }
6316	public function setDeleteAction ( $ deleteAction ) { $ deleteAction = strtoupper ( $ deleteAction ) ; if ( ! in_array ( $ deleteAction , $ this -> getAvailableActions ( ) ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Action %s does not exist.' , $ deleteAction ) ) ; } $ this -> deleteAction = $ deleteAction ; }
997	public function offsetUnset ( $ offset ) { if ( $ offset === true ) { $ this -> trueValue = null ; $ this -> trueValueIsSet = false ; } elseif ( $ offset === false ) { $ this -> falseValue = null ; $ this -> falseValueIsSet = false ; } elseif ( is_int ( $ offset ) || is_string ( $ offset ) ) { unset ( $ this -> standardStore [ $ offset ] ) ; } elseif ( is_float ( $ offset ) ) { unset ( $ this -> floatStore [ ( string ) $ offset ] ) ; } elseif ( is_object ( $ offset ) ) { $ this -> objectStore -> offsetUnset ( $ offset ) ; } elseif ( is_array ( $ offset ) ) { $ index = array_search ( $ offset , $ this -> arrayKeys , true ) ; if ( $ index !== false ) { array_splice ( $ this -> arrayKeys , $ index , 1 ) ; array_splice ( $ this -> arrayValues , $ index , 1 ) ; } } elseif ( $ offset === null ) { $ this -> nullValue = null ; $ this -> nullValueIsSet = false ; } }
7015	private function format_y ( & $ str ) { if ( strstr ( $ str , '%y' ) ) $ str = str_replace ( '%y' , substr ( $ this -> year , strlen ( $ this -> year ) - 2 , 2 ) , $ str ) ; }
8000	public function calculateNtResponse ( HashCredentialInterface $ hash_credential , $ client_challenge = null , $ server_challenge_nonce = null ) { $ encryption_data = $ server_challenge_nonce ; if ( null !== $ client_challenge ) { $ extended_security_hasher = $ this -> crypt_hasher_factory -> build ( static :: EXTENDED_SESSION_SECURITY_HASHER_ALGORITHM ) ; $ nt_extended_security_challenge_source = $ server_challenge_nonce . $ client_challenge ; $ nt_extended_security_hash = $ extended_security_hasher -> update ( $ nt_extended_security_challenge_source ) -> digest ( ) ; $ nt_extended_security_challenge = substr ( $ nt_extended_security_hash , 0 , static :: EXTENDED_SESSION_SECURITY_CHALLENGE_LENGTH ) ; $ encryption_data = $ nt_extended_security_challenge ; } return $ this -> calculateChallengeResponseData ( $ hash_credential , $ encryption_data ) ; }
8286	protected function loadDefaultConfig ( array $ config ) { $ configurator = new PluginConfigurator ; $ validConfig = $ configurator -> validate ( isset ( $ config [ self :: PLUGIN_NAME ] ) ? $ config [ self :: PLUGIN_NAME ] : null ) ; return $ validConfig ; }
11287	protected function _getCustomValue ( $ attributeName , $ query , $ loadMap = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap ) ; if ( ! $ result ) { $ result = $ query -> fetch ( ) ; } return $ result ; }
6173	public function read ( $ path , $ file ) { return $ this -> driver -> read ( $ this -> root . $ path , $ file ) ; }
3937	private function setOptions ( PropertyInterface $ property , $ propInfo ) { if ( null !== $ property -> getOptions ( ) || ! isset ( $ propInfo [ 'options' ] ) ) { return ; } $ property -> setOptions ( $ propInfo [ 'options' ] ) ; }
11821	function prepare_items ( ) { $ this -> columns = array ( $ this -> get_columns ( ) , $ this -> get_hidden_columns ( ) , $ this -> get_sortable_columns ( ) ) ; $ this -> items = $ this -> get_items ( ) ; usort ( $ this -> example_data , array ( $ this , 'usort_reorder' ) ) ; }
4928	public function setListener ( $ event , $ service , $ method = null , $ priority = 0 ) { if ( is_int ( $ method ) ) { $ priority = $ method ; $ method = null ; } $ name = uniqid ( ) ; $ this -> listenerSpecs [ $ name ] = [ 'event' => $ event , 'service' => $ service , 'method' => $ method , 'priority' => $ priority , 'instance' => null , ] ; return $ this ; }
9542	public function runSyncAction ( $ syncActionBaseUrl , $ component , $ action , array $ configData ) { $ uriParts = [ ] ; if ( $ this -> super ) { $ uriParts [ ] = $ this -> super ; } $ uriParts [ ] = $ component ; $ uriParts [ ] = 'action' ; $ uriParts [ ] = $ action ; $ uri = rtrim ( $ syncActionBaseUrl , '/' ) . '/' . implode ( '/' , $ uriParts ) ; $ body = [ 'configData' => $ configData , ] ; try { $ request = new Request ( 'POST' , $ uri , [ ] , json_encode ( $ body ) ) ; $ response = $ this -> guzzle -> send ( $ request ) ; } catch ( RequestException $ e ) { throw new ClientException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return $ this -> decodeResponse ( $ response ) ; }
1909	private function stripNamespace ( string $ fqcn ) : string { if ( false !== ( $ pos = strrpos ( $ fqcn , '\\' ) ) ) { return substr ( $ fqcn , $ pos + 1 ) ; } return $ fqcn ; }
8458	public function updateDb ( ) { $ this -> printTaskInfo ( 'Do database updates' ) ; $ this -> drush ( 'updb' ) ; $ drushVersion = $ this -> getVersion ( ) ; if ( - 1 === version_compare ( $ drushVersion , '6.0' ) ) { $ this -> printTaskInfo ( 'Will clear cache after db updates for drush ' . $ drushVersion ) ; $ this -> clearCache ( ) ; } else { $ this -> printTaskInfo ( 'Will not clear cache after db updates, since drush ' . $ drushVersion . ' should do it automatically' ) ; } return $ this ; }
780	public function getValue ( $ name , $ defaultValue = null ) { return isset ( $ this -> _cookies [ $ name ] ) ? $ this -> _cookies [ $ name ] -> value : $ defaultValue ; }
11390	public function getStatus ( ) { if ( isset ( $ this -> _log ) ) { $ this -> _status = $ this -> log -> statusLog ; } elseif ( ! isset ( $ this -> _status ) ) { $ this -> _status = new Status ( $ this -> log ) ; } return $ this -> _status ; }
1247	public static function ini ( $ profile = null , $ filename = null ) { $ filename = $ filename ? : ( self :: getHomeDir ( ) . '/.ebay_sdk/credentials' ) ; $ profile = $ profile ? : ( getenv ( self :: ENV_PROFILE ) ? : 'default' ) ; return function ( ) use ( $ filename , $ profile ) { if ( ! is_readable ( $ filename ) ) { return new \ InvalidArgumentException ( "Cannot read credentials from $filename" ) ; } $ data = parse_ini_file ( $ filename , true ) ; if ( $ data === false ) { return new \ InvalidArgumentException ( "Invalid credentials file $filename" ) ; } if ( ! isset ( $ data [ $ profile ] ) ) { return new \ InvalidArgumentException ( "'$profile' not found in credentials file" ) ; } if ( ! isset ( $ data [ $ profile ] [ 'ebay_app_id' ] ) || ! isset ( $ data [ $ profile ] [ 'ebay_cert_id' ] ) || ! isset ( $ data [ $ profile ] [ 'ebay_dev_id' ] ) ) { return new \ InvalidArgumentException ( "No credentials present in INI profile '$profile' ($filename)" ) ; } return new Credentials ( $ data [ $ profile ] [ 'ebay_app_id' ] , $ data [ $ profile ] [ 'ebay_cert_id' ] , $ data [ $ profile ] [ 'ebay_dev_id' ] ) ; } ; }
12933	protected function generateContent ( $ type , $ id , $ name , $ language ) { $ content = new Content ( ) ; $ content -> setContentId ( $ id ) ; $ content -> setContentType ( $ type ) ; $ content -> setDeleted ( false ) ; $ content -> setName ( $ name ) ; $ content -> setLanguage ( $ language ) ; $ content -> setStatus ( $ this -> getReference ( 'status-published' ) ) ; $ content -> setVersion ( '1' ) ; $ content -> setSiteId ( '2' ) ; $ date = new \ DateTime ( "now" ) ; $ content -> setVersionName ( $ content -> getName ( ) . '_' . $ date -> format ( "Y-m-d_H:i:s" ) ) ; return $ content ; }
48	protected function getListeners ( Event $ event ) { $ scriptListeners = $ this -> getScriptListeners ( $ event ) ; if ( ! isset ( $ this -> listeners [ $ event -> getName ( ) ] [ 0 ] ) ) { $ this -> listeners [ $ event -> getName ( ) ] [ 0 ] = array ( ) ; } krsort ( $ this -> listeners [ $ event -> getName ( ) ] ) ; $ listeners = $ this -> listeners ; $ listeners [ $ event -> getName ( ) ] [ 0 ] = array_merge ( $ listeners [ $ event -> getName ( ) ] [ 0 ] , $ scriptListeners ) ; return call_user_func_array ( 'array_merge' , $ listeners [ $ event -> getName ( ) ] ) ; }
1644	public function simplify ( Polyline $ polyline ) : Polyline { $ counterPoints = $ polyline -> getNumberOfPoints ( ) ; if ( $ counterPoints < 3 ) { return clone $ polyline ; } $ result = new Polyline ( ) ; $ bearingCalc = new BearingEllipsoidal ( ) ; $ points = $ polyline -> getPoints ( ) ; $ index = 0 ; $ result -> addPoint ( $ points [ $ index ] ) ; do { $ index ++ ; if ( $ index === ( $ counterPoints - 1 ) ) { $ result -> addPoint ( $ points [ $ index ] ) ; break ; } $ bearing1 = $ bearingCalc -> calculateBearing ( $ points [ $ index - 1 ] , $ points [ $ index ] ) ; $ bearing2 = $ bearingCalc -> calculateBearing ( $ points [ $ index ] , $ points [ $ index + 1 ] ) ; $ bearingDifference = min ( fmod ( $ bearing1 - $ bearing2 + 360 , 360 ) , fmod ( $ bearing2 - $ bearing1 + 360 , 360 ) ) ; if ( $ bearingDifference > $ this -> bearingAngle ) { $ result -> addPoint ( $ points [ $ index ] ) ; } } while ( $ index < $ counterPoints ) ; return $ result ; }
1379	protected function validateRelationship ( $ relation , ? string $ field = null ) : bool { $ path = $ field ? '/data/relationships' : '/' ; $ member = $ field ? : 'data' ; if ( ! is_object ( $ relation ) ) { $ this -> memberNotObject ( $ path , $ member ) ; return false ; } $ path = $ field ? "{$path}/{$field}" : $ path ; if ( ! property_exists ( $ relation , 'data' ) ) { $ this -> memberRequired ( $ path , 'data' ) ; return false ; } $ data = $ relation -> data ; if ( is_array ( $ data ) ) { return $ this -> validateToMany ( $ data , $ field ) ; } return $ this -> validateToOne ( $ data , $ field ) ; }
6798	public function install ( $ country = 'US' , $ currency = 'USD' ) { $ this -> installCountries ( $ country ) ; $ this -> installCurrencies ( $ currency ) ; $ this -> installTaxes ( $ country ) ; $ this -> installTaxGroups ( $ country ) ; $ this -> installTaxRules ( $ country ) ; $ this -> installCustomerGroups ( ) ; }
7918	public static function labelGroup ( $ labels = [ ] , $ options = [ ] ) { Ui :: addCssClasses ( $ options , [ 'ui' , 'labels' ] ) ; $ lines = [ ] ; foreach ( $ labels as $ label ) { $ content = ArrayHelper :: remove ( $ label , 'content' ) ; $ lines [ ] = static :: label ( $ content , $ label ) ; } return Ui :: tag ( 'div' , implode ( "\n" , $ lines ) , $ options ) ; }
9712	private function writeSupbookInternal ( ) { $ record = 0x01AE ; $ length = 0x0004 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , $ this -> spreadsheet -> getSheetCount ( ) , 0x0401 ) ; return $ this -> writeData ( $ header . $ data ) ; }
11874	protected function renewAccessToken ( ) { $ token = $ this -> authorizer -> getApi ( ) -> getAuthorizerToken ( $ this -> authorizer -> getAppId ( ) , $ this -> authorizer -> getRefreshToken ( ) ) ; $ this -> authorizer -> setAccessToken ( $ token [ 'authorizer_access_token' ] , $ token [ 'expires_in' ] - 1500 ) ; return $ token [ 'authorizer_access_token' ] ; }
9849	public function createSignedResponse ( int $ status , string $ body , SigningSecretKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { $ signature = \ ParagonIE_Sodium_Compat :: crypto_sign_detached ( $ body , $ key -> getString ( true ) ) ; if ( isset ( $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] ) ) { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] [ ] = Base64UrlSafe :: encode ( $ signature ) ; } else { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] = Base64UrlSafe :: encode ( $ signature ) ; } return new Response ( $ status , new Headers ( $ headers ) , $ this -> stringToStream ( $ body ) ) ; }
3287	public function plugin ( $ name , array $ options = null ) { $ helper = $ this -> getTwigHelpers ( ) -> setRenderer ( $ this ) ; if ( $ helper -> has ( $ name ) ) { return $ helper -> get ( $ name , $ options ) ; } return $ this -> getHelperPluginManager ( ) -> get ( $ name , $ options ) ; }
2203	public static function decodeEntities ( $ varValue ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: decodeEntities ( $ v ) ; } return $ varValue ; } $ varValue = static :: preserveBasicEntities ( $ varValue ) ; $ varValue = html_entity_decode ( $ varValue , ENT_QUOTES , Config :: get ( 'characterSet' ) ) ; return $ varValue ; }
5318	public function wait ( ) { $ this -> internalWait ( ) ; $ event = $ this -> isSuccessExit ( ) ? 'success' : 'error' ; $ this -> internalEmit ( 'exit' , $ this -> pid ) ; $ this -> internalEmit ( $ event ) ; return $ this ; }
12648	public function get ( ) { $ arResult = [ 'status' => $ this -> status ( ) , 'data' => $ this -> data ( ) , 'message' => $ this -> message ( ) , 'code' => $ this -> code ( ) , ] ; return $ arResult ; }
9861	private function writeDimension ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'dimension' ) ; $ objWriter -> writeAttribute ( 'ref' , $ pSheet -> calculateWorksheetDimension ( ) ) ; $ objWriter -> endElement ( ) ; }
1552	protected function adapterFor ( $ relation ) { $ adapter = $ this -> getStore ( ) -> adapterFor ( $ relation -> getModel ( ) ) ; if ( ! $ adapter instanceof AbstractAdapter ) { throw new RuntimeException ( 'Expecting inverse resource adapter to be an Eloquent adapter.' ) ; } return $ adapter ; }
5402	public function isExpired ( $ now ) { if ( ! $ this -> expiry ) { return true ; } if ( is_string ( $ now ) ) { $ now = strtotime ( $ now ) ; } return ( $ this -> expiry < $ now ) ; }
9822	public function writeRelationships ( Spreadsheet $ spreadsheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ customPropertyList = $ spreadsheet -> getProperties ( ) -> getCustomProperties ( ) ; if ( ! empty ( $ customPropertyList ) ) { $ this -> writeRelationship ( $ objWriter , 4 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties' , 'docProps/custom.xml' ) ; } $ this -> writeRelationship ( $ objWriter , 3 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties' , 'docProps/app.xml' ) ; $ this -> writeRelationship ( $ objWriter , 2 , 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties' , 'docProps/core.xml' ) ; $ this -> writeRelationship ( $ objWriter , 1 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' , 'xl/workbook.xml' ) ; if ( $ spreadsheet -> hasRibbon ( ) ) { $ this -> writeRelationShip ( $ objWriter , 5 , 'http://schemas.microsoft.com/office/2006/relationships/ui/extensibility' , $ spreadsheet -> getRibbonXMLData ( 'target' ) ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
4662	public function sendNow ( ) { $ config = $ this -> getManager ( ) -> getDI ( ) -> getConfig ( ) ; $ message = $ this -> getMessage ( ) ; $ username = $ config -> email -> username ; $ password = $ config -> email -> password ; $ host = $ config -> email -> host ; $ port = $ config -> email -> port ; $ transport = \ Swift_SmtpTransport :: newInstance ( $ host , $ port ) ; $ transport -> setUsername ( $ username ) ; $ transport -> setPassword ( $ password ) ; $ swift = \ Swift_Mailer :: newInstance ( $ transport ) ; $ failures = [ ] ; $ swift -> send ( $ message , $ failures ) ; }
7935	public function send ( $ from , $ to , $ msg ) { $ opt = array ( 'sender' => $ from , 'receivers' => array ( $ to ) , 'message' => $ msg ) ; return $ this -> createJob ( $ opt ) ; }
11935	public function primaryKey ( ) { $ pk = $ this -> meta -> schema -> primaryKey ; if ( is_array ( $ pk ) ) { $ ppk = [ ] ; foreach ( $ pk as $ key ) { $ ppk [ ] = $ key ; } return implode ( '.' , $ ppk ) ; } return $ pk ; }
10009	public function createSheet ( $ sheetIndex = null ) { $ newSheet = new Worksheet ( $ this ) ; $ this -> addSheet ( $ newSheet , $ sheetIndex ) ; return $ newSheet ; }
3572	public function set ( $ key , $ value = null , $ group = null ) { if ( $ key instanceof Attribute ) { return $ this -> setInstance ( $ key ) ; } if ( $ this -> has ( $ key ) ) { $ this -> update ( $ key , $ value , $ group ) ; } else { $ this -> items [ $ key ] = $ this -> newAttribute ( $ key , $ value , $ group ) ; } return $ this ; }
791	public function addErrors ( array $ items ) { foreach ( $ items as $ attribute => $ errors ) { if ( is_array ( $ errors ) ) { foreach ( $ errors as $ error ) { $ this -> addError ( $ attribute , $ error ) ; } } else { $ this -> addError ( $ attribute , $ errors ) ; } } }
7649	public function stream_flush ( ) { $ result = fflush ( $ this -> temporaryFileHandle ) ; if ( $ this -> writeMode ) { $ containerExists = $ this -> getStorageClient ( $ this -> fileName ) -> containerExists ( $ this -> getContainerName ( $ this -> fileName ) ) ; if ( ! $ containerExists ) { $ this -> getStorageClient ( $ this -> fileName ) -> createContainer ( $ this -> getContainerName ( $ this -> fileName ) ) ; } try { $ this -> getStorageClient ( $ this -> fileName ) -> putBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } catch ( BlobException $ ex ) { @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; throw $ ex ; } } return $ result ; }
3436	protected function fetchAllPropsForSelect ( ) { $ props = [ ] ; $ rsProps = static :: $ cIblockObject -> GetProperties ( $ this -> iblockId ) ; while ( $ prop = $ rsProps -> Fetch ( ) ) { $ props [ ] = 'PROPERTY_' . $ prop [ 'CODE' ] ; } return $ props ; }
4498	private function getTrimmedJson ( callable $ inner , int $ limit , string $ error ) : array { $ gcmInner = $ inner ( $ this -> text ) ; $ gcmInnerJson = json_encode ( $ gcmInner , JSON_UNESCAPED_UNICODE ) ; if ( ( $ gcmInnerJsonLength = \ strlen ( $ gcmInnerJson ) ) > $ limit ) { $ cut = $ gcmInnerJsonLength - $ limit ; if ( $ this -> text && ( $ textLength = \ strlen ( $ this -> text ) ) > $ cut && $ this -> allowTrimming ) { $ gcmInner = $ inner ( mb_strcut ( $ this -> text , 0 , $ textLength - $ cut - 3 , 'utf8' ) . '...' ) ; } else { throw new MessageTooLongException ( "$error $gcmInnerJson" ) ; } } return $ gcmInner ; }
4764	protected function validateDeliveryAddressOptIn ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_deliveryaddress' ) ; $ changeExistigAddress = ( int ) $ this -> getRequestParameter ( 'oegdproptin_changeDelAddress' ) ; $ addressId = $ this -> getRequestParameter ( 'oxaddressid' ) ; $ deliveryAddressData = $ this -> _getDelAddressData ( ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinDeliveryAddress' ) && ( ( null == $ addressId ) || ( '-1' == $ addressId ) || ( 1 == $ changeExistigAddress ) ) && ! empty ( $ deliveryAddressData ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
8588	public function setASINPrepInstructions ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ASINPrepInstructions' ] [ 'FieldValue' ] = $ value ; return $ this ; }
67	private function resolveSymlinkedDirectorySymlink ( $ pathname ) { if ( ! is_dir ( $ pathname ) ) { return $ pathname ; } $ resolved = rtrim ( $ pathname , '/' ) ; if ( ! strlen ( $ resolved ) ) { return $ pathname ; } return $ resolved ; }
3807	protected function translateLegend ( $ legend , $ metaModel ) { $ arrLegend = StringUtil :: deserialize ( $ legend [ 'legendtitle' ] ) ; if ( is_array ( $ arrLegend ) ) { $ strLegend = $ arrLegend [ $ GLOBALS [ 'TL_LANGUAGE' ] ] ; if ( ! $ strLegend ) { $ strLegend = $ arrLegend [ $ metaModel -> getFallbackLanguage ( ) ] ; if ( ! $ strLegend ) { $ strLegend = 'legend' . ( count ( $ this -> legends ) + 1 ) ; } } } else { $ strLegend = $ legend [ 'legendtitle' ] ? $ legend [ 'legendtitle' ] : 'legend' ; } $ legendName = StringUtil :: standardize ( $ strLegend ) ; $ this -> legends [ $ legendName ] = array ( 'name' => $ strLegend , 'visible' => ! ( isset ( $ legend [ 'legendhide' ] ) && ( bool ) $ legend [ 'legendhide' ] ) , 'properties' => array ( ) ) ; return $ legendName ; }
2431	public function checkCategory ( $ varValue ) { if ( \ strlen ( $ varValue ) || Contao \ Input :: post ( 'FORM_SUBMIT' ) == 'tl_style' ) { return $ varValue ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ key = 'tl_style_' . CURRENT_ID ; $ filter = $ objSessionBag -> get ( 'filter' ) ; if ( \ strlen ( $ filter [ $ key ] [ 'category' ] ) ) { return $ filter [ $ key ] [ 'category' ] ; } return '' ; }
1502	public function acceptable ( AcceptHeaderInterface $ accept ) : ? Encoding { foreach ( $ accept -> getMediaTypes ( ) as $ mediaType ) { if ( $ encoding = $ this -> matchesTo ( $ mediaType ) ) { return $ encoding ; } } return null ; }
9667	private function writeGradientFill ( XMLWriter $ objWriter , Fill $ pFill ) { $ objWriter -> startElement ( 'fill' ) ; $ objWriter -> startElement ( 'gradientFill' ) ; $ objWriter -> writeAttribute ( 'type' , $ pFill -> getFillType ( ) ) ; $ objWriter -> writeAttribute ( 'degree' , $ pFill -> getRotation ( ) ) ; $ objWriter -> startElement ( 'stop' ) ; $ objWriter -> writeAttribute ( 'position' , '0' ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getStartColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'stop' ) ; $ objWriter -> writeAttribute ( 'position' , '1' ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getEndColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
8308	public function assertArrayOfStrings ( $ config , $ key ) { if ( ! array_key_exists ( $ key , $ config ) ) { return $ this ; } if ( ! is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " section must be an array." ) ; } foreach ( $ config [ $ key ] as $ value ) { if ( ! is_string ( $ value ) ) { throw new ConfigurationException ( "Values in the `{$key}` must be strings" . gettype ( $ value ) . " found." ) ; } elseif ( $ value === "" ) { throw new ConfigurationException ( "Empty string not allowed in `{$key}` array." ) ; } } return $ this ; }
589	protected function registerBundle ( $ bundles , $ name , & $ registered ) { if ( ! isset ( $ registered [ $ name ] ) ) { $ registered [ $ name ] = false ; $ bundle = $ bundles [ $ name ] ; foreach ( $ bundle -> depends as $ depend ) { $ this -> registerBundle ( $ bundles , $ depend , $ registered ) ; } unset ( $ registered [ $ name ] ) ; $ registered [ $ name ] = $ bundle ; } elseif ( $ registered [ $ name ] === false ) { throw new Exception ( "A circular dependency is detected for target '{$name}': " . $ this -> composeCircularDependencyTrace ( $ name , $ registered ) . '.' ) ; } }
10434	protected function prepareTypeServiceConfigs ( $ serviceConfig , $ typeConfig , $ type ) { return array_merge ( $ serviceConfig , $ typeConfig [ 'config' ] , [ 'entity_class' => $ typeConfig [ 'entity_class' ] , 'document_class' => $ typeConfig [ 'document_class' ] , 'document_type' => $ type , ] ) ; }
6759	public function process ( ContainerBuilder $ container ) { if ( ! $ container -> has ( $ this -> registry ) ) { return ; } $ definition = $ container -> findDefinition ( $ this -> registry ) ; $ taggedServices = $ container -> findTaggedServiceIds ( $ this -> tag ) ; foreach ( $ taggedServices as $ id => $ tags ) { $ arguments = [ new Reference ( $ id ) ] ; if ( $ this -> withPriority ) { $ arguments [ ] = $ this -> resolvePriority ( $ tags ) ; } $ definition -> addMethodCall ( $ this -> method , $ arguments ) ; } }
4219	private function clearSummary ( $ flags ) { $ return = null ; $ clearErrors = $ flags & Debug :: CLEAR_SUMMARY_ERRORS ; if ( $ flags & Debug :: CLEAR_SUMMARY ) { $ return = 'summary (' . ( $ clearErrors ? 'incl errors' : 'sans errors' ) . ')' ; $ curPriority = \ end ( $ this -> data [ 'groupPriorityStack' ] ) ; foreach ( \ array_keys ( $ this -> data [ 'logSummary' ] ) as $ priority ) { $ entriesKeep = array ( ) ; if ( $ priority === $ curPriority ) { $ curDepth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] [ $ priority ] as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entriesKeep = $ this -> debug -> internal -> getCurrentGroups ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ curDepth ) ; } else { $ this -> data [ 'groupStacks' ] [ $ priority ] = array ( ) ; } $ this -> clearLogHelper ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ clearErrors , $ entriesKeep ) ; } } elseif ( $ clearErrors ) { $ return = 'summary errors' ; } return $ return ; }
135	public function ensureBinariesPresence ( PackageInterface $ package ) { try { $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; } catch ( \ InvalidArgumentException $ e ) { return ; } if ( $ installer instanceof BinaryPresenceInterface ) { $ installer -> ensureBinariesPresence ( $ package ) ; } }
3898	public function handleMetaChange ( $ strMetaName , $ varNewValue ) { if ( $ strMetaName == 'colname' ) { if ( $ this -> get ( $ strMetaName ) != $ varNewValue ) { $ this -> renameColumn ( $ varNewValue ) ; } return $ this ; } return parent :: handleMetaChange ( $ strMetaName , $ varNewValue ) ; }
2283	protected static function url ( ) { $ host = static :: get ( 'httpHost' ) ; $ xhost = static :: get ( 'httpXForwardedHost' ) ; if ( $ xhost != '' && $ xhost == Config :: get ( 'sslProxyDomain' ) ) { return 'https://' . $ xhost . '/' . $ host ; } return ( static :: get ( 'ssl' ) ? 'https://' : 'http://' ) . $ host ; }
722	public function json ( ) { if ( version_compare ( PHP_VERSION , '5.6' , '<' ) && $ this -> getDb ( ) -> getDriverName ( ) === 'mysql' ) { throw new \ yii \ base \ Exception ( 'JSON column type is not supported in PHP < 5.6' ) ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_JSON ) ; }
1637	protected function setupQueue ( QueueManager $ queue ) { $ queue -> looping ( function ( ) { $ this -> app -> bugsnag -> flush ( ) ; $ this -> app -> bugsnag -> clearBreadcrumbs ( ) ; $ this -> app -> make ( Tracker :: class ) -> clear ( ) ; } ) ; if ( ! class_exists ( JobProcessing :: class ) ) { return ; } $ queue -> before ( function ( JobProcessing $ event ) { $ this -> app -> bugsnag -> setFallbackType ( 'Queue' ) ; $ job = [ 'name' => $ event -> job -> getName ( ) , 'queue' => $ event -> job -> getQueue ( ) , 'attempts' => $ event -> job -> attempts ( ) , 'connection' => $ event -> connectionName , ] ; if ( method_exists ( $ event -> job , 'resolveName' ) ) { $ job [ 'resolved' ] = $ event -> job -> resolveName ( ) ; } $ this -> app -> make ( Tracker :: class ) -> set ( $ job ) ; } ) ; }
9384	public function getIcons ( ) { $ icons = [ ] ; foreach ( $ this -> getGroupedIcons ( ) as $ name => $ group ) { foreach ( $ group as $ id => $ icon ) { if ( ! isset ( $ icons [ $ id ] ) ) { $ icons [ $ id ] = isset ( $ icon [ 'name' ] ) ? $ icon [ 'name' ] : $ id ; } } } ksort ( $ icons ) ; return $ icons ; }
5201	public function buildConnectionOptions ( ) { $ connection_name = $ this -> config -> get ( "tail-settings.default" ) ; if ( $ this -> connection_name ) $ connection_name = $ this -> connection_name ; $ connectionOptions = $ this -> config -> get ( "tail-settings.connections.$connection_name" ) ; if ( ! isset ( $ connectionOptions [ 'exchange_type' ] ) ) $ connectionOptions [ 'exchange_type' ] = 'direct' ; if ( ! isset ( $ connectionOptions [ 'content_type' ] ) ) $ connectionOptions [ 'content_type' ] = 'text/plain' ; if ( $ this -> vhost ) $ connectionOptions [ 'vhost' ] = $ this -> vhost ; if ( $ this -> exchange ) $ connectionOptions [ 'exchange' ] = $ this -> exchange ; if ( $ this -> exchange_type ) $ connectionOptions [ 'exchange_type' ] = $ this -> exchange_type ; if ( $ this -> content_type ) $ connectionOptions [ 'content_type' ] = $ this -> content_type ; $ connectionOptions [ 'queue_name' ] = $ this -> queue_name ; return $ connectionOptions ; }
8566	public function getShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_GetShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_GetShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_GetShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7303	public function onParentChange ( ResourceEventInterface $ event ) { $ customer = $ this -> getCustomerFromEvent ( $ event ) ; if ( $ this -> updateFromParent ( $ customer ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ customer , true ) ; } }
10136	private function writeZoom ( ) { if ( $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) == 100 ) { return ; } $ record = 0x00A0 ; $ length = 0x0004 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) , 100 ) ; $ this -> append ( $ header . $ data ) ; }
1442	protected function replaceRecord ( & $ stub ) { $ resource = $ this -> getResourceName ( ) ; $ stub = str_replace ( 'DummyRecord' , Str :: classify ( str_singular ( $ resource ) ) , $ stub ) ; return $ this ; }
1779	public function getEmptyStringOrNull ( ) { if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ) { return '' ; } return static :: getEmptyStringOrNullByFieldType ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ; }
8450	public function contactRename ( $ contact , $ firstName , $ lastName ) { $ contact = $ this -> escapePeer ( $ contact ) ; $ firstName = $ this -> escapeStringArgument ( $ firstName ) ; $ lastName = $ this -> escapeStringArgument ( $ lastName ) ; return $ this -> exec ( 'rename_contact ' . $ contact . ' ' . $ firstName . ' ' . $ lastName ) ; }
6605	public function validateRequestTokenResponse ( $ params ) { if ( ! isset ( $ params [ 'oauth_token' ] ) || ! isset ( $ params [ 'oauth_token_secret' ] ) || empty ( $ params [ 'oauth_token' ] ) || empty ( $ params [ 'oauth_token_secret' ] ) ) { throw new InvalidOAuthTokenException ( 'request token' ) ; } return true ; }
3353	public function updateInfo ( ) { $ this -> cached_data = ( array ) $ this -> api -> __preparedRequest ( 'file' , 'GET' , array ( 'uuid' => $ this -> uuid ) ) ; return $ this -> cached_data ; }
10784	public function parse ( UriInterface $ uri ) : ParsedURL { $ matches = [ ] ; if ( preg_match ( $ this -> pattern , $ uri -> getPath ( ) , $ matches ) === 0 ) { throw new InvalidRequestURLException ( "Unable to parse request path: did not match regex" ) ; } if ( ! ( $ endpoint = $ matches [ "endpoint" ] ?? null ) ) { throw new InvalidRequestURLException ( "Unable to match endpoint in url" ) ; } $ element = $ matches [ "element" ] ?? null ; $ version = $ matches [ "version" ] ?? null ; $ apiKey = $ matches [ "apiKey" ] ?? null ; $ acceptableMimeTypes = [ ] ; if ( ( $ acceptableExtension = $ matches [ "acceptableExtension" ] ?? null ) ) { if ( ! $ this -> MIMEProvider ) { throw new UnableToParseURLException ( "Unable to accept acceptable extensions" ) ; } else { try { $ acceptableMimeTypes [ ] = $ this -> MIMEProvider -> provideMIME ( $ acceptableExtension ) ; } catch ( UnableToProvideMIMEException $ exception ) { throw new UnableToParseURLException ( $ exception -> getMessage ( ) ) ; } } } return new ParsedURL ( $ endpoint , $ element , $ version , $ apiKey , $ acceptableMimeTypes , $ uri -> getQuery ( ) ) ; }
3778	protected function getLabel ( ) { if ( null === ( $ attribute = $ this -> getFilteredAttribute ( ) ) ) { return null ; } if ( $ label = $ this -> get ( 'label' ) ) { return $ label ; } return $ attribute -> getName ( ) ; }
9500	public function supportsEvent ( $ eventId ) { $ supportedEvents = [ WatcherInterface :: CREATE_EVENT , WatcherInterface :: MODIFY_EVENT , WatcherInterface :: DELETE_EVENT , WatcherInterface :: ALL_EVENT ] ; return array_search ( $ eventId , $ supportedEvents , true ) !== false ; }
11253	public function transaction ( callable $ callback ) : void { $ this -> pdo -> beginTransaction ( ) ; $ callback ( $ this ) ; $ this -> pdo -> commit ( ) ; }
11031	protected function ensureFieldIds ( ) { if ( $ this -> submitModelName ) { $ formName = Inflector :: slug ( $ this -> submitModelName , '_' ) ; } else { $ model = new \ ReflectionClass ( $ this -> model ) ; $ formName = $ model -> getShortName ( ) ; } $ parts = [ ] ; preg_match_all ( '/{([^}]+)}/' , $ this -> template , $ parts ) ; $ keys = array_flip ( $ parts [ 1 ] ) ; $ fieldIds = [ ] ; if ( isset ( $ keys [ 'country' ] ) ) { $ fieldIds [ 'country' ] = $ formName . '_country_id' ; } if ( isset ( $ keys [ 'state' ] ) ) { $ fieldIds [ 'state' ] = $ formName . '_state_id' ; } if ( isset ( $ keys [ 'region' ] ) ) { $ fieldIds [ 'region' ] = $ formName . '_region_id' ; } if ( isset ( $ keys [ 'city' ] ) ) { $ fieldIds [ 'city' ] = $ formName . '_city_id' ; } if ( isset ( $ keys [ 'address' ] ) ) { $ fieldIds [ 'address' ] = $ formName . '_address' ; } if ( isset ( $ keys [ 'postalCode' ] ) ) { $ fieldIds [ 'postal_code' ] = $ formName . '_postal_code' ; } if ( isset ( $ keys [ 'geolocation' ] ) ) { $ fieldIds [ 'latitude' ] = $ formName . '_latitude' ; $ fieldIds [ 'longitude' ] = $ formName . '_longitude' ; } $ this -> fieldIds = $ fieldIds ; }
8971	protected function fromJson ( $ json ) { $ data = json_decode ( $ json , true ) ; return new Rate ( $ data [ 'sourceName' ] , ( float ) $ data [ 'value' ] , $ data [ 'currencyCode' ] , $ data [ 'rateType' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'date' ] ) , $ data [ 'baseCurrencyCode' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'createdAt' ] ) , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'modifiedAt' ] ) ) ; }
1603	private function _getVariables ( ) { $ variables = $ this -> _overrideObject ; if ( $ this -> _element !== null ) { foreach ( $ this -> _element -> attributes ( ) as $ name ) if ( $ name !== $ this -> _handle ) $ variables [ $ name ] = $ this -> _element -> $ name ; $ variables = array_merge ( $ variables , $ this -> _element -> toArray ( $ this -> _element -> extraFields ( ) ) ) ; } return $ variables ; }
3437	public function refreshFields ( ) { if ( $ this -> id === null ) { $ this -> original = [ ] ; return $ this -> fields = [ ] ; } $ sectionsBackup = isset ( $ this -> fields [ 'IBLOCK_SECTION' ] ) ? $ this -> fields [ 'IBLOCK_SECTION' ] : null ; $ this -> fields = static :: query ( ) -> getById ( $ this -> id ) -> fields ; if ( ! empty ( $ sectionsBackup ) ) { $ this -> fields [ 'IBLOCK_SECTION' ] = $ sectionsBackup ; } $ this -> fieldsAreFetched = true ; $ this -> original = $ this -> fields ; return $ this -> fields ; }
3964	private function getJsonFile ( $ filename ) { if ( ! is_readable ( $ filename ) ) { return [ ] ; } $ contents = json_decode ( file_get_contents ( $ filename ) , true ) ; return $ contents ? : [ ] ; }
7556	function getChildrenByAttribute ( $ attribute , $ value , $ mode = 'equals' , $ compare = 'total' , $ recursive = true ) { if ( $ this -> childCount ( ) < 1 ) { return array ( ) ; } $ mode = explode ( ' ' , strtolower ( $ mode ) ) ; $ match = ( ( isset ( $ mode [ 1 ] ) && ( $ mode [ 1 ] === 'not' ) ) ? 'false' : 'true' ) ; return $ this -> getChildrenByMatch ( array ( 'attributes' => array ( $ attribute => array ( 'operator_value' => $ mode [ 0 ] , 'value' => $ value , 'match' => $ match , 'compare' => $ compare ) ) ) , $ recursive ) ; }
11937	protected function find ( $ params ) { $ debug = false ; $ q = new Query ( ) ; $ q -> select ( '*' ) ; $ q -> from ( $ this -> _tableName ) ; foreach ( $ params as $ k => $ v ) { if ( $ k === 'join' ) { foreach ( $ v as $ join ) { if ( ! isset ( $ join [ 'type' ] ) ) { $ join [ 'type' ] = 'INNER JOIN' ; } if ( ! isset ( $ join [ 'params' ] ) ) { $ join [ 'params' ] = [ ] ; } $ q -> join ( $ join [ 'type' ] , $ join [ 'table' ] , $ join [ 'on' ] , $ join [ 'params' ] ) ; } $ debug = true ; } elseif ( in_array ( $ k , [ 'where' ] ) ) { $ q -> { $ k } ( $ v ) ; } else { $ q -> { $ k } = $ v ; } } if ( $ debug ) { } return $ q ; }
5699	public function findActionByName ( $ action ) { $ actions = $ this -> owner -> getBetterButtonsActions ( ) ; $ formAction = false ; foreach ( $ actions as $ f ) { if ( $ formAction ) { break ; } if ( $ f instanceof CompositeField ) { $ formAction = $ f -> fieldByName ( $ action ) ; } elseif ( $ f -> getName ( ) === $ action ) { $ formAction = $ f ; } } if ( ! $ formAction ) { $ utils = $ this -> owner -> getBetterButtonsUtils ( ) ; $ formAction = $ utils -> fieldByName ( $ action ) ; } return $ formAction ; }
6366	public function compound ( Comparator $ secondaryComparator ) : Ordering { return Ordering :: from ( Collections :: comparatorFrom ( function ( $ object1 , $ object2 ) use ( $ secondaryComparator ) { $ res = $ this -> compare ( $ object1 , $ object2 ) ; return $ res !== 0 ? $ res : $ secondaryComparator -> compare ( $ object1 , $ object2 ) ; } ) ) ; }
2457	public function deleteChilds ( $ table , $ id , & $ delete ) { $ cctable = array ( ) ; $ ctable = $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'ctable' ] ; if ( ! \ is_array ( $ ctable ) ) { return ; } foreach ( $ ctable as $ v ) { $ this -> loadDataContainer ( $ v ) ; $ cctable [ $ v ] = $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'ctable' ] ; if ( $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'dynamicPtable' ] ) { $ ptable = $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'ptable' ] ; $ cond = ( $ ptable == 'tl_article' ) ? "(ptable=? OR ptable='')" : "ptable=?" ; $ objDelete = $ this -> Database -> prepare ( "SELECT id FROM $v WHERE pid=? AND $cond" ) -> execute ( $ id , $ ptable ) ; } else { $ objDelete = $ this -> Database -> prepare ( "SELECT id FROM $v WHERE pid=?" ) -> execute ( $ id ) ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'doNotDeleteRecords' ] && \ strlen ( $ v ) && $ objDelete -> numRows ) { foreach ( $ objDelete -> fetchAllAssoc ( ) as $ row ) { $ delete [ $ v ] [ ] = $ row [ 'id' ] ; if ( ! empty ( $ cctable [ $ v ] ) ) { $ this -> deleteChilds ( $ v , $ row [ 'id' ] , $ delete ) ; } } } } }
8178	protected function sendMail ( $ to , $ subject , $ view , $ params = [ ] ) { $ mailer = Yii :: $ app -> mailer ; $ mailer -> viewPath = '@abhimanyu/user/views/mail' ; return $ mailer -> compose ( [ 'html' => $ view , 'text' => 'text/' . $ view ] , $ params ) -> setTo ( $ to ) -> setFrom ( Yii :: $ app -> config -> get ( 'mail.username' ) , 'no@reply.com' ) -> setSubject ( $ subject ) -> send ( ) ; }
11793	public function setCc ( $ mail = '' , $ name = null ) { $ this -> cc = Helper :: deduplicate ( array_merge ( $ this -> cc , call_user_func_array ( array ( '\MimeMailer\Helper' , 'checkPeopleArgs' ) , func_get_args ( ) ) ) ) ; return $ this ; }
3625	public function getDevices ( $ type = DEVICE_TYPE_THERMOSTAT ) { $ this -> prepareForGet ( ) ; if ( $ type == DEVICE_TYPE_PROTECT ) { $ protects = array ( ) ; $ topaz = isset ( $ this -> last_status -> topaz ) ? $ this -> last_status -> topaz : array ( ) ; foreach ( $ topaz as $ protect ) { $ protects [ ] = $ protect -> serial_number ; } return $ protects ; } $ devices_serials = array ( ) ; foreach ( $ this -> last_status -> user -> { $ this -> userid } -> structures as $ structure ) { list ( , $ structure_id ) = explode ( '.' , $ structure ) ; foreach ( $ this -> last_status -> structure -> { $ structure_id } -> devices as $ device ) { list ( , $ device_serial ) = explode ( '.' , $ device ) ; $ devices_serials [ ] = $ device_serial ; } } return $ devices_serials ; }
2989	public function setLogger ( LoggerInterface $ logger ) { if ( $ this -> transport instanceof LoggerAwareInterface ) { $ this -> transport -> setLogger ( $ logger ) ; } }
7120	protected function getFindBySubjectAndSupplierQuery ( ) { if ( null !== $ this -> findBySubjectAndSupplierQuery ) { return $ this -> findBySubjectAndSupplierQuery ; } $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; return $ this -> findBySubjectAndSupplierQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( $ this -> getAlias ( ) . '.supplier' , ':supplier' ) ) -> getQuery ( ) ; }
8393	public static function run ( ) { if ( self :: $ isInit === true ) { self :: $ request = new Request ( self :: $ routes ) ; self :: $ controllers = array ( ) ; try { $ before = self :: $ request -> getBefore ( ) ; foreach ( $ before as $ b ) { $ controller = Controllers :: get ( $ b [ 'class' ] ) ; $ action = $ b [ 'action' ] ; $ controller -> $ action ( self :: $ request ) ; } if ( self :: $ request -> hasEnded ( ) === false ) { $ controller = Controllers :: get ( self :: $ request -> getClass ( ) ) ; $ action = self :: $ request -> getAction ( ) ; $ controller -> $ action ( self :: $ request ) ; if ( self :: $ request -> hasEnded ( ) === false ) { $ after = self :: $ request -> getAfter ( ) ; foreach ( $ after as $ a ) { $ controller = Controllers :: get ( $ a [ 'class' ] ) ; $ action = $ a [ 'action' ] ; $ controller -> $ action ( self :: $ request ) ; } } } } catch ( \ Exception $ e ) { echo 'Exception: ' . $ e -> getMessage ( ) . PHP_EOL ; echo $ e -> getTraceAsString ( ) ; } } }
6753	public static function installWebServer ( ) { $ appPath = __DIR__ . '/../../../..' ; self :: createFolderIfNotExists ( "$appPath/web" ) ; self :: createCopy ( __DIR__ , 'app.php' , "$appPath/web" , 'app.php' ) ; self :: createCopy ( __DIR__ , 'app_dev.php' , "$appPath/web" , 'app_dev.php' ) ; }
8471	public function critical ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'critical' , $ scope , $ message , $ context , $ config ) ; }
11998	static public function generatePhalcon ( $ modelName , $ field , $ length = 16 ) { do { $ generate = self :: generate ( $ length ) ; } while ( self :: phalconQuery ( $ modelName , $ field , $ generate ) ) ; return $ generate ; }
3076	public function processInput ( QtiRunnerServiceContext $ context , array $ input ) { $ responses = [ ] ; foreach ( $ input as $ data ) { if ( ! is_array ( $ data ) || ! isset ( $ data [ 'channel' ] ) || ! isset ( $ data [ 'message' ] ) ) { throw new \ common_exception_InconsistentData ( 'Wrong message chunk received by the bidirectional communication service: either channel or message content is missing!' ) ; } if ( $ this -> hasChannel ( $ data [ 'channel' ] , self :: CHANNEL_TYPE_INPUT ) ) { $ channel = $ this -> getChannel ( $ data [ 'channel' ] , self :: CHANNEL_TYPE_INPUT ) ; $ responses [ ] = $ this -> processChannel ( $ channel , $ context , $ data [ 'message' ] ) ; } else { $ responses [ ] = $ this -> fallback ( $ data [ 'channel' ] , $ context , $ data [ 'message' ] ) ; } } return $ responses ; }
5509	public function expect ( $ method , $ args , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected arguments' ) ; $ this -> checkArgumentsIsArray ( $ args , 'set expected arguments' ) ; $ this -> expectations -> expectArguments ( $ method , $ args , $ message ) ; $ args = $ this -> replaceWildcards ( $ args ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args [ strtolower ( $ method ) ] = new ParametersExpectation ( $ args , $ message ) ; }
7903	protected function dynamicUploadTo ( $ uploadTo ) { $ disk = Str :: snake ( substr ( $ uploadTo , 8 ) ) ; return $ this -> uploadTo ( $ disk ) ; }
877	private function skipClass ( Tokens $ tokens , $ classIndex , $ classOpenIndex , $ classCloseIndex ) { $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ classIndex ) ] ; if ( ! $ prevToken -> isGivenKind ( T_FINAL ) ) { return true ; } for ( $ index = $ classIndex ; $ index < $ classOpenIndex ; ++ $ index ) { if ( $ tokens [ $ index ] -> isGivenKind ( T_EXTENDS ) ) { return true ; } } $ useIndex = $ tokens -> getNextTokenOfKind ( $ classIndex , [ [ CT :: T_USE_TRAIT ] ] ) ; return $ useIndex && $ useIndex < $ classCloseIndex ; }
5396	public function paintSkip ( $ message ) { parent :: paintSkip ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'skip>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "skip>\n" ; }
6275	protected function read ( $ start , $ len ) { $ end = $ start + $ len ; if ( $ end <= 2048 ) { return substr ( $ this -> index , $ start , $ len ) ; } $ bytes = '' ; if ( $ this -> buf && $ start >= $ this -> bufStart ) { $ bytes .= substr ( $ this -> buf , $ start - $ this -> bufStart , $ len ) ; $ bytesRead = strlen ( $ bytes ) ; $ len -= $ bytesRead ; $ start += $ bytesRead ; } else { $ bytesRead = 0 ; } if ( ! $ len ) { return $ bytes ; } if ( $ start !== $ this -> filePos ) { if ( fseek ( $ this -> handle , $ start ) === - 1 ) { throw new Exception ( 'Seek failed, file "' . $ this -> fileName . '" may be corrupted.' ) ; } } $ buf = fread ( $ this -> handle , max ( $ len , 1024 ) ) ; if ( $ buf === false ) { $ buf = '' ; } $ bytes .= substr ( $ buf , 0 , $ len ) ; if ( strlen ( $ bytes ) !== $ len + $ bytesRead ) { throw new Exception ( 'Read from CDB file failed, file "' . $ this -> fileName . '" may be corrupted.' ) ; } $ this -> filePos = $ end ; $ this -> bufStart = $ start ; $ this -> buf = $ buf ; return $ bytes ; }
4991	public function getEntity ( $ key = '*' ) { return isset ( $ this -> entities [ $ key ] ) ? $ this -> entities [ $ key ] : null ; }
7695	function MsPowerpoint_InitSlideLst ( $ Master = false ) { if ( $ Master ) { $ RefLst = & $ this -> OpenXmlSlideMasterLst ; } else { $ RefLst = & $ this -> OpenXmlSlideLst ; } if ( $ RefLst !== false ) return $ RefLst ; $ PresFile = 'ppt/presentation.xml' ; $ prefix = ( $ Master ) ? 'slideMasters/' : 'slides/' ; $ o = $ this -> OpenXML_Rels_GetObj ( 'ppt/presentation.xml' , $ prefix ) ; $ Txt = $ this -> FileRead ( $ PresFile ) ; if ( $ Txt === false ) return false ; $ p = 0 ; $ i = 0 ; $ lst = array ( ) ; $ tag = ( $ Master ) ? 'p:sldMasterId' : 'p:sldId' ; while ( $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , $ tag , $ p ) ) { $ i ++ ; $ rid = $ loc -> GetAttLazy ( 'r:id' ) ; if ( $ rid === false ) { $ this -> RaiseError ( "(Init Slide List) attribute 'r:id' is missing for slide #$i in '$PresFile'." ) ; } elseif ( isset ( $ o -> TargetLst [ $ rid ] ) ) { $ f = 'ppt/' . $ o -> TargetLst [ $ rid ] ; $ lst [ ] = array ( 'file' => $ f , 'idx' => $ this -> FileGetIdx ( $ f ) , 'rid' => $ rid ) ; } else { $ this -> RaiseError ( "(Init Slide List) Slide corresponding to rid=$rid is not found in the Rels file of '$PresFile'." ) ; } $ p = $ loc -> PosEnd ; } $ RefLst = $ lst ; return $ RefLst ; }
10680	protected function generateURLSegment ( $ title ) { $ filter = URLSegmentFilter :: create ( ) ; $ t = $ filter -> filter ( $ title ) ; if ( ! $ t || $ t == '-' || $ t == '-1' ) { $ t = "{$this->owner->ClassName}-{$this->owner->ID}" ; } else { $ class = $ this -> owner -> ClassName ; $ obj = $ class :: get ( ) -> filter ( array ( "URLSegment" => $ t ) ) -> exclude ( array ( "ID" => $ this -> owner -> ID ) ) -> first ( ) ; if ( $ obj ) { $ t .= "-{$this->owner->ID}" ; } } return $ t ; }
5085	protected function buildUrl ( $ iTotal , $ iPage , $ iPageOffset ) { $ aParams = [ 'page' => $ iPage + $ iPageOffset , ] ; if ( $ aParams [ 'page' ] <= 0 ) { return null ; } elseif ( $ aParams [ 'page' ] === 1 ) { unset ( $ aParams [ 'page' ] ) ; } $ iTotalPages = ceil ( $ iTotal / static :: CONFIG_PER_PAGE ) ; if ( ! empty ( $ aParams [ 'page' ] ) && $ aParams [ 'page' ] > $ iTotalPages ) { return null ; } $ sUrl = site_url ( ) . uri_string ( ) ; if ( ! empty ( $ aParams ) ) { $ sUrl .= '?' . http_build_query ( $ aParams ) ; } return $ sUrl ; }
11385	public static function signUrlForGoogle ( string $ sUrlToSign , string $ sClientId , string $ sPrivateKey ) : string { $ aUrl = parse_url ( $ sUrlToSign ) ; $ aUrl [ 'query' ] .= '&client=' . $ sClientId ; $ aUrlToSign = $ aUrl [ 'path' ] . "?" . $ aUrl [ 'query' ] ; $ decodedKey = base64_decode ( str_replace ( array ( '-' , '_' ) , array ( '+' , '/' ) , $ sPrivateKey ) ) ; $ sSignature = hash_hmac ( "sha1" , $ aUrlToSign , $ decodedKey , true ) ; $ sEncodedSignature = str_replace ( array ( '+' , '/' ) , array ( '-' , '_' ) , base64_encode ( $ sSignature ) ) ; $ sOriginalUrl = $ aUrl [ 'scheme' ] . "://" . $ aUrl [ 'host' ] . $ aUrl [ 'path' ] . "?" . $ aUrl [ 'query' ] ; return $ sOriginalUrl . '&signature=' . $ sEncodedSignature ; }
10192	public static function parseDsn ( $ string = null ) { $ opts = null ; if ( ! empty ( $ string ) ) { $ dsn = ( object ) DsnParser :: parseUrl ( $ string ) -> toArray ( ) ; $ opts = [ 'driver' => $ dsn -> driver , 'host' => $ dsn -> host , 'database' => $ dsn -> dbname , 'username' => $ dsn -> user , 'password' => isset ( $ dsn -> pass ) ? $ dsn -> pass : null ] ; } return $ opts ; }
12529	public function getForeignDataSource ( $ foreignModelClass ) { foreach ( $ this -> dataSources as $ dataSource ) { if ( $ dataSource -> foreignModel -> modelName === $ foreignModelClass ) { return $ dataSource ; } } return false ; }
9114	public function init ( ) { $ this -> registerController ( \ Nkey \ Caribu \ Mvc \ Controller \ ErrorController :: class ) ; $ this -> registerView ( \ Nkey \ Caribu \ Mvc \ View \ DefaultView :: class ) ; }
3603	public function createJsonResponseFromException ( \ Exception $ exception , JsonRequest $ jsonRequest = null ) { $ jsonResponse = new JsonResponse ( ) ; if ( $ exception instanceof Exceptions \ ErrorException ) { $ jsonResponse -> setErrorCode ( 0 !== $ exception -> getCode ( ) ? $ exception -> getCode ( ) : - 32603 ) ; $ jsonResponse -> setErrorMessage ( ! empty ( $ exception -> getMessage ( ) ) ? $ exception -> getMessage ( ) : 'Internal error' ) ; $ jsonResponse -> setErrorData ( $ exception -> getData ( ) ) ; } else { $ jsonResponse -> setErrorCode ( 0 !== $ exception -> getCode ( ) ? $ exception -> getCode ( ) : - 32603 ) ; $ jsonResponse -> setErrorMessage ( ! empty ( $ exception -> getMessage ( ) ) ? $ exception -> getMessage ( ) : 'Internal error' ) ; } if ( $ jsonRequest ) { $ jsonResponse -> setId ( $ jsonRequest -> getId ( ) ) ; } return $ jsonResponse ; }
10048	public function getColourByIndex ( $ index ) { if ( isset ( $ this -> colourMap [ $ index ] ) ) { return $ this -> colourMap [ $ index ] ; } return null ; }
4657	public function run ( Job $ job , $ command ) { if ( is_string ( $ command ) ) { $ command = [ '/bin/bash' , '-c' , $ command ] ; } $ image = $ this -> docker -> getImageManager ( ) -> find ( $ job -> getName ( ) ) ; $ hostConfig = new HostConfig ( ) ; $ config = new ContainerConfig ( ) ; $ config -> setCmd ( $ command ) ; $ config -> setImage ( $ image -> getId ( ) ) ; $ config -> setHostConfig ( $ hostConfig ) ; $ config -> setLabels ( new \ ArrayObject ( [ 'com.jolici.container=true' ] ) ) ; $ config -> setAttachStderr ( true ) ; $ config -> setAttachStdout ( true ) ; $ links = [ ] ; foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { $ serviceContainer = $ this -> docker -> getContainerManager ( ) -> find ( $ service -> getContainer ( ) ) ; $ links [ ] = sprintf ( '%s:%s' , $ serviceContainer -> getName ( ) , $ service -> getName ( ) ) ; } } $ hostConfig -> setLinks ( $ links ) ; $ containerCreateResult = $ this -> docker -> getContainerManager ( ) -> create ( $ config ) ; $ attachStream = $ this -> docker -> getContainerManager ( ) -> attach ( $ containerCreateResult -> getId ( ) , [ 'stream' => true , 'stdout' => true , 'stderr' => true , ] , ContainerManager :: FETCH_STREAM ) ; $ attachStream -> onStdout ( $ this -> logger -> getRunStdoutCallback ( ) ) ; $ attachStream -> onStderr ( $ this -> logger -> getRunStderrCallback ( ) ) ; $ this -> docker -> getContainerManager ( ) -> start ( $ containerCreateResult -> getId ( ) ) ; $ attachStream -> wait ( ) ; $ containerWait = $ this -> docker -> getContainerManager ( ) -> wait ( $ containerCreateResult -> getId ( ) ) ; return $ containerWait -> getStatusCode ( ) ; }
9435	public function theta ( $ float_min , $ float_max ) { self :: checkOrder ( $ float_min , $ float_max ) ; if ( $ this -> r || $ this -> i ) { throw new \ RuntimeException ( 'You cannot set theta value, because algebraic form is in use.' ) ; } $ this -> theta = new \ stdClass ( ) ; $ this -> theta -> min = $ float_min ; $ this -> theta -> max = $ float_max ; return $ this ; }
2024	public static function findByAliases ( $ arrAliases , array $ arrOptions = array ( ) ) { if ( empty ( $ arrAliases ) || ! \ is_array ( $ arrAliases ) ) { return null ; } $ arrAliases = array_filter ( array_map ( function ( $ v ) { return preg_match ( '/^[\w\/.-]+$/u' , $ v ) ? $ v : null ; } , $ arrAliases ) ) ; if ( empty ( $ arrAliases ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.alias IN('" . implode ( "','" , array_filter ( $ arrAliases ) ) . "')" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.alias" , $ arrAliases ) ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
3678	public function generateAjax ( $ folder , $ strField , $ level , $ mount = false ) { return parent :: generateAjax ( $ folder , $ this -> strField , $ level , $ mount ) ; }
9209	protected function findKey ( Table $ Table , Entity $ entity ) { if ( ! empty ( $ entity -> { $ Table -> primaryKey ( ) } ) ) { $ key = $ entity -> { $ Table -> primaryKey ( ) } ; } else { $ key = 'unknown' ; } return $ key ; }
7835	protected function getWorkflowsNamespace ( ) { $ relative = ltrim ( config ( 'workflow.path' ) , app_path ( ) ) ; $ chunks = array_map ( 'ucfirst' , explode ( '/' , $ relative ) ) ; return implode ( '\\' , $ chunks ) ; }
9859	public function getStream ( $ stream ) { if ( $ stream === null ) { return null ; } $ streamData = '' ; if ( $ this -> props [ $ stream ] [ 'size' ] < self :: SMALL_BLOCK_THRESHOLD ) { $ rootdata = $ this -> _readData ( $ this -> props [ $ this -> rootentry ] [ 'startBlock' ] ) ; $ block = $ this -> props [ $ stream ] [ 'startBlock' ] ; while ( $ block != - 2 ) { $ pos = $ block * self :: SMALL_BLOCK_SIZE ; $ streamData .= substr ( $ rootdata , $ pos , self :: SMALL_BLOCK_SIZE ) ; $ block = self :: getInt4d ( $ this -> smallBlockChain , $ block * 4 ) ; } return $ streamData ; } $ numBlocks = $ this -> props [ $ stream ] [ 'size' ] / self :: BIG_BLOCK_SIZE ; if ( $ this -> props [ $ stream ] [ 'size' ] % self :: BIG_BLOCK_SIZE != 0 ) { ++ $ numBlocks ; } if ( $ numBlocks == 0 ) { return '' ; } $ block = $ this -> props [ $ stream ] [ 'startBlock' ] ; while ( $ block != - 2 ) { $ pos = ( $ block + 1 ) * self :: BIG_BLOCK_SIZE ; $ streamData .= substr ( $ this -> data , $ pos , self :: BIG_BLOCK_SIZE ) ; $ block = self :: getInt4d ( $ this -> bigBlockChain , $ block * 4 ) ; } return $ streamData ; }
12619	protected function loadForeignDataItems ( ) { if ( ! $ this -> fileSource ) { \ d ( "boom" ) ; return false ; } $ foreignModelClass = $ this -> foreignModelClass ; $ lines = $ this -> fileSource -> getLines ( $ this -> lazyForeign ) ; $ lineCount = 0 ; foreach ( $ lines as $ id => $ line ) { if ( $ this -> lazyForeign ) { $ this -> createForeignDataItem ( null , [ 'deferredModel' => $ line ] ) ; } else { $ model = $ this -> createModel ( $ line -> id , $ line -> attributes ) ; $ this -> createForeignDataItem ( $ model , [ 'deferredModel' => $ line ] ) ; } $ lineCount ++ ; } $ this -> task -> addInfo ( "Processed {$lineCount} lines from {$this->fileSource->id}" ) ; }
2135	public static function preload ( ) { include __DIR__ . '/../../config/default.php' ; include __DIR__ . '/../../config/agents.php' ; include __DIR__ . '/../../config/mimetypes.php' ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ( $ blnHasLcf = file_exists ( $ rootDir . '/system/config/localconfig.php' ) ) === true ) { include $ rootDir . '/system/config/localconfig.php' ; } static :: loadParameters ( ) ; static :: $ blnHasLcf = $ blnHasLcf ; }
10089	function addAttachmentFromBase64Data ( $ filename , $ mimetype , $ contents ) { $ attachment = new Attachment ( $ filename , $ mimetype , $ contents ) ; $ this -> attachments [ ] = $ attachment ; }
9223	public function unserialize ( $ data ) { $ _data = unserialize ( $ data ) ; $ this -> page = $ _data [ 'page' ] ; $ this -> key = $ _data [ 'key' ] ; $ this -> data = $ _data [ 'data' ] ; $ this -> api = null ; $ this -> endpoint = null ; $ this -> pagination = array ( ) ; }
8350	public function perform ( array $ args = [ ] ) : int { $ transport = new Swift_SmtpTransport ( $ args [ 'smtp' ] [ 'host' ] , $ args [ 'smtp' ] [ 'port' ] ) ; $ transport -> setUsername ( $ args [ 'smtp' ] [ 'username' ] ) ; $ transport -> setPassword ( $ args [ 'smtp' ] [ 'password' ] ) ; $ mailer = new Swift_Mailer ( $ transport ) ; $ message = ( new Swift_Message ( $ args [ 'subject' ] ) ) -> setFrom ( [ $ args [ 'from' ] [ 'email' ] => $ args [ 'from' ] [ 'email' ] ] ) -> setTo ( [ $ args [ 'to' ] [ 'email' ] => $ args [ 'to' ] [ 'name' ] ] ) -> setBody ( $ args [ 'message' ] ) ; $ result = $ mailer -> send ( $ message ) ; return $ result === 1 ; }
7363	protected function updatePaymentTotal ( SaleInterface $ sale ) { $ changed = false ; $ currency = $ sale -> getCurrency ( ) -> getCode ( ) ; $ paid = $ this -> paymentCalculator -> calculatePaidTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ paid , $ sale -> getPaidTotal ( ) , $ currency ) ) { $ sale -> setPaidTotal ( $ paid ) ; $ changed = true ; } $ pending = $ this -> paymentCalculator -> calculateOfflinePendingTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ pending , $ sale -> getPendingTotal ( ) , $ currency ) ) { $ sale -> setPendingTotal ( $ pending ) ; $ changed = true ; } $ acceptedOutstanding = $ this -> paymentCalculator -> calculateOutstandingAcceptedTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ acceptedOutstanding , $ sale -> getOutstandingAccepted ( ) , $ currency ) ) { $ sale -> setOutstandingAccepted ( $ acceptedOutstanding ) ; $ changed = true ; } $ expiredOutstanding = $ this -> paymentCalculator -> calculateOutstandingExpiredTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ expiredOutstanding , $ sale -> getOutstandingExpired ( ) , $ currency ) ) { $ sale -> setOutstandingExpired ( $ expiredOutstanding ) ; $ changed = true ; } if ( $ changed && $ this -> outstandingReleaser -> releaseFund ( $ sale ) ) { $ sale -> setOutstandingAccepted ( $ this -> paymentCalculator -> calculateOutstandingAcceptedTotal ( $ sale ) ) ; $ sale -> setOutstandingExpired ( $ this -> paymentCalculator -> calculateOutstandingExpiredTotal ( $ sale ) ) ; } return $ changed ; }
3755	public function sameModels ( $ objModel1 , $ objModel2 ) { if ( ! ( $ objModel1 instanceof Model && $ objModel2 instanceof Model ) ) { throw new \ InvalidArgumentException ( 'Passed models are not valid.' ) ; } $ objNative1 = $ objModel1 -> getItem ( ) ; $ objNative2 = $ objModel2 -> getItem ( ) ; if ( $ objNative1 -> getMetaModel ( ) === $ objNative2 -> getMetaModel ( ) ) { return true ; } foreach ( $ objNative1 -> getMetaModel ( ) -> getAttributes ( ) as $ objAttribute ) { if ( $ objNative1 -> get ( $ objAttribute -> getColName ( ) ) != $ objNative2 -> get ( $ objAttribute -> getColName ( ) ) ) { return false ; } } return true ; }
9042	private function emptyEnvironment ( ) { foreach ( array_keys ( $ _ENV ) as $ key ) { putenv ( $ key ) ; unset ( $ _ENV [ $ key ] ) ; unset ( $ _SERVER [ $ key ] ) ; } }
1151	protected function getViewData ( ) { $ this -> validator -> setRemote ( $ this -> remote ) ; $ data = $ this -> validator -> validationData ( ) ; $ data [ 'selector' ] = $ this -> selector ; if ( ! is_null ( $ this -> ignore ) ) { $ data [ 'ignore' ] = $ this -> ignore ; } return $ data ; }
11306	public static function getDataFromId ( $ id ) { $ db = Neuron_Core_Database :: __getInstance ( ) ; $ id = intval ( $ id ) ; $ r = $ db -> getDataFromQuery ( $ db -> customQuery ( " SELECT * FROM n_players WHERE n_players.plid = '" . $ id . "' " ) ) ; if ( count ( $ r ) == 1 ) { return $ r [ 0 ] ; } return null ; }
6084	public function uploadNewVersion ( $ id , $ pathname , $ revisionComment , $ filename = null , $ progress = null , $ chunkSize = 10485760 ) { $ chunk = 0 ; $ chunksTotal = ceil ( filesize ( $ pathname ) / $ chunkSize ) ; $ fileId = sha1 ( uniqid ( 'uploadVersion' , true ) ) ; $ filename = $ filename ? : pathinfo ( $ filename , PATHINFO_BASENAME ) ; $ fp = fopen ( $ pathname , 'r' ) ; if ( false === $ fp ) { throw new UploadException ( 'Could not open file "' . $ pathname . '" for reading.' ) ; } if ( $ chunkSize > 10485760 ) { $ this -> logger -> warning ( 'Using a chunk size larger then 10MB is not recommended. Uploading is not guaranteed to work properly.' ) ; } while ( $ chunkData = fread ( $ fp , $ chunkSize ) ) { $ result = $ this -> uploadNewVersionChunked ( $ chunkData , $ id , $ revisionComment , $ filename , $ chunk , $ chunksTotal , $ fileId ) ; if ( is_callable ( $ progress ) ) { try { call_user_func ( $ progress , $ chunk + 1 , $ chunksTotal ) ; } catch ( \ Exception $ e ) { $ this -> logger -> warning ( 'Could not report progress due to callback error.' , [ 'message' => $ e -> getMessage ( ) ] ) ; } } $ this -> logger -> info ( 'Upload progress!' , [ 'part' => $ chunk + 1 , 'total' => $ chunksTotal ] ) ; if ( isset ( $ result [ 'mediaId' ] ) ) { return new MediaResponse ( $ result ) ; } if ( isset ( $ result [ 'success' ] ) && false == $ result [ 'success' ] ) { throw new UploadException ( $ result [ 'error' ] [ 'message' ] , $ result [ 'error' ] [ 'code' ] ) ; } $ fileId = $ result [ 'fileId' ] ; ++ $ chunk ; } if ( $ chunk == $ chunksTotal - 1 ) { throw new UploadException ( 'Uploaded all chunks, but something went wrong.' ) ; } if ( false === $ chunkData ) { throw new UploadException ( 'Could not read chunk ' . $ chunk . ' from file "' . $ pathname . '".' ) ; } throw new UploadException ( 'Unknown upload error!' ) ; }
12420	public function dt ( $ domain , $ singular ) { $ singular = ( string ) $ singular ; try { $ locale = $ this -> getLocale ( ) ; foreach ( $ this -> getTranslations ( $ domain ) as $ object ) { if ( ( $ string = $ object -> translate ( $ singular , $ domain , $ locale ) ) != $ singular ) { return $ string ; } } } catch ( \ Exception $ e ) { ; } return ( string ) $ singular ; }
5964	public function channelGroupGetById ( $ cgid ) { if ( ! array_key_exists ( ( string ) $ cgid , $ this -> channelGroupList ( ) ) ) { throw new Ts3Exception ( "invalid groupID" , 0xA00 ) ; } return $ this -> cgroupList [ intval ( ( string ) $ cgid ) ] ; }
8591	public function setStatus ( $ status ) { if ( ! $ this -> isNumericArray ( $ status ) ) { $ status = array ( $ status ) ; } $ this -> fields [ 'Status' ] [ 'FieldValue' ] = $ status ; return $ this ; }
7580	protected function verifyUrl ( ) { $ UrlArray = explode ( "?" , $ this -> Url ) ; if ( strpos ( $ UrlArray [ 0 ] , "$" ) !== false ) { throw new InvalidURLException ( get_called_class ( ) , "Configured URL is " . $ this -> Url ) ; } return true ; }
2799	public static function generate ( $ mutantFile = null , $ bootstrap = '' , $ replacingFile = null ) { $ loadHumbug = '' ; if ( 'phar:' === substr ( __FILE__ , 0 , 5 ) ) { $ loadHumbug = '\Phar::loadPhar(\'' . str_replace ( 'phar://' , '' , \ Phar :: running ( ) ) . '\', \'humbug.phar\');' ; $ humbugBootstrap = 'phar://humbug.phar' . '/bootstrap.php' ; } else { $ humbugBootstrap = realpath ( __DIR__ . '/../../../bootstrap.php' ) ; } $ file = sys_get_temp_dir ( ) . '/humbug.phpunit.bootstrap.php' ; if ( ! is_null ( $ mutantFile ) ) { $ mutantFile = addslashes ( $ mutantFile ) ; $ replacingFile = addslashes ( $ replacingFile ) ; $ prepend = <<<PREPEND<?php{$loadHumbug}require_once '{$humbugBootstrap}';use Humbug\StreamWrapper\IncludeInterceptor;IncludeInterceptor::intercept('{$replacingFile}', '{$mutantFile}');IncludeInterceptor::enable();PREPEND ; if ( ! empty ( $ bootstrap ) ) { $ buffer = $ prepend . "\nrequire_once '{$bootstrap}';" ; } else { $ buffer = $ prepend ; } file_put_contents ( $ file , $ buffer ) ; } else { if ( ! empty ( $ bootstrap ) ) { $ buffer = "<?php\n{$loadHumbug}\nrequire_once '{$humbugBootstrap}';\nrequire_once '{$bootstrap}';" ; } else { $ buffer = "<?php\n{$loadHumbug}\nrequire_once '{$humbugBootstrap}';" ; } file_put_contents ( $ file , $ buffer ) ; } }
5986	public function getTokens ( ) { $ tokens = [ 'accessToken' => null , 'refreshToken' => null ] ; if ( $ this -> oauth2Middleware instanceof OAuthMiddleware ) { $ tokens [ 'accessToken' ] = $ this -> oauth2Middleware -> getAccessToken ( ) ; $ tokens [ 'refreshToken' ] = $ this -> oauth2Middleware -> getRefreshToken ( ) ; } if ( $ this -> cache instanceof Cache && empty ( $ tokens [ 'accessToken' ] ) && $ this -> cache -> contains ( 'oauth2accesstoken' ) ) { $ tokens [ 'accessToken' ] = unserialize ( $ this -> cache -> fetch ( 'oauth2accesstoken' ) ) ; } if ( $ this -> cache instanceof Cache && empty ( $ tokens [ 'accessToken' ] ) && $ this -> cache -> contains ( 'oauth2refreshtoken' ) ) { $ tokens [ 'refreshToken' ] = unserialize ( $ this -> cache -> fetch ( 'oauth2refreshtoken' ) ) ; } if ( empty ( $ tokens [ 'accessToken' ] ) ) { $ response = $ this -> getClient ( ) -> get ( '/' ) ; $ tokens [ 'accessToken' ] = $ this -> oauth2Middleware -> getAccessToken ( ) ; $ tokens [ 'refreshToken' ] = $ this -> oauth2Middleware -> getRefreshToken ( ) ; } return $ tokens ; }
8043	public function onProcessCreate ( Semaphore $ semaphore ) { $ this -> semaphore = $ semaphore ; $ this -> create -> __invoke ( $ this -> semaphore , $ this -> storage ) ; }
810	private function toComparableNames ( array $ types , array $ symbolShortNames ) { $ normalized = array_map ( function ( $ type ) use ( $ symbolShortNames ) { $ type = strtolower ( $ type ) ; if ( isset ( $ symbolShortNames [ $ type ] ) ) { return $ symbolShortNames [ $ type ] ; } return $ type ; } , $ types ) ; sort ( $ normalized ) ; return $ normalized ; }
8440	public function createAction ( string $ production_slug , Request $ request , TokenStorageInterface $ token , AuthorizationCheckerInterface $ auth ) : Response { $ production_repo = $ this -> em -> getRepository ( Production :: class ) ; if ( null === $ production = $ production_repo -> findOneBy ( [ 'slug' => $ production_slug ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ auth -> isGranted ( 'GROUP_ROLE_USER' , $ production ) ) { throw new AccessDeniedException ( ) ; } $ user = $ token -> getToken ( ) -> getUser ( ) ; $ post = new Post ( ) ; $ post -> setActive ( true ) ; $ post -> setPinned ( false ) ; $ post -> setAuthor ( $ user -> getUsername ( ) ) ; $ post -> addGroup ( $ production ) ; if ( $ request -> query -> has ( 'reply-to' ) ) { $ repo = $ this -> em -> getRepository ( Post :: class ) ; if ( null === $ parent = $ repo -> findOneBy ( [ 'id' => $ request -> query -> get ( 'reply-to' ) ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ parent -> getGroups ( ) -> contains ( $ production ) ) { throw new AccessDeniedException ( ) ; } if ( null !== $ parent -> getParent ( ) ) { throw new AccessDeniedException ( ) ; } $ post -> setParent ( $ parent ) ; $ form = $ this -> form -> create ( ReplyType :: class , $ post ) ; } else { $ form = $ this -> form -> create ( PostType :: class , $ post ) ; } $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> em -> persist ( $ post ) ; $ this -> em -> flush ( ) ; $ this -> session -> getFlashBag ( ) -> add ( 'success' , $ this -> translator -> trans ( 'post.created' , [ ] , BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ) ) ; return new RedirectResponse ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) ] ) ) ; } return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Post/create.html.twig' , [ 'form' => $ form -> createView ( ) , 'post' => $ post , 'production' => $ production , ] ) ) ; }
5141	public function run ( ) : void { $ request = $ request = ServerRequestFactory :: fromGlobals ( ) ; $ response = $ this -> process ( $ request ) ; $ emitter = $ this -> getContainer ( ) -> has ( EmitterInterface :: class ) ? $ this -> getContainer ( ) -> get ( EmitterInterface :: class ) : new SapiEmitter ( ) ; $ emitter -> emit ( $ response ) ; }
4077	protected function getPaletteCombinationRows ( ) { $ combinations = $ this -> getCombinationsFromDatabase ( ) ; $ success = array ( ) ; if ( ! $ combinations ) { return array_keys ( $ this -> information ) ; } foreach ( $ combinations as $ combination ) { $ modelId = $ combination -> pid ; $ modelName = $ this -> tableNameFromId ( $ modelId ) ; if ( ! empty ( $ this -> information [ $ modelName ] [ self :: COMBINATION ] ) ) { continue ; } $ this -> information [ $ modelName ] [ self :: MODELID ] = $ modelId ; $ this -> information [ $ modelName ] [ self :: COMBINATION ] = array ( 'dca_id' => $ combination -> dca_id , 'view_id' => $ combination -> view_id ) ; $ this -> setTableMapping ( $ modelId , $ modelName ) ; $ success [ ] = $ modelId ; } return $ success ; }
11255	public function call ( string $ class ) : void { $ files = $ this -> all ( $ class ) ; if ( count ( $ files ) < 1 ) { throw InvalidArgumentException :: forNotFoundSeeder ( ) ; } foreach ( $ files as [ $ file , $ content ] ) { $ this -> load ( $ content ) ; $ this -> resolve ( $ file [ 'filename' ] ) -> run ( ) ; } }
12836	public function makeDirectory ( $ path , $ mode = 0755 , $ recursive = false ) { if ( ! file_exists ( $ path ) ) { return mkdir ( $ path , $ mode , $ recursive ) ; } return true ; }
8523	public function setAdvertisingRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'AdvertisingRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9307	public function setJsonApiSecurityHash ( $ jsonApiSecurityHash ) { if ( ! is_string ( $ jsonApiSecurityHash ) ) { throw new \ InvalidArgumentException ( '`jsonApiSecurityHash` expects string value!' ) ; } $ this -> options [ 'jsonApiSecurityHash' ] = ( string ) $ jsonApiSecurityHash ; return $ this ; }
10122	private function writePrintHeaders ( ) { $ record = 0x002a ; $ length = 0x0002 ; $ fPrintRwCol = $ this -> printHeaders ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fPrintRwCol ) ; $ this -> append ( $ header . $ data ) ; }
960	public function handle ( Request $ request , Closure $ next ) { if ( Config :: get ( 'shopify-app.billing_enabled' ) === true ) { $ shop = ShopifyApp :: shop ( ) ; if ( ! $ shop -> isFreemium ( ) && ! $ shop -> isGrandfathered ( ) && ! $ shop -> plan ) { return Redirect :: route ( 'billing' ) ; } } return $ next ( $ request ) ; }
9342	public function populate ( $ arrAll ) { $ this -> arr = array_chunk ( $ arrAll , $ this -> size -> cols ) ; return $ this ; }
12838	static public function dir ( $ directory , $ date = false ) { if ( $ date ) { $ directory = rtrim ( $ directory , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . self :: getDateDirectory ( ) ; } if ( ! is_dir ( $ directory ) ) { $ umask = umask ( 0000 ) ; if ( @ mkdir ( $ directory , 0777 , true ) === false ) { throw new Exception ( sprintf ( 'Directory "%s" cannot be created.' , $ directory ) ) ; } umask ( $ umask ) ; } return $ directory ; }
9647	public function whateverMatches ( string $ param ) : RouteBuilder { if ( array_key_exists ( $ param , $ this -> matchers ) ) { unset ( $ this -> matchers [ $ param ] ) ; } return $ this ; }
128	protected function getPackageBasePath ( PackageInterface $ package ) { $ installPath = $ this -> getInstallPath ( $ package ) ; $ targetDir = $ package -> getTargetDir ( ) ; if ( $ targetDir ) { return preg_replace ( '{/*' . str_replace ( '/' , '/+' , preg_quote ( $ targetDir ) ) . '/?$}' , '' , $ installPath ) ; } return $ installPath ; }
11597	public static function setCacheType ( string $ sCacheName ) { if ( $ sCacheName === 'file' ) { self :: $ _sTypeOfCache = 'file' ; } else if ( $ sCacheName === 'memcache' ) { self :: $ _sTypeOfCache = 'memcache' ; } else if ( $ sCacheName === 'apc' ) { self :: $ _sTypeOfCache = 'apc' ; } else if ( $ sCacheName === 'redis' ) { self :: $ _sTypeOfCache = 'redis' ; } else { self :: $ _sTypeOfCache = 'mock' ; } }
6859	protected static function solsticeDecember ( $ year , $ vsop = true ) { $ month = 12 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
8862	public function getYearlyArchiveLink ( ) { $ date = $ this -> dbObject ( "PublishDate" ) ; return Controller :: join_links ( $ this -> Parent ( ) -> Link ( "archive" ) , $ date -> format ( "Y" ) ) ; }
10842	protected function refreshProductSellPrices ( ProductInterface $ product ) { $ sellPrice = $ product -> getSellPrice ( ) ; $ grossAmount = $ sellPrice -> getGrossAmount ( ) ; $ discountedGrossAmount = $ sellPrice -> getDiscountedGrossAmount ( ) ; $ taxRate = $ product -> getSellPriceTax ( ) -> getValue ( ) ; $ netAmount = TaxHelper :: calculateNetPrice ( $ grossAmount , $ taxRate ) ; $ discountedNetAmount = TaxHelper :: calculateNetPrice ( $ discountedGrossAmount , $ taxRate ) ; $ sellPrice -> setTaxRate ( $ taxRate ) ; $ sellPrice -> setTaxAmount ( $ grossAmount - $ netAmount ) ; $ sellPrice -> setNetAmount ( $ netAmount ) ; $ sellPrice -> setDiscountedTaxAmount ( $ discountedGrossAmount - $ discountedNetAmount ) ; $ sellPrice -> setDiscountedNetAmount ( $ discountedNetAmount ) ; }
5519	protected function emulateCall ( $ method , $ args , $ step ) { return $ this -> actions -> respond ( $ step , $ method , $ args ) ; }
4773	public function order ( Request $ request , WidgetInterface $ widget , string $ widgetId , int $ order ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; $ widgetConfig -> addWidgetConfig ( $ widgetId , [ 'order' => $ order ] ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; } return $ this -> json ( [ 'result' => 'success' , ] ) ; }
7542	function typeIndex ( ) { if ( ! $ this -> parent ) { return - 1 ; } else { $ index = - 1 ; foreach ( array_keys ( $ this -> parent -> children ) as $ k ) { if ( strcasecmp ( $ this -> tag , $ this -> parent -> children [ $ k ] -> tag ) === 0 ) { ++ $ index ; } if ( $ this -> parent -> children [ $ k ] === $ this ) { return $ index ; } } return - 1 ; } }
7351	public function isPaid ( ) { return 0 <= Money :: compare ( $ this -> paidTotal , $ this -> grandTotal , $ this -> getCurrency ( ) -> getCode ( ) ) ; }
12019	function addProperties ( ) { $ requiredProperties = [ 'api' => '\\' . $ this -> apiClassname , 'parameters' => 'array' , 'response' => '\Amp\Artax\Response' , 'originalResponse' => '\Amp\Artax\Response' , ] ; foreach ( $ requiredProperties as $ propertyName => $ typehint ) { $ propertyGenerator = new PropertyGenerator ( $ propertyName , null ) ; $ docBlock = new DocBlockGenerator ( '@var ' . $ typehint ) ; $ propertyGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addPropertyFromGenerator ( $ propertyGenerator ) ; } $ docBlock = new DocBlockGenerator ( 'Get the last response.' ) ; $ body = 'return $this->response;' ; $ methodGenerator = $ this -> createMethodGenerator ( 'getResponse' , $ body , $ docBlock , [ ] , '\Amp\Artax\Response' ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; $ docBlock = new DocBlockGenerator ( 'Set the last response. This should only be used by the API class when the operation has been dispatched. Storing the response is required as some APIs store out-of-bound information in the headers e.g. rate-limit info, pagination that is not really part of the operation.' ) ; $ body = '$this->response = $response;' ; $ methodGenerator = $ this -> createMethodGenerator ( 'setResponse' , $ body , $ docBlock , [ [ 'response' , 'Amp\Artax\Response' ] ] ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
1021	public function toSerializableArray ( ) { $ arr = [ 'message' => $ this -> getMessage ( ) , ] ; $ locations = Utils :: map ( $ this -> getLocations ( ) , static function ( SourceLocation $ loc ) { return $ loc -> toSerializableArray ( ) ; } ) ; if ( ! empty ( $ locations ) ) { $ arr [ 'locations' ] = $ locations ; } if ( ! empty ( $ this -> path ) ) { $ arr [ 'path' ] = $ this -> path ; } if ( ! empty ( $ this -> extensions ) ) { $ arr [ 'extensions' ] = $ this -> extensions ; } return $ arr ; }
10902	public function loadRelation ( string $ name ) { if ( ! isset ( $ this -> relationObjects [ $ name ] ) || empty ( $ this -> relationObjects [ $ name ] ) ) { $ relation = $ this -> getRelations ( ) [ $ name ] ; if ( ! $ relation || ! $ relation [ 'entity' ] || ! $ this -> get ( $ relation [ 'key' ] ?? 'id' ) ) { return null ; } $ entity = $ this -> entity ( $ relation [ 'entity' ] ) ; $ type = $ relation [ 'type' ] ?? 'has_one' ; $ key = $ relation [ 'key' ] ?? ( 'has_one' === $ type ? $ this -> __getEntityName ( ) . '_id' : 'id' ) ; $ foreignKey = $ relation [ 'foreign_key' ] ?? ( 'has_one' === $ type ? 'id' : $ this -> __getEntityName ( ) . '_id' ) ; $ assoc = $ relation [ 'assoc' ] ?? false ; $ this -> relationObjects [ $ name ] = ( 'has_one' === $ type ) ? $ entity -> load ( $ this -> get ( $ key ) , $ foreignKey ) : $ entity -> loadAll ( [ $ foreignKey => $ this -> get ( $ key ) ] , $ assoc ) ; } return $ this -> relationObjects [ $ name ] ?? null ; }
2473	public function indexContent ( Content $ content ) { $ this -> gateway -> bulkIndexDocuments ( array ( $ this -> mapper -> mapContentBlock ( $ content ) ) ) ; }
10818	public static function error ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'error' , $ length , $ separator ) ; }
5605	public function paintMethodEnd ( $ method ) { if ( $ this -> fail || $ this -> error || ! $ this -> pass ) { } else { $ this -> listener -> write ( '{status:"pass",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
12024	private function addConstructorMethod ( ) { $ requiredParameters = $ this -> operationDefinition -> getRequiredParams ( ) ; $ methodGenerator = new MethodGenerator ( '__construct' ) ; $ defaultParams = $ this -> operationDefinition -> getDefaultParams ( ) ; $ body = '' ; if ( count ( $ defaultParams ) ) { $ body = '$defaultParams = [' . PHP_EOL ; foreach ( $ defaultParams as $ param ) { $ body .= sprintf ( " '%s' => '%s'," , $ param -> getName ( ) , $ param -> getDefault ( ) ) ; $ body .= PHP_EOL ; } $ body .= '];' . PHP_EOL ; $ body .= '$this->setParams($defaultParams);' . PHP_EOL ; } $ constructorParams = [ ] ; $ constructorParams [ ] = new ParameterGenerator ( 'api' , $ this -> apiGenerator -> getFQCN ( ) ) ; $ body .= '$this->api = $api;' . PHP_EOL ; foreach ( $ requiredParameters as $ param ) { $ normalizedParamName = normalizeParamName ( $ param -> getName ( ) ) ; $ constructorParams [ ] = new ParameterGenerator ( $ normalizedParamName , $ param -> getType ( ) ) ; $ body .= sprintf ( "\$this->parameters['%s'] = $%s;" . PHP_EOL , $ param -> getName ( ) , $ normalizedParamName ) ; } $ methodGenerator -> setParameters ( $ constructorParams ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
7791	public function setClosingBalanceClass ( $ closingBalanceClass ) { if ( ! is_callable ( $ closingBalanceClass ) && ! class_exists ( $ closingBalanceClass ) ) { throw new \ InvalidArgumentException ( '$closingBalanceClass must be a valid classname or a PHP callable' ) ; } $ this -> closingBalanceClass = $ closingBalanceClass ; return $ this ; }
9358	public function getModulePath ( $ moduleName ) { if ( array_key_exists ( $ moduleName , $ this -> loadedModules ) ) { $ module = $ this -> loadedModules [ $ moduleName ] ; $ moduleConfig = $ module -> getAutoloaderConfig ( ) ; return $ moduleConfig [ self :: STANDARD_AUTOLOLOADER ] [ self :: NAMESPACE_KEY ] [ $ moduleName ] ; } return null ; }
8715	public function getAccessToken ( ) : ApiAccessToken { try { $ accessToken = $ this -> tokenStorage -> getAccessToken ( ) ; } catch ( UnableToAcquireAccessToken $ e ) { $ accessToken = null ; } if ( $ accessToken && $ accessToken -> isExpired ( ) ) { $ this -> tokenStorage -> unsetAccessToken ( ) ; $ accessToken = null ; } return $ accessToken ? : $ this -> refreshToken ( ) ; }
12433	private function getMaxPercentForInfinityBonus ( $ cfgParams , $ scheme ) { $ result = 0 ; $ params = $ cfgParams [ $ scheme ] ; foreach ( $ params as $ item ) { $ percent = $ item -> getInfinity ( ) ; if ( $ percent > $ result ) { $ result = $ percent ; } } return $ result ; }
1855	public static function findUpcomingByPids ( $ arrIds , $ intLimit = 0 , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; $ arrColumns = array ( "($t.endTime>=$time OR ($t.recurring='1' AND ($t.recurrences=0 OR $t.repeatEnd>=$time))) AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ") AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ) ; if ( $ intLimit > 0 ) { $ arrOptions [ 'limit' ] = $ intLimit ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.startTime" ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
10906	public function remove ( ) : bool { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE | \ sndsgd \ Fs :: WRITABLE ) === false ) { $ this -> error = "failed to remove directory; {$this->error}" ; return false ; } foreach ( $ this -> getList ( ) as $ entity ) { if ( $ entity -> remove ( ) === false ) { $ this -> error = $ entity -> getError ( ) ; return false ; } } if ( @ rmdir ( $ this -> path ) === false ) { $ this -> setError ( "failed to remove directory '{$this->path}'" ) ; return false ; } return true ; }
10254	public function getStreet ( ) { $ number = rand ( 100 , 9999 ) ; $ street_name = Street :: orderByRaw ( Database :: random ( ) ) -> first ( ) -> name ; return $ number . ' ' . $ street_name ; }
10349	public function validateArgSet ( $ set ) { if ( isset ( $ set ) ) { foreach ( $ set as $ arg ) { if ( ! isset ( $ this -> { $ arg } ) ) { throw new \ Exception ( 'Response not valid: ' . $ arg . ' has not been set!' ) ; } } } }
11071	public function setInteger ( string $ key , $ value , int $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( int ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
9921	private function findManyToManyRelations ( array $ models ) { for ( $ i = 0 ; $ i < sizeof ( $ models ) ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < sizeof ( $ models ) ; $ j ++ ) { $ model1 = $ models [ $ i ] ; $ model2 = $ models [ $ j ] ; if ( strcasecmp ( $ model1 -> getName ( ) , $ model2 -> getName ( ) ) < 0 ) { $ tableName = strtolower ( $ model1 -> getName ( ) ) . '_' . strtolower ( $ model2 -> getName ( ) ) ; } else { $ tableName = strtolower ( $ model2 -> getName ( ) ) . '_' . strtolower ( $ model1 -> getName ( ) ) ; } if ( $ this -> databaseRepository -> hasTable ( $ tableName ) ) { $ this -> defineManyToManyRelation ( $ model1 , $ model2 ) ; } } } }
3556	public function setMetaGroup ( $ group = null ) { if ( ! preg_match ( '/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/' , $ group ) && $ group !== null ) { throw new InvalidArgumentException ( "Provided group [{$group}] is not valid variable name." ) ; } $ this -> attributes [ 'meta_group' ] = $ group ; }
11236	public function url ( $ url = null , $ append = '' ) { unset ( $ _POST ) ; unset ( $ _FILES ) ; header ( 'location: ' . $ this -> getRedirect ( $ url ) . $ append ) ; exit ; }
823	private function getPreviousUnsetCall ( Tokens $ tokens , $ index ) { $ previousUnsetSemicolon = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( null === $ previousUnsetSemicolon ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetSemicolon ] -> equals ( ';' ) ) { return $ previousUnsetSemicolon ; } $ previousUnsetBraceEnd = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetSemicolon ) ; if ( null === $ previousUnsetBraceEnd ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetBraceEnd ] -> equals ( ')' ) ) { return $ previousUnsetBraceEnd ; } $ previousUnsetBraceStart = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ previousUnsetBraceEnd ) ; $ previousUnset = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetBraceStart ) ; if ( null === $ previousUnset ) { return $ index ; } if ( ! $ tokens [ $ previousUnset ] -> isGivenKind ( T_UNSET ) ) { return $ previousUnset ; } return [ $ previousUnset , $ previousUnsetBraceStart , $ previousUnsetBraceEnd , $ previousUnsetSemicolon , ] ; }
9596	public function makeSession ( ) { $ session = new Session ( $ this -> dic -> resolve ( 'Symfony\Component\HttpFoundation\Session\Storage\SessionStorageInterface' ) , $ this -> dic -> resolve ( 'Symfony\Component\HttpFoundation\Session\Attribute\AttributeBagInterface' ) , $ this -> dic -> resolve ( 'Symfony\Component\HttpFoundation\Session\Flash\FlashBagInterface' ) ) ; $ session -> setName ( $ this -> config -> get ( 'session.cookie.name' , 'autarky_session' ) ) ; return $ session ; }
7154	protected function match ( $ role , $ action ) : bool { $ roles = $ actions = [ '*' ] ; $ allow = false ; if ( $ role != '*' ) array_unshift ( $ roles , $ role ) ; if ( $ action != '*' ) array_unshift ( $ actions , $ action ) ; foreach ( $ roles as $ _role ) { foreach ( $ actions as $ _action ) { if ( isset ( $ this -> _rules [ $ _role ] [ $ _action ] ) ) { $ allow = $ this -> _rules [ $ _role ] [ $ _action ] ; break 2 ; } } } return $ allow === true ; }
10803	public function deletePageHistoricAction ( ) { $ responseData = $ this -> params ( ) -> fromRoute ( 'datas' , $ this -> params ( ) -> fromQuery ( 'datas' , '' ) ) ; $ idPage = $ responseData [ 0 ] [ 'idPage' ] ; $ response = array ( 'idPage' => $ idPage ) ; $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_delete_start' , $ this , $ response ) ; $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ melisCoreAuth = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreAuth' ) ; $ userId = ( int ) null ; $ userAuthDatas = $ melisCoreAuth -> getStorage ( ) -> read ( ) ; if ( $ userAuthDatas ) $ userId = $ userAuthDatas -> usr_id ; $ histDatas = array ( 'hist_page_id' => $ idPage , 'hist_action' => 'Delete' , 'hist_date' => date ( 'Y-m-d H:i:s' ) , 'hist_user_id' => $ userId , 'hist_description' => 'tr_melispagehistoric_action_text_Delete' ) ; $ melisPageHistoricTable -> save ( $ histDatas ) ; $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_delete_end' , $ this , $ responseData ) ; }
256	public function afterRun ( $ result ) { $ event = new WidgetEvent ( ) ; $ event -> result = $ result ; $ this -> trigger ( self :: EVENT_AFTER_RUN , $ event ) ; return $ event -> result ; }
3084	public function getAssessmentItemRefByIdentifiers ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , array $ identifiers ) { $ assessmentItemRefs = [ ] ; foreach ( $ identifiers as $ identifier ) { $ assessmentItemRefs [ ] = $ this -> getAssessmentItemRefByIdentifier ( $ privateCompilationDirectory , $ identifier ) ; } return $ assessmentItemRefs ; }
1342	public function getParameters ( ) : EncodingParametersInterface { if ( $ this -> parameters ) { return $ this -> parameters ; } return $ this -> parameters = $ this -> container -> make ( EncodingParametersInterface :: class ) ; }
2671	public function deleteDictionaryItem ( $ dictionaryId , $ itemKey ) { $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/item/' . urlencode ( $ itemKey ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; return $ result ; }
3500	public function withApnId ( ApnId $ apnId = null ) : Notification { $ cloned = clone $ this ; $ cloned -> apnId = $ apnId ; return $ cloned ; }
9597	protected function flashMessages ( $ messages ) { $ flashBag = $ this -> getSession ( ) -> getFlashBag ( ) ; foreach ( ( array ) $ messages as $ message ) { $ flashBag -> add ( '_messages' , $ message ) ; } }
12561	public function send ( $ msgType , $ message , $ to = null ) { $ message = ( new MessageBuilder ( ) ) -> msgType ( $ msgType ) -> message ( $ message ) -> to ( $ to ) -> build ( ) ; $ api = is_array ( $ to ) ? self :: API_SEND_BY_OPENID : self :: API_SEND_BY_GROUP ; return $ this -> post ( $ api , $ message ) ; }
10636	protected function resolvePaths ( array $ fixPaths ) { $ this -> rootDir = \ realpath ( isset ( $ fixPaths [ 'rootDir' ] ) ? $ fixPaths [ 'rootDir' ] : __DIR__ . '/../../../../' ) ; $ this -> packageDir = \ realpath ( isset ( $ fixPaths [ 'packageDir' ] ) ? $ fixPaths [ 'packageDir' ] : __DIR__ . '/../' ) ; $ this -> configPath = Utils :: fixPath ( isset ( $ fixPaths [ 'configPath' ] ) ? $ fixPaths [ 'configPath' ] : '/app/' ) ; if ( $ this -> rootDir === false || $ this -> packageDir === false ) throw new \ InvalidArgumentException ( 'Bootstrap directories do not exists or are not accessible' ) ; if ( $ this [ 'minion.usePropel' ] ) { $ this -> propelConfigPath = \ realpath ( isset ( $ fixPaths [ 'propelConfigPath' ] ) ? $ fixPaths [ 'propelConfigPath' ] : Utils :: fixPath ( $ this -> packageDir . '/propel.php' ) ) ; if ( $ this -> propelConfigPath === false ) throw new \ InvalidArgumentException ( 'Propel configuration file in vendor Minion not found' ) ; } }
9759	function contain ( $ value = null ) : self { if ( $ this -> hasFlag ( 'file' ) ) return $ this -> expect ( @ file_get_contents ( $ this -> target ) , stringContains ( $ value ) ) ; return $ this -> expect ( $ this -> target , is_string ( $ this -> target ) ? stringContains ( $ value ) : contains ( $ value ) ) ; }
4446	public function tagged ( string $ tag , int $ offset = 0 , int $ limit = 25 ) : array { $ response = json_decode ( $ this -> client -> call ( 'tag' , 'get' , $ tag , $ offset , $ limit ) , true ) ; if ( empty ( $ response [ 'jobs' ] ) ) { $ response [ 'jobs' ] = [ ] ; } return $ response [ 'jobs' ] ; }
7230	public function getMarginPercent ( ) { if ( 0 < $ this -> margin && 0 < $ this -> revenue ) { return round ( $ this -> margin * 100 / $ this -> revenue , 1 ) ; } return 0 ; }
7292	public function get_users_by_meta ( $ meta_key , $ meta_value = '' , $ meta_compare = '' , $ include_empty = FALSE ) { if ( $ include_empty ) { if ( in_array ( $ meta_compare , array ( '<>' , '!=' ) ) ) { $ meta_compare = '=' ; } else { $ meta_compare = '!=' ; } $ query = new WP_User_Query ( array ( 'meta_key' => $ meta_key , 'meta_value' => $ meta_value , 'meta_compare' => $ meta_compare , 'fields' => 'ID' ) ) ; $ exclude_users = $ query -> get_results ( ) ; $ query = new WP_User_Query ( array ( 'fields' => 'all_with_meta' , 'exclude' => $ exclude_users ) ) ; return $ query -> get_results ( ) ; } $ query = new WP_User_Query ( array ( 'meta_key' => $ meta_key , 'meta_value' => $ meta_value , 'meta_compare' => $ meta_compare , 'fields' => 'all_with_meta' ) ) ; return $ query -> get_results ( ) ; }
11722	public function getPosts ( $ limit = null , $ offset = null ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; if ( is_null ( $ limit ) && is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) ) ; } elseif ( is_null ( $ limit ) && ! is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) , $ limit ) ; } elseif ( ! is_null ( $ limit ) && ! is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) , $ limit , $ offset ) ; } return $ entities ; }
4741	private function createProfilerProbes ( $ name , ContainerBuilder $ container ) { $ key = sprintf ( "socloz_monitoring.profiler.probe.definition.%s" , $ name ) ; if ( $ container -> hasParameter ( $ key ) ) { $ definition = $ container -> getParameter ( $ key ) ; return array ( $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_CALLS | Probe :: TRACKER_TIMING , $ definition , $ container ) ) ; } else { return array ( $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_CALLS , $ container -> getParameter ( $ key . '.calls' ) , $ container ) , $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_TIMING , $ container -> getParameter ( $ key . '.timing' ) , $ container ) , ) ; } }
7458	public function background ( ) : Font { if ( $ this -> color !== null ) { $ this -> turnToBackground ( ) ; } $ this -> background = true ; return $ this ; }
1955	public function getStyleSheets ( Contao \ DataContainer $ dc ) { $ intPid = $ dc -> activeRecord -> pid ; if ( Contao \ Input :: get ( 'act' ) == 'overrideAll' ) { $ intPid = Contao \ Input :: get ( 'id' ) ; } $ objStyleSheet = $ this -> Database -> prepare ( "SELECT id, name FROM tl_style_sheet WHERE pid=?" ) -> execute ( $ intPid ) ; if ( $ objStyleSheet -> numRows < 1 ) { return array ( ) ; } $ return = array ( ) ; while ( $ objStyleSheet -> next ( ) ) { $ return [ $ objStyleSheet -> id ] = $ objStyleSheet -> name ; } return $ return ; }
4718	public function processStandardUrl ( Text $ text ) { $ hashes = array ( ) ; $ text -> replace ( '{<code>.*?</code>}m' , function ( Text $ w ) use ( & $ hashes ) { $ md5 = md5 ( $ w ) ; $ hashes [ $ md5 ] = $ w ; return "{gfm-extraction-$md5}" ; } ) ; $ text -> replace ( '{(?<!]\(|"|<|\[)((?:https?|ftp)://[^\'">\s]+)(?!>|\"|\])}' , '<\1>' ) ; $ text -> replace ( '/\{gfm-extraction-([0-9a-f]{32})\}/m' , function ( Text $ w , Text $ md5 ) use ( & $ hashes ) { return $ hashes [ ( string ) $ md5 ] ; } ) ; }
161	public function orHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'or' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
4508	public function decoded ( JWTDecodedEvent $ event ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! $ this -> accessor -> isReadable ( $ payload , $ this -> property ) ) { $ event -> markAsInvalid ( ) ; } elseif ( $ this -> validate && $ this -> accessor -> getValue ( $ payload , $ this -> property ) !== $ request -> getClientIp ( ) ) { $ event -> markAsInvalid ( ) ; } }
8260	protected function saveLoginInfo ( $ resourceOwner ) { $ u = new User ( ) ; $ u -> setAuthenticated ( true ) ; $ u -> setAuthenticator ( $ this -> getName ( ) ) ; $ attrMap = $ this -> providerConfig [ 'attributeMap' ] ; $ userIdAttr = $ attrMap [ 'userId' ] ; $ userId = $ this -> getResourceAttribute ( $ userIdAttr , $ resourceOwner ) ; $ u -> setId ( $ userId ) ; unset ( $ attrMap [ 'userId' ] ) ; if ( isset ( $ attrMap [ 'displayName' ] ) ) { $ name = $ this -> getResourceAttribute ( $ attrMap [ 'displayName' ] , $ resourceOwner ) ; $ u -> setDisplayName ( $ name ) ; unset ( $ attrMap [ 'displayName' ] ) ; } foreach ( $ attrMap as $ mapKey => $ mapValue ) { $ value = $ this -> getResourceAttribute ( $ mapValue , $ resourceOwner ) ; $ u -> setAttribute ( $ mapKey , $ value ) ; } $ u -> setGroups ( $ this -> providerConfig [ 'default' ] [ 'groups' ] ) ; foreach ( $ this -> providerConfig [ 'default' ] [ 'attributes' ] as $ key => $ value ) { if ( null === $ u -> getAttribute ( $ key ) ) { $ u -> setAttribute ( $ key , $ value ) ; } } $ this -> picoAuth -> setUser ( $ u ) ; $ this -> picoAuth -> afterLogin ( ) ; }
11567	public function set ( string $ sNameOfDi , callable $ cFunction , bool $ bShared = false ) : Di { if ( $ bShared === true ) { self :: $ _aSharedDependencyInjectorContener [ md5 ( $ sNameOfDi ) ] = $ cFunction ; } else { $ this -> _aDependencyInjectorContener [ md5 ( $ sNameOfDi ) ] = $ cFunction ; } return $ this ; }
169	public static function unlink ( $ path ) { $ isWindows = DIRECTORY_SEPARATOR === '\\' ; if ( ! $ isWindows ) { return unlink ( $ path ) ; } if ( is_link ( $ path ) && is_dir ( $ path ) ) { return rmdir ( $ path ) ; } try { return unlink ( $ path ) ; } catch ( ErrorException $ e ) { if ( function_exists ( 'exec' ) && file_exists ( $ path ) ) { exec ( 'DEL /F/Q ' . escapeshellarg ( $ path ) ) ; return ! file_exists ( $ path ) ; } return false ; } }
8997	public function isEmpty ( $ filter = null ) : bool { if ( ! $ this -> exists ( ) ) { throw new DirectoryException ( "Directory {dir} does not exist" , array ( 'dir' => $ this -> path ) ) ; } $ iter = new \ DirectoryIterator ( $ this -> path ) ; while ( $ iter -> valid ( ) ) { if ( ! $ iter -> isDot ( ) && ( $ filter === null || ! preg_match ( "/$filter/" , $ iter -> getFilename ( ) ) ) ) { return false ; } $ iter -> next ( ) ; } return true ; }
1179	protected function getValidationData ( array $ rules , array $ customAttributes = [ ] ) { $ attributes = array_filter ( array_keys ( $ rules ) , function ( $ attribute ) { return $ attribute !== '' && mb_strpos ( $ attribute , '*' ) !== false ; } ) ; $ attributes = array_merge ( array_keys ( $ customAttributes ) , $ attributes ) ; $ data = array_reduce ( $ attributes , function ( $ data , $ attribute ) { Arr :: set ( $ data , $ attribute , true ) ; return $ data ; } , [ ] ) ; return $ data ; }
3266	public function getPath ( ) : string { return $ this -> config -> getDir ( ) . $ this -> getName ( ) . $ this -> config -> getExt ( ) ; }
2539	protected function executeMethodOnSoapClientForMsg ( $ msgName , $ method ) { $ result = null ; $ soapClient = $ this -> getSoapClient ( $ msgName ) ; if ( $ soapClient instanceof \ SoapClient ) { $ result = $ soapClient -> $ method ( ) ; } return $ result ; }
311	private function applyTableAlias ( $ query , $ conditions , $ alias = null ) { if ( $ alias === null ) { $ alias = array_keys ( $ query -> getTablesUsedInFrom ( ) ) [ 0 ] ; } $ prefixedConditions = [ ] ; foreach ( $ conditions as $ columnName => $ columnValue ) { if ( strpos ( $ columnName , '(' ) === false ) { $ columnName = preg_replace ( '/^' . preg_quote ( $ alias ) . '\.(.*)$/' , '$1' , $ columnName ) ; if ( strpos ( $ columnName , '[[' ) === 0 ) { $ prefixedColumn = "{$alias}.{$columnName}" ; } else { $ prefixedColumn = "{$alias}.[[{$columnName}]]" ; } } else { $ prefixedColumn = $ columnName ; } $ prefixedConditions [ $ prefixedColumn ] = $ columnValue ; } return $ prefixedConditions ; }
5831	public function sendRequest ( Request $ request ) { $ this -> prepareRequest ( $ request ) ; $ result = curl_exec ( $ this -> ch ) ; if ( $ result === false ) { throw new \ RuntimeException ( "cURL request failed with error: " . curl_error ( $ this -> ch ) ) ; } $ response = $ this -> createResponseObject ( $ result ) ; curl_close ( $ this -> ch ) ; return $ response ; }
2101	public static function getNumericDatimFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> datimFormat != '' && static :: isNumericFormat ( $ objPage -> datimFormat ) ) { return $ objPage -> datimFormat ; } } return Config :: get ( 'datimFormat' ) ; }
12534	public function pagination ( $ lastSeen , $ count ) { $ params = [ 'type' => 2 , 'last_seen' => intval ( $ lastSeen ) , 'count' => intval ( $ count ) , ] ; return $ this -> fetch ( $ params ) ; }
8782	protected function finish ( $ output = null ) { if ( ! is_null ( $ output ) ) { $ file = fopen ( $ this -> file , 'w+' ) ; fwrite ( $ file , $ output ) ; fclose ( $ file ) ; return $ output ; } return false ; }
6299	public function addToBar ( array $ item , $ name = 'default' , $ first = false ) { if ( ! array_key_exists ( $ name , $ this -> bar ) ) { $ this -> bar [ $ name ] = [ ] ; } if ( $ first ) { $ this -> bar [ $ name ] = array_merge ( [ $ item ] , $ this -> bar [ $ name ] ) ; } else { $ this -> bar [ $ name ] [ ] = $ item ; } return $ this ; }
11187	public static function get ( array $ arr , $ k , $ default = null ) { if ( isset ( $ arr [ $ k ] ) ) return $ arr [ $ k ] ; $ nested = explode ( '.' , $ k ) ; foreach ( $ nested as $ part ) { if ( isset ( $ arr [ $ part ] ) ) { $ arr = $ arr [ $ part ] ; continue ; } else { $ arr = $ default ; break ; } } return $ arr ; }
12567	public function sendCard ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_CARD , $ message , $ to ) ; }
2449	public function editComment ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> isAllowedToEditComment ( $ row [ 'parent' ] , $ row [ 'source' ] ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg/i' , '_.svg' , $ icon ) ) . ' ' ; }
10647	private function buildMessages ( $ scope = 'create' ) { $ custom_messages = $ this -> messages [ 'global' ] ; foreach ( $ this -> messages [ $ scope ] as $ key => $ value ) { $ custom_messages [ $ key ] = $ value ; } return $ custom_messages ; }
6389	public function readFacetofaceSession ( $ id ) { $ model = $ this -> readObject ( $ id , 'facetoface_sessions' ) ; $ model -> dates = $ this -> readStoreRecords ( 'facetoface_sessions_dates' , [ 'sessionid' => $ id ] ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/facetoface/signup.php?s=' . $ id ; return $ model ; }
10054	public function setDataValues ( $ dataValues ) { $ this -> dataValues = Functions :: flattenArray ( $ dataValues ) ; $ this -> pointCount = count ( $ dataValues ) ; return $ this ; }
477	public function renameTable ( $ table , $ newName ) { $ time = $ this -> beginCommand ( "rename table $table to $newName" ) ; $ this -> db -> createCommand ( ) -> renameTable ( $ table , $ newName ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
603	protected function startsWithAnyLongest ( array & $ with , $ caseSensitive , & $ length = null , & $ content = null ) { if ( empty ( $ with ) ) { return false ; } if ( ! is_array ( reset ( $ with ) ) ) { usort ( $ with , function ( $ string1 , $ string2 ) { return mb_strlen ( $ string2 , 'UTF-8' ) - mb_strlen ( $ string1 , 'UTF-8' ) ; } ) ; $ map = [ ] ; foreach ( $ with as $ string ) { $ map [ mb_strlen ( $ string , 'UTF-8' ) ] [ $ caseSensitive ? $ string : mb_strtoupper ( $ string , 'UTF-8' ) ] = true ; } $ with = $ map ; } foreach ( $ with as $ testLength => $ testValues ) { $ content = $ this -> substring ( $ testLength , $ caseSensitive ) ; if ( isset ( $ testValues [ $ content ] ) ) { $ length = $ testLength ; return true ; } } return false ; }
8561	public function cancelShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_CancelShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CancelShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_CancelShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CancelShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CancelShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_CancelShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11067	protected function compileMixins ( ) { $ sql = array ( ) ; foreach ( $ this -> mixins as $ mixin ) { $ compiled = $ this -> { $ mixin } -> compile ( ) ; if ( $ compiled !== "" ) { $ sql [ ] = $ compiled ; } } return $ sql ; }
3871	protected function getLanguage ( $ singleLanguage , $ metaModels ) { if ( ! empty ( $ singleLanguage ) ) { return array ( $ singleLanguage ) ; } elseif ( $ metaModels -> isTranslated ( ) && $ metaModels -> getAvailableLanguages ( ) ) { return $ metaModels -> getAvailableLanguages ( ) ; } return array ( $ GLOBALS [ 'TL_LANGUAGE' ] ) ; }
1497	public function push ( Encoding ... $ encodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ encodings ) -> all ( ) ; return $ copy ; }
7069	static function isValid ( $ unit , $ throw = false ) { if ( in_array ( $ unit , static :: getUnits ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Invalid unit '$unit'." ) ; } return false ; }
6051	public function listFolders ( $ root = 0 , $ depth = 0 , $ includeProperties = true , $ includeObjectCounts = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'root' => $ root , 'depth' => $ depth , 'includeProperties' => $ includeProperties , 'includeObjectCounts' => $ includeObjectCounts ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FolderResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
3081	protected function buildOptions ( RunnerServiceContext $ context ) { $ session = $ context -> getTestSession ( ) ; $ options = [ 'allowComment' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowComment ( $ session ) , 'allowSkipping' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowSkipping ( $ session ) , 'exitButton' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowExit ( $ session , $ context ) , 'logoutButton' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowLogout ( $ session ) , 'validateResponses' => \ taoQtiTest_helpers_TestRunnerUtils :: doesValidateResponses ( $ session ) , 'sectionPause' => $ this -> getServiceManager ( ) -> get ( SectionPauseService :: SERVICE_ID ) -> couldBePaused ( $ session ) ] ; $ categories = $ this -> getCategories ( $ context ) ; $ prefixCategory = 'x-tao-option-' ; $ prefixCategoryLen = strlen ( $ prefixCategory ) ; foreach ( $ categories as $ category ) { if ( ! strncmp ( $ category , $ prefixCategory , $ prefixCategoryLen ) ) { $ optionName = lcfirst ( str_replace ( ' ' , '' , ucwords ( strtr ( substr ( $ category , $ prefixCategoryLen ) , [ '-' => ' ' , '_' => ' ' ] ) ) ) ) ; $ options [ $ optionName ] = true ; } } return $ options ; }
2113	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'articlenav' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } global $ objPage ; $ this -> objArticles = ArticleModel :: findPublishedWithTeaserByPidAndColumn ( $ objPage -> id , $ this -> strColumn ) ; if ( $ this -> objArticles === null ) { return '' ; } if ( ! Input :: get ( 'articles' ) ) { if ( ! $ this -> loadFirst ) { return '' ; } $ objArticle = $ this -> objArticles -> current ( ) ; $ strAlias = $ objArticle -> alias ? : $ objArticle -> id ; $ this -> redirect ( $ objPage -> getFrontendUrl ( '/articles/' . $ strAlias ) ) ; } return parent :: generate ( ) ; }
8860	public function onBeforePublish ( ) { if ( $ this -> dbObject ( 'PublishDate' ) -> InPast ( ) && ! $ this -> isPublished ( ) ) { $ this -> setCastedField ( "PublishDate" , time ( ) ) ; $ this -> write ( ) ; } }
11755	public function markElect ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MARK_ELECT , $ params ] ) ; }
3228	function doGet ( $ host , $ path , $ params = null ) { Checker :: argString ( "host" , $ host ) ; Checker :: argString ( "path" , $ path ) ; return RequestUtil :: doGet ( $ this -> clientIdentifier , $ this -> accessToken , $ this -> userLocale , $ host , $ path , $ params ) ; }
9076	public function addTag ( $ name , array $ attributes = array ( ) ) { foreach ( $ this -> rules as $ rule ) { $ rule -> addTag ( $ name , $ attributes ) ; } }
10687	private function setCreatePermissions ( ) { if ( $ this -> config -> has ( 'io' , 'group' ) ) Path :: setDefaultFileGroup ( $ this -> config -> get ( 'io' , 'group' ) ) ; $ file_mode = ( int ) $ this -> config -> get ( 'io' , 'file_mode' ) ; if ( $ file_mode ) { $ of = $ file_mode ; $ file_mode = octdec ( sprintf ( "%04d" , $ file_mode ) ) ; Path :: setDefaultFileMode ( $ file_mode ) ; } $ dir_mode = ( int ) $ this -> config -> get ( 'io' , 'dir_mode' ) ; if ( $ dir_mode ) { $ of = $ dir_mode ; $ dir_mode = octdec ( sprintf ( "%04d" , $ dir_mode ) ) ; Path :: setDefaultDirMode ( $ dir_mode ) ; } }
1617	public function column ( $ column , $ db = null ) { if ( $ this -> emulateExecution ) { return [ ] ; } return $ this -> executeScript ( $ db , 'Column' , $ column ) ; }
5039	public function set ( $ key , ImageInterface $ image , $ check = true ) { $ images = $ this -> getImages ( ) ; if ( $ check && ( $ img = $ this -> get ( $ key ) ) ) { $ images -> removeElement ( $ img ) ; } $ image -> setBelongsTo ( $ this -> id ) ; $ image -> setKey ( $ key ) ; $ images -> add ( $ image ) ; return $ this ; }
4027	protected function getLabelComment ( ModelInterface $ model , TranslatorInterface $ translator ) { if ( $ model -> getProperty ( 'comment' ) ) { return sprintf ( $ translator -> translate ( 'typedesc._comment_' , 'tl_metamodel_filtersetting' ) , StringUtil :: specialchars ( $ model -> getProperty ( 'comment' ) ) ) ; } return '' ; }
9293	protected function getAssetsUrl ( ) { if ( ! isset ( $ this -> _assetsUrl ) ) { $ path = dirname ( __FILE__ ) . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'assets' ; $ this -> _assetsUrl = Yii :: app ( ) -> assetManager -> publish ( $ path , false , - 1 , $ this -> forceCopyAssets ) ; } return $ this -> _assetsUrl ; }
10081	protected function registerManager ( ) { $ this -> app -> singleton ( 'auja' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; return new Auja ( $ app , $ app [ 'auja.configurator' ] , $ config [ 'models' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Auja' , 'auja' ) ; }
11540	protected function resolveAddOptions ( array $ options ) { if ( $ this -> optionsResolved ) { return ; } $ this -> optionsResolver -> clear ( ) ; $ this -> optionsResolver -> setRequired ( array ( 'page' , 'language' , 'country' , 'slot' , 'blockname' , 'type' , 'position' , 'direction' , ) ) ; $ this -> optionsResolver -> resolve ( $ options ) ; $ this -> optionsResolved = true ; }
4416	public function onKernelResponse ( FilterResponseEvent $ event ) { $ routeName = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; if ( $ routeName !== FallbackRouter :: ROUTE_NAME ) { return ; } $ response = $ event -> getResponse ( ) ; if ( ! $ response instanceof LegacyResponse ) { return ; } if ( ! $ this -> legacyMode && ( int ) $ response -> getStatusCode ( ) === Response :: HTTP_NOT_FOUND ) { $ moduleResult = $ response -> getModuleResult ( ) ; $ exception = new NotFoundHttpException ( isset ( $ moduleResult [ 'errorMessage' ] ) ? $ moduleResult [ 'errorMessage' ] : 'Not Found' ) ; $ exception -> setOriginalResponse ( $ response ) ; throw $ exception ; } }
4692	public function andHaving ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> having = $ this -> having ? '(' . $ this -> having . ') AND (' . $ expression . ')' : $ expression ; $ this -> pushArgs ( 'having' , $ args ) ; return $ this ; }
2517	public function pnrAddMultiElements ( RequestOptions \ PnrAddMultiElementsOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_AddMultiElements' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
9666	private function writeFill ( XMLWriter $ objWriter , Fill $ pFill ) { if ( $ pFill -> getFillType ( ) === Fill :: FILL_GRADIENT_LINEAR || $ pFill -> getFillType ( ) === Fill :: FILL_GRADIENT_PATH ) { $ this -> writeGradientFill ( $ objWriter , $ pFill ) ; } elseif ( $ pFill -> getFillType ( ) !== null ) { $ this -> writePatternFill ( $ objWriter , $ pFill ) ; } }
3950	private function buildChildOperationButton ( $ idParameter , $ itemId , $ href , $ label , $ name , $ icon , $ attributes , $ table ) { $ modelId = ModelId :: fromValues ( $ table , $ itemId ) ; $ url = $ href . '&amp;' . $ idParameter . '=' . $ modelId -> getSerialized ( ) ; if ( 'id' !== $ idParameter ) { $ url .= '&amp;id=' ; } $ url = $ this -> controller -> addToUrl ( $ url ) ; if ( 'id' !== $ idParameter ) { $ url = preg_replace ( '#(&amp;)id=(?:&amp;)?#' , '$1' , $ url ) ; } $ title = sprintf ( $ label ? : $ name , $ itemId ) ; return sprintf ( '<a href="%1$s" title="%2$s"%3$s>%4$s</a> ' , $ url , specialchars ( $ title ) , $ attributes , $ this -> iconBuilder -> getBackendIconImageTag ( $ icon , $ label ) ) ; }
8817	public function delete ( $ key = null , $ filter = true ) { parse_str ( file_get_contents ( "php://input" ) , $ _DELETE ) ; if ( $ key == null ) { return $ _DELETE ; } return $ this -> filter ( $ _DELETE [ $ key ] , $ filter ) ; }
9858	private function isValueInList ( Cell $ cell ) { $ cellValue = $ cell -> getValue ( ) ; $ dataValidation = $ cell -> getDataValidation ( ) ; $ formula1 = $ dataValidation -> getFormula1 ( ) ; if ( ! empty ( $ formula1 ) ) { if ( $ formula1 [ 0 ] === '"' ) { return in_array ( strtolower ( $ cellValue ) , explode ( ',' , strtolower ( trim ( $ formula1 , '"' ) ) ) , true ) ; } elseif ( strpos ( $ formula1 , ':' ) > 0 ) { $ matchFormula = '=MATCH(' . $ cell -> getCoordinate ( ) . ', ' . $ formula1 . ', 0)' ; $ calculation = Calculation :: getInstance ( $ cell -> getWorksheet ( ) -> getParent ( ) ) ; try { $ result = $ calculation -> calculateFormula ( $ matchFormula , $ cell -> getCoordinate ( ) , $ cell ) ; return $ result !== Functions :: NA ( ) ; } catch ( Exception $ ex ) { return false ; } } } return true ; }
3815	protected function process ( $ table , $ metaModelName , $ parentId , Request $ request ) { $ this -> knownAttributes = $ this -> fetchExisting ( $ table , $ parentId ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; if ( ! $ metaModel ) { throw new \ RuntimeException ( 'Could not retrieve MetaModel ' . $ metaModelName ) ; } if ( $ request -> request -> has ( 'add' ) || $ request -> request -> has ( 'saveNclose' ) ) { $ this -> perform ( $ table , $ request , $ metaModel , $ parentId ) ; if ( $ request -> request -> has ( 'saveNclose' ) ) { return new RedirectResponse ( $ this -> getReferer ( $ request , $ table , false ) ) ; } } return new Response ( $ this -> templating -> render ( 'MetaModelsCoreBundle::Backend/add-all.html.twig' , $ this -> render ( $ table , $ metaModel , $ request ) ) ) ; }
10525	public function setFieldValue ( $ field , $ value ) { $ type = $ this -> getFieldFormType ( $ field ) ; switch ( $ type ) { case 'select' : return $ this -> selectOptionForm ( $ field , $ value ) ; case 'checkbox' : case 'checkboxGroup' : return $ this -> checkOptionForm ( $ field ) ; default : return $ this -> fillFieldForm ( $ field , $ value ) ; } }
1065	private function findConflict ( ValidationContext $ context , $ parentFieldsAreMutuallyExclusive , $ responseName , array $ field1 , array $ field2 ) { [ $ parentType1 , $ ast1 , $ def1 ] = $ field1 ; [ $ parentType2 , $ ast2 , $ def2 ] = $ field2 ; $ areMutuallyExclusive = $ parentFieldsAreMutuallyExclusive || ( $ parentType1 !== $ parentType2 && $ parentType1 instanceof ObjectType && $ parentType2 instanceof ObjectType ) ; $ type1 = $ def1 === null ? null : $ def1 -> getType ( ) ; $ type2 = $ def2 === null ? null : $ def2 -> getType ( ) ; if ( ! $ areMutuallyExclusive ) { $ name1 = $ ast1 -> name -> value ; $ name2 = $ ast2 -> name -> value ; if ( $ name1 !== $ name2 ) { return [ [ $ responseName , sprintf ( '%s and %s are different fields' , $ name1 , $ name2 ) ] , [ $ ast1 ] , [ $ ast2 ] , ] ; } if ( ! $ this -> sameArguments ( $ ast1 -> arguments ? : [ ] , $ ast2 -> arguments ? : [ ] ) ) { return [ [ $ responseName , 'they have differing arguments' ] , [ $ ast1 ] , [ $ ast2 ] , ] ; } } if ( $ type1 && $ type2 && $ this -> doTypesConflict ( $ type1 , $ type2 ) ) { return [ [ $ responseName , sprintf ( 'they return conflicting types %s and %s' , $ type1 , $ type2 ) ] , [ $ ast1 ] , [ $ ast2 ] , ] ; } $ selectionSet1 = $ ast1 -> selectionSet ; $ selectionSet2 = $ ast2 -> selectionSet ; if ( $ selectionSet1 && $ selectionSet2 ) { $ conflicts = $ this -> findConflictsBetweenSubSelectionSets ( $ context , $ areMutuallyExclusive , Type :: getNamedType ( $ type1 ) , $ selectionSet1 , Type :: getNamedType ( $ type2 ) , $ selectionSet2 ) ; return $ this -> subfieldConflicts ( $ conflicts , $ responseName , $ ast1 , $ ast2 ) ; } return null ; }
6134	public function setMetadata ( $ metadata ) { if ( is_array ( $ metadata ) ) { $ this -> metadata = $ metadata ; return $ this ; } $ this -> metadata = json_decode ( $ metadata , true ) ; if ( null === $ this -> metadata ) { $ this -> metadata = $ metadata ; } return $ this ; }
10549	public function setApplication ( Application $ app ) { $ this -> setVariable ( 'app' , $ app ) -> setVariable ( 'path_config' , $ app -> pathConfig ) -> setVariable ( 'i18n' , $ app -> i18n ) ; try { $ this -> setVariable ( 'db' , $ app -> db ) ; } catch ( \ Wedeto \ DB \ Exception \ ConfigurationException $ db ) { } return $ this ; }
11069	protected function getStatusData ( $ identifier ) { foreach ( $ this -> options [ 'statuses' ] as $ status ) { if ( ( int ) $ status [ 'id' ] === ( int ) $ identifier ) { return $ status ; } } return null ; }
2990	public function uploadFromPath ( $ path ) { $ file = new FormUpload ( $ path ) ; $ this -> request -> setParam ( 'content' , $ file ) ; return $ this ; }
3525	public function lookup ( $ username ) { try { $ data = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_PERSONA_API . 'public/account/lookup?q=' . urlencode ( $ username ) , $ this -> access_token ) ; return new self ( $ this -> access_token , $ data -> id ) ; } catch ( GuzzleException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) throw new UserNotFoundException ( 'User ' . $ username . ' was not found.' ) ; throw $ e ; } }
4976	public static function factory ( ContainerInterface $ container ) { $ manager = $ container -> get ( 'ModuleManager' ) ; $ modules = $ manager -> getLoadedModules ( ) ; return new static ( $ modules ) ; }
1481	public function getDefaultCodec ( ) : Codec { return $ this -> factory -> createCodec ( $ this -> getContainer ( ) , $ this -> encodings -> find ( MediaTypeInterface :: JSON_API_MEDIA_TYPE ) ? : Encoding :: jsonApi ( ) , $ this -> decodings -> find ( MediaTypeInterface :: JSON_API_MEDIA_TYPE ) ) ; }
4765	protected function validateRegistrationOptin ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_userregistration' ) ; $ registrationOption = ( int ) $ this -> getRequestParameter ( 'option' ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinUserRegistration' ) && ( 3 == $ registrationOption ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
2916	protected function stringToType ( $ string ) { if ( is_string ( $ string ) ) { switch ( true ) { case ( $ string == 'null' || $ string == 'NULL' ) : $ string = null ; break ; case ( $ string == 'true' || $ string == 'TRUE' ) : $ string = true ; break ; case ( $ string == 'false' || $ string == 'FALSE' ) : $ string = false ; break ; default : break ; } } return $ string ; }
6086	public function listTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/moodboards/templates' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new MoodboardTemplateResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
7212	public function generateLoginToken ( array $ redirectUrl = null , string $ expireInterval = '1 day' , bool $ addRememberMeCookie = true ) : string { $ data = [ 'url' => $ redirectUrl , 'timestamp' => Time :: now ( ) -> toUnixString ( ) , 'expireInterval' => $ expireInterval , 'addRememberMeCookie' => $ addRememberMeCookie ] ; $ serializedData = serialize ( $ data ) ; $ token = Security :: encrypt ( $ serializedData , $ this -> getKey ( ) , $ this -> getSalt ( ) ) ; return base64_encode ( $ token ) ; }
11507	public function serve ( ) { Log :: debug ( 'Request received:' , [ 'Method' => $ this -> request -> getMethod ( ) , 'URI' => $ this -> request -> getRequestUri ( ) , 'Query' => $ this -> request -> getQueryString ( ) , 'Protocal' => $ this -> request -> server -> get ( 'SERVER_PROTOCOL' ) , 'Content' => $ this -> request -> getContent ( ) , ] ) ; $ this -> validate ( $ this -> token ) ; if ( $ str = $ this -> request -> get ( 'echostr' ) ) { Log :: debug ( "Output 'echostr' is '$str'." ) ; return new Response ( $ str ) ; } $ result = $ this -> handleRequest ( ) ; $ response = $ this -> buildResponse ( $ result [ 'to' ] , $ result [ 'from' ] , $ result [ 'response' ] ) ; Log :: debug ( 'Server response created:' , compact ( 'response' ) ) ; return new Response ( $ response ) ; }
4124	private function generateProxyClass ( $ class , $ fileName , $ template ) { $ methods = $ this -> generateMethods ( $ class ) ; $ sleepImpl = $ this -> generateSleep ( $ class ) ; $ placeholders = array ( '<namespace>' , '<proxyClassName>' , '<className>' , '<methods>' , '<sleepImpl>' ) ; $ className = ltrim ( $ class -> name , '\\' ) ; $ proxyClassName = ClassUtils :: generateProxyClassName ( $ class -> name , $ this -> proxyNamespace ) ; $ parts = explode ( '\\' , strrev ( $ proxyClassName ) , 2 ) ; $ proxyClassNamespace = strrev ( $ parts [ 1 ] ) ; $ proxyClassName = strrev ( $ parts [ 0 ] ) ; $ replacements = array ( $ proxyClassNamespace , $ proxyClassName , $ className , $ methods , $ sleepImpl ) ; $ template = str_replace ( $ placeholders , $ replacements , $ template ) ; file_put_contents ( $ fileName , $ template , LOCK_EX ) ; }
8853	public function getCurrentCategory ( ) { $ category = $ this -> request -> param ( "Category" ) ; if ( $ category ) { return $ this -> dataRecord -> Categories ( ) -> filter ( "URLSegment" , $ category ) -> first ( ) ; } return null ; }
2882	protected function _initEmail ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ index = $ this -> getRequest ( ) -> getParam ( 'index' ) ; if ( $ token === null || $ index === null ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return null ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return null ; } $ emails = $ requestProfile -> getEmails ( ) ; if ( ! $ emails || ! ( $ index < count ( $ emails ) ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'E-mail not found' ) ; return null ; } return $ emails [ ( int ) $ index ] ; }
10901	public function loadAll ( array $ where = [ ] , bool $ assoc = false , array $ fields = null ) : Collection { $ allData = $ this -> medoo -> select ( $ this -> getTable ( ) , $ fields ? $ fields : '*' , $ where ) ; $ this -> sentry -> breadcrumbs -> record ( [ 'message' => 'Entity ' . $ this -> __getEntityName ( ) . '::loadAll(' . \ print_r ( $ where , true ) . ', ' . $ assoc . ', ' . \ print_r ( $ fields , true ) . ')' , 'data' => [ 'query' => $ this -> medoo -> last ( ) ] , 'category' => 'Database' , 'level' => 'info' , ] ) ; $ items = [ ] ; foreach ( $ allData as $ data ) { $ items [ ] = ( $ assoc ) ? $ data : $ this -> container [ 'entity' ] ( $ this -> __getEntityName ( ) ) -> setData ( $ data ) ; } return new Collection ( $ items ) ; }
2394	public function addString ( $ strData , $ strName , $ intTime = 0 ) { ++ $ this -> intCount ; $ strName = strtr ( $ strName , '\\' , '/' ) ; $ arrFile [ 'file_signature' ] = self :: FILE_SIGNATURE ; $ arrFile [ 'version_needed_to_extract' ] = "\x14\x00" ; $ arrFile [ 'general_purpose_bit_flag' ] = "\x00\x00" ; $ arrFile [ 'compression_method' ] = "\x08\x00" ; $ arrFile [ 'last_mod_file_hex' ] = $ this -> unixToHex ( $ intTime ) ; $ arrFile [ 'crc-32' ] = pack ( 'V' , crc32 ( $ strData ) ) ; $ intUncompressed = \ strlen ( $ strData ) ; $ strData = gzcompress ( $ strData ) ; $ strData = substr ( substr ( $ strData , 0 , - 4 ) , 2 ) ; $ intCompressed = \ strlen ( $ strData ) ; $ arrFile [ 'compressed_size' ] = pack ( 'V' , $ intCompressed ) ; $ arrFile [ 'uncompressed_size' ] = pack ( 'V' , $ intUncompressed ) ; $ arrFile [ 'file_name_length' ] = pack ( 'v' , \ strlen ( $ strName ) ) ; $ arrFile [ 'extra_field_length' ] = "\x00\x00" ; $ arrFile [ 'file_name' ] = $ strName ; $ arrFile [ 'extra_field' ] = '' ; $ intOffset = @ ftell ( $ this -> resFile ) ; fwrite ( $ this -> resFile , implode ( '' , $ arrFile ) ) ; fwrite ( $ this -> resFile , $ strData ) ; $ arrHeader [ 'header_signature' ] = self :: CENTRAL_DIR_START ; $ arrHeader [ 'version_made_by' ] = "\x00\x00" ; $ arrHeader [ 'version_needed_to_extract' ] = $ arrFile [ 'version_needed_to_extract' ] ; $ arrHeader [ 'general_purpose_bit_flag' ] = $ arrFile [ 'general_purpose_bit_flag' ] ; $ arrHeader [ 'compression_method' ] = $ arrFile [ 'compression_method' ] ; $ arrHeader [ 'last_mod_file_hex' ] = $ arrFile [ 'last_mod_file_hex' ] ; $ arrHeader [ 'crc-32' ] = $ arrFile [ 'crc-32' ] ; $ arrHeader [ 'compressed_size' ] = $ arrFile [ 'compressed_size' ] ; $ arrHeader [ 'uncompressed_size' ] = $ arrFile [ 'uncompressed_size' ] ; $ arrHeader [ 'file_name_length' ] = $ arrFile [ 'file_name_length' ] ; $ arrHeader [ 'extra_field_length' ] = $ arrFile [ 'extra_field_length' ] ; $ arrHeader [ 'file_comment_length' ] = "\x00\x00" ; $ arrHeader [ 'disk_number_start' ] = "\x00\x00" ; $ arrHeader [ 'internal_file_attributes' ] = "\x00\x00" ; $ arrHeader [ 'external_file_attributes' ] = pack ( 'V' , 32 ) ; $ arrHeader [ 'offset_of_local_header' ] = pack ( 'V' , $ intOffset ) ; $ arrHeader [ 'file_name' ] = $ arrFile [ 'file_name' ] ; $ arrHeader [ 'extra_field' ] = $ arrFile [ 'extra_field' ] ; $ arrHeader [ 'file_comment' ] = '' ; $ this -> strCentralDir .= implode ( '' , $ arrHeader ) ; }
5090	public function execute ( $ path ) { if ( ! file_exists ( $ path ) || ! is_readable ( $ path ) ) throw new SquidException ( "The file at [$path] is unreadable or doesn't exists" ) ; $ data = file_get_contents ( $ path ) ; $ result = $ this -> connector -> bulk ( ) -> add ( $ data ) -> executeAll ( ) ; return ( bool ) $ result ; }
2365	public static function prepareSlug ( $ strSlug ) { $ strSlug = static :: stripInsertTags ( $ strSlug ) ; $ strSlug = static :: restoreBasicEntities ( $ strSlug ) ; $ strSlug = static :: decodeEntities ( $ strSlug ) ; return $ strSlug ; }
9626	public function getAll ( array $ filterAttributes = [ ] ) { $ filters = [ 'query' => [ $ filterAttributes ] ] ; try { $ result = $ this -> client -> get ( $ this -> slug , $ filters ) ; } catch ( RequestException $ e ) { $ return [ 'request' ] = $ e -> getRequest ( ) . "\n" ; if ( $ e -> hasResponse ( ) ) { return $ return [ 'response' ] = $ e -> getResponse ( ) . "\n" ; } } return $ result -> json ( ) ; }
9054	public function createRelationTable ( $ tableName ) : self { $ table = $ this -> getTableData ( $ tableName ) ; $ name = $ this -> name . '_x_' . $ table -> name ; return $ this -> relationTables [ ] = $ this -> tableFactory -> create ( $ name , $ this -> prefix ) ; }
5922	public function setPropertySets ( array $ propertySets ) { $ this -> propertySets = [ ] ; foreach ( $ propertySets as $ item ) { $ this -> addPropertySet ( $ item ) ; } return $ this ; }
5342	private function getSoapClient ( $ service , $ method , array $ parameters ) { $ timestamp = time ( ) ; $ nonce = uniqid ( null , true ) ; $ soapClient = $ this -> client -> buildSoapClient ( $ service ) ; $ soapClient -> setTimestamp ( $ timestamp ) ; $ soapClient -> setNonce ( $ nonce ) ; $ soapClient -> setSignature ( array_merge ( $ parameters , [ '__method' => $ method ] ) , $ this -> client -> getPrivateKey ( ) , $ service , $ this -> client -> getEndpoint ( ) , $ timestamp , $ nonce ) ; return $ soapClient ; }
7080	public function onPreCopy ( SaleTransformEvent $ event ) { $ source = $ event -> getSource ( ) ; if ( $ source instanceof OrderInterface ) { if ( $ source -> getState ( ) !== OrderStates :: STATE_NEW ) { $ event -> addMessage ( new ResourceMessage ( 'ekyna_commerce.sale.message.transform_prevented' , ResourceMessage :: TYPE_ERROR ) ) ; } } }
827	public function getCommentBlockIndices ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_COMMENT ) ) { throw new \ InvalidArgumentException ( 'Given index must point to a comment.' ) ; } $ commentType = $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ; $ indices = [ $ index ] ; if ( self :: TYPE_SLASH_ASTERISK === $ commentType ) { return $ indices ; } $ count = \ count ( $ tokens ) ; ++ $ index ; for ( ; $ index < $ count ; ++ $ index ) { if ( $ tokens [ $ index ] -> isComment ( ) ) { if ( $ commentType === $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ) { $ indices [ ] = $ index ; continue ; } break ; } if ( ! $ tokens [ $ index ] -> isWhitespace ( ) || $ this -> getLineBreakCount ( $ tokens , $ index , $ index + 1 ) > 1 ) { break ; } } return $ indices ; }
9273	public function filter ( $ text ) { $ text = str_replace ( "\r" , '' , $ text ) ; $ text = str_replace ( ' ' , ' &nbsp;' , $ text ) ; $ this -> _parseBbcodeNobbcode ( $ text ) ; $ this -> _parseBbcodeCode ( $ text ) ; $ this -> _parseBbcodeQuote ( $ text ) ; $ this -> _parseBbcodeList ( $ text ) ; $ this -> _parseSimpleBbcode ( 'i' , '<em>$1</em>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'u' , '<u>$1</u>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'b' , '<strong>$1</strong>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'del' , '<del>$1</del>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'strike' , '<del>$1</del>' , $ text ) ; $ this -> _parseParamBbcode ( 'color' , '([a-zA-Z]*|\#?[0-9a-fA-F]{6})' , '<span style="color: $1">$2</span>' , $ text ) ; $ this -> _parseParamBbcode ( 'bgcolor' , '([a-zA-Z]*|\#?[0-9a-fA-F]{6})' , '<span style="background-color: $1">$2</span>' , $ text ) ; $ this -> _parseParamBbcode ( 'align' , '(center|left|right|justify){1}' , '<div style="text-alignement: $1">$2</div>' , $ text ) ; $ this -> _parseParamBbcode ( 'size' , '([0-9].*)' , '<span style="font-size: $1">$2</span>' , $ text ) ; $ this -> _parseBbcodeEmail ( $ text ) ; $ this -> _parseBbcodeUrl ( $ text ) ; $ this -> _parseBbcodeImg ( $ text ) ; $ this -> _parseBbcodeSpoiler ( $ text ) ; $ this -> _parseScriptTags ( $ text ) ; $ this -> _parseSmiley ( $ text ) ; $ this -> _parseBbcodeBr ( $ text ) ; return $ text ; }
10666	public function setReportUri ( string $ reportUri ) : void { if ( ! $ this -> enableProtection ) { throw new MiddlewareException ( $ this , "You can't set the report URI because the XSS protection is disabled" ) ; } if ( $ this -> blockMode ) { throw new MiddlewareException ( $ this , sprintf ( "You can't set the report URI because the block mode is already enabled (see %s)" , 'https://developer.mozilla.org/docs/Web/HTTP/Headers/X-XSS-Protection' ) ) ; } $ this -> reportUri = $ reportUri ; }
5176	public function add ( string $ key , $ value ) : self { if ( ! array_key_exists ( $ key , $ this -> props ) ) { return $ this -> addNew ( $ key , $ value ) ; } if ( is_array ( $ this -> props [ $ key ] ) ) { return $ this -> addArray ( $ key , $ value ) ; } return $ this -> appendToArray ( $ key , $ value ) ; }
7866	protected function drawBorderTop ( $ isCore = false ) { $ crossroads = $ isCore ? static :: CROSSROADS_UP : static :: CROSSROADS ; $ this -> drawBorder ( static :: BORDER_NW , $ crossroads , static :: BORDER_NE ) ; $ this -> geometry -> increaseNesting ( ) ; }
7503	public function tf ( string $ key , array $ args = null , array $ replacements = null , string ... $ namespaces ) { $ this -> view -> out ( $ this -> getTf ( $ key , $ args , $ replacements , ... $ namespaces ) ) ; }
5101	public function valuesExp ( $ expression , $ bind = false ) { return $ this -> appendPart ( CmdInsert :: PART_VALUES , $ expression , $ bind ) ; }
4461	private function handleChildErrors ( & $ socket ) : Closure { $ reserved = str_repeat ( '*' , 32 * 1024 ) ; return function ( ) use ( & $ reserved , & $ socket ) : void { unset ( $ reserved ) ; $ error = error_get_last ( ) ; if ( $ error === null ) { unset ( $ reserved ) ; return ; } $ handler = new ErrorFormatter ( ) ; if ( $ handler -> constant ( $ error [ 'type' ] ) === null ) { $ this -> logger -> warning ( '{type}: Unable to recognize error type. Skip sending error to master: {message}' , $ this -> logContext + [ 'message' => $ error [ 'message' ] ] ) ; return ; } if ( is_resource ( $ socket ) == false ) { $ this -> logger -> warning ( '{type}: supplied resource is not a valid socket resource. Skip sending error to master: {message}' , $ this -> logContext + [ 'message' => $ error [ 'message' ] ] ) ; return ; } $ this -> logger -> debug ( '{type}: sending error to master' , $ this -> logContext ) ; $ data = serialize ( $ error ) ; do { $ len = socket_write ( $ socket , $ data ) ; if ( $ len === false || $ len === 0 ) { break ; } $ data = substr ( $ data , $ len ) ; } while ( is_numeric ( $ len ) && $ len > 0 && is_resource ( $ socket ) ) ; } ; }
1607	public function save ( $ uri , $ to , $ type , $ siteId = null , $ id = null ) { if ( $ siteId === 'null' ) $ siteId = null ; if ( $ id ) { $ record = RedirectRecord :: findOne ( compact ( 'id' ) ) ; if ( ! $ record ) return 'Unable to find redirect with ID: ' . $ id ; } else { $ existing = RedirectRecord :: findOne ( compact ( 'uri' , 'siteId' ) ) ; if ( $ existing ) return 'A redirect with that URI already exists!' ; $ record = new RedirectRecord ( ) ; } $ record -> uri = $ uri ; $ record -> to = $ to ; $ record -> type = $ type ; if ( $ siteId !== false ) $ record -> siteId = $ siteId ; if ( ! $ record -> save ( ) ) return $ record -> getErrors ( ) ; return $ record -> id ; }
12476	public function setCurrentTheme ( $ identifier ) { $ theme = $ this -> getTheme ( $ identifier ) ; $ this -> container -> get ( 'session' ) -> set ( '_admin_theme' , $ theme ) ; }
2800	protected static function generateBeanCreationCode ( string $ padding , string $ beanId , string $ methodParams , BeanPostProcessorsProperty $ postProcessorsProperty ) : string { $ content = $ padding . '$instance = parent::' . $ beanId . '(' . $ methodParams . ');' . PHP_EOL ; $ content .= $ padding . 'if ($instance instanceof \\' . InitializedBean :: class . ') { ' . PHP_EOL ; $ content .= $ padding . ' $instance->postInitialization();' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; $ content .= PHP_EOL ; $ content .= $ padding . 'foreach ($this->' . $ postProcessorsProperty -> getName ( ) . ' as $postProcessor) { ' . PHP_EOL ; $ content .= $ padding . ' $postProcessor->postProcess($instance, "' . $ beanId . '");' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; return $ content ; }
8854	public function getArchiveYear ( ) { $ year = $ this -> request -> param ( "Year" ) ; if ( preg_match ( "/^[0-9]{4}$/" , $ year ) ) { return ( int ) $ year ; } return null ; }
3289	public function start ( ) : Promise { if ( $ this -> handle ) { throw new StatusError ( "Process has already been started." ) ; } return call ( function ( ) { $ this -> handle = $ this -> processRunner -> start ( $ this -> command , $ this -> cwd , $ this -> env , $ this -> options ) ; return $ this -> pid = yield $ this -> handle -> pidDeferred -> promise ( ) ; } ) ; }
9614	public function authenticate ( TokenInterface $ token ) { $ user = $ this -> userProvider -> loadUserByApiKey ( $ this -> encoder -> encodePassword ( $ token -> getCredentials ( ) ) ) ; if ( ! $ user || ! ( $ user instanceof UserInterface ) ) { throw new AuthenticationException ( 'Bad credentials' ) ; } $ token = new ApiKeyToken ( $ token -> getCredentials ( ) , $ user -> getRoles ( ) ) ; $ token -> setUser ( $ user ) ; return $ token ; }
11392	public static function getInstance ( ) : Debug { if ( ! ( self :: $ _oInstance instanceof self ) ) { self :: $ _oInstance = new self ( ) ; } return self :: $ _oInstance ; }
11240	public function def ( $ checkName , $ class , $ method , $ errorMessage , $ passing = true , $ arguments = false ) { $ this -> customChecks -> $ checkName = [ '_call' , $ class , $ method , $ passing , $ arguments ] ; $ this -> lang -> $ checkName = $ errorMessage ; }
2541	protected function analyzeWithErrCodeCategoryMsgQuery ( SendResult $ response , $ qErr , $ qCat , $ qMsg , $ errLevel = null ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ errorCatNode = $ domXpath -> query ( $ qCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ errLevel ) ; } return $ analyzeResponse ; }
1189	protected function isImplemented ( $ rule ) { return in_array ( $ rule , $ this -> clientRules ) || in_array ( $ rule , $ this -> serverRules ) ; }
12397	public function orWhere ( $ field , $ operator = null , $ value = null ) { return $ this -> where ( $ field , $ operator , $ value , '||' ) ; }
4369	public function buildTable ( $ rows , $ options = array ( ) ) { $ options = \ array_merge ( array ( 'attribs' => array ( ) , 'caption' => null , 'columns' => array ( ) , 'totalCols' => array ( ) , ) , $ options ) ; if ( \ is_string ( $ options [ 'attribs' ] ) ) { $ options [ 'attribs' ] = array ( 'class' => $ options [ 'attribs' ] , ) ; } if ( $ this -> debug -> abstracter -> isAbstraction ( $ rows ) && $ rows [ 'traverseValues' ] ) { $ options [ 'caption' ] .= ' (' . $ this -> markupClassname ( $ rows [ 'className' ] , 'span' , array ( 'title' => $ rows [ 'phpDoc' ] [ 'summary' ] ? : null , ) ) . ')' ; $ options [ 'caption' ] = \ trim ( $ options [ 'caption' ] ) ; $ rows = $ rows [ 'traverseValues' ] ; } $ keys = $ options [ 'columns' ] ? : $ this -> debug -> methodTable -> colKeys ( $ rows ) ; $ this -> tableInfo = array ( 'colClasses' => \ array_fill_keys ( $ keys , null ) , 'haveObjRow' => false , 'totals' => \ array_fill_keys ( $ options [ 'totalCols' ] , null ) , ) ; $ tBody = '' ; foreach ( $ rows as $ k => $ row ) { $ tBody .= $ this -> buildTableRow ( $ row , $ keys , $ k ) ; } if ( ! $ this -> tableInfo [ 'haveObjRow' ] ) { $ tBody = \ str_replace ( '<td class="t_classname"></td>' , '' , $ tBody ) ; } return $ this -> debug -> utilities -> buildTag ( 'table' , $ options [ 'attribs' ] , "\n" . ( $ options [ 'caption' ] ? '<caption>' . $ options [ 'caption' ] . '</caption>' . "\n" : '' ) . $ this -> buildTableHeader ( $ keys ) . '<tbody>' . "\n" . $ tBody . '</tbody>' . "\n" . $ this -> buildTableFooter ( $ keys ) ) ; }
12597	public function getCacheAdapter ( $ namespace ) { if ( ! $ this -> isCacheable ( $ namespace ) ) { return null ; } if ( is_array ( $ this -> cacheOptions -> getAdapter ( ) ) ) { if ( ! isset ( $ this -> cacheOptions -> getAdapter ( ) [ $ namespace ] ) ) { return null ; } $ adapter = $ this -> cacheOptions -> getAdapter ( ) [ $ namespace ] ; } else { $ adapter = $ this -> cacheOptions -> getAdapter ( ) ; } if ( is_object ( $ adapter ) ) { return $ adapter ; } if ( $ this -> getServiceLocator ( ) -> has ( $ adapter ) ) { return $ this -> getServiceLocator ( ) -> get ( $ adapter ) ; } return new $ adapter ; }
10059	public function commit ( ) { foreach ( $ this -> deferred as $ item ) { $ this -> save ( $ item ) ; } $ this -> deferred = [ ] ; return true ; }
8401	public function render ( RenderInterface $ render , $ status = 200 ) { $ this -> renderInst = $ render ; $ this -> status = $ status ; }
7794	protected function accountNumber ( $ text ) { if ( $ account = $ this -> getLine ( '25' , $ text ) ) { return ltrim ( substr ( $ account , 12 ) , '0' ) ; } return null ; }
876	private function isCommentWithFixableIndentation ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isComment ( ) ) { return false ; } if ( 0 === strpos ( $ tokens [ $ index ] -> getContent ( ) , '/*' ) ) { return true ; } $ firstCommentIndex = $ index ; while ( true ) { $ i = $ this -> getSiblingContinuousSingleLineComment ( $ tokens , $ firstCommentIndex , false ) ; if ( null === $ i ) { break ; } $ firstCommentIndex = $ i ; } $ lastCommentIndex = $ index ; while ( true ) { $ i = $ this -> getSiblingContinuousSingleLineComment ( $ tokens , $ lastCommentIndex , true ) ; if ( null === $ i ) { break ; } $ lastCommentIndex = $ i ; } if ( $ firstCommentIndex === $ lastCommentIndex ) { return true ; } for ( $ i = $ firstCommentIndex + 1 ; $ i < $ lastCommentIndex ; ++ $ i ) { if ( ! $ tokens [ $ i ] -> isWhitespace ( ) && ! $ tokens [ $ i ] -> isComment ( ) ) { return false ; } } return true ; }
7070	static function round ( $ value , $ unit = 'piece' ) { if ( 0 < $ precision = static :: getPrecision ( $ unit ) ) { $ divider = pow ( 10 , $ precision ) ; return round ( floor ( $ value * $ divider ) / $ divider , $ precision ) ; } return floor ( $ value ) ; }
239	private function loadTableMetadataFromCache ( $ cache , $ name ) { if ( $ cache === null ) { $ this -> _tableMetadata [ $ name ] = [ ] ; return ; } $ metadata = $ cache -> get ( $ this -> getCacheKey ( $ name ) ) ; if ( ! is_array ( $ metadata ) || ! isset ( $ metadata [ 'cacheVersion' ] ) || $ metadata [ 'cacheVersion' ] !== static :: SCHEMA_CACHE_VERSION ) { $ this -> _tableMetadata [ $ name ] = [ ] ; return ; } unset ( $ metadata [ 'cacheVersion' ] ) ; $ this -> _tableMetadata [ $ name ] = $ metadata ; }
10115	private function writeFooter ( ) { $ record = 0x0015 ; $ recordData = StringHelper :: UTF8toBIFF8UnicodeLong ( $ this -> phpSheet -> getHeaderFooter ( ) -> getOddFooter ( ) ) ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; }
1013	private function readComment ( $ line , $ col , Token $ prev ) { $ start = $ this -> position ; $ value = '' ; $ bytes = 1 ; do { [ $ char , $ code , $ bytes ] = $ this -> moveStringCursor ( 1 , $ bytes ) -> readChar ( ) ; $ value .= $ char ; } while ( $ code && ( $ code > 0x001F || $ code === 0x0009 ) ) ; return new Token ( Token :: COMMENT , $ start , $ this -> position , $ line , $ col , $ prev , $ value ) ; }
661	public function beginTransaction ( $ isolationLevel = null ) { $ this -> open ( ) ; if ( ( $ transaction = $ this -> getTransaction ( ) ) === null ) { $ transaction = $ this -> _transaction = new Transaction ( [ 'db' => $ this ] ) ; } $ transaction -> begin ( $ isolationLevel ) ; return $ transaction ; }
4700	protected function handleInput ( InputInterface $ input ) { if ( $ file = $ input -> getArgument ( 'file' ) ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The input file "%s" not found' , $ file ) ) ; } return file_get_contents ( $ file ) ; } else { $ contents = '' ; if ( $ stdin = fopen ( 'php://stdin' , 'r' ) ) { if ( stream_set_blocking ( $ stdin , false ) ) { $ contents = stream_get_contents ( $ stdin ) ; } fclose ( $ stdin ) ; } if ( $ contents ) { return $ contents ; } } throw new \ InvalidArgumentException ( 'No input file' ) ; }
12118	public function getParam ( $ key , $ default = null ) { $ param = parent :: getParam ( $ key , $ default ) ; if ( is_string ( $ param ) ) { return trim ( $ param ) ; } return $ param ; }
8018	public function getUrl ( $ name , $ expires = NULL ) { return $ this -> getClient ( ) -> getObjectUrl ( $ this -> bucket , $ name , $ expires ) ; }
4159	function pop ( ) { $ response = $ this -> redis -> blPop ( $ this -> key , 10 ) ; if ( $ response ) { list ( $ list , $ serializedJob ) = $ response ; $ job = unserialize ( $ serializedJob ) ; return $ job ; } }
8850	public function rss ( ) { $ rss = new RSSFeed ( $ this -> getBlogPosts ( ) , $ this -> Link ( ) , $ this -> MetaTitle , $ this -> MetaDescription ) ; $ this -> extend ( 'updateRss' , $ rss ) ; return $ rss -> outputToBrowser ( ) ; }
5653	private function longestFlag ( $ flag_sets ) { $ longest = 0 ; foreach ( $ flag_sets as $ flags ) { foreach ( $ flags as $ flag ) { $ longest = max ( $ longest , strlen ( $ this -> renderFlag ( $ flag ) ) ) ; } } return $ longest ; }
11909	public function getRequiredParams ( ) { $ requiredParams = [ ] ; foreach ( $ this -> parameters as $ parameter ) { if ( $ parameter -> getIsOptional ( ) || $ parameter -> hasDefault ( ) ) { continue ; } $ requiredParams [ ] = $ parameter ; } return $ requiredParams ; }
1354	protected function sort ( $ query , array $ sortBy ) { foreach ( $ sortBy as $ param ) { $ this -> sortBy ( $ query , $ param ) ; } }
2834	public function startRendering ( Mage_Core_Block_Abstract $ block ) { if ( $ this -> isRendering ) { $ this -> renderedCount ++ ; Mage :: log ( "Recursive block rendering {$this->getName()}" , Zend_Log :: DEBUG ) ; return ; } $ this -> init ( $ block ) ; $ this -> isRendering = true ; $ this -> renderedCount ++ ; $ this -> renderedAt = microtime ( true ) ; if ( self :: $ startRenderingTime === null ) { self :: $ startRenderingTime = $ this -> renderedAt ; } }
10483	public static function createSoftBounce ( $ recipientEmailAddress , $ listExternalId , $ recipientExternalId = null , $ ipAddress = '127.0.0.1' ) { if ( $ recipientExternalId == null ) { $ recipientExternalId = rand ( 1 , 99999 ) ; } return ( new Payload ( ) ) -> setIpAddress ( $ ipAddress ) -> setAction ( Type :: SOFT_BOUNCE ) -> setCampaignId ( rand ( 1 , 99999 ) ) -> setListExternalId ( $ listExternalId ) -> setReason ( Type :: REASON_SYSTEM_AUTOMATIC ) -> setRecipientEmailAddress ( $ recipientEmailAddress ) -> setHash ( md5 ( $ recipientEmailAddress ) ) -> setRecipientExternalId ( $ recipientExternalId ) -> setTriggerDate ( new \ DateTime ( ) ) -> setType ( Type :: SOFT_BOUNCE ) ; }
4036	private function fetchTemplatesFromResourceDirectories ( $ templateBaseName ) { $ allTemplates = [ ] ; $ themeName = $ this -> getNoThemeMessage ( ) ; foreach ( $ this -> resourceDirs as $ resourceDir ) { $ allTemplates = array_replace_recursive ( $ allTemplates , $ this -> getTemplatesForBaseFrom ( $ templateBaseName , $ resourceDir . '/templates' , $ themeName ) ) ; } return $ allTemplates ; }
12652	public function getPageTexts ( $ language ) { if ( ! isset ( $ this -> contents [ $ language ] ) ) { $ this -> contents [ $ language ] = $ this -> readFileContents ( $ language ) ; } return $ this -> contents [ $ language ] ; }
7517	function parse_text ( ) { $ len = $ this -> pos - 1 - $ this -> status [ 'last_pos' ] ; $ this -> status [ 'text' ] = ( ( $ len > 0 ) ? substr ( $ this -> doc , $ this -> status [ 'last_pos' ] + 1 , $ len ) : '' ) ; }
528	public function actionInfo ( ) { $ items = [ 'framework' , 'app-basic' , 'app-advanced' , ] ; $ extensionPath = "{$this->basePath}/extensions" ; foreach ( scandir ( $ extensionPath ) as $ extension ) { if ( ctype_alpha ( $ extension ) && is_dir ( $ extensionPath . '/' . $ extension ) ) { $ items [ ] = $ extension ; } } if ( $ this -> update ) { foreach ( $ items as $ item ) { $ this -> stdout ( "fetching tags for $item..." ) ; if ( $ item === 'framework' ) { $ this -> gitFetchTags ( ( string ) $ this -> basePath ) ; } elseif ( strncmp ( 'app-' , $ item , 4 ) === 0 ) { $ this -> gitFetchTags ( "{$this->basePath}/apps/" . substr ( $ item , 4 ) ) ; } else { $ this -> gitFetchTags ( "{$this->basePath}/extensions/$item" ) ; } $ this -> stdout ( "done.\n" , Console :: FG_GREEN , Console :: BOLD ) ; } } else { $ this -> stdout ( "\nInformation may be outdated, re-run with `--update` to fetch latest tags.\n\n" ) ; } $ versions = $ this -> getCurrentVersions ( $ items ) ; $ nextVersions = $ this -> getNextVersions ( $ versions , self :: PATCH ) ; $ w = $ this -> minWidth ( array_keys ( $ versions ) ) ; $ this -> stdout ( str_repeat ( ' ' , $ w + 2 ) . "Current Version Next Version\n" , Console :: BOLD ) ; foreach ( $ versions as $ ext => $ version ) { $ this -> stdout ( $ ext . str_repeat ( ' ' , $ w + 3 - mb_strlen ( $ ext ) ) . $ version . '' ) ; $ this -> stdout ( str_repeat ( ' ' , 17 - mb_strlen ( $ version ) ) . $ nextVersions [ $ ext ] . "\n" ) ; } }
2968	protected function pickMetadata ( $ data ) { $ metadata = [ ] ; if ( ArrayUtils :: has ( $ data , 'rows' ) ) { $ metadata = ArrayUtils :: omit ( $ data , 'rows' ) ; } else if ( ArrayUtils :: has ( $ data , 'meta' ) ) { $ metadata = ArrayUtils :: get ( $ data , 'meta' ) ; } return new Entry ( $ metadata ) ; }
2246	public static function isVisibleElement ( Model $ objElement ) { $ blnReturn = true ; if ( TL_MODE == 'FE' ) { if ( $ objElement -> protected ) { if ( ! FE_USER_LOGGED_IN ) { $ blnReturn = false ; } else { $ objUser = FrontendUser :: getInstance ( ) ; if ( ! \ is_array ( $ objUser -> groups ) ) { $ blnReturn = false ; } else { $ groups = StringUtil :: deserialize ( $ objElement -> groups ) ; if ( empty ( $ groups ) || ! \ is_array ( $ groups ) || ! \ count ( array_intersect ( $ groups , $ objUser -> groups ) ) ) { $ blnReturn = false ; } } } } elseif ( $ objElement -> guests && FE_USER_LOGGED_IN ) { $ blnReturn = false ; } } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] as $ callback ) { $ blnReturn = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objElement , $ blnReturn ) ; } } return $ blnReturn ; }
8719	public function fresh ( $ with = [ ] ) { if ( ! $ this -> exists ) { return ; } $ query = static :: newQueryWithoutScopes ( ) -> with ( is_string ( $ with ) ? func_get_args ( ) : $ with ) -> where ( $ this -> getKeyName ( ) , $ this -> getKey ( ) ) ; ( new TranslatableScope ( ) ) -> apply ( $ query , $ this ) ; return $ query -> first ( ) ; }
8322	public function getLoad ( $ paramsList = [ 'waiting' , 'load' , 'minbid' , 'averageRecognitionTime' ] ) { $ parser = $ this -> getLoadXml ( ) ; if ( is_string ( $ paramsList ) ) { return $ parser -> $ paramsList -> __toString ( ) ; } $ statusData = [ ] ; foreach ( $ paramsList as $ item ) { $ statusData [ $ item ] = $ parser -> $ item -> __toString ( ) ; } return $ statusData ; }
8551	public function setPerformanceBondRefundEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PerformanceBondRefundEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11495	public function showAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , "page_collection_manager" => $ app [ "red_kite_cms.page_collection_manager" ] , 'form_factory' => $ app [ "form.factory" ] , "pages_collection_parser" => $ app [ "red_kite_cms.pages_collection_parser" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , 'theme' => $ app [ "red_kite_cms.theme" ] , 'template_assets' => $ app [ "red_kite_cms.template_assets" ] , 'twig' => $ app [ "twig" ] , ) ; return parent :: show ( $ options ) ; }
405	public function addCorsHeaders ( $ response , $ headers ) { if ( empty ( $ headers ) === false ) { $ responseHeaders = $ response -> getHeaders ( ) ; foreach ( $ headers as $ field => $ value ) { $ responseHeaders -> set ( $ field , $ value ) ; } } }
344	public static function mailto ( $ text , $ email = null , $ options = [ ] ) { $ options [ 'href' ] = 'mailto:' . ( $ email === null ? $ text : $ email ) ; return static :: tag ( 'a' , $ text , $ options ) ; }
6591	protected function asset ( $ type ) { $ busters = $ this -> checkAndGetBusters ( ) ; $ bustersOfThisType = array ( ) ; foreach ( $ busters as $ key => $ value ) { if ( strpos ( $ key , $ type ) !== false ) { $ bustersOfThisType [ $ key ] = $ value ; } } $ busterStrings = $ this -> parseTags ( $ bustersOfThisType , $ type ) ; return implode ( "\n" , $ busterStrings ) ; }
4076	protected function getMetaModelName ( $ nameOrId ) { return isset ( $ this -> tableMap [ $ nameOrId ] ) ? $ this -> tableMap [ $ nameOrId ] : $ nameOrId ; }
8724	public function translations ( ) { $ localKey = $ this -> getKeyName ( ) ; $ foreignKey = $ this -> getForeignKey ( ) ; $ instance = $ this -> translationModel ( ) ; return new HasMany ( $ instance -> newQuery ( ) , $ this , $ instance -> getTable ( ) . '.' . $ foreignKey , $ localKey ) ; }
9062	private function getTableSchema ( ) : ? Row { return $ this -> connection -> query ( " SELECT [tab.ENGINE], [col.COLLATION_NAME], [col.CHARACTER_SET_NAME] FROM [information_schema.TABLES] tab JOIN [information_schema.COLLATION_CHARACTER_SET_APPLICABILITY] col ON [tab.TABLE_COLLATION] = [col.COLLATION_NAME] WHERE [tab.TABLE_SCHEMA] = %s AND [tab.TABLE_NAME] = %s" , $ this -> database , $ this -> name ) -> fetch ( ) ; }
8851	public function PaginatedList ( ) { $ posts = new PaginatedList ( $ this -> blogPosts ) ; if ( $ this -> PostsPerPage > 0 ) $ posts -> setPageLength ( $ this -> PostsPerPage ) ; else $ posts -> setPageLength ( $ this -> getBlogPosts ( ) -> count ( ) ) ; $ start = $ this -> request -> getVar ( $ posts -> getPaginationGetVar ( ) ) ; $ posts -> setPageStart ( $ start ) ; return $ posts ; }
12684	public function offsetSet ( $ offset , $ value ) { if ( is_null ( $ this -> result ) ) { $ this -> fetchData ( ) ; } if ( ! $ this -> isFetched ( ) ) { trigger_error ( 'Web2All_Table_ObjectList::offsetSet: cannot set value on unitialized list' , E_USER_NOTICE ) ; return false ; } if ( ! $ this -> is_assoc && ! is_numeric ( $ value ) ) { trigger_error ( 'Web2All_Table_ObjectList::offsetSet: can only set numeric keys non assoc lists' , E_USER_NOTICE ) ; return false ; } if ( $ value instanceof $ this -> classname ) { $ this -> result [ $ offset ] = $ value ; } else { trigger_error ( 'Web2All_Table_ObjectList::offsetSet: can only add objects of type ' . $ this -> classname . ' to the list' , E_USER_NOTICE ) ; return false ; } }
947	protected function scripttagExists ( array $ shopScripttags , array $ scripttag ) { foreach ( $ shopScripttags as $ shopScripttag ) { if ( $ shopScripttag -> src === $ scripttag [ 'src' ] ) { return true ; } } return false ; }
2143	public function generate ( $ objRootPage = null ) { global $ objPage ; $ obj403 = $ this -> prepare ( $ objRootPage ) ; $ objPage = $ obj403 -> loadDetails ( ) ; $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'regular' ] ( ) ; header ( 'HTTP/1.1 403 Forbidden' ) ; $ objHandler -> generate ( $ objPage ) ; }
6177	protected function executeDelete ( ) { foreach ( $ this -> tableData as $ key => $ row ) { if ( $ this -> where && ! $ this -> where -> execute ( $ row ) ) { continue ; } unset ( $ this -> tableData [ $ key ] ) ; } $ this -> tableData = array_values ( $ this -> tableData ) ; }
733	public function toArray ( array $ fields = [ ] , array $ expand = [ ] , $ recursive = true ) { $ data = [ ] ; foreach ( $ this -> resolveFields ( $ fields , $ expand ) as $ field => $ definition ) { $ attribute = is_string ( $ definition ) ? $ this -> $ definition : $ definition ( $ this , $ field ) ; if ( $ recursive ) { $ nestedFields = $ this -> extractFieldsFor ( $ fields , $ field ) ; $ nestedExpand = $ this -> extractFieldsFor ( $ expand , $ field ) ; if ( $ attribute instanceof Arrayable ) { $ attribute = $ attribute -> toArray ( $ nestedFields , $ nestedExpand ) ; } elseif ( is_array ( $ attribute ) ) { $ attribute = array_map ( function ( $ item ) use ( $ nestedFields , $ nestedExpand ) { if ( $ item instanceof Arrayable ) { return $ item -> toArray ( $ nestedFields , $ nestedExpand ) ; } return $ item ; } , $ attribute ) ; } } $ data [ $ field ] = $ attribute ; } if ( $ this instanceof Linkable ) { $ data [ '_links' ] = Link :: serialize ( $ this -> getLinks ( ) ) ; } return $ recursive ? ArrayHelper :: toArray ( $ data ) : $ data ; }
9543	public function getMessages ( ) { $ messages = array ( ) ; if ( ! empty ( $ this -> error ) ) { $ messages [ ] = $ this -> error ; } if ( ! empty ( $ this -> warning ) ) { $ messages [ ] = $ this -> warning ; } return $ messages ; }
11266	public function library ( $ pathname , & $ caller = false , $ exposeToView = false ) { $ name = $ this -> getName ( $ pathname ) ; $ path = $ this -> getPath ( $ pathname ) ; if ( $ caller ) { if ( $ this -> getPathBackslash ( $ pathname ) == '' ) { $ lib = '\\Cora\\' . $ name ; } else { $ lib = $ pathname ; } $ libObj = new $ lib ( $ caller ) ; $ caller -> $ name = $ libObj ; if ( $ exposeToView ) $ caller -> setData ( $ name , $ libObj ) ; } }
12142	public static function provider ( ProviderInterface $ provider = null ) { if ( $ provider ) { static :: $ provider = $ provider ; } elseif ( ! static :: $ provider ) { static :: $ provider = new Provider \ Native ( static :: $ root ) ; } return static :: $ provider ; }
11163	protected function getResponseFormat ( array $ config ) { if ( isset ( $ config [ 'responseFormat' ] ) ) { if ( ! is_string ( $ config [ 'responseFormat' ] ) ) { throw new \ DomainException ( 'responseFormat must reference a string' , self :: ERR_INVALID_RESPONSEFORMAT ) ; } return $ config [ 'responseFormat' ] ; } return '[ %link% ] "%title%" by %author%' . '; Length %duration%' . '; Published %published%' . '; Views %views%' . '; Likes %likes%' ; }
6132	protected function getSuffixFlag ( ) { if ( ! $ this -> currObj instanceof Client ) { return "" ; } if ( $ this -> flagpath && $ this -> currObj [ "client_country" ] ) { return $ this -> getImage ( $ this -> currObj [ "client_country" ] -> toLower ( ) . ".png" , $ this -> currObj [ "client_country" ] , null , false , true ) ; } return "" ; }
3835	protected function prepareTemplate ( Template $ objTemplate , $ arrRowData , $ objSettings ) { $ objTemplate -> setData ( array ( 'attribute' => $ this , 'settings' => $ objSettings , 'row' => $ arrRowData , 'raw' => $ arrRowData [ $ this -> getColName ( ) ] , 'additional_class' => $ objSettings -> get ( 'additional_class' ) ? ' ' . $ objSettings -> get ( 'additional_class' ) : '' ) ) ; }
1612	private function _setCriteriaIdByType ( $ criteria , Element $ type , $ id ) { switch ( $ type :: className ( ) ) { case 'Entry' : $ criteria -> sectionId = $ id ; break ; case 'Category' : $ criteria -> groupId = $ id ; break ; } }
2122	public function add ( $ strFile , $ strVersion = null , $ strMedia = 'all' ) { $ strType = strrchr ( $ strFile , '.' ) ; if ( $ strType != self :: CSS && $ strType != self :: JS && $ strType != self :: SCSS && $ strType != self :: LESS ) { throw new \ InvalidArgumentException ( "Invalid file $strFile" ) ; } $ strMode = ( $ strType == self :: JS ) ? self :: JS : self :: CSS ; if ( $ this -> strMode === null ) { $ this -> strMode = $ strMode ; } elseif ( $ this -> strMode != $ strMode ) { throw new \ LogicException ( 'You cannot mix different file types. Create another Combiner object instead.' ) ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ strFile ) ) { if ( file_exists ( $ this -> strRootDir . '/' . $ this -> strWebDir . '/' . $ strFile ) ) { $ strFile = $ this -> strWebDir . '/' . $ strFile ; } else { return ; } } if ( isset ( $ this -> arrFiles [ $ strFile ] ) ) { return ; } if ( $ strVersion === null ) { $ strVersion = filemtime ( $ this -> strRootDir . '/' . $ strFile ) ; } $ arrFile = array ( 'name' => $ strFile , 'version' => $ strVersion , 'media' => $ strMedia , 'extension' => $ strType ) ; $ this -> arrFiles [ $ strFile ] = $ arrFile ; $ this -> strKey .= '-f' . $ strFile . '-v' . $ strVersion . '-m' . $ strMedia ; }
5127	public function readQTime ( ) { $ msec = $ this -> readUInt ( ) ; $ time = strtotime ( 'midnight' ) + $ msec / 1000 ; $ dt = \ DateTime :: createFromFormat ( 'U.u' , sprintf ( '%.6F' , $ time ) ) ; $ dt -> setTimezone ( new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; return $ dt ; }
3250	public function scopeWhereCurrent ( $ query ) { if ( Auth :: guest ( ) ) return $ query ; return $ query -> whereUser ( Auth :: user ( ) -> shopId ) ; }
2508	public function createRequest ( $ messageName , RequestOptionsInterface $ params ) { $ this -> checkMessageIsInWsdl ( $ messageName ) ; $ builder = $ this -> findBuilderForMessage ( $ messageName ) ; if ( $ builder instanceof ConvertInterface ) { return $ builder -> convert ( $ params , $ this -> getActiveVersionFor ( $ messageName ) ) ; } else { throw new \ RuntimeException ( 'No builder found for message ' . $ messageName ) ; } }
11088	public static function getUserBrowser ( ) { $ user_agent = $ _SERVER [ 'HTTP_USER_AGENT' ] ; $ user_browser = 'unknown' ; if ( false !== stripos ( $ user_agent , 'MSIE' ) && false === stripos ( $ user_agent , 'Opera' ) ) { $ user_browser = 'Internet Explorer' ; } elseif ( false !== stripos ( $ user_agent , 'Firefox' ) ) { $ user_browser = 'Mozilla Firefox' ; } elseif ( false !== stripos ( $ user_agent , 'Chrome' ) ) { $ user_browser = 'Google Chrome' ; } elseif ( false !== stripos ( $ user_agent , 'Safari' ) ) { $ user_browser = 'Apple Safari' ; } elseif ( false !== stripos ( $ user_agent , 'Opera' ) ) { $ user_browser = 'Opera' ; } elseif ( false !== stripos ( $ user_agent , 'Netscape' ) ) { $ user_browser = 'Netscape' ; } return $ user_browser ; }
4636	public function send ( $ email , array $ options = [ ] ) : ResultInterface { if ( is_string ( $ email ) ) { $ email = $ this -> emailBuilder -> build ( $ email , $ options ) ; } elseif ( is_array ( $ email ) ) { $ email = $ this -> emailBuilder -> build ( Email :: class , $ email ) ; } elseif ( ! $ email instanceof Email ) { throw Exception \ InvalidArgumentException :: fromValidTypes ( [ 'string' , 'array' , Email :: class ] , $ email , 'email' ) ; } $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_PRE_RENDER ) ) ; $ this -> renderEmailBody ( $ email ) ; $ eventResp = $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_PRE_SEND ) ) ; if ( $ eventResp -> contains ( false ) ) { return new MailResult ( $ email , false ) ; } try { $ message = MessageFactory :: createMessageFromEmail ( $ email ) -> setBody ( $ this -> buildBody ( $ email -> getBody ( ) , $ email -> getCharset ( ) ) ) ; $ this -> attachFiles ( $ message , $ email ) ; $ this -> addCustomHeaders ( $ message , $ email ) ; $ this -> transport -> send ( $ message ) ; $ result = new MailResult ( $ email ) ; $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_POST_SEND , $ result ) ) ; return $ result ; } catch ( Throwable $ e ) { $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_SEND_ERROR , new MailResult ( $ email , false , $ e ) ) ) ; throw new Exception \ MailException ( 'An error occurred while trying to send the email' , $ e -> getCode ( ) , $ e ) ; } }
10262	public function getInternet ( $ person_name = null , $ company = null ) { if ( empty ( $ person_name ) ) { $ person_name = $ this -> getFullName ( ) ; } $ internet = new Entities \ Internet ( ) ; $ internet -> domain = $ this -> getDomain ( $ company ) ; $ internet -> username = $ this -> getUserName ( $ person_name ) ; $ internet -> email = $ this -> getEmail ( $ person_name , $ internet -> domain ) ; $ internet -> url = $ this -> getUrl ( $ internet -> domain ) ; $ internet -> ip = $ this -> getIp ( ) ; return $ internet ; }
2484	protected function getAllSearchTargets ( ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = [ ] ; $ searchTargets = $ this -> endpointResolver -> getEndpoints ( ) ; if ( ! empty ( $ searchTargets ) ) { foreach ( $ searchTargets as $ endpointName ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; }
1314	public function url ( $ path , array $ parameters ) { $ this -> resetLastResponse ( ) ; $ this -> response -> setApiPath ( $ path ) ; $ query = http_build_query ( $ parameters ) ; return sprintf ( '%s/%s?%s' , self :: API_HOST , $ path , $ query ) ; }
5275	public function having ( $ column , $ param1 = null , $ param2 = null ) { $ this -> statements [ 'having' ] = $ this -> generateWhere ( $ column , $ param1 , $ param2 , 'having' ) ; return $ this ; }
6572	protected function registerCommands ( ) { $ this -> app [ 'command.countries.migration' ] = $ this -> app -> share ( function ( $ app ) { return new MigrationCommand ( $ app ) ; } ) ; $ this -> commands ( 'command.countries.migration' ) ; }
732	public function evaluateAttributes ( $ event ) { if ( $ this -> skipUpdateOnClean && $ event -> name === ActiveRecord :: EVENT_BEFORE_UPDATE && empty ( $ this -> owner -> dirtyAttributes ) ) { return ; } $ attributes = array_keys ( array_filter ( $ this -> attributes , function ( $ carry ) use ( $ event ) { return array_key_exists ( $ event -> name , $ carry ) ; } ) ) ; if ( ! empty ( $ this -> order [ $ event -> name ] ) ) { $ attributes = array_merge ( array_intersect ( ( array ) $ this -> order [ $ event -> name ] , $ attributes ) , array_diff ( $ attributes , ( array ) $ this -> order [ $ event -> name ] ) ) ; } foreach ( $ attributes as $ attribute ) { if ( $ this -> preserveNonEmptyValues && ! empty ( $ this -> owner -> $ attribute ) ) { continue ; } $ this -> owner -> $ attribute = $ this -> getValue ( $ attribute , $ event ) ; } }
1795	private function addFrontendRoute ( RouteCollection $ routes , array $ defaults ) : void { $ route = new Route ( '/{alias}' . $ this -> urlSuffix , $ defaults , [ 'alias' => '.+' ] ) ; $ this -> addLocaleToRoute ( $ route ) ; $ routes -> add ( 'contao_frontend' , $ route ) ; }
8920	protected function parseRelator ( & $ node , & $ out , $ default = null ) { $ relterm = $ node -> text ( 'marc:subfield[@code="e"]' ) ; $ relcode = $ node -> text ( 'marc:subfield[@code="4"]' ) ; if ( ! empty ( $ relcode ) ) { $ out [ 'role' ] = $ relcode ; } elseif ( ! empty ( $ relterm ) ) { $ out [ 'role' ] = $ relterm ; } elseif ( ! is_null ( $ default ) ) { $ out [ 'role' ] = $ default ; } }
12530	public function apply ( $ quantity , $ reason , $ comment = '' , $ poiId = null ) { $ params = [ 'quantity' => intval ( $ quantity ) , 'apply_reason' => $ reason , ] ; if ( ! empty ( $ comment ) ) { $ params [ 'comment' ] = $ comment ; } if ( ! is_null ( $ poiId ) ) { $ params [ 'poi_id' ] = intval ( $ poiId ) ; } return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_APPLYID , $ params ] ) ; }
5697	public function baseTransform ( ) { parent :: baseTransform ( ) ; $ disabled = ( ! $ this -> gridFieldRequest -> getPreviousRecordID ( ) ) ; return $ this -> setDisabled ( $ disabled ) ; }
6586	protected function request ( array $ options ) { $ this -> info = null ; $ this -> setOpt ( $ options ) ; $ result = $ this -> perform ( 'curl_exec' ) ; $ this -> info = $ this -> perform ( 'curl_getinfo' ) ; return $ result ; }
2691	public function getForceLossyUrl ( ) { $ baseFile = $ this -> getBaseFile ( ) ; $ extension = pathinfo ( $ baseFile , PATHINFO_EXTENSION ) ; $ url = $ this -> getBaseFileUrl ( $ baseFile ) ; if ( $ extension == 'png' || $ extension == 'bmp' ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { $ this -> lossyUrl = $ url . '?format=jpeg' ; } else { $ this -> lossyParam = '&format=jpeg' ; } } }
4839	public function request ( $ method , $ endpoint , $ params = array ( ) ) { if ( ! isset ( $ params [ 'http_authorization' ] ) ) { if ( ! isset ( $ this -> account_details [ 'access_token' ] ) ) { throw new GoCardless_ClientException ( 'Access token missing' ) ; } $ params [ 'http_bearer' ] = $ this -> account_details [ 'access_token' ] ; } if ( isset ( $ this -> account_details [ 'ua_tag' ] ) ) { $ params [ 'ua_tag' ] = $ this -> account_details [ 'ua_tag' ] ; } if ( substr ( $ endpoint , 0 , 6 ) == '/oauth' ) { $ url = $ this -> base_url . $ endpoint ; } else { $ url = $ this -> base_url . self :: $ api_path . $ endpoint ; } return call_user_func ( GoCardless :: getClass ( 'Request' ) . '::' . $ method , $ url , $ params ) ; }
692	protected function createView ( array $ config ) { if ( ! array_key_exists ( 'class' , $ config ) ) { $ config [ 'class' ] = View :: className ( ) ; } return Yii :: createObject ( $ config ) ; }
8723	public function translateOrNew ( $ locale ) { if ( is_null ( $ instance = $ this -> translate ( $ locale ) ) ) { return $ this -> newModelInstance ( ) ; } return $ instance ; }
6383	public function readFeedbackAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'feedback_completed' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/feedback/complete.php?id=' . $ id ; $ model -> name = 'Attempt ' . $ id ; $ model -> responses = $ this -> readStoreRecords ( 'feedback_value' , [ 'completed' => $ id ] ) ; return $ model ; }
1041	public function wait ( Promise $ promise ) { $ this -> beforeWait ( $ promise ) ; $ dfdQueue = Deferred :: getQueue ( ) ; $ promiseQueue = SyncPromise :: getQueue ( ) ; while ( $ promise -> adoptedPromise -> state === SyncPromise :: PENDING && ! ( $ dfdQueue -> isEmpty ( ) && $ promiseQueue -> isEmpty ( ) ) ) { Deferred :: runQueue ( ) ; SyncPromise :: runQueue ( ) ; $ this -> onWait ( $ promise ) ; } $ syncPromise = $ promise -> adoptedPromise ; if ( $ syncPromise -> state === SyncPromise :: FULFILLED ) { return $ syncPromise -> result ; } if ( $ syncPromise -> state === SyncPromise :: REJECTED ) { throw $ syncPromise -> result ; } throw new InvariantViolation ( 'Could not resolve promise' ) ; }
1376	protected function validateTypeMember ( $ value , string $ path ) : bool { if ( ! is_string ( $ value ) ) { $ this -> memberNotString ( $ path , 'type' ) ; return false ; } if ( empty ( $ value ) ) { $ this -> memberEmpty ( $ path , 'type' ) ; return false ; } if ( ! $ this -> store -> isType ( $ value ) ) { $ this -> resourceTypeNotRecognised ( $ value , $ path ) ; return false ; } return true ; }
10469	public function post ( Request $ request ) { $ this -> emit ( 'message.send' , array ( $ request -> xml ( ) ) ) ; $ response = $ this -> connector -> post ( $ request ) ; $ this -> emit ( 'message.recv' , array ( $ response ) ) ; try { return $ this -> parseXml ( $ response ) ; } catch ( InvalidXMLException $ e ) { throw new InvalidNcipResponseException ( 'Invalid response received from the NCIP service "' . $ this -> connector -> url . '": ' . $ response ) ; } }
12362	public function database ( $ db ) { $ connection = $ this -> connection ; $ connection -> db = $ db ; $ this -> constructConnections = $ connection ; $ connection = class_exists ( "Clusterpoint\Connection" ) ? new Connection ( $ this -> constructConnections ) : new StandartConnection ( $ this -> constructConnections ) ; return new Service ( $ connection ) ; }
3434	public function refreshGroups ( ) { if ( $ this -> id === null ) { return [ ] ; } global $ USER ; $ this -> fields [ 'GROUP_ID' ] = $ this -> isCurrent ( ) ? $ USER -> getUserGroupArray ( ) : static :: $ bxObject -> getUserGroup ( $ this -> id ) ; $ this -> groupsAreFetched = true ; return $ this -> fields [ 'GROUP_ID' ] ; }
9927	private function cleanUnwanted ( Parameters $ params , $ permitted ) { foreach ( $ params -> toArray ( ) as $ key => $ value ) { if ( is_array ( $ value ) && ! is_int ( $ key ) ) { if ( ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } elseif ( ! is_int ( $ key ) && ! in_array ( $ key , $ permitted ) && ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } }
89	public function write ( array $ hash , $ options = 448 ) { $ dir = dirname ( $ this -> path ) ; if ( ! is_dir ( $ dir ) ) { if ( file_exists ( $ dir ) ) { throw new \ UnexpectedValueException ( $ dir . ' exists and is not a directory.' ) ; } if ( ! @ mkdir ( $ dir , 0777 , true ) ) { throw new \ UnexpectedValueException ( $ dir . ' does not exist and could not be created.' ) ; } } $ retries = 3 ; while ( $ retries -- ) { try { file_put_contents ( $ this -> path , static :: encode ( $ hash , $ options ) . ( $ options & self :: JSON_PRETTY_PRINT ? "\n" : '' ) ) ; break ; } catch ( \ Exception $ e ) { if ( $ retries ) { usleep ( 500000 ) ; continue ; } throw $ e ; } } }
8112	public static function merge_owners ( SS_List $ groups , SS_List $ members ) { $ contentReviewOwners = new ArrayList ( ) ; if ( $ groups -> count ( ) ) { $ groupIDs = [ ] ; foreach ( $ groups as $ group ) { $ familyIDs = $ group -> collateFamilyIDs ( ) ; if ( is_array ( $ familyIDs ) ) { $ groupIDs = array_merge ( $ groupIDs , array_values ( $ familyIDs ) ) ; } } array_unique ( $ groupIDs ) ; if ( count ( $ groupIDs ) ) { $ groupMembers = DataObject :: get ( Member :: class ) -> where ( "\"Group\".\"ID\" IN (" . implode ( "," , $ groupIDs ) . ")" ) -> leftJoin ( "Group_Members" , "\"Member\".\"ID\" = \"Group_Members\".\"MemberID\"" ) -> leftJoin ( 'Group' , "\"Group_Members\".\"GroupID\" = \"Group\".\"ID\"" ) ; $ contentReviewOwners -> merge ( $ groupMembers ) ; } } $ contentReviewOwners -> merge ( $ members ) ; $ contentReviewOwners -> removeDuplicates ( ) ; return $ contentReviewOwners ; }
4915	private function addArray ( array $ result ) { if ( 1 < count ( $ result ) && ! isset ( $ result [ 'name' ] ) && ! is_string ( $ result [ 0 ] ) ) { foreach ( $ result as $ r ) { if ( is_array ( $ r ) ) { $ this -> add ( $ r ) ; } else { return $ this -> addTraversable ( new \ ArrayIterator ( $ result ) ) ; } } return $ this ; } if ( is_string ( $ result [ 0 ] ) ) { $ result = [ 'name' => $ result [ 0 ] , 'entities' => isset ( $ result [ 1 ] ) ? $ result [ 1 ] : null , 'options' => isset ( $ result [ 2 ] ) && is_array ( $ result [ 2 ] ) ? $ result [ 2 ] : [ 'description' => isset ( $ result [ 2 ] ) ? $ result [ 2 ] : null , 'viewScript' => isset ( $ result [ 3 ] ) ? $ result [ 3 ] : null , ] , ] ; } if ( ! isset ( $ result [ 'name' ] ) || ! isset ( $ result [ 'entities' ] ) ) { throw new \ UnexpectedValueException ( 'Array must have the keys "name" and "entities".' ) ; } if ( ! count ( $ result [ 'entities' ] ) ) { throw new \ UnexpectedValueException ( 'Entities must be non-empty.' ) ; } $ result = new DependencyResult ( $ result [ 'name' ] , $ result [ 'entities' ] , isset ( $ result [ 'options' ] ) ? $ result [ 'options' ] : null ) ; return $ this -> addResult ( $ result ) ; }
6077	public function uploadNewVersionChunked ( $ fileData , $ id , $ revisionComment , $ name , $ chunk , $ chunks , $ fileId ) { $ parameters = [ 'query' => [ 'revisionComment' => $ revisionComment , 'name' => $ name , 'chunk' => $ chunk , 'chunks' => $ chunks , 'fileId' => $ fileId , ] , 'multipart' => [ [ 'name' => 'file' , 'contents' => \ GuzzleHttp \ Psr7 \ stream_for ( $ fileData ) , 'filename' => $ name , ] , ] , 'headers' => null , ] ; $ result = $ this -> post ( 'v1/media.json/' . $ id . '/version' , $ parameters ) ; return $ result ; }
10356	public function lockOut ( ) { $ this -> resetAttempts ( ) ; $ this -> cache -> add ( $ this -> lockOutKey , $ this -> getDelay ( ) + time ( ) , $ this -> getExpiry ( ) ) ; }
11616	public function invite ( $ account , $ wechatId ) { $ params = [ 'kf_account' => $ account , 'invite_wx' => $ wechatId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_INVITE_BIND , $ params ] ) ; }
434	private function isIncorrectClassNameOrPrefix ( $ className , $ prefix ) { if ( ! preg_match ( '%^[a-z][a-z0-9\\-_]*$%' , $ className ) ) { return true ; } if ( $ prefix !== '' && ! preg_match ( '%^[a-z0-9_/]+$%i' , $ prefix ) ) { return true ; } return false ; }
723	public function checkIntegrity ( $ check = true , $ schema = '' , $ table = '' ) { $ enable = $ check ? 'CHECK' : 'NOCHECK' ; $ schema = $ schema ? : $ this -> db -> getSchema ( ) -> defaultSchema ; $ tableNames = $ this -> db -> getTableSchema ( $ table ) ? [ $ table ] : $ this -> db -> getSchema ( ) -> getTableNames ( $ schema ) ; $ viewNames = $ this -> db -> getSchema ( ) -> getViewNames ( $ schema ) ; $ tableNames = array_diff ( $ tableNames , $ viewNames ) ; $ command = '' ; foreach ( $ tableNames as $ tableName ) { $ tableName = $ this -> db -> quoteTableName ( "{$schema}.{$tableName}" ) ; $ command .= "ALTER TABLE $tableName $enable CONSTRAINT ALL; " ; } return $ command ; }
3808	protected function translateProperty ( $ property , $ metaModel , $ legend ) { $ attribute = $ metaModel -> getAttributeById ( $ property [ 'attr_id' ] ) ; if ( ! $ attribute ) { return false ; } $ propName = $ attribute -> getColName ( ) ; $ this -> legends [ $ legend ] [ 'properties' ] [ ] = $ propName ; $ this -> properties [ $ propName ] = array ( 'info' => $ attribute -> getFieldDefinition ( $ property ) , ) ; return true ; }
3057	public function isAdaptive ( AssessmentItemRef $ currentAssessmentItemRef = null ) { return $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> isAdaptive ( $ this -> getTestSession ( ) , $ currentAssessmentItemRef ) ; }
11074	public function setDateTime ( string $ key , $ value , string $ format , string $ ignoredDefaultValue = null ) { if ( $ value instanceof DateTime ) { $ this -> set ( $ key , $ value -> format ( $ format ) , $ ignoredDefaultValue ) ; } return $ this ; }
7106	protected function calculateTotalByState ( PaymentSubjectInterface $ subject , $ state ) { PaymentStates :: isValidState ( $ state , true ) ; $ currency = $ subject -> getCurrency ( ) -> getCode ( ) ; $ total = 0 ; foreach ( $ subject -> getPayments ( ) as $ payment ) { if ( $ payment -> getState ( ) === $ state ) { $ total += $ this -> convertPaymentAmount ( $ payment , $ currency ) ; } } return $ total ; }
10244	public function getImplementedFunctionNames ( ) { $ returnValue = [ ] ; foreach ( self :: $ phpSpreadsheetFunctions as $ functionName => $ function ) { if ( $ this -> isImplemented ( $ functionName ) ) { $ returnValue [ ] = $ functionName ; } } return $ returnValue ; }
2479	protected function getSearchFields ( Criterion $ criterion , $ fieldDefinitionIdentifier , $ fieldTypeIdentifier = null , $ name = null ) { return $ this -> fieldNameResolver -> getFieldTypes ( $ criterion , $ fieldDefinitionIdentifier , $ fieldTypeIdentifier , $ name ) ; }
12008	public function getMessages ( $ domain = 'default' , $ locale = null ) { if ( $ locale === null ) { $ locale = $ this -> getLocale ( ) ; } if ( ! isset ( $ this -> messages [ $ domain ] [ $ locale ] ) ) { $ this -> loadMessages ( $ domain , $ locale ) ; } return $ this -> messages [ $ domain ] [ $ locale ] ; }
2510	public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( self :: Q_G_ERR ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ errorCatNode = $ domXpath -> query ( self :: Q_G_CAT ) -> item ( 0 ) ; $ analyzeResponse -> setStatus ( $ this -> makeStatusForPotentiallyNonExistent ( $ errorCatNode ) ) ; $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( self :: Q_G_MSG ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) , 'general' ) ; } $ errorCodeNodeList = $ domXpath -> query ( self :: Q_D_ERR ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ errorCatNode = $ domXpath -> query ( self :: Q_D_CAT ) -> item ( 0 ) ; $ analyzeResponse -> setStatus ( $ this -> makeStatusForPotentiallyNonExistent ( $ errorCatNode ) ) ; $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( self :: Q_D_MSG ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) , 'deficient_fop' ) ; } return $ analyzeResponse ; }
5087	public function commit ( ) : bool { if ( ! $ this -> isInTransaction ) throw new NotInTransactionException ( ) ; $ this -> isInTransaction = false ; return $ this -> executeDirect ( 'COMMIT' ) ; }
5626	public function addRequestParameter ( $ key , $ value ) { $ this -> raw = false ; $ this -> request -> add ( $ key , $ value ) ; }
10464	private function deductionForDeletion ( $ connection , $ tableName , $ documentType , $ documentId , $ shopId ) { $ sql = sprintf ( "SELECT `id` FROM {$tableName} WHERE `type` != 'D' AND `document_type` = :documentType AND `document_id` = :documentId AND `status` = :status AND `id` < :id" ) ; $ statement = $ connection -> prepare ( $ sql ) ; $ statement -> execute ( [ 'documentType' => $ documentType , 'documentId' => $ documentId , 'status' => self :: STATUS_NEW , 'id' => $ connection -> lastInsertId ( ) , ] ) ; $ entries = $ statement -> fetchAll ( ) ; foreach ( $ entries as $ entry ) { $ this -> removeRecord ( $ entry [ 'id' ] , [ $ shopId ] ) ; } }
9972	public function setCodeName ( $ pValue , $ validate = true ) { if ( $ this -> getCodeName ( ) == $ pValue ) { return $ this ; } if ( $ validate ) { $ pValue = str_replace ( ' ' , '_' , $ pValue ) ; self :: checkSheetCodeName ( $ pValue ) ; if ( $ this -> getParent ( ) ) { if ( $ this -> getParent ( ) -> sheetCodeNameExists ( $ pValue ) ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 29 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 29 ) ; } $ i = 1 ; while ( $ this -> getParent ( ) -> sheetCodeNameExists ( $ pValue . '_' . $ i ) ) { ++ $ i ; if ( $ i == 10 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 28 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 28 ) ; } } elseif ( $ i == 100 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 27 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 27 ) ; } } } $ pValue = $ pValue . '_' . $ i ; } } } $ this -> codeName = $ pValue ; return $ this ; }
5764	public function routeIndexResetFilter ( Request $ request , Response $ response , $ args ) { return $ this -> indexViewObjects ( $ response , true ) ; }
10123	private function writePrintGridlines ( ) { $ record = 0x002b ; $ length = 0x0002 ; $ fPrintGrid = $ this -> phpSheet -> getPrintGridlines ( ) ? 1 : 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fPrintGrid ) ; $ this -> append ( $ header . $ data ) ; }
11185	public function addMatch ( string $ method , string $ uri , $ next ) { $ method = strtoupper ( $ method ) ; if ( ! in_array ( $ method , $ this -> supported_methods ) ) { throw new Exception ( "Method " . $ method . " is not supported." ) ; } if ( ! is_string ( $ uri ) ) { throw new Exception ( "Uri " . $ uri . " is not valid." ) ; } if ( is_callable ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => true , $ this -> ARRAY_CALLABLE_KEY => $ next ) ; } elseif ( is_string ( $ next ) ) { if ( file_exists ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ next ) ; } else { $ dir_next = __DIR__ . "/" . $ next ; if ( file_exists ( $ dir_next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ dir_next ) ; } else { throw new Exception ( "File " . $ next . " not found." ) ; } } } else { throw new Exception ( "Invalid third parameter. Expecting callable or file." ) ; } array_push ( $ this -> match_list , $ new_match ) ; }
7553	protected function match_tags ( $ tags ) { $ res = false ; foreach ( $ tags as $ tag => $ match ) { if ( ! is_array ( $ match ) ) { $ match = array ( 'match' => $ match , 'operator' => 'or' , 'compare' => 'total' , 'case_sensitive' => false ) ; } else { if ( is_int ( $ tag ) ) { $ tag = $ match [ 'tag' ] ; } if ( ! isset ( $ match [ 'match' ] ) ) { $ match [ 'match' ] = true ; } if ( ! isset ( $ match [ 'operator' ] ) ) { $ match [ 'operator' ] = 'or' ; } if ( ! isset ( $ match [ 'compare' ] ) ) { $ match [ 'compare' ] = 'total' ; } if ( ! isset ( $ match [ 'case_sensitive' ] ) ) { $ match [ 'case_sensitive' ] = false ; } } if ( ( $ match [ 'operator' ] === 'and' ) && ( ! $ res ) ) { return false ; } elseif ( ! ( $ res && ( $ match [ 'operator' ] === 'or' ) ) ) { if ( $ match [ 'compare' ] === 'total' ) { $ a = $ this -> tag ; } elseif ( $ match [ 'compare' ] === 'namespace' ) { $ a = $ this -> getNamespace ( ) ; } elseif ( $ match [ 'compare' ] === 'name' ) { $ a = $ this -> getTag ( ) ; } if ( $ match [ 'case_sensitive' ] ) { $ res = ( ( $ a === $ tag ) === $ match [ 'match' ] ) ; } else { $ res = ( ( strcasecmp ( $ a , $ tag ) === 0 ) === $ match [ 'match' ] ) ; } } } return $ res ; }
6109	public function permAssign ( $ permid , $ permvalue ) { return $ this -> getParent ( ) -> channelPermAssign ( $ this -> getId ( ) , $ permid , $ permvalue ) ; }
10697	public function send ( ResponseInterface $ response ) : ResponseInterface { $ response -> getBody ( ) -> write ( json_encode ( $ this -> toArray ( ) ) ) ; return $ response -> withHeader ( 'Content-Type' , self :: MIME_TYPE_JSON ) ; }
295	public function getOldAttribute ( $ name ) { return isset ( $ this -> _oldAttributes [ $ name ] ) ? $ this -> _oldAttributes [ $ name ] : null ; }
12778	public function getRefreshInstructions ( ) { $ i = [ ] ; $ i [ 'type' ] = 'widget' ; $ i [ 'systemId' ] = $ this -> collectorItem -> systemId ; $ i [ 'recreateParams' ] = $ this -> recreateParams ; if ( $ this -> section ) { $ i [ 'section' ] = $ this -> section -> systemId ; } return $ i ; }
1415	public function invalidResource ( string $ path , ? string $ detail = null , array $ failed = [ ] ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'resource_invalid' , 'code' ) , $ this -> trans ( 'resource_invalid' , 'title' ) , $ detail ? : $ this -> trans ( 'resource_invalid' , 'detail' ) , $ this -> pointer ( $ path ) , $ failed ? compact ( 'failed' ) : null ) ; }
631	public function batchInsert ( $ table , $ columns , $ rows ) { $ table = $ this -> db -> quoteSql ( $ table ) ; $ columns = array_map ( function ( $ column ) { return $ this -> db -> quoteSql ( $ column ) ; } , $ columns ) ; $ params = [ ] ; $ sql = $ this -> db -> getQueryBuilder ( ) -> batchInsert ( $ table , $ columns , $ rows , $ params ) ; $ this -> setRawSql ( $ sql ) ; $ this -> bindValues ( $ params ) ; return $ this ; }
248	public function destroy ( ) { if ( $ this -> getIsActive ( ) ) { $ sessionId = session_id ( ) ; $ this -> close ( ) ; $ this -> setId ( $ sessionId ) ; $ this -> open ( ) ; session_unset ( ) ; session_destroy ( ) ; $ this -> setId ( $ sessionId ) ; } }
1885	public function getItemsAsString ( $ strSeparator = ' ' ) { $ arrLinks = array ( ) ; foreach ( $ this -> getItemsAsArray ( ) as $ arrItem ) { if ( $ arrItem [ 'href' ] === null ) { $ arrLinks [ ] = sprintf ( '<li><strong class="active">%s</strong></li>' , $ arrItem [ 'page' ] ) ; } else { $ arrLinks [ ] = sprintf ( '<li><a href="%s" class="link" title="%s">%s</a></li>' , $ arrItem [ 'href' ] , $ arrItem [ 'title' ] , $ arrItem [ 'page' ] ) ; } } return implode ( $ strSeparator , $ arrLinks ) ; }
7017	private function formatG ( & $ str ) { if ( strstr ( $ str , '%G' ) ) $ str = str_replace ( '%G' , sprintf ( '%1d' , $ this -> hour ) , $ str ) ; }
10607	public function checkLoggedInAction ( ) { $ data = array ( 'logged' => 0 , 'data' => null ) ; if ( ! $ this -> zfcUserAuthentication ( ) -> hasIdentity ( ) ) { return new JsonModel ( $ data ) ; } $ identity = $ this -> zfcUserAuthentication ( ) -> getIdentity ( ) ; $ data [ 'logged' ] = 1 ; $ userModel = $ this -> getServiceLocator ( ) -> get ( 'user.model.user' ) ; $ data [ 'data' ] = $ userModel -> init ( $ identity , $ this -> getServiceLocator ( ) ) ; return new JsonModel ( $ data ) ; }
8648	private function addRequiredParameters ( array $ parameters ) { $ parameters [ 'AWSAccessKeyId' ] = $ this -> awsAccessKeyId ; $ parameters [ 'Timestamp' ] = $ this -> getFormattedTimestamp ( new DateTime ( 'now' , new DateTimeZone ( 'UTC' ) ) ) ; $ parameters [ 'Version' ] = self :: SERVICE_VERSION ; $ parameters [ 'SignatureVersion' ] = $ this -> config [ 'SignatureVersion' ] ; if ( $ parameters [ 'SignatureVersion' ] > 1 ) { $ parameters [ 'SignatureMethod' ] = $ this -> config [ 'SignatureMethod' ] ; } $ parameters [ 'Signature' ] = $ this -> signParameters ( $ parameters , $ this -> awsSecretAccessKey ) ; return $ parameters ; }
194	public function sendFile ( $ filePath , $ attachmentName = null , $ options = [ ] ) { if ( ! isset ( $ options [ 'mimeType' ] ) ) { $ options [ 'mimeType' ] = FileHelper :: getMimeTypeByExtension ( $ filePath ) ; } if ( $ attachmentName === null ) { $ attachmentName = basename ( $ filePath ) ; } $ handle = fopen ( $ filePath , 'rb' ) ; $ this -> sendStreamAsFile ( $ handle , $ attachmentName , $ options ) ; return $ this ; }
3249	public function hasItem ( $ sku , $ requireAll = false ) { if ( is_array ( $ sku ) ) { foreach ( $ sku as $ skuSingle ) { $ hasItem = $ this -> hasItem ( $ skuSingle ) ; if ( $ hasItem && ! $ requireAll ) { return true ; } elseif ( ! $ hasItem && $ requireAll ) { return false ; } } return $ requireAll ; } else { foreach ( $ this -> items as $ item ) { if ( $ item -> sku == $ sku ) { return true ; } } } return false ; }
314	public function getVendorPath ( ) { if ( $ this -> _vendorPath === null ) { $ this -> setVendorPath ( $ this -> getBasePath ( ) . DIRECTORY_SEPARATOR . 'vendor' ) ; } return $ this -> _vendorPath ; }
5614	public function paintMethodEnd ( $ message ) { parent :: paintCaseEnd ( $ message ) ; $ node = $ this -> _stack -> pop ( ) ; $ current = $ this -> _stack -> peek ( ) ; if ( $ node -> isFailed ( ) ) { $ current -> fail ( ) ; } $ current -> putChild ( $ node ) ; }
7081	public function onPostCopy ( SaleTransformEvent $ event ) { $ source = $ event -> getSource ( ) ; $ target = $ event -> getTarget ( ) ; $ target -> setOriginNumber ( $ source -> getNumber ( ) ) ; if ( $ source instanceof OrderInterface && $ target instanceof OrderInterface ) { $ target -> setSample ( $ source -> isSample ( ) ) ; } if ( null === $ customer = $ source -> getCustomer ( ) ) { return ; } if ( $ target instanceof OrderInterface && $ customer -> hasParent ( ) ) { $ target -> setCustomer ( $ customer -> getParent ( ) ) ; if ( null === $ target -> getOriginCustomer ( ) ) { $ target -> setOriginCustomer ( $ customer ) ; } } }
4006	protected function createInstance ( CreateMetaModelEvent $ event , $ arrData ) { if ( ! $ this -> createInstanceViaLegacyFactory ( $ event , $ arrData ) ) { $ metaModel = new MetaModel ( $ arrData , $ this -> dispatcher , $ this -> database ) ; $ metaModel -> setServiceContainer ( function ( ) { return $ this -> getServiceContainer ( ) ; } , false ) ; $ event -> setMetaModel ( $ metaModel ) ; } if ( $ event -> getMetaModel ( ) ) { $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] = $ event -> getMetaModel ( ) ; $ this -> instancesById [ $ event -> getMetaModel ( ) -> get ( 'id' ) ] = $ event -> getMetaModel ( ) ; } }
4611	public function get ( $ iSize = 150 , $ sECLevel = 'L' , $ iMargin = 1 ) { return self :: API_URL . $ iSize . 'x' . $ iSize . '&cht=qr&chld=' . $ sECLevel . '|' . $ iMargin . '&chl=' . $ this -> sData ; }
1714	public static function getInstance ( ) { if ( static :: $ objInstance !== null ) { return static :: $ objInstance ; } $ objToken = System :: getContainer ( ) -> get ( 'security.token_storage' ) -> getToken ( ) ; if ( $ objToken !== null && is_a ( $ objToken -> getUser ( ) , static :: class ) ) { return $ objToken -> getUser ( ) ; } $ strUser = System :: getContainer ( ) -> get ( 'contao.security.token_checker' ) -> getBackendUsername ( ) ; if ( $ strUser !== null ) { static :: $ objInstance = static :: loadUserByUsername ( $ strUser ) ; return static :: $ objInstance ; } return parent :: getInstance ( ) ; }
12324	protected function doExecute ( InputInterface $ input , OutputInterface $ output ) { if ( $ this -> askQuestions ( $ input , $ output ) == static :: RETURN_ERROR ) { return static :: RETURN_ERROR ; } $ data = $ this -> prepareData ( $ input ) ; $ this -> doPreExecuteTasks ( $ input , $ output , $ data ) ; $ return = $ this -> executeTasks ( $ input , $ output , $ data ) ; $ this -> doPostExecuteTasks ( $ input , $ output , $ data , $ return ) ; return $ return ; }
12721	public function isShared ( $ abstract ) { if ( ! isset ( $ this -> bindings [ $ abstract ] ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be valid keys in binding container stack." , __METHOD__ ) ) ; } return ( $ this -> bindings [ $ abstract ] [ 'shared' ] ? true : false ) ; }
3583	protected function joinMeta ( Builder $ query , $ column ) { $ query -> prefixColumnsForJoin ( ) ; $ alias = $ this -> generateMetaAlias ( ) ; $ table = ( new Attribute ) -> getTable ( ) ; $ query -> leftJoin ( "{$table} as {$alias}" , function ( $ join ) use ( $ alias , $ column ) { $ join -> on ( "{$alias}.metable_id" , '=' , $ this -> getQualifiedKeyName ( ) ) -> where ( "{$alias}.metable_type" , '=' , $ this -> getMorphClass ( ) ) -> where ( "{$alias}.meta_key" , '=' , $ column ) ; } ) ; return $ alias ; }
10713	public function saveMany ( ArrayAccess $ models ) { if ( ! $ models instanceof Collection ) { $ models = collect ( $ models ) ; } foreach ( $ models as $ model ) { $ this -> save ( $ model ) ; } return $ models ; }
4209	private function methodInfo ( $ obj , \ ReflectionMethod $ reflectionMethod ) { $ declaringClassName = $ reflectionMethod -> getDeclaringClass ( ) -> getName ( ) ; $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionMethod ) ; $ vis = 'public' ; if ( $ reflectionMethod -> isPrivate ( ) ) { $ vis = 'private' ; } elseif ( $ reflectionMethod -> isProtected ( ) ) { $ vis = 'protected' ; } $ info = array ( 'implements' => null , 'inheritedFrom' => $ declaringClassName != \ get_class ( $ obj ) ? $ declaringClassName : null , 'isAbstract' => $ reflectionMethod -> isAbstract ( ) , 'isDeprecated' => $ reflectionMethod -> isDeprecated ( ) || isset ( $ phpDoc [ 'deprecated' ] ) , 'isFinal' => $ reflectionMethod -> isFinal ( ) , 'isStatic' => $ reflectionMethod -> isStatic ( ) , 'params' => $ this -> getParams ( $ reflectionMethod , $ phpDoc ) , 'phpDoc' => $ phpDoc , 'visibility' => $ vis , ) ; unset ( $ info [ 'phpDoc' ] [ 'param' ] ) ; return $ info ; }
8848	public function tag ( ) { $ tag = $ this -> getCurrentTag ( ) ; if ( $ tag ) { $ this -> blogPosts = $ tag -> BlogPosts ( ) ; return $ this -> render ( ) ; } return $ this -> httpError ( 404 , "Not Found" ) ; }
1842	public function process ( ContainerBuilder $ container ) : void { if ( ! $ container -> has ( 'contao.fragment.registry' ) ) { return ; } $ this -> registerFragments ( $ container , ContentElementReference :: TAG_NAME ) ; $ this -> registerFragments ( $ container , FrontendModuleReference :: TAG_NAME ) ; }
9928	protected function valueIsEmpty ( $ value ) { return ( is_object ( $ value ) && $ value instanceof Parameters && $ value -> isEmpty ( ) ) || ( is_array ( $ value ) && ! count ( $ value ) ) ; }
12272	public function exec ( $ calcId ) { $ result = [ ] ; $ dwnlCompress = $ this -> daoBonDwnl -> getByCalcId ( $ calcId ) ; $ mapById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCompress , EBonDwnl :: A_CUST_REF ) ; $ mapDepth = $ this -> hlpDwnlTree -> mapByTreeDepthDesc ( $ dwnlCompress , EBonDwnl :: A_CUST_REF , EBonDwnl :: A_DEPTH ) ; $ mapTeams = $ this -> hlpDwnlTree -> mapByTeams ( $ dwnlCompress , EBonDwnl :: A_CUST_REF , EBonDwnl :: A_PARENT_REF ) ; $ signupDebitCustomers = $ this -> hlpSignUpDebitCust -> exec ( ) ; foreach ( $ mapDepth as $ depth => $ levelCustomers ) { $ this -> logger -> debug ( "Process level #$depth of the downline tree." ) ; foreach ( $ levelCustomers as $ custId ) { $ entity = $ mapById [ $ custId ] ; $ ov = $ entity -> getPv ( ) ; $ isSignUpDebit = in_array ( $ custId , $ signupDebitCustomers ) ; if ( $ isSignUpDebit ) { $ ov += Cfg :: SIGNUP_DEBIT_PV ; } if ( isset ( $ mapTeams [ $ custId ] ) ) { $ team = $ mapTeams [ $ custId ] ; foreach ( $ team as $ memberId ) { $ member = $ result [ $ memberId ] ; $ memberOv = $ member -> getOv ( ) ; $ ov += $ memberOv ; } } $ entity -> setOv ( $ ov ) ; $ result [ $ custId ] = $ entity ; } } unset ( $ mapPv ) ; unset ( $ mapTeams ) ; unset ( $ mapDepth ) ; return $ result ; }
8939	public function closeChangeset ( $ id ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/close' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'format' ] = 'text/xml' ; $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ header ) ; }
6963	public function toDate ( ) { if ( $ this -> dt ) return $ this -> dt ; else return AstroDate :: jd ( $ this -> jd , TimeScale :: TT ( ) ) ; }
7707	function _ApplyDiffToAll ( $ Diff ) { $ this -> PosBeg += $ Diff ; $ this -> PosEnd += $ Diff ; $ this -> pST_PosEnd += $ Diff ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ Diff ; }
2148	public function removeSubscriptions ( $ intUser , $ strMode ) { if ( ! $ intUser ) { return ; } if ( $ strMode == 'close_delete' ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=(SELECT email FROM tl_member WHERE id=?)" ) -> execute ( $ intUser ) ; } else { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active='' WHERE email=(SELECT email FROM tl_member WHERE id=?)" ) -> execute ( $ intUser ) ; } }
7979	public function getSessionProperties ( $ sessId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionProperties ( $ this -> pp , $ this -> sn , $ sessId ) ) ; }
7926	public function fireEvent ( $ event , array $ args = [ ] ) { if ( isset ( $ this -> eventListeners [ $ event ] ) === false ) return $ args ; foreach ( $ this -> eventListeners [ $ event ] as $ listener ) call_user_func_array ( $ listener , $ args ) ; return $ args ; }
9295	public function buildCustomFields ( $ form_fields = [ ] , $ config_name = 'custom_form' ) { $ fields = collect ( $ form_fields ) -> map ( function ( $ field , $ name ) use ( $ config_name ) { return $ this -> render ( isset ( $ field [ 'type' ] ) ? $ field [ 'type' ] : 'text' , [ $ name , $ field [ 'label' ] , [ 'data-table' => $ config_name ] ] ) ; } ) ; return $ fields ; }
2255	protected function eliminateNestedPages ( $ arrPages , $ strTable = null , $ blnSorting = false ) { if ( empty ( $ arrPages ) || ! \ is_array ( $ arrPages ) ) { return array ( ) ; } if ( ! $ strTable ) { $ strTable = 'tl_page' ; } $ arrPages = array_intersect ( $ arrPages , $ this -> Database -> getChildRecords ( 0 , $ strTable , $ blnSorting ) ) ; $ arrPages = array_values ( array_diff ( $ arrPages , $ this -> Database -> getChildRecords ( $ arrPages , $ strTable , $ blnSorting ) ) ) ; return $ arrPages ; }
5991	public function setDeploymentDateRange ( $ deploymentDateRange ) { if ( $ deploymentDateRange instanceof DateTimeRange ) { $ this -> deploymentDateRange = $ deploymentDateRange ; } elseif ( is_array ( $ deploymentDateRange ) ) { $ this -> deploymentDateRange = new DateTimeRange ( $ deploymentDateRange ) ; } else { $ this -> deploymentDateRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
7983	public function addRestoreTask ( $ sessionId ) { return json_decode ( self :: getClient ( ) -> createPcaRestoreTask ( $ this -> pp , $ this -> sn , $ sessionId ) ) ; }
10158	private function readMulBlank ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ row = self :: getUInt2d ( $ recordData , 0 ) ; $ fc = self :: getUInt2d ( $ recordData , 2 ) ; if ( ! $ this -> readDataOnly && $ this -> readEmptyCells ) { for ( $ i = 0 ; $ i < $ length / 2 - 3 ; ++ $ i ) { $ columnString = Coordinate :: stringFromColumnIndex ( $ fc + $ i + 1 ) ; if ( ( $ this -> getReadFilter ( ) !== null ) && $ this -> getReadFilter ( ) -> readCell ( $ columnString , $ row + 1 , $ this -> phpSheet -> getTitle ( ) ) ) { $ xfIndex = self :: getUInt2d ( $ recordData , 4 + 2 * $ i ) ; $ this -> phpSheet -> getCell ( $ columnString . ( $ row + 1 ) ) -> setXfIndex ( $ this -> mapCellXfIndex [ $ xfIndex ] ) ; } } } }
8903	public function delete_by_at ( $ condition , $ time ) { $ this -> prevent_if_not_soft_deletable ( ) ; $ this -> _set_where ( $ condition ) ; return $ this -> _delete ( $ condition , $ time ) ; }
784	protected function validateCache ( $ lastModified , $ etag ) { if ( Yii :: $ app -> request -> headers -> has ( 'If-None-Match' ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getETags ( ) , true ) ; } elseif ( Yii :: $ app -> request -> headers -> has ( 'If-Modified-Since' ) ) { return $ lastModified !== null && @ strtotime ( Yii :: $ app -> request -> headers -> get ( 'If-Modified-Since' ) ) >= $ lastModified ; } return false ; }
8511	public function listInboundShipmentItems ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentItemsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentItemsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipmentItems' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentItemsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3541	public static function getGroupAssigmentOptions ( $ optionName , $ individualGroupAssignmentOptions = null ) { if ( $ individualGroupAssignmentOptions != null && is_array ( $ individualGroupAssignmentOptions ) && array_key_exists ( $ optionName , $ individualGroupAssignmentOptions ) ) { return $ individualGroupAssignmentOptions [ $ optionName ] ; } else if ( isset ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX ) ) { return static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Group-Option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
12370	public static function getArrayItemByPointSeparatedKey ( array & $ data , string $ key ) { if ( strpos ( $ key , '.' ) !== false ) { preg_match ( '/([a-zA-Z0-9_\-]+)\.([a-zA-Z0-9_\-\.]+)/' , $ key , $ keys ) ; if ( ! isset ( $ data [ $ keys [ 1 ] ] ) ) { throw new Exception ( 'Undefined index: ' . $ keys [ 1 ] ) ; } if ( ! is_array ( $ data [ $ keys [ 1 ] ] ) ) { throw new Exception ( "The element indexed {$keys[1]} isn't an array." ) ; } return self :: getArrayItemByPointSeparatedKey ( $ data [ $ keys [ 1 ] ] , $ keys [ 2 ] ) ; } elseif ( isset ( $ data [ $ key ] ) ) { return $ data [ $ key ] ; } else { throw new Exception ( 'Undefined index: ' . $ key ) ; } }
939	public function isWhitespace ( $ whitespaces = " \t\n\r\0\x0B" ) { if ( null === $ whitespaces ) { $ whitespaces = " \t\n\r\0\x0B" ; } if ( $ this -> isArray && ! $ this -> isGivenKind ( T_WHITESPACE ) ) { return false ; } return '' === trim ( $ this -> content , $ whitespaces ) ; }
12897	public function to ( string $ path , int $ status = 301 , array $ headers = array ( ) ) { return $ this -> makeRedirect ( $ path , $ status , $ headers ) ; }
8184	public function getPeakMemoryUsage ( ) { return isset ( $ this -> ends [ 'pmu' ] ) && isset ( $ this -> starts [ 'pmu' ] ) ? $ this -> ends [ 'pmu' ] - $ this -> starts [ 'pmu' ] : 0 ; }
1443	protected function replaceApplicationNamespace ( & $ stub ) { $ namespace = rtrim ( $ this -> laravel -> getNamespace ( ) , '\\' ) ; $ stub = str_replace ( 'DummyApplicationNamespace' , $ namespace , $ stub ) ; return $ this ; }
8343	public static function init ( ) { if ( self :: $ isInit === false ) { self :: $ rawRequest = null ; self :: $ routes = array ( ) ; self :: $ isInit = true ; if ( defined ( 'STRAY_IS_HTTP' ) === true && constant ( 'STRAY_IS_HTTP' ) === true ) { self :: $ rawRequest = new RawRequest ( ) ; Session :: init ( ) ; Locale :: init ( self :: $ rawRequest ) ; } } }
962	public function buildAuthUrl ( $ mode = null ) { return $ this -> api -> getAuthUrl ( Config :: get ( 'shopify-app.api_scopes' ) , URL :: secure ( Config :: get ( 'shopify-app.api_redirect' ) ) , $ mode ?? 'offline' ) ; }
1280	public function extractEnvironmentId ( array $ data ) : string { if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Space' === $ data [ 'sys' ] [ 'type' ] ) { return $ this -> environmentId ; } if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Environment' === $ data [ 'sys' ] [ 'type' ] ) { return $ data [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'sys' ] [ 'environment' ] ) ) { return $ data [ 'sys' ] [ 'environment' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'environment' ] ) ) { return $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'environment' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] ) && ! $ data [ 'items' ] ) { return $ this -> environmentId ; } return 'master' ; }
10989	protected function _setData ( $ key , $ value ) { $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerSet ( $ store , $ key , $ value ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ store ) ; } }
4591	public function setOwnerUuid ( ? string $ ownerUuid ) { if ( null !== $ ownerUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ ownerUuid ) ) { throw new InvalidArgumentException ( 'Owner uuid is not valid.' ) ; } } $ this -> ownerUuid = $ ownerUuid ; return $ this ; }
11915	public static function from ( Reader $ reader , \ Reflector $ reflector ) { if ( $ reflector instanceof \ ReflectionClass ) { return new static ( Psi :: it ( $ reader -> getClassAnnotations ( $ reflector ) ) -> toArray ( ) ) ; } if ( $ reflector instanceof \ ReflectionMethod ) { return new static ( Psi :: it ( $ reader -> getMethodAnnotations ( $ reflector ) ) -> toArray ( ) ) ; } return new static ( ) ; }
5479	protected function addRadioButton ( $ tag ) { if ( ! isset ( $ this -> radios [ $ tag -> getName ( ) ] ) ) { $ this -> widgets [ ] = new SimpleRadioGroup ( ) ; $ this -> radios [ $ tag -> getName ( ) ] = count ( $ this -> widgets ) - 1 ; } $ this -> widgets [ $ this -> radios [ $ tag -> getName ( ) ] ] -> addWidget ( $ tag ) ; }
10180	private function storeCurrentCell ( ) { if ( $ this -> currentCellIsDirty && ! empty ( $ this -> currentCoordinate ) ) { $ this -> currentCell -> detach ( ) ; $ stored = $ this -> cache -> set ( $ this -> cachePrefix . $ this -> currentCoordinate , $ this -> currentCell ) ; if ( ! $ stored ) { $ this -> __destruct ( ) ; throw new PhpSpreadsheetException ( "Failed to store cell {$this->currentCoordinate} in cache" ) ; } $ this -> currentCellIsDirty = false ; } $ this -> currentCoordinate = null ; $ this -> currentCell = null ; }
8811	public function header ( $ key , $ value ) { if ( is_array ( $ key ) && ! empty ( $ key ) ) { foreach ( $ key as $ k => $ v ) { $ this -> headers -> set ( $ k , $ v ) ; } } elseif ( is_string ( $ key ) && ! empty ( $ key ) ) { $ this -> headers -> set ( $ key , $ value ) ; } return $ this ; }
1337	protected function getQueryParameters ( EncodingParametersInterface $ parameters ) { return new EncodingParameters ( $ parameters -> getIncludePaths ( ) , $ parameters -> getFieldSets ( ) , $ parameters -> getSortParameters ( ) ? : $ this -> defaultSort ( ) , $ parameters -> getPaginationParameters ( ) ? : $ this -> defaultPagination ( ) , $ parameters -> getFilteringParameters ( ) , $ parameters -> getUnrecognizedParameters ( ) ) ; }
12197	public static function toBlock ( Serializer $ serializer , $ json ) { if ( empty ( $ json ) ) { return null ; } $ contentArray = json_decode ( $ json , true ) ; if ( ! array_key_exists ( "type" , $ contentArray ) ) { return null ; } $ className = BlockFactory :: getBlockClass ( $ contentArray [ "type" ] ) ; if ( ! class_exists ( $ className ) ) { return null ; } return $ serializer -> deserialize ( $ json , $ className , 'json' ) ; }
8726	public function shouldFallback ( $ locale = null ) { if ( ! $ this -> getWithFallback ( ) || ! $ this -> getFallbackLocale ( ) ) { return false ; } $ locale = $ locale ? : $ this -> getLocale ( ) ; return $ locale != $ this -> getFallbackLocale ( ) ; }
2391	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> calendarfeeds ) || ! \ is_array ( $ this -> User -> calendarfeeds ) ) { $ root = array ( 0 ) ; } else { $ root = $ this -> User -> calendarfeeds ; } if ( \ in_array ( $ insertId , $ root ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_calendar_feed' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_calendar_feed' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, calendarfeeds, calendarfeedp FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrCalendarfeedp = Contao \ StringUtil :: deserialize ( $ objGroup -> calendarfeedp ) ; if ( \ is_array ( $ arrCalendarfeedp ) && \ in_array ( 'create' , $ arrCalendarfeedp ) ) { $ arrCalendarfeeds = Contao \ StringUtil :: deserialize ( $ objGroup -> calendarfeeds , true ) ; $ arrCalendarfeeds [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET calendarfeeds=? WHERE id=?" ) -> execute ( serialize ( $ arrCalendarfeeds ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT calendarfeeds, calendarfeedp FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrCalendarfeedp = Contao \ StringUtil :: deserialize ( $ objUser -> calendarfeedp ) ; if ( \ is_array ( $ arrCalendarfeedp ) && \ in_array ( 'create' , $ arrCalendarfeedp ) ) { $ arrCalendarfeeds = Contao \ StringUtil :: deserialize ( $ objUser -> calendarfeeds , true ) ; $ arrCalendarfeeds [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET calendarfeeds=? WHERE id=?" ) -> execute ( serialize ( $ arrCalendarfeeds ) , $ this -> User -> id ) ; } } $ root [ ] = $ insertId ; $ this -> User -> calendarfeeds = $ root ; } }
4407	public function getCurrentMenuPlugin ( ) { $ currentRequest = $ this -> requestStack -> getCurrentRequest ( ) ; if ( ! $ currentRequest instanceof Request ) { return false ; } foreach ( $ this -> menuPluginRegistry -> getMenuPlugins ( ) as $ identifier => $ menuPlugin ) { if ( $ menuPlugin -> matches ( $ currentRequest ) ) { return $ identifier ; } } return false ; }
4420	public function onKernelBuilt ( PostBuildKernelEvent $ event ) { $ currentRequest = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ currentRequest === null || ! $ event -> getKernelHandler ( ) instanceof ezpWebBasedKernelHandler || $ this -> configResolver -> getParameter ( 'legacy_mode' ) === true || ! $ this -> isUserAuthenticated ( ) ) { return ; } $ currentRequest -> getSession ( ) -> set ( 'eZUserLoggedInID' , $ this -> repository -> getCurrentUser ( ) -> id ) ; }
11925	public function generate ( string $ outputDir ) : array { $ generatedFiles = [ ] ; foreach ( $ this -> generators as $ generator ) { $ this -> logger -> info ( 'Running generator ' . get_class ( $ generator ) ) ; $ result = $ generator -> generate ( ) ; foreach ( $ result -> all ( ) as $ phpFile ) { $ path = str_replace ( [ '/' , "\\" ] , DIRECTORY_SEPARATOR , $ outputDir . '/' . $ phpFile -> getFqcn ( ) -> getNamespace ( ) ) ; BaseUtil :: ensureDirectory ( $ path , 0711 ) ; $ filePath = $ path . DIRECTORY_SEPARATOR . $ phpFile -> getFqcn ( ) -> getName ( ) . '.php' ; $ this -> logger -> info ( 'Writing to file ' . $ filePath ) ; file_put_contents ( $ filePath , $ phpFile -> getText ( ) ) ; $ generatedFiles [ ] = new GeneratedFile ( $ filePath , $ phpFile ) ; } } return $ generatedFiles ; }
9554	public function naming ( $ namer ) { if ( $ namer instanceof \ Closure ) { $ namer = new ClosureNamer ( $ namer ) ; } $ this -> namer = $ namer ; return $ this ; }
9761	function containOnlyInstancesOf ( string $ className ) : self { return $ this -> expect ( $ this -> target , containsOnlyInstancesOf ( $ className ) ) ; }
4759	protected function transformTemplate ( Template $ template ) { return array ( 'template' => $ template -> getTemplate ( ) , 'engine' => $ template -> getEngine ( ) , 'vars' => $ this -> transform ( $ template -> getVars ( ) ) , 'streamable' => $ this -> transformBoolean ( $ template -> isStreamable ( ) ) , ) ; }
6674	public function restart_when_add ( ) { $ state = isset ( $ _POST [ 'state' ] ) ? $ _POST [ 'state' ] : null ; $ nonce = isset ( $ _POST [ 'nonce' ] ) ? $ _POST [ 'nonce' ] : '' ; if ( ! wp_verify_nonce ( $ nonce , 'eliasis' ) && ! wp_verify_nonce ( $ nonce , 'customRatingGrifusAdmin' ) ) { die ( 'Busted!' ) ; } App :: setCurrentID ( 'EFG' ) ; $ slug = Module :: CustomRatingGrifus ( ) -> getOption ( 'slug' ) ; $ this -> model -> set_restart_when_add ( $ slug , $ state ) ; $ response = [ 'restart-when-add' => $ state ] ; echo json_encode ( $ response ) ; die ( ) ; }
4910	public function renderSummary ( SummaryFormInterface $ form ) { $ form -> prepare ( ) ; $ baseFieldset = $ form -> getBaseFieldset ( ) ; if ( ! isset ( $ baseFieldset ) ) { throw new \ InvalidArgumentException ( 'For the Form ' . get_class ( $ form ) . ' there is no Basefieldset' ) ; } $ dataAttributesMarkup = '' ; foreach ( $ form -> getAttributes ( ) as $ dataKey => $ dataValue ) { if ( preg_match ( '/^data-/' , $ dataKey ) ) { $ dataAttributesMarkup .= sprintf ( ' %s="%s"' , $ dataKey , $ dataValue ) ; } } $ markup = '<div class="panel panel-default" style="min-height: 100px;"' . $ dataAttributesMarkup . '> <div class="panel-body"><div class="sf-controls">%s</div>%s</div></div>' ; $ view = $ this -> getView ( ) ; $ buttonMarkup = false === $ form -> getOption ( 'editable' ) ? '' : '<button type="button" class="btn btn-default btn-xs sf-edit">' . '<span class="yk-icon yk-icon-edit"></span> ' . $ view -> translate ( 'Edit' ) . '</button>' ; if ( ( $ controlButtons = $ form -> getOption ( 'control_buttons' ) ) !== null ) { $ buttonMarkup .= PHP_EOL . implode ( PHP_EOL , array_map ( function ( array $ buttonSpec ) use ( $ view ) { return '<button type="button" class="btn btn-default btn-xs' . ( isset ( $ buttonSpec [ 'class' ] ) ? ' ' . $ buttonSpec [ 'class' ] : '' ) . '">' . ( isset ( $ buttonSpec [ 'icon' ] ) ? '<span class="yk-icon yk-icon-' . $ buttonSpec [ 'icon' ] . '"></span> ' : '' ) . $ view -> translate ( $ buttonSpec [ 'label' ] ) . '</button>' ; } , $ controlButtons ) ) ; } $ elementMarkup = $ this -> renderSummaryElement ( $ baseFieldset ) ; return sprintf ( $ markup , $ buttonMarkup , $ elementMarkup ) ; }
9135	public static function parseUrl ( $ url ) : Url { $ parts = parse_url ( $ url ) ; if ( false === $ parts || false === Arrays :: hasElement ( $ parts , 'host' ) || false === Arrays :: hasElement ( $ parts , 'scheme' ) ) { throw new InvalidUrlException ( 'The URL {url} does not contain necessary parts' , array ( 'url' => $ url ) ) ; } $ address = $ parts [ 'host' ] ; $ scheme = $ parts [ 'scheme' ] ; $ query = ( isset ( $ parts [ 'query' ] ) ? $ parts [ 'query' ] : '' ) ; $ port = 0 ; $ path = "/" ; if ( isset ( $ parts [ 'port' ] ) ) { $ port = intval ( $ parts [ 'port' ] ) ; } if ( $ port == 0 ) { $ port = self :: getPortByScheme ( $ scheme ) ; } if ( isset ( $ parts [ 'path' ] ) ) { $ path = $ parts [ 'path' ] ; } return new Url ( $ address , $ port , $ path , $ scheme , $ query ) ; }
6057	public function removeMediaFromFolder ( $ folderId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/folders/' . $ folderId . '/media/' . $ mediaId . '' , $ parameters ) ; return $ result ; }
384	protected function validateImage ( $ image ) { if ( false === ( $ imageInfo = getimagesize ( $ image -> tempName ) ) ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } list ( $ width , $ height ) = $ imageInfo ; if ( $ width == 0 || $ height == 0 ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } if ( $ this -> minWidth !== null && $ width < $ this -> minWidth ) { return [ $ this -> underWidth , [ 'file' => $ image -> name , 'limit' => $ this -> minWidth ] ] ; } if ( $ this -> minHeight !== null && $ height < $ this -> minHeight ) { return [ $ this -> underHeight , [ 'file' => $ image -> name , 'limit' => $ this -> minHeight ] ] ; } if ( $ this -> maxWidth !== null && $ width > $ this -> maxWidth ) { return [ $ this -> overWidth , [ 'file' => $ image -> name , 'limit' => $ this -> maxWidth ] ] ; } if ( $ this -> maxHeight !== null && $ height > $ this -> maxHeight ) { return [ $ this -> overHeight , [ 'file' => $ image -> name , 'limit' => $ this -> maxHeight ] ] ; } return null ; }
9003	protected function extra_tablenav ( $ which ) { if ( $ which !== 'top' ) { return ; } $ this -> months_dropdown ( '' ) ; $ selected = isset ( $ _GET [ 'level' ] ) ? $ _GET [ 'level' ] : '' ; ?> <label for="filter-by-level" class="screen-reader-text"> <?php echo $ this -> translations [ 'levelFilterLabel' ] ; ?> </label> <select name="level" id="filter-by-level"> <option value=""> <?php echo $ this -> translations [ 'allLevels' ] ; ?> </option> <?php foreach ( $ this -> get_levels ( ) as $ level => $ label ) : ?> <option value=" <?php echo esc_attr ( $ level ) ; ?> " <?php selected ( $ selected , $ level ) ; ?> > <?php echo $ label ; ?> </option> <?php endforeach ; ?> </select> <?php submit_button ( $ this -> translations [ 'filter' ] , 'button' , 'filter_action' , false ) ; }
3407	public function setLockStore ( StoreInterface $ store ) : Factory { $ this -> lockFactory = new Factory ( $ store ) ; return $ this -> lockFactory ; }
7281	public function forward ( $ host , array $ headers = [ ] ) { return Curl :: create ( $ this -> method , $ host . $ this -> url , $ this -> inputs , array_merge ( $ this -> headers , $ headers ) ) ; }
7564	protected function parse_compare ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { switch ( $ this -> doc [ $ this -> pos ++ ] ) { case '$' : return ( $ this -> token = self :: TOK_COMPARE_ENDS ) ; case '%' : return ( $ this -> token = self :: TOK_COMPARE_REGEX ) ; case '^' : return ( $ this -> token = self :: TOK_COMPARE_STARTS ) ; case '<' : return ( $ this -> token = self :: TOK_COMPARE_SMALLER_THAN ) ; } } return false ; }
7138	protected function getConstraintsForStep ( $ step ) { $ constraints = [ new Valid ( ) ] ; if ( $ step === static :: SHIPMENT_STEP ) { $ constraints [ ] = new Constraints \ SaleShipmentStep ( ) ; } if ( $ step === static :: PAYMENT_STEP ) { $ constraints [ ] = new Constraints \ SaleShipmentStep ( ) ; $ constraints [ ] = new Constraints \ RelayPoint ( ) ; $ constraints [ ] = new Constraints \ SalePaymentStep ( ) ; } return $ constraints ; }
2372	public static function toXhtml ( $ strString ) { $ arrPregReplace = array ( '/<(br|hr|img)([^>]*)>/i' => '<$1$2 />' , '/ border="[^"]*"/' => '' ) ; $ arrStrReplace = array ( '/ />' => ' />' , '<b>' => '<strong>' , '</b>' => '</strong>' , '<i>' => '<em>' , '</i>' => '</em>' , '<u>' => '<span style="text-decoration:underline">' , '</u>' => '</span>' , ' target="_self"' => '' , ' target="_blank"' => ' onclick="return !window.open(this.href)"' ) ; $ strString = preg_replace ( array_keys ( $ arrPregReplace ) , $ arrPregReplace , $ strString ) ; $ strString = str_ireplace ( array_keys ( $ arrStrReplace ) , $ arrStrReplace , $ strString ) ; return $ strString ; }
9586	public function scaffoldFormField ( $ title = null , $ params = null ) { $ field = new ExternalURLField ( $ this -> name , $ title ) ; $ field -> setMaxLength ( $ this -> getSize ( ) ) ; return $ field ; }
4540	public function get ( string $ key ) { $ config = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ config ) { throw new OutOfRangeException ( 'Config "' . $ key . '" does not exist.' ) ; } $ this -> manager -> detach ( $ config ) ; return $ config -> getValue ( ) ; }
8143	public function getLexer ( ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 1.25 and will be removed in 2.0.' , __FUNCTION__ ) , E_USER_DEPRECATED ) ; if ( null === $ this -> lexer ) { $ this -> lexer = new Twig_Lexer ( $ this ) ; } return $ this -> lexer ; }
10487	public function applyMapping ( $ params , $ mapping ) { $ newParams = [ ] ; foreach ( $ params as $ key => $ value ) { $ newParams [ $ mapping [ $ key ] ] = $ value ; } return $ newParams ; }
10079	public static function strCaseReverse ( $ pValue ) { $ characters = self :: mbStrSplit ( $ pValue ) ; foreach ( $ characters as & $ character ) { if ( self :: mbIsUpper ( $ character ) ) { $ character = mb_strtolower ( $ character , 'UTF-8' ) ; } else { $ character = mb_strtoupper ( $ character , 'UTF-8' ) ; } } return implode ( '' , $ characters ) ; }
12763	public function remove ( $ name , $ path = null , $ domain = null , $ secure = false , $ httpOnly = false ) { if ( $ this -> exists ( $ name ) ) { $ expire = time ( ) - ( 3600 * 24 * 365 ) ; $ this -> set ( $ name , '' , $ expire , $ path , $ domain , $ secure , $ httpOnly ) ; } }
2642	public function cleanAll ( ) { if ( $ this -> purged == true ) { return true ; } $ this -> purged = true ; $ type = 'clean/purge all' ; $ uri = $ this -> _getApiServiceUri ( ) . 'purge_all' ; $ result = $ this -> _purge ( $ uri , null ) ; if ( $ result [ 'status' ] ) { $ this -> logger -> execute ( 'clean all items' ) ; } $ canPublishPurgeAllChanges = $ this -> config -> canPublishPurgeAllChanges ( ) ; $ canPublishPurgeChanges = $ this -> config -> canPublishPurgeChanges ( ) ; if ( $ this -> config -> areWebHooksEnabled ( ) && ( $ canPublishPurgeAllChanges || $ canPublishPurgeChanges ) ) { $ this -> sendWebHook ( '*initiated clean/purge all*' ) ; $ canPublishPurgeAllDebugBacktrace = $ this -> config -> canPublishPurgeAllDebugBacktrace ( ) ; $ canPublishPurgeDebugBacktrace = $ this -> config -> canPublishPurgeDebugBacktrace ( ) ; if ( $ canPublishPurgeAllDebugBacktrace == false && $ canPublishPurgeDebugBacktrace == false ) { return $ result [ 'status' ] ; } $ this -> stackTrace ( $ type ) ; } return $ result [ 'status' ] ; }
10161	private function readPane ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ px = self :: getUInt2d ( $ recordData , 0 ) ; $ py = self :: getUInt2d ( $ recordData , 2 ) ; $ rwTop = self :: getUInt2d ( $ recordData , 4 ) ; $ colLeft = self :: getUInt2d ( $ recordData , 6 ) ; if ( $ this -> frozen ) { $ cell = Coordinate :: stringFromColumnIndex ( $ px + 1 ) . ( $ py + 1 ) ; $ topLeftCell = Coordinate :: stringFromColumnIndex ( $ colLeft + 1 ) . ( $ rwTop + 1 ) ; $ this -> phpSheet -> freezePane ( $ cell , $ topLeftCell ) ; } } }
10462	public function getTableName ( $ shopId = null ) { $ tableName = parent :: getTableName ( ) ; if ( $ shopId === null ) { $ shopId = $ this -> getActiveShopId ( ) ; } if ( ! $ this -> isShopValid ( $ shopId ) ) { throw new InvalidArgumentException ( "Shop id \"{$shopId}\" is invalid." ) ; } $ tableName .= '_' . $ shopId ; try { SqlValidator :: validateTableName ( $ tableName ) ; } catch ( InvalidArgumentException $ e ) { throw new InvalidArgumentException ( "Shop id \"{$shopId}\" is invalid." , 0 , $ e ) ; } return $ tableName ; }
8264	protected function onOAuthError ( $ errorCode ) { $ errorCode = strlen ( $ errorCode > 100 ) ? substr ( $ errorCode , 0 , 100 ) : $ errorCode ; $ this -> logger -> notice ( "OAuth2 error response: code {code}, provider {provider}" , array ( "code" => $ errorCode , "provider" => get_class ( $ this -> provider ) , ) ) ; $ this -> session -> addFlash ( "error" , "The provider returned an error ($errorCode)" ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
4753	private function getContactFormMethod ( ) { $ method = self :: CONTACT_FORM_METHOD_DEFAULT ; if ( $ configMethod = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'OeGdprOptinContactFormMethod' ) ) { $ method = $ configMethod ; } return $ method ; }
6090	public function addMediaToMoodboard ( $ moodboardId , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards/' . $ moodboardId . '/media' , $ parameters ) ; return $ result ; }
2470	public function getMaxDepthForContent ( ContentType $ contentType ) : int { if ( isset ( $ this -> contentTypeMap [ $ contentType -> identifier ] ) ) { return $ this -> contentTypeMap [ $ contentType -> identifier ] ; } return $ this -> defaultIndexingDepth ; }
8324	public function getPingbacks ( ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=get_pingback" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( strpos ( $ responseText , 'OK|' ) !== false ) { $ data = explode ( '|' , $ responseText ) ; unset ( $ data [ 0 ] ) ; return empty ( $ data [ 1 ] ) ? [ ] : array_values ( $ data ) ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
5130	protected function withString ( string $ string , string $ name = 'query' ) : self { $ string = ltrim ( ( string ) $ string , '#' ) ; $ clone = clone $ this ; $ clone -> { $ name } = $ this -> filterQuery ( $ string ) ; return $ clone ; }
6094	public function isUtf8 ( ) { $ pattern = array ( ) ; $ pattern [ ] = "[\xC2-\xDF][\x80-\xBF]" ; $ pattern [ ] = "\xE0[\xA0-\xBF][\x80-\xBF]" ; $ pattern [ ] = "[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}" ; $ pattern [ ] = "\xED[\x80-\x9F][\x80-\xBF]" ; $ pattern [ ] = "\xF0[\x90-\xBF][\x80-\xBF]{2}" ; $ pattern [ ] = "[\xF1-\xF3][\x80-\xBF]{3}" ; $ pattern [ ] = "\xF4[\x80-\x8F][\x80-\xBF]{2}" ; return preg_match ( "%(?:" . implode ( "|" , $ pattern ) . ")+%xs" , $ this -> string ) ; }
4551	public function getList ( $ form ) : array { $ objects = $ this -> execute ( 'GET' , 'http://www.mocky.io/v2/592c3c86110000f8016df7de' ) ; $ list = [ ] ; foreach ( $ objects as $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
8695	public static function format ( $ size , $ decimals = 2 , $ decPoint = '.' , $ thousandsSep = '' , $ unitSep = '' ) { $ output = $ unit = null ; foreach ( self :: getBinarySizes ( ) as $ unit => $ divider ) { $ output = $ size / $ divider ; if ( $ output < 1000 ) { break ; } } if ( null === $ output ) { throw new \ UnexpectedValueException ( "Unable to parse value: '{$size}'" ) ; } $ unit = $ unit === 'o' ? 'o' : ucfirst ( $ unit ) ; $ trimmed = rtrim ( rtrim ( number_format ( $ output , $ decimals , $ decPoint , $ thousandsSep ) , '0' ) , $ decPoint ) ; $ formatted = $ trimmed . $ unitSep . $ unit ; return str_replace ( ' ' , utf8_encode ( chr ( 160 ) ) , $ formatted ) ; }
1953	public static function findActiveBySourceAndParent ( $ strSource , $ intParent , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.source=? AND $t.parent=? AND $t.active='1'" ) , array ( $ strSource , $ intParent ) , $ arrOptions ) ; }
9815	public function setWorksheet ( Worksheet $ value = null ) { if ( $ value !== null ) { $ this -> worksheet = $ value ; } return $ this ; }
8199	public function expect ( $ type , $ value = null , $ message = null ) { $ token = $ this -> tokens [ $ this -> current ] ; if ( ! $ token -> test ( $ type , $ value ) ) { $ line = $ token -> getLine ( ) ; throw new Twig_Error_Syntax ( sprintf ( '%sUnexpected token "%s" of value "%s" ("%s" expected%s).' , $ message ? $ message . '. ' : '' , Twig_Token :: typeToEnglish ( $ token -> getType ( ) ) , $ token -> getValue ( ) , Twig_Token :: typeToEnglish ( $ type ) , $ value ? sprintf ( ' with value "%s"' , $ value ) : '' ) , $ line , $ this -> source ) ; } $ this -> next ( ) ; return $ token ; }
11059	public static function files ( $ path , array $ extensions = array ( ) ) { $ files = array ( ) ; $ it = new \ RecursiveDirectoryIterator ( $ path ) ; $ filter = false ; if ( ! empty ( $ extensions ) && is_array ( $ extensions ) ) { $ filter = true ; } foreach ( new \ RecursiveIteratorIterator ( $ it ) as $ file ) { if ( $ filter ) { $ f = explode ( '.' , $ file ) ; $ ext = strtolower ( array_pop ( $ f ) ) ; if ( in_array ( $ ext , $ extensions ) ) { $ files [ ] = $ file ; } } else { $ files [ ] = $ file ; } } return $ files ; }
10381	protected static function unify_files ( $ params , $ data = '' ) { $ type = $ params [ 'type' ] ; $ routes = $ params [ 'routes' ] ; $ extension = ( 'style' == $ type ) ? '.css' : '.js' ; $ hash = sha1 ( implode ( '' , $ params [ 'files' ] ) ) ; $ min_file = $ routes [ 'path' ] . $ hash . $ extension ; if ( ! is_file ( $ min_file ) || self :: $ changes ) { foreach ( $ params [ 'paths' ] as $ id => $ path ) { if ( isset ( $ params [ 'urls' ] [ $ id ] ) ) { $ url = $ params [ 'urls' ] [ $ id ] ; $ path = $ routes [ 'path' ] . $ params [ 'files' ] [ $ id ] ; $ data .= self :: save_external_file ( $ url , $ path ) ; } $ data .= file_get_contents ( $ path ) ; } $ data = ( self :: $ minify ) ? self :: compress_files ( $ data ) : $ data ; self :: save_file ( $ min_file , $ data ) ; } self :: set_processed_files ( ) ; return self :: set_new_params ( $ type , $ hash , $ routes [ 'url' ] , $ extension ) ; }
2697	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ enabled = false ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ vclPath = Config :: VCL_AUTH_SNIPPET_PATH ; $ snippets = $ this -> config -> getVclSnippets ( $ vclPath ) ; $ status = true ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> getSnippet ( $ activeVersion , $ name ) ; if ( ! $ status ) { break ; } } if ( ! $ status ) { $ this -> api -> checkAuthDictionaryPopulation ( $ activeVersion ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'content' => $ value , 'priority' => 10 ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ enabled = true ; } else { $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ this -> api -> removeSnippet ( $ clone -> number , $ name ) ; } } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ this -> sendWebhook ( $ enabled , $ clone ) ; $ comment = [ 'comment' => 'Magento Module turned ON Basic Authentication' ] ; if ( ! $ enabled ) { $ comment = [ 'comment' => 'Magento Module turned OFF Basic Authentication' ] ; } $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
2660	public function getRequest ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/request_settings/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET , '' , false , null , false ) ; return $ result ; }
5341	protected function call ( $ service , $ method , array $ parameters = [ ] ) { return $ this -> getSoapClient ( $ service , $ method , $ parameters ) -> __call ( $ method , $ parameters ) ; }
1590	protected function invokeMany ( iterable $ hooks , ... $ arguments ) { foreach ( $ hooks as $ hook ) { $ result = $ this -> invoke ( $ hook , ... $ arguments ) ; if ( ! is_null ( $ result ) ) { return $ result ; } } return null ; }
9320	protected function getEchoMethods ( ) { $ methods = [ 'compileRawEchos' => strlen ( stripcslashes ( $ this -> rawTags [ 0 ] ) ) , 'compileEscapedEchos' => strlen ( stripcslashes ( $ this -> escapedTags [ 0 ] ) ) , 'compileMarkdownEchos' => strlen ( stripcslashes ( $ this -> markdownTags [ 0 ] ) ) , 'compileRegularEchos' => strlen ( stripcslashes ( $ this -> contentTags [ 0 ] ) ) , ] ; uksort ( $ methods , function ( $ method1 , $ method2 ) use ( $ methods ) { if ( $ methods [ $ method1 ] > $ methods [ $ method2 ] ) { return - 1 ; } if ( $ methods [ $ method1 ] < $ methods [ $ method2 ] ) { return 1 ; } if ( $ method1 === 'compileRawEchos' ) { return - 1 ; } if ( $ method2 === 'compileRawEchos' ) { return 1 ; } if ( $ method1 === 'compileEscapedEchos' ) { return - 1 ; } if ( $ method2 === 'compileEscapedEchos' ) { return 1 ; } if ( $ method1 === 'compileMarkdownEchos' ) { return - 1 ; } if ( $ method2 === 'compileMarkdownEchos' ) { return 1 ; } } ) ; return $ methods ; }
8431	public function start ( ) { Loop :: run ( function ( ) { $ this -> logger -> info ( sprintf ( "RPQ is now started, and is listening for new jobs every %d ms" , $ this -> config [ 'poll_interval' ] ) , [ 'queue' => $ this -> queue -> getName ( ) ] ) ; $ this -> setIsRunning ( false ) ; Loop :: repeat ( $ this -> config [ 'poll_interval' ] , function ( $ watcherId , $ callback ) { if ( ! $ this -> isRunning ) { return ; } $ this -> queue -> rescheduleJobs ( ) ; if ( count ( $ this -> processes ) === $ this -> config [ 'max_jobs' ] ) { return ; } $ job = $ this -> queue -> pop ( ) ; if ( $ job !== null ) { $ command = sprintf ( 'exec %s %s --jobId=%s --name=%s' , ( $ this -> config [ 'process' ] [ 'script' ] ?? $ _SERVER [ "SCRIPT_FILENAME" ] ) , $ this -> config [ 'process' ] [ 'command' ] , $ job -> getId ( ) , $ this -> queue -> getName ( ) ) ; if ( $ this -> config [ 'process' ] [ 'config' ] === true ) { $ command .= " --config={$this->args['configFile']}" ; } $ process = new Process ( $ command ) ; $ process -> start ( ) ; $ pid = yield $ process -> getPid ( ) ; $ this -> logger -> info ( 'Started worker' , [ 'pid' => $ pid , 'command' => $ command , 'id' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; $ this -> processes [ $ pid ] = [ 'process' => $ process , 'id' => $ job -> getId ( ) ] ; $ stream = $ process -> getStdout ( ) ; while ( $ chunk = yield $ stream -> read ( ) ) { $ this -> logger -> info ( $ chunk , [ 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; } $ code = yield $ process -> join ( ) ; $ this -> jobHandler -> exit ( $ job -> getId ( ) , $ pid , $ code , false , $ this -> config [ 'failed_job_backoff_time' ] ) ; unset ( $ this -> processes [ $ pid ] ) ; } } ) ; $ this -> registerSignals ( ) ; } ) ; }
5718	public function doPublishAndClose ( $ data , $ form ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return $ this -> publish ( $ data , $ form , $ this -> owner , $ this -> getBackLink ( ) ) ; }
9349	public function multiplyAllow ( $ matrix ) { if ( is_numeric ( $ matrix ) ) { return true ; } if ( $ matrix instanceof Complex ) { return true ; } if ( $ matrix instanceof Matrix ) { return $ this -> size -> cols == $ matrix -> rows ; } return false ; }
3442	public function fetchUsing ( $ methodAndParams ) { if ( is_string ( $ methodAndParams ) || empty ( $ methodAndParams [ 'method' ] ) ) { $ this -> fetchUsing = in_array ( $ methodAndParams , [ 'GetNext' , 'getNext' ] ) ? [ 'method' => 'GetNext' , 'params' => [ true , true ] ] : [ 'method' => 'Fetch' ] ; return $ this ; } if ( in_array ( $ methodAndParams [ 'method' ] , [ 'GetNext' , 'getNext' ] ) ) { $ bTextHtmlAuto = isset ( $ methodAndParams [ 'params' ] [ 0 ] ) ? $ methodAndParams [ 'params' ] [ 0 ] : true ; $ useTilda = isset ( $ methodAndParams [ 'params' ] [ 1 ] ) ? $ methodAndParams [ 'params' ] [ 1 ] : true ; $ this -> fetchUsing = [ 'method' => 'GetNext' , 'params' => [ $ bTextHtmlAuto , $ useTilda ] ] ; } else { $ this -> fetchUsing = [ 'method' => 'Fetch' ] ; } return $ this ; }
5461	protected function acceptPageEnd ( ) { while ( count ( $ this -> open_forms ) ) { $ this -> complete_forms [ ] = array_pop ( $ this -> open_forms ) ; } foreach ( $ this -> left_over_labels as $ label ) { for ( $ i = 0 , $ count = count ( $ this -> complete_forms ) ; $ i < $ count ; $ i ++ ) { $ this -> complete_forms [ $ i ] -> attachLabelBySelector ( new SelectById ( $ label -> getFor ( ) ) , $ label -> getText ( ) ) ; } } $ this -> page -> setForms ( $ this -> complete_forms ) ; $ this -> page -> setFrames ( $ this -> loading_frames ) ; }
10779	private function addSessionCookie ( ResponseInterface $ response ) : ResponseInterface { $ params = session_get_cookie_params ( ) ; $ cookie = new SetCookie ( session_name ( ) , session_id ( ) , time ( ) + $ params [ "lifetime" ] , $ params [ "path" ] , $ params [ "domain" ] , $ params [ "secure" ] , $ params [ "httponly" ] ) ; return $ cookie -> addToResponse ( $ response ) ; }
3414	public function fill ( $ fields ) { if ( ! is_array ( $ fields ) ) { return ; } if ( isset ( $ fields [ 'ID' ] ) ) { $ this -> id = $ fields [ 'ID' ] ; } $ this -> fields = $ fields ; $ this -> fieldsAreFetched = true ; if ( method_exists ( $ this , 'afterFill' ) ) { $ this -> afterFill ( ) ; } $ this -> original = $ this -> fields ; }
2027	public static function findPublishedRegularWithoutGuestsByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ") AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( empty ( $ arrOptions [ 'includeRoot' ] ) ) { $ arrColumns [ ] = "$t.type!='root'" ; } if ( FE_USER_LOGGED_IN ) { $ arrColumns [ ] = "$t.guests=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.id" , $ arrIds ) ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
12617	public function removeAttribute ( string $ attributeName ) { if ( isset ( $ this -> attributes [ $ attributeName ] ) ) unset ( $ this -> attributes [ $ attributeName ] ) ; }
2721	private function getMessageInStoreLocale ( StoreInterface $ emulatedStore ) { $ currentStore = $ this -> storeManager -> getStore ( ) ; $ this -> localeResolver -> emulate ( $ emulatedStore -> getId ( ) ) ; $ this -> storeManager -> setCurrentStore ( $ emulatedStore -> getId ( ) ) ; $ message = __ ( 'You are in the wrong store. Click OK to visit the %1 store.' , [ $ emulatedStore -> getName ( ) ] ) -> __toString ( ) ; $ this -> localeResolver -> revert ( ) ; $ this -> storeManager -> setCurrentStore ( $ currentStore -> getId ( ) ) ; return $ message ; }
4435	public static function fromErrorMessage ( string $ error ) : QlessException { $ area = null ; $ message = $ error ; if ( preg_match ( self :: ERROR_MESSAGE_RE , $ error , $ matches ) > 0 ) { $ area = $ matches [ 'area' ] ; $ message = $ matches [ 'message' ] ; } switch ( true ) { case ( $ area === 'Requeue' && stripos ( $ message , 'does not exist' ) !== false ) : case ( stripos ( $ message , 'Job does not exist' ) !== false ) : return new InvalidJobException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job given out to another worker' ) !== false ) : return new JobLostException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job not currently running' ) !== false ) : default : return new QlessException ( $ message , $ area ) ; } }
6816	public function isSameAs ( Adjustment $ adjustment ) : bool { return $ this -> name === $ adjustment -> getName ( ) && $ this -> rate === $ adjustment -> getRate ( ) ; }
4367	protected function emailErr ( Event $ error ) { $ dateTimeFmt = 'Y-m-d H:i:s (T)' ; $ errMsg = $ error [ 'message' ] ; if ( $ error [ 'isHtml' ] ) { $ errMsg = \ strip_tags ( $ errMsg ) ; $ errMsg = \ htmlspecialchars_decode ( $ errMsg ) ; } $ countSince = $ error [ 'stats' ] [ 'countSince' ] ; $ isCli = $ this -> isCli ( ) ; $ subject = $ isCli ? 'Error: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) : 'Website Error: ' . $ _SERVER [ 'SERVER_NAME' ] ; $ subject .= ': ' . $ errMsg . ( $ countSince ? ' (' . $ countSince . 'x)' : '' ) ; $ emailBody = '' ; if ( ! empty ( $ countSince ) ) { $ dateTimePrev = \ date ( $ dateTimeFmt , $ error [ 'stats' ] [ 'tsEmailed' ] ) ; $ emailBody .= 'Error has occurred ' . $ countSince . ' times since last email (' . $ dateTimePrev . ').' . "\n\n" ; } $ emailBody .= '' . 'datetime: ' . \ date ( $ dateTimeFmt ) . "\n" . 'errormsg: ' . $ errMsg . "\n" . 'errortype: ' . $ error [ 'type' ] . ' (' . $ error [ 'typeStr' ] . ')' . "\n" . 'file: ' . $ error [ 'file' ] . "\n" . 'line: ' . $ error [ 'line' ] . "\n" . '' ; if ( ! $ isCli ) { $ emailBody .= '' . 'remote_addr: ' . $ _SERVER [ 'REMOTE_ADDR' ] . "\n" . 'http_host: ' . $ _SERVER [ 'HTTP_HOST' ] . "\n" . 'referer: ' . ( isset ( $ _SERVER [ 'HTTP_REFERER' ] ) ? $ _SERVER [ 'HTTP_REFERER' ] : 'null' ) . "\n" . 'request_uri: ' . $ _SERVER [ 'REQUEST_URI' ] . "\n" . '' ; } if ( ! empty ( $ _POST ) ) { $ emailBody .= 'post params: ' . \ var_export ( $ _POST , true ) . "\n" ; } if ( $ error [ 'type' ] & $ this -> cfg [ 'emailTraceMask' ] ) { $ backtraceStr = $ this -> backtraceStr ( $ error ) ; $ emailBody .= "\n" . ( $ backtraceStr ? 'backtrace: ' . $ backtraceStr : 'no backtrace' ) ; } $ this -> email ( $ this -> cfg [ 'emailTo' ] , $ subject , $ emailBody ) ; return ; }
1627	public function useFiles ( $ path , $ level = 'debug' ) { foreach ( $ this -> loggers as $ logger ) { if ( $ logger instanceof Log ) { $ logger -> useFiles ( $ path , $ level ) ; } } }
12448	static function run_update_ezinfo ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_EX , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( 'ezinfo.php' ) -> maxdepth ( 0 ) ; pake_replace_regexp ( $ files , $ destdir , array ( '/^([\s]{1,25}\x27Version\x27[\s]+=>[\s]+[\x27\x22])(.*)([\x27\x22],?\r?\n?)/m' => '${1}' . $ opts [ 'version' ] [ 'alias' ] . $ opts [ 'releasenr' ] [ 'separator' ] . $ opts [ 'version' ] [ 'release' ] . '$3' , '/^([\s]{1,25}\x27License\x27[\s]+=>[\s]+[\x27\x22])(.*)([\x27\x22],?\r?\n?)/m' => '${1}' . $ opts [ 'version' ] [ 'license' ] . '$3' ) , 1 ) ; $ files = pakeFinder :: type ( 'file' ) -> maxdepth ( 0 ) -> name ( 'extension.xml' ) ; pake_replace_regexp ( $ files , $ destdir , array ( '#^([\s]{1,8}<version>)([^<]*)(</version>\r?\n?)#m' => '${1}' . $ opts [ 'version' ] [ 'alias' ] . $ opts [ 'releasenr' ] [ 'separator' ] . $ opts [ 'version' ] [ 'release' ] . '$3' , '#^([\s]{1,8}<license>)([^<]*)(</license>\r?\n?)#m' => '${1}' . htmlspecialchars ( $ opts [ 'version' ] [ 'license' ] ) . '$3' , '#^([\s]{1,8}<copyright>)Copyright \(C\) 1999-[\d]{4} eZ Systems AS(</copyright>\r?\n?)#m' => '${1}' . 'Copyright (C) 1999-' . strftime ( '%Y' ) . ' eZ Systems AS' . '$2' ) , 1 ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_EX , $ opts ) ; }
9039	public function getByHash ( $ columns , string $ hash ) : ? IEntity { if ( $ this -> manager -> hasher === null ) { throw new MissingServiceException ( 'Hasher is missing' ) ; } return $ this -> toEntity ( $ this -> manager -> hasher -> hashSQL ( $ this -> builder ( ) , $ columns , $ hash ) ) ; }
543	public function init ( ) { parent :: init ( ) ; if ( $ this -> logFile === null ) { $ this -> logFile = Yii :: $ app -> getRuntimePath ( ) . '/logs/app.log' ; } else { $ this -> logFile = Yii :: getAlias ( $ this -> logFile ) ; } if ( $ this -> maxLogFiles < 1 ) { $ this -> maxLogFiles = 1 ; } if ( $ this -> maxFileSize < 1 ) { $ this -> maxFileSize = 1 ; } }
5743	protected function parseContentType ( $ contentType ) { if ( false === stripos ( $ contentType , ';' ) ) { throw new ParserException ( 'ContentType does not contain a \';\'' ) ; } list ( $ mime , $ boundary ) = explode ( ';' , $ contentType , 2 ) ; list ( $ key , $ boundaryValue ) = explode ( '=' , trim ( $ boundary ) , 2 ) ; if ( 'boundary' != $ key ) { throw new ParserException ( 'Boundary does not start with \'boundary=\'' ) ; } return [ strtolower ( trim ( $ mime ) ) , $ boundaryValue ] ; }
9714	private function writeStyle ( ) { $ record = 0x0293 ; $ length = 0x0004 ; $ ixfe = 0x8000 ; $ BuiltIn = 0x00 ; $ iLevel = 0xff ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vCC' , $ ixfe , $ BuiltIn , $ iLevel ) ; $ this -> append ( $ header . $ data ) ; }
3788	public static function calculateConditions ( IMetaModelDataDefinition $ container , array $ inputScreen ) { if ( $ container -> hasDefinition ( ModelRelationshipDefinitionInterface :: NAME ) ) { $ definition = $ container -> getDefinition ( ModelRelationshipDefinitionInterface :: NAME ) ; } else { $ definition = new DefaultModelRelationshipDefinition ( ) ; $ container -> setDefinition ( ModelRelationshipDefinitionInterface :: NAME , $ definition ) ; } if ( ! $ definition instanceof ModelRelationshipDefinitionInterface ) { throw new \ InvalidArgumentException ( 'Search element does not implement the correct interface.' ) ; } $ instance = new static ( ) ; $ instance -> container = $ container ; $ instance -> inputScreen = $ inputScreen ; $ instance -> definition = $ definition ; $ instance -> calculate ( ) ; }
8030	public function takeFreeProcess ( ) { if ( $ this -> getFreeProcessesCount ( ) === 0 ) { return NULL ; } $ freePid = array_shift ( $ this -> freeProcessIds ) ; if ( $ freePid === NULL ) { return NULL ; } return $ this -> getProcessDetails ( $ freePid ) ; }
10516	protected function createPhotosCollection ( Product $ product , $ values ) { $ photos = new ArrayCollection ( ) ; $ identifiers = $ this -> getMediaIdentifiers ( $ values ) ; $ hierarchy = 0 ; foreach ( $ identifiers as $ id ) { $ media = $ this -> getMediaById ( $ id ) ; $ photo = $ this -> getProductPhoto ( $ media , $ product , $ values ) ; $ photo -> setHierarchy ( $ hierarchy ++ ) ; if ( ! $ photos -> contains ( $ photo ) ) { $ photos -> add ( $ photo ) ; } } return $ photos ; }
11237	public function saveUrl ( $ url = false , $ append = '' ) { if ( $ url == false ) { $ url = '//' . $ this -> config [ 'base_url' ] . $ _SERVER [ 'REQUEST_URI' ] ; } $ this -> saved = $ this -> getRedirect ( $ url ) . $ append ; $ this -> session -> savedUrl = $ this -> saved ; }
1753	public static function getCountries ( ) { $ return = array ( ) ; $ countries = array ( ) ; $ arrAux = array ( ) ; static :: loadLanguageFile ( 'countries' ) ; include __DIR__ . '/../../config/countries.php' ; foreach ( $ countries as $ strKey => $ strName ) { $ arrAux [ $ strKey ] = isset ( $ GLOBALS [ 'TL_LANG' ] [ 'CNT' ] [ $ strKey ] ) ? Utf8 :: toAscii ( $ GLOBALS [ 'TL_LANG' ] [ 'CNT' ] [ $ strKey ] ) : $ strName ; } asort ( $ arrAux ) ; foreach ( array_keys ( $ arrAux ) as $ strKey ) { $ return [ $ strKey ] = $ GLOBALS [ 'TL_LANG' ] [ 'CNT' ] [ $ strKey ] ?? $ countries [ $ strKey ] ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getCountries' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getCountries' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getCountries' ] as $ callback ) { static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ return , $ countries ) ; } } return $ return ; }
12946	protected function parseTags ( $ tags ) { return array_unique ( is_array ( $ tags ) ? array_filter ( $ tags ) : preg_split ( '/\s*,\s*/' , $ tags , - 1 , PREG_SPLIT_NO_EMPTY ) ) ; }
12766	public function run ( ) : void { $ this -> isRan = true ; foreach ( $ this -> getAll ( ) as $ header ) { header ( $ header ) ; } }
1680	public function handleUserProfile ( Contao \ DataContainer $ dc ) { if ( Contao \ Input :: get ( 'do' ) != 'login' ) { return ; } if ( Contao \ BackendUser :: getInstance ( ) -> id != Contao \ Input :: get ( 'id' ) || Contao \ Input :: get ( 'act' ) != 'edit' ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not allowed to edit this page.' ) ; } $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'closed' ] = true ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'hideVersionMenu' ] = true ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] = array ( '__selector__' => $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ '__selector__' ] , 'default' => $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ 'login' ] ) ; $ arrFields = Contao \ StringUtil :: trimsplit ( '[,;]' , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ 'default' ] ) ; foreach ( $ arrFields as $ strField ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ strField ] [ 'exclude' ] = false ; } }
7391	public function assign ( $ in ) { $ this -> _massageBlockInput ( $ in ) ; if ( empty ( $ in ) ) { foreach ( $ this -> _publicNames as $ publicName ) { $ this -> __unset ( $ publicName ) ; } } elseif ( is_object ( $ in ) ) { foreach ( $ this -> _publicNames as $ publicName ) { if ( isset ( $ in -> { $ publicName } ) ) { $ this -> _setByName ( $ publicName , $ in -> { $ publicName } ) ; } else { $ this -> __unset ( $ publicName ) ; } } } else { foreach ( $ this -> _publicNames as $ publicName ) { if ( isset ( $ in [ $ publicName ] ) ) { $ this -> _setByName ( $ publicName , $ in [ $ publicName ] ) ; } else { $ this -> __unset ( $ publicName ) ; } } } $ this -> _checkRelatedProperties ( ) ; }
7134	public function findOrCreateGoodLine ( Invoice \ InvoiceInterface $ invoice , Common \ SaleItemInterface $ item , $ available , $ expected = null ) { $ line = null ; if ( 0 >= $ available ) { return $ line ; } foreach ( $ invoice -> getLinesByType ( Document \ DocumentLineTypes :: TYPE_GOOD ) as $ invoiceLine ) { if ( $ invoiceLine -> getSaleItem ( ) === $ item ) { $ line = $ invoiceLine ; } } if ( null === $ line ) { $ line = $ this -> createLine ( $ invoice ) ; $ line -> setInvoice ( $ invoice ) -> setType ( Document \ DocumentLineTypes :: TYPE_GOOD ) -> setSaleItem ( $ item ) -> setDesignation ( $ item -> getDesignation ( ) ) -> setDescription ( $ item -> getDescription ( ) ) -> setReference ( $ item -> getReference ( ) ) ; } $ line -> setAvailable ( $ available ) ; $ line -> setExpected ( $ expected ) ; if ( Invoice \ InvoiceTypes :: isInvoice ( $ invoice ) && null === $ invoice -> getId ( ) ) { $ line -> setQuantity ( min ( $ expected , $ available ) ) ; } return $ line ; }
11514	public function getNamedParams ( string $ category = null ) : array { switch ( $ category ) { case 'attribute' : return $ this -> request -> getAttributes ( ) ; case 'query' : return $ this -> request -> getQueryParams ( ) ; case 'uploaded_files' : return $ this -> request -> getUploadedFiles ( ) ; case 'parsed_body' : { $ body = $ this -> request -> getParsedBody ( ) ; if ( ! $ body ) { return [ ] ; } if ( is_array ( $ body ) ) { return $ body ; } if ( is_object ( $ body ) ) { return get_object_vars ( $ body ) ; } } return [ ] ; case 'server' : return $ this -> request -> getServerParams ( ) ; case 'cookie' : return $ this -> request -> getCookieParams ( ) ; } return [ ] ; }
8751	private function addCurrentMessage ( ) { if ( $ this -> currentMessage -> hasTranslation ( ) ) { $ this -> messages [ ] = $ this -> currentMessage ; $ this -> currentMessage = new Message ( ) ; } }
369	public function getViewNames ( $ schema = '' , $ refresh = false ) { if ( ! isset ( $ this -> _viewNames [ $ schema ] ) || $ refresh ) { $ this -> _viewNames [ $ schema ] = $ this -> findViewNames ( $ schema ) ; } return $ this -> _viewNames [ $ schema ] ; }
9434	public function rho ( $ float_min , $ float_max ) { self :: checkOrder ( $ float_min , $ float_max ) ; if ( $ float_min < 0 || $ float_max < 0 ) { throw new \ InvalidArgumentException ( 'Rho value must be a positive number!' ) ; } if ( $ this -> r || $ this -> i ) { throw new \ RuntimeException ( 'You cannot set rho value, because algebraic form is in use.' ) ; } $ this -> rho = new \ stdClass ( ) ; $ this -> rho -> min = $ float_min ; $ this -> rho -> max = $ float_max ; return $ this ; }
8306	public function assertString ( $ config , $ key ) { if ( array_key_exists ( $ key , $ config ) && ! is_string ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " must be a string." ) ; } return $ this ; }
5183	public function article ( string $ singleJsonArticle ) : Article { if ( json_decode ( $ singleJsonArticle , true ) ) { $ dataArticle = json_decode ( $ singleJsonArticle , true ) [ 'data' ] ; $ article = new Article ( $ this -> filterString ( $ this -> getValue ( 'title' , $ dataArticle ) ) , $ this -> filterString ( $ this -> getValue ( 'body' , $ dataArticle ) ) , $ this -> filterString ( $ this -> getValue ( 'source' , $ dataArticle ) ) , $ this -> getValue ( 'unique_id' , $ dataArticle ) , $ this -> filterInteger ( $ this -> getValue ( 'type_id' , $ dataArticle [ 'type' ] ) ) , $ this -> filterInteger ( $ this -> getValue ( 'category_id' , $ dataArticle [ 'category' ] ) ) , $ this -> getValue ( 'reporter' , $ dataArticle ) , $ this -> filterString ( $ this -> getValue ( 'lead' , $ dataArticle ) ) , $ this -> getValue ( 'tag_name' , $ dataArticle [ 'tags' ] ) , $ this -> filterString ( $ this -> getValue ( 'published_at' , $ dataArticle ) ) , ( string ) $ this -> filterInteger ( $ this -> getValue ( 'id' , $ dataArticle ) ) ) ; $ attachmentConstants = [ Article :: ATTACHMENT_FIELD_PHOTO , Article :: ATTACHMENT_FIELD_PAGE , Article :: ATTACHMENT_FIELD_GALLERY , Article :: ATTACHMENT_FIELD_VIDEO , ] ; $ attachmentTypes = [ self :: JSON_PHOTO_FIELD , self :: JSON_PAGE_FIELD , self :: JSON_GALLERY_FIELD , self :: JSON_VIDEO_FIELD , ] ; $ attachmentAttributes = $ this -> lookUp ( $ attachmentConstants ) ; return $ this -> generalAttachment ( $ article , $ attachmentConstants , $ attachmentTypes , $ attachmentAttributes , $ dataArticle ) ; } throw new \ Exception ( 'Empty or invalid JSON Response' , 1 ) ; }
8162	public function unblock ( ) { $ this -> status = User :: STATUS_ACTIVE ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
9508	public function showByLevel ( Log $ log , $ level ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_SHOW ) ; if ( $ level == 'all' ) return redirect ( ) -> route ( 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ levels = $ this -> logViewer -> levelsNames ( ) ; $ entries = $ this -> logViewer -> entries ( $ log -> date , $ level ) -> paginate ( $ this -> perPage ) ; $ this -> addBreadcrumbRoute ( trans ( 'foundation::log-viewer.titles.logs-list' ) , 'admin::foundation.system.log-viewer.logs.list' ) ; $ this -> setTitle ( $ log -> date . ' | ' . ucfirst ( $ level ) ) ; $ this -> addBreadcrumbRoute ( $ log -> date , 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ this -> addBreadcrumb ( ucfirst ( $ level ) ) ; return $ this -> view ( 'admin.system.log-viewer.show' , compact ( 'log' , 'levels' , 'entries' , 'level' ) ) ; }
7447	function decrypt ( $ data , $ password ) { $ data = base64_decode ( $ data ) ; $ salt = substr ( $ data , 0 , 16 ) ; $ ct = substr ( $ data , 16 ) ; $ rounds = 3 ; $ data00 = $ password . $ salt ; $ hash = array ( ) ; $ hash [ 0 ] = hash ( 'sha256' , $ data00 , true ) ; $ result = $ hash [ 0 ] ; for ( $ i = 1 ; $ i < $ rounds ; $ i ++ ) { $ hash [ $ i ] = hash ( 'sha256' , $ hash [ $ i - 1 ] . $ data00 , true ) ; $ result .= $ hash [ $ i ] ; } $ key = substr ( $ result , 0 , 32 ) ; $ iv = substr ( $ result , 32 , 16 ) ; return openssl_decrypt ( $ ct , 'AES-256-CBC' , $ key , true , $ iv ) ; }
1139	public function shiftSiblingsForRestore ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> increment ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>=' , $ lft ) -> increment ( $ rgtCol , $ diff ) ; } ) ; }
7970	public function deleteBlacklist ( $ domain , $ number ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ number ) throw new BadMethodCallException ( 'Parameter $number is missing.' ) ; try { $ r = $ this -> delete ( 'sms/' . $ domain . '/blacklists/' . $ number ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r ; }
1520	public function removeFromRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doRemoveFromRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; }
3938	private function setExplanation ( PropertyInterface $ property , $ propInfo ) { if ( $ property -> getExplanation ( ) || ! isset ( $ propInfo [ 'explanation' ] ) ) { return ; } $ property -> setExplanation ( $ propInfo [ 'explanation' ] ) ; }
6374	public function transformAndConcat ( callable $ transformer ) : FluentIterable { return self :: from ( Iterables :: concatIterables ( $ this -> transform ( $ transformer ) ) ) ; }
3656	public function boot ( ) { $ environment = System :: getContainer ( ) -> get ( 'contao.framework' ) -> getAdapter ( Environment :: class ) ; $ script = explode ( '?' , $ environment -> get ( 'relativeRequest' ) , 2 ) [ 0 ] ; if ( ( 'contao/login' === $ script ) || ( 'contao/install' === $ script ) ) { return ; } $ connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; if ( ! $ connection -> getSchemaManager ( ) -> tablesExist ( [ 'tl_metamodel' , 'tl_metamodel_dca' , 'tl_metamodel_dca_sortgroup' , 'tl_metamodel_dcasetting' , 'tl_metamodel_dcasetting_condition' , 'tl_metamodel_attribute' , 'tl_metamodel_filter' , 'tl_metamodel_filtersetting' , 'tl_metamodel_rendersettings' , 'tl_metamodel_rendersetting' , 'tl_metamodel_dca_combine' , ] ) ) { System :: getContainer ( ) -> get ( 'logger' ) -> error ( 'MetaModels startup interrupted. Not all MetaModels tables have been created.' ) ; return ; } $ event = new MetaModelsBootEvent ( ) ; $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT , $ event ) ; $ determinator = System :: getContainer ( ) -> get ( 'cca.dc-general.scope-matcher' ) ; switch ( true ) { case $ determinator -> currentScopeIsFrontend ( ) : $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT_FRONTEND , $ event ) ; break ; case $ determinator -> currentScopeIsBackend ( ) : $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT_BACKEND , $ event ) ; break ; default : } }
3153	public function storeTraceVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getTraceVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
10060	public function set ( $ key , $ value ) { $ meta = $ this -> metaModel :: where ( 'key' , $ key ) -> first ( ) ; if ( $ meta === null ) { $ meta = new $ this -> metaModel ; $ meta -> key = $ key ; } $ meta -> value = $ value ; $ meta -> save ( ) ; }
11061	public static function supportedEncodings ( ) { if ( static :: $ supported_encodings === null ) { $ supported = mb_list_encodings ( ) ; foreach ( $ supported as $ key => $ value ) { static :: $ supported_encodings [ strtolower ( $ value ) ] = $ value ; foreach ( mb_encoding_aliases ( $ value ) as $ k => $ v ) { static :: $ supported_encodings [ strtolower ( $ v ) ] = $ value ; } } } return static :: $ supported_encodings ; }
3359	public function preview ( $ width , $ height ) { if ( ! $ width || ! $ height ) { throw new \ Exception ( 'Please, provide both width and height for preview' ) ; } $ result = clone $ this ; $ result -> operations [ ] [ 'preview' ] = array ( 'width' => $ width , 'height' => $ height , ) ; return $ result ; }
4323	public static function buildTag ( $ tagName , $ attribs = array ( ) , $ innerhtml = '' ) { $ tagName = \ strtolower ( $ tagName ) ; $ attribStr = self :: buildAttribString ( $ attribs ) ; return \ in_array ( $ tagName , self :: $ htmlEmptyTags ) ? '<' . $ tagName . $ attribStr . ' />' : '<' . $ tagName . $ attribStr . '>' . $ innerhtml . '</' . $ tagName . '>' ; }
2230	protected function getTargetFolders ( $ strFolder , $ intLevel = 1 ) { $ strFolders = '' ; $ strPath = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFolder ; foreach ( scan ( $ strPath ) as $ strFile ) { if ( ! is_dir ( $ strPath . '/' . $ strFile ) || strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } $ strRelPath = $ strFolder . '/' . $ strFile ; $ strFolders .= sprintf ( '<option value="%s"%s>%s%s</option>' , $ strRelPath , ( ( Contao \ Input :: post ( 'target' ) == $ strRelPath ) ? ' selected="selected"' : '' ) , str_repeat ( ' &nbsp; ' , $ intLevel ) , basename ( $ strRelPath ) ) ; $ strFolders .= $ this -> getTargetFolders ( $ strRelPath , ( $ intLevel + 1 ) ) ; } return $ strFolders ; }
6832	protected function getSupplierOrderItemFromEvent ( ResourceEventInterface $ event ) { $ item = $ event -> getResource ( ) ; if ( ! $ item instanceof SupplierOrderItemInterface ) { throw new InvalidArgumentException ( "Expected instance of SupplierOrderItemInterface." ) ; } return $ item ; }
4750	public function filterPlans ( array $ plans , array $ filters ) : array { foreach ( $ filters as $ key => $ filter ) { if ( array_key_exists ( $ key , current ( $ plans ) ) ) { $ plans = array_filter ( $ plans , function ( $ element ) use ( $ key , $ filter ) { return $ element [ $ key ] == $ filter ; } ) ; } } return $ plans ; }
7661	function SetWordWrap ( ) { if ( $ this -> WordWrap < 1 ) return ; switch ( $ this -> message_type ) { case "alt" : case "alt_attachments" : $ this -> AltBody = $ this -> WrapText ( $ this -> AltBody , $ this -> WordWrap ) ; break ; default : $ this -> Body = $ this -> WrapText ( $ this -> Body , $ this -> WordWrap ) ; break ; } }
7771	protected function fetchMessage ( $ field , $ rule ) { if ( isset ( $ this -> fieldMessages [ $ field ] [ $ rule ] ) ) { return $ this -> fieldMessages [ $ field ] [ $ rule ] ; } if ( isset ( $ this -> ruleMessages [ $ rule ] ) ) { return $ this -> ruleMessages [ $ rule ] ; } return $ this -> usedRules [ $ rule ] -> error ( ) ; }
1980	public static function generateUnwrapped ( $ strScope = TL_MODE , $ blnRaw = false ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return '' ; } $ strMessages = '' ; $ flashBag = $ session -> getFlashBag ( ) ; foreach ( static :: getTypes ( ) as $ strType ) { $ strClass = strtolower ( $ strType ) ; $ arrMessages = $ flashBag -> get ( static :: getFlashBagKey ( $ strType , $ strScope ) ) ; foreach ( array_unique ( $ arrMessages ) as $ strMessage ) { if ( $ strType == 'TL_RAW' || $ blnRaw ) { $ strMessages .= $ strMessage ; } else { $ strMessages .= '<p class="' . $ strClass . '">' . $ strMessage . '</p>' ; } } } return trim ( $ strMessages ) ; }
6261	public function getActionMap ( ) { $ actionMap = ( array ) Configure :: read ( 'SimpleRbac.actionMap' ) ; if ( empty ( $ actionMap ) && $ this -> _config [ 'allowEmptyActionMap' ] === false ) { throw new \ RuntimeException ( 'SimpleRbac.actionMap configuration is empty!' ) ; } return $ actionMap ; }
5770	public function getLoggedInAdministrator ( ) : Administrator { if ( ! isset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { throw new \ Exception ( "No one is logged in" ) ; } if ( null === $ administrator = ( AdministratorsEntityMapper :: getInstance ( ) ) -> getObjectById ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { unset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ; throw new \ Exception ( "Invalid administrator id " . $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] . " in session" ) ; } return $ administrator ; }
3933	private function setDescription ( PropertyInterface $ property , $ propInfo ) { if ( $ property -> getDescription ( ) || ! isset ( $ propInfo [ 'description' ] ) ) { return ; } $ property -> setDescription ( $ propInfo [ 'description' ] ) ; }
4516	public function setSortOrder ( ? string $ sortOrder ) { $ this -> sortOrder = $ sortOrder ; $ this -> _sortOrder = null !== $ sortOrder ; return $ this ; }
7848	private function checkConfig ( ) : void { if ( empty ( $ this -> device ) ) { Log :: warning ( 'Config "message.smsgatewayme.device" is not defined.' ) ; } if ( empty ( $ this -> token ) ) { Log :: warning ( 'Config "message.smsgatewayme.token" is not defined.' ) ; } }
4721	public function processListItems ( Text $ list , array $ options = array ( ) , $ level = 0 ) { $ list -> replace ( '/\n{2,}\z/' , "\n" ) ; $ list -> replace ( '{ (\n)? # leading line = $1 (^[ \t]*) # leading whitespace = $2 (' . $ this -> getPattern ( ) . ') [ \t]+ # list marker = $3 ((?s:.+?) # list item text = $4 (\n{1,2})) (?= \n* (\z | \2 (' . $ this -> getPattern ( ) . ') [ \t]+)) }mx' , function ( Text $ w , Text $ leadingLine , Text $ ls , Text $ m , Text $ item ) use ( $ options , $ level ) { if ( ( string ) $ leadingLine || $ item -> match ( '/\n{2,}/' ) ) { $ this -> markdown -> emit ( 'outdent' , array ( $ item ) ) ; $ this -> markdown -> emit ( 'block' , array ( $ item ) ) ; } else { $ this -> markdown -> emit ( 'outdent' , array ( $ item ) ) ; $ this -> processList ( $ item , $ options , ++ $ level ) ; $ item -> rtrim ( ) ; $ this -> markdown -> emit ( 'inline' , array ( $ item ) ) ; } return $ this -> getRenderer ( ) -> renderListItem ( $ item ) . "\n" ; } ) ; }
7114	static public function isBetterMode ( $ modeA , $ modeB ) { if ( $ modeA === static :: MODE_DISABLED ) { return $ modeB !== static :: MODE_DISABLED ; } elseif ( $ modeA === static :: MODE_JUST_IN_TIME ) { return in_array ( $ modeB , [ static :: MODE_MANUAL , static :: MODE_AUTO ] , true ) ; } return false ; }
3160	protected function storeVariable ( QtiRunnerServiceContext $ context , $ itemUri , \ taoResultServer_models_classes_Variable $ metaVariable , $ itemId = null ) { $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ testUri = $ context -> getTestDefinitionUri ( ) ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; if ( ! is_null ( $ itemUri ) ) { $ resultStore -> storeItemVariable ( $ testUri , $ itemUri , $ metaVariable , $ this -> getTransmissionId ( $ context , $ itemId ) ) ; } else { $ resultStore -> storeTestVariable ( $ testUri , $ metaVariable , $ sessionId ) ; } return true ; }
9604	public function scalarTripleProduct ( self $ b , self $ c ) { return $ this -> dotProduct ( $ b -> crossProduct ( $ c ) ) ; }
12482	private function mapByGeneration ( $ mapByDepthDesc , $ mapById ) { $ result = [ ] ; foreach ( $ mapByDepthDesc as $ depth => $ ids ) { foreach ( $ ids as $ custId ) { $ entry = $ mapById [ $ custId ] ; $ path = $ entry -> getPath ( ) ; $ parents = $ this -> hlpTree -> getParentsFromPathReversed ( $ path ) ; $ level = 0 ; foreach ( $ parents as $ parentId ) { $ level += 1 ; if ( ! isset ( $ result [ $ parentId ] ) ) { $ result [ $ parentId ] = [ ] ; } if ( ! isset ( $ result [ $ parentId ] [ $ level ] ) ) { $ result [ $ parentId ] [ $ level ] = [ ] ; } $ result [ $ parentId ] [ $ level ] [ ] = $ custId ; } } } return $ result ; }
6418	public static function isEmpty ( IteratorAggregate $ iterable ) : bool { return Iterators :: isEmpty ( Iterators :: from ( $ iterable -> getIterator ( ) ) ) ; }
4328	public static function parseAttribString ( $ str , $ dataDecode = true ) { $ attribs = array ( ) ; $ regexAttribs = '/\b([\w\-]+)\b(?: \s*=\s*(["\'])(.*?)\\2 | \s*=\s*(\S+) )?/xs' ; \ preg_match_all ( $ regexAttribs , $ str , $ matches ) ; $ keys = \ array_map ( 'strtolower' , $ matches [ 1 ] ) ; $ values = \ array_replace ( $ matches [ 3 ] , \ array_filter ( $ matches [ 4 ] , 'strlen' ) ) ; foreach ( $ keys as $ i => $ k ) { $ attribs [ $ k ] = $ values [ $ i ] ; if ( \ in_array ( $ k , self :: $ htmlBoolAttr ) ) { $ attribs [ $ k ] = true ; } } \ ksort ( $ attribs ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_string ( $ v ) ) { $ attribs [ $ k ] = \ htmlspecialchars_decode ( $ v ) ; } $ isDataAttrib = \ strpos ( $ k , 'data-' ) === 0 ; if ( $ isDataAttrib && $ dataDecode ) { $ val = $ attribs [ $ k ] ; $ attribs [ $ k ] = \ json_decode ( $ attribs [ $ k ] , true ) ; if ( $ attribs [ $ k ] === null && $ val !== 'null' ) { $ attribs [ $ k ] = \ json_decode ( '"' . $ val . '"' , true ) ; } } } return $ attribs ; }
11230	public function get ( $ section , array $ params = [ ] , $ headers = [ ] ) { $ params = array_merge ( $ this -> parameters , $ params , $ this -> defaultParameters ) ; return $ this -> client -> get ( $ this -> getUrl ( $ section , $ params ) , $ headers ) ; }
8038	public function find ( $ identifier , array $ fields = [ ] ) { $ results = $ this -> ldap -> search ( $ this -> base_dn , $ this -> search_filter . '=' . $ identifier , ( $ fields ? : $ this -> search_fields ) ) ; if ( count ( $ results ) > 0 ) { $ entry = $ this -> ldap -> entry ( $ results ) ; if ( isset ( $ entry [ 0 ] ) && ! empty ( $ entry [ 0 ] ) ) { return $ entry [ 0 ] ; } } throw new EmptySearchResultException ; }
6950	private function getByCountryAndBusinessQuery ( ) { if ( null === $ this -> byCountryAndBusinessQuery ) { $ qb = $ this -> getBaseQueryBuilder ( ) ; $ this -> byCountryAndBusinessQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( 'r.business' , ':business' ) ) -> getQuery ( ) -> setParameter ( 'business' , true ) -> setMaxResults ( 1 ) ; } return $ this -> byCountryAndBusinessQuery ; }
8713	public function orWhereTranslated ( $ column , $ operator = null , $ value = null ) { return $ this -> whereTranslated ( $ column , $ operator , $ value , 'or' ) ; }
3775	public function maxChildren ( $ conditionType ) { $ factory = $ this -> factories -> has ( $ conditionType ) ? $ this -> getFactory ( $ conditionType ) : null ; if ( ! $ factory instanceof NestablePropertyConditionFactoryInterface ) { if ( null !== $ value = $ this -> fallbackFactory -> maxChildren ( $ conditionType ) ) { return $ value ; } return 0 ; } return $ factory -> maxChildren ( ) ; }
12891	protected function redirectCorrectDomainSystemParams ( & $ domainParams ) { $ localizationParamName = static :: URL_PARAM_LOCALIZATION ; if ( isset ( $ domainParams [ $ localizationParamName ] ) ) { $ domainParams [ $ localizationParamName ] = $ this -> redirectLocalizationGetUrlValueAndUnsetGet ( $ domainParams [ $ localizationParamName ] ) ; } }
2576	protected function mergeOptions ( $ existingOptions , $ newOptions ) { if ( ! empty ( $ newOptions ) ) { $ existingOptions = array_merge ( $ existingOptions , $ newOptions ) ; } return $ existingOptions ; }
6060	public function retrieveFileData ( $ id , $ template = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'template' => $ template ] , 'body' => json_encode ( [ ] ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/asset' , $ parameters , $ cachePolicy ) ; return $ result ; }
6040	public function download ( $ sessionId , array $ downloads ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'downloads' => $ downloads ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/download' , $ parameters , true ) ; return $ result ; }
3009	public function fetch ( $ template , array $ data = [ ] ) { if ( isset ( $ data [ 'template' ] ) ) { throw new \ InvalidArgumentException ( "Duplicate template key found" ) ; } if ( ! is_file ( $ this -> templatePath . $ template ) ) { throw new \ RuntimeException ( "View cannot render `$template` because the template does not exist" ) ; } $ data = array_merge ( $ this -> attributes , $ data ) ; try { ob_start ( ) ; $ this -> protectedIncludeScope ( $ this -> templatePath . $ template , $ data ) ; $ output = ob_get_clean ( ) ; if ( $ this -> layout !== null ) { ob_start ( ) ; $ data [ 'content' ] = $ output ; $ this -> protectedIncludeScope ( $ this -> layout , $ data ) ; $ output = ob_get_clean ( ) ; } } catch ( \ Throwable $ e ) { ob_end_clean ( ) ; throw $ e ; } catch ( \ Exception $ e ) { ob_end_clean ( ) ; throw $ e ; } return $ output ; }
7687	function Misc_CellRef ( $ Col , $ Row ) { $ r = '' ; $ x = $ Col ; do { $ x = $ x - 1 ; $ c = ( $ x % 26 ) ; $ x = ( $ x - $ c ) / 26 ; $ r = chr ( 65 + $ c ) . $ r ; } while ( $ x > 0 ) ; return $ r . $ Row ; }
1350	public function none ( string ... $ resourceTypes ) : self { foreach ( $ resourceTypes as $ resourceType ) { $ this -> allow ( $ resourceType , [ ] ) ; } return $ this ; }
5550	public function getRequestData ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getRequestData ( ) ; } return $ this -> frameset -> getRequestData ( ) ; }
11640	public function getData ( ) { if ( is_null ( $ this -> _currentData ) ) { $ this -> _currentDataRaw = $ this -> dataProvider -> getData ( ) ; $ this -> _currentData = [ ] ; $ itemNumber = $ this -> dataProvider -> pagination -> offset ; $ row = 0 ; foreach ( $ this -> _currentDataRaw as $ r ) { $ p = [ 'itemNumber' => $ itemNumber , 'id' => $ r -> primaryKey , 'values' => [ ] ] ; foreach ( $ this -> columns as $ key => $ c ) { $ p [ 'values' ] [ $ key ] = $ c -> getDataValue ( $ row , $ r , false ) ; } $ p [ 'acl' ] = [ ] ; if ( $ this -> owner -> instanceSettings [ 'whoAmI' ] === 'parent' and isset ( $ r -> childObject ) and $ r -> childObject -> hasBehavior ( 'Access' ) ) { $ p [ 'acl' ] = $ r -> childObject -> aclSummary ( ) ; } elseif ( $ this -> owner -> instanceSettings [ 'whoAmI' ] === 'child' and isset ( $ r -> parentObject ) and $ r -> parentObject -> hasBehavior ( 'Access' ) ) { $ p [ 'acl' ] = $ r -> parentObject -> aclSummary ( ) ; } elseif ( $ r -> hasBehavior ( 'Access' ) ) { $ p [ 'acl' ] = $ r -> aclSummary ( ) ; } $ this -> _currentData [ 'item-' . $ itemNumber ] = $ p ; $ row ++ ; $ itemNumber ++ ; } } return $ this -> _currentData ; }
2200	public static function findPublishedByPidAndColumn ( $ intPid , $ strColumn , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.inColumn=?" ) ; $ arrValues = array ( $ intPid , $ strColumn ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
11910	public function getDefaultParams ( ) { $ defaultParams = [ ] ; foreach ( $ this -> parameters as $ parameter ) { if ( $ parameter -> hasDefault ( ) ) { if ( $ parameter -> getIsAPIParameter ( ) == false ) { $ defaultParams [ ] = $ parameter ; } } } return $ defaultParams ; }
1735	public function getProvisionUri ( User $ user , Request $ request ) : string { $ issuer = rawurlencode ( $ request -> getSchemeAndHttpHost ( ) ) ; return sprintf ( 'otpauth://totp/%s:%s?secret=%s&issuer=%s' , $ issuer , rawurlencode ( $ user -> getUsername ( ) ) . '@' . $ issuer , $ this -> getUpperUnpaddedSecretForUser ( $ user ) , $ issuer ) ; }
11228	protected function getUrl ( $ section , array $ uriParams = [ ] ) { $ endpoint = rtrim ( $ this -> getEndpoint ( ) , '/' ) ; $ section = ltrim ( $ section , '/' ) ; $ params = http_build_query ( $ uriParams ) ; if ( $ params ) { return sprintf ( "%s/%s?%s" , $ endpoint , $ section , $ params ) ; } else { return sprintf ( "%s/%s" , $ endpoint , $ section ) ; } }
9848	public function createSignedRequest ( string $ method , string $ uri , string $ body , SigningSecretKey $ key , array $ headers = [ ] ) : RequestInterface { $ signature = \ ParagonIE_Sodium_Compat :: crypto_sign_detached ( $ body , $ key -> getString ( true ) ) ; if ( isset ( $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] ) ) { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] [ ] = Base64UrlSafe :: encode ( $ signature ) ; } else { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] = Base64UrlSafe :: encode ( $ signature ) ; } return new Request ( $ method , Uri :: createFromString ( $ uri ) , new Headers ( $ headers ) , [ ] , [ ] , $ this -> stringToStream ( $ body ) , [ ] ) ; }
6332	public function createResponse ( $ status , $ errorCode , $ errorDescription ) { $ document = new \ DOMDocument ( '1.0' , 'utf-8' ) ; $ document -> formatOutput = false ; $ response = $ document -> appendChild ( $ document -> createElement ( 'SVSPurchaseStatusNotificationResponse' ) ) ; $ result = $ response -> appendChild ( $ document -> createElement ( 'TransactionResult' ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Description' , $ errorDescription ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Code' , $ errorCode ) ) ; $ response -> appendChild ( $ document -> createElement ( 'Status' , $ status ) ) ; $ authentication = $ response -> appendChild ( $ document -> createElement ( 'Authentication' ) ) ; $ checksum = $ authentication -> appendChild ( $ document -> createElement ( 'Checksum' , $ this -> getMerchantPassword ( ) ) ) ; $ checksum -> nodeValue = $ this -> calculateXmlChecksum ( $ document -> saveXML ( ) ) ; return $ document -> saveXML ( ) ; }
10140	private function readRecordData ( $ data , $ pos , $ len ) { $ data = substr ( $ data , $ pos , $ len ) ; if ( $ this -> encryption == self :: MS_BIFF_CRYPTO_NONE || $ pos < $ this -> encryptionStartPos ) { return $ data ; } $ recordData = '' ; if ( $ this -> encryption == self :: MS_BIFF_CRYPTO_RC4 ) { $ oldBlock = floor ( $ this -> rc4Pos / self :: REKEY_BLOCK ) ; $ block = floor ( $ pos / self :: REKEY_BLOCK ) ; $ endBlock = floor ( ( $ pos + $ len ) / self :: REKEY_BLOCK ) ; if ( $ block != $ oldBlock || $ pos < $ this -> rc4Pos || ! $ this -> rc4Key ) { $ this -> rc4Key = $ this -> makeKey ( $ block , $ this -> md5Ctxt ) ; $ step = $ pos % self :: REKEY_BLOCK ; } else { $ step = $ pos - $ this -> rc4Pos ; } $ this -> rc4Key -> RC4 ( str_repeat ( "\0" , $ step ) ) ; while ( $ block != $ endBlock ) { $ step = self :: REKEY_BLOCK - ( $ pos % self :: REKEY_BLOCK ) ; $ recordData .= $ this -> rc4Key -> RC4 ( substr ( $ data , 0 , $ step ) ) ; $ data = substr ( $ data , $ step ) ; $ pos += $ step ; $ len -= $ step ; ++ $ block ; $ this -> rc4Key = $ this -> makeKey ( $ block , $ this -> md5Ctxt ) ; } $ recordData .= $ this -> rc4Key -> RC4 ( substr ( $ data , 0 , $ len ) ) ; $ this -> rc4Pos = $ pos + $ len ; } elseif ( $ this -> encryption == self :: MS_BIFF_CRYPTO_XOR ) { throw new Exception ( 'XOr encryption not supported' ) ; } return $ recordData ; }
8806	protected function ensureFacadeExists ( $ alias ) { if ( file_exists ( $ path = storage_path ( 'cache/facade-' . sha1 ( $ alias ) . '.php' ) ) ) { return $ path ; } file_put_contents ( $ path , $ this -> formatFacadeStub ( $ alias , file_get_contents ( __DIR__ . '/stubs/facade.stub' ) ) ) ; return $ path ; }
11996	static public function doctrine ( $ tableName , $ field , $ length = 16 ) { do { $ generate = self :: generate ( $ length ) ; } while ( self :: doctrineQuery ( $ tableName , $ field , $ generate ) ) ; return $ generate ; }
12230	public function deleteNodes ( $ xpath ) { if ( ! is_string ( $ xpath ) ) { throw new InvalidArgumentException ( 'Argument 1 passed to deleteNodes() must be a string, ' . gettype ( $ xpath ) . ' given' ) ; } $ nodes = $ this -> _xpath ( $ xpath ) ; if ( isset ( $ nodes [ 0 ] ) ) { $ tmp = dom_import_simplexml ( $ nodes [ 0 ] ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { unset ( $ nodes [ 0 ] ) ; } } foreach ( $ nodes as $ node ) { $ node -> deleteSelf ( ) ; } return count ( $ nodes ) ; }
5685	protected function getUrlFromLink ( $ link ) { $ url = $ this -> expandUrl ( $ link -> getHref ( ) ) ; if ( $ link -> getAttribute ( 'target' ) ) { $ url -> setTarget ( $ link -> getAttribute ( 'target' ) ) ; } return $ url ; }
1449	protected function relationshipRules ( $ record , string $ field ) : array { return collect ( $ this -> rules ( $ record ) ) -> filter ( function ( $ v , $ key ) use ( $ field ) { return Str :: startsWith ( $ key , $ field ) ; } ) -> all ( ) ; }
9828	public function getCreateAssociationName ( $ modelName , $ otherModelName ) { return sprintf ( 'auja.%s.%s.create' , $ this -> toUrlName ( $ modelName ) , $ this -> toUrlName ( $ otherModelName ) ) ; }
11745	public function getShakeInfo ( $ ticket , $ needPoi = null ) { $ params = [ 'ticket' => $ ticket , ] ; if ( $ needPoi !== null ) { $ params [ 'need_poi' ] = intval ( $ needPoi ) ; } return $ this -> parseJSON ( 'json' , [ self :: API_GET_SHAKE_INFO , $ params ] ) ; }
453	public function delete ( $ table , $ condition , & $ params ) { $ sql = 'DELETE FROM ' . $ this -> db -> quoteTableName ( $ table ) ; $ where = $ this -> buildWhere ( $ condition , $ params ) ; return $ where === '' ? $ sql : $ sql . ' ' . $ where ; }
1915	protected function getQuestion ( ) { $ this -> generateCaptcha ( ) ; $ question = $ GLOBALS [ 'TL_LANG' ] [ 'SEC' ] [ 'question' . random_int ( 1 , 3 ) ] ; $ question = sprintf ( $ question , $ this -> arrCaptcha [ 'int1' ] , $ this -> arrCaptcha [ 'int2' ] ) ; $ strEncoded = '' ; $ arrCharacters = Utf8 :: str_split ( $ question ) ; foreach ( $ arrCharacters as $ strCharacter ) { $ strEncoded .= sprintf ( '&#%s;' , Utf8 :: ord ( $ strCharacter ) ) ; } return $ strEncoded ; }
1506	protected function buildParams ( EncodingParametersInterface $ parameters ) { return array_filter ( [ QueryParametersParserInterface :: PARAM_FILTER => $ parameters -> getFilteringParameters ( ) , QueryParametersParserInterface :: PARAM_SORT => $ this -> buildSortParams ( ( array ) $ parameters -> getSortParameters ( ) ) ] ) ; }
3116	public function setCatValue ( $ testSessionId , $ assessmentSectionId , $ key , $ value ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setCatValue ( $ assessmentSectionId , $ key , $ value ) ; $ extendedState -> save ( ) ; }
7145	public function add_custom_profile_fields ( $ user ) { $ user_settings = apply_filters ( 'iac_get_user_settings' , array ( ) , $ user -> ID ) ; $ nonce = wp_create_nonce ( 'iac_user_settings' ) ; ?> <h3> <?php _e ( 'Informer?' , $ this -> get_textdomain ( ) ) ; ?> </h3> <table class="form-table"> <tr id="post_subscription"> <th> <label for="post_subscription_checkbox"> <?php _e ( 'Posts subscription' , $ this -> get_textdomain ( ) ) ; ?> </label> </th> <td> <input type="checkbox" id="post_subscription_checkbox" name="post_subscription" value="1" <?php checked ( '1' , $ user_settings [ 'inform_about_posts' ] ) ; ?> /> <span class="description"> <?php _e ( 'Inform about new posts via e-mail, without your own posts.' , $ this -> get_textdomain ( ) ) ; ?> </span> </td> </tr> <tr id="comment_subscription"> <th> <label for="comment_subscription_checkbox"> <?php _e ( 'Comments subscription' , $ this -> get_textdomain ( ) ) ; ?> </label> </th> <td> <input type="checkbox" id="comment_subscription_checkbox" name="comment_subscription" value="1" <?php checked ( '1' , $ user_settings [ 'inform_about_comments' ] ) ; ?> /> <span class="description"> <?php _e ( 'Inform about new comments via e-mail, without your own comments.' , $ this -> get_textdomain ( ) ) ; ?> </span> <input type="hidden" name="iac_nonce" value=" <?php echo $ nonce ; ?> " /> </td> </tr> </table> <?php }
4281	public function stream_tell ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ position = \ ftell ( $ this -> handle ) ; self :: register ( ) ; return $ position ; }
5709	public function getButtonName ( ) { $ raw = $ this -> buttonName ? : $ this -> getButtonText ( ) ; return preg_replace ( '/[^a-z0-9-_]/' , '' , strtolower ( $ this -> getButtonText ( ) ) ) ; }
8271	protected function getKeyEncoder ( $ lockData ) { if ( isset ( $ lockData [ 'encoder' ] ) && is_string ( $ lockData [ 'encoder' ] ) ) { $ name = $ lockData [ 'encoder' ] ; } else { $ name = $ this -> config [ "encoder" ] ; } try { $ instance = $ this -> picoAuth -> getContainer ( ) -> get ( $ name ) ; } catch ( \ Exception $ e ) { throw new \ RuntimeException ( "Specified PageLock encoder not resolvable." ) ; } return $ instance ; }
7566	protected function parse_single ( $ recursive = true ) { if ( ( $ c = $ this -> parse_conditions ( ) ) === false ) { return false ; } $ this -> parse_callback ( $ c , $ recursive , $ this -> search_root ) ; return true ; }
5617	public function getTotalSize ( ) { if ( ! isset ( $ this -> _size ) ) { $ size = $ this -> getSize ( ) ; if ( ! $ this -> isLeaf ( ) ) { foreach ( $ this -> getChildren ( ) as $ child ) { $ size += $ child -> getTotalSize ( ) ; } } $ this -> _size = $ size ; } return $ this -> _size ; }
2744	public function execute ( \ Magento \ Framework \ Event \ Observer $ observer ) { if ( $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> isEnabled ( ) ) { $ this -> purgeCache -> sendPurgeRequest ( ) ; } }
1587	public function pointerForRelationship ( string $ key , string $ default = '/' ) : string { $ field = collect ( explode ( '.' , $ key ) ) -> first ( ) ; if ( ! $ this -> isRelationship ( $ field ) ) { throw new \ InvalidArgumentException ( "Field {$field} is not a relationship." ) ; } $ pointer = $ this -> pointer ( $ key ) ; return Str :: after ( $ pointer , "relationships/{$field}" ) ? : $ default ; }
4841	public function fetch_sub_resource ( $ type , $ params = array ( ) ) { $ endpoint = preg_replace ( '/api\/v[0-9]+\//' , '' , parse_url ( $ this -> sub_resource_uris [ $ type ] , PHP_URL_PATH ) ) ; $ sub_resource_params = array ( ) ; if ( $ param_string = parse_url ( $ this -> sub_resource_uris [ $ type ] , PHP_URL_QUERY ) ) { $ split_params = explode ( '&' , $ param_string ) ; foreach ( $ split_params as $ split_param ) { $ parts = explode ( '=' , $ split_param ) ; $ sub_resource_params [ $ parts [ 0 ] ] = $ parts [ 1 ] ; } } $ params = array_merge ( $ params , $ sub_resource_params ) ; $ class = 'GoCardless_' . GoCardless_Utils :: camelize ( GoCardless_Utils :: singularize ( $ type ) ) ; $ objects = array ( ) ; foreach ( $ this -> client -> request ( 'get' , $ endpoint , $ params ) as $ value ) { $ objects [ ] = new $ class ( $ this -> client , $ value ) ; } return $ objects ; }
10484	public static function createSpamComplaint ( $ recipientEmailAddress , $ listExternalId , $ recipientExternalId = null , $ ipAddress = '127.0.0.1' ) { if ( $ recipientExternalId == null ) { $ recipientExternalId = rand ( 1 , 99999 ) ; } return ( new Payload ( ) ) -> setIpAddress ( $ ipAddress ) -> setAction ( Type :: SPAM_COMPLAINT ) -> setCampaignId ( rand ( 1 , 99999 ) ) -> setListExternalId ( $ listExternalId ) -> setReason ( Type :: REASON_USER_REQUEST ) -> setRecipientEmailAddress ( $ recipientEmailAddress ) -> setHash ( md5 ( $ recipientEmailAddress ) ) -> setRecipientExternalId ( $ recipientExternalId ) -> setTriggerDate ( new \ DateTime ( ) ) -> setType ( Type :: SPAM_COMPLAINT ) ; }
11224	private static function getRegexRoutes ( ) { foreach ( self :: $ routes as $ key => $ value ) { unset ( self :: $ routes [ $ key ] ) ; if ( strpos ( $ key , ':' ) !== false ) { self :: any ( $ key , $ value ) ; } } }
1082	private function skip ( $ kind ) { $ match = $ this -> lexer -> token -> kind === $ kind ; if ( $ match ) { $ this -> lexer -> advance ( ) ; } return $ match ; }
5438	public function match ( $ subject , & $ match ) { if ( count ( $ this -> patterns ) === 0 ) { return false ; } if ( ! preg_match ( $ this -> getCompoundedRegex ( ) , $ subject , $ matches ) ) { $ match = '' ; return false ; } $ match = $ matches [ 0 ] ; for ( $ i = 1 ; $ i < count ( $ matches ) ; $ i ++ ) { if ( $ matches [ $ i ] ) { return $ this -> labels [ $ i - 1 ] ; } } return true ; }
9606	public function multiplyByScalar ( $ scalar ) { $ result = [ ] ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ result [ $ i ] = $ component * $ scalar ; } return new static ( $ result ) ; }
6214	protected function initialize ( ) { if ( $ this -> get ( 'serverData' ) === null ) { $ this -> set ( 'serverData' , ( array ) $ _SERVER ) ; } if ( $ this -> get ( 'getData' ) === null ) { $ this -> set ( 'getData' , ( array ) $ _GET ) ; } if ( $ this -> get ( 'postData' ) === null ) { $ this -> set ( 'postData' , ( array ) $ _POST ) ; } if ( $ this -> get ( 'sessionData' ) === null && isset ( $ _SESSION ) ) { $ this -> set ( 'sessionData' , ( array ) $ _SESSION ) ; } $ serverData = $ this -> get ( 'serverData' ) ; if ( ! $ this -> get ( 'projectRoot' ) ) { $ projectRoot = isset ( $ serverData [ '_' ] ) ? $ serverData [ '_' ] : $ serverData [ 'DOCUMENT_ROOT' ] ; $ this -> set ( 'projectRoot' , $ projectRoot ) ; } if ( ! $ this -> get ( 'url' ) ) { if ( isset ( $ serverData [ 'REDIRECT_URL' ] ) ) { $ this -> set ( 'url' , $ serverData [ 'REDIRECT_URL' ] ) ; } elseif ( isset ( $ serverData [ 'SCRIPT_NAME' ] ) ) { $ this -> set ( 'url' , $ serverData [ 'SCRIPT_NAME' ] ) ; } } if ( ! $ this -> get ( 'hostname' ) ) { $ this -> set ( 'hostname' , isset ( $ serverData [ 'HTTP_HOST' ] ) ? $ serverData [ 'HTTP_HOST' ] : 'No Host' ) ; } $ protocol = $ this -> get ( 'secure' ) ? 'https' : 'http' ; $ endPoint = $ this -> get ( 'apiEndPoint' ) ? : $ protocol . '://' . $ this -> get ( 'host' ) . $ this -> get ( 'resource' ) ; $ this -> set ( 'apiEndPoint' , $ endPoint ) ; }
7628	public function getContainerAcl ( $ containerName = '' , $ signedIdentifiers = false ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'acl' ) , 'GET' , array ( ) , false , null , self :: RESOURCE_CONTAINER , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } if ( $ signedIdentifiers == false ) { $ accessType = $ response -> getHeader ( Storage :: PREFIX_STORAGE_HEADER . 'blob-public-access' ) ; if ( strtolower ( $ accessType ) == 'true' ) { $ accessType = self :: ACL_PUBLIC_CONTAINER ; } return $ accessType ; } $ result = $ this -> parseResponse ( $ response ) ; if ( ! $ result ) { return array ( ) ; } $ entries = null ; if ( $ result -> SignedIdentifier ) { if ( count ( $ result -> SignedIdentifier ) > 1 ) { $ entries = $ result -> SignedIdentifier ; } else { $ entries = array ( $ result -> SignedIdentifier ) ; } } $ returnValue = array ( ) ; foreach ( $ entries as $ entry ) { $ returnValue [ ] = new SignedIdentifier ( $ entry -> Id , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Start ? $ entry -> AccessPolicy -> Start : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Expiry ? $ entry -> AccessPolicy -> Expiry : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Permission ? $ entry -> AccessPolicy -> Permission : '' : '' ) ; } return $ returnValue ; }
3099	public function getItems ( RunnerServiceContext $ serviceContext ) { $ this -> getRunnerService ( ) -> assertQtiRunnerServiceContext ( $ serviceContext ) ; $ runnerService = $ this -> getRunnerService ( ) ; $ testMap = $ runnerService -> getTestMap ( $ serviceContext ) ; $ items = [ ] ; foreach ( $ this -> getItemIdentifiersFromTestMap ( $ testMap ) as $ itemIdentifier ) { $ itemRef = $ runnerService -> getItemHref ( $ serviceContext , $ itemIdentifier ) ; $ items [ $ itemIdentifier ] = [ 'baseUrl' => $ runnerService -> getItemPublicUrl ( $ serviceContext , $ itemRef ) , 'itemData' => $ this -> getItemData ( $ serviceContext , $ itemRef ) , 'itemState' => $ runnerService -> getItemState ( $ serviceContext , $ itemIdentifier ) , 'itemIdentifier' => $ itemIdentifier , 'portableElements' => $ runnerService -> getItemPortableElements ( $ serviceContext , $ itemRef ) , ] ; } return $ items ; }
9621	protected function qsencode ( array $ data = array ( ) ) { $ req = '' ; if ( $ data ) { foreach ( $ data as $ key => $ value ) { $ req .= $ key . '=' . urlencode ( stripslashes ( $ value ) ) . '&' ; } $ req = substr ( $ req , 0 , strlen ( $ req ) - 1 ) ; } return $ req ; }
9983	public static function dataTypeForValue ( $ pValue ) { if ( $ pValue === null ) { return DataType :: TYPE_NULL ; } elseif ( $ pValue === '' ) { return DataType :: TYPE_STRING ; } elseif ( $ pValue instanceof RichText ) { return DataType :: TYPE_INLINE ; } elseif ( $ pValue [ 0 ] === '=' && strlen ( $ pValue ) > 1 ) { return DataType :: TYPE_FORMULA ; } elseif ( is_bool ( $ pValue ) ) { return DataType :: TYPE_BOOL ; } elseif ( is_float ( $ pValue ) || is_int ( $ pValue ) ) { return DataType :: TYPE_NUMERIC ; } elseif ( preg_match ( '/^[\+\-]?(\d+\\.?\d*|\d*\\.?\d+)([Ee][\-\+]?[0-2]?\d{1,3})?$/' , $ pValue ) ) { $ tValue = ltrim ( $ pValue , '+-' ) ; if ( is_string ( $ pValue ) && $ tValue [ 0 ] === '0' && strlen ( $ tValue ) > 1 && $ tValue [ 1 ] !== '.' ) { return DataType :: TYPE_STRING ; } elseif ( ( strpos ( $ pValue , '.' ) === false ) && ( $ pValue > PHP_INT_MAX ) ) { return DataType :: TYPE_STRING ; } return DataType :: TYPE_NUMERIC ; } elseif ( is_string ( $ pValue ) ) { $ errorCodes = DataType :: getErrorCodes ( ) ; if ( isset ( $ errorCodes [ $ pValue ] ) ) { return DataType :: TYPE_ERROR ; } } return DataType :: TYPE_STRING ; }
448	protected function renderPageButtons ( ) { $ pageCount = $ this -> pagination -> getPageCount ( ) ; if ( $ pageCount < 2 && $ this -> hideOnSinglePage ) { return '' ; } $ buttons = [ ] ; $ currentPage = $ this -> pagination -> getPage ( ) ; $ firstPageLabel = $ this -> firstPageLabel === true ? '1' : $ this -> firstPageLabel ; if ( $ firstPageLabel !== false ) { $ buttons [ ] = $ this -> renderPageButton ( $ firstPageLabel , 0 , $ this -> firstPageCssClass , $ currentPage <= 0 , false ) ; } if ( $ this -> prevPageLabel !== false ) { if ( ( $ page = $ currentPage - 1 ) < 0 ) { $ page = 0 ; } $ buttons [ ] = $ this -> renderPageButton ( $ this -> prevPageLabel , $ page , $ this -> prevPageCssClass , $ currentPage <= 0 , false ) ; } list ( $ beginPage , $ endPage ) = $ this -> getPageRange ( ) ; for ( $ i = $ beginPage ; $ i <= $ endPage ; ++ $ i ) { $ buttons [ ] = $ this -> renderPageButton ( $ i + 1 , $ i , null , $ this -> disableCurrentPageButton && $ i == $ currentPage , $ i == $ currentPage ) ; } if ( $ this -> nextPageLabel !== false ) { if ( ( $ page = $ currentPage + 1 ) >= $ pageCount - 1 ) { $ page = $ pageCount - 1 ; } $ buttons [ ] = $ this -> renderPageButton ( $ this -> nextPageLabel , $ page , $ this -> nextPageCssClass , $ currentPage >= $ pageCount - 1 , false ) ; } $ lastPageLabel = $ this -> lastPageLabel === true ? $ pageCount : $ this -> lastPageLabel ; if ( $ lastPageLabel !== false ) { $ buttons [ ] = $ this -> renderPageButton ( $ lastPageLabel , $ pageCount - 1 , $ this -> lastPageCssClass , $ currentPage >= $ pageCount - 1 , false ) ; } $ options = $ this -> options ; $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'ul' ) ; return Html :: tag ( $ tag , implode ( "\n" , $ buttons ) , $ options ) ; }
4053	private function fetchConditions ( $ inputScreenId ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return $ builder -> select ( 'cond.*' , 'setting.attr_id AS setting_attr_id' ) -> from ( 'tl_metamodel_dcasetting_condition' , 'cond' ) -> leftJoin ( 'cond' , 'tl_metamodel_dcasetting' , 'setting' , 'cond.settingId=setting.id' ) -> leftJoin ( 'setting' , 'tl_metamodel_dca' , 'dca' , 'setting.pid=dca.id' ) -> where ( 'cond.enabled=1' ) -> andWhere ( 'setting.published=1' ) -> andWhere ( 'dca.id=:screenId' ) -> setParameter ( 'screenId' , $ inputScreenId ) -> orderBy ( 'pid' ) -> addOrderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; }
3653	public static function render ( $ strTemplate , $ strOutputFormat , $ arrTplData , $ blnFailIfNotFound = false ) { $ objTemplate = new self ( $ strTemplate ) ; $ objTemplate -> setData ( $ arrTplData ) ; return $ objTemplate -> parse ( $ strOutputFormat , $ blnFailIfNotFound ) ; }
3524	private function fetch ( $ account_id ) { if ( ! $ account_id ) return null ; $ data = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_API . 'stats/accountId/' . $ account_id . '/bulk/window/alltime' , $ this -> access_token ) ; $ this -> display_name = Account :: getDisplayNameFromID ( str_replace ( "-" , "" , $ this -> account_id ) , $ this -> access_token ) ; $ compiledStats = [ ] ; foreach ( $ data as $ stat ) { $ parsed = $ this -> parseStatItem ( $ stat ) ; $ compiledStats = array_merge_recursive ( $ compiledStats , $ parsed ) ; } $ platforms = [ ] ; foreach ( $ compiledStats as $ key => $ platform ) { $ platforms [ $ key ] = new Platform ( $ platform ) ; } return $ platforms ; }
3998	protected function getAttribute ( $ metaModelIdOrName , $ intDataId , $ strAttributeName , $ strOutput = 'raw' ) { $ objMM = $ this -> loadMetaModel ( $ metaModelIdOrName ) ; if ( null === $ objMM ) { return false ; } if ( empty ( $ strOutput ) ) { $ strOutput = 'raw' ; } $ objMetaModelItem = $ objMM -> findById ( $ intDataId ) ; if ( null === $ objMetaModelItem ) { throw new \ RuntimeException ( 'MetaModel item not found: ' . $ intDataId ) ; } $ arrAttr = $ objMetaModelItem -> parseAttribute ( $ strAttributeName ) ; return $ arrAttr [ $ strOutput ] ; }
2833	protected function _initQuery ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ index = $ this -> getRequest ( ) -> getParam ( 'index' ) ; if ( $ token === null || $ index === null ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return null ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return null ; } $ queries = $ requestProfile -> getQueries ( ) ; if ( ! $ queries || ! ( $ index < count ( $ queries ) ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Query not found' ) ; return null ; } return $ queries [ ( int ) $ index ] ; }
2180	private function findIn ( string $ path ) : Finder { return Finder :: create ( ) -> ignoreDotFiles ( false ) -> sort ( static function ( SplFileInfo $ a , SplFileInfo $ b ) : int { $ countA = substr_count ( strtr ( $ a -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; $ countB = substr_count ( strtr ( $ b -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; return $ countA <=> $ countB ; } ) -> followLinks ( ) -> in ( $ path ) ; }
1123	public function descendantsAndSelf ( ) { return $ this -> newNestedSetQuery ( ) -> where ( $ this -> getLeftColumnName ( ) , '>=' , $ this -> getLeft ( ) ) -> where ( $ this -> getLeftColumnName ( ) , '<' , $ this -> getRight ( ) ) ; }
11354	private function generateProxy ( $ className ) { if ( isset ( $ this -> checkedClasses [ $ className ] ) ) { return $ this -> checkedClasses [ $ className ] ; } $ proxyParameters = array ( 'className' => $ className , 'factory' => get_class ( $ this ) , 'proxyManagerVersion' => Version :: VERSION ) ; $ proxyClassName = $ this -> configuration -> getClassNameInflector ( ) -> getProxyClassName ( $ className , $ proxyParameters ) ; $ this -> generateProxyClass ( $ proxyClassName , $ className , $ proxyParameters ) ; $ this -> configuration -> getSignatureChecker ( ) -> checkSignature ( new ReflectionClass ( $ proxyClassName ) , $ proxyParameters ) ; return $ this -> checkedClasses [ $ className ] = $ proxyClassName ; }
11850	public static function createFault ( $ code , $ message ) { $ response = new \ SimpleXMLElement ( "<methodResponse></methodResponse>" ) ; $ struct = $ response -> addChild ( "fault" ) -> addChild ( "value" ) -> addChild ( "struct" ) ; $ member = $ struct -> addChild ( "member" ) ; $ member -> addChild ( "name" , "faultCode" ) ; $ member -> addChild ( "value" ) -> addChild ( "int" , $ code ) ; $ member = $ struct -> addChild ( "member" ) ; $ member -> addChild ( "name" , "faultString" ) ; $ member -> addChild ( "value" , $ message ) ; return $ response -> asXML ( ) ; }
8671	public static function combine ( $ keys , $ values ) { $ keys = Arr :: from ( $ keys ) ; $ values = Arr :: from ( $ values ) ; if ( count ( $ keys ) !== count ( $ values ) ) { throw new InvalidArgumentException ( 'The size of keys and values needs to be the same.' ) ; } if ( count ( $ keys ) === 0 ) { return new static ( ) ; } return new static ( array_combine ( $ keys , $ values ) ) ; }
10267	public function setEndColor ( Color $ pValue ) { $ color = $ pValue -> getIsSupervisor ( ) ? $ pValue -> getSharedComponent ( ) : $ pValue ; if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getEndColor ( ) -> getStyleArray ( [ 'argb' => $ color -> getARGB ( ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> endColor = $ color ; } return $ this ; }
3533	public static function findByAttribute ( $ attribute , $ searchValue ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } $ userObjectsFound = static :: getAdldapProvider ( ) -> search ( ) -> select ( 'samaccountname' ) -> where ( $ attribute , '=' , $ searchValue ) -> get ( ) ; $ userObjectReturn = null ; if ( count ( $ userObjectsFound ) == 1 ) { $ userObjectReturn = static :: findByUsername ( $ userObjectsFound [ 0 ] [ 'samaccountname' ] [ 0 ] ) ; } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } return $ userObjectReturn ; }
4940	public function setIsMultiple ( $ flag ) { $ this -> isMultiple = ( bool ) $ flag ; if ( $ flag ) { $ this -> setAttribute ( 'multiple' , true ) ; } else { $ this -> removeAttribute ( 'multiple' ) ; } return $ this ; }
1127	public function isAncestorOf ( $ other ) { return ( $ this -> getLeft ( ) < $ other -> getLeft ( ) && $ this -> getRight ( ) > $ other -> getLeft ( ) && $ this -> inSameScope ( $ other ) ) ; }
3646	public function clean ( $ value , bool $ trim = true , bool $ clean = true ) { if ( is_bool ( $ value ) || is_int ( $ value ) || is_float ( $ value ) ) { return $ value ; } $ final = null ; if ( $ value !== null ) { if ( is_array ( $ value ) ) { $ all = $ value ; $ final = [ ] ; foreach ( $ all as $ key => $ value ) { if ( $ value !== null ) { $ final [ $ key ] = $ this -> clean ( $ value , $ trim , $ clean ) ; } } } else { if ( $ value !== null ) { $ final = $ this -> process ( ( string ) $ value , $ trim , $ clean ) ; } } } return $ final ; }
10895	public function addCollection ( UriCollection $ collection ) { foreach ( $ collection -> all ( ) as $ name => $ uri ) { unset ( $ this -> uris [ $ name ] ) ; $ this -> uris [ $ name ] = $ uri ; } $ this -> resources = array_merge ( $ this -> resources , $ collection -> getResources ( ) ) ; }
6760	static public function buildCacheKey ( $ columns = '*' , array $ conditionsAndOptions = [ ] ) { foreach ( $ conditionsAndOptions as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$conditionsAndOptions argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; if ( is_array ( $ columns ) ) { foreach ( $ columns as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$columns argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; } else if ( $ columns instanceof DbExpr ) { $ columns = $ columns -> get ( ) ; } return hash ( 'sha256' , json_encode ( array ( $ columns , $ conditionsAndOptions ) ) ) ; }
8952	public function retrieveMapData ( $ left , $ bottom , $ right , $ top ) { $ base = 'map?bbox=' . $ left . ',' . $ bottom . ',' . $ right . ',' . $ top ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'GET' , array ( ) ) ; return simplexml_load_string ( $ response -> body ) ; }
4284	public function url_stat ( $ path , $ flags ) { self :: restorePrev ( ) ; if ( ! \ file_exists ( $ path ) ) { $ info = false ; } elseif ( $ flags & STREAM_URL_STAT_LINK ) { $ info = $ flags & STREAM_URL_STAT_QUIET ? @ \ lstat ( $ path ) : \ lstat ( $ path ) ; } else { $ info = $ flags & STREAM_URL_STAT_QUIET ? @ \ stat ( $ path ) : \ stat ( $ path ) ; } self :: register ( ) ; return $ info ; }
12096	public function generateSignCode ( array $ params , $ secret ) { ksort ( $ params ) ; if ( isset ( $ params [ self :: SIGN_NAMESPACE ] ) ) { unset ( $ params [ self :: SIGN_NAMESPACE ] ) ; } return md5 ( implode ( '' , $ params ) . $ secret ) ; }
5869	protected static function getVirtualFileObject ( $ fileName , array $ metadata ) { $ resourceFactory = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: class ) ; $ recordData = [ 'uid' => 0 , 'pid' => 0 , 'name' => 'Temporary Upload Storage' , 'description' => 'Internal storage, mounting the temporary PHP upload directory.' , 'driver' => 'Local' , 'processingfolder' => '' , 'configuration' => '' , 'is_online' => true , 'is_browsable' => false , 'is_public' => false , 'is_writable' => false , 'is_default' => false , ] ; $ storageConfiguration = [ 'basePath' => PathUtility :: dirname ( $ fileName ) , 'pathType' => 'absolute' ] ; $ virtualStorage = $ resourceFactory -> createStorageObject ( $ recordData , $ storageConfiguration ) ; $ name = PathUtility :: basename ( $ fileName ) ; $ extension = strtolower ( substr ( $ name , strrpos ( $ name , '.' ) + 1 ) ) ; $ virtualFileObject = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ File :: class , [ 'identifier' => '/' . $ name , 'name' => $ name , 'extension' => $ extension , ] , $ virtualStorage , $ metadata ) ; return $ virtualFileObject ; }
6121	public function permissionGetIdByName ( $ name ) { if ( ! array_key_exists ( ( string ) $ name , $ this -> permissionList ( ) ) ) { throw new Ts3Exception ( "invalid permission ID" , 0xA02 ) ; } return $ this -> permissionList [ ( string ) $ name ] [ "permid" ] ; }
10691	public function shutdown ( ) { if ( ! $ this -> is_shutdown ) { $ this -> is_shutdown = true ; if ( ! empty ( $ this -> autoloader ) ) spl_autoload_unregister ( array ( $ this -> autoloader , 'autoload' ) ) ; ErrorInterceptor :: unregisterErrorHandler ( ) ; restore_exception_handler ( ) ; } }
12737	protected function translate ( ) { $ translatorOptions = $ this -> getTranslatorOptions ( ) ; if ( empty ( $ translatorOptions ) && ! array_key_exists ( "fields" , $ translatorOptions ) ) { return ; } $ params = array ( ) ; if ( array_key_exists ( "params" , $ translatorOptions ) ) { $ params = $ translatorOptions [ "params" ] ; } $ domain = "RedKiteCms" ; if ( array_key_exists ( "domain" , $ translatorOptions ) ) { $ domain = $ translatorOptions [ "domain" ] ; } foreach ( $ translatorOptions [ "fields" ] as $ field ) { $ field = ucfirst ( $ field ) ; $ method = 'get' . $ field ; $ value = Translator :: translate ( $ this -> $ method ( ) , $ params , $ domain ) ; $ method = 'set' . $ field ; $ this -> $ method ( $ value ) ; } }
8629	public function setParticipation ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Participation' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12781	private function decrypt ( $ encrypted , $ appId ) { try { $ key = $ this -> getAESKey ( ) ; $ ciphertext = base64_decode ( $ encrypted , true ) ; $ iv = substr ( $ key , 0 , 16 ) ; $ decrypted = openssl_decrypt ( $ ciphertext , 'aes-256-cbc' , $ key , OPENSSL_RAW_DATA | OPENSSL_NO_PADDING , $ iv ) ; } catch ( BaseException $ e ) { throw new EncryptionException ( $ e -> getMessage ( ) , EncryptionException :: ERROR_DECRYPT_AES ) ; } try { $ result = $ this -> decode ( $ decrypted ) ; if ( strlen ( $ result ) < 16 ) { return '' ; } $ content = substr ( $ result , 16 , strlen ( $ result ) ) ; $ listLen = unpack ( 'N' , substr ( $ content , 0 , 4 ) ) ; $ xmlLen = $ listLen [ 1 ] ; $ xml = substr ( $ content , 4 , $ xmlLen ) ; $ fromAppId = trim ( substr ( $ content , $ xmlLen + 4 ) ) ; } catch ( BaseException $ e ) { throw new EncryptionException ( $ e -> getMessage ( ) , EncryptionException :: ERROR_INVALID_XML ) ; } if ( $ fromAppId !== $ appId ) { throw new EncryptionException ( 'Invalid appId.' , EncryptionException :: ERROR_INVALID_APPID ) ; } $ dataSet = json_decode ( $ xml , true ) ; if ( $ dataSet && ( JSON_ERROR_NONE === json_last_error ( ) ) ) { $ xml = XML :: build ( $ dataSet ) ; } return $ xml ; }
2447	public function notifyOfReply ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> activeRecord || ! $ dc -> activeRecord -> addReply || $ dc -> activeRecord -> notifyReply ) { return ; } $ objNotify = Contao \ CommentsNotifyModel :: findActiveBySourceAndParent ( $ dc -> activeRecord -> source , $ dc -> activeRecord -> parent ) ; if ( $ objNotify !== null ) { while ( $ objNotify -> next ( ) ) { $ strUrl = Contao \ Idna :: decode ( Contao \ Environment :: get ( 'base' ) ) . $ objNotify -> url ; $ objEmail = new Contao \ Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_notifyReplySubject' ] , Contao \ Idna :: decode ( Contao \ Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_notifyReplyMessage' ] , $ objNotify -> name , $ strUrl . '#c' . $ dc -> id , $ strUrl . '?token=' . $ objNotify -> tokenRemove ) ; $ objEmail -> sendTo ( $ objNotify -> email ) ; } } $ this -> Database -> prepare ( "UPDATE tl_comments SET notifiedReply='1' WHERE id=?" ) -> execute ( $ dc -> id ) ; }
8448	public function broadcastMsg ( array $ peers , $ msg ) { $ peerList = $ this -> formatPeers ( $ peers ) ; return $ this -> exec ( 'broadcast ' . $ peerList . ' ' . $ msg ) ; }
11316	public function handleUseRequest ( $ data , $ transactionId , $ transactionKey ) { if ( ! $ this -> objCredits ) { return null ; } if ( isset ( $ _POST [ 'transaction_id' ] ) && isset ( $ _POST [ 'transaction_secret' ] ) ) { $ valid = $ this -> objCredits -> isRequestValid ( $ _POST [ 'transaction_id' ] , $ _POST [ 'transaction_secret' ] ) ; if ( $ valid ) { $ amount = $ _POST [ 'transaction_amount' ] ; $ this -> objUser -> useCredit ( $ amount , $ data ) ; return true ; } else { $ this -> error = 'This request was not valid or already executed. Ignore.' ; } } else { $ this -> error = 'No post data received.' ; } return false ; }
11954	public function resetAllPropertiesExcept ( $ properties = array ( ) ) { foreach ( $ this -> obj_to_db_trans as $ obj_prop => $ db_field ) { if ( ! in_array ( $ obj_prop , $ this -> key_properties ) && ! in_array ( $ obj_prop , $ properties ) ) { $ this -> { $ obj_prop } = null ; } } }
6840	public function getData ( $ key ) { if ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } throw new InjectorException ( "data $key not found" ) ; }
8157	public function prependPath ( $ path , $ namespace = self :: MAIN_NAMESPACE ) { $ this -> cache = $ this -> errorCache = array ( ) ; $ checkPath = $ this -> isAbsolutePath ( $ path ) ? $ path : $ this -> rootPath . $ path ; if ( ! is_dir ( $ checkPath ) ) { throw new Twig_Error_Loader ( sprintf ( 'The "%s" directory does not exist ("%s").' , $ path , $ checkPath ) ) ; } $ path = rtrim ( $ path , '/\\' ) ; if ( ! isset ( $ this -> paths [ $ namespace ] ) ) { $ this -> paths [ $ namespace ] [ ] = $ path ; } else { array_unshift ( $ this -> paths [ $ namespace ] , $ path ) ; } }
5729	public function bindGridField ( Form $ form , GridFieldDetailForm_ItemRequest $ request ) { $ this -> setForm ( $ form ) ; $ this -> gridFieldRequest = $ request ; foreach ( $ this -> children as $ child ) { if ( ! $ child instanceof BetterButton && ! $ child instanceof BetterButtonAction ) { throw new Exception ( "DropdownFormAction must be passed instances of BetterButton" ) ; } $ child -> bindGridField ( $ form , $ request ) ; $ child -> setIsGrouped ( true ) ; if ( $ child instanceof FormAction ) { $ child -> setUseButtonTag ( true ) ; } } return $ this ; }
8610	public function updateSubscription ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_UpdateSubscriptionInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/UpdateSubscriptionInput.php' ) ; $ request = new MWSSubscriptionsService_Model_UpdateSubscriptionInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateSubscription' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/UpdateSubscriptionResponse.php' ) ; $ response = MWSSubscriptionsService_Model_UpdateSubscriptionResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8966	public static function exists ( $ currencyCode ) { $ currencyCode = trim ( strtoupper ( $ currencyCode ) ) ; return array_key_exists ( $ currencyCode , self :: $ codes ) ; }
6741	public function to ( $ target ) { if ( is_null ( $ this -> request ) ) { throw new \ LogicException ( 'Missing request instance.' ) ; } $ target = new Uri ( $ target ) ; $ uri = $ this -> request -> getUri ( ) -> withScheme ( $ target -> getScheme ( ) ) -> withHost ( $ target -> getHost ( ) ) ; if ( $ port = $ target -> getPort ( ) ) { $ uri = $ uri -> withPort ( $ port ) ; } if ( $ path = $ target -> getPath ( ) ) { $ uri = $ uri -> withPath ( rtrim ( $ path , '/' ) . '/' . ltrim ( $ uri -> getPath ( ) , '/' ) ) ; } if ( ! empty ( $ this -> request -> getQueryParams ( ) ) ) { $ queryParams = $ this -> request -> getQueryParams ( ) ; if ( count ( $ queryParams ) == 1 && empty ( array_shift ( $ queryParams ) ) ) { $ queryKeys = array_keys ( $ this -> request -> getQueryParams ( ) ) ; $ uri = $ uri -> withQuery ( $ queryKeys [ 0 ] ) ; } else { $ uri = $ uri -> withQuery ( http_build_query ( $ this -> request -> getQueryParams ( ) ) ) ; } } $ request = $ this -> request -> withUri ( $ uri ) ; foreach ( $ request -> getHeaders ( ) as $ headerName => $ headerValue ) { if ( empty ( $ headerValue [ 0 ] ) ) { $ request = $ request -> withoutHeader ( $ headerName ) ; } } return $ this -> client -> send ( $ request ) ; }
8307	public function assertStringContaining ( $ config , $ key , $ searchedPart ) { $ this -> assertString ( $ config , $ key ) ; if ( array_key_exists ( $ key , $ config ) && strpos ( $ config [ $ key ] , $ searchedPart ) === false ) { throw new ConfigurationException ( $ key . " must contain " . $ searchedPart ) ; } return $ this ; }
2991	private function encodeRecord ( $ record , $ childName , & $ xml ) { foreach ( $ record as $ key => $ value ) { if ( $ value instanceof \ DateTime ) { if ( $ value -> format ( 'His' ) === '000000' ) { $ value = $ value -> format ( 'm/d/Y' ) ; } else { $ value = $ value -> format ( 'Y-m-d H:i:s' ) ; } } $ keyValue = $ xml -> addChild ( $ childName ) ; $ keyValue -> addAttribute ( 'val' , $ key ) ; if ( is_array ( $ value ) ) { $ this -> parseNestedValues ( $ value , $ keyValue ) ; } else { $ keyValue [ 0 ] = $ value ; } } }
6205	public function onException ( \ Exception $ exception ) { if ( $ this -> shouldNotifyException ( $ exception ) ) { $ this -> airbrakeClient -> notifyOnException ( $ exception ) ; } return true ; }
6184	public function display ( $ type = 'all' , $ print = false ) { $ messages = '' ; $ data = '' ; if ( in_array ( $ type , $ this -> msgTypes ) ) { $ flashMessages = $ this -> driver -> get ( 'flash_messages' ) ; foreach ( $ flashMessages [ $ type ] as $ msg ) { $ messages .= $ msg ; } $ data .= $ messages ; $ this -> clear ( $ type ) ; } elseif ( $ type === 'all' ) { $ flashMessages = $ this -> driver -> get ( 'flash_messages' ) ; foreach ( $ flashMessages as $ type => $ msgArray ) { $ messages = '' ; foreach ( $ msgArray as $ msg ) { $ messages .= $ msg ; } $ data .= $ messages ; } $ this -> clear ( ) ; } else { return false ; } if ( $ print ) { echo $ data ; return null ; } return $ data ; }
6388	public function readSite ( ) { $ model = $ this -> readCourse ( 1 ) ; $ model -> url = $ this -> cfg -> wwwroot ; $ model -> type = "site" ; return $ model ; }
12361	public function getPublisherForMessage ( Message $ message ) { $ attributes = $ message -> getAttributes ( ) ; if ( ! isset ( $ attributes [ 'headers' ] ) || ! isset ( $ attributes [ 'headers' ] [ $ this -> headerName ] ) ) { throw MissingPublisherException :: noHeaderInMessage ( $ message , $ this -> headerName ) ; } $ value = $ attributes [ 'headers' ] [ $ this -> headerName ] ; foreach ( $ this -> valueMap as $ hash => $ values ) { if ( ! in_array ( $ value , $ values , true ) ) { continue ; } return $ this -> publishers [ $ hash ] ; } throw MissingPublisherException :: noKnownPublisherFor ( $ message ) ; }
1408	protected function attributeKeys ( Model $ model ) { if ( is_array ( $ this -> attributes ) ) { return $ this -> attributes ; } return $ model -> getVisible ( ) ; }
5152	static function sortEmailsByCreationDatePredicate ( $ emailA , $ emailB ) { $ sortKeyA = $ emailA -> sent_at ; $ sortKeyB = $ emailB -> sent_at ; return ( $ sortKeyA > $ sortKeyB ) ? - 1 : 1 ; }
3979	private function createCommand ( CommandCollectionInterface $ collection , $ operationName , $ queryParameters , $ icon , $ extraValues = [ ] ) { $ command = $ this -> getCommandInstance ( $ collection , $ operationName ) ; $ parameters = $ command -> getParameters ( ) ; foreach ( $ queryParameters as $ name => $ value ) { if ( ! isset ( $ parameters [ $ name ] ) ) { $ parameters [ $ name ] = $ value ; } } if ( ! $ command -> getLabel ( ) ) { $ command -> setLabel ( $ operationName . '.0' ) ; if ( isset ( $ extraValues [ 'label' ] ) ) { $ command -> setLabel ( $ extraValues [ 'label' ] ) ; } } if ( ! $ command -> getDescription ( ) ) { $ command -> setDescription ( $ operationName . '.1' ) ; if ( isset ( $ extraValues [ 'description' ] ) ) { $ command -> setDescription ( $ extraValues [ 'description' ] ) ; } } $ extra = $ command -> getExtra ( ) ; $ extra [ 'icon' ] = $ icon ; foreach ( $ extraValues as $ name => $ value ) { if ( ! isset ( $ extra [ $ name ] ) ) { $ extra [ $ name ] = $ value ; } } }
12538	public function setRelations ( $ value ) { if ( $ this -> companionObject ) { $ baseObject = $ this -> companionObject ; } else { $ baseObject = $ this -> owner ; } $ fields = $ baseObject -> getFields ( ) ; foreach ( $ value as $ tabId => $ relation ) { if ( ! isset ( $ relation [ '_moduleHandler' ] ) ) { \ d ( "boom" ) ; exit ; continue ; } if ( ! isset ( $ fields [ $ relation [ '_moduleHandler' ] ] ) ) { \ d ( $ relation [ '_moduleHandler' ] ) ; \ d ( array_keys ( $ fields ) ) ; exit ; continue ; } $ baseAttributes = [ ] ; $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> model ; if ( empty ( $ model ) ) { $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> resetModel ( ) ; } $ model -> attributes = $ relation ; $ model -> _moduleHandler = $ relation [ '_moduleHandler' ] ; $ model -> tabularId = $ relation [ '_moduleHandler' ] ; list ( $ relationship , $ role ) = $ baseObject -> objectType -> getRelationship ( $ model -> _moduleHandler ) ; $ relatedHandler = $ baseObject -> objectType -> getRelatedType ( $ model -> _moduleHandler ) ; if ( ! $ relatedHandler ) { continue ; } if ( ! $ this -> owner -> tabularId && ! $ this -> owner -> isNewRecord && empty ( $ model -> parent_object_id ) && empty ( $ model -> child_object_id ) ) { continue ; } $ this -> _relations [ $ tabId ] = $ model ; } }
11010	public function addDefaultSrc ( string $ source ) : bool { if ( ! in_array ( $ source , $ this -> tags [ 'default-src' ] ) ) { $ this -> tags [ 'default-src' ] [ ] = $ source ; return true ; } return false ; }
1707	private function hasCookie ( Response $ response ) : bool { $ cookies = $ response -> headers -> getCookies ( ) ; foreach ( $ cookies as $ cookie ) { if ( self :: COOKIE_NAME === $ cookie -> getName ( ) ) { return true ; } } return false ; }
10309	function getOpensCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ formatFilter = null , $ socialNetworkFilter = null , $ deviceTypeFilter = null , $ excludeAnonymousOpens = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousOpens ) ) $ params [ 'exclude_anonymous_opens' ] = ( $ excludeAnonymousOpens == true ) ? "true" : "false" ; if ( isset ( $ formatFilter ) ) $ params [ 'format' ] = $ formatFilter ; $ params = $ this -> appendArrayFields ( $ params , "social_network" , $ socialNetworkFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "device_type" , $ deviceTypeFilter ) ; return $ this -> get ( 'reports/opens/count' , $ params ) ; }
8191	public function actionConfirm ( $ id , $ code ) { $ user = UserIdentity :: findByActivationToken ( $ id , $ code ) ; if ( $ user == NULL ) throw new NotFoundHttpException ; if ( ! empty ( $ user ) ) { $ user -> activation_token = NULL ; $ user -> status = User :: STATUS_ACTIVE ; $ user -> save ( FALSE ) ; Yii :: $ app -> session -> setFlash ( 'success' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' has successfully been activated' ) ) ; } else Yii :: $ app -> session -> setFlash ( 'error' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' could not been activated. Please contact the Administrator' ) ) ; return $ this -> render ( 'confirm' , [ 'user' => $ user ] ) ; }
12485	public function adapterHasBehavior ( Adapter $ adapter , $ behavior ) { if ( $ adapter instanceof KnowsItsBehaviors ) { return in_array ( $ behavior , $ adapter -> getBehaviors ( ) ) ; } return true === is_a ( $ adapter , $ behavior ) ; }
10236	private function writeDefaultContentType ( XMLWriter $ objWriter , $ pPartname , $ pContentType ) { if ( $ pPartname != '' && $ pContentType != '' ) { $ objWriter -> startElement ( 'Default' ) ; $ objWriter -> writeAttribute ( 'Extension' , $ pPartname ) ; $ objWriter -> writeAttribute ( 'ContentType' , $ pContentType ) ; $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
12525	static function release ( $ token , $ mode , $ opts = array ( ) ) { clearstatcache ( ) ; $ lockDir = self :: lockDir ( $ opts ) ; if ( $ mode == LOCK_EX ) { $ wLockFile = "$lockDir/{$token}_W.lock" ; if ( is_file ( $ wLockFile ) && ! unlink ( $ wLockFile ) ) { pake_echo_error ( "Could not remove W lock file '$wLockFile'" ) ; } return ; } $ rLockFile = "$lockDir/{$token}_R/" . getmypid ( ) . ".lock" ; if ( is_file ( $ rLockFile ) && ! unlink ( $ rLockFile ) ) { pake_echo_error ( "Could not remove R lock file '$rLockFile'" ) ; } }
7820	public function store ( $ pipeline , array $ pipes ) { $ workflow = [ $ pipeline => $ pipes ] ; $ yaml = $ this -> parser -> dump ( $ workflow ) ; $ this -> files -> append ( $ this -> getSource ( ) , $ yaml ) ; }
11142	public function getAttributes ( $ props ) { $ attr = '' ; if ( isset ( $ props [ 'primaryKey' ] ) ) { $ attr .= 'NOT NULL AUTO_INCREMENT ' ; } if ( isset ( $ props [ 'defaultValue' ] ) ) { $ attr .= "DEFAULT '" . $ props [ 'defaultValue' ] . "'" ; } return $ attr ; }
10909	public function inject ( string ... $ methods ) : Binding { if ( $ this -> definition -> injects === null ) { $ this -> definition -> injects = \ array_fill_keys ( $ methods , true ) ; } else { foreach ( $ methods as $ f ) { $ this -> definition -> injects [ $ f ] = true ; } } return $ this ; }
10820	public static function warning ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'warning' , $ length , $ separator ) ; }
4266	public static function register ( $ pathsExclude = array ( ) ) { $ result = \ stream_wrapper_unregister ( static :: PROTOCOL ) ; if ( $ result === false ) { throw new \ UnexpectedValueException ( 'Failed to unregister' ) ; } if ( $ pathsExclude ) { self :: $ pathsExclude = $ pathsExclude ; } \ stream_wrapper_register ( static :: PROTOCOL , \ get_called_class ( ) ) ; \ ini_set ( 'opcache.enable' , 0 ) ; }
4788	function insert ( $ data ) { $ rows = func_get_args ( ) ; $ return = $ this -> insert_multi ( $ rows ) ; if ( ! $ return ) { return false ; } if ( ! is_array ( $ data ) ) { return $ return ; } if ( $ this -> notORM -> driver == "pgsql" ) { if ( ! isset ( $ data [ $ this -> primary ] ) ) { $ pgss = $ this -> query ( "SELECT pg_get_serial_sequence('" . $ this -> table . "', '" . $ this -> primary . "') pgss" , $ this -> parameters ) -> fetch ( ) ; if ( isset ( $ pgss [ 'pgss' ] ) ) { $ rs = $ this -> query ( "select last_value id from " . $ pgss [ 'pgss' ] , $ this -> parameters ) -> fetch ( ) ; $ data [ $ this -> primary ] = $ rs [ 'id' ] ; $ this -> sequence = $ rs [ 'id' ] ; } } } else { if ( ! isset ( $ data [ $ this -> primary ] ) && ( $ id = $ this -> notORM -> connection -> lastInsertId ( $ this -> notORM -> structure -> getSequence ( $ this -> table ) ) ) ) { $ data [ $ this -> primary ] = $ id ; } } return new $ this -> notORM -> rowClass ( $ data , $ this ) ; }
3347	public function __preparedRequest ( $ type , $ request_type = 'GET' , $ params = array ( ) , $ data = array ( ) , $ retry_throttled = null ) { $ retry_throttled = $ retry_throttled ? : $ this -> retry_throttled ; $ path = $ this -> __getPath ( $ type , $ params ) ; while ( true ) { try { return $ this -> request ( $ request_type , $ path , $ data ) ; } catch ( ThrottledRequestException $ exception ) { if ( $ retry_throttled > 0 ) { sleep ( $ exception -> getTimeout ( ) ) ; $ retry_throttled -- ; continue ; } else { throw $ exception ; } } } return null ; }
1992	public static function getMetaData ( $ strData , $ strLanguage ) { if ( empty ( $ strLanguage ) ) { return array ( ) ; } $ arrData = StringUtil :: deserialize ( $ strData ) ; $ strLanguage = str_replace ( '-' , '_' , $ strLanguage ) ; if ( ! \ is_array ( $ arrData ) || ! isset ( $ arrData [ $ strLanguage ] ) ) { return array ( ) ; } return $ arrData [ $ strLanguage ] ; }
1051	public static function getArgumentValues ( $ def , $ node , $ variableValues = null ) { if ( empty ( $ def -> args ) ) { return [ ] ; } $ argumentNodes = $ node -> arguments ; if ( empty ( $ argumentNodes ) ) { return [ ] ; } $ argumentValueMap = [ ] ; foreach ( $ argumentNodes as $ argumentNode ) { $ argumentValueMap [ $ argumentNode -> name -> value ] = $ argumentNode -> value ; } return static :: getArgumentValuesForMap ( $ def , $ argumentValueMap , $ variableValues , $ node ) ; }
7420	protected function getNumList ( ) : array { preg_match_all ( '/\/\d+/u' , $ this -> request -> route ( ) , $ numList ) ; $ numList = $ numList [ 0 ] ; $ numList = array_map ( function ( $ val ) { return intval ( ltrim ( $ val , '/' ) ) ; } , $ numList ) ; return $ numList ; }
6052	public function retrieveFolder ( $ id , $ depth = 0 , $ includeProperties = true , $ includeObjectCounts = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'depth' => $ depth , 'includeProperties' => $ includeProperties , 'includeObjectCounts' => $ includeObjectCounts ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
6287	private function buildReactRequest ( RequestInterface $ request ) { $ headers = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ headers [ $ name ] = ( is_array ( $ value ) ? $ value [ 0 ] : $ value ) ; } $ reactRequest = $ this -> client -> request ( $ request -> getMethod ( ) , ( string ) $ request -> getUri ( ) , $ headers , $ request -> getProtocolVersion ( ) ) ; return $ reactRequest ; }
10049	private static function toArray ( $ object ) { $ type = gettype ( $ object ) ; if ( $ type == 'array' ) { foreach ( $ object as $ element ) { $ result [ ] = self :: toArray ( $ element ) ; } return $ result ; } else if ( $ type == 'object' ) { if ( is_subclass_of ( $ object , 'AbstractJSONWrapper' ) ) { return $ object -> toArray ( ) ; } else { trigger_error ( "JSONSerializer: Trying to serialize " . get_class ( $ object ) ) ; return $ object ; } } else { return $ object ; } }
9671	private function writeCellStyleDxf ( XMLWriter $ objWriter , \ PhpOffice \ PhpSpreadsheet \ Style \ Style $ pStyle ) { $ objWriter -> startElement ( 'dxf' ) ; $ this -> writeFont ( $ objWriter , $ pStyle -> getFont ( ) ) ; $ this -> writeNumFmt ( $ objWriter , $ pStyle -> getNumberFormat ( ) ) ; $ this -> writeFill ( $ objWriter , $ pStyle -> getFill ( ) ) ; $ objWriter -> startElement ( 'alignment' ) ; if ( $ pStyle -> getAlignment ( ) -> getHorizontal ( ) !== null ) { $ objWriter -> writeAttribute ( 'horizontal' , $ pStyle -> getAlignment ( ) -> getHorizontal ( ) ) ; } if ( $ pStyle -> getAlignment ( ) -> getVertical ( ) !== null ) { $ objWriter -> writeAttribute ( 'vertical' , $ pStyle -> getAlignment ( ) -> getVertical ( ) ) ; } if ( $ pStyle -> getAlignment ( ) -> getTextRotation ( ) !== null ) { $ textRotation = 0 ; if ( $ pStyle -> getAlignment ( ) -> getTextRotation ( ) >= 0 ) { $ textRotation = $ pStyle -> getAlignment ( ) -> getTextRotation ( ) ; } elseif ( $ pStyle -> getAlignment ( ) -> getTextRotation ( ) < 0 ) { $ textRotation = 90 - $ pStyle -> getAlignment ( ) -> getTextRotation ( ) ; } $ objWriter -> writeAttribute ( 'textRotation' , $ textRotation ) ; } $ objWriter -> endElement ( ) ; $ this -> writeBorder ( $ objWriter , $ pStyle -> getBorders ( ) ) ; if ( ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== null ) || ( $ pStyle -> getProtection ( ) -> getHidden ( ) !== null ) ) { if ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== Protection :: PROTECTION_INHERIT || $ pStyle -> getProtection ( ) -> getHidden ( ) !== Protection :: PROTECTION_INHERIT ) { $ objWriter -> startElement ( 'protection' ) ; if ( ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== null ) && ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== Protection :: PROTECTION_INHERIT ) ) { $ objWriter -> writeAttribute ( 'locked' , ( $ pStyle -> getProtection ( ) -> getLocked ( ) == Protection :: PROTECTION_PROTECTED ? 'true' : 'false' ) ) ; } if ( ( $ pStyle -> getProtection ( ) -> getHidden ( ) !== null ) && ( $ pStyle -> getProtection ( ) -> getHidden ( ) !== Protection :: PROTECTION_INHERIT ) ) { $ objWriter -> writeAttribute ( 'hidden' , ( $ pStyle -> getProtection ( ) -> getHidden ( ) == Protection :: PROTECTION_PROTECTED ? 'true' : 'false' ) ) ; } $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; }
10907	public static function get ( array $ server ) : array { $ params = [ ] ; if ( isset ( $ server [ 'QUERY_STRING' ] ) ) { $ query = ltrim ( $ server [ 'QUERY_STRING' ] , '?' ) ; foreach ( explode ( '&' , $ query ) as $ pair ) { if ( $ pair ) { list ( $ name , $ value ) = self :: normalize ( array_map ( 'urldecode' , explode ( '=' , $ pair , 2 ) ) ) ; $ params [ $ name ] [ ] = $ value ; } } } return $ params ? array_map ( function ( $ v ) { return count ( $ v ) === 1 ? $ v [ 0 ] : $ v ; } , $ params ) : $ params ; }
6867	protected function getSaleFromInvoice ( InvoiceInterface $ invoice ) { if ( null === $ sale = $ invoice -> getSale ( ) ) { $ cs = $ this -> persistenceHelper -> getChangeSet ( $ invoice , $ this -> getSalePropertyPath ( ) ) ; if ( ! empty ( $ cs ) ) { $ sale = $ cs [ 0 ] ; } } if ( ! $ sale instanceof SaleInterface ) { throw new Exception \ RuntimeException ( "Failed to retrieve invoice's sale." ) ; } return $ sale ; }
9721	public function getSamples ( ) { $ baseDir = realpath ( __DIR__ . '/../../../samples' ) ; $ directory = new RecursiveDirectoryIterator ( $ baseDir ) ; $ iterator = new RecursiveIteratorIterator ( $ directory ) ; $ regex = new RegexIterator ( $ iterator , '/^.+\.php$/' , RecursiveRegexIterator :: GET_MATCH ) ; $ files = [ ] ; foreach ( $ regex as $ file ) { $ file = str_replace ( $ baseDir . '/' , '' , $ file [ 0 ] ) ; $ info = pathinfo ( $ file ) ; $ category = str_replace ( '_' , ' ' , $ info [ 'dirname' ] ) ; $ name = str_replace ( '_' , ' ' , preg_replace ( '/(|\.php)/' , '' , $ info [ 'filename' ] ) ) ; if ( ! in_array ( $ category , [ '.' , 'boostrap' , 'templates' ] ) ) { if ( ! isset ( $ files [ $ category ] ) ) { $ files [ $ category ] = [ ] ; } $ files [ $ category ] [ $ name ] = $ file ; } } ksort ( $ files ) ; foreach ( $ files as & $ f ) { asort ( $ f ) ; } return $ files ; }
12701	public function setEditorConfig ( $ config ) { if ( $ config instanceof Traversable ) { $ config = ArrayUtils :: iteratorToArray ( $ config ) ; } if ( ! is_array ( $ config ) ) { throw new InvalidArgumentException ( 'The options parameter must be an array or a Traversable' ) ; } $ this -> editorConfig = $ config ; return $ this ; }
11408	public function onBootstrap ( MvcEvent $ e ) { if ( ! $ e -> getRequest ( ) instanceof HttpRequest ) { return ; } $ app = $ e -> getApplication ( ) ; $ services = $ app -> getServiceManager ( ) ; $ eventManager = $ app -> getEventManager ( ) ; $ sharedEventManager = $ eventManager -> getSharedManager ( ) ; $ sharedEventManager -> attach ( UserService :: class , 'register' , function ( $ e ) use ( $ services ) { $ user = $ e -> getParam ( 'user' ) ; if ( $ user instanceof RoleableInterface && $ services -> has ( AuthorizationModuleOptions :: class ) ) { $ config = $ services -> get ( PermissionsModuleOptions :: class ) ; $ roleClass = $ config -> getRoleEntityClass ( ) ; $ mapper = $ services -> get ( 'MapperManager' ) -> get ( $ roleClass ) ; if ( $ defaultRole = $ mapper -> find ( $ config -> getAuthenticatedRole ( ) ) ) { $ user -> addRole ( $ defaultRole ) ; } } } , 100 ) ; }
2114	public function onBuild ( MenuEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser ) { return ; } $ factory = $ event -> getFactory ( ) ; $ tree = $ event -> getTree ( ) ; $ modules = $ user -> navigation ( ) ; foreach ( $ modules as $ categoryName => $ categoryData ) { $ categoryNode = $ tree -> getChild ( $ categoryName ) ; if ( ! $ categoryNode ) { $ categoryNode = $ this -> createNode ( $ factory , $ categoryName , $ categoryData ) ; if ( isset ( $ categoryData [ 'class' ] ) && preg_match ( '/\bnode-collapsed\b/' , $ categoryData [ 'class' ] ) ) { $ categoryNode -> setDisplayChildren ( false ) ; } $ tree -> addChild ( $ categoryNode ) ; } foreach ( $ categoryData [ 'modules' ] as $ moduleName => $ moduleData ) { $ moduleNode = $ this -> createNode ( $ factory , $ moduleName , $ moduleData ) ; $ moduleNode -> setCurrent ( ( bool ) $ moduleData [ 'isActive' ] ) ; $ categoryNode -> addChild ( $ moduleNode ) ; } } }
11888	public function getFamiliarity ( $ user = null ) { if ( is_null ( $ user ) ) { $ user = $ this -> getUser ( false ) ; } if ( is_object ( $ user ) ) { $ user = $ user -> primaryKey ; } $ familarityKey = md5 ( $ user ) ; if ( ! isset ( $ this -> _familiarity [ $ familarityKey ] ) ) { $ this -> _familiarity [ $ familarityKey ] = false ; $ familiarityClass = Yii :: $ app -> classes [ 'ObjectFamiliarity' ] ; if ( ! empty ( $ user ) ) { $ attributes = [ ] ; $ attributes [ $ this -> objectField ] = $ this -> owner -> primaryKey ; $ attributes [ $ this -> userField ] = $ user ; $ this -> _familiarity [ $ familarityKey ] = $ familiarityClass :: find ( ) -> where ( $ attributes ) -> one ( ) ; if ( empty ( $ this -> _familiarity [ $ familarityKey ] ) ) { $ this -> _familiarity [ $ familarityKey ] = new $ familiarityClass ( ) ; $ this -> _familiarity [ $ familarityKey ] -> attributes = $ attributes ; } } } return $ this -> _familiarity [ $ familarityKey ] ; }
8428	public function getFileIcon ( $ fileType , $ iconLib = 'cmti' ) { switch ( $ iconLib ) { case 'cmti' : { return $ this -> getCmtiFileIcon ( $ fileType ) ; } case 'fa' : { return $ this -> getFaFileIcon ( $ fileType ) ; } } }
12396	public function where ( $ field , $ operator = null , $ value = null , $ logical = '&&' ) { if ( $ field instanceof Closure ) { $ this -> scope -> where .= $ this -> scope -> where == '' ? ' (' : $ logical . ' (' ; call_user_func ( $ field , $ this ) ; $ this -> scope -> where .= ') ' ; } else { $ logical = ( strlen ( $ this -> scope -> where ) <= 1 || substr ( $ this -> scope -> where , - 1 ) == '(' ) ? '' : $ logical ; $ this -> scope -> where .= Parser :: where ( $ field , $ operator , $ value , $ logical ) ; } return $ this ; }
12223	public function get ( $ keys = [ ] ) { $ this -> buildIfNotBuilded ( ) ; $ keys = $ keys == [ ] ? $ this -> keys ( ) : $ keys ; if ( ! $ keys ) { return $ this -> builder -> get ( ) ; } return $ this -> builder -> withColumns ( $ keys ) -> get ( $ keys ) ; }
5637	public function paintError ( $ message ) { parent :: paintError ( $ message ) ; print 'Exception ' . $ this -> getExceptionCount ( ) . "!\n$message\n" ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print "\tin " . implode ( "\n\tin " , array_reverse ( $ breadcrumb ) ) ; print "\n" ; }
1675	public function unsynchronize ( ) { if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ) { System :: getContainer ( ) -> get ( 'filesystem' ) -> touch ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ; } }
9669	private function writeFont ( XMLWriter $ objWriter , Font $ pFont ) { $ objWriter -> startElement ( 'font' ) ; if ( $ pFont -> getBold ( ) !== null ) { $ objWriter -> startElement ( 'b' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getBold ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getItalic ( ) !== null ) { $ objWriter -> startElement ( 'i' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getItalic ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getStrikethrough ( ) !== null ) { $ objWriter -> startElement ( 'strike' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getStrikethrough ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getUnderline ( ) !== null ) { $ objWriter -> startElement ( 'u' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getUnderline ( ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getSuperscript ( ) === true || $ pFont -> getSubscript ( ) === true ) { $ objWriter -> startElement ( 'vertAlign' ) ; if ( $ pFont -> getSuperscript ( ) === true ) { $ objWriter -> writeAttribute ( 'val' , 'superscript' ) ; } elseif ( $ pFont -> getSubscript ( ) === true ) { $ objWriter -> writeAttribute ( 'val' , 'subscript' ) ; } $ objWriter -> endElement ( ) ; } if ( $ pFont -> getSize ( ) !== null ) { $ objWriter -> startElement ( 'sz' ) ; $ objWriter -> writeAttribute ( 'val' , StringHelper :: formatNumber ( $ pFont -> getSize ( ) ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getColor ( ) -> getARGB ( ) !== null ) { $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFont -> getColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getName ( ) !== null ) { $ objWriter -> startElement ( 'name' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getName ( ) ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; }
11404	public function changeAction ( ) { $ theme = $ this -> container -> get ( 'request' ) -> request -> get ( 'admin_theme' ) ; $ this -> container -> get ( 'vince_t.admin.theme.handler' ) -> setCurrentTheme ( $ theme ) ; $ headers = $ this -> container -> get ( 'request' ) -> server -> getHeaders ( ) ; $ referer = $ headers [ 'REFERER' ] ; return new RedirectResponse ( $ referer ) ; }
8413	public function getLink ( ) { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( isset ( $ this -> servers [ 'all' ] ) === true ) { return $ this -> servers [ 'all' ] [ 'link' ] ; } if ( $ this -> transactionLevel >= 1 ) { return $ this -> servers [ 'write' ] [ 'link' ] ; } return $ this -> servers [ 'read' ] [ 'link' ] ; }
12826	protected function saveSlotDefinition ( $ dir , array $ slot ) { $ slotsFilename = $ this -> getSlotDefinitionFile ( $ dir ) ; FilesystemTools :: writeFile ( $ slotsFilename , json_encode ( $ slot ) , $ this -> filesystem ) ; }
6752	public static function getCallable ( Logger $ logger , $ type , $ maxMessageLength ) { return function ( MessageInterface $ message ) use ( $ logger , $ type , $ maxMessageLength ) { $ startMessage = null ; if ( $ message instanceof RequestInterface ) { $ startMessage = sprintf ( 'Proxy %s start: HTTP/%s %s %s' , $ type , $ message -> getProtocolVersion ( ) , $ message -> getMethod ( ) , $ message -> getRequestTarget ( ) ) ; } elseif ( $ message instanceof ResponseInterface ) { $ startMessage = sprintf ( 'Proxy %s start: HTTP/%s %s %s' , $ type , $ message -> getProtocolVersion ( ) , $ message -> getStatusCode ( ) , $ message -> getReasonPhrase ( ) ) ; } if ( ! is_null ( $ startMessage ) ) { $ logger -> log ( Logger :: INFO , $ startMessage ) ; } foreach ( $ message -> getHeaders ( ) as $ name => $ value ) { $ logger -> log ( Logger :: INFO , sprintf ( "Proxy %s header: %s => %s" , $ type , $ name , implode ( ', ' , $ value ) ) ) ; } $ body = $ message -> getBody ( ) ; if ( strlen ( $ body ) > $ maxMessageLength ) { $ body = substr ( $ body , 0 , $ maxMessageLength ) . '[TRUNCATED]' ; } $ logger -> log ( Logger :: INFO , sprintf ( "Proxy %s body: %s" , $ type , $ body ) ) ; if ( ! is_null ( $ message ) && $ message -> getBody ( ) -> isSeekable ( ) ) { $ message -> getBody ( ) -> rewind ( ) ; } return $ message ; } ; }
328	public static function instance ( $ refresh = false ) { $ className = get_called_class ( ) ; if ( $ refresh || ! isset ( self :: $ _instances [ $ className ] ) ) { self :: $ _instances [ $ className ] = Yii :: createObject ( $ className ) ; } return self :: $ _instances [ $ className ] ; }
12167	private function createMenuGroupTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?menu_group`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?menu_group` ( `menu_group_id` int(11) NOT NULL AUTO_INCREMENT, `menu_group_title` varchar(45) NOT NULL, `menu_group_order` int(11) NOT NULL DEFAULT '0', `menu_group_uid` varchar(45) NOT NULL, `menu_group_iscore` TINYINT(1) NOT NULL DEFAULT '0', PRIMARY KEY (`menu_group_id`), UNIQUE KEY `menu_group_id_UNIQUE` (`menu_group_id`), UNIQUE KEY `menu_group_uid_UNIQUE` (`menu_group_uid`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=6 ; " ) ; $ this -> database -> query ( "INSERT INTO `?menu_group` (`menu_group_id`, `menu_group_title`, `menu_group_order`, `menu_group_uid`, `menu_group_iscore`) VALUES (1, 'Media Menu', 1, 'mediamenu', 1), (2, 'User Menu', 2, 'usermenu', 1), (3, 'Dashboard Menu', 3, 'dashboardmenu', 1), (4, 'Messages Menu', 4, 'messagesmenu', 1), (5, 'Profile Menu', 5, 'profilemenu', 1), (6, 'People Menu', 6, 'peoplemenu', 1);" ) ; }
3783	private function getConditionAttribute ( $ settingId ) { $ setting = $ this -> getRow ( $ settingId , 'tl_metamodel_dcasetting' ) ; if ( $ setting -> dcatype == 'attribute' ) { $ attribute = ( object ) $ this -> getRow ( $ setting -> attr_id , 'tl_metamodel_attribute' ) ; $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ attribute -> pid ) ; $ attribute = $ this -> factory -> getMetaModel ( $ metaModelName ) -> getAttributeById ( $ attribute -> id ) ; if ( $ attribute ) { return $ attribute -> getName ( ) ; } } else { $ title = StringUtil :: deserialize ( $ setting -> legendtitle , true ) ; return isset ( $ title [ $ GLOBALS [ 'TL_LANGUAGE' ] ] ) ? $ title [ $ GLOBALS [ 'TL_LANGUAGE' ] ] : current ( $ title ) ; } return 'unknown ' . $ setting -> dcatype ; }
466	public function buildInCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
7320	public function diff ( AstroDate $ b ) { $ prec = 12 ; $ jd1 = $ this -> toJD ( $ prec ) ; $ jd2 = $ b -> toJD ( $ prec ) ; $ days = bcsub ( $ jd1 , $ jd2 , $ prec ) ; return Time :: days ( - 1 * $ days ) ; }
6675	public function add_meta_boxes ( $ post_type , $ post ) { App :: setCurrentID ( 'EFG' ) ; $ is_active = $ this -> get_rating_state ( $ post -> ID ) ; if ( App :: main ( ) -> is_publish_post ( $ post ) && $ is_active ) { $ this -> add_styles ( ) ; $ this -> add_scripts ( ) ; add_meta_box ( 'info_movie-rating-movie' , __ ( 'Extensions For Grifus - Custom rating' , 'extensions-for-grifus-rating' ) , [ $ this , 'render_meta_boxes' ] , $ post_type , 'normal' , 'high' ) ; } }
1716	public function isAllowed ( $ int , $ row ) { if ( $ this -> isAdmin ) { return true ; } if ( ! $ row [ 'includeChmod' ] ) { $ pid = $ row [ 'pid' ] ; $ row [ 'chmod' ] = false ; $ row [ 'cuser' ] = false ; $ row [ 'cgroup' ] = false ; $ objParentPage = PageModel :: findById ( $ pid ) ; while ( $ objParentPage !== null && $ row [ 'chmod' ] === false && $ pid > 0 ) { $ pid = $ objParentPage -> pid ; $ row [ 'chmod' ] = $ objParentPage -> includeChmod ? $ objParentPage -> chmod : false ; $ row [ 'cuser' ] = $ objParentPage -> includeChmod ? $ objParentPage -> cuser : false ; $ row [ 'cgroup' ] = $ objParentPage -> includeChmod ? $ objParentPage -> cgroup : false ; $ objParentPage = PageModel :: findById ( $ pid ) ; } if ( $ row [ 'chmod' ] === false ) { $ row [ 'chmod' ] = Config :: get ( 'defaultChmod' ) ; } if ( $ row [ 'cuser' ] === false ) { $ row [ 'cuser' ] = ( int ) Config :: get ( 'defaultUser' ) ; } if ( $ row [ 'cgroup' ] === false ) { $ row [ 'cgroup' ] = ( int ) Config :: get ( 'defaultGroup' ) ; } } $ chmod = StringUtil :: deserialize ( $ row [ 'chmod' ] ) ; $ chmod = \ is_array ( $ chmod ) ? $ chmod : array ( $ chmod ) ; $ permission = array ( 'w' . $ int ) ; if ( \ in_array ( $ row [ 'cgroup' ] , $ this -> groups ) ) { $ permission [ ] = 'g' . $ int ; } if ( $ row [ 'cuser' ] == $ this -> id ) { $ permission [ ] = 'u' . $ int ; } return \ count ( array_intersect ( $ permission , $ chmod ) ) > 0 ; }
7686	function Misc_ColNum ( $ ColRef , $ IsODF ) { if ( $ IsODF ) { $ p = strpos ( $ ColRef , '.' ) ; if ( $ p !== false ) $ ColRef = substr ( $ ColRef , $ p ) ; $ ColRef = str_replace ( array ( '.' , '$' ) , '' , $ ColRef ) ; $ ColRef = explode ( ':' , $ ColRef ) ; $ ColRef = $ ColRef [ 0 ] ; } $ num = 0 ; $ rank = 0 ; for ( $ i = strlen ( $ ColRef ) - 1 ; $ i >= 0 ; $ i -- ) { $ l = $ ColRef [ $ i ] ; if ( ! is_numeric ( $ l ) ) { $ l = ord ( strtoupper ( $ l ) ) - 64 ; if ( $ l > 0 && $ l < 27 ) { $ num = $ num + $ l * pow ( 26 , $ rank ) ; } else { return $ this -> RaiseError ( '(Sheet) Reference of cell \'' . $ ColRef . '\' cannot be recognized.' ) ; } $ rank ++ ; } } return $ num ; }
12137	public function update ( QuestionRequest $ request , Question $ question ) { try { $ request = $ request -> all ( ) ; $ attributes [ 'title' ] = $ request [ 'title' ] ; $ attributes [ 'question' ] = $ request [ 'question' ] ; $ attributes [ 'category_id' ] = $ request [ 'category_id' ] ; $ question -> update ( $ attributes ) ; return redirect ( '/discussion/' . $ request [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/question/' . $ question -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
3694	public function getBreadcrumb ( GetBreadcrumbEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ elements = $ this -> storeFactory -> createStore ( ) ; $ this -> getBreadcrumbElements ( $ environment , $ elements ) ; $ event -> setElements ( $ elements -> getElements ( ) ) ; $ event -> stopPropagation ( ) ; }
6914	public function removeShipment ( ShipmentInterface $ shipment ) { if ( $ this -> shipments -> contains ( $ shipment ) ) { $ this -> shipments -> removeElement ( $ shipment ) ; } return $ this ; }
9959	public function unprotectCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> unprotectCells ( $ cellRange ) ; }
1168	protected function setRemoteValidation ( $ attribute , $ validateAll = false ) { $ validator = $ this -> validator ; $ rules = $ validator -> getRules ( ) ; $ rules = isset ( $ rules [ $ attribute ] ) ? $ rules [ $ attribute ] : [ ] ; if ( in_array ( 'no_js_validation' , $ rules ) ) { $ validator -> setRules ( [ $ attribute => [ ] ] ) ; return ; } if ( ! $ validateAll ) { $ rules = $ this -> purgeNonRemoteRules ( $ rules , $ validator ) ; } $ validator -> setRules ( [ $ attribute => $ rules ] ) ; }
11518	protected function GenerateHTML5Favicon ( SiteTree $ owner , & $ metadata , Image $ HTML5Favicon ) { $ metadata .= $ owner -> MarkupComment ( 'HTML5 Favicon' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 192 , 192 ) -> getAbsoluteURL ( ) , 'image/png' , '192x192' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 128 , 128 ) -> getAbsoluteURL ( ) , 'image/png' , '128x128' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 96 , 96 ) -> getAbsoluteURL ( ) , 'image/png' , '96x96' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 32 , 32 ) -> getAbsoluteURL ( ) , 'image/png' , '32x32' ) ; $ metadata .= $ owner -> MarkupLink ( 'icon' , $ HTML5Favicon -> Fill ( 16 , 16 ) -> getAbsoluteURL ( ) , 'image/png' , '16x16' ) ; }
5372	public function merge ( $ query ) { if ( is_object ( $ query ) ) { $ this -> request = array_merge ( $ this -> request , $ query -> getAll ( ) ) ; } elseif ( is_array ( $ query ) ) { foreach ( $ query as $ key => $ value ) { $ this -> add ( $ key , $ value ) ; } } }
1390	protected function resourceDoesNotExist ( string $ path ) : void { $ this -> errors -> add ( $ this -> translator -> resourceDoesNotExist ( $ path ) ) ; }
1399	public function errors ( $ errors , $ defaultStatusCode = null , array $ headers = [ ] ) { if ( $ errors instanceof ErrorResponseInterface ) { return $ this -> getErrorResponse ( $ errors ) ; } if ( is_array ( $ errors ) ) { $ errors = $ this -> api -> getErrors ( ) -> errors ( ... $ errors ) ; } return $ this -> errors ( $ this -> factory -> createErrorResponse ( $ errors , $ defaultStatusCode , $ headers ) ) ; }
2077	public function purgeScriptCache ( ) { foreach ( array ( 'assets/js' , 'assets/css' ) as $ dir ) { $ objFolder = new Folder ( $ dir ) ; $ objFolder -> purge ( ) ; } $ this -> import ( StyleSheets :: class , 'StyleSheets' ) ; $ this -> StyleSheets -> updateStyleSheets ( ) ; $ this -> purgePageCache ( ) ; $ this -> log ( 'Purged the script cache' , __METHOD__ , TL_CRON ) ; }
6618	protected function parseEndpointName ( $ method , $ endpoint ) { $ endpoint = str_replace ( ' ' , '' , ucwords ( str_replace ( [ '-' , '+' , '%20' ] , ' ' , $ endpoint ) ) ) ; $ method = strtolower ( $ method ) ; return $ method . $ endpoint . 'Endpoint' ; }
9129	public function setInterceptor ( StreamInterceptor $ interceptor ) { $ this -> interceptor = $ interceptor ; stream_filter_append ( $ this -> stdout , $ interceptor -> getFilterName ( ) ) ; }
10151	private function readFooter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { if ( $ recordData ) { if ( $ this -> version == self :: XLS_BIFF8 ) { $ string = self :: readUnicodeStringLong ( $ recordData ) ; } else { $ string = $ this -> readByteStringShort ( $ recordData ) ; } $ this -> phpSheet -> getHeaderFooter ( ) -> setOddFooter ( $ string [ 'value' ] ) ; $ this -> phpSheet -> getHeaderFooter ( ) -> setEvenFooter ( $ string [ 'value' ] ) ; } } }
3993	public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; $ values = Helper :: encodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( $ values ) ; }
5469	public function overlayMessage ( $ compare , $ dumper ) { $ this -> dumper = $ dumper ; return sprintf ( $ this -> message , $ this -> testMessage ( $ compare ) ) ; }
3313	protected function appendAppIdAndBucketIfEmpty ( array $ options = [ ] ) { $ options [ 'appid' ] = empty ( $ options [ 'appid' ] ) ? $ this -> authorization -> getAppId ( ) : $ options [ 'appid' ] ; $ options [ 'bucket' ] = empty ( $ options [ 'bucket' ] ) ? $ this -> authorization -> getBucket ( ) : $ options [ 'bucket' ] ; return $ options ; }
3326	public function render ( OptionCollection $ options ) { $ lines = array ( ) ; foreach ( $ options as $ option ) { $ c1 = $ this -> renderOption ( $ option ) ; $ lines [ ] = "\t" . $ c1 ; $ lines [ ] = wordwrap ( "\t\t" . $ option -> desc , $ this -> screenWidth , "\n\t\t" ) ; $ lines [ ] = '' ; } return implode ( "\n" , $ lines ) ; }
1335	protected function paginate ( $ query , EncodingParametersInterface $ parameters ) { if ( ! $ this -> paging ) { throw new RuntimeException ( 'Paging is not supported on adapter: ' . get_class ( $ this ) ) ; } if ( method_exists ( $ this -> paging , 'withQualifiedKeyName' ) ) { $ this -> paging -> withQualifiedKeyName ( $ this -> getQualifiedKeyName ( ) ) ; } return $ this -> paging -> paginate ( $ query , $ parameters ) ; }
3196	public function getConsumedExtraTime ( $ tags = null , $ maxTime = 0 , $ target = TimePoint :: TARGET_SERVER ) { if ( $ maxTime ) { $ totalConsumed = $ this -> compute ( $ tags , $ target ) ; $ consumedExtraTime = $ totalConsumed - $ maxTime < 0 ? 0 : $ totalConsumed - $ maxTime ; $ this -> setConsumedExtraTime ( $ consumedExtraTime ) -> save ( ) ; } return $ this -> consumedExtraTime ; }
4394	public function capture ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsCapture ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> capture ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_RECEIVED ; $ order -> setPaymentStatus ( $ status ) ; } }
1501	public function matchesTo ( MediaTypeInterface $ mediaType ) : ? Encoding { return collect ( $ this -> stack ) -> first ( function ( Encoding $ encoding ) use ( $ mediaType ) { return $ encoding -> matchesTo ( $ mediaType ) ; } ) ; }
710	public function tinyInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TINYINT , $ length ) ; }
8587	public function setLowestOfferListing ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LowestOfferListing' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12697	static function getOpts ( $ extname = '' , $ version = '' , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; if ( $ version == '' && self :: isValidVersion ( $ extname ) ) { $ version = $ extname ; $ extname = '' ; } if ( $ version != '' && ! self :: isValidVersion ( $ version ) ) { throw new PakeException ( "'$version' is not a valid version number" ) ; } if ( $ extname == '' ) { $ extname = self :: getDefaultExtName ( ) ; } if ( ! isset ( self :: $ options [ $ extname ] ) || ! is_array ( self :: $ options [ $ extname ] ) ) { if ( isset ( $ cliopts [ 'config-file' ] ) ) { $ cfgfile = $ cliopts [ 'config-file' ] ; } else { $ cfgfile = self :: getOptionsDir ( ) . "/options-$extname.yaml" ; } if ( isset ( $ cliopts [ 'user-config-file' ] ) ) { $ usercfgfile = $ cliopts [ 'user-config-file' ] ; if ( ! is_file ( $ cliopts [ 'user-config-file' ] ) ) { throw new PakeException ( "Could not find user-configuration-file {$cliopts['user-config-file']}" ) ; } } else { $ usercfgfile = self :: getOptionsDir ( ) . "/options-user.yaml" ; } foreach ( $ cliopts as $ opt => $ val ) { if ( substr ( $ opt , 0 , 7 ) == 'option.' ) { unset ( $ cliopts [ $ opt ] ) ; $ work = array_reverse ( explode ( '.' , substr ( $ opt , 7 ) ) ) ; $ built = array ( array_shift ( $ work ) => $ val ) ; foreach ( $ work as $ key ) { $ built = array ( $ key => $ built ) ; } self :: recursivemerge ( $ cliopts , $ built ) ; } } self :: loadConfiguration ( $ cfgfile , $ extname , $ version , $ usercfgfile , $ cliopts ) ; } pake_echo ( "Building extension $extname ( " . self :: $ options [ $ extname ] [ 'extension' ] [ 'name' ] . " ) version " . self :: $ options [ $ extname ] [ 'version' ] [ 'alias' ] . self :: $ options [ $ extname ] [ 'releasenr' ] [ 'separator' ] . self :: $ options [ $ extname ] [ 'version' ] [ 'release' ] ) ; return self :: $ options [ $ extname ] ; }
49	protected function getScriptListeners ( Event $ event ) { $ package = $ this -> composer -> getPackage ( ) ; $ scripts = $ package -> getScripts ( ) ; if ( empty ( $ scripts [ $ event -> getName ( ) ] ) ) { return array ( ) ; } if ( $ this -> loader ) { $ this -> loader -> unregister ( ) ; } $ generator = $ this -> composer -> getAutoloadGenerator ( ) ; if ( $ event instanceof ScriptEvent ) { $ generator -> setDevMode ( $ event -> isDevMode ( ) ) ; } $ packages = $ this -> composer -> getRepositoryManager ( ) -> getLocalRepository ( ) -> getCanonicalPackages ( ) ; $ packageMap = $ generator -> buildPackageMap ( $ this -> composer -> getInstallationManager ( ) , $ package , $ packages ) ; $ map = $ generator -> parseAutoloads ( $ packageMap , $ package ) ; $ this -> loader = $ generator -> createLoader ( $ map ) ; $ this -> loader -> register ( ) ; return $ scripts [ $ event -> getName ( ) ] ; }
6639	protected function initNavigation ( ) { Yii :: $ app -> params [ 'nav' ] [ 'wavecms_dashboard' ] = [ 'label' => FontAwesome :: icon ( 'home' ) . Yii :: t ( 'wavecms/main' , 'Dashboard' ) , 'url' => [ '/' ] , 'position' => 500 ] ; Yii :: $ app -> params [ 'nav' ] [ 'wavecms_user' ] = [ 'label' => FontAwesome :: icon ( 'users' ) . Yii :: t ( 'wavecms/user' , 'Users' ) , 'url' => 'javascript: ;' , 'options' => [ 'class' => 'drop-down' ] , 'permission' => 'wavecms-user' , 'position' => 9000 , 'items' => [ [ 'label' => FontAwesome :: icon ( 'user' ) . Yii :: t ( 'wavecms/user' , 'List of users' ) , 'url' => [ '/wavecms/user/index' ] ] , [ 'label' => FontAwesome :: icon ( 'key' ) . Yii :: t ( 'wavecms/user' , 'Roles' ) , 'url' => [ '/wavecms/role/index' ] ] , ] ] ; Yii :: $ app -> params [ 'nav' ] [ 'wavecms_settings' ] = [ 'label' => FontAwesome :: icon ( 'cog' ) . Yii :: t ( 'wavecms/main' , 'Settings' ) , 'url' => 'javascript: ;' , 'options' => [ 'class' => 'drop-down' ] , 'permission' => 'wavecms-settings' , 'position' => 10000 , 'items' => [ [ 'label' => FontAwesome :: icon ( 'flag' ) . Yii :: t ( 'wavecms/main' , 'Translations' ) , 'url' => [ '/wavecms/translation/index' ] ] , [ 'label' => FontAwesome :: icon ( 'database' ) . Yii :: t ( 'wavecms/main' , 'Cache' ) , 'url' => [ '/wavecms/settings/cache' ] ] ] ] ; }
11596	public function exec ( $ dwnlBonus ) { $ result = [ ] ; $ mapById = $ this -> hlpDwnlTree -> mapById ( $ dwnlBonus , EBonDwnl :: A_CUST_REF ) ; $ mapTeams = $ this -> hlpDwnlTree -> mapByTeams ( $ dwnlBonus , EBonDwnl :: A_CUST_REF , EBonDwnl :: A_PARENT_REF ) ; foreach ( $ dwnlBonus as $ one ) { $ custId = $ one -> getCustomerRef ( ) ; $ cust = $ mapById [ $ custId ] ; $ tv = $ cust -> getPv ( ) ; if ( isset ( $ mapTeams [ $ custId ] ) ) { $ frontTeam = $ mapTeams [ $ custId ] ; foreach ( $ frontTeam as $ teamMemberId ) { $ member = $ mapById [ $ teamMemberId ] ; $ memberPv = $ member -> getPv ( ) ; $ tv += $ memberPv ; } } $ cust -> setTv ( $ tv ) ; $ result [ $ custId ] = $ cust ; } return $ result ; }
3776	public function run ( ) { $ template = new BackendTemplate ( 'be_dcastylepicker' ) ; $ template -> main = '' ; $ template -> headline = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodelspicker' ] ; $ inputName = Input :: get ( 'inputName' ) ; if ( ! preg_match ( '~^[a-z\-_0-9]+$~i' , $ inputName ) ) { throw new RuntimeException ( 'Field-Parameter ERROR!' ) ; } $ template -> field = $ inputName ; $ template -> items = $ GLOBALS [ Input :: get ( 'item' ) ] ; if ( ! strlen ( $ template -> headline ) ) { $ template -> headline = $ GLOBALS [ 'TL_CONFIG' ] [ 'websiteTitle' ] ; } $ template -> theme = Backend :: getTheme ( ) ; $ template -> base = Environment :: get ( 'base' ) ; $ template -> language = $ GLOBALS [ 'TL_LANGUAGE' ] ; $ template -> title = $ GLOBALS [ 'TL_CONFIG' ] [ 'websiteTitle' ] ; $ template -> charset = $ GLOBALS [ 'TL_CONFIG' ] [ 'characterSet' ] ; $ template -> pageOffset = Input :: cookie ( 'BE_PAGE_OFFSET' ) ; $ template -> error = ( Input :: get ( 'act' ) == 'error' ) ? $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] : '' ; $ template -> skipNavigation = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'skipNavigation' ] ; $ template -> request = ampersand ( Environment :: get ( 'request' ) ) ; $ template -> top = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backToTop' ] ; $ template -> be27 = ! $ GLOBALS [ 'TL_CONFIG' ] [ 'oldBeTheme' ] ; $ template -> expandNode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'expandNode' ] ; $ template -> collapseNode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'collapseNode' ] ; $ template -> strField = Input :: get ( 'fld' ) ; $ template -> output ( ) ; }
8382	public function fetch ( ) { if ( $ this -> statement == null || $ this -> getErrorState ( ) != '00000' ) { return false ; } return $ this -> statement -> fetch ( \ PDO :: FETCH_ASSOC ) ; }
11467	public function init ( array $ viewDirs , array $ params ) { $ this -> viewDirs = $ viewDirs ; $ this -> params = $ params ; $ this -> parts = new ClearViewPartsCollection ( ) ; }
6252	protected function createUngroupedGroupPresence ( $ id = null ) { $ id = $ id ? : 'automatic-ungrouped-permissions' ; return new AclPresence ( [ 'type' => AclPresenceType :: GROUP , 'id' => $ id , 'label' => 'acl.ungrouped-permissions' , 'translated' => true , ] ) ; }
5143	public static function create ( array $ data ) : \ One \ Model \ Photo { $ url = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'url' , '' ) ) ; $ ratio = self :: validateString ( ( string ) self :: checkData ( $ data , 'ratio' , '' ) ) ; $ description = self :: validateString ( ( string ) self :: checkData ( $ data , 'description' , '' ) ) ; $ information = self :: validateString ( ( string ) self :: checkData ( $ data , 'information' , '' ) ) ; return self :: createPhoto ( $ url , $ ratio , $ description , $ information ) ; }
10200	private function writeXfStyles ( XMLWriter $ writer , Spreadsheet $ spreadsheet ) { foreach ( $ spreadsheet -> getCellXfCollection ( ) as $ style ) { $ writer -> startElement ( 'style:style' ) ; $ writer -> writeAttribute ( 'style:name' , self :: CELL_STYLE_PREFIX . $ style -> getIndex ( ) ) ; $ writer -> writeAttribute ( 'style:family' , 'table-cell' ) ; $ writer -> writeAttribute ( 'style:parent-style-name' , 'Default' ) ; $ writer -> startElement ( 'style:text-properties' ) ; $ font = $ style -> getFont ( ) ; if ( $ font -> getBold ( ) ) { $ writer -> writeAttribute ( 'fo:font-weight' , 'bold' ) ; $ writer -> writeAttribute ( 'style:font-weight-complex' , 'bold' ) ; $ writer -> writeAttribute ( 'style:font-weight-asian' , 'bold' ) ; } if ( $ font -> getItalic ( ) ) { $ writer -> writeAttribute ( 'fo:font-style' , 'italic' ) ; } if ( $ color = $ font -> getColor ( ) ) { $ writer -> writeAttribute ( 'fo:color' , sprintf ( '#%s' , $ color -> getRGB ( ) ) ) ; } if ( $ family = $ font -> getName ( ) ) { $ writer -> writeAttribute ( 'fo:font-family' , $ family ) ; } if ( $ size = $ font -> getSize ( ) ) { $ writer -> writeAttribute ( 'fo:font-size' , sprintf ( '%.1fpt' , $ size ) ) ; } if ( $ font -> getUnderline ( ) && $ font -> getUnderline ( ) != Font :: UNDERLINE_NONE ) { $ writer -> writeAttribute ( 'style:text-underline-style' , 'solid' ) ; $ writer -> writeAttribute ( 'style:text-underline-width' , 'auto' ) ; $ writer -> writeAttribute ( 'style:text-underline-color' , 'font-color' ) ; switch ( $ font -> getUnderline ( ) ) { case Font :: UNDERLINE_DOUBLE : $ writer -> writeAttribute ( 'style:text-underline-type' , 'double' ) ; break ; case Font :: UNDERLINE_SINGLE : $ writer -> writeAttribute ( 'style:text-underline-type' , 'single' ) ; break ; } } $ writer -> endElement ( ) ; $ writer -> startElement ( 'style:table-cell-properties' ) ; $ writer -> writeAttribute ( 'style:rotation-align' , 'none' ) ; if ( $ fill = $ style -> getFill ( ) ) { switch ( $ fill -> getFillType ( ) ) { case Fill :: FILL_SOLID : $ writer -> writeAttribute ( 'fo:background-color' , sprintf ( '#%s' , strtolower ( $ fill -> getStartColor ( ) -> getRGB ( ) ) ) ) ; break ; case Fill :: FILL_GRADIENT_LINEAR : case Fill :: FILL_GRADIENT_PATH : break ; case Fill :: FILL_NONE : default : } } $ writer -> endElement ( ) ; $ writer -> endElement ( ) ; } }
6809	public function currency ( float $ number , string $ currency = null ) : string { return $ this -> getCurrencyFormatter ( ) -> formatCurrency ( $ number , $ currency ? $ currency : $ this -> currency ) ; }
7265	public static function select ( $ queryString = "" , array $ queryParams = [ ] ) { $ tableName = static :: tableName ( ) ; $ rows = Db :: query ( " select $tableName.* from $tableName $queryString " , $ queryParams , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return new Collection ( [ ] ) ; $ collection = [ ] ; foreach ( $ rows as $ row ) { $ model = new static ; foreach ( $ row as $ column => $ val ) $ model -> $ column = $ model -> decodeValue ( $ val , $ column ) ; $ collection [ ] = $ model ; } return new Collection ( $ collection ) ; }
7610	public function signup ( ) { if ( $ this -> validate ( ) ) { $ user = new User ( ) ; $ user -> username = $ this -> username ; $ user -> email = $ this -> email ; $ user -> setPassword ( $ this -> password ) ; $ user -> generateAuthKey ( ) ; if ( $ user -> save ( ) ) { return $ user ; } } return null ; }
8528	public function listFinancialEventGroupsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroupsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10055	public function push ( $ type , $ value , $ reference = null ) { $ this -> stack [ $ this -> count ++ ] = [ 'type' => $ type , 'value' => $ value , 'reference' => $ reference , ] ; if ( $ type == 'Function' ) { $ localeFunction = Calculation :: localeFunc ( $ value ) ; if ( $ localeFunction != $ value ) { $ this -> stack [ ( $ this -> count - 1 ) ] [ 'localeValue' ] = $ localeFunction ; } } }
9566	public function addAfterHook ( $ hook ) { if ( ! isset ( $ this -> options [ 'after' ] ) ) { $ this -> options [ 'after' ] = [ ] ; } $ this -> options [ 'after' ] [ ] = $ hook ; }
6169	protected function writeException ( $ exception ) { $ this -> writeNewLine ( ) ; do { $ exceptionStack [ ] = $ exception ; } while ( $ exception = $ exception -> getPreviousWrapped ( ) ) ; foreach ( explode ( "\n" , $ exception = array_shift ( $ exceptionStack ) ) as $ line ) { if ( $ exception && false !== $ pos = strpos ( $ line , $ exception -> getClassName ( ) . ': ' ) ) { $ whitespace = str_repeat ( ' ' , ( $ pos += strlen ( $ exception -> getClassName ( ) ) ) + 2 ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , sprintf ( ' %s ' , substr ( $ line , 0 , $ pos ) ) , false ) ; $ this -> writeWithColor ( 'fg-red' , substr ( $ line , $ pos + 1 ) ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ exception = array_shift ( $ exceptionStack ) ; continue ; } $ this -> writeWithColor ( 'fg-red' , $ line ) ; } }
6368	private function parseWithMode ( $ raw_taf , $ strict ) { $ clean_taf = trim ( $ raw_taf ) ; $ clean_taf = preg_replace ( "#\n+#" , ' ' , $ clean_taf ) ; $ clean_taf = preg_replace ( "#\r+#" , ' ' , $ clean_taf ) ; $ clean_taf = preg_replace ( '#[ ]{2,}#' , ' ' , $ clean_taf ) . ' ' ; $ clean_taf = strtoupper ( $ clean_taf ) ; if ( strpos ( $ clean_taf , 'CNL' ) === false ) { $ remaining_taf = trim ( $ clean_taf ) . ' END' ; } else { $ remaining_taf = $ clean_taf ; } $ decoded_taf = new DecodedTaf ( $ clean_taf ) ; $ with_cavok = false ; foreach ( $ this -> decoder_chain as $ chunk_decoder ) { try { $ decoded = $ chunk_decoder -> parse ( $ remaining_taf , $ with_cavok ) ; $ result = $ decoded [ 'result' ] ; if ( $ result != null ) { foreach ( $ result as $ key => $ value ) { if ( $ value !== null ) { $ setter_name = 'set' . ucfirst ( $ key ) ; $ decoded_taf -> $ setter_name ( $ value ) ; } } } $ remaining_taf = $ decoded [ 'remaining_taf' ] ; } catch ( ChunkDecoderException $ cde ) { $ decoded_taf -> addDecodingException ( $ cde ) ; if ( $ strict ) { break ; } $ remaining_taf = $ cde -> getRemainingTaf ( ) ; } if ( $ chunk_decoder instanceof VisibilityChunkDecoder ) { $ with_cavok = $ decoded_taf -> getCavok ( ) ; } } $ evolutionDecoder = new EvolutionChunkDecoder ( $ strict , $ with_cavok ) ; while ( $ remaining_taf != null && trim ( $ remaining_taf ) != 'END' ) { $ evolutionDecoder -> parse ( $ remaining_taf , $ decoded_taf ) ; $ remaining_taf = $ evolutionDecoder -> getRemaining ( ) ; } return $ decoded_taf ; }
2105	protected function generateFaqLink ( $ objFaq ) { $ objCategory = $ objFaq -> getRelated ( 'pid' ) ; $ jumpTo = ( int ) $ objCategory -> jumpTo ; if ( $ jumpTo < 1 ) { throw new \ Exception ( "FAQ categories without redirect page cannot be used in an FAQ list" ) ; } if ( ! isset ( $ this -> arrTargets [ $ jumpTo ] ) ) { $ this -> arrTargets [ $ jumpTo ] = ampersand ( Environment :: get ( 'request' ) , true ) ; if ( $ jumpTo > 0 && ( $ objTarget = PageModel :: findByPk ( $ jumpTo ) ) !== null ) { $ this -> arrTargets [ $ jumpTo ] = ampersand ( $ objTarget -> getFrontendUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ) ; } } return sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ this -> arrTargets [ $ jumpTo ] ) , ( $ objFaq -> alias ? : $ objFaq -> id ) ) ; }
9137	public function call ( callable $ callable , array $ args = [ ] ) { $ args = $ this -> resolveArguments ( $ args ) ; $ reflection = $ this -> reflectCallable ( $ callable ) ; return call_user_func_array ( $ callable , $ this -> getParameters ( $ reflection , $ args ) ) ; }
11201	public function fetchOffset ( $ num ) { if ( $ this -> contentModified ) { $ this -> generateContent ( ) ; } $ key = $ this -> fetchOffsetKey ( $ num ) ; if ( $ key != null ) { return $ this -> content [ $ key ] ; } return null ; }
11388	public function create ( $ action ) { $ actionName = ucfirst ( $ action ) ; $ class = sprintf ( 'RedKiteCms\Content\BlockManager\BlockManager%s' , $ actionName ) ; if ( ! class_exists ( $ class ) ) { return null ; } $ reflectionClass = new \ ReflectionClass ( $ class ) ; return $ reflectionClass -> newInstance ( $ this -> serializer , $ this -> optionsResolver ) ; }
9482	private function prepare ( array $ folders ) { return collect ( $ folders ) -> mapWithKeys ( function ( $ folder ) { $ path = base_path ( $ folder ) ; return [ $ folder => [ 'chmod' => ( int ) substr ( sprintf ( '%o' , fileperms ( $ path ) ) , - 4 ) , 'writable' => is_writable ( $ path ) , ] , ] ; } ) ; }
6655	public function normalizeHeaders ( $ params ) { $ out = '' ; foreach ( $ params as $ key => $ param ) { $ out .= $ key . '="' . rawurlencode ( trim ( $ param ) ) . '",' ; } return rtrim ( $ out , ',' ) ; }
8623	public function setOfferListingCount ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OfferListingCount' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1219	private function debugRequest ( $ url , array $ headers , $ body ) { $ str = $ url . PHP_EOL ; $ str .= array_reduce ( array_keys ( $ headers ) , function ( $ str , $ key ) use ( $ headers ) { $ str .= $ key . ': ' . $ headers [ $ key ] . PHP_EOL ; return $ str ; } , '' ) ; $ str .= $ body ; $ this -> debug ( $ str ) ; }
9868	private function writePrintOptions ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'printOptions' ) ; $ objWriter -> writeAttribute ( 'gridLines' , ( $ pSheet -> getPrintGridlines ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'gridLinesSet' , 'true' ) ; if ( $ pSheet -> getPageSetup ( ) -> getHorizontalCentered ( ) ) { $ objWriter -> writeAttribute ( 'horizontalCentered' , 'true' ) ; } if ( $ pSheet -> getPageSetup ( ) -> getVerticalCentered ( ) ) { $ objWriter -> writeAttribute ( 'verticalCentered' , 'true' ) ; } $ objWriter -> endElement ( ) ; }
2559	protected function loadPaymentSupplementaryData ( MopInfo $ options ) { foreach ( $ options -> paySupData as $ paySupData ) { $ this -> paymentModule -> paymentSupplementaryData [ ] = new PaymentSupplementaryData ( $ paySupData -> function , $ paySupData -> data ) ; } }
7029	public function getMessagesForQuantity ( float $ quantity ) { $ messages = [ ] ; if ( $ quantity < $ this -> minimumQuantity ) { $ messages [ ] = $ this -> minimumMessage ; } elseif ( 0 < $ this -> maximumQuantity && $ quantity > $ this -> maximumQuantity ) { $ messages [ ] = $ this -> maximumMessage ; } else { if ( null !== $ this -> availableMessage ) { $ messages [ ] = $ this -> availableMessage ; } if ( $ quantity > $ this -> availableQuantity ) { if ( null !== $ this -> resupplyMessage ) { $ messages [ ] = $ this -> resupplyMessage ; if ( $ quantity > $ this -> availableQuantity + $ this -> resupplyQuantity ) { $ messages [ ] = $ this -> overflowMessage ; } } else { $ messages [ ] = $ this -> overflowMessage ; } } } if ( empty ( $ messages ) ) { $ messages [ ] = $ this -> overflowMessage ; } return $ messages ; }
4565	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ user = $ event -> getUser ( ) ; $ roles = [ ] ; if ( $ user instanceof User ) { $ roles = $ user -> getIdentity ( ) -> getRoles ( ) ; } else { if ( null !== $ user -> getIdentityUuid ( ) ) { switch ( $ user -> getIdentity ( ) ) { case Identity :: ANONYMOUS : $ identity = $ this -> api -> get ( 'identities.anonymous' ) -> get ( $ user -> getIdentityUuid ( ) ) ; break ; case Identity :: INDIVIDUAL : $ identity = $ this -> api -> get ( 'identities.individual' ) -> get ( $ user -> getIdentityUuid ( ) ) ; break ; case Identity :: ORGANIZATION : $ identity = $ this -> api -> get ( 'identities.organization' ) -> get ( $ user -> getIdentityUuid ( ) ) ; break ; case Identity :: STAFF : $ identity = $ this -> api -> get ( 'identities.staff' ) -> get ( $ user -> getIdentityUuid ( ) ) ; break ; case Identity :: SYSTEM : $ identity = $ this -> api -> get ( 'identities.system' ) -> get ( $ user -> getIdentityUuid ( ) ) ; break ; default : throw new DomainException ( 'User identity is not valid.' ) ; } foreach ( $ identity -> getRoles ( ) as $ role ) { $ roles [ ] = substr ( $ role , - 36 ) ; } } } $ this -> accessor -> setValue ( $ data , $ this -> property , $ roles ) ; $ event -> setData ( $ data ) ; }
5150	protected function getEmailRecipients ( $ email ) { $ recipients = $ email -> Headers -> to . ' ' . $ email -> Headers -> cc ; if ( $ email -> Headers -> bcc != NULL ) { $ recipients .= ' ' . $ email -> Headers -> bcc ; } return $ recipients ; }
9527	private function parseEvery ( ) { $ results = [ ] ; $ i = 0 ; while ( $ i < count ( $ this -> argv ) ) { $ parameter = $ this -> argv [ $ i ] ; if ( $ this -> parseSingle ( $ i , $ parameter , $ results ) === false ) { break ; } } return $ results ; }
11960	public function reduce ( Closure $ fn , $ initial = null ) { return array_reduce ( $ this -> elements , $ fn , $ initial ) ; }
6419	public function start ( ) : Stopwatch { Preconditions :: checkState ( ! $ this -> isRunning , 'This stopwatch is already running.' ) ; $ this -> isRunning = true ; $ this -> startTick = $ this -> ticker -> read ( ) ; return $ this ; }
11573	public function SendHeaders ( ) { if ( headers_sent ( ) ) { return $ this ; } header ( 'HTTP/' . $ this -> Version . ' ' . $ this -> StatusCode . ' ' . $ this -> StatusText , true , $ this -> StatusCode ) ; foreach ( $ this -> Headers -> GetCookies ( ) as $ cookie ) { } return $ this ; }
6835	protected function preventForbiddenChange ( Model \ InvoiceLineInterface $ line ) { if ( $ this -> persistenceHelper -> isChanged ( $ line , 'type' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ line , 'type' ) ; if ( $ old !== $ new ) { throw new Exception \ RuntimeException ( "Changing the invoice line's type is not supported." ) ; } } }
11394	public static function setKindOfReportLog ( string $ sKindOfReportLog ) { if ( $ sKindOfReportLog === 'screen' || $ sKindOfReportLog === 'all' ) { self :: $ _sKindOfReportLog = $ sKindOfReportLog ; } else { self :: $ _sKindOfReportLog = 'error_log' ; } }
7931	public function appendToCollection ( array $ data ) { list ( $ data ) = $ this -> fireEvent ( 'append-to-collection' , [ $ data ] ) ; $ files = [ ] ; if ( isset ( $ data [ 'files' ] [ 'js' ] ) && is_array ( $ data [ 'files' ] [ 'js' ] ) ) $ files [ 'js' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'js' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; if ( isset ( $ data [ 'files' ] [ 'css' ] ) && is_array ( $ data [ 'files' ] [ 'css' ] ) ) $ files [ 'css' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'css' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; $ this -> collection [ ] = [ 'order' => isset ( $ data [ 'order' ] ) ? $ data [ 'order' ] : 0 , 'name' => isset ( $ data [ 'name' ] ) ? $ data [ 'name' ] : uniqid ( ) , 'files' => $ files , 'group' => isset ( $ data [ 'group' ] ) ? $ data [ 'group' ] : $ this -> defaultGroup , 'require' => isset ( $ data [ 'require' ] ) ? $ data [ 'require' ] : [ ] ] ; return $ this ; }
8119	public function submitReview ( $ record , $ data ) { if ( ! $ this -> canSubmitReview ( $ record ) ) { throw new ValidationException ( _t ( __CLASS__ . '.ErrorReviewPermissionDenied' , 'It seems you don\'t have the necessary permissions to submit a content review' ) ) ; } $ notes = ( ! empty ( $ data [ 'Review' ] ) ? $ data [ 'Review' ] : _t ( __CLASS__ . '.NoComments' , '(no comments)' ) ) ; $ record -> addReviewNote ( Security :: getCurrentUser ( ) , $ notes ) ; $ record -> advanceReviewDate ( ) ; $ request = $ this -> controller -> getRequest ( ) ; $ message = _t ( __CLASS__ . '.Success' , 'Review successfully added' ) ; if ( $ request -> getHeader ( 'X-Formschema-Request' ) ) { return $ message ; } elseif ( Director :: is_ajax ( ) ) { $ response = HTTPResponse :: create ( $ message , 200 ) ; $ response -> addHeader ( 'Content-Type' , 'text/html; charset=utf-8' ) ; return $ response ; } return $ this -> controller -> redirectBack ( ) ; }
12764	public function add ( string $ header ) : self { foreach ( $ this -> getAll ( ) as $ tmp ) { if ( $ tmp === $ header ) { throw new Exception ( "The '{$header}' header has already been added." ) ; } } $ this -> headerList [ ] = $ header ; return self :: $ instance ; }
844	public function clearEmptyTokens ( ) { $ limit = $ this -> count ( ) ; $ index = 0 ; for ( ; $ index < $ limit ; ++ $ index ) { if ( $ this -> isEmptyAt ( $ index ) ) { break ; } } if ( $ limit === $ index ) { return ; } for ( $ count = $ index ; $ index < $ limit ; ++ $ index ) { if ( ! $ this -> isEmptyAt ( $ index ) ) { $ this [ $ count ++ ] = $ this [ $ index ] ; } } $ this -> setSize ( $ count ) ; }
12643	public function getWidgetId ( ) { if ( ! is_null ( $ this -> _widgetId ) ) { return $ this -> _widgetId ; } return $ this -> _widgetId = 'ic-widget-' . md5 ( microtime ( ) . mt_rand ( ) ) ; }
6369	public static function compose ( callable $ g , callable $ f ) : callable { return function ( $ input ) use ( $ g , $ f ) { return Functions :: call ( $ g , Functions :: call ( $ f , $ input ) ) ; } ; }
6553	public function unlock ( ) { try { if ( $ this -> pid === $ this -> getSerial ( ) && is_resource ( $ this -> fh ) ) { $ this -> removeLineFromFile ( $ this -> pid , $ this -> fh ) ; flock ( $ this -> fh , LOCK_UN ) ; fclose ( $ this -> fh ) ; if ( filesize ( $ filename = $ this -> getPidFilename ( ) ) === 0 ) { unlink ( $ filename ) ; } } } catch ( FileNotFoundException $ fnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID file %s doesn\'t exist' , $ this -> getPidFilename ( ) ) ) ; } catch ( LineNotFoundException $ lnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID %s is can not be found in PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) ) ; } catch ( \ Exception $ e ) { throw new \ Exception ( sprintf ( 'Can\'t remove PID %s from PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) , null , $ e ) ; } }
5529	protected function chainMockReturns ( ) { $ code = " function returns(\$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returns(\$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsAt(\$timing, \$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsAt(\$timing, \$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByValue(\$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returns(\$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByValueAt(\$timing, \$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByValueAt(\$timing, \$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByReference(\$method, &\$ref, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByReference(\$method, \$ref, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByReferenceAt(\$timing, \$method, &\$ref, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByReferenceAt(\$timing, \$method, \$ref, \$args);\n" ; $ code .= " }\n" ; return $ code ; }
447	private function attachBehaviorInternal ( $ name , $ behavior ) { if ( ! ( $ behavior instanceof Behavior ) ) { $ behavior = Yii :: createObject ( $ behavior ) ; } if ( is_int ( $ name ) ) { $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ ] = $ behavior ; } else { if ( isset ( $ this -> _behaviors [ $ name ] ) ) { $ this -> _behaviors [ $ name ] -> detach ( ) ; } $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ $ name ] = $ behavior ; } return $ behavior ; }
4515	public static function parseFile ( string $ file , array $ data = [ ] ) : array { $ string = file_get_contents ( $ file ) ; return static :: parse ( $ string , $ data ) ; }
5835	private function clearExpiredCacheEntries ( int $ now ) { $ this -> now = $ now ; foreach ( $ this -> cacheTimeouts as $ path => $ timeout ) { if ( $ now <= $ timeout ) { break ; } $ fileInfo = $ this -> cache [ $ path ] ; unset ( $ this -> cache [ $ path ] , $ this -> cacheTimeouts [ $ path ] ) ; $ this -> bufferedFileCount -= isset ( $ fileInfo -> buffer ) ; $ this -> cacheEntryCount -- ; } }
2571	public static function isValidFopType ( $ fopType ) { return ( $ fopType == self :: IDENT_CASH || $ fopType == self :: IDENT_CHECK || $ fopType == self :: IDENT_CREDITCARD || $ fopType == self :: IDENT_MISC ) ; }
8501	public function setGetMatchingProductForIdResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMatchingProductForIdResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5126	public static function init ( array $ directories , EnvironmentInterface $ environment = null , bool $ handleErrors = true ) : ? self { if ( $ handleErrors ) { ExceptionHandler :: register ( ) ; } $ core = new static ( new Container ( ) , $ directories ) ; $ core -> container -> bindSingleton ( EnvironmentInterface :: class , $ environment ?? new Environment ( ) ) ; try { ContainerScope :: runScope ( $ core -> container , function ( ) use ( $ core ) { $ core -> bootload ( ) ; $ core -> bootstrap ( ) ; } ) ; } catch ( \ Throwable $ e ) { ExceptionHandler :: handleException ( $ e ) ; return null ; } return $ core ; }
10891	public function syntax ( $ error = "Please specify valid options" ) { $ ostr = ( ! $ error ) ? STDOUT : STDERR ; if ( is_string ( $ error ) ) fprintf ( $ ostr , "Error: %s\n" , $ error ) ; fprintf ( $ ostr , "Syntax: php " . $ _SERVER [ 'argv' ] [ 0 ] . " <options> <action>\n\n" ) ; fprintf ( $ ostr , "Options: \n" ) ; $ max_opt_length = 0 ; $ max_arg_length = 0 ; $ params = $ this -> parameters ; usort ( $ params , function ( $ a , $ b ) { $ lo = ! empty ( $ a [ 0 ] ) ? $ a [ 0 ] : $ a [ 1 ] ; $ ro = ! empty ( $ b [ 0 ] ) ? $ b [ 0 ] : $ b [ 1 ] ; return strcmp ( $ lo , $ ro ) ; } ) ; foreach ( $ params as $ param ) { $ max_opt_length = max ( strlen ( $ param [ 1 ] ) + 3 , $ max_opt_length ) ; $ max_arg_length = max ( strlen ( $ param [ 2 ] ) + 3 , $ max_arg_length ) ; } foreach ( $ this -> parameters as $ param ) { fprintf ( $ ostr , " " ) ; $ so = $ param [ 0 ] ? "-" . $ param [ 0 ] : "" ; $ lo = $ param [ 1 ] ? "--" . $ param [ 1 ] : "" ; $ arg = $ param [ 2 ] ? '<' . $ param [ 2 ] . '>' : "" ; $ pstr = sprintf ( "%-2s %-" . $ max_opt_length . "s %-" . $ max_arg_length . "s " , $ so , $ lo , $ arg ) ; $ indent = strlen ( $ pstr ) + 4 ; fprintf ( $ ostr , $ pstr ) ; self :: formatText ( $ indent , self :: MAX_LINE_LENGTH , $ param [ 3 ] , $ ostr ) ; } exit ( $ error === false ? 0 : 1 ) ; }
11433	public function query ( $ keyword , $ categories , array $ other = [ ] ) { $ params = [ 'query' => $ keyword , 'category' => implode ( ',' , ( array ) $ categories ) , 'appid' => $ this -> getAccessToken ( ) -> getAppId ( ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , array_merge ( $ params , $ other ) ] ) ; }
1698	private function loadFrontendUser ( string $ username , BackendUser $ backendUser ) : ? FrontendUser { try { $ frontendUser = $ this -> userProvider -> loadUserByUsername ( $ username ) ; if ( ! $ frontendUser instanceof FrontendUser ) { throw new UsernameNotFoundException ( 'User is not a front end user' ) ; } } catch ( UsernameNotFoundException $ e ) { if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'Could not find a front end user with the username "%s"' , $ username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , '' ) ] ) ; } return null ; } $ allowedGroups = StringUtil :: deserialize ( $ backendUser -> amg , true ) ; $ frontendGroups = StringUtil :: deserialize ( $ frontendUser -> groups , true ) ; if ( ! $ backendUser -> isAdmin && ! \ count ( array_intersect ( $ frontendGroups , $ allowedGroups ) ) ) { return null ; } return $ frontendUser ; }
2956	public function deviceClose ( ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { return true ; } if ( fclose ( $ this -> _dHandle ) ) { $ this -> _dHandle = null ; $ this -> _dState = SERIAL_DEVICE_SET ; return true ; } trigger_error ( "Unable to close the device" , E_USER_ERROR ) ; return false ; }
6544	public function currentShardingKey ( ) { return isset ( $ this -> options [ SelectorSourceInterface :: SHARDING_KEY ] ) ? $ this -> options [ SelectorSourceInterface :: SHARDING_KEY ] : null ; }
1539	protected function isExpectingContent ( $ request ) : bool { $ methods = $ this -> route -> isNotRelationship ( ) ? [ 'POST' , 'PATCH' ] : [ 'POST' , 'PATCH' , 'DELETE' ] ; return \ in_array ( $ request -> getMethod ( ) , $ methods ) ; }
1327	public function toUrl ( ) { $ postData = $ this -> toPostdata ( ) ; $ out = $ this -> getNormalizedHttpUrl ( ) ; if ( $ postData ) { $ out .= '?' . $ postData ; } return $ out ; }
642	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
8808	public function get ( $ key = null ) { return ( is_null ( $ key ) ? $ _COOKIE : ( $ this -> has ( $ key ) ? $ _COOKIE [ $ key ] : null ) ) ; }
181	public function getConverter ( ) { if ( $ this -> _converter === null ) { $ this -> _converter = Yii :: createObject ( AssetConverter :: className ( ) ) ; } elseif ( is_array ( $ this -> _converter ) || is_string ( $ this -> _converter ) ) { if ( is_array ( $ this -> _converter ) && ! isset ( $ this -> _converter [ 'class' ] ) ) { $ this -> _converter [ 'class' ] = AssetConverter :: className ( ) ; } $ this -> _converter = Yii :: createObject ( $ this -> _converter ) ; } return $ this -> _converter ; }
3423	protected function groupsMustBeSelected ( ) { return in_array ( 'GROUPS' , $ this -> select ) || in_array ( 'GROUP_ID' , $ this -> select ) || in_array ( 'GROUPS_ID' , $ this -> select ) ; }
8212	protected function validateFile ( $ filePath , $ message = 'File' , $ allowEmpty = true ) { if ( ! file_exists ( $ filePath ) || ! is_readable ( $ filePath ) ) { throw new \ RuntimeException ( "$message '{$filePath}' doesn't exist or is not readable." ) ; } if ( ! $ allowEmpty && 0 === filesize ( $ filePath ) ) { throw new \ RuntimeException ( "$message '{$filePath}' is empty." ) ; } return realpath ( $ filePath ) ; }
12612	public function getIP ( ) { $ ip = "UNKNOWN" ; if ( getenv ( "HTTP_CLIENT_IP" ) ) { $ ip = getenv ( "HTTP_CLIENT_IP" ) ; } else if ( getenv ( "HTTP_X_FORWARDED_FOR" ) ) { $ ip = getenv ( "HTTP_X_FORWARDED_FOR" ) ; } else if ( getenv ( "REMOTE_ADDR" ) ) { $ ip = getenv ( "REMOTE_ADDR" ) ; } return $ ip ; }
4432	protected function getRunner ( & $ errors ) { $ output = $ this -> output ; $ runner = function ( $ err ) use ( $ output , & $ errors ) { if ( ! empty ( $ err ) ) { $ output -> writeln ( '<fg=red>FAILED</>' ) ; $ errors = array_merge ( $ errors , $ err ) ; } else { $ output -> writeln ( '<info>OK</info>' ) ; } } ; return $ runner ; }
9214	public function actionCreate ( ) { $ model = new StaticPage ( ) ; $ model -> time = date ( "Y-m-d H:i:s" ) ; $ model -> isdel = 0 ; $ post = Yii :: $ app -> request -> post ( ) ; if ( isset ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { if ( is_array ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { $ post [ 'StaticPage' ] [ 'tags' ] = implode ( "," , $ post [ 'StaticPage' ] [ 'tags' ] ) ; } } if ( $ model -> load ( $ post ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; } }
115	public function execute ( $ command , $ url , $ cwd = null , $ path = null , $ verbose = false ) { $ this -> config -> prohibitUrlByConfig ( $ url , $ this -> io ) ; return $ this -> executeWithAuthRetry ( $ command , $ cwd , $ url , $ path , $ verbose ) ; }
11829	public function getByTag ( $ tag ) { $ taggings = $ this -> getTaggings ( ) ; if ( array_key_exists ( $ tag , $ taggings ) ) { return $ taggings [ $ tag ] ; } return array ( ) ; }
11878	protected static function getDumpContent ( $ var , $ maxSize = null ) { $ dump = '<div class="dump_segment_content_main">' ; $ dump .= '<div class="dump_variable">' ; $ dump .= sprintf ( '<ul>%s</ul>' , static :: dumpElement ( $ var , '' , $ maxSize ) ) ; $ dump .= '</div>' ; $ dump .= '</div>' ; return $ dump ; }
1424	protected function load ( $ record , EncodingParametersInterface $ parameters ) { $ relationshipPaths = $ this -> getRelationshipPaths ( $ parameters -> getIncludePaths ( ) ) ; $ record -> loadMissing ( $ relationshipPaths ) ; }
6995	public static function parseApplePriceMatrix ( $ dom , $ currency , $ directory = null ) { if ( is_string ( $ dom ) ) { if ( file_exists ( $ dom ) && is_file ( $ dom ) ) { $ file = $ dom ; $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTMLFile ( $ file ) ; unset ( $ file ) ; } else { $ content = $ dom ; $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTML ( $ content ) ; unset ( $ content ) ; } } if ( ! $ dom instanceof \ DOMDocument ) { throw new \ InvalidArgumentException ( sprintf ( 'The first argument must be a DOMDocument instance or path to ApplePriceMatrix file, "%s" given.' , is_object ( $ dom ) ? get_class ( $ dom ) : gettype ( $ dom ) ) ) ; } $ currency = strtoupper ( $ currency ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ tierPrimary = static :: parseApplePriceMatrixTier ( $ xpath , 1 , $ currency ) ; $ tierAlternative = static :: parseApplePriceMatrixTier ( $ xpath , 2 , $ currency ) ; $ prices = $ tierPrimary + $ tierAlternative ; ksort ( $ prices ) ; if ( $ directory ) { if ( ! is_writable ( $ directory ) ) { throw new \ RuntimeException ( sprintf ( 'Could not write prices map to directory "%s". Directory is not writable.' , $ directory ) ) ; } $ file = $ directory . '/' . $ currency . '.php' ; file_put_contents ( $ file , '<?php return ' . var_export ( $ prices , 1 ) . ';' ) ; } return $ prices ; }
3634	public function events ( Request $ request ) : array { $ em = \ bean ( 'eventManager' ) ; if ( $ event = \ trim ( $ request -> query ( 'name' ) ) ) { if ( ! $ queue = $ em -> getListenerQueue ( $ event ) ) { return [ 'msg' => 'event name is invalid: ' . $ event ] ; } $ classes = [ ] ; foreach ( $ queue -> getIterator ( ) as $ listener ) { $ classes [ ] = \ get_class ( $ listener ) ; } return $ classes ; } return $ em -> getListenedEvents ( ) ; }
9594	public function makeSessionHandler ( ) { $ handler = $ this -> dic -> resolve ( 'Autarky\Http\SessionHandlerFactory' ) -> makeHandler ( $ this -> config -> get ( 'session.handler' ) ) ; if ( $ this -> config -> get ( 'session.write_check' ) === true ) { $ handler = new WriteCheckSessionHandler ( $ handler ) ; } return $ handler ; }
3165	public function switchClientStoreId ( RunnerServiceContext $ context , $ receivedStoreId ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ sessionId = $ session -> getSessionId ( ) ; $ stateService = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) ; $ lastStoreId = $ stateService -> getStoreId ( $ sessionId ) ; if ( $ lastStoreId == false || $ lastStoreId != $ receivedStoreId ) { $ stateService -> setStoreId ( $ sessionId , $ receivedStoreId ) ; } return $ lastStoreId ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'switchClientStoreId' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
9057	public function addPrimaryKey ( string $ name ) : Column { $ column = $ this -> addColumn ( $ name ) ; $ this -> setPrimaryKey ( $ name ) ; return $ column ; }
8513	public function listInboundShipments ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipments' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1752	public static function isInstalledLanguage ( $ strLanguage ) { if ( ! isset ( static :: $ arrLanguages [ $ strLanguage ] ) ) { $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( is_dir ( $ rootDir . '/vendor/contao/core-bundle/src/Resources/contao/languages/' . $ strLanguage ) ) { static :: $ arrLanguages [ $ strLanguage ] = true ; } elseif ( is_dir ( static :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) . '/contao/languages/' . $ strLanguage ) ) { static :: $ arrLanguages [ $ strLanguage ] = true ; } else { $ files = static :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'languages' ) -> depth ( 0 ) -> directories ( ) -> name ( $ strLanguage ) ; static :: $ arrLanguages [ $ strLanguage ] = \ count ( $ files ) > 0 ; } } return static :: $ arrLanguages [ $ strLanguage ] ; }
10602	public function addQuery ( $ name , $ value ) { $ part = $ name . '=' . $ value ; $ this -> _urlParts [ 'query' ] .= empty ( $ this -> _urlParts [ 'query' ] ) ? $ part : '&' . $ part ; return $ this ; }
3083	public function getAssessmentItemRefByIdentifier ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , $ identifier ) { $ compilationDataService = $ this -> getServiceLocator ( ) -> get ( CompilationDataService :: SERVICE_ID ) ; $ filename = "adaptive-assessment-item-ref-${identifier}" ; return $ compilationDataService -> readPhpCompilationData ( $ privateCompilationDirectory , "${filename}.php" , "${filename}" ) ; }
12651	private function writeTextsToFile ( $ language ) { $ textInfo = array ( ) ; $ outdateInfo = array ( ) ; foreach ( $ this -> contents [ $ language ] as $ id => $ info ) { $ textInfo [ $ id ] = $ info [ 'content' ] ; $ outdateInfo [ $ id ] = $ info [ 'outdated' ] ; } if ( $ language === $ this -> baseLang ) { $ content = array ( 'root' => $ textInfo ) + array_fill_keys ( $ this -> extraLangs , true ) ; } else { $ content = $ textInfo ; } $ encodeFlags = JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES ; $ content = "'use strict';\n/*global define*/\ndefine(" . json_encode ( $ content , $ encodeFlags ) . ");\n" ; $ fs = $ this -> env -> getFileSystem ( ) ; $ fs -> putFile ( $ this -> getFileName ( $ language ) , $ content ) ; $ fs -> putFile ( $ this -> getOutdateInfoFileName ( $ language ) , json_encode ( $ outdateInfo , $ encodeFlags ) ) ; }
1916	public function generateQuestion ( ) { return sprintf ( '<span id="captcha_text_%s" class="captcha_text%s">%s</span>' , $ this -> strId , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , $ this -> getQuestion ( ) ) ; }
11544	public function confirmPasswordReset ( $ token ) { $ user = $ this -> getMapper ( ) -> findOneBy ( [ 'registrationToken' => $ token ] ) ; if ( ! $ user instanceof UserInterface ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setRegistrationToken ( $ this -> getRegistrationToken ( ) ) ; $ user -> setEmailConfirmed ( true ) ; $ password = $ this -> getPasswordGenerator ( ) -> generate ( ) ; $ passwordService = $ this -> getMapper ( ) -> getPasswordService ( ) ; $ user -> setPassword ( $ passwordService -> create ( $ password ) ) ; $ viewModel = new ViewModel ( compact ( 'user' , 'password' ) ) ; $ viewModel -> setTemplate ( 'mail-message/user-change-password-success' ) ; $ mailService = $ this -> getMailService ( ) ; $ message = $ mailService -> getMessage ( ) ; $ message -> setTo ( $ user -> getEmail ( ) , $ user -> getDisplayName ( ) ) ; $ subject = 'Your password has been changed!' ; if ( $ this -> getTranslator ( ) && $ this -> isTranslatorEnabled ( ) ) { $ subject = $ this -> getTranslator ( ) -> translate ( $ subject , $ this -> getTranslatorTextDomain ( ) ) ; } $ message -> setSubject ( $ subject ) ; $ mailService -> setBody ( $ viewModel ) -> sendMessage ( ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
9534	private function parseQuote ( & $ argv , $ argument , $ quoteType ) { if ( substr ( $ argument , strlen ( $ argument ) - 1 , 1 ) !== $ quoteType ) { $ this -> argv [ ] = substr ( $ argument , 1 ) ; while ( ( $ argument_part = array_shift ( $ argv ) ) != null && substr ( $ argument_part , strlen ( $ argument_part ) - 1 , 1 ) !== $ quoteType ) { $ this -> argv [ count ( $ this -> argv ) - 1 ] .= ' ' . $ argument_part ; } $ this -> argv [ count ( $ this -> argv ) - 1 ] .= ' ' . substr ( $ argument_part , 0 , strlen ( $ argument_part ) - 1 ) ; } else { $ this -> argv [ ] = substr ( substr ( $ argument , 1 ) , 0 , strlen ( $ argument ) - 2 ) ; } }
2855	public function getDatabaseUpdatesWithHandle ( $ handle , $ storeId , $ area ) { $ databaseHandles = array ( ) ; $ designPackage = Mage :: getModel ( 'core/design_package' ) ; $ designPackage -> setStore ( $ storeId ) ; $ designPackage -> setArea ( $ area ) ; $ layoutResourceModel = Mage :: getResourceModel ( 'core/layout' ) ; $ bind = array ( 'store_id' => $ storeId , 'area' => $ area , 'package' => $ designPackage -> getPackageName ( ) , 'theme' => $ designPackage -> getTheme ( 'layout' ) , 'layout_update_handle' => $ handle ) ; $ readAdapter = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_read' ) ; $ select = $ readAdapter -> select ( ) -> from ( array ( 'layout_update' => $ layoutResourceModel -> getMainTable ( ) ) , array ( 'layout_update_id' , 'xml' ) ) -> join ( array ( 'link' => $ layoutResourceModel -> getTable ( 'core/layout_link' ) ) , 'link.layout_update_id=layout_update.layout_update_id' , '' ) -> where ( 'link.store_id IN (0, :store_id)' ) -> where ( 'link.area = :area' ) -> where ( 'link.package = :package' ) -> where ( 'link.theme = :theme' ) -> where ( 'layout_update.handle = :layout_update_handle' ) -> order ( 'layout_update.sort_order ' . Varien_Db_Select :: SQL_ASC ) ; $ result = $ readAdapter -> fetchAssoc ( $ select , $ bind ) ; if ( count ( $ result ) ) { foreach ( $ result as $ dbLayoutUpdate ) { $ databaseHandles [ $ dbLayoutUpdate [ 'layout_update_id' ] ] = $ dbLayoutUpdate [ 'xml' ] ; } } return $ databaseHandles ; }
3861	public function prepare ( ) { if ( $ this -> objItems ) { return $ this ; } if ( ! $ this -> objFilter ) { $ this -> objFilter = $ this -> objMetaModel -> getEmptyFilter ( ) ; } if ( $ this -> objFilterSettings ) { $ this -> objFilterSettings -> addRules ( $ this -> objFilter , $ this -> arrParam ) ; } $ this -> modifyFilter ( ) ; $ intTotal = $ this -> objMetaModel -> getCount ( $ this -> objFilter ) ; $ calculator = $ this -> paginationLimitCalculator ; $ calculator -> setTotalAmount ( $ intTotal ) ; $ curPage = ( int ) \ Input :: get ( 'page' ) ; if ( $ curPage > 1 ) { $ calculator -> setCurrentPage ( $ curPage ) ; } $ this -> objTemplate -> total = $ intTotal ; $ this -> objItems = $ this -> objMetaModel -> findByFilter ( $ this -> objFilter , $ this -> strSortBy , $ calculator -> getCalculatedOffset ( ) , $ calculator -> getCalculatedLimit ( ) , $ this -> strSortDirection , $ this -> getAttributeNames ( ) ) ; return $ this ; }
5646	public function createInvoker ( $ invoker ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ invoker = $ this -> reporters [ $ i ] -> createInvoker ( $ invoker ) ; } return $ invoker ; }
8906	public function count_by ( ) { $ where = func_get_args ( ) ; $ this -> _set_where ( $ where ) ; $ this -> apply_soft_delete_filter ( ) ; return $ this -> _database -> count_all_results ( $ this -> _table ) ; }
8866	private function runTask ( TaskInterface $ task , PayloadInterface $ payload ) { $ this -> logTask ( $ task , LogLevel :: INFO , 'Starting execution.' ) ; try { if ( ! $ task -> unless ( ) ) { $ this -> dispatch ( 'runner.task.unless' , $ task , $ payload ) ; $ this -> logTask ( $ task , LogLevel :: INFO , 'Skipping because unless() returned boolean false.' ) ; return ; } $ this -> dispatch ( 'runner.task.start' , $ task , $ payload ) ; $ task -> setUp ( ) ; $ exitCode = ( int ) $ task -> run ( $ payload ) ? : 0 ; $ task -> tearDown ( ) ; if ( $ task -> isFailOnError ( ) && $ exitCode !== 0 ) { throw new FailException ( sprintf ( 'Task: %s failed with exit code %s' , get_class ( $ task ) , $ exitCode ) ) ; } $ message = sprintf ( 'Task exited with status code %s' , $ exitCode ) ; if ( $ exitCode === 0 ) { $ this -> logTask ( $ task , LogLevel :: INFO , $ message ) ; } else { $ this -> logTask ( $ task , LogLevel :: WARNING , $ message ) ; } $ this -> dispatch ( 'runner.task.success' , $ task , $ payload , $ exitCode ) ; $ task -> markAsSuccessfullyExecuted ( ) ; } catch ( SkipException $ e ) { $ this -> logTask ( $ task , LogLevel :: INFO , 'Skipping.' ) ; $ this -> dispatch ( 'runner.task.skip' , $ task , $ payload ) ; } catch ( RetryException $ e ) { $ this -> logTask ( $ task , LogLevel :: NOTICE , 'Retry thrown. Starting again.' ) ; $ this -> dispatch ( 'runner.task.retry' , $ task , $ payload ) ; if ( ! $ task -> getMaxRetries ( ) ) { throw new LogicException ( 'A retry exception was thrown, but no retries instance was set.' ) ; } $ task -> getMaxRetries ( ) -> increase ( ) ; $ this -> runTask ( $ task , $ payload ) ; return ; } catch ( FailException $ e ) { $ this -> logTask ( $ task , LogLevel :: WARNING , sprintf ( 'Failure thrown. Given message: %s' , $ e -> getMessage ( ) ) ) ; $ exitCode = $ e -> getCode ( ) ; if ( is_int ( $ exitCode ) ) { $ this -> dispatch ( 'runner.task.failure' , $ task , $ payload , $ exitCode ) ; } else { $ this -> dispatch ( 'runner.task.failure' , $ task , $ payload ) ; } throw $ e ; } $ this -> logTask ( $ task , LogLevel :: INFO , 'Execution successful.' ) ; }
9984	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> name ) ) $ this -> name = $ xmlElement -> name ; if ( isset ( $ xmlElement -> entries ) ) { $ this -> entries = array ( ) ; foreach ( $ xmlElement -> entries -> children ( ) as $ entry ) { $ this -> entries [ ] = $ entry ; } } }
3351	private function __setRequestType ( $ ch , $ type = 'GET' ) { $ this -> current_method = strtoupper ( $ type ) ; switch ( $ type ) { case 'GET' : break ; case 'POST' : curl_setopt ( $ ch , CURLOPT_POST , true ) ; break ; case 'PUT' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'PUT' ) ; break ; case 'DELETE' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'DELETE' ) ; break ; case 'HEAD' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'HEAD' ) ; curl_setopt ( $ ch , CURLOPT_NOBODY , true ) ; break ; case 'OPTIONS' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'OPTIONS' ) ; break ; default : throw new \ Exception ( 'No request type is provided for request. Use post, put, delete, get or appropriate constants.' ) ; } }
11559	public function SetWeekWords ( $ weekWords , $ lang = '' ) { if ( ! $ lang ) $ lang = $ this -> lang ; if ( is_array ( $ weekWords ) ) { $ this -> weekWords [ $ lang ] = $ weekWords ; } else { $ this -> weekWords [ $ lang ] = explode ( ',' , ( string ) $ weekWords ) ; } return $ this ; }
7311	public static function solsticeWinter ( $ year ) { $ jd = static :: solsticeDecember ( ( int ) $ year , false ) ; return AstroDate :: jd ( $ jd , TimeScale :: TT ( ) ) ; }
9817	public function setView ( $ pValue ) { if ( $ pValue === null ) { $ pValue = self :: SHEETVIEW_NORMAL ; } if ( in_array ( $ pValue , self :: $ sheetViewTypes ) ) { $ this -> sheetviewType = $ pValue ; } else { throw new PhpSpreadsheetException ( 'Invalid sheetview layout type.' ) ; } return $ this ; }
249	public function regenerateID ( $ deleteOldSession = false ) { if ( $ this -> getIsActive ( ) ) { if ( YII_DEBUG && ! headers_sent ( ) ) { session_regenerate_id ( $ deleteOldSession ) ; } else { @ session_regenerate_id ( $ deleteOldSession ) ; } } }
10458	public function validate ( string $ answer ) : string { if ( trim ( ( string ) $ answer ) === '' ) { throw new \ RuntimeException ( sprintf ( '%s Given value: "%s"' , $ this -> getErrorMessage ( ) , $ answer ) ) ; } return $ answer ; }
8384	public function select ( $ select ) { if ( is_array ( $ select ) === true ) { $ this -> select = '' ; foreach ( $ select as $ key => $ elem ) { $ this -> select .= $ elem ; if ( is_numeric ( $ key ) === false ) { $ this -> select .= ' AS ' . $ key ; } $ this -> select .= ', ' ; } $ this -> select = substr ( $ this -> select , 0 , - 2 ) ; } elseif ( ! is_string ( $ select ) ) { throw new InvalidArgumentException ( sprintf ( 'Argument 1 passed to %s must be an array or string!' , __METHOD__ ) ) ; } else { $ this -> select = $ select ; } return $ this ; }
5112	protected function setPart ( $ part , $ sql , $ bind = false ) { $ this -> parts [ $ part ] = $ sql ; if ( is_array ( $ bind ) ) $ this -> bind [ $ part ] = $ bind ; else if ( $ bind === false ) $ this -> bind [ $ part ] = false ; else $ this -> bind [ $ part ] = [ $ bind ] ; return $ this ; }
9146	public function get ( $ key ) { if ( ! isset ( $ this -> sessionContainer [ $ key ] ) ) { return null ; } return $ this -> sessionContainer [ $ key ] ; }
7359	public static function getDefaultPriceMapLoader ( ) { if ( null === self :: $ defaultPriceMapLoader ) { $ currencyDir = realpath ( __DIR__ . '/../../../data/prices' ) ; self :: $ defaultPriceMapLoader = new PhpFileLoader ( array ( $ currencyDir ) ) ; } return self :: $ defaultPriceMapLoader ; }
6925	private function getFindOneByCountryAndMethodAndWeightQuery ( ) { if ( null === $ this -> findOneByCountryAndMethodAndWeightQuery ) { $ qb = $ this -> getCollectionQueryBuilder ( 'o' ) ; $ qb -> join ( 'o.zone' , 'z' ) -> join ( 'o.method' , 'm' ) -> andWhere ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'z.countries' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'o.weight' , ':weight' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.method' , ':method' ) ) -> addOrderBy ( 'o.weight' , 'ASC' ) -> setMaxResults ( 1 ) ; $ this -> findOneByCountryAndMethodAndWeightQuery = $ qb -> getQuery ( ) ; } return $ this -> findOneByCountryAndMethodAndWeightQuery ; }
381	public function createServerInformationLink ( ) { $ serverUrls = [ 'http://httpd.apache.org/' => [ 'apache' ] , 'http://nginx.org/' => [ 'nginx' ] , 'http://lighttpd.net/' => [ 'lighttpd' ] , 'http://gwan.com/' => [ 'g-wan' , 'gwan' ] , 'http://iis.net/' => [ 'iis' , 'services' ] , 'https://secure.php.net/manual/en/features.commandline.webserver.php' => [ 'development' ] , ] ; if ( isset ( $ _SERVER [ 'SERVER_SOFTWARE' ] ) ) { foreach ( $ serverUrls as $ url => $ keywords ) { foreach ( $ keywords as $ keyword ) { if ( stripos ( $ _SERVER [ 'SERVER_SOFTWARE' ] , $ keyword ) !== false ) { return '<a href="' . $ url . '" target="_blank">' . $ this -> htmlEncode ( $ _SERVER [ 'SERVER_SOFTWARE' ] ) . '</a>' ; } } } } return '' ; }
2443	public static function encrypt ( $ varValue , $ strKey = null ) { if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: encrypt ( $ v ) ; } return $ varValue ; } elseif ( $ varValue == '' ) { return '' ; } if ( static :: $ resTd === null ) { static :: initialize ( ) ; } if ( ! $ strKey ) { $ strKey = System :: getContainer ( ) -> getParameter ( 'contao.encryption_key' ) ; } $ iv = mcrypt_create_iv ( mcrypt_enc_get_iv_size ( static :: $ resTd ) ) ; mcrypt_generic_init ( static :: $ resTd , md5 ( $ strKey ) , $ iv ) ; $ strEncrypted = mcrypt_generic ( static :: $ resTd , $ varValue ) ; $ strEncrypted = base64_encode ( $ iv . $ strEncrypted ) ; mcrypt_generic_deinit ( static :: $ resTd ) ; return $ strEncrypted ; }
9814	public function addEntriesToBlacklist ( $ id , $ entries , $ importName = null ) { if ( $ importName == null ) { $ importName = "phpclient_import_" . uniqid ( ) ; } $ action = new AddEntriesAction ( ) ; $ action -> importName = $ importName ; $ action -> entries = $ entries ; return $ this -> post ( "blacklists/" . $ id . "/actions" , $ action -> toXMLString ( ) ) ; }
3263	public static function format ( $ value ) { return preg_replace ( [ '/:symbol/' , '/:price/' , '/:currency/' ] , [ Config :: get ( 'shop.currency_symbol' ) , $ value , Config :: get ( 'shop.currency' ) ] , Config :: get ( 'shop.display_price_format' ) ) ; }
9843	public function createSignedJsonRequest ( string $ method , string $ uri , array $ arrayToJsonify , SigningSecretKey $ key , array $ headers = [ ] ) : RequestInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSignedRequest ( $ method , $ uri , $ body , $ key , $ headers ) ; }
2092	protected function initializeSession ( $ formId ) { if ( Input :: post ( 'FORM_SUBMIT' ) != $ formId ) { return ; } $ arrMessageBox = array ( 'TL_ERROR' , 'TL_CONFIRM' , 'TL_INFO' ) ; $ _SESSION [ 'FORM_DATA' ] = \ is_array ( $ _SESSION [ 'FORM_DATA' ] ) ? $ _SESSION [ 'FORM_DATA' ] : array ( ) ; foreach ( $ arrMessageBox as $ tl ) { if ( \ is_array ( $ _SESSION [ $ formId ] [ $ tl ] ) ) { $ _SESSION [ $ formId ] [ $ tl ] = array_unique ( $ _SESSION [ $ formId ] [ $ tl ] ) ; foreach ( $ _SESSION [ $ formId ] [ $ tl ] as $ message ) { $ objTemplate = new FrontendTemplate ( 'form_message' ) ; $ objTemplate -> message = $ message ; $ objTemplate -> class = strtolower ( $ tl ) ; $ this -> Template -> fields .= $ objTemplate -> parse ( ) . "\n" ; } $ _SESSION [ $ formId ] [ $ tl ] = array ( ) ; } } }
11117	protected function rollbackMigrations ( array $ migrations ) : void { $ this -> notify -> note ( '' ) ; foreach ( $ this -> getMigrationFiles ( M :: TYPE_DOWN ) as $ file ) { if ( in_array ( $ name = $ this -> getMigrationName ( $ file ) , $ migrations , true ) ) { $ this -> runDown ( $ file ) ; continue ; } $ this -> notify -> note ( "<fg=red>Migrate not found (in database table):</> {$name}" ) ; } }
10490	public function neg ( ) { if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value * - 1 ) ; }
371	public function isColorEnabled ( $ stream = \ STDOUT ) { return $ this -> color === null ? Console :: streamSupportsAnsiColors ( $ stream ) : $ this -> color ; }
9353	public function inverse ( ) { $ det = $ this -> det ( ) ; if ( $ det == 0 ) { throw new \ RuntimeException ( 'Cannot get inverse matrix: determinant is nul!' ) ; } return $ this -> adjugate ( ) -> multiply ( 1 / $ det ) ; }
12242	public function asPrettyXML ( $ filepath = null ) { $ xml = dom_import_simplexml ( new SimpleXMLElement ( $ this -> asXML ( ) ) ) ; $ xsl = new DOMDocument ; $ xsl -> loadXML ( '<?xml version="1.0" encoding="utf-8"?><xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="xml" indent="yes" /> <xsl:template match="text()"> <!-- remove everything that contains only whitespace, with at least one LF ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; $ result = trim ( $ xslt -> transformToXML ( $ xml ) ) ; if ( isset ( $ filepath ) ) { return ( bool ) file_put_contents ( $ filepath , $ result ) ; } return $ result ; }
7966	public function getProperties ( $ billingAccount ) { if ( ! $ billingAccount ) throw new BadMethodCallException ( 'Parameter $billingAccount is missing.' ) ; try { $ r = $ this -> get ( 'telephony/' . $ billingAccount ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new TelephonyException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
12181	public function getPrimaryObject ( $ primaryObject , $ relatedObject , $ role ) { if ( ! $ this -> handlePrimary ) { return false ; } if ( $ role === 'child' ) { $ primaryField = 'primary_child' ; if ( ! $ relatedObject -> objectType -> getPrimaryAsChild ( $ this -> parent ) ) { return false ; } $ primaryParent = $ primaryObject ; } else { $ primaryField = 'primary_parent' ; if ( ! $ relatedObject -> objectType -> getPrimaryAsParent ( $ this -> child ) ) { return false ; } $ primaryParent = $ relatedObject ; } $ key = json_encode ( [ __FUNCTION__ , $ this -> systemId , $ primaryObject -> primaryKey ] ) ; if ( ! isset ( self :: $ _cache [ $ key ] ) ) { self :: $ _cache [ $ key ] = null ; $ relationClass = Yii :: $ app -> classes [ 'Relation' ] ; $ childClass = $ this -> child -> primaryModel ; $ relation = $ relationClass :: find ( ) ; $ alias = $ relationClass :: tableName ( ) ; $ relation -> andWhere ( [ '`' . $ alias . '`.`parent_object_id`' => $ primaryParent -> primaryKey , '`' . $ alias . '`.`' . $ primaryField . '`' => 1 ] ) ; $ relation -> andWhere ( [ 'or' , '`' . $ alias . '`.`child_object_id` LIKE :prefix' ] ) ; $ relation -> params [ ':prefix' ] = $ childClass :: modelPrefix ( ) . '-%' ; $ primaryObject -> addActiveConditions ( $ relation , $ alias ) ; $ relation = $ relation -> one ( ) ; if ( ! empty ( $ relation ) ) { self :: $ _cache [ $ key ] = $ relation ; } } return self :: $ _cache [ $ key ] ; }
3543	public function actionCreateExampleRole ( ) { $ auth = Yii :: $ app -> authManager ; $ displayDetailedAbout = $ auth -> createPermission ( 'permissionDisplayDetailedAbout' ) ; $ displayDetailedAbout -> description = 'Permission to display detailed about informations' ; $ auth -> add ( $ displayDetailedAbout ) ; $ useContactPage = $ auth -> createPermission ( 'permissionToUseContanctPage' ) ; $ useContactPage -> description = 'Permission to use the contanct page' ; $ auth -> add ( $ useContactPage ) ; $ yii2ExampleGroup = $ auth -> createRole ( 'yii2_example_group' ) ; $ auth -> add ( $ yii2ExampleGroup ) ; $ auth -> addChild ( $ yii2ExampleGroup , $ displayDetailedAbout ) ; $ auth -> addChild ( $ yii2ExampleGroup , $ useContactPage ) ; $ useHomePage = $ auth -> createPermission ( 'permissionToSeeHome' ) ; $ useHomePage -> description = 'Permission to use the home page' ; $ auth -> add ( $ useHomePage ) ; $ yii2HomeGroup = $ auth -> createRole ( 'yii2_see_home_group' ) ; $ auth -> add ( $ yii2HomeGroup ) ; $ auth -> addChild ( $ yii2HomeGroup , $ useHomePage ) ; echo "\n\n!!!! TODO !!!!\nTow roles with the name yii2_example_group and yii2_see_home_group were created in yii2.\nPlease create the groups with the same name in Active Directory.\nAssign the user you are using for the login to this groups in Active Directory.\n" ; }
9818	private function polynomialRegression ( $ order , $ yValues , $ xValues ) { $ x_sum = array_sum ( $ xValues ) ; $ y_sum = array_sum ( $ yValues ) ; $ xx_sum = $ xy_sum = 0 ; for ( $ i = 0 ; $ i < $ this -> valueCount ; ++ $ i ) { $ xy_sum += $ xValues [ $ i ] * $ yValues [ $ i ] ; $ xx_sum += $ xValues [ $ i ] * $ xValues [ $ i ] ; $ yy_sum += $ yValues [ $ i ] * $ yValues [ $ i ] ; } for ( $ i = 0 ; $ i < $ this -> valueCount ; ++ $ i ) { for ( $ j = 0 ; $ j <= $ order ; ++ $ j ) { $ A [ $ i ] [ $ j ] = pow ( $ xValues [ $ i ] , $ j ) ; } } for ( $ i = 0 ; $ i < $ this -> valueCount ; ++ $ i ) { $ B [ $ i ] = [ $ yValues [ $ i ] ] ; } $ matrixA = new Matrix ( $ A ) ; $ matrixB = new Matrix ( $ B ) ; $ C = $ matrixA -> solve ( $ matrixB ) ; $ coefficients = [ ] ; for ( $ i = 0 ; $ i < $ C -> getRowDimension ( ) ; ++ $ i ) { $ r = $ C -> get ( $ i , 0 ) ; if ( abs ( $ r ) <= pow ( 10 , - 9 ) ) { $ r = 0 ; } $ coefficients [ ] = $ r ; } $ this -> intersect = array_shift ( $ coefficients ) ; $ this -> slope = $ coefficients ; $ this -> calculateGoodnessOfFit ( $ x_sum , $ y_sum , $ xx_sum , $ yy_sum , $ xy_sum ) ; foreach ( $ this -> xValues as $ xKey => $ xValue ) { $ this -> yBestFitValues [ $ xKey ] = $ this -> getValueOfYForX ( $ xValue ) ; } }
2609	public function getNextVersion ( array $ versions ) { if ( isset ( end ( $ versions ) -> number ) ) { return ( int ) end ( $ versions ) -> number + 1 ; } throw new LocalizedException ( __ ( 'Error fetching next version.' ) ) ; }
108	private function addExtension ( $ name , $ prettyVersion ) { $ extraDescription = null ; try { $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } catch ( \ UnexpectedValueException $ e ) { $ extraDescription = ' (actual version: ' . $ prettyVersion . ')' ; if ( preg_match ( '{^(\d+\.\d+\.\d+(?:\.\d+)?)}' , $ prettyVersion , $ match ) ) { $ prettyVersion = $ match [ 1 ] ; } else { $ prettyVersion = '0' ; } $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } $ packageName = $ this -> buildPackageName ( $ name ) ; $ ext = new CompletePackage ( $ packageName , $ version , $ prettyVersion ) ; $ ext -> setDescription ( 'The ' . $ name . ' PHP extension' . $ extraDescription ) ; $ this -> addPackage ( $ ext ) ; }
12835	private function generateFactoryCreatorMethod ( FactoredService $ service ) : string { $ factoryMethod = $ service -> getFactoryMethod ( ) ; $ taggedAs = implode ( ', ' , $ service -> getTags ( ) ) ; $ classNormalized = $ this -> normalizeFqcn ( $ service -> getClass ( ) ) ; $ optional = $ service -> getFactoryMethod ( ) -> isOptional ( ) ? '?' : '' ; if ( $ service -> isSingleton ( ) ) { return <<<PHP /** * Get the factored service "{$service->getId()}" (Singleton) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : {$optional}{$classNormalized} { if (isset(\$this->singletons['{$service->getId()}'])) { return \$this->singletons['{$service->getId()}']; } /** @noinspection OneTimeUseVariablesInspection */ \$service = \$this->singletons['{$service->getId()}'] = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; } return <<<PHP /** * Get a fresh instance of service "{$service->getId()}" (Prototype) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : $classNormalized { \$this->prototypes['{$service->getId()}'] = (\$this->prototypes['{$service->getId()}'] ?? 0) + 1; /** @noinspection OneTimeUseVariablesInspection */ \$service = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; }
11025	public function __isset ( $ name ) : bool { if ( strrpos ( $ name , 'facet_' , - strlen ( $ name ) ) !== false ) { return true ; } return false ; }
4483	public function requeue ( string $ queue ) : void { if ( $ this -> client -> call ( 'recur.update' , $ this -> jid , 'queue' , $ queue ) ) { $ this -> setQueue ( $ queue ) ; } }
9165	public function fields ( $ entity = array ( ) , $ action = 'all' , array $ params = array ( ) ) { $ fieldCollection = array ( ) ; $ entity = $ this -> entityFactory -> build ( $ entity ) ; if ( $ entity instanceof \ ElggEntity ) { $ params [ 'entity' ] = $ entity ; $ fields = ( array ) elgg_trigger_plugin_hook ( 'prototype' , $ action , $ params , array ( ) ) ; $ attribute_names = $ this -> entityFactory -> getAttributeNames ( $ entity ) ; if ( ! $ entity -> guid ) { $ fields [ 'type' ] = array ( 'type' => 'hidden' ) ; $ fields [ 'subtype' ] = array ( 'type' => 'hidden' ) ; $ fields [ 'owner_guid' ] = array ( 'type' => 'hidden' ) ; $ fields [ 'container_guid' ] = array ( 'type' => 'hidden' ) ; } else { $ fields [ 'guid' ] = array ( 'type' => 'hidden' ) ; } foreach ( $ fields as $ shortname => $ field ) { $ field [ 'entity_type' ] = $ entity -> getType ( ) ; $ field [ 'entity_subtype' ] = $ entity -> getSubtype ( ) ; if ( empty ( $ field [ 'shortname' ] ) ) { $ field [ 'shortname' ] = $ shortname ; } if ( in_array ( $ shortname , $ attribute_names ) ) { $ field [ 'data_type' ] = 'attribute' ; $ field [ 'class_name' ] = Elements \ AttributeField :: CLASSNAME ; } $ fieldObj = $ this -> fieldFactory -> build ( $ field ) ; if ( $ fieldObj instanceof Elements \ Field ) { $ fieldCollection [ ] = $ fieldObj ; } } } return new Elements \ FieldCollection ( $ fieldCollection ) ; }
8597	public function listMarketplaceParticipationsByNextToken ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListMarketplaceParticipationsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
545	protected function rotateFiles ( ) { $ file = $ this -> logFile ; for ( $ i = $ this -> maxLogFiles ; $ i >= 0 ; -- $ i ) { $ rotateFile = $ file . ( $ i === 0 ? '' : '.' . $ i ) ; if ( is_file ( $ rotateFile ) ) { if ( $ i === $ this -> maxLogFiles ) { @ unlink ( $ rotateFile ) ; continue ; } $ newFile = $ this -> logFile . '.' . ( $ i + 1 ) ; $ this -> rotateByCopy ? $ this -> rotateByCopy ( $ rotateFile , $ newFile ) : $ this -> rotateByRename ( $ rotateFile , $ newFile ) ; if ( $ i === 0 ) { $ this -> clearLogFile ( $ rotateFile ) ; } } } }
8951	public function getCapabilities ( ) { $ base = 'capabilities' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'GET' , array ( ) ) ; return simplexml_load_string ( $ response -> body ) ; }
4000	protected function loadMetaModel ( $ nameOrId ) { if ( is_numeric ( $ nameOrId ) ) { $ tableName = $ this -> getServiceContainer ( ) -> getFactory ( ) -> translateIdToMetaModelName ( $ nameOrId ) ; } elseif ( is_string ( $ nameOrId ) ) { $ tableName = $ nameOrId ; } if ( isset ( $ tableName ) ) { return $ this -> getServiceContainer ( ) -> getFactory ( ) -> getMetaModel ( $ tableName ) ; } return null ; }
6207	public function set ( $ key , $ value ) { if ( $ this -> exists ( $ key ) ) { $ this -> dataStore [ $ key ] = $ value ; } }
283	private function findFixtures ( array $ fixtures = [ ] ) { $ fixturesPath = $ this -> getFixturePath ( ) ; $ filesToSearch = [ '*Fixture.php' ] ; $ findAll = ( $ fixtures === [ ] ) ; if ( ! $ findAll ) { $ filesToSearch = [ ] ; foreach ( $ fixtures as $ fileName ) { $ filesToSearch [ ] = $ fileName . 'Fixture.php' ; } } $ files = FileHelper :: findFiles ( $ fixturesPath , [ 'only' => $ filesToSearch ] ) ; $ foundFixtures = [ ] ; foreach ( $ files as $ fixture ) { $ foundFixtures [ ] = $ this -> getFixtureRelativeName ( $ fixture ) ; } return $ foundFixtures ; }
3317	public function pushValue ( $ value ) { $ value = $ this -> _preprocessValue ( $ value ) ; $ this -> value [ ] = $ value ; $ this -> callTrigger ( ) ; }
7285	protected function initializeInvoiceSubject ( ) { $ this -> invoiceTotal = 0 ; $ this -> creditTotal = 0 ; $ this -> invoiceState = InvoiceStates :: STATE_NEW ; $ this -> invoices = new ArrayCollection ( ) ; }
8944	public function getDetails ( ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/details' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'GET' , $ parameters ) ; return $ response -> body ; }
12559	public function fixFile ( $ file ) { $ contents = preg_split ( "/\\r\\n|\\r|\\n/" , file_get_contents ( $ file ) ) ; $ changed = false ; if ( $ this -> fixFileSlashes ( $ file , $ contents ) ) { $ changed = true ; } if ( $ changed ) { file_put_contents ( $ file , implode ( "\n" , $ contents ) ) ; } return $ changed ; }
2469	public function mapContentBlock ( Content $ content ) { $ contentInfo = $ content -> versionInfo -> contentInfo ; $ locations = $ this -> locationHandler -> loadLocationsByContent ( $ contentInfo -> id ) ; $ blockFields = $ this -> getBlockFields ( $ content ) ; $ contentFields = $ this -> getContentFields ( $ content ) ; $ documents = [ ] ; $ locationFieldsMap = [ ] ; foreach ( $ locations as $ location ) { $ locationFieldsMap [ $ location -> id ] = $ this -> getLocationFields ( $ location ) ; } foreach ( array_keys ( $ content -> versionInfo -> names ) as $ languageCode ) { $ blockTranslationFields = $ this -> getBlockTranslationFields ( $ content , $ languageCode ) ; $ translationLocationDocuments = array ( ) ; foreach ( $ locations as $ location ) { $ translationLocationDocuments [ ] = new Document ( array ( 'id' => $ this -> generateLocationDocumentId ( $ location -> id , $ languageCode ) , 'fields' => array_merge ( $ blockFields , $ locationFieldsMap [ $ location -> id ] , $ blockTranslationFields ) , ) ) ; } $ isMainTranslation = ( $ contentInfo -> mainLanguageCode === $ languageCode ) ; $ alwaysAvailable = ( $ isMainTranslation && $ contentInfo -> alwaysAvailable ) ; $ contentTranslationFields = $ this -> getContentTranslationFields ( $ content , $ languageCode ) ; $ documents [ ] = new Document ( array ( 'id' => $ this -> generateContentDocumentId ( $ contentInfo -> id , $ languageCode ) , 'languageCode' => $ languageCode , 'alwaysAvailable' => $ alwaysAvailable , 'isMainTranslation' => $ isMainTranslation , 'fields' => array_merge ( $ blockFields , $ contentFields , $ blockTranslationFields , $ contentTranslationFields ) , 'documents' => $ translationLocationDocuments , ) ) ; } return $ documents ; }
5188	private function createPage ( string $ title , string $ body , string $ source , int $ order , string $ cover , string $ lead ) : \ One \ Model \ Page { return new Page ( $ title , $ body , $ source , $ order , $ cover , $ lead ) ; }
1282	public function getField ( string $ fieldId , bool $ tryCaseInsensitive = false ) { if ( isset ( $ this -> fields [ $ fieldId ] ) ) { return $ this -> fields [ $ fieldId ] ; } if ( $ tryCaseInsensitive ) { foreach ( $ this -> fields as $ name => $ field ) { if ( \ mb_strtolower ( $ name ) === \ mb_strtolower ( $ fieldId ) ) { return $ field ; } } } return null ; }
5129	private function conv ( $ str ) { if ( $ this -> supportsExtMbstring ) { return mb_convert_encoding ( $ str , 'UTF-8' , 'UTF-16BE' ) ; } return preg_replace_callback ( '/(?:[\xD8-\xDB]...)|(?:..)/s' , function ( $ m ) { if ( isset ( $ m [ 0 ] [ 3 ] ) ) { list ( , $ higher , $ lower ) = unpack ( 'n*' , $ m [ 0 ] ) ; $ code = ( ( $ higher & 0x03FF ) << 10 ) + ( $ lower & 0x03FF ) + 0x10000 ; return pack ( 'c*' , $ code >> 18 | 0xF0 , $ code >> 12 & 0x3F | 0x80 , $ code >> 6 & 0x3F | 0x80 , $ code & 0x3F | 0x80 ) ; } list ( , $ code ) = unpack ( 'n' , $ m [ 0 ] ) ; if ( $ code < 0x80 ) { return chr ( $ code ) ; } elseif ( $ code < 0x0800 ) { return chr ( $ code >> 6 | 0xC0 ) . chr ( $ code & 0x3F | 0x80 ) ; } else { return chr ( $ code >> 12 | 0xE0 ) . chr ( $ code >> 6 & 0x3F | 0x80 ) . chr ( $ code & 0x3F | 0x80 ) ; } return '?' ; } , $ str ) ; }
10857	public function getMarked ( string $ marker ) : array { if ( ! \ is_subclass_of ( $ marker , Marker :: class ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker implementation %s must extend %s' , $ marker , Marker :: class ) ) ; } if ( ! isset ( $ this -> marked [ $ marker ] ) ) { $ this -> cacheMarkers ( $ marker ) ; } return \ array_map ( function ( array $ marked ) { return $ this -> shared [ $ marked [ 0 ] -> typeName ] ?? $ this -> get ( $ marked [ 0 ] -> typeName ) ; } , $ this -> marked [ $ marker ] ) ; }
9664	public static function registerReader ( $ readerType , $ readerClass ) { if ( ! is_a ( $ readerClass , Reader \ IReader :: class , true ) ) { throw new Reader \ Exception ( 'Registered readers must implement ' . Reader \ IReader :: class ) ; } self :: $ readers [ $ readerType ] = $ readerClass ; }
633	public function delete ( $ table , $ condition = '' , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> delete ( $ table , $ condition , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
9540	private function getParameterClosure ( $ parameter ) { $ parameterClosure = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { @ $ parameterClosure = $ this -> parameterCluster -> prefixes [ $ prefix ] [ substr ( $ parameter , strlen ( $ prefix ) , strlen ( $ parameter ) - strlen ( $ prefix ) ) ] ; } } return $ parameterClosure ; }
525	protected function migrateToVersion ( $ version ) { $ originalVersion = $ version ; $ migrations = $ this -> getNewMigrations ( ) ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { $ this -> actionUp ( $ i + 1 ) ; return ExitCode :: OK ; } } $ migrations = array_keys ( $ this -> getMigrationHistory ( null ) ) ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { if ( $ i === 0 ) { $ this -> stdout ( "Already at '$originalVersion'. Nothing needs to be done.\n" , Console :: FG_YELLOW ) ; } else { $ this -> actionDown ( $ i ) ; } return ExitCode :: OK ; } } throw new Exception ( "Unable to find the version '$originalVersion'." ) ; }
11832	public function getCache ( ) { if ( ! $ this -> cache ) { $ services = $ this -> getServices ( ) ; $ cache = $ services -> get ( 'Cache' ) ; $ this -> setCache ( $ cache ) ; } return $ this -> cache ; }
785	protected function generateEtag ( $ seed ) { $ etag = '"' . rtrim ( base64_encode ( sha1 ( $ seed , true ) ) , '=' ) . '"' ; return $ this -> weakEtag ? 'W/' . $ etag : $ etag ; }
11449	public function fill ( array $ attributes ) { if ( $ this -> getFieldManager ( ) ) { $ attributes = $ this -> getFieldManager ( ) -> transformToResource ( $ attributes ) ; } return parent :: fill ( $ attributes ) ; }
6153	public function setPropertyType ( $ propertyType ) { if ( $ propertyType instanceof PropertyType ) { $ this -> propertyType = $ propertyType ; } elseif ( is_array ( $ propertyType ) ) { $ this -> propertyType = new PropertyType ( $ propertyType ) ; } else { $ this -> propertyType = null ; trigger_error ( 'Argument must be an object of class PropertyType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
10037	function createCustomField ( $ name , $ type = 'string' ) { $ queryParameters = array ( 'type' => $ type ) ; $ encodedName = urlencode ( mb_convert_encoding ( $ name , "UTF-8" ) ) ; return $ this -> post ( "contacts/fields/custom/${encodedName}" , "" , $ queryParameters ) ; }
8412	public function isConnected ( ) : bool { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { return isset ( $ this -> servers [ 'all' ] [ 'link' ] ) ; } return isset ( $ this -> servers [ 'read' ] [ 'link' ] ) && isset ( $ this -> servers [ 'write' ] [ 'link' ] ) ; }
12553	public function save ( $ path , $ name = null ) { if ( ! file_exists ( $ path ) ) { mkdir ( $ path , 0777 , true ) ; } $ destinationPath = rtrim ( $ path , '/' ) ; if ( $ name ) { $ destinationPath .= '/' . $ name ; } else { $ destinationPath .= '/' . $ this -> name ; } if ( ! copy ( $ this -> tmpName , $ destinationPath ) ) { $ reason = 'Unknown' ; if ( ! file_exists ( $ path ) ) { $ reason = 'Path "' . $ path . '" not exists.' ; } else if ( ! is_writeable ( $ path ) ) $ reason = 'Path "' . $ path . '" required permission to write.' ; throw new FileFailSavedException ( $ reason ) ; } }
12521	public function renderLabel ( $ customFieldOrClass , $ slug = null , array $ params = array ( ) ) { $ resolvedParams = array_merge ( $ this -> defaultParams , $ params ) ; $ customField = ( $ customFieldOrClass instanceof CustomField ) ? $ customFieldOrClass : $ this -> container -> get ( 'chill.custom_field.provider' ) -> getCustomField ( $ customFieldOrClass , $ slug ) ; return $ this -> container -> get ( 'templating' ) -> render ( $ resolvedParams [ 'label_layout' ] , array ( 'customField' => $ customField ) ) ; }
2705	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: VCL_AUTH_SNIPPET_PATH ) ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> hasSnippet ( $ activeVersion , $ name ) ; if ( $ status == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1643	public function getCenter ( ) : Coordinate { $ centerLat = ( $ this -> getNorth ( ) + $ this -> getSouth ( ) ) / 2 ; return new Coordinate ( $ centerLat , $ this -> getCenterLng ( ) ) ; }
7090	public function removeDefaultHeader ( $ headers = "" ) { foreach ( $ headers as $ header ) foreach ( $ this -> defaultHeaders as $ h => $ v ) if ( $ header === $ h ) unset ( $ this -> defaultHeaders [ $ h ] ) ; return $ this -> defaultHeaders ; }
1126	public function isSelfOrDescendantOf ( $ other ) { return ( $ this -> getLeft ( ) >= $ other -> getLeft ( ) && $ this -> getLeft ( ) < $ other -> getRight ( ) && $ this -> inSameScope ( $ other ) ) ; }
12129	public function failed ( $ fail = true ) { if ( ! func_num_args ( ) ) { return $ this -> _failed ; } $ this -> _failed = $ fail ; return $ this ; }
10656	public function usort ( $ cmp_function ) { $ tmp = $ this -> getArrayCopy ( ) ; $ ret = usort ( $ tmp , $ cmp_function ) ; $ tmp = new self ( $ tmp ) ; $ this -> exchangeArray ( $ tmp -> getArrayCopy ( ) ) ; return $ ret ; }
3248	public function remove ( $ item , $ quantity = 0 ) { $ cartItem = $ this -> getItem ( is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku ) ; if ( ! empty ( $ cartItem ) ) { if ( ! empty ( $ quantity ) ) { $ cartItem -> quantity -= $ quantity ; $ cartItem -> save ( ) ; if ( $ cartItem -> quantity > 0 ) return true ; } $ cartItem -> delete ( ) ; } $ this -> resetCalculations ( ) ; return $ this ; }
1423	protected function with ( $ query , EncodingParametersInterface $ parameters ) { $ query -> with ( $ this -> getRelationshipPaths ( ( array ) $ parameters -> getIncludePaths ( ) ) ) ; }
6435	public function completeLogin ( $ extrainputs = array ( ) ) { if ( ! isset ( $ extrainputs [ 'oauth_token' ] ) || $ extrainputs [ 'oauth_token' ] == '' ) { throw new \ Exception ( 'Xing oauth. Somethign went wrong. No token in the session' ) ; } $ credentials = array ( 'identifier' => $ this -> options [ 'consumer_key' ] , 'secret' => $ this -> options [ 'consumer_secret' ] ) ; $ server = new \ League \ OAuth1 \ Client \ Server \ Xing ( $ credentials ) ; $ this -> access_token = $ server -> getTokenCredentials ( $ this -> temp_credentials , $ extrainputs [ 'oauth_token' ] , $ extrainputs [ 'oauth_verifier' ] ) ; return $ this -> getUserProfile ( ) ; }
1237	private function set ( $ class , $ name , $ value ) { self :: ensurePropertyExists ( $ class , $ name ) ; self :: ensurePropertyType ( $ class , $ name , $ value ) ; $ this -> setValue ( $ class , $ name , $ value ) ; }
12963	public function checkDbExists ( $ name ) { $ data = $ this -> query ( "SELECT COUNT(*) AS total FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '" . $ this -> escape ( $ name ) . "'" , true ) ; if ( isset ( $ data [ '0' ] [ 'total' ] ) && $ data [ '0' ] [ 'total' ] == '1' ) { return true ; } return false ; }
610	public function get ( $ class , $ params = [ ] , $ config = [ ] ) { if ( isset ( $ this -> _singletons [ $ class ] ) ) { return $ this -> _singletons [ $ class ] ; } elseif ( ! isset ( $ this -> _definitions [ $ class ] ) ) { return $ this -> build ( $ class , $ params , $ config ) ; } $ definition = $ this -> _definitions [ $ class ] ; if ( is_callable ( $ definition , true ) ) { $ params = $ this -> resolveDependencies ( $ this -> mergeParams ( $ class , $ params ) ) ; $ object = call_user_func ( $ definition , $ this , $ params , $ config ) ; } elseif ( is_array ( $ definition ) ) { $ concrete = $ definition [ 'class' ] ; unset ( $ definition [ 'class' ] ) ; $ config = array_merge ( $ definition , $ config ) ; $ params = $ this -> mergeParams ( $ class , $ params ) ; if ( $ concrete === $ class ) { $ object = $ this -> build ( $ class , $ params , $ config ) ; } else { $ object = $ this -> get ( $ concrete , $ params , $ config ) ; } } elseif ( is_object ( $ definition ) ) { return $ this -> _singletons [ $ class ] = $ definition ; } else { throw new InvalidConfigException ( 'Unexpected object definition type: ' . gettype ( $ definition ) ) ; } if ( array_key_exists ( $ class , $ this -> _singletons ) ) { $ this -> _singletons [ $ class ] = $ object ; } return $ object ; }
9108	protected function attainThemeName ( ) { $ themeName = $ this -> getResolverObject ( 'resolver_adapter_service' ) -> getName ( ) ; return ( empty ( $ themeName ) && ! ( $ themeName === '0' ) ) ? false : $ themeName ; }
897	private function fixTokensCompare ( Tokens $ tokens , $ startLeft , $ endLeft , $ compareOperatorIndex , $ startRight , $ endRight ) { $ type = $ tokens [ $ compareOperatorIndex ] -> getId ( ) ; $ content = $ tokens [ $ compareOperatorIndex ] -> getContent ( ) ; if ( \ array_key_exists ( $ type , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ type ] ; } elseif ( \ array_key_exists ( $ content , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ content ] ; } $ right = $ this -> fixTokensComparePart ( $ tokens , $ startRight , $ endRight ) ; $ left = $ this -> fixTokensComparePart ( $ tokens , $ startLeft , $ endLeft ) ; for ( $ i = $ startRight ; $ i <= $ endRight ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } for ( $ i = $ startLeft ; $ i <= $ endLeft ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ tokens -> insertAt ( $ startRight , $ left ) ; $ tokens -> insertAt ( $ startLeft , $ right ) ; return $ startLeft ; }
11628	protected function getLockFile ( ) { $ request = $ this -> getRequest ( ) ; $ params = $ request -> getParams ( ) ; $ controller = $ params -> controller ; $ action = $ params -> action ; $ normalizedController = strtolower ( stripslashes ( str_replace ( __NAMESPACE__ , '' , $ controller ) ) ) ; $ fileBaseName = implode ( '_' , array ( basename ( $ request -> getScriptName ( ) ) , $ normalizedController , $ action ) ) ; return $ this -> lockdir . DIRECTORY_SEPARATOR . $ fileBaseName . self :: FILE_SUFFIX ; }
2275	public function getLayoutSections ( ) { $ arrSections = array ( 'header' , 'left' , 'right' , 'main' , 'footer' ) ; $ objLayout = $ this -> Database -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = Contao \ StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ arrSections [ ] = $ v [ 'id' ] ; } } } } return Contao \ Backend :: convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) ; }
3864	private function setTitleAndDescription ( ) { $ page = $ this -> getPage ( ) ; if ( $ page && $ this -> objItems -> getCount ( ) ) { if ( ! empty ( $ this -> strTitleAttribute ) ) { while ( $ this -> objItems -> next ( ) ) { $ objCurrentItem = $ this -> objItems -> current ( ) ; $ arrTitle = $ objCurrentItem -> parseAttribute ( $ this -> strTitleAttribute , 'text' , $ this -> getView ( ) ) ; if ( ! empty ( $ arrTitle [ 'text' ] ) ) { $ page -> pageTitle = strip_tags ( $ arrTitle [ 'text' ] ) ; break ; } } $ this -> objItems -> reset ( ) ; } if ( ! empty ( $ this -> strDescriptionAttribute ) ) { while ( $ this -> objItems -> next ( ) ) { $ objCurrentItem = $ this -> objItems -> current ( ) ; $ arrDescription = $ objCurrentItem -> parseAttribute ( $ this -> strDescriptionAttribute , 'text' , $ this -> getView ( ) ) ; if ( ! empty ( $ arrDescription [ 'text' ] ) ) { $ page -> description = StringUtil :: substr ( $ arrDescription [ 'text' ] , 160 ) ; break ; } } $ this -> objItems -> reset ( ) ; } } }
7578	protected function configureData ( $ data ) { if ( ! empty ( $ this -> _REQUIRED_DATA ) && is_array ( $ data ) ) { $ data = $ this -> configureDefaultData ( $ data ) ; } $ this -> setData ( $ data ) ; }
11126	public function update ( Request $ request ) { foreach ( $ request -> all ( ) as $ key => $ value ) { if ( substr ( $ key , 0 , 8 ) == 'setting_' ) { $ skipSave = false ; $ key = substr ( $ key , 8 ) ; if ( ! $ skipSave ) { $ this -> settingRepository -> save ( $ key , $ value ) ; } } } Flash :: success ( trans ( 'l5starter::messages.update.success' ) ) ; return redirect ( route ( 'admin.settings.index' ) ) ; }
11023	public function run ( string $ task , $ ostr = STDERR ) { $ task = str_replace ( ":" , "\\" , $ task ) ; $ log = Logger :: getLogger ( '' ) ; $ log -> addLogWriter ( new StreamWriter ( STDOUT ) ) ; if ( ! class_exists ( $ task ) ) { fprintf ( $ ostr , "Error: task does not exist: {$task}\n" ) ; return false ; } try { if ( ! is_subclass_of ( $ task , TaskInterface :: class ) ) { fprintf ( $ ostr , "Error: invalid task: {$task}\n" ) ; return false ; } $ taskrunner = new $ task ; $ taskrunner -> execute ( ) ; } catch ( \ Throwable $ e ) { fprintf ( $ ostr , "Error: error while running task: %s\n" , $ task ) ; fprintf ( $ ostr , "Exception: %s\n" , get_class ( $ e ) ) ; fprintf ( $ ostr , "Message: %s\n" , $ e -> getMessage ( ) ) ; if ( method_exists ( $ e , "getLine" ) ) fprintf ( $ ostr , "On: %s (line %d)\n" , $ e -> getFile ( ) , $ e -> getLine ( ) ) ; fprintf ( $ ostr , $ e -> getTraceAsString ( ) . "\n" ) ; return false ; } return true ; }
9514	public function addFacetedQuery ( $ query , $ index , array $ keys ) { $ this -> AddQuery ( $ query , $ index ) ; $ currentOffset = $ this -> _offset ; $ mode = $ this -> _sort ; $ sortby = $ this -> _sortby ; $ limit = $ this -> _limit ; $ this -> _offset = 0 ; $ this -> _sort = 0 ; $ this -> _sortby = '' ; $ this -> SetLimits ( 0 , 999 ) ; foreach ( $ keys as $ key ) { $ this -> setGroupByAttr ( $ key ) ; $ this -> AddQuery ( $ query , $ index ) ; } $ this -> _offset = $ currentOffset ; $ this -> _sort = $ mode ; $ this -> _sortby = $ sortby ; $ this -> SetLimits ( $ currentOffset , $ limit ) ; }
1455	protected function validateHasOne ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasOne ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasOneExpected ( $ key ) ) ; return false ; } $ identifier = $ relationship -> getData ( ) ; if ( ! $ identifier ) { return true ; } if ( ! $ this -> validateIdentifier ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateExists ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateAcceptable ( $ identifier , $ record , $ key , $ resource ) ) { return false ; } return true ; }
9047	public function getType ( $ data_type = 'metadata' , $ type = 'text' ) { if ( isset ( $ this -> types [ $ data_type ] [ $ type ] ) ) { return $ this -> types [ $ data_type ] [ $ type ] ; } return false ; }
8888	public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ requestHandler ) : ResponseInterface { $ this -> container -> set ( ServerRequestInterface :: class , $ request ) ; $ result = $ this -> dispatch ( $ this -> route ( $ request ) ) ; if ( $ result instanceof ResponseInterface ) { return $ result ; } return $ response = ( new Response ( ) ) -> withProtocolVersion ( '1.1' ) -> withBody ( \ GuzzleHttp \ Psr7 \ stream_for ( $ result ) ) ; }
9782	private function parseIf ( ) { $ if_open = $ this -> pop ( 'IF_OPEN' ) ; $ output = 'if(' . $ if_open [ 1 ] . ') {' . "\n" ; $ this -> currLine ++ ; $ seeking = true ; while ( $ seeking ) { list ( $ type , $ value ) = $ this -> peek ( ) ; switch ( $ type ) { case 'IF_CLOSE' : $ this -> pop ( ) ; $ output .= "}\n" ; $ seeking = false ; $ this -> currLine ++ ; break ; case 'ELSE' : $ this -> pop ( ) ; $ output .= "} else {\n" ; $ this -> currLine ++ ; break ; case 'ELSE_IF' : $ token = $ this -> pop ( ) ; $ output .= '} elseif(' . $ token [ 1 ] . ") {\n" ; $ this -> currLine ++ ; break ; default : $ output .= $ this -> parseExpression ( ) ; break ; } } return $ output ; }
9951	public function duplicateConditionalStyle ( array $ pCellStyle , $ pRange = '' ) { foreach ( $ pCellStyle as $ cellStyle ) { if ( ! ( $ cellStyle instanceof Conditional ) ) { throw new Exception ( 'Style is not a conditional style' ) ; } } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> setConditionalStyles ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row , $ pCellStyle ) ; } } return $ this ; }
7540	function index ( $ count_all = true ) { if ( ! $ this -> parent ) { return - 1 ; } elseif ( $ count_all ) { return $ this -> parent -> findChild ( $ this ) ; } else { $ index = - 1 ; foreach ( array_keys ( $ this -> parent -> children ) as $ k ) { if ( ! $ this -> parent -> children [ $ k ] -> isTextOrComment ( ) ) { ++ $ index ; } if ( $ this -> parent -> children [ $ k ] === $ this ) { return $ index ; } } return - 1 ; } }
571	public function generatePasswordHash ( $ password , $ cost = null ) { if ( $ cost === null ) { $ cost = $ this -> passwordHashCost ; } if ( function_exists ( 'password_hash' ) ) { return password_hash ( $ password , PASSWORD_DEFAULT , [ 'cost' => $ cost ] ) ; } $ salt = $ this -> generateSalt ( $ cost ) ; $ hash = crypt ( $ password , $ salt ) ; if ( ! is_string ( $ hash ) || strlen ( $ hash ) !== 60 ) { throw new Exception ( 'Unknown error occurred while generating hash.' ) ; } return $ hash ; }
4471	public function requeue ( ? string $ queue = null , array $ opts = [ ] ) : string { $ opts = array_merge ( [ 'delay' => 0 , 'data' => $ this -> data , 'priority' => $ this -> priority , 'retries' => $ this -> retries , 'tags' => $ this -> tags , 'depends' => $ this -> dependencies , ] , $ opts ) ; $ queueName = $ queue ? : $ this -> queue ; $ data = json_encode ( $ opts [ 'data' ] , JSON_UNESCAPED_SLASHES ) ? : '{}' ; return $ this -> client -> requeue ( $ this -> worker , $ queueName , $ this -> jid , $ this -> klass , $ data , $ opts [ 'delay' ] , 'priority' , $ opts [ 'priority' ] , 'tags' , json_encode ( $ opts [ 'tags' ] , JSON_UNESCAPED_SLASHES ) , 'retries' , $ opts [ 'retries' ] , 'depends' , json_encode ( $ opts [ 'depends' ] , JSON_UNESCAPED_SLASHES ) ) ; }
680	protected function validateConjunctionCondition ( $ operator , $ condition ) { if ( ! is_array ( $ condition ) || ! ArrayHelper :: isIndexed ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireMultipleOperands' , [ 'operator' => $ operator ] ) ) ; return ; } foreach ( $ condition as $ part ) { $ this -> validateCondition ( $ part ) ; } }
5790	private function setDefaultValue ( $ columnDefault ) { if ( is_null ( $ columnDefault ) ) { $ this -> defaultValue = '' ; } else { switch ( $ this -> type ) { case 'character' : case 'character varying' : case 'text' : case 'USER-DEFINED' : $ parseColumnDefault = explode ( "'" , $ columnDefault ) ; $ this -> defaultValue = $ parseColumnDefault [ 1 ] ; break ; case 'boolean' : if ( $ columnDefault == 'true' ) { $ this -> defaultValue = Postgres :: BOOLEAN_TRUE ; } break ; default : $ this -> defaultValue = $ columnDefault ; } } }
11987	private function isEndOfLine ( $ i ) { $ ch = $ this -> data [ $ i ] ; if ( $ this -> getLineEndingModeCrlf ( ) ) { if ( $ ch == "\r" ) { $ more_ch = $ i + 1 < strlen ( $ this -> data ) ; if ( $ more_ch ) { $ next_n = $ this -> data [ $ i + 1 ] == "\n" ; if ( $ next_n ) return true ; } } } else { if ( $ ch == "\n" ) return true ; } return false ; }
1892	public function accept ( ) { if ( strncmp ( $ this -> current ( ) -> getFilename ( ) , '.' , 1 ) === 0 ) { return false ; } $ strPath = $ this -> current ( ) -> getPathname ( ) ; if ( is_file ( $ strPath ) ) { $ strPath = \ dirname ( $ strPath ) ; } $ objFolder = new Folder ( StringUtil :: stripRootDir ( $ strPath ) ) ; return ! $ objFolder -> isUnsynchronized ( ) ; }
8974	public function setOutputFormat ( $ format ) { $ output = array ( 'xml' , 'html' , 'text' , 'text-main' ) ; if ( ! in_array ( $ format , $ output ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Available output format: %s' , implode ( ', ' , $ output ) ) ) ; } $ this -> outputFormat = $ format ; return $ this ; }
2579	protected function loadCustomerRefs ( $ dkNumber ) { if ( ! is_null ( $ dkNumber ) ) { $ this -> customerRef = new MasterPricer \ CustomerRef ( ) ; $ this -> customerRef -> customerReferences [ ] = new MasterPricer \ CustomerReferences ( $ dkNumber , MasterPricer \ CustomerReferences :: QUAL_AGENCY_GROUPING_ID ) ; } }
12883	public function getUnmappedLocalKeys ( ) { $ u = array_diff ( array_keys ( $ this -> localModel -> getMetaData ( ) -> columns ) , array_keys ( $ this -> _map ) ) ; unset ( $ u [ $ this -> localPrimaryKeyName ] ) ; return $ u ; }
9371	public function integrate ( $ integrations , ConfigurationInterface $ config = null ) { list ( $ config , $ container ) = array ( $ config ? : $ this -> config , static :: $ container ) ; foreach ( ( array ) $ integrations as $ item ) { $ integration = is_string ( $ item ) ? new $ item : $ item ; $ container = $ integration -> define ( $ container , $ config ) ; } static :: $ container = $ container ; return $ this ; }
1726	protected function checkAccountStatus ( ) { @ trigger_error ( 'Using User::checkAccountStatus() has been deprecated and will no longer work in Contao 5.0. Use Symfony security instead.' , E_USER_DEPRECATED ) ; try { $ userChecker = System :: getContainer ( ) -> get ( 'contao.security.user_checker' ) ; $ userChecker -> checkPreAuth ( $ this ) ; $ userChecker -> checkPostAuth ( $ this ) ; } catch ( AuthenticationException $ exception ) { return false ; } return true ; }
5416	protected function dispatchRequest ( $ socket , $ encoding ) { foreach ( $ this -> headers as $ header_line ) { $ socket -> write ( $ header_line . "\r\n" ) ; } if ( count ( $ this -> cookies ) > 0 ) { $ socket -> write ( 'Cookie: ' . implode ( ';' , $ this -> cookies ) . "\r\n" ) ; } $ encoding -> writeHeadersTo ( $ socket ) ; $ socket -> write ( "\r\n" ) ; $ encoding -> writeTo ( $ socket ) ; }
659	public function noCache ( callable $ callable ) { $ this -> _queryCacheInfo [ ] = false ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } }
944	private function parseRules ( ) { if ( null === $ this -> options [ 'rules' ] ) { return $ this -> getConfig ( ) -> getRules ( ) ; } $ rules = trim ( $ this -> options [ 'rules' ] ) ; if ( '' === $ rules ) { throw new InvalidConfigurationException ( 'Empty rules value is not allowed.' ) ; } if ( '{' === $ rules [ 0 ] ) { $ rules = json_decode ( $ rules , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new InvalidConfigurationException ( sprintf ( 'Invalid JSON rules input: %s.' , json_last_error_msg ( ) ) ) ; } return $ rules ; } $ rules = [ ] ; foreach ( explode ( ',' , $ this -> options [ 'rules' ] ) as $ rule ) { $ rule = trim ( $ rule ) ; if ( '' === $ rule ) { throw new InvalidConfigurationException ( 'Empty rule name is not allowed.' ) ; } if ( '-' === $ rule [ 0 ] ) { $ rules [ substr ( $ rule , 1 ) ] = false ; } else { $ rules [ $ rule ] = true ; } } return $ rules ; }
12450	static function run_check_templates ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( array ( '*.tpl' ) ) -> maxdepth ( 0 ) -> in ( $ destdir ) ; if ( count ( $ files ) ) { $ php = self :: getTool ( 'php' , $ opts ) ; if ( strpos ( pake_sh ( $ php . " -v" ) , 'PHP' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$php does not seem to be a valid php executable" ) ; } $ ezp = @ $ opts [ 'ezublish' ] [ 'install_dir_LS' ] ; if ( $ ezp == '' ) { $ ezp = '../..' ; } if ( ! file_exists ( $ ezp . '/bin/php/eztemplatecheck.php' ) ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$ezp does not seem to be a valid eZ Publish install" ) ; } $ rootpath = pakeFinder :: type ( 'directory' ) -> name ( $ opts [ 'extension' ] [ 'name' ] ) -> in ( self :: getBuildDir ( $ opts ) ) ; $ rootpath = dirname ( $ rootpath [ 0 ] ) ; $ out = pake_sh ( "cd " . escapeshellarg ( $ ezp ) . " && " . escapeshellarg ( $ php ) . " bin/php/eztemplatecheck.php " . escapeshellarg ( $ rootpath ) ) ; if ( strpos ( $ out , 'Some templates did not validate' ) !== false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( $ out ) ; } } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
12707	public static function parseSignature ( string $ signature ) : array { $ signature = explode ( ' ' , trim ( $ signature ) ) ; $ command = trim ( $ signature [ 0 ] ) ; $ arguments = [ ] ; $ options = [ ] ; foreach ( $ signature as $ word ) { $ type = self :: determineTypeOfWord ( $ word ) ; if ( $ type == self :: OPTION_TYPE ) { list ( $ key , $ defaultValue ) = self :: parse ( $ word ) ; $ options [ $ key ] = $ defaultValue ; } elseif ( $ type == self :: ARGUMENT_TYPE ) { list ( $ key , $ defaultValue ) = self :: parse ( $ word ) ; $ arguments [ $ key ] = $ defaultValue ; } } return [ $ command , $ arguments , $ options ] ; }
10096	protected function processSize ( $ size ) { if ( $ size === null ) { return $ size ; } $ size = ( int ) $ size ; if ( $ size <= 0 ) { throw new InvalidArgumentException ( 'Size has to be larger than 0' ) ; } return ( int ) $ size ; }
928	public function delete ( $ path ) { if ( isset ( $ this -> files [ $ path ] ) ) { unset ( $ this -> files [ $ path ] ) ; } $ this -> unlink ( $ path ) ; }
5877	protected static function findExistingFile ( $ fileName ) { $ file = null ; $ relativePath = substr ( PathUtility :: dirname ( $ fileName ) , strlen ( PATH_site ) ) ; $ resourceFactory = \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: getInstance ( ) ; $ targetFolder = $ resourceFactory -> retrieveFileOrFolderObject ( $ relativePath ) ; $ storageConfiguration = $ targetFolder -> getStorage ( ) -> getConfiguration ( ) ; if ( isset ( $ storageConfiguration [ 'basePath' ] ) ) { $ basePath = rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . '/' ; $ basePath = GeneralUtility :: getFileAbsFileName ( $ basePath ) ; $ identifier = substr ( $ fileName , strlen ( $ basePath ) - 1 ) ; $ row = GeneralUtility :: makeInstance ( ConnectionPool :: class ) -> getConnectionForTable ( 'sys_file' ) -> select ( [ 'uid' ] , 'sys_file' , [ 'storage' => $ targetFolder -> getStorage ( ) -> getUid ( ) , 'identifier' => $ identifier , ] ) -> fetch ( ) ; if ( ! empty ( $ row [ 'uid' ] ) ) { $ fileRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ FileRepository :: class ) ; $ file = $ fileRepository -> findByUid ( $ row [ 'uid' ] ) ; } } return $ file ; }
555	private function notifyNotFoundCaches ( $ cachesNames ) { $ this -> stdout ( "The following cache components were NOT found:\n\n" , Console :: FG_RED ) ; foreach ( $ cachesNames as $ name ) { $ this -> stdout ( "\t* $name \n" , Console :: FG_GREEN ) ; } $ this -> stdout ( "\n" ) ; }
12026	private function generateExecuteDocBlock ( $ methodDescription ) { $ responseClass = $ this -> operationDefinition -> getResponseClass ( ) ; $ docBlock = new DocBlockGenerator ( $ methodDescription , null ) ; if ( $ responseClass ) { $ tags [ ] = new GenericTag ( 'return' , '\\' . $ responseClass ) ; } else { $ tags [ ] = new GenericTag ( 'return' , 'mixed' ) ; } $ docBlock -> setTags ( $ tags ) ; return $ docBlock ; }
10243	public function isImplemented ( $ pFunction ) { $ pFunction = strtoupper ( $ pFunction ) ; $ notImplemented = ! isset ( self :: $ phpSpreadsheetFunctions [ $ pFunction ] ) || ( is_array ( self :: $ phpSpreadsheetFunctions [ $ pFunction ] [ 'functionCall' ] ) && self :: $ phpSpreadsheetFunctions [ $ pFunction ] [ 'functionCall' ] [ 1 ] === 'DUMMY' ) ; return ! $ notImplemented ; }
8701	public function getString ( ) { $ this -> validateElement ( ) ; $ elementStringData = '' ; $ elementStringData = '<' . static :: TYPE ; foreach ( $ this -> attributes as $ key => $ data ) { $ elementStringData .= ' ' . $ key . '="' . $ data . '"' ; } $ elementStringData .= '>' ; if ( $ this -> text !== null ) { $ elementStringData .= $ this -> text ; } if ( count ( $ this -> childElements ) > 0 ) { if ( static :: TYPE == 'svg' ) { foreach ( $ this -> childElements as $ childElement ) { $ this -> defs = array_merge ( $ this -> defs , $ childElement -> getDefs ( ) ) ; } if ( count ( $ this -> defs ) > 0 ) { $ defArea = new \ SVGCreator \ Elements \ Defs ( ) ; foreach ( $ this -> defs as $ def ) { $ defArea -> append ( $ def ) ; } $ elementStringData .= $ defArea -> getString ( ) ; } } foreach ( $ this -> childElements as $ childElement ) { $ elementStringData .= $ childElement -> getString ( ) ; } } $ elementStringData .= '</' . static :: TYPE . '>' ; $ this -> elementString = $ elementStringData ; return $ this -> elementString ; }
10408	public function addDocumentParameter ( $ field , $ value ) { $ this -> documentParamCache [ md5 ( $ value . $ field ) ] = [ $ field , $ value ] ; }
1120	public function getRoot ( ) { if ( $ this -> exists ) { return $ this -> ancestorsAndSelf ( ) -> whereNull ( $ this -> getParentColumnName ( ) ) -> first ( ) ; } else { $ parentId = $ this -> getParentId ( ) ; if ( ! is_null ( $ parentId ) && $ currentParent = static :: find ( $ parentId ) ) { return $ currentParent -> getRoot ( ) ; } else { return $ this ; } } }
3620	public function setFanEveryDaySchedule ( $ start_hour , $ end_hour , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'fan_duty_start_time' => $ start_hour * 3600 , 'fan_duty_end_time' => $ end_hour * 3600 ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
4453	public function isPaused ( ) : bool { $ stat = json_decode ( $ this -> client -> queues ( $ this -> name ) , true ) ; return isset ( $ stat [ 'name' ] ) && $ stat [ 'name' ] === $ this -> name && $ stat [ 'paused' ] == true ; }
7147	public function get_user_settings ( $ default = array ( ) , $ user_id = NULL ) { if ( ! $ user_id ) return $ default ; $ default_opt_in = apply_filters ( 'iac_default_opt_in' , FALSE ) ; $ default = $ default_opt_in ? '1' : '0' ; $ settings = array ( 'inform_about_posts' => get_user_meta ( $ user_id , 'post_subscription' , TRUE ) , 'inform_about_comments' => get_user_meta ( $ user_id , 'comment_subscription' , TRUE ) ) ; foreach ( $ settings as $ k => $ v ) { if ( '' === $ v ) $ settings [ $ k ] = $ default ; } return $ settings ; }
7089	public function defaultHeader ( array $ headers = [ ] ) { $ this -> defaultHeaders = array_merge ( $ this -> defaultHeaders , $ headers ) ; return $ this -> defaultHeaders ; }
7002	public function action ( Callable $ action = null ) { if ( $ action ) $ this -> action = $ action ; return $ this -> action ; }
12124	public function getLanguages ( ) { $ languages = array ( ) ; foreach ( $ this -> getAliases ( ) as $ siteAlias ) { $ language = $ siteAlias -> getLanguage ( ) ; if ( ! in_array ( $ language , $ languages ) ) { $ languages [ ] = $ language ; } } return $ languages ; }
10448	private function callIfExistsAndEnabled ( $ method , array $ parameters = [ ] ) { if ( ! $ this -> isEnabled ( ) ) return ; if ( method_exists ( $ this , $ method ) && $ this -> { "{$method}IsEnabled" } ( ) ) { $ this -> container -> call ( [ $ this , $ method ] , $ parameters ) ; } }
5973	public function events ( ) { if ( ! $ this -> events instanceof EventsController ) { $ this -> events = new EventsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> events -> setLogger ( $ this -> logger ) ; } return $ this -> events ; }
9878	private function writeWorkbookPr ( XMLWriter $ objWriter ) { $ objWriter -> startElement ( 'workbookPr' ) ; if ( Date :: getExcelCalendar ( ) == Date :: CALENDAR_MAC_1904 ) { $ objWriter -> writeAttribute ( 'date1904' , '1' ) ; } $ objWriter -> writeAttribute ( 'codeName' , 'ThisWorkbook' ) ; $ objWriter -> endElement ( ) ; }
6221	public function setHttpClient ( $ httpClient ) { if ( is_null ( $ httpClient ) ) { $ httpClient = new Curl ; $ threeScaleVersion = new ThreeScaleVersion ( ) ; $ version = $ threeScaleVersion -> getVersion ( ) ; $ httpClient -> options [ 'CURLOPT_FOLLOWLOCATION' ] = false ; $ httpClient -> headers [ 'X-3scale-User-Agent' ] = 'plugin-php-v' . $ version ; } $ this -> httpClient = $ httpClient ; }
3881	private function getPageDetails ( $ pageId ) { if ( empty ( $ pageId ) ) { return array ( ) ; } $ event = new GetPageDetailsEvent ( $ pageId ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; return $ event -> getPageDetails ( ) ; }
8874	public function addAttachment ( $ attachment ) { if ( ! file_exists ( $ attachment ) ) { pines_error ( 'Invalid attachment.' ) ; return false ; } $ this -> attachments [ ] = $ attachment ; return true ; }
9949	public function getStyleByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 = null , $ row2 = null ) { if ( $ columnIndex2 !== null && $ row2 !== null ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> getStyle ( $ cellRange ) ; } return $ this -> getStyle ( Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 ) ; }
5972	public function deployment ( ) { if ( ! $ this -> deployment instanceof DeploymentController ) { $ this -> deployment = new DeploymentController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> deployment -> setLogger ( $ this -> logger ) ; } return $ this -> deployment ; }
11609	public function actionDisconnect ( $ id ) { $ account = $ this -> finder -> findAccountById ( $ id ) ; if ( $ account === null ) { throw new NotFoundHttpException ; } if ( $ account -> user_id != \ Yii :: $ app -> user -> id ) { throw new ForbiddenHttpException ; } $ account -> delete ( ) ; return $ this -> redirect ( [ 'networks' ] ) ; }
7075	private function addItemDetails ( array & $ details , Model \ SaleItemInterface $ item ) { $ total = 0 ; if ( ! ( $ item -> isCompound ( ) && ! $ item -> hasPrivateChildren ( ) ) ) { $ itemResult = $ item -> getResult ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NAME' . $ this -> line ] = $ item -> getTotalQuantity ( ) . 'x ' . $ item -> getDesignation ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NUMBER' . $ this -> line ] = $ item -> getReference ( ) ; if ( ! empty ( $ description = $ item -> getDescription ( ) ) ) { $ details [ 'L_PAYMENTREQUEST_0_DESC' . $ this -> line ] = $ description ; } $ details [ 'L_PAYMENTREQUEST_0_AMT' . $ this -> line ] = $ this -> format ( $ itemResult -> getTotal ( ) ) ; $ total = $ itemResult -> getTotal ( ) ; $ this -> line ++ ; } foreach ( $ item -> getChildren ( ) as $ child ) { $ total += $ this -> addItemDetails ( $ details , $ child ) ; } return $ total ; }
9544	public static function allExcept ( $ except ) { $ result = [ 'parameter' => [ 'longest' => 9 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> prefix . $ parameter -> parameterName ; } , ] , 'properties' => [ 'longest' => 10 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> getPropertiesAsString ( ) ; } , ] , 'aliases' => [ 'longest' => 7 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> getAliasUsage ( false ) ; } , ] , 'description' => [ 'longest' => 11 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> description ; } , ] , 'required' => [ 'longest' => 8 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> required ? 'Yes' : '' ; } , ] , ] ; foreach ( $ except as $ exceptKey ) { unset ( $ result [ $ exceptKey ] ) ; } return $ result ; }
2078	public function purgePageCache ( ) { $ strCacheDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCacheDir . '/http_cache' ) ; $ objFolder -> purge ( ) ; $ this -> log ( 'Purged the page cache' , __METHOD__ , TL_CRON ) ; }
7151	public function equals ( SubjectIdentity $ identity ) { return $ this -> provider === $ identity -> getProvider ( ) && $ this -> identifier === $ identity -> getIdentifier ( ) ; }
8280	public function onPagesLoaded ( array & $ pages ) { unset ( $ pages [ "403" ] ) ; if ( ! $ this -> config [ "alterPageArray" ] ) { return ; } if ( $ this -> errorOccurred ) { $ pages = array ( ) ; return ; } foreach ( $ pages as $ id => $ page ) { try { $ allowed = $ this -> checkAccess ( $ id ) ; } catch ( \ Exception $ e ) { $ this -> errorHandler ( $ e , $ this -> requestUrl ) ; $ pages = array ( ) ; return ; } if ( ! $ allowed ) { unset ( $ pages [ $ id ] ) ; } } }
10422	public function addToInsertList ( $ key , $ value , $ isString = true ) { $ this -> sqlInsertList [ $ key ] = [ 'value' => $ value , 'string' => $ isString , ] ; }
12195	protected function extractArguments ( array $ arguments , array $ data ) { $ instanceArgs = [ ] ; foreach ( $ arguments as $ arg ) { if ( array_key_exists ( $ arg -> getName ( ) , $ data ) ) { $ instanceArgs [ ] = $ data [ $ arg -> getName ( ) ] ; } else { $ instanceArgs [ ] = null ; } } return $ instanceArgs ; }
10688	private function configureAutoloaderAndResolver ( ) { if ( $ this -> autoloader !== null ) return ; $ cache = $ this -> cachemanager -> getCache ( "resolution" ) ; $ this -> autoloader = new Autoloader ( ) ; $ this -> autoloader -> setCache ( $ cache ) ; $ this -> injector -> setInstance ( Autoloader :: class , $ this -> autoloader ) ; $ this -> resolver = new Resolver ( $ cache ) ; $ this -> resolver -> addResolverType ( 'template' , 'template' , '.php' ) -> addResolverType ( 'assets' , 'assets' ) -> addResolverType ( 'app' , 'app' ) -> addResolverType ( 'code' , 'src' ) -> addResolverType ( 'language' , 'language' ) -> addResolverType ( 'migrations' , 'migrations' ) -> setResolver ( "app" , new Router ( "router" ) ) ; $ this -> injector -> setInstance ( Resolver :: class , $ this -> resolver ) ; spl_autoload_register ( array ( $ this -> autoloader , 'autoload' ) , true , true ) ; $ cl = Autoloader :: findComposerAutoloader ( ) ; if ( ! empty ( $ cl ) ) { $ vendor_dir = Autoloader :: findComposerAutoloaderVendorDir ( $ cl ) ; $ this -> autoloader -> importComposerAutoloaderConfiguration ( $ vendor_dir ) ; $ this -> resolver -> autoConfigureFromComposer ( $ vendor_dir ) ; } else { $ my_dir = __DIR__ ; $ wedeto_dir = dirname ( dirname ( $ my_dir ) ) ; $ this -> autoloader -> registerNS ( "Wedeto\\" , $ wedeto_dir , Autoloader :: PSR4 ) ; $ modules = $ this -> resolver -> findModules ( $ wedeto_dir , '/modules' , "" , 0 ) ; foreach ( $ modules as $ name => $ path ) $ this -> resolver -> registerModule ( $ name , $ path ) ; } }
9737	public function setWidth ( $ pValue ) { if ( $ this -> resizeProportional && $ pValue != 0 ) { $ ratio = $ this -> height / ( $ this -> width != 0 ? $ this -> width : 1 ) ; $ this -> height = round ( $ ratio * $ pValue ) ; } $ this -> width = $ pValue ; return $ this ; }
3747	protected function extractSorting ( $ config ) { $ sorting = $ config -> getSorting ( ) ; $ sortBy = key ( $ sorting ) ; $ sortDir = current ( $ sorting ) ? : DCGE :: MODEL_SORTING_ASC ; return array ( $ sortBy , $ sortDir ) ; }
7328	private function configureVatNumberSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Pricing \ Model \ VatNumberSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> vatNumberSubjectClassCache ) ) { return ; } $ this -> addMappings ( $ metadata , $ this -> getVatNumberSubjectMappings ( ) ) ; $ this -> vatNumberSubjectClassCache [ ] = $ class ; }
6844	public function callInClass ( $ class_name , $ action , $ params = array ( ) ) { $ ref = new ReflectionMethod ( $ class_name , $ action ) ; if ( ! $ ref -> isPublic ( ) && ! $ ref -> isStatic ( ) ) throw new InjectorException ( "$class_name->$action is not public or static" ) ; $ params_need = $ ref -> getParameters ( ) ; $ args = $ this -> apply ( $ params_need , $ params ) ; $ obj = $ this -> produce ( $ class_name , $ params ) ; return call_user_func_array ( [ $ obj , $ action ] , $ args ) ; }
2445	protected static function initialize ( ) { if ( ! \ in_array ( 'mcrypt' , get_loaded_extensions ( ) ) ) { throw new \ Exception ( 'The PHP mcrypt extension is not installed' ) ; } if ( ! self :: $ resTd = mcrypt_module_open ( Config :: get ( 'encryptionCipher' ) , '' , Config :: get ( 'encryptionMode' ) , '' ) ) { throw new \ Exception ( 'Error initializing encryption module' ) ; } }
4873	public function init ( ) { $ this -> setName ( 'buttons' ) ; if ( ! isset ( $ this -> options [ 'render_summary' ] ) ) { $ this -> options [ 'render_summary' ] = false ; } $ this -> setAttribute ( 'class' , 'text-right' ) ; $ this -> add ( array ( 'type' => 'Core/Spinner-Submit' , 'name' => 'submit' , 'options' => array ( 'label' => 'Save' , ) , 'attributes' => array ( 'id' => 'submit' , 'type' => 'submit' , 'value' => 'Save' , 'class' => 'sf-submit btn btn-primary btn-xs' ) , ) ) ; $ this -> add ( array ( 'type' => 'Button' , 'name' => 'cancel' , 'options' => array ( 'label' => 'Cancel' , ) , 'attributes' => array ( 'id' => 'cancel' , 'type' => 'reset' , 'value' => 'Cancel' , 'class' => 'sf-cancel btn btn-default btn-xs' ) , ) ) ; }
11520	protected function GenerateWindowsPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata , Image $ WindowsPinicon ) { $ metadata .= $ owner -> MarkupComment ( 'Windows Pinned Icon' ) ; $ appName = $ config -> fetchPiniconTitle ( ) ; if ( ! $ appName ) { $ appName = $ config -> Title ; } $ metadata .= $ owner -> MarkupMeta ( 'application-name' , $ appName ) ; if ( $ config -> fetchWindowsPiniconBackgroundColor ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'msapplication-TileColor' , $ config -> fetchWindowsPiniconBackgroundColor ( ) ) ; } $ metadata .= $ owner -> MarkupMeta ( 'msapplication-square70x70logo' , $ WindowsPinicon -> Fill ( 70 , 70 ) -> getAbsoluteURL ( ) ) ; $ metadata .= $ owner -> MarkupMeta ( 'msapplication-square150x150logo' , $ WindowsPinicon -> Fill ( 150 , 150 ) -> getAbsoluteURL ( ) ) ; }
11620	public function auth ( ) : \ TheCMSThread \ Core \ Main \ Auth { static $ auth ; if ( $ auth === null ) { $ auth = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\Auth" ) ; } $ auth -> __construct ( ) ; return $ auth ; }
6756	public static function createApp ( string $ appPath , string $ environment , bool $ debug ) : BaseKernel { $ envPath = $ appPath . '/.env' ; if ( file_exists ( $ envPath ) ) { $ dotenv = new Dotenv ( ) ; $ dotenv -> load ( $ envPath ) ; } $ oneBundleAppConfig = new \ OneBundleApp \ App \ OneBundleAppConfig ( $ appPath , $ environment ) ; \ Symfony \ Component \ Debug \ ErrorHandler :: register ( ) ; \ Symfony \ Component \ Debug \ ExceptionHandler :: register ( ) ; return new \ Mmoreram \ BaseBundle \ Kernel \ BaseKernel ( $ oneBundleAppConfig -> getBundles ( ) , $ oneBundleAppConfig -> getConfig ( ) , $ oneBundleAppConfig -> getRoutes ( ) , $ environment , $ debug , $ appPath . '/var' ) ; }
204	public static function moveCursorTo ( $ column , $ row = null ) { if ( $ row === null ) { echo "\033[" . ( int ) $ column . 'G' ; } else { echo "\033[" . ( int ) $ row . ';' . ( int ) $ column . 'H' ; } }
735	protected function getDirectPermissionsByUser ( $ userId ) { $ permissions = [ ] ; foreach ( $ this -> getAssignments ( $ userId ) as $ name => $ assignment ) { $ permission = $ this -> items [ $ assignment -> roleName ] ; if ( $ permission -> type === Item :: TYPE_PERMISSION ) { $ permissions [ $ name ] = $ permission ; } } return $ permissions ; }
3515	public function getLocale ( ) { if ( ! $ this -> cookiesLoaded ) { $ key = $ this -> cookiePrefix . 'lang_locale' ; $ queuedCookieLocale = \ Cookie :: queued ( $ key , null ) ; $ locale = getSupportedLocale ( $ queuedCookieLocale != null ? $ queuedCookieLocale -> getValue ( ) : \ Cookie :: get ( $ key , '' ) ) ; parent :: setLocale ( $ locale ) ; $ this -> getShowUnpublished ( ) ; $ this -> cookiesLoaded = true ; } return parent :: getLocale ( ) ; }
11941	public function onExecuteAction ( ExecuteActionEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ position = 1 ; foreach ( $ request -> getConfig ( ) -> getArray ( 'argument' ) as $ argument ) { $ this -> validateArgument ( $ request , $ argument , $ position ++ ) ; } }
10029	function getContactsByFilterId ( $ filterId , $ page_index = 1 , $ page_size = 100 , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'page_index' => $ page_index , 'page_size' => $ page_size , 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/filter/' . utf8_encode ( $ filterId ) , $ queryParameters ) ; }
1451	protected function validatorForDelete ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) : ValidatorInterface { return $ this -> createValidator ( $ data , $ rules , $ messages , $ customAttributes ) ; }
11555	private function getBonusTotals ( $ dsBegin , $ dsEnd ) { $ query = $ this -> qbGetBonusTotals -> build ( ) ; $ conn = $ query -> getConnection ( ) ; $ bind = [ QBGetTotals :: BND_PERIOD_BEGIN => $ dsBegin , QBGetTotals :: BND_PERIOD_END => $ dsEnd ] ; $ rs = $ conn -> fetchAll ( $ query , $ bind ) ; $ result = [ ] ; foreach ( $ rs as $ one ) { $ accId = $ one [ QBGetTotals :: A_ACC_ID ] ; $ custId = $ one [ QBGetTotals :: A_CUST_ID ] ; $ total = $ one [ QBGetTotals :: A_TOTAL ] ; if ( $ custId ) { $ item = new DTotal ( ) ; $ item -> accountId = $ accId ; $ item -> customerId = $ custId ; $ item -> total = $ total ; $ result [ $ custId ] = $ item ; } } return $ result ; }
6161	public function addPropertyRequest ( $ item ) { if ( ! ( $ item instanceof PropertyRequest ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertyRequest ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertyRequest. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertyRequest"!' , E_USER_WARNING ) ; } } $ this -> properties [ ] = $ item ; return $ this ; }
1815	public function tableImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=table' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a> ' . Contao \ Image :: getHtml ( 'demagnify.svg' , '' , 'title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_shrink' ] ) . '" style="cursor:pointer" onclick="Backend.tableWizardResize(0.9)"' ) . Contao \ Image :: getHtml ( 'magnify.svg' , '' , 'title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_expand' ] ) . '" style="cursor:pointer" onclick="Backend.tableWizardResize(1.1)"' ) ; }
2459	public function move ( ) { if ( $ this -> intId && Input :: get ( 'sid' ) && ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'root' ] || ! \ in_array ( $ this -> intId , $ this -> root ) ) ) { $ objRow = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE id=? OR id=?" ) -> limit ( 2 ) -> execute ( $ this -> intId , Input :: get ( 'sid' ) ) ; $ row = $ objRow -> fetchAllAssoc ( ) ; if ( $ row [ 0 ] [ 'pid' ] == $ row [ 1 ] [ 'pid' ] ) { $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET sorting=? WHERE id=?" ) -> execute ( $ row [ 0 ] [ 'sorting' ] , $ row [ 1 ] [ 'id' ] ) ; $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET sorting=? WHERE id=?" ) -> execute ( $ row [ 1 ] [ 'sorting' ] , $ row [ 0 ] [ 'id' ] ) ; $ this -> invalidateCacheTags ( $ this ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
6014	public function retrieveProtocol ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/protocols/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Protocol ( $ result ) ; return $ result ; }
8547	public function setPayWithAmazonEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PayWithAmazonEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3941	public function maxChildren ( $ conditionType ) { if ( ! isset ( $ GLOBALS [ 'METAMODELS' ] [ 'inputscreen_conditions' ] [ $ conditionType ] [ 'maxChildren' ] ) ) { return null ; } @ trigger_error ( 'Configuring input screen conditions via global array is deprecated. ' . 'Please implement/configure a valid condition factory.' , E_USER_DEPRECATED ) ; return $ GLOBALS [ 'METAMODELS' ] [ 'inputscreen_conditions' ] [ $ conditionType ] [ 'maxChildren' ] ; }
12825	protected function getSlotDefinition ( $ dir ) { $ slotsFilename = $ this -> getSlotDefinitionFile ( $ dir ) ; return json_decode ( FilesystemTools :: readFile ( $ slotsFilename ) , true ) ; }
1378	protected function validateIdentifier ( $ value , string $ path , ? int $ index = null ) : bool { $ member = is_int ( $ index ) ? ( string ) $ index : 'data' ; if ( ! is_object ( $ value ) ) { $ this -> memberNotObject ( $ path , $ member ) ; return false ; } $ dataPath = sprintf ( '%s/%s' , rtrim ( $ path , '/' ) , $ member ) ; $ valid = true ; if ( ! property_exists ( $ value , 'type' ) ) { $ this -> memberRequired ( $ dataPath , 'type' ) ; $ valid = false ; } else if ( ! $ this -> validateTypeMember ( $ value -> type , $ dataPath ) ) { $ valid = false ; } if ( ! property_exists ( $ value , 'id' ) ) { $ this -> memberRequired ( $ dataPath , 'id' ) ; $ valid = false ; } else if ( ! $ this -> validateIdMember ( $ value -> id , $ dataPath ) ) { $ valid = false ; } if ( property_exists ( $ value , 'attributes' ) || property_exists ( $ value , 'relationships' ) ) { $ this -> memberNotIdentifier ( $ path , $ member ) ; $ valid = false ; } return $ valid ; }
3798	private function checkModelWithVariants ( $ containedModel ) { $ isVarbase = ( bool ) $ containedModel -> getProperty ( 'varbase' ) ; $ vargroup = $ containedModel -> getProperty ( 'vargroup' ) ; $ isCurrentVarbase = ( bool ) $ this -> currentModel -> getProperty ( 'varbase' ) ; $ currentVargroup = $ this -> currentModel -> getProperty ( 'vargroup' ) ; if ( $ isVarbase && ! $ this -> circularReference && $ isCurrentVarbase ) { $ this -> disablePA = false ; } elseif ( ! $ isVarbase && ! $ isCurrentVarbase && $ vargroup == $ currentVargroup ) { $ this -> disablePA = false ; } $ this -> disablePI = ! $ isCurrentVarbase || $ isVarbase ; }
8831	protected function getCheckboxCheckedState ( $ name , $ value , $ checked ) { $ posted = $ this -> getValueAttribute ( $ name , $ checked ) ; if ( is_array ( $ posted ) ) { return in_array ( $ value , $ posted ) ; } else { return ( bool ) $ posted ; } }
634	public function createTable ( $ table , $ columns , $ options = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createTable ( $ table , $ columns , $ options ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
12097	public function checkSignCode ( array $ params , $ secret ) { if ( false === isset ( $ params [ self :: SIGN_NAMESPACE ] ) ) { return false ; } return $ params [ self :: SIGN_NAMESPACE ] === $ this -> generateSignCode ( $ params , $ secret ) ; }
12069	public function updateProject ( Project $ project , $ composerJson ) { $ response = $ this -> getResponse ( 'post' , sprintf ( 'v2/projects/%s' , $ project -> getProjectKey ( ) ) , array ( ) , array ( 'project_file' => $ composerJson ) ) ; return $ this -> hydrator -> hydrate ( $ project , $ response ) ; }
3254	private function getItem ( $ sku ) { $ className = Config :: get ( 'shop.item' ) ; $ item = new $ className ( ) ; return $ item -> where ( 'sku' , $ sku ) -> where ( 'cart_id' , $ this -> attributes [ 'id' ] ) -> first ( ) ; }
8415	public function beginTransaction ( ) : bool { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } ++ $ this -> transactionLevel ; if ( $ this -> transactionLevel == 1 ) { return $ this -> providerDatabase -> beginTransaction ( $ this -> GetMasterLink ( ) ) ; } return $ this -> providerDatabase -> savePoint ( $ this -> GetMasterLink ( ) , 'LEVEL' . ( $ this -> transactionLevel - 1 ) ) ; }
7945	public function ipDeleteMonitoringNotification ( $ id , $ ip , $ notificationId ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Missing parameter $ip.' ) ; if ( ! $ notificationId ) throw new BadMethodCallException ( 'Missing parameter $notificationId.' ) ; try { $ r = $ this -> delete ( 'xdsl/' . $ id . '/ips/' . $ ip . '/monitoringNotifications/' . $ notificationId ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return ; }
6707	public function afterFind ( $ event ) { if ( is_array ( $ this -> fields ) ) { foreach ( $ this -> fields as $ field ) { if ( $ event -> sender -> { $ field } ) { $ event -> sender -> { $ field } = explode ( ';' , $ event -> sender -> { $ field } ) ; } } } }
4398	protected function getTransactionReference ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ base ) { $ code = $ this -> getServiceItem ( ) -> getCode ( ) ; $ service = $ base -> getService ( \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT , $ code ) ; return $ service -> getAttribute ( 'TRANSACTIONID' , 'payment/omnipay' ) ; }
5405	public function agePrematurely ( $ interval ) { for ( $ i = 0 ; $ i < count ( $ this -> cookies ) ; $ i ++ ) { $ this -> cookies [ $ i ] -> agePrematurely ( $ interval ) ; } }
1847	protected function parseArticles ( $ objArticles , $ blnAddArchive = false ) { $ limit = $ objArticles -> count ( ) ; if ( $ limit < 1 ) { return array ( ) ; } $ count = 0 ; $ arrArticles = array ( ) ; while ( $ objArticles -> next ( ) ) { $ objArticle = $ objArticles -> current ( ) ; $ arrArticles [ ] = $ this -> parseArticle ( $ objArticle , $ blnAddArchive , ( ( ++ $ count == 1 ) ? ' first' : '' ) . ( ( $ count == $ limit ) ? ' last' : '' ) . ( ( ( $ count % 2 ) == 0 ) ? ' odd' : ' even' ) , $ count ) ; } return $ arrArticles ; }
880	private function resolveSubset ( $ setName , $ setValue ) { $ rules = $ this -> getSetDefinition ( $ setName ) ; foreach ( $ rules as $ name => $ value ) { if ( '@' === $ name [ 0 ] ) { $ set = $ this -> resolveSubset ( $ name , $ setValue ) ; unset ( $ rules [ $ name ] ) ; $ rules = array_merge ( $ rules , $ set ) ; } elseif ( ! $ setValue ) { $ rules [ $ name ] = false ; } else { $ rules [ $ name ] = $ value ; } } return $ rules ; }
10522	protected function quoteIndex ( array $ cols ) { $ q = [ ] ; foreach ( $ cols as $ col ) { $ q [ ] = $ this -> quoteLeading ( $ col ) ; } return $ q ; }
4152	public function getBearerToken ( ) { $ url = $ this -> getBearerTokenUrl ( ) ; $ params = array ( 'post' => array ( 'grant_type' => 'client_credentials' ) , 'headers' => $ this -> buildBearerTokenHeader ( ) , ) ; $ response = $ this -> curl -> send ( $ url , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> token_type ) || $ obj -> token_type != 'bearer' ) { $ this -> findExceptions ( $ response ) ; } $ this -> bearerToken = rawurldecode ( $ obj -> access_token ) ; unset ( $ url , $ params , $ response , $ obj ) ; return $ this -> bearerToken ; }
2779	public function git ( string $ commandLine , ? string $ cwd = null ) : string { $ command = new GitCommand ( $ commandLine ) ; $ command -> executeRaw ( is_string ( $ commandLine ) ) ; $ command -> setDirectory ( $ cwd ) ; return $ this -> run ( $ command ) ; }
6020	public function removeMediaFromDeploymentSite ( $ id , $ mediaIds ) { $ parameters = [ 'query' => [ 'mediaIds' => $ mediaIds ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/deployment/' . $ id . '/media' , $ parameters ) ; return $ result ; }
3951	protected function isEmptyValue ( $ mixValue ) { if ( is_array ( $ mixValue ) ) { return $ this -> isArrayEmpty ( $ mixValue ) ; } elseif ( $ mixValue === '' ) { return true ; } elseif ( $ mixValue === null ) { return true ; } return false ; }
85	public function getPackageFilename ( PackageInterface $ package ) { $ nameParts = array ( preg_replace ( '#[^a-z0-9-_]#i' , '-' , $ package -> getName ( ) ) ) ; if ( preg_match ( '{^[a-f0-9]{40}$}' , $ package -> getDistReference ( ) ) ) { array_push ( $ nameParts , $ package -> getDistReference ( ) , $ package -> getDistType ( ) ) ; } else { array_push ( $ nameParts , $ package -> getPrettyVersion ( ) , $ package -> getDistReference ( ) ) ; } if ( $ package -> getSourceReference ( ) ) { $ nameParts [ ] = substr ( sha1 ( $ package -> getSourceReference ( ) ) , 0 , 6 ) ; } $ name = implode ( '-' , array_filter ( $ nameParts , function ( $ p ) { return ! empty ( $ p ) ; } ) ) ; return str_replace ( '/' , '-' , $ name ) ; }
137	public function install ( RepositoryInterface $ repo , InstallOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; $ installer -> install ( $ repo , $ package ) ; $ this -> markForNotification ( $ package ) ; }
11247	public function getLast ( ) : array { $ sql = "select migration from {$this->table} as b where exists (select max(batch) from {$this->table} as a where b.batch = a.batch) order by migration desc" ; $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> execute ( ) ; return $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; }
6901	public function destroy ( ) : void { if ( $ this -> is_active ( ) ) { session_unset ( ) ; session_destroy ( ) ; $ this -> _data = [ ] ; Cookie :: delete ( $ this -> name ) ; } }
10637	public function uploadAction ( Request $ request ) { $ rawMedias = array_merge ( $ this -> processUploadedFiles ( $ request -> files ) , $ this -> processUrls ( $ request ) ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ mtm = $ this -> get ( 'mm_media.mediatype.manager' ) ; $ returnData = array ( ) ; foreach ( $ rawMedias as $ rawmedia ) { if ( null != ( $ mt = $ mtm -> getMediaTypeMatch ( $ rawmedia ) ) ) { $ ms = $ mt -> getEntity ( ) ; $ em -> persist ( $ ms ) ; $ em -> flush ( ) ; $ returnData [ ] = array ( 'id' => $ ms -> getId ( ) , 'path' => $ rawmedia , 'mediatype' => ( string ) $ ms -> getMediaType ( ) , ) ; } } return new JsonResponse ( array ( 'success' => true , 'data' => $ returnData , ) ) ; }
4192	protected function dumpPhpDoc ( $ phpDoc ) { $ str = '' ; foreach ( $ phpDoc as $ k => $ values ) { if ( ! \ is_array ( $ values ) ) { continue ; } foreach ( $ values as $ value ) { if ( $ k == 'link' ) { $ value = '<a href="' . $ value [ 'uri' ] . '" target="_blank">' . \ htmlspecialchars ( $ value [ 'desc' ] ? : $ value [ 'uri' ] ) . '</a>' ; } elseif ( $ k == 'see' && $ value [ 'uri' ] ) { $ value = '<a href="' . $ value [ 'uri' ] . '" target="_blank">' . \ htmlspecialchars ( $ value [ 'desc' ] ? : $ value [ 'uri' ] ) . '</a>' ; } else { $ value = \ htmlspecialchars ( \ implode ( ' ' , $ value ) ) ; } $ str .= '<dd class="phpdoc phpdoc-' . $ k . '">' . '<span class="phpdoc-tag">' . $ k . '</span>' . '<span class="t_operator">:</span> ' . $ value . '</dd>' . "\n" ; } } if ( $ str ) { $ str = '<dt class="phpDoc">phpDoc</dt>' . "\n" . $ str ; } return $ str ; }
10813	public function callMethodInWrappedInst ( $ method , $ args ) { $ i = $ this -> getWrappedInst ( ) ; if ( method_exists ( $ i , $ method ) ) { return call_user_method_array ( $ method , $ i , $ args ) ; } throw new UnknownMethodException ( 'Calling unknown method: ' . get_class ( $ i ) . "::$method()" ) ; }
1369	protected function bindInboundRequest ( ) { $ this -> app -> singleton ( JsonApiRequest :: class ) ; $ this -> app -> alias ( JsonApiRequest :: class , 'json-api.request' ) ; $ this -> app -> singleton ( Route :: class , function ( Application $ app ) { return new Route ( $ app -> make ( ResolverInterface :: class ) , $ app -> make ( 'router' ) -> current ( ) ) ; } ) ; $ this -> app -> bind ( StoreInterface :: class , function ( ) { return json_api ( ) -> getStore ( ) ; } ) ; $ this -> app -> bind ( ResolverInterface :: class , function ( ) { return json_api ( ) -> getResolver ( ) ; } ) ; $ this -> app -> bind ( ErrorRepositoryInterface :: class , function ( ) { return json_api ( ) -> getErrors ( ) ; } ) ; $ this -> app -> bind ( ContainerInterface :: class , function ( ) { return json_api ( ) -> getContainer ( ) ; } ) ; $ this -> app -> singleton ( HeaderParametersInterface :: class , function ( Application $ app ) { $ parser = $ app -> make ( HttpFactoryInterface :: class ) -> createHeaderParametersParser ( ) ; $ serverRequest = $ app -> make ( ServerRequestInterface :: class ) ; return $ parser -> parse ( $ serverRequest , http_contains_body ( $ serverRequest ) ) ; } ) ; $ this -> app -> singleton ( EncodingParametersInterface :: class , function ( Application $ app ) { $ parser = $ app -> make ( HttpFactoryInterface :: class ) -> createQueryParametersParser ( ) ; return $ parser -> parseQueryParameters ( request ( ) -> query ( ) ) ; } ) ; }
12368	public function set ( string $ name , string $ value = null ) : Headers { if ( $ value !== null ) { header ( $ name . ': ' . $ value ) ; } else { header ( $ name ) ; } return $ this ; }
520	protected function migrateUp ( $ class ) { if ( $ class === self :: BASE_MIGRATION ) { return true ; } $ this -> stdout ( "*** applying $class\n" , Console :: FG_YELLOW ) ; $ start = microtime ( true ) ; $ migration = $ this -> createMigration ( $ class ) ; if ( $ migration -> up ( ) !== false ) { $ this -> addMigrationHistory ( $ class ) ; $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** applied $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_GREEN ) ; return true ; } $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** failed to apply $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_RED ) ; return false ; }
4396	public function refund ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsRefund ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ type = \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT ; $ service = $ this -> getBasketService ( $ base , $ type , $ this -> getServiceItem ( ) -> getCode ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> refund ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ attr = array ( 'REFUNDID' => $ response -> getTransactionReference ( ) ) ; $ this -> setAttributes ( $ service , $ attr , 'payment/omnipay' ) ; $ this -> saveOrderBase ( $ base ) ; $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_REFUND ; $ order -> setPaymentStatus ( $ status ) ; $ this -> saveOrder ( $ order ) ; } }
5830	public function prepareRequest ( Request $ request ) { $ this -> ch = curl_init ( ) ; curl_setopt ( $ this -> ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ this -> ch , CURLOPT_HEADER , true ) ; curl_setopt ( $ this -> ch , CURLOPT_URL , $ request -> getUrl ( ) ) ; $ options = $ request -> getOptions ( ) ; if ( ! empty ( $ options ) ) { curl_setopt_array ( $ this -> ch , $ options ) ; } $ method = $ request -> getMethod ( ) ; if ( $ method === 'post' ) { curl_setopt ( $ this -> ch , CURLOPT_POST , 1 ) ; } elseif ( $ method !== 'get' ) { curl_setopt ( $ this -> ch , CURLOPT_CUSTOMREQUEST , strtoupper ( $ method ) ) ; } curl_setopt ( $ this -> ch , CURLOPT_HTTPHEADER , $ request -> formatHeaders ( ) ) ; if ( $ this -> methods [ $ method ] === true ) { curl_setopt ( $ this -> ch , CURLOPT_POSTFIELDS , $ request -> encodeData ( ) ) ; } }
5120	private function requestGate ( string $ method , string $ path , array $ header = [ ] , array $ body = [ ] , array $ options = [ ] ) : string { if ( empty ( $ this -> accessToken ) ) { $ this -> renewAuthToken ( ) ; } $ request = new \ GuzzleHttp \ Psr7 \ Request ( $ method , $ path , array_merge ( $ this -> options -> get ( 'default_headers' ) , $ header ) , $ this -> createBodyForRequest ( $ this -> prepareMultipartData ( $ body ) ) ) ; return ( string ) $ this -> sendRequest ( $ request ) ; }
9089	public function viewBody ( ) { $ sticky_values = hypePrototyper ( ) -> prototype -> getStickyValues ( $ this -> action ) ; hypePrototyper ( ) -> prototype -> clearStickyValues ( $ this -> action ) ; $ validation_status = hypePrototyper ( ) -> prototype -> getValidationStatus ( $ this -> action ) ; hypePrototyper ( ) -> prototype -> clearValidationStatus ( $ this -> action ) ; $ i = 0 ; foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getInputView ( ) === false ) { continue ; } $ shortname = $ field -> getShortname ( ) ; if ( isset ( $ sticky_values [ $ shortname ] ) ) { $ field -> setStickyValue ( $ sticky_values [ $ shortname ] ) ; } if ( isset ( $ validation_status [ $ shortname ] ) ) { $ field -> setValidation ( $ validation_status [ $ shortname ] [ 'status' ] , $ validation_status [ $ shortname ] [ 'messages' ] ) ; } $ output .= $ field -> viewInput ( array ( 'index' => $ i , 'entity' => $ this -> entity , ) ) ; $ i ++ ; } $ submit = elgg_view ( 'prototyper/input/submit' , array ( 'entity' => $ this -> entity , 'action' => $ this -> action , ) ) ; $ output .= elgg_format_element ( 'div' , array ( 'class' => 'elgg-foot' , ) , $ submit ) ; return $ output ; }
1224	private function fillPathParams ( $ uri , array & $ paramValues ) { return preg_replace_callback ( '/{(\S+)}/U' , function ( $ matches ) use ( & $ paramValues ) { $ path = $ matches [ 1 ] ; if ( array_key_exists ( $ path , $ paramValues ) ) { $ value = $ paramValues [ $ path ] ; unset ( $ paramValues [ $ path ] ) ; } else { $ value = $ path ; } return $ value ; } , $ uri ) ; }
10050	public function resolve ( ) { if ( is_null ( $ this -> config -> getDisplayField ( ) ) || $ this -> config -> getDisplayField ( ) == '' ) { $ this -> config -> setDisplayField ( $ this -> resolveDisplayField ( ) ) ; $ this -> config -> setVisibleFields ( $ this -> resolveVisibleFields ( ) ) ; } return $ this -> config ; }
462	public function buildCondition ( $ condition , & $ params ) { if ( is_array ( $ condition ) ) { if ( empty ( $ condition ) ) { return '' ; } $ condition = $ this -> createConditionFromArray ( $ condition ) ; } if ( $ condition instanceof ExpressionInterface ) { return $ this -> buildExpression ( $ condition , $ params ) ; } return ( string ) $ condition ; }
6452	public function findLabels ( $ text ) { $ xpath = new XPath \ InaccurateText ( '//label[@for]' , $ this -> getWorkingElement ( ) ) ; $ labels = [ ] ; foreach ( $ xpath -> text ( $ text ) -> findAll ( ) as $ label ) { $ labels [ $ label -> getAttribute ( 'for' ) ] = $ label ; } return $ labels ; }
6854	private function findPaymentTokens ( PaymentInterface $ payment ) { $ identity = $ this -> getPaymentIdentity ( $ payment ) ; $ tokens = $ this -> payum -> getTokenStorage ( ) -> findBy ( [ 'details' => $ identity , ] ) ; return $ tokens ; }
4288	public function onError ( Event $ event ) { if ( $ event [ 'inConsole' ] || ! $ event [ 'isFirstOccur' ] ) { return ; } $ this -> processLogEntry ( 'errorNotConsoled' , array ( $ event [ 'typeStr' ] . ': ' . $ event [ 'file' ] . ' (line ' . $ event [ 'line' ] . '): ' . $ event [ 'message' ] ) , array ( 'channel' => 'phpError' , 'class' => $ event [ 'type' ] & $ this -> debug -> getCfg ( 'errorMask' ) ? 'danger' : 'warning' , ) ) ; }
7000	public function url ( $ url = null ) { if ( $ url ) $ this -> url = trim ( $ url ) ; return $ this -> url ; }
11191	public function routeProcess ( $ uri = false , $ httpMethod = false ) { if ( ! $ httpMethod ) $ httpMethod = $ _SERVER [ 'REQUEST_METHOD' ] ; $ this -> httpMethod = $ httpMethod ; if ( ! $ uri ) $ uri = $ _SERVER [ 'REQUEST_URI' ] ; $ this -> setPath ( $ uri ) ; $ customPathSearch = $ this -> customFind ( ) ; if ( $ customPathSearch || ( ! $ customPathSearch && $ this -> config [ 'automatic_routing' ] ) ) { $ this -> routeFind ( ) ; } else if ( $ customPathSearch == - 1 ) { $ this -> error ( '403' ) ; } }
12323	protected function askQuestions ( InputInterface $ input , OutputInterface $ output ) { foreach ( $ this -> questions as $ question ) { if ( ! $ question -> ask ( $ input , $ output ) ) { return static :: RETURN_ERROR ; } } return static :: RETURN_SUCCESS ; }
737	protected function saveToFile ( $ data , $ file ) { file_put_contents ( $ file , "<?php\nreturn " . VarDumper :: export ( $ data ) . ";\n" , LOCK_EX ) ; $ this -> invalidateScriptCache ( $ file ) ; }
408	public function get ( $ name = null , $ defaultValue = null ) { if ( $ name === null ) { return $ this -> getQueryParams ( ) ; } return $ this -> getQueryParam ( $ name , $ defaultValue ) ; }
9668	private function writePatternFill ( XMLWriter $ objWriter , Fill $ pFill ) { $ objWriter -> startElement ( 'fill' ) ; $ objWriter -> startElement ( 'patternFill' ) ; $ objWriter -> writeAttribute ( 'patternType' , $ pFill -> getFillType ( ) ) ; if ( $ pFill -> getFillType ( ) !== Fill :: FILL_NONE ) { if ( $ pFill -> getStartColor ( ) -> getARGB ( ) ) { $ objWriter -> startElement ( 'fgColor' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getStartColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } } if ( $ pFill -> getFillType ( ) !== Fill :: FILL_NONE ) { if ( $ pFill -> getEndColor ( ) -> getARGB ( ) ) { $ objWriter -> startElement ( 'bgColor' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getEndColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
11381	public function render ( FormInterface $ form ) { if ( method_exists ( $ form , 'prepare' ) ) { $ form -> prepare ( ) ; } if ( ! $ form -> getAttribute ( 'role' ) ) { $ form -> setAttribute ( 'role' , 'form' ) ; } $ formContent = '' ; foreach ( $ form as $ element ) { if ( $ element instanceof FieldsetInterface ) { $ formContent .= $ this -> getView ( ) -> formCollection ( $ element ) ; } else { $ element -> setOption ( '_form' , $ form ) ; $ formContent .= $ this -> getView ( ) -> formRow ( $ element ) ; } } return $ this -> openTag ( $ form ) . $ formContent . $ this -> closeTag ( ) ; }
9963	public function removeRow ( $ pRow , $ pNumRows = 1 ) { if ( $ pRow >= 1 ) { $ highestRow = $ this -> getHighestDataRow ( ) ; $ objReferenceHelper = ReferenceHelper :: getInstance ( ) ; $ objReferenceHelper -> insertNewBefore ( 'A' . ( $ pRow + $ pNumRows ) , 0 , - $ pNumRows , $ this ) ; for ( $ r = 0 ; $ r < $ pNumRows ; ++ $ r ) { $ this -> getCellCollection ( ) -> removeRow ( $ highestRow ) ; -- $ highestRow ; } } else { throw new Exception ( 'Rows to be deleted should at least start from row 1.' ) ; } return $ this ; }
12321	protected function prepareData ( InputInterface $ input ) { $ return = [ ] ; foreach ( $ this -> validators as $ validator ) { $ result = $ validator -> validate ( $ input ) ; if ( isset ( $ result ) && is_array ( $ result ) ) { $ return = NestedArray :: mergeDeep ( $ return , $ result ) ; } elseif ( isset ( $ result ) ) { $ return [ ] = $ result ; } } return $ return ; }
211	protected function hashPluginOptions ( $ view ) { $ encOptions = empty ( $ this -> clientOptions ) ? '{}' : Json :: htmlEncode ( $ this -> clientOptions ) ; $ this -> _hashVar = self :: PLUGIN_NAME . '_' . hash ( 'crc32' , $ encOptions ) ; $ this -> options [ 'data-plugin-' . self :: PLUGIN_NAME ] = $ this -> _hashVar ; $ view -> registerJs ( "var {$this->_hashVar} = {$encOptions};" , View :: POS_HEAD ) ; }
2227	public function editHeader ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> User -> canEditFieldsOf ( 'tl_faq_category' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
241	public function init ( ) { parent :: init ( ) ; if ( $ this -> model === null ) { throw new InvalidConfigException ( 'Please specify the "model" property.' ) ; } if ( $ this -> formatter === null ) { $ this -> formatter = Yii :: $ app -> getFormatter ( ) ; } elseif ( is_array ( $ this -> formatter ) ) { $ this -> formatter = Yii :: createObject ( $ this -> formatter ) ; } if ( ! $ this -> formatter instanceof Formatter ) { throw new InvalidConfigException ( 'The "formatter" property must be either a Format object or a configuration array.' ) ; } $ this -> normalizeAttributes ( ) ; if ( ! isset ( $ this -> options [ 'id' ] ) ) { $ this -> options [ 'id' ] = $ this -> getId ( ) ; } }
8032	public function validateDatesArray ( $ attribute , $ value , array $ parameters , Validator $ validator ) { foreach ( $ value as $ date ) { if ( false === strtotime ( $ date ) || empty ( $ date ) ) { return false ; } } return true ; }
11562	protected function getWeekWordsUnitsAndShortcuts ( $ lang ) { if ( ! isset ( $ this -> weekWords [ $ lang ] ) ) { if ( isset ( static :: $ WeekWordsDefault [ $ lang ] ) ) { $ this -> weekWords [ $ lang ] = explode ( ',' , static :: $ WeekWordsDefault [ $ lang ] ) ; } else { $ this -> weekWords [ $ lang ] = [ ] ; } } if ( ! $ this -> units ) $ this -> units = explode ( ',' , static :: $ UnitsDefault ) ; if ( ! isset ( $ this -> shortcuts [ $ lang ] ) ) { if ( isset ( static :: $ ShortcutsDefault [ $ lang ] ) ) { $ shortcuts = [ ] ; foreach ( static :: $ ShortcutsDefault [ $ lang ] as $ shortcutsLocalized ) foreach ( $ shortcutsLocalized as $ shortcut ) $ shortcuts [ $ shortcut ] = str_replace ( ' ' , '&nbsp;' , $ shortcut ) ; $ this -> shortcuts [ $ lang ] = & $ shortcuts ; } else { $ this -> shortcuts [ $ lang ] = [ ] ; } } return [ $ this -> weekWords [ $ lang ] , $ this -> units , $ this -> shortcuts [ $ lang ] ] ; }
6608	public static function getAllProvider ( $ relatedRecords = [ ] , $ sort = [ ] , $ limit = null ) { $ query = self :: find ( ) -> with ( $ relatedRecords ) -> orderBy ( $ sort ) ; return self :: convertToProvider ( $ query , [ ] , $ limit ) ; }
7477	public function downloadAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ file = $ em -> find ( 'Orkestra\Bundle\ApplicationBundle\Entity\File' , $ id ) ; if ( ! $ file ) { throw $ this -> createNotFoundException ( 'Unable to locate File' ) ; } $ securityContext = $ this -> get ( 'security.authorization_checker' ) ; foreach ( $ file -> getGroups ( ) as $ group ) { if ( ! $ securityContext -> isGranted ( $ group -> getRole ( ) ) ) { throw $ this -> createNotFoundException ( 'Unable to locate File' ) ; } } return new Response ( $ file -> getContent ( ) , 200 , array ( 'Content-Type' => $ file -> getMimeType ( ) , 'Content-Disposition' => sprintf ( 'attachment; filename="%s"' , $ file -> getFilename ( ) ) ) ) ; }
6593	protected function parseTags ( array $ bustersOfThisType , $ type ) { $ busterStrings = array ( ) ; foreach ( $ bustersOfThisType as $ fileName => $ hash ) { $ template = $ this -> config [ $ type . 'Template' ] ; $ rootPath = $ this -> config [ 'rootPath' ] ; $ pathInfo = pathInfo ( $ fileName ) ; $ fileBasePath = $ pathInfo [ 'dirname' ] ; $ fileBaseName = $ pathInfo [ 'filename' ] ; $ template = str_replace ( '{{ROOT_PATH}}' , $ rootPath , $ template ) ; $ template = str_replace ( '{{HASH}}' , $ hash , $ template ) ; $ template = str_replace ( '{{FILE_PATH}}' , $ fileBasePath , $ template ) ; $ template = str_replace ( '{{FILE_NAME}}' , $ fileBaseName , $ template ) ; $ busterStrings [ ] = $ template ; } return $ busterStrings ; }
4865	public function listing ( array $ options = [ ] ) { $ filter = [ 'queue' => $ this -> getName ( ) ] ; if ( isset ( $ options [ 'status' ] ) ) { $ filter [ 'status' ] = $ options [ 'status' ] ; } $ opt = [ 'sort' => [ 'scheduled' => 1 , 'priority' => 1 ] ] ; if ( isset ( $ options [ 'limit' ] ) ) { $ opt [ 'limit' ] = $ options [ 'limit' ] ; } $ cursor = $ this -> mongoCollection -> find ( $ filter , $ opt ) ; $ jobs = $ cursor -> toArray ( ) ; foreach ( $ jobs as & $ envelope ) { $ envelope [ 'job' ] = $ this -> unserializeJob ( $ envelope [ 'data' ] , [ '__id__' => $ envelope [ '_id' ] ] ) ; } return $ jobs ; }
12205	public function generate ( $ date = 'global' , Response $ response = null ) { if ( ! $ response ) $ response = new Response ; if ( $ this -> maxAge ) $ response -> setMaxAge ( $ this -> maxAge ) ; if ( $ this -> sharedMaxAge ) $ response -> setSharedMaxAge ( $ this -> sharedMaxAge ) ; if ( $ date instanceof \ DateTime ) { $ response -> setLastModified ( $ date ) ; } else { $ response -> setLastModified ( $ this -> manager -> getLastUpdate ( $ date ) ) ; } return $ response ; }
1402	public function getErrors ( ) { if ( ! is_null ( $ this -> errors ) ) { return collect ( $ this -> errors ) ; } try { $ this -> errors = $ this -> parse ( ) ; } catch ( \ Exception $ ex ) { $ this -> errors = [ ] ; } return collect ( $ this -> errors ) ; }
11598	private static function _getCacheObject ( ) { if ( self :: $ _sTypeOfCache === 'file' ) { if ( ! isset ( self :: $ _aCache [ 'file' ] ) ) { self :: $ _aCache [ 'file' ] = new CacheFile ; } return self :: $ _aCache [ 'file' ] ; } else if ( self :: $ _sTypeOfCache === 'memcache' ) { if ( ! isset ( self :: $ _aCache [ 'memcache' ] ) ) { $ oDbConf = Config :: get ( 'Memcache' ) -> configuration ; if ( isset ( $ oDbConf -> port ) ) { $ sPort = $ oDbConf -> port ; } else { $ sPort = null ; } if ( isset ( $ oDbConf -> timeout ) ) { $ iTimeout = $ oDbConf -> timeout ; } else { $ iTimeout = null ; } self :: $ _aCache [ 'memcache' ] = new CacheMemcache ( $ oDbConf -> host , $ sPort , $ iTimeout ) ; } return self :: $ _aCache [ 'memcache' ] ; } else if ( self :: $ _sTypeOfCache === 'apc' ) { if ( ! isset ( self :: $ _aCache [ 'apc' ] ) ) { self :: $ _aCache [ 'apc' ] = new Apc ; } return self :: $ _aCache [ 'apc' ] ; } else if ( self :: $ _sTypeOfCache === 'redis' ) { if ( ! isset ( self :: $ _aCache [ 'redis' ] ) ) { $ oDbConf = Config :: get ( 'Redis' ) -> configuration ; self :: $ _aCache [ 'memcache' ] = new Redis ( $ oDbConf ) ; } return self :: $ _aCache [ 'redis' ] ; } else if ( self :: $ _sTypeOfCache === 'mock' ) { if ( ! isset ( self :: $ _aCache [ 'mock' ] ) ) { self :: $ _aCache [ 'mock' ] = new Mock ; } return self :: $ _aCache [ 'mock' ] ; } }
8346	public static function route ( $ method , $ path , $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'route' , 'method' => $ method , 'path' => $ path , 'action' => $ action , 'namespace' => self :: $ namespace , 'subdomain' => self :: $ subdomain , 'uri' => self :: $ uri ) ; } }
1270	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ quantumViewRequest = $ xml -> appendChild ( $ xml -> createElement ( 'QuantumViewRequest' ) ) ; $ quantumViewRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; if ( null !== $ this -> name || null !== $ this -> beginDateTime || null !== $ this -> fileName ) { $ subscriptionRequest = $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'SubscriptionRequest' ) ) ; if ( null !== $ this -> name ) { $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'Name' , $ this -> name ) ) ; } if ( null !== $ this -> beginDateTime ) { $ dateTimeRange = $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'DateTimeRange' ) ) ; $ dateTimeRange -> appendChild ( $ xml -> createElement ( 'BeginDateTime' , $ this -> beginDateTime ) ) ; $ dateTimeRange -> appendChild ( $ xml -> createElement ( 'EndDateTime' , $ this -> endDateTime ) ) ; } elseif ( null !== $ this -> fileName ) { $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'FileName' , $ this -> fileName ) ) ; } } if ( null !== $ this -> bookmark ) { $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'Bookmark' , $ this -> bookmark ) ) ; } $ request = $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'QVEvents' ) ) ; return $ xml -> saveXML ( ) ; }
1202	public function buildItem ( ItemInterface $ item , array $ options ) { $ item -> setUri ( $ options [ 'uri' ] ) -> setLabel ( $ options [ 'label' ] ) -> setAttributes ( $ options [ 'attributes' ] ) -> setLinkAttributes ( $ options [ 'linkAttributes' ] ) -> setChildrenAttributes ( $ options [ 'childrenAttributes' ] ) -> setLabelAttributes ( $ options [ 'labelAttributes' ] ) -> setCurrent ( $ options [ 'current' ] ) -> setDisplay ( $ options [ 'display' ] ) -> setDisplayChildren ( $ options [ 'displayChildren' ] ) ; $ this -> buildExtras ( $ item , $ options ) ; }
5881	public function processUpload_postProcessAction ( & $ filename , DataHandler $ pObj ) { $ filename = static :: $ imageResizer -> processFile ( $ filename , '' , '' , null , $ GLOBALS [ 'BE_USER' ] , [ $ this , 'notify' ] ) ; }
9180	final public function getViewSettings ( ) { $ rf = new \ ReflectionClass ( $ this ) ; $ this -> viewName = str_replace ( 'View' , '' , $ rf -> getShortName ( ) ) ; $ matches = array ( ) ; if ( preg_match ( "#@applyTo\((.*)\)#" , $ rf -> getDocComment ( ) , $ matches ) ) { $ params = array ( ) ; parse_str ( str_replace ( ',' , '&' , $ matches [ 1 ] ) , $ params ) ; if ( is_array ( $ params ) ) { foreach ( $ params as $ param => $ value ) { if ( $ param == 'controller' ) { $ this -> controllers = explode ( '|' , $ value ) ; } if ( $ param == 'action' ) { $ this -> actions = explode ( '|' , $ value ) ; } } } } return $ this ; }
5866	protected function getIndexer ( \ TYPO3 \ CMS \ Core \ Resource \ ResourceStorage $ storage ) { return GeneralUtility :: makeInstance ( Indexer :: class , $ storage ) ; }
1042	private function printBlockString ( $ value , $ isDescription ) { $ escaped = str_replace ( '"""' , '\\"""' , $ value ) ; return ( $ value [ 0 ] === ' ' || $ value [ 0 ] === "\t" ) && strpos ( $ value , "\n" ) === false ? ( '"""' . preg_replace ( '/"$/' , "\"\n" , $ escaped ) . '"""' ) : ( '"""' . "\n" . ( $ isDescription ? $ escaped : $ this -> indent ( $ escaped ) ) . "\n" . '"""' ) ; }
1137	public function setDepthWithSubtree ( ) { $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ self -> descendantsAndSelf ( ) -> select ( $ self -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; $ oldDepth = ! is_null ( $ self -> getDepth ( ) ) ? $ self -> getDepth ( ) : 0 ; $ newDepth = $ self -> getLevel ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ self -> getKeyName ( ) , '=' , $ self -> getKey ( ) ) -> update ( array ( $ self -> getDepthColumnName ( ) => $ newDepth ) ) ; $ self -> setAttribute ( $ self -> getDepthColumnName ( ) , $ newDepth ) ; $ diff = $ newDepth - $ oldDepth ; if ( ! $ self -> isLeaf ( ) && $ diff != 0 ) $ self -> descendants ( ) -> increment ( $ self -> getDepthColumnName ( ) , $ diff ) ; } ) ; return $ this ; }
8996	protected function buildNamespace ( ApiDefinition $ definition , $ namespace ) { if ( $ this -> config [ 'version_in_namespace' ] && $ definition -> getVersion ( ) ) { $ namespace .= '\\' . preg_replace ( array ( '/(^[0-9])/' , '/[^a-zA-Z0-9]/' ) , array ( 'Version\1' , '_' ) , $ definition -> getVersion ( ) ) ; } return $ namespace ; }
704	public function setDefaultRoles ( $ roles ) { if ( is_array ( $ roles ) ) { $ this -> defaultRoles = $ roles ; } elseif ( $ roles instanceof \ Closure ) { $ roles = call_user_func ( $ roles ) ; if ( ! is_array ( $ roles ) ) { throw new InvalidValueException ( 'Default roles closure must return an array' ) ; } $ this -> defaultRoles = $ roles ; } else { throw new InvalidArgumentException ( 'Default roles must be either an array or a callable' ) ; } }
6845	public static function seconds ( $ step = 1 , $ start = 0 , $ end = 60 ) { $ step = ( int ) $ step ; $ seconds = array ( ) ; for ( $ i = $ start ; $ i < $ end ; $ i += $ step ) { $ seconds [ $ i ] = sprintf ( '%02d' , $ i ) ; } return $ seconds ; }
687	protected function getChildrenRecursive ( $ name , $ childrenList , & $ result ) { if ( isset ( $ childrenList [ $ name ] ) ) { foreach ( $ childrenList [ $ name ] as $ child ) { $ result [ $ child ] = true ; $ this -> getChildrenRecursive ( $ child , $ childrenList , $ result ) ; } } }
6192	protected function loadRoutes ( $ path ) { $ this -> app -> config [ 'router' ] [ 'routes' ] = array_merge ( $ this -> app -> config [ 'router' ] [ 'routes' ] ?? [ ] , ( require $ path ) [ 'routes' ] ) ; }
11647	function parseAndAddServiceFromFile ( $ serviceFilename ) { $ service = require $ serviceFilename ; if ( $ service == false ) { throw new APIBuilderException ( "Failed to open service file `$serviceFilename`." ) ; } if ( is_array ( $ service ) == false ) { throw new APIBuilderException ( "File `$serviceFilename` did not return a service array. Cannot build API from it." ) ; } $ this -> parseAndAddService ( $ service ) ; }
5248	public function find ( $ id ) { $ child = $ this -> childClassName ; $ model = $ child :: findWithParentId ( $ id , $ this -> parent -> getId ( ) ) ; if ( $ model ) { $ model -> setParent ( $ this -> parent ) ; } return $ model ; }
537	protected function updateDocComment ( $ doc , $ properties ) { $ lines = explode ( "\n" , $ doc ) ; $ propertyPart = false ; $ propertyPosition = false ; foreach ( $ lines as $ i => $ line ) { $ line = trim ( $ line ) ; if ( strncmp ( $ line , '* @property ' , 12 ) === 0 ) { $ propertyPart = true ; } elseif ( $ propertyPart && $ line == '*' ) { $ propertyPosition = $ i ; $ propertyPart = false ; } if ( strncmp ( $ line , '* @author ' , 10 ) === 0 && $ propertyPosition === false ) { $ propertyPosition = $ i - 1 ; $ propertyPart = false ; } if ( $ propertyPart ) { unset ( $ lines [ $ i ] ) ; } } if ( $ propertyPosition === false ) { $ propertyPosition = \ count ( $ lines ) - 2 ; } $ finalDoc = '' ; foreach ( $ lines as $ i => $ line ) { $ finalDoc .= $ line . "\n" ; if ( $ i == $ propertyPosition ) { $ finalDoc .= $ properties ; } } return $ finalDoc ; }
3411	public function format ( ) : string { foreach ( $ this -> times as $ unit => $ value ) { if ( $ this -> time >= $ value ) { $ time = floor ( $ this -> time / $ value * 100 ) / 100 ; return "{$time} {$unit}" ; } } return round ( $ this -> time * 1000 ) . " ms" ; }
5368	public function asMime ( ) { $ part = 'Content-Disposition: form-data; ' ; $ part .= 'name="' . $ this -> key . '"; ' ; $ part .= 'filename="' . $ this -> filename . '"' ; $ part .= "\r\nContent-Type: " . $ this -> deduceMimeType ( ) ; $ part .= "\r\n\r\n" . $ this -> content ; return $ part ; }
1853	public function onReplaceInsertTags ( string $ tag ) { $ chunks = explode ( '::' , $ tag ) ; if ( 'trans' !== $ chunks [ 0 ] ) { return false ; } $ parameters = isset ( $ chunks [ 3 ] ) ? explode ( ':' , $ chunks [ 3 ] ) : [ ] ; return $ this -> translator -> trans ( $ chunks [ 1 ] , $ parameters , $ chunks [ 2 ] ?? null ) ; }
8929	public function stack ( $ icons ) { if ( count ( $ icons ) !== 2 ) { throw new \ InvalidArgumentException ( 'Expecting exactly 2 icons in the stack' ) ; } $ contents = [ ] ; $ index = 2 ; foreach ( $ icons as $ key => $ value ) { $ contents [ ] = $ this -> getStackIconElement ( $ key , $ value , $ index ) ; -- $ index ; } return $ this -> html -> span ( $ contents ) -> addClass ( 'fa-stack' ) ; }
3532	public static function sendFortnitePostRequest ( $ endpoint , $ access_token , $ params = null ) { $ client = new Client ( ) ; try { $ response = $ client -> post ( $ endpoint , [ 'json' => $ params , 'headers' => [ 'User-Agent' => self :: FORTNITE_USER_AGENT , 'Authorization' => 'bearer ' . $ access_token ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
12841	static public function recursiveDelete ( $ path ) { if ( is_file ( $ path ) ) { return unlink ( $ path ) ; } $ scans = glob ( rtrim ( $ path , '/' ) . '/*' ) ; foreach ( $ scans as $ scan ) { self :: recursiveDelete ( $ scan ) ; } return rmdir ( $ path ) ; }
12114	protected function loadForeignDataItems ( ) { $ this -> _foreignDataItems = [ ] ; if ( $ this -> lazyForeign ) { $ primaryKeys = $ this -> foreignModel -> findPrimaryKeys ( $ this -> settings [ 'foreignPullParams' ] ) ; foreach ( $ primaryKeys as $ primaryKey ) { $ this -> createForeignDataItem ( null , [ 'foreignPrimaryKey' => $ primaryKey ] ) ; } } else { $ foreignModels = $ this -> foreignModel -> findAll ( $ this -> settings [ 'foreignPullParams' ] ) ; foreach ( $ foreignModels as $ key => $ model ) { $ this -> createForeignDataItem ( $ model , [ ] ) ; } } }
6719	private function handleAuthorizeResponse ( $ response ) { $ status = ArrayHelper :: getValue ( $ response , 'status' ) ; if ( ! is_null ( $ status ) && $ status == 'success' ) { $ code = ArrayHelper :: getValue ( $ response , 'data.code' ) ; if ( is_null ( $ code ) ) { throw new Oauth2ClientException ( self :: CODE_NOT_SET ) ; } return $ code ; } else { $ message = ArrayHelper :: getValue ( $ response , 'message' , self :: DEFAULT_ERROR ) ; throw new Oauth2ClientException ( $ message ) ; } }
8348	public function setValue ( string $ v ) : string { if ( static :: isValid ( $ v ) === false ) { throw new BadUse ( '"' . $ v . '" is not recognized as a possible value' ) ; } $ this -> value = $ v ; }
12660	public function removeAll ( ) { $ fs = $ this -> env -> getFileSystem ( ) ; $ fs -> deleteFile ( $ this -> baseDir . $ this -> pageName . '.js' ) ; $ fs -> deleteFile ( $ this -> outdatedDir . $ this -> baseLang . '/' . $ this -> pageName . '.json' ) ; foreach ( $ this -> extraLangs as $ language ) { $ fs -> deleteFile ( $ this -> baseDir . $ language . '/' . $ this -> pageName . '.js' ) ; $ fs -> deleteFile ( $ this -> outdatedDir . $ language . '/' . $ this -> pageName . '.json' ) ; } }
11114	public function rollback ( array $ options = [ ] ) : void { $ migrations = $ this -> getMigrationsForRollback ( $ options ) ; if ( count ( $ migrations ) === 0 ) { $ this -> notify -> note ( '<info>Nothing to rollback.</info>' ) ; return ; } $ this -> rollbackMigrations ( $ migrations ) ; }
4584	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ this -> accessor -> setValue ( $ data , $ this -> property , $ this -> getSignature ( ) ) ; $ event -> setData ( $ data ) ; }
5203	public function close ( ) { if ( isset ( $ this -> channel ) ) $ this -> channel -> close ( ) ; if ( isset ( $ this -> AMQPConnection ) ) $ this -> AMQPConnection -> close ( ) ; }
5476	protected function encode ( ) { $ class = $ this -> encoding ; $ encoding = new $ class ( ) ; for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { $ this -> widgets [ $ i ] -> write ( $ encoding ) ; } return $ encoding ; }
5448	public function acceptStartToken ( $ token , $ event ) { if ( $ event == LEXER_ENTER ) { $ this -> tag = strtolower ( substr ( $ token , 1 ) ) ; return true ; } if ( $ event == LEXER_EXIT ) { $ success = $ this -> listener -> startElement ( $ this -> tag , $ this -> attributes ) ; $ this -> tag = '' ; $ this -> attributes = array ( ) ; return $ success ; } if ( $ token !== '=' ) { $ this -> current_attribute = strtolower ( html_entity_decode ( $ token , ENT_QUOTES ) ) ; $ this -> attributes [ $ this -> current_attribute ] = '' ; } return true ; }
11353	private function compress ( $ dwnlSnap , $ pv , $ calcId ) { $ in = new \ Praxigento \ Core \ Data ( ) ; $ in -> set ( PPhase1 :: IN_DWNL_PLAIN , $ dwnlSnap ) ; $ in -> set ( PPhase1 :: IN_PV , $ pv ) ; $ in -> set ( PPhase1 :: IN_CALC_ID , $ calcId ) ; $ in -> set ( PPhase1 :: IN_KEY_CALC_ID , EBonDwnl :: A_CALC_REF ) ; $ in -> set ( PPhase1 :: IN_KEY_CUST_ID , QBSnap :: A_CUST_ID ) ; $ in -> set ( PPhase1 :: IN_KEY_PARENT_ID , QBSnap :: A_PARENT_ID ) ; $ in -> set ( PPhase1 :: IN_KEY_DEPTH , QBSnap :: A_DEPTH ) ; $ in -> set ( PPhase1 :: IN_KEY_PATH , QBSnap :: A_PATH ) ; $ in -> set ( PPhase1 :: IN_KEY_PV , EBonDwnl :: A_PV ) ; $ out = $ this -> procPhase1 -> exec ( $ in ) ; $ updates = $ out -> get ( PPhase1 :: OUT_COMPRESSED ) ; $ pvTransfers = $ out -> get ( PPhase1 :: OUT_PV_TRANSFERS ) ; $ result = [ $ updates , $ pvTransfers ] ; return $ result ; }
3571	public function queryHook ( ) { return function ( $ next , $ query , $ bag ) { $ method = $ bag -> get ( 'method' ) ; $ args = $ bag -> get ( 'args' ) ; $ column = $ args -> get ( 'column' ) ; if ( ! $ this -> hasColumn ( $ column ) && $ this -> allowsMeta ( $ column ) && $ this -> isMetaQueryable ( $ method ) ) { return call_user_func_array ( [ $ this , 'metaQuery' ] , [ $ query , $ method , $ args ] ) ; } if ( in_array ( $ method , [ 'select' , 'addSelect' ] ) ) { call_user_func_array ( [ $ this , 'metaSelect' ] , [ $ query , $ args ] ) ; } return $ next ( $ query , $ bag ) ; } ; }
8017	public function fileExists ( $ name ) { $ http = new \ Guzzle \ Http \ Client ( ) ; try { $ response = $ http -> get ( $ this -> getUrl ( $ name ) ) -> send ( ) ; } catch ( ClientErrorResponseException $ e ) { return false ; } return $ response -> isSuccessful ( ) ; }
1088	private static function getFieldDefinition ( Schema $ schema , Type $ parentType , FieldNode $ fieldNode ) { $ name = $ fieldNode -> name -> value ; $ schemaMeta = Introspection :: schemaMetaFieldDef ( ) ; if ( $ name === $ schemaMeta -> name && $ schema -> getQueryType ( ) === $ parentType ) { return $ schemaMeta ; } $ typeMeta = Introspection :: typeMetaFieldDef ( ) ; if ( $ name === $ typeMeta -> name && $ schema -> getQueryType ( ) === $ parentType ) { return $ typeMeta ; } $ typeNameMeta = Introspection :: typeNameMetaFieldDef ( ) ; if ( $ name === $ typeNameMeta -> name && $ parentType instanceof CompositeType ) { return $ typeNameMeta ; } if ( $ parentType instanceof ObjectType || $ parentType instanceof InterfaceType ) { $ fields = $ parentType -> getFields ( ) ; return $ fields [ $ name ] ?? null ; } return null ; }
2087	public static function getDefaultPath ( $ template , $ format ) { $ file = $ template . '.' . $ format ; $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ files [ $ template ] ) ) { return $ rootDir . '/' . self :: $ files [ $ template ] . '/' . $ file ; } $ strPath = null ; try { foreach ( $ container -> get ( 'contao.resource_finder' ) -> findIn ( 'templates' ) -> name ( $ file ) as $ file ) { $ strPath = $ file -> getPathname ( ) ; } } catch ( \ InvalidArgumentException $ e ) { } if ( $ strPath !== null ) { return $ strPath ; } throw new \ Exception ( 'Could not find template "' . $ template . '"' ) ; }
6353	public static function tryFind ( Iterator $ iterator , callable $ predicate ) : Optional { return Optional :: ofNullable ( self :: find ( $ iterator , $ predicate ) ) ; }
9284	private function checkImports ( $ lessPath , $ cssPath , $ callback ) { static $ needsRecompile = false ; if ( $ needsRecompile ) return $ needsRecompile ; $ lessContent = file_get_contents ( $ lessPath ) ; preg_match_all ( '/(?<=@import)\s+"([^"]+)/im' , $ lessContent , $ imports ) ; foreach ( $ imports [ 1 ] as $ import ) { $ importPath = realpath ( dirname ( $ lessPath ) . DIRECTORY_SEPARATOR . $ import ) ; if ( file_exists ( $ importPath ) ) { if ( $ callback ( $ importPath , $ cssPath ) ) { $ needsRecompile = true ; break ; } else $ needsRecompile = $ this -> checkImports ( $ importPath , $ cssPath , $ callback ) ; } } return $ needsRecompile ; }
7524	function parse_all ( ) { $ this -> errors = array ( ) ; $ this -> status [ 'last_pos' ] = - 1 ; if ( ( $ this -> token === self :: TOK_TAG_OPEN ) || ( $ this -> next_pos ( '<' , false ) === self :: TOK_UNKNOWN ) ) { do { if ( ! $ this -> parse_tag ( ) ) { return false ; } } while ( $ this -> next_pos ( '<' ) !== self :: TOK_NULL ) ; } $ this -> pos = $ this -> size ; $ this -> parse_text ( ) ; return true ; }
11483	public function getFactory ( $ class , array $ params = array ( ) ) { if ( ! isset ( $ this -> factories [ $ class ] ) && $ this -> autowire ) { $ this -> factories [ $ class ] = Definition :: getDefaultForClass ( $ class ) ; } $ factory = $ this -> factories [ $ class ] ; if ( $ params ) { $ factory = $ factory -> getFactory ( $ params ) ; } return $ factory ; }
11770	public function switchTo ( NodeConnectionInterface $ connection ) { if ( $ connection && $ connection === $ this -> current ) { return ; } if ( $ connection !== $ this -> master && ! in_array ( $ connection , $ this -> slaves , true ) ) { throw new \ InvalidArgumentException ( 'Invalid connection or connection not found.' ) ; } $ connection -> connect ( ) ; if ( $ this -> current ) { $ this -> current -> disconnect ( ) ; } $ this -> current = $ connection ; }
8216	private function getNextJob ( $ tube , $ state ) { if ( 'ready' == $ this -> state ) { return $ this -> reserveJob ( $ tube ) ; } return $ this -> peekJob ( $ tube , $ state ) ; }
6485	private function isUsingStandardPort ( ) : bool { return $ this -> port === null || ( ( $ this -> scheme === 'http' && $ this -> port === 80 ) || ( $ this -> scheme === 'https' && $ this -> port === 443 ) ) ; }
4116	public function getBlockPath ( Mage_Core_Block_Abstract $ block ) { $ blockPath = array ( ) ; $ step = $ block -> getParentBlock ( ) ; $ i = 0 ; while ( $ i ++ < 20 && $ step instanceof Mage_Core_Block_Abstract ) { $ blockPath [ ] = $ this -> getBlockInfo ( $ step , false ) ; $ step = $ step -> getParentBlock ( ) ; } return $ blockPath ; }
5010	public function getPermissions ( ) { if ( ! $ this -> permissions ) { $ type = property_exists ( $ this , 'permissionsType' ) ? $ this -> permissionsType : str_replace ( '\\Entity\\' , '/' , static :: class ) ; $ permissions = new Permissions ( $ type ) ; if ( method_exists ( $ this , 'setupPermissions' ) ) { $ this -> setupPermissions ( $ permissions ) ; } $ this -> setPermissions ( $ permissions ) ; } return $ this -> permissions ; }
2408	public function flushAllData ( ) { @ trigger_error ( 'Using Template::flushAllData() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ function_exists ( 'fastcgi_finish_request' ) ) { fastcgi_finish_request ( ) ; } elseif ( PHP_SAPI !== 'cli' ) { $ status = ob_get_status ( true ) ; $ level = \ count ( $ status ) ; while ( $ level -- > 0 && ( ! empty ( $ status [ $ level ] [ 'del' ] ) || ( isset ( $ status [ $ level ] [ 'flags' ] ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_REMOVABLE ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_FLUSHABLE ) ) ) ) { ob_end_flush ( ) ; } flush ( ) ; } }
10655	public function groupBy ( $ func ) { $ ret = array ( ) ; $ it = $ this -> getIterator ( ) ; while ( $ it -> valid ( ) ) { if ( is_object ( $ it -> current ( ) ) ) { $ key = call_user_func ( $ func , $ it -> current ( ) ) ; } else { $ value = $ it -> current ( ) ; $ key = call_user_func_array ( $ func , array ( & $ value ) ) ; $ it -> offsetSet ( $ it -> key ( ) , $ value ) ; unset ( $ value ) ; } if ( is_array ( $ key ) ) { $ ref = & $ ret ; foreach ( $ key as $ subkey ) { if ( ! array_key_exists ( $ subkey , $ ref ) ) { $ ref [ $ subkey ] = array ( ) ; } $ ref = & $ ref [ $ subkey ] ; } $ ref [ ] = $ it -> current ( ) ; } else { $ ret [ $ key ] [ ] = $ it -> current ( ) ; } $ it -> next ( ) ; } unset ( $ ref ) ; $ ret = new self ( $ ret ) ; $ this -> exchangeArray ( $ ret -> getArrayCopy ( ) ) ; return $ this ; }
10708	public function getMany ( $ columns = [ '*' ] , $ paginated = false , $ perPage = null ) { $ results = $ paginated ? $ this -> getManyPaginated ( $ perPage , $ columns ) : $ this -> getQuery ( ) -> get ( $ columns ) ; return $ this -> returnResults ( $ results ) ; }
11189	public static function json ( $ jsonStr , $ k = null , $ default = null ) { $ json = json_decode ( $ jsonStr , true ) ; if ( $ k && $ json ) { return self :: get ( $ json , $ k , $ default ) ; } return $ json ; }
505	public function init ( ) { parent :: init ( ) ; if ( ! isset ( $ this -> translations [ 'yii' ] ) && ! isset ( $ this -> translations [ 'yii*' ] ) ) { $ this -> translations [ 'yii' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => 'en-US' , 'basePath' => '@yii/messages' , ] ; } if ( ! isset ( $ this -> translations [ 'app' ] ) && ! isset ( $ this -> translations [ 'app*' ] ) ) { $ this -> translations [ 'app' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => Yii :: $ app -> sourceLanguage , 'basePath' => '@app/messages' , ] ; } }
10385	protected static function unify_params ( $ type , $ field , $ default = '' ) { $ data = array_column ( self :: $ data [ $ type ] , $ field ) ; switch ( $ field ) { case 'media' : case 'footer' : case 'version' : foreach ( $ data as $ key => $ value ) { if ( $ data [ 0 ] !== $ value ) { return $ default ; } } return ( isset ( $ data [ 0 ] ) && $ data [ 0 ] ) ? $ data [ 0 ] : $ default ; default : $ params = [ ] ; foreach ( $ data as $ key => $ value ) { $ params = array_merge ( $ params , $ value ) ; } return array_unique ( $ params ) ; } }
9497	protected function getOne ( $ end_point ) { $ end_point = strtolower ( $ end_point ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ request = $ this -> api -> get ( $ end_point ) ; $ response = $ this -> processRequest ( $ request ) ; $ result = $ response -> json ( ) ; $ type = $ this -> getType ( ) ; $ className = explode ( '\\' , $ type ) ; $ baseName = strtolower ( end ( $ className ) ) ; if ( $ result && isset ( $ result [ $ baseName ] ) ) { $ t = new $ type ( ) ; $ t -> setManagingClient ( $ this ) ; return $ t -> fromArray ( $ result [ $ baseName ] ) ; } return null ; }
12935	protected function resolveMoveOptions ( array $ options ) { if ( $ this -> optionsResolved ) { return ; } $ this -> optionsResolver -> clear ( ) ; $ this -> optionsResolver -> setRequired ( array ( 'page' , 'language' , 'country' , 'sourceSlot' , 'position' , ) ) ; $ this -> optionsResolver -> setDefined ( array ( 'targetSlot' , 'blockname' , 'oldName' , 'newName' , 'slot' , ) ) ; $ this -> optionsResolver -> resolve ( $ options ) ; $ this -> optionsResolved = true ; }
10903	public function delete ( ) : bool { return ( bool ) $ this -> medoo -> delete ( $ this -> getTable ( ) , [ 'id' => $ this -> getId ( ) ] ) ; }
9515	private function _initLoggerCascade ( $ configFile , $ loggerName ) { $ err = '' ; try { $ fs = $ this -> _obm -> get ( Filesystem :: class ) ; if ( $ fs -> isAbsolutePath ( $ configFile ) ) { $ fileName = $ configFile ; } else { $ fileName = BP . '/' . $ configFile ; } $ realPath = realpath ( $ fileName ) ; if ( $ realPath ) { Cascade :: fileConfig ( $ realPath ) ; $ this -> _logger = Cascade :: getLogger ( $ loggerName ) ; } else { $ err = "Cannot open logging configuration file '$fileName'. Default Magento logger is used." ; } } catch ( \ Exception $ e ) { $ err = $ e -> getMessage ( ) ; } finally { if ( is_null ( $ this -> _logger ) ) { $ this -> _logger = $ this -> _obm -> get ( \ Magento \ Framework \ Logger \ Monolog :: class ) ; $ this -> warning ( $ err ) ; } } }
4193	protected function dumpProperties ( $ abs ) { $ label = \ count ( $ abs [ 'properties' ] ) ? 'properties' : 'no properties' ; if ( $ abs [ 'viaDebugInfo' ] ) { $ label .= ' <span class="text-muted">(via __debugInfo)</span>' ; } $ str = '<dt class="properties">' . $ label . '</dt>' . "\n" ; $ magicMethods = \ array_intersect ( array ( '__get' , '__set' ) , \ array_keys ( $ abs [ 'methods' ] ) ) ; $ str .= $ this -> magicMethodInfo ( $ magicMethods ) ; foreach ( $ abs [ 'properties' ] as $ k => $ info ) { $ vis = ( array ) $ info [ 'visibility' ] ; $ isPrivateAncestor = \ in_array ( 'private' , $ vis ) && $ info [ 'inheritedFrom' ] ; $ classes = \ array_keys ( \ array_filter ( array ( 'debuginfo-value' => $ info [ 'valueFrom' ] == 'debugInfo' , 'excluded' => $ info [ 'isExcluded' ] , 'forceShow' => $ info [ 'forceShow' ] , 'debug-value' => $ info [ 'valueFrom' ] == 'debug' , 'private-ancestor' => $ isPrivateAncestor , 'property' => true , \ implode ( ' ' , $ vis ) => $ info [ 'visibility' ] !== 'debug' , ) ) ) ; $ modifiers = $ vis ; if ( $ info [ 'isStatic' ] ) { $ modifiers [ ] = 'static' ; } $ str .= '<dd class="' . \ implode ( ' ' , $ classes ) . '">' . \ implode ( ' ' , \ array_map ( function ( $ modifier ) { return '<span class="t_modifier_' . $ modifier . '">' . $ modifier . '</span>' ; } , $ modifiers ) ) . ( $ isPrivateAncestor ? ' (<i>' . $ info [ 'inheritedFrom' ] . '</i>)' : '' ) . ( $ info [ 'type' ] ? ' <span class="t_type">' . $ info [ 'type' ] . '</span>' : '' ) . ' <span class="property-name"' . ' title="' . \ htmlspecialchars ( $ info [ 'desc' ] ) . '"' . '>' . $ k . '</span>' . ( $ info [ 'value' ] !== $ this -> debug -> abstracter -> UNDEFINED ? ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ info [ 'value' ] ) : '' ) . '</dd>' . "\n" ; } return $ str ; }
1783	protected function countItems ( $ newsArchives , $ blnFeatured ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] as $ callback ) { if ( ( $ intResult = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ newsArchives , $ blnFeatured , $ this ) ) === false ) { continue ; } if ( \ is_int ( $ intResult ) ) { return $ intResult ; } } } return NewsModel :: countPublishedByPids ( $ newsArchives , $ blnFeatured ) ; }
1266	private function createRecoverLabelRequest ( $ trackingData , $ labelSpecificationOpts = null , $ labelDeliveryOpts = null , $ translateOpts = null ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ container = $ xml -> appendChild ( $ xml -> createElement ( 'LabelRecoveryRequest' ) ) ; $ request = $ container -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LabelRecovery' ) ) ; if ( is_string ( $ trackingData ) ) { $ container -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ trackingData ) ) ; } elseif ( is_array ( $ trackingData ) ) { $ referenceNumber = $ container -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) ; $ referenceNumber -> appendChild ( $ xml -> createElement ( 'Value' , $ trackingData [ 'value' ] ) ) ; $ container -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ trackingData [ 'shipperNumber' ] ) ) ; } if ( ! empty ( $ labelSpecificationOpts ) ) { $ labelSpec = $ request -> appendChild ( $ xml -> createElement ( 'LabelSpecification' ) ) ; if ( isset ( $ labelSpecificationOpts [ 'userAgent' ] ) ) { $ labelSpec -> appendChild ( $ xml -> createElement ( 'HTTPUserAgent' , $ labelSpecificationOpts [ 'userAgent' ] ) ) ; } if ( isset ( $ labelSpecificationOpts [ 'imageFormat' ] ) ) { $ format = $ labelSpec -> appendChild ( $ xml -> createElement ( 'LabelImageFormat' ) ) ; $ format -> appendChild ( $ xml -> createElement ( 'Code' , $ labelSpecificationOpts [ 'imageFormat' ] ) ) ; } } if ( ! empty ( $ labelDeliveryOpts ) ) { $ labelDelivery = $ request -> appendChild ( $ xml -> createElement ( 'LabelDelivery' ) ) ; $ labelDelivery -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' , $ labelDeliveryOpts [ 'link' ] ) ) ; } if ( ! empty ( $ translateOpts ) ) { $ translate = $ request -> appendChild ( $ xml -> createElement ( 'Translate' ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'LanguageCode' , $ translateOpts [ 'language' ] ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'DialectCode' , $ translateOpts [ 'dialect' ] ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'Code' , '01' ) ) ; } return $ xml -> saveXML ( ) ; }
11400	public function fromData ( $ data ) { $ this -> fromdata = $ data ; $ resource = fopen ( 'php://memory' , 'r+' ) ; fwrite ( $ resource , $ data ) ; rewind ( $ resource ) ; $ this -> setResource ( $ resource ) ; return $ this ; }
3995	public function replaceTags ( $ strTag ) { $ arrElements = explode ( '::' , $ strTag ) ; if ( $ arrElements [ 0 ] != 'mm' ) { return false ; } try { switch ( $ arrElements [ 1 ] ) { case 'total' : return $ this -> getCount ( $ arrElements [ 2 ] , $ arrElements [ 3 ] ) ; case 'attribute' : return $ this -> getAttribute ( $ arrElements [ 2 ] , $ arrElements [ 3 ] , $ arrElements [ 4 ] , $ arrElements [ 5 ] ) ; case 'item' : return $ this -> getItem ( $ arrElements [ 2 ] , $ arrElements [ 3 ] , $ arrElements [ 4 ] , $ arrElements [ 5 ] ) ; case 'jumpTo' : return $ this -> jumpTo ( $ arrElements [ 2 ] , $ arrElements [ 3 ] , $ arrElements [ 4 ] , $ arrElements [ 5 ] ) ; default : } } catch ( \ Exception $ exc ) { System :: log ( 'Error by replace tags: ' . $ exc -> getMessage ( ) , __CLASS__ . ' | ' . __FUNCTION__ , TL_ERROR ) ; } return false ; }
9733	public function setARGB ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: COLOR_BLACK ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'argb' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> argb = $ pValue ; } return $ this ; }
8029	public function registerFreeProcessId ( $ pid ) { $ processDetails = $ this -> getProcessDetails ( $ pid ) ; if ( $ processDetails !== NULL ) { $ this -> registerFreeProcess ( $ processDetails ) ; } return $ this ; }
6289	public function set ( $ theme ) { if ( ! $ this -> has ( $ theme ) ) { throw new ThemeNotFoundException ( $ theme ) ; } $ this -> loadTheme ( $ theme ) ; }
7146	public function save_custom_profile_fields ( $ user_id ) { if ( 'POST' !== $ _SERVER [ 'REQUEST_METHOD' ] || ! isset ( $ _POST [ 'iac_nonce' ] ) ) { return ; } if ( ! wp_verify_nonce ( $ _POST [ 'iac_nonce' ] , 'iac_user_settings' ) ) { return ; } do_action ( 'iac_save_user_settings' , $ user_id , isset ( $ _POST [ 'post_subscription' ] ) ? $ _POST [ 'post_subscription' ] : NULL , isset ( $ _POST [ 'comment_subscription' ] ) ? $ _POST [ 'comment_subscription' ] : NULL ) ; }
8637	public function setOrderFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7249	protected function validateShipmentMethodRequirements ( SaleInterface $ sale , Constraint $ constraint ) { if ( null === $ method = $ sale -> getShipmentMethod ( ) ) { return ; } if ( $ sale -> isSameAddress ( ) ) { $ address = $ sale -> getInvoiceAddress ( ) ; $ path = 'invoiceAddress' ; } else { $ address = $ sale -> getDeliveryAddress ( ) ; $ path = 'deliveryAddress' ; } if ( null === $ address ) { return ; } $ gateway = $ this -> gatewayRegistry -> getGateway ( $ method -> getGatewayName ( ) ) ; if ( $ gateway -> requires ( Gateway \ GatewayInterface :: REQUIREMENT_MOBILE ) ) { if ( is_null ( $ address -> getMobile ( ) ) ) { $ this -> context -> buildViolation ( $ constraint -> shipment_method_require_mobile ) -> atPath ( $ path . '.mobile' ) -> addViolation ( ) ; } } }
12504	public static function rollbackTransaction ( $ connection ) { $ connection -> query = 'ROLLBACK' ; $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; return self :: sendQuery ( $ connection ) ; }
2152	public function synchronize ( $ varValue , $ objUser , $ objModule = null ) { if ( $ objUser === null ) { return $ varValue ; } $ blnIsFrontend = true ; if ( $ objUser instanceof DataContainer ) { $ objUser = $ this -> Database -> prepare ( "SELECT * FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ objUser -> id ) ; if ( $ objUser -> numRows < 1 ) { return $ varValue ; } $ blnIsFrontend = false ; } if ( $ varValue == $ objUser -> newsletter || $ objUser -> email == '' ) { return $ varValue ; } $ time = time ( ) ; $ varValue = StringUtil :: deserialize ( $ varValue , true ) ; if ( $ blnIsFrontend && $ objModule instanceof Module ) { $ arrChannel = StringUtil :: deserialize ( $ objModule -> newsletters , true ) ; } else { $ arrChannel = $ this -> Database -> query ( "SELECT id FROM tl_newsletter_channel" ) -> fetchEach ( 'id' ) ; } $ arrDelete = array_values ( array_diff ( $ arrChannel , $ varValue ) ) ; if ( ! empty ( $ arrDelete ) && \ is_array ( $ arrDelete ) ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrDelete ) ) . ") AND email=?" ) -> execute ( $ objUser -> email ) ; } foreach ( $ varValue as $ intId ) { $ intId = ( int ) $ intId ; if ( $ intId < 1 ) { continue ; } $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE pid=? AND email=?" ) -> execute ( $ intId , $ objUser -> email ) ; if ( $ objRecipient -> count < 1 ) { $ this -> Database -> prepare ( "INSERT INTO tl_newsletter_recipients SET pid=?, tstamp=$time, email=?, active=?, addedOn=?" ) -> execute ( $ intId , $ objUser -> email , ( $ objUser -> disable ? '' : 1 ) , ( $ blnIsFrontend ? $ time : '' ) ) ; } } return serialize ( $ varValue ) ; }
8034	private function buildAttributesFromLdap ( $ entry ) { $ this -> attributes [ 'dn' ] = $ entry [ 'dn' ] ; foreach ( $ entry as $ index => $ key ) { if ( array_key_exists ( $ index , config ( 'ldap.search_fields' ) ) ) { $ this -> attributes [ $ key ] = isset ( $ entry [ $ key ] [ 1 ] ) ? $ entry [ $ key ] : $ entry [ $ key ] [ 0 ] ; } } ; }
848	public function getNonWhitespaceSibling ( $ index , $ direction , $ whitespaces = null ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } $ token = $ this [ $ index ] ; if ( ! $ token -> isWhitespace ( $ whitespaces ) ) { return $ index ; } } }
7717	function FileGetState ( $ NameOrIdx ) { $ idx = $ this -> FileGetIdx ( $ NameOrIdx ) ; if ( $ idx === false ) { $ idx = $ this -> FileGetIdxAdd ( $ NameOrIdx ) ; if ( $ idx === false ) { return false ; } else { return 'a' ; } } elseif ( isset ( $ this -> ReplInfo [ $ idx ] ) ) { if ( $ this -> ReplInfo [ $ idx ] === false ) { return 'd' ; } else { return 'm' ; } } else { return 'u' ; } }
2653	public function updateSnippet ( array $ snippet ) { $ url = $ this -> _getApiServiceUri ( ) . 'snippet' . '/' . $ snippet [ 'name' ] ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ snippet ) ; return $ result ; }
8608	public function registerDestination ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_RegisterDestinationInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/RegisterDestinationInput.php' ) ; $ request = new MWSSubscriptionsService_Model_RegisterDestinationInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'RegisterDestination' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/RegisterDestinationResponse.php' ) ; $ response = MWSSubscriptionsService_Model_RegisterDestinationResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3801	public function getCache ( ) { @ trigger_error ( '"' . __METHOD__ . '" is deprecated as the service container will get removed.' , E_USER_DEPRECATED ) ; if ( \ is_callable ( $ this -> cache ) ) { $ this -> cache = \ call_user_func ( $ this -> cache ) ; } return $ this -> cache ; }
1452	protected function createValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) : ValidatorInterface { return $ this -> factory -> createDeleteValidator ( $ data , $ rules , $ messages , $ customAttributes ) ; }
6960	public static function dt ( AstroDate $ dt ) { $ epoch = new static ( $ dt -> toTT ( ) -> toJD ( ) ) ; $ epoch -> dt = $ dt -> copy ( ) ; return $ epoch ; }
442	public function hasEventHandlers ( $ name ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( ! empty ( $ handlers ) && StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { return true ; } } return ! empty ( $ this -> _events [ $ name ] ) || Event :: hasHandlers ( $ this , $ name ) ; }
