2703	function extensionCommand ( shell , args , data , evaluationId ) { var deferred = shell . runtime . q . defer ( ) ; var name = args . name ; var moduleName = 'ijs.ext.' + name ; var modulePath = args . path || moduleName ; installer . install ( modulePath , shell . config . userPath , true , function ( error ) { if ( error ) { deferred . reject ( shell . createError ( 'Unable to install extension module "%s"' , moduleName ) ) ; } else { var extensionPath = path . join ( shell . config . userPath , 'node_modules' , moduleName ) ; var extension = require ( extensionPath ) ; try { extension . initialize ( shell , function ( error , result ) { if ( error ) { deferred . reject ( shell . createError ( 'Error initializing extension' ) ) ; } else { shell . loadedExtensions [ name ] = true ; deferred . resolve ( result ) ; } } ) ; } catch ( e ) { deferred . reject ( shell . createError ( 'Error initializing extension' ) ) ; } } } ) return deferred . promise ; }
1026	function Discover ( userAddress ) { return new Promise ( ( resolve , reject ) => { if ( userAddress in cachedInfo ) { return resolve ( cachedInfo [ userAddress ] ) ; } var webFinger = new WebFinger ( { tls_only : false , uri_fallback : true , request_timeout : 5000 } ) ; return webFinger . lookup ( userAddress , function ( err , response ) { if ( err ) { return reject ( err ) ; } else if ( ( typeof response . idx . links . remotestorage !== 'object' ) || ( typeof response . idx . links . remotestorage . length !== 'number' ) || ( response . idx . links . remotestorage . length <= 0 ) ) { log ( "[Discover] WebFinger record for " + userAddress + " does not have remotestorage defined in the links section " , JSON . stringify ( response . json ) ) ; return reject ( "WebFinger record for " + userAddress + " does not have remotestorage defined in the links section." ) ; } var rs = response . idx . links . remotestorage [ 0 ] ; var authURL = rs . properties [ 'http://tools.ietf.org/html/rfc6749#section-4.2' ] || rs . properties [ 'auth-endpoint' ] ; var storageApi = rs . properties [ 'http://remotestorage.io/spec/version' ] || rs . type ; cachedInfo [ userAddress ] = { href : rs . href , storageApi : storageApi , authURL : authURL , properties : rs . properties } ; if ( hasLocalStorage ) { localStorage [ SETTINGS_KEY ] = JSON . stringify ( { cache : cachedInfo } ) ; } return resolve ( cachedInfo [ userAddress ] ) ; } ) ; } ) ; }
969	function makeArrayObservable ( arr , observer , proxyArrApis ) { Object . keys ( proxyArrApis ) . forEach ( method => { let rawMethod = arr [ method ] ; arr [ method ] = proxyArrApis [ method ] . bind ( arr , observer , rawMethod ) ; } ) ; arr . setItem = updateArrayItem . bind ( arr , observer ) ; arr . getItem = getArrayItem . bind ( arr , observer ) ; return arr ; }
3378	function ( ) { var items = this . getFilterItems ( ) , filters = [ ] , n , nlen , item , d , i , len ; for ( n = 0 , nlen = items . length ; n < nlen ; n ++ ) { item = items [ n ] ; if ( item . active ) { d = [ ] . concat ( item . serialize ( ) ) ; for ( i = 0 , len = d . length ; i < len ; i ++ ) { filters . push ( { field : item . dataIndex , data : d [ i ] } ) ; } } } return filters ; }
3184	function read ( ) { const TLS_CERT = process . env . TLS_CERT ; const TLS_KEY = process . env . TLS_KEY ; const TLS_CA = process . env . TLS_CA ; const tls_cert = readOpt ( "--tls-cert" ) ; const tls_key = readOpt ( "--tls-key" ) ; const tls_ca = readOpt ( "--tls-ca" ) ; const result = { } ; if ( tls_cert ) { if ( tls_key ) { result . cert = readFile ( tls_cert ) ; result . key = readFile ( tls_key ) ; if ( tls_ca ) { result . ca = readFile ( tls_ca ) ; } } else { result . pfx = readFile ( tls_cert ) ; } } else if ( TLS_CERT ) { if ( TLS_KEY ) { result . cert = readFile ( TLS_CERT ) ; result . key = readFile ( TLS_KEY ) ; if ( TLS_CA ) { result . ca = readFile ( TLS_CA ) ; } } else { result . pfx = readFile ( TLS_CERT ) ; } } return Promise . all ( keys ( result ) . map ( key => result [ key ] . then ( data => { return result [ key ] = data ; } ) ) ) . then ( ( ) => result ) ; }
476	function deepAssign ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key2 = 0 ; _key2 < _len ; _key2 ++ ) { args [ _key2 ] = arguments [ _key2 ] ; } if ( args . length < 2 ) { throw new Error ( 'deepAssign accept two and more argument' ) ; } for ( var i = args . length - 1 ; i > - 1 ; i -- ) { if ( isPrimitive ( args [ i ] ) ) { throw new TypeError ( 'deepAssign only accept non primitive type' ) ; } } var target = args . shift ( ) ; args . forEach ( function ( source ) { return _deepAssign ( source , target ) ; } ) ; return target ; }
2551	function isIterateeCall ( value , index , object ) { if ( ! isObject$5 ( object ) ) { return false ; } var type = typeof index ; if ( type == 'number' ? ( isArrayLike$1 ( object ) && isIndex$3 ( index , object . length ) ) : ( type == 'string' && index in object ) ) { return eq$3 ( object [ index ] , value ) ; } return false ; }
1189	function update_time ( element ) { var settings = element . data ( "easydate.settings" ) ; var element_id = $ . data ( element [ 0 ] ) ; elements [ element_id ] = element ; delete updates [ element_id ] ; var date = get_date ( element , settings ) ; if ( isNaN ( date ) ) return ; element . html ( format_date ( date , settings ) ) ; if ( settings . live ) { var timeout = get_timeout_delay ( date , settings ) ; if ( ! isNaN ( timeout ) ) { if ( timeout > 2147483647 ) timeout = 2147483647 ; var id = setTimeout ( function ( ) { update_time ( element ) ; } , Math . round ( timeout ) ) ; updates [ element_id ] = id ; } } }
2266	function ( client ) { this . settings = client . settings ; this . client = client ; this . accessTokenInactiveTimer = null ; this . accessTokenCreationTimer = null ; }
2966	function base ( args , ctor ) { var plain = false ; function clas ( ) { if ( this !== global ) { plain ? ( plain = false ) : ctor . apply ( this , arguments ) ; return this ; } else { return ( plain = true ) && clas . apply ( new clas ( ) , arguments ) ; } } var properties = { } ; clas . init = bind ( ctor ) ; clas . extend = function ( obj ) { if ( is ( 'Function' , obj ) ) { if ( obj . hasOwnProperty ( 'extend' ) ) { return obj . extend ( properties ) ; } } else { for ( var i in obj ) { if ( obj . hasOwnProperty ( i ) ) { extend ( clas , properties , obj , i ) ; } } } return clas ; } ; var i = is ( 'Function' , ctor ) && ctor . hasOwnProperty ( 'init' ) ? 0 : 1 ; for ( var l = args . length ; i < l ; i ++ ) { if ( is ( 'Object' , args [ i ] ) ) { clas . extend ( args [ i ] ) ; } else { args [ i ] . extend ( clas ) ; } } return clas ; }
3024	function highest ( word ) { word |= word >> 1 ; word |= word >> 2 ; word |= word >> 4 ; word |= word >> 8 ; word |= word >> 16 ; return position ( ( word >>> 1 ) + 1 ) ; }
2579	function reverse ( s ) { if ( s . length < 64 ) { var str = '' ; for ( var i = s . length ; i >= 0 ; i -- ) str += s . charAt ( i ) ; return str ; } else { return s . split ( '' ) . reverse ( ) . join ( '' ) ; } }
1785	function injectMocha ( Mocha ) { _injectPrototype ( Console , Mocha . reporters . Base . prototype ) ; _injectPrototype ( HTML , Mocha . reporters . HTML . prototype ) ; _injectPrototype ( MultiReporter , Object . getPrototypeOf ( Mocha . Runner . prototype ) ) ; }
305	function addListener ( element , type , listener ) { var options = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : { } ; var _handler = listener ; type . trim ( ) . split ( REGEXP_SPACES ) . forEach ( function ( event ) { if ( options . once && ! onceSupported ) { var _element$listeners = element . listeners , listeners = _element$listeners === void 0 ? { } : _element$listeners ; _handler = function handler ( ) { delete listeners [ event ] [ listener ] ; element . removeEventListener ( event , _handler , options ) ; for ( var _len2 = arguments . length , args = new Array ( _len2 ) , _key2 = 0 ; _key2 < _len2 ; _key2 ++ ) { args [ _key2 ] = arguments [ _key2 ] ; } listener . apply ( element , args ) ; } ; if ( ! listeners [ event ] ) { listeners [ event ] = { } ; } if ( listeners [ event ] [ listener ] ) { element . removeEventListener ( event , listeners [ event ] [ listener ] , options ) ; } listeners [ event ] [ listener ] = _handler ; element . listeners = listeners ; } element . addEventListener ( event , _handler , options ) ; } ) ; }
1921	function makePossibleRangesCSS ( property ) { var valueRange = property . valueRange ( true ) ; var result = [ property . range ( true ) , valueRange ] ; var stringStream = require ( 'stringStream' ) ; var cssEditTree = require ( 'cssEditTree' ) ; var range = require ( 'range' ) ; var value = property . value ( ) ; _ . each ( property . valueParts ( ) , function ( r ) { var clone = r . clone ( ) ; result . push ( clone . shift ( valueRange . start ) ) ; var stream = stringStream . create ( r . substring ( value ) ) ; if ( stream . match ( / ^[\w\-]+\( / , true ) ) { stream . start = stream . pos ; stream . skipToPair ( '(' , ')' ) ; var fnBody = stream . current ( ) ; result . push ( range . create ( clone . start + stream . start , fnBody ) ) ; _ . each ( cssEditTree . findParts ( fnBody ) , function ( part ) { result . push ( range . create ( clone . start + stream . start + part . start , part . substring ( fnBody ) ) ) ; } ) ; } } ) ; return _ . chain ( result ) . filter ( function ( item ) { return ! ! item . length ( ) ; } ) . uniq ( false , function ( item ) { return item . toString ( ) ; } ) . value ( ) ; }
3488	function ( dest , source , names , usePrototypeKeys ) { if ( typeof names == 'string' ) { names = names . split ( / [,;\s] / ) ; } var n , nLen = names ? names . length : 0 , name ; for ( n = 0 ; n < nLen ; n ++ ) { name = names [ n ] ; if ( usePrototypeKeys || source . hasOwnProperty ( name ) ) { dest [ name ] = source [ name ] ; } } return dest ; }
2365	function updateDatasetClients ( wcb ) { var datasetClientIds = _ . pluck ( datasetClientsToSync , 'id' ) ; syncStorage . updateManyDatasetClients ( { id : { $in : datasetClientIds } } , { syncScheduled : Date . now ( ) } , wcb ) ; }
603	function getBlocks ( text ) { var blocks = [ ] , depth = 0 , blockStartTag = "" , currentBlock = "" , blockEndTag = "" ; text = text . replace ( commentRegex , "" ) ; createTokenizer ( ) ; htmlBlockTokenizer . onText ( text ) ; htmlBlockTokenizer . end ( ) ; forEach ( tokens , function ( token , i ) { var nextToken = tokens [ i + 1 ] ; switch ( token . type ) { case "content" : case "greater-than-sign-content" : case "inline-start" : case "inline-end" : case "other-tag" : case "other-element-start" : case "other-element-end" : case "greater than sign" : if ( ! nextToken || ( depth === 0 && ( nextToken . type === "block-start" || nextToken . type === "block-end" ) ) ) { currentBlock += token . src ; blocks . push ( currentBlock ) ; blockStartTag = "" ; currentBlock = "" ; blockEndTag = "" ; } else { currentBlock += token . src ; } break ; case "block-start" : if ( depth !== 0 ) { if ( currentBlock . trim ( ) !== "" ) { blocks . push ( currentBlock ) ; } currentBlock = "" ; blockEndTag = "" ; } depth ++ ; blockStartTag = token . src ; break ; case "block-end" : depth -- ; blockEndTag = token . src ; if ( "" !== blockStartTag && "" !== blockEndTag ) { blocks . push ( blockStartTag + currentBlock + blockEndTag ) ; } else if ( "" !== currentBlock . trim ( ) ) { blocks . push ( currentBlock ) ; } blockStartTag = "" ; currentBlock = "" ; blockEndTag = "" ; break ; } if ( depth < 0 ) { depth = 0 ; } } ) ; return blocks ; }
2429	function nextchild ( compare , a , i , j ) { if ( j - i < 2 ) return i ; if ( compare ( a [ i ] , a [ i + 1 ] ) <= 0 ) return i ; return i + 1 ; }
2032	function changeAddrFromMnemonic ( walletInfo , index , BITBOX ) { const rootSeed = BITBOX . Mnemonic . toSeed ( walletInfo . mnemonic ) if ( walletInfo . network === "testnet" ) var masterHDNode = BITBOX . HDNode . fromSeed ( rootSeed , "testnet" ) else var masterHDNode = BITBOX . HDNode . fromSeed ( rootSeed ) const account = BITBOX . HDNode . derivePath ( masterHDNode , "m/44'/145'/0'" ) const change = BITBOX . HDNode . derivePath ( account , ` ${ index } ` ) return change }
1251	function ( ) { return this . read_list ( function ( ) { const node = this . node ( "staticvariable" ) ; let variable = this . node ( "variable" ) ; if ( this . expect ( this . tok . T_VARIABLE ) ) { const name = this . text ( ) . substring ( 1 ) ; this . next ( ) ; variable = variable ( name , false , false ) ; } else { variable = variable ( "#ERR" , false , false ) ; } if ( this . token === "=" ) { return node ( variable , this . next ( ) . read_expr ( ) ) ; } else { return variable ; } } , "," ) ; }
155	function ( post ) { let latitude , longitude ; if ( ! post ) { return ; } latitude = parseFloat ( getValueByKey ( post . metadata , 'geo_latitude' ) ) ; longitude = parseFloat ( getValueByKey ( post . metadata , 'geo_longitude' ) ) ; if ( latitude && longitude ) { return [ latitude , longitude ] ; } }
2134	function _boolToNum ( value , numTrue , numFalse , defaultVal ) { if ( typeof value === 'boolean' ) { return value ? numTrue : numFalse ; } return typeof value === 'number' ? value : defaultVal ; }
455	function getStringsFromAxes ( props , axis ) { const { tickValues , tickFormat } = props ; let tickValueArray ; if ( ! tickValues || ( ! Array . isArray ( tickValues ) && ! tickValues [ axis ] ) ) { tickValueArray = tickFormat && Array . isArray ( tickFormat ) ? tickFormat : [ ] ; } else { tickValueArray = tickValues [ axis ] || tickValues ; } return tickValueArray . filter ( ( val ) => typeof val === "string" ) ; }
2553	function baseGetTag$1 ( value ) { if ( value == null ) { return value === undefined ? undefinedTag$1 : nullTag$1 ; } return ( symToStringTag$2 && symToStringTag$2 in Object ( value ) ) ? _getRawTag ( value ) : _objectToString ( value ) ; }
1222	function pos ( el ) { var o = { x : el . offsetLeft , y : el . offsetTop } while ( ( el = el . offsetParent ) ) o . x += el . offsetLeft , o . y += el . offsetTop return o }
2485	function SocketTransport ( URL , options ) { if ( ! URL ) { throw new Error ( 'A WebSocket URL must be passed to the SocketTransport constructor!' ) ; } if ( ! ( this instanceof SocketTransport ) ) { return new SocketTransport ( URL , options ) ; } this . _URL = URL ; this . _options = options || { } ; this . _socket = null ; this . _state = 'unconnected' ; this . _active = false ; this . _reconnectTimeout = null ; EventEmitter2 . call ( this ) ; var self = this ; var listeners = { open : function ( ) { self . _handleOpen ( ) ; } , error : function ( error ) { self . _handleError ( error ) ; } , close : function ( closeEvent ) { self . _handleDisconnect ( ) ; } , message : function ( messageEvent ) { self . emit ( 'message' , messageEvent . data ) ; } } ; this . _standardListeners = listeners ; }
2961	function mailCommon ( type , data , req , res ) { const { zlSite } = res . locals ; if ( 'form-notice' === type ) { if ( data . text ) { data . text += ` \n ${ req . cookies . referer } \n \n ` + ` ` + ` \n \n ` + ` ${ req . ip } \n ${ req . get ( 'Referrer' ) } \n \n ` + ` ${ process . env . ZEAL_NETWORK_NAME } ` + ` ` } } data . from = ` ${ zlSite . zsName } ${ process . env . ZEAL_NETWORK_EMAIL } ` ; if ( zlSite . zsInternalConfig && zlSite . zsInternalConfig . displayEmail ) { data . replyTo = ` ${ zlSite . zsName } ${ zlSite . zsInternalConfig . displayEmail } ` ; } return data ; }
1294	function MakeMirror ( value , opt_transient ) { var mirror ; if ( ! opt_transient && mirror_cache_enabled_ ) { for ( var id in mirror_cache_ ) { mirror = mirror_cache_ [ id ] ; if ( mirror . value ( ) === value ) { return mirror ; } if ( mirror . isNumber ( ) && IsNaN ( mirror . value ( ) ) && typeof value == 'number' && IsNaN ( value ) ) { return mirror ; } } } if ( IS_UNDEFINED ( value ) ) { mirror = new UndefinedMirror ( ) ; } else if ( IS_NULL ( value ) ) { mirror = new NullMirror ( ) ; } else if ( IS_BOOLEAN ( value ) ) { mirror = new BooleanMirror ( value ) ; } else if ( IS_NUMBER ( value ) ) { mirror = new NumberMirror ( value ) ; } else if ( IS_STRING ( value ) ) { mirror = new StringMirror ( value ) ; } else if ( IS_SYMBOL ( value ) ) { mirror = new SymbolMirror ( value ) ; } else if ( IS_ARRAY ( value ) ) { mirror = new ArrayMirror ( value ) ; } else if ( IS_DATE ( value ) ) { mirror = new DateMirror ( value ) ; } else if ( IS_FUNCTION ( value ) ) { mirror = new FunctionMirror ( value ) ; } else if ( IS_REGEXP ( value ) ) { mirror = new RegExpMirror ( value ) ; } else if ( IS_ERROR ( value ) ) { mirror = new ErrorMirror ( value ) ; } else if ( IS_SCRIPT ( value ) ) { mirror = new ScriptMirror ( value ) ; } else if ( IS_MAP ( value ) || IS_WEAKMAP ( value ) ) { mirror = new MapMirror ( value ) ; } else if ( IS_SET ( value ) || IS_WEAKSET ( value ) ) { mirror = new SetMirror ( value ) ; } else if ( IS_MAP_ITERATOR ( value ) || IS_SET_ITERATOR ( value ) ) { mirror = new IteratorMirror ( value ) ; } else if ( ObjectIsPromise ( value ) ) { mirror = new PromiseMirror ( value ) ; } else if ( IS_GENERATOR ( value ) ) { mirror = new GeneratorMirror ( value ) ; } else { mirror = new ObjectMirror ( value , MirrorType . OBJECT_TYPE , opt_transient ) ; } if ( mirror_cache_enabled_ ) mirror_cache_ [ mirror . handle ( ) ] = mirror ; return mirror ; }
1896	function ( tree , filters , profile ) { var utils = require ( 'utils' ) ; profile = require ( 'profile' ) . get ( profile ) ; _ . each ( list ( filters ) , function ( filter ) { var name = utils . trim ( filter . toLowerCase ( ) ) ; if ( name && name in registeredFilters ) { tree = registeredFilters [ name ] ( tree , profile ) ; } } ) ; return tree ; }
3324	function ( ) { var line = [ ] ; line . push ( this . commandAssignment . value . name ) ; Object . keys ( this . _assignments ) . forEach ( function ( name ) { var assignment = this . _assignments [ name ] ; var type = assignment . param . type ; if ( assignment . value !== assignment . param . defaultValue ) { line . push ( ' ' ) ; line . push ( type . stringify ( assignment . value ) ) ; } } , this ) ; return line . join ( '' ) ; }
3795	function errorHandler ( response , error ) { response . status ( 500 ) . send ( error !== undefined && error !== null ? error . toString ( ) : '' ) }
1323	function goToSameSet ( s1 , s2 , table , symbol ) { if ( ! currentTransitionMap [ s1 ] || ! currentTransitionMap [ s2 ] ) { return false ; } const originalTransitionS1 = table [ s1 ] [ symbol ] ; const originalTransitionS2 = table [ s2 ] [ symbol ] ; if ( ! originalTransitionS1 && ! originalTransitionS2 ) { return true ; } return currentTransitionMap [ s1 ] . has ( originalTransitionS1 ) && currentTransitionMap [ s2 ] . has ( originalTransitionS2 ) ; }
2880	function showTasks ( tasks ) { const taskList = Object . keys ( tasks ) ; if ( taskList . length ) { taskList . forEach ( ( task ) => { process . stdout . write ( ` ${ task } ` ) ; if ( tasks [ task ] . description ) { process . stdout . write ( ` ${ tasks [ task ] . description } ` ) ; } process . stdout . write ( '\n' ) ; } ) ; } else \n }
2527	function streamToBuffer ( stream , cb ) { var bufs = [ ] ; stream . on ( 'data' , function ( d ) { bufs . push ( d ) ; } ) . on ( 'end' , function ( ) { cb ( null , Buffer . concat ( bufs ) ) ; } ) . on ( 'error' , function ( err ) { cb ( err ) ; } ) ; }
2107	function ( req , cb ) { let config = req . soajs . config ; let loginMode = config . loginMode ; if ( req . soajs . tenantOauth && req . soajs . tenantOauth . loginMode ) { loginMode = req . soajs . tenantOauth . loginMode ; } let criteria = { "userId.loginMode" : loginMode , "userId.id" : req . soajs . inputmaskData . userId } ; let combo = { collection : tokenCollectionName , condition : criteria } ; libProduct . model . removeEntry ( req . soajs , combo , function ( error , result ) { let data = { config : req . soajs . config , error : error , code : 404 } ; checkIfError ( req , cb , data , function ( ) { return cb ( null , result . result ) ; } ) ; } ) ; }
2668	function render ( self ) { var container = isDOMElement ( self . node ) ? self . node : document . getElementById ( self . node ) ; var leaves = [ ] , click ; var renderLeaf = function ( item ) { var leaf = document . createElement ( 'div' ) ; var content = document . createElement ( 'div' ) ; var text = document . createElement ( 'div' ) ; var expando = document . createElement ( 'div' ) ; leaf . setAttribute ( 'class' , 'tree-leaf' ) ; content . setAttribute ( 'class' , 'tree-leaf-content' ) ; content . setAttribute ( 'data-item' , JSON . stringify ( item ) ) ; text . setAttribute ( 'class' , 'tree-leaf-text' ) ; text . textContent = item . name ; expando . setAttribute ( 'class' , 'tree-expando ' + ( item . expanded ? 'expanded' : '' ) ) ; expando . textContent = item . expanded ? '-' : '+' ; content . appendChild ( expando ) ; content . appendChild ( text ) ; leaf . appendChild ( content ) ; if ( item . children && item . children . length > 0 ) { var children = document . createElement ( 'div' ) ; children . setAttribute ( 'class' , 'tree-child-leaves' ) ; forEach ( item . children , function ( child ) { var childLeaf = renderLeaf ( child ) ; children . appendChild ( childLeaf ) ; } ) ; if ( ! item . expanded ) { children . classList . add ( 'hidden' ) ; } leaf . appendChild ( children ) ; } else { expando . classList . add ( 'hidden' ) ; } return leaf ; } ; forEach ( self . data , function ( item ) { leaves . push ( renderLeaf . call ( self , item ) ) ; } ) ; container . innerHTML = leaves . map ( function ( leaf ) { return leaf . outerHTML ; } ) . join ( '' ) ; click = function ( e ) { var parent = ( e . target || e . currentTarget ) . parentNode ; var data = JSON . parse ( parent . getAttribute ( 'data-item' ) ) ; var leaves = parent . parentNode . querySelector ( '.tree-child-leaves' ) ; if ( leaves ) { if ( leaves . classList . contains ( 'hidden' ) ) { self . expand ( parent , leaves ) ; } else { self . collapse ( parent , leaves ) ; } } else { emit ( self , 'select' , { target : e , data : data } ) ; } } ; forEach ( container . querySelectorAll ( '.tree-leaf-text' ) , function ( node ) { node . onclick = click ; } ) ; forEach ( container . querySelectorAll ( '.tree-expando' ) , function ( node ) { node . onclick = click ; } ) ; }
330	function getCanvasData ( ) { var canvasData = this . canvasData ; var data = { } ; if ( this . ready ) { forEach ( [ 'left' , 'top' , 'width' , 'height' , 'naturalWidth' , 'naturalHeight' ] , function ( n ) { data [ n ] = canvasData [ n ] ; } ) ; } return data ; }
323	function move ( offsetX ) { var offsetY = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : offsetX ; var _this$canvasData = this . canvasData , left = _this$canvasData . left , top = _this$canvasData . top ; return this . moveTo ( isUndefined ( offsetX ) ? offsetX : left + Number ( offsetX ) , isUndefined ( offsetY ) ? offsetY : top + Number ( offsetY ) ) ; }
688	function ( kb , x , contentTypes ) { var cts = kb . fetcher . getHeader ( x , 'content-type' ) if ( cts ) { for ( var j = 0 ; j < cts . length ; j ++ ) { for ( var k = 0 ; k < contentTypes . length ; k ++ ) { if ( cts [ j ] . indexOf ( contentTypes [ k ] ) >= 0 ) { return true } } } } return false }
2648	function storeJob ( jobCompleted ) { let emitterStore = new EventEmitter ( ) ; let socketStoreJob = io . connect ( urlSocket ) ; let msg = messageBuilder ( jobCompleted , 'storeJob' , true ) ; socketStoreJob . on ( 'connect' , function ( ) { socketStoreJob . emit ( 'storeJob' , msg ) ; } ) . on ( 'addingResponse' , ( messageRes ) => { logger_1 . logger . log ( 'info' , ` ` ) ; logger_1 . logger . log ( 'debug' , ` \n ${ JSON . stringify ( messageRes ) } ` ) ; if ( messageRes . value === 'success' ) emitterStore . emit ( 'addSuccess' , messageRes ) ; if ( messageRes . value === 'errorAddjob' ) emitterStore . emit ( 'addError' , messageRes ) ; } ) ; return emitterStore ; }
1449	function ( name ) { delete this . __scope . unresolved [ name ] ; var stub = name + "." ; for ( var id in this . __scope . unresolved ) { if ( id . startsWith ( stub ) ) { delete this . __scope . unresolved [ id ] ; } } }
379	function treeMap ( node , mapfn ) { var results = [ ] ; nodeWalk ( node , function ( node ) { results = results . concat ( mapfn ( node ) ) ; return false ; } ) ; return results ; }
1829	function makeNext ( browser ) { return function next ( code ) { exitCode += code ; currentRun ++ ; if ( code === 0 ) { console . log ( browser + ' success' ) ; } else { console . log ( browser + ' fail' ) ; } if ( currentRun == numberOfRuns ) { process . exit ( exitCode ) ; } } ; }
2914	function Transaction ( config ) { _classCallCheck ( this , Transaction ) ; this . _web3 = config . parent . _web3 ; this . _logger = config . parent . _logger ; this . _hash = config . hash ; }
2203	function checkFile ( src ) { if ( ! grunt . file . exists ( src ) ) { grunt . log . error ( "Source file \"" + \" + src ) ; "\" not fount." } \" }
2418	function writeFile ( modified , data , file ) { return ! modified ? Promise . resolve ( false ) : new Promise ( ( resolve , reject ) => { fs . writeFile ( file , data , ( error ) => { error ? reject ( error ) : resolve ( true ) ; } ) ; } ) ; }
291	function ( pluginSlug ) { const query = { fields : 'icons,banners,compatibility,ratings,-contributors' , locale : getWporgLocaleCode ( ) , } ; pluginSlug = pluginSlug . replace ( new RegExp ( '.php$' ) , '' ) ; const baseUrl = 'https://api.wordpress.org/plugins/info/1.0/' + pluginSlug + '.jsonp' ; return new Promise ( ( resolve , reject ) => { jsonp ( baseUrl , query , function ( error , data ) { if ( error ) { debug ( 'error downloading plugin details from .org: %s' , error ) ; reject ( error ) ; return ; } if ( ! data || ! data . slug ) { debug ( 'unrecognized format fetching plugin details from .org: %s' , data ) ; reject ( new Error ( 'Unrecognized response format' ) ) ; return ; } resolve ( data ) ; } ) ; } ) ; }
2216	function javascript ( node ) { if ( ! is ( node , 'script' ) ) { return false } if ( has ( node , 'type' ) ) { return check ( node . properties . type ) } return ! has ( node , 'language' ) || check ( node . properties . language , 'text/' ) }
2164	function refreshPosition ( item ) { var current = item . element [ 0 ] ; item . top = 0 ; item . left = 0 ; item . right = 0 ; while ( current && current !== contentEl [ 0 ] ) { item . top += current . offsetTop ; item . left += current . offsetLeft ; if ( current . offsetParent ) { item . right += current . offsetParent . offsetWidth - current . offsetWidth - current . offsetLeft ; } current = current . offsetParent ; } item . height = item . element . prop ( 'offsetHeight' ) ; var defaultVal = $mdUtil . floatingScrollbars ( ) ? '0' : undefined ; $mdUtil . bidi ( item . clone , 'margin-left' , item . left , defaultVal ) ; $mdUtil . bidi ( item . clone , 'margin-right' , defaultVal , item . right ) ; }
1492	function ( filename ) { return new Promise ( ( resolve , reject ) => { fs . unlink ( filename , function ( err ) { if ( err && err . code != "ENOENT" ) { reject ( err ) ; } else { resolve ( ) ; } } ) ; } ) ; }
3006	function ( records ) { var ghost = this . createGhost ( records ) , store = ghost . store ; store . removeAll ( ) ; store . add ( records ) ; return ghost . getEl ( ) ; }
3218	function ( e , record ) { var me = this , recIdx , fromIdx , isSelected = me . isSelected ( record ) , from = ( me . selectionStart && me . isSelected ( me . lastFocused ) ) ? me . selectionStart : ( me . selectionStart = me . lastFocused ) , key = e . getCharCode ( ) , isSpace = key === e . SPACE , direction = key === e . UP || key === e . PAGE_UP ? 'up' : ( key === e . DOWN || key === e . DOWN ? 'down' : null ) ; switch ( me . selectionMode ) { case 'MULTI' : if ( isSpace ) { if ( e . shiftKey ) { me . selectRange ( from , record , e . ctrlKey ) ; } else { if ( isSelected ) { me . doDeselect ( record , e . ctrlKey ) ; me . setLastFocused ( null ) ; me . setLastFocused ( record ) ; } else { me . doSelect ( record , e . ctrlKey ) ; } } } else if ( e . shiftKey && from ) { fromIdx = me . store . indexOf ( from ) ; recIdx = me . store . indexOf ( record ) ; if ( direction === 'up' && fromIdx <= recIdx ) { me . deselectRange ( me . lastFocused , recIdx + 1 ) ; } else if ( direction === 'down' && fromIdx >= recIdx ) { me . deselectRange ( me . lastFocused , recIdx - 1 ) ; } else if ( from !== record ) { me . selectRange ( from , record , e . ctrlKey ) ; } me . lastSelected = record ; me . setLastFocused ( record ) ; } else if ( e . ctrlKey && isSelected ) { me . setLastFocused ( record ) ; } else if ( e . ctrlKey ) { me . setLastFocused ( record ) ; } else { me . doSelect ( record , false ) ; } break ; case 'SIMPLE' : if ( isSelected ) { me . doDeselect ( record ) ; } else { me . doSelect ( record , true ) ; } break ; case 'SINGLE' : if ( isSpace ) { if ( isSelected ) { me . doDeselect ( record ) ; me . setLastFocused ( record ) ; } else { me . doSelect ( record ) ; } } else if ( e . ctrlKey ) { me . setLastFocused ( record ) ; } else if ( me . allowDeselect && isSelected ) { me . doDeselect ( record ) ; } else { me . doSelect ( record , false ) ; } break ; } if ( ! e . shiftKey ) { if ( me . isSelected ( record ) ) { me . selectionStart = record ; } } }
1743	function changeData ( state , sourceName , data ) { const source = state . sources [ sourceName ] ; if ( ! source ) { return state ; } const src_mixin = { } ; src_mixin [ sourceName ] = Object . assign ( { } , source , { data , } ) ; return Object . assign ( { } , state , { sources : Object . assign ( { } , state . sources , src_mixin ) , } , incrementVersion ( state . metadata , dataVersionKey ( sourceName ) ) ) ; }
995	function addFile ( filename ) { var file = zip . addFile ( filename ) ; var sha = new SHAWriteStream ( manifest , filename , file ) ; return sha ; }
3731	function getInputArguments ( args ) { var out = { } ; out . localServices = { } ; if ( args . length > 0 ) { out . source = args [ 0 ] ; out . target = args [ 0 ] ; if ( _ . isPlainObject ( args [ 0 ] ) ) { var opts = args [ 0 ] ; out . target = opts . target ; out . source = opts . source ; out . instance = opts . instance ; } if ( args . length > 1 ) { var argsDefined = _ . isString ( args [ 0 ] ) || _ . isArray ( args [ 0 ] ) ; if ( argsDefined ) { if ( _ . isArray ( args [ 0 ] ) ) { out . source = args [ 0 ] ; } else { out . source = _ . isString ( args [ 0 ] ) ? [ args [ 0 ] ] : args [ 0 ] ; } if ( _ . isFunction ( args [ 1 ] ) ) { out . target = args [ 1 ] ; } if ( _ . isFunction ( args [ 2 ] ) ) { out . target = args [ 2 ] ; } } else { if ( _ . isFunction ( args [ 1 ] ) ) { out . callReady = args [ 1 ] ; } if ( _ . isPlainObject ( args [ 1 ] ) ) { out . localServices = args [ 1 ] ; } } } if ( args . length === 3 ) { if ( _ . isPlainObject ( args [ 1 ] ) ) { out . localServices = args [ 1 ] ; } if ( _ . isFunction ( args [ 2 ] ) ) { out . callReady = args [ 2 ] ; } } } out . target = out . target || function ( ) { } ; out . source = out . source ? out . source : out . target ; out . callReady = out . callReady || function ( ) { } ; return out ; }
196	function isCancelable ( purchase ) { if ( isIncludedWithPlan ( purchase ) ) { return false ; } if ( isPendingTransfer ( purchase ) ) { return false ; } if ( isExpired ( purchase ) ) { return false ; } if ( isRefundable ( purchase ) ) { return true ; } return purchase . canDisableAutoRenew ; }
2919	function templatesFromStream ( templateStream ) { var firstTemplate = null ; templateStream . on ( 'data' , function ( file ) { var relpath = file . relative ; var deferred ; if ( registry . hasOwnProperty ( relpath ) ) { deferred = registry [ relpath ] ; } else { deferred = registry [ relpath ] = new Deferred ( ) ; } try { if ( ! file . isBuffer ( ) ) { throw pluginError ( 'Template source must be buffer' ) ; } var template = compile ( { data : file . contents . toString ( ) , name : file . path , path : file . path } ) ; deferred . resolve ( template ) ; if ( firstTemplate === null ) { firstTemplate = template ; } else { firstTemplate = false ; theOnlyTemplate . reject ( pluginError ( 'Multiple templates given, must select one' ) ) ; } } catch ( err ) { deferred . reject ( err ) ; } } ) . on ( 'end' , function ( ) { if ( firstTemplate ) theOnlyTemplate . resolve ( firstTemplate ) ; else theOnlyTemplate . reject ( pluginError ( 'No templates in template stream' ) ) ; noMoreTemplates ( ) ; } ) . on ( 'error' , function ( err ) { templateStreamError = err ; noMoreTemplates ( ) ; } ) ; }
391	function dasherizeShorthands ( hash ) { Object . keys ( hash ) . forEach ( function ( key ) { var val = hash [ key ] [ 0 ] ; if ( key . length === 1 && val . indexOf ( '_' ) > - 1 ) { hash [ dasherizeFlag ( val ) ] = val ; } } ) ; return hash ; }
3882	function or ( defaultValue ) { return function ( maybe ) { for ( const value of maybe ) { return maybe_1 . just ( value ) ; } return defaultValue ; } ; }
814	function check_chain_group_scripts_ready ( chain_group ) { var any_scripts_ready = false ; for ( var i = 0 ; i < chain_group . scripts . length ; i ++ ) { if ( chain_group . scripts [ i ] . ready && chain_group . scripts [ i ] . exec_trigger ) { any_scripts_ready = true ; chain_group . scripts [ i ] . exec_trigger ( ) ; chain_group . scripts [ i ] . exec_trigger = null ; } } return any_scripts_ready ; }
88	function setRange ( target ) { var value = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 0 ; if ( ! is$1 . element ( target ) ) { return ; } target . value = value ; controls . updateRangeFill . call ( this , target ) ; }
2936	function splitLines ( string , index ) { const str = index ? string . substring ( index ) : string ; return str . split ( / \r\n|\r|\n / ) ; }
1621	function parse_scan_results_interface ( callback ) { return function ( error , stdout , stderr ) { if ( error ) { callback ( error ) ; } else { callback ( error , parse_scan_results ( stdout . trim ( ) ) ) ; } } ; }
296	function forEach ( data , callback ) { if ( data && isFunction ( callback ) ) { if ( Array . isArray ( data ) || isNumber ( data . length ) ) { toArray ( data ) . forEach ( function ( value , key ) { callback . call ( data , value , key , data ) ; } ) ; } else if ( isObject ( data ) ) { Object . keys ( data ) . forEach ( function ( key ) { callback . call ( data , data [ key ] , key , data ) ; } ) ; } } return data ; }
463	function _applyRemainingDefaultOptions ( opts ) { opts . icon = opts . hasOwnProperty ( 'icon' ) ? opts . icon : '\ue9cb' ; \ue9cb opts . visible = opts . hasOwnProperty ( 'visible' ) ? opts . visible : 'hover' ; opts . placement = opts . hasOwnProperty ( 'placement' ) ? opts . placement : 'right' ; opts . class = opts . hasOwnProperty ( 'class' ) ? opts . class : '' ; }
205	function UndocumentedSite ( id , wpcom ) { debug ( 'UndocumentedSite' , id ) ; if ( ! ( this instanceof UndocumentedSite ) ) { return new UndocumentedSite ( id , wpcom ) ; } this . wpcom = wpcom ; this . _id = id ; }
3679	function run ( js , path ) { var m = new Module ( path , module ) Module . _findPath = findPath m . paths = Module . _nodeModulePaths ( dirname ( path ) ) m . id = path m . filename = path js = 'module.return=eval(' + json ( js ) + ')' m . _compile ( js , path ) Module . _findPath = originalFindPath return m }
372	function karmaEsmFramework ( karmaConfig , karmaEmitter ) { if ( ! karmaConfig . files . some ( file => file . type === 'module' ) ) { throw new Error ( "Did not find any test files with type='module'." + "Follow this format: { pattern: config.grep ? config.grep : 'test/**/*.test.js', type: 'module' }" , ) ; } initialize ( karmaConfig , karmaEmitter ) ; }
1957	function appendChild ( parent , childrens ) { if ( childrens . length === undefined ) childrens = [ childrens ] ; var docFrag = document . createDocumentFragment ( ) ; for ( var i = 0 , ln = childrens . length ; i < ln ; i ++ ) { docFrag . appendChild ( childrens [ i ] ) ; } parent . appendChild ( docFrag ) ; }
3843	function replace ( target , replaceWith ) { function escapeRegExp ( str ) { return str . replace ( / [.*+?^${}()|[\]\\] / g , "\\$&" ) ; } \\ }
642	function updateUnformattedText ( key , value ) { this . element . input [ key ] . value = value ; this . data [ key ] = value ; }
3492	function report ( node , needed , gotten , loc , isLastNodeCheck ) { var msgContext = { needed : needed , type : indentType , characters : needed === 1 ? "character" : "characters" , gotten : gotten } ; var indentChar = indentType === "space" ? " " : "\t" ; \t function getFixerFunction ( ) { var rangeToFix = [ ] ; if ( needed > gotten ) { var spaces = "" + new Array ( needed - gotten + 1 ) . join ( indentChar ) ; if ( isLastNodeCheck === true ) { rangeToFix = [ node . range [ 1 ] - 1 , node . range [ 1 ] - 1 ] ; } else { rangeToFix = [ node . range [ 0 ] , node . range [ 0 ] ] ; } return function ( fixer ) { return fixer . insertTextBeforeRange ( rangeToFix , spaces ) ; } ; } else { if ( isLastNodeCheck === true ) { rangeToFix = [ node . range [ 1 ] - ( gotten - needed ) - 1 , node . range [ 1 ] - 1 ] ; } else { rangeToFix = [ node . range [ 0 ] - ( gotten - needed ) , node . range [ 0 ] ] ; } return function ( fixer ) { return fixer . removeRange ( rangeToFix ) ; } ; } } }
785	function ( bBox ) { var size = Math . max ( bBox [ 3 ] , bBox [ 4 ] , bBox [ 5 ] ) ; var ratio = Math . max ( viewer . _width , viewer . _height ) / Math . min ( viewer . _width , viewer . _height ) ; viewer . _distance = size / Math . tan ( viewer . perspectiveCamera . fov * Math . PI / 180.0 ) * ratio * 1.0 ; }
2108	function ( req , cb ) { let criteria = { "clientId" : req . soajs . inputmaskData . clientId } ; let combo = { collection : tokenCollectionName , condition : criteria } ; libProduct . model . removeEntry ( req . soajs , combo , function ( error , result ) { let data = { config : req . soajs . config , error : error , code : 404 } ; checkIfError ( req , cb , data , function ( ) { return cb ( null , result . result ) ; } ) ; } ) ; }
3868	function removeAttribute ( node , prop ) { if ( node && node . el ) { node . el . removeAttribute ( prop ) ; } }
1924	function getReflectedCSSName ( name ) { name = require ( 'cssEditTree' ) . baseName ( name ) ; var vendorPrefix = '^(?:\\-\\w+\\-)?' , \\ ; \\ \\ }
3571	function ( object ) { sjl . throwTypeErrorIfNotOfType ( SjlMap . name , 'object' , object , 'Object' , 'Only `Object` types allowed.' ) ; var self = this , entry , objectIt = new ObjectIterator ( object ) ; while ( objectIt . valid ( ) ) { entry = objectIt . next ( ) ; self . set ( entry . value [ 0 ] , entry . value [ 1 ] ) ; } return self ; }
1252	function findChunkFile ( chunk , chunkId , outputFilePath ) { for ( let i = 0 ; i < chunk . files . length ; i ++ ) { const chunkFile = chunk . files [ i ] ; let normalizedOutputFilePath = outputFilePath . replace ( / ^\.\/ / , '' ) ; if ( ! / \.js$ / . test ( chunkFile ) ) { normalizedOutputFilePath = normalizedOutputFilePath . substr ( 0 , normalizedOutputFilePath . length - 3 ) ; } if ( normalizedOutputFilePath === chunkFile ) { return chunkFile ; } } if ( chunk . id === chunkId ) { return chunk . files [ 0 ] ; } return undefined ; }
1677	function mkextract ( opts ) { var chunk = null var indent = 0 var number = 0 opts = merge ( { } , { trim : true , dotted_names : false , parsers : [ PARSERS . parse_tag , PARSERS . parse_type , PARSERS . parse_name , PARSERS . parse_description ] } , opts || { } ) return function extract ( line ) { var result = null var startPos = line . indexOf ( MARKER_START ) var endPos = line . indexOf ( MARKER_END ) if ( startPos !== - 1 && line . indexOf ( MARKER_START_SKIP ) !== startPos ) { chunk = [ ] indent = startPos + MARKER_START . length } if ( chunk ) { var lineStart = indent var startWithStar = false var nonSpaceChar = line . match ( / \S / ) if ( chunk . length > 0 && nonSpaceChar ) { if ( nonSpaceChar [ 0 ] === '*' ) { lineStart = nonSpaceChar . index + 2 startWithStar = true } else if ( nonSpaceChar . index < indent ) { lineStart = nonSpaceChar . index } } chunk . push ( { number : number , startWithStar : startWithStar , source : line . slice ( lineStart , endPos === - 1 ? line . length : endPos ) } ) if ( endPos !== - 1 ) { result = parse_block ( chunk , opts ) chunk = null indent = 0 } } number += 1 return result } }
2490	function AppClient ( URL , options ) { if ( ! ( this instanceof AppClient ) ) { return new AppClient ( URL , options ) ; } options = options || { } ; var transport = options . transport || new SocketTransport ( URL ) ; var RPC = options . RPC || new JSONRPC ( transport ) ; var commander = options . commander || new Commander ( RPC ) ; transport . on ( 'connect' , function ( ) { setTimeout ( function ( ) { commander . triggerRetries ( ) ; } , 10000 * Math . random ( ) ) ; } ) ; transport . on ( 'error' , function ( ) { } ) ; Object . defineProperties ( this , { transport : { enumerable : true , get : function ( ) { return transport ; } } , RPC : { enumerable : true , get : function ( ) { return RPC ; } } , commander : { enumerable : true , get : function ( ) { return commander ; } } } ) ; transport . start ( ) ; }
2363	function convertToObject ( itemArr ) { var obj = { } ; _ . each ( itemArr , function ( item ) { obj [ item . uid ] = item ; } ) ; return obj ; }
2782	function sendMessage ( args ) { last = new Date ( ) ; fs . write ( tmpfile , JSON . stringify ( args ) + '\n' , \n ) ; 'a' }
161	function updateImageBlocks ( blocks , image ) { forEach ( blocks , block => { if ( imageBlocks [ block . name ] ) { imageBlocks [ block . name ] ( block , image ) ; } if ( block . innerBlocks . length ) { updateImageBlocks ( block . innerBlocks , image ) ; } } ) ; }
59	function createElement ( type , attributes , text ) { var element = document . createElement ( type ) ; if ( is$1 . object ( attributes ) ) { setAttributes ( element , attributes ) ; } if ( is$1 . string ( text ) ) { element . innerText = text ; } return element ; }
2241	function ( collection , key , ip ) { if ( ! collection ) { collection = { } ; } if ( ! collection [ key ] ) { collection [ key ] = [ ] ; } collection [ key ] . push ( ip ) ; }
1428	function ( className ) { var library = this . getLibraryFromClassname ( className ) ; if ( ! library ) { return null ; } var path = library . getRootDir ( ) + "/" + library . getSourcePath ( ) + "/" + className . replace ( / \. / g , "/" ) + ".js" ; return path ; }
1168	function ( endType ) { function watchEnd ( link , end ) { end = end || { } ; var previousEnd = link . previous ( endType ) || { } ; var updateEndFunction = this [ '_' + endType + 'BBoxUpdate' ] ; if ( this . _isModel ( previousEnd ) ) { this . stopListening ( this . paper . getModelById ( previousEnd . id ) , 'change' , updateEndFunction ) ; } if ( this . _isModel ( end ) ) { this . listenTo ( this . paper . getModelById ( end . id ) , 'change' , updateEndFunction ) ; } _ . bind ( updateEndFunction , this ) ( { cacheOnly : true } ) ; return this ; } return watchEnd ; }
899	function compile ( file , options ) { let config = options . config || { } ; let presets = config . presets || [ ] ; let tsPreset = '@babel/preset-typescript' ; if ( ! presets . includes ( tsPreset ) ) { config . presets = [ tsPreset ] . concat ( presets ) ; options . config = config ; } return parserHelper . compile ( file , options , 7 ) ; }
1425	function ( library , locales ) { const Promisify = qx . tool . compiler . utils . Promisify ; return Promise . all ( locales . map ( locale => { var translation = new qx . tool . compiler . app . Translation ( library , locale ) ; return translation . read ( ) . then ( ( ) => { let unusedEntries = { } ; for ( let msgid in translation . getEntries ( ) ) unusedEntries [ msgid ] = true ; return Promise . all ( this . __classes . map ( async classname => { if ( ! classname . startsWith ( library . getNamespace ( ) ) ) { return ; } let dbClassInfo = await Promisify . call ( cb => this . getClassInfo ( classname , cb ) ) ; if ( ! dbClassInfo . translations ) return ; dbClassInfo . translations . forEach ( function ( src ) { var entry = translation . getOrCreateEntry ( src . msgid ) ; delete unusedEntries [ src . msgid ] ; if ( src . msgid_plural ) { entry . msgid_plural = src . msgid_plural ; } if ( ! entry . comments ) { entry . comments = { } ; } entry . comments . extracted = src . comment ; entry . comments . reference = { } ; let ref = entry . comments . reference ; const fileName = classname . replace ( / \. / g , "/" ) + ".js" ; const fnAddReference = lineNo => { let arr = ref [ fileName ] ; if ( ! arr ) arr = ref [ fileName ] = [ ] ; if ( ! arr . includes ( src . lineNo ) ) { arr . push ( lineNo ) ; } } ; if ( qx . lang . Type . isArray ( src . lineNo ) ) { src . lineNo . forEach ( fnAddReference ) ; } else { fnAddReference ( src . lineNo ) ; } } ) ; } ) ) . then ( ( ) => { Object . keys ( unusedEntries ) . forEach ( msgid => { var entry = translation . getEntry ( msgid ) ; if ( entry ) { if ( ! entry . comments ) { entry . comments = { } ; } entry . comments . extracted = "NO LONGER USED" ; entry . comments . reference = { } ; } } ) ; } ) ; } ) . then ( ( ) => translation . write ( ) ) ; } ) ) ; }
1105	function computeIndexChunks ( buffer ) { var BLOCK_SIZE = 65536 ; var view = new jDataView ( buffer , 0 , buffer . byteLength , true ) ; var minBlockIndex = Infinity ; var contigStartOffsets = [ ] ; view . getInt32 ( ) ; var n_ref = view . getInt32 ( ) ; for ( var j = 0 ; j < n_ref ; j ++ ) { contigStartOffsets . push ( view . tell ( ) ) ; var n_bin = view . getInt32 ( ) ; for ( var i = 0 ; i < n_bin ; i ++ ) { view . getUint32 ( ) ; var n_chunk = view . getInt32 ( ) ; view . skip ( n_chunk * 16 ) ; } var n_intv = view . getInt32 ( ) ; if ( n_intv ) { var offset = VirtualOffset . fromBlob ( view . getBytes ( 8 ) , 0 ) , coffset = offset . coffset + ( offset . uoffset ? BLOCK_SIZE : 0 ) ; minBlockIndex = coffset ? Math . min ( coffset , minBlockIndex ) : BLOCK_SIZE ; view . skip ( ( n_intv - 1 ) * 8 ) ; } } contigStartOffsets . push ( view . tell ( ) ) ; return { chunks : _ . zip ( _ . initial ( contigStartOffsets ) , _ . rest ( contigStartOffsets ) ) , minBlockIndex } ; }
2530	function ( ... rest ) { const _key = _hash ( rest , opt . id ) ; return cacheObj . get ( opt , _key ) . then ( res => { if ( typeof res == 'undefined' || res === null ) { res = _update . bind ( this ) ( opt , func , rest ) ; } return res ; } ) ; }
3883	function ( e ) { var history = S . History , current = history . getFragment ( ) ; if ( OLD_IE && current == history . fragment && history . iframe ) current = history . getFragment ( history . getHash ( history . iframe ) ) ; if ( current == history . fragment ) return false ; if ( history . iframe ) history . navigate ( current ) ; history . loadUrl ( ) ; }
2031	function openWallet ( filename ) { try { delete require . cache [ require . resolve ( filename ) ] const walletInfo = require ( filename ) return walletInfo } catch ( err ) { throw new Error ( ` ${ filename } ` ) } }
2217	function check ( value , prefix ) { var val if ( typeof value !== 'string' ) { return false } val = trim ( value . split ( ';' , 1 ) [ 0 ] ) . toLowerCase ( ) return val === '' || mime . indexOf ( ( prefix || '' ) + val ) !== - 1 }
661	function ( word , locale ) { var deviationFragments = createDeviationFragmentsMemoized ( syllableMatchers ( locale ) ) ; var remainingParts = word ; var syllableCount = 0 ; forEach ( deviationFragments , function ( deviationFragment ) { if ( deviationFragment . occursIn ( remainingParts ) ) { remainingParts = deviationFragment . removeFrom ( remainingParts ) ; syllableCount += deviationFragment . getSyllables ( ) ; } } ) ; return { word : remainingParts , syllableCount : syllableCount } ; }
199	function paymentLogoType ( purchase ) { if ( isPaidWithCreditCard ( purchase ) ) { return purchase . payment . creditCard . type ; } if ( isPaidWithPayPalDirect ( purchase ) ) { return 'placeholder' ; } return purchase . payment . type || null ; }
1053	function form ( context , value , all ) { var dict = context . data var flags = context . flags var alternative value = trim ( value ) if ( ! value ) { return null } value = normalize ( value , context . conversion . in ) if ( exact ( context , value ) ) { if ( ! all && flag ( flags , 'FORBIDDENWORD' , dict [ value ] ) ) { return null } return value } if ( value . toUpperCase ( ) === value ) { alternative = value . charAt ( 0 ) + value . slice ( 1 ) . toLowerCase ( ) if ( ignore ( flags , dict [ alternative ] , all ) ) { return null } if ( exact ( context , alternative ) ) { return alternative } } alternative = value . toLowerCase ( ) if ( alternative !== value ) { if ( ignore ( flags , dict [ alternative ] , all ) ) { return null } if ( exact ( context , alternative ) ) { return alternative } } return null }
1517	function find ( nodeById , id ) { var node = nodeById . get ( id ) if ( ! node ) throw new Error ( 'missing: ' + id ) return node }
1461	function generateSite ( ) { return new Promise ( ( resolve , reject ) => { Metalsmith ( __dirname ) . metadata ( { site : { title : "Qooxdoo Application Server" , description : "Mini website used by \"qx serve\"" , \" , \" , email : "info@qooxdoo.org" , twitter_username : "qooxdoo" } , github_username : "qooxdoo" , pages : [ "/" , "/about/" ] , baseurl : "" , url : "" } ) . lang : "en" partials : { } . source ( './src' ) . destination ( './build' ) . clean ( true ) . use ( loadPartials ) . use ( markdown ( ) ) . use ( getPages ) . use ( layouts ( { engine : 'dot' } ) ) ; } ) ; }
2379	function removeUpdatesInRequest ( updatesInDb , updatesInRequest ) { var updatesNotInRequest = _ . filter ( updatesInDb , function ( dbUpdate ) { var foundInRequest = _ . findWhere ( updatesInRequest , { hash : dbUpdate . hash } ) ; return ! foundInRequest ; } ) ; return updatesNotInRequest ; }
2925	function deepSet ( obj , path ) { var value = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : null ; var define = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : ! 1 ; if ( ! ( 0 , _object . isObject ) ( obj ) ) throw new TypeError ( 'Deepget is only supported for objects' ) ; var parts = interpolatePath ( path ) ; for ( var i = 0 ; i < parts . length - 1 ; i ++ ) { if ( parts [ i ] === '' ) continue ; if ( ! obj [ parts [ i ] ] ) obj [ parts [ i ] ] = { } ; obj = obj [ parts [ i ] ] ; if ( ! ( 0 , _array . isArray ) ( obj ) ) continue ; if ( i < parts . length - 2 ) { obj = obj [ parts [ i + 1 ] ] ; i ++ ; } } define ? Object . defineProperty ( obj , parts [ parts . length - 1 ] , value ) : obj [ parts [ parts . length - 1 ] ] = value ; return ! 0 ; }
866	function hasTrailingCommaForFunction ( node ) { const length = node . params . length return ( length >= 1 && sourceCode . getTokenAfter ( node . params [ length - 1 ] ) . value === "," ) }
266	function toggleToolbarsScrollableOnResize ( ) { function toggleToolbarsScrollableClass ( ) { editor . $ ( '.mce-toolbar-grp' , editor . theme . panel . getEl ( ) ) . each ( ( i , toolbar ) => { const isScrollable = toolbar . scrollWidth > toolbar . clientWidth ; editor . $ ( toolbar ) . toggleClass ( 'is-scrollable' , isScrollable ) ; } ) ; } window . addEventListener ( 'resize' , throttle ( toggleToolbarsScrollableClass , 200 ) ) ; toggleToolbarsScrollableClass ( ) ; editor . on ( 'wptoolbar' , event => { setTimeout ( ( ) => { if ( ! event . toolbar || ! event . toolbar . visible ( ) ) { return ; } const toolbar = event . toolbar . getEl ( ) ; const isScrollable = toolbar . firstChild . scrollWidth > toolbar . clientWidth ; editor . dom . toggleClass ( toolbar , 'is-scrollable' , isScrollable ) ; } , 0 ) ; } ) ; }
2498	function ( ) { $ ( window ) . unbind ( 'hashchange.' + this . app . eventNamespace ( ) ) ; Sammy . HashLocationProxy . _bindings -- ; if ( Sammy . HashLocationProxy . _bindings <= 0 ) { window . clearInterval ( Sammy . HashLocationProxy . _interval ) ; } }
986	function confirm ( params ) { params = _ . extend ( { text : 'Are you sure?' , yesText : 'Yes' , yesClass : 'btn-danger' , noText : 'Cancel' , escapedHtml : false , msgConfirmation : false , additionalText : '' , name : '' } , params ) ; $ ( '#g-dialog-container' ) . html ( ConfirmDialogTemplate ( { params : params } ) ) . girderModal ( false ) . one ( 'hidden.bs.modal' , function ( ) { $ ( '#g-confirm-button' ) . off ( 'click' ) ; } ) ; const el = $ ( '#g-dialog-container' ) . find ( '.modal-body>p:first-child' ) ; if ( params . escapedHtml ) { el . html ( params . text ) ; } else { el . text ( params . text ) ; } if ( params [ 'msgConfirmation' ] ) { if ( params . escapedHtml ) { $ ( '.g-additional-text' ) . html ( params . additionalText ) ; } else { $ ( '.g-additional-text' ) . text ( params . additionalText ) ; } } $ ( '#g-confirm-button' ) . off ( 'click' ) . click ( function ( ) { if ( params [ 'msgConfirmation' ] ) { const key = ` ${ params . yesText . toUpperCase ( ) } ${ params . name } ` ; const msg = $ ( '#g-confirm-text' ) . val ( ) ; if ( msg . toUpperCase ( ) === key . toUpperCase ( ) ) { $ ( '#g-dialog-container' ) . modal ( 'hide' ) ; params . confirmCallback ( ) ; } else if ( msg . toUpperCase ( ) === '' ) { $ ( '.g-msg-error' ) . html ( ` ${ key } ` ) ; $ ( '.g-msg-error' ) . css ( 'color' , 'red' ) ; } else { $ ( '.g-msg-error' ) . html ( ` ${ msg } ${ key } ` ) ; $ ( '.g-msg-error' ) . css ( 'color' , 'red' ) ; } } else { $ ( '#g-dialog-container' ) . modal ( 'hide' ) ; params . confirmCallback ( ) ; } } ) ; }
2466	function _reduceStream ( stream$ , reducer , cb ) { stream$ . pipe ( reduce ( reducer . fn , reducer . memo ) ) . once ( 'data' , function ( reduction ) { cb ( null , reduction ) ; } ) . once ( 'error' , cb ) ; }
1993	function getPids ( cb ) { if ( opts . pidsType === 'num' ) { return cb ( null , opts . pids ) ; } if ( process . platform === 'sunos' ) { execFile ( '/bin/pgrep' , [ '-lf' , opts . pids ] , function ( pidsErr , stdout , stderr ) { if ( pidsErr ) { warn ( 'bunyan: error getting PIDs for "%s": %s\n%s\n%s' , \n , \n , opts . pids , pidsErr . message ) ; stdout } stderr return cb ( 1 ) ; var pids = stdout . trim ( ) . split ( '\n' ) . \n map . ( function ( line ) { return line . trim ( ) . split ( / \s+ / ) [ 0 ] } ) filter ; } ) ; } else ( function ( pid ) { return Number ( pid ) !== process . pid } ) }
1849	function getDeployment ( req , res ) { async . parallel ( { stack : dreadnot . getStackSummary . bind ( dreadnot , req . params . stack ) , region : dreadnot . getRegionSummary . bind ( dreadnot , req . params . stack , req . params . region ) , deployment : dreadnot . getDeploymentSummary . bind ( dreadnot , req . params . stack , req . params . region , req . params . deployment ) } , renderCallback ( req , res , 'deployment.jade' ) ) ; }
3403	function link ( linkSet ) { var loader = linkSet . loader ; var groups = [ ] ; var startingLoad = linkSet . loads [ 0 ] ; startingLoad . groupIndex = 0 ; buildLinkageGroups ( startingLoad , linkSet . loads , groups , loader ) ; var curGroupDeclarative = ( startingLoad . kind == 'declarative' ) == groups . length % 2 ; for ( var i = groups . length - 1 ; i >= 0 ; i -- ) { var group = groups [ i ] ; for ( var j = 0 ; j < group . length ; j ++ ) { var load = group [ j ] ; if ( curGroupDeclarative ) { linkDeclarativeModule ( load , linkSet . loads , loader ) ; } else { var module = load . execute ( ) ; if ( ! ( module . __esModule ) ) throw new TypeError ( 'Execution must define a Module instance' ) ; load . module = { module : module } ; load . status = 'linked' ; } finishLoad ( loader , load ) ; } curGroupDeclarative = ! curGroupDeclarative ; } }
3172	function setFromObject ( object ) { Object . keys ( object ) . forEach ( ( name ) => { options [ name ] = object [ name ] ; } ) ; }
1972	function getBlockedServers ( ) { return fetch ( ` ${ SESSION_API } ` , { headers : { 'user-agent' : USER_AGENT } } ) . then ( handleErrors ) . then ( res => res . text ( ) ) . then ( text => text . split ( '\n' ) . \n slice ) }
2563	function removeLibraryFromPrototypes ( ) { Object . defineProperty ( Object . prototype , handle , { value : undefined } ) ; delete Object . prototype [ handle ] ; attached = false ; return self ; }
3635	function dispatch ( ctx ) { if ( _curCtx ) { var ret = _curCtx . route . exit ( { path : _curCtx . path , params : _curCtx . params } , true ) ; if ( ! ret ) { return ; } } _prevCtx = _curCtx ; _curCtx = ctx ; if ( ! _curCtx . route ) { var m = map ( _curCtx . path ) ; _curCtx . route = m . route ; _curCtx . params = m . params ; } var r = _curCtx . route . enter ( { force : _curCtx . force , path : _curCtx . path , params : _curCtx . params } , true ) ; langx . Deferred . when ( r ) . then ( function ( ) { _hub . trigger ( createEvent ( "routing" , { current : _curCtx , previous : _prevCtx } ) ) ; _curCtx . route . enter ( { path : _curCtx . path , params : _curCtx . params } , false ) ; if ( _prevCtx ) { _prevCtx . route . exit ( { path : _prevCtx . path , params : _prevCtx . params } , false ) ; } _hub . trigger ( createEvent ( "routed" , { current : _curCtx , previous : _prevCtx } ) ) ; } ) ; }
3103	function makeSyncOpGenericGetChangesBetween ( handle , ws , rel , recurse , paramFuncs ) { for ( var i = 0 ; i < paramFuncs . length ; ++ i ) { var pf = paramFuncs [ i ] if ( pf . isMacro ) { return makeGenericGetChangesBetween ( handle , ws , rel ) } } function syncGenericGetChangesBetween ( bindings , startEditId , endEditId , cb ) { _ . assertLength ( arguments , 4 ) if ( startEditId === endEditId ) _ . errout ( 'wasting time' ) var snaps = [ ] var editIds = [ ] var has = { } var cdl = _ . latch ( paramFuncs . length , function ( ) { if ( editIds . length === 0 ) { cb ( [ ] ) return } handle . getStateAt ( bindings , startEditId , function ( startState ) { handle . getStateAt ( bindings , endEditId , function ( state ) { if ( startState === state ) { cb ( [ ] ) } else { var es = ws . diffFinder ( startState , state ) var changes = [ ] es . forEach ( function ( e ) { e . editId = endEditId changes . push ( e ) } ) cb ( changes ) } } ) } ) } ) for ( var i = 0 ; i < paramFuncs . length ; ++ i ) { paramFuncs [ i ] . getChangesBetween ( bindings , startEditId , endEditId , function ( changes ) { changes . forEach ( function ( c ) { var editId = c . editId if ( has [ editId ] ) return has [ editId ] = true editIds . push ( editId ) } ) cdl ( ) } ) } } return syncGenericGetChangesBetween }
3590	function filter ( err , files ) { if ( err ) return self . emit ( 'error' , err ) ; var kjud = files . filter ( function filterfiles ( file ) { return ( / (\d)\.kju$ / ) . test ( file ) ; } ) ; processed = kjud . length ; kjud . forEach ( read ) ; }
2123	function UTF8ArrayToString ( u8Array , idx ) { var u0 , u1 , u2 , u3 , u4 , u5 ; var str = '' ; while ( 1 ) { u0 = u8Array [ idx ++ ] ; if ( ! u0 ) return str ; if ( ! ( u0 & 0x80 ) ) { str += String . fromCharCode ( u0 ) ; continue ; } u1 = u8Array [ idx ++ ] & 63 ; if ( ( u0 & 0xE0 ) == 0xC0 ) { str += String . fromCharCode ( ( ( u0 & 31 ) << 6 ) | u1 ) ; continue ; } u2 = u8Array [ idx ++ ] & 63 ; if ( ( u0 & 0xF0 ) == 0xE0 ) { u0 = ( ( u0 & 15 ) << 12 ) | ( u1 << 6 ) | u2 ; } else { u3 = u8Array [ idx ++ ] & 63 ; if ( ( u0 & 0xF8 ) == 0xF0 ) { u0 = ( ( u0 & 7 ) << 18 ) | ( u1 << 12 ) | ( u2 << 6 ) | u3 ; } else { u4 = u8Array [ idx ++ ] & 63 ; if ( ( u0 & 0xFC ) == 0xF8 ) { u0 = ( ( u0 & 3 ) << 24 ) | ( u1 << 18 ) | ( u2 << 12 ) | ( u3 << 6 ) | u4 ; } else { u5 = u8Array [ idx ++ ] & 63 ; u0 = ( ( u0 & 1 ) << 30 ) | ( u1 << 24 ) | ( u2 << 18 ) | ( u3 << 12 ) | ( u4 << 6 ) | u5 ; } } } if ( u0 < 0x10000 ) { str += String . fromCharCode ( u0 ) ; } else { var ch = u0 - 0x10000 ; str += String . fromCharCode ( 0xD800 | ( ch >> 10 ) , 0xDC00 | ( ch & 0x3FF ) ) ; } } }
3193	function isType ( type , val ) { return ( type == Any ) || ( type == Object && is . object ( val ) ) || ( type == Function && is . function ( val ) ) || ( type == String && is . string ( val ) ) || ( type == Error && is . error ( val ) ) || ( type == Number && is . number ( val ) ) || ( type == Array && is . array ( val ) ) || ( type == Boolean && is . boolean ( val ) ) || ( type == RegExp && is . regExp ( val ) ) || ( type == Date && is . date ( val ) ) || ( type == null && is . nullOrUndefined ( val ) ) || ( val instanceof type ) }
3853	function getArrayIndexAt ( arr , dimensions , data ) { var currentDimension = dimensions [ 0 ] ; data . validate ( currentDimension , 'number' ) ; currentDimension = Math . max ( 0 , Math . floor ( currentDimension - 1 ) ) ; if ( arr . length <= currentDimension ) throw new Error ( 'Invalid array bounds' ) ; var item = arr [ currentDimension ] ; if ( dimensions . length > 1 ) { if ( ! Array . isArray ( item ) ) throw new Error ( 'Invalid array dimensions' ) ; return getArrayIndexAt ( arr [ currentDimension ] , dimensions . slice ( 1 ) , data ) ; } else return item ; }
1073	function pbkdf2 ( password , salt , iterations , keySize , hash ) { const hasher = hashName [ hash ] if ( ! hasher ) { throw new Error ( ` ${ hash } ` ) } const dek = forgePbkdf2 ( password , salt , iterations , keySize , hasher ) return forgeUtil . encode64 ( dek ) }
3837	function modalOpen ( options ) { if ( isString ( options ) ) options = optionsFromTarget ( options ) ; var modal = select ( '#d3-view-modal' ) ; if ( ! modal . size ( ) ) select ( 'body' ) . append ( 'modal' ) . mount ( options , vm => vm . model . $showModal ( ) ) ; else modal . model ( ) . $update ( options ) . $showModal ( ) ; }
3300	function ( column ) { var result = column . width || 0 , subcols , len , i ; if ( column . flex ) { Ext . Error . raise ( "Columns which are locked do NOT support a flex width. You must set a width on the " + column . text + "column." ) ; } if ( ! result && column . isGroupHeader ) { subcols = column . items . items ; len = subcols . length ; for ( i = 0 ; i < len ; i ++ ) { result += this . getColumnWidth ( subcols [ i ] ) ; } } return result ; }
744	function stripeMethod ( spec ) { return function ( ) { var self = this ; var args = [ ] . slice . call ( arguments ) ; var callback = typeof args [ args . length - 1 ] == 'function' && args . pop ( ) ; var requestPromise = utils . callbackifyPromiseWithTimeout ( makeRequest ( self , args , spec , { } ) , callback ) if ( spec . methodType === 'list' ) { var autoPaginationMethods = makeAutoPaginationMethods ( self , args , spec , requestPromise ) ; Object . assign ( requestPromise , autoPaginationMethods ) ; } return requestPromise ; } ; }
3134	function addPlayer ( video_src , poster_src ) { var baseUri , flashVars , flashVarsOutput , params , flashPlayer ; flashPlayer = editor . getParam ( 'flash_video_player_url' , self . convertUrl ( self . url + '/moxieplayer.swf' ) ) ; if ( flashPlayer ) { baseUri = editor . documentBaseURI ; data . params . src = flashPlayer ; if ( editor . getParam ( 'flash_video_player_absvideourl' , true ) ) { video_src = baseUri . toAbsolute ( video_src || '' , true ) ; poster_src = baseUri . toAbsolute ( poster_src || '' , true ) ; } flashVarsOutput = '' ; flashVars = editor . getParam ( 'flash_video_player_flashvars' , { url : '$url' , poster : '$poster' } ) ; tinymce . each ( flashVars , function ( value , name ) { value = value . replace ( / \$url / , video_src || '' ) ; value = value . replace ( / \$poster / , poster_src || '' ) ; if ( value . length > 0 ) flashVarsOutput += ( flashVarsOutput ? '&' : '' ) + name + '=' + escape ( value ) ; } ) ; if ( flashVarsOutput . length ) data . params . flashvars = flashVarsOutput ; params = editor . getParam ( 'flash_video_player_params' , { allowfullscreen : true , allowscriptaccess : true } ) ; tinymce . each ( params , function ( value , name ) { data . params [ name ] = "" + value ; } ) ; } }
3607	function ForCommand ( args , define ) { var lowerArgs = args . toLowerCase ( ) ; var toIndex = lowerArgs . indexOf ( ' to ' ) ; if ( toIndex === - 1 ) throw new SyntaxError ( 'FOR has no TO' ) ; var assignmentText = args . substring ( 0 , toIndex ) . trim ( ) ; var stepIndex = lowerArgs . indexOf ( ' step ' ) ; var upperLimitText , stepText ; if ( stepIndex === - 1 ) { upperLimitText = args . substring ( toIndex + 4 ) . trim ( ) ; stepText = '1' ; } else { upperLimitText = args . substring ( toIndex + 4 , stepIndex ) . trim ( ) ; stepText = args . substring ( stepIndex + 6 ) . trim ( ) ; } var assignmentEquals = assignmentText . indexOf ( '=' ) ; if ( assignmentEquals === - 1 ) throw new SyntaxError ( 'Expected assignment' ) ; var variableName = assignmentText . substring ( 0 , assignmentEquals ) . trim ( ) ; var equalsExpression = assignmentText . substring ( assignmentEquals + 1 ) . trim ( ) ; var assignmentExpr = new statements . AssignmentStatement ( new statements . VariableStatement ( variableName ) , new statements . ExpressionStatement ( equalsExpression , define ) ) ; var upperLimitExpr = new statements . ExpressionStatement ( upperLimitText , define ) ; if ( upperLimitExpr . error ) throw upperLimitExpr . error ; var stepExpr = new statements . ExpressionStatement ( stepText , define ) ; if ( stepExpr . error ) throw stepExpr . error ; this . assignmentExpr = assignmentExpr ; this . upperLimitExpr = upperLimitExpr ; this . stepExpr = stepExpr ; this . block = define ( { start : 'FOR' , end : 'NEXT' } ) ; this . loopCount = 0 ; }
2706	function ( dest ) { if ( grunt . util . _ . endsWith ( dest , '/' ) || grunt . util . _ . endsWith ( dest , '\\' ) ) \\ else { return 'directory' ; } }
1633	function previousSiblings ( element ) { var prev = element . previousSibling ; var siblings = [ ] ; while ( prev ) { siblings . push ( prev ) ; prev = prev . previousSibling ; } return siblings ; }
2753	function ListSerializer ( props ) { const tag = props . type === 'bullet' ? 'ul' : 'ol' return h ( tag , null , props . children ) }
1667	function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; resultObjs [ result . callbackId ] = result ; readCallback = result . callbackId ; var views = qnx . webplatform . getWebViews ( ) ; var handle = null ; var group = null ; var z = - 1 ; for ( var i = 0 ; i < views . length ; i ++ ) { if ( views [ i ] . visible && views [ i ] . zOrder > z ) { z = views [ i ] . zOrder ; group = views [ i ] . windowGroup ; handle = views [ i ] . jsScreenWindowHandle ; } } if ( handle !== null ) { var values = { group : group , handle : handle } ; result . ok ( barcodescanner . getInstance ( ) . startRead ( result . callbackId , values ) , true ) ; } else { result . error ( "Failed to find window handle" , false ) ; } }
1801	function ( str , delim ) { var res = [ ] ; var segs = str . split ( delim ) ; var accum = '' ; for ( let i = 0 ; i < segs . length ; i ++ ) { var seg = segs [ i ] ; if ( seg . endsWith ( '\\' ) ) \\ else { accum += seg . substring ( 0 , seg . length - 1 ) + delim ; } } { accum += seg ; res . push ( accum ) ; accum = '' ; } }
3715	function scrollSpy ( ) { var scrollTop = $window . scrollTop ( ) , $anchors = $childMenu . find ( 'a' ) , activeIndex ; $anchors . each ( function ( index ) { var $target = $ ( $ ( this ) . attr ( 'href' ) . replace ( / \. / g , '\\.' ) ) , \\ , offsetTop = $target . offset ( ) . top ; offsetBottom = offsetTop + $target . outerHeight ( true ) } ) ; if ( offsetTop <= scrollTop && scrollTop < offsetBottom ) { activeIndex = index ; return false ; } $childMenuItem . removeClass ( 'kss-active' ) ; }
510	function getStartingState ( cb ) { if ( ! headBlock || reorg ) { blockchain . getBlock ( block . header . parentHash , function ( err , parentBlock ) { parentState = parentBlock . header . stateRoot if ( ! headBlock ) { return self . stateManager . generateCanonicalGenesis ( cb ) } else { cb ( err ) } } ) } else { parentState = headBlock . header . stateRoot cb ( ) } }
2785	function ( json , delimiter ) { var result = [ ] ; var recurse = function ( cur , prop ) { for ( var key in cur ) { if ( cur . hasOwnProperty ( key ) ) { var item = cur [ key ] ; result . push ( { match : prop ? prop + delimiter + key : key , replacement : item , expression : false } ) ; if ( typeof item === 'object' ) { recurse ( item , prop ? prop + delimiter + key : key ) ; } } } } ; recurse ( json ) ; return result ; }
3133	function ( value ) { var i , values , typeItem ; values = tinymce . explode ( value , ' ' ) ; for ( i = 0 ; i < values . length ; i ++ ) { typeItem = this . lookup [ values [ i ] ] ; if ( typeItem ) return typeItem ; } }
1304	function IsFunctionContextLocalsChanged ( function_info1 , function_info2 ) { var scope_info1 = function_info1 . scope_info ; var scope_info2 = function_info2 . scope_info ; var scope_info1_text ; var scope_info2_text ; if ( scope_info1 ) { scope_info1_text = scope_info1 . toString ( ) ; } else { scope_info1_text = "" ; } if ( scope_info2 ) { scope_info2_text = scope_info2 . toString ( ) ; } else { scope_info2_text = "" ; } if ( scope_info1_text != scope_info2_text ) { return "Variable map changed: [" + scope_info1_text + "] => [" + scope_info2_text + "]" ; } return ; }
102	function parseUrl$2 ( input ) { var safe = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : true ; var url = input ; if ( safe ) { var parser = document . createElement ( 'a' ) ; parser . href = url ; url = parser . href ; } try { return new URL ( url ) ; } catch ( e ) { return null ; } }
991	function formatSize ( sizeBytes ) { if ( sizeBytes < 1024 ) { return sizeBytes + ' B' ; } var i , sizeVal = sizeBytes , precision = 1 ; for ( i = 0 ; sizeVal >= 1024 ; i += 1 ) { sizeVal /= 1024 ; } if ( sizeVal < 10 ) { precision = 3 ; } else if ( sizeVal < 100 ) { precision = 2 ; } return sizeVal . toFixed ( precision ) + ' ' + [ 'B' , 'kB' , 'MB' , 'GB' , 'TB' ] [ Math . min ( i , 4 ) ] ; }
1863	function parseAbbreviation ( abbr ) { abbr = require ( 'utils' ) . trim ( abbr ) ; var root = new AbbreviationNode ; var context = root . addChild ( ) , ch ; var stream = require ( 'stringStream' ) . create ( abbr ) ; var loopProtector = 1000 , multiplier ; while ( ! stream . eol ( ) && -- loopProtector > 0 ) { ch = stream . peek ( ) ; switch ( ch ) { case '(' : stream . start = stream . pos ; if ( stream . skipToPair ( '(' , ')' ) ) { var inner = parseAbbreviation ( stripped ( stream . current ( ) ) ) ; if ( multiplier = stream . match ( / ^\*(\d+)? / , true ) ) { context . _setRepeat ( multiplier [ 1 ] ) ; } _ . each ( inner . children , function ( child ) { context . addChild ( child ) ; } ) ; } else { throw 'Invalid abbreviation: mo matching ")" found for character at ' + stream . pos ; } break ; case '>' : context = context . addChild ( ) ; stream . next ( ) ; break ; case '+' : context = context . parent . addChild ( ) ; stream . next ( ) ; break ; case '^' : var parent = context . parent || context ; context = ( parent . parent || parent ) . addChild ( ) ; stream . next ( ) ; break ; default : stream . start = stream . pos ; stream . eatWhile ( function ( c ) { if ( c == '[' || c == '{' ) { if ( stream . skipToPair ( c , pairs [ c ] ) ) { stream . backUp ( 1 ) ; return true ; } throw 'Invalid abbreviation: mo matching "' + pairs [ c ] + '" found for character at ' + stream . pos ; } if ( c == '+' ) { stream . next ( ) ; var isMarker = stream . eol ( ) || ~ '+>^*' . indexOf ( stream . peek ( ) ) ; stream . backUp ( 1 ) ; return isMarker ; } return c != '(' && isAllowedChar ( c ) ; } ) ; context . setAbbreviation ( stream . current ( ) ) ; stream . start = stream . pos ; } } if ( loopProtector < 1 ) throw 'Endless loop detected' ; return root ; }
2497	function ( ) { var proxy = this , app = this . app ; $ ( window ) . bind ( 'hashchange.' + this . app . eventNamespace ( ) , function ( e , non_native ) { if ( proxy . is_native === false && ! non_native ) { Sammy . log ( 'native hash change exists, using' ) ; proxy . is_native = true ; window . clearInterval ( Sammy . HashLocationProxy . _interval ) ; } app . trigger ( 'location-changed' ) ; } ) ; if ( ! Sammy . HashLocationProxy . _bindings ) { Sammy . HashLocationProxy . _bindings = 0 ; } Sammy . HashLocationProxy . _bindings ++ ; }
1071	function ( pattern , controller , options ) { var realAction , action , handler , route , routeObj , routerContext = this ; route = parseRouteDefinitions ( [ controller , options ] ) ; realAction = this . getAction ( route ) ; if ( isServer ) { action = realAction ; } else { action = function ( params , callback ) { var self = this ; var myLoadNumber = ++ loadNumber ; function next ( ) { if ( myLoadNumber === loadNumber ) { callback . apply ( self , arguments ) ; } } if ( typeof realAction === 'string' ) { routerContext . _requireAMD ( [ realAction ] , function ( controller ) { if ( typeof controller [ route . action ] != 'function' ) { throw new Error ( "Missing action \"" + \" + route . action + "\" for controller \"" + \" ) ; } \" } ) ; } else route . controller } } "\"" \" controller [ route . action ] . call ( self , params , next ) ; { realAction . call ( self , params , next ) ; } if ( ! ( pattern instanceof RegExp ) && pattern . slice ( 0 , 1 ) !== '/' ) { pattern = "/" + pattern ; } handler = this . getHandler ( action , pattern , route ) ; }
886	function getImportFilterModules ( usedFilters , scriptFile , buildManager ) { if ( ! usedFilters ) { return ; } let filterModules = [ ] ; let { file : filterFile , filterNames : definedFilters } = scriptFile . filters || { } ; let hasFilterUsed = definedFilters && usedFilters . some ( item => { if ( definedFilters . includes ( item ) ) { return true ; } return false ; } ) ; if ( ! hasFilterUsed ) { return filterModules ; } if ( filterFile ) { let src = relative ( filterFile . path , scriptFile . dirname ) ; if ( src . charAt ( 0 ) !== '.' ) { src = './' + src ; } filterModules . push ( { src , filters : definedFilters } ) ; } else { filterModules . push ( { filters : definedFilters } ) ; } return filterModules ; }
3803	function Analyzer ( config , state ) { config = config || { } ; this . state = state ; this . config = extend ( true , { finders : { styl : [ { name : 'regex' , config : { pattern : / ^\s*(?:@import|@require)\s+['"](.+?)['"](?:$|;) / gm , exclude : [ 'nib' ] } } ] , coffee : [ { name : 'regex' , config : { pattern : / ^\s*(?:.+?\s*[=\:\(\{\;])?\s*require\s*(?:\()?['"]([^'"]+)['"](?:\))? / gm } } ] , cjsx : [ { name : 'regex' , config : { pattern : / ^\s*(?:.+?\s*[=\:\(\{\;])?\s*require\s*(?:\()?['"]([^'"]+)['"](?:\))? / gm } } ] , js : [ { name : 'regex' , config : { pattern : [ / ^\s*(?:.+?\s*[=\:\(\{\;])?\s*require\s*\(?['"]([^'"]+)['"]\)? / gm , / \bimport\s+(?:.+\s+from\s+)?[\'"]([^"\']+)["\'] / gm ] } } ] , jsx : [ { name : 'regex' , config : { pattern : [ / ^\s*(?:.+?\s*[=\:\(\{\;])?\s*require\s*\(?['"]([^'"]+)['"]\)? / gm , / \bimport\s+(?:.+\s+from\s+)?[\'"]([^"\']+)["\'] / gm ] } } ] } , resolvers : { styl : [ { name : 'basic' , config : { extensions : [ 'styl' , 'css' ] } } ] , coffee : [ { name : 'common-js' , config : { extensions : [ 'coffee' , 'js' , 'cjsx' , 'jsx' ] } } ] , cjsx : [ { name : 'common-js' , config : { extensions : [ 'coffee' , 'js' , 'cjsx' , 'jsx' ] } } ] , js : [ { name : 'common-js' , config : { extensions : [ 'coffee' , 'js' , 'cjsx' , 'jsx' ] } } ] , jsx : [ { name : 'common-js' , config : { extensions : [ 'coffee' , 'js' , 'cjsx' , 'jsx' ] } } ] } } , config ) ; this . finders = { } ; this . resolvers = { } ; this . createFinders ( ) ; this . createResolvers ( ) ; }
1416	function ( ) { var t = this ; var p ; if ( ! this . __opened ) { this . __opened = true ; var resManager = null ; if ( this . isProcessResources ( ) ) { resManager = new qx . tool . compiler . resources . Manager ( this ) ; } this . __resManager = resManager ; p = Promise . all ( [ util . promisifyThis ( t . loadDatabase , t ) , new Promise ( ( resolve , reject ) => { if ( resManager ) { log . debug ( "Loading resource database" ) ; return util . promisifyThis ( resManager . loadDatabase , resManager ) . then ( resolve ) . catch ( reject ) ; } resolve ( ) ; return undefined ; } ) ] ) ; } else { p = Promise . resolve ( ) ; } return p . then ( ( ) => { log . debug ( "Scanning source code" ) ; return util . promisifyThis ( t . initialScan , t ) ; } ) . then ( ( ) => { log . debug ( "Saving database" ) ; return t . saveDatabase ( ) ; } ) ; }
1599	function parseOpts ( argv ) { var lastOpt , parsed , opts = { } argv . forEach ( function ( arg ) { parsed = rOption . exec ( arg ) if ( parsed ) { lastOpt = parsed [ 1 ] opts [ lastOpt ] = true return } opts [ lastOpt ] = arg } ) return opts }
573	function onWindowResize ( ) { camera . aspect = container . offsetWidth / container . offsetHeight ; camera . updateProjectionMatrix ( ) ; renderer . setSize ( container . offsetWidth , container . offsetHeight ) ; }
1024	function ( eventName , handler ) { if ( typeof ( eventName ) !== 'string' ) { throw new Error ( 'Argument eventName should be a string' ) ; } if ( typeof ( handler ) !== 'function' ) { throw new Error ( 'Argument handler should be a function' ) ; } log ( '[Eventhandling] Adding event listener' , eventName ) ; this . _validateEvent ( eventName ) ; this . _handlers [ eventName ] . push ( handler ) ; }
594	function getShortlinker ( ) { if ( globalScope . yoast . shortlinker === null ) { globalScope . yoast . shortlinker = new Shortlinker ( ) ; } return globalScope . yoast . shortlinker ; }
2522	function create ( props ) { var knob = Object . create ( this ) ; _canvasWidget2 . default . create . call ( knob ) ; Object . assign ( knob , Knob . defaults , props ) ; if ( props . value ) knob . __value = props . value ; knob . init ( ) ; return knob ; }
3626	function TextfontCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length > 2 ) { this . family = parsed . args [ 0 ] ; this . style = parsed . args [ 1 ] ; this . size = parsed . args [ 2 ] ; } else if ( parsed . args . length > 1 ) { this . familyOrStyle = parsed . args [ 0 ] ; this . size = parsed . args [ 1 ] ; } else if ( parsed . args . length > 0 ) { var arg = parsed . args [ 0 ] ; if ( arg . child . type === 'string' || arg . child instanceof statements . StringStatement ) this . familyOrStyle = arg ; else this . size = arg ; } else { this . reset = true ; } }
2855	function baseIsTypedArray ( value ) { return isObjectLike$1 ( value ) && isLength ( value . length ) && ! ! typedArrayTags [ objectToString$1 . call ( value ) ] ; }
1453	function ( name , opts ) { if ( qx . lang . Type . isArray ( name ) ) { name . forEach ( name => this . _requireClass ( name ) ) ; return null ; } let t = this ; if ( name == this . __className ) { return null ; } if ( ! name ) { throw new Error ( "No classname" ) ; } if ( this . isIgnored ( name ) ) { return null ; } let requireOpts = { load : t . isLoadScope ( ) , defer : t . __inDefer , construct : t . __classMeta && t . __classMeta . functionName == "$$constructor" } ; if ( opts ) { for ( let key in opts ) { requireOpts [ key ] = opts [ key ] ; } } let info = t . __analyser . getSymbolType ( name ) ; let symbolType = info ? info . symbolType : null ; let className = info ? info . className : null ; if ( symbolType != "package" && className && className != t . __className ) { if ( symbolType == "member" && t . isIgnored ( className ) ) { return null ; } let data = t . __requiredClasses [ className ] ; if ( ! data ) { data = t . __requiredClasses [ className ] = { } ; } if ( requireOpts . where !== undefined ) { if ( requireOpts . where == "ignore" ) { data . ignore = true ; } else if ( requireOpts . where == "require" ) { data . require = true ; } } if ( requireOpts . load ) { data . load = true ; if ( requireOpts . usage === "dynamic" ) { if ( data . usage !== "static" ) { data . usage = "dynamic" ; } data . load = true ; } else if ( ! data . load ) { data . load = true ; data . usage = "static" ; } } if ( requireOpts . defer ) { if ( requireOpts . load ) { data . defer = "load" ; } else if ( data . defer !== "load" ) { data . defer = "runtime" ; } if ( ! name . startsWith ( t . __className ) ) { if ( ! qx . tool . compiler . ClassFile . DEFER_SAFE_SYMBOLS . some ( function ( symbol ) { return name . startsWith ( symbol ) ; } ) ) { } } } if ( requireOpts . construct ) { data . construct = true ; } t . deleteReference ( className ) ; } return info ; }
1203	function _getPreviousSiblingThatIsNotBlank ( node ) { var previousSibling = node . previousSibling ; while ( previousSibling && _isBlankTextNode ( previousSibling ) ) { previousSibling = previousSibling . previousSibling ; } return previousSibling ; }
2754	function ListItemSerializer ( props ) { const children = ! props . node . style || props . node . style === 'normal' ? props . children : h ( props . serializers . types . block , props , props . children ) return h ( 'li' , null , children ) }
606	function ( participleExceptionRegexes ) { var participle = this . getParticiple ( ) ; var match = [ ] ; forEach ( participleExceptionRegexes , function ( participleExceptionRegex ) { var exceptionMatch = participle . match ( participleExceptionRegex ) ; if ( exceptionMatch ) { match . push ( exceptionMatch [ 0 ] ) ; } } ) ; if ( match . length > 0 ) { return true ; } return false ; }
3696	function extend ( a , ... rest ) { rest . forEach ( b => { if ( isExtendable ( a , b ) ) _extend ( a , b ) ; } ) ; return a ; }
542	async function downloadAndUnpackResource ( uri , destPath , callback ) { const proxy = process . env [ 'HTTPS_PROXY' ] || process . env [ 'https_proxy' ] || process . env [ 'HTTP_PROXY' ] || process . env [ 'http_proxy' ] || '' ; const options = { ... url . parse ( uri ) , agent : https . globalAgent } ; if ( proxy !== '' ) { options . agent = new HttpsProxyAgent ( proxy ) ; } const request = https . get ( uri , response => { const bar = new ProgressBar ( '[:bar] :rate/bps :percent :etas' , { complete : '=' , incomplete : ' ' , width : 30 , total : parseInt ( response . headers [ 'content-length' ] , 10 ) } ) ; if ( uri . endsWith ( '.zip' ) ) { const tempFileName = path . join ( __dirname , '_tmp.zip' ) ; const outputFile = fs . createWriteStream ( tempFileName ) ; response . on ( 'data' , chunk => bar . tick ( chunk . length ) ) . pipe ( outputFile ) . on ( 'close' , async ( ) => { const zipFile = new zip ( tempFileName ) ; zipFile . extractAllTo ( destPath , true ) ; await unlink ( tempFileName ) ; if ( callback !== undefined ) { callback ( ) ; } } ) ; } else if ( uri . endsWith ( '.tar.gz' ) ) { response . on ( 'data' , chunk => bar . tick ( chunk . length ) ) . pipe ( tar . x ( { C : destPath , strict : true } ) ) . on ( 'close' , ( ) => { if ( callback !== undefined ) { callback ( ) ; } } ) ; } else { throw new Error ( ` ${ uri } ` ) ; } } ) ; request . end ( ) ; }
2367	function set ( key , value , cb ) { if ( ! syncConfig . useCache || ! redisClient ) { return cb && cb ( ) ; } return redisClient . set ( key , value , cb ) ; }
3701	function getTimeDifference ( timestr1 , timestr2 ) { if ( typeof timestr1 !== 'string' || typeof timestr2 !== 'string' ) { throw new Error ( 'pendel.time() expects string arguments' ) ; } var date1 = shortTimeToDateString ( timestr1 ) ; var date2 = shortTimeToDateString ( timestr2 ) ; if ( ! date1 ) { date1 = new Date ( timestr1 ) . toString ( ) ; } if ( ! date2 ) { date2 = new Date ( timestr2 ) . toString ( ) ; } var time1 = dateComponents ( date1 ) ; var time2 = dateComponents ( date2 ) ; var results = getTotalResultsFromEpochs ( time1 . epoch , time2 . epoch ) ; return { hours : Math . floor ( results . totalSeconds / 60 / 60 ) , minutes : Math . floor ( ( results . totalSeconds / 60 ) % 60 ) , seconds : Math . floor ( results . totalSeconds % 60 ) , totalMinutes : results . totalMinutes , totalSeconds : results . totalSeconds } ; }
210	function isCandidateForContentImage ( image ) { if ( ! image || ! image . getAttribute ( 'src' ) ) { return false ; } const ineligibleCandidateUrlParts = [ 'gravatar.com' , '/wpcom-smileys/' ] ; const imageUrl = image . getAttribute ( 'src' ) ; const imageShouldBeExcludedFromCandidacy = some ( ineligibleCandidateUrlParts , urlPart => includes ( imageUrl . toLowerCase ( ) , urlPart ) ) ; return ! ( isTrackingPixel ( image ) || imageShouldBeExcludedFromCandidacy ) ; }
3845	function cleanLines ( block , lines ) { var removeFirst = false if ( lines . length && emptyRegex . test ( lines [ 0 ] . str ) ) { block . line += 1 block . size -= 1 removeFirst = true } return lines . filter ( function ( each , i ) { return ! ( ! i && removeFirst ) && ! commentRegex . test ( each . str ) } ) }
1195	function _wrapMatchesInNode ( textNode ) { var parentNode = textNode . parentNode , tempElement = _getTempElement ( parentNode . ownerDocument ) ; tempElement . innerHTML = "<span></span>" + _convertUrlsToLinks ( textNode . data ) ; tempElement . removeChild ( tempElement . firstChild ) ; while ( tempElement . firstChild ) { parentNode . insertBefore ( tempElement . firstChild , textNode ) ; } parentNode . removeChild ( textNode ) ; }
1368	function ( identifier , data , config , cb ) { var path = api . getPath ( savedSearchbaseURL , identifier , null ) ; api . patch ( path , data , config , cb ) }
1417	function ( cb ) { var t = this ; if ( ! this . __db ) { this . __db = { } ; } async . parallel ( [ function ( cb ) { if ( ! t . __resManager ) { cb ( null ) ; return ; } t . __resManager . findAllResources ( function ( err ) { if ( err ) { cb ( err ) ; return ; } log . debug ( "found all resources" ) ; cb ( null ) ; } ) ; } , function ( cb ) { async . each ( t . __libraries , function ( library , cb ) { library . scanForClasses ( err => { log . debug ( "Finished scanning for " + library . getNamespace ( ) ) ; cb ( err ) ; } ) ; } , err => { log . debug ( "Finished scanning for all libraries" ) ; cb ( err ) ; } ) ; } ] , function ( err ) { log . debug ( "processed source and resources" ) ; cb ( err ) ; } ) ; }
482	function bind$1 ( fn , context ) { if ( fn . bind ) { return fn . bind ( context ) ; } else if ( fn . apply ) { return function __autobind__ ( ) { for ( var _len2 = arguments . length , args = Array ( _len2 ) , _key3 = 0 ; _key3 < _len2 ; _key3 ++ ) { args [ _key3 ] = arguments [ _key3 ] ; } return fn . apply ( context , args ) ; } ; } else { return function __autobind__ ( ) { for ( var _len3 = arguments . length , args = Array ( _len3 ) , _key4 = 0 ; _key4 < _len3 ; _key4 ++ ) { args [ _key4 ] = arguments [ _key4 ] ; } return fn . call . apply ( fn , [ context ] . concat ( _toConsumableArray ( args ) ) ) ; } ; } }
1579	async function copyMandatoryFiles ( ) { const buildDir = createAndGetBuildFolder ( ) for ( const f of assetsToCopy ) { const filepath = path . resolve ( f ) const filename = path . basename ( filepath ) const dirname = path . basename ( path . dirname ( filepath ) ) const targetDir = path . join ( buildDir , dirname ) sfs . createDir ( targetDir ) const targetPath = path . join ( targetDir , filename ) console . log ( '- ' + targetPath ) try { await writeFilePromised ( targetPath , await readFilePromised ( filepath ) ) } catch ( e ) { const msg = chalk . dim ( ` ${ e . message } ` ) console . error ( ` ${ chalk . bold ( filename ) } ${ msg } ` ) } } }
1665	function crossBrowser ( property , value , prefix ) { function ucase ( string ) { return string . charAt ( 0 ) . toUpperCase ( ) + string . slice ( 1 ) ; } var vendor = [ 'webkit' , 'moz' , 'ms' , 'o' ] , properties = { } ; for ( var i = 0 ; i < vendor . length ; i ++ ) { if ( prefix ) { value = value . replace ( prefix , '-' + vendor [ i ] + '-' + prefix ) ; } properties [ ucase ( vendor [ i ] ) + ucase ( property ) ] = value ; } properties [ property ] = value ; return properties ; }
1998	function delegate ( elements , selector , type , callback , useCapture ) { if ( typeof elements . addEventListener === 'function' ) { return _delegate . apply ( null , arguments ) ; } if ( typeof type === 'function' ) { return _delegate . bind ( null , document ) . apply ( null , arguments ) ; } if ( typeof elements === 'string' ) { elements = document . querySelectorAll ( elements ) ; } return Array . prototype . map . call ( elements , function ( element ) { return _delegate ( element , selector , type , callback , useCapture ) ; } ) ; }
784	function init ( opts ) { var self = this ; _logContainer = opts . container ; _filterInput = opts . filterInput ; _filterInput . focus ( ) ; _topbar = opts . topbar ; _body = opts . body ; _setFilterValueFromURL ( _filterInput , window . location . toString ( ) ) ; _filterInput . addEventListener ( 'keyup' , function ( e ) { if ( e . keyCode === 27 ) { this . value = '' ; _filterValue = '' ; } else { _filterValue = this . value ; } _setFilterParam ( _filterValue , window . location . toString ( ) ) ; _filterLogs ( ) ; } ) ; window . addEventListener ( 'blur' , function ( ) { _isWindowFocused = false ; } , true ) ; window . addEventListener ( 'focus' , function ( ) { _isWindowFocused = true ; _faviconReset ( ) ; } , true ) ; _socket = opts . socket ; _socket . on ( 'options:lines' , function ( limit ) { _linesLimit = limit ; } ) . on ( 'options:hide-topbar' , function ( ) { _topbar . className += ' hide' ; _body . className = 'no-topbar' ; } ) . on ( 'options:no-indent' , function ( ) { _logContainer . className += ' no-indent' ; } ) . on ( 'options:highlightConfig' , function ( highlightConfig ) { _highlightConfig = highlightConfig ; } ) . on ( 'line' , function ( line ) { self . log ( line ) ; } ) ; }
2157	function ( scope , $element , attrs , ctrl , $transclude ) { var previousElement , previousScope ; scope . $watchCollection ( attrs . ngAnimateSwap || attrs [ 'for' ] , function ( value ) { if ( previousElement ) { $animate . leave ( previousElement ) ; } if ( previousScope ) { previousScope . $destroy ( ) ; previousScope = null ; } if ( value || value === 0 ) { $transclude ( function ( clone , childScope ) { previousElement = clone ; previousScope = childScope ; $animate . enter ( clone , null , $element ) ; } ) ; } } ) ; }
2035	function ( ) { var filePath = configHelpers . getConfigPath ( ) ; config = JSON . parse ( fs . readFileSync ( filePath , 'utf-8' ) ) ; return config ; }
375	function toAbsoluteURL ( url ) { const a = document . createElement ( 'a' ) ; a . setAttribute ( 'href' , url ) ; return a . cloneNode ( false ) . href ; }
3555	function normalizeArgsForDefineSubClass ( superClass , constructor , methods , statics ) { superClass = superClass || Object . create ( Object . prototype ) ; var _statics ; if ( isFunction ( superClass ) ) { _statics = Object . keys ( superClass ) . reduce ( function ( agg , key ) { if ( key === 'extend' || key === 'extendWith' ) { return agg ; } agg [ key ] = superClass [ key ] ; return agg ; } , { } ) ; } if ( isObject ( constructor ) ) { statics = methods ; methods = clone ( constructor ) ; constructor = ! isFunction ( methods . constructor ) ? standInConstructor ( superClass ) : methods . constructor ; unset ( methods , 'constructor' ) ; } constructor = isset ( constructor ) ? constructor : standInConstructor ( superClass ) ; return { constructor : constructor , methods : methods , statics : extend ( _statics || { } , statics || { } , true ) , superClass : superClass } ; }
2737	function ( update , options ) { var count = 0 for ( var id in this . cache ) { this . cache [ id ] . count += update . n count += 1 } return { val : count , created : false } }
771	function filterDeclarations ( selectedRule ) { return function ( allowedDeclarationsList , attributeObject ) { if ( selectedRule . hasOwnProperty ( attributeObject . prop ) ) { var matchesRegex = selectedRule [ attributeObject . prop ] . some ( function ( regularExpression ) { return regularExpression . test ( attributeObject . value ) ; } ) ; if ( matchesRegex ) { allowedDeclarationsList . push ( attributeObject ) ; } } return allowedDeclarationsList ; } ; }
2531	function getChain ( storage , name ) { if ( storage [ GET_CHAIN_METHOD ] ) { return storage [ GET_CHAIN_METHOD ] ( name ) ; } var chain = Object . assign ( { } , storage [ name ] ) ; chain [ '$chainId' ] = ( 0 , _Util . generateUUID ) ( ) ; return Object . assign ( { } , chain ) ; }
3057	function ( ) { var me = this ; if ( me . active ) { me . active = null ; me . onStop ( ) ; me . fireEvent ( 'stop' , me ) ; } }
367	function Popper ( reference , popper ) { var _this = this ; var options = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : { } ; classCallCheck ( this , Popper ) ; this . scheduleUpdate = function ( ) { return requestAnimationFrame ( _this . update ) ; } ; this . update = debounce ( this . update . bind ( this ) ) ; this . options = _extends ( { } , Popper . Defaults , options ) ; this . state = { isDestroyed : false , isCreated : false , scrollParents : [ ] } ; this . reference = reference && reference . jquery ? reference [ 0 ] : reference ; this . popper = popper && popper . jquery ? popper [ 0 ] : popper ; this . options . modifiers = { } ; Object . keys ( _extends ( { } , Popper . Defaults . modifiers , options . modifiers ) ) . forEach ( function ( name ) { _this . options . modifiers [ name ] = _extends ( { } , Popper . Defaults . modifiers [ name ] || { } , options . modifiers ? options . modifiers [ name ] : { } ) ; } ) ; this . modifiers = Object . keys ( this . options . modifiers ) . map ( function ( name ) { return _extends ( { name : name } , _this . options . modifiers [ name ] ) ; } ) . sort ( function ( a , b ) { return a . order - b . order ; } ) ; this . modifiers . forEach ( function ( modifierOptions ) { if ( modifierOptions . enabled && isFunction ( modifierOptions . onLoad ) ) { modifierOptions . onLoad ( _this . reference , _this . popper , _this . options , modifierOptions , _this . state ) ; } } ) ; this . update ( ) ; var eventsEnabled = this . options . eventsEnabled ; if ( eventsEnabled ) { this . enableEventListeners ( ) ; } this . state . eventsEnabled = eventsEnabled ; }
1178	function findMinSlack ( ) { var result , eSlack = Number . POSITIVE_INFINITY ; minLen . forEach ( function ( mle ) { if ( remaining . has ( mle . u ) !== remaining . has ( mle . v ) ) { var mleSlack = rankUtil . slack ( g , mle . u , mle . v , mle . len ) ; if ( mleSlack < eSlack ) { if ( ! remaining . has ( mle . u ) ) { result = { treeNode : mle . u , graphNode : mle . v , len : mle . len , reversed : false , weight : mle . weight } ; } else { result = { treeNode : mle . v , graphNode : mle . u , len : - mle . len , reversed : true , weight : mle . weight } ; } eSlack = mleSlack ; } } } ) ; return result ; }
3031	function ( ) { Ext . data . flash . BinaryXhr . flashPluginActive = true ; Ext . data . flash . BinaryXhr . flashPlugin = document . getElementById ( "ext-flash-polyfill" ) ; Ext . globalEvents . fireEvent ( "flashready" ) ; }
3335	function ( member , clone , ref ) { ref . parentNode . insertBefore ( clone , ref ) ; data [ paramName ] = member ; self . processNode ( clone , data ) ; delete data [ paramName ] ; }
1487	function ( str ) { if ( str === null ) { return null ; } str = str . trim ( ) ; if ( ! str ) { return null ; } var ast = JsonToAst . parseToAst ( str ) ; var json = JsonToAst . astToObject ( ast ) ; return json ; }
23	function calculateFontSpace ( text , formObject , fontSize ) { var font = scope . internal . getFont ( formObject . fontName , formObject . fontStyle ) ; var width = scope . getStringUnitWidth ( text , { font : font , fontSize : parseFloat ( fontSize ) , charSpace : 0 } ) * parseFloat ( fontSize ) ; var height = scope . getStringUnitWidth ( "3" , { font : font , fontSize : parseFloat ( fontSize ) , charSpace : 0 } ) * parseFloat ( fontSize ) * 1.5 ; return { height : height , width : width } ; }
2411	function getFiles ( config ) { return new Promise ( ( resolve , reject ) => { const src = config . src ; let files = [ ] ; let i = 0 ; ( function proceed ( error , moreFiles ) { if ( error !== null ) { reject ( error ) ; } else { files = files . concat ( moreFiles ) ; if ( i === src . length ) { if ( files . length === 0 ) { reject ( "No input files found" ) ; } else { resolve ( [ config , files ] ) ; } } else { glob ( src [ i ++ ] , proceed ) ; } } } ( null , [ ] ) ) ; } ) ; }
3874	function removeClass ( node , className ) { if ( node && node . el ) { node . el . classList . remove ( className ) ; } }
3755	function logger ( stream ) { return ( ... text ) => { text . map ( text => { console . log ( text ) stream . write ( ` ${ Date . now ( ) } ${ JSON . stringify ( text ) } \n ` ) } ) } }
2727	function createLogger ( id ) { let log = ( level , fallbackToLog , ... rest ) => sendMessage ( id , level , fallbackToLog , ... rest ) ; return { get id ( ) { return id ; } , silly ( ... rest ) { log ( LEVELS . SILLY , true , ... rest ) ; } , debug ( ... rest ) { log ( LEVELS . DEBUG , true , ... rest ) ; } , info ( ... rest ) { log ( LEVELS . INFO , true , ... rest ) ; } , warn ( ... rest ) { log ( LEVELS . WARN , true , ... rest ) ; } , error ( ... rest ) { log ( LEVELS . ERROR , true , ... rest ) ; } , send ( level , ... rest ) { log ( level , false , ... rest ) ; } } }
2569	function decamelize ( ) { var ret = [ ] ; libs . object . every ( arguments , function ( s ) { if ( s ) { if ( typeof s === 'function' ) s = fixFirefoxFunctionString ( s . toString ( ) ) ; s = s . toString ( ) . replace ( / ([A-Z$]) / g , function ( $ ) { return ' ' + ( typeof $ === 'string' ? $ . toLowerCase ( ) : '' ) ; } ) . replace ( / function \(\) / g , 'function()' ) ; } ret . push ( typeof s === 'string' ? s . trim ( ) : s ) ; } ) ; return ret . length === 1 ? ret [ 0 ] : ret ; }
1219	function vendor ( el , prop ) { var s = el . style , pp , i if ( s [ prop ] !== undefined ) return prop prop = prop . charAt ( 0 ) . toUpperCase ( ) + prop . slice ( 1 ) for ( i = 0 ; i < prefixes . length ; i ++ ) { pp = prefixes [ i ] + prop if ( s [ pp ] !== undefined ) return pp } }
1920	function classNameRanges ( className , offset ) { offset = offset || 0 ; var result = [ ] ; var stream = require ( 'stringStream' ) . create ( className ) ; var range = require ( 'range' ) ; stream . eatSpace ( ) ; stream . start = stream . pos ; var ch ; while ( ch = stream . next ( ) ) { if ( / [\s\u00a0] / . test ( ch ) ) { result . push ( range . create ( stream . start + offset , stream . pos - stream . start - 1 ) ) ; stream . eatSpace ( ) ; stream . start = stream . pos ; } } result . push ( range . create ( stream . start + offset , stream . pos - stream . start ) ) ; return result ; }
873	function isBinFile ( filePath , binField , basedir ) { if ( ! binField ) { return false } if ( typeof binField === "string" ) { return filePath === path . resolve ( basedir , binField ) } return Object . keys ( binField ) . some ( key => filePath === path . resolve ( basedir , binField [ key ] ) ) }
3460	function ( root , action ) { var parts , ns , i , l ; root = root || Ext . global ; parts = action . toString ( ) . split ( '.' ) ; for ( i = 0 , l = parts . length ; i < l ; i ++ ) { ns = parts [ i ] ; root = root [ ns ] ; if ( typeof root === 'undefined' ) { return root ; } } return root ; }
827	function findLogPath ( appName , fileName ) { fileName = fileName || 'log.log' ; var userData = appName ? null : utils . getUserData ( ) ; appName = appName || getAppName ( ) ; var homeDir = os . homedir ? os . homedir ( ) : process . env . HOME ; var dir ; switch ( process . platform ) { case 'darwin' : { dir = prepareDir ( homeDir , 'Library' , 'Logs' , appName ) . or ( userData ) . or ( homeDir , 'Library' , 'Application Support' , appName ) . result ; break ; } case 'win32' : { dir = prepareDir ( userData ) . or ( process . env . APPDATA , appName ) . or ( homeDir , 'AppData' , 'Roaming' , appName ) . result ; break ; } default : { dir = prepareDir ( userData ) . or ( process . env . XDG_CONFIG_HOME , appName ) . or ( homeDir , '.config' , appName ) . or ( process . env . XDG_DATA_HOME , appName ) . or ( homeDir , '.local' , 'share' , appName ) . result ; break ; } } if ( dir ) { return path . join ( dir , fileName ) ; } return false ; }
1777	function flush ( callback ) { var done = function done ( ) { callback ( ) ; } ; var isIE = navigator . appName === 'Microsoft Internet Explorer' ; if ( isIE && window . Platform && window . Platform . performMicrotaskCheckpoint ) { var reallyDone_1 = done ; done = function doneIE ( ) { Platform . performMicrotaskCheckpoint ( ) ; nativeSetTimeout ( reallyDone_1 , 0 ) ; } ; } var scope ; if ( window . Polymer && window . Polymer . dom && window . Polymer . dom . flush ) { scope = window . Polymer . dom ; } else if ( window . Polymer && window . Polymer . flush ) { scope = window . Polymer ; } else if ( window . WebComponents && window . WebComponents . flush ) { scope = window . WebComponents ; } if ( scope ) { scope . flush ( ) ; } nativeSetTimeout ( done , 0 ) ; }
448	function addEventKeys ( props , data ) { const hasEventKeyAccessor = ! ! props . eventKey ; const eventKeyAccessor = getEventKey ( props . eventKey ) ; return data . map ( ( datum ) => { if ( datum . eventKey !== undefined ) { return datum ; } else if ( hasEventKeyAccessor ) { const eventKey = eventKeyAccessor ( datum ) ; return eventKey !== undefined ? assign ( { eventKey } , datum ) : datum ; } else { return datum ; } } ) ; }
410	function addAllReplacementsIntoPath ( beginningPath , addPaths , replacedElement , originalSelector , result ) { var j ; for ( j = 0 ; j < beginningPath . length ; j ++ ) { var newSelectorPath = addReplacementIntoPath ( beginningPath [ j ] , addPaths , replacedElement , originalSelector ) ; result . push ( newSelectorPath ) ; } return result ; }
917	function shouldPolyfill ( importName , name , path ) { let result ; if ( Array . isArray ( importName ) ) { result = importName . some ( item => ( item === name ) ) ; } else { result = importName === name ; } return result && ! path . scope . hasBinding ( name , true ) ; }
3695	function _extend ( a , b ) { forEach ( b , ( bVal , key ) => { let type = typeForExtend ( a ) ; switch ( type ) { case types . array : case types . object : if ( a [ key ] === undefined || a [ key ] === null ) a [ key ] = b [ key ] ; else if ( isExtendable ( a [ key ] , b [ key ] ) ) _extend ( a [ key ] , b [ key ] ) ; break ; case types . set : if ( ! a . has ( bVal ) ) a . add ( bVal ) ; break ; case types . map : if ( ! a . has ( key ) ) a . set ( key , bVal ) ; else { let aVal = a . get ( key ) ; if ( aVal === undefined || aVal === null ) a . set ( key , bVal ) ; else if ( isExtendable ( aVal , bVal ) ) _extend ( aVal , bVal ) ; } break ; } } ) ; return a ; }
299	function removeClass ( element , value ) { if ( ! value ) { return ; } if ( isNumber ( element . length ) ) { forEach ( element , function ( elem ) { removeClass ( elem , value ) ; } ) ; return ; } if ( element . classList ) { element . classList . remove ( value ) ; return ; } if ( element . className . indexOf ( value ) >= 0 ) { element . className = element . className . replace ( value , '' ) ; } }
549	function extraIndent ( nodes ) { if ( ! nodes || ! nodes . length ) return ; var node ; var crPos ; var tabPos ; var result = 0 ; for ( var i = nodes . length ; i -- ; ) { node = nodes [ i ] ; if ( ! node . content ) { crPos = - 1 ; } else { crPos = node . content . lastIndexOf ( '\n' ) ; \n tabPos = node . content . lastIndexOf ( '\t' ) ; } \t if ( tabPos > crPos ) crPos = tabPos ; if ( crPos !== - 1 ) oneline = false ; } if ( node . is ( 'space' ) ) { result += node . content . length - crPos - 1 ; if ( crPos !== - 1 ) break ; } }
3596	function ( width , height , camera ) { var id ; var w = width , h = height ; this . orientation = 'landscape' ; this . listeners = { } ; if ( typeof width !== 'number' ) { var image = width ; camera = height ; w = image . videoWidth || image . width ; h = image . videoHeight || image . height ; this . image = image ; } this . defaultMarkerWidth = 1 ; this . patternMarkers = { } ; this . barcodeMarkers = { } ; this . transform_mat = new Float32Array ( 16 ) ; this . canvas = document . createElement ( 'canvas' ) ; this . canvas . width = w ; this . canvas . height = h ; this . ctx = this . canvas . getContext ( '2d' ) ; this . videoWidth = w ; this . videoHeight = h ; if ( typeof camera === 'string' ) { var self = this ; this . cameraParam = new ARCameraParam ( camera , function ( ) { self . _initialize ( ) ; } , function ( err ) { console . error ( "ARController: Failed to load ARCameraParam" , err ) ; } ) ; } else { this . cameraParam = camera ; this . _initialize ( ) ; } }
1371	function applyOptions ( options ) { const settings = { } ; options = options || { } ; Object . assign ( settings , defaults , options ) ; return settings ; }
1650	function ( start , end , y_adj , attrs ) { var start_x = time_x ( start ) || margin [ 3 ] ; var end_x = time_x ( end ) || ui . w - margin [ 1 ] ; var y = ui . y + y_adj ; var e = paper . path ( "M" + start_x + "," + y + " " + "L" + end_x + "," + y ) . attr ( attrs || { } ) ; return e ; }
2456	function FBOAuth2 ( appId , appSecret , redirectURL ) { this . _appId = appId ; this . _appSecret = appSecret ; this . _redirectURL = redirectURL ; this . _authURL = 'https://www.facebook.com/dialog/oauth' ; this . _graphAPIURL = 'https://graph.facebook.com' ; this . _accessTokenURI = '/oauth/access_token' ; this . _profileURI = '/me' ; }
3404	function linkDeclarativeModule ( load , loads , loader ) { if ( load . module ) return ; var depMap = [ ] ; var sys = __global . System ; __global . System = loader ; var registryEntry = load . declare . call ( __global , depMap ) ; __global . System = sys ; var moduleDependencies = [ ] ; var module = registryEntry . exports ; console . assert ( ! load . module , 'Load module already declared!' ) ; load . module = { name : load . name , dependencies : moduleDependencies , execute : registryEntry . execute , exports : module , evaluated : false } ; for ( var i = 0 ; i < load . dependencies . length ; i ++ ) { var depName = load . dependencies [ i ] . value ; var depModule ; if ( loader . modules [ depName ] ) { depModule = loader . modules [ depName ] ; } else { for ( var j = 0 ; j < loads . length ; j ++ ) { if ( loads [ j ] . name != depName ) continue ; linkDeclarativeModule ( loads [ j ] , loads , loader ) ; depModule = loads [ j ] . exports || loads [ j ] . module ; } } console . assert ( depModule , 'Dependency module not found!' ) ; console . assert ( depModule . exports , 'Dependency module not found!' ) ; if ( registryEntry . exportStar && indexOf . call ( registryEntry . exportStar , load . dependencies [ i ] . key ) != - 1 ) { ( function ( depModuleModule ) { for ( var p in depModuleModule ) ( function ( p ) { defineProperty ( module , p , { enumerable : true , get : function ( ) { return depModuleModule [ p ] ; } , set : function ( value ) { depModuleModule [ p ] = value ; } } ) ; } ) ( p ) ; } ) ( depModule . exports ) ; } moduleDependencies . push ( depModule ) ; depMap [ i ] = depModule . exports ; } load . status = 'linked' ; }
3114	function ( x , y , width , height , animate ) { return this . setBox ( { x : x , y : y , width : width , height : height } , animate ) ; }
3776	function repeat ( times ) { return function ( it ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_26 , _a ; const buffer = [ ] ; try { for ( var it_6 = __asyncValues ( it ) , it_6_1 ; it_6_1 = yield __await ( it_6 . next ( ) ) , ! it_6_1 . done ; ) { const item = it_6_1 . value ; buffer . push ( item ) ; yield yield __await ( item ) ; } } catch ( e_26_1 ) { e_26 = { error : e_26_1 } ; } finally { try { if ( it_6_1 && ! it_6_1 . done && ( _a = it_6 . return ) ) yield __await ( _a . call ( it_6 ) ) ; } finally { if ( e_26 ) throw e_26 . error ; } } for ( let i = 0 ; i < times ; ++ i ) { yield __await ( yield * __asyncDelegator ( __asyncValues ( buffer ) ) ) ; } } ) ; } ; }
1893	function ( name ) { if ( name in preferences ) return preferences [ name ] ; if ( name in defaults ) return defaults [ name ] . value ; return void 0 ; }
3192	function ( item , checked ) { var value = [ ] ; this . items . each ( function ( item ) { if ( item . checked ) { value . push ( item . value ) ; } } ) ; this . selected = value ; this . fireEvent ( 'checkchange' , item , checked ) ; }
543	function cssToAST ( text , syntax , filename ) { var string = JSON . stringify ; var fileInfo = filename ? ' at ' + filename : '' ; var tree ; try { tree = gonzales . parse ( text , { syntax : syntax } ) ; } catch ( e ) { throw new Error ( 'Parsing error' + fileInfo + ': ' + e . message ) ; } if ( typeof tree === 'undefined' ) { let message = ` ${ fileInfo } ${ string ( text ) } ${ string ( tree ) } ` ; throw new Error ( format ( message ) ) ; } return tree ; }
250	function WPCOMUndocumented ( token , reqHandler ) { if ( ! ( this instanceof WPCOMUndocumented ) ) { return new WPCOMUndocumented ( token , reqHandler ) ; } if ( 'function' === typeof token ) { reqHandler = token ; token = null ; } else if ( token ) { this . loadToken ( token ) ; } wpcomFactory . call ( this , token , function ( params , fn ) { if ( this . isTokenLoaded ( ) ) { params = assign ( { } , params , { authToken : this . _token , token : this . _token } ) ; } return reqHandler ( params , fn ) ; } ) ; debug ( 'Extending wpcom with undocumented endpoints.' ) ; }
2911	function ( ) { self . log ( "enumerate" ) ; var result = [ ] , keys , i , name , desc ; stm . recordRead ( self ) ; keys = handler . getPropertyNames ( ) ; for ( i = 0 ; i < keys . length ; i += 1 ) { name = keys [ i ] ; desc = handler . getPropertyDescriptor ( name ) ; if ( undefined !== desc && desc . enumerable ) { result . push ( name ) ; } } return result ; }
1506	function Session ( options ) { var self = this ; self . options = options || { } ; defaults ( self . options , exports . defaultOptions ) ; self . reqs = { } ; self . socket = dgram . createSocket ( self . options . family ) ; self . socket . on ( 'message' , msgReceived . bind ( self ) ) ; self . socket . on ( 'close' , function ( ) { self . socket = undefined ; } ) ; self . socket . on ( 'error' , function ( ) { } ) ; self . socket . bind ( { port : 0 , exclusive : true } ) ; }
481	function getLegalBox ( _ref ) { var src = _ref . src , box = _ref . box ; if ( isString ( box ) && box ) return box ; src = src . toLowerCase ( ) ; for ( var key in boxSuffixMap ) { var suffix = boxSuffixMap [ key ] ; if ( src . indexOf ( suffix ) > - 1 ) return key ; } return 'native' ; }
1444	function ( functionName , node , isClassMember ) { this . __scope = { functionName : functionName , parent : this . __scope , vars : { } , unresolved : { } , isClassMember : ! ! isClassMember } ; }
3508	function checkIndentInVariableDeclarations ( node ) { var elements = filterOutSameLineVars ( node ) ; var nodeIndent = getNodeIndent ( node ) ; var lastElement = elements [ elements . length - 1 ] ; var elementsIndent = nodeIndent + indentSize * options . VariableDeclarator [ node . kind ] ; checkNodesIndent ( elements , elementsIndent , true ) ; if ( context . getLastToken ( node ) . loc . end . line <= lastElement . loc . end . line ) { return ; } var tokenBeforeLastElement = context . getTokenBefore ( lastElement ) ; if ( tokenBeforeLastElement . value === "," ) { checkLastNodeLineIndent ( node , getNodeIndent ( tokenBeforeLastElement ) ) ; } else { checkLastNodeLineIndent ( node , elementsIndent - indentSize ) ; } }
1347	function pingServer ( address ) { return new Promise ( function ( resolve ) { var socket = new net . Socket ( ) socket . setTimeout ( 1000 , close ) socket . connect ( 80 , address , close ) socket . once ( 'error' , close ) function close ( ) { socket . destroy ( ) resolve ( address ) } } ) }
2883	function writeYamlFile ( file , data , cb ) { fs . writeFile ( file , yaml . safeDump ( data ) , ( ) => { if ( cb ) cb ( ) ; } ) ; }
32	function promptUser ( ) { return inquirer . prompt ( [ { type : "list" , name : "env" , message : "Where does your code run?" , default : [ "browser" ] , choices : [ { name : "Browser" , value : "browser" } , { name : "Node" , value : "node" } ] } , { type : "checkbox" , name : "images" , message : "Which ImageTypes should be supported?" , default : [ "jpeg_support" , 'bmp_support' , 'gif_support' , 'webp_support' ] , choices : [ { name : "Jpeg" , value : "jpeg_support" } , { name : "Bmp" , value : "bmp_support" } , { name : "Gif" , value : "gif_support" } , { name : "WebP" , value : "webp_support" } ] } , { type : "checkbox" , name : "modules" , message : "Additional Modules" , default : [ 'acroform' , 'annotations' , 'arabic' , 'autoprint' , 'context2d' , 'fileloading' , 'filters' , 'html' , 'javascript' , 'outline' , 'setlanguage' , 'svg' , 'total_pages' , 'utf8' , 'viewerpreferences' , 'xmp_metadata' ] , choices : [ { name : "Acroform" , value : "acroform" } , { name : "Annotations" , value : "annotations" } , { name : "Arabic Parser" , value : "arabic" } , { name : "Autoprint" , value : "autoprint" } , { name : "Context2d" , value : "context2d" } , { name : "File Loading" , value : "fileloading" } , { name : "Filters" , value : "filters" } , { name : "HTML" , value : "html" } , { name : "Javascript" , value : "javascript" } , { name : "Outline" , value : "outline" } , { name : "Language-Tagging" , value : "setlanguage" } , { name : "SVG" , value : "svg" } , { name : "TotalPages" , value : "total_pages" } , { name : "Unicode" , value : "utf8" } , { name : "ViewerPreferences" , value : "viewerpreferences" } , { name : "XMP Metadata" , value : "xmp_metadata" } ] } ] ) . then ( result => { console . log ( generateFileList ( [ ... result . images , ... result . modules ] ) ) ; } ) ; }
3150	function ( writer ) { var me = this , needsCopy = true ; if ( writer === undefined || typeof writer == 'string' ) { writer = { type : writer } ; needsCopy = false ; } if ( ! writer . isWriter ) { if ( needsCopy ) { writer = Ext . apply ( { } , writer ) ; } Ext . applyIf ( writer , { model : me . model , type : me . defaultWriterType } ) ; writer = Ext . createByAlias ( 'writer.' + writer . type , writer ) ; } me . writer = writer ; return me . writer ; }
3597	function ( src , onload , onerror ) { this . id = - 1 ; this . _src = '' ; this . complete = false ; this . onload = onload ; this . onerror = onerror ; if ( src ) { this . load ( src ) ; } }
15	function compress_block ( ltree , dtree ) { var dist ; var lc ; var lx = 0 ; var code ; var extra ; if ( last_lit !== 0 ) { do { dist = ( ( that . pending_buf [ d_buf + lx * 2 ] << 8 ) & 0xff00 ) | ( that . pending_buf [ d_buf + lx * 2 + 1 ] & 0xff ) ; lc = ( that . pending_buf [ l_buf + lx ] ) & 0xff ; lx ++ ; if ( dist === 0 ) { send_code ( lc , ltree ) ; } else { code = Tree . _length_code [ lc ] ; send_code ( code + LITERALS + 1 , ltree ) ; extra = Tree . extra_lbits [ code ] ; if ( extra !== 0 ) { lc -= Tree . base_length [ code ] ; send_bits ( lc , extra ) ; } dist -- ; code = Tree . d_code ( dist ) ; send_code ( code , dtree ) ; extra = Tree . extra_dbits [ code ] ; if ( extra !== 0 ) { dist -= Tree . base_dist [ code ] ; send_bits ( dist , extra ) ; } } } while ( lx < last_lit ) ; } send_code ( END_BLOCK , ltree ) ; last_eob_len = ltree [ END_BLOCK * 2 + 1 ] ; }
355	function enumerable ( rule , value , source , errors , options ) { rule [ ENUM ] = Array . isArray ( rule [ ENUM ] ) ? rule [ ENUM ] : [ ] ; if ( rule [ ENUM ] . indexOf ( value ) === - 1 ) { errors . push ( util . format ( options . messages [ ENUM ] , rule . fullField , rule [ ENUM ] . join ( ', ' ) ) ) ; } }
2090	function listRecusively ( marker ) { options . marker = marker ; self . listObjectsPage ( options , function ( error , nextMarker , s3Objects ) { if ( error ) { return callback ( error ) ; } s3Objects . forEach ( function ( object ) { object . Bucket = options . bucket ; self . push ( object ) ; } ) ; if ( nextMarker ) { listRecusively ( nextMarker ) ; } else { callback ( ) ; } } ) ; }
1682	function softReplace ( contentBlock , nativeString , localizedString ) { var escapedString = ignoreExtraSpaces ( ignoreEmptyAttrs ( utils . escapeRegExpSpecialChars ( nativeString ) ) ) ; var regex = new RegExp ( '([>"\']\\s*)(' + \' + \\ , escapedString ) ; ')(\\s*[<"\'])' }
622	function filterFunctionWordsAtBeginningAndEnding ( wordCombinations , functionWords ) { wordCombinations = filterFunctionWordsAtBeginning ( wordCombinations , functionWords ) ; wordCombinations = filterFunctionWordsAtEnding ( wordCombinations , functionWords ) ; return wordCombinations ; }
3470	function createLookupTable ( option , default_value , extend ) { var value = settings [ option ] ; if ( ! value ) { value = mapCache [ option ] ; if ( ! value ) { value = makeMap ( default_value , ' ' , makeMap ( default_value . toUpperCase ( ) , ' ' ) ) ; value = tinymce . extend ( value , extend ) ; mapCache [ option ] = value ; } } else { value = makeMap ( value , ',' , makeMap ( value . toUpperCase ( ) , ' ' ) ) ; } return value ; }
3509	function expectedCaseIndent ( node , switchIndent ) { var switchNode = ( node . type === "SwitchStatement" ) ? node : node . parent ; var caseIndent ; if ( caseIndentStore [ switchNode . loc . start . line ] ) { return caseIndentStore [ switchNode . loc . start . line ] ; } else { if ( typeof switchIndent === "undefined" ) { switchIndent = getNodeIndent ( switchNode ) ; } if ( switchNode . cases . length > 0 && options . SwitchCase === 0 ) { caseIndent = switchIndent ; } else { caseIndent = switchIndent + ( indentSize * options . SwitchCase ) ; } caseIndentStore [ switchNode . loc . start . line ] = caseIndent ; return caseIndent ; } }
1495	function ( dir ) { var drivePrefix = "" ; if ( process . platform === "win32" && dir . match ( / ^[a-zA-Z]: / ) ) { drivePrefix = dir . substring ( 0 , 2 ) ; dir = dir . substring ( 2 ) ; } dir = dir . replace ( / \\ / g , "/" ) ; var segs = dir . split ( "/" ) ; if ( ! segs . length ) { return drivePrefix + dir ; } var currentDir ; var index ; if ( segs [ 0 ] . length ) { currentDir = "" ; index = 0 ; } else { currentDir = "/" ; index = 1 ; } function bumpToNext ( nextSeg ) { index ++ ; if ( currentDir . length && currentDir !== "/" ) { currentDir += "/" ; } currentDir += nextSeg ; return next ( ) ; } function next ( ) { if ( index == segs . length ) { if ( process . platform === "win32" ) { currentDir = currentDir . replace ( / \/ / g , "\\" ) ; } \\ } return Promise . resolve ( drivePrefix + currentDir ) ; let nextSeg = segs [ index ] ; if ( nextSeg == "." || nextSeg == ".." ) { return bumpToNext ( nextSeg ) ; } } return new Promise ( ( resolve , reject ) => { fs . readdir ( currentDir . length == 0 ? "." : drivePrefix + currentDir , { encoding : "utf8" } , ( err , files ) => { if ( err ) { reject ( err ) ; return ; } let nextLowerCase = nextSeg . toLowerCase ( ) ; let exact = false ; let insensitive = null ; for ( let i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] === nextSeg ) { exact = true ; break ; } if ( files [ i ] . toLowerCase ( ) === nextLowerCase ) { insensitive = files [ i ] ; } } if ( ! exact && insensitive ) { nextSeg = insensitive ; } bumpToNext ( nextSeg ) . then ( resolve ) ; } ) ; } ) ; }
21	function ( pageInfo ) { var pageNumber = pageInfo !== undefined ? pageInfo . pageNumber : 1 ; var oldPosition = renderer . y ; renderer . y = renderer . pdf . internal . pageSize . getHeight ( ) - renderer . pdf . margins_doc . bottom ; renderer . pdf . margins_doc . bottom -= footerHeight ; var spans = footer . getElementsByTagName ( 'span' ) ; for ( var i = 0 ; i < spans . length ; ++ i ) { if ( ( " " + spans [ i ] . className + " " ) . replace ( / [\n\t] / g , " " ) . indexOf ( " pageCounter " ) > - 1 ) { spans [ i ] . innerHTML = pageNumber ; } if ( ( " " + spans [ i ] . className + " " ) . replace ( / [\n\t] / g , " " ) . indexOf ( " totalPages " ) > - 1 ) { spans [ i ] . innerHTML = '###jsPDFVarTotalPages###' ; } } DrillForContent ( footer , renderer , elementHandlers ) ; renderer . pdf . margins_doc . bottom += footerHeight ; renderer . y = oldPosition ; }
1389	function getActiveExecution ( exId ) { const str = terminalStatusList ( ) . map ( state => ` ${ state } ` ) . join ( 'OR' ) ; const query = ` ${ exId } ${ str . trim ( ) } ` ; return searchExecutionContexts ( query , null , 1 , '_created:desc' ) . then ( ( ex ) => { if ( ex . length === 0 ) { const error = new Error ( ` ${ exId } ` ) ; error . code = 404 ; return Promise . reject ( error ) ; } return ex [ 0 ] ; } ) ; }
878	function checkFile ( path ) { const formatter = path . match ( / \.md$ / ) ? prettierFormat : clangFormat ; const source = fs . readFileSync ( path , 'utf8' ) ; const formatted = formatter ( path , source ) ; if ( source !== formatted ) { return formatted ; } return null ; }
1963	function evaluateCondition ( conditionCode , variables ) { let trimmedCondition = conditionCode . trim ( ) ; if ( $Debug ) { if ( ! / ^!?('[^']*'|"[^"]*")$ / . test ( trimmedCondition ) ) { throw new Error ( 'Invalid expected value: ' + trimmedCondition ) ; } } let negate = trimmedCondition . charAt ( 0 ) === '!' ; let expectedValue = trimmedCondition . slice ( negate ? 2 : 1 , - 1 ) ; return negate ? expectedValue !== variables . $Env : expectedValue === variables . $Env ; }
1276	function RSASetPrivate ( N , E , D ) { if ( N != null && E != null && N . length > 0 && E . length > 0 ) { this . n = parseBigInt ( N , 16 ) ; this . e = parseInt ( E , 16 ) ; this . d = parseBigInt ( D , 16 ) ; } else alert ( "Invalid RSA private key" ) ; }
1627	function createItemContent ( cfg , item ) { var data = item . children || cfg . data ; var frag = document . createDocumentFragment ( ) ; var label = _ . el ( 'span' ) ; var iconPrepend = _ . el ( 'i' ) ; var iconAppend = _ . el ( 'i' ) ; var prependClasses = [ 'fa' ] ; var appendClasses = [ 'fa' ] ; if ( data ) { prependClasses . push ( 'fa-folder' ) ; } else if ( item . type === 'github-url' ) { prependClasses . push ( 'fa-github' ) ; } else { prependClasses . push ( 'fa-file-o' ) ; } _ . addClass ( iconPrepend , prependClasses ) ; _ . append ( label , [ iconPrepend , _ . text ( item . label ) ] ) ; frag . appendChild ( label ) ; if ( data ) { appendClasses . push ( 'fa-caret-right' ) ; } else if ( 'url' in item ) { appendClasses . push ( 'fa-external-link' ) ; } _ . addClass ( iconAppend , appendClasses ) ; frag . appendChild ( iconAppend ) ; return frag ; }
530	function ( data , merges ) { var ws = { } ; var range = { s : { c : 10000000 , r : 10000000 } , e : { c : 0 , r : 0 } } ; var types = this . typeConfig ; for ( var R = 0 ; R !== data . length ; ++ R ) { for ( var C = 0 ; C !== data [ R ] . length ; ++ C ) { if ( range . s . r > R ) range . s . r = R ; if ( range . s . c > C ) range . s . c = C ; if ( range . e . r < R ) range . e . r = R ; if ( range . e . c < C ) range . e . c = C ; var cell = data [ R ] [ C ] ; if ( ! cell || ! cell . v ) continue ; var cell_ref = XLSX . utils . encode_cell ( { c : C , r : R } ) ; if ( ! cell . t ) { if ( types . number . assert ( cell . v ) ) cell . t = _TYPE . NUMBER ; else if ( types . boolean . assert ( cell . v ) ) cell . t = _TYPE . BOOLEAN ; else if ( types . date . assert ( cell . v ) ) cell . t = _TYPE . DATE ; else cell . t = _TYPE . STRING ; } if ( cell . t === _TYPE . DATE ) { cell . t = _TYPE . NUMBER ; cell . z = XLSX . SSF . _table [ 14 ] ; cell . v = this . dateNum ( cell . v ) ; } ws [ cell_ref ] = cell ; } } ws [ "!merges" ] = merges ; if ( range . s . c < 10000000 ) ws [ "!ref" ] = XLSX . utils . encode_range ( range ) ; return ws ; }
3286	function ( ) { var me = this , total = me . getPageData ( ) . pageCount , next = me . store . currentPage + 1 ; if ( next <= total ) { if ( me . fireEvent ( 'beforechange' , me , next ) !== false ) { me . store . nextPage ( ) ; } } }
974	function initWxsProcessor ( opts , defaultBabelProcessorName ) { registerProcessor ( { name : 'wxs2filter' , processor ( file , options ) { let content = file . content . toString ( ) ; return { content : wxs2filter ( content ) } ; } , extnames : [ 'wxs' ] , rext : 'filter.js' } ) ; }
356	function range ( rule , value , source , errors , options ) { const len = typeof rule . len === 'number' ; const min = typeof rule . min === 'number' ; const max = typeof rule . max === 'number' ; const spRegexp = / [\uD800-\uDBFF][\uDC00-\uDFFF] / g ; let val = value ; let key = null ; const num = typeof ( value ) === 'number' ; const str = typeof ( value ) === 'string' ; const arr = Array . isArray ( value ) ; if ( num ) { key = 'number' ; } else if ( str ) { key = 'string' ; } else if ( arr ) { key = 'array' ; } if ( ! key ) { return false ; } if ( arr ) { val = value . length ; } if ( str ) { val = value . replace ( spRegexp , '_' ) . length ; } if ( len ) { if ( val !== rule . len ) { errors . push ( util . format ( options . messages [ key ] . len , rule . fullField , rule . len ) ) ; } } else if ( min && ! max && val < rule . min ) { errors . push ( util . format ( options . messages [ key ] . min , rule . fullField , rule . min ) ) ; } else if ( max && ! min && val > rule . max ) { errors . push ( util . format ( options . messages [ key ] . max , rule . fullField , rule . max ) ) ; } else if ( min && max && ( val < rule . min || val > rule . max ) ) { errors . push ( util . format ( options . messages [ key ] . range , rule . fullField , rule . min , rule . max ) ) ; } }
1740	function incrementVersion ( metadata , version ) { const new_metadata = Object . assign ( { } , metadata ) ; new_metadata [ version ] = getVersion ( metadata , version ) + 1 ; return { metadata : new_metadata , } ; }
260	function ( site ) { if ( ! site ) { return [ ] ; } if ( ! _pluginsBySite [ site . ID ] && ! _fetching [ site . ID ] ) { PluginsActions . fetchSitePlugins ( site ) ; _fetching [ site . ID ] = true ; } if ( ! _pluginsBySite [ site . ID ] ) { return _pluginsBySite [ site . ID ] ; } return values ( _pluginsBySite [ site . ID ] ) ; }
1058	function casing ( value ) { var head = exact ( value . charAt ( 0 ) ) var rest = value . slice ( 1 ) if ( ! rest ) { return head } rest = exact ( rest ) if ( head === rest ) { return head } if ( head === 'u' && rest === 'l' ) { return 's' } return null }
1895	function ( name ) { var result = { } ; _ . each ( this . getArray ( name ) , function ( val ) { var parts = val . split ( ':' ) ; result [ parts [ 0 ] ] = parts [ 1 ] ; } ) ; return result ; }
3631	function workaround ( ) { var node = document . createElement ( 'div' ) ; function matches ( element , selector ) { if ( method . call ( element , selector ) ) { return true ; } else if ( ! element . parentNode ) { node . appendChild ( element ) ; var result = method . call ( element , selector ) ; node . removeChild ( element ) ; return result ; } else { return false ; } } return matches ; }
2335	function syncRecords ( datasetId , params , cb ) { debug ( '[%s] process syncRecords request' , datasetId ) ; var queryParams = params . query_params || { } ; var metaData = params . meta_data || { } ; var cuid = syncConfig . cuidProducer ( params ) ; var datasetClient = new DatasetClient ( datasetId , { queryParams : queryParams , metaData : metaData } ) ; var clientRecords = params . clientRecs || { } ; async . waterfall ( [ function checkDatasetclientStopped ( callback ) { syncStorage . readDatasetClient ( datasetClient . getId ( ) , function ( err , datasetClientJson ) { if ( err ) { return callback ( err ) ; } if ( ! datasetClientJson ) { var errMsg = "unknown dataset client datasetId = " + datasetId + " :: queryParams = " + util . inspect ( queryParams ) ; debugError ( "[%s] %s" , datasetId , errMsg ) ; return callback ( errMsg ) ; } if ( datasetClientJson . stopped === true ) { return callback ( new Error ( 'sync stopped for dataset ' + datasetId ) ) ; } else { return callback ( ) ; } } ) ; } , async . apply ( listLocalDatasetClientData , datasetClient ) , function listOtherChanges ( localDatasetData , callback ) { if ( localDatasetData ) { listChangesNotInLocalDataset ( datasetId , localDatasetData . syncLoopEnd , { cuid : cuid } , function ( err , appliedUpdates , clientPendingChanges ) { return callback ( err , localDatasetData , appliedUpdates , clientPendingChanges ) ; } ) ; } else { return callback ( ) ; } } ] , function ( err , localDatasetData , appliedUpdatesSinceLastSync , pendingUpdates ) { if ( err ) { return cb ( err ) ; } if ( ! localDatasetData ) { return cb ( null , { } ) ; } var localDatasetDataObj = convertToObject ( localDatasetData . records ) ; var appliedUpdatesSinceLastSyncObj = convertToObject ( appliedUpdatesSinceLastSync ) ; var pendingUpdatesObj = convertToObject ( pendingUpdates ) ; removeAppliedUpdates ( clientRecords , localDatasetDataObj , appliedUpdatesSinceLastSyncObj ) ; removePendingChanges ( clientRecords , localDatasetDataObj , pendingUpdatesObj ) ; var delta = computeDelta ( datasetId , clientRecords , localDatasetDataObj ) ; var res = delta ; res . hash = localDatasetData . globalHash ; debug ( '[%s] syncRecords API response %j' , datasetId , res ) ; return cb ( null , res ) ; } ) ; }
3001	function ( type ) { var me = this , oldType = me . type ; me . type = type ; if ( me . rendered ) { if ( oldType ) { me . toolEl . removeCls ( me . baseCls + '-' + oldType ) ; } me . toolEl . addCls ( me . baseCls + '-' + type ) ; } else { me . renderData . type = type ; } return me ; }
1559	function promisifyMethod ( obj , methodName , options ) { if ( ! obj ) { throw new TypeError ( 'promisify.method requires a truthy value' ) ; } return promisify ( obj [ methodName ] . bind ( obj ) , options ) ; }
1478	function ( marker , showPosition ) { var msg = qx . tool . compiler . Console . MESSAGE_IDS [ marker . msgId ] || marker . msgId ; var str = "" ; var pos = marker . pos ; if ( showPosition !== false && pos && pos . start && pos . start . line ) { str += "[" + pos . start . line ; if ( pos . start . column ) { str += "," + pos . start . column ; } if ( pos . end && pos . end . line && pos . end . line !== pos . start . line && pos . end . column !== pos . start . column ) { str += " to " + pos . end . line ; if ( pos . end . column ) { str += "," + pos . end . column ; } } str += "] " ; } str += qx . lang . String . format ( msg . message , marker . args || [ ] ) ; return str ; }
206	function addOrEditProduct ( list = [ ] , newProduct ) { let found = 0 ; const products = list . map ( product => { if ( product . ID === newProduct . ID ) { found = 1 ; return newProduct ; } return product ; } ) ; if ( ! found ) { return [ newProduct , ... products ] ; } return products ; }
1583	function initCloneByTag ( object , tag , isDeep ) { var Ctor = object . constructor ; switch ( tag ) { case arrayBufferTag$2 : return cloneArrayBuffer ( object ) ; case boolTag$2 : case dateTag$2 : return new Ctor ( + object ) ; case dataViewTag$3 : return cloneDataView ( object , isDeep ) ; case float32Tag$1 : case float64Tag$1 : case int8Tag$1 : case int16Tag$1 : case int32Tag$1 : case uint8Tag$1 : case uint8ClampedTag$1 : case uint16Tag$1 : case uint32Tag$1 : return cloneTypedArray ( object , isDeep ) ; case mapTag$4 : return new Ctor ; case numberTag$2 : case stringTag$3 : return new Ctor ( object ) ; case regexpTag$2 : return cloneRegExp ( object ) ; case setTag$4 : return new Ctor ; case symbolTag$2 : return cloneSymbol ( object ) ; } }
3281	async function getAllFiles ( file , options ) { let files = await getFiles ( [ file ] , options ) ; while ( hasUnloaded ( files ) ) files = await getFiles ( files , options ) ; return files ; }
1762	function ( ) { var multi = this . _client . multi ( ) ; multi . execAsync = Promise . promisify ( multi . exec ) ; return multi ; }
2180	function updateInkBarStyles ( ) { var elements = getElements ( ) ; if ( ! elements . tabs [ ctrl . selectedIndex ] ) { angular . element ( elements . inkBar ) . css ( { left : 'auto' , right : 'auto' } ) ; return ; } if ( ! ctrl . tabs . length ) return queue . push ( ctrl . updateInkBarStyles ) ; if ( ! $element . prop ( 'offsetParent' ) ) return handleResizeWhenVisible ( ) ; var index = ctrl . selectedIndex , totalWidth = elements . paging . offsetWidth , tab = elements . tabs [ index ] , left = tab . offsetLeft , right = totalWidth - left - tab . offsetWidth ; if ( ctrl . shouldCenterTabs ) { var tabWidth = calcTabsWidth ( elements . tabs ) ; if ( totalWidth > tabWidth ) { $mdUtil . nextTick ( updateInkBarStyles , false ) ; } } updateInkBarClassName ( ) ; angular . element ( elements . inkBar ) . css ( { left : left + 'px' , right : right + 'px' } ) ; }
3708	function skipUntil ( predicate ) { return function * ( iterable ) { let i = 0 ; let canReturn = false ; for ( const item of iterable ) { if ( ! canReturn ) { canReturn = predicate ( item , i ) ; if ( canReturn ) { yield item ; } i = i + 1 ; } else { yield item ; } } } ; }
1336	function or ( first , ... fragments ) { for ( let fragment of fragments ) { first = orPair ( first , fragment ) ; } return first ; }
656	function areEqual ( urlA , urlB ) { urlA = removeQueryArgs ( removeHash ( urlA ) ) ; urlB = removeQueryArgs ( removeHash ( urlB ) ) ; return addTrailingSlash ( urlA ) === addTrailingSlash ( urlB ) ; }
843	function defineVisitor ( context , options ) { const testInfoPrototype = { get isStrict ( ) { return nomalizeScope ( context . getScope ( ) , this . node ) . isStrict } , } function isNotSupportingVersion ( aCase ) { return ( ! aCase . supported || options . version . intersects ( getSemverRange ( ` ${ aCase . supported } ` ) ) ) } function isNotSupportingOn ( node ) { return aCase => isNotSupportingVersion ( aCase ) && ( ! aCase . test || aCase . test ( { node , __proto__ : testInfoPrototype } ) ) } return ( keywords . filter ( keyword => ! options . ignores . has ( keyword ) && features [ keyword ] . cases . some ( isNotSupportingVersion ) ) . reduce ( ( visitor , keyword ) => { const { ruleId , cases } = features [ keyword ] const rule = esRules [ ruleId ] const thisContext = { __proto__ : context , report ( descriptor ) { if ( descriptor . data ) { descriptor . data . version = options . version . raw } else { descriptor . data = { version : options . version . raw } } descriptor . fix = undefined const node = descriptor . node const hitCase = cases . find ( isNotSupportingOn ( node ) ) if ( hitCase ) { descriptor . messageId = hitCase . messageId descriptor . data . supported = hitCase . supported super . report ( descriptor ) } } , } return merge ( visitor , rule . create ( thisContext ) ) } , { } ) ) }
2554	function hashDelete$3 ( key ) { var result = this . has ( key ) && delete this . __data__ [ key ] ; this . size -= result ? 1 : 0 ; return result ; }
1090	function parse ( string ) { if ( typeof string !== 'string' ) { return undefined } var match = CREDENTIALS_REGEXP . exec ( string ) if ( ! match ) { return undefined } var userPass = USER_PASS_REGEXP . exec ( decodeBase64 ( match [ 1 ] ) ) if ( ! userPass ) { return undefined } return new Credentials ( userPass [ 1 ] , userPass [ 2 ] ) }
1775	function generateMarkdownTable ( api ) { if ( isEmpty ( api . props ) ) return '' ; return HEADER . concat ( join ( map ( api . props , ( description , propName ) => join ( [ ` \` ${ propName } \` ` , description . required ? 'true' : '' , inferType ( description . type ) , replaceNewlineWithBreak ( getValue ( description , 'defaultValue.value' , '' ) ) , replaceNewlineWithBreak ( description . description ) , ] , ' | ' ) ) , '\n' ) ) ; }
3042	function createNewLi ( ed , e ) { if ( isEnterWithoutShift ( e ) && isEndOfListItem ( ) ) { var node = ed . selection . getNode ( ) ; var li = ed . dom . create ( "li" ) ; var parentLi = ed . dom . getParent ( node , 'li' ) ; ed . dom . insertAfter ( li , parentLi ) ; if ( tinymce . isIE6 || tinymce . isIE7 || tinyMCE . isIE8 ) { ed . selection . setCursorLocation ( li , 1 ) ; } else { ed . selection . setCursorLocation ( li , 0 ) ; } e . preventDefault ( ) ; } }
1540	function getFormatMatch ( match , arr ) { var obj = { } , value , num ; arr . forEach ( function ( key , i ) { value = match [ i + 1 ] ; if ( isUndefined ( value ) || value === '' ) return ; if ( key === 'year' ) { obj . yearAsString = value . replace ( / ' / , '' ) ; } num = parseFloat ( value . replace ( / ' / , '' ) . replace ( / , / , '.' ) ) ; obj [ key ] = ! isNaN ( num ) ? num : value . toLowerCase ( ) ; } ) ; return obj ; }
2474	function filterVerbs ( activities ) { return activities . filter ( function ( activity ) { var showing = verbsShowing [ activity . verb ] ; if ( showing == undefined ) showing = verbsShowing [ "other" ] ; return showing ; } ) }
3582	function buildParams ( identifier , instanceState ) { var params = { } if ( instanceState ) { params . Filters = [ { Name : 'instance-state-name' , Values : [ instanceState ] } ] } if ( isInstanceId ( identifier ) ) { params . InstanceIds = [ identifier ] return params } params . Filters = params . Filters || [ ] params . Filters . push ( { Name : 'tag:Name' , Values : [ identifier ] } ) return params }
3654	function ( name , mainTester , parentTester ) { if ( ! mainTester ) mainTester = this this . id = groupid ( ) this . mainTester = mainTester this . parentTester = parentTester this . name = name this . doneTests = 0 this . doneAsserts = 0 this . runningTests = 0 this . doneCalled = false this . doSourcemappery = true this . complete = new Future }
3412	function ( h , skip_undo ) { var ed = this . editor , r = ed . selection . getRng ( ) ; if ( ! ed . selection . isCollapsed ( ) && r . startContainer != r . endContainer ) ed . getDoc ( ) . execCommand ( 'Delete' , false , null ) ; ed . execCommand ( 'mceInsertContent' , false , h , { skip_undo : skip_undo } ) ; }
1002	function ( newHeight , widowLayoutStyle ) { var itemWidthSum = this . left , rowWidthWithoutSpacing = this . width - ( this . items . length - 1 ) * this . spacing , clampedToNativeRatio , clampedHeight , errorWidthPerItem , roundedCumulativeErrors , singleItemGeometry , centerOffset ; if ( typeof widowLayoutStyle === 'undefined' || [ 'justify' , 'center' , 'left' ] . indexOf ( widowLayoutStyle ) < 0 ) { widowLayoutStyle = 'left' ; } clampedHeight = Math . max ( this . edgeCaseMinRowHeight , Math . min ( newHeight , this . edgeCaseMaxRowHeight ) ) ; if ( newHeight !== clampedHeight ) { this . height = clampedHeight ; clampedToNativeRatio = ( rowWidthWithoutSpacing / clampedHeight ) / ( rowWidthWithoutSpacing / newHeight ) ; } else { this . height = newHeight ; clampedToNativeRatio = 1.0 ; } this . items . forEach ( function ( item ) { item . top = this . top ; item . width = item . aspectRatio * this . height * clampedToNativeRatio ; item . height = this . height ; item . left = itemWidthSum ; itemWidthSum += item . width + this . spacing ; } , this ) ; if ( widowLayoutStyle === 'justify' ) { itemWidthSum -= ( this . spacing + this . left ) ; errorWidthPerItem = ( itemWidthSum - this . width ) / this . items . length ; roundedCumulativeErrors = this . items . map ( function ( item , i ) { return Math . round ( ( i + 1 ) * errorWidthPerItem ) ; } ) ; if ( this . items . length === 1 ) { singleItemGeometry = this . items [ 0 ] ; singleItemGeometry . width -= Math . round ( errorWidthPerItem ) ; } else { this . items . forEach ( function ( item , i ) { if ( i > 0 ) { item . left -= roundedCumulativeErrors [ i - 1 ] ; item . width -= ( roundedCumulativeErrors [ i ] - roundedCumulativeErrors [ i - 1 ] ) ; } else { item . width -= roundedCumulativeErrors [ i ] ; } } ) ; } } else if ( widowLayoutStyle === 'center' ) { centerOffset = ( this . width - itemWidthSum ) / 2 ; this . items . forEach ( function ( item ) { item . left += centerOffset + this . spacing ; } , this ) ; } }
3532	function isIllegalArguments ( _ref ) { var fn = _ref . fn ; var cb = _ref . cb ; var matcher = _ref . matcher ; if ( typeof fn !== 'function' ) { return Promise . reject ( new Error ( 'Expected fn to be a Function' ) ) ; } if ( typeof cb !== 'undefined' && typeof cb !== 'function' ) { return Promise . reject ( new Error ( 'Expected cb to be a Function' ) ) ; } if ( ! ( matcher instanceof RegExp ) && [ 'function' , 'string' ] . indexOf ( typeof matcher === 'undefined' ? 'undefined' : _typeof ( matcher ) ) === - 1 && matcher . constructor !== Error . constructor ) { return Promise . reject ( new Error ( UNRECOGNISED_MATCHER_ERR ) ) ; } return Promise . resolve ( ) ; }
635	function ( i18n , options ) { this . type = "Assessor" ; this . setI18n ( i18n ) ; this . _assessments = [ ] ; this . _options = options || { } ; if ( ! isUndefined ( this . _options . researcher ) ) { this . _researcher = this . _options . researcher ; } }
3581	function doesAutoScalingGroupExist ( autoScaling , asgName ) { return autoScaling . describeAutoScalingGroupsPromised ( { AutoScalingGroupNames : [ asgName ] } ) . then ( function found ( data ) { return ! _ . isEmpty ( data . AutoScalingGroups ) } ) }
3158	function ( ) { var reply = [ ] ; this . getSettingNames ( ) . forEach ( function ( setting ) { reply . push ( { 'key' : setting , 'value' : this . getSetting ( setting ) . get ( ) } ) ; } , this ) ; return reply ; }
1909	function findParts ( str ) { var stream = require ( 'stringStream' ) . create ( str ) ; var ch ; var result = [ ] ; var sep = / [\s\u00a0,] / ; var add = function ( ) { stream . next ( ) ; result . push ( range ( stream . start , stream . current ( ) ) ) ; stream . start = stream . pos ; } ; stream . eatSpace ( ) ; stream . start = stream . pos ; while ( ch = stream . next ( ) ) { if ( ch == '"' || ch == "'" ) { stream . next ( ) ; if ( ! stream . skipTo ( ch ) ) break ; add ( ) ; } else if ( ch == '(' ) { stream . backUp ( 1 ) ; if ( ! stream . skipToPair ( '(' , ')' ) ) break ; stream . backUp ( 1 ) ; add ( ) ; } else { if ( sep . test ( ch ) ) { result . push ( range ( stream . start , stream . current ( ) . length - 1 ) ) ; stream . eatWhile ( sep ) ; stream . start = stream . pos ; } } } add ( ) ; return _ . chain ( result ) . filter ( function ( item ) { return ! ! item . length ( ) ; } ) . uniq ( false , function ( item ) { return item . toString ( ) ; } ) . value ( ) ; }
2666	function forEach ( arr , callback , scope ) { var i , len = arr . length ; for ( i = 0 ; i < len ; i += 1 ) { callback . call ( scope , arr [ i ] , i ) ; } }
358	function string ( rule , value , callback , source , options ) { const errors = [ ] ; const validate = rule . required || ( ! rule . required && source . hasOwnProperty ( rule . field ) ) ; if ( validate ) { if ( isEmptyValue ( value , 'string' ) && ! rule . required ) { return callback ( ) ; } rules . required ( rule , value , source , errors , options , 'string' ) ; if ( ! isEmptyValue ( value , 'string' ) ) { rules . type ( rule , value , source , errors , options ) ; rules . range ( rule , value , source , errors , options ) ; rules . pattern ( rule , value , source , errors , options ) ; if ( rule . whitespace === true ) { rules . whitespace ( rule , value , source , errors , options ) ; } } } callback ( errors ) ; }
1370	async function onDataRead ( filename , data ) { log ( 'file ' + path . basename ( filename ) + ' read' ) ; const ext = path . extname ( filename ) . replace ( / ^\. / , '' ) ; const optimizedData = await minify [ ext ] ( data ) ; let b64Optimize ; if ( ext === 'css' ) [ , b64Optimize ] = await tryToCatch ( minify . img , filename , optimizedData ) ; return b64Optimize || optimizedData ; }
546	function getHandler ( optionName ) { var option = require ( './options/' + optionName ) ; if ( ! option . detect ) throw new Error ( 'Option does not have `detect()` method.' ) ; return { name : option . name , detect : option . detect , detectDefault : option . detectDefault } ; }
1796	function RemoteWritableStream ( process , daemon , writeHeaderFunc , closeHeaderFunc ) { stream . Writable . call ( this ) ; this . process = process ; this . daemon = daemon ; this . credit = 0 ; this . backPressure = new Array ( 0 ) ; this . closed = false ; this . writeHeaderFunc = writeHeaderFunc ; this . closeHeaderFunc = closeHeaderFunc ; this . on ( 'drain' , ( ) => this . _drainBackPressure ( ) ) ; this . once ( 'finish' , ( ) => { if ( ! this . process . closed ) { this . daemon . write ( closeHeaderFunc ( this . process . id ) ) ; } this . closed = true ; } ) ; }
2244	function ClickTrackingContext ( ctx , px , py ) { forward ( this , ctx ) ; var stack = [ ] ; this . hits = [ ] ; this . hit = null ; var that = this ; function recordHit ( ) { that . hits . unshift ( Array . prototype . slice . call ( stack ) ) ; that . hit = that . hits [ 0 ] ; } this . pushObject = function ( o ) { stack . unshift ( o ) ; } ; this . popObject = function ( ) { stack . shift ( ) ; } ; this . reset = function ( ) { this . hits = [ ] ; this . hit = null ; } ; this . clearRect = function ( x , y , w , h ) { } ; this . fillRect = function ( x , y , w , h ) { if ( px >= x && px <= x + w && py >= y && py <= y + h ) recordHit ( ) ; } ; this . strokeRect = function ( x , y , w , h ) { } ; this . fill = function ( fillRule ) { if ( ctx . isPointInPath ( px , py ) ) recordHit ( ) ; } ; this . stroke = function ( ) { if ( ctx . isPointInStroke ( px , py ) ) recordHit ( ) ; } ; this . fillText = function ( text , x , y , maxWidth ) { } ; this . strokeText = function ( text , x , y , maxWidth ) { } ; }
824	function init_script_chain_group ( ) { if ( ! group || ! group . scripts ) { chain . push ( group = { scripts : [ ] , finished : true } ) ; } }
1878	function ( name ) { if ( ! name ) return null ; if ( ! ( name in cache ) ) { cache [ name ] = require ( 'utils' ) . deepMerge ( { } , systemSettings [ name ] , userSettings [ name ] ) ; } var data = cache [ name ] , subsections = _ . rest ( arguments ) , key ; while ( data && ( key = subsections . shift ( ) ) ) { if ( key in data ) { data = data [ key ] ; } else { return null ; } } return data ; }
1262	function cleanFilter ( ) { sbSearch . reset ( ) ; if ( ! templateOpts . sidebar . enabled || ! $sidebarNodes ) return ; setFilterBtnStates ( ) ; if ( $txtSearch ) $txtSearch . val ( '' ) ; $sidebarNodes . removeClass ( 'hidden' ) ; if ( $btnClean ) $btnClean . hide ( ) ; $ ( '.toolbar-buttons > span' ) . css ( 'color' , '#fff' ) ; $ ( '.chevron' ) . show ( ) ; setTimeout ( function ( ) { setSidebarNodesOutline ( templateOpts . sidebar . outline ) ; if ( $txtSearch ) $txtSearch . focus ( ) ; } , 100 ) ; isFilterActive = false ; }
1700	function _calcScrollOffset ( normalize , refreshParticle ) { if ( refreshParticle || ( this . _scroll . particleValue === undefined ) ) { this . _scroll . particleValue = this . _scroll . particle . getPosition1D ( ) ; this . _scroll . particleValue = Math . round ( this . _scroll . particleValue * 1000 ) / 1000 ; } var scrollOffset = this . _scroll . particleValue ; if ( this . _scroll . scrollDelta || this . _scroll . normalizedScrollDelta ) { scrollOffset += this . _scroll . scrollDelta + this . _scroll . normalizedScrollDelta ; if ( ( ( this . _scroll . boundsReached & Bounds . PREV ) && ( scrollOffset > this . _scroll . springPosition ) ) || ( ( this . _scroll . boundsReached & Bounds . NEXT ) && ( scrollOffset < this . _scroll . springPosition ) ) || ( this . _scroll . boundsReached === Bounds . BOTH ) ) { scrollOffset = this . _scroll . springPosition ; } if ( normalize ) { if ( ! this . _scroll . scrollDelta ) { this . _scroll . normalizedScrollDelta = 0 ; _setParticle . call ( this , scrollOffset , undefined , '_calcScrollOffset' ) ; } this . _scroll . normalizedScrollDelta += this . _scroll . scrollDelta ; this . _scroll . scrollDelta = 0 ; } } if ( this . _scroll . scrollForceCount && this . _scroll . scrollForce ) { if ( this . _scroll . springPosition !== undefined ) { scrollOffset = ( scrollOffset + this . _scroll . scrollForce + this . _scroll . springPosition ) / 2.0 ; } else { scrollOffset += this . _scroll . scrollForce ; } } if ( ! this . options . overscroll ) { if ( ( this . _scroll . boundsReached === Bounds . BOTH ) || ( ( this . _scroll . boundsReached === Bounds . PREV ) && ( scrollOffset > this . _scroll . springPosition ) ) || ( ( this . _scroll . boundsReached === Bounds . NEXT ) && ( scrollOffset < this . _scroll . springPosition ) ) ) { scrollOffset = this . _scroll . springPosition ; } } return scrollOffset ; }
1177	function ( type , value , targetElement ) { switch ( type ) { case 'number' : value = parseFloat ( value ) ; break ; case 'toggle' : value = targetElement . checked ; break ; default : value = value ; break ; } return value ; }
3547	function classOf ( value ) { var retVal , valueType , toString ; if ( typeof value === _undefined ) { retVal = _Undefined ; } else if ( value === null ) { retVal = _Null ; } else { toString = value . toString . name === 'toString' ? Object . prototype . toString : value . toString ; valueType = toString . call ( value ) ; retVal = valueType . substring ( 8 , valueType . length - 1 ) ; if ( retVal === _Number && isNaN ( value ) ) { retVal = 'NaN' ; } } return retVal ; }
3775	function flip ( it ) { return __asyncGenerator ( this , arguments , function * flip_1 ( ) { yield __await ( yield * __asyncDelegator ( __asyncValues ( yield __await ( reduce ( ( prev , next ) => [ next ] . concat ( prev ) , [ ] ) ( it ) ) ) ) ) ; } ) ; }
3252	function ( ownerContext , axis ) { var size = axis . end - axis . begin , center = ownerContext . centerRegion ; if ( center ) { center [ 'set' + axis . sizePropCap ] ( size - center . getMarginInfo ( ) [ axis . sizeProp ] ) ; center . layoutPos [ axis . posProp ] = axis . begin ; } return Ext . isNumber ( size ) ? 1 : 0 ; }
1104	function ( str , gsv ) { if ( gsv . length % 4 % 3 === 0 ) { throw new Error ( 'Invalid GSV length: ' + str ) ; } var sats = [ ] ; for ( var i = 4 ; i < gsv . length - 3 ; i += 4 ) { var prn = parseNumber ( gsv [ i ] ) ; var snr = parseNumber ( gsv [ i + 3 ] ) ; sats . push ( { 'prn' : prn , 'elevation' : parseNumber ( gsv [ i + 1 ] ) , 'azimuth' : parseNumber ( gsv [ i + 2 ] ) , 'snr' : snr , 'status' : prn !== null ? ( snr !== null ? 'tracking' : 'in view' ) : null } ) ; } return { 'msgNumber' : parseNumber ( gsv [ 2 ] ) , 'msgsTotal' : parseNumber ( gsv [ 1 ] ) , 'satellites' : sats , 'signalId' : gsv . length % 4 === 2 ? parseNumber ( gsv [ gsv . length - 2 ] ) : null } ; }
3032	function ( javascriptId , state , data ) { var connection ; connection = this . liveConnections [ Number ( javascriptId ) ] ; if ( connection ) { connection . onFlashStateChange ( state , data ) ; } else { Ext . warn . log ( "onFlashStateChange for unknown connection ID: " + javascriptId ) ; } }
176	function isDefaultOrNullQueryValue ( value , key ) { return value === undefined || value === null || DEFAULT_THEME_QUERY [ key ] === value ; }
3418	function ( headerCt , header , e ) { if ( header . isCheckerHd ) { e . stopEvent ( ) ; var me = this , isChecked = header . el . hasCls ( Ext . baseCSSPrefix + 'grid-hd-checker-on' ) ; me . preventFocus = true ; if ( isChecked ) { me . deselectAll ( ) ; } else { me . selectAll ( ) ; } delete me . preventFocus ; } }
1373	function loadRcConfig ( callback ) { const sync = typeof callback !== 'function' ; if ( sync ) { const fp = rcLoader . for ( this . resourcePath ) ; if ( typeof fp !== 'string' ) { return { } ; } this . addDependency ( fp ) ; const options = loadConfig ( fp ) ; delete options . dirname ; return options ; } rcLoader . for ( this . resourcePath , ( err , fp ) => { if ( typeof fp !== 'string' ) { return callback ( null , { } ) ; } this . addDependency ( fp ) ; const options = loadConfig ( fp ) ; delete options . dirname ; callback ( err , options ) ; } ) ; }
2813	function checkIfShouldStick ( ) { if ( mediaQuery && ! matchMedia ( '(' + mediaQuery + ')' ) . matches ) return ; var scrollTop = ( window . pageYOffset || doc . scrollTop ) - ( doc . clientTop || 0 ) ; var shouldStick = scrollTop >= stickyLine ; if ( shouldStick && ! isSticking ) stickElement ( ) ; else if ( ! shouldStick && isSticking ) unstickElement ( ) ; }
2795	function addWhereClause ( baseClause , k , v ) { if ( v . startsWith ( '>' ) ) { baseClause . where ( k , '>=' , v . substring ( 1 ) ) ; return } if ( v . startsWith ( '<' ) ) { baseClause . where ( k , '<=' , v . substring ( 1 ) ) ; return } if ( v . startsWith ( '~' ) ) { baseClause . where ( k , 'LIKE' , v . substring ( 1 ) ) ; return } if ( k . endsWith ( 'Id' ) ) { baseClause . where ( k . substring ( 0 , k . length - 2 ) + '_id' , '=' , v ) ; return } baseClause . where ( k , '=' , v ) ; return }
3783	function compileValue ( value ) { if ( value . subtype === 'array' ) { return compileArray ( value ) } else if ( value . subtype === 'object' ) { return compileObject ( value ) } else if ( value . subtype === 'mixin' ) { return compileMixin ( value ) } else if ( value . subtype === 'js' ) { return compileJS ( value ) } else if ( value . subtype === 'function' ) { return compileFunction ( value ) } throw new Error ( 'Invalid subtype: ' + value . subtype ) }
2105	function getAssetDir ( ) { var dir = path . dirname ( process . argv [ 1 ] ) ; if ( isDev ( ) ) { let epeiosPath = getEpeiosPath ( ) ; return path . resolve ( epeiosPath , "tools/xdhq/examples/common/" , path . relative ( path . resolve ( epeiosPath , "tools/xdhq/examples/NJS/" ) , path . resolve ( dir ) ) ) ; } else return path . resolve ( dir ) ; }
3289	function ( fromClass , members ) { Ext . classSystemMonitor && Ext . classSystemMonitor ( this , 'Ext.Base#borrow' , arguments ) ; var prototype = this . prototype , fromPrototype = fromClass . prototype , className = Ext . getClassName ( this ) , i , ln , name , fn , toBorrow ; members = Ext . Array . from ( members ) ; for ( i = 0 , ln = members . length ; i < ln ; i ++ ) { name = members [ i ] ; toBorrow = fromPrototype [ name ] ; if ( typeof toBorrow == 'function' ) { fn = Ext . Function . clone ( toBorrow ) ; if ( className ) { fn . displayName = className + '#' + name ; } fn . $owner = this ; fn . $name = name ; prototype [ name ] = fn ; } else { prototype [ name ] = toBorrow ; } } return this ; }
56	function unbindListeners ( ) { if ( this && this . eventListeners ) { this . eventListeners . forEach ( function ( item ) { var element = item . element , type = item . type , callback = item . callback , options = item . options ; element . removeEventListener ( type , callback , options ) ; } ) ; this . eventListeners = [ ] ; } }
3643	function ( key , onlyCheckDirectory ) { var filePath = this . loadVar ( key ) ; if ( ! filePath ) { exitProcess ( 'empty file path for ' + key , this . alarm ) ; return false ; } if ( ! onlyCheckDirectory ) { if ( ! fs . existsSync ( filePath ) ) { exitProcess ( 'the value of ' + key + ' is a necessary file ,but not exists in ' + filePath , this . alarm ) ; return false ; } } else { var dirname = path . dirname ( filePath ) ; if ( ! fs . lstatSync ( dirname ) . isDirectory ( ) ) { exitProcess ( 'the path ' + dirname + ' must exist and be a directory' , this . alarm ) ; return false ; } } return filePath ; }
2686	function createMessage ( identities , header , parentHeader , metadata , content ) { return { identities : identities , header : header , parentHeader : parentHeader , metadata : metadata , content : content } ; }
3594	function ( func ) { var fnStr = func . toString ( ) . replace ( / ((\/\/.*$)|(\/\*[\s\S]*?\*\/)) / mg , '' ) ; return fnStr . slice ( fnStr . indexOf ( '(' ) + 1 , fnStr . indexOf ( ')' ) ) . match ( / ([^\s,]+) / g ) || [ ] ; }
1316	function Packet ( link , id , kind ) { this . link = link ; this . id = id ; this . kind = kind ; this . a1 = 0 ; this . a2 = new Array ( DATA_SIZE ) ; }
2806	function LogWatcher ( dirpath , maxfiles , ignoreInitial ) { _classCallCheck ( this , LogWatcher ) ; var _this = _possibleConstructorReturn ( this , ( LogWatcher . __proto__ || Object . getPrototypeOf ( LogWatcher ) ) . call ( this ) ) ; _this . _dirpath = dirpath || DEFAULT_SAVE_DIR ; _this . _filter = isCommanderLog ; _this . _maxfiles = maxfiles || 3 ; _this . _logDetailMap = { } ; _this . _ops = [ ] ; _this . _op = null ; _this . _startTime = new Date ( ) ; _this . _timer = null ; _this . _die = false ; _this . _ignoreInitial = ignoreInitial || false ; _this . stopped = false ; _this . _loop ( ) ; _this . emit ( 'Started' ) ; return _this ; }
3217	function ( record , e , keepExisting ) { var me = this , isSelected = me . isSelected ( record ) ; switch ( me . selectionMode ) { case 'MULTI' : if ( e . shiftKey && me . selectionStart ) { me . selectRange ( me . selectionStart , record , e . ctrlKey ) ; } else if ( e . ctrlKey && isSelected ) { me . doDeselect ( record , false ) ; } else if ( e . ctrlKey ) { me . doSelect ( record , true , false ) ; } else if ( isSelected && ! e . shiftKey && ! e . ctrlKey && me . selected . getCount ( ) > 1 ) { me . doSelect ( record , keepExisting , false ) ; } else if ( ! isSelected ) { me . doSelect ( record , false ) ; } break ; case 'SIMPLE' : if ( isSelected ) { me . doDeselect ( record ) ; } else { me . doSelect ( record , true ) ; } break ; case 'SINGLE' : if ( me . allowDeselect && isSelected ) { me . doDeselect ( record ) ; } else { me . doSelect ( record , false ) ; } break ; } if ( ! e . shiftKey ) { if ( me . isSelected ( record ) ) { me . selectionStart = record ; } else { me . selectionStart = null ; } } }
733	function parseDescriptors ( ) { var pError = false , w , d , h , i , candidate = { } , desc , lastChar , value , intVal , floatVal ; for ( i = 0 ; i < descriptors . length ; i ++ ) { desc = descriptors [ i ] ; lastChar = desc [ desc . length - 1 ] ; value = desc . substring ( 0 , desc . length - 1 ) ; intVal = parseInt ( value , 10 ) ; floatVal = parseFloat ( value ) ; if ( regexNonNegativeInteger . test ( value ) && ( lastChar === "w" ) ) { if ( w || d ) { pError = true ; } if ( intVal === 0 ) { pError = true ; } else { w = intVal ; } } else if ( regexFloatingPoint . test ( value ) && ( lastChar === "x" ) ) { if ( w || d || h ) { pError = true ; } if ( floatVal < 0 ) { pError = true ; } else { d = floatVal ; } } else if ( regexNonNegativeInteger . test ( value ) && ( lastChar === "h" ) ) { if ( h || d ) { pError = true ; } if ( intVal === 0 ) { pError = true ; } else { h = intVal ; } } else { pError = true ; } } if ( ! pError ) { candidate . url = url ; if ( w ) { candidate . w = w ; } if ( d ) { candidate . d = d ; } if ( h ) { candidate . h = h ; } if ( ! h && ! d && ! w ) { candidate . d = 1 ; } if ( candidate . d === 1 ) { set . has1x = true ; } candidate . set = set ; candidates . push ( candidate ) ; } }
47	function _captureUrlChange ( from , to ) { var parsedLoc = parseUrl$1 ( this . _location . href ) ; var parsedTo = parseUrl$1 ( to ) ; var parsedFrom = parseUrl$1 ( from ) ; this . _lastHref = to ; if ( parsedLoc . protocol === parsedTo . protocol && parsedLoc . host === parsedTo . host ) to = parsedTo . relative ; if ( parsedLoc . protocol === parsedFrom . protocol && parsedLoc . host === parsedFrom . host ) from = parsedFrom . relative ; this . captureBreadcrumb ( { category : 'navigation' , data : { to : to , from : from } } ) ; }
2854	function baseMean ( array , iteratee ) { var length = array ? array . length : 0 ; return length ? ( baseSum ( array , iteratee ) / length ) : NAN ; }
554	function updateIndent ( info , dict , whitespaceNode ) { var item = dict [ info . id ] ; if ( ! item ) return whitespaceNode ; var crPos = whitespaceNode . lastIndexOf ( '\n' ) ; \n var tabPos = whitespaceNode . lastIndexOf ( '\t' ) ; \t if ( tabPos > crPos ) crPos = tabPos ; var firstPart = whitespaceNode . substr ( 0 , crPos + 1 ) ; }
611	function splitSentence ( sentence , language ) { const stopwordRegex = languageVariables [ language ] . stopwordRegex ; const stopwords = sentence . match ( stopwordRegex ) || [ ] ; const splitSentences = splitOnWords ( sentence , stopwords ) ; return createSentenceParts ( splitSentences , language ) ; }
224	function setupQuoraGlobal ( ) { if ( window . qp ) { return ; } const quoraPixel = ( window . qp = function ( ) { quoraPixel . qp ? quoraPixel . qp . apply ( quoraPixel , arguments ) : quoraPixel . queue . push ( arguments ) ; } ) ; quoraPixel . queue = [ ] ; }
5	function formatNunjucksError ( err , input ) { const match = err . message . match ( / Line (\d+), Column \d+ / ) ; if ( ! match ) return err ; const errLine = parseInt ( match [ 1 ] , 10 ) ; if ( isNaN ( errLine ) ) return err ; const splited = err . message . replace ( '(unknown path)' , '' ) . split ( '\n' ) ; \n const e = new Error ( ) ; e . name = 'Nunjucks Error' ; e . line = errLine ; e . location = splited [ 0 ] ; e . type = splited [ 1 ] . trim ( ) ; e . message = getContext ( input . split ( / \r?\n / ) , errLine , e . location , e . type ) . join ( '\n' ) ; }
3811	function WhileCommand ( args , define ) { var parsed = new statements . ArgumentStatement ( args , { separator : false } ) ; this . condition = parsed . args [ 0 ] ; this . block = define ( { start : 'WHILE' , end : 'WEND' } ) ; }
2698	function setupOutline ( ) { var markup = '<select id="tocDropDown" style="float: right"><option>Outline</option></select>' ; IPython . toolbar . element . append ( markup ) ; var tocDropDown = $ ( '#tocDropDown' ) ; tocDropDown . change ( function ( e ) { var index = tocDropDown . val ( ) ; if ( index . length === '' ) { return false ; } var scrollTop = IPython . notebook . get_cell ( 0 ) . element . position ( ) . top - IPython . notebook . get_cell ( parseInt ( index ) ) . element . position ( ) . top ; IPython . notebook . element . animate ( { scrollTop : - scrollTop } , 250 , 'easeInOutCubic' ) ; tocDropDown . blur ( ) ; tocDropDown . find ( 'option' ) . get ( 0 ) . selected = true ; return false ; } ) ; function createOption ( title , value , level ) { var prefix = level > 1 ? new Array ( level + 1 ) . join ( '&nbsp;&nbsp;' ) : '' ; var text = prefix + IPython . utils . escape_html ( title ) ; return '<option value="' + value + '">' + text + '</option>' ; } function updateOutline ( ) { var content = [ ] ; content . push ( createOption ( 'Table of Contents' , '' , 0 ) ) ; var cells = IPython . notebook . get_cells ( ) ; cells . forEach ( function ( c , i ) { if ( ( c . cell_type == 'heading' ) && ( c . level <= 3 ) ) { var cell = $ ( c . element ) ; var header = cell . find ( 'h' + c . level ) ; var title = header . text ( ) ; title = title . substring ( - 1 , title . length - 1 ) ; if ( title == 'Type Heading Here' ) { return ; } content . push ( createOption ( title , i , c . level ) ) ; } } ) ; var markup = content . join ( '' ) ; tocDropDown . html ( markup ) ; } updateOutline ( ) ; $ ( [ IPython . events ] ) . on ( 'set_dirty.Notebook' , function ( event , data ) { updateOutline ( ) ; } ) ; $ ( [ IPython . events ] ) . on ( 'command_mode.Cell' , function ( event , data ) { updateOutline ( ) ; } ) ; }
3215	function ( store , initial ) { var me = this ; me . mixins . bindable . bindStore . apply ( me , arguments ) ; if ( me . store && ! initial ) { me . refresh ( ) ; } }
3372	function ( grid , state ) { var filters = { } ; this . filters . each ( function ( filter ) { if ( filter . active ) { filters [ filter . dataIndex ] = filter . getValue ( ) ; } } ) ; return ( state . filters = filters ) ; }
1560	function promisifyMethods ( obj , methodNames , options ) { if ( ! obj ) { throw new TypeError ( 'promisify.methods requires a truthy value' ) ; } const out = { } ; for ( let methodName of methodNames ) { out [ methodName ] = promisify ( obj [ methodName ] . bind ( obj ) , options ) ; } return out ; }
3620	function zset ( obj , vonly ) { var vtype = this . type ( 3 ) , key = ! vonly ? this . getStringBuffer ( obj . key ) : new Buffer ( 0 ) , length = obj . length !== undefined ? obj . length : Object . keys ( obj . value ) . length , len = this . getLengthEncoding ( length , false ) , value = this . object ( obj . value ) ; return Buffer . concat ( [ vtype , key , len , value ] , vtype . length + key . length + len . length + value . length ) }
2145	function ( key , value , writeAttr , attrName ) { var node = this . $$element [ 0 ] , booleanKey = getBooleanAttrName ( node , key ) , aliasedKey = getAliasedAttrName ( key ) , observer = key , nodeName ; if ( booleanKey ) { this . $$element . prop ( key , value ) ; attrName = booleanKey ; } else if ( aliasedKey ) { this [ aliasedKey ] = value ; observer = aliasedKey ; } this [ key ] = value ; if ( attrName ) { this . $attr [ key ] = attrName ; } else { attrName = this . $attr [ key ] ; if ( ! attrName ) { this . $attr [ key ] = attrName = snake_case ( key , '-' ) ; } } nodeName = nodeName_ ( this . $$element ) ; if ( nodeName === 'img' && key === 'srcset' ) { this [ key ] = value = sanitizeSrcset ( value , '$set(\'srcset\', value)' ) ; } \' \' if ( writeAttr !== false ) { if ( value === null || isUndefined ( value ) ) { this . $$element . removeAttr ( attrName ) ; } else { if ( SIMPLE_ATTR_NAME . test ( attrName ) ) { this . $$element . attr ( attrName , value ) ; } else { setSpecialAttr ( this . $$element [ 0 ] , attrName , value ) ; } } } }
2011	function makeBuffer ( width , height , drawFun ) { var canvas = makeCanvas ( width , height ) ; var ctx = canvas . getContext ( "2d" ) ; if ( platform . isEjecta ( ) ) { ctx . imageSmoothingEnabled = false ; } drawFun ( ctx ) ; return canvas ; }
1799	function ( path ) { var p = path ; const ar = p . indexOf ( '->' ) ; if ( ar >= 0 ) { p = p . substring ( ar + 2 ) ; } const cu = p . indexOf ( '/{' ) ; if ( cu > 0 ) { p = p . substring ( 0 , cu ) ; } return p ; }
3838	function ColorCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 3 ) throw new SyntaxError ( 'COLOR command requires 3 arguments' ) ; this . red = parsed . args [ 0 ] ; this . green = parsed . args [ 1 ] ; this . blue = parsed . args [ 2 ] ; this . alpha = parsed . args . length > 3 ? parsed . args [ 3 ] : false ; }
763	function Keycloak ( config , keycloakConfig ) { this . config = new Config ( keycloakConfig ) ; this . grantManager = new GrantManager ( this . config ) ; this . stores = [ BearerStore ] ; if ( ! config ) { throw new Error ( 'Adapter configuration must be provided.' ) ; } this . config . scope = config . scope ; if ( config && config . store && config . cookies ) { throw new Error ( 'Either `store` or `cookies` may be set, but not both' ) ; } if ( config && config . store ) { this . stores . push ( new SessionStore ( config . store ) ) ; } else if ( config && config . cookies ) { this . stores . push ( CookieStore ) ; } this . config . idpHint = config . idpHint ; }
2662	function smsGetCampaignInfo ( callback , campaign_id ) { if ( campaign_id === undefined ) { return callback ( returnError ( "Empty sms campaign id" ) ) ; } sendRequest ( 'sms/campaigns/info/' + campaign_id , 'GET' , { } , true , callback ) ; }
351	function ( ) { var scrollTop = content . scrollTop ; var diff = ( finalScrollTop - scrollTop ) ; if ( Math . abs ( diff ) > 3 ) { content . scrollTop += diff / 3 ; editor . animateCallback = callback ; editor . animateTimeout = setTimeout ( animate , 50 ) ; } else { if ( callback ) { callback ( true ) ; } content . scrollTop = finalScrollTop ; delete editor . animateTimeout ; delete editor . animateCallback ; } }
795	function load ( map , options ) { var promises = [ ] ; var loaded = { } ; var filename ; options = options || { } ; for ( var key in map ) { if ( map . hasOwnProperty ( key ) ) { if ( ! map [ key ] || map [ key ] . length === 0 ) { continue ; } filename = map [ key ] ; if ( ! options . external ) { filename = path . resolve ( ROOT_DIR , filename ) ; } promises . push ( loadSingle ( filename ) . then ( ( function ( _key ) { return function ( data ) { loaded [ _key ] = data ; } ; } ) ( key ) ) ) ; } } map . loaded = loaded ; return Q . all ( promises ) ; }
3512	function list ( type , num , fn ) { var records = [ ] ; var bail = false ; var created = function ( err , record ) { if ( bail ) return ; if ( err ) { bail = true ; return fn ( err ) ; } records . push ( record ) ; if ( records . length === num ) { fn ( null , records ) ; } } ; for ( var i = 0 ; i < num ; i ++ ) { factory ( type , created ) ; } }
1390	function gen ( k8sPods , clusterState , clusterNameLabel ) { const hostIPs = _ . uniq ( _ . map ( k8sPods . items , 'status.hostIP' ) ) ; const oldHostIps = _ . difference ( _ . keys ( clusterState ) , hostIPs ) ; _ . forEach ( oldHostIps , ( ip ) => { delete clusterState [ ip ] ; } ) ; Object . keys ( clusterState ) . forEach ( ( nodeId ) => { clusterState [ nodeId ] . active = [ ] ; } ) ; k8sPods . items . forEach ( ( pod ) => { if ( pod . metadata . labels . clusterName === clusterNameLabel ) { if ( ! _ . has ( clusterState , pod . status . hostIP ) ) { clusterState [ pod . status . hostIP ] = { node_id : pod . status . hostIP , hostname : pod . status . hostIP , pid : 'N/A' , node_version : 'N/A' , teraslice_version : 'N/A' , total : 'N/A' , state : 'connected' , available : 'N/A' , active : [ ] } ; } const worker = { assets : [ ] , assignment : pod . metadata . labels . nodeType , ex_id : pod . metadata . labels . exId , image : pod . spec . containers [ 0 ] . image , job_id : pod . metadata . labels . jobId , pod_name : pod . metadata . name , pod_ip : pod . status . podIP , worker_id : pod . metadata . name , } ; if ( pod . status . phase === 'Running' ) { clusterState [ pod . status . hostIP ] . active . push ( worker ) ; } } } ) ; }
1724	function _getDateFromScrollWheels ( ) { var date = new Date ( this . _date ) ; for ( var i = 0 ; i < this . scrollWheels . length ; i ++ ) { var scrollWheel = this . scrollWheels [ i ] ; var component = scrollWheel . component ; var item = scrollWheel . scrollController . getFirstVisibleItem ( ) ; if ( item && item . renderNode ) { component . setComponent ( date , component . getComponent ( item . renderNode . date ) ) ; } } return date ; }
684	function ( ) { const item = items . pop ( ) ; if ( ! item ) { return Promise . resolve ( { done : true } ) ; } return deleteItem ( item , session ) ; }
3522	function compile ( content , options ) { options = merge ( { outputLanguage : 'es5' , modules : 'commonjs' , filename : '<unknown file>' , sourceMap : false , cwd : process . cwd ( ) , moduleName : false } , options || { } ) ; var moduleName = options . moduleName ; traceurOptions . reset ( ) ; merge ( traceurOptions , options ) ; var errorReporter = new ErrorReporter ( ) ; var sourceFile = new SourceFile ( options . filename , content ) ; var parser = new Parser ( sourceFile , errorReporter ) ; var tree = parser . parseModule ( ) ; var transformer ; if ( moduleName === true || options . modules == 'register' || options . modules == 'inline' ) { moduleName = options . filename . replace ( / \.js$ / , '' ) ; moduleName = path . relative ( options . cwd , moduleName ) . replace ( / \\ / g , '/' ) ; } if ( moduleName ) { transformer = new AttachModuleNameTransformer ( moduleName ) ; tree = transformer . transformAny ( tree ) ; } if ( options . outputLanguage . toLowerCase ( ) === 'es6' ) { transformer = new PureES6Transformer ( errorReporter ) ; } else { transformer = new FromOptionsTransformer ( errorReporter ) ; } var transformedTree = transformer . transform ( tree ) ; if ( errorReporter . hadError ( ) ) { return { js : null , errors : errorReporter . errors , sourceMap : null } ; } var treeWriterOptions = { } ; if ( options . sourceMap ) { treeWriterOptions . sourceMapGenerator = new SourceMapGenerator ( { file : options . filename , sourceRoot : null } ) ; } return { js : TreeWriter . write ( transformedTree , treeWriterOptions ) , errors : errorReporter . errors , sourceMap : treeWriterOptions . sourceMap || null } ; }
1010	function baseName ( path ) { const parts = path . split ( '/' ) ; if ( path . substr ( - 1 ) === '/' ) { return parts [ parts . length - 2 ] + '/' ; } else { return parts [ parts . length - 1 ] ; } }
3383	function ( options ) { var form = this . getForm ( options ) ; if ( form ) { return ( options . isUpload || ( / multipart\/form-data / i ) . test ( form . getAttribute ( 'enctype' ) ) ) ; } return false ; }
2495	function ( ) { var f = $ . jstree . _focused ( ) ; if ( f && f !== this ) { f . get_container ( ) . removeClass ( "jstree-focused" ) ; } if ( f !== this ) { this . get_container ( ) . addClass ( "jstree-focused" ) ; focused_instance = this . get_index ( ) ; } this . __callback ( ) ; }
397	function readStylesheets ( files , outputBanner ) { return Promise . all ( files . map ( ( filename ) => { if ( isURL ( filename ) ) { return new Promise ( ( resolve , reject ) => { request ( { url : filename , headers : { 'User-Agent' : 'UnCSS' } } , ( err , response , body ) => { if ( err ) { return reject ( err ) ; } return resolve ( body ) ; } ) ; } ) ; } else if ( fs . existsSync ( filename ) ) { return new Promise ( ( resolve , reject ) => { fs . readFile ( filename , 'utf-8' , ( err , contents ) => { if ( err ) { return reject ( err ) ; } return resolve ( contents ) ; } ) ; } ) ; } throw new Error ( ` ${ path . join ( process . cwd ( ) , filename ) } ` ) ; } ) ) . then ( ( res ) => { if ( outputBanner ) { for ( let i = 0 , len = files . length ; i < len ; i ++ ) { const banner = ` ${ files [ i ] . replace ( / \\ / g , '/' ) } \n ` ; res [ i ] = banner + res [ i ] ; } } return res ; } ) ; }
1077	function Redirect ( { computedMatch , to , push = false } ) { return ( < RouterContext . Consumer > { ( context ) => { invariant ( context , 'You should not use <Redirect> outside a <Router>' ) ; const { history , staticContext } = context ; const method = push ? history . push : history . replace ; const location = createLocation ( computedMatch ? typeof to === 'string' ? generatePath ( to , computedMatch . params ) : { ... to , pathname : generatePath ( to . pathname , computedMatch . params ) } : to ) ; if ( staticContext ) { method ( location ) ; return null ; } return ( < Lifecycle onMount = { ( ) => { method ( location ) ; } } onUpdate = { ( self , prevProps ) => { const prevLocation = createLocation ( prevProps . to ) ; if ( ! locationsAreEqual ( prevLocation , { ... location , key : prevLocation . key } ) ) { method ( location ) ; } } } to = { to } / > ) ; } } < / RouterContext . Consumer > ) ; }
2954	function cache ( app ) { if ( app . locals . config . cacheDb && 'redis' === app . locals . config . cacheDb . connector ) { let redis = require ( "redis" ) . createClient ( app . locals . config . cacheDb ) ; redis . on ( "error" , function ( err ) { app . error ( err ) ; } ) ; redis . del ( 'zlSites' , 'themeTrees' , 'themesConfig' ) ; return { get : function ( ) { if ( 3 == arguments . length ) { redis . hget ( arguments [ 0 ] , arguments [ 1 ] , arguments [ 2 ] ) ; } else if ( 2 == arguments . length ) { redis . get ( arguments [ 0 ] , arguments [ 1 ] ) ; } } , set : function ( ) { if ( 4 == arguments . length ) { redis . hset ( arguments [ 0 ] , arguments [ 1 ] , arguments [ 2 ] , arguments [ 3 ] ) ; } else if ( 3 == arguments . length ) { redis . set ( arguments [ 0 ] , arguments [ 1 ] , arguments [ 2 ] ) ; } } , setvol : function ( ) { if ( 4 == arguments . length ) { redis . set ( arguments [ 0 ] , arguments [ 1 ] , ( ) => { redis . expire ( arguments [ 0 ] , arguments [ 2 ] , arguments [ 3 ] ) ; } ) ; } } , del : function ( ) { if ( 3 == arguments . length ) { redis . hdel ( arguments [ 0 ] , arguments [ 1 ] , arguments [ 2 ] ) ; } else if ( 2 == arguments . length ) { redis . del ( arguments [ 0 ] , arguments [ 1 ] ) ; } } } } else { app . error ( 'No config.cacheDb provided. This may affect performance.' ) ; let e = function ( ) { arguments [ arguments . length - 1 ] ( ) ; } return { get : e , set : e , setvol : e , del : e } } }
2001	function listenNodeList ( nodeList , type , callback ) { Array . prototype . forEach . call ( nodeList , function ( node ) { node . addEventListener ( type , callback ) ; } ) ; return { destroy : function ( ) { Array . prototype . forEach . call ( nodeList , function ( node ) { node . removeEventListener ( type , callback ) ; } ) ; } } }
3615	function database ( n ) { var dbid = new Buffer ( [ 0xFE ] ) , len = this . getLengthEncoding ( n , false ) ; return Buffer . concat ( [ dbid , len ] , dbid . length + len . length ) ; }
2767	function two ( context , next ) { setTimeout ( function ( ) { context . two = 'Hello' ; console . log ( 'Hello from two' , context ) ; chain ( { nested : 'Hello' } , [ one , three ] ) ; return next ( ) ; } , 1000 ) ; }
3691	function equals ( x , y ) { let rc = new RecurseCounter ( 1000 ) ; return _equals . call ( null , x , y , rc ) ; }
1289	function ArrayFind ( predicate , thisArg ) { CHECK_OBJECT_COERCIBLE ( this , "Array.prototype.find" ) ; var array = TO_OBJECT ( this ) ; var length = TO_INTEGER ( array . length ) ; return InnerArrayFind ( predicate , thisArg , array , length ) ; }
278	function stopMutationObserver ( ) { if ( mutationObserver && mutationObserverActive ) { activePlaceholders = [ ] ; activePlaceholderEverDetected = false ; mutationObserver . disconnect ( ) ; mutationObserverActive = false ; } }
3188	function ( title ) { var me = this , titleCmp = me . titleCmp ; me . title = title ; if ( titleCmp . rendered ) { titleCmp . textEl . update ( me . title || '&#160;' ) ; titleCmp . updateLayout ( ) ; } else { me . titleCmp . on ( { render : function ( ) { me . setTitle ( title ) ; } , single : true } ) ; } }
451	function formatData ( dataset , props , expectedKeys ) { const isArrayOrIterable = Array . isArray ( dataset ) || Immutable . isIterable ( dataset ) ; if ( ! isArrayOrIterable || getLength ( dataset ) < 1 ) { return [ ] ; } const defaultKeys = [ "x" , "y" , "y0" ] ; expectedKeys = Array . isArray ( expectedKeys ) ? expectedKeys : defaultKeys ; const stringMap = { x : expectedKeys . indexOf ( "x" ) !== - 1 ? createStringMap ( props , "x" ) : undefined , y : expectedKeys . indexOf ( "y" ) !== - 1 ? createStringMap ( props , "y" ) : undefined , y0 : expectedKeys . indexOf ( "y0" ) !== - 1 ? createStringMap ( props , "y" ) : undefined } ; const createAccessor = ( name ) => { return Helpers . createAccessor ( props [ name ] !== undefined ? props [ name ] : name ) ; } ; const accessor = expectedKeys . reduce ( ( memo , type ) => { memo [ type ] = createAccessor ( type ) ; return memo ; } , { } ) ; const preformattedData = isEqual ( expectedKeys , defaultKeys ) && props . x === "_x" && props . y === "_y" && props . y0 === "_y0" ; const data = preformattedData ? dataset : dataset . reduce ( ( dataArr , datum , index ) => { datum = parseDatum ( datum ) ; const fallbackValues = { x : index , y : datum } ; const processedValues = expectedKeys . reduce ( ( memo , type ) => { const processedValue = accessor [ type ] ( datum ) ; const value = processedValue !== undefined ? processedValue : fallbackValues [ type ] ; if ( value !== undefined ) { if ( typeof value === "string" && stringMap [ type ] ) { memo [ ` ${ type } ` ] = value ; memo [ ` ${ type } ` ] = stringMap [ type ] [ value ] ; } else { memo [ ` ${ type } ` ] = value ; } } return memo ; } , { } ) ; const formattedDatum = assign ( { } , processedValues , datum ) ; if ( ! isEmpty ( formattedDatum ) ) { dataArr . push ( formattedDatum ) ; } return dataArr ; } , [ ] ) ; const sortedData = sortData ( data , props . sortKey , props . sortOrder ) ; const cleanedData = cleanData ( sortedData , props ) ; return addEventKeys ( props , cleanedData ) ; }
74	function replaceAll ( ) { var input = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : '' ; var find = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : '' ; var replace = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : '' ; return input . replace ( new RegExp ( find . toString ( ) . replace ( / ([.*+?^=!:${}()|[\]/\\]) / g , '\\$1' ) , \\ ) , 'g' ) ; }
3166	function consume_directive_entity ( proc_stack ) { let pos = proc_stack . _tGetNPos ( ) ; proc_stack . tSkip ( 4 ) ; let directive_name = proc_stack . tAcceptUntil ( "(" ) ; proc_stack . tSkip ( ) ; let raw_args = { } ; do { proc_stack . tSkipWhile ( WHITESPACE ) ; if ( proc_stack . tPeek ( ) == ")" ) { break ; } let arg_name = proc_stack . tAcceptUntil ( "=" ) ; proc_stack . tSkip ( ) ; raw_args [ arg_name ] = consume_char_data_with_entity_directives ( proc_stack , true , "," , ")" ) ; } while ( proc_stack . tSkipIf ( "," ) ) ; if ( ! proc_stack . tSkipIf ( ")" ) ) { throw new SyntaxError ( ` ` ) ; } proc_stack . tSkipIf ( ";" ) ; return new DirectiveExpr ( proc_stack , pos , directive_name , raw_args ) ; }
1763	function ial ( app , opts ) { Object . defineProperty ( app . context , 'i18n' , { get : function ( ) { if ( this . _i18n ) { return this . _i18n } const i18n = new I18n ( opts ) i18n . request = this . request this . _i18n = i18n this . state . i18n = i18n registerMethods ( this . state , i18n ) debug ( 'app.ctx.i18n %j' , i18n ) return i18n } } ) Object . defineProperty ( app . request , 'i18n' , { get : function ( ) { return this . ctx . i18n } } ) return function i18nMiddleware ( ctx , next ) { ctx . i18n . whitelist . some ( key => { const customLocaleMethod = typeof key === 'function' && ctx . i18n . setLocale ( key . apply ( ctx ) ) if ( customLocaleMethod || ctx . i18n [ SET_PREFIX + key ] ( ) ) return true } ) return next ( ) } }
1986	function ( e ) { e . data . handler . over = true ; $ . iframeTracker . retrieveFocus ( ) ; try { e . data . handler . overCallback ( this , e ) ; } catch ( ex ) { } }
1438	async function ( ) { await qx . tool . cli . Utils . makeParentDir ( this . getCachePath ( ) ) ; await fs . writeFileAsync ( this . getCachePath ( ) , JSON . stringify ( this . __cache , null , 2 ) , "UTF-8" ) ; }
1300	function BuildCodeInfoTree ( code_info_array ) { var index = 0 ; function BuildNode ( ) { var my_index = index ; index ++ ; var child_array = new GlobalArray ( ) ; while ( index < code_info_array . length && code_info_array [ index ] . outer_index == my_index ) { child_array . push ( BuildNode ( ) ) ; } var node = new CodeInfoTreeNode ( code_info_array [ my_index ] , child_array , my_index ) ; for ( var i = 0 ; i < child_array . length ; i ++ ) { child_array [ i ] . parent = node ; } return node ; } var root = BuildNode ( ) ; Assert ( index == code_info_array . length ) ; return root ; }
1748	function encodeSignature ( method ) { const signature = ` ${ method . name } ${ utils . getKeys ( method . inputs , 'type' ) . join ( ',' ) } ` ; const signatureEncoded = ` ${ ( new Buffer ( utils . keccak256 ( signature ) , 'hex' ) ) . slice ( 0 , 4 ) . toString ( 'hex' ) } ` ; return signatureEncoded ; }
2657	function smsAddPhonesToBlacklist ( callback , phones , comment ) { if ( ( phones === undefined ) || ( ! phones . length ) ) { return callback ( returnError ( "Empty phones" ) ) ; } var data = { 'phones' : JSON . stringify ( phones ) , 'description' : comment } sendRequest ( 'sms/black_list' , 'POST' , data , true , callback ) ; }
1603	function compileFile ( srcPath , dstPath , format , toStdout ) { if ( ! fs . existsSync ( dstPath ) ) { makePath ( dstPath ) } fs . readFile ( srcPath , 'utf8' , function ( err , data ) { if ( err ) throw err var cwd = process . cwd ( ) var smapDstPath = dstPath + '.map' var smapSrcPath = path . relative ( path . dirname ( path . join ( cwd , dstPath ) ) , path . join ( cwd , srcPath ) ) var result = ram . compile ( data , { filename : srcPath , format : format , sourceMap : ! toStdout , sourceMapCfg : { source : smapSrcPath , sourceContent : data } } ) if ( toStdout ) { process . stdout . write ( result . js + '\n' ) \n } return if ( result . js ) { result . js = result . js + '\n//# sourceMappingURL=' + \n + path . basename ( dstPath ) '.map' } } ) }
944	function initRelations ( component , isPage ) { let relations = component . relations ; if ( ! relations || isPage ) { return ; } Object . keys ( relations ) . forEach ( k => { let item = relations [ k ] ; let { target } = item ; if ( typeof target === 'function' ) { target = target ( ) ; item . target = target . behavior ; } } ) ; }
3102	function applyEachOptimization ( rel ) { var originalRel = rel rel = JSON . parse ( JSON . stringify ( rel ) ) try { var newImplicits = [ rel . params [ 1 ] . implicits [ 0 ] ] var bindingsUsed = _ . extend ( { } , rel . params [ 1 ] . bindingsUsed ) var maps = [ ] var failed = false var newMacroExpr = replaceMacroPropertyExpressions ( rel . params [ 1 ] . expr , rel . params [ 1 ] . implicits , function ( macroPropertyExpr ) { if ( macroPropertyExpr . schemaType . type === 'map' ) { failed = true return } var uid = 'extproperty_' + Math . random ( ) var bu = { } bu [ uid ] = true var m = { type : 'view' , view : 'map' , params : [ rel . params [ 0 ] , { type : 'macro' , manyImplicits : 1 , expr : { type : 'param' , name : uid , schemaType : rel . params [ 0 ] . schemaType . members } , bindingsUsed : bu , implicits : [ uid ] , schemaType : rel . params [ 0 ] . schemaType . members , implicitTypes : [ rel . params [ 0 ] . schemaType . members ] } , { type : 'macro' , manyImplicits : 1 , expr : JSON . parse ( JSON . stringify ( macroPropertyExpr ) ) , bindingsUsed : bu , implicits : [ rel . params [ 1 ] . implicits [ 0 ] ] , schemaType : macroPropertyExpr . schemaType , implicitTypes : [ rel . params [ 1 ] . implicitTypes [ 0 ] ] } ] , willBeOptimized : true , uid : uid } m . schemaType = { type : 'map' , key : m . params [ 1 ] . schemaType , value : m . params [ 2 ] . schemaType } maps . push ( applyEachOptimizationToView ( m ) ) newImplicits . push ( uid ) bindingsUsed [ uid ] = true _ . assertDefined ( macroPropertyExpr . schemaType ) return { type : 'param' , name : uid , schemaType : macroPropertyExpr . schemaType } } ) if ( failed ) return originalRel var newMacro = { type : 'macro' , expr : newMacroExpr , manyImplicits : newImplicits . length , implicits : newImplicits , implicitTypes : [ rel . params [ 0 ] . schemaType . members ] , bindingsUsed : bindingsUsed , schemaType : newMacroExpr . schemaType } return { type : 'view' , view : 'each-optimization' , params : [ rel . params [ 0 ] , newMacro ] . concat ( maps ) , schemaType : rel . schemaType , code : rel . code } } catch ( e ) { return originalRel } }
1292	function GetMethod ( obj , p ) { var func = obj [ p ] ; if ( IS_NULL_OR_UNDEFINED ( func ) ) return UNDEFINED ; if ( IS_CALLABLE ( func ) ) return func ; throw MakeTypeError ( kCalledNonCallable , typeof func ) ; }
3856	function takeHeader ( content , level , name ) { var currLevel = sectionStack . length if ( level > currLevel + 1 ) { throwSyntaxError ( 'Unexpected header level ' + level + ' on section level ' + currLevel ) } else if ( level === 1 ) { throwSyntaxError ( 'There can be only one header level 1, the first line of the file' ) } sectionStack . length = level - 1 section = { type : 'section' , name : name || '' , line : line , size : 1 , content : content , level : level , children : [ ] } sectionStack [ sectionStack . length - 1 ] . children . push ( section ) sectionStack . push ( section ) }
2054	function ( scope ) { if ( ! scope ) throw ( 'textAngular Error: A toolbar requires a scope' ) ; if ( ! scope . name || scope . name === '' ) throw ( 'textAngular Error: A toolbar requires a name' ) ; if ( toolbars [ scope . name ] ) throw ( 'textAngular Error: A toolbar with name "' + scope . name + '" already exists' ) ; toolbars [ scope . name ] = scope ; angular . forEach ( editors , function ( _editor ) { _editor . _registerToolbar ( scope ) ; } ) ; }
370	function copyPolyfills ( pluginConfig , outputConfig ) { if ( ! pluginConfig . polyfillDynamicImports && ! pluginConfig . polyfillWebcomponents && ! pluginConfig . polyfillBabel ) { return ; } const polyfillsDir = ` ${ outputConfig . dir . replace ( '/legacy' , '' ) } ` ; mkdirp . sync ( polyfillsDir ) ; if ( pluginConfig . polyfillDynamicImports ) { copyFileSync ( path . resolve ( pathJoin ( __dirname , '../../src/dynamic-import-polyfill.js' ) ) , ` ${ polyfillsDir } ` , ) ; } if ( pluginConfig . polyfillWebcomponents ) { copyFileSync ( require . resolve ( '@webcomponents/webcomponentsjs/webcomponents-bundle.js' ) , ` ${ polyfillsDir } ` , ) ; } if ( pluginConfig . polyfillBabel ) { copyFileSync ( require . resolve ( '@babel/polyfill/browser.js' ) , ` ${ polyfillsDir } ` , ) ; } }
495	function oldVideoTimeupdate ( ) { var currentTime = _this2 . kernel . currentTime ; if ( bias <= 0 && currentTime >= idealTime || bias > 0 && ( Math . abs ( idealTime - currentTime ) <= bias && newVideoReady || currentTime - idealTime > bias ) ) { chimeeHelper . removeEvent ( _this2 . dom . videoElement , 'timeupdate' , oldVideoTimeupdate ) ; chimeeHelper . removeEvent ( video , 'error' , _videoError , true ) ; if ( ! newVideoReady ) { chimeeHelper . removeEvent ( video , 'canplay' , videoCanplay , true ) ; chimeeHelper . removeEvent ( video , 'loadedmetadata' , videoLoadedmetadata , true ) ; kernel . destroy ( ) ; return resolve ( ) ; } return reject ( { error : false , video : video , kernel : kernel } ) ; } }
515	function runTx ( raw , cb ) { var tx = new Transaction ( raw ) tx . sign ( Buffer . from ( keyPair . secretKey , 'hex' ) ) console . log ( '----running tx-------' ) vm . runTx ( { tx : tx } , function ( err , results ) { createdAddress = results . createdAddress console . log ( 'gas used: ' + results . gasUsed . toString ( ) ) console . log ( 'returned: ' + results . vm . return . toString ( 'hex' ) ) if ( createdAddress ) { console . log ( 'address created: ' + createdAddress . toString ( 'hex' ) ) } cb ( err ) } ) }
282	function insertDOM ( ) { if ( null !== document . getElementById ( 'directlyRTMScript' ) ) { return ; } const d = document . createElement ( 'div' ) ; d . id = 'directlyRTMScript' ; d . src = DIRECTLY_ASSETS_BASE_URL ; document . body . appendChild ( d ) ; }
2171	function keydown ( event ) { switch ( event . keyCode ) { case $mdConstant . KEY_CODE . DOWN_ARROW : if ( ctrl . loading ) return ; event . stopPropagation ( ) ; event . preventDefault ( ) ; ctrl . index = Math . min ( ctrl . index + 1 , ctrl . matches . length - 1 ) ; updateScroll ( ) ; reportMessages ( false , ReportType . Selected ) ; break ; case $mdConstant . KEY_CODE . UP_ARROW : if ( ctrl . loading ) return ; event . stopPropagation ( ) ; event . preventDefault ( ) ; ctrl . index = ctrl . index < 0 ? ctrl . matches . length - 1 : Math . max ( 0 , ctrl . index - 1 ) ; updateScroll ( ) ; reportMessages ( false , ReportType . Selected ) ; break ; case $mdConstant . KEY_CODE . TAB : onListLeave ( ) ; if ( ctrl . hidden || ctrl . loading || ctrl . index < 0 || ctrl . matches . length < 1 ) return ; select ( ctrl . index ) ; break ; case $mdConstant . KEY_CODE . ENTER : if ( ctrl . hidden || ctrl . loading || ctrl . index < 0 || ctrl . matches . length < 1 ) return ; if ( hasSelection ( ) ) return ; event . stopPropagation ( ) ; event . preventDefault ( ) ; select ( ctrl . index ) ; break ; case $mdConstant . KEY_CODE . ESCAPE : event . preventDefault ( ) ; if ( ! shouldProcessEscape ( ) ) return ; event . stopPropagation ( ) ; clearSelectedItem ( ) ; if ( $scope . searchText && hasEscapeOption ( 'clear' ) ) { clearSearchText ( ) ; } ctrl . hidden = true ; if ( hasEscapeOption ( 'blur' ) ) { doBlur ( true ) ; } break ; default : } }
50	function round ( number , step ) { if ( step < 1 ) { var places = getDecimalPlaces ( step ) ; return parseFloat ( number . toFixed ( places ) ) ; } return Math . round ( number / step ) * step ; }
900	function createInitCallArgs ( declarationPath , config , opts , t ) { let { isPage , isComponent , isApp , getInitOptions } = opts ; let callArgs = [ declarationPath . node ] ; let initOptions ; if ( opts . tplRefs ) { initOptions = { refs : opts . tplRefs } ; } let extraInitOpts = getInitOptions && getInitOptions ( config , { isPage , isComponent , isApp } ) ; if ( extraInitOpts ) { initOptions || ( initOptions = { } ) ; Object . assign ( initOptions , extraInitOpts ) ; } if ( initOptions ) { callArgs . push ( createSimpleObjectExpression ( initOptions , t ) ) ; } return callArgs ; }
3756	function forward ( receiver , provider , keys ) { keys = keys || allKeys ( provider ) ; keys = Array . isArray ( keys ) ? keys : [ keys ] ; keys . forEach ( function ( key ) { var val = provider [ key ] ; if ( typeof val === 'function' ) { receiver [ key ] = function ( ) { return provider [ key ] . apply ( provider , arguments ) ; } ; } else { receiver [ key ] = val ; } } ) ; return receiver ; }
3881	function filter ( predicate ) { return flatMap ( value => predicate ( value ) ? maybe_1 . just ( value ) : maybe_1 . nothing ( ) ) ; }
3153	function getLogsObject ( name , callback ) { fs . readFile ( path . join ( LOG_DIR , name ) , function ( err , data ) { if ( err ) { return callback ( err , null ) ; } safejson . parse ( data , function ( err , logArray ) { if ( err ) { return callback ( err , null ) ; } callback ( null , { logs : logArray } ) ; } ) ; } ) ; }
3414	function manager ( map , key ) { if ( ! ( key instanceof Object ) ) { throw new TypeError ( 'Key must be an object' ) } let contents = map . get ( key ) if ( ! contents ) { map . set ( key , contents = { } ) } return contents }
2030	function saveWallet ( filename , walletData ) { return new Promise ( ( resolve , reject ) => { fs . writeFile ( filename , JSON . stringify ( walletData , null , 2 ) , function ( err ) { if ( err ) return reject ( console . error ( err ) ) return resolve ( ) } ) } ) }
186	function storeInfoSubmitError ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT_FAILURE : const error = WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT_FAILURE === action . type ? action . error : false ; return error ; } return state ; }
1705	function _ensureVisibleSequence ( viewSequence , next ) { this . _scroll . scrollToSequence = undefined ; this . _scroll . scrollToRenderNode = undefined ; this . _scroll . ensureVisibleRenderNode = viewSequence . get ( ) ; this . _scroll . scrollToDirection = next ; this . _scroll . scrollDirty = true ; }
2987	function ( forModel ) { let model = { model : app . models [ forModel ] , prop : app . models [ forModel ] . definition . properties , settings : app . models [ forModel ] . settings , meta : app . models [ forModel ] . settings . zlMeta , ns : '' } ; if ( model . meta && model . meta [ 'Namespace' ] ) { model . ns = model . meta [ 'Namespace' ] ; } return model ; }
217	function setup ( ) { var build = null , errors = '' , rootdir = path . resolve ( __dirname , '..' , '..' ) ; function spawnMake ( ) { debug ( 'spawning %o' , 'npm run build-css' ) ; build = spawn ( 'npm' , [ 'run' , 'build-css' ] , { shell : true , cwd : rootdir , stdio : [ 'ignore' , 'pipe' , 'pipe' ] , } ) ; errors = '' ; build . once ( 'exit' , onexit ) ; build . stdout . setEncoding ( 'utf8' ) ; build . stdout . on ( 'data' , onstdout ) ; build . stderr . on ( 'data' , onstderr ) ; } function onstdout ( d ) { debug ( 'stdout %o' , d . trim ( ) ) ; } function onexit ( ) { build . stderr . removeListener ( 'data' , onstderr ) ; build . stdout . removeListener ( 'data' , onstdout ) ; build = null ; } function onstderr ( stderr ) { process . stderr . write ( stderr . toString ( 'utf8' ) ) ; errors += stderr . toString ( 'utf8' ) ; } return function ( req , res , next ) { if ( ! build ) { spawnMake ( ) ; } build . once ( 'exit' , function ( code ) { if ( 0 === code ) { next ( ) ; } else { res . send ( '<pre>`npm run build-css` failed \n\n' + \n + \n ) ; } } ) ; } ; }
1155	function ( o , angle ) { angle = ( angle + 360 ) % 360 ; this . toPolar ( o ) ; this . y += toRad ( angle ) ; var p = point . fromPolar ( this . x , this . y , o ) ; this . x = p . x ; this . y = p . y ; return this ; }
3191	function ( glyph ) { var me = this , iconCmp = me . iconCmp ; if ( ! me . iconCmp ) { me . initIconCmp ( ) ; me . insert ( 0 , me . iconCmp ) ; } else if ( iconCmp ) { if ( glyph ) { me . iconCmp . setGlyph ( glyph ) ; } else { me . iconCmp . destroy ( ) ; delete me . iconCmp ; } } }
1202	function _isBlankTextNode ( node ) { return node . nodeType === wysihtml5 . TEXT_NODE && ! wysihtml5 . lang . string ( node . data ) . trim ( ) ; }
352	function ( event ) { var target = event . target ; if ( ( target !== absoluteAnchor ) && ! util . isChildOf ( target , absoluteAnchor ) ) { destroy ( ) ; } }
3277	async function resolveModule ( moduleId , options , root = options . base ) { if ( options . lookup . has ( moduleId ) ) return options . lookup . get ( moduleId ) ; const absolutePath = await options . resolver ( moduleId , root ) ; if ( options . mapper . hasOwnProperty ( absolutePath ) ) return options . mapper [ absolutePath ] ; if ( options . lookup . has ( absolutePath ) ) return options . lookup . get ( absolutePath ) ; return absolutePath ; }
758	function ( event , g , contextB ) { if ( event . preventDefault ) { event . preventDefault ( ) ; } else { event . returnValue = false ; event . cancelBubble = true ; } var canvasPos = utils . findPos ( g . canvas_ ) ; contextB . px = canvasPos . x ; contextB . py = canvasPos . y ; contextB . dragStartX = utils . dragGetX_ ( event , contextB ) ; contextB . dragStartY = utils . dragGetY_ ( event , contextB ) ; contextB . cancelNextDblclick = false ; contextB . tarp . cover ( ) ; }
1850	function Jenkins ( options , log ) { var parsed = url . parse ( options . url ) ; if ( options . username && options . password ) { parsed [ 'auth' ] = util . format ( '%s:%s' , options . username , options . password ) ; } this . _url = url . format ( parsed ) ; this . _options = options ; this . log = log || logmagic . local ( 'jenkins' ) ; }
3118	function ( ) { var me = this , result = me . getComponent ( me . activeTab ) ; if ( result && me . items . indexOf ( result ) != - 1 ) { me . activeTab = result ; } else { me . activeTab = null ; } return me . activeTab ; }
2421	function ( xyz , OMIT_MAG ) { var azi , elev , r ; var aziElevR = new Array ( xyz . length ) ; for ( var i = 0 ; i < xyz . length ; i ++ ) { azi = Math . atan2 ( xyz [ i ] [ 1 ] , xyz [ i ] [ 0 ] ) ; elev = Math . atan2 ( xyz [ i ] [ 2 ] , Math . sqrt ( xyz [ i ] [ 0 ] * xyz [ i ] [ 0 ] + xyz [ i ] [ 1 ] * xyz [ i ] [ 1 ] ) ) ; if ( OMIT_MAG == 1 ) { aziElevR [ i ] = [ azi , elev ] ; } else { r = Math . sqrt ( xyz [ i ] [ 0 ] * xyz [ i ] [ 0 ] + xyz [ i ] [ 1 ] * xyz [ i ] [ 1 ] + xyz [ i ] [ 2 ] * xyz [ i ] [ 2 ] ) ; aziElevR [ i ] = [ azi , elev , r ] ; } } return aziElevR ; }
1325	function getRange ( text ) { const range = text . match ( / \d+ / g ) . map ( Number ) ; if ( Number . isFinite ( range [ 1 ] ) && range [ 1 ] < range [ 0 ] ) { throw new SyntaxError ( ` ${ text } ` ) ; } return range ; }
339	function ( item ) { var that = this , r ; var docFrag = document . createDocumentFragment ( ) ; var option = this . options [ item . idx ] ; var data = this . data ? this . data [ item . idx ] : option ; var content = this . customSelected ? this . config . renderSelection ( data ) : option . textContent ; var tag = util . createElement ( "li" , { class : "selectr-tag" , html : content } ) ; var btn = util . createElement ( "button" , { class : "selectr-tag-remove" , type : "button" } ) ; tag . appendChild ( btn ) ; tag . idx = item . idx ; tag . tag = option . value ; this . tags . push ( tag ) ; if ( this . config . sortSelected ) { var tags = this . tags . slice ( ) ; r = function ( val , arr ) { val . replace ( / (\d+)|(\D+) / g , function ( that , $1 , $2 ) { arr . push ( [ $1 || Infinity , $2 || "" ] ) ; } ) ; } ; tags . sort ( function ( a , b ) { var x = [ ] , y = [ ] , ac , bc ; if ( that . config . sortSelected === true ) { ac = a . tag ; bc = b . tag ; } else if ( that . config . sortSelected === 'text' ) { ac = a . textContent ; bc = b . textContent ; } r ( ac , x ) ; r ( bc , y ) ; while ( x . length && y . length ) { var ax = x . shift ( ) ; var by = y . shift ( ) ; var nn = ( ax [ 0 ] - by [ 0 ] ) || ax [ 1 ] . localeCompare ( by [ 1 ] ) ; if ( nn ) return nn ; } return x . length - y . length ; } ) ; util . each ( tags , function ( i , tg ) { docFrag . appendChild ( tg ) ; } ) ; this . label . innerHTML = "" ; } else { docFrag . appendChild ( tag ) ; } if ( this . config . taggable ) { this . label . insertBefore ( docFrag , this . input . parentNode ) ; } else { this . label . appendChild ( docFrag ) ; } }
2718	function setUpDataStore ( dataStore , labels , dataLength ) { var i ; for ( i = 0 ; i < dataLength ; i ++ ) { dataStore [ i ] = { words : { } , labels : { } } ; labels . forEach ( function ( label ) { dataStore [ i ] . labels [ label ] = 0 ; } ) ; } }
1842	function render ( req , res , template , data , options ) { res . render ( template , misc . merge ( { user : req . remoteUser , title : dreadnot . config . name , env : dreadnot . config . env , url : req . originalUrl , emsg : res . emsg , wmsg : dreadnot . warning , helpers : viewHelpers , data : data } , options || { } ) ) ; }
1959	function processTemplate ( template , variables ) { for ( let variableName of Object . keys ( variables ) ) { let value = variables [ variableName ] ; template = replaceVariable ( template , variableName , value ) ; } template = evaluateConditions ( template , variables ) ; return template ; }
2675	function runSession ( evaluator , config ) { _session . signer = signers . create ( config . signature_scheme , config . key ) ; _session . io = createSocket ( 'pub' , config . ip , config . iopub_port ) ; _session . shell = createSocket ( 'xrep' , config . ip , config . shell_port , messageHandler ) ; _session . control = createSocket ( 'xrep' , config . ip , config . control_port , messageHandler ) ; _session . evaluator = evaluator ; _session . handlers = handlers . create ( _session ) ; createSocket ( 'rep' , config . ip , config . hb_port , heartbeatHandler ) ; }
2529	function cached ( opt ) { if ( typeof opt == 'undefined' || opt === null ) opt = { } ; if ( typeof opt == 'string' ) opt = { type : opt } ; if ( typeof opt . id != 'string' ) opt . id = _random_string ( 8 ) ; opt = Object . assign ( { } , getSettings ( ) , opt ) ; for ( var i in opt ) checkSetting ( i , opt [ i ] ) ; return function ( func , key , descriptor ) { if ( key ) func = func [ key ] ; const f = function ( ... rest ) { const _key = _hash ( rest , opt . id ) ; return cacheObj . get ( opt , _key ) . then ( res => { if ( typeof res == 'undefined' || res === null ) { res = _update . bind ( this ) ( opt , func , rest ) ; } return res ; } ) ; } f . forceUpdate = function ( ... rest ) { _update . bind ( this , opt , func ) ( rest ) } if ( key ) { descriptor . value = f ; } else { return f ; } } }
560	function ( newFaces ) { if ( this . unassigned . isEmpty ( ) === false ) { var vertex = this . unassigned . first ( ) ; do { var nextVertex = vertex . next ; var maxDistance = this . tolerance ; var maxFace = null ; for ( var i = 0 ; i < newFaces . length ; i ++ ) { var face = newFaces [ i ] ; if ( face . mark === Visible ) { var distance = face . distanceToPoint ( vertex . point ) ; if ( distance > maxDistance ) { maxDistance = distance ; maxFace = face ; } if ( maxDistance > 1000 * this . tolerance ) break ; } } if ( maxFace !== null ) { this . addVertexToFace ( vertex , maxFace ) ; } vertex = nextVertex ; } while ( vertex !== null ) ; } return this ; }
3100	function Simple ( ) { if ( arguments . length > 0 ) { this . _parse ( arguments [ 0 ] ) ; } else { var date = new Date ( ) ; this . _year = date . getUTCFullYear ( ) ; this . _month = date . getUTCMonth ( ) ; this . _day = date . getUTCDay ( ) ; this . _hours = date . getUTCHours ( ) ; this . _minutes = date . getUTCMinutes ( ) ; this . _seconds = date . getUTCSeconds ( ) ; this . _tzHours = 0 ; this . _tzMinutes = 0 ; } }
1007	function ( scope , mode ) { if ( typeof ( scope ) !== 'string' || scope . indexOf ( '/' ) !== - 1 || scope . length === 0 ) { throw new Error ( 'Scope should be a non-empty string without forward slashes' ) ; } if ( ! mode . match ( / ^rw?$ / ) ) { throw new Error ( 'Mode should be either \'r\' or \'rw\'' ) ; } \' \' }
152	function generateStaticUrls ( target ) { const urls = { ... staticFilesUrls } ; const assets = getAssets ( target ) . assetsByChunkName ; forEach ( assets , ( asset , name ) => { urls [ name ] = asset ; } ) ; return urls ; }
3544	function compose ( ) { var args = argsToArray ( arguments ) ; return function ( arg0 ) { return args . reduceRight ( function ( value , arg ) { return arg ( value ) ; } , arg0 ) ; } ; }
1558	function promisify ( orig , options ) { if ( typeof orig !== 'function' ) { throw new TypeError ( 'promisify requires a function' ) ; } if ( orig [ kCustomPromisifiedSymbol ] ) { const fn = orig [ kCustomPromisifiedSymbol ] ; if ( typeof fn !== 'function' ) { throw new TypeError ( 'The [util.promisify.custom] property must be a function' ) ; } Object . defineProperty ( fn , kCustomPromisifiedSymbol , { value : fn , enumerable : false , writable : false , configurable : true } ) ; return fn ; } function fn ( ) { const args = toArray ( arguments ) ; return new Promise ( ( resolve , reject ) => { args . push ( callbackBuilder ( resolve , reject , options ) ) ; try { orig . apply ( this , args ) ; } catch ( err ) { reject ( err ) ; } } ) ; } Object . setPrototypeOf ( fn , Object . getPrototypeOf ( orig ) ) ; Object . defineProperty ( fn , kCustomPromisifiedSymbol , { value : fn , enumerable : false , writable : false , configurable : true } ) ; return Object . defineProperties ( fn , getOwnPropertyDescriptors ( orig ) ) ; }
447	function getEventKey ( key ) { if ( isFunction ( key ) ) { return key ; } else if ( key === null || key === undefined ) { return ( ) => undefined ; } return property ( key ) ; }
1196	function parse ( elementOrHtml , rules , context , cleanUp ) { wysihtml5 . lang . object ( currentRules ) . merge ( defaultRules ) . merge ( rules ) . get ( ) ; context = context || elementOrHtml . ownerDocument || document ; var fragment = context . createDocumentFragment ( ) , isString = typeof ( elementOrHtml ) === "string" , element , newNode , firstChild ; if ( isString ) { element = wysihtml5 . dom . getAsDom ( elementOrHtml , context ) ; } else { element = elementOrHtml ; } while ( element . firstChild ) { firstChild = element . firstChild ; element . removeChild ( firstChild ) ; newNode = _convert ( firstChild , cleanUp ) ; if ( newNode ) { fragment . appendChild ( newNode ) ; } } element . innerHTML = "" ; element . appendChild ( fragment ) ; return isString ? wysihtml5 . quirks . getCorrectInnerHTML ( element ) : element ; }
1598	function updateIndent ( ) { var str = '' for ( var idx = 0 ; idx < this . indentLevel ; idx ++ ) { str += this . indentUnit } this . currentIndent = str }
1265	function getFilterClickHandler ( filter ) { var isKind = filter === 'kind' ; var has = isKind ? sbSearch . hasKind : sbSearch . hasScope ; var add = isKind ? sbSearch . addKind : sbSearch . addScope ; var remove = isKind ? sbSearch . removeKind : sbSearch . removeScope ; return function ( event ) { var btn = $ ( this ) ; var value = ( btn . attr ( 'data-' + filter ) || '*' ) . toLowerCase ( ) ; if ( has . call ( sbSearch , value ) ) { remove . call ( sbSearch , value ) ; } else if ( event . shiftKey ) { add . call ( sbSearch , value ) ; } else { sbSearch [ filter ] = [ value ] ; } var strSearch ; if ( $txtSearch ) { sbSearch . parseKeywords ( $txtSearch . val ( ) ) ; strSearch = sbSearch . toString ( ) ; $txtSearch . val ( strSearch ) . focus ( ) ; if ( $btnClean ) $btnClean . show ( ) ; } else { sbSearch . keywords = [ ] ; strSearch = sbSearch . toString ( ) ; } filterSidebarNodes ( strSearch ) ; } ; }
2142	function ( match , strUntilValue , name , value , index ) { var self = this ; var expression = value ; if ( ! this . isRelevantTagAttr ( this . currentTag , name ) ) { return ; } if ( isTemplate ( value ) ) { if ( pathIsAbsolute ( value ) && self . root !== undefined && self . parseDynamicRoutes ) { expression = loaderUtils . urlToRequest ( value , self . root ) ; } } this . matches . push ( { start : index + strUntilValue . length , length : value . length , value : value , expression : expression } ) ; }
1689	function _contextSet ( contextNodeOrId , set ) { var contextNode = this . _nodesById ? _contextGet . call ( this , contextNodeOrId ) : contextNodeOrId ; if ( contextNode ) { var node = contextNode . node ; if ( ! node ) { if ( contextNode . next ) { if ( contextNode . index < this . _contextState . nextSetIndex ) { LayoutUtility . error ( 'Nodes must be layed out in the same order as they were requested!' ) ; } this . _contextState . nextSetIndex = contextNode . index ; } else if ( contextNode . prev ) { if ( contextNode . index > this . _contextState . prevSetIndex ) { LayoutUtility . error ( 'Nodes must be layed out in the same order as they were requested!' ) ; } this . _contextState . prevSetIndex = contextNode . index ; } node = _contextGetCreateAndOrderNodes . call ( this , contextNode . renderNode , contextNode . prev ) ; node . _viewSequence = contextNode . viewSequence ; node . _layoutCount ++ ; if ( node . _layoutCount === 1 ) { this . _contextState . addCount ++ ; } contextNode . node = node ; } node . usesTrueSize = contextNode . usesTrueSize ; node . trueSizeRequested = contextNode . trueSizeRequested ; node . set ( set , this . _context . size ) ; contextNode . set = set ; } return set ; }
365	function getBoundaries ( popper , reference , padding , boundariesElement ) { var fixedPosition = arguments . length > 4 && arguments [ 4 ] !== undefined ? arguments [ 4 ] : false ; var boundaries = { top : 0 , left : 0 } ; var offsetParent = fixedPosition ? getFixedPositionOffsetParent ( popper ) : findCommonOffsetParent ( popper , reference ) ; if ( boundariesElement === 'viewport' ) { boundaries = getViewportOffsetRectRelativeToArtbitraryNode ( offsetParent , fixedPosition ) ; } else { var boundariesNode = void 0 ; if ( boundariesElement === 'scrollParent' ) { boundariesNode = getScrollParent ( getParentNode ( reference ) ) ; if ( boundariesNode . nodeName === 'BODY' ) { boundariesNode = popper . ownerDocument . documentElement ; } } else if ( boundariesElement === 'window' ) { boundariesNode = popper . ownerDocument . documentElement ; } else { boundariesNode = boundariesElement ; } var offsets = getOffsetRectRelativeToArbitraryNode ( boundariesNode , offsetParent , fixedPosition ) ; if ( boundariesNode . nodeName === 'HTML' && ! isFixed ( offsetParent ) ) { var _getWindowSizes = getWindowSizes ( popper . ownerDocument ) , height = _getWindowSizes . height , width = _getWindowSizes . width ; boundaries . top += offsets . top - offsets . marginTop ; boundaries . bottom = height + offsets . top ; boundaries . left += offsets . left - offsets . marginLeft ; boundaries . right = width + offsets . left ; } else { boundaries = offsets ; } } padding = padding || 0 ; var isPaddingNumber = typeof padding === 'number' ; boundaries . left += isPaddingNumber ? padding : padding . left || 0 ; boundaries . top += isPaddingNumber ? padding : padding . top || 0 ; boundaries . right -= isPaddingNumber ? padding : padding . right || 0 ; boundaries . bottom -= isPaddingNumber ? padding : padding . bottom || 0 ; return boundaries ; }
2694	function htmlCommand ( shell , args , data , evaluationId ) { return shell . runtime . data . html ( data ) ; }
111	function getProviderByUrl ( url ) { if ( / ^(https?:\/\/)?(www\.)?(youtube\.com|youtube-nocookie\.com|youtu\.?be)\/.+$ / . test ( url ) ) { return providers . youtube ; } if ( / ^https?:\/\/player.vimeo.com\/video\/\d{0,9}(?=\b|\/) / . test ( url ) ) { return providers . vimeo ; } return null ; }
3760	function writeBuffer ( buffer ) { var written = fs . writeSync ( this . fd , buffer , 0 , buffer . length , null ) ; fs . fsyncSync ( this . fd ) ; return written ; }
3503	function isSingleLineNode ( node ) { var lastToken = context . getLastToken ( node ) , startLine = node . loc . start . line , endLine = lastToken . loc . end . line ; return startLine === endLine ; }
3127	function ( items ) { var me = this , i ; if ( items || me . hasListeners . remove ) { if ( items ) { for ( i = items . length - 1 ; i >= 0 ; -- i ) { me . remove ( items [ i ] ) ; } } else { while ( me . length ) { me . removeAt ( 0 ) ; } } } else { me . length = me . items . length = me . keys . length = 0 ; me . map = { } ; me . indexMap = { } ; me . generation ++ ; me . indexGeneration = me . generation ; } }
2956	function ( ) { if ( 4 == arguments . length ) { redis . hset ( arguments [ 0 ] , arguments [ 1 ] , arguments [ 2 ] , arguments [ 3 ] ) ; } else if ( 3 == arguments . length ) { redis . set ( arguments [ 0 ] , arguments [ 1 ] , arguments [ 2 ] ) ; } }
2078	function Plugin ( pluginPath ) { this . pluginPath = pluginPath ; this . we = we ; this . events = this . we . events ; this . hooks = this . we . hooks ; this . router = this . we . router ; this . assets = { js : { } , css : { } } ; this [ 'package.json' ] = require ( path . join ( pluginPath , 'package.json' ) ) ; this . controllersPath = path . join ( this . pluginPath , this . controllerFolder ) ; this . modelsPath = path . join ( this . pluginPath , this . modelFolder ) ; this . modelHooksPath = path . join ( this . pluginPath , this . modelHookFolder ) ; this . modelInstanceMethodsPath = path . join ( this . pluginPath , this . modelInstanceMethodFolder ) ; this . modelClassMethodsPath = path . join ( this . pluginPath , this . modelClassMethodFolder ) ; this . searchParsersPath = path . join ( this . pluginPath , this . searchParsersFolder ) ; this . searchTargetsPath = path . join ( this . pluginPath , this . searchTargetsFolder ) ; this . templatesPath = this . pluginPath + '/server/templates' ; this . helpersPath = this . pluginPath + '/server/helpers' ; this . resourcesPath = this . pluginPath + '/server/resources' ; this . routesPath = this . pluginPath + '/server/routes' ; this . helpers = { } ; this . layouts = { } ; this . templates = { } ; this . configs = { } ; this . controllers = { } ; this . models = { } ; this . routes = { } ; this . appFiles = [ ] ; this . appAdminFiles = [ ] ; }
512	function payOmmersAndMiner ( cb ) { var ommers = block . uncleHeaders async . series ( [ rewardOmmers , rewardMiner ] , cb ) function rewardOmmers ( done ) { async . each ( block . uncleHeaders , function ( ommer , next ) { var minerReward = new BN ( self . _common . param ( 'pow' , 'minerReward' ) ) var heightDiff = new BN ( block . header . number ) . sub ( new BN ( ommer . number ) ) var reward = ( ( new BN ( 8 ) ) . sub ( heightDiff ) ) . mul ( minerReward . divn ( 8 ) ) if ( reward . ltn ( 0 ) ) { reward = new BN ( 0 ) } rewardAccount ( ommer . coinbase , reward , next ) } , done ) } function rewardMiner ( done ) { var minerReward = new BN ( self . _common . param ( 'pow' , 'minerReward' ) ) var niblingReward = minerReward . divn ( 32 ) var totalNiblingReward = niblingReward . muln ( ommers . length ) var reward = minerReward . add ( totalNiblingReward ) rewardAccount ( block . header . coinbase , reward , done ) } function rewardAccount ( address , reward , done ) { self . stateManager . getAccount ( address , function ( err , account ) { if ( err ) return done ( err ) account . balance = new BN ( account . balance ) . add ( reward ) self . stateManager . putAccount ( address , account , done ) } ) } }
2952	function resetLocalOrResetUTC ( increment , date , utc ) { var _incrementHandlers ; var incrementHandlers = ( _incrementHandlers = { } , defineProperty ( _incrementHandlers , SECOND , function ( date ) { return new Date ( date [ 'set' + utc + 'Seconds' ] ( date [ 'get' + utc + 'Seconds' ] ( ) , 0 ) ) ; } ) , defineProperty ( _incrementHandlers , MINUTE , function ( date ) { return new Date ( date [ 'set' + utc + 'Minutes' ] ( date [ 'get' + utc + 'Minutes' ] ( ) , 0 , 0 ) ) ; } ) , defineProperty ( _incrementHandlers , HOUR , function ( date ) { return new Date ( date [ 'set' + utc + 'Hours' ] ( date [ 'get' + utc + 'Hours' ] ( ) , 0 , 0 , 0 ) ) ; } ) , defineProperty ( _incrementHandlers , DATE , function ( date ) { date [ 'set' + utc + 'Date' ] ( date [ 'get' + utc + 'Date' ] ( ) ) ; date [ 'set' + utc + 'Hours' ] ( 0 , 0 , 0 , 0 ) ; return new Date ( date ) ; } ) , defineProperty ( _incrementHandlers , WEEK , function ( date ) { date [ 'set' + utc + 'Date' ] ( date [ 'get' + utc + 'Date' ] ( ) - date [ 'get' + utc + 'Day' ] ( ) ) ; date [ 'set' + utc + 'Hours' ] ( 0 , 0 , 0 , 0 ) ; return new Date ( date ) ; } ) , defineProperty ( _incrementHandlers , MONTH , function ( date ) { date [ 'set' + utc + 'Month' ] ( date [ 'get' + utc + 'Month' ] ( ) , 1 ) ; date [ 'set' + utc + 'Hours' ] ( 0 , 0 , 0 , 0 ) ; return new Date ( date ) ; } ) , defineProperty ( _incrementHandlers , YEAR , function ( date ) { date [ 'set' + utc + 'FullYear' ] ( date [ 'get' + utc + 'FullYear' ] ( ) , 0 , 1 ) ; date [ 'set' + utc + 'Hours' ] ( 0 , 0 , 0 , 0 ) ; return new Date ( date ) ; } ) , _incrementHandlers ) ; return incrementHandlers [ increment ] ( date ) ; }
1894	function ( name ) { var val = this . get ( name ) ; if ( _ . isUndefined ( val ) || val === null || val === '' ) { return null ; } val = _ . map ( val . split ( ',' ) , require ( 'utils' ) . trim ) ; if ( ! val . length ) { return null ; } return val ; }
2627	function Parallel ( asyncFncWrapper ) { asyncFncWrapper = getAsyncFncWrapper ( asyncFncWrapper ) ; this . add = function ( ) { var fnc , args ; if ( arguments . length === 1 ) { fnc = arguments [ 0 ] ; } else if ( arguments . length > 1 ) { fnc = arguments [ arguments . length - 1 ] ; args = [ ] ; for ( var i = 0 ; i < arguments . length - 1 ; i ++ ) { args . push ( arguments [ i ] ) ; } } if ( typeof fnc !== 'function' ) throw new Error ( 'Async Parallel: Last argument have to be function(arg1, arg2, ..., next).' ) ; this . _fncQueue = this . _fncQueue || [ ] ; this . _fncQueue . push ( { args : args , fnc : fnc } ) ; this . execute = function ( finalFnc ) { var fncQueue = this . _fncQueue ; fncQueue . finished = 0 ; function run ( itm ) { asyncFncWrapper ( function ( ) { if ( itm . args ) { itm . args . push ( next ) ; itm . fnc . apply ( itm , itm . args ) ; } else itm . fnc ( next ) ; } ) ; } function next ( ) { if ( arguments . length > 0 ) throw new Error ( 'Async Parallel: next() callback do not accept any arguments, ' + 'because of parallel behaviour, it cannot stop executing on error argument in callback' ) ; else if ( ! fncQueue ) throw new Error ( 'Async Parallel: cannot execute next() more than once per function' ) ; else if ( fncQueue . finished + 1 < fncQueue . length ) { fncQueue . finished += 1 ; } else { fncQueue = null ; if ( typeof finalFnc === 'function' ) asyncFncWrapper ( finalFnc ) ; } } for ( var i = 0 ; i < ( fncQueue || [ ] ) . length ; i ++ ) { run ( fncQueue [ i ] ) ; } } ; return this ; } ; this . execute = function ( fnc ) { if ( typeof fnc === 'function' ) asyncFncWrapper ( fnc ) ; } ; }
284	function getInitialServerState ( initialReducer ) { if ( typeof window !== 'object' || ! window . initialReduxState || isSupportSession ( ) ) { return null ; } const serverState = deserialize ( window . initialReduxState , initialReducer ) ; return pick ( serverState , Object . keys ( window . initialReduxState ) ) ; }
3865	function text ( node , _text2 ) { if ( node && node . el ) { node . el . innerHTML = _text2 ; } }
1054	function NSpell ( aff , dic ) { var length var index var dictionaries if ( ! ( this instanceof NSpell ) ) { return new NSpell ( aff , dic ) } if ( typeof aff === 'string' || buffer ( aff ) ) { if ( typeof dic === 'string' || buffer ( dic ) ) { dictionaries = [ { dic : dic } ] } } else if ( aff ) { if ( 'length' in aff ) { dictionaries = aff aff = aff [ 0 ] && aff [ 0 ] . aff } else { if ( aff . dic ) { dictionaries = [ aff ] } aff = aff . aff } } if ( ! aff ) { throw new Error ( 'Missing `aff` in dictionary' ) } aff = affix ( aff ) this . data = { } this . compoundRuleCodes = aff . compoundRuleCodes this . replacementTable = aff . replacementTable this . conversion = aff . conversion this . compoundRules = aff . compoundRules this . rules = aff . rules this . flags = aff . flags length = dictionaries ? dictionaries . length : 0 index = - 1 while ( ++ index < length ) { dic = dictionaries [ index ] if ( dic && dic . dic ) { this . dictionary ( dic . dic ) } } }
1761	function ( opts ) { this . _client = Promise . promisifyAll ( redis . createClient ( opts ) ) ; if ( opts . db ) { this . _client . selectAsync ( opts . db ) ; } this . redisOpts = opts ; }
1809	function ( type ) { return Focusable . _domForEvent . call ( this , type ) || Container . prototype . domForEvent . call ( this , type ) ; }
1087	function makeHooksSafe ( routes , store ) { if ( Array . isArray ( routes ) ) { return routes . map ( route => makeHooksSafe ( route , store ) ) ; } const onEnter = routes . onEnter ; if ( onEnter ) { routes . onEnter = function safeOnEnter ( ... args ) { try { store . getState ( ) ; } catch ( err ) { if ( onEnter . length === 3 ) { args [ 2 ] ( ) ; } return ; } onEnter . apply ( null , args ) ; } ; } if ( routes . childRoutes ) { makeHooksSafe ( routes . childRoutes , store ) ; } if ( routes . indexRoute ) { makeHooksSafe ( routes . indexRoute , store ) ; } return routes ; }
1639	function ( el , check ) { var cls = el . classList var size = cls . length var result = false var i = 0 for ( i ; i < size ; i ++ ) { if ( cls [ i ] . toString ( ) === check ) result = true } return result }
253	function transferInitiateFailure ( siteId , error , plugin ) { const context = ! ! plugin ? 'plugin' : 'theme' ; return dispatch => { const themeInitiateFailureAction = { type : THEME_TRANSFER_INITIATE_FAILURE , siteId , error , } ; dispatch ( withAnalytics ( recordTracksEvent ( 'calypso_automated_transfer_initiate_failure' , { plugin , context } ) , themeInitiateFailureAction ) ) ; } ; }
2305	function ( data , obj , options ) { var result = { } ; Object . keys ( obj ) . forEach ( function ( key ) { result [ key ] = expander . process ( data , obj [ key ] , options ) ; } ) ; return result ; }
3010	function readyCb ( cb ) { if ( exports . slowGet ) { setTimeout ( function ( ) { cb ( undefined , api . getView ( viewId , historicalKey ) ) } , exports . slowGet ) } else { var viewObj = api . getView ( viewId , historicalKey ) if ( ! viewObj ) _ . errout ( 'could not find view object: ' + viewId ) cb ( undefined , viewObj ) } }
58	function extend ( ) { var target = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : { } ; for ( var _len = arguments . length , sources = new Array ( _len > 1 ? _len - 1 : 0 ) , _key = 1 ; _key < _len ; _key ++ ) { sources [ _key - 1 ] = arguments [ _key ] ; } if ( ! sources . length ) { return target ; } var source = sources . shift ( ) ; if ( ! is$1 . object ( source ) ) { return target ; } Object . keys ( source ) . forEach ( function ( key ) { if ( is$1 . object ( source [ key ] ) ) { if ( ! Object . keys ( target ) . includes ( key ) ) { Object . assign ( target , _defineProperty ( { } , key , { } ) ) ; } extend ( target [ key ] , source [ key ] ) ; } else { Object . assign ( target , _defineProperty ( { } , key , source [ key ] ) ) ; } } ) ; return extend . apply ( void 0 , [ target ] . concat ( sources ) ) ; }
845	function isNotSupportingOn ( node ) { return aCase => isNotSupportingVersion ( aCase ) && ( ! aCase . test || aCase . test ( { node , __proto__ : testInfoPrototype } ) ) }
2886	function ( schema , definition ) { return _ . reduce ( schema , function ( memo , field ) { var attrName = field . COLUMN_NAME . toLowerCase ( ) ; Object . keys ( definition ) . forEach ( function ( key ) { if ( attrName === key . toLowerCase ( ) ) attrName = key ; } ) ; var type = field . DATA_TYPE ; type = type . replace ( / \([0-9]+\)$ / , '' ) ; memo [ attrName ] = { type : type } ; if ( field . primaryKey ) { memo [ attrName ] . primaryKey = field . primaryKey ; } if ( field . unique ) { memo [ attrName ] . unique = field . unique ; } if ( field . indexed ) { memo [ attrName ] . indexed = field . indexed ; } return memo ; } , { } ) ; }
2776	function splitUnique ( string ) { string = string && string . trim ( ) ; if ( string ) { return unique ( string . split ( / \s+ / ) ) ; } else { return undefined ; } }
1206	function _execCommand ( doc , command , nodeName , className ) { if ( className ) { var eventListener = dom . observe ( doc , "DOMNodeInserted" , function ( event ) { var target = event . target , displayStyle ; if ( target . nodeType !== wysihtml5 . ELEMENT_NODE ) { return ; } displayStyle = dom . getStyle ( "display" ) . from ( target ) ; if ( displayStyle . substr ( 0 , 6 ) !== "inline" ) { target . className += " " + className ; } } ) ; } doc . execCommand ( command , false , nodeName ) ; if ( eventListener ) { eventListener . stop ( ) ; } }
3707	function skipWhile ( predicate ) { return function * ( iterable ) { let i = 0 ; let canReturn = false ; for ( const item of iterable ) { if ( ! canReturn ) { canReturn = ! predicate ( item , i ) ; if ( canReturn ) { yield item ; } i = i + 1 ; } else { yield item ; } } } ; }
522	function CreateSetPolyfill ( ) { return ( function ( ) { function Set ( ) { this . _map = new _Map ( ) ; } Object . defineProperty ( Set . prototype , "size" , { get : function ( ) { return this . _map . size ; } , enumerable : true , configurable : true } ) ; Set . prototype . has = function ( value ) { return this . _map . has ( value ) ; } ; Set . prototype . add = function ( value ) { return this . _map . set ( value , value ) , this ; } ; Set . prototype . delete = function ( value ) { return this . _map . delete ( value ) ; } ; Set . prototype . clear = function ( ) { this . _map . clear ( ) ; } ; Set . prototype . keys = function ( ) { return this . _map . keys ( ) ; } ; Set . prototype . values = function ( ) { return this . _map . values ( ) ; } ; Set . prototype . entries = function ( ) { return this . _map . entries ( ) ; } ; Set . prototype [ "@@iterator" ] = function ( ) { return this . keys ( ) ; } ; Set . prototype [ iteratorSymbol ] = function ( ) { return this . keys ( ) ; } ; return Set ; } ( ) ) ; }
2040	function ( app ) { var ret = false ; if ( config . apps [ app ] !== undefined ) { delete config . apps [ app ] ; configHelpers . saveConfig ( ) ; ret = true ; } return ret ; }
2462	function mergeModels ( value , model ) { const newModel = Object . assign ( { } , model ) ; tools_1 . deepExtend ( newModel , value ) ; return { model : newModel , isChanged : deepEqual ( model , newModel ) } ; }
803	function writeBody ( req , res , context , start , page ) { var elementPromises = PageUtil . standardizeElements ( page . getElements ( ) ) ; var rendered = elementPromises . map ( ( ) => ELEMENT_PENDING ) ; var dfds = elementPromises . map ( ( ) => Q . defer ( ) ) ; var doElement = ( element , index ) => { if ( rendered [ index ] === ELEMENT_ALREADY_WRITTEN ) return ; rendered [ index ] = renderElement ( res , element , context ) ; writeElements ( res , rendered ) ; dfds [ index ] . resolve ( ) ; } ; elementPromises . forEach ( ( promise , index ) => promise . then ( element => doElement ( element , index ) ) . catch ( e => { logger . error ( ` ${ index } ` , e ) try { if ( rendered [ index ] !== ELEMENT_ALREADY_WRITTEN ) { rendered [ index ] = '' ; writeElements ( res , rendered ) ; } } finally { dfds [ index ] . resolve ( ) ; } } ) . catch ( e => logger . error ( ` ${ index } ` , e ) ) ) ; var totalWait = DebugUtil . getRenderTimeout ( ) || FAILSAFE_RENDER_TIMEOUT , timeRemaining = totalWait - ( new Date - start ) var retval = Q . defer ( ) ; var writeBodyDfd = Q . defer ( ) ; writeBodyDfd . promise . catch ( ( err ) => { writeElements ( res , rendered . map ( value => value === ELEMENT_PENDING ? '' : value ) ) ; RLS ( ) . lateArrivals = undefined ; renderScriptsAsync ( [ { text : ` ` } ] , res ) logger . error ( "Error in writeBody" , err ) ; retval . resolve ( ) ; } ) ; Q . all ( dfds . map ( dfd => dfd . promise ) ) . then ( writeBodyDfd . resolve ) ; const timeout = setTimeout ( ( ) => { writeBodyDfd . reject ( { message : "Timed out rendering." , timeWaited : timeRemaining , elements : rendered . map ( val => { if ( val === ELEMENT_ALREADY_WRITTEN ) { return 'W' ; } else if ( val === ELEMENT_PENDING ) { return 'P' ; } else { return 'R' ; } } ) , } ) ; } , timeRemaining ) ; writeBodyDfd . promise . then ( ( ) => { clearTimeout ( timeout ) ; retval . resolve ( ) ; } ) ; return retval . promise ; }
474	function genTraversalHandler ( fn ) { var setter = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : function ( target , key , value ) { target [ key ] = value ; } ; function recursiveFn ( source , target , key ) { if ( isArray ( source ) || isObject ( source ) ) { target = isPrimitive ( target ) ? isObject ( source ) ? { } : [ ] : target ; for ( var _key in source ) { setter ( target , _key , recursiveFn ( source [ _key ] , target [ _key ] , _key ) ) ; } return target ; } return fn ( source , target , key ) ; } return recursiveFn ; }
1108	function ( el ) { var bounding = el . getBoundingClientRect ( ) ; return ( bounding . top >= 0 && bounding . left >= 0 && bounding . bottom <= ( window . innerHeight || document . documentElement . clientHeight ) && bounding . right <= ( window . innerWidth || document . documentElement . clientWidth ) ) ; }
846	function readPackageJson ( dir ) { const filePath = path . join ( dir , "package.json" ) try { const text = fs . readFileSync ( filePath , "utf8" ) const data = JSON . parse ( text ) if ( typeof data === "object" && data !== null ) { data . filePath = filePath return data } } catch ( _err ) { } return null }
1462	function compileScss ( ) { return new Promise ( ( resolve , reject ) => { sass . render ( { file : "sass/qooxdoo.scss" , outFile : "build/qooxdoo.css" } , function ( err , result ) { if ( err ) reject ( err ) ; else resolve ( result ) ; } ) ; } ) . then ( result => fs . writeFileAsync ( "build/qooxdoo.css" , result . css , "utf8" ) ) ; }
844	function isNotSupportingVersion ( aCase ) { return ( ! aCase . supported || options . version . intersects ( getSemverRange ( ` ${ aCase . supported } ` ) ) ) }
2594	function union ( a ) { var args = libs . object . only ( libs . object . toArray ( arguments ) , 'array' ) ; var union = [ ] ; args . unshift ( a ) ; libs . object . each ( args , function ( array ) { libs . object . each ( array , function ( item ) { if ( union . indexOf ( item ) === - 1 ) union . push ( item ) ; } ) ; } ) ; return union ; }
440	function getDomainWithZero ( props , axis ) { const propsDomain = getDomainFromProps ( props , axis ) ; if ( propsDomain ) { return propsDomain ; } const dataset = Data . getData ( props ) ; const y0Min = dataset . reduce ( ( min , datum ) => ( datum . _y0 < min ? datum . _y0 : min ) , Infinity ) ; const ensureZero = ( domain ) => { if ( axis === "x" ) { return domain ; } const defaultMin = y0Min !== Infinity ? y0Min : 0 ; const maxDomainProp = getMaxFromProps ( props , axis ) ; const minDomainProp = getMinFromProps ( props , axis ) ; const max = maxDomainProp !== undefined ? maxDomainProp : Collection . getMaxValue ( domain , defaultMin ) ; const min = minDomainProp !== undefined ? minDomainProp : Collection . getMinValue ( domain , defaultMin ) ; return getDomainFromMinMax ( min , max ) ; } ; const getDomainFunction = ( ) => { return getDomainFromData ( props , axis , dataset ) ; } ; const formatDomainFunction = ( domain ) => { return formatDomain ( ensureZero ( domain ) , props , axis ) ; } ; return createDomainFunction ( getDomainFunction , formatDomainFunction ) ( props , axis ) ; }
3353	function ( ) { var me = this , picker = new Ext . tree . Panel ( { shrinkWrapDock : 2 , store : me . store , floating : true , displayField : me . displayField , columns : me . columns , minHeight : me . minPickerHeight , maxHeight : me . maxPickerHeight , manageHeight : false , shadow : false , listeners : { scope : me , itemclick : me . onItemClick } , viewConfig : { listeners : { scope : me , render : me . onViewRender } } } ) , view = picker . getView ( ) ; if ( Ext . isIE9 && Ext . isStrict ) { view . on ( { scope : me , highlightitem : me . repaintPickerView , unhighlightitem : me . repaintPickerView , afteritemexpand : me . repaintPickerView , afteritemcollapse : me . repaintPickerView } ) ; } return picker ; }
3039	function HttpLog ( ) { var args = arguer . apply ( _constructorFormat , arguments ) ; if ( args instanceof Error ) return httpLog ( args ) ; if ( args . response instanceof Http . IncomingMessage && args . response . statusCode ) return httpLog ( args . response . statusCode , Http . STATUS_CODES [ args . response . statusCode ] ) ; if ( args . error instanceof HttpLog ) return args . error ; var log ; if ( args . error ) { log = args . error ; } else if ( args . message !== undefined || ( args . status !== undefined && args . data !== null ) || args . data ) { log = new Error ( args . message ) ; } else { return HttpLog . none ; } log . __proto__ = HttpLog . prototype ; if ( args . status !== undefined ) log . status = args . status ; log . data = args . data || { } ; return log ; }
2212	function extractSection ( content ) { var depth = 0 ; var start = 0 ; var position = 0 ; var length = 0 ; var remain = content ; var section = { } ; do { var result = remain . match ( regex ) ; if ( ! result ) break ; length = result [ 0 ] . length ; position += result . index ; if ( depth === 0 ) { start = position + length ; section = mout . object . merge ( section , parseSignature ( result [ 4 ] ) , { before : content . slice ( 0 , position ) , linebreak : result [ 1 ] , indent : result [ 2 ] } ) ; } remain = remain . slice ( result . index + length ) ; depth += ( result [ 3 ] === "-start" ) ; depth -= ( result [ 3 ] === "-end" ) ; if ( depth === 0 ) { return mout . object . merge ( section , { inner : content . slice ( start , position ) , after : content . slice ( position + length ) } ) ; } position += length ; } while ( true ) ; return null ; }
2567	function getKeys ( o ) { switch ( typeof o ) { case 'object' : return o ? Object . keys ( o ) : [ ] ; case 'string' : var keys = [ ] ; for ( var i = 0 ; i < o . length ; i ++ ) keys . push ( i . toString ( ) ) ; return keys ; default : return [ ] ; } }
3621	function array ( arr ) { var buffers = [ ] , buf , i , len = 0 ; for ( i = 0 ; i < arr . length ; i ++ ) { buf = this . getStringBuffer ( arr [ i ] ) ; len += buf . length ; buffers . push ( buf ) ; } return Buffer . concat ( buffers , len ) ; }
3377	function ( filters ) { if ( filters ) { var me = this , i , filtersLength ; for ( i = 0 , filtersLength = filters . length ; i < filtersLength ; i ++ ) { me . addFilter ( filters [ i ] ) ; } } }
1261	function enlargeUUID ( shortId , translator ) { var uu1 = translator ( shortId ) ; var leftPad = "" ; var m ; for ( var i = 0 , len = 32 - uu1 . length ; i < len ; ++ i ) { leftPad += "0" ; } m = ( leftPad + uu1 ) . match ( / (\w{8})(\w{4})(\w{4})(\w{4})(\w{12}) / ) ; return [ m [ 1 ] , m [ 2 ] , m [ 3 ] , m [ 4 ] , m [ 5 ] ] . join ( '-' ) ; }
3220	function ( record ) { record = Ext . isNumber ( record ) ? this . store . getAt ( record ) : record ; return this . selected . contains ( record ) ; }
163	function handlePreview ( calypsoPort ) { $ ( '#editor' ) . on ( 'click' , '.editor-post-preview' , e => { e . preventDefault ( ) ; e . stopPropagation ( ) ; const postUrl = select ( 'core/editor' ) . getCurrentPostAttribute ( 'link' ) ; const previewChannel = new MessageChannel ( ) ; calypsoPort . postMessage ( { action : 'previewPost' , payload : { postUrl : postUrl , } , } , [ previewChannel . port2 ] ) ; const isAutosaveable = select ( 'core/editor' ) . isEditedPostAutosaveable ( ) ; if ( ! isAutosaveable ) { sendPreviewData ( ) ; return ; } const postStatus = select ( 'core/editor' ) . getEditedPostAttribute ( 'status' ) ; const isDraft = [ 'draft' , 'auto-draft' ] . indexOf ( postStatus ) !== - 1 ; if ( isDraft ) { dispatch ( 'core/editor' ) . savePost ( { isPreview : true } ) ; } else { dispatch ( 'core/editor' ) . autosave ( { isPreview : true } ) ; } const unsubscribe = subscribe ( ( ) => { const isSavingPost = select ( 'core/editor' ) . isSavingPost ( ) ; if ( ! isSavingPost ) { unsubscribe ( ) ; sendPreviewData ( ) ; } } ) ; function sendPreviewData ( ) { const previewUrl = select ( 'core/editor' ) . getEditedPostPreviewLink ( ) ; const featuredImageId = select ( 'core/editor' ) . getEditedPostAttribute ( 'featured_media' ) ; const featuredImage = featuredImageId ? get ( select ( 'core' ) . getMedia ( featuredImageId ) , 'source_url' ) : null ; const authorId = select ( 'core/editor' ) . getCurrentPostAttribute ( 'author' ) ; const author = find ( select ( 'core' ) . getAuthors ( ) , { id : authorId } ) ; const editedPost = { title : select ( 'core/editor' ) . getEditedPostAttribute ( 'title' ) , URL : select ( 'core/editor' ) . getEditedPostAttribute ( 'link' ) , excerpt : select ( 'core/editor' ) . getEditedPostAttribute ( 'excerpt' ) , content : select ( 'core/editor' ) . getEditedPostAttribute ( 'content' ) , featured_image : featuredImage , author : author , } ; previewChannel . port1 . postMessage ( { previewUrl : previewUrl , editedPost : editedPost , } ) ; previewChannel . port1 . close ( ) ; } } ) ; }
3185	function readOpt ( option ) { const prefix = ` ${ option } ` ; for ( let i = 0 , len = process . argv . length , arg ; i < len ; i ++ ) { arg = process . argv [ i ] ; if ( arg === option ) { return process . argv [ i + 1 ] ; } else if ( arg . indexOf ( prefix ) === 0 ) { return arg . substr ( prefix . length ) ; } } }
1548	function move ( point , position , octree , octant , parent , depth ) { const children = octant . children ; let result = null ; let i , l ; let points ; if ( octant . contains ( point , octree . bias ) ) { if ( octant . contains ( position , octree . bias ) ) { if ( children !== null ) { ++ depth ; for ( i = 0 , l = children . length ; result === null && i < l ; ++ i ) { result = move ( point , position , octree , children [ i ] , octant , depth ) ; } } else if ( octant . points !== null ) { points = octant . points ; for ( i = 0 , l = points . length ; i < l ; ++ i ) { if ( point . equals ( points [ i ] ) ) { points [ i ] . copy ( position ) ; result = octant . data [ i ] ; break ; } } } } else { result = remove ( point , octree , octant , parent ) ; put ( position , result , octree , parent , depth - 1 ) ; } } return result ; }
3724	function isBemDecl ( node ) { if ( node . type !== 'CallExpression' ) { return false ; } if ( node . callee . type !== 'MemberExpression' ) { return false ; } if ( node . callee . property . type !== 'Identifier' || node . callee . property . name !== 'decl' ) { return false ; } var obj = node . callee . object ; if ( obj . type === "Identifier" ) { return obj . name === "BEM" ; } if ( obj . type === "MemberExpression" ) { if ( obj . object . type !== "Identifier" ) { return false ; } if ( obj . object . name !== "BEM" ) { return false ; } if ( obj . property . type !== "Identifier" ) { return false ; } return obj . property . name === "DOM" ; } return false ; }
644	function rateMetaDescLength ( metaDescLength ) { var rating ; switch ( true ) { case metaDescLength > 0 && metaDescLength < 120 : case metaDescLength > maximumMetaDescriptionLength : rating = "ok" ; break ; case metaDescLength >= 120 && metaDescLength <= maximumMetaDescriptionLength : rating = "good" ; break ; default : rating = "bad" ; break ; } return rating ; }
309	function getTransforms ( _ref ) { var rotate = _ref . rotate , scaleX = _ref . scaleX , scaleY = _ref . scaleY , translateX = _ref . translateX , translateY = _ref . translateY ; var values = [ ] ; if ( isNumber ( translateX ) && translateX !== 0 ) { values . push ( "translateX(" . concat ( translateX , "px)" ) ) ; } if ( isNumber ( translateY ) && translateY !== 0 ) { values . push ( "translateY(" . concat ( translateY , "px)" ) ) ; } if ( isNumber ( rotate ) && rotate !== 0 ) { values . push ( "rotate(" . concat ( rotate , "deg)" ) ) ; } if ( isNumber ( scaleX ) && scaleX !== 1 ) { values . push ( "scaleX(" . concat ( scaleX , ")" ) ) ; } if ( isNumber ( scaleY ) && scaleY !== 1 ) { values . push ( "scaleY(" . concat ( scaleY , ")" ) ) ; } var transform = values . length ? values . join ( ' ' ) : 'none' ; return { WebkitTransform : transform , msTransform : transform , transform : transform } ; }
3183	function readSync ( ) { const TLS_CERT = process . env . TLS_CERT ; const TLS_KEY = process . env . TLS_KEY ; const TLS_CA = process . env . TLS_CA ; const tls_cert = readOpt ( "--tls-cert" ) ; const tls_key = readOpt ( "--tls-key" ) ; const tls_ca = readOpt ( "--tls-ca" ) ; const result = { secureOptions : constants . SSL_OP_NO_TLSv1 } ; if ( tls_cert ) { if ( tls_key ) { result . cert = fs . readFileSync ( tls_cert ) ; result . key = fs . readFileSync ( tls_key ) ; if ( tls_ca ) { result . ca = fs . readFileSync ( tls_ca ) ; } } else { result . pfx = fs . readFileSync ( tls_cert ) ; } } else if ( TLS_CERT ) { if ( TLS_KEY ) { result . cert = fs . readFileSync ( TLS_CERT ) ; result . key = fs . readFileSync ( TLS_KEY ) ; if ( TLS_CA ) { result . ca = fs . readFileSync ( TLS_CA ) ; } } else { result . pfx = fs . readFileSync ( TLS_CERT ) ; } } return result ; }
2678	function textCommand ( shell , args , data , evaluationId ) { return dataCommand ( shell , args , data , evaluationId , function ( value ) { return value ; } ) ; }
1927	function getImageSizeForSource ( editor , src , callback ) { var fileContent ; var au = require ( 'actionUtils' ) ; if ( src ) { if ( / ^data: / . test ( src ) ) { fileContent = require ( 'base64' ) . decode ( src . replace ( / ^data\:.+?;.+?, / , '' ) ) ; return callback ( au . getImageSize ( fileContent ) ) ; } var file = require ( 'file' ) ; var absPath = file . locateFile ( editor . getFilePath ( ) , src ) ; if ( absPath === null ) { throw "Can't find " + src + ' file' ; } file . read ( absPath , function ( err , content ) { if ( err ) { throw 'Unable to read ' + absPath + ': ' + err ; } content = String ( content ) ; callback ( au . getImageSize ( content ) ) ; } ) ; } }
1630	function removeClass ( element , className ) { var classNames = className ; function _removeClass ( el , cn ) { var classRegex ; if ( el . classList ) { el . classList . remove ( cn ) ; } else { classRegex = new RegExp ( '(?:^|\\s)' + \\ + cn , '(?!\\S)' ) ; \\ } } 'g' el . className = el . className . replace ( classRegex , '' ) . trim ( ) ; if ( ! isArray ( className ) ) { classNames = className . trim ( ) . split ( / \s+ / ) ; } }
1362	function remove ( appDataPath = CERT_PATH ) { if ( fs . existsSync ( appDataPath ) ) { fs . readdirSync ( appDataPath ) . forEach ( file => fs . unlinkSync ( path . join ( appDataPath , file ) ) ) fs . rmdirSync ( appDataPath ) } }
1229	function ( ) { var el = this . opts . element , sync ; el . on ( "change.select2" , this . bind ( function ( e ) { if ( this . opts . element . data ( "select2-change-triggered" ) !== true ) { this . initSelection ( ) ; } } ) ) ; sync = this . bind ( function ( ) { var enabled , readonly , self = this ; var disabled = el . prop ( "disabled" ) ; if ( disabled === undefined ) disabled = false ; this . enable ( ! disabled ) ; var readonly = el . prop ( "readonly" ) ; if ( readonly === undefined ) readonly = false ; this . readonly ( readonly ) ; syncCssClasses ( this . container , this . opts . element , this . opts . adaptContainerCssClass ) ; this . container . addClass ( evaluate ( this . opts . containerCssClass ) ) ; syncCssClasses ( this . dropdown , this . opts . element , this . opts . adaptDropdownCssClass ) ; this . dropdown . addClass ( evaluate ( this . opts . dropdownCssClass ) ) ; } ) ; el . on ( "propertychange.select2 DOMAttrModified.select2" , sync ) ; if ( this . mutationCallback === undefined ) { this . mutationCallback = function ( mutations ) { mutations . forEach ( sync ) ; } } if ( typeof WebKitMutationObserver !== "undefined" ) { if ( this . propertyObserver ) { delete this . propertyObserver ; this . propertyObserver = null ; } this . propertyObserver = new WebKitMutationObserver ( this . mutationCallback ) ; this . propertyObserver . observe ( el . get ( 0 ) , { attributes : true , subtree : false } ) ; } }
870	function validateRegExpLiteral ( node ) { validateRegExp ( node . regex . pattern , node . regex . flags , node ) }
2755	function BlockTypeSerializer ( props ) { const style = props . node . style || 'normal' if ( / ^h\d / . test ( style ) ) { return h ( style , null , props . children ) } return style === 'blockquote' ? h ( 'blockquote' , null , props . children ) : h ( 'p' , null , props . children ) }
1020	function ( path ) { return this . _getParentId ( path ) . then ( ( parentId ) => { return this . _request ( 'POST' , BASE_URL + '/drive/v2/files' , { body : JSON . stringify ( { title : metaTitleFromFileName ( baseName ( path ) ) , mimeType : GD_DIR_MIME_TYPE , parents : [ { id : parentId } ] } ) , headers : { 'Content-Type' : 'application/json; charset=UTF-8' } } ) . then ( ( response ) => { const meta = JSON . parse ( response . responseText ) ; return Promise . resolve ( meta . id ) ; } ) ; } ) ; }
2850	function basePick ( object , props ) { object = Object ( object ) ; return basePickBy ( object , props , function ( value , key ) { return key in object ; } ) ; }
1114	function showHelpAndDie ( message ) { if ( message ) { console . error ( message ) ; } console . error ( commander . helpInformation ( ) ) ; process . exit ( 1 ) ; }
3535	function listen ( name , callBack ) { function f ( ) { try { callBack . apply ( this , arguments ) ; } catch ( e ) { console . error ( e ) ; } } callbacks [ callBack ] = f ; messageBus . bind ( name , f ) ; }
1475	function ( yargs , classNames , packageName ) { let pkg = null ; packageName . split ( "." ) . forEach ( seg => { if ( pkg === null ) { pkg = window [ seg ] ; } else { pkg = pkg [ seg ] ; } } ) ; classNames . forEach ( cmd => { require ( "../../../" + packageName . replace ( / \. / g , "/" ) + "/" + cmd ) ; let data = pkg [ cmd ] . getYargsCommand ( ) ; yargs . command ( data ) ; } ) ; }
3717	function scrollSidebar ( event ) { if ( event . handled !== true ) { var scrollTop = $window . scrollTop ( ) , maxScrollTop = $document . height ( ) - $window . height ( ) ; if ( scrollTop >= 0 && prevScrollTop >= 0 && scrollTop <= maxScrollTop && prevScrollTop <= maxScrollTop ) { $sidebar . scrollTop ( $sidebar . scrollTop ( ) + ( scrollTop - prevScrollTop ) ) ; } prevScrollTop = scrollTop ; event . handled = true ; } else { return false ; } }
2360	function ( datasetId , criteria , options , callback ) { return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doListUpdates ) ( datasetId , criteria , options , callback ) ; }
931	function removeFileExtnameAssociatedProcessor ( extnames , processorName , existedMap ) { if ( ! extnames ) { return ; } if ( ! Array . isArray ( extnames ) ) { extnames = [ extnames ] ; } extnames . forEach ( k => { let currItems = existedMap [ k ] ; if ( Array . isArray ( currItems ) ) { let idx = currItems . indexOf ( processorName ) ; if ( idx !== - 1 ) { currItems . splice ( idx , 1 ) ; currItems . length === 0 && ( existedMap [ k ] = undefined ) ; } } else if ( currItems === processorName ) { existedMap [ k ] = undefined ; } } ) ; }
394	function filterUnusedRules ( pages , css , ignore , usedSelectors ) { let ignoreNextRule = false , ignoreNextRulesStart = false , unusedRules = [ ] , unusedRuleSelectors , usedRuleSelectors ; ignoreNextRule = false ; css . walk ( ( rule ) => { if ( rule . type === 'comment' ) { if ( / ^!?\s?uncss:ignore start\s?$ / . test ( rule . text ) ) { ignoreNextRulesStart = true ; } else if ( / ^!?\s?uncss:ignore end\s?$ / . test ( rule . text ) ) { ignoreNextRulesStart = false ; } else if ( / ^!?\s?uncss:ignore\s?$ / . test ( rule . text ) ) { ignoreNextRule = true ; } } else if ( rule . type === 'rule' ) { if ( rule . parent . type === 'atrule' && _ . endsWith ( rule . parent . name , 'keyframes' ) ) { return ; } if ( ignoreNextRulesStart ) { ignore = ignore . concat ( rule . selectors ) ; } else if ( ignoreNextRule ) { ignoreNextRule = false ; ignore = ignore . concat ( rule . selectors ) ; } usedRuleSelectors = filterUnusedSelectors ( rule . selectors , ignore , usedSelectors ) ; unusedRuleSelectors = rule . selectors . filter ( ( selector ) => usedRuleSelectors . indexOf ( selector ) < 0 ) ; if ( unusedRuleSelectors && unusedRuleSelectors . length ) { unusedRules . push ( { type : 'rule' , selectors : unusedRuleSelectors , position : rule . source } ) ; } if ( usedRuleSelectors . length === 0 ) { rule . remove ( ) ; } else { rule . selectors = usedRuleSelectors ; } } } ) ; filterEmptyAtRules ( css ) ; filterKeyframes ( css , unusedRules ) ; return css ; }
2110	function requireModel ( filePath , cb ) { fs . exists ( filePath , function ( exists ) { if ( ! exists ) { return cb ( new Error ( "Requested Model Not Found!" ) ) ; } libProduct . model = require ( filePath ) ; return cb ( null , libProduct ) ; } ) ; }
520	function _normalizeSequence ( sequence ) { var i ; for ( i = 0 ; i < sequence . length ; ++ i ) { sequence [ i ] . sort ( function ( x , y ) { if ( x . length > 1 && y . length === 1 ) { return - 1 ; } else if ( x . length === 1 && y . length > 1 ) { return 1 ; } return x > y ? 1 : - 1 ; } ) ; sequence [ i ] = sequence [ i ] . join ( '+' ) ; } }
3160	function ( ) { return this . getSettingNames ( ) . map ( function ( key ) { return this . _settings [ key ] . type . stringify ( this . get ( key ) ) ; } . bind ( this ) ) ; }
665	function ( array , language ) { if ( isUndefined ( language ) || language === "" ) { language = "en" ; } const functionWords = get ( getFunctionWords , [ language ] , [ ] ) ; if ( array . length > 1 ) { const arrayFiltered = filter ( array , function ( word ) { return ( ! includes ( functionWords . all , word . trim ( ) . toLocaleLowerCase ( ) ) ) ; } ) ; if ( arrayFiltered . length > 0 ) { return arrayFiltered ; } } return array ; }
1703	function _getVisibleItem ( first ) { var result = { } ; var diff ; var prevDiff = 10000000 ; var diffDelta = ( first && this . options . alignment ) ? - this . _contextSizeCache [ this . _direction ] : ( ( ! first && ! this . options . alignment ) ? this . _contextSizeCache [ this . _direction ] : 0 ) ; var scrollOffset = this . _scroll . unnormalizedScrollOffset ; var node = this . _nodes . getStartEnumNode ( true ) ; while ( node ) { if ( ! node . _invalidated || ( node . scrollLength === undefined ) ) { break ; } if ( node . _viewSequence ) { diff = Math . abs ( diffDelta - ( scrollOffset + ( ! first ? node . scrollLength : 0 ) ) ) ; if ( diff >= prevDiff ) { break ; } prevDiff = diff ; result . scrollOffset = scrollOffset ; result . _node = node ; scrollOffset += node . scrollLength ; } node = node . _next ; } scrollOffset = this . _scroll . unnormalizedScrollOffset ; node = this . _nodes . getStartEnumNode ( false ) ; while ( node ) { if ( ! node . _invalidated || ( node . scrollLength === undefined ) ) { break ; } if ( node . _viewSequence ) { scrollOffset -= node . scrollLength ; diff = Math . abs ( diffDelta - ( scrollOffset + ( ! first ? node . scrollLength : 0 ) ) ) ; if ( diff >= prevDiff ) { break ; } prevDiff = diff ; result . scrollOffset = scrollOffset ; result . _node = node ; } node = node . _prev ; } if ( ! result . _node ) { return undefined ; } result . scrollLength = result . _node . scrollLength ; if ( this . options . alignment ) { result . visiblePerc = ( Math . min ( result . scrollOffset + result . scrollLength , 0 ) - Math . max ( result . scrollOffset , - this . _contextSizeCache [ this . _direction ] ) ) / result . scrollLength ; } else { result . visiblePerc = ( Math . min ( result . scrollOffset + result . scrollLength , this . _contextSizeCache [ this . _direction ] ) - Math . max ( result . scrollOffset , 0 ) ) / result . scrollLength ; } result . index = result . _node . _viewSequence . getIndex ( ) ; result . viewSequence = result . _node . _viewSequence ; result . renderNode = result . _node . renderNode ; return result ; }
2948	function makeEntity ( req , res , all , top , data , path = '' , promises ) { var Role = app . models . Role ; const { zlSite } = res . locals ; const zsBaseUrlPath = ( zlSite . zsBaseUrlPath ) ? ` ${ zlSite . zsBaseUrlPath } ` : '/' _ . forEach ( _ . filter ( all , [ 'scsParent' , top ] ) , function ( val ) { val = val . toJSON ( ) ; if ( _ . find ( all , [ 'scsParent' , val . scsId ] ) ) { data = makeEntity ( req , res , all , val . scsId , data , path + val . scsSlug + '/' , promises ) ; } let loadThisEntity = ( ) => { data [ val . scsId ] = val ; data [ val . scsId ] [ 'contents' ] = [ ] ; data [ val . scsId ] [ 'path' ] = ` ${ path } ${ val . scsSlug } ` ; data [ val . scsId ] [ 'realPath' ] = ` ${ zsBaseUrlPath } ${ data [ val . scsId ] [ 'path' ] } ` ; } let ctx = app . locals . authCtx ( req , res ) ; return promises . push ( new Promise ( ( resolve , reject ) => { Role . isInRole ( val . scsPermission , ctx , ( err , isInRole ) => { if ( isInRole ) { loadThisEntity ( ) ; } resolve ( ) ; } ) ; } ) ) ; loadThisEntity ( ) ; } ) ; return data ; }
3644	function ( key , endWithSeparator ) { var filepath = this . loadNecessaryFile ( key ) ; if ( ! filepath ) { exitProcess ( 'empty directory for ' + key , this . alarm ) ; return false ; } if ( ! fs . lstatSync ( filepath ) . isDirectory ( ) ) { exitProcess ( 'the path ' + filepath + ' must be a directory' , this . alarm ) ; return false ; } if ( endWithSeparator && ! filepath . endWith ( path . sep ) ) { exitProcess ( 'the path ' + filepath + ' must be end with a separator' , this . alarm ) ; return false ; } return filepath ; }
1160	function ( knots ) { var firstControlPoints = [ ] ; var secondControlPoints = [ ] ; var n = knots . length - 1 ; var i ; if ( n == 1 ) { firstControlPoints [ 0 ] = point ( ( 2 * knots [ 0 ] . x + knots [ 1 ] . x ) / 3 , ( 2 * knots [ 0 ] . y + knots [ 1 ] . y ) / 3 ) ; secondControlPoints [ 0 ] = point ( 2 * firstControlPoints [ 0 ] . x - knots [ 0 ] . x , 2 * firstControlPoints [ 0 ] . y - knots [ 0 ] . y ) ; return [ firstControlPoints , secondControlPoints ] ; } var rhs = [ ] ; for ( i = 1 ; i < n - 1 ; i ++ ) { rhs [ i ] = 4 * knots [ i ] . x + 2 * knots [ i + 1 ] . x ; } rhs [ 0 ] = knots [ 0 ] . x + 2 * knots [ 1 ] . x ; rhs [ n - 1 ] = ( 8 * knots [ n - 1 ] . x + knots [ n ] . x ) / 2.0 ; var x = this . getFirstControlPoints ( rhs ) ; for ( i = 1 ; i < n - 1 ; ++ i ) { rhs [ i ] = 4 * knots [ i ] . y + 2 * knots [ i + 1 ] . y ; } rhs [ 0 ] = knots [ 0 ] . y + 2 * knots [ 1 ] . y ; rhs [ n - 1 ] = ( 8 * knots [ n - 1 ] . y + knots [ n ] . y ) / 2.0 ; var y = this . getFirstControlPoints ( rhs ) ; for ( i = 0 ; i < n ; i ++ ) { firstControlPoints . push ( point ( x [ i ] , y [ i ] ) ) ; if ( i < n - 1 ) { secondControlPoints . push ( point ( 2 * knots [ i + 1 ] . x - x [ i + 1 ] , 2 * knots [ i + 1 ] . y - y [ i + 1 ] ) ) ; } else { secondControlPoints . push ( point ( ( knots [ n ] . x + x [ n - 1 ] ) / 2 , ( knots [ n ] . y + y [ n - 1 ] ) / 2 ) ) ; } } return [ firstControlPoints , secondControlPoints ] ; }
2431	function exec ( command , options ) { return new PromiseWithEvents_1 . PromiseWithEvents ( function ( resolve , reject , eventEmitter ) { var childProcess = cp . exec ( command , options , function ( err , stdout , stderr ) { if ( err ) { reject ( err ) ; } else { resolve ( { stdout : stdout . toString ( ) , stderr : stderr . toString ( ) } ) ; } } ) ; process . nextTick ( function ( ) { return eventEmitter . emit ( 'process' , childProcess ) ; } ) ; } ) ; }
3850	function publish ( subject , op , target ) { try { var type = ( _ . isString ( target ) ) ? target : target . type ; var topic = getTopic ( type ) ; var event = new Event ( subject , op , target ) ; provider . publish ( topic , event ) ; } catch ( err ) { logger . error ( 'unable to publish event' , err ) ; } }
3144	function ( parent , el ) { var id = el . id , children = parent . children , items = this . items ; if ( children ) { Ext . Array . remove ( children , items [ id ] ) ; } delete items [ id ] ; }
3352	function sortArgs ( app , argv , options ) { options = options || [ ] ; var first = options . first || [ ] ; var last = options . last || [ ] ; var cliKeys = [ ] ; if ( app . cli && app . cli . keys ) { cliKeys = app . cli . keys ; } var keys = utils . union ( first , cliKeys , Object . keys ( argv ) ) ; keys = utils . diff ( keys , last ) ; keys = utils . union ( keys , last ) ; var len = keys . length ; var idx = - 1 ; var res = { } ; while ( ++ idx < len ) { var key = keys [ idx ] ; if ( argv . hasOwnProperty ( key ) ) { res [ key ] = argv [ key ] ; } } return res ; }
524	function getExternals ( api , pluginOptions ) { const nodeModulesPath = pluginOptions . nodeModulesPath || './node_modules' let nodeModulesPaths = [ ] if ( Array . isArray ( nodeModulesPath ) ) { nodeModulesPaths = nodeModulesPath } else { nodeModulesPaths . push ( nodeModulesPath ) } const userExternals = pluginOptions . externals || [ ] const userExternalsWhitelist = [ ] userExternals . forEach ( ( d , i ) => { if ( d . match ( / ^! / ) ) { userExternals . splice ( i , 1 ) userExternalsWhitelist . push ( d . replace ( / ^! / , '' ) ) } } ) const { dependencies } = require ( api . resolve ( './package.json' ) ) const externalsList = Object . keys ( dependencies || { } ) . reduce ( ( depList , dep ) => { try { let pgkString for ( const path of nodeModulesPaths ) { if ( fs . existsSync ( api . resolve ( ` ${ path } ${ dep } ` ) ) ) { pgkString = fs . readFileSync ( api . resolve ( ` ${ path } ${ dep } ` ) ) . toString ( ) break } } if ( ! pgkString ) { throw new Error ( ` ${ dep } ` ) } const pkg = JSON . parse ( pgkString ) const name = userExternals . find ( name => new RegExp ( ` ${ pkg . name } ` ) . test ( name ) ) const fields = [ 'main' , 'module' , 'jsnext:main' , 'browser' ] if ( userExternalsWhitelist . indexOf ( dep ) === - 1 && ( ! fields . some ( field => field in pkg ) || ! ! pkg . binary || ! ! pkg . gypfile || ! ! name ) ) { depList . push ( name || dep ) } } catch ( e ) { console . log ( e ) depList . push ( dep ) } return depList } , [ ] ) let externals = { } externalsList . forEach ( d => { externals [ d ] = ` ${ d } ` } ) return externals }
3804	function RrectCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 5 ) throw new SyntaxError ( 'RRECT command requires 5 arguments' ) ; this . x1 = parsed . args [ 0 ] ; this . y1 = parsed . args [ 1 ] ; this . x2 = parsed . args [ 2 ] ; this . y2 = parsed . args [ 3 ] ; this . radius = parsed . args [ 4 ] ; this . stroke = parsed . args . length > 5 ? parsed . args [ 5 ] : false ; }
847	function get ( option ) { if ( option && option . allowModules && Array . isArray ( option . allowModules ) ) { return option . allowModules . map ( String ) } return null }
2015	function chromeStorageGet ( keys , callback ) { window . chrome . storage . sync . get ( keys , function ( data ) { if ( window . chrome . runtime . lastError ) { callback ( window . chrome . runtime . lastError ) ; } else { callback ( undefined , data ) ; } } ) ; }
1144	function curry ( func , arity ) { arity = typeof arity == 'number' ? arity : ( + arity || func . length ) ; return createBound ( func , 4 , null , null , null , arity ) ; }
1021	function ( path ) { let id ; if ( path === '/' ) { return Promise . resolve ( 'root' ) ; } else if ( ( id = this . _fileIdCache . get ( path ) ) ) { return Promise . resolve ( id ) ; } return this . _getFolder ( parentPath ( path ) ) . then ( ( ) => { id = this . _fileIdCache . get ( path ) ; if ( ! id ) { if ( path . substr ( - 1 ) === '/' ) { return this . _createFolder ( path ) . then ( ( ) => { return this . _getFileId ( path ) ; } ) ; } else { return Promise . resolve ( ) ; } } return Promise . resolve ( id ) ; } ) ; }
1033	function ( path ) { var url = 'https://api.dropbox.com/2/sharing/list_shared_links' ; var options = { body : { path : getDropboxPath ( path ) , direct_only : true } } ; return this . _request ( 'POST' , url , options ) . then ( ( response ) => { if ( response . status !== 200 && response . status !== 409 ) { return Promise . reject ( new Error ( 'Invalid response status: ' + response . status ) ) ; } var body ; try { body = JSON . parse ( response . responseText ) ; } catch ( e ) { return Promise . reject ( new Error ( 'Invalid response body: ' + response . responseText ) ) ; } if ( response . status === 409 ) { return Promise . reject ( new Error ( 'API error: ' + response . error_summary ) ) ; } if ( ! body . links . length ) { return Promise . reject ( new Error ( 'No links returned' ) ) ; } return Promise . resolve ( body . links [ 0 ] . url ) ; } , ( error ) => { error . message = 'Could not get link to a shared file or folder ("' + path + '"): ' + error . message ; return Promise . reject ( error ) ; } ) ; }
3317	function ( text ) { if ( text == null ) { throw new Error ( 'Illegal text for Argument: ' + text ) ; } var ev = { argument : this , oldText : this . text , text : text } ; this . text = text ; this . emitter . _dispatchEvent ( 'argumentChange' , ev ) ; }
2902	function ( connectionName , table , options , cb ) { if ( LOG_DEBUG ) { console . log ( "BEGIN destroy" ) ; } var connectionObject = connections [ connectionName ] ; var collection = connectionObject . collections [ table ] ; var _schema = connectionObject . schema ; var overrides = connectionOverrides [ connectionName ] || { } ; var _options = _ . cloneDeep ( sqlOptions ) ; if ( hop ( overrides , 'wlNext' ) ) { _options . wlNext = overrides . wlNext ; } var sequel = new Sequel ( _schema , _options ) ; var query ; try { query = sequel . destroy ( table , options ) ; } catch ( e ) { return cb ( e ) ; } query . query = query . query . replace ( 'RETURNING *' , '' ) ; query . query = query . query . replace ( / \$ / g , ':' ) ; query . query = query . query . replace ( " AS " , " " ) ; connectionObject . pool . getConnection ( function ( err , connection ) { if ( err ) { handleQueryError ( err , 'destroy' ) ; return ; } if ( LOG_QUERIES ) { console . log ( 'Executing query: ' + query . query ) ; console . log ( 'Data for query: ' + JSON . stringify ( query . values ) ) ; } connection . execute ( query . query , query . values , { autoCommit : true , outFormat : oracledb . OBJECT } , function __DELETE__ ( err , result ) { if ( err ) { doRelease ( connection ) ; return cb ( handleQueryError ( err , 'destroy' ) ) ; } doRelease ( connection ) ; cb ( null , result . rows ) ; } ) ; } ) ; }
756	function getControlPoints ( p0 , p1 , p2 , opt_alpha , opt_allowFalseExtrema ) { var alpha = ( opt_alpha !== undefined ) ? opt_alpha : 1 / 3 ; var allowFalseExtrema = opt_allowFalseExtrema || false ; if ( ! p2 ) { return [ p1 . x , p1 . y , null , null ] ; } var l1x = ( 1 - alpha ) * p1 . x + alpha * p0 . x , l1y = ( 1 - alpha ) * p1 . y + alpha * p0 . y , r1x = ( 1 - alpha ) * p1 . x + alpha * p2 . x , r1y = ( 1 - alpha ) * p1 . y + alpha * p2 . y ; if ( l1x != r1x ) { var deltaY = p1 . y - r1y - ( p1 . x - r1x ) * ( l1y - r1y ) / ( l1x - r1x ) ; l1y += deltaY ; r1y += deltaY ; } if ( ! allowFalseExtrema ) { if ( l1y > p0 . y && l1y > p1 . y ) { l1y = Math . max ( p0 . y , p1 . y ) ; r1y = 2 * p1 . y - l1y ; } else if ( l1y < p0 . y && l1y < p1 . y ) { l1y = Math . min ( p0 . y , p1 . y ) ; r1y = 2 * p1 . y - l1y ; } if ( r1y > p1 . y && r1y > p2 . y ) { r1y = Math . max ( p1 . y , p2 . y ) ; l1y = 2 * p1 . y - r1y ; } else if ( r1y < p1 . y && r1y < p2 . y ) { r1y = Math . min ( p1 . y , p2 . y ) ; l1y = 2 * p1 . y - r1y ; } } return [ l1x , l1y , r1x , r1y ] ; }
1619	function parse_command_interface ( callback ) { return function ( error , stdout , stderr ) { if ( error ) { callback ( error ) ; } else { var output = parse_command_block ( stdout . trim ( ) ) ; if ( output . result === 'FAIL' ) { callback ( new Error ( output . result ) ) ; } else { callback ( error , parse_command_block ( stdout . trim ( ) ) ) ; } } } ; }
3487	function ( callback , scope , args , delay ) { if ( Ext . isFunction ( callback ) ) { args = args || [ ] ; scope = scope || window ; if ( delay ) { Ext . defer ( callback , delay , scope , args ) ; } else { callback . apply ( scope , args ) ; } } }
3149	function ( reader ) { var me = this , needsCopy = true , current = me . reader ; if ( reader === undefined || typeof reader == 'string' ) { reader = { type : reader } ; needsCopy = false ; } if ( reader . isReader ) { reader . setModel ( me . model ) ; } else { if ( needsCopy ) { reader = Ext . apply ( { } , reader ) ; } Ext . applyIf ( reader , { proxy : me , model : me . model , type : me . defaultReaderType } ) ; reader = Ext . createByAlias ( 'reader.' + reader . type , reader ) ; } if ( reader !== current && reader . onMetaChange ) { reader . onMetaChange = Ext . Function . createSequence ( reader . onMetaChange , this . onMetaChange , this ) ; } me . reader = reader ; return me . reader ; }
1956	function Sender ( options ) { EventEmitter . call ( this ) ; _ . extend ( this , _ . defaults ( options || { } , { retries : 4 } ) ) ; }
856	function createMatch ( includePatterns , excludePatterns ) { const include = includePatterns . map ( pattern => new Minimatch ( pattern ) ) const exclude = excludePatterns . map ( pattern => new Minimatch ( pattern ) ) return filePath => include . some ( m => m . match ( filePath ) ) && ! exclude . some ( m => m . match ( filePath ) ) }
876	function existsCaseSensitive ( filePath ) { let dirPath = filePath while ( dirPath !== "" && ! ROOT . test ( dirPath ) ) { const fileName = path . basename ( dirPath ) dirPath = path . dirname ( dirPath ) if ( fs . readdirSync ( dirPath ) . indexOf ( fileName ) === - 1 ) { return false } } return true }
3531	function start ( mode , target , system , containerDef , container , out , cb ) { proc . start ( mode , target , system , containerDef , container , out , cb ) ; }
3513	function ( size , units ) { if ( typeof size == 'number' ) { return size + ( units || this . defaultUnit || 'px' ) ; } if ( size === "" || size == "auto" || size === undefined || size === null ) { return size || '' ; } if ( ! this . unitRe . test ( size ) ) { if ( Ext . isDefined ( Ext . global . console ) ) { Ext . global . console . warn ( "Warning, size detected as NaN on Element.addUnits." ) ; } return size || '' ; } return size ; }
3392	function ( request ) { return { request : request , requestId : request . id , status : request . aborted ? - 1 : 0 , statusText : request . aborted ? 'transaction aborted' : 'communication failure' , aborted : request . aborted , timedout : request . timedout } ; }
3688	function _singleCopy ( sourceRef , copyRef , rc ) { return _instanceCopy ( sourceRef , copyRef , rc , ( item , val , key ) => { copyRef [ key ] = _clone ( val , rc ) ; } ) ; }
2677	function addMessage ( message ) { var text = message . content ? message . content . code . trim ( ) : '' ; if ( ! text ) { return ; } message . content . code = text ; _messages . push ( message ) ; if ( _idle ) { processNextMessage ( ) ; } }
3603	function ValidationErrors ( errors ) { this . errors = errors ? errors : { } ; this . addError = function ( field , message ) { if ( ! this . errors [ field ] ) { this . errors [ field ] = [ ] ; } this . errors [ field ] . push ( util . format ( message , field ) ) ; } ; this . getErrors = function ( field ) { if ( field ) { return this . errors [ field ] ; } else { return this . errors ; } } ; this . hasErrors = function ( ) { return _ . keys ( this . errors ) . length > 0 ; } ; this . isValidationErrors = function ( ) { return true ; } ; }
2592	function pad ( n , length ) { return libs . string . pad ( n . toString ( ) , length , '0' , true ) ; }
1698	function _scrollUpdate ( event ) { if ( ! this . options . enabled ) { return ; } var offset = Array . isArray ( event . delta ) ? event . delta [ this . _direction ] : event . delta ; this . scroll ( offset ) ; }
360	function pattern ( rule , value , source , errors , options ) { if ( rule . pattern ) { if ( rule . pattern instanceof RegExp ) { rule . pattern . lastIndex = 0 ; if ( ! rule . pattern . test ( value ) ) { errors . push ( util . format ( options . messages . pattern . mismatch , rule . fullField , value , rule . pattern ) ) ; } } else if ( typeof rule . pattern === 'string' ) { const _pattern = new RegExp ( rule . pattern ) ; if ( ! _pattern . test ( value ) ) { errors . push ( util . format ( options . messages . pattern . mismatch , rule . fullField , value , rule . pattern ) ) ; } } } }
301	function getData ( element , name ) { if ( isObject ( element [ name ] ) ) { return element [ name ] ; } if ( element . dataset ) { return element . dataset [ name ] ; } return element . getAttribute ( "data-" . concat ( toParamCase ( name ) ) ) ; }
2992	function ( active , suppressEvent ) { if ( this . active != active ) { this . active = active ; if ( suppressEvent !== true ) { this . fireEvent ( active ? 'activate' : 'deactivate' , this ) ; } } }
3263	function expandOptions ( val , allowValues ) { val = val || [ ] ; var trail = [ ] ; return val . reduce ( function ( a , c ) { if ( ! constants_1 . FLAG_SHORT . test ( c ) || constants_1 . FLAG_COUNT . test ( c ) ) return a . concat ( c ) ; var split = c . slice ( 1 ) . split ( '' ) . map ( function ( n ) { return "-" + n ; } ) ; if ( allowValues ) return a . concat ( split ) ; trail = trail . concat ( split ) ; return a ; } , [ ] ) . concat ( trail ) ; }
3574	function ( ) { return this . sort ( ) . wrapItems ? new ObjectIterator ( this . _keys , this . _values . map ( function ( item ) { return item . value ; } ) ) : new SjlMap . prototype . entries . call ( this . sort ( ) ) ; }
715	function getMarkdownToTextConverter ( ) { const remark = require ( 'remark' ) const strip = require ( 'strip-markdown' ) const converter = remark ( ) . use ( strip ) return ( md ) => String ( converter . processSync ( md ) ) }
168	function _initStorage ( options ) { const dbInfo = { } ; if ( options ) { for ( const i in options ) { dbInfo [ i ] = options [ i ] ; } } dbInfo . db = { } ; dummyStorage [ dbInfo . name ] = dbInfo . db ; this . _dbInfo = dbInfo ; return Promise . resolve ( ) ; }
1147	function ( ) { var target = arguments [ 0 ] ; for ( var i = 1 , l = arguments . length ; i < l ; i ++ ) { var extension = arguments [ i ] ; if ( ( Object ( extension ) !== extension ) && ! _ . isFunction ( extension ) && ( extension === null || extension === undefined ) ) { continue ; } _ . each ( extension , function ( copy , key ) { if ( this . mixin . deep && ( Object ( copy ) === copy ) ) { if ( ! target [ key ] ) { target [ key ] = _ . isArray ( copy ) ? [ ] : { } ; } this . mixin ( target [ key ] , copy ) ; return ; } if ( target [ key ] !== copy ) { if ( ! this . mixin . supplement || ! target . hasOwnProperty ( key ) ) { target [ key ] = copy ; } } } , this ) ; } return target ; }
2225	function AsyncObservable ( fn , context , initialValue ) { this . resolve = this . resolve . bind ( this ) ; this . lastSetValue = new SimpleObservable ( initialValue ) ; this . handler = this . handler . bind ( this ) ; function observe ( ) { this . resolveCalled = false ; this . inGetter = true ; var newVal = fn . call ( context , this . lastSetValue . get ( ) , this . bound === true ? this . resolve : undefined ) ; this . inGetter = false ; if ( newVal !== undefined ) { this . resolve ( newVal ) ; } else if ( this . resolveCalled ) { this . resolve ( this . _value ) ; } if ( this . bound !== true ) { return newVal ; } } if ( process . env . NODE_ENV !== 'production' ) { canReflect . assignSymbols ( this , { "can.getName" : function ( ) { return ( canReflect . getName ( this . constructor ) + "<" + canReflect . getName ( fn ) + ">" ) ; } } ) ; Object . defineProperty ( this . handler , "name" , { value : canReflect . getName ( this ) + ".handler" } ) ; Object . defineProperty ( observe , "name" , { value : canReflect . getName ( fn ) + "::" + canReflect . getName ( this . constructor ) } ) ; } this . observation = new Observation ( observe , this ) ; }
1905	function ( val ) { if ( ! _ . isUndefined ( val ) && this . _value !== ( val = String ( val ) ) ) { this . parent . _updateSource ( val , this . valueRange ( ) ) ; this . _value = val ; } return this . _value ; }
2480	function ( options , cb ) { return doNpmCommand ( { npmCommand : 'install' , cmdArgs : options . dependencies , cmdOptions : { production : options . production || false , loglevel : options . loglevel || undefined , save : options . save || false , 'save-dev' : options . saveDev || false , 'save-exact' : options . saveExact || false , prefix : options . prefix || undefined , } , dir : options . dir } , cb ) ; }
3214	function diffText ( a , b ) { var changes = [ ] var text = a while ( text !== b ) { var c = partiallyDiffText ( text , b ) if ( c . type === 'add' ) { text = text . substr ( 0 , c . index ) + c . value + text . substr ( c . index ) } else { text = text . substr ( 0 , c . index ) + text . substr ( c . index + c . many ) } changes . push ( c ) } return changes }
3382	function ( form , url , params , options ) { form = Ext . getDom ( form ) ; options = options || { } ; var id = Ext . id ( ) , frame = document . createElement ( 'iframe' ) , hiddens = [ ] , encoding = 'multipart/form-data' , buf = { target : form . target , method : form . method , encoding : form . encoding , enctype : form . enctype , action : form . action } , addField = function ( name , value ) { hiddenItem = document . createElement ( 'input' ) ; Ext . fly ( hiddenItem ) . set ( { type : 'hidden' , value : value , name : name } ) ; form . appendChild ( hiddenItem ) ; hiddens . push ( hiddenItem ) ; } , hiddenItem , obj , value , name , vLen , v , hLen , h ; Ext . fly ( frame ) . set ( { id : id , name : id , cls : Ext . baseCSSPrefix + 'hide-display' , src : Ext . SSL_SECURE_URL } ) ; document . body . appendChild ( frame ) ; if ( document . frames ) { document . frames [ id ] . name = id ; } Ext . fly ( form ) . set ( { target : id , method : 'POST' , enctype : encoding , encoding : encoding , action : url || buf . action } ) ; if ( params ) { obj = Ext . Object . fromQueryString ( params ) || { } ; for ( name in obj ) { if ( obj . hasOwnProperty ( name ) ) { value = obj [ name ] ; if ( Ext . isArray ( value ) ) { vLen = value . length ; for ( v = 0 ; v < vLen ; v ++ ) { addField ( name , value [ v ] ) ; } } else { addField ( name , value ) ; } } } } Ext . fly ( frame ) . on ( 'load' , Ext . Function . bind ( this . onUploadComplete , this , [ frame , options ] ) , null , { single : ! Ext . isOpera } ) ; form . submit ( ) ; Ext . fly ( form ) . set ( buf ) ; hLen = hiddens . length ; for ( h = 0 ; h < hLen ; h ++ ) { Ext . removeNode ( hiddens [ h ] ) ; } }
915	function replaceElementAttributeVariable ( attrs , data ) { let newAttrs = Object . assign ( { } , attrs ) ; attrs && Object . keys ( attrs ) . forEach ( k => { let value = attrs [ k ] ; if ( k . startsWith ( ':' ) ) { let newDataName = data [ value ] ; newDataName && ( newAttrs [ k ] = newDataName ) ; } else { value = replaceTemplateVariable ( value , data ) ; newAttrs [ k ] = value ; } } ) ; return newAttrs ; }
3569	function ( key ) { if ( this . has ( key ) ) { var _index = this . _keys . indexOf ( key ) ; this . _values . splice ( _index , 1 ) ; this . _keys . splice ( _index , 1 ) ; } return this ; }
2148	function replaceWith ( $rootElement , elementsToRemove , newNode ) { var firstElementToRemove = elementsToRemove [ 0 ] , removeCount = elementsToRemove . length , parent = firstElementToRemove . parentNode , i , ii ; if ( $rootElement ) { for ( i = 0 , ii = $rootElement . length ; i < ii ; i ++ ) { if ( $rootElement [ i ] === firstElementToRemove ) { $rootElement [ i ++ ] = newNode ; for ( var j = i , j2 = j + removeCount - 1 , jj = $rootElement . length ; j < jj ; j ++ , j2 ++ ) { if ( j2 < jj ) { $rootElement [ j ] = $rootElement [ j2 ] ; } else { delete $rootElement [ j ] ; } } $rootElement . length -= removeCount - 1 ; if ( $rootElement . context === firstElementToRemove ) { $rootElement . context = newNode ; } break ; } } } if ( parent ) { parent . replaceChild ( newNode , firstElementToRemove ) ; } var fragment = window . document . createDocumentFragment ( ) ; for ( i = 0 ; i < removeCount ; i ++ ) { fragment . appendChild ( elementsToRemove [ i ] ) ; } if ( jqLite . hasData ( firstElementToRemove ) ) { jqLite . data ( newNode , jqLite . data ( firstElementToRemove ) ) ; jqLite ( firstElementToRemove ) . off ( '$destroy' ) ; } jqLite . cleanData ( fragment . querySelectorAll ( '*' ) ) ; for ( i = 1 ; i < removeCount ; i ++ ) { delete elementsToRemove [ i ] ; } elementsToRemove [ 0 ] = newNode ; elementsToRemove . length = 1 ; }
1128	function BigIq54LicenseProvider ( bigIp , options ) { const injectedLogger = options ? options . logger : undefined ; let loggerOptions = options ? options . loggerOptions : undefined ; this . constructorOptions = { } ; if ( options ) { Object . keys ( options ) . forEach ( ( option ) => { this . constructorOptions [ option ] = options [ option ] ; } ) ; } if ( injectedLogger ) { this . logger = injectedLogger ; util . setLogger ( injectedLogger ) ; } else { loggerOptions = loggerOptions || { logLevel : 'none' } ; loggerOptions . module = module ; this . logger = Logger . getLogger ( loggerOptions ) ; util . setLoggerOptions ( loggerOptions ) ; } this . bigIp = bigIp ; }
1719	function _initHideAnimation ( item , prevItem , size ) { var startHideAnimation = _startHideAnimation . bind ( this , item , prevItem , size ) ; if ( item . wait ) { item . wait . then ( startHideAnimation , startHideAnimation ) ; } else { startHideAnimation ( ) ; } }
1232	function PubEmitterSocket ( ) { this . sock = new PubSocket ; this . emit = this . sock . send . bind ( this . sock ) ; this . bind = this . sock . bind . bind ( this . sock ) ; this . connect = this . sock . connect . bind ( this . sock ) ; this . close = this . sock . close . bind ( this . sock ) ; }
831	function generateComponent ( typedocHtmlFile , relativeTypedocHtmlFile , demoAppDocsModuleDir ) { const directory = path . dirname ( relativeTypedocHtmlFile ) ; mkdirp . sync ( path . join ( demoAppDocsModuleDir , directory ) ) ; const fileName = path . basename ( relativeTypedocHtmlFile ) ; const componentHtmlFileName = fileName . replace ( / \.html$ / , '.component.html' ) ; const componentHtmlFile = path . join ( demoAppDocsModuleDir , directory , componentHtmlFileName ) ; const typedocHtmlFileContent = fs . readFileSync ( typedocHtmlFile , { encoding : 'utf8' } ) ; const escapedHtmlFileContent = fixRouterFragments ( fixReadmeMdLinks ( escapeHtmlForAngular ( typedocHtmlFileContent ) ) ) ; fs . writeFileSync ( componentHtmlFile , escapedHtmlFileContent , { encoding : 'utf8' } ) ; const componentFileName = fileName . replace ( / \.html$ / , '.component' ) ; const componentTsFileName = componentFileName + '.ts' ; const componentTsFile = path . join ( demoAppDocsModuleDir , directory , componentTsFileName ) ; const componentName = generateComponentName ( fileName ) ; const componentTsFileContent = ` ${ componentHtmlFileName } ${ componentName } ` ; fs . writeFileSync ( componentTsFile , componentTsFileContent , { encoding : 'utf8' } ) ; return { name : componentName , file : path . join ( directory , componentFileName ) , route : relativeTypedocHtmlFile } ; }
682	function searchForItems ( session ) { const searchPrompts = [ { type : "text" , name : "searchText" , message : "Search Query" } , { type : "list" , name : "itemTypes" , message : "Item Types" } , { type : "list" , name : "itemTags" , message : "Tags" } , { type : "number" , name : "number" , message : "How Many?" } ] ; return prompts ( searchPrompts ) . then ( ( { searchText , itemTypes , itemTags , number } ) => { const query = new SearchQueryBuilder ( ) . match ( session . username ) . in ( "owner" ) ; const types = itemTypes . filter ( type => type . length ) ; if ( types . length ) { query . and ( ) . startGroup ( ) ; types . forEach ( ( type , index , types ) => { query . match ( type ) . in ( "type" ) ; if ( index !== types . length - 1 ) { query . or ( ) ; } } ) ; query . endGroup ( ) ; } const tags = itemTags . filter ( tag => tag . length ) ; if ( tags . length ) { query . and ( ) . startGroup ( ) ; tags . forEach ( ( tag , index , tags ) => { query . match ( tag ) . in ( "tags" ) ; if ( index !== tags . length - 1 ) { query . or ( ) ; } } ) ; query . endGroup ( ) ; } if ( searchText . length ) { query . and ( ) . match ( searchText ) ; } console . log ( chalk . blue ( ` ${ query . toParam ( ) } ` ) ) ; return searchItems ( { authentication : session , q : query , num : number } ) . then ( response => { return { response , session } ; } ) . catch ( err => { console . warn ( err ) ; } ) } ) ; }
1047	function add ( buf ) { var self = this var flags = self . flags var lines = buf . toString ( 'utf8' ) . split ( '\n' ) \n var length = lines . length var index = - 1 var line var forbidden var word var model var flag flag = flags . FORBIDDENWORD || false flags . FORBIDDENWORD = flag while ( ++ index < length ) { line = trim ( lines [ index ] ) if ( ! line ) { continue } line = line . split ( '/' ) word = line [ 0 ] model = line [ 1 ] forbidden = word . charAt ( 0 ) === '*' if ( forbidden ) { word = word . slice ( 1 ) } self . add ( word , model ) if ( forbidden ) { self . data [ word ] . push ( flag ) } } }
3274	async function getVinylFile ( filePath , options ) { if ( ! isString ( filePath ) ) { if ( ! options . lookup . has ( filePath . path ) ) options . lookup . set ( filePath . path , filePath ) ; return filePath ; } if ( options . lookup . has ( filePath ) ) return options . lookup . get ( filePath ) ; return createVinylFile ( filePath , options ) ; }
2979	function sanitize ( str ) { const symbolMap = { '\'' : \' , '\\textquotesingle{}' , \\ , '"' : '\\textquotedbl{}' , \\ , '`' : '\\textasciigrave{}' , \\ , '^' : '\\textasciicircum{}' , \\ , '~' : '\\textasciitilde{}' , \\ , '<' : '\\textless{}' , \\ , '>' : '\\textgreater{}' , \\ , '|' : '\\textbar{}' } \\ }
117	function checkLoading ( event ) { var _this4 = this ; this . loading = [ 'stalled' , 'waiting' ] . includes ( event . type ) ; clearTimeout ( this . timers . loading ) ; this . timers . loading = setTimeout ( function ( ) { toggleClass ( _this4 . elements . container , _this4 . config . classNames . loading , _this4 . loading ) ; ui . toggleControls . call ( _this4 ) ; } , this . loading ? 250 : 0 ) ; }
2368	function get ( key , cb ) { if ( ! syncConfig . useCache || ! redisClient ) { return cb && cb ( ) ; } return redisClient . get ( key , cb ) ; }
2014	function rotateClockwise ( buffer ) { var w = buffer . height ; var h = buffer . width ; var w2 = Math . floor ( w / 2 ) ; var h2 = Math . floor ( h / 2 ) ; return makeBuffer ( w , h , function ( context ) { context . translate ( w2 , h2 ) ; context . rotate ( Math . PI / 2 ) ; context . drawImage ( buffer , - h2 , - w2 ) ; } ) ; }
559	function ( face , absorbingFace ) { var faceVertices = this . removeAllVerticesFromFace ( face ) ; if ( faceVertices !== undefined ) { if ( absorbingFace === undefined ) { this . unassigned . appendChain ( faceVertices ) ; } else { var vertex = faceVertices ; do { var nextVertex = vertex . next ; var distance = absorbingFace . distanceToPoint ( vertex . point ) ; if ( distance > this . tolerance ) { this . addVertexToFace ( vertex , absorbingFace ) ; } else { this . unassigned . append ( vertex ) ; } vertex = nextVertex ; } while ( vertex !== null ) ; } } return this ; }
3525	function ( ) { var me = this , idx ; if ( ( idx = Ext . Array . indexOf ( me . indexes , me . currentIndex ) ) !== - 1 ) { me . currentIndex = me . indexes [ idx - 1 ] || me . indexes [ me . indexes . length - 1 ] ; me . getSelectionModel ( ) . select ( me . currentIndex ) ; } }
3379	function ( p ) { if ( this . encode ) { delete p [ this . paramPrefix ] ; } else { var regex , key ; regex = new RegExp ( '^' + this . paramPrefix + '\[[0-9]+\]' ) ; \[ } }
1845	function getLogin ( req , res ) { var next = req . param ( 'next' ) ; render ( req , res , 'login.jade' , { next : next } ) ; }
2685	function initialize ( shell ) { shell . requiredModules = { } ; shell . installedModules = { } ; shell . state . require = function ( name ) { return customRequire ( shell , name ) ; } ; shell . registerCommand ( 'module' , moduleCommand ) ; shell . registerCommand ( 'modules' , modulesCommand ) ; }
2280	function request ( self , options , callback ) { var _http = get ( self , options , 'secure' ) ? https : http ; if ( Steam . devMode ) console . log ( options ) ; var req = _http . request ( options , function ( res ) { var data , dataStr = '' ; res . on ( 'data' , function ( chunk ) { dataStr += chunk ; } ) ; res . on ( 'end' , function ( ) { var statusCode = res . statusCode ; if ( statusCode !== 200 ) { if ( statusCode === 401 ) { return callback ( new Error ( 'Invalid API Key' ) ) ; } else { return callback ( new Error ( "HTTP " + statusCode + " " + http . STATUS_CODES [ statusCode ] ) ) ; } } try { data = JSON . parse ( dataStr ) ; } catch ( e ) { return callback ( new Error ( 'Unable to parse JSON data' ) ) ; } if ( ( data . response instanceof Object ) && ( Object . keys ( data ) . length === 1 ) ) { data = data . response ; } if ( ( data . result instanceof Object ) && Object . keys ( data ) . length === 1 ) { data = data . result ; } callback ( null , data ) ; } ) } ) ; req . end ( options . data ) ; req . on ( 'error' , function ( err ) { callback ( err ) ; } ) ; }
2143	function refresh ( entry ) { if ( entry !== freshEnd ) { if ( ! staleEnd ) { staleEnd = entry ; } else if ( staleEnd === entry ) { staleEnd = entry . n ; } link ( entry . n , entry . p ) ; link ( entry , freshEnd ) ; freshEnd = entry ; freshEnd . n = null ; } }
1199	function ( node ) { var range = this . getRange ( ) ; if ( ! range ) { return ; } try { range . surroundContents ( node ) ; this . selectNode ( node ) ; } catch ( e ) { node . appendChild ( range . extractContents ( ) ) ; range . insertNode ( node ) ; } }
1914	function ( abbr , text , syntax , profile , contextNode ) { var filters = require ( 'filters' ) ; var utils = require ( 'utils' ) ; syntax = syntax || emmet . defaultSyntax ( ) ; profile = require ( 'profile' ) . get ( profile , syntax ) ; require ( 'tabStops' ) . resetTabstopIndex ( ) ; var data = filters . extractFromAbbreviation ( abbr ) ; var parsedTree = require ( 'abbreviationParser' ) . parse ( data [ 0 ] , { syntax : syntax , pastedContent : text , contextNode : contextNode } ) ; if ( parsedTree ) { var filtersList = filters . composeList ( syntax , profile , data [ 1 ] ) ; filters . apply ( parsedTree , filtersList , profile ) ; return utils . replaceVariables ( parsedTree . toString ( ) ) ; } return null ; }
3844	function ExpressionStatement ( data , define ) { this . child = parseExpression ( data , define ? define . line : 'unknown' ) ; if ( this . child instanceof SyntaxError ) throw this . child ; else if ( this . child . error ) throw this . child . error ; }
2711	function getMailtoUrl ( to , fields ) { this . form . action . match ( / mailto:([^\?&]+) / ) ; to = to || RegExp . $1 || '' ; fields = fields || { subject : this . form . getAttribute ( 'data-subject' ) || '' , body : this . getBody ( ) } ; if ( ! to && ! fields . to ) { throw new Error ( 'Could not find any person to send an email to.' ) ; } return 'mailto:' + to + '?' + Object . keys ( fields ) . reduce ( function ( a , b , i ) { return a + ( i > 0 ? '&' : '' ) + encodeURIComponent ( b ) + '=' + encodeURIComponent ( fields [ b ] ) . replace ( / %0A(?!%) / g , '%0D%0A' ) + ( b === 'body' ? '%0D%0A' : '' ) } , '' ) ; }
3645	function ( key , endWithSeparator ) { var url = this . loadNecessaryString ( key ) ; if ( ! url ) { exitProcess ( 'empty url for ' + key , this . alarm ) ; return false ; } if ( ! url . startWith ( 'http://' ) && ! url . startWith ( 'https://' ) ) { exitProcess ( 'invalid url:' + url , this . alarm ) ; return false ; } if ( endWithSeparator && ! url . endWith ( '/' ) ) { exitProcess ( 'the url[' + url + '] must be end with /' , this . alarm ) ; return false ; } if ( ! endWithSeparator && url . endWith ( '/' ) ) { exitProcess ( 'the url[' + url + '] must not be end with /' , this . alarm ) ; return false ; } return url ; }
1941	function ( gradient ) { var result = null ; require ( 'utils' ) . trim ( gradient ) . replace ( / ^([\w\-]+)\((.+?)\)$ / , function ( str , type , definition ) { type = type . toLowerCase ( ) . replace ( / ^\-[a-z]+\- / , '' ) ; if ( type == 'linear-gradient' || type == 'lg' ) { result = parseLinearGradient ( definition ) ; return '' ; } return str ; } ) ; return result ; }
3705	function PiechartCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 8 ) throw new SyntaxError ( 'PIECHART command requires 8 arguments' ) ; this . x = parsed . args [ 0 ] ; this . y = parsed . args [ 1 ] ; this . r = parsed . args [ 2 ] ; this . itemsLength = parsed . args [ 3 ] ; this . percentages = parsed . args [ 4 ] ; this . itemsRed = parsed . args [ 5 ] ; this . itemsGreen = parsed . args [ 6 ] ; this . itemsBlue = parsed . args [ 7 ] ; }
1882	function ( name , syntax ) { if ( ! name && syntax ) { var profile = require ( 'resources' ) . findItem ( syntax , 'profile' ) ; if ( profile ) { name = profile ; } } if ( ! name ) { return profiles . plain ; } if ( name instanceof OutputProfile ) { return name ; } if ( _ . isString ( name ) && name . toLowerCase ( ) in profiles ) { return profiles [ name . toLowerCase ( ) ] ; } return this . create ( name ) ; }
3434	function ( array ) { var worker = [ ] ; function rFlatten ( a ) { var i , ln , v ; for ( i = 0 , ln = a . length ; i < ln ; i ++ ) { v = a [ i ] ; if ( Ext . isArray ( v ) ) { rFlatten ( v ) ; } else { worker . push ( v ) ; } } return worker ; } return rFlatten ( array ) ; }
1949	function makeAttributesString ( tag , profile ) { var attrs = '' ; var otherAttrs = [ ] ; var attrQuote = profile . attributeQuote ( ) ; var cursor = profile . cursor ( ) ; _ . each ( tag . attributeList ( ) , function ( a ) { var attrName = profile . attributeName ( a . name ) ; switch ( attrName . toLowerCase ( ) ) { case 'id' : attrs += '#' + ( a . value || cursor ) ; break ; case 'class' : attrs += '.' + transformClassName ( a . value || cursor ) ; break ; default : otherAttrs . push ( ':' + attrName + ' => ' + attrQuote + ( a . value || cursor ) + attrQuote ) ; } } ) ; if ( otherAttrs . length ) attrs += '{' + otherAttrs . join ( ', ' ) + '}' ; return attrs ; }
3771	function skipUntil ( predicate ) { return function ( iterable ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_18 , _a ; let i = 0 ; let canReturn = false ; try { for ( var iterable_16 = __asyncValues ( iterable ) , iterable_16_1 ; iterable_16_1 = yield __await ( iterable_16 . next ( ) ) , ! iterable_16_1 . done ; ) { const item = iterable_16_1 . value ; if ( ! canReturn ) { canReturn = yield __await ( predicate ( item , i ) ) ; if ( canReturn ) { yield yield __await ( item ) ; } i = i + 1 ; } else { yield yield __await ( item ) ; } } } catch ( e_18_1 ) { e_18 = { error : e_18_1 } ; } finally { try { if ( iterable_16_1 && ! iterable_16_1 . done && ( _a = iterable_16 . return ) ) yield __await ( _a . call ( iterable_16 ) ) ; } finally { if ( e_18 ) throw e_18 . error ; } } } ) ; } ; }
1759	function ( qName , type ) { var client = redis . client ( ) ; var key = 'bull:' + qName + ':' + type ; if ( type === 'wait' || type === 'active' ) { return client . llenAsync ( key ) ; } else if ( type === 'delayed' ) { return client . zcardAsync ( key ) ; } else if ( type === 'completed' || type === 'failed' ) { return client . scardAsync ( key ) ; } throw new Error ( 'You must provide a valid job type.' ) ; }
2150	function isPure ( node , parentIsPure ) { switch ( node . type ) { case AST . MemberExpression : if ( node . computed ) { return false ; } break ; case AST . UnaryExpression : return PURITY_ABSOLUTE ; case AST . BinaryExpression : return node . operator !== '+' ? PURITY_ABSOLUTE : false ; case AST . CallExpression : return false ; } return ( undefined === parentIsPure ) ? PURITY_RELATIVE : parentIsPure ; }
3585	function addDefinition ( defName ) { var definition = definitions [ defName ] ; return function ( params , done ) { if ( ! done && typeof params === 'function' ) { done = params ; params = { } ; } var url = this . config . baseUrl + definition . url ; var xtraParams = { } ; xtraParams . fmt = this . config . responseFormat ; xtraParams . api_key = this . config . apiKey ; try { Object . keys ( definition . params ) . forEach ( function ( paramName ) { var paramDef = definition . params [ paramName ] ; if ( ! params [ paramName ] ) { if ( paramDef . required ) { throw new Error ( 'Parameter ' + paramName + ' is required' ) ; } else { return ; } } if ( paramDef . location === 'url' ) { url = url . replace ( new RegExp ( '{' + paramName + '}' , 'g' ) , params [ paramName ] ) ; } else if ( paramDef . location === 'querystring' ) { xtraParams [ paramName ] = params [ paramName ] ; } } ) ; } catch ( e ) { return done ( e ) ; } return request . get ( url ) . query ( xtraParams ) . end ( function onEnd ( err , res ) { return done ( err , res . body ) ; } ) ; } ; }
2115	function getPermission ( ) { var permission = NotificationAPI . permission ; var permissionGranted = false ; if ( permission === 'granted' ) { permissionGranted = true ; } return permissionGranted ; }
2831	function ( position ) { if ( ! this . templateNodes [ 0 ] ) { htmlToElem ( this . domElement , this . template ) ; this . templateNodes . push ( Array . prototype . slice . call ( this . domElement . childNodes ) ) ; return ; } var dummyWrapper = document . createElement ( "div" ) ; htmlToElem ( dummyWrapper , this . template ) ; var templateNodes = Array . prototype . slice . call ( dummyWrapper . childNodes ) ; if ( position == null || position == this . templateNodes . length ) { for ( var i = 0 ; i < templateNodes . length ; i ++ ) { this . domElement . appendChild ( templateNodes [ i ] ) ; } this . templateNodes . push ( templateNodes ) ; } else { for ( var i = 0 ; i < templateNodes . length ; i ++ ) { this . domElement . insertBefore ( templateNodes [ i ] , this . templateNodes [ position ] [ 0 ] ) ; } this . templateNodes . splice ( position , 0 , templateNodes ) ; } }
1515	function sortLinkColumnAscending ( link1 , link2 ) { if ( linkColumnDistance ( link1 ) == linkColumnDistance ( link2 ) ) { return link1 . circularLinkType == 'bottom' ? sortLinkSourceYDescending ( link1 , link2 ) : sortLinkSourceYAscending ( link1 , link2 ) ; } else { return linkColumnDistance ( link2 ) - linkColumnDistance ( link1 ) ; } }
2643	function ( element , valueAccessor , allBindings , viewModel , bindingContext ) { var $element = $ ( element ) ; var observable = valueAccessor ( ) ; if ( ko . unwrap ( observable ) ) { $element . datepicker ( 'update' , observable . datePicker ( ) . format ( 'DD.MM.YYYY' ) ) ; } }
2901	function ( connectionName , table , options , data , cb ) { if ( LOG_DEBUG ) { console . log ( "BEGIN update" ) ; } if ( hop ( options , 'limit' ) ) { return cb ( new Error ( 'Your \'LIMIT ' + \' + options . limit ) ) ; } '\' is not allowed in the Oracle DB UPDATE query.' \' var connectionObject = connections [ connectionName ] ; var collection = connectionObject . collections [ table ] ; var _schema = connectionObject . schema ; var processor = new Processor ( _schema ) ; var overrides = connectionOverrides [ connectionName ] || { } ; var _options = _ . cloneDeep ( sqlOptions ) ; if ( hop ( overrides , 'wlNext' ) ) { _options . wlNext = overrides . wlNext ; } var sequel = new Sequel ( _schema , _options ) ; var query ; try { query = sequel . update ( table , options , data ) ; } catch ( e ) { return cb ( e ) ; } query . query = query . query . replace ( 'RETURNING *' , '' ) ; query . query = query . query . replace ( / \$ / g , ':' ) ; query . query = query . query . replace ( ' AS ' , " " ) ; var keys = Object . keys ( data ) ; var j = 1 ; for ( j ; j < keys . length + 1 ; j ++ ) { query . query = query . query . replace ( ":" + j , ":" + keys [ j - 1 ] ) ; } var keysoptions = Object . keys ( options . where ) ; var oraOptions = { where : { } } ; for ( var k = 0 ; k < keysoptions . length ; k ++ ) { oraOptions . where [ "where" + keysoptions [ k ] ] = options . where [ keysoptions [ k ] ] ; data [ "where" + keysoptions [ k ] ] = options . where [ keysoptions [ k ] ] ; } var keysoptions = Object . keys ( oraOptions . where ) ; }
1590	function VFile ( options ) { var prop var index var length if ( ! options ) { options = { } } else if ( typeof options === 'string' || buffer ( options ) ) { options = { contents : options } } else if ( 'message' in options && 'messages' in options ) { return options } if ( ! ( this instanceof VFile ) ) { return new VFile ( options ) } this . data = { } this . messages = [ ] this . history = [ ] this . cwd = process . cwd ( ) index = - 1 length = order . length while ( ++ index < length ) { prop = order [ index ] if ( own . call ( options , prop ) ) { this [ prop ] = options [ prop ] } } for ( prop in options ) { if ( order . indexOf ( prop ) === - 1 ) { this [ prop ] = options [ prop ] } } }
1969	function uploadSkin ( { accessToken } , profileId , file , isSlim = false ) { const form = new FormData ( ) form . append ( 'model' , isSlim ? 'slim' : '' ) form . append ( 'file' , file ) return fetch ( ` ${ CORE_API } ${ profileId } ` , { method : 'PUT' , body : form , headers : { 'user-agent' : USER_AGENT , 'authorization' : ` ${ accessToken } ` } } ) . then ( handleErrors ) . then ( res => null ) }
1088	function auth ( req ) { if ( ! req ) { throw new TypeError ( 'argument req is required' ) } if ( typeof req !== 'object' ) { throw new TypeError ( 'argument req is required to be an object' ) } var header = getAuthorization ( req ) return parse ( header ) }
310	function getMaxZoomRatio ( pointers ) { var pointers2 = assign ( { } , pointers ) ; var ratios = [ ] ; forEach ( pointers , function ( pointer , pointerId ) { delete pointers2 [ pointerId ] ; forEach ( pointers2 , function ( pointer2 ) { var x1 = Math . abs ( pointer . startX - pointer2 . startX ) ; var y1 = Math . abs ( pointer . startY - pointer2 . startY ) ; var x2 = Math . abs ( pointer . endX - pointer2 . endX ) ; var y2 = Math . abs ( pointer . endY - pointer2 . endY ) ; var z1 = Math . sqrt ( x1 * x1 + y1 * y1 ) ; var z2 = Math . sqrt ( x2 * x2 + y2 * y2 ) ; var ratio = ( z2 - z1 ) / z1 ; ratios . push ( ratio ) ; } ) ; } ) ; ratios . sort ( function ( a , b ) { return Math . abs ( a ) < Math . abs ( b ) ; } ) ; return ratios [ 0 ] ; }
2976	function trmv ( A , x , isLower ) { var dot = blas1 . dot ; var n = A . shape [ 1 ] ; var i = 0 ; if ( isLower ) { for ( i = n - 1 ; i >= 0 ; i -- ) { x . set ( i , dot ( A . pick ( i , null ) . hi ( i + 1 ) , x . hi ( i + 1 ) ) ) ; } } else { for ( i = 0 ; i < n ; i ++ ) { x . set ( i , dot ( A . pick ( i , null ) . lo ( i ) , x . lo ( i ) ) ) ; } } return true ; }
3285	function ( ) { var me = this , prev = me . store . currentPage - 1 ; if ( prev > 0 ) { if ( me . fireEvent ( 'beforechange' , me , prev ) !== false ) { me . store . previousPage ( ) ; } } }
1742	function moveGroup ( state , action ) { const place_at = getLayerIndexById ( state . layers , action . placeAt ) ; const n_layers = state . layers . length ; if ( place_at < 0 || place_at > n_layers ) { return state ; } let group_start = null ; let group_end = null ; for ( let i = 0 , ii = n_layers ; i < ii ; i ++ ) { const group = getGroup ( state . layers [ i ] ) ; if ( group === action . group ) { if ( group_start === null || i < group_start ) { group_start = i ; } if ( group_end === null || i > group_end ) { group_end = i ; } } } let place_start = place_at ; const place_group = getGroup ( state . layers [ place_at ] ) ; const place_ahead = ( place_at > group_start ) ; if ( place_group ) { let new_place = - 1 ; if ( place_ahead ) { for ( let i = n_layers - 1 ; i >= 0 && new_place < 0 ; i -- ) { if ( getGroup ( state . layers [ i ] ) === place_group ) { new_place = i ; } } } else { for ( let i = 0 , ii = n_layers ; i < ii && new_place < 0 ; i ++ ) { if ( getGroup ( state . layers [ i ] ) === place_group ) { new_place = i ; } } } place_start = new_place ; } let new_layers = [ ] ; const group_layers = state . layers . slice ( group_start , group_end + 1 ) ; for ( let i = 0 , ii = n_layers ; i < ii ; i ++ ) { const layer = state . layers [ i ] ; const in_group = ( getGroup ( layer ) === action . group ) ; if ( place_ahead && ! in_group ) { new_layers . push ( layer ) ; } if ( i === place_start ) { new_layers = new_layers . concat ( group_layers ) ; } if ( ! place_ahead && ! in_group ) { new_layers . push ( layer ) ; } } return Object . assign ( { } , state , { layers : new_layers , } , incrementVersion ( state . metadata , LAYER_VERSION_KEY ) ) ; }
3136	function ( binding ) { var me = this , bindings = me . bindings , len = bindings . length , i , item , keys ; if ( me . processing ) { me . bindings = bindings . slice ( 0 ) ; } keys = me . processKeys ( binding . key ) ; for ( i = 0 ; i < len ; ++ i ) { item = bindings [ i ] ; if ( item . fn === binding . fn && item . scope === binding . scope ) { if ( binding . alt == item . alt && binding . crtl == item . crtl && binding . shift == item . shift ) { if ( Ext . Array . equals ( item . keyCode , keys ) ) { Ext . Array . erase ( me . bindings , i , 1 ) ; return ; } } } } }
1204	function _getNextSiblingThatIsNotBlank ( node ) { var nextSibling = node . nextSibling ; while ( nextSibling && _isBlankTextNode ( nextSibling ) ) { nextSibling = nextSibling . nextSibling ; } return nextSibling ; }
324	function moveTo ( x ) { var y = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : x ; var canvasData = this . canvasData ; var changed = false ; x = Number ( x ) ; y = Number ( y ) ; if ( this . ready && ! this . disabled && this . options . movable ) { if ( isNumber ( x ) ) { canvasData . left = x ; changed = true ; } if ( isNumber ( y ) ) { canvasData . top = y ; changed = true ; } if ( changed ) { this . renderCanvas ( true ) ; } } return this ; }
1355	function nextVersions ( options , nameVersionPairs , checkLatestOnly ) { check . verify . object ( options , 'expected object with options' ) check . verify . array ( nameVersionPairs , 'expected array' ) nameVersionPairs = cleanVersions ( nameVersionPairs ) const verbose = verboseLog ( options ) verbose ( 'checking NPM registry' ) var MAX_CHECK_TIMEOUT = options . checkVersionTimeout || 10000 var fetchPromises = nameVersionPairs . map ( fetchVersions . bind ( null , options ) ) var fetchAllPromise = q . all ( fetchPromises ) . timeout ( MAX_CHECK_TIMEOUT , 'timed out waiting for NPM after ' + MAX_CHECK_TIMEOUT + 'ms' ) return fetchAllPromise . then ( _ . partial ( filterFetchedVersions , checkLatestOnly ) , q . reject ) }
142	function updateChangedCssFiles ( ) { let hash , filePath ; const changedFiles = [ ] ; for ( filePath in publicCssFiles ) { hash = md5File . sync ( filePath ) ; if ( hash !== publicCssFiles [ filePath ] ) { publicCssFiles [ filePath ] = hash ; changedFiles . push ( path . basename ( filePath ) ) ; } } return changedFiles ; }
707	function propertyTree ( subject ) { var rep = myDocument . createElement ( 'table' ) var lastPred = null var sts = subjects [ sz . toStr ( subject ) ] if ( ! sts ) { rep . appendChild ( myDocument . createTextNode ( '...' ) ) return rep } sts . sort ( ) var same = 0 var predicateTD for ( var i = 0 ; i < sts . length ; i ++ ) { var st = sts [ i ] var tr = myDocument . createElement ( 'tr' ) if ( st . predicate . uri !== lastPred ) { if ( lastPred && same > 1 ) predicateTD . setAttribute ( 'rowspan' , '' + same ) predicateTD = myDocument . createElement ( 'td' ) predicateTD . setAttribute ( 'class' , 'pred' ) var anchor = myDocument . createElement ( 'a' ) anchor . setAttribute ( 'href' , st . predicate . uri ) anchor . addEventListener ( 'click' , UI . widgets . openHrefInOutlineMode , true ) anchor . appendChild ( myDocument . createTextNode ( UI . utils . predicateLabelForXML ( st . predicate ) ) ) predicateTD . appendChild ( anchor ) tr . appendChild ( predicateTD ) lastPred = st . predicate . uri same = 0 } same ++ var objectTD = myDocument . createElement ( 'td' ) objectTD . appendChild ( objectTree ( st . object ) ) tr . appendChild ( objectTD ) rep . appendChild ( tr ) } if ( lastPred && same > 1 ) predicateTD . setAttribute ( 'rowspan' , '' + same ) return rep }
3431	function ( ) { var intersection = [ ] , arrays = slice . call ( arguments ) , arraysLength , array , arrayLength , minArray , minArrayIndex , minArrayCandidate , minArrayLength , element , elementCandidate , elementCount , i , j , k ; if ( ! arrays . length ) { return intersection ; } arraysLength = arrays . length ; for ( i = minArrayIndex = 0 ; i < arraysLength ; i ++ ) { minArrayCandidate = arrays [ i ] ; if ( ! minArray || minArrayCandidate . length < minArray . length ) { minArray = minArrayCandidate ; minArrayIndex = i ; } } minArray = ExtArray . unique ( minArray ) ; erase ( arrays , minArrayIndex , 1 ) ; minArrayLength = minArray . length ; arraysLength = arrays . length ; for ( i = 0 ; i < minArrayLength ; i ++ ) { element = minArray [ i ] ; elementCount = 0 ; for ( j = 0 ; j < arraysLength ; j ++ ) { array = arrays [ j ] ; arrayLength = array . length ; for ( k = 0 ; k < arrayLength ; k ++ ) { elementCandidate = array [ k ] ; if ( element === elementCandidate ) { elementCount ++ ; break ; } } } if ( elementCount === arraysLength ) { intersection . push ( element ) ; } } return intersection ; }
1180	function redirect ( v ) { var edges = tree . inEdges ( v ) ; for ( var i in edges ) { var e = edges [ i ] ; var u = tree . source ( e ) ; var value = tree . edge ( e ) ; redirect ( u ) ; tree . delEdge ( e ) ; value . reversed = ! value . reversed ; tree . addEdge ( e , v , u , value ) ; } }
312	function getPointersCenter ( pointers ) { var pageX = 0 ; var pageY = 0 ; var count = 0 ; forEach ( pointers , function ( _ref3 ) { var startX = _ref3 . startX , startY = _ref3 . startY ; pageX += startX ; pageY += startY ; count += 1 ; } ) ; pageX /= count ; pageY /= count ; return { pageX : pageX , pageY : pageY } ; }
2520	function ( props ) { if ( typeof props != 'object' ) { throw new Error ( 'expected object' ) ; } var child = Object . create ( this ) ; mixin ( child , props ) ; child . fastdom = this ; if ( child . initialize ) { child . initialize ( ) ; } return child ; }
342	function ( ) { if ( this . config . searchable || this . config . taggable ) { this . input . value = null ; this . searching = false ; if ( this . config . searchable ) { util . removeClass ( this . inputContainer , "active" ) ; } if ( util . hasClass ( this . container , "notice" ) ) { util . removeClass ( this . container , "notice" ) ; util . addClass ( this . container , "open" ) ; this . input . focus ( ) ; } util . each ( this . items , function ( i , item ) { util . removeClass ( item , "excluded" ) ; if ( ! this . customOption ) { item . innerHTML = item . textContent ; } } , this ) ; } }
2957	function ( ) { if ( 4 == arguments . length ) { redis . set ( arguments [ 0 ] , arguments [ 1 ] , ( ) => { redis . expire ( arguments [ 0 ] , arguments [ 2 ] , arguments [ 3 ] ) ; } ) ; } }
718	function ( senderPriv , recipientPub , msg ) { if ( ! senderPriv || ! recipientPub || ! msg ) throw new Error ( 'Missing argument !' ) ; let iv = nacl . randomBytes ( 16 ) let salt = nacl . randomBytes ( 32 ) let encoded = _encode ( senderPriv , recipientPub , msg , iv , salt ) ; return encoded ; }
1318	function addPreRun ( func ) { if ( ! Module [ 'preRun' ] ) Module [ 'preRun' ] = [ ] ; else if ( typeof Module [ 'preRun' ] == 'function' ) Module [ 'preRun' ] = [ Module [ 'preRun' ] ] ; Module [ 'preRun' ] . push ( func ) ; }
2210	function validateBake ( inlineValues ) { if ( "_bake" in inlineValues ) { var signature = inlineValues [ "_bake" ] ; delete inlineValues [ "_bake" ] ; var set = signature . split ( ">" , 2 ) ; return { src : mout . string . trim ( set [ 0 ] ) , dest : mout . string . trim ( set [ 1 ] ) } ; } return null ; }
2439	function checkTile ( tile ) { if ( ! tile ) return false ; if ( tileIndices && tileIndices . includes ( tile . index ) ) return true ; if ( tileProperty && tile . properties [ tileProperty ] ) return true ; if ( checkCollide && tile . collides ) return true ; return false ; }
3327	function ( ) { var rect = this . element . getClientRects ( ) [ 0 ] ; this . completer . style . top = rect . top + 'px' ; var height = rect . bottom - rect . top ; this . completer . style . height = height + 'px' ; this . completer . style . lineHeight = height + 'px' ; this . completer . style . left = rect . left + 'px' ; var width = rect . right - rect . left ; this . completer . style . width = width + 'px' ; if ( this . hintDirection . get ( ) === 'below' ) { this . hinter . style . top = rect . bottom + 'px' ; this . hinter . style . bottom = 'auto' ; } else { this . hinter . style . top = 'auto' ; this . hinter . style . bottom = ( this . doc . documentElement . clientHeight - rect . top ) + 'px' ; } this . hinter . style . left = ( rect . left + 30 ) + 'px' ; this . hinter . style . maxWidth = ( width - 110 ) + 'px' ; if ( this . popupOutput ) { if ( this . outputDirection . get ( ) === 'below' ) { this . output . style . top = rect . bottom + 'px' ; this . output . style . bottom = 'auto' ; } else { this . output . style . top = 'auto' ; this . output . style . bottom = ( this . doc . documentElement . clientHeight - rect . top ) + 'px' ; } this . output . style . left = rect . left + 'px' ; this . output . style . width = ( width - 80 ) + 'px' ; } }
3687	function _mapCopy ( sourceRef , copyRef , rc ) { return _instanceCopy ( sourceRef , copyRef , rc , ( map , val , key ) => { map . set ( key , _clone ( val , rc ) ) ; } ) ; }
3343	function ( id ) { var existing = doc . getElementById ( id ) ; if ( existing ) { existing . parentNode . removeChild ( existing ) ; } }
2102	function ( soajs , combo , cb ) { checkForMongo ( soajs ) ; mongo . remove ( combo . collection , combo . condition , cb ) ; }
704	function ( store , subject ) { kb . fetcher . nowOrWhenFetched ( store . uri , subject , function ( ok , body ) { if ( ! ok ) return complain ( 'Cannot load store ' + store . uri + ': ' + body ) var forms = UI . widgets . formsFor ( subject ) for ( var i = 0 ; i < forms . length ; i ++ ) { var form = forms [ i ] var heading = dom . createElement ( 'h4' ) box . appendChild ( heading ) if ( form . uri ) { var formStore = $rdf . Util . uri . document ( form ) if ( formStore . uri !== form . uri ) { var e = box . appendChild ( UI . widgets . editFormButton ( dom , box , form , formStore , complainIfBad ) ) e . setAttribute ( 'style' , 'float: right;' ) } } var anchor = dom . createElement ( 'a' ) anchor . setAttribute ( 'href' , form . uri ) heading . appendChild ( anchor ) anchor . textContent = UI . utils . label ( form , true ) UI . widgets . appendForm ( dom , box , { } , subject , form , store , complainIfBad ) } } ) }
418	function ( ) { if ( parserInput . peekNotNumeric ( ) ) { return ; } var value = parserInput . $re ( / ^([+-]?\d*\.?\d+)(%|[a-z_]+)? / i ) ; if ( value ) { return new ( tree . Dimension ) ( value [ 1 ] , value [ 2 ] ) ; } }
3143	function ( ) { var me = this , items = me . flushQueue . clear ( ) , length = items . length , i ; if ( length ) { ++ me . flushCount ; for ( i = 0 ; i < length ; ++ i ) { items [ i ] . flush ( ) ; } } }
2420	function ( coeffs , aziElev ) { var aziElevR = aziElev ; var N = Math . sqrt ( coeffs . length ) - 1 ; var Y_N = computeRealSH ( N , aziElev ) ; var data = numeric . dotVM ( coeffs , Y_N ) ; for ( var i = 0 ; i < aziElev . length ; i ++ ) { aziElevR [ i ] [ 2 ] = data [ i ] ; } return aziElevR ; }
2414	function readFile ( file , encoding ) { return new Promise ( ( resolve , reject ) => { fs . readFile ( file , encoding , ( error , data ) => error ? reject ( error ) : resolve ( data ) ) ; } ) ; }
1320	function isMultisource ( arg ) { return Array . isArray ( arg ) && ! ( typeof arg [ 0 ] === 'number' && ( arg . length === 1 || typeof arg [ 1 ] === 'number' ) ) && ! ( arg . length < 32 && arg . every ( ch => Array . isArray ( ch ) || ArrayBuffer . isView ( ch ) ) ) }
849	function getModuleExportsNodes ( scope ) { const variable = scope . set . get ( "module" ) if ( variable == null ) { return [ ] } return variable . references . map ( reference => reference . identifier . parent ) . filter ( node => node . type === "MemberExpression" && getStaticPropertyName ( node ) === "exports" ) }
2354	function ( datasetClientId , fields , records , callback ) { return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doUpdateDatasetClientWithRecords ) ( datasetClientId , fields , records , callback ) ; }
69	function repaint ( element ) { setTimeout ( function ( ) { try { toggleHidden ( element , true ) ; element . offsetHeight ; toggleHidden ( element , false ) ; } catch ( e ) { } } , 0 ) ; }
655	function ( paper ) { this . setPaper ( paper ) ; this . defaultResearches = { urlLength : urlLength , wordCountInText : wordCountInText , findKeywordInPageTitle : findKeywordInPageTitle , calculateFleschReading : calculateFleschReading , getLinkStatistics : getLinkStatistics , getLinks : getLinks , linkCount : linkCount , imageCount : imageCount , altTagCount : altTagCount , matchKeywordInSubheadings : matchKeywordInSubheadings , keywordCount : keywordCount , getKeywordDensity : getKeywordDensity , stopWordsInKeyword : stopWordsInKeyword , stopWordsInUrl : stopWordsInUrl , metaDescriptionLength : metaDescriptionLength , keyphraseLength : keyphraseLength , keywordCountInUrl : keywordCountInUrl , firstParagraph : findKeywordInFirstParagraph , metaDescriptionKeyword : metaDescriptionKeyword , pageTitleWidth : pageTitleWidth , wordComplexity : wordComplexity , getParagraphLength : getParagraphLength , countSentencesFromText : countSentencesFromText , countSentencesFromDescription : countSentencesFromDescription , getSubheadingTextLengths : getSubheadingTextLengths , findTransitionWords : findTransitionWords , passiveVoice : passiveVoice , getSentenceBeginnings : getSentenceBeginnings , relevantWords : relevantWords , readingTime : readingTime , getTopicDensity : getTopicDensity , topicCount : topicCount , sentences , keyphraseDistribution : keyphraseDistribution , morphology : morphology , functionWordsInKeyphrase : functionWordsInKeyphrase , h1s : h1s , } ; this . _data = { } ; this . customResearches = { } ; }
3320	function ( nameOrNumber ) { var name = ( typeof nameOrNumber === 'string' ) ? nameOrNumber : Object . keys ( this . _assignments ) [ nameOrNumber ] ; return this . _assignments [ name ] ; }
1508	function wrapper ( type , contents ) { var buf , len , i ; len = lengthArray ( contents . length ) ; buf = new Buffer ( 1 + contents . length + len . length ) ; buf [ 0 ] = type ; for ( i = 1 ; i < len . length + 1 ; i ++ ) { buf [ i ] = len [ i - 1 ] ; } contents . copy ( buf , len . length + 1 , 0 ) ; return buf ; }
3666	function options ( Class , hash ) { var opts ; var type = { type : Class . _usergrid . type } ; if ( hash ) { opts = _ . assign ( { } , hash , type ) ; } else { opts = type ; } return opts ; }
2745	function tryApplyUpdates ( onHotUpdateSuccess ) { if ( ! module . hot ) { window . location . reload ( ) ; return ; } if ( ! isUpdateAvailable ( ) || ! canApplyUpdates ( ) ) { return ; } function handleApplyUpdates ( err , updatedModules ) { if ( err || ! updatedModules ) { window . location . reload ( ) ; return ; } if ( typeof onHotUpdateSuccess === 'function' ) { onHotUpdateSuccess ( ) ; } if ( isUpdateAvailable ( ) ) { tryApplyUpdates ( ) ; } } var result = module . hot . check ( true , handleApplyUpdates ) ; if ( result && result . then ) { result . then ( function ( updatedModules ) { handleApplyUpdates ( null , updatedModules ) ; } , function ( err ) { handleApplyUpdates ( err , null ) ; } ) ; } }
645	function updateProgressBar ( element , value , maximum , rating ) { var barElement , progress , allClasses = [ "snippet-editor__progress--bad" , "snippet-editor__progress--ok" , "snippet-editor__progress--good" , ] ; element . value = value ; domManipulation . removeClasses ( element , allClasses ) ; domManipulation . addClass ( element , "snippet-editor__progress--" + rating ) ; if ( ! this . hasProgressSupport ) { barElement = element . getElementsByClassName ( "snippet-editor__progress-bar" ) [ 0 ] ; progress = ( value / maximum ) * 100 ; barElement . style . width = progress + "%" ; } }
2250	function use ( code , lightColor ) { return util . format ( base , ( lightColor === true ) ? code + colorLightValueChange : code ) ; }
1337	function gen ( node ) { if ( node && ! generator [ node . type ] ) { throw new Error ( ` ${ node . type } ` ) ; } return node ? generator [ node . type ] ( node ) : '' ; }
966	function analyseNativeComponent ( scriptFile , options ) { if ( scriptFile . isAnalysedComponents ) { return ; } scriptFile . isAnalysedComponents = true ; let { appType } = options ; if ( appType === 'quick' ) { return ; } addComponentSameNameFiles ( scriptFile , options ) ; }
1582	function isEmpty ( value ) { if ( value == null ) { return true ; } if ( isArrayLike ( value ) && ( isArray ( value ) || typeof value == 'string' || typeof value . splice == 'function' || isBuffer ( value ) || isTypedArray ( value ) || isArguments ( value ) ) ) { return ! value . length ; } var tag = getTag$1 ( value ) ; if ( tag == mapTag$3 || tag == setTag$3 ) { return ! value . size ; } if ( isPrototype ( value ) ) { return ! baseKeys ( value ) . length ; } for ( var key in value ) { if ( hasOwnProperty$c . call ( value , key ) ) { return false ; } } return true ; }
2968	function sizeIt ( gridSize , sizeEle , sizeScreen = 'xs' ) { let outerSize = _getOuterSize ( gridSize , sizeScreen ) ; let size = sizeEle * grid / outerSize ; if ( size > grid ) size = grid ; else if ( size < 1 ) size = 1 ; return Math . round ( size ) ; }
2154	function formatNumber ( number , pattern , groupSep , decimalSep , fractionSize ) { if ( ! ( isString ( number ) || isNumber ( number ) ) || isNaN ( number ) ) return '' ; var isInfinity = ! isFinite ( number ) ; var isZero = false ; var numStr = Math . abs ( number ) + '' , formattedText = '' , parsedNumber ; if ( isInfinity ) { formattedText = '\u221e' ; } else \u221e { parsedNumber = parse ( numStr ) ; roundNumber ( parsedNumber , fractionSize , pattern . minFrac , pattern . maxFrac ) ; var digits = parsedNumber . d ; var integerLen = parsedNumber . i ; var exponent = parsedNumber . e ; var decimals = [ ] ; isZero = digits . reduce ( function ( isZero , d ) { return isZero && ! d ; } , true ) ; while ( integerLen < 0 ) { digits . unshift ( 0 ) ; integerLen ++ ; } if ( integerLen > 0 ) { decimals = digits . splice ( integerLen , digits . length ) ; } else { decimals = digits ; digits = [ 0 ] ; } var groups = [ ] ; if ( digits . length >= pattern . lgSize ) { groups . unshift ( digits . splice ( - pattern . lgSize , digits . length ) . join ( '' ) ) ; } while ( digits . length > pattern . gSize ) { groups . unshift ( digits . splice ( - pattern . gSize , digits . length ) . join ( '' ) ) ; } if ( digits . length ) { groups . unshift ( digits . join ( '' ) ) ; } formattedText = groups . join ( groupSep ) ; if ( decimals . length ) { formattedText += decimalSep + decimals . join ( '' ) ; } if ( exponent ) { formattedText += 'e+' + exponent ; } } }
3303	function defaultTransformer ( ... args ) { try { let [ record , ... rest ] = args try { record = typeof record === 'string' ? JSON . parse ( record ) : record } catch ( err ) { return { type : 'bunyan' , record : { err : new Error ( 'Could not parse message.' ) } } } return { type : 'bunyan' , record } } catch ( err ) { return { type : 'bunyan' , record : { err : new Error ( 'Internal error occurred.' ) } } } }
3291	function getPlugins ( opts ) { var batterRootDir = __dirname . replace ( delim + 'lib' , '' ) ; var batterTasks = { rootDir : batterRootDir } ; var currentProject = { rootDir : opts . rootDir } ; var plugins = opts . plugins || [ ] ; plugins . unshift ( batterTasks ) ; if ( batterRootDir !== opts . rootDir ) { plugins . push ( currentProject ) ; } return plugins ; }
2545	function toFinite ( value ) { if ( ! value ) { return value === 0 ? value : 0 ; } value = toNumber ( value ) ; if ( value === INFINITY$3 || value === - INFINITY$3 ) { var sign = ( value < 0 ? - 1 : 1 ) ; return sign * MAX_INTEGER ; } return value === value ? value : 0 ; }
1216	function newMethod ( name , accessor ) { var impl = OAuth . SignatureMethod . REGISTERED [ name ] ; if ( impl != null ) { var method = new impl ( ) ; method . initialize ( name , accessor ) ; return method ; } var err = new Error ( "signature_method_rejected" ) ; var acceptable = "" ; for ( var r in OAuth . SignatureMethod . REGISTERED ) { if ( acceptable != "" ) acceptable += '&' ; acceptable += OAuth . percentEncode ( r ) ; } err . oauth_acceptable_signature_methods = acceptable ; throw err ; }
3373	function ( store ) { var me = this ; if ( me . store && me . storeListeners ) { me . store . un ( me . storeListeners ) ; } if ( store ) { me . storeListeners = { scope : me } ; if ( me . local ) { me . storeListeners . load = me . onLoad ; } else { me . storeListeners [ 'before' + ( store . buffered ? 'prefetch' : 'load' ) ] = me . onBeforeLoad ; } store . on ( me . storeListeners ) ; } else { delete me . storeListeners ; } me . store = store ; }
3790	function ( params ) { var res = [ ] ; if ( typeof ( params ) === 'undefined' ) params = { displayEverything : false } ; if ( ! this . registeredModels || Object . keys ( this . registeredModels ) . length === 0 ) { res . push ( 'There is no registered models' ) ; } else { res . push ( 'List of registered models' ) ; for ( var modelName in this . registeredModels ) { res . push ( ' - ' + modelName ) ; if ( params . displayEverything ) { for ( var key in this . registeredModels [ modelName ] ) { res . push ( ' ' + key + ' : ' + this . registeredModels [ modelName ] [ key ] . type ) ; } } } } return res . join ( '\n' ) ; }
2559	function attachLibraryToSelf ( ) { for ( var i in libs ) if ( libs . hasOwnProperty ( i ) && ! self [ i ] ) self [ i ] = libs [ i ] ; return self ; }
885	function getCustomComponentTags ( config ) { let { usingComponents } = config || { } ; if ( ! usingComponents ) { return ; } return Object . keys ( usingComponents ) . map ( k => toHyphen ( k ) ) ; }
1978	function setSkin ( { accessToken } , profileId , skinUrl , isSlim = false ) { const params = new URLSearchParams ( ) params . append ( 'model' , isSlim ? 'slim' : '' ) params . append ( 'url' , skinUrl ) return fetch ( ` ${ CORE_API } ${ profileId } ` , { method : 'POST' , body : params , headers : { 'user-agent' : USER_AGENT , 'authorization' : ` ${ accessToken } ` } } ) . then ( handleErrors ) . then ( res => null ) }
2187	function _clone ( value , refFrom , refTo , deep ) { var copy = function copy ( copiedValue ) { var len = refFrom . length ; var idx = 0 ; while ( idx < len ) { if ( value === refFrom [ idx ] ) { return refTo [ idx ] ; } idx += 1 ; } refFrom [ idx + 1 ] = value ; refTo [ idx + 1 ] = copiedValue ; for ( var key in value ) { copiedValue [ key ] = deep ? _clone ( value [ key ] , refFrom , refTo , true ) : value [ key ] ; } return copiedValue ; } ; switch ( type ( value ) ) { case 'Object' : return copy ( { } ) ; case 'Array' : return copy ( [ ] ) ; case 'Date' : return new Date ( value . valueOf ( ) ) ; case 'RegExp' : return _cloneRegExp ( value ) ; default : return value ; } }
3351	function ( req , res , runMethod ) { var form = new formidable . IncomingForm ( ) , files = { } , fields = { } , size = 0 for ( var i in formConfig ) { form [ i ] = formConfig [ i ] } form . on ( 'file' , function ( field , file ) { size += file . size if ( size > maxUploadSize ) { return false ; } if ( files [ field ] ) { if ( ! util . isArray ( files [ field ] ) ) files [ field ] = [ files [ field ] ] files [ field ] . push ( file ) } else { files [ field ] = file ; } } ) form . on ( 'field' , function ( field , value ) { if ( fields [ field ] ) { if ( ! util . isArray ( fields [ field ] ) ) fields [ field ] = [ fields [ field ] ] fields [ field ] . push ( value ) } else { fields [ field ] = value ; } } ) form . on ( 'end' , function ( ) { fields . files = files runMethod ( req , res , fields ) ; } ) ; form . parse ( req ) ; }
865	function hasPattern ( s , pattern ) { const m = pattern . exec ( s ) return m != null && ( m [ 1 ] || "" ) . length % 2 === 0 }
3179	function ( width , height ) { var me = this ; me . target . setSize ( width , height ) ; me . fireEvent ( 'resize' , me , width , height , null ) ; }
3236	function ( columns ) { var i , len = columns . length , column ; for ( i = 0 ; i < len ; i ++ ) { column = columns [ i ] ; if ( ! column . processed && column . locked ) { return true ; } } }
1380	function Publisher ( AWSConfig , cacheOptions ) { this . config = AWSConfig ; this . client = new AWS . S3 ( AWSConfig ) ; var bucket = this . config . params . Bucket ; if ( ! bucket ) { throw new Error ( 'Missing `params.Bucket` config value.' ) ; } this . _cacheFile = cacheOptions && cacheOptions . cacheFileName ? cacheOptions . cacheFileName : '.awspublish-' + bucket ; try { this . _cache = JSON . parse ( fs . readFileSync ( this . getCacheFilename ( ) , 'utf8' ) ) ; } catch ( err ) { this . _cache = { } ; } }
1354	function getLocalModuleVersion ( name ) { check . verify . string ( name , 'missing name string' ) try { var filename = path . join ( 'node_modules' , name , 'package.json' ) var contents = fs . readFileSync ( filename , 'utf-8' ) var pkg = JSON . parse ( contents ) return pkg . version } catch ( error ) { console . error ( 'could not fetch version for local module' , name ) console . error ( error ) return null } }
2533	function getChainContext ( storage , chainId , field ) { if ( storage [ GET_CHAIN_CONTEXT_METHOD ] ) { return storage [ GET_CHAIN_CONTEXT_METHOD ] ( chainId , field ) ; } if ( storage [ chainId ] ) { return storage [ chainId ] [ field ] ; } }
3280	async function getFiles ( paths , options ) { const files = ( await getVinylFiles ( paths , options ) ) . map ( file => [ file , ... getRequires ( file , options ) ] ) ; return ( await promiseFlatten ( files ) ) . filter ( file => file ) . filter ( filterDuplicateFiles ( ) ) ; }
2663	function smsCancelCampaign ( callback , campaign_id ) { if ( campaign_id === undefined ) { return callback ( returnError ( "Empty sms campaign id" ) ) ; } sendRequest ( 'sms/campaigns/cancel/' + campaign_id , 'PUT' , { } , true , callback ) ; }
298	function addClass ( element , value ) { if ( ! value ) { return ; } if ( isNumber ( element . length ) ) { forEach ( element , function ( elem ) { addClass ( elem , value ) ; } ) ; return ; } if ( element . classList ) { element . classList . add ( value ) ; return ; } var className = element . className . trim ( ) ; if ( ! className ) { element . className = value ; } else if ( className . indexOf ( value ) < 0 ) { element . className = "" . concat ( className , " " ) . concat ( value ) ; } }
1328	function checkFlags ( flags ) { const seen = new Set ( ) ; for ( const flag of flags ) { if ( seen . has ( flag ) || ! validFlags . includes ( flag ) ) { throw new SyntaxError ( ` ${ flags } ` ) ; } seen . add ( flag ) ; } return flags . split ( '' ) . sort ( ) . join ( '' ) ; }
2151	function $$SanitizeUriProvider ( ) { var aHrefSanitizationWhitelist = / ^\s*(https?|s?ftp|mailto|tel|file): / , imgSrcSanitizationWhitelist = / ^\s*((https?|ftp|file|blob):|data:image\/) / ; this . aHrefSanitizationWhitelist = function ( regexp ) { if ( isDefined ( regexp ) ) { aHrefSanitizationWhitelist = regexp ; return this ; } return aHrefSanitizationWhitelist ; } ; this . imgSrcSanitizationWhitelist = function ( regexp ) { if ( isDefined ( regexp ) ) { imgSrcSanitizationWhitelist = regexp ; return this ; } return imgSrcSanitizationWhitelist ; } ; this . $get = function ( ) { return function sanitizeUri ( uri , isMediaUrl ) { var regex = isMediaUrl ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist ; var normalizedVal = urlResolve ( uri && uri . trim ( ) ) . href ; if ( normalizedVal !== '' && ! normalizedVal . match ( regex ) ) { return 'unsafe:' + normalizedVal ; } return uri ; } ; } ; }
240	function parseGitDiffToPathArray ( command ) { return execSync ( command , { encoding : 'utf8' } ) . split ( '\n' ) . \n map . ( name => name . trim ( ) ) filter ; }
8	function calculateLineHeight ( model , columnWidths ) { var padding = this . internal . __cell__ . padding ; var fontSize = this . internal . __cell__ . table_font_size ; var scaleFactor = this . internal . scaleFactor ; return Object . keys ( model ) . map ( function ( value ) { return typeof value === 'object' ? value . text : value } ) . map ( function ( value ) { return this . splitTextToSize ( value , columnWidths [ value ] - padding - padding ) } , this ) . map ( function ( value ) { return this . getLineHeightFactor ( ) * value . length * fontSize / scaleFactor + padding + padding } , this ) . reduce ( function ( pv , cv ) { return Math . max ( pv , cv ) } , 0 ) ; }
2894	function injectData ( tokenValue , options , key ) { var data ; if ( ~ options . contentType . indexOf ( 'application/json' ) ) { data = options . data ? JSON . parse ( options . data ) : { } ; data [ key ] = tokenValue ; options . data = JSON . stringify ( data ) ; } else { options . data += options . data ? '&' : '' ; options . data += key + '=' + tokenValue ; } }
1489	async function ( filename , data ) { if ( ! data ) { if ( await fs . existsAsync ( filename ) ) { fs . unlinkAsync ( filename ) ; } } else { await fs . writeFileAsync ( filename , JSON . stringify ( data , null , 2 ) , "utf8" ) ; } }
1565	function sum ( arr , prop ) { return arr . reduce ( function ( sum , obj ) { return sum + obj . stats [ prop ] ; } , 0 ) ; }
3852	function setArrayIndexAt ( arr , dimensions , val , data ) { var currentDimension = dimensions [ 0 ] . execute ( data ) ; data . validate ( currentDimension , 'number' ) ; currentDimension -= 1 ; if ( currentDimension < 0 ) currentDimension = 0 ; if ( arr . length <= currentDimension ) throw new Error ( 'Invalid array bounds' ) ; var item = arr [ currentDimension ] ; if ( dimensions . length > 1 ) { if ( ! Array . isArray ( item ) ) throw new Error ( 'Invalid array dimensions' ) ; return setArrayIndexAt ( arr [ currentDimension ] , dimensions . slice ( 1 ) , val , data ) ; } else arr [ currentDimension ] = val ; }
401	function fromSource ( src , options ) { const config = { features : { FetchExternalResources : [ 'script' ] , ProcessExternalResources : [ 'script' ] } , virtualConsole : jsdom . createVirtualConsole ( ) . sendTo ( console ) , userAgent : options . userAgent } ; if ( options . htmlroot ) { config . resourceLoader = function ( resource , callback ) { const src = resource . element . getAttribute ( 'src' ) ; if ( src . indexOf ( '/' ) === 0 ) { resource . url . pathname = path . join ( options . htmlroot , src ) ; } return resource . defaultFetch ( callback ) ; } ; } if ( options . inject ) { config . onload = function ( window ) { if ( typeof options . inject === 'function' ) { options . inject ( window ) ; } else { require ( path . join ( __dirname , options . inject ) ) ( window ) ; } } ; } return new Promise ( ( resolve , reject ) => { jsdom . env ( src , config , ( err , res ) => { if ( err ) { return reject ( err ) ; } return resolve ( res ) ; } ) ; } ) . then ( ( result ) => { return new Promise ( ( resolve ) => { setTimeout ( ( ) => resolve ( result ) , options . timeout ) ; } ) ; } ) ; }
3567	function ( callback , context ) { var self = this , values = self . _values ; context = context || self ; self . _keys . forEach ( function ( key , index , keys ) { callback . call ( context , values [ index ] , key , keys ) ; } ) ; return this ; }
1379	function toAwsParams ( file ) { var params = { } ; var headers = file . s3 . headers || { } ; for ( var header in headers ) { if ( header === 'x-amz-acl' ) { params . ACL = headers [ header ] ; } else if ( header === 'Content-MD5' ) { params . ContentMD5 = headers [ header ] ; } else { params [ pascalCase ( header ) ] = headers [ header ] ; } } params . Key = file . s3 . path ; params . Body = file . contents ; return params ; }
1999	function listener ( element , selector , type , callback ) { return function ( e ) { e . delegateTarget = closest_1 ( e . target , selector ) ; if ( e . delegateTarget ) { callback . call ( element , e ) ; } } }
1529	function CasStrategy ( options , verify ) { if ( typeof options == 'function' ) { verify = options ; options = undefined ; } options = options || { } ; if ( ! verify ) { throw new TypeError ( 'CasStrategy requires a verify callback' ) ; } if ( ! options . casURL ) { throw new TypeError ( 'CasStrategy requires a casURL option' ) ; } Strategy . call ( this ) ; this . name = 'cas' ; this . _verify = verify ; this . _passReqToCallback = options . passReqToCallback ; this . casBaseUrl = options . casURL ; this . casPgtUrl = options . pgtURL || undefined ; this . casPropertyMap = options . propertyMap || { } ; this . casSessionKey = options . sessionKey || 'cas' ; this . cas = new CAS ( { base_url : this . casBaseUrl , version : 2 , external_pgt_url : this . casPgtUrl , ssl_cert : options . sslCert , ssl_key : options . sslKey , ssl_ca : options . sslCA } ) ; }
2267	function ( object ) { var parts = [ ] ; for ( var param in object ) { if ( object . hasOwnProperty ( param ) ) { parts . push ( encodeURIComponent ( param ) + '=' + encodeURIComponent ( object [ param ] ) ) ; } } return parts . join ( '&' ) ; }
3780	function CloseCommand ( args , define ) { var parsed = new statements . ExpressionStatement ( args , define ) ; if ( ! ( parsed . child instanceof statements . PointerStatement ) ) throw new SyntaxError ( 'Expected pointer' ) ; this . pointer = parsed ; }
2003	function getAttributeValue ( suffix , element ) { var attribute = 'data-clipboard-' + suffix ; if ( ! element . hasAttribute ( attribute ) ) { return ; } return element . getAttribute ( attribute ) ; }
1098	function listenerForId ( id , timeout ) { return listenToIpc ( responseChannel ) . do ( ( [ x ] ) => d ( ` ${ x . id } ${ id } ${ JSON . stringify ( x ) } ` ) ) . filter ( ( [ receive ] ) => receive . id === id && id ) . take ( 1 ) . mergeMap ( ( [ receive ] ) => { if ( receive . error ) { let e = new Error ( receive . error . message ) ; e . stack = receive . error . stack ; return Observable . throw ( e ) ; } return Observable . of ( receive . result ) ; } ) . timeout ( timeout ) ; }
2310	function onmessage ( e ) { debug ( 'onmessage' ) ; if ( e . origin !== proxyOrigin ) { debug ( 'ignoring message... %o !== %o' , e . origin , proxyOrigin ) ; return ; } let { data } = e ; if ( ! data ) { return debug ( 'no `data`, bailing' ) ; } if ( data === 'ready' ) { onload ( ) ; return ; } if ( postStrings && 'string' === typeof data ) { data = JSON . parse ( data ) ; } if ( data . upload || data . download ) { return onprogress ( data ) ; } if ( ! data . length ) { return debug ( '`e.data` doesn\'t appear to be an Array, bailing...' ) ; } \' const id = data [ data . length - 1 ] ; if ( ! ( id in requests ) ) { return debug ( 'bailing, no matching request with callback: %o' , id ) ; } const xhr = requests [ id ] ; const { params } = xhr ; let body , statusCode , headers ; const { apiNamespace } = params ; body = data [ 0 ] ; statusCode = data [ 1 ] ; headers = data [ 2 ] ; if ( statusCode === 207 ) { } else { delete requests [ id ] ; } if ( ! params . metaAPI ) { debug ( 'got %o status code for URL: %o' , statusCode , params . path ) ; } else { statusCode = body === 'metaAPIupdated' ? 200 : 500 ; } if ( typeof headers === 'object' ) { headers . status = statusCode ; } }
3366	function ( ed ) { var self = this , testKey = PLUGIN_NAME + '_test' , testVal = "OK" ; self . key = PLUGIN_NAME + ed . id ; tinymce . each ( [ function ( ) { if ( localStorage ) { localStorage . setItem ( testKey , testVal ) ; if ( localStorage . getItem ( testKey ) === testVal ) { localStorage . removeItem ( testKey ) ; return localStorage ; } } } , function ( ) { if ( sessionStorage ) { sessionStorage . setItem ( testKey , testVal ) ; if ( sessionStorage . getItem ( testKey ) === testVal ) { sessionStorage . removeItem ( testKey ) ; return sessionStorage ; } } } , function ( ) { if ( tinymce . isIE ) { ed . getElement ( ) . style . behavior = "url('#default#userData')" ; return { autoExpires : TRUE , setItem : function ( key , value ) { var userDataElement = ed . getElement ( ) ; userDataElement . setAttribute ( key , value ) ; userDataElement . expires = self . getExpDate ( ) ; try { userDataElement . save ( "TinyMCE" ) ; } catch ( e ) { } } , getItem : function ( key ) { var userDataElement = ed . getElement ( ) ; try { userDataElement . load ( "TinyMCE" ) ; return userDataElement . getAttribute ( key ) ; } catch ( e ) { return null ; } } , removeItem : function ( key ) { ed . getElement ( ) . removeAttribute ( key ) ; } } ; } } , ] , function ( setup ) { try { self . storage = setup ( ) ; if ( self . storage ) return false ; } catch ( e ) { } } ) ; }
3019	function peekTokenNoLineTerminator ( ) { var t = peekToken ( ) ; var start = lastToken . location . end . offset ; var end = t . location . start . offset ; for ( var i = start ; i < end ; i ++ ) { var code = input . charCodeAt ( i ) ; if ( isLineTerminator ( code ) ) return null ; if ( code === 47 ) { code = input . charCodeAt ( ++ i ) ; if ( code === 47 ) return null ; i = input . indexOf ( '*/' , i ) + 2 ; } } return t ; }
734	function extend ( style , rule , sheet , newStyle = { } ) { mergeExtend ( style , rule , sheet , newStyle ) mergeRest ( style , rule , sheet , newStyle ) return newStyle }
1539	function collectDateArguments ( args , allowDuration ) { var obj , arr ; if ( isObject ( args [ 0 ] ) ) { return args ; } else if ( isNumber ( args [ 0 ] ) && ! isNumber ( args [ 1 ] ) ) { return [ args [ 0 ] ] ; } else if ( isString ( args [ 0 ] ) && allowDuration ) { return [ getDateParamsFromString ( args [ 0 ] ) , args [ 1 ] ] ; } obj = { } ; DateArgumentUnits . forEach ( function ( u , i ) { obj [ u . unit ] = args [ i ] ; } ) ; return [ obj ] ; }
1713	function _initTransferableAnimations ( item , prevItem , callback ) { var callbackCount = 0 ; function waitForAll ( ) { callbackCount -- ; if ( callbackCount === 0 ) { callback ( ) ; } } for ( var sourceId in item . options . transfer . items ) { if ( _initTransferableAnimation . call ( this , item , prevItem , sourceId , waitForAll ) ) { callbackCount ++ ; } } if ( ! callbackCount ) { callback ( ) ; } }
1097	function getSendMethod ( windowOrWebView ) { if ( ! windowOrWebView ) return ( ... a ) => ipc . send ( ... a ) ; if ( 'webContents' in windowOrWebView ) { return ( ... a ) => { d ( ` ${ JSON . stringify ( a ) } ` ) ; if ( ! windowOrWebView . webContents . isDestroyed ( ) ) { windowOrWebView . webContents . send ( ... a ) ; } else { throw new Error ( ` ` ) ; } } ; } else { return ( ... a ) => { d ( ` ${ JSON . stringify ( a ) } ` ) ; windowOrWebView . send ( ... a ) ; } ; } }
2120	function OktaAPI ( apiToken , domain , preview ) { if ( apiToken == undefined || domain == undefined ) { throw new Error ( "OktaAPI requires an API token and a domain" ) ; } this . domain = domain ; if ( preview == undefined ) this . preview = false ; else this . preview = preview ; this . request = new NetworkAbstraction ( apiToken , domain , preview ) ; this . users = new OktaAPIUsers ( apiToken , domain , preview ) ; this . groups = new OktaAPIGroups ( apiToken , domain , preview ) ; this . sessions = new OktaAPISessions ( apiToken , domain , preview ) ; this . apps = new OktaAPIApps ( apiToken , domain , preview ) ; this . events = new OktaAPIEvents ( apiToken , domain , preview ) ; }
2991	function bundleServer ( app , promises ) { var { themes , config } = app . locals ; _ . forEach ( themes , function ( val , theme ) { promises . push ( new Promise ( function ( resolve ) { readyBundle ( app , '' , theme , resolve , ( wpConfig , sitePath , appBundled , done ) => { if ( ! wpConfig ) return ; let conf = { output : { filename : ` ${ config . contentPath } ${ theme } ` } , entry : ` ${ themes [ appBundled ] . path } ${ themes [ appBundled ] . zealderConfig . serverRenderFile } ` } ; var webpackConfig = merge ( webpackServer , wpConfig , conf ) ; webpack ( webpackConfig , ( err , stats ) => { if ( err ) throw new Error ( err . stack || err ) ; const info = stats . toJson ( ) ; if ( stats . hasErrors ( ) ) app . error ( info . errors ) ; done ( ) ; } ) ; } ) ; } ) ) ; } ) ; }
747	function createSharingUrl ( network ) { return this . baseNetworks [ network ] . sharer . replace ( / @url / g , encodeURIComponent ( this . url ) ) . replace ( / @title / g , encodeURIComponent ( this . title ) ) . replace ( / @description / g , encodeURIComponent ( this . description ) ) . replace ( / @quote / g , encodeURIComponent ( this . quote ) ) . replace ( / @hashtags / g , this . generateHashtags ( network , this . hashtags ) ) . replace ( / @media / g , this . media ) . replace ( / @twitteruser / g , this . twitterUser ? '&via=' + this . twitterUser : '' ) ; }
1193	function ( sel , range ) { var ranges = sel . getAllRanges ( ) , removed = false ; sel . removeAllRanges ( ) ; for ( var i = 0 , len = ranges . length ; i < len ; ++ i ) { if ( removed || range !== ranges [ i ] ) { sel . addRange ( ranges [ i ] ) ; } else { removed = true ; } } if ( ! sel . rangeCount ) { updateEmptySelection ( sel ) ; } }
3502	function checkIndentInFunctionBlock ( node ) { var calleeNode = node . parent ; var indent ; if ( calleeNode . parent && ( calleeNode . parent . type === "Property" || calleeNode . parent . type === "ArrayExpression" ) ) { indent = getNodeIndent ( calleeNode , false , false ) ; } else { indent = getNodeIndent ( calleeNode ) ; } if ( calleeNode . parent . type === "CallExpression" ) { var calleeParent = calleeNode . parent ; if ( calleeNode . type !== "FunctionExpression" && calleeNode . type !== "ArrowFunctionExpression" ) { if ( calleeParent && calleeParent . loc . start . line < node . loc . start . line ) { indent = getNodeIndent ( calleeParent ) ; } } else { if ( isArgBeforeCalleeNodeMultiline ( calleeNode ) && calleeParent . callee . loc . start . line === calleeParent . callee . loc . end . line && ! isNodeFirstInLine ( calleeNode ) ) { indent = getNodeIndent ( calleeParent ) ; } } } indent += indentSize ; var parentVarNode = getVariableDeclaratorNode ( node ) ; if ( parentVarNode && isNodeInVarOnTop ( node , parentVarNode ) ) { indent += indentSize * options . VariableDeclarator [ parentVarNode . parent . kind ] ; } if ( node . body . length > 0 ) { checkNodesIndent ( node . body , indent ) ; } checkLastNodeLineIndent ( node , indent - indentSize ) ; }
2995	function sign ( input , algorithm , secret ) { const alg = algorithmMap [ algorithm ] if ( ! alg ) { throw new Error ( errorMap [ '002' ] . message ) } const type = typeMap [ algorithm ] let signature switch ( type ) { case 'hmac' : signature = hmacSign ( input , alg , secret ) break case 'sign' : signature = rsaSign ( input , alg , secret ) break default : signature = hmacSign ( input , alg , secret ) break } return signature }
562	function ( ) { var activeFaces = [ ] ; for ( var i = 0 ; i < this . faces . length ; i ++ ) { var face = this . faces [ i ] ; if ( face . mark === Visible ) { activeFaces . push ( face ) ; } } this . faces = activeFaces ; return this ; }
2575	function titleCase ( s ) { var arr = [ ] ; libs . object . each ( s . split ( ' ' ) , function ( t ) { arr . push ( libs . string . ucFirst ( t ) ) ; } ) ; return arr . join ( ' ' ) ; }
1660	function bootstrap ( ) { var server = RPC . apply ( null , arguments ) var io = server . io var allQueries = [ ] Object . keys ( models ) . forEach ( function ( modelName ) { var model = models [ modelName ] model . _exposeCallback ( server ) } ) io . use ( function ( socket , next ) { const registeredLQs = { } socket . moonridge = { registeredLQs : registeredLQs , user : { privilege_level : 0 } } socket . on ( 'disconnect' , function ( ) { debug ( socket . id , ' socket disconnected, cleaning up LQ listeners' ) for ( var LQId in registeredLQs ) { var LQ = registeredLQs [ LQId ] LQ . removeListener ( socket ) } } ) next ( ) } ) server . expose ( { MR : { getModels : function ( ) { return Object . keys ( models ) } , deAuthorize : function ( ) { this . moonridge . user = { privilege_level : 0 } } } } ) if ( process . env . MOONRIDGE_HEALTH === '1' ) { server . expose ( { MR : { getHealth : function ( ) { var allModels = { } var index = allQueries . length while ( index -- ) { var modelQueriesForSerialization = { } var model = allQueries [ index ] for ( var LQ in model . queries ) { modelQueriesForSerialization [ LQ ] = Object . keys ( model . queries [ LQ ] . listeners ) . length } allModels [ model . modelName ] = modelQueriesForSerialization } return { pid : process . pid , memory : process . memoryUsage ( ) , uptime : process . uptime ( ) , liveQueries : allModels } } } } ) } return server }
3325	function CliView ( cli , env ) { cli . cliView = this ; this . cli = cli ; this . doc = document ; this . win = dom . getParentWindow ( this . doc ) ; this . env = env ; this . element = this . doc . getElementById ( 'cockpitInput' ) ; if ( ! this . element ) { return ; } this . settings = env . settings ; this . hintDirection = this . settings . getSetting ( 'hintDirection' ) ; this . outputDirection = this . settings . getSetting ( 'outputDirection' ) ; this . outputHeight = this . settings . getSetting ( 'outputHeight' ) ; this . isUpdating = false ; this . createElements ( ) ; this . update ( ) ; }
919	function addDataChangeWatcher ( ctx , prop , deep ) { let handlerName = getInnerWatcher ( prop ) ; watchDataChange . call ( ctx , prop , handlerName , { deep } ) ; }
2252	function clearLine ( ) { if ( process . stdout . clearLine ) { process . stdout . clearLine ( ) ; process . stdout . cursorTo ( 0 ) ; } else { var str = '\r' , \r ; i = 0 for ( i = 0 ; i < lastLineLength ; i ++ ) { str += ' ' ; } } process . stdout . write ( str ) ; lastLineLength = 0 ; }
1074	function getRawHeader ( _block ) { if ( typeof _block . difficulty !== 'string' ) { _block . difficulty = '0x' + _block . difficulty . toString ( 16 ) } const block = new EthereumBlock ( _block ) return block . header }
2192	function PartialHull ( a , b , idx , lowerIds , upperIds ) { this . a = a this . b = b this . idx = idx this . lowerIds = lowerIds this . upperIds = upperIds }
3132	function ( data , force_absolute ) { var self = this , editor = self . editor , baseUri = editor . documentBaseURI , sources , attrs , img , i ; data . params . src = self . convertUrl ( data . params . src , force_absolute ) ; attrs = data . video . attrs ; if ( attrs ) attrs . src = self . convertUrl ( attrs . src , force_absolute ) ; if ( attrs ) attrs . poster = self . convertUrl ( attrs . poster , force_absolute ) ; sources = toArray ( data . video . sources ) ; if ( sources ) { for ( i = 0 ; i < sources . length ; i ++ ) sources [ i ] . src = self . convertUrl ( sources [ i ] . src , force_absolute ) ; } img = self . editor . dom . create ( 'img' , { id : data . id , style : data . style , align : data . align , hspace : data . hspace , vspace : data . vspace , src : self . editor . theme . url + '/img/trans.gif' , 'class' : 'mceItemMedia mceItem' + self . getType ( data . type ) . name , 'data-mce-json' : JSON . serialize ( data , "'" ) } ) ; img . width = data . width = normalizeSize ( data . width || ( data . type == 'audio' ? "300" : "320" ) ) ; img . height = data . height = normalizeSize ( data . height || ( data . type == 'audio' ? "32" : "240" ) ) ; return img ; }
646	function getAnalyzerTitle ( ) { var title = this . data . title ; if ( isEmpty ( title ) ) { title = this . opts . defaultValue . title ; } if ( this . hasPluggable ( ) ) { title = this . refObj . pluggable . _applyModifications ( "data_page_title" , title ) ; } return stripSpaces ( title ) ; }
764	function GrantManager ( config ) { this . realmUrl = config . realmUrl ; this . clientId = config . clientId ; this . secret = config . secret ; this . publicKey = config . publicKey ; this . public = config . public ; this . bearerOnly = config . bearerOnly ; this . notBefore = 0 ; this . rotation = new Rotation ( config ) ; }
2293	function serializeState ( ) { var data = model . data , scale = model . scale , translate = model . translate ; model . state = { nodes : data . nodes . map ( function ( node ) { return { type : node . type , property : node . property , fixed : node . fixed , x : Math . round ( node . x ) , y : Math . round ( node . y ) } ; } ) , links : data . links . map ( function ( link ) { return { source : link . source . index , target : link . target . index } ; } ) , scale : scale , translate : translate } ; }
2715	function registerXDiv ( ) { var xProto = Object . create ( HTMLElement . prototype ) ; xProto . attachedCallback = function ( ) { var scriptEl = document . createElement ( 'script' ) ; if ( ! this . dataset . controller ) { console . error ( 'No controller specified for x-div.' ) ; return ; } scriptEl . src = getControllerSrc ( this . dataset . controller ) ; scriptEl . async = true ; this . appendChild ( scriptEl ) ; } ; document . registerElement ( 'x-div' , { prototype : xProto } ) ; }
3272	function ( ) { if ( ! this . highlight || ! this . items ) { return ; } var me = this , items = me . items , len = items . length , opts = Ext . merge ( { } , me . highlightCfg , me . highlight ) , animate = me . chart . animate , i = 0 , obj , p , sprite ; for ( ; i < len ; i ++ ) { if ( ! items [ i ] ) { continue ; } sprite = items [ i ] . sprite ; if ( sprite && sprite . _highlighted ) { if ( sprite . _anim ) { sprite . _anim . paused = true ; } obj = { } ; for ( p in opts ) { if ( Ext . isObject ( sprite . _defaults [ p ] ) ) { obj [ p ] = Ext . apply ( { } , sprite . _defaults [ p ] ) ; } else { obj [ p ] = sprite . _defaults [ p ] ; } } if ( animate ) { sprite . _endStyle = obj ; sprite . _anim = new Ext . fx . Anim ( { target : sprite , to : obj , duration : 150 } ) ; } else { sprite . setAttributes ( obj , true ) ; } delete sprite . _highlighted ; } } }
858	function parse ( option ) { if ( ! option || ! option . convertPath || typeof option . convertPath !== "object" ) { return null } const converters = [ ] for ( const pattern of normalizeValue ( option . convertPath ) ) { const include = toStringArray ( pattern . include ) const exclude = toStringArray ( pattern . exclude ) const fromRegexp = new RegExp ( String ( pattern . replace [ 0 ] ) ) const toStr = String ( pattern . replace [ 1 ] ) converters . push ( { match : createMatch ( include , exclude ) , convert : defineConvert ( fromRegexp , toStr ) , } ) } return combine ( converters ) }
1664	function ( buildDone ) { if ( assemble . options . pages ) { _ . forOwn ( assemble . options . pages , function ( fileInfo , filename ) { if ( ! filename || filename . length === 0 ) { grunt . warn ( 'Pages need a filename.' ) ; buildDone ( ) ; return false ; } if ( ! buildPage ( filename , fileInfo ) ) { buildDone ( ) ; return false ; } } ) ; } buildDone ( ) ; }
3424	function ( ) { var me = this , cfg = { app : me , startConfig : me . getStartConfig ( ) } ; Ext . apply ( cfg , me . taskbarConfig ) ; return cfg ; }
918	function proxyDataGetter ( ctx , prop ) { let proxyProps = ctx . __proxyProps ; proxyProps || ( proxyProps = ctx . __proxyProps = { } ) ; if ( proxyProps [ prop ] ) { return ; } proxyProps [ prop ] = true ; let descriptor = Object . getOwnPropertyDescriptor ( ctx , prop ) ; if ( descriptor && descriptor . configurable ) { let newDescriptor = Object . assign ( { } , descriptor , { get ( ) { ctx . __deps && ctx . __deps . push ( prop ) ; return descriptor . get && descriptor . get . call ( ctx ) ; } } ) ; Object . defineProperty ( ctx , prop , newDescriptor ) ; } else { console . warn ( 'cannot configure the data prop descriptor info:' , prop ) ; } }
1408	function WritableStreamDefaultWriterAbort ( writer , reason ) { const stream = writer . _ownerWritableStream ; assert ( stream !== undefined ) ; return WritableStreamAbort ( stream , reason ) ; }
3702	function getDateDifference ( timestr1 , timestr2 ) { var start = timestr1 . toLocaleDateString ? timestr1 : new Date ( timestr1 ) ; var end = timestr2 . toLocaleDateString ? timestr2 : new Date ( timestr2 ) ; if ( start . toString ( ) === 'Invalid Date' || end . toString ( ) === 'Invalid Date' ) { throw new TypeError ( 'pendel.date() expects two valid date strings' ) ; } var dr = moment . range ( start , end ) ; return { years : dr . diff ( 'years' ) , months : dr . diff ( 'months' ) , weeks : dr . diff ( 'weeks' ) , days : dr . diff ( 'days' ) , hours : dr . diff ( 'hours' ) , minutes : dr . diff ( 'minutes' ) , seconds : dr . diff ( 'seconds' ) } ; }
2344	function doReadDatasetClient ( datasetClientId , cb ) { debug ( 'doReadDatasetClient datasetClientId = %s' , datasetClientId ) ; var col = mongoClient . collection ( DATASETCLIENTS_COLLECTION ) ; col . findOne ( { id : datasetClientId } , function ( err , datasetClient ) { if ( err ) { debugError ( 'Failed to read datasetClient due to error %s :: datasetClientId = %s' , err , datasetClientId ) ; } return cb ( err , datasetClient ) ; } ) ; }
1701	function _snapToPage ( ) { if ( ! this . options . paginated || this . _scroll . scrollForceCount || ( this . _scroll . springPosition !== undefined ) ) { return ; } var item ; switch ( this . options . paginationMode ) { case PaginationMode . SCROLL : if ( ! this . options . paginationEnergyThreshold || ( Math . abs ( this . _scroll . particle . getEnergy ( ) ) <= this . options . paginationEnergyThreshold ) ) { item = this . options . alignment ? this . getLastVisibleItem ( ) : this . getFirstVisibleItem ( ) ; if ( item && item . renderNode ) { this . goToRenderNode ( item . renderNode ) ; } } break ; case PaginationMode . PAGE : item = this . options . alignment ? this . getLastVisibleItem ( ) : this . getFirstVisibleItem ( ) ; if ( item && item . renderNode ) { this . goToRenderNode ( item . renderNode ) ; } break ; } }
76	function stripHTML ( source ) { var fragment = document . createDocumentFragment ( ) ; var element = document . createElement ( 'div' ) ; fragment . appendChild ( element ) ; element . innerHTML = source ; return fragment . firstChild . innerText ; }
3665	function ( criteria , cb ) { var self = this ; this . first ( criteria , function ( err , entity ) { if ( err ) { return cb ( err ) ; } if ( entity ) { cb ( null , entity ) ; } else { self . create ( criteria , cb ) ; } } ) ; }
1869	function ( source ) { var pos = 0 ; return _ . map ( this . lex ( source ) , function ( token ) { if ( token . type == 'line' ) { token . value = getNewline ( source , pos ) ; } return { type : token . type , start : pos , end : ( pos += token . value . length ) } ; } ) ; }
1197	function ( iframe ) { if ( ! wysihtml5 . dom . contains ( doc . documentElement , iframe ) ) { return ; } var that = this , iframeWindow = iframe . contentWindow , iframeDocument = iframe . contentWindow . document , charset = doc . characterSet || doc . charset || "utf-8" , sandboxHtml = this . _getHtml ( { charset : charset , stylesheets : this . config . stylesheets } ) ; iframeDocument . open ( "text/html" , "replace" ) ; iframeDocument . write ( sandboxHtml ) ; iframeDocument . close ( ) ; this . getWindow = function ( ) { return iframe . contentWindow ; } ; this . getDocument = function ( ) { return iframe . contentWindow . document ; } ; iframeWindow . onerror = function ( errorMessage , fileName , lineNumber ) { throw new Error ( "wysihtml5.Sandbox: " + errorMessage , fileName , lineNumber ) ; } ; if ( ! wysihtml5 . browser . supportsSandboxedIframes ( ) ) { var i , length ; for ( i = 0 , length = windowProperties . length ; i < length ; i ++ ) { this . _unset ( iframeWindow , windowProperties [ i ] ) ; } for ( i = 0 , length = windowProperties2 . length ; i < length ; i ++ ) { this . _unset ( iframeWindow , windowProperties2 [ i ] , wysihtml5 . EMPTY_FUNCTION ) ; } for ( i = 0 , length = documentProperties . length ; i < length ; i ++ ) { this . _unset ( iframeDocument , documentProperties [ i ] ) ; } this . _unset ( iframeDocument , "cookie" , "" , true ) ; } this . loaded = true ; setTimeout ( function ( ) { that . callback ( that ) ; } , 0 ) ; }
2152	function urlsAreSameOrigin ( url1 , url2 ) { url1 = urlResolve ( url1 ) ; url2 = urlResolve ( url2 ) ; return ( url1 . protocol === url2 . protocol && url1 . host === url2 . host ) ; }
2130	function constructAppGroupModel ( id , lastUpdated , priority , links ) { var model = { } ; if ( id ) model . id = id ; if ( lastUpdated ) model . lastUpdated = lastUpdated ; if ( priority ) model . priority = priority ; if ( links ) model . links = links ; return model ; }
3417	function ( isChecked ) { var view = this . views [ 0 ] , headerCt = view . headerCt , checkHd = headerCt . child ( 'gridcolumn[isCheckerHd]' ) , cls = this . checkerOnCls ; if ( checkHd ) { if ( isChecked ) { checkHd . addCls ( cls ) ; } else { checkHd . removeCls ( cls ) ; } } }
1737	function authVectorTileLoader ( fetchOptions ) { return function ( tile , url ) { const loader = ( ) => { fetch ( url , fetchOptions ) . then ( r => r . arrayBuffer ( ) ) . then ( ( source ) => { const format = tile . getFormat ( ) ; tile . setProjection ( format . readProjection ( source ) ) ; tile . setFeatures ( format . readFeatures ( source ) ) ; tile . setExtent ( format . getLastExtent ( ) ) ; } ) . catch ( ( err ) => { tile . onError ( ) ; } ) ; } ; tile . setLoader ( loader ) ; } ; }
128	function load ( ) { var _this2 = this ; if ( ! this . enabled ) { return ; } if ( ! is$1 . object ( window . google ) || ! is$1 . object ( window . google . ima ) ) { loadScript ( this . player . config . urls . googleIMA . sdk ) . then ( function ( ) { _this2 . ready ( ) ; } ) . catch ( function ( ) { _this2 . trigger ( 'error' , new Error ( 'Google IMA SDK failed to load' ) ) ; } ) ; } else { this . ready ( ) ; } }
3043	function setCursorPositionToOriginalLi ( li ) { var list = ed . dom . getParent ( li , 'ol,ul' ) ; if ( list != null ) { var lastLi = list . lastChild ; ed . selection . setCursorLocation ( lastLi , 0 ) ; } }
2122	function change ( evt ) { evt = evt || win . event ; if ( 'readystatechange' === evt . type ) { readystate . change ( docReadyState ( ) ) ; if ( complete !== docReadyState ( ) ) return ; } if ( 'load' === evt . type ) readystate . change ( 'complete' ) ; else readystate . change ( 'interactive' ) ; ( evt . type === 'load' ? win : doc ) [ off ] ( evt . type , change , false ) ; }
2113	function koaConnect ( connectMiddleware ) { const handler = connectMiddleware . length < 3 ? noCallbackHandler : withCallbackHandler return function koaConnect ( ctx , next ) { return handler ( ctx , connectMiddleware , next ) } }
3268	function stripNegate ( val , negate ) { negate = escape ( negate || constants_1 . NEGATE_CHAR ) ; var exp = new RegExp ( '^' + negate ) ; return val . replace ( exp , '' ) ; }
1200	function ( textNodes , range ) { var firstNode = textNodes [ 0 ] , lastNode = textNodes [ textNodes . length - 1 ] ; var merges = [ ] , currentMerge ; var rangeStartNode = firstNode , rangeEndNode = lastNode ; var rangeStartOffset = 0 , rangeEndOffset = lastNode . length ; var textNode , precedingTextNode ; for ( var i = 0 , len = textNodes . length ; i < len ; ++ i ) { textNode = textNodes [ i ] ; precedingTextNode = this . getAdjacentMergeableTextNode ( textNode . parentNode , false ) ; if ( precedingTextNode ) { if ( ! currentMerge ) { currentMerge = new Merge ( precedingTextNode ) ; merges . push ( currentMerge ) ; } currentMerge . textNodes . push ( textNode ) ; if ( textNode === firstNode ) { rangeStartNode = currentMerge . firstTextNode ; rangeStartOffset = rangeStartNode . length ; } if ( textNode === lastNode ) { rangeEndNode = currentMerge . firstTextNode ; rangeEndOffset = currentMerge . getLength ( ) ; } } else { currentMerge = null ; } } var nextTextNode = this . getAdjacentMergeableTextNode ( lastNode . parentNode , true ) ; if ( nextTextNode ) { if ( ! currentMerge ) { currentMerge = new Merge ( lastNode ) ; merges . push ( currentMerge ) ; } currentMerge . textNodes . push ( nextTextNode ) ; } if ( merges . length ) { for ( i = 0 , len = merges . length ; i < len ; ++ i ) { merges [ i ] . doMerge ( ) ; } range . setStart ( rangeStartNode , rangeStartOffset ) ; range . setEnd ( rangeEndNode , rangeEndOffset ) ; } }
2868	function ( options , params ) { var qpsApi = qps ( options ) ; var task = new Task ( ) ; Rx . Observable . from ( qpsApi . ticket . post ( params ) ) . catch ( ( err ) => { if ( err . match ( / ^Specified targetId .* was unknown$ / ) ) { task . running ( 'warning' , ` ${ params . TargetId } ` ) ; delete params . TargetId ; return Rx . Observable . from ( module . exports . getTicket ( options , params ) ) ; } else { return Rx . Observable . throw ( new Error ( err ) ) ; } } ) . subscribe ( task ) ; if ( returnObservable ) { return task ; } else { return task . toPromise ( extPromise ) ; } }
685	function ( kb , x , displayables ) { var t = kb . findTypeURIs ( subject ) for ( var k = 0 ; k < displayables . length ; k ++ ) { if ( $rdf . Util . mediaTypeClass ( displayables [ k ] ) . uri in t ) { return true } } return false }
1465	function ( filename , cb ) { var t = this ; var lines = [ ] ; function write ( key , value ) { if ( value === undefined || value === null ) { return ; } value = value . replace ( / \t / g , "\\t" ) . \\ replace . ( / \r / g , "\\r" ) \\ . replace ( / \n / g , "\\n" ) ; \\ } replace ( / " / g , "\\\"" ) \\ }
3005	function doBegin ( n ) { if ( n !== 'html' && ! option . fragment ) { if ( n === 'div' && option . adsafe ) { error ( "ADSAFE: Use the fragment option." ) ; } else { error ( "Expected '{a}' and instead saw '{b}'." , token , 'html' , n ) ; } } if ( option . adsafe ) { if ( n === 'html' ) { error ( "Currently, ADsafe does not operate on whole HTML documents. It operates on <div> fragments and .js files." , token ) ; } if ( option . fragment ) { if ( n !== 'div' ) { error ( "ADsafe violation: Wrap the widget in a div." , token ) ; } } else { error ( "Use the fragment option." , token ) ; } } option . browser = true ; assume ( ) ; }
441	function getMaxFromProps ( props , axis ) { if ( isPlainObject ( props . maxDomain ) && props . maxDomain [ axis ] !== undefined ) { return props . maxDomain [ axis ] ; } return typeof props . maxDomain === "number" ? props . maxDomain : undefined ; }
1890	function createMatcher ( text ) { var memo = { } , m ; return { open : function ( i ) { var m = this . matches ( i ) ; return m && m . type == 'open' ? m : null ; } , close : function ( i ) { var m = this . matches ( i ) ; return m && m . type == 'close' ? m : null ; } , matches : function ( i ) { var key = 'p' + i ; if ( ! ( key in memo ) ) { if ( text . charAt ( i ) == '<' ) { var substr = text . slice ( i ) ; if ( m = substr . match ( reOpenTag ) ) { memo [ key ] = openTag ( i , m ) ; } else if ( m = substr . match ( reCloseTag ) ) { memo [ key ] = closeTag ( i , m ) ; } else { memo [ key ] = false ; } } } return memo [ key ] ; } , text : function ( ) { return text ; } } ; }
329	function scale ( scaleX ) { var scaleY = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : scaleX ; var imageData = this . imageData ; var transformed = false ; scaleX = Number ( scaleX ) ; scaleY = Number ( scaleY ) ; if ( this . ready && ! this . disabled && this . options . scalable ) { if ( isNumber ( scaleX ) ) { imageData . scaleX = scaleX ; transformed = true ; } if ( isNumber ( scaleY ) ) { imageData . scaleY = scaleY ; transformed = true ; } if ( transformed ) { this . renderCanvas ( true , true ) ; } } return this ; }
1494	function ( name ) { return new Promise ( ( resolve , reject ) => { rimraf ( name , err => { if ( err ) { reject ( err ) ; } else { resolve ( ) ; } } ) ; } ) ; }
817	function request_script ( chain_opts , script_obj , registry_item , onload , preload_this_script ) { setTimeout ( function ( ) { var script , src = script_obj . real_src , xhr ; if ( "item" in append_to ) { if ( ! append_to [ 0 ] ) { setTimeout ( arguments . callee , 25 ) ; return ; } append_to = append_to [ 0 ] ; } script = document . createElement ( "script" ) ; if ( script_obj . type ) script . type = script_obj . type ; if ( script_obj . charset ) script . charset = script_obj . charset ; if ( script_obj . crossOrigin ) script . crossOrigin = script_obj . crossOrigin ; if ( preload_this_script ) { if ( real_preloading ) { if ( chain_opts [ _Debug ] ) log_msg ( "start script preload: " + src ) ; registry_item . elem = script ; if ( explicit_preloading ) { script . preload = true ; script . onpreload = onload ; } else { script . onreadystatechange = function ( ) { if ( script . readyState == "loaded" ) onload ( ) ; } ; } script . src = src ; } else if ( chain_opts [ _UseCORSXHR ] || ( src . indexOf ( root_domain ) == 0 && chain_opts [ _UseLocalXHR ] ) ) { xhr = new XMLHttpRequest ( ) ; if ( chain_opts [ _Debug ] ) log_msg ( "start script preload (xhr): " + src ) ; xhr . onreadystatechange = function ( ) { if ( xhr . readyState == 4 ) { xhr . onreadystatechange = function ( ) { } ; registry_item . text = xhr . responseText + "\n//@ sourceURL=" + \n ; src } } ; onload ( ) ; xhr . open ( "GET" , src ) ; } else xhr . send ( ) ; } else { if ( chain_opts [ _Debug ] ) log_msg ( "start script preload (cache): " + src ) ; script . type = "text/cache-script" ; create_script_load_listener ( script , registry_item , "ready" , function ( ) { append_to . removeChild ( script ) ; onload ( ) ; } ) ; script . src = src ; append_to . insertBefore ( script , append_to . firstChild ) ; } } , if ( script_ordered_async ) { if ( chain_opts [ _Debug ] ) log_msg ( "start script load (ordered async): " + src ) ; script . async = false ; create_script_load_listener ( script , registry_item , "finished" , onload ) ; script . src = src ; append_to . insertBefore ( script , append_to . firstChild ) ; } else { if ( chain_opts [ _Debug ] ) log_msg ( "start script load: " + src ) ; create_script_load_listener ( script , registry_item , "finished" , onload ) ; script . src = src ; append_to . insertBefore ( script , append_to . firstChild ) ; } ) ; }
1861	function ( ) { var utils = require ( 'utils' ) ; var start = this . start ; var end = this . end ; var content = this . content ; var node = this ; _ . each ( outputProcessors , function ( fn ) { start = fn ( start , node , 'start' ) ; content = fn ( content , node , 'content' ) ; end = fn ( end , node , 'end' ) ; } ) ; var innerContent = _ . map ( this . children , function ( child ) { return child . toString ( ) ; } ) . join ( '' ) ; content = require ( 'abbreviationUtils' ) . insertChildContent ( content , innerContent , { keepVariable : false } ) ; return start + utils . padString ( content , this . padding ) + end ; }
470	function isObject ( obj ) { return Object ( obj ) === obj && String ( obj ) === '[object Object]' && ! isFunction ( obj ) && ! isArray ( obj ) ; }
2072	function _loadProcessor ( processorName ) { const compatibleVersion = compatibleProcessors [ processorName ] if ( compatibleVersion === undefined ) { const error = new Error ( ` ${ processorName } ` ) error . code = 'MODULE_NOT_SUPPORTED' throw error } return require ( ` ${ processorName } ` ) ( _loadModule ( processorName ) ) }
1886	function ( editor ) { var content = String ( editor . getContent ( ) ) ; var caretPos = editor . getCaretPos ( ) ; var tree = require ( 'xmlEditTree' ) . parseFromPosition ( content , caretPos , true ) ; if ( tree ) { var attr = tree . itemFromPosition ( caretPos , true ) ; return attr && attr . name ( ) . toLowerCase ( ) == 'style' && attr . valueRange ( true ) . cmp ( caretPos , 'lte' , 'gte' ) ; } return false ; }
923	function compile ( file , options ) { let obj = json5 . parse ( file . content . toString ( ) ) ; let result = JSON . stringify ( obj , null , 4 ) ; return { content : result } ; }
3587	function ( file ) { var xml = file . contents ; var xmlDoc = libxmljs . parseXml ( xml ) ; var rootNode = xmlDoc . root ( ) ; var resourceObject = { } ; var valueNodes = rootNode . find ( "data" ) ; valueNodes . forEach ( function ( element ) { var name = element . attr ( "name" ) . value ( ) ; var value = element . get ( "value" ) . text ( ) ; resourceObject [ name ] = value ; } ) ; return JSON . stringify ( resourceObject ) ; }
3106	function domGen ( tagName ) { return ( opts , ... args ) => { if ( ! seemLikePlainObject ( opts ) ) { args . unshift ( opts ) opts = undefined } return $ ( '<' + tagName + '/>' , opts ) . append ( ... [ ] . concat ( ... args ) ) } }
2321	function getOptions ( ) { var argv = yargs . usage ( "Usage: $0 [options] config_file" ) . example ( "$0 config.json" , "Start clyde reading configuration from 'config.json' file." ) . example ( "$0 --log debug config.json" , "Start clyde with log messages on 'debug' level and reading configuration from 'config.json' file." ) . describe ( "logfile" , "Path to the log file. Default 'clyde.log'." ) . nargs ( "logfile" , 1 ) . describe ( "loglevel" , "Level used for clyde log messages. Default 'info'." ) . nargs ( "loglevel" , 1 ) . describe ( "port" , "Port where clyde will listen. Default 8080." ) . nargs ( "port" , 1 ) . help ( "help" ) . demand ( 1 , "A configuration file must be specified" ) . showHelpOnFail ( false , "Specify --help for available options" ) . argv ; var options = require ( path . join ( process . cwd ( ) , argv . _ [ 0 ] ) ) ; options . logfile = argv . logfile || options . logfile || "clyde.log" ; options . loglevel = argv . loglevel || options . loglevel || "info" ; options . port = argv . port || options . port || 8000 ; return options ; }
3012	function getFiles ( dir , pattern , fn ) { if ( "function" === typeof pattern ) { fn = pattern ; pattern = undefined ; } pattern = pattern || / .* / ig ; fs . readdir ( dir , function ( err , files ) { if ( err ) return fn && fn ( err ) ; async . map ( files , function ( f , cb ) { fs . stat ( path . join ( dir , f ) , function ( err , stats ) { if ( err ) return cb && cb ( err ) ; cb && cb ( null , { filename : f , stats : stats } ) } ) } , function ( err , stats ) { if ( err ) return fn && fn ( err ) ; var fstats = stats . filter ( function ( f ) { return f . stats . isFile ( ) && pattern . test ( f . filename ) ; } ) ; fn && fn ( null , fstats ) ; } ) ; } ) ; }
2209	function validateForEach ( inlineValues , values , array ) { if ( "_foreach" in inlineValues ) { var match ; if ( match = forEachRegex . exec ( inlineValues [ "_foreach" ] ) ) { var object = { keyName : match [ 2 ] , valueName : match [ 3 ] , values : values [ match [ 1 ] ] } ; return object ; } var set = inlineValues [ "_foreach" ] . split ( ":" ) ; delete inlineValues [ "_foreach" ] ; getArrayValues ( set . slice ( 1 ) . join ( ":" ) , values ) . forEach ( function ( value ) { array . push ( value ) ; } ) ; return set [ 0 ] ; } return null ; }
2729	function configure ( { useGlobal = true , disable = [ ] , namespaces = { } , tags = { } , verbose = false } = { } , override = false ) { const config = Object . create ( null ) ; config . useGlobal = ! ! useGlobal ; config . disable = normalizeArray ( disable ) . map ( v => v + '' ) ; config . namespaces = namespaces ; config . tags = { disable : normalizeArray ( get ( tags , 'disable' , [ ] ) ) } ; config . verbose = verbose ; configRegistry = override ? config : deepmerge ( configRegistry , config , deepMergeOptions ) ; }
187	function listsRequest ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST : case WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST_FAILURE : return WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST === type ; } return state ; }
3540	function ( rootPath ) { this . plugins = { } ; this . mainTree = { } ; this . groups = { } ; this . resolved = false ; if ( rootPath ) { if ( typeof rootPath !== 'string' ) { throw new Error ( 'Invalid rootPath parameter creating tree' ) ; } this . rootPath = rootPath ; } else { this . rootPath = '.' ; } }
2083	function PluginManager ( we ) { this . we = we ; projectPath = we . projectPath ; this . nodeModulesPath = path . resolve ( projectPath , 'node_modules' ) ; this . configs = we . configs ; this . plugins = { } ; this . pluginNames = this . getPluginsList ( ) ; this . pluginFiles = { } ; this . pluginPaths = [ ] ; this . records = [ ] ; this . pluginsToInstall = { } ; }
2231	function getSignerClass ( ) { var version ; if ( this . config . signatureVersion ) { version = this . config . signatureVersion ; } else { version = this . api . signatureVersion ; } return AWS . Signers . RequestSigner . getVersion ( version ) ; }
2947	function loadModels ( app , datasource , src , cb = null ) { const ds = app . dataSources [ datasource ] ; let promises = [ ] , modelsNames = [ ] ; let files = fs . readdirSync ( src ) ; if ( files ) { files . forEach ( file => { if ( file . endsWith ( '.json' ) ) { promises . push ( new Promise ( ( resolve , reject ) => { fs . readFile ( ` ${ src } ${ file } ` , 'utf8' , ( fileErr , data ) => { if ( fileErr ) app . error ( ` ` , file , fileErr ) ; else { let mJson = JSON . parse ( data ) ; let model = loopback . createModel ( mJson ) ; app . model ( model , { dataSource : datasource } ) ; modelsNames . push ( mJson . name ) ; resolve ( ) ; } } ) ; } ) ) ; } } ) ; } Promise . all ( promises ) . then ( ( ) => { if ( files ) { files . forEach ( file => { if ( file . endsWith ( '.js' ) ) { require ( ` ${ src } ${ file } ` ) ( app ) ; } } ) ; if ( 'development' === process . env . NODE_ENV && ! _ . isEmpty ( modelsNames ) ) { ds . autoupdate ( modelsNames ) ; } } if ( cb ) cb ( ) ; } ) ; }
294	function isPlainObject ( value ) { if ( ! isObject ( value ) ) { return false ; } try { var _constructor = value . constructor ; var prototype = _constructor . prototype ; return _constructor && prototype && hasOwnProperty . call ( prototype , 'isPrototypeOf' ) ; } catch ( error ) { return false ; } }
1512	function ( arg ) { var value = arg . value ; var flag = arg . flag ; var result = null ; if ( value ) { value = Array . isArray ( value ) ? value : [ value ] ; result = [ ] ; value . forEach ( function ( path ) { result . push ( flag ) ; result . push ( path ) ; } ) ; } return result ; }
3667	function define ( Class , constructor , type ) { if ( ! client ) { throw new Error ( 'Usergrid not configured' ) ; } if ( typeof Class === 'function' ) { type = constructor ; constructor = Class ; Class = { } ; } Class . _usergrid = { constructor : constructor , type : ( type ) ? type : constructor . name . toLowerCase ( ) } ; _ . mixin ( Class , usergridStatics ( client ) ) ; return Class ; }
1233	function toRegExp ( str ) { if ( str instanceof RegExp ) return str ; str = escape ( str ) ; str = str . replace ( / \\\* / g , '(.+)' ) ; return new RegExp ( '^' + str + '$' ) ; }
1717	function _startShowAnimation ( item , spec ) { if ( ! item . halted ) { var callback = item . showCallback ; if ( spec . transform ) { item . mod . setTransform ( Transform . identity , item . options . show . transition , callback ) ; callback = undefined ; } if ( spec . opacity !== undefined ) { item . mod . setOpacity ( 1 , item . options . show . transition , callback ) ; callback = undefined ; } _startTransferableAnimations . call ( this , item , callback ) ; } }
2878	function ( options , cb ) { if ( ! options . sassDir ) { grunt . log . error ( 'compass-multiple needs sassDir for searching scss files.' ) ; cb ( false ) ; } if ( options . sassFiles ) { var pathes = options . sassFiles ; var pathesCount = pathes . length ; var currentCount = 0 ; var files = [ ] ; for ( var i = 0 ; i < pathes . length ; i ++ ) { glob ( pathes [ i ] , function ( error , tmpFiles ) { if ( error ) { console . log ( 'error: ' , error ) ; cb ( false ) ; } files = files . concat ( tmpFiles ) ; currentCount ++ ; if ( pathesCount === currentCount ) { grunt . log . writeln ( 'pathes: ' , files ) ; compileFiles ( options , files , cb ) ; } } ) ; } } else { var searchPath = options . sassDir + '/**/*.scss' ; glob ( searchPath , function ( error , files ) { if ( error ) { console . log ( 'error: ' , error ) ; cb ( false ) ; } compileFiles ( options , files , cb ) ; } ) ; } }
3499	function checkLastNodeLineIndent ( node , lastLineIndent ) { var lastToken = context . getLastToken ( node ) ; var endIndent = getNodeIndent ( lastToken , true ) ; if ( endIndent !== lastLineIndent && isNodeFirstInLine ( node , true ) ) { report ( node , lastLineIndent , endIndent , { line : lastToken . loc . start . line , column : lastToken . loc . start . column } , true ) ; } }
380	function nodeWalk ( node , predicate , getChildNodes ) { if ( getChildNodes === void 0 ) { getChildNodes = module . exports . defaultChildNodes ; } if ( predicate ( node ) ) { return node ; } var match = null ; var childNodes = getChildNodes ( node ) ; if ( childNodes ) { for ( var i = 0 ; i < childNodes . length ; i ++ ) { match = nodeWalk ( childNodes [ i ] , predicate , getChildNodes ) ; if ( match ) { break ; } } } return match ; }
2725	function sendMessage ( id , level , fallbackToLog , ... rest ) { const levelMethod = level . toLowerCase ( ) ; const options = buildMessageOptions ( id ) ; const tagsToDisable = get ( configRegistry , 'tags.disable' , [ ] ) ; const namespaceTags = get ( configRegistry , ` ${ id } ` , [ ] ) ; const containsDisabledTag = tagsToDisable . some ( ( element ) => { return namespaceTags . indexOf ( element ) > - 1 ; } ) ; if ( options . disable . indexOf ( level ) > - 1 || containsDisabledTag ) { if ( ! ! configRegistry . verbose ) { console . log ( ` ${ level } ${ id } ` ) ; } return ; } const [ , , stats , ... args ] = applyPlugins ( pluginsRegistry , id , level , calcStats ( ) , ... rest ) ; wrappers . concat ( options . wrappers ) . forEach ( ( wrapper ) => { const restOrArgs = equalsWrapperOptValue ( wrapper , 'passInitialArguments' , true ) ? rest : args ; const plugins = extractWrapperPlugins ( wrapper ) ; const [ , , wrapperStats , ... wrapperArgs ] = applyPlugins ( plugins , id , level , stats , ... restOrArgs ) ; if ( typeof wrapper [ levelMethod ] === 'function' ) { return wrapper [ levelMethod ] ( id , wrapperStats , ... wrapperArgs ) ; } else if ( typeof wrapper . log === 'function' && ! ! fallbackToLog ) { return wrapper . log ( id , level , wrapperStats , ... wrapperArgs ) ; } if ( ! ! configRegistry . verbose ) { console . log ( ` ${ fallbackToLog } ` ) ; } } ) ; }
903	function getPageInfo ( pagePath , prefix ) { let parts = pagePath . split ( '/' ) ; let componentName = parts . pop ( ) ; let pageName = parts . join ( '/' ) ; prefix && ( pageName = ` ${ prefix } ${ pageName } ` ) ; return { pageName , componentName } ; }
1594	function ( cb ) { var id = new Buffer ( 8 ) , time = Date . now ( ) - this . epoch ; id . fill ( 0 ) ; if ( time === this . lastTime ) { if ( this . overflow ) { overflowCond ( this , cb ) ; return ; } this . seq = ( this . seq + 1 ) & this . seqMask ; if ( this . seq === 0 ) { this . overflow = true ; overflowCond ( this , cb ) ; return ; } } else { this . overflow = false ; this . seq = 0 ; } this . lastTime = time ; id . writeUInt32BE ( ( ( time & 0x3 ) << 22 ) | this . id | this . seq , 4 ) ; id . writeUInt8 ( Math . floor ( time / 4 ) & 0xFF , 4 ) ; id . writeUInt16BE ( Math . floor ( time / FlakeId . POW10 ) & 0xFFFF , 2 ) ; id . writeUInt16BE ( Math . floor ( time / FlakeId . POW26 ) & 0xFFFF , 0 ) ; if ( cb ) { process . nextTick ( cb . bind ( null , null , id ) ) ; } else { return id ; } }
1005	function ( cb ) { var i ; log ( '[Caching] Setting activate handler' , cb , this . pendingActivations ) ; this . activateHandler = cb ; for ( i = 0 ; i < this . pendingActivations . length ; i ++ ) { cb ( this . pendingActivations [ i ] ) ; } delete this . pendingActivations ; }
335	function ( event , func ) { this . _events = this . _events || { } ; if ( event in this . _events === false ) return ; this . _events [ event ] . splice ( this . _events [ event ] . indexOf ( func ) , 1 ) ; }
2223	function autoInjectServices ( object , args ) { if ( args . length === 0 ) return ; let code = object . constructor . toString ( ) ; code = code . match ( 'constructor\\([\\$a-zA-Z0-9\\,\\s]+\\)' ) [ \\ ] ; \\ \\ \\ }
935	function overrideProcessor ( existedProcessor , extnameProcessorMap , opts ) { let oldExtnames ; let newExtnames ; Object . keys ( opts ) . forEach ( k => { let v = opts [ k ] ; if ( ! v ) { return ; } if ( k === 'extnames' ) { oldExtnames = existedProcessor [ k ] ; newExtnames = v ; } if ( k === 'hook' ) { v = overrideObjectFunctions ( v , existedProcessor [ k ] ) ; } existedProcessor [ k ] = v ; } ) ; let processor = opts . processor ; if ( processor ) { existedProcessor . processor = resolveProcessor ( processor ) ; } let processorName = opts . name ; removeFileExtnameAssociatedProcessor ( oldExtnames , processorName , extnameProcessorMap ) ; addFileExtnameAssociatedProcessor ( newExtnames , processorName , extnameProcessorMap ) ; }
790	function updateProgress ( ) { var progressBar = document . querySelector ( '.progress-bar' ) ; if ( progressBar !== null ) { var numSlides = document . getElementsByClassName ( 'slide' ) . length ; var position = currentPosition ( ) - 1 ; var percent = ( numSlides === 1 ) ? 100 : 100 * position / ( numSlides - 1 ) ; progressBar . style . width = percent . toString ( ) + '%' ; } }
270	function connectAccountFetchComplete ( state = { } , action ) { return Object . assign ( { } , state , { connectedUserID : action . connectedUserID || '' , displayName : action . displayName || '' , email : action . email || '' , error : action . error || '' , firstName : action . firstName || '' , isActivated : action . isActivated || false , isDeauthorizing : false , isRequesting : false , lastName : action . lastName || '' , logo : action . logo || '' , } ) ; }
1661	function ( socket ) { if ( this . listeners [ socket . id ] ) { delete this . listeners [ socket . id ] if ( Object . keys ( this . listeners ) . length === 0 ) { this . destroy ( ) } } else { return new Error ( 'no listener present on LQ ' + this . qKey ) } }
2346	function createIndexForCollection ( collectionName , indexField , indexOpts ) { var collection = mongoClient . collection ( collectionName ) ; collection . createIndex ( indexField , indexOpts , function ( err ) { if ( err ) { debugError ( 'Failed to create index for collection. collection = %s :: index = %j :: error = %j' , collectionName , indexField , err ) ; } else { debug ( 'Index created for collection. Collection = %s :: index = %j' , collectionName , indexField ) ; } } ) ; }
195	function handleRenewNowClick ( purchase , siteSlug ) { const renewItem = cartItems . getRenewalItemFromProduct ( purchase , { domain : purchase . meta , } ) ; const renewItems = [ renewItem ] ; analytics . tracks . recordEvent ( 'calypso_purchases_renew_now_click' , { product_slug : purchase . productSlug , } ) ; addItems ( renewItems ) ; page ( '/checkout/' + siteSlug ) ; }
2218	function collapsable ( node ) { return ( is ( 'text' , node ) || element ( node , list ) || embedded ( node ) || bodyOK ( node ) || ( element ( node , 'meta' ) && has ( node , 'itemProp' ) ) ) }
3563	function extractBoolFromArray ( array , startOrEndBln ) { var extractedValue = extractFromArrayAt ( array , startOrEndBln ? 0 : array . length - 1 , _Boolean , false ) [ 0 ] ; return isBoolean ( extractedValue ) ? extractedValue : false ; }
219	function KeyboardShortcuts ( keyBindings ) { if ( ! ( this instanceof KeyboardShortcuts ) ) { return new KeyboardShortcuts ( keyBindings ) ; } this . lastKey = undefined ; this . lastKeyTime = undefined ; this . timeLimit = 2000 ; this . boundKeyHandler = this . handleKeyPress . bind ( this ) ; this . isNotificationsOpen = false ; if ( typeof window !== 'undefined' ) { keymaster . filter = ignoreDefaultAndContentEditableFilter ; this . bindShortcuts ( keyBindings ) ; } }
2070	function makeDateFromStringAndFormat ( config ) { var tokens = config . _f . match ( formattingTokens ) , string = config . _i , i , parsedInput ; config . _a = [ ] ; for ( i = 0 ; i < tokens . length ; i ++ ) { parsedInput = ( getParseRegexForToken ( tokens [ i ] , config ) . exec ( string ) || [ ] ) [ 0 ] ; if ( parsedInput ) { string = string . slice ( string . indexOf ( parsedInput ) + parsedInput . length ) ; } if ( formatTokenFunctions [ tokens [ i ] ] ) { addTimeToArrayFromToken ( tokens [ i ] , parsedInput , config ) ; } } if ( string ) { config . _il = string ; } if ( config . _isPm && config . _a [ 3 ] < 12 ) { config . _a [ 3 ] += 12 ; } if ( config . _isPm === false && config . _a [ 3 ] === 12 ) { config . _a [ 3 ] = 0 ; } dateFromArray ( config ) ; }
697	function ( x , event , selected ) { if ( selected ) { currentSubject = x } else { currentSubject = null if ( currentMode === 1 ) deselectObject ( ) } if ( currentMode !== 0 ) showFiltered ( currentMode ) }
2038	function ( name ) { var destPath = configHelpers . modulePath ( name ) ; var sourcePath = pathExtra . join ( __dirname , '..' , 'node_modules' , name ) ; if ( ! fs . existsSync ( destPath ) ) { fs . copySync ( sourcePath , destPath ) ; } }
3054	function ( propNames , state ) { var me = this , i , n ; if ( typeof propNames == 'string' ) { me . savePropToState ( propNames , state ) ; } else { for ( i = 0 , n = propNames . length ; i < n ; ++ i ) { me . savePropToState ( propNames [ i ] , state ) ; } } return state ; }
726	function ( values , silent ) { this . buffer = document . createDocumentFragment ( ) ; var childNodes = this . $control [ 0 ] . childNodes ; for ( var i = 0 ; i < childNodes . length ; i ++ ) { this . buffer . appendChild ( childNodes [ i ] ) ; } var items = $ . isArray ( values ) ? values : [ values ] ; for ( var i = 0 , n = items . length ; i < n ; i ++ ) { this . isPending = ( i < n - 1 ) ; this . addItem ( items [ i ] , silent ) ; } var control = this . $control [ 0 ] ; control . insertBefore ( this . buffer , control . firstChild ) ; this . buffer = null ; }
1622	function parse_status_block ( block ) { var match ; var parsed = { interface : block . match ( / ^([^\s]+) / ) [ 1 ] } ; if ( ( match = block . match ( / Link encap:\s*([^\s]+) / ) ) ) { parsed . link = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = block . match ( / HWaddr\s+([^\s]+) / ) ) ) { parsed . address = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = block . match ( / inet6\s+addr:\s*([^\s]+) / ) ) ) { parsed . ipv6_address = match [ 1 ] ; } if ( ( match = block . match ( / inet\s+addr:\s*([^\s]+) / ) ) ) { parsed . ipv4_address = match [ 1 ] ; } if ( ( match = block . match ( / Bcast:\s*([^\s]+) / ) ) ) { parsed . ipv4_broadcast = match [ 1 ] ; } if ( ( match = block . match ( / Mask:\s*([^\s]+) / ) ) ) { parsed . ipv4_subnet_mask = match [ 1 ] ; } if ( ( match = block . match ( / UP / ) ) ) { parsed . up = true ; } if ( ( match = block . match ( / BROADCAST / ) ) ) { parsed . broadcast = true ; } if ( ( match = block . match ( / RUNNING / ) ) ) { parsed . running = true ; } if ( ( match = block . match ( / MULTICAST / ) ) ) { parsed . multicast = true ; } if ( ( match = block . match ( / LOOPBACK / ) ) ) { parsed . loopback = true ; } return parsed ; }
813	function merge_objs ( source , target ) { for ( var k in source ) { if ( source . hasOwnProperty ( k ) ) { target [ k ] = source [ k ] ; } } return target ; }
2362	function invoke ( dataset_id , params , callback ) { debug ( 'invoke' ) ; if ( arguments . length < 3 ) throw new Error ( 'invoke requires 3 arguments' ) ; if ( ! params || ! params . fn ) { var err = new Error ( 'no fn parameter provided in params "' + util . inspect ( params ) + '"' ) ; debugError ( '[%s] warn %s %j' , dataset_id , err , params ) ; return callback ( err , null ) ; } var fn = params . fn ; if ( invokeFunctions . indexOf ( fn ) < 0 ) { return callback ( new Error ( 'invalid fn parameter provided in params "' + fn + '"' ) , null ) ; } if ( ! syncConnected ) { return callback ( new Error ( 'Sync not connected' ) ) ; } var fnHandler = module . exports [ fn ] || server [ fn ] || server . api [ fn ] ; server . api . start ( function ( ) { return fnHandler ( dataset_id , params , callback ) ; } ) ; }
1150	function ( args ) { var amount = _ . isFinite ( args . amount ) ? args . amount : 1 ; return _ . template ( '<filter><feColorMatrix type="saturate" values="${amount}"/></filter>' , { amount : 1 - amount } ) ; }
3609	function freeMemory ( mappedVars , step ) { if ( mappedVars . length > 0 ) { let mappedVarsStringify = [ ] for ( let mappedVar of mappedVars ) { if ( mappedVar . hasOwnProperty ( "self" ) && mappedVar . self ) { delete mappedVar . self . code mappedVarsStringify . push ( JSON . stringify ( mappedVar . self ) ) } } return simpleEval ( ` ${ mappedVarsStringify . join ( ',' ) } ` , false , step ) } }
1329	function GroupRefOrDecChar ( text , textLoc ) { const reference = Number ( text . slice ( 1 ) ) ; if ( reference > 0 && reference <= capturingGroupsCount ) { return Node ( { type : 'Backreference' , kind : 'number' , number : reference , reference , } , textLoc ) ; } return Char ( text , 'decimal' , textLoc ) ; }
328	function scaleY ( _scaleY ) { var scaleX = this . imageData . scaleX ; return this . scale ( isNumber ( scaleX ) ? scaleX : 1 , _scaleY ) ; }
2828	function Component ( domElement ) { this . domElement = domElement ; this . template = "" ; this . templateNodes = [ ] ; this . model = [ ] ; this . parentModel = null ; this . built = false ; }
1293	function CreateStringIterator ( string ) { CHECK_OBJECT_COERCIBLE ( string , 'String.prototype[Symbol.iterator]' ) ; var s = TO_STRING ( string ) ; var iterator = new StringIterator ; SET_PRIVATE ( iterator , stringIteratorIteratedStringSymbol , s ) ; SET_PRIVATE ( iterator , stringIteratorNextIndexSymbol , 0 ) ; return iterator ; }
717	function ( privateKey , password ) { if ( ! privateKey || ! password ) throw new Error ( 'Missing argument !' ) ; let pass = derivePassSha ( password , 20 ) ; let r = encrypt ( privateKey , convert . hexToUint8 ( pass . priv ) ) ; return { ciphertext : CryptoJS . enc . Hex . stringify ( r . ciphertext ) , iv : convert . uint8ToHex ( r . iv ) } ; }
3388	function ( ) { var requests = this . requests , id ; for ( id in requests ) { if ( requests . hasOwnProperty ( id ) ) { this . abort ( requests [ id ] ) ; } } }
30	function GifWriterOutputLZWCodeStream ( buf , p , min_code_size , index_stream ) { buf [ p ++ ] = min_code_size ; var cur_subblock = p ++ ; var clear_code = 1 << min_code_size ; var code_mask = clear_code - 1 ; var eoi_code = clear_code + 1 ; var next_code = eoi_code + 1 ; var cur_code_size = min_code_size + 1 ; var cur_shift = 0 ; var cur = 0 ; function emit_bytes_to_buffer ( bit_block_size ) { while ( cur_shift >= bit_block_size ) { buf [ p ++ ] = cur & 0xff ; cur >>= 8 ; cur_shift -= 8 ; if ( p === cur_subblock + 256 ) { buf [ cur_subblock ] = 255 ; cur_subblock = p ++ ; } } } function emit_code ( c ) { cur |= c << cur_shift ; cur_shift += cur_code_size ; emit_bytes_to_buffer ( 8 ) ; } var ib_code = index_stream [ 0 ] & code_mask ; var code_table = { } ; emit_code ( clear_code ) ; for ( var i = 1 , il = index_stream . length ; i < il ; ++ i ) { var k = index_stream [ i ] & code_mask ; var cur_key = ib_code << 8 | k ; var cur_code = code_table [ cur_key ] ; if ( cur_code === undefined ) { cur |= ib_code << cur_shift ; cur_shift += cur_code_size ; while ( cur_shift >= 8 ) { buf [ p ++ ] = cur & 0xff ; cur >>= 8 ; cur_shift -= 8 ; if ( p === cur_subblock + 256 ) { buf [ cur_subblock ] = 255 ; cur_subblock = p ++ ; } } if ( next_code === 4096 ) { emit_code ( clear_code ) ; next_code = eoi_code + 1 ; cur_code_size = min_code_size + 1 ; code_table = { } ; } else { if ( next_code >= ( 1 << cur_code_size ) ) ++ cur_code_size ; code_table [ cur_key ] = next_code ++ ; } ib_code = k ; } else { ib_code = cur_code ; } } emit_code ( ib_code ) ; emit_code ( eoi_code ) ; emit_bytes_to_buffer ( 1 ) ; if ( cur_subblock + 1 === p ) { buf [ cur_subblock ] = 0 ; } else { buf [ cur_subblock ] = p - cur_subblock - 1 ; buf [ p ++ ] = 0 ; } return p ; }
1658	function run ( cmd , args , options , done ) { if ( typeof options === 'function' ) { done = options ; options = undefined ; } var executed = false ; var ch = spawn ( cmd , args , options ) ; var stdout = '' ; var stderr = '' ; ch . stdout . on ( 'data' , function ( d ) { stdout += d . toString ( ) ; } ) ; ch . stderr . on ( 'data' , function ( d ) { stderr += d . toString ( ) ; } ) ; ch . on ( 'error' , function ( err ) { if ( executed ) return ; executed = true ; done ( new Error ( err ) ) ; } ) ; ch . on ( 'close' , function ( code ) { if ( executed ) return ; executed = true ; if ( stderr ) { return done ( new Error ( stderr ) ) ; } done ( null , stdout , code ) ; } ) ; }
1834	function saveWarning ( req , res ) { var text = req . body . action === 'save' ? req . body . warning_text : '' ; dreadnot . setWarning ( req . remoteUser , text , function ( err ) { if ( err ) { res . respond ( err ) ; } else { getWarning ( req , res ) ; } } ) ; }
2227	function ( ) { var sendTracerInit = function ( ) { sendObjectToInspectedPage ( { content : { type : "MEIOSIS_TRACER_INIT" } } ) } var triggerStreamValue = function ( index , value ) { sendObjectToInspectedPage ( { content : { type : "MEIOSIS_TRIGGER_STREAM_VALUE" , index : index , value : value } } ) } tracer = window . meiosisTracer ( { selector : "#meiosis-tracer" , sendTracerInit : sendTracerInit , triggerStreamValue : triggerStreamValue , direction : "auto" } ) }
54	function on ( element ) { var events = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : '' ; var callback = arguments . length > 2 ? arguments [ 2 ] : undefined ; var passive = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : true ; var capture = arguments . length > 4 && arguments [ 4 ] !== undefined ? arguments [ 4 ] : false ; toggleListener . call ( this , element , events , callback , true , passive , capture ) ; }
3634	function find ( action , req , res , cb ) { var result = { } ; clean ( action , result , req , res , function ( err ) { if ( err ) { return cb ( err ) ; } if ( options . found ) { options . found ( result , req , res , cb ) ; } else { cb && cb ( null , result ) ; } } ) ; }
145	function isValidProductCategory ( category ) { return ( category && category . id && 'number' === typeof category . id && category . name && 'string' === typeof category . name && category . slug && 'string' === typeof category . slug ) ; }
3823	function ( app ) { var self = this ; app . locals [ self . options . templateVar ] = self ; var routes = self . getRoutes ( ) ; routes . forEach ( function ( route ) { if ( route . controller . indexOf ( 'staticDir:' ) === 0 ) { self . bindStaticRoute ( app , route ) ; } else { self . bindRegularRoute ( app , route ) ; } } ) ; }
3747	function ( i , validate ) { if ( arguments . length === 1 ) { return av . type ( i ) ; } var _i ; var me = function ( d ) { if ( ! arguments . length ) { if ( typeof _i === 'object' ) { var o = { } ; for ( var prop in _i ) { o [ prop ] = _i [ prop ] ( ) ; } return o ; } else { return _i ; } } _i = validate ( d ) ; if ( typeof _i === 'object' ) { for ( var prop_object in _i ) { me [ prop_object ] = _i [ prop_object ] ; } } } ; me ( i ) ; return me ; }
3546	function replacePlaceHolders ( array , args ) { var out = array . map ( function ( element ) { return ! ( element instanceof PlaceHolder ) ? element : ( args . length > 0 ? args . shift ( ) : element ) ; } ) ; return args . length > 0 ? out . concat ( args ) : out ; }
1655	function list ( PID , options , callback ) { if ( typeof options === 'function' ) { callback = options ; options = { } ; } if ( typeof options !== 'object' ) { options = { } ; } PID = parseInt ( PID , 10 ) ; if ( isNaN ( PID ) || PID < - 1 ) { callback ( new TypeError ( 'The pid provided is invalid' ) ) ; return ; } getAll ( function ( err , list ) { if ( err ) { callback ( err ) ; return ; } if ( PID === - 1 ) { for ( var i = 0 ; i < list . length ; i ++ ) { list [ i ] = options . advanced ? { ppid : list [ i ] [ 0 ] , pid : list [ i ] [ 1 ] } : ( list [ i ] = list [ i ] [ 1 ] ) ; } callback ( null , list ) ; return ; } var root ; for ( var l = 0 ; l < list . length ; l ++ ) { if ( list [ l ] [ 1 ] === PID ) { root = options . advanced ? { ppid : list [ l ] [ 0 ] , pid : PID } : PID ; break ; } if ( list [ l ] [ 0 ] === PID ) { root = options . advanced ? { pid : PID } : PID ; } } if ( ! root ) { callback ( new Error ( 'No maching pid found' ) ) ; return ; } var tree = { } ; while ( list . length > 0 ) { var e = list . pop ( ) ; if ( tree [ e [ 0 ] ] ) { tree [ e [ 0 ] ] . push ( e [ 1 ] ) ; } else { tree [ e [ 0 ] ] = [ e [ 1 ] ] ; } } var idx = 0 ; var pids = [ root ] ; while ( idx < pids . length ) { var curpid = options . advanced ? pids [ idx ++ ] . pid : pids [ idx ++ ] ; if ( ! tree [ curpid ] ) continue ; var len = tree [ curpid ] . length ; for ( var j = 0 ; j < len ; j ++ ) { pids . push ( options . advanced ? { ppid : curpid , pid : tree [ curpid ] [ j ] } : tree [ curpid ] [ j ] ) ; } delete tree [ curpid ] ; } if ( ! options . root ) { pids . shift ( ) ; } callback ( null , pids ) ; } ) ; }
1476	function ( msgId , ... args ) { for ( var i = 0 ; i < args . length ; i ++ ) { var arg = args [ i ] ; if ( typeof arg !== "string" && typeof arg !== "number" && arg !== null ) { args [ i ] = String ( arg ) ; } } if ( this . isMachineReadable ( ) ) { let str = "##" + msgId + ":" + JSON . stringify ( args ) ; console . log ( str ) ; } else { var writer = this . getWriter ( ) ; let str = this . decode ( msgId , ... args ) ; if ( writer ) { writer ( str , msgId , ... args ) ; } else { console . log ( str ) ; } } }
2601	function histogram ( ) { var histogram = { } ; libs . object . every ( arguments , function ( o ) { if ( typeof o === 'boolean' ) { if ( ! histogram [ o ] ) histogram [ o ] = 1 ; else histogram [ o ] ++ ; } else if ( typeof o === 'function' ) { if ( ! histogram [ 'function' ] ) histogram [ 'function' ] = 1 ; else histogram [ o ] ++ ; } else { libs . object . every ( o , function ( val ) { switch ( true ) { case typeof val === 'function' : case typeof val === 'undefined' : val = typeof val ; break ; case typeof val === 'object' && val === null : val = 'null' ; break ; case typeof val === 'object' && val instanceof Array : val = 'array' ; break ; case typeof val === 'object' : val = 'object' ; break ; default : val = val . toString ( ) ; } if ( typeof histogram [ val ] !== 'number' ) histogram [ val ] = 0 ; histogram [ val ] ++ ; } ) ; } } ) ; return histogram ; }
2647	function processPointerPosition ( e ) { var prevValue = this . value ; if ( this . style === 'horizontal' ) { this . __value = ( e . clientX - this . rect . left ) / this . rect . width ; } else { this . __value = 1 - ( e . clientY - this . rect . top ) / this . rect . height ; } if ( this . __value > 1 ) this . __value = 1 ; if ( this . __value < 0 ) this . __value = 0 ; var shouldDraw = this . output ( ) ; if ( shouldDraw ) this . draw ( ) ; }
3651	function ( e ) { var ANON = '{anonymous}' , lineRE = / Line (\d+).*script (?:in )?(\S+) / i ; var lines = e . message . split ( '\n' ) , \n ; result = [ ] for ( var i = 2 , len = lines . length ; i < len ; i += 2 ) { var match = lineRE . exec ( lines [ i ] ) ; if ( match ) { result . push ( ANON + '()@' + match [ 2 ] + ':' + match [ 1 ] + ' -- ' + lines [ i + 1 ] . replace ( / ^\s+ / , '' ) ) ; } } }
2724	function log ( ctx , start , len , err , event ) { const status = err ? ( err . status || 500 ) : ( ctx . status || 404 ) ; const s = status / 100 | 0 ; const color = colorCodes [ s ] ; let length ; if ( ~ [ 204 , 205 , 304 ] . indexOf ( status ) ) { length = "" ; } else if ( null == len ) { length = "-" ; } else { length = bytes ( len ) ; } const upstream = err ? chalk . red ( "xxx" ) : event === "end" ? chalk . yellow ( "-x-" ) : chalk . gray ( " ) ; logger . debug ( ` ${ upstream } ${ chalk . bold ( ctx . method ) } ${ chalk . gray ( ctx . originalUrl ) } ${ chalk [ color ] ( status ) } ${ chalk . gray ( time ( start ) ) } ${ chalk . gray ( length ) } ` ) ; }
692	function WildCardButtons ( ) { var menuDiv = myDocument . getElementById ( outline . UserInput . menuID ) var div = menuDiv . insertBefore ( myDocument . createElement ( 'div' ) , menuDiv . firstChild ) var input1 = div . appendChild ( myDocument . createElement ( 'input' ) ) var input2 = div . appendChild ( myDocument . createElement ( 'input' ) ) input1 . type = 'button' ; input1 . value = 'New...' input2 . type = 'button' ; input2 . value = 'Know its URI' function highlightInput ( e ) { var menu = myDocument . getElementById ( outline . UserInput . menuID ) if ( menu . lastHighlight ) menu . lastHighlight . className = '' menu . lastHighlight = UI . utils . ancestor ( UI . utils . getTarget ( e ) , 'INPUT' ) if ( ! menu . lastHighlight ) return menu . lastHighlight . className = 'activeItem' } div . addEventListener ( 'mouseover' , highlightInput , false ) input1 . addEventListener ( 'click' , this . createNew , false ) input2 . addEventListener ( 'click' , this . inputURI , false ) }
2190	function _uniqContentEquals ( aIterator , bIterator , stackA , stackB ) { var a = _arrayFromIterator ( aIterator ) ; var b = _arrayFromIterator ( bIterator ) ; function eq ( _a , _b ) { return _equals ( _a , _b , stackA . slice ( ) , stackB . slice ( ) ) ; } return ! _containsWith ( function ( b , aItem ) { return ! _containsWith ( eq , aItem , b ) ; } , b , a ) ; }
1499	function ForceFillColumnWidths ( allColumns , expectedWidth , startIdx ) { var contentWidth = 0 , columnsToResize = startIdx > - 1 ? allColumns . slice ( startIdx , allColumns . length ) . filter ( ( c ) => { return c . canAutoResize } ) : allColumns . filter ( ( c ) => { return c . canAutoResize } ) ; allColumns . forEach ( ( c ) => { if ( ! c . canAutoResize ) { contentWidth += c . width ; } else { contentWidth += ( c . $$oldWidth || c . width ) ; } } ) ; var remainingWidth = expectedWidth - contentWidth , additionWidthPerColumn = remainingWidth / columnsToResize . length , exceedsWindow = contentWidth > expectedWidth ; columnsToResize . forEach ( ( column ) => { if ( exceedsWindow ) { column . width = column . $$oldWidth || column . width ; } else { if ( ! column . $$oldWidth ) { column . $$oldWidth = column . width ; } var newSize = column . $$oldWidth + additionWidthPerColumn ; if ( column . minWith && newSize < column . minWidth ) { column . width = column . minWidth ; } else if ( column . maxWidth && newSize > column . maxWidth ) { column . width = column . maxWidth ; } else { column . width = newSize ; } } } ) ; }
2025	function ( callback ) { var cozyLight = require ( './cozy-light' ) ; logger . info ( 'Restarting...' ) ; actions . stop ( function ( ) { configHelpers . loadConfigFile ( ) ; cozyLight . routes = { } ; logger . info ( 'Starting all apps...' ) ; pluginHelpers . loadAll ( this . program , function ( ) { actions . start ( this . program , function ( ) { logger . info ( '...Cozy Light was properly restarted.' ) ; nodeHelpers . invoke ( callback ) ; actionsEvent . emit ( 'restarted' ) ; } ) ; } ) ; } ) ; }
68	function setFocus ( ) { var element = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : null ; var tabFocus = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; if ( ! is$1 . element ( element ) ) { return ; } element . focus ( { preventScroll : true } ) ; if ( tabFocus ) { toggleClass ( element , this . config . classNames . tabFocus ) ; } }
1864	function locateOutputPlaceholder ( text ) { var range = require ( 'range' ) ; var result = [ ] ; var stream = require ( 'stringStream' ) . create ( text ) ; while ( ! stream . eol ( ) ) { if ( stream . peek ( ) == '\\' ) \\ else { stream . next ( ) ; } { stream . start = stream . pos ; if ( stream . match ( outputPlaceholder , true ) ) { result . push ( range . create ( stream . start , outputPlaceholder ) ) ; continue ; } } } stream . next ( ) ; }
36	function isSameStacktrace ( stack1 , stack2 ) { if ( isOnlyOneTruthy ( stack1 , stack2 ) ) return false ; var frames1 = stack1 . frames ; var frames2 = stack2 . frames ; if ( frames1 === undefined || frames2 === undefined ) return false ; if ( frames1 . length !== frames2 . length ) return false ; var a , b ; for ( var i = 0 ; i < frames1 . length ; i ++ ) { a = frames1 [ i ] ; b = frames2 [ i ] ; if ( a . filename !== b . filename || a . lineno !== b . lineno || a . colno !== b . colno || a [ 'function' ] !== b [ 'function' ] ) return false ; } return true ; }
2605	function isNumeric ( ) { return libs . object . every ( arguments , function ( item ) { return ! isNaN ( parseFloat ( item ) ) && isFinite ( item ) ; } ) ; }
623	function filterOnDensity ( wordCombinations , wordCount , lowerLimit , upperLimit ) { return wordCombinations . filter ( function ( combination ) { return ( combination . getDensity ( wordCount ) >= lowerLimit && combination . getDensity ( wordCount ) < upperLimit ) ; } ) ; }
3318	function ( command , arg ) { var docs = [ ] ; docs . push ( '<strong><tt> &gt; ' ) ; docs . push ( command . name ) ; if ( command . params && command . params . length > 0 ) { command . params . forEach ( function ( param ) { if ( param . defaultValue === undefined ) { docs . push ( ' [' + param . name + ']' ) ; } else { docs . push ( ' <em>[' + param . name + ']</em>' ) ; } } , this ) ; } docs . push ( '</tt></strong><br/>' ) ; docs . push ( command . description ? command . description : '(No description)' ) ; docs . push ( '<br/>' ) ; if ( command . params && command . params . length > 0 ) { docs . push ( '<ul>' ) ; command . params . forEach ( function ( param ) { docs . push ( '<li>' ) ; docs . push ( '<strong><tt>' + param . name + '</tt></strong>: ' ) ; docs . push ( param . description ? param . description : '(No description)' ) ; if ( param . defaultValue === undefined ) { docs . push ( ' <em>[Required]</em>' ) ; } else if ( param . defaultValue === null ) { docs . push ( ' <em>[Optional]</em>' ) ; } else { docs . push ( ' <em>[Default: ' + param . defaultValue + ']</em>' ) ; } docs . push ( '</li>' ) ; } , this ) ; docs . push ( '</ul>' ) ; } return new Hint ( Status . VALID , docs . join ( '' ) , arg ) ; }
3282	function srcFilePusher ( options ) { return through . obj ( function ( file , encoding , done ) { getAllFiles ( file , options ) . then ( files => { files . forEach ( file => this . push ( file ) ) ; done ( ) ; } , err => { } ) ; } ) }
3551	function implode ( list , separator ) { var retVal = '' , prototypeOfList = Object . getPrototypeOf ( list ) ; if ( isArray ( list ) ) { retVal = list . join ( separator ) ; } else if ( prototypeOfList . constructor . name === 'Set' || prototypeOfList . constructor . name === 'SjlSet' ) { retVal = [ ] ; list . forEach ( function ( value ) { retVal . push ( value ) ; } ) ; retVal = retVal . join ( separator ) ; } return retVal ; }
619	function filterFunctionWordsAnywhere ( wordCombinations , functionWords ) { return wordCombinations . filter ( function ( combination ) { return isEmpty ( intersection ( functionWords , combination . getWords ( ) ) ) ; } ) ; }
231	function recordOrderInCriteo ( cart , orderId ) { if ( ! isAdTrackingAllowed ( ) || ! isCriteoEnabled ) { return ; } const params = [ 'trackTransaction' , { id : orderId , currency : cart . currency , item : cartToCriteoItems ( cart ) , } , ] ; debug ( 'recordOrderInCriteo:' , params ) ; recordInCriteo ( ... params ) ; }
3723	function getShaSalt ( ) { var shaDeps = [ __filename , __dirname + '/protractor_api.dart' ] ; return shaTextHexDigest . apply ( shaDeps . map ( utils . readTextFile ) ) ; }
3139	function ( key , fn , scope ) { var keyCode , shift , ctrl , alt ; if ( Ext . isObject ( key ) && ! Ext . isArray ( key ) ) { keyCode = key . key ; shift = key . shift ; ctrl = key . ctrl ; alt = key . alt ; } else { keyCode = key ; } this . addBinding ( { key : keyCode , shift : shift , ctrl : ctrl , alt : alt , fn : fn , scope : scope } ) ; }
1950	function makeAttributesString ( node , profile ) { var attrQuote = profile . attributeQuote ( ) ; var cursor = profile . cursor ( ) ; return _ . map ( node . attributeList ( ) , function ( a ) { var attrName = profile . attributeName ( a . name ) ; return ' ' + attrName + '=' + attrQuote + ( a . value || cursor ) + attrQuote ; } ) . join ( '' ) ; }
1456	function ( analyser , className ) { var filename = pathModule . join ( analyser . getOutputDir ( ) , "transpiled" , className . replace ( / \. / g , pathModule . sep ) + ".js" ) ; return filename ; }
3553	function extend ( o , p , deep ) { if ( ! o || ! p ) { return o ; } Object . keys ( p ) . forEach ( function ( prop ) { var propDescription = Object . getOwnPropertyDescriptor ( o , prop ) ; if ( propDescription && ! ( isset ( propDescription . get ) && isset ( propDescription . set ) ) && ! propDescription . writable ) { return ; } if ( deep === true ) { if ( isObject ( p [ prop ] ) && isObject ( o [ prop ] ) && ! isEmptyObj ( p [ prop ] ) ) { extend ( o [ prop ] , p [ prop ] , deep ) ; } else { o [ prop ] = p [ prop ] ; } } else { o [ prop ] = p [ prop ] ; } } ) ; return o ; }
838	function generateTemplate ( templateFile , snippetsDir ) { const titleTemplateFile = templateFile . replace ( '.template.html' , '.title-template.html' ) ; const outputTemplateFile = templateFile . replace ( '.template.html' , '.html' ) ; const codeFile = templateFile . replace ( '.template.html' , '.ts' ) ; const styleFile = templateFile . replace ( '.template.html' , '.scss' ) ; const titleTemplateFileContent = fs . readFileSync ( path . resolve ( snippetsDir , titleTemplateFile ) , { encoding : 'utf8' } ) ; const templateFileContent = fs . readFileSync ( path . resolve ( snippetsDir , templateFile ) , { encoding : 'utf8' } ) ; const templateTabHtml = tabHtml ( path . basename ( outputTemplateFile ) , templateFileContent , 'html' ) ; let codeFileContent = fs . readFileSync ( path . resolve ( snippetsDir , codeFile ) , { encoding : 'utf8' } ) ; codeFileContent = codeFileContent . replace ( / @local\/ng5-slider / g , "ng5-slider" ) ; const codeTabHtml = tabHtml ( path . basename ( codeFile ) , codeFileContent , 'typescript' ) ; let styleTabHtml = '' ; if ( fs . existsSync ( path . resolve ( snippetsDir , styleFile ) ) ) { const styleFileContent = fs . readFileSync ( path . resolve ( snippetsDir , styleFile ) , { encoding : 'utf8' } ) ; styleTabHtml = tabHtml ( path . basename ( styleFile ) , styleFileContent , 'scss' ) ; } const outputHtmlFileContent = ` ${ titleTemplateFileContent } ${ templateFileContent } ${ codeTabHtml } ${ templateTabHtml } ${ styleTabHtml } ` ; fs . writeFileSync ( path . resolve ( snippetsDir , outputTemplateFile ) , outputHtmlFileContent , { encoding : 'utf8' } ) ; }
971	function initJsProcessor ( opts , defaultBabelProcessorName ) { let plugins = ( opts && opts . plugins ) || [ jsPlugin ] ; registerProcessor ( { name : ( opts && opts . processor ) || defaultBabelProcessorName , hook : { before ( file , options ) { if ( file . isWxCompScript ) { options . plugins || ( options . plugins = [ ] ) ; options . plugins . push . apply ( options . plugins , plugins ) ; } } } } ) ; }
1906	function ( val ) { if ( ! _ . isUndefined ( val ) && this . _name !== ( val = String ( val ) ) ) { this . parent . _updateSource ( val , this . nameRange ( ) ) ; this . _name = val ; } return this . _name ; }
633	function getSentencesFromBlock ( block ) { const sentenceTokenizer = new SentenceTokenizer ( ) ; const { tokenizer , tokens } = sentenceTokenizer . createTokenizer ( ) ; sentenceTokenizer . tokenize ( tokenizer , block ) ; return tokens . length === 0 ? [ ] : sentenceTokenizer . getSentencesFromTokens ( tokens ) ; }
1765	function emitKeypressEvents ( stream , iface ) { if ( stream [ KEYPRESS_DECODER ] ) return ; if ( StringDecoder === undefined ) StringDecoder = require ( 'string_decoder' ) . StringDecoder ; stream [ KEYPRESS_DECODER ] = new StringDecoder ( 'utf8' ) ; stream [ ESCAPE_DECODER ] = emitKeys ( stream ) ; stream [ ESCAPE_DECODER ] . next ( ) ; const escapeCodeTimeout = ( ) => stream [ ESCAPE_DECODER ] . next ( '' ) ; let timeoutId ; function onData ( b ) { if ( stream . listenerCount ( 'keypress' ) > 0 ) { var r = stream [ KEYPRESS_DECODER ] . write ( b ) ; if ( r ) { clearTimeout ( timeoutId ) ; if ( iface ) { iface . _sawKeyPress = r . length === 1 ; } for ( var i = 0 ; i < r . length ; i ++ ) { if ( r [ i ] === '\t' && \t && typeof r [ i + 1 ] === 'string' ) iface { iface . isCompletionEnabled = false ; } } } } else try { stream [ ESCAPE_DECODER ] . next ( r [ i ] ) ; if ( r [ i ] === kEscape && i + 1 === r . length ) { timeoutId = setTimeout ( escapeCodeTimeout , iface ? iface . escapeCodeTimeout : ESCAPE_CODE_TIMEOUT ) ; } } catch ( err ) { stream [ ESCAPE_DECODER ] = emitKeys ( stream ) ; stream [ ESCAPE_DECODER ] . next ( ) ; throw err ; } finally { if ( iface ) { iface . isCompletionEnabled = true ; } } } { stream . removeListener ( 'data' , onData ) ; stream . on ( 'newListener' , onNewListener ) ; } function onNewListener ( event ) { if ( event === 'keypress' ) { stream . on ( 'data' , onData ) ; stream . removeListener ( 'newListener' , onNewListener ) ; } } }
77	function getHTML ( element ) { var wrapper = document . createElement ( 'div' ) ; wrapper . appendChild ( element ) ; return wrapper . innerHTML ; }
3810	function CommonJSResolverStrategy ( config ) { BasicResolverStrategy . call ( this , config ) ; this . config = extend ( true , this . config , { } , config ) ; }
3104	function ( key , task , done , ttl ) { const queue = this . queue ; const semaphore = this . semaphore ; if ( ! ttl ) ttl = this . ttl ; const runTask = ( res ) => new Promise ( ( resolve ) => task ( ( ... args ) => resolve ( Response . setData ( res , args ) ) ) ) ; const startThenRunTask = ( lock_key ) => queue . start ( key , Response . factory ( ttl ) ) . then ( runTask ) . then ( queue . dequeue . bind ( null , key ) ) . then ( ( ) => semaphore . release ( key , lock_key ) ) . catch ( ( err ) => { semaphore . release ( key , lock_key ) ; throw err ; } ) ; const startIfNotWaiting = ( ) => Promise . all ( [ queue . isWaiting ( key ) , semaphore . lock ( key ) ] ) . then ( ( [ is_waiting , lock_key ] ) => ( ! is_waiting && lock_key ) ? startThenRunTask ( lock_key ) : null ) return queue . add ( key , done ) . then ( startIfNotWaiting ) ; }
2326	function TMEhandler ( manager , inputEvent , inputData ) { var isTouch = inputData . pointerType == INPUT_TYPE_TOUCH , isMouse = inputData . pointerType == INPUT_TYPE_MOUSE ; if ( isMouse && inputData . sourceCapabilities && inputData . sourceCapabilities . firesTouchEvents ) { return ; } if ( isTouch ) { recordTouches . call ( this , inputEvent , inputData ) ; } else if ( isMouse && isSyntheticEvent . call ( this , inputData ) ) { return ; } this . callback ( manager , inputEvent , inputData ) ; }
1350	function timePassed ( t ) { if ( t > 0 ) this . find ( ".wcp-time-current" ) . text ( parseTime ( t , this . vlc . length ) ) ; else if ( this . find ( ".wcp-time-current" ) . text ( ) != "" && this . find ( ".wcp-time-total" ) . text ( ) == "" ) this . find ( ".wcp-time-current" ) . text ( "" ) ; if ( typeof opts [ this . context ] . subtitles === 'undefined' ) opts [ this . context ] . subtitles = [ ] ; if ( opts [ this . context ] . subtitles . length > 0 ) { var nowSecond = ( t - opts [ this . context ] . subDelay ) / 1000 ; if ( opts [ this . context ] . trackSub > - 2 ) { var subtitle = - 1 ; var os = 0 ; for ( os in opts [ this . context ] . subtitles ) { if ( os > nowSecond ) break ; subtitle = os ; } if ( subtitle > 0 ) { if ( subtitle != opts [ this . context ] . trackSub ) { if ( ( opts [ this . context ] . subtitles [ subtitle ] . t . match ( new RegExp ( "<" , "g" ) ) || [ ] ) . length == 2 ) { if ( ! ( opts [ this . context ] . subtitles [ subtitle ] . t . substr ( 0 , 1 ) == "<" && opts [ this . context ] . subtitles [ subtitle ] . t . slice ( - 1 ) == ">" ) ) { opts [ this . context ] . subtitles [ subtitle ] . t = opts [ this . context ] . subtitles [ subtitle ] . t . replace ( / <\/?[^>]+(>|$) / g , "" ) ; } } else if ( ( opts [ this . context ] . subtitles [ subtitle ] . t . match ( new RegExp ( "<" , "g" ) ) || [ ] ) . length > 2 ) { opts [ this . context ] . subtitles [ subtitle ] . t = opts [ this . context ] . subtitles [ subtitle ] . t . replace ( / <\/?[^>]+(>|$) / g , "" ) ; } this . find ( ".wcp-subtitle-text" ) . html ( nl2br ( opts [ this . context ] . subtitles [ subtitle ] . t ) ) ; opts [ this . context ] . trackSub = subtitle ; } else if ( opts [ this . context ] . subtitles [ subtitle ] . o < nowSecond ) { this . find ( ".wcp-subtitle-text" ) . html ( "" ) ; } } } } }
1273	function ( timestamp ) { int_timestamp = parseInt ( timestamp ) ; assert ( int_timestamp >= last_timestamp , "Inconsistent timestamps." ) ; last_timestamp = int_timestamp ; distortion += distortion_per_entry ; return int_timestamp / 1000 - distortion ; }
1366	function ( identifier , data , config , cb ) { if ( data . action === undefined ) { return new Error ( "action param can not be empty." ) ; } var path = api . getPath ( baseURL , identifier , customActionPath + data . action ) ; api . post ( path , data , config , cb ) ; }
3360	function ( key ) { var pos = key . indexOf ( '[' ) ; if ( pos === - 1 ) return { type : 'string' , val : key } ; return { type : 'array' , val : key . substr ( 0 , pos ) } ; }
3390	function ( request , xdrResult ) { var me = this , options = request . options , result , success , response ; try { result = me . parseStatus ( request . xhr . status ) ; } catch ( e ) { result = { success : false , isException : false } ; } success = me . isXdr ? xdrResult : result . success ; if ( success ) { response = me . createResponse ( request ) ; me . fireEvent ( 'requestcomplete' , me , response , options ) ; Ext . callback ( options . success , options . scope , [ response , options ] ) ; } else { if ( result . isException || request . aborted || request . timedout ) { response = me . createException ( request ) ; } else { response = me . createResponse ( request ) ; } me . fireEvent ( 'requestexception' , me , response , options ) ; Ext . callback ( options . failure , options . scope , [ response , options ] ) ; } Ext . callback ( options . callback , options . scope , [ options , success , response ] ) ; delete me . requests [ request . id ] ; return response ; }
109	function findTrack ( languages ) { var _this3 = this ; var force = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; var tracks = captions . getTracks . call ( this ) ; var sortIsDefault = function sortIsDefault ( track ) { return Number ( ( _this3 . captions . meta . get ( track ) || { } ) . default ) ; } ; var sorted = Array . from ( tracks ) . sort ( function ( a , b ) { return sortIsDefault ( b ) - sortIsDefault ( a ) ; } ) ; var track ; languages . every ( function ( language ) { track = sorted . find ( function ( track ) { return track . language === language ; } ) ; return ! track ; } ) ; return track || ( force ? sorted [ 0 ] : undefined ) ; }
1298	function CollectNew ( node_list ) { for ( var i = 0 ; i < node_list . length ; i ++ ) { link_to_original_script_list . push ( node_list [ i ] ) ; CollectNew ( node_list [ i ] . children ) ; } }
3123	function ( objs ) { var me = this , key ; if ( arguments . length > 1 || Ext . isArray ( objs ) ) { me . insert ( me . length , arguments . length > 1 ? arguments : objs ) ; } else { for ( key in objs ) { if ( objs . hasOwnProperty ( key ) ) { if ( me . allowFunctions || typeof objs [ key ] != 'function' ) { me . add ( key , objs [ key ] ) ; } } } } }
2507	function existsOrCreateSync ( filePath , opts ) { opts = opts || { } ; opts . encoding = opts . encoding || 'utf8' ; opts . data = opts . data || opts . content || '' ; opts . mode = opts . mode || '0777' ; var fp = resolve ( filePath ) ; var isFile = opts . hasOwnProperty ( 'isFile' ) ? opts . isFile : ! ! fp . extName ; var exists = fs . existsSync ( fp . fullPath ) ; if ( ! exists || opts . replace ) { mkdir ( ( isFile ? fp . dirName : fp . fullPath ) ) ; if ( isFile || opts . replace ) fs . writeFileSync ( fp . fullPath , opts . data , opts . encoding ) ; } function mkdir ( fullPath ) { if ( fs . existsSync ( fullPath ) ) return ; else { var parentPath = fullPath . split ( '/' ) ; parentPath . pop ( ) ; mkdir ( parentPath . join ( '/' ) ) ; fs . mkdirSync ( fullPath , opts . mode ) ; } } return exists ; }
2667	function emit ( instance , name ) { var args = [ ] . slice . call ( arguments , 2 ) ; if ( events . indexOf ( name ) > - 1 ) { if ( instance . handlers [ name ] && instance . handlers [ name ] instanceof Array ) { forEach ( instance . handlers [ name ] , function ( handle ) { window . setTimeout ( function ( ) { handle . callback . apply ( handle . context , args ) ; } , 0 ) ; } ) ; } } else { throw new Error ( name + ' event cannot be found on TreeView.' ) ; } }
334	function ( event , func ) { this . _events = this . _events || { } ; this . _events [ event ] = this . _events [ event ] || [ ] ; this . _events [ event ] . push ( func ) ; }
3554	function extendMulti ( ) { var args = argsToArray ( arguments ) , deep = extractBoolFromArrayStart ( args ) , arg0 = args . shift ( ) ; args . forEach ( function ( arg ) { if ( isObject ( arg ) ) { extend ( arg0 , arg , deep ) ; } } ) ; return arg0 ; }
950	function makeComputedObservable ( ctx ) { let computedInfo = ctx . $rawComputed || { } ; if ( typeof computedInfo === 'function' ) { ctx . $rawComputed = computedInfo = computedInfo ( ) ; } let observer = new ComputedObserver ( ctx , computedInfo ) ; let ctxProps = { } ; Object . keys ( computedInfo ) . forEach ( k => { ctxProps [ k ] = { get : observer . getGetter ( k ) , set : observer . getSetter ( k ) , enumerable : true } ; } ) ; Object . defineProperties ( ctx , ctxProps ) ; return observer ; }
1266	function getWithResolvedData ( ctx , cur , down ) { return function ( data ) { return ctx . push ( data ) . _get ( cur , down ) ; } ; }
924	function initPlatformInfo ( callback ) { api . getSystemInfo ( { success ( info ) { callback && callback ( null , info ) ; } , fail ( err ) { callback && callback ( err ) ; } } ) ; }
1987	function ( e ) { e . data . handler . over = false ; $ . iframeTracker . retrieveFocus ( ) ; try { e . data . handler . outCallback ( this , e ) ; } catch ( ex ) { } }
2669	function validatePackageName ( package_name ) { var msg = 'Error validating package name. ' ; if ( ! / ^[a-zA-Z][a-zA-Z0-9_]+(\.[a-zA-Z][a-zA-Z0-9_]*)+$ / . test ( package_name ) ) { return Q . reject ( new CordovaError ( msg + 'Package name must look like: com.company.Name' ) ) ; } if ( / \b[Cc]lass\b / . test ( package_name ) ) { return Q . reject ( new CordovaError ( msg + '"class" is a reserved word' ) ) ; } return Q . resolve ( ) ; }
851	function getLocation ( node ) { const token = sourceCode . getTokenAfter ( node ) return { start : node . loc . start , end : token . loc . end , } }
2434	function OneToMany ( elements ) { return function ( targetObject , propertyKey ) { var entityMetadata = targetObject ; if ( ! entityMetadata . oneToManyMap ) { entityMetadata . oneToManyMap = { } ; } entityMetadata . oneToManyMap [ propertyKey ] = elements ; } ; }
2977	function ( ) { this . TYPE = { TAG : 'tag' , USER : 'user' } this . urlRules = { tag : { rule : / ((https?):\/\/)?(www\.)?instagram.com\/explore\/tags\/([\w_]+) / mi } , user : { rule : / ((https?):\/\/)?(www\.)?instagram\.com\/([\w._]+)\/? / mi } } }
501	function ( runState , cb ) { let selfdestructToAddress = runState . stack . pop ( ) if ( runState . static ) { trap ( ERROR . STATIC_STATE_CHANGE ) } var stateManager = runState . stateManager var contract = runState . contract var contractAddress = runState . address selfdestructToAddress = addressToBuffer ( selfdestructToAddress ) stateManager . getAccount ( selfdestructToAddress , function ( err , toAccount ) { if ( err ) { cb ( err ) return } stateManager . accountIsEmpty ( selfdestructToAddress , function ( error , empty ) { if ( error ) { cb ( error ) return } if ( ( new BN ( contract . balance ) ) . gtn ( 0 ) ) { if ( empty ) { try { subGas ( runState , new BN ( runState . _common . param ( 'gasPrices' , 'callNewAccount' ) ) ) } catch ( e ) { cb ( e . error ) return } } } if ( ! runState . selfdestruct [ contractAddress . toString ( 'hex' ) ] ) { runState . gasRefund = runState . gasRefund . addn ( runState . _common . param ( 'gasPrices' , 'selfdestructRefund' ) ) } runState . selfdestruct [ contractAddress . toString ( 'hex' ) ] = selfdestructToAddress runState . stopped = true var newBalance = new BN ( contract . balance ) . add ( new BN ( toAccount . balance ) ) async . waterfall ( [ stateManager . getAccount . bind ( stateManager , selfdestructToAddress ) , function ( account , cb ) { account . balance = newBalance stateManager . putAccount ( selfdestructToAddress , account , cb ) } , stateManager . getAccount . bind ( stateManager , contractAddress ) , function ( account , cb ) { account . balance = new BN ( 0 ) stateManager . putAccount ( contractAddress , account , cb ) } ] , function ( err ) { cb ( err ) } ) } ) } ) }
1364	function ( identifier , data , config , cb ) { if ( data . tags === undefined ) { return new Error ( "tags param can not be empty." ) ; } var path = api . getPathWithData ( baseURL , identifier , tagsActionPath , data ) ; api . delete ( path , config , cb ) ; }
3030	function Range ( str ) { var range = str ; if ( range . charAt ( 0 ) == 'A' ) { this . _approximate = true ; range = str . substr ( 1 ) ; } var parts = range . split ( '/' ) ; if ( parts . length != 2 || ( ! parts [ 0 ] && ! parts [ 1 ] ) ) { throw new Error ( 'Invalid Date Range' ) ; } if ( parts [ 0 ] ) { try { this . start = new Simple ( parts [ 0 ] ) ; } catch ( e ) { throw new Error ( e . message + ' in Range Start Date' ) ; } } if ( parts [ 1 ] ) { if ( parts [ 1 ] . charAt ( 0 ) == 'P' ) { if ( ! this . start ) { throw new Error ( 'A Range may not end with a duration if missing a start date' ) ; } try { this . duration = new Duration ( parts [ 1 ] ) ; } catch ( e ) { throw new Error ( e . message + ' in Range End Date' ) ; } this . end = GedUtil . addDuration ( this . start , this . duration ) ; } else { try { this . end = new Simple ( parts [ 1 ] ) ; } catch ( e ) { throw new Error ( e . message + ' in Range End Date' ) ; } if ( this . start ) { this . duration = GedUtil . getDuration ( this . start , this . end ) ; } } } }
308	function addTimestamp ( url ) { var timestamp = "timestamp=" . concat ( new Date ( ) . getTime ( ) ) ; return url + ( url . indexOf ( '?' ) === - 1 ? '?' : '&' ) + timestamp ; }
103	function buildUrlParams ( input ) { var params = new URLSearchParams ( ) ; if ( is$1 . object ( input ) ) { Object . entries ( input ) . forEach ( function ( _ref ) { var _ref2 = _slicedToArray ( _ref , 2 ) , key = _ref2 [ 0 ] , value = _ref2 [ 1 ] ; params . set ( key , value ) ; } ) ; } return params ; }
322	function destroy ( ) { var element = this . element ; if ( ! element [ NAMESPACE ] ) { return this ; } element [ NAMESPACE ] = undefined ; if ( this . isImg && this . replaced ) { element . src = this . originalUrl ; } this . uncreate ( ) ; return this ; }
1624	function expand_r ( options , lines , prefix ) { Object . getOwnPropertyNames ( options ) . forEach ( function ( key ) { var full = prefix . concat ( key ) ; var value = options [ key ] ; if ( Array . isArray ( value ) ) { value . forEach ( function ( val ) { lines . push ( full . concat ( val ) . join ( ' ' ) ) ; } ) ; } else if ( typeof ( value ) == 'object' ) { expand_r ( value , lines , full ) ; } else { lines . push ( full . concat ( value ) . join ( ' ' ) ) ; } } ) ; }
1912	function ( name , value , pos ) { var list = this . list ( ) ; var start = this . nameRange ( ) . end ; var editTree = require ( 'editTree' ) ; var styles = _ . pick ( this . options , 'styleBefore' , 'styleSeparator' , 'styleQuote' ) ; if ( _ . isUndefined ( pos ) ) pos = list . length ; var donor = list [ pos ] ; if ( donor ) { start = donor . fullRange ( ) . start ; } else if ( donor = list [ pos - 1 ] ) { start = donor . range ( ) . end ; } if ( donor ) { styles = _ . pick ( donor , 'styleBefore' , 'styleSeparator' , 'styleQuote' ) ; } value = styles . styleQuote + value + styles . styleQuote ; var attribute = new XMLEditElement ( this , editTree . createToken ( start + styles . styleBefore . length , name ) , editTree . createToken ( start + styles . styleBefore . length + name . length + styles . styleSeparator . length , value ) ) ; _ . extend ( attribute , styles ) ; this . _updateSource ( attribute . styleBefore + attribute . toString ( ) , start ) ; this . _children . splice ( pos , 0 , attribute ) ; return attribute ; }
1640	function ( ) { var self = this ; console . log ( 'starting capture...' ) ; var req = get_req ( ) ; req . onreadystatechange = function start_capture_response ( ) { if ( req . readyState === 4 ) { if ( req . status == 200 ) { console . log ( 'started.' ) ; jQuery ( "#start" ) . hide ( ) ; jQuery ( "#stop" ) . show ( ) ; htracr . ui . pulse_logo ( ) ; } else { var error = eval ( "(" + req . responseText + ")" ) ; alert ( "Sorry, I can't start the sniffer; it says \"" + \" + error . message ) ; "\"." } } } ; \" console . log ( "start problem: " + error ) ; req . open ( "POST" , "/start" , true ) ; }
1647	function ( ) { var self = this ; var idx = self . capture_idx ; self . w = ( ( idx . end - idx . start ) / 1000 * self . pix_per_sec ) + margin [ 1 ] + margin [ 3 ] ; self . h = margin [ 0 ] + margin [ 2 ] ; for ( var s in idx . servers ) { self . h += ( self . server_pad * 2 ) ; self . h += ( ( idx . servers [ s ] [ 1 ] . length ) * self . conn_pad ) ; } console . log ( "resizing to " + self . w + " x " + self . h ) ; paper . setSize ( self . w , self . h ) ; labels . setSize ( self . label_w , self . h ) ; }
1916	function toggleCSSComment ( editor ) { var range = require ( 'range' ) . create ( editor . getSelectionRange ( ) ) ; var info = require ( 'editorUtils' ) . outputInfo ( editor ) ; if ( ! range . length ( ) ) { var rule = require ( 'cssEditTree' ) . parseFromPosition ( info . content , editor . getCaretPos ( ) ) ; if ( rule ) { var property = cssItemFromPosition ( rule , editor . getCaretPos ( ) ) ; range = property ? property . range ( true ) : require ( 'range' ) . create ( rule . nameRange ( true ) . start , rule . source ) ; } } if ( ! range . length ( ) ) { range = require ( 'range' ) . create ( editor . getCurrentLineRange ( ) ) ; require ( 'utils' ) . narrowToNonSpace ( info . content , range ) ; } return genericCommentToggle ( editor , '/*' , '*/' , range ) ; }
1375	function workflowGuidWorkflowLocale ( ) { return self . apos . docs . db . ensureIndex ( { workflowGuid : 1 , workflowLocale : 1 } , { sparse : 1 , unique : 1 } ) . catch ( function ( err ) { return resolveDuplicateDocs ( ) . then ( function ( ) { return workflowGuidWorkflowLocale ( ) ; } ) ; } ) ; }
1386	function allocateWorkers ( execution ) { const kr = new K8sResource ( 'deployments' , 'worker' , context . sysconfig . teraslice , execution ) ; const workerDeployment = kr . resource ; logger . debug ( ` \n \n ${ JSON . stringify ( workerDeployment , null , 2 ) } ` ) ; return k8s . post ( workerDeployment , 'deployment' ) . then ( result => logger . debug ( ` ${ JSON . stringify ( result ) } ` ) ) . catch ( ( err ) => { const error = new TSError ( err , { reason : 'Error submitting k8s worker deployment' } ) ; return Promise . reject ( error ) ; } ) ; }
2018	function ( program , callback ) { var config = configHelpers . getConfig ( ) ; config . plugins = config . plugins || { } ; var loadPlugin = function ( pluginName , cb ) { pluginHelpers . loadPlugin ( pluginName , program , cb ) ; } ; Object . keys ( config . plugins ) . forEach ( loadPlugin ) ; nodeHelpers . invoke ( callback ) ; }
1638	function ( v ) { var result = 0 var key for ( key in v ) { v . hasOwnProperty ( key ) && result ++ } return result }
2809	function ( functionBody , argNames , argValues , context ) { var functionArgs = argNames . concat ( functionBody ) ; var fn = Function . apply ( null , functionArgs ) ; return function ( ) { var args = argValues . concat ( Array . prototype . slice . call ( arguments ) ) ; return fn . apply ( context , args ) ; } }
2478	function lookup ( name , obj ) { for ( const key in obj ) { const re = RegExp ( key , 'i' ) if ( name . match ( re ) ) { return obj [ key ] } } return null }
2424	function ( n , x , Pnm_minus1 , Pnm_minus2 ) { var Pnm = new Array ( n + 1 ) ; switch ( n ) { case 1 : var x2 = numeric . mul ( x , x ) ; var P10 = x ; var P11 = numeric . sqrt ( numeric . sub ( 1 , x2 ) ) ; Pnm [ 0 ] = P10 ; Pnm [ 1 ] = P11 ; break ; case 2 : var x2 = numeric . mul ( x , x ) ; var P20 = numeric . mul ( 3 , x2 ) ; P20 = numeric . sub ( P20 , 1 ) ; P20 = numeric . div ( P20 , 2 ) ; var P21 = numeric . sub ( 1 , x2 ) ; P21 = numeric . sqrt ( P21 ) ; P21 = numeric . mul ( 3 , P21 ) ; P21 = numeric . mul ( P21 , x ) ; var P22 = numeric . sub ( 1 , x2 ) ; P22 = numeric . mul ( 3 , P22 ) ; Pnm [ 0 ] = P20 ; Pnm [ 1 ] = P21 ; Pnm [ 2 ] = P22 ; break ; default : var x2 = numeric . mul ( x , x ) ; var one_min_x2 = numeric . sub ( 1 , x2 ) ; var k = 2 * n - 1 ; var dfact_k = 1 ; if ( ( k % 2 ) == 0 ) { for ( var kk = 1 ; kk < k / 2 + 1 ; kk ++ ) dfact_k = dfact_k * 2 * kk ; } else { for ( var kk = 1 ; kk < ( k + 1 ) / 2 + 1 ; kk ++ ) dfact_k = dfact_k * ( 2 * kk - 1 ) ; } Pnm [ n ] = numeric . mul ( dfact_k , numeric . pow ( one_min_x2 , n / 2 ) ) ; Pnm [ n - 1 ] = numeric . mul ( 2 * n - 1 , numeric . mul ( x , Pnm_minus1 [ n - 1 ] ) ) ; for ( var m = 0 ; m < n - 1 ; m ++ ) { var temp1 = numeric . mul ( 2 * n - 1 , numeric . mul ( x , Pnm_minus1 [ m ] ) ) ; var temp2 = numeric . mul ( n + m - 1 , Pnm_minus2 [ m ] ) ; Pnm [ m ] = numeric . div ( numeric . sub ( temp1 , temp2 ) , n - m ) ; } } return Pnm ; }
2732	function ( options ) { var self = this var result = [ ] if ( options . _id ) { var id = Array . isArray ( options . _id ) ? options . _id : [ options . _id ] id . forEach ( function ( id ) { if ( self . cache [ id ] ) { result . push ( self . cache [ id ] ) } } ) } else { result = Object . keys ( this . cache ) . map ( function ( k ) { return self . cache [ k ] } ) . sort ( function ( count1 , count2 ) { return count1 . _id - count2 . _id } ) if ( options . skip || options . limit ) { var skip = options . skip || 0 var limit = options . limit || 0 return result . slice ( skip , skip + limit ) } } return result }
1514	function computeNodeDepths ( graph ) { var nodes , next , x ; for ( nodes = graph . nodes , next = [ ] , x = 0 ; nodes . length ; ++ x , nodes = next , next = [ ] ) { nodes . forEach ( function ( node ) { node . depth = x ; node . sourceLinks . forEach ( function ( link ) { if ( next . indexOf ( link . target ) < 0 && ! link . circular ) { next . push ( link . target ) ; } } ) ; } ) ; } for ( nodes = graph . nodes , next = [ ] , x = 0 ; nodes . length ; ++ x , nodes = next , next = [ ] ) { nodes . forEach ( function ( node ) { node . height = x ; node . targetLinks . forEach ( function ( link ) { if ( next . indexOf ( link . source ) < 0 && ! link . circular ) { next . push ( link . source ) ; } } ) ; } ) ; } graph . nodes . forEach ( function ( node ) { node . column = Math . floor ( align . call ( null , node , x ) ) ; } ) ; }
444	function isDomainComponent ( component ) { const getRole = ( child ) => { return child && child . type ? child . type . role : "" ; } ; let role = getRole ( component ) ; if ( role === "portal" ) { const children = React . Children . toArray ( component . props . children ) ; role = children . length ? getRole ( children [ 0 ] ) : "" ; } const whitelist = [ "area" , "axis" , "bar" , "boxplot" , "candlestick" , "errorbar" , "group" , "line" , "pie" , "scatter" , "stack" , "voronoi" ] ; return includes ( whitelist , role ) ; }
2974	function render ( rawCode , idPre ) { var codeArr = { } ; var re = / <script[^>]* src\s*=\s*'*"*([^'"]+)[^>]*>.*<\/script> / gi ; var HeaderCode = re . exec ( rawCode ) ; if ( HeaderCode ) { _ . forEach ( HeaderCode , function ( code , key ) { if ( 0 === key ) return ; codeArr [ ` ${ idPre } ${ key } ` ] = code ; } ) ; } re = / <script[^>]*>([^]+)<\/script> / gi ; HeaderCode = re . exec ( rawCode ) ; if ( HeaderCode ) { _ . forEach ( HeaderCode , function ( code , key ) { if ( 0 === key ) return ; codeArr [ ` ${ idPre } ${ key } ` ] = { code : code } ; } ) ; } return codeArr ; }
690	function Click ( e ) { var target = UI . utils . getTarget ( e ) if ( UI . utils . getTerm ( target ) . termType !== 'Literal' ) return this . literalModification ( target ) e . preventDefault ( ) e . stopPropagation ( ) }
2501	function ( name , data ) { if ( typeof data == 'undefined' ) { data = { } ; } if ( ! data . context ) { data . context = this ; } return this . app . trigger ( name , data ) ; }
2577	function ellipses_ ( s , length , place , ellipses ) { if ( isNaN ( parseInt ( length , 10 ) ) ) length = s . length ; if ( length < 0 || ! isFinite ( length ) ) length = 0 ; ellipses = typeof ellipses === 'string' ? ellipses : '...' ; if ( s . length <= length ) return s ; if ( length <= ellipses . length ) { return ellipses . substring ( 0 , length ) ; } else if ( ! place || place !== 'front' ) { return s . substr ( 0 , length - ellipses . length ) + ellipses ; } else { return ellipses + s . substr ( 0 , length - ellipses . length ) ; } }
2322	function getWindowForElement ( element ) { var doc = element . ownerDocument || element ; return doc . defaultView || doc . parentWindow || window ; }
1657	function get ( callback ) { if ( file === undefined ) { callback ( new Error ( os . platform ( ) + ' is not supported yet, please open an issue (https://github.com/simonepri/pidtree)' ) ) ; } var list = require ( './' + file ) ; list ( callback ) ; }
181	function syncStatusRequest ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST : case WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST_FAILURE : return WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST === type ; } return state ; }
566	function ( eyeVertex ) { var horizon = [ ] ; this . unassigned . clear ( ) ; this . removeVertexFromFace ( eyeVertex , eyeVertex . face ) ; this . computeHorizon ( eyeVertex . point , null , eyeVertex . face , horizon ) ; this . addNewFaces ( eyeVertex , horizon ) ; this . resolveUnassignedPoints ( this . newFaces ) ; return this ; }
203	function overwriteExistingPurchases ( existingPurchases , newPurchases ) { let purchases = newPurchases ; existingPurchases . forEach ( purchase => { if ( ! find ( purchases , { ID : purchase . ID } ) ) { purchases = purchases . concat ( purchase ) ; } } ) ; return purchases ; }
1264	function toggleHamMenu ( show ) { if ( ! $nbmBtn ) return ; var fn = show ? 'addClass' : 'removeClass' ; $nbmBtn [ fn ] ( 'toggled' ) ; $navOverlay [ fn ] ( 'toggled' ) ; $navbarMenu [ fn ] ( 'toggled' ) ; helper . toggleBodyScroll ( ! show ) ; if ( show ) { $navbarMenu . scrollTop ( 0 ) ; if ( $sidebarWrapper && $sidebarWrapper . length ) { $wrapper . removeClass ( 'toggled' ) ; $sidebarToggle . removeClass ( 'toggled' ) ; $sidebarToggle . css ( 'opacity' , 0 ) ; } } else { $sidebarToggle . css ( 'opacity' , 1 ) ; } }
794	function populateSingle ( filename , destination , key ) { return loadSingle ( filename ) . then ( function ( data ) { if ( data ) { if ( Object . prototype . toString . call ( destination [ key ] ) === '[object Array]' ) { destination . loaded [ key ] = destination . loaded [ key ] || [ ] ; destination . loaded [ key ] . push ( data ) ; } else { destination . loaded [ key ] = data ; } } } ) ; }
2453	async function ( query , options ) { try { let response = await fetch ( ` ${ query } ` , options ) ; let json = await response . json ( ) ; return json ; } catch ( err ) { return err ; } }
2982	function metaData ( req , res , next ) { var zlSite = res . locals . zlSite ; if ( zlSite . zsOptions && zlSite . zsOptions . favicons ) { res . locals . favicons = zlSite . zsOptions . favicons ; } res . locals . title = zlSite . zsName ; if ( ! res . locals . robots ) res . locals . robots = 'INDEX, FOLLOW' ; next ( ) ; }
2428	function siftdown ( compare , a , i , j , k ) { var current = k - i ; while ( true ) { var firstchild = 2 * current + 1 ; if ( firstchild >= j - i ) break ; var candidate = ( 0 , _nextchild2 . default ) ( compare , a , i + firstchild , j ) ; if ( compare ( a [ i + current ] , a [ candidate ] ) <= 0 ) break ; var tmp = a [ i + current ] ; a [ i + current ] = a [ candidate ] ; a [ candidate ] = tmp ; current = candidate - i ; } return i + current ; }
2359	function ( datasetId , acknowledgementFields , callback ) { return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doSaveUpdate ) ( datasetId , acknowledgementFields , callback ) ; }
1821	function requestPromise ( options ) { return new Promise ( ( resolve , reject ) => { request ( options , ( error , response ) => { if ( ! error && response . statusCode === 200 ) { resolve ( response ) ; } else if ( error ) { reject ( error ) ; } else { reject ( new Error ( ` ${ response . statusCode } ` ) ) ; } } ) ; } ) ; }
172	function setUpLocale ( context , next ) { const language = getLanguage ( context . params . lang ) ; if ( language ) { context . lang = context . params . lang ; if ( language . rtl ) { context . isRTL = true ; } } next ( ) ; }
2824	function invokeConfigFn ( tasks ) { for ( var taskName in tasks ) { if ( tasks . hasOwnProperty ( taskName ) ) { tasks [ taskName ] ( grunt ) ; } } }
1707	function _innerRender ( ) { var specs = this . _specs ; for ( var i3 = 0 , j3 = specs . length ; i3 < j3 ; i3 ++ ) { if ( specs [ i3 ] . renderNode ) { specs [ i3 ] . target = specs [ i3 ] . renderNode . render ( ) ; } } if ( ! specs . length || ( specs [ specs . length - 1 ] !== this . _cleanupRegistration ) ) { specs . push ( this . _cleanupRegistration ) ; } return specs ; }
3876	function on ( element , ev , cb , context ) { for ( var _len = arguments . length , args = Array ( _len > 4 ? _len - 4 : 0 ) , _key = 4 ; _key < _len ; _key ++ ) { args [ _key - 4 ] = arguments [ _key ] ; } var _this = this ; var el = element . el , events = ev . split ( ' ' ) , fn = function fn ( e ) { cb . apply ( context || _this , [ e , element ] . concat ( args ) ) ; } ; events . forEach ( function ( event ) { el . addEventListener ( event , fn ) ; } ) ; var evt = { remove : function remove ( ) { events . forEach ( function ( event ) { return el . removeEventListener ( event , fn ) ; } ) ; var evts = element . _events ; evts . splice ( evts . indexOf ( evt ) , 1 ) ; } } ; element . _events . push ( evt ) ; return evt ; }
2276	function ( query , next ) { switch ( ctx . type ) { case 'model' : Model . find ( query , next ) ; break ; case 'relation' : Model . findOne ( query , function ( err , instance ) { if ( err ) return next ( err ) ; var builder = new _queryBuilder2 . default ( { type : ctx . type , count : ctx . count , now : ctx . now , nowISOString : ctx . nowISOString , params : { range : ctx . params . range , where : ctx . params . where , custom : ctx . params . custom } } ) ; builder . onComplete ( function ( _err , _query ) { if ( _err ) return next ( _err ) ; instance [ ctx . relation || ctx . params . relation ] ( _query , next ) ; } ) ; builder . build ( ) ; } ) ; break ; case 'nested' : Model . findOne ( query , function ( err , instance ) { return next ( err , instance [ ctx . nested ] ) ; } ) ; break ; default : next ( null , [ ] ) ; } }
938	function generateFilterCode ( filterObjAst , t , options ) { if ( ! filterObjAst . properties . length ) { return '' ; } let { format = 'es6' , usingBabel6 } = options || { } ; let ast ; if ( format === 'es6' ) { ast = generateES6ModuleFilterCode ( filterObjAst , t ) ; } else { ast = generateCommonJSModuleFilterCode ( filterObjAst , t ) ; } return generateCode ( ast , { auxiliaryCommentBefore : 'Auto generated filter code by okam' } , usingBabel6 ) . code ; }
319	function reset ( ) { if ( this . ready && ! this . disabled ) { this . imageData = assign ( { } , this . initialImageData ) ; this . canvasData = assign ( { } , this . initialCanvasData ) ; this . cropBoxData = assign ( { } , this . initialCropBoxData ) ; this . renderCanvas ( ) ; if ( this . cropped ) { this . renderCropBox ( ) ; } } return this ; }
22	function getFont ( fontName , fontStyle , options ) { var key = undefined , fontNameLowerCase ; options = options || { } ; fontName = fontName !== undefined ? fontName : fonts [ activeFontKey ] . fontName ; fontStyle = fontStyle !== undefined ? fontStyle : fonts [ activeFontKey ] . fontStyle ; fontNameLowerCase = fontName . toLowerCase ( ) ; if ( fontmap [ fontNameLowerCase ] !== undefined && fontmap [ fontNameLowerCase ] [ fontStyle ] !== undefined ) { key = fontmap [ fontNameLowerCase ] [ fontStyle ] ; } else if ( fontmap [ fontName ] !== undefined && fontmap [ fontName ] [ fontStyle ] !== undefined ) { key = fontmap [ fontName ] [ fontStyle ] ; } else { if ( options . disableWarning === false ) { console . warn ( "Unable to look up font label for font '" + fontName + "', '" + fontStyle + "'. Refer to getFontList() for available fonts." ) ; } } if ( ! key && ! options . noFallback ) { key = fontmap [ 'times' ] [ fontStyle ] ; if ( key == null ) { key = fontmap [ 'times' ] [ 'normal' ] ; } } return key ; }
3399	function proceedToFetch ( loader , load , p ) { proceedToTranslate ( loader , load , p . then ( function ( address ) { if ( load . linkSets . length == 0 ) return ; load . address = address ; return loader . loaderObj . fetch ( { name : load . name , metadata : load . metadata , address : address } ) ; } ) ) ; }
498	function ( runState ) { const [ offset , length ] = runState . stack . popN ( 2 ) subMemUsage ( runState , offset , length ) let data = Buffer . alloc ( 0 ) if ( ! length . isZero ( ) ) { data = runState . memory . read ( offset . toNumber ( ) , length . toNumber ( ) ) } subGas ( runState , new BN ( runState . _common . param ( 'gasPrices' , 'sha3Word' ) ) . imul ( length . divCeil ( new BN ( 32 ) ) ) ) const r = new BN ( utils . keccak256 ( data ) ) runState . stack . push ( r ) }
3734	function findNextOutside ( data , items , index , exclude ) { var result , positionResult = { start : 0 , end : index ? index - 1 : - 1 } ; do { result = findNext ( data , items , positionResult . end + 1 ) ; } while ( result . index !== - 1 && ( positionResult = inPosition ( result . index , exclude ) ) ) ; return result ; }
3819	function ( verb , path , controller , method ) { if ( this . __verbs . indexOf ( verb ) >= 0 ) { var entry = { verb : verb , path : path , controller : controller , method : method } ; this . routes . push ( entry ) ; } else { throw new Error ( 'Unrecognised HTTP verb for route: ' + path ) ; } }
592	function updateLocalizer ( refObj , targetLocalizersHelpers ) { let refHelper = refObj . stackHelper ; let localizerHelper = refObj . localizerHelper ; let plane = refHelper . slice . cartesianEquation ( ) ; localizerHelper . referencePlane = plane ; for ( let i = 0 ; i < targetLocalizersHelpers . length ; i ++ ) { for ( let j = 0 ; j < 3 ; j ++ ) { let targetPlane = targetLocalizersHelpers [ i ] [ 'plane' + ( j + 1 ) ] ; if ( targetPlane && plane . x . toFixed ( 6 ) === targetPlane . x . toFixed ( 6 ) && plane . y . toFixed ( 6 ) === targetPlane . y . toFixed ( 6 ) && plane . z . toFixed ( 6 ) === targetPlane . z . toFixed ( 6 ) ) { targetLocalizersHelpers [ i ] [ 'plane' + ( j + 1 ) ] = plane ; } } } localizerHelper . geometry = refHelper . slice . geometry ; }
3306	function arrSort ( a , b ) { var acomp = a [ 'name' ] . toString ( 10 ) ; var bcomp = b [ 'name' ] . toString ( 10 ) ; if ( ! isNaN ( Number ( acomp ) ) ) { acomp = Number ( acomp ) ; } if ( ! isNaN ( Number ( bcomp ) ) ) { bcomp = Number ( bcomp ) ; } if ( acomp < bcomp ) { return - 1 ; } if ( acomp > bcomp ) { return 1 ; } return 0 ; }
3243	function ( ) { if ( ! this . isTextArea ) { return false ; } var inputEl = this . textField . inputEl ; var overflowY = inputEl . getStyle ( 'overflow-y' ) ; if ( overflowY == 'hidden' || overflowY == 'visible' ) { return false ; } if ( overflowY == 'scroll' ) { return true ; } if ( inputEl . dom . scrollHeight <= inputEl . dom . clientHeight ) { return false ; } return true ; }
1744	function mapDispatchToProps ( dispatch ) { return { moveSlide : ( count ) => { dispatch ( bookmarkAction . moveSlide ( count ) ) ; } , zoomTo : ( coords , zoomLevel ) => { dispatch ( mapActions . setView ( coords , zoomLevel ) ) ; } } ; }
2621	function implementsOwn ( o , method ) { var args = libs . object . toArray ( arguments ) , a = args . shift ( ) ; if ( ! a ) return false ; return libs . object . every ( args , function ( m ) { if ( ! ( a [ m ] instanceof Function ) || ! o . hasOwnProperty ( method ) ) return false ; } ) ; }
2682	function createShell ( config , callback ) { var shell = new Shell ( config ) ; modules . initialize ( shell ) ; extensions . initialize ( shell ) ; require ( './commands' ) . initialize ( shell ) ; require ( './displayCommands' ) . initialize ( shell ) ; require ( './dataCommands' ) . initialize ( shell ) ; process . nextTick ( function ( ) { callback ( shell ) ; } ) ; }
3794	function ( callback , compilationSource ) { if ( compilationSource && this . cache . compilationSource && this . cache . compilationSource === compilationSource ) return ; var callbackError = function ( type , strOrErr ) { var error = strOrErr instanceof Error ? strOrErr : new Error ( strOrErr ) ; error . _Type = type ; t . cache . error = error ; callback ( error ) ; } , t = this ; if ( t . compiler ) { ( t . compiler . read || function ( path , callback ) { fs . readFile ( t . srcPath , function ( err , buffer ) { if ( err ) return callback ( err ) ; callback ( null , buffer . toString ( ) ) ; } ) ; } ) ( t . srcPath , function ( err , fileContent ) { if ( err ) return callbackError ( 'Reading' , err ) ; t . lint ( t , fileContent , function ( err ) { if ( err ) return callbackError ( 'Linting' , err ) ; t . parse ( fileContent , function ( err , data ) { if ( err ) return callbackError ( 'Parsing' , err ) ; try { t . _compile ( data , function ( err , results , dependencies ) { if ( err ) return callbackError ( 'Compiling' , err ) ; if ( err === false ) return callback ( ) ; t . optimize ( t , results , function ( err , optimizedResults ) { if ( err ) return callbackError ( 'Optimizing' , err ) ; t . cache . error = null ; t . cache . compilationTime = Date . now ( ) ; t . cache . compilationSource = compilationSource ; if ( err === false ) { t . cache . dependencies = null ; return callback ( ) ; } t . cache . dependencies = ! dependencies || dependencies . app ? dependencies : { app : dependencies } ; t . write ( optimizedResults , callback ) ; } ) ; } ) ; } catch ( err ) { return callbackError ( 'Compiling' , err ) ; } } ) ; } ) ; } ) ; } else { t . copy ( callback ) ; } }
1977	function lookupProfileAt ( name , date , agent = 'minecraft' ) { const hasDate = typeof date !== 'undefined' const query = hasDate ? ` ${ agent } ${ name } ${ date } ` : ` ${ agent } ${ name } ` return fetch ( ` ${ CORE_API } ${ query } ` , { headers : { 'user-agent' : USER_AGENT , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => { if ( res . status === 204 ) throw new Error ( ` ${ name } ` ) return res . json ( ) } ) }
1751	function logDecoder ( abi , useNumberedParams = true ) { const eventMap = { } abi . filter ( item => item . type === 'event' ) . map ( item => { eventMap [ eventSignature ( item ) ] = item } ) return function ( logItems ) { return logItems . map ( log => decodeLogItem ( eventMap [ log . topics [ 0 ] ] , log , useNumberedParams ) ) . filter ( i => i ) } }
1615	function strip_ignored_bytes ( octets ) { for ( var o = octets . length - 1 ; o >= 0 ; o -- ) { switch ( octets [ o ] ) { case XON : case XON_HIGH : case XOFF : case XOFF_HIGH : octets . splice ( o , 1 ) ; continue ; } } return octets ; }
2041	function ( plugin , manifest ) { if ( config . plugins === undefined ) { config . plugins = { } ; } config . plugins [ plugin ] = { name : manifest . name , displayName : manifest . displayName , version : manifest . version , description : manifest . description } ; configHelpers . saveConfig ( ) ; }
2146	function groupScan ( node , attrStart , attrEnd ) { var nodes = [ ] ; var depth = 0 ; if ( attrStart && node . hasAttribute && node . hasAttribute ( attrStart ) ) { do { if ( ! node ) { throw $compileMinErr ( 'uterdir' , 'Unterminated attribute, found \'{0}\' but no matching \'{1}\' found.' , \' , \' ) ; } \' \' attrStart } while attrEnd ; } else if ( node . nodeType === NODE_TYPE_ELEMENT ) { if ( node . hasAttribute ( attrStart ) ) depth ++ ; if ( node . hasAttribute ( attrEnd ) ) depth -- ; } nodes . push ( node ) ; }
3548	function forEach ( arrayLike , callback , context ) { var classOfArrayLike = sjl . classOf ( arrayLike ) ; switch ( classOfArrayLike ) { case _Array : case 'Set' : case 'SjlSet' : case 'SjlMap' : case 'Map' : arrayLike . forEach ( callback , context ) ; break ; case _Object : forEachInObj ( arrayLike , callback , context ) ; break ; default : throw new TypeError ( 'sjl.forEach takes only ' + '`Array`, `Object`, `Map`, `Set`, `SjlSet`, and `SjlMap` objects. ' + 'Type passed in: `' + classOfArrayLike + '`.' ) ; } }
1257	function initialize ( component ) { if ( typeof component . update !== 'function' ) { throw new Error ( 'Etch components must implement `update(props, children)`.' ) } let virtualNode = component . render ( ) if ( ! isValidVirtualNode ( virtualNode ) ) { let namePart = component . constructor && component . constructor . name ? ' in ' + component . constructor . name : '' throw new Error ( 'invalid falsy value ' + virtualNode + ' returned from render()' + namePart ) } applyContext ( component , virtualNode ) component . refs = { } component . virtualNode = virtualNode component . element = render ( component . virtualNode , { refs : component . refs , listenerContext : component } ) }
1732	function FontLayout ( context , options ) { size = context . size ; direction = context . direction ; text = options . text || 'KLMNOPQRSTUVW' ; spacing = ( options . spacing === undefined ) ? 10 : options . spacing ; offset = 0 ; set . size [ 0 ] = options . segmentSize ? options . segmentSize [ 0 ] : 20 ; set . size [ 1 ] = options . segmentSize ? options . segmentSize [ 1 ] : 4 ; for ( var i = 0 ; i < text . length ; i ++ ) { var charSegments = charMap [ text . charAt ( i ) ] || charMap [ '?' ] ; for ( var j = 0 ; j < 8 ; j ++ ) { if ( charSegments & ( 1 << j ) ) { node = context . next ( ) ; if ( ! node ) { return ; } var segment = segmentMap [ j ] ; set . translate [ 0 ] = ( set . size [ 0 ] * segment [ 0 ] ) + ( segment [ 3 ] * set . size [ 1 ] ) ; set . translate [ 1 ] = ( set . size [ 0 ] * segment [ 1 ] ) + ( segment [ 4 ] * set . size [ 1 ] ) ; set . translate [ direction ] += offset ; set . rotate [ 2 ] = ( segment [ 2 ] * Math . PI * 2 ) ; set . scrollLength = i ? 0 : ( direction ? ( set . size [ 0 ] * 2 ) : set . size [ 1 ] ) ; if ( ( j === 0 ) && ( i < ( text . length - 1 ) ) ) { set . scrollLength += spacing ; } context . set ( node , set ) ; } } offset += ( direction ? ( set . size [ 0 ] * 2 ) : set . size [ 0 ] ) + spacing ; } }
887	function getIncludeTemplateElement ( tplFile ) { let ast = tplFile . ast ; if ( ! ast ) { ast = tplFile . ast = parseDom ( tplFile . content . toString ( ) ) ; } let children = ast . children ; for ( let i = 0 , len = children . length ; i < len ; i ++ ) { let node = children [ i ] ; if ( node . type === 'tag' && node . name === 'template' ) { return node ; } } }
2797	function empty ( entity , schema , Empty ) { if ( typeof entity === 'undefined' || entity === null ) { return } _ . forEach ( schema , function ( v , k ) { if ( v === Empty ) { delete entity [ k ] } } ) }
2651	function init ( user_id , secret , storage , callback ) { API_USER_ID = user_id ; API_SECRET = secret ; TOKEN_STORAGE = storage ; if ( ! callback ) { callback = function ( ) { } } if ( ! fs . existsSync ( TOKEN_STORAGE ) ) { mkdirSyncRecursive ( TOKEN_STORAGE ) ; } if ( TOKEN_STORAGE . substr ( - 1 ) !== '/' ) { TOKEN_STORAGE += '/' ; } var hashName = md5 ( API_USER_ID + '::' + API_SECRET ) ; if ( fs . existsSync ( TOKEN_STORAGE + hashName ) ) { TOKEN = fs . readFileSync ( TOKEN_STORAGE + hashName , { encoding : 'utf8' } ) ; } if ( ! TOKEN . length ) { getToken ( callback ) ; return ; } callback ( TOKEN ) }
708	function objectTree ( obj ) { var res switch ( obj . termType ) { case 'NamedNode' : let anchor = myDocument . createElement ( 'a' ) anchor . setAttribute ( 'href' , obj . uri ) anchor . addEventListener ( 'click' , UI . widgets . openHrefInOutlineMode , true ) anchor . appendChild ( myDocument . createTextNode ( UI . utils . label ( obj ) ) ) return anchor case 'Literal' : if ( ! obj . datatype || ! obj . datatype . uri ) { res = myDocument . createElement ( 'div' ) res . setAttribute ( 'style' , 'white-space: pre-wrap;' ) res . textContent = obj . value return res } else if ( obj . datatype . uri === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral' ) { res = myDocument . createElement ( 'div' ) res . setAttribute ( 'class' , 'embeddedXHTML' ) res . innerHTML = obj . value return res } return myDocument . createTextNode ( obj . value ) case 'BlankNode' : if ( obj . toNT ( ) in doneBnodes ) { referencedBnodes [ ( obj . toNT ( ) ) ] = true let anchor = myDocument . createElement ( 'a' ) anchor . setAttribute ( 'href' , '#' + obj . toNT ( ) . slice ( 2 ) ) anchor . setAttribute ( 'class' , 'bnodeRef' ) anchor . textContent = '*' + obj . toNT ( ) . slice ( 3 ) return anchor } doneBnodes [ obj . toNT ( ) ] = true var newTable = propertyTree ( obj ) doneBnodes [ obj . toNT ( ) ] = newTable if ( UI . utils . ancestor ( newTable , 'TABLE' ) && UI . utils . ancestor ( newTable , 'TABLE' ) . style . backgroundColor === 'white' ) { newTable . style . backgroundColor = '#eee' } else { newTable . style . backgroundColor = 'white' } return newTable case 'Collection' : res = myDocument . createElement ( 'table' ) res . setAttribute ( 'class' , 'collectionAsTables' ) for ( var i = 0 ; i < obj . elements . length ; i ++ ) { var tr = myDocument . createElement ( 'tr' ) res . appendChild ( tr ) tr . appendChild ( objectTree ( obj . elements [ i ] ) ) } return res case 'Graph' : res = panes . dataContents . statementsAsTables ( obj . statements , myDocument ) res . setAttribute ( 'class' , 'nestedFormula' ) return res case 'Variable' : res = myDocument . createTextNode ( '?' + obj . uri ) return res } throw new Error ( 'Unhandled node type: ' + obj . termType ) }
2946	function setPackagesState ( app , dependencies , cb ) { var zealPacks = { } ; let promises = [ ] ; _ . forEach ( dependencies , function ( val , key ) { buildPackagesList ( app , zealPacks , val , key , promises ) ; } ) ; Promise . all ( promises ) . then ( ( ) => { app . emit ( 'zealder packages loaded' ) ; if ( cb ) cb ( zealPacks ) ; } ) ; }
2162	function ( element , parent , options ) { options = options || { } ; $mdUtil . disableScrollAround . _count = Math . max ( 0 , $mdUtil . disableScrollAround . _count || 0 ) ; $mdUtil . disableScrollAround . _count ++ ; if ( $mdUtil . disableScrollAround . _restoreScroll ) { return $mdUtil . disableScrollAround . _restoreScroll ; } var body = $document [ 0 ] . body ; var restoreBody = disableBodyScroll ( ) ; var restoreElement = disableElementScroll ( parent ) ; return $mdUtil . disableScrollAround . _restoreScroll = function ( ) { if ( -- $mdUtil . disableScrollAround . _count <= 0 ) { restoreBody ( ) ; restoreElement ( ) ; delete $mdUtil . disableScrollAround . _restoreScroll ; } } ; function disableElementScroll ( element ) { element = angular . element ( element || body ) ; var scrollMask ; if ( options . disableScrollMask ) { scrollMask = element ; } else { scrollMask = angular . element ( '<div class="md-scroll-mask">' + ' <div class="md-scroll-mask-bar"></div>' + '</div>' ) ; element . append ( scrollMask ) ; } scrollMask . on ( 'wheel' , preventDefault ) ; scrollMask . on ( 'touchmove' , preventDefault ) ; return function restoreElementScroll ( ) { scrollMask . off ( 'wheel' ) ; scrollMask . off ( 'touchmove' ) ; if ( ! options . disableScrollMask && scrollMask [ 0 ] . parentNode ) { scrollMask [ 0 ] . parentNode . removeChild ( scrollMask [ 0 ] ) ; } } ; function preventDefault ( e ) { e . preventDefault ( ) ; } } function disableBodyScroll ( ) { var documentElement = $document [ 0 ] . documentElement ; var prevDocumentStyle = documentElement . style . cssText || '' ; var prevBodyStyle = body . style . cssText || '' ; var viewportTop = $mdUtil . getViewportTop ( ) ; var clientWidth = body . clientWidth ; var hasVerticalScrollbar = body . scrollHeight > body . clientHeight + 1 ; var scrollElement = documentElement . scrollTop > 0 ? documentElement : body ; if ( hasVerticalScrollbar ) { angular . element ( body ) . css ( { position : 'fixed' , width : '100%' , top : - viewportTop + 'px' } ) ; } if ( body . clientWidth < clientWidth ) { body . style . overflow = 'hidden' ; } if ( hasVerticalScrollbar ) { documentElement . style . overflowY = 'scroll' ; } return function restoreScroll ( ) { body . style . cssText = prevBodyStyle ; documentElement . style . cssText = prevDocumentStyle ; scrollElement . scrollTop = viewportTop ; } ; } }
2049	function ( msg ) { if ( msg && msg . message && msg . message . message && msg . message . message . binary ) { var out = [ ] , i = 0 ; for ( i = 0 ; i < msg . message . message . binary . length ; i += 1 ) { out . push ( new Buffer ( new Uint8Array ( msg . message . message . binary [ i ] ) ) ) ; } msg . message . message . binary = out ; } process . send ( msg ) ; }
2770	function mat3from4 ( out , mat4x4 ) { out [ 0 ] [ 0 ] = mat4x4 [ 0 ] out [ 0 ] [ 1 ] = mat4x4 [ 1 ] out [ 0 ] [ 2 ] = mat4x4 [ 2 ] out [ 1 ] [ 0 ] = mat4x4 [ 4 ] out [ 1 ] [ 1 ] = mat4x4 [ 5 ] out [ 1 ] [ 2 ] = mat4x4 [ 6 ] out [ 2 ] [ 0 ] = mat4x4 [ 8 ] out [ 2 ] [ 1 ] = mat4x4 [ 9 ] out [ 2 ] [ 2 ] = mat4x4 [ 10 ] }
3442	function removeCaretContainer ( caretContainer ) { var child , currentCaretContainer , lastContainer ; if ( caretContainer ) { rng = selection . getRng ( true ) ; rng . setStartBefore ( caretContainer ) ; rng . setEndBefore ( caretContainer ) ; child = findFirstTextNode ( caretContainer ) ; if ( child && child . nodeValue . charAt ( 0 ) == invisibleChar ) { child = child . deleteData ( 0 , 1 ) ; } dom . remove ( caretContainer , true ) ; selection . setRng ( rng ) ; } else { currentCaretContainer = getParentCaretContainer ( selection . getStart ( ) ) ; while ( ( caretContainer = dom . get ( caretContainerId ) ) && caretContainer !== lastContainer ) { if ( currentCaretContainer !== caretContainer ) { child = findFirstTextNode ( caretContainer ) ; if ( child && child . nodeValue . charAt ( 0 ) == invisibleChar ) { child = child . deleteData ( 0 , 1 ) ; } dom . remove ( caretContainer , true ) ; } lastContainer = caretContainer ; } } }
738	function ( args ) { var opts = { auth : null , headers : { } , } ; if ( args . length > 0 ) { var arg = args [ args . length - 1 ] ; if ( utils . isAuthKey ( arg ) ) { opts . auth = args . pop ( ) ; } else if ( utils . isOptionsHash ( arg ) ) { var params = args . pop ( ) ; var extraKeys = Object . keys ( params ) . filter ( function ( key ) { return OPTIONS_KEYS . indexOf ( key ) == - 1 ; } ) ; if ( extraKeys . length ) { emitWarning ( 'Invalid options found (' + extraKeys . join ( ', ' ) + '); ignoring.' ) ; } if ( params . api_key ) { opts . auth = params . api_key ; } if ( params . idempotency_key ) { opts . headers [ 'Idempotency-Key' ] = params . idempotency_key ; } if ( params . stripe_account ) { opts . headers [ 'Stripe-Account' ] = params . stripe_account ; } if ( params . stripe_version ) { opts . headers [ 'Stripe-Version' ] = params . stripe_version ; } } } return opts ; }
1137	function compareAscending ( a , b ) { var ac = a . criteria , bc = b . criteria ; if ( ac !== bc ) { if ( ac > bc || typeof ac == 'undefined' ) { return 1 ; } if ( ac < bc || typeof bc == 'undefined' ) { return - 1 ; } } return a . index - b . index ; }
7	async function getAdopter ( name ) { try { const policyResponse = await ecr . getRepositoryPolicy ( { repositoryName : name } ) . promise ( ) ; const policy = JSON . parse ( policyResponse . policyText ) ; return ( policy . Statement || [ ] ) . find ( ( x ) => x . Action === markerStatement . Action ) || { } ; } catch ( e ) { if ( e . code !== 'RepositoryPolicyNotFoundException' ) { throw e ; } return { } ; } }
1146	function mixin ( object , source ) { var ctor = object , isFunc = ! source || isFunction ( ctor ) ; if ( ! source ) { ctor = lodashWrapper ; source = object ; object = lodash ; } forEach ( functions ( source ) , function ( methodName ) { var func = object [ methodName ] = source [ methodName ] ; if ( isFunc ) { ctor . prototype [ methodName ] = function ( ) { var value = this . __wrapped__ , args = [ value ] ; push . apply ( args , arguments ) ; var result = func . apply ( object , args ) ; if ( value && typeof value == 'object' && value === result ) { return this ; } result = new ctor ( result ) ; result . __chain__ = this . __chain__ ; return result ; } ; } } ) ; }
3322	function ( ) { var args = { } ; this . getAssignments ( ) . forEach ( function ( assignment ) { args [ assignment . param . name ] = assignment . value ; } , this ) ; return args ; }
978	function isAppMediaMatch ( params , tokens , allAppTypes , appType ) { let expression = convertMediaQueryToJSExpression ( tokens , allAppTypes , appType ) ; try { return { value : eval ( expression ) , expression } ; } catch ( ex ) { throw new Error ( 'illegal style env media rule:' + params ) ; } }
2092	function superMethod ( methodname ) { var func = null ; var p = this . __proto__ ; if ( ! p ) throw new Error ( 'invalid parameters' ) ; for ( p = p . __proto__ ; ! isEmpty ( p ) ; p = p . __proto__ ) { var method = p [ methodname ] ; if ( typeof method === 'function' ) { func = method ; break ; } } if ( ! func ) throw new Error ( 'super method not found: ' + methodname ) ; return func ; }
2390	function ( iterator , context ) { var list = new ArrayList ; return list . add ( _ . sortBy ( this , iterator , context ) ) ; }
1158	function ( r ) { this . x += r . x ; this . y += r . y ; this . width += r . width ; this . height += r . height ; return this ; }
1014	function ( ) { const url = BASE_URL + '/drive/v2/about?fields=user' ; return this . _request ( 'GET' , url , { } ) . then ( function ( resp ) { try { const info = JSON . parse ( resp . responseText ) ; return Promise . resolve ( info ) ; } catch ( e ) { return Promise . reject ( e ) ; } } ) ; }
425	function ( ) { var entities = [ ] , e , delim , index = parserInput . i ; do { e = this . comment ( ) ; if ( e ) { entities . push ( e ) ; continue ; } e = this . addition ( ) || this . entity ( ) ; if ( e ) { entities . push ( e ) ; if ( ! parserInput . peek ( / ^\/[\/*] / ) ) { delim = parserInput . $char ( '/' ) ; if ( delim ) { entities . push ( new ( tree . Anonymous ) ( delim , index ) ) ; } } } } while ( e ) ; if ( entities . length > 0 ) { return new ( tree . Expression ) ( entities ) ; } }
2593	function inherits ( constructor , superConstructor ) { if ( constructor === undefined || constructor === null ) throw new TypeError ( 'The constructor to "inherits" must not be ' + 'null or undefined' ) ; if ( superConstructor === undefined || superConstructor === null ) throw new TypeError ( 'The super constructor to "inherits" must not ' + 'be null or undefined' ) ; if ( superConstructor . prototype === undefined ) throw new TypeError ( 'The super constructor to "inherits" must ' + 'have a prototype' ) ; constructor . super_ = superConstructor ; Object . setPrototypeOf ( constructor . prototype , superConstructor . prototype ) ; ProtoLib . killCacheForConstructor ( constructor ) ; return constructor ; }
2457	function ( options ) { EventEmitter . apply ( this , arguments ) ; options = options || { } ; this . limit = options . limit || 16 ; this . json = options . json || false ; this . records = options . records || [ ] ; }
1376	function replaceIdsRecursively ( doc ) { _ . each ( doc , function ( val , key ) { if ( key === 'workflowGuidAndLocaleDuplicates' ) { return ; } if ( ( typeof ( val ) === 'string' ) && ( val . length < 100 ) ) { if ( idsToNew [ val ] ) { self . apos . utils . warn ( 'Correcting ' + doc [ key ] + ' to ' + idsToNew [ val ] + ' in join' ) ; doc [ key ] = idsToNew [ val ] ; modified = true ; } } else if ( val && ( typeof ( val ) === 'object' ) ) { replaceIdsRecursively ( val ) ; } } ) ; }
408	function ( t ) { return function ( ) { var obj = Object . create ( t . prototype ) ; t . apply ( obj , Array . prototype . slice . call ( arguments , 0 ) ) ; return obj ; } ; }
1533	function ( baseDir , importPath ) { var parts = importPath . split ( '/' ) ; var pathname = path . join ( baseDir , importPath ) ; if ( parts [ 0 ] === 'node_modules' ) { importPath = parts . slice ( 1 ) . join ( '/' ) ; } var dirs = findNodeModules ( { cwd : baseDir , relative : false } ) ; _ . each ( dirs , function ( dir ) { if ( fs . existsSync ( path . join ( dir , importPath ) ) ) { pathname = path . join ( dir , importPath ) ; return false ; } } ) ; return pathname ; }
115	function setTitle ( ) { var label = i18n . get ( 'play' , this . config ) ; if ( is$1 . string ( this . config . title ) && ! is$1 . empty ( this . config . title ) ) { label += ", " . concat ( this . config . title ) ; } Array . from ( this . elements . buttons . play || [ ] ) . forEach ( function ( button ) { button . setAttribute ( 'aria-label' , label ) ; } ) ; if ( this . isEmbed ) { var iframe = getElement . call ( this , 'iframe' ) ; if ( ! is$1 . element ( iframe ) ) { return ; } var title = ! is$1 . empty ( this . config . title ) ? this . config . title : 'video' ; var format = i18n . get ( 'frameTitle' , this . config ) ; iframe . setAttribute ( 'title' , format . replace ( '{title}' , title ) ) ; } }
1441	function ( callback ) { var t = this ; var className = this . __className ; t . __fatalCompileError = false ; t . __numClassesDefined = 0 ; fs . readFile ( this . getSourcePath ( ) , { encoding : "utf-8" } , function ( err , src ) { if ( err ) { callback ( err ) ; return ; } try { let options = t . __analyser . getBabelOptions ( ) || { } ; options . modules = false ; var config = { babelrc : false , sourceFileName : t . getSourcePath ( ) , filename : t . getSourcePath ( ) , sourceMaps : true , "presets" : [ [ require . resolve ( "@babel/preset-env" ) , options ] ] , plugins : [ t . _babelClassPlugin ( ) ] , parserOpts : { sourceType : "script" } , passPerPreset : true } ; var result = babelCore . transform ( src , config ) ; } catch ( ex ) { if ( ex . _babel ) { console . log ( ex ) ; } t . addMarker ( "compiler.syntaxError" , ex . loc , ex . message , ex . codeFrame ) ; t . __fatalCompileError = true ; t . _compileDbClassInfo ( ) ; callback ( ) ; return ; } if ( ! t . __numClassesDefined ) { t . addMarker ( "compiler.missingClassDef" ) ; t . __fatalCompileError = true ; t . _compileDbClassInfo ( ) ; callback ( ) ; return ; } if ( ! t . __metaDefinitions [ className ] ) { t . addMarker ( "compiler.wrongClassName" , null , className , Object . keys ( t . __metaDefinitions ) . join ( ", " ) ) ; t . _compileDbClassInfo ( ) ; } var pos = className . lastIndexOf ( "." ) ; var name = pos > - 1 ? className . substring ( pos + 1 ) : className ; var outputPath = t . getOutputPath ( ) ; util . mkParentPath ( outputPath , function ( err ) { if ( err ) { callback ( err ) ; return ; } fs . writeFile ( outputPath , result . code + "\n\n//# sourceMappingURL=" + \n + \n + name , ".js.map?dt=" , ( new Date ( ) . getTime ( ) ) ) ; } ) ; } ) ; }
1566	function traverse ( file ) { file = master . resolve ( file ) ; fs . stat ( file , function ( err , stat ) { if ( ! err ) { if ( stat . isDirectory ( ) ) { if ( ~ exports . ignoreDirectories . indexOf ( basename ( file ) ) ) return ; fs . readdir ( file , function ( err , files ) { files . map ( function ( f ) { return file + '/' + f ; } ) . forEach ( traverse ) ; } ) ; } else { watch ( file ) ; } } } ) ; }
518	function _handleKey ( character , modifiers , e ) { var self = this ; if ( ! self . recording ) { _origHandleKey . apply ( self , arguments ) ; return ; } if ( e . type == 'keydown' ) { if ( character . length === 1 && _recordedCharacterKey ) { _recordCurrentCombo ( ) ; } for ( i = 0 ; i < modifiers . length ; ++ i ) { _recordKey ( modifiers [ i ] ) ; } _recordKey ( character ) ; } else if ( e . type == 'keyup' && _currentRecordedKeys . length > 0 ) { _recordCurrentCombo ( ) ; } }
2650	function pivotTable ( dataset ) { var column_names = [ ] ; var xvalues = [ ] ; var values = { } ; var rows = { } ; for ( rn in dataset . data ) { if ( rn == 0 ) { continue ; } var val1 = dataset . data [ rn ] [ 0 ] ; var val2 = dataset . data [ rn ] [ 1 ] ; if ( column_names . indexOf ( val2 ) == - 1 ) { column_names . push ( val2 ) ; } if ( xvalues . indexOf ( val1 ) == - 1 ) { xvalues . push ( val1 ) ; } if ( ! ( val1 in values ) ) { values [ val1 ] = [ ] ; } values [ val1 ] [ val2 ] = dataset . data [ rn ] [ 2 ] ; } for ( n in xvalues ) { var val1 = xvalues [ n ] ; rows [ val1 ] = [ ] ; for ( m in column_names ) { var val2 = column_names [ m ] ; if ( val1 in values && val2 in values [ val1 ] ) { rows [ val1 ] . push ( values [ val1 ] [ val2 ] ) ; } else { rows [ val1 ] . push ( null ) ; } } } var res = [ ] ; column_names . unshift ( dataset . fields [ 0 ] . name ) ; res . push ( column_names ) ; xvalues . forEach ( function ( item ) { var r = [ item ] . concat ( rows [ item ] ) ; res . push ( r ) ; } ) ; return res ; }
3222	function deployRules ( { client , rules , secret } ) { const lastRequest = rulesRequests . get ( client . projectId ) ; return Promise . resolve ( lastRequest ) . then ( oldRulesHash => { const newRuleHash = hash ( rules ) ; if ( oldRulesHash === newRuleHash ) { return oldRulesHash ; } const request = client . rules ( { rules , secret } ) ; rulesRequests . set ( client . projectId , request . then ( ( ) => newRuleHash , ( ) => oldRulesHash ) ) ; return request ; } ) ; }
239	function cleanupRepliesCache ( ) { const keysToRemove = [ ] ; try { for ( let i = 0 ; i < localStorage . length ; i ++ ) { const storedReplyKey = localStorage . key ( i ) ; if ( 'reply_' == localStorage . key ( i ) . substring ( 0 , 6 ) ) { const storedReply = getItem ( storedReplyKey ) ; if ( storedReply && Date . now ( ) - storedReply [ 1 ] >= 24 * 60 * 60 * 1000 ) { keysToRemove . push ( storedReplyKey ) ; } } } } catch ( e ) { debug ( 'couldnt cleanup cache' ) ; } keysToRemove . forEach ( function ( key ) { removeItem ( key ) ; } ) ; }
1526	function ( command , parameters , callback ) { if ( typeof parameters === 'function' ) { callback = parameters ; parameters = { } ; } parameters || ( parameters = { } ) ; parameters . command = command ; parameters . nonce = nonce ( ) ; const options = { method : 'POST' , url : PRIVATE_API_URL , form : parameters , headers : this . _getPrivateHeaders ( parameters ) } ; return this . _request ( options , callback ) ; }
588	function handleSeries ( seriesContainer ) { loader . free ( ) ; loader = null ; let stack = seriesContainer [ 0 ] . mergeSeries ( seriesContainer ) [ 0 ] . stack [ 0 ] ; let stackHelper = new HelpersStack ( stack ) ; stackHelper . bbox . visible = false ; stackHelper . borderColor = '#2196F3' ; stackHelper . border . visible = false ; scene . add ( stackHelper ) ; let worldbb = stack . worldBoundingBox ( ) ; let lpsDims = new THREE . Vector3 ( ( worldbb [ 1 ] - worldbb [ 0 ] ) / 2 , ( worldbb [ 3 ] - worldbb [ 2 ] ) / 2 , ( worldbb [ 5 ] - worldbb [ 4 ] ) / 2 ) ; let box = { center : stack . worldCenter ( ) . clone ( ) , halfDimensions : new THREE . Vector3 ( lpsDims . x + 10 , lpsDims . y + 10 , lpsDims . z + 10 ) , } ; let canvas = { width : threeD . clientWidth , height : threeD . clientHeight , } ; camera . directions = [ stack . xCosine , stack . yCosine , stack . zCosine ] ; camera . box = box ; camera . canvas = canvas ; camera . update ( ) ; camera . fitBox ( 2 ) ; updateLabels ( camera . directionsLabel , stack . modality ) ; buildGUI ( stackHelper ) ; hookCallbacks ( stackHelper ) ; }
2440	function returnCache ( cache ) { let text = '' ; for ( const key in cache ) { if ( ! cache . hasOwnProperty ( key ) ) { continue ; } text += cache [ key ] ; } return text ; }
2761	function bufferContents ( file , enc , cb ) { if ( file . isNull ( ) ) { return cb ( ) ; } if ( file . isStream ( ) ) { this . emit ( 'error' , new PluginError ( 'gulp-livingcss' , 'Streaming not supported' ) ) ; return cb ( ) ; } files . push ( file . path ) ; cb ( ) ; }
2777	function walkNodes ( $nodes , currentItem ) { $nodes . each ( function ( i , node ) { var $node = $ ( node ) ; var props = splitUnique ( $node . attr ( 'itemprop' ) ) ; if ( props && currentItem ) { var value = null ; if ( $node . is ( '[itemscope]' ) ) { value = parseItem ( node , currentItem ) ; } else { value = parsePropertyValue ( node ) ; walkNodes ( $node . children ( ) , currentItem ) ; } currentItem . addProperties ( props , value ) ; } else if ( $node . is ( '[itemscope]' ) && ! $node . is ( '[itemprop]' ) ) { var newItem = parseItem ( node , currentItem ) ; if ( newItem !== Item . ERROR ) { items . push ( newItem ) ; } } else { walkNodes ( $node . children ( ) , currentItem ) ; } } ) ; }
2674	function messageHandler ( ) { var message = messages . read ( arguments , _session . signer ) ; if ( ! message ) { return ; } var handler = _session . handlers [ message . header . msg_type ] ; if ( handler ) { handler ( message ) ; } }
1888	function ( input ) { var output = [ ] ; var chr1 , chr2 , chr3 , enc1 , enc2 , enc3 , enc4 , cdp1 , cdp2 , cdp3 ; var i = 0 , il = input . length , b64 = chars ; while ( i < il ) { cdp1 = input . charCodeAt ( i ++ ) ; cdp2 = input . charCodeAt ( i ++ ) ; cdp3 = input . charCodeAt ( i ++ ) ; chr1 = cdp1 & 0xff ; chr2 = cdp2 & 0xff ; chr3 = cdp3 & 0xff ; enc1 = chr1 >> 2 ; enc2 = ( ( chr1 & 3 ) << 4 ) | ( chr2 >> 4 ) ; enc3 = ( ( chr2 & 15 ) << 2 ) | ( chr3 >> 6 ) ; enc4 = chr3 & 63 ; if ( isNaN ( cdp2 ) ) { enc3 = enc4 = 64 ; } else if ( isNaN ( cdp3 ) ) { enc4 = 64 ; } output . push ( b64 . charAt ( enc1 ) + b64 . charAt ( enc2 ) + b64 . charAt ( enc3 ) + b64 . charAt ( enc4 ) ) ; } return output . join ( '' ) ; }
110	function getLabel ( track ) { var currentTrack = track ; if ( ! is$1 . track ( currentTrack ) && support . textTracks && this . captions . toggled ) { currentTrack = captions . getCurrentTrack . call ( this ) ; } if ( is$1 . track ( currentTrack ) ) { if ( ! is$1 . empty ( currentTrack . label ) ) { return currentTrack . label ; } if ( ! is$1 . empty ( currentTrack . language ) ) { return track . language . toUpperCase ( ) ; } return i18n . get ( 'enabled' , this . config ) ; } return i18n . get ( 'disabled' , this . config ) ; }
537	async function build ( ) { console . error ( '* Building TensorFlow Node.js bindings' ) ; cp . exec ( 'node-gyp rebuild' , ( err ) => { if ( err ) { throw new Error ( 'node-gyp rebuild failed with: ' + err ) ; } } ) ; }
183	function apiKeySubmit ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT : case WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT_FAILURE : return WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT === type ; } return state ; }
1843	function handleError ( req , res , err ) { switch ( err . name ) { case 'NotFoundError' : render ( req , res , 'error' , err , { status : 404 } ) ; break ; default : render ( req , res , 'error' , err , { status : 500 } ) ; } }
2534	function create ( props ) { var multiButton = Object . create ( this ) ; _canvasWidget2 . default . create . call ( multiButton ) ; Object . assign ( multiButton , MultiButton . defaults , props ) ; if ( props . value ) { multiButton . __value = props . value ; } else { multiButton . __value = [ ] ; for ( var i = 0 ; i < multiButton . count ; i ++ ) { multiButton . __value [ i ] = 0 ; } multiButton . value = [ ] ; } multiButton . active = { } ; multiButton . __prevValue = [ ] ; multiButton . init ( ) ; return multiButton ; }
1885	function ( editor ) { var content = String ( editor . getContent ( ) ) ; var caretPos = editor . getCaretPos ( ) ; var tag = require ( 'htmlMatcher' ) . tag ( content , caretPos ) ; return tag && tag . open . name . toLowerCase ( ) == 'style' && tag . innerRange . cmp ( caretPos , 'lte' , 'gte' ) ; }
2069	function addTimeToArrayFromToken ( token , input , config ) { var a , datePartArray = config . _a ; switch ( token ) { case 'M' : case 'MM' : datePartArray [ 1 ] = ( input == null ) ? 0 : ~ ~ input - 1 ; break ; case 'MMM' : case 'MMMM' : a = getLangDefinition ( config . _l ) . monthsParse ( input ) ; if ( a != null ) { datePartArray [ 1 ] = a ; } else { config . _isValid = false ; } break ; case 'D' : case 'DD' : case 'DDD' : case 'DDDD' : if ( input != null ) { datePartArray [ 2 ] = ~ ~ input ; } break ; case 'YY' : datePartArray [ 0 ] = ~ ~ input + ( ~ ~ input > 68 ? 1900 : 2000 ) ; break ; case 'YYYY' : case 'YYYYY' : datePartArray [ 0 ] = ~ ~ input ; break ; case 'a' : case 'A' : config . _isPm = getLangDefinition ( config . _l ) . isPM ( input ) ; break ; case 'H' : case 'HH' : case 'h' : case 'hh' : datePartArray [ 3 ] = ~ ~ input ; break ; case 'm' : case 'mm' : datePartArray [ 4 ] = ~ ~ input ; break ; case 's' : case 'ss' : datePartArray [ 5 ] = ~ ~ input ; break ; case 'S' : case 'SS' : case 'SSS' : datePartArray [ 6 ] = ~ ~ ( ( '0.' + input ) * 1000 ) ; break ; case 'X' : config . _d = new Date ( parseFloat ( input ) * 1000 ) ; break ; case 'Z' : case 'ZZ' : config . _useUTC = true ; config . _tzm = timezoneMinutesFromString ( input ) ; break ; } if ( input == null ) { config . _isValid = false ; } }
3309	function validateType ( jsdocNode , type ) { if ( ! type || ! canTypeBeValidated ( type . type ) ) { return ; } var typesToCheck = [ ] ; var elements = [ ] ; switch ( type . type ) { case 'TypeApplication' : elements = type . applications [ 0 ] . type === 'UnionType' ? type . applications [ 0 ] . elements : type . applications ; typesToCheck . push ( getCurrentExpectedTypes ( type ) ) ; break ; case 'RecordType' : elements = type . fields ; break ; case 'UnionType' : case 'ArrayType' : elements = type . elements ; break ; case 'FieldType' : typesToCheck . push ( getCurrentExpectedTypes ( type . value ) ) ; break ; default : typesToCheck . push ( getCurrentExpectedTypes ( type ) ) ; } elements . forEach ( validateType . bind ( null , jsdocNode ) ) ; typesToCheck . forEach ( function ( typeToCheck ) { if ( typeToCheck . expectedType && typeToCheck . expectedType !== typeToCheck . currentType ) { context . report ( { node : jsdocNode , message : 'Use \'{{expectedType}}\' instead of \'{{currentType}}\'.' , \' } ) ; } } ) ; }
1372	function parseForwarded ( value ) { const forwarded = { } value . trim ( ) . split ( ';' ) . forEach ( ( part ) => { const pair = part . trim ( ) . split ( '=' ) ; forwarded [ pair [ 0 ] ] = pair [ 1 ] ; } ) ; return forwarded ; }
582	function messageHandlerSendWithPromise ( actionName , data , transfers ) { var callbackId = this . callbackIndex ++ ; var message = { action : actionName , data : data , callbackId : callbackId } ; var capability = createPromiseCapability ( ) ; this . callbacksCapabilities [ callbackId ] = capability ; try { this . postMessage ( message , transfers ) ; } catch ( e ) { capability . reject ( e ) ; } return capability . promise ; }
2921	function templateFromFile ( path ) { forcedTemplateName = 'singleton' ; if ( cache . hasOwnProperty ( templateSrc ) ) { registry . singleton = cache [ templateSrc ] ; return ; } var deferred = cache [ templateSrc ] = registry . singleton = new Deferred ( ) ; fs . readFile ( templateSrc , 'utf-8' , function ( err , data ) { try { if ( err ) throw err ; var template = compile ( { data : data , name : templateSrc , path : templateSrc } ) ; deferred . resolve ( template ) ; } catch ( err2 ) { deferred . reject ( err2 ) ; } } ) ; }
245	function getParent ( node , className ) { while ( node && node . parentNode ) { if ( node . className && ( ' ' + node . className + ' ' ) . indexOf ( ' ' + className + ' ' ) !== - 1 ) { return node ; } node = node . parentNode ; } return false ; }
1450	function ( name ) { var scope = this . __scope ; if ( ! scope . ignore ) { scope . ignore = { } ; } var segs = name . split ( "," ) ; segs . forEach ( name => { if ( name . endsWith ( ".*" ) ) { scope . ignore [ name ] = name . substring ( 0 , name . length - 2 ) ; } else if ( name . endsWith ( "*" ) ) { scope . ignore [ name ] = name . substring ( 0 , name . length - 1 ) ; } else { scope . ignore [ name ] = true ; } } ) ; }
2347	function ensureIndexesForDataset ( datasetId ) { createIndexForCollection ( getDatasetRecordsCollectionName ( datasetId ) , { 'uid' : 1 } , { } ) ; createIndexForCollection ( getDatasetRecordsCollectionName ( datasetId ) , { 'refs' : 1 } , { } ) ; createIndexForCollection ( require ( './sync-updates' ) . getDatasetUpdatesCollectionName ( datasetId ) , { 'cuid' : 1 , 'hash' : 1 } , { } ) ; }
1835	function handleError ( err , req , res ) { switch ( err . name ) { case 'NotFoundError' : res . send ( err , 404 ) ; break ; default : res . send ( err , 500 ) ; } }
1611	function writeIIFEStub ( ctx ) { writeRamdaFunctionAsGlobalStub ( ctx ) ctx . writeTop ( ';(function () {' ) ctx . newLine ( ) ctx . newLine ( ) ctx . write ( '})()' ) }
1971	function invalidate ( { accessToken , clientToken } ) { return fetch ( ` ${ YGGDRASIL_API } ` , { method : 'POST' , body : JSON . stringify ( { accessToken , clientToken } ) , headers : { 'user-agent' : USER_AGENT , 'content-type' : 'application/json' } } ) . then ( handleErrors ) . then ( res => null ) }
862	function getDefaultVersion ( filename ) { const info = getPackageJson ( filename ) const nodeVersion = info && info . engines && info . engines . node return semver . validRange ( nodeVersion ) || DEFAULT_VERSION }
2926	function deepGet ( obj , path ) { var get_parent = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : ! 1 ; if ( ! ( 0 , _object . isObject ) ( obj ) ) throw new TypeError ( 'Deepget is only supported for objects' ) ; var parts = interpolatePath ( path ) ; if ( parts . length === 0 || parts . length === 1 && get_parent ) return obj ; if ( get_parent ) parts . pop ( ) ; var cursor = obj ; while ( parts . length > 0 ) { cursor = ( 0 , _array . isArray ) ( cursor ) ? cursor [ parseInt ( parts . shift ( ) ) ] : cursor [ parts . shift ( ) ] ; } return cursor || cursor === ! 1 || cursor === 0 || cursor === '' ? cursor : undefined ; }
3556	function makeExtendableConstructor ( constructor ) { var extender = function ( constructor_ , methods_ , statics_ ) { return defineSubClass ( constructor , constructor_ , methods_ , statics_ ) ; } ; constructor . extend = constructor . extendWith = extender ; return constructor ; }
2311	function onprogress ( data ) { debug ( 'got "progress" event: %o' , data ) ; const xhr = requests [ data . callbackId ] ; if ( xhr ) { const prog = new ProgressEvent ( 'progress' , data ) ; const target = data . upload ? xhr . upload : xhr ; target . dispatchEvent ( prog ) ; } }
472	function isElement ( obj ) { return ! ! ( ( typeof HTMLElement === 'undefined' ? 'undefined' : _typeof ( HTMLElement ) ) === 'object' ? obj instanceof HTMLElement : obj && ( typeof obj === 'undefined' ? 'undefined' : _typeof ( obj ) ) === 'object' && obj !== null && obj . nodeType === 1 && typeof obj . nodeName === 'string' ) ; }
1736	function authTileLoader ( fetchOptions ) { return function ( tile , src ) { fetch ( src , fetchOptions ) . then ( r => r . blob ( ) ) . then ( ( imgData ) => { tile . getImage ( ) . src = URL . createObjectURL ( imgData ) ; } ) . catch ( ( ) => { console . error ( 'Error fetchimg image at:' , src ) ; } ) ; } ; }
1051	function flag ( values , value , flags ) { return flags && own . call ( values , value ) && flags . indexOf ( values [ value ] ) !== - 1 }
2165	function MdToastController ( $mdToast , $scope ) { this . $onInit = function ( ) { var self = this ; if ( self . highlightAction ) { $scope . highlightClasses = [ 'md-highlight' , self . highlightClass ] ; } $scope . $watch ( function ( ) { return activeToastContent ; } , function ( ) { self . content = activeToastContent ; } ) ; this . resolve = function ( ) { $mdToast . hide ( ACTION_RESOLVE ) ; } ; } ; }
3328	function ( ev , hashId , keyCode ) { var stopEvent ; if ( keyCode === keys . TAB || keyCode === keys . UP || keyCode === keys . DOWN ) { stopEvent = true ; } else if ( hashId != 0 || keyCode != 0 ) { stopEvent = canon . execKeyCommand ( this . env , 'cli' , hashId , keyCode ) ; } stopEvent && event . stopEvent ( ev ) ; }
3097	function ( parent , records , toAdd ) { var me = this , ln = records ? records . length : 0 , i , record ; if ( ! me . recursive && parent !== me . node ) { return ; } if ( parent !== this . node && ! me . isVisible ( parent ) ) { return ; } if ( ln ) { for ( i = 0 ; i < ln ; i ++ ) { record = records [ i ] ; toAdd . push ( record ) ; if ( record . isExpanded ( ) ) { if ( record . isLoaded ( ) ) { me . handleNodeExpand ( record , record . childNodes , toAdd ) ; } else { record . set ( 'expanded' , false ) ; record . expand ( ) ; } } } } }
1411	function pipe ( ) { var _this = this ; var items = [ ] ; for ( var _i = 0 ; _i < arguments . length ; _i ++ ) { items [ _i ] = arguments [ _i ] ; } var _done = false ; var targets = items . map ( wrap_async_iterable_iterator_1 . wrapAsyncIterableIterator ) ; var call = function ( methodName , value ) { return new Promise ( function ( resolve , reject ) { var remaining = targets . concat ( ) ; var next = function ( _a ) { var value = _a . value , done = _a . done ; if ( ! _done ) { _done = done ; } if ( ! remaining . length || _done ) { if ( methodName === "next" ) { while ( remaining . length ) { ( remaining . shift ( ) . return || ( function ( ) { } ) ) ( ) ; } } return resolve ( { value : value , done : done } ) ; } var fn = remaining . shift ( ) [ methodName ] ; return fn ? fn ( value ) . then ( next , reject ) : next ( value ) ; } ; next ( { value : value , done : false } ) ; } ) ; } ; return _a = { } , _a [ Symbol . asyncIterator ] = function ( ) { return _this ; } , _a . next = call . bind ( this , "next" ) , _a . return = call . bind ( this , "return" ) , _a . throw = call . bind ( this , "throw" ) , _a ; var _a ; }
1629	function addClass ( element , className ) { var classNames = className ; function _addClass ( el , cn ) { if ( ! el . className ) { el . className = cn ; } else if ( ! hasClass ( el , cn ) ) { if ( el . classList ) { el . classList . add ( cn ) ; } else { el . className += ' ' + cn ; } } } if ( ! isArray ( className ) ) { classNames = className . trim ( ) . split ( / \s+ / ) ; } classNames . forEach ( _addClass . bind ( null , element ) ) ; return element ; }
405	function deleteDB ( name , { blocked } = { } ) { const request = indexedDB . deleteDatabase ( name ) ; if ( blocked ) request . addEventListener ( 'blocked' , ( ) => blocked ( ) ) ; return wrap ( request ) . then ( ( ) => undefined ) ; }
2552	function getRawTag$1 ( value ) { var isOwn = hasOwnProperty$7 . call ( value , symToStringTag$1 ) , tag = value [ symToStringTag$1 ] ; try { value [ symToStringTag$1 ] = undefined ; } catch ( e ) { } var result = nativeObjectToString$1 . call ( value ) ; { if ( isOwn ) { value [ symToStringTag$1 ] = tag ; } else { delete value [ symToStringTag$1 ] ; } } return result ; }
1860	function ( name , value ) { if ( arguments . length == 2 ) { var ix = _ . indexOf ( _ . pluck ( this . _attributes , 'name' ) , name . toLowerCase ( ) ) ; if ( ~ ix ) { this . _attributes [ ix ] . value = value ; } else { this . _attributes . push ( { name : name , value : value } ) ; } } return ( _ . find ( this . attributeList ( ) , function ( attr ) { return attr . name == name ; } ) || { } ) . value ; }
2349	function diff ( datasetClientJson , localRecords , next ) { var recordsDiff = diffRecords ( syncUtil . convertToObject ( localRecords ) , syncUtil . convertToObject ( records ) ) ; return next ( null , datasetClientJson , recordsDiff ) ; }
1651	function ( when , len , attrs ) { var x = time_x ( when ) ; var end_y = ui . y + len ; var e = paper . path ( "M" + x + "," + ui . y + " " + "L" + x + "," + end_y ) . attr ( attrs || { } ) ; return e ; }
251	function AccountPasswordData ( ) { this . validatedPassword = null ; this . charsets = { lowerChars : 'abcdefghjkmnpqrstuvwxyz' . split ( '' ) , upperChars : 'ABCDEFGHJKMNPQRSTUVWXYZ' . split ( '' ) , digitChars : '23456789' . split ( '' ) , specialChars : '!@#$%^&*' . split ( '' ) , } ; this . letterCharsets = pick ( this . charsets , [ 'lowerChars' , 'upperChars' ] ) ; }
3425	function ( id , lastEditId , readyCb ) { addViewTasks . push ( { id : id , lastEditId : lastEditId , cb : readyCb } ) if ( ! hasViews ) { poll ( ) } hasViews = true }
730	function ( $el ) { var caret = Math . min ( this . caretPos , this . items . length ) ; var el = $el [ 0 ] ; var target = this . buffer || this . $control [ 0 ] ; if ( caret === 0 ) { target . insertBefore ( el , target . firstChild ) ; } else { target . insertBefore ( el , target . childNodes [ caret ] ) ; } this . setCaret ( caret + 1 ) ; }
331	function setCanvasData ( data ) { var canvasData = this . canvasData ; var aspectRatio = canvasData . aspectRatio ; if ( this . ready && ! this . disabled && isPlainObject ( data ) ) { if ( isNumber ( data . left ) ) { canvasData . left = data . left ; } if ( isNumber ( data . top ) ) { canvasData . top = data . top ; } if ( isNumber ( data . width ) ) { canvasData . width = data . width ; canvasData . height = data . width / aspectRatio ; } else if ( isNumber ( data . height ) ) { canvasData . height = data . height ; canvasData . width = data . height * aspectRatio ; } this . renderCanvas ( true ) ; } return this ; }
3423	function ( ) { var me = this , cfg = { app : me , menu : [ ] } , launcher ; Ext . apply ( cfg , me . startConfig ) ; Ext . each ( me . modules , function ( module ) { launcher = module . launcher ; if ( launcher ) { launcher . handler = launcher . handler || Ext . bind ( me . createWindow , me , [ module ] ) ; cfg . menu . push ( module . launcher ) ; } } ) ; return cfg ; }
2161	function duration_humanize__getSetRelativeTimeThreshold ( threshold , limit ) { if ( thresholds [ threshold ] === undefined ) { return false ; } if ( limit === undefined ) { return thresholds [ threshold ] ; } thresholds [ threshold ] = limit ; return true ; }
157	function sanitizeExtra ( data ) { const path = data . _contactDetailsCache ? [ '_contactDetailsCache' , 'extra' ] : 'extra' ; return data && isArray ( get ( data , path ) ) ? omit ( data , path ) : data ; }
1301	function ProcessInternals ( info_node ) { info_node . new_start_pos = chunk_it . TranslatePos ( info_node . info . start_position ) ; var child_index = 0 ; var code_changed = false ; var source_changed = false ; while ( ! chunk_it . done ( ) && chunk_it . current ( ) . pos1 < info_node . info . end_position ) { if ( child_index < info_node . children . length ) { var child = info_node . children [ child_index ] ; if ( child . info . end_position <= chunk_it . current ( ) . pos1 ) { ProcessUnchangedChild ( child ) ; child_index ++ ; continue ; } else if ( child . info . start_position >= chunk_it . current ( ) . pos1 + chunk_it . current ( ) . len1 ) { code_changed = true ; chunk_it . next ( ) ; continue ; } else if ( child . info . start_position <= chunk_it . current ( ) . pos1 && child . info . end_position >= chunk_it . current ( ) . pos1 + chunk_it . current ( ) . len1 ) { ProcessInternals ( child ) ; source_changed = source_changed || ( child . status != FunctionStatus . UNCHANGED ) ; code_changed = code_changed || ( child . status == FunctionStatus . DAMAGED ) ; child_index ++ ; continue ; } else { code_changed = true ; child . status = FunctionStatus . DAMAGED ; child . status_explanation = "Text diff overlaps with function boundary" ; child_index ++ ; continue ; } } else { if ( chunk_it . current ( ) . pos1 + chunk_it . current ( ) . len1 <= info_node . info . end_position ) { info_node . status = FunctionStatus . CHANGED ; chunk_it . next ( ) ; continue ; } else { info_node . status = FunctionStatus . DAMAGED ; info_node . status_explanation = "Text diff overlaps with function boundary" ; return ; } } Assert ( "Unreachable" , false ) ; } while ( child_index < info_node . children . length ) { var child = info_node . children [ child_index ] ; ProcessUnchangedChild ( child ) ; child_index ++ ; } if ( code_changed ) { info_node . status = FunctionStatus . CHANGED ; } else if ( source_changed ) { info_node . status = FunctionStatus . SOURCE_CHANGED ; } info_node . new_end_pos = chunk_it . TranslatePos ( info_node . info . end_position ) ; }
197	function maybeWithinRefundPeriod ( purchase ) { if ( isRefundable ( purchase ) ) { return true ; } return ( 'undefined' !== typeof purchase . subscribedDate && 'undefined' !== typeof purchase . refundPeriodInDays && moment ( ) . diff ( moment ( purchase . subscribedDate ) , 'days' ) <= purchase . refundPeriodInDays ) ; }
551	function extraIndentVal ( nodes , i ) { var subset = [ ] ; var declaration = nodes . get ( i ) ; if ( ! declaration . is ( 'declaration' ) ) return ; for ( var x = declaration . length ; x -- ; ) { if ( ! declaration . get ( x ) . is ( 'value' ) ) continue ; x -- ; while ( ! declaration . get ( x ) . is ( 'propertyDelimiter' ) ) { subset . push ( declaration . get ( x ) ) ; x -- ; } break ; } return extraIndent ( subset ) ; }
3023	function weight ( word ) { return HAMMING_TABLE [ ( word >> 0x00 ) & 0xF ] + HAMMING_TABLE [ ( word >> 0x04 ) & 0xF ] + HAMMING_TABLE [ ( word >> 0x08 ) & 0xF ] + HAMMING_TABLE [ ( word >> 0x0C ) & 0xF ] + HAMMING_TABLE [ ( word >> 0x10 ) & 0xF ] + HAMMING_TABLE [ ( word >> 0x14 ) & 0xF ] + HAMMING_TABLE [ ( word >> 0x18 ) & 0xF ] + HAMMING_TABLE [ ( word >> 0x1C ) & 0xF ] ; }
3516	function LoaderCache ( options ) { if ( ! ( this instanceof LoaderCache ) ) { return new LoaderCache ( options ) ; } this . options = options || { } ; this . defaultType = this . options . defaultType || 'sync' ; this . types = [ ] ; this . decorate ( 'resolve' ) ; this . decorate ( 'get' ) ; }
3174	function addFeatureOption ( name , kind ) { if ( kind === EXPERIMENTAL ) experimentalOptions [ name ] = true ; Object . defineProperty ( parseOptions , name , { get : function ( ) { return ! ! options [ name ] ; } , enumerable : true , configurable : true } ) ; Object . defineProperty ( transformOptions , name , { get : function ( ) { var v = options [ name ] ; if ( v === 'parse' ) return false ; return v ; } , enumerable : true , configurable : true } ) ; var defaultValue = options [ name ] || kind === ON_BY_DEFAULT ; options [ name ] = defaultValue ; defaultValues [ name ] = defaultValue ; }
3311	function SelectionType ( typeSpec ) { if ( ! Array . isArray ( typeSpec . data ) && typeof typeSpec . data !== 'function' ) { throw new Error ( 'instances of SelectionType need typeSpec.data to be an array or function that returns an array:' + JSON . stringify ( typeSpec ) ) ; } Object . keys ( typeSpec ) . forEach ( function ( key ) { this [ key ] = typeSpec [ key ] ; } , this ) ; }
3561	function unConfigurableNamespace ( ns_string , objToSearch , valueToSet ) { var parent = objToSearch , shouldSetValue = typeof valueToSet !== _undefined , hasOwnProperty ; ns_string . split ( '.' ) . forEach ( function ( key , i , parts ) { hasOwnProperty = parent . hasOwnProperty ( key ) ; if ( i === parts . length - 1 && shouldSetValue && ! hasOwnProperty ) { defineEnumProp ( parent , key , valueToSet ) ; } else if ( typeof parent [ key ] === _undefined && ! hasOwnProperty ) { defineEnumProp ( parent , key , { } ) ; } parent = parent [ key ] ; } ) ; return parent ; }
2400	function ( definedLogLevels ) { logLevels = this . _merge ( definedLogLevels ) ; for ( var key in winston . loggers . loggers ) { var logger = winston . loggers . loggers [ key ] ; if ( logLevels [ 'all' ] ) { if ( logLevels [ 'all' ] != 'none' ) { if ( logger . transports . console ) { logger . transports . console . level = logLevels [ 'all' ] ; } else { logger . add ( winston . transports . Console , { level : logLevels [ 'all' ] , json : false , timestamp : true , label : key , align : true } , false ) ; } } else { logger . remove ( winston . transports . Console ) } } else { var level = logLevels [ key ] ; if ( logger . transports . console ) { if ( level != 'none' ) { logger . transports . console . level = level ; } else { logger . remove ( winston . transports . Console ) } } } } return this ; }
3253	function ( childItems ) { var length = childItems . length , index , childContext ; for ( index = 0 ; index < length ; ++ index ) { childContext = childItems [ index ] ; childContext . setProp ( 'x' , childContext . layoutPos . x + childContext . marginInfo . left ) ; childContext . setProp ( 'y' , childContext . layoutPos . y + childContext . marginInfo . top ) ; } }
304	function removeListener ( element , type , listener ) { var options = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : { } ; var handler = listener ; type . trim ( ) . split ( REGEXP_SPACES ) . forEach ( function ( event ) { if ( ! onceSupported ) { var listeners = element . listeners ; if ( listeners && listeners [ event ] && listeners [ event ] [ listener ] ) { handler = listeners [ event ] [ listener ] ; delete listeners [ event ] [ listener ] ; if ( Object . keys ( listeners [ event ] ) . length === 0 ) { delete listeners [ event ] ; } if ( Object . keys ( listeners ) . length === 0 ) { delete element . listeners ; } } } element . removeEventListener ( event , handler , options ) ; } ) ; }
1447	function ( name ) { var pos = name . indexOf ( "." ) ; if ( pos > - 1 ) { name = name . substring ( 0 , pos ) ; } for ( var tmp = this . __scope ; tmp ; tmp = tmp . parent ) { if ( tmp . vars [ name ] !== undefined ) { return true ; } } return false ; }
2819	function ( xhr , options , promise ) { var instance = this , url = options . url , method = options . method || GET , headers = options . headers ? options . headers . itsa_deepClone ( ) : { } , async = ! options . sync , data = options . data , reject = promise . reject , sendPayload , additionalData ; if ( ! xhr ) { console . error ( NAME , "_initXHR fails: " + ERROR_NO_XHR ) ; reject ( ERROR_NO_XHR ) ; return ; } headers . itsa_merge ( instance . _standardHeaders ) ; method = method . toUpperCase ( ) ; if ( BODY_METHODS [ method ] ) { url = url . split ( "?" ) ; url [ 1 ] && ( additionalData = instance . _queryStringToDataObject ( url [ 1 ] ) ) ; if ( additionalData && ! additionalData . itsa_isEmpty ( ) ) { data || ( data = { } ) ; data . itsa_merge ( additionalData ) ; } url = url [ 0 ] ; } else if ( data && ( headers [ CONTENT_TYPE ] !== MIME_BLOB ) ) { url += ( url . itsa_contains ( "?" ) ? "&" : "?" ) + instance . _toQueryString ( data ) ; } xhr . open ( method , url , async ) ; options . responseType && ( xhr . responseType = options . responseType ) ; options . withCredentials && ( xhr . withCredentials = true ) ; instance . _xhrInitList . forEach ( function ( fn ) { fn ( xhr , promise , headers , method ) ; } ) ; if ( BODY_METHODS [ method ] && data ) { if ( headers [ CONTENT_TYPE ] === MIME_BLOB ) { if ( ! xhr . _isXDR ) { sendPayload = data ; } } else { sendPayload = ( ( headers [ CONTENT_TYPE ] === MIME_JSON ) || xhr . _isXDR ) ? JSON . stringify ( data ) : instance . _toQueryString ( data ) ; } } xhr . send ( sendPayload ) ; promise . abort = function ( ) { reject ( ABORTED ) ; xhr . _aborted = true ; xhr . abort ( ) ; } ; async || xhr . onreadystatechange ( ) ; }
3801	function processFile ( file ) { var changed = true ; while ( changed && ! file . processed ) { changed = false ; changed = processWraps ( file ) ; changed = processInserts ( file ) ; } file . processed = true ; }
979	function normalizeAppMediaQueryTokens ( tokens ) { for ( let i = tokens . length - 1 ; i >= 0 ; i -- ) { let item = tokens [ i ] . trim ( ) ; if ( item && item !== '(' ) { break ; } tokens . pop ( ) ; } }
1405	function ReadableByteStreamControllerClose ( controller ) { const stream = controller . _controlledReadableStream ; assert ( controller . _closeRequested === false ) ; assert ( stream . _state === 'readable' ) ; if ( controller . _totalQueuedBytes > 0 ) { controller . _closeRequested = true ; return ; } if ( controller . _pendingPullIntos . length > 0 ) { const firstPendingPullInto = controller . _pendingPullIntos [ 0 ] ; if ( firstPendingPullInto . bytesFilled > 0 ) { const e = new TypeError ( 'Insufficient bytes to fill elements in the given buffer' ) ; ReadableByteStreamControllerError ( controller , e ) ; throw e ; } } ReadableStreamClose ( stream ) ; }
3564	function mergeOnPropsMulti ( obj1 , obj2 ) { var args = argsToArray ( arguments ) , deep = extractBoolFromArrayStart ( args ) , arg0 = args . shift ( ) ; args . forEach ( function ( arg ) { if ( ! isObject ( arg ) ) { return ; } mergeOnProps ( arg0 , arg , deep ) ; } ) ; return arg0 ; }
1556	function withTimeout ( promise , delay , message ) { let timeout ; const timeoutPromise = new Promise ( ( resolve , reject ) => { const error = message instanceof Error ? message : new Error ( message || 'Operation timed out.' ) ; timeout = setTimeout ( reject , delay , error ) ; } ) ; return Promise . race ( [ promise , timeoutPromise ] ) . then ( ( value ) => { clearTimeout ( timeout ) ; return value ; } , ( err ) => { clearTimeout ( timeout ) ; throw err ; } ) ; }
3530	function build ( mode , system , cdef , out , cb ) { var cmd = cdef . specific . processBuild || cdef . specific . build ; var branch = '' ; logger . info ( 'building' ) ; out . stdout ( 'building' ) ; if ( ! cmd ) { return cb ( null , { } ) ; } if ( ! cdef . specific . repositoryUrl ) { return cb ( new Error ( 'missing repositoryUrl' ) , { } ) ; } var parsed = parseGitUrl ( cdef . specific . repositoryUrl ) ; if ( parsed . branch ) { branch = parsed . branch ; } if ( cdef . specific . commit ) { var synchCommand = [ [ ' ( ' + 'test `git show-ref --hash refs/heads/' + branch + '` = ' + cdef . specific . commit , ' && ' , 'git checkout -q ' + branch , ' ) ' , ' || ' , 'git checkout -q ' + cdef . specific . commit ] . join ( ' ' ) , 'echo checked out ' + cdef . specific . commit , ] . join ( ' && ' ) ; executor . exec ( mode , synchCommand , pathFromRepoUrl ( system , cdef ) , out , function ( err ) { if ( err ) { return cb ( err ) ; } executor . exec ( mode , cmd , pathFromRepoUrl ( system , cdef ) , out , cb ) ; } ) ; } else { executor . exec ( mode , cmd , pathFromRepoUrl ( system , cdef ) , out , cb ) ; } }
0	function getCounts ( langs = [ ] ) { return { langs : langs . length , modelLangs : langs . filter ( ( { models } ) => models && ! ! models . length ) . length , models : langs . map ( ( { models } ) => ( models ? models . length : 0 ) ) . reduce ( ( a , b ) => a + b , 0 ) , } }
1578	function createRelation ( type , product ) { return { type , text : product . presskit . title , path : getAbsolutePageUrl ( product . path , product . presskit . type ) } }
1091	function install ( cef_version ) { downloadCef ( cef_version , function ( err ) { if ( err ) { util . log ( 'Failed to add dependencies' , 'error' ) ; throw err ; } copyDllWrapper ( function ( err ) { if ( err ) { util . log ( 'Failed to copy dll_wrapper.gyp' ) ; throw err ; } util . log ( 'Done!' ) ; } ) ; } ) ; }
3284	function parseOptions ( options = { } , vinylCjsDeps ) { const _options = Object . assign ( { gulp : vinylCjsDeps . gulp || require ( 'gulp' ) , base : options . cwd || process . cwd ( ) , cwd : options . base || process . cwd ( ) , internalOnly : false , debugVcjd : false } , options ) ; _options . mapper = Object . assign ( { } , options . mapper || { } ) ; _options . lookup = new Map ( options . lookup || [ ] ) ; _options . resolver = createResolver ( options ) ; return _options ; }
3234	function ( pos , direction , e , preventWrap , verifierFn , scope ) { if ( direction == 'left' ) { direction = 'up' ; } else if ( direction == 'right' ) { direction = 'down' ; } pos = Ext . view . Table . prototype . walkCells . call ( this , pos , direction , e , preventWrap , verifierFn , scope ) ; if ( pos && ! pos . column ) { pos . column = 1 ; } return pos ; }
1605	function readFromStdin ( cb ) { var chunks = [ ] var stdin = process . stdin stdin . resume ( ) stdin . setEncoding ( 'utf8' ) stdin . on ( 'data' , function ( chunk ) { chunks . push ( chunk ) } ) stdin . on ( 'end' , function ( ) { cb ( chunks . join ( ' ' ) ) } ) }
2798	function initModel ( config ) { if ( typeof config . bookshelfModel . prototype . schema === 'undefined' ) { config . bookshelfModel . prototype . schema = { } } addConstraintsForForeignKeys ( config . bookshelfModel , config . baseQuery ) config . bookshelfModel . prototype . format = tableColumnRenamer . renameOnFormat config . bookshelfModel . prototype . parse = tableColumnRenamer . renameOnParse initJsonDateFormat ( config . bookshelfModel ) }
1992	function processStdin ( opts , stylize , callback ) { var leftover = '' ; var stdin = process . stdin ; stdin . resume ( ) ; stdin . setEncoding ( 'utf8' ) ; stdin . on ( 'data' , function ( chunk ) { var lines = chunk . split ( / \r\n|\n / ) ; var length = lines . length ; if ( length === 1 ) { leftover += lines [ 0 ] ; return ; } if ( length > 1 ) { handleLogLine ( null , leftover + lines [ 0 ] , opts , stylize ) ; } leftover = lines . pop ( ) ; length -= 1 ; for ( var i = 1 ; i < length ; i ++ ) { handleLogLine ( null , lines [ i ] , opts , stylize ) ; } } ) ; stdin . on ( 'end' , function ( ) { if ( leftover ) { handleLogLine ( null , leftover , opts , stylize ) ; leftover = '' ; } callback ( ) ; } ) ; }
1330	function validateUnicodeGroupName ( name , state ) { const isUnicodeName = uRe . test ( name ) || ucpRe . test ( name ) ; const isUnicodeState = ( state === 'u' || state === 'xu' || state === 'u_class' ) ; if ( isUnicodeName && ! isUnicodeState ) { throw new SyntaxError ( ` ${ name } \` \` ` ) ; } }
2111	function noCallbackHandler ( ctx , connectMiddleware , next ) { connectMiddleware ( ctx . req , ctx . res ) return next ( ) }
735	function convertCase ( style ) { const converted = { } for ( const prop in style ) { const key = prop . indexOf ( '--' ) === 0 ? prop : hyphenate ( prop ) converted [ key ] = style [ prop ] } if ( style . fallbacks ) { if ( Array . isArray ( style . fallbacks ) ) converted . fallbacks = style . fallbacks . map ( convertCase ) else converted . fallbacks = convertCase ( style . fallbacks ) } return converted }
1042	function onTablesSelected ( tables ) { steps . collect = mapValues ( steps . collect , function ( method ) { return partial ( method , adapter , { tables : tables } ) ; } ) ; async . parallel ( steps . collect , onTableDataCollected ) ; }
445	function generateDataArray ( props , axis ) { const propsDomain = isPlainObject ( props . domain ) ? props . domain [ axis ] : props . domain ; const domain = propsDomain || Scale . getBaseScale ( props , axis ) . domain ( ) ; const samples = props . samples || 1 ; const domainMax = Math . max ( ... domain ) ; const domainMin = Math . min ( ... domain ) ; const step = ( domainMax - domainMin ) / samples ; const values = range ( domainMin , domainMax , step ) ; return last ( values ) === domainMax ? values : values . concat ( domainMax ) ; }
896	function handleOnFilter ( file , filterName ) { let usedFilters = file . filters ; usedFilters || ( usedFilters = file . filters = [ ] ) ; if ( ! usedFilters . includes ( filterName ) ) { usedFilters . push ( filterName ) ; } }
1571	function getElementHeight ( element ) { var clone = element . cloneNode ( true ) clone . style . cssText = 'visibility: hidden; display: block; margin: -999px 0' var height = ( element . parentNode . appendChild ( clone ) ) . clientHeight element . parentNode . removeChild ( clone ) return height }
2811	function ( expected , actual , msg ) { bender . assert . areSame ( js_beautify ( expected , this . _config ) , js_beautify ( actual , this . _config ) , msg ) ; }
1811	function ( tagName , options , children ) { var e = env . doc . createElement ( tagName ) ; utils . forEach ( options || { } , function ( value , name ) { if ( name == 'style' ) { e . style . cssText = value ; } else if ( name == 'html' ) { e . innerHTML = value ; } else if ( name == 'className' ) { e . className = value ; } else { e . setAttribute ( name , value ) ; } } ) ; children && utils . forEach ( children , function ( c ) { e . appendChild ( c ) ; } ) ; return e ; }
1730	function _updateView ( event ) { var index = this . tabBar . getSelectedItemIndex ( ) ; this . animationController . halt ( ) ; if ( index >= 0 ) { this . animationController . show ( this . _items [ index ] . view ) ; } else { this . animationController . hide ( ) ; } }
337	function ( ) { if ( this . items . length ) { var f = document . createDocumentFragment ( ) ; if ( this . config . pagination ) { var pages = this . pages . slice ( 0 , this . pageIndex ) ; util . each ( pages , function ( i , items ) { util . each ( items , function ( j , item ) { appendItem ( item , f , this . customOption ) ; } , this ) ; } , this ) ; } else { util . each ( this . items , function ( i , item ) { appendItem ( item , f , this . customOption ) ; } , this ) ; } if ( f . childElementCount ) { util . removeClass ( this . items [ this . navIndex ] , "active" ) ; this . navIndex = f . querySelector ( ".selectr-option" ) . idx ; util . addClass ( this . items [ this . navIndex ] , "active" ) ; } this . tree . appendChild ( f ) ; } }
2716	function processCondition ( condition , errorMessage ) { if ( ! condition ) { var completeErrorMessage = '' ; var re = / at ([^\s]+)\s\( / g ; var stackTrace = new Error ( ) . stack ; var stackFunctions = [ ] ; var funcName = re . exec ( stackTrace ) ; while ( funcName && funcName [ 1 ] ) { stackFunctions . push ( funcName [ 1 ] ) ; funcName = re . exec ( stackTrace ) ; } if ( stackFunctions [ 2 ] ) { completeErrorMessage = stackFunctions [ 2 ] + ': ' + completeErrorMessage ; } completeErrorMessage += errorMessage ; return completeErrorMessage ; } return null ; }
3818	function LoadspriteCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 2 ) throw new SyntaxError ( 'LOADSPRITE command requires 2 arguments' ) ; else if ( parsed . args . length > 2 && parsed . args . length < 5 ) throw new SyntaxError ( 'LOADSPRITE command requires 5 arguments' ) ; this . id = parsed . args [ 0 ] ; if ( parsed . args . length > 2 ) { this . x1 = parsed . args [ 1 ] ; this . y1 = parsed . args [ 2 ] ; this . x2 = parsed . args [ 3 ] ; this . y2 = parsed . args [ 4 ] ; } else { this . fileName = parsed . args [ 1 ] ; } }
2996	function hmacVerify ( input , algorithm , secret , signature ) { try { const verify = signature === hmacSign ( input , algorithm , secret ) if ( ! verify ) { errorMap [ '006' ] . message = 'Unvalid secret for hmac verify, signature verification failed' errorMap [ '006' ] . error = new Error ( errorMap [ '006' ] . message ) } return verify } catch ( e ) { errorMap [ '006' ] . message = 'Exception error in hamc verify, signature verification failed' errorMap [ '006' ] . error = e return false } }
1153	function ( x , y ) { var svg = this . svg ( ) . node ; var p = svg . createSVGPoint ( ) ; p . x = x ; p . y = y ; try { var globalPoint = p . matrixTransform ( svg . getScreenCTM ( ) . inverse ( ) ) ; var globalToLocalMatrix = this . node . getTransformToElement ( svg ) . inverse ( ) ; } catch ( e ) { return p ; } return globalPoint . matrixTransform ( globalToLocalMatrix ) ; }
1779	function expandUrl ( url , base ) { if ( ! base ) return url ; if ( url . match ( / ^(\/|https?:\/\/) / ) ) return url ; if ( base . substr ( base . length - 1 ) !== '/' ) { base = base + '/' ; } return base + url ; }
3069	function ( ) { var tip = this . tip ; if ( ! tip ) { tip = this . tip = Ext . create ( 'Ext.tip.QuickTip' , { ui : 'form-invalid' } ) ; tip . tagConfig = Ext . apply ( { } , { attribute : 'errorqtip' } , tip . tagConfig ) ; } }
2005	function FontLoader ( fontFamiliesArray , delegate , timeout ) { this . delegate = delegate ; this . timeout = ( typeof timeout !== "undefined" ) ? timeout : 3000 ; this . _fontFamiliesArray = fontFamiliesArray . slice ( 0 ) ; this . _testContainer = null ; this . _adobeBlankSizeWatcher = null ; this . _timeoutId = null ; this . _intervalId = null ; this . _intervalDelay = 50 ; this . _numberOfLoadedFonts = 0 ; this . _numberOfFontFamilies = this . _fontFamiliesArray . length ; this . _fontsMap = { } ; this . _finished = false ; }
755	function ( event , g , context ) { if ( context . cancelNextDblclick ) { context . cancelNextDblclick = false ; return ; } var e = { canvasx : context . dragEndX , canvasy : context . dragEndY , cancelable : true , } ; if ( g . cascadeEvents_ ( 'dblclick' , e ) ) { return ; } if ( event . altKey || event . shiftKey ) { return ; } g . resetZoom ( ) ; }
3361	function ( direction ) { var me = this ; me . direction = direction ? direction . toUpperCase ( ) : direction ; me . updateSortFunction ( ) ; }
2565	function create ( props ) { var button = Object . create ( this ) ; _canvasWidget2 . default . create . call ( button ) ; Object . assign ( button , Button . defaults , props ) ; if ( props . value ) button . __value = props . value ; button . init ( ) ; return button ; }
3394	function daysInMonth ( month , year ) { switch ( month ) { case 1 : case 3 : case 5 : case 7 : case 8 : case 10 : case 12 : return 31 ; case 4 : case 6 : case 9 : case 11 : return 30 ; case 2 : var leapyear ; if ( year % 4 != 0 ) { leapyear = false ; } else if ( year % 100 != 0 ) { leapyear = true ; } else if ( year % 400 != 0 ) { leapyear = false ; } else { leapyear = true ; } if ( leapyear ) { return 29 ; } else { return 28 ; } default : throw new Error ( 'Unknown Month' ) ; } }
781	function ( ) { var collection = _logContainer . childNodes ; var i = collection . length ; if ( i === 0 ) { return ; } while ( i ) { _filterElement ( collection [ i - 1 ] ) ; i -= 1 ; } window . scrollTo ( 0 , document . body . scrollHeight ) ; }
3505	function checkIndentInArrayOrObjectBlock ( node ) { if ( isSingleLineNode ( node ) ) { return ; } var elements = ( node . type === "ArrayExpression" ) ? node . elements : node . properties ; elements = elements . filter ( function ( elem ) { return elem !== null ; } ) ; if ( elements . length > 0 && elements [ 0 ] . loc . start . line === node . loc . start . line ) { return ; } var nodeIndent ; var elementsIndent ; var parentVarNode = getVariableDeclaratorNode ( node ) ; if ( isNodeFirstInLine ( node ) ) { var parent = node . parent ; var effectiveParent = parent ; if ( parent . type === "MemberExpression" ) { if ( isNodeFirstInLine ( parent ) ) { effectiveParent = parent . parent . parent ; } else { effectiveParent = parent . parent ; } } nodeIndent = getNodeIndent ( effectiveParent ) ; if ( parentVarNode && parentVarNode . loc . start . line !== node . loc . start . line ) { if ( parent . type !== "VariableDeclarator" || parentVarNode === parentVarNode . parent . declarations [ 0 ] ) { if ( parentVarNode . loc . start . line === effectiveParent . loc . start . line ) { nodeIndent = nodeIndent + ( indentSize * options . VariableDeclarator [ parentVarNode . parent . kind ] ) ; } else if ( parent . type === "ObjectExpression" || parent . type === "ArrayExpression" || parent . type === "CallExpression" || parent . type === "ArrowFunctionExpression" || parent . type === "NewExpression" ) { nodeIndent = nodeIndent + indentSize ; } } } else if ( ! parentVarNode && ! isFirstArrayElementOnSameLine ( parent ) && effectiveParent . type !== "MemberExpression" && effectiveParent . type !== "ExpressionStatement" && effectiveParent . type !== "AssignmentExpression" && effectiveParent . type !== "Property" ) { nodeIndent = nodeIndent + indentSize ; } elementsIndent = nodeIndent + indentSize ; checkFirstNodeLineIndent ( node , nodeIndent ) ; } else { nodeIndent = getNodeIndent ( node ) ; elementsIndent = nodeIndent + indentSize ; } if ( isNodeInVarOnTop ( node , parentVarNode ) ) { elementsIndent += indentSize * options . VariableDeclarator [ parentVarNode . parent . kind ] ; } if ( node . parent && node . parent . type === "CallExpression" && node . parent . arguments . length > 1 && isNodeFirstArgument ( node ) && isNodeOnSameLineAsPrevious ( node ) && isNextArgumentOnNextLine ( node ) ) { elementsIndent += indentSize ; } checkNodesIndent ( elements , elementsIndent , true ) ; if ( elements . length > 0 ) { if ( elements [ elements . length - 1 ] . loc . end . line === node . loc . end . line ) { return ; } } var lastIndent = elementsIndent - indentSize ; checkLastNodeLineIndent ( node , lastIndent ) ; }
2059	function ( toolbarKey , toolKey ) { if ( toolbars [ toolbarKey ] ) toolbars [ toolbarKey ] . updateToolDisplay ( toolKey , taTools [ toolKey ] , true ) ; else throw ( 'textAngular Error: No Toolbar with name "' + toolbarKey + '" exists' ) ; }
122	function publish ( bundleId , pathsNotFound ) { if ( ! bundleId ) return ; var q = bundleCallbackQueue [ bundleId ] ; bundleResultCache [ bundleId ] = pathsNotFound ; if ( ! q ) return ; while ( q . length ) { q [ 0 ] ( bundleId , pathsNotFound ) ; q . splice ( 0 , 1 ) ; } }
3271	function ( item ) { if ( ! item ) { return ; } var me = this , sprite = item . sprite , opts = Ext . merge ( { } , me . highlightCfg , me . highlight ) , surface = me . chart . surface , animate = me . chart . animate , p , from , to , pi ; if ( ! me . highlight || ! sprite || sprite . _highlighted ) { return ; } if ( sprite . _anim ) { sprite . _anim . paused = true ; } sprite . _highlighted = true ; if ( ! sprite . _defaults ) { sprite . _defaults = Ext . apply ( { } , sprite . attr ) ; from = { } ; to = { } ; for ( p in opts ) { if ( ! ( p in sprite . _defaults ) ) { sprite . _defaults [ p ] = surface . availableAttrs [ p ] ; } from [ p ] = sprite . _defaults [ p ] ; to [ p ] = opts [ p ] ; if ( Ext . isObject ( opts [ p ] ) ) { from [ p ] = { } ; to [ p ] = { } ; Ext . apply ( sprite . _defaults [ p ] , sprite . attr [ p ] ) ; Ext . apply ( from [ p ] , sprite . _defaults [ p ] ) ; for ( pi in sprite . _defaults [ p ] ) { if ( ! ( pi in opts [ p ] ) ) { to [ p ] [ pi ] = from [ p ] [ pi ] ; } else { to [ p ] [ pi ] = opts [ p ] [ pi ] ; } } for ( pi in opts [ p ] ) { if ( ! ( pi in to [ p ] ) ) { to [ p ] [ pi ] = opts [ p ] [ pi ] ; } } } } sprite . _from = from ; sprite . _to = to ; sprite . _endStyle = to ; } if ( animate ) { sprite . _anim = new Ext . fx . Anim ( { target : sprite , from : sprite . _from , to : sprite . _to , duration : 150 } ) ; } else { sprite . setAttributes ( sprite . _to , true ) ; } }
3529	function readAnalyserConfig ( analyserPath ) { var filePath = path . join ( analyserPath , 'config.json' ) ; return readFile ( filePath , { encoding : 'utf8' } ) . then ( function ( fileContents ) { try { return doResolve ( JSON . parse ( jsonWithComments ( fileContents ) ) ) ; } catch ( err ) { return doReject ( ` ${ analyserPath } ` , err ) ; } } , function ( err ) { return doReject ( ` ${ analyserPath } ` , err ) ; } ) ; }
2792	function eatBraces ( stream , root ) { if ( stream . eat ( LBRACE ) ) { let stack = 1 , token ; while ( ! stream . eof ( ) ) { if ( stream . eat ( RBRACE ) ) { stack -- ; if ( ! stack ) { break ; } } else if ( stream . eat ( LBRACE ) ) { stack ++ ; } else if ( eatUrl ( stream ) || eatString ( stream ) ) { continue ; } else if ( token = comment ( stream ) ) { root . addComment ( token ) ; continue ; } else { stream . next ( ) ; } } return true ; } return false ; }
3727	function getKey ( propNode ) { if ( propNode . key . type === "Literal" ) { return propNode . key . value ; } if ( propNode . key . type === "Identifier" ) { return propNode . key . name ; } }
852	function enforceModuleExports ( ) { const globalScope = context . getScope ( ) const exportsNodes = getExportsNodes ( globalScope ) const assignList = batchAssignAllowed ? createAssignmentList ( getModuleExportsNodes ( globalScope ) ) : [ ] for ( const node of exportsNodes ) { if ( assignList . length > 0 && assignList . indexOf ( getTopAssignment ( node ) ) !== - 1 ) { continue } context . report ( { node , loc : getLocation ( node ) , message : "Unexpected access to 'exports'. Use 'module.exports' instead." , } ) } }
2664	function smsGetCampaignCost ( callback , sender_name , body , addressbook_id , phones ) { if ( sender_name === undefined ) { return callback ( returnError ( "Empty sender name" ) ) ; } if ( body === undefined ) { return callback ( returnError ( "Empty sms text" ) ) ; } if ( ( addressbook_id === undefined ) || ( phones === undefined ) || ( ! phones . length ) ) { return callback ( returnError ( "Empty book id or phones" ) ) ; } var data = { 'sender' : sender_name , 'body' : body , 'addressBookId' : addressbook_id } if ( phones . length ) { data [ 'phones' ] = JSON . stringify ( phones ) ; } sendRequest ( 'sms/campaigns/cost' , 'GET' , data , true , callback ) ; }
1523	function nodesOverlap ( nodeA , nodeB ) { if ( nodeA . y0 > nodeB . y0 && nodeA . y0 < nodeB . y1 ) { return true } else if ( nodeA . y1 > nodeB . y0 && nodeA . y1 < nodeB . y1 ) { return true } else if ( nodeA . y0 < nodeB . y0 && nodeA . y1 > nodeB . y1 ) { return true } else { return false } }
2405	function addKnockoutArrayMutators ( ko , array , subscribable , signal ) { var fnNames = [ 'remove' , 'removeAll' , 'destroy' , 'destroyAll' , 'replace' ] ; fnNames . forEach ( function ( fnName ) { Object . defineProperty ( array , fnName , { enumerable : false , value : function ( ) { var result ; signal . pause = true ; try { var fn = ko . observableArray . fn [ fnName ] ; result = fn . apply ( ko . observableArray ( array ) , arguments ) ; } finally { signal . pause = false ; } subscribable . notifySubscribers ( array ) ; return result ; } } ) ; } ) ; }
2358	function ( datasetId , acknowledgement , callback ) { return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doFindAndDeleteUpdate ) ( datasetId , acknowledgement , callback ) ; }
1424	async function ( library , locale ) { var t = this ; var id = locale + ":" + library . getNamespace ( ) ; var translation = t . __translations [ id ] ; if ( ! translation ) { translation = t . __translations [ id ] = new qx . tool . compiler . app . Translation ( library , locale ) ; await translation . checkRead ( ) ; } return translation ; }
1542	function formatDate ( date , format , relative , localeCode ) { var adu , loc = getLocalization ( localeCode ) , caps = regexp ( / ^[A-Z] / ) , value , shortcut ; if ( ! date . isValid ( ) ) { return 'Invalid Date' ; } else if ( Date [ format ] ) { format = Date [ format ] ; } else if ( isFunction ( format ) ) { adu = getAdjustedUnitWithMonthFallback ( date ) ; format = format . apply ( date , adu . concat ( loc ) ) ; } if ( ! format && relative ) { adu = adu || getAdjustedUnitWithMonthFallback ( date ) ; if ( adu [ 1 ] === 0 ) { adu [ 1 ] = 1 ; adu [ 0 ] = 1 ; } return loc . getRelativeFormat ( adu ) ; } format = format || 'long' ; format = loc [ format ] || format ; DateOutputFormats . forEach ( function ( dof ) { format = format . replace ( regexp ( '\\{(' + \\ + dof . token , ')(\\d)?\\}' ) , \\ ) ; } ) ; \\ }
956	function initBabelProcessorOptions ( file , processorOpts , buildManager ) { processorOpts = Object . assign ( { } , buildManager . babelConfig , processorOpts ) ; let plugins = normalizeBabelPlugins ( processorOpts . plugins , file , buildManager ) ; let configInitHandler = initConfigInfo . bind ( null , buildManager , 'config' , file ) ; let appBaseClass = buildManager . getOutputAppBaseClass ( ) ; let pluginOpts = { appType : buildManager . appType , config : configInitHandler } ; let filterOptions = buildManager . getFilterTransformOptions ( ) ; let enableMixinSupport = buildManager . isEnableMixinSupport ( ) ; let { api , framework , localPolyfill , polyfill } = buildManager . buildConf ; let getInitOptions = buildManager . getAppBaseClassInitOptions . bind ( buildManager , file ) ; if ( file . isEntryScript ) { Object . assign ( pluginOpts , { framework , registerApi : api , baseClass : appBaseClass && appBaseClass . app } ) ; localPolyfill || ( pluginOpts . polyfill = polyfill ) ; pluginOpts . getInitOptions = getInitOptions ; plugins . push ( [ programPlugins . app , pluginOpts ] ) ; } else if ( file . isPageScript ) { Object . assign ( pluginOpts , { enableMixinSupport , filterOptions , tplRefs : file . tplRefs , baseClass : appBaseClass && appBaseClass . page , getInitOptions } ) ; plugins . push ( [ programPlugins . page , pluginOpts ] ) ; } else if ( file . isComponentScript ) { Object . assign ( pluginOpts , { enableMixinSupport , filterOptions , tplRefs : file . tplRefs , baseClass : appBaseClass && appBaseClass . component , getInitOptions } ) ; plugins . push ( [ programPlugins . component , pluginOpts ] ) ; } else if ( file . isBehavior ) { plugins . push ( [ programPlugins . behavior , pluginOpts ] ) ; } if ( localPolyfill && ! file . compiled ) { initLocalPolyfillPlugins ( localPolyfill , plugins ) ; } processorOpts . plugins = plugins ; return processorOpts ; }
1586	function resetStyles ( stack ) { var stackClone = stack . slice ( 0 ) ; stack . length = 0 ; return stackClone . reverse ( ) . map ( function ( tag ) { return '</' + tag + '>' ; } ) . join ( '' ) ; }
84	function createMenuItem ( _ref ) { var _this3 = this ; var value = _ref . value , list = _ref . list , type = _ref . type , title = _ref . title , _ref$badge = _ref . badge , badge = _ref$badge === void 0 ? null : _ref$badge , _ref$checked = _ref . checked , checked = _ref$checked === void 0 ? false : _ref$checked ; var attributes = getAttributesFromSelector ( this . config . selectors . inputs [ type ] ) ; var menuItem = createElement ( 'button' , extend ( attributes , { type : 'button' , role : 'menuitemradio' , class : "" . concat ( this . config . classNames . control , " " ) . concat ( attributes . class ? attributes . class : '' ) . trim ( ) , 'aria-checked' : checked , value : value } ) ) ; var flex = createElement ( 'span' ) ; flex . innerHTML = title ; if ( is$1 . element ( badge ) ) { flex . appendChild ( badge ) ; } menuItem . appendChild ( flex ) ; Object . defineProperty ( menuItem , 'checked' , { enumerable : true , get : function get ( ) { return menuItem . getAttribute ( 'aria-checked' ) === 'true' ; } , set : function set ( checked ) { if ( checked ) { Array . from ( menuItem . parentNode . children ) . filter ( function ( node ) { return matches$1 ( node , '[role="menuitemradio"]' ) ; } ) . forEach ( function ( node ) { return node . setAttribute ( 'aria-checked' , 'false' ) ; } ) ; } menuItem . setAttribute ( 'aria-checked' , checked ? 'true' : 'false' ) ; } } ) ; this . listeners . bind ( menuItem , 'click keyup' , function ( event ) { if ( is$1 . keyboardEvent ( event ) && event . which !== 32 ) { return ; } event . preventDefault ( ) ; event . stopPropagation ( ) ; menuItem . checked = true ; switch ( type ) { case 'language' : _this3 . currentTrack = Number ( value ) ; break ; case 'quality' : _this3 . quality = value ; break ; case 'speed' : _this3 . speed = parseFloat ( value ) ; break ; default : break ; } controls . showMenuPanel . call ( _this3 , 'home' , is$1 . keyboardEvent ( event ) ) ; } , type , false ) ; controls . bindMenuItemShortcuts . call ( this , menuItem , type ) ; list . appendChild ( menuItem ) ; }
243	function isImageLargeEnoughForFeature ( image ) { if ( ! image ) { return false ; } const imageIsTallEnough = 100 <= image . width ; const imageIsWideEnough = 75 <= image . height ; return imageIsTallEnough && imageIsWideEnough ; }
3861	function attach ( node ) { if ( node && node . el && node . placeholder && node . placeholder . parentNode ) { node . placeholder . parentNode . replaceChild ( node . el , node . placeholder ) ; } }
1832	function loadScript ( src ) { return new Promise ( resolve => { const script = document . createElement ( 'script' ) ; script . onload = resolve ; script . src = src ; document . head . appendChild ( script ) ; } ) ; }
960	function initComponentData ( instance , options , isPage ) { let data = instance . data ; if ( isFunction ( data ) ) { instance . data = instance . data ( ) ; } instance . $init && instance . $init ( isPage , options ) ; }
3472	function ( node ) { var contentEditable ; if ( node . nodeType != 1 ) { return null ; } contentEditable = node . getAttribute ( "data-mce-contenteditable" ) ; if ( contentEditable && contentEditable !== "inherit" ) { return contentEditable ; } return node . contentEditable !== "inherit" ? node . contentEditable : null ; }
3017	function ( astList , context , callback ) { var retval = new Array ( astList . length ) ; asyncEach ( astList , function ( ast , i , done ) { run ( ast , context , function ( err , val ) { if ( err ) { callback ( err ) ; } else { retval [ i ] = val ; done ( ) ; } } ) ; } , callback , null , retval ) ; }
3380	function ( record , columnHeader ) { var me = this , grid = me . editingPlugin . grid , store = grid . store , view = grid . getView ( ) , context = me . context = Ext . apply ( me . editingPlugin . context , { view : view , store : store } ) ; if ( ! me . rendered ) { me . render ( view . el ) ; } context . grid . getSelectionModel ( ) . select ( record ) ; me . loadRecord ( record ) ; if ( ! me . isVisible ( ) ) { me . show ( ) ; } me . reposition ( { callback : this . focusContextCell } ) ; }
3836	function addChildren ( newData ) { var promises = [ ] ; newData . forEach ( function ( child ) { promises . push ( add ( child ) ) ; } ) ; return Promise . all ( promises ) . then ( emitValue ) ; }
2617	function keyOfMax ( o , func ) { if ( ! o || typeof o !== 'object' ) return o ; if ( libs . object . size ( o ) === 0 ) return ; if ( ! ( func instanceof Function ) ) func = undefined ; var max , maxValue , maxKey ; if ( ! func ) { max = libs . object . first ( o ) ; maxKey = libs . object . keys ( o ) [ 0 ] ; libs . object . each ( o , 1 , function ( item , key ) { if ( item >= max ) { max = item ; maxKey = key ; } } ) ; } else { max = libs . object . first ( o ) ; maxKey = libs . object . keys ( o ) [ 0 ] ; maxValue = func . call ( max , max ) ; libs . object . each ( o , 1 , function ( item , key ) { var value = func . call ( item , item ) ; if ( value >= maxValue ) { if ( value >= maxValue ) { max = item ; maxValue = value ; maxKey = key ; } } } ) ; } return maxKey ; }
2588	function ( n , symbol ) { if ( n === undefined || n === null || ! libs . object . isNumeric ( n ) ) return n ; n = libs . object . getNumeric ( n ) . toFixed ( 2 ) ; symbol = typeof symbol === 'string' ? symbol : '$' ; return n . replace ( / ^(-)?(\d+)\.(\d+)$ / , function ( $0 , $1 , $2 , $3 ) { $1 = $2 === '0' && $3 === '00' ? null : $1 ; return ( $1 || '' ) + symbol + libs . number . withPlaceholders ( $2 ) + '.' + $3 ; } ) ; }
3435	function ( array , comparisonFn ) { var min = array [ 0 ] , i , ln , item ; for ( i = 0 , ln = array . length ; i < ln ; i ++ ) { item = array [ i ] ; if ( comparisonFn ) { if ( comparisonFn ( min , item ) === 1 ) { min = item ; } } else { if ( item < min ) { min = item ; } } } return min ; }
3593	function ( raw ) { if ( typeof raw !== 'object' || raw === null || util . isArray ( raw ) ) { return false ; } if ( raw . wiretree ) { return true ; } return false ; }
788	function navigate ( n ) { var position = currentPosition ( ) ; var numSlides = document . getElementsByClassName ( 'slide' ) . length ; var nextPosition = ( position - 1 + n ) % numSlides + 1 ; nextPosition = ( nextPosition - 1 + numSlides ) % numSlides + 1 ; document . getElementById ( 'slide-' + position ) . classList . add ( 'hidden' ) ; document . getElementById ( 'slide-' + nextPosition ) . classList . remove ( 'hidden' ) ; updateProgress ( ) ; updateURL ( ) ; updateTabIndex ( ) ; }
2793	function underscore ( baseQuery ) { return _ . mapKeys ( baseQuery , function ( v , k ) { return tableColumnRenamer . underscore ( k ) } ) }
2958	function ( ) { if ( 3 == arguments . length ) { redis . hdel ( arguments [ 0 ] , arguments [ 1 ] , arguments [ 2 ] ) ; } else if ( 2 == arguments . length ) { redis . del ( arguments [ 0 ] , arguments [ 1 ] ) ; } }
2924	function getTemplateName ( data ) { for ( var i = 0 ; i < templateAttribute . length ; ++ i ) { if ( ! data ) return null ; data = data [ templateAttribute [ i ] ] ; } return data ; }
731	function ( templateName , data ) { var value , id , label ; var html = '' ; var cache = false ; var self = this ; var regex_tag = / ^[\t \r\n]*<([a-z][a-z0-9\-_]*(?:\:[a-z][a-z0-9\-_]*)?) / i ; if ( templateName === 'option' || templateName === 'item' ) { value = hash_key ( data [ self . settings . valueField ] ) ; cache = ! ! value ; } if ( cache ) { if ( ! isset ( self . renderCache [ templateName ] ) ) { self . renderCache [ templateName ] = { } ; } if ( self . renderCache [ templateName ] . hasOwnProperty ( value ) ) { return self . renderCache [ templateName ] [ value ] ; } } html = $ ( self . settings . render [ templateName ] . apply ( this , [ data , escape_html ] ) ) ; if ( templateName === 'option' || templateName === 'option_create' ) { if ( ! data [ self . settings . disabledField ] ) { html . attr ( 'data-selectable' , '' ) ; } } else if ( templateName === 'optgroup' ) { id = data [ self . settings . optgroupValueField ] || '' ; html . attr ( 'data-group' , id ) ; if ( data [ self . settings . disabledField ] ) { html . attr ( 'data-disabled' , '' ) ; } } if ( templateName === 'option' || templateName === 'item' ) { html . attr ( 'data-value' , value || '' ) ; } if ( cache ) { self . renderCache [ templateName ] [ value ] = html [ 0 ] ; } return html [ 0 ] ; }
2027	function ( plugin , callback ) { var cozyLight = require ( './cozy-light' ) ; var config = configHelpers . getConfig ( ) ; logger . info ( 'Removing ' + plugin + '...' ) ; if ( config . plugins [ plugin ] === undefined ) { logger . error ( plugin + ' is not installed.' ) ; nodeHelpers . invoke ( callback , true ) ; } else { var module = config . plugins [ plugin ] . name ; npmHelpers . uninstall ( module , function removePluginFromConfig ( err ) { if ( err ) { logger . raw ( err ) ; logger . error ( 'npm did not uninstall ' + plugin + ' correctly.' ) ; nodeHelpers . invoke ( callback , err ) ; } else { logger . info ( plugin + ' successfully uninstalled.' ) ; pluginHelpers . stop ( plugin , function ( ) { pluginHelpers . unloadPlugin ( plugin ) ; configHelpers . watcher . one ( callback ) ; configHelpers . removePlugin ( plugin ) ; } ) ; } } ) ; } }
2986	function ( res , scContent , post , cb ) { let model = this . _modelInfo ( scContent [ 'forModel' ] ) ; let fields = this . makeFormFields ( res , scContent ) ; let data = { } ; let where = null ; _ . forEach ( fields , function ( val ) { if ( val . isId ) { if ( post [ val . name ] ) where = { [ val . name ] : post [ val . name ] } } else if ( val . name in post ) { if ( val . embedIn ) { data [ val . embedIn ] = Object . assign ( { } , data [ val . embedIn ] , { [ val . name ] : post [ val . name ] } ) ; } else data [ val . name ] = post [ val . name ] ; } } ) ; if ( scContent . forceVals ) { _ . forEach ( scContent . forceVals , function ( val , key ) { data [ key ] = val ; } ) ; } if ( where ) { model . model . upsertWithWhere ( where , data , ( err , inst ) => { cb ( err , inst ) ; } ) ; } else { model . model . create ( data , ( err , inst ) => { cb ( err , inst ) ; } ) ; } }
1609	function parse ( src , opts ) { var parser = new Parser ( ) parser . yy = { parseError : util . parseError , filename : opts . filename } return parser . parse ( src ) }
3359	function ( value ) { var me = this , record ; me . value = value ; if ( me . store . loading ) { return me ; } record = value ? me . store . getNodeById ( value ) : me . store . getRootNode ( ) ; if ( value === undefined ) { record = me . store . getRootNode ( ) ; me . value = record . getId ( ) ; } else { record = me . store . getNodeById ( value ) ; } me . setRawValue ( record ? record . get ( me . displayField ) : '' ) ; return me ; }
2239	function SharedIniFileCredentials ( options ) { AWS . Credentials . call ( this ) ; options = options || { } ; this . filename = options . filename ; this . profile = options . profile || process . env . AWS_PROFILE || 'default' ; this . get ( function ( ) { } ) ; }
2641	function convertOfficialMap ( attributes ) { let map = { } for ( let attribute in attributes ) { let key = officialAttributeMap [ attribute ] map [ key ] = attributes [ attribute ] } return map }
170	function build_chunks ( sub_text , sub_ranges , range_data , container , options ) { let text_start = null , text_stop = null , i , remove_r_id , r_id , sr_id , range_id , range_info , new_i , new_sub_text , new_sub_range ; for ( i = 0 ; i < sub_ranges . length ; i ++ ) { if ( sub_ranges [ i ] . index . length == 0 ) { if ( text_start == null ) { text_start = i ; } } else { if ( text_start != null ) { text_stop = i ; container . appendChild ( document . createTextNode ( sub_text . substring ( text_start , text_stop ) ) ) ; text_start = null ; text_stop = null ; } remove_r_id = null ; for ( r_id in sub_ranges [ i ] . index ) { if ( null === remove_r_id || sub_ranges [ i ] . index [ r_id ] . len > sub_ranges [ i ] . index [ remove_r_id ] . len ) { remove_r_id = r_id ; } } range_id = sub_ranges [ i ] . index [ remove_r_id ] . id ; range_info = range_data [ range_id ] ; new_i = i + sub_ranges [ i ] . index [ remove_r_id ] . len - 1 ; new_sub_text = sub_text . substring ( i , i + sub_ranges [ i ] . index [ remove_r_id ] . len ) ; new_sub_range = sub_ranges . slice ( i , 1 + i + sub_ranges [ i ] . index [ remove_r_id ] . len ) ; for ( sr_id = 0 ; sr_id < new_sub_range . length ; sr_id ++ ) { new_sub_range [ sr_id ] . index . splice ( remove_r_id , 1 ) ; } container . appendChild ( render_range ( new_sub_text , new_sub_range , range_info , range_data , options ) ) ; i = new_i ; } } if ( text_start != null ) { container . appendChild ( document . createTextNode ( sub_text . substring ( text_start , sub_text . length ) ) ) ; } container . normalize ( ) ; }
621	function filterFunctionWordsAtEnding ( wordCombinations , functionWords ) { return wordCombinations . filter ( function ( combination ) { const words = combination . getWords ( ) ; const lastWordIndex = words . length - 1 ; return ! includes ( functionWords , words [ lastWordIndex ] ) ; } ) ; }
236	function initFacebook ( ) { if ( user . get ( ) ) { initFacebookAdvancedMatching ( ) ; } else { window . fbq ( 'init' , TRACKING_IDS . facebookInit ) ; window . fbq ( 'set' , 'autoConfig' , false , TRACKING_IDS . facebookJetpackInit ) ; window . fbq ( 'init' , TRACKING_IDS . facebookJetpackInit ) ; } }
2965	function removeFileAtPath ( file , to_dir ) { var fs = require ( 'fs' ) ; var file_name = filenameFromPath ( file ) ; var file_at_dest_dir = to_dir + file_name ; fs . unlink ( file_at_dest_dir ) ; console . log ( "Removed file at directory: " + file_at_dest_dir ) ; }
2893	function icons ( done ) { const stream = gulp . src ( config . src ) . pipe ( iconfont ( { fontName : config . iconName , appendUniconde : true , formats : config . formats , timestamp : config . useTimestamp ? getTimestamp ( ) : 0 , autohint : config . autohint , normalize : config . normalize , } ) ) ; stream . pipe ( gulp . dest ( config . dest ) ) ; core . events . emit ( 'reload' ) ; if ( config . templates . enabled && config . templates . sets . length ) { stream . on ( 'glyphs' , ( glyphs ) => { const iconData = { glyphs : glyphs . map ( glyph => ( { name : glyph . name , content : glyph . unicode [ 0 ] . toString ( 16 ) . toUpperCase ( ) , } ) ) , fontName : config . iconName , fontPath : config . fontPathPrefix , classNamePrefix : config . classNamePrefix , } ; Promise . all ( config . templates . sets . map ( set => new Promise ( ( resolve , reject ) => { processIconTemplate ( set . src , set . dest , iconData , ( err ) => { if ( err ) reject ( ) ; resolve ( ) ; } ) ; } ) ) ) . then ( ( ) => done ( ) ) ; } ) ; } else { done ( ) ; } }
3083	function ( walk ) { if ( ! walk . at ( '({' ) ) return false ; var endIdx = walk . indexOf ( '})' ) ; if ( endIdx === null ) return false ; walk . skip ( 2 ) ; var ctl = this . formCompiler . createCtl ( 'selectMenu' ) ; ctl . items = [ ] ; this . out . push ( '<select' ) ; this . emitAttrs ( { id : ctl . id , name : ctl . id , class : ctl . type } ) ; this . out . push ( '>' ) ; this . emitMenuItems ( ctl , new SubWalker ( walk , walk . position , endIdx ) ) ; this . out . push ( '</select>' ) ; walk . startFrom ( endIdx ) . skip ( 2 ) ; return true ; }
3074	function ( type ) { var ctl = { type : type } ; var idx = this . form . controls . length ; var id = this . form . signature + ':' + idx ; ctl . id = 'c-' + utils . sha256 ( id ) . substring ( 0 , 8 ) ; this . form . controls . push ( ctl ) ; return ctl ; }
636	function configureStore ( preloadedState = { } , extraMiddleware = [ ] ) { const enhancers = configureEnhancers ( extraMiddleware ) ; return createStore ( rootReducer , preloadedState , enhancers ) ; }
657	function isInternalLink ( url , host ) { const parsedUrl = urlMethods . parse ( url , false , true ) ; if ( url . indexOf ( "//" ) === - 1 && url . indexOf ( "/" ) === 0 ) { return true ; } if ( url . indexOf ( "#" ) === 0 ) { return false ; } if ( ! parsedUrl . host ) { return true ; } return parsedUrl . host === host ; }
929	function sortDefaultProcessors ( processorNames , processors ) { if ( Array . isArray ( processorNames ) ) { processorNames . sort ( ( a , b ) => { a = processors [ a ] ; b = processors [ b ] ; return ( a . order || 0 ) - ( b . order || 0 ) ; } ) ; } }
2917	function FormatError ( func , msg , value ) { this . name = 'FormatError' ; this . message = new Formatter ( ) ( msg , value ) ; if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , func ) ; } }
3768	function identity ( iterable ) { return __asyncGenerator ( this , arguments , function * identity_1 ( ) { return yield __await ( yield __await ( yield * __asyncDelegator ( __asyncValues ( iterable ) ) ) ) ; } ) ; }
2317	function loadResources ( resources , providerIndex ) { var result = [ ] , index , num = resources . length , resource , prefilters , postfilters ; for ( index = 0 ; index < num ; index ++ ) { resource = resources [ index ] ; prefilters = [ ] ; postfilters = [ ] ; if ( ! resource . id ) { throw new InvalidConfiguration ( InvalidConfiguration . INVALID_RESOURCE_MESSAGE + " Resource at index " + index + " on" + " provider at index " + providerIndex + " has no 'id' property." ) ; } if ( ! resource . context ) { throw new InvalidConfiguration ( InvalidConfiguration . INVALID_RESOURCE_MESSAGE + " Resource at index " + index + " on" + " provider at index " + providerIndex + " has no 'context' property." ) ; } if ( resource . prefilters ) { prefilters = loadMiddlewareFilters ( resource . prefilters ) ; } if ( resource . postfilters ) { postfilters = loadMiddlewareFilters ( resource . postfilters ) ; } result . push ( { id : resource . id , context : resource . context , prefilters : prefilters , postfilters : postfilters } ) ; } return result ; }
1758	function ( qName , id ) { var q = queue . get ( qName ) ; return q . getJob ( id ) . then ( function ( job ) { return job . remove ( ) ; } ) ; }
1563	function asCheckedCallback ( promise , cb , useOwnMethod ) { let called = false ; if ( useOwnMethod ) { promise . asCallback ( after ) ; } else { asCallback ( promise , after ) ; } function after ( ) { expect ( called ) . toBeFalsy ( ) ; called = true ; return cb . apply ( this , arguments ) ; } }
3027	function zipDates ( start , end ) { if ( start . month != undefined && end . month == undefined ) { end . month = 1 ; } if ( start . month == undefined && end . month != undefined ) { start . month = 1 ; } if ( start . day != undefined && end . day == undefined ) { end . day = 1 ; } if ( start . day == undefined && end . day != undefined ) { start . day = 1 ; } if ( start . hours != undefined && end . hours == undefined ) { end . hours = 0 ; } if ( start . hours == undefined && end . hours != undefined ) { start . hours = 0 ; } if ( start . minutes != undefined && end . minutes == undefined ) { end . minutes = 0 ; } if ( start . minutes == undefined && end . minutes != undefined ) { start . minutes = 0 ; } if ( start . seconds != undefined && end . seconds == undefined ) { end . seconds = 0 ; } if ( start . seconds == undefined && end . seconds != undefined ) { start . seconds = 0 ; } }
3884	function ( fragmentOverride , state ) { var fragment = baseUrl + ( this . fragment = this . getFragment ( fragmentOverride ) ) ; if ( fragment ) { var a = $ ( 'a[href="' + fragment + '"]' ) ; a . length === 0 ? S . redirect ( fragment ) : a . click ( ) ; } }
385	function insertNode ( parent , index , newNode , replace ) { if ( ! parent . childNodes ) { parent . childNodes = [ ] ; } var newNodes = [ ] ; var removedNode = replace ? parent . childNodes [ index ] : null ; if ( newNode ) { if ( isDocumentFragment ( newNode ) ) { if ( newNode . childNodes ) { newNodes = Array . from ( newNode . childNodes ) ; newNode . childNodes . length = 0 ; } } else { newNodes = [ newNode ] ; remove ( newNode ) ; } } if ( replace ) { removedNode = parent . childNodes [ index ] ; } Array . prototype . splice . apply ( parent . childNodes , [ index , replace ? 1 : 0 ] . concat ( newNodes ) ) ; newNodes . forEach ( function ( n ) { n . parentNode = parent ; } ) ; if ( removedNode ) { removedNode . parentNode = undefined ; } }
1468	async function ( ) { let { applications } = await this . getProjectData ( ) ; if ( applications instanceof Array && applications . length ) { return path . resolve ( process . cwd ( ) , applications [ 0 ] . path ) ; } throw new qx . tool . cli . Utils . UserError ( "Cannot find application path - are you in the right directory?" ) ; }
2999	function getType ( v ) { var result = '' ; if ( v == null ) { result = v + '' ; } else { result = typeof v ; if ( result == 'object' || result == 'function' ) { result = illa . classByType [ illa . classByType . toString . call ( v ) ] || 'object' ; } } return result ; }
6	function ( event , context , responseStatus , physicalResourceId , responseData , reason ) { return new Promise ( ( resolve , reject ) => { const https = require ( 'https' ) ; const { URL } = require ( 'url' ) ; var responseBody = JSON . stringify ( { Status : responseStatus , Reason : reason , PhysicalResourceId : physicalResourceId || context . logStreamName , StackId : event . StackId , RequestId : event . RequestId , LogicalResourceId : event . LogicalResourceId , Data : responseData } ) ; const parsedUrl = new URL ( event . ResponseURL || defaultResponseURL ) ; const options = { hostname : parsedUrl . hostname , port : 443 , path : parsedUrl . pathname + parsedUrl . search , method : 'PUT' , headers : { 'Content-Type' : '' , 'Content-Length' : responseBody . length } } ; https . request ( options ) . on ( 'error' , reject ) . on ( 'response' , res => { res . resume ( ) ; if ( res . statusCode >= 400 ) { reject ( new Error ( ` ${ res . statusCode } ${ res . statusMessage } ` ) ) ; } else { resolve ( ) ; } } ) . end ( responseBody , 'utf8' ) ; } ) ; }
895	function handleOnTag ( file , tagName , replaceTagName ) { let tags = file . tags ; tags || ( tags = file . tags = { } ) ; if ( replaceTagName && tags . hasOwnProperty ( replaceTagName ) ) { delete tags [ replaceTagName ] ; } tags [ tagName ] = true ; }
2839	function ( directory ) { var git , gitRef , packagePath , packageInfos ; packagePath = path . join ( directory , "package.json" ) ; return Q . nfcall ( exec , "cd " + directory + " && git config --get remote.origin.url" ) . then ( function ( output ) { git = output . join ( "" ) . replace ( / (\r\n|\n|\r) / gm , "" ) ; if ( ! fs . existsSync ( packagePath ) ) { return Q . reject ( new Error ( "package.json not found" ) ) ; } else { return Q ( ) ; } } ) . then ( function ( ) { return Q . nfcall ( exec , "cd " + directory + " && git rev-parse HEAD" ) . then ( function ( output ) { gitRef = output . join ( "" ) . replace ( / (\r\n|\n|\r) / gm , "" ) ; } ) ; } ) . then ( function ( ) { return Q . nfcall ( fs . readFile , packagePath , 'utf8' ) ; } ) . then ( function ( output ) { packageInfos = JSON . parse ( output ) ; return Q ( { 'git' : git + "#" + gitRef , 'package' : packageInfos } ) ; } ) ; }
3049	function ( store , initial ) { var me = this ; me . mixins . bindable . bindStore . apply ( me , arguments ) ; store = me . store ; if ( store && store . isLoading ( ) ) { me . onBeforeLoad ( ) ; } }
1938	function findGradient ( cssProp ) { var value = cssProp . value ( ) ; var gradient = null ; var matchedPart = _ . find ( cssProp . valueParts ( ) , function ( part ) { return gradient = module . parse ( part . substring ( value ) ) ; } ) ; if ( matchedPart && gradient ) { return { gradient : gradient , valueRange : matchedPart } ; } return null ; }
3447	function ( height ) { var me = this , isNum = ( typeof height == "number" ) ; if ( isNum && me . autoBoxAdjust && ! me . isBorderBox ( ) ) { height -= ( me . getBorderWidth ( "tb" ) + me . getPadding ( "tb" ) ) ; } return ( isNum && height < 0 ) ? 0 : height ; }
2012	function flipBufferHorizontally ( buffer ) { return makeBuffer ( buffer . width , buffer . height , function ( context ) { context . scale ( - 1 , 1 ) ; context . drawImage ( buffer , - buffer . width , 0 ) ; } ) ; }
3595	function ( mod ) { self . res = getProcessed ( self . processing , mod , self . raw . settings ) ; self . resolved = true ; callback ( ) ; }
2375	function listIndexes ( callback ) { debug ( '[%s] list existing indexes' , self . queueName ) ; collection . indexInformation ( { full : true } , function ( err , indexInfo ) { if ( err ) { debug ( '[%s] error getting indexInfo. skipping ttl index check: %s' , self . queueName , err ) ; return callback ( null , null ) ; } return callback ( null , indexInfo ) ; } ) ; }
669	function InvalidTypeError ( message ) { Error . captureStackTrace ( this , this . constructor ) ; this . name = this . constructor . name ; this . message = message ; }
980	function initAppMediaTargetInfo ( ctx , currToken ) { let { allAppTypes , hasAppMediaType } = ctx ; let isAppMediaTarget = allAppTypes . includes ( currToken ) ; hasAppMediaType || ( ctx . hasAppMediaType = isAppMediaTarget ) ; if ( ! isAppMediaTarget && ! MEDIA_QUERY_OPERATORS . includes ( currToken ) ) { return true ; } return false ; }
321	function replace ( url ) { var hasSameSize = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; if ( ! this . disabled && url ) { if ( this . isImg ) { this . element . src = url ; } if ( hasSameSize ) { this . url = url ; this . image . src = url ; if ( this . ready ) { this . viewBoxImage . src = url ; forEach ( this . previews , function ( element ) { element . getElementsByTagName ( 'img' ) [ 0 ] . src = url ; } ) ; } } else { if ( this . isImg ) { this . replaced = true ; } this . options . data = null ; this . uncreate ( ) ; this . load ( url ) ; } } return this ; }
649	function getIndicesByWord ( word , text ) { var startIndex = 0 ; var searchStringLength = word . length ; var index , indices = [ ] ; while ( ( index = text . indexOf ( word , startIndex ) ) > - 1 ) { var isPreviousCharacterWordBoundary = characterInBoundary ( text [ index - 1 ] ) || index === 0 ; var isNextCharacterWordBoundary = characterInBoundary ( text [ index + searchStringLength ] ) || ( text . length === index + searchStringLength ) ; if ( isPreviousCharacterWordBoundary && isNextCharacterWordBoundary ) { indices . push ( { index : index , match : word , } ) ; } startIndex = index + searchStringLength ; } return indices ; }
2352	function ( datasetClientId , fieldsToUpdate , callback ) { return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doUpdateDatasetClient ) ( datasetClientId , fieldsToUpdate , false , callback ) ; }
1746	function stripZeros ( aInput ) { var a = aInput ; var first = a [ 0 ] ; while ( a . length > 0 && first . toString ( ) === '0' ) { a = a . slice ( 1 ) ; first = a [ 0 ] ; } return a ; }
1522	function onlyCircularLink ( link ) { var nodeSourceLinks = link . source . sourceLinks var sourceCount = 0 nodeSourceLinks . forEach ( function ( l ) { sourceCount = l . circular ? sourceCount + 1 : sourceCount } ) var nodeTargetLinks = link . target . targetLinks var targetCount = 0 nodeTargetLinks . forEach ( function ( l ) { targetCount = l . circular ? targetCount + 1 : targetCount } ) if ( sourceCount > 1 || targetCount > 1 ) { return false } else { return true } }
3099	function inlineAndCompile ( filenames , options , reporter , callback , errback ) { var depTarget = options && options . depTarget ; var referrerName = options && options . referrer ; var basePath ; if ( referrerName ) { referrerName = referrerName && referrerName + 'src/node' ; basePath = path . join ( __dirname , '../../' ) ; } else { basePath = path . resolve ( './' ) + '/' ; } basePath = basePath . replace ( / \\ / g , '/' ) ; var scriptsCount = options . scripts . length ; var loadCount = 0 ; var elements = [ ] ; var hooks = new InlineLoaderHooks ( reporter , basePath , elements , depTarget ) ; var loader = new TraceurLoader ( hooks ) ; function appendEvaluateModule ( name , referrerName ) { var normalizedName = traceur . ModuleStore . normalize ( name , referrerName ) ; var tree = traceur . codegeneration . module . createModuleEvaluationStatement ( normalizedName ) ; elements . push ( tree ) ; } function loadNext ( ) { var loadAsScript = scriptsCount && ( loadCount < scriptsCount ) ; var doEvaluateModule = false ; var loadFunction = loader . import ; var name = filenames [ loadCount ] ; if ( loadAsScript ) { loadFunction = loader . loadAsScript ; } else { name = name . replace ( / \.js$ / , '' ) ; if ( options . modules !== 'inline' && options . modules !== 'instantiate' ) doEvaluateModule = true ; } var loadOptions = { referrerName : referrerName } ; var codeUnit = loadFunction . call ( loader , name , loadOptions ) . then ( function ( ) { if ( doEvaluateModule ) appendEvaluateModule ( name , referrerName ) ; loadCount ++ ; if ( loadCount < filenames . length ) { loadNext ( ) ; } else if ( depTarget ) { callback ( null ) ; } else { var tree = allLoaded ( basePath , reporter , elements ) ; callback ( tree ) ; } } , function ( err ) { errback ( err ) ; } ) . catch ( function ( ex ) { console . error ( 'Internal error ' + ( ex . stack || ex ) ) ; } ) ; } loadNext ( ) ; }
553	function updateDict ( info , dict ) { if ( info . prefixLength === 0 && info . extra === 0 ) return ; var indent = dict [ info . id ] || { prefixLength : 0 , extra : 0 } ; let indentLength = indent . prefixLength + indent . extra ; let infoLength = info . prefixLength + info . extra ; if ( indentLength > infoLength ) { dict [ info . id ] = indent ; } else { dict [ info . id ] = { prefixLength : info . prefixLength , extra : info . extra } ; } }
3395	function setDefaults ( ) { if ( seq === undefined ) seq = ~ ~ ( Math . random ( ) * 0xffffff ) if ( pid === undefined ) pid = process . pid % 0xffff if ( mid === undefined ) mid = crypto . createHash ( 'md5' ) . update ( os . hostname ( ) ) . digest ( ) . slice ( 0 , 3 ) . readUIntBE ( 0 , 3 ) ctr = 0 unique = pad ( mid , 6 , 16 ) + pad ( pid , 4 , 16 ) seqpref = pad ( ~ ~ ( seq / 16 ) , 5 , 16 ) }
901	function transformMiniProgram ( t , path , declarationPath , config , opts ) { if ( t . isObjectExpression ( declarationPath ) ) { declarationPath . traverse ( getCodeTraverseVisitors ( t , config , opts ) ) ; } else if ( opts . isExtension ) { return ; } else { throw path . buildCodeFrameError ( 'export require plain object' ) ; } let baseClassName = path . scope . generateUid ( opts . baseName ) ; let rootPath = path . findParent ( p => t . isProgram ( p ) ) ; let bodyPath = rootPath . get ( 'body.0' ) ; removeComments ( t , bodyPath , 'leadingComments' ) ; bodyPath . insertBefore ( createImportDeclaration ( baseClassName , opts . baseId , t ) ) ; if ( opts . isApp ) { appTransformer . extendAppFramework ( t , path , bodyPath , baseClassName , opts ) ; } let callArgs = createInitCallArgs ( declarationPath , config . config , opts , t ) ; let needExport = opts . needExport || ! opts . baseClass ; let toReplacePath = needExport ? path . get ( 'declaration' ) : path ; let callExpression = t . callExpression ( t . identifier ( baseClassName ) , callArgs ) ; if ( opts . isBehavior || ! opts . baseClass ) { toReplacePath . replaceWith ( t . expressionStatement ( callExpression ) ) ; } else { toReplacePath . replaceWith ( t . expressionStatement ( t . callExpression ( t . identifier ( opts . baseClass ) , [ callExpression ] ) ) ) ; } }
141	function onexit ( code ) { let changedFiles ; cssMake . stderr . removeListener ( 'data' , onstderr ) ; cssMake . stdout . removeListener ( 'data' , onstdout ) ; cssMake = null ; if ( scheduleBuild ) { scheduleBuild = false ; spawnMake ( ) ; } else if ( 0 === code ) { changedFiles = updateChangedCssFiles ( ) ; if ( 0 !== changedFiles . length ) { debug ( chalk . green ( 'css reload' ) ) ; io . of ( '/css-hot-reload' ) . emit ( 'css-hot-reload' , { status : 'reload' , changedFiles : changedFiles , } ) ; } else { debug ( chalk . green ( 'css up to date' ) ) ; io . of ( '/css-hot-reload' ) . emit ( 'css-hot-reload' , { status : 'up-to-date' } ) ; } } else { debug ( chalk . red ( 'css build failed' ) ) ; io . of ( '/css-hot-reload' ) . emit ( 'css-hot-reload' , { status : 'build-failed' , error : errors , } ) ; } }
1145	function wrap ( value , wrapper ) { if ( ! isFunction ( wrapper ) ) { throw new TypeError ; } return function ( ) { var args = [ value ] ; push . apply ( args , arguments ) ; return wrapper . apply ( this , args ) ; } ; }
1564	function asCallback ( promise , cb ) { promise . then ( ( res ) => cb ( null , res ) , cb ) ; }
230	function floodlightUserParams ( ) { const params = { } ; const currentUser = user . get ( ) ; if ( currentUser ) { params . u4 = hashPii ( currentUser . ID ) ; } const anonymousUserId = tracksAnonymousUserId ( ) ; if ( anonymousUserId ) { params . u5 = anonymousUserId ; } return params ; }
228	function recordOrderInBing ( cart , orderId , wpcomJetpackCartInfo ) { if ( ! isAdTrackingAllowed ( ) || ! isBingEnabled ) { return ; } if ( wpcomJetpackCartInfo . containsWpcomProducts ) { if ( null !== wpcomJetpackCartInfo . wpcomCostUSD ) { const params = { ec : 'purchase' , gv : wpcomJetpackCartInfo . wpcomCostUSD , } ; debug ( 'recordOrderInBing: record WPCom purchase' , params ) ; window . uetq . push ( params ) ; } else { debug ( ` ${ cart . currency } ` ) ; } } if ( wpcomJetpackCartInfo . containsJetpackProducts ) { if ( null !== wpcomJetpackCartInfo . jetpackCostUSD ) { const params = { ec : 'purchase' , gv : wpcomJetpackCartInfo . jetpackCostUSD , el : 'jetpack' , } ; debug ( 'recordOrderInBing: record Jetpack purchase' , params ) ; window . uetq . push ( params ) ; } else { debug ( ` ${ cart . currency } ` ) ; } } }
3748	function ( d ) { if ( ! arguments . length ) { if ( typeof _i === 'object' ) { var o = { } ; for ( var prop in _i ) { o [ prop ] = _i [ prop ] ( ) ; } return o ; } else { return _i ; } } _i = validate ( d ) ; if ( typeof _i === 'object' ) { for ( var prop_object in _i ) { me [ prop_object ] = _i [ prop_object ] ; } } }
3636	function start ( ) { if ( router . useHashbang == null && router . useHistoryApi == null ) { if ( window . location . host && window . history . pushState ) { router . useHistoryApi = true ; } else { router . useHashbang = true ; } } var initPath = "" ; if ( router . useHistoryApi ) { initPath = window . location . pathname ; if ( _baseUrl === undefined ) { _baseUrl = initPath . replace ( / \/$ / , "" ) ; } initPath = initPath . replace ( _baseUrl , "" ) || _homePath || "/" ; } else if ( router . useHashbang ) { initPath = window . location . hash . replace ( "#!" , "" ) || _homePath || "/" ; } else { initPath = "/" ; } if ( ! initPath . startsWith ( "/" ) ) { initPath = "/" + initPath ; } if ( router . useHistoryApi ) { window . addEventListener ( "popstate" , function ( e ) { if ( e . state ) dispatch ( e . state ) ; e . preventDefault ( ) ; } ) ; } else if ( router . useHashbang ) { window . addEventListener ( "hashchange" , function ( e ) { dispatch ( { path : window . location . hash . replace ( / ^#! / , "" ) } ) ; e . preventDefault ( ) ; } ) ; } go ( initPath ) ; }
3182	function ( ) { var nativeDate = window . Date , p , statics = [ 'useStrict' , 'formatCodeToRegex' , 'parseFunctions' , 'parseRegexes' , 'formatFunctions' , 'y2kYear' , 'MILLI' , 'SECOND' , 'MINUTE' , 'HOUR' , 'DAY' , 'MONTH' , 'YEAR' , 'defaults' , 'dayNames' , 'monthNames' , 'monthNumbers' , 'getShortMonthName' , 'getShortDayName' , 'getMonthNumber' , 'formatCodes' , 'isValid' , 'parseDate' , 'getFormatCode' , 'createFormat' , 'createParser' , 'parseCodes' ] , proto = [ 'dateFormat' , 'format' , 'getTimezone' , 'getGMTOffset' , 'getDayOfYear' , 'getWeekOfYear' , 'isLeapYear' , 'getFirstDayOfMonth' , 'getLastDayOfMonth' , 'getDaysInMonth' , 'getSuffix' , 'clone' , 'isDST' , 'clearTime' , 'add' , 'between' ] , sLen = statics . length , pLen = proto . length , stat , prot , s ; for ( s = 0 ; s < sLen ; s ++ ) { stat = statics [ s ] ; nativeDate [ stat ] = utilDate [ stat ] ; } for ( p = 0 ; p < pLen ; p ++ ) { prot = proto [ p ] ; nativeDate . prototype [ prot ] = function ( ) { var args = Array . prototype . slice . call ( arguments ) ; args . unshift ( this ) ; return utilDate [ prot ] . apply ( utilDate , args ) ; } ; } }
3700	function ( msg , code , errorStr , cb ) { return function ( error , data ) { if ( error ) { error = json_rpc . newSysError ( msg , code , errorStr , error ) ; } cb ( error , data ) ; } ; }
1631	function hasClass ( element , className ) { if ( ! element || ! ( 'className' in element ) ) { return false ; } return element . className . split ( / \s+ / ) . indexOf ( className ) !== - 1 ; }
1601	function _eval ( opts ) { throwIfRequiredOption ( opts , 'src' ) var src = opts [ 'src' ] if ( src === 'stdin' ) { readFromStdin ( function ( src ) { run ( src ) } ) } else { run ( src ) } function run ( src ) { var fn = new Function ( 'R' , ram . compile ( src , '<eval>' ) . js ) fn ( R ) } }
1113	function match ( name , regexps ) { for ( let regexp of regexps ) if ( regexp . test ( name ) ) return true ; return false ; }
3772	function concat ( ... iterables ) { return function ( it ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_20 , _a ; yield __await ( yield * __asyncDelegator ( __asyncValues ( it ) ) ) ; try { for ( var iterables_1 = __asyncValues ( iterables ) , iterables_1_1 ; iterables_1_1 = yield __await ( iterables_1 . next ( ) ) , ! iterables_1_1 . done ; ) { const iterable = iterables_1_1 . value ; yield __await ( yield * __asyncDelegator ( __asyncValues ( iterable ) ) ) ; } } catch ( e_20_1 ) { e_20 = { error : e_20_1 } ; } finally { try { if ( iterables_1_1 && ! iterables_1_1 . done && ( _a = iterables_1 . return ) ) yield __await ( _a . call ( iterables_1 ) ) ; } finally { if ( e_20 ) throw e_20 . error ; } } } ) ; } ; }
480	function runStoppableQueue ( queue ) { for ( var _len2 = arguments . length , args = Array ( _len2 > 1 ? _len2 - 1 : 0 ) , _key2 = 1 ; _key2 < _len2 ; _key2 ++ ) { args [ _key2 - 1 ] = arguments [ _key2 ] ; } var step = function step ( index ) { if ( index >= queue . length ) { return true ; } var result = isFunction ( queue [ index ] ) ? queue [ index ] . apply ( queue , _toConsumableArray ( args ) ) : queue [ index ] ; if ( result === false ) return false ; return step ( ++ index ) ; } ; return step ( 0 ) ; }
1505	function compareOids ( oidA , oidB ) { var mlen , i ; if ( typeof oidA === 'undefined' && typeof oidB !== 'undefined' ) { return 1 ; } else if ( typeof oidA !== 'undefined' && typeof oidB === 'undefined' ) { return - 1 ; } mlen = Math . min ( oidA . length , oidB . length ) ; for ( i = 0 ; i < mlen ; i ++ ) { if ( oidA [ i ] > oidB [ i ] ) { return - 1 ; } else if ( oidB [ i ] > oidA [ i ] ) { return 1 ; } } if ( oidA . length > oidB . length ) { return - 1 ; } else if ( oidB . length > oidA . length ) { return 1 ; } else { return 0 ; } }
2199	function addNativeHtml5Validators ( ctrl , validatorName , badFlags , ignoreFlags , validity ) { if ( isObject ( validity ) ) { ctrl . $$hasNativeValidators = true ; var validator = function ( value ) { if ( ! ctrl . $error [ validatorName ] && ! testFlags ( validity , ignoreFlags ) && testFlags ( validity , badFlags ) ) { ctrl . $setValidity ( validatorName , false ) ; return ; } return value ; } ; ctrl . $parsers . push ( validator ) ; } }
2915	function spawnCommandWithKill ( ... args ) { const child = spawnCommand ( ... args ) child . kill = kill . bind ( child ) return child }
2176	function handleOffsetChange ( left ) { var elements = getElements ( ) ; var newValue = ( ( ctrl . shouldCenterTabs || isRtl ( ) ? '' : '-' ) + left + 'px' ) ; newValue = newValue . replace ( '--' , '' ) ; angular . element ( elements . paging ) . css ( $mdConstant . CSS . TRANSFORM , 'translate3d(' + newValue + ', 0, 0)' ) ; $scope . $broadcast ( '$mdTabsPaginationChanged' ) ; }
194	function getPurchasesBySite ( purchases , sites ) { return purchases . reduce ( ( result , currentValue ) => { const site = find ( result , { id : currentValue . siteId } ) ; if ( site ) { site . purchases = site . purchases . concat ( currentValue ) ; } else { const siteObject = find ( sites , { ID : currentValue . siteId } ) ; result = result . concat ( { id : currentValue . siteId , name : currentValue . siteName , slug : siteObject ? siteObject . slug : currentValue . domain , isDomainOnly : siteObject ? siteObject . options . is_domain_only : false , title : currentValue . siteName || currentValue . domain || '' , purchases : [ currentValue ] , domain : siteObject ? siteObject . domain : currentValue . domain , } ) ; } return result ; } , [ ] ) . sort ( ( a , b ) => ( a . title . toLowerCase ( ) > b . title . toLowerCase ( ) ? 1 : - 1 ) ) ; }
1612	function writeRamdaFunctionAsGlobalStub ( ctx ) { ctx . newLineTop ( ) ctx . newLineTop ( ) Object . keys ( ctx . usedRamdaFns ) . forEach ( function ( key ) { ctx . newLineTop ( ) ctx . writeTop ( 'var ' + key + ' = R.' + key ) } ) }
793	function loadSingle ( source ) { var promise ; if ( source . match ( / ^https?:\/\/ / ) ) { promise = httpGetPromise ( source ) ; } else { promise = readFilePromise ( normalizePath ( source ) ) ; } return promise ; }
830	function generateTypedocDocs ( typedocDocsDir ) { const publicApiConfigFile = path . resolve ( __dirname , '../src/ng5-slider/lib/public_api.json' ) ; const publicApiConfig = JSON . parse ( fs . readFileSync ( publicApiConfigFile , { encoding : 'utf8' } ) ) ; const files = publicApiConfig . exports . map ( exportDef => path . resolve ( __dirname , ` ${ exportDef . file } ` ) ) ; const themeDir = path . resolve ( __dirname , '../typedoc-theme' ) ; const apiDocsReadmeFile = path . resolve ( __dirname , '../typedoc-theme/README.md' ) ; utils . copyReadmeMd ( apiDocsReadmeFile ) ; const app = new typedoc . Application ( { module : 'commonjs' , target : 'es6' , includeDeclarations : false , experimentalDecorators : true , excludeExternals : true , theme : themeDir } ) ; app . generateDocs ( files , typedocDocsDir ) ; const mainReadmeFile = path . resolve ( __dirname , '../README.md' ) ; utils . copyReadmeMd ( mainReadmeFile ) ; }
3135	function ( binding ) { var me = this , keyCode = binding . key , i , len ; if ( me . processing ) { me . bindings = bindings . slice ( 0 ) ; } if ( Ext . isArray ( binding ) ) { for ( i = 0 , len = binding . length ; i < len ; i ++ ) { me . addBinding ( binding [ i ] ) ; } return ; } me . bindings . push ( Ext . apply ( { keyCode : me . processKeys ( keyCode ) } , binding ) ) ; }
1056	function parse ( buf , options , dict ) { var index var last var value value = buf . toString ( UTF8 ) last = value . indexOf ( linefeed ) + 1 index = value . indexOf ( linefeed , last ) while ( index !== - 1 ) { if ( value . charCodeAt ( last ) !== tab ) { parseLine ( value . slice ( last , index ) , options , dict ) } last = index + 1 index = value . indexOf ( linefeed , last ) } parseLine ( value . slice ( last ) , options , dict ) }
483	function isAccessorDescriptor ( desc ) { return ! ! desc && ( isFunction ( desc . get ) || isFunction ( desc . set ) ) && isBoolean ( desc . configurable ) && isBoolean ( desc . enumerable ) && desc . writable === undefined ; }
2640	function createElement ( ) { var element = document . createElement ( 'canvas' ) ; element . setAttribute ( 'touch-action' , 'none' ) ; element . style . position = 'absolute' ; element . style . display = 'block' ; return element ; }
116	function checkPlaying ( event ) { var _this3 = this ; toggleClass ( this . elements . container , this . config . classNames . playing , this . playing ) ; toggleClass ( this . elements . container , this . config . classNames . paused , this . paused ) ; toggleClass ( this . elements . container , this . config . classNames . stopped , this . stopped ) ; Array . from ( this . elements . buttons . play || [ ] ) . forEach ( function ( target ) { target . pressed = _this3 . playing ; } ) ; if ( is$1 . event ( event ) && event . type === 'timeupdate' ) { return ; } ui . toggleControls . call ( this ) ; }
1452	function ( name , location ) { var t = this ; var requiredOpts = { load : t . isLoadScope ( ) , defer : t . __inDefer , construct : t . __classMeta && t . __classMeta . functionName == "$$constructor" , location : location } ; var dest = t . __environmentChecks . required [ name ] ; if ( ! dest ) { dest = t . __environmentChecks . required [ name ] = { } ; } if ( requiredOpts . load ) { dest . load = true ; } if ( requiredOpts . defer ) { dest . defer = true ; } if ( requiredOpts . construct ) { dest . construct = true ; } t . _requireClass ( "qx.core.Environment" , { location : location } ) ; if ( qx . tool . compiler . ClassFile . ENVIRONMENT_CONSTANTS [ name ] === undefined ) { var entry = qx . tool . compiler . ClassFile . ENVIRONMENT_CHECKS [ name ] ; if ( entry && entry . className ) { t . _requireClass ( entry . className , { load : requiredOpts . load , location : location } ) ; dest . className = entry . className ; } else if ( ! entry ) { t . _requireClass ( name , { load : requiredOpts . load , location : location } ) ; } } }
583	function ( message , transfers ) { if ( transfers && this . postMessageTransfers ) { this . comObj . postMessage ( message , transfers ) ; } else { this . comObj . postMessage ( message ) ; } }
1867	function tokenize ( ) { var ch = walker . ch ; if ( ch === " " || ch === "\t" ) \t { return white ( ) ; } if ( ch === '/' ) { return comment ( ) ; } if ( ch === '"' || ch === "'" ) { return str ( ) ; } if ( ch === '(' ) { return brace ( ) ; } if ( ch === '-' || ch === '.' || isDigit ( ch ) ) { return num ( ) ; } if ( isNameChar ( ch ) ) { return identifier ( ) ; } if ( isOp ( ch ) ) { return op ( ) ; } if ( ch === "\n" ) \n }
2020	function ( callback ) { var plugins = Object . keys ( pluginHelpers . loadedPlugins || { } ) ; async . eachSeries ( plugins , pluginHelpers . stop , callback ) ; }
964	function transform ( transformers , element , tplOpts , options ) { let { config } = tplOpts ; let onTag = config . onTag ; if ( onTag ) { onTag ( element . name ) ; } let transformer = findMatchElemTransformer ( transformers . element , element ) ; transformer && transformer . call ( this , element , tplOpts , options ) ; if ( element . removed ) { return ; } let { attribs : attrs } = element ; attrs && Object . keys ( attrs ) . forEach ( k => { transformer = findMatchAttrTransformer ( transformers . attribute , k ) ; if ( transformer ) { transformer . call ( this , attrs , k , tplOpts , options , element ) ; if ( transformer . type === 'for' ) { element . hasForLoop = true ; } } } ) ; }
1804	function ( selector , context , skipFiltering ) { var match ; if ( ! context && ( match = selector . match ( idRegexp ) ) ) { var element = require ( './view' ) . byId ( match [ 1 ] ) ; return new Collection ( element ? [ element ] : [ ] ) ; } context = context || require ( './attaching' ) . Attaching . instances ( ) ; if ( context . length === undefined ) { context = [ context ] ; } var tokens = Selector . tokenize ( selector ) , expr = tokens [ 0 ] , extra = tokens [ 1 ] , result = context , mapper ; while ( expr . length > 0 ) { mapper = mappers [ expr [ 0 ] ] ? mappers [ expr . shift ( ) ] : mappers [ '' ] ; result = mapper ( result ) ; if ( expr . length === 0 ) { break ; } result = Selector . reduce ( expr . shift ( ) , result ) ; } if ( extra ) { result = result . concat ( Selector . find ( extra , context , true ) ) ; } return skipFiltering ? result : new Collection ( utils . unique ( result ) ) ; }
1443	function ( className ) { if ( ! this . __metaStack . length ) { throw new Error ( "No __metaStack entries to pop" ) ; } let meta = this . __metaStack [ this . __metaStack . length - 1 ] ; if ( className && meta . className != className ) { throw new Error ( "Wrong __metaStack entries to pop, expected " + className + " found " + meta . className ) ; } this . __metaStack . pop ( ) ; meta = this . __metaStack [ this . __metaStack . length - 1 ] || null ; this . __classMeta = meta ; }
2881	function sh ( cmd , exitOnError , cb ) { const child = exec ( cmd , { encoding : 'utf8' , timeout : 1000 * 60 * 2 , } ) ; let stdout = '' ; child . stdout . on ( 'data' , ( data ) => { stdout += data ; process . stdout . write ( data ) ; } ) ; child . stderr . on ( 'data' , ( data ) => { process . stdout . write ( data ) ; } ) ; child . on ( 'close' , ( code ) => { if ( code > 0 ) { if ( exitOnError ) { if ( typeof cb === 'function' ) { cb ( new Error ( ` ${ code } ${ cmd } ` ) ) ; } else { process . stdout . write ( ` ${ code } ${ cmd } \n ` ) ; process . exit ( code ) ; } } else { notifier . notify ( { title : cmd , message : stdout , sound : true , } ) ; } } if ( typeof cb === 'function' ) cb ( ) ; } ) ; }
1500	function PDU ( ) { this . type = asn1ber . pduTypes . GetRequestPDU ; this . reqid = 1 ; this . error = 0 ; this . errorIndex = 0 ; this . varbinds = [ new VarBind ( ) ] ; }
926	function tryToResolveRequireModId ( t , path , state ) { let opts = state . opts || { } ; let resolveRequireId = opts . resolveDepRequireId ; let exportNode = path . node ; let source = exportNode . source ; if ( ! t . isStringLiteral ( source ) ) { return ; } let modId = source . value ; let newModId = resolveRequireId ( modId ) ; if ( newModId && newModId !== modId ) { let requireIdNode = path . get ( 'source' ) ; requireIdNode . replaceWith ( t . stringLiteral ( newModId ) ) ; } }
178	function settingsRequest ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST : case WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_FAILURE : return WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST === type ; } return state ; }
66	function matches$1 ( element , selector ) { function match ( ) { return Array . from ( document . querySelectorAll ( selector ) ) . includes ( this ) ; } var matches = match ; return matches . call ( element , selector ) ; }
2407	function startWatchingarray ( ko , observable , array ) { var subscribable = getSubscribableForArray ( ko , array ) ; return subscribable . subscribe ( observable ) ; }
1226	function checkFormatter ( formatter , formatterName ) { if ( $ . isFunction ( formatter ) ) return true ; if ( ! formatter ) return false ; throw new Error ( formatterName + " must be a function or a falsy value" ) ; }
2491	function writeTobuffer ( value , buffer ) { write ( buffer , value , OFFSET , LITTLE_ENDIAN , MANTISSA_LENGTH , NUMBER_OF_BYTES ) ; }
3304	function getString ( ref ) { try { if ( ref ) { try { return ref ; } catch ( e ) { return ref . toString ( ) ; } } else { try { return ref . toString ( ) ; } catch ( e ) { return "undefined" ; } } } catch ( e ) { return "undefined" ; } }
2471	function ( scriptOrLink ) { for ( var p = 0 , len = options . ignorePatterns . length ; p < len ; p ++ ) { if ( options . ignorePatterns [ p ] . test ( scriptOrLink ) ) { return true ; } } return false ; }
399	function processWithTextApi ( [ options , pages , stylesheets ] ) { if ( options . raw ) { if ( _ . isString ( options . raw ) ) { stylesheets . push ( options . raw ) ; } else { throw new Error ( 'UnCSS: options.raw - expected a string' ) ; } } if ( ! _ . flatten ( stylesheets ) . length ) { throw new Error ( 'UnCSS: no stylesheets found' ) ; } const cssStr = stylesheets . join ( ' \n' ) ; \n let pcss , report ; try { pcss = postcss . parse ( cssStr ) ; } catch ( err ) { throw utility . parseErrorMessage ( err , cssStr ) ; } }
1384	async function display ( header , items , type , active = false , parse = false , id ) { let rows ; if ( type === 'txt' ) { await text ( header , items ) ; } else if ( type === 'txtHorizontal' ) { const opts = { head : header , chars : { top : '' , 'top-mid' : '' , 'top-left' : '' , 'top-right' : '' , bottom : '' , 'bottom-mid' : '' , 'bottom-left' : '' , 'bottom-right' : '' , left : '' , 'left-mid' : '' , mid : '' , 'mid-mid' : '' , right : '' , 'right-mid' : '' , middle : ' ' . repeat ( 2 ) } , style : { 'padding-left' : 0 , 'padding-right' : 0 , head : [ 'white' ] , border : [ 'white' ] } } ; if ( parse ) { rows = await parseResponse ( header , items , active , id ) ; await horizontal ( rows , opts ) ; } else { await horizontal ( items , opts ) ; } } else if ( type === 'prettyHorizontal' ) { const opts = { head : header , style : { 'padding-left' : 0 , 'padding-right' : 0 , head : [ 'blue' ] } } ; if ( parse ) { rows = await parseResponse ( header , items , active , id ) ; await horizontal ( rows , opts ) ; } else { await horizontal ( items , opts ) ; } } else if ( type === 'txtVertical' ) { const style = { chars : { top : '' , 'top-mid' : '' , 'top-left' : '' , 'top-right' : '' , bottom : '' , 'bottom-mid' : '' , 'bottom-left' : '' , 'bottom-right' : '' , left : '' , 'left-mid' : '' , mid : '' , 'mid-mid' : '' , right : '' , 'right-mid' : '' , middle : ' ' . repeat ( 3 ) } , style : { 'padding-left' : 0 , 'padding-right' : 0 , head : [ 'white' ] } } ; if ( parse ) { rows = await parseResponse ( header , items , active , id ) ; await vertical ( header , rows , style ) ; } else { await vertical ( header , items , style ) ; } } else if ( type === 'prettyVertical' ) { const style = { style : { 'padding-left' : 0 , 'padding-right' : 0 , head : [ 'blue' ] } } ; if ( parse ) { rows = await parseResponse ( header , items , active , id ) ; await vertical ( header , rows , style ) ; } else { await vertical ( header , items , style ) ; } } else { await pretty ( header , items ) ; } }
539	async function symlinkDepsLib ( ) { if ( destLibPath === undefined ) { throw new Error ( 'Destination path not supplied!' ) ; } try { await symlink ( depsLibTensorFlowPath , destLibPath ) ; if ( os . platform ( ) !== 'win32' ) { await symlink ( depsLibTensorFlowFrameworkPath , destFrameworkLibPath ) ; } } catch ( e ) { console . error ( ` ${ destLibPath } ` ) ; await copy ( depsLibTensorFlowPath , destLibPath ) ; if ( os . platform ( ) !== 'win32' ) { await copy ( depsLibTensorFlowFrameworkPath , destFrameworkLibPath ) ; } } }
2338	function stop ( dataset_id , cb ) { if ( ! syncStarted ) { return cb ( ) ; } debug ( '[%s] stop sync for dataset' , dataset_id ) ; syncStorage . updateManyDatasetClients ( { datasetId : dataset_id } , { stopped : true } , cb ) ; }
504	function ( next ) { genesisBlock . header = new BlockHeader ( testData . genesisBlockHeader ) blockchain . putGenesis ( genesisBlock , next ) }
2695	function scriptCommand ( shell , args , data , evaluationId ) { return shell . runtime . data . script ( data ) ; }
576	function error ( msg ) { if ( arguments . length > 1 ) { var logArguments = [ 'Error:' ] ; logArguments . push . apply ( logArguments , arguments ) ; console . log . apply ( console , logArguments ) ; msg = [ ] . join . call ( arguments , ' ' ) ; } else { console . log ( 'Error: ' + msg ) ; } console . log ( backtrace ( ) ) ; UnsupportedManager . notify ( UNSUPPORTED_FEATURES . unknown ) ; throw new Error ( msg ) ; }
3245	function ( ) { var oldVisible = this . isButtonCurrentlyVisible ( ) ; var newVisible = this . shouldButtonBeVisible ( ) ; var clearButtonEl = this . clearButtonEl ; if ( oldVisible != newVisible ) { if ( this . animateClearButton && this . animateWithCss3 ) { this . clearButtonEl . removeCls ( this . clearButtonCls + ( oldVisible ? '-on' : '-off' ) ) ; clearButtonEl . addCls ( this . clearButtonCls + ( newVisible ? '-on' : '-off' ) ) ; } else { clearButtonEl . stopAnimation ( ) ; clearButtonEl . setVisible ( newVisible , this . animateClearButton ) ; } clearButtonEl . setStyle ( 'background-color' , this . textField . inputEl . getStyle ( 'background-color' ) ) ; if ( ! ( this . isTextArea && Ext . isGecko ) && ! Ext . isIE ) { var deltaPaddingRight = clearButtonEl . getWidth ( ) - this . clearButtonEl . getMargin ( 'l' ) ; var currentPaddingRight = this . textField . inputEl . getPadding ( 'r' ) ; var factor = ( newVisible ? + 1 : - 1 ) ; this . textField . inputEl . dom . style . paddingRight = ( currentPaddingRight + factor * deltaPaddingRight ) + 'px' ; } } }
2357	function doListUpdates ( datasetId , criteria , options , callback ) { debug ( '[%s] doListUpdates criteria = %j' , datasetId , criteria ) ; var updatesCollection = mongoClient . collection ( getDatasetUpdatesCollectionName ( datasetId ) ) ; var docLimit = options && options . limit ; var cursor = updatesCollection . find ( criteria ) ; if ( docLimit && docLimit > 0 ) { cursor = cursor . limit ( docLimit ) ; } cursor . toArray ( function ( err , updates ) { if ( err ) { debugError ( '[%s] Failed to doListUpdates due to error %s :: criteria = %j' + criteria , datasetId , err , criteria ) ; return callback ( err ) ; } return callback ( null , updates ) ; } ) ; }
3109	function ( value ) { value = value || '' ; return this . setStyle ( { left : value , right : value , top : value , bottom : value , 'z-index' : '' , position : STATIC } ) ; }
1549	function findPoints ( point , radius , skipSelf , octant , result ) { const children = octant . children ; let i , l ; if ( children !== null ) { let child ; for ( i = 0 , l = children . length ; i < l ; ++ i ) { child = children [ i ] ; if ( child . contains ( point , radius ) ) { findPoints ( point , radius , skipSelf , child , result ) ; } } } else if ( octant . points !== null ) { const points = octant . points ; const rSq = radius * radius ; let p ; for ( i = 0 , l = points . length ; i < l ; ++ i ) { p = points [ i ] ; if ( p . equals ( point ) ) { if ( ! skipSelf ) { result . push ( { point : p . clone ( ) , data : octant . data [ i ] } ) ; } } else if ( p . distanceToSquared ( point ) <= rSq ) { result . push ( { point : p . clone ( ) , data : octant . data [ i ] } ) ; } } } }
3655	function remove ( array , item ) { console . log ( "attempting to remove " + item ) var index = array . indexOf ( item ) if ( index !== - 1 ) array . splice ( index , 1 ) }
3663	function ( uuid_or_name , cb ) { if ( _ . isObject ( uuid_or_name ) ) { return cb ( new Error ( 'parameter must be a uuid or name' ) ) ; } var self = this ; client . getEntity ( { type : self . _usergrid . type , uuid : uuid_or_name } , translateSDKCallback ( function ( err , entity ) { if ( err ) { return cb ( err ) ; } cb ( null , wrap ( self , entity ) ) ; } ) ) ; }
613	function verifyArguments ( args ) { if ( ! isObject ( args . callbacks . getData ) ) { throw new MissingArgument ( "The app requires an object with a getdata callback." ) ; } if ( ! isObject ( args . targets ) ) { throw new MissingArgument ( "`targets` is a required App argument, `targets` is not an object." ) ; } if ( args . hasSnippetPreview && ! isValidSnippetPreview ( args . snippetPreview ) && ! isString ( args . targets . snippet ) ) { throw new MissingArgument ( "A snippet preview is required. When no SnippetPreview object isn't passed to " + "the App, the `targets.snippet` is a required App argument. `targets.snippet` is not a string." ) ; } }
107	function setLanguage ( input ) { var passive = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : true ; if ( ! is$1 . string ( input ) ) { this . debug . warn ( 'Invalid language argument' , input ) ; return ; } var language = input . toLowerCase ( ) ; this . captions . language = language ; var tracks = captions . getTracks . call ( this ) ; var track = captions . findTrack . call ( this , [ language ] ) ; captions . set . call ( this , tracks . indexOf ( track ) , passive ) ; }
406	function getCursorAdvanceMethods ( ) { return cursorAdvanceMethods || ( cursorAdvanceMethods = [ IDBCursor . prototype . advance , IDBCursor . prototype . continue , IDBCursor . prototype . continuePrimaryKey , ] ) ; }
2849	function tail ( array ) { var length = array ? array . length : 0 ; return length ? baseSlice ( array , 1 , length ) : [ ] ; }
3599	function doesLoadBalancerExist ( elb , loadBalancerName ) { function inspectError ( err ) { if ( err . code === 'LoadBalancerNotFound' ) { return false } return Bluebird . reject ( err ) } return elb . describeLoadBalancersPromised ( { LoadBalancerNames : [ loadBalancerName ] } ) . then ( _ . constant ( true ) ) . error ( inspectError ) }
637	function removeLinksFromText ( text ) { const anchors = getAnchorsFromText ( text ) ; if ( anchors . length > 0 ) { anchors . forEach ( function ( anchor ) { text = text . replace ( anchor , "" ) ; } ) ; } return text ; }
237	function isServerSideRenderCompatible ( context ) { return Boolean ( isSectionIsomorphic ( context . store . getState ( ) ) && ! context . user && isDefaultLocale ( context . lang ) && context . layout ) ; }
153	function getAcceptedLanguagesFromHeader ( header ) { if ( ! header ) { return [ ] ; } return header . split ( ',' ) . map ( lang => { const match = lang . match ( / ^[A-Z]{2,3}(-[A-Z]{2,3})? / i ) ; if ( ! match ) { return false ; } return match [ 0 ] . toLowerCase ( ) ; } ) . filter ( lang => lang ) ; }
1018	function ( path ) { return this . _getFileId ( path ) . then ( ( id ) => { let query , fields , data , etagWithoutQuotes , itemsMap ; if ( ! id ) { return Promise . resolve ( { statusCode : 404 } ) ; } query = '\'' + \' + id ; '\' in parents' \' } ) ; }
1836	function responseCallback ( req , res ) { return function ( err , data ) { if ( err ) { handleError ( err , req , res ) ; } else { res . send ( data ) ; } } ; }
3469	function ( ) { var me = this , buffer = me . callBuffer , len = buffer . length ; if ( len > 0 ) { me . sendRequest ( len == 1 ? buffer [ 0 ] : buffer ) ; me . callBuffer = [ ] ; } }
458	function findAxisComponents ( childComponents , predicate ) { predicate = predicate || identity ; const findAxes = ( children ) => { return children . reduce ( ( memo , child ) => { if ( child . type && child . type . role === "axis" && predicate ( child ) ) { return memo . concat ( child ) ; } else if ( child . props && child . props . children ) { return memo . concat ( findAxes ( React . Children . toArray ( child . props . children ) ) ) ; } return memo ; } , [ ] ) ; } ; return findAxes ( childComponents ) ; }
1283	function locateAcpiDevice ( dev ) { if ( ! dev . isDevice ( ) ) { return null ; } const addr = dev . address ( ) ; const slotId = ( ( addr >>> 16 ) & 0xffff ) >>> 0 ; const funcId = ( addr & 0xffff ) >>> 0 ; let busId = 0 ; if ( dev . isRootBridge ( ) ) { busId = dev . getRootBridgeBusNumber ( ) ; return { bus : busId , slot : slotId , func : funcId , } ; } const parentDev = dev . parent ( ) ; if ( parentDev === null ) { return null ; } if ( ! parentDev . isDevice ( ) ) { return null ; } if ( parentDev . isRootBridge ( ) ) { busId = parentDev . getRootBridgeBusNumber ( ) ; return { bus : busId , slot : slotId , func : funcId , } ; } const parentLocation = locateAcpiDevice ( parentDev ) ; if ( parentLocation === null ) { return null ; } const pciParent = pciAccessorFactory . get ( { bus : parentLocation . bus , slot : parentLocation . slot , func : parentLocation . func , } ) ; const header = pciParent . read ( pciParent . fields ( ) . HEADER_TYPE ) ; const headerType = ( header & 0x7f ) >>> 0 ; if ( headerType !== 0x01 && headerType !== 0x02 ) { return null ; } const bridgeBus = pciParent . read ( pciParent . bridgeFields ( ) . SECONDARY_BUS ) ; return { bus : bridgeBus , slot : slotId , func : funcId , } ; }
1810	function ( ) { var result = [ ] , indexes = this . selection ( ) . indexes ( ) ; for ( var i = 0 , l = indexes . length ; i < l ; i ++ ) { var item = this . _data . slice ( indexes [ i ] , indexes [ i ] + 1 ) [ 0 ] ; if ( item ) result . push ( item ) ; } ; return result ; }
528	function ( string ) { if ( ! string ) return "" ; var types = this . typeConfig ; if ( ~ string . indexOf ( types . string . defaultClass ) ) { return _TYPE . STRING ; } else if ( ~ string . indexOf ( types . number . defaultClass ) ) { return _TYPE . NUMBER ; } else if ( ~ string . indexOf ( types . boolean . defaultClass ) ) { return _TYPE . BOOLEAN ; } else if ( ~ string . indexOf ( types . date . defaultClass ) ) { return _TYPE . DATE ; } else { return "" ; } }
2596	function rotateLeft ( a , amount ) { if ( ! ( a instanceof Array ) ) return a ; return libs . array . rotate ( a , 'left' , amount ) ; }
2175	function handleStretchTabs ( stretchTabs ) { var elements = getElements ( ) ; angular . element ( elements . wrapper ) . toggleClass ( 'md-stretch-tabs' , shouldStretchTabs ( ) ) ; updateInkBarStyles ( ) ; }
2371	function doCreate ( datasetId , pendingChange , callback ) { var record = pendingChange . post ; var metaData = pendingChange . meta_data ; debug ( '[%s] CREATE Start data = %j' , datasetId , record ) ; dataHandlers . doCreate ( datasetId , record , metaData , function ( err , data ) { if ( err ) { debugError ( '[%s] CREATE Failed - : err = %s' , datasetId , err ) ; } else { debug ( '[%s] CREATE Success - uid = %s' , datasetId , data . uid ) ; pendingChange . oldUid = pendingChange . uid ; pendingChange . uid = data . uid ; } return saveUpdate ( datasetId , pendingChange , err ? SYNC_UPDATE_TYPES . FAILED : SYNC_UPDATE_TYPES . APPLIED , err ? util . inspect ( err ) : null , callback ) ; } ) ; }
1378	function getWorkflowGuids ( callback ) { return self . apos . docs . db . findWithProjection ( { _id : { $in : _ . pluck ( related , '_id' ) } } , { _id : 1 , workflowGuid : 1 , type : 1 } ) . toArray ( function ( err , guidDocs ) { if ( err ) { return fail ( err ) ; } _ . each ( guidDocs , function ( guidDoc ) { var relatedOne = _ . find ( related , { _id : guidDoc . _id } ) ; if ( relatedOne ) { relatedOne . workflowGuid = guidDoc . workflowGuid ; idsByGuid [ relatedOne . workflowGuid ] = relatedOne . _id ; relatedOne . type = guidDoc . type ; } } ) ; related = _ . filter ( related , function ( relatedOne ) { return relatedOne . type && relatedOne . workflowGuid && self . includeType ( relatedOne . type ) ; } ) ; return callback ( null ) ; } ) ; }
1129	function encrypt ( publicKeyDataOrFile , data ) { const deferred = q . defer ( ) ; let publicKeyPromise ; const getPublicKey = function getPublicKey ( publicKeyFile ) { const publicKeyDeferred = q . defer ( ) ; fs . readFile ( publicKeyFile , ( err , publicKey ) => { if ( err ) { logger . warn ( 'Error reading public key:' , err ) ; publicKeyDeferred . reject ( err ) ; } else { publicKeyDeferred . resolve ( publicKey ) ; } } ) ; return publicKeyDeferred . promise ; } ; if ( typeof data !== 'string' ) { deferred . reject ( new Error ( 'data must be a string' ) ) ; return deferred . promise ; } if ( publicKeyDataOrFile . startsWith ( '-----BEGIN PUBLIC KEY-----' ) ) { publicKeyPromise = q ( publicKeyDataOrFile ) ; } else { publicKeyPromise = getPublicKey ( publicKeyDataOrFile ) ; } publicKeyPromise . then ( ( publicKey ) => { let encrypted ; try { encrypted = crypto . publicEncrypt ( publicKey , util . createBufferFrom ( data ) ) ; deferred . resolve ( encrypted . toString ( 'base64' ) ) ; } catch ( err ) { logger . warn ( 'Error encrypting data:' , err ) ; deferred . reject ( err ) ; } } ) . catch ( ( err ) => { logger . warn ( 'Unable to get public key:' , err ) ; deferred . reject ( err ) ; } ) ; return deferred . promise ; }
1210	function getParameterList ( parameters ) { if ( parameters == null ) { return [ ] ; } if ( typeof parameters != "object" ) { return OAuth . decodeForm ( parameters + "" ) ; } if ( parameters instanceof Array ) { return parameters ; } var list = [ ] ; for ( var p in parameters ) { list . push ( [ p , parameters [ p ] ] ) ; } return list ; }
1693	function _getActualDirection ( direction ) { if ( this . _layout . capabilities && this . _layout . capabilities . direction ) { if ( Array . isArray ( this . _layout . capabilities . direction ) ) { for ( var i = 0 ; i < this . _layout . capabilities . direction . length ; i ++ ) { if ( this . _layout . capabilities . direction [ i ] === direction ) { return direction ; } } return this . _layout . capabilities . direction [ 0 ] ; } else { return this . _layout . capabilities . direction ; } } return ( direction === undefined ) ? Utility . Direction . Y : direction ; }
3120	function resize ( ) { var deltaSize , d = ed . getDoc ( ) , body = d . body , de = d . documentElement , DOM = tinymce . DOM , resizeHeight = t . autoresize_min_height , myHeight ; myHeight = tinymce . isIE ? body . scrollHeight : ( tinymce . isWebKit && body . clientHeight == 0 ? 0 : body . offsetHeight ) ; if ( myHeight > t . autoresize_min_height ) resizeHeight = myHeight ; if ( t . autoresize_max_height && myHeight > t . autoresize_max_height ) { resizeHeight = t . autoresize_max_height ; body . style . overflowY = "auto" ; de . style . overflowY = "auto" ; } else { body . style . overflowY = "hidden" ; de . style . overflowY = "hidden" ; body . scrollTop = 0 ; } if ( resizeHeight !== oldSize ) { deltaSize = resizeHeight - oldSize ; DOM . setStyle ( DOM . get ( ed . id + '_ifr' ) , 'height' , resizeHeight + 'px' ) ; oldSize = resizeHeight ; if ( tinymce . isWebKit && deltaSize < 0 ) resize ( ) ; } }
3041	function skipWhitespaceNodes ( e , next ) { while ( e && ( e . nodeType === 8 || ( e . nodeType === 3 && / ^[ \t\n\r]*$ / . test ( e . nodeValue ) ) ) ) { e = next ( e ) ; } return e ; }
3871	function removeStyle ( node , prop ) { if ( node && node . el ) { node . el . style [ prop ] = '' ; } }
3500	function checkFirstNodeLineIndent ( node , firstLineIndent ) { var startIndent = getNodeIndent ( node , false ) ; if ( startIndent !== firstLineIndent && isNodeFirstInLine ( node ) ) { report ( node , firstLineIndent , startIndent , { line : node . loc . start . line , column : node . loc . start . column } ) ; } }
1338	function preservesInCharClass ( value , index , parent ) { if ( value === '^' ) { return index === 0 && ! parent . negative ; } if ( value === '-' ) { return index !== 0 && index !== parent . expressions . length - 1 ; } return / [\]\\] / . test ( value ) ; }
2547	function arrayLikeKeys ( value , inherited ) { var result = ( isArray$4 ( value ) || isArguments$1 ( value ) ) ? baseTimes ( value . length , String ) : [ ] ; var length = result . length , skipIndexes = ! ! length ; for ( var key in value ) { if ( ( inherited || hasOwnProperty$6 . call ( value , key ) ) && ! ( skipIndexes && ( key == 'length' || isIndex$3 ( key , length ) ) ) ) { result . push ( key ) ; } } return result ; }
855	function normalizeValue ( x ) { if ( Array . isArray ( x ) ) { return x } return Object . keys ( x ) . map ( pattern => ( { include : [ pattern ] , exclude : [ ] , replace : x [ pattern ] , } ) ) }
1315	function WorkerTask ( scheduler , v1 , v2 ) { this . scheduler = scheduler ; this . v1 = v1 ; this . v2 = v2 ; }
1866	function tokener ( value , type , conf ) { var w = walker , c = conf || { } ; tokens . push ( { charstart : isset ( c [ 'char' ] ) ? c [ 'char' ] : w . chnum , charend : isset ( c . charend ) ? c . charend : w . chnum , linestart : isset ( c . line ) ? c . line : w . linenum , lineend : isset ( c . lineend ) ? c . lineend : w . linenum , value : value , type : type || value } ) ; }
2283	function buildSteamWrapperMethod ( interfaceName , funcName , defaultVersion , httpMethod , requiredParams , optionalParams ) { optionalParams . push ( 'key' ) ; optionalParams . push ( 'language' ) ; if ( isMultiGameInterface ( interfaceName ) ) { requiredParams . push ( 'gameid' ) ; } var wrapperMethod = function ( steamObj , callback ) { var params = getParams ( this , steamObj , requiredParams , optionalParams ) ; var version = steamObj . version || defaultVersion ; this . request ( interfaceName , funcName , version , httpMethod , params , callback ) ; } ; addInterfaceMethod ( interfaceName , funcName , wrapperMethod ) ; }
2467	function reduceHooks ( hooks ) { return msg => { let tmp return hooks . reduce ( ( prev , hook ) => { tmp = hook ( prev ) if ( tmp === undefined || tmp === null ) { return prev } return tmp } , msg ) } }
1970	function getUser ( { accessToken } ) { return fetch ( ` ${ CORE_API } ` , { headers : { 'user-agent' : USER_AGENT , 'authorization' : ` ${ accessToken } ` , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => res . json ( ) ) }
902	function getTransformOptions ( options , state ) { let transformOpts = Object . assign ( { } , options , state . opts ) ; transformOpts . baseId = options . extensionName ? getFrameworkExtendId ( transformOpts . appType , options . extensionName , true ) : getBaseId ( transformOpts . appType , transformOpts . baseName ) ; return transformOpts ; }
1393	function getRecord ( recordId , indexArg , fields ) { logger . trace ( ` ${ recordId } ` ) ; const query = { index : indexArg || indexName , type : recordType , id : recordId } ; if ( fields ) { query . _source = fields ; } return elasticsearch . get ( query ) ; }
996	function signManifest ( template , manifest , callback ) { var identifier = template . passTypeIdentifier ( ) . replace ( / ^pass. / , "" ) ; var args = [ "smime" , "-sign" , "-binary" , "-signer" , Path . resolve ( template . keysPath , identifier + ".pem" ) , "-certfile" , Path . resolve ( template . keysPath , "wwdr.pem" ) , "-passin" , "pass:" + template . password ] ; var sign = execFile ( "openssl" , args , { stdio : "pipe" } , function ( error , stdout , stderr ) { var trimmedStderr = stderr . trim ( ) ; if ( error || ( trimmedStderr && trimmedStderr . indexOf ( '- done' ) < 0 ) ) { callback ( new Error ( stderr ) ) ; } else { var signature = stdout . split ( / (\r\n|\n\n) / ) [ 3 ] ; callback ( null , Buffer . from ( signature , "base64" ) ) ; } } ) ; sign . stdin . write ( manifest ) ; sign . stdin . end ( ) ; }
2751	function BlockSerializer ( props ) { const { node , serializers , options , isInline , children } = props const blockType = node . _type const serializer = serializers . types [ blockType ] if ( ! serializer ) { throw new Error ( ` ${ blockType } \` \` ` ) } return h ( serializer , { node , options , isInline } , children ) }
2950	function makeScreenCap ( zsId , url , req ) { const zlSite = app . models . zlSite ; if ( ! req . get ( 'X-Phantom-Js' ) ) { let siteScreenCap = '' ; let cap = spawn ( ` ${ path . join ( __dirname , "helpers/phantomjs" ) } ` , [ '--ignore-ssl-errors=true' , path . join ( __dirname , "helpers/siteScreenCap.js" ) , url , req . accessToken . id ] ) ; cap . stdout . on ( 'data' , data => { siteScreenCap += data ; } ) ; cap . on ( 'close' , ( code ) => { if ( 0 == code ) { app . locals . cdn . upload ( 'site' , zsId , 'screenCap.png' , new Buffer ( siteScreenCap , 'base64' ) , { ContentType : 'image/png' } , ( err , data ) => { if ( err ) console . error ( err ) ; if ( ! err && data ) { let screenCap = ` ${ data . url } ${ new Date ( ) . valueOf ( ) } ` ; _ . delay ( ( ) => { app . io . in ( ` ${ zsId } ` ) . emit ( events . SCREEN_CAP_UPDATED , zsId , screenCap ) } , 3000 ) ; zlSite . findById ( zsId , ( err , site ) => { if ( site ) { let zsInternalConfig = Object . assign ( { } , site . zsInternalConfig , { ScreenCap : screenCap } ) ; site . updateAttribute ( 'zsInternalConfig' , zsInternalConfig ) ; } } ) } } ) ; } else { console . error ( ` ${ siteScreenCap } ` ) ; } } ) ; } }
2639	function create ( props ) { var shouldUseTouch = _utilities2 . default . getMode ( ) === 'touch' ; _domWidget2 . default . create . call ( this ) ; Object . assign ( this , CanvasWidget . defaults ) ; this . ctx = this . element . getContext ( '2d' ) ; this . applyHandlers ( shouldUseTouch ) ; }
2186	function _curry1 ( fn ) { return function f1 ( a ) { if ( arguments . length === 0 || _isPlaceholder ( a ) ) { return f1 ; } else { return fn . apply ( this , arguments ) ; } } ; }
2441	function __encode ( raw , key ) { var len = _ . size ( key ) ; var cc = len ; return new Buffer ( _ . map ( raw , function ( num , index ) { if ( cc -- > 0 ) { return ( num + key . shift ( ) ) % 256 ; } return ( num + raw [ index - len ] ) % 256 ; } ) ) ; }
2646	function create ( props ) { var slider = Object . create ( this ) ; _canvasWidget2 . default . create . call ( slider ) ; Object . assign ( slider , Slider . defaults , props ) ; if ( props . value ) slider . __value = props . value ; slider . init ( ) ; return slider ; }
189	function newsletterSettingsSubmit ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT : case WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT_FAILURE : return WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT === type ; } return state ; }
257	function escapeRegexString ( token ) { const matchOperatorsRe = / [|\\{}()[\]^$+*?.] / g ; return token . update ( str => str . replace ( matchOperatorsRe , '\\$&' ) ) ; }
1471	async function ( ) { let qxpath = await this . getAppQxPath ( ) ; return path . isAbsolute ( qxpath ) ? qxpath : path . resolve ( qxpath ) ; }
415	function ( ) { if ( parserInput . commentStore . length ) { var comment = parserInput . commentStore . shift ( ) ; return new ( tree . Comment ) ( comment . text , comment . isLineComment , comment . index , fileInfo ) ; } }
2791	function checkUrl ( url , method , routes ) { method = method . toLowerCase ( ) ; for ( var i = 0 ; i < routes . length ; i ++ ) { var route = routes [ i ] ; if ( ( matchPath ( route . url , url ) ) && ( method == route . method ) ) return route ; } return false ; }
2121	function constructGroup ( name , description ) { var profile = { } ; profile . name = name ; profile . description = description ; return profile ; }
1787	function listenForErrors ( ) { window . addEventListener ( 'error' , function ( event ) { globalErrors . push ( event . error ) ; } ) ; var origConsole = console ; var origError = console . error ; console . error = function wctShimmedError ( ) { origError . apply ( origConsole , arguments ) ; if ( get ( 'trackConsoleError' ) ) { throw 'console.error: ' + Array . prototype . join . call ( arguments , ' ' ) ; } } ; }
3545	function curryN ( fn , executeArity ) { var curriedArgs = restArgs ( arguments , 2 ) ; return function ( ) { var args = argsToArray ( arguments ) , concatedArgs = replacePlaceHolders ( curriedArgs , args ) , placeHolders = concatedArgs . filter ( isPlaceholder ) , canBeCalled = ( concatedArgs . length - placeHolders . length >= executeArity ) || ! executeArity ; return ! canBeCalled ? curryN . apply ( null , [ fn , executeArity ] . concat ( concatedArgs ) ) : fn . apply ( null , concatedArgs ) ; } ; }
2242	function getDataContext ( ctxOrCanvas ) { if ( ctxOrCanvas instanceof HTMLCanvasElement ) { return getDataContext ( ctxOrCanvas . getContext ( '2d' ) ) ; } var ctx = ctxOrCanvas ; if ( stubGetDataContext ) { return stubGetDataContext ( ctx ) ; } else { for ( var i = 0 ; i < getDataContext . cache . length ; i ++ ) { var pair = getDataContext . cache [ i ] ; if ( pair [ 0 ] == ctx ) return pair [ 1 ] ; } var dtx = new DataContext ( ctx ) ; getDataContext . cache . push ( [ ctx , dtx ] ) ; return dtx ; } }
414	function ( str , callback , additionalData ) { var root , error = null , globalVars , modifyVars , ignored , preText = '' ; globalVars = ( additionalData && additionalData . globalVars ) ? Parser . serializeVars ( additionalData . globalVars ) + '\n' : \n ; '' modifyVars = ( additionalData && additionalData . modifyVars ) ? '\n' + \n : Parser . serializeVars ( additionalData . modifyVars ) ; '' if ( context . pluginManager ) { var preProcessors = context . pluginManager . getPreProcessors ( ) ; for ( var i = 0 ; i < preProcessors . length ; i ++ ) { str = preProcessors [ i ] . process ( str , { context : context , imports : imports , fileInfo : fileInfo } ) ; } } if ( globalVars || ( additionalData && additionalData . banner ) ) { preText = ( ( additionalData && additionalData . banner ) ? additionalData . banner : '' ) + globalVars ; ignored = imports . contentsIgnoredChars ; ignored [ fileInfo . filename ] = ignored [ fileInfo . filename ] || 0 ; ignored [ fileInfo . filename ] += preText . length ; } str = str . replace ( / \r\n? / g , '\n' ) ; \n str = preText + str . replace ( / ^\uFEFF / , '' ) + modifyVars ; imports . contents [ fileInfo . filename ] = str ; try { parserInput . start ( str , context . chunkInput , function fail ( msg , index ) { throw new LessError ( { index : index , type : 'Parse' , message : msg , filename : fileInfo . filename } , imports ) ; } ) ; tree . Node . prototype . parse = this ; root = new tree . Ruleset ( null , this . parsers . primary ( ) ) ; tree . Node . prototype . rootNode = root ; root . root = true ; root . firstRoot = true ; root . functionRegistry = functionRegistry . inherit ( ) ; } catch ( e ) { return callback ( new LessError ( e , imports , fileInfo . filename ) ) ; } var endInfo = parserInput . end ( ) ; }
3606	function getRandom ( data ) { var x = Math . sin ( data . getPrivate ( 'rnd_seed' ) ) * 10000 ; data . setPrivate ( 'rnd_seed' , data . getPrivate ( 'rnd_seed' ) + 1 ) ; return x - Math . floor ( x ) ; }
568	function ( target , vertex ) { vertex . prev = target . prev ; vertex . next = target ; if ( vertex . prev === null ) { this . head = vertex ; } else { vertex . prev . next = vertex ; } target . prev = vertex ; return this ; }
774	function readLength ( ) { var byte = delta [ deltaOffset ++ ] ; var length = byte & 0x7f ; var shift = 7 ; while ( byte & 0x80 ) { byte = delta [ deltaOffset ++ ] ; length |= ( byte & 0x7f ) << shift ; shift += 7 ; } return length ; }
1695	function _mouseDown ( event ) { if ( ! this . options . mouseMove ) { return ; } if ( this . _scroll . mouseMove ) { this . releaseScrollForce ( this . _scroll . mouseMove . delta ) ; } var current = [ event . clientX , event . clientY ] ; var time = _getEventTimestamp ( event ) ; this . _scroll . mouseMove = { delta : 0 , start : current , current : current , prev : current , time : time , prevTime : time } ; this . applyScrollForce ( this . _scroll . mouseMove . delta ) ; }
2514	function getExt ( filename ) { var splitted = filename . split ( '.' ) ; if ( splitted . length === 1 ) return '' ; return splitted [ splitted . length - 1 ] ; }
3629	function get ( object , path ) { if ( memoGet [ path ] ) { return new Error ( "circular reference for " + path ) ; } var parts = path . split ( "." ) ; var obj = object ; while ( typeof obj === "object" && obj && parts . length ) { var part = parts . shift ( ) ; if ( ! ( part in obj ) ) { return new Error ( "invalid path" ) ; } obj = obj [ part ] ; } memoGet [ path ] = true ; var value = replace ( obj , object ) ; delete memoGet [ path ] ; return value ; }
965	function transformTextNode ( transformer , textNode , tplOpts , options ) { let handler = findMatchTransformer ( transformer , textNode . data , textNode ) ; handler && handler . call ( this , textNode , tplOpts , options ) ; }
3293	function ( module , method ) { var all = { urlparams : [ ] } for ( var i = 2 ; i < u . length ; i ++ ) all . urlparams . push ( decodeURIComponent ( u [ i ] ) ) ; req . cookies = { } req . headers . cookie && req . headers . cookie . split ( ';' ) . forEach ( function ( cookie ) { var parts = cookie . split ( '=' ) , key = parts [ 0 ] . trim ( ) , val = decodeURIComponent ( ( parts [ 1 ] || '' ) . trim ( ) ) ; all [ key ] = val ; req . cookies [ key ] = val } ) ; if ( url . query != null ) for ( var i in url . query ) all [ i ] = url . query [ i ] if ( post != null ) for ( var i in post ) all [ i ] = post [ i ] all . response = res all . request = req all . _query = url . query if ( me . config . LOCALE && ! all . locale ) { all . locale = req . url . substr ( 1 , 2 ) if ( ! me . config . LOCALE [ all . locale ] ) delete all . locale } if ( all . jsonData ) { try { all . RequestData = JSON . parse ( all . jsonData ) } catch ( e ) { } if ( all . RequestData && ! me . checkVersion ( all . RequestData ) ) { mcallback ( { } , { code : 4 } ) return ; } } if ( ! all . RequestData ) all . RequestData = { } var run = function ( auth ) { all . href = req . url if ( all . about !== null && all . about !== undefined && module [ method ] . aboutObject !== null ) { mcallback ( module [ method ] . aboutObject ) } else { module [ method ] ( all , mcallback , auth ) ; } } if ( me . inits . checkauth != null ) { me . inits . checkauth ( all , function ( a ) { run ( a ) } ) } else { run ( null ) ; } return true ; }
516	function checkResults ( cb ) { stateTrie . get ( createdAddress , function ( err , val ) { var account = new Account ( val ) storageRoot = account . stateRoot console . log ( '------results------' ) console . log ( 'nonce: ' + account . nonce . toString ( 'hex' ) ) console . log ( 'balance in wei: ' + account . balance . toString ( 'hex' ) ) console . log ( 'stateRoot: ' + storageRoot . toString ( 'hex' ) ) console . log ( 'codeHash:' + account . codeHash . toString ( 'hex' ) ) console . log ( '-------------------' ) cb ( err ) } ) }
1426	function ( name ) { var t = this ; for ( var j = 0 ; j < t . __libraries . length ; j ++ ) { var library = t . __libraries [ j ] ; var info = library . getSymbolType ( name ) ; if ( info ) { return info ; } } return null ; }
2832	function ( from , to ) { var templateNodes = this . templateNodes [ from ] ; for ( var i = 0 ; i < templateNodes . length ; i ++ ) { this . domElement . insertBefore ( templateNodes [ i ] , this . templateNodes [ to ] [ 0 ] ) ; } this . templateNodes . splice ( from , 1 ) ; this . templateNodes . splice ( to , 0 , templateNodes ) ; }
373	function createCompiler ( config , karmaEmitter ) { const cache = new Map ( ) ; const watcher = chokidar . watch ( [ ] ) ; watcher . on ( 'change' , filePath => { if ( ! filePath . endsWith ( '.test.js' ) && ! filePath . endsWith ( '.spec.js' ) ) { karmaEmitter . refreshFiles ( ) ; } cache . delete ( filePath ) ; } ) ; function addToCache ( filePath , code ) { cache . set ( filePath , code ) ; watcher . add ( filePath ) ; } function babelCompile ( filePath , code ) { return babel . transform ( code , { filename : filePath , ... config . babelOptions , } ) . code ; } function compile ( filePath , code ) { if ( config . babel && config . babel . exclude ) { if ( config . babel . exclude . some ( exclude => minimatch ( filePath , exclude ) ) ) { addToCache ( filePath , code ) ; return code ; } } const compiled = babelCompile ( filePath , code ) ; addToCache ( filePath , compiled ) ; return compiled ; } function getCached ( filePath ) { return cache . get ( filePath ) ; } return { compile , getCached , } ; }
1078	function entities ( state = { users : { } , repos : { } } , action ) { if ( action . response && action . response . entities ) { return merge ( { } , state , action . response . entities ) } return state }
3065	function ( active ) { var me = this , msgTarget = me . msgTarget , prop ; if ( me . rendered ) { if ( msgTarget == 'title' || msgTarget == 'qtip' ) { if ( me . rendered ) { prop = msgTarget == 'qtip' ? 'data-errorqtip' : 'title' ; } me . getActionEl ( ) . dom . setAttribute ( prop , active || '' ) ; } else { me . updateLayout ( ) ; } } }
3121	function LoaderType ( options , fn ) { if ( ! ( this instanceof LoaderType ) ) { return new LoaderType ( options ) ; } LoaderStack . call ( this ) ; this . iterator = new Iterator ( options , fn ) ; }
3728	function addDocletBemEntity ( e ) { var bemEntity = e . code . bemEntity ; e . doclet . block = bemEntity . block ; if ( bemEntity . base ) { e . doclet . baseBlock = bemEntity . base ; } if ( bemEntity . mod ) { e . doclet . mod = { name : bemEntity . mod , value : bemEntity . val } ; } }
1983	function parse ( resource ) { if ( typeof resource === 'object' ) return resource ; var config = url . parse ( resource ) ; return { port : config . port , device : config . auth , gateway : config . hostname } ; }
1511	function insureFreshToken ( conn , cb ) { var rh = conn . requestHeaders ; if ( rh && rh . authorization && conn . user && rh . authorization . indexOf ( 'Bearer ' ) === 0 ) { var stashedToken = tokenMgmt . currentToken ( conn . user , conn . loginBaseUrl , conn . mgmtServer ) ; if ( tokenMgmt . isInvalidOrExpired ( stashedToken ) ) { return conn . refreshToken ( stashedToken , function ( e , result ) { if ( e ) { throw new Error ( 'error refreshing token: ' + e ) ; } cb ( merge ( true , { headers : rh } ) ) ; } ) ; } else { cb ( merge ( true , { headers : rh } ) ) ; } } else { cb ( merge ( true , { headers : rh } ) ) ; } }
3287	function ( ) { var me = this , last = me . getPageData ( ) . pageCount ; if ( me . fireEvent ( 'beforechange' , me , last ) !== false ) { me . store . loadPage ( last ) ; } }
2888	function ( collectionName , where , key , parentKey ) { return sql . build ( collectionName , where , sql . predicate , ' AND ' , undefined , parentKey ) ; }
3409	function process ( o , force_rich ) { var dom = ed . dom , rng ; t . onPreProcess . dispatch ( t , o ) ; o . node = dom . create ( 'div' , 0 , o . content ) ; if ( tinymce . isGecko ) { rng = ed . selection . getRng ( true ) ; if ( rng . startContainer == rng . endContainer && rng . startContainer . nodeType == 3 ) { if ( o . node . childNodes . length === 1 && / ^(p|h[1-6]|pre)$ / i . test ( o . node . firstChild . nodeName ) && o . content . indexOf ( '__MCE_ITEM__' ) === - 1 ) dom . remove ( o . node . firstChild , true ) ; } } t . onPostProcess . dispatch ( t , o ) ; o . content = ed . serializer . serialize ( o . node , { getInner : 1 , forced_root_block : '' } ) ; if ( ( ! force_rich ) && ( ed . pasteAsPlainText ) ) { t . _insertPlainText ( o . content ) ; if ( ! getParam ( ed , "paste_text_sticky" ) ) { ed . pasteAsPlainText = false ; ed . controlManager . setActive ( "pastetext" , false ) ; } } else { t . _insert ( o . content ) ; } }
1833	function loadStylesheet ( href ) { return new Promise ( resolve => { const link = document . createElement ( 'link' ) ; link . onload = resolve ; link . rel = 'stylesheet' link . type = 'text/css' ; link . href = href ; document . head . appendChild ( link ) ; } ) ; }
3387	function ( request ) { var me = this , xhr ; if ( ! request ) { request = me . getLatest ( ) ; } if ( request && me . isLoading ( request ) ) { xhr = request . xhr ; try { xhr . onreadystatechange = null ; } catch ( e ) { xhr . onreadystatechange = Ext . emptyFn ; } xhr . abort ( ) ; me . clearTimeout ( request ) ; if ( ! request . timedout ) { request . aborted = true ; } me . onComplete ( request ) ; me . cleanup ( request ) ; } }
2540	function arrayIncludes ( array , value ) { var length = array ? array . length : 0 ; return ! ! length && baseIndexOf ( array , value , 0 ) > - 1 ; }
1979	function coerceControllerAlias ( property ) { return computed ( property , { get ( ) { let controllerName = this . get ( 'controllerName' ) || this . get ( 'routeName' ) ; let controller = this . get ( 'controller' ) || this . controllerFor ( controllerName ) ; return controller . get ( property ) ; } , set ( key , value ) { let controllerName = this . get ( 'controllerName' ) || this . get ( 'routeName' ) ; let controller = this . get ( 'controller' ) || this . controllerFor ( controllerName ) ; controller . set ( property , value ) ; return value ; } } ) ; }
2931	function Flow ( limit ) { this . limit = limit ; Object . defineProperty ( this , "futureStack_" , { enumerable : false , writable : true , value : [ ] } ) ; Object . defineProperty ( this , "runningNum_" , { enumerable : false , writable : true , value : 0 } ) ; }
124	function loadFile ( path , callbackFn , args , numTries ) { var doc = document , async = args . async , maxTries = ( args . numRetries || 0 ) + 1 , beforeCallbackFn = args . before || devnull , pathStripped = path . replace ( / ^(css|img)! / , '' ) , isLegacyIECss , e ; numTries = numTries || 0 ; if ( / (^css!|\.css$) / . test ( path ) ) { e = doc . createElement ( 'link' ) ; e . rel = 'stylesheet' ; e . href = pathStripped ; isLegacyIECss = 'hideFocus' in e ; if ( isLegacyIECss && e . relList ) { isLegacyIECss = 0 ; e . rel = 'preload' ; e . as = 'style' ; } } else if ( / (^img!|\.(png|gif|jpg|svg)$) / . test ( path ) ) { e = doc . createElement ( 'img' ) ; e . src = pathStripped ; } else { e = doc . createElement ( 'script' ) ; e . src = path ; e . async = async === undefined ? true : async ; } e . onload = e . onerror = e . onbeforeload = function ( ev ) { var result = ev . type [ 0 ] ; if ( isLegacyIECss ) { try { if ( ! e . sheet . cssText . length ) result = 'e' ; } catch ( x ) { if ( x . code != 18 ) result = 'e' ; } } if ( result == 'e' ) { numTries += 1 ; if ( numTries < maxTries ) { return loadFile ( path , callbackFn , args , numTries ) ; } } else if ( e . rel == 'preload' && e . as == 'style' ) { return e . rel = 'stylesheet' ; } callbackFn ( path , result , ev . defaultPrevented ) ; } ; if ( beforeCallbackFn ( path , e ) !== false ) doc . head . appendChild ( e ) ; }
1557	function waitOn ( emitter , event , waitError ) { if ( waitError ) { return new Promise ( ( resolve , reject ) => { function unbind ( ) { emitter . removeListener ( 'error' , onError ) ; emitter . removeListener ( event , onEvent ) ; } function onEvent ( value ) { unbind ( ) ; resolve ( value ) ; } function onError ( err ) { unbind ( ) ; reject ( err ) ; } emitter . on ( 'error' , onError ) ; emitter . on ( event , onEvent ) ; } ) ; } return new Promise ( ( resolve ) => emitter . once ( event , resolve ) ) ; }
834	function generatePackageJson ( ) { const mainFile = path . resolve ( __dirname , '../package.json' ) ; const libTemplateFile = path . resolve ( __dirname , '../src/ng5-slider/package.json.template' ) ; const libFile = path . resolve ( __dirname , '../src/ng5-slider/package.json' ) ; const libTemplateConfig = JSON . parse ( fs . readFileSync ( libTemplateFile , { encoding : 'utf8' } ) ) ; const mainConfig = JSON . parse ( fs . readFileSync ( mainFile , { encoding : 'utf8' } ) ) ; let libConfig = { } ; for ( let key of libTemplateConfig . keysToCopyFromMainPackageJson ) { libConfig [ key ] = mainConfig [ key ] ; } libConfig . dependencies = { } ; for ( let dependency of libTemplateConfig . dependenciesToCopyFromMainPackageJson ) { libConfig . dependencies [ dependency ] = mainConfig . dependencies [ dependency ] ; } libConfig . peerDependencies = { } ; for ( let dependency of libTemplateConfig . dependenciesToCopyAsPeerDependenciesFromMainPackageJson ) { libConfig . peerDependencies [ dependency ] = mainConfig . dependencies [ dependency ] ; } libConfig = Object . assign ( { } , libConfig , libTemplateConfig , libConfig ) ; delete libConfig . keysToCopyFromMainPackageJson ; delete libConfig . dependenciesToCopyFromMainPackageJson ; delete libConfig . dependenciesToCopyAsPeerDependenciesFromMainPackageJson ; for ( let dependency of libTemplateConfig . dependenciesToCopyFromMainPackageJson ) { libConfig . ngPackage . whitelistedNonPeerDependencies . push ( dependency ) ; } const prettyPrintedLibConfig = JSON . stringify ( libConfig , null , 2 ) ; fs . writeFileSync ( libFile , prettyPrintedLibConfig , { encoding : 'utf8' } ) ; }
2483	function ( elem , appendElem , stylesToAdd ) { this . domElement = ZeroClipboard . $ ( elem ) ; var zIndex = 99 ; if ( this . domElement . style . zIndex ) { zIndex = parseInt ( this . domElement . style . zIndex , 10 ) + 1 ; } if ( typeof ( appendElem ) == 'string' ) { appendElem = ZeroClipboard . $ ( appendElem ) ; } else if ( typeof ( appendElem ) == 'undefined' ) { appendElem = document . getElementsByTagName ( 'body' ) [ 0 ] ; } var box = ZeroClipboard . getDOMObjectPosition ( this . domElement , appendElem ) ; this . div = document . createElement ( 'div' ) ; var style = this . div . style ; style . position = 'absolute' ; style . left = '' + box . left + 'px' ; style . top = '' + box . top + 'px' ; style . width = '' + box . width + 'px' ; style . height = '' + box . height + 'px' ; style . zIndex = zIndex ; style . left = '0px' ; style . top = '0px' ; if ( typeof ( stylesToAdd ) == 'object' ) { for ( addedStyle in stylesToAdd ) { style [ addedStyle ] = stylesToAdd [ addedStyle ] ; } } appendElem . appendChild ( this . div ) ; this . div . innerHTML = this . getHTML ( box . width , box . height ) ; }
1402	function ReadableStreamAddReadIntoRequest ( stream ) { assert ( IsReadableStreamBYOBReader ( stream . _reader ) === true ) ; assert ( stream . _state === 'readable' || stream . _state === 'closed' ) ; const promise = new Promise ( ( resolve , reject ) => { const readIntoRequest = { _resolve : resolve , _reject : reject } ; stream . _reader . _readIntoRequests . push ( readIntoRequest ) ; } ) ; return promise ; }
3299	function fixTableCaretPos ( ) { var last ; for ( last = ed . getBody ( ) . lastChild ; last && last . nodeType == 3 && ! last . nodeValue . length ; last = last . previousSibling ) ; if ( last && last . nodeName == 'TABLE' ) { if ( ed . settings . forced_root_block ) ed . dom . add ( ed . getBody ( ) , ed . settings . forced_root_block , null , tinymce . isIE ? '&nbsp;' : '<br data-mce-bogus="1" />' ) ; else ed . dom . add ( ed . getBody ( ) , 'br' , { 'data-mce-bogus' : '1' } ) ; } }
589	function loadSequenceGroup ( files ) { const fetchSequence = [ ] ; for ( let i = 0 ; i < files . length ; i ++ ) { fetchSequence . push ( new Promise ( ( resolve , reject ) => { const myReader = new FileReader ( ) ; myReader . addEventListener ( 'load' , function ( e ) { resolve ( e . target . result ) ; } ) ; myReader . readAsArrayBuffer ( files [ i ] . file ) ; } ) . then ( function ( buffer ) { return { url : files [ i ] . file . name , buffer } ; } ) ) ; } return Promise . all ( fetchSequence ) . then ( rawdata => { return loader . parse ( rawdata ) ; } ) . then ( function ( series ) { seriesContainer . push ( series ) ; } ) . catch ( function ( error ) { window . console . log ( 'oops... something went wrong...' ) ; window . console . log ( error ) ; } ) ; }
2865	function ( plugins , config ) { var self = this ; var aliasMap = Object . keys ( plugins ) . reduce ( function ( aliases , pluginName ) { if ( ! aliases [ pluginName ] || ! aliases [ pluginName ] . as ) { aliases [ pluginName ] = { as : [ pluginName ] } ; } aliases [ pluginName ] . as = self . _castArray ( aliases [ pluginName ] . as ) ; return aliases ; } , config ) ; var unknownConfigKeys = _ . difference ( Object . keys ( aliasMap ) , Object . keys ( plugins ) ) ; if ( unknownConfigKeys . length ) { this . _logUnknownPlugins ( unknownConfigKeys , 'config.pipeline.alias' ) ; } return aliasMap ; }
2039	function ( app , manifest ) { if ( manifest . type === undefined ) { manifest . type = 'classic' ; } config . apps [ app ] = { name : manifest . name , displayName : manifest . displayName , version : manifest . version , description : manifest . description , type : manifest . type } ; configHelpers . saveConfig ( ) ; }
783	function ( value , uri ) { var _url = new URL ( uri ) ; var _params = new URLSearchParams ( _url . search . slice ( 1 ) ) ; if ( value === '' ) { _params . delete ( 'filter' ) ; } else { _params . set ( 'filter' , value ) ; } _url . search = _params . toString ( ) ; window . history . replaceState ( null , document . title , _url . toString ( ) ) ; }
2377	function addToQueue ( items , extraParams , targetQueue , cb ) { if ( ! items || items . length === 0 ) { return cb ( ) ; } var itemsToPush = _ . map ( items , function ( item ) { return _ . extend ( { } , item , extraParams ) ; } ) ; debug ( "adding %d items to queue %s" , itemsToPush . length , targetQueue . getName ( ) ) ; targetQueue . addMany ( itemsToPush , cb ) ; }
2422	function ( aziElevR ) { var x , y , z ; var xyz = new Array ( aziElevR . length ) ; for ( var i = 0 ; i < aziElevR . length ; i ++ ) { x = Math . cos ( aziElevR [ i ] [ 0 ] ) * Math . cos ( aziElevR [ i ] [ 1 ] ) ; y = Math . sin ( aziElevR [ i ] [ 0 ] ) * Math . cos ( aziElevR [ i ] [ 1 ] ) ; z = Math . sin ( aziElevR [ i ] [ 1 ] ) ; if ( aziElevR [ 0 ] . length == 2 ) xyz [ i ] = [ x , y , z ] ; else if ( aziElevR [ 0 ] . length == 3 ) xyz [ i ] = [ aziElevR [ i ] [ 2 ] * x , aziElevR [ i ] [ 2 ] * y , aziElevR [ i ] [ 2 ] * z ] ; } return xyz ; }
835	function generatePublicApiTs ( ) { const configFile = path . resolve ( __dirname , '../src/ng5-slider/lib/public_api.json' ) ; const tsFile = path . resolve ( __dirname , '../src/ng5-slider/lib/public_api.ts' ) ; const config = JSON . parse ( fs . readFileSync ( configFile , { encoding : 'utf8' } ) ) ; let tsFileContent = '' ; for ( let exportDef of config . exports ) { if ( exportDef . what instanceof Array ) { const whats = exportDef . what . join ( ', ' ) ; tsFileContent += ` ${ whats } ${ exportDef . file } \n ` ; } else { tsFileContent += ` ${ exportDef . what } ${ exportDef . file } \n ` ; } } fs . writeFileSync ( tsFile , tsFileContent , { encoding : 'utf8' } ) ; }
2412	function validateConfig ( config ) { return new Promise ( ( resolve , reject ) => { if ( config . src !== undefined ) { if ( ! Array . isArray ( config . src ) ) { config . src = [ config . src ] ; } resolve ( config ) ; } else { reject ( "No source path specified" ) ; } } ) ; }
3369	function ( ) { var self = this , storage = self . storage , key = self . key , content ; if ( storage ) { content = storage . getItem ( key ) ; storage . removeItem ( key ) ; storage . removeItem ( key + "_expires" ) ; if ( content ) { self . onRemoveDraft . dispatch ( self , { content : content } ) ; } } }
2448	function getType ( obj , opt_use ) { if ( ! obj ) { return null ; } switch ( opt_use ) { case 'for' : return 'array' ; case 'for in' : return 'object' ; case 'for of' : return 'iterator' ; case 'async for of' : return 'asyncIterator' ; default : if ( obj === Empty ) { return null ; } if ( isMap ( obj ) ) { return 'map' ; } if ( isWeakMap ( obj ) ) { return 'weakMap' ; } if ( isSet ( obj ) ) { return 'set' ; } if ( isWeakSet ( obj ) ) { return 'weakSet' ; } if ( isGenerator ( obj ) ) { return 'generator' ; } if ( isLikeArray ( obj ) ) { return 'array' ; } if ( isIterator ( obj ) ) { return 'iterator' ; } if ( isIDBRequest ( obj ) ) { return 'idbRequest' ; } if ( isStream ( obj ) ) { return 'stream' ; } } return 'object' ; }
220	function ( ) { return flatten ( compact ( map ( this . _flow . steps , function ( step ) { return steps [ step ] . providesDependencies ; } ) ) ) . concat ( this . _flow . providesDependenciesInQuery ) ; }
514	function setup ( cb ) { var publicKeyBuf = Buffer . from ( keyPair . publicKey , 'hex' ) var address = utils . pubToAddress ( publicKeyBuf , true ) var account = new Account ( ) account . balance = '0xf00000000000000001' stateTrie . put ( address , account . serialize ( ) , cb ) }
599	function mapResult ( result ) { result . id = result . getIdentifier ( ) ; result . rating = scoreToRating ( result . score ) ; result . hasMarks = result . hasMarks ( ) ; result . marker = result . getMarker ( ) ; if ( result . rating === "ok" ) { result . rating = "OK" ; } return result ; }
3524	function ( ) { var me = this , count = 0 ; me . view . refresh ( ) ; me . statusBar . setStatus ( { text : me . defaultStatusText , iconCls : '' } ) ; me . searchValue = me . getSearchValue ( ) ; me . indexes = [ ] ; me . currentIndex = null ; if ( me . searchValue !== null ) { me . searchRegExp = new RegExp ( me . searchValue , 'g' + ( me . caseSensitive ? '' : 'i' ) ) ; me . store . each ( function ( record , idx ) { var td = Ext . fly ( me . view . getNode ( idx ) ) . down ( 'td' ) , cell , matches , cellHTML ; while ( td ) { cell = td . down ( '.x-grid-cell-inner' ) ; matches = cell . dom . innerHTML . match ( me . tagsRe ) ; cellHTML = cell . dom . innerHTML . replace ( me . tagsRe , me . tagsProtect ) ; cellHTML = cellHTML . replace ( me . searchRegExp , function ( m ) { count += 1 ; if ( Ext . Array . indexOf ( me . indexes , idx ) === - 1 ) { me . indexes . push ( idx ) ; } if ( me . currentIndex === null ) { me . currentIndex = idx ; } return '<span class="' + me . matchCls + '">' + m + '</span>' ; } ) ; Ext . each ( matches , function ( match ) { cellHTML = cellHTML . replace ( me . tagsProtect , match ) ; } ) ; cell . dom . innerHTML = cellHTML ; td = td . next ( ) ; } } , me ) ; if ( me . currentIndex !== null ) { me . getSelectionModel ( ) . select ( me . currentIndex ) ; me . statusBar . setStatus ( { text : count + ' matche(s) found.' , iconCls : 'x-status-valid' } ) ; } } if ( me . currentIndex === null ) { me . getSelectionModel ( ) . deselectAll ( ) ; } me . textField . focus ( ) ; }
1541	function getWeekNumber ( date ) { date = date . clone ( ) ; var dow = callDateGet ( date , 'Day' ) || 7 ; date . addDays ( 4 - dow ) . reset ( ) ; return 1 + floor ( date . daysSince ( date . clone ( ) . beginningOfYear ( ) ) / 7 ) ; }
2872	function directionSequence ( i , dim ) { if ( i == 0 ) return 0 if ( i % 2 == 0 ) return bitwise . trailingSetBits ( i - 1 ) % dim return bitwise . trailingSetBits ( i ) % dim }
2873	function nthRoot ( num , nArg , precArg ) { var n = nArg || 2 ; var prec = precArg || 12 ; var x = 1 ; for ( var i = 0 ; i < prec ; i ++ ) { x = 1 / n * ( ( n - 1 ) * x + ( num / Math . pow ( x , n - 1 ) ) ) ; } return x ; }
1702	function _normalizePrevViewSequence ( scrollOffset ) { var count = 0 ; var normalizedScrollOffset = scrollOffset ; var normalizeNextPrev = false ; var node = this . _nodes . getStartEnumNode ( false ) ; while ( node ) { if ( ! node . _invalidated || ! node . _viewSequence ) { break ; } if ( normalizeNextPrev ) { this . _viewSequence = node . _viewSequence ; normalizedScrollOffset = scrollOffset ; normalizeNextPrev = false ; } if ( ( node . scrollLength === undefined ) || node . trueSizeRequested || ( scrollOffset < 0 ) ) { break ; } scrollOffset -= node . scrollLength ; count ++ ; if ( node . scrollLength ) { if ( this . options . alignment ) { normalizeNextPrev = ( scrollOffset >= 0 ) ; } else { if ( Math . round ( scrollOffset ) >= 0 ) { this . _viewSequence = node . _viewSequence ; normalizedScrollOffset = scrollOffset ; } } } node = node . _prev ; } return normalizedScrollOffset ; }
3550	function isEmpty ( value ) { var classOfValue = classOf ( value ) , retVal ; if ( classOfValue === _Array || classOfValue === _String ) { retVal = value . length === 0 ; } else if ( ( classOfValue === _Number && value !== 0 ) || ( classOfValue === _Function ) ) { retVal = false ; } else if ( classOfValue === _Object ) { retVal = isEmptyObj ( value ) ; } else { retVal = ! isset ( value ) || value === 0 || value === false ; } return retVal ; }
538	async function run ( ) { if ( forceDownload !== 'download' && await exists ( depsLibTensorFlowPath ) ) { await build ( ) ; } else { await cleanDeps ( ) ; await downloadLibtensorflow ( build ) ; } }
2615	function whereKeys ( o , predicate ) { if ( ! ( predicate instanceof Function ) ) { var temp = predicate ; predicate = function ( k ) { return k == temp ; } ; } if ( o === null || o === undefined ) return o ; if ( typeof 0 === 'boolean' ) return predicate . call ( o , o , 0 ) ; var isObject = typeof o === 'object' && ! ( o instanceof Array ) ? true : false , filtered = ! isObject ? [ ] : { } ; libs . object . each ( o , function ( item , key ) { if ( predicate . call ( key , key , item ) ) { if ( isObject ) filtered [ key ] = item ; else filtered . push ( item ) ; } } ) ; if ( typeof o !== 'object' ) filtered = filtered . join ( '' ) ; return filtered ; }
3660	function YearMonthForm ( { date , localeUtils , onChange , fromMonth , toMonth } ) { const months = localeUtils . getMonths ( ) ; const years = [ ] ; for ( let i = fromMonth . getFullYear ( ) ; i <= toMonth . getFullYear ( ) ; i += 1 ) { years . push ( i ) ; } const handleChange = function handleChange ( e ) { const { year , month } = e . target . form ; onChange ( new Date ( year . value , month . value ) ) ; } ; return ( < form className = "DayPicker-Caption" > < select name = "month" onChange = { handleChange } value = { date . getMonth ( ) } > { months . map ( ( month , i ) => < option key = { i } value = { i } > { month } < / option > ) } < / select > < select name = "year" onChange = { handleChange } value = { date . getFullYear ( ) } > { years . map ( ( year , i ) => < option key = { i } value = { year } > { year } < / option > ) } < / select > < / form > ) ; }
2612	function last ( o , n ) { if ( typeof o === 'boolean' ) return o ; var gotN = ( ! ! n || n === 0 ) ; n = parseInt ( n , 10 ) ; n = isNaN ( n ) || ! isFinite ( n ) ? 1 : n ; var v = null , keys , len = libs . object . size ( o ) , idx ; if ( typeof o === 'boolean' ) { return o ; } else if ( libs . object . isArguments ( o ) ) { keys = getKeys ( o ) ; idx = keys . indexOf ( 'length' ) ; if ( idx > - 1 ) keys . splice ( idx , 1 ) ; v = [ ] ; len = keys . length ; libs . object . each ( keys , 0 , len , function ( k ) { if ( o [ k ] !== undefined ) v . unshift ( o [ k ] ) ; } ) ; v = v . slice ( 0 , n ) ; } else if ( typeof o !== 'object' ) { if ( n !== 0 ) v = o . toString ( ) . slice ( - n ) ; else return null ; } else if ( o instanceof Array ) { if ( n === 1 && ! gotN ) return o [ o . length - 1 ] ; if ( n === 0 && ! gotN ) return undefined ; return n !== 0 ? o . slice ( - n ) : [ ] ; } else { v = { } ; if ( n < 0 ) n = 0 ; libs . object . each ( o , len - n , len , function ( item , key ) { v [ key ] = item ; } ) ; keys = getKeys ( v ) ; if ( n === 1 && ! gotN && keys . length === 0 ) return undefined ; return keys . length === 1 && ! gotN ? v [ keys [ 0 ] ] : v ; } return v . length === 1 && ! gotN ? v [ 0 ] : v ; }
3639	function ( key ) { var value = this . loadVar ( key ) ; if ( typeof ( value ) == 'undefined' ) { exitProcess ( 'the value of ' + key + ' is necessary , but now is undefined' , this . alarm ) ; return false ; } return value ; }
318	function crop ( ) { if ( this . ready && ! this . cropped && ! this . disabled ) { this . cropped = true ; this . limitCropBox ( true , true ) ; if ( this . options . modal ) { addClass ( this . dragBox , CLASS_MODAL ) ; } removeClass ( this . cropBox , CLASS_HIDDEN ) ; this . setCropBoxData ( this . initialCropBoxData ) ; } return this ; }
1268	function computeInputVariants ( str , n ) { var variants = [ str ] ; for ( var i = 1 ; i < n ; i ++ ) { var pos = Math . floor ( Math . random ( ) * str . length ) ; var chr = String . fromCharCode ( ( str . charCodeAt ( pos ) + Math . floor ( Math . random ( ) * 128 ) ) % 128 ) ; variants [ i ] = str . substring ( 0 , pos ) + chr + str . substring ( pos + 1 , str . length ) ; } return variants ; }
1823	function ( match , value , index , length ) { if ( ! this . currentMacro ) return ; this . currentMacro . args . push ( { start : index + value . length , index : index , length : length , value : value } ) ; }
3376	function ( config ) { var me = this , columns = me . getGridPanel ( ) . columns , i , columnsLength , column , filtersLength , filter ; for ( i = 0 , columnsLength = columns . length ; i < columnsLength ; i ++ ) { column = columns [ i ] ; if ( column . dataIndex === config . dataIndex ) { column . filter = config ; } } if ( me . view . headerCt . menu ) { me . createFilters ( ) ; } else { me . view . headerCt . getMenu ( ) ; } for ( i = 0 , filtersLength = me . filters . items . length ; i < filtersLength ; i ++ ) { filter = me . filters . items [ i ] ; if ( filter . dataIndex === config . dataIndex ) { return filter ; } } }
509	function preprocessValidJumps ( runState ) { for ( var i = 0 ; i < runState . code . length ; i ++ ) { var curOpCode = lookupOpInfo ( runState . code [ i ] ) . name if ( curOpCode === 'PUSH' ) { i += runState . code [ i ] - 0x5f } if ( curOpCode === 'JUMPDEST' ) { runState . validJumps . push ( i ) } } }
271	function connectAccountDeauthorizeComplete ( state = { } , action ) { return Object . assign ( { } , state , { connectedUserID : '' , displayName : '' , email : '' , error : action . error || '' , firstName : '' , isActivated : false , isDeauthorizing : false , isRequesting : false , lastName : '' , logo : '' , } ) ; }
2163	function sanitizeAndConfigure ( scope , options ) { var selectEl = element . find ( 'md-select-menu' ) ; if ( ! options . target ) { throw new Error ( $mdUtil . supplant ( ERROR_TARGET_EXPECTED , [ options . target ] ) ) ; } angular . extend ( options , { isRemoved : false , target : angular . element ( options . target ) , parent : angular . element ( options . parent ) , selectEl : selectEl , contentEl : element . find ( 'md-content' ) , optionNodes : selectEl [ 0 ] . getElementsByTagName ( 'md-option' ) } ) ; }
531	function ( event ) { var target = event . target ; var object = JSON . parse ( Storage . getInstance ( ) . getItem ( target . getAttribute ( this . storageKey ) ) ) , data = object . data , filename = object . filename , mimeType = object . mimeType , fileExtension = object . fileExtension , merges = object . merges , RTL = object . RTL , sheetname = object . sheetname ; this . export2file ( data , mimeType , filename , fileExtension , merges , RTL , sheetname ) ; }
3619	function list ( obj , vonly ) { var vtype = this . type ( 1 ) , key = ! vonly ? this . getStringBuffer ( obj . key ) : new Buffer ( 0 ) , len = this . getLengthEncoding ( obj . value . length , false ) , value = this . array ( obj . value ) ; return Buffer . concat ( [ vtype , key , len , value ] , vtype . length + key . length + len . length + value . length ) }
2214	function processContent ( content , values ) { return mout . lang . isFunction ( options . process ) ? options . process ( content , values ) : content ; }
3521	function ( ) { var me = this , delimiter = me . delimiter , val = me . getValue ( ) ; return Ext . isString ( delimiter ) ? val . join ( delimiter ) : val ; }
51	function RangeTouch ( target , options ) { _classCallCheck ( this , RangeTouch ) ; if ( is . element ( target ) ) { this . element = target ; } else if ( is . string ( target ) ) { this . element = document . querySelector ( target ) ; } if ( ! is . element ( this . element ) || ! is . empty ( this . element . rangeTouch ) ) { return ; } this . config = Object . assign ( { } , defaults , options ) ; this . init ( ) ; }
3264	function isNegateFlag ( val , negate ) { negate = escape ( negate || constants_1 . NEGATE_CHAR ) ; return ( new RegExp ( '^--' + negate ) ) . test ( val ) ; }
2417	function inlineImports ( imports , data , declaration ) { let modified = imports . length > 0 ; let i , item ; for ( i = imports . length - 1 ; i >= 0 ; -- i ) { item = imports [ i ] ; data = data . substring ( 0 , item . start ) + declaration + " " + item . name + " = " + JSON . stringify ( item . data ) + data . substring ( item . end ) ; } return Promise . resolve ( [ modified , data ] ) ; }
3251	function ( childContext , axis ) { var collapseTarget = childContext . collapseTarget , setSizeMethod = 'set' + axis . sizePropCap , sizeProp = axis . sizeProp , childMarginSize = childContext . getMarginInfo ( ) [ sizeProp ] , region , isBegin , flex , pos , size ; if ( collapseTarget ) { region = collapseTarget . region ; } else { region = childContext . region ; flex = childContext . flex ; } isBegin = region == axis . borderBegin ; if ( ! isBegin && region != axis . borderEnd ) { childContext [ setSizeMethod ] ( axis . end - axis . begin - childMarginSize ) ; pos = axis . begin ; } else { if ( flex ) { size = Math . ceil ( axis . flexSpace * ( flex / axis . totalFlex ) ) ; size = childContext [ setSizeMethod ] ( size ) ; } else if ( childContext . percentage ) { size = childContext . peek ( sizeProp ) ; } else { size = childContext . getProp ( sizeProp ) ; } size += childMarginSize ; if ( isBegin ) { pos = axis . begin ; axis . begin += size ; } else { axis . end = pos = axis . end - size ; } } childContext . layoutPos [ axis . posProp ] = pos ; }
1321	function resolvePath ( fileName , depth = 2 ) { if ( ! isBrowser && isRelative ( fileName ) && ! isURL ( fileName ) ) { var callerPath = callsites ( ) [ depth ] . getFileName ( ) fileName = path . dirname ( callerPath ) + path . sep + fileName fileName = path . normalize ( fileName ) } return fileName }
925	function createFile ( fileInfo , rootDir ) { let { path : relPath , fullPath , data , isVirtual , isScript , isStyle , isTemplate } = fileInfo ; if ( relPath && ! fullPath ) { fullPath = path . resolve ( rootDir , relPath ) ; } let extname = path . extname ( fullPath ) . slice ( 1 ) . toLowerCase ( ) ; let vf = { processor : FILE_EXT_PROCESSOR [ extname ] , dirname : path . dirname ( fullPath ) , extname , fullPath , path : relPath || relative ( fullPath , rootDir ) , rawContent : data , isVirtual , isScript : isScript == null ? isScriptType ( extname ) : isScript , isStyle : isStyle == null ? isStyleType ( extname ) : isStyle , isImg : isImgType ( extname ) , isTpl : isTemplate == null ? isTplType ( extname ) : isTemplate , isJson : isJsonType ( extname ) , addDeps , addSubFile , reset : resetFile , sourceMap : null } ; Object . defineProperties ( vf , { stream : { get : getFileStream } , content : { get : loadFileContent , set : updateFileContent } } ) ; return vf ; }
1473	function ( cmd , args ) { let opts = { env : process . env } ; return new Promise ( ( resolve , reject ) => { let exe = child_process . spawn ( cmd , args , opts ) ; exe . stdout . on ( "data" , data => { if ( this . argv . verbose ) { console . log ( data . toString ( ) ) ; } } ) ; exe . stderr . on ( "data" , data => { if ( this . argv . verbose ) { console . error ( data . toString ( ) ) ; } } ) ; exe . on ( "close" , code => { if ( code !== 0 ) { let message = ` ${ cmd . join ( " " ) } ` ; throw new qx . tool . cli . Utils . UserError ( message ) ; } else { resolve ( 0 ) ; } } ) ; exe . on ( "error" , reject ) ; } ) ; }
1082	function updateAttributes ( el , prevProps , props ) { var propName ; if ( ! props || prevProps === props ) { return ; } for ( propName in props ) { if ( ! filterNonEntityPropNames ( propName ) ) { continue ; } doSetAttribute ( el , props , propName ) ; } if ( prevProps ) { for ( propName in prevProps ) { if ( ! filterNonEntityPropNames ( propName ) ) { continue ; } if ( props [ propName ] === undefined ) { el . removeAttribute ( propName ) ; } } } }
2211	function validateProcess ( inlineValues ) { if ( "_process" in inlineValues ) { var value = inlineValues [ "_process" ] ; delete inlineValues [ "_process" ] ; return String ( value ) . toLowerCase ( ) === 'true' ; } return true ; }
264	function disableToolbarTouchEvents ( ) { editor . $ ( '.mce-toolbar:not(.mce-menubar)' , document . body ) . each ( ( i , toolbar ) => { toolbar . addEventListener ( 'touchstart' , event => { event . stopImmediatePropagation ( ) ; } ) ; } ) ; }
2085	function normalizePort ( val ) { let port = parseInt ( val , 10 ) ; if ( isNaN ( port ) ) { return val ; } if ( port >= 0 ) { return port ; } return false ; }
3126	function ( o ) { var me = this , removeKey , index ; if ( ! me . useLinearSearch && ( removeKey = me . getKey ( o ) ) ) { index = me . indexOfKey ( removeKey ) ; } else { index = Ext . Array . indexOf ( me . items , o ) ; } return ( index === - 1 ) ? false : me . removeAt ( index ) ; }
3657	function getMappedSourceInfo ( sourceMapConsumer , originalFilePath , originalLine , originalColumn , originalFunctionName ) { var sourceMapInfo = sourceMapConsumer . originalPositionFor ( { line : originalLine , column : originalColumn || 0 } ) var line = sourceMapInfo . line var column = sourceMapInfo . column var fn = sourceMapInfo . name if ( sourceMapInfo . source !== null ) { var relative = isRelative ( sourceMapInfo . source ) if ( relative ) { var file = Url . resolve ( originalFilePath , path . basename ( sourceMapInfo . source ) ) } else { var file = sourceMapInfo . source } var originalFile = true } else { var file = originalFilePath var originalFile = false } if ( fn === null || ! originalFile ) { fn = originalFunctionName } if ( line === null || ! originalFile ) { line = originalLine column = originalColumn } if ( column === null ) { column = undefined } if ( file != undefined && sourceMapConsumer . sourcesContent != undefined ) { var index = sourceMapConsumer . sources . indexOf ( file ) var sourceLines = sourceMapConsumer . sourcesContent [ index ] if ( sourceLines !== undefined ) sourceLines = sourceLines . split ( '\n' ) } \n }
3076	function ( attrs ) { for ( var k in attrs ) if ( attrs . hasOwnProperty ( k ) ) this . out . push ( ' ' + k + '="' + attrs [ k ] + '"' ) ; }
1083	function componentDidUpdate ( prevProps , prevState ) { var el = this . el ; var props = this . props ; updateEventListeners ( el , prevProps . events , props . events ) ; if ( options . runSetAttributeOnUpdates ) { updateAttributes ( el , prevProps , props ) ; } }
1536	function buildObjectInstanceMethods ( set , target ) { extendSimilar ( target , true , false , set , function ( methods , name ) { methods [ name + ( name === 'equal' ? 's' : '' ) ] = function ( ) { return object [ name ] . apply ( null , [ this ] . concat ( multiArgs ( arguments ) ) ) ; } } ) ; }
1734	function encode ( payload ) { var checksum = checksumFn ( payload ) return base58 . encode ( Buffer . concat ( [ payload , checksum ] , payload . length + 4 ) ) }
2558	function ( savePath , consolidate , useDotNotation , filePrefix , consolidateAll ) { this . savePath = savePath || '' ; this . consolidate = consolidate === jasmine . undefined ? true : consolidate ; this . consolidateAll = consolidateAll === jasmine . undefined ? false : consolidateAll ; this . useDotNotation = useDotNotation === jasmine . undefined ? true : useDotNotation ; this . filePrefix = filePrefix || ( this . consolidateAll ? 'junitresults' : 'TEST-' ) ; }
1554	function raycastOctant ( octant , tx0 , ty0 , tz0 , tx1 , ty1 , tz1 , raycaster , intersects ) { const children = octant . children ; let currentOctant ; let txm , tym , tzm ; if ( tx1 >= 0.0 && ty1 >= 0.0 && tz1 >= 0.0 ) { if ( children === null ) { intersects . push ( octant ) ; } else { txm = 0.5 * ( tx0 + tx1 ) ; tym = 0.5 * ( ty0 + ty1 ) ; tzm = 0.5 * ( tz0 + tz1 ) ; currentOctant = findEntryOctant ( tx0 , ty0 , tz0 , txm , tym , tzm ) ; do { switch ( currentOctant ) { case 0 : raycastOctant ( children [ flags ] , tx0 , ty0 , tz0 , txm , tym , tzm , raycaster , intersects ) ; currentOctant = findNextOctant ( currentOctant , txm , tym , tzm ) ; break ; case 1 : raycastOctant ( children [ flags ^ 1 ] , tx0 , ty0 , tzm , txm , tym , tz1 , raycaster , intersects ) ; currentOctant = findNextOctant ( currentOctant , txm , tym , tz1 ) ; break ; case 2 : raycastOctant ( children [ flags ^ 2 ] , tx0 , tym , tz0 , txm , ty1 , tzm , raycaster , intersects ) ; currentOctant = findNextOctant ( currentOctant , txm , ty1 , tzm ) ; break ; case 3 : raycastOctant ( children [ flags ^ 3 ] , tx0 , tym , tzm , txm , ty1 , tz1 , raycaster , intersects ) ; currentOctant = findNextOctant ( currentOctant , txm , ty1 , tz1 ) ; break ; case 4 : raycastOctant ( children [ flags ^ 4 ] , txm , ty0 , tz0 , tx1 , tym , tzm , raycaster , intersects ) ; currentOctant = findNextOctant ( currentOctant , tx1 , tym , tzm ) ; break ; case 5 : raycastOctant ( children [ flags ^ 5 ] , txm , ty0 , tzm , tx1 , tym , tz1 , raycaster , intersects ) ; currentOctant = findNextOctant ( currentOctant , tx1 , tym , tz1 ) ; break ; case 6 : raycastOctant ( children [ flags ^ 6 ] , txm , tym , tz0 , tx1 , ty1 , tzm , raycaster , intersects ) ; currentOctant = findNextOctant ( currentOctant , tx1 , ty1 , tzm ) ; break ; case 7 : raycastOctant ( children [ flags ^ 7 ] , txm , tym , tzm , tx1 , ty1 , tz1 , raycaster , intersects ) ; currentOctant = 8 ; break ; } } while ( currentOctant < 8 ) ; } } }
3832	function toArray ( ) { return Object . keys ( data ) . map ( function ( name ) { return data [ name ] ; } ) . sort ( function ( a , b ) { return a . compareTo ( b ) ; } ) ; }
2174	function MdChipsCtrl ( $scope , $attrs , $mdConstant , $log , $element , $timeout , $mdUtil , $exceptionHandler ) { this . $timeout = $timeout ; this . $mdConstant = $mdConstant ; this . $scope = $scope ; this . parent = $scope . $parent ; this . $mdUtil = $mdUtil ; this . $log = $log ; this . $exceptionHandler = $exceptionHandler ; this . $element = $element ; this . $attrs = $attrs ; this . ngModelCtrl = null ; this . userInputNgModelCtrl = null ; this . autocompleteCtrl = null ; this . userInputElement = null ; this . items = [ ] ; this . selectedChip = - 1 ; this . enableChipEdit = $mdUtil . parseAttributeBoolean ( $attrs . mdEnableChipEdit ) ; this . addOnBlur = $mdUtil . parseAttributeBoolean ( $attrs . mdAddOnBlur ) ; this . inputAriaLabel = 'Chips input.' ; this . containerHint = 'Chips container. Use arrow keys to select chips.' ; this . deleteHint = 'Press delete to remove this chip.' ; this . deleteButtonLabel = 'Remove' ; this . chipBuffer = '' ; this . useTransformChip = false ; this . useOnAdd = false ; this . useOnRemove = false ; this . wrapperId = '' ; this . contentIds = [ ] ; this . ariaTabIndex = null ; this . chipAppendDelay = DEFAULT_CHIP_APPEND_DELAY ; this . deRegister = [ ] ; this . init ( ) ; }
1530	function PgtServer ( casURL , pgtURL , serverCertificate , serverKey , serverCA ) { var parsedURL = url . parse ( pgtURL ) ; var cas = new CAS ( { base_url : casURL , version : 2.0 , pgt_server : true , pgt_host : parsedURL . hostname , pgt_port : parsedURL . port , ssl_key : serverKey , ssl_cert : serverCertificate , ssl_ca : serverCA || null } ) ; }
1454	function ( path ) { if ( path . indexOf ( "/" ) < 0 && path . indexOf ( "." ) > - 1 ) { path = path . replace ( / \. / g , "/" ) ; } if ( ! qx . lang . Array . contains ( this . __requiredAssets , path ) ) { this . __requiredAssets . push ( path ) ; } }
2859	function createWrap ( func , bitmask , thisArg , partials , holders , argPos , ary , arity ) { var isBindKey = bitmask & BIND_KEY_FLAG ; if ( ! isBindKey && typeof func != 'function' ) { throw new TypeError ( FUNC_ERROR_TEXT ) ; } var length = partials ? partials . length : 0 ; if ( ! length ) { bitmask &= ~ ( PARTIAL_FLAG | PARTIAL_RIGHT_FLAG ) ; partials = holders = undefined ; } ary = ary === undefined ? ary : nativeMax ( toInteger ( ary ) , 0 ) ; arity = arity === undefined ? arity : toInteger ( arity ) ; length -= holders ? holders . length : 0 ; if ( bitmask & PARTIAL_RIGHT_FLAG ) { var partialsRight = partials , holdersRight = holders ; partials = holders = undefined ; } var data = isBindKey ? undefined : getData ( func ) ; var newData = [ func , bitmask , thisArg , partials , holders , partialsRight , holdersRight , argPos , ary , arity ] ; if ( data ) { mergeData ( newData , data ) ; } func = newData [ 0 ] ; bitmask = newData [ 1 ] ; thisArg = newData [ 2 ] ; partials = newData [ 3 ] ; holders = newData [ 4 ] ; arity = newData [ 9 ] = newData [ 9 ] == null ? ( isBindKey ? 0 : func . length ) : nativeMax ( newData [ 9 ] - length , 0 ) ; if ( ! arity && bitmask & ( CURRY_FLAG | CURRY_RIGHT_FLAG ) ) { bitmask &= ~ ( CURRY_FLAG | CURRY_RIGHT_FLAG ) ; } if ( ! bitmask || bitmask == BIND_FLAG ) { var result = createBind ( func , bitmask , thisArg ) ; } else if ( bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG ) { result = createCurry ( func , bitmask , arity ) ; } else if ( ( bitmask == PARTIAL_FLAG || bitmask == ( BIND_FLAG | PARTIAL_FLAG ) ) && ! holders . length ) { result = createPartial ( func , bitmask , thisArg , partials ) ; } else { result = createHybrid . apply ( undefined , newData ) ; } var setter = data ? baseSetData : setData ; return setWrapToString ( setter ( result , newData ) , func , bitmask ) ; }
258	function ( fetchOptions ) { const namespace = getNamespace ( fetchOptions ) ; debug ( 'getPaginationData:' , namespace ) ; return { fetchInitialized : _usersFetchedByNamespace . hasOwnProperty ( namespace ) , totalUsers : _totalUsersByNamespace [ namespace ] || 0 , fetchingUsers : _fetchingUsersByNamespace [ namespace ] || false , usersCurrentOffset : _offsetByNamespace [ namespace ] , numUsersFetched : _usersFetchedByNamespace [ namespace ] , fetchNameSpace : namespace , } ; }
2435	function Entity ( entityConfiguration ) { return function ( constructor ) { var entityMetadata = constructor ; if ( entityMetadata . entity ) { throw "Cannot set @Table, it is already set to '" + JSON . stringify ( entityMetadata . entity ) + "'" ; } entityMetadata . name = constructor . prototype . name ; if ( ! entityConfiguration ) { entityConfiguration = true ; } entityMetadata . entity = entityConfiguration ; } ; }
3769	function scan ( predicate , initial ) { return function ( iterable ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_7 , _a ; let index = 0 ; let prevState = initial ; try { for ( var iterable_5 = __asyncValues ( iterable ) , iterable_5_1 ; iterable_5_1 = yield __await ( iterable_5 . next ( ) ) , ! iterable_5_1 . done ; ) { const value = iterable_5_1 . value ; prevState = yield __await ( Promise . resolve ( predicate ( prevState , value , index ) ) ) ; yield yield __await ( prevState ) ; index = index + 1 ; } } catch ( e_7_1 ) { e_7 = { error : e_7_1 } ; } finally { try { if ( iterable_5_1 && ! iterable_5_1 . done && ( _a = iterable_5 . return ) ) yield __await ( _a . call ( iterable_5 ) ) ; } finally { if ( e_7 ) throw e_7 . error ; } } return yield __await ( prevState ) ; } ) ; } ; }
3815	function ( ) { var mapping = { } ; _ . each ( sails . config . policies , function ( _policy , controllerId ) { controllerId = util . normalizeControllerId ( controllerId ) ; if ( ! util . isDictionary ( _policy ) ) { mapping [ controllerId ] = policyHookDef . normalizePolicy ( _policy ) ; return ; } mapping [ controllerId ] = { } ; _ . each ( _policy , function ( __policy , actionId ) { actionId = actionId . toLowerCase ( ) ; mapping [ controllerId ] [ actionId ] = policyHookDef . normalizePolicy ( __policy ) ; } ) ; } ) ; return mapping ; }
2256	function timeOutput ( difference , timeValue , pluralTimeName ) { let result = '' ; if ( Math . round ( difference / timeValue ) === 1 ) { result = ` ${ pluralTimeName . substring ( 0 , pluralTimeName . length - 1 ) } ` ; } else { result = ` ${ Math . round ( difference / timeValue ) } ${ pluralTimeName } ` ; } return result ; }
1875	function ( start , len ) { if ( _ . isUndefined ( start ) || start === null ) return null ; if ( start instanceof Range ) return start ; if ( _ . isObject ( start ) && 'start' in start && 'end' in start ) { len = start . end - start . start ; start = start . start ; } return new Range ( start , len ) ; }
3671	function ( state , scope , secondaryScope ) { if ( ! validators . isBlockStart ( state ) ) return state . error ( constants . unexpectedToken ) ; state . next ( ) ; utils . statementsInBlock ( state , scope , secondaryScope ) ; if ( ! validators . isBlockEnd ( state ) ) return state . error ( constants . unexpectedToken ) ; state . next ( ) ; }
936	function updateReferProcessorInfo ( existedProcessors , processorName , referProcessorName ) { let currProcessor = existedProcessors [ processorName ] ; if ( ! currProcessor || currProcessor . processor ) { return ; } let referProcessorInfo = existedProcessors [ referProcessorName ] ; if ( ! referProcessorInfo ) { return ; } let deps = referProcessorInfo . deps ; deps && ! Array . isArray ( deps ) && ( deps = [ deps ] ) ; let oldDeps = currProcessor . deps ; oldDeps && ! Array . isArray ( oldDeps ) && ( oldDeps = [ oldDeps ] ) ; let old = Object . assign ( { } , currProcessor ) ; Object . assign ( currProcessor , referProcessorInfo , old , { refer : referProcessorName , deps : merge ( deps || [ ] , oldDeps || [ ] ) , processor : referProcessorInfo . processor } ) ; }
3588	function doesLaunchConfigurationExist ( autoScaling , launchConfigurationName ) { return autoScaling . describeLaunchConfigurationsPromised ( { LaunchConfigurationNames : [ launchConfigurationName ] } ) . then ( function found ( data ) { return ! _ . isEmpty ( data . LaunchConfigurations ) } ) }
837	function copyReadmeMd ( sourceReadmeMd ) { const libReadmeFile = path . resolve ( __dirname , '../src/ng5-slider/README.md' ) ; const sourceReadme = fs . readFileSync ( sourceReadmeMd , { encoding : 'utf8' } ) ; fs . writeFileSync ( libReadmeFile , sourceReadme , { encoding : 'utf8' } ) ; }
1474	function ( cmd ) { return new Promise ( ( resolve , reject ) => { child_process . exec ( cmd , ( err , stdout , stderr ) => { if ( err ) { reject ( err ) ; } if ( stderr ) { reject ( new Error ( stderr ) ) ; } resolve ( stdout ) ; } ) ; } ) ; }
3685	function _objectCopy ( sourceRef , copyRef , rc ) { let origIndex = rc . xStack . indexOf ( sourceRef ) ; if ( origIndex === - 1 ) { rc . push ( sourceRef , copyRef ) ; for ( let [ key , val ] of _entries ( sourceRef ) ) copyRef [ key ] = _clone ( val , rc ) ; let symbols = Object . getOwnPropertySymbols ( sourceRef ) ; for ( let symbol of symbols ) copyRef [ symbol ] = _clone ( sourceRef [ symbol ] , rc ) ; rc . pop ( ) ; return copyRef ; } else return rc . yStack [ origIndex ] ; }
2814	function buildServicesInternal ( ) { if ( _ . isFunction ( subdivision . buildServices ) ) { subdivision . vent . trigger ( 'before:buildServices' ) ; return subdivision . buildServices ( ) . then ( function ( ) { subdivision . vent . trigger ( 'after:buildServices' ) ; } ) ; } else { return Promise . resolve ( ) ; } }
3141	function ( ) { var me = this ; if ( me . enabled ) { me . target . removeListener ( me . eventName , me . handleTargetEvent , me ) ; me . enabled = false ; } }
595	function ( sentencePartText , auxiliaries , locale ) { this . _sentencePartText = sentencePartText ; this . _auxiliaries = auxiliaries ; this . _locale = locale ; this . _isPassive = false ; }
2614	function only ( o , types ) { types = libs . object . toArray ( arguments ) ; types . shift ( ) ; libs . object . each ( types , function ( type , key ) { this [ key ] = type . replace ( / s$ / , '' ) ; } ) ; if ( typeof o !== 'object' || ! o ) return o ; var isArray = o instanceof Array ? true : false , filtered = isArray ? [ ] : { } , typeArr = types . indexOf ( 'array' ) , typeObj = types . indexOf ( 'object object' ) ; libs . object . each ( o , function ( item , key ) { var typeItem = types . indexOf ( typeof item ) ; if ( typeObj !== - 1 && typeArr === - 1 ) { if ( ( typeof item === 'object' && ! ( item instanceof Array ) ) || ( typeof item !== 'object' && typeItem !== - 1 ) ) { if ( isArray ) filtered . push ( item ) ; else filtered [ key ] = item ; } } else if ( typeObj !== - 1 && typeArr !== - 1 ) { types . push ( 'object' ) ; if ( typeItem !== - 1 ) { if ( isArray ) filtered . push ( item ) ; else filtered [ key ] = item ; } } else if ( typeItem !== - 1 || ( item instanceof Array && typeArr !== - 1 ) ) { if ( isArray ) filtered . push ( item ) ; else filtered [ key ] = item ; } } ) ; return filtered ; }
3037	function consume_string ( proc_stack ) { let delim = proc_stack . tAccept ( ) ; let str = delim ; let escaping = 0 ; let done = false ; while ( ! done ) { let c = proc_stack . tAccept ( ) ; if ( c == "\\" ) \\ else { escaping ^= 1 ; } { if ( c == delim && ! escaping ) { done = true ; } else if ( c == "\r" || \r ) c == "\n" \n } } { if ( ! escaping ) { throw new SyntaxError ( ` ` ) ; } if ( c == "\r" && \r ) proc_stack . tPeek ( ) == "\n" } }
3244	function ( ) { if ( this . hideClearButtonWhenEmpty && Ext . isEmpty ( this . textField . getValue ( ) ) ) { return false ; } var clearButtonEl = this . clearButtonEl ; if ( this . hideClearButtonWhenMouseOut && ! clearButtonEl . hasCls ( this . clearButtonCls + '-mouse-over-button' ) && ! clearButtonEl . hasCls ( this . clearButtonCls + '-mouse-over-input' ) ) { return false ; } return true ; }
133	function newSource ( type , init ) { if ( ! ( type in types ) || ! init && type === currentType || ! currentType . length && type === types . video ) { return ; } switch ( type ) { case types . video : player . source = { type : 'video' , title : 'View From A Blue Moon' , sources : [ { src : 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-576p.mp4' , type : 'video/mp4' , size : 576 } , { src : 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-720p.mp4' , type : 'video/mp4' , size : 720 } , { src : 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-1080p.mp4' , type : 'video/mp4' , size : 1080 } , { src : 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-1440p.mp4' , type : 'video/mp4' , size : 1440 } ] , poster : 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.jpg' , tracks : [ { kind : 'captions' , label : 'English' , srclang : 'en' , src : 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.en.vtt' , default : true } , { kind : 'captions' , label : 'French' , srclang : 'fr' , src : 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.fr.vtt' } ] } ; break ; case types . audio : player . source = { type : 'audio' , title : 'Kishi Bashi &ndash; &ldquo;It All Began With A Burst&rdquo;' , sources : [ { src : 'https://cdn.plyr.io/static/demo/Kishi_Bashi_-_It_All_Began_With_a_Burst.mp3' , type : 'audio/mp3' } , { src : 'https://cdn.plyr.io/static/demo/Kishi_Bashi_-_It_All_Began_With_a_Burst.ogg' , type : 'audio/ogg' } ] } ; break ; case types . youtube : player . source = { type : 'video' , sources : [ { src : 'https://youtube.com/watch?v=bTqVqk7FSmY' , provider : 'youtube' } ] } ; break ; case types . vimeo : player . source = { type : 'video' , sources : [ { src : 'https://vimeo.com/76979871' , provider : 'vimeo' } ] } ; break ; default : break ; } currentType = type ; Array . from ( buttons ) . forEach ( function ( button ) { return toggleClass ( button . parentElement , 'active' , false ) ; } ) ; toggleClass ( document . querySelector ( "[data-source=\"" . \" concat ) , ( type , "\"]" ) , true ) ; \" 'active' }
2013	function flipBufferVertically ( buffer ) { return makeBuffer ( buffer . width , buffer . height , function ( context ) { context . scale ( 1 , - 1 ) ; context . drawImage ( buffer , 0 , - buffer . height ) ; } ) ; }
772	function readUint64 ( buffer , offset ) { var hi = ( buffer [ offset ] << 24 | buffer [ offset + 1 ] << 16 | buffer [ offset + 2 ] << 8 | buffer [ offset + 3 ] << 0 ) >>> 0 ; var lo = ( buffer [ offset + 4 ] << 24 | buffer [ offset + 5 ] << 16 | buffer [ offset + 6 ] << 8 | buffer [ offset + 7 ] << 0 ) >>> 0 ; return hi * 0x100000000 + lo ; }
2017	function SoundManager ( manifest ) { this . muted = false ; this . looping = { } ; this . context = new window . AudioContext ( ) ; this . gainNode = this . context . createGain ( ) ; this . gainNode . connect ( this . context . destination ) ; this . volume = this . gainNode . gain . value ; this . installSafariWorkaround ( ) ; this . assets = new AssetLoader ( manifest , loadSound . bind ( undefined , this . context ) ) ; }
3358	function ( ) { var me = this , picker = me . picker , store = picker . store , value = me . value , node ; if ( value ) { node = store . getNodeById ( value ) ; } if ( ! node ) { node = store . getRootNode ( ) ; } picker . selectPath ( node . getPath ( ) ) ; Ext . defer ( function ( ) { picker . getView ( ) . focus ( ) ; } , 1 ) ; }
2374	function MongodbQueue ( name , metrics , lock , opts ) { if ( ! name ) { throw new Error ( 'name is required to create a mongodb queue' ) ; } if ( ! opts || ! opts . mongodb ) { throw new Error ( 'mongodb is not specified to create mongodb queue' ) ; } this . queueName = name ; this . metrics = metrics ; this . lock = lock ; this . lockName = opts . lockName || ( 'lock:sync:' + this . queueName ) ; this . lockTimeout = opts . lockTimeout || 10000 ; this . mongodb = opts . mongodb ; this . queueOptions = { visibility : opts . visibility || 30 , ttl : opts . queueMessagesTTL || 24 * 60 * 60 } ; this . queue ; }
598	function sortResults ( assessmentResults ) { return assessmentResults . sort ( ( a , b ) => { if ( a . score < b . score ) { return - 1 ; } if ( a . score > b . score ) { return 1 ; } return a . id . localeCompare ( b . id ) ; } ) ; }
2790	function ( initValues , element , notCreate ) { if ( element === undefined ) { if ( notCreate ) { item . values ( initValues , notCreate ) ; } else { item . values ( initValues ) ; } } else { item . elm = element ; var values = templater . get ( item , initValues ) ; item . values ( values ) ; } }
2731	function ( objects , options ) { var self = this objects . forEach ( function ( object ) { self . cache [ object . _id ] = object } ) return objects }
3468	function ( transaction ) { var me = this , enableBuffer = me . enableBuffer ; if ( transaction . form ) { me . sendFormRequest ( transaction ) ; return ; } if ( typeof transaction . timeout !== 'undefined' ) { me . sendRequest ( transaction ) ; return ; } if ( enableBuffer ) { me . callBuffer . push ( transaction ) ; if ( ! me . callTask ) { me . callTask = new Ext . util . DelayedTask ( me . combineAndSend , me ) ; } me . callTask . delay ( Ext . isNumber ( enableBuffer ) ? enableBuffer : 10 ) ; } else { me . combineAndSend ( ) ; } }
1314	function IdleTask ( scheduler , v1 , count ) { this . scheduler = scheduler ; this . v1 = v1 ; this . count = count ; }
2045	function ( ) { var apps = { } ; var baseUrl = configHelpers . getServerUrl ( ) ; Object . keys ( config . apps || { } ) . forEach ( function ( name ) { apps [ name ] = { name : config . apps [ name ] . name , displayName : config . apps [ name ] . displayName , version : config . apps [ name ] . version , url : baseUrl + '/apps/' + config . apps [ name ] . name + '/' } ; } ) ; return apps ; }
232	function recordViewCheckoutInCriteo ( cart ) { if ( ! isAdTrackingAllowed ( ) || ! isCriteoEnabled ) { return ; } if ( cart . is_signup ) { return ; } const params = [ 'viewBasket' , { currency : cart . currency , item : cartToCriteoItems ( cart ) , } , ] ; debug ( 'recordViewCheckoutInCriteo:' , params ) ; recordInCriteo ( ... params ) ; }
3598	function PackageMemberListReadStream ( dirToScan ) { sjl . throwTypeErrorIfEmpty ( 'PackageMemberListReadStream' , 'dirToScan' , dirToScan , String ) ; this . _pathToRead = dirToScan ; Readable . call ( this , { encoding : 'utf8' , objectMode : false , highWaterMark : 100000 , } ) ; }
786	function handleMouseDown ( event ) { mouseDown = true ; lastMouseX = event . clientX ; lastMouseY = event . clientY ; startX = event . clientX ; startY = event . clientY ; var r = viewer . _canvas . getBoundingClientRect ( ) ; var viewX = startX - r . left ; var viewY = viewer . _height - ( startY - r . top ) ; id = viewer . _getID ( viewX , viewY ) ; viewer . _fire ( 'mouseDown' , { id : id } ) ; switch ( event . button ) { case 0 : button = 'left' ; break ; case 1 : button = 'middle' ; break ; case 2 : button = 'right' ; break ; default : button = 'left' ; break ; } viewer . _disableTextSelection ( ) ; }
3658	function getFunctionCallLines ( sourcesContent , filePath , functionName , lineNumber , multiLineSearch , warningHandler ) { if ( sourcesContent !== undefined ) { var source = Future ( sourcesContent ) } else { var source = options . getScriptSourceLines ( filePath ) } return source . catch ( function ( e ) { warningHandler ( e ) return Future ( undefined ) } ) . then ( function ( fileLines ) { if ( fileLines !== undefined ) { var startLine = findStartLine ( fileLines , functionName , lineNumber ) if ( startLine === 'lineOfCodeNotFound' ) { return Future ( "<line of code not found (possibly an error?)> " ) } else if ( startLine !== 'sourceNotAvailable' ) { if ( multiLineSearch ) { return Future ( findFullSourceLine ( fileLines , startLine ) ) } else { return Future ( fileLines [ startLine ] . trim ( ) ) } } } return Future ( "<source not available>" ) } ) }
398	function getHTML ( files , options ) { if ( _ . isString ( files ) ) { files = [ files ] ; } files = _ . flatten ( files . map ( ( file ) => { if ( ! isURL ( file ) && ! isHTML ( file ) ) { return glob . sync ( file ) ; } return file ; } ) ) ; if ( ! files . length ) { return Promise . reject ( new Error ( 'UnCSS: no HTML files found' ) ) ; } options . files = files ; return Promise . all ( files . map ( ( file ) => jsdom . fromSource ( file , options ) ) ) ; }
2403	function ( name , src , onload , requester , errorback ) { var xhr = new XMLHttpRequest ( ) ; xhr . open ( "GET" , src , true ) ; var onerror = function ( e ) { if ( errorback ) { errorback ( { src : src , requester : requester } ) ; } else { throw new Error ( '\n Missing: ' + \n + src + '\n Requester: ' ) ; } } ; \n requester xhr . onerror = onerror ; }
2820	function ( xhr , promise , headers , method ) { if ( ! xhr . _isXDR ) { var name ; if ( ( method !== "POST" ) && ( method !== "PUT" ) ) { headers [ "If-Modified-Since" ] = "Wed, 15 Nov 1995 01:00:00 GMT" ; delete headers [ CONTENT_TYPE ] ; } for ( name in headers ) { xhr . setRequestHeader ( name , headers [ name ] ) ; } ! BODY_METHODS [ method ] || ( headers && ( CONTENT_TYPE in headers ) ) || xhr . setRequestHeader ( CONTENT_TYPE , DEF_CONTENT_TYPE_POST ) ; } }
1346	function getServers ( ) { var interfaces = os . networkInterfaces ( ) var result = [ ] for ( var key in interfaces ) { var addresses = interfaces [ key ] for ( var i = addresses . length ; i -- ; ) { var address = addresses [ i ] if ( address . family === 'IPv4' && ! address . internal ) { var subnet = ip . subnet ( address . address , address . netmask ) var current = ip . toLong ( subnet . firstAddress ) var last = ip . toLong ( subnet . lastAddress ) - 1 while ( current ++ < last ) result . push ( ip . fromLong ( current ) ) } } } return result }
2433	function ManyToOne ( elements ) { return function ( targetObject , propertyKey ) { var entityMetadata = targetObject ; if ( ! entityMetadata . manyToOneMap ) { entityMetadata . manyToOneMap = { } ; } entityMetadata . manyToOneMap [ propertyKey ] = elements ; } ; }
2631	function processPointerPosition ( e ) { var prevValue = this . value , sliderNum = void 0 ; if ( this . style === 'horizontal' ) { sliderNum = Math . floor ( e . clientY / this . rect . height / ( 1 / this . count ) ) ; this . __value [ sliderNum ] = ( e . clientX - this . rect . left ) / this . rect . width ; } else { sliderNum = Math . floor ( e . clientX / this . rect . width / ( 1 / this . count ) ) ; this . __value [ sliderNum ] = 1 - ( e . clientY - this . rect . top ) / this . rect . height ; } for ( var i = 0 ; i < this . count ; i ++ ) { if ( this . __value [ i ] > 1 ) this . __value [ i ] = 1 ; if ( this . __value [ i ] < 0 ) this . __value [ i ] = 0 ; } var shouldDraw = this . output ( ) ; if ( shouldDraw ) this . draw ( ) ; }
1637	function ( obj , src ) { var result = false var key for ( key in obj ) { if ( obj . hasOwnProperty ( key ) && key === src ) result = true } return result }
1923	function matchPair ( editor , direction ) { direction = String ( ( direction || 'out' ) . toLowerCase ( ) ) ; var info = require ( 'editorUtils' ) . outputInfo ( editor ) ; var range = require ( 'range' ) ; var sel = range . create ( editor . getSelectionRange ( ) ) ; var content = info . content ; if ( lastMatch && ! lastMatch . range . equal ( sel ) ) { lastMatch = null ; } if ( lastMatch && sel . length ( ) ) { if ( direction == 'in' ) { if ( lastMatch . type == 'tag' && ! lastMatch . close ) { return false ; } else { if ( lastMatch . range . equal ( lastMatch . outerRange ) ) { lastMatch . range = lastMatch . innerRange ; } else { var narrowed = require ( 'utils' ) . narrowToNonSpace ( content , lastMatch . innerRange ) ; lastMatch = matcher . find ( content , narrowed . start + 1 ) ; if ( lastMatch && lastMatch . range . equal ( sel ) && lastMatch . outerRange . equal ( sel ) ) { lastMatch . range = lastMatch . innerRange ; } } } } else { if ( ! lastMatch . innerRange . equal ( lastMatch . outerRange ) && lastMatch . range . equal ( lastMatch . innerRange ) && sel . equal ( lastMatch . range ) ) { lastMatch . range = lastMatch . outerRange ; } else { lastMatch = matcher . find ( content , sel . start ) ; if ( lastMatch && lastMatch . range . equal ( sel ) && lastMatch . innerRange . equal ( sel ) ) { lastMatch . range = lastMatch . outerRange ; } } } } else { lastMatch = matcher . find ( content , sel . start ) ; } if ( lastMatch && ! lastMatch . range . equal ( sel ) ) { editor . createSelection ( lastMatch . range . start , lastMatch . range . end ) ; return true ; } lastMatch = null ; return false ; }
3808	function ArgumentStatement ( args , options , define ) { options = options || { } ; this . value = args ; this . flags = { } ; this . args = [ ] ; this . options = options ; if ( typeof options . parse === 'undefined' ) options . parse = true ; if ( typeof options . separator === 'undefined' ) options . separator = ',' ; if ( typeof options . parseArgs === 'undefined' ) options . parseArgs = true ; if ( options . parse ) { if ( options . flags ) { var isFlag = true ; while ( isFlag ) { var firstFlagEnd = args . indexOf ( ' ' ) ; if ( firstFlagEnd === - 1 ) firstFlagEnd = args . length ; var firstFlag = args . substring ( 0 , firstFlagEnd ) . trim ( ) . toUpperCase ( ) ; if ( options . flags . indexOf ( firstFlag ) !== - 1 ) { this . flags [ firstFlag ] = true ; args = args . substring ( firstFlagEnd ) . trim ( ) ; } else isFlag = false ; } } this . rawArgs = args ; args = args . trim ( ) ; var argList = [ args ] ; if ( options . separator ) { if ( ! args . length ) argList = [ ] ; else { var positions = util . findPositions ( args , [ { 'start' : '"' , 'end' : '"' } , { 'start' : '(' , 'end' : ')' } ] ) ; argList = util . splitOutside ( args , options . separator , positions ) ; } } for ( var i = 0 ; i < argList . length ; i ++ ) { var arg = argList [ i ] . trim ( ) ; if ( options . parseArgs ) arg = new statements . ExpressionStatement ( arg , define ) ; this . args . push ( arg ) ; } } }
3778	async function count ( source ) { var e_33 , _a ; let i = 0 ; try { for ( var source_4 = __asyncValues ( source ) , source_4_1 ; source_4_1 = await source_4 . next ( ) , ! source_4_1 . done ; ) { const it = source_4_1 . value ; ++ i ; } } catch ( e_33_1 ) { e_33 = { error : e_33_1 } ; } finally { try { if ( source_4_1 && ! source_4_1 . done && ( _a = source_4 . return ) ) await _a . call ( source_4 ) ; } finally { if ( e_33 ) throw e_33 . error ; } } return i ; }
114	function build ( ) { var _this = this ; this . listeners . media ( ) ; if ( ! this . supported . ui ) { this . debug . warn ( "Basic support only for " . concat ( this . provider , " " ) . concat ( this . type ) ) ; ui . toggleNativeControls . call ( this , true ) ; return ; } if ( ! is$1 . element ( this . elements . controls ) ) { controls . inject . call ( this ) ; this . listeners . controls ( ) ; } ui . toggleNativeControls . call ( this ) ; if ( this . isHTML5 ) { captions . setup . call ( this ) ; } this . volume = null ; this . muted = null ; this . loop = null ; this . quality = null ; this . speed = null ; controls . updateVolume . call ( this ) ; controls . timeUpdate . call ( this ) ; ui . checkPlaying . call ( this ) ; toggleClass ( this . elements . container , this . config . classNames . pip . supported , support . pip && this . isHTML5 && this . isVideo ) ; toggleClass ( this . elements . container , this . config . classNames . airplay . supported , support . airplay && this . isHTML5 ) ; toggleClass ( this . elements . container , this . config . classNames . isIos , browser . isIos ) ; toggleClass ( this . elements . container , this . config . classNames . isTouch , this . touch ) ; this . ready = true ; setTimeout ( function ( ) { triggerEvent . call ( _this , _this . media , 'ready' ) ; } , 0 ) ; ui . setTitle . call ( this ) ; if ( this . poster ) { ui . setPoster . call ( this , this . poster , false ) . catch ( function ( ) { } ) ; } if ( this . config . duration ) { controls . durationUpdate . call ( this ) ; } }
2864	function formatTable ( table , links , notes ) { var widths = [ ] ; var rows = table . map ( function ( row ) { var cells = row . map ( function ( cell ) { return formatSpans ( cell , links , notes ) ; } ) ; cells . forEach ( function ( cell , index ) { widths [ index ] = Math . max ( cell . length , widths [ index ] || 5 ) ; widths [ index ] = Math . min ( widths [ index ] , 50 ) ; } ) ; return cells . join ( ' & ' ) ; } ) ; var totalWidth = widths . reduce ( function sum ( val , width ) { return val + width ; } , 0 ) ; totalWidth = Math . max ( totalWidth , 100 ) ; widths = widths . map ( function ( width ) { var relativeWidth = width / totalWidth ; return 'p{' + relativeWidth + '\\textwidth}' ; } ) . \\ join ; ( ' | ' ) var str = '\\begin{longtable}{ | ' + \\ + widths + ' |}\n' + \n + '\\hline\n' + \\ + \n ; }
2496	function ( ) { var json = { } ; $ . each ( this , function ( k , v ) { if ( ! _isFunction ( v ) ) { json [ k ] = v ; } } ) ; return json ; }
2629	function createOptions ( ) { this . element . innerHTML = '' ; var _iteratorNormalCompletion = true ; var _didIteratorError = false ; var _iteratorError = undefined ; try { for ( var _iterator = this . options [ Symbol . iterator ] ( ) , _step ; ! ( _iteratorNormalCompletion = ( _step = _iterator . next ( ) ) . done ) ; _iteratorNormalCompletion = true ) { var option = _step . value ; var optionEl = document . createElement ( 'option' ) ; optionEl . setAttribute ( 'value' , option ) ; optionEl . innerText = option ; this . element . appendChild ( optionEl ) ; } } catch ( err ) { _didIteratorError = true ; _iteratorError = err ; } finally { try { if ( ! _iteratorNormalCompletion && _iterator . return ) { _iterator . return ( ) ; } } finally { if ( _didIteratorError ) { throw _iteratorError ; } } } }
3482	function createNewBlock ( name ) { var node = container , block , clonedNode , caretNode ; block = name || parentBlockName == "TABLE" ? dom . create ( name || newBlockName ) : parentBlock . cloneNode ( false ) ; caretNode = block ; if ( settings . keep_styles !== false ) { do { if ( / ^(SPAN|STRONG|B|EM|I|FONT|STRIKE|U)$ / . test ( node . nodeName ) ) { if ( node . id == '_mce_caret' ) { continue ; } clonedNode = node . cloneNode ( false ) ; dom . setAttrib ( clonedNode , 'id' , '' ) ; if ( block . hasChildNodes ( ) ) { clonedNode . appendChild ( block . firstChild ) ; block . appendChild ( clonedNode ) ; } else { caretNode = clonedNode ; block . appendChild ( clonedNode ) ; } } } while ( node = node . parentNode ) ; } if ( ! tinymce . isIE ) { caretNode . innerHTML = '<br data-mce-bogus="1">' ; } return block ; }
1244	function read_constant_declaration ( ) { const result = this . node ( "constant" ) ; let constName = null ; let value = null ; if ( this . token === this . tok . T_STRING || ( this . php7 && this . is ( "IDENTIFIER" ) ) ) { constName = this . node ( "identifier" ) ; const name = this . text ( ) ; this . next ( ) ; constName = constName ( name ) ; } else { this . expect ( "IDENTIFIER" ) ; } if ( this . expect ( "=" ) ) { value = this . next ( ) . read_expr ( ) ; } return result ( constName , value ) ; }
1922	function matchedRangeForCSSProperty ( rule , selRange , isBackward ) { var property = null ; var possibleRanges , curRange = null , ix ; var list = rule . list ( ) ; var searchFn , nearestItemFn ; if ( isBackward ) { list . reverse ( ) ; searchFn = function ( p ) { return p . range ( true ) . start <= selRange . start ; } ; nearestItemFn = function ( r ) { return r . start < selRange . start ; } ; } else { searchFn = function ( p ) { return p . range ( true ) . end >= selRange . end ; } ; nearestItemFn = function ( r ) { return r . end > selRange . start ; } ; } while ( property = _ . find ( list , searchFn ) ) { possibleRanges = makePossibleRangesCSS ( property ) ; if ( isBackward ) possibleRanges . reverse ( ) ; curRange = _ . find ( possibleRanges , function ( r ) { return r . equal ( selRange ) ; } ) ; if ( ! curRange ) { var matchedRanges = _ . filter ( possibleRanges , function ( r ) { return r . inside ( selRange . end ) ; } ) ; if ( matchedRanges . length > 1 ) { curRange = matchedRanges [ 1 ] ; break ; } if ( curRange = _ . find ( possibleRanges , nearestItemFn ) ) break ; } else { ix = _ . indexOf ( possibleRanges , curRange ) ; if ( ix != possibleRanges . length - 1 ) { curRange = possibleRanges [ ix + 1 ] ; break ; } } curRange = null ; selRange . start = selRange . end = isBackward ? property . range ( true ) . start - 1 : property . range ( true ) . end + 1 ; } return curRange ; }
2963	function copyFileFrom ( file , to_dir ) { var sys = require ( "sys" ) ; var fs = require ( 'fs' ) ; var file_name = filenameFromPath ( file ) ; if ( file_name == ".DS_Store" ) { return ; } sys . pump ( fs . createReadStream ( file ) , fs . createWriteStream ( to_dir ) , function ( ) { console . log ( "Copied file: " + file ) ; console . log ( "To new destination: " + to_dir + "\n" ) ; } ) ; }
281	function configureGlobals ( ) { window . DirectlyRTM = window . DirectlyRTM || function ( ) { ( window . DirectlyRTM . cq = window . DirectlyRTM . cq || [ ] ) . push ( arguments ) ; } ; window . DirectlyRTM ( 'config' , getDefaultOptions ( ) ) ; }
2396	function get_crash_thread ( report ) { var crash = report [ 'crash' ] || { } ; var threads = crash [ 'threads' ] || [ ] ; var thread = threads . find ( function ( thread ) { return ! ! thread [ 'crashed' ] ; } ) ; return thread || crash [ 'crashed_thread' ] ; }
2858	function isError ( value ) { if ( ! isObjectLike ( value ) ) { return false ; } return ( objectToString . call ( value ) == errorTag ) || ( typeof value . message == 'string' && typeof value . name == 'string' ) ; }
668	function research ( paper , researcher ) { const language = getLanguage ( paper . getLocale ( ) ) ; const morphologyData = get ( researcher . getData ( "morphology" ) , [ language ] , false ) ; return collectForms ( paper . getKeyword ( ) , paper . getSynonyms ( ) , language , morphologyData ) ; }
2269	function templateMatches ( template , obj ) { for ( var key in template ) { if ( template . hasOwnProperty ( key ) && obj [ key ] !== template [ key ] ) { return false ; } } return true ; }
1753	function ( ) { var client = redis . client ( ) ; return client . keysAsync ( 'bull:*:id' ) . then ( function ( keys ) { return _ . map ( keys , function ( key ) { return key . slice ( 5 , - 3 ) ; } ) ; } ) ; }
3580	function doesSecurityGroupExist ( ec2 , securityGroupName ) { function inspectError ( err ) { if ( err . code === 'InvalidGroup.NotFound' ) { return false } return Bluebird . reject ( err ) } return ec2 . describeSecurityGroupsPromised ( { GroupNames : [ securityGroupName ] } ) . then ( _ . constant ( true ) ) . error ( inspectError ) }
2714	function getSerialisedData ( ) { var data = this . getFormData ( ) ; return data . length === 0 ? '' : '?' + data . map ( function ( f ) { return encodeURIComponent ( f . name ) + '=' + encodeURIComponent ( f . value ) ; } ) . join ( '&' ) ; }
45	function captureException ( ex , options ) { options = objectMerge$1 ( { trimHeadFrames : 0 } , options ? options : { } ) ; if ( isErrorEvent$1 ( ex ) && ex . error ) { ex = ex . error ; } else if ( isDOMError$1 ( ex ) || isDOMException$1 ( ex ) ) { var name = ex . name || ( isDOMError$1 ( ex ) ? 'DOMError' : 'DOMException' ) ; var message = ex . message ? name + ': ' + ex . message : name ; return this . captureMessage ( message , objectMerge$1 ( options , { stacktrace : true , trimHeadFrames : options . trimHeadFrames + 1 } ) ) ; } else if ( isError$1 ( ex ) ) { ex = ex ; } else if ( isPlainObject$1 ( ex ) ) { options = this . _getCaptureExceptionOptionsFromPlainObject ( options , ex ) ; ex = new Error ( options . message ) ; } else { return this . captureMessage ( ex , objectMerge$1 ( options , { stacktrace : true , trimHeadFrames : options . trimHeadFrames + 1 } ) ) ; } this . _lastCapturedException = ex ; try { var stack = tracekit . computeStackTrace ( ex ) ; this . _handleStackInfo ( stack , options ) ; } catch ( ex1 ) { if ( ex !== ex1 ) { throw ex1 ; } } return this ; }
3130	function ( property , root , allowNull ) { var values = this . extractValues ( property , root ) , length = values . length , hits = { } , unique = [ ] , value , strValue , i ; for ( i = 0 ; i < length ; i ++ ) { value = values [ i ] ; strValue = String ( value ) ; if ( ( allowNull || ! Ext . isEmpty ( value ) ) && ! hits [ strValue ] ) { hits [ strValue ] = true ; unique . push ( value ) ; } } return unique ; }
2036	function ( ) { var configString = JSON . stringify ( config , null , 2 ) ; fs . writeFileSync ( configHelpers . getConfigPath ( ) , configString ) ; }
3365	function iopaStaticSend ( context , path , opts ) { opts = opts || { } ; return new Promise ( function iopaStaticLoad ( resolve , reject ) { var root = opts . root ? normalize ( pathResolve ( opts . root ) ) : '' ; var index = opts . index ; var maxage = opts . maxage || 0 ; var hidden = opts . hidden || false ; var sync = opts . sync || false ; opts = null ; path = decode ( path ) ; if ( path == "" ) path = "/" ; var trailingSlash = '/' == path [ path . length - 1 ] ; if ( - 1 == path ) return reject ( 'failed to decode' ) ; if ( ~ path . indexOf ( '\0' ) ) \0 return reject ( 'null bytes' ) ; if ( index && trailingSlash ) path += index ; if ( ! root && ! isAbsolute ( path ) ) return reject ( 'relative paths require the .root option' ) ; if ( ! root && ~ path . indexOf ( '..' ) ) return reject ( 'malicious path' ) ; path = normalize ( join ( root , path ) ) ; if ( root && 0 != path . indexOf ( root ) ) return reject ( 'malicious path' ) ; if ( ! hidden && leadingDot ( path ) ) return resolve ( ) ; var stats ; try { stats = fs . statSync ( path ) ; } catch ( err ) { return resolve ( null ) ; } if ( stats . isDirectory ( ) ) { return resolve ( null ) ; } var contentType = mime . lookup ( path ) || 'application/octet-stream' ; context . response . writeHead ( 200 , { 'Content-Type' : contentType , 'Last-Modified' : stats . mtime . toUTCString ( ) , 'Content-Length' : stats . size + '' , 'Cache-Control' : 'max-age=' + ( maxage / 1000 | 0 ) } ) ; } ) ; }
3347	function cloneObject ( obj ) { if ( obj === null || typeof obj !== 'object' ) { return obj ; } var temp = obj . constructor ( ) ; for ( var key in obj ) { temp [ key ] = cloneObject ( obj [ key ] ) ; } return temp ; }
1235	function Node ( kind , docs , location ) { this . kind = kind ; if ( docs ) { this . leadingComments = docs ; } if ( location ) { this . loc = location ; } }
3788	function validateObjectRequired ( options , modelObject , entity , parents , errors ) { for ( var key in modelObject ) { if ( ! modelObject [ key ] . type && entity ) { validateObjectRequired ( options , modelObject [ key ] , entity [ key ] , parents + '.' + key , errors ) ; } else if ( ! options . notRequired && modelObject [ key ] . required && ( ! entity || ! entity [ key ] ) ) { if ( ! errors . notFound ) errors . notFound = [ ] ; var fieldName = parents + '.' + key ; errors . notFound . push ( fieldName ) ; errors . text . push ( 'Field ' + fieldName + ' not found' ) ; } } return errors ; }
2504	function enteringString ( cm , pos , ch ) { var line = cm . getLine ( pos . line ) ; var token = cm . getTokenAt ( pos ) ; if ( / \bstring2?\b / . test ( token . type ) ) return false ; var stream = new CodeMirror . StringStream ( line . slice ( 0 , pos . ch ) + ch + line . slice ( pos . ch ) , 4 ) ; stream . pos = stream . start = token . start ; for ( ; ; ) { var type1 = cm . getMode ( ) . token ( stream , token . state ) ; if ( stream . pos >= pos . ch + 1 ) return / \bstring2?\b / . test ( type1 ) ; stream . start = stream . pos ; } }
3738	function splitOutside ( data , separator , exclude ) { var result = [ ] ; var accumulator = "" ; for ( var i = 0 ; i < data . length ; i ++ ) { accumulator += data [ i ] ; var isInExclusion = inPosition ( i , exclude ) ; if ( ! isInExclusion && endsWith ( accumulator , separator ) ) { result . push ( accumulator . substring ( 0 , accumulator . length - separator . length ) ) ; accumulator = '' ; } } result . push ( accumulator ) ; return result ; }
1109	function main ( ) { var app = new App ( ) ; function intentHandler ( url ) { Auth0Cordova . onRedirectUri ( url ) ; } window . handleOpenURL = intentHandler ; app . run ( '#app' ) ; }
2541	function baseIndexOf ( array , value , fromIndex ) { if ( value !== value ) { return baseFindIndex ( array , baseIsNaN , fromIndex ) ; } var index = fromIndex - 1 , length = array . length ; while ( ++ index < length ) { if ( array [ index ] === value ) { return index ; } } return - 1 ; }
663	function ( word , locale ) { var syllableCount = 0 ; var fullWordExclusion = countFullWordDeviations ( word , locale ) ; if ( fullWordExclusion !== 0 ) { return fullWordExclusion ; } var partialExclusions = countPartialWordDeviations ( word , locale ) ; word = partialExclusions . word ; syllableCount += partialExclusions . syllableCount ; syllableCount += countUsingVowels ( word , locale ) ; return syllableCount ; }
1457	function ( array , searchElement ) { var minIndex = 0 ; var maxIndex = array . length - 1 ; var currentIndex ; var currentElement ; while ( minIndex <= maxIndex ) { currentIndex = ( minIndex + maxIndex ) / 2 | 0 ; currentElement = array [ currentIndex ] ; if ( currentElement < searchElement ) { minIndex = currentIndex + 1 ; } else if ( currentElement > searchElement ) { maxIndex = currentIndex - 1 ; } else { return currentIndex ; } } return - 1 ; }
1550	function cull ( octant , region , result ) { const children = octant . children ; let i , l ; b . min = octant . min ; b . max = octant . max ; if ( region . intersectsBox ( b ) ) { if ( children !== null ) { for ( i = 0 , l = children . length ; i < l ; ++ i ) { cull ( children [ i ] , region , result ) ; } } else { result . push ( octant ) ; } } }
144	function isValidCategoriesArray ( categories ) { for ( let i = 0 ; i < categories . length ; i ++ ) { if ( ! isValidProductCategory ( categories [ i ] ) ) { return false ; } } return true ; }
2660	function smsSend ( callback , sender_name , phones , body , date , transliterate ) { if ( sender_name === undefined ) { return callback ( returnError ( "Empty sender name" ) ) ; } if ( ( phones === undefined ) || ( ! phones . length ) ) { return callback ( returnError ( "Empty phones" ) ) ; } if ( body === undefined ) { return callback ( returnError ( "Empty sms text" ) ) ; } var data = { 'sender' : sender_name , 'phones' : JSON . stringify ( phones ) , 'body' : body , 'date' : date , 'transliterate' : transliterate } sendRequest ( 'sms/send' , 'POST' , data , true , callback ) ; }
3011	function fileStatus ( prev , stat , filename , dir , fn ) { var fullname = path . join ( dir , filename ) if ( prev === undefined || prev === null ) { fn && fn ( null , { stats : { mtime : stat . mtime , size : stat . size } , code : 1 } ) ; return ; } var mtimeChange = stat . mtime . valueOf ( ) != prev . stats . mtime . valueOf ( ) ; var sizeChange = stat . size != prev . stats . size ; if ( ! mtimeChange && ! sizeChange ) { return fn && fn ( null , { stats : { mtime : stat . mtime , size : stat . size } , code : 0 } ) ; } fn && fn ( null , { stats : { mtime : stat . mtime , size : stat . size } , code : 2 } ) ; }
1242	function ( ) { if ( this . _input . substring ( this . offset - 1 , this . offset - 1 + this . heredoc_label . length ) === this . heredoc_label ) { const ch = this . _input [ this . offset - 1 + this . heredoc_label . length ] ; if ( ch === "\n" || \n || ch === "\r" ) \r } ch === ";" }
1857	function ( child , position ) { child = child || new AbbreviationNode ; child . parent = this ; if ( _ . isUndefined ( position ) ) { this . children . push ( child ) ; } else { this . children . splice ( position , 0 , child ) ; } return child ; }
982	function parseAppMediaQueryParam ( allAppTypes , params ) { let ctx = { allAppTypes , hasAppMediaType : false , tokens : [ ] } ; let buffer = '' ; for ( let i = 0 , len = params . length ; i < len ; i ++ ) { let c = params [ i ] ; if ( QUERY_PARAMS_SEPARATORS . includes ( c ) ) { buffer = initAppMediaQueryToken ( ctx , buffer , c ) ; if ( buffer === true ) { buffer = '' ; break ; } } else { buffer += c ; } } if ( buffer ) { let result = initAppMediaTargetInfo ( ctx , buffer . trim ( ) ) ; result || ( ctx . tokens . push ( buffer ) ) ; } return ctx ; }
3791	function ( modelName , entity , options , next ) { if ( typeof options === 'function' ) next = options ; if ( ! options ) options = { } ; var modelObject = this . registeredModels [ modelName ] ; if ( typeof modelName === 'object' ) { modelObject = deepLook ( modelName , this . types ) ; } else if ( this . types [ modelName ] ) { if ( options . one ) this . types [ modelName ] . one = options . one ; var result = this . types [ modelName ] . check ( entity ) ? null : { notMatched : modelName } ; return typeof next === 'function' ? next ( result ) : result ; } var errors = validateObjectRequired ( options , modelObject , entity , [ ] , validateObjectEntity ( modelObject , entity ) ) ; if ( ! errors . text [ 0 ] ) errors = { } ; if ( errors && errors . text ) errors . text = errors . text . join ( '. ' ) ; if ( typeof next === 'function' ) { next ( Object . keys ( errors ) . length ? errors : null ) ; } else { return Object . keys ( errors ) . length ? errors : { } ; } }
778	function $body ( byte , i , chunk ) { if ( inf . write ( byte ) ) return $body ; var buf = inf . flush ( ) ; if ( buf . length !== length ) throw new Error ( "Length mismatch, expected " + length + " got " + buf . length ) ; inf . recycle ( ) ; if ( buf . length ) { parts . push ( buf ) ; } emitObject ( ) ; if ( -- num ) return $header ; sha1sum . update ( bodec . slice ( chunk , 0 , i + 1 ) ) ; return $checksum ; }
700	function ( a , success ) { if ( success ) { var deleteContainer = kb . statementsMatching ( undefined , SIOC ( 'container_of' ) , kb . sym ( doc . getElementById ( 'post_' + evt . target . parentNode . id ) . getAttribute ( 'content' ) ) ) sparqlUpdater . batch_delete_statement ( deleteContainer , mbconfirmDeletePost ) } else { that . notify ( 'Oops, there was a problem, please try again' ) evt . target . disabled = false } }
1555	function deferred ( options ) { let args = null ; const promise = new Promise ( ( resolve , reject ) => args = [ resolve , reject , options ] ) ; promise . defer = function defer ( ) { if ( ! args ) throw new Error ( 'defer has already been called' ) ; const callback = callbackBuilder . apply ( undefined , args ) ; args = null ; return callback ; } ; return promise ; }
3340	function ( target , dd , e , dragData ) { delete this . dropOK ; if ( ! target ) { return ; } var f = dragData . field ; if ( ! f ) { return ; } var type = target . record . fields . get ( target . fieldName ) . type , types = Ext . data . Types ; switch ( type ) { case types . FLOAT : case types . INT : if ( ! f . isXType ( 'numberfield' ) ) { return ; } break ; case types . DATE : if ( ! f . isXType ( 'datefield' ) ) { return ; } break ; case types . BOOL : if ( ! f . isXType ( 'checkbox' ) ) { return ; } } this . dropOK = true ; Ext . fly ( target . node ) . addCls ( 'x-drop-target-active' ) ; }
95	function setQualityMenu ( options ) { var _this6 = this ; if ( ! is$1 . element ( this . elements . settings . panels . quality ) ) { return ; } var type = 'quality' ; var list = this . elements . settings . panels . quality . querySelector ( '[role="menu"]' ) ; if ( is$1 . array ( options ) ) { this . options . quality = dedupe ( options ) . filter ( function ( quality ) { return _this6 . config . quality . options . includes ( quality ) ; } ) ; } var toggle = ! is$1 . empty ( this . options . quality ) && this . options . quality . length > 1 ; controls . toggleMenuButton . call ( this , type , toggle ) ; emptyElement ( list ) ; controls . checkMenu . call ( this ) ; if ( ! toggle ) { return ; } var getBadge = function getBadge ( quality ) { var label = i18n . get ( "qualityBadge." . concat ( quality ) , _this6 . config ) ; if ( ! label . length ) { return null ; } return controls . createBadge . call ( _this6 , label ) ; } ; this . options . quality . sort ( function ( a , b ) { var sorting = _this6 . config . quality . options ; return sorting . indexOf ( a ) > sorting . indexOf ( b ) ? 1 : - 1 ; } ) . forEach ( function ( quality ) { controls . createMenuItem . call ( _this6 , { value : quality , list : list , type : type , title : controls . getLabel . call ( _this6 , 'quality' , quality ) , badge : getBadge ( quality ) } ) ; } ) ; controls . updateSetting . call ( this , type , list ) ; }
3862	function append ( parent , child ) { if ( parent . el !== undefined && child . el !== undefined ) { parent . el . appendChild ( child . el ) ; } }
2128	function constructAppModel ( id , name , label , created , lastUpdated , status , features , signOnMode , accessibility , visibility , credentials , settings , links , embedded ) { var model = { } ; if ( id ) model . id = id ; if ( name ) model . name = name ; if ( label ) model . label = label ; if ( created ) model . created = created ; if ( lastUpdated ) model . lastUpdated = lastUpdated ; if ( status ) model . status = status ; if ( features ) model . features = features ; if ( signOnMode ) model . signOnMode = signOnMode ; if ( accessibility ) model . accessibility = accessibility ; if ( visibility ) model . visibility = visibility ; if ( credentials ) model . credentials = credentials ; if ( settings ) model . settings = settings ; if ( links ) model . links = links ; if ( embedded ) model . embedded = embedded ; return model ; }
3647	function ( ) { var versions = [ "Msxml2.XMLHTTP" , "Msxml3.XMLHTTP" , "Microsoft.XMLHTTP" , "MSXML2.XmlHttp.6.0" , "MSXML2.XmlHttp.5.0" , "MSXML2.XmlHttp.4.0" , "MSXML2.XmlHttp.3.0" , "MSXML2.XmlHttp.2.0" ] if ( XMLHttpRequest !== undefined ) { createXMLHTTPObject = function ( ) { return new XMLHttpRequest ( ) } return createXMLHTTPObject ( ) } else { for ( var i = 0 , n = versions . length ; i < n ; i ++ ) { try { var version = versions [ i ] var fn = function ( ) { return new ActiveXObject ( version ) } createXMLHTTPObject = fn return createXMLHTTPObject ( ) } catch ( e ) { } } } throw new Error ( 'Cant get XmlHttpRequest object' ) }
1241	function ( ) { const revert = this . offset ; if ( this . _input [ this . offset - 1 ] === "<" && this . _input [ this . offset ] === "<" && this . _input [ this . offset + 1 ] === "<" ) { this . offset += 3 ; if ( this . is_TABSPACE ( ) ) { while ( this . offset < this . size ) { this . offset ++ ; if ( ! this . is_TABSPACE ( ) ) { break ; } } } let tChar = this . _input [ this . offset - 1 ] ; if ( tChar === "'" || tChar === '"' ) { this . offset ++ ; } else { tChar = null ; } if ( this . is_LABEL_START ( ) ) { let yyoffset = this . offset - 1 ; while ( this . offset < this . size ) { this . offset ++ ; if ( ! this . is_LABEL ( ) ) { break ; } } const yylabel = this . _input . substring ( yyoffset , this . offset - 1 ) ; if ( ! tChar || tChar === this . _input [ this . offset - 1 ] ) { if ( tChar ) this . offset ++ ; if ( this . _input [ this . offset - 1 ] === "\r" || \r ) this . _input [ this . offset - 1 ] === "\n" } } } \n { this . heredoc_label = yylabel ; yyoffset = this . offset - revert ; this . offset = revert ; this . consume ( yyoffset ) ; if ( tChar === "'" ) { this . begin ( "ST_NOWDOC" ) ; } else { this . begin ( "ST_HEREDOC" ) ; } return this . tok . T_START_HEREDOC ; } }
238	function setTabIndexOnEditorIframe ( tabindex ) { return function ( ) { const editorIframe = document . getElementById ( ` ${ this . id } ` ) ; if ( ! editorIframe ) { return ; } editorIframe . setAttribute ( 'tabIndex' , tabindex ) ; } ; }
839	function highlight ( code , lang ) { return prism . highlight ( code . trim ( ) , prism . languages [ lang ] ) ; }
689	function ( ) { var query = new $rdf . Query ( 'IRC log entries' ) var v = [ ] var vv = [ 'chan' , 'msg' , 'date' , 'list' , 'pred' , 'creator' , 'content' ] vv . map ( function ( x ) { query . vars . push ( v [ x ] = $rdf . variable ( x ) ) } ) query . pat . add ( v [ 'chan' ] , ns . foaf ( 'chatEventList' ) , v [ 'list' ] ) query . pat . add ( v [ 'list' ] , v [ 'pred' ] , v [ 'msg' ] ) query . pat . add ( v [ 'msg' ] , ns . dc ( 'date' ) , v [ 'date' ] ) query . pat . add ( v [ 'msg' ] , ns . dc ( 'creator' ) , v [ 'creator' ] ) query . pat . add ( v [ 'msg' ] , ns . dc ( 'description' ) , v [ 'content' ] ) return query }
3427	function ( array ) { var clone = [ ] , i = 0 , ln = array . length , item ; for ( ; i < ln ; i ++ ) { item = array [ i ] ; if ( ExtArray . indexOf ( clone , item ) === - 1 ) { clone . push ( item ) ; } } return clone ; }
2778	function parseItem ( node , currentItem ) { if ( currentItem && currentItem . hasMemoryOf ( node ) ) { return Item . ERROR ; } var $node = $ ( node ) ; var type = splitUnique ( $node . attr ( 'itemtype' ) ) ; type = type && type . filter ( isAbsoluteUrl ) ; var item = new Item ( { type : type , id : $node . attr ( 'itemid' ) , node : node , parent : currentItem } ) ; walkNodes ( $node . children ( ) , item ) ; var refs = splitUnique ( $node . attr ( 'itemref' ) ) ; if ( refs ) { var refsSelector = refs . map ( function makeIdSelector ( id ) { return '#' + id ; } ) . join ( ',' ) ; walkNodes ( $ ( refsSelector ) , item ) ; } return item ; }
2876	function getConsoleReporterOpts ( opts ) { opts = opts || { } ; opts . print = function ( ) { grunt . log . write . apply ( this , arguments ) ; } ; opts . verbosity = opts . verbosity === undefined ? opts . verbose : opts . verbosity ; return opts ; }
2459	function ( conf , bitwise , parent ) { EventEmitter . call ( this ) ; conf = conf || { } ; constants ( this ) ; this . keys = keys ; this . bitwise = ( bitwise === true ) ; this . configure ( ) ; var cstreams = parent && conf . streams ; var streams = conf . streams , stream = conf . stream ; streams = streams || this . getDefaultStream ( conf ) ; delete conf . streams ; delete conf . stream ; var target = parent ? merge ( parent . conf , { } ) : merge ( defaults , { } ) ; this . conf = merge ( conf , target ) ; if ( typeof this . conf . name !== 'string' || ! this . conf . name . length ) { throw new Error ( 'Logger name \'' + \' + this . conf . name ) ; } '\' is invalid' \' this . name = this . conf . name ; conf . streams = streams ; if ( stream ) conf . stream = stream ; this . pid = this . conf . pid || process . pid ; this . hostname = this . conf . hostname || os . hostname ( ) ; this . fields = { } ; this . streams = [ ] ; }
3092	function getInfoSync ( dir ) { var fullname = path . join ( dir , '.epm/CONFIG' ) ; if ( ! fs . existsSync ( fullname ) ) { return { name : 'unknown' , engine : 'unknown' , path : dir } ; } var info = JSON . parse ( fs . readFileSync ( fullname , 'utf-8' ) ) ; return { name : info . name || 'unknown' , engine : info . engine || 'unknown' , path : dir } ; }
3835	function onChildAdd ( newData ) { if ( ! started ) return ; if ( data [ newData . key ( ) ] ) return ; if ( ! ended && ! data [ newData . key ( ) ] && marker && newData . compareTo ( marker ) > 0 ) return ; return add ( newData ) . then ( emitValue ) ; }
2505	function resolve ( paths ) { paths = Array . isArray ( paths ) ? paths : [ paths ] ; var fullPath = path . resolve . apply ( this , paths ) . replace ( / \\ / g , '/' ) ; return { fullPath : fullPath , dirName : path . dirname ( fullPath ) , fileName : path . basename ( fullPath ) , extName : path . extname ( fullPath ) . replace ( '.' , '' ) } ; }
2603	function occurrencesOf ( obj , what ) { if ( arguments . length < 2 ) return 0 ; if ( typeof obj === 'boolean' ) { return 0 ; } if ( typeof obj === 'number' ) { return occurrencesOf ( obj . toString ( ) , what ) ; } else if ( typeof obj === 'function' ) { return occurrencesOf ( fixFirefoxFunctionString ( obj . toString ( ) ) , what ) ; } var count = 0 ; if ( typeof obj === 'string' ) { if ( typeof what === 'string' || typeof what === 'number' ) { var regexp = new RegExp ( what . toString ( ) , 'g' ) , m ; while ( m = regexp . exec ( obj ) ) count ++ ; } } else if ( typeof obj !== 'string' ) { libs . object . every ( obj , function ( item ) { if ( item === what ) count ++ ; } ) ; } return count ; }
2392	function KoaNunjucks ( oCtx , sPath , oOpts ) { this . enviornment = nunjucks . configure ( sPath , oOpts ) ; this . _ctx = oCtx ; }
1648	function ( ) { var self = this ; var start_x = time_x ( self . capture_idx . start ) ; var end_x = time_x ( self . capture_idx . end ) ; var end_y = self . h - margin [ 2 ] ; var end_attrs = { stroke : "#666" , "stroke-width" : "1" } ; var label_attrs = { fill : "white" , "font-size" : "16" , "opacity" : ".5" } ; paper . path ( "M" + start_x + "," + margin [ 0 ] + " " + "L" + start_x + "," + end_y ) . attr ( end_attrs ) ; var m ; if ( self . pix_per_sec <= 1000 ) { m = 1000 ; } else if ( self . pix_per_sec <= 2000 ) { m = 500 ; } else if ( self . pix_per_sec <= 3500 ) { m = 250 ; } else if ( self . pix_per_sec <= 5000 ) { m = 100 ; } else { m = 50 ; } for ( var i = self . capture_idx . start ; i < self . capture_idx . end ; i += m ) { var i_x = time_x ( i ) ; paper . path ( "M" + i_x + "," + margin [ 0 ] + " " + "L" + i_x + "," + end_y ) . attr ( { stroke : "#444" , "stroke-width" : "1" } ) ; paper . text ( i_x , end_y + 10 , ( ( i - self . capture_idx . start ) / 1000 ) + "s" ) . attr ( label_attrs ) ; paper . text ( i_x , margin [ 0 ] - 20 , ( ( i - self . capture_idx . start ) / 1000 ) + "s" ) . attr ( label_attrs ) ; } paper . path ( "M" + end_x + "," + margin [ 0 ] + " " + "L" + end_x + "," + end_y ) . attr ( end_attrs ) ; }
985	function initProcessor ( options = { } , defaultBabelProcessorName ) { let { js } = options ; if ( js !== false ) { initJsProcessor ( js , defaultBabelProcessorName ) ; } }
3410	function grabContent ( e ) { var n , or , rng , oldRng , sel = ed . selection , dom = ed . dom , body = ed . getBody ( ) , posY , textContent ; if ( e . clipboardData || dom . doc . dataTransfer ) { textContent = ( e . clipboardData || dom . doc . dataTransfer ) . getData ( 'Text' ) ; if ( ed . pasteAsPlainText ) { e . preventDefault ( ) ; process ( { content : dom . encode ( textContent ) . replace ( / \r?\n / g , '<br />' ) } ) ; return ; } } if ( dom . get ( '_mcePaste' ) ) return ; n = dom . add ( body , 'div' , { id : '_mcePaste' , 'class' : 'mcePaste' , 'data-mce-bogus' : '1' } , '\uFEFF\uFEFF' ) ; \uFEFF \uFEFF if ( body != ed . getDoc ( ) . body ) posY = dom . getPos ( ed . selection . getStart ( ) , body ) . y ; else posY = body . scrollTop + dom . getViewPort ( ed . getWin ( ) ) . y ; }
3125	function ( index , keys , objects ) { var me = this , itemKey , removeIndex , i , len = keys . length , fireAdd = me . hasListeners . add , syncIndices ; if ( objects != null ) { me . useLinearSearch = true } else { objects = keys ; keys = new Array ( len ) ; for ( i = 0 ; i < len ; i ++ ) { keys [ i ] = this . getKey ( objects [ i ] ) ; } } me . suspendEvents ( ) ; for ( i = 0 ; i < len ; i ++ ) { removeIndex = me . indexOfKey ( keys [ i ] ) ; if ( removeIndex !== - 1 ) { if ( removeIndex < index ) { index -- ; } me . removeAt ( removeIndex ) ; } } me . resumeEvents ( ) ; syncIndices = index === me . length && me . indexGeneration === me . generation ; Ext . Array . insert ( me . items , index , objects ) ; Ext . Array . insert ( me . keys , index , keys ) ; me . length += len ; me . generation ++ ; if ( syncIndices ) { me . indexGeneration = me . generation ; } for ( i = 0 ; i < len ; i ++ , index ++ ) { itemKey = keys [ i ] ; if ( itemKey != null ) { me . map [ itemKey ] = objects [ i ] ; if ( syncIndices ) { me . indexMap [ itemKey ] = index ; } } if ( fireAdd ) { me . fireEvent ( 'add' , index , objects [ i ] , itemKey ) ; } } return objects ; }
2387	function ( isSorted , iterator ) { var list = new ArrayList ; return list . add ( _ . uniq ( this , isSorted , iterator ) ) ; }
1182	function createCanvas ( ) { canvas = document . createElement ( 'canvas' ) ; canvas . width = imageWidth ; canvas . height = imageHeight ; context = canvas . getContext ( '2d' ) ; context . fillStyle = options . backgroundColor || 'white' ; context . fillRect ( 0 , 0 , imageWidth , imageHeight ) ; }
165	function handleGoToAllPosts ( calypsoPort ) { $ ( '#editor' ) . on ( 'click' , '.edit-post-fullscreen-mode-close__toolbar a' , e => { e . preventDefault ( ) ; calypsoPort . postMessage ( { action : 'goToAllPosts' , payload : { unsavedChanges : select ( 'core/editor' ) . isEditedPostDirty ( ) , } , } ) ; } ) ; }
3765	function _vendorsList ( vendors , ignore = false ) { let vendorsList = '' let sign = ( ignore ) ? '-' : '+' for ( let vendor of vendors ) { vendorsList += ` ${ sign } ${ vendor } ` } return vendorsList }
164	function handleInsertClassicBlockMedia ( calypsoPort ) { calypsoPort . addEventListener ( 'message' , onInsertClassicBlockMedia , false ) ; calypsoPort . start ( ) ; function onInsertClassicBlockMedia ( message ) { const action = get ( message , 'data.action' ) ; if ( action !== 'insertClassicBlockMedia' ) { return ; } const editorId = get ( message , 'data.payload.editorId' ) ; const media = get ( message , 'data.payload.media' ) ; tinymce . editors [ editorId ] . execCommand ( 'mceInsertContent' , false , media ) ; } }
567	function VertexNode ( point ) { this . point = point ; this . prev = null ; this . next = null ; this . face = null ; }
1341	function uninstall ( name ) { if ( typeof name !== 'string' || name === '' ) { throw new TypeError ( 'The algorithm name must be an non-empty string.' ) ; } const hashFunc = funcs [ name ] ; if ( ! hashFunc ) { throw new TypeError ( ` ${ name } ` ) ; } delete funcs [ name ] ; queue . splice ( queue . indexOf ( name ) , 1 ) ; }
3295	function ( result , request ) { var success = true ; if ( request . timeout ) { clearTimeout ( request . timeout ) ; } delete this [ request . callbackName ] ; delete this . requests [ request . id ] ; this . cleanupErrorHandling ( request ) ; Ext . fly ( request . script ) . remove ( ) ; if ( request . errorType ) { success = false ; Ext . callback ( request . failure , request . scope , [ request . errorType ] ) ; } else { Ext . callback ( request . success , request . scope , [ result ] ) ; } Ext . callback ( request . callback , request . scope , [ success , result , request . errorType ] ) ; Ext . EventManager . idleEvent . fire ( ) ; }
180	function syncStatus ( state = { } , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_RESYNC_REQUEST_SUCCESS : return Object . assign ( { } , action . syncStatus ) ; } return state ; }
1879	function ( syntax , name , memo ) { if ( ! syntax || ! name ) return null ; memo = memo || [ ] ; var names = [ name ] ; if ( ~ name . indexOf ( '-' ) ) names . push ( name . replace ( / \- / g , ':' ) ) ; var data = this . getSection ( syntax ) , matchedItem = null ; _ . find ( [ 'snippets' , 'abbreviations' ] , function ( sectionName ) { var data = this . getSection ( syntax , sectionName ) ; if ( data ) { return _ . find ( names , function ( n ) { if ( data [ n ] ) return matchedItem = parseItem ( n , data [ n ] , sectionName ) ; } ) ; } } , this ) ; memo . push ( syntax ) ; if ( ! matchedItem && data [ 'extends' ] && ! _ . include ( memo , data [ 'extends' ] ) ) { return this . findSnippet ( data [ 'extends' ] , name , memo ) ; } return matchedItem ; }
2195	function ( input , prefix ) { _ . forOwn ( input , function ( value , key ) { if ( ( / [^\w-] / ) . test ( key ) ) { console . warn ( key + ': the key format is not valid' ) ; } if ( _ . isPlainObject ( value ) ) { return recursion ( value , prefix ? [ prefix , key ] . join ( '_' ) : key ) ; } result [ ( prefix ? [ null , prefix , key ] : [ null , key ] ) . join ( '_' ) ] = _ . isFinite ( value ) ? value : _ . truncate ( _ . toString ( value ) , { length : 32765 } ) ; } ) ; }
316	function arrayBufferToDataURL ( arrayBuffer , mimeType ) { var chunks = [ ] ; var chunkSize = 8192 ; var uint8 = new Uint8Array ( arrayBuffer ) ; while ( uint8 . length > 0 ) { chunks . push ( fromCharCode . apply ( null , toArray ( uint8 . subarray ( 0 , chunkSize ) ) ) ) ; uint8 = uint8 . subarray ( chunkSize ) ; } return "data:" . concat ( mimeType , ";base64," ) . concat ( btoa ( chunks . join ( '' ) ) ) ; }
1708	function _setPullToRefreshState ( pullToRefresh , state ) { if ( pullToRefresh . state !== state ) { pullToRefresh . state = state ; if ( pullToRefresh . node && pullToRefresh . node . setPullToRefreshStatus ) { pullToRefresh . node . setPullToRefreshStatus ( state ) ; } } }
454	function getData ( props ) { return props . data ? formatData ( props . data , props ) : formatData ( generateData ( props ) , props ) ; }
1122	function initEncryption ( provider , bigIp ) { const PRIVATE_KEY_OUT_FILE = '/tmp/tempPrivateKey.pem' ; let passphrase ; if ( provider . hasFeature ( CloudProvider . FEATURE_ENCRYPTION ) ) { logger . debug ( 'Generating public/private keys for autoscaling.' ) ; return cryptoUtil . generateRandomBytes ( PASSPHRASE_LENGTH , 'base64' ) . then ( ( response ) => { passphrase = response ; return cryptoUtil . generateKeyPair ( PRIVATE_KEY_OUT_FILE , { passphrase , keyLength : '3072' } ) ; } ) . then ( ( publicKey ) => { return provider . putPublicKey ( this . instanceId , publicKey ) ; } ) . then ( ( ) => { return bigIp . installPrivateKey ( PRIVATE_KEY_OUT_FILE , AUTOSCALE_PRIVATE_KEY_FOLDER , AUTOSCALE_PRIVATE_KEY , { passphrase } ) ; } ) . then ( ( ) => { return bigIp . save ( ) ; } ) . catch ( ( err ) => { logger . info ( 'initEncryption error' , err && err . message ? err . message : err ) ; return q . reject ( err ) ; } ) ; } return q ( ) ; }
2634	function promiseShouldFail ( promise , done , handler ) { promise . then ( result => done ( new Error ( 'Promise expected to fail' ) ) ) . catch ( error => { handler ( error ) done ( ) } ) . catch ( error => done ( error ) ) }
1027	function ( ) { this . rs . setBackend ( 'dropbox' ) ; if ( this . token ) { hookIt ( this . rs ) ; } else { this . rs . authorize ( { authURL : AUTH_URL , scope : '' , clientId : this . clientId } ) ; } }
396	function parsePaths ( source , stylesheets , options ) { return stylesheets . map ( ( sheet ) => { let sourceProtocol ; const isLocalFile = sheet . substr ( 0 , 5 ) === 'file:' ; if ( sheet . substr ( 0 , 4 ) === 'http' ) { return sheet ; } if ( isURL ( source ) && ! isLocalFile ) { sourceProtocol = url . parse ( source ) . protocol ; if ( sheet . substr ( 0 , 2 ) === '//' ) { return sourceProtocol ? sourceProtocol + sheet : 'http:' + sheet ; } return url . resolve ( source , sheet ) ; } sheet = sheet . split ( '?' ) [ 0 ] . split ( '#' ) [ 0 ] ; if ( isLocalFile ) { sheet = url . parse ( sheet ) . path . replace ( '%20' , ' ' ) ; sheet = isWindows ( ) ? sheet . substring ( 1 ) : sheet ; if ( options . htmlroot ) { return path . join ( options . htmlroot , sheet ) ; } sheet = path . relative ( path . join ( path . dirname ( source ) ) , sheet ) ; } if ( sheet [ 0 ] === '/' && options . htmlroot ) { return path . join ( options . htmlroot , sheet ) ; } else if ( isHTML ( source ) ) { return path . join ( options . csspath , sheet ) ; } return path . join ( path . dirname ( source ) , options . csspath , sheet ) ; } ) ; }
1595	function Route ( spec ) { var route ; if ( this ) { route = this ; } else { route = Object . create ( Route . prototype ) ; } if ( typeof spec === 'undefined' ) { throw new Error ( 'A route spec is required' ) ; } route . spec = spec ; route . ast = Parser . parse ( spec ) ; return route ; }
3697	function _smash ( a , b ) { this . forEach ( b , ( val , key ) => { if ( this . isSmashable ( a [ key ] , b [ key ] ) ) this . _smash ( a [ key ] , b [ key ] ) ; else a [ key ] = this . deepCopy ( b [ key ] ) ; } ) ; return a ; }
1942	function ( gradient ) { if ( _ . isString ( gradient ) ) gradient = this . parse ( gradient ) ; if ( ! gradient ) return null ; var colorStops = _ . map ( gradient . colorStops , _ . clone ) ; _ . each ( colorStops , function ( cs ) { if ( ! ( 'position' in cs ) ) return ; if ( ~ cs . position . indexOf ( '.' ) || cs . unit == '%' ) { cs . position = parseFloat ( cs . position ) / ( cs . unit == '%' ? 100 : 1 ) ; } else { throw "Can't convert color stop '" + ( cs . position + ( cs . unit || '' ) ) + "'" ; } } ) ; fillImpliedPositions ( colorStops ) ; colorStops = _ . map ( colorStops , function ( cs , i ) { if ( ! cs . position && ! i ) return 'from(' + cs . color + ')' ; if ( cs . position == 1 && i == colorStops . length - 1 ) return 'to(' + cs . color + ')' ; return 'color-stop(' + ( cs . position . toFixed ( 2 ) . replace ( / \.?0+$ / , '' ) ) + ', ' + cs . color + ')' ; } ) ; return '-webkit-gradient(linear, ' + oldWebkitDirection ( gradient . direction ) + ', ' + colorStops . join ( ', ' ) + ')' ; }
3178	function ( ) { var me = this , menuTrigger = me . menuTrigger , names = me . layout . names ; if ( menuTrigger . rendering ) { menuTrigger . finishRender ( ) ; me . triggerTotalWidth = menuTrigger [ names . getWidth ] ( ) + menuTrigger . el . getMargin ( names . parallelMargins ) ; } }
3713	function ( compressedData ) { var inflatedData = zlib . inflateSync ( new Buffer ( compressedData , 'base64' ) ) ; var outputString = "[" + String . fromCharCode . apply ( null , inflatedData ) + "]" ; var outputArray = JSON . parse ( outputString ) ; return ArrayConverter . diffsToValues ( outputArray ) ; }
3449	function ( className , testFn , scope ) { var me = this , dom = me . dom , hasTest = Ext . isFunction ( testFn ) ; me . hover ( function ( ) { if ( hasTest && testFn . call ( scope || me , me ) === false ) { return ; } Ext . fly ( dom , INTERNAL ) . addCls ( className ) ; } , function ( ) { Ext . fly ( dom , INTERNAL ) . removeCls ( className ) ; } ) ; return me ; }
3692	function forEach ( item , method , context ) { let type = getType ( item ) ; switch ( type ) { case types . date : case types . function : case types . object : case types . regexp : if ( ! item [ Symbol . iterator ] ) { for ( let [ key , value ] of _entries ( item ) ) { if ( item . hasOwnProperty ( key ) ) method . call ( context , value , key , item ) ; } } else { for ( let value of item ) { method . call ( context , value , undefined , item ) ; } } break ; case types . arguments : case types . array : for ( let i = 0 ; i < item . length ; i ++ ) method . call ( context , item [ i ] , i , item ) ; break ; case types . map : for ( let [ key , value ] of item ) method . call ( context , value , key , item ) ; break ; case types . set : for ( let value of item ) method . call ( context , value , value , item ) ; break ; default : if ( item [ Symbol . iterator ] ) { for ( let value of item [ Symbol . iterator ] ( ) ) method . call ( context , value , undefined , item ) ; } else if ( ! typeset . has ( type ) && type && type . constructor ) { for ( let [ key , value ] of _entries ( item ) ) { if ( item . hasOwnProperty ( key ) ) method . call ( context , value , key , item ) ; } } break ; } return item ; }
1981	function isValid ( message ) { if ( ! Constants . equals ( message . slice ( 4 , 16 ) ) ) return false ; var checksum = message . readUInt16BE ( message . length - 2 ) ; return checksum === crc ( message . slice ( 16 , - 2 ) ) ; }
1757	function ( qName , data , opts ) { var q = queue . get ( qName ) ; return q . add ( data , opts ) . then ( function ( job ) { if ( ! job ) { return job ; } return job . getState ( ) . then ( function ( state ) { job . state = state ; return job ; } ) ; } ) ; }
3869	function setStyle ( node , prop , value ) { if ( node && node . el ) { if ( isObject ( prop ) ) { Object . keys ( prop ) . forEach ( function ( key ) { node . el . style [ key ] = prop [ key ] ; } ) ; } else { node . el . style [ prop ] = value ; } } }
3630	function checkBug ( ) { var a = document . createElement ( 'div' ) ; if ( method . call ( a , 'div' ) ) { return false ; } var b = document . createElement ( 'div' ) ; a . appendChild ( b ) ; return method . call ( b , 'div' ) ; }
3314	function ( ) { var conversion = this . parse ( '' ) ; if ( lastSetting ) { var current = lastSetting . get ( ) ; if ( conversion . predictions . length === 0 ) { conversion . predictions . push ( current ) ; } else { var removed = false ; while ( true ) { var index = conversion . predictions . indexOf ( current ) ; if ( index === - 1 ) { break ; } conversion . predictions . splice ( index , 1 ) ; removed = true ; } if ( removed ) { conversion . predictions . push ( current ) ; } } } return conversion ; }
2408	function notifyWhenPresentOrFutureArrayValuesMutate ( ko , observable ) { var watchingArraySubscription = null ; ko . computed ( function ( ) { if ( watchingArraySubscription ) { watchingArraySubscription . dispose ( ) ; watchingArraySubscription = null ; } var newarray = observable ( ) ; if ( newarray instanceof Array ) { watchingArraySubscription = startWatchingarray ( ko , observable , newarray ) ; } } ) ; }
1726	function _clickItem ( scrollWheel , event ) { if ( scrollWheel && event && event . target ) { scrollWheel . scrollController . goToRenderNode ( event . target ) ; } }
2073	function getJson ( filename , cb ) { fs . readFile ( filename , function ( err , data ) { if ( err ) return cb ( err , null ) try { var json = JSON . parse ( data ) cb ( null , json ) } catch ( e ) { cb ( e , null ) } } ) }
2080	function Theme ( name , projectPath , options ) { if ( ! name || ( typeof name !== 'string' ) ) { return new Error ( 'Param name is required for instantiate a new Theme object' ) ; } if ( ! options ) options = { } ; this . we = we ; this . hooks = this . we . hooks ; this . events = this . we . events ; const self = this ; this . config = { } ; this . projectPath = projectPath ; this . config . themeFolder = options . themeFolder || path . resolve ( projectPath , 'node_modules' , name ) ; this . config . shortThemeFolder = options . themeFolder || 'node_modules' + '/' + name ; delete require . cache [ require . resolve ( this . config . themeFolder ) ] ; const npmModule = require ( this . config . themeFolder ) ; this . name = name ; const packageJSONPath = this . config . themeFolder + '/package.json' ; delete require . cache [ require . resolve ( packageJSONPath ) ] ; this [ 'package.json' ] = require ( packageJSONPath ) ; this . version = this [ 'package.json' ] . version ; this . templates = { } ; this . layouts = { } ; this . widgets = { } ; this . tplsFolder = path . resolve ( self . config . themeFolder , 'templates/server' ) ; _ . merge ( this , npmModule ) ; }
1175	function ( command ) { if ( command . options && command . options . validation === false ) return true ; var handoverErr ; _ . each ( this . _map [ command . action ] , function ( route ) { var i = 0 ; function callbacks ( err ) { var fn = route [ i ++ ] ; try { if ( fn ) { fn ( err , command , callbacks ) ; } else { handoverErr = err ; return ; } } catch ( err ) { callbacks ( err ) ; } } ; callbacks ( handoverErr ) ; } ) ; if ( handoverErr ) { if ( this . get ( 'cancelInvalid' ) ) this . _commandManager . cancel ( ) ; this . trigger ( 'invalid' , handoverErr ) ; return false ; } return true ; }
1562	function unpatchPromise ( ) { for ( let method of methods ) { if ( Promise . prototype [ method . name ] === method ) { delete Promise . prototype [ method . name ] ; } } }
104	function update ( ) { var _this = this ; var tracks = captions . getTracks . call ( this , true ) ; var _this$captions = this . captions , active = _this$captions . active , language = _this$captions . language , meta = _this$captions . meta , currentTrackNode = _this$captions . currentTrackNode ; var languageExists = Boolean ( tracks . find ( function ( track ) { return track . language === language ; } ) ) ; if ( this . isHTML5 && this . isVideo ) { tracks . filter ( function ( track ) { return ! meta . get ( track ) ; } ) . forEach ( function ( track ) { _this . debug . log ( 'Track added' , track ) ; meta . set ( track , { default : track . mode === 'showing' } ) ; track . mode = 'hidden' ; on . call ( _this , track , 'cuechange' , function ( ) { return captions . updateCues . call ( _this ) ; } ) ; } ) ; } if ( languageExists && this . language !== language || ! tracks . includes ( currentTrackNode ) ) { captions . setLanguage . call ( this , language ) ; captions . toggle . call ( this , active && languageExists ) ; } toggleClass ( this . elements . container , this . config . classNames . captions . enabled , ! is$1 . empty ( tracks ) ) ; if ( ( this . config . controls || [ ] ) . includes ( 'settings' ) && this . config . settings . includes ( 'captions' ) ) { controls . setCaptionsMenu . call ( this ) ; } }
1101	function ( str , gga ) { if ( gga . length !== 16 ) { throw new Error ( 'Invalid GGA length: ' + str ) ; } return { 'time' : parseTime ( gga [ 1 ] ) , 'lat' : parseCoord ( gga [ 2 ] , gga [ 3 ] ) , 'lon' : parseCoord ( gga [ 4 ] , gga [ 5 ] ) , 'alt' : parseDist ( gga [ 9 ] , gga [ 10 ] ) , 'quality' : parseGGAFix ( gga [ 6 ] ) , 'satellites' : parseNumber ( gga [ 7 ] ) , 'hdop' : parseNumber ( gga [ 8 ] ) , 'geoidal' : parseDist ( gga [ 11 ] , gga [ 12 ] ) , 'age' : parseNumber ( gga [ 13 ] ) , 'stationID' : parseNumber ( gga [ 14 ] ) } ; }
261	function ( sites , pluginSlug ) { let plugin , plugins = this . getPlugins ( sites ) , pluginSites ; if ( ! plugins ) { return ; } plugin = find ( plugins , _filters . isEqual . bind ( this , pluginSlug ) ) ; if ( ! plugin ) { return null ; } pluginSites = plugin . sites . filter ( site => site . visible ) . map ( site => { const pluginSite = clone ( getSite ( reduxGetState ( ) , site . ID ) ) ; pluginSite . plugin = site . plugin ; return pluginSite ; } ) ; return pluginSites . sort ( function ( first , second ) { return first . title . toLowerCase ( ) > second . title . toLowerCase ( ) ? 1 : - 1 ; } ) ; }
3080	function ( walk ) { if ( ! walk . at ( '@ ' ) ) return false ; var startIdx = walk . position ; var found = false ; while ( ! found && walk . hasCurrent ( ) ) { walk . scrollToTerm ( ) . skipBlankLines ( ) ; if ( walk . atSpaces ( this . blockIndent ) ) { var i = walk . position ; walk . skipWhitespaces ( ) ; if ( ! walk . at ( '@' ) && ! walk . at ( '*' ) ) { found = true ; walk . startFrom ( i ) ; } } else found = true ; } var g = this . stripSelector ( new SubWalker ( walk , startIdx , walk . position ) ) ; this . emitAssociativeGroup ( g ) ; return true ; }
1463	function ( ) { return { command : "list [repository]" , describe : "if no repository name is given, lists all available contribs that are compatible with the project's qooxdoo version (\"--all\" lists incompatible ones as well). Otherwise, list all compatible contrib libraries." , \" , \" } ; }
2068	function formatMoment ( m , format ) { var i = 5 ; function replaceLongDateFormatTokens ( input ) { return m . lang ( ) . longDateFormat ( input ) || input ; } while ( i -- && localFormattingTokens . test ( format ) ) { format = format . replace ( localFormattingTokens , replaceLongDateFormatTokens ) ; } if ( ! formatFunctions [ format ] ) { formatFunctions [ format ] = makeFormatFunction ( format ) ; } return formatFunctions [ format ] ( m ) ; }
2787	function ldt ( date , long = true , options = null ) { return Localizer . Singleton . formatDateTime ( date , long , options ) }
3148	function ( model , setOnStore ) { var me = this ; me . model = Ext . ModelManager . getModel ( model ) ; me . setReader ( this . reader ) ; me . setWriter ( this . writer ) ; if ( setOnStore && me . store ) { me . store . setModel ( me . model ) ; } }
1227	function defaultTokenizer ( input , selection , selectCallback , opts ) { var original = input , dupe = false , token , index , i , l , separator ; if ( ! opts . createSearchChoice || ! opts . tokenSeparators || opts . tokenSeparators . length < 1 ) return undefined ; while ( true ) { index = - 1 ; for ( i = 0 , l = opts . tokenSeparators . length ; i < l ; i ++ ) { separator = opts . tokenSeparators [ i ] ; index = input . indexOf ( separator ) ; if ( index >= 0 ) break ; } if ( index < 0 ) break ; token = input . substring ( 0 , index ) ; input = input . substring ( index + separator . length ) ; if ( token . length > 0 ) { token = opts . createSearchChoice . call ( this , token , selection ) ; if ( token !== undefined && token !== null && opts . id ( token ) !== undefined && opts . id ( token ) !== null ) { dupe = false ; for ( i = 0 , l = selection . length ; i < l ; i ++ ) { if ( equal ( opts . id ( token ) , opts . id ( selection [ i ] ) ) ) { dupe = true ; break ; } } if ( ! dupe ) selectCallback ( token ) ; } } } if ( original !== input ) return input ; }
791	function updateTabIndex ( ) { var allLinks = document . querySelectorAll ( '.slide a' ) ; var position = currentPosition ( ) ; var currentPageLinks = document . getElementById ( 'slide-' + position ) . querySelectorAll ( 'a' ) ; var i ; for ( i = 0 ; i < allLinks . length ; i ++ ) { allLinks [ i ] . setAttribute ( 'tabindex' , - 1 ) ; } for ( i = 0 ; i < currentPageLinks . length ; i ++ ) { currentPageLinks [ i ] . removeAttribute ( 'tabindex' ) ; } }
2228	function recurse ( streams ) { if ( streams . length < 2 ) return streams [ 0 ] . pipe ( streams [ 1 ] ) recurse ( streams . slice ( 1 ) ) }
1694	function _getViewSequenceAtIndex ( index , startViewSequence ) { if ( this . _viewSequence . getAtIndex ) { return this . _viewSequence . getAtIndex ( index , startViewSequence ) ; } var viewSequence = startViewSequence || this . _viewSequence ; var i = viewSequence ? viewSequence . getIndex ( ) : index ; if ( index > i ) { while ( viewSequence ) { viewSequence = viewSequence . getNext ( ) ; if ( ! viewSequence ) { return undefined ; } i = viewSequence . getIndex ( ) ; if ( i === index ) { return viewSequence ; } else if ( index < i ) { return undefined ; } } } else if ( index < i ) { while ( viewSequence ) { viewSequence = viewSequence . getPrevious ( ) ; if ( ! viewSequence ) { return undefined ; } i = viewSequence . getIndex ( ) ; if ( i === index ) { return viewSequence ; } else if ( index > i ) { return undefined ; } } } return viewSequence ; }
1946	function processClassName ( name , item ) { name = transformClassName ( name , item , 'element' ) ; name = transformClassName ( name , item , 'modifier' ) ; var block = '' , element = '' , modifier = '' ; var separators = getSeparators ( ) ; if ( ~ name . indexOf ( separators . element ) ) { var blockElem = name . split ( separators . element ) ; var elemModifiers = blockElem [ 1 ] . split ( separators . modifier ) ; block = blockElem [ 0 ] ; element = elemModifiers . shift ( ) ; modifier = elemModifiers . join ( separators . modifier ) ; } else if ( ~ name . indexOf ( separators . modifier ) ) { var blockModifiers = name . split ( separators . modifier ) ; block = blockModifiers . shift ( ) ; modifier = blockModifiers . join ( separators . modifier ) ; } if ( block || element || modifier ) { if ( ! block ) { block = item . __bem . block ; } var prefix = block ; var result = [ ] ; if ( element ) { prefix += separators . element + element ; result . push ( prefix ) ; } else { result . push ( prefix ) ; } if ( modifier ) { result . push ( prefix + separators . modifier + modifier ) ; } item . __bem . block = block ; item . __bem . element = element ; item . __bem . modifier = modifier ; return result ; } return name ; }
2481	function ( ) { var i = 0 , len = SinonExpect . assertions . length , matcher ; for ( i , len ; i < len ; i ++ ) { matcher = SinonExpect . assertions [ i ] ; ( function ( matcher ) { SinonExpect . SinonAssertions . prototype [ matcher ] = function ( ) { var args = Array . prototype . slice . call ( arguments ) , sinon = SinonExpect . _sinon ; args . unshift ( this . obj ) ; sinon . assert [ matcher ] . apply ( sinon . assert , args ) ; } ; } ( matcher ) ) ; } }
2112	function withCallbackHandler ( ctx , connectMiddleware , next ) { return new Promise ( ( resolve , reject ) => { connectMiddleware ( ctx . req , ctx . res , err => { if ( err ) reject ( err ) else resolve ( next ( ) ) } ) } ) }
3229	function ( obj ) { var i = 0 , items = this . items , len = this . length , item , el ; for ( ; i < len ; i ++ ) { item = items [ i ] ; el = item . el ; if ( el ) { el . setStyle ( obj ) ; } } }
2939	function markymark ( container = document . getElementsByTagName ( 'marky-mark' ) ) { if ( container instanceof HTMLElement ) { return initializer ( container ) ; } if ( ! ( container instanceof Array ) && ! ( container instanceof HTMLCollection ) && ! ( container instanceof NodeList ) ) { throw new TypeError ( 'argument should be an HTMLElement, Array, HTMLCollection' ) ; } return Array . from ( container ) . map ( initializer ) ; }
1815	function _watchedEventsBindAll ( context ) { var watchedEvents = getState ( '__watchedEvents' , context ) ; if ( watchedEvents ) { var data ; for ( var name in watchedEvents ) { if ( watchedEvents . hasOwnProperty ( name ) ) { data = watchedEvents [ name ] ; var target = getTarget ( data . target , context ) ; if ( target ) { target [ data . type ] ( data . event , data . callback , data . context ) ; } } } } }
302	function setData ( element , name , data ) { if ( isObject ( data ) ) { element [ name ] = data ; } else if ( element . dataset ) { element . dataset [ name ] = data ; } else { element . setAttribute ( "data-" . concat ( toParamCase ( name ) ) , data ) ; } }
1952	function ( err , res ) { if ( err ) return sender . emit ( 'transmissionError' , err , data . channelURI ) ; sender . emit ( 'transmitted' , res , data . channelURI ) ; }
2208	function validateRender ( inlineValues ) { if ( "_render" in inlineValues ) { var skipValue = inlineValues [ "_render" ] ; if ( skipValue in options ) { return ! options [ skipValue ] ; } } return false ; }
2423	function ( N , data ) { var azi = new Array ( data . length ) ; var elev = new Array ( data . length ) ; for ( var i = 0 ; i < data . length ; i ++ ) { azi [ i ] = data [ i ] [ 0 ] ; elev [ i ] = data [ i ] [ 1 ] ; } var factorials = new Array ( 2 * N + 1 ) ; var Ndirs = azi . length ; var Nsh = ( N + 1 ) * ( N + 1 ) ; var leg_n_minus1 = 0 ; var leg_n_minus2 = 0 ; var leg_n ; var sinel = numeric . sin ( elev ) ; var index_n = 0 ; var Y_N = new Array ( Nsh ) ; var Nn0 , Nnm ; var cosmazi , sinmazi ; for ( var i = 0 ; i < 2 * N + 1 ; i ++ ) factorials [ i ] = factorial ( i ) ; for ( var n = 0 ; n < N + 1 ; n ++ ) { if ( n == 0 ) { var temp0 = new Array ( azi . length ) ; temp0 . fill ( 1 ) ; Y_N [ n ] = temp0 ; index_n = 1 ; } else { leg_n = recurseLegendrePoly ( n , sinel , leg_n_minus1 , leg_n_minus2 ) ; Nn0 = Math . sqrt ( 2 * n + 1 ) ; for ( var m = 0 ; m < n + 1 ; m ++ ) { if ( m == 0 ) Y_N [ index_n + n ] = numeric . mul ( Nn0 , leg_n [ m ] ) ; else { Nnm = Nn0 * Math . sqrt ( 2 * factorials [ n - m ] / factorials [ n + m ] ) ; cosmazi = numeric . cos ( numeric . mul ( m , azi ) ) ; sinmazi = numeric . sin ( numeric . mul ( m , azi ) ) ; Y_N [ index_n + n - m ] = numeric . mul ( Nnm , numeric . mul ( leg_n [ m ] , sinmazi ) ) ; Y_N [ index_n + n + m ] = numeric . mul ( Nnm , numeric . mul ( leg_n [ m ] , cosmazi ) ) ; } } index_n = index_n + 2 * n + 1 ; } leg_n_minus2 = leg_n_minus1 ; leg_n_minus1 = leg_n ; } return Y_N ; }
1862	function ( ) { if ( ! this . children . length ) return null ; var deepestChild = this ; while ( deepestChild . children . length ) { deepestChild = _ . last ( deepestChild . children ) ; } return deepestChild ; }
782	function ( filterInput , uri ) { var _url = new URL ( uri ) ; var _filterValueFromURL = _url . searchParams . get ( 'filter' ) ; if ( typeof _filterValueFromURL !== 'undefined' && _filterValueFromURL !== null ) { _filterValue = _filterValueFromURL ; filterInput . value = _filterValue ; } }
2546	function toNumber ( value ) { if ( typeof value == 'number' ) { return value ; } if ( isSymbol$3 ( value ) ) { return NAN ; } if ( isObject$4 ( value ) ) { var other = typeof value . valueOf == 'function' ? value . valueOf ( ) : value ; value = isObject$4 ( other ) ? ( other + '' ) : other ; } if ( typeof value != 'string' ) { return value === 0 ? value : + value ; } value = value . replace ( reTrim , '' ) ; var isBinary = reIsBinary . test ( value ) ; return ( isBinary || reIsOctal . test ( value ) ) ? freeParseInt ( value . slice ( 2 ) , isBinary ? 2 : 8 ) : ( reIsBadHex . test ( value ) ? NAN : + value ) ; }
1680	function tokenizeCheck ( ) { var fn = tokenize . serie . apply ( tokenize , arguments ) ; return function ( text , opts , callback ) { try { callback ( null , fn ( text , opts ) ) ; } catch ( err ) { callback ( err ) ; } } ; }
1644	function get_req ( ) { var self = this ; var req ; if ( window . XMLHttpRequest ) { try { req = new XMLHttpRequest ( ) ; } catch ( e1 ) { req = false ; } } else if ( window . ActiveXObject ) { try { req = new ActiveXObject ( "Microsoft.XMLHTTP" ) ; } catch ( e2 ) { req = false ; } } return req ; }
295	function toArray ( value ) { return Array . from ? Array . from ( value ) : slice . call ( value ) ; }
3078	function ( type , walk ) { if ( ! this . atGroupMarker ( type , walk ) ) return false ; var startIdx = walk . position ; var found = false ; while ( walk . hasCurrent ( ) && ! found ) { walk . scrollToTerm ( ) . skipWhitespaces ( ) ; if ( ! this . atGroupMarker ( type , walk ) ) found = true ; } var g = this . stripSelector ( new SubWalker ( walk , startIdx , walk . position ) ) ; this . emitGroup ( type , g ) ; return true ; }
3067	function getPreviewCss ( ed , fmt ) { var name , previewElm , dom = ed . dom , previewCss = '' , parentFontSize , previewStylesName ; previewStyles = ed . settings . preview_styles ; if ( previewStyles === false ) return '' ; if ( ! previewStyles ) previewStyles = 'font-family font-size font-weight text-decoration text-transform color background-color' ; function removeVars ( val ) { return val . replace ( / %(\w+) / g , '' ) ; } ; name = fmt . block || fmt . inline || 'span' ; previewElm = dom . create ( name ) ; each ( fmt . styles , function ( value , name ) { value = removeVars ( value ) ; if ( value ) dom . setStyle ( previewElm , name , value ) ; } ) ; each ( fmt . attributes , function ( value , name ) { value = removeVars ( value ) ; if ( value ) dom . setAttrib ( previewElm , name , value ) ; } ) ; each ( fmt . classes , function ( value ) { value = removeVars ( value ) ; if ( ! dom . hasClass ( previewElm , value ) ) dom . addClass ( previewElm , value ) ; } ) ; dom . setStyles ( previewElm , { position : 'absolute' , left : - 0xFFFF } ) ; ed . getBody ( ) . appendChild ( previewElm ) ; parentFontSize = dom . getStyle ( ed . getBody ( ) , 'fontSize' , true ) ; parentFontSize = / px$ / . test ( parentFontSize ) ? parseInt ( parentFontSize , 10 ) : 0 ; each ( previewStyles . split ( ' ' ) , function ( name ) { var value = dom . getStyle ( previewElm , name , true ) ; if ( name == 'background-color' && / transparent|rgba\s*\([^)]+,\s*0\) / . test ( value ) ) { value = dom . getStyle ( ed . getBody ( ) , name , true ) ; if ( dom . toHex ( value ) . toLowerCase ( ) == '#ffffff' ) { return ; } } if ( name == 'font-size' ) { if ( / em|%$ / . test ( value ) ) { if ( parentFontSize === 0 ) { return ; } value = parseFloat ( value , 10 ) / ( / %$ / . test ( value ) ? 100 : 1 ) ; value = ( value * parentFontSize ) + 'px' ; } } previewCss += name + ':' + value + ';' ; } ) ; dom . remove ( previewElm ) ; return previewCss ; }
1935	function fillImpliedPositions ( colorStops ) { var from = 0 ; _ . each ( colorStops , function ( cs , i ) { if ( ! i ) return cs . position = cs . position || 0 ; if ( i == colorStops . length - 1 && ! ( 'position' in cs ) ) cs . position = 1 ; if ( 'position' in cs ) { var start = colorStops [ from ] . position || 0 ; var step = ( cs . position - start ) / ( i - from ) ; _ . each ( colorStops . slice ( from , i ) , function ( cs2 , j ) { cs2 . position = start + step * j ; } ) ; from = i ; } } ) ; }
2291	function processGloss ( gloss , callback ) { if ( ! ( gloss instanceof Element ) ) { var err = new Error ( 'Invalid gloss element' ) ; if ( typeof callback === 'function' ) { callback ( err ) ; } else { throw err ; } } var lines = Array . prototype . slice . call ( gloss . children ) ; var linesToAlign = [ ] ; var firstRawLine = null ; var firstRawLineNum = 0 ; triggerEvent ( gloss , events . beforeGloss ) ; if ( firstLineOrig ) { var firstLine = lines [ 0 ] ; addClass ( firstLine , classes . original ) ; } if ( lastLineFree ) { var lastLine = lines [ lines . length - 1 ] ; addClass ( lastLine , classes . freeTranslation ) ; } lines . forEach ( function ( line , lineNum ) { var isOrig = hasClass ( line , classes . original ) ; var isFree = hasClass ( line , classes . freeTranslation ) ; var shouldSkip = hasClass ( line , classes . noAlign ) ; var shouldAlign = ! isOrig && ! isFree && ! shouldSkip ; if ( shouldAlign ) { triggerEvent ( line , events . beforeLex , { lineNum : lineNum } ) ; var tokens = _this2 . lex ( line . innerHTML ) ; triggerEvent ( line , events . afterLex , { tokens : tokens , lineNum : lineNum } ) ; linesToAlign . push ( tokens ) ; addClass ( line , classes . hidden ) ; if ( ! firstRawLine ) { firstRawLine = line ; firstRawLineNum = lineNum ; } } else { addClass ( line , classes . line ) ; addClass ( line , classes . lineNum + lineNum ) ; } } ) ; var lastRawLineNum = firstRawLineNum + ( linesToAlign . length - 1 ) ; triggerEvent ( gloss , events . beforeAlign , { lines : linesToAlign , firstLineNum : firstRawLineNum , lastLineNum : lastRawLineNum } ) ; var alignedLines = _this2 . align ( linesToAlign ) ; triggerEvent ( gloss , events . afterAlign , { lines : alignedLines , firstLineNum : firstRawLineNum , lastLineNum : lastRawLineNum } ) ; var alignedWrapper = undefined ; if ( gloss . tagName === 'UL' || gloss . tagName === 'OL' ) { alignedWrapper = 'li' ; } else { alignedWrapper = 'div' ; } triggerEvent ( gloss , events . beforeFormat , { lines : alignedLines , firstLineNum : firstRawLineNum , lastLineNum : lastRawLineNum } ) ; var formattedLines = _this2 . format ( alignedLines , alignedWrapper , firstRawLineNum ) ; gloss . insertBefore ( formattedLines , firstRawLine ) ; triggerEvent ( formattedLines , events . afterFormat , { firstLineNum : firstRawLineNum , lastLineNum : lastRawLineNum } ) ; if ( ! spacing ) { addClass ( gloss , classes . noSpace ) ; } addClass ( gloss , classes . glossed ) ; triggerEvent ( gloss , events . afterGloss ) ; }
2292	function UrlHelper ( params ) { this . url = "http://store.steampowered.com/search/?" ; if ( ! ! params . tags ) { for ( i = 0 ; i < params . tags . length ; i ++ ) params . tags [ i ] = parameters . tags . get ( params . tags [ i ] ) . value this . url += "tags=" + params . tags . join ( "," ) + "&" ; } if ( ! ! params . os ) { for ( i = 0 ; i < params . os . length ; i ++ ) params . os [ i ] = parameters . os . get ( params . os [ i ] ) . value this . url += "os=" + params . os . join ( "," ) + "&" ; } if ( ! ! params . playerAmount ) for ( i = 0 ; i < params . playerAmount . length ; i ++ ) params . playerAmount [ i ] = parameters . playerAmount . get ( params . playerAmount [ i ] ) . value this . url += "category3=" + params . playerAmount . join ( "," ) + "&" ; if ( params . gamesOnly ) this . url += "category1=998&" ; }
2337	function init ( dataset_id , options , cb ) { debug ( '[%s] init sync with options %j' , dataset_id , options ) ; datasets . init ( dataset_id , options ) ; module . exports . api . start ( function ( err ) { if ( err ) { return cb ( err ) ; } syncStorage . updateManyDatasetClients ( { datasetId : dataset_id } , { stopped : false } , cb ) ; } ) ; }
3805	function cons ( b , value , next ) { var free = readValue ( b , 0 ) || 8 updateValue ( b , free , value ) ; updateNext ( b , free , next ) updateValue ( b , 0 , free + 8 ) return free }
2773	async function sendMessage ( app , context , title , message , { update = '' , updateAfterDays = 7 , owner , repo } = { } ) { if ( ! app || ! context || ! title || ! message ) { throw new Error ( 'Required parameter missing' ) ; } if ( ! owner || ! repo ) { ( { owner , repo } = context . repo ( ) ) ; } const appGh = await app . auth ( ) ; const { name : appName , html_url : appUrl } = ( await appGh . apps . get ( { } ) ) . data ; const { data : issues } = await context . github . issues . getForRepo ( { owner , repo , state : 'open' , creator : ` ${ appName } ` , per_page : 100 } ) ; message = message . replace ( / {appName} / , appName ) . replace ( / {appUrl} / , appUrl ) ; const messageHash = crypto . createHash ( 'sha256' ) . update ( message ) . digest ( 'hex' ) ; const messageHashRx = new RegExp ( ` ${ messageHash } ` ) ; for ( const issue of issues ) { if ( ! messageHashRx . test ( issue . body ) ) { continue ; } let commentId = null ; if ( update && ! issue . locked && Date . now ( ) - Date . parse ( issue . updated_at ) >= updateAfterDays * 24 * 60 * 60 * 1000 ) { update = update . replace ( / {appName} / , appName ) . replace ( / {appUrl} / , appUrl ) ; const { data : commentData } = await context . github . issues . createComment ( { owner , repo , number : issue . number , body : update } ) ; commentId = commentData . id ; } return new Message ( owner , repo , issue . number , commentId , false ) ; } title = title . replace ( / {appName} / , appName ) . replace ( / {appUrl} / , appUrl ) ; const { data : issueData } = await context . github . issues . create ( { owner , repo , title , body : ` ${ message } \n ${ messageHash } ` } ) ; return new Message ( owner , repo , issueData . number , null , true ) ; }
2573	function rtrim ( s , what ) { what = typeof what === 'string' ? what : '\\s+' ; \\ }
3186	function ( target ) { var me = this , anims = [ ] , timeline = me . timeline , ln = timeline . length , anim , easing , damper , attrs , i ; if ( me . fireEvent ( 'beforeanimate' , me ) !== false ) { for ( i = 0 ; i < ln ; i ++ ) { anim = timeline [ i ] ; attrs = anim . attrs ; easing = attrs . easing || me . easing ; damper = attrs . damper || me . damper ; delete attrs . easing ; delete attrs . damper ; anim = new Ext . fx . Anim ( { target : target , easing : easing , damper : damper , duration : anim . duration , paused : true , to : attrs } ) ; anims . push ( anim ) ; } me . animations = anims ; me . target = anim . target ; for ( i = 0 ; i < ln - 1 ; i ++ ) { anim = anims [ i ] ; anim . nextAnim = anims [ i + 1 ] ; anim . on ( 'afteranimate' , function ( ) { this . nextAnim . paused = false ; } ) ; anim . on ( 'afteranimate' , function ( ) { this . fireEvent ( 'keyframe' , this , ++ this . keyframeStep ) ; } , me ) ; } anims [ ln - 1 ] . on ( 'afteranimate' , function ( ) { this . lastFrame ( ) ; } , me ) ; } }
1778	function setup ( options ) { var childRunner = ChildRunner . current ( ) ; if ( childRunner ) { _deepMerge ( _config , childRunner . parentScope . WCT . _config ) ; delete _config . mochaOptions . ui ; } if ( options && typeof options === 'object' ) { _deepMerge ( _config , options ) ; } if ( ! _config . root ) { var root = scriptPrefix ( 'browser.js' ) ; _config . root = basePath ( root . substr ( 0 , root . length - 1 ) ) ; if ( ! _config . root ) { throw new Error ( 'Unable to detect root URL for WCT sources. Please set WCT.root before including browser.js' ) ; } } }
338	function ( option , data ) { data = data || option ; var content = this . customOption ? this . config . renderOption ( data ) : option . textContent ; var opt = util . createElement ( "li" , { class : "selectr-option" , html : content , role : "treeitem" , "aria-selected" : false } ) ; opt . idx = option . idx ; this . items . push ( opt ) ; if ( option . defaultSelected ) { this . defaultSelected . push ( option . idx ) ; } if ( option . disabled ) { opt . disabled = true ; util . addClass ( opt , "disabled" ) ; } return opt ; }
2570	function differenceFromString ( s , other ) { if ( typeof other !== 'string' || typeof s !== 'string' ) return s ; var sarr = s . split ( '' ) , oarr = other . split ( '' ) ; return libs . array . difference ( sarr , oarr ) . join ( '' ) ; }
3312	function DeferredType ( typeSpec ) { if ( typeof typeSpec . defer !== 'function' ) { throw new Error ( 'Instances of DeferredType need typeSpec.defer to be a function that returns a type' ) ; } Object . keys ( typeSpec ) . forEach ( function ( key ) { this [ key ] = typeSpec [ key ] ; } , this ) ; }
93	function updateSetting ( setting , container , input ) { var pane = this . elements . settings . panels [ setting ] ; var value = null ; var list = container ; if ( setting === 'captions' ) { value = this . currentTrack ; } else { value = ! is$1 . empty ( input ) ? input : this [ setting ] ; if ( is$1 . empty ( value ) ) { value = this . config [ setting ] . default ; } if ( ! is$1 . empty ( this . options [ setting ] ) && ! this . options [ setting ] . includes ( value ) ) { this . debug . warn ( "Unsupported value of '" . concat ( value , "' for " ) . concat ( setting ) ) ; return ; } if ( ! this . config [ setting ] . options . includes ( value ) ) { this . debug . warn ( "Disabled value of '" . concat ( value , "' for " ) . concat ( setting ) ) ; return ; } } if ( ! is$1 . element ( list ) ) { list = pane && pane . querySelector ( '[role="menu"]' ) ; } if ( ! is$1 . element ( list ) ) { return ; } var label = this . elements . settings . buttons [ setting ] . querySelector ( "." . concat ( this . config . classNames . menu . value ) ) ; label . innerHTML = controls . getLabel . call ( this , setting , value ) ; var target = list && list . querySelector ( "[value=\"" . \" concat ) ; ( value , "\"]" ) }
1221	function merge ( obj ) { for ( var i = 1 ; i < arguments . length ; i ++ ) { var def = arguments [ i ] for ( var n in def ) if ( obj [ n ] === undefined ) obj [ n ] = def [ n ] } return obj }
3698	function smash ( a , ... rest ) { rest . forEach ( b => { if ( this . isSmashable ( a , b ) ) this . _smash ( a , b ) ; } ) ; return a ; }
679	function ( app ) { var elems = [ "content" , "focusKeyword" , "synonyms" ] ; for ( var i = 0 ; i < elems . length ; i ++ ) { document . getElementById ( elems [ i ] ) . addEventListener ( "input" , app . refresh . bind ( app ) ) ; } document . getElementById ( "locale" ) . addEventListener ( "input" , setLocale . bind ( app ) ) ; document . getElementById ( "premium" ) . addEventListener ( "input" , setPremium . bind ( app ) ) ; }
1903	function ( val ) { if ( ! _ . isUndefined ( val ) && this . _name !== ( val = String ( val ) ) ) { this . _updateSource ( val , this . _positions . name , this . _positions . name + this . _name . length ) ; this . _name = val ; } return this . _name ; }
3670	function forward ( event , source , target ) { source . on ( event , target . emit . bind ( target , event ) ) ; }
1659	function ps ( callback ) { var args = [ '-A' , '-o' , 'ppid,pid' ] ; bin ( 'ps' , args , function ( err , stdout , code ) { if ( err ) return callback ( err ) ; if ( code !== 0 ) { return callback ( new Error ( 'pidtree ps command exited with code ' + code ) ) ; } try { stdout = stdout . split ( os . EOL ) ; var list = [ ] ; for ( var i = 1 ; i < stdout . length ; i ++ ) { stdout [ i ] = stdout [ i ] . trim ( ) ; if ( ! stdout [ i ] ) continue ; stdout [ i ] = stdout [ i ] . split ( / \s+ / ) ; stdout [ i ] [ 0 ] = parseInt ( stdout [ i ] [ 0 ] , 10 ) ; stdout [ i ] [ 1 ] = parseInt ( stdout [ i ] [ 1 ] , 10 ) ; list . push ( stdout [ i ] ) ; } callback ( null , list ) ; } catch ( error ) { callback ( error ) ; } } ) ; }
2747	function interceptWriteStream ( writeStream ) { return new Promise ( ( resolve , reject ) => { let response = "" ; let writeBkp = writeStream . write ; let sendBkp = writeStream . send ; let endBkp = writeStream . end ; writeStream . write = function ( chunk , encoding , callback ) { response += chunk ; if ( typeof encoding == "function" ) { encoding ( ) ; } else if ( callback ) { callback ( ) ; } return true ; } ; writeStream . send = function ( body ) { writeStream . end ( body ) ; } ; writeStream . end = function ( chunk , encoding , callback ) { if ( chunk ) { response += chunk ; } writeStream . write = writeBkp ; writeStream . send = sendBkp ; writeStream . end = endBkp ; if ( typeof encoding == "function" ) { writeStream . once ( "finish" , encoding ) ; } else if ( callback ) { writeStream . once ( "finish" , encoding ) ; } resolve ( response ) ; } ; } ) ; }
2741	function ( endpoint , all ) { if ( ! _ . isNil ( endpoint ) ) { all = _ . assignIn ( _ . clone ( allEndpointParameters ( endpoint . parent , endpoint . parameters ) ) , all || { } ) } return all }
1814	function ( context ) { context . icon = 'loading' ; context . disabled = true ; if ( this . props . loadingMessage ) { context . children = this . props . loadingMessage ; } }
3009	function _returnMap ( callback , file , created ) { if ( typeof file === 'string' ) { var map = foldermap . mapSync ( file ) ; Object . defineProperty ( map , '_created' , { value : created } ) ; } else { var map = { } ; for ( var i in file ) { map [ i ] = foldermap . mapSync ( file [ i ] ) ; Object . defineProperty ( map [ i ] , '_created' , { value : created } ) ; } } callback ( null , map ) ; }
2213	function parse ( fileContent , filePath , destFile , values ) { var section = extractSection ( fileContent ) ; if ( section ) { fileContent = processContent ( section . before , values ) ; if ( section . inner ) { fileContent += replaceString ( section . inner , "" , "" , filePath , section . attributes , filePath , destFile , values ) ; } else if ( section . includePath ) { fileContent += replaceFile ( section . linebreak , section . indent , section . includePath , section . attributes , filePath , destFile , values ) ; } fileContent += parse ( section . after , filePath , destFile , values ) ; } else { return processContent ( fileContent , values ) ; } return fileContent ; }
1365	function ( identifier , data , config , cb ) { var path = api . getPath ( baseURL , identifier , detailsActionPath ) ; api . post ( path , data , config , cb ) ; }
3173	function addOptions ( flags ) { Object . keys ( options ) . forEach ( function ( name ) { var dashedName = toDashCase ( name ) ; if ( ( name in parseOptions ) && ( name in transformOptions ) ) { flags . option ( '--' + dashedName + ' [true|false|parse]' , descriptions [ name ] ) ; flags . on ( dashedName , ( value ) => setOption ( dashedName , value ) ) ; } else if ( options [ name ] !== null ) { flags . option ( '--' + dashedName , descriptions [ name ] ) ; flags . on ( dashedName , ( ) => setOption ( dashedName , true ) ) ; } } ) ; flags . option ( '--referrer <name>' , 'Bracket output code with System.referrerName=<name>' , ( name ) => { setOption ( 'referrer' , name ) ; return name ; } ) ; flags . option ( '--type-assertion-module <path>' , 'Absolute path to the type assertion module.' , ( path ) => { setOption ( 'type-assertion-module' , path ) ; return path ; } ) ; flags . option ( '--script <fileName>' , 'Parse as Script (must precede modules)' , ( fileName ) => { options . scripts . push ( fileName ) ; } ) ; }
392	function filterUnusedSelectors ( selectors , ignore , usedSelectors ) { return selectors . filter ( ( selector ) => { selector = dePseudify ( selector ) ; if ( selector [ 0 ] === '@' ) { return true ; } for ( let i = 0 , len = ignore . length ; i < len ; ++ i ) { if ( _ . isRegExp ( ignore [ i ] ) && ignore [ i ] . test ( selector ) ) { return true ; } if ( ignore [ i ] === selector ) { return true ; } } return usedSelectors . indexOf ( selector ) !== - 1 ; } ) ; }
913	function parseTplDataInfo ( value ) { value = value . substring ( 1 , value . length - 1 ) ; let items = value . split ( ',' ) ; let dataObjAttrs = { } ; items . forEach ( item => { let colonIdx = item . indexOf ( ':' ) ; if ( colonIdx !== - 1 ) { let key = item . substring ( 0 , colonIdx ) . trim ( ) ; let value = item . substr ( colonIdx + 1 ) . trim ( ) ; key === value || ( dataObjAttrs [ key ] = value ) ; } } ) ; return Object . keys ( dataObjAttrs ) . length ? dataObjAttrs : null ; }
2890	function sqlTypeCast ( type , attrName ) { type = type && type . toLowerCase ( ) ; switch ( type ) { case 'string' : return 'VARCHAR2(255)' ; case 'text' : case 'array' : case 'json' : return 'VARCHAR2(255)' ; case 'boolean' : return 'NUMBER(1) CHECK("' + attrName + '" IN (0,1))' ; case 'int' : case 'integer' : return 'NUMBER' ; case 'float' : case 'double' : return 'FLOAT' ; case 'date' : return 'DATE' ; case 'datetime' : return 'TIMESTAMP' ; case 'binary' : return 'BLOB' ; default : console . error ( "Unregistered type given: " + type ) ; return "TEXT" ; } }
1360	function download ( url , path ) { console . log ( "Downloading the mkcert executable..." ) const file = fs . createWriteStream ( path ) return new Promise ( resolve => { function get ( url , file ) { https . get ( url , ( response ) => { if ( response . statusCode === 302 ) get ( response . headers . location , file ) else response . pipe ( file ) . on ( "finish" , resolve ) } ) } get ( url , file ) } ) }
1433	function ( ) { return path . join ( process . cwd ( ) , qx . tool . cli . ConfigSchemas . lockfile . filename ) ; }
3709	function distinctUntilKeyChanged ( keySelector ) { return function * ( it ) { let prev = undefined ; for ( const item of it ) { const key = keySelector ( item ) ; if ( key === prev ) { continue ; } prev = key ; yield item ; } } ; }
1679	function tokenizeDefine ( infos ) { return tokenize . split ( function ( text , tok ) { var _infos = _ . isFunction ( infos ) ? infos . apply ( null , arguments ) : _ . clone ( infos ) ; if ( ! _infos ) return null ; _infos = _ . defaults ( _infos , { index : 0 , message : "" , replacements : [ ] } ) ; _infos = _ . extend ( tok , _infos ) ; _infos . message = _ . template ( _infos . message ) ( _infos ) ; return _infos ; } ) ; }
955	function normalizeBabelPlugins ( plugins , file , buildManager ) { if ( typeof plugins === 'function' ) { plugins = plugins ( file ) ; } plugins = plugins ? [ ] . concat ( plugins ) : [ ] ; if ( ! hasBabelDepPlugin ( plugins ) ) { plugins . push ( DEP_PLUGIN_NAME ) ; } return ( plugins || [ ] ) . map ( item => { if ( typeof item === 'string' ) { let result = BUILTIN_PLUGINS [ item ] ; if ( typeof result === 'function' ) { return result ( file , buildManager ) ; } } return item ; } ) ; }
1403	function ReadableStreamReaderGenericCancel ( reader , reason ) { const stream = reader . _ownerReadableStream ; assert ( stream !== undefined ) ; return ReadableStreamCancel ( stream , reason ) ; }
3617	function expiry ( expires ) { var buffer , int64 ; if ( expires % 1000 === 0 ) { buffer = new Buffer ( 5 ) ; buffer . writeUInt8 ( 0xFD , 0 ) ; buffer . writeInt32LE ( expires / 1000 , 1 ) ; } else { buffer = new Buffer ( 9 ) ; int64 = new Int64 ( expires ) ; buffer . writeUInt8 ( 0xFC , 0 ) ; buffer . writeUInt32LE ( int64 . low32 ( ) , 1 ) ; buffer . writeUInt32LE ( int64 . high32 ( ) , 5 ) ; } return buffer ; }
2364	function SyncScheduler ( syncQueueImpl , options ) { if ( ! syncQueueImpl ) { throw new Error ( 'syncQueueImpl is required' ) ; } this . syncQueue = syncQueueImpl ; options = options || { } ; this . syncSchedulerLockName = options . syncSchedulerLockName || 'locks:sync:SyncScheduler' ; this . timeBetweenChecks = options . timeBetweenChecks || 500 ; this . timeBeforeCrashAssumed = options . timeBeforeCrashAssumed || 20000 ; this . stopped = false ; }
1287	function ArraySome ( f , receiver ) { CHECK_OBJECT_COERCIBLE ( this , "Array.prototype.some" ) ; var array = TO_OBJECT ( this ) ; var length = TO_LENGTH ( array . length ) ; return InnerArraySome ( f , receiver , array , length ) ; }
2817	function ( parentClass , constructor ) { constructor . prototype = Object . create ( parentClass . prototype ) ; for ( var key in Subscribable . prototype ) { constructor . prototype [ key ] = Subscribable . prototype [ key ] ; } constructor . prototype . constructor = constructor ; constructor . prototype . _keepHot = true ; return constructor ; }
3294	function ( request ) { var me = this , requests = me . requests , key ; if ( request ) { if ( ! request . id ) { request = requests [ request ] ; } me . handleAbort ( request ) ; } else { for ( key in requests ) { if ( requests . hasOwnProperty ( key ) ) { me . abort ( requests [ key ] ) ; } } } }
3650	function ( e ) { var lineRE = / ^.*at (\w+) \(([^\)]+)\)$ / gm ; return e . stack . replace ( / at Anonymous function / gm , '{anonymous}()@' ) . replace ( / ^(?=\w+Error\:).*$\n / m , '' ) . replace ( lineRE , '$1@$2' ) . split ( '\n' ) ; }
2994	function hmacSign ( input , algorithm , secret ) { return crypto . createHmac ( algorithm , secret ) . update ( input ) . digest ( 'base64' ) }
1790	function loadFiles ( pattern , rootDir ) { var isString = typeof pattern === 'string' ; var isArray = Array . isArray ( pattern ) ; if ( ( ! isString && ! isArray ) || ( pattern . length === 0 ) ) { throw new TypeError ( 'A glob pattern or an array of glob patterns is required.' ) ; } var filelist = resolveGlob ( pattern , rootDir ) . map ( function ( filename ) { return path . relative ( process . cwd ( ) , path . join ( rootDir , filename ) ) ; } ) ; var subfiles = getSubfiles ( filelist ) ; subfiles . forEach ( function ( subfile ) { util . log ( 'Loading' , util . colors . yellow ( subfile . relativePath ) ) ; loadSubfile ( subfile , tasks ) ; } ) ; }
2476	function projectConfigAddPaths ( originalConfig ) { const config = originalConfig ; if ( ! Object . prototype . hasOwnProperty . call ( config . paths . src , TASK_NAME ) ) { config . paths . src [ TASK_NAME ] = ` ${ config . dirs . src } ` ; } if ( ! Object . prototype . hasOwnProperty . call ( config . paths . dest , TASK_NAME ) ) { config . paths . dest [ TASK_NAME ] = ` ${ config . dirs . dest } ` ; } return config ; }
2841	function ( localImagePath ) { var imageFile = fs . readFileSync ( localImagePath ) ; var mimeType = mime . lookup ( localImagePath ) ; var ret = "data:" ; ret += mimeType ; ret += ";base64," ; ret += imageFile . toString ( "base64" ) ; return ret ; }
946	function getPlainObjectNodeValue ( node , path , t ) { let result ; if ( t . isObjectExpression ( node ) ) { result = { } ; let props = node . properties || [ ] ; for ( let i = 0 , len = props . length ; i < len ; i ++ ) { let subNode = props [ i ] ; let keyNode = subNode . key ; let key ; if ( t . isLiteral ( keyNode ) ) { key = keyNode . value ; } else if ( t . isIdentifier ( keyNode ) ) { key = keyNode . name ; } if ( ! key ) { continue ; } result [ key ] = getPlainObjectNodeValue ( subNode . value , path , t ) ; } } else if ( t . isArrayExpression ( node ) ) { result = [ ] ; node . elements . forEach ( item => { result . push ( getPlainObjectNodeValue ( item , path , t ) ) ; } ) ; } else if ( t . isNullLiteral ( node ) ) { result = null ; } else if ( t . isLiteral ( node ) ) { result = node . value ; } else { throw path . buildCodeFrameError ( 'only constant is supported' ) ; } return result ; }
1004	function ( path , strategy ) { if ( typeof path !== 'string' ) { throw new Error ( 'path should be a string' ) ; } if ( ! util . isFolder ( path ) ) { throw new Error ( 'path should be a folder' ) ; } if ( this . _remoteStorage && this . _remoteStorage . access && ! this . _remoteStorage . access . checkPathPermission ( path , 'r' ) ) { throw new Error ( 'No access to path "' + path + '". You have to claim access to it first.' ) ; } if ( ! strategy . match ( / ^(FLUSH|SEEN|ALL)$ / ) ) { throw new Error ( "strategy should be 'FLUSH', 'SEEN', or 'ALL'" ) ; } this . _rootPaths [ path ] = strategy ; if ( strategy === 'ALL' ) { if ( this . activateHandler ) { this . activateHandler ( path ) ; } else { this . pendingActivations . push ( path ) ; } } }
1502	function parseSingleOid ( oid ) { if ( typeof oid !== 'string' ) { return oid ; } if ( oid [ 0 ] !== '.' ) { throw new Error ( 'Invalid OID format' ) ; } oid = oid . split ( '.' ) . filter ( function ( s ) { return s . length > 0 ; } ) . map ( function ( s ) { return parseInt ( s , 10 ) ; } ) ; return oid ; }
912	function getImportTemplateElement ( tplFile , name ) { if ( ! name ) { return ; } let ast = tplFile . ast ; if ( ! ast ) { ast = tplFile . ast = parseDom ( tplFile . content . toString ( ) ) ; } let children = ast . children ; for ( let i = 0 , len = children . length ; i < len ; i ++ ) { let node = children [ i ] ; if ( node . type === 'tag' && node . name === 'template' ) { let { attribs : attrs } = node ; if ( attrs && attrs . name === name ) { return node ; } } } }
3584	function EdmundsClient ( config ) { if ( ! ( this instanceof EdmundsClient ) ) { return new EdmundsClient ( config ) ; } var defaultConfig = { } ; defaultConfig . responseFormat = 'json' ; defaultConfig . baseUrl = 'https://api.edmunds.com' ; this . config = extend ( defaultConfig , config ) ; if ( ! this . config . apiKey ) { throw new Error ( 'API key must be provided' ) ; } }
417	function ( ) { var ch , name , index = parserInput . i ; parserInput . save ( ) ; if ( parserInput . currentChar ( ) === '@' && ( name = parserInput . $re ( / ^@@?[\w-]+ / ) ) ) { ch = parserInput . currentChar ( ) ; if ( ch === '(' || ch === '[' && ! parserInput . prevChar ( ) . match ( / ^\s / ) ) { var result = parsers . variableCall ( name ) ; if ( result ) { parserInput . forget ( ) ; return result ; } } parserInput . forget ( ) ; return new ( tree . Variable ) ( name , index , fileInfo ) ; } parserInput . restore ( ) ; }
526	function ( string ) { var self = this ; return String ( string ) . replace ( / [&<>'\/] / g , function ( s ) { return self . entityMap [ s ] ; } ) ; }
1208	function ( elementToChange ) { var that = this , firstField = this . container . querySelector ( SELECTOR_FORM_ELEMENTS ) ; this . elementToChange = elementToChange ; this . _observe ( ) ; this . _interpolate ( ) ; if ( elementToChange ) { this . interval = setInterval ( function ( ) { that . _interpolate ( true ) ; } , 500 ) ; } dom . addClass ( this . link , CLASS_NAME_OPENED ) ; this . container . style . display = "" ; this . fire ( "show" ) ; if ( firstField && ! elementToChange ) { try { firstField . focus ( ) ; } catch ( e ) { } } }
80	function findElements ( ) { try { this . elements . controls = getElement . call ( this , this . config . selectors . controls . wrapper ) ; this . elements . buttons = { play : getElements . call ( this , this . config . selectors . buttons . play ) , pause : getElement . call ( this , this . config . selectors . buttons . pause ) , restart : getElement . call ( this , this . config . selectors . buttons . restart ) , rewind : getElement . call ( this , this . config . selectors . buttons . rewind ) , fastForward : getElement . call ( this , this . config . selectors . buttons . fastForward ) , mute : getElement . call ( this , this . config . selectors . buttons . mute ) , pip : getElement . call ( this , this . config . selectors . buttons . pip ) , airplay : getElement . call ( this , this . config . selectors . buttons . airplay ) , settings : getElement . call ( this , this . config . selectors . buttons . settings ) , captions : getElement . call ( this , this . config . selectors . buttons . captions ) , fullscreen : getElement . call ( this , this . config . selectors . buttons . fullscreen ) } ; this . elements . progress = getElement . call ( this , this . config . selectors . progress ) ; this . elements . inputs = { seek : getElement . call ( this , this . config . selectors . inputs . seek ) , volume : getElement . call ( this , this . config . selectors . inputs . volume ) } ; this . elements . display = { buffer : getElement . call ( this , this . config . selectors . display . buffer ) , currentTime : getElement . call ( this , this . config . selectors . display . currentTime ) , duration : getElement . call ( this , this . config . selectors . display . duration ) } ; if ( is$1 . element ( this . elements . progress ) ) { this . elements . display . seekTooltip = this . elements . progress . querySelector ( "." . concat ( this . config . classNames . tooltip ) ) ; } return true ; } catch ( error ) { this . debug . warn ( 'It looks like there is a problem with your custom controls HTML' , error ) ; this . toggleNativeControls ( true ) ; return false ; } }
1585	function toHexString ( num ) { var str = num . toString ( 16 ) ; while ( str . length < 2 ) { str = '0' + str ; } return str ; }
1518	function computeNodeLinks ( graph ) { graph . nodes . forEach ( function ( node , i ) { node . index = i node . sourceLinks = [ ] node . targetLinks = [ ] } ) var nodeById = map ( graph . nodes , id ) graph . links . forEach ( function ( link , i ) { link . index = i var source = link . source var target = link . target if ( typeof source !== 'object' ) { source = link . source = find ( nodeById , source ) } if ( typeof target !== 'object' ) { target = link . target = find ( nodeById , target ) } source . sourceLinks . push ( link ) target . targetLinks . push ( link ) } ) return graph }
2562	function ( ) { var ccId , proto = getProto ( this ) , cId = proto . constructor . __get_protolib_id__ , lib = { } , i = 0 , last = null , m ; currentThis = this ; do { ccId = proto . constructor . __get_protolib_id__ ; if ( cached [ ccId ] && i === 0 ) { return cached [ ccId ] ; } else if ( cached [ ccId ] ) { for ( m in cached [ ccId ] ) if ( cached [ ccId ] . hasOwnProperty ( m ) ) lib [ m ] = cached [ ccId ] [ m ] ; if ( ! inheritanceChain [ cId ] ) inheritanceChain [ cId ] = [ ] ; inheritanceChain [ cId ] = inheritanceChain [ ccId ] . concat ( inheritanceChain [ cId ] ) ; cached [ cId ] = lib ; return lib ; } else { if ( ! libp [ ccId ] ) libp [ ccId ] = { } ; for ( m in libp [ ccId ] ) if ( libp [ ccId ] . hasOwnProperty ( m ) ) lib [ m ] = libp [ ccId ] [ m ] ; if ( ! inheritanceChain [ ccId ] ) inheritanceChain [ ccId ] = [ ] ; inheritanceChain [ cId ] . unshift ( ccId ) ; cached [ cId ] = lib ; last = ccId ; } ++ i ; } while ( proto = getProto ( proto ) ) ; lib . __protolib_cId__ = cId ; return lib ; }
2425	function ( A ) { var z = numeric . svd ( A ) , foo = z . S [ 0 ] ; var U = z . U , S = z . S , V = z . V ; var m = A . length , n = A [ 0 ] . length , tol = Math . max ( m , n ) * numeric . epsilon * foo , M = S . length ; var Sinv = new Array ( M ) ; for ( var i = M - 1 ; i !== - 1 ; i -- ) { if ( S [ i ] > tol ) Sinv [ i ] = 1 / S [ i ] ; else Sinv [ i ] = 0 ; } return numeric . dot ( numeric . dot ( V , numeric . diag ( Sinv ) ) , numeric . transpose ( U ) ) }
87	function updateVolume ( ) { if ( ! this . supported . ui ) { return ; } if ( is$1 . element ( this . elements . inputs . volume ) ) { controls . setRange . call ( this , this . elements . inputs . volume , this . muted ? 0 : this . volume ) ; } if ( is$1 . element ( this . elements . buttons . mute ) ) { this . elements . buttons . mute . pressed = this . muted || this . volume === 0 ; } }
2555	function mapCacheSet$3 ( key , value ) { var data = _getMapData ( this , key ) , size = data . size ; data . set ( key , value ) ; this . size += data . size == size ? 0 : 1 ; return this ; }
1342	function use ( name ) { if ( name === undefined ) { if ( queue . length === 0 ) { throw new Error ( 'No algorithm installed.' ) ; } name = queue [ queue . length - 1 ] ; } else if ( typeof name !== 'string' || name === '' ) { throw new TypeError ( 'The algorithm name must be an non-empty string.' ) ; } const hashFunc = funcs [ name ] ; if ( ! hashFunc ) { throw new TypeError ( ` ${ name } ` ) ; } return hashFunc ; }
3880	function flatMap ( mapper ) { return function ( maybe ) { for ( const value of maybe ) { return mapper ( value ) ; } return maybe_1 . nothing ( ) ; } ; }
3454	function ( ) { var me = this ; if ( me . fireEvent ( 'beforedestroy' , me ) !== false ) { me . remove ( ) ; me . surface . onDestroy ( me ) ; me . clearListeners ( ) ; me . fireEvent ( 'destroy' ) ; } }
1534	function ( options , callback ) { if ( _ . isFunction ( options ) && ! callback ) { callback = options ; options = { } ; } options = _ . clone ( options ) ; bootcode ( function ( err , code ) { if ( err ) { return callback ( err ) ; } if ( ! code ) { return callback ( new Error ( 'sandbox: bootcode missing!' ) ) ; } options . bootCode = code ; PostmanSandbox . create ( options , callback ) ; } ) ; }
3565	function ( keyOrNsKey , value ) { var self = this ; if ( sjl . isObject ( keyOrNsKey ) ) { sjl . extend . apply ( sjl , [ true , self ] . concat ( sjl . argsToArray ( arguments ) ) ) ; } else if ( sjl . isString ( keyOrNsKey ) ) { sjl . autoNamespace ( keyOrNsKey , self , value ) ; } else if ( sjl . isset ( keyOrNsKey ) ) { throw new TypeError ( contextName + '.set only allows strings or objects as it\'s first parameter. ' + \' + 'Param type received: `' + sjl . classOf ( keyOrNsKey ) ) ; } '`.' }
1028	function ( path ) { var url = 'https://api.dropboxapi.com/2/files/list_folder' ; var revCache = this . _revCache ; var self = this ; var processResponse = function ( resp ) { var body , listing ; if ( resp . status !== 200 && resp . status !== 409 ) { return Promise . reject ( 'Unexpected response status: ' + resp . status ) ; } try { body = JSON . parse ( resp . responseText ) ; } catch ( e ) { return Promise . reject ( e ) ; } if ( resp . status === 409 ) { if ( compareApiError ( body , [ 'path' , 'not_found' ] ) ) { return Promise . resolve ( { } ) ; } return Promise . reject ( new Error ( 'API returned an error: ' + body . error_summary ) ) ; } listing = body . entries . reduce ( function ( map , item ) { var isDir = item [ '.tag' ] === 'folder' ; var itemName = item . path_lower . split ( '/' ) . slice ( - 1 ) [ 0 ] + ( isDir ? '/' : '' ) ; if ( isDir ) { map [ itemName ] = { ETag : revCache . get ( path + itemName ) } ; } else { map [ itemName ] = { ETag : item . rev } ; self . _revCache . set ( path + itemName , item . rev ) ; } return map ; } , { } ) ; if ( body . has_more ) { return loadNext ( body . cursor ) . then ( function ( nextListing ) { return Object . assign ( listing , nextListing ) ; } ) ; } return Promise . resolve ( listing ) ; } ; const loadNext = function ( cursor ) { const continueURL = 'https://api.dropboxapi.com/2/files/list_folder/continue' ; const params = { body : { cursor : cursor } } ; return self . _request ( 'POST' , continueURL , params ) . then ( processResponse ) ; } ; return this . _request ( 'POST' , url , { body : { path : getDropboxPath ( path ) } } ) . then ( processResponse ) . then ( function ( listing ) { return Promise . resolve ( { statusCode : 200 , body : listing , contentType : 'application/json; charset=UTF-8' , revision : revCache . get ( path ) } ) ; } ) ; }
2661	function smsGetListCampaigns ( callback , date_from , date_to ) { var data = { 'dateFrom' : date_from , 'dateTo' : date_to } sendRequest ( 'sms/campaigns/list' , 'GET' , data , true , callback ) ; }
2492	function buf2hex ( buffer , options = { prefix : true } ) { var hex = Array . prototype . map . call ( new Uint8Array ( buffer ) , x => ( '00' + x . toString ( 16 ) ) . slice ( - 2 ) ) . join ( '' ) ; return options . prefix === true ? ` ${ hex } ` : hex ; }
92	function durationUpdate ( ) { if ( ! this . supported . ui || ! this . config . invertTime && this . currentTime ) { return ; } if ( this . duration >= Math . pow ( 2 , 32 ) ) { toggleHidden ( this . elements . display . currentTime , true ) ; toggleHidden ( this . elements . progress , true ) ; return ; } if ( is$1 . element ( this . elements . inputs . seek ) ) { this . elements . inputs . seek . setAttribute ( 'aria-valuemax' , this . duration ) ; } var hasDuration = is$1 . element ( this . elements . display . duration ) ; if ( ! hasDuration && this . config . displayDuration && this . paused ) { controls . updateTimeDisplay . call ( this , this . elements . display . currentTime , this . duration ) ; } if ( hasDuration ) { controls . updateTimeDisplay . call ( this , this . elements . display . duration , this . duration ) ; } controls . updateSeekTooltip . call ( this ) ; }
1803	function ( input , it ) { var output = input ; var expr ; while ( ( expr = this . getExpr ( output ) ) !== null ) { var evalsTo = $parse ( expr . expr ) ( { it : it } ) ; output = output . substring ( 0 , expr . start ) + evalsTo + output . substring ( expr . stop + 1 ) ; } return output ; }
3504	function isFirstArrayElementOnSameLine ( node ) { if ( node . type === "ArrayExpression" && node . elements [ 0 ] ) { return node . elements [ 0 ] . loc . start . line === node . loc . start . line && node . elements [ 0 ] . type === "ObjectExpression" ; } else { return false ; } }
752	function loadAndParseFile ( filename , settings , nextFile ) { if ( settings . debug ) { debug ( 'loadAndParseFile(\'' + \' + filename ) ; '\')' \' } debug ( 'totalFiles: ' + settings . totalFiles ) ; }
511	function runBlock ( cb ) { self . runBlock ( { block : block , root : parentState } , function ( err , results ) { if ( err ) { blockchain . delBlock ( block . header . hash ( ) , function ( ) { cb ( err ) } ) } else { headBlock = block cb ( ) } } ) }
3640	function ( key ) { var str = this . loadVar ( key ) ; if ( typeof ( str ) != 'string' ) { exitProcess ( 'the value of ' + key + ' is a necessary string, but get ' + str , this . alarm ) ; return false ; } return str ; }
2502	function ( partialPath , locals ) { var normalizedPartialPath = normalizeTemplatePath ( partialPath , path . dirname ( normalizedTemplatePath ) ) ; return exports . compile ( normalizedPartialPath ) ( locals ) ; }
2002	function listenSelector ( selector , type , callback ) { return delegate_1 ( document . body , selector , type , callback ) ; }
1686	function _contextNext ( ) { if ( ! this . _contextState . nextSequence ) { return undefined ; } if ( this . _context . reverse ) { this . _contextState . nextSequence = this . _contextState . nextSequence . getNext ( ) ; if ( ! this . _contextState . nextSequence ) { return undefined ; } } var renderNode = this . _contextState . nextSequence . get ( ) ; if ( ! renderNode ) { this . _contextState . nextSequence = undefined ; return undefined ; } var nextSequence = this . _contextState . nextSequence ; if ( ! this . _context . reverse ) { this . _contextState . nextSequence = this . _contextState . nextSequence . getNext ( ) ; } if ( this . _contextState . lastRenderNode === renderNode ) { throw 'ViewSequence is corrupted, should never contain the same renderNode twice, index: ' + nextSequence . getIndex ( ) ; } this . _contextState . lastRenderNode = renderNode ; return { renderNode : renderNode , viewSequence : nextSequence , next : true , index : ++ this . _contextState . nextGetIndex } ; }
2768	function ExpressView ( view ) { this . render = ( options , callback ) => { const variables = { ... options . _locals , ... options } ; callback ( null , view ( variables ) ) ; } ; this . path = view . id ; }
741	function safeExec ( cmd , cb ) { try { utils . _exec ( cmd , cb ) ; } catch ( e ) { cb ( e , null ) ; } }
3656	function assert ( that , success , actualValue , expectedValue , type , functionName , lineInfo , stackIncrease ) { if ( ! stackIncrease ) stackIncrease = 1 if ( ! functionName ) functionName = "ok" if ( ! lineInfo ) var lineInfoFuture = getLineInformation ( functionName , stackIncrease , that . doSourcemappery , that . warningHandler ) else var lineInfoFuture = Future ( lineInfo ) var cur = that while ( cur !== undefined ) { setTesterTimeout ( cur ) cur = cur . parentTester } var emitData = lineInfoFuture . then ( function ( lineInfo ) { var result = lineInfo result . type = 'assert' if ( type !== 'count' ) result . success = success === true if ( actualValue !== undefined ) result . actual = actualValue if ( expectedValue !== undefined ) result . expected = expectedValue result . parent = that . id result . time = now ( ) return Future ( result ) } ) return that . manager . emit ( type , emitData ) }
570	function ( vertex ) { if ( this . head === null ) { this . head = vertex ; } else { this . tail . next = vertex ; } vertex . prev = this . tail ; vertex . next = null ; this . tail = vertex ; return this ; }
2922	function processFile ( file , cb ) { var data = dataSource ( file ) ; return pickTemplate ( forcedTemplateName || getTemplateName ( data ) || defaultTemplateName ) . then ( function ( template ) { file . path = replaceExt ( file . path , '.html' ) ; data . _file = file ; data . _target = { path : file . path , relative : replaceExt ( file . relative , '.html' ) , } ; var result = template . render ( data ) ; file . contents = new Buffer ( result , 'utf-8' ) ; return file ; } ) ; }
2167	function correctHorizontalAlignment ( ) { var dropdown = elements . scrollContainer . getBoundingClientRect ( ) , styles = { } ; if ( dropdown . right > root . right - MENU_PADDING ) { styles . left = ( hrect . right - dropdown . width ) + 'px' ; } elements . $ . scrollContainer . css ( styles ) ; }
202	function loadCSS ( cssUrl , currentLink ) { return new Promise ( resolve => { const link = document . createElement ( 'link' ) ; link . rel = 'stylesheet' ; link . type = 'text/css' ; link . href = cssUrl ; if ( 'onload' in link ) { link . onload = ( ) => { link . onload = null ; resolve ( link ) ; } ; } else { setTimeout ( ( ) => resolve ( link ) , 500 ) ; } document . head . insertBefore ( link , currentLink ? currentLink . nextSibling : null ) ; } ) ; }
1625	function parse_status_block ( block ) { var match ; if ( ! block ) return ; var parsed = { interface : block . match ( / ^([^\s]+) / ) [ 1 ] } ; if ( ( match = block . match ( / Access Point:\s*([A-Fa-f0-9:]{17}) / ) ) ) { parsed . access_point = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = block . match ( / Frequency[:|=]\s*([0-9\.]+) / ) ) ) { parsed . frequency = parseFloat ( match [ 1 ] ) ; } if ( ( match = block . match ( / IEEE\s*([^\s]+) / ) ) ) { parsed . ieee = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = block . match ( / Mode[:|=]\s*([^\s]+) / ) ) ) { parsed . mode = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = block . match ( / Noise level[:|=]\s*(-?[0-9]+) / ) ) ) { parsed . noise = parseInt ( match [ 1 ] , 10 ) ; } if ( ( match = block . match ( / Link Quality[:|=]\s*([0-9]+) / ) ) ) { parsed . quality = parseInt ( match [ 1 ] , 10 ) ; } if ( ( match = block . match ( / Sensitivity[:|=]\s*([0-9]+) / ) ) ) { parsed . sensitivity = parseInt ( match [ 1 ] , 10 ) ; } if ( ( match = block . match ( / Signal level[:|=]\s*(-?[0-9]+) / ) ) ) { parsed . signal = parseInt ( match [ 1 ] , 10 ) ; } if ( ( match = block . match ( / ESSID[:|=]\s*"([^"]+)" / ) ) ) { parsed . ssid = match [ 1 ] ; } if ( ( match = block . match ( / unassociated / ) ) ) { parsed . unassociated = true ; } return parsed ; }
2984	function ( scContent ) { if ( _ . isEmpty ( scContent [ 'data' ] ) ) { return ; } let columns = [ ] ; if ( scContent [ 'columns' ] ) { columns = scContent [ 'columns' ] ; } else { let model = this . _modelInfo ( scContent [ 'forModel' ] ) ; _ . forEach ( _ . head ( scContent [ 'data' ] ) , function ( value , key ) { if ( ! model . prop [ key ] || model . prop [ key ] [ 'id' ] ) { return ; } columns . push ( { title : key . replace ( model . ns , '' ) , data : key } ) ; } ) ; } return columns ; }
3401	function updateLinkSetOnLoad ( linkSet , load ) { console . assert ( load . status == 'loaded' || load . status == 'linked' , 'loaded or linked' ) ; linkSet . loadingCount -- ; if ( linkSet . loadingCount > 0 ) return ; var startingLoad = linkSet . loads [ 0 ] ; try { link ( linkSet ) ; } catch ( exc ) { return linkSetFailed ( linkSet , exc ) ; } console . assert ( linkSet . loads . length == 0 , 'loads cleared' ) ; linkSet . resolve ( startingLoad ) ; }
1716	function _initShowAnimation ( item , prevItem , size ) { var spec = item . options . show . animation ? item . options . show . animation . call ( undefined , true , size ) : { } ; item . startSpec = spec ; item . endSpec = { opacity : 1 , transform : Transform . identity } ; item . mod . halt ( ) ; if ( spec . transform ) { item . mod . setTransform ( spec . transform ) ; } if ( spec . opacity !== undefined ) { item . mod . setOpacity ( spec . opacity ) ; } if ( spec . align ) { item . mod . setAlign ( spec . align ) ; } if ( spec . origin ) { item . mod . setOrigin ( spec . origin ) ; } var startShowAnimation = _startShowAnimation . bind ( this , item , spec ) ; var waitAndShow = item . wait ? function ( ) { item . wait . then ( startShowAnimation , startShowAnimation ) ; } : startShowAnimation ; if ( prevItem ) { _initTransferableAnimations . call ( this , item , prevItem , waitAndShow ) ; } else { waitAndShow ( ) ; } }
2282	function addInterfaceMethod ( interfaceName , funcName , fN ) { if ( Steam . INTERFACES [ interfaceName ] === undefined ) { Steam . INTERFACES [ interfaceName ] = { } ; } Steam . INTERFACES [ interfaceName ] [ funcName ] = fN ; var name = funcName . substr ( 0 , 1 ) . toLowerCase ( ) + funcName . substr ( 1 ) ; if ( ! isMultiGameInterface ( interfaceName ) ) { steam [ name ] = fN ; } else { if ( steam [ name ] !== undefined ) return ; var multi_interface_name = interfaceName . split ( '_' ) [ 0 ] ; steam [ name ] = function ( steamObj , callback ) { var gameid = get ( this , steamObj , 'gameid' ) ; var interface_name = multi_interface_name + '_' + gameid ; Steam . INTERFACES [ interface_name ] [ funcName ] . call ( this , steamObj , callback ) ; } ; } }
55	function once ( element ) { var _this2 = this ; var events = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : '' ; var callback = arguments . length > 2 ? arguments [ 2 ] : undefined ; var passive = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : true ; var capture = arguments . length > 4 && arguments [ 4 ] !== undefined ? arguments [ 4 ] : false ; var onceCallback = function onceCallback ( ) { off ( element , events , onceCallback , passive , capture ) ; for ( var _len = arguments . length , args = new Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } callback . apply ( _this2 , args ) ; } ; toggleListener . call ( this , element , events , onceCallback , true , passive , capture ) ; }
1121	function getAutoscaleProcessCount ( ) { const actions = 'cluster-action update|-c update|cluster-action join|-c join' ; const grepCommand = ` ${ actions } ` ; return util . getProcessCount ( grepCommand ) . then ( ( response ) => { return q ( response ) ; } ) . catch ( ( err ) => { logger . error ( 'Could not determine if another autoscale script is running' ) ; return q . reject ( err ) ; } ) ; }
3443	function moveSelection ( ) { var nonEditableStart , nonEditableEnd , isCollapsed , rng , element ; function hasSideContent ( element , left ) { var container , offset , walker , node , len ; container = rng . startContainer ; offset = rng . startOffset ; if ( container . nodeType == 3 ) { len = container . nodeValue . length ; if ( ( offset > 0 && offset < len ) || ( left ? offset == len : offset == 0 ) ) { return ; } } else { if ( offset < container . childNodes . length ) { var pos = ! left && offset > 0 ? offset - 1 : offset ; container = container . childNodes [ pos ] ; if ( container . hasChildNodes ( ) ) { container = container . firstChild ; } } else { return ! left ? element : null ; } } walker = new TreeWalker ( container , element ) ; while ( node = walker [ left ? 'prev' : 'next' ] ( ) ) { if ( node . nodeType === 3 && node . nodeValue . length > 0 ) { return ; } else if ( getContentEditable ( node ) === "true" ) { return node ; } } return element ; } ; removeCaretContainer ( ) ; isCollapsed = selection . isCollapsed ( ) ; nonEditableStart = getNonEditableParent ( selection . getStart ( ) ) ; nonEditableEnd = getNonEditableParent ( selection . getEnd ( ) ) ; if ( nonEditableStart || nonEditableEnd ) { rng = selection . getRng ( true ) ; if ( isCollapsed ) { nonEditableStart = nonEditableStart || nonEditableEnd ; var start = selection . getStart ( ) ; if ( element = hasSideContent ( nonEditableStart , true ) ) { insertCaretContainerOrExpandToBlock ( element , true ) ; } else if ( element = hasSideContent ( nonEditableStart , false ) ) { insertCaretContainerOrExpandToBlock ( element , false ) ; } else { selection . select ( nonEditableStart ) ; } } else { rng = selection . getRng ( true ) ; if ( nonEditableStart ) { rng . setStartBefore ( nonEditableStart ) ; } if ( nonEditableEnd ) { rng . setEndAfter ( nonEditableEnd ) ; } selection . setRng ( rng ) ; } } }
346	function lastNonWhitespace ( ) { var p = chars . length - 1 ; while ( p >= 0 ) { var pp = chars [ p ] ; if ( ! isWhiteSpace ( pp ) ) { return pp ; } p -- ; } return '' ; }
1335	function alt ( first , ... fragments ) { for ( let fragment of fragments ) { first = altPair ( first , fragment ) ; } return first ; }
565	function ( eyeVertex , horizonEdge ) { var face = Face . create ( eyeVertex , horizonEdge . tail ( ) , horizonEdge . head ( ) ) ; this . faces . push ( face ) ; face . getEdge ( - 1 ) . setTwin ( horizonEdge . twin ) ; return face . getEdge ( 0 ) ; }
810	function normalizeError ( err ) { if ( err instanceof Error ) { return _ . pickBy ( { message : err . message , stack : err . stack , } , val => ! _ . isEmpty ( val ) ) ; } if ( err && err . status && err . response ) { return { response : { status : err . status , responseText : _ . truncate ( _ . trimStart ( err . response ? err . response . text : "<no response body>" ) , 200 ) , } , } } return err ; }
1124	function markVersions ( instances ) { let highestVersion = '0.0.0' ; let instance ; Object . keys ( instances ) . forEach ( ( instanceId ) => { instance = instances [ instanceId ] ; if ( instance . version && util . versionCompare ( instance . version , highestVersion ) > 0 ) { highestVersion = instance . version ; } } ) ; Object . keys ( instances ) . forEach ( ( instanceId ) => { instance = instances [ instanceId ] ; if ( ! instance . version || util . versionCompare ( instance . version , highestVersion ) === 0 ) { instance . versionOk = true ; } else { instance . versionOk = false ; } } ) ; }
3045	function ( uuid ) { if ( ! uuid . match ( UUID . rvalid ) ) { return false ; } var hex = uuid . replace ( / [\-{}] / g , '' ) ; var bin = '' ; for ( var i = 0 ; i < hex . length ; i += 2 ) { bin += String . fromCharCode ( parseInt ( hex . charAt ( i ) + hex . charAt ( i + 1 ) , 16 ) ) ; } return bin ; }
2870	function createListBoxMixin ( { id , field } ) { return this . createObject ( { qInfo : { qType : 'ListObject' } , qListObjectDef : { qStateName : '$' , qLibraryId : undef . if ( id , '' ) , qDef : { qFieldDefs : undef . if ( field , [ field ] , [ ] ) } , qInitialDataFetch : [ { qTop : 0 , qLeft : 0 , qHeight : 5 , qWidth : 1 } ] } } ) . then ( ( object ) => { return object . getLayout ( ) ; } ) }
3016	function ( ) { var hash = new this . self ( this . initialConfig ) , map = this . map , key ; hash . suspendEvents ( ) ; for ( key in map ) { if ( map . hasOwnProperty ( key ) ) { hash . add ( key , map [ key ] ) ; } } hash . resumeEvents ( ) ; return hash ; }
1464	async function ( ) { if ( ! this . __mtime ) { return this . read ( ) ; } var poFile = this . getPoFilename ( ) ; let stat = await qx . tool . compiler . files . Utils . safeStat ( poFile ) ; if ( stat && this . __mtime == stat . mtime ) { return undefined ; } return this . read ( ) ; }
3240	function ( el ) { var styles = [ 'transitionProperty' , 'WebkitTransitionProperty' , 'MozTransitionProperty' , 'OTransitionProperty' , 'msTransitionProperty' , 'KhtmlTransitionProperty' ] ; var style = el . dom . style ; for ( var i = 0 , length = styles . length ; i < length ; ++ i ) { if ( style [ styles [ i ] ] !== 'undefined' ) { return true ; } } return false ; }
2057	function ( toolKey , _newTool ) { var _this = this ; angular . forEach ( toolbars , function ( toolbarScope , toolbarKey ) { _this . updateToolbarToolDisplay ( toolbarKey , toolKey , _newTool ) ; } ) ; }
2709	function ( view , offset , length ) { var trmOffset = lib . locateStrTrm . ucs ( view , offset , length ) ; if ( trmOffset !== - 1 ) { length = trmOffset - offset ; } return lib . readStr . ucs ( view , offset , length ) ; }
400	function init ( files , options , callback ) { if ( _ . isFunction ( options ) ) { callback = options ; options = { } ; } else if ( ! _ . isFunction ( callback ) ) { throw new TypeError ( 'UnCSS: expected a callback' ) ; } if ( options . uncssrc ) { try { options = _ . merge ( utility . parseUncssrc ( options . uncssrc ) , options ) ; } catch ( err ) { if ( err instanceof SyntaxError ) { callback ( new SyntaxError ( 'UnCSS: uncssrc file is invalid JSON.' ) ) ; return ; } callback ( err ) ; return ; } } options = _ . defaults ( options , { csspath : '' , ignore : [ ] , media : [ ] , timeout : 0 , report : false , ignoreSheets : [ ] , html : files , banner : true , raw : null , userAgent : 'uncss' , inject : null } ) ; process ( options ) . then ( ( [ css , report ] ) => callback ( null , css , report ) , callback ) ; }
151	function setLoading ( state , params , newStatus ) { const queries = ( state . queries && { ... state . queries } ) || { } ; const key = getSerializedProductsQuery ( params ) ; queries [ key ] = { ... ( queries [ key ] || { } ) , isLoading : newStatus } ; return queries ; }
1793	function ( callback , verbose , updateOptions , startOptions ) { log ( PLUGIN_NAME + ' - Webdriver standalone will be updated' ) ; return new Promise ( ( resolve ) => { this . webDriverUpdate ( updateOptions , ( ) => { log ( PLUGIN_NAME + ' - Webdriver standalone is updated' ) ; resolve ( this . webDriverStandaloneStart ( callback , verbose , startOptions ) ) ; } ) ; } ) ; }
1006	function ( path ) { if ( this . _rootPaths [ path ] !== undefined ) { return this . _rootPaths [ path ] ; } else if ( path === '/' ) { return 'SEEN' ; } else { return this . checkPath ( containingFolder ( path ) ) ; } }
371	function writeModules ( pluginConfig , outputConfig , entryModules ) { const indexHTML = getOutputHTML ( outputConfig . dir ) ; const head = query ( indexHTML , predicates . hasTagName ( 'head' ) ) ; const body = query ( indexHTML , predicates . hasTagName ( 'body' ) ) ; if ( pluginConfig . polyfillDynamicImports ) { append ( body , createScriptModule ( 'window.importModule=src=>import(src);' ) ) ; append ( body , createScriptModule ( ` \` \$ \` ${ entryModules . map ( src => ` ${ src } ` ) . join ( '' ) } ` ) , ) ; entryModules . forEach ( src => { append ( head , createElement ( 'link' , { rel : 'preload' , as : 'script' , crossorigin : 'anonymous' , href : src , } ) , ) ; } ) ; } else { entryModules . forEach ( src => { append ( body , createScript ( { type : 'module' , src } ) ) ; } ) ; } writeOutputHTML ( outputConfig . dir , indexHTML ) ; }
2710	function Mailto ( form , options ) { this . form = null ; this . preventDefault = true ; this . formatter = Mailto . defaultFormatter ; this . onSubmit = function ( m ) { } ; this . initFormObject ( form ) ; this . initOptions ( options ) ; this . initFormHandler ( ) ; }
1980	function encode ( ) { var data = this . data ; var length = 11 ; var sender = this . sender ; var target = this . target ; var header = new Buffer ( 9 ) ; var content = ! data || isBuffer ( data ) ? data : this . encode ( data ) ; if ( content ) length += content . length ; header . writeUInt8 ( length , 0 ) ; header . writeUInt8 ( sender . subnet , 1 ) ; header . writeUInt8 ( sender . id , 2 ) ; header . writeUInt16BE ( sender . type , 3 ) ; header . writeUInt16BE ( this . code , 5 ) ; header . writeUInt8 ( target . subnet , 7 ) ; header . writeUInt8 ( target . id , 8 ) ; return content ? Buffer . concat ( [ header , content ] ) : header ; }
2327	function ( input ) { var srcEvent = input . srcEvent ; var direction = input . offsetDirection ; if ( this . manager . session . prevented ) { srcEvent . preventDefault ( ) ; return ; } var actions = this . actions ; var hasNone = inStr ( actions , TOUCH_ACTION_NONE ) && ! TOUCH_ACTION_MAP [ TOUCH_ACTION_NONE ] ; var hasPanY = inStr ( actions , TOUCH_ACTION_PAN_Y ) && ! TOUCH_ACTION_MAP [ TOUCH_ACTION_PAN_Y ] ; var hasPanX = inStr ( actions , TOUCH_ACTION_PAN_X ) && ! TOUCH_ACTION_MAP [ TOUCH_ACTION_PAN_X ] ; if ( hasNone ) { var isTapPointer = input . pointers . length === 1 ; var isTapMovement = input . distance < 2 ; var isTapTouchTime = input . deltaTime < 250 ; if ( isTapPointer && isTapMovement && isTapTouchTime ) { return ; } } if ( hasPanX && hasPanY ) { return ; } if ( hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL ) { return this . preventSrc ( srcEvent ) ; } }
97	function setSpeedMenu ( options ) { var _this8 = this ; if ( ! is$1 . element ( this . elements . settings . panels . speed ) ) { return ; } var type = 'speed' ; var list = this . elements . settings . panels . speed . querySelector ( '[role="menu"]' ) ; if ( is$1 . array ( options ) ) { this . options . speed = options ; } else if ( this . isHTML5 || this . isVimeo ) { this . options . speed = [ 0.5 , 0.75 , 1 , 1.25 , 1.5 , 1.75 , 2 ] ; } this . options . speed = this . options . speed . filter ( function ( speed ) { return _this8 . config . speed . options . includes ( speed ) ; } ) ; var toggle = ! is$1 . empty ( this . options . speed ) && this . options . speed . length > 1 ; controls . toggleMenuButton . call ( this , type , toggle ) ; emptyElement ( list ) ; controls . checkMenu . call ( this ) ; if ( ! toggle ) { return ; } this . options . speed . forEach ( function ( speed ) { controls . createMenuItem . call ( _this8 , { value : speed , list : list , type : type , title : controls . getLabel . call ( _this8 , 'speed' , speed ) } ) ; } ) ; controls . updateSetting . call ( this , type , list ) ; }
3847	function populateLabels ( labelTemplateString , labels , numberOfSteps , graphMin , stepValue ) { if ( labelTemplateString ) { for ( var i = 1 ; i < numberOfSteps + 1 ; i ++ ) { labels . push ( tmpl ( labelTemplateString , { value : ( graphMin + ( stepValue * i ) ) . toFixed ( getDecimalPlaces ( stepValue ) ) } ) ) ; } } }
3014	function ( key ) { var me = this , value ; if ( me . containsKey ( key ) ) { value = me . map [ key ] ; delete me . map [ key ] ; -- me . length ; if ( me . hasListeners . remove ) { me . fireEvent ( 'remove' , me , key , value ) ; } return true ; } return false ; }
276	function getEligibleGSuiteDomain ( selectedDomainName , domains ) { if ( selectedDomainName && canDomainAddGSuite ( selectedDomainName ) ) { return selectedDomainName ; } const [ eligibleDomain ] = getGSuiteSupportedDomains ( domains ) ; return ( eligibleDomain && eligibleDomain . name ) || '' ; }
96	function getBadge ( quality ) { var label = i18n . get ( "qualityBadge." . concat ( quality ) , _this6 . config ) ; if ( ! label . length ) { return null ; } return controls . createBadge . call ( _this6 , label ) ; }
1111	function processProps ( props ) { const { title , label , key , value } = props ; const cloneProps = { ... props } ; if ( label && ! title ) { if ( ! warnDeprecatedLabel ) { warning ( false , "'label' in treeData is deprecated. Please use 'title' instead." ) ; warnDeprecatedLabel = true ; } cloneProps . title = label ; } if ( ! key ) { cloneProps . key = value ; } return cloneProps ; }
2884	function middleware ( file , options ) { var matcher = new RegExp ( "\\.(?:" + \\ + middleware . extensions . join ( "|" ) ) ")$" if ( ! matcher . test ( file ) ) return through ( ) ; var input = '' ; var write = function ( buffer ) { input += buffer ; } var end = function ( ) { this . queue ( createModule ( input , options ) ) ; this . queue ( null ) ; } }
1855	function ( abbr , syntax , profile , contextNode ) { if ( ! abbr ) return '' ; syntax = syntax || defaultSyntax ; var filters = r ( 'filters' ) ; var parser = r ( 'abbreviationParser' ) ; profile = r ( 'profile' ) . get ( profile , syntax ) ; r ( 'tabStops' ) . resetTabstopIndex ( ) ; var data = filters . extractFromAbbreviation ( abbr ) ; var outputTree = parser . parse ( data [ 0 ] , { syntax : syntax , contextNode : contextNode } ) ; var filtersList = filters . composeList ( syntax , profile , data [ 1 ] ) ; filters . apply ( outputTree , filtersList , profile ) ; return outputTree . toString ( ) ; }
2988	function ( modMeth , filter , cb = ( err , val , cb ) => cb ( ) ) { this . promises . push ( new Promise ( ( resolve , reject ) => { modMeth ( ... filter , ( err , val ) => { cb ( err , val , resolve ) ; } ) ; } ) ) ; }
1643	function ( ) { var self = this ; console . log ( 'clearing...' ) ; var req = get_req ( ) ; req . onreadystatechange = function clear_state_response ( ) { if ( req . readyState === 4 ) { htracr . ui . clear ( ) ; } } ; req . open ( "POST" , "/clear" , true ) ; req . send ( "" ) ; return false ; }
2426	function ( A ) { var AT = numeric . transpose ( A ) ; return numeric . dot ( numeric . inv ( numeric . dot ( AT , A ) ) , AT ) ; }
1191	function ( props ) { var inst , cls = this , key = props [ cls . keyAttr ] ; if ( key && _ . has ( cls . cache , key ) ) { inst = cls . cache [ key ] ; inst . merge ( props ) ; } else { inst = new cls ( props ) ; if ( key ) { cls . cache [ key ] = inst ; } inst . on ( "change:" + cls . keyAttr , function ( model , key ) { var oldKey = model . previous ( cls . keyAttr ) ; if ( oldKey && _ . has ( cls . cache , oldKey ) ) { delete cls . cache [ oldKey ] ; } cls . cache [ key ] = inst ; } ) ; } return inst ; }
131	function clamp ( ) { var input = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : 0 ; var min = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 0 ; var max = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : 255 ; return Math . min ( Math . max ( input , min ) , max ) ; }
1012	function ( path , body , contentType , options ) { const fullPath = googleDrivePath ( path ) ; function putDone ( response ) { if ( response . status >= 200 && response . status < 300 ) { const meta = JSON . parse ( response . responseText ) ; const etagWithoutQuotes = removeQuotes ( meta . etag ) ; return Promise . resolve ( { statusCode : 200 , contentType : meta . mimeType , revision : etagWithoutQuotes } ) ; } else if ( response . status === 412 ) { return Promise . resolve ( { statusCode : 412 , revision : 'conflict' } ) ; } else { return Promise . reject ( "PUT failed with status " + response . status + " (" + response . responseText + ")" ) ; } } return this . _getFileId ( fullPath ) . then ( ( id ) => { if ( id ) { if ( options && ( options . ifNoneMatch === '*' ) ) { return putDone ( { status : 412 } ) ; } return this . _updateFile ( id , fullPath , body , contentType , options ) . then ( putDone ) ; } else { return this . _createFile ( fullPath , body , contentType , options ) . then ( putDone ) ; } } ) ; }
983	function compilePug ( file , options ) { let content = file . content . toString ( ) ; let config = options . config || { } ; config . pretty = true ; let data = config . data ; delete config . data ; let fn = pug . compile ( content , config ) ; content = fn ( data ) ; return { content } ; }
201	function verifyHTML ( caption ) { if ( ! caption || ( caption . indexOf ( '<' ) === - 1 && caption . indexOf ( '>' ) === - 1 ) ) { return caption ; } if ( ! serializer ) { serializer = new tinymce . html . Serializer ( { } , editor . schema ) ; } return serializer . serialize ( editor . parser . parse ( caption , { forced_root_block : false } ) ) ; }
874	function getExistingExtensions ( filePath ) { const basename = path . basename ( filePath , path . extname ( filePath ) ) try { return fs . readdirSync ( path . dirname ( filePath ) ) . filter ( filename => path . basename ( filename , path . extname ( filename ) ) === basename ) . map ( filename => path . extname ( filename ) ) } catch ( _error ) { return [ ] } }
465	function getClaimValue ( entity , prop ) { if ( ! entity . claims ) return ; if ( ! entity . claims [ prop ] ) return ; let value , c ; for ( let i = 0 ; i < entity . claims [ prop ] . length ; i ++ ) { c = entity . claims [ prop ] [ i ] ; if ( c . rank === 'deprecated' ) continue ; if ( c . mainsnak . snaktype !== 'value' ) continue ; value = c . mainsnak . datavalue . value ; if ( c . rank === 'preferred' ) return value ; } return value ; }
1194	function ( needle ) { if ( arr . indexOf ) { return arr . indexOf ( needle ) !== - 1 ; } else { for ( var i = 0 , length = arr . length ; i < length ; i ++ ) { if ( arr [ i ] === needle ) { return true ; } } return false ; } }
487	function compressOneArgFnArray ( fns ) { var errmsg = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 'You must pass me an array of function' ; if ( ! isArray ( fns ) || fns . length < 1 ) { throw new TypeError ( errmsg ) ; } if ( fns . length === 1 ) { if ( ! isFunction ( fns [ 0 ] ) ) { throw new TypeError ( errmsg ) ; } return fns [ 0 ] ; } return fns . reduce ( function ( prev , curr ) { if ( ! isFunction ( curr ) || ! isFunction ( prev ) ) throw new TypeError ( errmsg ) ; return function ( value ) { return bind$1 ( curr , this ) ( bind$1 ( prev , this ) ( value ) ) ; } ; } ) ; }
3483	function wrapSelfAndSiblingsInDefaultBlock ( container , offset ) { var newBlock , parentBlock , startNode , node , next , blockName = newBlockName || 'P' ; parentBlock = dom . getParent ( container , dom . isBlock ) ; if ( ! parentBlock || ! canSplitBlock ( parentBlock ) ) { parentBlock = parentBlock || editableRoot ; if ( ! parentBlock . hasChildNodes ( ) ) { newBlock = dom . create ( blockName ) ; parentBlock . appendChild ( newBlock ) ; rng . setStart ( newBlock , 0 ) ; rng . setEnd ( newBlock , 0 ) ; return newBlock ; } node = container ; while ( node . parentNode != parentBlock ) { node = node . parentNode ; } while ( node && ! dom . isBlock ( node ) ) { startNode = node ; node = node . previousSibling ; } if ( startNode ) { newBlock = dom . create ( blockName ) ; startNode . parentNode . insertBefore ( newBlock , startNode ) ; node = startNode ; while ( node && ! dom . isBlock ( node ) ) { next = node . nextSibling ; newBlock . appendChild ( node ) ; node = next ; } rng . setStart ( container , offset ) ; rng . setEnd ( container , offset ) ; } } return container ; }
1928	function isSingleProperty ( snippet ) { var utils = require ( 'utils' ) ; snippet = utils . trim ( snippet ) ; if ( ~ snippet . indexOf ( '/*' ) || / [\n\r] / . test ( snippet ) ) { return false ; } if ( ! / ^[a-z0-9\-]+\s*\: / i . test ( snippet ) ) { return false ; } snippet = require ( 'tabStops' ) . processText ( snippet , { replaceCarets : true , tabstop : function ( ) { return 'value' ; } } ) ; return snippet . split ( ':' ) . length == 2 ; }
3877	function remove ( el ) { while ( el . _events . length > 0 ) { el . _events . shift ( ) . remove ( ) ; } if ( el . children ) { destroy ( el . children ) ; } if ( el . elGroup !== undefined ) { el . elGroup . delete ( el . el ) ; } if ( el . el !== undefined ) { if ( el . el . remove ) { el . el . remove ( ) ; } else if ( el . el . parentNode ) { el . el . parentNode . removeChild ( el . el ) ; } delete el . el ; } }
2442	function __decode ( raw , key ) { var res = [ ] ; var len = _ . size ( key ) ; var cc = len ; for ( var i = 0 , ii = _ . size ( raw ) ; i < ii ; ++ i ) { if ( cc -- > 0 ) { res [ i ] = ( raw [ i ] - key . shift ( ) ) % 256 ; } else { res [ i ] = ( raw [ i ] - res [ i - len ] ) % 256 ; } } return new Buffer ( res ) ; }
2576	function splice ( s , index , count , add ) { return s . slice ( 0 , index ) + ( add || '' ) + s . slice ( index + count ) ; }
65	function hasClass ( element , className ) { return is$1 . element ( element ) && element . classList . contains ( className ) ; }
2098	function _prepopulate_metadata ( _arg , _cb ) { var entry ; try { entry = JSON . parse ( _arg ) ; } catch ( e ) { _cb ( ) ; return ; } var nm = path . join ( entry . parent , entry . name ) ; var k = sprintf ( FILES_KEY_FMT , nm ) ; var stats = self . cache . get ( k ) ; if ( stats ) { _cb ( ) ; return ; } self . db . get ( k , function ( err , val ) { if ( ! err ) { _cb ( ) ; return ; } var fh = uuid . v4 ( ) ; var info ; var cfile = path . join ( self . location , 'fscache' , fh ) ; if ( entry . type !== 'directory' ) { info = { name : entry . name , extension : 'bin' , type : 'application/octet-stream' , size : entry . size , headers : { 'last-modified' : entry . mtime } , _fhandle : fh , _cacheFile : cfile , last_stat : now } ; } else { info = { name : entry . name , extension : 'directory' , type : 'application/x-json-stream; type=directory' , headers : { 'last-modified' : entry . mtime , 'result-set-size' : 3 } , last_modified : entry . mtime , _fhandle : fh , _cacheFile : cfile , last_stat : now } ; } var k1 = sprintf ( FHANDLE_KEY_FMT , nm ) ; var k2 = sprintf ( FNAME_KEY_FMT , fh ) ; self . db . batch ( ) . put ( k , info ) . put ( k1 , fh ) . put ( k2 , nm ) . write ( function ( err2 ) { if ( ! err2 ) self . cache . set ( k , info ) ; _cb ( ) ; } ) ; } ) ; }
2071	function makeDateFromString ( config ) { var i , string = config . _i , match = isoRegex . exec ( string ) ; if ( match ) { config . _f = 'YYYY-MM-DD' + ( match [ 2 ] || " " ) ; for ( i = 0 ; i < 4 ; i ++ ) { if ( isoTimes [ i ] [ 1 ] . exec ( string ) ) { config . _f += isoTimes [ i ] [ 0 ] ; break ; } } if ( parseTokenTimezone . exec ( string ) ) { config . _f += " Z" ; } makeDateFromStringAndFormat ( config ) ; } else { config . _d = new Date ( string ) ; } }
3156	function bravojs_print ( ) { var output = "" ; var i ; var stdout ; for ( i = 0 ; i < arguments . length ; i ++ ) output += arguments [ i ] + ( i === arguments . length - 1 ? "" : " " ) ; output . replace ( / \t / , " " ) ; if ( typeof window . document != "undefined" && ( stdout = window . document . getElementById ( 'stdout' ) ) ) { output += "\n" ; \n } else if ( typeof stdout . value !== "undefined" ) { stdout . value += output ; if ( stdout . focus ) stdout . focus ( ) ; if ( stdout . tagName === "TEXTAREA" ) stdout . scrollTop = stdout . scrollHeight ; } else { if ( typeof stdout . innerText !== "undefined" ) { stdout . innerText = stdout . innerText . slice ( 0 , - 1 ) + output + " " ; } else stdout . textContent += output ; } }
1776	function buildDocs ( api ) { const view = buildTemplateView ( api ) ; const queue = d3 . queue ( 1 ) ; Object . keys ( api ) . forEach ( ( filepath ) => { queue . defer ( buildReadMe , filepath , view ) ; } ) ; queue . await ( ( err ) => { if ( err ) { console . log ( err ) ; } console . log ( 'Finished building docs' ) ; } ) ; }
2356	function doFindAndDeleteUpdate ( datasetId , acknowledgement , callback ) { debug ( '[%s] doFindAndDeleteUpdate acknowledgement = %j' , datasetId , acknowledgement ) ; var updatesCollection = mongoClient . collection ( getDatasetUpdatesCollectionName ( datasetId ) ) ; updatesCollection . findOneAndDelete ( { cuid : acknowledgement . cuid , hash : acknowledgement . hash } , function ( err , result ) { if ( err ) { debugError ( '[%s] Failed to doFindAndDeleteUpdate due to error %s :: acknowledgement = %j' , datasetId , err , acknowledgement ) ; return callback ( err ) ; } return callback ( null , result . value ) ; } ) ; }
2969	function _getOuterSize ( gridSize , sizeScreen ) { if ( 'lg' === sizeScreen ) { if ( gridSize && gridSize . lg ) { return gridSize . lg ; } else if ( gridSize && gridSize . md ) { return gridSize . md ; } else if ( gridSize && gridSize . sm ) { return gridSize . sm ; } else if ( gridSize && gridSize . xs ) { return gridSize . xs ; } } else if ( 'md' === sizeScreen ) { if ( gridSize && gridSize . md ) { return gridSize . md ; } else if ( gridSize && gridSize . sm ) { return gridSize . sm ; } else if ( gridSize && gridSize . xs ) { return gridSize . xs ; } } else if ( 'sm' === sizeScreen ) { if ( gridSize && gridSize . sm ) { return gridSize . sm ; } else if ( gridSize && gridSize . xs ) { return gridSize . xs ; } } else if ( 'xs' === sizeScreen ) { if ( gridSize && gridSize . xs ) { return gridSize . xs ; } } return grid ; }
1994	function processFile ( file , opts , stylize , callback ) { var stream = fs . createReadStream ( file ) ; if ( / \.gz$ / . test ( file ) ) { stream = stream . pipe ( require ( 'zlib' ) . createGunzip ( ) ) ; } var decoder = new ( require ( 'string_decoder' ) . StringDecoder ) ( 'utf8' ) ; streams [ file ] . stream = stream ; stream . on ( 'error' , function ( err ) { streams [ file ] . done = true ; callback ( err ) ; } ) ; var leftover = '' ; stream . on ( 'data' , function ( data ) { var chunk = decoder . write ( data ) ; if ( ! chunk . length ) { return ; } var lines = chunk . split ( / \r\n|\n / ) ; var length = lines . length ; if ( length === 1 ) { leftover += lines [ 0 ] ; return ; } if ( length > 1 ) { handleLogLine ( file , leftover + lines [ 0 ] , opts , stylize ) ; } leftover = lines . pop ( ) ; length -= 1 ; for ( var i = 1 ; i < length ; i ++ ) { handleLogLine ( file , lines [ i ] , opts , stylize ) ; } } ) ; stream . on ( 'end' , function ( ) { streams [ file ] . done = true ; if ( leftover ) { handleLogLine ( file , leftover , opts , stylize ) ; leftover = '' ; } else { emitNextRecord ( opts , stylize ) ; } callback ( ) ; } ) ; }
910	function compile ( file , options ) { if ( ! file . compileReady && ! file . owner . processed ) { return { content : file . content } ; } let { getAllPageConfigFiles , sourceDir , designWidth } = options ; let obj = JSON . parse ( file . content . toString ( ) ) ; let routerInfo = normalizeRouteInfo ( obj . pages ) ; delete obj . pages ; obj . router = routerInfo ; normalizeDebugConfig ( obj ) ; if ( designWidth ) { obj . config || ( obj . config = { } ) ; if ( ! obj . config . designWidth ) { obj . config . designWidth = designWidth ; } } let displayInfo = obj . display ; let displayConfig = normalizeWindowConfig ( obj . window ) ; displayConfig && ( displayInfo = Object . assign ( displayConfig , displayInfo ) ) ; displayInfo && ( obj . display = displayInfo ) ; delete obj . window ; if ( displayInfo && displayInfo . pages ) { displayInfo . pages = normalizeDisplayPages ( displayInfo . pages ) ; } let features = getUsedAPIFeatures ( obj . features , options ) ; features && ( obj . features = features ) ; let pageConfigFiles = getAllPageConfigFiles ( ) ; let currDisplayPages = ( displayInfo && displayInfo . pages ) || { } ; pageConfigFiles . forEach ( item => { addDisplayPageConfig ( currDisplayPages , sourceDir , item ) ; } ) ; if ( Object . keys ( currDisplayPages ) . length ) { displayInfo || ( obj . display = { } ) ; obj . display . pages = currDisplayPages ; } return { content : JSON . stringify ( obj , null , 4 ) } ; }
662	function ( word , locale ) { var syllableCount = 0 ; syllableCount += countVowelGroups ( word , locale ) ; syllableCount += countVowelDeviations ( word , locale ) ; return syllableCount ; }
2713	function getData ( ) { var data = { } ; this . getFormData ( ) . forEach ( function ( d ) { if ( Array . isArray ( data [ d . name ] ) ) { data [ d . name ] . push ( d . value ) ; } else if ( data [ d . name ] !== undefined ) { data [ d . name ] = [ data [ d . name ] , d . value ] ; } else { data [ d . name ] = d . value ; } } ) ; return data ; }
1344	function verify ( hashstr , password ) { const name = which ( hashstr ) ; if ( name === null ) { throw new TypeError ( 'No compatible algorithm installed.' ) ; } return use ( name ) . verify ( hashstr , password ) ; }
3773	function distinct ( it ) { return __asyncGenerator ( this , arguments , function * distinct_1 ( ) { var e_24 , _a ; const resultSet = new Set ( ) ; try { for ( var it_5 = __asyncValues ( it ) , it_5_1 ; it_5_1 = yield __await ( it_5 . next ( ) ) , ! it_5_1 . done ; ) { const item = it_5_1 . value ; if ( ! resultSet . has ( item ) ) { resultSet . add ( item ) ; yield yield __await ( item ) ; } } } catch ( e_24_1 ) { e_24 = { error : e_24_1 } ; } finally { try { if ( it_5_1 && ! it_5_1 . done && ( _a = it_5 . return ) ) yield __await ( _a . call ( it_5 ) ) ; } finally { if ( e_24 ) throw e_24 . error ; } } } ) ; }
3661	function Floodgate ( opts ) { if ( ! ( this instanceof Floodgate ) ) return new Floodgate ( opts ) ; opts = opts || { } ; Transform . call ( this , opts ) ; this . _interval = opts . interval || 0 ; }
2632	function matchAll ( regex , string ) { let match let matches = [ ] while ( ( match = regex . exec ( string ) ) !== null ) { delete match [ 'index' ] delete match [ 'input' ] matches . push ( match ) } return matches }
279	function checkActivePlaceholders ( ) { const placeholdersCount = activePlaceholders . length ; debug ( ` ${ placeholdersCount } ` ) ; if ( placeholdersCount > 0 ) { activePlaceholderEverDetected = true ; } if ( activePlaceholderEverDetected && placeholdersCount === 0 ) { const { startTime , trigger } = determineTimingType ( ) ; const duration = Math . round ( performance . now ( ) - startTime ) ; debug ( ` ${ duration } ${ trigger } ` ) ; analytics . timing . record ( ` ${ trigger } ` , duration ) ; stopMutationObserver ( ) ; } }
1455	function ( library , className ) { return pathModule . join ( library . getRootDir ( ) , library . getSourcePath ( ) , className . replace ( / \. / g , pathModule . sep ) + ".js" ) ; }
2949	function buildAllRoles ( all , roles ) { all . push ( ... roles ) ; _ . forEach ( roles , function ( role ) { if ( ROLE_INHERIT [ role ] ) { all = buildAllRoles ( all , ROLE_INHERIT [ role ] ) ; } } ) ; return all ; }
3793	function SleepCommand ( args , define ) { this . duration = new statements . ExpressionStatement ( args , define ) ; if ( this . duration . error ) throw this . duration . error ; }
591	function init ( ) { function animate ( ) { render ( ) ; requestAnimationFrame ( function ( ) { animate ( ) ; } ) ; } initRenderer3D ( r0 ) ; initRenderer2D ( r1 ) ; initRenderer2D ( r2 ) ; initRenderer2D ( r3 ) ; animate ( ) ; }
3201	function stringify ( string , params , noError ) { var arr = string . split ( ':' ) ; var param ; for ( var i = 0 , c = arr . length ; i < c ; i ++ ) { param = arr [ i ] ; if ( i % 2 ) { if ( ! ( typeof params [ param ] === 'string' || typeof params [ param ] === 'number' ) ) { if ( ! noError ) { throw new Error ( 'Variable ' + param + ' not defined' ) ; } } else { arr [ i ] = params [ param ] ; } } } return arr . join ( '' ) ; }
2590	function isInt ( ) { return libs . object . every ( arguments , function ( n ) { return typeof n === 'number' && n % 1 === 0 && n . toString ( ) . indexOf ( '.' ) === - 1 ; } ) ; }
2432	function field ( query ) { var queryDefinition ; if ( query instanceof Function ) { queryDefinition = query ( ) ; } else { queryDefinition = query ; } var customField = queryDefinition . select ; customField = customField . addSubQuery ( queryDefinition ) ; return customField ; }
2296	function randomPrice ( oldPrice , volatility ) { const rnd = randomNumber ( ) ; let changePercent = 2 * volatility * rnd ; if ( changePercent > volatility ) { changePercent -= ( 2 * volatility ) ; } const changeAmount = oldPrice * changePercent ; const newPrice = oldPrice + changeAmount ; return newPrice ; }
1901	function ( name , value , pos ) { var element = this . get ( name ) ; if ( element ) return element . value ( value ) ; if ( ! _ . isUndefined ( value ) ) { return this . add ( name , value , pos ) ; } }
3440	function ( eventDescriptor ) { var me = this ; if ( ! eventDescriptor . defer ) { me . makeToken ( eventDescriptor , 'done' ) ; me . fireEvent ( 'keyframe' , me , eventDescriptor ) ; } return eventDescriptor . done ; }
1653	function time_x ( t ) { var self = this ; if ( t === null ) { return null ; } var delta = t - ui . capture_idx . start ; if ( delta < 0 ) { console . log ( 'Negative delta for time ' + t ) ; } var pix = delta * ui . pix_per_sec / 1000 ; var x = margin [ 3 ] + pix ; return x ; }
720	function ( ua , uaLength ) { let temp = [ ] ; for ( let i = 0 ; i < uaLength ; i += 4 ) { let x = ua [ i ] * 0x1000000 + ( ua [ i + 1 ] || 0 ) * 0x10000 + ( ua [ i + 2 ] || 0 ) * 0x100 + ( ua [ i + 3 ] || 0 ) ; temp . push ( ( x > 0x7fffffff ) ? x - 0x100000000 : x ) ; } return CryptoJS . lib . WordArray . create ( temp , uaLength ) ; }
1225	function thunk ( formula ) { var evaluated = false , value ; return function ( ) { if ( evaluated === false ) { value = formula ( ) ; evaluated = true ; } return value ; } ; }
1537	function arrayEach ( arr , fn , startIndex , loop ) { var length , index , i ; if ( startIndex < 0 ) startIndex = arr . length + startIndex ; i = isNaN ( startIndex ) ? 0 : startIndex ; length = loop === true ? arr . length + i : arr . length ; while ( i < length ) { index = i % arr . length ; if ( ! ( index in arr ) ) { return iterateOverSparseArray ( arr , fn , i , loop ) ; } else if ( fn . call ( arr , arr [ index ] , index , arr ) === false ) { break ; } i ++ ; } }
940	function interceptPromiseResponse ( hasIntercepted , promise , doneHookInfo ) { let { hook } = doneHookInfo ; return promise . then ( res => ( hasIntercepted ? doneHookInfo . resData : hook ( null , res ) ) , err => { if ( hasIntercepted ) { let { resException , resData } = doneHookInfo ; if ( resException ) { throw resData ; } return resData ; } return hook ( err || 'err' ) ; } ) ; }
508	function loadContract ( cb ) { stateManager . getAccount ( runState . address , function ( err , account ) { if ( err ) return cb ( err ) runState . contract = account cb ( ) } ) }
3219	function ( fireEvent ) { var me = this ; if ( fireEvent && ! me . bulkChange ) { me . fireEvent ( 'selectionchange' , me , me . getSelection ( ) ) ; } }
1577	function ( image ) { const imageName = path . join ( 'images' , image ) const thumbName = path . join ( 'images' , ` ${ image } ` ) const thumbPath = path . join ( destination , thumbName ) if ( fs . existsSync ( thumbPath ) ) return thumbName return imageName }
1327	function Char ( value , kind , loc ) { let symbol ; let codePoint ; switch ( kind ) { case 'decimal' : { codePoint = Number ( value . slice ( 1 ) ) ; symbol = String . fromCodePoint ( codePoint ) ; break ; } case 'oct' : { codePoint = parseInt ( value . slice ( 1 ) , 8 ) ; symbol = String . fromCodePoint ( codePoint ) ; break ; } case 'hex' : case 'unicode' : { if ( value . lastIndexOf ( '\\u' ) > \\ ) 0 else { let [ lead , trail ] = value . split ( '\\u' ) . \\ slice ; ( 1 ) lead = parseInt ( lead , 16 ) ; trail = parseInt ( trail , 16 ) ; codePoint = ( lead - 0xd800 ) * 0x400 + ( trail - 0xdc00 ) + 0x10000 ; } symbol = String . fromCodePoint ( codePoint ) ; } { const hex = value . slice ( 2 ) . replace ( '{' , '' ) ; codePoint = parseInt ( hex , 16 ) ; if ( codePoint > 0x10ffff ) { throw new SyntaxError ( ` ${ value } ` ) ; } symbol = String . fromCodePoint ( codePoint ) ; } break ; } case 'meta' : { switch ( value ) { case '\\t' : \\ symbol = '\t' ; \t codePoint = symbol . codePointAt ( 0 ) ; break ; case '\\n' : \\ symbol = '\n' ; \n codePoint = symbol . codePointAt ( 0 ) ; break ; case '\\r' : \\ symbol = '\r' ; \r codePoint = symbol . codePointAt ( 0 ) ; break ; } case '\\v' : \\ symbol = '\v' ; \v } }
2528	function Bucks ( params ) { this . _tasks = [ ] ; this . _taskcount = 0 ; this . _results = [ ] ; this . callback = none ; this . failure = none ; this . _alive = true ; this . _interrupt = false ; this . __id = uid ( ) ; Bucks . living [ this . __id ] = this ; this . initialize ( params ) ; }
3313	function ArrayType ( typeSpec ) { if ( typeSpec instanceof Type ) { this . subtype = typeSpec ; } else if ( typeof typeSpec === 'string' ) { this . subtype = types . getType ( typeSpec ) ; if ( this . subtype == null ) { throw new Error ( 'Unknown array subtype: ' + typeSpec ) ; } } else { throw new Error ( 'Can\' handle array subtype' ) ; } }
10	function monkeyPatch ( ) { return { transform : ( code , id ) => { var file = id . split ( '/' ) . pop ( ) if ( file === 'FileSaver.js' ) { code = code . replace ( / define !== null\) && \(define.amd != null / g , '0' ) } else if ( file === 'html2canvas.js' ) { code = code . replace ( / &&\s+define.amd / g , '&& define.amd && false' ) } return code } } }
377	function getTextContent ( node ) { if ( isCommentNode ( node ) ) { return node . data || '' ; } if ( isTextNode ( node ) ) { return node . value || '' ; } var subtree = nodeWalkAll ( node , isTextNode ) ; return subtree . map ( getTextContent ) . join ( '' ) ; }
3720	function pickUnit ( srcDecls , destDecls , name , picked , stack ) { var decl = srcDecls [ name ] ; if ( ! picked [ name ] ) { if ( stack [ name ] ) { error ( "Recursive dependency '" + name + "'" ) ; } stack [ name ] = true ; for ( var i = 0 , len = decl . _dependencies . length ; i < len ; i ++ ) { var reqName = decl . _dependencies [ i ] ; forEach ( srcDecls , reqName , function ( depName ) { if ( depName !== name ) { pickUnit ( srcDecls , destDecls , depName , picked , stack ) ; } } ) ; } destDecls [ name ] = decl ; picked [ name ] = true ; } }
3642	function ( key ) { var obj = this . loadVar ( key ) ; if ( ! obj || typeof ( obj ) != 'object' ) { exitProcess ( 'the value of ' + key + ' is a necessary object ,but get ' + obj , this . alarm ) ; return false ; } return obj ; }
280	function getDefaultOptions ( ) { const ids = config ( 'directly_rtm_widget_ids' ) ; const env = config ( 'directly_rtm_widget_environment' ) ; return { id : ids [ env ] , displayAskQuestion : false , } ; }
2279	function get ( self , steamObj , key ) { steamObj = steamObj || { } ; if ( steamObj [ key ] !== undefined ) { return steamObj [ key ] ; } else if ( self [ key ] !== undefined ) { return self [ key ] ; } else if ( Steam [ key ] !== undefined ) { return Steam [ key ] ; } else { throw new Error ( "Missing required field: " + key ) ; } }
154	function setUpCSP ( req , res , next ) { const originalUrlPathname = req . originalUrl . split ( '?' ) [ 0 ] ; if ( ! / ^\/log-in / . test ( originalUrlPathname ) ) { next ( ) ; return ; } const inlineScripts = [ 'sha256-3yiQswl88knA3EhjrG5tj5gmV6EUdLYFvn2dygc0xUQ=' , 'sha256-ZKTuGaoyrLu2lwYpcyzib+xE4/2mCN8PKv31uXS3Eg4=' , ] ; req . context . inlineScriptNonce = crypto . randomBytes ( 48 ) . toString ( 'hex' ) ; const policy = { 'default-src' : [ "'self'" ] , 'script-src' : [ "'self'" , "'report-sample'" , "'unsafe-eval'" , 'stats.wp.com' , 'https://widgets.wp.com' , '*.wordpress.com' , 'https://apis.google.com' , ` ${ req . context . inlineScriptNonce } ` , 'www.google-analytics.com' , ... inlineScripts . map ( hash => ` ${ hash } ` ) , ] , 'base-uri' : [ "'none'" ] , 'style-src' : [ "'self'" , '*.wp.com' , 'https://fonts.googleapis.com' ] , 'form-action' : [ "'self'" ] , 'object-src' : [ "'none'" ] , 'img-src' : [ "'self'" , 'data' , '*.wp.com' , '*.files.wordpress.com' , '*.gravatar.com' , 'https://www.google-analytics.com' , 'https://amplifypixel.outbrain.com' , 'https://img.youtube.com' , ] , 'frame-src' : [ "'self'" , 'https://public-api.wordpress.com' , 'https://accounts.google.com/' ] , 'font-src' : [ "'self'" , '*.wp.com' , 'https://fonts.gstatic.com' , 'data:' , ] , 'media-src' : [ "'self'" ] , 'connect-src' : [ "'self'" , 'https://*.wordpress.com/' , 'https://*.wp.com' ] , 'report-uri' : [ '/cspreport' ] , } ; const policyString = Object . keys ( policy ) . map ( key => ` ${ key } ${ policy [ key ] . join ( ' ' ) } ` ) . join ( '; ' ) ; res . set ( { 'Content-Security-Policy-Report-Only' : policyString } ) ; next ( ) ; }
580	function createPromiseCapability ( ) { var capability = { } ; capability . promise = new Promise ( function ( resolve , reject ) { capability . resolve = resolve ; capability . reject = reject ; } ) ; return capability ; }
3038	function consume_template ( proc_stack ) { let template = "`" ; proc_stack . tSkip ( 1 ) ; let escaping = 0 ; let done = false ; while ( ! done ) { let c = proc_stack . tAccept ( ) ; if ( c == "\\" ) \\ else { escaping ^= 1 ; } { if ( c == "`" && ! escaping ) { done = true ; } escaping = 0 ; } } template += c ; }
1668	function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; result . ok ( passwordCrypto . getInstance ( ) . ping ( ) , false ) ; }
2010	function choosePointInEntity ( game , entity ) { var position = game . entities . getComponent ( entity , "position" ) ; var size = game . entities . getComponent ( entity , "size" ) ; if ( size === undefined ) { return { "x" : position . x , "y" : position . y } ; } return { "x" : random . inRange ( position . x , ( position . x + size . width ) ) , "y" : random . inRange ( position . y , ( position . y + size . height ) ) } ; }
2863	function ( fieldName ) { var field ; if ( this . domain && fieldName ) { field = this . domain . getIndexField ( fieldName ) ; if ( ! field . exists ( ) ) { this . throwValidationError ( 'CS-UnknownFieldInMatchExpression' , 'Field \'' + \' + fieldName + '\' is not defined in the metadata for this ' + \' ) ; } else 'collection. All fields used in the match expression must be ' } 'defined in the metadata.' if ( ! field . searchEnabled ) { this . available = false ; } }
1063	function ( ) { var retVal , parsedOptions ; if ( this . model ) { retVal = this . model . toJSON ( ) ; } else if ( this . collection ) { retVal = { models : this . collection . toJSON ( ) , meta : this . collection . meta , params : this . collection . params } ; } parsedOptions = _ . omit ( this . options , [ 'model' , 'collection' , 'app' ] ) ; return _ . extend ( { } , retVal , parsedOptions ) ; }
3354	function ( ) { var style = this . picker . getView ( ) . getEl ( ) . dom . style ; style . display = style . display ; }
3534	function exec ( cmd ) { return new Promise ( function ( resolve , reject ) { child_process . exec ( cmd , function ( error , stdout , stderr ) { if ( error ) { reject ( stderr . trim ( ) ) ; } else { resolve ( stdout . trim ( ) ) ; } } ) ; } ) ; }
86	function updateTimeDisplay ( ) { var target = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : null ; var time = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 0 ; var inverted = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : false ; if ( ! is$1 . element ( target ) || ! is$1 . number ( time ) ) { return ; } target . innerText = controls . formatTime ( time , inverted ) ; }
1410	function WritableStreamDefaultControllerError ( controller , e ) { const stream = controller . _controlledWritableStream ; assert ( stream . _state === 'writable' || stream . _state === 'closing' ) ; WritableStreamError ( stream , e ) ; controller . _queue = [ ] ; }
1958	function getLogicalPartitions ( disk , index , offset , extendedPartitionOffset , limit ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { if ( extendedPartitionOffset === undefined ) { extendedPartitionOffset = offset ; } if ( limit === undefined ) { limit = Infinity ; } const result = [ ] ; if ( limit <= 0 ) { return result ; } const buf = yield readFromDisk ( disk , offset , MBR_SIZE ) ; for ( const p of getPartitionsFromMBRBuf ( buf ) ) { if ( ! p . extended ) { result . push ( mbrPartitionDict ( p , offset , index ) ) ; } else if ( limit > 0 ) { const logicalPartitions = yield getLogicalPartitions ( disk , index + 1 , extendedPartitionOffset + p . byteOffset ( ) , extendedPartitionOffset , limit - 1 ) ; result . push ( ... logicalPartitions ) ; return result ; } } return result ; } ) ; }
2100	function ( soajs , id , cb ) { checkForMongo ( soajs ) ; var id1 ; try { id1 = mongo . ObjectId ( id ) ; return id1 ; } catch ( e ) { soajs . log . error ( e ) ; throw e ; } }
2758	function ( time , deltaTime ) { var progress ; var now = this . now ( ) ; var obj3d = this . el . object3D ; this . checkForComponentChanged ( ) ; if ( this . lerpingPosition ) { progress = ( now - this . startLerpTimePosition ) / this . duration ; obj3d . position . lerpVectors ( this . startPosition , this . targetPosition , progress ) ; if ( progress >= 1 ) { this . lerpingPosition = false ; } } if ( this . lerpingRotation ) { progress = ( now - this . startLerpTimeRotation ) / this . duration ; THREE . Quaternion . slerp ( this . startRotation , this . targetRotation , obj3d . quaternion , progress ) ; if ( progress >= 1 ) { this . lerpingRotation = false ; } } if ( this . lerpingScale ) { progress = ( now - this . startLerpTimeScale ) / this . duration ; obj3d . scale . lerpVectors ( this . startScale , this . targetScale , progress ) ; if ( progress >= 1 ) { this . lerpingScale = false ; } } }
2254	function updateLocation ( method ) { return function ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } return { type : _constants . CALL_HISTORY_METHOD , payload : { method : method , args : args } } ; } ; }
3310	function requireJsDoc ( node , isVirtual , paramsToCheck ) { var lines = sourceCode . lines ; var index = node . loc . start . line ; lines = lines . slice ( 0 , index ) ; var matches = lines . filter ( function ( line ) { return line . match ( / \/\*\* / gi ) ; } ) ; var lastIndex = lines . lastIndexOf ( matches [ matches . length - 1 ] ) ; var jsdocComment = findJSDocComment ( sourceCode . ast . comments , lastIndex ) ; if ( ! jsdocComment ) { report ( node ) ; return ; } checkJSDoc ( node , jsdocComment , isVirtual , paramsToCheck ) ; }
3405	function ( ) { var me = this , view = me . view ; view . on ( { scope : me , groupclick : me . onGroupClick } ) ; if ( me . enableGroupingMenu ) { me . injectGroupingMenu ( ) ; } me . pruneGroupedHeader ( ) ; me . lastGroupField = me . getGroupField ( ) ; me . block ( ) ; me . onGroupChange ( ) ; me . unblock ( ) ; }
914	function replaceTemplateVariable ( value , data ) { return value . replace ( / \{\{(.+)\}\} / g , ( match , varName ) => { varName = varName . trim ( ) ; let newVarName = data [ varName ] ; if ( newVarName ) { return ` ${ newVarName } ` ; } return match ; } ) ; }
1596	function createVisitor ( handlers ) { nodeTypes . forEach ( function ( nodeType ) { if ( typeof handlers [ nodeType ] === 'undefined' ) { throw new Error ( 'No handler defined for ' + nodeType . displayName ) ; } } ) ; return { visit : function ( node , context ) { return this . handlers [ node . displayName ] . call ( this , node , context ) ; } , handlers : handlers } ; }
43	function computeStackTrace ( ex , depth ) { var stack = null ; depth = depth == null ? 0 : + depth ; try { stack = computeStackTraceFromStackProp ( ex ) ; if ( stack ) { return stack ; } } catch ( e ) { if ( TraceKit . debug ) { throw e ; } } try { stack = computeStackTraceByWalkingCallerChain ( ex , depth + 1 ) ; if ( stack ) { return stack ; } } catch ( e ) { if ( TraceKit . debug ) { throw e ; } } return { name : ex . name , message : ex . message , url : getLocationHref ( ) } ; }
1806	function domHandler ( e ) { e = e || env . root . event ; var wrapped = wrapDomEvent ( e ) ; evt . trigger ( this , normalize ( wrapped ) ) ; }
3385	function ( options , params ) { var form = this . getForm ( options ) , serializedForm ; if ( form && ! this . isFormUpload ( options ) ) { serializedForm = Ext . Element . serializeForm ( form ) ; params = params ? ( params + '&' + serializedForm ) : serializedForm ; } return params ; }
1050	function add ( word , rules ) { var curr = ( own . call ( dict , word ) && dict [ word ] ) || [ ] dict [ word ] = curr . concat ( rules || [ ] ) }
1224	function installFilteredMouseMove ( element ) { element . on ( "mousemove" , function ( e ) { var lastpos = lastMousePosition ; if ( lastpos === undefined || lastpos . x !== e . pageX || lastpos . y !== e . pageY ) { $ ( e . target ) . trigger ( "mousemove-filtered" , e ) ; } } ) ; }
1395	function _attachRoomsSocketIO ( ) { if ( ! io ) return ; io . use ( ( socket , next ) => { const { node_id : nodeId , } = socket . handshake . query ; if ( nodeId ) { logger . info ( ` ${ nodeId } ` ) ; socket . join ( nodeId ) ; } return next ( ) ; } ) ; }
3867	function getAttribute ( node , prop ) { if ( node && node . el ) { return node . el . getAttribute ( prop ) ; } else { return undefined ; } }
2382	function ( error ) { if ( error ) { result . callbackError ( error , false ) ; } else { result . callbackOk ( undefined , false ) ; } }
1851	function ( query , queryOptions , callback ) { if ( ! queryOptions ) { callback = query ; query = { } ; queryOptions = { } ; } else if ( ! callback ) { callback = queryOptions ; queryOptions = { } ; } this . find ( query , queryOptions , function ( err , items ) { if ( err ) { return callback ( err ) ; } callback ( null , items [ 0 ] ) ; } ) ; }
2676	function inspectCommand ( shell , args , data , evaluationId ) { if ( args . names ) { args . names . forEach ( function ( n ) { console . log ( n + ':' ) ; console . dir ( shell . state [ n ] ) ; console . log ( ) ; } ) ; } }
3649	function ( e ) { var stack = ( e . stack + '\n' ) . \n replace . ( / ^\S[^\(]+?[\n$] / gm , '' ) replace . ( / ^\s+(at eval )?at\s+ / gm , '' ) replace . ( / ^([^\(]+?)([\n$]) / gm , '{anonymous}()@$1$2' ) replace . ( / ^Object.<anonymous>\s*\(([^\)]+)\) / gm , '{anonymous}()@$1' ) split ; ( '\n' ) \n }
773	function check ( type , hash , callback ) { if ( typeof type !== "string" ) throw new TypeError ( "type must be string" ) ; if ( typeof hash !== "string" ) throw new TypeError ( "hash must be string" ) ; if ( hasCache [ hash ] ) return callback ( null , true ) ; local . hasHash ( hash , function ( err , has ) { if ( err ) return callback ( err ) ; hasCache [ hash ] = has ; callback ( null , has ) ; } ) ; }
963	function normalizeTransformers ( transformerMap ) { let result = [ ] ; transformerMap && Object . keys ( transformerMap ) . forEach ( k => { let item = transformerMap [ k ] ; if ( item ) { item . transform . type = k ; result . push ( Object . assign ( { } , item , { name : k } ) ) ; } } ) ; return result ; }
2937	function inlineHandler ( string , selectionRange , symbol ) { let newString = string ; const newSelectionRange = [ ... selectionRange ] ; const insertSymbols = [ symbol , symbol ] ; const symbolLength = symbol . length ; const relevantPart = string . substring ( selectionRange [ 0 ] - symbolLength , selectionRange [ 1 ] + symbolLength ) . trim ( ) ; if ( relevantPart . includes ( symbol ) ) { newSelectionRange . forEach ( ( selectionIndex , j ) => { const isStartingIndex = j === 0 ; const isEndingIndex = j === 1 ; if ( newString . lastIndexOf ( symbol , selectionIndex ) === selectionIndex - symbolLength ) { newString = newString . substring ( 0 , selectionIndex - symbolLength ) + newString . substring ( selectionIndex ) ; if ( isStartingIndex ) { newSelectionRange [ 0 ] -= symbolLength ; newSelectionRange [ 1 ] -= symbolLength ; } if ( isEndingIndex && ! insertSymbols [ 0 ] ) { newSelectionRange [ 1 ] -= symbol . length ; } insertSymbols [ j ] = '' ; } if ( newString . indexOf ( symbol , selectionIndex ) === selectionIndex ) { newString = newString . substring ( 0 , selectionIndex ) + newString . substring ( selectionIndex + symbolLength ) ; if ( isStartingIndex ) { if ( newSelectionRange [ 0 ] !== newSelectionRange [ 1 ] ) { newSelectionRange [ 1 ] -= symbolLength ; } if ( newSelectionRange [ 0 ] === newSelectionRange [ 1 ] ) { newSelectionRange [ 0 ] -= symbolLength ; } } if ( isEndingIndex && insertSymbols [ 0 ] ) { newSelectionRange [ 1 ] += symbolLength ; } insertSymbols [ j ] = '' ; } } ) ; } const value = newString . substring ( 0 , newSelectionRange [ 0 ] ) + insertSymbols [ 0 ] + newString . substring ( newSelectionRange [ 0 ] , newSelectionRange [ 1 ] ) + insertSymbols [ 1 ] + newString . substring ( newSelectionRange [ 1 ] ) ; return { value , range : [ newSelectionRange [ 0 ] + insertSymbols [ 0 ] . length , newSelectionRange [ 1 ] + insertSymbols [ 1 ] . length ] } ; }
1926	function updateImageSizeCSS ( editor ) { var offset = editor . getCaretPos ( ) ; var info = require ( 'editorUtils' ) . outputInfo ( editor ) ; var cssRule = require ( 'cssEditTree' ) . parseFromPosition ( info . content , offset , true ) ; if ( cssRule ) { var prop = cssRule . itemFromPosition ( offset , true ) , m ; if ( prop && ( m = / url\((["']?)(.+?)\1\) / i . exec ( prop . value ( ) || '' ) ) ) { getImageSizeForSource ( editor , m [ 2 ] , function ( size ) { if ( size ) { var compoundData = cssRule . range ( true ) ; cssRule . value ( 'width' , size . width + 'px' ) ; cssRule . value ( 'height' , size . height + 'px' , cssRule . indexOf ( 'width' ) + 1 ) ; require ( 'actionUtils' ) . compoundUpdate ( editor , _ . extend ( compoundData , { data : cssRule . toString ( ) , caret : offset } ) ) ; } } ) ; } } }
1217	function makeSubclass ( getSignatureFunction ) { var superClass = OAuth . SignatureMethod ; var subClass = function ( ) { superClass . call ( this ) ; } ; subClass . prototype = new superClass ( ) ; subClass . prototype . getSignature = getSignatureFunction ; subClass . prototype . constructor = subClass ; return subClass ; }
1161	function ( model , opt ) { opt = opt || { } ; if ( _ . isUndefined ( opt . inbound ) && _ . isUndefined ( opt . outbound ) ) { opt . inbound = opt . outbound = true ; } var links = [ ] ; this . each ( function ( cell ) { var source = cell . get ( 'source' ) ; var target = cell . get ( 'target' ) ; if ( source && source . id === model . id && opt . outbound ) { links . push ( cell ) ; } if ( target && target . id === model . id && opt . inbound ) { links . push ( cell ) ; } } ) ; return links ; }
1467	async function ( ) { let { libraries } = await this . getProjectData ( ) ; if ( libraries instanceof Array && libraries . length ) { return path . resolve ( process . cwd ( ) , libraries [ 0 ] . path ) ; } throw new qx . tool . cli . Utils . UserError ( "Cannot find library path - are you in the right directory?" ) ; }
2598	function unique ( a ) { if ( ! ( a instanceof Array ) ) return a ; var visited = [ ] , unique = [ ] ; libs . object . each ( a , function ( item ) { if ( visited . indexOf ( item ) === - 1 ) { unique . push ( item ) ; visited . push ( item ) ; } } ) ; return unique ; }
2967	function clas ( ) { if ( this !== global ) { plain ? ( plain = false ) : ctor . apply ( this , arguments ) ; return this ; } else { return ( plain = true ) && clas . apply ( new clas ( ) , arguments ) ; } }
2764	function one ( context , next ) { setTimeout ( function ( ) { context . one = 'Hello' ; console . log ( 'Hello from one' , context ) ; return next ( ) ; } , 1000 ) ; console . log ( 'Hi from one' , context ) ; }
2509	function writeFile ( filePath , data , callback , count ) { if ( typeof callback !== 'function' ) throw new Error ( 'Wrong arguments' ) ; filePath = path . resolve ( filePath ) ; count = count || 0 ; var maxLimit = 5 ; fs . writeFile ( filePath , data , function ( err ) { if ( err ) { if ( count >= maxLimit ) callback ( new Error ( 'fsExt.writeFile: max repeat limit reached' ) . cause ( err ) ) ; else setTimeout ( function ( ) { writeFile ( filePath , data , callback , count + 1 ) ; } , 500 ) ; } else callback ( ) ; } ) ; }
1138	function baseFlatten ( array , isShallow , isArgArrays , fromIndex ) { var index = ( fromIndex || 0 ) - 1 , length = array ? array . length : 0 , result = [ ] ; while ( ++ index < length ) { var value = array [ index ] ; if ( value && typeof value == 'object' && typeof value . length == 'number' && ( isArray ( value ) || isArguments ( value ) ) ) { if ( ! isShallow ) { value = baseFlatten ( value , isShallow , isArgArrays ) ; } var valIndex = - 1 , valLength = value . length , resIndex = result . length ; result . length += valLength ; while ( ++ valIndex < valLength ) { result [ resIndex ++ ] = value [ valIndex ] ; } } else if ( ! isArgArrays ) { result . push ( value ) ; } } return result ; }
446	function sortData ( dataset , sortKey , sortOrder = "ascending" ) { if ( ! sortKey ) { return dataset ; } if ( sortKey === "x" || sortKey === "y" ) { sortKey = ` ${ sortKey } ` ; } const order = sortOrder === "ascending" ? "asc" : "desc" ; return orderBy ( dataset , sortKey , order ) ; }
2251	function text ( message , effect , lightColor ) { return [ use ( effect [ 0 ] , lightColor ) , String ( message ) , use ( effect [ 1 ] , lightColor ) ] . join ( '' ) ; }
2846	function ( property , val ) { if ( val === undefined ) { val = ( property === undefined ) ? this : property ; property = "__all__" ; } if ( property == "__all__" ) { notify ( this . _subscribers [ "__all__" ] , val ) ; } else { notify ( this . _subscribers [ property ] , val ) ; this . notify ( ) ; } }
2155	function defaults ( dst , src ) { forEach ( src , function ( value , key ) { if ( ! isDefined ( dst [ key ] ) ) { dst [ key ] = value ; } } ) ; }
423	function ( ) { var index = parserInput . i , name , value , rules , nonVendorSpecificName , hasIdentifier , hasExpression , hasUnknown , hasBlock = true , isRooted = true ; if ( parserInput . currentChar ( ) !== '@' ) { return ; } value = this [ 'import' ] ( ) || this . plugin ( ) || this . media ( ) ; if ( value ) { return value ; } parserInput . save ( ) ; name = parserInput . $re ( / ^@[a-z-]+ / ) ; if ( ! name ) { return ; } nonVendorSpecificName = name ; if ( name . charAt ( 1 ) == '-' && name . indexOf ( '-' , 2 ) > 0 ) { nonVendorSpecificName = '@' + name . slice ( name . indexOf ( '-' , 2 ) + 1 ) ; } switch ( nonVendorSpecificName ) { case '@charset' : hasIdentifier = true ; hasBlock = false ; break ; case '@namespace' : hasExpression = true ; hasBlock = false ; break ; case '@keyframes' : case '@counter-style' : hasIdentifier = true ; break ; case '@document' : case '@supports' : hasUnknown = true ; isRooted = false ; break ; default : hasUnknown = true ; break ; } parserInput . commentStore . length = 0 ; if ( hasIdentifier ) { value = this . entity ( ) ; if ( ! value ) { error ( 'expected ' + name + ' identifier' ) ; } } else if ( hasExpression ) { value = this . expression ( ) ; if ( ! value ) { error ( 'expected ' + name + ' expression' ) ; } } else if ( hasUnknown ) { value = this . permissiveValue ( / ^[{;] / ) ; hasBlock = ( parserInput . currentChar ( ) === '{' ) ; if ( ! value ) { if ( ! hasBlock && parserInput . currentChar ( ) !== ';' ) { error ( name + ' rule is missing block or ending semi-colon' ) ; } } else if ( ! value . value ) { value = null ; } } if ( hasBlock ) { rules = this . blockRuleset ( ) ; } if ( rules || ( ! hasBlock && value && parserInput . $char ( ';' ) ) ) { parserInput . forget ( ) ; return new ( tree . AtRule ) ( name , value , rules , index , fileInfo , context . dumpLineNumbers ? getDebugInfo ( index ) : null , isRooted ) ; } parserInput . restore ( 'at-rule options not recognised' ) ; }
3721	function pickUnits ( dest , settings ) { var units = settings . units ; if ( ! isArray ( units ) ) { error ( "Invalid units array in pick settings" ) ; } if ( ! ( settings . namespace instanceof Gumup ) ) { error ( "Invalid namespace in pick settings" ) ; } var picked = { } , srcDecls = settings . namespace . _declarations ; for ( var i = 0 , len = units . length ; i < len ; i ++ ) { var reqName = units [ i ] ; if ( ! checkRequireName ( reqName ) ) { error ( "Invalid unit name '" + reqName + "' in pick settings" ) ; } forEach ( srcDecls , reqName , function ( depName ) { pickUnit ( srcDecls , dest . _declarations , depName , picked , { } ) ; } ) ; } }
1171	function ( cell ) { var id = _ . isString ( cell ) ? cell : cell . id ; var $view = this . $ ( '[model-id="' + id + '"]' ) ; if ( $view . length ) { return $view . data ( 'view' ) ; } return undefined ; }
2693	function writeMessage ( message , socket , signer ) { var header = JSON . stringify ( message . header ) ; var parentHeader = JSON . stringify ( message . parentHeader ) ; var metadata = JSON . stringify ( message . metadata ) ; var content = JSON . stringify ( message . content ) ; var signature = signer . sign ( [ header , parentHeader , metadata , content ] ) ; var socketData = [ message . identities , '<IDS|MSG>' , signature , header , parentHeader , metadata , content ] ; socket . send ( socketData ) ; }
3774	function orderBy ( keySelector , comparison ) { const trueKeySelector = keySelector || defaultKeySelector ; const trueComparison = comparison || defaultComparison ; return function ( item ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_25 , _a ; const keyedMapper = map ( ( item , index ) => ( { item , key : trueKeySelector ( item , index ) } ) ) ; const keyed = keyedMapper ( item ) ; const keyedArray = yield __await ( toWriteableArray ( keyed ) ) ; keyedArray . sort ( ( a , b ) => trueComparison ( a . key , b . key ) ) ; try { for ( var keyedArray_1 = __asyncValues ( keyedArray ) , keyedArray_1_1 ; keyedArray_1_1 = yield __await ( keyedArray_1 . next ( ) ) , ! keyedArray_1_1 . done ; ) { const { item } = keyedArray_1_1 . value ; yield yield __await ( item ) ; } } catch ( e_25_1 ) { e_25 = { error : e_25_1 } ; } finally { try { if ( keyedArray_1_1 && ! keyedArray_1_1 . done && ( _a = keyedArray_1 . return ) ) yield __await ( _a . call ( keyedArray_1 ) ) ; } finally { if ( e_25 ) throw e_25 . error ; } } } ) ; } ; }
9	function makeWorker ( script ) { var URL = window . URL || window . webkitURL ; var Blob = window . Blob ; var Worker = window . Worker ; if ( ! URL || ! Blob || ! Worker || ! script ) { return null ; } var blob = new Blob ( [ script ] ) ; var worker = new Worker ( URL . createObjectURL ( blob ) ) ; return worker ; }
313	function getAdjustedSizes ( _ref4 ) { var aspectRatio = _ref4 . aspectRatio , height = _ref4 . height , width = _ref4 . width ; var type = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 'contain' ; var isValidWidth = isPositiveNumber ( width ) ; var isValidHeight = isPositiveNumber ( height ) ; if ( isValidWidth && isValidHeight ) { var adjustedWidth = height * aspectRatio ; if ( type === 'contain' && adjustedWidth > width || type === 'cover' && adjustedWidth < width ) { height = width / aspectRatio ; } else { width = height * aspectRatio ; } } else if ( isValidWidth ) { height = width / aspectRatio ; } else if ( isValidHeight ) { width = height * aspectRatio ; } return { width : width , height : height } ; }
792	function pluck ( obj , fields ) { var plucked = { } ; if ( ! obj ) { return ; } fields . forEach ( function ( field ) { plucked [ field ] = obj [ field ] ; } ) ; return plucked ; }
2721	function addLabel ( label , self ) { if ( ! ( label in self . labels ) ) { self . labels [ label ] = 1 ; } else { self . labels [ label ] ++ ; } }
3040	function ( animate ) { var me = this ; me . setVisible ( ! me . isVisible ( ) , me . anim ( animate ) ) ; return me ; }
2430	function siftup ( compare , a , i , j , k ) { var current = k - i ; while ( current !== 0 ) { var parent = i + ( current - 1 >>> 1 ) ; if ( compare ( a [ i + current ] , a [ parent ] ) >= 0 ) return i + current ; var tmp = a [ i + current ] ; a [ i + current ] = a [ parent ] ; a [ parent ] = tmp ; current = parent - i ; } return i + current ; }
2542	function countHolders ( array , placeholder ) { var length = array . length , result = 0 ; while ( length -- ) { if ( array [ length ] === placeholder ) { result ++ ; } } return result ; }
2583	function advanceDays ( d , daysInTheFuture , adjustForWeekend ) { if ( ! ( d instanceof Date ) ) return d ; daysInTheFuture = daysInTheFuture && libs . generic . isNumeric ( daysInTheFuture ) ? daysInTheFuture : 1 ; d . setTime ( d . getTime ( ) + ( daysInTheFuture * 86400000 ) ) ; if ( adjustForWeekend && ( d . getDay ( ) === 0 || d . getDay ( ) === 6 ) ) { while ( d . getDay ( ) === 0 || d . getDay ( ) === 6 ) d . setTime ( d . getTime ( ) + 86400000 ) ; } return d ; }
2589	function factorial ( n ) { if ( typeof n !== 'number' || n < 0 ) return NaN ; if ( n > 170 ) return Infinity ; if ( n === 0 || n === 1 ) return 1 ; return n * factorial ( n - 1 ) ; }
3047	function ( obj ) { if ( ! obj ) { obj = promise ; } else { for ( var key in promise ) { obj [ key ] = promise [ key ] ; } } return obj ; }
698	function ( ) { var id = mb . getUser ( Post . creator ) . id var xupdateStatus = doc . getElementById ( 'xupdateStatus' ) var xinReplyToContainer = doc . getElementById ( 'xinReplyToContainer' ) var xupdateSubmit = doc . getElementById ( 'xupdateSubmit' ) xupdateStatus . value = '@' + id + ' ' xupdateStatus . focus ( ) xinReplyToContainer . value = post . uri xupdateSubmit . value = 'Reply' }
1045	function importSpecifier ( name , def ) { return { type : def === true ? 'ImportDefaultSpecifier' : 'ImportSpecifier' , id : { type : 'Identifier' , name : name } , name : null } ; }
569	function ( target , vertex ) { vertex . prev = target ; vertex . next = target . next ; if ( vertex . next === null ) { this . tail = vertex ; } else { vertex . next . prev = vertex ; } target . next = vertex ; return this ; }
1285	function sc_isVectorEqual ( v1 , v2 , comp ) { if ( v1 . length !== v2 . length ) return false ; for ( var i = 0 ; i < v1 . length ; i ++ ) if ( ! comp ( v1 [ i ] , v2 [ i ] ) ) return false ; return true ; }
2153	function getBaseUrl ( ) { if ( window . document . baseURI ) { return window . document . baseURI ; } if ( ! baseUrlParsingNode ) { baseUrlParsingNode = window . document . createElement ( 'a' ) ; baseUrlParsingNode . href = '.' ; baseUrlParsingNode = baseUrlParsingNode . cloneNode ( false ) ; } return baseUrlParsingNode . href ; }
2144	function link ( nextEntry , prevEntry ) { if ( nextEntry !== prevEntry ) { if ( nextEntry ) nextEntry . p = prevEntry ; if ( prevEntry ) prevEntry . n = nextEntry ; } }
1049	function check ( value , double ) { var state = memory . state [ value ] var corrected if ( state !== Boolean ( state ) ) { result . push ( value ) corrected = form ( context , value ) state = corrected && ! flag ( flags , noSuggestType , data [ corrected ] ) memory . state [ value ] = state if ( state ) { memory . weighted [ value ] = double ? 10 : 0 memory . suggestions . push ( value ) } } if ( state ) { memory . weighted [ value ] ++ } }
389	function split_linebreaks ( s ) { s = s . replace ( acorn . allLineBreaks , '\n' ) ; \n var out = [ ] , idx = s . indexOf ( "\n" ) ; \n while ( idx !== - 1 ) { out . push ( s . substring ( 0 , idx ) ) ; s = s . substring ( idx + 1 ) ; idx = s . indexOf ( "\n" ) ; } }
3063	function ( index , silent ) { var me = this ; if ( ! index ) { index = 0 ; } else if ( ! Ext . isNumber ( index ) ) { index = Ext . Array . indexOf ( me . items , index ) ; } me . items [ index ] . disabled = true ; me . up ( 'tablepanel' ) . el . select ( '.' + Ext . baseCSSPrefix + 'action-col-' + index ) . addCls ( me . disabledCls ) ; if ( ! silent ) { me . fireEvent ( 'disable' , me ) ; } }
1930	function findPrefixes ( property , noAutofill ) { var result = [ ] ; _ . each ( vendorPrefixes , function ( obj , prefix ) { if ( hasPrefix ( property , prefix ) ) { result . push ( prefix ) ; } } ) ; if ( ! result . length && ! noAutofill ) { _ . each ( vendorPrefixes , function ( obj , prefix ) { if ( ! obj . obsolete ) result . push ( prefix ) ; } ) ; } return result ; }
1070	function actionCall ( action , params ) { action . call ( router , params , router . getRenderCallback ( route ) ) ; }
2237	function checkSuccess ( resp ) { if ( ! this . config . successPath ) { return resp . httpResponse . statusCode < 300 ; } var r = AWS . util . jamespath . find ( this . config . successPath , resp . data ) ; if ( this . config . failureValue && this . config . failureValue . indexOf ( r ) >= 0 ) { return null ; } if ( this . expectedValue ) { return r === this . expectedValue ; } else { return r ? true : false ; } }
3523	function ( ) { var me = this , value = me . textField . getValue ( ) ; if ( value === '' ) { return null ; } if ( ! me . regExpMode ) { value = value . replace ( me . regExpProtect , function ( m ) { return '\\' + \\ ; } ) ; } else m { try { new RegExp ( value ) ; } catch ( error ) { me . statusBar . setStatus ( { text : error . message , iconCls : 'x-status-error' } ) ; return null ; } if ( value === '^' || value === '$' ) { return null ; } } }
2743	function ( p ) { var isRollLeft = roll == null || roll . getDepth ( ) >= 1 if ( roll ) { roll . up ( ) } if ( isRollLeft ) { next ( ) } else { callback ( null , null , resultStatus ) } }
2207	function validateIf ( inlineValues , values ) { if ( "_if" in inlineValues ) { var value = inlineValues [ "_if" ] ; delete inlineValues [ "_if" ] ; var params = { } ; var condition = value . replace ( ifRegex , function ( match , varname ) { if ( ! varname ) return match ; var resolved = resolveName ( varname , values ) ; if ( options . semanticIf === true ) { resolved = [ "no" , "off" ] . indexOf ( resolved ) === - 1 ; } else if ( mout . lang . isArray ( options . semanticIf ) ) { resolved = options . semanticIf . indexOf ( resolved ) === - 1 ; } else if ( mout . lang . isFunction ( options . semanticIf ) ) { resolved = options . semanticIf ( resolved ) ; } params [ varname ] = resolved ; return "params['" + varname + "']" ; } ) ; try { return ! eval ( condition ) ; } catch ( e ) { grunt . log . error ( "Invalid if condition: '" + value + "'" ) ; } } return false ; }
1654	function wmic ( callback ) { var args = [ 'PROCESS' , 'get' , 'ParentProcessId,ProcessId' ] ; var options = { windowsHide : true , windowsVerbatimArguments : true } ; bin ( 'wmic' , args , options , function ( err , stdout , code ) { if ( err ) { callback ( err ) ; return ; } if ( code !== 0 ) { callback ( new Error ( 'pidtree wmic command exited with code ' + code ) ) ; return ; } try { stdout = stdout . split ( os . EOL ) ; var list = [ ] ; for ( var i = 1 ; i < stdout . length ; i ++ ) { stdout [ i ] = stdout [ i ] . trim ( ) ; if ( ! stdout [ i ] ) continue ; stdout [ i ] = stdout [ i ] . split ( / \s+ / ) ; stdout [ i ] [ 0 ] = parseInt ( stdout [ i ] [ 0 ] , 10 ) ; stdout [ i ] [ 1 ] = parseInt ( stdout [ i ] [ 1 ] , 10 ) ; list . push ( stdout [ i ] ) ; } callback ( null , list ) ; } catch ( error ) { callback ( error ) ; } } ) ; }
2704	function extensionsCommand ( shell , args , data , evaluationId ) { var names = [ ] ; for ( var n in shell . loadedExtensions ) { names . push ( n ) ; } console . log ( names . join ( '\n' ) ) ; }
972	function initTplProcessor ( opts ) { registerProcessor ( { name : 'wxml2swan' , processor : 'view' , extnames : [ 'wxml' ] , rext : 'swan' , options : opts || { plugins : [ wxmlPlugin ] } } ) ; }
3420	function ( list ) { var store = list . getStore ( ) ; return Ext . Array . sort ( list . getSelectionModel ( ) . getSelection ( ) , function ( a , b ) { a = store . indexOf ( a ) ; b = store . indexOf ( b ) ; if ( a < b ) { return - 1 ; } else if ( a > b ) { return 1 ; } return 0 ; } ) ; }
2479	function isSsh ( input ) { if ( Array . isArray ( input ) ) { return input . indexOf ( "ssh" ) !== - 1 || input . indexOf ( "rsync" ) !== - 1 ; } if ( typeof input !== "string" ) { return false ; } var prots = protocols ( input ) ; input = input . substring ( input . indexOf ( "://" ) + 3 ) ; if ( isSsh ( prots ) ) { return true ; } return input . indexOf ( "@" ) < input . indexOf ( ":" ) ; }
1220	function css ( el , prop ) { for ( var n in prop ) el . style [ vendor ( el , n ) || n ] = prop [ n ] return el }
3802	function Service ( name ) { debug ( 'new service: %s' , name ) ; assert ( name , "service not supplied with name" ) ; this . name = name ; this . middleware = [ ] ; this . uri = new Uri ( ) ; this . status = new Status ( ) ; this . initialize ( ) ; return this ; }
3846	function drawAllDataPoints ( animationDecimal ) { var rotationDegree = ( 2 * Math . PI ) / data . datasets [ 0 ] . data . length ; ctx . save ( ) ; ctx . translate ( width / 2 , height / 2 ) ; for ( var i = 0 ; i < data . datasets . length ; i ++ ) { ctx . beginPath ( ) ; ctx . moveTo ( 0 , animationDecimal * ( - 1 * calculateOffset ( data . datasets [ i ] . data [ 0 ] , calculatedScale , scaleHop ) ) ) ; for ( var j = 1 ; j < data . datasets [ i ] . data . length ; j ++ ) { ctx . rotate ( rotationDegree ) ; ctx . lineTo ( 0 , animationDecimal * ( - 1 * calculateOffset ( data . datasets [ i ] . data [ j ] , calculatedScale , scaleHop ) ) ) ; } ctx . closePath ( ) ; ctx . fillStyle = data . datasets [ i ] . fillColor ; ctx . strokeStyle = data . datasets [ i ] . strokeColor ; ctx . lineWidth = config . datasetStrokeWidth ; ctx . fill ( ) ; ctx . stroke ( ) ; if ( config . pointDot ) { ctx . fillStyle = data . datasets [ i ] . pointColor ; ctx . strokeStyle = data . datasets [ i ] . pointStrokeColor ; ctx . lineWidth = config . pointDotStrokeWidth ; for ( var k = 0 ; k < data . datasets [ i ] . data . length ; k ++ ) { ctx . rotate ( rotationDegree ) ; ctx . beginPath ( ) ; ctx . arc ( 0 , animationDecimal * ( - 1 * calculateOffset ( data . datasets [ i ] . data [ k ] , calculatedScale , scaleHop ) ) , config . pointDotRadius , 2 * Math . PI , false ) ; ctx . fill ( ) ; ctx . stroke ( ) ; } } ctx . rotate ( rotationDegree ) ; } ctx . restore ( ) ; }
564	function ( eyePoint , crossEdge , face , horizon ) { this . deleteFaceVertices ( face ) ; face . mark = Deleted ; var edge ; if ( crossEdge === null ) { edge = crossEdge = face . getEdge ( 0 ) ; } else { edge = crossEdge . next ; } do { var twinEdge = edge . twin ; var oppositeFace = twinEdge . face ; if ( oppositeFace . mark === Visible ) { if ( oppositeFace . distanceToPoint ( eyePoint ) > this . tolerance ) { this . computeHorizon ( eyePoint , twinEdge , oppositeFace , horizon ) ; } else { horizon . push ( edge ) ; } } edge = edge . next ; } while ( edge !== crossEdge ) ; return this ; }
3227	function ( redraw ) { var i = 0 , items = this . items , len = this . length ; for ( ; i < len ; i ++ ) { items [ i ] . show ( redraw ) ; } return this ; }
3840	function PrintCommand ( args , define ) { if ( args [ args . length - 1 ] === ";" ) { this . noLine = true ; args = args . substr ( - 1 ) ; } else this . noLine = false ; var parsed = new statements . ArgumentStatement ( args , { flags : [ 'USING' ] , parseArgs : false } ) ; if ( parsed . flags . USING ) { if ( parsed . args . length !== 1 ) throw new SyntaxError ( 'PRINT USING command requires 1 argument' ) ; if ( parsed . args . length > 1 ) throw new SyntaxError ( 'Unexpected comma' ) ; var semicolonIndex = parsed . args [ 0 ] . indexOf ( ';' ) ; if ( semicolonIndex === - 1 ) throw new SyntaxError ( 'Expected semicolon' ) ; var formatExpression = new statements . ExpressionStatement ( parsed . args [ 0 ] . substring ( 0 , semicolonIndex ) . trim ( ) , define ) ; var numberExpression = new statements . ExpressionStatement ( parsed . args [ 0 ] . substring ( semicolonIndex + 1 ) . trim ( ) , define ) ; if ( formatExpression . error instanceof SyntaxError ) throw formatExpression . error ; if ( numberExpression . error instanceof SyntaxError ) throw numberExpression . error ; this . formatExpr = formatExpression ; this . numberExpr = numberExpression ; } else { var items = [ ] ; for ( var i = 0 ; i < parsed . args . length ; i ++ ) { var expr = new statements . ExpressionStatement ( parsed . args [ i ] , define ) ; if ( expr . error instanceof SyntaxError ) throw expr . error ; items . push ( expr ) ; } this . items = items ; } }
3878	function onDOMAttached ( el ) { var _this2 = this ; var handlers = [ ] , attached = false , _step = undefined ; if ( el . el !== undefined ) { _step = function step ( ) { if ( attached ) { while ( handlers . length > 0 ) { handlers . shift ( ) ( ) ; } } else { window . requestAnimationFrame ( _step ) ; if ( document . body . contains ( el . el ) ) { attached = true ; } } } ; } return { then : function then ( cb , context ) { handlers . push ( cb . bind ( context || _this2 ) ) ; window . requestAnimationFrame ( _step ) ; } } ; }
1089	function getAuthorization ( req ) { if ( ! req . headers || typeof req . headers !== 'object' ) { throw new TypeError ( 'argument req is required to have headers property' ) } return req . headers . authorization }
3681	function get ( options , config ) { options = options || found config = config || { } var dir = options . dir || found . dir || 'config' var env = options . env || found . env || 'staging' var base = options . base || found . base || 'base' var key = env . toLowerCase ( ) . replace ( / ^([gro]|ca) / , 'p' ) . replace ( / ^(sa|[al]) / , 'd' ) . replace ( / ^[qtbcij] / , 's' ) [ 0 ] var environment = map [ key ] || map [ key = 's' ] config . env = env config . environment = environment config . isDebug = / de?bu?g / i . test ( env ) config . isDevelopment = ( key === 'd' ) config . isStaging = ( key === 's' ) config . isProduction = ( key === 'p' ) hide ( config , 'load' , load ) config . load ( dir , base ) config . load ( dir , environment ) var subEnvironments = config . subEnvironments if ( subEnvironments && subEnvironments . indexOf ( env ) > - 1 ) { config . load ( dir , env ) } return config }
2774	function packageStatesSerialize ( ) { if ( atom . packages . serialize != null ) { return atom . packages . serialize ( ) } atom . packages . getActivePackages ( ) . forEach ( ( pack ) => { var state if ( pack . serialize != null ) state = pack . serialize ( ) if ( state ) { atom . packages . setPackageState ( pack . name , state ) } } ) return atom . packages . packageStates }
556	function ( vertex , face ) { vertex . face = face ; if ( face . outside === null ) { this . assigned . append ( vertex ) ; } else { this . assigned . insertBefore ( face . outside , vertex ) ; } face . outside = vertex ; return this ; }
3453	function canonicalMd5 ( md5 ) { if ( md5 ) { if ( Buffer . isBuffer ( md5 ) ) md5 = md5 . toString ( 'base64' ) else if ( md5 && md5 . match ( / ^md5- / ) ) md5 = md5 . replace ( / ^md5- / , '' ) if ( md5 . length === 32 ) md5 = new Buffer ( md5 , 'hex' ) . toString ( 'base64' ) } return md5 }
1414	function ( value , oldValue ) { var loader = path . join ( __dirname , "loader-" + ( this . isBrowserApp ( ) ? "browser" : "server" ) + ".tmpl.js" ) ; this . setLoaderTemplate ( loader ) ; this . setTheme ( null ) ; }
2215	function compare ( a , b , index ) { return ( ( a . charCodeAt ( index ) || 0 ) - ( b . charCodeAt ( index ) || 0 ) || compare ( a , b , index + 1 ) ) }
3224	function ( ) { var renderData = this . callParent ( ) ; if ( this . owner . getHierarchyState ( ) . rtl ) { renderData . innerCtCls = ( renderData . innerCtCls || '' ) + ' ' + Ext . baseCSSPrefix + 'rtl' ; } return renderData ; }
1103	function ( str , rmc ) { if ( rmc . length !== 13 && rmc . length !== 14 && rmc . length !== 15 ) { throw new Error ( 'Invalid RMC length: ' + str ) ; } return { 'time' : parseTime ( rmc [ 1 ] , rmc [ 9 ] ) , 'status' : parseRMC_GLLStatus ( rmc [ 2 ] ) , 'lat' : parseCoord ( rmc [ 3 ] , rmc [ 4 ] ) , 'lon' : parseCoord ( rmc [ 5 ] , rmc [ 6 ] ) , 'speed' : parseKnots ( rmc [ 7 ] ) , 'track' : parseNumber ( rmc [ 8 ] ) , 'variation' : parseRMCVariation ( rmc [ 10 ] , rmc [ 11 ] ) , 'faa' : rmc . length > 13 ? parseFAA ( rmc [ 12 ] ) : null , 'navStatus' : rmc . length > 14 ? rmc [ 13 ] : null } ; }
1	function className ( node , value ) { var klass = node . className || '' , svg = klass && klass . baseVal !== undefined if ( value === undefined ) return svg ? klass . baseVal : klass svg ? ( klass . baseVal = value ) : ( node . className = value ) }
571	function ( vertex ) { if ( vertex . prev === null ) { this . head = vertex . next ; } else { vertex . prev . next = vertex . next ; } if ( vertex . next === null ) { this . tail = vertex . prev ; } else { vertex . next . prev = vertex . prev ; } return this ; }
823	function advance_exec_cursor ( ) { if ( chain_is_corked ) return ; while ( exec_cursor < chain . length ) { if ( is_func ( chain [ exec_cursor ] ) ) { if ( chain_opts [ _Debug ] ) log_msg ( "$LAB.wait() executing: " + chain [ exec_cursor ] ) ; try { chain [ exec_cursor ++ ] ( ) ; } catch ( err ) { if ( chain_opts [ _Debug ] ) log_error ( "$LAB.wait() error caught: " , err ) ; } continue ; } else if ( ! chain [ exec_cursor ] . finished ) { if ( check_chain_group_scripts_ready ( chain [ exec_cursor ] ) ) continue ; break ; } exec_cursor ++ ; } if ( exec_cursor == chain . length ) { scripts_currently_loading = false ; group = false ; } }
3842	function charAt ( index ) { return value => value . length <= index ? undefined : value . charAt ( index ) ; }
2127	function ( method , where , what , query , callback ) { var opts = { } ; if ( what == undefined ) opts . body = "" ; else opts . body = JSON . stringify ( what ) ; opts . headers = { } ; opts . headers [ 'Content-Length' ] = opts . body . length ; opts . headers [ 'Content-Type' ] = "application/json" ; opts . headers [ 'Authorization' ] = "SSWS " + apiKey ; opts . method = method ; opts . uri = url . parse ( where ) ; if ( query != null ) opts . qs = query ; request ( opts , function ( error , clientResp , resp ) { handleResponse ( error , false , clientResp , resp , callback ) } ) ; }
3086	function trailer ( file , fn ) { return through ( { objectMode : true } , function ( a , e , cb ) { this . push ( a ) cb ( ) } , function ( cb ) { var self = this fn ( function ( err , val ) { if ( err ) { return cb ( err ) } if ( val ) { if ( typeof val === 'string' ) { val = new Buffer ( string ) } var f = new File ( { path : file , contents : val } ) self . push ( f ) } cb ( ) } ) } ) }
3559	function valueOrDefault ( value , defaultValue , type ) { defaultValue = typeof defaultValue === _undefined ? null : defaultValue ; var retVal ; if ( isset ( type ) ) { retVal = issetAndOfType . apply ( null , [ value ] . concat ( sjl . restArgs ( arguments , 2 ) ) ) ? value : defaultValue ; } else { retVal = isset ( value ) ? value : defaultValue ; } return retVal ; }
2665	function smsDeleteCampaign ( callback , campaign_id ) { if ( campaign_id === undefined ) { return callback ( returnError ( "Empty sms campaign id" ) ) ; } var data = { 'id' : campaign_id } sendRequest ( 'sms/campaigns' , 'DELETE' , data , true , callback ) ; }
2835	function loadFormatter ( formatterPath ) { try { formatterPath = ( formatterPath === 'jslint_xml' ) ? 'jslint' : formatterPath ; return require ( './lib/' + formatterPath + '_emitter' ) ; } catch ( e ) { console . error ( 'Unrecognized format: %s' , formatterPath ) ; console . error ( 'This emitter was not found on lib folder.\nYou can always create yours :)\n' ) ; \n } }
882	function getRequiredModulePath ( valuePath , moduleName , t , removeRequireDeclaration = false ) { let bindVar = valuePath . scope . bindings [ moduleName ] ; if ( ! bindVar ) { throw valuePath . buildCodeFrameError ( ` ${ moduleName } ` ) ; } let declareNodePath = bindVar . path ; let parentStatementPath = bindVar . path . getStatementParent ( ) ; if ( t . isImportDeclaration ( parentStatementPath ) ) { let id = parentStatementPath . node . source . value ; if ( removeRequireDeclaration ) { let toRemovePath = declareNodePath ; if ( t . isImportDefaultSpecifier ( declareNodePath . node ) ) { toRemovePath = declareNodePath . parentPath ; } removeNode ( t , toRemovePath , { tail : true } ) ; } return id ; } else if ( t . isVariableDeclarator ( declareNodePath ) ) { let initNode = declareNodePath . node . init ; let id = getRequireExpressionModuleId ( initNode , t ) ; if ( id ) { removeRequireDeclaration && removeVariableDeclaration ( t , bindVar , { tail : true } ) ; return id ; } } throw valuePath . buildCodeFrameError ( ` ${ moduleName } ` ) ; }
1918	function removeComment ( str ) { return str . replace ( new RegExp ( '^' + utils . escapeForRegexp ( commentStart ) + '\\s*' ) , \\ ) . function ( str ) { caretPos -= str . length ; return '' ; } replace ; }
624	function filterEndingWith ( wordCombinations , str , exceptions ) { wordCombinations = wordCombinations . filter ( function ( combination ) { const combinationstr = combination . getCombination ( ) ; for ( let i = 0 ; i < exceptions . length ; i ++ ) { if ( combinationstr . endsWith ( exceptions [ i ] ) ) { return true ; } } return ! combinationstr . endsWith ( str ) ; } ) ; return wordCombinations ; }
1377	function fallback ( callback ) { return async . series ( [ viaBasis , noBasis ] , callback ) ; function viaBasis ( callback ) { return self . apos . migrations . eachDoc ( { workflowLocale : basis } , 5 , function ( doc , callback ) { if ( ! self . includeType ( doc . type ) ) { return setImmediate ( callback ) ; } doc . workflowResolveDeferred = true ; var afterSaveOptions = _ . assign ( { } , options , { permissions : false , workflowMissingLocalesLive : self . apos . argv . live ? true : 'liveOnly' } ) ; return self . docAfterSave ( req , doc , afterSaveOptions , callback ) ; } , callback ) ; } function noBasis ( callback ) { var localeNames = Object . keys ( self . locales ) ; var orphans ; return async . series ( [ find , fix ] , callback ) ; function find ( callback ) { const query = [ { $match : { workflowLocale : { $in : localeNames } } } , { $group : { _id : "$workflowGuid" , count : { $sum : 1 } } } , { $match : { count : { $lt : localeNames . length } } } ] ; return self . apos . docs . db . aggregate ( query ) . toArray ( function ( err , _orphans ) { if ( err ) { return callback ( err ) ; } orphans = _orphans ; return callback ( null ) ; } ) ; } function fix ( callback ) { var seen = { } ; if ( ! orphans . length ) { return callback ( null ) ; } return self . apos . migrations . eachDoc ( { workflowGuid : { $in : _ . pluck ( orphans , '_id' ) } } , 5 , function ( doc , callback ) { if ( seen [ doc . workflowGuid ] ) { return setImmediate ( callback ) ; } seen [ doc . workflowGuid ] = true ; if ( ! self . includeType ( doc . type ) ) { return setImmediate ( callback ) ; } doc . workflowResolveDeferred = true ; var afterSaveOptions = _ . assign ( { } , options , { permissions : false , workflowMissingLocalesLive : self . apos . argv . live ? true : 'liveOnly' } ) ; return self . docAfterSave ( req , doc , afterSaveOptions , callback ) ; } , callback ) ; } } }
3839	function onChange ( ) { if ( props . onChange ) { var changeHandlers = [ ... props . onChange ] var value = editor . getValue ( ) return changeHandlers . map ( ( f ) => f ( value ) ) } }
1786	function loadSync ( ) { debug ( 'Loading environment scripts:' ) ; var a11ySuiteScriptPath = 'web-component-tester/data/a11ySuite.js' ; var scripts = get ( 'environmentScripts' ) ; var a11ySuiteWillBeLoaded = window . __generatedByWct || scripts . indexOf ( a11ySuiteScriptPath ) > - 1 ; if ( ! a11ySuiteWillBeLoaded && ! window . __wctUseNpm ) { scripts . push ( a11ySuiteScriptPath ) ; } scripts . forEach ( function ( path ) { var url = expandUrl ( path , get ( 'root' ) ) ; debug ( 'Loading environment script:' , url ) ; document . write ( '<script src="' + encodeURI ( url ) + '"></script>' ) ; } ) ; debug ( 'Environment scripts loaded' ) ; var imports = get ( 'environmentImports' ) ; imports . forEach ( function ( path ) { var url = expandUrl ( path , get ( 'root' ) ) ; debug ( 'Loading environment import:' , url ) ; document . write ( '<link rel="import" href="' + encodeURI ( url ) + '">' ) ; } ) ; debug ( 'Environment imports loaded' ) ; }
2932	function Future ( f , args ) { var self = this ; function run ( ) { args [ args . length ] = function cb ( ) { switch ( arguments . length ) { case 0 : self . result = null ; break ; case 1 : if ( arguments [ 0 ] instanceof Error ) { self . err = arguments [ 0 ] ; } else { self . result = arguments [ 0 ] ; } break ; default : self . err = arguments [ 0 ] ; if ( arguments . length === 2 ) { self . result = arguments [ 1 ] ; } else { self . result = Array . prototype . slice . call ( arguments , 1 ) ; } break ; } if ( self . flow_ ) self . flow_ . futureFinished ( ) ; var caller = self . caller ; if ( caller ) caller . run ( ) ; } ; args . length ++ ; f . apply ( undefined , args ) ; } this . run = run ; var flow = Fiber . current . flow ; if ( flow ) { Object . defineProperty ( this , "flow_" , { enumerable : false , writable : true , value : flow } ) ; flow . registerFuture ( this ) ; } else { run ( ) ; } }
1388	function finishExecution ( exId , err ) { if ( err ) { const error = new TSError ( err , { reason : ` ${ exId } ` , context : { ex_id : exId , } } ) ; logger . error ( error ) ; } return getExecutionContext ( exId ) . then ( ( execution ) => { const status = execution . _status ; if ( [ 'stopping' , 'stopped' ] . includes ( status ) ) { logger . debug ( ` ${ exId } ` ) ; return true ; } logger . debug ( ` ${ exId } ` ) ; return clusterService . stopExecution ( exId ) . catch ( ( stopErr ) => { const stopError = new TSError ( stopErr , { reason : 'error finishing the execution' , context : { ex_id : exId , } } ) ; logger . error ( stopError ) ; } ) ; } ) ; }
362	function getStyleComputedProperty ( element , property ) { if ( element . nodeType !== 1 ) { return [ ] ; } var window = element . ownerDocument . defaultView ; var css = window . getComputedStyle ( element , null ) ; return property ? css [ property ] : css ; }
166	function openLinksInParentFrame ( ) { const viewPostLinkSelectors = [ '.components-notice-list .is-success .components-notice__action.is-link' , '.post-publish-panel__postpublish .components-panel__body.is-opened a' , '.components-panel__body.is-opened .post-publish-panel__postpublish-buttons a.components-button' , ] . join ( ',' ) ; $ ( '#editor' ) . on ( 'click' , viewPostLinkSelectors , e => { e . preventDefault ( ) ; window . open ( e . target . href , '_top' ) ; } ) ; if ( calypsoifyGutenberg . manageReusableBlocksUrl ) { const manageReusableBlocksLinkSelectors = [ '.editor-inserter__manage-reusable-blocks' , 'a.components-menu-item__button[href*="post_type=wp_block"]' , ] . join ( ',' ) ; $ ( '#editor' ) . on ( 'click' , manageReusableBlocksLinkSelectors , e => { e . preventDefault ( ) ; window . open ( calypsoifyGutenberg . manageReusableBlocksUrl , '_top' ) ; } ) ; } }
1945	function ( name , collection ) { if ( collection in elementTypes ) { elementTypes [ collection ] = _ . without ( this . getCollection ( collection ) , name ) ; } }
3628	function replace ( value , configData ) { if ( typeof value != "string" ) { return value ; } else { return value . replace ( propStringTmplRe , function ( match , path ) { var value = get ( configData , path ) ; if ( ! ( value instanceof Error ) ) { return value ; } else { return match ; } } ) ; } }
2927	function ( ) { var args = Array . prototype . slice . apply ( arguments ) ; var message = args [ 0 ] ; var rpcCallbackHandler = function ( ) { } ; if ( '__type' in message && message . __type === 'rpc' ) { rpcCallbackHandler = function ( err , result ) { self . emit ( message . __backChannel , { err : err , result : result } ) ; } ; } args = [ ] . concat ( args , [ rpcCallbackHandler ] ) ; handler . apply ( null , args ) ; }
2488	function ( direction , cloud_element ) { var start = $ ( '#cloudGraphPagingStart' ) . val ( ) ; var rows = $ ( '#cloudGraphPagingRows' ) . val ( ) ; var startAt = start ? parseInt ( start ) : 0 ; var numRows = rows ? parseInt ( rows ) : 20 ; var newStart = Math . max ( startAt + ( rows * direction ) , 0 ) ; $ ( '#cloudGraphPagingStart' ) . val ( newStart ) ; var graph_element = $ ( '#graph-content' , cloud_element ) ; $ ( '#canvas' , graph_element ) . empty ( ) ; init_graph ( graph_element ) ; }
2183	function message ( msg , thisArg ) { var sig = colors . red ( thisArg . name ) ; sig += ' in plugin ' ; sig += '"' + colors . cyan ( thisArg . plugin ) + '"' ; sig += '\n' ; \n sig += msg ; }
2137	function wrapFn ( mocker , fn ) { return function ( ) { var args = Array . prototype . slice . call ( arguments ) ; mocker . history . push ( args ) ; return fn . apply ( this , arguments ) ; } ; }
2802	function setForeignKeys ( request , baseQuery ) { if ( typeof baseQuery === 'undefined' ) { return } _ . forEach ( baseQuery ( request ) , function ( v , k ) { request . payload [ k ] = request . params [ k ] } ) }
2324	function inputHandler ( manager , eventType , input ) { var pointersLen = input . pointers . length ; var changedPointersLen = input . changedPointers . length ; var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0 ; var isFinal = eventType & ( INPUT_END | INPUT_CANCEL ) && pointersLen - changedPointersLen === 0 ; input . isFirst = ! ! isFirst ; input . isFinal = ! ! isFinal ; if ( isFirst ) { manager . session = { } ; } input . eventType = eventType ; computeInputData ( manager , input ) ; manager . emit ( 'hammer.input' , input ) ; manager . recognize ( input ) ; manager . session . prevInput = input ; }
1755	function ( qName ) { if ( this . _q . name !== qName ) { this . _q . name = qName ; var queueOpts = { redis : { host : redis . redisOpts . host , port : redis . redisOpts . port , DB : redis . redisOpts . db , opts : { auth_pass : redis . redisOpts . auth_pass } } } ; this . _q . instance = new bull ( qName , queueOpts ) ; } return this . _q . instance ; }
1876	function ( fn , options ) { this . _list . push ( _ . extend ( { order : 0 } , options || { } , { fn : fn } ) ) ; }
207	function createSitesComponent ( context ) { const contextPath = sectionify ( context . path ) ; const basePath = contextPath === '/sites' ? '/stats' : contextPath ; analytics . pageView . record ( contextPath , sitesPageTitleForAnalytics ) ; return ( < SitesComponent siteBasePath = { basePath } getSiteSelectionHeaderText = { context . getSiteSelectionHeaderText } / > ) ; }
2149	function encodePath ( path ) { var segments = path . split ( '/' ) , i = segments . length ; while ( i -- ) { segments [ i ] = encodeUriSegment ( segments [ i ] . replace ( / %2F / g , '/' ) ) ; } return segments . join ( '/' ) ; }
3608	function Emitter ( opts ) { Transform . call ( this ) ; this . _writableState . objectMode = true ; this . _readableState . objectMode = true ; opts = opts || { } ; this . name = opts . name ; this . passthrough = opts . passthrough ; }
1236	function ( ) { let location = null ; const args = Array . prototype . slice . call ( arguments ) ; args . push ( docs ) ; if ( typeof result . preBuild === "function" ) { result . preBuild ( arguments ) ; } if ( self . withPositions || self . withSource ) { let src = null ; if ( self . withSource ) { src = parser . lexer . _input . substring ( start . offset , parser . prev [ 2 ] ) ; } if ( self . withPositions ) { location = new Location ( src , start , new Position ( parser . prev [ 0 ] , parser . prev [ 1 ] , parser . prev [ 2 ] ) ) ; } else { location = new Location ( src , null , null ) ; } args . push ( location ) ; } if ( ! kind ) { kind = args . shift ( ) ; } const node = self [ kind ] ; if ( typeof node !== "function" ) { throw new Error ( 'Undefined node "' + kind + '"' ) ; } const astNode = Object . create ( node . prototype ) ; node . apply ( astNode , args ) ; result . instance = astNode ; if ( result . trailingComments ) { astNode . trailingComments = result . trailingComments ; } if ( typeof result . postBuild === "function" ) { result . postBuild ( astNode ) ; } if ( parser . debug ) { delete AST . stack [ result . stackUid ] ; } return self . resolvePrecedence ( astNode , parser ) ; }
1255	function ( page , data ) { if ( page . flagAniBind == true ) return ; [ "animationstart" , "animationend" ] . forEach ( function ( animationkey , index ) { var animition = paramsIn [ animationkey ] , webkitkey = "webkit" + animationkey . replace ( / ^a|s|e / g , function ( matchs ) { return matchs . toUpperCase ( ) ; } ) ; var animateEventName = isWebkit ? webkitkey : animationkey ; if ( index ) { page . addEventListener ( animateEventName , function ( ) { if ( this . classList . contains ( "in" ) == false ) { this . style . display = "none" ; } this . classList . remove ( params ( this ) . form ) ; } ) ; } if ( typeof animition == "string" && paramsIn . root [ animition ] ) { page . addEventListener ( animateEventName , function ( ) { data . root [ animition ] . call ( data . root , this , this . classList . contains ( "in" ) ? "into" : "out" , options ) ; } ) ; } else if ( typeof animition == "function" ) { page . addEventListener ( animateEventName , function ( ) { animition . call ( data . root , this , this . classList . contains ( "in" ) ? "into" : "out" , options ) ; } ) ; } page . flagAniBind = true ; } ) ; }
3297	function createTableGrid ( node ) { var selection = ed . selection , tblElm = ed . dom . getParent ( node || selection . getNode ( ) , 'table' ) ; if ( tblElm ) return new TableGrid ( tblElm , ed . dom , selection ) ; }
1925	function decodeFromBase64 ( editor , data , pos ) { var filePath = String ( editor . prompt ( 'Enter path to file (absolute or relative)' ) ) ; if ( ! filePath ) return false ; var file = require ( 'file' ) ; var absPath = file . createPath ( editor . getFilePath ( ) , filePath ) ; if ( ! absPath ) { throw "Can't save file" ; } file . save ( absPath , require ( 'base64' ) . decode ( data . replace ( / ^data\:.+?;.+?, / , '' ) ) ) ; editor . replaceContent ( '$0' + filePath , pos , pos + data . length ) ; return true ; }
1164	function ( el ) { var $el = this . $ ( el ) ; if ( $el . length === 0 || $el [ 0 ] === this . el ) { var attrs = this . model . get ( 'attrs' ) || { } ; if ( attrs [ '.' ] && attrs [ '.' ] [ 'magnet' ] === false ) { return undefined ; } return this . el ; } if ( $el . attr ( 'magnet' ) ) { return $el [ 0 ] ; } return this . findMagnet ( $el . parent ( ) ) ; }
105	function toggle ( input ) { var passive = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : true ; if ( ! this . supported . ui ) { return ; } var toggled = this . captions . toggled ; var activeClass = this . config . classNames . captions . active ; var active = is$1 . nullOrUndefined ( input ) ? ! toggled : input ; if ( active !== toggled ) { if ( ! passive ) { this . captions . active = active ; this . storage . set ( { captions : active } ) ; } if ( ! this . language && active && ! passive ) { var tracks = captions . getTracks . call ( this ) ; var track = captions . findTrack . call ( this , [ this . captions . language ] . concat ( _toConsumableArray ( this . captions . languages ) ) , true ) ; this . captions . language = track . language ; captions . set . call ( this , tracks . indexOf ( track ) ) ; return ; } if ( this . elements . buttons . captions ) { this . elements . buttons . captions . pressed = active ; } toggleClass ( this . elements . container , activeClass , active ) ; this . captions . toggled = active ; controls . updateSetting . call ( this , 'captions' ) ; triggerEvent . call ( this , this . media , active ? 'captionsenabled' : 'captionsdisabled' ) ; } }
3456	function join_plugins ( plugins ) { debug . assert ( plugins ) . is ( 'array' ) ; debug . assert ( ARRAY ( plugins ) . every ( is . func ) ) . equals ( true ) ; return function join_plugins_ ( req , res , next ) { var queue = [ ] . concat ( plugins ) ; function do_iteration_ ( ) { if ( queue . length === 0 ) { next ( ) ; return ; } var plugin = queue . shift ( ) ; debug . assert ( plugin ) . is ( 'function' ) ; plugin ( req , res , function plugin_wrapper ( err ) { if ( err ) { next ( err ) ; return ; } do_iteration_ ( ) ; } ) ; } function do_iteration ( ) { try { do_iteration_ ( ) ; } catch ( err ) { next ( err ) ; return ; } } do_iteration ( ) ; } ; }
3021	function CI ( pull_request , branch , build_number , builder ) { this . pull_request = pull_request ; this . branch = branch ; this . build_number = build_number ; this . builder = builder ; this . GetVersion = GetVersion ; this . GetPullRequest = GetPullRequest ; this . PublishGitTag = PublishGitTag ; this . MergeDownstream = MergeDownstream ; }
525	function ( hashKey , dataObject , myContent , myClass , bootstrapSettings ) { var exportButton = document . createElement ( "button" ) ; exportButton . setAttribute ( "type" , "button" ) ; exportButton . setAttribute ( this . storageKey , hashKey ) ; exportButton . className = bootstrapSettings . bootstrapClass + bootstrapSettings . bootstrapTheme + myClass ; exportButton . textContent = myContent ; return exportButton ; }
1889	function ( data ) { var o1 , o2 , o3 , h1 , h2 , h3 , h4 , bits , i = 0 , ac = 0 , tmpArr = [ ] ; var b64 = chars , il = data . length ; if ( ! data ) { return data ; } data += '' ; do { h1 = b64 . indexOf ( data . charAt ( i ++ ) ) ; h2 = b64 . indexOf ( data . charAt ( i ++ ) ) ; h3 = b64 . indexOf ( data . charAt ( i ++ ) ) ; h4 = b64 . indexOf ( data . charAt ( i ++ ) ) ; bits = h1 << 18 | h2 << 12 | h3 << 6 | h4 ; o1 = bits >> 16 & 0xff ; o2 = bits >> 8 & 0xff ; o3 = bits & 0xff ; if ( h3 == 64 ) { tmpArr [ ac ++ ] = String . fromCharCode ( o1 ) ; } else if ( h4 == 64 ) { tmpArr [ ac ++ ] = String . fromCharCode ( o1 , o2 ) ; } else { tmpArr [ ac ++ ] = String . fromCharCode ( o1 , o2 , o3 ) ; } } while ( i < il ) ; return tmpArr . join ( '' ) ; }
2008	function ( prefab ) { this . prefab = prefab ; this . origin = { "x" : 0 , "y" : 0 } ; this . spreadType = "random" ; this . angle = 0 ; this . arcWidth = Math . PI / 2 ; this . qtyMin = 1 ; this . qtyMax = 1 ; this . sizeMin = 1 ; this . sizeMax = 1 ; this . velocityMin = 0.5 ; this . velocityMax = 0.5 ; this . accelerationX = 0 ; this . accelerationY = 0 ; this . lifeSpanMin = 0 ; this . lifeSpanMax = 500 ; }
3147	function ( item , width , height ) { var items = item , len = 1 , contextItem , i ; if ( item . isComposite ) { items = item . elements ; len = items . length ; item = items [ 0 ] ; } else if ( ! item . dom && ! item . el ) { len = items . length ; item = items [ 0 ] ; } for ( i = 0 ; i < len ; ) { contextItem = this . get ( item ) ; contextItem . setSize ( width , height ) ; item = items [ ++ i ] ; } }
2200	function ( docular_webapp_target ) { var ABS_SCRIPTS = __dirname ; var ABS_LIB = path . resolve ( ABS_SCRIPTS + '/..' ) ; var ABS_DEFAULT_GENERATED_WEBAPP = ABS_LIB + '/generated/' ; return docular_webapp_target ? path . resolve ( process . cwd ( ) + '/' + docular_webapp_target ) : path . relative ( process . cwd ( ) , ABS_DEFAULT_GENERATED_WEBAPP ) ; }
2895	function injectQuery ( tokenValue , options , param ) { options . url += ~ options . url . indexOf ( '?' ) ? '&' : '?' ; options . url += param + '=' + tokenValue ; }
3089	function ( errors ) { var me = this , e , eLen , error , value , key ; function mark ( fieldId , msg ) { var field = me . findField ( fieldId ) ; if ( field ) { field . markInvalid ( msg ) ; } } if ( Ext . isArray ( errors ) ) { eLen = errors . length ; for ( e = 0 ; e < eLen ; e ++ ) { error = errors [ e ] ; mark ( error . id , error . msg ) ; } } else if ( errors instanceof Ext . data . Errors ) { eLen = errors . items . length ; for ( e = 0 ; e < eLen ; e ++ ) { error = errors . items [ e ] ; mark ( error . field , error . message ) ; } } else { for ( key in errors ) { if ( errors . hasOwnProperty ( key ) ) { value = errors [ key ] ; mark ( key , value , errors ) ; } } } return this ; }
2618	function min ( o , func ) { if ( ! o || typeof o !== 'object' ) return o ; if ( libs . object . size ( o ) === 0 ) return ; if ( ! ( func instanceof Function ) ) func = undefined ; if ( typeof o !== 'object' ) return o ; var min , minValue ; if ( ! func ) { min = libs . object . first ( o ) ; libs . object . each ( o , 1 , function ( item ) { if ( item <= min ) min = item ; } ) ; } else { min = libs . object . first ( o ) ; minValue = func . call ( min , min ) ; libs . object . each ( o , 1 , function ( item ) { var value = func . call ( item , item ) ; if ( value <= minValue ) { min = item ; minValue = value ; } } ) ; } return min ; }
3066	function ( ) { var sorters = this . sorters . items , len = sorters . length , i = 0 , sorter ; for ( ; i < len ; ++ i ) { sorter = sorters [ i ] ; if ( ! sorter . isGrouper ) { return sorter ; } } return null ; }
699	function ( a , success ) { if ( success ) { that . notify ( 'Post deleted.' ) var deleteThisNode = evt . target . parentNode deleteThisNode . parentNode . removeChild ( deleteThisNode ) kb . removeMany ( deleteMe ) } else { that . notify ( 'Oops, there was a problem, please try again' ) evt . target . disabled = true } }
1944	function ( name , collection ) { if ( ! elementTypes [ collection ] ) elementTypes [ collection ] = [ ] ; var col = this . getCollection ( collection ) ; if ( ! _ . include ( col , name ) ) col . push ( name ) ; }
3111	function ( ) { var me = this , offsetParent = me . dom . offsetParent , style = me . getStyle ( [ 'left' , 'top' ] ) , x = style . left , y = style . top ; if ( ! x || x === 'auto' ) { x = 0 ; } else if ( me . pxRe . test ( x ) ) { x = parseFloat ( x ) ; } else { x = me . getX ( ) ; if ( offsetParent ) { x -= Element . getX ( offsetParent ) ; } } if ( ! y || y === 'auto' ) { y = 0 ; } else if ( me . pxRe . test ( y ) ) { y = parseFloat ( y ) ; } else { y = me . getY ( ) ; if ( offsetParent ) { y -= Element . getY ( offsetParent ) ; } } return [ x , y ] ; }
2503	function ( type , content , textAfter , state ) { if ( this . jsonMode ) { return / ^[\[,{]$ / . test ( content ) || / ^} / . test ( textAfter ) ; } else { if ( content == ";" && state . lexical && state . lexical . type == ")" ) return false ; return / ^[;{}]$ / . test ( content ) && ! / ^; / . test ( textAfter ) ; } }
3168	function init ( ) { SXE . initElementDialog ( 'del' ) ; if ( SXE . currentAction == "update" ) { setFormValue ( 'datetime' , tinyMCEPopup . editor . dom . getAttrib ( SXE . updateElement , 'datetime' ) ) ; setFormValue ( 'cite' , tinyMCEPopup . editor . dom . getAttrib ( SXE . updateElement , 'cite' ) ) ; SXE . showRemoveButton ( ) ; } }
3848	function ( path ) { var xhr = new XMLHttpRequest ; xhr . open ( 'GET' , baseUrl + 'web/' + path + '.js' , false ) ; xhr . send ( ) ; if ( xhr . status !== 200 ) new FatalError ( 'Unable to load: ' + path + '.js' ) ; var s = document . createElement ( 'script' ) ; s . type = "text/javascript" ; s . text = xhr . responseText ; document . getElementsByTagName ( 'head' ) [ 0 ] . appendChild ( s ) ; }
2833	function BaseImporter ( ) { this . _schema = null ; this . _export = null ; this . _types = { } ; this . _model = { properties : { } , definitions : { } , ids : { } } ; this . error = null ; var baseImporter = this ; this . on ( 'readyStateChanged' , function ( readyState ) { if ( readyStates . complete === readyState ) { if ( baseImporter . error ) { baseImporter . emit ( 'failed' , baseImporter . error ) ; } else { baseImporter . emit ( 'success' , null , baseImporter . getModel ( ) ) ; } baseImporter . emit ( 'complete' , baseImporter . error , baseImporter . getModel ( ) ) ; } } ) ; }
1179	function dfs ( n ) { var children = spanningTree . successors ( n ) ; for ( var c in children ) { var child = children [ c ] ; dfs ( child ) ; } if ( n !== spanningTree . graph ( ) . root ) { setCutValue ( graph , spanningTree , n ) ; } }
916	function updateTemplateDataVariableName ( element , data ) { let { children } = element ; let result = [ ] ; children && children . forEach ( item => { let { type } = item . type ; let newItem = Object . assign ( { } , item ) ; if ( type === 'tag' ) { let { attribs : attrs , children } = item ; newItem . attribs = replaceElementAttributeVariable ( attrs , data ) ; if ( children ) { let newChildren = updateTemplateDataVariableName ( item , data ) ; newChildren && ( newItem . children = newChildren ) ; } } else if ( type === 'text' ) { let { data : textValue } = item ; textValue = replaceTemplateVariable ( textValue , data ) ; newItem . data = textValue ; } result . push ( newItem ) ; } ) ; return result ; }
2879	function pageRange ( selected , numPages , num ) { let selectedPos = Math . ceil ( num / 2 ) ; let start = ( selected < selectedPos ) ? 1 : selected - selectedPos + 1 ; let len = ( numPages < start + num - 1 ) ? numPages - start + 1 : num ; return Array . apply ( null , Array ( len ) ) . map ( ( u , i ) => start + i ) ; }
2719	function argMax ( array ) { var maxIndex = 0 , i ; for ( i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] > array [ maxIndex ] ) { maxIndex = i ; } } return maxIndex ; }
677	function ( values ) { this . _hasScore = false ; this . _identifier = "" ; this . _hasMarks = false ; this . _marker = emptyMarker ; this . score = 0 ; this . text = "" ; this . marks = [ ] ; if ( isUndefined ( values ) ) { values = { } ; } if ( ! isUndefined ( values . score ) ) { this . setScore ( values . score ) ; } if ( ! isUndefined ( values . text ) ) { this . setText ( values . text ) ; } if ( ! isUndefined ( values . marks ) ) { this . setMarks ( values . marks ) ; } }
596	function ( i18n , options = { } ) { Assessor . call ( this , i18n , options ) ; this . type = "ContentAssessor" ; const locale = ( options . hasOwnProperty ( "locale" ) ) ? options . locale : "en_US" ; this . _assessments = [ new FleschReadingEase ( contentConfiguration ( locale ) . fleschReading ) , new SubheadingDistributionTooLong ( ) , paragraphTooLong , new SentenceLengthInText ( contentConfiguration ( locale ) . sentenceLength ) , transitionWords , passiveVoice , textPresence , sentenceBeginnings , ] ; }
1023	function unHookGetItemURL ( rs ) { if ( ! rs . _origBaseClientGetItemURL ) { return ; } BaseClient . prototype . getItemURL = rs . _origBaseClientGetItemURL ; delete rs . _origBaseClientGetItemURL ; }
2607	function isArguments ( ) { return libs . object . every ( arguments , function ( item ) { return Object . prototype . toString . call ( item ) === '[object Arguments]' ; } ) ; }
209	function isTrackingPixel ( image ) { if ( ! image || ! image . src ) { return false ; } const edgeLength = image . height + image . width ; return edgeLength === 1 || edgeLength === 2 ; }
2091	function createClass ( ) { var mixins , definition ; switch ( arguments . length ) { case 0 : throw new Error ( 'class definition required' ) ; break ; case 1 : mixins = [ ] ; definition = arguments [ 0 ] ; break ; default : mixins = arguments [ 0 ] ; definition = arguments [ 1 ] ; break ; } var newclass = definition [ 'constructor' ] ; if ( typeof newclass !== 'function' ) throw new Error ( 'constructor function required' ) ; if ( typeof newclass . name === 'string' && newclass . name . length === 0 ) throw new Error ( 'constructor name required, it will be used as new class name' ) ; newclass . prototype = definition ; newclass . prototype . instanceOf = instanceOf ; newclass . prototype . Super = superMethod ; if ( ! mixins ) return newclass ; if ( Array . isArray ( mixins ) ) { for ( var i = mixins . length - 1 ; i >= 0 ; i -- ) { newclass = mixin ( newclass , mixins [ i ] ) ; } return newclass ; } else { return mixin ( newclass , mixins ) ; } }
1673	function ( success , fail , args ) { args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; vibration . getInstance ( ) . vibration_request ( args ) ; success ( ) ; }
1099	function objectAndParentGivenPath ( path ) { let obj = global || window ; let parent = obj ; for ( let part of path . split ( '.' ) ) { parent = obj ; obj = obj [ part ] ; } d ( ` ${ parent } ${ obj } ` ) ; if ( typeof ( parent ) !== 'object' ) { throw new Error ( ` ${ path } ` ) ; } return [ parent , obj ] ; }
2406	function getSubscribableForArray ( ko , array ) { var subscribable = array . _subscribable ; var signal = { } ; if ( ! subscribable ) { subscribable = array . _subscribable = new ko . subscribable ( ) ; wrapStandardArrayMutators ( array , subscribable , signal ) ; addKnockoutArrayMutators ( ko , array , subscribable , signal ) ; } return subscribable ; }
3436	function ( array ) { var sum = 0 , i , ln , item ; for ( i = 0 , ln = array . length ; i < ln ; i ++ ) { item = array [ i ] ; sum += item ; } return sum ; }
2455	function ( msg , flags ) { if ( flags . exact ) { seneca . add ( _ . extend ( { } , msg , { role : 'entity' , cmd : 'save' } ) , save ) seneca . add ( _ . extend ( { } , msg , { role : 'entity' , cmd : 'load' } ) , load ) seneca . add ( _ . extend ( { } , msg , { role : 'entity' , cmd : 'list' } ) , list ) seneca . add ( _ . extend ( { } , msg , { role : 'entity' , cmd : 'remove' } ) , remove ) return } var actions = { save : save , load : load , list : list , remove : remove } var core_patterns = [ { role : 'entity' , cmd : 'save' } , { role : 'entity' , cmd : 'load' } , { role : 'entity' , cmd : 'list' } , { role : 'entity' , cmd : 'remove' } ] _ . each ( core_patterns , function ( core_pat ) { var pats = seneca . list ( core_pat ) _ . each ( pats , function ( pat ) { seneca . add ( pat , actions [ core_pat . cmd ] ) } ) } ) }
44	function _promiseRejectionHandler ( event ) { this . _logDebug ( 'debug' , 'Raven caught unhandled promise rejection:' , event ) ; this . captureException ( event . reason , { mechanism : { type : 'onunhandledrejection' , handled : false } } ) ; }
1279	function addWECPropertyIfDefined ( object , property , value ) { if ( ! IS_UNDEFINED ( value ) ) { defineWECProperty ( object , property , value ) ; } }
853	function enforceExports ( ) { const globalScope = context . getScope ( ) const exportsNodes = getExportsNodes ( globalScope ) const moduleExportsNodes = getModuleExportsNodes ( globalScope ) const assignList = batchAssignAllowed ? createAssignmentList ( exportsNodes ) : [ ] const batchAssignList = [ ] for ( const node of moduleExportsNodes ) { if ( assignList . length > 0 ) { const found = assignList . indexOf ( getTopAssignment ( node ) ) if ( found !== - 1 ) { batchAssignList . push ( assignList [ found ] ) assignList . splice ( found , 1 ) continue } } context . report ( { node , loc : getLocation ( node ) , message : "Unexpected access to 'module.exports'. Use 'exports' instead." , } ) } for ( const node of exportsNodes ) { if ( ! isAssignee ( node ) ) { continue } if ( batchAssignList . indexOf ( getTopAssignment ( node ) ) !== - 1 ) { continue } context . report ( { node , loc : getLocation ( node ) , message : "Unexpected assignment to 'exports'. Don't modify 'exports' itself." , } ) } }
3526	function makeCtor ( className ) { function constructor ( ) { return this . constructor . apply ( this , arguments ) || null ; } if ( className ) { constructor . displayName = className ; } return constructor ; }
2169	function selectedItemChange ( selectedItem , previousSelectedItem ) { updateModelValidators ( ) ; if ( selectedItem ) { getDisplayValue ( selectedItem ) . then ( function ( val ) { $scope . searchText = val ; handleSelectedItemChange ( selectedItem , previousSelectedItem ) ; } ) ; } else if ( previousSelectedItem && $scope . searchText ) { getDisplayValue ( previousSelectedItem ) . then ( function ( displayValue ) { if ( angular . isString ( $scope . searchText ) && displayValue . toString ( ) . toLowerCase ( ) === $scope . searchText . toLowerCase ( ) ) { $scope . searchText = '' ; } } ) ; } if ( selectedItem !== previousSelectedItem ) announceItemChange ( ) ; }
2139	function fail ( part , suiteIndex , testIndex , msg ) { if ( typeof testIndex === 'string' ) { msg = testIndex ; testIndex = undefined ; } var o ; var isSuite = false ; if ( typeof testIndex === 'number' ) { o = suites [ suiteIndex ] . tests [ testIndex ] ; if ( typeof msg === 'string' ) { suites [ suiteIndex ] . tests [ testIndex ] [ part ] . failmsg = msg ; } display . details ( 'test' , o ) ; } else { isSuite = true ; o = suites [ suiteIndex ] ; if ( typeof msg === 'string' ) { suites [ suiteIndex ] [ part ] . failmsg = msg ; } display . details ( 'suite' , o ) ; } display . fail ( part , o ) ; if ( part === 'takedown' ) { o . takedown . status = false ; if ( ( isSuite ) && ( ! o . abortOnFail ) ) { run ( 'setup' , o . next ) ; } else { run ( 'afterEach' , suiteIndex , testIndex ) ; } } else if ( part === 'afterEach' ) { o . afterEach . status = false ; if ( typeof o . parent . tests [ o . parent . testIndex ] === 'object' ) { if ( ! o . parent . abortOnFail ) { var ti = o . parent . testIndex ; o . parent . testIndex = o . parent . testIndex + 1 ; run ( 'beforeEach' , suiteIndex , ti ) ; } } else { run ( 'takedown' , suiteIndex ) ; } } else if ( part === 'beforeEach' ) { o . beforeEach . status = false ; run ( 'afterEach' , suiteIndex , testIndex ) ; } else if ( part === 'setup' ) { o . setup . status = false ; run ( 'takedown' , suiteIndex , testIndex ) ; } else if ( part === 'actual' ) { o . status = false ; if ( o . parent . abortOnFail ) { display . print ( 'test failed with abortOnFail set... aborting.' ) ; showSummary ( ) ; } run ( 'takedown' , suiteIndex , testIndex ) ; } else { throw new Error ( 'no part specified in run()' ) ; } }
1892	function ( name , value , description ) { var prefs = name ; if ( _ . isString ( name ) ) { prefs = { } ; prefs [ name ] = { value : value , description : description } ; } _ . each ( prefs , function ( v , k ) { defaults [ k ] = isValueObj ( v ) ? v : { value : v } ; } ) ; }
3806	function insert ( b , node , value ) { return updateNext ( b , node , cons ( b , value , readNext ( b , node ) ) ) }
3261	function toCamelcase ( val , strict ) { if ( strict === void 0 ) { strict = true ; } if ( ! strict || ! / \S+\.[^\.]\S+ / . test ( val ) ) return chek_1 . camelcase ( val ) ; return val ; }
3601	function _browserifyBundle ( ) { let bundler = browserifyBundler ( ) ; bundler = watchify ( bundler ) ; bundler . on ( 'update' , ( ) => _runBrowserifyBundle ( bundler ) ) ; return _runBrowserifyBundle ( bundler ) ; }
575	function warn ( msg ) { if ( PDFJS . verbosity >= PDFJS . VERBOSITY_LEVELS . warnings ) { console . log ( 'Warning: ' + msg ) ; } }
1760	function ( qName , type , offset , limit ) { var q = queue . get ( qName ) ; if ( ! ( offset >= 0 ) ) { offset = 0 ; } if ( ! ( limit >= 0 ) ) { limit = 30 ; } if ( type === 'wait' || type === 'active' ) { return q . getJobs ( type , 'LIST' , offset , offset + limit - 1 ) . then ( function ( jobs ) { return Promise . all ( _ . map ( jobs , function ( job ) { if ( ! job ) { return null ; } return job . getState ( ) . then ( function ( state ) { job . state = state ; return job ; } ) ; } ) ) ; } ) ; } else if ( type === 'delayed' ) { return q . getJobs ( type , 'ZSET' , offset , offset + limit - 1 ) . then ( function ( jobs ) { return Promise . all ( _ . map ( jobs , function ( job ) { if ( ! job ) { return null ; } return job . getState ( ) . then ( function ( state ) { job . state = state ; return job ; } ) ; } ) ) ; } ) ; } else if ( type === 'completed' || type === 'failed' ) { var client = redis . client ( ) ; var key = 'bull:' + qName + ':' + type ; return client . smembersAsync ( key ) . then ( function ( ids ) { var _ids = ids . slice ( offset , offset + limit ) ; return Promise . all ( _ . map ( _ids , function ( id ) { return q . getJob ( id ) . then ( function ( job ) { if ( ! job ) { return null ; } return job . getState ( ) . then ( function ( state ) { job . state = state ; return job ; } ) ; } ) ; } ) ) ; } ) ; } throw new Error ( 'You must provide a valid job type.' ) ; }
158	function transmitDraftId ( calypsoPort ) { if ( ! / wp-admin\/post-new.php / . test ( location . href ) ) { return ; } const unsubscribe = subscribe ( ( ) => { const currentPost = select ( 'core/editor' ) . getCurrentPost ( ) ; if ( currentPost && currentPost . id && currentPost . status !== 'auto-draft' ) { calypsoPort . postMessage ( { action : 'draftIdSet' , payload : { postId : currentPost . id } , } ) ; unsubscribe ( ) ; } } ) ; }
1001	function ( itemData ) { var newItems = this . items . concat ( itemData ) , rowWidthWithoutSpacing = this . width - ( newItems . length - 1 ) * this . spacing , newAspectRatio = newItems . reduce ( function ( sum , item ) { return sum + item . aspectRatio ; } , 0 ) , targetAspectRatio = rowWidthWithoutSpacing / this . targetRowHeight , previousRowWidthWithoutSpacing , previousAspectRatio , previousTargetAspectRatio ; if ( this . isBreakoutRow ) { if ( this . items . length === 0 ) { if ( itemData . aspectRatio >= 1 ) { this . items . push ( itemData ) ; this . completeLayout ( rowWidthWithoutSpacing / itemData . aspectRatio , 'justify' ) ; return true ; } } } if ( newAspectRatio < this . minAspectRatio ) { this . items . push ( merge ( itemData ) ) ; return true ; } else if ( newAspectRatio > this . maxAspectRatio ) { if ( this . items . length === 0 ) { this . items . push ( merge ( itemData ) ) ; this . completeLayout ( rowWidthWithoutSpacing / newAspectRatio , 'justify' ) ; return true ; } previousRowWidthWithoutSpacing = this . width - ( this . items . length - 1 ) * this . spacing ; previousAspectRatio = this . items . reduce ( function ( sum , item ) { return sum + item . aspectRatio ; } , 0 ) ; previousTargetAspectRatio = previousRowWidthWithoutSpacing / this . targetRowHeight ; if ( Math . abs ( newAspectRatio - targetAspectRatio ) > Math . abs ( previousAspectRatio - previousTargetAspectRatio ) ) { this . completeLayout ( previousRowWidthWithoutSpacing / previousAspectRatio , 'justify' ) ; return false ; } else { this . items . push ( merge ( itemData ) ) ; this . completeLayout ( rowWidthWithoutSpacing / newAspectRatio , 'justify' ) ; return true ; } } else { this . items . push ( merge ( itemData ) ) ; this . completeLayout ( rowWidthWithoutSpacing / newAspectRatio , 'justify' ) ; return true ; } }
3718	function forEach ( declarations , reqName , callback ) { var d ; if ( reqName === "*" ) { for ( d in declarations ) { callback . call ( this , d ) ; } } else if ( reqName . charAt ( reqName . length - 1 ) === "*" ) { var baseName = reqName . substring ( 0 , reqName . length - 1 ) ; for ( d in declarations ) { if ( d . indexOf ( baseName ) === 0 ) { callback . call ( this , d ) ; } } } else { if ( declarations [ reqName ] ) { callback . call ( this , reqName ) ; } else { error ( "Invalid dependency '" + reqName + "'" ) ; } } }
2736	function ( options ) { var objects = [ ] for ( var id in this . cache ) { objects . push ( this . cache [ id ] ) } this . cache = { } return objects }
252	function transferStatus ( siteId , transferId , status , message , themeId ) { return { type : THEME_TRANSFER_STATUS_RECEIVE , siteId , transferId , status , message , themeId , } ; }
3627	function MerchantCalculations ( objGoogleCheckout ) { var self = this ; assert . ok ( objGoogleCheckout , "A GoogleCheckout object is the only required argument" ) ; self . gc = objGoogleCheckout ; self . settings = self . gc . settings ; }
1044	function getOffset ( cursor , defaultOffset ) { if ( typeof cursor === 'undefined' || cursor === null ) { return defaultOffset ; } let offset = cursorToOffset ( cursor ) ; if ( isNaN ( offset ) ) { return defaultOffset ; } return offset ; }
212	function updateLastSeenTime ( proposedTime , fromStorage ) { let fromNote = false ; let mostRecentNoteTime = 0 ; if ( proposedTime > 1123473600000 ) { proposedTime = proposedTime / 1000 ; } debug ( 'updateLastSeenTime 0' , { proposedTime : proposedTime , fromStorage : fromStorage , lastSeenTime : this . lastSeenTime , } ) ; if ( fromStorage ) { if ( proposedTime <= this . lastSeenTime ) { return false ; } this . lastSeenTime = proposedTime ; return true ; } const notes = getAllNotes ( store . getState ( ) ) ; if ( notes . length ) { mostRecentNoteTime = Date . parse ( notes [ 0 ] . timestamp ) / 1000 ; } debug ( 'updateLastSeenTime 1' , { proposedTime : proposedTime , showing : this . showing , visible : this . visible , lastSeenTime : this . lastSeenTime , mostRecentNoteTime : mostRecentNoteTime , } ) ; if ( this . isShowing && this . isVisible && mostRecentNoteTime > proposedTime ) { proposedTime = mostRecentNoteTime ; fromNote = true ; } debug ( 'updateLastSeenTime 2' , { proposedTime : proposedTime , fromNote : fromNote , oldNews : proposedTime <= this . lastSeenTime , } ) ; if ( proposedTime <= this . lastSeenTime ) { return false ; } this . lastSeenTime = proposedTime ; try { localStorage . setItem ( 'notesLastMarkedSeen' , this . lastSeenTime ) ; } catch ( e ) { } if ( fromNote ) { debug ( 'updateLastSeenTime 3' , this . lastSeenTime ) ; sendLastSeenTime ( this . lastSeenTime ) ; } return true ; }
875	function getEnginesNode ( filename ) { const info = getPackageJson ( filename ) return getSemverRange ( info && info . engines && info . engines . node ) }
2688	function createExecuteErrorResponseMessage ( parentMessage , executionCount , error , traceback ) { var content = { status : 'error' , execution_count : executionCount , ename : error . constructor . name , evalue : error . toString ( ) , traceback : traceback } ; return newMessage ( _messageNames . executeResponse , parentMessage , content ) ; }
1359	function getExe ( ) { switch ( process . platform ) { case "darwin" : return "mkcert-" + MKCERT_VERSION + "-darwin-amd64" case "linux" : return "mkcert-" + MKCERT_VERSION + "-linux-amd64" case "win32" : return "mkcert-" + MKCERT_VERSION + "-windows-amd64.exe" default : console . warn ( "Cannot generate the localhost certificate on your " + "platform. Please, consider contacting the developer if you can help." ) process . exit ( 0 ) } }
429	function hasFakeRuleset ( atRuleNode ) { var bodyRules = atRuleNode . rules ; return bodyRules . length === 1 && ( ! bodyRules [ 0 ] . paths || bodyRules [ 0 ] . paths . length === 0 ) ; }
2515	function getFileItem ( fileId , stat , filePath ) { return { id : fileId , fullPath : filePath , name : getName ( fileId , ! stat . isDirectory ( ) ) , ancestors : getPathAncestors ( fileId ) , isDir : stat . isDirectory ( ) , isFile : ! stat . isDirectory ( ) , ext : ! stat . isDirectory ( ) ? getExt ( fileId ) : null , modifiedDT : stat . mtime , createdDT : stat . birthtime , size : stat . size } ; }
3266	function isArgVariadicRequired ( val , variadic ) { variadic = variadic || constants_1 . VARIADIC_CHAR ; return isArgRequired ( val ) && val . endsWith ( variadic + '>' ) ; }
695	function ( kb , subject ) { if ( kb . updater . editable ( subject . doc ( ) , kb ) ) return subject . doc ( ) var store = kb . any ( subject . doc ( ) , QU ( 'annotationStore' ) ) return store }
368	function writeOutputHTML ( dir , html ) { const outputPath = pathJoin ( dir , 'index.html' ) ; mkdirp . sync ( path . dirname ( outputPath ) ) ; writeFileSync ( outputPath , serialize ( html ) ) ; }
208	function updateReceiptState ( state , receiptId , attributes ) { return Object . assign ( { } , state , { [ receiptId ] : Object . assign ( { } , initialReceiptState , state [ receiptId ] , attributes ) , } ) ; }
1704	function _goToSequence ( viewSequence , next , noAnimation ) { if ( noAnimation ) { this . _viewSequence = viewSequence ; this . _scroll . springPosition = undefined ; _updateSpring . call ( this ) ; this . halt ( ) ; this . _scroll . scrollDelta = 0 ; _setParticle . call ( this , 0 , 0 , '_goToSequence' ) ; this . _scroll . scrollDirty = true ; } else { this . _scroll . scrollToSequence = viewSequence ; this . _scroll . scrollToRenderNode = viewSequence . get ( ) ; this . _scroll . ensureVisibleRenderNode = undefined ; this . _scroll . scrollToDirection = next ; this . _scroll . scrollDirty = true ; } }
2733	function ( objects , options ) { var idSet = new Set ( objects . map ( function ( object ) { return object . _id } ) ) if ( idSet . length < objects . length ) { throw new this . getService ( ) . errors . BadRequest ( 'Duplicate IDs' ) } this . cache = objects return objects }
615	function calculateOccurrences ( wordCombinations ) { const occurrences = { } ; forEach ( wordCombinations , function ( wordCombination ) { const combination = wordCombination . getCombination ( ) ; if ( ! has ( occurrences , combination ) ) { occurrences [ combination ] = wordCombination ; } occurrences [ combination ] . incrementOccurrences ( ) ; } ) ; return values ( occurrences ) ; }
3197	function file_path ( ) { pending ++ for ( var i = globs . length ; i -- ; ) { const glob = globs [ i ] const glob_full = glob . glob const glob_base = glob . base const glob_negated = glob . negated const glob_pattern = glob . pattern if ( entry === glob_full || mm . isMatch ( entry , glob_pattern , ALLOW ) ) { return done ( null , file ) } } pending -- done ( null , null ) }
2840	function ( payload , next ) { jira . getProject ( options . project , handleGetProject ( options , payload , next ) ) ; }
2789	function hasChanged ( newData , oldData ) { var changed = false for ( var i = 0 ; i < scope . length ; i ++ ) { var k = scope [ i ] , newVal = _ . get ( newData , k ) , oldVal = _ . get ( oldData , k ) if ( ! _ . isEqual ( newVal , oldVal ) ) { changed = true break } } return changed }
193	function updatedAction ( siteId , originatingAction , successAction , sentData ) { return ( dispatch , getState , { data : receivedData } ) => { dispatch ( productUpdated ( siteId , receivedData , originatingAction ) ) ; const props = { sentData , receivedData } ; dispatchWithProps ( dispatch , getState , successAction , props ) ; } ; }
634	function createWorker ( url ) { let worker = null ; try { worker = new Worker ( url ) ; } catch ( e ) { try { const blobUrl = createBlobURL ( url ) ; worker = new Worker ( blobUrl ) ; } catch ( e2 ) { throw e2 ; } } return worker ; }
2649	function handshake ( param ) { return new Promise ( ( resolve , reject ) => { if ( types . isClientConfig ( param ) ) { logger_1 . logger . log ( 'info' , ` ` ) ; logger_1 . logger . log ( 'debug' , ` \n ${ JSON . stringify ( param ) } ` ) ; let socket = io . connect ( ` ${ param . warehouseAddress } ${ param . portSocket } ` ) ; socket . on ( 'connect' , function ( ) { logger_1 . logger . log ( 'info' , ` \n ` ) ; resolve ( ) ; } ) . on ( 'connect_error' , function ( ) { logger_1 . logger . log ( 'debug' , ` \n ` ) ; reject ( ) ; socket . disconnect ( ) ; } ) ; } else { logger_1 . logger . log ( 'error' , ` \n ${ JSON . stringify ( config ) } ` ) ; reject ( ) ; } } ) ; }
438	function getDomainFromMinMax ( min , max ) { const getSinglePointDomain = ( val ) => { const verySmallNumber = val === 0 ? 2 * Math . pow ( 10 , - 10 ) : Math . pow ( 10 , - 10 ) ; const verySmallDate = 1 ; const minVal = val instanceof Date ? new Date ( + val - verySmallDate ) : + val - verySmallNumber ; const maxVal = val instanceof Date ? new Date ( + val + verySmallDate ) : + val + verySmallNumber ; return val === 0 ? [ 0 , maxVal ] : [ minVal , maxVal ] ; } ; return + min === + max ? getSinglePointDomain ( max ) : [ min , max ] ; }
3338	function ( model , req ) { if ( ! model ) return { } var fields = { } , queryFieldSet if ( req ) { if ( req . fieldSet ) { queryFieldSet = { } try { queryFieldSet = JSON . parse ( req . fieldSet ) } catch ( e ) { queryFieldSet = null } } else if ( req . urlparams && req . urlparams [ 1 ] ) { queryFieldSet = { } var x = req . urlparams [ 1 ] . split ( ',' ) for ( var i = 0 ; i < x . length ; i ++ ) queryFieldSet [ x [ i ] ] = 1 } } for ( var i in model . fields ) if ( model . fields [ i ] && model . fields [ i ] . visable ) { if ( ! queryFieldSet || queryFieldSet [ model . fields [ i ] . name ] ) fields [ model . fields [ i ] . name ] = 1 } return fields ; }
2415	function parseImports ( data , file , extensions ) { const imports = [ ] ; let result = importRegExp . exec ( data ) ; let encoding ; while ( result !== null ) { encoding = extensions [ path . extname ( result [ 2 ] ) ] ; if ( encoding !== undefined ) { imports . push ( new FileImport ( result . index , importRegExp . lastIndex , result [ 1 ] , path . resolve ( path . dirname ( file ) , result [ 2 ] ) , encoding ) ) ; } result = importRegExp . exec ( data ) ; } return Promise . resolve ( [ imports , data ] ) ; }
962	function fetchData ( url , options ) { let { method = 'GET' } = options || { } ; method = method . toUpperCase ( ) ; return httpApi . request ( Object . assign ( { url } , options , { method } ) ) ; }
3269	function stripVariadic ( val , variadic ) { variadic = escape ( variadic || constants_1 . VARIADIC_CHAR ) ; var exp = new RegExp ( variadic + '$' ) ; return val . replace ( exp , '' ) ; }
3131	function ( ) { var me = this , copy = new this . self ( me . initialConfig ) ; copy . add ( me . keys , me . items ) ; return copy ; }
3228	function ( ) { var me = this , i = 0 , items = me . items , surface = me . getSurface ( ) , len = me . length ; if ( surface ) { for ( ; i < len ; i ++ ) { surface . renderItem ( items [ i ] ) ; } } return me ; }
951	function makePropsObservable ( ctx ) { let props = ctx . $rawProps ; if ( typeof props === 'function' ) { props = ctx . $rawProps = props ( ) ; } if ( ! props ) { return ; } let observer = new Observer ( ctx , ctx [ propDataKey ] || { } , null , true ) ; let propsObj = { } ; Object . keys ( props ) . reduce ( ( last , item ) => { last [ item ] = true ; return last ; } , propsObj ) ; Object . defineProperties ( ctx , proxyObject ( observer , propsObj ) ) ; return observer ; }
1683	function generateNonce ( length ) { return generateSecureRandom ( length ) . then ( ( nonce ) => { const nonceString = base64js . fromByteArray ( nonce ) ; return nonceString ; } ) ; }
3752	function genParam ( param ) { var res = { name : param . name || '' , description : param . description || '' , optional : ! ! param . optional } ; if ( param . type ) { res . types = param . type . names . slice ( 0 ) ; } if ( param . defaultvalue ) { res [ 'default' ] = param . defaultvalue ; } return res ; }
2763	function next ( ) { var middleware = chain . shift ( ) ; if ( middleware && typeof middleware === 'function' ) { middleware . call ( this , context , next ) ; } return this ; }
1030	function ( path ) { var url = 'https://api.dropboxapi.com/2/sharing/create_shared_link_with_settings' ; var options = { body : { path : getDropboxPath ( path ) } } ; return this . _request ( 'POST' , url , options ) . then ( ( response ) => { if ( response . status !== 200 && response . status !== 409 ) { return Promise . reject ( new Error ( 'Invalid response status:' + response . status ) ) ; } var body ; try { body = JSON . parse ( response . responseText ) ; } catch ( e ) { return Promise . reject ( new Error ( 'Invalid response body: ' + response . responseText ) ) ; } if ( response . status === 409 ) { if ( compareApiError ( body , [ 'shared_link_already_exists' ] ) ) { return this . _getSharedLink ( path ) ; } return Promise . reject ( new Error ( 'API error: ' + body . error_summary ) ) ; } return Promise . resolve ( body . url ) ; } ) . then ( ( link ) => { this . _itemRefs [ path ] = link ; if ( hasLocalStorage ) { localStorage . setItem ( SETTINGS_KEY + ':shares' , JSON . stringify ( this . _itemRefs ) ) ; } return Promise . resolve ( link ) ; } , ( error ) => { error . message = 'Sharing Dropbox file or folder ("' + path + '") failed: ' + error . message ; return Promise . reject ( error ) ; } ) ; }
815	function create_script_load_listener ( elem , registry_item , flag , onload ) { elem . onload = elem . onreadystatechange = function ( ) { if ( ( elem . readyState && elem . readyState != "complete" && elem . readyState != "loaded" ) || registry_item [ flag ] ) return ; elem . onload = elem . onreadystatechange = null ; onload ( ) ; } ; }
550	function extraIndentProperty ( nodes , i ) { var subset = [ ] ; while ( i -- ) { if ( ! nodes . get ( i ) || nodes . get ( i ) . is ( 'declarationDelimiter' ) ) break ; subset . unshift ( nodes . get ( i ) ) ; } return extraIndent ( subset ) ; }
3834	function emitValue ( ) { var arr = toArray ( ) ; marker = arr [ arr . length - 1 ] ; setTimeout ( function ( ) { emitter . emit ( 'value' , arr ) ; } , 0 ) ; }
499	function ( runState , cb ) { const number = runState . stack . pop ( ) var blockchain = runState . blockchain var diff = new BN ( runState . block . header . number ) . sub ( number ) if ( diff . gtn ( 256 ) || diff . lten ( 0 ) ) { runState . stack . push ( new BN ( 0 ) ) cb ( null ) return } blockchain . getBlock ( number , function ( err , block ) { if ( err ) return cb ( err ) const blockHash = new BN ( block . hash ( ) ) runState . stack . push ( blockHash ) cb ( null ) } ) }
988	function ( opts ) { opts = opts || { } ; const defaults = { girderToken : getCurrentToken ( ) || cookie . find ( 'girderToken' ) , error : ( error , status ) => { let info ; if ( error . status === 401 ) { events . trigger ( 'g:loginUi' ) ; info = { text : 'You must log in to view this resource' , type : 'warning' , timeout : 4000 , icon : 'info' } ; } else if ( error . status === 403 ) { info = { text : 'Access denied. See the console for more details.' , type : 'danger' , timeout : 5000 , icon : 'attention' } ; } else if ( error . status === 0 && error . statusText === 'abort' ) { return ; } else if ( error . status === 500 && error . responseJSON && error . responseJSON . type === 'girder' ) { info = { text : error . responseJSON . message , type : 'warning' , timeout : 5000 , icon : 'info' } ; } else if ( status === 'parsererror' ) { info = { text : 'A parser error occurred while communicating with the ' + 'server (did you use the correct value for `dataType`?). ' + 'Details have been logged in the console.' , type : 'danger' , timeout : 5000 , icon : 'attention' } ; } else { info = { text : 'An error occurred while communicating with the ' + 'server. Details have been logged in the console.' , type : 'danger' , timeout : 5000 , icon : 'attention' } ; } events . trigger ( 'g:alert' , info ) ; console . error ( error . status + ' ' + error . statusText , error . responseText ) ; } } ; const args = _ . extend ( { } , defaults , opts ) ; if ( ! args . url ) { throw new Error ( 'restRequest requires a "url" argument' ) ; } args . url = ` ${ getApiRoot ( ) } ${ args . url . substring ( 0 , 1 ) === '/' ? '' : '/' } ${ args . url } ` ; if ( args . girderToken ) { args . headers = args . headers || { } ; args . headers [ 'Girder-Token' ] = args . girderToken ; delete args . girderToken ; } return Backbone . $ . ajax ( args ) ; }
1898	function ( value , start , end ) { var r = range ( start , _ . isUndefined ( end ) ? 0 : end - start ) ; var delta = value . length - r . length ( ) ; var update = function ( obj ) { _ . each ( obj , function ( v , k ) { if ( v >= r . end ) obj [ k ] += delta ; } ) ; } ; update ( this . _positions ) ; _ . each ( this . list ( ) , function ( item ) { update ( item . _positions ) ; } ) ; this . source = require ( 'utils' ) . replaceSubstring ( this . source , value , r ) ; }
139	function MailingList ( category , wpcom ) { if ( ! ( this instanceof MailingList ) ) { return new MailingList ( category , wpcom ) ; } this . _category = category ; this . wpcom = wpcom ; }
1248	function ( options ) { if ( typeof this === "function" ) { return new this ( options ) ; } this . tokens = tokens ; this . lexer = new lexer ( this ) ; this . ast = new AST ( ) ; this . parser = new parser ( this . lexer , this . ast ) ; if ( options && typeof options === "object" ) { if ( options . parser && options . parser . php7 === false ) { if ( ! options . lexer ) { options . lexer = { } ; } options . lexer . php7 = false ; } combine ( options , this ) ; } }
1008	function ( scope ) { var savedMap = { } ; var name ; for ( name in this . scopeModeMap ) { savedMap [ name ] = this . scopeModeMap [ name ] ; } this . reset ( ) ; delete savedMap [ scope ] ; for ( name in savedMap ) { this . set ( name , savedMap [ name ] ) ; } }
3463	function ( transaction , event ) { var success = ! ! event . status , funcName = success ? 'success' : 'failure' , callback , options , result ; if ( transaction && transaction . callback ) { callback = transaction . callback ; options = transaction . callbackOptions ; result = typeof event . result !== 'undefined' ? event . result : event . data ; if ( Ext . isFunction ( callback ) ) { callback ( result , event , success , options ) ; } else { Ext . callback ( callback [ funcName ] , callback . scope , [ result , event , success , options ] ) ; Ext . callback ( callback . callback , callback . scope , [ result , event , success , options ] ) ; } } }
3368	function ( ) { var self = this , storage = self . storage , content ; if ( storage ) { content = storage . getItem ( self . key ) ; if ( content ) { self . editor . setContent ( content ) ; self . onRestoreDraft . dispatch ( self , { content : content } ) ; } } }
710	function ( subject ) { var kb = UI . store var ns = UI . ns var t = kb . findTypeURIs ( subject ) if ( t [ ns . ldp ( 'Container' ) . uri ] || t [ ns . ldp ( 'BasicContainer' ) . uri ] ) { var contents = kb . each ( subject , ns . ldp ( 'contains' ) ) var count = 0 contents . map ( function ( file ) { if ( UI . widgets . isImage ( file ) ) count ++ } ) return count > 0 ? 'Slideshow' : null } return null }
3674	function ReadpixelCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 2 ) throw new SyntaxError ( 'READPIXEL command requires 2 arguments' ) ; this . x = parsed . args [ 0 ] ; this . y = parsed . args [ 1 ] ; }
1538	function collateStrings ( a , b ) { var aValue , bValue , aChar , bChar , aEquiv , bEquiv , index = 0 , tiebreaker = 0 ; a = getCollationReadyString ( a ) ; b = getCollationReadyString ( b ) ; do { aChar = getCollationCharacter ( a , index ) ; bChar = getCollationCharacter ( b , index ) ; aValue = getCollationValue ( aChar ) ; bValue = getCollationValue ( bChar ) ; if ( aValue === - 1 || bValue === - 1 ) { aValue = a . charCodeAt ( index ) || null ; bValue = b . charCodeAt ( index ) || null ; } aEquiv = aChar !== a . charAt ( index ) ; bEquiv = bChar !== b . charAt ( index ) ; if ( aEquiv !== bEquiv && tiebreaker === 0 ) { tiebreaker = aEquiv - bEquiv ; } index += 1 ; } while ( aValue != null && bValue != null && aValue === bValue ) ; if ( aValue === bValue ) return tiebreaker ; return aValue < bValue ? - 1 : 1 ; }
789	function updateURL ( ) { try { window . history . replaceState ( { } , null , '#' + currentPosition ( ) ) ; } catch ( e ) { window . location . hash = currentPosition ( ) ; } }
2381	function DatasetClientsCleaner ( opts ) { this . retentionPeriod = opts . retentionPeriod || '24h' ; this . checkFrequency = opts . checkFrequency || '1h' ; this . cleanerLockName = opts . cleanerLockName || 'locks:sync:DatasetCleaner' ; this . lockTimeout = parseDuration ( this . checkFrequency ) / 2 ; this . job ; }
2258	function register ( ports , log ) { ports . storageGetItem . subscribe ( storageGetItem ) ; ports . storageSetItem . subscribe ( storageSetItem ) ; ports . storageRemoveItem . subscribe ( storageRemoveItem ) ; ports . storageClear . subscribe ( storageClear ) ; ports . storagePushToSet . subscribe ( storagePushToSet ) ; ports . storageRemoveFromSet . subscribe ( storageRemoveFromSet ) ; storageEventListenerPorts . push ( ports ) ; log = log || function ( ) { } ; function storageGetItem ( key ) { log ( 'storageGetItem' , key ) ; const response = getLocalStorageItem ( key ) ; log ( 'storageGetItemResponse' , key , response ) ; ports . storageGetItemResponse . send ( [ key , response ] ) ; } function storageSetItem ( [ key , value ] ) { log ( 'storageSetItem' , key , value ) ; setLocalStorageItem ( key , value ) ; } function storageRemoveItem ( key ) { log ( 'storageRemoveItem' , key ) ; window . localStorage . removeItem ( key ) ; } function storageClear ( ) { log ( 'storageClear' ) ; window . localStorage . clear ( ) ; } function storagePushToSet ( [ key , value ] ) { log ( 'storagePushToSet' , key , value ) ; const item = getLocalStorageItem ( key ) ; const list = Array . isArray ( item ) ? item : [ ] ; if ( list . indexOf ( value ) === - 1 ) { list . push ( value ) ; } setLocalStorageItem ( key , list ) ; } function storageRemoveFromSet ( [ key , value ] ) { log ( 'storageRemoveFromSet' , key , value ) ; const list = getLocalStorageItem ( key ) ; if ( ! Array . isArray ( list ) ) { log ( 'storageRemoveFromSet [aborting; not a list]' , key , value , list ) ; return ; } const jsonValue = JSON . stringify ( value ) ; const updatedSet = list . filter ( item => jsonValue !== JSON . stringify ( item ) ) ; setLocalStorageItem ( key , updatedSet ) ; } }
491	function attrAndStyleCheck ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } if ( args . length > 2 ) { return [ 'set' ] . concat ( args ) ; } if ( args . length === 2 ) { if ( [ 'video' , 'container' , 'wrapper' , 'videoElement' ] . indexOf ( args [ 0 ] ) > - 1 ) { return [ 'get' ] . concat ( args ) ; } return [ 'set' , 'container' ] . concat ( args ) ; } return [ 'get' , 'container' ] . concat ( args ) ; }
2104	function initBLModel ( req , res , cb ) { let modelName = config . model ; if ( req . soajs . servicesConfig && req . soajs . servicesConfig . model ) { modelName = req . soajs . servicesConfig . model ; } if ( process . env . SOAJS_TEST && req . soajs . inputmaskData . model ) { modelName = req . soajs . inputmaskData . model ; } BLModule . init ( modelName , function ( error , BL ) { if ( error ) { req . soajs . log . error ( error ) ; return res . json ( req . soajs . buildResponse ( { "code" : 601 , "msg" : config . errors [ 601 ] } ) ) ; } else { return cb ( BL ) ; } } ) ; }
3744	function nextLine ( context , ast , prompt , oldPrompt , forceCursor , eval ) { rl . question ( prompt , function ( answer ) { eval ( answer , context , ast , forceCursor === - 1 ? ast . root . length : forceCursor , function ( newPrompt , newCursor ) { nextLine ( context , ast , newPrompt || oldPrompt , oldPrompt , typeof newCursor === 'undefined' ? - 1 : newCursor , eval ) ; } ) ; } ) ; }
3693	function typeForExtend ( val ) { let type = getType ( val ) ; if ( type === types . function || ! typeset . has ( type ) && type && type . constructor ) type = types . object ; return type ; }
2410	function inline ( config , files ) { return new Promise ( ( resolve , reject ) => { let filesChanged = 0 ; let i = 0 ; ( function proceed ( result ) { if ( result ) { filesChanged ++ ; } if ( i === files . length ) { resolve ( "Modified " + filesChanged + " files" ) ; } else { InlineImport . transform ( files [ i ++ ] , config . options ) . then ( proceed ) . catch ( reject ) ; } } ( ) ) ; } ) ; }
1139	function pluck ( collection , property ) { var index = - 1 , length = collection ? collection . length : 0 ; if ( typeof length == 'number' ) { var result = Array ( length ) ; while ( ++ index < length ) { result [ index ] = collection [ index ] [ property ] ; } } return result || map ( collection , property ) ; }
1174	function ( command ) { return _ . isArray ( command ) ? _ . find ( command , function ( singleCmd ) { return ! this . _validateCommand ( singleCmd ) ; } , this ) : this . _validateCommand ( command ) ; }
3082	function ( walk ) { if ( ! walk . at ( '{{' ) ) return false ; var endIdx = walk . indexOf ( ']}' ) ; if ( endIdx === null ) return false ; var str = walk . substring ( walk . position + 2 , endIdx ) ; var data = str . split ( '}[' ) ; if ( data . length != 2 ) return false ; var size = data [ 0 ] . length ; var value = data [ 0 ] . trim ( ) ; var defaultValue = data [ 1 ] . trim ( ) ; if ( ! defaultValue ) return false ; var ctl = this . formCompiler . createCtl ( 'inputText' ) ; ctl . value = value ; ctl . defaultValue = defaultValue ; this . out . push ( '<input' ) ; this . emitAttrs ( { id : ctl . id , name : ctl . id , class : ctl . type , type : 'text' , size : size , value : defaultValue } ) ; this . out . push ( '/>' ) ; walk . startFrom ( endIdx ) . skip ( 2 ) ; }
1932	function ( abbr , value , syntax ) { syntax = syntax || 'css' ; var resources = require ( 'resources' ) ; var autoInsertPrefixes = prefs . get ( 'css.autoInsertVendorPrefixes' ) ; var isImportant ; if ( isImportant = / ^(.+)\!$ / . test ( abbr ) ) { abbr = RegExp . $1 ; } var snippet = resources . findSnippet ( syntax , abbr ) ; if ( snippet && ! autoInsertPrefixes ) { return transformSnippet ( snippet , isImportant , syntax ) ; } var prefixData = this . extractPrefixes ( abbr ) ; var valuesData = this . extractValues ( prefixData . property ) ; var abbrData = _ . extend ( prefixData , valuesData ) ; if ( ! snippet ) { snippet = resources . findSnippet ( syntax , abbrData . property ) ; } else { abbrData . values = null ; } if ( ! snippet && prefs . get ( 'css.fuzzySearch' ) ) { snippet = resources . fuzzyFindSnippet ( syntax , abbrData . property , parseFloat ( prefs . get ( 'css.fuzzySearchMinScore' ) ) ) ; } if ( ! snippet ) { snippet = abbrData . property + ':' + defaultValue ; } else if ( ! _ . isString ( snippet ) ) { snippet = snippet . data ; } if ( ! isSingleProperty ( snippet ) ) { return snippet ; } var snippetObj = this . splitSnippet ( snippet ) ; var result = [ ] ; if ( ! value && abbrData . values ) { value = _ . map ( abbrData . values , function ( val ) { return this . normalizeValue ( val , snippetObj . name ) ; } , this ) . join ( ' ' ) + ';' ; } snippetObj . value = value || snippetObj . value ; var prefixes = abbrData . prefixes == 'all' || ( ! abbrData . prefixes && autoInsertPrefixes ) ? findPrefixes ( snippetObj . name , autoInsertPrefixes && abbrData . prefixes != 'all' ) : abbrData . prefixes ; var names = [ ] , propName ; _ . each ( prefixes , function ( p ) { if ( p in vendorPrefixes ) { propName = vendorPrefixes [ p ] . transformName ( snippetObj . name ) ; names . push ( propName ) ; result . push ( transformSnippet ( propName + ':' + snippetObj . value , isImportant , syntax ) ) ; } } ) ; result . push ( transformSnippet ( snippetObj . name + ':' + snippetObj . value , isImportant , syntax ) ) ; names . push ( snippetObj . name ) ; if ( prefs . get ( 'css.alignVendor' ) ) { var pads = require ( 'utils' ) . getStringsPads ( names ) ; result = _ . map ( result , function ( prop , i ) { return pads [ i ] + prop ; } ) ; } return result ; }
933	function initProcessorInfo ( name , info , existedProcessors ) { let processor = info . processor ; if ( ! processor ) { return info ; } if ( typeof processor === 'string' ) { let old = existedProcessors [ processor ] ; if ( old ) { info . processor = undefined ; info = removeUndefinedAttributes ( info ) ; let deps = info . deps ; deps && ! Array . isArray ( deps ) && ( deps = [ deps ] ) ; let oldDeps = old . deps ; oldDeps && ! Array . isArray ( oldDeps ) && ( oldDeps = [ oldDeps ] ) ; info = Object . assign ( { } , old , info ) ; info . deps = merge ( deps || [ ] , oldDeps || [ ] ) ; return Object . assign ( { refer : processor } , old , info ) ; } } try { info . processor = resolveProcessor ( processor ) ; } catch ( ex ) { let msg = ` \` ${ name } \` \` ${ processor } \` ` + ` ${ ex . message || ex . toString ( ) } ` ; throw new Error ( msg ) ; } return info ; }
2051	function sortPitches ( pitches ) { return pitches . map ( Pitch ) . sort ( function ( a , b ) { return a - b } ) . map ( function ( pitch ) { return pitch . sciPitch ( ) } ) }
2168	function gatherElements ( ) { var snapWrap = gatherSnapWrap ( ) ; elements = { main : $element [ 0 ] , scrollContainer : $element [ 0 ] . querySelector ( '.md-virtual-repeat-container' ) , scroller : $element [ 0 ] . querySelector ( '.md-virtual-repeat-scroller' ) , ul : $element . find ( 'ul' ) [ 0 ] , input : $element . find ( 'input' ) [ 0 ] , wrap : snapWrap . wrap , snap : snapWrap . snap , root : document . body } ; elements . li = elements . ul . getElementsByTagName ( 'li' ) ; elements . $ = getAngularElements ( elements ) ; inputModelCtrl = elements . $ . input . controller ( 'ngModel' ) ; }
3090	function ( values ) { var me = this , v , vLen , val , field ; function setVal ( fieldId , val ) { var field = me . findField ( fieldId ) ; if ( field ) { field . setValue ( val ) ; if ( me . trackResetOnLoad ) { field . resetOriginalValue ( ) ; } } } Ext . suspendLayouts ( ) ; if ( Ext . isArray ( values ) ) { vLen = values . length ; for ( v = 0 ; v < vLen ; v ++ ) { val = values [ v ] ; setVal ( val . id , val . value ) ; } } else { Ext . iterate ( values , setVal ) ; } Ext . resumeLayouts ( true ) ; return this ; }
1672	function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; result . ok ( simpleBtSppPlugin . getInstance ( ) . initialiseBluetooth ( ) , false ) ; }
1521	function numberOfNonSelfLinkingCycles ( node , id ) { var sourceCount = 0 node . sourceLinks . forEach ( function ( l ) { sourceCount = l . circular && ! selfLinking ( l , id ) ? sourceCount + 1 : sourceCount } ) var targetCount = 0 node . targetLinks . forEach ( function ( l ) { targetCount = l . circular && ! selfLinking ( l , id ) ? targetCount + 1 : targetCount } ) return sourceCount + targetCount }
2975	function TripCase ( options ) { if ( ! options || ! options . email || ! options . password ) throw 'Missing required options' ; this . email = options . email ; this . password = options . password ; this . session = null ; return this ; }
3180	function ( date , format ) { var formatFunctions = utilDate . formatFunctions ; if ( ! Ext . isDate ( date ) ) { return '' ; } if ( formatFunctions [ format ] == null ) { utilDate . createFormat ( format ) ; } return formatFunctions [ format ] . call ( date ) + '' ; }
2220	function FlashMiddleware ( req , res , next ) { if ( ! isObject ( req . session ) ) throw new Error ( 'express-session is required. (npm i express-session)' ) ; if ( ! req . session [ sessionName ] || ! isArray ( req . session [ sessionName ] ) ) req . session [ sessionName ] = [ ] ; req [ utilityName ] = function ( ) { const argc = arguments . length ; let notification ; let redirect = REDIRECT ; if ( argc ) { if ( argc === 1 ) { const arg = arguments [ 0 ] ; if ( isObject ( arg ) ) { notification = arg ; redirect = ( arg . redirect === undefined ) ? redirect : arg . redirect ; } else { notification = { message : '' + arg } ; } } else { notification = { type : '' + arguments [ 0 ] , message : '' + arguments [ 1 ] } ; redirect = ( arguments [ 2 ] === undefined ) ? redirect : arguments [ 2 ] ; } } if ( notification && req . session [ sessionName ] ) { req . session [ sessionName ] . push ( notification ) ; } if ( redirect ) { const redirectUrl = ( typeof redirect === 'string' ) ? redirect : req . originalUrl ; res . redirect ( redirectUrl ) ; } else { return function ManualRender ( callback ) { render ( req , res , callback ) ; } } } render ( req , res , next ) ; }
290	function setup ( ) { const app = express ( ) ; app . enable ( 'trust proxy' ) ; app . use ( cookieParser ( ) ) ; app . use ( userAgent . express ( ) ) ; if ( 'development' === process . env . NODE_ENV ) { if ( ! config . isEnabled ( 'css-hot-reload' ) ) { app . use ( build ( ) ) ; } require ( 'bundler' ) ( app ) ; app . use ( morgan ( 'dev' ) ) ; if ( config . isEnabled ( 'wpcom-user-bootstrap' ) ) { if ( config ( 'wordpress_logged_in_cookie' ) ) { const username = config ( 'wordpress_logged_in_cookie' ) . split ( '%7C' ) [ 0 ] ; console . info ( chalk . cyan ( '\nYour logged in cookie set to user: ' + \n ) ) ; username } else app . use ( function ( req , res , next ) { if ( ! req . cookies . wordpress_logged_in ) { req . cookies . wordpress_logged_in = config ( 'wordpress_logged_in_cookie' ) ; } next ( ) ; } ) ; } } else { console . info ( chalk . red ( '\nYou need to set `wordpress_logged_in_cookie` in secrets.json' + \n ) ) ; } ' for wpcom-user-bootstrap to work in development.' { app . use ( morgan ( 'combined' ) ) ; } app . use ( pwa ( ) ) ; app . use ( '/calypso' , express . static ( path . resolve ( __dirname , '..' , '..' , 'public' ) ) ) ; app . get ( '/nostats.js' , function ( request , response ) { analytics . tracks . recordEvent ( 'calypso_stats_blocked' , { do_not_track : request . headers . dnt , } , request ) ; response . setHeader ( 'content-type' , 'application/javascript' ) ; response . end ( "console.log('Stats are disabled');" ) ; } ) ; if ( 'development' === process . env . NODE_ENV ) { app . use ( '/assets' , express . static ( path . resolve ( __dirname , '..' , '..' , 'assets' ) ) ) ; app . use ( '/client' , express . static ( path . resolve ( __dirname , '..' , '..' , 'client' ) ) ) ; } if ( config . isEnabled ( 'devdocs' ) ) { app . use ( require ( 'devdocs' ) ( ) ) ; } if ( config . isEnabled ( 'desktop' ) ) { app . use ( '/desktop' , express . static ( path . resolve ( __dirname , '..' , '..' , '..' , 'public_desktop' ) ) ) ; } app . use ( require ( 'api' ) ( ) ) ; }
33	function ( imgData ) { var doc = new jsPDF ( ) ; doc . addImage ( imgData , 'JPEG' , 10 , 10 , 50 , 50 ) ; doc . addImage ( imgData , 'JPEG' , 70 , 10 , 100 , 120 ) ; doc . save ( 'output.pdf' ) ; }
25	function OffPushDown ( formObject ) { var xobj = createFormXObject ( formObject ) ; var stream = [ ] ; stream . push ( "0.749023 g" ) ; stream . push ( "0 0 " + f2 ( AcroFormAppearance . internal . getWidth ( formObject ) ) + " " + f2 ( AcroFormAppearance . internal . getHeight ( formObject ) ) + " re" ) ; stream . push ( "f" ) ; xobj . stream = stream . join ( "\n" ) ; \n }
1334	function astTraverse ( root , options = { } ) { const pre = options . pre ; const post = options . post ; const skipProperty = options . skipProperty ; function visit ( node , parent , prop , idx ) { if ( ! node || typeof node . type !== 'string' ) { return ; } let res = undefined ; if ( pre ) { res = pre ( node , parent , prop , idx ) ; } if ( res !== false ) { if ( parent && parent [ prop ] ) { if ( ! isNaN ( idx ) ) { node = parent [ prop ] [ idx ] ; } else { node = parent [ prop ] ; } } for ( let prop in node ) if ( node . hasOwnProperty ( prop ) ) { if ( skipProperty ? skipProperty ( prop , node ) : prop [ 0 ] === '$' ) { continue ; } const child = node [ prop ] ; if ( Array . isArray ( child ) ) { let index = 0 ; NodePath . traversingIndexStack . push ( index ) ; while ( index < child . length ) { visit ( child [ index ] , node , prop , index ) ; index = NodePath . updateTraversingIndex ( + 1 ) ; } NodePath . traversingIndexStack . pop ( ) ; } else { visit ( child , node , prop ) ; } } } if ( post ) { post ( node , parent , prop , idx ) ; } } visit ( root , null ) ; }
2636	function copyAssetToContext ( src , dest , context ) { var sourceAsset = path . join ( testDir , src ) ; var targetAsset = path . join ( context . dir , dest ) ; if ( ! fs . existsSync ( sourceAsset ) ) { throw new Error ( "The test asset is missing" ) ; } fs . copySync ( sourceAsset , targetAsset ) ; if ( ! fs . existsSync ( targetAsset ) ) { throw new Error ( "The test asset could not be copied" ) ; } }
3753	function genProperty ( members , name ) { var res = { name : name , deprecated : false , description : '' , types : [ ] } ; members . filter ( { kind : 'member' , name : name } ) . each ( function ( doclet ) { if ( doclet . description ) { res . description += doclet . description + '\n' ; } \n if ( ! res . access ) { res . access = doclet . access ; } if ( ! res . scope ) { res . scope = doclet . scope ; } if ( doclet . deprected ) { res . deprecated = true ; } } ) ; if ( res . types . length === 0 && doclet . type ) { res . types = doclet . type . names . slice ( 0 ) ; } res . scope = res . scope || 'instance' ; res . access = res . acccess || 'public' ; }
1211	function getParameterMap ( parameters ) { if ( parameters == null ) { return { } ; } if ( typeof parameters != "object" ) { return OAuth . getParameterMap ( OAuth . decodeForm ( parameters + "" ) ) ; } if ( parameters instanceof Array ) { var map = { } ; for ( var p = 0 ; p < parameters . length ; ++ p ) { var key = parameters [ p ] [ 0 ] ; if ( map [ key ] === undefined ) { map [ key ] = parameters [ p ] [ 1 ] ; } } return map ; } return parameters ; }
469	function ( it ) { if ( FREEZE && meta . NEED && isExtensible ( it ) && ! _has ( it , META ) ) setMeta ( it ) ; return it ; }
3757	function RegexFinderStrategy ( config ) { config = config || { } ; FinderStrategy . call ( this , config ) ; this . config = extend ( true , this . config , { } , config ) ; }
2750	function resolveBot ( bot ) { let isWaterfall = ( "function" == typeof bot ) || Array . isArray ( bot ) ; if ( isWaterfall ) { let dialog = bot ; let connector = new TestConnector ( ) ; bot = new builder . UniversalBot ( connector ) ; bot . dialog ( '/' , dialog ) ; } else if ( bot instanceof builder . UniversalBot ) { if ( ! bot . connector ( ) ) { bot . connector ( 'console' , new TestConnector ( ) ) ; } } else { throw new Error ( ` ${ JSON . stringify ( bot ) } ` ) ; } return bot ; }
716	function ( password , count ) { if ( ! password ) throw new Error ( 'Missing argument !' ) ; if ( ! count || count <= 0 ) throw new Error ( 'Please provide a count number above 0' ) ; let data = password ; console . time ( 'sha3^n generation time' ) ; for ( let i = 0 ; i < count ; ++ i ) { data = CryptoJS . SHA3 ( data , { outputLength : 256 } ) ; } console . timeEnd ( 'sha3^n generation time' ) ; return { 'priv' : CryptoJS . enc . Hex . stringify ( data ) } ; }
1037	function unHookSyncCycle ( rs ) { if ( ! rs . _dropboxOrigSyncCycle ) { return ; } rs . syncCycle = rs . _dropboxOrigSyncCycle ; delete rs . _dropboxOrigSyncCycle ; }
1824	function ( match , strUntilValue , name , value , index ) { var self = this ; var containsTemplate = false ; if ( ! this . isRelevantTagAttr ( this . currentTag , name ) ) { return ; } this . matches . push ( { start : index + strUntilValue . length , length : value . length , value : value , containsTemplate : isTemplate ( value ) } ) ; }
3854	function createArrayDepth ( dimensions , endpoint ) { var currentDimension = dimensions [ 0 ] ; var newArr = new Array ( currentDimension ) ; for ( var i = 0 ; i < currentDimension ; i ++ ) { var value = endpoint ; if ( dimensions . length > 1 ) value = createArrayDepth ( dimensions . slice ( 1 ) , endpoint ) ; newArr [ i ] = value ; } return newArr ; }
833	function generateModuleFile ( componentsMetadata , demoAppDocsModuleDir ) { const imports = componentsMetadata . map ( componentMetadata => ` ${ componentMetadata . name } ${ componentMetadata . file } ` ) . join ( '\n' ) ; \n const components = componentsMetadata . map ( componentMetadata => ` ${ componentMetadata . name } ` ) . join ( '\n' ) ; \n const routes = componentsMetadata . map ( componentMetadata => ` ${ componentMetadata . route } ${ componentMetadata . name } ` ) . join ( '\n' ) ; \n }
2037	function ( ) { var exists = fs . existsSync ( configHelpers . getConfigPath ( ) ) ; if ( ! exists ) { config = { apps : { } , plugins : { } } ; configHelpers . saveConfig ( ) ; } }
683	async function deleteItems ( items , session ) { const asyncIterable = { [ Symbol . asyncIterator ] : ( ) => ( { next : function ( ) { const item = items . pop ( ) ; if ( ! item ) { return Promise . resolve ( { done : true } ) ; } return deleteItem ( item , session ) ; } } ) } ; const { next } = asyncIterable [ Symbol . asyncIterator ] ( ) ; for ( let { done , deleted , item } = await next ( ) ; ! done ; { done , deleted , item } = await next ( ) ) { if ( deleted ) { console . log ( chalk . green ( ` ${ item . title } \n ` ) ) ; } else { console . log ( chalk . gray ( ` ${ item . title } \n ` ) ) ; } } return Promise . resolve ( ) ; }
802	function ( fn , opts , trim , basePath , prefix ) { var slashPattern = isWindows ? / \\ / g : / \/ / g var name = fn . substring ( basePath . length + trim . length , fn . length ) . replace ( / \.jsx?$ / , '' ) . replace ( slashPattern , '.' ) if ( opts . label ) { name += '.' + opts . label } if ( prefix ) { name = prefix + name } return name ; }
3331	function ( scores ) { var completion = '' ; var i = 0 ; var lastStatus = - 1 ; while ( true ) { if ( lastStatus !== scores [ i ] ) { completion += '<span class=' + scores [ i ] . toString ( ) + '>' ; lastStatus = scores [ i ] ; } completion += this . element . value [ i ] ; i ++ ; if ( i === this . element . value . length ) { completion += '</span>' ; break ; } if ( lastStatus !== scores [ i ] ) { completion += '</span>' ; } } return completion ; }
130	function PreviewThumbnails ( player ) { _classCallCheck ( this , PreviewThumbnails ) ; this . player = player ; this . thumbnails = [ ] ; this . loaded = false ; this . lastMouseMoveTime = Date . now ( ) ; this . mouseDown = false ; this . loadedImages = [ ] ; this . elements = { thumb : { } , scrubbing : { } } ; this . load ( ) ; }
2602	function copy ( item ) { var copy ; if ( ! item ) return item ; switch ( typeof item ) { case 'string' : case 'number' : case 'function' : case 'boolean' : return item ; default : if ( item instanceof Array ) { return item . slice ( 0 ) ; } else { copy = { } ; } } libs . object . every ( item , function ( o , k ) { copy [ k ] = o ; } ) ; return copy ; }
28	function splitParagraphIntoLines ( text , maxlen , options ) { if ( ! options ) { options = { } ; } var line = [ ] , lines = [ line ] , line_length = options . textIndent || 0 , separator_length = 0 , current_word_length = 0 , word , widths_array , words = text . split ( ' ' ) , spaceCharWidth = getCharWidthsArray . apply ( this , [ ' ' , options ] ) [ 0 ] , i , l , tmp , lineIndent ; if ( options . lineIndent === - 1 ) { lineIndent = words [ 0 ] . length + 2 ; } else { lineIndent = options . lineIndent || 0 ; } if ( lineIndent ) { var pad = Array ( lineIndent ) . join ( " " ) , wrds = [ ] ; words . map ( function ( wrd ) { wrd = wrd . split ( / \s*\n / ) ; if ( wrd . length > 1 ) { wrds = wrds . concat ( wrd . map ( function ( wrd , idx ) { return ( idx && wrd . length ? "\n" : \n ) + "" ; } ) ) ; } else wrd } ) ; { wrds . push ( wrd [ 0 ] ) ; } words = wrds ; } lineIndent = getStringUnitWidth . apply ( this , [ pad , options ] ) ; for ( i = 0 , l = words . length ; i < l ; i ++ ) { var force = 0 ; word = words [ i ] ; if ( lineIndent && word [ 0 ] == "\n" ) \n { word = word . substr ( 1 ) ; force = 1 ; } widths_array = getCharWidthsArray . apply ( this , [ word , options ] ) ; current_word_length = getArraySum ( widths_array ) ; } if ( line_length + separator_length + current_word_length > maxlen || force ) { if ( current_word_length > maxlen ) { tmp = splitLongWord . apply ( this , [ word , widths_array , maxlen - ( line_length + separator_length ) , maxlen ] ) ; line . push ( tmp . shift ( ) ) ; line = [ tmp . pop ( ) ] ; while ( tmp . length ) { lines . push ( [ tmp . shift ( ) ] ) ; } current_word_length = getArraySum ( widths_array . slice ( word . length - ( line [ 0 ] ? line [ 0 ] . length : 0 ) ) ) ; } else { line = [ word ] ; } lines . push ( line ) ; line_length = current_word_length + lineIndent ; separator_length = spaceCharWidth ; } else { line . push ( word ) ; line_length += separator_length + current_word_length ; separator_length = spaceCharWidth ; } }
3786	function sprintf ( fstr , array ) { array . forEach ( function ( value ) { fstr = format ( fstr , value ) ; } ) ; return fstr ; }
898	function navigateTo ( options ) { let { url , params } = options ; let queryIdx = url . indexOf ( '?' ) ; if ( queryIdx !== - 1 ) { let query = url . substr ( queryIdx + 1 ) ; url = url . substring ( 0 , queryIdx ) ; if ( query ) { query = parseQuery ( query ) ; params = Object . assign ( { } , query , params ) ; } } if ( url . charAt ( 0 ) === '/' ) { let urlParts = url . split ( '/' ) ; urlParts . pop ( ) ; url = urlParts . join ( '/' ) ; } router . push ( { uri : url , params } ) ; }
112	function get ( ) { return ( Fullscreen . native || this . player . config . fullscreen . fallback ) && this . player . config . fullscreen . enabled && this . player . supported . ui && this . player . isVideo ; }
2748	function getRandomMusic ( queue , msg ) { fs . readFile ( './data/autoplaylist.txt' , 'utf8' , function ( err , data ) { if ( err ) throw err ; con ( 'OK: autoplaylist.txt' ) ; var random = data . split ( '\n' ) ; \n var num = getRandomInt ( random . length ) ; con ( random [ num ] ) var url = random [ num ] ; msg . author . username = "AUTOPLAYLIST" ; } ) ; }
2309	function patchFileObjects ( formData ) { if ( ! window . chrome || ! supportsFileConstructor ) { return ; } for ( let i = 0 ; i < formData . length ; i ++ ) { const val = getFileValue ( formData [ i ] [ 1 ] ) ; if ( val ) { formData [ i ] [ 1 ] = new File ( [ val ] , val . name , { type : val . type } ) ; } } }
732	function updateMetrics ( ) { isVwDirty = false ; DPR = window . devicePixelRatio ; cssCache = { } ; sizeLengthCache = { } ; pf . DPR = DPR || 1 ; units . width = Math . max ( window . innerWidth || 0 , docElem . clientWidth ) ; units . height = Math . max ( window . innerHeight || 0 , docElem . clientHeight ) ; units . vw = units . width / 100 ; units . vh = units . height / 100 ; evalId = [ units . height , units . width , DPR ] . join ( "-" ) ; units . em = pf . getEmValue ( ) ; units . rem = units . em ; }
3316	function Argument ( emitter , text , start , end , prefix , suffix ) { this . emitter = emitter ; this . setText ( text ) ; this . start = start ; this . end = end ; this . prefix = prefix ; this . suffix = suffix ; }
3872	function addClass ( node , className ) { if ( node && node . el ) { node . el . classList . add ( className ) ; } }
1690	function _resolveConfigSize ( renderNode ) { if ( renderNode instanceof RenderNode ) { var result = null ; var target = renderNode . get ( ) ; if ( target ) { result = _resolveConfigSize ( target ) ; if ( result ) { return result ; } } if ( renderNode . _child ) { return _resolveConfigSize ( renderNode . _child ) ; } } else if ( renderNode instanceof Surface ) { return renderNode . size ? { renderNode : renderNode , size : renderNode . size } : undefined ; } else if ( renderNode . options && renderNode . options . size ) { return { renderNode : renderNode , size : renderNode . options . size } ; } return undefined ; }
3448	function ( opacity , animate ) { var me = this ; if ( ! me . dom ) { return me ; } if ( ! animate || ! me . anim ) { me . setStyle ( 'opacity' , opacity ) ; } else { if ( typeof animate != 'object' ) { animate = { duration : 350 , easing : 'ease-in' } ; } me . animate ( Ext . applyIf ( { to : { opacity : opacity } } , animate ) ) ; } return me ; }
2475	function stdCall ( options , call , args , cb ) { var val = '' ; for ( var key in args ) { val += '&' + encodeURIComponent ( key ) + '=' + encodeURIComponent ( args [ key ] ) ; } if ( call !== undefined ) { call = '?command=' + call ; } if ( call === undefined ) { call = '' ; } if ( val === undefined ) { val = '' ; } http . get ( { hostname : 'localhost' , port : options . httpPort , path : '/requests/status.json' + call + val , auth : ':' + options . httpPassword , agent : false } , function ( res ) { if ( cb !== undefined ) { cb ( res ) ; } } ) ; }
2198	function $SnifferProvider ( ) { this . $get = [ '$window' , '$document' , function ( $window , $document ) { var eventSupport = { } , android = int ( ( / android (\d+) / . exec ( lowercase ( ( $window . navigator || { } ) . userAgent ) ) || [ ] ) [ 1 ] ) , boxee = / Boxee / i . test ( ( $window . navigator || { } ) . userAgent ) , document = $document [ 0 ] || { } , documentMode = document . documentMode , vendorPrefix , vendorRegex = / ^(Moz|webkit|O|ms)(?=[A-Z]) / , bodyStyle = document . body && document . body . style , transitions = false , animations = false , match ; if ( bodyStyle ) { for ( var prop in bodyStyle ) { if ( match = vendorRegex . exec ( prop ) ) { vendorPrefix = match [ 0 ] ; vendorPrefix = vendorPrefix . substr ( 0 , 1 ) . toUpperCase ( ) + vendorPrefix . substr ( 1 ) ; break ; } } if ( ! vendorPrefix ) { vendorPrefix = ( 'WebkitOpacity' in bodyStyle ) && 'webkit' ; } transitions = ! ! ( ( 'transition' in bodyStyle ) || ( vendorPrefix + 'Transition' in bodyStyle ) ) ; animations = ! ! ( ( 'animation' in bodyStyle ) || ( vendorPrefix + 'Animation' in bodyStyle ) ) ; if ( android && ( ! transitions || ! animations ) ) { transitions = isString ( document . body . style . webkitTransition ) ; animations = isString ( document . body . style . webkitAnimation ) ; } } return { history : ! ! ( $window . history && $window . history . pushState && ! ( android < 4 ) && ! boxee ) , hashchange : 'onhashchange' in $window && ( ! documentMode || documentMode > 7 ) , hasEvent : function ( event ) { if ( event == 'input' && msie == 9 ) return false ; if ( isUndefined ( eventSupport [ event ] ) ) { var divElm = document . createElement ( 'div' ) ; eventSupport [ event ] = 'on' + event in divElm ; } return eventSupport [ event ] ; } , csp : csp ( ) , vendorPrefix : vendorPrefix , transitions : transitions , animations : animations , android : android , msie : msie , msieDocumentMode : documentMode } ; } ] ; }
578	function PageViewPort_clone ( args ) { args = args || { } ; var scale = 'scale' in args ? args . scale : this . scale ; var rotation = 'rotation' in args ? args . rotation : this . rotation ; return new PageViewport ( this . viewBox . slice ( ) , scale , rotation , this . offsetX , this . offsetY , args . dontFlip ) ; }
1250	function ( token ) { const body = this . node ( "block" ) ; const items = [ ] ; if ( this . expect ( ":" ) ) this . next ( ) ; while ( this . token != this . EOF && this . token !== token ) { items . push ( this . read_inner_statement ( ) ) ; } if ( this . expect ( token ) ) this . next ( ) ; this . expectEndOfStatement ( ) ; return body ( null , items ) ; }
1781	function drawFaviconArc ( context , total , start , length , color ) { var arcStart = ARC_OFFSET + Math . PI * 2 * ( start / total ) ; var arcEnd = ARC_OFFSET + Math . PI * 2 * ( ( start + length ) / total ) ; context . beginPath ( ) ; context . strokeStyle = color ; context . lineWidth = ARC_WIDTH ; context . arc ( 16 , 16 , 16 - ARC_WIDTH / 2 , arcStart , arcEnd ) ; context . stroke ( ) ; }
2945	function vhostof ( req , regexp , subsite ) { var host = req . headers . host var hostname = hostnameof ( req ) if ( ! hostname ) { return } var match = regexp . exec ( hostname ) if ( ! match ) { return } if ( subsite && 'IS_ROUTE' != subsite && ! _ . startsWith ( req . path , subsite + '/' , 1 ) && ( req . get ( 'X-Base-Url-Path' ) != subsite ) ) { return } var obj = Object . create ( null ) obj . host = host obj . hostname = hostname obj . length = match . length - 1 for ( var i = 1 ; i < match . length ; i ++ ) { obj [ i - 1 ] = match [ i ] } return obj }
1520	function circularLinksCross ( link1 , link2 ) { if ( link1 . source . column < link2 . target . column ) { return false } else if ( link1 . target . column > link2 . source . column ) { return false } else { return true } }
1218	function processInitialData ( value , name ) { if ( name == View . prototype . modelName ) { options . model = def . models [ name ] . unique ( value ) ; } else if ( def . models [ name ] ) { options . data [ name ] = def . models [ name ] . unique ( value ) ; } else { options . data [ name ] = value ; } }
2848	function addStats ( database , cb ) { var changeDB = database . databaseName ? database : db . db ( database . name ) ; changeDB . stats ( function ( err , stats ) { if ( stats . collections ) { stats . collections -- ; } stats . _id = stats . db ; stats . name = stats . db ; stats . collectionCount = stats . collections ; delete stats . collections ; dbList . push ( stats ) ; cb ( null , database ) ; } ) ; }
255	function queryDocs ( query ) { return docsIndex . search ( query ) . map ( result => { const doc = documents [ result . ref ] , snippet = makeSnippet ( doc , query ) ; return { path : doc . path , title : doc . title , snippet : snippet , } ; } ) ; }
2670	function validateProjectName ( project_name ) { var msg = 'Error validating project name. ' ; if ( project_name === '' ) { return Q . reject ( new CordovaError ( msg + 'Project name cannot be empty' ) ) ; } if ( project_name === 'CordovaActivity' ) { return Q . reject ( new CordovaError ( msg + 'Project name cannot be CordovaActivity' ) ) ; } if ( / ^[0-9] / . test ( project_name ) ) { return Q . reject ( new CordovaError ( msg + 'Project name must not begin with a number' ) ) ; } return Q . resolve ( ) ; }
3056	function ( ) { var me = this ; if ( ! me . active ) { me . active = new Date ( ) ; me . startTime = me . getTime ( ) ; me . onStart ( ) ; me . fireEvent ( 'start' , me ) ; } }
2058	function ( toolbarKey , toolKey , _newTool ) { if ( toolbars [ toolbarKey ] ) toolbars [ toolbarKey ] . updateToolDisplay ( toolKey , _newTool ) ; else throw ( 'textAngular Error: No Toolbar with name "' + toolbarKey + '" exists' ) ; }
3704	function InputCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( ! parsed . args . length ) throw new SyntaxError ( 'INPUT requires at least one argument' ) ; var question = "" , placeVar , file ; if ( parsed . args . length === 1 ) placeVar = parsed . args [ 0 ] ; else { if ( parsed . args [ 0 ] . child instanceof statements . PointerStatement ) file = parsed . args [ 0 ] ; else question = parsed . args [ 0 ] ; placeVar = parsed . args [ 1 ] ; } if ( ! ( placeVar . child instanceof statements . VariableStatement || placeVar . child instanceof statements . FunctionStatement ) ) throw new SyntaxError ( 'Expected variable' ) ; this . file = file ; this . question = question ; this . placeVar = placeVar ; }
3860	function detach ( node ) { if ( node . placeholder instanceof HTMLElement === false ) { node . placeholder = createPlaceholder ( node . data . tag || node . el . tagName ) ; } if ( node && node . el && node . el . parentNode ) { node . el . parentNode . replaceChild ( node . placeholder , node . el ) ; } }
2451	function canExtendProto ( obj ) { if ( ! obj ) { return false ; } if ( isArray ( obj ) || isPlainObject ( obj ) ) { return true ; } return isFunction ( obj . constructor ) && ! isNative . test ( obj . constructor . toString ( ) ) ; }
3151	function getRequiredFilename ( name , callback ) { var filepath = path . join ( LOG_DIR , name ) ; function getStats ( ) { fs . stat ( filepath , function ( err , stats ) { if ( err ) { callback ( err , null ) ; } else if ( stats && stats . size >= MAX_FILE_SIZE ) { createFile ( ) ; } else { callback ( null , name ) ; } } ) ; } function createFile ( ) { fs . writeFile ( filepath , '[]' , function ( err ) { if ( err ) { callback ( err , null ) ; } else { callback ( null , name ) ; } } ) ; } fs . exists ( filepath , function ( exists ) { if ( exists ) { getStats ( ) ; } else { createFile ( ) ; } } ) ; }
1943	function ( gradient , prefix ) { if ( gradient . type == 'linear' ) { var fn = ( prefix ? '-' + prefix + '-' : '' ) + 'linear-gradient' ; var colorStops = _ . map ( gradient . colorStops , function ( cs ) { return cs . color + ( 'position' in cs ? ' ' + cs . position + ( cs . unit || '' ) : '' ) ; } ) ; if ( gradient . direction && ( ! prefs . get ( 'css.gradient.omitDefaultDirection' ) || ! _ . include ( defaultLinearDirections , gradient . direction ) ) ) { colorStops . unshift ( gradient . direction ) ; } return fn + '(' + colorStops . join ( ', ' ) + ')' ; } }
3699	function File ( name , file , parent ) { this . name = name ; this . file = file ; this . parent = parent ; this . readCursor = 0 ; this . eof = false ; }
3062	function ( index , silent ) { var me = this ; if ( ! index ) { index = 0 ; } else if ( ! Ext . isNumber ( index ) ) { index = Ext . Array . indexOf ( me . items , index ) ; } me . items [ index ] . disabled = false ; me . up ( 'tablepanel' ) . el . select ( '.' + Ext . baseCSSPrefix + 'action-col-' + index ) . removeCls ( me . disabledCls ) ; if ( ! silent ) { me . fireEvent ( 'enable' , me ) ; } }
91	function timeUpdate ( event ) { var invert = ! is$1 . element ( this . elements . display . duration ) && this . config . invertTime ; controls . updateTimeDisplay . call ( this , this . elements . display . currentTime , invert ? this . duration - this . currentTime : this . currentTime , invert ) ; if ( event && event . type === 'timeupdate' && this . media . seeking ) { return ; } controls . updateProgress . call ( this , event ) ; }
1326	function checkClassRange ( from , to ) { if ( from . kind === 'control' || to . kind === 'control' || ( ! isNaN ( from . codePoint ) && ! isNaN ( to . codePoint ) && from . codePoint > to . codePoint ) ) { throw new SyntaxError ( ` ${ from . value } ${ to . value } ` ) ; } }
1602	function compile ( opts ) { var srcPath = opts [ 'src' ] || process . cwd ( ) var dstPath = opts [ 'dst' ] var format = opts [ 'format' ] || 'cjs' var toStdout = dstPath === 'stdout' var stat = fs . statSync ( srcPath ) if ( ! srcPath ) { srcPath = path . cwd ( ) } if ( ! dstPath ) { dstPath = path . join ( path . dirname ( srcPath ) , path . basename ( srcPath , util . ext ) + ( stat . isFile ( ) ? '.js' : '' ) ) } if ( stat . isFile ( ) ) { compileFile ( srcPath , dstPath , format , toStdout ) } else if ( stat . isDirectory ( ) ) { compileDir ( srcPath , dstPath , format ) } }
1847	function getStacks ( req , res ) { var data = { } ; async . auto ( { stacks : function ( callback ) { dreadnot . getStackSummaries ( function ( err , stacks ) { data . stacks = stacks ; callback ( err ) ; } ) ; } , regions : [ 'stacks' , function ( callback ) { async . forEach ( data . stacks , function ( stack , callback ) { dreadnot . getRegionSummaries ( stack . name , function ( err , regions ) { if ( err ) { callback ( err ) ; return ; } stack . regions = regions ; async . forEach ( stack . regions , function ( region , callback ) { if ( region . latest_deployment === '0' ) { region . latest_deployment = null ; callback ( ) ; return ; } dreadnot . getDeploymentSummary ( stack . name , region . name , region . latest_deployment , function ( err , deployment ) { region . latest_deployment = deployment ; callback ( err ) ; } ) ; } , callback ) ; } ) ; } , callback ) ; } ] , } , function ( err ) { renderCallback ( req , res , 'stacks.jade' ) ( err , data ) ; } ) ; }
3673	function ( state , noError ) { if ( validators . isSemicolon ( state ) ) { state . next ( ) ; } else if ( state . token && ! validators . isBlockEnd ( state ) ) { var lb = state . lookback ( ) ; if ( ! lb || state . token . line === lb . line ) { if ( ! noError ) state . error ( constants . unexpectedToken ) ; return false ; } } return true ; }
2838	function Observer ( fn , observerInfo ) { Subscribable . call ( this ) ; this . fn = fn ; this . dependency = [ ] ; this . currentValue = null ; this . observerInfo = observerInfo ; this . _dependencyGetter = this . dependencyGetter . bind ( this ) ; this . call ( ) ; }
242	function normalizeApiAttributes ( attributes ) { attributes = clone ( attributes ) ; attributes = normalizeTermsForApi ( attributes ) ; if ( attributes . author ) { attributes . author = attributes . author . ID ; } return attributes ; }
314	function getRotatedSizes ( _ref5 ) { var width = _ref5 . width , height = _ref5 . height , degree = _ref5 . degree ; degree = Math . abs ( degree ) % 180 ; if ( degree === 90 ) { return { width : height , height : width } ; } var arc = degree % 90 * Math . PI / 180 ; var sinArc = Math . sin ( arc ) ; var cosArc = Math . cos ( arc ) ; var newWidth = width * cosArc + height * sinArc ; var newHeight = width * sinArc + height * cosArc ; return degree > 90 ? { width : newHeight , height : newWidth } : { width : newWidth , height : newHeight } ; }
612	function createDefaultSnippetPreview ( ) { var targetElement = document . getElementById ( this . config . targets . snippet ) ; return new SnippetPreview ( { analyzerApp : this , targetElement : targetElement , callbacks : { saveSnippetData : this . config . callbacks . saveSnippetData , } , } ) ; }
2063	function ( element , attribute ) { var resultingElements = [ ] ; var childNodes = element . children ( ) ; if ( childNodes . length ) { angular . forEach ( childNodes , function ( child ) { resultingElements = resultingElements . concat ( taDOM . getByAttribute ( angular . element ( child ) , attribute ) ) ; } ) ; } if ( element . attr ( attribute ) !== undefined ) resultingElements . push ( element ) ; return resultingElements ; }
643	function rateTitleLength ( titleLength ) { var rating ; switch ( true ) { case titleLength > 0 && titleLength <= 399 : case titleLength > 600 : rating = "ok" ; break ; case titleLength >= 400 && titleLength <= 600 : rating = "good" ; break ; default : rating = "bad" ; break ; } return rating ; }
1675	function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; result . ok ( mongoose . getInstance ( ) . start ( args ) , false ) ; }
2075	function cleanup ( ctx , cb ) { cleanupRun = true var msg = "Shutting down Sauce Connector" console . log ( msg ) ctx . comment ( msg ) if ( connectorProc ) connectorProc . kill ( "SIGINT" ) setTimeout ( function ( ) { if ( connectorProc ) connectorProc . kill ( "SIGKILL" ) fs . unlink ( PIDFILE , function ( ) { } ) msg = "Sauce Connector successfully shut down" console . log ( msg ) ctx . comment ( msg ) return cb ( 0 ) } , 5000 ) }
977	function convertMediaQueryToJSExpression ( tokens , allAppTypes , appType ) { let result = [ ] ; tokens . forEach ( item => { item = item . trim ( ) ; if ( allAppTypes . includes ( item ) ) { result . push ( ` ${ item } ${ appType } ` ) ; } else if ( item === 'and' ) { result . push ( '&&' ) ; } else if ( item === ',' || item === 'or' ) { result . push ( '||' ) ; } else if ( item === 'not' ) { result . push ( '!' ) ; } else if ( item === '(' || item === ')' ) { result . push ( item ) ; } } ) ; let lastItem = result [ result . length - 1 ] ; if ( lastItem === '&&' || lastItem === '||' ) { result . pop ( ) ; } let braceStack = [ ] ; result . forEach ( ( item , index ) => { if ( item === '(' ) { braceStack . push ( index ) ; } else if ( item === ')' ) { braceStack . pop ( ) ; } } ) ; for ( let i = braceStack . length - 1 ; i >= 0 ; i -- ) { result . splice ( braceStack [ i ] , 1 ) ; } return result . join ( '' ) ; }
2463	function ( name , obj ) { obj . _namespace = name ; observers = observers . concat ( obj . _observers ) ; obj . _emitter = caramel ; }
2550	function isIndex$3 ( value , length ) { length = length == null ? MAX_SAFE_INTEGER$3 : length ; return ! ! length && ( typeof value == 'number' || reIsUint$3 . test ( value ) ) && ( value > - 1 && value % 1 == 0 && value < length ) ; }
3036	function ( data ) { var me = this ; this . status = data . status || 0 ; me . responseHeaders = { } ; if ( me . mimeType ) { me . responseHeaders [ "content-type" ] = me . mimeType ; } if ( data . reason == "complete" ) { this . responseBytes = data . data ; me . responseHeaders [ "content-length" ] = data . data . length ; } else if ( data . reason == "error" || data . reason == "securityError" ) { this . statusText = data . text ; me . responseHeaders [ "content-length" ] = 0 ; } else { Ext . Error . raise ( "Unkown reason code in data: " + data . reason ) ; } }
2585	function advanceYears ( d , yearsInTheFuture , adjustForWeekend ) { if ( ! ( d instanceof Date ) ) return d ; yearsInTheFuture = yearsInTheFuture && libs . generic . isNumeric ( yearsInTheFuture ) ? yearsInTheFuture : 1 ; d . setTime ( d . getTime ( ) + ( yearsInTheFuture * 31536000000 ) ) ; if ( adjustForWeekend && ( d . getDay ( ) === 0 || d . getDay ( ) === 6 ) ) { while ( d . getDay ( ) === 0 || d . getDay ( ) === 6 ) d . setTime ( d . getTime ( ) + 86400000 ) ; } return d ; }
2343	function doRemoveDatasetClientWithRecords ( datasetClientId , cb ) { debug ( 'doRemoveDatasetClientWithRecords datasetClientId = %s' , datasetClientId ) ; async . waterfall ( [ async . apply ( doReadDatasetClient , datasetClientId ) , function removeRefs ( datasetClientJson , next ) { var datasetId = datasetClientJson . datasetId ; var recordsCollection = mongoClient . collection ( getDatasetRecordsCollectionName ( datasetId ) ) ; recordsCollection . updateMany ( { 'refs' : datasetClientId } , { '$pull' : { 'refs' : datasetClientId } } , function ( err ) { return next ( err , datasetClientJson ) ; } ) ; } , function deleteDatasetClient ( datasetClientJson , next ) { var col = mongoClient . collection ( DATASETCLIENTS_COLLECTION ) ; col . findOneAndDelete ( { 'id' : datasetClientId } , next ) ; } ] , function ( err , result ) { if ( err ) { debug ( 'Failed to doRemoveDatasetClientWithRecords due to error %s' , err ) ; return cb ( err ) ; } else { return cb ( null , result && result . value ) ; } } ) ; }
3095	function isRepoSync ( dir ) { var dirs if ( dir instanceof Array ) { dirs = dir } else { dirs = getDirectoriesSync ( dir ) } var res = dirs . filter ( function ( name ) { return name . match ( / \.epm / ig ) } ) ; return res . length > 0 ; }
1641	function ( ) { var self = this ; console . log ( 'stopping capture...' ) ; var req = get_req ( ) ; req . onreadystatechange = function stop_capture_response ( ) { if ( req . readyState === 4 ) { self . update_state ( ) ; console . log ( 'stopped.' ) ; jQuery ( "#stop" ) . hide ( ) ; jQuery ( "#start" ) . show ( ) ; htracr . ui . unpulse_logo ( true ) ; } } ; req . open ( "POST" , "/stop" , true ) ; req . send ( "" ) ; return false ; }
3455	function ( options ) { this . astStack = new ASTStack ( ) ; this . tags = options . customTags ; this . raw = '' ; this . disableParseTag = false ; this . line = 1 ; this . lineStart = 0 ; this . position = 0 ; this . parseTagStack = [ ] ; this . forItems = [ ] ; this . tablerowItems = [ ] ; this . forItems . test = this . tablerowItems . test = function ( name ) { var name = name . split ( '.' ) [ 0 ] ; return this . indexOf ( name ) === - 1 ? false : true ; } ; }
16	function copy_block ( buf , len , header ) { bi_windup ( ) ; last_eob_len = 8 ; if ( header ) { put_short ( len ) ; put_short ( ~ len ) ; } that . pending_buf . set ( window . subarray ( buf , buf + len ) , that . pending ) ; that . pending += len ; }
2671	function ( file ) { var contents = fs . readFileSync ( file , 'utf-8' ) ; if ( contents ) { contents = contents . substring ( contents . indexOf ( '<' ) ) ; } var doc = new et . ElementTree ( et . XML ( contents ) ) ; var root = doc . getroot ( ) ; if ( root . tag !== 'widget' ) { throw new Error ( file + ' has incorrect root node name (expected "widget", was "' + root . tag + '")' ) ; } return doc ; }
880	function getRequireExpressionModuleId ( node , t ) { if ( t . isCallExpression ( node ) ) { let { arguments : args , callee } = node ; if ( t . isIdentifier ( callee ) && callee . name === 'require' && args . length === 1 && t . isLiteral ( args [ 0 ] ) ) { let id = args [ 0 ] . value ; return id ; } } }
879	function serializeAttrs ( attributes , opts ) { if ( ! attributes ) { return ; } let output = '' ; let value ; Object . keys ( attributes ) . forEach ( key => { value = attributes [ key ] ; if ( output ) { output += ' ' ; } let isBoolAttr = value && typeof value === 'boolean' ; if ( isBoolAttr ) { output += key ; } else { output += key + '="' + ( opts . decodeEntities ? entities . encodeXML ( value ) : value ) + '"' ; } } ) ; return output ; }
2179	function adjustOffset ( index ) { var elements = getElements ( ) ; if ( ! angular . isNumber ( index ) ) index = ctrl . focusIndex ; if ( ! elements . tabs [ index ] ) return ; if ( ctrl . shouldCenterTabs ) return ; var tab = elements . tabs [ index ] , left = tab . offsetLeft , right = tab . offsetWidth + left , extraOffset = 32 ; if ( index == 0 ) { ctrl . offsetLeft = 0 ; return ; } if ( isRtl ( ) ) { var tabWidthsBefore = calcTabsWidth ( Array . prototype . slice . call ( elements . tabs , 0 , index ) ) ; var tabWidthsIncluding = calcTabsWidth ( Array . prototype . slice . call ( elements . tabs , 0 , index + 1 ) ) ; ctrl . offsetLeft = Math . min ( ctrl . offsetLeft , fixOffset ( tabWidthsBefore ) ) ; ctrl . offsetLeft = Math . max ( ctrl . offsetLeft , fixOffset ( tabWidthsIncluding - elements . canvas . clientWidth ) ) ; } else { ctrl . offsetLeft = Math . max ( ctrl . offsetLeft , fixOffset ( right - elements . canvas . clientWidth + extraOffset ) ) ; ctrl . offsetLeft = Math . min ( ctrl . offsetLeft , fixOffset ( left ) ) ; } }
3821	function ( app , route ) { var self = this ; var controller ; var controllerPath = self . options . controllersPath + route . controller ; try { controller = require ( self . options . rootPath + controllerPath ) ; } catch ( e ) { throw new Error ( 'The specified controller (' + controllerPath + ') does not exist.' ) ; } if ( controller ) { if ( controller [ route . method ] === undefined ) { throw new Error ( 'The specified method (' + route . method + ') does not exist on the controller (' + controllerPath + ').' ) ; } app [ route . verb ] ( route . path , controller [ route . method ] ) ; } }
1100	function executeMainProcessMethod ( moduleName , methodChain , args ) { const theModule = electron [ moduleName ] ; const path = methodChain . join ( '.' ) ; return get ( theModule , path ) . apply ( theModule , args ) ; }
1431	function ( ) { var m = this . __dbFilename . match ( / (^.*)\/([^/]+)$ / ) ; var resDb ; if ( m && m . length == 3 ) { resDb = m [ 1 ] + "/resource-db.json" ; } else { resDb = "resource-db.json" ; } return resDb ; }
1148	function ( args ) { return _ . template ( '<filter><feGaussianBlur in="SourceAlpha" stdDeviation="${blur}"/><feOffset dx="${dx}" dy="${dy}" result="offsetblur"/><feFlood flood-color="${color}"/><feComposite in2="offsetblur" operator="in"/><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>' , { dx : args . dx || 0 , dy : args . dy || 0 , color : args . color || 'black' , blur : _ . isFinite ( args . blur ) ? args . blur : 4 } ) ; }
2897	function ( conn , cb ) { if ( LOG_DEBUG ) { console . log ( "BEGIN tearDown" ) ; } if ( typeof conn == 'function' ) { cb = conn ; conn = null ; } if ( ! conn ) { connections = { } ; return cb ( ) ; } if ( ! connections [ conn ] ) return cb ( ) ; delete connections [ conn ] ; cb ( ) ; }
3068	function HTTPError ( ) { var args = Array . prototype . slice . call ( arguments ) ; if ( ! ( this instanceof HTTPError ) ) { var self = new HTTPError ( ) ; return FUNCTION ( self ) . apply ( self , args ) ; } var headers , msg , code ; ARRAY ( args ) . forEach ( function HTTPError_foreach ( arg ) { if ( typeof arg === 'object' ) { headers = arg ; } if ( typeof arg === 'string' ) { msg = arg ; } if ( typeof arg === 'number' ) { code = arg ; } } ) ; code = code || 500 ; msg = msg || ( '' + code + ' ' + require ( 'http' ) . STATUS_CODES [ code ] ) ; headers = headers || { } ; Error . call ( this ) ; Error . captureStackTrace ( this , this ) ; this . code = code ; this . message = msg ; this . headers = headers ; }
2191	function delaunayRefine ( points , triangulation ) { var stack = [ ] var numPoints = points . length var stars = triangulation . stars for ( var a = 0 ; a < numPoints ; ++ a ) { var star = stars [ a ] for ( var j = 1 ; j < star . length ; j += 2 ) { var b = star [ j ] if ( b < a ) { continue } if ( triangulation . isConstraint ( a , b ) ) { continue } var x = star [ j - 1 ] , y = - 1 for ( var k = 1 ; k < star . length ; k += 2 ) { if ( star [ k - 1 ] === b ) { y = star [ k ] break } } if ( y < 0 ) { continue } if ( inCircle ( points [ a ] , points [ b ] , points [ x ] , points [ y ] ) < 0 ) { stack . push ( a , b ) } } } while ( stack . length > 0 ) { var b = stack . pop ( ) var a = stack . pop ( ) var x = - 1 , y = - 1 var star = stars [ a ] for ( var i = 1 ; i < star . length ; i += 2 ) { var s = star [ i - 1 ] var t = star [ i ] if ( s === b ) { y = t } else if ( t === b ) { x = s } } if ( x < 0 || y < 0 ) { continue } if ( inCircle ( points [ a ] , points [ b ] , points [ x ] , points [ y ] ) >= 0 ) { continue } triangulation . flip ( a , b ) testFlip ( points , triangulation , stack , x , a , y ) testFlip ( points , triangulation , stack , a , y , x ) testFlip ( points , triangulation , stack , y , b , x ) testFlip ( points , triangulation , stack , b , x , y ) } }
780	function ( elem ) { var pattern = new RegExp ( _filterValue , 'i' ) ; var element = elem ; if ( pattern . test ( element . textContent ) ) { element . style . display = '' ; } else { element . style . display = 'none' ; } }
2626	function Series ( asyncFncWrapper ) { asyncFncWrapper = getAsyncFncWrapper ( asyncFncWrapper ) ; this . add = function ( ) { var fnc , args ; if ( arguments . length === 1 ) { fnc = arguments [ 0 ] ; } else if ( arguments . length > 1 ) { fnc = arguments [ arguments . length - 1 ] ; args = [ ] ; for ( var i = 0 ; i < arguments . length - 1 ; i ++ ) { args . push ( arguments [ i ] ) ; } } if ( typeof fnc !== 'function' ) throw new Error ( 'Async Series: Last argument have to be function(arg1, arg2, ..., next).' ) ; this . _fncQueue = this . _fncQueue || [ ] ; this . _fncQueue . push ( { args : args , fnc : fnc } ) ; this . execute = function ( finalFnc ) { var fncQueue = this . _fncQueue ; fncQueue . current = 0 ; fncQueue . scheduled = 0 ; function run ( itm ) { asyncFncWrapper ( function ( ) { fncQueue . scheduled = fncQueue . current ; if ( itm . args ) { itm . args . push ( next ) ; itm . fnc . apply ( itm , itm . args ) ; } else itm . fnc ( next ) ; } ) ; } function next ( ) { if ( ! fncQueue || fncQueue . scheduled !== fncQueue . current ) throw new Error ( 'Async Series: cannot execute next() more than once per function' ) ; if ( arguments . length > 0 && ( arguments [ 0 ] !== null && typeof arguments [ 0 ] !== 'undefined' ) ) { var args = Array . prototype . slice . call ( arguments ) ; fncQueue = null ; if ( typeof finalFnc === 'function' ) asyncFncWrapper ( function ( ) { finalFnc . apply ( this , args ) ; } ) ; } else if ( fncQueue . current + 1 < fncQueue . length ) { fncQueue . current += 1 ; run ( fncQueue [ fncQueue . current ] ) ; } else { fncQueue = null ; if ( typeof finalFnc === 'function' ) asyncFncWrapper ( finalFnc ) ; } } if ( fncQueue && fncQueue . length > 0 ) run ( fncQueue [ fncQueue . current ] ) ; } ; return this ; } ; this . execute = function ( fnc ) { if ( typeof fnc === 'function' ) asyncFncWrapper ( fnc ) ; } ; }
3501	function getVariableDeclaratorNode ( node ) { var parent = node . parent ; while ( parent . type !== "VariableDeclarator" && parent . type !== "Program" ) { parent = parent . parent ; } return parent . type === "VariableDeclarator" ? parent : null ; }
640	function getRelevantWords ( text , locale ) { if ( ! isEqual ( text , previousRelevantWords . text ) || ! isEqual ( locale , previousRelevantWords . locale ) ) { previousRelevantWords = { text , locale , data : calculateRelevantWords ( text , locale ) , } ; } return previousRelevantWords . data ; }
1092	function download ( url , onError ) { var request = require ( 'request' ) ; util . log ( 'Downloading cef tarball for ' + platform + '-' + arch + '...' ) ; var requestOpts = { uri : url , onResponse : true } var proxyUrl = process . env . http_proxy || process . env . HTTP_PROXY || process . env . npm_config_proxy if ( proxyUrl ) { util . log ( 'using proxy: ' + proxyUrl , 'verbose' ) ; requestOpts . proxy = proxyUrl } return request ( requestOpts ) . on ( 'error' , onError ) . on ( 'response' , function ( res ) { onError ( null , res ) } ) ; }
990	function formatDate ( datestr , resolution ) { datestr = datestr . replace ( ' ' , 'T' ) ; var date = new Date ( datestr ) ; var output = MONTHS [ date . getMonth ( ) ] ; resolution = resolution || DATE_MONTH ; if ( resolution >= DATE_DAY ) { output += ' ' + date . getDate ( ) + ',' ; } output += ' ' + date . getFullYear ( ) ; if ( resolution >= DATE_MINUTE ) { output += ' at ' + date . getHours ( ) + ':' + ( '0' + date . getMinutes ( ) ) . slice ( - 2 ) ; } if ( resolution >= DATE_SECOND ) { output += ':' + ( '0' + date . getSeconds ( ) ) . slice ( - 2 ) ; } return output ; }
1256	function updateProps ( domNode , oldVirtualNode , oldProps , newVirtualNode , newProps ) { if ( oldProps ) { for ( var name in oldProps ) { if ( name === 'ref' || name === 'on' ) continue if ( name in EVENT_LISTENER_PROPS ) continue if ( ! newProps || ! ( name in newProps ) ) { if ( name === 'dataset' ) { updateProps ( domNode . dataset , null , oldProps && oldProps . dataset , null , null ) } else if ( name !== 'innerHTML' && oldVirtualNode && SVG_TAGS . has ( oldVirtualNode . tag ) ) { domNode . removeAttribute ( SVG_ATTRIBUTE_TRANSLATIONS . get ( name ) || name ) } else { domNode [ name ] = EMPTY delete domNode [ name ] } } } } if ( newProps ) { for ( var name in newProps ) { if ( name === 'ref' || name === 'on' ) continue if ( name in EVENT_LISTENER_PROPS ) continue var oldValue = oldProps && oldProps [ name ] var newValue = newProps [ name ] if ( name === 'dataset' ) { updateNestedProps ( domNode . dataset , oldValue , newValue , false ) } else if ( name === 'style' && typeof newValue !== 'string' ) { if ( typeof oldValue === 'string' ) { domNode . style = '' oldValue = null } updateNestedProps ( domNode . style , oldValue , newValue , true ) } else if ( name === 'attributes' ) { updateAttributes ( domNode , oldValue , newValue ) } else { if ( newValue !== oldValue ) { if ( name !== 'innerHTML' && newVirtualNode && SVG_TAGS . has ( newVirtualNode . tag ) ) { domNode . setAttribute ( SVG_ATTRIBUTE_TRANSLATIONS . get ( name ) || name , newValue ) } else if ( newVirtualNode && newVirtualNode . tag === 'input' && name === 'value' && domNode [ name ] === newValue ) { } else { domNode [ name ] = newValue } } } } } }
3485	function insertBr ( ) { var brElm , extraBr , marker ; if ( container && container . nodeType == 3 && offset >= container . nodeValue . length ) { if ( ! tinymce . isIE && ! hasRightSideBr ( ) ) { brElm = dom . create ( 'br' ) ; rng . insertNode ( brElm ) ; rng . setStartAfter ( brElm ) ; rng . setEndAfter ( brElm ) ; extraBr = true ; } } brElm = dom . create ( 'br' ) ; rng . insertNode ( brElm ) ; if ( tinymce . isIE && parentBlockName == 'PRE' && ( ! documentMode || documentMode < 8 ) ) { brElm . parentNode . insertBefore ( dom . doc . createTextNode ( '\r' ) , \r ) ; } brElm marker = dom . create ( 'span' , { } , '&nbsp;' ) ; brElm . parentNode . insertBefore ( marker , brElm ) ; selection . scrollIntoView ( marker ) ; dom . remove ( marker ) ; if ( ! extraBr ) { rng . setStartAfter ( brElm ) ; rng . setEndAfter ( brElm ) ; } else { rng . setStartBefore ( brElm ) ; rng . setEndBefore ( brElm ) ; } selection . setRng ( rng ) ; }
2096	function update_db ( p , stats , _cb ) { var key = sprintf ( FILES_KEY_FMT , p ) ; var k1 = sprintf ( FHANDLE_KEY_FMT , p ) ; var k2 = sprintf ( FNAME_KEY_FMT , stats . _fhandle ) ; self . db . batch ( ) . put ( key , stats ) . put ( k1 , stats . _fhandle ) . put ( k2 , p ) . write ( function onBatchWrite ( err2 ) { if ( err2 ) { log . error ( err2 , 'update_db(%s): failed' , p ) ; _cb ( errno ( err2 ) ) ; } else { log . trace ( 'update_db(%s): done' , p ) ; self . cache . set ( key , stats ) ; _cb ( null ) ; } } ) ; }
1553	function findNextOctant ( currentOctant , tx1 , ty1 , tz1 ) { let min ; let exit = 0 ; if ( tx1 < ty1 ) { min = tx1 ; exit = 0 ; } else { min = ty1 ; exit = 1 ; } if ( tz1 < min ) { exit = 2 ; } return octantTable [ currentOctant ] [ exit ] ; }
2081	function parseRecord ( req , res , record ) { for ( var associationName in res . locals . Model . associations ) { if ( ! record [ associationName ] ) { if ( record . dataValues [ associationName + 'Id' ] ) { record . dataValues [ associationName ] = record [ associationName + 'Id' ] ; } } else { if ( record . dataValues [ associationName + 'Id' ] ) { record . dataValues [ associationName ] = record [ associationName + 'Id' ] ; } else if ( isObject ( record [ associationName ] && record [ associationName ] . id ) ) { record . dataValues [ associationName ] = record [ associationName ] . id ; } else if ( req . we . utils . isNNAssoc ( record [ associationName ] ) ) { record . dataValues [ associationName ] = record [ associationName ] . id ; } else { for ( var i = record . dataValues [ associationName ] . length - 1 ; i >= 0 ; i -- ) { record . dataValues [ associationName ] [ i ] = record . dataValues [ associationName ] [ i ] . id ; } } } } return record ; }
81	function createLabel ( key ) { var attr = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; var text = i18n . get ( key , this . config ) ; var attributes = Object . assign ( { } , attr , { class : [ attr . class , this . config . classNames . hidden ] . filter ( Boolean ) . join ( ' ' ) } ) ; return createElement ( 'span' , attributes , text ) ; }
2233	function abort ( ) { this . removeAllListeners ( 'validateResponse' ) ; this . removeAllListeners ( 'extractError' ) ; this . on ( 'validateResponse' , function addAbortedError ( resp ) { resp . error = AWS . util . error ( new Error ( 'Request aborted by user' ) , { code : 'RequestAbortedError' , retryable : false } ) ; } ) ; if ( this . httpRequest . stream ) { this . httpRequest . stream . abort ( ) ; if ( this . httpRequest . _abortCallback ) { this . httpRequest . _abortCallback ( ) ; } else { this . removeAllListeners ( 'send' ) ; } } return this ; }
1245	function ( asInterface ) { const result = [ - 1 , - 1 , - 1 ] ; if ( this . is ( "T_MEMBER_FLAGS" ) ) { let idx = 0 , val = 0 ; do { switch ( this . token ) { case this . tok . T_PUBLIC : idx = 0 ; val = 0 ; break ; case this . tok . T_PROTECTED : idx = 0 ; val = 1 ; break ; case this . tok . T_PRIVATE : idx = 0 ; val = 2 ; break ; case this . tok . T_STATIC : idx = 1 ; val = 1 ; break ; case this . tok . T_ABSTRACT : idx = 2 ; val = 1 ; break ; case this . tok . T_FINAL : idx = 2 ; val = 2 ; break ; } if ( asInterface ) { if ( idx == 0 && val == 2 ) { this . expect ( [ this . tok . T_PUBLIC , this . tok . T_PROTECTED ] ) ; val = - 1 ; } else if ( idx == 2 && val == 1 ) { this . error ( ) ; val = - 1 ; } } if ( result [ idx ] !== - 1 ) { this . error ( ) ; } else if ( val !== - 1 ) { result [ idx ] = val ; } } while ( this . next ( ) . is ( "T_MEMBER_FLAGS" ) ) ; } if ( result [ 1 ] == - 1 ) result [ 1 ] = 0 ; if ( result [ 2 ] == - 1 ) result [ 2 ] = 0 ; return result ; }
1032	function ( path ) { const url = 'https://api.dropboxapi.com/2/files/delete' ; const requestBody = { path : getDropboxPath ( path ) } ; return this . _request ( 'POST' , url , { body : requestBody } ) . then ( ( response ) => { if ( response . status !== 200 && response . status !== 409 ) { return Promise . resolve ( { statusCode : response . status } ) ; } var responseBody = response . responseText ; try { responseBody = JSON . parse ( responseBody ) ; } catch ( e ) { return Promise . reject ( new Error ( 'Invalid response body: ' + responseBody ) ) ; } if ( response . status === 409 ) { if ( compareApiError ( responseBody , [ 'path_lookup' , 'not_found' ] ) ) { return Promise . resolve ( { statusCode : 404 } ) ; } return Promise . reject ( new Error ( 'API error: ' + responseBody . error_summary ) ) ; } return Promise . resolve ( { statusCode : 200 } ) ; } ) . then ( ( result ) => { if ( result . statusCode === 200 || result . statusCode === 404 ) { this . _revCache . delete ( path ) ; delete this . _itemRefs [ path ] ; } return Promise . resolve ( result ) ; } , ( error ) => { error . message = 'Could not delete Dropbox file or folder ("' + path + '"): ' + error . message ; return Promise . reject ( error ) ; } ) ; }
3389	function ( request , xdrResult ) { var me = this ; if ( ( request . xhr && request . xhr . readyState == 4 ) || me . isXdr ) { me . clearTimeout ( request ) ; me . onComplete ( request , xdrResult ) ; me . cleanup ( request ) ; Ext . EventManager . idleEvent . fire ( ) ; } }
3028	function zipDuration ( date , duration ) { var toSet = { } ; if ( duration . getSeconds ( ) ) { toSet = { seconds : true , minutes : true , hours : true , days : true , months : true } ; } else if ( duration . getMinutes ( ) ) { toSet = { minutes : true , hours : true , days : true , months : true } ; } else if ( duration . getHours ( ) ) { toSet = { hours : true , days : true , months : true } ; } else if ( duration . getDays ( ) ) { toSet = { days : true , months : true } ; } else if ( duration . getMonths ( ) ) { toSet = { months : true } ; } else { return ; } if ( toSet . seconds && date . seconds == undefined ) { date . seconds = 0 ; } if ( toSet . minutes && date . minutes == undefined ) { date . minutes = 0 ; } if ( toSet . hours && date . hours == undefined ) { date . hours = 0 ; } if ( toSet . days && date . day == undefined ) { date . day = 1 ; } if ( toSet . months && date . month == undefined ) { date . month = 1 ; } }
4	function pipeStream ( ... args ) { const src = args . shift ( ) ; return new Promise ( ( resolve , reject ) => { let stream = src . on ( 'error' , reject ) ; let target ; while ( ( target = args . shift ( ) ) != null ) { stream = stream . pipe ( target ) . on ( 'error' , reject ) ; } stream . on ( 'finish' , resolve ) ; stream . on ( 'end' , resolve ) ; stream . on ( 'close' , resolve ) ; } ) ; }
3710	function orderBy ( keySelector , comparison ) { const trueKeySelector = keySelector || defaultKeySelector ; const trueComparison = comparison || defaultComparison ; return function * ( item ) { const keyedMapper = map ( ( item , index ) => ( { item , key : trueKeySelector ( item , index ) } ) ) ; const keyed = keyedMapper ( item ) ; const keyedArray = Array . from ( keyed ) ; keyedArray . sort ( ( a , b ) => trueComparison ( a . key , b . key ) ) ; for ( const { item } of keyedArray ) { yield item ; } } ; }
288	function getEligibleEmailForwardingDomain ( selectedDomainName , domains = [ ] ) { const eligibleDomains = getEmailForwardingSupportedDomains ( domains ) ; let selectedDomain ; if ( selectedDomainName ) { selectedDomain = eligibleDomains . reduce ( function ( selected , domain ) { return domain . name === selectedDomainName ? domain . name : selected ; } , '' ) ; } return selectedDomain || ( eligibleDomains . length && eligibleDomains [ 0 ] . name ) || '' ; }
3421	function ( ) { var me = this ; me . mixins . field . setValue . call ( me , me . setupValue ( me . toField . store . getRange ( ) ) ) ; }
540	async function moveDepsLib ( ) { await rename ( depsLibTensorFlowPath , destLibPath ) ; if ( os . platform ( ) !== 'win32' ) { await rename ( depsLibTensorFlowFrameworkPath , destFrameworkLibPath ) ; } }
2521	function flush ( fastdom ) { var reads = fastdom . reads . splice ( 0 , fastdom . reads . length ) , writes = fastdom . writes . splice ( 0 , fastdom . writes . length ) , error ; try { runTasks ( reads ) ; runTasks ( writes ) ; } catch ( e ) { error = e ; } fastdom . scheduled = false ; if ( fastdom . reads . length || fastdom . writes . length ) { scheduleFlush ( fastdom ) ; } if ( error ) { if ( fastdom . catch ) { fastdom . catch ( error ) ; } else { throw error ; } } }
2332	function listPendingChangesForClient ( datasetId , clientInfo , cb ) { pendingQueue . search ( { datasetId : datasetId , cuid : clientInfo . cuid } , cb ) ; }
2861	function basePickBy ( object , props , predicate ) { var index = - 1 , length = props . length , result = { } ; while ( ++ index < length ) { var key = props [ index ] , value = object [ key ] ; if ( predicate ( value , key ) ) { baseAssignValue ( result , key , value ) ; } } return result ; }
2525	function recurse ( node ) { if ( node . previousSibling ) recurse ( node . previousSibling ) ; switch ( node . nodeType ) { case 8 : html += "<!--" + node . nodeValue + " ; break ; } }
2499	function ( verb , path ) { var app = this , routed = false ; this . trigger ( 'lookup-route' , { verb : verb , path : path } ) ; if ( typeof this . routes [ verb ] != 'undefined' ) { $ . each ( this . routes [ verb ] , function ( i , route ) { if ( app . routablePath ( path ) . match ( route . path ) ) { routed = route ; return false ; } } ) ; } return routed ; }
3071	function ( sourceEditMode ) { var me = this , iframe = me . iframeEl , textarea = me . textareaEl , hiddenCls = Ext . baseCSSPrefix + 'hidden' , btn = me . getToolbar ( ) . getComponent ( 'sourceedit' ) ; if ( ! Ext . isBoolean ( sourceEditMode ) ) { sourceEditMode = ! me . sourceEditMode ; } me . sourceEditMode = sourceEditMode ; if ( btn . pressed !== sourceEditMode ) { btn . toggle ( sourceEditMode ) ; } if ( sourceEditMode ) { me . disableItems ( true ) ; me . syncValue ( ) ; iframe . addCls ( hiddenCls ) ; textarea . removeCls ( hiddenCls ) ; textarea . dom . removeAttribute ( 'tabIndex' ) ; textarea . focus ( ) ; me . inputEl = textarea ; } else { if ( me . initialized ) { me . disableItems ( me . readOnly ) ; } me . pushValue ( ) ; iframe . removeCls ( hiddenCls ) ; textarea . addCls ( hiddenCls ) ; textarea . dom . setAttribute ( 'tabIndex' , - 1 ) ; me . deferFocus ( ) ; me . inputEl = iframe ; } me . fireEvent ( 'editmodechange' , me , sourceEditMode ) ; me . updateLayout ( ) ; }
148	function getDomainNameFromReceiptOrCart ( receipt , cart ) { let domainRegistration ; if ( receipt && ! isEmpty ( receipt . purchases ) ) { domainRegistration = find ( values ( receipt . purchases ) , isDomainRegistration ) ; } if ( cartItems . hasDomainRegistration ( cart ) ) { domainRegistration = cartItems . getDomainRegistrations ( cart ) [ 0 ] ; } if ( domainRegistration ) { return domainRegistration . meta ; } return null ; }
3446	function makeCompat ( logger ) { return function ( name ) { return function ( ... x ) { assume ( x ) . is . an ( 'array' ) ; assume ( x . length ) . greaterThan ( 0 ) ; let msg = util . format . apply ( null , x ) ; let level = 'warn' ; let msgObj = { dbgname : name , dbgcmpt : true , } ; if ( msg . match ( / \[alert-operator\] / ) ) { level = 'fatal' ; msgObj . alert = true ; } logger [ level ] . call ( logger , msgObj , msg ) ; } ; } ; }
75	function toTitleCase ( ) { var input = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : '' ; return input . toString ( ) . replace ( / \w\S* / g , function ( text ) { return text . charAt ( 0 ) . toUpperCase ( ) + text . substr ( 1 ) . toLowerCase ( ) ; } ) ; }
2355	function ( datasetClientId , callback ) { return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doReadDatasetClientWithRecordsUseCache ) ( datasetClientId , callback ) ; }
2106	function ( req , cb ) { let config = req . soajs . config ; let loginMode = config . loginMode ; if ( req . soajs . tenantOauth && req . soajs . tenantOauth . loginMode ) { loginMode = req . soajs . tenantOauth . loginMode ; } function getLocal ( ) { let condition = { 'userId' : req . soajs . inputmaskData [ 'username' ] } ; let combo = { collection : userCollectionName , condition : condition } ; libProduct . model . findEntry ( req . soajs , combo , function ( err , record ) { if ( record ) { let hashConfig = { "hashIterations" : config . hashIterations , "seedLength" : config . seedLength } ; if ( req . soajs . servicesConfig && req . soajs . servicesConfig . oauth ) { if ( req . soajs . servicesConfig . oauth . hashIterations && req . soajs . servicesConfig . oauth . seedLength ) { hashConfig = { "hashIterations" : req . soajs . servicesConfig . oauth . hashIterations , "seedLength" : req . soajs . servicesConfig . oauth . seedLength } ; } } coreHasher . init ( hashConfig ) ; coreHasher . compare ( req . soajs . inputmaskData . password , record . password , function ( err , result ) { if ( err || ! result ) { return cb ( 413 ) ; } delete record . password ; if ( record . tId && req . soajs . tenant ) { if ( record . tId . toString ( ) !== req . soajs . tenant . id ) { return cb ( 403 ) ; } } if ( record ) { record . loginMode = loginMode ; } return cb ( null , record ) ; } ) ; } else { req . soajs . log . error ( "Username " + req . soajs . inputmaskData [ 'username' ] + " not found" ) ; return cb ( 401 ) ; } } ) ; } if ( loginMode === 'urac' ) { let data = { 'username' : req . soajs . inputmaskData [ 'username' ] , 'password' : req . soajs . inputmaskData [ 'password' ] } ; uracDriver . login ( req . soajs , data , function ( errCode , record ) { if ( errCode ) { return cb ( errCode ) ; } if ( record ) { record . loginMode = loginMode ; } return cb ( null , record ) ; } ) ; } else { getLocal ( ) ; } }
930	function addFileExtnameAssociatedProcessor ( extnames , processorName , existedMap ) { if ( ! extnames ) { return ; } if ( ! Array . isArray ( extnames ) ) { extnames = [ extnames ] ; } extnames . forEach ( k => { k = k . toLowerCase ( ) ; let processors = existedMap [ k ] ; if ( Array . isArray ( processors ) ) { processors . push ( processorName ) ; } else if ( processors ) { existedMap [ k ] = [ processors , processorName ] ; } else { existedMap [ k ] = processorName ; } } ) ; }
3170	function ( packageName , version ) { Ext . versions [ packageName ] = new Version ( version ) ; Ext . lastRegisteredVersion = Ext . versions [ packageName ] ; return this ; }
2808	function ( ) { if ( this . read ) { this . computed_observable = new Observer ( this . createFunction ( "return (" + this . value + ");" , [ "m" , "p" ] , [ this . context . model , this . context . parent ] , this . context . domElement ) , { domElement : this . context . domElement , attribute : this . name , value : this . value } ) ; this . read_binded = this . read . bind ( this ) ; this . computed_observable . subscribe ( this . read_binded ) ; this . read ( this . computed_observable . currentValue ) ; } if ( this . event ) { this . event ( this . createEventFunction ( ) ) ; } }
3857	function throwSyntaxError ( message , errorLine , size ) { errorLine = errorLine === undefined ? line : errorLine size = size === undefined ? 1 : size var snippet = getSnippet ( source , errorLine , size ) , err = new SyntaxError ( message + '\n' + \n ) snippet err . line = errorLine }
1480	function ( ) { return { command : "migrate [options]" , desc : "migrates a qooxdoo application to the next major version" , usage : "migrate" , builder : { "verbose" : { alias : "v" , describe : "enables additional progress output to console" , type : "boolean" } } , handler : function ( argv ) { return new qx . tool . cli . commands . Migrate ( argv ) . process ( ) . catch ( e => { console . error ( e . stack || e . message ) ; process . exit ( 1 ) ; } ) ; } } ; }
577	function combineUrl ( baseUrl , url ) { if ( ! url ) { return baseUrl ; } if ( / ^[a-z][a-z0-9+\-.]*: / i . test ( url ) ) { return url ; } var i ; if ( url . charAt ( 0 ) === '/' ) { i = baseUrl . indexOf ( '://' ) ; if ( url . charAt ( 1 ) === '/' ) { ++ i ; } else { i = baseUrl . indexOf ( '/' , i + 3 ) ; } return baseUrl . substring ( 0 , i ) + url ; } else { var pathLength = baseUrl . length ; i = baseUrl . lastIndexOf ( '#' ) ; pathLength = i >= 0 ? i : pathLength ; i = baseUrl . lastIndexOf ( '?' , pathLength ) ; pathLength = i >= 0 ? i : pathLength ; var prefixLength = baseUrl . lastIndexOf ( '/' , pathLength ) ; return baseUrl . substring ( 0 , prefixLength + 1 ) + url ; } }
61	function insertElement ( type , parent , attributes , text ) { if ( ! is$1 . element ( parent ) ) { return ; } parent . appendChild ( createElement ( type , attributes , text ) ) ; }
3396	function getTimestamp ( ) { var now = Math . floor ( Date . now ( ) / 1000 ) if ( time !== now ) { ctr = 0 timestamp = pad ( time = now , 8 , 16 ) } else assert ( ++ ctr < 0x1000000 , 'more than 16 million ids generated in 1 second' ) return timestamp }
462	function updateState ( ) { history . replaceState ( { left_top : split_left . scrollTop , right_top : split_right . scrollTop } , document . title ) ; }
82	function createBadge ( text ) { if ( is$1 . empty ( text ) ) { return null ; } var badge = createElement ( 'span' , { class : this . config . classNames . menu . value } ) ; badge . appendChild ( createElement ( 'span' , { class : this . config . classNames . menu . badge } , text ) ) ; return badge ; }
1940	function findGradientFromPosition ( content , pos ) { var cssProp = null ; var cssRule = require ( 'cssEditTree' ) . parseFromPosition ( content , pos , true ) ; if ( cssRule ) { cssProp = cssRule . itemFromPosition ( pos , true ) ; if ( ! cssProp ) { cssProp = _ . find ( cssRule . list ( ) , function ( elem ) { return elem . range ( true ) . end == pos ; } ) ; } } return { rule : cssRule , property : cssProp } ; }
1440	function expandMemberExpression ( str ) { var segs = str . split ( "." ) ; var expr = types . memberExpression ( types . identifier ( segs [ 0 ] ) , types . identifier ( segs [ 1 ] ) ) ; for ( var i = 2 ; i < segs . length ; i ++ ) { expr = types . memberExpression ( expr , types . identifier ( segs [ i ] ) ) ; } return expr ; }
1531	function ( element , link ) { if ( angular . isFunction ( link ) ) { link = { post : link } ; } var compiledContents ; return { pre : ( link && link . pre ) ? link . pre : null , post : function ( scope , element , attrs , trvw ) { if ( ! compiledContents ) { compiledContents = $compile ( trvw . getNodeTpl ( ) ) ; } compiledContents ( scope , function ( clone ) { element . append ( clone ) ; } ) ; if ( link && link . post ) { link . post . apply ( null , arguments ) ; } } } ; }
3849	function TcolorCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 3 ) throw new SyntaxError ( 'TCOLOR command requires 3 arguments' ) ; this . red = parsed . args [ 0 ] ; this . green = parsed . args [ 1 ] ; this . blue = parsed . args [ 2 ] ; }
2336	function ( metric , records ) { var returnValue = { message : 'no stats available' , name : metric . displayName } ; if ( records && records . length > 0 ) { returnValue = _ . chain ( records ) . map ( function ( recordStr ) { return JSON . parse ( recordStr ) ; } ) . groupBy ( function ( record ) { return record . tags [ metric . groupByTag ] ; } ) . reduce ( function ( reduced , groupRecords , groupKey ) { groupRecords = _ . sortBy ( groupRecords , 'ts' ) ; var processedData = _ . reduce ( groupRecords , function ( memo , groupRecord ) { var value = groupRecord . fields [ metric . valueField ] ; memo . current = value ; memo . numberOfRecords ++ ; memo . total += value ; memo . max = Math . max ( value , memo . max ) ; memo . min = Math . min ( value , memo . min ) ; memo . from = Math . min ( groupRecord . ts , memo . from ) ; memo . end = Math . max ( groupRecord . ts , memo . end ) ; return memo ; } , { max : 0 , min : MAX_NUMBER , current : 0 , numberOfRecords : 0 , total : 0 , from : MAX_NUMBER , end : 0 } ) ; reduced [ groupKey ] = { current : metric . dataFormatter ( processedData . current ) , max : metric . dataFormatter ( processedData . max ) , min : metric . dataFormatter ( processedData . min ) , average : metric . dataFormatter ( processedData . total / processedData . numberOfRecords ) , numberOfRecords : processedData . numberOfRecords , from : new Date ( processedData . from ) . toISOString ( ) , end : new Date ( processedData . end ) . toISOString ( ) } ; return reduced ; } , { } ) . value ( ) ; } return returnValue ; }
2271	function system ( initialState , reduce , feedback ) { return rx . defer ( function ( ) { var state = new rx . ReplaySubject ( 1 ) ; var scheduler = rx . queueScheduler ; var events = feedback . map ( function ( x ) { return x ( state , scheduler ) ; } ) ; var mergedEvent = rx . merge . apply ( rx , events ) . pipe ( observeOn_1 . observeOn ( scheduler ) ) ; var eventsWithEffects = mergedEvent . pipe ( scan_1 . scan ( reduce , initialState ) , tap_1 . tap ( function ( x ) { state . next ( x ) ; } ) , subscribeOn_1 . subscribeOn ( scheduler ) , startWith_1 . startWith ( initialState ) , observeOn_1 . observeOn ( scheduler ) ) ; var hackOnSubscribed = rx . defer ( function ( ) { state . next ( initialState ) ; return rx . empty ( ) ; } ) ; return rx . merge . apply ( rx , [ eventsWithEffects , hackOnSubscribed ] ) . pipe ( catchError_1 . catchError ( function ( e ) { dispatchError ( e ) ; return rx . throwError ( e ) ; } ) ) ; } ) ; }
2815	function ( path ) { var node = this . $getNode ( path , false ) ; if ( node !== null ) { return _ . keys ( node . nodes ) ; } else { return null ; } }
1652	function ( name , value , cursor , single ) { if ( value ) { if ( ! htracr . ui . urls [ name ] ) { ui . urls [ name ] = { } ; } if ( single === true ) { ui . urls [ name ] [ value ] = cursor ; } else { if ( ! ui . urls [ name ] [ value ] ) { ui . urls [ name ] [ value ] = [ ] ; } ui . urls [ name ] [ value ] . push ( cursor ) ; } } }
177	function settings ( state = { } , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_FAILURE : case WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_CAMPAIGN_DEFAULTS_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT_SUCCESS : return Object . assign ( { } , state , action . settings ) ; case WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST_SUCCESS : const data = { mailchimp_lists : action . lists } ; const listKeys = keys ( action . lists ) ; if ( ! state . mailchimp_list && listKeys . length > 0 ) { data . mailchimp_list = listKeys [ 0 ] ; } return Object . assign ( { } , state , data ) ; } return state ; }
1674	function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; if ( ! initialiseBluetoothCallbackId ) { initialiseBluetoothCallbackId = result . callbackId ; resultObjs [ result . callbackId ] = result ; result . ok ( simpleXpBeaconPlugin . getInstance ( ) . initialiseBluetooth ( result . callbackId ) , true ) ; } else { result . error ( "Initialise Bluetooth failure" , false ) ; } }
1715	function _processAnimations ( event ) { var prevItem ; for ( var i = 0 ; i < this . _viewStack . length ; i ++ ) { var item = this . _viewStack [ i ] ; switch ( item . state ) { case ItemState . HIDE : item . state = ItemState . HIDING ; _initHideAnimation . call ( this , item , prevItem , event . size ) ; _updateState . call ( this ) ; break ; case ItemState . SHOW : item . state = ItemState . SHOWING ; _initShowAnimation . call ( this , item , prevItem , event . size ) ; _updateState . call ( this ) ; break ; } prevItem = item ; } }
1151	function ( sx , sy ) { sy = ( typeof sy === 'undefined' ) ? sx : sy ; var transformAttr = this . attr ( 'transform' ) || '' , transform = parseTransformString ( transformAttr ) ; if ( typeof sx === 'undefined' ) { return transform . scale ; } transformAttr = transformAttr . replace ( / scale\([^\)]*\) / g , '' ) . trim ( ) ; this . attr ( 'transform' , transformAttr + ' scale(' + sx + ',' + sy + ')' ) ; return this ; }
388	function wrapTransitioningContext ( Comp ) { return props => { return ( < TransitioningContext . Consumer > { context => < Comp context = { context } { ... props } / > } < / TransitioningContext . Consumer > ) ; } ; }
2052	function parseNavItem ( item ) { if ( item . route === req . path ) { item . isActive = true ; } var childArray = [ ] ; for ( var child in item . children ) { var subItem = parseNavItem ( item . children [ child ] ) ; if ( subItem . isActive || subItem . hasActiveChildren ) { item . hasActiveChildren = true ; } if ( userHasAccess ( subItem ) ) { childArray . push ( subItem ) ; } } childArray . sort ( function ( a , b ) { return a . _w - b . _w } ) ; item . children = childArray ; return item ; }
3087	function ( ) { var fw , ix = 0 ; each ( this . windows , function ( w ) { if ( w . zIndex > ix ) { fw = w ; ix = w . zIndex ; } } ) ; return fw ; }
1727	function _createOverlay ( ) { this . overlay = new LayoutController ( { layout : OverlayLayout , layoutOptions : { itemSize : this . options . wheelLayout . itemSize } , dataSource : this . _overlayRenderables } ) ; this . add ( this . overlay ) ; }
676	function replaceCharactersByIndex ( text , indices , substitute ) { const modifiedTextSplitByLetter = text . split ( "" ) ; indices . forEach ( function ( index ) { modifiedTextSplitByLetter . splice ( index , 1 , substitute ) ; } ) ; return modifiedTextSplitByLetter . join ( "" ) ; }
1773	function ( process ) { var subSection = new TextSection ( ) ; this . last ( ) . add ( { process : process , truthy : subSection } ) ; this . stack . push ( subSection ) ; }
3739	function inPosition ( index , items ) { for ( var i = 0 ; i < items . length ; i ++ ) { var item = items [ i ] ; if ( index >= item . start && index <= item . end ) return item ; } return false ; }
3622	function object ( obj ) { var buffers = [ ] , buf , k , v , len = 0 ; for ( k in obj ) { buf = this . getStringBuffer ( k ) ; len += buf . length ; buffers . push ( buf ) ; buf = this . getStringBuffer ( obj [ k ] ) ; len += buf . length ; buffers . push ( buf ) ; } return Buffer . concat ( buffers , len ) ; }
828	function format ( msg , formatter , electronLog , removeStyles ) { removeStyles = removeStyles !== undefined ? removeStyles : false ; if ( typeof formatter === 'function' ) { return formatter ( msg , electronLog ) ; } var date = new Date ( msg . date || Date . now ( ) ) ; var variables = msg . variables ; var result = formatter ; for ( var i in variables ) { if ( ! variables . hasOwnProperty ( i ) ) continue ; result = result . replace ( '{' + i + '}' , variables [ i ] ) ; } result = result . replace ( '{level}' , msg . level ) . replace ( '{text}' , stringifyArray ( msg . data ) ) . replace ( '{y}' , String ( date . getFullYear ( ) ) ) . replace ( '{m}' , pad ( date . getMonth ( ) + 1 ) ) . replace ( '{d}' , pad ( date . getDate ( ) ) ) . replace ( '{h}' , pad ( date . getHours ( ) ) ) . replace ( '{i}' , pad ( date . getMinutes ( ) ) ) . replace ( '{s}' , pad ( date . getSeconds ( ) ) ) . replace ( '{ms}' , pad ( date . getMilliseconds ( ) , 3 ) ) . replace ( '{z}' , formatTimeZone ( date . getTimezoneOffset ( ) ) ) ; if ( removeStyles ) { result = result . replace ( / %c / g , '' ) ; } return result ; }
2964	function realDestinationPath ( file , from_dir , to_dir ) { var length = from_dir . length ; var from_dir_path = file . substring ( length , file . length ) ; return to_dir + from_dir_path ; }
3246	function quit ( message , line , chr ) { var percentage = Math . floor ( ( line / lines . length ) * 100 ) ; throw { name : 'JSHintError' , line : line , character : chr , message : message + " (" + percentage + "% scanned)." , raw : message } ; }
1019	function ( path ) { const foldername = parentPath ( path ) ; return this . _getFileId ( foldername ) . then ( ( parentId ) => { if ( parentId ) { return Promise . resolve ( parentId ) ; } else { return this . _createFolder ( foldername ) ; } } ) ; }
3479	function unmarkBogusCaretParents ( ) { var i , caretContainer , node ; caretContainer = getParentCaretContainer ( selection . getStart ( ) ) ; if ( caretContainer && ! dom . isEmpty ( caretContainer ) ) { tinymce . walk ( caretContainer , function ( node ) { if ( node . nodeType == 1 && node . id !== caretContainerId && ! dom . isEmpty ( node ) ) { dom . setAttrib ( node , 'data-mce-bogus' , null ) ; } } , 'childNodes' ) ; } }
1228	function clazz ( SuperClass , methods ) { var constructor = function ( ) { } ; constructor . prototype = new SuperClass ; constructor . prototype . constructor = constructor ; constructor . prototype . parent = SuperClass . prototype ; constructor . prototype = $ . extend ( constructor . prototype , methods ) ; return constructor ; }
739	function ( sub ) { var Super = this ; var Constructor = hasOwn . call ( sub , 'constructor' ) ? sub . constructor : function ( ) { Super . apply ( this , arguments ) ; } ; Object . assign ( Constructor , Super ) ; Constructor . prototype = Object . create ( Super . prototype ) ; Object . assign ( Constructor . prototype , sub ) ; return Constructor ; }
3514	function ( ) { return Math . max ( ! Ext . isStrict ? document . body . scrollHeight : document . documentElement . scrollHeight , this . getViewportHeight ( ) ) ; }
350	function _positionForIndex ( index ) { var textTillIndex = el . value . substring ( 0 , index ) ; var row = ( textTillIndex . match ( / \n / g ) || [ ] ) . length + 1 ; var col = textTillIndex . length - textTillIndex . lastIndexOf ( "\n" ) ; \n }
2000	function listenNode ( node , type , callback ) { node . addEventListener ( type , callback ) ; return { destroy : function ( ) { node . removeEventListener ( type , callback ) ; } } }
3528	function ( err ) { if ( err ) { defer . reject ( err ) ; } else { [ ] . shift . call ( arguments ) ; if ( arguments . length > 1 ) defer . resolve ( arguments ) ; else defer . resolve . apply ( defer , arguments ) ; } }
818	function execute_preloaded_script ( chain_opts , script_obj , registry_item ) { var script ; function preload_execute_finished ( ) { if ( script != null ) { script = null ; script_executed ( registry_item ) ; } } if ( registry [ script_obj . src ] . finished ) return ; if ( ! chain_opts [ _AllowDuplicates ] ) registry [ script_obj . src ] . finished = true ; script = registry_item . elem || document . createElement ( "script" ) ; if ( script_obj . type ) script . type = script_obj . type ; if ( script_obj . charset ) script . charset = script_obj . charset ; if ( script_obj . crossOrigin ) script . crossOrigin = script_obj . crossOrigin ; create_script_load_listener ( script , registry_item , "finished" , preload_execute_finished ) ; if ( registry_item . elem ) { registry_item . elem = null ; } else if ( registry_item . text ) { script . onload = script . onreadystatechange = null ; script . text = registry_item . text ; } else { script . src = script_obj . real_src ; } append_to . insertBefore ( script , append_to . firstChild ) ; if ( registry_item . text ) { preload_execute_finished ( ) ; } }
3616	function key ( obj , vonly ) { var buffer = new Buffer ( 0 ) , item ; if ( obj . expiry !== undefined && ! vonly ) { buffer = this . expiry ( obj . expiry ) ; } item = this [ obj . rtype ] ( obj , vonly ) ; return Buffer . concat ( [ buffer , item ] , buffer . length + item . length ) }
1154	function ( o ) { o = ( o && point ( o ) ) || point ( 0 , 0 ) ; var x = this . x ; var y = this . y ; this . x = sqrt ( ( x - o . x ) * ( x - o . x ) + ( y - o . y ) * ( y - o . y ) ) ; this . y = toRad ( o . theta ( point ( x , y ) ) ) ; return this ; }
1172	function ( p ) { p = g . point ( p ) ; var views = _ . map ( this . model . getElements ( ) , this . findViewByModel ) ; return _ . filter ( views , function ( view ) { return g . rect ( V ( view . el ) . bbox ( false , this . viewport ) ) . containsPoint ( p ) ; } , this ) ; }
3549	function classOfIsMulti ( value , type ) { return ( sjl . restArgs ( arguments , 1 ) ) . some ( function ( _type ) { return classOfIs ( value , _type ) ; } ) ; }
3737	function lastIndexOfOutside ( data , item , index , exclude ) { var result , positionResult = { start : index ? index + 1 : data . length + 1 , end : 0 } ; do { result = data . lastIndexOf ( item , positionResult . start - 1 ) ; } while ( result . index !== - 1 && ( positionResult = inPosition ( result . index , exclude ) ) ) ; return result ; }
3305	function clickMe ( print_r , str ) { return ( function ( ) { print_r . objRef = eval ( str ) ; print_r . strObjRef = str ; print_r . refresh ( ) ; } ) ; }
1131	function getLicenseProvider ( poolName , options ) { const methodOptions = { } ; Object . assign ( methodOptions , options ) ; const factoryOptions = { } ; Object . assign ( factoryOptions , this . constructorOptions ) ; let licenseProvider ; if ( methodOptions . autoApiType ) { return getApiType . call ( this , poolName , methodOptions ) . then ( ( apiType ) => { factoryOptions . version = this . version ; try { licenseProvider = bigIqLicenseProviderFactory . getLicenseProviderByType ( apiType , this . bigIp , factoryOptions ) ; return q ( licenseProvider ) ; } catch ( err ) { this . logger . info ( 'Error getting license provider by type' , err && err . message ? err . message : err ) ; return q . reject ( err ) ; } } ) . catch ( ( err ) => { this . logger . info ( 'Error getting api type' , err && err . message ? err . message : err ) ; return q . reject ( err ) ; } ) ; } try { licenseProvider = bigIqLicenseProviderFactory . getLicenseProviderByVersion ( this . version , this . bigIp , factoryOptions ) ; return q ( licenseProvider ) ; } catch ( err ) { this . logger . info ( 'Error getting license provider by type' , err && err . message ? err . message : err ) ; return q . reject ( err ) ; } }
1747	function decodeParams ( names , types , data , useNumberedParams = true ) { if ( arguments . length < 3 ) { data = types ; types = names ; names = [ ] ; } data = utils . hexOrBuffer ( data ) ; var values = new Result ( ) ; var offset = 0 ; types . forEach ( function ( type , index ) { var coder = getParamCoder ( type ) ; if ( coder . dynamic ) { var dynamicOffset = uint256Coder . decode ( data , offset ) ; var result = coder . decode ( data , dynamicOffset . value . toNumber ( ) ) ; offset += dynamicOffset . consumed ; } else { var result = coder . decode ( data , offset ) ; offset += result . consumed ; } if ( useNumberedParams ) { values [ index ] = result . value ; } if ( names [ index ] ) { values [ names [ index ] ] = result . value ; } } ) ; return values ; }
1947	function getIndentation ( node ) { if ( _ . include ( prefs . getArray ( 'format.noIndentTags' ) || [ ] , node . name ( ) ) ) { return '' ; } return require ( 'resources' ) . getVariable ( 'indentation' ) ; }
2334	function computeDelta ( datasetId , clientRecords , serverRecords ) { var creates = { } ; var updates = { } ; var deletes = { } ; _ . each ( serverRecords , function ( serverRecord , serverRecordUid ) { var serverRecHash = serverRecord . hash ; if ( clientRecords [ serverRecordUid ] ) { if ( clientRecords [ serverRecordUid ] !== serverRecHash ) { debug ( '[%s] Updating client record %s client hash=%s' , datasetId , serverRecordUid , clientRecords [ serverRecordUid ] ) ; updates [ serverRecordUid ] = serverRecord ; } } else { debug ( '[%s] Creating client record %s' , datasetId , serverRecordUid ) ; creates [ serverRecordUid ] = serverRecord ; } } ) ; _ . each ( clientRecords , function ( clientRecordHash , clientRecordUid ) { if ( ! serverRecords [ clientRecordUid ] ) { debug ( '[%s] Deleting client record %s' , datasetId , clientRecordUid ) ; deletes [ clientRecordUid ] = { } ; } } ) ; return { create : creates , update : updates , delete : deletes } ; }
3267	function stripFlag ( val , negate ) { negate = escape ( negate || constants_1 . NEGATE_CHAR ) ; return ( val || '' ) . replace ( new RegExp ( '^--?(' + negate + ')?' ) , '' ) ; }
1479	async function ( ) { let apps = [ ] ; let argv = this . argv ; let result = { target : argv . target , outputPath : argv . outputPath || null , locales : null , writeAllTranslations : argv . writeAllTranslations , environment : { } , applications : apps , libraries : argv . library || [ ] , config : argv . configFile || "compile.json" , continuous : argv . continuous , verbose : argv . verbose } ; if ( argv . set ) { argv . set . forEach ( function ( kv ) { var m = kv . match ( / ^([^=\s]+)(=(.+))?$ / ) ; if ( m ) { var key = m [ 1 ] ; var value = m [ 3 ] ; try { result . environment [ key ] = Function ( "\"use strict\";return (" + \" + \" ) value ; } ")" } else ( ) } ) ; } catch ( error ) { throw new Error ( "Failed to translate environment value '" + value + "' to a js datatype - " + error ) ; } { throw new Error ( "Failed to parse environment setting commandline option '" + kv + "'" ) ; } }
3094	function getDirectoriesSync ( dir ) { return fs . readdirSync ( dir ) . filter ( function ( item ) { return fs . statSync ( path . join ( dir , item ) ) . isDirectory ( ) ; } ) ; }
999	function getEpoch ( epoch ) { if ( ! epoch ) { return 0 ; } if ( typeof epoch . getTime === "function" ) { return epoch . getTime ( ) ; } if ( typeof epoch === "number" ) { return epoch ; } throw new TypeError ( "now should be milliseconds since UNIX epoch" ) ; }
761	function ( opt_options ) { this . canvas_ = document . createElement ( "canvas" ) ; opt_options = opt_options || { } ; this . direction_ = opt_options . direction || null ; }
3579	function ( key , value , priority ) { var normalizedPriority = this . normalizePriority ( priority ) , serial = this . _internalSerialNumbers ++ ; if ( this . wrapItems ) { return new ( this . itemWrapperConstructor ) ( key , value , normalizedPriority , serial ) ; } try { value . key = key ; value . priority = priority ; value . serial = serial ; } catch ( e ) { throw new TypeError ( 'PriorityList can only work in "unwrapped" mode with values/objects' + ' that can have properties created/set on them. Type encountered: `' + sjl . classOf ( value ) + '`;' + ' Original error: ' + e . message ) ; } return value ; }
729	function ( ) { var self = this ; var trigger = self . isOpen ; if ( self . settings . mode === 'single' && self . items . length ) { self . hideInput ( ) ; if ( ! self . isBlurring ) { self . $control_input . blur ( ) ; } } self . isOpen = false ; self . $dropdown . hide ( ) ; self . setActiveOption ( null ) ; self . refreshState ( ) ; if ( trigger ) self . trigger ( 'dropdown_close' , self . $dropdown ) ; }
2297	function randomIncident ( types , start , end ) { const x1 = randomDate ( start , end ) ; const x2 = new Date ( x1 ) ; x2 . setDate ( x1 . getDate ( ) + ( Math . floor ( Math . random ( ) * 45 ) ) ) ; Incidents . insert ( { x1 : x1 . getTime ( ) , x2 : x2 . getTime ( ) , y1 : ( Math . floor ( Math . random ( ) * 99 ) ) , type : types [ ( Math . floor ( Math . random ( ) * 2 ) ) ] , } ) ; }
1029	function ( path , options ) { if ( ! this . connected ) { return Promise . reject ( "not connected (path: " + path + ")" ) ; } var url = 'https://content.dropboxapi.com/2/files/download' ; var self = this ; var savedRev = this . _revCache . get ( path ) ; if ( savedRev === null ) { return Promise . resolve ( { statusCode : 404 } ) ; } if ( options && options . ifNoneMatch ) { if ( ! this . _initialFetchDone ) { return this . fetchDelta ( ) . then ( ( ) => { return this . get ( path , options ) ; } ) ; } if ( savedRev && ( savedRev === options . ifNoneMatch ) ) { return Promise . resolve ( { statusCode : 304 } ) ; } } if ( path . substr ( - 1 ) === '/' ) { return this . _getFolder ( path , options ) ; } var params = { headers : { 'Dropbox-API-Arg' : JSON . stringify ( { path : getDropboxPath ( path ) } ) , } , responseType : 'arraybuffer' } ; if ( options && options . ifNoneMatch ) { params . headers [ 'If-None-Match' ] = options . ifNoneMatch ; } return this . _request ( 'GET' , url , params ) . then ( function ( resp ) { var status = resp . status ; var meta , body , mime , rev ; if ( status !== 200 && status !== 409 ) { return Promise . resolve ( { statusCode : status } ) ; } meta = resp . getResponseHeader ( 'Dropbox-API-Result' ) ; return getTextFromArrayBuffer ( resp . response , 'UTF-8' ) . then ( function ( responseText ) { body = responseText ; if ( status === 409 ) { meta = body ; } try { meta = JSON . parse ( meta ) ; } catch ( e ) { return Promise . reject ( e ) ; } if ( status === 409 ) { if ( compareApiError ( meta , [ 'path' , 'not_found' ] ) ) { return { statusCode : 404 } ; } return Promise . reject ( new Error ( 'API error while downloading file ("' + path + '"): ' + meta . error_summary ) ) ; } mime = resp . getResponseHeader ( 'Content-Type' ) ; rev = meta . rev ; self . _revCache . set ( path , rev ) ; self . _shareIfNeeded ( path ) ; if ( shouldBeTreatedAsBinary ( responseText , mime ) ) { body = resp . response ; } else { try { body = JSON . parse ( body ) ; mime = 'application/json; charset=UTF-8' ; } catch ( e ) { } } return { statusCode : status , body : body , contentType : mime , revision : rev } ; } ) ; } ) ; }
3475	function ( command ) { if ( selection . isCollapsed ( ) ) selection . select ( selection . getNode ( ) ) ; execNativeCommand ( command ) ; selection . collapse ( FALSE ) ; }
1081	function currCb ( res , isErr ) { if ( effectSettled ) { return } effectSettled = true cb . cancel = noop if ( sagaMonitor ) { isErr ? sagaMonitor . effectRejected ( effectId , res ) : sagaMonitor . effectResolved ( effectId , res ) } cb ( res , isErr ) }
71	function setAspectRatio ( input ) { if ( ! this . isVideo ) { return { } ; } var ratio = getAspectRatio . call ( this , input ) ; var _ref = is$1 . array ( ratio ) ? ratio : [ 0 , 0 ] , _ref2 = _slicedToArray ( _ref , 2 ) , w = _ref2 [ 0 ] , h = _ref2 [ 1 ] ; var padding = 100 / w * h ; this . elements . wrapper . style . paddingBottom = "" . concat ( padding , "%" ) ; if ( this . isVimeo && this . supported . ui ) { var height = 240 ; var offset = ( height - padding ) / ( height / 50 ) ; this . media . style . transform = "translateY(-" . concat ( offset , "%)" ) ; } else if ( this . isHTML5 ) { this . elements . wrapper . classList . toggle ( this . config . classNames . videoFixedRatio , ratio !== null ) ; } return { padding : padding , ratio : ratio } ; }
2016	function chromeStorageSet ( data , callback ) { window . chrome . storage . sync . set ( data , function ( ) { callback ( window . chrome . runtime . lastError ) ; } ) ; }
2232	function defineMethods ( svc ) { AWS . util . each ( svc . prototype . api . operations , function iterator ( method ) { if ( svc . prototype [ method ] ) return ; svc . prototype [ method ] = function ( params , callback ) { return this . makeRequest ( method , params , callback ) ; } ; } ) ; }
826	function build ( ) { console . log ( 'Creating an optimized production build...' ) ; webpack ( config ) . run ( ( err ) => { if ( err ) { console . error ( 'Failed to create a production build. Reason:' ) ; console . error ( err . message || err ) ; process . exit ( 1 ) ; } console . log ( chalk . green ( 'Compiled successfully.' ) ) ; console . log ( ` ${ chalk . cyan ( 'dist' ) } ` ) ; console . log ( ) ; } ) ; }
2389	function ( predicate , context ) { var list = new ArrayList ; return list . add ( _ . filter ( this , predicate , context ) ) ; }
1802	function ( input ) { var dollarCurly = input . indexOf ( '${' ) ; if ( dollarCurly >= 0 ) { var endCurly = input . indexOf ( '}' , dollarCurly ) ; if ( endCurly >= 0 ) { return { start : dollarCurly , stop : endCurly , expr : input . substring ( dollarCurly + 2 , endCurly ) } ; } } return null ; }
2800	function formatNumber ( payload , schema ) { _ . forEach ( schema , function ( v , k ) { if ( v !== null && v . _type === 'number' ) { if ( typeof payload [ k ] === 'undefined' || payload [ k ] === null ) { payload [ k ] = 0 } } } ) }
1205	function _removeLineBreakBeforeAndAfter ( node ) { var nextSibling = _getNextSiblingThatIsNotBlank ( node ) , previousSibling = _getPreviousSiblingThatIsNotBlank ( node ) ; if ( nextSibling && _isLineBreak ( nextSibling ) ) { nextSibling . parentNode . removeChild ( nextSibling ) ; } if ( previousSibling && _isLineBreak ( previousSibling ) ) { previousSibling . parentNode . removeChild ( previousSibling ) ; } }
1409	function WritableStreamDefaultControllerAbort ( controller , reason ) { controller . _queue = [ ] ; const sinkAbortPromise = PromiseInvokeOrFallbackOrNoop ( controller . _underlyingSink , 'abort' , [ reason ] , 'close' , [ controller ] ) ; return sinkAbortPromise . then ( ( ) => undefined ) ; }
3686	function _setCopy ( sourceRef , copyRef , rc ) { return _instanceCopy ( sourceRef , copyRef , rc , ( set , val ) => { set . add ( _clone ( val , rc ) ) ; } ) ; }
3176	function munge ( str , options ) { var aMunged = [ ] ; var aChars , i ; options = options || { } ; if ( options . encoding ) { if ( encoder . TYPES . indexOf ( options . encoding ) < 0 ) throw Error ( 'Invalid encoding option given: ' + options . encoding ) ; } else options . encoding = encoder . DEFAULT ; if ( str ) { aChars = str . split ( '' ) ; for ( i in aChars ) aMunged [ i ] = '&#' + encoder [ options . encoding ] ( aChars [ i ] ) + ';' ; } return aMunged . join ( '' ) ; }
3684	function _instanceCopy ( sourceRef , copyRef , rc , copier ) { let origIndex = rc . xStack . indexOf ( sourceRef ) ; if ( origIndex === - 1 ) { rc . push ( sourceRef , copyRef ) ; forEach ( sourceRef , function ( value , key ) { copier ( copyRef , value , key ) ; } ) ; rc . pop ( ) ; return copyRef ; } else return rc . yStack [ origIndex ] ; }
1011	function ( ) { this . rs . setBackend ( 'googledrive' ) ; this . rs . authorize ( { authURL : AUTH_URL , scope : AUTH_SCOPE , clientId : this . clientId } ) ; }
3364	function Recurring ( str ) { var parts = str . split ( '/' ) ; if ( str . charAt ( 0 ) != 'R' || parts . length != 3 ) { throw new Error ( 'Invalid Recurring Date' ) ; } if ( ! parts [ 1 ] || ! parts [ 2 ] ) { throw new Error ( 'Recurring must have a start and end' ) ; } var countNum = parts [ 0 ] . substr ( 1 ) ; if ( countNum ) { if ( ! ( / ^[0-9]+$ / . test ( countNum ) ) ) { throw new Error ( 'Invalid recurrence count: not a number' ) } this . count = parseInt ( countNum , 10 ) ; if ( this . count < 0 ) throw new Error ( 'Invalid recurrence count' ) ; } Range . call ( this , parts [ 1 ] + '/' + parts [ 2 ] ) ; delete this . end ; if ( this . count ) { this . end = this . getNth ( this . count ) ; } }
3511	function define ( type , Model ) { if ( arguments . length === 1 ) { Model = type ; type = Model . prototype . __type || Model . modelName ; } var factory = new Factory ( Model ) ; factories . set ( type , factory ) return factory ; }
932	function getFileExtnameAssociatedProcessor ( processors ) { let result = Object . keys ( processors ) . reduce ( ( lastValue , processorName ) => { let processor = processors [ processorName ] ; let extnames = processor . extnames || [ ] ; if ( ! Array . isArray ( extnames ) ) { extnames = [ extnames ] ; } addFileExtnameAssociatedProcessor ( extnames , processorName , lastValue ) ; return lastValue ; } , { } ) ; Object . keys ( result ) . forEach ( k => sortDefaultProcessors ( result [ k ] , processors ) ) ; return result ; }
223	function getSyncProgressPercentage ( state , siteId ) { const syncStatus = getSyncStatus ( state , siteId ) , queued = get ( syncStatus , 'queue' ) , sent = get ( syncStatus , 'sent' ) , total = get ( syncStatus , 'total' ) , queuedMultiplier = 0.1 , sentMultiplier = 0.9 ; if ( isPendingSyncStart ( state , siteId ) || ! queued || ! sent || ! total ) { return 0 ; } const countQueued = reduce ( queued , ( sum , value ) => { return ( sum += value ) ; } , 0 ) ; const countSent = reduce ( sent , ( sum , value ) => { return ( sum += value ) ; } , 0 ) ; const countTotal = reduce ( total , ( sum , value ) => { return ( sum += value ) ; } , 0 ) ; const percentQueued = ( countQueued / countTotal ) * queuedMultiplier * 100 ; const percentSent = ( countSent / countTotal ) * sentMultiplier * 100 ; return Math . ceil ( percentQueued + percentSent ) ; }
1551	function findOctantsByLevel ( octant , level , depth , result ) { const children = octant . children ; let i , l ; if ( depth === level ) { result . push ( octant ) ; } else if ( children !== null ) { ++ depth ; for ( i = 0 , l = children . length ; i < l ; ++ i ) { findOctantsByLevel ( children [ i ] , level , depth , result ) ; } } }
1504	function defaults ( targ , _defs ) { [ ] . slice . call ( arguments , 1 ) . forEach ( function ( def ) { Object . keys ( def ) . forEach ( function ( key ) { if ( ! targ . hasOwnProperty ( key ) ) { targ [ key ] = def [ key ] ; } } ) ; } ) ; }
3592	function ( ) { var s4 = function ( ) { return Math . floor ( ( 1 + Math . random ( ) ) * 0x10000 ) . toString ( 16 ) . substring ( 1 ) ; } ; return s4 ( ) + s4 ( ) + '-' + s4 ( ) ; }
945	function preparePolyfillSupport ( polyfill , rootDir , logger ) { if ( ! polyfill ) { return ; } if ( ! Array . isArray ( polyfill ) ) { polyfill = [ polyfill ] ; } polyfill . forEach ( info => { try { ensure ( info . desc , info . deps , rootDir ) ; } catch ( ex ) { logger . warn ( ex . toString ( ) ) ; } } ) ; }
2004	function AssetLoader ( manifest , loader ) { this . assets = loadAssets ( manifest , loader , function ( err ) { if ( err ) { console . error ( err ) ; } } ) ; }
1112	function writeHeaders ( file , headers , only = null ) { for ( let name in headers ) { let value = headers [ name ] ; if ( only && ! match ( name , only ) ) continue ; if ( Array . isArray ( value ) ) for ( let item of value ) file . write ( ` ${ name } ${ item } \n ` ) ; else file . write ( ` ${ name } ${ value } \n ` ) ; } }
1967	function lookupProfiles ( names , agent = 'minecraft' ) { return fetch ( ` ${ CORE_API } ${ agent } ` , { method : 'POST' , body : JSON . stringify ( names ) , headers : { 'user-agent' : USER_AGENT , 'content-type' : 'application/json' , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => res . json ( ) ) }
2574	function ltrim ( s , what ) { what = typeof what === 'string' ? what : '\\s+' ; \\ }
311	function getPointer ( _ref2 , endOnly ) { var pageX = _ref2 . pageX , pageY = _ref2 . pageY ; var end = { endX : pageX , endY : pageY } ; return endOnly ? end : assign ( { startX : pageX , startY : pageY } , end ) ; }
225	function recordProduct ( product , orderId ) { if ( ! isAdTrackingAllowed ( ) ) { debug ( 'recordProduct: [Skipping] ad tracking is not allowed' ) ; return ; } if ( TRACKING_STATE_VALUES . LOADED !== trackingState ) { loadTrackingScripts ( recordProduct . bind ( null , product , orderId ) ) ; return ; } const isJetpackPlan = productsValues . isJetpackPlan ( product ) ; if ( isJetpackPlan ) { debug ( 'Recording Jetpack purchase' , product ) ; } else { debug ( 'Recording purchase' , product ) ; } const currentUser = user . get ( ) ; const userId = currentUser ? hashPii ( currentUser . ID ) : 0 ; try { const item = { currency : product . currency , id : orderId , name : product . product_slug , price : product . cost , sku : product . product_slug , quantity : 1 , } ; debug ( 'recordProduct: ga ecommerce add item' , item ) ; window . ga ( 'ecommerce:addItem' , item ) ; if ( isAdwordsEnabled ) { if ( window . google_trackConversion ) { let googleConversionId , googleConversionLabel ; if ( isJetpackPlan ) { googleConversionId = ADWORDS_CONVERSION_ID_JETPACK ; googleConversionLabel = TRACKING_IDS . googleConversionLabelJetpack ; } else { googleConversionId = ADWORDS_CONVERSION_ID ; googleConversionLabel = TRACKING_IDS . googleConversionLabel ; } window . google_trackConversion ( { google_conversion_id : googleConversionId , google_conversion_label : googleConversionLabel , google_conversion_value : product . cost , google_conversion_currency : product . currency , google_custom_params : { product_slug : product . product_slug , user_id : userId , order_id : orderId , } , google_remarketing_only : false , } ) ; } } } catch ( err ) { debug ( 'Unable to save purchase tracking data' , err ) ; } }
2581	function pad ( s , length , delim , pre ) { var i , thisLength = s . length ; if ( ! delim ) delim = ' ' ; if ( length === 0 ) return '' ; else if ( isNaN ( parseInt ( length , 10 ) ) ) return s ; length = parseInt ( length , 10 ) ; if ( length < thisLength ) return ! pre ? s . slice ( 0 , length ) : s . slice ( - length ) ; if ( pre ) { for ( i = 0 ; i < length - thisLength ; i ++ ) s = delim + s ; } else { for ( i = 0 ; i < length - thisLength ; i ++ ) s += delim ; } return s ; }
1126	function getDataFromPropPath ( pathArray , obj ) { if ( pathArray . length === 0 ) { return undefined ; } return pathArray . reduce ( ( result , prop ) => { if ( typeof result !== 'object' || result === null ) { return { } ; } if ( prop === '' ) { return result ; } return result [ prop ] ; } , obj ) ; }
585	function onWindowResize ( ) { let threeD = document . getElementById ( 'r3d' ) ; camera . canvas = { width : threeD . clientWidth , height : threeD . clientHeight , } ; camera . fitBox ( 2 ) ; renderer . setSize ( threeD . clientWidth , threeD . clientHeight ) ; stackHelper . slice . canvasWidth = threeD . clientWidth ; stackHelper . slice . canvasHeight = threeD . clientHeight ; }
1039	function extractFeatures ( chunk ) { var frame = arrayToTyped ( chunk ) ; var fset = Meyda . extract ( featuresToExtract , frame ) ; for ( let j = 0 ; j < featuresToExtract . length ; j ++ ) { var feature = fset [ featuresToExtract [ j ] ] ; features [ featuresToExtract [ j ] ] . push ( feature ) ; } }
3822	function ( app , route ) { var self = this ; var folderPath = route . controller . replace ( / staticDir: / g , '' ) ; var folder = self . options . rootPath + folderPath ; try { var info = fs . lstatSync ( folder ) ; if ( info . isDirectory ( ) ) { app . use ( express . static ( folder ) ) ; } } catch ( e ) { throw new Error ( 'The specified static path (' + folderPath + ') does not exist or is not a directory.' ) ; } }
2933	function hashish ( ) { var id = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : Math . floor ( Math . random ( ) * 100 ) ; var n = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 2 ; var base = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : 36 ; return _createHash ( id , _createSalts ( n , base ) , base ) ; }
382	function nodeWalkAncestors ( node , predicate ) { var parent = node . parentNode ; if ( ! parent ) { return undefined ; } if ( predicate ( parent ) ) { return parent ; } return nodeWalkAncestors ( parent , predicate ) ; }
607	function getSentenceBeginning ( sentence , firstWordExceptions ) { const words = getWords ( stripTags ( stripSpaces ( sentence ) ) ) ; if ( words . length === 0 ) { return "" ; } let firstWord = words [ 0 ] . toLocaleLowerCase ( ) ; if ( firstWordExceptions . indexOf ( firstWord ) > - 1 && words . length > 1 ) { firstWord += " " + words [ 1 ] ; } return firstWord ; }
494	function eventBinderCheck ( key , fn ) { if ( ! chimeeHelper . isString ( key ) ) throw new TypeError ( 'key parameter must be String' ) ; if ( ! chimeeHelper . isFunction ( fn ) ) throw new TypeError ( 'fn parameter must be Function' ) ; }
1156	function ( ref , distance ) { var theta = toRad ( point ( ref ) . theta ( this ) ) ; return this . offset ( cos ( theta ) * distance , - sin ( theta ) * distance ) ; }
1591	function message ( reason , position , origin ) { var filePath = this . path var message = new VMessage ( reason , position , origin ) if ( filePath ) { message . name = filePath + ':' + message . name message . file = filePath } message . fatal = false this . messages . push ( message ) return message }
2681	function Shell ( config ) { this . config = config ; this . commands = { } ; this . runtime = ijsrt ; this . state = vm . createContext ( createGlobals ( this ) ) ; this . code = '' ; require ( '../../node_modules/tern/plugin/node.js' ) ; var ternOptions = { defs : [ require ( '../../node_modules/tern/defs/ecma5.json' ) ] , plugins : { node : { } } } ; this . ternServer = new tern . Server ( ternOptions ) ; }
3013	function ( key , value ) { if ( value === undefined ) { value = key ; key = this . getKey ( value ) ; } return [ key , value ] ; }
2659	function smsAddCampaign ( callback , sender_name , addressbook_id , body , date , transliterate ) { if ( sender_name === undefined ) { return callback ( returnError ( "Empty sender name" ) ) ; } if ( addressbook_id === undefined ) { return callback ( returnError ( "Empty book id" ) ) ; } if ( body === undefined ) { return callback ( returnError ( "Empty sms text" ) ) ; } var data = { 'sender' : sender_name , 'addressBookId' : addressbook_id , 'body' : body , 'date' : date , 'transliterate' : transliterate } sendRequest ( 'sms/campaigns' , 'POST' , data , true , callback ) ; }
147	function UserSettings ( ) { if ( ! ( this instanceof UserSettings ) ) { return new UserSettings ( ) ; } this . settings = false ; this . initialized = false ; this . reAuthRequired = false ; this . fetchingSettings = false ; this . unsavedSettings = { } ; }
3216	function ( suppressEvent ) { var me = this , selections = me . store . getRange ( ) , i = 0 , len = selections . length , start = me . getSelection ( ) . length ; me . bulkChange = true ; for ( ; i < len ; i ++ ) { me . doSelect ( selections [ i ] , true , suppressEvent ) ; } delete me . bulkChange ; me . maybeFireSelectionChange ( me . getSelection ( ) . length !== start ) ; }
3249	function ( s ) { s = tinymce . trim ( s ) ; function rep ( re , str ) { s = s . replace ( re , str ) ; } ; rep ( / <a.*?href=\"(.*?)\".*?>(.*?)<\/a> / gi , "[url=$1]$2[/url]" ) ; rep ( / <font.*?color=\"(.*?)\".*?class=\"codeStyle\".*?>(.*?)<\/font> / gi , "[code][color=$1]$2[/color][/code]" ) ; rep ( / <font.*?color=\"(.*?)\".*?class=\"quoteStyle\".*?>(.*?)<\/font> / gi , "[quote][color=$1]$2[/color][/quote]" ) ; rep ( / <font.*?class=\"codeStyle\".*?color=\"(.*?)\".*?>(.*?)<\/font> / gi , "[code][color=$1]$2[/color][/code]" ) ; rep ( / <font.*?class=\"quoteStyle\".*?color=\"(.*?)\".*?>(.*?)<\/font> / gi , "[quote][color=$1]$2[/color][/quote]" ) ; rep ( / <span style=\"color: ?(.*?);\">(.*?)<\/span> / gi , "[color=$1]$2[/color]" ) ; rep ( / <font.*?color=\"(.*?)\".*?>(.*?)<\/font> / gi , "[color=$1]$2[/color]" ) ; rep ( / <span style=\"font-size:(.*?);\">(.*?)<\/span> / gi , "[size=$1]$2[/size]" ) ; rep ( / <font>(.*?)<\/font> / gi , "$1" ) ; rep ( / <img.*?src=\"(.*?)\".*?\/> / gi , "[img]$1[/img]" ) ; rep ( / <span class=\"codeStyle\">(.*?)<\/span> / gi , "[code]$1[/code]" ) ; rep ( / <span class=\"quoteStyle\">(.*?)<\/span> / gi , "[quote]$1[/quote]" ) ; rep ( / <strong class=\"codeStyle\">(.*?)<\/strong> / gi , "[code][b]$1[/b][/code]" ) ; rep ( / <strong class=\"quoteStyle\">(.*?)<\/strong> / gi , "[quote][b]$1[/b][/quote]" ) ; rep ( / <em class=\"codeStyle\">(.*?)<\/em> / gi , "[code][i]$1[/i][/code]" ) ; rep ( / <em class=\"quoteStyle\">(.*?)<\/em> / gi , "[quote][i]$1[/i][/quote]" ) ; rep ( / <u class=\"codeStyle\">(.*?)<\/u> / gi , "[code][u]$1[/u][/code]" ) ; rep ( / <u class=\"quoteStyle\">(.*?)<\/u> / gi , "[quote][u]$1[/u][/quote]" ) ; rep ( / <\/(strong|b)> / gi , "[/b]" ) ; rep ( / <(strong|b)> / gi , "[b]" ) ; rep ( / <\/(em|i)> / gi , "[/i]" ) ; rep ( / <(em|i)> / gi , "[i]" ) ; rep ( / <\/u> / gi , "[/u]" ) ; rep ( / <span style=\"text-decoration: ?underline;\">(.*?)<\/span> / gi , "[u]$1[/u]" ) ; rep ( / <u> / gi , "[u]" ) ; rep ( / <blockquote[^>]*> / gi , "[quote]" ) ; rep ( / <\/blockquote> / gi , "[/quote]" ) ; rep ( / <br \/> / gi , "\n" ) ; \n rep ( / <br\/> / gi , "\n" ) ; \n rep ( / <br> / gi , "\n" ) ; \n rep ( / <p> / gi , "" ) ; rep ( / <\/p> / gi , "\n" ) ; \n rep ( / &nbsp;|\u00a0 / gi , " " ) ; rep ( / &quot; / gi , "\"" ) ; }
1552	function findEntryOctant ( tx0 , ty0 , tz0 , txm , tym , tzm ) { let entry = 0 ; if ( tx0 > ty0 && tx0 > tz0 ) { if ( tym < tx0 ) { entry |= 2 ; } if ( tzm < tx0 ) { entry |= 1 ; } } else if ( ty0 > tz0 ) { if ( txm < ty0 ) { entry |= 4 ; } if ( tzm < ty0 ) { entry |= 1 ; } } else { if ( txm < tz0 ) { entry |= 4 ; } if ( tym < tz0 ) { entry |= 2 ; } } return entry ; }
759	function ( idx ) { if ( nextPointIdx >= idx ) return ; for ( var j = idx ; j < points . length ; ++ j ) { nextPoint = null ; if ( ! isNaN ( points [ j ] . yval ) && points [ j ] . yval !== null ) { nextPointIdx = j ; nextPoint = points [ j ] ; break ; } } }
49	function getDecimalPlaces ( value ) { var match = "" . concat ( value ) . match ( / (?:\.(\d+))?(?:[eE]([+-]?\d+))?$ / ) ; if ( ! match ) { return 0 ; } return Math . max ( 0 , ( match [ 1 ] ? match [ 1 ] . length : 0 ) - ( match [ 2 ] ? + match [ 2 ] : 0 ) ) ; }
2468	function pcomp ( f , g ) { return function ( ) { return f . apply ( null , arguments ) && g . apply ( null , arguments ) ; } }
2652	function getEmailTemplate ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty email template id' ) ) ; } sendRequest ( 'template/' + id , 'GET' , { } , true , callback ) ; }
94	function getLabel ( setting , value ) { switch ( setting ) { case 'speed' : return value === 1 ? i18n . get ( 'normal' , this . config ) : "" . concat ( value , "&times;" ) ; case 'quality' : if ( is$1 . number ( value ) ) { var label = i18n . get ( "qualityLabel." . concat ( value ) , this . config ) ; if ( ! label . length ) { return "" . concat ( value , "p" ) ; } return label ; } return toTitleCase ( value ) ; case 'captions' : return captions . getLabel . call ( this ) ; default : return null ; } }
2971	function check_role_authorization ( req , res , next ) { if ( ! req . hasOwnProperty ( "user" ) || ! req . user . hasOwnProperty ( 'authorized_roles' ) || ! ( req . user . authorized_roles instanceof Array ) || req . user . authorized_roles . length === 0 ) { running_debug ( "Unhautorized: Invalid role or path not configured" ) ; var err = new Error ( "Unhautorized: Invalid role or path not configured" ) ; err . status = 401 ; return next ( err ) ; } running_debug ( "Authorized roles: " + req . user . authorized_roles ) ; return next ( ) ; }
581	function messageHandlerSend ( actionName , data , transfers ) { var message = { action : actionName , data : data } ; this . postMessage ( message , transfers ) ; }
1308	function UpdateScriptBreakPoints ( script ) { for ( var i = 0 ; i < script_break_points . length ; i ++ ) { var break_point = script_break_points [ i ] ; if ( ( break_point . type ( ) == Debug . ScriptBreakPointType . ScriptName || break_point . type ( ) == Debug . ScriptBreakPointType . ScriptRegExp ) && break_point . matchesScript ( script ) ) { break_point . set ( script ) ; } } }
90	function updateSeekTooltip ( event ) { var _this5 = this ; if ( ! this . config . tooltips . seek || ! is$1 . element ( this . elements . inputs . seek ) || ! is$1 . element ( this . elements . display . seekTooltip ) || this . duration === 0 ) { return ; } var percent = 0 ; var clientRect = this . elements . progress . getBoundingClientRect ( ) ; var visible = "" . concat ( this . config . classNames . tooltip , "--visible" ) ; var toggle = function toggle ( _toggle ) { toggleClass ( _this5 . elements . display . seekTooltip , visible , _toggle ) ; } ; if ( this . touch ) { toggle ( false ) ; return ; } if ( is$1 . event ( event ) ) { percent = 100 / clientRect . width * ( event . pageX - clientRect . left ) ; } else if ( hasClass ( this . elements . display . seekTooltip , visible ) ) { percent = parseFloat ( this . elements . display . seekTooltip . style . left , 10 ) ; } else { return ; } if ( percent < 0 ) { percent = 0 ; } else if ( percent > 100 ) { percent = 100 ; } controls . updateTimeDisplay . call ( this , this . elements . display . seekTooltip , this . duration / 100 * percent ) ; this . elements . display . seekTooltip . style . left = "" . concat ( percent , "%" ) ; if ( is$1 . event ( event ) && [ 'mouseenter' , 'mouseleave' ] . includes ( event . type ) ) { toggle ( event . type === 'mouseenter' ) ; } }
464	function _addBaselineStyles ( ) { if ( document . head . querySelector ( 'style.anchorjs' ) !== null ) { return ; } var style = document . createElement ( 'style' ) , linkRule = ' .anchorjs-link {' + ' opacity: 0;' + ' text-decoration: none;' + ' -webkit-font-smoothing: antialiased;' + ' -moz-osx-font-smoothing: grayscale;' + ' }' , hoverRule = ' *:hover > .anchorjs-link,' + ' .anchorjs-link:focus {' + ' opacity: 1;' + ' }' , anchorjsLinkFontFace = ' @font-face {' + ' font-family: "anchorjs-icons";' + ' src: url(data:n/a;base64,AAEAAAALAIAAAwAwT1MvMg8yG2cAAAE4AAAAYGNtYXDp3gC3AAABpAAAAExnYXNwAAAAEAAAA9wAAAAIZ2x5ZlQCcfwAAAH4AAABCGhlYWQHFvHyAAAAvAAAADZoaGVhBnACFwAAAPQAAAAkaG10eASAADEAAAGYAAAADGxvY2EACACEAAAB8AAAAAhtYXhwAAYAVwAAARgAAAAgbmFtZQGOH9cAAAMAAAAAunBvc3QAAwAAAAADvAAAACAAAQAAAAEAAHzE2p9fDzz1AAkEAAAAAADRecUWAAAAANQA6R8AAAAAAoACwAAAAAgAAgAAAAAAAAABAAADwP/AAAACgAAA/9MCrQABAAAAAAAAAAAAAAAAAAAAAwABAAAAAwBVAAIAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAMCQAGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAg//0DwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAAIAAAACgAAxAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADAAAAAIAAgAAgAAACDpy//9//8AAAAg6cv//f///+EWNwADAAEAAAAAAAAAAAAAAAAACACEAAEAAAAAAAAAAAAAAAAxAAACAAQARAKAAsAAKwBUAAABIiYnJjQ3NzY2MzIWFxYUBwcGIicmNDc3NjQnJiYjIgYHBwYUFxYUBwYGIwciJicmNDc3NjIXFhQHBwYUFxYWMzI2Nzc2NCcmNDc2MhcWFAcHBgYjARQGDAUtLXoWOR8fORYtLTgKGwoKCjgaGg0gEhIgDXoaGgkJBQwHdR85Fi0tOAobCgoKOBoaDSASEiANehoaCQkKGwotLXoWOR8BMwUFLYEuehYXFxYugC44CQkKGwo4GkoaDQ0NDXoaShoKGwoFBe8XFi6ALjgJCQobCjgaShoNDQ0NehpKGgobCgoKLYEuehYXAAAADACWAAEAAAAAAAEACAAAAAEAAAAAAAIAAwAIAAEAAAAAAAMACAAAAAEAAAAAAAQACAAAAAEAAAAAAAUAAQALAAEAAAAAAAYACAAAAAMAAQQJAAEAEAAMAAMAAQQJAAIABgAcAAMAAQQJAAMAEAAMAAMAAQQJAAQAEAAMAAMAAQQJAAUAAgAiAAMAAQQJAAYAEAAMYW5jaG9yanM0MDBAAGEAbgBjAGgAbwByAGoAcwA0ADAAMABAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAH//wAP) format("truetype");' + ' }' , pseudoElContent = ' [data-anchorjs-icon]::after {' + ' content: attr(data-anchorjs-icon);' + ' }' , firstStyleEl ; style . className = 'anchorjs' ; style . appendChild ( document . createTextNode ( '' ) ) ; firstStyleEl = document . head . querySelector ( '[rel="stylesheet"], style' ) ; if ( firstStyleEl === undefined ) { document . head . appendChild ( style ) ; } else { document . head . insertBefore ( style , firstStyleEl ) ; } style . sheet . insertRule ( linkRule , style . sheet . cssRules . length ) ; style . sheet . insertRule ( hoverRule , style . sheet . cssRules . length ) ; style . sheet . insertRule ( pseudoElContent , style . sheet . cssRules . length ) ; style . sheet . insertRule ( anchorjsLinkFontFace , style . sheet . cssRules . length ) ; }
2188	function pipe ( ) { if ( arguments . length === 0 ) { throw new Error ( 'pipe requires at least one argument' ) ; } return _arity ( arguments [ 0 ] . length , reduce ( _pipe , arguments [ 0 ] , tail ( arguments ) ) ) ; }
13	function tr_init ( ) { l_desc . dyn_tree = dyn_ltree ; l_desc . stat_desc = StaticTree . static_l_desc ; d_desc . dyn_tree = dyn_dtree ; d_desc . stat_desc = StaticTree . static_d_desc ; bl_desc . dyn_tree = bl_tree ; bl_desc . stat_desc = StaticTree . static_bl_desc ; bi_buf = 0 ; bi_valid = 0 ; last_eob_len = 8 ; init_block ( ) ; }
341	function ( ) { var tree = this . tree ; var scrollTop = tree . scrollTop ; var scrollHeight = tree . scrollHeight ; var offsetHeight = tree . offsetHeight ; var atBottom = scrollTop >= ( scrollHeight - offsetHeight ) ; if ( ( atBottom && this . pageIndex < this . pages . length ) ) { var f = document . createDocumentFragment ( ) ; util . each ( this . pages [ this . pageIndex ] , function ( i , item ) { appendItem ( item , f , this . customOption ) ; } , this ) ; tree . appendChild ( f ) ; this . pageIndex ++ ; this . emit ( "selectr.paginate" , { items : this . items . length , total : this . data . length , page : this . pageIndex , pages : this . pages . length } ) ; } }
3072	function ( ) { var me = this , i , l , btns , doc , name , queriedName , fontSelect , toolbarSubmenus ; if ( me . readOnly ) { return ; } if ( ! me . activated ) { me . onFirstFocus ( ) ; return ; } btns = me . getToolbar ( ) . items . map ; doc = me . getDoc ( ) ; if ( me . enableFont && ! Ext . isSafari2 ) { queriedName = doc . queryCommandValue ( 'fontName' ) ; name = ( queriedName ? queriedName . split ( "," ) [ 0 ] . replace ( / ^' / , '' ) . replace ( / '$ / , '' ) : me . defaultFont ) . toLowerCase ( ) ; fontSelect = me . fontSelect . dom ; if ( name !== fontSelect . value || name != queriedName ) { fontSelect . value = name ; } } function updateButtons ( ) { for ( i = 0 , l = arguments . length , name ; i < l ; i ++ ) { name = arguments [ i ] ; btns [ name ] . toggle ( doc . queryCommandState ( name ) ) ; } } if ( me . enableFormat ) { updateButtons ( 'bold' , 'italic' , 'underline' ) ; } if ( me . enableAlignments ) { updateButtons ( 'justifyleft' , 'justifycenter' , 'justifyright' ) ; } if ( ! Ext . isSafari2 && me . enableLists ) { updateButtons ( 'insertorderedlist' , 'insertunorderedlist' ) ; } toolbarSubmenus = me . toolbar . query ( 'menu' ) ; for ( i = 0 ; i < toolbarSubmenus . length ; i ++ ) { toolbarSubmenus [ i ] . hide ( ) ; } me . syncValue ( ) ; }
1400	function TransformStreamCloseReadableInternal ( transformStream ) { assert ( transformStream . _errored === false ) ; assert ( transformStream . _readableClosed === false ) ; try { ReadableStreamDefaultControllerClose ( transformStream . _readableController ) ; } catch ( e ) { assert ( false ) ; } transformStream . _readableClosed = true ; }
1187	async function getImageDataFromSource ( source ) { const isStringSource = typeof source === 'string' const isURLSource = isStringSource ? isUrl ( source ) : false const { tagName } = source return new Promise ( ( resolve , reject ) => { if ( isStringSource ) { if ( isNode ) { Jimp . read ( isURLSource ? { url : source , headers : { } } : source , ( err , image ) => { if ( err ) { reject ( err ) } else { const { data , width , height } = image . bitmap resolve ( { data : data . toJSON ( ) . data , width , height , } ) } } ) } else if ( isURLSource ) { const img = new Image ( ) img . onerror = reject img . onload = ( ) => resolve ( createImageData ( img ) ) img . src = source } else { const imgElem = document . getElementById ( source ) if ( imgElem ) { resolve ( createImageData ( imgElem ) ) } reject ( new Error ( 'Invalid image source specified!' ) ) } } else if ( tagName ) { if ( tagName === 'IMG' ) { resolve ( createImageData ( source ) ) } else if ( tagName === 'CANVAS' ) { resolve ( source . getContext ( '2d' ) . getImageData ( 0 , 0 , source . naturalWidth , source . naturalHeight ) ) } reject ( new Error ( 'Invalid image source specified!' ) ) } else if ( source . data && source . width && source . height ) { resolve ( source ) } else { reject ( new Error ( 'Invalid image source specified!' ) ) } } ) }
848	function getTopAssignment ( leafNode ) { let node = leafNode while ( node . parent . type === "MemberExpression" && node . parent . object === node ) { node = node . parent } if ( ! isAssignee ( node ) ) { return null } while ( node . parent . type === "AssignmentExpression" ) { node = node . parent } return node }
3250	function ( s ) { s = tinymce . trim ( s ) ; function rep ( re , str ) { s = s . replace ( re , str ) ; } ; rep ( / \n / gi , "<br />" ) ; rep ( / \[b\] / gi , "<strong>" ) ; rep ( / \[\/b\] / gi , "</strong>" ) ; rep ( / \[i\] / gi , "<em>" ) ; rep ( / \[\/i\] / gi , "</em>" ) ; rep ( / \[u\] / gi , "<u>" ) ; rep ( / \[\/u\] / gi , "</u>" ) ; rep ( / \[url=([^\]]+)\](.*?)\[\/url\] / gi , "<a href=\"$1\">$2</a>" ) ; \" \" rep ( / \[url\](.*?)\[\/url\] / gi , "<a href=\"$1\">$1</a>" ) ; \" \" rep ( / \[img\](.*?)\[\/img\] / gi , "<img src=\"$1\" />" ) ; }
1437	function ( readFromFile = false ) { if ( ! readFromFile && this . __cache && typeof this . __cache == "object" ) { return this . __cache ; } try { this . __cache = jsonlint . parse ( fs . readFileSync ( this . getCachePath ( ) , "UTF-8" ) ) ; } catch ( e ) { this . __cache = { repos : { list : [ ] , data : { } } , compat : { } } ; } return this . __cache ; }
2779	function resolveUrlAttribute ( $node , attr ) { var url = $node . attr ( attr ) ; if ( url === undefined ) return '' ; if ( isAbsoluteUrl ( url ) ) { return url ; } else { return urlUtil . resolve ( base , url ) ; } }
3677	function save ( file , options ) { var stream = fs . createWriteStream ( file , options ) ; function onSave ( ) { stream . removeAllListeners ( ) ; this . emit ( 'save' ) ; } function onError ( err ) { stream . removeAllListeners ( ) ; this . emit ( 'error' , err ) ; } stream . on ( 'finish' , onSave . bind ( this ) ) ; stream . on ( 'error' , onError . bind ( this ) ) ; this . pipe ( stream ) ; return this ; }
1079	function errorMessage ( state = null , action ) { const { type , error } = action if ( type === ActionTypes . RESET_ERROR_MESSAGE ) { return null } else if ( error ) { return action . error } return state }
3675	function ( config ) { if ( ! config ) { return "" ; } var result = [ ] ; for ( var key in config ) { if ( typeof config [ key ] == "undefined" ) { continue ; } result . push ( key + "=" + config [ key ] ) ; } if ( result . length > 0 ) { return "?" + result . join ( "&" ) ; } return "" ; }
2494	function hex2num ( value ) { if ( value === undefined ) throw new Error ( 'Value is undefined' ) ; var buffer = hex2buf ( value ) ; return readFromBuffer ( buffer ) ; }
72	function getQualityOptions ( ) { return html5 . getSources . call ( this ) . map ( function ( source ) { return Number ( source . getAttribute ( 'size' ) ) ; } ) . filter ( Boolean ) ; }
860	function reportItem ( node , name , info ) { context . report ( { node , loc : node . loc , message : "{{name}} was deprecated since v{{version}}{{replace}}." , data : { name , version : info . since , replace : toReplaceMessage ( info . replacedBy ) , } , } ) }
2257	function RestClient ( baseUrl ) { if ( typeof baseUrl !== 'string' ) { if ( typeof document !== 'undefined' ) { baseUrl = document . getElementById ( 'baseUrlHolder' ) . getAttribute ( 'data' ) + '/api/' ; } else { baseUrl = '/api/' ; } } this . organizations = new OrganizationsClient ( baseUrl ) ; this . projects = new ProjectsClient ( baseUrl ) ; this . user = new UserClient ( baseUrl ) ; this . users = new UsersClient ( baseUrl ) ; this . getStatus = ( ) => { return this . user . get ( [ 'status' ] ) ; } ; }
706	function ( subject , dom ) { var outliner = panes . getOutliner ( dom ) var kb = UI . store var arg = UI . ns . arg subject = kb . canon ( subject ) var div = dom . createElement ( 'div' ) div . setAttribute ( 'class' , 'argumentPane' ) var comment = kb . any ( subject , UI . ns . rdfs ( 'comment' ) ) if ( comment ) { var para = dom . createElement ( 'p' ) para . setAttribute ( 'style' , 'margin-left: 2em; font-style: italic;' ) div . appendChild ( para ) para . textContent = comment . value } div . appendChild ( dom . createElement ( 'hr' ) ) var plist = kb . statementsMatching ( subject , arg ( 'support' ) ) outliner . appendPropertyTRs ( div , plist , false ) div . appendChild ( dom . createElement ( 'hr' ) ) plist = kb . statementsMatching ( subject , arg ( 'opposition' ) ) outliner . appendPropertyTRs ( div , plist , false ) div . appendChild ( dom . createElement ( 'hr' ) ) return div }
273	function applyPrecision ( cost , precision ) { const exponent = Math . pow ( 10 , precision ) ; return Math . ceil ( cost * exponent ) / exponent ; }
3450	function init ( type ) { O . ui . updateHistory ( ) ; O . inherited ( this ) ( 'html5-dialog' + ( type ? '-' + type : '' ) ) ; this . appendTo ( document . body ) ; O . ui . newHistory ( ) ; this . lastHistory = O . ui . lastHistory ; this . hook ( ) ; this . type = type ; if ( ! O . ui . dialogs ) { O . ui . dialogs = [ ] ; } O . ui . dialogs . push ( this ) ; this . on ( 'removed' , removed . bind ( this ) ) ; this . on ( 'closed' , closed . bind ( this ) ) ; }
63	function getAttributesFromSelector ( sel , existingAttributes ) { if ( ! is$1 . string ( sel ) || is$1 . empty ( sel ) ) { return { } ; } var attributes = { } ; var existing = extend ( { } , existingAttributes ) ; sel . split ( ',' ) . forEach ( function ( s ) { var selector = s . trim ( ) ; var className = selector . replace ( '.' , '' ) ; var stripped = selector . replace ( / [[\]] / g , '' ) ; var parts = stripped . split ( '=' ) ; var _parts = _slicedToArray ( parts , 1 ) , key = _parts [ 0 ] ; var value = parts . length > 1 ? parts [ 1 ] . replace ( / ["'] / g , '' ) : '' ; var start = selector . charAt ( 0 ) ; switch ( start ) { case '.' : if ( is$1 . string ( existing . class ) ) { attributes . class = "" . concat ( existing . class , " " ) . concat ( className ) ; } else { attributes . class = className ; } break ; case '#' : attributes . id = selector . replace ( '#' , '' ) ; break ; case '[' : attributes [ key ] = value ; break ; default : break ; } } ) ; return extend ( existing , attributes ) ; }
439	function getDomainFromProps ( props , axis ) { const minDomain = getMinFromProps ( props , axis ) ; const maxDomain = getMaxFromProps ( props , axis ) ; if ( isPlainObject ( props . domain ) && props . domain [ axis ] ) { return props . domain [ axis ] ; } else if ( Array . isArray ( props . domain ) ) { return props . domain ; } else if ( minDomain !== undefined && maxDomain !== undefined ) { return getDomainFromMinMax ( minDomain , maxDomain ) ; } return undefined ; }
274	function canDomainAddGSuite ( domainName ) { const GOOGLE_APPS_INVALID_SUFFIXES = [ '.in' , '.wpcomstaging.com' ] ; const GOOGLE_APPS_BANNED_PHRASES = [ 'google' ] ; const includesBannedPhrase = some ( GOOGLE_APPS_BANNED_PHRASES , bannedPhrase => includes ( domainName , bannedPhrase ) ) ; const hasInvalidSuffix = some ( GOOGLE_APPS_INVALID_SUFFIXES , invalidSuffix => endsWith ( domainName , invalidSuffix ) ) ; return ! ( hasInvalidSuffix || includesBannedPhrase || isGSuiteRestricted ( ) ) ; }
1984	function getComponentDescendants ( root , component , onlyChildren , includeSelf ) { var node = rquery_getDOMNode ( component ) , descendants = [ ] ; if ( onlyChildren ) { descendants = node . children ; } else { descendants = node . getElementsByTagName ( '*' ) ; } descendants = _ . toArray ( descendants ) ; if ( includeSelf ) { descendants . unshift ( rquery_getDOMNode ( component ) ) ; } injectCompositeComponents ( root , descendants ) ; return descendants ; }
2470	function paragraph ( dict , wordCount , startWithCommon ) { const result = [ ] ; let totalWords = 0 ; let words ; if ( startWithCommon && dict . common ) { words = dict . common . slice ( 0 , wordCount ) ; totalWords += words . length ; result . push ( sentence ( insertCommas ( words ) , '.' ) ) ; } while ( totalWords < wordCount ) { words = sample ( dict . words , Math . min ( rand ( 2 , 30 ) , wordCount - totalWords ) ) ; totalWords += words . length ; result . push ( sentence ( insertCommas ( words ) ) ) ; } return result . join ( ' ' ) ; }
275	function formatPrice ( cost , currencyCode , options = { } ) { if ( undefined !== options . precision ) { cost = applyPrecision ( cost , options . precision ) ; } return formatCurrency ( cost , currencyCode , cost % 1 > 0 ? { } : { precision : 0 } ) ; }
3539	function ( obj ) { var res = { } , i ; for ( i in obj ) { res [ i ] = obj [ i ] ; } return res ; }
1995	function MochaWorkerReporter ( runner ) { EVENTS . forEach ( function ( eventName ) { runner . on ( eventName , function ( test , error ) { var data = { 'event' : eventName , 'test' : clean ( test , error ) } ; try { process . send ( { type : 'testResults' , data : data } ) ; } catch ( e ) { console . log ( 'MochaWorkerReporter: Error sending test results.' , JSON . stringify ( data ) , e . message , e . stack ) ; process . exit ( 1 ) ; } } ) ; } ) ; }
3384	function ( options , url ) { var form = this . getForm ( options ) ; if ( form ) { url = url || form . action ; } return url ; }
1569	function installDevelopmentWatcher ( startingFolder , callback ) { const buildFolder = config . commands . build . output bs . init ( { server : [ buildFolder , assets ] , port : config . commands . build . port , files : path . join ( assets , '**/*.css' ) , ui : false , open : false } ) const templateFolder = path . join ( assets , '**/*.html' ) const dataFolder = path . join ( startingFolder , '**/data.xml' ) const watcher = createWatcher ( templateFolder , dataFolder ) watcher . on ( 'change' , ( ) => { callback ( ) bs . reload ( ) } ) }
3064	function ( readOnly ) { var me = this , inputEl = me . inputEl ; readOnly = ! ! readOnly ; me [ readOnly ? 'addCls' : 'removeCls' ] ( me . readOnlyCls ) ; me . readOnly = readOnly ; if ( inputEl ) { inputEl . dom . readOnly = readOnly ; } else if ( me . rendering ) { me . setReadOnlyOnBoxReady = true ; } me . fireEvent ( 'writeablechange' , me , readOnly ) ; }
340	function ( item ) { var tag = false ; util . each ( this . tags , function ( i , t ) { if ( t . idx === item . idx ) { tag = t ; } } , this ) ; if ( tag ) { this . label . removeChild ( tag ) ; this . tags . splice ( this . tags . indexOf ( tag ) , 1 ) ; } }
652	function ( words , text ) { var matchedWords = [ ] ; forEach ( words , function ( word ) { word = stripSpaces ( word ) ; if ( ! matchWordInSentence ( word , text ) ) { return matchedWords ; } matchedWords = matchedWords . concat ( getIndicesByWord ( word , text ) ) ; } ) ; matchedWords = matchedWords . sort ( function ( a , b ) { if ( a . index < b . index ) { return - 1 ; } if ( a . index > b . index ) { return 1 ; } return 0 ; } ) ; return matchedWords ; }
3195	function generateAssignStateOutOfFinally ( enclosingFinally , destination ) { var finallyState = enclosingFinally . finallyState ; return createStatementList ( createAssignStateStatement ( finallyState ) , parseStatement ` ${ destination } ` ) ; }
1134	function jscoverage_initTabContents ( queryString ) { var showMissingColumn = false ; var url = null ; var windowURL = null ; var parameters , parameter , i , index , name , value ; if ( queryString . length > 0 ) { queryString = queryString . substring ( 1 ) ; parameters = queryString . split ( / &|; / ) ; for ( i = 0 ; i < parameters . length ; i ++ ) { parameter = parameters [ i ] ; index = parameter . indexOf ( '=' ) ; if ( index === - 1 ) { url = decodeURIComponent ( parameter ) ; } else { name = parameter . substr ( 0 , index ) ; value = decodeURIComponent ( parameter . substr ( index + 1 ) ) ; if ( name === 'missing' || name === 'm' ) { showMissingColumn = jscoverage_getBooleanValue ( value ) ; } else if ( name === 'url' || name === 'u' || name === 'frame' || name === 'f' ) { url = value ; } else if ( name === 'window' || name === 'w' ) { windowURL = value ; } } } } var checkbox = document . getElementById ( 'checkbox' ) ; checkbox . checked = showMissingColumn ; if ( showMissingColumn ) { jscoverage_appendMissingColumn ( ) ; } var isValidURL = function ( url ) { var result = jscoverage_isValidURL ( url ) ; if ( ! result ) { alert ( 'Invalid URL: ' + url ) ; } return result ; } ; if ( url !== null && isValidURL ( url ) ) { frames [ 0 ] . location = url ; } else if ( windowURL !== null && isValidURL ( windowURL ) ) { window . open ( windowURL ) ; } if ( ! document . getElementById ( 'browserTab' ) ) { jscoverage_recalculateSummaryTab ( ) ; } }
1519	function linkAngle ( link ) { var adjacent = Math . abs ( link . y1 - link . y0 ) var opposite = Math . abs ( link . target . x0 - link . source . x1 ) return Math . atan ( opposite / adjacent ) }
1392	function allocateWorkers ( execution , numOfWorkersRequested ) { const exId = execution . ex_id ; const jobId = execution . job_id ; const jobStr = JSON . stringify ( execution ) ; const sortedNodes = _ . orderBy ( clusterState , 'available' , 'desc' ) ; let workersRequested = numOfWorkersRequested ; let availWorkers = _availableWorkers ( false , true ) ; const dispatch = _makeDispatch ( ) ; while ( workersRequested > 0 && availWorkers > 0 ) { for ( let i = 0 ; i < sortedNodes . length ; i += 1 ) { if ( workersRequested > 0 && availWorkers > 0 ) { if ( sortedNodes [ i ] . available >= 1 ) { dispatch . set ( sortedNodes [ i ] . node_id , 1 ) ; availWorkers -= 1 ; workersRequested -= 1 ; } } else { break ; } } } const workerData = { job : jobStr , id : exId , ex_id : exId , job_id : jobId , workers : 1 , assignment : 'worker' } ; while ( workersRequested > 0 ) { logger . trace ( ` ${ exId } ` ) ; pendingWorkerRequests . enqueue ( workerData ) ; workersRequested -= 1 ; } const results = [ ] ; _ . forOwn ( dispatch . getDispatch ( ) , ( workerCount , nodeId ) => { const requestedWorkersData = { job : jobStr , id : exId , ex_id : exId , job_id : jobId , workers : workerCount , assignment : 'worker' } ; const createRequest = messaging . send ( { to : 'node_master' , address : nodeId , message : 'cluster:workers:create' , payload : requestedWorkersData , response : true } ) . then ( ( msg ) => { const createdWorkers = _ . get ( msg , 'payload.createdWorkers' ) ; if ( ! _ . isInteger ( createdWorkers ) ) { logger . error ( ` ${ nodeId } ` , msg ) ; return ; } if ( createdWorkers < workerCount ) { logger . warn ( ` ${ nodeId } ${ createdWorkers } ${ workerCount } ` ) ; const newWorkersRequest = _ . cloneDeep ( requestedWorkersData ) ; newWorkersRequest . workers = workerCount - createdWorkers ; pendingWorkerRequests . enqueue ( newWorkersRequest ) ; } else { logger . debug ( ` ${ nodeId } ${ createdWorkers } ` ) ; } } ) . catch ( ( err ) => { logger . error ( err , ` ${ workerCount } ${ nodeId } ` ) ; pendingWorkerRequests . enqueue ( requestedWorkersData ) ; } ) ; results . push ( createRequest ) ; } ) ; return Promise . all ( results ) ; }
2097	function process_entry ( val , nextent ) { if ( ! val || ! val . _tmp_pathname ) { nextent ( ) ; return ; } var nm = val . _tmp_pathname ; delete val . _tmp_pathname ; if ( val . _no_evict || val . _in_flight || wb_pending [ nm ] || wb_inprogress [ nm ] ) { nextent ( ) ; return ; } if ( self . curr_size < self . max_size ) { nextent ( ) ; return ; } fs . stat ( val . _cacheFile , function ( serr , stats ) { if ( serr ) { nextent ( ) ; return ; } if ( val . _no_evict || val . _in_flight || wb_pending [ nm ] || wb_inprogress [ nm ] ) { nextent ( ) ; return ; } fs . unlink ( val . _cacheFile , function ( uerr ) { if ( ! uerr ) { self . _reduce_cache ( nm , stats . size ) ; log . trace ( 'evicted(%s, %d): %d' , nm , size , self . curr_size ) ; } nextent ( ) ; } ) ; } ) ; }
2303	function ( data , lookup , options ) { var property ; while ( property = findProperty ( lookup ) ) { if ( property . src !== lookup ) { lookup = _ . template ( lookup , data , options ) ; } else { lookup = expander . process ( data , getobject . get ( data , property . prop ) , options ) ; } } if ( hasTemplate ( lookup ) ) { lookup = _ . template ( lookup , data , options ) ; } return lookup ; }
2523	function processPointerPosition ( e ) { var xOffset = e . clientX , yOffset = e . clientY ; var radius = this . rect . width / 2 ; this . lastValue = this . value ; if ( ! this . usesRotation ) { if ( this . lastPosition !== - 1 ) { this . __value = 1 - yOffset / this . rect . height ; } } else { var xdiff = radius - xOffset ; var ydiff = radius - yOffset ; var angle = Math . PI + Math . atan2 ( ydiff , xdiff ) ; this . __value = ( angle + Math . PI * 1.5 ) % ( Math . PI * 2 ) / ( Math . PI * 2 ) ; if ( this . lastRotationValue > .8 && this . __value < .2 ) { this . __value = 1 ; } else if ( this . lastRotationValue < .2 && this . __value > .8 ) { this . __value = 0 ; } } if ( this . __value > 1 ) this . __value = 1 ; if ( this . __value < 0 ) this . __value = 0 ; this . lastRotationValue = this . __value ; this . lastPosition = yOffset ; var shouldDraw = this . output ( ) ; if ( shouldDraw ) this . draw ( ) ; }
2205	function applyIndent ( indent , content ) { if ( ! indent || indent . length < 1 ) { return content ; } return content . split ( "\n" ) . \n map . ( function ( line ) { return line . trim ( ) !== "" ? ( indent + line ) : "" ; } ) join ; }
523	function fuzzysearch ( searchString , haystack , caseInsensitive ) { var tlen = haystack . length ; var qlen = searchString . length ; var chunks = 1 ; var finding = false ; var prefix = true ; if ( qlen > tlen ) { return false ; } if ( qlen === tlen ) { if ( searchString === haystack ) { return { caseMatch : true , chunks : 1 , prefix : true } ; } else if ( searchString . toLowerCase ( ) === haystack . toLowerCase ( ) ) { return { caseMatch : false , chunks : 1 , prefix : true } ; } else { return false ; } } outer : for ( var i = 0 , j = 0 ; i < qlen ; i ++ ) { var nch = searchString [ i ] ; while ( j < tlen ) { var targetChar = haystack [ j ++ ] ; if ( targetChar === nch ) { finding = true ; continue outer ; } if ( finding ) { chunks ++ ; finding = false ; } } if ( caseInsensitive ) { return false } return fuzzysearch ( searchString . toLowerCase ( ) , haystack . toLowerCase ( ) , true ) ; } return { caseMatch : ! caseInsensitive , chunks : chunks , prefix : j <= qlen } ; }
2898	function ( connectionName , table , query , data , cb ) { var connectionObject = connections [ connectionName ] ; if ( LOG_DEBUG ) { console . log ( "BEGIN query" ) ; } if ( _ . isFunction ( data ) ) { cb = data ; data = null ; } if ( ! data ) data = { } ; connectionObject . pool . getConnection ( function ( err , connection ) { if ( err ) { return handleQueryError ( err , 'query' ) ; ; } if ( LOG_QUERIES ) { console . log ( 'Executing query: ' + query ) ; } connection . execute ( query , data , { outFormat : oracledb . OBJECT } , function ( err , result ) { if ( err ) { doRelease ( connection ) ; return cb ( err , result ) ; } return castClobs ( result , function ( err , result ) { if ( err ) { doRelease ( connection ) ; return cb ( err , result ) ; } if ( LOG_QUERIES ) { console . log ( "Length: " + result . rows . length ) ; } doRelease ( connection ) ; return cb ( err , result ) ; } ) ; } ) ; } ) ; }
70	function check ( type , provider , playsinline ) { var canPlayInline = browser . isIPhone && playsinline && support . playsinline ; var api = support [ type ] || provider !== 'html5' ; var ui = api && support . rangeInput && ( type !== 'video' || ! browser . isIPhone || canPlayInline ) ; return { api : api , ui : ui } ; }
799	function getUserHome ( ) { return process . env . HOME || process . env . HOMEPATH || process . env . USERPROFILE ; }
2342	function doRemoveDatasetClients ( datasetClientsToRemove , cb ) { var removeIds = _ . pluck ( datasetClientsToRemove , 'id' ) ; var datasetIds = _ . uniq ( _ . pluck ( datasetClientsToRemove , 'datasetId' ) ) ; debug ( 'doRemoveDatasetClients: removed datasetClients = %d, datasets = %d' , removeIds . length , datasetIds . length ) ; async . series ( [ function deleteDatasetClientAndRefs ( callback ) { async . map ( removeIds , doRemoveDatasetClientWithRecords , function ( err , deleteResult ) { if ( err ) { debug ( 'Failed to delete datasetClients due to error %s' , err ) ; } return callback ( err , deleteResult ) ; } ) ; } , function removeUnusedRecords ( callback ) { async . map ( datasetIds , removeRecordsForDataset , function ( err , deletedCount ) { if ( err ) { debug ( 'Error occured when delete records for dataset due to error %s' , err ) ; } return callback ( err , deletedCount ) ; } ) ; } ] , function ( err , results ) { if ( err ) { return cb ( err ) ; } else { return cb ( null , results [ 0 ] ) ; } } ) ; }
297	function hasClass ( element , value ) { return element . classList ? element . classList . contains ( value ) : element . className . indexOf ( value ) > - 1 ; }
1768	function toCompute ( value ) { if ( value ) { if ( value . isComputed ) { return value ; } if ( value . compute ) { return value . compute ; } else { return makeComputeLike ( value ) ; } } return value ; }
3515	function ( iterable = null ) { this . front = null ; this . back = null ; this . length = 0 ; if ( iterable !== null ) { for ( let value of iterable ) this . push ( value ) ; } }
3381	function Approximate ( ) { if ( arguments . length > 0 ) { if ( arguments [ 0 ] . length < 1 || arguments [ 0 ] . charAt ( 0 ) != 'A' ) { throw new Error ( 'Invalid Approximate Date' ) ; } try { Simple . call ( this , arguments [ 0 ] . substr ( 1 ) ) ; } catch ( e ) { throw new Error ( e . message + ' in Approximate Date' ) ; } } else { Simple . call ( this ) ; } }
842	function merge ( x , y ) { for ( const key of Object . keys ( y ) ) { if ( typeof x [ key ] === "function" ) { if ( x [ key ] . _handlers == null ) { const fs = [ x [ key ] , y [ key ] ] x [ key ] = dispatch . bind ( null , fs ) x [ key ] . _handlers = fs } else { x [ key ] . _handlers . push ( y [ key ] ) } } else { x [ key ] = y [ key ] } } return x }
670	function getRegexFromDoubleArray ( twoPartTransitionWords ) { const cacheKey = flattenDeep ( twoPartTransitionWords ) . join ( "" ) ; if ( regexFromDoubleArrayCacheKey !== cacheKey || regexFromDoubleArray === null ) { regexFromDoubleArrayCacheKey = cacheKey ; regexFromDoubleArray = createRegexFromDoubleArray ( twoPartTransitionWords ) ; } return regexFromDoubleArray ; }
3345	function ( refreshCache ) { var result = { } , selector ; if ( rules === null || refreshCache ) { CSS . refreshCache ( ) ; } for ( selector in rules ) { result [ selector ] = rules [ selector ] . cssRule ; } return result ; }
3050	function callback ( key , err , result ) { delete waiting [ key ] ; results [ key ] = result ; context . log ( err ) ; checkDone ( ) ; }
768	function Token ( token , clientId ) { this . token = token ; this . clientId = clientId ; if ( token ) { try { const parts = token . split ( '.' ) ; this . header = JSON . parse ( Buffer . from ( parts [ 0 ] , 'base64' ) . toString ( ) ) ; this . content = JSON . parse ( Buffer . from ( parts [ 1 ] , 'base64' ) . toString ( ) ) ; this . signature = Buffer . from ( parts [ 2 ] , 'base64' ) ; this . signed = parts [ 0 ] + '.' + parts [ 1 ] ; } catch ( err ) { this . content = { exp : 0 } ; } } }
3122	function ( oldKey , newKey ) { var me = this , map = me . map , indexMap = me . indexMap , index = me . indexOfKey ( oldKey ) , item ; if ( index > - 1 ) { item = map [ oldKey ] ; delete map [ oldKey ] ; delete indexMap [ oldKey ] ; map [ newKey ] = item ; indexMap [ newKey ] = index ; me . keys [ index ] = newKey ; me . generation ++ ; } }
369	function getOutputHTML ( dir ) { if ( existsSync ( ` ${ dir } ` ) ) { return readHTML ( ` ${ dir } ` ) ; } const outputHTML = readHTML ( inputIndexHTMLPath ) ; const scripts = queryAll ( outputHTML , predicates . hasTagName ( 'script' ) ) ; const moduleScripts = scripts . filter ( script => getAttribute ( script , 'type' ) === 'module' ) ; moduleScripts . forEach ( moduleScript => { remove ( moduleScript ) ; } ) ; writeOutputHTML ( dir , outputHTML ) ; return outputHTML ; }
3566	function ( ) { var self = this ; return self . valid ( ) ? { done : false , value : self . _values [ self . pointer ] } : { done : true } ; }
1280	function toLDMLString ( options ) { var getOption = getGetOption ( options , 'dateformat' ) ; var ldmlString = '' ; var option = getOption ( 'weekday' , 'string' , [ 'narrow' , 'short' , 'long' ] ) ; ldmlString += appendToLDMLString ( option , { narrow : 'EEEEE' , short : 'EEE' , long : 'EEEE' } ) ; option = getOption ( 'era' , 'string' , [ 'narrow' , 'short' , 'long' ] ) ; ldmlString += appendToLDMLString ( option , { narrow : 'GGGGG' , short : 'GGG' , long : 'GGGG' } ) ; option = getOption ( 'year' , 'string' , [ '2-digit' , 'numeric' ] ) ; ldmlString += appendToLDMLString ( option , { '2-digit' : 'yy' , 'numeric' : 'y' } ) ; option = getOption ( 'month' , 'string' , [ '2-digit' , 'numeric' , 'narrow' , 'short' , 'long' ] ) ; ldmlString += appendToLDMLString ( option , { '2-digit' : 'MM' , 'numeric' : 'M' , 'narrow' : 'MMMMM' , 'short' : 'MMM' , 'long' : 'MMMM' } ) ; option = getOption ( 'day' , 'string' , [ '2-digit' , 'numeric' ] ) ; ldmlString += appendToLDMLString ( option , { '2-digit' : 'dd' , 'numeric' : 'd' } ) ; var hr12 = getOption ( 'hour12' , 'boolean' ) ; option = getOption ( 'hour' , 'string' , [ '2-digit' , 'numeric' ] ) ; if ( IS_UNDEFINED ( hr12 ) ) { ldmlString += appendToLDMLString ( option , { '2-digit' : 'jj' , 'numeric' : 'j' } ) ; } else if ( hr12 === true ) { ldmlString += appendToLDMLString ( option , { '2-digit' : 'hh' , 'numeric' : 'h' } ) ; } else { ldmlString += appendToLDMLString ( option , { '2-digit' : 'HH' , 'numeric' : 'H' } ) ; } option = getOption ( 'minute' , 'string' , [ '2-digit' , 'numeric' ] ) ; ldmlString += appendToLDMLString ( option , { '2-digit' : 'mm' , 'numeric' : 'm' } ) ; option = getOption ( 'second' , 'string' , [ '2-digit' , 'numeric' ] ) ; ldmlString += appendToLDMLString ( option , { '2-digit' : 'ss' , 'numeric' : 's' } ) ; option = getOption ( 'timeZoneName' , 'string' , [ 'short' , 'long' ] ) ; ldmlString += appendToLDMLString ( option , { short : 'z' , long : 'zzzz' } ) ; return ldmlString ; }
3690	function _compareObject ( x , y , rc ) { if ( x === y ) return true ; if ( x . constructor && y . constructor && x . constructor !== y . constructor ) return false ; let xKeys = Object . keys ( x ) ; let yKeys = Object . keys ( y ) ; xKeys . sort ( ) ; yKeys . sort ( ) ; if ( ! _equals ( xKeys , yKeys , rc ) ) return false ; rc . push ( x , y ) ; for ( let k in x ) { if ( ! _equals ( x [ k ] , y [ k ] , rc ) ) return false ; } rc . pop ( ) ; return true ; }
1961	function evaluateConditions ( template , variables ) { let source ; do { source = template ; template = processSimpleConditions ( template , variables ) ; template = processIfElseConditions ( template , variables ) ; } while ( source !== template ) ; return template ; }
1997	function closest ( element , selector ) { while ( element && element . nodeType !== DOCUMENT_NODE_TYPE ) { if ( typeof element . matches === 'function' && element . matches ( selector ) ) { return element ; } element = element . parentNode ; } }
3363	function ( fn ) { var me = this ; fn = fn || me . sorterFn || me . defaultSorterFn ; me . sort = me . createSortFunction ( fn ) ; }
1764	function handleGroup ( self , group , width , maxColumns ) { if ( group . length === 0 ) { return ; } var minRows = Math . ceil ( group . length / maxColumns ) ; for ( var row = 0 ; row < minRows ; row ++ ) { for ( var col = 0 ; col < maxColumns ; col ++ ) { var idx = row * maxColumns + col ; if ( idx >= group . length ) { break ; } var item = group [ idx ] ; self . _writeToOutput ( item ) ; if ( col < maxColumns - 1 ) { for ( var s = 0 ; s < width - item . length ; s ++ ) { self . _writeToOutput ( ' ' ) ; } } } self . _writeToOutput ( '\r\n' ) ; } \r }
3052	function ( ) { var me = this , id = me . stateful && me . getStateId ( ) , hasListeners = me . hasListeners , state ; if ( id ) { state = Ext . state . Manager . get ( id ) ; if ( state ) { state = Ext . apply ( { } , state ) ; if ( ! hasListeners . beforestaterestore || me . fireEvent ( 'beforestaterestore' , me , state ) !== false ) { me . applyState ( state ) ; if ( hasListeners . staterestore ) { me . fireEvent ( 'staterestore' , me , state ) ; } } } } }
1284	function BinaryConstraint ( var1 , var2 , strength ) { BinaryConstraint . superConstructor . call ( this , strength ) ; this . v1 = var1 ; this . v2 = var2 ; this . direction = Direction . NONE ; this . addConstraint ( ) ; }
680	async function streamToString ( readableStream ) { return new Promise ( ( resolve , reject ) => { const chunks = [ ] ; readableStream . on ( "data" , data => { chunks . push ( data . toString ( ) ) ; } ) ; readableStream . on ( "end" , ( ) => { resolve ( chunks . join ( "" ) ) ; } ) ; readableStream . on ( "error" , reject ) ; } ) ; }
3664	function ( criteria , limit , cb ) { if ( _ . isFunction ( limit ) ) { cb = limit ; limit = undefined ; } var self = this ; var query = buildQuery ( criteria , limit ) ; client . createCollection ( options ( self , query ) , translateSDKCallback ( function ( err , collection ) { if ( err ) { return cb ( err ) ; } cb ( null , wrapCollection ( self , collection ) ) ; } ) ) ; }
2867	function ( config , aliasMap , pluginInstances ) { var self = this ; pluginInstances . forEach ( function ( instance ) { if ( instance . runBefore ) { var befores = self . _castArray ( instance . runBefore ) ; config = self . _mergeAuthorProvidedOrderWithConfigOrder ( 'before' , instance . name , befores , config , aliasMap ) ; } if ( instance . runAfter ) { var afters = self . _castArray ( instance . runAfter ) ; config = self . _mergeAuthorProvidedOrderWithConfigOrder ( 'after' , instance . name , afters , config , aliasMap ) ; } } ) ; var aliases = this . _flattenAliasMap ( aliasMap ) ; var configNames = Object . keys ( config ) . reduce ( function ( arr , key ) { arr . push ( key ) ; var befores = self . _castArray ( config [ key ] . before ) ; var afters = self . _castArray ( config [ key ] . after ) ; return arr . concat ( befores ) . concat ( afters ) ; } , [ ] ) . reduce ( function ( arr , key ) { if ( arr . indexOf ( key ) === - 1 ) { arr . push ( key ) ; } return arr ; } , [ ] ) ; var unknownConfigKeys = _ . difference ( configNames , aliases ) ; if ( unknownConfigKeys . length ) { this . _logUnknownPlugins ( unknownConfigKeys , 'config.pipeline.runOrder' ) ; } return config ; }
2022	function ( apporplugin ) { try { configHelpers . enable ( apporplugin ) ; logger . info ( apporplugin + ' enabled' ) ; } catch ( err ) { logger . error ( 'Cannot enable given app or plugin, ' + apporplugin + ' cannot find it in the config file.' ) ; } }
2775	function atomSerialize ( ) { var options = { isUnloading : true } if ( atom . serialize != null ) return atom . serialize ( options ) return { version : atom . constructor . version , project : atom . project . serialize ( options ) , workspace : atom . workspace . serialize ( ) , packageStates : packageStatesSerialize ( ) , grammars : { grammarOverridesByPath : atom . grammars . grammarOverridesByPath } , fullScreen : atom . isFullScreen ( ) , windowDimensions : atom . windowDimensions } }
2473	function topVerbs ( activities , count ) { var counts = { } , list = [ ] , top ; for ( var i in activities ) { var verb = activities [ i ] . verb ; counts [ verb ] = ( counts [ verb ] || 0 ) + 1 ; } for ( key in counts ) list . push ( { key : key , values : counts [ key ] } ) ; top = list . sort ( function ( a , b ) { return b . values - a . values } ) . slice ( 0 , count ) . map ( function ( verb ) { return verb . key } ) . concat ( "other" ) ; verbsShowing = top . reduce ( function ( showing , verb ) { showing [ verb . key ] = verbsShowing [ verb ] ; if ( showing [ verb ] == undefined ) showing [ verb ] = true ; return showing ; } , { } ) ; return top ; }
475	function recursiveFn ( source , target , key ) { if ( isArray ( source ) || isObject ( source ) ) { target = isPrimitive ( target ) ? isObject ( source ) ? { } : [ ] : target ; for ( var _key in source ) { setter ( target , _key , recursiveFn ( source [ _key ] , target [ _key ] , _key ) ) ; } return target ; } return fn ( source , target , key ) ; }
617	function sortCombinations ( wordCombinations ) { wordCombinations . sort ( function ( combinationA , combinationB ) { const difference = combinationB . getRelevance ( ) - combinationA . getRelevance ( ) ; if ( difference !== 0 ) { return difference ; } return combinationB . getLength ( ) - combinationA . getLength ( ) ; } ) ; }
941	function hookAPIInit ( init , args , ctx ) { if ( isFunction ( init ) ) { if ( args . length > 1 || ! isObject ( args [ 0 ] ) ) { args = [ args ] ; } return init . apply ( this , [ ... args , ctx ] ) ; } }
590	function init ( ) { function animate ( ) { updateGeometries ( ) ; render ( ) ; requestAnimationFrame ( function ( ) { animate ( ) ; } ) ; } threeD = document . getElementById ( 'r3d' ) ; renderer = new THREE . WebGLRenderer ( { antialias : true , } ) ; renderer . setSize ( threeD . offsetWidth , threeD . offsetHeight ) ; renderer . setClearColor ( 0x353535 , 1 ) ; renderer . setPixelRatio ( window . devicePixelRatio ) ; threeD . appendChild ( renderer . domElement ) ; stats = new Stats ( ) ; threeD . appendChild ( stats . domElement ) ; scene = new THREE . Scene ( ) ; camera = new THREE . PerspectiveCamera ( 45 , threeD . offsetWidth / threeD . offsetHeight , 0.01 , 10000000 ) ; camera . position . x = 150 ; camera . position . y = 150 ; camera . position . z = 100 ; controls = new ControlsTrackball ( camera , threeD ) ; controls . rotateSpeed = 1.4 ; controls . zoomSpeed = 1.2 ; controls . panSpeed = 0.8 ; controls . noZoom = false ; controls . noPan = false ; controls . dynamicDampingFactor = 0.3 ; particleLight = new THREE . Mesh ( new THREE . SphereGeometry ( 2 , 8 , 8 ) , new THREE . MeshBasicMaterial ( { color : 0xfff336 } ) ) ; scene . add ( particleLight ) ; animate ( ) ; }
1186	function createImageData ( image ) { const canvas = document . createElement ( 'canvas' ) const ctx = canvas . getContext ( '2d' ) const width = image . naturalWidth const height = image . naturalHeight canvas . width = width canvas . height = height ctx . drawImage ( image , 0 , 0 ) return ctx . getImageData ( 0 , 0 , image . naturalWidth , image . naturalHeight ) }
173	function customPostMetadataToProductAttributes ( metadata ) { const productAttributes = { } ; metadata . forEach ( ( { key , value } ) => { const schemaKey = metaKeyToSchemaKeyMap [ key ] ; if ( ! schemaKey ) { return ; } if ( metadataSchema [ schemaKey ] . type === 'boolean' ) { value = ! ! Number ( value ) ; } productAttributes [ schemaKey ] = value ; } ) ; return productAttributes ; }
2482	function ( thingy ) { if ( typeof ( thingy ) == 'string' ) thingy = document . getElementById ( thingy ) ; if ( ! thingy . addClass ) { thingy . hide = function ( ) { this . style . display = 'none' ; } ; thingy . show = function ( ) { this . style . display = '' ; } ; thingy . addClass = function ( name ) { this . removeClass ( name ) ; this . className += ' ' + name ; } ; thingy . removeClass = function ( name ) { var classes = this . className . split ( / \s+ / ) ; var idx = - 1 ; for ( var k = 0 ; k < classes . length ; k ++ ) { if ( classes [ k ] == name ) { idx = k ; k = classes . length ; } } if ( idx > - 1 ) { classes . splice ( idx , 1 ) ; this . className = classes . join ( ' ' ) ; } return this ; } ; thingy . hasClass = function ( name ) { return ! ! this . className . match ( new RegExp ( "\\s*" + \\ + name ) ) ; } ; } "\\s*" }
3638	function ( key ) { var value ; if ( key . indexOf ( '.' ) == - 1 ) { value = this . configObj [ key ] ; } else { var keyArray = key . split ( '.' ) ; var keyStr = keyArray [ 0 ] ; value = this . configObj [ keyStr ] ; for ( var i = 1 , len = keyArray . length ; i < len ; i ++ ) { if ( ! value && i < len - 1 ) { exitProcess ( 'the var [' + keyStr + '] is empty.' , this . alarm ) ; return undefined ; } var keyNow = keyArray [ i ] ; keyStr += '.' + keyNow ; value = value [ keyNow ] ; } } slogger . debug ( 'load var [' + key + '],value:' , value ) ; return value ; }
1310	function ValueToProtocolValue_ ( value , mirror_serializer ) { var json ; switch ( typeof value ) { case 'object' : if ( value instanceof Mirror ) { json = mirror_serializer . serializeValue ( value ) ; } else if ( IS_ARRAY ( value ) ) { json = ArrayToProtocolArray_ ( value , mirror_serializer ) ; } else { json = ObjectToProtocolObject_ ( value , mirror_serializer ) ; } break ; case 'boolean' : case 'string' : case 'number' : json = value ; break ; default : json = null ; } return json ; }
2066	function addOrSubtractDurationFromMoment ( mom , duration , isAdding , ignoreUpdateOffset ) { var milliseconds = duration . _milliseconds , days = duration . _days , months = duration . _months , minutes , hours , currentDate ; if ( milliseconds ) { mom . _d . setTime ( + mom . _d + milliseconds * isAdding ) ; } if ( days || months ) { minutes = mom . minute ( ) ; hours = mom . hour ( ) ; } if ( days ) { mom . date ( mom . date ( ) + days * isAdding ) ; } if ( months ) { mom . month ( mom . month ( ) + months * isAdding ) ; } if ( milliseconds && ! ignoreUpdateOffset ) { moment . updateOffset ( mom ) ; } if ( days || months ) { mom . minute ( minutes ) ; mom . hour ( hours ) ; } }
942	function hookAPIDone ( done , sync , args , ctx ) { let hasDoneHook = isFunction ( done ) ; let hasIntercepted = false ; let doneHookInfo ; if ( hasDoneHook ) { doneHookInfo = createAPIDoneHook ( done , ctx ) ; hasIntercepted = interceptAsyncAPIDone ( sync , args , doneHookInfo . hook ) ; } return { hasDoneHook , hasIntercepted , doneHookInfo } ; }
1723	function Base ( options ) { this . _eventOutput = new EventHandler ( ) ; this . _pool = [ ] ; EventHandler . setOutputHandler ( this , this . _eventOutput ) ; if ( options ) { for ( var key in options ) { this [ key ] = options [ key ] ; } } }
1163	function ( attrs , value , opt ) { var currentAttrs = this . get ( 'attrs' ) ; var delim = '/' ; if ( _ . isString ( attrs ) ) { if ( value ) { var attr = { } ; joint . util . setByPath ( attr , attrs , value , delim ) ; return this . set ( 'attrs' , _ . merge ( { } , currentAttrs , attr ) , opt ) ; } else { return joint . util . getByPath ( currentAttrs , attrs , delim ) ; } } return this . set ( 'attrs' , _ . merge ( { } , currentAttrs , attrs ) , value ) ; }
587	function onMouseMove ( event ) { if ( ctrlDown ) { if ( drag . start . x === null ) { drag . start . x = event . clientX ; drag . start . y = event . clientY ; } let threshold = 15 ; stackHelper . slice . intensityAuto = false ; let dynamicRange = stack . minMax [ 1 ] - stack . minMax [ 0 ] ; dynamicRange /= threeD . clientWidth ; if ( Math . abs ( event . clientX - drag . start . x ) > threshold ) { stackHelper . slice . windowWidth += dynamicRange * ( event . clientX - drag . start . x ) ; drag . start . x = event . clientX ; } if ( Math . abs ( event . clientY - drag . start . y ) > threshold ) { stackHelper . slice . windowCenter -= dynamicRange * ( event . clientY - drag . start . y ) ; drag . start . y = event . clientY ; } } }
725	function ( ) { var self = this ; self . loadedSearches = { } ; self . userOptions = { } ; self . renderCache = { } ; var options = self . options ; $ . each ( self . options , function ( key , value ) { if ( self . items . indexOf ( key ) == - 1 ) { delete options [ key ] ; } } ) ; self . options = self . sifter . items = options ; self . lastQuery = null ; self . trigger ( 'option_clear' ) ; }
3538	function CouchDBCache ( options ) { var self = this ; options = options || { } ; this . expireAfterSeconds = options . expireAfterSeconds || 60 ; this . connection = Promise . resolve ( ) . then ( function ( ) { return options . auth ? this . auth ( options . auth . username , options . auth . password ) : null ; } ) . then ( function ( cookie ) { return nano ( { url : options . url || ( options . protocol + '://' + options . host + ':' + options . port ) , cookie : cookie } ) ; } ) ; this . db = this . connection . then ( function ( connection ) { var dbName = options . db || 'openamagent' ; return Promise . promisify ( connection . db . create . bind ( connection . db ) ) ( dbName ) . catch ( function ( ) { } ) . then ( function ( ) { return connection . use ( dbName ) ; } ) ; } ) ; }
3652	function ( url ) { if ( ! ( url in this . sourceCache ) ) { this . sourceCache [ url ] = this . ajax ( url ) . split ( '\n' ) ; } \n }
2680	function createGlobals ( shell ) { var globals = { Buffer : Buffer , console : console , clearImmediate : clearImmediate , clearInterval : clearInterval , clearTimeout : clearTimeout , setImmediate : setImmediate , setInterval : setInterval , setTimeout : setTimeout , _ : ijsrt } ; globals . global = globals ; return globals ; }
3159	function ( data ) { for ( var key in data ) { if ( data . hasOwnProperty ( key ) ) { var setting = this . _settings [ key ] ; if ( setting ) { var value = setting . type . parse ( data [ key ] ) ; this . set ( key , value ) ; } else { this . set ( key , data [ key ] ) ; } } } }
2101	function ( soajs , combo , cb ) { checkForMongo ( soajs ) ; mongo . findOne ( combo . collection , combo . condition || { } , combo . fields || null , combo . options || null , cb ) ; }
3520	function ( cmp ) { var me = this , newGroup = cmp , oldGroup ; if ( Ext . isString ( cmp ) ) { newGroup = Ext . getCmp ( newGroup ) ; } if ( newGroup === me . activeGroup ) { return true ; } oldGroup = me . activeGroup ; if ( me . fireEvent ( 'beforegroupchange' , me , newGroup , oldGroup ) !== false ) { me . activeGroup = newGroup ; me . fireEvent ( 'groupchange' , me , newGroup , oldGroup ) ; } else { return false ; } return true ; }
3196	function directory_path ( ) { pending ++ readdir ( entry , ( err , children ) => { if ( err ) return done ( err ) for ( var i = children . length ; i -- ; ) { if ( path !== null && base !== null ) { files . push ( { base , path : join ( path , children [ i ] ) } ) } else if ( path !== null ) { files . push ( { base : null , path : join ( path , children [ i ] ) } ) } else { files . push ( { base , path : children [ i ] } ) } } pending -- done ( null , null ) } ) }
490	function set ( value ) { if ( value === true ) { while ( waitingQueue . length > 0 ) { waitingQueue [ 0 ] ( ) ; waitingQueue . shift ( ) ; } } return value ; }
1937	function getPropertiesForGradient ( gradient , propertyName ) { var props = [ ] ; var css = require ( 'cssResolver' ) ; if ( prefs . get ( 'css.gradient.fallback' ) && ~ propertyName . toLowerCase ( ) . indexOf ( 'background' ) ) { props . push ( { name : 'background-color' , value : '${1:' + gradient . colorStops [ 0 ] . color + '}' } ) ; } _ . each ( prefs . getArray ( 'css.gradient.prefixes' ) , function ( prefix ) { var name = css . prefixed ( propertyName , prefix ) ; if ( prefix == 'webkit' && prefs . get ( 'css.gradient.oldWebkit' ) ) { try { props . push ( { name : name , value : module . oldWebkitLinearGradient ( gradient ) } ) ; } catch ( e ) { } } props . push ( { name : name , value : module . toString ( gradient , prefix ) } ) ; } ) ; return props . sort ( function ( a , b ) { return b . name . length - a . name . length ; } ) ; }
997	function cloneObject ( object ) { var clone = { } ; if ( object ) { for ( var key in object ) clone [ key ] = object [ key ] ; } return clone ; }
2260	function fetch ( options ) { var time , promise , resolve , reject ; time = new Date ( ) ; promise = new Promise ( function ( r1 , r2 ) { resolve = r1 ; reject = r2 ; } ) ; try { options = normalise ( options ) ; if ( options . resultIds ) { wpt . getResults ( options , options . resultIds ) . then ( after ) ; } else { wpt . runTests ( options ) . then ( wpt . getResults . bind ( null , options ) ) . then ( after ) ; } } catch ( error ) { reject ( error ) ; } return promise ; function after ( results ) { results = { data : results , options : options , times : { begin : time , end : new Date ( ) } } ; if ( options . dump ) { dump ( options , results ) ; } resolve ( results ) ; } }
584	function hookCallbacks ( stackHelper ) { let stack = stackHelper . _stack ; controls . addEventListener ( 'OnScroll' , function ( e ) { if ( e . delta > 0 ) { if ( stackHelper . index >= stackHelper . orientationMaxIndex - 1 ) { return false ; } stackHelper . index += 1 ; } else { if ( stackHelper . index <= 0 ) { return false ; } stackHelper . index -= 1 ; } } ) ; function onWindowResize ( ) { let threeD = document . getElementById ( 'r3d' ) ; camera . canvas = { width : threeD . clientWidth , height : threeD . clientHeight , } ; camera . fitBox ( 2 ) ; renderer . setSize ( threeD . clientWidth , threeD . clientHeight ) ; stackHelper . slice . canvasWidth = threeD . clientWidth ; stackHelper . slice . canvasHeight = threeD . clientHeight ; } window . addEventListener ( 'resize' , onWindowResize , false ) ; onWindowResize ( ) ; function onWindowKeyPressed ( event ) { ctrlDown = event . ctrlKey ; if ( ! ctrlDown ) { drag . start . x = null ; drag . start . y = null ; } } document . addEventListener ( 'keydown' , onWindowKeyPressed , false ) ; document . addEventListener ( 'keyup' , onWindowKeyPressed , false ) ; function onMouseMove ( event ) { if ( ctrlDown ) { if ( drag . start . x === null ) { drag . start . x = event . clientX ; drag . start . y = event . clientY ; } let threshold = 15 ; stackHelper . slice . intensityAuto = false ; let dynamicRange = stack . minMax [ 1 ] - stack . minMax [ 0 ] ; dynamicRange /= threeD . clientWidth ; if ( Math . abs ( event . clientX - drag . start . x ) > threshold ) { stackHelper . slice . windowWidth += dynamicRange * ( event . clientX - drag . start . x ) ; drag . start . x = event . clientX ; } if ( Math . abs ( event . clientY - drag . start . y ) > threshold ) { stackHelper . slice . windowCenter -= dynamicRange * ( event . clientY - drag . start . y ) ; drag . start . y = event . clientY ; } } } document . addEventListener ( 'mousemove' , onMouseMove ) ; }
2173	function updateScroll ( ) { if ( ! elements . li [ 0 ] ) return ; var height = elements . li [ 0 ] . offsetHeight , top = height * ctrl . index , bot = top + height , hgt = elements . scroller . clientHeight , scrollTop = elements . scroller . scrollTop ; if ( top < scrollTop ) { scrollTo ( top ) ; } else if ( bot > scrollTop + hgt ) { scrollTo ( bot - hgt ) ; } }
2599	function ascending ( a ) { if ( ! ( a instanceof Array ) ) return a ; return a . sort ( function ( a , b ) { if ( a !== undefined && a !== null ) a = a . toString ( ) ; if ( b !== undefined && b !== null ) b = b . toString ( ) ; return a < b ? - 1 : a > b ? 1 : 0 ; } ) ; }
2061	function ( toolKey , toolDefinition , group , index ) { taRegisterTool ( toolKey , toolDefinition ) ; angular . forEach ( toolbars , function ( toolbarScope ) { toolbarScope . addTool ( toolKey , toolDefinition , group , index ) ; } ) ; }
3711	function repeat ( times ) { return function * ( it ) { const buffer = [ ] ; for ( const item of it ) { buffer . push ( item ) ; yield item ; } for ( let i = 0 ; i < times ; ++ i ) { yield * buffer ; } } ; }
1498	function GetTotalFlexGrow ( columns ) { var totalFlexGrow = 0 ; for ( let c of columns ) { totalFlexGrow += c . flexGrow || 0 ; } return totalFlexGrow ; }
200	function cssNameFromFilename ( name ) { if ( name ) { const [ cssChunkFilename , chunkQueryString ] = name . split ( '?' , 2 ) ; return cssChunkFilename . replace ( / \.js$ / i , '.css' + ( chunkQueryString ? ` ${ chunkQueryString } ` : '' ) ) ; } }
1003	function createNewRow ( layoutConfig , layoutData ) { var isBreakoutRow ; if ( layoutConfig . fullWidthBreakoutRowCadence !== false ) { if ( ( ( layoutData . _rows . length + 1 ) % layoutConfig . fullWidthBreakoutRowCadence ) === 0 ) { isBreakoutRow = true ; } } return new Row ( { top : layoutData . _containerHeight , left : layoutConfig . containerPadding . left , width : layoutConfig . containerWidth - layoutConfig . containerPadding . left - layoutConfig . containerPadding . right , spacing : layoutConfig . boxSpacing . horizontal , targetRowHeight : layoutConfig . targetRowHeight , targetRowHeightTolerance : layoutConfig . targetRowHeightTolerance , edgeCaseMinRowHeight : 0.5 * layoutConfig . targetRowHeight , edgeCaseMaxRowHeight : 2 * layoutConfig . targetRowHeight , rightToLeft : false , isBreakoutRow : isBreakoutRow , widowLayoutStyle : layoutConfig . widowLayoutStyle } ) ; }
2723	function Debug ( ... rest ) { if ( new . target ) { this . debug = ( id , stats , ... rest ) => { debug ( id ) ( ... rest ) ; } ; return ; } return new Debug ( ... rest ) ; }
2654	function smsAddPhonesWithVariables ( callback , addressbook_id , phones ) { if ( ( addressbook_id === undefined ) || ( phones === undefined ) || ( ! Object . keys ( phones ) . length ) ) { return callback ( returnError ( "Empty phones or book id" ) ) ; } var data = { addressBookId : addressbook_id , phones : JSON . stringify ( phones ) } ; sendRequest ( 'sms/numbers/variables' , 'POST' , data , true , callback ) ; }
283	function loadDirectlyScript ( ) { return new Promise ( ( resolve , reject ) => { loadScript ( DIRECTLY_RTM_SCRIPT_URL , function ( error ) { if ( error ) { return reject ( new Error ( ` ${ error . src } ` ) ) ; } resolve ( ) ; } ) ; } ) ; }
1192	function ( range , touchingIsIntersecting ) { assertRangeValid ( this ) ; if ( getRangeDocument ( range ) != getRangeDocument ( this ) ) { throw new DOMException ( "WRONG_DOCUMENT_ERR" ) ; } var startComparison = dom . comparePoints ( this . startContainer , this . startOffset , range . endContainer , range . endOffset ) , endComparison = dom . comparePoints ( this . endContainer , this . endOffset , range . startContainer , range . startOffset ) ; return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0 ; }
3813	function ( cb ) { cb = util . optional ( cb ) ; this . loadMiddleware ( function ( err ) { if ( err ) return cb ( err ) ; sails . log . verbose ( 'Finished loading policy middleware logic.' ) ; cb ( ) ; } . bind ( this ) ) ; sails . on ( 'router:before' , this . bindPolicies ) ; }
2079	function ( inputPath , outputPath , outputCharset ) { var target = path . resolve ( inputPath ) , result = { 'success' : true , 'files' : [ ] } ; if ( fs . existsSync ( target ) ) { if ( fs . statSync ( target ) . isDirectory ( ) ) { var targets = fs . readdirSync ( target ) ; for ( var i in targets ) { if ( ! ModuleCompiler . isFileIgnored ( targets [ i ] ) ) { var inputFile = path . resolve ( target , targets [ i ] ) , outputFile = path . join ( outputPath , targets [ i ] ) ; if ( path . extname ( inputFile ) === '.js' ) { result . files . push ( ModuleCompiler . build ( inputFile , outputFile , outputCharset ) ) ; } } } } else { result . files . push ( ModuleCompiler . build ( target , outputPath , outputCharset ) ) ; } } else { var modulePath = ModuleCompiler . getModulePath ( inputPath ) ; if ( modulePath ) { result . files . push ( ModuleCompiler . build ( modulePath , outputPath , outputCharset ) ) ; } else { result . success = false ; ! ModuleCompiler . _config . silent && console . info ( '[err]' . bold . red + ' cannot find target: %s' , target ) ; } } return result ; }
3761	function end ( ) { this . writeBuffer ( this . crc . value ( ) ) ; fs . closeSync ( this . fd ) ; this . fd = null ; this . crc = null ; this . converter = null ; }
736	function ResourceNamespace ( stripe , resources ) { for ( var name in resources ) { var camelCaseName = name [ 0 ] . toLowerCase ( ) + name . substring ( 1 ) ; var resource = new resources [ name ] ( stripe ) ; this [ camelCaseName ] = resource ; } }
674	function getIndicesOfWords ( text ) { const indices = [ ] ; const words = getWords ( text ) ; let startSearchFrom = 0 ; words . forEach ( function ( word ) { const currentIndex = text . indexOf ( word , startSearchFrom ) ; indices . push ( currentIndex ) ; startSearchFrom = currentIndex + word . length ; } ) ; return indices ; }
1735	function main ( ) { return new Promise ( ( resolve ) => { fsx . readFile ( path . resolve ( __dirname , '../package.json' ) , 'utf8' , ( err , data ) => { if ( err ) { throw err ; } resolve ( data ) ; } ) ; } ) . then ( ( data ) => JSON . parse ( data ) ) . then ( ( packageData ) => { const { author , version , description , keywords , repository , license , bugs , homepage , peerDependencies , dependencies , } = packageData ; const minimalPackage = { name : '@boundlessgeo/sdk' , author , version , description , keywords , repository , license , bugs , homepage , peerDependencies , dependencies , } ; return new Promise ( ( resolve ) => { const buildPath = path . resolve ( __dirname , '../dist/package.json' ) ; const data = JSON . stringify ( minimalPackage , null , 2 ) ; fsx . writeFile ( buildPath , data , ( err ) => { if ( err ) { throw ( err ) ; } process . stdout . write ( ` ${ buildPath } \n ` ) ; resolve ( ) ; } ) ; } ) ; } ) ; }
2566	function bindProperty ( o , parent , prop ) { Object . defineProperty ( o , prop , { get : function ( ) { try { return parent [ prop ] ; } catch ( e ) { } } , set : function ( val ) { try { parent [ prop ] = val ; } catch ( e ) { } } , configurable : true } ) ; }
2742	function AposGroups ( options ) { var self = this ; aposSchemas . addFieldType ( { name : 'a2Permissions' , displayer : function ( snippet , name , $field , $el , field , callback ) { _ . each ( apos . data . aposGroups . permissions , function ( permission ) { $el . findByName ( permission . value ) . val ( _ . contains ( snippet . permissions || [ ] , permission . value ) ? '1' : '0' ) ; } ) ; return callback ( ) ; } , converter : function ( data , name , $field , $el , field , callback ) { _ . each ( apos . data . aposGroups . permissions , function ( permission ) { data [ permission . value ] = $el . findByName ( permission . value ) . val ( ) ; } ) ; return callback ( ) ; } } ) ; aposSchemas . addFieldType ( { name : 'a2People' , displayer : function ( snippet , name , $field , $el , field , callback ) { var source = aposPages . getType ( 'people' ) . _action + '/autocomplete' ; $ . jsonCall ( source , { values : _ . map ( snippet . people || [ ] , function ( person ) { return person . _id ; } ) } , function ( results ) { var labelMap = { } ; _ . each ( results , function ( result ) { labelMap [ result . value ] = result . label ; } ) ; $el . find ( '[data-name="people"]' ) . selective ( { sortable : options . peopleSortable , extras : field . extras , source : source , data : _ . map ( snippet . _people || [ ] , function ( person ) { var label = labelMap [ person . _id ] ; var data = { label : label , value : person . _id } ; if ( person . groupExtras && person . groupExtras [ snippet . _id ] ) { $ . extend ( true , data , person . groupExtras [ snippet . _id ] ) ; } return data ; } ) } ) ; return callback ( ) ; } ) ; } , converter : function ( data , name , $field , $el , field , callback ) { data . _peopleInfo = $el . find ( '[data-name="people"]' ) . selective ( 'get' , { incomplete : true } ) ; return callback ( ) ; } } ) ; AposSnippets . call ( self , options ) ; self . addingToManager = function ( $el , $snippet , snippet ) { $snippet . find ( '[data-published]' ) . val ( snippet . published ? 'Yes' : 'No' ) ; } ; }
2019	function ( program , app , callback ) { var attachPlugin = function ( pluginName , cb ) { pluginHelpers . start ( pluginName , program , app , cb ) ; } ; var plugins = Object . keys ( pluginHelpers . loadedPlugins ) async . eachSeries ( plugins , attachPlugin , function ( ) { callback ( ) ; } ) ; }
2518	function ( fn , ctx ) { var task = ! ctx ? fn : fn . bind ( ctx ) ; this . reads . push ( task ) ; scheduleFlush ( this ) ; return task ; }
357	function required ( rule , value , source , errors , options , type ) { if ( rule . required && ( ! source . hasOwnProperty ( rule . field ) || util . isEmptyValue ( value , type || rule . type ) ) ) { errors . push ( util . format ( options . messages . required , rule . fullField ) ) ; } }
3084	function ( ) { var $ = cheerio . load ( this . form . html . template ) ; this . form . controls . forEach ( function ( ctl ) { switch ( ctl . type ) { case 'checkboxGroup' : case 'radioGroup' : ctl . items . forEach ( function ( item ) { var input = $ ( 'input#' + item . id ) ; input . attr ( 'disabled' , 'disabled' ) ; if ( item . value ) input . attr ( 'checked' , 'checked' ) ; } ) ; break ; case 'selectMenu' : var select = $ ( 'select#' + ctl . id ) ; select . attr ( 'disabled' , 'disabled' ) ; ctl . items . forEach ( function ( item ) { if ( item . value ) select . val ( item . id ) ; } ) ; break ; case 'inputText' : var input = $ ( 'input#' + ctl . id ) ; input . val ( ctl . value ) ; input . attr ( 'disabled' , 'disabled' ) ; break ; case 'associativeGroup' : var ag = $ ( 'fieldset#' + ctl . id ) ; ag . addClass ( 'disabled' ) ; utils . associativeGroupCategories ( ctl ) . forEach ( function ( category ) { var $dropTarget = ag . find ( '#category-' + category . item . id ) . find ( '.dropTarget' ) ; category . items . forEach ( function ( item ) { var $item = ag . find ( '#item-' + item . id ) ; $dropTarget . append ( $item ) ; } ) ; } ) ; break ; } } , this ) ; this . form . html . solution = $ . html ( ) ; $ = cheerio . load ( this . form . html . template ) ; $ ( '.solution' ) . remove ( ) ; utils . shuffle ( $ , '.sortableGroup' ) ; utils . shuffle ( $ , '.associativeGroup .items' ) ; this . form . html . prompt = $ . html ( ) ; }
968	function updateArrayItem ( observer , idx , value ) { observer . set ( idx , value ) ; this [ idx ] = value ; }
2413	function readConfig ( ) { const pkgConfigPromise = new Promise ( ( resolve , reject ) => { fs . readFile ( path . join ( process . cwd ( ) , "package.json" ) ) . then ( ( data ) => { try { resolve ( JSON . parse ( data ) . inlineImport ) ; } catch ( error ) { reject ( error ) ; } } ) . catch ( ( error ) => { resolve ( ) ; } ) ; } ) ; const configFilePromise = new Promise ( ( resolve , reject ) => { fs . readFile ( path . join ( process . cwd ( ) , argv . config ) ) . then ( ( data ) => { try { resolve ( JSON . parse ( data ) ) ; } catch ( error ) { reject ( error ) ; } } ) . catch ( ( error ) => { if ( error . code === "ENOENT" ) { reject ( "No configuration found (" + argv . config + ")" ) ; } else { reject ( "Failed to read the configuration file (" + error + ")" ) ; } } ) ; } ) ; return new Promise ( ( resolve , reject ) => { pkgConfigPromise . then ( ( config ) => { return ( config !== undefined ) ? Promise . resolve ( config ) : configFilePromise ; } ) . then ( resolve ) . catch ( reject ) ; } ) ; }
307	function getOffset ( element ) { var box = element . getBoundingClientRect ( ) ; return { left : box . left + ( window . pageXOffset - document . documentElement . clientLeft ) , top : box . top + ( window . pageYOffset - document . documentElement . clientTop ) } ; }
711	function removeAndRefresh ( d ) { var table = d . parentNode var par = table . parentNode var placeholder = dom . createElement ( 'table' ) placeholder . setAttribute ( 'style' , 'width: 100%;' ) par . replaceChild ( placeholder , table ) table . removeChild ( d ) par . replaceChild ( table , placeholder ) }
442	function getMinFromProps ( props , axis ) { if ( isPlainObject ( props . minDomain ) && props . minDomain [ axis ] !== undefined ) { return props . minDomain [ axis ] ; } return typeof props . minDomain === "number" ? props . minDomain : undefined ; }
2524	function setContextValue ( setChainContext , chainId , name , value ) { if ( value instanceof Function ) { throw new FunctionAsValueException ( ) ; } setChainContext ( chainId , name , value ) ; }
693	function ( subject ) { var target = kb . any ( subject , ns . meeting ( 'target' ) ) || subject var count = kb . each ( target , predicate ) . length if ( count > 0 ) { return UI . utils . label ( predicate ) + ' ' + count } return null }
1872	function ( text , pad ) { var padStr = ( _ . isNumber ( pad ) ) ? this . repeatString ( require ( 'resources' ) . getVariable ( 'indentation' ) || '\t' , \t ) : pad ; pad var result = [ ] ; var lines = this . splitByLines ( text ) ; var nl = this . getNewline ( ) ; result . push ( lines [ 0 ] ) ; for ( var j = 1 ; j < lines . length ; j ++ ) result . push ( nl + padStr + lines [ j ] ) ; }
1800	function ChartJsProvider ( ) { var options = { } ; var ChartJs = { Chart : Chart , getOptions : function ( type ) { var typeOptions = type && options [ type ] || { } ; return angular . extend ( { } , options , typeOptions ) ; } } ; this . setOptions = function ( type , customOptions ) { if ( ! customOptions ) { customOptions = type ; options = angular . extend ( options , customOptions ) ; return ; } options [ type ] = angular . extend ( options [ type ] || { } , customOptions ) ; } ; this . $get = function ( ) { return ChartJs ; } ; }
3797	function ( cb ) { var calli = Dog . new ( { name : 'Calli' } ) ; scott . addDog ( calli , function ( err ) { if ( err ) { return cb ( err ) ; } scott . fetchDogs ( function ( err ) { if ( err ) { return cb ( err ) ; } assert ( scott . dogs ) ; var dog = scott . dogs [ 0 ] ; assert ( dog . uuid ) ; assert ( dog . name === 'Calli' ) ; cb ( ) ; } ) ; } ) ; }
2285	function filterElement ( flJson ) { var returnJson = { "photo" : { } } ; returnJson . photo . title = flJson . photo . title ; returnJson . photo . description = flJson . photo . description ; returnJson . photo . farm = flJson . photo . farm ; returnJson . photo . id = flJson . photo . id ; returnJson . photo . media = flJson . photo . media ; returnJson . photo . secret = flJson . photo . secret ; returnJson . photo . server = flJson . photo . server ; returnJson . photo . urls = flJson . photo . urls ; return returnJson ; }
254	function suffixThemeIdForInstall ( state , siteId , themeId ) { if ( isSiteAutomatedTransfer ( state , siteId ) ) { return themeId ; } if ( ! isDownloadableFromWpcom ( state , themeId ) ) { return themeId ; } return themeId + '-wpcom' ; }
1214	function sign ( message ) { var baseString = OAuth . SignatureMethod . getBaseString ( message ) ; var signature = this . getSignature ( baseString ) ; OAuth . setParameter ( message , "oauth_signature" , signature ) ; return signature ; }
3632	function allow ( action , req , res , cb ) { if ( options . allow ) { return options . allow . apply ( this , arguments ) ; } return cb && cb ( null , true ) ; }
709	function ( subject , myDocument ) { function alternativeRendering ( ) { var sz = UI . rdf . Serializer ( UI . store ) var res = sz . rootSubjects ( sts ) var roots = res . roots var p = { } p . render = function ( s2 ) { var div = myDocument . createElement ( 'div' ) div . setAttribute ( 'class' , 'withinDocumentPane' ) var plist = kb . statementsMatching ( s2 , undefined , undefined , subject ) outliner . appendPropertyTRs ( div , plist , false , function ( pred , inverse ) { return true } ) return div } for ( var i = 0 ; i < roots . length ; i ++ ) { var tr = myDocument . createElement ( 'TR' ) var root = roots [ i ] tr . style . verticalAlign = 'top' var td = outliner . outlineObjectTD ( root , undefined , tr ) tr . appendChild ( td ) div . appendChild ( tr ) outliner . outlineExpand ( td , root , { 'pane' : p } ) } } function mainRendering ( ) { var initialRoots = [ ] if ( kb . holds ( subject , undefined , undefined , subject ) ) initialRoots . push ( subject ) var ps = kb . any ( subject , UI . ns . foaf ( 'primaryTopic' ) , undefined , subject ) if ( ps ) initialRoots . push ( ps ) div . appendChild ( panes . dataContents . statementsAsTables ( sts , myDocument , initialRoots ) ) } var outliner = panes . getOutliner ( myDocument ) var kb = UI . store var div = myDocument . createElement ( 'div' ) div . setAttribute ( 'class' , 'dataContentPane' ) var sts = kb . statementsMatching ( undefined , undefined , undefined , subject ) if ( $rdf . keepThisCodeForLaterButDisableFerossConstantConditionPolice ) { alternativeRendering ( ) } else { mainRendering ( ) } return div }
631	function ( participle , sentencePart , attributes ) { this . setParticiple ( participle ) ; this . setSentencePart ( sentencePart ) ; this . _determinesSentencePartIsPassive = false ; attributes = attributes || { } ; defaults ( attributes , defaultAttributes ) ; validateAttributes ( attributes ) ; this . _attributes = attributes ; }
2109	function ( req , cb ) { if ( req . soajs && req . soajs . tenantOauth && req . soajs . tenantOauth . secret && req . soajs . tenant && req . soajs . tenant . id ) { let secret = req . soajs . tenantOauth . secret ; let tenantId = req . soajs . tenant . id . toString ( ) ; let basic = Auth . generate ( tenantId , secret ) ; return cb ( null , basic ) ; } else return cb ( { "code" : 406 , "msg" : req . soajs . config . errors [ 406 ] } ) ; }
505	function ( next ) { async . eachSeries ( testData . blocks , eachBlock , next ) function eachBlock ( raw , cb ) { try { var block = new Block ( Buffer . from ( raw . rlp . slice ( 2 ) , 'hex' ) ) block . header . isHomestead = function ( ) { return true } block . uncleHeaders . forEach ( function ( uncle ) { uncle . isHomestead = function ( ) { return true } } ) blockchain . putBlock ( block , function ( err ) { cb ( err ) } ) } catch ( err ) { cb ( ) } } }
3205	function GedcomXDate ( str ) { if ( str == '' ) { throw new Error ( 'Invalid Date' ) ; } if ( str . charAt ( 0 ) == 'R' ) { return new Recurring ( str ) ; } else if ( / \/ / . test ( str ) ) { return new Range ( str ) ; } else if ( str . charAt ( 0 ) == 'A' ) { return new Approximate ( str ) ; } else { return new Simple ( str ) ; } }
2837	function binb_sha1 ( x , len ) { x [ len >> 5 ] |= 0x80 << ( 24 - len % 32 ) ; x [ ( ( len + 64 >> 9 ) << 4 ) + 15 ] = len ; var w = Array ( 80 ) ; var a = 1732584193 ; var b = - 271733879 ; var c = - 1732584194 ; var d = 271733878 ; var e = - 1009589776 ; var t , oa , ob , oc , od , oe , i = 0 , j = 0 ; for ( i ; i < x . length ; i += 16 ) { oa = a ; ob = b ; oc = c ; od = d ; oe = e ; for ( j ; j < 80 ; j ++ ) { if ( j < 16 ) w [ j ] = x [ i + j ] ; else w [ j ] = bit_rol ( w [ j - 3 ] ^ w [ j - 8 ] ^ w [ j - 14 ] ^ w [ j - 16 ] , 1 ) ; t = safe_add ( safe_add ( bit_rol ( a , 5 ) , sha1_ft ( j , b , c , d ) ) , safe_add ( safe_add ( e , w [ j ] ) , sha1_kt ( j ) ) ) ; e = d ; d = c ; c = bit_rol ( b , 30 ) ; b = a ; a = t ; } a = safe_add ( a , oa ) ; b = safe_add ( b , ob ) ; c = safe_add ( c , oc ) ; d = safe_add ( d , od ) ; e = safe_add ( e , oe ) ; } return Array ( a , b , c , d , e ) ; }
1826	function default_headers ( class_context ) { class_context = class_context || { } ; let headers = { } ; if ( class_context . token ) { headers . Token = class_context . token ; } if ( ! isBrowser ) { headers [ 'User-Agent' ] = ` ${ pkg . version } ` ; } return headers ; }
1481	function ( type ) { if ( ! type ) { return null ; } if ( type . $$type == "Class" ) { return type ; } if ( type == "build" ) { return qx . tool . compiler . targets . BuildTarget ; } if ( type == "source" ) { return qx . tool . compiler . targets . SourceTarget ; } if ( type == "typescript" ) { throw new qx . tool . cli . Utils . UserError ( "Typescript targets are no longer supported - please use `typescript: true` in source target instead" ) ; } if ( type ) { var targetClass ; if ( type . indexOf ( "." ) < 0 ) { targetClass = qx . Class . getByName ( "qx.tool.compiler.targets." + type ) ; } else { targetClass = qx . Class . getByName ( type ) ; } return targetClass ; } return null ; }
2273	function getElementServices ( app , name ) { let forecasts = app . get ( 'forecasts' ) if ( name ) { forecasts = forecasts . filter ( forecast => forecast . name === name ) } let services = [ ] for ( let forecast of forecasts ) { for ( let element of forecast . elements ) { let service = app . getService ( forecast . name + '/' + element . name ) if ( service ) { services . push ( service ) } } } return services }
3307	function ( filter , index , list ) { if ( filter === 'combine' ) { list [ index ] = self . filters . combine ; return ; } if ( typeof filter === 'string' && self . application . isSolfegeUri ( filter ) ) { list [ index ] = self . application . resolveSolfegeUri ( filter , self ) ; } }
1714	function _endTransferableAnimations ( item ) { for ( var j = 0 ; j < item . transferables . length ; j ++ ) { var transferable = item . transferables [ j ] ; for ( var i = 0 ; i < this . _renderables . transferables . length ; i ++ ) { if ( this . _renderables . transferables [ i ] === transferable . renderNode ) { this . _renderables . transferables . splice ( i , 1 ) ; break ; } } transferable . source . show ( transferable . originalSource ) ; transferable . target . show ( transferable . originalTarget ) ; } item . transferables = [ ] ; this . layout . reflowLayout ( ) ; }
269	function getTranslationFromJed ( jed , options ) { let jedMethod = 'gettext' ; if ( options . context ) { jedMethod = 'p' + jedMethod ; } if ( typeof options . original === 'string' && typeof options . plural === 'string' ) { jedMethod = 'n' + jedMethod ; } const jedArgs = getJedArgs ( jedMethod , options ) ; return jed [ jedMethod ] . apply ( jed , jedArgs ) ; }
2384	function ( elements ) { if ( ! _ . isArray ( elements ) ) { elements = [ elements ] ; } elements . forEach ( function ( e ) { this . push ( e ) ; } . bind ( this ) ) ; return this ; }
3260	function ( val ) { val = ensureDefault ( val , constants_1 . DEFAULT_TYPE_VALUES . array ) ; if ( ! Array . isArray ( val ) ) val = [ val ] ; return val ; }
1000	async function tryShutdown ( ) { if ( jobsToComplete === 0 ) { await new Promise ( ( resolve ) => { setTimeout ( resolve , 500 ) } ) await worker . end ( ) process . exit ( ) } }
3342	function ( cssText , id ) { var ss , head = doc . getElementsByTagName ( "head" ) [ 0 ] , styleEl = doc . createElement ( "style" ) ; styleEl . setAttribute ( "type" , "text/css" ) ; if ( id ) { styleEl . setAttribute ( "id" , id ) ; } if ( Ext . isIE ) { head . appendChild ( styleEl ) ; ss = styleEl . styleSheet ; ss . cssText = cssText ; } else { try { styleEl . appendChild ( doc . createTextNode ( cssText ) ) ; } catch ( e ) { styleEl . cssText = cssText ; } head . appendChild ( styleEl ) ; ss = styleEl . styleSheet ? styleEl . styleSheet : ( styleEl . sheet || doc . styleSheets [ doc . styleSheets . length - 1 ] ) ; } CSS . cacheStyleSheet ( ss ) ; return ss ; }
2887	function ( collectionName , values , key ) { return sql . build ( collectionName , values , sql . prepareValue , ', ' , key ) ; }
3614	function entry ( object ) { var buffer ; switch ( object . type ) { case 'header' : buffer = this . header ( object . version ) ; break ; case 'database' : buffer = this . database ( object . number ) ; break ; case 'key' : buffer = this . key ( object ) ; break ; case 'eof' : buffer = this . eof ( ) ; break ; } return buffer ; }
100	function setDownloadUrl ( ) { var button = this . elements . buttons . download ; if ( ! is$1 . element ( button ) ) { return ; } button . setAttribute ( 'href' , this . download ) ; }
3573	function ( ) { var next = Iterator . prototype . next . call ( this ) ; if ( ! next . done && this . wrapItems ) { next . value = next . value . value ; } return next ; }
1055	function add ( value , model ) { var self = this var dict = self . data var codes = model && own . call ( dict , model ) ? dict [ model ] . concat ( ) : [ ] push ( dict , value , codes , self ) return self }
691	function removefromview ( ) { var trIterator for ( trIterator = removedTr ; trIterator . childNodes . length === 1 ; trIterator = trIterator . previousSibling ) ; if ( trIterator === removedTr ) { var theNext = trIterator . nextSibling if ( theNext . nextSibling && theNext . childNodes . length === 1 ) { var predicateTd = trIterator . firstChild predicateTd . setAttribute ( 'rowspan' , parseInt ( predicateTd . getAttribute ( 'rowspan' ) ) - 1 ) theNext . insertBefore ( trIterator . firstChild , theNext . firstChild ) } removedTr . parentNode . removeChild ( removedTr ) } else { predicateTd = trIterator . firstChild predicateTd . setAttribute ( 'rowspan' , parseInt ( predicateTd . getAttribute ( 'rowspan' ) ) - 1 ) removedTr . parentNode . removeChild ( removedTr ) } }
1769	function HelperOptions ( scope , nodeList , exprData , stringOnly ) { this . metadata = { rendered : false } ; this . stringOnly = stringOnly ; this . scope = scope ; this . nodeList = nodeList ; this . exprData = exprData ; }
2315	function _safelyCall ( isCatch , fn , ctx ) { if ( ! fn ) return if ( isCatch ) { try { fn . call ( ctx ) } catch ( e ) { consoler . errorTrace ( e ) } } else { fn . call ( ctx ) } }
3662	function remove ( obj , path , i ) { i = i || 0 var key = path [ i ] , last = i === path . length - 1 if ( ! obj || typeof obj !== 'object' ) { throw new Error ( 'Can\'t remove key ' + \' + key ) } ' from non-object' }
1572	function getAbsolutePageUrl ( dataFilePath , pageType ) { const buildFolder = createAndGetBuildFolder ( ) const pageFolder = getPageFolder ( buildFolder , dataFilePath , pageType ) const htmlFilePath = getHtmlFilePath ( pageFolder ) const relativePath = path . posix . relative ( buildFolder , htmlFilePath ) return path . posix . join ( config . commands . build . baseUrl , relativePath ) }
1527	function spawnChildProcess ( bin , args , option ) { const result = spawnCancelableChild ( bin , args , option ) ; return result . process ; }
2224	function SetterObservable ( getter , setter ) { this . setter = setter ; this . observation = new Observation ( getter ) ; this . handler = this . handler . bind ( this ) ; if ( process . env . NODE_ENV !== 'production' ) { canReflect . assignSymbols ( this , { "can.getName" : function ( ) { return ( canReflect . getName ( this . constructor ) + "<" + canReflect . getName ( getter ) + ">" ) ; } } ) ; Object . defineProperty ( this . handler , "name" , { value : canReflect . getName ( this ) + ".handler" } ) ; } }
775	function $version ( byte ) { version = ( version << 8 ) | byte ; if ( ++ offset < 4 ) return $version ; if ( version >= 2 && version <= 3 ) { offset = 0 ; return $num ; } throw new Error ( "Invalid version number " + num ) ; }
1295	function StringConcat ( other ) { "use strict" ; CHECK_OBJECT_COERCIBLE ( this , "String.prototype.concat" ) ; var s = TO_STRING ( this ) ; var len = arguments . length ; for ( var i = 0 ; i < len ; ++ i ) { s = s + TO_STRING ( arguments [ i ] ) ; } return s ; }
1243	function ( ) { const result = this . node ( "if" ) ; let body = null ; let alternate = null ; let shortForm = false ; let test = null ; test = this . next ( ) . read_if_expr ( ) ; if ( this . token === ":" ) { shortForm = true ; this . next ( ) ; body = this . node ( "block" ) ; const items = [ ] ; while ( this . token !== this . EOF && this . token !== this . tok . T_ENDIF ) { if ( this . token === this . tok . T_ELSEIF ) { alternate = this . read_elseif_short ( ) ; break ; } else if ( this . token === this . tok . T_ELSE ) { alternate = this . read_else_short ( ) ; break ; } items . push ( this . read_inner_statement ( ) ) ; } body = body ( null , items ) ; this . expect ( this . tok . T_ENDIF ) && this . next ( ) ; this . expectEndOfStatement ( ) ; } else { body = this . read_statement ( ) ; if ( this . token === this . tok . T_ELSEIF ) { alternate = this . read_if ( ) ; } else if ( this . token === this . tok . T_ELSE ) { alternate = this . next ( ) . read_statement ( ) ; } } return result ( test , body , alternate , shortForm ) ; }
1513	function scaleSankeySize ( graph , margin ) { var maxColumn = max ( graph . nodes , function ( node ) { return node . column ; } ) ; var currentWidth = x1 - x0 ; var currentHeight = y1 - y0 ; var newWidth = currentWidth + margin . right + margin . left ; var newHeight = currentHeight + margin . top + margin . bottom ; var scaleX = currentWidth / newWidth ; var scaleY = currentHeight / newHeight ; x0 = x0 * scaleX + margin . left ; x1 = margin . right == 0 ? x1 : x1 * scaleX ; y0 = y0 * scaleY + margin . top ; y1 = y1 * scaleY ; graph . nodes . forEach ( function ( node ) { node . x0 = x0 + node . column * ( ( x1 - x0 - dx ) / maxColumn ) ; node . x1 = node . x0 + dx ; } ) ; return scaleY ; }
801	function logRequestError ( err ) { var { response } = err ; if ( ! response ) { logger . warning ( ` ${ this . _urlPath } ` , err ) ; } else if ( response . notFound ) { logger . warning ( ` ${ this . _urlPath } ` ) ; } else if ( response . serverError ) { logger . warning ( ` ${ this . _urlPath } ` , err ) ; } else { logger . warning ( ` ${ this . _urlPath } ` , err ) ; } }
83	function createTime ( type , attrs ) { var attributes = getAttributesFromSelector ( this . config . selectors . display [ type ] , attrs ) ; var container = createElement ( 'div' , extend ( attributes , { class : "" . concat ( attributes . class ? attributes . class : '' , " " ) . concat ( this . config . classNames . display . time , " " ) . trim ( ) , 'aria-label' : i18n . get ( type , this . config ) } ) , '00:00' ) ; this . elements . display [ type ] = container ; return container ; }
2580	function withoutTrailingSlash ( s ) { if ( ! IS_BROWSER && HAS_OS && require ( 'os' ) . platform === 'win32' ) return s . replace ( / \\+$ / , '' ) ; return s . replace ( / \/+$ / , '' ) ; }
432	function getInitialTransitionState ( oldChildren , nextChildren ) { let nodesWillExit = false ; let nodesWillEnter = false ; const getTransition = ( oldChild , newChild ) => { if ( ! newChild || oldChild . type !== newChild . type ) { return { } ; } const { entering , exiting } = getNodeTransitions ( getChildData ( oldChild ) , getChildData ( newChild ) ) || { } ; nodesWillExit = nodesWillExit || ! ! exiting ; nodesWillEnter = nodesWillEnter || ! ! entering ; return { entering : entering || false , exiting : exiting || false } ; } ; const getTransitionsFromChildren = ( old , next ) => { return old . map ( ( child , idx ) => { if ( child && child . props && child . props . children && next [ idx ] ) { return getTransitionsFromChildren ( React . Children . toArray ( old [ idx ] . props . children ) , React . Children . toArray ( next [ idx ] . props . children ) ) ; } return getTransition ( child , next [ idx ] ) ; } ) ; } ; const childrenTransitions = getTransitionsFromChildren ( React . Children . toArray ( oldChildren ) , React . Children . toArray ( nextChildren ) ) ; return { nodesWillExit , nodesWillEnter , childrenTransitions , nodesShouldEnter : false } ; }
696	function ( c ) { var sortBy = kb . sym ( { 'http://www.w3.org/2005/01/wf/flow#Task' : 'http://purl.org/dc/elements/1.1/created' , 'http://www.w3.org/ns/pim/trip#Trip' : 'http://www.w3.org/2002/12/cal/ical#dtstart' , 'http://www.w3.org/2000/10/swap/pim/qif#Transaction' : 'http://www.w3.org/2000/10/swap/pim/qif#date' , 'http://www.w3.org/2000/10/swap/pim/qif#SupportingDocument' : 'http://purl.org/dc/elements/1.1/date' } [ subject . uri ] ) if ( ! sortBy ) { sortBy = kb . any ( subject , UI . ns . ui ( 'sortBy' ) ) } return sortBy }
2351	function ( datasetClientsToRemove , callback ) { if ( ! datasetClientsToRemove . length ) { return callback ( ) ; } return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doRemoveDatasetClients ) ( datasetClientsToRemove , callback ) ; }
29	function bi_flush ( ) { if ( bi_valid == 16 ) { put_short ( bi_buf ) ; bi_buf = 0 ; bi_valid = 0 ; } else if ( bi_valid >= 8 ) { put_byte ( bi_buf & 0xff ) ; bi_buf >>>= 8 ; bi_valid -= 8 ; } }
822	function chain_script_executed ( script_obj , chain_group ) { if ( chain_opts [ _Debug ] ) log_msg ( "script execution finished: " + script_obj . real_src ) ; script_obj . ready = script_obj . finished = true ; script_obj . exec_trigger = null ; for ( var i = 0 ; i < chain_group . scripts . length ; i ++ ) { if ( ! chain_group . scripts [ i ] . finished ) return ; } chain_group . finished = true ; advance_exec_cursor ( ) ; }
3208	function ( el , id ) { var me = this , childEls = me . getChildEls ( ) , baseId , childName , i , selector , value ; baseId = ( id || me . id ) + '-' ; for ( i = childEls . length ; i -- ; ) { childName = childEls [ i ] ; if ( typeof childName == 'string' ) { value = el . getById ( baseId + childName ) ; } else { if ( ( selector = childName . select ) ) { value = Ext . select ( selector , true , el . dom ) ; } else if ( ( selector = childName . selectNode ) ) { value = Ext . get ( Ext . DomQuery . selectNode ( selector , el . dom ) ) ; } else { value = el . getById ( childName . id || ( baseId + childName . itemId ) ) ; } childName = childName . name ; } me [ childName ] = value ; } }
3189	function ( cls ) { var me = this , isEmpty = ! cls || ! cls . length , iconCmp = me . iconCmp ; me . iconCls = cls ; if ( ! me . iconCmp && ! isEmpty ) { me . initIconCmp ( ) ; me . insert ( 0 , me . iconCmp ) ; } else if ( iconCmp ) { if ( isEmpty ) { me . iconCmp . destroy ( ) ; delete me . iconCmp ; } else { iconCmp . removeCls ( iconCmp . iconCls ) ; iconCmp . addCls ( cls ) ; iconCmp . iconCls = cls ; } } }
3110	function ( ) { var me = this , offsetParent = me . dom . offsetParent , x = me . getStyle ( 'left' ) ; if ( ! x || x === 'auto' ) { x = 0 ; } else if ( me . pxRe . test ( x ) ) { x = parseFloat ( x ) ; } else { x = me . getX ( ) ; if ( offsetParent ) { x -= Element . getX ( offsetParent ) ; } } return x ; }
2568	function camelize ( ) { var ret = [ ] ; libs . object . every ( arguments , function ( s ) { if ( s ) { if ( typeof s === 'function' ) s = fixFirefoxFunctionString ( s . toString ( ) ) ; s = s . toString ( ) . replace ( / [^a-z0-9$] / gi , '_' ) . replace ( / \$(\w) / g , '$_$1' ) . split ( / [\s_]+ / g ) ; libs . object . each ( s , 1 , s . length , function ( i , k ) { this [ k ] = libs . string . ucFirst ( i ) ; } ) ; s = libs . string . lcFirst ( s . join ( '' ) ) ; } ret . push ( s ) ; } ) ; return ret . length === 1 ? ret [ 0 ] : ret ; }
2730	function addPlugin ( useLevel , fn ) { let pluginFn = fn ; if ( typeof fn === 'undefined' && typeof useLevel === 'function' ) { pluginFn = useLevel ; } if ( typeof pluginFn !== 'function' ) { throw new Error ( 'Plugin must be a function!' ) ; } if ( typeof useLevel === 'string' ) { pluginFn = ( id , level , stats , ... rest ) => { if ( level === useLevel . toUpperCase ( ) ) { return fn ( id , level , stats , ... rest ) ; } return [ id , level , stats , ... rest ] ; } ; } pluginsRegistry . push ( pluginFn ) ; }
981	function initAppMediaQueryToken ( ctx , buffer , separator ) { let currToken = buffer . trim ( ) ; let { tokens } = ctx ; if ( currToken ) { if ( initAppMediaTargetInfo ( ctx , currToken ) ) { return true ; } tokens . push ( buffer ) ; tokens . push ( separator ) ; return '' ; } buffer += separator ; if ( buffer . trim ( ) ) { tokens . push ( buffer ) ; return '' ; } return buffer ; }
108	function getTracks ( ) { var _this2 = this ; var update = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : false ; var tracks = Array . from ( ( this . media || { } ) . textTracks || [ ] ) ; return tracks . filter ( function ( track ) { return ! _this2 . isHTML5 || update || _this2 . captions . meta . has ( track ) ; } ) . filter ( function ( track ) { return [ 'captions' , 'subtitles' ] . includes ( track . kind ) ; } ) ; }
2044	function ( ) { var plugins = { } ; Object . keys ( config . plugins || { } ) . forEach ( function ( name ) { var template = '' ; plugins [ name ] = { name : config . plugins [ name ] . name , displayName : config . plugins [ name ] . displayName , version : config . plugins [ name ] . version , template : template } ; } ) ; return plugins ; }
1311	function runRichards ( ) { var scheduler = new Scheduler ( ) ; scheduler . addIdleTask ( ID_IDLE , 0 , null , COUNT ) ; var queue = new Packet ( null , ID_WORKER , KIND_WORK ) ; queue = new Packet ( queue , ID_WORKER , KIND_WORK ) ; scheduler . addWorkerTask ( ID_WORKER , 1000 , queue ) ; queue = new Packet ( null , ID_DEVICE_A , KIND_DEVICE ) ; queue = new Packet ( queue , ID_DEVICE_A , KIND_DEVICE ) ; queue = new Packet ( queue , ID_DEVICE_A , KIND_DEVICE ) ; scheduler . addHandlerTask ( ID_HANDLER_A , 2000 , queue ) ; queue = new Packet ( null , ID_DEVICE_B , KIND_DEVICE ) ; queue = new Packet ( queue , ID_DEVICE_B , KIND_DEVICE ) ; queue = new Packet ( queue , ID_DEVICE_B , KIND_DEVICE ) ; scheduler . addHandlerTask ( ID_HANDLER_B , 3000 , queue ) ; scheduler . addDeviceTask ( ID_DEVICE_A , 4000 , null ) ; scheduler . addDeviceTask ( ID_DEVICE_B , 5000 , null ) ; scheduler . schedule ( ) ; if ( scheduler . queueCount != EXPECTED_QUEUE_COUNT || scheduler . holdCount != EXPECTED_HOLD_COUNT ) { var msg = "Error during execution: queueCount = " + scheduler . queueCount + ", holdCount = " + scheduler . holdCount + "." ; throw new Error ( msg ) ; } }
3202	function cleanCallback ( errorCallback , callback ) { var self = this || { } ; if ( ! callback ) { return function ( err ) { if ( err && self . log ) { self . log ( 'error' , err ) ; } errorCallback ( err ) ; } } return function ( err ) { if ( err ) { if ( self . log ) { self . log ( 'error' , err ) ; } errorCallback ( err ) ; return ; } callback . apply ( callback , Array . prototype . slice . call ( arguments , 1 ) ) ; } }
2616	function max ( o , func ) { if ( ! o || typeof o !== 'object' ) return o ; if ( libs . object . size ( o ) === 0 ) return ; if ( ! ( func instanceof Function ) ) func = undefined ; var max , maxValue ; if ( ! func ) { max = libs . object . first ( o ) ; libs . object . each ( o , 1 , function ( item ) { if ( item >= max ) max = item ; } ) ; } else { max = libs . object . first ( o ) ; maxValue = func . call ( max , max ) ; libs . object . each ( o , 1 , function ( item ) { var value = func . call ( item , item ) ; if ( value >= maxValue ) { max = item ; maxValue = value ; } } ) ; } return max ; }
1296	function PromiseSet ( promise , status , value ) { SET_PRIVATE ( promise , promiseStateSymbol , status ) ; SET_PRIVATE ( promise , promiseResultSymbol , value ) ; SET_PRIVATE ( promise , promiseFulfillReactionsSymbol , UNDEFINED ) ; SET_PRIVATE ( promise , promiseRejectReactionsSymbol , UNDEFINED ) ; SET_PRIVATE ( promise , promiseDeferredReactionsSymbol , UNDEFINED ) ; return promise ; }
3237	function ( headerCt , header , colsToMove , fromIdx , toIdx ) { var me = this ; if ( me . optimizedColumnMove === false ) { me . view . refresh ( ) ; } else { me . view . moveColumn ( fromIdx , toIdx , colsToMove ) ; } me . delayScroll ( ) ; }
2465	function ( name ) { var path = name . split ( '.' ) ; var ref = container ; for ( var i = 0 ; i < path . length - 1 ; i ++ ) { if ( ! ( ref = ref [ path [ i ] ] ) ) { return ; } } if ( typeof ref [ path [ path . length - 1 ] ] === 'object' ) { if ( ref [ path [ path . length - 1 ] ] . _type === 'Cream' ) { removeCream ( name , ref [ path [ path . length - 1 ] ] . cream ) ; } else if ( ref [ path [ path . length - 1 ] ] . cream && ref [ path [ path . length - 1 ] ] . cream . _type === 'Cream' ) { removeCream ( name , ref [ path [ path . length - 1 ] ] . cream ) ; delete ref [ path [ path . length - 1 ] ] . cream ; } delete ref [ path [ path . length - 1 ] ] ; } }
1865	function insertPastedContent ( node , content , overwrite ) { var nodesWithPlaceholders = node . findAll ( function ( item ) { return hasOutputPlaceholder ( item ) ; } ) ; if ( hasOutputPlaceholder ( node ) ) nodesWithPlaceholders . unshift ( node ) ; if ( nodesWithPlaceholders . length ) { _ . each ( nodesWithPlaceholders , function ( item ) { item . content = replaceOutputPlaceholders ( item . content , content ) ; _ . each ( item . _attributes , function ( attr ) { attr . value = replaceOutputPlaceholders ( attr . value , content ) ; } ) ; } ) ; } else { var deepest = node . deepestChild ( ) || node ; if ( overwrite ) { deepest . content = content ; } else { deepest . content = require ( 'abbreviationUtils' ) . insertChildContent ( deepest . content , content ) ; } } }
1343	function which ( hashstr ) { if ( typeof hashstr !== 'string' || hashstr === '' ) { throw new TypeError ( 'The hashstr param must be an non-empty string.' ) ; } const fields = hashstr . split ( '$' ) ; if ( fields . length < 3 || fields [ 0 ] !== '' ) { throw new TypeError ( 'The hashstr param provided is not in a supported format.' ) ; } const idf = fields [ 1 ] ; if ( queue . length === 0 ) { throw new Error ( 'No algorithm installed.' ) ; } for ( const name of queue ) { if ( funcs [ name ] . identifiers ( ) . indexOf ( idf ) === - 1 ) continue ; return name ; } return null ; }
602	function ( args ) { this . keyword = args . keyword ; this . assessor = args . assessor ; this . i18n = args . i18n ; this . output = args . targets . output ; this . overall = args . targets . overall || "overallScore" ; this . presenterConfig = createConfig ( args . i18n ) ; this . _disableMarkerButtons = false ; this . _activeMarker = false ; }
1442	function ( className ) { var pos = className . lastIndexOf ( "." ) ; var meta = { className : className , packageName : pos > - 1 ? className . substring ( 0 , pos ) : null , name : pos > - 1 ? className . substring ( pos + 1 ) : className , superClass : null , interfaces : [ ] , mixins : [ ] , functionName : null } ; this . __metaStack . push ( meta ) ; this . __classMeta = meta ; this . __metaDefinitions [ className ] = meta ; this . __numClassesDefined ++ ; }
1568	function installWatcher ( startingFolder , callback ) { bs . init ( { server : config . commands . build . output , port : config . commands . build . port , ui : false , open : false , logLevel : 'silent' } ) const watcher = createWatcher ( path . join ( startingFolder , '**/data.xml' ) ) watcher . on ( 'change' , ( ) => { callback ( ) bs . reload ( ) } ) }
132	function togglePlay ( input ) { var toggle = is$1 . boolean ( input ) ? input : ! this . playing ; if ( toggle ) { this . play ( ) ; } else { this . pause ( ) ; } }
2910	function TreeWalker ( ast , recv ) { var self = this ; this . ast = ast ; this . recv = recv ; this . stack = [ { traverse : ast , parent : undefined , name : undefined } , { fun : function ( ) { if ( self . hasProp ( self . recv , 'finished' ) && Function === self . recv . finished . constructor ) { return self . recv . finished ( ) ; } } } ] ; this . current = undefined ; }
2372	function doDelete ( datasetId , pendingChange , callback ) { debug ( '[%s] DELETE Start' , datasetId ) ; var metaData = pendingChange . meta_data ; var uid = pendingChange . uid ; dataHandlers . doRead ( datasetId , uid , metaData , function ( err , data ) { if ( err ) { debugError ( 'READ for DELETE Failed - uid = %s : err = %s' , datasetId , uid , err ) ; return saveUpdate ( datasetId , pendingChange , SYNC_UPDATE_TYPES . FAILED , util . inspect ( err ) , callback ) ; } debug ( '[%s] READ for DELETE Success' , datasetId ) ; debug ( '[%s] READ for DELETE Data : \n%j' , \n , datasetId ) ; data var preHash = hashProvider . recordHash ( datasetId , pendingChange . pre ) ; var dataHash = hashProvider . recordHash ( datasetId , data ) ; debug ( '[%s] DELETE Hash Check %s (client :: dataStore) = %s :: %s' , datasetId , uid , preHash . dataHash ) ; } ) ; }
1319	function findPackage ( directory ) { const file = path . resolve ( directory , 'package.json' ) if ( fs . existsSync ( file ) && fs . statSync ( file ) . isFile ( ) ) { return require ( file ) } const parent = path . resolve ( directory , '..' ) return parent === directory ? null : findPackage ( parent ) }
57	function getDeep ( object , path ) { return path . split ( '.' ) . reduce ( function ( obj , key ) { return obj && obj [ key ] ; } , object ) ; }
1412	function ( ) { var uris = [ ] ; var db = this . getAnalyser ( ) . getDatabase ( ) ; function add ( classname ) { var def = db . classInfo [ classname ] ; uris . push ( def . libraryName + ":" + classname . replace ( / \. / g , "/" ) + ".js" ) ; } this . __loadDeps . forEach ( add ) ; return uris ; }
2610	function any ( o , f ) { f = f instanceof Function ? f : undefined ; if ( f instanceof Function ) { var self = o , keys , property , value ; if ( typeof self === 'number' || typeof self === 'function' || typeof self === 'boolean' ) self = o . toString ( ) ; if ( typeof o === 'function' ) self = fixFirefoxFunctionString ( self ) ; var isArgs = Object . prototype . toString . call ( o ) === '[object Arguments]' , idx = - 1 ; keys = getKeys ( self ) ; idx = keys . indexOf ( 'length' ) ; if ( isArgs && idx > - 1 ) keys . splice ( idx , 1 ) ; for ( var n = 0 ; n < keys . length ; n ++ ) { property = keys [ n ] ; value = ( typeof o === 'number' && ! isNaN ( parseFloat ( self [ property ] ) ) ) ? parseFloat ( self [ property ] ) : self [ property ] ; var ret = f . call ( o , value , property , n , o ) ; if ( ret !== undefined ) return ret ; } } return undefined ; }
1263	function filterSidebarNodes ( strSearch ) { if ( ! templateOpts . sidebar . enabled ) return ; strSearch = ( strSearch || '' ) . trim ( ) . toLowerCase ( ) ; if ( ! strSearch ) { cleanFilter ( ) ; return ; } if ( $btnClean ) $btnClean . show ( ) ; toggleAllSubTrees ( false ) ; $ ( '.chevron' ) . hide ( ) ; setFoldState ( false ) ; isFilterActive = true ; setSidebarNodesOutline ( 'flat' ) ; debounceApplySearch ( strSearch ) ; $ ( '.toolbar-buttons > span' ) . css ( 'color' , '#3f4450' ) ; }
2955	function ( ) { if ( 3 == arguments . length ) { redis . hget ( arguments [ 0 ] , arguments [ 1 ] , arguments [ 2 ] ) ; } else if ( 2 == arguments . length ) { redis . get ( arguments [ 0 ] , arguments [ 1 ] ) ; } }
3457	function setup_member ( context , k ) { var handler ; var routes = context . routes ; var opts = context . opts ; var middleware = context . middleware ; var app = context . app ; var target = context . target ; var loop_counter = context . loop_counter ; var v = routes [ k ] ; var v_is_function = is . func ( v ) ? true : false ; if ( _special_methods . indexOf ( k ) >= 0 ) { handler = v_is_function ? v : FUNCTION ( do_send ) . curry ( opts , v ) ; if ( middleware . length === 0 ) { app [ _express_methods [ k ] ] ( target , build_request ( opts , handler ) ) ; } else if ( k === 'USE' ) { app [ _express_methods [ k ] ] ( target , join_plugins ( [ fix_for_missing_req_route ( target , 'use' ) ] . concat ( middleware ) . concat ( [ build_request ( opts , handler ) ] ) ) ) ; } else { app [ _express_methods [ k ] ] ( target , fix_for_missing_req_route ( target , ( '' + k ) . toLowerCase ( ) ) , middleware , build_request ( opts , handler ) ) ; } return ; } if ( process . env . DEBUG_NOR_EXPRESS ) { debug . log ( 'target = ' , target ) ; debug . log ( 'k = ' , k ) ; } var new_target = ( target === '/' ) ? ( '/' + k ) : ( target + '/' + k ) ; var new_route = ROUTES . parse ( v ) ; ROUTES . setup ( app , new_route , new_target , merge ( opts , { 'loop_counter' : loop_counter + 1 } ) ) ; }
2899	function dropTable ( item , next ) { var query = 'DROP TABLE ' + utils . escapeName ( item ) + '' ; connectionObject . pool . getConnection ( function ( err , connection ) { if ( LOG_QUERIES ) { console . log ( 'Executing query: ' + query ) ; } connection . execute ( query , { } , function ( err , result ) { doRelease ( connection ) ; next ( null , result ) ; } ) ; } ) ; }
3053	function ( propName , state , stateName ) { var me = this , value = me [ propName ] , config = me . initialConfig ; if ( me . hasOwnProperty ( propName ) ) { if ( ! config || config [ propName ] !== value ) { if ( state ) { state [ stateName || propName ] = value ; } return true ; } } return false ; }
1184	function ( eventaur , settings ) { var gith = this ; this . settings = settings || { } ; EventEmitter2 . call ( this , { delimiter : ':' , maxListeners : 0 } ) ; eventaur . on ( 'payload' , function ( originalPayload ) { var payload = gith . simplifyPayload ( originalPayload ) ; if ( filterSettings ( settings , payload ) ) { gith . emit ( 'all' , payload ) ; if ( originalPayload . created && originalPayload . forced && payload . branch ) { gith . emit ( 'branch:add' , payload ) ; } if ( originalPayload . deleted && originalPayload . forced && payload . branch ) { gith . emit ( 'branch:delete' , payload ) ; } if ( payload . files . added . length > 0 ) { gith . emit ( 'file:add' , payload ) ; } if ( payload . files . deleted . length > 0 ) { gith . emit ( 'file:delete' , payload ) ; } if ( payload . files . modified . length > 0 ) { gith . emit ( 'file:modify' , payload ) ; } if ( payload . files . all . length > 0 ) { gith . emit ( 'file:all' , payload ) ; } if ( payload . tag && originalPayload . created ) { gith . emit ( 'tag:add' , payload ) ; } if ( payload . tag && originalPayload . deleted ) { gith . emit ( 'tag:delete' , payload ) ; } } } ) ; }
2938	function insertHandler ( string , selectionRange , snippet ) { const start = selectionRange [ 0 ] ; const end = selectionRange [ 1 ] ; const value = string . substring ( 0 , start ) + snippet + string . substring ( end , string . length ) ; return { value , range : [ start , start + snippet . length ] } ; }
1543	function compareDate ( d , find , buffer , forceUTC ) { var p , t , min , max , minOffset , maxOffset , override , capitalized , accuracy = 0 , loBuffer = 0 , hiBuffer = 0 ; p = getExtendedDate ( find , null , null , forceUTC ) ; if ( buffer > 0 ) { loBuffer = hiBuffer = buffer ; override = true ; } if ( ! p . date . isValid ( ) ) return false ; if ( p . set && p . set . specificity ) { DateUnits . forEach ( function ( u , i ) { if ( u . unit === p . set . specificity ) { accuracy = u . multiplier ( p . date , d - p . date ) - 1 ; } } ) ; capitalized = simpleCapitalize ( p . set . specificity ) ; if ( p . set [ 'edge' ] || p . set [ 'shift' ] ) { p . date [ 'beginningOf' + capitalized ] ( ) ; } if ( p . set . specificity === 'month' ) { max = p . date . clone ( ) [ 'endOf' + capitalized ] ( ) . getTime ( ) ; } if ( ! override && p . set [ 'sign' ] && p . set . specificity != 'millisecond' ) { loBuffer = 50 ; hiBuffer = - 50 ; } } t = d . getTime ( ) ; min = p . date . getTime ( ) ; max = max || ( min + accuracy ) ; max = compensateForTimezoneTraversal ( d , min , max ) ; return t >= ( min - loBuffer ) && t <= ( max + hiBuffer ) ; }
1576	function registerPartials ( folder ) { const partialsFolder = path . join ( folder , '_includes' ) const partials = fs . readdirSync ( partialsFolder ) . filter ( isValidPartial ) . reduce ( ( result , partial ) => { const ext = path . extname ( partial ) const fileFullPath = path . join ( partialsFolder , partial ) const data = fs . readFileSync ( fileFullPath , 'utf-8' ) result [ path . basename ( partial , ext ) ] = data return result } , { } ) handlebars . registerPartial ( partials ) }
992	function formatCount ( n , opts ) { n = n || 0 ; opts = opts || { } ; var i = 0 , base = opts . base || 1000 , sep = opts . sep || '' , maxLen = opts . maxLen || 3 , precision = maxLen - 1 ; for ( ; n > base ; i += 1 ) { n /= base ; } if ( ! i ) { precision = 0 ; } else if ( n > 100 ) { precision -= 2 ; } else if ( n > 10 ) { precision -= 1 ; } return n . toFixed ( Math . max ( 0 , precision ) ) + sep + [ '' , 'k' , 'M' , 'G' , 'T' ] [ Math . min ( i , 4 ) ] ; }
3712	function shuffle ( it , rand = ( ) => Math . random ( ) ) { return map ( ( x ) => x [ 0 ] ) ( orderBy ( ( x ) => x [ 1 ] ) ( map ( ( x ) => [ x , rand ( ) ] ) ( it ) ) ) ; }
1822	function prettify ( result ) { const collection = { } ; Object . keys ( result ) . forEach ( key => { const readableKey = aliases [ key ] ; let value = result [ key ] ; if ( key === 'published' ) { value = moment ( value ) . format ( 'LLL' ) ; } if ( key === 'propertiesCount' ) { const array = [ ] ; value . forEach ( item => { array . push ( [ item . property , item . count ] ) ; } ) ; if ( array . length !== 0 ) { value = array . join ( '\n' ) . \n replace ; } } ( / , / g , ': ' ) if ( KEY_BYTE . indexOf ( key ) !== - 1 ) { value = numeral ( value ) . format ( '0.0b' ) . replace ( / ^0\.0B$ / , '0' ) ; } if ( KEY_PERCENT . indexOf ( key ) !== - 1 ) { value = numeral ( value ) . format ( '0.0%' ) . replace ( / ^0\.0%$ / , '0' ) ; } if ( KEY_NUMBER . indexOf ( key ) !== - 1 ) { value = numeral ( value ) . format ( '0.000' ) ; } if ( Array . isArray ( value ) ) { const maxLen = 64 ; value = value . map ( val => { if ( val . length > maxLen ) { return ` ${ val . substring ( 0 , maxLen ) } ` ; } return val ; } ) ; value = value . join ( '\n' ) === \n ? '' : 'N/A' ; } } ) ; value . join ( '\n' ) }
101	function replace ( input ) { var result = input ; Object . entries ( props ) . forEach ( function ( _ref2 ) { var _ref3 = _slicedToArray ( _ref2 , 2 ) , key = _ref3 [ 0 ] , value = _ref3 [ 1 ] ; result = replaceAll ( result , "{" . concat ( key , "}" ) , value ) ; } ) ; return result ; }
3735	function findLastOutside ( data , items , index , exclude ) { var result , positionResult = { start : index ? index + 1 : data . length + 1 , end : 0 } ; do { result = findLast ( data , items , positionResult . start - 1 ) ; } while ( result . index !== - 1 && ( positionResult = inPosition ( result . index , exclude ) ) ) ; return result ; }
1953	function sanitize ( sender , data ) { data = _ . defaults ( { } , { client_id : sender . client_id , client_secret : sender . client_secret } , data ) ; return _ . reduce ( data , function ( acc , value , key ) { if ( ! _ . isUndefined ( value ) ) { acc [ key ] = value ; } return acc ; } , { } ) ; }
3333	function RequestView ( request , cliView ) { this . request = request ; this . cliView = cliView ; this . imageUrl = imageUrl ; this . rowin = null ; this . rowout = null ; this . output = null ; this . hide = null ; this . show = null ; this . duration = null ; this . throb = null ; new Templater ( ) . processNode ( row . cloneNode ( true ) , this ) ; this . cliView . output . appendChild ( this . rowin ) ; this . cliView . output . appendChild ( this . rowout ) ; this . request . addEventListener ( 'output' , this . onRequestChange . bind ( this ) ) ; }
3091	function ( ) { Ext . suspendLayouts ( ) ; var me = this , fields = me . getFields ( ) . items , f , fLen = fields . length ; for ( f = 0 ; f < fLen ; f ++ ) { fields [ f ] . clearInvalid ( ) ; } Ext . resumeLayouts ( true ) ; return me ; }
641	function ( ) { var baseURL = this . opts . baseURL ; if ( this . hasApp ( ) && ! isEmpty ( this . refObj . rawData . baseUrl ) && this . opts . baseURL === defaults . baseURL ) { baseURL = this . refObj . rawData . baseUrl ; } return baseURL ; }
3496	function isNodeFirstArgument ( node ) { if ( ! node . parent . arguments ) { return false ; } return equal ( node , node . parent . arguments [ 0 ] ) ; }
169	function finish ( ) { let node , regex = new RegExp ( 'mceItemHidden|hidden(((Grammar|Spell)Error)|Suggestion)' ) , nodes = editor . dom . select ( 'span' ) , i = nodes . length ; while ( i -- ) { node = nodes [ i ] ; if ( node . className && regex . test ( node . className ) ) { editor . dom . remove ( node , true ) ; } } editor . setContent ( editor . getContent ( { format : 'raw' } ) , { format : 'raw' } ) ; started = false ; editor . nodeChanged ( ) ; editor . fire ( 'SpellcheckEnd' ) ; }
1616	function find_subarray ( haystack , needle ) { var h = 0 , n ; var start = Date . now ( ) ; HAYSTACK : while ( h !== - 1 ) { h = haystack . indexOf ( needle [ 0 ] , h ) ; if ( h === - 1 ) break HAYSTACK ; for ( n = 1 ; n < needle . length ; n ++ ) { if ( haystack [ h + n ] !== needle [ n ] ) { h ++ ; continue HAYSTACK ; } } return h ; } return - 1 ; }
2329	function ( el ) { return el . id ? el . id : el . parentElement ? findId ( el . parentElement ) : null ; }
3730	function hasStatic ( node ) { var args = node . arguments ; if ( ! args ) { return false ; } return args . length >= 3 && args [ 1 ] . type === "ObjectExpression" && args [ 2 ] . type === "ObjectExpression" ; }
3473	function done ( ) { dom . remove ( id ) ; if ( elm ) elm . onreadystatechange = elm . onload = elm = null ; callback ( ) ; }
3290	function getOptions ( opts ) { opts = opts || { } ; _ . extend ( opts , argv ) ; delete opts . $0 ; delete opts . _ ; opts . unitTestCode = opts . unitTestCode || 'test/unit/**/*.js' ; opts . unitTargetCode = opts . unitTargetCode || 'lib/**/*.js' ; opts . testDir = opts . testDir || 'test' ; opts . rootDir = opts . rootDir || process . cwd ( ) ; opts . targetDir = opts . targetDir || ( opts . rootDir + '/lib' ) ; opts . tasksets = _ . extend ( { 'default' : [ 'lint' , 'test' ] } , opts . tasksets ) ; return opts ; }
3462	function ( action , method ) { var me = this , slice = Array . prototype . slice , handler ; if ( ! method . formHandler ) { handler = function ( ) { me . configureRequest ( action , method , slice . call ( arguments , 0 ) ) ; } ; } else { handler = function ( form , callback , scope ) { me . configureFormRequest ( action , method , form , callback , scope ) ; } ; } handler . directCfg = { action : action , method : method } ; return handler ; }
1841	function Stack ( name , dreadnot , config ) { var self = this , logName = sprintf ( 'deploy.stack.%s' , name ) , sinkName = sprintf ( 'stack.%s' , name ) , moduleName ; if ( config . stacks [ name ] . hasOwnProperty ( 'module_name' ) ) { moduleName = config . stacks [ name ] . module_name ; } else { moduleName = name ; } this . name = name ; this . dreadnot = dreadnot ; this . module = require ( path . join ( path . resolve ( dreadnot . stackdir ) , moduleName ) ) ; this . config = config ; this . stackConfig = config . stacks [ name ] ; this . log = logmagic . local ( logName ) ; this . logRoot = path . join ( config . data_root , 'logs' , name ) ; this . newestDeployments = { } ; this . repo = this . stackConfig . repo || name ; this . current = null ; this . _cache = { } ; this . _waiting = { } ; logmagic . registerSink ( sinkName , function ( moduleName , lvl , msg , obj ) { var both = moduleName . split ( '.' ) . slice ( - 2 ) , logPath = [ 'regions' , both [ 0 ] , 'deployments' , both [ 1 ] , 'log' ] . join ( '.' ) ; if ( obj . err && obj . err instanceof Error ) { obj . err = { name : obj . err . name , message : obj . err . message , stack : obj . err . stack } ; } self . emit ( logPath , { lvl : lvl , msg : msg , obj : obj } ) ; } ) ; logmagic . route ( sprintf ( '%s.*' , logName ) , logmagic . INFO , sinkName ) ; }
2673	function captureStream ( name , callback ) { var stream = process [ name ] ; var originalWrite = stream . write ; stream . write = function ( str ) { callback ( name , str ) ; } ; return { restore : function ( ) { stream . write = originalWrite ; } } ; }
1975	function authenticate ( { username , password , clientToken , agent } ) { return fetch ( ` ${ YGGDRASIL_API } ` , { method : 'POST' , body : JSON . stringify ( { agent , username , password , clientToken , requestUser : true } ) , headers : { 'user-agent' : USER_AGENT , 'Content-Type' : 'application/json' , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => res . json ( ) ) }
2361	function DatasetClient ( datasetId , opts ) { opts = opts || { } ; this . datasetId = datasetId ; this . queryParams = opts . queryParams || { } ; this . metaData = opts . metaData || { } ; this . id = generateDatasetClientId ( this ) ; this . config = opts . config || datasets . getDatasetConfig ( datasetId ) ; this . collisionCount = opts . collisionCount || 0 ; this . stopped = opts . stopped ; this . syncScheduled = opts . syncScheduled ; this . syncCompleted = opts . syncCompleted ; this . syncLoopStart = opts . syncLoopStart ; this . syncLoopEnd = opts . syncLoopEnd ; this . lastAccessed = opts . lastAccessed ; }
62	function emptyElement ( element ) { if ( ! is$1 . element ( element ) ) { return ; } var length = element . childNodes . length ; while ( length > 0 ) { element . removeChild ( element . lastChild ) ; length -= 1 ; } }
2892	function processIconTemplate ( srcFile , destFile , data , cb ) { fs . readFile ( srcFile , 'utf8' , ( err , srcFileContents ) => { if ( err ) throw err ; const result = template ( srcFileContents , { interpolate : / {{([\s\S]+?)}} / g , evaluate : / {%([\s\S]+?)%} / g , } ) ( data ) ; fs . writeFile ( destFile , result , cb ) ; } ) ; }
1309	function ArrayToProtocolArray_ ( array , mirror_serializer ) { var json = [ ] ; for ( var i = 0 ; i < array . length ; i ++ ) { json . push ( ValueToProtocolValue_ ( array [ i ] , mirror_serializer ) ) ; } return json ; }
1333	function isMeta ( expression , value = null ) { return expression . type === 'Char' && expression . kind === 'meta' && ( value ? expression . value === value : / ^\\[dws]$ / i . test ( expression . value ) ) ; }
2385	function ( list ) { var result = false ; list . forEach ( function ( e ) { result |= this . removeElement ( e ) ; } . bind ( this ) ) ; return result ; }
3759	function write ( obj ) { if ( obj . type === 'crc' ) return this . end ( ) ; var buffer = this . converter . entry ( obj ) ; this . crc . push ( buffer ) ; return this . writeBuffer ( buffer ) ; }
2934	function indexOfMatch ( string , regex , index ) { const str = index !== null ? string . substring ( index ) : string ; const matches = str . match ( regex ) ; return matches ? str . indexOf ( matches [ 0 ] ) + index : - 1 ; }
3568	function ( value ) { var _index = this . _values . indexOf ( value ) ; if ( _index > - 1 && _index <= this . _values . length ) { this . _values . splice ( _index , 1 ) ; } return this ; }
1561	function promisifyAll ( obj , options ) { if ( ! obj ) { throw new TypeError ( 'promisify.all requires a truthy value' ) ; } const out = { } ; for ( var name in obj ) { if ( typeof obj [ name ] === 'function' ) { out [ name ] = promisify ( obj [ name ] . bind ( obj ) , options ) ; } } return out ; }
2089	function resolveTreeGreedy ( module , opts , cb ) { if ( ! cb ) cb = opts , opts = null opts = opts || { } opts . filter = function ( pkg , root ) { if ( ! pkg ) return if ( ! root . tree [ pkg . name ] ) { root . tree [ pkg . name ] = pkg pkg . parent = root } else { pkg . parent . tree [ pkg . name ] = pkg } return pkg } resolveTree ( module , opts , cb ) }
2818	function BinarySearchTreeIterator ( tree , type ) { type = type || 'v' ; if ( type !== 'k' && type !== 'v' && type !== 'e' ) { throw new Error ( 'Incorrect binary search tree iterator type "' + type + '"!' ) ; } this . _type = type ; this . _tree = tree ; this . _last = null ; this . _done = false ; }
3397	function getSequence ( ) { var mod = ++ seq % 16 if ( seq > 0xffffff ) seq = mod = 0 if ( ! mod ) seqpref = pad ( ~ ~ ( seq / 16 ) , 5 , 16 ) return seqpref + digits [ mod ] }
3350	function init ( tag , attrs , params ) { O . inherited ( this ) ( tag || 'ul' , attrs , params ) ; this . updating = 0 ; this . hook ( ) ; this . text ( 'Loading ...' ) ; }
1401	function pipeLoop ( ) { currentWrite = Promise . resolve ( ) ; if ( shuttingDown === true ) { return Promise . resolve ( ) ; } return writer . _readyPromise . then ( ( ) => { return ReadableStreamDefaultReaderRead ( reader ) . then ( ( { value , done } ) => { if ( done === true ) { return undefined ; } currentWrite = WritableStreamDefaultWriterWrite ( writer , value ) ; return currentWrite ; } ) ; } ) . then ( pipeLoop ) ; }
3323	function ( includeCommand ) { var args = [ ] ; if ( includeCommand === true ) { args . push ( this . commandAssignment ) ; } Object . keys ( this . _assignments ) . forEach ( function ( name ) { args . push ( this . getAssignment ( name ) ) ; } , this ) ; return args ; }
222	function isFullSyncing ( state , siteId ) { const syncStatus = getSyncStatus ( state , siteId ) ; if ( ! syncStatus ) { return false ; } const isStarted = get ( syncStatus , 'started' ) ; const isFinished = get ( syncStatus , 'finished' ) ; return isStarted && ! isFinished ; }
2696	function kernelInfoHandler ( message ) { var infoMessage = messages . kernelInfoResponse ( message ) ; messages . write ( infoMessage , _session . shell , _session . signer ) ; }
2788	function getStyle ( element , property ) { if ( window . getComputedStyle ) { return getStyleProperty ( element , property ) . original ; } else if ( element . currentStyle ) { return element . currentStyle [ property ] ; } return null ; }
3171	function ( packageName , since , closure , scope ) { if ( Version . compare ( Ext . getVersion ( packageName ) , since ) < 1 ) { closure . call ( scope ) ; } }
2116	function ( title , options , callback ) { var autoClose = 0 ; if ( options . autoClose && ( typeof options . autoClose === 'number' ) ) { autoClose = options . autoClose ; } if ( ! options . icon ) { options . icon = '/favicon.ico' ; } var onNotification = function ( notification ) { if ( options . onClick && notification ) { notification . onclick = options . onClick ; } var hideNotification = function ( ) { notification . close ( ) ; } ; if ( autoClose ) { setTimeout ( hideNotification , autoClose ) ; } callback ( null , hideNotification ) ; } ; var serviceWorkerRegistration = options . serviceWorkerRegistration ; if ( serviceWorkerRegistration ) { delete options . serviceWorkerRegistration ; if ( ! options . tag ) { tagCounter ++ ; options . tag = 'webnotification-' + Date . now ( ) + '-' + tagCounter ; } var tag = options . tag ; serviceWorkerRegistration . showNotification ( title , options ) . then ( function onCreate ( ) { serviceWorkerRegistration . getNotifications ( { tag : tag } ) . then ( function notificationsFetched ( notifications ) { if ( notifications && notifications . length ) { onNotification ( notifications [ 0 ] ) ; } else { callback ( new Error ( 'Unable to find notification.' ) ) ; } } ) . catch ( callback ) ; } ) . catch ( callback ) ; } else { var instance ; try { instance = new NotificationAPI ( title , options ) ; } catch ( error ) { callback ( error ) ; } if ( instance ) { onNotification ( instance ) ; } } }
3308	function getCurrentExpectedTypes ( type ) { var currentType ; var expectedType ; if ( type . name ) { currentType = type . name ; } else if ( type . expression ) { currentType = type . expression . name ; } expectedType = currentType && preferType [ currentType ] ; return { currentType : currentType , expectedType : expectedType } ; }
2825	function ensureProperties ( str ) { str = str || '' ; t . ok ( hasPropertyDefinition ( view , 'value' ) , 'has `value` property' + str ) ; t . equal ( typeof view . name , 'string' , 'has `name` property that is a string' + str ) ; t . notEqual ( view . name , '' , '`name` property should not be empty string' + str ) ; t . ok ( isFunction ( view . setValue ) , 'has `setValue` method' + str ) ; t . equal ( typeof view . valid , 'boolean' , 'has `valid` property that is a boolean' + str ) ; t . equal ( parent , view . parent , 'has same `parent` property' + str ) ; }
1774	function inferType ( type ) { if ( ! type ) return '' ; function iterateTypes ( subTree ) { return map ( normalizeValue ( subTree ) , inferType ) . join ( ', ' ) ; } switch ( type . name ) { case 'arrayOf' : return ` ${ iterateTypes ( type . value ) } ` ; case 'custom' : return COMMON_PROP_TYPES_TO_LINKS_MAP [ type . raw ] || type . raw ; case 'enum' : return ` ${ iterateTypes ( type . value ) } ` ; case 'shape' : case 'shapeOf' : return 'object' ; case 'union' : return iterateTypes ( type . value ) ; default : return type . name || type . value ; } }
20	function ( ax , ay , bx , by , cx , cy , dx , dy ) { var tobx = bx - ax ; var toby = by - ay ; var tocx = cx - bx ; var tocy = cy - by ; var todx = dx - cx ; var tody = dy - cy ; var precision = 40 ; var d , i , px , py , qx , qy , rx , ry , tx , ty , sx , sy , x , y , minx , miny , maxx , maxy , toqx , toqy , torx , tory , totx , toty ; for ( i = 0 ; i < ( precision + 1 ) ; i ++ ) { d = i / precision ; px = ax + d * tobx ; py = ay + d * toby ; qx = bx + d * tocx ; qy = by + d * tocy ; rx = cx + d * todx ; ry = cy + d * tody ; toqx = qx - px ; toqy = qy - py ; torx = rx - qx ; tory = ry - qy ; sx = px + d * toqx ; sy = py + d * toqy ; tx = qx + d * torx ; ty = qy + d * tory ; totx = tx - sx ; toty = ty - sy ; x = sx + d * totx ; y = sy + d * toty ; if ( i == 0 ) { minx = x ; miny = y ; maxx = x ; maxy = y ; } else { minx = Math . min ( minx , x ) ; miny = Math . min ( miny , y ) ; maxx = Math . max ( maxx , x ) ; maxy = Math . max ( maxy , y ) ; } } return new Rectangle ( Math . round ( minx ) , Math . round ( miny ) , Math . round ( maxx - minx ) , Math . round ( maxy - miny ) ) ; }
1854	function ( fn , context ) { return fn . call ( context || global , _ . bind ( r , this ) , _ , this ) ; }
435	function formatDomain ( domain , props , axis ) { return cleanDomain ( padDomain ( domain , props , axis ) , props , axis ) ; }
1919	function makePossibleRangesHTML ( source , tokens , offset ) { offset = offset || 0 ; var range = require ( 'range' ) ; var result = [ ] ; var attrStart = - 1 , attrName = '' , attrValue = '' , attrValueRange , tagName ; _ . each ( tokens , function ( tok ) { switch ( tok . type ) { case 'tag' : tagName = source . substring ( tok . start , tok . end ) ; if ( / ^<[\w\:\-] / . test ( tagName ) ) { result . push ( range . create ( { start : tok . start + 1 , end : tok . end } ) ) ; } break ; case 'attribute' : attrStart = tok . start ; attrName = source . substring ( tok . start , tok . end ) ; break ; case 'string' : result . push ( range . create ( attrStart , tok . end - attrStart ) ) ; attrValueRange = range . create ( tok ) ; attrValue = attrValueRange . substring ( source ) ; if ( isQuote ( attrValue . charAt ( 0 ) ) ) attrValueRange . start ++ ; if ( isQuote ( attrValue . charAt ( attrValue . length - 1 ) ) ) attrValueRange . end -- ; result . push ( attrValueRange ) ; if ( attrName == 'class' ) { result = result . concat ( classNameRanges ( attrValueRange . substring ( source ) , attrValueRange . start ) ) ; } break ; } } ) ; _ . each ( result , function ( r ) { r . shift ( offset ) ; } ) ; return _ . chain ( result ) . filter ( function ( item ) { return ! ! item . length ( ) ; } ) . uniq ( false , function ( item ) { return item . toString ( ) ; } ) . value ( ) ; }
1015	function ( id , path , body , contentType , options ) { const metadata = { mimeType : contentType } ; const headers = { 'Content-Type' : 'application/json; charset=UTF-8' } ; if ( options && options . ifMatch ) { headers [ 'If-Match' ] = '"' + options . ifMatch + '"' ; } return this . _request ( 'PUT' , BASE_URL + '/upload/drive/v2/files/' + id + '?uploadType=resumable' , { body : JSON . stringify ( metadata ) , headers : headers } ) . then ( ( response ) => { if ( response . status === 412 ) { return ( response ) ; } else { return this . _request ( 'PUT' , response . getResponseHeader ( 'Location' ) , { body : contentType . match ( / ^application\/json / ) ? JSON . stringify ( body ) : body } ) ; } } ) ; }
2147	function mergeTemplateAttributes ( dst , src ) { var srcAttr = src . $attr , dstAttr = dst . $attr ; forEach ( dst , function ( value , key ) { if ( key . charAt ( 0 ) !== '$' ) { if ( src [ key ] && src [ key ] !== value ) { if ( value . length ) { value += ( key === 'style' ? ';' : ' ' ) + src [ key ] ; } else { value = src [ key ] ; } } dst . $set ( key , value , true , srcAttr [ key ] ) ; } } ) ; forEach ( src , function ( value , key ) { if ( ! dst . hasOwnProperty ( key ) && key . charAt ( 0 ) !== '$' ) { dst [ key ] = value ; if ( key !== 'class' && key !== 'style' ) { dstAttr [ key ] = srcAttr [ key ] ; } } } ) ; }
3199	function clone ( o ) { var c = { } ; var h = Object . keys ( o ) ; for ( var i = 0 , co = h . length ; i < co ; i ++ ) { c [ h [ i ] ] = o [ h [ i ] ] ; } return c ; }
3117	function ( card ) { var me = this , previous ; card = me . getComponent ( card ) ; if ( card ) { previous = me . getActiveTab ( ) ; if ( previous !== card && me . fireEvent ( 'beforetabchange' , me , card , previous ) === false ) { return false ; } if ( ! card . isComponent ) { Ext . suspendLayouts ( ) ; card = me . add ( card ) ; Ext . resumeLayouts ( ) ; } me . activeTab = card ; Ext . suspendLayouts ( ) ; me . layout . setActiveItem ( card ) ; card = me . activeTab = me . layout . getActiveItem ( ) ; if ( card && card !== previous ) { me . tabBar . setActiveTab ( card . tab ) ; Ext . resumeLayouts ( true ) ; if ( previous !== card ) { me . fireEvent ( 'tabchange' , me , card , previous ) ; } } else { Ext . resumeLayouts ( true ) ; } return card ; } }
2744	function figureOutWhoUserIs ( req ) { var username = req . query . username if ( username === 'skroob' ) { return { username : username , email : 'pres@skroob.com' } } throw new HttpErrors . Unauthorized ( ) }
1696	function _touchStart ( event ) { if ( ! this . _touchEndEventListener ) { this . _touchEndEventListener = function ( event2 ) { event2 . target . removeEventListener ( 'touchend' , this . _touchEndEventListener ) ; _touchEnd . call ( this , event2 ) ; } . bind ( this ) ; } var oldTouchesCount = this . _scroll . activeTouches . length ; var i = 0 ; var j ; var touchFound ; while ( i < this . _scroll . activeTouches . length ) { var activeTouch = this . _scroll . activeTouches [ i ] ; touchFound = false ; for ( j = 0 ; j < event . touches . length ; j ++ ) { var touch = event . touches [ j ] ; if ( touch . identifier === activeTouch . id ) { touchFound = true ; break ; } } if ( ! touchFound ) { this . _scroll . activeTouches . splice ( i , 1 ) ; } else { i ++ ; } } for ( i = 0 ; i < event . touches . length ; i ++ ) { var changedTouch = event . touches [ i ] ; touchFound = false ; for ( j = 0 ; j < this . _scroll . activeTouches . length ; j ++ ) { if ( this . _scroll . activeTouches [ j ] . id === changedTouch . identifier ) { touchFound = true ; break ; } } if ( ! touchFound ) { var current = [ changedTouch . clientX , changedTouch . clientY ] ; var time = _getEventTimestamp ( event ) ; this . _scroll . activeTouches . push ( { id : changedTouch . identifier , start : current , current : current , prev : current , time : time , prevTime : time } ) ; changedTouch . target . addEventListener ( 'touchend' , this . _touchEndEventListener ) ; } } if ( ! oldTouchesCount && this . _scroll . activeTouches . length ) { this . applyScrollForce ( 0 ) ; this . _scroll . touchDelta = 0 ; } }
748	function share ( network ) { this . openSharer ( network , this . createSharingUrl ( network ) ) ; this . $root . $emit ( 'social_shares_open' , network , this . url ) ; this . $emit ( 'open' , network , this . url ) ; }
1709	function ViewStackLayout ( context , options ) { var set = { size : context . size , translate : [ 0 , 0 , 0 ] } ; this . _size [ 0 ] = context . size [ 0 ] ; this . _size [ 1 ] = context . size [ 1 ] ; var views = context . get ( 'views' ) ; var transferables = context . get ( 'transferables' ) ; var visibleCount = 0 ; for ( var i = 0 ; i < views . length ; i ++ ) { var item = this . _viewStack [ i ] ; switch ( item . state ) { case ItemState . HIDDEN : context . set ( views [ i ] , { size : context . size , translate : [ context . size [ 0 ] * 2 , context . size [ 1 ] * 2 , 0 ] } ) ; break ; case ItemState . HIDE : case ItemState . HIDING : case ItemState . VISIBLE : case ItemState . SHOW : case ItemState . SHOWING : if ( visibleCount < 2 ) { visibleCount ++ ; var view = views [ i ] ; context . set ( view , set ) ; for ( var j = 0 ; j < transferables . length ; j ++ ) { for ( var k = 0 ; k < item . transferables . length ; k ++ ) { if ( transferables [ j ] . renderNode === item . transferables [ k ] . renderNode ) { context . set ( transferables [ j ] , { translate : [ 0 , 0 , set . translate [ 2 ] ] , size : [ context . size [ 0 ] , context . size [ 1 ] ] } ) ; } } } set . translate [ 2 ] += options . zIndexOffset ; } break ; } } }
3433	function ( array , begin , end ) { if ( typeof begin === 'undefined' ) { return slice . call ( array ) ; } if ( typeof end === 'undefined' ) { return slice . call ( array , begin ) ; } return slice . call ( array , begin , end ) ; }
2330	function listLocalDatasetClientData ( datasetClient , cb ) { syncStorage . readDatasetClientWithRecords ( datasetClient . getId ( ) , function ( err , datasetClientsWithRecords ) { if ( err ) { return cb ( err ) ; } if ( ! datasetClientsWithRecords || ! datasetClientsWithRecords . syncCompleted ) { return cb ( null , null ) ; } else { return cb ( null , datasetClientsWithRecords ) ; } } ) ; }
1684	function _isEqualArray ( a , b ) { if ( a === b ) { return true ; } if ( ( a === undefined ) || ( b === undefined ) ) { return false ; } var i = a . length ; if ( i !== b . length ) { return false ; } while ( i -- ) { if ( a [ i ] !== b [ i ] ) { return false ; } } return true ; }
1772	function ( helperOptions ) { if ( helperOptions . exprData . argExprs . length !== 1 ) { throw new Error ( "for(of) broken syntax" ) ; } var helperExpr = helperOptions . exprData . argExprs [ 0 ] . expr ; var variableName , valueLookup , valueObservable ; if ( helperExpr instanceof expression . Lookup ) { valueObservable = helperExpr . value ( helperOptions . scope ) ; } else if ( helperExpr instanceof expression . Helper ) { var inLookup = helperExpr . argExprs [ 0 ] ; if ( inLookup . key !== "of" ) { throw new Error ( "for(of) broken syntax" ) ; } variableName = helperExpr . methodExpr . key ; valueLookup = helperExpr . argExprs [ 1 ] ; valueObservable = valueLookup . value ( helperOptions . scope ) ; } var items = valueObservable ; var args = [ ] . slice . call ( arguments ) , options = args . pop ( ) , resolved = bindAndRead ( items ) ; if ( resolved && ! canReflect . isListLike ( resolved ) ) { return forOfObject ( resolved , variableName , helperOptions ) ; } if ( options . stringOnly ) { var parts = [ ] ; canReflect . eachIndex ( resolved , function ( value , index ) { var variableScope = { } ; if ( variableName !== undefined ) { variableScope [ variableName ] = value ; } parts . push ( helperOptions . fn ( options . scope . add ( { index : index } , { special : true } ) . addLetContext ( variableScope ) ) ) ; } ) ; return parts . join ( "" ) ; } else { options . metadata . rendered = true ; return function ( el ) { var nodeList = [ el ] ; nodeList . expression = "live.list" ; nodeLists . register ( nodeList , null , options . nodeList , true ) ; nodeLists . update ( options . nodeList , [ el ] ) ; var cb = function ( item , index , parentNodeList ) { var variableScope = { } ; if ( variableName !== undefined ) { variableScope [ variableName ] = item ; } return options . fn ( options . scope . add ( { index : index } , { special : true } ) . addLetContext ( variableScope ) , options . options , parentNodeList ) ; } ; live . list ( el , items , cb , options . context , el . parentNode , nodeList , function ( list , parentNodeList ) { return options . inverse ( options . scope , options . options , parentNodeList ) ; } ) ; } ; } }
1524	function ( options , callback ) { if ( ! ( 'headers' in options ) ) { options . headers = { } ; } options . json = true ; options . headers [ 'User-Agent' ] = Poloniex . USER_AGENT ; options . strictSSL = Poloniex . STRICT_SSL ; options . timeout = Poloniex . TIMEOUT ; return new Promise ( function ( resolve , reject ) { request ( options , function ( err , response , body ) { if ( ! err && ( typeof body === 'undefined' || body === null ) ) { err = new Error ( 'Empty response from remote server' ) ; } if ( err ) { reject ( err ) ; } else { resolve ( body ) ; } if ( typeof callback === 'function' ) { callback ( err , body ) ; } } ) ; } ) ; }
1066	function ( ) { var template = this . getTemplate ( ) , data ; this . _preRender ( ) ; data = this . getTemplateData ( ) ; data = this . decorateTemplateData ( data ) ; if ( template == null ) { throw new Error ( this . name + ": template \"" + \" + this . getTemplateName ( ) ) ; } "\" not found." }
246	function deselect ( ) { let clipboard , dom = editor . dom ; if ( selected ) { clipboard = editor . dom . select ( '.wpview-clipboard' , selected ) [ 0 ] ; dom . unbind ( clipboard ) ; dom . remove ( clipboard ) ; dom . unbind ( selected , 'beforedeactivate focusin focusout click mouseup' , _stop ) ; dom . setAttrib ( selected , 'data-mce-selected' , null ) ; } selected = null ; }
1613	function ( hdr ) { sess . _next_subpacket_handler = function ( spkt ) { sess . _next_subpacket_handler = null ; sess . _consume_ZSINIT_data ( spkt ) ; sess . _send_header ( 'ZACK' ) ; sess . _next_header_handler = between_files_handler ; } ; }
921	function findChangeComputedProps ( allDeps , changeProp ) { let result = [ ] ; Object . keys ( allDeps ) . forEach ( k => { let depList = allDeps [ k ] ; if ( k !== changeProp && depList . indexOf ( changeProp ) !== - 1 ) { result . push ( k ) ; } } ) ; return result ; }
3142	function ( removeTarget ) { var me = this , target = me . target ; me . bindings = [ ] ; me . disable ( ) ; if ( removeTarget === true ) { if ( target . isComponent ) { target . destroy ( ) ; } else { target . remove ( ) ; } } delete me . target ; }
2625	function equalArrayElements ( needle , haystack ) { let missingNeedle = needle . filter ( n => haystack . indexOf ( n ) === - 1 ) if ( missingNeedle . length !== 0 ) { return false } let missingHaystack = haystack . filter ( h => needle . indexOf ( h ) === - 1 ) return missingHaystack . length === 0 }
2571	function intersectString ( s , other ) { if ( typeof other !== 'string' || typeof s !== 'string' ) return s ; var sarr = s . split ( '' ) , oarr = other . split ( '' ) ; return libs . array . intersect ( sarr , oarr ) . join ( '' ) ; }
1749	function encodeMethod ( method , values ) { const paramsEncoded = encodeParams ( utils . getKeys ( method . inputs , 'type' ) , values ) . substring ( 2 ) ; return ` ${ encodeSignature ( method ) } ${ paramsEncoded } ` ; }
1482	function ( callback ) { var t = this ; async . waterfall ( [ function readDb ( callback ) { fs . exists ( t . __dbFilename , function ( exists ) { if ( exists ) { fs . readFile ( t . __dbFilename , { encoding : "utf-8" } , callback ) ; } else { callback ( null , null ) ; } } ) ; } , function parseDb ( data , callback ) { t . __db = data && data . trim ( ) . length ? jsonlint . parse ( data ) : { } ; callback ( null , t . __db ) ; } ] , callback ) ; }
1436	async function ( library_name ) { return ( await this . getContribData ( ) ) . libraries . find ( lib => lib . library_name === library_name ) ; }
422	function ( ) { var entities = this . entities ; return this . comment ( ) || entities . literal ( ) || entities . variable ( ) || entities . url ( ) || entities . property ( ) || entities . call ( ) || entities . keyword ( ) || this . mixin . call ( true ) || entities . javascript ( ) ; }
743	function StripeResource ( stripe , urlData ) { this . _stripe = stripe ; this . _urlData = urlData || { } ; this . basePath = utils . makeURLInterpolator ( this . basePath || stripe . getApiField ( 'basePath' ) ) ; this . resourcePath = this . path ; this . path = utils . makeURLInterpolator ( this . path ) ; if ( this . includeBasic ) { this . includeBasic . forEach ( function ( methodName ) { this [ methodName ] = StripeResource . BASIC_METHODS [ methodName ] ; } , this ) ; } this . initialize . apply ( this , arguments ) ; }
1868	function getNewline ( content , pos ) { return content . charAt ( pos ) == '\r' && \r ? content . charAt ( pos + 1 ) == '\n' : \n ; }
167	function toolbarPin ( editor ) { let isMonitoringScroll = false , isPinned = false , container ; function setContainer ( ) { container = editor . getContainer ( ) ; } function togglePinned ( toBePinned ) { isPinned = toBePinned ; editor . dom . toggleClass ( container , 'is-pinned' , isPinned ) ; } const pinToolbarOnScroll = throttle ( ( ) => { if ( ! container ) { return ; } if ( isPinned && window . pageYOffset < container . offsetTop ) { togglePinned ( false ) ; } else if ( ! isPinned && window . pageYOffset > container . offsetTop ) { togglePinned ( true ) ; } } , 50 ) ; const maybeBindScroll = throttle ( event => { const isVisual = ! editor . isHidden ( ) ; const shouldBind = 'remove' !== event . type && isVisual && isWithinBreakpoint ( '>660px' ) ; if ( shouldBind === isMonitoringScroll ) { return ; } const eventBindFn = ( shouldBind ? 'add' : 'remove' ) + 'EventListener' ; window [ eventBindFn ] ( 'scroll' , pinToolbarOnScroll ) ; isMonitoringScroll = shouldBind ; if ( isMonitoringScroll ) { setContainer ( ) ; pinToolbarOnScroll ( ) ; } else { togglePinned ( false ) ; } } , 200 ) ; editor . on ( 'init show hide remove' , maybeBindScroll ) ; window . addEventListener ( 'resize' , maybeBindScroll ) ; }
3646	function VariableStatement ( name ) { var bracketIndex = name . indexOf ( '(' ) ; if ( bracketIndex !== - 1 ) { var endBracketIndex = name . indexOf ( ')' ) ; if ( endBracketIndex === - 1 ) throw new SyntaxError ( 'Expected end bracket' ) ; var arrayName = name . substring ( 0 , bracketIndex ) ; var arrayDimensionsText = name . substring ( bracketIndex + 1 , endBracketIndex ) . trim ( ) ; var arrayDimensions = new statements . ArgumentStatement ( arrayDimensionsText ) ; name = arrayName ; this . isArray = true ; this . dimensions = arrayDimensions . args ; } else this . isArray = false ; if ( name [ name . length - 1 ] === '$' ) { this . type = 'string' ; this . name = name . substring ( 0 , name . length - 1 ) ; } else { this . type = 'number' ; this . name = name ; } }
1351	function ( opts ) { opts . accesskey = opts . accesskey || opts . password ; delete opts . password ; if ( opts . selenium . hostname . match ( / ondemand.saucelabs.com / ) ) { opts . SAUCE_USERNAME = opts . SAUCE_USERNAME || opts . username ; opts . SAUCE_ACCESSKEY = opts . SAUCE_ACCESSKEY || opts . accesskey ; if ( typeof opts . SAUCE_USERNAME !== 'undefined' && typeof opts . SAUCE_ACCESSKEY !== 'undefined' ) { opts . selenium . auth = opts . SAUCE_USERNAME + ':' + opts . SAUCE_ACCESSKEY ; delete opts . SAUCE_ACCESSKEY ; delete opts . SAUCE_USERNAME ; } } else if ( opts . selenium . hostname . match ( / hub.browserstack.com / ) ) { opts . BROWSERSTACK_USERNAME = opts . BROWSERSTACK_USERNAME || opts . username ; opts . BROWSERSTACK_KEY = opts . BROWSERSTACK_KEY || opts . accesskey ; if ( typeof opts . BROWSERSTACK_USERNAME !== 'undefined' ) { opts . browsers . forEach ( function ( browser ) { browser [ 'browserstack.user' ] = opts . BROWSERSTACK_USERNAME ; browser [ 'browserstack.key' ] = opts . BROWSERSTACK_KEY ; } ) ; delete opts . BROWSERSTACK_USERNAME ; delete opts . BROWSERSTACK_KEY ; delete opts . selenium . user ; delete opts . selenium . pwd ; } } delete opts . username ; delete opts . password ; return opts ; }
2088	function oldIsPlugin ( nodeModulePath ) { try { if ( fs . statSync ( path . resolve ( nodeModulePath , 'plugin.js' ) ) ) { return true ; } else { return false ; } } catch ( e ) { return false ; } }
3355	function ( ) { var me = this , picker ; if ( me . isExpanded ) { picker = me . getPicker ( ) ; if ( me . matchFieldWidth ) { picker . setWidth ( me . bodyEl . getWidth ( ) ) ; } if ( picker . isFloating ( ) ) { me . doAlign ( ) ; } } }
1891	function ( node , offset ) { var maxNum = 0 ; var options = { tabstop : function ( data ) { var group = parseInt ( data . group ) ; if ( group > maxNum ) maxNum = group ; if ( data . placeholder ) return '${' + ( group + offset ) + ':' + data . placeholder + '}' ; else return '${' + ( group + offset ) + '}' ; } } ; _ . each ( [ 'start' , 'end' , 'content' ] , function ( p ) { node [ p ] = this . processText ( node [ p ] , options ) ; } , this ) ; return maxNum ; }
1544	function ( done ) { var dependencies = [ ] , addPackageToDependencies = function ( pkg ) { dependencies . push ( pkg . name ) ; } ; this . bundler . on ( 'package' , addPackageToDependencies ) ; return this . compile ( function ( err ) { this . bundler . removeListener ( 'package' , addPackageToDependencies ) ; return done ( err , _ . uniq ( dependencies ) . sort ( ) ) ; } . bind ( this ) ) ; }
3061	function matchIdentifierName ( name ) { var noid = identifier ( ) . replace ( '[' , '[^' ) ; noid = '(^|$|' + noid + ')' ; return noid + name + noid ; }
419	function ( ) { var js , index = parserInput . i ; parserInput . save ( ) ; var escape = parserInput . $char ( '~' ) ; var jsQuote = parserInput . $char ( '`' ) ; if ( ! jsQuote ) { parserInput . restore ( ) ; return ; } js = parserInput . $re ( / ^[^`]*` / ) ; if ( js ) { parserInput . forget ( ) ; return new ( tree . JavaScript ) ( js . substr ( 0 , js . length - 1 ) , Boolean ( escape ) , index , fileInfo ) ; } parserInput . restore ( 'invalid javascript definition' ) ; }
1788	function extendInterfaces ( helperName , helperFactory ) { interfaceExtensions . push ( function ( ) { var Mocha = window . Mocha ; Object . keys ( Mocha . interfaces ) . forEach ( function ( interfaceName ) { var originalInterface = Mocha . interfaces [ interfaceName ] ; var teardownProperty = interfaceName === 'tdd' ? 'teardown' : 'afterEach' ; Mocha . interfaces [ interfaceName ] = function ( suite ) { originalInterface . apply ( this , arguments ) ; suite . on ( 'pre-require' , function ( context , _file , _mocha ) { var teardown = context [ teardownProperty ] . bind ( context ) ; context [ helperName ] = helperFactory ( context , teardown , interfaceName ) ; } ) ; } ; } ) ; } ) ; }
627	function getRelevantWords ( text , locale ) { let language = getLanguage ( locale ) ; if ( ! functionWordLists . hasOwnProperty ( language ) ) { language = "en" ; } const functionWords = functionWordLists [ language ] ; const words = getWordCombinations ( text , 1 , functionWords . all ) ; const wordCount = words . length ; let oneWordCombinations = getRelevantCombinations ( calculateOccurrences ( words ) ) ; sortCombinations ( oneWordCombinations ) ; oneWordCombinations = take ( oneWordCombinations , 100 ) ; const oneWordRelevanceMap = { } ; forEach ( oneWordCombinations , function ( combination ) { oneWordRelevanceMap [ combination . getCombination ( ) ] = combination . getRelevance ( ) ; } ) ; const twoWordCombinations = calculateOccurrences ( getWordCombinations ( text , 2 , functionWords . all ) ) ; const threeWordCombinations = calculateOccurrences ( getWordCombinations ( text , 3 , functionWords . all ) ) ; const fourWordCombinations = calculateOccurrences ( getWordCombinations ( text , 4 , functionWords . all ) ) ; const fiveWordCombinations = calculateOccurrences ( getWordCombinations ( text , 5 , functionWords . all ) ) ; let combinations = oneWordCombinations . concat ( twoWordCombinations , threeWordCombinations , fourWordCombinations , fiveWordCombinations ) ; combinations = filterCombinations ( combinations , functionWords , language ) ; forEach ( combinations , function ( combination ) { combination . setRelevantWords ( oneWordRelevanceMap ) ; } ) ; combinations = getRelevantCombinations ( combinations ) ; sortCombinations ( combinations ) ; if ( wordCount >= wordCountLowerLimit ) { combinations = filterOnDensity ( combinations , wordCount , densityLowerLimit , densityUpperLimit ) ; } return take ( combinations , relevantWordLimit ) ; }
3517	function ( type , options , fn ) { if ( arguments . length === 1 ) { return this [ type ] . iterator . fn ; } if ( typeof options === 'function' ) { fn = options ; options = { } ; } this [ type ] = new LoaderType ( options , fn . bind ( this ) ) ; this . setLoaderType ( type ) ; return this ; }
2306	function _set ( obj , keypath , value ) { var parts = _keyPathNormalize ( keypath ) . split ( '.' ) var last = parts . pop ( ) var dest = obj var hasError var errorInfo util . some ( parts , function ( key ) { var t = util . type ( dest ) if ( t != 'object' && t != 'array' ) { hasError = true errorInfo = [ key , dest ] return true } dest = dest [ key ] } ) if ( ! hasError ) { if ( util . type ( dest ) != 'object' && util . type ( dest ) != 'array' ) { hasError = true errorInfo = [ last , dest ] } else { dest [ last ] = value return obj } } throw new Error ( 'Can\' not access "' + \' + errorInfo [ 0 ] + '" of "' + errorInfo [ 1 ] + '" when set value of "' + keypath ) }
1119	function createTrafficGroup ( bigIp , trafficGroup ) { let createGroup = true ; bigIp . list ( '/tm/cm/traffic-group' ) . then ( ( response ) => { response . forEach ( ( group ) => { if ( group . name === trafficGroup ) { createGroup = false ; } } ) ; if ( createGroup ) { return bigIp . create ( '/tm/cm/traffic-group' , { name : trafficGroup , partition : '/Common' } ) ; } return q ( ) ; } ) . catch ( ( err ) => { return q . reject ( err ) ; } ) ; }
3169	function ( ) { var me = this , obj = me . getStorageObject ( ) , ids = me . getIds ( ) , len = ids . length , i ; for ( i = 0 ; i < len ; i ++ ) { obj . removeItem ( me . getRecordKey ( ids [ i ] ) ) ; } obj . removeItem ( me . getRecordCounterKey ( ) ) ; obj . removeItem ( me . getTreeKey ( ) ) ; obj . removeItem ( me . id ) ; me . cache = { } ; }
1413	function ( ) { var result = { } ; this . __classes . forEach ( name => result [ name ] = true ) ; this . __expandClassnames ( this . getInclude ( ) ) . forEach ( name => result [ name ] = true ) ; this . __expandClassnames ( this . getExclude ( ) ) . forEach ( name => delete result [ name ] ) ; return Object . keys ( result ) . sort ( ) ; }
2997	function rsaVerify ( input , algorithm , publicSecret , signature ) { try { const verify = crypto . createVerify ( algorithm ) . update ( input ) . verify ( publicSecret , base64URLUnescape ( signature ) , 'base64' ) if ( ! verify ) { errorMap [ '006' ] . message = 'Unvalid public secret for rsa verify, signature verification failed' errorMap [ '006' ] . error = new Error ( errorMap [ '006' ] . message ) } return verify } catch ( e ) { errorMap [ '006' ] . message = 'Exception error in rsa verify, signature verification failed' errorMap [ '006' ] . error = e return false } }
3407	function ( ) { var me = this , header = me . getGroupedHeader ( ) ; if ( me . hideGroupedHeader && header ) { Ext . suspendLayouts ( ) ; if ( me . prunedHeader && me . prunedHeader !== header ) { me . prunedHeader . show ( ) ; } me . prunedHeader = header ; header . hide ( ) ; Ext . resumeLayouts ( true ) ; } }
993	function localeComparator ( model1 , model2 ) { var a1 = model1 . get ( this . sortField ) , a2 = model2 . get ( this . sortField ) ; if ( a1 !== undefined && a1 . localeCompare ) { var result = a1 . localeCompare ( a2 ) * this . sortDir ; if ( result || ! this . secondarySortField ) { return result ; } a1 = model1 . get ( this . secondarySortField ) ; a2 = model2 . get ( this . secondarySortField ) ; return a1 . localeCompare ( a2 ) * this . sortDir ; } return a1 > a2 ? this . sortDir : ( a1 < a2 ? - this . sortDir : 0 ) ; }
807	function ( state , title , url ) { var win = this . win ; if ( this . canClientNavigate ( ) ) { win . history . replaceState ( state , title , url ) ; } else if ( url !== this . currentUrl ( ) ) { this . navigationWindow ( ) . location . replace ( url ) ; } }
1215	function initialize ( name , accessor ) { var consumerSecret ; if ( accessor . accessorSecret != null && name . length > 9 && name . substring ( name . length - 9 ) == "-Accessor" ) { consumerSecret = accessor . accessorSecret ; } else { consumerSecret = accessor . consumerSecret ; } this . key = OAuth . percentEncode ( consumerSecret ) + "&" + OAuth . percentEncode ( accessor . tokenSecret ) ; }
1904	function ( pos , isAbsolute ) { return _ . find ( this . list ( ) , function ( elem ) { return elem . range ( isAbsolute ) . inside ( pos ) ; } ) ; }
1127	function checkTask ( taskPath , taskIdToCheck , options ) { const func = function ( ) { const deferred = q . defer ( ) ; this . list ( ` ${ taskPath } ${ taskIdToCheck } ` , undefined , util . NO_RETRY ) . then ( ( response ) => { const statusAttribute = ( options && options . statusAttribute ) ? options . statusAttribute : '_taskState' ; const taskState = response [ statusAttribute ] ; if ( taskState === 'VALIDATING' || taskState === 'STARTED' ) { deferred . reject ( ) ; } else if ( taskState === 'COMPLETED' || taskState === 'FINISHED' ) { deferred . resolve ( { success : true , response } ) ; } else if ( taskState === 'FAILED' ) { deferred . resolve ( { success : false , response } ) ; } else { deferred . reject ( new Error ( ` ${ taskState } ` ) ) ; } } ) . catch ( ( ) => { deferred . resolve ( { success : true } ) ; } ) ; return deferred . promise ; } ; return util . tryUntil ( this , util . DEFAULT_RETRY , func ) ; }
3518	function ( name ) { var args = utils . slice ( arguments , 1 ) ; var opts = args . shift ( ) ; var type = this . getLoaderType ( opts ) ; this [ type ] . set ( name , this [ type ] . resolve ( args ) ) ; return this ; }
2826	function printEnvironment ( environment , path , outputFile ) { if ( path ) environment = traverse ( environment ) . get ( path . split ( '.' ) ) ; path = path ? '.' + path : '' ; if ( argv . format === 'json' || outputFile ) { var json = JSON . stringify ( environment , null , 2 ) ; if ( outputFile ) fs . writeFileSync ( outputFile , json , 'utf-8' ) ; else console . log ( JSON . stringify ( environment , null , 2 ) ) ; } else { environment = _ . mapValues ( environment , function ( v ) { return util . inspect ( v , { colors : true } ) ; } ) ; console . log ( chalk . blue ( '==> ' ) + chalk . bold ( renv . environment + path ) ) ; console . log ( columnify ( environment , { showHeaders : false , config : { key : { minWidth : parseInt ( width * 0.4 ) , maxWidth : parseInt ( width * 0.4 ) } , value : { minWidth : parseInt ( width * 0.6 ) , maxWidth : parseInt ( width * 0.6 ) } , } } ) ) ; } }
616	function getRelevantCombinations ( wordCombinations ) { wordCombinations = wordCombinations . filter ( function ( combination ) { return combination . getOccurrences ( ) !== 1 && combination . getRelevance ( ) !== 0 ; } ) ; return wordCombinations ; }
3875	function val ( node , _val2 ) { if ( node && node . el ) { var el = node . el ; if ( _val2 !== undefined ) { el . value = _val2 ; } else { return el . value ; } } }
2823	function ( ) { var instance = this ; instance . _runningRequests . forEach ( function ( promise ) { promise . abort ( ) ; } ) ; instance . _runningRequests . length = 0 ; }
3489	function ( o ) { for ( var i = 1 , a = arguments , len = a . length ; i < len ; i ++ ) { Ext . destroy ( o [ a [ i ] ] ) ; delete o [ a [ i ] ] ; } }
2268	function ( queryString ) { var pairs = queryString . split ( '&' ) ; var params = { } ; pairs . forEach ( function ( pair ) { pair = pair . split ( '=' ) ; params [ pair [ 0 ] ] = decodeURIComponent ( pair [ 1 ] || '' ) ; } ) ; return params ; }
267	function warn ( ) { if ( ! I18N . throwErrors ) { return ; } if ( 'undefined' !== typeof window && window . console && window . console . warn ) { window . console . warn . apply ( window . console , arguments ) ; } }
3337	function ( data , hashId , key ) { if ( hashId != 0 && ( key == "" || String . fromCharCode ( 0 ) ) ) { return null ; } var r = this . $composeBuffer ( data , hashId , key ) ; var buffer = r . bufferToUse ; var symbolicName = r . symbolicName ; r = this . $find ( data , buffer , symbolicName , hashId , key ) ; if ( DEBUG ) { console . log ( "KeyboardStateMapper#match" , buffer , symbolicName , r ) ; } return r ; }
2125	function constructProfile ( firstName , lastName , email , login , mobilePhone , customAttribs ) { var profile = { } ; profile . login = ( login ? login : email ) ; profile . email = email ; profile . firstName = firstName ; profile . lastName = lastName ; profile . mobilePhone = mobilePhone ; if ( customAttribs != undefined ) { for ( prop in customAttribs ) { profile [ prop ] = customAttribs [ prop ] ; } } return profile ; }
503	function checkCallMemCost ( runState , callOptions , localOpts ) { subMemUsage ( runState , localOpts . outOffset , localOpts . outLength ) if ( ! callOptions . gasLimit ) { callOptions . gasLimit = new BN ( runState . gasLeft ) } }
2076	function startConnector ( username , apiKey , exitCb ) { var jarPath = process . env . SAUCE_JAR || path . join ( __dirname , "thirdparty" , "Sauce-Connect.jar" ) var jcmd = "java" var jargs = [ "-Xmx64m" , "-jar" , jarPath , username , apiKey ] var screencmd = "java -Xmx64m -jar " + jarPath + " [USERNAME] [API KEY]" ctx . comment ( "Starting Sauce Connector" ) var opts = { cwd : ctx . workingDir , cmd : { command : jcmd , args : jargs , screen : screencmd } } connectorProc = ctx . cmd ( opts , exitCb ) connectorProc . stdout . on ( 'data' , function ( data ) { console . log ( ">>" , data ) ; if ( / Connected! You may start your tests. / . exec ( data ) !== null ) { console . log ( ">> STRIDER-SAUCE :: TUNNEL READY" ) return cb ( null , true ) } } ) }
2086	function onListening ( ) { let addr = server . address ( ) , bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr . port ; we . log . info ( 'Run in ' + we . env + ' enviroment and listening on ' + bind ) ; if ( process . send ) { process . send ( 'ready' ) ; } }
2517	function compareDirFiles ( parentId , old_children , descendants ) { var changes = [ ] , not_found = object . extend ( { } , old_children ) ; for ( var id in descendants ) { if ( descendants [ id ] . ancestors [ descendants [ id ] . ancestors . length - 1 ] === parentId ) { if ( ! old_children [ id ] ) { changes . push ( { event : 'created' , file : descendants [ id ] } ) ; old_children [ id ] = descendants [ id ] ; } else if ( old_children [ id ] . modifiedDT < descendants [ id ] . modifiedDT ) { changes . push ( { event : 'updated' , file : descendants [ id ] } ) ; old_children [ id ] = descendants [ id ] ; delete not_found [ id ] ; } else { delete not_found [ id ] ; } } } for ( var id in not_found ) { changes . push ( { event : 'removed' , file : not_found [ id ] } ) ; delete old_children [ id ] ; } return changes ; }
628	function WordCombination ( words , occurrences , functionWords ) { this . _words = words ; this . _length = words . length ; this . _occurrences = occurrences || 0 ; this . _functionWords = functionWords ; }
1136	function jscoverage_selectTab ( tab ) { if ( typeof tab !== 'number' ) { tab = jscoverage_tabIndexOf ( tab ) ; } var tabs = document . getElementById ( 'tabs' ) ; var tabPages = document . getElementById ( 'tabPages' ) ; var nodeList ; var tabNum ; var i ; var node ; nodeList = tabs . childNodes ; tabNum = 0 ; for ( i = 0 ; i < nodeList . length ; i ++ ) { node = nodeList . item ( i ) ; if ( node . nodeType !== 1 ) { continue ; } if ( node . className !== 'disabled' ) { if ( tabNum === tab ) { node . className = 'selected' ; } else { node . className = '' ; } } tabNum ++ ; } nodeList = tabPages . childNodes ; tabNum = 0 ; for ( i = 0 ; i < nodeList . length ; i ++ ) { node = nodeList . item ( i ) ; if ( node . nodeType !== 1 ) { continue ; } if ( tabNum === tab ) { node . className = 'selected TabPage' ; } else { node . className = 'TabPage' ; } tabNum ++ ; } }
1213	function correctTimestampFromSrc ( parameterName ) { parameterName = parameterName || "oauth_timestamp" ; var scripts = document . getElementsByTagName ( 'script' ) ; if ( scripts == null || ! scripts . length ) return ; var src = scripts [ scripts . length - 1 ] . src ; if ( ! src ) return ; var q = src . indexOf ( "?" ) ; if ( q < 0 ) return ; parameters = OAuth . getParameterMap ( OAuth . decodeForm ( src . substring ( q + 1 ) ) ) ; var t = parameters [ parameterName ] ; if ( t == null ) return ; OAuth . correctTimestamp ( t ) ; }
2345	function doUpdateDatasetClient ( datasetClientId , fields , upsert , cb ) { debug ( 'doUpdateDatasetClient datasetClientId = %s :: fields = %j' , datasetClientId , fields ) ; var col = mongoClient . collection ( DATASETCLIENTS_COLLECTION ) ; delete fields . _id ; col . findOneAndUpdate ( { id : datasetClientId } , { '$set' : fields } , { upsert : upsert , returnOriginal : false } , function ( err , result ) { if ( err ) { debugError ( 'Failed to update datasetClients due to error %s :: datasetClientId = %s :: fields = %j' , err , datasetClientId , fields ) ; return cb ( err ) ; } if ( result . value === null ) { return cb ( new Error ( 'DatasetClient not found for id ' + datasetClientId ) ) ; } ensureIndexesForDataset ( result . value . datasetId ) ; return cb ( null , result . value ) ; } ) ; }
3796	function ( cb ) { Person . find ( 'Scott' , function ( err , person ) { if ( err ) { return cb ( err ) ; } assert ( person . uuid ) ; assert ( person . name === 'Scott' ) ; scott = person ; cb ( ) ; } ) ; }
1439	async function ( path ) { return fs . writeFileAsync ( path , JSON . stringify ( this . __cache , null , 2 ) , "UTF-8" ) . catch ( e => console . error ( ` ${ path } ` + e . message ) ) ; }
2248	function get ( path ) { let czConfig ; try { fs . accessSync ( path , fs . R_OK ) ; czConfig = require ( path ) ; } catch ( err ) { czConfig = { } ; } return czConfig ; }
2851	function arrayAggregator ( array , setter , iteratee , accumulator ) { var index = - 1 , length = array ? array . length : 0 ; while ( ++ index < length ) { var value = array [ index ] ; setter ( accumulator , value , iteratee ( value ) , array ) ; } return accumulator ; }
1116	function proxyRequest ( req , res , proxyTo , opts ) { opts = opts || { } ; var httpRequestFunction = opts . httpRequestFunction || http . request ; var httpsRequestFunction = opts . httpsRequestFunction || https . request ; var setHostHeader = opts . setHostHeader ; var proxyUrl = proxyTo ; if ( typeof ( proxyTo ) === 'string' ) { proxyUrl = url . parse ( proxyTo , true ) ; } var proxyToHost = proxyUrl . hostname ; var proxyToPort = proxyUrl . port || ( proxyUrl . protocol === 'https:' ? 443 : 80 ) ; var proxyToPath = proxyUrl . pathname + ( proxyUrl . search === null ? "" : proxyUrl . search ) ; var requestFunction = ( proxyUrl . protocol === 'https:' ) ? httpsRequestFunction : httpRequestFunction ; var headers = { } ; for ( var h in req . headers ) { headers [ h ] = req . headers [ h ] ; } if ( setHostHeader ) { headers . host = proxyToHost + ( proxyUrl . port ? ":" + proxyUrl . port : "" ) ; } var proxyReq = requestFunction ( { host : proxyToHost , port : proxyToPort , method : req . method , path : proxyToPath , headers : headers } , function ( proxyRes ) { res . statusCode = proxyRes . statusCode ; res . headers = proxyRes . headers ; proxyRes . on ( "data" , function ( chunk ) { res . write ( chunk ) ; } ) ; proxyRes . on ( "end" , function ( ) { res . end ( ) ; } ) ; } ) ; proxyReq . on ( 'error' , function ( err ) { res . statusCode = 502 ; res . send ( 'Bad Gateway! Could not proxy request. Invalid host or proxy destination down? Reported error was: ' + err ) ; } ) ; if ( req . rawBody ) { proxyReq . write ( req . rawBody ) ; } proxyReq . end ( ) ; }
3239	function ( ) { var animateWithClass = this . animateClearButton && this . animateWithCss3 ; this . clearButtonEl = this . textField . bodyEl . createChild ( { tag : 'div' , cls : this . clearButtonCls } ) ; if ( this . animateClearButton ) { this . animateWithCss3 = this . supportsCssTransition ( this . clearButtonEl ) ; } if ( this . animateWithCss3 ) { this . clearButtonEl . addCls ( this . clearButtonCls + '-off' ) ; } else { this . clearButtonEl . setStyle ( 'visibility' , 'hidden' ) ; } }
3611	function writeLockFile ( path , data , cb ) { lock ( path , function ( unlock ) { fse . writeFile ( path , data , function ( e , d ) { unlock ( ) ; cb ( e , d ) ; } ) ; } ) ; }
723	function ( e ) { var self = this ; if ( ! self . isFocused || ! self . isOpen ) { self . focus ( ) ; e . preventDefault ( ) ; } }
2263	function ( o ) { function CreatedObject ( ) { } CreatedObject . prototype = o ; var tmp = new CreatedObject ( ) ; tmp . __proto__ = o ; return tmp ; }
1731	function _resolveNodeSize ( node ) { var localItemSize = itemSize ; if ( getItemSize ) { localItemSize = getItemSize ( node . renderNode , size ) ; } if ( ( localItemSize [ 0 ] === true ) || ( localItemSize [ 1 ] === true ) ) { var result = context . resolveSize ( node , size ) ; if ( localItemSize [ 0 ] !== true ) { result [ 0 ] = itemSize [ 0 ] ; } if ( localItemSize [ 1 ] !== true ) { result [ 1 ] = itemSize [ 1 ] ; } return result ; } else { return localItemSize ; } }
1887	function ( node ) { return ( this . hasTagsInContent ( node ) && this . isBlock ( node ) ) || _ . any ( node . children , function ( child ) { return this . isBlock ( child ) ; } , this ) ; }
73	function closest ( array , value ) { if ( ! is$1 . array ( array ) || ! array . length ) { return null ; } return array . reduce ( function ( prev , curr ) { return Math . abs ( curr - value ) < Math . abs ( prev - value ) ? curr : prev ; } ) ; }
272	function connectAccountOAuthInitComplete ( state = { } , action ) { return Object . assign ( { } , state , { isOAuthInitializing : false , error : action . error || '' , oauthUrl : action . oauthUrl || '' , } ) ; }
3348	function ( node , callback , scope , args ) { var me = this , reader , dataRoot , data , callbackArgs ; if ( node . isLoaded ( ) ) { callbackArgs = [ node . childNodes ] ; if ( args ) { callbackArgs . push . apply ( callbackArgs , args ) ; } Ext . callback ( callback , scope || node , callbackArgs ) ; } else if ( dataRoot = ( data = ( node . raw || node [ node . persistenceProperty ] ) [ ( reader = me . getProxy ( ) . getReader ( ) ) . root ] ) ) { me . fillNode ( node , reader . extractData ( dataRoot ) ) ; delete data [ reader . root ] ; callbackArgs = [ node . childNodes ] ; if ( args ) { callbackArgs . push . apply ( callbackArgs , args ) ; } Ext . callback ( callback , scope || node , callbackArgs ) ; } else if ( node . isLoading ( ) ) { me . on ( 'load' , function ( ) { callbackArgs = [ node . childNodes ] ; if ( args ) { callbackArgs . push . apply ( callbackArgs , args ) ; } Ext . callback ( callback , scope || node , callbackArgs ) ; } , me , { single : true } ) ; } else { me . read ( { node : node , callback : function ( ) { delete me . lastOptions . callback ; callbackArgs = [ node . childNodes ] ; if ( args ) { callbackArgs . push . apply ( callbackArgs , args ) ; } Ext . callback ( callback , scope || node , callbackArgs ) ; } } ) ; } }
1115	function robohydraHeadType ( settings ) { var parentClass = settings . parentClass || RoboHydraHead ; var newConstructorFunction = function ( props ) { if ( ! props && settings . defaultProps ) { deprecationWarning ( "deprecated 'defaultProps', please use 'defaultPropertyObject' instead" ) ; props = settings . defaultProps ; } props = props || settings . defaultPropertyObject || { } ; this . _importProperties ( newConstructorFunction , props ) ; var parentPropBuilder = settings . parentPropertyBuilder || function ( ) { return { } ; } ; if ( settings . parentPropBuilder ) { deprecationWarning ( "deprecated 'parentPropBuilder', please use 'parentPropertyBuilder' instead" ) ; parentPropBuilder = settings . parentPropBuilder ; } var parentProps = parentPropBuilder . call ( this ) ; IMPLICIT_OPTIONAL_PROPS . forEach ( function ( p ) { var propName = typeof p === 'object' ? p . name : p ; if ( ! ( propName in parentProps ) ) { parentProps [ propName ] = this [ propName ] ; } } , this ) ; parentClass . call ( this , parentProps ) ; this . type = settings . name || '<undefined>' ; if ( typeof settings . init === 'function' ) { settings . init . call ( this ) ; } } ; newConstructorFunction . mandatoryProperties = settings . mandatoryProperties || [ ] ; newConstructorFunction . optionalProperties = ( settings . optionalProperties || [ ] ) . concat ( IMPLICIT_OPTIONAL_PROPS ) ; newConstructorFunction . prototype = new parentClass ( ) ; return newConstructorFunction ; }
433	function omit ( originalObject , keys = [ ] ) { const newObject = { } ; for ( const key in originalObject ) { if ( keys . indexOf ( key ) >= 0 ) { continue ; } if ( ! Object . prototype . hasOwnProperty . call ( originalObject , key ) ) { continue ; } newObject [ key ] = originalObject [ key ] ; } return newObject ; }
2275	function ( next ) { var options = { type : ctx . type , count : ctx . count , now : ctx . now , nowISOString : ctx . nowISOString , params : { pk : Model . getIdName ( ) , id : ctx . params . id , relation : ctx . params . relation , custom : ctx . params . custom } } ; if ( ctx . type === 'model' ) { options . params . where = ctx . params . where ; options . params . range = ctx . params . range ; } new _queryBuilder2 . default ( options ) . onComplete ( next ) . build ( ) ; }
3344	function ( id , url ) { var ss ; CSS . removeStyleSheet ( id ) ; ss = doc . createElement ( "link" ) ; ss . setAttribute ( "rel" , "stylesheet" ) ; ss . setAttribute ( "type" , "text/css" ) ; ss . setAttribute ( "id" , id ) ; ss . setAttribute ( "href" , url ) ; doc . getElementsByTagName ( "head" ) [ 0 ] . appendChild ( ss ) ; }
3612	function callHandlers ( cults , e ) { var broken = false ; for ( var i = 0 ; i < cults . length ; i ++ ) { var cult = cults [ i ] ; var handlers = cult && cult . events && cult . events [ e . type ] ; if ( ! handlers ) continue ; var selectors = Object . keys ( handlers ) ; if ( callHandler ( cult , e , handlers , selectors ) === false ) { broken = true ; break ; } } return broken ; }
162	function updateFeaturedImagePreview ( image ) { const currentImageId = select ( 'core/editor' ) . getEditedPostAttribute ( 'featured_media' ) ; if ( currentImageId !== image . id ) { return ; } preloadImage ( image . url ) . then ( ( ) => { const currentImage = select ( 'core' ) . getMedia ( currentImageId ) ; const updatedImage = { ... currentImage , media_details : { height : image . height , width : image . width , } , source_url : image . url , } ; dispatch ( 'core' ) . receiveEntityRecords ( 'root' , 'media' , [ updatedImage ] , null , true ) ; } ) ; }
1808	function ( index ) { var range = this . _visibleRange ( ) , dm = this . metrics ( ) . rowDimensions ( index ) , maxY = dm . top + dm . height , minY = dm . top ; if ( maxY >= range . to ) { this . scrollableParent ( ) . scroll ( 0 , maxY - range . to + ( index === this . data ( ) . length - 1 ? 100 : 0 ) ) ; } else if ( minY < range . from ) { this . scrollableParent ( ) . scroll ( 0 , minY - range . from ) ; } this . _wrappedUpdate ( ) ; return this ; }
3262	function expandArgs ( val , match , safe ) { if ( Array . isArray ( val ) ) return val . slice ( 0 ) ; match = match || [ '"' , "'" ] ; safe = safe || [ '[' , ']' , '<' , '>' ] ; function replacer ( p , c ) { p . a [ p . a . length - 1 ] += c . replace ( / \\(.) / , '$1' ) ; } var all = safe . concat ( match ) ; var result = val . match ( / \\?.|^$ / g ) . reduce ( function ( p , c ) { if ( ~ all . indexOf ( c ) ) { p . quote ^= 1 ; if ( ~ safe . indexOf ( c ) ) replacer ( p , c ) ; } else if ( ! p . quote && c === ' ' ) p . a . push ( '' ) ; else replacer ( p , c ) ; return p ; } , { a : [ '' ] , e : false } ) . a ; return result ; }
3746	function save ( done ) { if ( process . browser ) return done ( ) ; fs . writeFile ( __dirname + '/../../data/filesystem.json' , JSON . stringify ( fileContents ) , function ( err ) { if ( done ) done ( err ) ; } ) ; }
3330	function ( ) { this . isUpdating = true ; var input = { typed : this . element . value , cursor : { start : dom . getSelectionStart ( this . element ) , end : dom . getSelectionEnd ( this . element . selectionEnd ) } } ; this . cli . update ( input ) ; var display = this . cli . getAssignmentAt ( input . cursor . start ) . getHint ( ) ; dom . removeCssClass ( this . completer , Status . VALID . toString ( ) ) ; dom . removeCssClass ( this . completer , Status . INCOMPLETE . toString ( ) ) ; dom . removeCssClass ( this . completer , Status . INVALID . toString ( ) ) ; var completion = '<span class="cptPrompt">&gt;</span> ' ; if ( this . element . value . length > 0 ) { var scores = this . cli . getInputStatusMarkup ( ) ; completion += this . markupStatusScore ( scores ) ; } if ( this . element . value . length > 0 && display . predictions && display . predictions . length > 0 ) { var tab = display . predictions [ 0 ] ; completion += ' &nbsp;&#x21E5; ' + ( tab . name ? tab . name : tab ) ; } this . completer . innerHTML = completion ; dom . addCssClass ( this . completer , this . cli . getWorstHint ( ) . status . toString ( ) ) ; var hint = '' ; if ( this . element . value . length !== 0 ) { hint += display . message ; if ( display . predictions && display . predictions . length > 0 ) { hint += ': [ ' ; display . predictions . forEach ( function ( prediction ) { hint += ( prediction . name ? prediction . name : prediction ) ; hint += ' | ' ; } , this ) ; hint = hint . replace ( / \| $ / , ']' ) ; } } this . hinter . innerHTML = hint ; if ( hint . length === 0 ) { dom . addCssClass ( this . hinter , 'cptNoPopup' ) ; } else { dom . removeCssClass ( this . hinter , 'cptNoPopup' ) ; } this . isUpdating = false ; }
40	function traceKitWindowOnError ( msg , url , lineNo , colNo , ex ) { var stack = null ; var exception = utils . isErrorEvent ( ex ) ? ex . error : ex ; var message = utils . isErrorEvent ( msg ) ? msg . message : msg ; if ( lastExceptionStack ) { TraceKit . computeStackTrace . augmentStackTraceWithInitialElement ( lastExceptionStack , url , lineNo , message ) ; processLastException ( ) ; } else if ( exception && utils . isError ( exception ) ) { stack = TraceKit . computeStackTrace ( exception ) ; notifyHandlers ( stack , true ) ; } else { var location = { url : url , line : lineNo , column : colNo } ; var name = undefined ; var groups ; if ( { } . toString . call ( message ) === '[object String]' ) { var groups = message . match ( ERROR_TYPES_RE ) ; if ( groups ) { name = groups [ 1 ] ; message = groups [ 2 ] ; } } location . func = UNKNOWN_FUNCTION ; stack = { name : name , message : message , url : getLocationHref ( ) , stack : [ location ] } ; notifyHandlers ( stack , true ) ; } if ( _oldOnerrorHandler ) { return _oldOnerrorHandler . apply ( this , arguments ) ; } return false ; }
2962	function recaptchaVerify ( req , res , action = 'form_submit' , cb , token = '' , threshold = 0.3 ) { const { zlSite } = res . locals ; if ( zlSite . user ) { cb ( ) ; } else { if ( ! token && 'POST' === req . method ) { token = req . body . recaptcha ; } if ( ! token ) { cb ( 'Token is required.' ) ; } else { request . post ( { url : 'https://www.google.com/recaptcha/api/siteverify' , json : true , form : { secret : req . app . locals . reCAPTCHAsecret , response : token , remoteip : req . ip } } , function ( error , response , body ) { if ( error ) { req . app . error ( error ) ; cb ( ) ; } else if ( body && body . success ) { if ( body . hostname !== req . hostname ) { cb ( ` ${ req . hostname } ${ body . hostname } ` ) ; } else if ( body . score < threshold ) cb ( 'score below threshold' ) ; else if ( action !== body . action ) { cb ( ` ${ action } ${ body . action } ` ) ; } else cb ( ) ; } else cb ( 'unknown error occurred' ) ; } ) ; } } }
2159	function locale_locales__getSetGlobalLocale ( key , values ) { var data ; if ( key ) { if ( typeof values === 'undefined' ) { data = locale_locales__getLocale ( key ) ; } else { data = defineLocale ( key , values ) ; } if ( data ) { globalLocale = data ; } } return globalLocale . _abbr ; }
64	function toggleClass ( element , className , force ) { if ( is$1 . nodeList ( element ) ) { return Array . from ( element ) . map ( function ( e ) { return toggleClass ( e , className , force ) ; } ) ; } if ( is$1 . element ( element ) ) { var method = 'toggle' ; if ( typeof force !== 'undefined' ) { method = force ? 'add' : 'remove' ; } element . classList [ method ] ( className ) ; return element . classList . contains ( className ) ; } return false ; }
2591	function choose ( n , k ) { if ( typeof n !== 'number' || typeof k !== 'number' ) return NaN ; if ( k === 0 ) return 1 ; return ( n * choose ( n - 1 , k - 1 ) ) / k ; }
214	function filterNoticesBy ( site , pluginSlug , log ) { if ( ! site && ! pluginSlug ) { return true ; } if ( isSameSiteNotice ( site , log ) && isSamePluginNotice ( pluginSlug , log ) ) { return true ; } else if ( ! pluginSlug && isSameSiteNotice ( site , log ) ) { return true ; } else if ( ! site && isSamePluginNotice ( pluginSlug , log ) ) { return true ; } return false ; }
701	function displayFormsForRelation ( pred , allowCreation ) { var sts = kb . statementsMatching ( subject , pred ) const outliner = panes . getOutliner ( dom ) if ( sts . length ) { for ( var i = 0 ; i < sts . length ; i ++ ) { outliner . appendPropertyTRs ( box , [ sts [ i ] ] ) var form = sts [ i ] . object var cell = dom . createElement ( 'td' ) box . lastChild . appendChild ( cell ) if ( allowCreation ) { cell . appendChild ( UI . widgets . newButton ( dom , kb , null , null , subject , form , store , function ( ok , body ) { if ( ok ) { } else complain ( 'Sorry, failed to save your change:\n' + \n ) } ) ) } body var formdef = kb . statementsMatching ( form , ns . rdf ( 'type' ) ) if ( ! formdef . length ) formdef = kb . statementsMatching ( form ) } if ( ! formdef . length ) complain ( 'No data about form' ) else { UI . widgets . editFormButton ( dom , box , form , formdef [ 0 ] . why , complainIfBad ) } } else box . appendChild ( dom . createElement ( 'hr' ) ) }
3782	function ReadCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; for ( var i = 0 ; i < parsed . args . length ; i ++ ) { var placeVar = parsed . args [ i ] ; if ( ! ( placeVar . child instanceof statements . VariableStatement || placeVar . child instanceof statements . FunctionStatement ) ) throw new SyntaxError ( 'Expected variable' ) ; } this . items = parsed . args ; }
3278	function getRequires ( file , options ) { return [ ... fileRequires ( file , options ) ] . map ( async ( moduleId ) => { if ( options . internalOnly && ( moduleId . charAt ( 0 ) !== '.' ) && ( moduleId . charAt ( 0 ) !== '/' ) ) { if ( options . mapper [ moduleId ] !== true ) return undefined ; } if ( options . mapper . hasOwnProperty ( moduleId ) && ! ( options . internalOnly && ( options . mapper [ moduleId ] === true ) ) ) { if ( options . mapper [ moduleId ] ) return resolveModule ( options . mapper [ moduleId ] , options ) ; return undefined ; } return resolveModule ( moduleId , options , path . dirname ( file . path ) ) ; } ) ; }
466	function checkWikipedia ( brands ) { Object . keys ( brands ) . forEach ( k => { [ 'brand:wikipedia' , 'operator:wikipedia' ] . forEach ( t => { let wp = brands [ k ] . tags [ t ] ; if ( wp && ! / ^[a-z_]{2,}:[^_]*$ / . test ( wp ) ) { _wrongFormat . push ( [ k , wp , t ] ) ; } } ) ; } ) ; }
3586	function createClient ( host , port , concurrent , frequency , duration , gen , iteration ) { var auth = defaults . auth var getMessage = defaults . getMessage emitter . emit ( 'start' ) if ( typeof gen . authenticate === 'function' ) { auth = gen . authenticate } if ( typeof gen . clientIterateMessage === 'function' ) { getMessage = gen . clientIterateMessage } var postAuth = function ( err , cookies , user , pass ) { ++ clientsAttempted if ( err ) { emitter . emit ( 'error' , err ) if ( clientsAttempted === concurrent && _intervals . length === 0 ) { emitter . emit ( 'end' ) } return } var socketUrl = gen . getSocketURL ( host , port , cookies , user , pass ) || host + ':' + port var socket = io ( socketUrl , { multiplex : false } ) . on ( 'connect' , function ( ) { emitter . emit ( 'client-connected' ) if ( typeof gen . events . connect === 'function' ) { gen . events . connect ( 'connect' , cookies , user , pass , { } , socket , emitter ) } Object . keys ( gen . events ) . forEach ( function ( eventName ) { socket . on ( eventName , function ( data ) { gen . events [ eventName ] . call ( null , eventName , cookies , user , pass , data , socket , emitter ) } ) } ) var sendMessage = function ( ) { var message = getMessage ( cookies , user , pass ) if ( ! Array . isArray ( message ) ) { message = [ message ] } for ( var i = 0 , len = message . length ; i < len ; i ++ ) { if ( message [ i ] ) { socket . json . send ( message [ i ] ) emitter . emit ( 'message' , message [ i ] ) } } } _intervals . push ( setInterval ( sendMessage , frequency ) ) setTimeout ( function ( ) { clearInterval ( _intervals . pop ( ) ) socket . emit ( 'disconnect' ) emitter . emit ( 'disconnect' ) socket . close ( ) if ( _intervals . length === 0 ) { done ( ) } } , duration ) } ) . on ( 'connect_error' , function ( err ) { emitter . emit ( 'error' , err ) if ( clientsAttempted === concurrent && _intervals . length === 0 ) { emitter . emit ( 'end' ) } } ) } auth ( host , port , iteration , postAuth ) }
3060	function parseExampleLine ( left , right , result ) { if ( ! left || ! right ) return false ; if ( right === 'setup' || right === 'teardown' ) { result [ right ] . push ( left ) ; } else { var test = { left : wrapEval ( left ) , title : ( left + ' // ' + right ) . replace ( / " / g , '\\"' ) } ; \\ if ( right === 'throws' ) { test . type = right ; test . right = '' ; } else { test . type = 'deepEqual' ; test . right = right ; } if ( RegExp ( matchIdentifierName ( 'done' ) ) . test ( left ) ) { test . type += 'Async' ; } } result . tests . push ( test ) ; }
2489	function doSubmit ( ) { var t = $form . attr ( 'target' ) , a = $form . attr ( 'action' ) ; form . setAttribute ( 'target' , id ) ; if ( form . getAttribute ( 'method' ) != 'POST' ) { form . setAttribute ( 'method' , 'POST' ) ; } if ( form . getAttribute ( 'action' ) != s . url ) { form . setAttribute ( 'action' , s . url ) ; } if ( ! s . skipEncodingOverride ) { $form . attr ( { encoding : 'multipart/form-data' , enctype : 'multipart/form-data' } ) ; } if ( s . timeout ) { setTimeout ( function ( ) { timedOut = true ; cb ( ) ; } , s . timeout ) ; } var extraInputs = [ ] ; try { if ( s . extraData ) { for ( var n in s . extraData ) { extraInputs . push ( $ ( '<input type="hidden" name="' + n + '" value="' + s . extraData [ n ] + '" />' ) . appendTo ( form ) [ 0 ] ) ; } } $io . appendTo ( 'body' ) ; $io . data ( 'form-plugin-onload' , cb ) ; form . submit ( ) ; } finally { form . setAttribute ( 'action' , a ) ; if ( t ) { form . setAttribute ( 'target' , t ) ; } else { $form . removeAttr ( 'target' ) ; } $ ( extraInputs ) . remove ( ) ; } }
2896	function homedir ( username ) { return username ? path . resolve ( path . dirname ( home ) , username ) : home ; }
2857	function basePullAt ( array , indexes ) { var length = array ? indexes . length : 0 , lastIndex = length - 1 ; while ( length -- ) { var index = indexes [ length ] ; if ( length == lastIndex || index !== previous ) { var previous = index ; if ( isIndex ( index ) ) { splice . call ( array , index , 1 ) ; } else if ( ! isKey ( index , array ) ) { var path = castPath ( index ) , object = parent ( array , path ) ; if ( object != null ) { delete object [ toKey ( last ( path ) ) ] ; } } else { delete array [ toKey ( index ) ] ; } } } return array ; }
3814	function ( ) { this . mapping = this . buildPolicyMap ( ) ; _bindPolicies ( this . mapping , sails . middleware . controllers ) ; sails . log . verbose ( 'Policy-controller bindings complete!' ) ; sails . emit ( 'hook:policies:bound' ) ; }
2816	function ( obj ) { if ( obj == null || typeof obj != 'object' || Object . isFrozen ( obj ) || obj . _keepHot ) return ; Object . freeze ( obj ) ; for ( var key in obj ) { if ( obj . hasOwnProperty ( key ) ) deepFreeze ( obj [ key ] ) ; } }
3081	function ( walk ) { if ( this . emitText ( walk ) ) return ; if ( this . tryInputText ( walk ) ) return ; if ( this . tryInputRegex ( walk ) ) return ; if ( this . tryInputTextWithDefault ( walk ) ) return ; if ( this . trySelectMenu ( walk ) ) return ; var _super = InlineCompiler . prototype . emitNormal . bind ( this ) ; return _super ( walk ) ; }
832	function generateComponentName ( fileName ) { const bareName = fileName . replace ( / \.html$ / , '' ) . replace ( / [._] / g , '' ) ; return bareName . charAt ( 0 ) . toUpperCase ( ) + bareName . substr ( 1 ) + 'Component' ; }
366	function isModifierEnabled ( modifiers , modifierName ) { return modifiers . some ( function ( _ref ) { var name = _ref . name , enabled = _ref . enabled ; return enabled && name === modifierName ; } ) ; }
1107	function ( el , ordinal , func ) { var options = $ ( el ) . data ( 'popupoptions' ) ; var openelement ; var elementclicked ; if ( typeof options === 'undefined' ) return ; openelement = options . openelement ? options . openelement : ( '.' + el . id + opensuffix ) ; elementclicked = $ ( openelement + '[data-popup-ordinal="' + ordinal + '"]' ) ; if ( typeof func == 'function' ) { func . call ( $ ( el ) , el , elementclicked ) ; } }
712	function optOnIconMouseDownListener ( e ) { var target = thisOutline . targetOf ( e ) var p = target . parentNode termWidget . replaceIcon ( p . parentNode , outlineIcons . termWidgets . optOn , outlineIcons . termWidgets . optOff , optOffIconMouseDownListener ) p . parentNode . parentNode . removeAttribute ( 'optional' ) }
984	function initJsProcessor ( opts , defaultBabelProcessorName ) { let plugins = ( opts && opts . plugins ) || [ adapterPlugin ] ; registerProcessor ( { name : ( opts && opts . processor ) || defaultBabelProcessorName , hook : { before ( file , options ) { if ( file . isAntCompScript && ! adapterPlugin . isAdapterModule ( file . path ) ) { options . plugins || ( options . plugins = [ ] ) ; options . plugins . push . apply ( options . plugins , plugins ) ; } } } } ) ; }
2299	function getRenderedTemplate ( template , data , variableRegex ) { return template . replace ( variableRegex , ( match , captured ) => { const replacement = valueForProperty ( data , captured . trim ( ) ) ; if ( replacement == null ) { return '' ; } if ( typeof replacement === 'function' ) { return replacement ( ) ; } return replacement ; } ) ; }
3779	async function empty ( source ) { var e_34 , _a ; let i = 0 ; try { for ( var source_5 = __asyncValues ( source ) , source_5_1 ; source_5_1 = await source_5 . next ( ) , ! source_5_1 . done ; ) { const it = source_5_1 . value ; return false ; } } catch ( e_34_1 ) { e_34 = { error : e_34_1 } ; } finally { try { if ( source_5_1 && ! source_5_1 . done && ( _a = source_5 . return ) ) await _a . call ( source_5 ) ; } finally { if ( e_34 ) throw e_34 . error ; } } return true ; }
2543	function createRecurry ( func , bitmask , wrapFunc , placeholder , thisArg , partials , holders , argPos , ary , arity ) { var isCurry = bitmask & CURRY_FLAG , newHolders = isCurry ? holders : undefined , newHoldersRight = isCurry ? undefined : holders , newPartials = isCurry ? partials : undefined , newPartialsRight = isCurry ? undefined : partials ; bitmask |= ( isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG ) ; bitmask &= ~ ( isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG ) ; if ( ! ( bitmask & CURRY_BOUND_FLAG ) ) { bitmask &= ~ ( BIND_FLAG | BIND_KEY_FLAG ) ; } var result = wrapFunc ( func , bitmask , thisArg , newPartials , newHolders , newPartialsRight , newHoldersRight , argPos , ary , arity ) ; result . placeholder = placeholder ; return setWrapToString ( result , func , bitmask ) ; }
1636	function ( el ) { this . el = el if ( typeof el . classList !== 'undefined' ) { this . old = false } else { this . classList = new nativeClasList ( el ) this . old = true } }
552	function walk ( args ) { args . node . forEach ( function ( item , i ) { var name = args . selector ( item ) ; var namespace = args . namespaceSelector && makeNamespace ( args . namespaceSelector ( item ) ) ; var extraSymbols = args . getExtraSymbols ( args . node , i ) ; var info = name && getPrefixInfo ( name , namespace , extraSymbols ) ; if ( ! info ) return ; args . payload ( info , i ) ; } ) ; }
1141	function sample ( collection , n , guard ) { var length = collection ? collection . length : 0 ; if ( typeof length != 'number' ) { collection = values ( collection ) ; } if ( n == null || guard ) { return collection ? collection [ random ( length - 1 ) ] : undefined ; } var result = shuffle ( collection ) ; result . length = nativeMin ( nativeMax ( 0 , n ) , result . length ) ; return result ; }
2860	function forInRight ( object , iteratee ) { return object == null ? object : baseForRight ( object , baseIteratee ( iteratee , 3 ) , keysIn ) ; }
3152	function getWriteFunction ( log ) { return function writeLogFile ( name , qcb ) { var dir = path . join ( LOG_DIR , name ) ; function readFile ( cb ) { fs . readFile ( dir , cb ) ; } function updateLogs ( logs , cb ) { logs . push ( log . toJSON ( ) ) ; cb ( null , logs ) ; } function writeFile ( str , cb ) { fs . writeFile ( dir , str , cb ) ; } async . waterfall ( [ readFile , safejson . parse , updateLogs , safejson . stringify , writeFile ] , qcb ) ; } ; }
2398	function parse ( report ) { var system = report [ 'system' ] || { } ; var crash = report [ 'crash' ] || { } ; return [ '' , 'Extra Information:' ] . concat ( parse_nsexception ( crash ) , parse_crash_thread ( report ) , parse_last_exception ( report ) , parse_diagnosis ( crash ) , parse_recrash ( report ) ) ; }
2756	function serializeSpan ( span , serializers , index , options ) { if ( span === '\n' && \n ) serializers . hardBreak { return h ( serializers . hardBreak , { key : ` ${ index } ` } ) } if ( typeof span === 'string' ) { return serializers . text ? h ( serializers . text , { key : ` ${ index } ` } , span ) : span } let children if ( span . children ) { children = { children : span . children . map ( ( child , i ) => options . serializeNode ( child , i , span . children , true ) ) } } const serializedNode = objectAssign ( { } , span , children ) }
1399	function TransformStreamCloseReadable ( transformStream ) { if ( transformStream . _errored === true ) { throw new TypeError ( 'TransformStream is already errored' ) ; } if ( transformStream . _readableClosed === true ) { throw new TypeError ( 'Readable side is already closed' ) ; } TransformStreamCloseReadableInternal ( transformStream ) ; }
1075	function initMatic ( ) { if ( ! matic ) { matic = new Matic ( { maticProvider : process . env . MATIC_PROVIDER , parentProvider : process . env . PARENT_PROVIDER , rootChainAddress : process . env . ROOTCHAIN_ADDRESS , maticWethAddress : process . env . MATIC_WETH_ADDRESS , syncerUrl : process . env . SYNCER_URL , watcherUrl : process . env . WATCHER_URL , withdrawManagerAddress : process . env . WITHDRAWMANAGER_ADDRESS , } ) matic . wallet = '<private-key>' } }
2852	function createHybrid ( func , bitmask , thisArg , partials , holders , partialsRight , holdersRight , argPos , ary , arity ) { var isAry = bitmask & ARY_FLAG , isBind = bitmask & BIND_FLAG , isBindKey = bitmask & BIND_KEY_FLAG , isCurried = bitmask & ( CURRY_FLAG | CURRY_RIGHT_FLAG ) , isFlip = bitmask & FLIP_FLAG , Ctor = isBindKey ? undefined : createCtor ( func ) ; function wrapper ( ) { var length = arguments . length , args = Array ( length ) , index = length ; while ( index -- ) { args [ index ] = arguments [ index ] ; } if ( isCurried ) { var placeholder = getHolder ( wrapper ) , holdersCount = countHolders ( args , placeholder ) ; } if ( partials ) { args = composeArgs ( args , partials , holders , isCurried ) ; } if ( partialsRight ) { args = composeArgsRight ( args , partialsRight , holdersRight , isCurried ) ; } length -= holdersCount ; if ( isCurried && length < arity ) { var newHolders = replaceHolders ( args , placeholder ) ; return createRecurry ( func , bitmask , createHybrid , wrapper . placeholder , thisArg , args , newHolders , argPos , ary , arity - length ) ; } var thisBinding = isBind ? thisArg : this , fn = isBindKey ? thisBinding [ func ] : func ; length = args . length ; if ( argPos ) { args = reorder ( args , argPos ) ; } else if ( isFlip && length > 1 ) { args . reverse ( ) ; } if ( isAry && ary < length ) { args . length = ary ; } if ( this && this !== root && this instanceof wrapper ) { fn = Ctor || createCtor ( fn ) ; } return fn . apply ( thisBinding , args ) ; } return wrapper ; }
816	function script_executed ( registry_item ) { registry_item . ready = registry_item . finished = true ; for ( var i = 0 ; i < registry_item . finished_listeners . length ; i ++ ) { registry_item . finished_listeners [ i ] ( ) ; } registry_item . ready_listeners = [ ] ; registry_item . finished_listeners = [ ] ; }
160	function handlePostLockTakeover ( calypsoPort ) { const unsubscribe = subscribe ( ( ) => { const isLocked = select ( 'core/editor' ) . isPostLocked ( ) ; const isLockTakeover = select ( 'core/editor' ) . isPostLockTakeover ( ) ; const allPostsButton = document . querySelector ( 'div.editor-post-locked-modal__buttons > a' ) ; const isPostTakeoverDialog = isLocked && isLockTakeover && allPostsButton ; if ( isPostTakeoverDialog ) { allPostsButton . addEventListener ( 'click' , event => { event . preventDefault ( ) ; calypsoPort . postMessage ( { action : 'goToAllPosts' } ) ; } , false ) ; if ( calypsoifyGutenberg && calypsoifyGutenberg . closeUrl ) { allPostsButton . setAttribute ( 'target' , '_parent' ) ; allPostsButton . setAttribute ( 'href' , calypsoifyGutenberg . closeUrl ) ; } unsubscribe ( ) ; } } ) ; }
601	function ( participle , sentencePart , attributes ) { Participle . call ( this , participle , sentencePart , attributes ) ; this . setSentencePartPassiveness ( this . isPassive ( ) ) ; }
216	function scrollIntoViewport ( element ) { const elementStartY = recursivelyWalkAndSum ( element , 'offsetTop' , 'offsetParent' ) , elementEndY = elementStartY + element . offsetHeight ; if ( isInViewportRange ( elementStartY , elementEndY ) ) { return ; } try { window . scroll ( { top : elementStartY , left : 0 , behavior : 'smooth' , } ) ; } catch ( e ) { window . scrollTo ( 0 , elementStartY ) ; } }
2847	function rowgroup ( items , name ) { return items . map ( ( [ htmlterm , ariaterm ] , i ) => { htmlcount += htmlterm . split ( ', ' ) . length ariacount += ariaterm . split ( ', ' ) . length return tr ( [ ! i && th ( { rowSpan : items . length , children : name , } ) , td ( htmlterm ) , td ( ariaterm ) ] ) } ) }
2904	function printOutput ( message ) { process . stdout . on ( 'error' , err => { if ( err . code === 'EPIPE' ) { } } ) arrayify ( message ) . forEach ( function ( msg ) { console . log ( ansi . format ( msg ) ) } ) }
1009	function metaTitleFromFileName ( filename ) { if ( filename . substr ( - 1 ) === '/' ) { filename = filename . substr ( 0 , filename . length - 1 ) ; } return decodeURIComponent ( filename ) ; }
2181	function Barcode1D ( ) { this . mode = MODE_BARWIDTH ; this . width = 0 ; this . height = 0 ; this . background = '#FFF' ; this . barcolor = '#000' ; this . type = 'PNG' ; this . offset = 0 ; this . modulewidth = 1 ; }
461	function fillData ( props , datasets ) { const { fillInMissingData } = props ; const xMap = datasets . reduce ( ( prev , dataset ) => { dataset . forEach ( ( datum ) => { prev [ datum . _x instanceof Date ? datum . _x . getTime ( ) : datum . _x ] = true ; } ) ; return prev ; } , { } ) ; const xKeys = keys ( xMap ) . map ( ( k ) => + k ) ; const xArr = orderBy ( xKeys ) ; return datasets . map ( ( dataset ) => { let indexOffset = 0 ; const isDate = dataset [ 0 ] && dataset [ 0 ] . _x instanceof Date ; const filledInData = xArr . map ( ( x , index ) => { x = + x ; const datum = dataset [ index - indexOffset ] ; if ( datum ) { const x1 = isDate ? datum . _x . getTime ( ) : datum . _x ; if ( x1 === x ) { return datum ; } else { indexOffset ++ ; const y = fillInMissingData ? 0 : null ; x = isDate ? new Date ( x ) : x ; return { x , y , _x : x , _y : y } ; } } else { const y = fillInMissingData ? 0 : null ; x = isDate ? new Date ( x ) : x ; return { x , y , _x : x , _y : y } ; } } ) ; return filledInData ; } ) ; }
3495	function isNodeFirstInLine ( node , byEndLocation ) { var firstToken = byEndLocation === true ? context . getLastToken ( node , 1 ) : context . getTokenBefore ( node ) , startLine = byEndLocation === true ? node . loc . end . line : node . loc . start . line , endLine = firstToken ? firstToken . loc . end . line : - 1 ; return startLine !== endLine ; }
3022	function ( table , config ) { config = Ext . apply ( { } , config ) ; table = this . table = Ext . get ( table ) ; var configFields = config . fields || [ ] , configColumns = config . columns || [ ] , fields = [ ] , cols = [ ] , headers = table . query ( "thead th" ) , i = 0 , len = headers . length , data = table . dom , width , height , store , col , text , name ; for ( ; i < len ; ++ i ) { col = headers [ i ] ; text = col . innerHTML ; name = 'tcol-' + i ; fields . push ( Ext . applyIf ( configFields [ i ] || { } , { name : name , mapping : 'td:nth(' + ( i + 1 ) + ')/@innerHTML' } ) ) ; cols . push ( Ext . applyIf ( configColumns [ i ] || { } , { text : text , dataIndex : name , width : col . offsetWidth , tooltip : col . title , sortable : true } ) ) ; } if ( config . width ) { width = config . width ; } else { width = table . getWidth ( ) + 1 ; } if ( config . height ) { height = config . height ; } Ext . applyIf ( config , { store : { data : data , fields : fields , proxy : { type : 'memory' , reader : { record : 'tbody tr' , type : 'xml' } } } , columns : cols , width : width , height : height } ) ; this . callParent ( [ config ] ) ; if ( config . remove !== false ) { data . parentNode . removeChild ( data ) ; } }
2842	function end ( ) { try { this . queue ( transformCss ( filePath , data , opts ) ) ; } catch ( err ) { this . emit ( "error" , new Error ( err ) ) ; } this . queue ( null ) ; }
671	function ( sentence , twoPartTransitionWords ) { sentence = normalizeSingleQuotes ( sentence ) ; const twoPartTransitionWordsRegex = getRegexFromDoubleArray ( twoPartTransitionWords ) ; return sentence . match ( twoPartTransitionWordsRegex ) ; }
2970	function RecursiveConcat ( options ) { this . concat = null ; this . currentCountDirectories = 0 ; this . currentCountFiles = 0 ; this . currentFolder = null ; this . newFileGenerated = null ; this . newFinalFile = "" ; this . options = options ; this . walkCounter = 0 ; this . stream = new Transform ( { objectMode : true } ) ; this . stream . _transform = function ( chunk , encoding , callback ) { var fullPath = null , file = { } , relative = chunk . relative ; file . base = chunk . base ; file . contents = chunk . contents ; file . extname = Path . extname ( relative ) ; file . basename = Path . basename ( relative , file . extname ) ; file . dirname = Path . dirname ( relative ) ; file . newDirname = utils . fixDirName ( file . dirname ) ; fullPath = file . newDirname + file . basename + file . extname ; file . path = Path . join ( chunk . base , fullPath ) ; if ( ! file . relative ) { file . relative = relative ; } callback ( null , self . walk ( file ) ) ; } ; var self = this ; return this . stream ; }
1290	function ArrayFindIndex ( predicate , thisArg ) { CHECK_OBJECT_COERCIBLE ( this , "Array.prototype.findIndex" ) ; var array = TO_OBJECT ( this ) ; var length = TO_INTEGER ( array . length ) ; return InnerArrayFindIndex ( predicate , thisArg , array , length ) ; }
3480	function renderBlockOnIE ( block ) { var oldRng ; if ( tinymce . isIE && dom . isBlock ( block ) ) { oldRng = selection . getRng ( ) ; block . appendChild ( dom . create ( 'span' , null , '\u00a0' ) ) ; \u00a0 selection . select ( block ) ; block . lastChild . outerHTML = '' ; } }
2951	function curry ( fn ) { return function resolver ( ) { for ( var _len = arguments . length , resolverArgs = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { resolverArgs [ _key ] = arguments [ _key ] ; } return function ( ) { for ( var _len2 = arguments . length , args = Array ( _len2 ) , _key2 = 0 ; _key2 < _len2 ; _key2 ++ ) { args [ _key2 ] = arguments [ _key2 ] ; } var nextArgs = resolverArgs . concat ( args . length ? args : null ) ; var next = nextArgs . length >= fn . length ? fn : resolver ; return next . apply ( undefined , toConsumableArray ( nextArgs ) ) ; } ; } ( ) ; }
129	function setupIMA ( ) { this . elements . container = createElement ( 'div' , { class : this . player . config . classNames . ads } ) ; this . player . elements . container . appendChild ( this . elements . container ) ; google . ima . settings . setVpaidMode ( google . ima . ImaSdkSettings . VpaidMode . ENABLED ) ; google . ima . settings . setLocale ( this . player . config . ads . language ) ; google . ima . settings . setDisableCustomPlaybackForIOS10Plus ( this . player . config . playsinline ) ; this . elements . displayContainer = new google . ima . AdDisplayContainer ( this . elements . container , this . player . media ) ; this . requestAds ( ) ; }
558	function ( face ) { if ( face . outside !== null ) { var start = face . outside ; var end = face . outside ; while ( end . next !== null && end . next . face === face ) { end = end . next ; } this . assigned . removeSubList ( start , end ) ; start . prev = end . next = null ; face . outside = null ; return start ; } }
1190	function ( type ) { var qp = { error : type , state : props . state } ; res . redirect ( props . redirect_uri + "?" + qs . stringify ( qp ) ) ; }
666	function ( keyphrase , synonyms , language = "en" , morphologyData ) { const synonymsSplit = parseSynonyms ( synonyms ) ; const keyphraseForms = buildForms ( keyphrase , language , morphologyData ) ; const synonymsForms = synonymsSplit . map ( synonym => buildForms ( synonym , language , morphologyData ) ) ; return { keyphraseForms : keyphraseForms , synonymsForms : synonymsForms , } ; }
2391	function thisToArgs ( that , args ) { args = Array . prototype . slice . call ( args , 0 ) ; args . unshift ( that ) ; return args ; }
353	function render ( element ) { connectDevtools ( DesktopRenderer ) ; ROOT_NODE = createElement ( 'ROOT' ) ; const container = ROOT_NODE ; const node = DesktopRenderer . createContainer ( ROOT_NODE ) ; DesktopRenderer . updateContainer ( element , node , null ) ; }
1356	function serializeMethods ( o ) { var v ; for ( var k in o ) { v = o [ k ] ; if ( _ . isObject ( v ) && ! _ . isArray ( v ) && ! _ . isFunction ( v ) ) { serializeMethods ( v ) ; } else { o [ k ] = serializeFunctions ( v ) ; } } }
3541	function configure ( pkg , env , target ) { const isModule = target === 'module' ; const input = ` ` ; const deps = [ ] . concat ( pkg . dependencies ? Object . keys ( pkg . dependencies ) : [ ] ) . concat ( pkg . peerDependencies ? Object . keys ( pkg . peerDependencies ) : [ ] ) ; const plugins = [ resolve ( { browser : true } ) , json ( ) , replace ( { 'process.env.NODE_ENV' : JSON . stringify ( env ) } ) , builtins ( ) , babel ( { include : [ ` ` ] } ) , globals ( ) ] . filter ( Boolean ) ; if ( isModule ) { return { plugins , input , output : [ { file : ` ${ pkg . module } ` , format : 'es' , sourcemap : true } , { file : ` ${ pkg . main } ` , format : 'cjs' , exports : 'named' , sourcemap : true } ] , external : id => ! ! deps . find ( dep => dep === id || id . startsWith ( ` ${ dep } ` ) ) } ; } return undefined ; }
821	function chain_script_ready ( script_obj , exec_trigger ) { if ( chain_opts [ _Debug ] ) log_msg ( "script preload finished: " + script_obj . real_src ) ; script_obj . ready = true ; script_obj . exec_trigger = function ( ) { if ( chain_opts [ _Debug ] ) log_msg ( "script execute start: " + script_obj . real_src ) ; exec_trigger ( ) ; } advance_exec_cursor ( ) ; }
561	function ( ) { var min = new THREE . Vector3 ( ) ; var max = new THREE . Vector3 ( ) ; var minVertices = [ ] ; var maxVertices = [ ] ; var i , l , j ; for ( i = 0 ; i < 3 ; i ++ ) { minVertices [ i ] = maxVertices [ i ] = this . vertices [ 0 ] ; } min . copy ( this . vertices [ 0 ] . point ) ; max . copy ( this . vertices [ 0 ] . point ) ; for ( i = 0 , l = this . vertices . length ; i < l ; i ++ ) { var vertex = this . vertices [ i ] ; var point = vertex . point ; for ( j = 0 ; j < 3 ; j ++ ) { if ( point . getComponent ( j ) < min . getComponent ( j ) ) { min . setComponent ( j , point . getComponent ( j ) ) ; minVertices [ j ] = vertex ; } } for ( j = 0 ; j < 3 ; j ++ ) { if ( point . getComponent ( j ) > max . getComponent ( j ) ) { max . setComponent ( j , point . getComponent ( j ) ) ; maxVertices [ j ] = vertex ; } } } this . tolerance = 3 * Number . EPSILON * ( Math . max ( Math . abs ( min . x ) , Math . abs ( max . x ) ) + Math . max ( Math . abs ( min . y ) , Math . abs ( max . y ) ) + Math . max ( Math . abs ( min . z ) , Math . abs ( max . z ) ) ) ; return { min : minVertices , max : maxVertices } ; }
354	function whitespace ( rule , value , source , errors , options ) { if ( / ^\s+$ / . test ( value ) || value === '' ) { errors . push ( util . format ( options . messages . whitespace , rule . fullField ) ) ; } }
2064	function ( elem , eventName , callback ) { var listener = function ( event ) { event = event || window . event ; var target = event . target || event . srcElement ; var block = callback . apply ( elem , [ event , target ] ) ; if ( block === false ) { if ( ! ! event . preventDefault ) event . preventDefault ( ) ; else { event . returnValue = false ; event . cancelBubble = true ; } } return block ; } ; if ( elem . attachEvent ) { elem . attachEvent ( "on" + eventName , listener ) ; } else { elem . addEventListener ( eventName , listener , false ) ; } return listener ; }
3438	function ( xpath ) { var me = this , parts = xpath . split ( '/' ) , regex = me . tagPathRegEx , i , n , m , count , tag , child , el = me . attachTo . document ; el = ( parts [ 0 ] == '~' ) ? el . body : el . getElementById ( parts [ 0 ] . substring ( 1 ) ) ; for ( i = 1 , n = parts . length ; el && i < n ; ++ i ) { m = regex . exec ( parts [ i ] ) ; count = m [ 2 ] ? parseInt ( m [ 2 ] , 10 ) : 1 ; tag = m [ 1 ] . toUpperCase ( ) ; for ( child = el . firstChild ; child ; child = child . nextSibling ) { if ( child . tagName == tag ) { if ( count == 1 ) { break ; } -- count ; } } el = child ; } return el ; }
2683	function moduleCommand ( shell , args , data , evaluationId ) { var deferred = shell . runtime . q . defer ( ) ; installer . install ( args . name , shell . config . userPath , false , function ( error ) { if ( error ) { deferred . reject ( shell . createError ( 'Could not install module' ) ) ; } else { shell . installedModules [ args . name ] = true ; deferred . resolve ( ) ; } } ) ; return deferred . promise ; }
659	function ( word , locale ) { var fullWordDeviations = syllableMatchers ( locale ) . deviations . words . full ; var deviation = find ( fullWordDeviations , function ( fullWordDeviation ) { return fullWordDeviation . word === word ; } ) ; if ( ! isUndefined ( deviation ) ) { return deviation . syllables ; } return 0 ; }
1025	function ( eventName , handler ) { this . _validateEvent ( eventName ) ; var hl = this . _handlers [ eventName ] . length ; for ( var i = 0 ; i < hl ; i ++ ) { if ( this . _handlers [ eventName ] [ i ] === handler ) { this . _handlers [ eventName ] . splice ( i , 1 ) ; return ; } } }
1260	function destroySync ( component , removeNode = true ) { syncDestructionsInProgressCounter ++ destroyChildComponents ( component . virtualNode ) if ( syncDestructionsInProgressCounter === 1 && removeNode ) component . element . remove ( ) syncDestructionsInProgressCounter -- }
2692	function readMessage ( socketData , signer ) { var identities = socketData [ 0 ] ; var signature = socketData [ 2 ] . toString ( ) ; var header = socketData [ 3 ] ; var parentHeader = socketData [ 4 ] ; var metadata = socketData [ 5 ] ; var content = socketData [ 6 ] ; if ( ! signer . validate ( signature , [ header , parentHeader , metadata , content ] ) ) { return null ; } return createMessage ( identities , JSON . parse ( header ) , JSON . parse ( parentHeader ) , JSON . parse ( metadata ) , JSON . parse ( content ) ) ; }
3225	function ( o ) { var me = this ; o . un ( { scope : me , mousedown : me . onMouseDown , mouseup : me . onMouseUp , mouseover : me . onMouseOver , mouseout : me . onMouseOut , click : me . onClick } ) ; return me . callParent ( arguments ) ; }
1340	function install ( name , algorithm ) { if ( typeof name !== 'string' || name === '' ) { throw new TypeError ( 'The algorithm name must be an non-empty string.' ) ; } if ( typeof algorithm !== 'object' || algorithm === null || Array . isArray ( algorithm ) ) { throw new TypeError ( 'The algorithm object must be an object.' ) ; } if ( typeof algorithm . hash !== 'function' ) { throw new TypeError ( 'The hash property of the algorithm object should be a function.' ) ; } if ( typeof algorithm . verify !== 'function' ) { throw new TypeError ( 'The verify property of the algorithm object should be a function.' ) ; } if ( typeof algorithm . identifiers !== 'function' ) { throw new TypeError ( 'The identifiers property of the algorithm object should be a function.' ) ; } if ( funcs [ name ] !== undefined ) { throw new TypeError ( ` ${ name } ` ) ; } const idfs = algorithm . identifiers ( ) ; for ( const an of queue ) { if ( funcs [ an ] . identifiers ( ) . some ( idf => idfs . indexOf ( idf ) !== - 1 ) ) { throw new Error ( 'The identifiers property of the algorithm object clashes with the ones of another algorithm.' ) ; } } funcs [ name ] = Object . assign ( { } , algorithm ) ; Object . freeze ( funcs [ name ] ) ; queue . push ( name ) ; }
2437	function observeResize ( el , cb ) { assert . ok ( isDom ( el ) , 'observe-resize: el should be a valid DOM element' ) assert . equal ( typeof cb , 'function' , 'observe-resize: cb should be type function' ) if ( typeof window !== 'object' ) return var called = false var frame = document . createElement ( 'iframe' ) frame . setAttribute ( 'class' , '__observe-resize__' ) el . appendChild ( frame ) assert . ok ( frame . contentWindow , 'observe-resize: no contentWindow detected - cannot start observing' ) frame . contentWindow . onresize = handleResize return function stopObserving ( ) { if ( frame . parentNode ) frame . parentNode . removeChild ( frame ) } function handleResize ( ) { if ( called ) return called = true window . requestAnimationFrame ( function ( ) { called = false cb ( el ) } ) } }
877	function get ( option ) { if ( option && option . resolvePaths && Array . isArray ( option . resolvePaths ) ) { return option . resolvePaths . map ( String ) } return null }
2609	function random ( o ) { if ( typeof o === 'object' ) { return o instanceof Array ? o [ Math . floor ( Math . random ( ) * o . length ) ] : o [ Object . keys ( o ) [ Math . floor ( Math . random ( ) * Object . keys ( o ) . length ) ] ] ; } else if ( typeof o === 'string' || typeof o === 'number' ) { var val = o , negative = false ; if ( o . length === 0 ) return '' ; if ( typeof o === 'number' && o < 0 ) { negative = true ; val = Math . abs ( val ) ; } val = val . toString ( ) [ Math . floor ( Math . random ( ) * val . toString ( ) . length ) ] ; if ( typeof o === 'number' ) val = parseInt ( val , 10 ) ; return negative ? - val : val ; } return o ; }
2757	function ( ) { var el = this . el ; this . lastPosition = el . getAttribute ( 'position' ) ; this . lastRotation = el . getAttribute ( 'rotation' ) ; this . lastScale = el . getAttribute ( 'scale' ) ; this . lerpingPosition = false ; this . lerpingRotation = false ; this . lerpingScale = false ; this . timeOfLastUpdate = 0 ; }
393	function filterEmptyAtRules ( css ) { css . walkAtRules ( ( atRule ) => { if ( atRule . name === 'media' && atRule . nodes . length === 0 ) { atRule . remove ( ) ; } } ) ; }
2245	function stringEscape ( str ) { let stringArray = str . toString ( ) . split ( '' ) ; for ( let j = 0 ; j < stringArray . length ; j ++ ) { for ( let i = 0 ; i < escapeArray . length ; i ++ ) { if ( stringArray [ j ] === escapeArray [ i ] ) { stringArray [ j ] = '\\' + \\ ; } } } escapeArray [ i ] }
1445	function ( node ) { var old = this . __scope ; var scope = this . __scope = this . __scope . parent ; var unresolved = scope . unresolved ; for ( var name in old . unresolved ) { var entry = unresolved [ name ] ; if ( ! entry ) { entry = unresolved [ name ] = { name : name , locations : [ ] } ; } entry . locations . push . apply ( entry . locations , old . unresolved [ name ] . locations ) ; } }
609	function splitOnWords ( sentence , stopwords ) { const splitSentences = [ ] ; forEach ( stopwords , function ( stopword ) { const sentenceSplit = sentence . split ( stopword ) ; if ( ! isEmpty ( sentenceSplit [ 0 ] ) ) { splitSentences . push ( sentenceSplit [ 0 ] ) ; } const startIndex = sentence . indexOf ( stopword ) ; const endIndex = sentence . length ; sentence = stripSpaces ( sentence . substr ( startIndex , endIndex ) ) ; } ) ; splitSentences . push ( sentence ) ; return splitSentences ; }
2409	function deleteBackup ( config ) { return new Promise ( ( resolve , reject ) => { const backupPath = path . join ( process . cwd ( ) , ( config . backup !== undefined ) ? config . backup : ".backup" ) ; fs . remove ( backupPath , ( error ) => { ( error === null ) ? resolve ( config ) : reject ( error ) ; } ) ; } ) ; }
2759	function ( datamodel , variables ) { traverse ( datamodel ) . forEach ( function ( path ) { if ( this . isLeaf && objectPath . has ( variables , path ) ) { this . update ( objectPath . get ( variables , path ) ) ; } } ) ; return datamodel ; }
958	function parseEventName ( name , element , tplOpts , opts ) { let eventAttrName = name . replace ( EVENT_REGEXP , '' ) ; let [ eventType , ... eventModifiers ] = eventAttrName . split ( '.' ) ; let eventMode = 'on' ; eventType = transformMiniProgramEventType ( element , eventType , opts ) ; let { logger , file } = tplOpts ; antNotSupportModifier . forEach ( item => { if ( eventModifiers . includes ( item ) ) { logger . warn ( ` ${ file . path } ${ name } ` , ` ${ item } ` ) ; } } ) ; if ( eventModifiers . includes ( 'capture' ) ) { eventMode = 'catch' ; } let nativeEvent = NATIVE_EVENT_MAP [ eventType . toLowerCase ( ) ] ; if ( nativeEvent ) { eventType = nativeEvent ; } let formatEventType = eventType . charAt ( 0 ) . toUpperCase ( ) + eventType . substr ( 1 ) ; eventAttrName = eventMode + formatEventType ; return { eventType , eventAttrName , eventModifiers } ; }
2771	function filter ( fn , ctx ) { assert . equal ( typeof fn , 'function' ) return function ( val ) { val = Array . isArray ( val ) ? val : [ val ] return Promise . resolve ( val . filter ( fn , ctx ) ) } }
928	function getRandomStringNotIn ( string ) { const randomString = Math . random ( ) . toString ( 36 ) . substr ( 2 ) ; if ( string . indexOf ( randomString ) === - 1 ) { return randomString ; } return getRandomStringNotIn ( string ) ; }
3075	function ( ctl ) { var len = ctl . items && ctl . items . length ; return utils . sha256 ( ctl . id + ':' + len ) . substring ( 0 , 8 ) ; }
724	function ( data ) { var key = hash_key ( data [ this . settings . valueField ] ) ; if ( typeof key === 'undefined' || key === null || this . options . hasOwnProperty ( key ) ) return false ; data . $order = data . $order || ++ this . order ; this . options [ key ] = data ; return key ; }
604	function formatNumber ( number ) { if ( Math . round ( number ) === number ) { return number ; } return Math . round ( number * 10000 ) / 10000 ; }
135	function preprocessCartForServer ( { coupon , is_coupon_applied , is_coupon_removed , currency , temporary , extra , products , tax , } ) { const needsUrlCoupon = ! ( coupon || is_coupon_applied || is_coupon_removed || typeof document === 'undefined' ) ; const urlCoupon = needsUrlCoupon ? url . parse ( document . URL , true ) . query . coupon : '' ; return Object . assign ( { coupon , is_coupon_applied , is_coupon_removed , currency , tax , temporary , extra , products : products . map ( ( { product_id , meta , free_trial , volume , extra : productExtra } ) => ( { product_id , meta , free_trial , volume , extra : productExtra , } ) ) , } , needsUrlCoupon && urlCoupon && { coupon : urlCoupon , is_coupon_applied : false , } ) ; }
555	function animate ( ) { controls . update ( ) ; renderer . render ( scene , camera ) ; controls1 . update ( ) ; renderer1 . render ( scene1 , camera1 ) ; requestAnimationFrame ( function ( ) { animate ( ) ; } ) ; }
507	function runVm ( err ) { const pc = runState . programCounter if ( ! err && pc !== 0 && ( pc < 0 || pc >= runState . code . length ) ) { err = new VmError ( ERROR . INVALID_OPCODE ) } if ( err ) { return parseVmResults ( err ) } async . whilst ( vmIsActive , iterateVm , parseVmResults ) }
171	function find_largest_range ( rs ) { let r_id = - 1 , r_size = 0 , i ; if ( rs . length < 1 ) { return null ; } for ( i = 0 ; i < rs . length ; i ++ ) { if ( null === rs [ i ] ) { continue ; } if ( - 1 === r_id || rs [ i ] . indices [ 1 ] - rs [ i ] . indices [ 0 ] > r_size ) { r_id = i ; r_size = rs [ i ] . indices [ 1 ] - rs [ i ] . indices [ 0 ] ; } } return r_id ; }
3221	function ( store , records , indexes , isMove ) { var me = this ; if ( me . selectionStart && Ext . Array . contains ( records , me . selectionStart ) ) { me . selectionStart = null ; } if ( isMove || me . locked || ! me . pruneRemoved ) { return ; } me . deselectDeletedRecords ( records ) ; }
976	function process ( file , options ) { let content = file . content . toString ( ) ; let { config : rules , logger } = options ; let result = content ; try { result = doReplacement ( content , rules || [ ] , file ) ; } catch ( ex ) { let tip ; if ( ex === 'devServer' ) { tip = ', please execute `npm run dev:server` script or start with `--server` option' ; } logger . error ( 'unknown replacement variable:' , ex + ( tip || '' ) ) ; } return { content : result } ; }
1881	function ( title , menu ) { var item = null ; _ . find ( menu || this . getMenu ( ) , function ( val ) { if ( val . type == 'action' ) { if ( val . label == title || val . name == title ) { return item = val . name ; } } else { return item = this . getActionNameForMenuTitle ( title , val . items ) ; } } , this ) ; return item || null ; }
857	function combine ( converters ) { return filePath => { for ( const converter of converters ) { if ( converter . match ( filePath ) ) { return converter . convert ( filePath ) } } return filePath } }
1574	function createTemplate ( type , destination ) { const templatePath = getTemplatePath ( assets , type ) if ( ! templatePath ) { throw new Error ( 'Missing template! Make sure your presskit has a "type" field (product/company)' ) } registerPartials ( assets ) registerHelpers ( destination ) const template = fs . readFileSync ( templatePath , 'utf-8' ) return handlebars . compile ( template ) }
3866	function setAttribute ( node , prop , value ) { if ( node && node . el ) { if ( isObject ( prop ) ) { Object . keys ( prop ) . forEach ( function ( key ) { node . el . setAttribute ( key , prop [ key ] ) ; } ) ; } else { node . el . setAttribute ( prop , value ) ; } } }
468	function ( KEY , exec ) { var fn = ( _core . Object || { } ) [ KEY ] || Object [ KEY ] ; var exp = { } ; exp [ KEY ] = exec ( fn ) ; _export ( _export . S + _export . F * _fails ( function ( ) { fn ( 1 ) ; } ) , 'Object' , exp ) ; }
1948	function shouldBreakInsideInline ( node , profile ) { var abbrUtils = require ( 'abbreviationUtils' ) ; var hasBlockElems = _ . any ( node . children , function ( child ) { if ( abbrUtils . isSnippet ( child ) ) return false ; return ! abbrUtils . isInline ( child ) ; } ) ; if ( ! hasBlockElems ) { return shouldFormatInline ( node , profile ) ; } return true ; }
806	function ( state , title , url ) { var win = this . win ; if ( this . canClientNavigate ( ) ) { win . history . pushState ( state , title , url ) ; } else { this . navigationWindow ( ) . location . href = url ; } }
326	function rotateTo ( degree ) { degree = Number ( degree ) ; if ( isNumber ( degree ) && this . ready && ! this . disabled && this . options . rotatable ) { this . imageData . rotate = degree % 360 ; this . renderCanvas ( true , true ) ; } return this ; }
2202	function _integral ( expr , context , lastRuleComment ) { var exprString = expr . toString ( { parenthesis : 'all' , handler : function ( node , options ) { if ( node . type === 'ParenthesisNode' ) { return '(' + node . content . toString ( options ) + ')' ; } } } ) ; var debugComment = lastRuleComment ? lastRuleComment + ": " : "" ; debugComment += "find integral of " + exprString + " d" + context . variable . name ; context . printDebug ( debugComment ) ; context . debugIndent ++ ; if ( context . subIntegral [ exprString ] !== undefined ) { context . printDebug ( "Precomputed: " + context . subIntegral [ exprString ] ) ; context . debugIndent -- ; return context . subIntegral [ exprString ] ; } context . subIntegral [ exprString ] = null ; for ( var i = 0 ; i < context . rules . length ; i ++ ) { var result = context . rules [ i ] ( expr , context , _integral ) ; if ( result !== undefined && result !== null ) { context . subIntegral [ exprString ] = result ; context . printDebug ( "Computed: " + result . toString ( { parenthesis : 'all' } ) ) ; context . debugIndent -- ; return result ; } } context . printDebug ( "No integral found" ) ; context . debugIndent -- ; return null ; }
2386	function ( predicate ) { var lists = new ArrayList ; var arrays = _ . partition ( this , predicate ) ; arrays . forEach ( function ( arr ) { var list = new ArrayList ; lists . push ( list . add ( arr ) ) ; } ) ; return lists ; }
3259	function ( val ) { val = ensureDefault ( val , constants_1 . DEFAULT_TYPE_VALUES . boolean ) ; return Boolean ( / ^false$ / i . test ( val ) ? false : val ) ; }
1754	function ( qName ) { if ( ! qName || qName . length === 0 ) { throw new Error ( 'You must specify a queue name.' ) ; } var client = redis . client ( ) ; return client . keysAsync ( 'bull:' + qName + ':*' ) . then ( function ( keys ) { if ( keys . length ) { return client . del ( keys ) ; } } ) ; }
1394	function verifyStatusUpdate ( exId , desiredStatus ) { if ( ! desiredStatus || ! _isValidStatus ( desiredStatus ) ) { const error = new Error ( ` ${ desiredStatus } ` ) ; error . statusCode = 422 ; return Promise . reject ( error ) ; } return getStatus ( exId ) . then ( ( status ) => { if ( desiredStatus === status ) { return Promise . resolve ( ) ; } if ( _isRunningStatus ( status ) && _isInitStatus ( desiredStatus ) ) { const error = new Error ( ` ${ status } ${ desiredStatus } ` ) ; return Promise . reject ( error ) ; } if ( _isTerminalStatus ( status ) ) { const error = new Error ( ` ${ status } ${ desiredStatus } ` ) ; return Promise . reject ( error ) ; } return Promise . resolve ( status ) ; } ) ; }
3816	function ( event ) { if ( ! event . target || ! event . target . policy ) { return ; } var fn = this . lookupFn ( event . target . policy , 'config.routes' ) ; sails . router . bind ( event . path , fn , event . verb , _ . merge ( event . options , event . target ) ) ; }
871	function getFilePath ( isModule , id , options ) { try { return resolve . sync ( id , options ) } catch ( _err ) { if ( isModule ) { return null } return path . resolve ( options . basedir , id ) } }
3270	function stripTokens ( val , negate , variadic ) { variadic = escape ( variadic || constants_1 . VARIADIC_CHAR ) ; negate = escape ( negate || constants_1 . NEGATE_CHAR ) ; var argExp = new RegExp ( [ '<' , '>' , '\\[' , \\ ] . '\\]' \\ , join ) ; ( '|' ) 'g' var noExp = new RegExp ( '^' + negate ) ; }
1791	function ( args , callback ) { let child = this . runProtractor ( args ) . on ( 'exit' , function ( code ) { if ( child ) { child . kill ( ) ; } if ( callback ) { callback ( code ) ; } } ) ; }
2537	function baseSet ( object , path , value , customizer ) { if ( ! isObject$2 ( object ) ) { return object ; } path = isKey$2 ( path , object ) ? [ path ] : castPath$2 ( path ) ; var index = - 1 , length = path . length , lastIndex = length - 1 , nested = object ; while ( nested != null && ++ index < length ) { var key = toKey$2 ( path [ index ] ) , newValue = value ; if ( index != lastIndex ) { var objValue = nested [ key ] ; newValue = customizer ? customizer ( objValue , key , nested ) : undefined ; if ( newValue === undefined ) { newValue = isObject$2 ( objValue ) ? objValue : ( isIndex$1 ( path [ index + 1 ] ) ? [ ] : { } ) ; } } assignValue ( nested , key , newValue ) ; nested = nested [ key ] ; } return object ; }
3798	function CircleCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 3 ) throw new SyntaxError ( 'CIRCLE command requires 3 arguments' ) ; this . x = parsed . args [ 0 ] ; this . y = parsed . args [ 1 ] ; this . radius = parsed . args [ 2 ] ; this . stroke = parsed . args . length > 3 ? parsed . args [ 3 ] : false ; }
2140	function prepareJson ( shares ) { let json = [ ] ; for ( let i = 0 ; i < shares . length ; i ++ ) { let share = shares [ i ] ; json [ i ] = { } ; json [ i ] . id = share . id ; let status = '?' ; switch ( share . state ) { case 0 : status = 'stopped' ; break ; case 1 : status = 'running' ; break ; case 2 : status = 'errored' ; break ; default : status = 'unknown' ; } json [ i ] . status = status ; json [ i ] . configPath = share . config . storagePath ; json [ i ] . uptime = prettyMs ( share . meta . uptimeMs ) ; json [ i ] . restarts = share . meta . numRestarts || 0 ; json [ i ] . peers = share . meta . farmerState . totalPeers || 0 ; json [ i ] . allocs = fixContractValue ( share . meta . farmerState . contractCount ) ; json [ i ] . dataReceivedCount = fixContractValue ( share . meta . farmerState . dataReceivedCount ) ; json [ i ] . delta = share . meta . farmerState . ntpStatus . delta ; json [ i ] . port = share . meta . farmerState . portStatus . listenPort ; json [ i ] . shared = share . meta . farmerState . spaceUsed ; json [ i ] . sharedPercent = share . meta . farmerState . percentUsed ; var bridgeCxStat = share . meta . farmerState . bridgesConnectionStatus ; switch ( bridgeCxStat ) { case 0 : json [ i ] . bridgeConnectionStatus = 'disconnected' ; break ; case 1 : json [ i ] . bridgeConnectionStatus = 'connecting' ; break ; case 2 : json [ i ] . bridgeConnectionStatus = 'confirming' ; break ; case 3 : json [ i ] . bridgeConnectionStatus = 'connected' ; break ; default : break ; } } return JSON . stringify ( json ) ; }
2301	function scaffold ( { source = '' , destination = 'destination' , onlyFiles = false , exclude = [ ] , variableRegex = / \{\{\s?([A-Za-z0-9-]+_?[A-Za-z0-9-]+)+\s?\}\} / g , } = { } , data = { } , ) { const cwd = process . cwd ( ) ; const thisSource = pathIsAbsolute ( source ) ? source : path . join ( cwd , source ) ; const thisDestination = pathIsAbsolute ( destination ) ? destination : path . join ( cwd , destination ) ; const thisOnlyFiles = onlyFiles ; const thisExclude = exclude ; const thisVariableRegex = variableRegex ; try { const listOfFiles = fs . readdirSync ( thisSource ) ; const destinationExists = fs . existsSync ( thisDestination ) ; if ( ! destinationExists ) { fs . mkdirSync ( thisDestination ) ; } listOfFiles . forEach ( ( file ) => { const thisFile = path . join ( thisSource , file ) ; const stat = fs . statSync ( thisFile ) ; const destinationFilename = getProcessedPath ( file , data ) ; const destinationPath = path . join ( thisDestination , destinationFilename ) ; if ( stat && stat . isDirectory ( ) && ! thisOnlyFiles && ! thisExclude . includes ( file ) ) { scaffold ( { source : thisFile , destination : destinationPath , onlyFiles : thisOnlyFiles , exclude : thisExclude , variableRegex : thisVariableRegex , } , data ) ; } else if ( ! stat . isDirectory ( ) ) { const template = fs . readFileSync ( thisFile , 'utf-8' ) ; const filledTemplate = getRenderedTemplate ( template , data , thisVariableRegex ) ; fs . writeFileSync ( destinationPath , filledTemplate ) ; } } ) ; } catch ( e ) { throw new Error ( e ) ; } }
3558	function throwTypeErrorIfEmpty ( prefix , paramName , value , type , suffix ) { throwTypeErrorIfEmptyOrNotOfType ( prefix , paramName , value , type , suffix ) ; }
2645	function runRequestQueue ( socket ) { var queue = socket . requestQueue ; if ( ! queue ) return ; for ( var i in queue ) { var isSafeToDereference = ( { } ) . hasOwnProperty . call ( queue , i ) ; if ( isSafeToDereference ) { _emitFrom ( socket , queue [ i ] ) ; } } queue = null ; }
3321	function ( ) { this . getAssignments ( true ) . forEach ( function ( assignment ) { this . _hints . push ( assignment . getHint ( ) ) ; } , this ) ; Hint . sort ( this . _hints ) ; }
3416	function ( view , initial ) { var me = this , checkbox = me . injectCheckbox , headerCt = view . headerCt ; if ( checkbox !== false ) { if ( checkbox == 'first' ) { checkbox = 0 ; } else if ( checkbox == 'last' ) { checkbox = headerCt . getColumnCount ( ) ; } Ext . suspendLayouts ( ) ; if ( view . getStore ( ) . buffered ) { me . showHeaderCheckbox = false ; } headerCt . add ( checkbox , me . getHeaderConfig ( ) ) ; Ext . resumeLayouts ( ) ; } if ( initial !== true ) { view . refresh ( ) ; } }
226	function recordOrderInQuantcast ( cart , orderId , wpcomJetpackCartInfo ) { if ( ! isAdTrackingAllowed ( ) || ! isQuantcastEnabled ) { return ; } if ( wpcomJetpackCartInfo . containsWpcomProducts ) { if ( null !== wpcomJetpackCartInfo . wpcomCostUSD ) { const params = { qacct : TRACKING_IDS . quantcast , labels : '_fp.event.Purchase Confirmation,_fp.pcat.' + wpcomJetpackCartInfo . wpcomProducts . map ( product => product . product_slug ) . join ( ' ' ) , orderid : orderId . toString ( ) , revenue : wpcomJetpackCartInfo . wpcomCostUSD . toString ( ) , event : 'refresh' , } ; debug ( 'recordOrderInQuantcast: record WPCom purchase' , params ) ; window . _qevents . push ( params ) ; } else { debug ( ` ${ cart . currency } ` ) ; } } if ( wpcomJetpackCartInfo . containsJetpackProducts ) { if ( null !== wpcomJetpackCartInfo . jetpackCostUSD ) { const params = { qacct : TRACKING_IDS . quantcast , labels : '_fp.event.Purchase Confirmation,_fp.pcat.' + wpcomJetpackCartInfo . jetpackProducts . map ( product => product . product_slug ) . join ( ' ' ) , orderid : orderId . toString ( ) , revenue : wpcomJetpackCartInfo . jetpackCostUSD . toString ( ) , event : 'refresh' , } ; debug ( 'recordOrderInQuantcast: record Jetpack purchase' , params ) ; window . _qevents . push ( params ) ; } else { debug ( ` ${ cart . currency } ` ) ; } } }
1415	function mkpath ( dir , cb ) { dir = path . normalize ( dir ) ; var segs = dir . split ( path . sep ) ; var made = "" ; async . eachSeries ( segs , function ( seg , cb ) { if ( made . length || ! seg . length ) { made += "/" ; } made += seg ; fs . exists ( made , function ( exists ) { if ( ! exists ) { fs . mkdir ( made , function ( err ) { if ( err && err . code === "EEXIST" ) { err = null ; } cb ( err ) ; } ) ; return ; } fs . stat ( made , function ( err , stat ) { if ( err ) { cb ( err ) ; } else if ( stat . isDirectory ( ) ) { cb ( null ) ; } else { cb ( new Error ( "Cannot create " + made + " (in " + dir + ") because it exists and is not a directory" , "ENOENT" ) ) ; } } ) ; } ) ; } , function ( err ) { cb ( err ) ; } ) ; }
3741	function pad ( data , length , pad ) { data = String ( data ) ; pad = pad || ' ' ; while ( data . length < length ) data += pad ; return data ; }
713	function handleFileSelect ( evt ) { evt . stopPropagation ( ) ; evt . preventDefault ( ) ; var files = evt . dataTransfer . files ; dumpFile ( files [ 0 ] ) ; }
2874	function hilbertIndex ( point , options ) { options = options || { } var index = 0 , code , entry = options . entry || 0 , direction = options . direction || 0 , i = options . precision || bitwise . bitPrecision ( Math . max . apply ( null , point ) ) - 1 , dim = point . length console . log ( i ) while ( i >= 0 ) { var bits = 0 var mask = 1 << dim - 1 for ( var k = 0 ; k < point . length ; k ++ ) { if ( point [ dim - ( k + 1 ) ] & ( 1 << i ) ) { bits |= mask } mask >>>= 1 } bits = grayTransform ( entry , direction , bits , dim ) code = grayInverse ( bits ) entry = entry ^ bitwise . rotateLeft ( entrySequence ( code ) , dim , 0 , direction + 1 ) direction = ( direction + directionSequence ( code , dim ) + 1 ) % dim index = ( index << dim ) | code i -- } return index }
3341	function ( target , dd , e , dragData ) { if ( this . dropOK ) { var value = dragData . field . getValue ( ) ; target . record . set ( target . fieldName , value ) ; this . onCellDrop ( target . fieldName , value ) ; return true ; } }
2093	function subOf ( child , mixin ) { if ( child === mixin ) return true ; if ( child && child . constructors ) { for ( var i in child . constructors ) { var parent = child . constructors [ i ] ; if ( parent === child ) continue ; if ( parent === mixin ) return true ; if ( subOf ( parent , mixin ) ) return true ; } } return false ; }
3536	function ImageDimensions ( assetPath , registeredAssets , callback ) { sassUtils . assertType ( assetPath , "string" ) ; sassUtils . assertType ( registeredAssets , "map" ) ; var self = this ; var getPath = self . checkImagePath ( assetPath . getValue ( ) , registeredAssets ) ; getPath . then ( function ( success ) { var imageDimensions = self . getDimensions ( success ) ; imageDimensions . then ( function ( dimensions ) { callback ( null , dimensions ) ; } , function ( err ) { callback ( err , null ) ; } ) ; } , function ( err ) { callback ( err , null ) ; } ) ; }
1670	function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; result . ok ( gseCrypto . getInstance ( ) . hash ( result . callbackId , args ) , false ) ; }
2561	function ( v ) { if ( this [ handle ] !== v ) { Object . defineProperty ( this , handle , { configurable : true , enumerable : true , writable : true , value : v } ) ; } }
1031	function ( ) { var url = 'https://api.dropboxapi.com/2/users/get_current_account' ; return this . _request ( 'POST' , url , { } ) . then ( function ( response ) { var info = response . responseText ; try { info = JSON . parse ( info ) ; } catch ( e ) { return Promise . reject ( new Error ( 'Could not query current account info: Invalid API response: ' + info ) ) ; } return Promise . resolve ( { email : info . email } ) ; } ) ; }
3439	function ( eventDescriptor ) { var me = this , index = ++ me . queueIndex ; if ( me . keyFrameEvents [ eventDescriptor . type ] ) { Ext . Array . insert ( me . eventQueue , index , [ { keyframe : true , ts : eventDescriptor . ts } ] ) ; } }
3602	function PauseCommand ( args , define ) { if ( args . length ) { this . message = new statements . ExpressionStatement ( args , define ) ; if ( this . message . error ) throw this . message . error ; } else this . message = new statements . StringStatement ( "[<< Paused, Press RETURN to Continue >>]" ) ; }
3575	function ( callback , context ) { SjlMap . prototype . forEach . call ( this . sort ( ) , function ( value , key , map ) { callback . call ( context , this . wrapItems ? value . value : value , key , map ) ; } , this ) ; return this ; }
2810	function ( expected , actual , optionsOrMsg ) { var options = optionsOrMsg instanceof Object ? optionsOrMsg : { message : optionsOrMsg } , msg = options . message , compatHtml = bender . tools && bender . tools . compatHtml ; if ( ! options . skipCompatHtml ) { var sortAttributes = ( 'sortAttributes' in options ) ? options . sortAttributes : true , fixZWS = ( 'fixZWS' in options ) ? options . fixZWS : true , fixNbsp = ( 'fixNbsp' in options ) ? options . fixNbsp : true ; if ( ! compatHtml ) { throw new Error ( 'Missing bender.tools.compatHtml' ) ; } expected = compatHtml ( expected , options . noInterWS , sortAttributes , fixZWS , options . fixStyles , fixNbsp , options . noTempElements , options . customFilters ) ; actual = compatHtml ( actual , options . noInterWS , sortAttributes , fixZWS , options . fixStyles , fixNbsp , options . noTempElements , options . customFilters ) ; } bender . assert . areSame ( html_beautify ( expected , this . _config ) , html_beautify ( actual , this . _config ) , msg ) ; }
593	function mapCanvasToData ( ) { for ( let i = ijkBBox [ 0 ] ; i < ijkBBox [ 1 ] + 1 ; i ++ ) { for ( let j = ijkBBox [ 2 ] ; j < ijkBBox [ 3 ] + 1 ; j ++ ) { for ( let k = ijkBBox [ 4 ] ; k < ijkBBox [ 5 ] + 1 ; k ++ ) { let worldCoordinate = new THREE . Vector3 ( i , j , k ) . applyMatrix4 ( stack2 . _ijk2LPS ) ; let screenCoordinates = worldCoordinate . clone ( ) ; screenCoordinates . project ( camera ) ; screenCoordinates . x = Math . round ( ( ( screenCoordinates . x + 1 ) * canvas . offsetWidth ) / 2 ) ; screenCoordinates . y = Math . round ( ( ( - screenCoordinates . y + 1 ) * canvas . offsetHeight ) / 2 ) ; screenCoordinates . z = 0 ; let pixel = context . getImageData ( screenCoordinates . x , screenCoordinates . y , 1 , 1 ) . data ; if ( pixel [ 3 ] > 0 && i >= 0 && j >= 0 && k >= 0 ) { let voxelIndex = i + j * stack2 . _columns + k * stack2 . _rows * stack2 . _columns ; let textureSize = 4096 ; let textureDimension = textureSize * textureSize ; let rawDataIndex = ~ ~ ( voxelIndex / textureDimension ) ; let inRawDataIndex = voxelIndex % textureDimension ; let oldValue = stack2 . rawData [ rawDataIndex ] [ inRawDataIndex ] ; let newValue = cursor . value ; if ( oldValue != newValue ) { stack2 . rawData [ rawDataIndex ] [ inRawDataIndex ] = newValue ; textures2 [ rawDataIndex ] . image . data = stack2 . rawData [ rawDataIndex ] ; textures2 [ rawDataIndex ] . needsUpdate = true ; editorStats [ oldValue ] -= 1 ; editorStats [ newValue ] += 1 ; } } } } } }
1080	function cancelMain ( ) { if ( mainTask . isRunning && ! mainTask . isCancelled ) { mainTask . isCancelled = true next ( TASK_CANCEL ) } }
798	function httpGetPromise ( url ) { var deferred = Q . defer ( ) , get ; var cb = function ( res ) { var data = '' ; res . on ( 'data' , function ( chunk ) { data += chunk ; } ) ; res . on ( 'err' , function ( err ) { debug ( err + ' ' + url ) ; deferred . reject ( err ) ; } ) ; res . on ( 'end' , function ( ) { if ( res . statusCode !== 200 ) { debug ( res . statusCode + ': ' + url ) ; deferred . resolve ( ) ; } else { debug ( 'fetched ' + url ) ; deferred . resolve ( data ) ; } } ) ; } ; if ( url . match ( / ^https / ) ) { get = https . get ( url , cb ) ; } else { get = http . get ( url , cb ) ; } get . on ( 'error' , function ( err ) { deferred . resolve ( ) ; debug ( err + ': ' + url ) ; } ) ; return deferred . promise ; }
2700	function computeSignature ( values , signatureScheme , signatureKey ) { var hmac = crypto . createHmac ( signatureScheme , signatureKey ) ; values . forEach ( function ( v ) { hmac . update ( v ) ; } ) ; return hmac . digest ( 'hex' ) ; }
2447	function isStream ( obj ) { return Boolean ( obj && isFunction ( obj . addListener ) && isFunction ( obj . removeListener ) && isFunction ( obj . destroy ) && ( isFunction ( obj . write ) && isFunction ( obj . end ) || isFunction ( obj . pipe ) && isFunction ( obj . read ) && isFunction ( obj . pause ) && isFunction ( obj . resume ) ) ) ; }
2378	function formatUpdates ( processedUpdates ) { var updates = { hashes : { } } ; _ . each ( processedUpdates , function ( update ) { var type = update . type ; var hash = update . hash ; updates . hashes [ hash ] = update ; updates [ type ] = updates [ type ] || { } ; updates [ type ] [ hash ] = update ; } ) ; return updates ; }
1692	function _forEachRenderable ( callback ) { if ( this . _nodesById ) { for ( var key in this . _nodesById ) { callback ( this . _nodesById [ key ] ) ; } } else { var sequence = this . _viewSequence . getHead ( ) ; while ( sequence ) { var renderable = sequence . get ( ) ; if ( renderable ) { callback ( renderable ) ; } sequence = sequence . getNext ( ) ; } } }
2794	function filterQueryParams ( baseClause , request ) { _ . forEach ( request . query , function ( v , k ) { addWhereClause ( baseClause , k , v ) } ) return baseClause }
1710	function _createLayout ( ) { this . _renderables = { views : [ ] , transferables : [ ] } ; this . _viewStack = [ ] ; this . layout = new LayoutController ( { layout : ViewStackLayout . bind ( this ) , layoutOptions : this . options , dataSource : this . _renderables } ) ; this . add ( this . layout ) ; this . layout . on ( 'layoutend' , _processAnimations . bind ( this ) ) ; }
1040	function getIdFromURL ( url ) { var id = url . replace ( youtubeRegexp , '$1' ) ; if ( id . includes ( ';' ) ) { var pieces = id . split ( ';' ) ; if ( pieces [ 1 ] . includes ( '%' ) ) { var uriComponent = decodeURIComponent ( pieces [ 1 ] ) ; id = ( "http://youtube.com" + uriComponent ) . replace ( youtubeRegexp , '$1' ) ; } else { id = pieces [ 0 ] ; } } else if ( id . includes ( '#' ) ) { id = id . split ( '#' ) [ 0 ] ; } return id }
452	function generateData ( props ) { const xValues = generateDataArray ( props , "x" ) ; const yValues = generateDataArray ( props , "y" ) ; const values = xValues . map ( ( x , i ) => { return { x , y : yValues [ i ] } ; } ) ; return values ; }
2034	function ( cozyHome , port ) { fs . mkdirsSync ( cozyHome ) ; configHelpers . setHomePath ( cozyHome ) ; configHelpers . setMainAppPort ( parseInt ( port ) ) ; configHelpers . setDefaultAppsPort ( parseInt ( port ) + 100 ) ; configHelpers . copyDependency ( 'pouchdb' ) ; configHelpers . createConfigFile ( ) ; configHelpers . watcher = configWatcher ; configHelpers . watcher . init ( configHelpers . getConfigPath ( ) ) ; return configHelpers . loadConfigFile ( ) ; }
1385	function _getClusterState ( ) { return k8s . list ( 'app=teraslice' , 'pods' ) . then ( k8sPods => k8sState . gen ( k8sPods , clusterState , clusterNameLabel ) ) . catch ( ( err ) => { logger . error ( err , 'Error listing teraslice pods in k8s' ) ; } ) ; }
2557	function get$2 ( object , path , defaultValue ) { var result = object == null ? undefined : _baseGet ( object , path ) ; return result === undefined ? defaultValue : result ; }
3812	function load ( file , options ) { var stream = fs . createReadStream ( file , options ) ; function onEnd ( ) { this . emit ( 'load' ) ; } function onError ( err ) { this . emit ( 'error' , err ) ; } stream . on ( 'end' , onEnd . bind ( this ) ) ; stream . on ( 'error' , onError . bind ( this ) ) ; stream . pipe ( this ) ; return this ; }
2597	function makeUnique ( a ) { if ( ! ( a instanceof Array ) ) return a ; var visited = [ ] ; for ( var i = 0 ; i < a . length ; i ++ ) { if ( visited . indexOf ( a [ i ] ) === - 1 ) { visited . push ( a [ i ] ) ; } else { a . splice ( i , 1 ) ; i -- ; } } return a ; }
2608	function toInt ( ) { var vals = [ ] ; libs . object . every ( arguments , function ( o ) { var radix = / ^0x / . test ( o ) ? 16 : 10 ; vals . push ( libs . object . isNumeric ( o ) ? parseInt ( o , radix ) : NaN ) ; } ) ; return vals . length === 1 ? vals [ 0 ] : vals ; }
3754	function IfCommand ( args , define ) { if ( util . endsWith ( args . toLowerCase ( ) , ' then' ) ) args = args . slice ( 0 , args . length - 5 ) . trim ( ) ; else throw new SyntaxError ( 'IF has no THEN' ) ; var parsed = new statements . ArgumentStatement ( args , { separator : false } , define ) ; this . condition = parsed . args [ 0 ] ; this . block = define ( { start : 'IF' , then : 'ELSE' , end : [ 'ENDIF' , 'RETURN' ] } ) ; }
2708	function ( view , offset , length ) { var trmOffset = lib . locateStrTrm . iso ( view , offset , length ) ; if ( trmOffset !== - 1 ) { length = trmOffset - offset ; } return lib . readStr . iso ( view , offset , length ) ; }
1955	function sendRequiredErrors ( sender , missingProps ) { _ . forEach ( missingProps , function ( prop ) { sender . emit ( 'error' , prop + ' is missing' ) ; } ) ; }
1017	function ( path , options ) { return this . _getFileId ( path ) . then ( ( id ) => { return this . _getMeta ( id ) . then ( ( meta ) => { let etagWithoutQuotes ; if ( typeof ( meta ) === 'object' && typeof ( meta . etag ) === 'string' ) { etagWithoutQuotes = removeQuotes ( meta . etag ) ; } if ( options && options . ifNoneMatch && ( etagWithoutQuotes === options . ifNoneMatch ) ) { return Promise . resolve ( { statusCode : 304 } ) ; } if ( ! meta . downloadUrl ) { if ( meta . exportLinks && meta . exportLinks [ 'text/html' ] ) { meta . mimeType += ';export=text/html' ; meta . downloadUrl = meta . exportLinks [ 'text/html' ] ; } else { return Promise . resolve ( { statusCode : 200 , body : '' , contentType : meta . mimeType , revision : etagWithoutQuotes } ) ; } } var params = { responseType : 'arraybuffer' } ; return this . _request ( 'GET' , meta . downloadUrl , params ) . then ( ( response ) => { return getTextFromArrayBuffer ( response . response , 'UTF-8' ) . then ( function ( responseText ) { let body = responseText ; if ( meta . mimeType . match ( / ^application\/json / ) ) { try { body = JSON . parse ( body ) ; } catch ( e ) { } } else { if ( shouldBeTreatedAsBinary ( responseText , meta . mimeType ) ) { body = response . response ; } } return { statusCode : 200 , body : body , contentType : meta . mimeType , revision : etagWithoutQuotes } ; } ) ; } ) ; } ) ; } ) ; }
2486	function Commander ( client , options ) { if ( ! ( this instanceof Commander ) ) { return new Commander ( client , options ) ; } EventEmitter2 . call ( this ) ; this . setMaxListeners ( 0 ) ; options = options || { } ; options . retryStrategy = options . retryStrategy || defaultRetry ; this . _client = client ; this . _options = options ; }
888	function processAppSpecifiedMediaRule ( allAppTypes , appType , rule ) { let result = matchAppMediaParams ( allAppTypes , appType , rule . params ) ; if ( ! result ) { return ; } let { removed , params } = result ; params && ( params = params . trim ( ) ) ; if ( removed ) { rule . remove ( ) ; } else if ( params ) { rule . params = params ; } else { let children = rule . parent . nodes ; let currRuleIdx = children . indexOf ( rule ) ; rule . nodes . forEach ( item => { item . parent = rule . parent ; let itemRaws = item . raws ; let subNodes = item . nodes ; subNodes && subNodes . forEach ( sub => sub . raws . before = itemRaws . before ) ; itemRaws . before = '\n' ; \n } ) ; itemRaws . after = '\n' ; \n children . splice ( currRuleIdx , 1 , ... rule . nodes ) ; } }
1741	function placeLayer ( state , layer , targetId ) { const new_layers = state . layers . slice ( ) ; const idx1 = getLayerIndexById ( new_layers , layer . id ) ; const idx2 = getLayerIndexById ( new_layers , targetId ) ; if ( idx1 !== - 1 ) { new_layers . splice ( idx1 , 1 ) ; } const newIndex = ( targetId && idx2 !== - 1 ) ? idx2 : new_layers . length ; new_layers . splice ( newIndex , 0 , layer ) ; return Object . assign ( { } , state , { layers : new_layers , } , incrementVersion ( state . metadata , LAYER_VERSION_KEY ) ) ; }
184	function apiKeySubmitError ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT_FAILURE : const error = WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT_FAILURE === action . type ? action . error : false ; return error ; } return state ; }
127	function Ads ( player ) { var _this = this ; _classCallCheck ( this , Ads ) ; this . player = player ; this . config = player . config . ads ; this . playing = false ; this . initialized = false ; this . elements = { container : null , displayContainer : null } ; this . manager = null ; this . loader = null ; this . cuePoints = null ; this . events = { } ; this . safetyTimer = null ; this . countdownTimer = null ; this . managerPromise = new Promise ( function ( resolve , reject ) { _this . on ( 'loaded' , resolve ) ; _this . on ( 'error' , reject ) ; } ) ; this . load ( ) ; }
3400	function asyncStartLoadPartwayThrough ( stepState ) { return function ( resolve , reject ) { var loader = stepState . loader ; var name = stepState . moduleName ; var step = stepState . step ; if ( loader . modules [ name ] ) throw new TypeError ( '"' + name + '" already exists in the module table' ) ; for ( var i = 0 , l = loader . loads . length ; i < l ; i ++ ) if ( loader . loads [ i ] . name == name ) throw new TypeError ( '"' + name + '" already loading' ) ; var load = createLoad ( name ) ; load . metadata = stepState . moduleMetadata ; var linkSet = createLinkSet ( loader , load ) ; loader . loads . push ( load ) ; resolve ( linkSet . done ) ; if ( step == 'locate' ) proceedToLocate ( loader , load ) ; else if ( step == 'fetch' ) proceedToFetch ( loader , load , Promise . resolve ( stepState . moduleAddress ) ) ; else { console . assert ( step == 'translate' , 'translate step' ) ; load . address = stepState . moduleAddress ; proceedToTranslate ( loader , load , Promise . resolve ( stepState . moduleSource ) ) ; } } }
421	function ( ) { var name , params = [ ] , match , ruleset , cond , variadic = false ; if ( ( parserInput . currentChar ( ) !== '.' && parserInput . currentChar ( ) !== '#' ) || parserInput . peek ( / ^[^{]*\} / ) ) { return ; } parserInput . save ( ) ; match = parserInput . $re ( / ^([#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\s*\( / ) ; if ( match ) { name = match [ 1 ] ; var argInfo = this . args ( false ) ; params = argInfo . args ; variadic = argInfo . variadic ; if ( ! parserInput . $char ( ')' ) ) { parserInput . restore ( 'Missing closing \')\'' ) ; \' } \' return ; parserInput . commentStore . length = 0 ; if ( parserInput . $str ( 'when' ) ) { cond = expect ( parsers . conditions , 'expected condition' ) ; } } else ruleset = parsers . block ( ) ; }
2766	function three ( context , next ) { console . log ( 'Hi from three' , context ) ; setTimeout ( function ( ) { context . three = 'Hello' ; console . log ( 'Hello from three' , context ) ; } , 1000 ) ; }
2722	function fromFile ( filename , callback ) { var configFile = filename || '../config/winston-config.json' ; fs . exists ( configFile , function ( exists ) { if ( exists ) { var winstonConf = require ( configFile ) . logging ; fromJson ( winstonConf , callback ) ; } else { callback ( new Error ( 'No config file found (at least provide a config/winston-config.json) with winston configuration' ) , winston ) ; } } ) ; }
506	function getHead ( next ) { vm . blockchain . getHead ( function ( err , block ) { state . root = block . header . stateRoot next ( err ) } ) }
3648	function isLikeAFuture ( x ) { return x . isResolved !== undefined && x . queue !== undefined && x . then !== undefined }
149	function bustHashForHrefs ( { name , oldValue } ) { const value = 'href' === name ? ` ${ oldValue . split ( '?' ) . shift ( ) } ${ new Date ( ) . getTime ( ) } ` : oldValue ; return { name , value } ; }
2184	function setDefaults ( plugin , message , opts ) { if ( typeof plugin === 'object' ) { return defaults ( plugin ) ; } opts = opts || { } ; if ( message instanceof Error ) { opts . error = message ; } else if ( typeof message === 'object' ) { opts = message ; } else { opts . message = message ; } opts . plugin = plugin ; return defaults ( opts ) ; }
2236	function constructor ( service , state ) { this . service = service ; this . state = state ; if ( typeof this . state === 'object' ) { AWS . util . each . call ( this , this . state , function ( key , value ) { this . state = key ; this . expectedValue = value ; } ) ; } this . loadWaiterConfig ( this . state ) ; if ( ! this . expectedValue ) { this . expectedValue = this . config . successValue ; } }
605	function ( participle , sentencePart , attributes ) { Participle . call ( this , participle , sentencePart , attributes ) ; checkException . call ( this ) ; }
336	function appendItem ( item , parent , custom ) { if ( item . parentNode ) { if ( ! item . parentNode . parentNode ) { parent . appendChild ( item . parentNode ) ; } } else { parent . appendChild ( item ) ; } util . removeClass ( item , "excluded" ) ; if ( ! custom ) { item . innerHTML = item . textContent ; } }
3506	function isNodeBodyBlock ( node ) { return node . type === "BlockStatement" || ( node . body && node . body . type === "BlockStatement" ) || ( node . consequent && node . consequent . type === "BlockStatement" ) ; }
1173	function ( r ) { r = g . rect ( r ) ; var views = _ . map ( this . model . getElements ( ) , this . findViewByModel ) ; return _ . filter ( views , function ( view ) { return r . intersect ( g . rect ( V ( view . el ) . bbox ( false , this . viewport ) ) ) ; } , this ) ; }
2033	async function getUTXOs ( walletInfo , BITBOX ) { try { const retArray = [ ] for ( var i = 0 ; i < walletInfo . hasBalance . length ; i ++ ) { const thisAddr = walletInfo . hasBalance [ i ] . cashAddress const u = await BITBOX . Address . utxo ( [ thisAddr ] ) for ( var j = 0 ; j < u [ 0 ] . length ; j ++ ) { const thisUTXO = u [ 0 ] [ j ] thisUTXO . hdIndex = walletInfo . hasBalance [ i ] . index if ( thisUTXO . confirmations > 0 ) retArray . push ( thisUTXO ) } } return retArray } catch ( err ) { console . log ( ` ` ) throw err } }
3138	function ( binding , e ) { var keys = [ 'shift' , 'ctrl' , 'alt' ] , i = 0 , len = keys . length , val , key ; for ( ; i < len ; ++ i ) { key = keys [ i ] ; val = binding [ key ] ; if ( ! ( val === undefined || ( val === e [ key + 'Key' ] ) ) ) { return false ; } } return true ; }
1859	function ( ) { var attrs = [ ] ; var res = this . matchedResource ( ) ; if ( require ( 'elements' ) . is ( res , 'element' ) && _ . isArray ( res . attributes ) ) { attrs = attrs . concat ( res . attributes ) ; } return optimizeAttributes ( attrs . concat ( this . _attributes ) ) ; }
939	function createAPIDoneHook ( done , ctx ) { let hookInfo = { resData : null , resException : false , hook : null } ; hookInfo . hook = ( err , res , complete , shouldCatchException ) => { let result ; if ( err != null ) { result = err ; if ( shouldCatchException ) { try { let data = done ( result , null , ctx ) ; data == null || ( result = data ) ; } catch ( ex ) { hookInfo . resException = true ; result = ex ; } } else { let data = done ( result , null , ctx ) ; data == null || ( result = data ) ; } } else { let data = done ( null , res , ctx ) ; data == null || ( res = data ) ; result = res ; } hookInfo . resData = result ; complete && complete ( result ) ; return result ; } ; return hookInfo ; }
1493	async function ( filename , length ) { if ( await this . safeStat ( filename ) && length > 1 ) { var lastFile = null ; for ( var i = length ; i > 0 ; i -- ) { var tmp = filename + "." + i ; if ( i == length ) { await this . safeUnlink ( tmp ) ; } else if ( await this . safeStat ( tmp ) ) { await rename ( tmp , lastFile ) ; } lastFile = tmp ; } await rename ( filename , lastFile ) ; } }
694	function ( subject ) { var kb = UI . store var t = kb . findTypeURIs ( subject ) var QU = $rdf . Namespace ( 'http://www.w3.org/2000/10/swap/pim/qif#' ) var WF = $rdf . Namespace ( 'http://www.w3.org/2005/01/wf/flow#' ) if ( t [ 'http://www.w3.org/ns/pim/trip#Trip' ] || subject . uri === 'http://www.w3.org/ns/pim/trip#Trip' || t [ 'http://www.w3.org/2005/01/wf/flow#Task' ] || t [ 'http://www.w3.org/2000/10/swap/pim/qif#Transaction' ] || QU ( 'Transaction' ) in kb . findSuperClassesNT ( subject ) || kb . holds ( subject , WF ( 'attachment' ) ) ) return 'attachments' return null }
829	function loadPackageName ( ) { var packageFile ; try { if ( require . main . filename ) { packageFile = find ( path . dirname ( require . main . filename ) ) ; } } catch ( e ) { packageFile = null ; } if ( ! packageFile && process . resourcesPath ) { packageFile = find ( path . join ( process . resourcesPath , 'app.asar' ) ) ; var electronModule = path . join ( 'node_modules' , 'electron' , 'package.json' ) ; if ( packageFile && packageFile . indexOf ( electronModule ) !== - 1 ) { packageFile = null ; } } if ( ! packageFile ) { packageFile = find ( process . cwd ( ) ) ; } if ( ! packageFile ) { return null ; } var content = fs . readFileSync ( packageFile , 'utf-8' ) ; var packageData = JSON . parse ( content ) ; return packageData ? packageData . productName || packageData . name : false ; }
3105	function Iterator ( options , fn ) { if ( typeof options === 'function' ) { fn = options ; options = { } ; } if ( typeof fn !== 'function' ) { throw new TypeError ( 'Iterator expects `fn` to be a function.' ) ; } this . options = options || { } ; this . fn = fn ; }
1982	function source ( message ) { var ip = [ ] ; for ( var i = 0 ; i < 4 ; i ++ ) ip . push ( message [ i ] ) ; return ip . join ( '.' ) ; }
1038	function hookGetItemURL ( rs ) { if ( rs . _origBaseClientGetItemURL ) { return ; } rs . _origBaseClientGetItemURL = BaseClient . prototype . getItemURL ; BaseClient . prototype . getItemURL = function ( ) { throw new Error ( 'getItemURL is not implemented for Dropbox yet' ) ; } ; }
3426	function ( array , fn , scope , reverse ) { array = ExtArray . from ( array ) ; var i , ln = array . length ; if ( reverse !== true ) { for ( i = 0 ; i < ln ; i ++ ) { if ( fn . call ( scope || array [ i ] , array [ i ] , i , array ) === false ) { return i ; } } } else { for ( i = ln - 1 ; i > - 1 ; i -- ) { if ( fn . call ( scope || array [ i ] , array [ i ] , i , array ) === false ) { return i ; } } } return true ; }
1838	function Nagios ( options , log ) { var parsed = url . parse ( options . url ) ; delete parsed . host ; parsed [ 'auth' ] = sprintf ( '%s:%s' , options . username , options . password ) ; this . _url = url . format ( parsed ) ; this . _options = options ; this . log = log || logmagic . local ( 'nagios' ) ; }
3332	function ( ev ) { if ( this . isUpdating ) { return ; } var prefix = this . element . value . substring ( 0 , ev . argument . start ) ; var suffix = this . element . value . substring ( ev . argument . end ) ; var insert = typeof ev . text === 'string' ? ev . text : ev . text . name ; this . element . value = prefix + insert + suffix ; var insertEnd = ( prefix + insert ) . length ; this . element . selectionStart = insertEnd ; this . element . selectionEnd = insertEnd ; }
126	function getTitle ( videoId ) { var _this2 = this ; var url = format ( this . config . urls . youtube . api , videoId ) ; fetch ( url ) . then ( function ( data ) { if ( is$1 . object ( data ) ) { var title = data . title , height = data . height , width = data . width ; _this2 . config . title = title ; ui . setTitle . call ( _this2 ) ; _this2 . embed . ratio = [ width , height ] ; } setAspectRatio . call ( _this2 ) ; } ) . catch ( function ( ) { setAspectRatio . call ( _this2 ) ; } ) ; }
2549	function baseRest ( func , start ) { start = nativeMax$1 ( start === undefined ? ( func . length - 1 ) : start , 0 ) ; return function ( ) { var args = arguments , index = - 1 , length = nativeMax$1 ( args . length - start , 0 ) , array = Array ( length ) ; while ( ++ index < length ) { array [ index ] = args [ start + index ] ; } index = - 1 ; var otherArgs = Array ( start + 1 ) ; while ( ++ index < start ) { otherArgs [ index ] = args [ index ] ; } otherArgs [ start ] = array ; return apply$1 ( func , this , otherArgs ) ; } ; }
2196	function shallowCopy ( src , dst ) { var i = 0 ; if ( isArray ( src ) ) { dst = dst || [ ] ; for ( ; i < src . length ; i ++ ) { dst [ i ] = src [ i ] ; } } else if ( isObject ( src ) ) { dst = dst || { } ; var keys = Object . keys ( src ) ; for ( var l = keys . length ; i < l ; i ++ ) { var key = keys [ i ] ; if ( ! ( key . charAt ( 0 ) === '$' && key . charAt ( 1 ) === '$' ) ) { dst [ key ] = src [ key ] ; } } } return dst || src ; }
1022	function ( id ) { return this . _request ( 'GET' , BASE_URL + '/drive/v2/files/' + id , { } ) . then ( function ( response ) { if ( response . status === 200 ) { return Promise . resolve ( JSON . parse ( response . responseText ) ) ; } else { return Promise . reject ( "request (getting metadata for " + id + ") failed with status: " + response . status ) ; } } ) ; }
31	function mapArrayBufferViews ( ary ) { return ary . map ( function ( chunk ) { if ( chunk . buffer instanceof ArrayBuffer ) { var buf = chunk . buffer ; if ( chunk . byteLength !== buf . byteLength ) { var copy = new Uint8Array ( chunk . byteLength ) ; copy . set ( new Uint8Array ( buf , chunk . byteOffset , chunk . byteLength ) ) ; buf = copy . buffer ; } return buf ; } return chunk ; } ) ; }
1592	function getConfig ( projectDir , appName , env ) { if ( ! [ 'dev' , 'test' , 'prod' ] . includes ( env ) ) exit ( ` ${ env } ` ) ; process . env . NODE_ENV = { dev : 'development' , test : 'testing' , prod : 'production' } [ env ] ; const configPath = path . join ( projectDir , 'basys.json' ) ; let projectConfig ; try { projectConfig = fs . readFileSync ( configPath , 'utf8' ) ; } catch ( e ) { exit ( ` ${ configPath } \n ` ) ; } try { projectConfig = JSON5 . parse ( projectConfig ) ; } catch ( e ) { exit ( ` ${ configPath } ${ e . message } \n ` + 'You can use JSON5 (https://json5.org) which is an extension of the JSON format, that includes:\n' + \n , ) ; } ' - comments,\n - unquoted and single-quoted object keys,\n - trailing commas,\n - single-quoted and multi-line strings.\n' \n \n \n \n if ( ! projectConfig || projectConfig . constructor !== Object ) { exit ( ` ${ configPath } ` ) ; } if ( ! projectConfig . apps ) exit ( "'apps' option must be provided in basys.json" ) ; const appNames = Object . keys ( projectConfig . apps ) ; if ( appNames . length === 0 ) exit ( 'At least one app must be defined in basys.json' ) ; if ( ! appName ) { if ( appNames . length > 1 ) exit ( 'App name must be specified' ) ; appName = appNames [ 0 ] ; } if ( ! appNames . includes ( appName ) ) { exit ( ` ${ appName } ${ appNames . join ( "', '" ) } ` ) ; } let config = projectConfig . apps [ appName ] ; if ( ! [ 'web' , 'mobile' , 'desktop' ] . includes ( config . type ) ) { exit ( ` ${ appName } ${ config . type } ` , ) ; } const defaultConfig = { entry : null , favicon : null , styles : [ ] , overrides : { } , caseSensitive : false , sourceMap : false , host : 'localhost' , port : 8080 , poll : false , custom : { } , } ; if ( config . type === 'web' ) { Object . assign ( defaultConfig , { backendEntry : null , backendPort : 3000 , nodeVersion : env === 'dev' ? 'current' : '8.9' , browsers : [ '> 0.5%' , 'last 2 versions' , 'Firefox ESR' , 'not dead' ] , testBrowsers : [ ] , } ) ; } if ( config [ env ] ) { config = merge ( config , config [ env ] ) ; delete config . dev ; delete config . test ; delete config . prod ; } config = merge ( defaultConfig , config ) ; }
3732	function findNext ( data , items , index ) { var currentIndex = data . length + 1 , found = '' ; for ( var i = 0 ; i < items . length ; i ++ ) { var item = items [ i ] ; var location = data . indexOf ( item , index ) ; if ( location !== - 1 && location < currentIndex ) { currentIndex = location ; found = item ; } } if ( currentIndex === data . length + 1 ) return { index : - 1 , found : '' } ; return { index : currentIndex , found : found } ; }
1729	function _setListeners ( ) { this . tabBar . on ( 'tabchange' , function ( event ) { _updateView . call ( this , event ) ; this . _eventOutput . emit ( 'tabchange' , { target : this , index : event . index , oldIndex : event . oldIndex , item : this . _items [ event . index ] , oldItem : ( ( event . oldIndex >= 0 ) && ( event . oldIndex < this . _items . length ) ) ? this . _items [ event . oldIndex ] : undefined } ) ; } . bind ( this ) ) ; }
2535	function mkSprite ( srcFiles , destImage , options , callback ) { options . src = srcFiles , grunt . verbose . writeln ( 'Options passed to Spritesmth:' , JSON . stringify ( options ) ) ; spritesmith ( options , function ( err , result ) { if ( err ) { grunt . fatal ( err ) ; return ; } var destDir = path . dirname ( destImage ) ; grunt . file . mkdir ( destDir ) ; fs . writeFileSync ( destImage , result . image , 'binary' ) ; grunt . log . writeln ( destImage , 'created.' ) ; callback ( result . coordinates ) ; } ) ; }
1840	function PagerDuty ( options , log ) { var parsed = url . parse ( options . url ) ; delete parsed . host ; this . url = url . format ( parsed ) ; this . users = options . users ; this . schedules = options . schedules ; this . log = log || logmagic . local ( 'pagerduty' ) ; this . pagerduty_auth = sprintf ( 'Token token=%s' , options . password ) ; }
3833	function add ( snapshot ) { return Promise . resolve ( mapFn ( snapshot ) ) . then ( function ( val ) { data [ snapshot . key ( ) ] = val ; } ) ; }
2613	function getCallback ( o ) { var last = libs . object . last ( o ) ; return last instanceof Function ? last : NULL_FUNCTION ; }
2194	function showValidation ( feedback ) { feedback . errors . forEach ( function ( error ) { console . log ( 'ERROR: ' + error ) ; } ) ; feedback . warnings . forEach ( function ( warning ) { console . log ( 'WARNING: ' + warning ) ; } ) ; console . log ( "Validator finished with " + feedback . warnings . length + " warnings and " + feedback . errors . length + " errors." ) ; process . exit ( feedback . errors . length > 0 ? 2 : 0 ) ; }
2595	function intersect ( ) { var arrays = libs . object . only ( libs . object . toArray ( arguments ) , 'array' ) ; if ( arrays . length === 0 ) return [ ] ; if ( arrays . length === 1 ) return libs . object . copy ( arrays [ 0 ] ) ; var intersection = arrays [ 0 ] , intermediate = [ ] ; for ( var i = 1 ; i < arrays . length ; i ++ ) { var arr = libs . object . copy ( arrays [ i ] ) ; for ( var n = 0 ; n < intersection . length ; n ++ ) { if ( arr . indexOf ( intersection [ n ] ) > - 1 ) { intermediate . push ( intersection [ n ] ) ; var idx = arr . indexOf ( intersection [ n ] ) ; arr . splice ( idx , 1 ) ; } } intersection = intermediate ; intermediate = [ ] ; } return intersection ; }
3826	function ( path ) { var routes = [ ] ; var fs = require ( 'fs' ) ; var array = fs . readFileSync ( path ) . toString ( ) . split ( "\n" ) ; \n array . forEach ( function ( route ) { if ( route !== "" && route . match ( / ^# / ) === null ) { routes . push ( route ) ; } } ) ; }
3623	function getStringBuffer ( s ) { var buffer , n = typeof s === 'number' ? s : null , cheader , compressed ; if ( n !== null || typeof s === 'string' && s . match ( / ^-?\d+$ / ) ) { if ( n === null ) { n = parseInt ( s ) ; } if ( n >= - 128 && n <= 127 ) { buffer = new Buffer ( 1 ) ; buffer . writeInt8 ( n , 0 ) ; buffer = this . length ( buffer , 0 , true ) ; return buffer ; } else if ( n >= - 32768 && n <= 32767 ) { buffer = new Buffer ( 2 ) ; buffer . writeInt16LE ( n , 0 ) ; buffer = this . length ( buffer , 1 , true ) ; return buffer ; } else if ( n >= - 2147483648 && n <= 2147483647 ) { buffer = new Buffer ( 4 ) ; buffer . writeInt32LE ( n , 0 ) ; buffer = this . length ( buffer , 2 , true ) ; return buffer ; } } if ( typeof s === 'string' ) { buffer = new Buffer ( s , this . encoding ) ; } else if ( s instanceof Buffer ) { buffer = s ; } if ( buffer . length > this . compressionThreshold ) { compressed = lzf . compress ( buffer ) ; if ( compressed . length < buffer . length ) { cheader = Buffer . concat ( [ this . getLengthEncoding ( 3 , true ) , this . getLengthEncoding ( compressed . length , false ) , this . getLengthEncoding ( buffer . length , false ) ] ) ; return Buffer . concat ( [ cheader , compressed ] , cheader . length + compressed . length ) ; } } buffer = this . length ( buffer , buffer . length , false ) ; return buffer ; }
3146	function ( layout ) { var me = this , ownerContext = me . getCmp ( layout . owner ) ; layout . pending = false ; if ( ownerContext . state . blocks ) { return ; } layout . done = true ; ++ layout . calcCount ; ++ me . calcCount ; layout . calculate ( ownerContext ) ; if ( layout . done ) { me . layoutDone ( layout ) ; if ( layout . completeLayout ) { me . queueCompletion ( layout ) ; } if ( layout . finalizeLayout ) { me . queueFinalize ( layout ) ; } } else if ( ! layout . pending && ! layout . invalid && ! ( layout . blockCount + layout . triggerCount - layout . firedTriggers ) ) { me . queueLayout ( layout ) ; } }
897	function initViewTransformOptions ( file , processOpts , buildManager , isNativeView ) { let plugins = processOpts . plugins ; let { appType , componentConf , buildConf } = buildManager ; if ( isNativeView ) { return Object . assign ( { } , processOpts , { plugins : normalizeViewPlugins ( plugins , appType ) } ) ; } let templateConf = ( componentConf && componentConf . template ) || { } ; if ( ! plugins || ! plugins . length ) { plugins = [ 'syntax' ] ; if ( templateConf . transformTags ) { plugins . push ( 'tagTransform' ) ; } if ( templateConf . useVuePrefix ) { plugins . unshift ( 'vuePrefix' ) ; } } plugins = normalizeViewPlugins ( plugins , appType ) ; let isSupportRef = buildManager . isEnableRefSupport ( ) ; isSupportRef && addBuiltinPlugin ( 'ref' , appType , plugins ) ; let isSupportVHtml = buildManager . isEnableVHtmlSupport ( ) ; isSupportVHtml && addBuiltinPlugin ( 'vhtml' , appType , plugins ) ; addBuiltinPlugin ( 'resource' , appType , plugins , true ) ; processOpts . plugins = plugins ; let filterOptions = buildManager . getFilterTransformOptions ( ) ; if ( filterOptions ) { filterOptions = Object . assign ( { onFilter : handleOnFilter . bind ( null , file ) } , filterOptions ) ; } return Object . assign ( { } , processOpts , { framework : buildConf . framework || [ ] , plugins , filter : filterOptions , template : templateConf , onTag : handleOnTag . bind ( null , file ) } ) ; }
1352	function ScrollAction ( opt_callback , opt_distance_func ) { var self = this ; this . beginMeasuringHook = function ( ) { } this . endMeasuringHook = function ( ) { } this . callback_ = opt_callback ; this . distance_func_ = opt_distance_func ; }
1230	function ( ) { var cid = this . containerId , scroll = "scroll." + cid , resize = "resize." + cid , orient = "orientationchange." + cid , mask , maskCss ; this . container . addClass ( "select2-dropdown-open" ) . addClass ( "select2-container-active" ) ; this . clearDropdownAlignmentPreference ( ) ; if ( this . dropdown [ 0 ] !== this . body ( ) . children ( ) . last ( ) [ 0 ] ) { this . dropdown . detach ( ) . appendTo ( this . body ( ) ) ; } mask = $ ( "#select2-drop-mask" ) ; if ( mask . length == 0 ) { mask = $ ( document . createElement ( "div" ) ) ; mask . attr ( "id" , "select2-drop-mask" ) . attr ( "class" , "select2-drop-mask" ) ; mask . hide ( ) ; mask . appendTo ( this . body ( ) ) ; mask . on ( "mousedown touchstart click" , function ( e ) { var dropdown = $ ( "#select2-drop" ) , self ; if ( dropdown . length > 0 ) { self = dropdown . data ( "select2" ) ; if ( self . opts . selectOnBlur ) { self . selectHighlighted ( { noFocus : true } ) ; } self . close ( ) ; e . preventDefault ( ) ; e . stopPropagation ( ) ; } } ) ; } if ( this . dropdown . prev ( ) [ 0 ] !== mask [ 0 ] ) { this . dropdown . before ( mask ) ; } $ ( "#select2-drop" ) . removeAttr ( "id" ) ; this . dropdown . attr ( "id" , "select2-drop" ) ; maskCss = _makeMaskCss ( ) ; mask . css ( maskCss ) . show ( ) ; this . dropdown . show ( ) ; this . positionDropdown ( ) ; this . dropdown . addClass ( "select2-drop-active" ) ; var that = this ; this . container . parents ( ) . add ( window ) . each ( function ( ) { $ ( this ) . on ( resize + " " + scroll + " " + orient , function ( e ) { var maskCss = _makeMaskCss ( ) ; $ ( "#select2-drop-mask" ) . css ( maskCss ) ; that . positionDropdown ( ) ; } ) ; } ) ; function _makeMaskCss ( ) { return { width : Math . max ( document . documentElement . scrollWidth , $ ( window ) . width ( ) ) , height : Math . max ( document . documentElement . scrollHeight , $ ( window ) . height ( ) ) } } }
2449	function getSameAs ( obj ) { if ( ! obj ) { return false ; } if ( isArray ( obj ) ) { return [ ] ; } if ( isPlainObject ( obj ) ) { return { } ; } if ( isMap ( obj ) ) { return new Map ( ) ; } if ( isSet ( obj ) ) { return new Set ( ) ; } return isFunction ( obj . constructor ) && ! isNative . test ( obj . constructor . toString ( ) ) ? { } : false ; }
3703	function getTotalResultsFromEpochs ( epoch1 , epoch2 ) { var millisecs = Math . abs ( epoch1 - epoch2 ) ; var seconds = millisecs / 1000 ; return { totalSeconds : seconds , totalMinutes : Math . floor ( seconds / 60 ) , totalHours : Math . floor ( seconds / 60 ) * 60 } ; }
1789	function addLocalGulpTasks ( subfile , submodule , tasks ) { var gulpMod = findModule ( function ( mod ) { return ( path . basename ( path . dirname ( mod . id ) ) === 'gulp' ) ; } , submodule ) ; var localInst = gulpMod . exports ; for ( var name in localInst . tasks ) { if ( localInst . tasks . hasOwnProperty ( name ) ) { var task = localInst . tasks [ name ] ; if ( ! task . __hubadded ) { task . __hubadded = true ; addSubtask ( subfile , tasks , task . name , task . dep , task . fn ) ; } } } }
85	function formatTime$1 ( ) { var time = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : 0 ; var inverted = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; if ( ! is$1 . number ( time ) ) { return time ; } var forceHours = getHours ( this . duration ) > 0 ; return formatTime ( time , forceHours , inverted ) ; }
2781	function processPatterns ( patterns , fn ) { var result = [ ] ; _ . flattenDeep ( patterns ) . forEach ( function ( pattern ) { var exclusion = pattern . indexOf ( '!' ) === 0 ; if ( exclusion ) { pattern = pattern . slice ( 1 ) ; } var matches = fn ( pattern ) ; if ( exclusion ) { result = _ . difference ( result , matches ) ; } else { result = _ . union ( result , matches ) ; } } ) ; return result ; }
3527	function ( config , existingEl ) { config = config || { } ; var me = this , dh = Ext . DomHelper , cp = config . parentEl , pel = cp ? Ext . getDom ( cp ) : document . body , hm = config . hideMode , cls = Ext . baseCSSPrefix + ( config . fixed && ! ( Ext . isIE6 || Ext . isIEQuirks ) ? 'fixed-layer' : 'layer' ) ; me . el = me ; if ( existingEl ) { me . dom = Ext . getDom ( existingEl ) ; } if ( ! me . dom ) { me . dom = dh . append ( pel , config . dh || { tag : 'div' , cls : cls } ) ; } else { me . addCls ( cls ) ; if ( ! me . dom . parentNode ) { pel . appendChild ( me . dom ) ; } } if ( config . id ) { me . id = me . dom . id = config . id ; } else { me . id = Ext . id ( me . dom ) ; } Ext . Element . addToCache ( me ) ; if ( config . cls ) { me . addCls ( config . cls ) ; } me . constrain = config . constrain !== false ; if ( hm ) { me . setVisibilityMode ( Ext . Element [ hm . toUpperCase ( ) ] ) ; if ( me . visibilityMode == Ext . Element . ASCLASS ) { me . visibilityCls = config . visibilityCls ; } } else if ( config . useDisplay ) { me . setVisibilityMode ( Ext . Element . DISPLAY ) ; } else { me . setVisibilityMode ( Ext . Element . VISIBILITY ) ; } if ( config . shadow ) { me . shadowOffset = config . shadowOffset || 4 ; me . shadow = new Ext . Shadow ( { offset : me . shadowOffset , mode : config . shadow , fixed : config . fixed } ) ; me . disableShadow ( ) ; } else { me . shadowOffset = 0 ; } me . useShim = config . shim !== false && Ext . useShims ; if ( config . hidden === true ) { me . hide ( ) ; } else { me . show ( ) ; } }
751	function mounted ( ) { if ( ! inBrowser ) { return ; } var dualScreenLeft = $window . screenLeft !== undefined ? $window . screenLeft : screen . left ; var dualScreenTop = $window . screenTop !== undefined ? $window . screenTop : screen . top ; var width = $window . innerWidth ? $window . innerWidth : ( document . documentElement . clientWidth ? document . documentElement . clientWidth : screen . width ) ; var height = $window . innerHeight ? $window . innerHeight : ( document . documentElement . clientHeight ? document . documentElement . clientHeight : screen . height ) ; this . popup . left = ( ( width / 2 ) - ( this . popup . width / 2 ) ) + dualScreenLeft ; this . popup . top = ( ( height / 2 ) - ( this . popup . height / 2 ) ) + dualScreenTop ; }
987	function wrap ( obj , funcName , wrapper ) { obj . prototype [ funcName ] = _ . wrap ( obj . prototype [ funcName ] , wrapper ) ; }
1183	function on ( el , types , fn , context ) { types . split ( ' ' ) . forEach ( function ( type ) { L . DomEvent . on ( el , type , fn , context ) } ) }
2845	function ( property , callback ) { if ( typeof property != "string" ) { callback = property ; property = "__all__" ; } if ( ! this . _subscribers [ property ] ) return ; if ( callback == null ) this . _subscribers [ property ] = [ ] ; var ind = this . _subscribers [ property ] . indexOf ( callback ) ; if ( ind >= 0 ) this . _subscribers [ property ] . splice ( ind , 1 ) ; }
1900	function ( name ) { if ( ! _ . isArray ( name ) ) name = [ name ] ; var names = [ ] , indexes = [ ] ; _ . each ( name , function ( item ) { if ( _ . isString ( item ) ) names . push ( item ) ; else if ( _ . isNumber ( item ) ) indexes . push ( item ) ; } ) ; return _ . filter ( this . list ( ) , function ( attribute , i ) { return _ . include ( indexes , i ) || _ . include ( names , attribute . name ( ) ) ; } ) ; }
2234	function eachItem ( callback ) { function wrappedCallback ( err , data ) { if ( err ) return callback ( err , null ) ; if ( data === null ) return callback ( null , null ) ; var config = this . request . service . paginationConfig ( this . request . operation ) ; var resultKey = config . resultKey ; if ( Array . isArray ( resultKey ) ) resultKey = resultKey [ 0 ] ; var results = AWS . util . jamespath . query ( resultKey , data ) ; AWS . util . arrayEach ( results , function ( result ) { AWS . util . arrayEach ( result , function ( item ) { callback ( null , item ) ; } ) ; } ) ; } this . eachPage ( wrappedCallback ) ; }
3346	function ( styleSheet , selector , cssText ) { var result , ruleSet = styleSheet . cssRules || styleSheet . rules , index = ruleSet . length ; if ( styleSheet . insertRule ) { styleSheet . insertRule ( selector + '{' + cssText + '}' , index ) ; } else { styleSheet . addRule ( selector , cssText || ' ' ) ; } CSS . cacheRule ( result = ruleSet [ index ] , styleSheet ) ; return result ; }
2920	function noMoreTemplates ( ) { registryComplete = true ; Object . keys ( registry ) . forEach ( function ( templateName ) { registry [ templateName ] . reject ( noSuchTemplate ( templateName ) ) ; } ) ; theOnlyTemplate . reject ( noSuchTemplate ( '<default>' ) ) ; }
1357	function _toJson ( next ) { options . xmlConverter ( response . body , options , function ( error , data ) { if ( error ) return next ( error ) ; debug ( 'Parsed XML' , data ) ; timer ( 'time to parsed XML' , Date . now ( ) - _startTime ) ; next ( null , data ) ; } ) ; }
3265	function isArgVariadic ( val , variadic ) { variadic = variadic || constants_1 . VARIADIC_CHAR ; return isArg ( val ) && ( val . endsWith ( variadic + ']' ) || val . endsWith ( variadic + '>' ) ) ; }
1545	function Foscam ( config ) { if ( ! config ) { throw new Error ( 'no config was supplied' ) ; } this . username = config . username ; this . password = config . password ; this . address = config . host ; this . port = config . port || 88 ; this . protocol = config . protocol || 'http' ; this . rejectUnauthorizedCerts = 'rejectUnauthorizedCerts' in config ? config . rejectUnauthorizedCerts : true ; this . baseUrl = this . protocol + '://' + this . address + ':' + this . port ; this . url = this . baseUrl + '/cgi-bin/CGIProxy.fcgi' ; this . streamUrl = this . baseUrl + '/cgi-bin/CGIStream.cgi' ; this . rpClient = rp . defaults ( { rejectUnauthorized : this . rejectUnauthorizedCerts , qs : { usr : this . username , pwd : this . password } } ) ; }
3510	function factory ( name , attrs , fn ) { if ( arguments . length === 2 ) { fn = attrs ; attrs = null ; } factories . get ( name ) . create ( attrs , fn ) ; }
1827	function version ( ) { const url = ` ${ config . api_url } ` ; const method = 'GET' ; const headers = default_headers ( ) ; const options = Object . assign ( { } , headers , { url , method } ) ; return request ( options ) ; }
2912	function ( obj , meta ) { var val , parentId ; if ( undefined === obj || util . isPrimitive ( obj ) ) { return { proxied : obj , raw : obj } ; } val = this . proxiedToTVar . get ( obj ) ; if ( undefined === val ) { val = this . objToTVar . get ( obj ) ; if ( undefined === val ) { this . tVarCount += 1 ; val = new TVar ( this . tVarCount , obj , this ) ; this . proxiedToTVar . set ( val . proxied , val ) ; this . objToTVar . set ( obj , val ) ; this . idToTVar [ val . id ] = val ; this . recordCreation ( val , meta ) ; return val ; } else { return val ; } } else { return val ; } }
221	function isPendingSyncStart ( state , siteId ) { const syncStatus = getSyncStatus ( state , siteId ) ; const fullSyncRequest = getFullSyncRequest ( state , siteId ) ; const isScheduled = get ( syncStatus , 'is_scheduled' ) ; if ( isScheduled ) { return true ; } const requestingFullSync = get ( fullSyncRequest , 'isRequesting' ) || get ( fullSyncRequest , 'scheduled' ) ; if ( ! requestingFullSync ) { return false ; } const lastRequested = get ( fullSyncRequest , 'lastRequested' ) ; const lastSuccessfulStatus = get ( syncStatus , 'lastSuccessfulStatus' ) ; if ( ! lastSuccessfulStatus ) { return true ; } return parseInt ( lastRequested , 10 ) > parseInt ( lastSuccessfulStatus , 10 ) ; }
3537	function clientReadyMessage ( cookies , user , pass ) { return { type : 'connected' , user : user , sessionID : cookies . sessionID , pass : pass } }
1421	function parseDb ( data , cb ) { if ( data && data . trim ( ) . length ) { log . debug ( "Parsing database" ) ; t . __db = jsonlint . parse ( data ) ; } else { log . debug ( "No database to parse" ) ; t . __db = { } ; } cb ( null , t . __db ) ; }
1096	function listenToIpc ( channel ) { return Observable . create ( ( subj ) => { let listener = ( event , ... args ) => { d ( ` ${ channel } ${ JSON . stringify ( args ) } ` ) ; subj . next ( args ) ; } ; d ( ` ${ channel } ` ) ; ipc . on ( channel , listener ) ; return new Subscription ( ( ) => ipc . removeListener ( channel , listener ) ) ; } ) ; }
1528	function spawnCancelableChild ( bin , args , option ) { let innerCancel = null ; let isCanceled = false ; const canceller = function ( ) { if ( isCanceled ) { return ; } isCanceled = true ; if ( typeof innerCancel === 'function' ) { innerCancel ( ) ; } } ; const process = new Promise ( function ( resolve , reject ) { if ( isCanceled ) { reject ( ) ; return ; } console . log ( 'spawn: ' + bin + ' ' + args . join ( ' ' ) ) ; const proc = childProcess . spawn ( bin , args , option ) ; innerCancel = function ( ) { proc . kill ( 'SIGINT' ) ; } ; proc . on ( 'exit' , function ( status ) { resolve ( status ) ; } ) ; } ) ; return { canceller , process , } ; }
1068	function ( ) { var params = { } , fetchOptions , fetchSpec ; if ( this . options . fetch_params ) { if ( ! _ . isObject ( this . options . fetch_params ) ) { throw new Error ( 'fetch_params must be an object for lazy loaded views' ) ; } params = this . options . fetch_params ; } else if ( this . options . param_name ) { params [ this . options . param_name ] = this . options . param_value ; } if ( this . options . fetch_options ) { if ( ! _ . isObject ( this . options . fetch_options ) ) { throw new Error ( 'fetch_options must be an object for lazy loaded views' ) ; } fetchOptions = this . options . fetch_options ; } if ( this . options . model_id != null ) { params . id = this . options . model_id ; } if ( this . options . model_name != null ) { fetchSpec = { model : { model : this . options . model_name , params : params } } ; } else if ( this . options . collection_name != null ) { fetchSpec = { collection : { collection : this . options . collection_name , params : params } } ; } if ( this . options . fetch_spec ) { if ( ! _ . isObject ( this . options . fetch_spec ) ) { throw new Error ( 'fetch_spec must be an object for lazy loaded views' ) ; } fetchSpec = this . options . fetch_spec ; } this . setLoading ( true ) ; this . _preRender ( ) ; this . app . fetch ( fetchSpec , fetchOptions , this . _fetchLazyCallback . bind ( this ) ) ; }
664	function ( text , locale ) { text = text . toLocaleLowerCase ( ) ; var words = getWords ( text ) ; var syllableCounts = map ( words , function ( word ) { return countSyllablesInWord ( word , locale ) ; } ) ; return sum ( syllableCounts ) ; }
2990	function shouldFetchContents ( state , scsId ) { const page = state . pages [ scsId ] ; if ( page . contents . length === 0 ) { return true } else if ( page . isFetching ) { return false } else { return page . didInvalidate } }
37	function fill ( obj , name , replacement , track ) { if ( obj == null ) return ; var orig = obj [ name ] ; obj [ name ] = replacement ( orig ) ; obj [ name ] . __raven__ = true ; obj [ name ] . __orig__ = orig ; if ( track ) { track . push ( [ obj , name , orig ] ) ; } }
3464	function ( options , success , response ) { var me = this , i , len , events , event , transaction , transactions ; if ( success ) { events = me . createEvents ( response ) ; for ( i = 0 , len = events . length ; i < len ; ++ i ) { event = events [ i ] ; transaction = me . getTransaction ( event ) ; me . fireEvent ( 'data' , me , event ) ; if ( transaction && me . fireEvent ( 'beforecallback' , me , event , transaction ) !== false ) { me . runCallback ( transaction , event , true ) ; Ext . direct . Manager . removeTransaction ( transaction ) ; } } } else { transactions = [ ] . concat ( options . transaction ) ; for ( i = 0 , len = transactions . length ; i < len ; ++ i ) { transaction = me . getTransaction ( transactions [ i ] ) ; if ( transaction && transaction . retryCount < me . maxRetries ) { transaction . retry ( ) ; } else { event = new Ext . direct . ExceptionEvent ( { data : null , transaction : transaction , code : Ext . direct . Manager . exceptions . TRANSPORT , message : 'Unable to connect to the server.' , xhr : response } ) ; me . fireEvent ( 'data' , me , event ) ; if ( transaction && me . fireEvent ( 'beforecallback' , me , transaction ) !== false ) { me . runCallback ( transaction , event , false ) ; Ext . direct . Manager . removeTransaction ( transaction ) ; } } } } }
3726	function getProperty ( objNode , name ) { for ( var i = 0 ; i < objNode . properties . length ; i ++ ) { if ( getKey ( objNode . properties [ i ] ) === name ) { return getValue ( objNode . properties [ i ] ) ; } } }
1966	function signout ( { username , password } ) { return fetch ( ` ${ YGGDRASIL_API } ` , { method : 'POST' , body : JSON . stringify ( { username , password } ) , headers : { 'user-agent' : USER_AGENT , 'content-type' : 'application/json' , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => null ) }
1036	function hookSyncCycle ( rs ) { if ( rs . _dropboxOrigSyncCycle ) { return ; } rs . _dropboxOrigSyncCycle = rs . syncCycle ; rs . syncCycle = ( ) => { if ( rs . sync ) { hookSync ( rs ) ; rs . _dropboxOrigSyncCycle ( arguments ) ; unHookSyncCycle ( rs ) ; } else { throw new Error ( 'expected sync to be initialized by now' ) ; } } ; }
2029	function ( distroName ) { logger . raw ( '\n\x1B[36m* ' + \n + \x1B ) ; distroName '\x1B[39m' \x1B }
156	function ( post ) { if ( ! post ) { return null ; } const isSharedPublicly = getValueByKey ( post . metadata , 'geo_public' ) ; if ( parseInt ( isSharedPublicly , 10 ) ) { return true ; } if ( undefined === isSharedPublicly ) { if ( getValueByKey ( post . metadata , 'geo_latitude' ) || getValueByKey ( post . metadata , 'geo_longitude' ) ) { return false ; } return true ; } return false ; }
1143	function bindAll ( object ) { var funcs = arguments . length > 1 ? baseFlatten ( arguments , true , false , 1 ) : functions ( object ) , index = - 1 , length = funcs . length ; while ( ++ index < length ) { var key = funcs [ index ] ; object [ key ] = createBound ( object [ key ] , 1 , null , null , object ) ; } return object ; }
3777	function doppler ( it ) { return __asyncGenerator ( this , arguments , function * doppler_1 ( ) { var e_27 , _a ; const buffer = [ ] ; try { for ( var it_7 = __asyncValues ( it ) , it_7_1 ; it_7_1 = yield __await ( it_7 . next ( ) ) , ! it_7_1 . done ; ) { const item = it_7_1 . value ; buffer . push ( item ) ; yield yield __await ( item ) ; } } catch ( e_27_1 ) { e_27 = { error : e_27_1 } ; } finally { try { if ( it_7_1 && ! it_7_1 . done && ( _a = it_7 . return ) ) yield __await ( _a . call ( it_7 ) ) ; } finally { if ( e_27 ) throw e_27 . error ; } } buffer . reverse ( ) ; yield __await ( yield * __asyncDelegator ( __asyncValues ( buffer ) ) ) ; } ) ; }
1404	function ReadableStreamDefaultControllerClose ( controller ) { const stream = controller . _controlledReadableStream ; assert ( controller . _closeRequested === false ) ; assert ( stream . _state === 'readable' ) ; controller . _closeRequested = true ; if ( controller . _queue . length === 0 ) { ReadableStreamClose ( stream ) ; } }
3800	function TriangleCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 6 ) throw new SyntaxError ( 'TRIANGLE command requires 6 arguments' ) ; this . x1 = parsed . args [ 0 ] ; this . y1 = parsed . args [ 1 ] ; this . x2 = parsed . args [ 2 ] ; this . y2 = parsed . args [ 3 ] ; this . x3 = parsed . args [ 4 ] ; this . y3 = parsed . args [ 5 ] ; this . stroke = parsed . args . length > 6 ? parsed . args [ 6 ] : false ; }
289	function getEmailForwardingSupportedDomains ( domains ) { return domains . filter ( function ( domain ) { const domainHasGSuite = hasGSuite ( domain ) ; const wpcomHosted = includes ( [ domainTypes . REGISTERED ] , domain . type ) && domain . hasWpcomNameservers ; const mapped = includes ( [ domainTypes . MAPPED ] , domain . type ) ; return ( wpcomHosted || mapped ) && ! domainHasGSuite ; } ) ; }
2734	function ( object , options ) { var created = typeof this . cache [ object . _id ] === 'undefined' this . cache [ object . _id ] = object return { created : created , val : object } }
292	function ( themeId ) { const query = { action : 'theme_information' , 'request[fields][extended_author]' : true , 'request[slug]' : themeId , } ; return superagent . get ( WPORG_THEMES_ENDPOINT ) . set ( 'Accept' , 'application/json' ) . query ( query ) . then ( ( { body } ) => body ) ; }
1142	function bind ( func , thisArg ) { return arguments . length > 2 ? createBound ( func , 17 , nativeSlice . call ( arguments , 2 ) , null , thisArg ) : createBound ( func , 1 , null , null , thisArg ) ; }
2270	function liftFeedbackLoop ( loops , mappings ) { return function ( outerState , scheduler ) { var embededLoops = loops . map ( function ( loop ) { return loop ( outerState . pipe ( map_1 . map ( mappings . mapState ) ) , scheduler ) . pipe ( map_1 . map ( mappings . mapEvent ) ) ; } ) ; return rx . merge . apply ( rx , embededLoops ) ; } ; }
3203	function iterateElements ( array ) { var index = 0 ; var rv = { } ; rv [ Symbol . iterator ] = { next ( ) { if ( index < array . length ) return { value : array [ index ++ ] , done : false } ; return { done : true } ; } } }
1185	function buildConfig ( wantedEnv ) { let isValid = wantedEnv && wantedEnv . length > 0 && allowedEnvs . indexOf ( wantedEnv ) !== - 1 ; let validEnv = isValid ? wantedEnv : 'dev' ; let config = require ( path . join ( __dirname , 'cfg/' + validEnv ) ) ; return config ; }
1125	function isMasterExternalValueOk ( masterId , instances ) { const instanceIds = Object . keys ( instances ) ; let instance ; let hasExternal ; for ( let i = 0 ; i < instanceIds . length ; i ++ ) { instance = instances [ instanceIds [ i ] ] ; if ( instance . external ) { hasExternal = true ; break ; } } if ( hasExternal ) { return ! ! instances [ masterId ] . external ; } return true ; }
1491	function ( filename ) { return new Promise ( ( resolve , reject ) => { fs . stat ( filename , function ( err , stats ) { if ( err && err . code != "ENOENT" ) { reject ( err ) ; } else { resolve ( err ? null : stats ) ; } } ) ; } ) ; }
1805	function uki ( val , context ) { if ( typeof val === "string" ) { return selector . find ( val , context ) ; } if ( val . length === undefined ) { val = [ val ] ; } if ( val . length > 0 && utils . isFunction ( val [ 0 ] . typeName ) ) { return new collection . Collection ( val ) ; } return builder . build ( val ) ; }
2620	function _implements ( ) { var args = libs . object . toArray ( arguments ) , a = args . shift ( ) ; if ( ! a ) return false ; return libs . object . every ( args , function ( m ) { if ( ! ( a [ m ] instanceof Function ) ) return false ; } ) ; }
3441	function getNonEditableParent ( node ) { var state ; while ( node ) { state = getContentEditable ( node ) ; if ( state ) { return state === "false" ? node : null ; } node = node . parentNode ; } }
3471	function addCustomElements ( custom_elements ) { var customElementRegExp = / ^(~)?(.+)$ / ; if ( custom_elements ) { each ( split ( custom_elements ) , function ( rule ) { var matches = customElementRegExp . exec ( rule ) , inline = matches [ 1 ] === '~' , cloneName = inline ? 'span' : 'div' , name = matches [ 2 ] ; children [ name ] = children [ cloneName ] ; customElementsMap [ name ] = cloneName ; if ( ! inline ) { blockElementsMap [ name . toUpperCase ( ) ] = { } ; blockElementsMap [ name ] = { } ; } if ( ! elements [ name ] ) { elements [ name ] = elements [ cloneName ] ; } each ( children , function ( element , child ) { if ( element [ cloneName ] ) element [ name ] = element [ cloneName ] ; } ) ; } ) ; } }
2513	function getName ( fileId , isFile ) { var splitted = fileId . split ( '/' ) ; var filename = splitted [ splitted . length - 1 ] ; if ( ! isFile ) return filename ; filename = filename . split ( '.' ) ; if ( filename . length === 1 ) return filename [ 0 ] ; filename . pop ( ) ; return filename . join ( '.' ) ; }
3033	function ( body ) { var me = this ; me . body = body ; if ( ! Ext . data . flash . BinaryXhr . flashPluginActive ) { Ext . globalEvents . addListener ( "flashready" , me . onFlashReady , me ) ; } else { this . onFlashReady ( ) ; } }
953	function initLocalPolyfillPlugins ( polyfills , plugins ) { polyfills . forEach ( item => { let pluginItem = polyfillPlugin [ item . type ] ; plugins . push ( [ pluginItem , { polyfill : item } ] ) ; } ) ; }
1797	function RemoteReadableStream ( process , daemon , ackHeaderFunc ) { stream . Readable . call ( this ) ; this . process = process ; this . daemon = daemon ; this . ackHeaderFunc = ackHeaderFunc ; this . credit = 0 ; this . closed = false ; this . resume ( ) ; this . on ( 'incoming' , ( data ) => this . handleIncoming ( data ) ) ; }
2062	function ( toolKey , toolDefinition , toolbarKey , group , index ) { taRegisterTool ( toolKey , toolDefinition ) ; toolbars [ toolbarKey ] . addTool ( toolKey , toolDefinition , group , index ) ; }
467	function buildReverseIndex ( obj ) { let warnCollisions = [ ] ; for ( let k in obj ) { checkAmbiguous ( k ) ; if ( obj [ k ] . match ) { for ( let i = obj [ k ] . match . length - 1 ; i >= 0 ; i -- ) { let match = obj [ k ] . match [ i ] ; checkAmbiguous ( match ) ; if ( rIndex [ match ] ) { warnCollisions . push ( [ rIndex [ match ] , match ] ) ; warnCollisions . push ( [ k , match ] ) ; } rIndex [ match ] = k ; } } } if ( warnCollisions . length ) { console . warn ( colors . yellow ( '\nWarning - match name collisions' ) ) ; \n console . warn ( 'To resolve these, make sure multiple entries do not contain the same "match" property.' ) ; } }
2298	function getDatetimeUnit ( min , max ) { const diff = max . diff ( min , 'days' ) ; let unit = 'month' ; if ( diff <= 14 ) { unit = 'day' ; } else if ( diff > 14 && diff <= 183 ) { unit = 'week' ; } return unit ; }
967	function compile ( file , options ) { const { resolve : resolveDep , logger } = options ; try { let componentConf = JSON . parse ( file . content . toString ( ) ) ; let usingComponents = componentConf [ USING_COMPONENT_KEY ] ; if ( ! usingComponents || ! file . component ) { return { content : file . content } ; } let result = { } ; let scriptFile = file . component ; Object . keys ( usingComponents ) . forEach ( k => { let value = usingComponents [ k ] ; if ( ! value ) { return ; } let resolvePath = resolveDep ( scriptFile , value ) ; result [ toHyphen ( k ) ] = resolvePath || value ; let resolveModInfo = scriptFile . resolvedModIds [ value ] ; let componentFile = resolveModInfo && resolveModInfo . file ; componentFile && analyseNativeComponent ( componentFile , options ) ; } ) ; componentConf [ USING_COMPONENT_KEY ] = result ; return { content : JSON . stringify ( componentConf , null , 4 ) } ; } catch ( ex ) { logger . error ( ` ${ file . path } ` , ex . stack || ex . toString ( ) ) ; } return { content : file . content } ; }
486	function createDefaultSetter ( key ) { return function set ( newValue ) { _Object$defineProperty ( this , key , { configurable : true , writable : true , enumerable : true , value : newValue } ) ; return newValue ; } ; }
489	function autobind ( obj , prop , descriptor ) { if ( arguments . length === 1 ) return autobindClass ( ) ( obj ) ; var _ref = descriptor || { } , fn = _ref . value , configurable = _ref . configurable ; if ( ! isFunction ( fn ) ) { throw new TypeError ( '@autobind can only be used on functions, not "' + fn + '" in ' + ( typeof fn === 'undefined' ? 'undefined' : _typeof ( fn ) ) + ' on property "' + prop + '"' ) ; } var constructor = obj . constructor ; return { configurable : configurable , enumerable : false , get : function get ( ) { var _this = this ; var boundFn = function boundFn ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } return fn . call . apply ( fn , [ _this ] . concat ( _toConsumableArray ( args ) ) ) ; } ; if ( this === obj ) { return fn ; } if ( this . constructor !== constructor && _Object$getPrototypeOf ( this ) . constructor === constructor ) { return fn ; } if ( this . constructor !== constructor && prop in this . constructor . prototype ) { return getBoundSuper ( this , fn ) ; } _Object$defineProperty ( this , prop , { configurable : true , writable : true , enumerable : false , value : boundFn } ) ; return boundFn ; } , set : createDefaultSetter ( prop ) } ; }
1086	function removeEventListeners ( el , eventName , handlers ) { var handler ; var i ; if ( ! handlers ) { return ; } if ( handlers . constructor === Function ) { handlers = [ handlers ] ; } for ( i = 0 ; i < handlers . length ; i ++ ) { el . removeEventListener ( eventName , handlers [ i ] ) ; } }
1302	function FindFunctionInfos ( compile_info ) { var wrappers = [ ] ; for ( var i = 0 ; i < shared_infos . length ; i ++ ) { var wrapper = shared_infos [ i ] ; if ( wrapper . start_position == compile_info . start_position && wrapper . end_position == compile_info . end_position ) { wrappers . push ( wrapper ) ; } } if ( wrappers . length > 0 ) { return wrappers ; } }
1072	function unmarshalPublicKey ( curve , key ) { const byteLen = curveLengths [ curve ] if ( ! key . slice ( 0 , 1 ) . equals ( Buffer . from ( [ 4 ] ) ) ) { throw new Error ( 'Invalid key format' ) } const x = new BN ( key . slice ( 1 , byteLen + 1 ) ) const y = new BN ( key . slice ( 1 + byteLen ) ) return { kty : 'EC' , crv : curve , x : toBase64 ( x , byteLen ) , y : toBase64 ( y , byteLen ) , ext : true } }
2980	function execute ( target , prop , ... args ) { return _ . isFunction ( target [ prop ] ) ? target [ prop ] ( ... args ) : target [ prop ] ; }
1718	function _haltItemAtFrame ( item , perc ) { item . mod . halt ( ) ; item . halted = true ; if ( item . startSpec && ( perc !== undefined ) ) { if ( ( item . startSpec . opacity !== undefined ) && ( item . endSpec . opacity !== undefined ) ) { item . mod . setOpacity ( _interpolate ( item . startSpec . opacity , item . endSpec . opacity , perc ) ) ; } if ( item . startSpec . transform && item . endSpec . transform ) { var transform = [ ] ; for ( var i = 0 ; i < item . startSpec . transform . length ; i ++ ) { transform . push ( _interpolate ( item . startSpec . transform [ i ] , item . endSpec . transform [ i ] , perc ) ) ; } item . mod . setTransform ( transform ) ; } } }
3864	function changePosition ( el , index ) { var HTMLElement = el . el ; if ( HTMLElement && HTMLElement . parentNode ) { var parentNode = HTMLElement . parentNode , elGroup = el . elGroup , size = elGroup . size , target = elGroup . getKeyByIndex ( index ) || elGroup . getLast ( ) ; if ( target !== HTMLElement ) { if ( size - 1 >= index ) { parentNode . insertBefore ( HTMLElement , target ) ; } else if ( target . nextSibling !== null ) { parentNode . insertBefore ( HTMLElement , target . nextSibling ) ; } else { parentNode . appendChild ( HTMLElement ) ; } el . elGroup . changeIndex ( HTMLElement , index ) ; } } }
1856	function ( ) { if ( global . console && global . console . log ) global . console . log . apply ( global . console , arguments ) ; }
332	function setAspectRatio ( aspectRatio ) { var options = this . options ; if ( ! this . disabled && ! isUndefined ( aspectRatio ) ) { options . aspectRatio = Math . max ( 0 , aspectRatio ) || NaN ; if ( this . ready ) { this . initCropBox ( ) ; if ( this . cropped ) { this . renderCropBox ( ) ; } } } return this ; }
2376	function ( datasetId , params , callback ) { var interceptor = requestInterceptors [ datasetId ] || defaults . requestInterceptor ; return interceptor ( datasetId , params , callback ) ; }
2221	function getFrameworkPath ( { framework , baseDir } ) { const pkgPath = path . join ( baseDir , 'package.json' ) ; assert ( fs . existsSync ( pkgPath ) , ` ${ pkgPath } ` ) ; const moduleDir = path . join ( baseDir , 'node_modules' ) ; const pkg = utility . readJSONSync ( pkgPath ) ; if ( framework ) { if ( path . isAbsolute ( framework ) ) { assert ( fs . existsSync ( framework ) , ` ${ framework } ` ) ; return framework ; } return assertAndReturn ( framework , moduleDir ) ; } if ( pkg . egg && pkg . egg . framework ) { return assertAndReturn ( pkg . egg . framework , moduleDir ) ; } return assertAndReturn ( 'egg' , moduleDir ) ; }
1618	function parse_status_block ( block ) { var match ; var parsed = { } ; if ( ( match = block . match ( / bssid=([A-Fa-f0-9:]{17}) / ) ) ) { parsed . bssid = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = block . match ( / freq=([0-9]+) / ) ) ) { parsed . frequency = parseInt ( match [ 1 ] , 10 ) ; } if ( ( match = block . match ( / mode=([^\s]+) / ) ) ) { parsed . mode = match [ 1 ] ; } if ( ( match = block . match ( / key_mgmt=([^\s]+) / ) ) ) { parsed . key_mgmt = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = block . match ( / [^b]ssid=([^\n]+) / ) ) ) { parsed . ssid = match [ 1 ] ; } if ( ( match = block . match ( / [^b]pairwise_cipher=([^\n]+) / ) ) ) { parsed . pairwise_cipher = match [ 1 ] ; } if ( ( match = block . match ( / [^b]group_cipher=([^\n]+) / ) ) ) { parsed . group_cipher = match [ 1 ] ; } if ( ( match = block . match ( / p2p_device_address=([A-Fa-f0-9:]{17}) / ) ) ) { parsed . p2p_device_address = match [ 1 ] ; } if ( ( match = block . match ( / wpa_state=([^\s]+) / ) ) ) { parsed . wpa_state = match [ 1 ] ; } if ( ( match = block . match ( / ip_address=([^\n]+) / ) ) ) { parsed . ip = match [ 1 ] ; } if ( ( match = block . match ( / [^_]address=([A-Fa-f0-9:]{17}) / ) ) ) { parsed . mac = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = block . match ( / uuid=([^\n]+) / ) ) ) { parsed . uuid = match [ 1 ] ; } if ( ( match = block . match ( / [^s]id=([0-9]+) / ) ) ) { parsed . id = parseInt ( match [ 1 ] , 10 ) ; } return parsed ; }
3044	function listener ( bot ) { return function ( buffer ) { var line = buffer . toString ( ) ; var truncatedLine = line . slice ( 0 , line . length - 1 ) ; if ( current_actions && ! isNaN ( parseInt ( truncatedLine ) ) && parseInt ( truncatedLine ) < current_actions . length ) { var action = current_actions [ parseInt ( truncatedLine ) ] ; current_actions = null ; if ( typeof action === "string" ) { bot ( platform , { sessionId : sessionId } , { type : 'action' , message : action , action : action } , oncomplete ) ; } else if ( action . url ) { request ( action . url , function ( error , response , body ) { var article = unfluff ( body ) ; console . log ( bot_name + ' > Processed Body For ' + article . title ) ; console . log ( '\n' + \n + article . text ) ; '\n' } ) ; } else \n } else oncomplete ( null , null , null , function ( ) { } ) ; } ; }
3828	function ( value ) { if ( this . _label ) this . _label . text ( value ) ; else this . _label = $ . create ( 'label' ) . attr ( 'for' , this . getAttr ( 'id' ) ) . prependTo ( this . _container ) . text ( value ) ; return this ; }
134	function ( str ) { const args = arguments let flag = true let i = 1 str = str . replace ( / %s / g , ( ) => { const arg = args [ i ++ ] if ( typeof arg === 'undefined' ) { flag = false return '' } return arg } ) return flag ? str : '' }
3048	function ( config ) { var me = this , comp ; if ( arguments . length === 2 ) { if ( Ext . isDefined ( Ext . global . console ) ) { Ext . global . console . warn ( 'Ext.LoadMask: LoadMask now uses a standard 1 arg constructor: use the target config' ) ; } comp = config ; config = arguments [ 1 ] ; } else { comp = config . target ; } if ( ! comp . isComponent ) { if ( Ext . isDefined ( Ext . global . console ) ) { Ext . global . console . warn ( 'Ext.LoadMask: LoadMask for elements has been deprecated, use Ext.dom.Element.mask & Ext.dom.Element.unmask' ) ; } comp = Ext . get ( comp ) ; this . isElement = true ; } me . ownerCt = comp ; if ( ! this . isElement ) { me . bindComponent ( comp ) ; } me . callParent ( [ config ] ) ; if ( me . store ) { me . bindStore ( me . store , true ) ; } }
1297	function PromiseHasUserDefinedRejectHandlerCheck ( handler , deferred ) { if ( handler !== PromiseIdRejectHandler ) { var combinedDeferred = GET_PRIVATE ( handler , promiseCombinedDeferredSymbol ) ; if ( IS_UNDEFINED ( combinedDeferred ) ) return true ; if ( PromiseHasUserDefinedRejectHandlerRecursive ( combinedDeferred . promise ) ) { return true ; } } else if ( PromiseHasUserDefinedRejectHandlerRecursive ( deferred . promise ) ) { return true ; } return false ; }
3428	function ( array , fn , scope ) { var i = 0 , len = array . length ; for ( ; i < len ; i ++ ) { if ( fn . call ( scope || array , array [ i ] , i ) ) { return array [ i ] ; } } return null ; }
3119	function ( syncId , blockCb , makeCb , reifyCb , cb ) { _ . assertLength ( arguments , 5 ) _ . assertFunction ( blockCb ) _ . assertFunction ( makeCb ) _ . assertFunction ( reifyCb ) _ . assertFunction ( cb ) ; _ . assertString ( syncId ) var e = { syncId : syncId } ; log ( 'BEGAN SYNC CLIENT' ) w . beginSync ( e ) ; syncListenersBySyncId [ syncId ] = { block : blockCb , make : makeCb , reify : reifyCb } cb ( makeSyncHandle ( syncId , makeCb ) ) }
1934	function parseLinearGradient ( gradient ) { var direction = defaultLinearDirections [ 0 ] ; var stream = require ( 'stringStream' ) . create ( require ( 'utils' ) . trim ( gradient ) ) ; var colorStops = [ ] , ch ; while ( ch = stream . next ( ) ) { if ( stream . peek ( ) == ',' ) { colorStops . push ( stream . current ( ) ) ; stream . next ( ) ; stream . eatSpace ( ) ; stream . start = stream . pos ; } else if ( ch == '(' ) { stream . skipTo ( ')' ) ; } } colorStops . push ( stream . current ( ) ) ; colorStops = _ . compact ( _ . map ( colorStops , normalizeSpace ) ) ; if ( ! colorStops . length ) return null ; if ( reDeg . test ( colorStops [ 0 ] ) || reKeyword . test ( colorStops [ 0 ] ) ) { direction = colorStops . shift ( ) ; } return { type : 'linear' , direction : direction , colorStops : _ . map ( colorStops , parseColorStop ) } ; }
3851	function ExecutionContext ( options ) { EventEmitter . call ( this ) ; this . stringVars = { } ; this . numberVars = { } ; this . pointers = { } ; this . gosubs = [ ] ; this . private = { rnd_seed : Math . random ( ) , sprites : [ ] , data : [ ] } ; this . constants = require ( './constants' ) ; this . running = false ; options = options || { } ; this . options = options ; if ( typeof options . delay === 'undefined' ) options . delay = false ; for ( var k in functions ) { if ( ! functions . hasOwnProperty ( k ) ) continue ; this . constants [ k ] = functions [ k ] ; } this . constants = pUtil . shallowClone ( this . constants ) ; }
1102	function ( str , gsa ) { if ( gsa . length !== 19 && gsa . length !== 20 ) { throw new Error ( 'Invalid GSA length: ' + str ) ; } var sats = [ ] ; for ( var i = 3 ; i < 15 ; i ++ ) { if ( gsa [ i ] !== '' ) { sats . push ( parseInt ( gsa [ i ] , 10 ) ) ; } } return { 'mode' : parseGSAMode ( gsa [ 1 ] ) , 'fix' : parseGSAFix ( gsa [ 2 ] ) , 'satellites' : sats , 'pdop' : parseNumber ( gsa [ 15 ] ) , 'hdop' : parseNumber ( gsa [ 16 ] ) , 'vdop' : parseNumber ( gsa [ 17 ] ) , 'systemId' : gsa . length > 19 ? parseNumber ( gsa [ 18 ] ) : null } ; }
2373	function applyPendingChange ( pendingChange , tries , callback ) { var datasetId = pendingChange . datasetId ; if ( ! datasetId || ! pendingChange . action || ! pendingChange . uid || ! pendingChange . cuid || ! pendingChange . hash ) { debugError ( "[%s] invalid pendingChange request dropped :: item = %j" , datasetId , pendingChange ) ; return callback ( ) ; } debug ( '[%s] processPending :: item = %j' , datasetId , pendingChange ) ; if ( tries > retryLimit ) { debugError ( '[%s] processPending failed :: tries = %d :: item = %j' , datasetId , tries , pendingChange ) ; return saveUpdate ( datasetId , pendingChange , SYNC_UPDATE_TYPES . FAILED , "crashed" , callback ) ; } pendingChange . tries = tries ; var action = pendingChange . action . toLowerCase ( ) ; var timer = metrics . startTimer ( ) ; function onComplete ( err ) { metricsClient . gauge ( metrics . KEYS . PENDING_CHANGE_PROCESS_TIME , { success : ! err , action : action } , timer . stop ( ) ) ; return callback ( err ) ; } switch ( action ) { case "create" : doCreate ( datasetId , pendingChange , onComplete ) ; break ; case "update" : doUpdate ( datasetId , pendingChange , onComplete ) ; break ; case "delete" : doDelete ( datasetId , pendingChange , onComplete ) ; break ; default : debugError ( "[%s] invalid pendingChange request dropped :: item = %j" , datasetId , pendingChange ) ; return onComplete ( ) ; } }
3212	function ( ) { if ( / \w / . test ( this . currentChar ) ) return this . readWord ( ) ; if ( / ["'`] / . test ( this . currentChar ) ) return this . readString ( ) ; if ( / [()] / . test ( this . currentChar ) ) return this . readGroupSymbol ( ) ; if ( / [!=<>] / . test ( this . currentChar ) ) return this . readOperator ( ) ; if ( this . currentChar === "" ) return { type : 'eot' , value : '' } ; else { this . readNextChar ( ) ; return { type : 'empty' , value : '' } ; } }
574	function info ( msg ) { if ( PDFJS . verbosity >= PDFJS . VERBOSITY_LEVELS . infos ) { console . log ( 'Info: ' + msg ) ; } }
1931	function parseList ( list ) { var result = _ . map ( ( list || '' ) . split ( ',' ) , require ( 'utils' ) . trim ) ; return result . length ? result : null ; }
1212	function getAuthorizationHeader ( realm , parameters ) { var header = 'OAuth realm="' + OAuth . percentEncode ( realm ) + '"' ; var list = OAuth . getParameterList ( parameters ) ; for ( var p = 0 ; p < list . length ; ++ p ) { var parameter = list [ p ] ; var name = parameter [ 0 ] ; if ( name . indexOf ( "oauth_" ) == 0 ) { header += ',' + OAuth . percentEncode ( name ) + '="' + OAuth . percentEncode ( parameter [ 1 ] ) + '"' ; } } return header ; }
390	function onOutputError ( err ) { if ( err . code === 'EACCES' ) { console . error ( err . path + " is not writable. Skipping!" ) ; } else { console . error ( err ) ; process . exit ( 0 ) ; } }
11	function rawjs ( opts ) { opts = opts || { } return { transform : ( code , id ) => { var variable = opts [ id . split ( '/' ) . pop ( ) ] if ( ! variable ) return code var keepStr = '/*rollup-keeper-start*/window.tmp=' + variable + ';/*rollup-keeper-end*/' return code + keepStr } , transformBundle : ( code ) => { for ( var file in opts ) { var r = new RegExp ( opts [ file ] + '\\$\\d+' , \\ ) \\ } 'g' code = code . replace ( r , opts [ file ] ) } } }
315	function dataURLToArrayBuffer ( dataURL ) { var base64 = dataURL . replace ( REGEXP_DATA_URL_HEAD , '' ) ; var binary = atob ( base64 ) ; var arrayBuffer = new ArrayBuffer ( binary . length ) ; var uint8 = new Uint8Array ( arrayBuffer ) ; forEach ( uint8 , function ( value , i ) { uint8 [ i ] = binary . charCodeAt ( i ) ; } ) ; return arrayBuffer ; }
247	function deepRemoveUndefinedKeysFromObject ( obj ) { for ( let key in obj ) { if ( obj . hasOwnProperty ( key ) ) { if ( _ . isUndefined ( obj [ key ] ) ) { delete obj [ key ] ; } else if ( _ . isObject ( obj [ key ] ) ) { deepRemoveUndefinedKeysFromObject ( obj [ key ] ) ; } } } return obj ; }
3356	function ( e , el ) { var key = e . getKey ( ) ; if ( key === e . ENTER || ( key === e . TAB && this . selectOnTab ) ) { this . selectItem ( this . picker . getSelectionModel ( ) . getSelection ( ) [ 0 ] ) ; } }
3714	function ShapeCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 3 ) throw new SyntaxError ( 'SHAPE command requires 3 arguments' ) ; this . pointsLength = parsed . args [ 0 ] ; this . pointsX = parsed . args [ 1 ] ; this . pointsY = parsed . args [ 2 ] ; this . stroke = parsed . args . length > 3 ? parsed . args [ 3 ] : false ; }
854	function filterNeverIgnoredFiles ( p ) { const basedir = path . dirname ( p . filePath ) const mainFilePath = typeof p . main === "string" ? path . join ( basedir , p . main ) : null return filePath => path . join ( basedir , filePath ) !== mainFilePath && filePath !== "package.json" && ! NEVER_IGNORED . test ( path . relative ( basedir , filePath ) ) }
3633	function clean ( action , result , req , res , cb ) { if ( options . clean ) { return options . clean . apply ( this , arguments ) ; } return cb && cb ( ) ; }
3248	function makePow ( left , prev ) { if ( left . isEmpty ( ) ) { return prev ; } const elem = left . first ( ) ; return makePow ( left . remove ( elem ) , prev . union ( prev . map ( e => e . add ( elem ) ) ) ) ; }
204	function removeMissingPurchasesByPredicate ( existingPurchases , newPurchases , predicate ) { return existingPurchases . filter ( purchase => { if ( matches ( predicate ) ( purchase ) && find ( newPurchases , { ID : purchase . ID } ) ) { return true ; } if ( ! matches ( predicate ) ( purchase ) ) { return true ; } return false ; } ) ; }
3079	function ( walk ) { if ( ! walk . at ( '^ ' ) ) return false ; var startIdx = walk . position ; var found = false ; while ( walk . hasCurrent ( ) && ! found ) { walk . scrollToTerm ( ) . skipWhitespaces ( ) ; if ( ! walk . at ( '^ ' ) ) found = true ; } var g = this . stripSelector ( new SubWalker ( walk , startIdx , walk . position ) ) ; this . emitSortableGroup ( g ) ; return true ; }
3242	function ( ) { var clearButtonEl = this . clearButtonEl ; if ( ! clearButtonEl ) { return ; } var right = 0 ; if ( this . fieldHasScrollBar ( ) ) { right += Ext . getScrollBarWidth ( ) ; } if ( this . textField . triggerWrap ) { right += this . textField . getTriggerWidth ( ) ; } clearButtonEl . alignTo ( this . textField . bodyEl , 'tr-tr' , [ - 1 * ( right + 3 ) , 5 ] ) ; }
2728	function getLogger ( id , { disable = [ ] , wrappers = [ ] , tags = [ ] } = { } ) { let config = { disable : normalizeArray ( disable ) . map ( v => v + '' ) , wrappers : normalizeArray ( wrappers ) , tags : normalizeArray ( tags ) } ; set ( configRegistry , ` ${ id } ` , deepmerge ( get ( configRegistry , ` ${ id } ` , { } ) , config , deepMergeOptions ) ) ; return loggers [ id ] || ( loggers [ id ] = createLogger ( id ) ) ; }
1094	function getCORSRequest ( ) { var xhr = new root . XMLHttpRequest ( ) ; if ( 'withCredentials' in xhr ) { xhr . withCredentials = this . withCredentials ? true : false ; return xhr ; } else if ( ! ! root . XDomainRequest ) { return new XDomainRequest ( ) ; } else { throw new Error ( 'CORS is not supported by your browser' ) ; } }
119	function removeCurrent ( ) { var className = player . config . classNames . tabFocus ; var current = getElements . call ( player , "." . concat ( className ) ) ; toggleClass ( current , className , false ) ; }
3157	function Setting ( settingSpec , settings ) { this . _settings = settings ; Object . keys ( settingSpec ) . forEach ( function ( key ) { this [ key ] = settingSpec [ key ] ; } , this ) ; this . type = types . getType ( this . type ) ; if ( this . type == null ) { throw new Error ( 'In ' + this . name + ': can\'t find type for: ' + \' ) ; } JSON . stringify ( settingSpec . type ) if ( ! this . name ) { throw new Error ( 'Setting.name == undefined. Ignoring.' , this ) ; } if ( ! this . defaultValue === undefined ) { throw new Error ( 'Setting.defaultValue == undefined' , this ) ; } if ( this . onChange ) { this . on ( 'change' , this . onChange . bind ( this ) ) } }
1152	function ( withoutTransformations , target ) { if ( ! this . node . ownerSVGElement ) return { x : 0 , y : 0 , width : 0 , height : 0 } ; var box ; try { box = this . node . getBBox ( ) ; box = { x : box . x | 0 , y : box . y | 0 , width : box . width | 0 , height : box . height | 0 } ; } catch ( e ) { box = { x : this . node . clientLeft , y : this . node . clientTop , width : this . node . clientWidth , height : this . node . clientHeight } ; } if ( withoutTransformations ) { return box ; } var matrix = this . node . getTransformToElement ( target || this . node . ownerSVGElement ) ; var corners = [ ] ; var point = this . node . ownerSVGElement . createSVGPoint ( ) ; point . x = box . x ; point . y = box . y ; corners . push ( point . matrixTransform ( matrix ) ) ; point . x = box . x + box . width ; point . y = box . y ; corners . push ( point . matrixTransform ( matrix ) ) ; point . x = box . x + box . width ; point . y = box . y + box . height ; corners . push ( point . matrixTransform ( matrix ) ) ; point . x = box . x ; point . y = box . y + box . height ; corners . push ( point . matrixTransform ( matrix ) ) ; var minX = corners [ 0 ] . x ; var maxX = minX ; var minY = corners [ 0 ] . y ; var maxY = minY ; for ( var i = 1 , len = corners . length ; i < len ; i ++ ) { var x = corners [ i ] . x ; var y = corners [ i ] . y ; if ( x < minX ) { minX = x ; } else if ( x > maxX ) { maxX = x ; } if ( y < minY ) { minY = y ; } else if ( y > maxY ) { maxY = y ; } } return { x : minX , y : minY , width : maxX - minX , height : maxY - minY } ; }
2450	function isStructure ( obj ) { if ( ! obj ) { return false ; } if ( isArray ( obj ) || isPlainObject ( obj ) || isMap ( obj ) || isSet ( obj ) ) { return true ; } return isFunction ( obj . constructor ) && ! isNative . test ( obj . constructor . toString ( ) ) ; }
2822	function ( queryString ) { var args = queryString . split ( "&" ) , data = { } ; args . forEach ( function ( arg ) { var item = arg . split ( "=" ) ; ( item . length === 2 ) && ( data [ item [ 0 ] ] = item [ 1 ] ) ; } ) ; return data ; }
182	function resyncRequest ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE_MAILCHIMP_RESYNC_REQUEST : case WOOCOMMERCE_MAILCHIMP_RESYNC_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_RESYNC_REQUEST_FAILURE : return WOOCOMMERCE_MAILCHIMP_RESYNC_REQUEST === type ; } return state ; }
262	function ( sites , pluginSlug ) { const installedOnSites = this . getSites ( sites , pluginSlug ) || [ ] ; return sites . filter ( function ( site ) { if ( ! site . visible ) { return false ; } if ( site . jetpack && site . isSecondaryNetworkSite ) { return false ; } return installedOnSites . every ( function ( installedOnSite ) { return installedOnSite . slug !== site . slug ; } ) ; } ) ; }
268	function getJedArgs ( jedMethod , props ) { switch ( jedMethod ) { case 'gettext' : return [ props . original ] ; case 'ngettext' : return [ props . original , props . plural , props . count ] ; case 'npgettext' : return [ props . context , props . original , props . plural , props . count ] ; case 'pgettext' : return [ props . context , props . original ] ; } return [ ] ; }
678	function ( sentence , locale ) { this . _sentenceText = sentence || "" ; this . _locale = locale || defaultAttributes . locale ; this . _isPassive = false ; }
2981	function loadUsrInfo ( token , app , zlSite , next ) { app . models . zlUser . findById ( token . userId , ( err , usr ) => { if ( err ) next ( err ) ; else if ( usr ) { zlSite . user = _ . cloneDeep ( usr ) ; if ( ! zlSite . user . usrPhoto && zlSite . user . email ) { let graHash = md5 ( zlSite . user . email . toLowerCase ( ) ) ; zlSite . user . usrPhoto = ` ${ graHash } ` } next ( ) ; } else { next ( ) ; } } ) ; }
949	function handleProxyEvent ( source , target , eventName , options ) { let { newEventName , prependSourceArg } = options || { } ; source . on ( eventName , function ( ... args ) { prependSourceArg && args . unshift ( source ) ; if ( typeof newEventName === 'function' ) { newEventName . apply ( target , args ) ; } else { newEventName || ( newEventName = eventName ) ; args . unshift ( newEventName ) ; target . emit . apply ( target , args ) ; } } ) ; }
2672	function Config ( file ) { this . _file = file ; this . _doc = _this . parse ( file ) ; this . _root = this . _doc . getroot ( ) ; }
1852	function ( obj ) { var res = _ . assign ( _ . assign ( { } , this ) , obj ) ; for ( var f in this ) { if ( _ . isFunction ( this [ f ] ) ) { res [ f ] = this [ f ] ; } } if ( _ . isFunction ( res . checkConnection ) ) { res . checkConnection ( ) ; } return res ; }
770	function stringifyStyleAttributes ( filteredAST ) { return filteredAST . nodes [ 0 ] . nodes . reduce ( function ( extractedAttributes , attributeObject ) { extractedAttributes . push ( attributeObject . prop + ':' + attributeObject . value ) ; return extractedAttributes ; } , [ ] ) . join ( ';' ) ; }
2026	function ( app , callback ) { var cozyLight = require ( './cozy-light' ) ; var config = configHelpers . getConfig ( ) ; logger . info ( 'Uninstalling ' + app + '...' ) ; if ( config . apps [ app ] === undefined ) { logger . error ( app + ' is not installed.' ) ; nodeHelpers . invoke ( callback , true ) ; } else { var module = config . apps [ app ] . name ; npmHelpers . uninstall ( module , function removeAppFromConfig ( err ) { if ( err ) { logger . raw ( err ) ; logger . error ( 'npm did not uninstall ' + app + ' correctly.' ) ; nodeHelpers . invoke ( callback , err ) ; } else { logger . info ( app + ' successfully uninstalled.' ) ; configHelpers . watcher . one ( callback ) ; configHelpers . removeApp ( app ) ; } } ) ; } }
3238	function ( ) { var me = this ; return me . lhsMarker || ( me . lhsMarker = Ext . DomHelper . append ( me . el , { cls : me . resizeMarkerCls } , true ) ) ; }
1676	function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; result . ok ( uPnP . getInstance ( ) . discover ( result . callbackId , args ) , false ) ; }
1767	function moveCursor ( stream , dx , dy ) { if ( stream === null || stream === undefined ) return ; if ( dx < 0 ) { stream . write ( CSI ` ${ - dx } ` ) ; } else if ( dx > 0 ) { stream . write ( CSI ` ${ dx } ` ) ; } if ( dy < 0 ) { stream . write ( CSI ` ${ - dy } ` ) ; } else if ( dy > 0 ) { stream . write ( CSI ` ${ dy } ` ) ; } }
3137	function ( binding , event ) { if ( this . checkModifiers ( binding , event ) ) { var key = event . getKey ( ) , handler = binding . fn || binding . handler , scope = binding . scope || this , keyCode = binding . keyCode , defaultEventAction = binding . defaultEventAction , i , len , keydownEvent = new Ext . EventObjectImpl ( event ) ; for ( i = 0 , len = keyCode . length ; i < len ; ++ i ) { if ( key === keyCode [ i ] ) { if ( handler . call ( scope , key , event ) !== true && defaultEventAction ) { keydownEvent [ defaultEventAction ] ( ) ; } break ; } } } }
3349	function ( node1 , node2 ) { return node1 [ node1 . persistenceProperty ] . index - node2 [ node2 . persistenceProperty ] . index ; }
2170	function handleSearchText ( searchText , previousSearchText ) { ctrl . index = getDefaultIndex ( ) ; if ( searchText === previousSearchText ) return ; updateModelValidators ( ) ; getDisplayValue ( $scope . selectedItem ) . then ( function ( val ) { if ( searchText !== val ) { $scope . selectedItem = null ; if ( searchText !== previousSearchText ) announceTextChange ( ) ; if ( ! isMinLengthMet ( ) ) { ctrl . matches = [ ] ; setLoading ( false ) ; reportMessages ( false , ReportType . Count ) ; } else { handleQuery ( ) ; } } } ) ; }
2021	function ( program , callback ) { var cozyLight = require ( './cozy-light' ) ; applicationHelpers . resetDefaultPort ( ) ; cozyLight . setStarted ( ) ; var app = express ( ) ; var morgand = morgan ( 'combined' ) ; if ( expressLog ) { app . use ( morgand ) ; } pluginHelpers . startAll ( program , app , function ( ) { mainAppHelper . start ( app ) ; applicationHelpers . startAll ( function ( ) { var jsonParser = bodyParser . json ( ) ; var urlencodedParser = bodyParser . urlencoded ( { extended : false } ) ; app . use ( urlencodedParser ) ; app . use ( jsonParser ) ; nodeHelpers . invoke ( callback , null , app , server ) ; } ) ; } ) ; }
961	function queryRefInstance ( selector ) { let isSelectAll = Array . isArray ( selector ) ; isSelectAll && ( selector = selector [ 0 ] ) ; let result ; if ( isSelectAll ) { if ( typeof this . selectAllComponents === 'function' ) { result = this . selectAllComponents ( selector ) ; } result || ( result = [ ] ) ; } else if ( typeof this . selectComponent === 'function' ) { result = this . selectComponent ( selector ) ; } return result ; }
1093	function checkGlob ( filename , globs ) { filename = path . relative ( process . cwd ( ) , filename ) ; return minimatchList ( filename , globs ) ; }
215	function isInViewportRange ( elementStart , elementEnd ) { let viewportStart = window . scrollY , viewportEnd = document . documentElement . clientHeight + window . scrollY ; return elementStart > viewportStart && elementEnd < viewportEnd ; }
513	function parseBlockResults ( err ) { if ( err ) { if ( checkpointedState ) { self . stateManager . revert ( function ( ) { cb ( err ) } ) } else { cb ( err ) } return } self . stateManager . commit ( function ( err ) { if ( err ) return cb ( err ) self . stateManager . getStateRoot ( function ( err , stateRoot ) { if ( err ) return cb ( err ) if ( generateStateRoot ) { block . header . stateRoot = stateRoot } if ( validateStateRoot ) { if ( receiptTrie . root && receiptTrie . root . toString ( 'hex' ) !== block . header . receiptTrie . toString ( 'hex' ) ) { err = new Error ( ( err || '' ) + 'invalid receiptTrie ' ) } if ( bloom . bitvector . toString ( 'hex' ) !== block . header . bloom . toString ( 'hex' ) ) { err = new Error ( ( err || '' ) + 'invalid bloom ' ) } if ( ethUtil . bufferToInt ( block . header . gasUsed ) !== Number ( gasUsed ) ) { err = new Error ( ( err || '' ) + 'invalid gasUsed ' ) } if ( stateRoot . toString ( 'hex' ) !== block . header . stateRoot . toString ( 'hex' ) ) { err = new Error ( ( err || '' ) + 'invalid block stateRoot ' ) } } result = { receipts : receipts , results : txResults , error : err } afterBlock ( cb . bind ( this , err , result ) ) } ) } ) }
3445	function setupLogger ( name , cfg ) { assume ( name ) . is . a ( 'string' ) ; if ( cfg ) { assume ( cfg ) . is . an ( 'object' ) ; assume ( cfg ) . not . includes ( 'name' ) ; } else { cfg = { } ; } cfg . name = name ; if ( process . env . FORCE_LOG_LINE_NUMBERS_AND_BE_SLOW === '1' ) { cfg . src = true ; } let envLevel = parseEnvironment ( process . env . LOG_LEVEL , cfg ) ; let oldLevel = cfg . level ; cfg . level = envLevel ; cfg . serializers = { err : bunyan . stdSerializers . err , } ; let logger = bunyan . createLogger ( cfg ) ; if ( oldLevel ) { if ( oldLevel !== envLevel ) { logger . warn ( { requested : oldLevel , used : envLevel , } , 'using log level from environment instead of code' ) ; } } assume ( logger ) . does . not . include ( 'debugCompat' ) ; logger . debugCompat = makeCompat ( logger ) ; return logger ; }
3334	function ( ev ) { this . cliView . cli . update ( { typed : this . request . typed , cursor : { start : 0 , end : 0 } } ) ; this . cliView . cli . exec ( ) ; }
113	function toggleNativeControls ( ) { var toggle = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : false ; if ( toggle && this . isHTML5 ) { this . media . setAttribute ( 'controls' , '' ) ; } else { this . media . removeAttribute ( 'controls' ) ; } }
2941	function toDDB ( data , mergeInto ) { var result = mergeInto || { } var keys = Object . keys ( data ) for ( var i = 0 ; i < keys . length ; i ++ ) { var p = keys [ i ] result [ p ] = toDDBValue ( data [ p ] ) } return result }
2658	function smsDeletePhonesFromBlacklist ( callback , phones ) { if ( ( phones === undefined ) || ( ! phones . length ) ) { return callback ( returnError ( "Empty phones" ) ) ; } var data = { 'phones' : JSON . stringify ( phones ) , } sendRequest ( 'sms/black_list' , 'DELETE' , data , true , callback ) ; }
2853	function baseXor ( arrays , iteratee , comparator ) { var index = - 1 , length = arrays . length ; while ( ++ index < length ) { var result = result ? arrayPush ( baseDifference ( result , arrays [ index ] , iteratee , comparator ) , baseDifference ( arrays [ index ] , result , iteratee , comparator ) ) : arrays [ index ] ; } return ( result && result . length ) ? baseUniq ( result , iteratee , comparator ) : [ ] ; }
2856	function baseUnset ( object , path ) { path = isKey ( path , object ) ? [ path ] : castPath ( path ) ; object = parent ( object , path ) ; var key = toKey ( last ( path ) ) ; return ! ( object != null && hasOwnProperty . call ( object , key ) ) || delete object [ key ] ; }
2993	function ( dataview ) { this . dataview = dataview ; dataview . mon ( dataview , { beforecontainerclick : this . cancelClick , scope : this , render : { fn : this . onRender , scope : this , single : true } } ) ; }
1933	function ( snippet ) { var utils = require ( 'utils' ) ; snippet = utils . trim ( snippet ) ; if ( snippet . indexOf ( ':' ) == - 1 ) { return { name : snippet , value : defaultValue } ; } var pair = snippet . split ( ':' ) ; return { name : utils . trim ( pair . shift ( ) ) , value : utils . trim ( pair . join ( ':' ) ) . replace ( / ^(\$\{0\}|\$0)(\s*;?)$ / , '${1}$2' ) } ; }
3743	function ( ) { var args = norma ( 'path:s?' , arguments ) ; var _url = url . format ( _ . clone ( this . url ) ) ; var _path = ( args . path || '' ) . replace ( / ^\/ / , '' ) ; return url . resolve ( _url , _path ) ; }
1623	function parse_status ( callback ) { return function ( error , stdout , stderr ) { if ( error ) callback ( error ) ; else callback ( error , stdout . trim ( ) . split ( '\n\n' ) . \n \n ) ; } ; }
3682	function decorate ( object , values ) { for ( var key in values ) { if ( typeof object [ key ] === 'object' ) { decorate ( object [ key ] , values [ key ] ) } else { object [ key ] = values [ key ] } } }
1782	function loadSuites ( files ) { files . forEach ( function ( file ) { if ( / \.js(\?.*)?$ / . test ( file ) ) { jsSuites$1 . push ( file ) ; } else if ( / \.html(\?.*)?$ / . test ( file ) ) { htmlSuites$1 . push ( file ) ; } else { throw new Error ( 'Unknown resource type: ' + file ) ; } } ) ; }
3444	function convertRegExpsToNonEditable ( ed , args ) { var i = nonEditableRegExps . length , content = args . content , cls = tinymce . trim ( nonEditClass ) ; if ( args . format == "raw" ) { return ; } while ( i -- ) { content = content . replace ( nonEditableRegExps [ i ] , function ( match ) { var args = arguments , index = args [ args . length - 2 ] ; if ( index > 0 && content . charAt ( index - 1 ) == '"' ) { return match ; } return '<span class="' + cls + '" data-mce-content="' + ed . dom . encode ( args [ 0 ] ) + '">' + ed . dom . encode ( typeof ( args [ 1 ] ) === "string" ? args [ 1 ] : args [ 0 ] ) + '</span>' ; } ) ; } args . content = content ; }
3210	function multiFieldSort ( array , sortBy ) { array . sort ( ( a , b ) => { for ( let field of sortBy ) { let reverse = field [ 0 ] === '-' ; if ( reverse ) { field = field . slice ( 1 ) ; } let valueA = getPath ( a , field ) ; let valueB = getPath ( b , field ) ; if ( reverse ) { if ( valueA > valueB ) return - 1 ; else if ( valueA < valueB ) return 1 ; } else { if ( valueA > valueB ) return 1 ; else if ( valueA < valueB ) return - 1 ; } } return 0 ; } ) ; return array ; }
3672	function ( state , scope , secondaryScope ) { state . createLexicalEnvironment ( ) ; state . levelDown ( scope ) ; if ( secondaryScope ) state . levelDown ( secondaryScope ) ; while ( state . token && ! validators . isBlockEnd ( state ) ) { state . processor . token ( state ) ; } if ( secondaryScope ) state . levelUp ( ) ; state . levelUp ( ) ; state . finalizeLexicalEnvironment ( ) ; }
3161	function ( statuses ) { var combined = Status . VALID ; for ( var i = 0 ; i < statuses . length ; i ++ ) { if ( statuses [ i ] . valueOf ( ) > combined . valueOf ( ) ) { combined = statuses [ i ] ; } } return combined ; }
471	function isNode$2 ( obj ) { return ! ! ( ( typeof Node === 'undefined' ? 'undefined' : _typeof ( Node ) ) === 'object' ? obj instanceof Node : obj && ( typeof obj === 'undefined' ? 'undefined' : _typeof ( obj ) ) === 'object' && typeof obj . nodeType === 'number' && typeof obj . nodeName === 'string' ) ; }
1721	function _setItemOptions ( item , options , callback ) { item . options = { show : { transition : this . options . show . transition || this . options . transition , animation : this . options . show . animation || this . options . animation } , hide : { transition : this . options . hide . transition || this . options . transition , animation : this . options . hide . animation || this . options . animation } , transfer : { transition : this . options . transfer . transition || this . options . transition , items : this . options . transfer . items || { } , zIndex : this . options . transfer . zIndex , fastResize : this . options . transfer . fastResize } } ; if ( options ) { item . options . show . transition = ( options . show ? options . show . transition : undefined ) || options . transition || item . options . show . transition ; if ( options && options . show && ( options . show . animation !== undefined ) ) { item . options . show . animation = options . show . animation ; } else if ( options && ( options . animation !== undefined ) ) { item . options . show . animation = options . animation ; } item . options . transfer . transition = ( options . transfer ? options . transfer . transition : undefined ) || options . transition || item . options . transfer . transition ; item . options . transfer . items = ( options . transfer ? options . transfer . items : undefined ) || item . options . transfer . items ; item . options . transfer . zIndex = ( options . transfer && ( options . transfer . zIndex !== undefined ) ) ? options . transfer . zIndex : item . options . transfer . zIndex ; item . options . transfer . fastResize = ( options . transfer && ( options . transfer . fastResize !== undefined ) ) ? options . transfer . fastResize : item . options . transfer . fastResize ; } item . showCallback = function ( ) { item . showCallback = undefined ; item . state = ItemState . VISIBLE ; _updateState . call ( this ) ; _endTransferableAnimations . call ( this , item ) ; item . endSpec = undefined ; item . startSpec = undefined ; if ( callback ) { callback ( ) ; } } . bind ( this ) ; }
1157	function ( p , angle ) { p = point ( p ) ; var center = point ( this . x + this . width / 2 , this . y + this . height / 2 ) ; var result ; if ( angle ) p . rotate ( center , angle ) ; var sides = [ line ( this . origin ( ) , this . topRight ( ) ) , line ( this . topRight ( ) , this . corner ( ) ) , line ( this . corner ( ) , this . bottomLeft ( ) ) , line ( this . bottomLeft ( ) , this . origin ( ) ) ] ; var connector = line ( center , p ) ; for ( var i = sides . length - 1 ; i >= 0 ; -- i ) { var intersection = sides [ i ] . intersection ( connector ) ; if ( intersection !== null ) { result = intersection ; break ; } } if ( result && angle ) result . rotate ( center , - angle ) ; return result ; }
620	function filterFunctionWordsAtBeginning ( wordCombinations , functionWords ) { return wordCombinations . filter ( function ( combination ) { return ! includes ( functionWords , combination . getWords ( ) [ 0 ] ) ; } ) ; }
233	function cartToCriteoItems ( cart ) { return cart . products . map ( product => { return { id : product . product_id , price : product . cost , quantity : product . volume , } ; } ) ; }
424	function ( ) { var entities = this . entities , negate ; if ( parserInput . peek ( / ^-[@\$\(] / ) ) { negate = parserInput . $char ( '-' ) ; } var o = this . sub ( ) || entities . dimension ( ) || entities . color ( ) || entities . variable ( ) || entities . property ( ) || entities . call ( ) || entities . quoted ( true ) || entities . colorKeyword ( ) || entities . mixinLookup ( ) ; if ( negate ) { o . parensInOp = true ; o = new ( tree . Negative ) ( o ) ; } return o ; }
2630	function create ( props ) { var multiSlider = Object . create ( this ) ; _canvasWidget2 . default . create . call ( multiSlider ) ; Object . assign ( multiSlider , MultiSlider . defaults , props ) ; if ( props . value ) multiSlider . __value = props . value ; multiSlider . init ( ) ; if ( props . value === undefined && multiSlider . count !== 4 ) { for ( var i = 0 ; i < multiSlider . count ; i ++ ) { multiSlider . __value [ i ] = i / multiSlider . count ; } } else if ( typeof props . value === 'number' ) { for ( var _i = 0 ; _i < multiSlider . count ; _i ++ ) { multiSlider . __value [ _i ] = props . value ; } } return multiSlider ; }
2655	function smsGetPhoneInfo ( callback , addressbook_id , phone ) { if ( ( addressbook_id === undefined ) || ( phone === undefined ) ) { return callback ( returnError ( "Empty phone or book id" ) ) ; } sendRequest ( 'sms/numbers/info/' + addressbook_id + '/' + phone , 'GET' , { } , true , callback ) ; }
303	function removeData ( element , name ) { if ( isObject ( element [ name ] ) ) { try { delete element [ name ] ; } catch ( error ) { element [ name ] = undefined ; } } else if ( element . dataset ) { try { delete element . dataset [ name ] ; } catch ( error ) { element . dataset [ name ] = undefined ; } } else { element . removeAttribute ( "data-" . concat ( toParamCase ( name ) ) ) ; } }
306	function dispatchEvent ( element , type , data ) { var event ; if ( isFunction ( Event ) && isFunction ( CustomEvent ) ) { event = new CustomEvent ( type , { detail : data , bubbles : true , cancelable : true } ) ; } else { event = document . createEvent ( 'CustomEvent' ) ; event . initCustomEvent ( type , true , true , data ) ; } return element . dispatchEvent ( event ) ; }
1780	function scriptPrefix ( filename ) { var scripts = document . querySelectorAll ( 'script[src*="' + filename + '"]' ) ; if ( scripts . length !== 1 ) { return null ; } var script = scripts [ 0 ] . src ; return script . substring ( 0 , script . indexOf ( filename ) ) ; }
3669	function defer ( func ) { return new ( class { constructor ( generator ) { this . generator = generator ; } [ Symbol . iterator ] ( ) { return this . generator ( ) [ Symbol . iterator ] ( ) ; } } ) ( func ) ; }
2702	function createError ( ) { var e = new Error ( util . format . apply ( null , arguments ) ) ; e . trace = false ; return e ; }
2760	function ( element ) { this . el = element ; this . core = window . lgData [ this . el . getAttribute ( 'lg-uid' ) ] ; if ( this . core . items . length < 2 ) { return false ; } this . core . s = Object . assign ( { } , autoplayDefaults , this . core . s ) ; this . interval = false ; this . fromAuto = true ; this . canceledOnTouch = false ; this . fourceAutoplayTemp = this . core . s . fourceAutoplay ; if ( ! this . core . doCss ( ) ) { this . core . s . progressBar = false ; } this . init ( ) ; return this ; }
2323	function createInputInstance ( manager ) { var Type ; var inputClass = manager . options . inputClass ; if ( inputClass ) { Type = inputClass ; } else if ( SUPPORT_POINTER_EVENTS ) { Type = PointerEventInput ; } else if ( SUPPORT_ONLY_TOUCH ) { Type = TouchInput ; } else if ( ! SUPPORT_TOUCH ) { Type = MouseInput ; } else { Type = TouchMouseInput ; } return new Type ( manager , inputHandler ) ; }
2261	function map ( options , results ) { var promise , resolve , reject ; promise = new Promise ( function ( r1 , r2 ) { resolve = r1 ; reject = r2 ; } ) ; try { results = results || get . results ( options ) ; results . options . log = get . log ( options ) ; results . options . mapper = get . mapper ( options ) ; options = results . options ; resolve ( options . mapper . map ( options , results ) ) ; } catch ( error ) { reject ( error ) ; } return promise ; }
2697	function createHandlers ( session ) { _session = session ; _queue = queue . create ( session ) ; var handlers = { } ; handlers [ messages . names . kernelInfoRequest ] = kernelInfoHandler ; handlers [ messages . names . shutdownRequest ] = shutdownHandler ; handlers [ messages . names . executeRequest ] = executeHandler ; handlers [ messages . names . completeRequest ] = completeHandler ; return handlers ; }
3830	function CommandStatement ( name , args , manager , line ) { this . name = name ; this . args = args ; if ( ! commands [ name ] ) throw new SyntaxError ( 'Unknown command: ' + name ) ; this . command = new commands [ name ] ( args , manager . create ( line ) ) ; }
3519	function ( name , options , stack ) { var args = utils . slice ( arguments ) ; var opts = { } ; name = args . shift ( ) ; if ( ! utils . isLoader ( options ) && lazy . isObject ( options ) ) { opts = args . shift ( ) ; } opts = opts || { } ; var type = this . getLoaderType ( opts ) ; opts . loaderType = type ; var inst = this [ type ] ; var iterator = this . iterator ( type ) ; stack = inst . resolve ( inst . get ( name ) . concat ( args ) ) ; var ctx = { app : this } ; ctx . options = opts ; ctx . iterator = inst . iterator ; ctx . loaders = inst ; return function ( ) { var args = [ ] . slice . call ( arguments ) . filter ( Boolean ) ; var len = args . length , loaders = [ ] ; while ( len -- > 1 ) { var arg = args [ len ] ; if ( ! utils . isLoader ( arg ) ) break ; loaders . unshift ( args . pop ( ) ) ; } loaders = stack . concat ( inst . resolve ( loaders ) ) ; if ( type === 'async' ) { args . push ( loaders . pop ( ) ) ; } loaders = inst . resolve ( loaders ) ; if ( loaders . length === 0 ) { loaders = inst . resolve ( opts . defaultLoader || [ ] ) ; } var wrapped = loaders . map ( opts . wrap || utils . identity ) ; var load = iterator . call ( this , wrapped ) ; var res = load . apply ( ctx , args ) ; return res ; } . bind ( this ) ; }
3490	function ( arr , methodName ) { var ret = [ ] , args = Array . prototype . slice . call ( arguments , 2 ) , a , v , aLen = arr . length ; for ( a = 0 ; a < aLen ; a ++ ) { v = arr [ a ] ; if ( v && typeof v [ methodName ] == 'function' ) { ret . push ( v [ methodName ] . apply ( v , args ) ) ; } else { ret . push ( undefined ) ; } } return ret ; }
970	function watchDataChange ( expressOrFunc , callback , options ) { if ( typeof expressOrFunc === 'function' ) { expressOrFunc = this . __addComputedProp ( expressOrFunc ) ; } if ( typeof callback === 'function' ) { let handlerName = getAnonymousWatcherName ( this ) ; this [ handlerName ] = callback ; callback = handlerName ; } return this . __watchDataChange ( expressOrFunc , callback , options ) ; }
1671	function ( success , fail , args ) { args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; var views = qnx . webplatform . getWebViews ( ) ; var handle = null ; var z = - 1 ; for ( var i = 0 ; i < views . length ; i ++ ) { if ( views [ i ] . visible && views [ i ] . zOrder > z ) { z = views [ i ] . zOrder ; handle = views [ i ] . jsScreenWindowHandle ; } } if ( handle !== null ) { var values = { value : args , handle : handle } ; success ( preventsleep . getInstance ( ) . setPreventSleep ( values ) ) ; } else { success ( "Unable to get window handle" ) ; } }
348	function parseString ( endQuote ) { chars . push ( '"' ) ; i ++ ; var c = curr ( ) ; while ( i < jsString . length && c !== endQuote ) { if ( c === '"' && prev ( ) !== '\\' ) \\ else { chars . push ( '\\"' ) ; } \\ if ( controlChars . hasOwnProperty ( c ) ) { chars . push ( controlChars [ c ] ) } else if ( c === '\\' ) \\ else { i ++ ; c = curr ( ) ; if ( c !== '\'' ) \' { chars . push ( '\\' ) ; } } } \\ }
1387	function getChunk ( readerClient , slice , opConfig , logger , metadata ) { const delimiter = opConfig . line_delimiter ; async function getMargin ( offset , length ) { let margin = '' ; return new Promise ( async ( resolve ) => { while ( margin . indexOf ( delimiter ) === - 1 ) { const chunk = await readerClient ( offset , length ) ; if ( ! chunk ) { resolve ( margin . split ( delimiter ) [ 0 ] ) ; return ; } margin += chunk ; offset += length ; } resolve ( margin . split ( delimiter ) [ 0 ] ) ; } ) ; } let needMargin = false ; if ( slice . length ) { if ( slice . offset + slice . length !== slice . total ) { needMargin = true ; } } return readerClient ( slice . offset , slice . length ) . then ( async ( data ) => { if ( data . endsWith ( delimiter ) ) { needMargin = false ; } if ( needMargin ) { const avgSize = _averageRecordSize ( data . split ( delimiter ) ) ; data += await getMargin ( slice . offset + slice . length , 2 * avgSize ) ; } return data ; } ) . then ( data => chunkFormatter [ opConfig . format ] ( data , logger , opConfig , metadata , slice ) ) ; }
2544	function insertWrapDetails ( source , details ) { var length = details . length , lastIndex = length - 1 ; details [ lastIndex ] = ( length > 1 ? '& ' : '' ) + details [ lastIndex ] ; details = details . join ( length > 2 ? ', ' : ' ' ) ; return source . replace ( reWrapComment , '{\n/* [wrapped with ' + \n + details ) ; }
3298	function fixTableCellSelection ( ed ) { if ( ! tinymce . isWebKit ) return ; var rng = ed . selection . getRng ( ) ; var n = ed . selection . getNode ( ) ; var currentCell = ed . dom . getParent ( rng . startContainer , 'TD,TH' ) ; if ( ! tableCellSelected ( ed , rng , n , currentCell ) ) return ; if ( ! currentCell ) { currentCell = n ; } var end = currentCell . lastChild ; while ( end . lastChild ) end = end . lastChild ; rng . setEnd ( end , end . nodeValue . length ) ; ed . selection . setRng ( rng ) ; }
2300	function getProcessedPath ( file , data ) { return file . replace ( / __([A-Za-z0-9-]+_?[A-Za-z0-9-]+)+__ / g , ( match ) => { const dataKey = match . substring ( 2 , match . length - 2 ) ; const dataVal = data [ dataKey ] ; if ( dataVal ) { return dataVal ; } return match ; } ) ; }
2972	function InSicht ( ) { var options = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : { } ; _classCallCheck ( this , InSicht ) ; this . options = Object . assign ( { } , defaults , options ) ; this . init ( ) ; }
3729	function isStaticDecl ( node ) { var parent = node . parent ; return hasStatic ( parent ) && parent . arguments [ 2 ] === node ; }
3190	function ( icon ) { var me = this , isEmpty = ! icon || ! icon . length , iconCmp = me . iconCmp ; me . icon = icon ; if ( ! me . iconCmp && ! isEmpty ) { me . initIconCmp ( ) ; me . insert ( 0 , me . iconCmp ) ; } else if ( iconCmp ) { if ( isEmpty ) { me . iconCmp . destroy ( ) ; delete me . iconCmp ; } else { iconCmp . setSrc ( me . icon ) ; } } }
1317	function ccallFunc ( func , returnType , argTypes , args ) { var stack = 0 ; function toC ( value , type ) { if ( type == 'string' ) { if ( value === null || value === undefined || value === 0 ) return 0 ; if ( ! stack ) stack = Runtime . stackSave ( ) ; var ret = Runtime . stackAlloc ( value . length + 1 ) ; writeStringToMemory ( value , ret ) ; return ret ; } else if ( type == 'array' ) { if ( ! stack ) stack = Runtime . stackSave ( ) ; var ret = Runtime . stackAlloc ( value . length ) ; writeArrayToMemory ( value , ret ) ; return ret ; } return value ; } function fromC ( value , type ) { if ( type == 'string' ) { return Pointer_stringify ( value ) ; } assert ( type != 'array' ) ; return value ; } var i = 0 ; var cArgs = args ? args . map ( function ( arg ) { return toC ( arg , argTypes [ i ++ ] ) ; } ) : [ ] ; var ret = fromC ( func . apply ( null , cArgs ) , returnType ) ; if ( stack ) Runtime . stackRestore ( stack ) ; return ret ; }
1646	function ( ) { var self = this ; self . clear_ui ( ) ; self . resize ( ) ; self . draw_scale ( ) ; self . capture_idx . servers . forEach ( function ( bundle ) { var server_name = bundle [ 0 ] ; var conn_ids = bundle [ 1 ] ; var i ; self . y += self . server_pad ; self . draw_server_label ( server_name ) ; self . y += self . server_pad ; conn_ids . forEach ( function ( conn_id ) { var conn = self . capture . sessions [ server_name ] [ conn_id ] ; htracr . connection ( conn ) . draw ( di , [ server_name , conn_id , undefined , 0 ] ) ; i = 0 ; conn . http_reqs . forEach ( function ( http_req ) { var msg = htracr . http_msg ( http_req ) ; msg . kind = "req" ; msg . draw ( di , [ server_name , conn_id , 'http_reqs' , i ] ) ; i += 1 ; } ) ; i = 0 ; conn . http_ress . forEach ( function ( http_req ) { var msg = htracr . http_msg ( http_req ) ; msg . kind = "res" ; msg . draw ( di , [ server_name , conn_id , 'http_ress' , i ] ) ; i += 1 ; } ) ; i = 0 ; conn . packets . forEach ( function ( packet ) { var pkt = htracr . packet ( packet ) ; pkt . draw ( di , [ server_name , conn_id , 'packets' , i ] ) ; i += 1 ; } ) ; self . y += self . conn_pad ; } ) ; self . draw_referers ( ) ; self . draw_locations ( ) ; } ) ; }
2804	function lazyConsForce ( ) { var val = this . tailFn ( ) ; this . tailValue = Array . isArray ( val ) ? fromArray ( val ) : val ; delete this . tail ; delete this . force ; return this ; }
545	function getDetectedOptions ( detected , handlers ) { var options = { } ; Object . keys ( detected ) . forEach ( function ( option ) { var values = detected [ option ] ; var i ; if ( ! values . length ) { for ( i = handlers . length ; i -- ; ) { if ( handlers [ i ] . name === option && handlers [ i ] . detectDefault !== undefined ) { options [ option ] = handlers [ i ] . detectDefault ; break ; } } } else if ( values . length === 1 ) { options [ option ] = values [ 0 ] ; } else { var variants = { } ; var bestGuess = null ; var maximum = 0 ; for ( i = values . length ; i -- ; ) { var currentValue = values [ i ] ; if ( variants [ currentValue ] ) { variants [ currentValue ] ++ ; } else { variants [ currentValue ] = 1 ; } if ( variants [ currentValue ] >= maximum ) { maximum = variants [ currentValue ] ; bestGuess = currentValue ; } } if ( bestGuess !== null ) { options [ option ] = bestGuess ; } } } ) ; return options ; }
2653	function updateEmailVariables ( callback , id , email , variables ) { if ( ( id === undefined ) || ( email === undefined ) || ( variables === undefined ) || ( ! variables . length ) ) { return callback ( returnError ( "Empty email, variables or book id" ) ) ; } var data = { email : email , variables : variables } ; sendRequest ( 'addressbooks/' + id + '/emails/variable' , 'POST' , data , true , callback ) ; }
3680	function move_aspirate_forward ( hash ) { var asp = u . unasp2asp ( hash . stemUlt ) ; if ( ! asp ) return ; var stem = u . replaceEnd ( hash . stem , hash . stemUlt , asp ) ; if ( ! stem || stem == hash . stem ) return ; hash . stems = [ stem ] ; if ( debug ) log ( 'mod: move_aspirate_forward' , stem ) ; }
2930	function randomBetween ( ) { var min = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : 0 ; var max = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 10 ; if ( ! isNumber ( min ) || isNumericalNaN ( min ) ) { throw new TypeError ( 'Min should be numeric' ) ; } if ( ! isNumber ( max ) || isNumericalNaN ( max ) ) { throw new TypeError ( 'Max should be numeric' ) ; } return Math . random ( ) * max + min ; }
3301	function ( activeHd , toIdx ) { var me = this , normalGrid = me . normalGrid , lockedGrid = me . lockedGrid , normalHCt = normalGrid . headerCt , lockedHCt = lockedGrid . headerCt , refreshFlags , ownerCt ; activeHd = activeHd || normalHCt . getMenu ( ) . activeHeader ; ownerCt = activeHd . ownerCt ; if ( activeHd . flex ) { activeHd . width = activeHd . getWidth ( ) ; delete activeHd . flex ; } Ext . suspendLayouts ( ) ; ownerCt . remove ( activeHd , false ) ; activeHd . locked = true ; me . ignoreAddLockedColumn = true ; if ( Ext . isDefined ( toIdx ) ) { lockedHCt . insert ( toIdx , activeHd ) ; } else { lockedHCt . add ( activeHd ) ; } me . ignoreAddLockedColumn = false ; refreshFlags = me . syncLockedWidth ( ) ; if ( refreshFlags [ 0 ] ) { lockedGrid . getView ( ) . refresh ( ) ; } if ( refreshFlags [ 1 ] ) { normalGrid . getView ( ) . refresh ( ) ; } Ext . resumeLayouts ( true ) ; me . fireEvent ( 'lockcolumn' , me , activeHd ) ; }
138	function highlight ( term , html , wrapperNode ) { debug ( 'Starting highlight' ) ; if ( ! wrapperNode ) { wrapperNode = document . createElement ( 'mark' ) ; } if ( ! term || ! html ) { return html ; } const root = document . createElement ( 'div' ) ; root . innerHTML = html ; walk ( root , term , wrapperNode ) ; return root . innerHTML ; }
1391	function errorHandler ( err ) { const logErr = logger ? logger . error . bind ( logger ) : console . log ; if ( cluster . isMaster ) { logErr ( ` ${ process . pid } ` ) ; } else { logErr ( ` ${ cluster . worker . id } ${ process . pid } ` ) ; } if ( err . message ) { logErr ( err . message ) ; } else { logErr ( err ) ; } if ( err . stack ) { logErr ( err . stack ) ; } setTimeout ( ( ) => { process . exit ( - 1 ) ; } , 600 ) ; }
3683	function hide ( object , name , value ) { Object . defineProperty ( object , name , { enumerable : false , value : value } ) }
3507	function blockIndentationCheck ( node ) { if ( isSingleLineNode ( node ) ) { return ; } if ( node . parent && ( node . parent . type === "FunctionExpression" || node . parent . type === "FunctionDeclaration" || node . parent . type === "ArrowFunctionExpression" ) ) { checkIndentInFunctionBlock ( node ) ; return ; } var indent ; var nodesToCheck = [ ] ; var statementsWithProperties = [ "IfStatement" , "WhileStatement" , "ForStatement" , "ForInStatement" , "ForOfStatement" , "DoWhileStatement" ] ; if ( node . parent && statementsWithProperties . indexOf ( node . parent . type ) !== - 1 && isNodeBodyBlock ( node ) ) { indent = getNodeIndent ( node . parent ) ; } else { indent = getNodeIndent ( node ) ; } if ( node . type === "IfStatement" && node . consequent . type !== "BlockStatement" ) { nodesToCheck = [ node . consequent ] ; } else if ( util . isArray ( node . body ) ) { nodesToCheck = node . body ; } else { nodesToCheck = [ node . body ] ; } if ( nodesToCheck . length > 0 ) { checkNodesIndent ( nodesToCheck , indent + indentSize ) ; } if ( node . type === "BlockStatement" ) { checkLastNodeLineIndent ( node , indent ) ; } }
660	function createDeviationFragments ( syllableConfig ) { var deviationFragments = [ ] ; var deviations = syllableConfig . deviations ; if ( ! isUndefined ( deviations . words ) && ! isUndefined ( deviations . words . fragments ) ) { deviationFragments = flatMap ( deviations . words . fragments , function ( fragments , fragmentLocation ) { return map ( fragments , function ( fragment ) { fragment . location = fragmentLocation ; return new DeviationFragment ( fragment ) ; } ) ; } ) ; } return deviationFragments ; }
2438	function getTasks ( ) { const tasks = { } , tmp = { } , mods = { } , exec = Object . assign ( { } , execStack ) ; let total = 0 , count = 0 ; ( 0 , _core2 . default ) ( exec ) . forEach ( ( el , key ) => { tmp [ key ] = ( 0 , _core2 . default ) ( el ) . map ( ( el , key ) => key ) ; mods [ key ] = 0 ; count ++ ; } , el => el . length ) ; const sort = ( a , b ) => b . value - a . value ; while ( total <= _thread . MAX_PRIORITY ) { const rands = [ ] ; ( 0 , _core2 . default ) ( exec ) . forEach ( ( el , key ) => { rands . push ( { key , value : _thread . PRIORITY [ key ] } ) ; } , el => el . length ) ; rands . sort ( sort ) ; let pos = rands . length - 1 , max = 0 ; ( 0 , _core2 . default ) ( rands ) . forEach ( ( el , i ) => { const interval = intervals [ pos ] ; if ( interval [ 1 ] > max ) { max = interval [ 1 ] ; } rands [ i ] . value = interval ; pos -- ; } ) ; const rand = ( 0 , _math . getRandomInt ) ( 0 , max ) ; ( 0 , _core2 . default ) ( rands ) . forEach ( ( { key , value } ) => { const arr = tmp [ key ] ; if ( rand >= value [ 0 ] && rand <= value [ 1 ] ) { tasks [ key ] = tasks [ key ] || [ ] ; let pos = lastPos [ key ] ; if ( arr [ pos ] == null ) { lastPos [ key ] = pos = 0 ; mods [ key ] = 0 ; } const point = exec [ key ] [ arr [ pos ] ] ; if ( point && ! point . pause ) { mods [ key ] ++ ; tasks [ key ] . push ( arr [ pos ] ) ; total += _thread . PRIORITY [ key ] ; } arr . splice ( pos , 1 ) ; if ( ! arr . length ) { delete exec [ key ] ; count -- ; } return false ; } } ) ; if ( ! count ) { break ; } } ( 0 , _core2 . default ) ( mods ) . forEach ( ( el , key ) => { lastPos [ key ] += el ; } ) ; return tasks ; }
2095	function rename ( obj ) { return rename_ ( function ( parsedPath ) { return { extname : obj . extname || parsedPath . extname , dirname : ( obj . dirnamePrefix || '' ) + parsedPath . dirname , basename : parsedPath . basename } ; } ) ; }
1418	function ( cb ) { async . each ( t . __libraries , function ( library , cb ) { library . scanForClasses ( err => { log . debug ( "Finished scanning for " + library . getNamespace ( ) ) ; cb ( err ) ; } ) ; } , err => { log . debug ( "Finished scanning for all libraries" ) ; cb ( err ) ; } ) ; }
1712	function _getTransferable ( item , view , id ) { if ( view . getTransferable ) { return view . getTransferable ( id ) ; } if ( view . getSpec && view . get && view . replace ) { if ( view . get ( id ) !== undefined ) { return { get : function ( ) { return view . get ( id ) ; } , show : function ( renderable ) { view . replace ( id , renderable ) ; } , getSpec : _getViewSpec . bind ( this , item , view , id ) } ; } } if ( view . layout ) { return _getTransferable . call ( this , item , view . layout , id ) ; } }
2308	function compute ( ) { util . forEach ( expressions , function ( exp , index ) { var v = that . $exec ( exp ) if ( ! v [ 0 ] ) caches [ index ] = v [ 1 ] } ) var str = '' util . forEach ( parts , function ( item , index ) { str += emptyStr ( item ) if ( index < expressions . length ) { str += emptyStr ( caches [ index ] ) } } ) return Expression . unveil ( str ) }
1270	function RunNextSetup ( ) { if ( index < length ) { try { suite . benchmarks [ index ] . Setup ( ) ; } catch ( e ) { suite . NotifyError ( e ) ; return null ; } return RunNextBenchmark ; } suite . NotifyResult ( ) ; return null ; }
884	function processFile ( file , processor , buildManager ) { let { compileContext , logger } = buildManager ; let { handler , options : opts , rext } = processor ; logger . debug ( ` ${ file . path } ${ processor . name } ` , opts ) ; let result = handler ( file , Object . assign ( { config : opts } , compileContext ) ) ; if ( ! result ) { return ; } rext && ( file . rext = rext ) ; if ( isPromise ( result ) ) { buildManager . addAsyncTask ( file , result ) ; return ; } if ( result . isSfcComponent ) { compileComponent ( result , file , buildManager ) ; result = { content : file . content } ; } buildManager . updateFileCompileResult ( file , result ) ; }
2506	function existsOrCreate ( filePath , opts , cb ) { if ( arguments . length === 2 ) { cb = arguments [ 1 ] ; opts = { } ; } opts . encoding = opts . encoding || 'utf8' ; opts . data = opts . data || opts . content || '' ; opts . mode = opts . mode || '0777' ; opts . replace = opts . replace ? true : false ; var fp = resolve ( filePath ) ; var isFile = opts . hasOwnProperty ( 'isFile' ) ? opts . isFile : ! ! fp . extName ; fs . exists ( fp . fullPath , function ( exists ) { if ( exists && ! opts . replace ) cb ( null , exists ) ; else { mkdirp ( ( isFile ? fp . dirName : fp . fullPath ) , opts . mode , function ( err ) { if ( err ) cb ( new Error ( 'fsExt.existsOrCreate: creating folders failed' ) . cause ( err ) ) ; else if ( isFile || opts . replace ) { fs . writeFile ( fp . fullPath , opts . data , opts . encoding , function ( err ) { if ( err ) cb ( new Error ( 'fsExt.existsOrCreate: creating file failed' ) . cause ( err ) ) ; else cb ( null , exists ) ; } ) ; } else cb ( null , exists ) ; } ) ; } } ) ; }
1792	function ( optsOrCallback , cb ) { let callback = cb ? cb : optsOrCallback ; let options = cb ? optsOrCallback : null ; let args = [ 'update' , '--standalone' ] ; let browsers = [ 'chrome' ] ; if ( options ) { if ( options . browsers && options . browsers . length > 0 ) { browsers = options . browsers ; } browsers . forEach ( function ( element ) { args . push ( '--' + element ) ; } ) ; if ( options . args ) { args = args . concat ( options . args ) ; } } childProcess . spawn ( COMMAND_RELATIVE_PATH + WEB_DRIVER_COMMAND , args , { 'cwd' : protractorDirToUse , 'stdio' : 'inherit' } ) . once ( 'close' , callback ) ; }
1795	function USBProcess ( id , daemon ) { this . id = id ; this . active = true ; this . closed = false ; this . forceKill = false ; this . exitedWithError = false ; this . waitForClose = true ; this . control = new RemoteWritableStream ( this , daemon , protocol . controlWrite , protocol . controlClose ) ; this . stdin = new RemoteWritableStream ( this , daemon , protocol . stdinWrite , protocol . stdinClose ) ; this . stdout = new RemoteReadableStream ( this , daemon , protocol . stdoutAck ) ; this . stderr = new RemoteReadableStream ( this , daemon , protocol . stderrAck ) ; this . once ( 'death' , ( data ) => { this . active = false ; this . control . end ( ) ; this . stdin . end ( ) ; this . closeProcessIfReady ( ) ; var exitCode = parseInt ( data . arg ) ; debug ( ` ${ this . commandString } ${ exitCode } ` ) ; if ( exitCode !== 0 && ! this . forceKill ) { this . exitedWithError = true ; } } ) ; this . close = ( ) => { daemon . write ( protocol . closeProcess ( this . id ) ) ; this . closed = true ; } ; this . kill = ( signal ) => { this . forceKill = true ; if ( this . waitForClose ) { daemon . write ( protocol . killProcess ( this . id , signal ) ) ; } else { this . active = false ; this . closed = true ; setImmediate ( ( ) => this . emit ( 'close' ) ) ; } } ; this . closeProcessIfReady = ( ) => { if ( ! this . active && ! this . closed && this . stdout . closed && this . stderr . closed ) { this . close ( ) ; } } ; this . stdout . once ( 'end' , ( ) => this . closeProcessIfReady ( ) ) ; this . stderr . once ( 'end' , ( ) => this . closeProcessIfReady ( ) ) ; this . stdout . signal = ( signalToSend ) => { switch ( signalToSend ) { case 'KILL' : this . kill ( 9 ) ; break ; case 'SIGINT' : this . kill ( 2 ) ; break ; } } ; daemon . write ( protocol . newProcess ( this . id ) ) ; this . stdout . ack ( MAX_BUFFER_SIZE ) ; this . stderr . ack ( MAX_BUFFER_SIZE ) ; }
3600	function lint ( files ) { return gulp . src ( files ) . pipe ( $ . plumber ( ) ) . pipe ( $ . eslint ( ) ) . pipe ( $ . eslint . format ( ) ) . pipe ( $ . eslint . failOnError ( ) ) . pipe ( $ . jscs ( ) ) . pipe ( $ . notify ( _jscsNotify ) ) ; }
908	function addFeatureItem ( logger , existed , name , params ) { if ( ! existed [ name ] ) { existed [ name ] = true ; let feature = { name } ; params && ( feature . params = params ) ; return feature ; } logger . debug ( 'duplicated feature declaration' , name ) ; return false ; }
386	function removeNodeSaveChildren ( node ) { var fosterParent = node . parentNode ; if ( ! fosterParent ) { return ; } var children = ( node . childNodes || [ ] ) . slice ( ) ; for ( var _i = 0 , children_1 = children ; _i < children_1 . length ; _i ++ ) { var child = children_1 [ _i ] ; insertBefore ( node . parentNode , node , child ) ; } remove ( node ) ; }
3288	function ( ) { var me = this , current = me . store . currentPage ; if ( me . fireEvent ( 'beforechange' , me , current ) !== false ) { me . store . loadPage ( current ) ; } }
3498	function checkNodesIndent ( nodes , indent , excludeCommas ) { nodes . forEach ( function ( node ) { if ( node . type === "IfStatement" && node . alternate ) { var elseToken = context . getTokenBefore ( node . alternate ) ; checkNodeIndent ( elseToken , indent , excludeCommas ) ; } checkNodeIndent ( node , indent , excludeCommas ) ; } ) ; }
779	function $checksum ( byte ) { checksum += toHex ( byte ) ; if ( ++ offset < 20 ) return $checksum ; var actual = sha1sum . digest ( ) ; if ( checksum !== actual ) throw new Error ( "Checksum mismatch: " + actual + " != " + checksum ) ; }
840	function tabHtml ( tabTitle , codeContent , codeLang ) { return ` ${ escape ( tabTitle ) } ${ codeLang } ${ codeLang } ${ escapeBraces ( highlight ( codeContent , codeLang ) ) } ` ; }
381	function nodeWalkAll ( node , predicate , matches , getChildNodes ) { if ( getChildNodes === void 0 ) { getChildNodes = module . exports . defaultChildNodes ; } if ( ! matches ) { matches = [ ] ; } if ( predicate ( node ) ) { matches . push ( node ) ; } var childNodes = getChildNodes ( node ) ; if ( childNodes ) { for ( var i = 0 ; i < childNodes . length ; i ++ ) { nodeWalkAll ( childNodes [ i ] , predicate , matches , getChildNodes ) ; } } return matches ; }
2935	function lastIndexOfMatch ( string , regex , index ) { const str = index !== null ? string . substring ( 0 , index ) : string ; const matches = str . match ( regex ) ; return matches ? str . lastIndexOf ( matches [ matches . length - 1 ] ) : - 1 ; }
2182	function update ( ) { var stateTree = buildTreeJSON ( xebraState . getPatchers ( ) ) ; var nodes = d3 . hierarchy ( stateTree , function ( d ) { return d . children ; } ) ; d3Tree ( nodes ) ; var link = g . selectAll ( ".link" ) . data ( nodes . descendants ( ) . slice ( 1 ) ) . enter ( ) . append ( "path" ) . attr ( "class" , "link" ) . attr ( "d" , diagonal ) ; var node = g . selectAll ( ".node" ) . data ( nodes . descendants ( ) ) . enter ( ) . append ( "g" ) . attr ( "class" , function ( d ) { return "node" + ( d . children ? " node--internal" : " node--leaf" ) ; } ) . attr ( "transform" , function ( d ) { return "translate(" + d . y + "," + d . x + ")" ; } ) ; node . append ( "circle" ) . attr ( "r" , 2.5 ) ; node . append ( "text" ) . attr ( "dy" , function ( d ) { return d . children ? - 10 : 0 } ) . attr ( "x" , function ( d ) { return d . children ? - 8 : 8 ; } ) . style ( "text-anchor" , "start" ) . text ( function ( d ) { return d . data . name ; } ) ; }
1516	function selfLinking ( link , id ) { return getNodeID ( link . source , id ) == getNodeID ( link . target , id ) ; }
1825	function getPropType ( propValue ) { const propType = typeof propValue ; if ( Array . isArray ( propValue ) ) { return 'array' ; } if ( propValue instanceof RegExp ) { return 'object' ; } return propType ; }
1939	function expandGradientOutsideValue ( editor , syntax ) { var propertyName = prefs . get ( 'css.gradient.defaultProperty' ) ; if ( ! propertyName ) return false ; var content = String ( editor . getContent ( ) ) ; var lineRange = require ( 'range' ) . create ( editor . getCurrentLineRange ( ) ) ; var line = lineRange . substring ( content ) . replace ( / ^\s+ / , function ( pad ) { lineRange . start += pad . length ; return '' ; } ) . replace ( / \s+$ / , function ( pad ) { lineRange . end -= pad . length ; return '' ; } ) ; var css = require ( 'cssResolver' ) ; var gradient = module . parse ( line ) ; if ( gradient ) { var props = getPropertiesForGradient ( gradient , propertyName ) ; props . push ( { name : propertyName , value : module . toString ( gradient ) + '${2}' } ) ; var sep = css . getSyntaxPreference ( 'valueSeparator' , syntax ) ; var end = css . getSyntaxPreference ( 'propertyEnd' , syntax ) ; if ( require ( 'preferences' ) . get ( 'css.alignVendor' ) ) { var pads = require ( 'utils' ) . getStringsPads ( _ . map ( props , function ( prop ) { return prop . value . substring ( 0 , prop . value . indexOf ( '(' ) ) ; } ) ) ; _ . each ( props , function ( prop , i ) { prop . value = pads [ i ] + prop . value ; } ) ; } props = _ . map ( props , function ( item ) { return item . name + sep + item . value + end ; } ) ; editor . replaceContent ( props . join ( '\n' ) , \n , lineRange . start ) ; lineRange . end } return true ; }
1432	function ( comment ) { var current = { name : "@description" , body : "" } ; var cmds = [ current ] ; if ( typeof comment == "string" ) { comment = comment . split ( "\n" ) ; } \n comment . forEach ( function ( line ) { line = line . trim ( ) ; var m = line . match ( / ^\*\s?(.*)$ / ) ; if ( m ) { line = m [ 1 ] ; } line = line . trim ( ) ; m = line . match ( / ^(\@[a-zA-Z0-9_]+)(.*)$ / ) ; if ( ! m ) { if ( current . body . length ) { current . body += "\n" ; } \n current . body += line ; } return ; var name = m [ 1 ] ; var body = m [ 2 ] ; if ( name == "@returns" ) { name = "@return" ; } if ( name == "@throw" ) { name = "@throws" ; } current = { name : name , body : body } ; } ) ; cmds . push ( current ) ; var result = { } ; }
600	function mapResults ( results ) { const mappedResults = [ ] ; for ( let i = 0 ; i < results . length ; i ++ ) { if ( ! results [ i ] . text ) { continue ; } mappedResults . push ( mapResult ( results [ i ] ) ) ; } return sortResults ( mappedResults ) ; }
241	function requestPosts ( siteId , query = { } ) { return dispatch => { dispatch ( { type : POSTS_REQUEST , siteId , query , } ) ; const source = siteId ? wpcom . site ( siteId ) : wpcom . me ( ) ; return source . postsList ( { ... query } ) . then ( ( { found , posts } ) => { dispatch ( receivePosts ( posts ) ) ; dispatch ( { type : POSTS_REQUEST_SUCCESS , siteId , query , found , posts , } ) ; } ) . catch ( error => { dispatch ( { type : POSTS_REQUEST_FAILURE , siteId , query , error , } ) ; } ) ; } ; }
3162	function defaultArgsProvider ( request , callback ) { var args = request . args , params = request . command . params ; for ( var i = 0 ; i < params . length ; i ++ ) { var param = params [ i ] ; if ( request . getParamStatus ( param ) != Status . VALID || param . defaultValue === null ) { var paramPrompt = param . description ; if ( param . defaultValue === null ) { paramPrompt += " (optional)" ; } var value = prompt ( paramPrompt , param . defaultValue || "" ) ; if ( ! value ) { callback ( ) ; return ; } else { args [ param . name ] = value ; } } } callback ( ) ; }
3177	function ( ) { var headerFragment = this . _parseHeader ( ) , data = { } , nodes , elm , matches , editor = this . editor ; function getAttr ( elm , name ) { var value = elm . attr ( name ) ; return value || '' ; } ; data . fontface = editor . getParam ( "fullpage_default_fontface" , "" ) ; data . fontsize = editor . getParam ( "fullpage_default_fontsize" , "" ) ; elm = headerFragment . firstChild ; if ( elm . type == 7 ) { data . xml_pi = true ; matches = / encoding="([^"]+)" / . exec ( elm . value ) ; if ( matches ) data . docencoding = matches [ 1 ] ; } elm = headerFragment . getAll ( '#doctype' ) [ 0 ] ; if ( elm ) data . doctype = '<!DOCTYPE' + elm . value + ">" ; elm = headerFragment . getAll ( 'title' ) [ 0 ] ; if ( elm && elm . firstChild ) { data . metatitle = elm . firstChild . value ; } each ( headerFragment . getAll ( 'meta' ) , function ( meta ) { var name = meta . attr ( 'name' ) , httpEquiv = meta . attr ( 'http-equiv' ) , matches ; if ( name ) data [ 'meta' + name . toLowerCase ( ) ] = meta . attr ( 'content' ) ; else if ( httpEquiv == "Content-Type" ) { matches = / charset\s*=\s*(.*)\s* / gi . exec ( meta . attr ( 'content' ) ) ; if ( matches ) data . docencoding = matches [ 1 ] ; } } ) ; elm = headerFragment . getAll ( 'html' ) [ 0 ] ; if ( elm ) data . langcode = getAttr ( elm , 'lang' ) || getAttr ( elm , 'xml:lang' ) ; elm = headerFragment . getAll ( 'link' ) [ 0 ] ; if ( elm && elm . attr ( 'rel' ) == 'stylesheet' ) data . stylesheet = elm . attr ( 'href' ) ; elm = headerFragment . getAll ( 'body' ) [ 0 ] ; if ( elm ) { data . langdir = getAttr ( elm , 'dir' ) ; data . style = getAttr ( elm , 'style' ) ; data . visited_color = getAttr ( elm , 'vlink' ) ; data . link_color = getAttr ( elm , 'link' ) ; data . active_color = getAttr ( elm , 'alink' ) ; } return data ; }
547	function isEmptyBlock ( node ) { if ( ! node . length ) return true ; return ! node . content . some ( function ( node ) { return ! node . is ( 'space' ) ; } ) ; }
1858	function ( ) { var node = new AbbreviationNode ( ) ; var attrs = [ 'abbreviation' , 'counter' , '_name' , '_text' , 'repeatCount' , 'hasImplicitRepeat' , 'start' , 'end' , 'content' , 'padding' ] ; _ . each ( attrs , function ( a ) { node [ a ] = this [ a ] ; } , this ) ; node . _attributes = _ . map ( this . _attributes , function ( attr ) { return _ . clone ( attr ) ; } ) ; node . _data = _ . clone ( this . _data ) ; node . children = _ . map ( this . children , function ( child ) { child = child . clone ( ) ; child . parent = node ; return child ; } ) ; return node ; }
2578	function shuffle ( s , splitter ) { var a = s . split ( typeof splitter === 'string' ? splitter : '' ) , n = a . length , replaceSplits = n - 1 ; for ( var i = n - 1 ; i > 0 ; i -- ) { var j = Math . floor ( Math . random ( ) * ( i + 1 ) ) , tmp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = tmp ; } for ( var k = 0 ; k < replaceSplits ; k ++ ) a . splice ( libs . number . randomIntInRange ( 0 , a . length ) , 0 , splitter ) ; return a . join ( '' ) ; }
1274	function RegExpGetFlags ( ) { if ( ! IS_RECEIVER ( this ) ) { throw MakeTypeError ( kRegExpNonObject , "RegExp.prototype.flags" , TO_STRING ( this ) ) ; } var result = '' ; if ( this . global ) result += 'g' ; if ( this . ignoreCase ) result += 'i' ; if ( this . multiline ) result += 'm' ; if ( this . unicode ) result += 'u' ; if ( this . sticky ) result += 'y' ; return result ; }
42	function augmentStackTraceWithInitialElement ( stackInfo , url , lineNo , message ) { var initial = { url : url , line : lineNo } ; if ( initial . url && initial . line ) { stackInfo . incomplete = false ; if ( ! initial . func ) { initial . func = UNKNOWN_FUNCTION ; } if ( stackInfo . stack . length > 0 ) { if ( stackInfo . stack [ 0 ] . url === initial . url ) { if ( stackInfo . stack [ 0 ] . line === initial . line ) { return false ; } else if ( ! stackInfo . stack [ 0 ] . line && stackInfo . stack [ 0 ] . func === initial . func ) { stackInfo . stack [ 0 ] . line = initial . line ; return false ; } } } stackInfo . stack . unshift ( initial ) ; stackInfo . partial = true ; return true ; } else { stackInfo . incomplete = true ; } return false ; }
2944	function contentsToDisplay ( req , res , scsId , scId = 0 , cb ) { var zlSiteContentIn = app . models . zlSiteContentIn ; var Role = app . models . Role ; var compMod = require ( './helpers/component-from-model' ) ( app ) ; if ( res . locals . emiter . emit ( ` ${ scsId } ` , cb ) ) { return ; } var { themeData } = res . locals ; let filter = { fields : { scsPermission : true , zlSiteId : true } } ; app . models . zlSiteContentSet . findById ( scsId , filter , ( err , scs ) => { if ( err || ! scs ) return cb ( ` ` ) ; let ctx = app . locals . authCtx ( req , res ) ; Role . isInRole ( scs . scsPermission , ctx , ( err , isInRole ) => { if ( isInRole ) { let filter = { fields : { scId : true } , include : { relation : 'zlSiteContent' , scope : { where : { scStatus : 'publish' , zlSiteId : res . locals . zlSite . zsId } , } , } , where : { scsId : scsId } , } ; zlSiteContentIn . find ( filter , ( err , data ) => { var promises = [ ] ; compMod . promises = promises ; _ . forEach ( data , function ( val , key ) { if ( ! val || ! val . zlSiteContent ) return data . splice ( key , 1 ) ; val = val . toJSON ( ) . zlSiteContent ; if ( 'page content' === val . scType ) { data = val . scContent ; if ( _ . isArray ( data ) ) { _ . forEach ( data , function ( subVal , subKey ) { subVal . scId = ( subVal . scId ) ? subVal . scId : ` ${ scsId } ${ subKey } ` ; prepContent ( req , res , data , subVal , subKey , promises , compMod , scsId , cb ) ; } ) ; } return false ; } else { data [ key ] = val . scContent ; prepContent ( req , res , data , val . scContent , key , promises , compMod , scsId , cb ) ; } } ) ; res . locals . emiter . emit ( ` ${ scsId } ` , data , promises ) ; Promise . all ( promises ) . then ( values => { cb ( null , data ) ; } ) ; } ) ; } else cb ( 'Page Authorization failed' ) ; } ) ; } ) ; compMod . themeData = themeData ; }
1477	function ( msgId , ... args ) { var msg = qx . tool . compiler . Console . MESSAGE_IDS [ msgId ] || msgId ; var str = qx . lang . String . format ( msg . message , args || [ ] ) ; return str ; }
1234	function ReqSocket ( ) { Socket . call ( this ) ; this . n = 0 ; this . ids = 0 ; this . callbacks = { } ; this . identity = this . get ( 'identity' ) ; this . use ( queue ( ) ) ; }
2284	function retrieveSteamAPIMethods ( key , callback ) { var _steam = new Steam ( ) ; _steam . getSupportedAPIList ( { key : key } , function ( err , data ) { if ( err ) return callback ( err ) ; var apiList = data . apilist ; if ( apiList === undefined ) return callback ( new Error ( 'No data returned' ) ) ; apiList = apiList . interfaces ; for ( var i = 0 ; i < apiList . length ; i ++ ) { var _interface = apiList [ i ] ; var methods = _interface . methods ; for ( var j = 0 ; j < methods . length ; j ++ ) { var method = methods [ j ] ; var optionalParams = [ ] , requiredParams = [ ] ; var params = method . parameters ; for ( var k = 0 ; k < params . length ; k ++ ) { var param = params [ k ] ; if ( param . optional ) { optionalParams . push ( param . name ) ; } else { requiredParams . push ( param . name ) ; } } buildSteamWrapperMethod ( _interface . name , method . name , method . version , method . httpmethod , requiredParams , optionalParams ) ; } } callback ( ) ; } ) ; }
2253	function ( ) { L . DomUtil . empty ( this . _container ) ; var legends = this . options . legends ; if ( ! legends ) return ; legends . forEach ( function ( legend ) { if ( ! legend . elements ) return ; var elements = legend . elements ; var className = 'legend-block' ; if ( this . options . detectStretched ) { if ( elements . length === 3 && elements [ 0 ] . label !== '' && elements [ 1 ] . label === '' && elements [ 2 ] . label !== '' ) { legend . type = 'stretched' ; } } if ( legend . type === 'stretched' ) { className += ' legend-stretched' ; } var block = L . DomUtil . create ( 'div' , className , this . _container ) ; if ( this . options . collapseSimple && elements . length == 1 && ! elements [ 0 ] . label ) { this . _addElement ( elements [ 0 ] . imageData , legend . name , block ) ; return ; } if ( legend . name ) { var header = L . DomUtil . create ( 'h4' , null , block ) ; L . DomUtil . create ( 'div' , 'caret' , header ) ; L . DomUtil . create ( 'span' , null , header ) . innerHTML = legend . name ; L . DomEvent . on ( header , 'click' , function ( ) { if ( L . DomUtil . hasClass ( header , 'closed' ) ) { L . DomUtil . removeClass ( header , 'closed' ) ; } else { L . DomUtil . addClass ( header , 'closed' ) ; } } , this ) ; } var elementContainer = L . DomUtil . create ( 'div' , 'legend-elements' , block ) ; elements . forEach ( function ( element ) { this . _addElement ( element . imageData , element . label , elementContainer ) ; } , this ) ; } , this ) ; }
905	function normalizeRouteInfo ( pages , subPackages ) { let result = { } ; let entryPageName = normalizePages ( result , pages ) ; subPackages && subPackages . forEach ( item => { let { root , pages : subPages } = item ; normalizePages ( result , subPages , root ) ; } ) ; return { entry : entryPageName , pages : result } ; }
263	function urlSafeBase64DecodeString ( str ) { const decodeMap = { '-' : '+' , _ : '/' , '.' : '=' , } ; return atob ( str . replace ( / [-_.] / g , ch => decodeMap [ ch ] ) ) ; }
378	function setTextContent ( node , value ) { if ( isCommentNode ( node ) ) { node . data = value ; } else if ( isTextNode ( node ) ) { node . value = value ; } else { var tn = newTextNode ( value ) ; tn . parentNode = node ; node . childNodes = [ tn ] ; } }
2050	function ( script ) { var file , name ; try { if ( script . indexOf ( 'node://' ) === 0 ) { name = script . substr ( 7 ) ; } file = fs . readFileSync ( name ) ; vm . runInContext ( file , freedomVM , name ) ; } catch ( e ) { console . error ( e ) ; process . exit ( 1 ) ; } }
1381	function ZarinPal ( MerchantID , sandbox ) { if ( typeof MerchantID === 'string' && MerchantID . length === config . merchantIDLength ) { this . merchant = MerchantID ; } else { console . error ( 'The MerchantID must be ' + config . merchantIDLength + ' Characters.' ) ; return false ; } this . sandbox = sandbox || false ; this . url = ( sandbox === true ) ? config . sandbox : config . https ; }
1059	function apply ( value , rule , rules ) { var entries = rule . entries var words = [ ] var index = - 1 var length = entries . length var entry var next var continuationRule var continuation var position var count while ( ++ index < length ) { entry = entries [ index ] if ( ! entry . match || value . match ( entry . match ) ) { next = value if ( entry . remove ) { next = next . replace ( entry . remove , '' ) } if ( rule . type === 'SFX' ) { next += entry . add } else { next = entry . add + next } words . push ( next ) continuation = entry . continuation if ( continuation && continuation . length !== 0 ) { position = - 1 count = continuation . length while ( ++ position < count ) { continuationRule = rules [ continuation [ position ] ] if ( continuationRule ) { words = words . concat ( apply ( next , continuationRule , rules ) ) } } } } } return words }
1324	function isSimpleRange ( classRange ) { const { from , to } = classRange ; return ( from . codePoint >= DIGIT_0_CP && from . codePoint <= DIGIT_9_CP && to . codePoint >= DIGIT_0_CP && to . codePoint <= DIGIT_9_CP ) || ( from . codePoint >= UPPER_A_CP && from . codePoint <= UPPER_Z_CP && to . codePoint >= UPPER_A_CP && to . codePoint <= UPPER_Z_CP ) || ( from . codePoint >= LOWER_A_CP && from . codePoint <= LOWER_Z_CP && to . codePoint >= LOWER_A_CP && to . codePoint <= LOWER_Z_CP ) ; }
2717	function Credulous ( options ) { var i ; if ( ! this ) { return new Credulous ( options ) ; } options = validateOptions ( options ) ; this . labels = options . labels ; this . dataLength = options . dataLength ; this . trainArgumentsLength = this . dataLength + 1 ; this . dataStore = [ ] ; setUpDataStore ( this . dataStore , this . labels , this . dataLength ) ; this . instancesTrained = 0 ; }
2929	function round ( val ) { var precision = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 0 ; if ( ! isNumber ( val ) || isNumericalNaN ( val ) ) { throw new TypeError ( 'Value should be numeric' ) ; } if ( precision === ! 1 || precision < 1 ) { return Math . round ( val ) ; } var exp = Math . pow ( 10 , Math . round ( precision ) ) ; return Math . round ( val * exp ) / exp ; }
1656	function list ( pid , options , callback ) { if ( typeof options === 'function' ) { callback = options ; options = undefined ; } if ( typeof callback === 'function' ) { pidtree ( pid , options , callback ) ; return ; } return pify ( pidtree , pid , options ) ; }
2690	function createCompleteInfoResponseMessage ( parentMessage , matchedText , matches , metadata ) { var content = { status : 'ok' , matched_text : matchedText , matches : matches } ; return newMessage ( _messageNames . completeResponse , parentMessage , content , metadata ) ; }
3411	function ( pl , o ) { var t = this , ed = t . editor , dom = ed . dom , styleProps ; if ( ed . settings . paste_enable_default_filters == false ) { return ; } if ( o . wordContent ) { each ( dom . select ( 'a' , o . node ) , function ( a ) { if ( ! a . href || a . href . indexOf ( '#_Toc' ) != - 1 ) dom . remove ( a , 1 ) ; } ) ; if ( getParam ( ed , "paste_convert_middot_lists" ) ) { t . _convertLists ( pl , o ) ; } styleProps = getParam ( ed , "paste_retain_style_properties" ) ; if ( ( tinymce . is ( styleProps , "string" ) ) && ( styleProps !== "all" ) && ( styleProps !== "*" ) ) { styleProps = tinymce . explode ( styleProps . replace ( / ^none$ / i , "" ) ) ; each ( dom . select ( '*' , o . node ) , function ( el ) { var newStyle = { } , npc = 0 , i , sp , sv ; if ( styleProps ) { for ( i = 0 ; i < styleProps . length ; i ++ ) { sp = styleProps [ i ] ; sv = dom . getStyle ( el , sp ) ; if ( sv ) { newStyle [ sp ] = sv ; npc ++ ; } } } dom . setAttrib ( el , 'style' , '' ) ; if ( styleProps && npc > 0 ) dom . setStyles ( el , newStyle ) ; else if ( el . nodeName == 'SPAN' && ! el . className ) dom . remove ( el , true ) ; } ) ; } } if ( getParam ( ed , "paste_remove_styles" ) || ( getParam ( ed , "paste_remove_styles_if_webkit" ) && tinymce . isWebKit ) ) { each ( dom . select ( '*[style]' , o . node ) , function ( el ) { el . removeAttribute ( 'style' ) ; el . removeAttribute ( 'data-mce-style' ) ; } ) ; } else { if ( tinymce . isWebKit ) { each ( dom . select ( '*' , o . node ) , function ( el ) { el . removeAttribute ( 'data-mce-style' ) ; } ) ; } } }
3613	function ( def ) { var start = Array . isArray ( def . start ) ? def . start : [ def . start ] ; var end = Array . isArray ( def . end ) ? def . end : [ def . end ] ; var then = def . then ? ( Array . isArray ( def . then ) ? def . then : [ def . then ] ) : [ ] ; var child = new Block ( line , { start : start , end : end , then : then } , self ) ; self . children . push ( child ) ; return child ; }
728	function ( ) { if ( ! this . isRequired ) return false ; var invalid = ! this . items . length ; this . isInvalid = invalid ; this . $control_input . prop ( 'required' , invalid ) ; this . $input . prop ( 'required' , ! invalid ) ; }
1258	function updateSync ( component , replaceNode = true ) { if ( ! isValidVirtualNode ( component . virtualNode ) ) { throw new Error ( ` ${ component . constructor ? component . constructor . name + ' instance' : component } ` ) } if ( component . element == null ) { throw new Error ( ` ${ component . constructor ? component . constructor . name + ' instance' : component } ` ) } let newVirtualNode = component . render ( ) if ( ! isValidVirtualNode ( newVirtualNode ) ) { const namePart = component . constructor && component . constructor . name ? ' in ' + component . constructor . name : '' throw new Error ( 'invalid falsy value ' + newVirtualNode + ' returned from render()' + namePart ) } applyContext ( component , newVirtualNode ) syncUpdatesInProgressCounter ++ let oldVirtualNode = component . virtualNode let oldDomNode = component . element let newDomNode = patch ( oldVirtualNode , newVirtualNode , { refs : component . refs , listenerContext : component } ) component . virtualNode = newVirtualNode if ( newDomNode !== oldDomNode && ! replaceNode ) { throw new Error ( 'The root node type changed on update, but the update was performed with the replaceNode option set to false' ) } else { component . element = newDomNode } if ( typeof component . writeAfterUpdate === 'function' ) { component . writeAfterUpdate ( ) } if ( typeof component . readAfterUpdate === 'function' ) { getScheduler ( ) . readDocument ( function ( ) { component . readAfterUpdate ( ) } ) } syncUpdatesInProgressCounter -- }
2065	function ( elem , event , listener ) { if ( elem . detachEvent ) { elem . detachEvent ( "on" + event , listener ) ; } else { elem . removeEventListener ( event , listener , false ) ; } }
1607	function srcToChunks ( src , opts , ctx ) { opts = opts || { } var ast = parse ( src , opts ) var errors = semantic . checkAst ( ast , ctx ) if ( errors ) { if ( opts . printErrors !== false ) { errors . forEach ( function ( e ) { console . error ( e ) } ) } return } else { return compiler . astToChunks ( ast , ctx , opts . format ) } }
3493	function getFixerFunction ( ) { var rangeToFix = [ ] ; if ( needed > gotten ) { var spaces = "" + new Array ( needed - gotten + 1 ) . join ( indentChar ) ; if ( isLastNodeCheck === true ) { rangeToFix = [ node . range [ 1 ] - 1 , node . range [ 1 ] - 1 ] ; } else { rangeToFix = [ node . range [ 0 ] , node . range [ 0 ] ] ; } return function ( fixer ) { return fixer . insertTextBeforeRange ( rangeToFix , spaces ) ; } ; } else { if ( isLastNodeCheck === true ) { rangeToFix = [ node . range [ 1 ] - ( gotten - needed ) - 1 , node . range [ 1 ] - 1 ] ; } else { rangeToFix = [ node . range [ 0 ] - ( gotten - needed ) , node . range [ 0 ] ] ; } return function ( fixer ) { return fixer . removeRange ( rangeToFix ) ; } ; } }
2511	function getFileInfo ( fileId , filePath , cb , repeated ) { repeated = repeated || 0 ; var fullPath = resolve ( filePath ) . fullPath ; fs . exists ( fullPath , function ( exists ) { if ( ! exists ) cb ( ) ; else fs . stat ( fullPath , function ( err , stat ) { if ( err && err . code === 'ENOENT' ) { cb ( ) ; } else if ( err && repeated < 5 ) setTimeout ( function ( ) { getFileInfo ( fileId , fullPath , cb , repeated + 1 ) ; } , 200 ) ; else if ( err ) cb ( err ) ; else cb ( null , getFileItem ( fileId , stat , fullPath ) ) ; } ) ; } ) ; }
497	function ( runState ) { const [ a , b ] = runState . stack . popN ( 2 ) const r = new BN ( a . lt ( b ) ? 1 : 0 ) runState . stack . push ( r ) }
881	function removeVariableDeclaration ( t , bindVar , removeOpts ) { let refPaths = bindVar . referencePaths || [ ] ; let removed ; refPaths . forEach ( item => { let parentPath = item . getStatementParent ( ) ; if ( t . isVariableDeclaration ( parentPath ) && t . isIdentifier ( item ) ) { removeNode ( t , item . parentPath , removeOpts ) ; removeComments ( t , parentPath , 'leadingComments' ) ; removed = true ; } } ) ; if ( ! removed ) { removeNode ( t , bindVar . path . getStatementParent ( ) , removeOpts ) ; } }
2009	function centerEntityOnPoint ( game , entity , point ) { var size = game . entities . getComponent ( entity , "size" ) ; var position = game . entities . addComponent ( entity , "position" ) ; position . x = point . x - ( size . width / 2 ) ; position . y = point . y - ( size . height / 2 ) ; }
1123	function getMasterInstance ( instances ) { let instanceId ; const instanceIds = Object . keys ( instances ) ; for ( let i = 0 ; i < instanceIds . length ; i ++ ) { instanceId = instanceIds [ i ] ; if ( instances [ instanceId ] . isMaster ) { return { id : instanceId , instance : instances [ instanceId ] } ; } } return null ; }
937	function registerProcessor ( existedProcessors , extnameProcessorMap , opts ) { let { name , processor , deps , rext , extnames , options , order , hook } = opts ; if ( ! name ) { throw new Error ( 'missing processor name to register' ) ; } if ( existedProcessors . hasOwnProperty ( name ) ) { overrideProcessor ( existedProcessors [ name ] , extnameProcessorMap , opts ) ; } else { existedProcessors [ name ] = initProcessorInfo ( name , { processor , deps , rext , extnames , options , order , hook } , existedProcessors ) ; addFileExtnameAssociatedProcessor ( extnames , name , extnameProcessorMap ) ; } if ( extnames && ! Array . isArray ( extnames ) ) { extnames = [ extnames ] ; } extnames && extnames . forEach ( k => sortDefaultProcessors ( extnameProcessorMap [ k ] , existedProcessors ) ) ; }
1374	function inferMaster ( ) { var inferred = _ . find ( self . nestedLocales , { name : self . defaultLocale } ) || self . nestedLocales [ 0 ] ; if ( ( self . nestedLocales . length > 1 ) && ( ! _ . find ( self . nestedLocales , function ( locale ) { return locale . children && locale . children . length ; } ) ) ) { var others = _ . filter ( self . nestedLocales , function ( locale ) { return locale . name !== inferred . name ; } ) ; self . nestedLocales = [ inferred ] ; if ( others . length ) { inferred . children = others ; } } }
2394	function parse ( report ) { var sys = report [ 'system' ] || { } ; var info = report [ 'report' ] || { } ; function _i ( x ) { return info [ x ] || '' ; } function _s ( x ) { return sys [ x ] || '' ; } var error = report [ 'crash' ] [ 'error' ] ; var thread = Utils . get_crash_thread ( report ) ; return [ Utils . header ( 'Incident Identifier:' , _i ( 'id' ) , 4 ) , Utils . header ( 'CrashReporter Key:' , _s ( 'device_app_hash' ) , 4 ) , Utils . header ( 'Hardware Model:' , _s ( 'machine' ) , 4 ) , Utils . header ( 'Process:' , ` ${ _s ( 'process_name' ) } ${ _s ( 'process_id' ) } ` ) , Utils . header ( 'Path:' , _s ( 'CFBundleExecutablePath' ) ) , Utils . header ( 'Identifier:' , _s ( 'CFBundleIdentifier' ) ) , Utils . header ( 'Version:' , ` ${ _s ( 'CFBundleShortVersionString' ) } ${ _s ( 'CFBundleVersion' ) } ` ) , Utils . header ( 'Code Type:' , get_cpu_arch ( report ) ) , Utils . header ( 'Parent Process:' , ` ${ _s ( 'parent_process_name' ) } ${ _s ( 'parent_process_id' ) } ` ) , Utils . header ( '' , '' ) , Utils . header ( 'Date/Time:' , get_time ( report ) ) , Utils . header ( 'OS Version:' , ` ${ _s ( 'system_name' ) } ${ _s ( 'system_version' ) } ${ _s ( 'os_version' ) } ` ) , Utils . header ( 'Report Version:' , 104 ) , Utils . header ( '' , '' ) ] . concat ( Errors . parse_errors ( error , thread ) ) ; }
2274	function fatalError ( stderr ) { return { errors : [ { message : [ { path : '' , code : 0 , line : 0 , start : 0 , descr : stderr } ] } ] } ; }
3232	function ( ) { var me = this , surface = me . getSurface ( ) , destroySprites = me . autoDestroy , item ; if ( surface ) { while ( me . getCount ( ) > 0 ) { item = me . first ( ) ; me . remove ( item ) ; surface . remove ( item , destroySprites ) ; } } me . clearListeners ( ) ; }
411	function replaceParentSelector ( paths , context , inSelector ) { var i , j , k , currentElements , newSelectors , selectorsMultiplied , sel , el , hadParentSelector = false , length , lastSelector ; function findNestedSelector ( element ) { var maybeSelector ; if ( ! ( element . value instanceof Paren ) ) { return null ; } maybeSelector = element . value . value ; if ( ! ( maybeSelector instanceof Selector ) ) { return null ; } return maybeSelector ; } currentElements = [ ] ; newSelectors = [ [ ] ] ; for ( i = 0 ; ( el = inSelector . elements [ i ] ) ; i ++ ) { if ( el . value !== '&' ) { var nestedSelector = findNestedSelector ( el ) ; if ( nestedSelector != null ) { mergeElementsOnToSelectors ( currentElements , newSelectors ) ; var nestedPaths = [ ] , replaced , replacedNewSelectors = [ ] ; replaced = replaceParentSelector ( nestedPaths , context , nestedSelector ) ; hadParentSelector = hadParentSelector || replaced ; for ( k = 0 ; k < nestedPaths . length ; k ++ ) { var replacementSelector = createSelector ( createParenthesis ( nestedPaths [ k ] , el ) , el ) ; addAllReplacementsIntoPath ( newSelectors , [ replacementSelector ] , el , inSelector , replacedNewSelectors ) ; } newSelectors = replacedNewSelectors ; currentElements = [ ] ; } else { currentElements . push ( el ) ; } } else { hadParentSelector = true ; selectorsMultiplied = [ ] ; mergeElementsOnToSelectors ( currentElements , newSelectors ) ; for ( j = 0 ; j < newSelectors . length ; j ++ ) { sel = newSelectors [ j ] ; if ( context . length === 0 ) { if ( sel . length > 0 ) { sel [ 0 ] . elements . push ( new Element ( el . combinator , '' , el . isVariable , el . _index , el . _fileInfo ) ) ; } selectorsMultiplied . push ( sel ) ; } else { for ( k = 0 ; k < context . length ; k ++ ) { var newSelectorPath = addReplacementIntoPath ( sel , context [ k ] , el , inSelector ) ; selectorsMultiplied . push ( newSelectorPath ) ; } } } newSelectors = selectorsMultiplied ; currentElements = [ ] ; } } mergeElementsOnToSelectors ( currentElements , newSelectors ) ; for ( i = 0 ; i < newSelectors . length ; i ++ ) { length = newSelectors [ i ] . length ; if ( length > 0 ) { paths . push ( newSelectors [ i ] ) ; lastSelector = newSelectors [ i ] [ length - 1 ] ; newSelectors [ i ] [ length - 1 ] = lastSelector . createDerived ( lastSelector . elements , inSelector . extendList ) ; } } return hadParentSelector ; }
1246	function ( read_only , encapsed , byref ) { let result ; if ( ! byref && this . token === "&" ) { byref = true ; this . next ( ) ; } if ( this . is ( [ this . tok . T_VARIABLE , "$" ] ) ) { result = this . read_reference_variable ( encapsed , byref ) ; } else if ( this . is ( [ this . tok . T_NS_SEPARATOR , this . tok . T_STRING , this . tok . T_NAMESPACE ] ) ) { result = this . node ( ) ; const name = this . read_namespace_name ( ) ; if ( this . token != this . tok . T_DOUBLE_COLON && this . token != "(" && [ "parentreference" , "selfreference" ] . indexOf ( name . kind ) === - 1 ) { const literal = name . name . toLowerCase ( ) ; if ( literal === "true" ) { result = name . destroy ( result ( "boolean" , true , name . name ) ) ; } else if ( literal === "false" ) { result = name . destroy ( result ( "boolean" , false , name . name ) ) ; } else { result = result ( "identifier" , name ) ; } } else { result . destroy ( name ) ; result = name ; } } else if ( this . token === this . tok . T_STATIC ) { result = this . node ( "staticreference" ) ; const raw = this . text ( ) ; this . next ( ) ; result = result ( raw ) ; } else { this . expect ( "VARIABLE" ) ; } if ( this . token === this . tok . T_DOUBLE_COLON ) { result = this . read_static_getter ( result , encapsed ) ; } return this . recursive_variable_chain_scan ( result , read_only , encapsed ) ; }
2458	function spy ( obj , method ) { if ( ! obj && ! method ) { obj = { spy : function ( ) { } } ; method = 'spy' ; } return double ( obj , method ) ; }
3706	function flatMap ( mapper ) { return function * ( iterable ) { let index = 0 ; for ( const value of iterable ) { const innerIterable = mapper ( value , index ) ; for ( const inner of innerIterable ) { yield inner ; } index = index + 1 ; } } ; }
1165	function ( el , selector ) { if ( el === this . el ) { return selector ; } var index = $ ( el ) . index ( ) ; selector = el . tagName + ':nth-child(' + ( index + 1 ) + ')' + ' ' + ( selector || '' ) ; return this . getSelector ( $ ( el ) . parent ( ) [ 0 ] , selector + ' ' ) ; }
959	function initExtensions ( type , instance , base ) { let cache = pluginCache ; if ( process . env . APP_TYPE === 'quick' ) { if ( ! appGlobal . okamPluginCache ) { appGlobal . okamPluginCache = pluginCache ; } cache = appGlobal . okamPluginCache ; } let existedBase = cache . baseClasses [ type ] ; if ( ! existedBase ) { let plugins = cache . usedExtensions [ type ] ; let args = [ { } ] ; plugins && Array . prototype . push . apply ( args , plugins ) ; args . push ( base ) ; existedBase = mixin . apply ( this , args ) ; cache . baseClasses [ type ] = existedBase ; } return mixin . apply ( this , [ instance , existedBase ] ) ; }
1117	function BigIq50LicenseProvider ( bigIp , options ) { const injectedLogger = options ? options . logger : undefined ; let loggerOptions = options ? options . loggerOptions : undefined ; if ( injectedLogger ) { this . logger = injectedLogger ; util . setLogger ( injectedLogger ) ; } else { loggerOptions = loggerOptions || { logLevel : 'none' } ; loggerOptions . module = module ; this . logger = Logger . getLogger ( loggerOptions ) ; util . setLoggerOptions ( loggerOptions ) ; } logger = this . logger ; this . bigIp = bigIp ; }
1645	function ( capture ) { var self = this ; self . clear ( ) ; self . capture = capture ; self . capture_idx = index_capture ( capture ) ; self . render ( ) ; }
1485	async function ( data ) { let t = this ; let result = { } ; return new Promise ( ( resolve , reject ) => { async . forEach ( data . libraries , function ( path , cb ) { t . __addLibrary ( path , result , cb ) ; } , function ( err ) { if ( err ) { reject ( err ) ; } else { resolve ( result ) ; } } ) ; } ) ; }
412	function ( value , unit ) { this . value = parseFloat ( value ) ; if ( isNaN ( this . value ) ) { throw new Error ( 'Dimension is not a number.' ) ; } this . unit = ( unit && unit instanceof Unit ) ? unit : new Unit ( unit ? [ unit ] : undefined ) ; this . setParent ( this . unit , this ) ; }
3362	function ( ) { var me = this ; me . direction = Ext . String . toggle ( me . direction , "ASC" , "DESC" ) ; me . updateSortFunction ( ) ; }
477	function getDeepProperty ( obj , keys ) { var _ref = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : { } , _ref$throwError = _ref . throwError , throwError = _ref$throwError === undefined ? false : _ref$throwError , backup = _ref . backup ; if ( isString ( keys ) ) { keys = keys . split ( '.' ) ; } if ( ! isArray ( keys ) ) { throw new TypeError ( 'keys of getDeepProperty must be string or Array<string>' ) ; } var read = [ ] ; var target = obj ; for ( var i = 0 , len = keys . length ; i < len ; i ++ ) { var key = keys [ i ] ; if ( isVoid ( target ) ) { if ( throwError ) { throw new Error ( 'obj' + ( read . length > 0 ? '.' + read . join ( '.' ) : ' itself' ) + ' is ' + target ) ; } else { return backup ; } } target = target [ key ] ; read . push ( key ) ; } return target ; }
1470	async function ( ) { let compileJsonPath = null ; try { path . join ( await this . getApplicationPath ( ) , "compile.json" ) ; } catch ( ex ) { } if ( compileJsonPath && await fs . existsAsync ( compileJsonPath ) ) { let compileConfig = await this . parseCompileConfig ( ) ; let qxpath = false ; let appPath = await this . getApplicationPath ( ) ; if ( compileConfig . libraries ) { for ( let somepath of compileConfig . libraries ) { let manifestPath = somepath ; if ( ! path . isAbsolute ( somepath ) ) { manifestPath = path . join ( appPath , manifestPath ) ; } manifestPath = path . join ( manifestPath , "Manifest.json" ) ; let manifest = await this . parseJsonFile ( manifestPath ) ; try { if ( manifest . provides . namespace === "qx" ) { qxpath = path . dirname ( manifestPath ) ; return qxpath ; } } catch ( e ) { console . warn ( ` ${ manifestPath } ` ) ; } } } } return this . getGlobalQxPath ( ) ; }
2206	function getArrayValues ( string , values ) { string = string . split ( " " ) . join ( "" ) ; if ( arrayRegex . test ( string ) ) return string . match ( arrayRegex ) [ 1 ] . split ( "," ) ; else { var array = processPlaceholder ( string , values ) ; if ( ! mout . lang . isArray ( array ) ) array = [ ] ; return array ; } }
2369	function del ( key , cb ) { if ( ! syncConfig . useCache || ! redisClient ) { return cb && cb ( ) ; } return redisClient . del ( key , cb ) ; }
333	function setDragMode ( mode ) { var options = this . options , dragBox = this . dragBox , face = this . face ; if ( this . ready && ! this . disabled ) { var croppable = mode === DRAG_MODE_CROP ; var movable = options . movable && mode === DRAG_MODE_MOVE ; mode = croppable || movable ? mode : DRAG_MODE_NONE ; options . dragMode = mode ; setData ( dragBox , DATA_ACTION , mode ) ; toggleClass ( dragBox , CLASS_CROP , croppable ) ; toggleClass ( dragBox , CLASS_MOVE , movable ) ; if ( ! options . cropBoxMovable ) { setData ( face , DATA_ACTION , mode ) ; toggleClass ( face , CLASS_CROP , croppable ) ; toggleClass ( face , CLASS_MOVE , movable ) ; } } return this ; }
2240	function getId ( callback ) { var self = this ; if ( typeof self . params . IdentityId === 'string' ) return callback ( ) ; self . cognito . getId ( function ( err , data ) { if ( ! err && data . IdentityId ) { self . params . IdentityId = data . IdentityId ; } callback ( err , data ) ; } ) ; }
2691	function createDataMessage ( parentMessage , representations ) { var content = { data : representations } ; return newMessage ( _messageNames . displayData , parentMessage , content ) ; }
60	function insertAfter ( element , target ) { if ( ! is$1 . element ( element ) || ! is$1 . element ( target ) ) { return ; } target . parentNode . insertBefore ( element , target . nextSibling ) ; }
1532	function ( scope , element , attrs , trvw ) { if ( ! compiledContents ) { compiledContents = $compile ( trvw . getNodeTpl ( ) ) ; } compiledContents ( scope , function ( clone ) { element . append ( clone ) ; } ) ; if ( link && link . post ) { link . post . apply ( null , arguments ) ; } }
2265	function ensureNameForm ( name , i ) { var pos = i || 0 ; if ( ! utils . isArray ( name . data . nameForms ) ) { name . data . nameForms = [ ] ; } while ( pos >= name . data . nameForms . length ) { name . data . nameForms . push ( { } ) ; } return name . data . nameForms [ pos ] ; }
211	function ready ( ) { const notes = getAllNotes ( store . getState ( ) ) ; const timestamps = notes . map ( property ( 'timestamp' ) ) . map ( timestamp => Date . parse ( timestamp ) / 1000 ) ; let newNoteCount = timestamps . filter ( time => time > this . lastSeenTime ) . length ; if ( ! this . firstRender && this . lastSeenTime === 0 ) { newNoteCount = 0 ; } const latestType = get ( notes . slice ( - 1 ) [ 0 ] , 'type' , null ) ; store . dispatch ( { type : 'APP_RENDER_NOTES' , newNoteCount , latestType } ) ; this . hasNewNoteData = false ; this . firstRender = false ; }
2077	function parseResponseType ( req ) { if ( req . query && req . query . responseType ) { if ( req . query . responseType == 'modal' ) { req . query . responseType = req . we . config . defaultResponseType ; req . query . contentOnly = true ; } req . headers . accept = mime . getType ( req . query . responseType . toLowerCase ( ) ) ; } if ( req . accepts ( req . we . config . responseTypes ) ) return ; req . headers . accept = req . we . config . defaultResponseType ; }
2399	function parse_errors ( error , thread ) { var signal = error [ 'signal' ] ; var mach = error [ 'mach' ] ; var exc_name = mach [ 'exception_name' ] || '0' ; var code_name = mach [ 'code_name' ] || '0x00000000' ; var sig_name = signal [ 'name' ] || signal [ 'signal' ] || '0' ; var addr_name = Utils . pad_hex ( error [ 'address' ] || 0 , '0' , 8 ) ; var index = 0 ; if ( thread ) { index = thread [ 'index' ] ; } return [ Utils . header ( 'Exception Type:' , ` ${ exc_name } ${ sig_name } ` ) , Utils . header ( 'Exception Codes:' , ` ${ code_name } ${ addr_name } ` ) , Utils . header ( 'Crashed Thread:' , index ) ] ; }
3124	function ( fn , scope ) { var items = Ext . Array . push ( [ ] , this . items ) , i = 0 , len = items . length , item ; for ( ; i < len ; i ++ ) { item = items [ i ] ; if ( fn . call ( scope || item , item , i , len ) === false ) { break ; } } }
2325	function computeInputData ( manager , input ) { var session = manager . session ; var pointers = input . pointers ; var pointersLength = pointers . length ; if ( ! session . firstInput ) { session . firstInput = simpleCloneInputData ( input ) ; } if ( pointersLength > 1 && ! session . firstMultiple ) { session . firstMultiple = simpleCloneInputData ( input ) ; } else if ( pointersLength === 1 ) { session . firstMultiple = false ; } var firstInput = session . firstInput ; var firstMultiple = session . firstMultiple ; var offsetCenter = firstMultiple ? firstMultiple . center : firstInput . center ; var center = input . center = getCenter ( pointers ) ; input . timeStamp = now ( ) ; input . deltaTime = input . timeStamp - firstInput . timeStamp ; input . angle = getAngle ( offsetCenter , center ) ; input . distance = getDistance ( offsetCenter , center ) ; computeDeltaXY ( session , input ) ; input . offsetDirection = getDirection ( input . deltaX , input . deltaY ) ; var overallVelocity = getVelocity ( input . deltaTime , input . deltaX , input . deltaY ) ; input . overallVelocityX = overallVelocity . x ; input . overallVelocityY = overallVelocity . y ; input . overallVelocity = abs ( overallVelocity . x ) > abs ( overallVelocity . y ) ? overallVelocity . x : overallVelocity . y ; input . scale = firstMultiple ? getScale ( firstMultiple . pointers , pointers ) : 1 ; input . rotation = firstMultiple ? getRotation ( firstMultiple . pointers , pointers ) : 0 ; input . maxPointers = ! session . prevInput ? input . pointers . length : input . pointers . length > session . prevInput . maxPointers ? input . pointers . length : session . prevInput . maxPointers ; computeIntervalInputData ( session , input ) ; var target = manager . element ; if ( hasParent ( input . srcEvent . target , target ) ) { target = input . srcEvent . target ; } input . target = target ; }
3825	function ( verb , path , controllerName ) { var controllerPath = this . options . controllersPath + controllerName ; try { var controller = require ( this . options . rootPath + controllerPath ) ; for ( var field in controller ) { if ( typeof controller [ field ] == 'function' ) { this . addNewRouteEntry ( verb , path . replace ( / {method} / , field ) , controllerName , field ) ; } } } catch ( e ) { throw new Error ( 'The specified controller (' + controllerPath + ') does not exist.' ) ; } }
3820	function ( url , val ) { var object = extend ( { } , val ) ; var append = false ; var remaining = url . match ( / :\w+ / ig ) ; if ( remaining && remaining . length > 0 ) { for ( var j = 0 ; j < remaining . length ; j ++ ) { var key = remaining [ j ] . replace ( ':' , '' ) ; if ( object [ key ] !== undefined ) { if ( this . canSerialise ( object [ key ] ) ) { var keyRegex = new RegExp ( ':' + key ) ; url = url . replace ( keyRegex , object [ key ] ) ; } delete object [ key ] ; } } if ( object !== { } ) { append = true ; } } else { append = true ; } if ( append ) { for ( var attr in object ) { if ( this . canSerialise ( object [ attr ] ) ) { var joiner = ( url . indexOf ( '?' ) >= 0 ) ? "&" : "?" ; url += joiner + attr + "=" + object [ attr ] ; } } } return url ; }
1989	function ( e ) { for ( var i in this . handlersList ) { if ( this . handlersList [ i ] . over === true ) { try { this . handlersList [ i ] . blurCallback ( e ) ; } catch ( ex ) { } } } }
3255	function ( ) { var result = { } , fields = this . fields , key , field ; for ( key in fields ) { if ( fields . hasOwnProperty ( key ) ) { field = fields [ key ] ; if ( field . isValid ( ) && field . getValue ( ) !== null ) { result [ key ] = field . getValue ( ) ; } } } return result ; }
52	function setup ( target ) { var options = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; var targets = null ; if ( is . empty ( target ) || is . string ( target ) ) { targets = Array . from ( document . querySelectorAll ( is . string ( target ) ? target : 'input[type="range"]' ) ) ; } else if ( is . element ( target ) ) { targets = [ target ] ; } else if ( is . nodeList ( target ) ) { targets = Array . from ( target ) ; } else if ( is . array ( target ) ) { targets = target . filter ( is . element ) ; } if ( is . empty ( targets ) ) { return null ; } var config = Object . assign ( { } , defaults , options ) ; if ( is . string ( target ) && config . watch ) { var observer = new MutationObserver ( function ( mutations ) { Array . from ( mutations ) . forEach ( function ( mutation ) { Array . from ( mutation . addedNodes ) . forEach ( function ( node ) { if ( ! is . element ( node ) || ! matches ( node , target ) ) { return ; } var range = new RangeTouch ( node , config ) ; } ) ; } ) ; } ) ; observer . observe ( document . body , { childList : true , subtree : true } ) ; } return targets . map ( function ( t ) { return new RangeTouch ( t , options ) ; } ) ; }
1770	function valueShouldBeInsertedAsHTML ( value ) { return value !== null && typeof value === "object" && ( typeof value [ toDOMSymbol ] === "function" || typeof value [ viewInsertSymbol ] === "function" || typeof value . nodeType === "number" ) ; }
2769	function tryMatchSequence ( key ) { seq . keys . push ( key . name ) ; var m = vim . map . matchInsert ( seq . keys ) , passThru = true ; if ( ! m ) { self . clearSequence ( ) ; } else if ( m === true ) { } else if ( matchSequence ( m ) ) { passThru = false ; } if ( passThru ) seq . last = new Date ( ) ; return passThru ; }
218	function parseCaption ( node , _parsed ) { if ( node . attrs && node . attrs . named ) { if ( REGEXP_CAPTION_ALIGN . test ( node . attrs . named . align ) ) { _parsed . appearance . align = node . attrs . named . align . match ( REGEXP_CAPTION_ALIGN ) [ 1 ] ; } if ( REGEXP_CAPTION_ID . test ( node . attrs . named . id ) ) { _parsed . media . ID = parseInt ( node . attrs . named . id . match ( REGEXP_CAPTION_ID ) [ 1 ] , 10 ) ; } if ( _parsed . media . width && isFinite ( node . attrs . named . width ) ) { _parsed . media . width = parseInt ( node . attrs . named . width , 10 ) ; } } if ( ! node . content ) { return _parsed ; } const img = node . content . match ( REGEXP_CAPTION_CONTENT ) ; if ( img && img [ 2 ] ) { _parsed . media . caption = img [ 2 ] . trim ( ) ; } if ( img ) { return _recurse ( img [ 1 ] , _parsed ) ; } return _parsed ; }
2103	function call ( ) { var args = [ xdhq , 3 ] ; var i = 0 ; while ( i < arguments . length ) args . push ( arguments [ i ++ ] ) ; njsq . _call . apply ( null , args ) ; }
2185	function _curry2 ( fn ) { return function f2 ( a , b ) { switch ( arguments . length ) { case 0 : return f2 ; case 1 : return _isPlaceholder ( a ) ? f2 : _curry1 ( function ( _b ) { return fn ( a , _b ) ; } ) ; default : return _isPlaceholder ( a ) && _isPlaceholder ( b ) ? f2 : _isPlaceholder ( a ) ? _curry1 ( function ( _a ) { return fn ( _a , b ) ; } ) : _isPlaceholder ( b ) ? _curry1 ( function ( _b ) { return fn ( a , _b ) ; } ) : fn ( a , b ) ; } } ; }
2532	function getChainDataById ( storage , chainId ) { if ( storage [ GET_CHAIN_METHOD ] ) { return storage [ GET_CHAIN_METHOD ] ( chainId ) ; } return storage [ chainId ] ; }
904	function normalizePages ( result , pages , prefix ) { let entryPageName ; pages . forEach ( ( item , idx ) => { let filter ; if ( typeof item === 'object' ) { let { path , filter : pageFilter } = item ; item = path ; filter = pageFilter ; } let { pageName , componentName } = getPageInfo ( item , prefix ) ; let pageInfo = { component : componentName } ; filter && ( pageInfo . filter = filter ) ; result [ pageName ] = pageInfo ; if ( idx === 0 ) { entryPageName = pageName ; } } ) ; return entryPageName ; }
1720	function _startHideAnimation ( item , prevItem , size ) { var spec = item . options . hide . animation ? item . options . hide . animation . call ( undefined , false , size ) : { } ; item . endSpec = spec ; item . startSpec = { opacity : 1 , transform : Transform . identity } ; if ( ! item . halted ) { item . mod . halt ( ) ; var callback = item . hideCallback ; if ( spec . transform ) { item . mod . setTransform ( spec . transform , item . options . hide . transition , callback ) ; callback = undefined ; } if ( spec . opacity !== undefined ) { item . mod . setOpacity ( spec . opacity , item . options . hide . transition , callback ) ; callback = undefined ; } if ( callback ) { callback ( ) ; } } }
1634	function uniqueCountryData ( data , type , parent ) { var hash = data . reduce ( function each ( prev , curr ) { if ( ! ( curr [ type ] in prev ) ) { if ( parent ) { if ( parent . label === curr [ parent . type ] ) { prev [ curr [ type ] ] = curr ; } } else if ( curr [ type ] ) { prev [ curr [ type ] ] = curr ; } } return prev ; } , { } ) ; return Object . keys ( hash ) . map ( function each ( item ) { return extend ( hash [ item ] , { label : item , type : type === 'name' ? 'country' : type } ) ; } ) ; }
3204	function ( fo , clear ) { this . filters = fo ; if ( this . filters && this . filterFields ) { for ( var fn in this . filters ) { if ( ! this . filterFields [ fn ] ) delete this . filters [ fn ] ; } for ( var fn in this . filterFields ) { var field = this . filterFields [ fn ] ; var value = this . filters [ field . filterName ] ; if ( Ext . isEmpty ( value ) ) { if ( clear ) this . setFieldValue ( field , '' ) ; } else this . setFieldValue ( field , value ) ; } } }
3484	function hasRightSideBr ( ) { var walker = new TreeWalker ( container , parentBlock ) , node ; while ( node = walker . current ( ) ) { if ( node . nodeName == 'BR' ) { return true ; } node = walker . next ( ) ; } }
3155	function ( ) { this . port = DEFAULT_STUBBATTI_PORT ; this . app = express ( ) ; this . console = global . console ; var stubbatti = this ; this . app [ KILL_METHOD ] ( KILL_PATH , function ( req , res ) { res . set ( 'Connection' , 'close' ) ; res . end ( ) ; stubbatti . stop ( ) ; } ) ; }
3370	function ( e ) { var msg ; tinymce . each ( tinyMCE . editors , function ( ed ) { if ( ed . plugins . autosave ) ed . plugins . autosave . storeDraft ( ) ; if ( ed . getParam ( "fullscreen_is_enabled" ) ) return ; if ( ! msg && ed . isDirty ( ) && ed . getParam ( "autosave_ask_before_unload" ) ) msg = ed . getLang ( "autosave.unload_msg" ) ; } ) ; return msg ; }
1907	function trimWhitespaceTokens ( tokens , mask ) { mask = mask || ( WHITESPACE_REMOVE_FROM_START | WHITESPACE_REMOVE_FROM_END ) ; var whitespace = [ 'white' , 'line' ] ; if ( ( mask & WHITESPACE_REMOVE_FROM_END ) == WHITESPACE_REMOVE_FROM_END ) while ( tokens . length && _ . include ( whitespace , _ . last ( tokens ) . type ) ) { tokens . pop ( ) ; } if ( ( mask & WHITESPACE_REMOVE_FROM_START ) == WHITESPACE_REMOVE_FROM_START ) while ( tokens . length && _ . include ( whitespace , tokens [ 0 ] . type ) ) { tokens . shift ( ) ; } return tokens ; }
2290	function triggerEvent ( el , name , data ) { var e = new LeipzigEvent ( name , data ) ; el . dispatchEvent ( e ) ; }
1253	function findAncestorDistance ( src , target , currentDistance ) { if ( target === src ) { return currentDistance ; } const distances = [ ] ; src . getParents ( ) . forEach ( ( srcParentChunkGroup ) => { const distance = findAncestorDistance ( srcParentChunkGroup , target , currentDistance + 1 ) ; if ( distance >= 0 ) { distances . push ( distance ) ; } } ) ; if ( distances . length === 0 ) { return - 1 ; } return Math . min ( ... distances ) ; }
1976	function isValid ( { accessToken , clientToken } ) { return fetch ( ` ${ YGGDRASIL_API } ` , { method : 'POST' , body : JSON . stringify ( { accessToken , clientToken } ) , headers : { 'user-agent' : USER_AGENT , 'content-type' : 'application/json' } } ) . then ( handleErrors ) . then ( res => true ) . catch ( err => { if ( err . message === 'Invalid token' ) return false throw err } ) }
191	function deleteInvites ( siteInvites , invitesToDelete ) { return siteInvites . filter ( siteInvite => ! includes ( invitesToDelete , siteInvite . key ) ) ; }
150	function updateCachedProduct ( products , product ) { let found = false ; const updatedProduct = { ... product , name : decodeEntities ( product . name ) } ; const newProducts = products . map ( p => { if ( p . id === product . id ) { found = true ; return updatedProduct ; } return p ; } ) ; if ( ! found ) { newProducts . push ( updatedProduct ) ; } return newProducts ; }
820	function ( ) { registry_item . ready = true ; for ( var i = 0 ; i < registry_item . ready_listeners . length ; i ++ ) { registry_item . ready_listeners [ i ] ( ) ; } registry_item . ready_listeners = [ ] ; }
805	function makeStandard ( standardize , fn ) { return function ( ) { return standardize ( fn . apply ( null , [ ] . slice . call ( arguments ) ) ) ; } }
416	function ( forceEscaped ) { var str , index = parserInput . i , isEscaped = false ; parserInput . save ( ) ; if ( parserInput . $char ( '~' ) ) { isEscaped = true ; } else if ( forceEscaped ) { parserInput . restore ( ) ; return ; } str = parserInput . $quoted ( ) ; if ( ! str ) { parserInput . restore ( ) ; return ; } parserInput . forget ( ) ; return new ( tree . Quoted ) ( str . charAt ( 0 ) , str . substr ( 1 , str . length - 2 ) , isEscaped , index , fileInfo ) ; }
460	function getDomain ( props , axis ) { const inherentAxis = getAxis ( props ) ; if ( axis && axis !== inherentAxis ) { return undefined ; } return Domain . createDomainFunction ( getDomainFromData ) ( props , inherentAxis ) ; }
430	function bind ( func , thisArg ) { var curryArgs = Array . prototype . slice . call ( arguments , 2 ) ; return function ( ) { var args = curryArgs . concat ( Array . prototype . slice . call ( arguments , 0 ) ) ; return func . apply ( thisArg , args ) ; } ; }
2812	function ( expected , actual , msg ) { var assert = bender . assert ; assert . isTypeOf ( 'object' , expected , 'Expected is not an object' ) ; assert . isTypeOf ( 'object' , actual , 'Actual is not an object' ) ; expected = JSON . stringify ( objectHelpers . sortObjectProperties ( expected ) ) ; actual = JSON . stringify ( objectHelpers . sortObjectProperties ( actual ) ) ; this . js ( expected , actual , msg ) ; }
3762	function AbstractSyntaxTree ( root , labels , manager ) { this . root = root ; this . labels = labels ; this . manager = manager ; manager . parse ( this ) ; }
159	function handlePostLocked ( calypsoPort ) { const unsubscribe = subscribe ( ( ) => { const isLocked = select ( 'core/editor' ) . isPostLocked ( ) ; const isLockTakeover = select ( 'core/editor' ) . isPostLockTakeover ( ) ; const lockedDialogButtons = document . querySelectorAll ( 'div.editor-post-locked-modal__buttons > a' ) ; const isPostTakeoverDialog = isLocked && ! isLockTakeover && lockedDialogButtons . length === 3 ; if ( isPostTakeoverDialog ) { lockedDialogButtons [ 0 ] . addEventListener ( 'click' , event => { event . preventDefault ( ) ; calypsoPort . postMessage ( { action : 'goToAllPosts' } ) ; } , false ) ; if ( calypsoifyGutenberg && calypsoifyGutenberg . closeUrl ) { lockedDialogButtons [ 0 ] . setAttribute ( 'target' , '_parent' ) ; lockedDialogButtons [ 0 ] . setAttribute ( 'href' , calypsoifyGutenberg . closeUrl ) ; } lockedDialogButtons [ 2 ] . setAttribute ( 'href' , addQueryArgs ( lockedDialogButtons [ 2 ] . getAttribute ( 'href' ) , { calypsoify : 1 , 'frame-nonce' : getQueryArg ( window . location . href , 'frame-nonce' ) , } ) ) ; unsubscribe ( ) ; } } ) ; }
1600	function run ( opts ) { throwIfRequiredOption ( opts , 'src' ) Module . _extensions [ util . ext ] = function ( module , filename ) { var content = fs . readFileSync ( filename , 'utf8' ) var result = ram . compile ( content , { filename : filename , format : 'cjs' , } ) module . _compile ( result . js , filename ) } Module . prototype . load = function load ( filename ) { var extension = path . extname ( filename ) this . filename = filename this . paths = Module . _nodeModulePaths ( path . dirname ( filename ) ) Module . _extensions [ extension ] ( this , filename ) return this . loaded = true } var src = opts [ 'src' ] var absolute = path . resolve ( process . cwd ( ) , src ) Object . assign ( global , R ) require ( absolute ) }
3367	function ( ) { var self = this , storage = self . storage , editor = self . editor , expires , content ; if ( storage ) { if ( ! storage . getItem ( self . key ) && ! editor . isDirty ( ) ) return ; content = editor . getContent ( { draft : true } ) ; if ( content . length > editor . settings . autosave_minlength ) { expires = self . getExpDate ( ) ; if ( ! self . storage . autoExpires ) self . storage . setItem ( self . key + "_expires" , expires ) ; self . storage . setItem ( self . key , content ) ; self . onStoreDraft . dispatch ( self , { expires : expires , content : content } ) ; } } }
2247	function get ( pathOrCzConfig , defaultConfig ) { const config = Object . assign ( cloneDeep ( defaults ) , cloneDeep ( defaultConfig ) || { } ) ; let czConfig = pathOrCzConfig || { } ; if ( typeof pathOrCzConfig === 'string' ) { czConfig = CzConfig . get ( pathOrCzConfig ) ; } const hasScopeEnum = Object . prototype . hasOwnProperty . call ( config . rules , 'scope-enum' ) ; if ( hasScopeEnum && ( typeof czConfig . scopes !== 'undefined' || typeof czConfig . scopeOverrides !== 'undefined' ) ) { config . rules [ 'scope-enum' ] [ 2 ] = Scopes . get ( czConfig ) ; } if ( hasScopeEnum && ! config . rules [ 'scope-enum' ] [ 2 ] . length ) { delete config . rules [ 'scope-enum' ] ; } const hasTypeEnum = Object . prototype . hasOwnProperty . call ( config . rules , 'type-enum' ) ; if ( hasTypeEnum && typeof czConfig . types !== 'undefined' ) { config . rules [ 'type-enum' ] [ 2 ] = Types . get ( czConfig ) ; } if ( hasTypeEnum && ! config . rules [ 'type-enum' ] [ 2 ] . length ) { delete config . rules [ 'type-enum' ] ; } return config ; }
3824	function ( ) { if ( this . routes . length === 0 ) { var routes ; try { routes = this . readFile ( this . options . rootPath + this . options . routesFile ) ; } catch ( e ) { throw new Error ( 'The specified routes file (' + this . options . routesFile + ') does not exist or could not be read.' ) ; } for ( var i = 0 ; i < routes . length ; i ++ ) { var bits = routes [ i ] . split ( / \s+ / ) ; var controller = bits [ 2 ] . split ( '.' ) ; if ( controller [ 1 ] == '{method}' ) { this . getWildcardRoutes ( bits [ 0 ] . toLowerCase ( ) , bits [ 1 ] , controller [ 0 ] ) ; } else { this . addNewRouteEntry ( bits [ 0 ] . toLowerCase ( ) , bits [ 1 ] , controller [ 0 ] , controller [ 1 ] ) ; } } } return this . routes ; }
2689	function createExecuteSuccessResponseMessage ( parentMessage , executionCount , metadata ) { var content = { status : 'ok' , execution_count : executionCount , payload : [ ] , user_variables : { } , user_expressions : { } } ; return newMessage ( _messageNames . executeResponse , parentMessage , content , metadata ) ; }
1016	function ( path , body , contentType ) { return this . _getParentId ( path ) . then ( ( parentId ) => { const fileName = baseName ( path ) ; const metadata = { title : metaTitleFromFileName ( fileName ) , mimeType : contentType , parents : [ { kind : "drive#fileLink" , id : parentId } ] } ; return this . _request ( 'POST' , BASE_URL + '/upload/drive/v2/files?uploadType=resumable' , { body : JSON . stringify ( metadata ) , headers : { 'Content-Type' : 'application/json; charset=UTF-8' } } ) . then ( ( response ) => { return this . _request ( 'POST' , response . getResponseHeader ( 'Location' ) , { body : contentType . match ( / ^application\/json / ) ? JSON . stringify ( body ) : body } ) ; } ) ; } ) ; }
894	function normalizeViewPlugins ( plugins , appType ) { return plugins . map ( pluginInfo => { let pluginItem = pluginInfo ; let pluginOptions ; if ( Array . isArray ( pluginInfo ) ) { pluginItem = pluginInfo [ 0 ] ; pluginOptions = pluginInfo [ 1 ] ; } if ( typeof pluginItem === 'string' ) { let pluginPath = BUILTIN_PLUGINS [ pluginItem ] ; if ( typeof pluginPath === 'function' ) { pluginPath = pluginPath ( appType ) ; } else if ( pluginPath && typeof pluginPath === 'object' ) { pluginPath = pluginPath [ appType ] || pluginPath . default ; } if ( pluginPath && Array . isArray ( pluginPath ) ) { pluginOptions = pluginPath [ 1 ] ; pluginPath = pluginPath [ 0 ] ; } pluginPath && ( pluginItem = pluginPath ) ; } if ( typeof pluginItem === 'string' ) { pluginItem = require ( pluginItem ) ; } return pluginOptions ? [ pluginItem , pluginOptions ] : pluginItem ; } ) ; }
1240	function ( expect , isBinary = false ) { let node = this . node ( "encapsed" ) ; this . next ( ) ; const start = this . lexer . yylloc . prev_offset - ( isBinary ? 1 : 0 ) ; const value = [ ] ; let type = null ; if ( expect === "`" ) { type = this . ast . encapsed . TYPE_SHELL ; } else if ( expect === '"' ) { type = this . ast . encapsed . TYPE_STRING ; } else { type = this . ast . encapsed . TYPE_HEREDOC ; } while ( this . token !== expect && this . token !== this . EOF ) { value . push ( this . read_encapsed_string_item ( true ) ) ; } this . expect ( expect ) && this . next ( ) ; node = node ( value , this . lexer . _input . substring ( start - 1 , this . lexer . yylloc . first_offset ) , type ) ; if ( expect === this . tok . T_END_HEREDOC ) { node . label = this . lexer . heredoc_label ; } return node ; }
3740	function endsWith ( data , str ) { if ( data . length < str . length ) return false ; if ( data === str ) return true ; return data . lastIndexOf ( str ) === data . length - str . length ; }
2178	function shouldPaginate ( ) { if ( ctrl . noPagination || ! loaded ) return false ; var canvasWidth = $element . prop ( 'clientWidth' ) ; angular . forEach ( getElements ( ) . tabs , function ( tab ) { canvasWidth -= tab . offsetWidth ; } ) ; return canvasWidth < 0 ; }
1095	function getReplyMethod ( request ) { let target = findTargetFromParentInfo ( request ) ; if ( target ) { return ( ... a ) => { if ( 'isDestroyed' in target && target . isDestroyed ( ) ) return ; target . send ( ... a ) ; } ; } else { d ( "Using reply to main process" ) ; return ( ... a ) => ipc . send ( ... a ) ; } }
3073	function ( input ) { this . reset ( ) ; this . form = { signature : utils . sha256 ( input ) , text : input , html : { prompt : '' , template : '' , solution : '' } , controls : [ ] } ; this . inline . formCompiler = this ; this . form . html . template = this . append ( input ) . outToString ( ) ; this . prepareHtml ( ) ; return this . form ; }
3770	async function first ( iterable ) { var e_13 , _a ; try { for ( var iterable_11 = __asyncValues ( iterable ) , iterable_11_1 ; iterable_11_1 = await iterable_11 . next ( ) , ! iterable_11_1 . done ; ) { const item = iterable_11_1 . value ; return item ; } } catch ( e_13_1 ) { e_13 = { error : e_13_1 } ; } finally { try { if ( iterable_11_1 && ! iterable_11_1 . done && ( _a = iterable_11 . return ) ) await _a . call ( iterable_11 ) ; } finally { if ( e_13 ) throw e_13 . error ; } } return undefined ; }
3209	function ( testFn ) { var me = this , old = me . getChildEls ( ) , keepers = ( me . childEls = [ ] ) , n , i , cel ; for ( i = 0 , n = old . length ; i < n ; ++ i ) { cel = old [ i ] ; if ( ! testFn ( cel ) ) { keepers . push ( cel ) ; } } }
1458	async function ( ) { let compile = await this . parseCompileConfig ( ) ; for ( let target of compile . targets ) { await this . __removePath ( path . join ( process . cwd ( ) , target . outputPath ) ) ; } await this . __removePath ( path . join ( process . cwd ( ) , "contrib" ) ) ; }
1873	function ( text , pad ) { var lines = this . splitByLines ( text ) ; for ( var i = 0 ; i < lines . length ; i ++ ) { if ( lines [ i ] . search ( pad ) == 0 ) lines [ i ] = lines [ i ] . substr ( pad . length ) ; } return lines . join ( this . getNewline ( ) ) ; }
2446	function isIterator ( obj ) { return Boolean ( obj && ( typeof Symbol === 'function' ? obj [ Symbol . iterator ] : isFunction ( obj [ '@@iterator' ] ) ) ) ; }
1486	function ( rootDir , result , cb ) { var lib = new qx . tool . compiler . app . Library ( ) ; lib . loadManifest ( rootDir , function ( err ) { if ( ! err ) { let s = lib . getNamespace ( ) ; let libs = s . split ( "." ) ; result [ libs [ 0 ] ] = false ; } return cb && cb ( err , lib ) ; } ) ; }
1286	function ArrayPush ( ) { CHECK_OBJECT_COERCIBLE ( this , "Array.prototype.push" ) ; var array = TO_OBJECT ( this ) ; var n = TO_LENGTH ( array . length ) ; var m = arguments . length ; if ( m > kMaxSafeInteger - n ) throw MakeTypeError ( kPushPastSafeLength , m , n ) ; for ( var i = 0 ; i < m ; i ++ ) { array [ i + n ] = arguments [ i ] ; } var new_length = n + m ; array . length = new_length ; return new_length ; }
1084	function updateEventListeners ( el , prevEvents , events ) { var eventName ; if ( ! prevEvents || ! events || prevEvents === events ) { return ; } for ( eventName in events ) { if ( prevEvents [ eventName ] === events [ eventName ] ) { continue ; } if ( prevEvents [ eventName ] ) { removeEventListeners ( el , eventName , prevEvents [ eventName ] ) ; } addEventListeners ( el , eventName , events [ eventName ] ) ; } for ( eventName in prevEvents ) { if ( ! events [ eventName ] ) { removeEventListeners ( el , eventName , prevEvents [ eventName ] ) ; } } }
3678	function findPath ( request , paths ) { if ( paths . length == 1 && / ^\.{2} / . test ( request ) ) { paths [ 0 ] = path . dirname ( paths [ 0 ] ) request = request . slice ( 1 ) } return originalFindPath ( request , paths ) }
2177	function scroll ( event ) { if ( ! ctrl . shouldPaginate ) return ; event . preventDefault ( ) ; ctrl . offsetLeft = fixOffset ( ctrl . offsetLeft - event . wheelDelta ) ; }
2272	function materializedRetryStrategy ( strategy ) { return function ( source ) { switch ( strategy . kind ) { case "ignoreErrorJustComplete" : return source . pipe ( catchError_1 . catchError ( function ( e ) { dispatchError ( e ) ; return rx . empty ( ) ; } ) ) ; case "ignoreErrorAndReturn" : return source . pipe ( catchError_1 . catchError ( function ( e ) { dispatchError ( e ) ; return rx . of ( strategy . value ) ; } ) ) ; case "exponentialBackoff" : return rx . defer ( function ( ) { var counter = 1 ; return source . pipe ( tap_1 . tap ( function ( ) { counter = 1 ; } , function ( ) { if ( counter * 2 <= strategy . maxBackoffFactor ) { counter *= 2 ; } } ) , retryWhen_1 . retryWhen ( function ( e ) { return e . pipe ( switchMap_1 . switchMap ( function ( x ) { dispatchError ( x ) ; return rx . of ( 0 ) . pipe ( delay_1 . delay ( strategy . initialTimeout * counter * 1000 ) ) ; } ) ) ; } ) ) ; } ) ; case "catchError" : return source . pipe ( catchError_1 . catchError ( function ( e ) { dispatchError ( e ) ; return rx . of ( strategy . handle ( e ) ) ; } ) ) ; default : return js_extensions_1 . unhandledCase ( strategy ) ; } } ; }
1363	function clone ( v ) { if ( v === null || typeof v !== "object" ) { return v ; } if ( isArray ( v ) ) { var arr = v . slice ( ) ; for ( var i = 0 ; i < v . length ; i ++ ) { arr [ i ] = clone ( arr [ i ] ) ; } return arr ; } else { var obj = { } ; for ( var k in v ) { obj [ k ] = clone ( v [ k ] ) ; } return obj ; } }
1348	function parseAll ( data ) { if ( ! data || ! data [ 0 ] ) { return [ ] } if ( process . platform . includes ( 'linux' ) ) { var rows = data [ 0 ] . split ( '\n' ) \n } else return rows . map ( function ( row ) { return parseLinux ( row , servers ) } ) . filter ( Boolean ) if ( process . platform . includes ( 'win32' ) ) { var winRows = data [ 0 ] . split ( '\n' ) . \n splice ( 1 ) } }
1706	function _goToPage ( amount , noAnimation ) { var viewSequence = ( ! noAnimation ? this . _scroll . scrollToSequence : undefined ) || this . _viewSequence ; if ( ! this . _scroll . scrollToSequence && ! noAnimation ) { var firstVisibleItem = this . getFirstVisibleItem ( ) ; if ( firstVisibleItem ) { viewSequence = firstVisibleItem . viewSequence ; if ( ( ( amount < 0 ) && ( firstVisibleItem . scrollOffset < 0 ) ) || ( ( amount > 0 ) && ( firstVisibleItem . scrollOffset > 0 ) ) ) { amount = 0 ; } } } if ( ! viewSequence ) { return ; } for ( var i = 0 ; i < Math . abs ( amount ) ; i ++ ) { var nextViewSequence = ( amount > 0 ) ? viewSequence . getNext ( ) : viewSequence . getPrevious ( ) ; if ( nextViewSequence ) { viewSequence = nextViewSequence ; } else { break ; } } _goToSequence . call ( this , viewSequence , amount >= 0 , noAnimation ) ; }
1496	function ( args ) { var opts ; for ( var i = 0 , l = args . length ; i < l ; i ++ ) { if ( args [ i ] . indexOf ( "settings=" ) == 0 ) { opts = args [ i ] . substr ( 9 ) ; break ; } else if ( args [ i ] . indexOf ( "'settings=" ) == 0 ) { opts = / 'settings\=(.*?)' / . exec ( args [ i ] ) [ 1 ] ; break ; } } if ( opts ) { opts = opts . replace ( / \\\{ / g , "{" ) . replace ( / \\\} / g , "}" ) ; opts = qx . lang . Json . parse ( opts ) ; for ( var prop in opts ) { var value = opts [ prop ] ; if ( typeof value == "string" ) { value = value . replace ( / \$$ / g , " " ) ; } try { qx . core . Environment . add ( prop , value ) ; } catch ( ex ) { this . error ( "Unable to define command-line setting " + prop + ": " + ex ) ; } } } }
179	function settingsRequestError ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_FAILURE : const error = WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_FAILURE === action . type ? action . error : false ; return error ; } return state ; }
2460	function createLogger ( conf , bitwise ) { conf = conf || { } ; if ( conf . json === undefined ) conf . json = true ; return new Logger ( conf , bitwise ) ; }
3003	function it ( type , value ) { var i , t ; if ( type === '(color)' || type === '(range)' ) { t = { type : type } ; } else if ( type === '(punctuator)' || ( type === '(identifier)' && is_own ( syntax , value ) ) ) { t = syntax [ value ] || syntax [ '(error)' ] ; } else { t = syntax [ type ] ; } t = Object . create ( t ) ; if ( type === '(string)' || type === '(range)' ) { if ( jx . test ( value ) ) { warningAt ( "Script URL." , line , from ) ; } } if ( type === '(identifier)' ) { t . identifier = true ; if ( value === '__iterator__' || value === '__proto__' ) { errorAt ( "Reserved name '{a}'." , line , from , value ) ; } else if ( option . nomen && ( value . charAt ( 0 ) === '_' || value . charAt ( value . length - 1 ) === '_' ) ) { warningAt ( "Unexpected {a} in '{b}'." , line , from , "dangling '_'" , value ) ; } } t . value = value ; t . line = line ; t . character = character ; t . from = from ; i = t . id ; if ( i !== '(endline)' ) { prereg = i && ( ( '(,=:[!&|?{};' . indexOf ( i . charAt ( i . length - 1 ) ) >= 0 ) || i === 'return' ) ; } return t ; }
2350	function ( filter , callback ) { metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doListDatasetClients ) ( filter , callback ) ; }
3758	function SyncFile ( path , flags , mode ) { flags = flags || 'w' ; this . fd = fs . openSync ( path , flags , mode ) ; this . crc = new Crc64 ( ) ; this . converter = new Converter ( ) ; }
3841	function intoExport ( obj ) { for ( var k in obj ) { if ( ! obj . hasOwnProperty ( k ) ) continue ; exports [ k ] = obj [ k ] ; } }
443	function getSymmetricDomain ( domain , values ) { const processedData = sortedUniq ( values . sort ( ( a , b ) => a - b ) ) ; const step = processedData [ 1 ] - processedData [ 0 ] ; return [ domain [ 0 ] , domain [ 1 ] + step ] ; }
1501	function clearRequest ( reqs , reqid ) { var self = this ; var entry = reqs [ reqid ] ; if ( entry ) { if ( entry . timeout ) { clearTimeout ( entry . timeout ) ; } delete reqs [ reqid ] ; } }
1207	function ( avoidHiddenFields ) { var field , fieldName , newValue , focusedElement = document . querySelector ( ":focus" ) , fields = this . container . querySelectorAll ( SELECTOR_FIELDS ) , length = fields . length , i = 0 ; for ( ; i < length ; i ++ ) { field = fields [ i ] ; if ( field === focusedElement ) { continue ; } if ( avoidHiddenFields && field . type === "hidden" ) { continue ; } fieldName = field . getAttribute ( ATTRIBUTE_FIELDS ) ; newValue = this . elementToChange ? ( this . elementToChange [ fieldName ] || "" ) : field . defaultValue ; field . value = newValue ; } }
3108	function ( identifier ) { if ( ! Bella . contains ( this . lines , identifier ) ) { this . lines . push ( identifier ) ; this . Event . onAddOnlineUser ( identifier ) ; return true ; } return false ; }
2560	function applyLibraryToPrototypes ( ) { if ( ! attached ) { Object . defineProperty ( Object . prototype , handle , { configurable : true , enumerable : false , set : function ( v ) { if ( this [ handle ] !== v ) { Object . defineProperty ( this , handle , { configurable : true , enumerable : true , writable : true , value : v } ) ; } } , get : function ( ) { var ccId , proto = getProto ( this ) , cId = proto . constructor . __get_protolib_id__ , lib = { } , i = 0 , last = null , m ; currentThis = this ; do { ccId = proto . constructor . __get_protolib_id__ ; if ( cached [ ccId ] && i === 0 ) { return cached [ ccId ] ; } else if ( cached [ ccId ] ) { for ( m in cached [ ccId ] ) if ( cached [ ccId ] . hasOwnProperty ( m ) ) lib [ m ] = cached [ ccId ] [ m ] ; if ( ! inheritanceChain [ cId ] ) inheritanceChain [ cId ] = [ ] ; inheritanceChain [ cId ] = inheritanceChain [ ccId ] . concat ( inheritanceChain [ cId ] ) ; cached [ cId ] = lib ; return lib ; } else { if ( ! libp [ ccId ] ) libp [ ccId ] = { } ; for ( m in libp [ ccId ] ) if ( libp [ ccId ] . hasOwnProperty ( m ) ) lib [ m ] = libp [ ccId ] [ m ] ; if ( ! inheritanceChain [ ccId ] ) inheritanceChain [ ccId ] = [ ] ; inheritanceChain [ cId ] . unshift ( ccId ) ; cached [ cId ] = lib ; last = ccId ; } ++ i ; } while ( proto = getProto ( proto ) ) ; lib . __protolib_cId__ = cId ; return lib ; } } ) ; attached = true ; } return self ; }
2201	function ( expr , context , subIntegral ) { var simplified = simplify . simplifyCore ( expr , context ) ; if ( ! simplified . equals ( expr ) ) { return subIntegral ( simplified , context , "simplified expression" ) ; } }
1419	function ( cb ) { var t = this ; async . waterfall ( [ function readDb ( cb ) { fs . exists ( t . getDbFilename ( ) , function ( exists ) { if ( exists ) { fs . readFile ( t . getDbFilename ( ) , { encoding : "utf-8" } , cb ) ; } else { cb ( null , null ) ; } } ) ; } , function parseDb ( data , cb ) { if ( data && data . trim ( ) . length ) { log . debug ( "Parsing database" ) ; t . __db = jsonlint . parse ( data ) ; } else { log . debug ( "No database to parse" ) ; t . __db = { } ; } cb ( null , t . __db ) ; } ] , function ( err , result ) { log . debug ( "loaded database: err=" + err ) ; cb ( ) ; } ) ; }
3029	function getObjFromDate ( date , adjustTimezone ) { var obj = { year : date . getYear ( ) , month : date . getMonth ( ) , day : date . getDay ( ) , hours : date . getHours ( ) , minutes : date . getMinutes ( ) , seconds : date . getSeconds ( ) } if ( adjustTimezone ) { if ( obj . minutes != undefined && date . getTZMinutes ( ) != undefined ) { obj . minutes += date . getTZMinutes ( ) ; } if ( obj . hours != undefined && date . getTZHours ( ) != undefined ) { obj . hours += date . getTZHours ( ) ; } } return obj ; }
618	function filterOneCharacterWordCombinations ( wordCombinations ) { return wordCombinations . filter ( function ( combination ) { return ! ( combination . getLength ( ) === 1 && combination . getWords ( ) [ 0 ] . length <= 1 ) ; } ) ; }
2783	function ( url ) { grunt . verbose . write ( 'Running PhantomJS...' ) . or . write ( '...' ) ; grunt . log . error ( ) ; grunt . warn ( 'PhantomJS unable to load "' + url + '" URI.' , 90 ) ; }
1828	function getTokenByName ( account , device_id , names = null ) { return co ( function * ( ) { const tokens = yield account . devices . tokenList ( device_id ) ; if ( ! tokens || ! tokens [ 0 ] ) return ; let token ; if ( names ) { names = Array . isArray ( names ) ? names : [ names ] ; for ( const name of names ) { token = tokens . find ( ( token ) => token . name . indexOf ( name ) >= 0 ) ; if ( token ) break ; } } else { token = tokens [ 0 ] ; } if ( ! token ) throw ` ${ device_id } ${ names } ` ; return token . token ; } ) . catch ( ( error ) => { throw error ; } ) ; }
2427	function ( yaw , pitch , roll ) { var Rx , Ry , Rz ; if ( roll == 0 ) Rx = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] ; else Rx = [ [ 1 , 0 , 0 ] , [ 0 , Math . cos ( roll ) , Math . sin ( roll ) ] , [ 0 , - Math . sin ( roll ) , Math . cos ( roll ) ] ] ; if ( pitch == 0 ) Ry = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] ; else Ry = [ [ Math . cos ( pitch ) , 0 , - Math . sin ( pitch ) ] , [ 0 , 1 , 0 ] , [ Math . sin ( pitch ) , 0 , Math . cos ( pitch ) ] ] ; if ( yaw == 0 ) Rz = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] ; else Rz = [ [ Math . cos ( yaw ) , Math . sin ( yaw ) , 0 ] , [ - Math . sin ( yaw ) , Math . cos ( yaw ) , 0 ] , [ 0 , 0 , 1 ] ] ; var R = numeric . dotMMsmall ( Ry , Rz ) ; R = numeric . dotMMsmall ( Rx , R ) ; return R ; }
2587	function ( n , placeholder ) { if ( n === undefined || n === null || ! libs . object . isNumeric ( n ) ) return n ; placeholder = typeof placeholder === 'string' ? placeholder : '.' ; var rest , idx , int , ns = n . toString ( ) , neg = n < 0 ; idx = ns . indexOf ( '.' ) ; int = parseInt ( Math . abs ( n ) , 10 ) . toString ( ) ; if ( idx > - 1 ) rest = '.' + ns . substring ( idx + 1 , ns . length ) ; return ( neg ? '-' : '' ) + libs . string . reverse ( libs . string . reverse ( int ) . replace ( / (\d{3})(?!$) / g , '$1,' ) ) + ( rest || '' ) ; }
3745	function initialize ( done ) { done = done || function ( ) { } ; if ( fileContents ) done ( ) ; fs . readFile ( __dirname + '/../../data/filesystem.json' , { encoding : 'utf8' } , function ( err , data ) { if ( err ) fileContents = { } ; else fileContents = JSON . parse ( data ) ; done ( ) ; } ) ; }
1929	function normalizeValue ( value ) { if ( value . charAt ( 0 ) == '-' && ! / ^\-[\.\d] / . test ( value ) ) { value = value . replace ( / ^\-+ / , '' ) ; } if ( value . charAt ( 0 ) == '#' ) { return normalizeHexColor ( value ) ; } return getKeyword ( value ) ; }
1282	function toLocaleDateTime ( date , locales , options , required , defaults , service ) { if ( ! ( date instanceof GlobalDate ) ) { throw MakeTypeError ( kMethodInvokedOnWrongType , "Date" ) ; } if ( IsNaN ( date ) ) return 'Invalid Date' ; var internalOptions = toDateTimeOptions ( options , required , defaults ) ; var dateFormat = cachedOrNewService ( service , locales , options , internalOptions ) ; return formatDate ( dateFormat , date ) ; }
143	function updateSiteState ( state , siteId , attributes ) { return Object . assign ( { } , state , { [ siteId ] : Object . assign ( { } , initialSiteState , state [ siteId ] , attributes ) , } ) ; }
3315	function ConversionHint ( conversion , arg ) { this . status = conversion . status ; this . message = conversion . message ; if ( arg ) { this . start = arg . start ; this . end = arg . end ; } else { this . start = 0 ; this . end = 0 ; } this . predictions = conversion . predictions ; }
3374	function ( ) { var me = this , headerCt = me . view . headerCt ; if ( headerCt ) { headerCt . items . each ( function ( header ) { var filter = me . getFilter ( header . dataIndex ) ; header [ filter && filter . active ? 'addCls' : 'removeCls' ] ( me . filterCls ) ; } ) ; } }
527	function ( string ) { var str = String ( string ) ; for ( var key in this . entityMap ) { str = str . replace ( RegExp ( this . entityMap [ key ] , "g" ) , key ) ; } return str ; }
3659	function mapException ( exception , warningHandler ) { try { if ( exception instanceof Error ) { var stacktrace ; return options . getExceptionInfo ( exception ) . then ( function ( trace ) { stacktrace = trace var smcFutures = [ ] for ( var n = 0 ; n < trace . length ; n ++ ) { if ( trace [ n ] . file !== undefined ) { smcFutures . push ( getSourceMapConsumer ( trace [ n ] . file , warningHandler ) ) } else { smcFutures . push ( Future ( undefined ) ) } } return Future . all ( smcFutures ) } ) . then ( function ( sourceMapConsumers ) { var CustomMappedException = proto ( MappedException , function ( ) { this . name = exception . name } ) try { throw CustomMappedException ( exception , stacktrace , sourceMapConsumers ) } catch ( mappedExcetion ) { return Future ( mappedExcetion ) } } ) } else { return Future ( exception ) } } catch ( e ) { var errorFuture = new Future errorFuture . throw ( e ) return errorFuture } }
2889	function ( collectionName , criterion , key , parentKey ) { var queryPart = '' ; if ( parentKey ) { return sql . prepareCriterion ( collectionName , criterion , key , parentKey ) ; } if ( key . toLowerCase ( ) === 'or' ) { queryPart = sql . build ( collectionName , criterion , sql . where , ' OR ' ) ; return ' ( ' + queryPart + ' ) ' ; } else if ( key . toLowerCase ( ) === 'and' ) { queryPart = sql . build ( collectionName , criterion , sql . where , ' AND ' ) ; return ' ( ' + queryPart + ' ) ' ; } else if ( _ . isArray ( criterion ) ) { queryPart = sql . prepareAttribute ( collectionName , null , key ) + " IN (" + sql . values ( collectionName , criterion , key ) + ")" ; return queryPart ; } else if ( key . toLowerCase ( ) === 'like' ) { return sql . build ( collectionName , criterion , function ( collectionName , value , attrName ) { var attrStr = sql . prepareAttribute ( collectionName , value , attrName ) ; attrStr = attrStr . replace ( / ' / g , '"' ) ; if ( _ . isRegExp ( value ) ) { throw new Error ( 'RegExp LIKE criterias not supported by the MySQLAdapter yet. Please contribute @ http://github.com/balderdashy/sails-mysql' ) ; } var valueStr = sql . prepareValue ( collectionName , value , attrName ) ; valueStr = valueStr . replace ( / %%% / g , '\\%' ) ; \\ var condition = ( attrStr + " LIKE " + valueStr ) ; } , return condition ; ) ; } else ' AND ' }
1813	function ( context ) { var _children = [ ] ; _children . push ( React . DOM . i ( { className : 'icon ' + context . icon } ) ) ; React . Children . forEach ( context . children , function ( child ) { _children . push ( child ) ; } ) ; context . children = _children ; }
3476	function ( command ) { var listElm , listParent ; execNativeCommand ( command ) ; listElm = dom . getParent ( selection . getNode ( ) , 'ol,ul' ) ; if ( listElm ) { listParent = listElm . parentNode ; if ( / ^(H[1-6]|P|ADDRESS|PRE)$ / . test ( listParent . nodeName ) ) { storeSelection ( ) ; dom . split ( listParent , listElm ) ; restoreSelection ( ) ; } } }
994	function localeSort ( a1 , a2 ) { if ( a1 !== undefined && a1 . localeCompare ) { return a1 . localeCompare ( a2 ) ; } return a1 > a2 ? 1 : ( a1 < a2 ? - 1 : 0 ) ; }
746	function ( seed , cb ) { var self = this ; utils . safeExec ( 'uname -a' , function ( err , uname ) { var userAgent = { } ; for ( var field in seed ) { userAgent [ field ] = encodeURIComponent ( seed [ field ] ) ; } userAgent . uname = encodeURIComponent ( uname || 'UNKNOWN' ) ; if ( self . _appInfo ) { userAgent . application = self . _appInfo ; } cb ( JSON . stringify ( userAgent ) ) } ) ; }
630	function MissingArgumentError ( message ) { Error . captureStackTrace ( this , this . constructor ) ; this . name = this . constructor . name ; this . message = message ; }
2118	function OktaAPIGroups ( apiToken , domain , preview ) { if ( apiToken == undefined || domain == undefined ) { throw new Error ( "OktaAPI requires an API token and a domain" ) ; } this . domain = domain ; if ( preview == undefined ) this . preview = false ; else this . preview = preview ; this . request = new NetworkAbstraction ( apiToken , domain , preview ) ; this . helpers = require ( './OktaAPIGroupsHelpers.js' ) }
2622	function create ( props ) { var joystick = Object . create ( this ) ; _canvasWidget2 . default . create . call ( joystick ) ; Object . assign ( joystick , Joystick . defaults , props ) ; if ( props . value ) joystick . __value = props . value ; joystick . init ( ) ; return joystick ; }
1962	function processCondition ( template , variables , matcher ) { while ( true ) { let matchedCondition = template . match ( matcher ) ; if ( ! matchedCondition ) { break ; } let fragment = matchedCondition [ 0 ] ; let conditionCode = matchedCondition [ 1 ] ; let testResult = evaluateCondition ( conditionCode , variables ) ; let replaceWith = testResult ? matchedCondition [ 2 ] : matchedCondition [ 3 ] || '' ; template = template . replace ( fragment , replaceWith ) ; } return template ; }
1249	function ( ) { while ( this . offset < this . size ) { const ch = this . input ( ) ; if ( ch === "\n" || \n ) ch === "\r" else \r } { return this . tok . T_COMMENT ; } }
453	function getCategories ( props , axis ) { return props . categories && ! Array . isArray ( props . categories ) ? props . categories [ axis ] : props . categories ; }
344	function TreePath ( container , root ) { if ( container ) { this . root = root ; this . path = document . createElement ( 'div' ) ; this . path . className = 'jsoneditor-treepath' ; this . path . setAttribute ( 'tabindex' , 0 ) ; this . contentMenuClicked ; container . appendChild ( this . path ) ; this . reset ( ) ; } }
2024	function ( callback ) { var cozyLight = require ( './cozy-light' ) ; if ( cozyLight . getStatus ( ) === 'started' ) { cozyLight . setStopped ( ) ; logger . info ( 'Stopping apps...' ) ; return applicationHelpers . stopAll ( function ( appErr ) { if ( appErr ) { logger . error ( 'An error occurred while stopping applications' ) ; logger . raw ( appErr ) ; } logger . info ( 'Stopping plugins...' ) ; pluginHelpers . stopAll ( function ( pluginErr ) { if ( pluginErr ) { logger . error ( 'An error occurred while stopping plugins' ) ; logger . raw ( pluginErr ) ; } logger . info ( 'Stopping server...' ) ; var timeout = nodeHelpers . throwTimeout ( 'main server is too slow to stop...' , 5000 ) ; mainAppHelper . stop ( function ( ) { clearTimeout ( timeout ) ; logger . info ( '\t' + \t + symbols . ok ) ; '\tmain server' } ) ; } ) ; } ) ; } \t nodeHelpers . invoke ( callback ) ; }
1580	function isDataFile ( filename ) { const ext = path . extname ( filename ) const filenameWithoutExt = path . basename ( filename , ext ) return filenameWithoutExt === 'data' && ext === '.xml' }
2380	function sync ( datasetId , params , cb ) { debug ( '[%s] process sync request for the dataset' , datasetId ) ; var queryParams = params . query_params || { } ; var metaData = params . meta_data || { } ; var datasetClient = new DatasetClient ( datasetId , { queryParams : queryParams , metaData : metaData } ) ; debug ( '[%s] processing sync API request :: query_params = %j:: meta_data = %j' , datasetId , queryParams , metaData ) ; async . series ( { requestInterceptor : async . apply ( interceptors . requestInterceptor , datasetId , params ) , readDatasetClient : function checkDatasetclientStopped ( callback ) { syncStorage . readDatasetClient ( datasetClient . getId ( ) , function ( err , datasetClientJson ) { if ( err ) { return callback ( err ) ; } if ( datasetClientJson && datasetClientJson . stopped === true ) { return callback ( new Error ( 'sync stopped for dataset ' + datasetId ) ) ; } else { return callback ( null , datasetClientJson ) ; } } ) ; } } , function ( err , results ) { if ( err ) { debugError ( '[%s] sync request returns error = %s %j' , datasetId , err , params ) ; return cb ( err ) ; } return processSyncAPI ( datasetId , params , results . readDatasetClient , cb ) ; } ) ; }
2604	function keys ( o ) { if ( o === undefined || o === null ) return [ ] ; var keys = getKeys ( o ) , idx ; if ( libs . object . isArguments ( o ) ) { idx = keys . indexOf ( 'length' ) ; if ( idx > - 1 ) keys . splice ( idx , 1 ) ; } return keys ; }
2472	function render ( activities , highlight ) { var verbs = topVerbs ( activities ) ; var selection = d3 . select ( selector ) . selectAll ( "li" ) . data ( filterVerbs ( activities ) , function ( activity ) { return activity . id } ) ; var li = selection . enter ( ) . append ( "li" ) ; li . html ( function ( activity ) { return activity . html . replace ( / (<time.*>).*(<\/time>) / , function ( _ , head , tail ) { var date = Date . create ( activity . published ) . format ( "{Weekday}, {Mon} {d} {h}:{mm} {TT}" ) ; return head + date + tail ; } ) } ) ; li . selectAll ( "div" ) . append ( "span" ) . attr ( "class" , "color" ) ; if ( highlight ) li . attr ( "class" , "highlight" ) . transition ( ) . delay ( 1 ) . attr ( "class" , "" ) ; selection . exit ( ) . remove ( ) ; selection . select ( ".color" ) . style ( "background-color" , function ( d ) { return verbColor ( verbs , d . verb ) ; } ) selection . order ( ) ; renderVerbs ( verbs ) ; }
533	function ( ) { this . _instance = null ; this . store = sessionStorage ; this . namespace = TableExport . prototype . defaultNamespace ; this . getKey = function ( key ) { return this . namespace + key ; } ; this . setItem = function ( _key , value , overwrite ) { var key = this . getKey ( _key ) ; if ( this . exists ( _key ) && ! overwrite ) { return ; } if ( typeof value !== "string" ) return _handleError ( '"value" must be a string.' ) ; this . store . setItem ( key , value ) ; return _key ; } ; this . getItem = function ( _key ) { var key = this . getKey ( _key ) ; return this . store . getItem ( key ) ; } ; this . exists = function ( _key ) { var key = this . getKey ( _key ) ; return this . store . getItem ( key ) !== null ; } ; this . removeItem = function ( _key ) { var key = this . getKey ( _key ) ; return this . store . removeItem ( key ) ; } ; }
2735	function ( update , options ) { var count = 0 for ( var id in this . cache ) { count += 1 if ( update . $inc ) { this . cache [ id ] . count += update . $inc } else { this . cache [ id ] . count -= update . $dec } } return count }
2916	function applyFormat ( method , args , string ) { var m , pos = 0 ; while ( ( m = string . substring ( pos ) . match ( argsExp ) ) ) { args . push ( m [ 2 ] ? + m [ 2 ] : ( m [ 1 ] ? m [ 1 ] === 'true' : m [ 4 ] . replace ( quotesExp [ m [ 3 ] ] , m [ 3 ] ) ) ) ; pos += m [ 0 ] . length ; } return method . apply ( null , args ) ; }
3002	function ( ) { var me = this , locked = me . lockable . lockedGrid . headerCt . getColumnsState ( ) , normal = me . lockable . normalGrid . headerCt . getColumnsState ( ) ; return locked . concat ( normal ) ; }
610	function createSentenceParts ( sentences , language ) { const auxiliaryRegex = languageVariables [ language ] . auxiliaryRegex ; const SentencePart = languageVariables [ language ] . SentencePart ; const sentenceParts = [ ] ; forEach ( sentences , function ( part ) { const foundAuxiliaries = sanitizeMatches ( part . match ( auxiliaryRegex || [ ] ) ) ; sentenceParts . push ( new SentencePart ( part , foundAuxiliaries , languageVariables [ language ] . locale ) ) ; } ) ; return sentenceParts ; }
740	function ( obj ) { if ( typeof obj !== 'object' ) { throw new Error ( 'Argument must be an object' ) ; } Object . keys ( obj ) . forEach ( function ( key ) { if ( obj [ key ] === null || obj [ key ] === undefined ) { delete obj [ key ] ; } } ) ; return obj ; }
1848	function getDeployments ( req , res ) { async . parallel ( { stack : dreadnot . getStackSummary . bind ( dreadnot , req . params . stack ) , region : dreadnot . getRegionSummary . bind ( dreadnot , req . params . stack , req . params . region ) , deployments : dreadnot . getDeploymentSummaries . bind ( dreadnot , req . params . stack , req . params . region ) } , renderCallback ( req , res , 'deployments.jade' ) ) ; }
1043	function onTableDataCollected ( err , data ) { bailOnError ( err ) ; var tableName , models = { } , model ; for ( tableName in data . tableStructure ) { model = steps . tableToObject ( { name : tableName , columns : data . tableStructure [ tableName ] , comment : data . tableComments [ tableName ] } , opts ) ; models [ model . name ] = model ; } data . models = steps . findReferences ( models ) ; steps . findOneToManyReferences ( adapter , data . models , function ( refErr ) { if ( refErr ) { throw refErr ; } data . types = steps . generateTypes ( data , opts ) ; adapter . close ( ) ; steps . outputData ( data , opts , onDataOutput ) ; } ) ; }
1307	function ScriptBreakPoint ( type , script_id_or_name , opt_line , opt_column , opt_groupId , opt_position_alignment ) { this . type_ = type ; if ( type == Debug . ScriptBreakPointType . ScriptId ) { this . script_id_ = script_id_or_name ; } else if ( type == Debug . ScriptBreakPointType . ScriptName ) { this . script_name_ = script_id_or_name ; } else if ( type == Debug . ScriptBreakPointType . ScriptRegExp ) { this . script_regexp_object_ = new GlobalRegExp ( script_id_or_name ) ; } else { throw MakeError ( kDebugger , "Unexpected breakpoint type " + type ) ; } this . line_ = opt_line || 0 ; this . column_ = opt_column ; this . groupId_ = opt_groupId ; this . position_alignment_ = IS_UNDEFINED ( opt_position_alignment ) ? Debug . BreakPositionAlignment . Statement : opt_position_alignment ; this . active_ = true ; this . condition_ = null ; this . break_points_ = [ ] ; }
2131	function ( rawErrors ) { var normalizedErrors = [ ] ; if ( typeof rawErrors === 'string' || ( typeof rawErrors === 'object' && ! Array . isArray ( rawErrors ) ) ) { rawErrors = [ rawErrors ] ; } if ( rawErrors != null ) { canReflect . eachIndex ( rawErrors , function ( error ) { [ ] . push . apply ( normalizedErrors , parseErrorItem ( error ) ) ; } ) ; } return normalizedErrors ; }
1430	function ( ) { if ( this . __qooxdooVersion ) { return this . __qooxdooVersion ; } if ( ! this . __qooxdooVersion ) { let lib = this . findLibrary ( "qx" ) ; if ( lib ) { this . __qooxdooVersion = lib . getVersion ( ) ; } } return this . __qooxdooVersion ; }
1434	async function ( ) { let contrib_json_path = this . getContribFileName ( ) ; if ( ! await fs . existsAsync ( contrib_json_path ) ) { return { version : qx . tool . cli . ConfigSchemas . lockfile . version , libraries : [ ] } ; } return qx . tool . compiler . utils . Json . loadJsonAsync ( contrib_json_path ) ; }
3478	function removeCaretContainer ( node , move_caret ) { var child , rng ; if ( ! node ) { node = getParentCaretContainer ( selection . getStart ( ) ) ; if ( ! node ) { while ( node = dom . get ( caretContainerId ) ) { removeCaretContainer ( node , false ) ; } } } else { rng = selection . getRng ( true ) ; if ( isCaretContainerEmpty ( node ) ) { if ( move_caret !== false ) { rng . setStartBefore ( node ) ; rng . setEndBefore ( node ) ; } dom . remove ( node ) ; } else { child = findFirstTextNode ( node ) ; if ( child . nodeValue . charAt ( 0 ) === INVISIBLE_CHAR ) { child = child . deleteData ( 0 , 1 ) ; } dom . remove ( node , 1 ) ; } selection . setRng ( rng ) ; } }
2370	function syncWithBackend ( payload , tries , callback ) { var datasetClientId = payload . id ; var datasetId = payload . datasetId ; var startTime = payload . startTime ; if ( ! datasetClientId || ! datasetId ) { recordProcessTime ( startTime , false ) ; debugError ( "no datasetId value found in sync request payload %j" , payload ) ; return callback ( ) ; } if ( tries > 1 ) { markDatasetClientAsCompleted ( datasetClientId , startTime , callback ) ; return ; } var queryParams = payload . queryParams || { } ; var metaData = payload . metaData || { } ; var expectedTimeout = datasets . getDatasetConfig ( datasetId ) . backendListTimeout * 1000 || 5 * 60 * 1000 ; async . waterfall ( [ function setSyncStart ( cb ) { var syncLoopStartTime = Date . now ( ) ; syncStorage . updateDatasetClient ( datasetClientId , { syncLoopStart : syncLoopStartTime , syncLoopEnd : syncLoopStartTime + expectedTimeout } , function ( err , datasetClient ) { return cb ( err , datasetClient ) ; } ) ; } , function listData ( datasetClient , cb ) { listDataWithTimeout ( { datasetClientId : datasetClientId , datasetId : datasetId , queryParams : queryParams , metaData : metaData } , expectedTimeout , function ( err , res ) { return cb ( err , datasetClient , res ) ; } ) ; } , function saveRecords ( datasetClient , recordsWithHash , cb ) { var toHash = _ . pluck ( recordsWithHash , 'hash' ) ; var globalHash = hashProvider . globalHash ( datasetId , toHash ) ; var globalHashWithCollisionCount = [ globalHash , datasetClient . collisionCount ] . join ( '_' ) ; syncStorage . updateDatasetClientWithRecords ( datasetClientId , { globalHash : globalHashWithCollisionCount } , recordsWithHash , cb ) ; } ] , function ( err ) { if ( err ) { debugError ( "[%s] Error when sync data with backend. error = %s" , datasetId , err ) ; } markDatasetClientAsCompleted ( datasetClientId , startTime , callback ) ; } ) ; }
2477	function findHeader ( aoa ) { const { i } = aoa . reduce ( ( prev , row , i ) => { const len = rowLength ( row ) if ( prev . len < len ) { return { i , len } } return prev } , { i : - 1 , len : 0 } ) return i }
1589	function updateStickyStack ( stickyStack , token , data ) { if ( token !== 'text' ) { stickyStack = stickyStack . filter ( notCategory ( categoryForCode ( data ) ) ) ; stickyStack . push ( { token : token , data : data , category : categoryForCode ( data ) } ) ; } return stickyStack ; }
1332	function loc ( start , end ) { if ( ! yy . options . captureLocations ) { return null ; } return { startOffset : start . startOffset , endOffset : end . endOffset , startLine : start . startLine , endLine : end . endLine , startColumn : start . startColumn , endColumn : end . endColumn , } ; }
2882	function readYamlFile ( file , cb ) { fs . readFile ( file , 'utf8' , ( err , data ) => { if ( err ) throw err ; cb ( yaml . safeLoad ( data ) ) ; } ) ; }
3077	function ( walk ) { var _super = BlockCompiler . prototype . emitParagraph . bind ( this ) ; if ( this . tryGroup ( 'checkbox' , walk ) ) return ; if ( this . tryGroup ( 'radio' , walk ) ) return ; if ( this . trySortableGroup ( walk ) ) return ; if ( this . tryAssociativeGroup ( walk ) ) return ; return _super ( walk ) ; }
2328	function ( tId , partialTree ) { if ( tId === void 0 ) { tId = '' ; } if ( partialTree === void 0 ) { partialTree = tree ; } if ( ! tId ) { return undefined ; } var found ; partialTree . some ( function ( treeItem ) { if ( treeItem [ id ] === tId ) { found = treeItem ; return true ; } found = treeItem [ children ] ? find ( tId , treeItem [ children ] ) : undefined ; return found ? true : false ; } ) ; return found ; }
2436	function Table ( tableConfiguration ) { return function ( constructor ) { var entityMetadata = constructor ; if ( entityMetadata . table ) { throw "Cannot set @Table, it is already set to '" + JSON . stringify ( entityMetadata . table ) + "'" ; } entityMetadata . table = tableConfiguration ; } ; }
737	function ( args ) { if ( args . length < 1 || ! isPlainObject ( args [ 0 ] ) ) { return { } ; } if ( ! utils . isOptionsHash ( args [ 0 ] ) ) { return args . shift ( ) ; } var argKeys = Object . keys ( args [ 0 ] ) ; var optionKeysInArgs = argKeys . filter ( function ( key ) { return OPTIONS_KEYS . indexOf ( key ) > - 1 ; } ) ; if ( optionKeysInArgs . length > 0 && optionKeysInArgs . length !== argKeys . length ) { emitWarning ( 'Options found in arguments (' + optionKeysInArgs . join ( ', ' ) + '). Did you mean to pass an options ' + 'object? See https://github.com/stripe/stripe-node/wiki/Passing-Options.' ) ; } return { } ; }
1626	function parse_scan ( show_hidden , callback ) { return function ( error , stdout , stderr ) { if ( error ) callback ( error ) ; else if ( show_hidden ) { callback ( error , stdout . split ( / Cell [0-9]+ - / ) . map ( parse_cell ) . filter ( has_keys ) . sort ( by_signal ) ) ; } else { callback ( error , stdout . split ( / Cell [0-9]+ - / ) . map ( parse_cell ) . filter ( has_ssid ) . sort ( by_signal ) ) ; } } ; }
3785	function ( string ) { return ( ( typeof string === 'string' || string instanceof String ) && string . length >= this . min && string . length <= this . max && ( ! this . match || string . match ( this . match ) ) ) ; }
1968	function getSession ( profileId ) { return fetch ( ` ${ SESSION_API } ${ profileId } ` , { headers : { 'user-agent' : USER_AGENT , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => { if ( res . status === 204 ) throw new Error ( 'no such profile' ) return res . json ( ) } ) . then ( ( { id , name , properties } ) => { const { timestamp , textures } = JSON . parse ( Base64 . decode ( properties [ 0 ] . value ) ) const { SKIN , CAPE } = textures return { id , name , timestamp , skin : SKIN && SKIN . url , cape : CAPE && CAPE . url , isSlim : SKIN && SKIN . metadata && SKIN . metadata . model === 'slim' } } ) }
2158	function ( $scope , element , attrs ) { var src = attrs . ngMessagesInclude || attrs . src ; $templateRequest ( src ) . then ( function ( html ) { if ( $scope . $$destroyed ) return ; if ( isString ( html ) && ! html . trim ( ) ) { replaceElementWithMarker ( element , src ) ; } else { $compile ( html ) ( $scope , function ( contents ) { element . after ( contents ) ; replaceElementWithMarker ( element , src ) ; } ) ; } } ) ; }
2500	function ( location , name , data , callback ) { if ( _isArray ( name ) ) { callback = data ; data = name ; name = null ; } return this . load ( location ) . then ( function ( content ) { var rctx = this ; if ( ! data ) { data = _isArray ( this . previous_content ) ? this . previous_content : [ ] ; } if ( callback ) { $ . each ( data , function ( i , value ) { var idata = { } , engine = this . next_engine || location ; name ? ( idata [ name ] = value ) : ( idata = value ) ; callback ( value , rctx . event_context . interpolate ( content , idata , engine ) ) ; } ) ; } else { return this . collect ( data , function ( i , value ) { var idata = { } , engine = this . next_engine || location ; name ? ( idata [ name ] = value ) : ( idata = value ) ; return this . event_context . interpolate ( content , idata , engine ) ; } , true ) ; } } ) ; }
957	function startBuild ( buildConf , clear ) { let buildManager = BuildManager . create ( buildConf . appType , buildConf ) ; if ( clear ) { buildManager . clear ( ) ; } startDevServer ( buildConf , buildManager ) ; let doneHandler = function ( ) { startFileChangeMonitor ( buildConf , buildManager ) ; } ; return runBuild ( buildConf , buildManager ) . then ( doneHandler , doneHandler ) ; }
1853	function ( name , func ) { wrapper . prototype [ name ] = function ( ) { var args = slice . call ( arguments ) ; unshift . call ( args , this . _wrapped ) ; return result ( func . apply ( _ , args ) , this . _chain ) ; } ; }
2277	function ( sourceFileName , code ) { var re = / class\s?([^\s]+)(\s?{|\s.*)|\s([^\s]+)\s?=\s?class / ; var m = re . exec ( code ) ; return ( sourceFileName || "" ) + ( m && m [ 1 ] || nonce ( ) ) ; }
3329	function ( ev ) { var handled ; if ( ev . keyCode === keys . RETURN ) { var worst = this . cli . getWorstHint ( ) ; if ( worst . status === Status . VALID ) { this . cli . exec ( ) ; this . element . value = '' ; } else { dom . setSelectionStart ( this . element , worst . start ) ; dom . setSelectionEnd ( this . element , worst . end ) ; } } this . update ( ) ; var current = this . cli . getAssignmentAt ( dom . getSelectionStart ( this . element ) ) ; if ( current ) { if ( ev . keyCode === keys . TAB ) { current . complete ( ) ; this . update ( ) ; } if ( ev . keyCode === keys . UP ) { current . increment ( ) ; this . update ( ) ; } if ( ev . keyCode === keys . DOWN ) { current . decrement ( ) ; this . update ( ) ; } } return handled ; }
3107	function ( v ) { var ots = Object . prototype . toString ; var s = typeof v ; if ( s == 'object' ) { if ( v ) { if ( ( ots . call ( v ) . indexOf ( 'HTML' ) !== - 1 && ots . call ( v ) . indexOf ( 'Element' ) != - 1 ) ) { return 'element' } if ( v instanceof Array || ( ! ( v instanceof Object ) && ( ots . call ( v ) == '[object Array]' ) || typeof v . length == 'number' && typeof v . splice != 'undefined' && typeof v . propertyIsEnumerable != 'undefined' && ! v . propertyIsEnumerable ( 'splice' ) ) ) { return 'array' } if ( ! ( v instanceof Object ) && ( ots . call ( v ) == '[object Function]' || typeof v . call != 'undefined' && typeof v . propertyIsEnumerable != 'undefined' && ! v . propertyIsEnumerable ( 'call' ) ) ) { return 'function' } } return 'null' ; } else if ( s == 'function' && typeof v . call == 'undefined' ) { return 'object' } return s ; }
2281	function getParams ( self , steamObj , requiredParams , optionalParams ) { var paramObj = { } ; for ( var i = 0 , len = requiredParams . length ; i < len ; i ++ ) { var paramName = requiredParams [ i ] ; paramName = paramName . replace ( "[0]" , "" ) ; paramObj [ paramName ] = get ( self , steamObj , paramName ) ; } for ( var i = 0 , len = optionalParams . length ; i < len ; i ++ ) { var paramName = optionalParams [ i ] ; paramName = paramName . replace ( "[0]" , "" ) ; try { paramObj [ paramName ] = get ( self , steamObj , paramName ) ; } catch ( e ) { } } return paramObj ; }
1034	function hookSync ( rs ) { if ( rs . _dropboxOrigSync ) { return ; } rs . _dropboxOrigSync = rs . sync . sync . bind ( rs . sync ) ; rs . sync . sync = function ( ) { return this . dropbox . fetchDelta . apply ( this . dropbox , arguments ) . then ( rs . _dropboxOrigSync , function ( err ) { rs . _emit ( 'error' , new Sync . SyncError ( err ) ) ; rs . _emit ( 'sync-done' ) ; } ) ; } . bind ( rs ) ; }
3004	function advance ( id , t ) { switch ( token . id ) { case '(number)' : if ( nexttoken . id === '.' ) { warning ( "A dot following a number can be confused with a decimal point." , token ) ; } break ; case '-' : if ( nexttoken . id === '-' || nexttoken . id === '--' ) { warning ( "Confusing minusses." ) ; } break ; case '+' : if ( nexttoken . id === '+' || nexttoken . id === '++' ) { warning ( "Confusing plusses." ) ; } break ; } if ( token . type === '(string)' || token . identifier ) { anonname = token . value ; } if ( id && nexttoken . id !== id ) { if ( t ) { if ( nexttoken . id === '(end)' ) { warning ( "Unmatched '{a}'." , t , t . id ) ; } else { warning ( "Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'." , nexttoken , id , t . id , t . line , nexttoken . value ) ; } } else if ( nexttoken . type !== '(identifier)' || nexttoken . value !== id ) { warning ( "Expected '{a}' and instead saw '{b}'." , nexttoken , id , nexttoken . value ) ; } } prevtoken = token ; token = nexttoken ; for ( ; ; ) { nexttoken = lookahead . shift ( ) || lex . token ( ) ; if ( nexttoken . id === '(end)' || nexttoken . id === '(error)' ) { return ; } if ( nexttoken . type === 'special' ) { doOption ( ) ; } else { if ( nexttoken . id !== '(endline)' ) { break ; } } } }
1069	function getAppAttributes ( attrs , req , res ) { if ( typeof attrs === 'function' ) { attrs = attrs ( req , res ) ; } return attrs || { } ; }
1076	function matchPath ( pathname , options = { } ) { if ( typeof options === 'string' ) options = { path : options } ; const { path , exact = false , strict = false , sensitive = false } = options ; const paths = [ ] . concat ( path ) ; return paths . reduce ( ( matched , p ) => { if ( matched ) return matched ; const { regexp , keys } = compilePath ( p , { end : exact , strict , sensitive } ) ; const match = regexp . exec ( pathname ) ; if ( ! match ) return null ; const [ url , ... values ] = match ; const isExact = pathname === url ; if ( exact && ! isExact ) return null ; return { path : p , url : p === '/' && url === '' ? '/' : url , isExact , params : keys . reduce ( ( memo , key , index ) => { memo [ key . name ] = values [ index ] ; return memo ; } , { } ) } ; } , null ) ; }
1880	function ( syntax , name , minScore ) { minScore = minScore || 0.3 ; var payload = this . getAllSnippets ( syntax ) ; var sc = require ( 'string-score' ) ; name = normalizeName ( name ) ; var scores = _ . map ( payload , function ( value , key ) { return { key : key , score : sc . score ( value . nk , name , 0.1 ) } ; } ) ; var result = _ . last ( _ . sortBy ( scores , 'score' ) ) ; if ( result && result . score >= minScore ) { var k = result . key ; return payload [ k ] . parsedValue ; } }
836	function readdirRecursivelySync ( dir ) { let results = [ ] ; const list = fs . readdirSync ( dir ) ; for ( let file of list ) { file = path . resolve ( dir , file ) ; const stat = fs . statSync ( file ) ; if ( stat && stat . isDirectory ( ) ) { results = results . concat ( readdirRecursivelySync ( file ) ) ; } else { results . push ( file ) ; } } return results ; }
3319	function ( assignment ) { if ( assignment . param . name !== '__command' ) { return ; } this . _assignments = { } ; if ( assignment . value ) { assignment . value . params . forEach ( function ( param ) { this . _assignments [ param . name ] = new Assignment ( param , this ) ; } , this ) ; } this . assignmentCount = Object . keys ( this . _assignments ) . length ; this . _dispatchEvent ( 'commandChange' , { command : assignment . value } ) ; }
2204	function parseInlineValues ( string ) { var match ; var values = { } ; while ( match = attributesRegex . exec ( string ) ) { values [ match [ 1 ] ] = match [ 2 ] ; } return values ; }
1162	function ( model ) { _ . each ( this . getConnectedLinks ( model ) , function ( link ) { link . set ( link . get ( 'source' ) . id === model . id ? 'source' : 'target' , g . point ( 0 , 0 ) ) ; } ) ; }
1846	function attemptLogin ( req , res ) { var username = req . param ( 'username' ) , password = req . param ( 'password' ) , next = req . param ( 'next' , '/' ) ; authdb . validate ( username , password , function ( err , valid ) { if ( valid ) { req . session . authed = true ; req . session . username = username ; res . redirect ( next ) ; } else { res . emsg = 'Invalid Username or Password' ; render ( req , res , 'login.jade' , { next : next } ) ; } } ) ; }
2762	function two ( context , next ) { setTimeout ( function ( ) { context . two = 'Hello' ; console . log ( 'Hello from two' , context ) ; return next ( ) ; } , 1000 ) ; }
2834	function ( nextSchema , nextScope , nextIndex , nextPath , nextCBack ) { var nSchema = nextSchema || false ; var nScope = nextScope ; var nIndex = nextIndex ; var nPath = nextPath ; var nCBack = nextCBack || function ( ) { } ; if ( false === nSchema ) { return function ( ) { } ; } else { return function ( ) { baseimporter . indexIDs . call ( baseimporter , nSchema , nScope , nIndex , nPath , nCBack ) ; } ; } }
361	function type ( rule , value , source , errors , options ) { if ( rule . required && value === undefined ) { required ( rule , value , source , errors , options ) ; return ; } const custom = [ 'integer' , 'float' , 'array' , 'regexp' , 'object' , 'method' , 'email' , 'number' , 'date' , 'url' , 'hex' ] ; const ruleType = rule . type ; if ( custom . indexOf ( ruleType ) > - 1 ) { if ( ! types [ ruleType ] ( value ) ) { errors . push ( util . format ( options . messages . types [ ruleType ] , rule . fullField , rule . type ) ) ; } } else if ( ruleType && typeof ( value ) !== rule . type ) { errors . push ( util . format ( options . messages . types [ ruleType ] , rule . fullField , rule . type ) ) ; } }
1711	function _getViewSpec ( item , view , id , callback ) { if ( ! item . view ) { return ; } var spec = view . getSpec ( id ) ; if ( spec && ! spec . trueSizeRequested ) { callback ( spec ) ; } else { Timer . after ( _getViewSpec . bind ( this , item , view , id , callback ) , 1 ) ; } }
3863	function insertBefore ( parent , child , index ) { var parentEl = parent . el , childEl = child . el ; if ( parentEl !== undefined && childEl !== undefined ) { if ( parentEl . childNodes [ index ] !== undefined ) { parentEl . insertBefore ( childEl , parentEl . childNodes [ index ] ) ; } else { parentEl . appendChild ( childEl ) ; } } }
48	function _isRepeatData ( current ) { var last = this . _lastData ; if ( ! last || current . message !== last . message || current . transaction !== last . transaction ) return false ; if ( current . stacktrace || last . stacktrace ) { return isSameStacktrace$1 ( current . stacktrace , last . stacktrace ) ; } else if ( current . exception || last . exception ) { return isSameException$1 ( current . exception , last . exception ) ; } return true ; }
1884	function ( editor ) { var syntax = editor . getSyntax ( ) ; var profile = require ( 'resources' ) . findItem ( syntax , 'profile' ) ; if ( profile ) { return profile ; } switch ( syntax ) { case 'xml' : case 'xsl' : return 'xml' ; case 'css' : if ( this . isInlineCSS ( editor ) ) { return 'line' ; } break ; case 'html' : var profile = require ( 'resources' ) . getVariable ( 'profile' ) ; if ( ! profile ) { profile = this . isXHTML ( editor ) ? 'xhtml' : 'html' ; } return profile ; } return 'xhtml' ; }
1488	async function ( filename ) { if ( ! await fs . existsAsync ( filename ) ) { return null ; } var data = await fs . readFileAsync ( filename , "utf8" ) ; try { return qx . tool . compiler . utils . Json . parseJson ( data ) ; } catch ( ex ) { throw new Error ( "Failed to load " + filename + ": " + ex ) ; } }
1397	function raw ( incomingData , logger , opConfig , metadata , slice ) { const data = _toRecords ( incomingData , opConfig . line_delimiter , slice ) ; return data . map ( ( record ) => { try { return DataEntity . make ( { data : record } , metadata ) ; } catch ( err ) { if ( opConfig . _dead_letter_action === 'log' ) { logger . error ( err , 'Bad record:' , record ) ; } else if ( opConfig . _dead_letter_action === 'throw' ) { throw err ; } return null ; } } ) ; }
1570	function findAllFiles ( baseDir , { ignoredFolders = [ ] , maxDepth = undefined } = { } ) { let list = [ ] function search ( dir , depth ) { fs . readdirSync ( dir ) . forEach ( file => { file = path . join ( dir , file ) let stat = fs . statSync ( file ) if ( stat . isFile ( ) ) { list . push ( file ) } else if ( stat . isDirectory ( ) ) { if ( ignoredFolders . includes ( path . basename ( file ) ) ) { return } if ( maxDepth && ( depth >= maxDepth ) ) { return } search ( file , depth + 1 ) } } ) } search ( baseDir , 0 ) return list }
519	function _recordKey ( key ) { var i ; for ( i = 0 ; i < _currentRecordedKeys . length ; ++ i ) { if ( _currentRecordedKeys [ i ] === key ) { return ; } } _currentRecordedKeys . push ( key ) ; if ( key . length === 1 ) { _recordedCharacterKey = true ; } }
2238	function checkError ( resp ) { var value = this . config . successValue ; if ( typeof value === 'number' ) { return resp . httpResponse . statusCode === value ; } else { return resp . error && resp . error . code === value ; } }
1466	function ( id ) { var t = this ; var entry = t . __translations [ id ] ; if ( ! entry ) { entry = t . __translations [ id ] = { msgid : id } ; } return entry ; }
927	function showEventNameLog ( name , newName , eventModifiers , attrs , tplOpts ) { let { logger , file , appType } = tplOpts ; NOT_SUPPORT_MODIFIERS . forEach ( item => { if ( eventModifiers . includes ( item ) ) { logger . warn ( ` ${ file . path } ${ name } ` , ` ${ item } ${ appType } ` ) ; } } ) ; if ( attrs . hasOwnProperty ( newName ) ) { logger . warn ( ` ${ file . path } ${ name } ${ newName } ` ) ; } }
1507	function inTree ( root , oid ) { var i ; if ( oid . length <= root . length ) { return false ; } for ( i = 0 ; i < root . length ; i ++ ) { if ( oid [ i ] !== root [ i ] ) { return false ; } } return true ; }
2135	function ( ) { if ( ( cachedWidth = element . offsetWidth ) != lastWidth || ( cachedHeight = element . offsetHeight ) != lastHeight ) { dirty = true ; lastWidth = cachedWidth ; lastHeight = cachedHeight ; } reset ( ) ; }
2043	function ( apporplugin ) { if ( config . plugins [ apporplugin ] !== undefined ) { config . plugins [ apporplugin ] . disabled = undefined ; configHelpers . saveConfig ( ) ; } else if ( config . apps [ apporplugin ] !== undefined ) { config . apps [ apporplugin ] . disabled = undefined ; configHelpers . saveConfig ( ) ; } else { throw new Error ( 'Cannot enable, given app or plugin ' + apporplugin + ' is not configured.' ) ; } }
1954	function getMissingProps ( data ) { var containsKey = _ . partial ( _ . contains , _ . keys ( data ) ) ; return _ . filter ( required , function ( req ) { return ! containsKey ( req ) ; } ) ; }
413	function parseNode ( str , parseList , currentIndex , fileInfo , callback ) { var result , returnNodes = [ ] ; var parser = parserInput ; try { parser . start ( str , false , function fail ( msg , index ) { callback ( { message : msg , index : index + currentIndex } ) ; } ) ; for ( var x = 0 , p , i ; ( p = parseList [ x ] ) ; x ++ ) { i = parser . i ; result = parsers [ p ] ( ) ; if ( result ) { result . _index = i + currentIndex ; result . _fileInfo = fileInfo ; returnNodes . push ( result ) ; } else { returnNodes . push ( null ) ; } } var endInfo = parser . end ( ) ; if ( endInfo . isFinished ) { callback ( null , returnNodes ) ; } else { callback ( true , null ) ; } } catch ( e ) { throw new LessError ( { index : e . index + currentIndex , message : e . message } , imports , fileInfo . filename ) ; } }
3637	function ( ) { var curCtx = router . current ( ) , prevCtx = router . previous ( ) ; var content = curCtx . route . render ( curCtx ) ; if ( content === undefined || content === null ) { return ; } if ( langx . isString ( content ) ) { this . _rvc . innerHTML = content ; } else { this . _rvc . innerHTML = "" ; this . _rvc . appendChild ( content ) ; } curCtx . route . trigger ( createEvent ( "rendered" , { route : curCtx . route , content : content } ) ) ; }
1420	function readDb ( cb ) { fs . exists ( t . getDbFilename ( ) , function ( exists ) { if ( exists ) { fs . readFile ( t . getDbFilename ( ) , { encoding : "utf-8" } , cb ) ; } else { cb ( null , null ) ; } } ) ; }
1988	function ( ) { if ( document . activeElement && document . activeElement . tagName === "IFRAME" ) { $ . iframeTracker . focusRetriever . focus ( ) ; $ . iframeTracker . focusRetrieved = true ; } }
906	function addDisplayPageConfig ( pages , sourceDir , configFile ) { let path = relative ( configFile . fullPath , sourceDir ) ; let { pageName } = getPageInfo ( path ) ; let currPageDisplayInfo = pages [ pageName ] ; let pageConfig = JSON . parse ( configFile . content ) ; let result = { } ; Object . keys ( pageConfig ) . forEach ( k => { let newKey = DISPLAY_PAGE_CONFIG_MAP [ k ] ; if ( newKey ) { result [ newKey ] = pageConfig [ k ] ; } } ) ; pages [ pageName ] = Object . assign ( { } , currPageDisplayInfo , result ) ; }
1877	function ( fn ) { this . _list = _ . without ( this . _list , _ . find ( this . _list , function ( item ) { return item . fn === fn ; } ) ) ; }
2226	function load ( dotGraph , appendTo ) { var dotAST = parseDot ( dotGraph ) ; if ( dotAST . length > 1 && appendTo !== undefined ) { throw new Error ( 'Dot file contains multiple graphs. Cannot use `saveTo` in this case' ) ; } if ( ! appendTo ) { appendTo = require ( 'ngraph.graph' ) ( ) ; } return loadOne ( appendTo , dotAST [ 0 ] ) ; }
2539	function isString ( value ) { return typeof value == 'string' || ( ! isArray$3 ( value ) && isObjectLike$4 ( value ) && objectToString$4 . call ( value ) == stringTag ) ; }
502	function getDataSlice ( data , offset , length ) { let len = new BN ( data . length ) if ( offset . gt ( len ) ) { offset = len } let end = offset . add ( length ) if ( end . gt ( len ) ) { end = len } data = data . slice ( offset . toNumber ( ) , end . toNumber ( ) ) data = utils . setLengthRight ( data , length . toNumber ( ) ) return data }
2765	function two ( context , next ) { context . two = 'Hello' ; console . log ( 'Hello from two' , context ) ; console . log ( 'Hi from two' , context ) ; return next ( ) ; }
259	function ( fetchOptions ) { let namespace = getNamespace ( fetchOptions ) , siteId = fetchOptions . siteId , users = [ ] ; debug ( 'getUsers:' , namespace ) ; if ( ! _usersBySite [ siteId ] ) { _usersBySite [ siteId ] = { } ; } if ( ! _userIDsByNamespace [ namespace ] ) { return users ; } _userIDsByNamespace [ namespace ] . forEach ( userId => { if ( _usersBySite [ siteId ] [ userId ] ) { users . push ( _usersBySite [ siteId ] [ userId ] ) ; } } ) ; return users ; }
2320	function Currencies ( currencies ) { if ( ! currencies ) { throw new Error ( 'Missing currencies object' ) ; } this . keys = parseInt ( currencies . keys || 0 ) ; this . metal = parseFloat ( currencies . metal || 0 ) ; if ( isNaN ( this . keys ) || isNaN ( this . metal ) ) { throw new Error ( 'Not a valid currencies object' ) ; } this . metal = toRefined ( toScrap ( this . metal ) ) ; }
2222	function getFrameworkOrEggPath ( cwd , eggNames ) { eggNames = eggNames || [ 'egg' ] ; const moduleDir = path . join ( cwd , 'node_modules' ) ; if ( ! fs . existsSync ( moduleDir ) ) { return '' ; } const pkgFile = path . join ( cwd , 'package.json' ) ; if ( fs . existsSync ( pkgFile ) ) { const pkg = utility . readJSONSync ( pkgFile ) ; if ( pkg . egg && pkg . egg . framework ) { return path . join ( moduleDir , pkg . egg . framework ) ; } } const names = fs . readdirSync ( moduleDir ) ; for ( const name of names ) { const pkgfile = path . join ( moduleDir , name , 'package.json' ) ; if ( ! fs . existsSync ( pkgfile ) ) { continue ; } const pkg = utility . readJSONSync ( pkgfile ) ; if ( pkg . dependencies ) { for ( const eggName of eggNames ) { if ( pkg . dependencies [ eggName ] ) { return path . join ( moduleDir , name ) ; } } } } for ( const eggName of eggNames ) { const pkgfile = path . join ( moduleDir , eggName , 'package.json' ) ; if ( fs . existsSync ( pkgfile ) ) { return path . join ( moduleDir , eggName ) ; } } return '' ; }
2278	function ( options , code ) { var rst = JSON . parse ( JSON . stringify ( options ) ) ; if ( rst . sourceMaps ) { if ( code ) { rst . sourceFileName = processSourceFileName ( rst . sourceFileName , code ) ; } if ( rst . sourceMaps === "inline" || rst . sourceMaps === "both" ) { rst . sourceMaps = true ; } } return rst ; }
1745	function addPoints ( sourceName , n_points = 10 ) { for ( let i = 0 ; i < n_points ; i ++ ) { store . dispatch ( mapActions . addFeatures ( sourceName , [ { type : 'Feature' , properties : { id : ` ${ i } ` , title : 'Random Point' , } , geometry : { type : 'Point' , coordinates : [ ( Math . random ( ) * 360 ) - 180 , ( Math . random ( ) * 180 ) - 90 ] , } , } ] ) ) ; } }
947	function createNode ( value , t ) { if ( t . isIdentifier ( value ) ) { return value ; } if ( Array . isArray ( value ) ) { let elements = [ ] ; value . forEach ( item => { let node = createNode ( item , t ) ; node && elements . push ( node ) ; } ) ; return t . arrayExpression ( elements ) ; } if ( Object . prototype . toString . call ( value ) === '[object Object]' ) { let props = [ ] ; Object . keys ( value ) . forEach ( k => { let node = createNode ( value [ k ] , t ) ; if ( node ) { props . push ( t . objectProperty ( t . identifier ( ` ${ k } ` ) , node ) ) ; } } ) ; return t . objectExpression ( props ) ; } if ( value == null ) { return t . nullLiteral ( ) ; } let valueType = typeof value ; switch ( valueType ) { case 'boolean' : return t . booleanLiteral ( value ) ; case 'string' : return t . stringLiteral ( value ) ; case 'number' : return t . numericLiteral ( value ) ; } }
1818	function S3Receiver ( s3ClientOpts ) { s3ClientOpts = s3ClientOpts || { } ; s3ClientOpts = _ . extend ( { } , globalOpts , s3ClientOpts ) ; var wasMaxBytesPerUpstreamQuotaExceeded ; var wasMaxBytesPerFileQuotaExceeded ; var maxBytesPerUpstream = s3ClientOpts . maxBytes || undefined ; var maxBytesPerFile = s3ClientOpts . maxBytesPerFile || undefined ; var receiver = Writable ( { objectMode : true } ) ; receiver . once ( 'error' , ( unusedErr ) => { } ) ; var bytesWrittenByFd = { } ; receiver . _write = ( incomingFileStream , encoding , proceed ) => { if ( ! _ . isString ( incomingFileStream . skipperFd ) || incomingFileStream . skipperFd === '' ) { if ( ! _ . isString ( incomingFileStream . fd ) || incomingFileStream . fd === '' ) { return proceed ( new Error ( 'In skipper-s3: Incoming file stream does not have the expected `.skipperFd` or `.fd` properties-- at least not as a valid string. If you are using sails-hook-uploads or skipper directly, this should have been automatically attached! Here is what we got for `.fd` (legacy property): `' + incomingFileStream . fd + '`. And here is what we got for `.skipperFd` (new property): `' + incomingFileStream . skipperFd + '`' ) ) ; } else { incomingFileStream . skipperFd = incomingFileStream . fd ; } } var incomingFd = incomingFileStream . skipperFd ; bytesWrittenByFd [ incomingFd ] = 0 ; incomingFileStream . once ( 'error' , ( unusedErr ) => { } ) ; _uploadFile ( incomingFd , incomingFileStream , ( progressInfo ) => { bytesWrittenByFd [ incomingFd ] = progressInfo . written ; incomingFileStream . byteCount = progressInfo . written ; let totalBytesWrittenForThisUpstream = 0 ; for ( let fd in bytesWrittenByFd ) { totalBytesWrittenForThisUpstream += bytesWrittenByFd [ fd ] ; } if ( maxBytesPerUpstream && totalBytesWrittenForThisUpstream > maxBytesPerUpstream ) { wasMaxBytesPerUpstreamQuotaExceeded = true ; return false ; } else if ( maxBytesPerFile && bytesWrittenByFd [ incomingFd ] > maxBytesPerFile ) { wasMaxBytesPerFileQuotaExceeded = true ; return false ; } else { if ( s3ClientOpts . onProgress ) { s3ClientOpts . onProgress ( progressInfo ) ; } else { receiver . emit ( 'progress' , progressInfo ) ; } return true ; } } , s3ClientOpts , ( err ) => { if ( err ) { if ( flaverr . taste ( { name : 'RequestAbortedError' } , err ) ) { if ( maxBytesPerUpstream && wasMaxBytesPerUpstreamQuotaExceeded ) { err = flaverr ( { code : 'E_EXCEEDS_UPLOAD_LIMIT' } , new Error ( ` ${ maxBytesPerUpstream } ` ) ) ; } else if ( maxBytesPerFile && wasMaxBytesPerFileQuotaExceeded ) { err = flaverr ( { code : 'E_EXCEEDS_FILE_SIZE_LIMIT' } , new Error ( ` ${ maxBytesPerFile } ` ) ) ; } } receiver . emit ( 'error' , err ) ; } else { incomingFileStream . byteCount = bytesWrittenByFd [ incomingFd ] ; receiver . emit ( 'writefile' , incomingFileStream ) ; return proceed ( ) ; } } ) ; } ; return receiver ; }
3542	function ( ) { var requiredRules = [ 'required' , 'requiredIf' , 'requiredUnless' , 'requiredWith' , 'requiredWithAll' , 'requiredWithout' , 'requiredWithoutAll' ] ; var requiredRulesFound = [ ] ; requiredRules . forEach ( function ( rule ) { if ( 'undefined' !== typeof this . constraintsByName [ rule ] ) { requiredRulesFound . push ( rule ) ; } } , this ) ; if ( requiredRulesFound . length == 0 ) return false ; if ( requiredRulesFound . indexOf ( 'required' ) >= 0 ) { return false !== this . constraintsByName . required . requirements ; } return true ; }
175	function parseAsElement ( node , _parsed ) { const element = createElementFromString ( node ) ; if ( element instanceof window . Element ) { return _recurse ( element , _parsed ) ; } return _parsed ; }
248	function processLibPhoneNumberMetadata ( libPhoneNumberData ) { const data = { } ; for ( let countryCode in libPhoneNumberData ) { if ( libPhoneNumberData . hasOwnProperty ( countryCode ) ) { const countryCodeUpper = countryCode . toUpperCase ( ) ; const country = libPhoneNumberData [ countryCode ] ; data [ countryCodeUpper ] = { isoCode : countryCodeUpper , dialCode : String ( country [ libPhoneNumberIndexes . COUNTRY_DIAL_CODE ] + ( country [ libPhoneNumberIndexes . REGION_AREA_CODE ] || '' ) ) , countryDialCode : String ( country [ libPhoneNumberIndexes . COUNTRY_DIAL_CODE ] ) , regionCode : country [ libPhoneNumberIndexes . REGION_AREA_CODE ] || '' , areaCodes : areaCodes [ countryCode ] , nationalPrefix : country [ libPhoneNumberIndexes . NATIONAL_PREFIX ] , patterns : ( country [ libPhoneNumberIndexes . NUMBER_FORMAT ] || [ ] ) . map ( processNumberFormat ) , internationalPatterns : ( country [ libPhoneNumberIndexes . INTERNATIONAL_NUMBER_FORMAT ] || [ ] ) . map ( processNumberFormat ) , priority : priorityData [ countryCodeUpper ] , } ; } } const noPattern = _ . filter ( data , _ . conforms ( { patterns : patterns => patterns . length === 0 } ) ) ; _ . forIn ( noPattern , function ( country ) { country . patternRegion = ( _ . maxBy ( _ . values ( _ . filter ( data , { dialCode : country . dialCode } ) ) , 'priority' ) || { } ) . isoCode ; console . log ( 'Info: ' + country . isoCode + " didn't have a pattern" + ( country . patternRegion ? ' so we use ' + country . patternRegion : '.' ) ) ; } ) ; return data ; }
2891	function validSubAttrCriteria ( c ) { return _ . isObject ( c ) && ( ! _ . isUndefined ( c . not ) || ! _ . isUndefined ( c . greaterThan ) || ! _ . isUndefined ( c . lessThan ) || ! _ . isUndefined ( c . greaterThanOrEqual ) || ! _ . isUndefined ( c . lessThanOrEqual ) || ! _ . isUndefined ( c [ '<' ] ) || ! _ . isUndefined ( c [ '<=' ] ) || ! _ . isUndefined ( c [ '!' ] ) || ! _ . isUndefined ( c [ '>' ] ) || ! _ . isUndefined ( c [ '>=' ] ) || ! _ . isUndefined ( c . startsWith ) || ! _ . isUndefined ( c . endsWith ) || ! _ . isUndefined ( c . contains ) || ! _ . isUndefined ( c . like ) ) ; }
3093	function getDirectories ( dir , cb ) { fs . readdir ( dir , function ( err , objects ) { if ( err ) { return cb && cb ( err ) ; } var dirs = objects . filter ( function ( item ) { return fs . statSync ( path . join ( dir , item ) ) . isDirectory ( ) ; } ) ; cb && cb ( null , dirs ) } ) }
1369	async function optimize ( file ) { check ( file ) ; const name = getName ( file ) ; log ( 'reading file ' + path . basename ( name ) ) ; const data = await readFile ( name , 'utf8' ) ; return onDataRead ( file , data ) ; }
2395	function convert ( report ) { return [ ] . concat ( Parsers . parse ( 'headers' , report ) , Parsers . parse ( 'reason' , report ) , Parsers . parse ( 'threads' , report ) , Parsers . parse ( 'cpu' , report ) , Parsers . parse ( 'images' , report ) , Parsers . parse ( 'extras' , report ) ) . join ( '\n' ) }
742	function ( opts ) { if ( ! opts ) { throw new Error . StripeError ( { message : 'Options are required' , } ) ; } opts . timestamp = Math . floor ( opts . timestamp ) || Math . floor ( Date . now ( ) / 1000 ) ; opts . scheme = opts . scheme || signature . EXPECTED_SCHEME ; opts . signature = opts . signature || signature . _computeSignature ( opts . timestamp + '.' + opts . payload , opts . secret ) ; var generatedHeader = [ 't=' + opts . timestamp , opts . scheme + '=' + opts . signature , ] . join ( ',' ) ; return generatedHeader ; }
850	function getExportsNodes ( scope ) { const variable = scope . set . get ( "exports" ) if ( variable == null ) { return [ ] } return variable . references . map ( reference => reference . identifier ) }
3164	function consume_doctype_or_comment ( proc_stack ) { let html = "<!" ; proc_stack . tSkip ( 2 ) ; html += proc_stack . tAcceptUntil ( ">" ) + proc_stack . tAccept ( ) ; return html ; }
473	function isPosterityNode ( parent , child ) { if ( ! isNode$2 ( parent ) || ! isNode$2 ( child ) ) { return false ; } while ( child . parentNode ) { child = child . parentNode ; if ( child === parent ) { return true ; } } return false ; }
437	function getDomainFromData ( props , axis , dataset ) { dataset = dataset || Data . getData ( props ) ; const { polar , startAngle = 0 , endAngle = 360 } = props ; const minDomain = getMinFromProps ( props , axis ) ; const maxDomain = getMaxFromProps ( props , axis ) ; if ( dataset . length < 1 ) { return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax ( minDomain , maxDomain ) : undefined ; } const min = minDomain !== undefined ? minDomain : getExtremeFromData ( dataset , axis , "min" ) ; const max = maxDomain !== undefined ? maxDomain : getExtremeFromData ( dataset , axis , "max" ) ; const domain = getDomainFromMinMax ( min , max ) ; return polar && axis === "x" && Math . abs ( startAngle - endAngle ) === 360 ? getSymmetricDomain ( domain , getFlatData ( dataset , axis ) ) : domain ; }
3733	function findLast ( data , items , index ) { var currentIndex = - 1 , found = '' ; for ( var i = 0 ; i < items . length ; i ++ ) { var item = items [ i ] ; var location = data . lastIndexOf ( item , index ) ; if ( location > currentIndex ) { currentIndex = location ; found = item ; } } return { index : currentIndex , found : found } ; }
1313	function TaskControlBlock ( link , id , priority , queue , task ) { this . link = link ; this . id = id ; this . priority = priority ; this . queue = queue ; this . task = task ; if ( queue == null ) { this . state = STATE_SUSPENDED ; } else { this . state = STATE_SUSPENDED_RUNNABLE ; } }
347	function nextNonWhiteSpace ( ) { var iNext = i + 1 ; while ( iNext < jsString . length && isWhiteSpace ( jsString [ iNext ] ) ) { iNext ++ ; } return jsString [ iNext ] ; }
3357	function ( record ) { var me = this ; me . setValue ( record . getId ( ) ) ; me . picker . hide ( ) ; me . inputEl . focus ( ) ; me . fireEvent ( 'select' , me , record ) }
3452	function ( dir ) { var cmd = path . normalize ( config . bin ) ; if ( config . jdependChart !== undefined ) { cmd += ' --jdepend-chart=' + config . jdependChart ; } if ( config . jdependXml !== undefined ) { cmd += ' --jdepend-xml=' + config . jdependXml ; } if ( config . overviewPyramid !== undefined ) { cmd += ' --overview-pyramid=' + config . overviewPyramid ; } if ( config . summaryXml !== undefined ) { cmd += ' --summary-xml=' + config . summaryXml ; } if ( config . coderankMode !== undefined ) { cmd += ' --coderank-mode=' + config . coderankMode ; } if ( config . coverageReport !== undefined ) { cmd += ' --coverage-report=' + config . coverageReport ; } if ( config . configuration !== undefined ) { cmd += ' --configuration=' + config . configuration ; } if ( config . ignoreDirectories !== undefined ) { cmd += ' --ignore=' + config . ignoreDirectories ; } if ( config . debug ) { cmd += ' --debug ' ; } return cmd ; }
1277	function supportedLocalesOf ( service , locales , options ) { if ( IS_NULL ( InternalRegExpMatch ( GetServiceRE ( ) , service ) ) ) { throw MakeError ( kWrongServiceType , service ) ; } if ( IS_UNDEFINED ( options ) ) { options = { } ; } else { options = TO_OBJECT ( options ) ; } var matcher = options . localeMatcher ; if ( ! IS_UNDEFINED ( matcher ) ) { matcher = TO_STRING ( matcher ) ; if ( matcher !== 'lookup' && matcher !== 'best fit' ) { throw MakeRangeError ( kLocaleMatcher , matcher ) ; } } else { matcher = 'best fit' ; } var requestedLocales = initializeLocaleList ( locales ) ; if ( IS_UNDEFINED ( AVAILABLE_LOCALES [ service ] ) ) { AVAILABLE_LOCALES [ service ] = getAvailableLocalesOf ( service ) ; } if ( matcher === 'best fit' ) { return initializeLocaleList ( bestFitSupportedLocalesOf ( requestedLocales , AVAILABLE_LOCALES [ service ] ) ) ; } return initializeLocaleList ( lookupSupportedLocalesOf ( requestedLocales , AVAILABLE_LOCALES [ service ] ) ) ; }
3533	function catchAndMatch ( fn , matcher , cb ) { return isIllegalArguments ( { fn : fn , matcher : matcher , cb : cb } ) . then ( fn , function ( err ) { throw err ; } ) . then ( function ( ) { var error = new Error ( 'No error thrown' ) ; if ( cb ) cb ( error ) ; return Promise . reject ( error ) ; } , function ( err ) { if ( doesMatch ( { matcher : matcher , err : err } ) ) { if ( cb ) cb ( ) ; return Promise . resolve ( ) ; } var error = new Error ( 'Error does not satisfy matcher' ) ; if ( cb ) cb ( error ) ; return Promise . reject ( error ) ; } ) ; }
2780	function parsePropertyValue ( node ) { var $node = $ ( node ) ; if ( $node . is ( 'meta' ) ) { return resolveAttribute ( $node , 'content' ) ; } else if ( $node . is ( 'audio,embed,iframe,img,source,track,video' ) ) { return resolveUrlAttribute ( $node , 'src' ) ; } else if ( $node . is ( 'a,area,link' ) ) { return resolveUrlAttribute ( $node , 'href' ) ; } else if ( $node . is ( 'object' ) ) { return resolveUrlAttribute ( $node , 'data' ) ; } else if ( $node . is ( 'data,meter' ) ) { return resolveAttribute ( $node , 'value' ) ; } else if ( $node . is ( 'time' ) ) { return resolveAttribute ( $node , 'datetime' ) ; } else { var text = $node . text ( ) ; return text || '' ; } }
3070	function ( ) { var doc = me . getDoc ( ) ; if ( doc . body || doc . readyState === 'complete' ) { Ext . TaskManager . stop ( task ) ; me . setDesignMode ( true ) ; Ext . defer ( me . initEditor , 10 , me ) ; } }
753	function ( event , g ) { var chartPos = utils . findPos ( g . canvas_ ) ; var box = { left : chartPos . x , right : chartPos . x + g . canvas_ . offsetWidth , top : chartPos . y , bottom : chartPos . y + g . canvas_ . offsetHeight } ; var pt = { x : utils . pageX ( event ) , y : utils . pageY ( event ) } ; var dx = distanceFromInterval ( pt . x , box . left , box . right ) , dy = distanceFromInterval ( pt . y , box . top , box . bottom ) ; return Math . max ( dx , dy ) ; }
811	function wrapLogger ( getLoggerForConfig , opts ) { var mainLogger = getLoggerForConfig ( 'main' , opts ) , timeLogger = getLoggerForConfig ( 'time' , opts ) , gaugeLogger = getLoggerForConfig ( 'gauge' , opts ) , classifyTime = makeTimeClassifier ( opts ) , classifyGauge = makeGaugeClassifier ( opts ) mainLogger . time = ( token , ms , opts ) => timeLogger [ classifyTime ( ms , opts ) ] ( token , { ms } ) ; mainLogger . gauge = ( token , val , opts ) => gaugeLogger [ classifyGauge ( val , opts ) ] ( token , { val } ) ; mainLogger . timeLogger = timeLogger ; mainLogger . gaugeLogger = gaugeLogger ; mainLogger . timer = ( token , opts ) => { var t0 = new Date , tt = t0 , nt = 0 , ct = 0 return { stop : ( ) => ( mainLogger . time ( token , ct = new Date - t0 , opts ) , ct ) , tick : ( name ) => { var now = new Date name || ( name = ` ${ nt ++ } ` ) ; mainLogger . time ( ` ${ token } ${ name } ` , ct = now - tt , opts ) ; tt = now ; return ct } , } ; } return mainLogger ; }
3429	function ( array , item ) { var index = ExtArray . indexOf ( array , item ) ; if ( index !== - 1 ) { erase ( array , index , 1 ) ; } return array ; }
1614	function send_files ( session , files , options ) { if ( ! options ) options = { } ; var batch = [ ] ; var total_size = 0 ; for ( var f = files . length - 1 ; f >= 0 ; f -- ) { var fobj = files [ f ] ; total_size += fobj . size ; batch [ f ] = { obj : fobj , name : fobj . name , size : fobj . size , mtime : new Date ( fobj . lastModified ) , files_remaining : files . length - f , bytes_remaining : total_size , } ; } var file_idx = 0 ; function promise_callback ( ) { var cur_b = batch [ file_idx ] ; if ( ! cur_b ) { return Promise . resolve ( ) ; } file_idx ++ ; return session . send_offer ( cur_b ) . then ( function after_send_offer ( xfer ) { if ( options . on_offer_response ) { options . on_offer_response ( cur_b . obj , xfer ) ; } if ( xfer === undefined ) { return promise_callback ( ) ; } return new Promise ( function ( res ) { var reader = new FileReader ( ) ; reader . onerror = function reader_onerror ( e ) { console . error ( "file read error" , e ) ; throw ( "File read error: " + e ) ; } ; var piece ; reader . onprogress = function reader_onprogress ( e ) { if ( e . target . result ) { piece = new Uint8Array ( e . target . result , xfer . get_offset ( ) ) _check_aborted ( session ) ; xfer . send ( piece ) ; if ( options . on_progress ) { options . on_progress ( cur_b . obj , xfer , piece ) ; } } } ; reader . onload = function reader_onload ( e ) { piece = new Uint8Array ( e . target . result , xfer , piece ) _check_aborted ( session ) ; xfer . end ( piece ) . then ( function ( ) { if ( options . on_progress && piece . length ) { options . on_progress ( cur_b . obj , xfer , piece ) ; } if ( options . on_file_complete ) { options . on_file_complete ( cur_b . obj , xfer ) ; } res ( promise_callback ( ) ) ; } ) ; } ; reader . readAsArrayBuffer ( cur_b . obj ) ; } ) ; } ) ; } return promise_callback ( ) ; }
1446	function ( name , valueName ) { if ( this . __scope . vars [ name ] === undefined ) { this . __scope . vars [ name ] = valueName || true ; var unresolved = this . __scope . unresolved ; delete unresolved [ name ] ; var re = new RegExp ( name + "\\." ) ; \\ } }
1913	function ( editor ) { var range = require ( 'range' ) . create ( editor . getSelectionRange ( ) ) ; var content = String ( editor . getContent ( ) ) ; if ( range . length ( ) ) { return range . substring ( content ) ; } var curLine = editor . getCurrentLineRange ( ) ; return require ( 'actionUtils' ) . extractAbbreviation ( content . substring ( curLine . start , range . start ) ) ; }
1064	function ( data ) { if ( this . app ) { data . _app = this . app ; } if ( this . model ) { data . _model = this . model ; } if ( this . collection ) { data . _collection = this . collection ; } data . _view = this ; return data ; }
719	function ( recipientPrivate , senderPublic , _payload ) { if ( ! recipientPrivate || ! senderPublic || ! _payload ) throw new Error ( 'Missing argument !' ) ; let binPayload = convert . hexToUint8 ( _payload ) ; let salt = new Uint8Array ( binPayload . buffer , 0 , 32 ) ; let iv = new Uint8Array ( binPayload . buffer , 32 , 16 ) ; let payload = new Uint8Array ( binPayload . buffer , 48 ) ; let keyPair = createKeyPairFromPrivateKeyString ( recipientPrivate ) ; let pk = convert . hexToUint8 ( senderPublic ) ; let encKey = deriveSharedKey ( keyPair , pk , salt ) ; let encIv = { iv : ua2words ( iv , 16 ) } ; let encrypted = { 'ciphertext' : ua2words ( payload , payload . length ) } ; let plain = CryptoJS . AES . decrypt ( encrypted , encKey , encIv ) ; let hexplain = CryptoJS . enc . Hex . stringify ( plain ) ; return hexplain ; }
277	function getGSuiteSupportedDomains ( domains ) { return domains . filter ( function ( domain ) { const wpcomHosted = includes ( [ domainTypes . REGISTERED ] , domain . type ) && ( domain . hasWpcomNameservers || hasGSuite ( domain ) ) ; const mapped = includes ( [ domainTypes . MAPPED ] , domain . type ) ; const notOtherProvidor = domain . googleAppsSubscription && domain . googleAppsSubscription . status !== 'other_provider' ; return ( wpcomHosted || mapped ) && canDomainAddGSuite ( domain . name ) && notOtherProvidor ; } ) ; }
3604	function LineCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 4 ) throw new SyntaxError ( 'LINE command requires 4 arguments' ) ; this . x1 = parsed . args [ 0 ] ; this . y1 = parsed . args [ 1 ] ; this . x2 = parsed . args [ 2 ] ; this . y2 = parsed . args [ 3 ] ; this . width = parsed . args . length > 4 ? parsed . args [ 4 ] : false ; }
79	function getIconUrl ( ) { var url = new URL ( this . config . iconUrl , window . location ) ; var cors = url . host !== window . location . host || browser . isIE && ! window . svg4everybody ; return { url : this . config . iconUrl , cors : cors } ; }
3	function getHighlightOptions ( config , arg ) { let lang = '' ; if ( rLang . test ( arg ) ) { arg = arg . replace ( rLang , ( match , _lang ) => { lang = _lang ; return '' ; } ) ; } let line_number = config . line_number ; if ( rLineNumber . test ( arg ) ) { arg = arg . replace ( rLineNumber , ( match , _line_number ) => { line_number = _line_number === 'true' ; return '' ; } ) ; } let first_line = 1 ; if ( rFirstLine . test ( arg ) ) { arg = arg . replace ( rFirstLine , ( match , _first_line ) => { first_line = _first_line ; return '' ; } ) ; } let mark = [ ] ; if ( rMark . test ( arg ) ) { arg = arg . replace ( rMark , ( match , _mark ) => { mark = _mark . split ( ',' ) . reduce ( function getMarkedLines ( prev , cur ) { if ( / - / . test ( cur ) ) { let a = Number ( cur . substr ( 0 , cur . indexOf ( '-' ) ) ) ; let b = Number ( cur . substr ( cur . indexOf ( '-' ) + 1 ) ) ; if ( b < a ) { const temp = a ; a = b ; b = temp ; } for ( ; a <= b ; a ++ ) { prev . push ( a ) ; } return prev ; } prev . push ( Number ( cur ) ) ; return prev ; } , [ ] ) ; return '' ; } ) ; } let caption = '' ; if ( rCaptionUrlTitle . test ( arg ) ) { const match = arg . match ( rCaptionUrlTitle ) ; caption = ` ${ match [ 1 ] } ${ match [ 2 ] } ${ match [ 3 ] } ${ match [ 4 ] } ` ; } else if ( rCaptionUrl . test ( arg ) ) { const match = arg . match ( rCaptionUrl ) ; caption = ` ${ match [ 1 ] } ${ match [ 2 ] } ${ match [ 3 ] } ` ; } else if ( rCaption . test ( arg ) ) { const match = arg . match ( rCaption ) ; caption = ` ${ match [ 1 ] } ` ; } return { lang , firstLine : first_line , caption , gutter : line_number , hljs : config . hljs , mark , tab : config . tab_replace , autoDetect : config . auto_detect } ; }
777	function emitObject ( ) { var body = bodec . join ( parts ) ; if ( body . length !== length ) { throw new Error ( "Body length mismatch" ) ; } var item = { type : numToType [ type ] , size : length , body : body , offset : start } ; if ( ref ) item . ref = ref ; parts . length = 0 ; start = 0 ; offset = 0 ; type = 0 ; length = 0 ; ref = null ; emit ( item ) ; }
1067	function ( ) { var html = this . getInnerHtml ( ) , attributes = this . getAttributes ( ) , tagName = _ . result ( this , "tagName" ) , attrString ; attrString = _ . inject ( attributes , function ( memo , value , key ) { return memo += " " + key + "=\"" + \" + _ . escape ( value ) ; } , "\"" ) ; \" }
3605	function PointCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 2 ) throw new SyntaxError ( 'POINT command requires 2 arguments' ) ; this . x = parsed . args [ 0 ] ; this . y = parsed . args [ 1 ] ; if ( parsed . args . length > 2 ) this . size = parsed . args [ 2 ] ; else this . size = false ; }
3858	function appendLine ( type ) { var len = section . children . length if ( newBlock || ! len || section . children [ len - 1 ] . type !== type ) { section . children . push ( { type : type , line : line , size : 1 } ) } else { section . children [ len - 1 ] . size += 1 } newBlock = false }
2801	function formatDate ( payload , schema ) { _ . forEach ( schema , function ( v , k ) { if ( v !== null && v . _type === 'date' ) { if ( payload [ k ] !== null ) { payload [ k ] = new Date ( payload [ k ] ) } } } ) }
787	function clone ( obj ) { var key , copy = { } ; if ( ! obj ) { return ; } for ( key in obj ) { copy [ key ] = obj [ key ] ; } return copy ; }
650	function ( words , text ) { var matchedWords = [ ] ; forEach ( words , function ( word ) { word = stripSpaces ( word ) ; if ( ! matchWordInSentence ( word , text ) ) { return ; } matchedWords = matchedWords . concat ( getIndicesByWord ( word , text ) ) ; } ) ; return matchedWords ; }
1065	function ( ) { var attributes = { } , fetchSummary = { } , modelUtils = this . app . modelUtils , nonAttributeOptions = this . nonAttributeOptions ; if ( this . attributes ) { _ . extend ( attributes , _ . result ( this , 'attributes' ) ) ; } if ( this . id ) { attributes . id = _ . result ( this , "id" ) ; } if ( this . className ) { attributes [ 'class' ] = _ . result ( this , "className" ) ; } attributes [ 'data-view' ] = this . name ; _ . each ( this . options , function ( value , key ) { if ( ! _ . isObject ( value ) && ! _ . include ( nonAttributeOptions , key ) ) { attributes [ "data-" + key ] = value ; } } ) ; fetchSummary = BaseView . extractFetchSummary ( modelUtils , this . options ) ; if ( ! _ . isEmpty ( fetchSummary ) ) { attributes [ 'data-fetch_summary' ] = JSON . stringify ( fetchSummary ) ; } return attributes ; }
1299	function TemporaryRemoveBreakPoints ( original_script , change_log ) { var script_break_points = GetScriptBreakPoints ( original_script ) ; var break_points_update_report = [ ] ; change_log . push ( { break_points_update : break_points_update_report } ) ; var break_point_old_positions = [ ] ; for ( var i = 0 ; i < script_break_points . length ; i ++ ) { var break_point = script_break_points [ i ] ; break_point . clear ( ) ; var break_point_position = FindScriptSourcePosition ( original_script , break_point . line ( ) , break_point . column ( ) ) ; var old_position_description = { position : break_point_position , line : break_point . line ( ) , column : break_point . column ( ) } ; break_point_old_positions . push ( old_position_description ) ; } return function ( pos_translator , old_script_copy_opt ) { for ( var i = 0 ; i < script_break_points . length ; i ++ ) { var break_point = script_break_points [ i ] ; if ( old_script_copy_opt ) { var clone = break_point . cloneForOtherScript ( old_script_copy_opt ) ; clone . set ( old_script_copy_opt ) ; break_points_update_report . push ( { type : "copied_to_old" , id : break_point . number ( ) , new_id : clone . number ( ) , positions : break_point_old_positions [ i ] } ) ; } var updated_position = pos_translator . Translate ( break_point_old_positions [ i ] . position , PosTranslator . ShiftWithTopInsideChunkHandler ) ; var new_location = original_script . locationFromPosition ( updated_position , false ) ; break_point . update_positions ( new_location . line , new_location . column ) ; var new_position_description = { position : updated_position , line : new_location . line , column : new_location . column } ; break_point . set ( original_script ) ; break_points_update_report . push ( { type : "position_changed" , id : break_point . number ( ) , old_positions : break_point_old_positions [ i ] , new_positions : new_position_description } ) ; } } ; }
3165	function consume_opening_or_closing_tag ( proc_stack ) { proc_stack . tSkip ( ) ; let is_closing = proc_stack . tSkipIf ( "/" ) ; let tag_name = proc_stack . tAcceptUntilSet ( TAG_NAME_DELIMITER ) . toLocaleLowerCase ( ) ; if ( ! / ^[a-z0-9]+(-[a-z0-9]+)*(:[a-z0-9]+(-[a-z0-9]+)*)?$ / . test ( tag_name ) ) { throw new SyntaxError ( ` ${ tag_name } ` ) ; } if ( ! is_closing && / ^zc- / . test ( tag_name ) ) { return consume_directive_tag ( proc_stack , tag_name ) ; } let parts = [ ] ; let html = "<" + ( is_closing ? "/" : "" ) + tag_name ; let done = false ; while ( ! done ) { html += proc_stack . tAcceptUntilSet ( ATTR_VAL_START_OR_TAG_END_DELIMITER ) ; let c = proc_stack . tAccept ( ) ; html += c ; switch ( c ) { case "\"" : \" parts . push ( html ) ; Array . prototype . push . apply ( parts , consume_char_data_with_entity_directives ( proc_stack , false , "\"" ) ) ; \" html = proc_stack . tAccept ( ) ; break ; } } case ">" : done = true ; break ; default : throw new Error ( ` ` ) ; }
345	function ModeSwitcher ( container , modes , current , onSwitch ) { var availableModes = { code : { 'text' : translate ( 'modeCodeText' ) , 'title' : translate ( 'modeCodeTitle' ) , 'click' : function ( ) { onSwitch ( 'code' ) } } , form : { 'text' : translate ( 'modeFormText' ) , 'title' : translate ( 'modeFormTitle' ) , 'click' : function ( ) { onSwitch ( 'form' ) ; } } , text : { 'text' : translate ( 'modeTextText' ) , 'title' : translate ( 'modeTextTitle' ) , 'click' : function ( ) { onSwitch ( 'text' ) ; } } , tree : { 'text' : translate ( 'modeTreeText' ) , 'title' : translate ( 'modeTreeTitle' ) , 'click' : function ( ) { onSwitch ( 'tree' ) ; } } , view : { 'text' : translate ( 'modeViewText' ) , 'title' : translate ( 'modeViewTitle' ) , 'click' : function ( ) { onSwitch ( 'view' ) ; } } } ; var items = [ ] ; for ( var i = 0 ; i < modes . length ; i ++ ) { var mode = modes [ i ] ; var item = availableModes [ mode ] ; if ( ! item ) { throw new Error ( 'Unknown mode "' + mode + '"' ) ; } item . className = 'jsoneditor-type-modes' + ( ( current == mode ) ? ' jsoneditor-selected' : '' ) ; items . push ( item ) ; } var currentMode = availableModes [ current ] ; if ( ! currentMode ) { throw new Error ( 'Unknown mode "' + current + '"' ) ; } var currentTitle = currentMode . text ; var box = document . createElement ( 'button' ) ; box . type = 'button' ; box . className = 'jsoneditor-modes jsoneditor-separator' ; box . innerHTML = currentTitle + ' &#x25BE;' ; box . title = 'Switch editor mode' ; box . onclick = function ( ) { var menu = new ContextMenu ( items ) ; menu . show ( box , container ) ; } ; var frame = document . createElement ( 'div' ) ; frame . className = 'jsoneditor-modes' ; frame . style . position = 'relative' ; frame . appendChild ( box ) ; container . appendChild ( frame ) ; this . dom = { container : container , box : box , frame : frame } ; }
1469	async function ( filePath ) { var data = await fs . readFileAsync ( filePath , "utf8" ) ; try { let compileAst = JsonToAst . parseToAst ( data , { verbose : true } ) ; let compileJson = JsonToAst . astToObject ( compileAst ) ; return compileJson ; } catch ( e ) { throw new qx . tool . cli . Utils . UserError ( ` ${ filePath } ` + e . message ) ; } }
1140	function reduceRight ( collection , callback , accumulator , thisArg ) { var noaccum = arguments . length < 3 ; callback = baseCreateCallback ( callback , thisArg , 4 ) ; forEachRight ( collection , function ( value , index , collection ) { accumulator = noaccum ? ( noaccum = false , value ) : callback ( accumulator , value , index , collection ) ; } ) ; return accumulator ; }
420	function ( parsedName ) { var lookups , important , i = parserInput . i , inValue = ! ! parsedName , name = parsedName ; parserInput . save ( ) ; if ( name || ( parserInput . currentChar ( ) === '@' && ( name = parserInput . $re ( / ^(@[\w-]+)(\(\s*\))? / ) ) ) ) { lookups = this . mixin . ruleLookups ( ) ; if ( ! lookups && ( ( inValue && parserInput . $str ( '()' ) !== '()' ) || ( name [ 2 ] !== '()' ) ) ) { parserInput . restore ( 'Missing \'[...]\' lookup in variable call' ) ; \' } \' return ; if ( ! inValue ) { name = name [ 1 ] ; } if ( lookups && parsers . important ( ) ) { important = true ; } } var call = new tree . VariableCall ( name , i , fileInfo ) ; }
1272	function TimerEvent ( label , color , pause , thread_id ) { assert ( thread_id >= 0 && thread_id < kNumThreads , "invalid thread id" ) ; this . label = label ; this . color = color ; this . pause = pause ; this . ranges = [ ] ; this . thread_id = thread_id ; this . index = ++ num_timer_event ; }
3543	function ( headers , callback ) { var xhr = new XMLHttpRequest ( ) , url = options . url , type = options . type , async = options . async || true , dataType = options . responseType || "blob" , data = options . data || null , username = options . username || null , password = options . password || null ; xhr . addEventListener ( 'load' , function ( ) { var data = { } ; data [ options . dataType ] = xhr . response ; callback ( xhr . status , xhr . statusText , data , xhr . getAllResponseHeaders ( ) ) ; } ) ; xhr . addEventListener ( 'error' , function ( ) { var data = { } ; data [ options . dataType ] = xhr . response ; callback ( xhr . status , xhr . statusText , data , xhr . getAllResponseHeaders ( ) ) ; } ) ; xhr . open ( type , url , async , username , password ) ; for ( var i in headers ) { xhr . setRequestHeader ( i , headers [ i ] ) ; } xhr . responseType = dataType ; xhr . send ( data ) ; }
3751	function genBlockMethod ( members , name ) { var res = { name : name , description : '' , params : [ ] , returns : [ ] , deprecated : false , final : false } ; members . filter ( { kind : 'function' , name : name } ) . each ( function ( doclet ) { if ( doclet . description ) { res . description += doclet . description + '\n' ; } \n if ( ! res . access ) { res . access = doclet . access ; } if ( ! res . scope ) { res . scope = doclet . scope ; } if ( res . returns . length === 0 ) { res . returns = genMethodReturns ( doclet . returns ) ; } if ( res . params . length === 0 ) { res . params = genMethodParams ( doclet . params ) ; } if ( doclet . deprecated ) { res . deprecated = doclet . deprecated ; } } ) ; if ( doclet . final ) { res . final = doclet . final ; } res . scope = res . scope || 'instance' ; res . access = res . access || 'public' ; }
1525	function ( command , parameters , callback ) { if ( typeof parameters === 'function' ) { callback = parameters ; parameters = { } ; } parameters || ( parameters = { } ) ; parameters . command = command ; const options = { method : 'GET' , url : PUBLIC_API_URL , qs : parameters } ; options . qs . command = command ; return this . _request ( options , callback ) ; }
1917	function genericCommentToggle ( editor , commentStart , commentEnd , range ) { var editorUtils = require ( 'editorUtils' ) ; var content = editorUtils . outputInfo ( editor ) . content ; var caretPos = editor . getCaretPos ( ) ; var newContent = null ; var utils = require ( 'utils' ) ; function removeComment ( str ) { return str . replace ( new RegExp ( '^' + utils . escapeForRegexp ( commentStart ) + '\\s*' ) , \\ ) . function ( str ) { caretPos -= str . length ; return '' ; } replace ; } ( new RegExp ( '\\s*' + \\ + utils . escapeForRegexp ( commentEnd ) ) , '$' ) '' var commentRange = searchComment ( content , caretPos , commentStart , commentEnd ) ; if ( commentRange && commentRange . overlap ( range ) ) { range = commentRange ; newContent = removeComment ( range . substring ( content ) ) ; } else { newContent = commentStart + ' ' + range . substring ( content ) . replace ( new RegExp ( utils . escapeForRegexp ( commentStart ) + '\\s*|\\s*' + \\ , \\ ) , utils . escapeForRegexp ( commentEnd ) ) + 'g' + '' ; ' ' } }
2264	function toRingClass ( claz ) { if ( claz . __classId__ ) return ; var proto = ! Object . getOwnPropertyNames ? claz . prototype : ( function ( ) { var keys = { } ; ( function crawl ( p ) { if ( p === Object . prototype ) return ; _ . extend ( keys , _ . chain ( Object . getOwnPropertyNames ( p ) ) . map ( function ( el ) { return [ el , true ] ; } ) . fromPairs ( ) . value ( ) ) ; crawl ( Object . getPrototypeOf ( p ) ) ; } ) ( claz . prototype ) ; return _ . fromPairs ( _ . map ( _ . keys ( keys ) , function ( k ) { return [ k , claz . prototype [ k ] ] ; } ) ) ; } ) ( ) ; proto = _ . chain ( proto ) . map ( function ( v , k ) { return [ k , v ] ; } ) . filter ( function ( el ) { return el [ 0 ] !== "constructor" && el [ 0 ] !== "__proto__" ; } ) . fromPairs ( ) . value ( ) ; var id = classCounter ++ ; _ . extend ( claz , { __mro__ : [ claz , ring . Object ] , __properties__ : _ . extend ( { } , proto , { __ringConstructor__ : function ( ) { this . $super . apply ( this , arguments ) ; var tmp = this . $super ; this . $super = null ; try { claz . apply ( this , arguments ) ; } finally { this . $super = tmp ; } } } ) , __classId__ : id , __parents__ : [ ring . Object ] , __classIndex__ : { "1" : ring . Object } , __ringConvertedObject__ : true } ) ; claz . __classIndex__ [ id ] = claz ; }
106	function set ( index ) { var passive = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : true ; var tracks = captions . getTracks . call ( this ) ; if ( index === - 1 ) { captions . toggle . call ( this , false , passive ) ; return ; } if ( ! is$1 . number ( index ) ) { this . debug . warn ( 'Invalid caption argument' , index ) ; return ; } if ( ! ( index in tracks ) ) { this . debug . warn ( 'Track not found' , index ) ; return ; } if ( this . captions . currentTrack !== index ) { this . captions . currentTrack = index ; var track = tracks [ index ] ; var _ref = track || { } , language = _ref . language ; this . captions . currentTrackNode = track ; controls . updateSetting . call ( this , 'captions' ) ; if ( ! passive ) { this . captions . language = language ; this . storage . set ( { language : language } ) ; } if ( this . isVimeo ) { this . embed . enableTextTrack ( language ) ; } triggerEvent . call ( this , this . media , 'languagechange' ) ; } captions . toggle . call ( this , true , passive ) ; if ( this . isHTML5 && this . isVideo ) { captions . updateCues . call ( this ) ; } }
1303	function FunctionCompileInfo ( raw_array ) { this . function_name = raw_array [ 0 ] ; this . start_position = raw_array [ 1 ] ; this . end_position = raw_array [ 2 ] ; this . param_num = raw_array [ 3 ] ; this . code = raw_array [ 4 ] ; this . code_scope_info = raw_array [ 5 ] ; this . scope_info = raw_array [ 6 ] ; this . outer_index = raw_array [ 7 ] ; this . shared_function_info = raw_array [ 8 ] ; this . next_sibling_index = null ; this . raw_array = raw_array ; }
681	function authenticate ( ) { const authPromtpts = [ { type : "text" , name : "username" , message : "Username" } , { type : "password" , name : "password" , message : "Password" } ] ; let session ; return prompts ( authPromtpts ) . then ( ( { username , password } ) => { session = new UserSession ( { username , password } ) ; return session . getUser ( ) ; } ) . then ( self => { return session ; } ) . catch ( error => { if ( error . name === "ArcGISRequestError" ) { console . log ( chalk . bold . red ( "Incorrect username and/or password please try again" ) ) ; return authenticate ( ) ; } console . log ( ` ${ chalk . bold . red ( error . name ) } ${ chalk . bold . red ( error . message ) } ` ) ; } ) ; }
1149	function ( args ) { var amount = _ . isFinite ( args . amount ) ? args . amount : 1 ; return _ . template ( '<filter><feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0"/></filter>' , { a : 0.2126 + 0.7874 * ( 1 - amount ) , b : 0.7152 - 0.7152 * ( 1 - amount ) , c : 0.0722 - 0.0722 * ( 1 - amount ) , d : 0.2126 - 0.2126 * ( 1 - amount ) , e : 0.7152 + 0.2848 * ( 1 - amount ) , f : 0.0722 - 0.0722 * ( 1 - amount ) , g : 0.2126 - 0.2126 * ( 1 - amount ) , h : 0.0722 + 0.9278 * ( 1 - amount ) } ) ; }
2445	function isLikeArray ( obj ) { const res = isArray ( obj ) || obj && isObjectInstance ( obj ) && ! isFuncRgxp . test ( toString . call ( obj ) ) && ( obj . length > 0 && 0 in obj || obj . length === 0 ) ; return Boolean ( res ) ; }
3211	function protect_split ( separator , str ) { var sep = '######' ; var string = false ; var nb_brackets = 0 ; var new_str = "" ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( ! string && / ['"`] / . test ( str [ i ] ) ) string = str [ i ] ; else if ( string && str [ i ] == string ) string = false ; else if ( ! string && str [ i ] == '(' ) nb_brackets ++ ; else if ( ! string && str [ i ] == ')' ) nb_brackets -- ; if ( str [ i ] == separator && ( nb_brackets > 0 || string ) ) new_str += sep ; else new_str += str [ i ] ; } str = new_str ; str = str . split ( separator ) ; str = str . map ( function ( item ) { return trim ( item . replace ( new RegExp ( sep , 'g' ) , separator ) ) ; } ) ; return str ; }
2255	function getHeader ( data ) { var header = { } header . umid = data . slice ( 0 , 3 ) header . mt_version = data . slice ( 3 , 5 ) header . rics = data . slice ( 5 , 9 ) header . key_id = data . slice ( 9 , 14 ) return header }
14	function _tr_tally ( dist , lc ) { var out_length , in_length , dcode ; that . pending_buf [ d_buf + last_lit * 2 ] = ( dist >>> 8 ) & 0xff ; that . pending_buf [ d_buf + last_lit * 2 + 1 ] = dist & 0xff ; that . pending_buf [ l_buf + last_lit ] = lc & 0xff ; last_lit ++ ; if ( dist === 0 ) { dyn_ltree [ lc * 2 ] ++ ; } else { matches ++ ; dist -- ; dyn_ltree [ ( Tree . _length_code [ lc ] + LITERALS + 1 ) * 2 ] ++ ; dyn_dtree [ Tree . d_code ( dist ) * 2 ] ++ ; } if ( ( last_lit & 0x1fff ) === 0 && level > 2 ) { out_length = last_lit * 8 ; in_length = strstart - block_start ; for ( dcode = 0 ; dcode < D_CODES ; dcode ++ ) { out_length += dyn_dtree [ dcode * 2 ] * ( 5 + Tree . extra_dbits [ dcode ] ) ; } out_length >>>= 3 ; if ( ( matches < Math . floor ( last_lit / 2 ) ) && out_length < Math . floor ( in_length / 2 ) ) return true ; } return ( last_lit === lit_bufsize - 1 ) ; }
762	function ( div ) { var sizeSpan = document . createElement ( 'span' ) ; sizeSpan . setAttribute ( 'style' , 'margin: 0; padding: 0 0 0 1em; border: 0;' ) ; div . appendChild ( sizeSpan ) ; var oneEmWidth = sizeSpan . offsetWidth ; div . removeChild ( sizeSpan ) ; return oneEmWidth ; }
3241	function ( ) { if ( ! this . clearOnEscape ) { return ; } this . textField . inputEl . on ( 'keydown' , function ( e ) { if ( e . getKey ( ) == Ext . EventObject . ESC ) { if ( this . textField . isExpanded ) { return ; } if ( this . textField . clearValue ) { Ext . Function . defer ( this . textField . clearValue , 1 , this . textField ) ; } else { Ext . Function . defer ( this . textField . setValue , 1 , this . textField , [ '' ] ) ; } e . stopEvent ( ) ; } } , this ) ; }
3051	function ( events ) { var me = this , i , event , stateEventsByName ; if ( me . stateful && me . getStateId ( ) ) { if ( typeof events == 'string' ) { events = Array . prototype . slice . call ( arguments , 0 ) ; } stateEventsByName = me . stateEventsByName || ( me . stateEventsByName = { } ) ; for ( i = events . length ; i -- ; ) { event = events [ i ] ; if ( ! stateEventsByName [ event ] ) { stateEventsByName [ event ] = 1 ; me . on ( event , me . onStateChange , me ) ; } } } }
867	function extendsNull ( node ) { return ( node . superClass != null && node . superClass . type === "Literal" && node . superClass . value === null ) }
359	function regexp ( rule , value , callback , source , options ) { const errors = [ ] ; const validate = rule . required || ( ! rule . required && source . hasOwnProperty ( rule . field ) ) ; if ( validate ) { if ( isEmptyValue ( value ) && ! rule . required ) { return callback ( ) ; } rules . required ( rule , value , source , errors , options ) ; if ( ! isEmptyValue ( value ) ) { rules . type ( rule , value , source , errors , options ) ; } } callback ( errors ) ; }
1831	function getLongestArray ( arrays ) { var lengths = arrays . map ( array => array . length ) return Math . max . apply ( null , lengths ) }
2197	function push ( ) { var name , value , browserCookies , updated ; for ( name in lastCookies ) { if ( isUndefined ( cookies [ name ] ) ) { $browser . cookies ( name , undefined ) ; } } for ( name in cookies ) { value = cookies [ name ] ; if ( ! angular . isString ( value ) ) { value = '' + value ; cookies [ name ] = value ; } if ( value !== lastCookies [ name ] ) { $browser . cookies ( name , value ) ; updated = true ; } } if ( updated ) { updated = false ; browserCookies = $browser . cookies ( ) ; for ( name in cookies ) { if ( cookies [ name ] !== browserCookies [ name ] ) { if ( isUndefined ( browserCookies [ name ] ) ) { delete cookies [ name ] ; } else { cookies [ name ] = browserCookies [ name ] ; } updated = true ; } } } }
3154	function deleteFile ( name , callback ) { fs . unlink ( path . join ( LOG_DIR , name ) , callback ) ; }
1259	function destroy ( component , removeNode = true ) { if ( syncUpdatesInProgressCounter > 0 || syncDestructionsInProgressCounter > 0 ) { destroySync ( component , removeNode ) return Promise . resolve ( ) } let scheduler = getScheduler ( ) scheduler . updateDocument ( function ( ) { destroySync ( component , removeNode ) } ) return scheduler . getNextUpdatePromise ( ) }
1198	function ( html ) { var range = rangy . createRange ( this . doc ) , node = range . createContextualFragment ( html ) , lastChild = node . lastChild ; this . insertNode ( node ) ; if ( lastChild ) { this . setAfter ( lastChild ) ; } }
1349	function parseOne ( data ) { if ( ! data || ! data [ 0 ] ) { return } if ( process . platform . includes ( 'linux' ) ) { if ( data [ 0 ] . indexOf ( 'no entry' ) >= 0 ) { return } var rows = data [ 0 ] . split ( '\n' ) . \n slice [ ( 1 ) ] 0 } else return parseLinux ( rows , servers , true ) if ( process . platform . includes ( 'win32' ) ) { return } }
532	function ( data , mime , name , extension , merges , RTL , sheetname ) { var format = extension . slice ( 1 ) ; data = this . getRawData ( data , extension , name , merges , RTL , sheetname ) ; if ( _isMobile && ( format === _FORMAT . CSV || format === _FORMAT . TXT ) ) { var dataURI = "data:" + mime + ";" + this . charset + "," + data ; this . downloadDataURI ( dataURI , name , extension ) ; } else { saveAs ( new Blob ( [ data ] , { type : mime + ";" + this . charset } ) , name + extension , true ) ; } }
3653	function recordAndTriggerHandlers ( type , eventData ) { this . history . push ( { type : type , data : eventData } ) this . handlers [ type ] . forEach ( function ( handlerInfo ) { try { handlerInfo . handler . call ( undefined , eventData ) } catch ( e ) { var throwErrorFn = options . throwAsyncException if ( handlerInfo . domain ) { throwErrorFn = handlerInfo . domain . bind ( throwErrorFn ) } throwErrorFn ( e ) } } ) }
27	function splitLongWord ( word , widths_array , firstLineMaxLen , maxLen ) { var answer = [ ] ; var i = 0 , l = word . length , workingLen = 0 ; while ( i !== l && workingLen + widths_array [ i ] < firstLineMaxLen ) { workingLen += widths_array [ i ] ; i ++ ; } answer . push ( word . slice ( 0 , i ) ) ; var startOfLine = i ; workingLen = 0 ; while ( i !== l ) { if ( workingLen + widths_array [ i ] > maxLen ) { answer . push ( word . slice ( startOfLine , i ) ) ; workingLen = 0 ; startOfLine = i ; } workingLen += widths_array [ i ] ; i ++ ; } if ( startOfLine !== i ) { answer . push ( word . slice ( startOfLine , i ) ) ; } return answer ; }
349	function parseKey ( ) { var specialValues = [ 'null' , 'true' , 'false' ] ; var key = '' ; var c = curr ( ) ; var regexp = / [a-zA-Z_$\d] / ; while ( regexp . test ( c ) ) { key += c ; i ++ ; c = curr ( ) ; } if ( specialValues . indexOf ( key ) === - 1 ) { chars . push ( '"' + key + '"' ) ; } else { chars . push ( key ) ; } }
3618	function string ( obj , vonly ) { var vtype = this . type ( 0 ) , key = ! vonly ? this . getStringBuffer ( obj . key ) : new Buffer ( 0 ) , value = this . getStringBuffer ( obj . value ) ; return Buffer . concat ( [ vtype , key , value ] , vtype . length + key . length + value . length ) }
3491	function ( ) { var parts = Ext . partition ( arguments , function ( val ) { return typeof val != 'function' ; } ) , arrs = parts [ 0 ] , fn = parts [ 1 ] [ 0 ] , len = Ext . max ( Ext . pluck ( arrs , "length" ) ) , ret = [ ] , i , j , aLen ; for ( i = 0 ; i < len ; i ++ ) { ret [ i ] = [ ] ; if ( fn ) { ret [ i ] = fn . apply ( fn , Ext . pluck ( arrs , i ) ) ; } else { for ( j = 0 , aLen = arrs . length ; j < aLen ; j ++ ) { ret [ i ] . push ( arrs [ j ] [ i ] ) ; } } } return ret ; }
1632	function nextSiblings ( element ) { var next = element . nextSibling ; var siblings = [ ] ; while ( next ) { siblings . push ( next ) ; next = next . nextSibling ; } return siblings ; }
1960	function replaceVariable ( template , name , value ) { let key = ` ${ name } ` ; let reg = new RegExp ( helper . escapeRegExp ( key ) , 'g' ) ; let encodedReg = new RegExp ( helper . escapeRegExp ( ` ${ name } ` ) , 'g' ) ; let encodedValue = JSON . stringify ( value ) . replace ( / <\/script / gi , '<\\/script' ) ; \\ }
1546	function put ( point , data , octree , octant , depth ) { let children = octant . children ; let exists = false ; let done = false ; let i , l ; if ( octant . contains ( point , octree . bias ) ) { if ( children === null ) { if ( octant . points === null ) { octant . points = [ ] ; octant . data = [ ] ; } else { for ( i = 0 , l = octant . points . length ; ! exists && i < l ; ++ i ) { exists = octant . points [ i ] . equals ( point ) ; } } if ( exists ) { octant . data [ i - 1 ] = data ; done = true ; } else if ( octant . points . length < octree . maxPoints || depth === octree . maxDepth ) { octant . points . push ( point . clone ( ) ) ; octant . data . push ( data ) ; ++ octree . pointCount ; done = true ; } else { octant . split ( ) ; octant . redistribute ( octree . bias ) ; children = octant . children ; } } if ( children !== null ) { ++ depth ; for ( i = 0 , l = children . length ; ! done && i < l ; ++ i ) { done = put ( point , data , octree , children [ i ] , depth ) ; } } } return done ; }
2786	function ld ( date , long = true , options = null ) { return Localizer . Singleton . formatDate ( date , long , options ) }
2295	function randomDate ( start , end ) { return new Date ( start . getTime ( ) + Math . random ( ) * ( end . getTime ( ) - start . getTime ( ) ) ) ; }
3247	function saveProperty ( name , token ) { if ( props [ name ] && is_own ( props , name ) ) warning ( "Duplicate member '{a}'." , nexttoken , i ) ; else props [ name ] = { } ; props [ name ] . basic = true ; props [ name ] . basicToken = token ; }
1604	function makePath ( dirPath ) { dirPath = path . dirname ( dirPath ) . split ( path . sep ) dirPath . reduce ( function ( dirPath , p ) { dirPath = path . join ( dirPath , p ) if ( ! fs . existsSync ( dirPath ) ) { try { fs . mkdirSync ( dirPath ) } catch ( e ) { throw 'Could not make path ' + dirPath } } return dirPath } , '' ) }
1167	function ( idx , value ) { idx = idx || 0 ; var labels = this . get ( 'labels' ) || [ ] ; if ( arguments . length === 0 || arguments . length === 1 ) { return labels [ idx ] ; } var newValue = _ . merge ( { } , labels [ idx ] , value ) ; var newLabels = labels . slice ( ) ; newLabels [ idx ] = newValue ; return this . set ( { labels : newLabels } ) ; }
3577	function ( key , value , priority ) { SjlMap . prototype . set . call ( this , key , this . resolveItemWrapping ( key , value , priority ) ) ; this . _sorted = false ; return this ; }
2393	function get_registers ( cpu ) { cpu = cpu . toLowerCase ( ) ; if ( cpu . startsWith ( 'arm' ) ) { return REGISTERS . ARM ; } if ( ~ [ 'x86' , 'i386' , 'i486' , 'i686' ] . indexOf ( cpu ) ) { return REGISTERS . X86 ; } if ( cpu === 'x86_64' ) { return REGISTERS . X86_64 ; } return [ ] ; }
2928	function toPercentage ( val ) { var precision = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 0 ; var min = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : 0 ; var max = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : 1 ; if ( ! isNumber ( val ) || isNumericalNaN ( val ) ) { throw new TypeError ( 'Value should be numeric' ) ; } if ( ! isNumber ( min ) || isNumericalNaN ( min ) ) { throw new TypeError ( 'Value should be numeric' ) ; } if ( ! isNumber ( max ) || isNumericalNaN ( max ) ) { throw new TypeError ( 'Value should be numeric' ) ; } return round ( ( val - min ) / ( max - min ) * 100 , precision ) ; }
485	function isInitializerDescriptor ( desc ) { return ! ! desc && isFunction ( desc . initializer ) && isBoolean ( desc . configurable ) && isBoolean ( desc . enumerable ) && isBoolean ( desc . writable ) ; }
409	function addReplacementIntoPath ( beginningPath , addPath , replacedElement , originalSelector ) { var newSelectorPath , lastSelector , newJoinedSelector ; newSelectorPath = [ ] ; if ( beginningPath . length > 0 ) { newSelectorPath = utils . copyArray ( beginningPath ) ; lastSelector = newSelectorPath . pop ( ) ; newJoinedSelector = originalSelector . createDerived ( utils . copyArray ( lastSelector . elements ) ) ; } else { newJoinedSelector = originalSelector . createDerived ( [ ] ) ; } if ( addPath . length > 0 ) { var combinator = replacedElement . combinator , parentEl = addPath [ 0 ] . elements [ 0 ] ; if ( combinator . emptyOrWhitespace && ! parentEl . combinator . emptyOrWhitespace ) { combinator = parentEl . combinator ; } newJoinedSelector . elements . push ( new Element ( combinator , parentEl . value , replacedElement . isVariable , replacedElement . _index , replacedElement . _fileInfo ) ) ; newJoinedSelector . elements = newJoinedSelector . elements . concat ( addPath [ 0 ] . elements . slice ( 1 ) ) ; } if ( newJoinedSelector . elements . length !== 0 ) { newSelectorPath . push ( newJoinedSelector ) ; } if ( addPath . length > 1 ) { var restOfPath = addPath . slice ( 1 ) ; restOfPath = restOfPath . map ( function ( selector ) { return selector . createDerived ( selector . elements , [ ] ) ; } ) ; newSelectorPath = newSelectorPath . concat ( restOfPath ) ; } return newSelectorPath ; }
3020	function ( ) { var instance = _ . clone ( modelView ) var numArgs = arguments . length if ( numArgs === 1 && typeof arguments [ 0 ] === 'object' ) { instance . args = arguments [ 0 ] } else { instance . args = { } if ( numArgs > 0 ) { instance . args . properties = [ ] for ( var i = 0 ; i < numArgs ; i ++ ) { assert ( typeof arguments [ i ] === 'string' , 'invalid argument ' + arguments [ i ] ) instance . args . properties [ i ] = arguments [ i ] } } } setModelViewInstanceId ( instance ) instance . class = 'ImmutableCoreModelViewInstance' instance . ImmutableCoreModelViewInstance = true return instance }
478	function transObjectAttrIntoArray ( obj ) { var fn = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : function ( a , b ) { return + a - + b ; } ; return _Object$keys ( obj ) . sort ( fn ) . reduce ( function ( order , key ) { return order . concat ( obj [ key ] ) ; } , [ ] ) ; }
99	function showMenuPanel ( ) { var _this9 = this ; var type = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : '' ; var tabFocus = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; var target = this . elements . container . querySelector ( "#plyr-settings-" . concat ( this . id , "-" ) . concat ( type ) ) ; if ( ! is$1 . element ( target ) ) { return ; } var container = target . parentNode ; var current = Array . from ( container . children ) . find ( function ( node ) { return ! node . hidden ; } ) ; if ( support . transitions && ! support . reducedMotion ) { container . style . width = "" . concat ( current . scrollWidth , "px" ) ; container . style . height = "" . concat ( current . scrollHeight , "px" ) ; var size = controls . getMenuSize . call ( this , target ) ; var restore = function restore ( event ) { if ( event . target !== container || ! [ 'width' , 'height' ] . includes ( event . propertyName ) ) { return ; } container . style . width = '' ; container . style . height = '' ; off . call ( _this9 , container , transitionEndEvent , restore ) ; } ; on . call ( this , container , transitionEndEvent , restore ) ; container . style . width = "" . concat ( size . width , "px" ) ; container . style . height = "" . concat ( size . height , "px" ) ; } toggleHidden ( current , true ) ; toggleHidden ( target , false ) ; controls . focusFirstMenuItem . call ( this , target , tabFocus ) ; }
2341	function doListDatasetClients ( filter , cb ) { debug ( 'doListDatasetClients' ) ; var col = mongoClient . collection ( DATASETCLIENTS_COLLECTION ) ; col . find ( filter ) . toArray ( function ( err , datasetClients ) { if ( err ) { debugError ( 'Failed to list datasetClients due to error %s' , err ) ; } return cb ( err , datasetClients ) ; } ) ; }
1902	function ( name ) { var element = this . get ( name ) ; if ( element ) { this . _updateSource ( '' , element . fullRange ( ) ) ; this . _children = _ . without ( this . _children , element ) ; } }
2067	function getLangDefinition ( key ) { if ( ! key ) { return moment . fn . _lang ; } if ( ! languages [ key ] && hasModule ) { try { require ( './lang/' + key ) ; } catch ( e ) { return moment . fn . _lang ; } } return languages [ key ] ; }
3018	function ( astList , context , callback ) { var retval = new Array ( 2 ) ; var i = 0 ; var getOpArgs2_callback = function ( err , val ) { if ( err ) { callback ( err ) ; } else { retval [ i ] = val ; i ++ ; if ( i >= 2 ) callback ( null , retval ) ; } } ; run ( astList [ 1 ] , context , getOpArgs2_callback ) ; run ( astList [ 2 ] , context , getOpArgs2_callback ) ; }
891	function doMixin ( target , source , k , opts ) { let { mixinAttrName = MIXIN_ATTR_NAME , lifecycleHookMap , mixinStrategy } = opts ; if ( k === mixinAttrName ) { return ; } let mixinHandler = mixinStrategy && mixinStrategy [ k ] ; if ( mixinHandler ) { target [ k ] = mixinHandler ( target [ k ] , source [ k ] ) ; } else if ( lifecycleHookMap [ k ] ) { let child = target [ k ] ; let parent = source [ k ] ; if ( ! Array . isArray ( child ) ) { child = child ? [ child ] : [ ] ; } if ( ! Array . isArray ( parent ) ) { parent = parent ? [ parent ] : [ ] ; } child . unshift . apply ( child , parent ) ; target [ k ] = child ; } else if ( ! target . hasOwnProperty ( k ) ) { target [ k ] = source [ k ] ; } }
749	function touch ( network ) { window . open ( this . createSharingUrl ( network ) , '_self' ) ; this . $root . $emit ( 'social_shares_open' , network , this . url ) ; this . $emit ( 'open' , network , this . url ) ; }
1159	function ( p , angle ) { p = point ( p ) ; if ( angle ) p . rotate ( point ( this . x , this . y ) , angle ) ; var dx = p . x - this . x ; var dy = p . y - this . y ; var result ; if ( dx === 0 ) { result = this . bbox ( ) . pointNearestToPoint ( p ) ; if ( angle ) return result . rotate ( point ( this . x , this . y ) , - angle ) ; return result ; } var m = dy / dx ; var mSquared = m * m ; var aSquared = this . a * this . a ; var bSquared = this . b * this . b ; var x = sqrt ( 1 / ( ( 1 / aSquared ) + ( mSquared / bSquared ) ) ) ; x = dx < 0 ? - x : x ; var y = m * x ; result = point ( this . x + x , this . y + y ) ; if ( angle ) return result . rotate ( point ( this . x , this . y ) , - angle ) ; return result ; }
198	function isRemovable ( purchase ) { if ( isIncludedWithPlan ( purchase ) ) { return false ; } if ( isConciergeSession ( purchase ) ) { return false ; } return ( isJetpackPlan ( purchase ) || isExpiring ( purchase ) || isExpired ( purchase ) || ( isDomainTransfer ( purchase ) && ! isRefundable ( purchase ) && isPurchaseCancelable ( purchase ) ) ) ; }
1181	function Set ( initialKeys ) { this . _size = 0 ; this . _keys = { } ; if ( initialKeys ) { for ( var i = 0 , il = initialKeys . length ; i < il ; ++ i ) { this . add ( initialKeys [ i ] ) ; } } }
320	function clear ( ) { if ( this . cropped && ! this . disabled ) { assign ( this . cropBoxData , { left : 0 , top : 0 , width : 0 , height : 0 } ) ; this . cropped = false ; this . renderCropBox ( ) ; this . limitCanvas ( true , true ) ; this . renderCanvas ( ) ; removeClass ( this . dragBox , CLASS_MODAL ) ; addClass ( this . cropBox , CLASS_HIDDEN ) ; } return this ; }
2132	function getResultSeverity ( result , config ) { return result . reduce ( ( previous , message ) => { let severity if ( message . fatal ) { return previous + 1 } severity = message . messages [ 0 ] ? message . messages [ 0 ] . severity : 0 if ( severity === 2 ) { return previous + 1 } return previous } , 0 ) }
2821	function ( data ) { var paramArray = [ ] , key , value ; for ( key in data ) { value = data [ key ] ; key = ENCODE_URI_COMPONENT ( key ) ; paramArray . push ( ( value === null ) ? key : ( key + "=" + ENCODE_URI_COMPONENT ( value ) ) ) ; } return paramArray . join ( "&" ) ; }
1331	function Node ( node , loc ) { if ( yy . options . captureLocations ) { node . loc = { source : parsingString . slice ( loc . startOffset , loc . endOffset ) , start : { line : loc . startLine , column : loc . startColumn , offset : loc . startOffset , } , end : { line : loc . endLine , column : loc . endColumn , offset : loc . endOffset , } , } ; } return node ; }
745	function ( cb ) { if ( Stripe . USER_AGENT_SERIALIZED ) { return cb ( Stripe . USER_AGENT_SERIALIZED ) ; } this . getClientUserAgentSeeded ( Stripe . USER_AGENT , function ( cua ) { Stripe . USER_AGENT_SERIALIZED = cua ; cb ( Stripe . USER_AGENT_SERIALIZED ) ; } ) }
2023	function ( apporplugin ) { try { configHelpers . disable ( apporplugin ) ; logger . info ( apporplugin + ' disabled' ) ; } catch ( err ) { logger . error ( 'Cannot disable given app or plugin, ' + apporplugin + ' cannot find it in the config file.' ) ; logger . raw ( err ) ; } }
317	function parseOrientation ( orientation ) { var rotate = 0 ; var scaleX = 1 ; var scaleY = 1 ; switch ( orientation ) { case 2 : scaleX = - 1 ; break ; case 3 : rotate = - 180 ; break ; case 4 : scaleY = - 1 ; break ; case 5 : rotate = 90 ; scaleY = - 1 ; break ; case 6 : rotate = 90 ; break ; case 7 : rotate = 90 ; scaleX = - 1 ; break ; case 8 : rotate = - 90 ; break ; default : } return { rotate : rotate , scaleX : scaleX , scaleY : scaleY } ; }
3233	function ( config ) { var me = this , o , key , value ; me . copyLegacyObject ( config , me . customRenderers , 'renderer' ) ; me . copyLegacyObject ( config , me . customEditors , 'editor' ) ; me . copyLegacyObject ( config , me . propertyNames , 'displayName' ) ; if ( me . customRenderers || me . customEditors || me . propertyNames ) { if ( Ext . global . console && Ext . global . console . warn ) { Ext . global . console . warn ( this . $className , 'customRenderers, customEditors & propertyNames have been consolidated into a new config, see "sourceConfig". These configurations will be deprecated.' ) ; } } }
1231	function SubEmitterSocket ( ) { this . sock = new SubSocket ; this . sock . onmessage = this . onmessage . bind ( this ) ; this . bind = this . sock . bind . bind ( this . sock ) ; this . connect = this . sock . connect . bind ( this . sock ) ; this . close = this . sock . close . bind ( this . sock ) ; this . listeners = [ ] ; }
638	function removeImagesFromText ( text ) { const images = imageInText ( text ) ; const imageTags = matchStringWithRegex ( text , "</img>" ) ; if ( images . length > 0 ) { images . forEach ( function ( image ) { text = text . replace ( image , "" ) ; } ) ; imageTags . forEach ( function ( imageTag ) { text = text . replace ( imageTag , "" ) ; } ) ; } return text ; }
521	function _finishRecording ( ) { if ( _recordedSequenceCallback ) { _normalizeSequence ( _recordedSequence ) ; _recordedSequenceCallback ( _recordedSequence ) ; } _recordedSequence = [ ] ; _recordedSequenceCallback = null ; _currentRecordedKeys = [ ] ; }
120	function setPlayerSize ( measure ) { if ( ! measure ) { return setAspectRatio . call ( player ) ; } var rect = elements . container . getBoundingClientRect ( ) ; var width = rect . width , height = rect . height ; return setAspectRatio . call ( player , "" . concat ( width , ":" ) . concat ( height ) ) ; }
2046	function ( app , callback ) { var options = { local : true , dir : configHelpers . getModulesPath ( ) , prefix : '' } ; npm . load ( options , function ( ) { app = pathExtra . resolve ( npmHelpers . initialWd , app ) ; npm . commands . link ( [ app ] , callback ) ; } ) ; }
769	function filterCss ( abstractSyntaxTree , allowedStyles ) { if ( ! allowedStyles ) { return abstractSyntaxTree ; } var filteredAST = cloneDeep ( abstractSyntaxTree ) ; var astRules = abstractSyntaxTree . nodes [ 0 ] ; var selectedRule ; if ( allowedStyles [ astRules . selector ] && allowedStyles [ '*' ] ) { selectedRule = mergeWith ( cloneDeep ( allowedStyles [ astRules . selector ] ) , allowedStyles [ '*' ] , function ( objValue , srcValue ) { if ( Array . isArray ( objValue ) ) { return objValue . concat ( srcValue ) ; } } ) ; } else { selectedRule = allowedStyles [ astRules . selector ] || allowedStyles [ '*' ] ; } if ( selectedRule ) { filteredAST . nodes [ 0 ] . nodes = astRules . nodes . reduce ( filterDeclarations ( selectedRule ) , [ ] ) ; } return filteredAST ; }
3809	function OpenCommand ( args , define ) { var lowerArgs = args . toLowerCase ( ) ; var forIndex = lowerArgs . indexOf ( ' for ' ) ; if ( forIndex === - 1 ) throw new SyntaxError ( 'OPEN without FOR' ) ; var filename = new statements . ExpressionStatement ( args . substring ( 0 , forIndex ) . trim ( ) , define ) ; var asIndex = lowerArgs . indexOf ( ' as ' ) ; if ( asIndex === - 1 ) throw new SyntaxError ( 'OPEN without AS' ) ; var type = args . substring ( forIndex + 5 , asIndex ) . trim ( ) . toLowerCase ( ) ; if ( type !== 'input' && type !== 'output' && type !== 'append' ) throw new SyntaxError ( 'Invalid mode' ) ; var pointer = new statements . ExpressionStatement ( args . substring ( asIndex + 4 ) . trim ( ) , define ) ; if ( ! ( pointer . child instanceof statements . PointerStatement ) ) throw new SyntaxError ( 'Expected pointer' ) ; this . filename = filename ; this . type = type ; this . pointer = pointer ; }
3015	function ( fn , scope ) { var items = Ext . apply ( { } , this . map ) , key , length = this . length ; scope = scope || this ; for ( key in items ) { if ( items . hasOwnProperty ( key ) ) { if ( fn . call ( scope , key , items [ key ] , length ) === false ) { break ; } } } return this ; }
1503	function parseOids ( options ) { if ( options . oid ) { options . oid = parseSingleOid ( options . oid ) ; } if ( options . oids ) { options . oids = options . oids . map ( parseSingleOid ) ; } }
244	function replaceMarkers ( ) { const markers = $ ( '.wpview-marker' ) ; if ( ! markers . length ) { return false ; } markers . each ( function ( index , node ) { let text = editor . dom . getAttrib ( node , 'data-wpview-text' ) , type = editor . dom . getAttrib ( node , 'data-wpview-type' ) ; editor . dom . replace ( editor . dom . createFragment ( '<div class="wpview-wrap" data-wpview-text="' + text + '" data-wpview-type="' + type + '">' + '<p class="wpview-selection-before">\u00a0</p>' + \u00a0 + '<div class="wpview-body" contenteditable="false"></div>' + '<p class="wpview-selection-after">\u00a0</p>' ) , \u00a0 ) ; } ) ; '</div>' }
3466	function ( action , method , args ) { var me = this , callData , data , callback , scope , opts , transaction , params ; callData = method . getCallData ( args ) ; data = callData . data ; callback = callData . callback ; scope = callData . scope ; opts = callData . options || { } ; params = Ext . apply ( { } , { provider : me , args : args , action : action , method : method . name , data : data , callbackOptions : opts , callback : scope && Ext . isFunction ( callback ) ? Ext . Function . bind ( callback , scope ) : callback } ) ; if ( opts . timeout ) { Ext . applyIf ( params , { timeout : opts . timeout } ) ; } ; transaction = new Ext . direct . Transaction ( params ) ; if ( me . fireEvent ( 'beforecall' , me , transaction , method ) !== false ) { Ext . direct . Manager . addTransaction ( transaction ) ; me . queueTransaction ( transaction ) ; me . fireEvent ( 'call' , me , transaction , method ) ; } }
2262	function onMessage ( msg , rinfo ) { if ( msg . length >= 15 && msg [ 0 ] === 0x23 && msg [ 1 ] === 0x02 && msg [ 14 ] === thisObject . findGatewaySequenceNumber && rinfo . family === "IPv4" ) { gatewayFound = true ; resolve ( rinfo . address ) ; } }
2340	function removeCollision ( datasetId , params , cb ) { debug ( '[%s] removeCollision' ) ; dataHandlers . removeCollision ( datasetId , params . hash , params . meta_data , cb ) ; }
3763	function execute ( ast , ctx , done ) { if ( ! done && ! ( ctx instanceof ExecutionContext ) ) { done = ctx ; ctx = new ExecutionContext ( ) ; } ast . execute ( ctx , done ) ; }
427	function ( less ) { this . less = less ; this . require = function ( prefix ) { prefix = path . dirname ( prefix ) ; return function ( id ) { var str = id . substr ( 0 , 2 ) ; if ( str === '..' || str === './' ) { return require ( path . join ( prefix , id ) ) ; } else { return require ( id ) ; } } ; } ; }
1874	function ( text , start , end ) { var range = require ( 'range' ) . create ( start , end ) ; var reSpace = / [\s\n\r\u00a0] / ; while ( range . start < range . end ) { if ( ! reSpace . test ( text . charAt ( range . start ) ) ) break ; range . start ++ ; } while ( range . end > range . start ) { range . end -- ; if ( ! reSpace . test ( text . charAt ( range . end ) ) ) { range . end ++ ; break ; } } return range ; }
3098	function ( parent , records , suppressEvent , callback , scope ) { var me = this , collapseIndex = me . indexOf ( parent ) + 1 , node , lastNodeIndexPlus , sibling , found ; if ( ! me . recursive && parent !== me . node ) { return ; } if ( ! suppressEvent ) { me . fireEvent ( 'beforecollapse' , parent , records , collapseIndex , callback , scope ) ; } if ( records . length && me . data . contains ( records [ 0 ] ) ) { node = parent ; while ( node . parentNode ) { sibling = node . nextSibling ; if ( sibling ) { found = true ; lastNodeIndexPlus = me . indexOf ( sibling ) ; break ; } else { node = node . parentNode ; } } if ( ! found ) { lastNodeIndexPlus = me . getCount ( ) ; } me . removeAt ( collapseIndex , lastNodeIndexPlus - collapseIndex ) ; } if ( ! suppressEvent ) { me . fireEvent ( 'collapse' , parent , records , collapseIndex ) ; } }
1965	function getOrdersStatistics ( metricKeys = [ 'item_sold_minecraft' , 'prepaid_card_redeemed_minecraft' ] ) { return fetch ( ` ${ CORE_API } ` , { method : 'POST' , body : JSON . stringify ( { metricKeys } ) , headers : { 'user-agent' : USER_AGENT , 'content-type' : 'application/json' , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => res . json ( ) ) }
492	function Vessel ( dispatcher , target , config ) { var _this = this ; _classCallCheck ( this , Vessel ) ; this . __dispatcher = dispatcher ; this . __target = target ; [ 'width' , 'height' , 'position' , 'display' ] . forEach ( function ( key ) { _Object$defineProperty ( _this , key , { get : function get ( ) { return this . __dispatcher . dom . getStyle ( this . __target , key ) ; } , set : function set ( value ) { if ( isNumber ( value ) ) { value = value + 'px' ; } if ( ! isString ( value ) ) { throw new Error ( 'The value of ' + key + ' in ' + this . __target + 'Config must be string, but not ' + ( typeof value === 'undefined' ? 'undefined' : _typeof ( value ) ) + '.' ) ; } this . __dispatcher . dom . setStyle ( this . __target , key , value ) ; } , configurable : true , enumerable : true } ) ; } ) ; deepAssign ( this , config ) ; }
3230	function ( obj ) { var i = 0 , items = this . items , surface = this . getSurface ( ) , len = this . length ; if ( surface ) { for ( ; i < len ; i ++ ) { surface . addCls ( items [ i ] , obj ) ; } } }
1819	function normalizeProtocol ( protocol ) { if ( protocol && protocol . length > 0 && protocol . charAt ( protocol . length - 1 ) !== ':' ) { return protocol + ':' } return protocol }
2042	function ( plugin ) { var ret = false ; if ( config . plugins [ plugin ] !== undefined ) { delete config . plugins [ plugin ] ; configHelpers . saveConfig ( ) ; ret = true ; } return ret ; }
2028	function ( distroName , actions , callback ) { if ( distros [ distroName ] !== undefined ) { var distro = distros [ distroName ] ; logger . info ( 'Installing plugins...' ) ; async . eachSeries ( distro . plugins , function addPlugin ( pluginName , cb ) { actions . installPlugin ( pluginName , cb ) ; } , function installApps ( err ) { if ( err ) { callback ( err ) ; } else { logger . info ( 'Installing apps...' ) ; async . eachSeries ( distro . apps , function addApp ( appName , cb ) { actions . installApp ( appName , cb ) ; } , callback ) ; } } ) ; } else { throw new Error ( 'Unknown distro, can\'t install it' ) ; } }
450	function downsample ( data , maxPoints , startingIndex = 0 ) { const dataLength = getLength ( data ) ; if ( dataLength > maxPoints ) { const k = Math . pow ( 2 , Math . ceil ( Math . log2 ( dataLength / maxPoints ) ) ) ; return data . filter ( ( d , i ) => ( i + startingIndex ) % k === 0 ) ; } return data ; }
767	function Enforcer ( keycloak , config ) { this . keycloak = keycloak ; this . config = config || { } ; if ( ! this . config . response_mode ) { this . config . response_mode = 'permissions' ; } if ( ! this . config . resource_server_id ) { this . config . resource_server_id = this . keycloak . getConfig ( ) . clientId ; } }
3231	function ( obj ) { var i = 0 , items = this . items , surface = this . getSurface ( ) , len = this . length ; if ( surface ) { for ( ; i < len ; i ++ ) { surface . removeCls ( items [ i ] , obj ) ; } } }
2862	function SelectQuery ( request , context ) { this . request = request ; this . domain = new Domain ( { source : request , context : context } ) ; this . filters = [ ] ; this . matchExpression = '' ; this . noResult = false ; this . parse ( ) ; }
796	function loadSettings ( source , ctx ) { return loadSingle ( source ) . then ( function ( data ) { if ( data ) { data = JSON . parse ( data ) ; ctx . override = data . override ; } } ) ; }
911	function normalizeQuickAppPage ( pageInfo ) { pageInfo = normalizePage ( pageInfo ) ; let { data , dataAccessType } = pageInfo ; if ( data && ! pageInfo [ dataAccessType ] ) { pageInfo [ dataAccessType ] = data ; delete pageInfo . data ; } let queryProps = [ ] ; if ( pageInfo . protected ) { queryProps = Object . keys ( pageInfo . protected ) ; } if ( pageInfo . public ) { queryProps = queryProps . push . apply ( queryProps , Object . keys ( pageInfo . public ) ) ; } let privateData = pageInfo . private ; privateData || ( privateData = pageInfo . private = { } ) ; privateData . queryProps__ = queryProps ; return pageInfo ; }
1275	function RSASetPublic ( N , E ) { if ( N != null && E != null && N . length > 0 && E . length > 0 ) { this . n = parseBigInt ( N , 16 ) ; this . e = parseInt ( E , 16 ) ; } else alert ( "Invalid RSA public key" ) ; }
3722	function initialize ( dest , declarations , name , cache , inited ) { var decl = declarations [ name ] ; if ( ! inited [ name ] ) { var len = cache . dependencies [ name ] . length ; for ( var i = 0 ; i < len ; i ++ ) { initialize ( dest , declarations , cache . dependencies [ name ] [ i ] , cache , inited ) ; } decl . _init ( dest , name ) ; inited [ name ] = true ; } }
123	function executeCallbacks ( args , depsNotFound ) { if ( args . call ) args = { success : args } ; if ( depsNotFound . length ) ( args . error || devnull ) ( depsNotFound ) ; else ( args . success || devnull ) ( args ) ; }
3256	function ( data ) { var me = this , fields = me . fields , key , field ; for ( key in fields ) { if ( fields . hasOwnProperty ( key ) ) { field = fields [ key ] ; field . suspendEvents ( ) ; field . setValue ( key in data ? data [ key ] : '' ) ; field . resumeEvents ( ) ; } } me . fireEvent ( 'update' , me ) ; }
3725	function getEntity ( decl ) { if ( decl . type === "Literal" ) { return { block : decl . value } ; } if ( decl . type === "ObjectExpression" ) { var base = getProperty ( decl , 'baseBlock' ) , o = { block : getProperty ( decl , 'block' ) , mod : getProperty ( decl , 'modName' ) , val : getProperty ( decl , 'modVal' ) } ; if ( base ) { o . base = base ; } return o ; } }
2136	function ( element , callback ) { var me = this ; var elementType = Object . prototype . toString . call ( element ) ; var isCollectionTyped = me . _isCollectionTyped = ( '[object Array]' === elementType || ( '[object NodeList]' === elementType ) || ( '[object HTMLCollection]' === elementType ) || ( 'undefined' !== typeof jQuery && element instanceof window . jQuery ) || ( 'undefined' !== typeof Elements && element instanceof window . Elements ) ) ; me . _element = element ; if ( isCollectionTyped ) { var i = 0 , j = element . length ; for ( ; i < j ; i ++ ) { attachResizeEvent ( element [ i ] , callback ) ; } } else { attachResizeEvent ( element , callback ) ; } }
26	function createDefaultAppearanceStream ( formObject ) { var fontKey = scope . internal . getFont ( formObject . fontName , formObject . fontStyle ) . id ; var encodedColor = scope . __private__ . encodeColorString ( formObject . color ) ; var fontSize = formObject . fontSize ; var result = '/' + fontKey + ' ' + fontSize + ' Tf ' + encodedColor ; return result ; }
3339	function ( grid ) { var me = this ; if ( grid . rendered ) { me . grid = grid ; grid . getView ( ) . on ( { render : function ( v ) { me . view = v ; Ext . ux . dd . CellFieldDropZone . superclass . constructor . call ( me , me . view . el ) ; } , single : true } ) ; } else { grid . on ( 'render' , me . init , me , { single : true } ) ; } }
402	function getStylesheets ( window , options ) { if ( Array . isArray ( options . media ) === false ) { options . media = [ options . media ] ; } const media = _ . union ( [ '' , 'all' , 'screen' ] , options . media ) ; const elements = window . document . querySelectorAll ( 'link[rel="stylesheet"]' ) ; return Array . prototype . map . call ( elements , ( link ) => ( { href : link . getAttribute ( 'href' ) , media : link . getAttribute ( 'media' ) || '' } ) ) . filter ( ( sheet ) => media . indexOf ( sheet . media ) !== - 1 ) . map ( ( sheet ) => sheet . href ) ; }
1642	function ( ) { var self = this ; console . log ( 'updating...' ) ; var req = get_req ( ) ; req . onreadystatechange = function update_state_response ( ) { if ( req . readyState === 4 ) { if ( req . status === 200 ) { var capture = JSON . parse ( req . responseText ) ; if ( capture . error ) { alert ( capture . error . message ) ; } htracr . ui . update ( capture ) ; console . log ( 'updated.' ) ; } else { console . log ( 'no updates.' ) ; } } } ; req . open ( "GET" , "/conns" , true ) ; req . send ( "" ) ; return false ; }
1120	function becomeMaster ( provider , bigIp , options ) { let hasUcs = false ; logger . info ( 'Becoming master.' ) ; logger . info ( 'Checking for backup UCS.' ) ; return provider . getStoredUcs ( ) . then ( ( response ) => { if ( response ) { hasUcs = true ; return loadUcs ( provider , bigIp , response , options . cloud ) ; } return q ( ) ; } ) . then ( ( ) => { if ( hasUcs ) { return initEncryption . call ( this , provider , bigIp ) ; } return q ( ) ; } ) . then ( ( ) => { return bigIp . list ( '/tm/sys/global-settings' ) ; } ) . then ( ( globalSettings ) => { const hostname = globalSettings ? globalSettings . hostname : undefined ; if ( hostname ) { this . instance . hostname = hostname ; } else { logger . debug ( 'hostname not found in this.instance or globalSettings' ) ; } return bigIp . list ( '/tm/sys/provision' ) ; } ) . then ( ( response ) => { const modulesProvisioned = { } ; if ( response && response . length > 0 ) { response . forEach ( ( module ) => { modulesProvisioned [ module . name ] = ! ( module . level === 'none' ) ; } ) ; } logger . info ( 'Creating device group.' ) ; const deviceGroupOptions = { autoSync : options . autoSync , saveOnAutoSync : options . saveOnAutoSync , fullLoadOnSync : options . fullLoadOnSync , asmSync : modulesProvisioned . asm || options . asmSync , networkFailover : options . networkFailover } ; return bigIp . cluster . createDeviceGroup ( options . deviceGroup , 'sync-failover' , [ this . instance . hostname ] , deviceGroupOptions ) ; } ) . then ( ( ) => { logger . info ( 'Writing master file.' ) ; return writeMasterFile ( hasUcs ) ; } ) ; }
3375	function ( ) { var f = [ ] , len , i ; this . filters . each ( function ( filter ) { if ( filter . active ) { f . push ( filter ) ; } } ) ; len = f . length ; return function ( record ) { for ( i = 0 ; i < len ; i ++ ) { if ( ! f [ i ] . validateRecord ( record ) ) { return false ; } } return true ; } ; }
2584	function advanceMonths ( d , monthsInTheFuture , adjustForWeekend ) { if ( ! ( d instanceof Date ) ) return d ; monthsInTheFuture = monthsInTheFuture && libs . generic . isNumeric ( monthsInTheFuture ) ? monthsInTheFuture : 1 ; d . setTime ( d . getTime ( ) + ( monthsInTheFuture * 2629746000 ) ) ; if ( adjustForWeekend && ( d . getDay ( ) === 0 || d . getDay ( ) === 6 ) ) { while ( d . getDay ( ) === 0 || d . getDay ( ) === 6 ) d . setTime ( d . getTime ( ) + 86400000 ) ; } return d ; }
1312	function Scheduler ( ) { this . queueCount = 0 ; this . holdCount = 0 ; this . blocks = new Array ( NUMBER_OF_IDS ) ; this . list = null ; this . currentTcb = null ; this . currentId = null ; }
3207	function ( autoRender , config ) { if ( ! tip ) { if ( ! Ext . isReady ) { Ext . onReady ( function ( ) { Ext . tip . QuickTipManager . init ( autoRender , config ) ; } ) ; return ; } var tipConfig = Ext . apply ( { disabled : disabled , id : 'ext-quicktips-tip' } , config ) , className = tipConfig . className , xtype = tipConfig . xtype ; if ( className ) { delete tipConfig . className ; } else if ( xtype ) { className = 'widget.' + xtype ; delete tipConfig . xtype ; } if ( autoRender !== false ) { tipConfig . renderTo = document . body ; if ( tipConfig . renderTo . tagName . toUpperCase ( ) != 'BODY' ) { Ext . Error . raise ( { sourceClass : 'Ext.tip.QuickTipManager' , sourceMethod : 'init' , msg : 'Cannot init QuickTipManager: no document body' } ) ; } } tip = Ext . create ( className || 'Ext.tip.QuickTip' , tipConfig ) ; Ext . quickTipsActive = true ; } }
3461	function ( ) { var me = this , actions = me . actions , namespace = me . namespace , action , cls , methods , i , len , method ; for ( action in actions ) { if ( actions . hasOwnProperty ( action ) ) { if ( me . disableNestedActions ) { cls = namespace [ action ] ; if ( ! cls ) { cls = namespace [ action ] = { } ; } } else { cls = me . getNamespace ( namespace , action ) ; if ( ! cls ) { cls = me . createNamespaces ( namespace , action ) ; } } methods = actions [ action ] ; for ( i = 0 , len = methods . length ; i < len ; ++ i ) { method = new Ext . direct . RemotingMethod ( methods [ i ] ) ; cls [ method . name ] = me . createHandler ( action , method ) ; } } } }
1238	function ( text , doubleQuote ) { if ( ! doubleQuote ) { return text . replace ( / \\['\\] / g , function ( seq ) { return specialChar [ seq ] ; } ) ; } return text . replace ( / \\[rntvef"'\\$] / g , function ( seq ) { return specialChar [ seq ] ; } ) ; }
1820	function buildSvg ( path , { size : { width , height } , VIEW_BOX } , pathOptions ) { const svgOptions = { viewBox : ` ${ VIEW_BOX } ${ VIEW_BOX } ` , 'shape-rendering' : 'optimizeSpeed' , } ; const svgOptionsStr = Object . entries ( svgOptions ) . map ( ( [ key , value ] ) => ` ${ key } ${ encodeURIComponent ( value ) } ` ) . join ( ' ' ) ; const pathOptionsStr = Object . entries ( pathOptions ) . map ( ( [ key , value ] ) => ` ${ key } ${ encodeURIComponent ( value ) } ` ) . join ( ' ' ) ; const svg = ` ${ width } ${ height } ${ svgOptionsStr } ${ pathOptionsStr } ${ path } ` ; const sprite = Sprite . fromImage ( ` ${ svg } ` ) ; sprite . _generatedSvgTexture = true ; return sprite ; }
2644	async function disposable ( ) { const name = "tmp" + Math . floor ( Math . random ( ) * 10000 ) ; await connection . dbCreate ( name ) . run ( ) ; const r = Object . create ( connection ) ; r . dispose = async function ( ) { await this . dbDrop ( name ) . run ( ) ; } ; r . _poolMaster . _options . db = name ; return r ; }
2339	function stopAll ( cb ) { if ( ! syncStarted ) { interceptors . restore ( ) ; dataHandlers . restore ( ) ; hashProvider . restore ( ) ; mongoDbClient = null ; redisClient = null ; metricsClient = null ; return cb ( ) ; } debug ( 'stopAll syncs' ) ; datasetClientCleaner . stop ( ) ; async . parallel ( [ async . apply ( syncStorage . updateManyDatasetClients , { } , { stopped : true } ) , async . apply ( stopAllWorkers , syncWorkers ) , async . apply ( stopAllWorkers , ackWorkers ) , async . apply ( stopAllWorkers , pendingWorkers ) , async . apply ( syncScheduler . stop . bind ( syncScheduler ) ) ] , function ( err ) { if ( err ) { debugError ( 'Failed to stop sync due to error : %s' , err ) ; return cb ( err ) ; } setConfig ( ) ; interceptors . restore ( ) ; dataHandlers . restore ( ) ; hashProvider . restore ( ) ; mongoDbClient = null ; redisClient = null ; metricsClient = null ; ackQueue = null ; pendingQueue = null ; syncQueue = null ; ackWorkers = [ ] ; pendingWorkers = [ ] ; syncWorkers = [ ] ; syncStarted = false ; syncLock = null ; datasetClientCleaner = null ; module . exports . api . start = async . memoize ( start ) ; return cb ( ) ; } ) ; }
3292	function whip ( gulp , taste , opts ) { opts = getOptions ( opts ) ; opts . taste = taste ; var tasks = _ . extend ( { } , opts . tasksets ) ; _ . each ( getPlugins ( opts ) , function ( plugin ) { var pluginRoot = plugin . rootDir ; var pluginBuildDir = pluginRoot + delim + 'build' ; if ( fs . existsSync ( pluginBuildDir ) ) { _ . each ( fs . readdirSync ( pluginBuildDir ) , function ( pluginFile ) { var taskName , task ; if ( taskRegex . test ( pluginFile ) ) { taskName = pluginFile . match ( taskRegex ) [ 1 ] ; task = require ( pluginBuildDir + delim + pluginFile ) ( gulp , opts ) ; if ( _ . isFunction ( task ) || ( task . deps && task . task ) ) { tasks [ taskName ] = task ; } else if ( _ . isObject ( task ) ) { _ . each ( task , function ( subtask , subtaskName ) { var fullTaskName = subtaskName === '' ? taskName : taskName + '.' + subtaskName ; tasks [ fullTaskName ] = subtask ; } ) ; } else { throw new Error ( pluginBuildDir + delim + pluginFile + ' is invalid' ) ; } } } ) ; } } ) ; _ . each ( tasks , function ( task , taskName ) { if ( _ . isFunction ( task ) || _ . isArray ( task ) ) { gulp . task ( taskName , task ) ; } else if ( task . deps && task . task ) { gulp . task ( taskName , task . deps , task . task ) ; } else { throw new Error ( 'Invalid task for ' + taskName ) ; } } ) ; }
1509	function oidArray ( oid ) { var bytes , i , val ; if ( oid . length < 2 ) { throw new Error ( "Minimum OID length is two." ) ; } else if ( oid [ 0 ] > 2 ) { throw new Error ( "Invalid OID" ) ; } else if ( oid [ 0 ] == 0 && oid [ 1 ] > 39 ) { throw new Error ( "Invalid OID" ) ; } else if ( oid [ 0 ] == 1 && oid [ 1 ] > 39 ) { throw new Error ( "Invalid OID" ) ; } else if ( oid [ 0 ] == 2 && oid [ 1 ] > 79 ) { throw new Error ( "Invalid OID" ) ; } bytes = [ 40 * oid [ 0 ] + oid [ 1 ] ] ; for ( i = 2 ; i < oid . length ; i ++ ) { val = oid [ i ] ; if ( val > 127 ) { bytes = bytes . concat ( oidInt ( val ) ) ; } else { bytes . push ( val ) ; } } return bytes ; }
2638	function ( fPath , strict , fn ) { if ( typeof ( strict ) === 'function' ) { fn = strict ; strict = false ; } var dir = path . dirname ( fPath ) ; var base = path . basename ( fPath ) ; if ( typeof watched === 'undefined' ) { return fn && fn ( '[checkFile] watched array not properly defined.' ) ; } else { fs . stat ( fPath , function onStat ( err , stats ) { if ( err ) { return fn && fn ( null , false ) ; } if ( typeof watched [ dir ] === 'undefined' || typeof watched [ dir ] . files === 'undefined' ) { return fn && fn ( null , false ) ; } if ( strict ) { return fn && fn ( null , watched [ dir ] . files [ base ] === stats . mtime . valueOf ( ) ) ; } else { return fn && fn ( null , typeof watched [ dir ] . files [ base ] !== 'undefined' ) ; } } ) ; } }
572	function ( a , b ) { if ( a . prev === null ) { this . head = b . next ; } else { a . prev . next = b . next ; } if ( b . next === null ) { this . tail = a . prev ; } else { b . next . prev = a . prev ; } return this ; }
3025	function onSelection ( ev ) { if ( ev ) { ev . stopPropagation ( ) ; ev . stopImmediatePropagation ( ) ; ev . preventDefault ( ) ; } setTimeout ( function ( ) { if ( window . getSelection ) { if ( window . getSelection ( ) . empty ) { window . getSelection ( ) . empty ( ) ; } else if ( window . getSelection ( ) . removeAllRanges ) { window . getSelection ( ) . removeAllRanges ( ) ; } } else if ( document . selection ) { document . selection . empty ( ) ; } } ) ; return false ; }
1132	function forceResetUserPassword ( user ) { const deferred = q . defer ( ) ; cryptoUtil . generateRandomBytes ( 24 , 'hex' ) . then ( ( randomBytes ) => { util . runShellCommand ( ` ${ randomBytes } \n ${ randomBytes } ${ user } ` ) ; deferred . resolve ( randomBytes ) ; } ) . catch ( ( err ) => { deferred . reject ( err ) ; } ) ; return deferred . promise ; }
384	function queryAll ( node , predicate , matches , getChildNodes ) { if ( getChildNodes === void 0 ) { getChildNodes = module . exports . defaultChildNodes ; } var elementPredicate = AND ( isElement , predicate ) ; return nodeWalkAll ( node , elementPredicate , matches , getChildNodes ) ; }
3750	function genEntityDescription ( data , kind , entityName ) { return data ( { kind : kind , name : entityName } ) . select ( 'description' ) . join ( '\n\n' ) ; }
722	function ( p ) { var dx = p . x - this . x , dy = p . y - this . y ; return dx * dx + dy * dy ; }
1936	function textualDirection ( direction ) { var angle = parseFloat ( direction ) ; if ( ! _ . isNaN ( angle ) ) { switch ( angle % 360 ) { case 0 : return 'left' ; case 90 : return 'bottom' ; case 180 : return 'right' ; case 240 : return 'top' ; } } return direction ; }
3393	function ( ) { var scriptTag = document . createElement ( 'script' ) ; scriptTag . type = 'text/vbscript' ; scriptTag . text = [ 'Function getIEByteArray(byteArray, out)' , 'Dim len, i' , 'len = LenB(byteArray)' , 'For i = 1 to len' , 'out.push(AscB(MidB(byteArray, i, 1)))' , 'Next' , 'End Function' ] . join ( '\n' ) ; \n Ext . getHead ( ) . dom . appendChild ( scriptTag ) ; }
404	function openDB ( name , version , { blocked , upgrade , blocking } = { } ) { const request = indexedDB . open ( name , version ) ; const openPromise = wrap ( request ) ; if ( upgrade ) { request . addEventListener ( 'upgradeneeded' , ( event ) => { upgrade ( wrap ( request . result ) , event . oldVersion , event . newVersion , wrap ( request . transaction ) ) ; } ) ; } if ( blocked ) request . addEventListener ( 'blocked' , ( ) => blocked ( ) ) ; if ( blocking ) openPromise . then ( db => db . addEventListener ( 'versionchange' , blocking ) ) ; return openPromise ; }
2286	function getFlickrCacheJson ( photoId ) { if ( ! enabledCache ) return null ; var d = new Date ( ) ; for ( var i = 0 ; i < cacheJson . length ; i ++ ) { if ( cacheJson [ i ] . fl . photo . id == photoId ) { if ( cacheJson [ i ] . expires > d . getTime ( ) ) { return cacheJson [ i ] . fl ; } break ; } } return null ; }
639	function paragraphHasNoText ( text ) { text = removeLinksFromText ( text ) ; if ( text === "" ) { return true ; } text = removeImagesFromText ( text ) ; if ( text === "" ) { return true ; } const emptyDivisions = findEmptyDivisions ( text ) ; if ( emptyDivisions . length < 1 ) { return false ; } emptyDivisions . forEach ( function ( emptyDivision ) { text = text . replace ( emptyDivision , "" ) ; } ) ; return text === "" ; }
249	function insertCountryAliases ( data ) { Object . keys ( aliases ) . forEach ( source => { data [ source ] = data [ aliases [ source ] ] ; } ) ; return data ; }
3610	function DrawtextCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 3 ) throw new SyntaxError ( 'DRAWTEXT command requires 3 arguments' ) ; else if ( parsed . args . length > 3 && parsed . args . length < 5 ) throw new SyntaxError ( 'DRAWTEXT command requires 5 arguments' ) ; this . text = parsed . args [ 0 ] ; this . x1 = parsed . args [ 1 ] ; this . y1 = parsed . args [ 2 ] ; if ( parsed . args . length > 3 ) { this . x2 = parsed . args [ 3 ] ; this . y2 = parsed . args [ 4 ] ; } else { this . x2 = false ; this . y2 = false ; } }
861	function get ( option ) { if ( option && option . tryExtensions && Array . isArray ( option . tryExtensions ) ) { return option . tryExtensions . map ( String ) } return null }
2289	function LeipzigEvent ( name , data ) { var leipzigEvent = undefined ; if ( window . CustomEvent ) { leipzigEvent = new CustomEvent ( name , { detail : data , bubbles : true , cancelable : true } ) ; } else { leipzigEvent = document . createEvent ( 'CustomEvent' ) ; leipzigEvent . initCustomEvent ( name , true , true , data ) ; } return leipzigEvent ; }
2243	function findRecorder ( div , selector ) { if ( ! div ) { if ( ! RecordingContext . recorders ) { throw 'You must call RecordingContext.recordAll() before using other RecordingContext static methods' ; } else if ( RecordingContext . recorders . length == 0 ) { throw 'Called a RecordingContext method, but no canvases are being recorded.' ; } else if ( RecordingContext . recorders . length > 1 ) { throw 'Called a RecordingContext method while multiple canvases were being recorded. Specify one using a div and selector.' ; } else { return RecordingContext . recorders [ 0 ] [ 1 ] ; } } else { return RecordingContext . recorderForSelector ( div , selector ) ; } }
804	function writeElements ( res , elements ) { var start = RLS ( ) . nextElement || ( RLS ( ) . nextElement = 0 ) ; for ( var i = start ; i < elements . length ; RLS ( ) . nextElement = ++ i ) { if ( elements [ i ] === ELEMENT_PENDING ) break ; writeElement ( res , elements [ i ] , i ) ; elements [ i ] = ELEMENT_ALREADY_WRITTEN ; if ( PageUtil . PageConfig . get ( 'isFragment' ) ) continue ; if ( RLS ( ) . haveBootstrapped ) { wakeElementRange ( res , i , i ) ; } else if ( i === elements . length - 1 ) { bootstrapClient ( res , i ) ; } } if ( i !== start ) flushRes ( res ) ; }
363	function getBoundingClientRect ( element ) { var rect = { } ; try { if ( isIE ( 10 ) ) { rect = element . getBoundingClientRect ( ) ; var scrollTop = getScroll ( element , 'top' ) ; var scrollLeft = getScroll ( element , 'left' ) ; rect . top += scrollTop ; rect . left += scrollLeft ; rect . bottom += scrollTop ; rect . right += scrollLeft ; } else { rect = element . getBoundingClientRect ( ) ; } } catch ( e ) { } var result = { left : rect . left , top : rect . top , width : rect . right - rect . left , height : rect . bottom - rect . top } ; var sizes = element . nodeName === 'HTML' ? getWindowSizes ( element . ownerDocument ) : { } ; var width = sizes . width || element . clientWidth || result . right - result . left ; var height = sizes . height || element . clientHeight || result . bottom - result . top ; var horizScrollbar = element . offsetWidth - width ; var vertScrollbar = element . offsetHeight - height ; if ( horizScrollbar || vertScrollbar ) { var styles = getStyleComputedProperty ( element ) ; horizScrollbar -= getBordersSize ( styles , 'x' ) ; vertScrollbar -= getBordersSize ( styles , 'y' ) ; result . width -= horizScrollbar ; result . height -= vertScrollbar ; } return getClientRect ( result ) ; }
3589	function KJU ( configuration ) { var self = this , option ; this . limit = 500 ; this . ms = 100 ; this . interval = 15000 ; this . warnings = true ; this . enabled = true ; this . recover = true ; this . dump = true ; this . path = process . cwd ( ) + '/' ; this . name = 'node_kju_backup.{sequence}.kju' ; for ( option in configuration ) this [ option ] = configuration [ option ] ; this . buffer = [ ] ; this . length = 0 ; this . drained = 0 ; this . processed = 0 ; this . since = Date . now ( ) ; this . minimum = this . interval / 2 ; this . maximum = this . interval * 2 ; EventEmitter2 . call ( this , { wildcard : true } ) ; if ( this . recover ) this . recovery ( ) ; if ( this . enabled ) this . enable ( ) ; fsExists ( this . path , function existing ( exists ) { if ( ! exists ) { return self . emit ( 'error' , new Error ( self . path + ' does not exist.' ) ) ; } if ( self . path [ self . path . length - 1 ] !== '/' ) { return self . emit ( 'error' , new Error ( self . path + ' should end with a slash' ) ) ; } } ) ; }
869	function validateRegExp ( pattern , flags , node ) { if ( typeof pattern === "string" ) { if ( hasPattern ( pattern , REGEXP_NAMED_GROUP ) ) { report ( node , "regexpNamedCaptureGroups" ) } if ( hasPattern ( pattern , REGEXP_LOOKBEHIND ) ) { report ( node , "regexpLookbehind" ) } if ( hasPattern ( pattern , REGEXP_UNICODE_PROPERTY ) ) { report ( node , "regexpUnicodeProperties" ) } } if ( typeof flags === "string" ) { if ( flags . indexOf ( "y" ) !== - 1 ) { report ( node , "regexpY" ) } if ( flags . indexOf ( "u" ) !== - 1 ) { report ( node , "regexpU" ) } if ( flags . indexOf ( "s" ) !== - 1 ) { report ( node , "regexpS" ) } } }
3235	function init ( ) { tinyMCEPopup . resizeToInnerSize ( ) ; var inst = tinyMCEPopup . editor ; var dom = inst . dom ; var elm = inst . selection . getNode ( ) ; var f = document . forms [ 0 ] ; var onclick = dom . getAttrib ( elm , 'onclick' ) ; setFormValue ( 'title' , dom . getAttrib ( elm , 'title' ) ) ; setFormValue ( 'id' , dom . getAttrib ( elm , 'id' ) ) ; setFormValue ( 'style' , dom . getAttrib ( elm , "style" ) ) ; setFormValue ( 'dir' , dom . getAttrib ( elm , 'dir' ) ) ; setFormValue ( 'lang' , dom . getAttrib ( elm , 'lang' ) ) ; setFormValue ( 'tabindex' , dom . getAttrib ( elm , 'tabindex' , typeof ( elm . tabindex ) != "undefined" ? elm . tabindex : "" ) ) ; setFormValue ( 'accesskey' , dom . getAttrib ( elm , 'accesskey' , typeof ( elm . accesskey ) != "undefined" ? elm . accesskey : "" ) ) ; setFormValue ( 'onfocus' , dom . getAttrib ( elm , 'onfocus' ) ) ; setFormValue ( 'onblur' , dom . getAttrib ( elm , 'onblur' ) ) ; setFormValue ( 'onclick' , onclick ) ; setFormValue ( 'ondblclick' , dom . getAttrib ( elm , 'ondblclick' ) ) ; setFormValue ( 'onmousedown' , dom . getAttrib ( elm , 'onmousedown' ) ) ; setFormValue ( 'onmouseup' , dom . getAttrib ( elm , 'onmouseup' ) ) ; setFormValue ( 'onmouseover' , dom . getAttrib ( elm , 'onmouseover' ) ) ; setFormValue ( 'onmousemove' , dom . getAttrib ( elm , 'onmousemove' ) ) ; setFormValue ( 'onmouseout' , dom . getAttrib ( elm , 'onmouseout' ) ) ; setFormValue ( 'onkeypress' , dom . getAttrib ( elm , 'onkeypress' ) ) ; setFormValue ( 'onkeydown' , dom . getAttrib ( elm , 'onkeydown' ) ) ; setFormValue ( 'onkeyup' , dom . getAttrib ( elm , 'onkeyup' ) ) ; className = dom . getAttrib ( elm , 'class' ) ; addClassesToList ( 'classlist' , 'advlink_styles' ) ; selectByValue ( f , 'classlist' , className , true ) ; TinyMCE_EditableSelects . init ( ) ; }
78	function formatTime ( ) { var time = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : 0 ; var displayHours = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; var inverted = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : false ; if ( ! is$1 . number ( time ) ) { return formatTime ( null , displayHours , inverted ) ; } var format = function format ( value ) { return "0" . concat ( value ) . slice ( - 2 ) ; } ; var hours = getHours ( time ) ; var mins = getMinutes ( time ) ; var secs = getSeconds ( time ) ; if ( displayHours || hours > 0 ) { hours = "" . concat ( hours , ":" ) ; } else { hours = '' ; } return "" . concat ( inverted && time > 0 ? '-' : '' ) . concat ( hours ) . concat ( format ( mins ) , ":" ) . concat ( format ( secs ) ) ; }
3391	function ( status ) { status = status == 1223 ? 204 : status ; var success = ( status >= 200 && status < 300 ) || status == 304 , isException = false ; if ( ! success ) { switch ( status ) { case 12002 : case 12029 : case 12030 : case 12031 : case 12152 : case 13030 : isException = true ; break ; } } return { success : success , isException : isException } ; }
1996	function CucumberReporter ( eventMediator ) { var options = { snippets : true , stream : process . stdout , useColors : true } ; this . failureCount = 0 ; this . eventMediator = eventMediator ; this . formatter = DotFormatter ( options ) ; this . eventMediator . on ( 'end' , this . allFeaturesDone . bind ( this ) ) ; }
2740	function ifStatusOk ( response , fulfill , reject ) { var responseCode = response . code ; if ( isClientError ( responseCode ) ) { reject ( { name : "ClientErrorException" , message : response . body } ) ; } else if ( isServerError ( responseCode ) ) { reject ( { name : "ServerErrorException" , message : response . error } ) ; } else if ( isOtherErrorResponse ( responseCode ) ) { reject ( { name : "OtherCommunicationException" , message : response . error } ) ; } else { fulfill ( response . body ) } }
3302	function ( store , columns ) { var me = this , oldStore = me . store , lockedGrid = me . lockedGrid , normalGrid = me . normalGrid ; Ext . suspendLayouts ( ) ; if ( columns ) { lockedGrid . headerCt . removeAll ( ) ; normalGrid . headerCt . removeAll ( ) ; columns = me . processColumns ( columns ) ; me . ignoreAddLockedColumn = true ; lockedGrid . headerCt . add ( columns . locked . items ) ; me . ignoreAddLockedColumn = false ; normalGrid . headerCt . add ( columns . normal . items ) ; me . syncLockedWidth ( ) ; } if ( store && store !== oldStore ) { store = Ext . data . StoreManager . lookup ( store ) ; me . store = store ; lockedGrid . bindStore ( store ) ; normalGrid . bindStore ( store ) ; } else { lockedGrid . getView ( ) . refresh ( ) ; normalGrid . getView ( ) . refresh ( ) ; } Ext . resumeLayouts ( true ) ; }
1382	function deferred ( ) { var outResolve = function ( ) { } ; var outReject = function ( ) { } ; var promise = new Promise ( function ( resolve , reject ) { outResolve = resolve ; outReject = reject ; } ) ; return { promise : promise , resolve : outResolve , reject : outReject , } ; }
2333	function removePendingChanges ( clientRecords , localDatasetClient , pendingChanges ) { _ . each ( pendingChanges , function ( pendingChange , uid ) { if ( clientRecords [ uid ] ) { delete clientRecords [ uid ] ; } if ( localDatasetClient [ uid ] ) { delete localDatasetClient [ uid ] ; } } ) ; }
2900	function ( connectionName , table , attrName , attrDef , cb ) { var connectionObject = connections [ connectionName ] ; if ( LOG_DEBUG ) { console . log ( "BEGIN addAttribute" ) ; } table = utils . escapeName ( table ) ; var attrs = { } ; attrs [ attrName ] = attrDef ; var _schema = utils . buildSchema ( attrs ) ; var query = 'ALTER TABLE ' + table + ' ADD COLUMN ' + _schema ; connectionObject . pool . getConnection ( function ( err , connection ) { if ( err ) { handleQueryError ( err , 'addAttribute' ) ; return ; } if ( LOG_QUERIES ) { console . log ( 'Executing query: ' + query ) ; } connection . execute ( query , { } , { outFormat : oracledb . OBJECT } , function __ADD_ATTRIBUTE__ ( err , result ) { doRelease ( connection ) ; if ( err ) return cb ( handleQueryError ( err , 'addAttribute' ) ) ; cb ( null , result . rows ) ; } ) ; } ) ; }
757	function ( dygraph ) { this . dygraph_ = dygraph ; this . points = [ ] ; this . setNames = [ ] ; this . annotations = [ ] ; this . yAxes_ = null ; this . xTicks_ = null ; this . yTicks_ = null ; }
1722	function _updateState ( ) { var prevItem ; var invalidated = false ; var hiddenViewCount = 0 ; var i = 0 ; while ( i < this . _viewStack . length ) { if ( this . _viewStack [ i ] . state === ItemState . HIDDEN ) { hiddenViewCount ++ ; for ( var j = 0 ; j < this . _viewStack . length ; j ++ ) { if ( ( this . _viewStack [ j ] . state !== ItemState . HIDDEN ) && ( this . _viewStack [ j ] . view === this . _viewStack [ i ] . view ) ) { this . _viewStack [ i ] . view = undefined ; this . _renderables . views . splice ( i , 1 ) ; this . _viewStack . splice ( i , 1 ) ; i -- ; hiddenViewCount -- ; break ; } } } i ++ ; } while ( hiddenViewCount > this . options . keepHiddenViewsInDOMCount ) { this . _viewStack [ 0 ] . view = undefined ; this . _renderables . views . splice ( 0 , 1 ) ; this . _viewStack . splice ( 0 , 1 ) ; hiddenViewCount -- ; } for ( i = hiddenViewCount ; i < ( Math . min ( this . _viewStack . length - hiddenViewCount , 2 ) + hiddenViewCount ) ; i ++ ) { var item = this . _viewStack [ i ] ; if ( item . state === ItemState . QUEUED ) { if ( ! prevItem || ( prevItem . state === ItemState . VISIBLE ) || ( prevItem . state === ItemState . HIDING ) ) { if ( prevItem && ( prevItem . state === ItemState . VISIBLE ) ) { prevItem . state = ItemState . HIDE ; prevItem . wait = item . wait ; } item . state = ItemState . SHOW ; invalidated = true ; } break ; } else if ( ( item . state === ItemState . VISIBLE ) && item . hide ) { item . state = ItemState . HIDE ; } if ( ( item . state === ItemState . SHOW ) || ( item . state === ItemState . HIDE ) ) { this . layout . reflowLayout ( ) ; } prevItem = item ; } if ( invalidated ) { _updateState . call ( this ) ; this . layout . reflowLayout ( ) ; } }
3481	function moveToCaretPosition ( root ) { var walker , node , rng , y , viewPort , lastNode = root , tempElm ; rng = dom . createRng ( ) ; if ( root . hasChildNodes ( ) ) { walker = new TreeWalker ( root , root ) ; while ( node = walker . current ( ) ) { if ( node . nodeType == 3 ) { rng . setStart ( node , 0 ) ; rng . setEnd ( node , 0 ) ; break ; } if ( nonEmptyElementsMap [ node . nodeName . toLowerCase ( ) ] ) { rng . setStartBefore ( node ) ; rng . setEndBefore ( node ) ; break ; } lastNode = node ; node = walker . next ( ) ; } if ( ! node ) { rng . setStart ( lastNode , 0 ) ; rng . setEnd ( lastNode , 0 ) ; } } else { if ( root . nodeName == 'BR' ) { if ( root . nextSibling && dom . isBlock ( root . nextSibling ) ) { if ( ! documentMode || documentMode < 9 ) { tempElm = dom . create ( 'br' ) ; root . parentNode . insertBefore ( tempElm , root ) ; } rng . setStartBefore ( root ) ; rng . setEndBefore ( root ) ; } else { rng . setStartAfter ( root ) ; rng . setEndAfter ( root ) ; } } else { rng . setStart ( root , 0 ) ; rng . setEnd ( root , 0 ) ; } } selection . setRng ( rng ) ; dom . remove ( tempElm ) ; viewPort = dom . getViewPort ( editor . getWin ( ) ) ; y = dom . getPos ( root ) . y ; if ( y < viewPort . y || y + 25 > viewPort . y + viewPort . h ) { editor . getWin ( ) . scrollTo ( 0 , y < viewPort . y ? y : y - viewPort . h + 25 ) ; } }
3213	function ( ) { var astNode = "" ; if ( this . currentToken . type == 'word' || this . currentToken . type == 'string' ) { astNode = this . currentToken . value ; this . readNextToken ( ) ; } else if ( this . currentToken . type == 'group' ) { this . readNextToken ( ) ; astNode = this . parseExpressionsRecursively ( ) ; this . readNextToken ( ) ; } return astNode ; }
293	function ( options = { } ) { const { search , page , number } = options ; const query = { action : 'query_themes' , 'request[fields][extended_author]' : true , 'request[search]' : search , 'request[page]' : page , 'request[per_page]:' : number , } ; return superagent . get ( WPORG_THEMES_ENDPOINT ) . set ( 'Accept' , 'application/json' ) . query ( query ) . then ( ( { body } ) => body ) ; }
2656	function smsUpdatePhonesVariables ( callback , addressbook_id , phones , variables ) { if ( addressbook_id === undefined ) { return callback ( returnError ( "Empty book id" ) ) ; } if ( ( phones === undefined ) || ( ! phones . length ) ) { return callback ( returnError ( "Empty phones" ) ) ; } if ( ( variables === undefined ) || ( ! Object . keys ( variables ) . length ) ) { return callback ( returnError ( "Empty variables" ) ) ; } var data = { 'addressBookId' : addressbook_id , 'phones' : JSON . stringify ( phones ) , 'variables' : JSON . stringify ( variables ) } sendRequest ( 'sms/numbers' , 'PUT' , data , true , callback ) ; }
3591	function read ( file , index , files ) { fs . readFile ( self . path + file , function readFile ( err , contents ) { if ( err ) return done ( ) , self . emit ( 'error' , err ) ; try { var todo = JSON . parse ( contents . toString ( 'utf8' ) ) ; self . push . apply ( self , todo ) ; fs . unlink ( self . path + file , function ignore ( err ) { } ) ; } catch ( e ) { self . emit ( 'error' , new Error ( 'Corrupted file, unable to parse contents of ' + file ) ) ; } done ( ) ; } ) ; }
1620	function parse_scan_results ( block ) { var match ; var results = [ ] ; var lines ; lines = block . split ( '\n' ) . \n map ; ( function ( item ) { return item + "\n" ; } ) \n }
2973	function userFromToken ( req , cb ) { const { accessToken } = req ; app . models . zlUser . findById ( accessToken . userId , ( err , usr ) => { if ( ! err && usr ) { cb ( null , usr ) ; } else cb ( err ) ; } ) ; }
3035	function ( state ) { var me = this ; if ( me . readyState != state ) { me . readyState = state ; me . onreadystatechange ( ) ; } }
3451	function ( e , target ) { var me = this , item , record ; if ( Ext . fly ( target ) . hasCls ( me . labelSelector ) && ! me . editing && ! e . ctrlKey && ! e . shiftKey ) { e . stopEvent ( ) ; item = me . view . findItemByChild ( target ) ; record = me . view . store . getAt ( me . view . indexOf ( item ) ) ; me . startEdit ( target , record . data [ me . dataIndex ] ) ; me . activeRecord = record ; } else if ( me . editing ) { me . field . blur ( ) ; e . preventDefault ( ) ; } }
1041	function getTimeFromURL ( url ) { if ( url === void 0 ) url = '' ; var times = url . match ( timeRegexp ) ; if ( ! times ) { return 0 } var full = times [ 0 ] ; var minutes = times [ 1 ] ; var seconds = times [ 2 ] ; if ( typeof seconds !== 'undefined' ) { seconds = parseInt ( seconds , 10 ) ; minutes = parseInt ( minutes , 10 ) ; } else if ( full . includes ( 'm' ) ) { minutes = parseInt ( minutes , 10 ) ; seconds = 0 ; } else { seconds = parseInt ( minutes , 10 ) ; minutes = 0 ; } return seconds + ( minutes * 60 ) }
3000	function addProps ( obj ) { var rest = [ ] ; for ( var _i = 1 ; _i < arguments . length ; _i ++ ) { rest [ _i - 1 ] = arguments [ _i ] ; } for ( var i = 0 , n = rest . length ; i < n ; i += 2 ) { if ( illa . isString ( rest [ i ] ) ) { obj [ rest [ i ] ] = rest [ i + 1 ] ; } } return obj ; }
2048	function ( app , callback ) { var appPath = pathExtra . resolve ( npmHelpers . initialWd , app ) ; var manifestPath = pathExtra . join ( appPath , 'package.json' ) ; if ( fs . existsSync ( appPath ) && fs . existsSync ( manifestPath ) ) { fs . readFile ( manifestPath , function checkError ( err , manifest ) { if ( err ) { logger . error ( err ) ; nodeHelpers . invoke ( callback , err ) ; } else { nodeHelpers . invoke ( callback , err , JSON . parse ( manifest ) , 'file' ) ; } } ) ; } else { var client = request . newClient ( 'https://raw.githubusercontent.com/' ) ; if ( app . indexOf ( '@' ) > 1 ) { var manifestUrl = app . split ( '@' ) [ 0 ] + '/' + app . split ( '@' ) [ 1 ] + '/package.json' ; } else { var manifestUrl = app + '/master/package.json' ; } console . log ( manifestUrl ) ; client . get ( manifestUrl , function ( err , res , manifest ) { if ( err ) { logger . error ( err ) ; nodeHelpers . invoke ( callback , err ) ; } else if ( res . statusCode !== 200 ) { logger . error ( err ) ; nodeHelpers . invoke ( callback , err ) ; } else { nodeHelpers . invoke ( callback , err , manifest , 'url' ) ; } } ) ; } }
1870	function ( ) { var res = require ( 'resources' ) ; if ( ! res ) { return '\n' ; } \n var nl = res . getVariable ( 'newline' ) ; }
808	function writeClientBootstrapFile ( outputDir , opts ) { const outputFile = outputDir + "/entry.js" ; fs . writeFileSync ( outputFile , ` ${ JSON . stringify ( opts . logLevel ) } ${ JSON . stringify ( opts . timingLogLevel ) } ${ JSON . stringify ( opts . gaugeLogLevel ) } ` ) ; return outputFile ; }
140	function embed ( editor ) { let embedDialogContainer ; const render = ( visible = true ) => { const selectedEmbedNode = editor . selection . getNode ( ) ; const store = editor . getParam ( 'redux_store' ) ; const embedDialogProps = { embedUrl : selectedEmbedNode . innerText || selectedEmbedNode . textContent , isVisible : visible , onCancel : ( ) => render ( false ) , onUpdate : newUrl => { editor . execCommand ( 'mceInsertContent' , false , newUrl ) ; render ( false ) ; } , } ; renderWithReduxStore ( React . createElement ( EmbedDialog , embedDialogProps ) , embedDialogContainer , store ) ; if ( ! visible ) { editor . focus ( ) ; } } ; editor . addCommand ( 'embedDialog' , ( ) => render ( ) ) ; editor . on ( 'init' , ( ) => { embedDialogContainer = editor . getContainer ( ) . appendChild ( document . createElement ( 'div' ) ) ; } ) ; editor . on ( 'remove' , ( ) => { ReactDom . unmountComponentAtNode ( embedDialogContainer ) ; embedDialogContainer . parentNode . removeChild ( embedDialogContainer ) ; embedDialogContainer = null ; } ) ; }
1575	function getTemplatePath ( folder , type ) { switch ( type ) { case 'product' : return path . join ( folder , 'product.html' ) case 'company' : return path . join ( folder , 'company.html' ) } }
3855	function ( section ) { section . children . forEach ( function ( child ) { if ( child . type === 'section' ) { finalParse ( child ) } else if ( child . type === 'text' || child . type === 'value' || child . type === 'code' ) { var sliceStart = child . line - 1 , sliceEnd = child . line + child . size - 1 , subLines = lines . slice ( sliceStart , sliceEnd ) if ( child . type === 'text' ) { child . content = subLines . join ( '\n' ) } else \n } } ) }
3437	function ( array ) { var len = arguments . length , i = 1 , newItem ; if ( array === undefined ) { array = [ ] ; } else if ( ! Ext . isArray ( array ) ) { array = [ array ] ; } for ( ; i < len ; i ++ ) { newItem = arguments [ i ] ; Array . prototype . push [ Ext . isIterable ( newItem ) ? 'apply' : 'call' ] ( array , newItem ) ; } return array ; }
2007	function SizeWatcher ( element , options ) { this . _element = element ; this . _delegate = options . delegate ; this . _size = null ; this . _continuous = ! ! options . continuous ; this . _direction = options . direction ? options . direction : SizeWatcher . directions . both ; this . _dimension = options . dimension ? options . dimension : SizeWatcher . dimensions . both ; this . _sizeIncreaseWatcherContentElm = null ; this . _sizeDecreaseWatcherElm = null ; this . _sizeIncreaseWatcherElm = null ; this . _state = SizeWatcher . states . initialized ; this . _generateScrollWatchers ( options . size ) ; this . _appendScrollWatchersToElement ( options . container ) ; }
2401	function parse ( report ) { var rows = [ '' ] ; var crash = report [ 'crash' ] || { } ; var error = crash [ 'error' ] ; var type = error [ 'type' ] ; var reason = error [ 'reason' ] ; var user_exception = error [ 'user_reported' ] ; var ns_exception = error [ 'nsexception' ] ; if ( ns_exception ) { rows . push ( format ( ns_exception ) ) ; rows . push ( '' ) ; return rows ; } if ( zombie_exception ( report ) ) { var last_exception = Utils . get_last_exception ( report ) ; if ( last_exception ) { rows . push ( format ( last_exception , reason ) ) ; rows . push ( 'NOTE: This exception has been deallocated! ' + 'Stack trace is crash from attempting to access this zombie exception.' ) ; rows . push ( '' ) ; } return rows ; } if ( user_exception ) { rows . push ( format ( user_exception , reason ) ) ; var line = user_exception [ 'line_of_code' ] ; var back = user_exception [ 'backtrace' ] || [ ] ; if ( line || back ) { rows . push ( 'Custom Backtrace:' ) ; } if ( line ) { rows . push ( ` ${ line } ` ) ; } return rows . concat ( back ) ; } if ( type == 'cpp_exception' ) { return rows . concat ( format ( error [ 'cppexception' ] , reason ) ) ; } if ( type == 'deadlock' ) { rows . push ( 'Application main thread deadlocked' ) ; rows . push ( '' ) ; } return rows ; }
2404	function rgbToHex ( rgb ) { function componentToHex ( c ) { var hex = c . toString ( 16 ) . toUpperCase ( ) ; return hex . length === 1 ? "0" + hex : hex ; } var color = rgb . map ( function ( component ) { return componentToHex ( parseInt ( component * 255 ) ) ; } ) ; color . unshift ( "0X" ) ; color = color . join ( "" ) ; return parseInt ( color ) ; }
1281	function fromLDMLString ( ldmlString ) { ldmlString = InternalRegExpReplace ( GetQuotedStringRE ( ) , ldmlString , '' ) ; var options = { } ; var match = InternalRegExpMatch ( / E{3,5} / , ldmlString ) ; options = appendToDateTimeObject ( options , 'weekday' , match , { EEEEE : 'narrow' , EEE : 'short' , EEEE : 'long' } ) ; match = InternalRegExpMatch ( / G{3,5} / , ldmlString ) ; options = appendToDateTimeObject ( options , 'era' , match , { GGGGG : 'narrow' , GGG : 'short' , GGGG : 'long' } ) ; match = InternalRegExpMatch ( / y{1,2} / , ldmlString ) ; options = appendToDateTimeObject ( options , 'year' , match , { y : 'numeric' , yy : '2-digit' } ) ; match = InternalRegExpMatch ( / M{1,5} / , ldmlString ) ; options = appendToDateTimeObject ( options , 'month' , match , { MM : '2-digit' , M : 'numeric' , MMMMM : 'narrow' , MMM : 'short' , MMMM : 'long' } ) ; match = InternalRegExpMatch ( / L{1,5} / , ldmlString ) ; options = appendToDateTimeObject ( options , 'month' , match , { LL : '2-digit' , L : 'numeric' , LLLLL : 'narrow' , LLL : 'short' , LLLL : 'long' } ) ; match = InternalRegExpMatch ( / d{1,2} / , ldmlString ) ; options = appendToDateTimeObject ( options , 'day' , match , { d : 'numeric' , dd : '2-digit' } ) ; match = InternalRegExpMatch ( / h{1,2} / , ldmlString ) ; if ( match !== null ) { options [ 'hour12' ] = true ; } options = appendToDateTimeObject ( options , 'hour' , match , { h : 'numeric' , hh : '2-digit' } ) ; match = InternalRegExpMatch ( / H{1,2} / , ldmlString ) ; if ( match !== null ) { options [ 'hour12' ] = false ; } options = appendToDateTimeObject ( options , 'hour' , match , { H : 'numeric' , HH : '2-digit' } ) ; match = InternalRegExpMatch ( / m{1,2} / , ldmlString ) ; options = appendToDateTimeObject ( options , 'minute' , match , { m : 'numeric' , mm : '2-digit' } ) ; match = InternalRegExpMatch ( / s{1,2} / , ldmlString ) ; options = appendToDateTimeObject ( options , 'second' , match , { s : 'numeric' , ss : '2-digit' } ) ; match = InternalRegExpMatch ( / z|zzzz / , ldmlString ) ; options = appendToDateTimeObject ( options , 'timeZoneName' , match , { z : 'short' , zzzz : 'long' } ) ; return options ; }
3254	function Duration ( str ) { if ( str . length < 1 || str . charAt ( 0 ) != 'P' ) { throw new Error ( 'Invalid Duration' ) ; } var duration = str . substr ( 1 ) ; if ( duration . length < 1 ) { throw new Error ( 'Invalid Duration' ) ; } if ( / \s / . test ( duration ) ) { throw new Error ( 'Non normalized durations not implemented' ) ; } else { this . _parseNormalized ( duration ) ; } }
2738	function ( object , options ) { return this . collection . findOneAndReplace ( { _id : object . _id } , object , { returnOriginal : false } ) . value }
2866	function ( aliasMap , config ) { var aliases = this . _flattenAliasMap ( aliasMap ) ; var allExcept = null ; if ( typeof config . allExcept !== 'undefined' ) { allExcept = this . _castArray ( config . allExcept ) ; delete config . allExcept ; } var keys = Object . keys ( config ) ; if ( allExcept ) { keys = keys . concat ( allExcept ) ; } var unknownConfigKeys = _ . difference ( keys , aliases ) ; if ( unknownConfigKeys . length ) { this . _logUnknownPlugins ( unknownConfigKeys , 'config.pipeline.disabled' ) ; } var disabledMap = aliases . reduce ( function ( map , alias ) { if ( map [ alias ] === undefined ) { if ( allExcept && allExcept . length ) { if ( allExcept . indexOf ( alias ) >= 0 ) { map [ alias ] = false ; } else { map [ alias ] = true ; } } else { map [ alias ] = false ; } } return map ; } , config ) ; return disabledMap ; }
2230	function Service ( config ) { if ( ! this . loadServiceClass ) { throw AWS . util . error ( new Error ( ) , 'Service must be constructed with `new\' operator' ) ; } \' var ServiceClass = this . loadServiceClass ( config || { } ) ; if ( ServiceClass ) return new ServiceClass ( config ) ; }
3088	function ( ) { var me = this , mon = me . monitor ; if ( mon ) { mon . unbind ( ) ; me . monitor = null ; } me . clearListeners ( ) ; me . checkValidityTask . cancel ( ) ; me . checkDirtyTask . cancel ( ) ; }
431	function getNodeTransitions ( oldData , nextData ) { const oldDataKeyed = oldData && getKeyedData ( oldData ) ; const nextDataKeyed = nextData && getKeyedData ( nextData ) ; return { entering : oldDataKeyed && getKeyedDataDifference ( nextDataKeyed , oldDataKeyed ) , exiting : nextDataKeyed && getKeyedDataDifference ( oldDataKeyed , nextDataKeyed ) } ; }
3413	function ( ) { var t = this , ed = t . editor ; ed . addCommand ( "mcePasteWord" , function ( ) { ed . windowManager . open ( { file : t . url + "/pasteword.htm" , width : parseInt ( getParam ( ed , "paste_dialog_width" ) ) , height : parseInt ( getParam ( ed , "paste_dialog_height" ) ) , inline : 1 } ) ; } ) ; if ( getParam ( ed , "paste_text_use_dialog" ) ) { ed . addCommand ( "mcePasteText" , function ( ) { ed . windowManager . open ( { file : t . url + "/pastetext.htm" , width : parseInt ( getParam ( ed , "paste_dialog_width" ) ) , height : parseInt ( getParam ( ed , "paste_dialog_height" ) ) , inline : 1 } ) ; } ) ; } ed . addButton ( "pasteword" , { title : "paste.paste_word_desc" , cmd : "mcePasteWord" } ) ; }
1484	function ( srcPaths ) { var t = this ; var db = this . __db ; var metas = { } ; for ( var libraryName in db . resources ) { var libraryData = db . resources [ libraryName ] ; for ( var resourcePath in libraryData ) { var fileInfo = libraryData [ resourcePath ] ; if ( ! fileInfo . meta ) { continue ; } for ( var altPath in fileInfo . meta ) { metas [ altPath ] = resourcePath ; } } } var assets = [ ] ; var assetPaths = { } ; function addAsset ( library , resourceName ) { if ( assetPaths [ resourceName ] !== undefined ) { return ; } var libraryData = db . resources [ library . getNamespace ( ) ] ; var fileInfo = libraryData [ resourceName ] ; if ( fileInfo . doNotCopy === true ) { return ; } var asset = { libraryName : library . getNamespace ( ) , filename : resourceName , fileInfo : fileInfo } ; var metaPath = metas [ resourceName ] ; if ( metaPath !== null ) { var metaInfo = libraryData [ metaPath ] ; if ( metaInfo ) { var resMetaData = metaInfo . meta [ resourceName ] ; fileInfo . composite = resMetaData [ 3 ] ; fileInfo . x = resMetaData [ 4 ] ; fileInfo . y = resMetaData [ 5 ] ; if ( ! assetPaths [ metaPath ] ) { srcPaths . push ( metaPath ) ; } } } assets . push ( asset ) ; assetPaths [ resourceName ] = assets . length - 1 ; } for ( var i = 0 ; i < srcPaths . length ; i ++ ) { var srcPath = srcPaths [ i ] ; var library = t . findLibraryForResource ( srcPath ) ; if ( ! library ) { t . warn ( "Cannot find library for " + srcPath ) ; continue ; } var pos = srcPath . indexOf ( ":" ) ; if ( pos > - 1 ) { srcPath = srcPath . substring ( pos + 1 ) ; } libraryData = db . resources [ library . getNamespace ( ) ] ; pos = srcPath . indexOf ( "*" ) ; if ( pos > - 1 ) { srcPath = srcPath . substring ( 0 , pos ) ; for ( var resourceName in libraryData ) { if ( resourceName . substring ( 0 , srcPath . length ) == srcPath ) { addAsset ( library , resourceName ) ; } } } else { fileInfo = libraryData [ srcPath ] ; if ( fileInfo && ( fileInfo . doNotCopy !== true ) ) { addAsset ( library , srcPath ) ; } } } return assets ; }
38	function safeJoin ( input , delimiter ) { if ( ! isArray ( input ) ) return '' ; var output = [ ] ; for ( var i = 0 ; i < input . length ; i ++ ) { try { output . push ( String ( input [ i ] ) ) ; } catch ( e ) { output . push ( '[value cannot be serialized]' ) ; } } return output . join ( delimiter ) ; }
3689	function clone ( origSource ) { let origIndex = - 1 ; let rc = new RecurseCounter ( 1000 ) ; return _clone . call ( null , origSource , rc ) ; }
2611	function first ( o , n ) { var gotN = ( n === 0 ? true : ! ! n ) , v ; n = parseInt ( n , 10 ) ; n = isNaN ( n ) || ! isFinite ( n ) ? 1 : n ; if ( typeof o === 'boolean' ) { return o ; } else if ( typeof o !== 'object' ) { if ( n !== 0 ) v = o . toString ( ) . slice ( 0 , n ) ; else return undefined ; } else if ( o instanceof Array ) { if ( n === 1 && ! gotN ) return o [ 0 ] ; if ( n === 0 && ! gotN ) return undefined ; return n !== 0 ? o . slice ( 0 , n ) : [ ] ; } else { v = { } ; libs . object . each ( o , 0 , n - 1 , function ( item , key ) { v [ key ] = item ; } ) ; var keys = getKeys ( v ) ; if ( n === 1 && ! gotN && keys . length === 0 ) return undefined ; return keys . length === 1 && ! gotN ? v [ keys [ 0 ] ] : v ; } return v . length === 1 && ! gotN ? v [ 0 ] : v ; }
705	function ( kb , subject , path ) { if ( path . length === 0 ) return [ subject ] var oo = kb . each ( subject , path [ 0 ] ) var res = [ ] for ( var i = 0 ; i < oo . length ; i ++ ) { res = res . concat ( followeach ( kb , oo [ i ] , path . slice ( 1 ) ) ) } return res }
1606	function isRIdent ( node ) { return node && node . type && node . type === T . IDENT && node . content === 'R' }
3570	function ( key , value ) { var index = this . _keys . indexOf ( key ) ; if ( index > - 1 ) { this . _keys [ index ] = key ; this . _values [ index ] = value ; } else { this . _keys . push ( key ) ; this . _values . push ( value ) ; } return this ; }
1798	function logAndFinish ( tessel ) { if ( tessel ) { log . info ( ` ${ tessel . displayName } ` ) ; controller . closeTesselConnections ( tessels . filter ( closable => closable !== tessel ) ) . then ( ( ) => resolve ( tessel ) ) ; } else { log . info ( 'Please specify a Tessel by name [--name <tessel name>]' ) ; controller . closeTesselConnections ( tessels ) . then ( ( ) => reject ( 'Multiple possible Tessel connections found.' ) ) ; } }
3113	function ( pos , zIndex , x , y ) { var me = this ; if ( ! pos && me . isStyle ( POSITION , STATIC ) ) { me . setStyle ( POSITION , RELATIVE ) ; } else if ( pos ) { me . setStyle ( POSITION , pos ) ; } if ( zIndex ) { me . setStyle ( ZINDEX , zIndex ) ; } if ( x || y ) { me . setXY ( [ x || false , y || false ] ) ; } }
2628	function create ( props ) { var menu = Object . create ( this ) ; _domWidget2 . default . create . call ( menu ) ; Object . assign ( menu , Menu . defaults , props ) ; menu . createOptions ( ) ; menu . element . addEventListener ( 'change' , function ( e ) { menu . __value = e . target . value ; menu . output ( ) ; if ( menu . onvaluechange !== null ) { menu . onvaluechange ( menu . value ) ; } } ) ; return menu ; }
3279	function filterDuplicateFiles ( ) { const lookup = new Map ( ) ; return value => { if ( lookup . has ( value ) ) return false ; return lookup . set ( value , true ) ; } }
3742	function shallowClone ( source , obj ) { if ( arguments . length < 2 ) { obj = source ; source = { } ; } for ( var key in obj ) { if ( ! obj . hasOwnProperty ( key ) ) continue ; source [ key ] = obj [ key ] ; } return source ; }
863	function getIgnoresEnum ( ) { return Object . keys ( OPTIONS . reduce ( ( retv , key ) => { for ( const alias of FEATURES [ key ] . alias ) { retv [ alias ] = true } retv [ key ] = true return retv } , Object . create ( null ) ) ) }
2623	function create ( ) { var shouldUseTouch = _utilities2 . default . getMode ( ) === 'touch' ; _widget2 . default . create . call ( this ) ; Object . assign ( this , DOMWidget . defaults ) ; if ( typeof this . createElement === 'function' ) { this . element = this . createElement ( ) ; } else { throw new Error ( 'widget inheriting from DOMWidget does not implement createElement method; this is required.' ) ; } }
868	function report ( node , key ) { const version = supportInfo . version const feature = supportInfo . features [ key ] if ( feature . supported ) { return } if ( ! feature . supportedInStrict ) { context . report ( { node , message : "{{feature}} {{be}} not supported yet on Node {{version}}." , data : { feature : feature . name , be : feature . singular ? "is" : "are" , version , } , } ) } else if ( ! nomalizeScope ( context . getScope ( ) , node ) . isStrict ) { context . report ( { node , message : "{{feature}} {{be}} not supported yet on Node {{version}}." , data : { feature : ` ${ feature . name } ` , be : feature . singular ? "is" : "are" , version , } , } ) } }
436	function getDomainFromCategories ( props , axis , categories ) { categories = categories || Data . getCategories ( props , axis ) ; const { polar , startAngle = 0 , endAngle = 360 } = props ; if ( ! categories ) { return undefined ; } const minDomain = getMinFromProps ( props , axis ) ; const maxDomain = getMaxFromProps ( props , axis ) ; const stringArray = Collection . containsStrings ( categories ) ? Data . getStringsFromCategories ( props , axis ) : [ ] ; const stringMap = stringArray . length === 0 ? null : stringArray . reduce ( ( memo , string , index ) => { memo [ string ] = index + 1 ; return memo ; } , { } ) ; const categoryValues = stringMap ? categories . map ( ( value ) => stringMap [ value ] ) : categories ; const min = minDomain !== undefined ? minDomain : Collection . getMinValue ( categoryValues ) ; const max = maxDomain !== undefined ? maxDomain : Collection . getMaxValue ( categoryValues ) ; const categoryDomain = getDomainFromMinMax ( min , max ) ; return polar && axis === "x" && Math . abs ( startAngle - endAngle ) === 360 ? getSymmetricDomain ( categoryDomain , categoryValues ) : categoryDomain ; }
541	async function run ( action ) { if ( action . endsWith ( 'symlink' ) ) { await symlinkDepsLib ( ) ; } else if ( action . endsWith ( 'move' ) ) { await moveDepsLib ( ) ; } else { throw new Error ( 'Invalid action: ' + action ) ; } }
1269	function BenchmarkSuite ( name , reference , benchmarks ) { this . name = name ; this . reference = reference ; this . benchmarks = benchmarks ; BenchmarkSuite . suites . push ( this ) ; }
46	function _breadcrumbEventHandler ( evtName ) { var self = this ; return function ( evt ) { self . _keypressTimeout = null ; if ( self . _lastCapturedEvent === evt ) return ; self . _lastCapturedEvent = evt ; var target ; try { target = htmlTreeAsString$1 ( evt . target ) ; } catch ( e ) { target = '<unknown>' ; } self . captureBreadcrumb ( { category : 'ui.' + evtName , message : target } ) ; } ; }
1738	function configureGeojsonSource ( glSource , mapView , baseUrl , wrapX , fetchOptions ) { const use_bbox = ( typeof glSource . data === 'string' && glSource . data . indexOf ( BBOX_STRING ) >= 0 ) ; const vector_src = new VectorSource ( { strategy : use_bbox ? bboxStrategy : allStrategy , loader : getLoaderFunction ( glSource , mapView . getProjection ( ) , baseUrl , fetchOptions ) , useSpatialIndex : true , wrapX : wrapX , } ) ; let new_src = vector_src ; if ( glSource . cluster ) { new_src = new ClusterSource ( { source : vector_src , distance : glSource . clusterRadius ? glSource . clusterRadius : 50 , } ) ; } updateGeojsonSource ( new_src , glSource , mapView , baseUrl , fetchOptions ) ; return new_src ; }
376	function normalize ( node ) { if ( ! ( isElement ( node ) || isDocument ( node ) || isDocumentFragment ( node ) ) ) { return ; } if ( ! node . childNodes ) { return ; } var textRangeStart = - 1 ; for ( var i = node . childNodes . length - 1 , n = void 0 ; i >= 0 ; i -- ) { n = node . childNodes [ i ] ; if ( isTextNode ( n ) ) { if ( textRangeStart === - 1 ) { textRangeStart = i ; } if ( i === 0 ) { collapseTextRange ( node , 0 , textRangeStart ) ; } } else { normalize ( n ) ; if ( textRangeStart > - 1 ) { collapseTextRange ( node , i + 1 , textRangeStart ) ; textRangeStart = - 1 ; } } } }
343	function ( query , option ) { var result = new RegExp ( query , "i" ) . exec ( option . textContent ) ; if ( result ) { return option . textContent . replace ( result [ 0 ] , "<span class='selectr-match'>" + result [ 0 ] + "</span>" ) ; } return false ; }
3624	function length ( buffer , n , special ) { var len = this . getLengthEncoding ( n , special ) ; return Buffer . concat ( [ len , buffer ] , len . length + buffer . length ) ; }
1110	function WebView ( ) { this . tab = null ; this . handler = null ; this . open = this . open . bind ( this ) ; this . handleFirstLoadEnd = this . handleFirstLoadEnd . bind ( this ) ; this . handleLoadError = this . handleLoadError . bind ( this ) ; this . handleExit = this . handleExit . bind ( this ) ; this . clearEvents = this . clearEvents . bind ( this ) ; this . close = this . close . bind ( this ) ; }
1398	function tsv ( incomingData , logger , opConfig , metadata , slice ) { return csv ( incomingData , logger , opConfig , metadata , slice ) ; }
1358	function itemsCallback ( error , itemsResponse ) { if ( error ) throw error ; var items = itemsResponse . searchResult . item ; console . log ( 'Found' , items . length , 'items' ) ; for ( var i = 0 ; i < items . length ; i ++ ) { console . log ( '- ' + items [ i ] . title ) ; } }
517	function readStorage ( cb ) { var storageTrie = stateTrie . copy ( ) storageTrie . root = storageRoot var stream = storageTrie . createReadStream ( ) console . log ( '------Storage------' ) stream . on ( 'data' , function ( data ) { console . log ( 'key: ' + data . key . toString ( 'hex' ) ) console . log ( 'Value: ' + rlp . decode ( data . value ) . toString ( ) ) } ) stream . on ( 'end' , cb ) }
2461	function ( id , type , attributes , relationships ) { var _this = this ; JsonApiResource . call ( _this , id , type ) ; BaseAttributesCreatedUpdated . call ( _this ) ; _this [ 'type' ] = type ; _this [ 'attributes' ] = attributes ; _this [ 'relationships' ] = relationships ; }
395	function parseUncssrc ( filename ) { let options = JSON . parse ( fs . readFileSync ( filename , 'utf-8' ) ) ; options . ignore = options . ignore ? options . ignore . map ( strToRegExp ) : undefined ; options . ignoreSheets = options . ignoreSheets ? options . ignoreSheets . map ( strToRegExp ) : undefined ; return options ; }
3560	function defineEnumProp ( obj , key , value ) { Object . defineProperty ( obj , key , { value : value , enumerable : true } ) ; }
922	function initGlobalComponents ( appType , componentConf , sourceDir ) { let { global : globalComponents } = componentConf ; if ( ! globalComponents ) { return ; } let result = { } ; Object . keys ( globalComponents ) . forEach ( k => { let value = globalComponents [ k ] ; value = value . replace ( / ^okam\/ / , BUILTIN_COMPONENTS_PACKAGE_ROOT + appType + '/' ) ; let isRelMod = value . charAt ( 0 ) === '.' ; if ( isRelMod ) { value = pathUtil . join ( sourceDir , value ) ; } result [ toHyphen ( k ) ] = { isNpmMod : ! isRelMod , modPath : value } ; } ) ; return result ; }
3422	function ( ) { var me = this , cfg = { app : me , taskbarConfig : me . getTaskbarConfig ( ) } ; Ext . apply ( cfg , me . desktopConfig ) ; return cfg ; }
3007	function visibilityChange ( ev ) { var that = this ; if ( this . visibilityTimeout ) { clearTimeout ( this . visibilityTimeout ) ; this . visibilityTimeout = undefined ; } switch ( document . visibilityState ) { case 'hidden' : this . visibilityTimeout = setTimeout ( function ( ) { that . visibilityTimeout = undefined ; O . gw . disconnect ( ) ; } , 10 * 1000 ) ; return ; case 'visible' : if ( ! O . gw . isConnected ( ) ) { O . gw . connect ( ) ; } return ; } }
2908	function handleRequest ( req , res ) { var self = this ; var config = self . app . config ; if ( req . url . indexOf ( config . transport . path ) !== - 1 && req . method . toLowerCase ( ) === config . transport . method . toLowerCase ( ) ) { return self . app . exec ( req . body , function ( err , out ) { if ( err ) { return handleError . call ( self , err , req , res ) ; } sendResponse ( res , out || null , { statusCode : 200 } ) ; } ) ; } sendResponse ( res , { message : 'To call an action use ' + config . transport . path } , { statusCode : 200 } ) ; }
2318	function loadProviders ( providers ) { var result = [ ] , index , num = providers . length , provider , prefilters , postfilters , resources ; for ( index = 0 ; index < num ; index ++ ) { provider = providers [ index ] ; prefilters = [ ] ; postfilters = [ ] ; resources = [ ] ; if ( ! provider . id ) { throw new InvalidConfiguration ( InvalidConfiguration . INVALID_PROVIDER_MESSAGE + " Provider at index " + index + " has no 'id' property." ) ; } if ( ! provider . target ) { throw new InvalidConfiguration ( InvalidConfiguration . INVALID_PROVIDER_MESSAGE + " Provider at index " + index + " has no 'target' property." ) ; } if ( ! provider . context ) { throw new InvalidConfiguration ( InvalidConfiguration . INVALID_PROVIDER_MESSAGE + " Provider at index " + index + " has no context' property." ) ; } if ( provider . prefilters ) { prefilters = loadMiddlewareFilters ( provider . prefilters ) ; } if ( provider . postfilters ) { postfilters = loadMiddlewareFilters ( provider . postfilters ) ; } if ( provider . resources ) { resources = loadResources ( provider . resources , index ) ; } result . push ( { id : provider . id , context : provider . context , target : provider . target , prefilters : prefilters , postfilters : postfilters , resources : resources } ) ; } return result ; }
1166	function ( ) { var markup = this . model . markup || this . model . get ( 'markup' ) ; if ( markup ) { var nodes = V ( markup ) ; V ( this . el ) . append ( nodes ) ; } else { throw new Error ( 'properties.markup is missing while the default render() implementation is used.' ) ; } this . update ( ) ; this . resize ( ) ; this . rotate ( ) ; this . translate ( ) ; return this ; }
1223	function splitVal ( string , separator ) { var val , i , l ; if ( string === null || string . length < 1 ) return [ ] ; val = string . split ( separator ) ; for ( i = 0 , l = val . length ; i < l ; i = i + 1 ) val [ i ] = $ . trim ( val [ i ] ) ; return val ; }
2484	function _full_delete ( hash , key1 , key2 ) { if ( key1 && key2 && hash && hash [ key1 ] && hash [ key1 ] [ key2 ] ) { delete hash [ key1 ] [ key2 ] ; } if ( us . isEmpty ( hash [ key1 ] ) ) { delete hash [ key1 ] ; } }
325	function zoom ( ratio , _originalEvent ) { var canvasData = this . canvasData ; ratio = Number ( ratio ) ; if ( ratio < 0 ) { ratio = 1 / ( 1 - ratio ) ; } else { ratio = 1 + ratio ; } return this . zoomTo ( canvasData . width * ratio / canvasData . naturalWidth , null , _originalEvent ) ; }
632	function getSubheadingsTopLevel ( text ) { const subheadings = [ ] ; const regex = / <h([2-3])(?:[^>]+)?>(.*?)<\/h\1> / ig ; let match ; while ( ( match = regex . exec ( text ) ) !== null ) { subheadings . push ( match ) ; } return subheadings ; }
2983	function trsv ( A , x , isLower ) { var dot = blas1 . dot ; var n = A . shape [ 1 ] ; var i = 0 ; if ( isLower ) { x . set ( 0 , x . get ( 0 ) / A . get ( 0 , 0 ) ) ; for ( i = 1 ; i < n ; i ++ ) { x . set ( i , ( x . get ( i ) - dot ( A . pick ( i , null ) . hi ( i ) , x . hi ( i ) ) ) / A . get ( i , i ) ) ; } } else { x . set ( n - 1 , x . get ( n - 1 ) / A . get ( n - 1 , n - 1 ) ) ; for ( i = n - 2 ; i >= 0 ; i -- ) { x . set ( i , ( x . get ( i ) - dot ( A . pick ( i , null ) . lo ( i + 1 ) , x . lo ( i + 1 ) ) ) / A . get ( i , i ) ) ; } } return true ; }
1085	function addEventListeners ( el , eventName , handlers ) { var handler ; var i ; if ( ! handlers ) { return ; } if ( handlers . constructor === Function ) { handlers = [ handlers ] ; } for ( i = 0 ; i < handlers . length ; i ++ ) { el . addEventListener ( eventName , handlers [ i ] ) ; } }
89	function updateRangeFill ( target ) { var range = is$1 . event ( target ) ? target . target : target ; if ( ! is$1 . element ( range ) || range . getAttribute ( 'type' ) !== 'range' ) { return ; } if ( matches$1 ( range , this . config . selectors . inputs . seek ) ) { range . setAttribute ( 'aria-valuenow' , this . currentTime ) ; var currentTime = controls . formatTime ( this . currentTime ) ; var duration = controls . formatTime ( this . duration ) ; var format = i18n . get ( 'seekLabel' , this . config ) ; range . setAttribute ( 'aria-valuetext' , format . replace ( '{currentTime}' , currentTime ) . replace ( '{duration}' , duration ) ) ; } else if ( matches$1 ( range , this . config . selectors . inputs . volume ) ) { var percent = range . value * 100 ; range . setAttribute ( 'aria-valuenow' , percent ) ; range . setAttribute ( 'aria-valuetext' , "" . concat ( percent . toFixed ( 1 ) , "%" ) ) ; } else { range . setAttribute ( 'aria-valuenow' , range . value ) ; } if ( ! browser . isWebkit ) { return ; } range . style . setProperty ( '--value' , "" . concat ( range . value / range . max * 100 , "%" ) ) ; }
2953	function getInheritTheme ( theme , tree = { } ) { if ( ! app . locals . themes [ theme ] ) { app . error ( 'requested theme:%s but it is not installed' , theme ) ; return tree ; } tree [ theme ] = { } ; var config = app . locals . themes [ theme ] . zealderConfig ; if ( config && config . themeDependency && ! tree [ config . themeDependency ] ) { tree = getInheritTheme ( config . themeDependency , tree ) ; } return tree ; }
909	function normalizeFeatureItem ( item , existed , result , logger ) { let addItem ; if ( typeof item === 'string' ) { addItem = addFeatureItem ( logger , existed , item ) ; } else if ( Array . isArray ( item ) ) { let [ name , params ] = item ; addItem = addFeatureItem ( logger , existed , name , params ) ; } else if ( item && typeof item === 'object' ) { let { name , params } = item ; addItem = addFeatureItem ( logger , existed , name , params ) ; } if ( addItem ) { result . push ( addItem ) ; } }
3870	function getStyle ( node , prop ) { if ( node && node . el ) { if ( node . el !== undefined && node . el . style !== undefined ) { return node . el . style [ prop ] ; } else { return undefined ; } } }
1990	function funcWithReturnFromSnippet ( js ) { if ( js . indexOf ( 'return' ) === - 1 ) { if ( js . substring ( js . length - 1 ) === ';' ) { js = js . substring ( 0 , js . length - 1 ) ; } js = 'return (' + js + ')' ; } var varDefs = [ ] ; Object . keys ( upperNameFromLevel ) . forEach ( function ( lvl ) { varDefs . push ( format ( 'var %s = %d;' , upperNameFromLevel [ lvl ] , lvl ) ) ; } ) ; varDefs = varDefs . join ( '\n' ) + \n ; '\n' }
3128	function ( o ) { var me = this , key ; if ( o != null ) { if ( ! me . useLinearSearch && ( key = me . getKey ( o ) ) ) { return this . map [ key ] != null ; } return Ext . Array . indexOf ( this . items , o ) !== - 1 ; } return false ; }
1812	function ( elem , ignoreScroll ) { var rect = elem . getBoundingClientRect ( ) ; var result = { top : rect . top | 0 , left : rect . left | 0 , right : rect . right | 0 , bottom : rect . bottom | 0 , width : ( rect . right - rect . left ) | 0 , height : ( rect . bottom - rect . top ) | 0 } ; if ( ignoreScroll ) { return result ; } var body = env . doc . body ; result . top += env . root . pageYOffset || body . scrollTop ; result . top += env . root . pageXOffset || body . scrollLeft ; return result ; }
185	function storeInfoSubmit ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT : case WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT_FAILURE : return WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT === type ; } return state ; }
1061	function add ( buf ) { var self = this var compound = self . compoundRules var compoundCodes = self . compoundRuleCodes var index = - 1 var length = compound . length var rule var source var character var offset var count parse ( buf , self , self . data ) while ( ++ index < length ) { rule = compound [ index ] source = '' offset = - 1 count = rule . length while ( ++ offset < count ) { character = rule . charAt ( offset ) if ( compoundCodes [ character ] . length === 0 ) { source += character } else { source += '(?:' + compoundCodes [ character ] . join ( '|' ) + ')' } } compound [ index ] = new RegExp ( source , 'i' ) } return self }
98	function getMenuSize ( tab ) { var clone = tab . cloneNode ( true ) ; clone . style . position = 'absolute' ; clone . style . opacity = 0 ; clone . removeAttribute ( 'hidden' ) ; tab . parentNode . appendChild ( clone ) ; var width = clone . scrollWidth ; var height = clone . scrollHeight ; removeElement ( clone ) ; return { width : width , height : height } ; }
426	function ( name , args , index , currentFileInfo ) { this . name = name ; this . args = args ; this . calc = name === 'calc' ; this . _index = index ; this . _fileInfo = currentFileInfo ; }
2707	function findFile ( name , dir ) { dir = dir || process . cwd ( ) ; var filename = path . normalize ( path . join ( dir , name ) ) ; if ( findFileResults [ filename ] !== undefined ) { return findFileResults [ filename ] ; } var parent = path . resolve ( dir , "../" ) ; if ( shjs . test ( "-e" , filename ) ) { findFileResults [ filename ] = filename ; return filename ; } if ( dir === parent ) { findFileResults [ filename ] = null ; return null ; } return findFile ( name , parent ) ; }
1048	function generate ( context , memory , words , edits ) { var characters = context . flags . TRY var characterLength = characters . length var data = context . data var flags = context . flags var result = [ ] var upper var length var index var word var position var count var before var after var nextAfter var nextNextAfter var character var nextCharacter var inject var offset length = edits && edits . length index = - 1 while ( ++ index < length ) { check ( edits [ index ] , true ) } length = words . length index = - 1 while ( ++ index < length ) { word = words [ index ] before = '' character = '' nextAfter = word nextNextAfter = word . slice ( 1 ) nextCharacter = word . charAt ( 0 ) position = - 1 count = word . length + 1 while ( ++ position < count ) { before += character after = nextAfter nextAfter = nextNextAfter nextNextAfter = nextAfter . slice ( 1 ) character = nextCharacter nextCharacter = word . charAt ( position + 1 ) upper = character . toLowerCase ( ) !== character check ( before + nextAfter ) if ( nextAfter ) { check ( before + nextCharacter + character + nextNextAfter ) } offset = - 1 while ( ++ offset < characterLength ) { inject = characters [ offset ] check ( before + inject + after ) check ( before + inject + nextAfter ) if ( upper ) { inject = inject . toUpperCase ( ) check ( before + inject + after ) check ( before + inject + nextAfter ) } } } } return result function check ( value , double ) { var state = memory . state [ value ] var corrected if ( state !== Boolean ( state ) ) { result . push ( value ) corrected = form ( context , value ) state = corrected && ! flag ( flags , noSuggestType , data [ corrected ] ) memory . state [ value ] = state if ( state ) { memory . weighted [ value ] = double ? 10 : 0 memory . suggestions . push ( value ) } } if ( state ) { memory . weighted [ value ] ++ } } }
2843	function apilist ( items ) { return ul ( items . map ( item => li ( { innerHTML : item . replace ( / (\w+) / g , apilink ) } ) ) ) }
1817	function ( ) { var args = Array . prototype . slice . call ( arguments ) , target = this ; if ( typeof args [ 0 ] !== 'string' ) { target = args [ 0 ] ; args . splice ( 0 , 1 ) ; } return function ( ) { target . trigger . apply ( target , args ) ; } ; }
3200	function fixPath ( string ) { if ( string . length < 1 ) { return string ; } if ( string . charAt ( string . length - 1 ) !== path . sep ) { string += path . sep ; } return string ; }
3115	function ( left , top ) { var me = this , style = me . dom . style ; style . left = me . addUnits ( left ) ; style . top = me . addUnits ( top ) ; return me ; }
2516	function getDirChildren ( parentId , items ) { var children = { } ; for ( var id in items ) { if ( items [ id ] . ancestors [ items [ id ] . ancestors . length - 1 ] === parentId ) children [ id ] = items [ id ] ; } return children ; }
629	function createAssessment ( name , score = 9 , text = "Excellent" ) { const assessment = new Assessment ( ) ; assessment . identifier = name ; assessment . getResult = ( ) => { const result = new AssessmentResult ( ) ; result . setScore ( score ) ; result . setText ( text ) ; return result ; } ; return assessment ; }
2316	function loadMiddlewareFilters ( filters ) { var result = [ ] , index , num = filters . length , filter , modulePath , middleware ; function startsWith ( string , searchString , position ) { position = position || 0 ; return string . indexOf ( searchString , position ) === position ; } for ( index = 0 ; index < num ; index ++ ) { filter = filters [ index ] ; if ( ! filter . id ) { throw new InvalidConfiguration ( InvalidConfiguration . INVALID_FILTER_MESSAGE + " Filter at index " + index + " has no 'id' property." ) ; } if ( ! filter . path ) { throw new InvalidConfiguration ( InvalidConfiguration . INVALID_FILTER_MESSAGE + " Filter at index " + index + " has no 'path' property." ) ; } modulePath = filter . path ; if ( startsWith ( filter . path , "." ) ) { modulePath = path . join ( basePath , filter . path ) ; } middleware = require ( modulePath ) . init ( filter . id , filter . config ) ; result . push ( { id : filter . id , path : modulePath , config : filter . config , middleware : middleware } ) ; } return result ; }
1837	function CloudMonitoring ( options , log ) { this . _options = options ; this . log = log || logmagic . local ( 'cloudmonitoring' ) ; this . defaultSuppressionDuration = options . defaultSuppressionDuration || DEFAULT_SUPPRESSION_DURATION ; this . monitoringApiUri = options . monitoringApiUri || DEFAULT_MONITORING_API_URI ; this . keystoneClient = new KeystoneClient ( options . authUri || DEFAULT_AUTH_URI , { username : options . username , apiKey : options . apiKey } ) ; }
2606	function getNumeric ( ) { var vals = [ ] ; libs . object . every ( arguments , function ( o ) { vals . push ( libs . object . isNumeric ( o ) ? parseFloat ( o ) : NaN ) ; } ) ; return vals . length === 1 ? vals [ 0 ] : vals ; }
1750	function decodeLogItem ( eventObject , log , useNumberedParams = true ) { if ( eventObject && log . topics [ 0 ] === eventSignature ( eventObject ) ) { return decodeEvent ( eventObject , log . data , log . topics , useNumberedParams ) } }
1396	function _toRecords ( rawData , delimiter , slice ) { let outputData = rawData ; if ( rawData . endsWith ( delimiter ) ) { outputData = rawData . slice ( 0 , - delimiter . length ) ; } if ( slice . offset === 0 ) { return outputData . split ( delimiter ) ; } return outputData . split ( delimiter ) . splice ( 1 ) ; }
1766	function cursorTo ( stream , x , y ) { if ( stream === null || stream === undefined ) return ; if ( typeof x !== 'number' && typeof y !== 'number' ) return ; if ( typeof x !== 'number' ) throw new Error ( 'ERR_INVALID_CURSOR_POS' ) ; if ( typeof y !== 'number' ) { stream . write ( CSI ` ${ x + 1 } ` ) ; } else { stream . write ( CSI ` ${ y + 1 } ${ x + 1 } ` ) ; } }
1584	function compileTS ( module ) { var exitCode = 0 ; var tmpDir = path . join ( options . tmpDir , "tsreq" ) ; var relativeFolder = path . dirname ( path . relative ( process . cwd ( ) , module . filename ) ) ; var jsname = path . join ( tmpDir , relativeFolder , path . basename ( module . filename , ".ts" ) + ".js" ) ; if ( ! isModified ( module . filename , jsname ) ) { return jsname ; } var argv = [ "node" , "tsc.js" , ! ! options . emitOnError ? "" : "--noEmitOnError" , "--nolib" , "--rootDir" , process . cwd ( ) , "--target" , options . targetES5 ? "ES5" : "ES3" , ! ! options . moduleKind ? "--module" : "" , ! ! options . moduleKind ? options . moduleKind : "" , "--outDir" , tmpDir , libPath , options . nodeLib ? path . resolve ( __dirname , "typings/node.d.ts" ) : null , module . filename ] ; var proc = merge ( merge ( { } , process ) , { argv : compact ( argv ) , exit : function ( code ) { if ( code !== 0 && options . exitOnError ) { console . error ( 'Fatal Error. Unable to compile TypeScript file. Exiting.' ) ; process . exit ( code ) ; } exitCode = code ; } } ) ; var sandbox = { process : proc , require : require , module : module , Buffer : Buffer , setTimeout : setTimeout , clearTimeout : clearTimeout , __filename : tsc } ; tscScript . runInNewContext ( sandbox ) ; if ( exitCode !== 0 ) { throw new Error ( 'Unable to compile TypeScript file.' ) ; } return jsname ; }
174	function parseAsShortcode ( node , _parsed ) { const shortcode = parse ( node ) ; if ( shortcode ) { return _recurse ( shortcode , _parsed ) ; } return _parsed ; }
2331	function listAppliedChangeSinceLastSync ( datasetId , lastSyncEndTime , clientInfo , cb ) { syncStorage . listUpdates ( datasetId , { type : SYNC_UPDATE_TYPES . APPLIED , cuid : clientInfo . cuid , timestamp : { $gt : lastSyncEndTime } } , null , cb ) ; }
2803	function transformConstraintViolationMessages ( input ) { return { validationErrors : _ . chain ( input . details ) . mapKeys ( function ( v , k ) { return ( input . details . length == 1 && input . details [ 0 ] . path === 'value' && input . details [ 0 ] . type === 'object.base' ) ? '.' : v . path } ) . mapValues ( function ( v ) { return { attributes : _ . chain ( v . context ) . pickBy ( function ( v , k ) { return typeof v !== 'undefined' && v !== null && k !== 'key' } ) . mapValues ( function ( i ) { return i . toString ( ) } ) , constraintClassName : v . type , invalidValue : v . context . value , messageTemplate : v . type , } } ) } }
300	function toggleClass ( element , value , added ) { if ( ! value ) { return ; } if ( isNumber ( element . length ) ) { forEach ( element , function ( elem ) { toggleClass ( elem , value , added ) ; } ) ; return ; } if ( added ) { addClass ( element , value ) ; } else { removeClass ( element , value ) ; } }
2624	function place ( ) { var containerWidth = this . container . getWidth ( ) , containerHeight = this . container . getHeight ( ) , width = this . width <= 1 ? containerWidth * this . width : this . width , height = this . height <= 1 ? containerHeight * this . height : this . height , x = this . x < 1 ? containerWidth * this . x : this . x , y = this . y < 1 ? containerHeight * this . y : this . y ; if ( ! this . attached ) { this . attached = true ; } if ( this . isSquare ) { if ( height > width ) { height = width ; } else { width = height ; } } this . element . width = width ; this . element . style . width = width + 'px' ; this . element . height = height ; this . element . style . height = height + 'px' ; this . element . style . left = x ; this . element . style . top = y ; this . rect = this . element . getBoundingClientRect ( ) ; }
3562	function changeCaseOfFirstChar ( str , func , thisFuncsName ) { var search , char , right , left ; throwTypeErrorIfNotOfType ( thisFuncsName , 'str' , str , _String ) ; search = str . search ( / [a-z] / i ) ; if ( isNumber ( search ) && search > - 1 ) { char = str . substr ( search , 1 ) [ func ] ( ) ; right = str . substr ( search + 1 , str . length - 1 ) ; left = search !== 0 ? str . substr ( 0 , search ) : '' ; str = left + char + right ; } return str ; }
2141	function ( content ) { var interpolateTest = _ . templateSettings . interpolate . test ( content ) ; if ( interpolateTest ) { _ . templateSettings . interpolate . lastIndex = 0 ; return true ; } var evaluateTest = _ . templateSettings . evaluate . test ( content ) ; if ( evaluateTest ) { _ . templateSettings . evaluate . lastIndex = 0 ; return true ; } var escapeTest = _ . templateSettings . escape . test ( content ) ; _ . templateSettings . escape . lastIndex = 0 ; return escapeTest ; }
3336	function string ( state ) { return [ { token : "string" , regex : '".*?"' } , { token : "string" , regex : '["].*$' , next : state + "-qqstring" } , { token : "string" , regex : "'.*?'" } , { token : "string" , regex : "['].*$" , next : state + "-qstring" } ] }
1353	function mockXhrGenerator ( file ) { var xhr = new MockHttpRequest ( ) ; xhr . upload = { } ; xhr . onsend = function ( ) { if ( xhr . upload . onloadstart ) { xhr . upload . onloadstart ( ) ; } var total = file && file . size || 1024 , done = 0 ; function start ( ) { setTimeout ( progress , 1000 ) ; } function progress ( ) { xhr . upload . onprogress ( { total : total , loaded : done } ) ; if ( done < total ) { setTimeout ( progress , 200 ) ; done = Math . min ( total , done + 254000 ) ; } else if ( ! file . abort ) { setTimeout ( finish , 1000 ) ; } } function finish ( ) { xhr . receive ( 200 , '{"message":"OK"}' ) ; } start ( ) ; } ; return xhr ; }
2288	function hasClass ( el , className ) { var test ; if ( el . classList ) { test = el . classList . contains ( className ) ; } else { var className = new RegExp ( '(^| )' + className + '( |$)' , 'gi' ) ; test = new RegExp ( className ) . test ( el . className ) ; } return test ; }
3398	function assertRange ( name , val , max ) { assert . equal ( typeof val , 'number' , name + ' must be a number' ) assert ( ! isNaN ( val ) , 'number' , name + ' must be a number' ) if ( val > max ) throw new RangeError ( name + ' must be lower than ' + max + ', but is ' + val ) else if ( val < 0 ) throw new RangeError ( name + ' must be greater than or equal to zero, but is ' + val ) else if ( val % 1 ) throw new RangeError ( name + ' must be an integer' ) }
500	function ( runState , done ) { if ( runState . static ) { trap ( ERROR . STATIC_STATE_CHANGE ) } const [ value , offset , length ] = runState . stack . popN ( 3 ) subMemUsage ( runState , offset , length ) let data = Buffer . alloc ( 0 ) if ( ! length . isZero ( ) ) { data = runState . memory . read ( offset . toNumber ( ) , length . toNumber ( ) ) } var options = { value : value , data : data } var localOpts = { inOffset : offset , inLength : length , outOffset : new BN ( 0 ) , outLength : new BN ( 0 ) } checkCallMemCost ( runState , options , localOpts ) checkOutOfGas ( runState , options ) makeCall ( runState , options , localOpts , done ) }
2619	function keyOfMin ( o , func ) { if ( ! o || typeof o !== 'object' ) return o ; if ( libs . object . size ( o ) === 0 ) return ; if ( ! ( func instanceof Function ) ) func = undefined ; if ( typeof o !== 'object' ) return o ; var min , minValue , minKey ; if ( ! func ) { min = libs . object . first ( o ) ; minKey = libs . object . keys ( o ) [ 0 ] ; libs . object . each ( o , 1 , function ( item , key ) { if ( item <= min ) { min = item ; minKey = key ; } } ) ; } else { min = libs . object . first ( o ) ; minValue = func . call ( min , min ) ; minKey = libs . object . keys ( o ) [ 0 ] ; libs . object . each ( o , 1 , function ( item , key ) { var value = func . call ( item , item ) ; if ( value <= minValue ) { min = item ; minValue = value ; minKey = key ; } } ) ; } return minKey ; }
121	function subscribe ( bundleIds , callbackFn ) { bundleIds = bundleIds . push ? bundleIds : [ bundleIds ] ; var depsNotFound = [ ] , i = bundleIds . length , numWaiting = i , fn , bundleId , r , q ; fn = function fn ( bundleId , pathsNotFound ) { if ( pathsNotFound . length ) depsNotFound . push ( bundleId ) ; numWaiting -- ; if ( ! numWaiting ) callbackFn ( depsNotFound ) ; } ; while ( i -- ) { bundleId = bundleIds [ i ] ; r = bundleResultCache [ bundleId ] ; if ( r ) { fn ( bundleId , r ) ; continue ; } q = bundleCallbackQueue [ bundleId ] = bundleCallbackQueue [ bundleId ] || [ ] ; q . push ( fn ) ; } }
2830	function ( newModel ) { var oldPos ; for ( var i = 0 ; i < newModel . length ; i ++ ) { oldPos = this . model . indexOf ( newModel [ i ] ) ; if ( oldPos >= 0 ) { if ( i != oldPos ) { this . moveTemplateNodes ( oldPos , i ) ; this . model . splice ( i , 0 , this . model . splice ( oldPos , 1 ) [ 0 ] ) ; } } else { if ( this . templateNodes [ i ] && newModel . indexOf ( this . model [ i ] ) == - 1 ) { this . model [ i ] = newModel [ i ] ; this . bindModel ( i ) ; } else { this . cloneTemplateNodes ( i ) ; this . model . splice ( i , 0 , newModel [ i ] ) ; this . bindModel ( i ) ; } } } if ( this . model . length > newModel . length ) { for ( var i = this . templateNodes . length - 1 ; newModel . length <= i ; i -- ) { this . unbindModel ( i ) ; this . removeTemplateNodes ( i ) ; } this . model . splice ( newModel . length , this . model . length - newModel . length ) ; } }
3477	function ( command ) { var name = 'align' + command . substring ( 7 ) ; var nodes = selection . isCollapsed ( ) ? [ dom . getParent ( selection . getNode ( ) , dom . isBlock ) ] : selection . getSelectedBlocks ( ) ; var matches = tinymce . map ( nodes , function ( node ) { return ! ! formatter . matchNode ( node , name ) ; } ) ; return tinymce . inArray ( matches , TRUE ) !== - 1 ; }
3789	function validateObjectEntity ( modelObject , entity , parents , errors ) { if ( ! errors ) errors = { } ; if ( ! errors . text ) errors . text = [ ] ; if ( ! parents ) parents = [ ] ; for ( var key in entity ) { var fieldName = parents + '.' + key ; if ( ! modelObject || ! modelObject [ key ] ) { if ( ! errors . notRequired ) errors . notRequired = [ ] ; errors . notRequired . push ( fieldName ) ; errors . text . push ( 'Field ' + fieldName + ' not required' ) ; } else if ( ! modelObject [ key ] . type ) { validateObjectEntity ( modelObject [ key ] , entity [ key ] , [ parents , key ] , errors ) ; } else if ( ! modelObject [ key ] . check ( entity [ key ] ) ) { if ( ! errors . notMatched ) errors . notMatched = { } ; errors . notMatched [ fieldName ] = modelObject [ key ] . type ; errors . text . push ( 'Field ' + fieldName + ' not matched with type ' + modelObject [ key ] . type ) ; } } return errors ; }
1535	function extend ( klass , instance , override , methods ) { var extendee = instance ? klass . prototype : klass ; initializeClass ( klass ) ; iterateOverObject ( methods , function ( name , method ) { var original = extendee [ name ] ; var existed = hasOwnProperty ( extendee , name ) ; if ( typeof override === 'function' ) { method = wrapNative ( extendee [ name ] , method , override ) ; } if ( override !== false || ! extendee [ name ] ) { defineProperty ( extendee , name , method ) ; } klass [ 'SugarMethods' ] [ name ] = { instance : instance , method : method , original : original , existed : existed } ; } ) ; }
1610	function writeCommonJSStub ( ast , ctx ) { ctx . newLineTop ( ) Object . keys ( ctx . usedRamdaFns ) . forEach ( function ( key ) { ctx . newLineTop ( ) ctx . writeTop ( 'var ' + key + ' = require(\'ramda/src/' + \' + key ) } ) '\')' \' ctx . newLine ( ) }
2126	function constructCredentials ( password , question , answer ) { var credentials = { } ; if ( password ) credentials . password = constructPassword ( password ) ; if ( question && answer ) credentials . recovery_question = constructRecoveryQuestion ( question , answer ) ; return credentials ; }
67	function trapFocus ( ) { var element = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : null ; var toggle = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; if ( ! is$1 . element ( element ) ) { return ; } var focusable = getElements . call ( this , 'button:not(:disabled), input:not(:disabled), [tabindex]' ) ; var first = focusable [ 0 ] ; var last = focusable [ focusable . length - 1 ] ; var trap = function trap ( event ) { if ( event . key !== 'Tab' || event . keyCode !== 9 ) { return ; } var focused = document . activeElement ; if ( focused === last && ! event . shiftKey ) { first . focus ( ) ; event . preventDefault ( ) ; } else if ( focused === first && event . shiftKey ) { last . focus ( ) ; event . preventDefault ( ) ; } } ; toggleListener . call ( this , this . elements . container , 'keydown' , trap , toggle , false ) ; }
2538	function mixin ( ctor , methods ) { var keyCopier = function ( key ) { ctor . prototype [ key ] = methods [ key ] ; } ; Object . keys ( methods ) . forEach ( keyCopier ) ; Object . getOwnPropertySymbols && Object . getOwnPropertySymbols ( methods ) . forEach ( keyCopier ) ; return ctor ; }
3129	function ( property , root , start , end ) { var values = this . extractValues ( property , root ) , length = values . length , sum = 0 , i ; start = start || 0 ; end = ( end || end === 0 ) ? end : length - 1 ; for ( i = start ; i <= end ; i ++ ) { sum += values [ i ] ; } return sum ; }
2512	function getPathAncestors ( filename ) { var tree = filename . split ( '/' ) ; tree . pop ( ) ; var treePath = [ ] ; for ( var i = 0 ; i < tree . length ; i ++ ) { treePath . push ( createId ( tree , i ) ) ; } function createId ( tree , count ) { var id = '' ; for ( var i = 0 ; i <= count ; i ++ ) { id += ( i > 0 ? '/' : '' ) + tree [ i ] ; } return id ; } return treePath ; }
17	function _tr_stored_block ( buf , stored_len , eof ) { send_bits ( ( STORED_BLOCK << 1 ) + ( eof ? 1 : 0 ) , 3 ) ; copy_block ( buf , stored_len , true ) ; }
192	function StatsDataLocalList ( options ) { if ( ! ( this instanceof StatsDataLocalList ) ) { return new StatsDataLocalList ( options ) ; } if ( 'string' !== typeof options . localStoreKey ) { throw new TypeError ( 'a options.localStoreKey must be passed in' ) ; } debug ( 'creating new local list' ) ; this . localStoreKey = options . localStoreKey ; this . limit = options . limit || 10 ; return this ; }
1973	function status ( ) { return fetch ( ` ${ STATUS_API } ` , { headers : { 'user-agent' : USER_AGENT , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => res . json ( ) ) . then ( ( sites ) => sites . reduce ( ( acc , val ) => { const hostname = Object . keys ( val ) [ 0 ] acc . push ( { hostname , color : val [ hostname ] , isAvailable : val [ hostname ] === 'green' || val [ hostname ] === 'yellow' , hasIssues : val [ hostname ] === 'yellow' || val [ hostname ] === 'red' } ) return acc } , [ ] ) ) }
2087	function dateToDateTime ( d ) { if ( d ) { var date = moment ( d ) ; if ( ! date . isValid ( ) ) return null ; return date . format ( 'YYYY-MM-DD HH:mm:ss' ) ; } else { return null ; } }
776	function $num ( byte ) { num = ( num << 8 ) | byte ; if ( ++ offset < 4 ) return $num ; offset = 0 ; emit ( { version : version , num : num } ) ; return $header ; }
3257	function ensureDefault ( val , def ) { if ( ( util_1 . isNullOrUndefined ( val ) || val === '' ) && ! chek_1 . isUndefined ( def ) ) return def ; return val ; }
2444	function validateOptions ( options ) { if ( options . includeSheets && options . excludeSheets ) { throw new Error ( "Do not pass both `includeSheets` and `excludeSheets`. It's confusing." ) } if ( options . includeSheets ) { if ( ! Array . isArray ( options . includeSheets ) ) options . includeSheets = [ options . includeSheets ] } if ( options . excludeSheets ) { if ( ! Array . isArray ( options . excludeSheets ) ) options . excludeSheets = [ options . excludeSheets ] } if ( options . excludeSheets && options . overrides ) { const overrides = Object . keys ( options . overrides ) overrides . forEach ( ( override ) => { if ( options . excludeSheets . indexOf ( override ) !== - 1 ) { console . warn ( ` \` ${ override } \` \` \` ` ) } } ) } return options }
2960	function authCtx ( req , res ) { let ctx = { accessToken : null , remotingContext : { req : req , res : res } } if ( req && req . accessToken ) ctx . accessToken = req . accessToken ; return ctx ; }
973	function initStyleProcessor ( opts ) { registerProcessor ( { name : 'wxss2css' , processor : 'postcss' , extnames : [ 'wxss' ] , rext : 'css' , options : opts || { plugins : [ wxssPlugin ] } } ) ; }
1306	function MakeBreakPoint ( source_position , opt_script_break_point ) { var break_point = new BreakPoint ( source_position , opt_script_break_point ) ; break_points . push ( break_point ) ; return break_point ; }
1974	function getProfileHistory ( profileId ) { return fetch ( ` ${ CORE_API } ${ profileId } ` , { headers : { 'user-agent' : USER_AGENT , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => { if ( res . status === 204 ) throw new Error ( ` ${ profileId } ` ) return res . json ( ) } ) }
2312	function resolve ( xhr , body , headers ) { const e = new ProgressEvent ( 'load' ) ; e . data = e . body = e . response = body ; e . headers = headers ; xhr . dispatchEvent ( e ) ; }
2313	function reject ( xhr , err , headers ) { const e = new ProgressEvent ( 'error' ) ; e . error = e . err = err ; e . headers = headers ; xhr . dispatchEvent ( e ) ; }
2633	function beforeEach ( test , context , done ) { context . dir = tmp . dirSync ( ) . name ; process . chdir ( context . dir ) ; done && done ( ) ; }
2053	function userHasAccess ( item ) { if ( typeof item . isSecure !== 'boolean' || item . isSecure === false ) { return true ; } else { var pageRoles = item . roles ; debug ( 'pageRoles' , item . title , pageRoles ) if ( Array . isArray ( pageRoles ) && pageRoles . length === 0 ) { if ( req . session . user ) { return true ; } else { return false } } if ( ! req . session . user || ! req . session . user . roleIds ) { return false ; } var userRoles = [ ] ; var sessionRoleIds = req . session . user . roleIds ; for ( var r in sessionRoleIds ) { userRoles . push ( sessionRoleIds [ r ] . toString ( ) ) ; } for ( var r in pageRoles ) { var pageRoleId = pageRoles [ r ] . toString ( ) ; if ( userRoles . indexOf ( pageRoleId ) !== - 1 ) { return true ; } } } return false ; }
1816	function _watchedEventsUnbindAll ( keepRegisteredEvents , context ) { var watchedEvents = getState ( '__watchedEvents' , context ) ; if ( watchedEvents ) { var data ; for ( var name in watchedEvents ) { if ( watchedEvents . hasOwnProperty ( name ) ) { data = watchedEvents [ name ] ; var target = getTarget ( data . target , context ) ; if ( target ) { target . off ( data . event , data . callback , data . context ) ; } } } if ( ! keepRegisteredEvents ) { setState ( { __watchedEvents : [ ] } , context ) ; } } }
2302	function ( lookup ) { var matches = tmplRegExp . exec ( lookup ) ; if ( matches ) { return { src : matches && matches [ 0 ] , prop : matches && matches [ 1 ] || matches [ 2 ] , } ; } else { return false ; } }
3112	function ( ) { var me = this , offsetParent = me . dom . offsetParent , y = me . getStyle ( 'top' ) ; if ( ! y || y === 'auto' ) { y = 0 ; } else if ( me . pxRe . test ( y ) ) { y = parseFloat ( y ) ; } else { y = me . getY ( ) ; if ( offsetParent ) { y -= Element . getY ( offsetParent ) ; } } return y ; }
3467	function ( transaction ) { return { action : transaction . action , method : transaction . method , data : transaction . data , type : 'rpc' , tid : transaction . id } ; }
3034	function ( ) { var me = this , req , status ; me . javascriptId = Ext . data . flash . BinaryXhr . registerConnection ( me ) ; req = { method : me . method , url : me . url , user : me . user , password : me . password , mimeType : me . mimeType , requestHeaders : me . requestHeaders , body : me . body , javascriptId : me . javascriptId } ; status = Ext . data . flash . BinaryXhr . flashPlugin . postBinary ( req ) ; }
647	function ( ) { var metaDesc = this . data . metaDesc ; if ( isEmpty ( metaDesc ) ) { metaDesc = this . opts . defaultValue . metaDesc ; } if ( this . hasPluggable ( ) ) { metaDesc = this . refObj . pluggable . _applyModifications ( "data_meta_desc" , metaDesc ) ; } if ( ! isEmpty ( this . opts . metaDescriptionDate ) && ! isEmpty ( metaDesc ) ) { metaDesc = this . opts . metaDescriptionDate + " - " + this . data . metaDesc ; } return stripSpaces ( metaDesc ) ; }
1783	function loadJsSuites ( _reporter , done ) { debug ( 'loadJsSuites' , jsSuites$1 ) ; var loaders = jsSuites$1 . map ( function ( file ) { return loadScript . bind ( util , file ) ; } ) ; parallel ( loaders , done ) ; }
457	function getStringsFromData ( props , axis ) { const isArrayOrIterable = Array . isArray ( props . data ) || Immutable . isIterable ( props . data ) ; if ( ! isArrayOrIterable ) { return [ ] ; } const key = props [ axis ] === undefined ? axis : props [ axis ] ; const accessor = Helpers . createAccessor ( key ) ; const data = props . data . reduce ( ( memo , d ) => { memo . push ( parseDatum ( d ) ) ; return memo ; } , [ ] ) ; const sortedData = sortData ( data , props . sortKey , props . sortOrder ) ; const dataStrings = sortedData . reduce ( ( dataArr , datum ) => { datum = parseDatum ( datum ) ; dataArr . push ( accessor ( datum ) ) ; return dataArr ; } , [ ] ) . filter ( ( datum ) => typeof datum === "string" ) ; return dataStrings . reduce ( ( prev , curr ) => { if ( curr !== undefined && curr !== null && prev . indexOf ( curr ) === - 1 ) { prev . push ( curr ) ; } return prev ; } , [ ] ) ; }
2635	function promiseShouldSucceed ( promise , done , handler ) { promise . then ( result => { handler ( result ) done ( ) } ) . catch ( error => done ( error ) ) }
2519	function ( fn , ctx ) { var task = ! ctx ? fn : fn . bind ( ctx ) ; this . writes . push ( task ) ; scheduleFlush ( this ) ; return task ; }
2909	function killPosix ( ) { getDescendentProcessInfo ( this . pid , ( err , descendent ) => { if ( err ) { return } descendent . forEach ( ( { PID : pid } ) => { try { process . kill ( pid ) } catch ( _err ) { } } ) } ) }
1883	function ( editor ) { var allowedSyntaxes = { 'html' : 1 , 'xml' : 1 , 'xsl' : 1 } ; var syntax = String ( editor . getSyntax ( ) ) ; if ( syntax in allowedSyntaxes ) { var content = String ( editor . getContent ( ) ) ; var tag = require ( 'htmlMatcher' ) . find ( content , editor . getCaretPos ( ) ) ; if ( tag && tag . type == 'tag' ) { var startTag = tag . open ; var contextNode = { name : startTag . name , attributes : [ ] } ; var tagTree = require ( 'xmlEditTree' ) . parse ( startTag . range . substring ( content ) ) ; if ( tagTree ) { contextNode . attributes = _ . map ( tagTree . getAll ( ) , function ( item ) { return { name : item . name ( ) , value : item . value ( ) } ; } ) ; } return contextNode ; } } return null ; }
493	function destroy ( ) { for ( var _key in this . plugins ) { this . unuse ( _key ) ; } this . binder . destroy ( ) ; delete this . binder ; this . dom . destroy ( ) ; delete this . dom ; this . kernel . destroy ( ) ; delete this . kernel ; delete this . vm ; delete this . plugins ; delete this . order ; }
2172	function getDisplayValue ( item ) { return $q . when ( getItemText ( item ) || item ) . then ( function ( itemText ) { if ( itemText && ! angular . isString ( itemText ) ) { $log . warn ( 'md-autocomplete: Could not resolve display value to a string. ' + 'Please check the `md-item-text` attribute.' ) ; } return itemText ; } ) ; function getItemText ( item ) { return ( item && $scope . itemText ) ? $scope . itemText ( getItemAsNameVal ( item ) ) : null ; } }
2119	function OktaAPISessions ( apiToken , domain , preview ) { if ( apiToken == undefined || domain == undefined ) { throw new Error ( "OktaAPI requires an API token and a domain" ) ; } this . domain = domain ; if ( preview == undefined ) this . preview = false ; else this . preview = preview ; this . request = new NetworkAbstraction ( apiToken , domain , preview ) ; }
1678	function tokenize ( content ) { var tokens = [ ] ; var parser = new htmlparser . Parser ( { onopentag : function ( name , attribs ) { } , ontext : function ( text ) { var start = parser . startIndex ; tokens . push ( { value : text , index : start , offset : text . length } ) ; } , onclosetag : function ( tagname ) { } } ) ; parser . write ( content ) ; parser . end ( ) ; return tokens ; }
1267	function cleanName ( name ) { name = getStr ( name ) . replace ( / ([^>]+>)?~?(.*) / , '$2' ) . replace ( / ^"[^"]+"\.?~?([^"]+)$ / , '$1' ) . replace ( / ^(module\.)?exports\. / , '' ) . replace ( / ^module: / , '' ) ; return fixBracket ( name ) ; }
2314	function instanceScopedDirective ( tar , dec , dname ) { if ( scopedChilds && scopedChilds . length && util . some ( scopedChilds , function ( item ) { return tar == item } ) ) return var drefs = tar . _diretives || [ ] if ( drefs && ~ util . indexOf ( drefs , dname ) ) return var def = _diretives [ dname ] var expr = _getAttribute ( tar , dec ) || '' drefs . push ( dec ) tar . _diretives = drefs _removeAttribute ( tar , dec ) var d = new Directive ( vm , tar , def , dec , expr , scope ) $directives . push ( d ) }
3187	function ( ) { var me = this , chart = me . chart , store = chart . getChartStore ( ) , data = store . data . items , count = me . getRecordCount ( ) , i , ln , record , min , max , xField = me . xField , xValue ; if ( count > 0 ) { min = Infinity ; max = - min ; for ( i = 0 , ln = data . length ; i < ln ; i ++ ) { record = data [ i ] ; xValue = record . get ( xField ) ; if ( xValue > max ) { max = xValue ; } if ( xValue < min ) { min = xValue ; } } if ( min == Infinity ) { min = 0 ; } if ( max == - Infinity ) { max = count - 1 ; } } else { min = max = 0 ; } return [ min , max ] ; }
3058	function enter ( node , parent ) { if ( ! node . body ) return ; for ( var i = 0 ; i < node . body . length ; i ++ ) { var append = [ ] . splice . bind ( node . body , i + 1 , 0 ) ; var current = node . body [ i ] ; var comment = [ ] . concat ( current . leadingComments , current . trailingComments ) ; for ( var j in comment ) { if ( ! comment [ j ] ) continue ; var test = parseComment ( comment [ j ] , append ) ; if ( test ) tests . push ( test ) ; } } }
2913	function ContractInstance ( config ) { _classCallCheck ( this , ContractInstance ) ; this . _config = config ; this . _contract = config . contract ; this . _web3 = this . _contract . _web3 ; this . _address = config . address ; this . _inst = this . contract . _contract . at ( this . _address ) ; this . _logger = { } ; for ( var logMethod in DUMMY_LOGGER ) { this . _logger [ logMethod ] = function ( logMethod , self ) { return function ( ) { self . contract . logger [ logMethod ] . apply ( self . contract . logger , [ '[' + self . address + ']: ' ] . concat ( Array . from ( arguments ) ) ) ; } ; } ( logMethod , this ) ; } }
2510	function readFile ( filePath , opts , callback , count ) { if ( arguments . length === 2 ) { callback = arguments [ 1 ] ; opts = null ; } if ( typeof callback !== 'function' ) throw new Error ( 'Wrong arguments' ) ; filePath = path . resolve ( filePath ) ; count = count || 0 ; var maxLimit = 5 ; fs . readFile ( filePath , opts , function ( err , data ) { if ( err ) { if ( count >= maxLimit ) callback ( new Error ( 'fsExt.readFie: max repeat limit reached' ) . cause ( err ) ) ; else setTimeout ( function ( ) { readFile ( filePath , opts , callback , count + 1 ) ; } , 500 ) ; } else callback ( null , data ) ; } ) ; }
766	function Config ( config ) { if ( ! config ) { config = path . join ( process . cwd ( ) , 'keycloak.json' ) ; } if ( typeof config === 'string' ) { this . loadConfiguration ( config ) ; } else { this . configure ( config ) ; } }
2129	function constructAppUserModel ( id , externalId , created , lastUpdated , scope , status , statusChanged , passwordChanged , syncState , lastSync , credentials , lastSync , links ) { var model = { } ; if ( id ) model . id = id ; if ( externalId ) model . externalId = externalId ; if ( created ) model . created = created ; if ( lastUpdated ) model . lastUpdated = lastUpdated ; if ( scope ) model . scope = scope ; if ( status ) model . status = status ; if ( statusChanged ) model . statusChanged = statusChanged ; if ( passwordChanged ) model . passwordChanged = passwordChanged ; if ( syncState ) model . syncState = syncState ; if ( lastSync ) model . lastSync = lastSync ; if ( credentials ) model . credentials = credentials ; if ( lastSync ) model . lastSync = lastSync ; if ( links ) model . links = links ; return model ; }
686	function ( newPaneOptions ) { var kb = UI . store var newInstance = newPaneOptions . newInstance if ( ! newInstance ) { let uri = newPaneOptions . newBase if ( uri . endsWith ( '/' ) ) { uri = uri . slice ( 0 , - 1 ) newPaneOptions . newBase = uri } newInstance = kb . sym ( uri ) } var contentType = mime . lookup ( newInstance . uri ) if ( ! contentType || ! contentType . includes ( 'html' ) ) { newInstance = $rdf . sym ( newInstance . uri + '.html' ) } newPaneOptions . newInstance = newInstance console . log ( 'New dokieli will make: ' + newInstance ) var htmlContents = DOKIELI_TEMPLATE var filename = newInstance . uri . split ( '/' ) . slice ( - 1 ) [ 0 ] filename = decodeURIComponent ( filename . split ( '.' ) [ 0 ] ) const encodedTitle = filename . replace ( / & / g , '&amp;' ) . replace ( / < / g , '&lt;' ) . replace ( / > / g , '&gt;' ) htmlContents = htmlContents . replace ( '<title>' , '<title>' + encodedTitle ) htmlContents = htmlContents . replace ( '</article>' , '<h1>' + encodedTitle + '</h1></article>' ) console . log ( '@@ New HTML for Dok:' + htmlContents ) return new Promise ( function ( resolve , reject ) { kb . fetcher . webOperation ( 'PUT' , newInstance . uri , { data : htmlContents , contentType : 'text/html' } ) . then ( function ( ) { console . log ( 'new Dokieli document created at ' + newPaneOptions . newInstance ) resolve ( newPaneOptions ) } ) . catch ( function ( err ) { console . log ( 'Error creating dokelili dok at ' + newPaneOptions . newInstance + ': ' + err ) } ) } ) }
35	function isSameException ( ex1 , ex2 ) { if ( isOnlyOneTruthy ( ex1 , ex2 ) ) return false ; ex1 = ex1 . values [ 0 ] ; ex2 = ex2 . values [ 0 ] ; if ( ex1 . type !== ex2 . type || ex1 . value !== ex2 . value ) return false ; if ( isBothUndefined ( ex1 . stacktrace , ex2 . stacktrace ) ) return false ; return isSameStacktrace ( ex1 . stacktrace , ex2 . stacktrace ) ; }
859	function toName ( type , path ) { const baseName = path . join ( "." ) return type === ReferenceTracker . CALL ? ` ${ baseName } ` : type === ReferenceTracker . CONSTRUCT ? ` ${ baseName } ` : baseName }
449	function createStringMap ( props , axis ) { const stringsFromAxes = getStringsFromAxes ( props , axis ) ; const stringsFromCategories = getStringsFromCategories ( props , axis ) ; const stringsFromData = getStringsFromData ( props , axis ) ; const allStrings = uniq ( [ ... stringsFromAxes , ... stringsFromCategories , ... stringsFromData ] ) ; return allStrings . length === 0 ? null : allStrings . reduce ( ( memo , string , index ) => { memo [ string ] = index + 1 ; return memo ; } , { } ) ; }
364	function isFixed ( element ) { var nodeName = element . nodeName ; if ( nodeName === 'BODY' || nodeName === 'HTML' ) { return false ; } if ( getStyleComputedProperty ( element , 'position' ) === 'fixed' ) { return true ; } var parentNode = getParentNode ( element ) ; if ( ! parentNode ) { return false ; } return isFixed ( parentNode ) ; }
2885	function createModule ( body , options ) { body = middleware . sanitize ( body ) if ( String ( options . parameterize ) !== 'false' ) { body = middleware . parameterise ( body ) } if ( options . module === "es6" || options . module === "es2015" ) { var module = 'export default ' + body + ';\n' ; } else \n { var module = 'module.exports = ' + body + ';\n' ; } }
1666	function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; resultObjs [ result . callbackId ] = result ; args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; vibration . getInstance ( ) . vibration_request ( result . callbackId , args ) ; result . noResult ( true ) ; }
3829	function parse ( code ) { try { var labels = { } ; var root = [ ] ; var manager = new BlockManager ( ) ; var lines = code . split ( '\n' ) ; \n for ( var i = 0 ; i < lines . length ; i ++ ) { try { var line = parseLine ( lines [ i ] . trim ( ) , i , labels , false , manager ) ; if ( line instanceof SyntaxError ) throw createLineError ( line , i ) ; if ( line . error instanceof SyntaxError ) throw createLineError ( line . error , i ) ; root [ i ] = line ; } catch ( ex ) { throw createLineError ( ex , i ) ; } } } return new AbstractSyntaxTree ( root , labels , manager ) ; }
3116	function ( rec ) { var me = this , node = me . getNode ( rec , true ) , el = me . el , adjustmentY = 0 , adjustmentX = 0 , elRegion = el . getRegion ( ) , nodeRegion ; elRegion . bottom = elRegion . top + el . dom . clientHeight ; elRegion . right = elRegion . left + el . dom . clientWidth ; if ( node ) { nodeRegion = Ext . fly ( node ) . getRegion ( ) ; if ( nodeRegion . top < elRegion . top ) { adjustmentY = nodeRegion . top - elRegion . top ; } else if ( nodeRegion . bottom > elRegion . bottom ) { adjustmentY = nodeRegion . bottom - elRegion . bottom ; } if ( nodeRegion . left < elRegion . left ) { adjustmentX = nodeRegion . left - elRegion . left ; } else if ( nodeRegion . right > elRegion . right ) { adjustmentX = nodeRegion . right - elRegion . right ; } if ( adjustmentX || adjustmentY ) { me . scrollBy ( adjustmentX , adjustmentY , false ) ; } el . focus ( ) ; } }
1687	function _contextPrev ( ) { if ( ! this . _contextState . prevSequence ) { return undefined ; } if ( ! this . _context . reverse ) { this . _contextState . prevSequence = this . _contextState . prevSequence . getPrevious ( ) ; if ( ! this . _contextState . prevSequence ) { return undefined ; } } var renderNode = this . _contextState . prevSequence . get ( ) ; if ( ! renderNode ) { this . _contextState . prevSequence = undefined ; return undefined ; } var prevSequence = this . _contextState . prevSequence ; if ( this . _context . reverse ) { this . _contextState . prevSequence = this . _contextState . prevSequence . getPrevious ( ) ; } if ( this . _contextState . lastRenderNode === renderNode ) { throw 'ViewSequence is corrupted, should never contain the same renderNode twice, index: ' + prevSequence . getIndex ( ) ; } this . _contextState . lastRenderNode = renderNode ; return { renderNode : renderNode , viewSequence : prevSequence , prev : true , index : -- this . _contextState . prevGetIndex } ; }
2905	function halt ( err , options ) { options = Object . assign ( { exitCode : 1 } , options ) if ( err ) { if ( err . code === 'EPIPE' ) { process . exit ( 0 ) } else { const t = require ( 'typical' ) printError ( t . isString ( err ) ? err : options . stack ? err . stack : err . message , options ) } } process . exit ( options . exitCode ) }
1725	function _createLayout ( ) { this . container = new ContainerSurface ( this . options . container ) ; this . container . setClasses ( this . classes ) ; this . layout = new LayoutController ( { layout : ProportionalLayout , layoutOptions : { ratios : [ ] } , direction : Utility . Direction . X } ) ; this . container . add ( this . layout ) ; this . add ( this . container ) ; }
1305	function DescribeChangeTree ( old_code_tree ) { function ProcessOldNode ( node ) { var child_infos = [ ] ; for ( var i = 0 ; i < node . children . length ; i ++ ) { var child = node . children [ i ] ; if ( child . status != FunctionStatus . UNCHANGED ) { child_infos . push ( ProcessOldNode ( child ) ) ; } } var new_child_infos = [ ] ; if ( node . textually_unmatched_new_nodes ) { for ( var i = 0 ; i < node . textually_unmatched_new_nodes . length ; i ++ ) { var child = node . textually_unmatched_new_nodes [ i ] ; new_child_infos . push ( ProcessNewNode ( child ) ) ; } } var res = { name : node . info . function_name , positions : DescribePositions ( node ) , status : node . status , children : child_infos , new_children : new_child_infos } ; if ( node . status_explanation ) { res . status_explanation = node . status_explanation ; } if ( node . textual_corresponding_node ) { res . new_positions = DescribePositions ( node . textual_corresponding_node ) ; } return res ; } function ProcessNewNode ( node ) { var child_infos = [ ] ; if ( false ) { for ( var i = 0 ; i < node . children . length ; i ++ ) { child_infos . push ( ProcessNewNode ( node . children [ i ] ) ) ; } } var res = { name : node . info . function_name , positions : DescribePositions ( node ) , children : child_infos , } ; return res ; } function DescribePositions ( node ) { return { start_position : node . info . start_position , end_position : node . info . end_position } ; } return ProcessOldNode ( old_code_tree ) ; }
2807	function loadImage ( image ) { $scope . $applyAsync ( function ( ) { if ( $scope . reversed ) $scope . flipContext ( ) ; $scope . signatureReady = true ; ctxBackground . clearRect ( 0 , 0 , canvas . width , canvas . height ) ; ctxBackground . drawImage ( image , 0 , 0 , canvasBackground . width , canvasBackground . height ) ; } ) ; }
934	function overrideObjectFunctions ( curr , old ) { if ( ! old ) { return curr ; } if ( ! curr && curr !== undefined ) { return old ; } let result = { } ; Object . keys ( curr ) . forEach ( k => { let v = curr [ k ] ; let oldV = old [ k ] ; if ( typeof v === 'function' && typeof oldV === 'function' ) { let currV = v ; v = function ( ... args ) { oldV . apply ( this , args ) ; currV . apply ( this , args ) ; } ; } result [ k ] = v ; } ) ; return result ; }
1188	function stdopts ( opts ) { opts = opts || { } opts . keys = opts . keys !== false opts . values = opts . values !== false return opts }
2687	function createKernelInfoResponseMessage ( parentMessage ) { var content = { language : 'javascript' , language_version : [ 1 , 0 ] , protocol_version : [ 4 , 1 ] } ; return newMessage ( _messageNames . kernelInfoResponse , parentMessage , content ) ; }
2877	function _taskFatalHandler_ ( e ) { var err = e ? ( e . stack || e . message || e ) : 'Unknown Error' ; grunt . fatal ( err , grunt . fail . code . TASK_FAILURE ) ; }
285	function shouldAddSympathy ( ) { if ( config . isEnabled ( 'force-sympathy' ) ) { return true ; } if ( config . isEnabled ( 'no-force-sympathy' ) ) { return false ; } if ( 'development' === process . env . NODE_ENV && Math . random ( ) < 0.25 ) { return true ; } return false ; }
667	function collectForms ( keyphrase , synonyms , language = "en" , morphologyData ) { const collectFormsWithMorphologyData = primeMorphologyData ( morphologyData ) ; return collectFormsWithMorphologyData ( keyphrase , synonyms , language ) ; }
2772	function ( rawValue ) { const value = stringifyInput ( rawValue ) ; if ( ! value . match ( FORMAT ) ) { throw new Error ( 'Invalid data format; expecting: \'' + \' + FORMAT + '\', found: \'' + \' ) ; } \' }
952	function makeDataObservable ( ctx ) { const data = ctx . data ; if ( ! data ) { return ; } if ( isPlainObject ( data ) ) { let observer = new Observer ( ctx , data ) ; Object . defineProperties ( ctx , proxyObject ( observer , data , ctx ) ) ; return observer ; } let err = new Error ( 'data require plain object' ) ; err . isTypeError = true ; throw err ; }
2749	function formatMessage ( message ) { var lines = message . split ( '\n' ) ; \n if ( ! lines [ 0 ] || ! lines [ 1 ] ) { return message ; } if ( lines [ 0 ] . lastIndexOf ( '!' ) !== - 1 ) { lines [ 0 ] = lines [ 0 ] . substr ( lines [ 0 ] . lastIndexOf ( '!' ) + 1 ) ; } if ( lines [ 1 ] . indexOf ( 'Module not found: ' ) === 0 ) { lines = [ lines [ 0 ] , lines [ 1 ] . replace ( 'Cannot resolve \'file\' or \'directory\' ' , \' ) . \' \' . \' '' , replace , ( 'Cannot resolve module ' , '' ) ] } replace ( 'Error: ' , '' ) '' }
579	function PageViewport_convertToViewportRectangle ( rect ) { var tl = Util . applyTransform ( [ rect [ 0 ] , rect [ 1 ] ] , this . transform ) ; var br = Util . applyTransform ( [ rect [ 2 ] , rect [ 3 ] ] , this . transform ) ; return [ tl [ 0 ] , tl [ 1 ] , br [ 0 ] , br [ 1 ] ] ; }
3415	function end ( ) { var transformed ; if ( ignore . some ( minimatch . bind ( null , file ) ) ) { var compiled = coffee . compile ( data , { sourceMap : true , generatedFile : file , inline : true , bare : options . bare , literate : isLiterate ( file ) } ) ; transformed = compiled . js ; } else { var instrumented = instrumentor . instrumentCoffee ( file , data ) ; var js = options . noInit ? instrumented . js : instrumented . init + instrumented . js ; transformed = js ; } this . queue ( transformed ) ; this . queue ( null ) ; }
2006	function ( sizeWatcher ) { var watchedElement = sizeWatcher . getWatchedElement ( ) ; if ( sizeWatcher === this . _adobeBlankSizeWatcher ) { this . _adobeBlankLoaded ( watchedElement ) ; } else { this . _elementSizeChanged ( watchedElement ) ; } }
3055	function ( ) { var me = this , task = me . stateTask ; if ( task ) { task . destroy ( ) ; me . stateTask = null ; } me . clearListeners ( ) ; }
2726	function calcStats ( ) { return { maxIdLength : Math . max ( ... Object . keys ( loggers ) . map ( ( l ) => l . length ) ) } ; }
2114	function makeOrdinal ( words ) { if ( ENDS_WITH_DOUBLE_ZERO_PATTERN . test ( words ) || ENDS_WITH_TEEN_PATTERN . test ( words ) ) { return words + 'th' ; } else if ( ENDS_WITH_Y_PATTERN . test ( words ) ) { return words . replace ( ENDS_WITH_Y_PATTERN , 'ieth' ) ; } else if ( ENDS_WITH_ZERO_THROUGH_TWELVE_PATTERN . test ( words ) ) { return words . replace ( ENDS_WITH_ZERO_THROUGH_TWELVE_PATTERN , replaceWithOrdinalVariant ) ; } return words ; }
3101	function ( ) { var me = this , ret = { minWidth : 20 , width : Ext . themeName === 'neptune' ? 70 : 60 , items : [ ] , enableOverflow : true } ; Ext . each ( this . quickStart , function ( item ) { ret . items . push ( { tooltip : { text : item . name , align : 'bl-tl' } , overflowText : item . name , iconCls : item . iconCls , module : item . module , handler : me . onQuickStartClick , scope : me } ) ; } ) ; return ret ; }
1035	function unHookSync ( rs ) { if ( ! rs . _dropboxOrigSync ) { return ; } rs . sync . sync = rs . _dropboxOrigSync ; delete rs . _dropboxOrigSync ; }
434	function createDomainFunction ( getDomainFromDataFunction , formatDomainFunction ) { getDomainFromDataFunction = isFunction ( getDomainFromDataFunction ) ? getDomainFromDataFunction : getDomainFromData ; formatDomainFunction = isFunction ( formatDomainFunction ) ? formatDomainFunction : formatDomain ; return ( props , axis ) => { const propsDomain = getDomainFromProps ( props , axis ) ; if ( propsDomain ) { return formatDomainFunction ( propsDomain , props , axis ) ; } const categories = Data . getCategories ( props , axis ) ; const domain = categories ? getDomainFromCategories ( props , axis , categories ) : getDomainFromDataFunction ( props , axis ) ; return domain ? formatDomainFunction ( domain , props , axis ) : undefined ; } ; }
975	function initProcessor ( options = { } , defaultBabelProcessorName ) { let { js , css , tpl , wxs } = options ; if ( tpl !== false ) { initTplProcessor ( tpl ) ; } if ( css !== false ) { initStyleProcessor ( css ) ; } if ( js !== false ) { initJsProcessor ( js , defaultBabelProcessorName ) ; } if ( wxs !== false ) { initWxsProcessor ( js , defaultBabelProcessorName ) ; } }
3273	function ( component , selector ) { if ( ! selector ) { return true ; } var selectors = selector . split ( ',' ) , length = selectors . length , i = 0 , query ; for ( ; i < length ; i ++ ) { selector = Ext . String . trim ( selectors [ i ] ) ; query = this . cache [ selector ] || ( this . cache [ selector ] = this . parse ( selector ) ) ; if ( query . is ( component ) ) { return true ; } } return false ; }
2582	function wordWrapToLength ( s , width , padleft , padright , omitFirst ) { if ( padright === undefined && padleft ) padright = padleft ; padleft = ! isNaN ( parseInt ( padleft , 10 ) ) ? parseInt ( padleft , 10 ) : 0 ; padright = ! isNaN ( parseInt ( padright , 10 ) ) ? parseInt ( padright , 10 ) : 0 ; var paddingLeft = '' ; for ( var n = 0 ; n < padleft ; n ++ ) paddingLeft += ' ' ; var cols = ! isNaN ( parseInt ( width , 10 ) ) ? length : 120 , arr = s . split ( ' ' ) , item = null , len = ! omitFirst ? cols - padright - padleft : cols - padright , str = ! omitFirst ? paddingLeft : '' , olen = cols - padright - padleft ; while ( ( item = arr . shift ( ) ) !== undefined ) { if ( item . length < len ) { str += item + ' ' ; len -= item . length + 1 ; } else if ( item . length > olen ) { str += item . substring ( 0 , len - 1 ) + '-\n' + \n ; paddingLeft arr . unshift ( item . substring ( len , item . length - 1 ) ) ; } else len = cols - padright - padleft ; } { str += '\n' + \n + paddingLeft + item ; ' ' } }
943	function queryComponentInstance ( ctx , id ) { let isSelectAll = Array . isArray ( id ) ; isSelectAll && ( id = id [ 0 ] ) ; let key = id . substr ( 1 ) ; return ctx . $child ( key ) ; }
3766	function create ( prototype , properties ) { Ctor . prototype = prototype || { } return properties ? copy ( new Ctor ( ) , properties ) : new Ctor ( ) }
1588	function categoryForCode ( code ) { code = parseInt ( code , 10 ) ; var result = null ; if ( code === 0 ) { result = 'all' ; } else if ( code === 1 ) { result = 'bold' ; } else if ( ( 2 < code && code < 5 ) ) { result = 'underline' ; } else if ( ( 4 < code && code < 7 ) ) { result = 'blink' ; } else if ( code === 8 ) { result = 'hide' ; } else if ( code === 9 ) { result = 'strike' ; } else if ( ( 29 < code && code < 38 ) || code === 39 || ( 89 < code && code < 98 ) ) { result = 'foreground-color' ; } else if ( ( 39 < code && code < 48 ) || code === 49 || ( 99 < code && code < 108 ) ) { result = 'background-color' ; } return result ; }
760	function validateNativeFormat ( data ) { const firstRow = data [ 0 ] ; const firstX = firstRow [ 0 ] ; if ( typeof firstX !== 'number' && ! utils . isDateLike ( firstX ) ) { throw new Error ( ` ${ typeof firstX } ${ firstX } ` ) ; } for ( let i = 1 ; i < firstRow . length ; i ++ ) { const val = firstRow [ i ] ; if ( val === null || val === undefined ) continue ; if ( typeof val === 'number' ) continue ; if ( utils . isArrayLike ( val ) ) continue ; throw new Error ( ` ${ typeof val } ${ val } ` ) ; } }
2229	function TemporaryCredentials ( params ) { AWS . Credentials . call ( this ) ; this . loadMasterCredentials ( ) ; this . expired = true ; this . params = params || { } ; if ( this . params . RoleArn ) { this . params . RoleSessionName = this . params . RoleSessionName || 'temporary-credentials' ; } this . service = new AWS . STS ( { params : this . params } ) ; }
3641	function ( key ) { var num = parseInt ( this . loadVar ( key ) ) ; if ( isNaN ( num ) ) { exitProcess ( 'the value of ' + key + ' is a necessary int ,but get ' + num , this . alarm ) ; return false ; } return num ; }
1608	function chunksToSourceMap ( chunks , cfg ) { var loc var outLine = 0 var outColumn = 0 var smap = sourcemap . newSourceMap ( ) var acc = '' chunks . forEach ( function ( chunk ) { if ( chunk . content === '\n' ) \n { outLine = outLine + 1 outColumn = 0 } loc = chunk . loc if ( loc ) { smap . add ( loc . firstLine - 1 , loc . firstColumn , outLine , outColumn ) } } ) if ( chunk . content !== '\n' ) \n }
2353	function ( datasetClientId , fields , callback ) { fields . id = datasetClientId ; return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doUpdateDatasetClient ) ( datasetClientId , fields , true , callback ) ; }
3576	function ( ) { if ( this . wrapItems ) { return new Iterator ( this . sort ( ) . _values . map ( function ( item ) { return item . value ; } ) ) ; } return new SjlMap . prototype . values . call ( this . sort ( ) ) ; }
2287	function getImageSize ( flickrJson , photo_id , photo_size ) { var sizeInfo = { "width" : 0 , "height" : 0 } ; var sizeTable = { "s" : "Square" , "q" : "Large Square" , "t" : "Thumbnail" , "m" : "Small" , "n" : "Small 320" , "-" : "Medium" , "z" : "Medium 640" , "c" : "Medium 800" , "b" : "Large" , "o" : "Original" } if ( flickrJson && flickrJson . sizes . size ) { for ( var i = 0 ; i < flickrJson . sizes . size . length ; i ++ ) { if ( flickrJson . sizes . size [ i ] . label == sizeTable [ photo_size ] ) { sizeInfo . width = flickrJson . sizes . size [ i ] . width ; sizeInfo . height = flickrJson . sizes . size [ i ] . height ; } } } return sizeInfo ; }
1060	function spell ( word ) { var self = this var dict = self . data var flags = self . flags var value = form ( self , word , true ) return { correct : self . correct ( word ) , forbidden : Boolean ( value && flag ( flags , 'FORBIDDENWORD' , dict [ value ] ) ) , warn : Boolean ( value && flag ( flags , 'WARN' , dict [ value ] ) ) } }
1062	function exact ( context , value ) { var data = context . data var flags = context . flags var codes = own . call ( data , value ) ? data [ value ] : null var compound var index var length if ( codes ) { return ! flag ( flags , 'ONLYINCOMPOUND' , codes ) } compound = context . compoundRules length = compound . length index = - 1 if ( value . length >= flags . COMPOUNDMIN ) { while ( ++ index < length ) { if ( value . match ( compound [ index ] ) ) { return true } } } return false }
1794	function ( ) { ! fs . existsSync ( __dirname + '/target' ) && fs . mkdirSync ( __dirname + '/target' ) ; ! fs . existsSync ( __dirname + '/target/e2e' ) && fs . mkdirSync ( __dirname + '/target/e2e' ) ; var reporterPath = path . resolve ( path . join ( __dirname , '/target/e2e' ) ) ; console . info ( 'The JUnit report will be generated into the following path:' , reporterPath ) ; jasmine . getEnv ( ) . addReporter ( new reporters . JUnitXmlReporter ( { 'savePath' : reporterPath , 'consolidate' : true , 'consolidateAll' : true } ) ) ; }
3817	function FunctionStatement ( name , args ) { if ( name [ name . length - 1 ] === '$' ) { this . type = 'string' ; this . name = name . substring ( 0 , name . length - 1 ) ; } else { this . type = 'number' ; this . name = name ; } var positions = util . findPositions ( args , [ { 'start' : '"' , 'end' : '"' } , { 'start' : '(' , 'end' : ')' } ] ) ; var argList = util . splitOutside ( args , "," , positions ) ; this . args = [ ] ; for ( var i = 0 ; i < argList . length ; i ++ ) { this . args . push ( new statements . ExpressionStatement ( argList [ i ] . trim ( ) ) ) ; } }
3175	function ( ) { this . addEvents ( 'change' , 'validitychange' , 'dirtychange' ) ; this . initValue ( ) ; var badNames = [ 'tagName' , 'nodeName' , 'children' , 'childNodes' ] , name = this . name ; if ( name && Ext . Array . indexOf ( badNames , name ) > - 1 ) { Ext . log . warn ( [ 'It is recommended to not use "' , name , '" as a field name, because it ' , 'can cause naming collisions during form submission.' ] . join ( '' ) ) ; } }
3676	function ( consumerKey , consumerSecret , applicationName , format , useCompression ) { this . eventHandlers = { } ; this . consumerKey = consumerKey ; this . consumerSecret = consumerSecret ; this . useCompression = useCompression || true ; this . format = format || "json" ; this . acceptEncoding = this . useCompression ? 'gzip, deflate' : 'identity' ; this . applicationName = applicationName ? ( applicationName + "/" ) : "" ; if ( ! this . consumerKey || ! this . consumerSecret ) { throw "ConsumerKey and ConsumerSecret should be specified in order to use SDK" ; } this . applicationName += this . tpl ( "JavaScript/{SDK_VERSION}/{format}" , { SDK_VERSION : this . SDK_VERSION , format : this . format } ) ; }
1497	function ScaleColumns ( colsByGroup , maxWidth , totalFlexGrow ) { angular . forEach ( colsByGroup , ( cols ) => { cols . forEach ( ( column ) => { if ( ! column . canAutoResize ) { maxWidth -= column . width ; totalFlexGrow -= column . flexGrow ; } else { column . width = 0 ; } } ) ; } ) ; var hasMinWidth = { } var remainingWidth = maxWidth ; do { let widthPerFlexPoint = remainingWidth / totalFlexGrow ; remainingWidth = 0 ; angular . forEach ( colsByGroup , ( cols ) => { cols . forEach ( ( column , i ) => { if ( column . canAutoResize && ! hasMinWidth [ i ] ) { let newWidth = column . width + column . flexGrow * widthPerFlexPoint ; if ( column . minWidth !== undefined && newWidth < column . minWidth ) { remainingWidth += newWidth - column . minWidth ; column . width = column . minWidth ; hasMinWidth [ i ] = true ; } else { column . width = newWidth ; } } } ) ; } ) ; } while ( remainingWidth !== 0 ) ; }
3371	function request ( url ) { return new Promise ( function ( resolve , reject ) { _request ( url , function ( error , response , body ) { if ( error ) return reject ( error ) ; resolve ( { response , body } ) } ) ; } ) ; }
3283	function createResolver ( options ) { return ( moduleId , base ) => new Promise ( ( resolve , reject ) => { const resolver = new Resolver ( options . resolver ? options . resolver : { } ) ; resolver . resolve ( moduleId , base , ( err , absolutePath ) => { if ( err ) { if ( options . debugVcjd ) debug ( ` ${ moduleId } \n \t ${ base } ` ) ; return reject ( err ) ; } if ( options . debugVcjd ) debug ( ` ${ moduleId } \n \t ${ base } \n \t ${ base } ` ) ; return resolve ( absolutePath ) ; } ) ; } ) }
626	function filterCombinations ( combinations , functionWords , language ) { combinations = filterFunctionWordsAnywhere ( combinations , specialCharacters ) ; combinations = filterOneCharacterWordCombinations ( combinations ) ; combinations = filterFunctionWords ( combinations , functionWords ) ; if ( language === "en" ) { combinations = filterEndingWith ( combinations , "'s" , [ ] ) ; } return combinations ; }
2487	function addListElementFontSize ( element ) { var hDataWeight = - 9007199254740992 ; var lDataWeight = 9007199254740992 ; $ . each ( element . find ( "li" ) , function ( ) { cDataWeight = getDataWeight ( this ) ; if ( cDataWeight == undefined ) { logWarning ( "No \"data-weight\" attribut defined on <li> element" ) ; } else \" } ) ; \" }
1472	async function ( libPath ) { let manifestPath = path . join ( libPath , "Manifest.json" ) ; let manifest = await this . parseJsonFile ( manifestPath ) ; let version ; try { version = manifest . info . version ; } catch ( e ) { throw new qx . tool . cli . Utils . UserError ( ` ` ) ; } if ( ! semver . valid ( version ) ) { throw new qx . tool . cli . Utils . UserError ( ` ${ manifestPath } ${ version } ` ) ; } return version ; }
3198	function extend ( a , b , noClone ) { a = a || { } ; if ( typeof a !== 'object' || typeof a . length !== 'undefined' ) { return b ; } if ( typeof b !== 'object' ) { return b ; } if ( ! noClone ) { a = clone ( a ) ; } var bk = Object . keys ( b ) ; for ( var i = 0 , c = bk . length ; i < c ; i ++ ) { var key = bk [ i ] ; if ( ! a . hasOwnProperty ( key ) || ! ( typeof b [ key ] === 'object' && typeof b [ key ] . length === 'undefined' ) && typeof b [ key ] !== 'function' ) { a [ key ] = b [ key ] ; } else { a [ key ] = extend ( a [ key ] , b [ key ] ) ; } } return a ; }
2907	function CompositeError ( message , innerErrors ) { this . message = message ; this . name = 'CompositeError' ; this . innerErrors = normalizeInnerErrors ( innerErrors ) ; Error . captureStackTrace ( this , this . constructor ) ; this . originalStackDescriptor = Object . getOwnPropertyDescriptor ( this , 'stack' ) ; Object . defineProperty ( this , 'stack' , { get : function ( ) { return this . formatStackTraces ( ) ; } } ) ; }
1490	function ( from , to ) { return new Promise ( ( resolve , reject ) => { util . mkParentPath ( to , function ( ) { var rs = fs . createReadStream ( from , { flags : "r" , encoding : "binary" } ) ; var ws = fs . createWriteStream ( to , { flags : "w" , encoding : "binary" } ) ; rs . on ( "end" , function ( ) { resolve ( ) ; } ) ; rs . on ( "error" , reject ) ; ws . on ( "error" , reject ) ; rs . pipe ( ws ) ; } ) ; } ) ; }
2796	function findByIdQueryParams ( request , config ) { return typeof config . baseQuery === 'undefined' ? { 'id' : request . params . id } : _ . merge ( { 'id' : request . params . id } , underscore ( config . baseQuery ( request ) ) ) }
1133	function jscoverage_endLengthyOperation ( ) { var progressBar = document . getElementById ( 'progressBar' ) ; ProgressBar . setPercentage ( progressBar , 100 ) ; setTimeout ( function ( ) { jscoverage_inLengthyOperation = false ; progressBar . style . visibility = 'hidden' ; var progressLabel = document . getElementById ( 'progressLabel' ) ; progressLabel . style . visibility = 'hidden' ; progressLabel . innerHTML = '' ; var tabs = document . getElementById ( 'tabs' ) . getElementsByTagName ( 'div' ) ; var i ; for ( i = 0 ; i < tabs . length ; i ++ ) { tabs . item ( i ) . style . cursor = '' ; } } , 50 ) ; }
3668	function SavespriteCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 2 ) throw new SyntaxError ( 'SAVESPRITE command requires 2 arguments' ) ; this . id = parsed . args [ 0 ] ; this . fileName = parsed . args [ 1 ] ; }
235	function recordOrderInGoogleAnalytics ( cart , orderId ) { if ( ! isAdTrackingAllowed ( ) ) { debug ( 'recordOrderInGoogleAnalytics: skipping as ad tracking is disallowed' ) ; return ; } const transaction = { id : orderId , affiliation : 'WordPress.com' , revenue : cart . total_cost , currency : cart . currency , } ; debug ( 'recordOrderInGoogleAnalytics: ga ecommerce add transaction' , transaction ) ; window . ga ( 'ecommerce:addTransaction' , transaction ) ; }
2348	function diffRecords ( localRecords , newRecords ) { var recordsDiff = { } ; _ . each ( newRecords , function ( record , uid ) { if ( localRecords [ uid ] ) { if ( localRecords [ uid ] . hash !== record . hash ) { record . op = "update" ; recordsDiff [ uid ] = record ; } } else { record . op = "update" ; recordsDiff [ uid ] = record ; } } ) ; _ . each ( localRecords , function ( record , uid ) { if ( ! newRecords [ uid ] ) { record . op = "delete" ; recordsDiff [ uid ] = record ; } } ) ; return recordsDiff ; }
948	function removeComments ( t , path , type ) { let commentPaths = path . get ( type ) ; if ( ! commentPaths || ! commentPaths . length ) { return ; } let isLeadingType = type === LEADING_COMMENT_TYPE ; if ( isLeadingType ) { let parentPath = path . parentPath ; let isParentProgram = parentPath && t . isProgram ( parentPath . node ) ; if ( isParentProgram ) { parentPath . addComments ( 'leading' , commentPaths . map ( item => item . node ) ) ; } } commentPaths . forEach ( item => item . remove ( ) ) ; }
2160	function configFromString ( config ) { var matched = aspNetJsonRegex . exec ( config . _i ) ; if ( matched !== null ) { config . _d = new Date ( + matched [ 1 ] ) ; return ; } configFromISO ( config ) ; if ( config . _isValid === false ) { delete config . _isValid ; utils_hooks__hooks . createFromInputFallback ( config ) ; } }
893	function addBuiltinPlugin ( pluginName , appType , plugins , insertAtTop ) { let pluginInfo = BUILTIN_PLUGINS [ pluginName ] ; if ( typeof pluginInfo === 'object' ) { pluginInfo = pluginInfo [ appType ] || pluginInfo . default ; } pluginInfo = normalizeViewPlugins ( [ pluginInfo ] , appType ) [ 0 ] ; let plugin = Array . isArray ( pluginInfo ) ? pluginInfo [ 0 ] : pluginInfo ; let hasBuiltinPlugin = plugins . some ( item => ( plugin === ( Array . isArray ( item ) ? item [ 0 ] : item ) ) ) ; if ( ! hasBuiltinPlugin ) { plugins [ insertAtTop ? 'unshift' : 'push' ] ( pluginInfo ) ; } }
1681	function parseFile ( input ) { fileContent = fs . readFileSync ( input , { encoding : "utf-8" } ) ; var ext = path . extname ( input ) ; if ( ext == '.html' ) return tokenizeHTML ( fileContent ) ; return fileContent ; }
889	function removeUnUseDecl ( decl , toRemovePropName ) { let nodes = decl . parent . nodes ; let currIdx = nodes . indexOf ( decl ) ; for ( let i = currIdx - 1 ; i >= 0 ; i -- ) { let item = nodes [ i ] ; if ( item . type === 'decl' && item . prop === toRemovePropName ) { item . remove ( ) ; } } }
586	function onWindowKeyPressed ( event ) { ctrlDown = event . ctrlKey ; if ( ! ctrlDown ) { drag . start . x = null ; drag . start . y = null ; } }
2989	function _embedGetter ( self , fields , embedGetter , key ) { let allOpts = [ ] ; self . res . locals . emiter . emit ( 'get-options' , embedGetter , allOpts ) ; if ( allOpts ) { allOpts . forEach ( function ( obj ) { obj . embedIn = key ; } ) ; fields . push ( ... allOpts ) ; } }
3807	function init ( pathToModels , cb , addToSwagger ) { modelPath = pathToModels ; glob ( modelPath + '/**/*.js' , function ( err , files ) { if ( err ) return cb && cb ( err ) ; files . forEach ( function ( file ) { var Model = require ( file ) ( ) , modelSwagger = null ; if ( Model . init ) { Model . init ( ) ; } modelSwagger = Model . getSwagger ( ) ; if ( modelSwagger && addToSwagger ) { modelSwagger . forEach ( function ( swaggerResource ) { swagger [ swaggerMethodName [ swaggerResource . spec . method . toLowerCase ( ) ] ] ( swaggerResource ) ; } ) ; } models . push ( Model ) ; } ) ; return cb && cb ( null , models ) ; } ) ; }
3276	function getVinylFiles ( files , options ) { return Promise . all ( files . map ( file => getVinylFile ( file , options ) ) ) ; }
714	function sha1 ( buffer , offset , length ) { offset = offset || 0 ; length = length || buffer . length ; var subArray = dicomParser . sharedCopy ( buffer , offset , length ) ; var rusha = new Rusha ( ) ; return rusha . digest ( subArray ) ; }
1617	function registerAction ( resource ) { return client . sendCommand ( { id : Lime . Guid ( ) , method : Lime . CommandMethod . SET , type : 'application/vnd.iris.eventTrack+json' , uri : '/event-track' , resource : resource } ) . catch ( e => console . log ( e ) ) ; }
2259	function run ( options ) { if ( options . results ) { return map ( options ) ; } return fetch ( options ) . then ( map . bind ( null , options ) ) ; }
1649	function ( val ) { var self = this ; console . log ( "zooming to " + val + "..." ) ; self . pix_per_sec = val ; self . render ( ) ; }
2923	function pickTemplate ( templateName ) { if ( templateName === THE_ONLY_TEMPLATE ) return theOnlyTemplate . promise ; if ( registry . hasOwnProperty ( templateName ) ) return registry [ templateName ] . promise ; if ( registryComplete ) throw noSuchTemplate ( templateName ) ; return ( registry [ templateName ] = new Deferred ( ) ) . promise ; }
3557	function defineSubClassPure ( superClass , constructor , methods , statics ) { var normalizedArgs = normalizeArgsForDefineSubClass . apply ( null , arguments ) , _superClass = normalizedArgs . superClass , _statics = normalizedArgs . statics , _constructor = normalizedArgs . constructor , _methods = normalizedArgs . methods ; _constructor . prototype = Object . create ( _superClass . prototype ) ; Object . defineProperty ( _constructor . prototype , 'constructor' , { value : _constructor } ) ; extend ( _constructor . prototype , _methods ) ; extend ( _constructor , _statics , true ) ; return _constructor ; }
2388	function ( iterator , context ) { var list = new ArrayList ; return list . add ( _ . map ( this , iterator , context ) ) ; }
1752	function loader ( content ) { const { addDependency , resource , resourcePath } = this ; const callback = this . async ( ) ; const { iconName , publicPath , sprite , svgoOptions } = Object . assign ( { } , DEFAULT_LOADER_OPTIONS , loaderUtils . getOptions ( this ) ) ; addDependency ( resourcePath ) ; imagemin . buffer ( content , { plugins : [ imageminSvgo ( svgoOptions ) , ] , } ) . then ( ( content ) => { const name = loaderUtils . interpolateName ( this , iconName , { content } ) ; const icon = sprite . addIcon ( resource , name , content . toString ( ) ) ; const hasSamePath = sprite . originalResourcePath === sprite . resourcePath ; setImmediate ( ( ) => { callback ( null , ` ${ publicPath ? ` ${ publicPath } ` : '__webpack_public_path__' } ${ icon . getUrlToSymbol ( ) } ${ icon . getUrlToView ( ) } ${ process . env . NODE_ENV !== 'production' && hasSamePath ? ` ${ icon . getUrlToSymbol ( true ) } ${ icon . getUrlToView ( true ) } ` : '' } ${ icon . getDocument ( ) . getViewBox ( ) } ${ icon . getDocument ( ) . getTitle ( ) } ` ) ; } ) ; } ) . catch ( ( err ) => { setImmediate ( ( ) => callback ( err ) ) ; } ) ; }
825	function ( ) { if ( arguments . length > 0 ) { for ( var i = 0 ; i < arguments . length ; i ++ ) { chain . push ( arguments [ i ] ) ; } group = chain [ chain . length - 1 ] ; } else group = false ; advance_exec_cursor ( ) ; return chainedAPI ; }
1483	function scanDir ( rootDir , dir , resource , doNotCopy , callback ) { fs . readdir ( dir , function ( err , files ) { if ( err ) { callback ( err ) ; return ; } async . forEach ( files , function ( file , callback ) { var absFile = path . join ( dir , file ) ; fs . stat ( absFile , function ( err , stat ) { if ( err ) { callback ( err ) ; return ; } if ( stat . isDirectory ( ) ) { scanDir ( rootDir , absFile , resource , doNotCopy , callback ) ; } else { var relFile = absFile . substring ( rootDir . length + 1 ) . replace ( / \\ / g , "/" ) ; var fileInfo = resources [ relFile ] ; delete unconfirmed [ relFile ] ; if ( ! fileInfo ) { fileInfo = resources [ relFile ] = { } ; } fileInfo . doNotCopy = doNotCopy ; fileInfo . resource = resource ; t . __librariesByResourceUri [ relFile ] = library ; var relDir = dir . substring ( rootDir . length + 1 ) . replace ( / \\ / g , "/" ) ; t . __librariesByResourceFolderUri [ relDir ] = library ; var tmp = "" ; relDir . split ( "/" ) . forEach ( seg => { if ( tmp . length ) { tmp += "/" ; } tmp += seg ; t . __librariesByResourceFolderUri [ tmp ] = library ; } ) ; var handlers = t . __handlers . filter ( handler => handler . matches ( absFile ) ) ; if ( ! handlers . length ) { callback ( ) ; return ; } if ( handlers . some ( handler => handler . needsCompile ( absFile , fileInfo , stat ) ) ) { fileInfo . mtime = stat . mtime ; tasks . push ( { fileInfo : fileInfo , absFile : absFile , library : library , handlers : handlers } ) ; } callback ( ) ; } } ) ; } , callback ) ; } ) ; }
2705	function initialize ( shell ) { shell . loadedExtensions = { } ; shell . registerCommand ( 'extension' , extensionCommand ) ; shell . registerCommand ( 'extensions' , extensionsCommand ) ; }
1201	function ( command ) { var obj = wysihtml5 . commands [ command ] , method = obj && obj . value ; if ( method ) { return method . call ( obj , this . composer , command ) ; } else { try { return this . doc . queryCommandValue ( command ) ; } catch ( e ) { return null ; } } }
1367	function ( identifier , data , config , cb ) { var path = api . getPathWithData ( baseURL , identifier , listLogsPath , data ) ; api . get ( path , config , cb ) ; }
1429	function ( key , value ) { if ( typeof key == "object" ) { var map = key ; for ( key in map ) { this . __environmentChecks [ key ] = map [ key ] ; } } else if ( value === undefined ) { delete this . __environmentChecks [ key ] ; } else { this . __environmentChecks [ key ] = value ; } }
687	function ( subject ) { var kb = UI . store var ns = UI . ns var t = kb . findTypeURIs ( subject ) if ( t [ ns . ldp ( 'Resource' ) . uri ] ) return 'Sharing' if ( t [ ns . ldp ( 'Container' ) . uri ] ) return 'Sharing' if ( t [ ns . ldp ( 'BasicContainer' ) . uri ] ) return 'Sharing' return null }
2074	function sauceConfigured ( config ) { var sauceAccessKey = config . access_key var sauceUsername = config . username if ( ! sauceAccessKey || ! sauceUsername ) { return false } return true }
2875	function hilbertIndexInverse ( dim , index , options ) { options = options || { } var entry = options . entry || 0 , direction = options . direction || 0 , m = curvePrecision ( index , dim ) , p = Array . apply ( null , new Array ( dim ) ) . map ( Number . prototype . valueOf , 0 ) for ( var i = m - 1 ; i >= 0 ; i -- ) { var mask = 1 << ( i * dim ) , bits = 0 , code for ( var k = dim - 1 ; k >= 0 ; k -- ) { if ( index & ( mask << k ) ) { bits |= ( 1 << k ) } } code = grayInverseTransform ( entry , direction , grayCode ( bits ) , dim ) for ( var k = 0 ; k < dim ; k ++ ) { if ( code & ( 1 << k ) ) { p [ k ] |= ( 1 << i ) } } entry = entry ^ bitwise . rotateLeft ( entrySequence ( bits ) , dim , 0 , direction + 1 ) direction = ( direction + directionSequence ( bits , dim ) + 1 ) % dim } return p }
1288	function ArrayCopyWithin ( target , start , end ) { CHECK_OBJECT_COERCIBLE ( this , "Array.prototype.copyWithin" ) ; var array = TO_OBJECT ( this ) ; var length = TO_LENGTH ( array . length ) ; return InnerArrayCopyWithin ( target , start , end , array , length ) ; }
2124	function lengthBytesUTF32 ( str ) { var len = 0 ; for ( var i = 0 ; i < str . length ; ++ i ) { var codeUnit = str . charCodeAt ( i ) ; if ( codeUnit >= 0xD800 && codeUnit <= 0xDFFF ) ++ i ; len += 4 ; } return len ; }
3258	function isLikeNumber ( val ) { return constants_1 . LIKE_HEX_NUMBER . test ( val ) || constants_1 . LIKE_NUMBER . test ( val ) ; }
2094	function _zero ( _arg , _cb ) { if ( ! _arg . create ) { _cb ( ) ; return ; } var now = new Date ( ) . toUTCString ( ) ; var info = { extension : 'bin' , type : 'application/octet-stream' , parent : path . dirname ( p ) , size : 0 , headers : { 'last-modified' : now } } ; var opts = { } ; if ( _arg . exclusive ) { opts . flag = 'wx' ; } else { opts . flag = 'w' ; } self . _stat ( p , info , function ( s_err , stats ) { if ( s_err ) { _cb ( s_err ) ; return ; } fs . writeFile ( stats . _cacheFile , new Buffer ( 0 ) , opts , function ( err ) { if ( err ) { _cb ( err ) ; return ; } self . cache . dirty ( p , stats . _fhandle , function ( d_err ) { if ( d_err ) { log . warn ( d_err , 'dirty(%s): failed' , p ) ; _cb ( d_err ) ; } else { self . cache . add_to_pdir ( p , _cb ) ; } } ) ; } ) ; } ) ; }
2138	function pass ( part , suiteIndex , testIndex ) { var o ; var isSuite = false ; if ( typeof testIndex === 'number' ) { o = suites [ suiteIndex ] . tests [ testIndex ] ; } else { isSuite = true ; o = suites [ suiteIndex ] ; } display . pass ( part , o ) ; if ( isSuite ) { if ( part === 'setup' ) { o . setup . status = true ; if ( ! testIndex ) { testIndex = 0 ; } else { testIndex = testIndex + 1 ; } if ( typeof o . tests [ testIndex ] === 'object' ) { run ( 'beforeEach' , suiteIndex , testIndex ) ; } else { run ( 'takedown' , suiteIndex ) ; } } else if ( part === 'takedown' ) { o . takedown . status = true ; if ( o . next ) { run ( 'setup' , suiteIndex + 1 ) ; } else { showSummary ( ) ; } } } else { if ( part === 'beforeEach' ) { o . beforeEach . status = true ; run ( 'setup' , suiteIndex , testIndex ) ; } else if ( part === 'setup' ) { o . setup . status = true ; run ( 'actual' , suiteIndex , testIndex ) ; } else if ( part === 'takedown' ) { o . takedown . status = true ; run ( 'afterEach' , suiteIndex , testIndex ) ; } else if ( part === 'afterEach' ) { o . afterEach . status = true ; if ( typeof o . parent . tests [ testIndex + 1 ] === 'object' ) { o . parent . testIndex = testIndex + 1 ; run ( 'beforeEach' , suiteIndex , testIndex + 1 ) ; } else { run ( 'takedown' , suiteIndex ) ; } } else { o . status = true ; run ( 'takedown' , suiteIndex , testIndex ) ; } } }
2443	function process ( rawXLSX , options ) { options = options || { } options = validateOptions ( options ) const defaultProcessor = options . processor || 'keyvalue' const overrides = options . overrides || { } const workbook = rawXLSX instanceof Buffer ? XLSX . read ( rawXLSX , { type : 'buffer' } ) : XLSX . readFile ( rawXLSX ) let sheets = workbook . SheetNames if ( options . includeSheets ) { sheets = sheets . filter ( ( s ) => options . includeSheets . indexOf ( s ) !== - 1 ) } if ( options . excludeSheets ) { sheets = sheets . filter ( ( s ) => options . excludeSheets . indexOf ( s ) === - 1 ) } let payload = { } sheets . forEach ( function ( sheet ) { const processor = overrides . hasOwnProperty ( sheet ) ? overrides [ sheet ] : defaultProcessor payload [ sheet ] = getProcessor ( processor ) ( workbook . Sheets [ sheet ] ) } ) return payload }
1422	function ( className ) { let t = this ; if ( ! t . __classes ) { t . __classes = [ ] ; } if ( t . __classes . indexOf ( className ) == - 1 ) { t . __classes . push ( className ) ; } }
672	function ( sentence , transitionWords ) { sentence = normalizeSingleQuotes ( sentence ) ; return transitionWords . filter ( word => matchWordInSentence ( word , sentence ) ) ; }
883	function transformFilterInAttribute ( element , tplOpts , options ) { let attrs = element . attribs ; let filterAttrs = element . _hasFilterAttrs ; if ( ! filterAttrs || ! filterAttrs . length ) { return ; } let { logger , file } = tplOpts ; let { filters } = options ; filterAttrs . forEach ( k => { let value = attrs [ k ] ; attrs [ k ] = updateFilterCall ( filters , logger , file , value ) ; } ) ; }
2383	function ( element ) { for ( var i = 0 , len = this . length ; i < len ; i ++ ) { if ( element === this [ i ] ) { return true ; } } return false ; }
2827	function rte ( src , dest , data ) { if ( typeof dest === 'object' ) { data = dest ; dest = src ; } var rte = new Rte ( src , data ) ; return rte . stringify ( dest ) ; }
529	function ( v , date1904 ) { if ( date1904 ) v += 1462 ; var epoch = Date . parse ( v ) ; var result = ( epoch - new Date ( Date . UTC ( 1899 , 11 , 30 ) ) ) / ( 24 * 60 * 60 * 1000 ) ; return Math . floor ( result ) ; }
597	function DeviationFragment ( options ) { this . _location = options . location ; this . _fragment = options . word ; this . _syllables = options . syllables ; this . _regex = null ; this . _options = pick ( options , [ "notFollowedBy" , "alsoFollowedBy" ] ) ; }
190	function newsletterSettingsSubmitError ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT_FAILURE : const error = WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT_FAILURE === action . type ? action . error : false ; return error ; } return state ; }
2712	function getFormData ( ) { var form = this . form ; var selector = [ 'input' , 'select' , 'textarea' ] . join ( ',' ) ; return [ ] . slice . call ( form . querySelectorAll ( selector ) ) . filter ( Mailto . formDataFilter ) . map ( Mailto . formDataMapper ( form ) ) ; }
1239	function ( expr ) { let result , offset ; const node = this . node ( "offsetlookup" ) ; if ( this . token === "[" ) { offset = this . next ( ) . read_expr ( ) ; if ( this . expect ( "]" ) ) this . next ( ) ; result = node ( expr , offset ) ; } else if ( this . token === this . tok . T_DOLLAR_OPEN_CURLY_BRACES ) { offset = this . read_encapsed_string_item ( false ) ; result = node ( expr , offset ) ; } return result ; }
2	function deserializeValue ( value ) { try { return value ? value == "true" || ( value == "false" ? false : value == "null" ? null : + value + "" == value ? + value : / ^[\[\{] / . test ( value ) ? $ . parseJSON ( value ) : value ) : value } catch ( e ) { return value } }
1635	function ( el ) { var className = el . className var listClass = className . split ( ' ' ) this . classList = listClass this . el = el }
3406	function ( menuItem , e ) { var me = this , menu = menuItem . parentMenu , hdr = menu . activeHeader , view = me . view , store = view . store ; delete me . lastGroupIndex ; me . block ( ) ; me . enable ( ) ; store . group ( hdr . dataIndex ) ; me . pruneGroupedHeader ( ) ; me . unblock ( ) ; me . refreshIf ( ) ; }
387	function getCode ( filePath ) { const cachedCode = esm . compiler . getCached ( filePath ) ; if ( cachedCode ) { return cachedCode ; } if ( ! fs . existsSync ( filePath ) ) { throw new Error ( ` ${ filePath } ` ) ; } const code = fs . readFileSync ( filePath , 'utf-8' ) ; return esm . compiler . compile ( filePath , code ) ; }
2166	function positionDropdown ( ) { if ( ! elements ) { return $mdUtil . nextTick ( positionDropdown , false , $scope ) ; } var dropdownHeight = ( $scope . dropdownItems || MAX_ITEMS ) * ITEM_HEIGHT ; var hrect = elements . wrap . getBoundingClientRect ( ) , vrect = elements . snap . getBoundingClientRect ( ) , root = elements . root . getBoundingClientRect ( ) , top = vrect . bottom - root . top , bot = root . bottom - vrect . top , left = hrect . left - root . left , width = hrect . width , offset = getVerticalOffset ( ) , position = $scope . dropdownPosition , styles ; if ( ! position ) { position = ( top > bot && root . height - top - MENU_PADDING < dropdownHeight ) ? 'top' : 'bottom' ; } if ( $attrs . mdFloatingLabel ) { left += INPUT_PADDING ; width -= INPUT_PADDING * 2 ; } styles = { left : left + 'px' , minWidth : width + 'px' , maxWidth : Math . max ( hrect . right - root . left , root . right - hrect . left ) - MENU_PADDING + 'px' } ; if ( position === 'top' ) { styles . top = 'auto' ; styles . bottom = bot + 'px' ; styles . maxHeight = Math . min ( dropdownHeight , hrect . top - root . top - MENU_PADDING ) + 'px' ; } else { var bottomSpace = root . bottom - hrect . bottom - MENU_PADDING + $mdUtil . getViewportTop ( ) ; styles . top = ( top - offset ) + 'px' ; styles . bottom = 'auto' ; styles . maxHeight = Math . min ( dropdownHeight , bottomSpace ) + 'px' ; } elements . $ . scrollContainer . css ( styles ) ; $mdUtil . nextTick ( correctHorizontalAlignment , false ) ; function getVerticalOffset ( ) { var offset = 0 ; var inputContainer = $element . find ( 'md-input-container' ) ; if ( inputContainer . length ) { var input = inputContainer . find ( 'input' ) ; offset = inputContainer . prop ( 'offsetHeight' ) ; offset -= input . prop ( 'offsetTop' ) ; offset -= input . prop ( 'offsetHeight' ) ; offset += inputContainer . prop ( 'offsetTop' ) ; } return offset ; } function correctHorizontalAlignment ( ) { var dropdown = elements . scrollContainer . getBoundingClientRect ( ) , styles = { } ; if ( dropdown . right > root . right - MENU_PADDING ) { styles . left = ( hrect . right - dropdown . width ) + 'px' ; } elements . $ . scrollContainer . css ( styles ) ; } }
3486	function ( el , prefix ) { var me = this , sandboxPrefix = '' ; el = Ext . getDom ( el , true ) || { } ; if ( el === document ) { el . id = me . documentId ; } else if ( el === window ) { el . id = me . windowId ; } if ( ! el . id ) { if ( me . isSandboxed ) { sandboxPrefix = Ext . sandboxName . toLowerCase ( ) + '-' ; } el . id = sandboxPrefix + ( prefix || "ext-gen" ) + ( ++ Ext . idSeed ) ; } return el . id ; }
1581	function startWatcher ( entryPoint , callback ) { if ( config . commands . build . dev ) { rimraf ( path . join ( createAndGetBuildFolder ( ) , 'css' ) , ( ) => { installDevelopmentWatcher ( entryPoint , callback ) } ) } else { installWatcher ( entryPoint , callback ) } }
702	function ( subject ) { var kb = UI . store var n = kb . each ( undefined , ns . rdf ( 'type' ) , subject ) . length if ( n > 0 ) return 'List (' + n + ')' return null }
2060	function ( toolKey ) { delete taTools [ toolKey ] ; angular . forEach ( toolbars , function ( toolbarScope ) { delete toolbarScope . tools [ toolKey ] ; for ( var i = 0 ; i < toolbarScope . toolbar . length ; i ++ ) { var toolbarIndex ; for ( var j = 0 ; j < toolbarScope . toolbar [ i ] . length ; j ++ ) { if ( toolbarScope . toolbar [ i ] [ j ] === toolKey ) { toolbarIndex = { group : i , index : j } ; break ; } if ( toolbarIndex !== undefined ) break ; } if ( toolbarIndex !== undefined ) { toolbarScope . toolbar [ toolbarIndex . group ] . slice ( toolbarIndex . index , 1 ) ; toolbarScope . _$element . children ( ) . eq ( toolbarIndex . group ) . children ( ) . eq ( toolbarIndex . index ) . remove ( ) ; } } } ) ; }
920	function collectComputedPropDeps ( ctx , prop , getter ) { ctx . __deps = [ ] ; let value = getter . call ( ctx ) ; ctx . __computedDeps [ prop ] = ctx . __deps ; ctx . __deps = null ; return value ; }
2556	function castPath$3 ( value , object ) { if ( isArray_1 ( value ) ) { return value ; } return _isKey ( value , object ) ? [ value ] : _stringToPath ( toString_1 ( value ) ) ; }
1361	function mkcert ( appDataPath , exe ) { const logPath = path . join ( appDataPath , "mkcert.log" ) const errPath = path . join ( appDataPath , "mkcert.err" ) appDataPath = appDataPath . replace ( " " , "\\ " ) \\ const exePath = path . join ( appDataPath , exe ) const crtPath = path . join ( appDataPath , "localhost.crt" ) const keyPath = path . join ( appDataPath , "localhost.key" ) const cmd = exePath + " -install -cert-file " + crtPath + " -key-file " + keyPath + " localhost" }
1844	function renderCallback ( req , res , template ) { return function ( err , data ) { if ( err ) { handleError ( req , res , err ) ; } else { render ( req , res , template , data ) ; } } ; }
1985	function flushDeferredPadding ( blocks ) { if ( ! padding ) return ; let prevBlock = blocks [ blocks . length - 2 ] ; prevBlock . text += padding ; }
256	function listDocs ( filePaths ) { return filePaths . map ( path => { const doc = find ( documents , entry => entry . path === path ) ; if ( doc ) { return { path : path , title : doc . title , snippet : defaultSnippet ( doc ) , } ; } return { path : path , title : 'Not found: ' + path , snippet : '' , } ; } ) ; }
1237	function ( ) { const ch = this . _input [ this . offset - 1 ] ; const fn = this . tokenTerminals [ ch ] ; if ( fn ) { return fn . apply ( this , [ ] ) ; } else { return this . yytext ; } }
3419	function ( ) { var me = this , showCheck = me . showHeaderCheckbox !== false ; return { isCheckerHd : showCheck , text : '&#160;' , width : me . headerWidth , sortable : false , draggable : false , resizable : false , hideable : false , menuDisabled : true , dataIndex : '' , cls : showCheck ? Ext . baseCSSPrefix + 'column-header-checkbox ' : '' , renderer : Ext . Function . bind ( me . renderer , me ) , editRenderer : me . editRenderer || me . renderEmpty , locked : me . hasLockedHeader ( ) } ; }
403	function findAll ( window , sels ) { const document = window . document ; const elements = document . getElementsByTagName ( 'noscript' ) ; Array . prototype . forEach . call ( elements , ( ns ) => { const wrapper = document . createElement ( 'div' ) ; wrapper . innerHTML = ns . textContent ; Array . prototype . forEach . call ( wrapper . children , ( child ) => { ns . parentNode . insertBefore ( child , ns ) ; } ) ; } ) ; return sels . filter ( ( selector ) => { try { return document . querySelector ( selector ) ; } catch ( e ) { return true ; } } ) ; }
234	function recordInCriteo ( eventName , eventProps ) { if ( ! isAdTrackingAllowed ( ) || ! isCriteoEnabled ) { debug ( 'recordInCriteo: [Skipping] ad tracking is not allowed' ) ; return ; } if ( TRACKING_STATE_VALUES . LOADED !== trackingState ) { loadTrackingScripts ( recordInCriteo . bind ( null , eventName , eventProps ) ) ; return ; } const events = [ ] ; events . push ( { event : 'setAccount' , account : TRACKING_IDS . criteo } ) ; events . push ( { event : 'setSiteType' , type : criteoSiteType ( ) } ) ; const normalizedHashedEmail = getNormalizedHashedUserEmail ( user ) ; if ( normalizedHashedEmail ) { events . push ( { event : 'setEmail' , email : [ normalizedHashedEmail ] } ) ; } const conversionEvent = clone ( eventProps ) ; conversionEvent . event = eventName ; events . push ( conversionEvent ) ; debug ( 'recordInCriteo: ' + eventName , cloneDeep ( events ) ) ; window . criteo_q . push ( ... events ) ; }
1176	function ( path , options ) { var cell = this . options . cellView . model ; var value = joint . util . getByPath ( cell . attributes , path , '/' ) ; if ( _ . isUndefined ( value ) && ! _ . isUndefined ( options . defaultValue ) ) { value = options . defaultValue ; } if ( options . valueRegExp ) { if ( _ . isUndefined ( value ) ) { throw new Error ( 'Inspector: defaultValue must be present when valueRegExp is used.' ) ; } var valueMatch = value . match ( new RegExp ( options . valueRegExp ) ) ; value = valueMatch && valueMatch [ 2 ] ; } return value ; }
3459	function makeDefine ( mapping , id ) { var require = function ( id ) { return mapping [ id ] ; } ; var exports = mapping [ id ] = { } ; var module = null ; return function ( factory ) { factory ( require , exports , module ) ; } ; }
1597	function writeTop ( d , loc ) { if ( d . indexOf ( '\n' ) != \n ) - 1 { throw 'Can not write content having \\n' } }
1964	function defaultKeyGenerator ( request ) { let protocol = request . protocol ; let host = request . get ( 'Host' ) ; let url = request . originalUrl ; return protocol + ':' + host + url ; }
1291	function ArrayIncludes ( searchElement , fromIndex ) { CHECK_OBJECT_COERCIBLE ( this , "Array.prototype.includes" ) ; var array = TO_OBJECT ( this ) ; var length = TO_LENGTH ( array . length ) ; return InnerArrayIncludes ( searchElement , fromIndex , array , length ) ; }
2452	async function asyncRoute ( req , res ) { await fakeWait ( ) ; res . send ( { ok : true } ) ; }
3572	function ( ) { var self = this , out = { } ; this . _keys . forEach ( function ( key , i ) { out [ key ] = self . _values [ i ] ; } ) ; return out ; }
1170	function findMiddleVertex ( p1 , p2 , preferredDirection ) { var direction = bestDirection ( p1 , p2 , preferredDirection ) ; if ( direction === 'down' || direction === 'up' ) { return { x : p1 . x , y : p2 . y , d : direction } ; } return { x : p2 . x , y : p1 . y , d : direction } ; }
2082	function Compiler ( config , op ) { this . outputFilePath = op ; this . modules = { } ; this . fileList = [ ] ; this . analyzedModules = [ ] ; this . combinedModules = [ ] ; this . buildComboModules = [ ] ; this . buildAnalyzedModules = [ ] ; this . config = config ; this . packages = config . packages ; }
1130	function getLabel ( logLevel , moduleLogging , verboseLabel ) { let parts ; let label = '' ; if ( moduleLogging ) { if ( logLevel === 'debug' || logLevel === 'silly' || verboseLabel ) { parts = moduleLogging . filename . split ( '/' ) ; label = ` ${ parts [ parts . length - 2 ] } ${ parts . pop ( ) } ` ; } } return label ; }
456	function getStringsFromCategories ( props , axis ) { if ( ! props . categories ) { return [ ] ; } const categories = getCategories ( props , axis ) ; const categoryStrings = categories && categories . filter ( ( val ) => typeof val === "string" ) ; return categoryStrings ? Collection . removeUndefined ( categoryStrings ) : [ ] ; }
3583	function doesInstanceExist ( ec2 , identifier , instanceState ) { var params = buildParams ( identifier , instanceState ) function inspectError ( err ) { if ( err . code === 'InvalidInstanceID.NotFound' ) { return false } return Bluebird . reject ( err ) } return ec2 . describeInstancesPromised ( params ) . then ( function checkResult ( data ) { return ! isEmpty ( data . Reservations ) } ) . catch ( inspectError ) }
2906	function getCli ( definitions , usageSections , argv ) { const commandLineArgs = require ( 'command-line-args' ) const commandLineUsage = require ( 'command-line-usage' ) const usage = usageSections ? commandLineUsage ( usageSections ) : '' const options = commandLineArgs ( definitions , argv ) return { options , usage } }
1910	function ( isAbsolute ) { var parts = findParts ( this . value ( ) ) ; if ( isAbsolute ) { var offset = this . valuePosition ( true ) ; _ . each ( parts , function ( p ) { p . shift ( offset ) ; } ) ; } return parts ; }
841	function nomalizeScope ( initialScope , node ) { let scope = getInnermostScope ( initialScope , node ) while ( scope && scope . block === node ) { scope = scope . upper } return scope }
3552	function searchObj ( ns_string , objToSearch ) { var parts = ns_string . split ( '.' ) , parent = objToSearch , classOfObj = classOf ( objToSearch ) , i ; throwTypeErrorIfNotOfType ( 'sjl.searchObj' , 'ns_string' , ns_string , String ) ; if ( classOfObj !== _Object && objToSearch instanceof Function === false ) { throw new TypeError ( 'sjl.searchObj expects `objToSearch` to be of type object ' + 'or an instance of `Function`. Type received: ' + classOfObj ) ; } for ( i = 0 ; i < parts . length ; i += 1 ) { if ( parts [ i ] in parent === false || isUndefined ( parent [ parts [ i ] ] ) ) { parent = undefined ; break ; } parent = parent [ parts [ i ] ] ; } return parent ; }
1451	function ( name ) { for ( var tmp = this . __scope ; tmp ; tmp = tmp . parent ) { if ( tmp . ignore ) { if ( tmp . ignore [ name ] ) { return true ; } for ( var key in tmp . ignore ) { if ( tmp . ignore [ key ] !== true ) { if ( name . startsWith ( tmp . ignore [ key ] ) ) { return true ; } } } } } return false ; }
1784	function _runMocha ( reporter , done , waited ) { if ( get ( 'waitForFrameworks' ) && ! waited ) { var waitFor = ( get ( 'waitFor' ) || whenFrameworksReady ) . bind ( window ) ; waitFor ( _runMocha . bind ( null , reporter , done , true ) ) ; return ; } debug ( '_runMocha' ) ; var mocha = window . mocha ; var Mocha = window . Mocha ; mocha . reporter ( reporter . childReporter ( window . location ) ) ; mocha . suite . title = reporter . suiteTitle ( window . location ) ; mocha . grep ( GREP ) ; var runner = Mocha . prototype . run . call ( mocha , function ( _error ) { if ( document . getElementById ( 'mocha' ) ) { Mocha . utils . highlightTags ( 'code' ) ; } done ( ) ; } ) ; if ( navigator . userAgent . match ( / chrome / i ) ) { window . onerror = null ; window . addEventListener ( 'error' , function ( event ) { if ( ! event . error ) return ; if ( event . error . ignore ) return ; runner . uncaught ( event . error ) ; } ) ; } }
53	function toggleListener ( element , event , callback ) { var _this = this ; var toggle = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : false ; var passive = arguments . length > 4 && arguments [ 4 ] !== undefined ? arguments [ 4 ] : true ; var capture = arguments . length > 5 && arguments [ 5 ] !== undefined ? arguments [ 5 ] : false ; if ( ! element || ! ( 'addEventListener' in element ) || is$1 . empty ( event ) || ! is$1 . function ( callback ) ) { return ; } var events = event . split ( ' ' ) ; var options = capture ; if ( supportsPassiveListeners ) { options = { passive : passive , capture : capture } ; } events . forEach ( function ( type ) { if ( _this && _this . eventListeners && toggle ) { _this . eventListeners . push ( { element : element , type : type , callback : callback , options : options } ) ; } element [ toggle ? 'addEventListener' : 'removeEventListener' ] ( type , callback , options ) ; } ) ; }
890	function processAppSpecifiedDeclaration ( allAppTypes , appType , decl ) { let { prop , parent } = decl ; let result ; if ( ( result = SPECIFIED_APP_PROP_DECL_REGEXP . exec ( prop ) ) ) { let propApp = result [ 1 ] ; let isMatchApp = appType === propApp ; if ( allAppTypes . includes ( propApp ) && ! isMatchApp ) { decl . remove ( ) ; } else if ( isMatchApp ) { let newPropName = prop . replace ( SPECIFIED_APP_PROP_DECL_REGEXP , '' ) ; removeUnUseDecl ( decl , newPropName ) ; decl . prop = newPropName ; } if ( ! parent . nodes || ! parent . nodes . length ) { parent . remove ( ) ; } } }
374	function karmaEsmPreprocessor ( logger ) { const log = logger . create ( 'preprocessor.esm' ) ; function preprocess ( code , file , done ) { try { let compiledCode = esm . compiler . getCached ( file . originalPath ) ; if ( ! compiledCode ) { compiledCode = esm . compiler . compile ( file . originalPath , code ) ; } done ( null , compiledCode ) ; } catch ( e ) { const message = ` \n \n ${ e . message } \n ${ file . originalPath } \n \n ` ; log . error ( message ) ; done ( null , code ) ; } } return preprocess ; }
1406	function WritableStreamAddWriteRequest ( stream ) { assert ( IsWritableStreamLocked ( stream ) === true ) ; assert ( stream . _state === 'writable' ) ; const promise = new Promise ( ( resolve , reject ) => { const writeRequest = { _resolve : resolve , _reject : reject } ; stream . _writeRequests . push ( writeRequest ) ; } ) ; return promise ; }
1459	function getPages ( files , metalsmith , done ) { var metadata = metalsmith . metadata ( ) ; var pages = [ ] ; var order = { } ; if ( metadata . site . pages ) metadata . site . pages . forEach ( ( url , index ) => typeof url == "string" ? order [ url ] = index : null ) ; var unorderedPages = [ ] ; function addPage ( url , title ) { var page = { url : url , title : title } ; var index = order [ url ] ; if ( index !== undefined ) pages [ index ] = page ; else unorderedPages . push ( page ) ; } for ( var filename in files ) { var file = files [ filename ] ; if ( filename == "index.html" ) addPage ( "/" , file . title || "Home Page" ) ; else if ( file . permalink || file . navigation ) addPage ( file . permalink || filename , file . title || "Home Page" ) ; } unorderedPages . forEach ( page => pages . push ( page ) ) ; metadata . site . pages = pages ; done ( ) ; }
2493	function num2hex ( value , options ) { if ( value === undefined ) throw new Error ( 'Value is undefined' ) ; var buffer = Buffer . alloc ( NUMBER_OF_BYTES ) ; writeTobuffer ( value , buffer ) ; return buf2hex ( buffer , options ) ; }
3494	function getNodeIndent ( node , byLastLine , excludeCommas ) { var token = byLastLine ? context . getLastToken ( node ) : context . getFirstToken ( node ) ; var src = context . getSource ( token , token . loc . start . column ) ; var regExp = excludeCommas ? indentPattern . excludeCommas : indentPattern . normal ; var indent = regExp . exec ( src ) ; return indent ? indent [ 0 ] . length : 0 ; }
1908	function findValueRange ( it ) { var skipTokens = [ 'white' , 'line' , ':' ] ; var tokens = [ ] , token , start , end ; it . nextUntil ( function ( tok ) { return ! _ . include ( skipTokens , this . itemNext ( ) . type ) ; } ) ; start = it . current ( ) . end ; while ( token = it . next ( ) ) { if ( token . type == '}' || token . type == ';' ) { trimWhitespaceTokens ( tokens , WHITESPACE_REMOVE_FROM_START | ( token . type == '}' ? WHITESPACE_REMOVE_FROM_END : 0 ) ) ; if ( tokens . length ) { start = tokens [ 0 ] . start ; end = _ . last ( tokens ) . end ; } else { end = start ; } return range ( start , end - start ) ; } tokens . push ( token ) ; } if ( tokens . length ) { return range ( tokens [ 0 ] . start , _ . last ( tokens ) . end - tokens [ 0 ] . start ) ; } }
3749	function DimCommand ( args ) { var parsed = new statements . ArgumentStatement ( args , { parseArgs : false } ) ; this . creates = [ ] ; for ( var i = 0 ; i < parsed . args . length ; i ++ ) { var dimDef = parsed . args [ i ] ; var startBracket = dimDef . indexOf ( '(' ) ; var endBracket = dimDef . indexOf ( ')' ) ; if ( startBracket === - 1 ) throw new SyntaxError ( 'Expected start bracket' ) ; if ( endBracket === - 1 ) throw new SyntaxError ( 'Expected end bracket' ) ; var arrayName = dimDef . substring ( 0 , startBracket ) . trim ( ) ; var arrayLengthName = dimDef . substring ( startBracket + 1 , endBracket ) ; var arrayLengthArg = new statements . ArgumentStatement ( arrayLengthName ) ; this . creates . push ( { name : arrayName , lengths : arrayLengthArg . args } ) } }
2249	function get ( czConfig ) { const types = [ ] ; if ( typeof czConfig . types === 'undefined' ) { return defaults ; } for ( const type of czConfig . types ) { types . push ( type . value ) ; } return types ; }
3386	function ( request ) { if ( ! request ) { request = this . getLatest ( ) ; } if ( ! ( request && request . xhr ) ) { return false ; } var state = request . xhr . readyState ; return ( ( request . xhr instanceof Ext . data . flash . BinaryXhr ) && state != 4 ) || ! ( state === 0 || state == 4 ) ; }
2536	function hasPath ( object , path , hasFunc ) { path = isKey$1 ( path , object ) ? [ path ] : castPath$1 ( path ) ; var result , index = - 1 , length = path . length ; while ( ++ index < length ) { var key = toKey$1 ( path [ index ] ) ; if ( ! ( result = object != null && hasFunc ( object , key ) ) ) { break ; } object = object [ key ] ; } if ( result ) { return result ; } var length = object ? object . length : 0 ; return ! ! length && isLength ( length ) && isIndex ( key , length ) && ( isArray$1 ( object ) || isArguments ( object ) ) ; }
2319	function load ( config ) { var configuration = { prefilters : [ ] , providers : [ ] , postfilters : [ ] } ; if ( typeof config !== "object" ) { throw new InvalidConfiguration ( InvalidConfiguration . EMPTY_MESSAGE ) ; } if ( ! config . providers || ! config . providers . length ) { throw new InvalidConfiguration ( InvalidConfiguration . NO_PROVIDER_MESSAGE ) ; } if ( config . prefilters ) { configuration . prefilters = loadMiddlewareFilters ( config . prefilters ) ; } if ( config . postfilters ) { configuration . postfilters = loadMiddlewareFilters ( config . postfilters ) ; } configuration . providers = loadProviders ( config . providers ) ; return configuration ; }
998	function nanoRemainder ( msFloat ) { var modulo = 1e6 ; var remainder = ( msFloat * 1e6 ) % modulo ; var positiveRemainder = remainder < 0 ? remainder + modulo : remainder ; return Math . floor ( positiveRemainder ) ; }
2829	function ( template ) { this . unbindAll ( ) ; if ( template == null ) { this . template = this . domElement . innerHTML ; } else { this . template = template ; htmlToElem ( this . domElement , this . template ) ; } this . built = false ; this . templateNodes = [ Array . prototype . slice . call ( this . domElement . childNodes ) ] ; }
2189	function pipeP ( ) { if ( arguments . length === 0 ) { throw new Error ( 'pipeP requires at least one argument' ) ; } return _arity ( arguments [ 0 ] . length , reduce ( _pipeP , arguments [ 0 ] , tail ( arguments ) ) ) ; }
1871	function ( strings ) { var lengths = _ . map ( strings , function ( s ) { return _ . isString ( s ) ? s . length : + s ; } ) ; var max = _ . max ( lengths ) ; return _ . map ( lengths , function ( l ) { var pad = max - l ; return pad ? this . repeatString ( ' ' , pad ) : '' ; } , this ) ; }
2099	function check_object ( now , key , p , c_info ) { stale_check_cnt ++ ; if ( ! c_info . last_stat || ( now - c_info . last_stat ) > self . ttl_ms ) { fs . unlink ( c_info . _cacheFile , function ( u_err ) { log . trace ( 'stale, discard: %s' , p ) ; stale_check_cnt -- ; if ( db_keys_done && stale_check_cnt === 0 ) self . emit ( 'ready' ) ; } ) ; } else { fs . stat ( c_info . _cacheFile , function ( err , stats ) { if ( ! err ) { log . trace ( 'not stale, keep: %s' , p ) ; self . _grow_cache ( p , stats . size ) ; } stale_check_cnt -- ; if ( db_keys_done && stale_check_cnt === 0 ) self . emit ( 'ready' ) ; } ) ; } }
2133	function ( inputNode , options = { } ) { this . formatter = require ( 'eslint/lib/formatters/stylish' ) if ( ! ( this instanceof StandardValidationFilter ) ) { return new StandardValidationFilter ( inputNode , options ) } Filter . call ( this , inputNode ) this . node = inputNode this . console = options . console || console this . internalOptions = { format : options . format ? options . format : undefined , throwOnError : options . throwOnError ? options . throwOnError : false , logOutput : options . logOutput ? options . logOutput : false , fix : options . fix ? options . fix : false , globals : options . globals || options . global } this . ignore = options . ignore ? options . ignore : function ( ) { return false } if ( typeof options . testGenerator === 'string' ) { const testGenerators = require ( './test-generators' ) this . testGenerator = testGenerators [ options . testGenerator ] if ( ! this . testGenerator ) { throw new Error ( ` ${ this . internalOptions . testGenerator } ` ) } } else { this . testGenerator = options . testGenerator } if ( this . testGenerator ) { this . targetExtension = 'lint-test.js' } this . formatter = require ( this . internalOptions . format ? this . internalOptions . format : 'eslint/lib/formatters/stylish' ) }
1247	function ( what , encapsed ) { const result = this . node ( "staticlookup" ) ; let offset , name ; if ( this . next ( ) . is ( [ this . tok . T_VARIABLE , "$" ] ) ) { offset = this . read_reference_variable ( encapsed , false ) ; } else if ( this . token === this . tok . T_STRING || this . token === this . tok . T_CLASS || ( this . php7 && this . is ( "IDENTIFIER" ) ) ) { offset = this . node ( "identifier" ) ; name = this . text ( ) ; this . next ( ) ; offset = offset ( name ) ; } else if ( this . token === "{" ) { offset = this . node ( "literal" ) ; name = this . next ( ) . read_expr ( ) ; this . expect ( "}" ) && this . next ( ) ; offset = offset ( "literal" , name , null ) ; this . expect ( "(" ) ; } else { this . error ( [ this . tok . T_VARIABLE , this . tok . T_STRING ] ) ; offset = this . node ( "identifier" ) ; name = this . text ( ) ; this . next ( ) ; offset = offset ( name ) ; } return result ( what , offset ) ; }
1897	function ( syntax , profile , additionalFilters ) { profile = require ( 'profile' ) . get ( profile ) ; var filters = list ( profile . filters || require ( 'resources' ) . findItem ( syntax , 'filters' ) || basicFilters ) ; if ( profile . extraFilters ) { filters = filters . concat ( list ( profile . extraFilters ) ) ; } if ( additionalFilters ) { filters = filters . concat ( list ( additionalFilters ) ) ; } if ( ! filters || ! filters . length ) { filters = list ( basicFilters ) ; } return filters ; }
2366	function insertDocsToDb ( dburl , collectionName , docs , cb ) { MongoClient . connect ( dburl , function ( err , db ) { if ( err ) { return cb ( err ) ; } var col = db . collection ( collectionName ) ; col . insertMany ( docs , function ( err , result ) { if ( err ) { return cb ( err ) ; } return cb ( null , result ) ; } ) ; } ) ; }
2235	function createReadStream ( ) { var streams = AWS . util . nodeRequire ( 'stream' ) ; var req = this ; var stream = null ; var legacyStreams = false ; if ( AWS . HttpClient . streamsApiVersion === 2 ) { stream = new streams . Readable ( ) ; stream . _read = function ( ) { } ; } else { stream = new streams . Stream ( ) ; stream . readable = true ; } stream . sent = false ; stream . on ( 'newListener' , function ( event ) { if ( ! stream . sent && ( event === 'data' || event === 'readable' ) ) { if ( event === 'data' ) legacyStreams = true ; stream . sent = true ; process . nextTick ( function ( ) { req . send ( function ( ) { } ) ; } ) ; } } ) ; this . on ( 'httpHeaders' , function streamHeaders ( statusCode , headers , resp ) { if ( statusCode < 300 ) { this . httpRequest . _streaming = true ; req . removeListener ( 'httpData' , AWS . EventListeners . Core . HTTP_DATA ) ; req . removeListener ( 'httpError' , AWS . EventListeners . Core . HTTP_ERROR ) ; req . on ( 'httpError' , function streamHttpError ( error , resp ) { resp . error = error ; resp . error . retryable = false ; } ) ; var httpStream = resp . httpResponse . stream ; if ( legacyStreams ) { httpStream . on ( 'data' , function ( arg ) { stream . emit ( 'data' , arg ) ; } ) ; httpStream . on ( 'end' , function ( ) { stream . emit ( 'end' ) ; } ) ; } else { httpStream . on ( 'readable' , function ( ) { var chunk ; do { chunk = httpStream . read ( ) ; if ( chunk !== null ) stream . push ( chunk ) ; } while ( chunk !== null ) ; stream . read ( 0 ) ; } ) ; httpStream . on ( 'end' , function ( ) { stream . push ( null ) ; } ) ; } httpStream . on ( 'error' , function ( err ) { stream . emit ( 'error' , err ) ; } ) ; } } ) ; this . on ( 'error' , function ( err ) { stream . emit ( 'error' , err ) ; } ) ; return stream ; }
1057	function parseLine ( line , options , dict ) { var word var codes var result var hashOffset var slashOffset slashOffset = line . indexOf ( slash ) while ( slashOffset !== - 1 && line . charAt ( slashOffset - 1 ) === backslash ) { line = line . slice ( 0 , slashOffset - 1 ) + line . slice ( slashOffset ) slashOffset = line . indexOf ( slash , slashOffset ) } hashOffset = line . indexOf ( numberSign ) if ( hashOffset >= 0 ) { if ( slashOffset >= 0 && slashOffset < hashOffset ) { word = line . slice ( 0 , slashOffset ) whiteSpaceExpression . lastIndex = slashOffset + 1 result = whiteSpaceExpression . exec ( line ) codes = line . slice ( slashOffset + 1 , result ? result . index : undefined ) } else { word = line . slice ( 0 , hashOffset ) } } else if ( slashOffset >= 0 ) { word = line . slice ( 0 , slashOffset ) codes = line . slice ( slashOffset + 1 ) } else { word = line } word = trim ( word ) if ( word ) { codes = parseCodes ( options . flags , codes && trim ( codes ) ) add ( dict , word , codes , options ) } }
2918	function chooseDataSource ( dataSource ) { if ( dataSource === 'json' ) { return function ( file ) { return JSON . parse ( file . contents . toString ( ) ) ; } ; } else if ( dataSource === 'vinyl' ) { return function ( file ) { file [ bodyAttribute ] = file . contents . toString ( ) ; return file ; } ; } else if ( dataSource === 'data' ) { return function ( file ) { var data = file . data ; data [ bodyAttribute ] = file . contents . toString ( ) ; return data ; } ; } else if ( typeof dataSource === 'function' ) { return dataSource ; } else { throw pluginError ( 'Unknown dataSource' ) ; } }
2454	function wrapRoute ( fn ) { if ( ! _lodash2 . default . isFunction ( fn ) ) { throw new Error ( 'fn should be a function' ) ; } return function ( req , res , next ) { try { var result = fn ( req , res , next ) ; if ( result && result . catch ) { result . catch ( next ) ; } } catch ( e ) { next ( e ) ; } } ; }
2805	function isEmptyTag ( node ) { if ( node . constructor === Element && ! node . hasChildNodes ( ) ) return true return Boolean ( EMPTY_TAG_SET [ node . tagName ] ) }
383	function query ( node , predicate , getChildNodes ) { if ( getChildNodes === void 0 ) { getChildNodes = module . exports . defaultChildNodes ; } var elementPredicate = AND ( isElement , predicate ) ; return nodeWalk ( node , elementPredicate , getChildNodes ) ; }
2397	function parse ( report , thread ) { var rows = [ '' ] ; var crashed = thread || Utils . get_crash_thread ( report ) ; if ( ! crashed ) { return rows ; } var index = crashed [ 'index' ] ; var sys = report [ 'system' ] || { } ; var type = sys [ 'binary_cpu_type' ] ; var sub = sys [ 'binary_cpu_subtype' ] ; var arch ; if ( ! type && ! sub ) { arch = sys [ 'cpu_arch' ] ; } else { arch = CPU . get_cpu_arch ( type , sub ) ; } var cpu = CPU . get_cpu_type ( arch ) ; rows . push ( ` ${ index } ${ cpu } ` ) ; var registers = ( crashed [ 'registers' ] || { } ) [ 'basic' ] || { } ; var reg_order = CPU . get_registers ( cpu ) ; var line = '' ; for ( var i = 0 , j = reg_order . length ; i < j ; i ++ ) { if ( i % 4 === 0 && i !== 0 ) { rows . push ( line ) ; line = '' ; } var register = reg_order [ i ] ; var register_addr = registers [ register ] || 0 ; var register_name = Utils . pad_left ( register , ' ' , 6 ) ; var register_loc = Utils . pad_hex ( register_addr , '0' , 8 ) ; var register_pad = Utils . pad_right ( register_loc , ' ' , 9 ) ; line += ` ${ register_name } ${ register_pad } ` ; } if ( line ) { rows . push ( line ) ; } return rows ; }
2720	function processDataItems ( items ) { var processedItems = [ ] ; items . forEach ( function ( item , i ) { processedItems [ i ] = processString ( item ) ; } ) ; return processedItems ; }
3167	function ( method , path , cb ) { http . request ( { hostname : DEFAULT_HOST , port : DEFAULT_PORT , path : path , method : method } , function ( res ) { res . pipe ( concat ( { encoding : 'string' } , function ( data ) { cb ( data , res . headers , res . statusCode ) ; } ) ) ; } ) . end ( ) ; }
1688	function _contextGet ( contextNodeOrId ) { if ( this . _nodesById && ( ( contextNodeOrId instanceof String ) || ( typeof contextNodeOrId === 'string' ) ) ) { var renderNode = this . _nodesById [ contextNodeOrId ] ; if ( ! renderNode ) { return undefined ; } if ( renderNode instanceof Array ) { var result = [ ] ; for ( var i = 0 , j = renderNode . length ; i < j ; i ++ ) { result . push ( { renderNode : renderNode [ i ] , arrayElement : true } ) ; } return result ; } return { renderNode : renderNode , byId : true } ; } else { return contextNodeOrId ; } }
864	function isIgnored ( key , ignores ) { return ( ignores . indexOf ( key ) !== - 1 || FEATURES [ key ] . alias . some ( alias => ignores . indexOf ( alias ) !== - 1 ) ) }
213	function accessibleFocus ( ) { document . addEventListener ( 'keydown' , function ( event ) { if ( keyboardNavigation ) { return ; } if ( keyboardNavigationKeycodes . indexOf ( event . keyCode ) !== - 1 ) { keyboardNavigation = true ; document . documentElement . classList . add ( 'accessible-focus' ) ; } } ) ; document . addEventListener ( 'mouseup' , function ( ) { if ( ! keyboardNavigation ) { return ; } keyboardNavigation = false ; document . documentElement . classList . remove ( 'accessible-focus' ) ; } ) ; }
1573	async function createThumbnails ( target , images ) { for ( const x of images ) { const imagePath = path . join ( target , x ) const thumbPath = path . join ( target , ` ${ x } ` ) try { await sharp ( imagePath ) . resize ( 450 ) . background ( { r : 255 , g : 255 , b : 255 , alpha : 1 } ) . flatten ( ) . jpeg ( ) . toFile ( thumbPath ) } catch ( e ) { const msg = chalk . dim ( ` ${ e . message } ` ) console . warn ( ` ${ chalk . bold ( x ) } ${ msg } ` ) } } }
2684	function modulesCommand ( shell , args , data , evaluationId ) { var names = [ ] ; for ( var n in shell . installedModules ) { names . push ( n ) ; } console . log ( names . join ( '\n' ) ) ; }
3140	function ( ) { var me = this ; if ( ! me . enabled ) { me . target . on ( me . eventName , me . handleTargetEvent , me ) ; me . enabled = true ; } }
3194	function findMorph ( args , morphs ) { for ( var i = 0 ; i < morphs . length ; i ++ ) { var sig = morphs [ i ] . sig if ( args . length == sig . length ) { var matched = true for ( var j = 0 ; j < sig . length ; j ++ ) { if ( ! isType ( sig [ j ] , args [ j ] ) ) { matched = false break } } if ( matched ) { return morphs [ i ] } } } throw new Error ( 'No matching function signature' ) }
1013	function ( path , options ) { const fullPath = googleDrivePath ( path ) ; return this . _getFileId ( fullPath ) . then ( ( id ) => { if ( ! id ) { return Promise . resolve ( { statusCode : 200 } ) ; } return this . _getMeta ( id ) . then ( ( meta ) => { let etagWithoutQuotes ; if ( ( typeof meta === 'object' ) && ( typeof meta . etag === 'string' ) ) { etagWithoutQuotes = removeQuotes ( meta . etag ) ; } if ( options && options . ifMatch && ( options . ifMatch !== etagWithoutQuotes ) ) { return { statusCode : 412 , revision : etagWithoutQuotes } ; } return this . _request ( 'DELETE' , BASE_URL + '/drive/v2/files/' + id , { } ) . then ( ( response ) => { if ( response . status === 200 || response . status === 204 ) { return { statusCode : 200 } ; } else { return Promise . reject ( "Delete failed: " + response . status + " (" + response . responseText + ")" ) ; } } ) ; } ) ; } ) ; }
548	function getPrefixInfo ( propertyName , namespace , extraSymbols ) { var baseName = propertyName ; var prefixLength = 0 ; namespace = namespace || '' ; extraSymbols = extraSymbols || 0 ; if ( ! propertyName ) return ; PREFIXES . some ( function ( prefix ) { prefix = '-' + prefix + '-' ; if ( propertyName . indexOf ( prefix ) !== 0 ) return ; baseName = baseName . substr ( prefix . length ) ; prefixLength = prefix . length ; return true ; } ) ; return { id : namespace + baseName , baseName : baseName , prefixLength : prefixLength , extra : extraSymbols } ; }
24	function YesPushDown ( formObject ) { var xobj = createFormXObject ( formObject ) ; var stream = [ ] ; var fontKey = scope . internal . getFont ( formObject . fontName , formObject . fontStyle ) . id ; var encodedColor = scope . __private__ . encodeColorString ( formObject . color ) ; var calcRes = calculateX ( formObject , formObject . caption ) ; stream . push ( "0.749023 g" ) ; stream . push ( "0 0 " + f2 ( AcroFormAppearance . internal . getWidth ( formObject ) ) + " " + f2 ( AcroFormAppearance . internal . getHeight ( formObject ) ) + " re" ) ; stream . push ( "f" ) ; stream . push ( "BMC" ) ; stream . push ( "q" ) ; stream . push ( "0 0 1 rg" ) ; stream . push ( "/" + fontKey + " " + f2 ( calcRes . fontSize ) + " Tf " + encodedColor ) ; stream . push ( "BT" ) ; stream . push ( calcRes . text ) ; stream . push ( "ET" ) ; stream . push ( "Q" ) ; stream . push ( "EMC" ) ; xobj . stream = stream . join ( "\n" ) ; \n }
534	function getPlatformLibtensorflowUri ( ) { let targetUri = BASE_URI ; if ( platform === 'linux' ) { if ( os . arch ( ) === 'arm' ) { targetUri = 'https://storage.googleapis.com/tf-builds/libtensorflow_r1_12_linux_arm.tar.gz' ; } else { if ( libType === 'gpu' ) { targetUri += GPU_LINUX ; } else { targetUri += CPU_LINUX ; } } } else if ( platform === 'darwin' ) { targetUri += CPU_DARWIN ; } else if ( platform === 'win32' ) { path = path . win32 ; if ( libType === 'gpu' ) { targetUri += GPU_WINDOWS ; } else { targetUri += CPU_WINDOWS ; } } else { throw new Error ( ` ${ platform } ` ) ; } return targetUri ; }
1345	function sanitizeProps ( props , toRemove ) { props = { ... props } ; for ( let i = 0 , l = toRemove . length ; i < l ; i += 1 ) { delete props [ toRemove [ i ] ] } return props ; }
1423	async function ( locale ) { var t = this ; var cldr = this . __cldrs [ locale ] ; if ( cldr ) { return cldr ; } return qx . tool . compiler . app . Cldr . loadCLDR ( locale ) . then ( cldr => t . __cldrs [ locale ] = cldr ) ; }
1669	function ( id ) { console . log ( 'XXXX Received Event: ' + id ) ; $ ( "#btnStartMonitor" ) . prop ( 'disabled' , false ) ; $ ( "#btnStopMonitor" ) . prop ( 'disabled' , true ) ; btLeHandler . initialise ( ) ; }
3430	function ( ) { var args = slice . call ( arguments ) , array = [ ] , i , ln ; for ( i = 0 , ln = args . length ; i < ln ; i ++ ) { array = array . concat ( args [ i ] ) ; } return ExtArray . unique ( array ) ; }
12	function ( tagName , opt ) { var el = document . createElement ( tagName ) ; if ( opt . className ) el . className = opt . className ; if ( opt . innerHTML ) { el . innerHTML = opt . innerHTML ; var scripts = el . getElementsByTagName ( 'script' ) ; for ( var i = scripts . length ; i -- > 0 ; ) { scripts [ i ] . parentNode . removeChild ( scripts [ i ] ) ; } } for ( var key in opt . style ) { el . style [ key ] = opt . style [ key ] ; } return el ; }
2219	function render ( req , res , next ) { if ( ! req . session [ sessionName ] . length ) { next ( ) ; } else { const resultHTML = [ ] ; async . each ( req . session [ sessionName ] , function ( item , next ) { beforeSingleRender ( item , function ( error , item ) { if ( error ) return next ( error ) ; app . render ( viewName , item , function ( error , html ) { if ( error ) return next ( error ) ; resultHTML . push ( html ) ; next ( null ) ; } ) } ) } , function ( error ) { if ( error ) return next ( error ) ; req . session [ sessionName ] . length = 0 ; afterAllRender ( resultHTML , function ( error , html ) { if ( error ) return next ( error ) ; res . locals [ localsName ] = html ; next ( ) ; } ) } ) } }
19	function ( y ) { if ( this . pageWrapYEnabled ) { this . lastBreak = 0 ; var manualBreaks = 0 ; var autoBreaks = 0 ; for ( var i = 0 ; i < this . pageBreaks . length ; i ++ ) { if ( y >= this . pageBreaks [ i ] ) { manualBreaks ++ ; if ( this . lastBreak === 0 ) { autoBreaks ++ ; } var spaceBetweenLastBreak = this . pageBreaks [ i ] - this . lastBreak ; this . lastBreak = this . pageBreaks [ i ] ; var pagesSinceLastBreak = Math . floor ( spaceBetweenLastBreak / this . pageWrapY ) ; autoBreaks += pagesSinceLastBreak ; } } if ( this . lastBreak === 0 ) { var pagesSinceLastBreak = Math . floor ( y / this . pageWrapY ) + 1 ; autoBreaks += pagesSinceLastBreak ; } return autoBreaks + manualBreaks ; } else { return this . pdf . internal . getCurrentPageInfo ( ) . pageNumber ; } }
2903	function printError ( message ) { arrayify ( message ) . forEach ( function ( msg ) { console . error ( ansi . format ( msg , 'red' ) ) } ) }
2526	function ( url , prev , done ) { if ( url . indexOf ( 'bootstrap/' ) === 0 ) { var component = url . substr ( 'bootstrap/' . length + 1 ) ; var file = cmsDir + '/src/scss/bootstrap/_' + component + '.scss' ; try { var stats = fs . lstatSync ( file ) ; if ( stats . isFile ( ) ) { return { file : file } ; } } catch ( ex ) { } } return sass . compiler . NULL ; }
18	function ( style ) { var rxRgb = / rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\) / ; var rxRgba = / rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\) / ; var rxTransparent = / transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\) / ; var r , g , b , a ; if ( style . isCanvasGradient === true ) { style = style . getColor ( ) ; } if ( ! style ) { return { r : 0 , g : 0 , b : 0 , a : 0 , style : style } ; } if ( rxTransparent . test ( style ) ) { r = 0 ; g = 0 ; b = 0 ; a = 0 ; } else { var matches = rxRgb . exec ( style ) ; if ( matches !== null ) { r = parseInt ( matches [ 1 ] ) ; g = parseInt ( matches [ 2 ] ) ; b = parseInt ( matches [ 3 ] ) ; a = 1 ; } else { matches = rxRgba . exec ( style ) ; if ( matches !== null ) { r = parseInt ( matches [ 1 ] ) ; g = parseInt ( matches [ 2 ] ) ; b = parseInt ( matches [ 3 ] ) ; a = parseFloat ( matches [ 4 ] ) ; } else { a = 1 ; if ( typeof style === "string" && style . charAt ( 0 ) !== '#' ) { var rgbColor = new RGBColor ( style ) ; if ( rgbColor . ok ) { style = rgbColor . toHex ( ) ; } else { style = '#000000' ; } } if ( style . length === 4 ) { r = style . substring ( 1 , 2 ) ; r += r ; g = style . substring ( 2 , 3 ) ; g += g ; b = style . substring ( 3 , 4 ) ; b += b ; } else { r = style . substring ( 1 , 3 ) ; g = style . substring ( 3 , 5 ) ; b = style . substring ( 5 , 7 ) ; } r = parseInt ( r , 16 ) ; g = parseInt ( g , 16 ) ; b = parseInt ( b , 16 ) ; } } } return { r : r , g : g , b : b , a : a , style : style } ; }
3432	function ( arrayA , arrayB ) { var clone = slice . call ( arrayA ) , ln = clone . length , i , j , lnB ; for ( i = 0 , lnB = arrayB . length ; i < lnB ; i ++ ) { for ( j = 0 ; j < ln ; j ++ ) { if ( clone [ j ] === arrayB [ i ] ) { erase ( clone , j , 1 ) ; j -- ; ln -- ; } } } return clone ; }
2699	function main ( ) { var parser = nomnom ( ) ; parser . script ( 'ijs' ) . nocolors ( ) . printer ( function ( s , code ) { console . log ( s ) ; if ( code ) { process . exit ( code ) ; } } ) . option ( 'version' , { abbr : 'v' , flag : true , help : 'print version and exit' , callback : function ( ) { console . log ( '0.1.0' ) ; process . exit ( 0 ) ; } } ) . option ( 'userPath' , { abbr : 'u' , full : 'userPath' , metavar : 'path' , type : 'string' , required : true , help : 'path that will contain installed node modules' , callback : function ( userPath ) { if ( ! fs . existsSync ( userPath ) || ! fs . statSync ( userPath ) . isDirectory ( ) ) { return 'expected an existing directory for the userPath option' ; } return null ; } } ) . option ( 'connectionFile' , { position : 0 , required : true , help : 'path to file containing kernel connection information' } ) ; var options = parser . parse ( process . argv . slice ( 2 ) ) ; if ( options ) { var shellConfig = { userPath : options . userPath } ; var connectionConfig = JSON . parse ( fs . readFileSync ( options . connectionFile , { encoding : 'utf8' } ) ) ; Shell . create ( shellConfig , function ( shell ) { Session . run ( shell , connectionConfig ) ; } ) ; } }
2752	function SpanSerializer ( props ) { const { mark , children } = props . node const isPlain = typeof mark === 'string' const markType = isPlain ? mark : mark . _type const serializer = props . serializers . marks [ markType ] if ( ! serializer ) { console . warn ( ` ${ markType } \` \` ` ) return h ( props . serializers . markFallback , null , children ) } return h ( serializer , props . node , children ) }
1448	function ( name , loc ) { var str = "" ; for ( var i = 0 ; i < name . length ; i ++ ) { if ( i ) { str += "." ; } str += name [ i ] ; if ( qx . tool . compiler . ClassFile . GLOBAL_SYMBOLS [ str ] || this . isIgnored ( str ) ) { return ; } } name = name . join ( "." ) ; if ( name == this . __className || name . startsWith ( this . __className + "." ) || name . startsWith ( "(" ) ) { return ; } if ( name == "qx.ui.tooltip.ToolTip" ) debugger ; var scope = this . __scope ; if ( scope . vars [ name ] !== undefined ) { return ; } if ( ! scope . unresolved [ name ] ) { scope . unresolved [ name ] = { name : name , locations : loc ? [ loc ] : [ ] , load : this . isLoadScope ( ) , defer : this . __inDefer } ; } else if ( loc ) { scope . unresolved [ name ] . locations . push ( loc ) ; } }
2679	function jsonCommand ( shell , args , data , evaluationId ) { return dataCommand ( shell , args , data , evaluationId , function ( value ) { return JSON . parse ( value ) ; } ) ; }
2739	function addHandler ( cls , replacer , reviver ) { if ( typeof cls !== "function" ) { throw new TypeError ( "'cls' must be class/function" ) ; } if ( typeof replacer !== "function" ) { throw new TypeError ( "'replacer' must be function" ) ; } if ( typeof reviver !== "function" ) { throw new TypeError ( "'reviver' must be function" ) ; } __handlers [ cls . name ] = { cls : cls , replacer : replacer , reviver : reviver } ; }
3578	function ( priority ) { var retVal ; if ( sjl . classOfIs ( priority , Number ) ) { retVal = priority ; } else { this . _internalPriorities += 1 ; retVal = + this . _internalPriorities ; } return retVal ; }
3465	function ( options ) { return options && options . tid ? Ext . direct . Manager . getTransaction ( options . tid ) : null ; }
3085	function ( o ) { if ( Ext . isString ( o ) ) { o = { text : o } ; } o = Ext . applyIf ( o || { } , { text : this . busyText , iconCls : this . busyIconCls } ) ; return this . setStatus ( o ) ; }
1427	function ( className ) { var t = this ; var info = this . __classFiles [ className ] ; if ( info ) { return info . library ; } for ( var j = 0 ; j < t . __libraries . length ; j ++ ) { var library = t . __libraries [ j ] ; info = library . getSymbolType ( className ) ; if ( info && ( info . symbolType == "class" || info . symbolType == "member" ) ) { return library ; } } return null ; }
286	function updateProductEdits ( edits , productId , doUpdate ) { const prevEdits = edits || [ ] ; let found = false ; const newEdits = prevEdits . map ( productEdits => { if ( isEqual ( productId , productEdits . productId ) ) { found = true ; return doUpdate ( productEdits ) ; } return productEdits ; } ) ; if ( ! found ) { newEdits . push ( doUpdate ( undefined ) ) ; } return newEdits ; }
2548	function assignInDefaults ( objValue , srcValue , key , object ) { if ( objValue === undefined || ( eq$3 ( objValue , objectProto$7 [ key ] ) && ! hasOwnProperty$6 . call ( object , key ) ) ) { return srcValue ; } return objValue ; }
1911	function ( content , pos , isBackward ) { var result = '' ; var len = content . length ; var offset = pos ; var stopChars = '{}/\\<>\n\r' ; \\ \n \r var bracePos = - 1 , ch ; while ( offset >= 0 ) { ch = content . charAt ( offset ) ; if ( ch == '{' ) { bracePos = offset ; break ; } else if ( ch == '}' && ! isBackward ) { offset ++ ; break ; } offset -- ; } }
3784	function DrawspriteCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 3 ) throw new SyntaxError ( 'DRAWSPRITE command requires 3 arguments' ) ; this . id = parsed . args [ 0 ] ; this . x = parsed . args [ 1 ] ; this . y = parsed . args [ 2 ] ; this . scale = parsed . args . length === 4 ? parsed . args [ 3 ] : false ; this . rotation = parsed . args . length === 5 ? parsed . args [ 4 ] : false ; }
1628	function closest ( element , test ) { var el = element ; while ( el ) { if ( test ( el ) ) { return el ; } el = el . parentNode ; } return null ; }
2047	function ( app , callback ) { var options = { dir : configHelpers . getModulesPath ( ) , prefix : '' } ; npm . load ( options , function ( ) { npm . commands . uninstall ( [ app ] , callback ) ; } ) ; }
2844	function ( property , callback ) { if ( typeof property != "string" ) { callback = property ; property = "__all__" ; } this . _subscribers [ property ] = this . _subscribers [ property ] || [ ] ; if ( this . _subscribers [ property ] . indexOf ( callback ) == - 1 ) { this . _subscribers [ property ] . push ( callback ) ; } }
2307	function ( text ) { if ( ! text || ! text . replace ) return text return text . replace ( / (&[#a-zA-Z0-9]+;) / g , function ( m , s ) { return _convertEntity ( s ) } ) }
1407	function IsWritableStreamDefaultWriter ( x ) { if ( ! typeIsObject ( x ) ) { return false ; } if ( ! Object . prototype . hasOwnProperty . call ( x , '_ownerWritableStream' ) ) { return false ; } return true ; }
544	function detectInTree ( tree , handlers ) { var detectedOptions = { } ; handlers . forEach ( function ( handler ) { detectedOptions [ handler . name ] = handler . detect ( tree ) ; } ) ; return detectedOptions ; }
188	function listsRequestError ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST_FAILURE : const error = WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST_FAILURE === action . type ? action . error : false ; return error ; } return state ; }
1567	function watch ( file ) { if ( ! ~ extensions . indexOf ( extname ( file ) ) ) return ; fs . watchFile ( file , { interval : interval } , function ( curr , prev ) { if ( curr . mtime > prev . mtime ) { console . log ( ' \033[36mchanged\033[0m \033[90m- %s\033[0m' , \033 ) ; \033 } } ) ; }
3859	function on ( event , cb , context ) { var args = Array . prototype . slice . call ( arguments , 0 ) ; return dom . on . apply ( false , [ this ] . concat ( args ) ) ; }
3402	function finishLoad ( loader , load ) { if ( load . name ) { console . assert ( ! loader . modules [ load . name ] , 'load not in module table' ) ; loader . modules [ load . name ] = load . module ; } var loadIndex = indexOf . call ( loader . loads , load ) ; if ( loadIndex != - 1 ) loader . loads . splice ( loadIndex , 1 ) ; for ( var i = 0 , l = load . linkSets . length ; i < l ; i ++ ) { loadIndex = indexOf . call ( load . linkSets [ i ] . loads , load ) ; if ( loadIndex != - 1 ) load . linkSets [ i ] . loads . splice ( loadIndex , 1 ) ; } load . linkSets . splice ( 0 , load . linkSets . length ) ; }
563	function ( ) { if ( this . assigned . isEmpty ( ) === false ) { var eyeVertex , maxDistance = 0 ; var eyeFace = this . assigned . first ( ) . face ; var vertex = eyeFace . outside ; do { var distance = eyeFace . distanceToPoint ( vertex . point ) ; if ( distance > maxDistance ) { maxDistance = distance ; eyeVertex = vertex ; } vertex = vertex . next ; } while ( vertex !== null && vertex . face === eyeFace ) ; return eyeVertex ; } }
2701	function createSigner ( signatureScheme , signatureKey ) { if ( signatureKey ) { signatureScheme = signatureScheme || 'sha256' ; if ( signatureScheme . indexOf ( 'hmac-' ) === 0 ) { signatureScheme = signatureScheme . substr ( 5 ) ; } return { sign : function ( values ) { return computeSignature ( values , signatureScheme , signatureKey ) ; } , validate : function ( signature , values ) { return signature === computeSignature ( values , signatureScheme , signatureKey ) ; } } } else { return { sign : function ( ) { return '' ; } , validate : function ( ) { return true ; } } } }
1662	function modelInstance ( data ) { var self = this ; if ( schema ) { _ . assign ( self , schema . methods ) ; } Model . call ( self , data ) ; }
1460	function loadPartials ( files , metalsmith , done ) { var metadata = metalsmith . metadata ( ) ; fs . readdirAsync ( "./partials" , "utf8" ) . then ( files => { var promises = files . map ( filename => { var m = filename . match ( / ^(.+)\.([^.]+)$ / ) ; if ( ! m ) return ; var name = m [ 1 ] ; var ext = m [ 2 ] ; return fs . readFileAsync ( "partials/" + filename , "utf8" ) . then ( data => { var fn ; try { fn = dot . template ( data ) ; } catch ( err ) { console . log ( "Failed to load partial " + filename + ": " + err ) ; return ; } fn . name = filename ; metadata . partials [ filename ] = fn ; if ( ext == "html" ) metadata . partials [ name ] = fn ; } ) ; } ) ; return Promise . all ( promises ) ; } ) . then ( ( ) => done ( ) ) . catch ( err => done ( err ) ) ; }
3787	function deepLook ( obj , types ) { if ( typeof ( obj ) !== 'object' ) return obj ; for ( var key in obj ) { if ( ! obj [ key ] . type ) { obj [ key ] = deepLook ( obj [ key ] , types ) ; } else { if ( ! types [ obj [ key ] . type ] ) { throw new Error ( 'No type ' + obj [ key ] . type + ' in Types: key ' + key ) ; } if ( typeof obj [ key ] . min !== 'undefined' && typeof types [ obj [ key ] . type ] . min !== 'undefined' && types [ obj [ key ] . type ] . min > obj [ key ] . min ) { throw new Error ( 'Key ' + key + ' minimal value (' + obj [ key ] . min + ') is less than acceptable minimal in Types (' + types [ obj [ key ] . type ] . min + ')' ) ; } if ( typeof obj [ key ] . max !== 'undefined' && typeof types [ obj [ key ] . type ] . max !== 'undefined' && types [ obj [ key ] . type ] . max < obj [ key ] . max ) { throw new Error ( 'Key ' + key + ' maximal value (' + obj [ key ] . max + ') is in excess of maximal acceptable value in Types (' + types [ obj [ key ] . type ] . max + ')' ) ; } } for ( var keyParent in types [ obj [ key ] . type ] ) { if ( ! obj [ key ] [ keyParent ] ) { obj [ key ] [ keyParent ] = types [ obj [ key ] . type ] [ keyParent ] ; } } } return obj ; }
1052	function normalize ( value , patterns ) { var length = patterns . length var index = - 1 var pattern while ( ++ index < length ) { pattern = patterns [ index ] value = value . replace ( pattern [ 0 ] , pattern [ 1 ] ) } return value }
3497	function checkNodeIndent ( node , indent , excludeCommas ) { var nodeIndent = getNodeIndent ( node , false , excludeCommas ) ; if ( node . type !== "ArrayExpression" && node . type !== "ObjectExpression" && nodeIndent !== indent && isNodeFirstInLine ( node ) ) { report ( node , indent , nodeIndent ) ; } }
2998	function verify ( input , algorithm , secret , signature ) { const alg = algorithmMap [ algorithm ] if ( ! alg ) { errorMap [ '006' ] . message = 'Algorithm not recognized, signature verification failed' errorMap [ '006' ] . message = new Error ( errorMap [ '006' ] . message ) return false } const type = typeMap [ algorithm ] switch ( type ) { case 'hmac' : return hmacVerify ( input , alg , secret , signature ) case 'sign' : return rsaVerify ( input , alg , secret , signature ) default : return hmacVerify ( input , alg , secret , signature ) } }
3181	function ( date ) { var num = 0 , d = Ext . Date . clone ( date ) , m = date . getMonth ( ) , i ; for ( i = 0 , d . setDate ( 1 ) , d . setMonth ( 0 ) ; i < m ; d . setMonth ( ++ i ) ) { num += utilDate . getDaysInMonth ( d ) ; } return num + date . getDate ( ) - 1 ; }
2784	function F ( type , term ) { let original = term ; if ( term && ! term . __meta ) { term = type . wrap ? type . wrap ( term ) : term ; term . __meta = { } ; term . __name = function ( name ) { term . __meta . name = name ; return term ; } ; term . __desc = function ( desc ) { term . __meta . desc = desc ; return term ; } ; if ( term . __meta ) { term . __meta . term = original ; term . __meta . name = "anon" ; term . __meta . desc = "no description" ; } ; } ; F . check ( type , term ) ; return term ; }
727	function ( value , silent ) { var self = this ; var $item , i , idx ; $item = ( value instanceof $ ) ? value : self . getItem ( value ) ; value = hash_key ( $item . attr ( 'data-value' ) ) ; i = self . items . indexOf ( value ) ; if ( i !== - 1 ) { $item . remove ( ) ; if ( $item . hasClass ( 'active' ) ) { idx = self . $activeItems . indexOf ( $item [ 0 ] ) ; self . $activeItems . splice ( idx , 1 ) ; } self . items . splice ( i , 1 ) ; self . lastQuery = null ; if ( ! self . settings . persist && self . userOptions . hasOwnProperty ( value ) ) { self . removeOption ( value , silent ) ; } if ( i < self . caretPos ) { self . setCaret ( self . caretPos - 1 ) ; } self . refreshState ( ) ; self . updatePlaceholder ( ) ; self . updateOriginalInput ( { silent : silent } ) ; self . positionDropdown ( ) ; self . trigger ( 'item_remove' , value , $item ) ; } }
2416	function readImports ( imports , data ) { return ( imports . length === 0 ) ? Promise . resolve ( [ imports , data ] ) : new Promise ( ( resolve , reject ) => { let i = 0 ; ( function proceed ( error , importData ) { if ( importData ) { imports [ i ++ ] . data = importData ; } if ( error ) { reject ( error ) ; } else if ( i === imports . length ) { resolve ( [ imports , data ] ) ; } else { fs . readFile ( imports [ i ] . path , imports [ i ] . encoding , proceed ) ; } } ( ) ) ; } ) ; }
479	function runRejectableQueue ( queue ) { for ( var _len = arguments . length , args = Array ( _len > 1 ? _len - 1 : 0 ) , _key = 1 ; _key < _len ; _key ++ ) { args [ _key - 1 ] = arguments [ _key ] ; } return new _Promise ( function ( resolve , reject ) { var step = function step ( index ) { if ( index >= queue . length ) { resolve ( ) ; return ; } var result = isFunction ( queue [ index ] ) ? queue [ index ] . apply ( queue , _toConsumableArray ( args ) ) : queue [ index ] ; if ( result === false ) return reject ( 'stop' ) ; return _Promise . resolve ( result ) . then ( function ( ) { return step ( index + 1 ) ; } ) . catch ( function ( err ) { return reject ( err || 'stop' ) ; } ) ; } ; step ( 0 ) ; } ) ; }
1339	function disjunctionToList ( node ) { if ( node . type !== 'Disjunction' ) { throw new TypeError ( ` ${ node . type } ` ) ; } const list = [ ] ; if ( node . left && node . left . type === 'Disjunction' ) { list . push ( ... disjunctionToList ( node . left ) , node . right ) ; } else { list . push ( node . left , node . right ) ; } return list ; }
2642	function ( ) { return _ . map ( ko . unwrap ( that . relations ) , function ( relation ) { return ko . unwrap ( relation . relatedPost . id ) ; } ) ; }
750	function openSharer ( network , url ) { var this$1 = this ; var popupWindow = null ; if ( popupWindow && this . popup . interval ) { clearInterval ( this . popup . interval ) ; popupWindow . close ( ) ; this . $root . $emit ( 'social_shares_change' , network , this . url ) ; this . $emit ( 'change' , network , this . url ) ; } popupWindow = window . open ( url , 'sharer' , 'status=' + ( this . popup . status ? 'yes' : 'no' ) + ',height=' + this . popup . height + ',width=' + this . popup . width + ',resizable=' + ( this . popup . resizable ? 'yes' : 'no' ) + ',left=' + this . popup . left + ',top=' + this . popup . top + ',screenX=' + this . popup . left + ',screenY=' + this . popup . top + ',toolbar=' + ( this . popup . toolbar ? 'yes' : 'no' ) + ',menubar=' + ( this . popup . menubar ? 'yes' : 'no' ) + ',scrollbars=' + ( this . popup . scrollbars ? 'yes' : 'no' ) + ',location=' + ( this . popup . location ? 'yes' : 'no' ) + ',directories=' + ( this . popup . directories ? 'yes' : 'no' ) ) ; popupWindow . focus ( ) ; this . popup . interval = setInterval ( function ( ) { if ( popupWindow . closed ) { clearInterval ( this$1 . popup . interval ) ; popupWindow = undefined ; this$1 . $root . $emit ( 'social_shares_close' , network , this$1 . url ) ; this$1 . $emit ( 'close' , network , this$1 . url ) ; } } , 500 ) ; }
3026	function multiplyDuration ( startDuration , multiplier ) { if ( ! isFinite ( multiplier ) || multiplier <= 0 ) { throw new Error ( 'Invalid Multiplier' ) ; } var newDuration = { } , hasTime = false , duration = '' ; if ( startDuration . getSeconds ( ) ) { newDuration . seconds = Math . round ( startDuration . getSeconds ( ) * multiplier ) ; } if ( startDuration . getMinutes ( ) ) { newDuration . minutes = Math . round ( startDuration . getMinutes ( ) * multiplier ) ; } if ( startDuration . getHours ( ) ) { newDuration . hours = Math . round ( startDuration . getHours ( ) * multiplier ) ; } if ( startDuration . getDays ( ) ) { newDuration . days = Math . round ( startDuration . getDays ( ) * multiplier ) ; } if ( startDuration . getMonths ( ) ) { newDuration . months = Math . round ( startDuration . getMonths ( ) * multiplier ) ; } if ( startDuration . getYears ( ) ) { newDuration . years = Math . round ( startDuration . getYears ( ) * multiplier ) ; } if ( newDuration . seconds ) { hasTime = true ; duration = newDuration . seconds + 'S' + duration ; } if ( newDuration . minutes ) { hasTime = true ; duration = newDuration . minutes + 'M' + duration ; } if ( newDuration . hours ) { hasTime = true ; duration = newDuration . hours + 'H' + duration ; } if ( hasTime ) { duration = 'T' + duration ; } if ( newDuration . days ) { duration = newDuration . days + 'D' + duration ; } if ( newDuration . months ) { duration = newDuration . months + 'M' + duration ; } if ( newDuration . years ) { duration = newDuration . years + 'Y' + duration ; } if ( ! duration ) { throw new Error ( 'Invalid Duration Multiplier' ) ; } return new Duration ( 'P' + duration ) ; }
1271	function sendPacket ( socket , srcMAC , type , serverIP , yourIP ) { const opt55 = { id : 55 , bytes : [ 1 , 3 , 6 , ] , } ; let options ; if ( serverIP && yourIP ) { const opt54 = { id : 54 , bytes : [ serverIP . a , serverIP . b , serverIP . c , serverIP . d ] , } ; const opt50 = { id : 50 , bytes : [ yourIP . a , yourIP . b , yourIP . c , yourIP . d ] , } ; options = [ opt55 , opt54 , opt50 ] ; } else { options = [ opt55 ] ; } const u8 = dhcpPacket . create ( type , srcMAC , options ) ; socket . send ( IP4Address . BROADCAST , 67 , u8 ) ; }
3408	function ( dataIndex ) { var view = this . view , header = view . headerCt . down ( 'gridcolumn[dataIndex=' + dataIndex + ']' ) , menu = view . headerCt . getMenu ( ) ; return header ? menu . down ( 'menuitem[headerId=' + header . id + ']' ) : null ; }
118	function toggleControls ( force ) { var controls = this . elements . controls ; if ( controls && this . config . hideControls ) { var recentTouchSeek = this . touch && this . lastSeekTime + 2000 > Date . now ( ) ; this . toggleControls ( Boolean ( force || this . loading || this . paused || controls . pressed || controls . hover || recentTouchSeek ) ) ; } }
459	function getDomainFromData ( props , axis ) { const { polar , startAngle = 0 , endAngle = 360 } = props ; const tickValues = getTickArray ( props ) ; if ( ! Array . isArray ( tickValues ) ) { return undefined ; } const minDomain = Domain . getMinFromProps ( props , axis ) ; const maxDomain = Domain . getMaxFromProps ( props , axis ) ; const tickStrings = stringTicks ( props ) ; const ticks = tickValues . map ( ( value ) => + value ) ; const defaultMin = tickStrings ? 1 : Collection . getMinValue ( ticks ) ; const defaultMax = tickStrings ? tickValues . length : Collection . getMaxValue ( ticks ) ; const min = minDomain !== undefined ? minDomain : defaultMin ; const max = maxDomain !== undefined ? maxDomain : defaultMax ; const initialDomain = Domain . getDomainFromMinMax ( min , max ) ; const domain = polar && axis === "x" && Math . abs ( startAngle - endAngle ) === 360 ? Domain . getSymmetricDomain ( initialDomain , ticks ) : initialDomain ; if ( isVertical ( props ) && ! polar ) { domain . reverse ( ) ; } return domain ; }
2508	function unwatchAll ( ) { for ( var filePath in _fileWatchers ) { if ( _fileWatchers [ filePath ] ) _fileWatchers [ filePath ] . close ( ) ; delete _fileWatchers [ filePath ] ; } for ( var dirPath in _dirWatchers ) { if ( _dirWatchers [ dirPath ] ) _dirWatchers [ dirPath ] . close ( ) ; delete _dirWatchers [ dirPath ] ; } }
265	function hideToolbarFadeOnFullScroll ( ) { editor . $ ( [ editor . $ ( '.mce-inline-toolbar-grp .mce-container-body' , document . body ) , editor . $ ( '.mce-toolbar-grp' , editor . theme . panel . getEl ( ) ) , ] ) . each ( ( i , toolbar ) => { toolbar . on ( 'scroll' , throttle ( ( { target } ) => { let action ; if ( target . scrollLeft === target . scrollWidth - target . clientWidth ) { action = 'add' ; } else if ( tinymce . DOM . hasClass ( target , 'is-scrolled-full' ) ) { action = 'remove' ; } if ( action ) { const elements = editor . $ ( target ) ; if ( ! elements . hasClass ( 'mce-container-body' ) ) { elements . add ( tinymce . DOM . getParent ( target , '.mce-container-body' ) ) ; } elements [ action + 'Class' ] ( 'is-scrolled-full' ) ; } } , 200 ) ) ; } ) ; }
2294	function track ( property ) { if ( ! ( property in trackedProperties ) ) { trackedProperties [ property ] = true ; values [ property ] = model [ property ] ; Object . defineProperty ( model , property , { get : function ( ) { return values [ property ] ; } , set : function ( value ) { values [ property ] = value ; getListeners ( property ) . forEach ( function ( callback ) { callback ( value ) ; } ) ; } } ) ; } }
2959	function bypass ( req , conditions = { files : 1 , api : 1 } ) { if ( conditions . files ) { let regexp = / \w+\.\w+$ / i ; if ( req . path . match ( regexp ) ) { return true ; } } if ( conditions . api ) { let regexp = / ^\/api\/ / i ; if ( req . path . match ( regexp ) ) { return true ; } } }
496	function registerEvents ( ) { var _ref = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : { } , name = _ref . name , target = _ref . target ; if ( ! name || ! chimeeHelper . isString ( name ) ) throw new Error ( 'The event name must be a string, but not ' + ( typeof name === 'undefined' ? 'undefined' : _typeof ( name ) ) ) ; if ( ! target || ! chimeeHelper . isString ( target ) ) throw new Error ( 'The event target must be a string, but not ' + ( typeof target === 'undefined' ? 'undefined' : _typeof ( target ) ) ) ; if ( target === 'kernel' ) { kernelEvents . push ( name ) ; } }
3223	function lock ( client , sequence ) { const lastSequence = sequences . get ( client . projectId ) ; return Promise . resolve ( lastSequence ) . then ( ( ) => { const result = sequence ( ) ; sequences . set ( client . projectId , result . then ( noop , noop ) ) ; return result ; } ) ; }
2193	function Event ( a , b , type , idx ) { this . a = a this . b = b this . type = type this . idx = idx }
287	function doesNotNeedSandbox ( iframe ) { const trustedHosts = [ 'spotify.com' , 'kickstarter.com' , 'soundcloud.com' , 'embed.ted.com' , 'player.twitch.tv' , ] ; const hostName = iframe . src && url . parse ( iframe . src ) . hostname ; const iframeHost = hostName && hostName . toLowerCase ( ) ; return some ( trustedHosts , trustedHost => endsWith ( '.' + iframeHost , '.' + trustedHost ) ) ; }
428	function ( less , context , rootFileInfo ) { this . less = less ; this . rootFilename = rootFileInfo . filename ; this . paths = context . paths || [ ] ; this . contents = { } ; this . contentsIgnoredChars = { } ; this . mime = context . mime ; this . error = null ; this . context = context ; this . queue = [ ] ; this . files = { } ; }
3326	function ( ) { var scrollHeight = Math . max ( this . output . scrollHeight , this . output . clientHeight ) ; this . output . scrollTop = scrollHeight - this . output . clientHeight ; }
1046	function ruleCodes ( flags , value ) { var flag = flags . FLAG var result = [ ] var length var index if ( ! value ) { return result } if ( flag === 'long' ) { index = 0 length = value . length while ( index < length ) { result . push ( value . substr ( index , 2 ) ) index += 2 } return result } return value . split ( flag === 'num' ? ',' : '' ) }
703	function viewAndSaveQuery ( outline , selection ) { var qs = outline . qs UI . log . info ( 'outline.doucment is now ' + outline . document . location ) var q = saveQuery ( selection , qs ) for ( let i = 0 ; i < qs . listeners . length ; i ++ ) { qs . listeners [ i ] . getActiveView ( ) . view . drawQuery ( q ) qs . listeners [ i ] . updateQueryControls ( qs . listeners [ i ] . getActiveView ( ) ) } }
2419	function ( N , data , CART_OR_SPH , DIRECT_OR_PINV ) { var Ndirs = data . length , Nsh = ( N + 1 ) * ( N + 1 ) ; var invY_N ; var mag = [ , ] ; if ( Nsh > Ndirs ) { console . log ( "The SHT degree is too high for the number of data points" ) } if ( CART_OR_SPH == 0 ) data = convertCart2Sph ( data ) ; for ( var i = 0 ; i < data . length ; i ++ ) { mag [ i ] = data [ i ] [ 2 ] ; } Y_N = computeRealSH ( N , data ) ; if ( DIRECT_OR_PINV == 0 ) { invY_N = numeric . mul ( 1 / Ndirs , Y_N ) ; } else { invY_N = pinv_direct ( numeric . transpose ( Y_N ) ) ; } var coeffs = numeric . dotMV ( invY_N , mag ) ; return coeffs ; }
327	function scaleX ( _scaleX ) { var scaleY = this . imageData . scaleY ; return this . scale ( _scaleX , isNumber ( scaleY ) ? scaleY : 1 ) ; }
765	function Rotation ( config ) { this . realmUrl = config . realmUrl ; this . minTimeBetweenJwksRequests = config . minTimeBetweenJwksRequests ; this . jwks = [ ] ; this . lastTimeRequesTime = 0 ; }
2056	function ( newTaTools ) { var _this = this ; angular . forEach ( newTaTools , function ( _newTool , key ) { _this . updateToolDisplay ( key , _newTool ) ; } ) ; }
654	function ( app ) { this . app = app ; this . loaded = false ; this . preloadThreshold = 3000 ; this . plugins = { } ; this . modifications = { } ; this . customTests = [ ] ; setTimeout ( this . _pollLoadingPlugins . bind ( this ) , 1500 ) ; }
1663	function ( assemble , next ) { grunt . verbose . writeln ( 'Validating options' ) ; if ( utils . endsWithDot ( assemble . options . ext ) ) { grunt . warn ( 'Invalid ext "' + assemble . options . ext + '". ext cannot end with a period.' ) ; done ( false ) ; } assemble . options . engine = assemble . options . engine || 'handlebars' ; grunt . verbose . ok ( '>> Current engine:' . yellow , assemble . options . engine ) ; assemble . engine . load ( assemble . options . engine ) ; var initializeEngine = function ( engine , options ) { engine . init ( options , { grunt : grunt , assemble : assemble } ) ; } ; assemble . options . initializeEngine = assemble . options . initializeEngine || initializeEngine ; var registerFunctions = function ( engine ) { engine . registerFunctions ( ) ; } ; assemble . options . registerFunctions = assemble . options . registerFunctions || registerFunctions ; var registerPartial = function ( engine , filename , content ) { engine . registerPartial ( filename , content ) ; } ; assemble . options . registerPartial = assemble . options . registerPartial || registerPartial ; assemble . partials = file . expand ( assemble . options . partials ) ; if ( _ . isArray ( assemble . options . dataFiles ) && assemble . options . dataFiles . length > 0 ) { assemble . dataFiles = file . expand ( assemble . options . dataFiles ) ; } if ( assemble . options . layouts ) { assemble . layoutFiles = file . expand ( { filter : 'isFile' } , assemble . options . layouts ) ; } if ( assemble . layoutFiles && assemble . layoutFiles . length !== 0 ) { grunt . verbose . writeln ( 'Found layout files:' . yellow , assemble . layoutFiles ) ; } else { assemble . layoutFiles = null ; } assemble . options . initializeEngine ( assemble . engine , assemble . options ) ; assemble . options . registerFunctions ( assemble . engine ) ; next ( assemble ) ; }
3799	function Polling ( objGoogleCheckout ) { var self = this ; assert . ok ( objGoogleCheckout , "A GoogleCheckout object is the only required argument" ) ; self . gc = objGoogleCheckout ; self . settings = self . gc . settings ; self . continueToken = null ; }
2746	function logMessage ( message , data ) { if ( ! message ) return render ( message , data , function ( err , res ) { if ( err ) { console . error ( '\n Error when rendering template complete message: ' + \n ) } else err . message . trim ( ) } ) }
125	function loadjs ( paths , arg1 , arg2 ) { var bundleId , args ; if ( arg1 && arg1 . trim ) bundleId = arg1 ; args = ( bundleId ? arg2 : arg1 ) || { } ; if ( bundleId ) { if ( bundleId in bundleIdCache ) { throw "LoadJS" ; } else { bundleIdCache [ bundleId ] = true ; } } function loadFn ( resolve , reject ) { loadFiles ( paths , function ( pathsNotFound ) { executeCallbacks ( args , pathsNotFound ) ; if ( resolve ) { executeCallbacks ( { success : resolve , error : reject } , pathsNotFound ) ; } publish ( bundleId , pathsNotFound ) ; } , args ) ; } if ( args . returnPromise ) return new Promise ( loadFn ) ; else loadFn ( ) ; }
1697	function _touchEnd ( event ) { var primaryTouch = this . _scroll . activeTouches . length ? this . _scroll . activeTouches [ 0 ] : undefined ; for ( var i = 0 ; i < event . changedTouches . length ; i ++ ) { var changedTouch = event . changedTouches [ i ] ; for ( var j = 0 ; j < this . _scroll . activeTouches . length ; j ++ ) { var touch = this . _scroll . activeTouches [ j ] ; if ( touch . id === changedTouch . identifier ) { this . _scroll . activeTouches . splice ( j , 1 ) ; if ( ( j === 0 ) && this . _scroll . activeTouches . length ) { var newPrimaryTouch = this . _scroll . activeTouches [ 0 ] ; newPrimaryTouch . start [ 0 ] = newPrimaryTouch . current [ 0 ] - ( touch . current [ 0 ] - touch . start [ 0 ] ) ; newPrimaryTouch . start [ 1 ] = newPrimaryTouch . current [ 1 ] - ( touch . current [ 1 ] - touch . start [ 1 ] ) ; } break ; } } } if ( ! primaryTouch || this . _scroll . activeTouches . length ) { return ; } var velocity = 0 ; var diffTime = primaryTouch . time - primaryTouch . prevTime ; if ( ( diffTime > 0 ) && ( ( _getEventTimestamp ( event ) - primaryTouch . time ) <= this . options . touchMoveNoVelocityDuration ) ) { var diffOffset = primaryTouch . current [ this . _direction ] - primaryTouch . prev [ this . _direction ] ; velocity = diffOffset / diffTime ; } var delta = this . _scroll . touchDelta ; var swipeDirection = ( Math . abs ( primaryTouch . current [ 0 ] - primaryTouch . prev [ 0 ] ) > Math . abs ( primaryTouch . current [ 1 ] - primaryTouch . prev [ 1 ] ) ) ? 0 : 1 ; var allowSwipes = ( swipeDirection === this . _direction ) ; this . releaseScrollForce ( delta , velocity , allowSwipes ) ; this . _scroll . touchDelta = 0 ; }
3206	function ( toClose ) { var me = this ; if ( toClose . active && me . items . getCount ( ) > 1 ) { return ( me . previousTab && me . previousTab !== toClose && ! me . previousTab . disabled ) ? me . previousTab : ( toClose . next ( 'tab[disabled=false]' ) || toClose . prev ( 'tab[disabled=false]' ) ) ; } }
2940	function toJavascript ( data , mergeInto ) { var result = mergeInto || { } var keys = Object . keys ( data ) for ( var i = 0 ; i < keys . length ; i ++ ) { var p = keys [ i ] result [ p ] = toJsValue ( data [ p ] ) } return result }
989	function sortOperations ( op1 , op2 ) { var pathCmp = op1 . path . localeCompare ( op2 . path ) ; if ( pathCmp !== 0 ) { return pathCmp ; } var index1 = methodOrder . indexOf ( op1 . method ) ; var index2 = methodOrder . indexOf ( op2 . method ) ; if ( index1 > - 1 && index2 > - 1 ) { return index1 > index2 ? 1 : ( index1 < index2 ? - 1 : 0 ) ; } if ( index1 > - 1 ) { return - 1 ; } if ( index2 > - 1 ) { return 1 ; } return op1 . method . localeCompare ( op2 . method ) ; }
1547	function fetch ( point , octree , octant ) { const children = octant . children ; let result = null ; let i , l ; let points ; if ( octant . contains ( point , octree . bias ) ) { if ( children !== null ) { for ( i = 0 , l = children . length ; result === null && i < l ; ++ i ) { result = fetch ( point , octree , children [ i ] ) ; } } else if ( octant . points !== null ) { points = octant . points ; for ( i = 0 , l = points . length ; result === null && i < l ; ++ i ) { if ( point . equals ( points [ i ] ) ) { result = octant . data [ i ] ; } } } } return result ; }
3458	function accept_multi ( filename , state ) { state = state || { } ; debug . assert ( filename ) . is ( 'string' ) ; debug . assert ( state ) . is ( 'object' ) ; if ( state . directory ) { return accept_dir ( filename , state ) ; } if ( state . file ) { return accept_file ( filename , state ) ; } return ; }
673	function ( sentences , transitionWords ) { const results = [ ] ; sentences . forEach ( sentence => { const twoPartMatches = matchTwoPartTransitionWords ( sentence , transitionWords . twoPartTransitionWords ( ) ) ; if ( twoPartMatches !== null ) { results . push ( { sentence : sentence , transitionWords : twoPartMatches , } ) ; return ; } const transitionWordMatches = matchTransitionWords ( sentence , transitionWords . transitionWords ) ; if ( transitionWordMatches . length !== 0 ) { results . push ( { sentence : sentence , transitionWords : transitionWordMatches , } ) ; return ; } } ) ; return results ; }
146	function hasLanguageChanged ( languageSettingValue , settings = { } ) { if ( ! languageSettingValue ) { return false ; } return ( ( languageSettingValue === settings . language && isEmpty ( settings . locale_variant ) ) || languageSettingValue === settings . locale_variant ) ; }
721	function ( destUa , cryptowords ) { for ( let i = 0 ; i < destUa . length ; i += 4 ) { let v = cryptowords . words [ i / 4 ] ; if ( v < 0 ) v += 0x100000000 ; destUa [ i ] = ( v >>> 24 ) ; destUa [ i + 1 ] = ( v >>> 16 ) & 0xff ; destUa [ i + 2 ] = ( v >>> 8 ) & 0xff ; destUa [ i + 3 ] = v & 0xff ; } return destUa ; }
3716	function fixSidebar ( ) { if ( $sidebarInner . outerHeight ( ) < $content . outerHeight ( ) ) { $sidebar . addClass ( 'kss-fixed' ) ; if ( $sidebarInner . outerHeight ( ) > $window . height ( ) ) { $sidebar . height ( $window . height ( ) ) ; $window . on ( 'scroll' , scrollSidebar ) . trigger ( 'scroll' ) ; } else { $sidebar . height ( 'auto' ) ; $window . off ( 'scroll' , scrollSidebar ) ; } } else { $sidebar . removeClass ( 'kss-fixed' ) ; $sidebar . height ( 'auto' ) ; $window . off ( 'scroll' , scrollSidebar ) ; } }
3781	function Block ( line , def , parent ) { this . startNames = [ ] ; this . thenNames = [ ] ; this . endNames = [ ] ; for ( var i = 0 ; i < def . start . length ; i ++ ) this . startNames . push ( def . start [ i ] . toLowerCase ( ) ) ; for ( var x = 0 ; x < def . end . length ; x ++ ) this . endNames . push ( def . end [ x ] . toLowerCase ( ) ) ; for ( var y = 0 ; y < def . then . length ; y ++ ) this . thenNames . push ( def . then [ y ] . toLowerCase ( ) ) ; this . line = line ; this . parent = parent ; this . searchIndex = line ; this . start = - 1 ; this . intermediateIndexes = { } ; this . intermediateCursors = { } ; this . end = - 1 ; }
136	function getNewMessages ( previousCartValue , nextCartValue ) { previousCartValue = previousCartValue || { } ; nextCartValue = nextCartValue || { } ; const nextCartMessages = nextCartValue . messages || [ ] ; if ( ! previousCartValue || ! previousCartValue . client_metadata || ! nextCartValue . client_metadata ) { return nextCartMessages ; } const previousDate = previousCartValue . client_metadata . last_server_response_date ; const nextDate = nextCartValue . client_metadata . last_server_response_date ; const hasNewServerData = i18n . moment ( nextDate ) . isAfter ( previousDate ) ; return hasNewServerData ? nextCartMessages : [ ] ; }
2637	function deepSet ( parent , key , value , mode ) { var parts = key . split ( '.' ) ; var current = parent ; if ( key === 'this' ) { if ( mode === 'push' ) parent . push ( value ) ; else parent = value . toString ( ) ; } else { for ( var i = 0 ; i < parts . length ; i ++ ) { if ( i >= parts . length - 1 ) { if ( mode === 'push' ) current [ parts [ i ] ] . push ( value ) ; else current [ parts [ i ] ] = value ; } else current [ parts [ i ] ] = current [ parts [ i ] ] || { } ; current = current [ parts [ i ] ] ; } } return parent ; }
3163	function execute ( ) { command . exec ( env , request . args , request ) ; if ( ! request . isAsync && ! request . isDone ) { request . done ( ) ; } }
1254	function findNearestCommonParentChunk ( chunkGroups , currentDistance = 0 ) { const distances = new Map ( ) ; for ( let i = 1 ; i < chunkGroups . length ; i ++ ) { const distance = findAncestorDistance ( chunkGroups [ i ] , chunkGroups [ 0 ] , currentDistance ) ; if ( distance < 0 ) { distances . delete ( chunkGroups [ 0 ] ) ; } else if ( ! distances . has ( chunkGroups [ 0 ] ) || distance < distances . get ( chunkGroups [ 0 ] ) ) { distances . set ( chunkGroups [ 0 ] , distance ) ; } } if ( distances . size === 0 ) { chunkGroups [ 0 ] . getParents ( ) . forEach ( ( chunkGroupParent ) => { const distanceRecord = findNearestCommonParentChunk ( [ chunkGroupParent ] . concat ( chunkGroups . slice ( 1 ) ) , currentDistance + 1 ) ; if ( distanceRecord . distance >= 0 && ( ! distances . has ( distanceRecord . chunkGroup ) || distances . get ( distanceRecord . chunkGroup ) < distanceRecord . distance ) ) { distances . set ( distanceRecord . chunkGroup , distanceRecord . distance ) ; } } ) ; } const nearestCommonParent = { chunkGroup : undefined , distance : - 1 , } ; distances . forEach ( ( distance , chunkGroup ) => { if ( nearestCommonParent . distance < 0 || distance < nearestCommonParent . distance ) { nearestCommonParent . chunkGroup = chunkGroup ; nearestCommonParent . distance = distance ; } } ) ; return nearestCommonParent ; }
800	function Request ( method , urlPath , cache ) { this . _method = method ; this . _urlPath = urlPath ; this . _cache = cache ; this . _queryParams = [ ] ; this . _postParams = null ; this . _headers = { } ; this . _timeout = null ; this . _type = "json" ; this . aborted = undefined ; }
39	function notifyHandlers ( stack , isWindowError ) { var exception = null ; if ( isWindowError && ! TraceKit . collectWindowErrors ) { return ; } for ( var i in handlers ) { if ( handlers . hasOwnProperty ( i ) ) { try { handlers [ i ] . apply ( null , [ stack ] . concat ( _slice . call ( arguments , 2 ) ) ) ; } catch ( inner ) { exception = inner ; } } } if ( exception ) { throw exception ; } }
2469	function replace ( regex , replacement , fileFilter ) { if ( fileFilter instanceof Array ) { fileFilter = fileFilter . reduce ( pcomp ) ; } else if ( ! fileFilter ) { fileFilter = ( ) => true ; } return files => { _ . forEach ( files , ( file , path ) => { if ( fileFilter ( file , path ) ) { file . contents = new Buffer ( file . contents . toString ( ) . replace ( regex , replacement ) ) ; } } ) ; } }
907	function normalizeWindowConfig ( windowConfig ) { if ( ! windowConfig ) { return ; } let result = { } ; Object . keys ( windowConfig ) . forEach ( k => { let newKey = DISPLAY_PAGE_CONFIG_MAP [ k ] ; if ( newKey ) { result [ newKey ] = windowConfig [ k ] ; } } ) ; return result ; }
608	function textPresenceAssessment ( paper , researcher , i18n ) { const text = stripHTMLTags ( paper . getText ( ) ) ; const urlTitle = createAnchorOpeningTag ( "https://yoa.st/35h" ) ; const urlCallToAction = createAnchorOpeningTag ( "https://yoa.st/35i" ) ; if ( text . length < 50 ) { const result = new AssessmentResult ( ) ; result . setText ( i18n . sprintf ( i18n . dgettext ( "js-text-analysis" , "%1$sNot enough content%2$s: %3$sPlease add some content to enable a good analysis%2$s." ) , urlTitle , "</a>" , urlCallToAction ) ) ; result . setScore ( 3 ) ; return result ; } return new AssessmentResult ( ) ; }
2942	function deepClone ( obj ) { if ( obj == null || typeof obj !== 'object' ) { return obj ; } var cloned = obj . constructor ( ) ; for ( var key in obj ) { if ( obj . hasOwnProperty ( key ) ) { cloned [ key ] = deepClone ( obj [ key ] ) ; } } return cloned ; }
2156	function ( playAnimation ) { if ( ! animationCompleted ) { animationPaused = ! playAnimation ; if ( timings . animationDuration ) { var value = blockKeyframeAnimations ( node , animationPaused ) ; if ( animationPaused ) { temporaryStyles . push ( value ) ; } else { removeFromArray ( temporaryStyles , value ) ; } } } else if ( animationPaused && playAnimation ) { animationPaused = false ; close ( ) ; } }
2586	function yyyymmdd ( d , delim ) { if ( ! ( d instanceof Date ) ) return d ; delim = typeof delim !== 'string' ? '-' : delim ; var dd = d . getDate ( ) , mm = d . getMonth ( ) + 1 , yyyy = d . getFullYear ( ) ; if ( dd < 10 ) dd = '0' + dd ; if ( mm < 10 ) mm = '0' + mm ; return yyyy + delim + mm + delim + dd ; }
1915	function toggleHTMLComment ( editor ) { var range = require ( 'range' ) . create ( editor . getSelectionRange ( ) ) ; var info = require ( 'editorUtils' ) . outputInfo ( editor ) ; if ( ! range . length ( ) ) { var tag = require ( 'htmlMatcher' ) . tag ( info . content , editor . getCaretPos ( ) ) ; if ( tag ) { range = tag . outerRange ; } } return genericCommentToggle ( editor , '<!--' , ' , range ) ; }
1593	function codeConfig ( config ) { const conf = Object . create ( null ) ; for ( const key in config . custom ) { conf [ key ] = config . custom [ key ] ; } for ( const key of [ 'host' , 'port' , 'backendPort' ] ) { conf [ key ] = config [ key ] ; } return conf ; }
648	function showTrace ( errorMessage ) { if ( isUndefined ( errorMessage ) ) { errorMessage = "" ; } if ( ! isUndefined ( console ) && ! isUndefined ( console . trace ) ) { console . trace ( errorMessage ) ; } }
1699	function _setParticle ( position , velocity , phase ) { if ( position !== undefined ) { this . _scroll . particleValue = position ; this . _scroll . particle . setPosition1D ( position ) ; if ( this . _scroll . springValue !== undefined ) { this . _scroll . pe . wake ( ) ; } } if ( velocity !== undefined ) { var oldVelocity = this . _scroll . particle . getVelocity1D ( ) ; if ( oldVelocity !== velocity ) { this . _scroll . particle . setVelocity1D ( velocity ) ; } } }
2943	function deepMerge ( one , another ) { if ( another == null || typeof another !== 'object' ) { return another ; } if ( one == null && typeof another === 'object' ) { if ( Array . isArray ( another ) ) { one = [ ] ; } else { one = { } ; } } var cloned = deepClone ( another ) ; for ( var key in cloned ) { if ( cloned . hasOwnProperty ( key ) ) { one [ key ] = deepMerge ( one [ key ] , another [ key ] ) ; } } return one ; }
675	function getIndicesOfCharacter ( text , characterToFind ) { const indices = [ ] ; if ( text . indexOf ( characterToFind ) > - 1 ) { for ( let i = 0 ; i < text . length ; i ++ ) { if ( text [ i ] === characterToFind ) { indices . push ( i ) ; } } } return indices ; }
3145	function ( ) { var me = this , layouts = me . layoutQueue . clear ( ) , length = layouts . length , i ; ++ me . cycleCount ; me . progressCount = 0 ; for ( i = 0 ; i < length ; ++ i ) { me . runLayout ( me . currentLayout = layouts [ i ] ) ; } me . currentLayout = null ; return me . progressCount > 0 ; }
137	function isRedirectToValidForSsr ( redirectToQueryValue ) { if ( 'undefined' === typeof redirectToQueryValue ) { return true ; } const redirectToDecoded = decodeURIComponent ( redirectToQueryValue ) ; return ( redirectToDecoded . startsWith ( 'https://wordpress.com/theme' ) || redirectToDecoded . startsWith ( 'https://wordpress.com/go' ) ) ; }
1209	function ( ) { this . observe ( "paste:composer" , function ( ) { var keepScrollPosition = true , that = this ; that . composer . selection . executeAndRestore ( function ( ) { wysihtml5 . quirks . cleanPastedHTML ( that . composer . element ) ; that . parse ( that . composer . element ) ; } , keepScrollPosition ) ; } ) ; this . observe ( "paste:textarea" , function ( ) { var value = this . textarea . getValue ( ) , newValue ; newValue = this . parse ( value ) ; this . textarea . setValue ( newValue ) ; } ) ; }
797	function readFilePromise ( filename ) { var deferred ; deferred = Q . defer ( ) ; fs . readFile ( filename , 'utf-8' , function ( err , contents ) { if ( err ) { if ( err . code === 'ENOENT' ) { debug ( err . code + ': ' + filename ) ; return deferred . resolve ( ) ; } debug ( err + ' ' + filename ) ; deferred . reject ( err ) ; } else { debug ( 'read ' + filename ) ; deferred . resolve ( contents ) ; } } ) ; return deferred . promise ; }
3767	function copy ( target , source ) { for ( var key in Object ( source ) ) target [ key ] = source [ key ] return target }
2871	function grayTransform ( entry , direction , x , dim ) { return bitwise . rotateRight ( ( x ^ entry ) , dim , 0 , direction + 1 ) }
1435	async function ( repo_name , library_name ) { let library = ( await this . getContribData ( ) ) . libraries . find ( lib => lib . repo_name === repo_name && lib . library_name === library_name ) ; return library ? library . repo_tag : false ; }
651	function ( indices ) { indices = sortIndices ( indices ) ; var filtered = [ ] ; for ( var i = 0 ; i < indices . length ; i ++ ) { if ( ! isUndefined ( indices [ i + 1 ] ) && indices [ i + 1 ] . index < indices [ i ] . index + indices [ i ] . match . length ) { filtered . push ( indices [ i ] ) ; i ++ ; continue ; } filtered . push ( indices [ i ] ) ; } return filtered ; }
1322	function areEquivalent ( s1 , s2 , table , alphabet ) { for ( const symbol of alphabet ) { if ( ! goToSameSet ( s1 , s2 , table , symbol ) ) { return false ; } } return true ; }
1278	function addWEPropertyIfDefined ( object , property , value ) { if ( ! IS_UNDEFINED ( value ) ) { defineWEProperty ( object , property , value ) ; } }
1807	function ( name , value ) { if ( arguments . length > 1 ) { for ( var i = this . length - 1 ; i >= 0 ; i -- ) { utils . prop ( this [ i ] , name , value ) ; } return this ; } else { return this [ 0 ] ? utils . prop ( this [ 0 ] , name ) : "" ; } }
229	function floodlightSessionId ( ) { const cookies = cookie . parse ( document . cookie ) ; const existingSessionId = cookies [ DCM_FLOODLIGHT_SESSION_COOKIE_NAME ] ; if ( existingSessionId ) { debug ( 'Floodlight: Existing session: ' + existingSessionId ) ; return existingSessionId ; } const newSessionId = uuid ( ) . replace ( new RegExp ( '-' , 'g' ) , '' ) ; debug ( 'Floodlight: New session: ' + newSessionId ) ; return newSessionId ; }
2246	function get ( czConfig ) { const scopes = [ ] ; if ( typeof czConfig . scopes === 'undefined' ) { return defaults ; } for ( const scope of czConfig . scopes ) { scopes . push ( scope . name ) ; } if ( typeof czConfig . scopeOverrides === 'undefined' ) { return scopes ; } for ( const type of Object . keys ( czConfig . scopeOverrides ) ) { for ( const scope of czConfig . scopeOverrides [ type ] ) { scopes . push ( scope . name ) ; } } return scopes . filter ( function ( value , index , scope ) { return scope . indexOf ( value ) === index ; } ) ; }
2117	function ( argumentsArray ) { var callback = noop ; if ( argumentsArray . length && ( typeof argumentsArray [ argumentsArray . length - 1 ] === 'function' ) ) { callback = argumentsArray . pop ( ) ; } var title = null ; var options = null ; if ( argumentsArray . length === 2 ) { title = argumentsArray [ 0 ] ; options = argumentsArray [ 1 ] ; } else if ( argumentsArray . length === 1 ) { var value = argumentsArray . pop ( ) ; if ( typeof value === 'string' ) { title = value ; options = { } ; } else { title = '' ; options = value ; } } title = title || '' ; options = options || { } ; return { callback : callback , title : title , options : options } ; }
3059	function parseComment ( comment , append ) { var escapedollar = '----esacepedollar' + '---' + 'jsdoc-at-examples---' ; function unescape ( result ) { return result . replace ( new RegExp ( escapedollar , 'g' ) , '$$' ) ; } comment . value = comment . value . replace ( / \$ / g , escapedollar ) ; var expose , examples , current , statement ; var test = { setup : [ ] , tests : [ ] , teardown : [ ] } ; var hastest = false ; comment = comment . value . replace ( / \$ / g , '$$$' ) . replace ( / \r / g , '' ) ; comment = comment . replace ( / \$ / g , '$$$' ) . replace ( RegExp ( spansLine ( '' ) ) , '' ) ; expose = RegExp ( spansLine ( '@expose\\s*(' + \\ + identifier ( ) ) , '*)' ) ; 'g' examples = RegExp ( spansLine ( '@examples' ) + '((?:' + spansLine ( '.*//.*' ) + ')*)' , 'g' ) ; while ( current = expose . exec ( comment ) ) { statement = buildExpose ( unescape ( current [ 1 ] ) ) ; if ( statement ) append ( statement ) ; } while ( current = splitLines ( examples . exec ( comment ) ) ) { for ( var i in current ) { if ( parseExampleLine ( current [ i ] [ 0 ] , current [ i ] [ 1 ] , test ) ) { hastest = true ; } } } }
2836	function createDirectory ( filePath , cb ) { var dirname = path . dirname ( filePath ) ; mkdirp ( dirname , function ( err ) { if ( ! err ) { cb ( ) ; } else { console . error ( 'Error creating directory: ' , err ) ; } } ) ; }
34	function parseId ( url ) { if ( is . empty ( url ) ) { return null ; } const regex = / ^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).* / ; return url . match ( regex ) ? RegExp . $2 : url ; }
1587	function range ( low , high ) { const results = [ ] ; for ( var j = low ; j <= high ; j ++ ) { results . push ( j ) ; } return results ; }
3764	function MarkLogicStore ( options ) { options = options || { } ; var collectionName = options . collection || defaultOptions . collection ; this . baseUri = options . baseUri || encodeURI ( collectionName . replace ( / \s / g , '-' ) ) ; Store . call ( this , options ) ; this . collectionName = collectionName ; this . ttl = options . ttl || defaultOptions . ttl || 0 ; this . db = options . client || marklogic . createDatabaseClient ( options ) ; }
653	function createMeasurementElement ( ) { const hiddenElement = document . createElement ( "div" ) ; hiddenElement . id = elementId ; hiddenElement . style . position = "absolute" ; hiddenElement . style . left = "-9999em" ; hiddenElement . style . top = 0 ; hiddenElement . style . height = 0 ; hiddenElement . style . overflow = "hidden" ; hiddenElement . style . fontFamily = "arial, sans-serif" ; hiddenElement . style . fontSize = "18px" ; hiddenElement . style . fontWeight = "400" ; document . body . appendChild ( hiddenElement ) ; return hiddenElement ; }
1728	function _setSelectedItem ( index ) { if ( index !== this . _selectedItemIndex ) { var oldIndex = this . _selectedItemIndex ; this . _selectedItemIndex = index ; this . layout . setLayoutOptions ( { selectedItemIndex : index } ) ; if ( ( oldIndex >= 0 ) && this . _renderables . items [ oldIndex ] . removeClass ) { this . _renderables . items [ oldIndex ] . removeClass ( 'selected' ) ; } if ( this . _renderables . items [ index ] . addClass ) { this . _renderables . items [ index ] . addClass ( 'selected' ) ; } if ( oldIndex >= 0 ) { this . _eventOutput . emit ( 'tabchange' , { target : this , index : index , oldIndex : oldIndex , item : this . _renderables . items [ index ] , oldItem : ( ( oldIndex >= 0 ) && ( oldIndex < this . _renderables . items . length ) ) ? this . _renderables . items [ oldIndex ] : undefined } ) ; } } }
41	function report ( ex , rethrow ) { var args = _slice . call ( arguments , 1 ) ; if ( lastExceptionStack ) { if ( lastException === ex ) { return ; } else { processLastException ( ) ; } } var stack = TraceKit . computeStackTrace ( ex ) ; lastExceptionStack = stack ; lastException = ex ; lastArgs = args ; setTimeout ( function ( ) { if ( lastException === ex ) { processLastException ( ) ; } } , stack . incomplete ? 2000 : 0 ) ; if ( rethrow !== false ) { throw ex ; } }
812	function makeThresholdsSieve ( options , defaults ) { if ( ! options ) options = { } ; Object . keys ( defaults ) . forEach ( key => options [ key ] || ( options [ key ] = defaults [ key ] ) ) ; return ( key , overrides ) => { if ( overrides && overrides [ key ] !== void 0 ) return overrides [ key ] ; return options [ key ] ; } }
1118	function listPrivateKey ( keyType , folder , name , noRetry ) { let privateKeyName ; if ( noRetry ) { privateKeyName = name . replace ( REG_EXPS . KEY_SUFFIX , '' ) ; } else { privateKeyName = ( name . match ( REG_EXPS . KEY_SUFFIX ) ) ? name : ` ${ name } ` ; } return util . runTmshCommand ( ` ${ keyType } ${ folder } ${ privateKeyName } ` ) . then ( ( keyData ) => { if ( ! keyData ) { if ( ! noRetry ) { return listPrivateKey ( keyType , folder , name , true ) ; } return q ( ) ; } return q ( { privateKeyName , keyData } ) ; } ) . catch ( ( err ) => { const notFoundRegex = / 01020036:3 / ; if ( err . message . match ( notFoundRegex ) && ! noRetry ) { return listPrivateKey ( keyType , folder , name , true ) ; } return q . reject ( err ) ; } ) ; }
1510	function intArray ( val ) { var array = [ ] , encVal = val , bytes ; if ( val === 0 ) { array . push ( 0 ) ; } else { if ( val < 0 ) { bytes = Math . floor ( 1 + Math . log ( - val ) / LOG256 ) ; encVal += Math . pow ( 2 , 8 * bytes ) ; } while ( encVal > 0 ) { array . push ( encVal % 256 ) ; encVal = parseInt ( encVal / 256 , 10 ) ; } } if ( val > 0 && array [ array . length - 1 ] >= 0x80 ) { array . push ( 0 ) ; } return array . reverse ( ) ; }
557	function ( vertex , face ) { if ( vertex === face . outside ) { if ( vertex . next !== null && vertex . next . face === face ) { face . outside = vertex . next ; } else { face . outside = null ; } } this . assigned . remove ( vertex ) ; return this ; }
1733	function removeFromExports ( exports , dependencies = { } ) { const localExports = { ... exports } ; Object . keys ( localExports ) . forEach ( ( exported ) => { if ( dependencies [ exported ] ) { delete localExports [ exported ] ; } } ) ; return localExports ; }
3694	function isExtendable ( ... args ) { if ( args . length < 1 ) return false ; let baseType = typeForExtend ( args [ 0 ] ) ; if ( ! ( baseType === types . array || baseType === types . object || baseType === types . set || baseType === types . map || baseType === types . function ) ) { return false ; } for ( let i = 1 ; i < args . length ; i ++ ) { let targetType = typeForExtend ( args [ i ] ) ; if ( targetType !== baseType ) return false ; } return true ; }
2084	function staticConfig ( projectPath , app ) { if ( ! projectPath ) throw new Error ( 'project path is required for load static configs' ) ; if ( app . staticConfigsIsLoad ) return app . config ; let projectConfigFolder = app . projectConfigFolder ; let files = [ ] ; try { files = fs . readdirSync ( projectConfigFolder ) ; } catch ( e ) { if ( e . code != 'ENOENT' ) console . error ( 'Error on load project config folder: ' , e ) ; } let file ; for ( let i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] == 'local.js' ) continue ; if ( ! files [ i ] . endsWith ( '.js' ) ) continue ; file = path . resolve ( projectConfigFolder , files [ i ] ) ; if ( fs . lstatSync ( file ) . isDirectory ( ) ) continue ; _ . merge ( app . config , require ( file ) ) ; } let jsonConfiguration = staticConfig . readJsonConfiguration ( projectConfigFolder ) ; let localConfigFile = staticConfig . readLocalConfigFile ( projectConfigFolder ) ; _ . merge ( app . config , jsonConfiguration , localConfigFile ) ; app . staticConfigsIsLoad = true ; return app . config ; }
3736	function indexOfOutside ( data , item , index , exclude ) { var result , positionResult = { start : 0 , end : index ? index - 1 : - 1 } ; do { result = data . indexOf ( item , positionResult . end + 1 ) ; } while ( result !== - 1 && ( positionResult = inPosition ( result , exclude ) ) ) ; return result ; }
407	function resolveOrReject ( data ) { if ( data . filename ) { console . warn ( data ) ; } if ( ! options . async ) { head . removeChild ( style ) ; } }
3873	function hasClass ( node , className ) { if ( node && node . el ) { return node . el . classList . contains ( className ) ; } else { return false ; } }
809	function errorInterceptor ( level , msg , meta ) { if ( meta instanceof Error ) { meta = { error : meta } ; } else if ( meta && meta . status && meta . response ) { meta = { error : meta } ; } if ( _ . isPlainObject ( meta ) ) { meta = _ . mapValues ( meta , normalizeError ) ; } return meta ; }
3625	function getLengthEncoding ( n , special ) { if ( n < 0 ) throw new Error ( 'Cannot write negative length encoding: ' + n ) ; if ( ! special ) { if ( n <= 0x3F ) { return new Buffer ( [ n ] ) ; } else if ( n <= 0x3FFF ) { return new Buffer ( [ 0x40 | ( n >> 8 ) , n & 0xFF ] ) ; } else if ( n <= 0xFFFFFFFF ) { var buffer = new Buffer ( 5 ) ; buffer . writeUInt8 ( 0x80 , 0 ) ; buffer . writeUInt32BE ( n , 1 ) ; return buffer ; } throw new Error ( 'Failed to write length encoding: ' + n ) ; } else { if ( n > 0x3F ) { throw new Error ( 'Cannot encode ' + n + ' using special length encoding' ) ; } return new Buffer ( [ 0xC0 | n ] ) ; } }
2799	function initJsonDateFormat ( bookshelfModel ) { const schema = bookshelfModel . prototype . schema const originalFunction = bookshelfModel . prototype . toJSON bookshelfModel . prototype . toJSON = function ( ) { const attrs = originalFunction . apply ( this , arguments ) _ . forEach ( attrs , function ( v , k ) { if ( v !== null && typeof schema [ k ] !== 'undefined' && schema [ k ] . _type === 'date' ) { attrs [ k ] = moment ( v ) . format ( schema [ k ] . _flags . format ) } } ) return attrs } }
3719	function mkdir ( units , name ) { if ( name !== "" ) { var parts = name . split ( "." ) ; var path = "" ; for ( var i = 0 , len = parts . length ; i < len ; i ++ ) { var part = parts [ i ] ; path += part ; if ( units [ part ] == null ) { units [ part ] = { } ; } else if ( typeof units [ part ] !== "object" ) { error ( "Cann't init unit '" + name + "' because path element '" + path + "' isn't an object" ) ; } units = units [ part ] ; path += "." ; } } return units ; }
1899	function ( name ) { if ( _ . isNumber ( name ) ) return this . list ( ) [ name ] ; if ( _ . isString ( name ) ) return _ . find ( this . list ( ) , function ( prop ) { return prop . name ( ) === name ; } ) ; return name ; }
1739	function hydrateLayerGroup ( layersDef , layerGroup ) { const hydrated_group = [ ] ; for ( let i = 0 , ii = layerGroup . length ; i < ii ; i ++ ) { hydrated_group . push ( hydrateLayer ( layersDef , layerGroup [ i ] ) ) ; } return hydrated_group ; }
3879	function match ( { just , nothing } ) { return function ( maybe ) { for ( const value of maybe ) { return just ( value ) ; } return nothing ( ) ; } ; }
3296	function ( url , params , options ) { var script = document . createElement ( 'script' ) ; script . setAttribute ( "src" , Ext . urlAppend ( url , Ext . Object . toQueryString ( params ) ) ) ; script . setAttribute ( "async" , true ) ; script . setAttribute ( "type" , "text/javascript" ) ; return script ; }
892	function flattenMixins ( mixins , target , opts ) { mixins . forEach ( item => { if ( typeof item === 'function' ) { item = item ( true , opts ) ; } if ( ! item || typeof item !== 'object' ) { return ; } let submixins = item . mixins ; if ( Array . isArray ( submixins ) && submixins . length ) { item = Object . assign ( { } , item ) ; flattenMixins ( submixins , item , opts ) ; } Object . keys ( item ) . forEach ( k => doMixin ( target , item , k , opts ) ) ; } ) ; }
625	function filterFunctionWords ( combinations , functionWords ) { combinations = filterFunctionWordsAnywhere ( combinations , functionWords . filteredAnywhere ) ; combinations = filterFunctionWordsAtBeginningAndEnding ( combinations , functionWords . filteredAtBeginningAndEnding ) ; combinations = filterFunctionWordsAtEnding ( combinations , functionWords . filteredAtEnding ) ; combinations = filterFunctionWordsAtBeginning ( combinations , functionWords . filteredAtBeginning ) ; return combinations ; }
2055	function ( name ) { var result = [ ] , _this = this ; angular . forEach ( this . retrieveEditor ( name ) . toolbars , function ( name ) { result . push ( _this . retrieveToolbar ( name ) ) ; } ) ; return result ; }
1991	function parseArgv ( argv ) { var parsed = { args : [ ] , help : false , color : null , paginate : null , outputMode : OM_LONG , jsonIndent : 2 , level : null , strict : false , pids : null , pidsType : null , timeFormat : TIME_UTC } ; var args = argv . slice ( 2 ) ; var newArgs = [ ] ; var optTakesArg = { 'd' : true , 'o' : true , 'c' : true , 'l' : true , 'p' : true } ; for ( var i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] . charAt ( 0 ) === '-' && args [ i ] . charAt ( 1 ) !== '-' && args [ i ] . length > 2 ) { var splitOpts = args [ i ] . slice ( 1 ) . split ( '' ) ; for ( var j = 0 ; j < splitOpts . length ; j ++ ) { newArgs . push ( '-' + splitOpts [ j ] ) ; if ( optTakesArg [ splitOpts [ j ] ] ) { var optArg = splitOpts . slice ( j + 1 ) . join ( '' ) ; if ( optArg . length ) { newArgs . push ( optArg ) ; } break ; } } } else { newArgs . push ( args [ i ] ) ; } } args = newArgs ; var condDefines = [ ] ; Object . keys ( upperNameFromLevel ) . forEach ( function ( lvl ) { condDefines . push ( format ( 'Object.prototype.%s = %s;' , upperNameFromLevel [ lvl ] , lvl ) ) ; } ) ; condDefines = condDefines . join ( '\n' ) + \n ; '\n' \n var endOfOptions = false ; }
2600	function descending ( a ) { if ( ! ( a instanceof Array ) ) return a ; return a . sort ( function ( a , b ) { if ( a !== undefined && a !== null ) a = a . toString ( ) ; if ( b !== undefined && b !== null ) b = b . toString ( ) ; return a > b ? - 1 : a < b ? 1 : 0 ; } ) ; }
3792	function ( type ) { var examples = this . getExamples ( type ) ; return examples [ Math . floor ( Math . random ( ) * examples . length ) ] ; }
484	function isDataDescriptor ( desc ) { return ! ! desc && desc . hasOwnProperty ( 'value' ) && isBoolean ( desc . configurable ) && isBoolean ( desc . enumerable ) && isBoolean ( desc . writable ) ; }
488	function getBoundSuper ( obj , fn ) { if ( typeof _WeakMap === 'undefined' ) { throw new Error ( 'Using @autobind on ' + fn . name + '() requires WeakMap support due to its use of super.' + fn . name + '()' ) ; } if ( ! mapStore ) { mapStore = new _WeakMap ( ) ; } if ( mapStore . has ( obj ) === false ) { mapStore . set ( obj , new _WeakMap ( ) ) ; } var superStore = mapStore . get ( obj ) ; if ( superStore . has ( fn ) === false ) { superStore . set ( fn , bind$1 ( fn , obj ) ) ; } return superStore . get ( fn ) ; }
3827	function ( action ) { var url ; var error ; var routes = this . getRoutes ( ) ; for ( var i = 0 ; url === undefined && i < routes . length ; i ++ ) { try { var route = routes [ i ] ; if ( action == route . controller + '.' + route . method ) { var params = [ ] ; if ( arguments . length > 1 ) { params = Array . prototype . slice . apply ( arguments ) ; params = params . slice ( 1 ) ; } url = this . bindUrl ( route . path , params ) ; } } catch ( e ) { error = e ; } } if ( url !== undefined ) { return url ; } else { if ( error !== undefined ) { throw error ; } else { throw new Error ( "No matching action was found." ) ; } } }
2572	function repeat ( s , times ) { times = parseInt ( times , 10 ) ; times = isNaN ( times ) || ! isFinite ( times ) || times <= 0 ? 1 : times ; var os = s ; for ( var i = 1 ; i < times ; i ++ ) s += os ; return s ; }
3046	function ( c ) { var cc = ( ( c . charCodeAt ( 0 ) & 0x0f ) << 12 ) | ( ( c . charCodeAt ( 1 ) & 0x3f ) << 6 ) | ( c . charCodeAt ( 2 ) & 0x3f ) ; return String . fromCharCode ( cc ) ; }
3831	function BasicResolverStrategy ( config ) { ResolverStrategy . call ( this , config ) ; this . config = extend ( true , this . config , { } , config ) ; }
2402	function order_stack ( stack ) { for ( var i = 0 ; i < stack . length ; i ++ ) { var handle = stack [ i ] . handle ; if ( handle . _first ) { var mid = stack . splice ( i , 1 ) [ 0 ] ; stack . unshift ( mid ) ; delete handle . _first ; handle . _moved_first = true ; return order_stack ( stack ) ; } else if ( handle . _before || handle . _after ) { var position = null ; if ( handle . _before ) { position = '_before' ; } else if ( handle . _after ) { position = '_after' ; } var label = handle [ position ] ; for ( var j = 0 ; j < stack . length ; j ++ ) { if ( stack [ j ] . handle . label === label ) { var new_index = j ; if ( position == '_after' ) new_index ++ ; stack . splice ( new_index , 0 , stack . splice ( i , 1 ) [ 0 ] ) ; handle [ '_moved' + position ] = handle [ position ] ; break ; } } delete handle [ position ] ; return order_stack ( stack ) ; } } return true ; }
1756	function ( qName , id ) { var q = queue . get ( qName ) ; return q . getJob ( id ) . then ( function ( job ) { if ( ! job ) { return job ; } return job . getState ( ) . then ( function ( state ) { job . state = state ; return job ; } ) ; } ) ; }
2869	function exportCubeMixin ( cubeDef ) { var app = this ; var task = new Task ( ) ; promise ( ) . then ( function ( ) { task . running ( 'info' , 'Starting!' ) ; } ) . then ( function ( reply ) { return app . createSessionObject ( { qHyperCubeDef : cubeDef , qInfo : { qType : 'mashup' } } ) . then ( function ( reply ) { task . running ( 'info' , 'Cube generated' ) ; return reply ; } ) } ) . then ( function ( sessionObject ) { return promise . all ( [ sessionObject , sessionObject . getLayout ( ) . then ( function ( reply ) { task . running ( 'info' , 'Got cube layout' ) ; return reply ; } ) ] ) } ) . then ( function ( [ sessionObject , cubeLayout ] ) { var columns = cubeLayout . qHyperCube . qSize . qcx ; var totalheight = cubeLayout . qHyperCube . qSize . qcy ; var pageheight = Math . floor ( 10000 / columns ) ; var numberOfPages = Math . ceil ( totalheight / pageheight ) ; var pages = Array . apply ( null , new Array ( numberOfPages ) ) . map ( function ( data , index ) { return sessionObject . getHyperCubeData ( '/qHyperCubeDef' , [ { qTop : ( pageheight * index ) , qLeft : 0 , qWidth : columns , qHeight : pageheight } ] ) . then ( ( page ) => { task . running ( 'page' , page ) ; return page ; } ) ; } , this ) ; return promise . all ( pages ) . then ( function ( pages ) { return promise . all ( [ sessionObject , cubeLayout , pages ] ) ; } ) ; } ) . then ( function ( [ sessionObject , cubeLayout , pages ] ) { pages = [ ] . concat . apply ( [ ] , pages . map ( function ( item ) { return item [ 0 ] . qMatrix ; } ) ) ; task . done ( pages ) ; return pages ; } ) . fail ( function ( err ) { task . failed ( err ) ; return promise . reject ( err ) ; } ) ; if ( returnObservable ) { return task ; } else { return task . toPromise ( extPromise ) ; } }
1383	async function parseResponse ( header , response , active = false , id ) { const rows = [ ] ; _ . each ( response , ( value , key ) => { let row = [ ] ; if ( active ) { _ . each ( response [ key ] . active , ( activeValue ) => { row = [ ] ; if ( id === undefined || activeValue . job_id === id || activeValue . ex_id === id ) { _ . each ( header , ( item ) => { if ( item === 'teraslice_version' ) { row . push ( response [ key ] . teraslice_version ) ; } else if ( item === 'node_id' ) { row . push ( response [ key ] . node_id ) ; } else if ( item === 'hostname' ) { row . push ( response [ key ] . hostname ) ; } else if ( item === 'node_version' ) { row . push ( response [ key ] . node_version ) ; } else { row . push ( activeValue [ item ] ) ; } } ) ; rows . push ( row ) ; } } ) ; } else { _ . each ( header , ( item ) => { if ( item === 'active' ) { row . push ( response [ key ] [ item ] . length ) ; } else { row . push ( response [ key ] [ item ] ) ; } } ) ; rows . push ( row ) ; } } ) ; return rows ; }
1839	function NewRelic ( license_key , options , log ) { this . url = "https://api.newrelic.com" ; this . _options = options ; this . license_key = license_key ; if ( ! this . _options . hasOwnProperty ( 'user' ) ) { this . _options [ 'user' ] = 'dreadnot' ; } this . log = log || logmagic . local ( 'sensu' ) ; }
1830	function ( ) { var buildRequest = buildJSONRequest . bind ( this ) ; if ( arguments . length == 2 ) { var cbSuccess = callbackWrap . bind ( this , arguments [ 0 ] ) ; var cbFailure = callbackWrap . bind ( this , arguments [ 1 ] ) ; cordova . exec ( cbSuccess , cbFailure , "BMSRequest" , "send" , [ buildRequest ( ) ] ) ; } else if ( arguments . length >= 3 ) { if ( typeof arguments [ 0 ] == "string" || typeof arguments [ 0 ] == "object" ) { var cbSuccess = callbackWrap . bind ( this , arguments [ 1 ] ) ; var cbFailure = callbackWrap . bind ( this , arguments [ 2 ] ) ; cordova . exec ( cbSuccess , cbFailure , "BMSRequest" , "send" , [ buildRequest ( arguments [ 0 ] ) ] ) ; } } }
2464	function ( name , obj , after ) { if ( typeof after === 'string' && ! inject ( after ) ( ) ) { caramel . once ( 'register:' + after , function ( ) { register ( name , obj ) ; } ) ; return ; } var path = name . split ( '.' ) ; var ref = container ; for ( var i = 0 ; i < path . length - 1 ; i ++ ) { if ( ! ref [ path [ i ] ] ) { ref = ref [ path [ i ] ] = { } ; } else { ref = ref [ path [ i ] ] ; } } if ( ! ref [ path [ path . length - 1 ] ] ) { ref [ path [ path . length - 1 ] ] = { cream : obj } ; } else { ref [ path [ path . length - 1 ] ] . cream = obj ; } createCream ( name , obj ) ; caramel . emit ( 'register:' + name ) ; }
2978	function siteAppsAdmin ( req , res , cb ) { var { themeData } = res . locals ; const { apps , getInheritTheme , themes } = req . app . locals ; if ( ! themeData . managingSite ) cb ( ) ; else { res . locals . addPages = function ( appPages ) { addPages ( req , res , appPages ) ; } let mgSiteApps = themeData . authSites [ themeData . managingSite ] . zsApps ; if ( mgSiteApps ) { req . app . debug ( 'Site has apps %o' , mgSiteApps ) ; _ . forEach ( mgSiteApps , function ( key ) { if ( apps [ key ] && apps [ key ] . main ) { let main = require ( ` ${ apps [ key ] . path } ${ apps [ key ] . main } ` ) ; if ( main . admin ) { main . admin ( req , res ) ; } } } ) ; } let mgSiteTheme = themeData . authSites [ themeData . managingSite ] . zsTheme ; if ( mgSiteTheme ) { let themeTree = getInheritTheme ( mgSiteTheme ) ; _ . forEach ( themeTree , function ( v , key ) { if ( themes [ key ] && themes [ key ] . main ) { let main = require ( ` ${ themes [ key ] . path } ${ themes [ key ] . main } ` ) ; if ( main . admin ) { main . admin ( req , res ) ; } } } ) ; } cb ( ) ; } }
3474	function eventHandler ( evt , args ) { var type = evt . type ; if ( self . removed ) return ; if ( self . onEvent . dispatch ( self , evt , args ) !== false ) { self [ nativeToDispatcherMap [ evt . fakeType || evt . type ] ] . dispatch ( self , evt , args ) ; } }
1951	function ( lang , data ) { if ( _ . isString ( data ) ) { data = { words : _ . compact ( data . split ( ' ' ) ) } ; } else if ( _ . isArray ( data ) ) { data = { words : data } ; } langs [ lang ] = data ; }
2304	function ( data , arr , options ) { return arr . map ( function ( lookup ) { return expander . process ( data , lookup , options ) ; } ) ; }
1685	function _destroyNode ( node ) { if ( node . _next ) { node . _next . _prev = node . _prev ; } if ( node . _prev ) { node . _prev . _next = node . _next ; } else { this . _first = node . _next ; } node . destroy ( ) ; if ( this . _pool . layoutNodes . size < MAX_POOL_SIZE ) { this . _pool . layoutNodes . size ++ ; node . _prev = undefined ; node . _next = this . _pool . layoutNodes . first ; this . _pool . layoutNodes . first = node ; } }
872	function getModuleName ( nameOrPath ) { let end = nameOrPath . indexOf ( "/" ) if ( end !== - 1 && nameOrPath [ 0 ] === "@" ) { end = nameOrPath . indexOf ( "/" , 1 + end ) } return end === - 1 ? nameOrPath : nameOrPath . slice ( 0 , end ) }
2985	function ( modelData , scContent ) { if ( scContent [ 'treeData' ] ) { let parentColumn = scContent . treeData . parentColumn ; let rootParent = ( scContent . treeData [ 'root' ] ) ? scContent . treeData [ 'root' ] : 0 ; let childColumn = scContent . idColumn ; scContent . treeData [ 'deepestLevel' ] = 0 ; let orderStart = 1 ; function sortData ( all , top , data , sort , level ) { if ( level > scContent . treeData [ 'deepestLevel' ] ) { scContent . treeData [ 'deepestLevel' ] = level ; } _ . forEach ( _ . filter ( all , [ parentColumn , top ] ) , function ( val ) { val = val . toJSON ( ) ; val [ 'treeDisplayOrder' ] = sort ; val [ 'treeLevel' ] = level ; data . push ( val ) ; if ( _ . find ( all , [ parentColumn , val [ childColumn ] ] ) ) { data = sortData ( all , val [ childColumn ] , data , orderStart , ( level + 1 ) ) ; } sort ++ ; } ) ; return data ; } return sortData ( modelData , rootParent , [ ] , orderStart , 0 ) ; } else { var data = [ ] ; _ . forEach ( modelData , function ( val ) { data . push ( val . toJSON ( ) ) ; } ) ; return data ; } }
614	function getWordCombinations ( text , combinationSize , functionWords ) { const sentences = getSentences ( text ) ; let words , combination ; return flatMap ( sentences , function ( sentence ) { sentence = sentence . toLocaleLowerCase ( ) ; sentence = normalizeQuotes ( sentence ) ; words = getWords ( sentence ) ; return filter ( map ( words , function ( word , i ) { if ( i + combinationSize - 1 < words . length ) { combination = words . slice ( i , i + combinationSize ) ; return new WordCombination ( combination , 0 , functionWords ) ; } return false ; } ) ) ; } ) ; }
754	function ( event , g , context ) { if ( event . button && event . button == 2 ) return ; context . initializeMouseDown ( event , g , context ) ; if ( event . altKey || event . shiftKey ) { DygraphInteraction . startPan ( event , g , context ) ; } else { DygraphInteraction . startZoom ( event , g , context ) ; } var mousemove = function ( event ) { if ( context . isZooming ) { var d = distanceFromChart ( event , g ) ; if ( d < DRAG_EDGE_MARGIN ) { DygraphInteraction . moveZoom ( event , g , context ) ; } else { if ( context . dragEndX !== null ) { context . dragEndX = null ; context . dragEndY = null ; g . clearZoomRect_ ( ) ; } } } else if ( context . isPanning ) { DygraphInteraction . movePan ( event , g , context ) ; } } ; var mouseup = function ( event ) { if ( context . isZooming ) { if ( context . dragEndX !== null ) { DygraphInteraction . endZoom ( event , g , context ) ; } else { DygraphInteraction . maybeTreatMouseOpAsClick ( event , g , context ) ; } } else if ( context . isPanning ) { DygraphInteraction . endPan ( event , g , context ) ; } utils . removeEvent ( document , 'mousemove' , mousemove ) ; utils . removeEvent ( document , 'mouseup' , mouseup ) ; context . destroy ( ) ; } ; g . addAndTrackEvent ( document , 'mousemove' , mousemove ) ; g . addAndTrackEvent ( document , 'mouseup' , mouseup ) ; }
3226	function ( redraw ) { var i = 0 , items = this . items , len = this . length ; for ( ; i < len ; i ++ ) { items [ i ] . hide ( redraw ) ; } return this ; }
954	function hasBabelDepPlugin ( plugins ) { return plugins . some ( item => { let pluginItem = item ; if ( Array . isArray ( item ) ) { pluginItem = item [ 0 ] ; } if ( typeof pluginItem === 'string' ) { return pluginItem === DEP_PLUGIN_NAME ; } return pluginItem === programPlugins . resolveDep ; } ) ; }
227	function recordOrderInFloodlight ( cart , orderId , wpcomJetpackCartInfo ) { if ( ! isAdTrackingAllowed ( ) || ! isFloodlightEnabled ) { return ; } debug ( 'recordOrderInFloodlight: record purchase' ) ; debug ( 'recordOrderInFloodlight:' ) ; recordParamsInFloodlightGtag ( { value : cart . total_cost , transaction_id : orderId , u1 : cart . total_cost , u2 : cart . products . map ( product => product . product_name ) . join ( ', ' ) , u3 : cart . currency , send_to : 'DC-6355556/wpsal0/wpsale+transactions' , } ) ; if ( wpcomJetpackCartInfo . containsWpcomProducts ) { debug ( 'recordOrderInFloodlight: WPCom' ) ; recordParamsInFloodlightGtag ( { value : wpcomJetpackCartInfo . wpcomCost , transaction_id : orderId , u1 : wpcomJetpackCartInfo . wpcomCost , u2 : wpcomJetpackCartInfo . wpcomProducts . map ( product => product . product_name ) . join ( ', ' ) , u3 : cart . currency , send_to : 'DC-6355556/wpsal0/purch0+transactions' , } ) ; } if ( wpcomJetpackCartInfo . containsJetpackProducts ) { debug ( 'recordOrderInFloodlight: Jetpack' ) ; recordParamsInFloodlightGtag ( { value : wpcomJetpackCartInfo . jetpackCost , transaction_id : orderId , u1 : wpcomJetpackCartInfo . jetpackCost , u2 : wpcomJetpackCartInfo . jetpackProducts . map ( product => product . product_name ) . join ( ', ' ) , u3 : cart . currency , send_to : 'DC-6355556/wpsal0/purch00+transactions' , } ) ; } }
536	async function downloadLibtensorflow ( callback ) { await ensureDir ( depsPath ) ; console . warn ( '* Downloading libtensorflow' ) ; resources . downloadAndUnpackResource ( getPlatformLibtensorflowUri ( ) , depsPath , async ( ) => { if ( platform === 'win32' ) { const depsIncludePath = path . join ( depsPath , 'include' ) ; if ( ! await exists ( depsLibTensorFlowPath ) ) { const libtensorflowDll = path . join ( depsPath , 'tensorflow.dll' ) ; if ( ! await exists ( libtensorflowDll ) ) { throw new Error ( 'Could not find libtensorflow.dll' ) ; } await ensureDir ( depsLibPath ) ; await rename ( libtensorflowDll , depsLibTensorFlowPath ) ; } if ( ! await exists ( depsIncludePath ) ) { await unlink ( path . join ( depsPath , 'c_api.h' ) ) ; await unlink ( path . join ( depsPath , 'LICENSE' ) ) ; resources . downloadAndUnpackResource ( TF_WIN_HEADERS_URI , depsPath , ( ) => { if ( callback !== undefined ) { callback ( ) ; } } ) ; } else { if ( callback !== undefined ) { callback ( ) ; } } } else { if ( callback !== undefined ) { callback ( ) ; } } } ) ; }
1691	function _getRoundedValue3D ( prop , def , precision , lockValue ) { if ( ! prop || ! prop . init ) { return def ; } return [ prop . enabled [ 0 ] ? ( Math . round ( ( prop . curState . x + ( ( prop . endState . x - prop . curState . x ) * lockValue ) ) / precision ) * precision ) : prop . endState . x , prop . enabled [ 1 ] ? ( Math . round ( ( prop . curState . y + ( ( prop . endState . y - prop . curState . y ) * lockValue ) ) / precision ) * precision ) : prop . endState . y , prop . enabled [ 2 ] ? ( Math . round ( ( prop . curState . z + ( ( prop . endState . z - prop . curState . z ) * lockValue ) ) / precision ) * precision ) : prop . endState . z ] ; }
1771	function debuggerHelper ( left , right ) { if ( process . env . NODE_ENV !== 'production' ) { var shouldBreak = evaluateArgs . apply ( null , Array . prototype . slice . call ( arguments , 0 , - 1 ) ) ; if ( ! shouldBreak ) { return ; } var options = arguments [ arguments . length - 1 ] , scope = options && options . scope ; var get = function ( path ) { return scope . get ( path ) ; } ; debuggerHelper . _lastGet = get ; canLog . log ( 'Use `get(<path>)` to debug this template' ) ; var allowDebugger = __testing . allowDebugger ; if ( allowDebugger ) { debugger ; return ; } } canLog . warn ( 'Forgotten {{debugger}} helper' ) ; }
3275	async function createVinylFile ( filePath , options ) { options . lookup . set ( filePath , vinylFile . read ( filePath , options ) ) ; if ( options . debugVcjd ) debug ( ` ${ filePath } ` ) ; return await options . lookup . get ( filePath ) ; }
2564	function getThisValueAndInvoke ( callback ) { return callback ( currentThis !== undefined && currentThis !== null ? ( typeof currentThis === 'object' ? currentThis : currentThis . valueOf ( ) ) : currentThis ) ; }
3096	function ( parent , records , suppressEvent ) { var me = this , insertIndex = me . indexOf ( parent ) + 1 , toAdd = [ ] ; if ( ! suppressEvent ) { me . fireEvent ( 'beforeexpand' , parent , records , insertIndex ) ; } me . handleNodeExpand ( parent , records , toAdd ) ; me . insert ( insertIndex , toAdd ) ; if ( ! suppressEvent ) { me . fireEvent ( 'expand' , parent , records ) ; } }
535	async function cleanDeps ( ) { if ( await exists ( depsPath ) ) { await rimrafPromise ( depsPath ) ; } await mkdir ( depsPath ) ; }
1169	function ( vertex ) { this . model . set ( 'attrs' , this . model . get ( 'attrs' ) || { } ) ; var attrs = this . model . get ( 'attrs' ) ; var vertices = ( this . model . get ( 'vertices' ) || [ ] ) . slice ( ) ; var originalVertices = vertices . slice ( ) ; var path = this . _V . connection . node . cloneNode ( false ) ; var originalPathLength = path . getTotalLength ( ) ; var pathLength ; var pathLengthTolerance = 20 ; var idx = vertices . length + 1 ; while ( idx -- ) { vertices . splice ( idx , 0 , vertex ) ; V ( path ) . attr ( 'd' , this . getPathData ( vertices ) ) ; pathLength = path . getTotalLength ( ) ; if ( pathLength - originalPathLength > pathLengthTolerance ) { vertices = originalVertices . slice ( ) ; } else { break ; } } this . model . set ( 'vertices' , vertices ) ; return Math . max ( idx , 0 ) ; }
819	function do_script ( chain_opts , script_obj , chain_group , preload_this_script ) { var registry_item , registry_items , ready_cb = function ( ) { script_obj . ready_cb ( script_obj , function ( ) { execute_preloaded_script ( chain_opts , script_obj , registry_item ) ; } ) ; } , finished_cb = function ( ) { script_obj . finished_cb ( script_obj , chain_group ) ; } ; script_obj . src = canonical_uri ( script_obj . src , chain_opts [ _BasePath ] ) ; script_obj . real_src = script_obj . src + ( chain_opts [ _CacheBust ] ? ( ( / \?.*$ / . test ( script_obj . src ) ? "&_" : "?_" ) + ~ ~ ( Math . random ( ) * 1E9 ) + "=" ) : "" ) ; if ( ! registry [ script_obj . src ] ) registry [ script_obj . src ] = { items : [ ] , finished : false } ; registry_items = registry [ script_obj . src ] . items ; if ( chain_opts [ _AllowDuplicates ] || registry_items . length == 0 ) { registry_item = registry_items [ registry_items . length ] = { ready : false , finished : false , ready_listeners : [ ready_cb ] , finished_listeners : [ finished_cb ] } ; request_script ( chain_opts , script_obj , registry_item , ( ( preload_this_script ) ? function ( ) { registry_item . ready = true ; for ( var i = 0 ; i < registry_item . ready_listeners . length ; i ++ ) { registry_item . ready_listeners [ i ] ( ) ; } registry_item . ready_listeners = [ ] ; } : function ( ) { script_executed ( registry_item ) ; } ) , preload_this_script ) ; } else { registry_item = registry_items [ 0 ] ; if ( registry_item . finished ) { finished_cb ( ) ; } else { registry_item . finished_listeners . push ( finished_cb ) ; } } }
1106	function ( el ) { var genericCloseButton ; if ( $ ( el ) . data ( 'popupoptions' ) . closebuttonmarkup ) { genericCloseButton = $ ( options . closebuttonmarkup ) . addClass ( el . id + '_close' ) ; } else { genericCloseButton = '<button class="popup_close ' + el . id + '_close" title="Close" aria-label="Close"><span aria-hidden="true">×</span></button>'; ; } }
658	function ( word , locale ) { var numberOfSyllables = 0 ; var vowelRegex = new RegExp ( "[^" + syllableMatchers ( locale ) . vowels + "]" , "ig" ) ; var foundVowels = word . split ( vowelRegex ) ; var filteredWords = filter ( foundVowels , function ( vowel ) { return vowel !== "" ; } ) ; numberOfSyllables += filteredWords . length ; return numberOfSyllables ; }
3008	function ( key , done ) { var val = null ; if ( cache . hasOwnProperty ( key ) ) { val = cache [ key ] ; } return done ( null , val ) ; }
1135	function jscoverage_recalculateSourceTab ( ) { if ( ! jscoverage_currentFile ) { jscoverage_endLengthyOperation ( ) ; return ; } var progressLabel = document . getElementById ( 'progressLabel' ) ; progressLabel . innerHTML = 'Calculating coverage ...' ; var progressBar = document . getElementById ( 'progressBar' ) ; ProgressBar . setPercentage ( progressBar , 20 ) ; setTimeout ( jscoverage_makeTable , 0 ) ; }
