0	function createInstance ( defaultConfig ) { var context = new Axios ( defaultConfig ) ; var instance = bind ( Axios . prototype . request , context ) ; utils . extend ( instance , Axios . prototype , context ) ; utils . extend ( instance , context ) ; return instance ; }
1	function CancelToken ( executor ) { if ( typeof executor !== 'function' ) { throw new TypeError ( 'executor must be a function.' ) ; } var resolvePromise ; this . promise = new Promise ( function promiseExecutor ( resolve ) { resolvePromise = resolve ; } ) ; var token = this ; executor ( function cancel ( message ) { if ( token . reason ) { return ; } token . reason = new Cancel ( message ) ; resolvePromise ( token . reason ) ; } ) ; }
2	function isArrayBufferView ( val ) { var result ; if ( ( typeof ArrayBuffer !== 'undefined' ) && ( ArrayBuffer . isView ) ) { result = ArrayBuffer . isView ( val ) ; } else { result = ( val ) && ( val . buffer ) && ( val . buffer instanceof ArrayBuffer ) ; } return result ; }
3	function isStandardBrowserEnv ( ) { if ( typeof navigator !== 'undefined' && ( navigator . product === 'ReactNative' || navigator . product === 'NativeScript' || navigator . product === 'NS' ) ) { return false ; } return ( typeof window !== 'undefined' && typeof document !== 'undefined' ) ; }
4	function forEach ( obj , fn ) { if ( obj === null || typeof obj === 'undefined' ) { return ; } if ( typeof obj !== 'object' ) { obj = [ obj ] ; } if ( isArray ( obj ) ) { for ( var i = 0 , l = obj . length ; i < l ; i ++ ) { fn . call ( null , obj [ i ] , i , obj ) ; } } else { for ( var key in obj ) { if ( Object . prototype . hasOwnProperty . call ( obj , key ) ) { fn . call ( null , obj [ key ] , key , obj ) ; } } } }
5	function extend ( a , b , thisArg ) { forEach ( b , function assignValue ( val , key ) { if ( thisArg && typeof val === 'function' ) { a [ key ] = bind ( val , thisArg ) ; } else { a [ key ] = val ; } } ) ; return a ; }
6	function writePackageManifest ( packageName ) { const packagePath = require . resolve ( packageName + '/package.json' ) let { name , main , author , license , types , typings } = require ( packagePath ) if ( ! main ) { main = 'index.js' } let typesFile = types || typings if ( typesFile ) { typesFile = require . resolve ( join ( packageName , typesFile ) ) } const compiledPackagePath = join ( __dirname , ` ${ packageName } ` ) const potentialLicensePath = join ( dirname ( packagePath ) , './LICENSE' ) if ( existsSync ( potentialLicensePath ) ) { this . _ . files . push ( { dir : compiledPackagePath , base : 'LICENSE' , data : readFileSync ( potentialLicensePath , 'utf8' ) } ) } this . _ . files . push ( { dir : compiledPackagePath , base : 'package.json' , data : JSON . stringify ( Object . assign ( { } , { name , main : ` ${ basename ( main , '.' + extname ( main ) ) } ` } , author ? { author } : undefined , license ? { license } : undefined , typesFile ? { types : relative ( compiledPackagePath , typesFile ) } : undefined ) ) + '\n' } ) }
7	function processMessage ( e ) { const obj = JSON . parse ( e . data ) switch ( obj . action ) { case 'building' : { console . log ( '[HMR] bundle ' + ( obj . name ? "'" + obj . name + "' " : '' ) + 'rebuilding' ) break } case 'built' : case 'sync' : { clearOutdatedErrors ( ) if ( obj . hash ) { handleAvailableHash ( obj . hash ) } if ( obj . warnings . length > 0 ) { handleWarnings ( obj . warnings ) } if ( obj . errors . length > 0 ) { if ( obj . action === 'sync' ) { hadRuntimeError = true } handleErrors ( obj . errors ) break } handleSuccess ( ) break } default : { if ( customHmrEventHandler ) { customHmrEventHandler ( obj ) break } break } } }
8	async function tryApplyUpdates ( onHotUpdateSuccess ) { if ( ! module . hot ) { console . error ( 'HotModuleReplacementPlugin is not in Webpack configuration.' ) return } if ( ! isUpdateAvailable ( ) || ! canApplyUpdates ( ) ) { return } function handleApplyUpdates ( err , updatedModules ) { if ( err || hadRuntimeError ) { if ( err ) { console . warn ( 'Error while applying updates, reloading page' , err ) } if ( hadRuntimeError ) { console . warn ( 'Had runtime error previously, reloading page' ) } window . location . reload ( ) return } if ( typeof onHotUpdateSuccess === 'function' ) { onHotUpdateSuccess ( ) } if ( isUpdateAvailable ( ) ) { tryApplyUpdates ( ) } } try { const updatedModules = await module . hot . check ( { ignoreUnaccepted : true } ) if ( updatedModules ) { handleApplyUpdates ( null , updatedModules ) } } catch ( err ) { handleApplyUpdates ( err , null ) } }
9	async function tryApplyUpdates ( ) { if ( ! isUpdateAvailable ( ) || ! canApplyUpdates ( ) ) { return } try { const res = await fetch ( ` ${ hotUpdatePath } ${ curHash } ` ) const data = await res . json ( ) const curPage = page === '/' ? 'index' : page const pageUpdated = Object . keys ( data . c ) . some ( mod => { return ( mod . indexOf ( ` ${ curPage . substr ( 0 , 1 ) === '/' ? curPage : ` ${ curPage } ` } ` ) !== - 1 || mod . indexOf ( ` ${ curPage . substr ( 0 , 1 ) === '/' ? curPage : ` ${ curPage } ` } ` . replace ( / \/ / g , '\\' ) ) !== \\ ) } ) - 1 } if ( pageUpdated ) { document . location . reload ( true ) } else { curHash = mostRecentHash } }
10	function formatMessage ( message , isError ) { let lines = message . split ( '\n' ) \n lines = lines . filter ( line => ! / Module [A-z ]+\(from / . test ( line ) ) lines = lines . map ( line => { const parsingError = / Line (\d+):(?:(\d+):)?\s*Parsing error: (.+)$ / . exec ( line ) if ( ! parsingError ) { return line } const [ , errorLine , errorColumn , errorMessage ] = parsingError return ` ${ friendlySyntaxErrorLabel } ${ errorMessage } ${ errorLine } ${ errorColumn } ` } ) message = lines . join ( '\n' ) \n message = message . replace ( / SyntaxError\s+\((\d+):(\d+)\)\s*(.+?)\n / g , ` ${ friendlySyntaxErrorLabel } \n ` ) message = message . replace ( / Line (\d+):\d+: / g , 'Line $1:' ) message = message . replace ( / ^.*export '(.+?)' was not found in '(.+?)'.*$ / gm , ` ` ) message = message . replace ( / ^.*export 'default' \(imported as '(.+?)'\) was not found in '(.+?)'.*$ / gm , ` ` ) message = message . replace ( / ^.*export '(.+?)' \(imported as '(.+?)'\) was not found in '(.+?)'.*$ / gm , ` ` ) lines = message . split ( '\n' ) \n if ( lines . length > 2 && lines [ 1 ] . trim ( ) === '' ) { lines . splice ( 1 , 1 ) } lines [ 0 ] = lines [ 0 ] . replace ( / ^(.*) \d+:\d+-\d+$ / , '$1' ) if ( lines [ 1 ] && lines [ 1 ] . indexOf ( 'Module not found: ' ) === 0 ) { lines = [ lines [ 0 ] , lines [ 1 ] . replace ( 'Error: ' , '' ) . replace ( 'Module not found: Cannot find file:' , 'Cannot find file:' ) ] } message = lines . join ( '\n' ) \n message = message . replace ( / ^\s*at\s((?!webpack:).)*:\d+:\d+[\s)]*(\n|$) / gm , '' ) message = message . replace ( / ^\s*at\s<anonymous>(\n|$) / gm , '' ) }
11	function UDecimalPad ( num , precision ) { var value = UDecimalString ( num ) ; assert . equal ( "number" , typeof precision === 'undefined' ? 'undefined' : ( 0 , _typeof3 . default ) ( precision ) , "precision" ) ; var part = value . split ( "." ) ; if ( precision === 0 && part . length === 1 ) { return part [ 0 ] ; } if ( part . length === 1 ) { return part [ 0 ] + '.' + "0" . repeat ( precision ) ; } else { var pad = precision - part [ 1 ] . length ; assert ( pad >= 0 , 'decimal \'' + \' + value + '\' exceeds precision ' ) ; \' } }
12	function parseSegment ( buffer , offset ) { let typeKey = buffer [ offset ] ; if ( typeKey <= 20 ) { if ( buffer [ offset + 1 ] == undefined ) throw new Error ( "ParseError: No value for uint8" ) ; return { typeKey : typeKey , value : buffer [ offset + 1 ] , bufferLength : 2 } ; } if ( typeKey <= 40 ) { if ( buffer [ offset + 2 ] == undefined ) throw new Error ( "ParseError: Incomplete value for uint16" ) ; return { typeKey : typeKey , value : buffer . readUInt16BE ( offset + 1 ) , bufferLength : 3 } ; } else if ( typeKey <= 90 ) { if ( buffer [ offset + 4 ] == undefined ) throw new Error ( "ParseError: Incomplete value for uint32" ) ; return { typeKey : typeKey , value : buffer . readUInt32BE ( offset + 1 ) , bufferLength : 5 } ; } else if ( typeKey <= 155 ) { if ( buffer [ offset + 1 ] == undefined ) throw new Error ( "ParseError: Incomplete length value for string" ) ; let len = buffer . readUInt8 ( offset + 1 ) ; if ( buffer [ offset + 1 + len ] == undefined ) throw new Error ( "ParseError: Incomplete value for string" ) ; let value = buffer . toString ( "utf8" , offset + 2 , offset + 2 + len ) ; return { typeKey : typeKey , value : value , bufferLength : 2 + len } ; } else if ( typeKey <= 165 ) { if ( buffer [ offset + 16 ] == undefined ) throw new Error ( "ParseError: Incomplete value for uuid" ) ; let len = 16 ; let value = new Buffer ( len ) ; buffer . copy ( value , 0 , offset + 1 , offset + 1 + len ) ; return { typeKey : typeKey , value : value , bufferLength : 1 + len } ; } else if ( typeKey <= 180 ) { if ( buffer [ offset + 1 ] == undefined ) throw new Error ( "ParseError: Incomplete length value for byte string" ) ; let len = buffer . readUInt8 ( offset + 1 ) ; if ( buffer [ offset + len + 1 ] == undefined ) throw new Error ( "ParseError: Incomplete value for byte string" ) ; let value = new Buffer ( len ) ; buffer . copy ( value , 0 , offset + 2 , offset + 2 + len ) ; return { typeKey : typeKey , value : value , bufferLength : 2 + len } ; } else { throw new Error ( "typeKey not supported" ) ; } }
13	function parseSegments ( buffer ) { if ( buffer . length == 0 ) throw new Error ( "bad segments stream" ) ; let pointer = 0 ; let segments = [ ] ; while ( pointer < buffer . length ) { let seg = parseSegment ( buffer , pointer ) ; segments . push ( seg ) ; pointer += seg . bufferLength ; delete seg . bufferLength ; } if ( pointer != buffer . length ) { throw new Error ( "Bad / incomplete segments" ) ; } return segments ; }
14	function parseQRCode ( text , options ) { if ( text . length < 3 || text . length > 2000 ) throw new Error ( "Invalid length of EvtLink" ) ; let textSplited = text . split ( "_" ) ; if ( textSplited . length > 2 ) return null ; let rawText ; if ( textSplited [ 0 ] . startsWith ( qrPrefix ) ) { rawText = textSplited [ 0 ] . substr ( qrPrefix . length ) ; } else { rawText = textSplited [ 0 ] ; } let segmentsBytes = EvtLink . dec2b ( rawText ) ; if ( segmentsBytes . length < 2 ) throw new Error ( "no flag in segment" ) ; let flag = segmentsBytes . readInt16BE ( 0 ) ; if ( ( flag & 1 ) == 0 ) { throw new Error ( "The EvtLink is invalid or its version is newer than version 1 and is not supported by evtjs yet" ) ; } let segmentsBytesRaw = new Buffer ( segmentsBytes . length - 2 ) ; segmentsBytes . copy ( segmentsBytesRaw , 0 , 2 , segmentsBytes . length ) ; let publicKeys = [ ] ; let signatures = [ ] ; if ( textSplited [ 1 ] ) { let buf = EvtLink . dec2b ( textSplited [ 1 ] ) ; let i = 0 ; if ( buf . length % 65 !== 0 ) { throw new Error ( "length of signature is invalid" ) ; } while ( i * 65 < buf . length ) { let current = new Buffer ( 65 ) ; buf . copy ( current , 0 , i * 65 , i * 65 + 65 ) ; let signature = ecc . Signature . fromBuffer ( current ) ; signatures . push ( signature . toString ( ) ) ; if ( ! options || options . recoverPublicKeys ) { publicKeys . push ( signature . recover ( segmentsBytes ) . toString ( ) ) ; } ++ i ; } } return { flag , segments : parseSegments ( segmentsBytesRaw ) , publicKeys , signatures } ; }
15	async function __calcKeyProvider ( keyProvider ) { if ( ! keyProvider ) { return [ ] ; } if ( keyProvider . apply && keyProvider . call ) { keyProvider = keyProvider ( ) ; } keyProvider = await Promise . resolve ( keyProvider ) ; if ( ! Array . isArray ( keyProvider ) ) { keyProvider = [ keyProvider ] ; } for ( let key of keyProvider ) { if ( ! EvtKey . isValidPrivateKey ( key ) ) { throw new Error ( "Invalid private key" ) ; } } return keyProvider ; }
16	function random32ByteBuffer ( { cpuEntropyBits = 0 , safe = true } = { } ) { assert . equal ( typeof cpuEntropyBits , "number" , "cpuEntropyBits" ) ; assert . equal ( typeof safe , "boolean" , "boolean" ) ; if ( safe ) { assert ( entropyCount >= 128 , "Call initialize() to add entropy (current: " + entropyCount + ")" ) ; } const hash_array = [ ] ; hash_array . push ( randomBytes ( 32 ) ) ; hash_array . push ( Buffer . from ( cpuEntropy ( cpuEntropyBits ) ) ) ; hash_array . push ( externalEntropyArray ) ; hash_array . push ( browserEntropy ( ) ) ; return hash . sha256 ( Buffer . concat ( hash_array ) ) ; }
17	function addEntropy ( ... ints ) { assert . equal ( externalEntropyArray . length , 101 , "externalEntropyArray" ) ; entropyCount += ints . length ; for ( const i of ints ) { const pos = entropyPos ++ % 101 ; const i2 = externalEntropyArray [ pos ] += i ; if ( i2 > 9007199254740991 ) externalEntropyArray [ pos ] = 0 ; } }
18	function cpuEntropy ( cpuEntropyBits = 128 ) { let collected = [ ] ; let lastCount = null ; let lowEntropySamples = 0 ; while ( collected . length < cpuEntropyBits ) { const count = floatingPointCount ( ) ; if ( lastCount != null ) { const delta = count - lastCount ; if ( Math . abs ( delta ) < 1 ) { lowEntropySamples ++ ; continue ; } const bits = Math . floor ( log2 ( Math . abs ( delta ) ) + 1 ) ; if ( bits < 4 ) { if ( bits < 2 ) { lowEntropySamples ++ ; } continue ; } collected . push ( delta ) ; } lastCount = count ; } if ( lowEntropySamples > 10 ) { const pct = Number ( lowEntropySamples / cpuEntropyBits * 100 ) . toFixed ( 2 ) ; console . warn ( ` ${ pct } ` ) ; } return collected ; }
19	function cryptoJsDecrypt ( message , key , iv ) { assert ( message , "Missing cipher text" ) ; message = toBinaryBuffer ( message ) ; const decipher = crypto . createDecipheriv ( "aes-256-cbc" , key , iv ) ; message = Buffer . concat ( [ decipher . update ( message ) , decipher . final ( ) ] ) ; return message ; }
20	function initialize ( ) { if ( initialized ) { return ; } unitTest ( ) ; keyUtils . addEntropy ( ... keyUtils . cpuEntropy ( ) ) ; assert ( keyUtils . entropyCount ( ) >= 128 , "insufficient entropy" ) ; initialized = true ; }
21	function montConvert ( x ) { var r = new BigInteger ( ) x . abs ( ) . dlShiftTo ( this . m . t , r ) r . divRemTo ( this . m , null , r ) if ( x . s < 0 && r . compareTo ( BigInteger . ZERO ) > 0 ) this . m . subTo ( r , r ) return r }
22	function verify ( data , pubkey , encoding = "utf8" ) { if ( typeof data === "string" ) { data = Buffer . from ( data , encoding ) ; } assert ( Buffer . isBuffer ( data ) , "data is a required String or Buffer" ) ; data = hash . sha256 ( data ) ; return verifyHash ( data , pubkey ) ; }
23	function recover ( data , encoding = "utf8" ) { if ( typeof data === "string" ) { data = Buffer . from ( data , encoding ) ; } assert ( Buffer . isBuffer ( data ) , "data is a required String or Buffer" ) ; data = hash . sha256 ( data ) ; return recoverHash ( data ) ; }
24	function invokeWith ( msg ) { print ( 'Finding comments in ' + msg . getRequestHeader ( ) . getURI ( ) . toString ( ) ) ; var body = msg . getResponseBody ( ) . toString ( ) if ( body . indexOf ( '<!--' ) > 0 ) { var o = body . indexOf ( '<!--' ) ; while ( o > 0 ) { var e = body . indexOf ( ' , o ) ; print ( "\t" + \t ) body . substr ( o , e - o + 3 ) } } }
25	function FormGroup ( props ) { const { children , className , grouped , inline , unstackable , widths } = props const classes = cx ( useKeyOnly ( grouped , 'grouped' ) , useKeyOnly ( inline , 'inline' ) , useKeyOnly ( unstackable , 'unstackable' ) , useWidthProp ( widths , null , true ) , 'fields' , className , ) const rest = getUnhandledProps ( FormGroup , props ) const ElementType = getElementType ( FormGroup , props ) return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) }
26	function Loader ( props ) { const { active , children , className , content , disabled , indeterminate , inline , inverted , size , } = props const classes = cx ( 'ui' , size , useKeyOnly ( active , 'active' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( indeterminate , 'indeterminate' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( children || content , 'text' ) , useKeyOrValueAndKey ( inline , 'inline' ) , 'loader' , className , ) const rest = getUnhandledProps ( Loader , props ) const ElementType = getElementType ( Loader , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
27	function ItemContent ( props ) { const { children , className , content , description , extra , header , meta , verticalAlign } = props const classes = cx ( useVerticalAlignProp ( verticalAlign ) , 'content' , className ) const rest = getUnhandledProps ( ItemContent , props ) const ElementType = getElementType ( ItemContent , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { ItemHeader . create ( header , { autoGenerateKey : false } ) } { ItemMeta . create ( meta , { autoGenerateKey : false } ) } { ItemDescription . create ( description , { autoGenerateKey : false } ) } { ItemExtra . create ( extra , { autoGenerateKey : false } ) } { content } < / ElementType > ) }
28	function Table ( props ) { const { attached , basic , celled , children , className , collapsing , color , columns , compact , definition , fixed , footerRow , headerRow , headerRows , inverted , padded , renderBodyRow , selectable , singleLine , size , sortable , stackable , striped , structured , tableData , textAlign , unstackable , verticalAlign , } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( celled , 'celled' ) , useKeyOnly ( collapsing , 'collapsing' ) , useKeyOnly ( definition , 'definition' ) , useKeyOnly ( fixed , 'fixed' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( selectable , 'selectable' ) , useKeyOnly ( singleLine , 'single line' ) , useKeyOnly ( sortable , 'sortable' ) , useKeyOnly ( stackable , 'stackable' ) , useKeyOnly ( striped , 'striped' ) , useKeyOnly ( structured , 'structured' ) , useKeyOnly ( unstackable , 'unstackable' ) , useKeyOrValueAndKey ( attached , 'attached' ) , useKeyOrValueAndKey ( basic , 'basic' ) , useKeyOrValueAndKey ( compact , 'compact' ) , useKeyOrValueAndKey ( padded , 'padded' ) , useTextAlignProp ( textAlign ) , useVerticalAlignProp ( verticalAlign ) , useWidthProp ( columns , 'column' ) , 'table' , className , ) const rest = getUnhandledProps ( Table , props ) const ElementType = getElementType ( Table , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } const hasHeaderRows = headerRow || headerRows const headerShorthandOptions = { defaultProps : { cellAs : 'th' } } const headerElement = hasHeaderRows && ( < TableHeader > { TableRow . create ( headerRow , headerShorthandOptions ) } { _ . map ( headerRows , ( data ) => TableRow . create ( data , headerShorthandOptions ) ) } < / TableHeader > ) return ( < ElementType { ... rest } className = { classes } > { headerElement } < TableBody > { renderBodyRow && _ . map ( tableData , ( data , index ) => TableRow . create ( renderBodyRow ( data , index ) ) ) } < / TableBody > { footerRow && < TableFooter > { TableRow . create ( footerRow ) } < / TableFooter > } < / ElementType > ) }
29	function Rail ( props ) { const { attached , children , className , close , content , dividing , internal , position , size , } = props const classes = cx ( 'ui' , position , size , useKeyOnly ( attached , 'attached' ) , useKeyOnly ( dividing , 'dividing' ) , useKeyOnly ( internal , 'internal' ) , useKeyOrValueAndKey ( close , 'close' ) , 'rail' , className , ) const rest = getUnhandledProps ( Rail , props ) const ElementType = getElementType ( Rail , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
30	function ButtonGroup ( props ) { const { attached , basic , buttons , children , className , color , compact , content , floated , fluid , icon , inverted , labeled , negative , positive , primary , secondary , size , toggle , vertical , widths , } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( basic , 'basic' ) , useKeyOnly ( compact , 'compact' ) , useKeyOnly ( fluid , 'fluid' ) , useKeyOnly ( icon , 'icon' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( labeled , 'labeled' ) , useKeyOnly ( negative , 'negative' ) , useKeyOnly ( positive , 'positive' ) , useKeyOnly ( primary , 'primary' ) , useKeyOnly ( secondary , 'secondary' ) , useKeyOnly ( toggle , 'toggle' ) , useKeyOnly ( vertical , 'vertical' ) , useKeyOrValueAndKey ( attached , 'attached' ) , useValueAndKey ( floated , 'floated' ) , useWidthProp ( widths ) , 'buttons' , className , ) const rest = getUnhandledProps ( ButtonGroup , props ) const ElementType = getElementType ( ButtonGroup , props ) if ( _ . isNil ( buttons ) ) { return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { _ . map ( buttons , button => Button . create ( button ) ) } < / ElementType > ) }
31	function GridRow ( props ) { const { centered , children , className , color , columns , divided , only , reversed , stretched , textAlign , verticalAlign , } = props const classes = cx ( color , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( divided , 'divided' ) , useKeyOnly ( stretched , 'stretched' ) , useMultipleProp ( only , 'only' ) , useMultipleProp ( reversed , 'reversed' ) , useTextAlignProp ( textAlign ) , useVerticalAlignProp ( verticalAlign ) , useWidthProp ( columns , 'column' , true ) , 'row' , className , ) const rest = getUnhandledProps ( GridRow , props ) const ElementType = getElementType ( GridRow , props ) return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) }
32	function FormField ( props ) { const { children , className , content , control , disabled , error , inline , label , required , type , width , } = props const classes = cx ( useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( error , 'error' ) , useKeyOnly ( inline , 'inline' ) , useKeyOnly ( required , 'required' ) , useWidthProp ( width , 'wide' ) , 'field' , className , ) const rest = getUnhandledProps ( FormField , props ) const ElementType = getElementType ( FormField , props ) if ( _ . isNil ( control ) ) { if ( _ . isNil ( label ) ) { return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { createHTMLLabel ( label , { autoGenerateKey : false } ) } < / ElementType > ) } const controlProps = { ... rest , content , children , disabled , required , type } if ( control === 'input' && ( type === 'checkbox' || type === 'radio' ) ) { return ( < ElementType className = { classes } > < label > { createElement ( control , controlProps ) } { label } < / label > < / ElementType > ) } if ( control === Checkbox || control === Radio ) { return ( < ElementType className = { classes } > { createElement ( control , { ... controlProps , label } ) } < / ElementType > ) } return ( < ElementType className = { classes } > { createHTMLLabel ( label , { defaultProps : { htmlFor : _ . get ( controlProps , 'id' ) } , autoGenerateKey : false , } ) } { createElement ( control , controlProps ) } < / ElementType > ) }
33	function CardContent ( props ) { const { children , className , content , description , extra , header , meta , textAlign } = props const classes = cx ( useKeyOnly ( extra , 'extra' ) , useTextAlignProp ( textAlign ) , 'content' , className ) const rest = getUnhandledProps ( CardContent , props ) const ElementType = getElementType ( CardContent , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { createShorthand ( CardHeader , val => ( { content : val } ) , header , { autoGenerateKey : false } ) } { createShorthand ( CardMeta , val => ( { content : val } ) , meta , { autoGenerateKey : false } ) } { createShorthand ( CardDescription , val => ( { content : val } ) , description , { autoGenerateKey : false , } ) } < / ElementType > ) }
34	function Item ( props ) { const { children , className , content , description , extra , header , image , meta } = props const classes = cx ( 'item' , className ) const rest = getUnhandledProps ( Item , props ) const ElementType = getElementType ( Item , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { ItemImage . create ( image , { autoGenerateKey : false } ) } < ItemContent content = { content } description = { description } extra = { extra } header = { header } meta = { meta } / > < / ElementType > ) }
35	function CommentAvatar ( props ) { const { className , src } = props const classes = cx ( 'avatar' , className ) const rest = getUnhandledProps ( CommentAvatar , props ) const [ imageProps , rootProps ] = partitionHTMLProps ( rest , { htmlProps : htmlImageProps } ) const ElementType = getElementType ( CommentAvatar , props ) return ( < ElementType { ... rootProps } className = { classes } > { createHTMLImage ( src , { autoGenerateKey : false , defaultProps : imageProps } ) } < / ElementType > ) }
36	function StatisticLabel ( props ) { const { children , className , content } = props const classes = cx ( 'label' , className ) const rest = getUnhandledProps ( StatisticLabel , props ) const ElementType = getElementType ( StatisticLabel , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
37	function FeedMeta ( props ) { const { children , className , content , like } = props const classes = cx ( 'meta' , className ) const rest = getUnhandledProps ( FeedMeta , props ) const ElementType = getElementType ( FeedMeta , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { createShorthand ( FeedLike , val => ( { content : val } ) , like , { autoGenerateKey : false } ) } { content } < / ElementType > ) }
38	function Container ( props ) { const { children , className , content , fluid , text , textAlign } = props const classes = cx ( 'ui' , useKeyOnly ( text , 'text' ) , useKeyOnly ( fluid , 'fluid' ) , useTextAlignProp ( textAlign ) , 'container' , className , ) const rest = getUnhandledProps ( Container , props ) const ElementType = getElementType ( Container , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
39	function StepGroup ( props ) { const { attached , children , className , content , fluid , items , ordered , size , stackable , unstackable , vertical , widths , } = props const classes = cx ( 'ui' , size , useKeyOnly ( fluid , 'fluid' ) , useKeyOnly ( ordered , 'ordered' ) , useKeyOnly ( unstackable , 'unstackable' ) , useKeyOnly ( vertical , 'vertical' ) , useKeyOrValueAndKey ( attached , 'attached' ) , useValueAndKey ( stackable , 'stackable' ) , useWidthProp ( widths ) , 'steps' , className , ) const rest = getUnhandledProps ( StepGroup , props ) const ElementType = getElementType ( StepGroup , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { _ . map ( items , item => Step . create ( item ) ) } < / ElementType > ) }
40	function Divider ( props ) { const { children , className , clearing , content , fitted , hidden , horizontal , inverted , section , vertical , } = props const classes = cx ( 'ui' , useKeyOnly ( clearing , 'clearing' ) , useKeyOnly ( fitted , 'fitted' ) , useKeyOnly ( hidden , 'hidden' ) , useKeyOnly ( horizontal , 'horizontal' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( section , 'section' ) , useKeyOnly ( vertical , 'vertical' ) , 'divider' , className , ) const rest = getUnhandledProps ( Divider , props ) const ElementType = getElementType ( Divider , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
41	function Header ( props ) { const { attached , block , children , className , color , content , disabled , dividing , floated , icon , image , inverted , size , sub , subheader , textAlign , } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( block , 'block' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( dividing , 'dividing' ) , useValueAndKey ( floated , 'floated' ) , useKeyOnly ( icon === true , 'icon' ) , useKeyOnly ( image === true , 'image' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( sub , 'sub' ) , useKeyOrValueAndKey ( attached , 'attached' ) , useTextAlignProp ( textAlign ) , 'header' , className , ) const rest = getUnhandledProps ( Header , props ) const ElementType = getElementType ( Header , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } const iconElement = Icon . create ( icon , { autoGenerateKey : false } ) const imageElement = Image . create ( image , { autoGenerateKey : false } ) const subheaderElement = HeaderSubheader . create ( subheader , { autoGenerateKey : false } ) if ( iconElement || imageElement ) { return ( < ElementType { ... rest } className = { classes } > { iconElement || imageElement } { ( content || subheaderElement ) && ( < HeaderContent > { content } { subheaderElement } < / HeaderContent > ) } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { content } { subheaderElement } < / ElementType > ) }
42	function Grid ( props ) { const { celled , centered , children , className , columns , container , divided , doubling , inverted , padded , relaxed , reversed , stackable , stretched , textAlign , verticalAlign , } = props const classes = cx ( 'ui' , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( container , 'container' ) , useKeyOnly ( doubling , 'doubling' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( stackable , 'stackable' ) , useKeyOnly ( stretched , 'stretched' ) , useKeyOrValueAndKey ( celled , 'celled' ) , useKeyOrValueAndKey ( divided , 'divided' ) , useKeyOrValueAndKey ( padded , 'padded' ) , useKeyOrValueAndKey ( relaxed , 'relaxed' ) , useMultipleProp ( reversed , 'reversed' ) , useTextAlignProp ( textAlign ) , useVerticalAlignProp ( verticalAlign ) , useWidthProp ( columns , 'column' , true ) , 'grid' , className , ) const rest = getUnhandledProps ( Grid , props ) const ElementType = getElementType ( Grid , props ) return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) }
43	function Breadcrumb ( props ) { const { children , className , divider , icon , sections , size } = props const classes = cx ( 'ui' , size , 'breadcrumb' , className ) const rest = getUnhandledProps ( Breadcrumb , props ) const ElementType = getElementType ( Breadcrumb , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } const childElements = [ ] _ . each ( sections , ( section , index ) => { const breadcrumbElement = BreadcrumbSection . create ( section ) childElements . push ( breadcrumbElement ) if ( index !== sections . length - 1 ) { const key = ` ${ breadcrumbElement . key } ` || JSON . stringify ( section ) childElements . push ( BreadcrumbDivider . create ( { content : divider , icon , key } ) ) } } ) return ( < ElementType { ... rest } className = { classes } > { childElements } < / ElementType > ) }
44	function CardDescription ( props ) { const { children , className , content , textAlign } = props const classes = cx ( useTextAlignProp ( textAlign ) , 'description' , className ) const rest = getUnhandledProps ( CardDescription , props ) const ElementType = getElementType ( CardDescription , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
45	function ItemGroup ( props ) { const { children , className , content , divided , items , link , relaxed , unstackable } = props const classes = cx ( 'ui' , useKeyOnly ( divided , 'divided' ) , useKeyOnly ( link , 'link' ) , useKeyOnly ( unstackable , 'unstackable' ) , useKeyOrValueAndKey ( relaxed , 'relaxed' ) , 'items' , className , ) const rest = getUnhandledProps ( ItemGroup , props ) const ElementType = getElementType ( ItemGroup , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } const itemsJSX = _ . map ( items , ( item ) => { const { childKey , ... itemProps } = item const finalKey = childKey || [ itemProps . content , itemProps . description , itemProps . header , itemProps . meta ] . join ( '-' ) return < Item { ... itemProps } key = { finalKey } / > } ) return ( < ElementType { ... rest } className = { classes } > { itemsJSX } < / ElementType > ) }
46	function GridColumn ( props ) { const { children , className , computer , color , floated , largeScreen , mobile , only , stretched , tablet , textAlign , verticalAlign , widescreen , width , } = props const classes = cx ( color , useKeyOnly ( stretched , 'stretched' ) , useMultipleProp ( only , 'only' ) , useTextAlignProp ( textAlign ) , useValueAndKey ( floated , 'floated' ) , useVerticalAlignProp ( verticalAlign ) , useWidthProp ( computer , 'wide computer' ) , useWidthProp ( largeScreen , 'wide large screen' ) , useWidthProp ( mobile , 'wide mobile' ) , useWidthProp ( tablet , 'wide tablet' ) , useWidthProp ( widescreen , 'wide widescreen' ) , useWidthProp ( width , 'wide' ) , 'column' , className , ) const rest = getUnhandledProps ( GridColumn , props ) const ElementType = getElementType ( GridColumn , props ) return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) }
47	function ItemImage ( props ) { const { size } = props const rest = getUnhandledProps ( ItemImage , props ) return < Image { ... rest } size = { size } ui = { ! ! size } wrapped / > }
48	function CardGroup ( props ) { const { centered , children , className , content , doubling , items , itemsPerRow , stackable , textAlign , } = props const classes = cx ( 'ui' , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( doubling , 'doubling' ) , useKeyOnly ( stackable , 'stackable' ) , useTextAlignProp ( textAlign ) , useWidthProp ( itemsPerRow ) , 'cards' , className , ) const rest = getUnhandledProps ( CardGroup , props ) const ElementType = getElementType ( CardGroup , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } const itemsJSX = _ . map ( items , ( item ) => { const key = item . key || [ item . header , item . description ] . join ( '-' ) return < Card key = { key } { ... item } / > } ) return ( < ElementType { ... rest } className = { classes } > { itemsJSX } < / ElementType > ) }
49	function TableRow ( props ) { const { active , cellAs , cells , children , className , disabled , error , negative , positive , textAlign , verticalAlign , warning , } = props const classes = cx ( useKeyOnly ( active , 'active' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( error , 'error' ) , useKeyOnly ( negative , 'negative' ) , useKeyOnly ( positive , 'positive' ) , useKeyOnly ( warning , 'warning' ) , useTextAlignProp ( textAlign ) , useVerticalAlignProp ( verticalAlign ) , className , ) const rest = getUnhandledProps ( TableRow , props ) const ElementType = getElementType ( TableRow , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { _ . map ( cells , cell => TableCell . create ( cell , { defaultProps : { as : cellAs } } ) ) } < / ElementType > ) }
50	function FeedEvent ( props ) { const { content , children , className , date , extraImages , extraText , image , icon , meta , summary , } = props const classes = cx ( 'event' , className ) const rest = getUnhandledProps ( FeedEvent , props ) const ElementType = getElementType ( FeedEvent , props ) const hasContentProp = content || date || extraImages || extraText || meta || summary const contentProps = { content , date , extraImages , extraText , meta , summary } return ( < ElementType { ... rest } className = { classes } > { createShorthand ( FeedLabel , val => ( { icon : val } ) , icon , { autoGenerateKey : false } ) } { createShorthand ( FeedLabel , val => ( { image : val } ) , image , { autoGenerateKey : false } ) } { hasContentProp && < FeedContent { ... contentProps } / > } { children } < / ElementType > ) }
51	function TabPane ( props ) { const { active , children , className , content , loading } = props const classes = cx ( useKeyOnly ( active , 'active' ) , useKeyOnly ( loading , 'loading' ) , 'tab' , className ) const rest = getUnhandledProps ( TabPane , props ) const ElementType = getElementType ( TabPane , props ) const calculatedDefaultProps = { } if ( ElementType === Segment ) { calculatedDefaultProps . attached = 'bottom' } return ( < ElementType { ... calculatedDefaultProps } { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
52	function ListContent ( props ) { const { children , className , content , description , floated , header , verticalAlign } = props const classes = cx ( useValueAndKey ( floated , 'floated' ) , useVerticalAlignProp ( verticalAlign ) , 'content' , className , ) const rest = getUnhandledProps ( ListContent , props ) const ElementType = getElementType ( ListContent , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { ListHeader . create ( header ) } { ListDescription . create ( description ) } { content } < / ElementType > ) }
53	function ButtonOr ( props ) { const { className , text } = props const classes = cx ( 'or' , className ) const rest = getUnhandledProps ( ButtonOr , props ) const ElementType = getElementType ( ButtonOr , props ) return < ElementType { ... rest } className = { classes } data-text = { text } / > }
54	function TableCell ( props ) { const { active , children , className , collapsing , content , disabled , error , icon , negative , positive , selectable , singleLine , textAlign , verticalAlign , warning , width , } = props const classes = cx ( useKeyOnly ( active , 'active' ) , useKeyOnly ( collapsing , 'collapsing' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( error , 'error' ) , useKeyOnly ( negative , 'negative' ) , useKeyOnly ( positive , 'positive' ) , useKeyOnly ( selectable , 'selectable' ) , useKeyOnly ( singleLine , 'single line' ) , useKeyOnly ( warning , 'warning' ) , useTextAlignProp ( textAlign ) , useVerticalAlignProp ( verticalAlign ) , useWidthProp ( width , 'wide' ) , className , ) const rest = getUnhandledProps ( TableCell , props ) const ElementType = getElementType ( TableCell , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { Icon . create ( icon ) } { content } < / ElementType > ) }
55	function BreadcrumbDivider ( props ) { const { children , className , content , icon } = props const classes = cx ( 'divider' , className ) const rest = getUnhandledProps ( BreadcrumbDivider , props ) const ElementType = getElementType ( BreadcrumbDivider , props ) if ( ! _ . isNil ( icon ) ) { return Icon . create ( icon , { defaultProps : { ... rest , className : classes } , autoGenerateKey : false , } ) } if ( ! _ . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? '/' : children } < / ElementType > ) }
56	function MessageList ( props ) { const { children , className , items } = props const classes = cx ( 'list' , className ) const rest = getUnhandledProps ( MessageList , props ) const ElementType = getElementType ( MessageList , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? _ . map ( items , MessageItem . create ) : children } < / ElementType > ) }
57	function TableFooter ( props ) { const { as } = props const rest = getUnhandledProps ( TableFooter , props ) return < TableHeader { ... rest } as = { as } / > }
58	function CommentGroup ( props ) { const { className , children , collapsed , content , minimal , size , threaded } = props const classes = cx ( 'ui' , size , useKeyOnly ( collapsed , 'collapsed' ) , useKeyOnly ( minimal , 'minimal' ) , useKeyOnly ( threaded , 'threaded' ) , 'comments' , className , ) const rest = getUnhandledProps ( CommentGroup , props ) const ElementType = getElementType ( CommentGroup , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
59	function Reveal ( props ) { const { active , animated , children , className , content , disabled , instant } = props const classes = cx ( 'ui' , animated , useKeyOnly ( active , 'active' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( instant , 'instant' ) , 'reveal' , className , ) const rest = getUnhandledProps ( Reveal , props ) const ElementType = getElementType ( Reveal , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
60	function Segment ( props ) { const { attached , basic , children , circular , className , clearing , color , compact , content , disabled , floated , inverted , loading , placeholder , padded , piled , raised , secondary , size , stacked , tertiary , textAlign , vertical , } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( basic , 'basic' ) , useKeyOnly ( circular , 'circular' ) , useKeyOnly ( clearing , 'clearing' ) , useKeyOnly ( compact , 'compact' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( loading , 'loading' ) , useKeyOnly ( placeholder , 'placeholder' ) , useKeyOnly ( piled , 'piled' ) , useKeyOnly ( raised , 'raised' ) , useKeyOnly ( secondary , 'secondary' ) , useKeyOnly ( stacked , 'stacked' ) , useKeyOnly ( tertiary , 'tertiary' ) , useKeyOnly ( vertical , 'vertical' ) , useKeyOrValueAndKey ( attached , 'attached' ) , useKeyOrValueAndKey ( padded , 'padded' ) , useTextAlignProp ( textAlign ) , useValueAndKey ( floated , 'floated' ) , 'segment' , className , ) const rest = getUnhandledProps ( Segment , props ) const ElementType = getElementType ( Segment , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
61	function PlaceholderLine ( props ) { const { className , length } = props const classes = cx ( 'line' , length , className ) const rest = getUnhandledProps ( PlaceholderLine , props ) const ElementType = getElementType ( PlaceholderLine , props ) return < ElementType { ... rest } className = { classes } / > }
62	function RevealContent ( props ) { const { children , className , content , hidden , visible } = props const classes = cx ( 'ui' , useKeyOnly ( hidden , 'hidden' ) , useKeyOnly ( visible , 'visible' ) , 'content' , className , ) const rest = getUnhandledProps ( RevealContent , props ) const ElementType = getElementType ( RevealContent , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
63	function FeedLike ( props ) { const { children , className , content , icon } = props const classes = cx ( 'like' , className ) const rest = getUnhandledProps ( FeedLike , props ) const ElementType = getElementType ( FeedLike , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { Icon . create ( icon , { autoGenerateKey : false } ) } { content } < / ElementType > ) }
64	function Placeholder ( props ) { const { children , className , content , fluid , inverted } = props const classes = cx ( 'ui' , useKeyOnly ( fluid , 'fluid' ) , useKeyOnly ( inverted , 'inverted' ) , 'placeholder' , className , ) const rest = getUnhandledProps ( Placeholder , props ) const ElementType = getElementType ( Placeholder , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
65	function Accordion ( props ) { const { className , fluid , inverted , styled } = props const classes = cx ( 'ui' , useKeyOnly ( fluid , 'fluid' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( styled , 'styled' ) , className , ) const rest = getUnhandledProps ( Accordion , props ) return < AccordionAccordion { ... rest } className = { classes } / > }
66	function PlaceholderImage ( props ) { const { className , square , rectangular } = props const classes = cx ( useKeyOnly ( square , 'square' ) , useKeyOnly ( rectangular , 'rectangular' ) , 'image' , className , ) const rest = getUnhandledProps ( PlaceholderImage , props ) const ElementType = getElementType ( PlaceholderImage , props ) return < ElementType { ... rest } className = { classes } / > }
67	function DropdownMenu ( props ) { const { children , className , content , direction , open , scrolling } = props const classes = cx ( direction , useKeyOnly ( open , 'visible' ) , useKeyOnly ( scrolling , 'scrolling' ) , 'menu transition' , className , ) const rest = getUnhandledProps ( DropdownMenu , props ) const ElementType = getElementType ( DropdownMenu , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
68	function ListIcon ( props ) { const { className , verticalAlign } = props const classes = cx ( useVerticalAlignProp ( verticalAlign ) , className ) const rest = getUnhandledProps ( ListIcon , props ) return < Icon { ... rest } className = { classes } / > }
69	function Advertisement ( props ) { const { centered , children , className , content , test , unit } = props const classes = cx ( 'ui' , unit , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( test , 'test' ) , 'ad' , className , ) const rest = getUnhandledProps ( Advertisement , props ) const ElementType = getElementType ( Advertisement , props ) return ( < ElementType { ... rest } className = { classes } data-text = { test } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
70	function StatisticGroup ( props ) { const { children , className , color , content , horizontal , inverted , items , size , widths } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( horizontal , 'horizontal' ) , useKeyOnly ( inverted , 'inverted' ) , useWidthProp ( widths ) , 'statistics' , className , ) const rest = getUnhandledProps ( StatisticGroup , props ) const ElementType = getElementType ( StatisticGroup , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { _ . map ( items , item => Statistic . create ( item ) ) } < / ElementType > ) }
71	function Statistic ( props ) { const { children , className , color , content , floated , horizontal , inverted , label , size , text , value , } = props const classes = cx ( 'ui' , color , size , useValueAndKey ( floated , 'floated' ) , useKeyOnly ( horizontal , 'horizontal' ) , useKeyOnly ( inverted , 'inverted' ) , 'statistic' , className , ) const rest = getUnhandledProps ( Statistic , props ) const ElementType = getElementType ( Statistic , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { StatisticValue . create ( value , { defaultProps : { text } , autoGenerateKey : false , } ) } { StatisticLabel . create ( label , { autoGenerateKey : false } ) } < / ElementType > ) }
72	function SegmentGroup ( props ) { const { children , className , compact , content , horizontal , piled , raised , size , stacked } = props const classes = cx ( 'ui' , size , useKeyOnly ( compact , 'compact' ) , useKeyOnly ( horizontal , 'horizontal' ) , useKeyOnly ( piled , 'piled' ) , useKeyOnly ( raised , 'raised' ) , useKeyOnly ( stacked , 'stacked' ) , 'segments' , className , ) const rest = getUnhandledProps ( SegmentGroup , props ) const ElementType = getElementType ( SegmentGroup , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
73	function TableHeaderCell ( props ) { const { as , className , sorted } = props const classes = cx ( useValueAndKey ( sorted , 'sorted' ) , className ) const rest = getUnhandledProps ( TableHeaderCell , props ) return < TableCell { ... rest } as = { as } className = { classes } / > }
74	function Feed ( props ) { const { children , className , events , size } = props const classes = cx ( 'ui' , size , 'feed' , className ) const rest = getUnhandledProps ( Feed , props ) const ElementType = getElementType ( Feed , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } const eventElements = _ . map ( events , ( eventProps ) => { const { childKey , date , meta , summary , ... eventData } = eventProps const finalKey = childKey || [ date , meta , summary ] . join ( '-' ) return < FeedEvent date = { date } key = { finalKey } meta = { meta } summary = { summary } { ... eventData } / > } ) return ( < ElementType { ... rest } className = { classes } > { eventElements } < / ElementType > ) }
75	function LabelGroup ( props ) { const { children , circular , className , color , content , size , tag } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( circular , 'circular' ) , useKeyOnly ( tag , 'tag' ) , 'labels' , className , ) const rest = getUnhandledProps ( LabelGroup , props ) const ElementType = getElementType ( LabelGroup , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) }
76	function FeedExtra ( props ) { const { children , className , content , images , text } = props const classes = cx ( useKeyOnly ( images , 'images' ) , useKeyOnly ( content || text , 'text' ) , 'extra' , className , ) const rest = getUnhandledProps ( FeedExtra , props ) const ElementType = getElementType ( FeedExtra , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } const imageElements = _ . map ( images , ( image , index ) => { const key = [ index , image ] . join ( '-' ) return createHTMLImage ( image , { key } ) } ) return ( < ElementType { ... rest } className = { classes } > { content } { imageElements } < / ElementType > ) }
77	function DropdownDivider ( props ) { const { className } = props const classes = cx ( 'divider' , className ) const rest = getUnhandledProps ( DropdownDivider , props ) const ElementType = getElementType ( DropdownDivider , props ) return < ElementType { ... rest } className = { classes } / > }
78	function FeedSummary ( props ) { const { children , className , content , date , user } = props const classes = cx ( 'summary' , className ) const rest = getUnhandledProps ( FeedSummary , props ) const ElementType = getElementType ( FeedSummary , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { createShorthand ( FeedUser , val => ( { content : val } ) , user , { autoGenerateKey : false } ) } { content } { createShorthand ( FeedDate , val => ( { content : val } ) , date , { autoGenerateKey : false } ) } < / ElementType > ) }
79	function StepContent ( props ) { const { children , className , content , description , title } = props const classes = cx ( 'content' , className ) const rest = getUnhandledProps ( StepContent , props ) const ElementType = getElementType ( StepContent , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { StepTitle . create ( title , { autoGenerateKey : false } ) } { StepDescription . create ( description , { autoGenerateKey : false } ) } < / ElementType > ) }
80	function Image ( props ) { const { avatar , bordered , centered , children , circular , className , content , dimmer , disabled , floated , fluid , hidden , href , inline , label , rounded , size , spaced , verticalAlign , wrapped , ui , } = props const classes = cx ( useKeyOnly ( ui , 'ui' ) , size , useKeyOnly ( avatar , 'avatar' ) , useKeyOnly ( bordered , 'bordered' ) , useKeyOnly ( circular , 'circular' ) , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( fluid , 'fluid' ) , useKeyOnly ( hidden , 'hidden' ) , useKeyOnly ( inline , 'inline' ) , useKeyOnly ( rounded , 'rounded' ) , useKeyOrValueAndKey ( spaced , 'spaced' ) , useValueAndKey ( floated , 'floated' ) , useVerticalAlignProp ( verticalAlign , 'aligned' ) , 'image' , className , ) const rest = getUnhandledProps ( Image , props ) const [ imgTagProps , rootProps ] = partitionHTMLProps ( rest , { htmlProps : htmlImageProps } ) const ElementType = getElementType ( Image , props , ( ) => { if ( ! _ . isNil ( dimmer ) || ! _ . isNil ( label ) || ! _ . isNil ( wrapped ) || ! childrenUtils . isNil ( children ) ) { return 'div' } } ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } if ( ElementType === 'img' ) { return < ElementType { ... rootProps } { ... imgTagProps } className = { classes } / > } return ( < ElementType { ... rootProps } className = { classes } href = { href } > { Dimmer . create ( dimmer , { autoGenerateKey : false } ) } { Label . create ( label , { autoGenerateKey : false } ) } < img { ... imgTagProps } / > < / ElementType > ) }
81	function ( canvas ) { var context = canvas . getContext ( '2d' ) , devicePixelRatio = window . devicePixelRatio || 1 , backingStorePixelRatio = context . webkitBackingStorePixelRatio || context . mozBackingStorePixelRatio || context . msBackingStorePixelRatio || context . oBackingStorePixelRatio || context . backingStorePixelRatio || 1 ; return devicePixelRatio / backingStorePixelRatio ; }
82	function ( render , background ) { var cssBackground = background ; if ( / (jpg|gif|png)$ / . test ( background ) ) cssBackground = 'url(' + background + ')' ; render . canvas . style . background = cssBackground ; render . canvas . style . backgroundSize = "contain" ; render . currentBackground = background ; }
83	function ( render , body ) { var bodyRender = body . render , texturePath = bodyRender . sprite . texture , texture = _getTexture ( render , texturePath ) , sprite = new PIXI . Sprite ( texture ) ; sprite . anchor . x = body . render . sprite . xOffset ; sprite . anchor . y = body . render . sprite . yOffset ; return sprite ; }
84	function ( render , body ) { var bodyRender = body . render , options = render . options , primitive = new PIXI . Graphics ( ) , fillStyle = Common . colorToNumber ( bodyRender . fillStyle ) , strokeStyle = Common . colorToNumber ( bodyRender . strokeStyle ) , strokeStyleIndicator = Common . colorToNumber ( bodyRender . strokeStyle ) , strokeStyleWireframe = Common . colorToNumber ( '#bbb' ) , strokeStyleWireframeIndicator = Common . colorToNumber ( '#CD5C5C' ) , part ; primitive . clear ( ) ; for ( var k = body . parts . length > 1 ? 1 : 0 ; k < body . parts . length ; k ++ ) { part = body . parts [ k ] ; if ( ! options . wireframes ) { primitive . beginFill ( fillStyle , 1 ) ; primitive . lineStyle ( bodyRender . lineWidth , strokeStyle , 1 ) ; } else { primitive . beginFill ( 0 , 0 ) ; primitive . lineStyle ( 1 , strokeStyleWireframe , 1 ) ; } primitive . moveTo ( part . vertices [ 0 ] . x - body . position . x , part . vertices [ 0 ] . y - body . position . y ) ; for ( var j = 1 ; j < part . vertices . length ; j ++ ) { primitive . lineTo ( part . vertices [ j ] . x - body . position . x , part . vertices [ j ] . y - body . position . y ) ; } primitive . lineTo ( part . vertices [ 0 ] . x - body . position . x , part . vertices [ 0 ] . y - body . position . y ) ; primitive . endFill ( ) ; if ( options . showAngleIndicator || options . showAxes ) { primitive . beginFill ( 0 , 0 ) ; if ( options . wireframes ) { primitive . lineStyle ( 1 , strokeStyleWireframeIndicator , 1 ) ; } else { primitive . lineStyle ( 1 , strokeStyleIndicator ) ; } primitive . moveTo ( part . position . x - body . position . x , part . position . y - body . position . y ) ; primitive . lineTo ( ( ( part . vertices [ 0 ] . x + part . vertices [ part . vertices . length - 1 ] . x ) / 2 - body . position . x ) , ( ( part . vertices [ 0 ] . y + part . vertices [ part . vertices . length - 1 ] . y ) / 2 - body . position . y ) ) ; primitive . endFill ( ) ; } } return primitive ; }
85	function ( body , options ) { options = options || { } ; Body . set ( body , { bounds : body . bounds || Bounds . create ( body . vertices ) , positionPrev : body . positionPrev || Vector . clone ( body . position ) , anglePrev : body . anglePrev || body . angle , vertices : body . vertices , parts : body . parts || [ body ] , isStatic : body . isStatic , isSleeping : body . isSleeping , parent : body . parent || body } ) ; Vertices . rotate ( body . vertices , body . angle , body . position ) ; Axes . rotate ( body . axes , body . angle ) ; Bounds . update ( body . bounds , body . vertices , body . velocity ) ; Body . set ( body , { axes : options . axes || body . axes , area : options . area || body . area , mass : options . mass || body . mass , inertia : options . inertia || body . inertia } ) ; var defaultFillStyle = ( body . isStatic ? '#2e2b44' : Common . choose ( [ '#006BA6' , '#0496FF' , '#FFBC42' , '#D81159' , '#8F2D56' ] ) ) , defaultStrokeStyle = '#000' ; body . render . fillStyle = body . render . fillStyle || defaultFillStyle ; body . render . strokeStyle = body . render . strokeStyle || defaultStrokeStyle ; body . render . sprite . xOffset += - ( body . bounds . min . x - body . position . x ) / ( body . bounds . max . x - body . bounds . min . x ) ; body . render . sprite . yOffset += - ( body . bounds . min . y - body . position . y ) / ( body . bounds . max . y - body . bounds . min . y ) ; }
86	async function createPages ( { actions , graphql } ) { const retrieveMarkdownPages = ( ) => graphql ( ` ` ) const exampleTemplate = path . resolve ( ` ` ) const docTemplate = path . resolve ( ` ` ) const result = await retrieveMarkdownPages ( ) if ( result . errors ) { console . error ( 'graphql error' , result . errors ) throw new Error ( 'Error invoking graphql for pages' ) } result . data . allMarkdownRemark . edges . forEach ( ( { node } ) => { const { frontmatter : { path : pagePath } , } = node const category = ( pagePath || '/' ) . split ( '/' ) . filter ( t => ! ! t ) [ 0 ] const isExample = category === 'examples' console . log ( ` ${ pagePath } ${ category } ` ) actions . createPage ( { path : pagePath , component : isExample ? exampleTemplate : docTemplate , context : { } , } ) } ) }
87	function isWindow ( val ) { if ( typeof val !== "object" ) { return false ; } const wrapper = idlUtils . wrapperForImpl ( val ) ; if ( typeof wrapper === "object" ) { return wrapper === wrapper . _globalProxy ; } return isWindow ( idlUtils . implForWrapper ( val ) ) ; }
88	function normalizeEventHandlerOptions ( options , defaultBoolKeys ) { const returnValue = { } ; if ( typeof options === "boolean" || options === null || typeof options === "undefined" ) { returnValue . capture = Boolean ( options ) ; return returnValue ; } if ( typeof options !== "object" ) { returnValue . capture = Boolean ( options ) ; defaultBoolKeys = defaultBoolKeys . filter ( k => k !== "capture" ) ; } for ( const key of defaultBoolKeys ) { returnValue [ key ] = Boolean ( options [ key ] ) ; } return returnValue ; }
89	function sammary ( ) { const nodeFn = function ( { parentPaths , lang , item , isDir , result } ) { const navTitle = generateNavTitle ( { parentPaths , item , sign : isDir ? '-' : '*' , lang } ) ; result . push ( navTitle ) ; } ; langs . forEach ( dir => { const SUMMARY = 'SUMMARY.md' ; const targetFile = path . join ( docsDir , ` ${ dir } ${ SUMMARY } ` ) ; const result = walk ( { catalog : docConfig . catalog , lang : dir , result : [ ] , parentPaths : [ ] , fn : nodeFn } ) ; if ( result && result . length ) { result . unshift ( '# whistle\n' ) ; \n } } ) ; }
90	function createItemString ( data , limit ) { var count = 0 ; var hasMore = false ; if ( ( 0 , _isSafeInteger2 [ 'default' ] ) ( data . size ) ) { count = data . size ; } else { for ( var _iterator = data , _isArray = Array . isArray ( _iterator ) , _i = 0 , _iterator = _isArray ? _iterator : ( 0 , _getIterator3 [ 'default' ] ) ( _iterator ) ; ; ) { var _ref ; if ( _isArray ) { if ( _i >= _iterator . length ) break ; _ref = _iterator [ _i ++ ] ; } else { _i = _iterator . next ( ) ; if ( _i . done ) break ; _ref = _i . value ; } var entry = _ref ; if ( limit && count + 1 > limit ) { hasMore = true ; break ; } count += 1 ; } } return '' + ( hasMore ? '>' : '' ) + count + ' ' + ( count !== 1 ? 'entries' : 'entry' ) ; }
91	function kw ( name , options = { } ) { options . keyword = name return keywords [ name ] = new TokenType ( name , options ) }
92	function isInAstralSet ( code , set ) { let pos = 0x10000 for ( let i = 0 ; i < set . length ; i += 2 ) { pos += set [ i ] if ( pos > code ) return false pos += set [ i + 1 ] if ( pos >= code ) return true } }
93	function transformMetadata ( metadata ) { const namesRegEx = new RegExp ( metadata . tokens . map ( token => token . name ) . join ( '|' ) , 'g' ) ; const replaceMap = { } ; metadata . tokens . map ( token => { replaceMap [ token . name ] = formatTokenName ( token . name ) ; } ) ; metadata . tokens . forEach ( ( token , i ) => { if ( token . role ) { token . role . forEach ( ( role , j ) => { metadata . tokens [ i ] . role [ j ] = role . replace ( namesRegEx , match => { return '`$' + replaceMap [ match ] + '`' ; } ) ; } ) ; } if ( token . alias ) { token . alias = formatTokenName ( token . alias ) ; } } ) ; return metadata ; }
94	async function findPackageFor ( filepath ) { let directory = filepath ; while ( directory !== '/' ) { const directoryToSearch = path . dirname ( directory ) ; const files = await fs . readdir ( directoryToSearch ) ; if ( files . indexOf ( 'package.json' ) !== - 1 ) { const packageJson = await fs . readJson ( path . join ( directoryToSearch , 'package.json' ) ) ; return packageJson . name ; } directory = path . resolve ( directory , '..' ) ; } throw new Error ( ` ${ filepath } ` ) ; }
95	function svgToggleClass ( svg , name , forceAdd ) { const list = svg . getAttribute ( 'class' ) . trim ( ) . split ( / \s+ / ) ; const uniqueList = Object . keys ( list . reduce ( ( o , item ) => Object . assign ( o , { [ item ] : 1 } ) , { } ) ) ; const index = uniqueList . indexOf ( name ) ; const found = index >= 0 ; const add = forceAdd === undefined ? ! found : forceAdd ; if ( found === ! add ) { if ( add ) { uniqueList . push ( name ) ; } else { uniqueList . splice ( index , 1 ) ; } svg . setAttribute ( 'class' , uniqueList . join ( ' ' ) ) ; } }
96	async function flatMapAsync ( source , mapFn ) { const results = await Promise . all ( source . map ( mapFn ) ) ; return results . reduce ( ( acc , result ) => acc . concat ( result ) , [ ] ) ; }
97	async function createJson ( sourceDir , config ) { config = config || { } ; return sassdoc . parse ( sourceDir , config ) . then ( data => { return data ; } , err => { console . error ( err ) ; } ) ; }
98	function dedupeArray ( arr ) { return arr . reduce ( ( p , item ) => { const type = item . type || item . context . type ; const name = item . name || item . context . name ; const id = [ type , name ] . join ( '|' ) ; if ( p . temp . indexOf ( id ) === - 1 ) { p . out . push ( item ) ; p . temp . push ( id ) ; } return p ; } , { temp : [ ] , out : [ ] } ) . out ; }
99	async function createMarkdown ( sourceDir , config ) { config = config || { } ; return sassdoc . parse ( sourceDir , config ) . then ( data => { let markdownFile = '' ; const documentedItems = data . filter ( ( item , index ) => item . access === 'public' || item . access === 'private' ) ; markdownFile += ` ` ; let currentGroup = '' ; documentedItems . forEach ( item => { const itemGroup = createGroupName ( item . group ) ; if ( itemGroup !== currentGroup ) { markdownFile += ` \n \n ${ itemGroup } ` ; currentGroup = itemGroup ; } markdownFile += createMarkdownItem ( item ) ; } ) ; return prettier . format ( toc . insert ( markdownFile , { slugify } ) , prettierOptions ) ; } , err => { console . error ( err ) ; } ) ; }
100	function flattenOptions ( options ) { const o = { } ; for ( const key in options ) { o [ key ] = options [ key ] ; } return o ; }
101	function append ( str , prefix = '' ) { const item = document . createElement ( 'li' ) ; item . textContent = prefix + str ; list . appendChild ( item ) ; }
102	function multiresNodeSort ( a , b ) { if ( a . level == 1 && b . level != 1 ) { return - 1 ; } if ( b . level == 1 && a . level != 1 ) { return 1 ; } return b . timestamp - a . timestamp ; }
103	function multiresNodeRenderSort ( a , b ) { if ( a . level != b . level ) { return a . level - b . level ; } return a . diff - b . diff ; }
104	function multiresDraw ( ) { if ( ! program . drawInProgress ) { program . drawInProgress = true ; gl . clear ( gl . COLOR_BUFFER_BIT ) ; for ( var i = 0 ; i < program . currentNodes . length ; i ++ ) { if ( program . currentNodes [ i ] . textureLoaded > 1 ) { gl . bindBuffer ( gl . ARRAY_BUFFER , cubeVertBuf ) ; gl . bufferData ( gl . ARRAY_BUFFER , new Float32Array ( program . currentNodes [ i ] . vertices ) , gl . STATIC_DRAW ) ; gl . vertexAttribPointer ( program . vertPosLocation , 3 , gl . FLOAT , false , 0 , 0 ) ; gl . bindBuffer ( gl . ARRAY_BUFFER , cubeVertTexCoordBuf ) ; gl . vertexAttribPointer ( program . texCoordLocation , 2 , gl . FLOAT , false , 0 , 0 ) ; gl . bindTexture ( gl . TEXTURE_2D , program . currentNodes [ i ] . texture ) ; gl . drawElements ( gl . TRIANGLES , 6 , gl . UNSIGNED_SHORT , 0 ) ; } } program . drawInProgress = false ; } }
105	function MultiresNode ( vertices , side , level , x , y , path ) { this . vertices = vertices ; this . side = side ; this . level = level ; this . x = x ; this . y = y ; this . path = path . replace ( '%s' , side ) . replace ( '%l' , level ) . replace ( '%x' , x ) . replace ( '%y' , y ) ; }
106	function rotateMatrix ( m , angle , axis ) { var s = Math . sin ( angle ) ; var c = Math . cos ( angle ) ; if ( axis == 'x' ) { return [ m [ 0 ] , c * m [ 1 ] + s * m [ 2 ] , c * m [ 2 ] - s * m [ 1 ] , m [ 3 ] , c * m [ 4 ] + s * m [ 5 ] , c * m [ 5 ] - s * m [ 4 ] , m [ 6 ] , c * m [ 7 ] + s * m [ 8 ] , c * m [ 8 ] - s * m [ 7 ] ] ; } if ( axis == 'y' ) { return [ c * m [ 0 ] - s * m [ 2 ] , m [ 1 ] , c * m [ 2 ] + s * m [ 0 ] , c * m [ 3 ] - s * m [ 5 ] , m [ 4 ] , c * m [ 5 ] + s * m [ 3 ] , c * m [ 6 ] - s * m [ 8 ] , m [ 7 ] , c * m [ 8 ] + s * m [ 6 ] ] ; } if ( axis == 'z' ) { return [ c * m [ 0 ] + s * m [ 1 ] , c * m [ 1 ] - s * m [ 0 ] , m [ 2 ] , c * m [ 3 ] + s * m [ 4 ] , c * m [ 4 ] - s * m [ 3 ] , m [ 5 ] , c * m [ 6 ] + s * m [ 7 ] , c * m [ 7 ] - s * m [ 6 ] , m [ 8 ] ] ; } }
107	function makeMatrix4 ( m ) { return [ m [ 0 ] , m [ 1 ] , m [ 2 ] , 0 , m [ 3 ] , m [ 4 ] , m [ 5 ] , 0 , m [ 6 ] , m [ 7 ] , m [ 8 ] , 0 , 0 , 0 , 0 , 1 ] ; }
108	function makePersp ( hfov , aspect , znear , zfar ) { var fovy = 2 * Math . atan ( Math . tan ( hfov / 2 ) * gl . drawingBufferHeight / gl . drawingBufferWidth ) ; var f = 1 / Math . tan ( fovy / 2 ) ; return [ f / aspect , 0 , 0 , 0 , 0 , f , 0 , 0 , 0 , 0 , ( zfar + znear ) / ( znear - zfar ) , ( 2 * zfar * znear ) / ( znear - zfar ) , 0 , 0 , - 1 , 0 ] ; }
109	function processLoadedTexture ( img , tex ) { gl . bindTexture ( gl . TEXTURE_2D , tex ) ; gl . texImage2D ( gl . TEXTURE_2D , 0 , gl . RGB , gl . RGB , gl . UNSIGNED_BYTE , img ) ; gl . texParameteri ( gl . TEXTURE_2D , gl . TEXTURE_MAG_FILTER , gl . LINEAR ) ; gl . texParameteri ( gl . TEXTURE_2D , gl . TEXTURE_MIN_FILTER , gl . LINEAR ) ; gl . texParameteri ( gl . TEXTURE_2D , gl . TEXTURE_WRAP_S , gl . CLAMP_TO_EDGE ) ; gl . texParameteri ( gl . TEXTURE_2D , gl . TEXTURE_WRAP_T , gl . CLAMP_TO_EDGE ) ; gl . bindTexture ( gl . TEXTURE_2D , null ) ; }
110	function checkZoom ( hfov ) { var newLevel = 1 ; while ( newLevel < image . maxLevel && gl . drawingBufferWidth > image . tileResolution * Math . pow ( 2 , newLevel - 1 ) * Math . tan ( hfov / 2 ) * 0.707 ) { newLevel ++ ; } program . level = newLevel ; }
111	function rotatePersp ( p , r ) { return [ p [ 0 ] * r [ 0 ] , p [ 0 ] * r [ 1 ] , p [ 0 ] * r [ 2 ] , 0 , p [ 5 ] * r [ 4 ] , p [ 5 ] * r [ 5 ] , p [ 5 ] * r [ 6 ] , 0 , p [ 10 ] * r [ 8 ] , p [ 10 ] * r [ 9 ] , p [ 10 ] * r [ 10 ] , p [ 11 ] , - r [ 8 ] , - r [ 9 ] , - r [ 10 ] , 0 ] ; }
112	function checkInView ( m , v ) { var vpp = applyRotPerspToVec ( m , v ) ; var winX = vpp [ 0 ] * vpp [ 3 ] ; var winY = vpp [ 1 ] * vpp [ 3 ] ; var winZ = vpp [ 2 ] * vpp [ 3 ] ; var ret = [ 0 , 0 , 0 ] ; if ( winX < - 1 ) ret [ 0 ] = - 1 ; if ( winX > 1 ) ret [ 0 ] = 1 ; if ( winY < - 1 ) ret [ 1 ] = - 1 ; if ( winY > 1 ) ret [ 1 ] = 1 ; if ( winZ < - 1 || winZ > 1 ) ret [ 2 ] = 1 ; return ret ; }
113	function onImageLoad ( ) { if ( ! renderer ) renderer = new libpannellum . renderer ( renderContainer ) ; if ( ! listenersAdded ) { listenersAdded = true ; dragFix . addEventListener ( 'mousedown' , onDocumentMouseDown , false ) ; document . addEventListener ( 'mousemove' , onDocumentMouseMove , false ) ; document . addEventListener ( 'mouseup' , onDocumentMouseUp , false ) ; if ( config . mouseZoom ) { uiContainer . addEventListener ( 'mousewheel' , onDocumentMouseWheel , false ) ; uiContainer . addEventListener ( 'DOMMouseScroll' , onDocumentMouseWheel , false ) ; } if ( config . doubleClickZoom ) { dragFix . addEventListener ( 'dblclick' , onDocumentDoubleClick , false ) ; } container . addEventListener ( 'mozfullscreenchange' , onFullScreenChange , false ) ; container . addEventListener ( 'webkitfullscreenchange' , onFullScreenChange , false ) ; container . addEventListener ( 'msfullscreenchange' , onFullScreenChange , false ) ; container . addEventListener ( 'fullscreenchange' , onFullScreenChange , false ) ; window . addEventListener ( 'resize' , onDocumentResize , false ) ; window . addEventListener ( 'orientationchange' , onDocumentResize , false ) ; if ( ! config . disableKeyboardCtrl ) { container . addEventListener ( 'keydown' , onDocumentKeyPress , false ) ; container . addEventListener ( 'keyup' , onDocumentKeyUp , false ) ; container . addEventListener ( 'blur' , clearKeys , false ) ; } document . addEventListener ( 'mouseleave' , onDocumentMouseUp , false ) ; if ( document . documentElement . style . pointerAction === '' && document . documentElement . style . touchAction === '' ) { dragFix . addEventListener ( 'pointerdown' , onDocumentPointerDown , false ) ; dragFix . addEventListener ( 'pointermove' , onDocumentPointerMove , false ) ; dragFix . addEventListener ( 'pointerup' , onDocumentPointerUp , false ) ; dragFix . addEventListener ( 'pointerleave' , onDocumentPointerUp , false ) ; } else { dragFix . addEventListener ( 'touchstart' , onDocumentTouchStart , false ) ; dragFix . addEventListener ( 'touchmove' , onDocumentTouchMove , false ) ; dragFix . addEventListener ( 'touchend' , onDocumentTouchEnd , false ) ; } if ( window . navigator . pointerEnabled ) container . style . touchAction = 'none' ; } renderInit ( ) ; setHfov ( config . hfov ) ; setTimeout ( function ( ) { isTimedOut = true ; } , 500 ) ; }
114	function ( tag ) { var result ; if ( xmpData . indexOf ( tag + '="' ) >= 0 ) { result = xmpData . substring ( xmpData . indexOf ( tag + '="' ) + tag . length + 2 ) ; result = result . substring ( 0 , result . indexOf ( '"' ) ) ; } else if ( xmpData . indexOf ( tag + '>' ) >= 0 ) { result = xmpData . substring ( xmpData . indexOf ( tag + '>' ) + tag . length + 1 ) ; result = result . substring ( 0 , result . indexOf ( '<' ) ) ; } if ( result !== undefined ) { return Number ( result ) ; } return null ; }
115	function anError ( errorMsg ) { if ( errorMsg === undefined ) errorMsg = config . strings . genericWebGLError ; infoDisplay . errorMsg . innerHTML = '<p>' + errorMsg + '</p>' ; controls . load . style . display = 'none' ; infoDisplay . load . box . style . display = 'none' ; infoDisplay . errorMsg . style . display = 'table' ; error = true ; renderContainer . style . display = 'none' ; fireEvent ( 'error' , errorMsg ) ; }
116	function clearError ( ) { if ( error ) { infoDisplay . load . box . style . display = 'none' ; infoDisplay . errorMsg . style . display = 'none' ; error = false ; fireEvent ( 'errorcleared' ) ; } }
117	function aboutMessage ( event ) { var pos = mousePosition ( event ) ; aboutMsg . style . left = pos . x + 'px' ; aboutMsg . style . top = pos . y + 'px' ; clearTimeout ( aboutMessage . t1 ) ; clearTimeout ( aboutMessage . t2 ) ; aboutMsg . style . display = 'block' ; aboutMsg . style . opacity = 1 ; aboutMessage . t1 = setTimeout ( function ( ) { aboutMsg . style . opacity = 0 ; } , 2000 ) ; aboutMessage . t2 = setTimeout ( function ( ) { aboutMsg . style . display = 'none' ; } , 2500 ) ; event . preventDefault ( ) ; }
118	function mousePosition ( event ) { var bounds = container . getBoundingClientRect ( ) ; var pos = { } ; pos . x = ( event . clientX || event . pageX ) - bounds . left ; pos . y = ( event . clientY || event . pageY ) - bounds . top ; return pos ; }
119	function onDocumentMouseDown ( event ) { event . preventDefault ( ) ; container . focus ( ) ; if ( ! loaded || ! config . draggable ) { return ; } var pos = mousePosition ( event ) ; if ( config . hotSpotDebug ) { var coords = mouseEventToCoords ( event ) ; console . log ( 'Pitch: ' + coords [ 0 ] + ', Yaw: ' + coords [ 1 ] + ', Center Pitch: ' + config . pitch + ', Center Yaw: ' + config . yaw + ', HFOV: ' + config . hfov ) ; } stopAnimation ( ) ; stopOrientation ( ) ; config . roll = 0 ; speed . hfov = 0 ; isUserInteracting = true ; latestInteraction = Date . now ( ) ; onPointerDownPointerX = pos . x ; onPointerDownPointerY = pos . y ; onPointerDownYaw = config . yaw ; onPointerDownPitch = config . pitch ; uiContainer . classList . add ( 'pnlm-grabbing' ) ; uiContainer . classList . remove ( 'pnlm-grab' ) ; fireEvent ( 'mousedown' , event ) ; animateInit ( ) ; }
120	function onDocumentDoubleClick ( event ) { if ( config . minHfov === config . hfov ) { _this . setHfov ( origHfov , 1000 ) ; } else { var coords = mouseEventToCoords ( event ) ; _this . lookAt ( coords [ 0 ] , coords [ 1 ] , config . minHfov , 1000 ) ; } }
121	function mouseEventToCoords ( event ) { var pos = mousePosition ( event ) ; var canvas = renderer . getCanvas ( ) ; var canvasWidth = canvas . clientWidth , canvasHeight = canvas . clientHeight ; var x = pos . x / canvasWidth * 2 - 1 ; var y = ( 1 - pos . y / canvasHeight * 2 ) * canvasHeight / canvasWidth ; var focal = 1 / Math . tan ( config . hfov * Math . PI / 360 ) ; var s = Math . sin ( config . pitch * Math . PI / 180 ) ; var c = Math . cos ( config . pitch * Math . PI / 180 ) ; var a = focal * c - y * s ; var root = Math . sqrt ( x * x + a * a ) ; var pitch = Math . atan ( ( y * c + focal * s ) / root ) * 180 / Math . PI ; var yaw = Math . atan2 ( x / root , a / root ) * 180 / Math . PI + config . yaw ; if ( yaw < - 180 ) yaw += 360 ; if ( yaw > 180 ) yaw -= 360 ; return [ pitch , yaw ] ; }
122	function onDocumentMouseMove ( event ) { if ( isUserInteracting && loaded ) { latestInteraction = Date . now ( ) ; var canvas = renderer . getCanvas ( ) ; var canvasWidth = canvas . clientWidth , canvasHeight = canvas . clientHeight ; var pos = mousePosition ( event ) ; var yaw = ( ( Math . atan ( onPointerDownPointerX / canvasWidth * 2 - 1 ) - Math . atan ( pos . x / canvasWidth * 2 - 1 ) ) * 180 / Math . PI * config . hfov / 90 ) + onPointerDownYaw ; speed . yaw = ( yaw - config . yaw ) % 360 * 0.2 ; config . yaw = yaw ; var vfov = 2 * Math . atan ( Math . tan ( config . hfov / 360 * Math . PI ) * canvasHeight / canvasWidth ) * 180 / Math . PI ; var pitch = ( ( Math . atan ( pos . y / canvasHeight * 2 - 1 ) - Math . atan ( onPointerDownPointerY / canvasHeight * 2 - 1 ) ) * 180 / Math . PI * vfov / 90 ) + onPointerDownPitch ; speed . pitch = ( pitch - config . pitch ) * 0.2 ; config . pitch = pitch ; } }
123	function onDocumentMouseUp ( event ) { if ( ! isUserInteracting ) { return ; } isUserInteracting = false ; if ( Date . now ( ) - latestInteraction > 15 ) { speed . pitch = speed . yaw = 0 ; } uiContainer . classList . add ( 'pnlm-grab' ) ; uiContainer . classList . remove ( 'pnlm-grabbing' ) ; latestInteraction = Date . now ( ) ; fireEvent ( 'mouseup' , event ) ; }
124	function onDocumentTouchStart ( event ) { if ( ! loaded || ! config . draggable ) { return ; } stopAnimation ( ) ; stopOrientation ( ) ; config . roll = 0 ; speed . hfov = 0 ; var pos0 = mousePosition ( event . targetTouches [ 0 ] ) ; onPointerDownPointerX = pos0 . x ; onPointerDownPointerY = pos0 . y ; if ( event . targetTouches . length == 2 ) { var pos1 = mousePosition ( event . targetTouches [ 1 ] ) ; onPointerDownPointerX += ( pos1 . x - pos0 . x ) * 0.5 ; onPointerDownPointerY += ( pos1 . y - pos0 . y ) * 0.5 ; onPointerDownPointerDist = Math . sqrt ( ( pos0 . x - pos1 . x ) * ( pos0 . x - pos1 . x ) + ( pos0 . y - pos1 . y ) * ( pos0 . y - pos1 . y ) ) ; } isUserInteracting = true ; latestInteraction = Date . now ( ) ; onPointerDownYaw = config . yaw ; onPointerDownPitch = config . pitch ; fireEvent ( 'touchstart' , event ) ; animateInit ( ) ; }
125	function onDocumentTouchMove ( event ) { if ( ! config . draggable ) { return ; } event . preventDefault ( ) ; if ( loaded ) { latestInteraction = Date . now ( ) ; } if ( isUserInteracting && loaded ) { var pos0 = mousePosition ( event . targetTouches [ 0 ] ) ; var clientX = pos0 . x ; var clientY = pos0 . y ; if ( event . targetTouches . length == 2 && onPointerDownPointerDist != - 1 ) { var pos1 = mousePosition ( event . targetTouches [ 1 ] ) ; clientX += ( pos1 . x - pos0 . x ) * 0.5 ; clientY += ( pos1 . y - pos0 . y ) * 0.5 ; var clientDist = Math . sqrt ( ( pos0 . x - pos1 . x ) * ( pos0 . x - pos1 . x ) + ( pos0 . y - pos1 . y ) * ( pos0 . y - pos1 . y ) ) ; setHfov ( config . hfov + ( onPointerDownPointerDist - clientDist ) * 0.1 ) ; onPointerDownPointerDist = clientDist ; } var touchmovePanSpeedCoeff = ( config . hfov / 360 ) * config . touchPanSpeedCoeffFactor ; var yaw = ( onPointerDownPointerX - clientX ) * touchmovePanSpeedCoeff + onPointerDownYaw ; speed . yaw = ( yaw - config . yaw ) % 360 * 0.2 ; config . yaw = yaw ; var pitch = ( clientY - onPointerDownPointerY ) * touchmovePanSpeedCoeff + onPointerDownPitch ; speed . pitch = ( pitch - config . pitch ) * 0.2 ; config . pitch = pitch ; } }
126	function onDocumentMouseWheel ( event ) { if ( ! loaded || ( config . mouseZoom == 'fullscreenonly' && ! fullscreenActive ) ) { return ; } event . preventDefault ( ) ; stopAnimation ( ) ; latestInteraction = Date . now ( ) ; if ( event . wheelDeltaY ) { setHfov ( config . hfov - event . wheelDeltaY * 0.05 ) ; speed . hfov = event . wheelDelta < 0 ? 1 : - 1 ; } else if ( event . wheelDelta ) { setHfov ( config . hfov - event . wheelDelta * 0.05 ) ; speed . hfov = event . wheelDelta < 0 ? 1 : - 1 ; } else if ( event . detail ) { setHfov ( config . hfov + event . detail * 1.5 ) ; speed . hfov = event . detail > 0 ? 1 : - 1 ; } animateInit ( ) ; }
127	function onDocumentKeyPress ( event ) { stopAnimation ( ) ; latestInteraction = Date . now ( ) ; stopOrientation ( ) ; config . roll = 0 ; var keynumber = event . which || event . keycode ; if ( config . capturedKeyNumbers . indexOf ( keynumber ) < 0 ) return ; event . preventDefault ( ) ; if ( keynumber == 27 ) { if ( fullscreenActive ) { toggleFullscreen ( ) ; } } else { changeKey ( keynumber , true ) ; } }
128	function onDocumentKeyUp ( event ) { var keynumber = event . which || event . keycode ; if ( config . capturedKeyNumbers . indexOf ( keynumber ) < 0 ) return ; event . preventDefault ( ) ; changeKey ( keynumber , false ) ; }
129	function changeKey ( keynumber , value ) { var keyChanged = false ; switch ( keynumber ) { case 109 : case 189 : case 17 : case 173 : if ( keysDown [ 0 ] != value ) { keyChanged = true ; } keysDown [ 0 ] = value ; break ; case 107 : case 187 : case 16 : case 61 : if ( keysDown [ 1 ] != value ) { keyChanged = true ; } keysDown [ 1 ] = value ; break ; case 38 : if ( keysDown [ 2 ] != value ) { keyChanged = true ; } keysDown [ 2 ] = value ; break ; case 87 : if ( keysDown [ 6 ] != value ) { keyChanged = true ; } keysDown [ 6 ] = value ; break ; case 40 : if ( keysDown [ 3 ] != value ) { keyChanged = true ; } keysDown [ 3 ] = value ; break ; case 83 : if ( keysDown [ 7 ] != value ) { keyChanged = true ; } keysDown [ 7 ] = value ; break ; case 37 : if ( keysDown [ 4 ] != value ) { keyChanged = true ; } keysDown [ 4 ] = value ; break ; case 65 : if ( keysDown [ 8 ] != value ) { keyChanged = true ; } keysDown [ 8 ] = value ; break ; case 39 : if ( keysDown [ 5 ] != value ) { keyChanged = true ; } keysDown [ 5 ] = value ; break ; case 68 : if ( keysDown [ 9 ] != value ) { keyChanged = true ; } keysDown [ 9 ] = value ; } if ( keyChanged && value ) { if ( typeof performance !== 'undefined' && performance . now ( ) ) { prevTime = performance . now ( ) ; } else { prevTime = Date . now ( ) ; } animateInit ( ) ; } }
130	function animateMove ( axis ) { var t = animatedMove [ axis ] ; var normTime = Math . min ( 1 , Math . max ( ( Date . now ( ) - t . startTime ) / 1000 / ( t . duration / 1000 ) , 0 ) ) ; var result = t . startPosition + config . animationTimingFunction ( normTime ) * ( t . endPosition - t . startPosition ) ; if ( ( t . endPosition > t . startPosition && result >= t . endPosition ) || ( t . endPosition < t . startPosition && result <= t . endPosition ) || t . endPosition === t . startPosition ) { result = t . endPosition ; speed [ axis ] = 0 ; delete animatedMove [ axis ] ; } config [ axis ] = result ; }
131	function animate ( ) { render ( ) ; if ( autoRotateStart ) clearTimeout ( autoRotateStart ) ; if ( isUserInteracting || orientation === true ) { requestAnimationFrame ( animate ) ; } else if ( keysDown [ 0 ] || keysDown [ 1 ] || keysDown [ 2 ] || keysDown [ 3 ] || keysDown [ 4 ] || keysDown [ 5 ] || keysDown [ 6 ] || keysDown [ 7 ] || keysDown [ 8 ] || keysDown [ 9 ] || config . autoRotate || animatedMove . pitch || animatedMove . yaw || animatedMove . hfov || Math . abs ( speed . yaw ) > 0.01 || Math . abs ( speed . pitch ) > 0.01 || Math . abs ( speed . hfov ) > 0.01 ) { keyRepeat ( ) ; if ( config . autoRotateInactivityDelay >= 0 && autoRotateSpeed && Date . now ( ) - latestInteraction > config . autoRotateInactivityDelay && ! config . autoRotate ) { config . autoRotate = autoRotateSpeed ; _this . lookAt ( origPitch , undefined , origHfov , 3000 ) ; } requestAnimationFrame ( animate ) ; } else if ( renderer && ( renderer . isLoading ( ) || ( config . dynamic === true && update ) ) ) { requestAnimationFrame ( animate ) ; } else { fireEvent ( 'animatefinished' , { pitch : _this . getPitch ( ) , yaw : _this . getYaw ( ) , hfov : _this . getHfov ( ) } ) ; animating = false ; prevTime = undefined ; var autoRotateStartTime = config . autoRotateInactivityDelay - ( Date . now ( ) - latestInteraction ) ; if ( autoRotateStartTime > 0 ) { autoRotateStart = setTimeout ( function ( ) { config . autoRotate = autoRotateSpeed ; _this . lookAt ( origPitch , undefined , origHfov , 3000 ) ; animateInit ( ) ; } , autoRotateStartTime ) ; } else if ( config . autoRotateInactivityDelay >= 0 && autoRotateSpeed ) { config . autoRotate = autoRotateSpeed ; _this . lookAt ( origPitch , undefined , origHfov , 3000 ) ; animateInit ( ) ; } } }
132	function taitBryanToQuaternion ( alpha , beta , gamma ) { var r = [ beta ? beta * Math . PI / 180 / 2 : 0 , gamma ? gamma * Math . PI / 180 / 2 : 0 , alpha ? alpha * Math . PI / 180 / 2 : 0 ] ; var c = [ Math . cos ( r [ 0 ] ) , Math . cos ( r [ 1 ] ) , Math . cos ( r [ 2 ] ) ] , s = [ Math . sin ( r [ 0 ] ) , Math . sin ( r [ 1 ] ) , Math . sin ( r [ 2 ] ) ] ; return new Quaternion ( c [ 0 ] * c [ 1 ] * c [ 2 ] - s [ 0 ] * s [ 1 ] * s [ 2 ] , s [ 0 ] * c [ 1 ] * c [ 2 ] - c [ 0 ] * s [ 1 ] * s [ 2 ] , c [ 0 ] * s [ 1 ] * c [ 2 ] + s [ 0 ] * c [ 1 ] * s [ 2 ] , c [ 0 ] * c [ 1 ] * s [ 2 ] + s [ 0 ] * s [ 1 ] * c [ 2 ] ) ; }
133	function computeQuaternion ( alpha , beta , gamma ) { var quaternion = taitBryanToQuaternion ( alpha , beta , gamma ) ; quaternion = quaternion . multiply ( new Quaternion ( Math . sqrt ( 0.5 ) , - Math . sqrt ( 0.5 ) , 0 , 0 ) ) ; var angle = window . orientation ? - window . orientation * Math . PI / 180 / 2 : 0 ; return quaternion . multiply ( new Quaternion ( Math . cos ( angle ) , 0 , - Math . sin ( angle ) , 0 ) ) ; }
134	function orientationListener ( e ) { var q = computeQuaternion ( e . alpha , e . beta , e . gamma ) . toEulerAngles ( ) ; if ( typeof ( orientation ) == 'number' && orientation < 10 ) { orientation += 1 ; } else if ( orientation === 10 ) { orientationYawOffset = q [ 2 ] / Math . PI * 180 + config . yaw ; orientation = true ; requestAnimationFrame ( animate ) ; } else { config . pitch = q [ 0 ] / Math . PI * 180 ; config . roll = - q [ 1 ] / Math . PI * 180 ; config . yaw = - q [ 2 ] / Math . PI * 180 + orientationYawOffset ; } }
135	function renderInit ( ) { try { var params = { } ; if ( config . horizonPitch !== undefined ) params . horizonPitch = config . horizonPitch * Math . PI / 180 ; if ( config . horizonRoll !== undefined ) params . horizonRoll = config . horizonRoll * Math . PI / 180 ; if ( config . backgroundColor !== undefined ) params . backgroundColor = config . backgroundColor ; renderer . init ( panoImage , config . type , config . dynamic , config . haov * Math . PI / 180 , config . vaov * Math . PI / 180 , config . vOffset * Math . PI / 180 , renderInitCallback , params ) ; if ( config . dynamic !== true ) { panoImage = undefined ; } } catch ( event ) { if ( event . type == 'webgl error' || event . type == 'no webgl' ) { anError ( ) ; } else if ( event . type == 'webgl size error' ) { anError ( config . strings . textureSizeError . replace ( '%s' , event . width ) . replace ( '%s' , event . maxWidth ) ) ; } else { anError ( config . strings . unknownError ) ; throw event ; } } }
136	function renderInitCallback ( ) { if ( config . sceneFadeDuration && renderer . fadeImg !== undefined ) { renderer . fadeImg . style . opacity = 0 ; var fadeImg = renderer . fadeImg ; delete renderer . fadeImg ; setTimeout ( function ( ) { renderContainer . removeChild ( fadeImg ) ; fireEvent ( 'scenechangefadedone' ) ; } , config . sceneFadeDuration ) ; } if ( config . compass ) { compass . style . display = 'inline' ; } else { compass . style . display = 'none' ; } createHotSpots ( ) ; infoDisplay . load . box . style . display = 'none' ; if ( preview !== undefined ) { renderContainer . removeChild ( preview ) ; preview = undefined ; } loaded = true ; fireEvent ( 'load' ) ; animateInit ( ) ; }
137	function createHotSpots ( ) { if ( hotspotsCreated ) return ; if ( ! config . hotSpots ) { config . hotSpots = [ ] ; } else { config . hotSpots = config . hotSpots . sort ( function ( a , b ) { return a . pitch < b . pitch ; } ) ; config . hotSpots . forEach ( createHotSpot ) ; } hotspotsCreated = true ; renderHotSpots ( ) ; }
138	function destroyHotSpots ( ) { var hs = config . hotSpots ; hotspotsCreated = false ; delete config . hotSpots ; if ( hs ) { for ( var i = 0 ; i < hs . length ; i ++ ) { var current = hs [ i ] . div ; if ( current ) { while ( current . parentNode && current . parentNode != renderContainer ) { current = current . parentNode ; } renderContainer . removeChild ( current ) ; } delete hs [ i ] . div ; } } }
139	function renderHotSpot ( hs ) { var hsPitchSin = Math . sin ( hs . pitch * Math . PI / 180 ) , hsPitchCos = Math . cos ( hs . pitch * Math . PI / 180 ) , configPitchSin = Math . sin ( config . pitch * Math . PI / 180 ) , configPitchCos = Math . cos ( config . pitch * Math . PI / 180 ) , yawCos = Math . cos ( ( - hs . yaw + config . yaw ) * Math . PI / 180 ) ; var z = hsPitchSin * configPitchSin + hsPitchCos * yawCos * configPitchCos ; if ( ( hs . yaw <= 90 && hs . yaw > - 90 && z <= 0 ) || ( ( hs . yaw > 90 || hs . yaw <= - 90 ) && z <= 0 ) ) { hs . div . style . visibility = 'hidden' ; } else { var yawSin = Math . sin ( ( - hs . yaw + config . yaw ) * Math . PI / 180 ) , hfovTan = Math . tan ( config . hfov * Math . PI / 360 ) ; hs . div . style . visibility = 'visible' ; var canvas = renderer . getCanvas ( ) , canvasWidth = canvas . clientWidth , canvasHeight = canvas . clientHeight ; var coord = [ - canvasWidth / hfovTan * yawSin * hsPitchCos / z / 2 , - canvasWidth / hfovTan * ( hsPitchSin * configPitchCos - hsPitchCos * yawCos * configPitchSin ) / z / 2 ] ; var rollSin = Math . sin ( config . roll * Math . PI / 180 ) , rollCos = Math . cos ( config . roll * Math . PI / 180 ) ; coord = [ coord [ 0 ] * rollCos - coord [ 1 ] * rollSin , coord [ 0 ] * rollSin + coord [ 1 ] * rollCos ] ; coord [ 0 ] += ( canvasWidth - hs . div . offsetWidth ) / 2 ; coord [ 1 ] += ( canvasHeight - hs . div . offsetHeight ) / 2 ; var transform = 'translate(' + coord [ 0 ] + 'px, ' + coord [ 1 ] + 'px) translateZ(9999px) rotate(' + config . roll + 'deg)' ; hs . div . style . webkitTransform = transform ; hs . div . style . MozTransform = transform ; hs . div . style . transform = transform ; } }
140	function mergeConfig ( sceneId ) { config = { } ; var k , s ; var photoSphereExcludes = [ 'haov' , 'vaov' , 'vOffset' , 'northOffset' , 'horizonPitch' , 'horizonRoll' ] ; specifiedPhotoSphereExcludes = [ ] ; for ( k in defaultConfig ) { if ( defaultConfig . hasOwnProperty ( k ) ) { config [ k ] = defaultConfig [ k ] ; } } for ( k in initialConfig . default ) { if ( initialConfig . default . hasOwnProperty ( k ) ) { if ( k == 'strings' ) { for ( s in initialConfig . default . strings ) { if ( initialConfig . default . strings . hasOwnProperty ( s ) ) { config . strings [ s ] = escapeHTML ( initialConfig . default . strings [ s ] ) ; } } } else { config [ k ] = initialConfig . default [ k ] ; if ( photoSphereExcludes . indexOf ( k ) >= 0 ) { specifiedPhotoSphereExcludes . push ( k ) ; } } } } if ( ( sceneId !== null ) && ( sceneId !== '' ) && ( initialConfig . scenes ) && ( initialConfig . scenes [ sceneId ] ) ) { var scene = initialConfig . scenes [ sceneId ] ; for ( k in scene ) { if ( scene . hasOwnProperty ( k ) ) { if ( k == 'strings' ) { for ( s in scene . strings ) { if ( scene . strings . hasOwnProperty ( s ) ) { config . strings [ s ] = escapeHTML ( scene . strings [ s ] ) ; } } } else { config [ k ] = scene [ k ] ; if ( photoSphereExcludes . indexOf ( k ) >= 0 ) { specifiedPhotoSphereExcludes . push ( k ) ; } } } } config . scene = sceneId ; } for ( k in initialConfig ) { if ( initialConfig . hasOwnProperty ( k ) ) { if ( k == 'strings' ) { for ( s in initialConfig . strings ) { if ( initialConfig . strings . hasOwnProperty ( s ) ) { config . strings [ s ] = escapeHTML ( initialConfig . strings [ s ] ) ; } } } else { config [ k ] = initialConfig [ k ] ; if ( photoSphereExcludes . indexOf ( k ) >= 0 ) { specifiedPhotoSphereExcludes . push ( k ) ; } } } } }
141	function toggleFullscreen ( ) { if ( loaded && ! error ) { if ( ! fullscreenActive ) { try { if ( container . requestFullscreen ) { container . requestFullscreen ( ) ; } else if ( container . mozRequestFullScreen ) { container . mozRequestFullScreen ( ) ; } else if ( container . msRequestFullscreen ) { container . msRequestFullscreen ( ) ; } else { container . webkitRequestFullScreen ( ) ; } } catch ( event ) { } } else { if ( document . exitFullscreen ) { document . exitFullscreen ( ) ; } else if ( document . mozCancelFullScreen ) { document . mozCancelFullScreen ( ) ; } else if ( document . webkitCancelFullScreen ) { document . webkitCancelFullScreen ( ) ; } else if ( document . msExitFullscreen ) { document . msExitFullscreen ( ) ; } } } }
142	function onFullScreenChange ( resize ) { if ( document . fullscreenElement || document . fullscreen || document . mozFullScreen || document . webkitIsFullScreen || document . msFullscreenElement ) { controls . fullscreen . classList . add ( 'pnlm-fullscreen-toggle-button-active' ) ; fullscreenActive = true ; } else { controls . fullscreen . classList . remove ( 'pnlm-fullscreen-toggle-button-active' ) ; fullscreenActive = false ; } if ( resize !== 'resize' ) fireEvent ( 'fullscreenchange' , fullscreenActive ) ; renderer . resize ( ) ; setHfov ( config . hfov ) ; animateInit ( ) ; }
143	function constrainHfov ( hfov ) { var minHfov = config . minHfov ; if ( config . type == 'multires' && renderer && config . multiResMinHfov ) { minHfov = Math . min ( minHfov , renderer . getCanvas ( ) . width / ( config . multiRes . cubeResolution / 90 * 0.9 ) ) ; } if ( minHfov > config . maxHfov ) { console . log ( 'HFOV bounds do not make sense (minHfov > maxHfov).' ) return config . hfov ; } var newHfov = config . hfov ; if ( hfov < minHfov ) { newHfov = minHfov ; } else if ( hfov > config . maxHfov ) { newHfov = config . maxHfov ; } else { newHfov = hfov ; } if ( config . avoidShowingBackground && renderer ) { var canvas = renderer . getCanvas ( ) ; newHfov = Math . min ( newHfov , Math . atan ( Math . tan ( ( config . maxPitch - config . minPitch ) / 360 * Math . PI ) / canvas . height * canvas . width ) * 360 / Math . PI ) ; } return newHfov ; }
144	function stopAnimation ( ) { animatedMove = { } ; autoRotateSpeed = config . autoRotate ? config . autoRotate : autoRotateSpeed ; config . autoRotate = false ; }
145	function load ( ) { clearError ( ) ; loaded = false ; controls . load . style . display = 'none' ; infoDisplay . load . box . style . display = 'inline' ; init ( ) ; }
146	function loadScene ( sceneId , targetPitch , targetYaw , targetHfov , fadeDone ) { loaded = false ; animatedMove = { } ; var fadeImg , workingPitch , workingYaw , workingHfov ; if ( config . sceneFadeDuration && ! fadeDone ) { var data = renderer . render ( config . pitch * Math . PI / 180 , config . yaw * Math . PI / 180 , config . hfov * Math . PI / 180 , { returnImage : true } ) ; if ( data !== undefined ) { fadeImg = new Image ( ) ; fadeImg . className = 'pnlm-fade-img' ; fadeImg . style . transition = 'opacity ' + ( config . sceneFadeDuration / 1000 ) + 's' ; fadeImg . style . width = '100%' ; fadeImg . style . height = '100%' ; fadeImg . onload = function ( ) { loadScene ( sceneId , targetPitch , targetYaw , targetHfov , true ) ; } ; fadeImg . src = data ; renderContainer . appendChild ( fadeImg ) ; renderer . fadeImg = fadeImg ; return ; } } if ( targetPitch === 'same' ) { workingPitch = config . pitch ; } else { workingPitch = targetPitch ; } if ( targetYaw === 'same' ) { workingYaw = config . yaw ; } else if ( targetYaw === 'sameAzimuth' ) { workingYaw = config . yaw + ( config . northOffset || 0 ) - ( initialConfig . scenes [ sceneId ] . northOffset || 0 ) ; } else { workingYaw = targetYaw ; } if ( targetHfov === 'same' ) { workingHfov = config . hfov ; } else { workingHfov = targetHfov ; } destroyHotSpots ( ) ; mergeConfig ( sceneId ) ; speed . yaw = speed . pitch = speed . hfov = 0 ; processOptions ( ) ; if ( workingPitch !== undefined ) { config . pitch = workingPitch ; } if ( workingYaw !== undefined ) { config . yaw = workingYaw ; } if ( workingHfov !== undefined ) { config . hfov = workingHfov ; } fireEvent ( 'scenechange' , sceneId ) ; load ( ) ; update = config . dynamicUpdate === true ; if ( config . dynamic ) { panoImage = config . panorama ; onImageLoad ( ) ; } }
147	function stopOrientation ( ) { window . removeEventListener ( 'deviceorientation' , orientationListener ) ; controls . orientation . classList . remove ( 'pnlm-orientation-button-active' ) ; orientation = false ; }
148	function fireEvent ( type ) { if ( type in externalEventListeners ) { for ( var i = externalEventListeners [ type ] . length ; i > 0 ; i -- ) { externalEventListeners [ type ] [ externalEventListeners [ type ] . length - i ] . apply ( null , [ ] . slice . call ( arguments , 1 ) ) ; } } }
149	function ( latchFunction , optional_timeoutMessage , optional_timeout ) { jasmine . getEnv ( ) . currentSpec . waitsFor . apply ( jasmine . getEnv ( ) . currentSpec , arguments ) ; }
150	function $getMouseOffset ( target , ev ) { ev = ev || _window . event ; var docPos = $getPosition ( target ) ; var mousePos = $mouseCoords ( ev ) ; return { x : mousePos . x - docPos . x , y : mousePos . y - docPos . y } ; }
151	function ( val , flags ) { number_check ( val ) if ( ! flags . precision ) { if ( ! flags . decimal_point ) { flags . precision = 6 } else { flags . precision = 0 } } else { flags . precision = parseInt ( flags . precision , 10 ) validate_precision ( flags . precision ) } return parseFloat ( val ) }
152	function ( self , other ) { if ( _b_ . isinstance ( other , int ) ) { if ( other . __class__ === $B . long_int ) { return $B . long_int . __sub__ ( $B . long_int . $factory ( self ) , $B . long_int . $factory ( other ) ) } other = int_value ( other ) if ( self > $B . max_int32 || self < $B . min_int32 || other > $B . max_int32 || other < $B . min_int32 ) { return $B . long_int . __sub__ ( $B . long_int . $factory ( self ) , $B . long_int . $factory ( other ) ) } return self - other } if ( _b_ . isinstance ( other , _b_ . bool ) ) { return self - other } var rsub = $B . $getattr ( other , "__rsub__" , _b_ . None ) if ( rsub !== _b_ . None ) { return rsub ( self ) } $err ( "-" , other ) }
153	function ( self , other ) { if ( _b_ . isinstance ( other , int ) ) { other = int_value ( other ) if ( typeof other == "number" ) { var res = self . valueOf ( ) - other . valueOf ( ) if ( res > $B . min_int && res < $B . max_int ) { return res } else { return $B . long_int . __sub__ ( $B . long_int . $factory ( self ) , $B . long_int . $factory ( other ) ) } } else if ( typeof other == "boolean" ) { return other ? self - 1 : self } else { return $B . long_int . __sub__ ( $B . long_int . $factory ( self ) , $B . long_int . $factory ( other ) ) } } if ( _b_ . isinstance ( other , _b_ . float ) ) { return new Number ( self - other ) } if ( _b_ . isinstance ( other , _b_ . complex ) ) { return $B . make_complex ( self - other . $real , - other . $imag ) } if ( _b_ . isinstance ( other , _b_ . bool ) ) { var bool_value = 0 ; if ( other . valueOf ( ) ) { bool_value = 1 } return self - bool_value } if ( _b_ . isinstance ( other , _b_ . complex ) ) { return $B . make_complex ( self . valueOf ( ) - other . $real , other . $imag ) } var rsub = $B . $getattr ( other , "__rsub__" , _b_ . None ) if ( rsub !== _b_ . None ) { return rsub ( self ) } throw $err ( "-" , other ) }
154	function inlineResourcesFromString ( content , urlResolver ) { return [ inlineTemplate , inlineStyle , removeModuleId ] . reduce ( ( content , fn ) => fn ( content , urlResolver ) , content ) ; }
155	function buildSass ( content , sourceFile ) { try { const result = sass . renderSync ( { data : content , file : sourceFile , importer : tildeImporter } ) ; return result . css . toString ( ) } catch ( e ) { console . error ( '\x1b[41m' ) ; \x1b console . error ( 'at ' + sourceFile + ':' + e . line + ":" + e . column ) ; console . error ( e . formatted ) ; console . error ( '\x1b[0m' ) ; } }
156	function FormioResourceRoutes ( config ) { config = config || { } ; return [ { path : '' , component : config . index || index_component_1 . FormioResourceIndexComponent } , { path : 'new' , component : config . create || create_component_1 . FormioResourceCreateComponent } , { path : ':id' , component : config . resource || resource_component_1 . FormioResourceComponent , children : [ { path : '' , redirectTo : 'view' , pathMatch : 'full' } , { path : 'view' , component : config . view || view_component_1 . FormioResourceViewComponent } , { path : 'edit' , component : config . edit || edit_component_1 . FormioResourceEditComponent } , { path : 'delete' , component : config . delete || delete_component_1 . FormioResourceDeleteComponent } ] } ] ; }
157	function BaseProducer ( client , options , defaultPartitionerType , customPartitioner ) { EventEmitter . call ( this ) ; options = options || { } ; this . ready = false ; this . client = client ; this . requireAcks = options . requireAcks === undefined ? DEFAULTS . requireAcks : options . requireAcks ; this . ackTimeoutMs = options . ackTimeoutMs === undefined ? DEFAULTS . ackTimeoutMs : options . ackTimeoutMs ; if ( customPartitioner !== undefined && options . partitionerType !== PARTITIONER_TYPES . custom ) { throw new Error ( 'Partitioner Type must be custom if providing a customPartitioner.' ) ; } else if ( customPartitioner === undefined && options . partitionerType === PARTITIONER_TYPES . custom ) { throw new Error ( 'No customer partitioner defined' ) ; } var partitionerType = PARTITIONER_MAP [ options . partitionerType ] || PARTITIONER_MAP [ defaultPartitionerType ] ; this . partitioner = new partitionerType ( customPartitioner ) ; this . connect ( ) ; }
158	function Context ( options ) { if ( ! options ) options = { body : '' , hostname : '' } ; const body = options . body ; const href = 'http://' + options . hostname + '/' ; const cache = Object . create ( null ) ; const keys = [ ] ; this . atob = function ( str ) { return Buffer . from ( str , 'base64' ) . toString ( 'binary' ) ; } ; this . location = { reload : function ( ) { } } ; this . document = { createElement : function ( ) { return { firstChild : { href : href } } ; } , getElementById : function ( id ) { if ( keys . indexOf ( id ) === - 1 ) { const re = new RegExp ( ' id=[\'"]?' + \' + id ) ; '[^>]*>([^<]*)' const match = body . match ( re ) ; keys . push ( id ) ; } cache [ id ] = match === null ? match : { innerHTML : match [ 1 ] } ; } } ; }
159	function alternative ( options , { captcha : { url , siteKey } } ) { console . error ( 'The url is "' + url + '"' ) ; console . error ( 'The site key is "' + siteKey + '"' ) ; return Promise . reject ( new Error ( 'This is a dummy function' ) ) ; }
160	function performRequest ( options , isFirstRequest ) { const requester = options . requester ; const request = requester ( options ) ; if ( request . getHeader ( 'host' ) === HOST ) { request . setHeader ( 'host' , request . uri . host ) ; } if ( typeof request . callback !== 'function' ) { throw new TypeError ( 'Expected a callback function, got ' + typeof ( request . callback ) + ' instead.' ) ; } if ( isFirstRequest ) { options . callback = request . callback ; } request . removeAllListeners ( 'error' ) . once ( 'error' , function ( error ) { onRequestResponse ( options , error ) ; } ) ; request . removeAllListeners ( 'complete' ) . once ( 'complete' , function ( response , body ) { onRequestResponse ( options , null , response , body ) ; } ) ; request . cloudscraper = true ; return request ; }
161	function onRequestResponse ( options , error , response , body ) { const callback = options . callback ; if ( error || ! body || ! body . toString ) { return callback ( new RequestError ( error , options , response ) ) ; } response . responseStartTime = Date . now ( ) ; response . isCloudflare = / ^cloudflare / i . test ( '' + response . caseless . get ( 'server' ) ) ; response . isHTML = / text\/html / i . test ( '' + response . caseless . get ( 'content-type' ) ) ; if ( ! Buffer . isBuffer ( body ) ) { return callback ( null , response , body ) ; } if ( / \bbr\b / i . test ( '' + response . caseless . get ( 'content-encoding' ) ) ) { if ( ! brotli . isAvailable ) { const cause = 'Received a Brotli compressed response. Please install brotli' ; return callback ( new RequestError ( cause , options , response ) ) ; } response . body = body = brotli . decompress ( body ) ; } if ( response . isCloudflare && response . isHTML ) { onCloudflareResponse ( options , response , body ) ; } else { onRequestComplete ( options , response , body ) ; } }
162	function onCaptcha ( options , response , body ) { const callback = options . callback ; const handler = options . onCaptcha ; const payload = { } ; let cause ; let match ; match = body . match ( / <form(?: [^<>]*)? id=["']?challenge-form['"]?(?: [^<>]*)?>([\S\s]*?)<\/form> / ) ; if ( ! match ) { cause = 'Challenge form extraction failed' ; return callback ( new ParserError ( cause , options , response ) ) ; } const form = response . challengeForm = match [ 1 ] ; match = form . match ( / \/recaptcha\/api\/fallback\?k=([^\s"'<>]*) / ) ; if ( ! match ) { match = body . match ( / data-sitekey=["']?([^\s"'<>]*) / ) ; if ( ! match ) { cause = 'Unable to find the reCAPTCHA site key' ; return callback ( new ParserError ( cause , options , response ) ) ; } } response . captcha = { url : response . request . uri . href , siteKey : match [ 1 ] , form : payload } ; match = form . match ( / <input(?: [^<>]*)? name=[^<>]+> / g ) ; if ( ! match ) { cause = 'Challenge form is missing inputs' ; return callback ( new ParserError ( cause , options , response ) ) ; } const inputs = match ; for ( let name , value , i = 0 ; i < inputs . length ; i ++ ) { name = inputs [ i ] . match ( / name=["']?([^\s"'<>]*) / ) ; if ( name ) { value = inputs [ i ] . match ( / value=["']?([^\s"'<>]*) / ) ; if ( value ) { payload [ name [ 1 ] ] = value [ 1 ] ; } } } if ( ! payload [ 's' ] ) { cause = 'Challenge form is missing secret input' ; return callback ( new ParserError ( cause , options , response ) ) ; } const submit = function ( error ) { if ( error ) { return callback ( new CaptchaError ( error , options , response ) ) ; } onSubmitCaptcha ( options , response , body ) ; } ; response . captcha . submit = submit ; const thenable = handler ( options , response , body ) ; if ( thenable && typeof thenable . then === 'function' ) { thenable . then ( submit , function ( error ) { if ( ! error ) { submit ( new Error ( 'Falsy error' ) ) ; } else { submit ( error ) ; } } ) ; } }
163	function ( error ) { if ( error ) { return callback ( new CaptchaError ( error , options , response ) ) ; } onSubmitCaptcha ( options , response , body ) ; }
164	function assets ( userOptions = { } ) { const options = { ... defaults , ... userOptions , } ; return ( files , metalsmith , cb ) => { const src = metalsmith . path ( options . source ) ; const dest = options . destination ; readdir ( src , ( readDirError , arr ) => { if ( readDirError ) { cb ( readDirError ) ; return ; } each ( arr , read , err => cb ( err , files ) ) ; } ) ; function read ( file , done ) { const name = path . join ( dest , path . relative ( src , file ) ) ; fs . stat ( file , ( statError , stats ) => { if ( statError ) { done ( statError ) ; return ; } fs . readFile ( file , ( err , buffer ) => { if ( err ) { done ( err ) ; return ; } const newFile = { } ; newFile . contents = buffer ; newFile . stats = stats ; newFile . mode = mode ( stats ) . toOctal ( ) ; files [ name ] = newFile ; done ( ) ; } ) ; } ) ; } } ; }
165	function getStartStopBoundaries ( parent , sidebar , topOffset ) { const bbox = parent . getBoundingClientRect ( ) ; const sidebarBbox = sidebar . getBoundingClientRect ( ) ; const bodyBbox = document . body . getBoundingClientRect ( ) ; const containerAbsoluteTop = bbox . top - bodyBbox . top ; const sidebarAbsoluteTop = sidebarBbox . top - bodyBbox . top ; const marginTop = sidebarAbsoluteTop - containerAbsoluteTop ; const start = containerAbsoluteTop - topOffset ; const stop = bbox . height + containerAbsoluteTop - sidebarBbox . height - marginTop - topOffset ; return { start , stop , } ; }
166	function around ( obj , method , fn ) { var old = obj [ method ] obj [ method ] = function ( ) { var args = new Array ( arguments . length ) for ( var i = 0 ; i < args . length ; i ++ ) args [ i ] = arguments [ i ] return fn . call ( this , old , args ) } }
167	function before ( obj , method , fn ) { var old = obj [ method ] obj [ method ] = function ( ) { fn . call ( this ) old . apply ( this , arguments ) } }
168	function copyTemplate ( from , to ) { write ( to , fs . readFileSync ( path . join ( TEMPLATE_DIR , from ) , 'utf-8' ) ) }
169	function copyTemplateMulti ( fromDir , toDir , nameGlob ) { fs . readdirSync ( path . join ( TEMPLATE_DIR , fromDir ) ) . filter ( minimatch . filter ( nameGlob , { matchBase : true } ) ) . forEach ( function ( name ) { copyTemplate ( path . join ( fromDir , name ) , path . join ( toDir , name ) ) } ) }
170	function createAppName ( pathName ) { return path . basename ( pathName ) . replace ( / [^A-Za-z0-9.-]+ / g , '-' ) . replace ( / ^[-_.]+|-+$ / g , '' ) . toLowerCase ( ) }
171	function emptyDirectory ( dir , fn ) { fs . readdir ( dir , function ( err , files ) { if ( err && err . code !== 'ENOENT' ) throw err fn ( ! files || ! files . length ) } ) }
172	function exit ( code ) { function done ( ) { if ( ! ( draining -- ) ) _exit ( code ) } var draining = 0 var streams = [ process . stdout , process . stderr ] exit . exited = true streams . forEach ( function ( stream ) { draining += 1 stream . write ( '' , done ) } ) done ( ) }
173	function loadTemplate ( name ) { var contents = fs . readFileSync ( path . join ( __dirname , '..' , 'templates' , ( name + '.ejs' ) ) , 'utf-8' ) var locals = Object . create ( null ) function render ( ) { return ejs . render ( contents , locals , { escape : util . inspect } ) } return { locals : locals , render : render } }
174	function main ( ) { var destinationPath = program . args . shift ( ) || '.' var appName = createAppName ( path . resolve ( destinationPath ) ) || 'hello-world' if ( program . view === true ) { if ( program . ejs ) program . view = 'ejs' if ( program . hbs ) program . view = 'hbs' if ( program . hogan ) program . view = 'hjs' if ( program . pug ) program . view = 'pug' } if ( program . view === true ) { warning ( 'the default view engine will not be jade in future releases\n' + \n ) "use `--view=jade' or `--help' for additional options" } program . view = 'jade' }
175	function mkdir ( base , dir ) { var loc = path . join ( base , dir ) console . log ( ' \x1b[36mcreate\x1b[0m : ' + \x1b + \x1b ) loc }
176	function renamedOption ( originalName , newName ) { return function ( val ) { warning ( util . format ( "option `%s' has been renamed to `%s'" , originalName , newName ) ) return val } }
177	function warning ( message ) { console . error ( ) message . split ( '\n' ) . \n forEach ( function ( line ) { console . error ( ' warning: %s' , line ) } ) }
178	function write ( file , str , mode ) { fs . writeFileSync ( file , str , { mode : mode || MODE_0666 } ) console . log ( ' \x1b[36mcreate\x1b[0m : ' + \x1b ) }
179	function bind_d3 ( f , context ) { return function ( ) { var args = [ this ] . concat ( [ ] . slice . call ( arguments ) ) f . apply ( context , args ) } }
180	function adjustOptions ( options ) { const directory = process . cwd ( ) ; const configPath = getWebpackConfigPath ( directory , options . config ) ; const haulOptions = getHaulConfig ( configPath , logger ) ; if ( haulOptions . platforms ) { const platformOption = command . options && command . options . find ( _ => _ . name === 'platform' ) ; if ( platformOption ) { platformOption . choices = [ ] ; for ( const platformName in haulOptions . platforms ) { if ( Object . prototype . hasOwnProperty . call ( haulOptions . platforms , platformName ) ) { if ( platformOption . choices ) { platformOption . choices . push ( { value : platformName , description : ` ${ haulOptions . platforms [ platformName ] } ` , } ) ; } } } } } }
181	function devToolsMiddleware ( debuggerProxy ) { return ( req , res , next ) => { switch ( req . cleanPath ) { case '/debugger-ui/' : case '/debugger-ui' : { const readStream = fs . createReadStream ( path . join ( __dirname , '../assets/debugger.html' ) ) ; res . writeHead ( 200 , { 'Content-Type' : 'text/html' } ) ; readStream . pipe ( res ) ; break ; } case '/debugger-ui/debuggerWorker.js' : case '/debuggerWorker.js' : { const readStream = fs . createReadStream ( path . join ( __dirname , '../assets/debuggerWorker.js' ) ) ; res . writeHead ( 200 , { 'Content-Type' : 'application/javascript' } ) ; readStream . pipe ( res ) ; break ; } case '/launch-js-devtools' : { if ( ! debuggerProxy . isDebuggerConnected ( ) ) { launchBrowser ( ` ${ req . socket . localPort } ` ) ; } res . end ( 'OK' ) ; break ; } default : next ( ) ; } } ; }
182	function onLoad ( event ) { event . demo . renderPass . camera = event . demo . camera ; document . getElementById ( "viewport" ) . children [ 0 ] . style . display = "none" ; }
183	function prefixSubstrings ( prefix , substrings , strings ) { let prefixed , regExp ; for ( const substring of substrings ) { prefixed = "$1" + prefix + substring . charAt ( 0 ) . toUpperCase ( ) + substring . slice ( 1 ) ; regExp = new RegExp ( "([^\\.])(\\b" + \\ + \\ , substring ) ; "\\b)" } }
184	function createCanvas ( width , height , data , channels ) { const canvas = document . createElementNS ( "http://www.w3.org/1999/xhtml" , "canvas" ) ; const context = canvas . getContext ( "2d" ) ; const imageData = context . createImageData ( width , height ) ; const target = imageData . data ; let x , y ; let i , j ; for ( y = 0 ; y < height ; ++ y ) { for ( x = 0 ; x < width ; ++ x ) { i = ( y * width + x ) * 4 ; j = ( y * width + x ) * channels ; target [ i ] = ( channels > 0 ) ? data [ j ] : 0 ; target [ i + 1 ] = ( channels > 1 ) ? data [ j + 1 ] : 0 ; target [ i + 2 ] = ( channels > 2 ) ? data [ j + 2 ] : 0 ; target [ i + 3 ] = ( channels > 3 ) ? data [ j + 3 ] : 255 ; } } canvas . width = width ; canvas . height = height ; context . putImageData ( imageData , 0 , 0 ) ; return canvas ; }
185	function smoothArea ( d , b ) { const a1 = b . min ; const a2 = b . max ; const b1X = Math . sqrt ( a1 . x * 2.0 ) * 0.5 ; const b1Y = Math . sqrt ( a1 . y * 2.0 ) * 0.5 ; const b2X = Math . sqrt ( a2 . x * 2.0 ) * 0.5 ; const b2Y = Math . sqrt ( a2 . y * 2.0 ) * 0.5 ; const p = saturate ( d / SMOOTH_MAX_DISTANCE ) ; a1 . set ( lerp ( b1X , a1 . x , p ) , lerp ( b1Y , a1 . y , p ) ) ; a2 . set ( lerp ( b2X , a2 . x , p ) , lerp ( b2Y , a2 . y , p ) ) ; return b ; }
186	function calculateDiagonalAreaForPixel ( p1 , p2 , pX , pY ) { let a ; let x , y ; let offsetX , offsetY ; for ( a = 0 , y = 0 ; y < DIAGONAL_SAMPLES ; ++ y ) { for ( x = 0 ; x < DIAGONAL_SAMPLES ; ++ x ) { offsetX = x / ( DIAGONAL_SAMPLES - 1.0 ) ; offsetY = y / ( DIAGONAL_SAMPLES - 1.0 ) ; if ( isInsideArea ( p1 , p2 , pX + offsetX , pY + offsetY ) ) { ++ a ; } } } return a / ( DIAGONAL_SAMPLES * DIAGONAL_SAMPLES ) ; }
187	function calculateDiagonalArea ( pattern , p1 , p2 , left , offset , result ) { const e = diagonalEdges [ pattern ] ; const e1 = e [ 0 ] ; const e2 = e [ 1 ] ; if ( e1 > 0 ) { p1 . x += offset [ 0 ] ; p1 . y += offset [ 1 ] ; } if ( e2 > 0 ) { p2 . x += offset [ 0 ] ; p2 . y += offset [ 1 ] ; } return result . set ( 1.0 - calculateDiagonalAreaForPixel ( p1 , p2 , 1.0 + left , 0.0 + left ) , calculateDiagonalAreaForPixel ( p1 , p2 , 1.0 + left , 1.0 + left ) ) ; }
188	function generatePatterns ( patterns , offset , orthogonal ) { const result = new Vector2 ( ) ; let i , l ; let x , y ; let c ; let pattern ; let data , size ; for ( i = 0 , l = patterns . length ; i < l ; ++ i ) { pattern = patterns [ i ] ; data = pattern . data ; size = pattern . width ; for ( y = 0 ; y < size ; ++ y ) { for ( x = 0 ; x < size ; ++ x ) { if ( orthogonal ) { calculateOrthogonalAreaForPattern ( i , x , y , offset , result ) ; } else { calculateDiagonalAreaForPattern ( i , x , y , offset , result ) ; } c = ( y * size + x ) * 2 ; data [ c ] = result . x * 255 ; data [ c + 1 ] = result . y * 255 ; } } } }
189	function assemble ( base , patterns , edges , size , orthogonal , target ) { const p = new Vector2 ( ) ; const dstData = target . data ; const dstWidth = target . width ; let i , l ; let x , y ; let c , d ; let edge ; let pattern ; let srcData , srcWidth ; for ( i = 0 , l = patterns . length ; i < l ; ++ i ) { edge = edges [ i ] ; pattern = patterns [ i ] ; srcData = pattern . data ; srcWidth = pattern . width ; for ( y = 0 ; y < size ; ++ y ) { for ( x = 0 ; x < size ; ++ x ) { p . fromArray ( edge ) . multiplyScalar ( size ) ; p . add ( base ) ; p . x += x ; p . y += y ; c = ( p . y * dstWidth + p . x ) * 2 ; d = orthogonal ? ( ( y * y * srcWidth + x * x ) * 2 ) : ( ( y * srcWidth + x ) * 2 ) ; dstData [ c ] = srcData [ d ] ; dstData [ c + 1 ] = srcData [ d + 1 ] ; } } } }
190	function deltaRight ( left , top ) { let d = 0 ; if ( top [ 3 ] === 1 && left [ 1 ] !== 1 && left [ 3 ] !== 1 ) { d += 1 ; } if ( d === 1 && top [ 2 ] === 1 && left [ 0 ] !== 1 && left [ 2 ] !== 1 ) { d += 1 ; } return d ; }
191	function bilinear ( e ) { const a = lerp ( e [ 0 ] , e [ 1 ] , 1.0 - 0.25 ) ; const b = lerp ( e [ 2 ] , e [ 3 ] , 1.0 - 0.25 ) ; return lerp ( a , b , 1.0 - 0.125 ) ; }
192	function checkForm ( that ) { var newValue = $ ( that ) . val ( ) var matches = newValue != '' ? newValue . match ( timeRegEx ) : '' var error = $ ( that ) . closest ( '.time-spinner' ) . find ( '.error_container' ) var $closerTimeSpinner = $ ( that ) . closest ( '.time-spinner' ) . find ( '.spinner-control' ) if ( matches ) { $ ( error ) . html ( '' ) return true } else { var errMsg = 'Formato data non valido' $ ( error ) . html ( errMsg ) return false } }
193	function resetToMove ( contextControl ) { var left = contextControl . find ( '.source .transfer-group' ) var right = contextControl . find ( '.target .transfer-group' ) var textLeft = contextControl . find ( '.source .transfer-header span.num' ) var textRight = contextControl . find ( '.target .transfer-header span.num' ) var header = contextControl . find ( '.transfer-header input' ) $ ( left ) . html ( elemLeft ) $ ( right ) . html ( elemRight ) $ ( textLeft ) . text ( elemLeftNum ) $ ( textRight ) . text ( elemRightNum ) $ ( header ) . prop ( 'disabled' , false ) }
194	function checkIfActive ( targetControl , targetHeaderControl , containerTypeControl , addButtonControl ) { $ ( targetControl ) . each ( function ( el ) { if ( $ ( this ) . prop ( 'checked' ) ) { if ( ! $ ( targetHeaderControl ) . hasClass ( 'semi-checked' ) ) { $ ( targetHeaderControl ) . addClass ( 'semi-checked' ) $ ( targetHeaderControl ) . prop ( 'checked' , false ) if ( containerTypeControl . hasClass ( 'source' ) ) { $ ( addButtonControl ) . addClass ( 'active' ) } if ( containerTypeControl . hasClass ( 'target' ) ) { $ ( inverseButton ) . addClass ( 'active' ) } } return false } else { $ ( targetHeaderControl ) . removeClass ( 'semi-checked' ) if ( containerTypeControl . hasClass ( 'source' ) ) { $ ( addButtonControl ) . removeClass ( 'active' ) } if ( containerTypeControl . hasClass ( 'target' ) ) { $ ( inverseButton ) . removeClass ( 'active' ) } } } ) }
195	function sourceControl ( contextControl ) { var tocheck = contextControl . find ( '.transfer-scroll' ) . find ( 'input' ) var checknum = tocheck . length var targetText = contextControl . find ( '.transfer-header' ) . find ( 'label span.num' ) var header = contextControl . find ( '.transfer-header input' ) $ ( header ) . prop ( 'checked' , false ) . removeClass ( 'semi-checked' ) if ( checknum < 1 ) { $ ( header ) . prop ( 'disabled' , true ) } else { $ ( header ) . prop ( 'disabled' , false ) } $ ( targetText ) . text ( checknum ) }
196	function targetControl ( targetControl ) { var tocheck = targetControl . find ( 'input' ) var checknum = tocheck . length var targetText = tocheck . closest ( '.it-transfer-wrapper' ) . find ( '.transfer-header' ) . find ( 'label span.num' ) var header = $ ( targetControl ) . find ( '.transfer-header input' ) if ( checknum < 1 ) { $ ( header ) . prop ( 'disabled' , true ) } else { $ ( header ) . prop ( 'disabled' , false ) } $ ( targetText ) . text ( checknum ) }
197	function checkToMove ( contextControl , targetControl ) { var elements = contextControl . find ( '.transfer-group' ) . find ( 'input:checked' ) var sourceTag = $ ( elements ) . closest ( '.form-check' ) $ ( elements ) . each ( function ( ) { $ ( this ) . prop ( 'checked' , false ) $ ( sourceTag ) . detach ( ) . appendTo ( targetControl ) . addClass ( 'added' ) } ) }
198	function updateScrollPos ( ) { if ( ! stickies . length ) { return } lastKnownScrollTop = document . documentElement . scrollTop || document . body . scrollTop if ( ! isAnimationRequested ) { isAnimationRequested = true if ( requestAnimationFrame ) { requestAnimationFrame ( setPositions ) } else { if ( timeout ) { clearTimeout ( timeout ) } timeout = setTimeout ( setPositions , 15 ) } } }
199	function scoreText ( score ) { if ( score === - 1 ) { return options . shortPass } score = score < 0 ? 0 : score if ( score < 26 ) { return options . shortPass } if ( score < 51 ) { return options . badPass } if ( score < 76 ) { return options . goodPass } return options . strongPass }
200	function calculateScore ( password ) { var score = 0 if ( password . length < options . minimumLength ) { return - 1 } score += password . length * 4 score += checkRepetition ( 1 , password ) . length - password . length score += checkRepetition ( 2 , password ) . length - password . length score += checkRepetition ( 3 , password ) . length - password . length score += checkRepetition ( 4 , password ) . length - password . length if ( password . match ( / (.*[0-9].*[0-9].*[0-9]) / ) ) { score += 5 } var symbols = '.*[!,@,#,$,%,^,&,*,?,_,~]' symbols = new RegExp ( '(' + symbols + symbols + ')' ) if ( password . match ( symbols ) ) { score += 5 } if ( password . match ( / ([a-z].*[A-Z])|([A-Z].*[a-z]) / ) ) { score += 10 } if ( password . match ( / ([a-zA-Z]) / ) && password . match ( / ([0-9]) / ) ) { score += 15 } if ( password . match ( / ([!,@,#,$,%,^,&,*,?,_,~]) / ) && password . match ( / ([0-9]) / ) ) { score += 15 } if ( password . match ( / ([!,@,#,$,%,^,&,*,?,_,~]) / ) && password . match ( / ([a-zA-Z]) / ) ) { score += 15 } if ( password . match ( / ^\w+$ / ) || password . match ( / ^\d+$ / ) ) { score -= 10 } if ( score > 100 ) { score = 100 } if ( score < 0 ) { score = 0 } return score }
201	function checkRepetition ( rLen , str ) { var res = '' , repeated = false for ( var i = 0 ; i < str . length ; i ++ ) { repeated = true for ( var j = 0 ; j < rLen && j + i + rLen < str . length ; j ++ ) { repeated = repeated && str . charAt ( j + i ) === str . charAt ( j + i + rLen ) } if ( j < rLen ) { repeated = false } if ( repeated ) { i += rLen - 1 repeated = false } else { res += str . charAt ( i ) } } return res }
202	function init ( ) { var shown = true var $text = options . showText var $graybar = $ ( '<div>' ) . addClass ( 'password-meter progress rounded-0 position-absolute' ) $graybar . append ( ` ` ) var $colorbar = $ ( '<div>' ) . attr ( { class : 'progress-bar' , role : 'progressbar' , 'aria-valuenow' : '0' , 'aria-valuemin' : '0' , 'aria-valuemax' : '100' , } ) var $insert = $ ( '<div>' ) . append ( $graybar . append ( $colorbar ) ) if ( options . showText ) { $text = $ ( '<small>' ) . addClass ( 'form-text text-muted' ) . html ( options . enterPass ) $insert . prepend ( $text ) } $object . after ( $insert ) $object . keyup ( function ( ) { var score = calculateScore ( $object . val ( ) ) $object . trigger ( 'password.score' , [ score ] ) var perc = score < 0 ? 0 : score $colorbar . removeClass ( function ( index , className ) { return ( className . match ( / (^|\s)bg-\S+ / g ) || [ ] ) . join ( ' ' ) } ) $colorbar . addClass ( 'bg-' + scoreColor ( score ) ) $colorbar . css ( { width : perc + '%' , } ) $colorbar . attr ( 'aria-valuenow' , perc ) if ( options . showText ) { var text = scoreText ( score ) if ( ! $object . val ( ) . length && score <= 0 ) { text = options . enterPass } if ( $text . html ( ) !== $ ( '<div>' ) . html ( text ) . html ( ) ) { $text . html ( text ) $text . removeClass ( function ( index , className ) { return ( className . match ( / (^|\s)text-\S+ / g ) || [ ] ) . join ( ' ' ) } ) $text . addClass ( 'text-' + scoreColor ( score ) ) $object . trigger ( 'password.text' , [ text , score ] ) } } } ) return this }
203	function LevelUpArrayAdapter ( name , db , serializer ) { this . db = Sublevel ( db ) ; this . db = this . db . sublevel ( name ) ; this . name = name ; this . serializer = serializer || { encode : function ( val , callback ) { callback ( null , val ) ; } , decode : function ( val , callback ) { callback ( null , val ) ; } } ; }
204	function fixProps ( tx , data ) { tx . _originals = [ ] ; const fieldNames = [ "nonce" , "gasPrice" , "gasLimit" , "value" ] ; fieldNames . forEach ( ( fieldName ) => configZeroableField ( tx , fieldName , 32 ) ) ; const vDescriptors = Object . getOwnPropertyDescriptor ( tx , "v" ) ; Object . defineProperty ( tx , "v" , { set : ( v ) => { vDescriptors . set . call ( tx , v ) ; const sigV = ethUtil . bufferToInt ( tx . v ) ; let chainId = Math . floor ( ( sigV - 35 ) / 2 ) ; if ( chainId < 0 ) { chainId = 0 ; } tx . _chainId = chainId || 0 ; } } ) ; if ( tx . isFake ( ) ) { Object . defineProperty ( tx , "from" , { enumerable : true , configurable : true , get : tx . getSenderAddress . bind ( tx ) , set : ( val ) => { if ( val ) { tx . _from = ethUtil . toBuffer ( val ) ; } else { tx . _from = null ; } } } ) ; if ( data && data . from ) { tx . from = data . from ; } tx . hash = fakeHash ; } }
205	function initData ( tx , data ) { if ( data ) { if ( typeof data === "string" ) { data = to . buffer ( data ) ; } if ( Buffer . isBuffer ( data ) ) { data = rlp . decode ( data ) ; } const self = tx ; if ( Array . isArray ( data ) ) { if ( data . length > tx . _fields . length ) { throw new Error ( "wrong number of fields in data" ) ; } data . forEach ( ( d , i ) => { self [ self . _fields [ i ] ] = ethUtil . toBuffer ( d ) ; } ) ; } else if ( ( typeof data === "undefined" ? "undefined" : typeof data ) === "object" ) { const keys = Object . keys ( data ) ; tx . _fields . forEach ( function ( field ) { if ( keys . indexOf ( field ) !== - 1 ) { self [ field ] = data [ field ] ; } if ( field === "gasLimit" ) { if ( keys . indexOf ( "gas" ) !== - 1 ) { self [ "gas" ] = data [ "gas" ] ; } } else if ( field === "data" ) { if ( keys . indexOf ( "input" ) !== - 1 ) { self [ "input" ] = data [ "input" ] ; } } } ) ; if ( ! tx . _chainId && data && data . chainId != null ) { tx . raw [ self . _fields . indexOf ( "v" ) ] = tx . _chainId = data . chainId || 0 ; } } else { throw new Error ( "invalid data" ) ; } } }
206	function TXRejectedError ( message ) { Error . captureStackTrace ( this , this . constructor ) ; this . name = this . constructor . name ; this . message = message ; }
207	function RequestFunnel ( ) { this . methods = { eth_call : true , eth_getStorageAt : true , eth_sendTransaction : true , eth_sendRawTransaction : true , eth_newBlockFilter : true , eth_getFilterChanges : true , eth_getFilterLogs : true } ; this . queue = [ ] ; this . isWorking = false ; }
208	function compileSass ( _path , ext , data , callback ) { const compiledCss = sass . renderSync ( { data : data , outputStyle : 'expanded' , importer : function ( url , prev , done ) { if ( url . startsWith ( '~' ) ) { const newUrl = path . join ( __dirname , 'node_modules' , url . substr ( 1 ) ) ; return { file : newUrl } ; } else { return { file : url } ; } } } ) ; callback ( null , compiledCss . css ) ; }
209	function requireBrocfile ( brocfilePath ) { let brocfile ; if ( brocfilePath . match ( / \.ts$ / ) ) { try { require . resolve ( 'ts-node' ) ; } catch ( e ) { throw new Error ( ` ` ) ; } try { require . resolve ( 'typescript' ) ; } catch ( e ) { throw new Error ( ` ` ) ; } require ( 'ts-node' ) . register ( ) ; brocfile = require ( brocfilePath ) ; } else { brocfile = esmRequire ( brocfilePath ) ; } if ( brocfile !== null && typeof brocfile === 'object' && brocfile . hasOwnProperty ( 'default' ) ) { brocfile = brocfile . default ; } return brocfile ; }
210	function runmath ( s ) { var ans ; try { ans = new nearley . Parser ( grammar . ParserRules , grammar . ParserStart ) . feed ( s ) ; if ( ans . results . length ) { return ans . results [ 0 ] . toString ( ) ; } else { var out = "Error: incomplete input, parse failed. :(" ; return out ; } } catch ( e ) { var out = new Array ( PROMPT . length + e . offset + 1 ) . join ( "-" ) + "^ Error." ; return out ; } }
211	function ( arr , isSigned ) { if ( this . type !== Pbf . Bytes ) return arr . push ( this . readVarint ( isSigned ) ) ; var end = readPackedEnd ( this ) ; arr = arr || [ ] ; while ( this . pos < end ) arr . push ( this . readVarint ( isSigned ) ) ; return arr ; }
212	function handleUnionSelections ( sqlASTNode , children , selections , gqlType , namespace , depth , options , context , internalOptions = { } ) { for ( let selection of selections ) { switch ( selection . kind ) { case 'Field' : const existingNode = children . find ( child => child . fieldName === selection . name . value && child . type === 'table' ) let newNode = new SQLASTNode ( sqlASTNode ) if ( existingNode ) { newNode = existingNode } else { children . push ( newNode ) } if ( internalOptions . defferedFrom ) { newNode . defferedFrom = internalOptions . defferedFrom } populateASTNode . call ( this , selection , gqlType , newNode , namespace , depth + 1 , options , context ) break case 'InlineFragment' : { const selectionNameOfType = selection . typeCondition . name . value const deferredType = this . schema . _typeMap [ selectionNameOfType ] const deferToObjectType = deferredType . constructor . name === 'GraphQLObjectType' const handler = deferToObjectType ? handleSelections : handleUnionSelections if ( deferToObjectType ) { const typedChildren = sqlASTNode . typedChildren children = typedChildren [ deferredType . name ] = typedChildren [ deferredType . name ] || [ ] internalOptions . defferedFrom = gqlType } handler . call ( this , sqlASTNode , children , selection . selectionSet . selections , deferredType , namespace , depth , options , context , internalOptions ) } break case 'FragmentSpread' : { const fragmentName = selection . name . value const fragment = this . fragments [ fragmentName ] const fragmentNameOfType = fragment . typeCondition . name . value const deferredType = this . schema . _typeMap [ fragmentNameOfType ] const deferToObjectType = deferredType . constructor . name === 'GraphQLObjectType' const handler = deferToObjectType ? handleSelections : handleUnionSelections if ( deferToObjectType ) { const typedChildren = sqlASTNode . typedChildren children = typedChildren [ deferredType . name ] = typedChildren [ deferredType . name ] || [ ] internalOptions . defferedFrom = gqlType } handler . call ( this , sqlASTNode , children , fragment . selectionSet . selections , deferredType , namespace , depth , options , context , internalOptions ) } break default : throw new Error ( 'Unknown selection kind: ' + selection . kind ) } } }
213	function handleSelections ( sqlASTNode , children , selections , gqlType , namespace , depth , options , context , internalOptions = { } , ) { for ( let selection of selections ) { switch ( selection . kind ) { case 'Field' : const existingNode = children . find ( child => child . fieldName === selection . name . value && child . type === 'table' ) let newNode = new SQLASTNode ( sqlASTNode ) if ( existingNode ) { newNode = existingNode } else { children . push ( newNode ) } if ( internalOptions . defferedFrom ) { newNode . defferedFrom = internalOptions . defferedFrom } populateASTNode . call ( this , selection , gqlType , newNode , namespace , depth + 1 , options , context ) break case 'InlineFragment' : { const selectionNameOfType = selection . typeCondition . name . value const sameType = selectionNameOfType === gqlType . name const interfaceType = ( gqlType . _interfaces || [ ] ) . map ( iface => iface . name ) . includes ( selectionNameOfType ) if ( sameType || interfaceType ) { handleSelections . call ( this , sqlASTNode , children , selection . selectionSet . selections , gqlType , namespace , depth , options , context , internalOptions ) } } break case 'FragmentSpread' : { const fragmentName = selection . name . value const fragment = this . fragments [ fragmentName ] const fragmentNameOfType = fragment . typeCondition . name . value const sameType = fragmentNameOfType === gqlType . name const interfaceType = gqlType . _interfaces . map ( iface => iface . name ) . indexOf ( fragmentNameOfType ) >= 0 if ( sameType || interfaceType ) { handleSelections . call ( this , sqlASTNode , children , fragment . selectionSet . selections , gqlType , namespace , depth , options , context , internalOptions ) } } break default : throw new Error ( 'Unknown selection kind: ' + selection . kind ) } } }
214	function columnToASTChild ( columnName , namespace ) { return { type : 'column' , name : columnName , fieldName : columnName , as : namespace . generate ( 'column' , columnName ) } }
215	function keyToASTChild ( key , namespace ) { if ( typeof key === 'string' ) { return columnToASTChild ( key , namespace ) } if ( Array . isArray ( key ) ) { const clumsyName = toClumsyName ( key ) return { type : 'composite' , name : key , fieldName : clumsyName , as : namespace . generate ( 'column' , clumsyName ) } } }
216	function stripRelayConnection ( gqlType , queryASTNode , fragments ) { const edgeType = stripNonNullType ( gqlType . _fields . edges . type ) const strippedType = stripNonNullType ( stripNonNullType ( edgeType . ofType ) . _fields . node . type ) const args = queryASTNode . arguments const edges = spreadFragments ( queryASTNode . selectionSet . selections , fragments , gqlType . name ) . find ( selection => selection . name . value === 'edges' ) if ( edges ) { queryASTNode = spreadFragments ( edges . selectionSet . selections , fragments , gqlType . name ) . find ( selection => selection . name . value === 'node' ) || { } } else { queryASTNode = { } } queryASTNode . arguments = args return { gqlType : strippedType , queryASTNode } }
217	function spreadFragments ( selections , fragments , typeName ) { return flatMap ( selections , selection => { switch ( selection . kind ) { case 'FragmentSpread' : const fragmentName = selection . name . value const fragment = fragments [ fragmentName ] return spreadFragments ( fragment . selectionSet . selections , fragments , typeName ) case 'InlineFragment' : if ( selection . typeCondition . name . value === typeName ) { return spreadFragments ( selection . selectionSet . selections , fragments , typeName ) } return [ ] default : return selection } } ) }
218	async function getNode ( typeName , resolveInfo , context , condition , dbCall , options = { } ) { const type = resolveInfo . schema . _typeMap [ typeName ] assert ( type , ` ${ typeName } ` ) assert ( type . _typeConfig . sqlTable , ` ${ typeName } ` ) let where = buildWhereFunction ( type , condition , options ) const fakeParentNode = { _fields : { node : { type , name : type . name . toLowerCase ( ) , where } } } const namespace = new AliasNamespace ( options . minify ) const sqlAST = { } const fieldNodes = resolveInfo . fieldNodes || resolveInfo . fieldASTs queryAST . populateASTNode . call ( resolveInfo , fieldNodes [ 0 ] , fakeParentNode , sqlAST , namespace , 0 , options , context ) queryAST . pruneDuplicateSqlDeps ( sqlAST , namespace ) const { sql , shapeDefinition } = await compileSqlAST ( sqlAST , context , options ) const data = arrToConnection ( await handleUserDbCall ( dbCall , sql , sqlAST , shapeDefinition ) , sqlAST ) await nextBatch ( sqlAST , data , dbCall , context , options ) if ( ! data ) return data data . __type__ = type return data }
219	function arrToConnection ( data , sqlAST ) { for ( let astChild of sqlAST . children || [ ] ) { if ( Array . isArray ( data ) ) { for ( let dataItem of data ) { recurseOnObjInData ( dataItem , astChild ) } } else if ( data ) { recurseOnObjInData ( data , astChild ) } } const pageInfo = { hasNextPage : false , hasPreviousPage : false } if ( ! data ) { if ( sqlAST . paginate ) { return { pageInfo , edges : [ ] } } return null } if ( sqlAST . paginate && ! data . _paginated ) { if ( sqlAST . sortKey || idx ( sqlAST , _ => _ . junction . sortKey ) ) { if ( idx ( sqlAST , _ => _ . args . first ) ) { if ( data . length > sqlAST . args . first ) { pageInfo . hasNextPage = true data . pop ( ) } } else if ( sqlAST . args && sqlAST . args . last ) { if ( data . length > sqlAST . args . last ) { pageInfo . hasPreviousPage = true data . pop ( ) } data . reverse ( ) } const sortKey = sqlAST . sortKey || sqlAST . junction . sortKey const edges = data . map ( obj => { const cursor = { } const key = sortKey . key for ( let column of wrap ( key ) ) { cursor [ column ] = obj [ column ] } return { cursor : objToCursor ( cursor ) , node : obj } } ) if ( data . length ) { pageInfo . startCursor = edges [ 0 ] . cursor pageInfo . endCursor = last ( edges ) . cursor } return { edges , pageInfo , _paginated : true } } if ( sqlAST . orderBy || ( sqlAST . junction && sqlAST . junction . orderBy ) ) { let offset = 0 if ( idx ( sqlAST , _ => _ . args . after ) ) { offset = cursorToOffset ( sqlAST . args . after ) + 1 } const arrayLength = data [ 0 ] && parseInt ( data [ 0 ] . $total , 10 ) const connection = connectionFromArraySlice ( data , sqlAST . args || { } , { sliceStart : offset , arrayLength } ) connection . total = arrayLength || 0 connection . _paginated = true return connection } } return data }
220	function validate ( rows ) { if ( Array . isArray ( rows ) ) return rows if ( rows && rows . rows ) return rows . rows throw new Error ( ` ${ util . inspect ( rows , { depth : 3 } ) } ` ) }
221	function sortKeyToWhereCondition ( keyObj , descending , sortTable , dialect ) { const { name , quote : q } = dialect const sortColumns = [ ] const sortValues = [ ] for ( let key in keyObj ) { sortColumns . push ( ` ${ q ( sortTable ) } ${ q ( key ) } ` ) sortValues . push ( maybeQuote ( keyObj [ key ] , name ) ) } const operator = descending ? '<' : '>' return name === 'oracle' ? recursiveWhereJoin ( sortColumns , sortValues , operator ) : ` ${ sortColumns . join ( ', ' ) } ${ operator } ${ sortValues . join ( ', ' ) } ` }
222	function clone ( frm , to ) { if ( frm === null || typeof frm !== "object" ) { return frm ; } if ( frm . constructor !== Object && frm . constructor !== Array ) { return frm ; } if ( frm . constructor === Date || frm . constructor === RegExp || frm . constructor === Function || frm . constructor === String || frm . constructor === Number || frm . constructor === Boolean ) { return new frm . constructor ( frm ) ; } to = to || new frm . constructor ( ) ; for ( var name in frm ) { to [ name ] = typeof to [ name ] === "undefined" ? clone ( frm [ name ] , null ) : to [ name ] ; } return to ; }
223	function buildString ( length , str ) { return Array . apply ( null , new Array ( length ) ) . map ( String . prototype . valueOf , str ) . join ( '' ) }
224	function concatArray ( arr , pretty , indentation , indentLevel ) { var currentIndent = buildString ( indentLevel , indentation ) var closingBraceIndent = buildString ( indentLevel - 1 , indentation ) var join = pretty ? ',\n' + \n : currentIndent ', ' }
225	function ( value , opts , indentLevel ) { indentLevel = indentLevel === undefined ? 1 : indentLevel + 1 switch ( Object . prototype . toString . call ( value ) ) { case '[object Number]' : return value case '[object Array]' : var pretty = false var valuesRepresentation = value . map ( function ( v ) { if ( Object . prototype . toString . call ( v ) === '[object Object]' ) { pretty = Object . keys ( v ) . length > 1 } return this . literalRepresentation ( v , opts , indentLevel ) } . bind ( this ) ) return concatArray ( valuesRepresentation , pretty , opts . indent , indentLevel ) case '[object Object]' : var keyValuePairs = [ ] for ( var k in value ) { keyValuePairs . push ( util . format ( '"%s": %s' , k , this . literalRepresentation ( value [ k ] , opts , indentLevel ) ) ) } return concatArray ( keyValuePairs , opts . pretty && keyValuePairs . length > 1 , opts . indent , indentLevel ) case '[object Boolean]' : return value . toString ( ) default : if ( value === null || value === undefined ) { return '' } return '"' + value . toString ( ) . replace ( / " / g , '\\"' ) + \\ } }
226	function ( text , placeholders ) { if ( text [ text . length - 1 ] == "]" && text . lastIndexOf ( " [" ) != - 1 ) { text = text . substr ( 0 , text . lastIndexOf ( " [" ) ) ; } var replaceAll = function ( str , substr , replacement ) { return str . replace ( new RegExp ( substr . replace ( / ([.*+?^=!:${}()|\[\]\/\\]) / g , "\\$1" ) , \\ ) , "g" ) ; } replacement var localeReplace = function ( text , placeholders ) { for ( var key in placeholders ) { text = replaceAll ( text , "%(" + key + ")s" , placeholders [ key ] ) ; } return text ; } ; var reactLocaleReplace = function ( text , placeholders ) { var start ; var expanded = [ text ] ; for ( var key in placeholders ) { start = expanded ; expanded = [ ] ; for ( var i = 0 ; i < start . length ; i ++ ) { if ( typeof start [ i ] == "string" ) { var keyStr = "%(" + key + ")s" ; var parts = start [ i ] . split ( keyStr ) ; var replaced = [ ] ; for ( var j = 0 ; j < parts . length - 1 ; j ++ ) { replaced . push ( parts [ j ] ) ; replaced . push ( placeholders [ key ] ) ; } replaced . push ( parts [ parts . length - 1 ] ) ; replaced = replaced . filter ( function ( str ) { return str != "" ; } ) ; expanded . push . apply ( expanded , replaced ) } else { expanded . push ( start [ i ] ) ; } } } return expanded ; } if ( placeholders ) { var hasReactElements = false ; for ( var key in placeholders ) { var val = placeholders [ key ] ; if ( typeof val !== "string" && React . isValidElement ( val ) ) { hasReactElements = true ; break ; } } return ( hasReactElements ? reactLocaleReplace ( text , placeholders ) : localeReplace ( text , placeholders ) ) ; } }
227	function createNode ( media ) { var node = new Audio ( ) ; node . onplay = function ( ) { Media . onStatus ( media . id , Media . MEDIA_STATE , Media . MEDIA_STARTING ) ; } ; node . onplaying = function ( ) { Media . onStatus ( media . id , Media . MEDIA_STATE , Media . MEDIA_RUNNING ) ; } ; node . ondurationchange = function ( e ) { Media . onStatus ( media . id , Media . MEDIA_DURATION , e . target . duration || - 1 ) ; } ; node . onerror = function ( e ) { var err = e . target . error . code === MediaError . MEDIA_ERR_SRC_NOT_SUPPORTED ? { code : MediaError . MEDIA_ERR_ABORTED } : e . target . error ; Media . onStatus ( media . id , Media . MEDIA_ERROR , err ) ; } ; node . onended = function ( ) { Media . onStatus ( media . id , Media . MEDIA_STATE , Media . MEDIA_STOPPED ) ; } ; if ( media . src ) { node . src = media . src ; } return node ; }
228	function ( win , lose , args ) { var id = args [ 0 ] ; var srcUri = processUri ( args [ 1 ] ) ; var createAudioNode = ! ! args [ 2 ] ; var thisM = Media . get ( id ) ; Media . prototype . node = null ; var prefix = args [ 1 ] . split ( ':' ) . shift ( ) ; var extension = srcUri . extension ; if ( thisM . node === null ) { if ( SUPPORTED_EXTENSIONS . indexOf ( extension ) === - 1 && SUPPORTED_PREFIXES . indexOf ( prefix ) === - 1 ) { if ( lose ) { lose ( { code : MediaError . MEDIA_ERR_ABORTED } ) ; } return false ; } if ( createAudioNode === true ) { thisM . node = new Audio ( ) ; thisM . node . msAudioCategory = "BackgroundCapableMedia" ; thisM . node . src = srcUri . absoluteCanonicalUri ; thisM . node . onloadstart = function ( ) { Media . onStatus ( id , Media . MEDIA_STATE , Media . MEDIA_STARTING ) ; } ; thisM . node . ontimeupdate = function ( e ) { Media . onStatus ( id , Media . MEDIA_POSITION , e . target . currentTime ) ; } ; thisM . node . onplaying = function ( ) { Media . onStatus ( id , Media . MEDIA_STATE , Media . MEDIA_RUNNING ) ; } ; thisM . node . ondurationchange = function ( e ) { Media . onStatus ( id , Media . MEDIA_DURATION , e . target . duration || - 1 ) ; } ; thisM . node . onerror = function ( e ) { var err = e . target . error . code === MediaError . MEDIA_ERR_SRC_NOT_SUPPORTED ? { code : MediaError . MEDIA_ERR_ABORTED } : e . target . error ; Media . onStatus ( id , Media . MEDIA_ERROR , err ) ; } ; thisM . node . onended = function ( ) { Media . onStatus ( id , Media . MEDIA_STATE , Media . MEDIA_STOPPED ) ; } ; } } return true ; }
229	function ( win , lose , args ) { var id = args [ 0 ] ; var thisM = Media . get ( id ) ; if ( ! thisM . node ) { args [ 2 ] = true ; if ( ! module . exports . create ( win , lose , args ) ) { return ; } } try { thisM . node . play ( ) ; } catch ( err ) { if ( lose ) { lose ( { code : MediaError . MEDIA_ERR_ABORTED } ) ; } } }
230	function ( win , lose , args ) { var id = args [ 0 ] ; var milliseconds = args [ 1 ] ; var thisM = Media . get ( id ) ; try { thisM . node . currentTime = milliseconds / 1000 ; win ( thisM . node . currentTime ) ; } catch ( err ) { lose ( "Failed to seek: " + err ) ; } }
231	function ( win , lose , args ) { var id = args [ 0 ] ; var thisM = Media . get ( id ) ; try { thisM . node . pause ( ) ; Media . onStatus ( id , Media . MEDIA_STATE , Media . MEDIA_PAUSED ) ; } catch ( err ) { lose ( "Failed to pause: " + err ) ; } }
232	function ( win , lose , args ) { var id = args [ 0 ] ; try { var p = ( Media . get ( id ) ) . node . currentTime ; win ( p ) ; } catch ( err ) { lose ( err ) ; } }
233	function ( win , lose , args ) { var id = args [ 0 ] ; var srcUri = processUri ( args [ 1 ] ) ; var dest = parseUriToPathAndFilename ( srcUri ) ; var destFileName = dest . fileName ; var success = function ( ) { Media . onStatus ( id , Media . MEDIA_STATE , Media . MEDIA_RUNNING ) ; } ; var error = function ( reason ) { Media . onStatus ( id , Media . MEDIA_ERROR , reason ) ; } ; Media . prototype . mediaCaptureMgr = null ; var thisM = ( Media . get ( id ) ) ; var captureInitSettings = new Windows . Media . Capture . MediaCaptureInitializationSettings ( ) ; captureInitSettings . streamingCaptureMode = Windows . Media . Capture . StreamingCaptureMode . audio ; thisM . mediaCaptureMgr = new Windows . Media . Capture . MediaCapture ( ) ; thisM . mediaCaptureMgr . addEventListener ( "failed" , error ) ; thisM . mediaCaptureMgr . initializeAsync ( captureInitSettings ) . done ( function ( result ) { thisM . mediaCaptureMgr . addEventListener ( "recordlimitationexceeded" , error ) ; thisM . mediaCaptureMgr . addEventListener ( "failed" , error ) ; Windows . Storage . ApplicationData . current . temporaryFolder . createFileAsync ( destFileName , Windows . Storage . CreationCollisionOption . replaceExisting ) . done ( function ( newFile ) { recordedFile = newFile ; var encodingProfile = null ; switch ( newFile . fileType ) { case '.m4a' : encodingProfile = Windows . Media . MediaProperties . MediaEncodingProfile . createM4a ( Windows . Media . MediaProperties . AudioEncodingQuality . auto ) ; break ; case '.mp3' : encodingProfile = Windows . Media . MediaProperties . MediaEncodingProfile . createMp3 ( Windows . Media . MediaProperties . AudioEncodingQuality . auto ) ; break ; case '.wma' : encodingProfile = Windows . Media . MediaProperties . MediaEncodingProfile . createWma ( Windows . Media . MediaProperties . AudioEncodingQuality . auto ) ; break ; default : error ( "Invalid file type for record" ) ; break ; } thisM . mediaCaptureMgr . startRecordToStorageFileAsync ( encodingProfile , newFile ) . done ( success , error ) ; } , error ) ; } , error ) ; }
234	function ( win , lose , args ) { var id = args [ 0 ] ; var thisM = Media . get ( id ) ; var srcUri = processUri ( thisM . src ) ; var dest = parseUriToPathAndFilename ( srcUri ) ; var destPath = dest . path ; var destFileName = dest . fileName ; var fsType = dest . fsType ; var success = function ( ) { Media . onStatus ( id , Media . MEDIA_STATE , Media . MEDIA_STOPPED ) ; } ; var error = function ( reason ) { Media . onStatus ( id , Media . MEDIA_ERROR , reason ) ; } ; thisM . mediaCaptureMgr . stopRecordAsync ( ) . done ( function ( ) { if ( fsType === fsTypes . TEMPORARY ) { if ( ! destPath ) { success ( ) ; } else { Windows . Storage . ApplicationData . current . temporaryFolder . getFolderAsync ( destPath ) . done ( function ( destFolder ) { recordedFile . copyAsync ( destFolder , destFileName , Windows . Storage . CreationCollisionOption . replaceExisting ) . done ( success , error ) ; } , error ) ; } } else { if ( ! destPath ) { recordedFile . copyAsync ( Windows . Storage . ApplicationData . current . localFolder , destFileName , Windows . Storage . CreationCollisionOption . replaceExisting ) . done ( success , error ) ; } else { Windows . Storage . ApplicationData . current . localFolder . getFolderAsync ( destPath ) . done ( function ( destFolder ) { recordedFile . copyAsync ( destFolder , destFileName , Windows . Storage . CreationCollisionOption . replaceExisting ) . done ( success , error ) ; } , error ) ; } } } , error ) ; }
235	function ( win , lose , args ) { var id = args [ 0 ] ; var thisM = Media . get ( id ) ; try { if ( thisM . node ) { thisM . node . onloadedmetadata = null ; thisM . node . onerror = null ; thisM . node . src = null ; delete thisM . node ; } } catch ( err ) { lose ( "Failed to release: " + err ) ; } }
236	function fullPathToAppData ( uri ) { if ( uri . schemeName === 'file' ) { if ( uri . rawUri . indexOf ( Windows . Storage . ApplicationData . current . localFolder . path ) !== - 1 ) { uri = new Windows . Foundation . Uri ( localFolderAppDataBasePath , uri . rawUri . replace ( localFolderFullPath , '' ) . replace ( / ^[\\\/]{1,2} / , '' ) ) ; } else if ( uri . rawUri . indexOf ( Windows . Storage . ApplicationData . current . temporaryFolder . path ) !== - 1 ) { uri = new Windows . Foundation . Uri ( tempFolderAppDataBasePath , uri . rawUri . replace ( tempFolderFullPath , '' ) . replace ( / ^[\\\/]{1,2} / , '' ) ) ; } else { throw new Error ( 'Not supported file uri: ' + uri . rawUri ) ; } } return uri ; }
237	function cdvfileToAppData ( uri ) { var cdvFsRoot ; if ( uri . schemeName === 'cdvfile' ) { cdvFsRoot = uri . path . split ( '/' ) [ 1 ] ; if ( cdvFsRoot === 'temporary' ) { return new Windows . Foundation . Uri ( tempFolderAppDataBasePath , uri . path . split ( '/' ) . slice ( 2 ) . join ( '/' ) ) ; } else if ( cdvFsRoot === 'persistent' ) { return new Windows . Foundation . Uri ( localFolderAppDataBasePath , uri . path . split ( '/' ) . slice ( 2 ) . join ( '/' ) ) ; } else { throw new Error ( cdvFsRoot + ' cdvfile root is not supported on Windows' ) ; } } return uri ; }
238	function processUri ( src ) { src = src . replace ( / ([^\/:])(\/\/)([^\/]) / g , '$1/$3' ) ; src = src . replace ( / ^[\\\/]{1,2} / , '' ) ; var uri = setTemporaryFsByDefault ( src ) ; uri = fullPathToAppData ( uri ) ; uri = cdvfileToAppData ( uri ) ; return uri ; }
239	function parseUriToPathAndFilename ( uri ) { var normalizedSrc = uri . path . split ( '/' ) . slice ( 2 ) . join ( '\\' ) ; \\ var path = normalizedSrc . substr ( 0 , normalizedSrc . lastIndexOf ( '\\' ) ) ; \\ var fileName = normalizedSrc . replace ( path + '\\' , \\ ) ; '' }
240	function Context ( hook , opts ) { this . hook = hook ; this . opts = Object . assign ( { } , opts ) ; this . cmdLine = process . argv . join ( ' ' ) ; Object . defineProperty ( this , 'cordova' , { get ( ) { return this . requireCordovaModule ( 'cordova-lib' ) . cordova ; } } ) ; }
241	function getUniqueCapabilities ( capabilities ) { return capabilities . reduce ( function ( uniqueCaps , currCap ) { var isRepeated = uniqueCaps . some ( function ( cap ) { return getCapabilityName ( cap ) === getCapabilityName ( currCap ) ; } ) ; return isRepeated ? uniqueCaps : uniqueCaps . concat ( [ currCap ] ) ; } , [ ] ) ; }
242	function compareCapabilities ( firstCap , secondCap ) { var firstCapName = getCapabilityName ( firstCap ) ; var secondCapName = getCapabilityName ( secondCap ) ; if ( firstCapName < secondCapName ) { return - 1 ; } if ( firstCapName > secondCapName ) { return 1 ; } return 0 ; }
243	function isCordova ( dir ) { if ( ! dir ) { var pwd = process . env . PWD ; var cwd = process . cwd ( ) ; if ( pwd && pwd !== cwd && pwd !== 'undefined' ) { return this . isCordova ( pwd ) || this . isCordova ( cwd ) ; } return this . isCordova ( cwd ) ; } var bestReturnValueSoFar = false ; for ( var i = 0 ; i < 1000 ; ++ i ) { var result = isRootDir ( dir ) ; if ( result === 2 ) { return dir ; } if ( result === 1 ) { bestReturnValueSoFar = dir ; } var parentDir = path . normalize ( path . join ( dir , '..' ) ) ; if ( parentDir === dir ) { return bestReturnValueSoFar ; } dir = parentDir ; } console . error ( 'Hit an unhandled case in util.isCordova' ) ; return false ; }
244	function cdProjectRoot ( ) { const projectRoot = this . getProjectRoot ( ) ; if ( ! origCwd ) { origCwd = process . env . PWD || process . cwd ( ) ; } process . env . PWD = projectRoot ; process . chdir ( projectRoot ) ; return projectRoot ; }
245	function deleteSvnFolders ( dir ) { var contents = fs . readdirSync ( dir ) ; contents . forEach ( function ( entry ) { var fullpath = path . join ( dir , entry ) ; if ( isDirectory ( fullpath ) ) { if ( entry === '.svn' ) { fs . removeSync ( fullpath ) ; } else module . exports . deleteSvnFolders ( fullpath ) ; } } ) ; }
246	function findPlugins ( pluginDir ) { var plugins = [ ] ; if ( fs . existsSync ( pluginDir ) ) { plugins = fs . readdirSync ( pluginDir ) . filter ( function ( fileName ) { var pluginPath = path . join ( pluginDir , fileName ) ; var isPlugin = isDirectory ( pluginPath ) || isSymbolicLink ( pluginPath ) ; return fileName !== '.svn' && fileName !== 'CVS' && isPlugin ; } ) ; } return plugins ; }
247	function HooksRunner ( projectRoot ) { var root = cordovaUtil . isCordova ( projectRoot ) ; if ( ! root ) throw new CordovaError ( 'Not a Cordova project ("' + projectRoot + '"), can\'t use hooks.' ) ; else \' }
248	function extractSheBangInterpreter ( fullpath ) { const chunkSize = 4096 ; const fileData = readChunk . sync ( fullpath , 0 , chunkSize ) ; const fileChunk = fileData . toString ( ) ; const hookCmd = shebangCommand ( fileChunk ) ; if ( hookCmd && fileData . length === chunkSize && ! fileChunk . match ( / [\r\n] / ) ) { events . emit ( 'warn' , 'shebang is too long for "' + fullpath + '"' ) ; } return hookCmd ; }
249	function isHookDisabled ( opts , hook ) { if ( opts === undefined || opts . nohooks === undefined ) { return false ; } var disabledHooks = opts . nohooks ; var length = disabledHooks . length ; for ( var i = 0 ; i < length ; i ++ ) { if ( hook . match ( disabledHooks [ i ] ) !== null ) { return true ; } } return false ; }
250	function ( ) { var modulemapper = require ( 'cordova/modulemapper' ) ; var channel = require ( 'cordova/channel' ) ; modulemapper . clobbers ( 'cordova/exec/proxy' , 'cordova.commandProxy' ) ; channel . onNativeReady . fire ( ) ; document . addEventListener ( "visibilitychange" , function ( ) { if ( document . hidden ) { channel . onPause . fire ( ) ; } else { channel . onResume . fire ( ) ; } } ) ; }
251	function ( hook , opts ) { if ( ! hook ) { throw new Error ( 'hook type is not specified' ) ; } return getApplicationHookScripts ( hook , opts ) . concat ( getPluginsHookScripts ( hook , opts ) ) ; }
252	function getPluginsHookScripts ( hook , opts ) { if ( ! hook ) { throw new Error ( 'hook type is not specified' ) ; } if ( opts . plugin ) { events . emit ( 'verbose' , 'Finding scripts for "' + hook + '" hook from plugin ' + opts . plugin . id + ' on ' + opts . plugin . platform + ' platform only.' ) ; return getPluginScriptFiles ( opts . plugin , hook , opts . plugin . platform ? [ opts . plugin . platform ] : opts . cordova . platforms ) ; } return getAllPluginsHookScriptFiles ( hook , opts ) ; }
253	function getApplicationHookScriptsFromDir ( dir ) { if ( ! ( fs . existsSync ( dir ) ) ) { return [ ] ; } var compareNumbers = function ( a , b ) { return isNaN ( parseInt ( a , 10 ) ) ? a . toLowerCase ( ) . localeCompare ( b . toLowerCase ? b . toLowerCase ( ) : b ) : parseInt ( a , 10 ) > parseInt ( b , 10 ) ? 1 : parseInt ( a , 10 ) < parseInt ( b , 10 ) ? - 1 : 0 ; } ; var scripts = fs . readdirSync ( dir ) . sort ( compareNumbers ) . filter ( function ( s ) { return s [ 0 ] !== '.' ; } ) ; return scripts . map ( function ( scriptPath ) { return { path : scriptPath , fullPath : path . join ( dir , scriptPath ) , useModuleLoader : false } ; } ) ; }
254	function getScriptsFromConfigXml ( hook , opts ) { var configPath = cordovaUtil . projectConfig ( opts . projectRoot ) ; var configXml = new ConfigParser ( configPath ) ; return configXml . getHookScripts ( hook , opts . cordova . platforms ) . map ( function ( scriptElement ) { return { path : scriptElement . attrib . src , fullPath : path . join ( opts . projectRoot , scriptElement . attrib . src ) } ; } ) ; }
255	function getPluginScriptFiles ( plugin , hook , platforms ) { var scriptElements = plugin . pluginInfo . getHookScripts ( hook , platforms ) ; return scriptElements . map ( function ( scriptElement ) { return { path : scriptElement . attrib . src , fullPath : path . join ( plugin . dir , scriptElement . attrib . src ) , plugin : plugin } ; } ) ; }
256	function getAllPluginsHookScriptFiles ( hook , opts ) { var scripts = [ ] ; var currentPluginOptions ; var plugins = ( new PluginInfoProvider ( ) ) . getAllWithinSearchPath ( path . join ( opts . projectRoot , 'plugins' ) ) ; plugins . forEach ( function ( pluginInfo ) { currentPluginOptions = { id : pluginInfo . id , pluginInfo : pluginInfo , dir : pluginInfo . dir } ; scripts = scripts . concat ( getPluginScriptFiles ( currentPluginOptions , hook , opts . cordova . platforms ) ) ; } ) ; return scripts ; }
257	function ensureUniqueCapabilities ( capabilities ) { var uniqueCapabilities = [ ] ; capabilities . getchildren ( ) . forEach ( function ( el ) { var name = el . attrib . Name ; if ( uniqueCapabilities . indexOf ( name ) !== - 1 ) { capabilities . remove ( el ) ; } else { uniqueCapabilities . push ( name ) ; } } ) ; }
258	function copyNewFile ( plugin_dir , src , project_dir , dest , link ) { var target_path = path . resolve ( project_dir , dest ) ; if ( fs . existsSync ( target_path ) ) throw new CordovaError ( '"' + target_path + '" already exists!' ) ; copyFile ( plugin_dir , src , project_dir , dest , ! ! link ) ; }
259	function PluginSpec ( raw , scope , id , version ) { this . scope = scope || null ; this . id = id || raw ; this . version = version || null ; this . package = ( scope ? scope + id : id ) || null ; }
260	function getPluginFilePath ( plugin , pluginFile , targetDir ) { var src = path . resolve ( plugin . dir , pluginFile ) ; return '$(ProjectDir)' + path . relative ( targetDir , src ) ; }
261	function platform ( command , targets , opts ) { return Promise . resolve ( ) . then ( function ( ) { var msg ; var projectRoot = cordova_util . cdProjectRoot ( ) ; var hooksRunner = new HooksRunner ( projectRoot ) ; if ( arguments . length === 0 ) command = 'ls' ; if ( targets && ! ( targets instanceof Array ) ) targets = [ targets ] ; if ( ( command === 'add' || command === 'rm' || command === 'remove' ) && ( ! targets || ( targets instanceof Array && targets . length === 0 ) ) ) { msg = 'You need to qualify `' + command + '` with one or more platforms!' ; return Promise . reject ( new CordovaError ( msg ) ) ; } opts = opts || { } ; opts . platforms = targets ; switch ( command ) { case 'add' : return module . exports . add ( hooksRunner , projectRoot , targets , opts ) ; case 'rm' : case 'remove' : return module . exports . remove ( hooksRunner , projectRoot , targets , opts ) ; case 'update' : case 'up' : return module . exports . update ( hooksRunner , projectRoot , targets , opts ) ; case 'check' : return module . exports . check ( hooksRunner , projectRoot ) ; default : return module . exports . list ( hooksRunner , projectRoot , opts ) ; } } ) ; }
262	function getPlatforms ( projectRoot ) { var xml = cordova_util . projectConfig ( projectRoot ) ; var cfg = new ConfigParser ( xml ) ; var engines = cfg . getEngines ( ) . map ( function ( engine ) { var result = { name : engine . name } ; if ( semver . validRange ( engine . spec , true ) ) { result . version = engine . spec ; } else { result . src = engine . spec ; } return result ; } ) ; return Promise . resolve ( engines ) ; }
263	function getPlugins ( projectRoot ) { var xml = cordova_util . projectConfig ( projectRoot ) ; var cfg = new ConfigParser ( xml ) ; var plugins = cfg . getPlugins ( ) . map ( function ( plugin ) { var result = { name : plugin . name } ; if ( semver . validRange ( plugin . spec , true ) ) { result . version = plugin . spec ; } else { result . src = plugin . spec ; } var variablesObject = plugin . variables ; var variablesArray = [ ] ; if ( variablesObject ) { for ( var variable in variablesObject ) { variablesArray . push ( { name : variable , value : variablesObject [ variable ] } ) ; } } result . variables = variablesArray ; return result ; } ) ; return Promise . resolve ( plugins ) ; }
264	function ( plugin_id , plugins_dir , platformJson , pluginInfoProvider ) { var depsInfo ; if ( typeof plugins_dir === 'object' ) { depsInfo = plugins_dir ; } else { depsInfo = pkg . generateDependencyInfo ( platformJson , plugins_dir , pluginInfoProvider ) ; } var graph = depsInfo . graph ; var dependencies = graph . getChain ( plugin_id ) ; var tlps = depsInfo . top_level_plugins ; var diff_arr = [ ] ; tlps . forEach ( function ( tlp ) { if ( tlp !== plugin_id ) { diff_arr . push ( graph . getChain ( tlp ) ) ; } } ) ; diff_arr . unshift ( dependencies ) ; var danglers = underscore . difference . apply ( null , diff_arr ) ; danglers = danglers && danglers . filter ( function ( x ) { return tlps . indexOf ( x ) < 0 ; } ) ; return danglers ; }
265	function createReplacement ( manifestFile , originalChange ) { var replacement = { target : manifestFile , parent : originalChange . parent , after : originalChange . after , xmls : originalChange . xmls , versions : originalChange . versions , deviceTarget : originalChange . deviceTarget } ; return replacement ; }
266	function checkID ( expectedIdAndVersion , pinfo ) { if ( ! expectedIdAndVersion ) return ; var parsedSpec = pluginSpec . parse ( expectedIdAndVersion ) ; if ( parsedSpec . id !== pinfo . id ) { throw new Error ( 'Expected plugin to have ID "' + parsedSpec . id + '" but got "' + pinfo . id + '".' ) ; } if ( parsedSpec . version && ! semver . satisfies ( pinfo . version , parsedSpec . version ) ) { throw new Error ( 'Expected plugin ' + pinfo . id + ' to satisfy version "' + parsedSpec . version + '" but got "' + pinfo . version + '".' ) ; } }
267	function getPlatformDetailsFromDir ( dir , platformIfKnown ) { var libDir = path . resolve ( dir ) ; var platform ; var version ; try { var pkgPath = path . join ( libDir , 'package.json' ) ; var pkg = cordova_util . requireNoCache ( pkgPath ) ; platform = module . exports . platformFromName ( pkg . name ) ; version = pkg . version ; } catch ( e ) { return Promise . reject ( new CordovaError ( 'The provided path does not seem to contain a valid package.json or a valid Cordova platform: ' + libDir ) ) ; } if ( ! version || ! platform ) { return Promise . reject ( new CordovaError ( 'The provided path does not seem to contain a ' + 'Cordova platform: ' + libDir ) ) ; } return Promise . resolve ( { libDir : libDir , platform : platform , version : version } ) ; }
268	function platformFromName ( name ) { var platName = name ; var platMatch = / ^cordova-([a-z0-9-]+)$ / . exec ( name ) ; if ( platMatch && ( platMatch [ 1 ] in platforms ) ) { platName = platMatch [ 1 ] ; events . emit ( 'verbose' , 'Removing "cordova-" prefix from ' + name ) ; } return platName ; }
269	function processMessage ( message ) { var firstChar = message . charAt ( 0 ) ; if ( firstChar == 'J' ) { eval ( message . slice ( 1 ) ) ; } else if ( firstChar == 'S' || firstChar == 'F' ) { var success = firstChar == 'S' ; var keepCallback = message . charAt ( 1 ) == '1' ; var spaceIdx = message . indexOf ( ' ' , 2 ) ; var status = + message . slice ( 2 , spaceIdx ) ; var nextSpaceIdx = message . indexOf ( ' ' , spaceIdx + 1 ) ; var callbackId = message . slice ( spaceIdx + 1 , nextSpaceIdx ) ; var payloadMessage = message . slice ( nextSpaceIdx + 1 ) ; var payload = [ ] ; buildPayload ( payload , payloadMessage ) ; cordova . callbackFromNative ( callbackId , success , status , payload , keepCallback ) ; } else { console . log ( "processMessage failed: invalid message: " + JSON . stringify ( message ) ) ; } }
270	function callEngineScripts ( engines , project_dir ) { return Promise . all ( engines . map ( function ( engine ) { var scriptPath = engine . scriptSrc || null ; if ( scriptPath && ( isWindows || fs . existsSync ( engine . scriptSrc ) ) ) { if ( ! isWindows ) { fs . chmodSync ( engine . scriptSrc , '755' ) ; } return superspawn . spawn ( scriptPath ) . then ( stdout => { engine . currentVersion = cleanVersionOutput ( stdout , engine . name ) ; if ( engine . currentVersion === '' ) { events . emit ( 'warn' , engine . name + ' version check returned nothing (' + scriptPath + '), continuing anyways.' ) ; engine . currentVersion = null ; } } , ( ) => { events . emit ( 'warn' , engine . name + ' version check failed (' + scriptPath + '), continuing anyways.' ) ; engine . currentVersion = null ; } ) . then ( _ => engine ) ; } else { if ( engine . currentVersion ) { engine . currentVersion = cleanVersionOutput ( engine . currentVersion , engine . name ) ; } else { events . emit ( 'warn' , engine . name + ' version not detected (lacks script ' + scriptPath + ' ), continuing.' ) ; } return Promise . resolve ( engine ) ; } } ) ) ; }
271	function createPackageJson ( plugin_path ) { var pluginInfo = new PluginInfo ( plugin_path ) ; var defaults = { id : pluginInfo . id , version : pluginInfo . version , description : pluginInfo . description , license : pluginInfo . license , keywords : pluginInfo . getKeywordsAndPlatforms ( ) , repository : pluginInfo . repo , engines : pluginInfo . getEngines ( ) , platforms : pluginInfo . getPlatformsArray ( ) } ; var initFile = require . resolve ( './init-defaults' ) ; return initPkgJson ( plugin_path , initFile , defaults ) . then ( _ => { events . emit ( 'verbose' , 'Package.json successfully created' ) ; } ) ; }
272	function preparePlatforms ( platformList , projectRoot , options ) { return Promise . all ( platformList . map ( function ( platform ) { var project = { root : projectRoot , projectConfig : new ConfigParser ( cordova_util . projectConfig ( projectRoot ) ) , locations : { plugins : path . join ( projectRoot , 'plugins' ) , www : cordova_util . projectWww ( projectRoot ) , rootConfigXml : cordova_util . projectConfig ( projectRoot ) } } ; return module . exports . restoreMissingPluginsForPlatform ( platform , projectRoot , options ) . then ( function ( ) { var platformApi = platforms . getPlatformApi ( platform ) ; return platformApi . prepare ( project , _ . clone ( options ) ) . then ( function ( ) { var platformRoot = path . join ( projectRoot , 'platforms' , platform ) ; var platformJson = PlatformJson . load ( platformRoot , platform ) ; var munger = new PlatformMunger ( platform , platformRoot , platformJson ) ; munger . add_config_changes ( project . projectConfig , true ) . save_all ( ) ; } ) ; } ) ; } ) ) ; }
273	function ( icon , icon_size ) { var density = icon . density || sizeToDensityMap [ icon_size ] ; if ( ! density ) { return ; } var previous = android_icons [ density ] ; if ( previous && previous . platform ) { return ; } android_icons [ density ] = icon ; }
274	function mapImageResources ( rootDir , subDir , type , resourceName ) { var pathMap = { } ; shell . ls ( path . join ( rootDir , subDir , type + '-*' ) ) . forEach ( function ( drawableFolder ) { var imagePath = path . join ( subDir , path . basename ( drawableFolder ) , resourceName ) ; pathMap [ imagePath ] = null ; } ) ; return pathMap ; }
275	function findAndroidLaunchModePreference ( platformConfig ) { var launchMode = platformConfig . getPreference ( 'AndroidLaunchMode' ) ; if ( ! launchMode ) { return 'singleTop' ; } var expectedValues = [ 'standard' , 'singleTop' , 'singleTask' , 'singleInstance' ] ; var valid = expectedValues . indexOf ( launchMode ) >= 0 ; if ( ! valid ) { events . emit ( 'warn' , 'Unrecognized value for AndroidLaunchMode preference: ' + launchMode + '. Expected values are: ' + expectedValues . join ( ', ' ) ) ; } return launchMode ; }
276	function AndroidManifest ( path ) { this . path = path ; this . doc = xml . parseElementtreeSync ( path ) ; if ( this . doc . getroot ( ) . tag !== 'manifest' ) { throw new Error ( 'AndroidManifest at ' + path + ' has incorrect root node name (expected "manifest")' ) ; } }
277	function expectUnmetRequirements ( expected ) { const actual = unmetRequirementsCollector . store ; expect ( actual ) . toEqual ( jasmine . arrayWithExactContents ( expected ) ) ; }
278	function findVersion ( versions , version ) { var cleanedVersion = semver . clean ( version ) ; for ( var i = 0 ; i < versions . length ; i ++ ) { if ( semver . clean ( versions [ i ] ) === cleanedVersion ) { return versions [ i ] ; } } return null ; }
279	function listUnmetRequirements ( name , failedRequirements ) { events . emit ( 'warn' , 'Unmet project requirements for latest version of ' + name + ':' ) ; failedRequirements . forEach ( function ( req ) { events . emit ( 'warn' , ' ' + req . dependency + ' (' + req . installed + ' in project, ' + req . required + ' required)' ) ; } ) ; }
280	function ( folderName , task ) { var defer = Q . defer ( ) ; var vn = ( task . name || folderName ) ; if ( ! task . id || ! check . isUUID ( task . id ) ) { defer . reject ( createError ( vn + ': id is a required guid' ) ) ; } ; if ( ! task . name || ! check . isAlphanumeric ( task . name ) ) { defer . reject ( createError ( vn + ': name is a required alphanumeric string' ) ) ; } if ( ! task . friendlyName || ! check . isLength ( task . friendlyName , 1 , 40 ) ) { defer . reject ( createError ( vn + ': friendlyName is a required string <= 40 chars' ) ) ; } if ( ! task . instanceNameFormat ) { defer . reject ( createError ( vn + ': instanceNameFormat is required' ) ) ; } defer . resolve ( ) ; return defer . promise ; }
281	function ( travisYML , newVersion , newCodeName , existingVersions ) { if ( existingVersions . versions . length === 0 ) return travisYML const nodeVersionIndex = getNodeVersionIndex ( existingVersions . versions , newVersion , newCodeName ) const travisYMLLines = travisYML . split ( '\n' ) \n if ( nodeVersionIndex === - 1 ) { let delimiter = '' let leadingSpaces = '' if ( existingVersions . versions && existingVersions . versions . length > 0 ) { if ( existingVersions . versions [ 0 ] . match ( / " / ) ) { delimiter = '"' } if ( existingVersions . versions [ 0 ] . match ( / ' / ) ) { delimiter = "'" } leadingSpaces = existingVersions . versions [ 0 ] . match ( / ^([ ]*) / ) [ 1 ] } if ( existingVersions . versions . length === 1 && existingVersions . startIndex === existingVersions . endIndex ) { travisYMLLines . splice ( existingVersions . startIndex , 1 , 'node_js:' ) travisYMLLines . splice ( existingVersions . startIndex + 1 , 0 , ` ${ leadingSpaces } ${ existingVersions . versions [ 0 ] } ` ) travisYMLLines . splice ( existingVersions . startIndex + 2 , 0 , ` ${ leadingSpaces } ${ delimiter } ${ newVersion } ${ delimiter } ` ) } else { travisYMLLines . splice ( existingVersions . endIndex + 1 , 0 , ` ${ leadingSpaces } ${ delimiter } ${ newVersion } ${ delimiter } ` ) } } }
282	function ( travisYML , newVersion , newCodeName , existingVersions ) { if ( existingVersions . versions . length === 0 ) return travisYML const nodeVersionIndex = getNodeVersionIndex ( existingVersions . versions , newVersion , newCodeName , true ) let travisYMLLines = travisYML . split ( '\n' ) \n if ( nodeVersionIndex !== - 1 ) { if ( existingVersions . versions . length !== 1 ) { const updatedVersionsArray = _ . filter ( existingVersions . versions . map ( ( version ) => { return hasNodeVersion ( version , newVersion , newCodeName , true ) ? undefined : version } ) , Boolean ) travisYMLLines . splice ( existingVersions . startIndex + 1 , existingVersions . endIndex - existingVersions . startIndex , updatedVersionsArray ) travisYMLLines = _ . flatten ( travisYMLLines ) } } }
283	function travisTransform ( travisYML ) { try { var travisJSON = yaml . safeLoad ( travisYML , { schema : yaml . FAILSAFE_SCHEMA } ) } catch ( e ) { return } if ( ! _ . get ( travisJSON , 'node_js' ) ) return const nodeVersionFromYaml = getNodeVersionsFromTravisYML ( travisYML ) const hasNodeVersion = getNodeVersionIndex ( nodeVersionFromYaml . versions , nodeVersion , codeName ) !== - 1 if ( hasNodeVersion ) return const updatedTravisYaml = addNodeVersionToTravisYML ( travisYML , nodeVersion , codeName , nodeVersionFromYaml ) return updatedTravisYaml }
284	function isDependencyIgnoredInGroups ( groups , packageFilePath , dependencyName ) { const groupName = getGroupForPackageFile ( groups , packageFilePath ) return groupName && _ . includes ( groups [ groupName ] . ignore , dependencyName ) }
285	function getDependencyURL ( { repositoryURL , dependency } ) { const githubURL = url . parse ( githubFromGit ( repositoryURL ) || '' ) if ( dependency && ! githubURL . href ) { return ` ${ dependency } ` } return githubURL }
286	function extractApis ( services ) { var filterTypes = arguments . length <= 1 || arguments [ 1 ] === undefined ? [ ] : arguments [ 1 ] ; services = Array . isArray ( services ) ? services : [ services ] ; var apis = services . reduce ( function ( total , service ) { var obj = service . constructor === Object ? service : Object . getPrototypeOf ( service ) ; var keys = aggregateApisByType ( obj , total , filterTypes ) ; total . push . apply ( total , keys ) ; return total ; } , [ ] ) ; return apis ; }
287	function extractNormalizedFacetValues ( results , attribute ) { var predicate = { name : attribute } ; if ( results . _state . isConjunctiveFacet ( attribute ) ) { var facet = find ( results . facets , predicate ) ; if ( ! facet ) return [ ] ; return map ( facet . data , function ( v , k ) { return { name : k , count : v , isRefined : results . _state . isFacetRefined ( attribute , k ) , isExcluded : results . _state . isExcludeRefined ( attribute , k ) } ; } ) ; } else if ( results . _state . isDisjunctiveFacet ( attribute ) ) { var disjunctiveFacet = find ( results . disjunctiveFacets , predicate ) ; if ( ! disjunctiveFacet ) return [ ] ; return map ( disjunctiveFacet . data , function ( v , k ) { return { name : k , count : v , isRefined : results . _state . isDisjunctiveFacetRefined ( attribute , k ) } ; } ) ; } else if ( results . _state . isHierarchicalFacet ( attribute ) ) { return find ( results . hierarchicalFacets , predicate ) ; } }
288	function recSort ( sortFn , node ) { if ( ! node . data || node . data . length === 0 ) { return node ; } var children = map ( node . data , partial ( recSort , sortFn ) ) ; var sortedChildren = sortFn ( children ) ; var newNode = merge ( { } , node , { data : sortedChildren } ) ; return newNode ; }
289	function ( attribute , operator , v ) { var value = valToNumber ( v ) ; if ( this . isNumericRefined ( attribute , operator , value ) ) return this ; var mod = merge ( { } , this . numericRefinements ) ; mod [ attribute ] = merge ( { } , mod [ attribute ] ) ; if ( mod [ attribute ] [ operator ] ) { mod [ attribute ] [ operator ] = mod [ attribute ] [ operator ] . slice ( ) ; mod [ attribute ] [ operator ] . push ( value ) ; } else { mod [ attribute ] [ operator ] = [ value ] ; } return this . setQueryParameters ( { numericRefinements : mod } ) ; }
290	function _clearNumericRefinements ( attribute ) { if ( isUndefined ( attribute ) ) { if ( isEmpty ( this . numericRefinements ) ) return this . numericRefinements ; return { } ; } else if ( isString ( attribute ) ) { if ( isEmpty ( this . numericRefinements [ attribute ] ) ) return this . numericRefinements ; return omit ( this . numericRefinements , attribute ) ; } else if ( isFunction ( attribute ) ) { var hasChanged = false ; var newNumericRefinements = reduce ( this . numericRefinements , function ( memo , operators , key ) { var operatorList = { } ; forEach ( operators , function ( values , operator ) { var outValues = [ ] ; forEach ( values , function ( value ) { var predicateResult = attribute ( { val : value , op : operator } , key , 'numeric' ) ; if ( ! predicateResult ) outValues . push ( value ) ; } ) ; if ( ! isEmpty ( outValues ) ) { if ( outValues . length !== values . length ) hasChanged = true ; operatorList [ operator ] = outValues ; } else hasChanged = true ; } ) ; if ( ! isEmpty ( operatorList ) ) memo [ key ] = operatorList ; return memo ; } , { } ) ; if ( hasChanged ) return newNumericRefinements ; return this . numericRefinements ; } }
291	function addHierarchicalFacet ( hierarchicalFacet ) { if ( this . isHierarchicalFacet ( hierarchicalFacet . name ) ) { throw new Error ( 'Cannot declare two hierarchical facets with the same name: `' + hierarchicalFacet . name + '`' ) ; } return this . setQueryParameters ( { hierarchicalFacets : this . hierarchicalFacets . concat ( [ hierarchicalFacet ] ) } ) ; }
292	function addFacetRefinement ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } if ( RefinementList . isRefined ( this . facetsRefinements , facet , value ) ) return this ; return this . setQueryParameters ( { facetsRefinements : RefinementList . addRefinement ( this . facetsRefinements , facet , value ) } ) ; }
293	function addExcludeRefinement ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } if ( RefinementList . isRefined ( this . facetsExcludes , facet , value ) ) return this ; return this . setQueryParameters ( { facetsExcludes : RefinementList . addRefinement ( this . facetsExcludes , facet , value ) } ) ; }
294	function addDisjunctiveFacetRefinement ( facet , value ) { if ( ! this . isDisjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration' ) ; } if ( RefinementList . isRefined ( this . disjunctiveFacetsRefinements , facet , value ) ) return this ; return this . setQueryParameters ( { disjunctiveFacetsRefinements : RefinementList . addRefinement ( this . disjunctiveFacetsRefinements , facet , value ) } ) ; }
295	function addTagRefinement ( tag ) { if ( this . isTagRefined ( tag ) ) return this ; var modification = { tagRefinements : this . tagRefinements . concat ( tag ) } ; return this . setQueryParameters ( modification ) ; }
296	function removeFacet ( facet ) { if ( ! this . isConjunctiveFacet ( facet ) ) { return this ; } return this . clearRefinements ( facet ) . setQueryParameters ( { facets : filter ( this . facets , function ( f ) { return f !== facet ; } ) } ) ; }
297	function removeDisjunctiveFacet ( facet ) { if ( ! this . isDisjunctiveFacet ( facet ) ) { return this ; } return this . clearRefinements ( facet ) . setQueryParameters ( { disjunctiveFacets : filter ( this . disjunctiveFacets , function ( f ) { return f !== facet ; } ) } ) ; }
298	function removeHierarchicalFacet ( facet ) { if ( ! this . isHierarchicalFacet ( facet ) ) { return this ; } return this . clearRefinements ( facet ) . setQueryParameters ( { hierarchicalFacets : filter ( this . hierarchicalFacets , function ( f ) { return f . name !== facet ; } ) } ) ; }
299	function removeFacetRefinement ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } if ( ! RefinementList . isRefined ( this . facetsRefinements , facet , value ) ) return this ; return this . setQueryParameters ( { facetsRefinements : RefinementList . removeRefinement ( this . facetsRefinements , facet , value ) } ) ; }
300	function removeExcludeRefinement ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } if ( ! RefinementList . isRefined ( this . facetsExcludes , facet , value ) ) return this ; return this . setQueryParameters ( { facetsExcludes : RefinementList . removeRefinement ( this . facetsExcludes , facet , value ) } ) ; }
301	function removeDisjunctiveFacetRefinement ( facet , value ) { if ( ! this . isDisjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration' ) ; } if ( ! RefinementList . isRefined ( this . disjunctiveFacetsRefinements , facet , value ) ) return this ; return this . setQueryParameters ( { disjunctiveFacetsRefinements : RefinementList . removeRefinement ( this . disjunctiveFacetsRefinements , facet , value ) } ) ; }
302	function removeTagRefinement ( tag ) { if ( ! this . isTagRefined ( tag ) ) return this ; var modification = { tagRefinements : filter ( this . tagRefinements , function ( t ) { return t !== tag ; } ) } ; return this . setQueryParameters ( modification ) ; }
303	function toggleFacetRefinement ( facet , value ) { if ( this . isHierarchicalFacet ( facet ) ) { return this . toggleHierarchicalFacetRefinement ( facet , value ) ; } else if ( this . isConjunctiveFacet ( facet ) ) { return this . toggleConjunctiveFacetRefinement ( facet , value ) ; } else if ( this . isDisjunctiveFacet ( facet ) ) { return this . toggleDisjunctiveFacetRefinement ( facet , value ) ; } throw new Error ( 'Cannot refine the undeclared facet ' + facet + '; it should be added to the helper options facets, disjunctiveFacets or hierarchicalFacets' ) ; }
304	function ( facet , path ) { if ( this . isHierarchicalFacetRefined ( facet ) ) { throw new Error ( facet + ' is already refined.' ) ; } var mod = { } ; mod [ facet ] = [ path ] ; return this . setQueryParameters ( { hierarchicalFacetsRefinements : defaults ( { } , mod , this . hierarchicalFacetsRefinements ) } ) ; }
305	function isFacetRefined ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } return RefinementList . isRefined ( this . facetsRefinements , facet , value ) ; }
306	function isExcludeRefined ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } return RefinementList . isRefined ( this . facetsExcludes , facet , value ) ; }
307	function getRefinedDisjunctiveFacets ( ) { var disjunctiveNumericRefinedFacets = intersection ( keys ( this . numericRefinements ) , this . disjunctiveFacets ) ; return keys ( this . disjunctiveFacetsRefinements ) . concat ( disjunctiveNumericRefinedFacets ) . concat ( this . getRefinedHierarchicalFacets ( ) ) ; }
308	function setParameter ( parameter , value ) { if ( this [ parameter ] === value ) return this ; var modification = { } ; modification [ parameter ] = value ; return this . setQueryParameters ( modification ) ; }
309	function setQueryParameters ( params ) { if ( ! params ) return this ; var error = SearchParameters . validate ( this , params ) ; if ( error ) { throw error ; } var parsedParams = SearchParameters . _parseNumbers ( params ) ; return this . mutateMe ( function mergeWith ( newInstance ) { var ks = keys ( params ) ; forEach ( ks , function ( k ) { newInstance [ k ] = parsedParams [ k ] ; } ) ; return newInstance ; } ) ; }
310	function ( facetName ) { if ( ! this . isHierarchicalFacet ( facetName ) ) { throw new Error ( 'Cannot get the breadcrumb of an unknown hierarchical facet: `' + facetName + '`' ) ; } var refinement = this . getHierarchicalRefinement ( facetName ) [ 0 ] ; if ( ! refinement ) return [ ] ; var separator = this . _getHierarchicalFacetSeparator ( this . getHierarchicalFacetByName ( facetName ) ) ; var path = refinement . split ( separator ) ; return map ( path , trim ) ; }
311	function runCommand ( cmd , args ) { var prev = null ; console . log ( chalk . cyanBright ( cmd ) + " " + args . map ( arg => { if ( arg . startsWith ( "-" ) ) return chalk . gray ( "\\" ) + \\ + "\n " ; \n } ) . chalk . bold ( arg ) return arg ; + join ) ; ( " " ) "\n" \n var proc = child_process . spawnSync ( cmd , args , { stdio : "inherit" } ) ; }
312	function compileIntrinsics ( ) { var target = path . join ( sourceDirectory , "passes" , "WasmIntrinsics.cpp" ) ; runCommand ( "python" , [ path . join ( binaryenDirectory , "scripts" , "embedwast.py" ) , path . join ( sourceDirectory , "passes" , "wasm-intrinsics.wast" ) , target ] ) ; sourceFiles . push ( target ) ; }
313	function compileShared ( ) { runCommand ( "python" , [ path . join ( emscriptenDirectory , "em++" ) ] . concat ( sourceFiles ) . concat ( commonOptions ) . concat ( [ "-o" , "shared.bc" ] ) ) ; }
314	function compileJs ( options ) { runCommand ( "python" , [ path . join ( emscriptenDirectory , "em++" ) , "shared.bc" ] . concat ( commonOptions ) . concat ( [ "--post-js" , options . post , "--closure" , "1" , "-s" , "WASM=0" , "-s" , "EXPORTED_FUNCTIONS=[" + exportedFunctionsArg + "]" , "-s" , "ALLOW_MEMORY_GROWTH=1" , "-s" , "ELIMINATE_DUPLICATE_FUNCTIONS=1" , "-s" , "MODULARIZE_INSTANCE=1" , "-s" , "EXPORT_NAME=\"Binaryen\"" , \" , \" , "-o" ] ) ) ; }
315	function compileWasm ( options ) { run ( "python" , [ path . join ( emscriptenDirectory , "em++" ) , "shared.bc" ] . concat ( commonOptions ) . concat ( [ "--post-js" , options . post , "--closure" , "1" , "-s" , "EXPORTED_FUNCTIONS=[" + exportedFunctionsArg + "]" , "-s" , "ALLOW_MEMORY_GROWTH=1" , "-s" , "BINARYEN=1" , "-s" , "BINARYEN_METHOD=\"native-wasm\"" , \" , \" , "-s" , "MODULARIZE_INSTANCE=1" , "-s" , "EXPORT_NAME=\"Binaryen\"" , \" ] ) ) ; }
316	function pluginState ( ) { return { _sync : { signedIn : false , userId : null , unsubscribe : { } , pathVariables : { } , patching : false , syncStack : { inserts : [ ] , updates : { } , propDeletions : { } , deletions : [ ] , debounceTimer : null , } , fetched : { } , stopPatchingTimeout : null } } ; }
317	function helpers ( originVal , newVal ) { if ( isArray ( originVal ) && isArrayHelper ( newVal ) ) { newVal = newVal . executeOn ( originVal ) ; } if ( isNumber ( originVal ) && isIncrementHelper ( newVal ) ) { newVal = newVal . executeOn ( originVal ) ; } return newVal ; }
318	function makeBatchFromSyncstack ( state , getters , Firebase , batchMaxCount ) { if ( batchMaxCount === void 0 ) { batchMaxCount = 500 ; } var firestorePath = state . _conf . firestorePath ; var firestorePathComplete = getters . firestorePathComplete ; var dbRef = getters . dbRef ; var collectionMode = getters . collectionMode ; var batch = Firebase . firestore ( ) . batch ( ) ; var log = { } ; var count = 0 ; var updates = grabUntilApiLimit ( 'updates' , count , batchMaxCount , state ) ; log [ 'updates: ' ] = updates ; count = count + updates . length ; updates . forEach ( function ( item ) { var id = item . id ; var docRef = ( collectionMode ) ? dbRef . doc ( id ) : dbRef ; if ( state . _conf . sync . guard . includes ( 'id' ) ) delete item . id ; batch . update ( docRef , item ) ; } ) ; var propDeletions = grabUntilApiLimit ( 'propDeletions' , count , batchMaxCount , state ) ; log [ 'prop deletions: ' ] = propDeletions ; count = count + propDeletions . length ; propDeletions . forEach ( function ( item ) { var id = item . id ; var docRef = ( collectionMode ) ? dbRef . doc ( id ) : dbRef ; if ( state . _conf . sync . guard . includes ( 'id' ) ) delete item . id ; batch . update ( docRef , item ) ; } ) ; var deletions = grabUntilApiLimit ( 'deletions' , count , batchMaxCount , state ) ; log [ 'deletions: ' ] = deletions ; count = count + deletions . length ; deletions . forEach ( function ( id ) { var docRef = dbRef . doc ( id ) ; batch . delete ( docRef ) ; } ) ; var inserts = grabUntilApiLimit ( 'inserts' , count , batchMaxCount , state ) ; log [ 'inserts: ' ] = inserts ; count = count + inserts . length ; inserts . forEach ( function ( item ) { var newRef = dbRef . doc ( item . id ) ; batch . set ( newRef , item ) ; } ) ; if ( state . _conf . logging ) { console . group ( '[vuex-easy-firestore] api call batch:' ) ; console . log ( "%cFirestore PATH: " + firestorePathComplete + " [" + firestorePath + "]" , 'color: grey' ) ; Object . keys ( log ) . forEach ( function ( key ) { console . log ( key , log [ key ] ) ; } ) ; console . groupEnd ( ) ; } return batch ; }
319	function iniModule ( userConfig , FirebaseDependency ) { var conf = copy ( merge ( { state : { } , mutations : { } , actions : { } , getters : { } } , defaultConfig , userConfig ) ) ; if ( ! errorCheck ( conf ) ) return ; var userState = conf . state ; var userMutations = conf . mutations ; var userActions = conf . actions ; var userGetters = conf . getters ; delete conf . state ; delete conf . mutations ; delete conf . actions ; delete conf . getters ; var docContainer = { } ; if ( conf . statePropName ) docContainer [ conf . statePropName ] = { } ; var restOfState = merge ( userState , docContainer ) ; if ( conf . firestoreRefType === 'doc' ) { var defaultValsInState = ( conf . statePropName ) ? restOfState [ conf . statePropName ] : restOfState ; conf . sync . defaultValues = copy ( merge ( defaultValsInState , conf . sync . defaultValues ) ) ; } return { namespaced : true , state : merge ( pluginState ( ) , restOfState , { _conf : conf } ) , mutations : merge ( userMutations , pluginMutations ( merge ( userState , { _conf : conf } ) ) ) , actions : merge ( userActions , pluginActions ( FirebaseDependency ) ) , getters : merge ( userGetters , pluginGetters ( FirebaseDependency ) ) } ; }
320	function setDefaultValues ( obj , defaultValues ) { if ( ! isWhat . isPlainObject ( defaultValues ) ) console . error ( '[vuex-easy-firestore] Trying to merge target:' , obj , 'onto a non-object (defaultValues):' , defaultValues ) ; if ( ! isWhat . isPlainObject ( obj ) ) console . error ( '[vuex-easy-firestore] Trying to merge a non-object:' , obj , 'onto the defaultValues:' , defaultValues ) ; var result = merge ( { extensions : [ convertTimestamps ] } , defaultValues , obj ) ; return findAndReplaceAnything . findAndReplace ( result , '%convertTimestamp%' , null , { onlyPlainObjects : true } ) ; }
321	function getId ( payloadPiece , conf , path , fullPayload ) { if ( isWhat . isString ( payloadPiece ) ) return payloadPiece ; if ( isWhat . isPlainObject ( payloadPiece ) ) { if ( 'id' in payloadPiece ) return payloadPiece . id ; var keys = Object . keys ( payloadPiece ) ; if ( keys . length === 1 ) return keys [ 0 ] ; } return '' ; }
322	function vuexEasyFirestore ( easyFirestoreModule , _a ) { var _b = _a === void 0 ? { logging : false , preventInitialDocInsertion : false , FirebaseDependency : Firebase$2 } : _a , _c = _b . logging , logging = _c === void 0 ? false : _c , _d = _b . preventInitialDocInsertion , preventInitialDocInsertion = _d === void 0 ? false : _d , _e = _b . FirebaseDependency , FirebaseDependency = _e === void 0 ? Firebase$2 : _e ; if ( FirebaseDependency ) { setFirebaseDependency ( FirebaseDependency ) ; setFirebaseDependency$1 ( FirebaseDependency ) ; } return function ( store ) { if ( ! isWhat . isArray ( easyFirestoreModule ) ) easyFirestoreModule = [ easyFirestoreModule ] ; easyFirestoreModule . forEach ( function ( config ) { config . logging = logging ; if ( config . sync && config . sync . preventInitialDocInsertion === undefined ) { config . sync . preventInitialDocInsertion = preventInitialDocInsertion ; } var moduleName = vuexEasyAccess . getKeysFromPath ( config . moduleName ) ; store . registerModule ( moduleName , iniModule ( config , FirebaseDependency ) ) ; } ) ; } ; }
323	function parseCSV ( csvFilePath , attributeFields ) { return new Promise ( ( resolve , reject ) => { try { csv ( csvFilePath , data => resolve ( _transformToHierarchy ( data , attributeFields ) ) ) ; } catch ( err ) { reject ( err ) ; } } ) ; }
324	function parseJSON ( jsonFilePath ) { return new Promise ( ( resolve , reject ) => { try { json ( jsonFilePath , data => resolve ( [ data ] ) ) ; } catch ( err ) { reject ( err ) ; } } ) ; }
325	function parseFlatJSON ( jsonFilePath , attributeFields ) { return new Promise ( ( resolve , reject ) => { try { json ( jsonFilePath , data => resolve ( _transformToHierarchy ( data , attributeFields ) ) ) ; } catch ( err ) { reject ( err ) ; } } ) ; }
326	function checkPropTypes ( typeSpecs , values , location , componentName , getStack ) { if ( true ) { for ( var typeSpecName in typeSpecs ) { if ( typeSpecs . hasOwnProperty ( typeSpecName ) ) { var error ; try { if ( typeof typeSpecs [ typeSpecName ] !== 'function' ) { var err = Error ( ( componentName || 'React class' ) + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs [ typeSpecName ] + '`.' ) ; err . name = 'Invariant Violation' ; throw err ; } error = typeSpecs [ typeSpecName ] ( values , typeSpecName , componentName , location , null , ReactPropTypesSecret ) ; } catch ( ex ) { error = ex ; } if ( error && ! ( error instanceof Error ) ) { printWarning ( ( componentName || 'React class' ) + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).' ) } if ( error instanceof Error && ! ( error . message in loggedTypeFailures ) ) { loggedTypeFailures [ error . message ] = true ; var stack = getStack ? getStack ( ) : '' ; printWarning ( 'Failed ' + location + ' type: ' + error . message + ( stack != null ? stack : '' ) ) ; } } } } }
327	function invokeGuardedCallback ( name , func , context , a , b , c , d , e , f ) { hasError = false ; caughtError = null ; invokeGuardedCallbackImpl$1 . apply ( reporter , arguments ) ; }
328	function getClosestInstanceFromNode ( node ) { if ( node [ internalInstanceKey ] ) { return node [ internalInstanceKey ] ; } while ( ! node [ internalInstanceKey ] ) { if ( node . parentNode ) { node = node . parentNode ; } else { return null ; } } var inst = node [ internalInstanceKey ] ; if ( inst . tag === HostComponent || inst . tag === HostText ) { return inst ; } return null ; }
329	function getInstanceFromNode$1 ( node ) { var inst = node [ internalInstanceKey ] ; if ( inst ) { if ( inst . tag === HostComponent || inst . tag === HostText ) { return inst ; } else { return null ; } } return null ; }
330	function getNodeFromInstance$1 ( inst ) { if ( inst . tag === HostComponent || inst . tag === HostText ) { return inst . stateNode ; } invariant ( false , 'getNodeFromInstance: Invalid argument.' ) ; }
331	function traverseEnterLeave ( from , to , fn , argFrom , argTo ) { var common = from && to ? getLowestCommonAncestor ( from , to ) : null ; var pathFrom = [ ] ; while ( true ) { if ( ! from ) { break ; } if ( from === common ) { break ; } var alternate = from . alternate ; if ( alternate !== null && alternate === common ) { break ; } pathFrom . push ( from ) ; from = getParent ( from ) ; } var pathTo = [ ] ; while ( true ) { if ( ! to ) { break ; } if ( to === common ) { break ; } var _alternate = to . alternate ; if ( _alternate !== null && _alternate === common ) { break ; } pathTo . push ( to ) ; to = getParent ( to ) ; } for ( var i = 0 ; i < pathFrom . length ; i ++ ) { fn ( pathFrom [ i ] , 'bubbled' , argFrom ) ; } for ( var _i = pathTo . length ; _i -- > 0 ; ) { fn ( pathTo [ _i ] , 'captured' , argTo ) ; } }
332	function makePrefixMap ( styleProp , eventName ) { var prefixes = { } ; prefixes [ styleProp . toLowerCase ( ) ] = eventName . toLowerCase ( ) ; prefixes [ 'Webkit' + styleProp ] = 'webkit' + eventName ; prefixes [ 'Moz' + styleProp ] = 'moz' + eventName ; return prefixes ; }
333	function ( ) { var Interface = this . constructor . Interface ; for ( var propName in Interface ) { { Object . defineProperty ( this , propName , getPooledWarningPropertyDefinition ( propName , Interface [ propName ] ) ) ; } } this . dispatchConfig = null ; this . _targetInst = null ; this . nativeEvent = null ; this . isDefaultPrevented = functionThatReturnsFalse ; this . isPropagationStopped = functionThatReturnsFalse ; this . _dispatchListeners = null ; this . _dispatchInstances = null ; { Object . defineProperty ( this , 'nativeEvent' , getPooledWarningPropertyDefinition ( 'nativeEvent' , null ) ) ; Object . defineProperty ( this , 'isDefaultPrevented' , getPooledWarningPropertyDefinition ( 'isDefaultPrevented' , functionThatReturnsFalse ) ) ; Object . defineProperty ( this , 'isPropagationStopped' , getPooledWarningPropertyDefinition ( 'isPropagationStopped' , functionThatReturnsFalse ) ) ; Object . defineProperty ( this , 'preventDefault' , getPooledWarningPropertyDefinition ( 'preventDefault' , function ( ) { } ) ) ; Object . defineProperty ( this , 'stopPropagation' , getPooledWarningPropertyDefinition ( 'stopPropagation' , function ( ) { } ) ) ; } }
334	function getCompositionEventType ( topLevelType ) { switch ( topLevelType ) { case TOP_COMPOSITION_START : return eventTypes . compositionStart ; case TOP_COMPOSITION_END : return eventTypes . compositionEnd ; case TOP_COMPOSITION_UPDATE : return eventTypes . compositionUpdate ; } }
335	function isFallbackCompositionEnd ( topLevelType , nativeEvent ) { switch ( topLevelType ) { case TOP_KEY_UP : return END_KEYCODES . indexOf ( nativeEvent . keyCode ) !== - 1 ; case TOP_KEY_DOWN : return nativeEvent . keyCode !== START_KEYCODE ; case TOP_KEY_PRESS : case TOP_MOUSE_DOWN : case TOP_BLUR : return true ; default : return false ; } }
336	function getValueForProperty ( node , name , expected , propertyInfo ) { { if ( propertyInfo . mustUseProperty ) { var propertyName = propertyInfo . propertyName ; return node [ propertyName ] ; } else { var attributeName = propertyInfo . attributeName ; var stringValue = null ; if ( propertyInfo . type === OVERLOADED_BOOLEAN ) { if ( node . hasAttribute ( attributeName ) ) { var value = node . getAttribute ( attributeName ) ; if ( value === '' ) { return true ; } if ( shouldRemoveAttribute ( name , expected , propertyInfo , false ) ) { return value ; } if ( value === '' + expected ) { return expected ; } return value ; } } else if ( node . hasAttribute ( attributeName ) ) { if ( shouldRemoveAttribute ( name , expected , propertyInfo , false ) ) { return node . getAttribute ( attributeName ) ; } if ( propertyInfo . type === BOOLEAN ) { return expected ; } stringValue = node . getAttribute ( attributeName ) ; } if ( shouldRemoveAttribute ( name , expected , propertyInfo , false ) ) { return stringValue === null ? expected : stringValue ; } else if ( stringValue === '' + expected ) { return expected ; } else { return stringValue ; } } } }
337	function getTargetInstForInputEventPolyfill ( topLevelType , targetInst ) { if ( topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN ) { return getInstIfValueChanged ( activeElementInst ) ; } }
338	function ( topLevelType , targetInst , nativeEvent , nativeEventTarget ) { var isOverEvent = topLevelType === TOP_MOUSE_OVER || topLevelType === TOP_POINTER_OVER ; var isOutEvent = topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_POINTER_OUT ; if ( isOverEvent && ( nativeEvent . relatedTarget || nativeEvent . fromElement ) ) { return null ; } if ( ! isOutEvent && ! isOverEvent ) { return null ; } var win = void 0 ; if ( nativeEventTarget . window === nativeEventTarget ) { win = nativeEventTarget ; } else { var doc = nativeEventTarget . ownerDocument ; if ( doc ) { win = doc . defaultView || doc . parentWindow ; } else { win = window ; } } var from = void 0 ; var to = void 0 ; if ( isOutEvent ) { from = targetInst ; var related = nativeEvent . relatedTarget || nativeEvent . toElement ; to = related ? getClosestInstanceFromNode ( related ) : null ; } else { from = null ; to = targetInst ; } if ( from === to ) { return null ; } var eventInterface = void 0 , leaveEventType = void 0 , enterEventType = void 0 , eventTypePrefix = void 0 ; if ( topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_MOUSE_OVER ) { eventInterface = SyntheticMouseEvent ; leaveEventType = eventTypes$2 . mouseLeave ; enterEventType = eventTypes$2 . mouseEnter ; eventTypePrefix = 'mouse' ; } else if ( topLevelType === TOP_POINTER_OUT || topLevelType === TOP_POINTER_OVER ) { eventInterface = SyntheticPointerEvent ; leaveEventType = eventTypes$2 . pointerLeave ; enterEventType = eventTypes$2 . pointerEnter ; eventTypePrefix = 'pointer' ; } var fromNode = from == null ? win : getNodeFromInstance$1 ( from ) ; var toNode = to == null ? win : getNodeFromInstance$1 ( to ) ; var leave = eventInterface . getPooled ( leaveEventType , from , nativeEvent , nativeEventTarget ) ; leave . type = eventTypePrefix + 'leave' ; leave . target = fromNode ; leave . relatedTarget = toNode ; var enter = eventInterface . getPooled ( enterEventType , to , nativeEvent , nativeEventTarget ) ; enter . type = eventTypePrefix + 'enter' ; enter . target = toNode ; enter . relatedTarget = fromNode ; accumulateEnterLeaveDispatches ( leave , enter , from , to ) ; return [ leave , enter ] ; }
339	function listenTo ( registrationName , mountAt ) { var isListening = getListeningForDocument ( mountAt ) ; var dependencies = registrationNameDependencies [ registrationName ] ; for ( var i = 0 ; i < dependencies . length ; i ++ ) { var dependency = dependencies [ i ] ; if ( ! ( isListening . hasOwnProperty ( dependency ) && isListening [ dependency ] ) ) { switch ( dependency ) { case TOP_SCROLL : trapCapturedEvent ( TOP_SCROLL , mountAt ) ; break ; case TOP_FOCUS : case TOP_BLUR : trapCapturedEvent ( TOP_FOCUS , mountAt ) ; trapCapturedEvent ( TOP_BLUR , mountAt ) ; isListening [ TOP_BLUR ] = true ; isListening [ TOP_FOCUS ] = true ; break ; case TOP_CANCEL : case TOP_CLOSE : if ( isEventSupported ( getRawEventName ( dependency ) ) ) { trapCapturedEvent ( dependency , mountAt ) ; } break ; case TOP_INVALID : case TOP_SUBMIT : case TOP_RESET : break ; default : var isMediaEvent = mediaEventTypes . indexOf ( dependency ) !== - 1 ; if ( ! isMediaEvent ) { trapBubbledEvent ( dependency , mountAt ) ; } break ; } isListening [ dependency ] = true ; } } }
340	function getEventTargetDocument ( eventTarget ) { return eventTarget . window === eventTarget ? eventTarget . document : eventTarget . nodeType === DOCUMENT_NODE ? eventTarget : eventTarget . ownerDocument ; }
341	function constructSelectEvent ( nativeEvent , nativeEventTarget ) { var doc = getEventTargetDocument ( nativeEventTarget ) ; if ( mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement ( doc ) ) { return null ; } var currentSelection = getSelection ( activeElement$1 ) ; if ( ! lastSelection || ! shallowEqual ( lastSelection , currentSelection ) ) { lastSelection = currentSelection ; var syntheticEvent = SyntheticEvent . getPooled ( eventTypes$3 . select , activeElementInst$1 , nativeEvent , nativeEventTarget ) ; syntheticEvent . type = 'select' ; syntheticEvent . target = activeElement$1 ; accumulateTwoPhaseDispatches ( syntheticEvent ) ; return syntheticEvent ; } return null ; }
342	function ( node , text ) { if ( text ) { var firstChild = node . firstChild ; if ( firstChild && firstChild === node . lastChild && firstChild . nodeType === TEXT_NODE ) { firstChild . nodeValue = text ; return ; } } node . textContent = text ; }
343	function createDangerousStringForStyles ( styles ) { { var serialized = '' ; var delimiter = '' ; for ( var styleName in styles ) { if ( ! styles . hasOwnProperty ( styleName ) ) { continue ; } var styleValue = styles [ styleName ] ; if ( styleValue != null ) { var isCustomProperty = styleName . indexOf ( '--' ) === 0 ; serialized += delimiter + hyphenateStyleName ( styleName ) + ':' ; serialized += dangerousStyleValue ( styleName , styleValue , isCustomProperty ) ; delimiter = ';' ; } } return serialized || null ; } }
344	function ( containerChildSet , workInProgress ) { var node = workInProgress . child ; while ( node !== null ) { if ( node . tag === HostComponent || node . tag === HostText ) { appendChildToContainerChildSet ( containerChildSet , node . stateNode ) ; } else if ( node . tag === HostPortal ) { } else if ( node . child !== null ) { node . child . return = node ; node = node . child ; continue ; } if ( node === workInProgress ) { return ; } while ( node . sibling === null ) { if ( node . return === null || node . return === workInProgress ) { return ; } node = node . return ; } node . sibling . return = node . return ; node = node . sibling ; } }
345	function safelyCallComponentWillUnmount ( current$$1 , instance ) { { invokeGuardedCallback ( null , callComponentWillUnmountWithTimer , null , current$$1 , instance ) ; if ( hasCaughtError ( ) ) { var unmountError = clearCaughtError ( ) ; captureCommitPhaseError ( current$$1 , unmountError ) ; } } }
346	function computeUniqueAsyncExpiration ( ) { var currentTime = requestCurrentTime ( ) ; var result = computeAsyncExpiration ( currentTime ) ; if ( result <= lastUniqueAsyncExpiration ) { result = lastUniqueAsyncExpiration + 1 ; } lastUniqueAsyncExpiration = result ; return lastUniqueAsyncExpiration ; }
347	function stringify ( content ) { if ( typeof content === 'string' && stringifiedRegexp . test ( content ) ) { return content ; } return JSON . stringify ( content , null , 2 ) ; }
348	function getLoaderOptions ( loaderPath , rule ) { let multiRuleProp ; if ( isWebpack1 ) { multiRuleProp = 'loaders' ; } else if ( rule . oneOf ) { multiRuleProp = 'oneOf' ; } else { multiRuleProp = 'use' ; } const multiRule = typeof rule === 'object' && Array . isArray ( rule [ multiRuleProp ] ) ? rule [ multiRuleProp ] : null ; let options ; if ( multiRule ) { const rules = [ ] . concat ( ... multiRule . map ( r => ( r . use || r ) ) ) ; options = rules . map ( normalizeRule ) . find ( r => loaderPath . includes ( r . loader ) ) . options ; } else { options = normalizeRule ( rule ) . options ; } return options ; }
349	function normalizeRule ( rule ) { if ( ! rule ) { throw new Error ( 'Rule should be string or object' ) ; } let data ; if ( typeof rule === 'string' ) { const parts = rule . split ( '?' ) ; data = { loader : parts [ 0 ] , options : parts [ 1 ] ? parseQuery ( ` ${ parts [ 1 ] } ` ) : null } ; } else { const options = isWebpack1 ? rule . query : rule . options ; data = { loader : rule . loader , options : options || null } ; } return data ; }
350	function findParent ( node , handle ) { let current = node while ( current ) { if ( handle ( current ) ) { return current } current = current . parent } }
351	function pure ( node , withChildren , after ) { var _this2 = this ; var t = assign$1 ( { } , node ) ; delete t . _id ; delete t . parent ; delete t . children ; delete t . open ; delete t . active ; delete t . style ; delete t . class ; delete t . innerStyle ; delete t . innerClass ; delete t . innerBackStyle ; delete t . innerBackClass ; var _arr = keys$1 ( t ) ; for ( var _i = 0 ; _i < _arr . length ; _i ++ ) { var key = _arr [ _i ] ; if ( key [ 0 ] === '_' ) { delete t [ key ] ; } } if ( withChildren && node . children ) { t . children = node . children . slice ( ) ; t . children . forEach ( function ( v , k ) { t . children [ k ] = _this2 . pure ( v , withChildren ) ; } ) ; } if ( after ) { return after ( t , node ) || t ; } return t ; }
352	function offset2 ( ) { return { x : this . offset . x + this . nodeInnerEl . offsetWidth , y : this . offset . y + this . nodeInnerEl . offsetHeight } ; }
353	function offsetToViewPort ( ) { var r = this . nodeInnerEl . getBoundingClientRect ( ) ; r . x = r . left ; r . y = r . top ; return r ; }
354	function currentTreeRootSecondChildExcludingDragging ( ) { var _this = this ; return this . currentTree . rootData . children . slice ( 0 , 3 ) . filter ( function ( v ) { return v !== _this . node ; } ) [ 1 ] ; }
355	function appendPrev ( info ) { if ( isNodeDroppable ( info . targetPrev ) ) { th . appendTo ( info . dplh , info . targetPrev ) ; if ( ! info . targetPrev . open ) info . store . toggleOpen ( info . targetPrev ) ; } else { insertDplhAfterTo ( info . dplh , info . targetPrev , info ) ; } }
356	function appendCurrentTree ( info ) { if ( isNodeDroppable ( info . currentTree . rootData ) ) { th . appendTo ( info . dplh , info . currentTree . rootData ) ; } }
357	function stripViewFromSelector ( selector ) { const keepView = [ 'XCUIElementTypeScrollView' , 'XCUIElementTypeCollectionView' , 'XCUIElementTypeTextView' , 'XCUIElementTypeWebView' , ] . includes ( selector ) ; if ( ! keepView && selector . indexOf ( 'View' ) === selector . length - 4 ) { return selector . substr ( 0 , selector . length - 4 ) ; } else { return selector ; } }
358	async function getPidUsingPattern ( pgrepPattern ) { const args = [ '-nif' , pgrepPattern ] ; try { const { stdout } = await exec ( 'pgrep' , args ) ; const pid = parseInt ( stdout , 10 ) ; if ( isNaN ( pid ) ) { log . debug ( ` ${ args . join ( ' ' ) } ${ stdout } ` ) ; return null ; } return ` ${ pid } ` ; } catch ( err ) { log . debug ( ` ${ args . join ( ' ' ) } ${ err . code } ` ) ; return null ; } }
359	async function killAppUsingPattern ( pgrepPattern ) { for ( const signal of [ 2 , 15 , 9 ] ) { if ( ! await getPidUsingPattern ( pgrepPattern ) ) { return ; } const args = [ ` ${ signal } ` , '-if' , pgrepPattern ] ; try { await exec ( 'pkill' , args ) ; } catch ( err ) { log . debug ( ` ${ args . join ( ' ' ) } ${ err . message } ` ) ; } await B . delay ( 100 ) ; } }
360	async function getPIDsListeningOnPort ( port , filteringFunc = null ) { const result = [ ] ; try { const { stdout } = await exec ( 'lsof' , [ '-ti' , ` ${ port } ` ] ) ; result . push ( ... ( stdout . trim ( ) . split ( / \n+ / ) ) ) ; } catch ( e ) { return result ; } if ( ! _ . isFunction ( filteringFunc ) ) { return result ; } return await B . filter ( result , async ( x ) => { const { stdout } = await exec ( 'ps' , [ '-p' , x , '-o' , 'command' ] ) ; return await filteringFunc ( stdout ) ; } ) ; }
361	async function removeAllSessionWebSocketHandlers ( server , sessionId ) { if ( ! server || ! _ . isFunction ( server . getWebSocketHandlers ) ) { return ; } const activeHandlers = await server . getWebSocketHandlers ( sessionId ) ; for ( const pathname of _ . keys ( activeHandlers ) ) { await server . removeWebSocketHandler ( pathname ) ; } }
362	async function verifyApplicationPlatform ( app , isSimulator ) { log . debug ( 'Verifying application platform' ) ; const infoPlist = path . resolve ( app , 'Info.plist' ) ; if ( ! await fs . exists ( infoPlist ) ) { log . debug ( ` ${ infoPlist } ` ) ; return null ; } const { CFBundleSupportedPlatforms } = await plist . parsePlistFile ( infoPlist ) ; log . debug ( ` ${ JSON . stringify ( CFBundleSupportedPlatforms ) } ` ) ; if ( ! _ . isArray ( CFBundleSupportedPlatforms ) ) { log . debug ( ` ${ infoPlist } ` ) ; return null ; } const isAppSupported = ( isSimulator && CFBundleSupportedPlatforms . includes ( 'iPhoneSimulator' ) ) || ( ! isSimulator && CFBundleSupportedPlatforms . includes ( 'iPhoneOS' ) ) ; if ( isAppSupported ) { return true ; } throw new Error ( ` ${ isSimulator ? 'Simulator' : 'Real device' } ${ app } ` + ` ` ) ; }
363	function isLocalHost ( urlString ) { try { const { hostname } = url . parse ( urlString ) ; return [ 'localhost' , '127.0.0.1' , '::1' , '::ffff:127.0.0.1' ] . includes ( hostname ) ; } catch { log . warn ( ` ${ urlString } ` ) ; } return false ; }
364	function normalizePlatformVersion ( originalVersion ) { const normalizedVersion = util . coerceVersion ( originalVersion , false ) ; if ( ! normalizedVersion ) { throw new Error ( ` ${ originalVersion } ` ) ; } const { major , minor } = new semver . SemVer ( normalizedVersion ) ; return ` ${ major } ${ minor } ` ; }
365	async function updateProjectFile ( agentPath , newBundleId ) { let projectFilePath = ` ${ agentPath } ${ PROJECT_FILE } ` ; try { await fs . copyFile ( projectFilePath , ` ${ projectFilePath } ` ) ; await replaceInFile ( projectFilePath , new RegExp ( WDA_RUNNER_BUNDLE_ID . replace ( '.' , '\.' ) , \. ) , 'g' ) ; newBundleId } log . debug ( ` ${ projectFilePath } ${ newBundleId } ` ) ; }
366	async function resetProjectFile ( agentPath ) { let projectFilePath = ` ${ agentPath } ${ PROJECT_FILE } ` ; try { if ( ! await fs . exists ( ` ${ projectFilePath } ` ) ) { return ; } await fs . mv ( ` ${ projectFilePath } ` , projectFilePath ) ; log . debug ( ` ${ projectFilePath } ${ WDA_RUNNER_BUNDLE_ID } ` ) ; } catch ( err ) { log . debug ( ` ${ err . message } ` ) ; log . warn ( ` ${ projectFilePath } ` + ` ${ WDA_RUNNER_BUNDLE_ID } ` + ` ` ) ; } }
367	function getAdditionalRunContent ( platformName , wdaRemotePort ) { const runner = ` ${ isTvOS ( platformName ) ? '_tvOS' : '' } ` ; return { [ runner ] : { EnvironmentVariables : { USE_PORT : wdaRemotePort } } } ; }
368	async function getWDAUpgradeTimestamp ( bootstrapPath ) { const carthageRootPath = path . resolve ( bootstrapPath , CARTHAGE_ROOT ) ; if ( await fs . exists ( carthageRootPath ) ) { const { mtime } = await fs . stat ( carthageRootPath ) ; return mtime . getTime ( ) ; } return null ; }
369	async function parseContainerPath ( remotePath , containerRootSupplier ) { const match = CONTAINER_PATH_PATTERN . exec ( remotePath ) ; if ( ! match ) { log . errorAndThrow ( ` ` + ` ${ CONTAINER_PATH_MARKER } ` + ` ${ remotePath } ` ) ; } let [ , bundleId , relativePath ] = match ; let containerType = null ; const typeSeparatorPos = bundleId . indexOf ( CONTAINER_TYPE_SEPARATOR ) ; if ( typeSeparatorPos > 0 && typeSeparatorPos < bundleId . length - 1 ) { containerType = bundleId . substring ( typeSeparatorPos + 1 ) ; log . debug ( ` ${ containerType } ` ) ; bundleId = bundleId . substring ( 0 , typeSeparatorPos ) ; } const containerRoot = _ . isFunction ( containerRootSupplier ) ? await containerRootSupplier ( bundleId , containerType ) : containerRootSupplier ; const resultPath = path . posix . resolve ( containerRoot , relativePath ) ; verifyIsSubPath ( resultPath , containerRoot ) ; return [ bundleId , resultPath ] ; }
370	async function pushFileToSimulator ( device , remotePath , base64Data ) { const buffer = Buffer . from ( base64Data , 'base64' ) ; if ( CONTAINER_PATH_PATTERN . test ( remotePath ) ) { const [ bundleId , dstPath ] = await parseContainerPath ( remotePath , async ( appBundle , containerType ) => await getAppContainer ( device . udid , appBundle , null , containerType ) ) ; log . info ( ` ${ bundleId } ${ remotePath } ` + ` ${ dstPath } ` ) ; if ( ! await fs . exists ( path . dirname ( dstPath ) ) ) { log . debug ( ` ${ path . dirname ( dstPath ) } ` ) ; await mkdirp ( path . dirname ( dstPath ) ) ; } await fs . writeFile ( dstPath , buffer ) ; return ; } const dstFolder = await tempDir . openDir ( ) ; const dstPath = path . resolve ( dstFolder , path . basename ( remotePath ) ) ; try { await fs . writeFile ( dstPath , buffer ) ; await addMedia ( device . udid , dstPath ) ; } finally { await fs . rimraf ( dstFolder ) ; } }
371	async function pullFromSimulator ( device , remotePath , isFile ) { let pathOnServer ; if ( CONTAINER_PATH_PATTERN . test ( remotePath ) ) { const [ bundleId , dstPath ] = await parseContainerPath ( remotePath , async ( appBundle , containerType ) => await getAppContainer ( device . udid , appBundle , null , containerType ) ) ; log . info ( ` ${ bundleId } ${ remotePath } ` + ` ${ dstPath } ` ) ; pathOnServer = dstPath ; } else { const simRoot = device . getDir ( ) ; pathOnServer = path . posix . join ( simRoot , remotePath ) ; verifyIsSubPath ( pathOnServer , simRoot ) ; log . info ( ` ${ pathOnServer } ` ) ; } if ( ! await fs . exists ( pathOnServer ) ) { log . errorAndThrow ( ` ${ isFile ? 'file' : 'folder' } ${ pathOnServer } ` ) ; } const buffer = isFile ? await fs . readFile ( pathOnServer ) : await zip . toInMemoryZip ( pathOnServer ) ; return Buffer . from ( buffer ) . toString ( 'base64' ) ; }
372	async function pullFromRealDevice ( device , remotePath , isFile ) { await verifyIFusePresence ( ) ; const mntRoot = await tempDir . openDir ( ) ; let isUnmountSuccessful = true ; try { let dstPath = path . resolve ( mntRoot , remotePath ) ; let ifuseArgs = [ '-u' , device . udid , mntRoot ] ; if ( CONTAINER_PATH_PATTERN . test ( remotePath ) ) { const [ bundleId , pathInContainer ] = await parseContainerPath ( remotePath , mntRoot ) ; dstPath = pathInContainer ; log . info ( ` ${ bundleId } ${ remotePath } ` + ` ${ dstPath } ` ) ; ifuseArgs = [ '-u' , device . udid , '--container' , bundleId , mntRoot ] ; } else { verifyIsSubPath ( dstPath , mntRoot ) ; } await mountDevice ( device , ifuseArgs ) ; isUnmountSuccessful = false ; try { if ( ! await fs . exists ( dstPath ) ) { log . errorAndThrow ( ` ${ isFile ? 'file' : 'folder' } ${ dstPath } ` ) ; } const buffer = isFile ? await fs . readFile ( dstPath ) : await zip . toInMemoryZip ( dstPath ) ; return Buffer . from ( buffer ) . toString ( 'base64' ) ; } finally { await exec ( 'umount' , [ mntRoot ] ) ; isUnmountSuccessful = true ; } } finally { if ( isUnmountSuccessful ) { await fs . rimraf ( mntRoot ) ; } else { log . warn ( ` ${ mntRoot } ` ) ; } } }
373	async function createSim ( caps , platform = PLATFORM_NAME_IOS ) { const appiumTestDeviceName = ` ${ UUID . create ( ) . toString ( ) . toUpperCase ( ) } ${ caps . deviceName } ` ; const udid = await createDevice ( appiumTestDeviceName , caps . deviceName , caps . platformVersion , { platform } ) ; return await getSimulator ( udid ) ; }
374	async function getExistingSim ( opts ) { const devices = await getDevices ( opts . platformVersion ) ; const appiumTestDeviceName = ` ${ opts . deviceName } ` ; let appiumTestDevice ; for ( const device of _ . values ( devices ) ) { if ( device . name === opts . deviceName ) { return await getSimulator ( device . udid ) ; } if ( device . name === appiumTestDeviceName ) { appiumTestDevice = device ; } } if ( appiumTestDevice ) { log . warn ( ` ${ opts . deviceName } ${ appiumTestDevice . name } ${ appiumTestDevice . udid } ` ) ; return await getSimulator ( appiumTestDevice . udid ) ; } return null ; }
375	function ( ) { const data = this . data ; let objectEls ; if ( data . objects ) { objectEls = this . el . sceneEl . querySelectorAll ( data . objects ) ; } else { objectEls = this . el . sceneEl . children ; } this . els = Array . prototype . slice . call ( objectEls ) ; }
376	function intersect ( el ) { let radius , mesh , distance , extent ; if ( ! el . isEntity ) { return ; } mesh = el . getObject3D ( 'mesh' ) ; if ( ! mesh ) { return ; } box . setFromObject ( mesh ) . getSize ( size ) ; extent = Math . max ( size . x , size . y , size . z ) / 2 ; radius = Math . sqrt ( 2 * extent * extent ) ; box . getCenter ( meshPosition ) ; if ( ! radius ) { return ; } distance = position . distanceTo ( meshPosition ) ; if ( distance < radius + colliderRadius ) { collisions . push ( el ) ; distanceMap . set ( el , distance ) ; } }
377	function ( ) { const gamepad = this . getGamepad ( ) ; if ( ! gamepad . buttons [ GamepadButton . DPAD_RIGHT ] ) { return new THREE . Vector2 ( ) ; } return new THREE . Vector2 ( ( gamepad . buttons [ GamepadButton . DPAD_RIGHT ] . pressed ? 1 : 0 ) + ( gamepad . buttons [ GamepadButton . DPAD_LEFT ] . pressed ? - 1 : 0 ) , ( gamepad . buttons [ GamepadButton . DPAD_UP ] . pressed ? - 1 : 0 ) + ( gamepad . buttons [ GamepadButton . DPAD_DOWN ] . pressed ? 1 : 0 ) ) ; }
378	function URLSearchParamsPolyfill ( search ) { search = search || "" ; if ( search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill ) { search = search . toString ( ) ; } this [ __URLSearchParams__ ] = parseToDict ( search ) ; }
379	function RequestQueue ( opts ) { if ( ! opts || typeof ( opts ) !== 'object' ) { opts = { } ; } this . size = ( opts . size > 0 ) ? opts . size : Infinity ; this . timeout = ( opts . timeout > 0 ) ? opts . timeout : 0 ; this . _queue = [ ] ; this . _timer = null ; this . _frozen = false ; }
380	function MessageTracker ( opts ) { assert . object ( opts ) ; assert . string ( opts . id ) ; assert . object ( opts . parser ) ; this . id = opts . id ; this . _msgid = 0 ; this . _messages = { } ; this . _abandoned = { } ; this . parser = opts . parser ; var self = this ; this . __defineGetter__ ( 'pending' , function ( ) { return Object . keys ( self . _messages ) ; } ) ; }
381	function connectSocket ( cb ) { cb = once ( cb ) ; function onResult ( err , res ) { if ( err ) { if ( self . connectTimer ) { clearTimeout ( self . connectTimer ) ; self . connectTimer = null ; } self . emit ( 'connectError' , err ) ; } cb ( err , res ) ; } function onConnect ( ) { if ( self . connectTimer ) { clearTimeout ( self . connectTimer ) ; self . connectTimer = null ; } socket . removeAllListeners ( 'error' ) . removeAllListeners ( 'connect' ) . removeAllListeners ( 'secureConnect' ) ; tracker . id = nextClientId ( ) + '__' + tracker . id ; self . log = self . log . child ( { ldap_id : tracker . id } , true ) ; setupClient ( cb ) ; } var port = ( self . port || self . socketPath ) ; if ( self . secure ) { socket = tls . connect ( port , self . host , self . tlsOptions ) ; socket . once ( 'secureConnect' , onConnect ) ; } else { socket = net . connect ( port , self . host ) ; socket . once ( 'connect' , onConnect ) ; } socket . once ( 'error' , onResult ) ; initSocket ( ) ; if ( self . connectTimeout ) { self . connectTimer = setTimeout ( function onConnectTimeout ( ) { if ( ! socket || ! socket . readable || ! socket . writeable ) { socket . destroy ( ) ; self . _socket = null ; onResult ( new ConnectionError ( 'connection timeout' ) ) ; } } , self . connectTimeout ) ; } }
382	function initSocket ( ) { tracker = new MessageTracker ( { id : self . url ? self . url . href : self . socketPath , parser : new Parser ( { log : log } ) } ) ; if ( typeof ( socket . setKeepAlive ) !== 'function' ) { socket . setKeepAlive = function setKeepAlive ( enable , delay ) { return socket . socket ? socket . socket . setKeepAlive ( enable , delay ) : false ; } ; } socket . on ( 'data' , function onData ( data ) { if ( log . trace ( ) ) log . trace ( 'data event: %s' , util . inspect ( data ) ) ; tracker . parser . write ( data ) ; } ) ; tracker . parser . on ( 'message' , function onMessage ( message ) { message . connection = self . _socket ; var callback = tracker . fetch ( message . messageID ) ; if ( ! callback ) { log . error ( { message : message . json } , 'unsolicited message' ) ; return false ; } return callback ( message ) ; } ) ; tracker . parser . on ( 'error' , function onParseError ( err ) { self . emit ( 'error' , new VError ( err , 'Parser error for %s' , tracker . id ) ) ; self . connected = false ; socket . end ( ) ; } ) ; }
383	function setupClient ( cb ) { cb = once ( cb ) ; function bail ( err ) { socket . destroy ( ) ; cb ( err || new Error ( 'client error during setup' ) ) ; } ( ( socket . socket ) ? socket . socket : socket ) . once ( 'close' , bail ) ; socket . once ( 'error' , bail ) ; socket . once ( 'end' , bail ) ; socket . once ( 'timeout' , bail ) ; self . _socket = socket ; self . _tracker = tracker ; var basicClient = { bind : function bindBypass ( name , credentials , controls , callback ) { return self . bind ( name , credentials , controls , callback , true ) ; } , search : function searchBypass ( base , options , controls , callback ) { return self . search ( base , options , controls , callback , true ) ; } , starttls : function starttlsBypass ( options , controls , callback ) { return self . starttls ( options , controls , callback , true ) ; } , unbind : self . unbind . bind ( self ) } ; vasync . forEachPipeline ( { func : function ( f , callback ) { f ( basicClient , callback ) ; } , inputs : self . listeners ( 'setup' ) } , function ( err , res ) { if ( err ) { self . emit ( 'setupError' , err ) ; } cb ( err ) ; } ) ; }
384	function Graph ( gridIn , options ) { options = options || { } ; this . nodes = [ ] ; this . diagonal = ! ! options . diagonal ; this . grid = [ ] ; for ( var x = 0 ; x < gridIn . length ; x ++ ) { this . grid [ x ] = [ ] ; for ( var y = 0 , row = gridIn [ x ] ; y < row . length ; y ++ ) { var node = new GridNode ( x , y , row [ y ] ) ; this . grid [ x ] [ y ] = node ; this . nodes . push ( node ) ; } } this . init ( ) ; }
385	function ( path , i ) { if ( i >= path . length ) { return setStartClass ( path , i ) ; } elementFromNode ( path [ i ] ) . removeClass ( css . active ) ; setTimeout ( function ( ) { removeClass ( path , i + 1 ) ; } , timeout * path [ i ] . getCost ( ) ) ; }
386	function forEach ( array , callback ) { if ( array ) { for ( var i = 0 , len = array . length ; i < len ; i ++ ) { var result = callback ( array [ i ] , i ) ; if ( result ) { return result ; } } } return undefined ; }
387	function arrayToMap ( array , makeKey ) { var result = { } ; forEach ( array , function ( value ) { result [ makeKey ( value ) ] = value ; } ) ; return result ; }
388	function createWatchedFileSet ( interval , chunkSize ) { if ( interval === void 0 ) { interval = 2500 ; } if ( chunkSize === void 0 ) { chunkSize = 30 ; } var watchedFiles = [ ] ; var nextFileToCheck = 0 ; var watchTimer ; function getModifiedTime ( fileName ) { return _fs . statSync ( fileName ) . mtime ; } function poll ( checkedIndex ) { var watchedFile = watchedFiles [ checkedIndex ] ; if ( ! watchedFile ) { return ; } _fs . stat ( watchedFile . fileName , function ( err , stats ) { if ( err ) { watchedFile . callback ( watchedFile . fileName ) ; } else if ( watchedFile . mtime . getTime ( ) !== stats . mtime . getTime ( ) ) { watchedFile . mtime = getModifiedTime ( watchedFile . fileName ) ; watchedFile . callback ( watchedFile . fileName , watchedFile . mtime . getTime ( ) === 0 ) ; } } ) ; } function startWatchTimer ( ) { watchTimer = setInterval ( function ( ) { var count = 0 ; var nextToCheck = nextFileToCheck ; var firstCheck = - 1 ; while ( ( count < chunkSize ) && ( nextToCheck !== firstCheck ) ) { poll ( nextToCheck ) ; if ( firstCheck < 0 ) { firstCheck = nextToCheck ; } nextToCheck ++ ; if ( nextToCheck === watchedFiles . length ) { nextToCheck = 0 ; } count ++ ; } nextFileToCheck = nextToCheck ; } , interval ) ; } function addFile ( fileName , callback ) { var file = { fileName : fileName , callback : callback , mtime : getModifiedTime ( fileName ) } ; watchedFiles . push ( file ) ; if ( watchedFiles . length === 1 ) { startWatchTimer ( ) ; } return file ; } function removeFile ( file ) { watchedFiles = ts . copyListRemovingItem ( file , watchedFiles ) ; } return { getModifiedTime : getModifiedTime , poll : poll , startWatchTimer : startWatchTimer , addFile : addFile , removeFile : removeFile } ; }
389	function startWatchTimer ( ) { watchTimer = setInterval ( function ( ) { var count = 0 ; var nextToCheck = nextFileToCheck ; var firstCheck = - 1 ; while ( ( count < chunkSize ) && ( nextToCheck !== firstCheck ) ) { poll ( nextToCheck ) ; if ( firstCheck < 0 ) { firstCheck = nextToCheck ; } nextToCheck ++ ; if ( nextToCheck === watchedFiles . length ) { nextToCheck = 0 ; } count ++ ; } nextFileToCheck = nextToCheck ; } , interval ) ; }
390	function scanTemplateAndSetTokenValue ( ) { var startedWithBacktick = text . charCodeAt ( pos ) === 96 ; pos ++ ; var start = pos ; var contents = "" ; var resultingToken ; while ( true ) { if ( pos >= end ) { contents += text . substring ( start , pos ) ; tokenIsUnterminated = true ; error ( ts . Diagnostics . Unterminated_template_literal ) ; resultingToken = startedWithBacktick ? 11 : 14 ; break ; } var currChar = text . charCodeAt ( pos ) ; if ( currChar === 96 ) { contents += text . substring ( start , pos ) ; pos ++ ; resultingToken = startedWithBacktick ? 11 : 14 ; break ; } if ( currChar === 36 && pos + 1 < end && text . charCodeAt ( pos + 1 ) === 123 ) { contents += text . substring ( start , pos ) ; pos += 2 ; resultingToken = startedWithBacktick ? 12 : 13 ; break ; } if ( currChar === 92 ) { contents += text . substring ( start , pos ) ; contents += scanEscapeSequence ( ) ; start = pos ; continue ; } if ( currChar === 13 ) { contents += text . substring ( start , pos ) ; pos ++ ; if ( pos < end && text . charCodeAt ( pos ) === 10 ) { pos ++ ; } contents += "\n" ; \n start = pos ; } continue ; } pos ++ ; ts . Debug . assert ( resultingToken !== undefined ) ; tokenValue = contents ; }
391	function utf16EncodeAsString ( codePoint ) { ts . Debug . assert ( 0x0 <= codePoint && codePoint <= 0x10FFFF ) ; if ( codePoint <= 65535 ) { return String . fromCharCode ( codePoint ) ; } var codeUnit1 = Math . floor ( ( codePoint - 65536 ) / 1024 ) + 0xD800 ; var codeUnit2 = ( ( codePoint - 65536 ) % 1024 ) + 0xDC00 ; return String . fromCharCode ( codeUnit1 , codeUnit2 ) ; }
392	function peekUnicodeEscape ( ) { if ( pos + 5 < end && text . charCodeAt ( pos + 1 ) === 117 ) { var start_1 = pos ; pos += 2 ; var value = scanExactNumberOfHexDigits ( 4 ) ; pos = start_1 ; return value ; } return - 1 ; }
393	function scanJsxIdentifier ( ) { if ( tokenIsIdentifierOrKeyword ( token ) ) { var firstCharPosition = pos ; while ( pos < end ) { var ch = text . charCodeAt ( pos ) ; if ( ch === 45 || ( ( firstCharPosition === pos ) ? isIdentifierStart ( ch , languageVersion ) : isIdentifierPart ( ch , languageVersion ) ) ) { pos ++ ; } else { break ; } } tokenValue += text . substr ( firstCharPosition , pos - firstCharPosition ) ; } return token ; }
394	function getDeclarationName ( node ) { if ( node . name ) { if ( node . kind === 218 && node . name . kind === 9 ) { return "\"" + \" + node . name . text ; } "\"" \" } if ( node . name . kind === 136 ) { var nameExpression = node . name . expression ; ts . Debug . assert ( ts . isWellKnownSymbolSyntactically ( nameExpression ) ) ; return ts . getPropertyNameForKnownSymbolName ( nameExpression . name . text ) ; } }
395	function bindChildren ( node ) { var saveParent = parent ; var saveContainer = container ; var savedBlockScopeContainer = blockScopeContainer ; parent = node ; var containerFlags = getContainerFlags ( node ) ; if ( containerFlags & 1 ) { container = blockScopeContainer = node ; if ( containerFlags & 4 ) { container . locals = { } ; } addToContainerChain ( container ) ; } else if ( containerFlags & 2 ) { blockScopeContainer = node ; blockScopeContainer . locals = undefined ; } if ( node . kind === 215 ) { seenThisKeyword = false ; ts . forEachChild ( node , bind ) ; node . flags = seenThisKeyword ? node . flags | 524288 : node . flags & ~ 524288 ; } else { ts . forEachChild ( node , bind ) ; } container = saveContainer ; parent = saveParent ; blockScopeContainer = savedBlockScopeContainer ; }
396	function nodePosToString ( node ) { var file = getSourceFileOfNode ( node ) ; var loc = ts . getLineAndCharacterOfPosition ( file , node . pos ) ; return file . fileName + "(" + ( loc . line + 1 ) + "," + ( loc . character + 1 ) + ")" ; }
397	function unescapeIdentifier ( identifier ) { return identifier . length >= 3 && identifier . charCodeAt ( 0 ) === 95 && identifier . charCodeAt ( 1 ) === 95 && identifier . charCodeAt ( 2 ) === 95 ? identifier . substr ( 1 ) : identifier ; }
398	function getEnclosingBlockScopeContainer ( node ) { var current = node . parent ; while ( current ) { if ( isFunctionLike ( current ) ) { return current ; } switch ( current . kind ) { case 248 : case 220 : case 244 : case 218 : case 199 : case 200 : case 201 : return current ; case 192 : if ( ! isFunctionLike ( current . parent ) ) { return current ; } } current = current . parent ; } }
399	function isDeclarationName ( name ) { if ( name . kind !== 69 && name . kind !== 9 && name . kind !== 8 ) { return false ; } var parent = name . parent ; if ( parent . kind === 226 || parent . kind === 230 ) { if ( parent . propertyName ) { return true ; } } if ( isDeclaration ( parent ) ) { return parent . name === name ; } return false ; }
400	function isIdentifierName ( node ) { var parent = node . parent ; switch ( parent . kind ) { case 141 : case 140 : case 143 : case 142 : case 145 : case 146 : case 247 : case 245 : case 166 : return parent . name === node ; case 135 : if ( parent . right === node ) { while ( parent . kind === 135 ) { parent = parent . parent ; } return parent . kind === 154 ; } return false ; case 163 : case 226 : return parent . propertyName === node ; case 230 : return true ; } return false ; }
401	function getExpandedCharCodes ( input ) { var output = [ ] ; var length = input . length ; for ( var i = 0 ; i < length ; i ++ ) { var charCode = input . charCodeAt ( i ) ; if ( charCode < 0x80 ) { output . push ( charCode ) ; } else if ( charCode < 0x800 ) { output . push ( ( charCode >> 6 ) | 192 ) ; output . push ( ( charCode & 63 ) | 128 ) ; } else if ( charCode < 0x10000 ) { output . push ( ( charCode >> 12 ) | 224 ) ; output . push ( ( ( charCode >> 6 ) & 63 ) | 128 ) ; output . push ( ( charCode & 63 ) | 128 ) ; } else if ( charCode < 0x20000 ) { output . push ( ( charCode >> 18 ) | 240 ) ; output . push ( ( ( charCode >> 12 ) & 63 ) | 128 ) ; output . push ( ( ( charCode >> 6 ) & 63 ) | 128 ) ; output . push ( ( charCode & 63 ) | 128 ) ; } else { ts . Debug . assert ( false , "Unexpected code point" ) ; } } return output ; }
402	function textSpanContainsTextSpan ( span , other ) { return other . start >= span . start && textSpanEnd ( other ) <= textSpanEnd ( span ) ; }
403	function isListTerminator ( kind ) { if ( token === 1 ) { return true ; } switch ( kind ) { case 1 : case 2 : case 4 : case 5 : case 6 : case 12 : case 9 : case 21 : return token === 16 ; case 3 : return token === 16 || token === 71 || token === 77 ; case 7 : return token === 15 || token === 83 || token === 106 ; case 8 : return isVariableDeclaratorListTerminator ( ) ; case 17 : return token === 27 || token === 17 || token === 15 || token === 83 || token === 106 ; case 11 : return token === 18 || token === 23 ; case 15 : case 19 : case 10 : return token === 20 ; case 16 : return token === 18 || token === 20 ; case 18 : return token === 27 || token === 17 ; case 20 : return token === 15 || token === 16 ; case 13 : return token === 27 || token === 39 ; case 14 : return token === 25 && lookAhead ( nextTokenIsSlash ) ; case 22 : return token === 18 || token === 54 || token === 16 ; case 23 : return token === 27 || token === 16 ; case 25 : return token === 20 || token === 16 ; case 24 : return token === 16 ; } }
404	function parseEntityName ( allowReservedWords , diagnosticMessage ) { var entity = parseIdentifier ( diagnosticMessage ) ; while ( parseOptional ( 21 ) ) { var node = createNode ( 135 , entity . pos ) ; node . left = entity ; node . right = parseRightSideOfDot ( allowReservedWords ) ; entity = finishNode ( node ) ; } return entity ; }
405	function findHighestListElementThatStartsAtPosition ( position ) { currentArray = undefined ; currentArrayIndex = - 1 ; current = undefined ; forEachChild ( sourceFile , visitNode , visitArray ) ; return ; function visitNode ( node ) { if ( position >= node . pos && position < node . end ) { forEachChild ( node , visitNode , visitArray ) ; return true ; } return false ; } function visitArray ( array ) { if ( position >= array . pos && position < array . end ) { for ( var i = 0 , n = array . length ; i < n ; i ++ ) { var child = array [ i ] ; if ( child ) { if ( child . pos === position ) { currentArray = array ; currentArrayIndex = i ; current = child ; return true ; } else { if ( child . pos < position && position < child . end ) { forEachChild ( child , visitNode , visitArray ) ; return true ; } } } } } return false ; } }
406	function getSymbolOfPartOfRightHandSideOfImportEquals ( entityName , importDeclaration ) { if ( ! importDeclaration ) { importDeclaration = ts . getAncestor ( entityName , 221 ) ; ts . Debug . assert ( importDeclaration !== undefined ) ; } if ( entityName . kind === 69 && ts . isRightSideOfQualifiedNameOrPropertyAccess ( entityName ) ) { entityName = entityName . parent ; } if ( entityName . kind === 69 || entityName . parent . kind === 135 ) { return resolveEntityName ( entityName , 1536 ) ; } else { ts . Debug . assert ( entityName . parent . kind === 221 ) ; return resolveEntityName ( entityName , 107455 | 793056 | 1536 ) ; } }
407	function resolveEntityName ( name , meaning , ignoreErrors ) { if ( ts . nodeIsMissing ( name ) ) { return undefined ; } var symbol ; if ( name . kind === 69 ) { var message = meaning === 1536 ? ts . Diagnostics . Cannot_find_namespace_0 : ts . Diagnostics . Cannot_find_name_0 ; symbol = resolveName ( name , name . text , meaning , ignoreErrors ? undefined : message , name ) ; if ( ! symbol ) { return undefined ; } } else if ( name . kind === 135 || name . kind === 166 ) { var left = name . kind === 135 ? name . left : name . expression ; var right = name . kind === 135 ? name . right : name . name ; var namespace = resolveEntityName ( left , 1536 , ignoreErrors ) ; if ( ! namespace || namespace === unknownSymbol || ts . nodeIsMissing ( right ) ) { return undefined ; } symbol = getSymbol ( getExportsOfSymbol ( namespace ) , right . text , meaning ) ; if ( ! symbol ) { if ( ! ignoreErrors ) { error ( right , ts . Diagnostics . Module_0_has_no_exported_member_1 , getFullyQualifiedName ( namespace ) , ts . declarationNameToString ( right ) ) ; } return undefined ; } } else { ts . Debug . fail ( "Unknown entity name kind." ) ; } ts . Debug . assert ( ( symbol . flags & 16777216 ) === 0 , "Should never get an instantiated symbol here." ) ; return symbol . flags & meaning ? symbol : resolveAlias ( symbol ) ; }
408	function isReservedMemberName ( name ) { return name . charCodeAt ( 0 ) === 95 && name . charCodeAt ( 1 ) === 95 && name . charCodeAt ( 2 ) !== 95 && name . charCodeAt ( 2 ) !== 64 ; }
409	function isSymbolUsedInExportAssignment ( symbol ) { if ( exportAssignmentSymbol === symbol ) { return true ; } if ( exportAssignmentSymbol && ! ! ( exportAssignmentSymbol . flags & 8388608 ) ) { resolvedExportSymbol = resolvedExportSymbol || resolveAlias ( exportAssignmentSymbol ) ; if ( resolvedExportSymbol === symbol ) { return true ; } return ts . forEach ( resolvedExportSymbol . declarations , function ( current ) { while ( current ) { if ( current === node ) { return true ; } current = current . parent ; } } ) ; } }
410	function getTypeOfPropertyOfType ( type , name ) { var prop = getPropertyOfType ( type , name ) ; return prop ? getTypeOfSymbol ( prop ) : undefined ; }
411	function getTypeForBindingElementParent ( node ) { var symbol = getSymbolOfNode ( node ) ; return symbol && getSymbolLinks ( symbol ) . type || getTypeForVariableLikeDeclaration ( node ) ; }
412	function getTypeForBindingElement ( declaration ) { var pattern = declaration . parent ; var parentType = getTypeForBindingElementParent ( pattern . parent ) ; if ( parentType === unknownType ) { return unknownType ; } if ( ! parentType || isTypeAny ( parentType ) ) { if ( declaration . initializer ) { return checkExpressionCached ( declaration . initializer ) ; } return parentType ; } var type ; if ( pattern . kind === 161 ) { var name_10 = declaration . propertyName || declaration . name ; type = getTypeOfPropertyOfType ( parentType , name_10 . text ) || isNumericLiteralName ( name_10 . text ) && getIndexTypeOfType ( parentType , 1 ) || getIndexTypeOfType ( parentType , 0 ) ; if ( ! type ) { error ( name_10 , ts . Diagnostics . Type_0_has_no_property_1_and_no_string_index_signature , typeToString ( parentType ) , ts . declarationNameToString ( name_10 ) ) ; return unknownType ; } } else { var elementType = checkIteratedTypeOrElementType ( parentType , pattern , false ) ; if ( ! declaration . dotDotDotToken ) { var propName = "" + ts . indexOf ( pattern . elements , declaration ) ; type = isTupleLikeType ( parentType ) ? getTypeOfPropertyOfType ( parentType , propName ) : elementType ; if ( ! type ) { if ( isTupleType ( parentType ) ) { error ( declaration , ts . Diagnostics . Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2 , typeToString ( parentType ) , parentType . elementTypes . length , pattern . elements . length ) ; } else { error ( declaration , ts . Diagnostics . Type_0_has_no_property_1 , typeToString ( parentType ) , propName ) ; } return unknownType ; } } else { type = createArrayType ( elementType ) ; } } return type ; }
413	function getTypeForVariableLikeDeclaration ( declaration ) { if ( declaration . parent . parent . kind === 200 ) { return anyType ; } if ( declaration . parent . parent . kind === 201 ) { return checkRightHandSideOfForOf ( declaration . parent . parent . expression ) || anyType ; } if ( ts . isBindingPattern ( declaration . parent ) ) { return getTypeForBindingElement ( declaration ) ; } if ( declaration . type ) { return getTypeFromTypeNode ( declaration . type ) ; } if ( declaration . kind === 138 ) { var func = declaration . parent ; if ( func . kind === 146 && ! ts . hasDynamicName ( func ) ) { var getter = ts . getDeclarationOfKind ( declaration . parent . symbol , 145 ) ; if ( getter ) { return getReturnTypeOfSignature ( getSignatureFromDeclaration ( getter ) ) ; } } var type = getContextuallyTypedParameterType ( declaration ) ; if ( type ) { return type ; } } if ( declaration . initializer ) { return checkExpressionCached ( declaration . initializer ) ; } if ( declaration . kind === 246 ) { return checkIdentifier ( declaration . name ) ; } if ( ts . isBindingPattern ( declaration . name ) ) { return getTypeFromBindingPattern ( declaration . name , false ) ; } return undefined ; }
414	function getTypeFromBindingElement ( element , includePatternInType ) { if ( element . initializer ) { return getWidenedType ( checkExpressionCached ( element . initializer ) ) ; } if ( ts . isBindingPattern ( element . name ) ) { return getTypeFromBindingPattern ( element . name , includePatternInType ) ; } return anyType ; }
415	function getTypeFromObjectBindingPattern ( pattern , includePatternInType ) { var members = { } ; ts . forEach ( pattern . elements , function ( e ) { var flags = 4 | 67108864 | ( e . initializer ? 536870912 : 0 ) ; var name = e . propertyName || e . name ; var symbol = createSymbol ( flags , name . text ) ; symbol . type = getTypeFromBindingElement ( e , includePatternInType ) ; symbol . bindingElement = e ; members [ symbol . name ] = symbol ; } ) ; var result = createAnonymousType ( undefined , members , emptyArray , emptyArray , undefined , undefined ) ; if ( includePatternInType ) { result . pattern = pattern ; } return result ; }
416	function getLocalTypeParametersOfClassOrInterfaceOrTypeAlias ( symbol ) { var result ; for ( var _i = 0 , _a = symbol . declarations ; _i < _a . length ; _i ++ ) { var node = _a [ _i ] ; if ( node . kind === 215 || node . kind === 214 || node . kind === 186 || node . kind === 216 ) { var declaration = node ; if ( declaration . typeParameters ) { result = appendTypeParameters ( result , declaration . typeParameters ) ; } } } return result ; }
417	function getBaseConstructorTypeOfClass ( type ) { if ( ! type . resolvedBaseConstructorType ) { var baseTypeNode = getBaseTypeNodeOfClass ( type ) ; if ( ! baseTypeNode ) { return type . resolvedBaseConstructorType = undefinedType ; } if ( ! pushTypeResolution ( type , 1 ) ) { return unknownType ; } var baseConstructorType = checkExpression ( baseTypeNode . expression ) ; if ( baseConstructorType . flags & 80896 ) { resolveStructuredTypeMembers ( baseConstructorType ) ; } if ( ! popTypeResolution ( ) ) { error ( type . symbol . valueDeclaration , ts . Diagnostics . _0_is_referenced_directly_or_indirectly_in_its_own_base_expression , symbolToString ( type . symbol ) ) ; return type . resolvedBaseConstructorType = unknownType ; } if ( baseConstructorType !== unknownType && baseConstructorType !== nullType && ! isConstructorType ( baseConstructorType ) ) { error ( baseTypeNode . expression , ts . Diagnostics . Type_0_is_not_a_constructor_function_type , typeToString ( baseConstructorType ) ) ; return type . resolvedBaseConstructorType = unknownType ; } type . resolvedBaseConstructorType = baseConstructorType ; } return type . resolvedBaseConstructorType ; }
418	function isIndependentTypeReference ( node ) { if ( node . typeArguments ) { for ( var _i = 0 , _a = node . typeArguments ; _i < _a . length ; _i ++ ) { var typeNode = _a [ _i ] ; if ( ! isIndependentType ( typeNode ) ) { return false ; } } } return true ; }
419	function createInstantiatedSymbolTable ( symbols , mapper , mappingThisOnly ) { var result = { } ; for ( var _i = 0 ; _i < symbols . length ; _i ++ ) { var symbol = symbols [ _i ] ; result [ symbol . name ] = mappingThisOnly && isIndependentMember ( symbol ) ? symbol : instantiateSymbol ( symbol , mapper ) ; } return result ; }
420	function getUnionSignatures ( types , kind ) { var signatureLists = ts . map ( types , function ( t ) { return getSignaturesOfType ( t , kind ) ; } ) ; var result = undefined ; for ( var i = 0 ; i < signatureLists . length ; i ++ ) { for ( var _i = 0 , _a = signatureLists [ i ] ; _i < _a . length ; _i ++ ) { var signature = _a [ _i ] ; if ( ! result || ! findMatchingSignature ( result , signature , false , true ) ) { var unionSignatures = findMatchingSignatures ( signatureLists , signature , i ) ; if ( unionSignatures ) { var s = signature ; if ( unionSignatures . length > 1 ) { s = cloneSignature ( signature ) ; s . resolvedReturnType = undefined ; s . unionSignatures = unionSignatures ; } ( result || ( result = [ ] ) ) . push ( s ) ; } } } } return result || emptyArray ; }
421	function getPropertyOfObjectType ( type , name ) { if ( type . flags & 80896 ) { var resolved = resolveStructuredTypeMembers ( type ) ; if ( ts . hasProperty ( resolved . members , name ) ) { var symbol = resolved . members [ name ] ; if ( symbolIsValue ( symbol ) ) { return symbol ; } } } }
422	function getApparentType ( type ) { if ( type . flags & 512 ) { do { type = getConstraintOfTypeParameter ( type ) ; } while ( type && type . flags & 512 ) ; if ( ! type ) { type = emptyObjectType ; } } if ( type . flags & 258 ) { type = globalStringType ; } else if ( type . flags & 132 ) { type = globalNumberType ; } else if ( type . flags & 8 ) { type = globalBooleanType ; } else if ( type . flags & 16777216 ) { type = globalESSymbolType ; } return type ; }
423	function getPropertyOfType ( type , name ) { type = getApparentType ( type ) ; if ( type . flags & 80896 ) { var resolved = resolveStructuredTypeMembers ( type ) ; if ( ts . hasProperty ( resolved . members , name ) ) { var symbol = resolved . members [ name ] ; if ( symbolIsValue ( symbol ) ) { return symbol ; } } if ( resolved === anyFunctionType || resolved . callSignatures . length || resolved . constructSignatures . length ) { var symbol = getPropertyOfObjectType ( globalFunctionType , name ) ; if ( symbol ) { return symbol ; } } return getPropertyOfObjectType ( globalObjectType , name ) ; } if ( type . flags & 49152 ) { return getPropertyOfUnionOrIntersectionType ( type , name ) ; } return undefined ; }
424	function getPropagatingFlagsOfTypes ( types ) { var result = 0 ; for ( var _i = 0 ; _i < types . length ; _i ++ ) { var type = types [ _i ] ; result |= type . flags ; } return result & 14680064 ; }
425	function getTypeFromClassOrInterfaceReference ( node , symbol ) { var type = getDeclaredTypeOfSymbol ( symbol ) ; var typeParameters = type . localTypeParameters ; if ( typeParameters ) { if ( ! node . typeArguments || node . typeArguments . length !== typeParameters . length ) { error ( node , ts . Diagnostics . Generic_type_0_requires_1_type_argument_s , typeToString ( type , undefined , 1 ) , typeParameters . length ) ; return unknownType ; } return createTypeReference ( type , ts . concatenate ( type . outerTypeParameters , ts . map ( node . typeArguments , getTypeFromTypeNode ) ) ) ; } if ( node . typeArguments ) { error ( node , ts . Diagnostics . Type_0_is_not_generic , typeToString ( type ) ) ; return unknownType ; } return type ; }
426	function getTypeFromTypeAliasReference ( node , symbol ) { var type = getDeclaredTypeOfSymbol ( symbol ) ; var links = getSymbolLinks ( symbol ) ; var typeParameters = links . typeParameters ; if ( typeParameters ) { if ( ! node . typeArguments || node . typeArguments . length !== typeParameters . length ) { error ( node , ts . Diagnostics . Generic_type_0_requires_1_type_argument_s , symbolToString ( symbol ) , typeParameters . length ) ; return unknownType ; } var typeArguments = ts . map ( node . typeArguments , getTypeFromTypeNode ) ; var id = getTypeListId ( typeArguments ) ; return links . instantiations [ id ] || ( links . instantiations [ id ] = instantiateType ( type , createTypeMapper ( typeParameters , typeArguments ) ) ) ; } if ( node . typeArguments ) { error ( node , ts . Diagnostics . Type_0_is_not_generic , symbolToString ( symbol ) ) ; return unknownType ; } return type ; }
427	function addTypesToSet ( typeSet , types , typeSetKind ) { for ( var _i = 0 ; _i < types . length ; _i ++ ) { var type = types [ _i ] ; addTypeToSet ( typeSet , type , typeSetKind ) ; } }
428	function isKnownProperty ( type , name ) { if ( type . flags & 80896 ) { var resolved = resolveStructuredTypeMembers ( type ) ; if ( relation === assignableRelation && ( type === globalObjectType || resolved . properties . length === 0 ) || resolved . stringIndexType || resolved . numberIndexType || getPropertyOfType ( type , name ) ) { return true ; } return false ; } if ( type . flags & 49152 ) { for ( var _i = 0 , _a = type . types ; _i < _a . length ; _i ++ ) { var t = _a [ _i ] ; if ( isKnownProperty ( t , name ) ) { return true ; } } return false ; } return true ; }
429	function objectTypeRelatedTo ( source , target , reportErrors ) { if ( overflow ) { return 0 ; } var id = relation !== identityRelation || source . id < target . id ? source . id + "," + target . id : target . id + "," + source . id ; var related = relation [ id ] ; if ( related !== undefined ) { if ( ! elaborateErrors || ( related === 3 ) ) { return related === 1 ? - 1 : 0 ; } } if ( depth > 0 ) { for ( var i = 0 ; i < depth ; i ++ ) { if ( maybeStack [ i ] [ id ] ) { return 1 ; } } if ( depth === 100 ) { overflow = true ; return 0 ; } } else { sourceStack = [ ] ; targetStack = [ ] ; maybeStack = [ ] ; expandingFlags = 0 ; } sourceStack [ depth ] = source ; targetStack [ depth ] = target ; maybeStack [ depth ] = { } ; maybeStack [ depth ] [ id ] = 1 ; depth ++ ; var saveExpandingFlags = expandingFlags ; if ( ! ( expandingFlags & 1 ) && isDeeplyNestedGeneric ( source , sourceStack , depth ) ) expandingFlags |= 1 ; if ( ! ( expandingFlags & 2 ) && isDeeplyNestedGeneric ( target , targetStack , depth ) ) expandingFlags |= 2 ; var result ; if ( expandingFlags === 3 ) { result = 1 ; } else { result = propertiesRelatedTo ( source , target , reportErrors ) ; if ( result ) { result &= signaturesRelatedTo ( source , target , 0 , reportErrors ) ; if ( result ) { result &= signaturesRelatedTo ( source , target , 1 , reportErrors ) ; if ( result ) { result &= stringIndexTypesRelatedTo ( source , target , reportErrors ) ; if ( result ) { result &= numberIndexTypesRelatedTo ( source , target , reportErrors ) ; } } } } } expandingFlags = saveExpandingFlags ; depth -- ; if ( result ) { var maybeCache = maybeStack [ depth ] ; var destinationCache = ( result === - 1 || depth === 0 ) ? relation : maybeStack [ depth - 1 ] ; ts . copyMap ( maybeCache , destinationCache ) ; } else { relation [ id ] = reportErrors ? 3 : 2 ; } return result ; }
430	function isDeeplyNestedGeneric ( type , stack , depth ) { if ( type . flags & ( 4096 | 131072 ) && depth >= 5 ) { var symbol = type . symbol ; var count = 0 ; for ( var i = 0 ; i < depth ; i ++ ) { var t = stack [ i ] ; if ( t . flags & ( 4096 | 131072 ) && t . symbol === symbol ) { count ++ ; if ( count >= 5 ) return true ; } } } return false ; }
431	function isVariableAssignedWithin ( symbol , node ) { var links = getNodeLinks ( node ) ; if ( links . assignmentChecks ) { var cachedResult = links . assignmentChecks [ symbol . id ] ; if ( cachedResult !== undefined ) { return cachedResult ; } } else { links . assignmentChecks = { } ; } return links . assignmentChecks [ symbol . id ] = isAssignedIn ( node ) ; function isAssignedInBinaryExpression ( node ) { if ( node . operatorToken . kind >= 56 && node . operatorToken . kind <= 68 ) { var n = node . left ; while ( n . kind === 172 ) { n = n . expression ; } if ( n . kind === 69 && getResolvedSymbol ( n ) === symbol ) { return true ; } } return ts . forEachChild ( node , isAssignedIn ) ; } function isAssignedInVariableDeclaration ( node ) { if ( ! ts . isBindingPattern ( node . name ) && getSymbolOfNode ( node ) === symbol && hasInitializer ( node ) ) { return true ; } return ts . forEachChild ( node , isAssignedIn ) ; } function isAssignedIn ( node ) { switch ( node . kind ) { case 181 : return isAssignedInBinaryExpression ( node ) ; case 211 : case 163 : return isAssignedInVariableDeclaration ( node ) ; case 161 : case 162 : case 164 : case 165 : case 166 : case 167 : case 168 : case 169 : case 171 : case 189 : case 172 : case 179 : case 175 : case 178 : case 176 : case 177 : case 180 : case 184 : case 182 : case 185 : case 192 : case 193 : case 195 : case 196 : case 197 : case 198 : case 199 : case 200 : case 201 : case 204 : case 205 : case 206 : case 241 : case 242 : case 207 : case 208 : case 209 : case 244 : case 233 : case 234 : case 238 : case 239 : case 235 : case 240 : return ts . forEachChild ( node , isAssignedIn ) ; } return false ; } }
432	function narrowType ( type , expr , assumeTrue ) { switch ( expr . kind ) { case 168 : return narrowTypeByTypePredicate ( type , expr , assumeTrue ) ; case 172 : return narrowType ( type , expr . expression , assumeTrue ) ; case 181 : var operator = expr . operatorToken . kind ; if ( operator === 32 || operator === 33 ) { return narrowTypeByEquality ( type , expr , assumeTrue ) ; } else if ( operator === 51 ) { return narrowTypeByAnd ( type , expr , assumeTrue ) ; } else if ( operator === 52 ) { return narrowTypeByOr ( type , expr , assumeTrue ) ; } else if ( operator === 91 ) { return narrowTypeByInstanceof ( type , expr , assumeTrue ) ; } break ; case 179 : if ( expr . operator === 49 ) { return narrowType ( type , expr . operand , ! assumeTrue ) ; } break ; } return type ; }
433	function getContextuallyTypedParameterType ( parameter ) { var func = parameter . parent ; if ( isFunctionExpressionOrArrowFunction ( func ) || ts . isObjectLiteralMethod ( func ) ) { if ( isContextSensitive ( func ) ) { var contextualSignature = getContextualSignature ( func ) ; if ( contextualSignature ) { var funcHasRestParameters = ts . hasRestParameter ( func ) ; var len = func . parameters . length - ( funcHasRestParameters ? 1 : 0 ) ; var indexOfParameter = ts . indexOf ( func . parameters , parameter ) ; if ( indexOfParameter < len ) { return getTypeAtPosition ( contextualSignature , indexOfParameter ) ; } if ( funcHasRestParameters && indexOfParameter === ( func . parameters . length - 1 ) && isRestParameterIndex ( contextualSignature , func . parameters . length - 1 ) ) { return getTypeOfSymbol ( ts . lastOrUndefined ( contextualSignature . parameters ) ) ; } } } } return undefined ; }
434	function getContextualTypeForInitializerExpression ( node ) { var declaration = node . parent ; if ( node === declaration . initializer ) { if ( declaration . type ) { return getTypeFromTypeNode ( declaration . type ) ; } if ( declaration . kind === 138 ) { var type = getContextuallyTypedParameterType ( declaration ) ; if ( type ) { return type ; } } if ( ts . isBindingPattern ( declaration . name ) ) { return getTypeFromBindingPattern ( declaration . name , true ) ; } } return undefined ; }
435	function applyToContextualType ( type , mapper ) { if ( ! ( type . flags & 16384 ) ) { return mapper ( type ) ; } var types = type . types ; var mappedType ; var mappedTypes ; for ( var _i = 0 ; _i < types . length ; _i ++ ) { var current = types [ _i ] ; var t = mapper ( current ) ; if ( t ) { if ( ! mappedType ) { mappedType = t ; } else if ( ! mappedTypes ) { mappedTypes = [ mappedType , t ] ; } else { mappedTypes . push ( t ) ; } } } return mappedTypes ? getUnionType ( mappedTypes ) : mappedType ; }
436	function contextualTypeHasIndexSignature ( type , kind ) { return ! ! ( type . flags & 16384 ? ts . forEach ( type . types , function ( t ) { return getIndexTypeOfStructuredType ( t , kind ) ; } ) : getIndexTypeOfStructuredType ( type , kind ) ) ; }
437	function getContextualTypeForObjectLiteralMethod ( node ) { ts . Debug . assert ( ts . isObjectLiteralMethod ( node ) ) ; if ( isInsideWithStatementBody ( node ) ) { return undefined ; } return getContextualTypeForObjectLiteralElement ( node ) ; }
438	function getContextualTypeForElementExpression ( node ) { var arrayLiteral = node . parent ; var type = getContextualType ( arrayLiteral ) ; if ( type ) { var index = ts . indexOf ( arrayLiteral . elements , node ) ; return getTypeOfPropertyOfContextualType ( type , "" + index ) || getIndexTypeOfContextualType ( type , 1 ) || ( languageVersion >= 2 ? getElementTypeOfIterable ( type , undefined ) : undefined ) ; } return undefined ; }
439	function getNonGenericSignature ( type ) { var signatures = getSignaturesOfStructuredType ( type , 0 ) ; if ( signatures . length === 1 ) { var signature = signatures [ 0 ] ; if ( ! signature . typeParameters ) { return signature ; } } }
440	function getContextualSignature ( node ) { ts . Debug . assert ( node . kind !== 143 || ts . isObjectLiteralMethod ( node ) ) ; var type = ts . isObjectLiteralMethod ( node ) ? getContextualTypeForObjectLiteralMethod ( node ) : getContextualType ( node ) ; if ( ! type ) { return undefined ; } if ( ! ( type . flags & 16384 ) ) { return getNonGenericSignature ( type ) ; } var signatureList ; var types = type . types ; for ( var _i = 0 ; _i < types . length ; _i ++ ) { var current = types [ _i ] ; var signature = getNonGenericSignature ( current ) ; if ( signature ) { if ( ! signatureList ) { signatureList = [ signature ] ; } else if ( ! compareSignatures ( signatureList [ 0 ] , signature , false , true , compareTypes ) ) { return undefined ; } else { signatureList . push ( signature ) ; } } } var result ; if ( signatureList ) { result = cloneSignature ( signatureList [ 0 ] ) ; result . resolvedReturnType = undefined ; result . unionSignatures = signatureList ; } return result ; }
441	function getJsxAttributePropertySymbol ( attrib ) { var attributesType = getJsxElementAttributesType ( attrib . parent ) ; var prop = getPropertyOfType ( attributesType , attrib . name . text ) ; return prop || unknownSymbol ; }
442	function checkClassPropertyAccess ( node , left , type , prop ) { var flags = getDeclarationFlagsFromSymbol ( prop ) ; var declaringClass = getDeclaredTypeOfSymbol ( prop . parent ) ; if ( left . kind === 95 ) { var errorNode = node . kind === 166 ? node . name : node . right ; if ( getDeclarationKindFromSymbol ( prop ) !== 143 ) { error ( errorNode , ts . Diagnostics . Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword ) ; return false ; } if ( flags & 256 ) { error ( errorNode , ts . Diagnostics . Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression , symbolToString ( prop ) , typeToString ( declaringClass ) ) ; return false ; } } if ( ! ( flags & ( 32 | 64 ) ) ) { return true ; } var enclosingClassDeclaration = ts . getContainingClass ( node ) ; var enclosingClass = enclosingClassDeclaration ? getDeclaredTypeOfSymbol ( getSymbolOfNode ( enclosingClassDeclaration ) ) : undefined ; if ( flags & 32 ) { if ( declaringClass !== enclosingClass ) { error ( node , ts . Diagnostics . Property_0_is_private_and_only_accessible_within_class_1 , symbolToString ( prop ) , typeToString ( declaringClass ) ) ; return false ; } return true ; } if ( left . kind === 95 ) { return true ; } if ( ! enclosingClass || ! hasBaseType ( enclosingClass , declaringClass ) ) { error ( node , ts . Diagnostics . Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses , symbolToString ( prop ) , typeToString ( declaringClass ) ) ; return false ; } if ( flags & 128 ) { return true ; } if ( type . flags & 33554432 ) { type = getConstraintOfTypeParameter ( type ) ; } if ( ! ( getTargetType ( type ) . flags & ( 1024 | 2048 ) && hasBaseType ( type , enclosingClass ) ) ) { error ( node , ts . Diagnostics . Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1 , symbolToString ( prop ) , typeToString ( enclosingClass ) ) ; return false ; } return true ; }
443	function getPropertyNameForIndexedAccess ( indexArgumentExpression , indexArgumentType ) { if ( indexArgumentExpression . kind === 9 || indexArgumentExpression . kind === 8 ) { return indexArgumentExpression . text ; } if ( indexArgumentExpression . kind === 167 || indexArgumentExpression . kind === 166 ) { var value = getConstantValue ( indexArgumentExpression ) ; if ( value !== undefined ) { return value . toString ( ) ; } } if ( checkThatExpressionIsProperSymbolReference ( indexArgumentExpression , indexArgumentType , false ) ) { var rightHandSideName = indexArgumentExpression . name . text ; return ts . getPropertyNameForKnownSymbolName ( rightHandSideName ) ; } return undefined ; }
444	function getSingleCallSignature ( type ) { if ( type . flags & 80896 ) { var resolved = resolveStructuredTypeMembers ( type ) ; if ( resolved . callSignatures . length === 1 && resolved . constructSignatures . length === 0 && resolved . properties . length === 0 && ! resolved . stringIndexType && ! resolved . numberIndexType ) { return resolved . callSignatures [ 0 ] ; } } return undefined ; }
445	function getEffectiveCallArguments ( node ) { var args ; if ( node . kind === 170 ) { var template = node . template ; args = [ undefined ] ; if ( template . kind === 183 ) { ts . forEach ( template . templateSpans , function ( span ) { args . push ( span . expression ) ; } ) ; } } else if ( node . kind === 139 ) { return undefined ; } else { args = node . arguments || emptyArray ; } return args ; }
446	function getEffectiveDecoratorArgumentType ( node , argIndex ) { if ( argIndex === 0 ) { return getEffectiveDecoratorFirstArgumentType ( node . parent ) ; } else if ( argIndex === 1 ) { return getEffectiveDecoratorSecondArgumentType ( node . parent ) ; } else if ( argIndex === 2 ) { return getEffectiveDecoratorThirdArgumentType ( node . parent ) ; } ts . Debug . fail ( "Decorators should not have a fourth synthetic argument." ) ; return unknownType ; }
447	function getEffectiveArgumentType ( node , argIndex , arg ) { if ( node . kind === 139 ) { return getEffectiveDecoratorArgumentType ( node , argIndex ) ; } else if ( argIndex === 0 && node . kind === 170 ) { return globalTemplateStringsArrayType ; } return undefined ; }
448	function getEffectiveArgument ( node , args , argIndex ) { if ( node . kind === 139 || ( argIndex === 0 && node . kind === 170 ) ) { return undefined ; } return args [ argIndex ] ; }
449	function getEffectiveArgumentErrorNode ( node , argIndex , arg ) { if ( node . kind === 139 ) { return node . expression ; } else if ( argIndex === 0 && node . kind === 170 ) { return node . template ; } else { return arg ; } }
450	function getDiagnosticHeadMessageForDecoratorResolution ( node ) { switch ( node . parent . kind ) { case 214 : case 186 : return ts . Diagnostics . Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression ; case 138 : return ts . Diagnostics . Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression ; case 141 : return ts . Diagnostics . Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression ; case 143 : case 145 : case 146 : return ts . Diagnostics . Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression ; } }
451	function resolveDecorator ( node , candidatesOutArray ) { var funcType = checkExpression ( node . expression ) ; var apparentType = getApparentType ( funcType ) ; if ( apparentType === unknownType ) { return resolveErrorCall ( node ) ; } var callSignatures = getSignaturesOfType ( apparentType , 0 ) ; if ( funcType === anyType || ( ! callSignatures . length && ! ( funcType . flags & 16384 ) && isTypeAssignableTo ( funcType , globalFunctionType ) ) ) { return resolveUntypedCall ( node ) ; } var headMessage = getDiagnosticHeadMessageForDecoratorResolution ( node ) ; if ( ! callSignatures . length ) { var errorInfo ; errorInfo = ts . chainDiagnosticMessages ( errorInfo , ts . Diagnostics . Cannot_invoke_an_expression_whose_type_lacks_a_call_signature ) ; errorInfo = ts . chainDiagnosticMessages ( errorInfo , headMessage ) ; diagnostics . add ( ts . createDiagnosticForNodeFromMessageChain ( node , errorInfo ) ) ; return resolveErrorCall ( node ) ; } return resolveCall ( node , callSignatures , candidatesOutArray , headMessage ) ; }
452	function getResolvedSignature ( node , candidatesOutArray ) { var links = getNodeLinks ( node ) ; if ( ! links . resolvedSignature || candidatesOutArray ) { links . resolvedSignature = anySignature ; if ( node . kind === 168 ) { links . resolvedSignature = resolveCallExpression ( node , candidatesOutArray ) ; } else if ( node . kind === 169 ) { links . resolvedSignature = resolveNewExpression ( node , candidatesOutArray ) ; } else if ( node . kind === 170 ) { links . resolvedSignature = resolveTaggedTemplateExpression ( node , candidatesOutArray ) ; } else if ( node . kind === 139 ) { links . resolvedSignature = resolveDecorator ( node , candidatesOutArray ) ; } else { ts . Debug . fail ( "Branch in 'getResolvedSignature' should be unreachable." ) ; } } return links . resolvedSignature ; }
453	function checkCallExpression ( node ) { checkGrammarTypeArguments ( node , node . typeArguments ) || checkGrammarArguments ( node , node . arguments ) ; var signature = getResolvedSignature ( node ) ; if ( node . expression . kind === 95 ) { return voidType ; } if ( node . kind === 169 ) { var declaration = signature . declaration ; if ( declaration && declaration . kind !== 144 && declaration . kind !== 148 && declaration . kind !== 153 ) { if ( compilerOptions . noImplicitAny ) { error ( node , ts . Diagnostics . new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type ) ; } return anyType ; } } return getReturnTypeOfSignature ( signature ) ; }
454	function assignBindingElementTypes ( node ) { if ( ts . isBindingPattern ( node . name ) ) { for ( var _i = 0 , _a = node . name . elements ; _i < _a . length ; _i ++ ) { var element = _a [ _i ] ; if ( element . kind !== 187 ) { if ( element . name . kind === 69 ) { getSymbolLinks ( getSymbolOfNode ( element ) ) . type = getTypeForBindingElement ( element ) ; } assignBindingElementTypes ( element ) ; } } } }
455	function checkTypeParameter ( node ) { if ( node . expression ) { grammarErrorOnFirstToken ( node . expression , ts . Diagnostics . Type_expected ) ; } checkSourceElement ( node . constraint ) ; if ( produceDiagnostics ) { checkTypeParameterHasIllegalReferencesInConstraint ( node ) ; checkTypeNameIsReserved ( node . name , ts . Diagnostics . Type_parameter_name_cannot_be_0 ) ; } }
456	function getPromisedType ( promise ) { if ( promise . flags & 1 ) { return undefined ; } if ( ( promise . flags & 4096 ) && promise . target === tryGetGlobalPromiseType ( ) ) { return promise . typeArguments [ 0 ] ; } var globalPromiseLikeType = getInstantiatedGlobalPromiseLikeType ( ) ; if ( globalPromiseLikeType === emptyObjectType || ! isTypeAssignableTo ( promise , globalPromiseLikeType ) ) { return undefined ; } var thenFunction = getTypeOfPropertyOfType ( promise , "then" ) ; if ( thenFunction && ( thenFunction . flags & 1 ) ) { return undefined ; } var thenSignatures = thenFunction ? getSignaturesOfType ( thenFunction , 0 ) : emptyArray ; if ( thenSignatures . length === 0 ) { return undefined ; } var onfulfilledParameterType = getUnionType ( ts . map ( thenSignatures , getTypeOfFirstParameterOfSignature ) ) ; if ( onfulfilledParameterType . flags & 1 ) { return undefined ; } var onfulfilledParameterSignatures = getSignaturesOfType ( onfulfilledParameterType , 0 ) ; if ( onfulfilledParameterSignatures . length === 0 ) { return undefined ; } var valueParameterType = getUnionType ( ts . map ( onfulfilledParameterSignatures , getTypeOfFirstParameterOfSignature ) ) ; return valueParameterType ; }
457	function checkDecorator ( node ) { var signature = getResolvedSignature ( node ) ; var returnType = getReturnTypeOfSignature ( signature ) ; if ( returnType . flags & 1 ) { return ; } var expectedReturnType ; var headMessage = getDiagnosticHeadMessageForDecoratorResolution ( node ) ; var errorInfo ; switch ( node . parent . kind ) { case 214 : var classSymbol = getSymbolOfNode ( node . parent ) ; var classConstructorType = getTypeOfSymbol ( classSymbol ) ; expectedReturnType = getUnionType ( [ classConstructorType , voidType ] ) ; break ; case 138 : expectedReturnType = voidType ; errorInfo = ts . chainDiagnosticMessages ( errorInfo , ts . Diagnostics . The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any ) ; break ; case 141 : expectedReturnType = voidType ; errorInfo = ts . chainDiagnosticMessages ( errorInfo , ts . Diagnostics . The_return_type_of_a_property_decorator_function_must_be_either_void_or_any ) ; break ; case 143 : case 145 : case 146 : var methodType = getTypeOfNode ( node . parent ) ; var descriptorType = createTypedPropertyDescriptorType ( methodType ) ; expectedReturnType = getUnionType ( [ descriptorType , voidType ] ) ; break ; } checkTypeAssignableTo ( returnType , expectedReturnType , node , headMessage , errorInfo ) ; }
458	function checkTypeNodeAsExpression ( node ) { if ( node && node . kind === 151 ) { var root = getFirstIdentifier ( node . typeName ) ; var meaning = root . parent . kind === 151 ? 793056 : 1536 ; var rootSymbol = resolveName ( root , root . text , meaning | 8388608 , undefined , undefined ) ; if ( rootSymbol && rootSymbol . flags & 8388608 ) { var aliasTarget = resolveAlias ( rootSymbol ) ; if ( aliasTarget . flags & 107455 && ! isConstEnumOrConstEnumOnlyModule ( resolveAlias ( rootSymbol ) ) ) { markAliasSymbolAsReferenced ( rootSymbol ) ; } } } }
459	function checkTypeAnnotationAsExpression ( node ) { switch ( node . kind ) { case 141 : checkTypeNodeAsExpression ( node . type ) ; break ; case 138 : checkTypeNodeAsExpression ( node . type ) ; break ; case 143 : checkTypeNodeAsExpression ( node . type ) ; break ; case 145 : checkTypeNodeAsExpression ( node . type ) ; break ; case 146 : checkTypeNodeAsExpression ( ts . getSetAccessorTypeAnnotationNode ( node ) ) ; break ; } }
460	function checkDecorators ( node ) { if ( ! node . decorators ) { return ; } if ( ! ts . nodeCanBeDecorated ( node ) ) { return ; } if ( ! compilerOptions . experimentalDecorators ) { error ( node , ts . Diagnostics . Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Specify_experimentalDecorators_to_remove_this_warning ) ; } if ( compilerOptions . emitDecoratorMetadata ) { switch ( node . kind ) { case 214 : var constructor = ts . getFirstConstructorWithBody ( node ) ; if ( constructor ) { checkParameterTypeAnnotationsAsExpressions ( constructor ) ; } break ; case 143 : checkParameterTypeAnnotationsAsExpressions ( node ) ; case 146 : case 145 : case 141 : case 138 : checkTypeAnnotationAsExpression ( node ) ; break ; } } emitDecorate = true ; if ( node . kind === 138 ) { emitParam = true ; } ts . forEach ( node . decorators , checkDecorator ) ; }
461	function checkIfThisIsCapturedInEnclosingScope ( node ) { var current = node ; while ( current ) { if ( getNodeCheckFlags ( current ) & 4 ) { var isDeclaration_1 = node . kind !== 69 ; if ( isDeclaration_1 ) { error ( node . name , ts . Diagnostics . Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference ) ; } else { error ( node , ts . Diagnostics . Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference ) ; } return ; } current = current . parent ; } }
462	function checkParameterInitializer ( node ) { if ( ts . getRootDeclaration ( node ) . kind !== 138 ) { return ; } var func = ts . getContainingFunction ( node ) ; visit ( node . initializer ) ; function visit ( n ) { if ( n . kind === 69 ) { var referencedSymbol = getNodeLinks ( n ) . resolvedSymbol ; if ( referencedSymbol && referencedSymbol !== unknownSymbol && getSymbol ( func . locals , referencedSymbol . name , 107455 ) === referencedSymbol ) { if ( referencedSymbol . valueDeclaration . kind === 138 ) { if ( referencedSymbol . valueDeclaration === node ) { error ( n , ts . Diagnostics . Parameter_0_cannot_be_referenced_in_its_initializer , ts . declarationNameToString ( node . name ) ) ; return ; } if ( referencedSymbol . valueDeclaration . pos < node . pos ) { return ; } } error ( n , ts . Diagnostics . Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it , ts . declarationNameToString ( node . name ) , ts . declarationNameToString ( n ) ) ; } } else { ts . forEachChild ( n , visit ) ; } } }
463	function checkVariableLikeDeclaration ( node ) { checkDecorators ( node ) ; checkSourceElement ( node . type ) ; if ( node . name . kind === 136 ) { checkComputedPropertyName ( node . name ) ; if ( node . initializer ) { checkExpressionCached ( node . initializer ) ; } } if ( ts . isBindingPattern ( node . name ) ) { ts . forEach ( node . name . elements , checkSourceElement ) ; } if ( node . initializer && ts . getRootDeclaration ( node ) . kind === 138 && ts . nodeIsMissing ( ts . getContainingFunction ( node ) . body ) ) { error ( node , ts . Diagnostics . A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation ) ; return ; } if ( ts . isBindingPattern ( node . name ) ) { if ( node . initializer ) { checkTypeAssignableTo ( checkExpressionCached ( node . initializer ) , getWidenedTypeForVariableLikeDeclaration ( node ) , node , undefined ) ; checkParameterInitializer ( node ) ; } return ; } var symbol = getSymbolOfNode ( node ) ; var type = getTypeOfVariableOrParameterOrProperty ( symbol ) ; if ( node === symbol . valueDeclaration ) { if ( node . initializer ) { checkTypeAssignableTo ( checkExpressionCached ( node . initializer ) , type , node , undefined ) ; checkParameterInitializer ( node ) ; } } else { var declarationType = getWidenedTypeForVariableLikeDeclaration ( node ) ; if ( type !== unknownType && declarationType !== unknownType && ! isTypeIdenticalTo ( type , declarationType ) ) { error ( node . name , ts . Diagnostics . Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2 , ts . declarationNameToString ( node . name ) , typeToString ( type ) , typeToString ( declarationType ) ) ; } if ( node . initializer ) { checkTypeAssignableTo ( checkExpressionCached ( node . initializer ) , declarationType , node , undefined ) ; } } if ( node . kind !== 141 && node . kind !== 140 ) { checkExportsOnMergedDeclarations ( node ) ; if ( node . kind === 211 || node . kind === 163 ) { checkVarDeclaredNamesNotShadowed ( node ) ; } checkCollisionWithCapturedSuperVariable ( node , node . name ) ; checkCollisionWithCapturedThisVariable ( node , node . name ) ; checkCollisionWithRequireExportsInGeneratedCode ( node , node . name ) ; } }
464	function checkElementTypeOfIterable ( iterable , errorNode ) { var elementType = getElementTypeOfIterable ( iterable , errorNode ) ; if ( errorNode && elementType ) { checkTypeAssignableTo ( iterable , createIterableType ( elementType ) , errorNode ) ; } return elementType || anyType ; }
465	function checkTypeParameters ( typeParameterDeclarations ) { if ( typeParameterDeclarations ) { for ( var i = 0 , n = typeParameterDeclarations . length ; i < n ; i ++ ) { var node = typeParameterDeclarations [ i ] ; checkTypeParameter ( node ) ; if ( produceDiagnostics ) { for ( var j = 0 ; j < i ; j ++ ) { if ( typeParameterDeclarations [ j ] . symbol === node . symbol ) { error ( node . name , ts . Diagnostics . Duplicate_identifier_0 , ts . declarationNameToString ( node . name ) ) ; } } } } } }
466	function checkSourceFileWorker ( node ) { var links = getNodeLinks ( node ) ; if ( ! ( links . flags & 1 ) ) { if ( node . isDefaultLib && compilerOptions . skipDefaultLibCheck ) { return ; } checkGrammarSourceFile ( node ) ; emitExtends = false ; emitDecorate = false ; emitParam = false ; potentialThisCollisions . length = 0 ; ts . forEach ( node . statements , checkSourceElement ) ; checkFunctionAndClassExpressionBodies ( node ) ; if ( ts . isExternalModule ( node ) ) { checkExternalModuleExports ( node ) ; } if ( potentialThisCollisions . length ) { ts . forEach ( potentialThisCollisions , checkIfThisIsCapturedInEnclosingScope ) ; potentialThisCollisions . length = 0 ; } if ( emitExtends ) { links . flags |= 8 ; } if ( emitDecorate ) { links . flags |= 16 ; } if ( emitParam ) { links . flags |= 32 ; } if ( emitAwaiter ) { links . flags |= 64 ; } if ( emitGenerator || ( emitAwaiter && languageVersion < 2 ) ) { links . flags |= 128 ; } links . flags |= 1 ; } }
467	function copySymbol ( symbol , meaning ) { if ( symbol . flags & meaning ) { var id = symbol . name ; if ( ! ts . hasProperty ( symbols , id ) ) { symbols [ id ] = symbol ; } } }
468	function getParentTypeOfClassElement ( node ) { var classSymbol = getSymbolOfNode ( node . parent ) ; return node . flags & 128 ? getTypeOfSymbol ( classSymbol ) : getDeclaredTypeOfSymbol ( classSymbol ) ; }
469	function getAugmentedPropertiesOfType ( type ) { type = getApparentType ( type ) ; var propsByName = createSymbolTable ( getPropertiesOfType ( type ) ) ; if ( getSignaturesOfType ( type , 0 ) . length || getSignaturesOfType ( type , 1 ) . length ) { ts . forEach ( getPropertiesOfType ( globalFunctionType ) , function ( p ) { if ( ! ts . hasProperty ( propsByName , p . name ) ) { propsByName [ p . name ] = p ; } } ) ; } return getNamedMembers ( propsByName ) ; }
470	function getReferencedExportContainer ( node ) { var symbol = getReferencedValueSymbol ( node ) ; if ( symbol ) { if ( symbol . flags & 1048576 ) { var exportSymbol = getMergedSymbol ( symbol . exportSymbol ) ; if ( exportSymbol . flags & 944 ) { return undefined ; } symbol = exportSymbol ; } var parentSymbol = getParentOfSymbol ( symbol ) ; if ( parentSymbol ) { if ( parentSymbol . flags & 512 && parentSymbol . valueDeclaration . kind === 248 ) { return parentSymbol . valueDeclaration ; } for ( var n = node . parent ; n ; n = n . parent ) { if ( ( n . kind === 218 || n . kind === 217 ) && getSymbolOfNode ( n ) === parentSymbol ) { return n ; } } } } }
471	function getReferencedImportDeclaration ( node ) { var symbol = getReferencedValueSymbol ( node ) ; return symbol && symbol . flags & 8388608 ? getDeclarationOfAliasSymbol ( symbol ) : undefined ; }
472	function getReferencedNestedRedeclaration ( node ) { var symbol = getReferencedValueSymbol ( node ) ; return symbol && isNestedRedeclarationSymbol ( symbol ) ? symbol . valueDeclaration : undefined ; }
473	function getExportDefaultTempVariableName ( ) { var baseName = "_default" ; if ( ! ts . hasProperty ( currentSourceFile . identifiers , baseName ) ) { return baseName ; } var count = 0 ; while ( true ) { var name_18 = baseName + "_" + ( ++ count ) ; if ( ! ts . hasProperty ( currentSourceFile . identifiers , name_18 ) ) { return name_18 ; } } }
474	function emitFiles ( resolver , host , targetSourceFile ) { var extendsHelper = "\nvar __extends = (this && this.__extends) || function (d, b) {\n for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n function __() { this.constructor = d; }\n d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};" ; \n \n \n \n \n var decorateHelper = "\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n return c > 3 && r && Object.defineProperty(target, key, r), r;\n};" ; \n \n \n \" \" \" \" \n \n \n var metadataHelper = "\nvar __metadata = (this && this.__metadata) || function (k, v) {\n if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};" ; \n }
475	function makeTempVariableName ( flags ) { if ( flags && ! ( tempFlags & flags ) ) { var name_19 = flags === 268435456 ? "_i" : "_n" ; if ( isUniqueName ( name_19 ) ) { tempFlags |= flags ; return name_19 ; } } while ( true ) { var count = tempFlags & 268435455 ; tempFlags ++ ; if ( count !== 8 && count !== 13 ) { var name_20 = count < 26 ? "_" + String . fromCharCode ( 97 + count ) : "_" + ( count - 26 ) ; if ( isUniqueName ( name_20 ) ) { return name_20 ; } } } }
476	function makeUniqueName ( baseName ) { if ( baseName . charCodeAt ( baseName . length - 1 ) !== 95 ) { baseName += "_" ; } var i = 1 ; while ( true ) { var generatedName = baseName + i ; if ( isUniqueName ( generatedName ) ) { return generatedNameSet [ generatedName ] = generatedName ; } i ++ ; } }
477	function encodeLastRecordedSourceMapSpan ( ) { if ( ! lastRecordedSourceMapSpan || lastRecordedSourceMapSpan === lastEncodedSourceMapSpan ) { return ; } var prevEncodedEmittedColumn = lastEncodedSourceMapSpan . emittedColumn ; if ( lastEncodedSourceMapSpan . emittedLine === lastRecordedSourceMapSpan . emittedLine ) { if ( sourceMapData . sourceMapMappings ) { sourceMapData . sourceMapMappings += "," ; } } else { for ( var encodedLine = lastEncodedSourceMapSpan . emittedLine ; encodedLine < lastRecordedSourceMapSpan . emittedLine ; encodedLine ++ ) { sourceMapData . sourceMapMappings += ";" ; } prevEncodedEmittedColumn = 1 ; } sourceMapData . sourceMapMappings += base64VLQFormatEncode ( lastRecordedSourceMapSpan . emittedColumn - prevEncodedEmittedColumn ) ; sourceMapData . sourceMapMappings += base64VLQFormatEncode ( lastRecordedSourceMapSpan . sourceIndex - lastEncodedSourceMapSpan . sourceIndex ) ; sourceMapData . sourceMapMappings += base64VLQFormatEncode ( lastRecordedSourceMapSpan . sourceLine - lastEncodedSourceMapSpan . sourceLine ) ; sourceMapData . sourceMapMappings += base64VLQFormatEncode ( lastRecordedSourceMapSpan . sourceColumn - lastEncodedSourceMapSpan . sourceColumn ) ; if ( lastRecordedSourceMapSpan . nameIndex >= 0 ) { sourceMapData . sourceMapMappings += base64VLQFormatEncode ( lastRecordedSourceMapSpan . nameIndex - lastEncodedNameIndex ) ; lastEncodedNameIndex = lastRecordedSourceMapSpan . nameIndex ; } lastEncodedSourceMapSpan = lastRecordedSourceMapSpan ; sourceMapData . sourceMapDecodedMappings . push ( lastEncodedSourceMapSpan ) ; function base64VLQFormatEncode ( inValue ) { function base64FormatEncode ( inValue ) { if ( inValue < 64 ) { return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" . charAt ( inValue ) ; } throw TypeError ( inValue + ": not a 64 based value" ) ; } if ( inValue < 0 ) { inValue = ( ( - inValue ) << 1 ) + 1 ; } else { inValue = inValue << 1 ; } var encodedStr = "" ; do { var currentDigit = inValue & 31 ; inValue = inValue >> 5 ; if ( inValue > 0 ) { currentDigit = currentDigit | 32 ; } encodedStr = encodedStr + base64FormatEncode ( currentDigit ) ; } while ( inValue > 0 ) ; return encodedStr ; } }
478	function createTempVariable ( flags ) { var result = ts . createSynthesizedNode ( 69 ) ; result . text = makeTempVariableName ( flags ) ; return result ; }
479	function indentIfOnDifferentLines ( parent , node1 , node2 , valueToWriteWhenNotIndenting ) { var realNodesAreOnDifferentLines = ! ts . nodeIsSynthesized ( parent ) && ! nodeEndIsOnSameLineAsNodeStart ( node1 , node2 ) ; var synthesizedNodeIsOnDifferentLine = synthesizedNodeStartsOnNewLine ( node2 ) ; if ( realNodesAreOnDifferentLines || synthesizedNodeIsOnDifferentLine ) { increaseIndent ( ) ; writeLine ( ) ; return true ; } else { if ( valueToWriteWhenNotIndenting ) { write ( valueToWriteWhenNotIndenting ) ; } return false ; } }
480	function emitExponentiationOperator ( node ) { var leftHandSideExpression = node . left ; if ( node . operatorToken . kind === 60 ) { var synthesizedLHS ; var shouldEmitParentheses = false ; if ( ts . isElementAccessExpression ( leftHandSideExpression ) ) { shouldEmitParentheses = true ; write ( "(" ) ; synthesizedLHS = ts . createSynthesizedNode ( 167 , false ) ; var identifier = emitTempVariableAssignment ( leftHandSideExpression . expression , false , false ) ; synthesizedLHS . expression = identifier ; if ( leftHandSideExpression . argumentExpression . kind !== 8 && leftHandSideExpression . argumentExpression . kind !== 9 ) { var tempArgumentExpression = createAndRecordTempVariable ( 268435456 ) ; synthesizedLHS . argumentExpression = tempArgumentExpression ; emitAssignment ( tempArgumentExpression , leftHandSideExpression . argumentExpression , true ) ; } else { synthesizedLHS . argumentExpression = leftHandSideExpression . argumentExpression ; } write ( ", " ) ; } else if ( ts . isPropertyAccessExpression ( leftHandSideExpression ) ) { shouldEmitParentheses = true ; write ( "(" ) ; synthesizedLHS = ts . createSynthesizedNode ( 166 , false ) ; var identifier = emitTempVariableAssignment ( leftHandSideExpression . expression , false , false ) ; synthesizedLHS . expression = identifier ; synthesizedLHS . dotToken = leftHandSideExpression . dotToken ; synthesizedLHS . name = leftHandSideExpression . name ; write ( ", " ) ; } emit ( synthesizedLHS || leftHandSideExpression ) ; write ( " = " ) ; write ( "Math.pow(" ) ; emit ( synthesizedLHS || leftHandSideExpression ) ; write ( ", " ) ; emit ( node . right ) ; write ( ")" ) ; if ( shouldEmitParentheses ) { write ( ")" ) ; } } else { write ( "Math.pow(" ) ; emit ( leftHandSideExpression ) ; write ( ", " ) ; emit ( node . right ) ; write ( ")" ) ; } }
481	function tryEmitStartOfVariableDeclarationList ( decl , startPos ) { if ( shouldHoistVariable ( decl , true ) ) { return false ; } var tokenKind = 102 ; if ( decl && languageVersion >= 2 ) { if ( ts . isLet ( decl ) ) { tokenKind = 108 ; } else if ( ts . isConst ( decl ) ) { tokenKind = 74 ; } } if ( startPos !== undefined ) { emitToken ( tokenKind , startPos ) ; write ( " " ) ; } else { switch ( tokenKind ) { case 102 : write ( "var " ) ; break ; case 108 : write ( "let " ) ; break ; case 74 : write ( "const " ) ; break ; } } return true ; }
482	function emitAssignment ( name , value , shouldEmitCommaBeforeAssignment ) { if ( shouldEmitCommaBeforeAssignment ) { write ( ", " ) ; } var exportChanged = isNameOfExportedSourceLevelDeclarationInSystemExternalModule ( name ) ; if ( exportChanged ) { write ( exportFunctionForFile + "(\"" ) ; \" emitNodeWithCommentsAndWithoutSourcemap ( name ) ; } write ( "\", " ) ; \" var isVariableDeclarationOrBindingElement = name . parent && ( name . parent . kind === 211 || name . parent . kind === 163 ) ; if ( isVariableDeclarationOrBindingElement ) { emitModuleMemberName ( name . parent ) ; } else { emit ( name ) ; } write ( " = " ) ; }
483	function emitTempVariableAssignment ( expression , canDefineTempVariablesInPlace , shouldEmitCommaBeforeAssignment ) { var identifier = createTempVariable ( 0 ) ; if ( ! canDefineTempVariablesInPlace ) { recordTempDeclaration ( identifier ) ; } emitAssignment ( identifier , expression , shouldEmitCommaBeforeAssignment ) ; return identifier ; }
484	function ensureIdentifier ( expr , reuseIdentifierExpressions ) { if ( expr . kind === 69 && reuseIdentifierExpressions ) { return expr ; } var identifier = emitTempVariableAssignment ( expr , canDefineTempVariablesInPlace , emitCount > 0 ) ; emitCount ++ ; return identifier ; }
485	function findSourceFile ( fileName , isDefaultLib , refFile , refPos , refEnd ) { if ( filesByName . contains ( fileName ) ) { return getSourceFileFromCache ( fileName , false ) ; } var normalizedAbsolutePath = ts . getNormalizedAbsolutePath ( fileName , host . getCurrentDirectory ( ) ) ; if ( filesByName . contains ( normalizedAbsolutePath ) ) { var file_1 = getSourceFileFromCache ( normalizedAbsolutePath , true ) ; filesByName . set ( fileName , file_1 ) ; return file_1 ; } var file = host . getSourceFile ( fileName , options . target , function ( hostErrorMessage ) { if ( refFile !== undefined && refPos !== undefined && refEnd !== undefined ) { fileProcessingDiagnostics . add ( ts . createFileDiagnostic ( refFile , refPos , refEnd - refPos , ts . Diagnostics . Cannot_read_file_0_Colon_1 , fileName , hostErrorMessage ) ) ; } else { fileProcessingDiagnostics . add ( ts . createCompilerDiagnostic ( ts . Diagnostics . Cannot_read_file_0_Colon_1 , fileName , hostErrorMessage ) ) ; } } ) ; filesByName . set ( fileName , file ) ; if ( file ) { skipDefaultLib = skipDefaultLib || file . hasNoDefaultLib ; filesByName . set ( normalizedAbsolutePath , file ) ; var basePath = ts . getDirectoryPath ( fileName ) ; if ( ! options . noResolve ) { processReferencedFiles ( file , basePath ) ; } processImportedModules ( file , basePath ) ; if ( isDefaultLib ) { file . isDefaultLib = true ; files . unshift ( file ) ; } else { files . push ( file ) ; } } return file ; function getSourceFileFromCache ( fileName , useAbsolutePath ) { var file = filesByName . get ( fileName ) ; if ( file && host . useCaseSensitiveFileNames ( ) ) { var sourceFileName = useAbsolutePath ? ts . getNormalizedAbsolutePath ( file . fileName , host . getCurrentDirectory ( ) ) : file . fileName ; if ( ts . normalizeSlashes ( fileName ) !== ts . normalizeSlashes ( sourceFileName ) ) { if ( refFile !== undefined && refPos !== undefined && refEnd !== undefined ) { fileProcessingDiagnostics . add ( ts . createFileDiagnostic ( refFile , refPos , refEnd - refPos , ts . Diagnostics . File_name_0_differs_from_already_included_file_name_1_only_in_casing , fileName , sourceFileName ) ) ; } else { fileProcessingDiagnostics . add ( ts . createCompilerDiagnostic ( ts . Diagnostics . File_name_0_differs_from_already_included_file_name_1_only_in_casing , fileName , sourceFileName ) ) ; } } } return file ; } }
486	function readConfigFile ( fileName , readFile ) { var text = "" ; try { text = readFile ( fileName ) ; } catch ( e ) { return { error : ts . createCompilerDiagnostic ( ts . Diagnostics . Cannot_read_file_0_Colon_1 , fileName , e . message ) } ; } return parseConfigFileTextToJson ( fileName , text ) ; }
487	function parseConfigFileTextToJson ( fileName , jsonText ) { try { return { config : / \S / . test ( jsonText ) ? JSON . parse ( jsonText ) : { } } ; } catch ( e ) { return { error : ts . createCompilerDiagnostic ( ts . Diagnostics . Failed_to_parse_file_0_Colon_1 , fileName , e . message ) } ; } }
488	function removeDynamicallyNamedProperties ( node ) { return ts . filter ( node . members , function ( member ) { return ! ts . hasDynamicName ( member ) ; } ) ; }
489	function getImmediatelyContainingArgumentInfo ( node ) { if ( node . parent . kind === 168 || node . parent . kind === 169 ) { var callExpression = node . parent ; if ( node . kind === 25 || node . kind === 17 ) { var list = getChildListThatStartsWithOpenerToken ( callExpression , node , sourceFile ) ; var isTypeArgList = callExpression . typeArguments && callExpression . typeArguments . pos === list . pos ; ts . Debug . assert ( list !== undefined ) ; return { kind : isTypeArgList ? 0 : 1 , invocation : callExpression , argumentsSpan : getApplicableSpanForArguments ( list ) , argumentIndex : 0 , argumentCount : getArgumentCount ( list ) } ; } var listItemInfo = ts . findListItemInfo ( node ) ; if ( listItemInfo ) { var list = listItemInfo . list ; var isTypeArgList = callExpression . typeArguments && callExpression . typeArguments . pos === list . pos ; var argumentIndex = getArgumentIndex ( list , node ) ; var argumentCount = getArgumentCount ( list ) ; ts . Debug . assert ( argumentIndex === 0 || argumentIndex < argumentCount , "argumentCount < argumentIndex, " + argumentCount + " < " + argumentIndex ) ; return { kind : isTypeArgList ? 0 : 1 , invocation : callExpression , argumentsSpan : getApplicableSpanForArguments ( list ) , argumentIndex : argumentIndex , argumentCount : argumentCount } ; } } else if ( node . kind === 11 && node . parent . kind === 170 ) { if ( ts . isInsideTemplateLiteral ( node , position ) ) { return getArgumentListInfoForTemplate ( node . parent , 0 ) ; } } else if ( node . kind === 12 && node . parent . parent . kind === 170 ) { var templateExpression = node . parent ; var tagExpression = templateExpression . parent ; ts . Debug . assert ( templateExpression . kind === 183 ) ; var argumentIndex = ts . isInsideTemplateLiteral ( node , position ) ? 0 : 1 ; return getArgumentListInfoForTemplate ( tagExpression , argumentIndex ) ; } else if ( node . parent . kind === 190 && node . parent . parent . parent . kind === 170 ) { var templateSpan = node . parent ; var templateExpression = templateSpan . parent ; var tagExpression = templateExpression . parent ; ts . Debug . assert ( templateExpression . kind === 183 ) ; if ( node . kind === 14 && ! ts . isInsideTemplateLiteral ( node , position ) ) { return undefined ; } var spanIndex = templateExpression . templateSpans . indexOf ( templateSpan ) ; var argumentIndex = getArgumentIndexForTemplatePiece ( spanIndex , node ) ; return getArgumentListInfoForTemplate ( tagExpression , argumentIndex ) ; } return undefined ; }
490	function selectBestInvalidOverloadIndex ( candidates , argumentCount ) { var maxParamsSignatureIndex = - 1 ; var maxParams = - 1 ; for ( var i = 0 ; i < candidates . length ; i ++ ) { var candidate = candidates [ i ] ; if ( candidate . hasRestParameter || candidate . parameters . length >= argumentCount ) { return i ; } if ( candidate . parameters . length > maxParams ) { maxParams = candidate . parameters . length ; maxParamsSignatureIndex = i ; } } return maxParamsSignatureIndex ; }
491	function getTokenAtPositionWorker ( sourceFile , position , allowPositionInLeadingTrivia , includeItemAtEndPosition ) { var current = sourceFile ; outer : while ( true ) { if ( isToken ( current ) ) { return current ; } for ( var i = 0 , n = current . getChildCount ( sourceFile ) ; i < n ; i ++ ) { var child = current . getChildAt ( i ) ; var start = allowPositionInLeadingTrivia ? child . getFullStart ( ) : child . getStart ( sourceFile ) ; if ( start <= position ) { var end = child . getEnd ( ) ; if ( position < end || ( position === end && child . kind === 1 ) ) { current = child ; continue outer ; } else if ( includeItemAtEndPosition && end === position ) { var previousToken = findPrecedingToken ( position , sourceFile , child ) ; if ( previousToken && includeItemAtEndPosition ( previousToken ) ) { return previousToken ; } } } } return current ; } }
492	function findTokenOnLeftOfPosition ( file , position ) { var tokenAtPosition = getTokenAtPosition ( file , position ) ; if ( isToken ( tokenAtPosition ) && position > tokenAtPosition . getStart ( file ) && position < tokenAtPosition . getEnd ( ) ) { return tokenAtPosition ; } return findPrecedingToken ( position , file ) ; }
493	function getJsDocTagAtPosition ( sourceFile , position ) { var node = ts . getTokenAtPosition ( sourceFile , position ) ; if ( isToken ( node ) ) { switch ( node . kind ) { case 102 : case 108 : case 74 : node = node . parent === undefined ? undefined : node . parent . parent ; break ; default : node = node . parent ; break ; } } if ( node ) { var jsDocComment = node . jsDocComment ; if ( jsDocComment ) { for ( var _i = 0 , _a = jsDocComment . tags ; _i < _a . length ; _i ++ ) { var tag = _a [ _i ] ; if ( tag . pos <= position && position <= tag . end ) { return tag ; } } } } return undefined ; }
494	function stripQuotes ( name ) { var length = name . length ; if ( length >= 2 && name . charCodeAt ( 0 ) === name . charCodeAt ( length - 1 ) && ( name . charCodeAt ( 0 ) === 34 || name . charCodeAt ( 0 ) === 39 ) ) { return name . substring ( 1 , length - 1 ) ; } ; return name ; }
495	function fixTokenKind ( tokenInfo , container ) { if ( ts . isToken ( container ) && tokenInfo . token . kind !== container . kind ) { tokenInfo . token . kind = container . kind ; } return tokenInfo ; }
496	function isListElement ( parent , node ) { switch ( parent . kind ) { case 214 : case 215 : return ts . rangeContainsRange ( parent . members , node ) ; case 218 : var body = parent . body ; return body && body . kind === 192 && ts . rangeContainsRange ( body . statements , node ) ; case 248 : case 192 : case 219 : return ts . rangeContainsRange ( parent . statements , node ) ; case 244 : return ts . rangeContainsRange ( parent . block . statements , node ) ; } return false ; }
497	function findEnclosingNode ( range , sourceFile ) { return find ( sourceFile ) ; function find ( n ) { var candidate = ts . forEachChild ( n , function ( c ) { return ts . startEndContainsRange ( c . getStart ( sourceFile ) , c . end , range ) && c ; } ) ; if ( candidate ) { var result = find ( candidate ) ; if ( result ) { return result ; } } return n ; } }
498	function prepareRangeContainsErrorFunction ( errors , originalRange ) { if ( ! errors . length ) { return rangeHasNoErrors ; } var sorted = errors . filter ( function ( d ) { return ts . rangeOverlapsWithStartEnd ( originalRange , d . start , d . start + d . length ) ; } ) . sort ( function ( e1 , e2 ) { return e1 . start - e2 . start ; } ) ; if ( ! sorted . length ) { return rangeHasNoErrors ; } var index = 0 ; return function ( r ) { while ( true ) { if ( index >= sorted . length ) { return false ; } var error = sorted [ index ] ; if ( r . end <= error . start ) { return false ; } if ( ts . startEndOverlapsWithStartEnd ( r . pos , r . end , error . start , error . start + error . length ) ) { return true ; } index ++ ; } } ; function rangeHasNoErrors ( r ) { return false ; } }
499	function isInsideComment ( sourceFile , token , position ) { return position <= token . getStart ( sourceFile ) && ( isInsideCommentRange ( ts . getTrailingCommentRanges ( sourceFile . text , token . getFullStart ( ) ) ) || isInsideCommentRange ( ts . getLeadingCommentRanges ( sourceFile . text , token . getFullStart ( ) ) ) ) ; function isInsideCommentRange ( comments ) { return ts . forEach ( comments , function ( comment ) { if ( comment . pos < position && position < comment . end ) { return true ; } else if ( position === comment . end ) { var text = sourceFile . text ; var width = comment . end - comment . pos ; if ( width <= 2 || text . charCodeAt ( comment . pos + 1 ) === 47 ) { return true ; } else { return ! ( text . charCodeAt ( comment . end - 1 ) === 47 && text . charCodeAt ( comment . end - 2 ) === 42 ) ; } } return false ; } ) ; } }
500	function getSemanticDiagnostics ( fileName ) { synchronizeHostData ( ) ; var targetSourceFile = getValidSourceFile ( fileName ) ; if ( ts . isJavaScript ( fileName ) ) { return getJavaScriptSemanticDiagnostics ( targetSourceFile ) ; } var semanticDiagnostics = program . getSemanticDiagnostics ( targetSourceFile , cancellationToken ) ; if ( ! program . getCompilerOptions ( ) . declaration ) { return semanticDiagnostics ; } var declarationDiagnostics = program . getDeclarationDiagnostics ( targetSourceFile , cancellationToken ) ; return ts . concatenate ( semanticDiagnostics , declarationDiagnostics ) ; }
501	function getCompletionEntryDisplayName ( name , target , performCharacterChecks ) { if ( ! name ) { return undefined ; } name = ts . stripQuotes ( name ) ; if ( ! name ) { return undefined ; } if ( performCharacterChecks ) { if ( ! ts . isIdentifierStart ( name . charCodeAt ( 0 ) , target ) ) { return undefined ; } for ( var i = 1 , n = name . length ; i < n ; i ++ ) { if ( ! ts . isIdentifierPart ( name . charCodeAt ( i ) , target ) ) { return undefined ; } } } return name ; }
502	function getScopeNode ( initialToken , position , sourceFile ) { var scope = initialToken ; while ( scope && ! ts . positionBelongsToNode ( scope , position , sourceFile ) ) { scope = scope . parent ; } return scope ; }
503	function tryGetObjectLikeCompletionSymbols ( objectLikeContainer ) { isMemberCompletion = true ; var typeForObject ; var existingMembers ; if ( objectLikeContainer . kind === 165 ) { isNewIdentifierLocation = true ; typeForObject = typeChecker . getContextualType ( objectLikeContainer ) ; existingMembers = objectLikeContainer . properties ; } else if ( objectLikeContainer . kind === 161 ) { isNewIdentifierLocation = false ; var rootDeclaration = ts . getRootDeclaration ( objectLikeContainer . parent ) ; if ( ts . isVariableLike ( rootDeclaration ) ) { if ( rootDeclaration . initializer || rootDeclaration . type ) { typeForObject = typeChecker . getTypeAtLocation ( objectLikeContainer ) ; existingMembers = objectLikeContainer . elements ; } } else { ts . Debug . fail ( "Root declaration is not variable-like." ) ; } } else { ts . Debug . fail ( "Expected object literal or binding pattern, got " + objectLikeContainer . kind ) ; } if ( ! typeForObject ) { return false ; } var typeMembers = typeChecker . getPropertiesOfType ( typeForObject ) ; if ( typeMembers && typeMembers . length > 0 ) { symbols = filterObjectMembersList ( typeMembers , existingMembers ) ; } return true ; }
504	function tryGetImportOrExportClauseCompletionSymbols ( namedImportsOrExports ) { var declarationKind = namedImportsOrExports . kind === 225 ? 222 : 228 ; var importOrExportDeclaration = ts . getAncestor ( namedImportsOrExports , declarationKind ) ; var moduleSpecifier = importOrExportDeclaration . moduleSpecifier ; if ( ! moduleSpecifier ) { return false ; } isMemberCompletion = true ; isNewIdentifierLocation = false ; var exports ; var moduleSpecifierSymbol = typeChecker . getSymbolAtLocation ( importOrExportDeclaration . moduleSpecifier ) ; if ( moduleSpecifierSymbol ) { exports = typeChecker . getExportsOfModule ( moduleSpecifierSymbol ) ; } symbols = exports ? filterNamedImportOrExportCompletionItems ( exports , namedImportsOrExports . elements ) : emptyArray ; return true ; }
505	function tryGetObjectLikeCompletionContainer ( contextToken ) { if ( contextToken ) { switch ( contextToken . kind ) { case 15 : case 24 : var parent_10 = contextToken . parent ; if ( parent_10 && ( parent_10 . kind === 165 || parent_10 . kind === 161 ) ) { return parent_10 ; } break ; } } return undefined ; }
506	function filterJsxAttributes ( symbols , attributes ) { var seenNames = { } ; for ( var _i = 0 ; _i < attributes . length ; _i ++ ) { var attr = attributes [ _i ] ; if ( attr . getStart ( ) <= position && position <= attr . getEnd ( ) ) { continue ; } if ( attr . kind === 238 ) { seenNames [ attr . name . text ] = true ; } } return ts . filter ( symbols , function ( a ) { return ! ts . lookUp ( seenNames , a . name ) ; } ) ; }
507	function isWriteAccess ( node ) { if ( node . kind === 69 && ts . isDeclarationName ( node ) ) { return true ; } var parent = node . parent ; if ( parent ) { if ( parent . kind === 180 || parent . kind === 179 ) { return true ; } else if ( parent . kind === 181 && parent . left === node ) { var operator = parent . operatorToken . kind ; return 56 <= operator && operator <= 68 ; } } return false ; }
508	function getSignatureHelpItems ( fileName , position ) { synchronizeHostData ( ) ; var sourceFile = getValidSourceFile ( fileName ) ; return ts . SignatureHelp . getSignatureHelpItems ( program , sourceFile , position , cancellationToken ) ; }
509	function hasValueSideModule ( symbol ) { return ts . forEach ( symbol . declarations , function ( declaration ) { return declaration . kind === 218 && ts . getModuleInstanceState ( declaration ) === 1 ; } ) ; }
510	function classifyTokenType ( tokenKind , token ) { if ( ts . isKeyword ( tokenKind ) ) { return 3 ; } if ( tokenKind === 25 || tokenKind === 27 ) { if ( token && ts . getTypeArgumentOrTypeParameterList ( token . parent ) ) { return 10 ; } } if ( ts . isPunctuation ( tokenKind ) ) { if ( token ) { if ( tokenKind === 56 ) { if ( token . parent . kind === 211 || token . parent . kind === 141 || token . parent . kind === 138 ) { return 5 ; } } if ( token . parent . kind === 181 || token . parent . kind === 179 || token . parent . kind === 180 || token . parent . kind === 182 ) { return 5 ; } } return 10 ; } else if ( tokenKind === 8 ) { return 4 ; } else if ( tokenKind === 9 ) { return 6 ; } else if ( tokenKind === 10 ) { return 6 ; } else if ( ts . isTemplateLiteralKind ( tokenKind ) ) { return 6 ; } else if ( tokenKind === 69 ) { if ( token ) { switch ( token . parent . kind ) { case 214 : if ( token . parent . name === token ) { return 11 ; } return ; case 137 : if ( token . parent . name === token ) { return 15 ; } return ; case 215 : if ( token . parent . name === token ) { return 13 ; } return ; case 217 : if ( token . parent . name === token ) { return 12 ; } return ; case 218 : if ( token . parent . name === token ) { return 14 ; } return ; case 138 : if ( token . parent . name === token ) { return 17 ; } return ; } } return 2 ; } }
511	function getParametersFromRightHandSideOfAssignment ( rightHandSide ) { while ( rightHandSide . kind === 172 ) { rightHandSide = rightHandSide . expression ; } switch ( rightHandSide . kind ) { case 173 : case 174 : return rightHandSide . parameters ; case 186 : for ( var _i = 0 , _a = rightHandSide . members ; _i < _a . length ; _i ++ ) { var member = _a [ _i ] ; if ( member . kind === 144 ) { return member . parameters ; } } break ; } return emptyArray ; }
512	function score ( backend , errorBasis ) { if ( typeof errorBasis !== "number" && ! errorBasis ) errorBasis = Date . now ( ) ; const timeSinceError = ( errorBasis - backend . lastError ) ; const statuses = backend . statuses ; const timeWeight = ( backend . lastError === 0 && 0 ) || ( ( timeSinceError < 1000 ) && 1 ) || ( ( timeSinceError < 3000 ) && 0.8 ) || ( ( timeSinceError < 5000 ) && 0.3 ) || ( ( timeSinceError < 10000 ) && 0.1 ) || 0 ; if ( statuses . length == 0 ) return 0 ; let requests = 0 ; let errors = 0 ; for ( let i = 0 ; i < statuses . length ; i ++ ) { const status = statuses [ i ] ; if ( status && ! isNaN ( status ) ) { requests += 1 ; if ( status >= 500 && status < 600 ) { errors += 1 ; } } } const score = ( 1 - ( timeWeight * ( errors / requests ) ) ) ; backend . healthScore = score ; backend . scoredRequestCount = backend . requestCount ; return score ; }
513	async function origin ( req , init ) { const url = new URL ( req . url ) const status = parseInt ( url . searchParams . get ( 'status' ) || '200' ) if ( status === 200 ) { return new Response ( ` ${ req . url } ${ new Date ( ) } ` ) } else { return new Response ( ` ${ status } ` , { status : status } ) } }
514	function ( element , transform , touch ) { var t = $drag . TRANSLATE_BOTH ( element , transform , touch ) ; var Dx = touch . distanceX ; var t0 = touch . startTransform ; var sign = Dx < 0 ? - 1 : 1 ; var angle = sign * Math . min ( ( Math . abs ( Dx ) / 700 ) * 30 , 30 ) ; t . rotateZ = angle + ( Math . round ( t0 . rotateZ ) ) ; return t ; }
515	function ( t ) { var absAngle = abs ( t . angle ) ; absAngle = absAngle >= 90 ? absAngle - 90 : absAngle ; var validDistance = t . total - t . distance <= TURNAROUND_MAX ; var validAngle = absAngle <= ANGLE_THRESHOLD || absAngle >= 90 - ANGLE_THRESHOLD ; var validVelocity = t . averageVelocity >= VELOCITY_THRESHOLD ; return validDistance && validAngle && validVelocity ; }
516	function ( element , eventHandlers , options ) { options = angular . extend ( { } , defaultOptions , options || { } ) ; return $touch . bind ( element , eventHandlers , options ) ; }
517	function ( type , c , t0 , tl ) { t0 = t0 || { } ; tl = tl || { } ; var ts = now ( ) ; var ts0 = t0 . timestamp || ts ; var tsl = tl . timestamp || ts0 ; var x = c . x ; var y = c . y ; var x0 = t0 . x || x ; var y0 = t0 . y || y ; var xl = tl . x || x0 ; var yl = tl . y || y0 ; var totalXl = tl . totalX || 0 ; var totalYl = tl . totalY || 0 ; var totalX = totalXl + abs ( x - xl ) ; var totalY = totalYl + abs ( y - yl ) ; var total = len ( totalX , totalY ) ; var duration = timediff ( ts , ts0 ) ; var durationl = timediff ( ts , tsl ) ; var dxl = x - xl ; var dyl = y - yl ; var dl = len ( dxl , dyl ) ; var dx = x - x0 ; var dy = y - y0 ; var d = len ( dx , dy ) ; var v = durationl > 0 ? abs ( dl / ( durationl / 1000 ) ) : 0 ; var tv = duration > 0 ? abs ( total / ( duration / 1000 ) ) : 0 ; var dir = abs ( dx ) > abs ( dy ) ? ( dx < 0 ? 'LEFT' : 'RIGHT' ) : ( dy < 0 ? 'TOP' : 'BOTTOM' ) ; var angle = dx !== 0 || dy !== 0 ? atan2 ( dy , dx ) * ( 180 / Math . PI ) : null ; angle = angle === - 180 ? 180 : angle ; return { type : type , timestamp : ts , duration : duration , startX : x0 , startY : y0 , prevX : xl , prevY : yl , x : c . x , y : c . y , step : dl , stepX : dxl , stepY : dyl , velocity : v , averageVelocity : tv , distance : d , distanceX : dx , distanceY : dy , total : total , totalX : totalX , totalY : totalY , direction : dir , angle : angle } ; }
518	function ( event ) { if ( event . touches && event . touches . length > 1 ) { return ; } tl = t0 = buildTouchInfo ( 'touchstart' , getCoordinates ( event ) ) ; $movementTarget . on ( moveEvents , onTouchMove ) ; $movementTarget . on ( endEvents , onTouchEnd ) ; if ( cancelEvents ) { $movementTarget . on ( cancelEvents , onTouchCancel ) ; } if ( startEventHandler ) { startEventHandler ( t0 , event ) ; } }
519	function ( e ) { e = e . length ? e [ 0 ] : e ; var tr = window . getComputedStyle ( e , null ) . getPropertyValue ( transformProperty ) ; return tr ; }
520	function ( elem , value ) { elem = elem . length ? elem [ 0 ] : elem ; elem . style [ styleProperty ] = value ; }
521	function ( e , t ) { var str = ( typeof t === 'string' ) ? t : this . toCss ( t ) ; setElementTransformProperty ( e , str ) ; }
522	function ( _path ) { if ( / ^((pre|post)?loader)s? / ig . test ( _path ) ) { return _path . replace ( / ^((pre|post)?loader)s? / ig , 'module.$1s' ) } if ( / ^(plugin)s? / g . test ( _path ) ) { return _path . replace ( / ^(plugin)s? / g , '$1s' ) } return _path }
523	function getPayload ( token ) { const payloadBase64 = token . split ( "." ) [ 1 ] . replace ( "-" , "+" ) . replace ( "_" , "/" ) ; const payloadDecoded = base64 . decode ( payloadBase64 ) ; const payloadObject = JSON . parse ( payloadDecoded ) ; if ( AV . isNumber ( payloadObject . exp ) ) { payloadObject . exp = new Date ( payloadObject . exp * 1000 ) ; } return payloadObject ; }
524	function setChapterActive ( $chapter , hash ) { if ( ! $chapter && ! hash ) { $chapter = $chapters . first ( ) ; } if ( ! ! hash ) { if ( $chapters . length > 1 ) { $chapter = $chapters . filter ( function ( ) { var titleId = getChapterHash ( $ ( this ) ) ; return titleId == hash ; } ) . first ( ) ; } else { $chapter = $chapters . first ( ) ; } } if ( $chapter . is ( $activeChapter ) ) { return ; } $activeChapter = $chapter ; $chapters . removeClass ( 'active' ) ; $chapter . addClass ( 'active' ) ; hash = getChapterHash ( $chapter ) ; var oldUri = window . location . pathname + window . location . hash , uri = window . location . pathname + hash ; if ( uri != oldUri ) { history . replaceState ( { path : uri } , null , uri ) ; } }
525	function getChapterHash ( $chapter ) { var $link = $chapter . children ( 'a' ) , hash = $link . attr ( 'href' ) . split ( '#' ) [ 1 ] ; if ( hash ) hash = '#' + hash ; return ( ! ! hash ) ? hash : '' ; }
526	function handleScrolling ( ) { var $scroller = getScroller ( ) , scrollTop = $scroller . scrollTop ( ) , scrollHeight = $scroller . prop ( 'scrollHeight' ) , clientHeight = $scroller . prop ( 'clientHeight' ) , nbChapters = $chapters . length , $chapter = null ; $ ( $chapters . get ( ) . reverse ( ) ) . each ( function ( index ) { var titleId = getChapterHash ( $ ( this ) ) , titleTop ; if ( ! ! titleId && ! $chapter ) { titleTop = getElementTopPosition ( titleId ) ; if ( scrollTop >= titleTop ) { $chapter = $ ( this ) ; } } if ( index == ( nbChapters - 1 ) && ! $chapter ) { $chapter = $ ( this ) ; } } ) ; if ( ! $chapter && ! scrollTop ) { $chapter = $chapters . first ( ) ; } if ( ! ! scrollTop && ( scrollHeight - scrollTop == clientHeight ) ) { $chapter = $chapters . last ( ) ; } setChapterActive ( $chapter ) ; }
527	function insertAt ( parent , selector , index , element ) { var lastIndex = parent . children ( selector ) . length ; if ( index < 0 ) { index = Math . max ( 0 , lastIndex + 1 + index ) ; } parent . append ( element ) ; if ( index < lastIndex ) { parent . children ( selector ) . eq ( index ) . before ( parent . children ( selector ) . last ( ) ) ; } }
528	function createDropdownMenu ( dropdown ) { var $menu = $ ( '<div>' , { 'class' : 'dropdown-menu' , 'html' : '<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>' } ) ; if ( typeof dropdown == 'string' ) { $menu . append ( dropdown ) ; } else { var groups = dropdown . map ( function ( group ) { if ( $ . isArray ( group ) ) return group ; else return [ group ] ; } ) ; groups . forEach ( function ( group ) { var $group = $ ( '<div>' , { 'class' : 'buttons' } ) ; var sizeClass = 'size-' + group . length ; group . forEach ( function ( btn ) { btn = $ . extend ( { text : '' , className : '' , onClick : defaultOnClick } , btn || { } ) ; var $btn = $ ( '<button>' , { 'class' : 'button ' + sizeClass + ' ' + btn . className , 'text' : btn . text } ) ; $btn . click ( btn . onClick ) ; $group . append ( $btn ) ; } ) ; $menu . append ( $group ) ; } ) ; } return $menu ; }
529	function createButton ( opts ) { opts = $ . extend ( { label : '' , icon : '' , text : '' , position : 'left' , className : '' , onClick : defaultOnClick , dropdown : null , index : null , id : generateId ( ) } , opts || { } ) ; buttons . push ( opts ) ; updateButton ( opts ) ; return opts . id ; }
530	function removeButton ( id ) { buttons = $ . grep ( buttons , function ( button ) { return button . id != id ; } ) ; updateAllButtons ( ) ; }
531	function removeButtons ( ids ) { buttons = $ . grep ( buttons , function ( button ) { return ids . indexOf ( button . id ) == - 1 ; } ) ; updateAllButtons ( ) ; }
532	function toggleSidebar ( _state , animation ) { if ( gitbook . state != null && isOpen ( ) == _state ) return ; if ( animation == null ) animation = true ; gitbook . state . $book . toggleClass ( 'without-animation' , ! animation ) ; gitbook . state . $book . toggleClass ( 'with-summary' , _state ) ; gitbook . storage . set ( 'sidebar' , isOpen ( ) ) ; }
533	function filterSummary ( paths ) { var $summary = $ ( '.book-summary' ) ; $summary . find ( 'li' ) . each ( function ( ) { var path = $ ( this ) . data ( 'path' ) ; var st = paths == null || paths . indexOf ( path ) !== - 1 ; $ ( this ) . toggle ( st ) ; if ( st ) $ ( this ) . parents ( 'li' ) . show ( ) ; } ) ; }
534	function init ( ) { $ ( document ) . on ( 'click' , '.toggle-dropdown' , toggleDropdown ) ; $ ( document ) . on ( 'click' , '.dropdown-menu' , function ( e ) { e . stopPropagation ( ) ; } ) ; $ ( document ) . on ( 'click' , closeDropdown ) ; }
535	function init ( ) { bindShortcut ( [ 'right' ] , function ( e ) { navigation . goNext ( ) ; } ) ; bindShortcut ( [ 'left' ] , function ( e ) { navigation . goPrev ( ) ; } ) ; bindShortcut ( [ 's' ] , function ( e ) { sidebar . toggle ( ) ; } ) ; }
536	function addDirective ( type ) { return function ( name , directive ) { if ( typeof name === 'function' ) { directive = name } if ( typeof directive !== 'function' ) { throw new TypeError ( 'Directive must be a function' ) } name = typeof name === 'string' ? name : directive . name if ( ! name ) { throw new TypeError ( 'Directive function must have a name' ) } directive . $name = name Toxy [ type ] [ name ] = directive return Toxy } }
537	function Directive ( directive ) { Rule . call ( this ) this . enabled = true this . directive = directive this . name = directive . $name || directive . name }
538	function Toxy ( opts ) { if ( ! ( this instanceof Toxy ) ) return new Toxy ( opts ) opts = Object . assign ( { } , Toxy . defaults , opts ) Proxy . call ( this , opts ) this . routes = [ ] this . _rules = midware ( ) this . _inPoisons = midware ( ) this . _outPoisons = midware ( ) setupMiddleware ( this ) }
539	function getModifiedConfigModuleIndex ( fileStr , snakedEnv , classedEnv ) { const moduleFileAst = acorn . parse ( fileStr , { module : true } ) ; if ( jp . paths ( moduleFileAst , ` ${ classedEnv } ` ) . length > 0 ) { return fileStr ; } const envImportAst = acorn . parse ( ` ${ snakedEnv } ${ classedEnv } ` ) ; const insertAt = jp . paths ( moduleFileAst , '$..[?(@.name=="require")]' ) . pop ( ) [ 2 ] + 1 ; moduleFileAst . body . splice ( insertAt , 0 , envImportAst ) ; const exportsAt = jp . paths ( moduleFileAst , '$..[?(@.name=="exports")]' ) . pop ( ) [ 2 ] ; moduleFileAst . body [ exportsAt ] . expression . right . properties . push ( createExportNode ( snakedEnv ) ) ; return escodegen . generate ( moduleFileAst , { format : { indent : { style : ' ' } } } ) ; }
540	function ( path ) { const data = fs . readFileSync ( path , 'utf8' ) ; const ast = esprima . parse ( data ) ; const cssDialects = [ '\\.cssmodule\\.css$' , \\ ] ; \\ '^.((?!cssmodule).)*\\.css$' \\ const preprocessorDialects = [ '\\.cssmodule\\.(sass|scss)$' , \\ , \\ , '^.((?!cssmodule).)*\\.(sass|scss)$' , \\ , '\\.cssmodule\\.less$' ] ; \\ \\ '^.((?!cssmodule).)*\\.less$' \\ '\\.cssmodule\\.styl$' \\ }
541	function Metadata ( options , controlConnection ) { if ( ! options ) { throw new errors . ArgumentError ( 'Options are not defined' ) ; } Object . defineProperty ( this , 'options' , { value : options , enumerable : false , writable : false } ) ; Object . defineProperty ( this , 'controlConnection' , { value : controlConnection , enumerable : false , writable : false } ) ; this . keyspaces = { } ; this . initialized = false ; this . _schemaParser = schemaParserFactory . getByVersion ( options , controlConnection , this . getUdt . bind ( this ) ) ; const self = this ; this . _preparedQueries = new PreparedQueries ( options . maxPrepared , function ( ) { self . log . apply ( self , arguments ) ; } ) ; }
542	function checkUdtTypes ( type ) { if ( type . code === types . dataTypes . udt ) { const udtName = type . info . split ( '.' ) ; type . info = { keyspace : udtName [ 0 ] , name : udtName [ 1 ] } ; if ( ! type . info . name ) { if ( ! keyspace ) { throw new TypeError ( 'No keyspace specified for udt: ' + udtName . join ( '.' ) ) ; } type . info . name = type . info . keyspace ; type . info . keyspace = keyspace ; } udts . push ( type ) ; return ; } if ( ! type . info ) { return ; } if ( type . code === types . dataTypes . list || type . code === types . dataTypes . set ) { return checkUdtTypes ( type . info ) ; } if ( type . code === types . dataTypes . map ) { checkUdtTypes ( type . info [ 0 ] ) ; checkUdtTypes ( type . info [ 1 ] ) ; } }
543	function PreparedQueries ( maxPrepared , logger ) { this . length = 0 ; this . _maxPrepared = maxPrepared ; this . _mapByKey = { } ; this . _mapById = { } ; this . _logger = logger ; }
544	function DriverError ( message ) { Error . call ( this , message ) ; Error . captureStackTrace ( this , this . constructor ) ; this . name = this . constructor . name ; this . info = 'Cassandra Driver Error' ; this . message = message ; }
545	function NoHostAvailableError ( innerErrors , message ) { DriverError . call ( this , message ) ; this . innerErrors = innerErrors ; this . info = 'Represents an error when a query cannot be performed because no host is available or could be reached by the driver.' ; if ( ! message ) { this . message = 'All host(s) tried for query failed.' ; if ( innerErrors ) { const hostList = Object . keys ( innerErrors ) ; if ( hostList . length > 0 ) { const host = hostList [ 0 ] ; this . message += util . format ( ' First host tried, %s: %s. See innerErrors.' , host , innerErrors [ host ] ) ; } } } }
546	function BusyConnectionError ( address , maxRequestsPerConnection , connectionLength ) { const message = util . format ( 'All connections to host %s are busy, %d requests are in-flight on %s' , address , maxRequestsPerConnection , connectionLength === 1 ? 'a single connection' : 'each connection' ) ; DriverError . call ( this , message , this . constructor ) ; this . info = 'Represents a client-side error indicating that all connections to a certain host have reached ' + 'the maximum amount of in-flight requests supported (pooling.maxRequestsPerConnection)' ; }
547	function extend ( baseOptions , userOptions ) { if ( arguments . length === 1 ) { userOptions = arguments [ 0 ] ; baseOptions = { } ; } const options = utils . deepExtend ( baseOptions , defaultOptions ( ) , userOptions ) ; if ( ! util . isArray ( options . contactPoints ) || options . contactPoints . length === 0 ) { throw new TypeError ( 'Contacts points are not defined.' ) ; } for ( let i = 0 ; i < options . contactPoints . length ; i ++ ) { const hostName = options . contactPoints [ i ] ; if ( ! hostName ) { throw new TypeError ( util . format ( 'Contact point %s (%s) is not a valid host name, ' + 'the following values are valid contact points: ipAddress, hostName or ipAddress:port' , i , hostName ) ) ; } } if ( ! options . logEmitter ) { options . logEmitter = function ( ) { } ; } if ( ! options . queryOptions ) { throw new TypeError ( 'queryOptions not defined in options' ) ; } if ( options . requestTracker !== null && ! ( options . requestTracker instanceof tracker . RequestTracker ) ) { throw new TypeError ( 'requestTracker must be an instance of RequestTracker' ) ; } if ( ! ( options . metrics instanceof metrics . ClientMetrics ) ) { throw new TypeError ( 'metrics must be an instance of ClientMetrics' ) ; } validatePoliciesOptions ( options . policies ) ; validateProtocolOptions ( options . protocolOptions ) ; validateSocketOptions ( options . socketOptions ) ; options . encoding = options . encoding || { } ; validateEncodingOptions ( options . encoding ) ; if ( options . profiles && ! util . isArray ( options . profiles ) ) { throw new TypeError ( 'profiles must be an Array of ExecutionProfile instances' ) ; } return options ; }
548	function validatePoliciesOptions ( policiesOptions ) { if ( ! policiesOptions ) { throw new TypeError ( 'policies not defined in options' ) ; } if ( ! ( policiesOptions . loadBalancing instanceof policies . loadBalancing . LoadBalancingPolicy ) ) { throw new TypeError ( 'Load balancing policy must be an instance of LoadBalancingPolicy' ) ; } if ( ! ( policiesOptions . reconnection instanceof policies . reconnection . ReconnectionPolicy ) ) { throw new TypeError ( 'Reconnection policy must be an instance of ReconnectionPolicy' ) ; } if ( ! ( policiesOptions . retry instanceof policies . retry . RetryPolicy ) ) { throw new TypeError ( 'Retry policy must be an instance of RetryPolicy' ) ; } if ( ! ( policiesOptions . addressResolution instanceof policies . addressResolution . AddressTranslator ) ) { throw new TypeError ( 'Address resolution policy must be an instance of AddressTranslator' ) ; } if ( policiesOptions . timestampGeneration !== null && ! ( policiesOptions . timestampGeneration instanceof policies . timestampGeneration . TimestampGenerator ) ) { throw new TypeError ( 'Timestamp generation policy must be an instance of TimestampGenerator' ) ; } }
549	function validateProtocolOptions ( protocolOptions ) { if ( ! protocolOptions ) { throw new TypeError ( 'protocolOptions not defined in options' ) ; } const version = protocolOptions . maxVersion ; if ( version && ( typeof version !== 'number' || ! types . protocolVersion . isSupported ( version ) ) ) { throw new TypeError ( util . format ( 'protocolOptions.maxVersion provided (%s) is invalid' , version ) ) ; } }
550	function validateSocketOptions ( socketOptions ) { if ( ! socketOptions ) { throw new TypeError ( 'socketOptions not defined in options' ) ; } if ( typeof socketOptions . readTimeout !== 'number' ) { throw new TypeError ( 'socketOptions.readTimeout must be a Number' ) ; } if ( typeof socketOptions . coalescingThreshold !== 'number' || socketOptions . coalescingThreshold <= 0 ) { throw new TypeError ( 'socketOptions.coalescingThreshold must be a positive Number' ) ; } }
551	function validateEncodingOptions ( encodingOptions ) { if ( encodingOptions . map ) { const mapConstructor = encodingOptions . map ; if ( typeof mapConstructor !== 'function' || typeof mapConstructor . prototype . forEach !== 'function' || typeof mapConstructor . prototype . set !== 'function' ) { throw new TypeError ( 'Map constructor not valid' ) ; } } if ( encodingOptions . set ) { const setConstructor = encodingOptions . set ; if ( typeof setConstructor !== 'function' || typeof setConstructor . prototype . forEach !== 'function' || typeof setConstructor . prototype . add !== 'function' ) { throw new TypeError ( 'Set constructor not valid' ) ; } } if ( ( encodingOptions . useBigIntAsLong || encodingOptions . useBigIntAsVarint ) && typeof BigInt === 'undefined' ) { throw new TypeError ( 'BigInt is not supported by the JavaScript engine' ) ; } }
552	function setProtocolDependentDefaults ( options , version ) { let coreConnectionsPerHost = coreConnectionsPerHostV3 ; let maxRequestsPerConnection = maxRequestsPerConnectionV3 ; if ( ! types . protocolVersion . uses2BytesStreamIds ( version ) ) { coreConnectionsPerHost = coreConnectionsPerHostV2 ; maxRequestsPerConnection = maxRequestsPerConnectionV2 ; } options . pooling = utils . deepExtend ( { } , { coreConnectionsPerHost , maxRequestsPerConnection } , options . pooling ) ; }
553	function ( name ) { name = name . toLowerCase ( ) ; if ( name . indexOf ( '<' ) > 0 ) { const listMatches = / ^(list|set)<(.+)>$ / . exec ( name ) ; if ( listMatches ) { return { code : this [ listMatches [ 1 ] ] , info : this . getByName ( listMatches [ 2 ] ) } ; } const mapMatches = / ^(map)< *(.+) *, *(.+)>$ / . exec ( name ) ; if ( mapMatches ) { return { code : this [ mapMatches [ 1 ] ] , info : [ this . getByName ( mapMatches [ 2 ] ) , this . getByName ( mapMatches [ 3 ] ) ] } ; } const udtMatches = / ^(udt)<(.+)>$ / . exec ( name ) ; if ( udtMatches ) { return { code : this [ udtMatches [ 1 ] ] , info : udtMatches [ 2 ] } ; } const tupleMatches = / ^(tuple)<(.+)>$ / . exec ( name ) ; if ( tupleMatches ) { return { code : this [ tupleMatches [ 1 ] ] , info : tupleMatches [ 2 ] . split ( ',' ) . map ( function ( x ) { return this . getByName ( x . trim ( ) ) ; } , this ) } ; } } const typeInfo = { code : this [ name ] , info : null } ; if ( typeof typeInfo . code !== 'number' ) { throw new TypeError ( 'Data type with name ' + name + ' not valid' ) ; } return typeInfo ; }
554	function getDataTypeNameByCode ( item ) { if ( ! item || typeof item . code !== 'number' ) { throw new errors . ArgumentError ( 'Invalid signature type definition' ) ; } const typeName = _dataTypesByCode [ item . code ] ; if ( ! typeName ) { throw new errors . ArgumentError ( util . format ( 'Type with code %d not found' , item . code ) ) ; } if ( ! item . info ) { return typeName ; } if ( util . isArray ( item . info ) ) { return ( typeName + '<' + item . info . map ( function ( t ) { return getDataTypeNameByCode ( t ) ; } ) . join ( ', ' ) + '>' ) ; } if ( typeof item . info . code === 'number' ) { return typeName + '<' + getDataTypeNameByCode ( item . info ) + '>' ; } return typeName ; }
555	function FrameHeader ( version , flags , streamId , opcode , bodyLength ) { this . version = version ; this . flags = flags ; this . streamId = streamId ; this . opcode = opcode ; this . bodyLength = bodyLength ; }
556	function generateTimestamp ( date , microseconds ) { if ( ! date ) { date = new Date ( ) ; } let longMicro = Long . ZERO ; if ( typeof microseconds === 'number' && microseconds >= 0 && microseconds < 1000 ) { longMicro = Long . fromInt ( microseconds ) ; } else { if ( _timestampTicks > 999 ) { _timestampTicks = 0 ; } longMicro = Long . fromInt ( _timestampTicks ) ; _timestampTicks ++ ; } return Long . fromNumber ( date . getTime ( ) ) . multiply ( _longOneThousand ) . add ( longMicro ) ; }
557	function MutableLong ( b00 , b16 , b32 , b48 ) { this . _arr = [ b00 & 0xffff , b16 & 0xffff , b32 & 0xffff , b48 & 0xffff ] ; }
558	function Aggregate ( ) { this . name = null ; this . keyspaceName = null ; this . signature = null ; this . argumentTypes = null ; this . stateFunction = null ; this . stateType = null ; this . finalFunction = null ; this . initConditionRaw = null ; this . initCondition = null ; this . returnType = null ; }
559	function Host ( address , protocolVersion , options , metadata ) { events . EventEmitter . call ( this ) ; this . address = address ; this . setDownAt = 0 ; this . isUpSince = null ; Object . defineProperty ( this , 'options' , { value : options , enumerable : false , writable : false } ) ; Object . defineProperty ( this , 'pool' , { value : new HostConnectionPool ( this , protocolVersion ) , enumerable : false } ) ; const self = this ; this . pool . on ( 'open' , this . _onNewConnectionOpen . bind ( this ) ) ; this . pool . on ( 'remove' , function onConnectionRemovedFromPool ( ) { self . _checkPoolState ( ) ; } ) ; this . cassandraVersion = null ; this . datacenter = null ; this . rack = null ; this . tokens = null ; this . hostId = null ; this . _distance = types . distance . ignored ; this . _healthResponseCounter = 0 ; Object . defineProperty ( this , '_metadata' , { value : metadata , enumerable : false } ) ; Object . defineProperty ( this , '_healthResponseCountTimer' , { value : null , enumerable : false , writable : true } ) ; this . reconnectionSchedule = this . options . policies . reconnection . newSchedule ( ) ; this . reconnectionDelay = 0 ; }
560	function ConstantSpeculativeExecutionPolicy ( delay , maxSpeculativeExecutions ) { if ( ! ( delay >= 0 ) ) { throw new errors . ArgumentError ( 'delay must be a positive number or zero' ) ; } if ( ! ( maxSpeculativeExecutions > 0 ) ) { throw new errors . ArgumentError ( 'maxSpeculativeExecutions must be a positive number' ) ; } this . _delay = delay ; this . _maxSpeculativeExecutions = maxSpeculativeExecutions ; }
561	function MaterializedView ( name ) { DataCollection . call ( this , name ) ; this . tableName = null ; this . whereClause = null ; this . includeAllColumns = false ; }
562	function DataCollection ( name ) { events . EventEmitter . call ( this ) ; this . setMaxListeners ( 0 ) ; Object . defineProperty ( this , 'loading' , { value : false , enumerable : false , writable : true } ) ; Object . defineProperty ( this , 'loaded' , { value : false , enumerable : false , writable : true } ) ; this . name = name ; this . bloomFilterFalsePositiveChance = 0 ; this . caching = null ; this . comment = null ; this . gcGraceSeconds = 0 ; this . compactionClass = null ; this . compactionOptions = null ; this . compression = null ; this . localReadRepairChance = 0 ; this . readRepairChance = 0 ; this . extensions = null ; this . crcCheckChance = null ; this . populateCacheOnFlush = false ; this . defaultTtl = 0 ; this . speculativeRetry = 'NONE' ; this . minIndexInterval = 128 ; this . maxIndexInterval = 2048 ; this . columns = null ; this . columnsByName = null ; this . partitionKeys = [ ] ; this . clusteringKeys = [ ] ; this . clusteringOrder = [ ] ; }
563	async function example ( ) { await client . connect ( ) ; await client . execute ( ` ` ) ; await client . execute ( ` ` ) ; await client . execute ( ` ` ) ; const concurrencyLevel = 32 ; const promises = new Array ( concurrencyLevel ) ; const info = { totalLength : 10000 , counter : 0 } ; for ( let i = 0 ; i < concurrencyLevel ; i ++ ) { promises [ i ] = executeOneAtATime ( info ) ; } try { await Promise . all ( promises ) ; console . log ( ` ${ info . totalLength } ${ concurrencyLevel } ` ) ; } finally { client . shutdown ( ) ; } }
564	function TableMetadata ( name ) { DataCollection . call ( this , name ) ; this . replicateOnWrite = true ; this . memtableFlushPeriod = 0 ; this . indexInterval = null ; this . isCompact = false ; this . indexes = null ; this . cdc = null ; this . virtual = false ; }
565	function SchemaParserV1 ( options , cc ) { SchemaParser . call ( this , options , cc ) ; this . selectTable = _selectTableV1 ; this . selectColumns = _selectColumnsV1 ; this . selectUdt = _selectUdtV1 ; this . selectAggregates = _selectAggregatesV1 ; this . selectFunctions = _selectFunctionsV1 ; }
566	function SchemaParserV2 ( options , cc , udtResolver ) { SchemaParser . call ( this , options , cc ) ; this . udtResolver = udtResolver ; this . selectTable = _selectTableV2 ; this . selectColumns = _selectColumnsV2 ; this . selectUdt = _selectUdtV2 ; this . selectAggregates = _selectAggregatesV2 ; this . selectFunctions = _selectFunctionsV2 ; this . selectIndexes = _selectIndexesV2 ; }
567	function SchemaParserV3 ( options , cc , udtResolver ) { SchemaParserV2 . call ( this , options , cc , udtResolver ) ; this . supportsVirtual = true ; }
568	function getByVersion ( options , cc , udtResolver , version , currentInstance ) { let parserConstructor = SchemaParserV1 ; if ( version && version [ 0 ] === 3 ) { parserConstructor = SchemaParserV2 ; } else if ( version && version [ 0 ] >= 4 ) { parserConstructor = SchemaParserV3 ; } if ( ! currentInstance || ! ( currentInstance instanceof parserConstructor ) ) { return new parserConstructor ( options , cc , udtResolver ) ; } return currentInstance ; }
569	function encodeRoutingKey ( fromUser ) { const encoder = self . _getEncoder ( ) ; try { if ( fromUser ) { encoder . setRoutingKeyFromUser ( params , execOptions ) ; } else { encoder . setRoutingKeyFromMeta ( meta , params , execOptions ) ; } } catch ( err ) { return callback ( err ) ; } callback ( ) ; }
570	function getJsFiles ( dir , fileArray ) { const files = fs . readdirSync ( dir ) ; fileArray = fileArray || [ ] ; files . forEach ( function ( file ) { if ( file === 'node_modules' ) { return ; } if ( fs . statSync ( dir + file ) . isDirectory ( ) ) { getJsFiles ( dir + file + '/' , fileArray ) ; return ; } if ( file . substring ( file . length - 3 , file . length ) !== '.js' ) { return ; } fileArray . push ( dir + file ) ; } ) ; return fileArray ; }
571	function SchemaFunction ( ) { this . name = null ; this . keyspaceName = null ; this . signature = null ; this . argumentNames = null ; this . argumentTypes = null ; this . body = null ; this . calledOnNullInput = null ; this . language = null ; this . returnType = null ; }
572	function copyBuffer ( buf ) { const targetBuffer = allocBufferUnsafe ( buf . length ) ; buf . copy ( targetBuffer ) ; return targetBuffer ; }
573	function fixStack ( stackTrace , error ) { if ( stackTrace ) { error . stack += '\n (event loop)\n' + \n ; } \n }
574	function log ( type , info , furtherInfo ) { if ( ! this . logEmitter ) { if ( ! this . options || ! this . options . logEmitter ) { throw new Error ( 'Log emitter not defined' ) ; } this . logEmitter = this . options . logEmitter ; } this . logEmitter ( 'log' , type , this . constructor . name , info , furtherInfo || '' ) ; }
575	function toLowerCaseProperties ( obj ) { const keys = Object . keys ( obj ) ; const result = { } ; for ( let i = 0 ; i < keys . length ; i ++ ) { const k = keys [ i ] ; result [ k . toLowerCase ( ) ] = obj [ k ] ; } return result ; }
576	function deepExtend ( target ) { const sources = Array . prototype . slice . call ( arguments , 1 ) ; sources . forEach ( function ( source ) { for ( const prop in source ) { if ( ! source . hasOwnProperty ( prop ) ) { continue ; } const targetProp = target [ prop ] ; const targetType = ( typeof targetProp ) ; if ( ! targetProp || targetType === 'number' || targetType === 'string' || util . isArray ( targetProp ) || util . isDate ( targetProp ) || targetProp . constructor . name !== 'Object' ) { target [ prop ] = source [ prop ] ; } else { target [ prop ] = deepExtend ( { } , targetProp , source [ prop ] ) ; } } } ) ; return target ; }
577	function arrayIterator ( arr ) { let index = 0 ; return { next : function ( ) { if ( index >= arr . length ) { return { done : true } ; } return { value : arr [ index ++ ] , done : false } ; } } ; }
578	function iteratorToArray ( iterator ) { const values = [ ] ; let item = iterator . next ( ) ; while ( ! item . done ) { values . push ( item . value ) ; item = iterator . next ( ) ; } return values ; }
579	function binarySearch ( arr , key , compareFunc ) { let low = 0 ; let high = arr . length - 1 ; while ( low <= high ) { const mid = ( low + high ) >>> 1 ; const midVal = arr [ mid ] ; const cmp = compareFunc ( midVal , key ) ; if ( cmp < 0 ) { low = mid + 1 ; } else if ( cmp > 0 ) { high = mid - 1 ; } else { return mid ; } } return ~ low ; }
580	function insertSorted ( arr , item , compareFunc ) { if ( arr . length === 0 ) { return arr . push ( item ) ; } let position = binarySearch ( arr , item , compareFunc ) ; if ( position < 0 ) { position = ~ position ; } arr . splice ( position , 0 , item ) ; }
581	function validateFn ( fn , name ) { if ( typeof fn !== 'function' ) { throw new errors . ArgumentError ( util . format ( '%s is not a function' , name || 'callback' ) ) ; } return fn ; }
582	function stringRepeat ( val , times ) { if ( ! times || times < 0 ) { return null ; } if ( times === 1 ) { return val ; } return new Array ( times + 1 ) . join ( val ) ; }
583	function promiseWrapper ( options , originalCallback , handler ) { if ( typeof originalCallback === 'function' ) { handler . call ( this , originalCallback ) ; return undefined ; } const factory = options . promiseFactory || defaultPromiseFactory ; const self = this ; return factory ( function handlerWrapper ( callback ) { handler . call ( self , callback ) ; } ) ; }
584	function WhiteListPolicy ( childPolicy , whiteList ) { if ( ! childPolicy ) { throw new Error ( "You must specify a child load balancing policy" ) ; } if ( ! util . isArray ( whiteList ) ) { throw new Error ( "You must provide the white list of host addresses" ) ; } this . childPolicy = childPolicy ; const map = { } ; whiteList . forEach ( function ( address ) { map [ address ] = true ; } ) ; this . whiteList = map ; }
585	function EventDebouncer ( delay , logger ) { this . _delay = delay ; this . _logger = logger ; this . _queue = null ; this . _timeout = null ; }
586	function FrameReader ( header , body , offset ) { this . header = header ; this . opcode = header . opcode ; this . offset = offset || 0 ; this . buf = body ; }
587	function Connection ( endpoint , protocolVersion , options ) { events . EventEmitter . call ( this ) ; this . setMaxListeners ( 0 ) ; if ( ! options ) { throw new Error ( 'options is not defined' ) ; } this . endpoint = endpoint ; this . endpointFriendlyName = endpoint ; if ( ! this . endpoint || this . endpoint . indexOf ( ':' ) < 0 ) { throw new Error ( 'EndPoint must contain the ip address and port separated by : symbol' ) ; } const portSeparatorIndex = this . endpoint . lastIndexOf ( ':' ) ; this . address = this . endpoint . substr ( 0 , portSeparatorIndex ) ; this . port = this . endpoint . substr ( portSeparatorIndex + 1 ) ; Object . defineProperty ( this , "options" , { value : options , enumerable : false , writable : false } ) ; if ( protocolVersion === null ) { protocolVersion = types . protocolVersion . maxSupported ; if ( options . protocolOptions . maxVersion ) { protocolVersion = options . protocolOptions . maxVersion ; } this . _checkingVersion = true ; } this . protocolVersion = protocolVersion ; this . _operations = { } ; this . _pendingWrites = [ ] ; this . _preparing = { } ; this . _idleTimeout = null ; this . timedOutOperations = 0 ; this . _streamIds = new StreamIdStack ( this . protocolVersion ) ; this . _metrics = options . metrics ; this . encoder = new Encoder ( protocolVersion , options ) ; this . keyspace = null ; this . emitDrain = false ; this . connected = false ; this . isSocketOpen = false ; }
588	function getClockId ( clockId ) { let buffer = clockId ; if ( typeof clockId === 'string' ) { buffer = utils . allocBufferFromString ( clockId , 'ascii' ) ; } if ( ! ( buffer instanceof Buffer ) ) { buffer = getRandomBytes ( 2 ) ; } else if ( buffer . length !== 2 ) { throw new Error ( 'Clock identifier must have 2 bytes' ) ; } return buffer ; }
589	function getNodeId ( nodeId ) { let buffer = nodeId ; if ( typeof nodeId === 'string' ) { buffer = utils . allocBufferFromString ( nodeId , 'ascii' ) ; } if ( ! ( buffer instanceof Buffer ) ) { buffer = getRandomBytes ( 6 ) ; } else if ( buffer . length !== 6 ) { throw new Error ( 'Node identifier must have 6 bytes' ) ; } return buffer ; }
590	function getTicks ( ticks ) { if ( typeof ticks !== 'number' || ticks >= _ticksInMs ) { _ticks ++ ; if ( _ticks >= _ticksInMs ) { _ticks = 0 ; } ticks = _ticks ; } return ticks ; }
591	function getTimeWithTicks ( date , ticks ) { if ( ! ( date instanceof Date ) || isNaN ( date . getTime ( ) ) ) { date = new Date ( ) ; const time = date . getTime ( ) ; _ticksForCurrentTime ++ ; if ( _ticksForCurrentTime > _ticksInMs || time > _lastTimestamp ) { _ticksForCurrentTime = 0 ; _lastTimestamp = time ; } ticks = _ticksForCurrentTime ; } return { time : date . getTime ( ) , ticks : getTicks ( ticks ) } ; }
592	function generateBuffer ( date , ticks , nodeId , clockId ) { const timeWithTicks = getTimeWithTicks ( date , ticks ) ; nodeId = getNodeId ( nodeId ) ; clockId = getClockId ( clockId ) ; const buffer = utils . allocBufferUnsafe ( 16 ) ; writeTime ( buffer , timeWithTicks . time , timeWithTicks . ticks ) ; clockId . copy ( buffer , 8 , 0 ) ; nodeId . copy ( buffer , 10 , 0 ) ; buffer [ 6 ] = buffer [ 6 ] & 0x0f ; buffer [ 6 ] = buffer [ 6 ] | 0x10 ; buffer [ 8 ] = buffer [ 8 ] & 0x3f ; buffer [ 8 ] = buffer [ 8 ] | 0x80 ; return buffer ; }
593	function Encoder ( protocolVersion , options ) { this . encodingOptions = options . encoding || utils . emptyObject ; defineInstanceMembers . call ( this ) ; this . setProtocolVersion ( protocolVersion ) ; setEncoders . call ( this ) ; if ( this . encodingOptions . copyBuffer ) { this . handleBuffer = handleBufferCopy ; } else { this . handleBuffer = handleBufferRef ; } }
594	function numberOfLeadingZeros ( value ) { if ( value . equals ( Long . ZERO ) ) { return 64 ; } let n = 1 ; let x = value . getHighBits ( ) ; if ( x === 0 ) { n += 32 ; x = value . getLowBits ( ) ; } if ( x >>> 16 === 0 ) { n += 16 ; x <<= 16 ; } if ( x >>> 24 === 0 ) { n += 8 ; x <<= 8 ; } if ( x >>> 28 === 0 ) { n += 4 ; x <<= 4 ; } if ( x >>> 30 === 0 ) { n += 2 ; x <<= 2 ; } n -= x >>> 31 ; return n ; }
595	function Index ( name , target , kind , options ) { this . name = name ; this . target = target ; this . kind = typeof kind === 'string' ? getKindByName ( kind ) : kind ; this . options = options ; }
596	function ( key ) { return _ . sortBy ( files , function ( el ) { return Number ( $ ( el ) . find ( 'span[data-lint]' ) . attr ( key ) ) * - 1 ; } ) ; }
597	function loadMode ( cm ) { var doc = cm . view . doc ; cm . view . mode = CodeMirror . getMode ( cm . options , cm . options . mode ) ; doc . iter ( 0 , doc . size , function ( line ) { line . stateAfter = null ; } ) ; cm . view . frontier = 0 ; startWorker ( cm , 100 ) ; }
598	function updateScrollbars ( d , docHeight ) { var totalHeight = docHeight + 2 * paddingTop ( d ) ; d . sizer . style . minHeight = d . heightForcer . style . top = totalHeight + "px" ; var scrollHeight = Math . max ( totalHeight , d . scroller . scrollHeight ) ; var needsH = d . scroller . scrollWidth > d . scroller . clientWidth ; var needsV = scrollHeight > d . scroller . clientHeight ; if ( needsV ) { d . scrollbarV . style . display = "block" ; d . scrollbarV . style . bottom = needsH ? scrollbarWidth ( d . measure ) + "px" : "0" ; d . scrollbarV . firstChild . style . height = ( scrollHeight - d . scroller . clientHeight + d . scrollbarV . clientHeight ) + "px" ; } else d . scrollbarV . style . display = "" ; if ( needsH ) { d . scrollbarH . style . display = "block" ; d . scrollbarH . style . right = needsV ? scrollbarWidth ( d . measure ) + "px" : "0" ; d . scrollbarH . firstChild . style . width = ( d . scroller . scrollWidth - d . scroller . clientWidth + d . scrollbarH . clientWidth ) + "px" ; } else d . scrollbarH . style . display = "" ; if ( needsH && needsV ) { d . scrollbarFiller . style . display = "block" ; d . scrollbarFiller . style . height = d . scrollbarFiller . style . width = scrollbarWidth ( d . measure ) + "px" ; } else d . scrollbarFiller . style . display = "" ; if ( mac_geLion && scrollbarWidth ( d . measure ) === 0 ) d . scrollbarV . style . minWidth = d . scrollbarH . style . minHeight = mac_geMountainLion ? "18px" : "12px" ; }
599	function restartBlink ( cm ) { var display = cm . display ; clearInterval ( display . blinker ) ; var on = true ; display . cursor . style . visibility = display . otherCursor . style . visibility = "" ; display . blinker = setInterval ( function ( ) { if ( ! display . cursor . offsetHeight ) return ; display . cursor . style . visibility = display . otherCursor . style . visibility = ( on = ! on ) ? "" : "hidden" ; } , cm . options . cursorBlinkRate ) ; }
600	function coordsChar ( cm , x , y ) { var doc = cm . view . doc ; y += cm . display . viewOffset ; if ( y < 0 ) return { line : 0 , ch : 0 , outside : true } ; var lineNo = lineAtHeight ( doc , y ) ; if ( lineNo >= doc . size ) return { line : doc . size - 1 , ch : getLine ( doc , doc . size - 1 ) . text . length } ; if ( x < 0 ) x = 0 ; for ( ; ; ) { var lineObj = getLine ( doc , lineNo ) ; var found = coordsCharInner ( cm , lineObj , lineNo , x , y ) ; var merged = collapsedSpanAtEnd ( lineObj ) ; if ( merged && found . ch == lineRight ( lineObj ) ) lineNo = merged . find ( ) . to . line ; else return found ; } }
601	function updateDoc ( cm , from , to , newText , selUpdate , origin ) { var split = sawReadOnlySpans && removeReadOnlyRanges ( cm . view . doc , from , to ) ; if ( split ) { for ( var i = split . length - 1 ; i >= 1 ; -- i ) updateDocInner ( cm , split [ i ] . from , split [ i ] . to , [ "" ] , origin ) ; if ( split . length ) return updateDocInner ( cm , split [ 0 ] . from , split [ 0 ] . to , newText , selUpdate , origin ) ; } else { return updateDocInner ( cm , from , to , newText , selUpdate , origin ) ; } }
602	function setSelection ( cm , anchor , head , bias , checkAtomic ) { cm . view . goalColumn = null ; var sel = cm . view . sel ; if ( checkAtomic || ! posEq ( anchor , sel . anchor ) ) anchor = skipAtomic ( cm , anchor , bias , checkAtomic != "push" ) ; if ( checkAtomic || ! posEq ( head , sel . head ) ) head = skipAtomic ( cm , head , bias , checkAtomic != "push" ) ; if ( posEq ( sel . anchor , anchor ) && posEq ( sel . head , head ) ) return ; sel . anchor = anchor ; sel . head = head ; var inv = posLess ( head , anchor ) ; sel . from = inv ? head : anchor ; sel . to = inv ? anchor : head ; cm . curOp . updateInput = true ; cm . curOp . selectionChanged = true ; }
603	function highlightLine ( cm , line , state ) { var mode = cm . view . mode , flattenSpans = cm . options . flattenSpans ; var changed = ! line . styles , pos = 0 , curText = "" , curStyle = null ; var stream = new StringStream ( line . text , cm . options . tabSize ) , st = line . styles || ( line . styles = [ ] ) ; if ( line . text == "" && mode . blankLine ) mode . blankLine ( state ) ; while ( ! stream . eol ( ) ) { var style = mode . token ( stream , state ) , substr = stream . current ( ) ; stream . start = stream . pos ; if ( ! flattenSpans || curStyle != style ) { if ( curText ) { changed = changed || pos >= st . length || curText != st [ pos ] || curStyle != st [ pos + 1 ] ; st [ pos ++ ] = curText ; st [ pos ++ ] = curStyle ; } curText = substr ; curStyle = style ; } else curText = curText + substr ; if ( stream . pos > 5000 ) break ; } if ( curText ) { changed = changed || pos >= st . length || curText != st [ pos ] || curStyle != st [ pos + 1 ] ; st [ pos ++ ] = curText ; st [ pos ++ ] = curStyle ; } if ( stream . pos > 5000 ) { st [ pos ++ ] = line . text . slice ( stream . pos ) ; st [ pos ++ ] = null ; } if ( pos != st . length ) { st . length = pos ; changed = true ; } return changed ; }
604	function e_prop ( e , prop ) { var overridden = e . override && e . override . hasOwnProperty ( prop ) ; return overridden ? e . override [ prop ] : e [ prop ] ; }
605	function Flow ( opts ) { this . support = ( typeof File !== 'undefined' && typeof Blob !== 'undefined' && typeof FileList !== 'undefined' && ( ! ! Blob . prototype . slice || ! ! Blob . prototype . webkitSlice || ! ! Blob . prototype . mozSlice || false ) ) ; if ( ! this . support ) { return ; } this . supportDirectory = ( / Chrome / . test ( window . navigator . userAgent ) || / Firefox / . test ( window . navigator . userAgent ) || / Edge / . test ( window . navigator . userAgent ) ) ; this . files = [ ] ; this . defaults = { chunkSize : 1024 * 1024 , forceChunkSize : false , simultaneousUploads : 3 , singleFile : false , fileParameterName : 'file' , progressCallbacksInterval : 500 , speedSmoothingFactor : 0.1 , query : { } , headers : { } , withCredentials : false , preprocess : null , method : 'multipart' , testMethod : 'GET' , uploadMethod : 'POST' , prioritizeFirstAndLastChunk : false , allowDuplicateUploads : false , target : '/' , testChunks : true , generateUniqueIdentifier : null , maxChunkRetries : 0 , chunkRetryInterval : null , permanentErrors : [ 404 , 413 , 415 , 500 , 501 ] , successStatuses : [ 200 , 201 , 202 ] , onDropStopPropagation : false , initFileFn : null , readFileFn : webAPIFileRead } ; this . opts = { } ; this . events = { } ; var $ = this ; this . onDrop = function ( event ) { if ( $ . opts . onDropStopPropagation ) { event . stopPropagation ( ) ; } event . preventDefault ( ) ; var dataTransfer = event . dataTransfer ; if ( dataTransfer . items && dataTransfer . items [ 0 ] && dataTransfer . items [ 0 ] . webkitGetAsEntry ) { $ . webkitReadDataTransfer ( event ) ; } else { $ . addFiles ( dataTransfer . files , event ) ; } } ; this . preventEvent = function ( event ) { event . preventDefault ( ) ; } ; this . opts = Flow . extend ( { } , this . defaults , opts || { } ) ; }
606	function ( event , fn ) { if ( event !== undefined ) { event = event . toLowerCase ( ) ; if ( fn !== undefined ) { if ( this . events . hasOwnProperty ( event ) ) { arrayRemove ( this . events [ event ] , fn ) ; } } else { delete this . events [ event ] ; } } else { this . events = { } ; } }
607	function ( event , args ) { args = Array . prototype . slice . call ( arguments ) ; event = event . toLowerCase ( ) ; var preventDefault = false ; if ( this . events . hasOwnProperty ( event ) ) { each ( this . events [ event ] , function ( callback ) { preventDefault = callback . apply ( this , args . slice ( 1 ) ) === false || preventDefault ; } , this ) ; } if ( event != 'catchall' ) { args . unshift ( 'catchAll' ) ; preventDefault = this . fire . apply ( this , args ) === false || preventDefault ; } return ! preventDefault ; }
608	function ( event ) { var $ = this ; var queue = event . dataTransfer . items . length ; var files = [ ] ; each ( event . dataTransfer . items , function ( item ) { var entry = item . webkitGetAsEntry ( ) ; if ( ! entry ) { decrement ( ) ; return ; } if ( entry . isFile ) { fileReadSuccess ( item . getAsFile ( ) , entry . fullPath ) ; } else { readDirectory ( entry . createReader ( ) ) ; } } ) ; function readDirectory ( reader ) { reader . readEntries ( function ( entries ) { if ( entries . length ) { queue += entries . length ; each ( entries , function ( entry ) { if ( entry . isFile ) { var fullPath = entry . fullPath ; entry . file ( function ( file ) { fileReadSuccess ( file , fullPath ) ; } , readError ) ; } else if ( entry . isDirectory ) { readDirectory ( entry . createReader ( ) ) ; } } ) ; readDirectory ( reader ) ; } else { decrement ( ) ; } } , readError ) ; } function fileReadSuccess ( file , fullPath ) { file . relativePath = fullPath . substring ( 1 ) ; files . push ( file ) ; decrement ( ) ; } function readError ( fileError ) { throw fileError ; } function decrement ( ) { if ( -- queue == 0 ) { $ . addFiles ( files , event ) ; } } }
609	function ( file ) { var custom = this . opts . generateUniqueIdentifier ; if ( typeof custom === 'function' ) { return custom ( file ) ; } var relativePath = file . relativePath || file . webkitRelativePath || file . fileName || file . name ; return file . size + '-' + relativePath . replace ( / [^0-9a-zA-Z_-] / img , '' ) ; }
610	function ( preventEvents ) { var found = false ; if ( this . opts . prioritizeFirstAndLastChunk ) { each ( this . files , function ( file ) { if ( ! file . paused && file . chunks . length && file . chunks [ 0 ] . status ( ) === 'pending' ) { file . chunks [ 0 ] . send ( ) ; found = true ; return false ; } if ( ! file . paused && file . chunks . length > 1 && file . chunks [ file . chunks . length - 1 ] . status ( ) === 'pending' ) { file . chunks [ file . chunks . length - 1 ] . send ( ) ; found = true ; return false ; } } ) ; if ( found ) { return found ; } } each ( this . files , function ( file ) { if ( ! file . paused ) { each ( file . chunks , function ( chunk ) { if ( chunk . status ( ) === 'pending' ) { chunk . send ( ) ; found = true ; return false ; } } ) ; } if ( found ) { return false ; } } ) ; if ( found ) { return true ; } var outstanding = false ; each ( this . files , function ( file ) { if ( ! file . isComplete ( ) ) { outstanding = true ; return false ; } } ) ; if ( ! outstanding && ! preventEvents ) { async ( function ( ) { this . fire ( 'complete' ) ; } , this ) ; } return false ; }
611	function ( domNodes , isDirectory , singleFile , attributes ) { if ( domNodes instanceof Element ) { domNodes = [ domNodes ] ; } each ( domNodes , function ( domNode ) { var input ; if ( domNode . tagName === 'INPUT' && domNode . type === 'file' ) { input = domNode ; } else { input = document . createElement ( 'input' ) ; input . setAttribute ( 'type' , 'file' ) ; extend ( input . style , { visibility : 'hidden' , position : 'absolute' , width : '1px' , height : '1px' } ) ; domNode . appendChild ( input ) ; domNode . addEventListener ( 'click' , function ( ) { input . click ( ) ; } , false ) ; } if ( ! this . opts . singleFile && ! singleFile ) { input . setAttribute ( 'multiple' , 'multiple' ) ; } if ( isDirectory ) { input . setAttribute ( 'webkitdirectory' , 'webkitdirectory' ) ; } each ( attributes , function ( value , key ) { input . setAttribute ( key , value ) ; } ) ; var $ = this ; input . addEventListener ( 'change' , function ( e ) { if ( e . target . value ) { $ . addFiles ( e . target . files , e ) ; e . target . value = '' ; } } , false ) ; } , this ) ; }
612	function ( domNodes ) { if ( typeof domNodes . length === 'undefined' ) { domNodes = [ domNodes ] ; } each ( domNodes , function ( domNode ) { domNode . addEventListener ( 'dragover' , this . preventEvent , false ) ; domNode . addEventListener ( 'dragenter' , this . preventEvent , false ) ; domNode . addEventListener ( 'drop' , this . onDrop , false ) ; } , this ) ; }
613	function ( domNodes ) { if ( typeof domNodes . length === 'undefined' ) { domNodes = [ domNodes ] ; } each ( domNodes , function ( domNode ) { domNode . removeEventListener ( 'dragover' , this . preventEvent ) ; domNode . removeEventListener ( 'dragenter' , this . preventEvent ) ; domNode . removeEventListener ( 'drop' , this . onDrop ) ; } , this ) ; }
614	function ( ) { var uploading = false ; each ( this . files , function ( file ) { if ( file . isUploading ( ) ) { uploading = true ; return false ; } } ) ; return uploading ; }
615	function ( ) { var num = 0 ; var should = true ; var simultaneousUploads = this . opts . simultaneousUploads ; each ( this . files , function ( file ) { each ( file . chunks , function ( chunk ) { if ( chunk . status ( ) === 'uploading' ) { num ++ ; if ( num >= simultaneousUploads ) { should = false ; return false ; } } } ) ; } ) ; return should && num ; }
616	function ( ) { var ret = this . _shouldUploadNext ( ) ; if ( ret === false ) { return ; } this . fire ( 'uploadStart' ) ; var started = false ; for ( var num = 1 ; num <= this . opts . simultaneousUploads - ret ; num ++ ) { started = this . uploadNextChunk ( true ) || started ; } if ( ! started ) { async ( function ( ) { this . fire ( 'complete' ) ; } , this ) ; } }
617	function ( fileList , event ) { var files = [ ] ; each ( fileList , function ( file ) { if ( ( ! ie10plus || ie10plus && file . size > 0 ) && ! ( file . size % 4096 === 0 && ( file . name === '.' || file . fileName === '.' ) ) ) { var uniqueIdentifier = this . generateUniqueIdentifier ( file ) ; if ( this . opts . allowDuplicateUploads || ! this . getFromUniqueIdentifier ( uniqueIdentifier ) ) { var f = new FlowFile ( this , file , uniqueIdentifier ) ; if ( this . fire ( 'fileAdded' , f , event ) ) { files . push ( f ) ; } } } } , this ) ; if ( this . fire ( 'filesAdded' , files , event ) ) { each ( files , function ( file ) { if ( this . opts . singleFile && this . files . length > 0 ) { this . removeFile ( this . files [ 0 ] ) ; } this . files . push ( file ) ; } , this ) ; this . fire ( 'filesSubmitted' , files , event ) ; } }
618	function ( file ) { for ( var i = this . files . length - 1 ; i >= 0 ; i -- ) { if ( this . files [ i ] === file ) { this . files . splice ( i , 1 ) ; file . abort ( ) ; this . fire ( 'fileRemoved' , file ) ; } } }
619	function ( uniqueIdentifier ) { var ret = false ; each ( this . files , function ( file ) { if ( file . uniqueIdentifier === uniqueIdentifier ) { ret = file ; } } ) ; return ret ; }
620	function ( ) { var sizeDelta = 0 ; var averageSpeed = 0 ; each ( this . files , function ( file ) { if ( ! file . paused && ! file . error ) { sizeDelta += file . size - file . sizeUploaded ( ) ; averageSpeed += file . averageSpeed ; } } ) ; if ( sizeDelta && ! averageSpeed ) { return Number . POSITIVE_INFINITY ; } if ( ! sizeDelta && ! averageSpeed ) { return 0 ; } return Math . floor ( sizeDelta / averageSpeed ) ; }
621	function ( ) { var timeSpan = Date . now ( ) - this . _lastProgressCallback ; if ( ! timeSpan ) { return ; } var smoothingFactor = this . flowObj . opts . speedSmoothingFactor ; var uploaded = this . sizeUploaded ( ) ; this . currentSpeed = Math . max ( ( uploaded - this . _prevUploadedSize ) / timeSpan * 1000 , 0 ) ; this . averageSpeed = smoothingFactor * this . currentSpeed + ( 1 - smoothingFactor ) * this . averageSpeed ; this . _prevUploadedSize = uploaded ; }
622	function ( chunk , event , message ) { switch ( event ) { case 'progress' : if ( Date . now ( ) - this . _lastProgressCallback < this . flowObj . opts . progressCallbacksInterval ) { break ; } this . measureSpeed ( ) ; this . flowObj . fire ( 'fileProgress' , this , chunk ) ; this . flowObj . fire ( 'progress' ) ; this . _lastProgressCallback = Date . now ( ) ; break ; case 'error' : this . error = true ; this . abort ( true ) ; this . flowObj . fire ( 'fileError' , this , message , chunk ) ; this . flowObj . fire ( 'error' , message , this , chunk ) ; break ; case 'success' : if ( this . error ) { return ; } this . measureSpeed ( ) ; this . flowObj . fire ( 'fileProgress' , this , chunk ) ; this . flowObj . fire ( 'progress' ) ; this . _lastProgressCallback = Date . now ( ) ; if ( this . isComplete ( ) ) { this . currentSpeed = 0 ; this . averageSpeed = 0 ; this . flowObj . fire ( 'fileSuccess' , this , message , chunk ) ; } break ; case 'retry' : this . flowObj . fire ( 'fileRetry' , this , chunk ) ; break ; } }
623	function ( reset ) { this . currentSpeed = 0 ; this . averageSpeed = 0 ; var chunks = this . chunks ; if ( reset ) { this . chunks = [ ] ; } each ( chunks , function ( c ) { if ( c . status ( ) === 'uploading' ) { c . abort ( ) ; this . flowObj . uploadNextChunk ( ) ; } } , this ) ; }
624	function ( ) { if ( typeof this . flowObj . opts . initFileFn === "function" ) { this . flowObj . opts . initFileFn ( this ) ; } this . abort ( true ) ; this . error = false ; this . _prevProgress = 0 ; var round = this . flowObj . opts . forceChunkSize ? Math . ceil : Math . floor ; var chunks = Math . max ( round ( this . size / this . flowObj . opts . chunkSize ) , 1 ) ; for ( var offset = 0 ; offset < chunks ; offset ++ ) { this . chunks . push ( new FlowChunk ( this . flowObj , this , offset ) ) ; } }
625	function ( ) { if ( this . error ) { return 1 ; } if ( this . chunks . length === 1 ) { this . _prevProgress = Math . max ( this . _prevProgress , this . chunks [ 0 ] . progress ( ) ) ; return this . _prevProgress ; } var bytesLoaded = 0 ; each ( this . chunks , function ( c ) { bytesLoaded += c . progress ( ) * ( c . endByte - c . startByte ) ; } ) ; var percent = bytesLoaded / this . size ; this . _prevProgress = Math . max ( this . _prevProgress , percent > 0.9999 ? 1 : percent ) ; return this . _prevProgress ; }
626	function ( ) { var outstanding = false ; each ( this . chunks , function ( chunk ) { var status = chunk . status ( ) ; if ( status === 'pending' || status === 'uploading' || status === 'reading' || chunk . preprocessState === 1 || chunk . readState === 1 ) { outstanding = true ; return false ; } } ) ; return ! outstanding ; }
627	function ( ) { if ( this . paused || this . error ) { return 0 ; } var delta = this . size - this . sizeUploaded ( ) ; if ( delta && ! this . averageSpeed ) { return Number . POSITIVE_INFINITY ; } if ( ! delta && ! this . averageSpeed ) { return 0 ; } return Math . floor ( delta / this . averageSpeed ) ; }
628	function webAPIFileRead ( fileObj , startByte , endByte , fileType , chunk ) { var function_name = 'slice' ; if ( fileObj . file . slice ) function_name = 'slice' ; else if ( fileObj . file . mozSlice ) function_name = 'mozSlice' ; else if ( fileObj . file . webkitSlice ) function_name = 'webkitSlice' ; chunk . readFinished ( fileObj . file [ function_name ] ( startByte , endByte , fileType ) ) ; }
629	function ( ) { this . xhr = new XMLHttpRequest ( ) ; this . xhr . addEventListener ( "load" , this . testHandler , false ) ; this . xhr . addEventListener ( "error" , this . testHandler , false ) ; var testMethod = evalOpts ( this . flowObj . opts . testMethod , this . fileObj , this ) ; var data = this . prepareXhrRequest ( testMethod , true ) ; this . xhr . send ( data ) ; }
630	function ( ) { var preprocess = this . flowObj . opts . preprocess ; var read = this . flowObj . opts . readFileFn ; if ( typeof preprocess === 'function' ) { switch ( this . preprocessState ) { case 0 : this . preprocessState = 1 ; preprocess ( this ) ; return ; case 1 : return ; } } switch ( this . readState ) { case 0 : this . readState = 1 ; read ( this . fileObj , this . startByte , this . endByte , this . fileObj . file . type , this ) ; return ; case 1 : return ; } if ( this . flowObj . opts . testChunks && ! this . tested ) { this . test ( ) ; return ; } this . loaded = 0 ; this . total = 0 ; this . pendingRetry = false ; this . xhr = new XMLHttpRequest ( ) ; this . xhr . upload . addEventListener ( 'progress' , this . progressHandler , false ) ; this . xhr . addEventListener ( "load" , this . doneHandler , false ) ; this . xhr . addEventListener ( "error" , this . doneHandler , false ) ; var uploadMethod = evalOpts ( this . flowObj . opts . uploadMethod , this . fileObj , this ) ; var data = this . prepareXhrRequest ( uploadMethod , false , this . flowObj . opts . method , this . bytes ) ; this . xhr . send ( data ) ; }
631	function ( isTest ) { if ( this . readState === 1 ) { return 'reading' ; } else if ( this . pendingRetry || this . preprocessState === 1 ) { return 'uploading' ; } else if ( ! this . xhr ) { return 'pending' ; } else if ( this . xhr . readyState < 4 ) { return 'uploading' ; } else { if ( this . flowObj . opts . successStatuses . indexOf ( this . xhr . status ) > - 1 ) { return 'success' ; } else if ( this . flowObj . opts . permanentErrors . indexOf ( this . xhr . status ) > - 1 || ! isTest && this . retries >= this . flowObj . opts . maxChunkRetries ) { return 'error' ; } else { this . abort ( ) ; return 'pending' ; } } }
632	function ( method , isTest , paramsMethod , blob ) { var query = evalOpts ( this . flowObj . opts . query , this . fileObj , this , isTest ) ; query = extend ( query || { } , this . getParams ( ) ) ; var target = evalOpts ( this . flowObj . opts . target , this . fileObj , this , isTest ) ; var data = null ; if ( method === 'GET' || paramsMethod === 'octet' ) { var params = [ ] ; each ( query , function ( v , k ) { params . push ( [ encodeURIComponent ( k ) , encodeURIComponent ( v ) ] . join ( '=' ) ) ; } ) ; target = this . getTarget ( target , params ) ; data = blob || null ; } else { data = new FormData ( ) ; each ( query , function ( v , k ) { data . append ( k , v ) ; } ) ; if ( typeof blob !== "undefined" ) data . append ( this . flowObj . opts . fileParameterName , blob , this . fileObj . file . name ) ; } this . xhr . open ( method , target , true ) ; this . xhr . withCredentials = this . flowObj . opts . withCredentials ; each ( evalOpts ( this . flowObj . opts . headers , this . fileObj , this , isTest ) , function ( v , k ) { this . xhr . setRequestHeader ( k , v ) ; } , this ) ; return data ; }
633	function evalOpts ( data , args ) { if ( typeof data === "function" ) { args = Array . prototype . slice . call ( arguments ) ; data = data . apply ( null , args . slice ( 1 ) ) ; } return data ; }
634	function each ( obj , callback , context ) { if ( ! obj ) { return ; } var key ; if ( typeof ( obj . length ) !== 'undefined' ) { for ( key = 0 ; key < obj . length ; key ++ ) { if ( callback . call ( context , obj [ key ] , key ) === false ) { return ; } } } else { for ( key in obj ) { if ( obj . hasOwnProperty ( key ) && callback . call ( context , obj [ key ] , key ) === false ) { return ; } } } }
635	function createTable ( ) { tableName = arguments [ 0 ] ; var fname = '' ; var callback ; if ( arguments . length === 2 ) { callback = arguments [ 1 ] ; fname = path . join ( userData , tableName + '.json' ) ; } else if ( arguments . length === 3 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; callback = arguments [ 2 ] ; } let exists = fs . existsSync ( fname ) ; if ( exists ) { callback ( false , tableName + '.json already exists!' ) ; return ; } else { let obj = new Object ( ) ; obj [ tableName ] = [ ] ; try { fs . writeFileSync ( fname , JSON . stringify ( obj , null , 2 ) , ( err ) => { } ) callback ( true , "Success!" ) return ; } catch ( e ) { callback ( false , e . toString ( ) ) ; return ; } } }
636	function valid ( ) { var fName = '' if ( arguments . length == 2 ) { const dbName = arguments [ 0 ] const dbLocation = arguments [ 1 ] var fName = path . join ( dbLocation , dbName + '.json' ) } else if ( arguments . length == 1 ) { const dbName = arguments [ 0 ] fname = path . join ( userData , dbName + '.json' ) } const content = fs . readFileSync ( fName , 'utf-8' ) try { JSON . parse ( content ) } catch ( e ) { return false } return true }
637	function insertTableContent ( ) { let tableName = arguments [ 0 ] ; var fname = '' ; var callback ; var tableRow ; if ( arguments . length === 3 ) { callback = arguments [ 2 ] ; fname = path . join ( userData , arguments [ 0 ] + '.json' ) ; tableRow = arguments [ 1 ] ; } else if ( arguments . length === 4 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; callback = arguments [ 3 ] ; tableRow = arguments [ 2 ] ; } let exists = fs . existsSync ( fname ) ; if ( exists ) { let table = JSON . parse ( fs . readFileSync ( fname ) ) ; let date = new Date ( ) ; let id = date . getTime ( ) ; tableRow [ 'id' ] = id ; table [ tableName ] . push ( tableRow ) ; try { fs . writeFileSync ( fname , JSON . stringify ( table , null , 2 ) , ( err ) => { } ) callback ( true , "Object written successfully!" ) ; return ; } catch ( e ) { callback ( false , "Error writing object." ) ; return ; } } callback ( false , "Table/json file doesn't exist!" ) ; return ; }
638	function count ( ) { let tableName = arguments [ 0 ] let callback if ( arguments . length === 2 ) { callback = arguments [ 1 ] getAll ( tableName , ( succ , data ) => { if ( succ ) { callback ( true , data . length ) return } else { callback ( false , data ) return } } ) } else if ( arguments . length === 3 ) { callback = arguments [ 2 ] getAll ( tableName , arguments [ 1 ] , ( succ , data ) => { if ( succ ) { callback ( true , data . length ) return } else { callback ( false , data ) return } } ) } else { callback ( false , 'Wrong number of arguments. Must be either 2 or 3 arguments including callback function.' ) return } }
639	function updateRow ( ) { let tableName = arguments [ 0 ] ; var fname = '' ; var where ; var set ; var callback ; if ( arguments . length === 4 ) { fname = path . join ( userData , tableName + '.json' ) ; where = arguments [ 1 ] ; set = arguments [ 2 ] ; callback = arguments [ 3 ] ; } else if ( arguments . length === 5 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; where = arguments [ 2 ] ; set = arguments [ 3 ] ; callback = arguments [ 4 ] ; } let exists = fs . existsSync ( fname ) ; let whereKeys = Object . keys ( where ) ; let setKeys = Object . keys ( set ) ; if ( exists ) { let table = JSON . parse ( fs . readFileSync ( fname ) ) ; let rows = table [ tableName ] ; let matched = 0 ; let matchedIndex = 0 ; for ( var i = 0 ; i < rows . length ; i ++ ) { for ( var j = 0 ; j < whereKeys . length ; j ++ ) { if ( rows [ i ] . hasOwnProperty ( whereKeys [ j ] ) ) { if ( rows [ i ] [ whereKeys [ j ] ] === where [ whereKeys [ j ] ] ) { matched ++ ; matchedIndex = i ; } } } } if ( matched === whereKeys . length ) { try { for ( var k = 0 ; k < setKeys . length ; k ++ ) { rows [ matchedIndex ] [ setKeys [ k ] ] = set [ setKeys [ k ] ] ; } let obj = new Object ( ) ; obj [ tableName ] = rows ; try { fs . writeFileSync ( fname , JSON . stringify ( obj , null , 2 ) , ( err ) => { } ) callback ( true , "Success!" ) return ; } catch ( e ) { callback ( false , e . toString ( ) ) ; return ; } callback ( true , rows ) ; } catch ( e ) { callback ( false , e . toString ( ) ) ; return ; } } else { callback ( false , "Cannot find the specified record." ) ; return ; } } else { callback ( false , 'Table file does not exist!' ) ; return ; } }
640	function createHeaderGetter ( str ) { var name = str . toLowerCase ( ) return function ( req , res ) { vary ( res , str ) var header = req . headers [ name ] if ( ! header ) { return undefined } var index = header . indexOf ( ',' ) return index !== - 1 ? header . substr ( 0 , index ) . trim ( ) : header . trim ( ) } }
641	function Param ( name , shortName , process ) { if ( process == null ) { process = cloudinary . Util . identity ; } this . name = name ; this . shortName = shortName ; this . process = process ; }
642	function ArrayParam ( name , shortName , sep , process ) { if ( sep == null ) { sep = '.' ; } this . sep = sep ; ArrayParam . __super__ . constructor . call ( this , name , shortName , process ) ; }
643	function TransformationParam ( name , shortName , sep , process ) { if ( shortName == null ) { shortName = "t" ; } if ( sep == null ) { sep = '.' ; } this . sep = sep ; TransformationParam . __super__ . constructor . call ( this , name , shortName , process ) ; }
644	function RangeParam ( name , shortName , process ) { if ( process == null ) { process = this . norm_range_value ; } RangeParam . __super__ . constructor . call ( this , name , shortName , process ) ; }
645	function Configuration ( options ) { if ( options == null ) { options = { } ; } this . configuration = Util . cloneDeep ( options ) ; Util . defaults ( this . configuration , DEFAULT_CONFIGURATION_PARAMS ) ; }
646	function Cloudinary ( options ) { var configuration ; this . devicePixelRatioCache = { } ; this . responsiveConfig = { } ; this . responsiveResizeInitialized = false ; configuration = new Configuration ( options ) ; this . config = function ( newConfig , newValue ) { return configuration . config ( newConfig , newValue ) ; } ; this . fromDocument = function ( ) { configuration . fromDocument ( ) ; return this ; } ; this . fromEnvironment = function ( ) { configuration . fromEnvironment ( ) ; return this ; } ; this . init = function ( ) { configuration . init ( ) ; return this ; } ; }
647	function getMode ( env , argv ) { argv = Object . keys ( argv ) . length ? argv : require ( 'minimist' ) ( process . argv . slice ( 2 ) ) ; var isProd = ( argv . mode || env . mode ) === 'production' || env === 'prod' || env . prod ; return isProd ? 'production' : 'development' ; }
648	function resolveLodash ( context , request , callback ) { if ( / ^lodash\/ / . test ( request ) ) { callback ( null , { commonjs : request , commonjs2 : request , amd : request , root : [ '_' , request . split ( '/' ) [ 1 ] ] } ) ; } else { callback ( ) ; } }
649	function baseConfig ( name , mode ) { const config = { name : ` ${ name } ${ mode } ` , mode , output : { library : 'cloudinary' , libraryTarget : 'umd' , globalObject : "this" , pathinfo : false } , optimization : { concatenateModules : true , moduleIds : 'named' , usedExports : true , minimizer : [ new TerserPlugin ( { terserOptions : { mangle : { keep_classnames : true , reserved : reserved , ie8 : true } } , } ) ] } , resolve : { extensions : [ '.js' ] } , externals : [ { jquery : 'jQuery' } ] , node : { Buffer : false , process : false } , devtool : "source-map" , module : { rules : [ { test : / \.m?js$ / , exclude : / (node_modules|bower_components) / , use : { loader : 'babel-loader' } } ] } , plugins : [ new webpack . BannerPlugin ( { banner : ` ${ version } ` , raw : true , entryOnly : true , } ) ] } ; let filename = ` ${ name } ` ; if ( mode === 'production' ) { filename += '.min' ; } const util = name . startsWith ( 'jquery' ) ? 'jquery' : 'lodash' ; const utilPath = path . resolve ( __dirname , ` ${ util } ` ) ; config . output . filename = ` ${ filename } ` ; config . entry = ` ${ name } ` ; config . resolve . alias = { "../util$" : utilPath , "./util$" : utilPath } ; if ( name === 'core' ) { config . externals . push ( resolveLodash ) ; } config . plugins . push ( new BundleAnalyzerPlugin ( { analyzerMode : 'static' , reportFilename : ` ${ filename } ` , openAnalyzer : false } ) ) ; return config ; }
650	function finalizeResourceType ( resourceType = "image" , type = "upload" , urlSuffix , useRootPath , shorten ) { var options ; resourceType = resourceType == null ? "image" : resourceType ; type = type == null ? "upload" : type ; if ( isPlainObject ( resourceType ) ) { options = resourceType ; resourceType = options . resource_type ; type = options . type ; urlSuffix = options . url_suffix ; useRootPath = options . use_root_path ; shorten = options . shorten ; } if ( type == null ) { type = 'upload' ; } if ( urlSuffix != null ) { resourceType = SEO_TYPES [ ` ${ resourceType } ${ type } ` ] ; type = null ; if ( resourceType == null ) { throw new Error ( ` ${ Object . keys ( SEO_TYPES ) . join ( ', ' ) } ` ) ; } } if ( useRootPath ) { if ( resourceType === 'image' && type === 'upload' || resourceType === "images" ) { resourceType = null ; type = null ; } else { throw new Error ( "Root path only supported for image/upload" ) ; } } if ( shorten && resourceType === 'image' && type === 'upload' ) { resourceType = 'iu' ; type = null ; } return [ resourceType , type ] . join ( "/" ) ; }
651	function Drag ( parent , options ) { _classCallCheck ( this , Drag ) ; options = options || { } ; var _this = _possibleConstructorReturn ( this , ( Drag . __proto__ || Object . getPrototypeOf ( Drag ) ) . call ( this , parent ) ) ; _this . moved = false ; _this . wheelActive = utils . defaults ( options . wheel , true ) ; _this . wheelScroll = options . wheelScroll || 1 ; _this . reverse = options . reverse ? 1 : - 1 ; _this . clampWheel = options . clampWheel ; _this . factor = options . factor || 1 ; _this . xDirection = ! options . direction || options . direction === 'all' || options . direction === 'x' ; _this . yDirection = ! options . direction || options . direction === 'all' || options . direction === 'y' ; _this . parseUnderflow ( options . underflow || 'center' ) ; _this . mouseButtons ( options . mouseButtons ) ; return _this ; }
652	function each ( object , fn ) { keys ( object ) . forEach ( function ( key ) { return fn ( object [ key ] , key ) ; } ) ; }
653	function reduce ( object , fn ) { var initial = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : 0 ; return keys ( object ) . reduce ( function ( accum , key ) { return fn ( accum , object [ key ] , key ) ; } , initial ) ; }
654	function isPlain ( value ) { return isObject ( value ) && toString . call ( value ) === '[object Object]' && value . constructor === Object ; }
655	function logByType ( type , args ) { var stringify = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : ! ! IE_VERSION && IE_VERSION < 11 ; var lvl = log . levels [ level ] ; var lvlRegExp = new RegExp ( '^(' + lvl + ')$' ) ; if ( type !== 'log' ) { args . unshift ( type . toUpperCase ( ) + ':' ) ; } if ( history ) { history . push ( [ ] . concat ( args ) ) ; } args . unshift ( 'VIDEOJS:' ) ; var fn = window . console && window . console [ type ] ; if ( ! fn || ! lvl || ! lvlRegExp . test ( type ) ) { return ; } if ( stringify ) { args = args . map ( function ( a ) { if ( isObject ( a ) || Array . isArray ( a ) ) { try { return JSON . stringify ( a ) ; } catch ( x ) { return String ( a ) ; } } return String ( a ) ; } ) . join ( ' ' ) ; } if ( ! fn . apply ) { fn ( args ) ; } else { fn [ Array . isArray ( args ) ? 'apply' : 'call' ] ( window . console , args ) ; } }
656	function createEl ( ) { var tagName = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : 'div' ; var properties = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; var attributes = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : { } ; var content = arguments [ 3 ] ; var el = document . createElement ( tagName ) ; Object . getOwnPropertyNames ( properties ) . forEach ( function ( propName ) { var val = properties [ propName ] ; if ( propName . indexOf ( 'aria-' ) !== - 1 || propName === 'role' || propName === 'type' ) { log$1 . warn ( tsml ( _templateObject , propName , val ) ) ; el . setAttribute ( propName , val ) ; } else if ( propName === 'textContent' ) { textContent ( el , val ) ; } else { el [ propName ] = val ; } } ) ; Object . getOwnPropertyNames ( attributes ) . forEach ( function ( attrName ) { el . setAttribute ( attrName , attributes [ attrName ] ) ; } ) ; if ( content ) { appendContent ( el , content ) ; } return el ; }
657	function addClass ( element , classToAdd ) { if ( element . classList ) { element . classList . add ( classToAdd ) ; } else if ( ! hasClass ( element , classToAdd ) ) { element . className = ( element . className + ' ' + classToAdd ) . trim ( ) ; } return element ; }
658	function toggleClass ( element , classToToggle , predicate ) { var has = hasClass ( element , classToToggle ) ; if ( typeof predicate === 'function' ) { predicate = predicate ( element , classToToggle ) ; } if ( typeof predicate !== 'boolean' ) { predicate = ! has ; } if ( predicate === has ) { return ; } if ( predicate ) { addClass ( element , classToToggle ) ; } else { removeClass ( element , classToToggle ) ; } return element ; }
659	function getPointerPosition ( el , event ) { var position = { } ; var box = findPosition ( el ) ; var boxW = el . offsetWidth ; var boxH = el . offsetHeight ; var boxY = box . top ; var boxX = box . left ; var pageY = event . pageY ; var pageX = event . pageX ; if ( event . changedTouches ) { pageX = event . changedTouches [ 0 ] . pageX ; pageY = event . changedTouches [ 0 ] . pageY ; } position . y = Math . max ( 0 , Math . min ( 1 , ( boxY - pageY + boxH ) / boxH ) ) ; position . x = Math . max ( 0 , Math . min ( 1 , ( pageX - boxX ) / boxW ) ) ; return position ; }
660	function appendContent ( el , content ) { normalizeContent ( content ) . forEach ( function ( node ) { return el . appendChild ( node ) ; } ) ; return el ; }
661	function getData ( el ) { var id = el [ elIdAttr ] ; if ( ! id ) { id = el [ elIdAttr ] = newGUID ( ) ; } if ( ! elData [ id ] ) { elData [ id ] = { } ; } return elData [ id ] ; }
662	function hasData ( el ) { var id = el [ elIdAttr ] ; if ( ! id ) { return false ; } return ! ! Object . getOwnPropertyNames ( elData [ id ] ) . length ; }
663	function removeData ( el ) { var id = el [ elIdAttr ] ; if ( ! id ) { return ; } delete elData [ id ] ; try { delete el [ elIdAttr ] ; } catch ( e ) { if ( el . removeAttribute ) { el . removeAttribute ( elIdAttr ) ; } else { el [ elIdAttr ] = null ; } } }
664	function _handleMultipleEvents ( fn , elem , types , callback ) { types . forEach ( function ( type ) { fn ( elem , type , callback ) ; } ) ; }
665	function off ( elem , type , fn ) { if ( ! hasData ( elem ) ) { return ; } var data = getData ( elem ) ; if ( ! data . handlers ) { return ; } if ( Array . isArray ( type ) ) { return _handleMultipleEvents ( off , elem , type , fn ) ; } var removeType = function removeType ( t ) { data . handlers [ t ] = [ ] ; _cleanUpEvents ( elem , t ) ; } ; if ( ! type ) { for ( var t in data . handlers ) { removeType ( t ) ; } return ; } var handlers = data . handlers [ type ] ; if ( ! handlers ) { return ; } if ( ! fn ) { removeType ( type ) ; return ; } if ( fn . guid ) { for ( var n = 0 ; n < handlers . length ; n ++ ) { if ( handlers [ n ] . guid === fn . guid ) { handlers . splice ( n -- , 1 ) ; } } } _cleanUpEvents ( elem , type ) ; }
666	function one ( elem , type , fn ) { if ( Array . isArray ( type ) ) { return _handleMultipleEvents ( one , elem , type , fn ) ; } var func = function func ( ) { off ( elem , type , func ) ; fn . apply ( this , arguments ) ; } ; func . guid = fn . guid = fn . guid || newGUID ( ) ; on ( elem , type , func ) ; }
667	function autoSetup ( ) { if ( ! isReal ( ) ) { return ; } var vids = document . getElementsByTagName ( 'video' ) ; var audios = document . getElementsByTagName ( 'audio' ) ; var mediaEls = [ ] ; if ( vids && vids . length > 0 ) { for ( var i = 0 , e = vids . length ; i < e ; i ++ ) { mediaEls . push ( vids [ i ] ) ; } } if ( audios && audios . length > 0 ) { for ( var _i = 0 , _e = audios . length ; _i < _e ; _i ++ ) { mediaEls . push ( audios [ _i ] ) ; } } if ( mediaEls && mediaEls . length > 0 ) { for ( var _i2 = 0 , _e2 = mediaEls . length ; _i2 < _e2 ; _i2 ++ ) { var mediaEl = mediaEls [ _i2 ] ; if ( mediaEl && mediaEl . getAttribute ) { if ( mediaEl . player === undefined ) { var options = mediaEl . getAttribute ( 'data-setup' ) ; if ( options !== null ) { videojs$2 ( mediaEl ) ; } } } else { autoSetupTimeout ( 1 ) ; break ; } } } else if ( ! _windowLoaded ) { autoSetupTimeout ( 1 ) ; } }
668	function autoSetupTimeout ( wait , vjs ) { if ( vjs ) { videojs$2 = vjs ; } window . setTimeout ( autoSetup , wait ) ; }
669	function setTextContent ( el , content ) { if ( el . styleSheet ) { el . styleSheet . cssText = content ; } else { el . textContent = content ; } }
670	function throttle ( fn , wait ) { var last = Date . now ( ) ; var throttled = function throttled ( ) { var now = Date . now ( ) ; if ( now - last >= wait ) { fn . apply ( undefined , arguments ) ; last = now ; } } ; return throttled ; }
671	function isValidEventType ( type ) { return ( typeof type === 'string' && / \S / . test ( type ) || Array . isArray ( type ) && ! ! type . length ) ; }
672	function Component ( player , options , ready ) { classCallCheck ( this , Component ) ; if ( ! player && this . play ) { this . player_ = player = this ; } else { this . player_ = player ; } this . options_ = mergeOptions ( { } , this . options_ ) ; options = this . options_ = mergeOptions ( this . options_ , options ) ; this . id_ = options . id || options . el && options . el . id ; if ( ! this . id_ ) { var id = player && player . id && player . id ( ) || 'no_player' ; this . id_ = id + '_component_' + newGUID ( ) ; } this . name_ = options . name || null ; if ( options . el ) { this . el_ = options . el ; } else if ( options . createEl !== false ) { this . el_ = this . createEl ( ) ; } evented ( this , { eventBusKey : this . el_ ? 'el_' : null } ) ; stateful ( this , this . constructor . defaultState ) ; this . children_ = [ ] ; this . childIndex_ = { } ; this . childNameIndex_ = { } ; if ( options . initChildren !== false ) { this . initChildren ( ) ; } this . ready ( ready ) ; if ( options . reportTouchActivity !== false ) { this . enableTouchActivity ( ) ; } }
673	function rangeCheck ( fnName , index , maxIndex ) { if ( typeof index !== 'number' || index < 0 || index > maxIndex ) { throw new Error ( 'Failed to execute \'' + \' + fnName + '\' on \'TimeRanges\': The index provided (' + \' + \' + \' ) ; } }
674	function getRange ( fnName , valueIndex , ranges , rangeIndex ) { rangeCheck ( fnName , rangeIndex , ranges . length - 1 ) ; return ranges [ rangeIndex ] [ valueIndex ] ; }
675	function createTimeRangesObj ( ranges ) { if ( ranges === undefined || ranges . length === 0 ) { return { length : 0 , start : function start ( ) { throw new Error ( 'This TimeRanges object is empty' ) ; } , end : function end ( ) { throw new Error ( 'This TimeRanges object is empty' ) ; } } ; } return { length : ranges . length , start : getRange . bind ( null , 'start' , 0 , ranges ) , end : getRange . bind ( null , 'end' , 1 , ranges ) } ; }
676	function createTimeRanges ( start , end ) { if ( Array . isArray ( start ) ) { return createTimeRangesObj ( start ) ; } else if ( start === undefined || end === undefined ) { return createTimeRangesObj ( ) ; } return createTimeRangesObj ( [ [ start , end ] ] ) ; }
677	function TextTrackCueList ( cues ) { classCallCheck ( this , TextTrackCueList ) ; var list = this ; if ( IS_IE8 ) { list = document . createElement ( 'custom' ) ; for ( var prop in TextTrackCueList . prototype ) { if ( prop !== 'constructor' ) { list [ prop ] = TextTrackCueList . prototype [ prop ] ; } } } TextTrackCueList . prototype . setCues_ . call ( list , cues ) ; Object . defineProperty ( list , 'length' , { get : function get$$1 ( ) { return this . length_ ; } } ) ; if ( IS_IE8 ) { return list ; } }
678	function getFileExtension ( path ) { if ( typeof path === 'string' ) { var splitPathRe = / ^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$ / i ; var pathParts = splitPathRe . exec ( path ) ; if ( pathParts ) { return pathParts . pop ( ) . toLowerCase ( ) ; } } return '' ; }
679	function loadTrack ( src , track ) { var opts = { uri : src } ; var crossOrigin = isCrossOrigin ( src ) ; if ( crossOrigin ) { opts . cors = crossOrigin ; } xhr ( opts , bind ( this , function ( err , response , responseBody ) { if ( err ) { return log$1 . error ( err , response ) ; } track . loaded_ = true ; if ( typeof window . WebVTT !== 'function' ) { if ( track . tech_ ) { var loadHandler = function loadHandler ( ) { return parseCues ( responseBody , track ) ; } ; track . tech_ . on ( 'vttjsloaded' , loadHandler ) ; track . tech_ . on ( 'vttjserror' , function ( ) { log$1 . error ( 'vttjs failed to load, stopping trying to process ' + track . src ) ; track . tech_ . off ( 'vttjsloaded' , loadHandler ) ; } ) ; } } else { parseCues ( responseBody , track ) ; } } ) ) ; }
680	function constructColor ( color , opacity ) { return 'rgba(' + parseInt ( color [ 1 ] + color [ 1 ] , 16 ) + ',' + parseInt ( color [ 2 ] + color [ 2 ] , 16 ) + ',' + parseInt ( color [ 3 ] + color [ 3 ] , 16 ) + ',' + opacity + ')' ; }
681	function checkVolumeSupport ( self , player ) { if ( player . tech_ && ! player . tech_ . featuresVolumeControl ) { self . addClass ( 'vjs-hidden' ) ; } self . on ( player , 'loadstart' , function ( ) { if ( ! player . tech_ . featuresVolumeControl ) { self . addClass ( 'vjs-hidden' ) ; } else { self . removeClass ( 'vjs-hidden' ) ; } } ) ; }
682	function parseOptionValue ( value , parser ) { if ( parser ) { value = parser ( value ) ; } if ( value && value !== 'none' ) { return value ; } }
683	function checkProgress ( ) { if ( _this3 . el_ . currentTime > 0 ) { if ( _this3 . el_ . duration === Infinity ) { _this3 . trigger ( 'durationchange' ) ; } _this3 . off ( 'timeupdate' , checkProgress ) ; } }
684	function findFirstPassingTechSourcePair ( outerArray , innerArray , tester ) { var found = void 0 ; outerArray . some ( function ( outerChoice ) { return innerArray . some ( function ( innerChoice ) { found = tester ( outerChoice , innerChoice ) ; if ( found ) { return true ; } } ) ; } ) ; return found ; }
685	function markPluginAsActive ( player , name ) { player [ PLUGIN_CACHE_KEY ] = player [ PLUGIN_CACHE_KEY ] || { } ; player [ PLUGIN_CACHE_KEY ] [ name ] = true ; }
686	function triggerSetupEvent ( player , hash , before ) { var eventName = ( before ? 'before' : '' ) + 'pluginsetup' ; player . trigger ( eventName , hash ) ; player . trigger ( eventName + ':' + hash . name , hash ) ; }
687	function createBasicPlugin ( name , plugin ) { var basicPluginWrapper = function basicPluginWrapper ( ) { triggerSetupEvent ( this , { name : name , plugin : plugin , instance : null } , true ) ; var instance = plugin . apply ( this , arguments ) ; markPluginAsActive ( this , name ) ; triggerSetupEvent ( this , { name : name , plugin : plugin , instance : instance } ) ; return instance ; } ; Object . keys ( plugin ) . forEach ( function ( prop ) { basicPluginWrapper [ prop ] = plugin [ prop ] ; } ) ; return basicPluginWrapper ; }
688	function createPluginFactory ( name , PluginSubClass ) { PluginSubClass . prototype . name = name ; return function ( ) { triggerSetupEvent ( this , { name : name , plugin : PluginSubClass , instance : null } , true ) ; for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } var instance = new ( Function . prototype . bind . apply ( PluginSubClass , [ null ] . concat ( [ this ] . concat ( args ) ) ) ) ( ) ; this [ name ] = function ( ) { return instance ; } ; triggerSetupEvent ( this , instance . getEventHash ( ) ) ; return instance ; } ; }
689	function videojs ( id , options , ready ) { var tag = void 0 ; if ( typeof id === 'string' ) { var players = videojs . getPlayers ( ) ; if ( id . indexOf ( '#' ) === 0 ) { id = id . slice ( 1 ) ; } if ( players [ id ] ) { if ( options ) { log$1 . warn ( 'Player "' + id + '" is already initialised. Options will not be applied.' ) ; } if ( ready ) { players [ id ] . ready ( ready ) ; } return players [ id ] ; } tag = $ ( '#' + id ) ; } else { tag = id ; } if ( ! tag || ! tag . nodeName ) { throw new TypeError ( 'The element or ID supplied is not valid. (videojs)' ) ; } if ( tag . player || Player . players [ tag . playerId ] ) { return tag . player || Player . players [ tag . playerId ] ; } options = options || { } ; videojs . hooks ( 'beforesetup' ) . forEach ( function ( hookFunction ) { var opts = hookFunction ( tag , mergeOptions ( options ) ) ; if ( ! isObject ( opts ) || Array . isArray ( opts ) ) { log$1 . error ( 'please return an object in beforesetup hooks' ) ; return ; } options = mergeOptions ( options , opts ) ; } ) ; var PlayerComponent = Component . getComponent ( 'Player' ) ; var player = new PlayerComponent ( tag , options , ready ) ; videojs . hooks ( 'setup' ) . forEach ( function ( hookFunction ) { return hookFunction ( player ) ; } ) ; return player ; }
690	function byteCount ( testName , len , baseLen ) { console . log ( testName + " Byte Count: " + len + ( baseLen ? ', ' + Math . round ( len / baseLen * 100 ) + '%' : '' ) ) ; }
691	function ( ) { var colors = [ ] var trs = _$sortableDataList . find ( "li" ) ; for ( var i = 0 ; i < trs . length ; i ++ ) { colors . push ( utils . rgb2hex ( $ ( trs [ i ] ) . find ( ".segmentColor" ) . css ( "background-color" ) ) ) ; } colors = utils . shuffleArray ( colors ) ; _setColors ( colors ) ; }
692	function ( moduleID , message , data ) { if ( C . DEBUG ) { console . log ( "[" + moduleID + "] publish(): " , message , data ) ; } for ( var i in _modules ) { var subscriptions = _modules [ i ] . subscriptions ; if ( subscriptions . hasOwnProperty ( message ) ) { subscriptions [ message ] ( { sender : moduleID , data : data } ) ; } } }
693	function ( ) { $ ( document ) . on ( "click" , ".selectPage" , function ( e ) { e . preventDefault ( ) ; _selectPage ( this . hash ) ; } ) ; $ ( window ) . on ( "resize" , function ( ) { var width = $ ( window ) . width ( ) ; var height = $ ( window ) . height ( ) ; var breakPoint = _updateBodySizeClass ( width ) ; mediator . publish ( _MODULE_ID , C . EVENT . PAGE . RESIZE , { width : width , height : height , breakPoint : breakPoint } ) ; } ) ; }
694	function ( width ) { var breakPointIndex = null ; for ( var i = 0 ; i < C . OTHER . BREAKPOINTS . length ; i ++ ) { if ( width >= C . OTHER . BREAKPOINTS [ i ] ) { breakPointIndex = i ; } } $ ( "body" ) . removeClass ( "size768 size992 size1200" ) ; var breakPoint = null ; if ( breakPointIndex !== null ) { breakPoint = C . OTHER . BREAKPOINTS [ breakPointIndex ] ; $ ( "body" ) . addClass ( "size" + breakPoint ) ; } return breakPoint ; }
695	function ( ) { var hb = new base . HandlebarsEnvironment ( ) ; Utils . extend ( hb , base ) ; hb . SafeString = SafeString ; hb . Exception = Exception ; hb . Utils = Utils ; hb . VM = runtime ; hb . template = function ( spec ) { return runtime . template ( spec , hb ) ; } ; return hb ; }
696	function ( paramSize , params , useRegister ) { var options = '{' + this . setupOptions ( paramSize , params ) . join ( ',' ) + '}' ; if ( useRegister ) { this . useRegister ( 'options' ) ; params . push ( 'options' ) ; return 'options=' + options ; } else { params . push ( options ) ; return '' ; } }
697	function ( msg ) { _canvasWidth = msg . data . config . size . canvasWidth ; _canvasHeight = msg . data . config . size . canvasHeight ; }
698	function ( number ) { switch ( number ) { case 1 : _demoPie2 . redraw ( ) ; _demoPie3 . redraw ( ) ; break ; case 2 : _demoPie1 . redraw ( ) ; _demoPie3 . redraw ( ) ; break ; case 3 : _demoPie1 . redraw ( ) ; _demoPie2 . redraw ( ) ; break ; } }
699	function ( ) { config . template . indexFile . options . data . C = _CONSTANTS . DEV ; config . template . indexFile . options . data . D3PIE_VERSION = packageFile . version ; config . template . devRequireConfig . options . data . handlebarsLib = _CONSTANTS . DEV . HANDLEBARS_LIB ; config . template . devRequireConfig . options . data . baseUrl = _CONSTANTS . DEV . BASE_URL ; var lines = [ ] ; for ( var i in _requireJSModulePaths ) { var file = _requireJSModulePaths [ i ] . replace ( / \.js$ / , "" ) ; lines . push ( '\t\t"' + \t + \t + i + '": "' ) ; } file '"' config . template . devRequireConfig . options . data . moduleStr = lines . join ( ",\n" ) ; \n }
700	function ( ) { return { header : titleTab . getTabData ( ) , footer : footerTab . getTabData ( ) , size : sizeTab . getTabData ( ) , data : dataTab . getTabData ( ) , labels : labelsTab . getTabData ( ) , tooltips : tooltipsTab . getTabData ( ) , effects : effectsTab . getTabData ( ) , callbacks : eventsTab . getTabData ( ) , misc : miscTab . getTabData ( ) } ; }
701	function getOrDef ( obj , prop ) { return obj [ prop ] === undefined ? options [ prop ] : obj [ prop ] ; }
702	function calcViewport ( ) { var scrollTop = $window . scrollTop ( ) , scrollLeft = window . pageXOffset || 0 , edgeX = options . edgeX , edgeY = options . edgeY ; viewportTop = scrollTop - edgeY ; viewportBottom = scrollTop + ( window . innerHeight || $window . height ( ) ) + edgeY ; viewportLeft = scrollLeft - edgeX ; viewportRight = scrollLeft + ( window . innerWidth || $window . width ( ) ) + edgeX ; }
703	function checkVersion ( ) { var nextVersionCheckTimestamp = parseInt ( Cookies . get ( 'nextVersionCheckTimestamp' ) ) || 0 ; if ( ! nextVersionCheckTimestamp || ( Date . now ( ) >= nextVersionCheckTimestamp ) ) { $http . get ( '/api/build-info' ) . then ( function success ( res ) { var currentVersion = parseVersion ( res . data && res . data . version ) ; $http . get ( 'https://api.github.com/repos/mcdcorp/opentest/releases' ) . then ( function success ( res ) { var eightDaysLater = Date . now ( ) + ( 8 * 24 * 60 * 60 * 1000 ) ; Cookies . set ( 'nextVersionCheckTimestamp' , eightDaysLater ) ; var latestVersionStr = res . data && res . data [ 0 ] && res . data [ 0 ] . tag_name ; var latestVersionUrl = res . data && res . data [ 0 ] && res . data [ 0 ] . html_url ; var latestVersion = parseVersion ( latestVersionStr ) ; if ( latestVersion && ( compareVersions ( latestVersion , currentVersion ) === 1 ) ) { $ . notify ( { message : 'A new OpenTest version is now available: <a href="' + latestVersionUrl + '" target="_blank">' + latestVersionStr + '</a>. ' + 'You should always stay on the latest version to benefit from new features and security updates.' } , { type : 'info' , delay : 0 , placement : { from : 'bottom' } } ) } } , function error ( res ) { var oneHourLater = Date . now ( ) + ( 60 * 60 * 1000 ) ; Cookies . set ( 'nextVersionCheckTimestamp' , oneHourLater ) ; } ) ; } ) ; } }
704	function parseVersion ( versionString ) { if ( typeof versionString !== 'string' ) { return null ; } var versionRegexMatch = versionString . match ( / v?(\d+)\.(\d+)\.(\d+) / i ) ; if ( versionRegexMatch ) { return [ parseInt ( versionRegexMatch [ 1 ] ) , parseInt ( versionRegexMatch [ 2 ] ) , parseInt ( versionRegexMatch [ 3 ] ) ] ; } else { return null ; } }
705	function cellAccessor ( row1 , col1 , row2 , col2 , isMerged ) { let theseCells = new cellBlock ( ) ; theseCells . ws = this ; row2 = row2 ? row2 : row1 ; col2 = col2 ? col2 : col1 ; if ( row2 > this . lastUsedRow ) { this . lastUsedRow = row2 ; } if ( col2 > this . lastUsedCol ) { this . lastUsedCol = col2 ; } for ( let r = row1 ; r <= row2 ; r ++ ) { for ( let c = col1 ; c <= col2 ; c ++ ) { let ref = ` ${ utils . getExcelAlpha ( c ) } ${ r } ` ; if ( ! this . cells [ ref ] ) { this . cells [ ref ] = new Cell ( r , c ) ; } if ( ! this . rows [ r ] ) { this . rows [ r ] = new Row ( r , this ) ; } if ( this . rows [ r ] . cellRefs . indexOf ( ref ) < 0 ) { this . rows [ r ] . cellRefs . push ( ref ) ; } theseCells . cells . push ( this . cells [ ref ] ) ; theseCells . excelRefs . push ( ref ) ; } } if ( isMerged ) { theseCells . merged = true ; mergeCells ( theseCells ) ; } return theseCells ; }
706	function allProjects ( done ) { User . find ( { } , function ( err , users ) { if ( err ) return done ( err ) ; Project . find ( ) . sort ( { _id : - 1 } ) . exec ( function ( err , projects ) { if ( err ) return done ( err ) ; done ( null , projects . map ( function ( project ) { project = utils . sanitizeProject ( project ) ; project . created_date = utils . timeFromId ( project . _id ) ; project . users = [ ] ; for ( var i = 0 ; i < users . length ; i ++ ) { if ( 'undefined' !== typeof users [ i ] . projects [ project . name ] ) { project . users . push ( { email : users [ i ] . email , access : users [ i ] . projects [ project . name ] } ) ; } } return project ; } ) ) ; } ) ; } ) ; }
707	function getConfig ( ) { process . env = filterEnv ( deprecated ( process . env ) , envDefaults ) ; var rc = require ( 'rc' ) ( 'strider' , defaults ) ; if ( ! rc . smtp ) rc . smtp = smtp ( rc ) ; if ( ! rc . smtp ) rc . stubSmtp = true ; rc . ldap = getConfigByName ( 'ldap' ) ; addPlugins ( rc , process . env ) ; if ( hasGithub ) { rc . plugins . github = rc . plugins . github || { } ; rc . plugins . github . hostname = rc . server_name ; } debug ( rc ) ; return rc ; }
708	function filterEnv ( env , defaults ) { var res = { } ; for ( var k in env ) { if ( defaults [ k . toLowerCase ( ) ] !== undefined ) { res [ ` ${ k . toLowerCase ( ) } ` ] = env [ k ] ; } else { res [ k ] = env [ k ] ; } } return res ; }
709	function mergePlugins ( branch , sjson ) { if ( ! branch ) return sjson ; if ( ! sjson ) return branch ; var plugins = [ ] ; var pluginMap = { } ; for ( var pluginIndex = 0 ; pluginIndex < sjson . length ; pluginIndex ++ ) { plugins . push ( sjson [ pluginIndex ] ) ; pluginMap [ sjson [ pluginIndex ] . id ] = true ; } for ( var branchIndex = 0 ; branchIndex < branch . length ; branchIndex ++ ) { if ( ! pluginMap [ branch [ branchIndex ] . id ] ) plugins . push ( branch [ branchIndex ] ) ; } return plugins ; }
710	function registerTemplate ( name , template , dir ) { cache [ name ] = function ( context , cb ) { if ( / \.html$ / . test ( template ) ) { dir = dir || '.' ; template = fs . readFileSync ( path . join ( dir , template ) , 'utf8' ) ; } cb ( null , template ) ; } ; }
711	function getPluginTemplate ( name , context ) { return function ( cb ) { if ( cache [ name ] ) { cache [ name ] ( context , function ( err , res ) { if ( err ) return cb ( err ) ; cb ( null , [ name , res ] ) ; } ) ; } else { cb ( null , null ) ; } } ; }
712	function engine ( path , options , fn ) { options . filename = path ; fs . readFile ( path , 'utf8' , function ( err , str ) { if ( err ) return fn ( err ) ; engine . render ( str , options , fn ) ; } ) ; }
713	function ( uid , socket ) { var socks = this . sockets [ uid ] ; if ( ! socks ) return false ; return socks . remove ( socket ) ; }
714	function ( socket ) { var session = socket . handshake . session ; if ( session && session . passport ) { this . addSocket ( session . passport . user , socket ) ; } else { console . debug ( 'Websocket connection does not have authorization - nothing to do.' ) ; } }
715	function status ( job ) { if ( job . errored ) return 'errored' ; if ( ! job . started ) return 'submitted' ; if ( ! job . finished ) return 'running' ; if ( job . test_exitcode !== 0 ) return 'failed' ; if ( job . type !== TEST_ONLY && job . deploy_exitcode !== 0 ) return 'failed' ; return 'passed' ; }
716	function prepareJob ( emitter , job ) { Project . findOne ( { name : job . project } ) . populate ( 'creator' ) . exec ( function ( err , project ) { if ( err || ! project ) return debug ( 'job.prepare - failed to get project' , job . project , err ) ; var provider = common . extensions . provider [ project . provider . id ] ; if ( ! provider ) { return debug ( 'job.prepare - provider not found for project' , job . project , project . provider . id ) ; } Job . create ( job , function ( err , mjob ) { if ( err ) return debug ( 'job.prepare - failed to save job' , job , err ) ; var jjob = mjob . toJSON ( ) ; jjob . project = project ; jjob . providerConfig = project . provider . config ; jjob . fromStriderJson = true ; striderJson ( provider , project , job . ref , function ( err , config ) { if ( err ) { if ( err . status === 403 || err . statusCode === 403 ) { debug ( 'job.prepare - access to strider.json is forbidden, skipping config merge' ) ; config = { } ; jjob . fromStriderJson = false ; } else if ( err . status === 404 || err . statusCode === 404 ) { debug ( 'job.prepare - strider.json not found, skipping config merge' ) ; config = { } ; jjob . fromStriderJson = false ; } else { debug ( 'job.prepare - error opening/processing project\'s `strider.json` file: ' , \' ) ; err config = { } ; } } else jjob . fromStriderJson = false ; { debug ( 'Using configuration from "strider.json".' ) ; } var branch = project . branch ( job . ref . branch || 'master' ) ; if ( ! branch ) { return debug ( 'job.prepare - branch not found' , job . ref . branch || 'master' , project . name ) ; } branch = branch . mirror_master ? project . branch ( 'master' ) : branch ; jjob . providerConfig = _ . extend ( { } , project . provider . config , config . provider || { } ) ; config . runner = config . runner || branch . runner ; if ( ! common . extensions . runner [ config . runner . id ] ) { debug ( ` ${ config . runner . id } ` ) ; } if ( config ) { delete config . provider ; config = utils . mergeConfigs ( branch , config ) ; } emitter . emit ( 'job.new' , jjob , config ) ; if ( ! mjob . runner ) mjob . runner = { } ; mjob . runner . id = config . runner . id ; } ) ; } ) ; } ) ; }
717	function killAttrs ( model , attrs ) { for ( var i = 0 ; i < attrs . length ; i ++ ) { delete model [ attrs [ i ] ] ; } }
718	function bodySetter ( req , res , next ) { if ( req . _post_body ) { return next ( ) ; } req . post_body = req . post_body || '' ; if ( 'POST' !== req . method ) { return next ( ) ; } req . _post_body = true ; req . on ( 'data' , function ( chunk ) { req . post_body += chunk ; } ) ; next ( ) ; }
719	function requireBody ( paramsList ) { return function ( req , res , next ) { var errors = [ ] ; var status = 'ok' ; for ( var i = 0 ; i < paramsList . length ; i ++ ) { var val = req . body [ paramsList [ i ] ] ; if ( ! val ) { errors . push ( ` \` ${ paramsList [ i ] } \` ` ) ; status = 'error' ; } } if ( errors . length === 0 ) { next ( ) ; } else { return res . status ( 400 ) . json ( { errors : errors , status : status } ) ; } } ; }
720	function anonProject ( req , res , next ) { var name = ` ${ req . params . org } ${ req . params . repo } ` ; name = name . toLowerCase ( ) ; Project . findOne ( { name : name } ) . populate ( 'creator' ) . exec ( function ( err , project ) { if ( err ) { return res . status ( 500 ) . send ( { error : 'Failed to find project' , info : err } ) ; } if ( ! project ) { return res . status ( 404 ) . send ( 'Project not found' ) ; } if ( ! project . creator ) { return res . status ( 400 ) . send ( 'Project malformed; project creator user is missing.' ) ; } req . project = project ; req . accessLevel = User . projectAccessLevel ( req . user , project ) ; if ( req . user && project . creator ) { req . user . isProjectCreator = project . creator . _id . toString ( ) === req . user . _id . toString ( ) ; } next ( ) ; } ) ; }
721	function requireUser ( req , res , next ) { if ( req . user ) { next ( ) ; } else { req . session . return_to = req . url ; res . redirect ( '/login' ) ; } }
722	function requireAdminOr401 ( req , res , next ) { if ( ! req . user || ! req . user [ 'account_level' ] || req . user . account_level < 1 ) { res . status ( 401 ) . send ( 'not authorized' ) ; } else { next ( ) ; } }
723	function pluginBlock ( indent , parser ) { var template = this . args [ 0 ] ; var output = '' ; output += ` ${ template } \n ` ; output += ` ${ template } \n ` ; output += 'if (_pg){ ' ; output += '_output += _pg;' ; output += '} else {\n' ; \n output += parser . compile . call ( this , ` ${ indent } ` ) ; output += '}\n' ; }
724	function _findNested ( d ) { let nested = [ ] ; walk . walkSync ( d , ( basedir , filename , stat ) => { const file = path . join ( basedir , filename ) ; if ( file . indexOf ( '.app/Info.plist' ) !== - 1 ) { const nest = file . lastIndexOf ( '.app/' ) ; nested . push ( file . substring ( 0 , nest + 4 ) ) ; } } ) ; return nested ; }
725	function binAbsLibs ( file , o ) { try { return bin . enumerateLibraries ( file ) . filter ( ( l ) => { return ! ( l . startsWith ( '/' ) ) ; } ) . map ( ( l ) => { if ( l [ 0 ] === '@' ) { const ll = depSolver . resolvePath ( o . exe , file , l , o . libs ) ; if ( ll ) { l = ll ; } else { console . error ( 'Warning: Cannot resolve dependency library: ' + file ) ; } } return l ; } ) ; } catch ( e ) { console . error ( 'Warning: missing file:' , file ) ; return [ ] ; } }
726	function _findLibraries ( appdir , appbin , disklibs ) { const exe = path . join ( appdir , appbin ) ; const o = { exe : exe , lib : exe , libs : disklibs } ; const libraries = [ ] ; const pending = [ exe ] ; while ( pending . length > 0 ) { const target = pending . pop ( ) ; if ( libraries . indexOf ( target ) === - 1 ) { libraries . push ( target ) ; } let res = binAbsLibs ( target , o ) ; const unexplored = res . filter ( l => libraries . indexOf ( l ) === - 1 ) ; pending . push ( ... unexplored . filter ( l => pending . indexOf ( l ) === - 1 ) ) ; libraries . push ( ... unexplored ) ; } return libraries ; }
727	function fix ( file , options , emit ) { const { appdir , bundleid , forceFamily , allowHttp } = options ; if ( ! file || ! appdir ) { throw new Error ( 'Invalid parameters for fixPlist' ) ; } let changed = false ; const data = plist . readFileSync ( file ) ; delete data [ '' ] ; if ( allowHttp ) { emit ( 'message' , 'Adding NSAllowArbitraryLoads' ) ; if ( ! Object . isObject ( data [ 'NSAppTransportSecurity' ] ) ) { data [ 'NSAppTransportSecurity' ] = { } ; } data [ 'NSAppTransportSecurity' ] [ 'NSAllowsArbitraryLoads' ] = true ; changed = true ; } if ( forceFamily ) { if ( performForceFamily ( data , emit ) ) { changed = true ; } } if ( bundleid ) { setBundleId ( data , bundleid ) ; changed = true ; } if ( changed ) { plist . writeFileSync ( file , data ) ; } }
728	function generateAccessor ( accessor ) { return function ( ) { let value = container [ varName ] if ( typeof value === 'undefined' ) { if ( typeof defValue === 'undefined' ) { return } value = defValue } if ( isBase64 ) { if ( ! value . match ( base64Regex ) ) { generateRaiseError ( value ) ( 'should be a valid base64 string if using convertFromBase64' ) } value = Buffer . from ( value , 'base64' ) . toString ( ) } const args = [ generateRaiseError ( value ) , value ] . concat ( Array . prototype . slice . call ( arguments ) ) return accessor . apply ( accessor , args ) } }
729	function ( isRequired ) { if ( isRequired === false ) { return accessors } if ( typeof container [ varName ] === 'undefined' && typeof defValue === 'undefined' ) { throw new EnvVarError ( ` ${ varName } ` ) } return accessors }
730	function ( ast , bodyContent ) { var macro = this . macros [ ast . id ] ; var ret = '' ; if ( ! macro ) { var jsmacros = this . jsmacros ; macro = jsmacros [ ast . id ] ; var jsArgs = [ ] ; if ( macro && macro . apply ) { utils . forEach ( ast . args , function ( a ) { jsArgs . push ( this . getLiteral ( a ) ) ; } , this ) ; var self = this ; jsmacros . eval = function ( ) { return self . eval . apply ( self , arguments ) ; } ; try { ret = macro . apply ( jsmacros , jsArgs ) ; } catch ( e ) { var pos = ast . pos ; var text = Velocity . Helper . getRefText ( ast ) ; var err = '\n at ' + \n + text + ' L/N ' + pos . first_line + ':' ; pos . first_column e . name = '' ; e . message += err ; } } } else throw new Error ( e ) ; { var asts = macro . asts ; var args = macro . args ; var callArgs = ast . args ; var local = { bodyContent : bodyContent } ; var guid = utils . guid ( ) ; var contextId = 'macro:' + ast . id + ':' + guid ; utils . forEach ( args , function ( ref , i ) { if ( callArgs [ i ] ) { local [ ref . id ] = this . getLiteral ( callArgs [ i ] ) ; } else { local [ ref . id ] = undefined ; } } , this ) ; ret = this . eval ( asts , local , contextId ) ; } }
731	function checkBinReferences_ ( file , data , warn , cb ) { if ( ! ( data . bin instanceof Object ) ) return cb ( ) var keys = Object . keys ( data . bin ) var keysLeft = keys . length if ( ! keysLeft ) return cb ( ) function handleExists ( relName , result ) { keysLeft -- if ( ! result ) warn ( 'No bin file found at ' + relName ) if ( ! keysLeft ) cb ( ) } keys . forEach ( function ( key ) { var dirName = path . dirname ( file ) var relName = data . bin [ key ] try { var binPath = path . resolve ( dirName , relName ) fs . stat ( binPath , ( err ) => handleExists ( relName , ! err ) ) } catch ( error ) { if ( error . message === 'Arguments to path.resolve must be strings' || error . message . indexOf ( 'Path must be a string' ) === 0 ) { warn ( 'Bin filename for ' + key + ' is not a string: ' + util . inspect ( relName ) ) handleExists ( relName , true ) } else { cb ( error ) } } } ) }
732	function ( ) { var self = this ; self . bind ( 'RuntimeInit' , function ( e , runtime ) { self . ruid = runtime . uid ; self . shimid = runtime . shimid ; self . bind ( "Ready" , function ( ) { self . trigger ( "Refresh" ) ; } , 999 ) ; self . bind ( 'Refresh' , function ( ) { var pos , size , browseButton , shimContainer , zIndex ; browseButton = Dom . get ( options . browse_button ) ; shimContainer = Dom . get ( runtime . shimid ) ; if ( browseButton ) { pos = Dom . getPos ( browseButton , Dom . get ( options . container ) ) ; size = Dom . getSize ( browseButton ) ; zIndex = parseInt ( Dom . getStyle ( browseButton , 'z-index' ) , 10 ) || 0 ; if ( shimContainer ) { Basic . extend ( shimContainer . style , { top : pos . y + 'px' , left : pos . x + 'px' , width : size . w + 'px' , height : size . h + 'px' , zIndex : zIndex + 1 } ) ; } } shimContainer = browseButton = null ; } ) ; runtime . exec . call ( self , 'FileInput' , 'init' , options ) ; } ) ; self . connectRuntime ( Basic . extend ( { } , options , { required_caps : { select_file : true } } ) ) ; }
733	function ( name , value ) { if ( ! options . hasOwnProperty ( name ) ) { return ; } var oldValue = options [ name ] ; switch ( name ) { case 'accept' : if ( typeof ( value ) === 'string' ) { value = Mime . mimes2extList ( value ) ; } break ; case 'container' : case 'required_caps' : throw new x . FileException ( x . FileException . NO_MODIFICATION_ALLOWED_ERR ) ; } options [ name ] = value ; this . exec ( 'FileInput' , 'setOption' , name , value ) ; this . trigger ( 'OptionChanged' , name , value , oldValue ) ; }
734	function ( e , runtime ) { self . unbind ( "RuntimeInit" , cb ) ; _run . call ( self , type , runtime ) ; }
735	function ( ) { this . result = null ; if ( Basic . inArray ( this . readyState , [ FileReader . EMPTY , FileReader . DONE ] ) !== - 1 ) { return ; } else if ( this . readyState === FileReader . LOADING ) { this . readyState = FileReader . DONE ; } this . exec ( 'FileReader' , 'abort' ) ; this . trigger ( 'abort' ) ; this . trigger ( 'loadend' ) ; }
736	function ( type ) { var list ; if ( type ) { type = type . toLowerCase ( ) ; list = eventpool [ this . uid ] && eventpool [ this . uid ] [ type ] ; } else { list = eventpool [ this . uid ] ; } return list ? list : false ; }
737	function ( type , fn ) { var self = this , list , i ; type = type . toLowerCase ( ) ; if ( / \s / . test ( type ) ) { Basic . each ( type . split ( / \s+ / ) , function ( type ) { self . removeEventListener ( type , fn ) ; } ) ; return ; } list = eventpool [ this . uid ] && eventpool [ this . uid ] [ type ] ; if ( list ) { if ( fn ) { for ( i = list . length - 1 ; i >= 0 ; i -- ) { if ( list [ i ] . fn === fn ) { list . splice ( i , 1 ) ; break ; } } } else { list = [ ] ; } if ( ! list . length ) { delete eventpool [ this . uid ] [ type ] ; if ( Basic . isEmptyObj ( eventpool [ this . uid ] ) ) { delete eventpool [ this . uid ] ; } } } }
738	function ( type , fn , priority , scope ) { var self = this ; self . bind . call ( this , type , function cb ( ) { self . unbind ( type , cb ) ; return fn . apply ( this , arguments ) ; } , priority , scope ) ; }
739	function ( cap , value ) { var refCaps = arguments [ 2 ] || caps ; if ( Basic . typeOf ( cap ) === 'string' && Basic . typeOf ( value ) === 'undefined' ) { cap = Runtime . parseCaps ( cap ) ; } if ( Basic . typeOf ( cap ) === 'object' ) { for ( var key in cap ) { if ( ! this . can ( key , cap [ key ] , refCaps ) ) { return false ; } } return true ; } if ( Basic . typeOf ( refCaps [ cap ] ) === 'function' ) { return refCaps [ cap ] . call ( this , value ) ; } else { return ( value === refCaps [ cap ] ) ; } }
740	function getShimVersion ( ) { var version ; try { version = navigator . plugins [ 'Shockwave Flash' ] ; version = version . description ; } catch ( e1 ) { try { version = new ActiveXObject ( 'ShockwaveFlash.ShockwaveFlash' ) . GetVariable ( '$version' ) ; } catch ( e2 ) { version = '0.0' ; } } version = version . match ( / \d+ / g ) ; return parseFloat ( version [ 0 ] + '.' + version [ 1 ] ) ; }
741	function removeSWF ( id ) { var obj = Dom . get ( id ) ; if ( obj && obj . nodeName == "OBJECT" ) { if ( Env . browser === 'IE' ) { obj . style . display = "none" ; ( function onInit ( ) { if ( obj . readyState == 4 ) { removeObjectInIE ( id ) ; } else { setTimeout ( onInit , 10 ) ; } } ) ( ) ; } else { obj . parentNode . removeChild ( obj ) ; } } }
742	function ( url ) { function origin ( url ) { return [ url . scheme , url . host , url . port ] . join ( '/' ) ; } if ( typeof url === 'string' ) { url = parseUrl ( url ) ; } return origin ( parseUrl ( ) ) === origin ( url ) ; }
743	function ctor ( ) { this . constructor = child ; if ( MXI_DEBUG ) { var getCtorName = function ( fn ) { var m = fn . toString ( ) . match ( / ^function\s([^\(\s]+) / ) ; return m ? m [ 1 ] : false ; } ; this . ctorName = getCtorName ( child ) ; } }
744	function inArray ( needle , array ) { if ( array ) { if ( Array . prototype . indexOf ) { return Array . prototype . indexOf . call ( array , needle ) ; } for ( var i = 0 , length = array . length ; i < length ; i ++ ) { if ( array [ i ] === needle ) { return i ; } } } return - 1 ; }
745	function arrayDiff ( needles , array ) { var diff = [ ] ; if ( typeOf ( needles ) !== 'array' ) { needles = [ needles ] ; } if ( typeOf ( array ) !== 'array' ) { array = [ array ] ; } for ( var i in needles ) { if ( inArray ( needles [ i ] , array ) === - 1 ) { diff . push ( needles [ i ] ) ; } } return diff . length ? diff : false ; }
746	function arrayIntersect ( array1 , array2 ) { var result = [ ] ; each ( array1 , function ( item ) { if ( inArray ( item , array2 ) !== - 1 ) { result . push ( item ) ; } } ) ; return result . length ? result : null ; }
747	function parseSizeStr ( size ) { if ( typeof ( size ) !== 'string' ) { return size ; } var muls = { t : 1099511627776 , g : 1073741824 , m : 1048576 , k : 1024 } , mul ; size = / ^([0-9\.]+)([tmgk]?)$ / . exec ( size . toLowerCase ( ) . replace ( / [^0-9\.tmkg] / g , '' ) ) ; mul = size [ 2 ] ; size = + size [ 1 ] ; if ( muls . hasOwnProperty ( mul ) ) { size *= muls [ mul ] ; } return Math . floor ( size ) ; }
748	function ( name , value ) { var self = this , valueType = Basic . typeOf ( value ) ; if ( value instanceof Blob ) { _blob = { name : name , value : value } ; } else if ( 'array' === valueType ) { name += '[]' ; Basic . each ( value , function ( value ) { self . append ( name , value ) ; } ) ; } else if ( 'object' === valueType ) { Basic . each ( value , function ( value , key ) { self . append ( name + '[' + key + ']' , value ) ; } ) ; } else if ( 'null' === valueType || 'undefined' === valueType || 'number' === valueType && isNaN ( value ) ) { self . append ( name , "false" ) ; } else { _fields . push ( { name : name , value : value . toString ( ) } ) ; } }
749	function ( cb ) { Basic . each ( _fields , function ( field ) { cb ( field . value , field . name ) ; } ) ; if ( _blob ) { cb ( _blob . value , _blob . name ) ; } }
750	function ( obj , name ) { if ( ! obj . className ) { return false ; } var regExp = new RegExp ( "(^|\\s+)" + \\ + name ) ; "(\\s+|$)" }
751	function ( obj , name ) { if ( ! hasClass ( obj , name ) ) { obj . className = ! obj . className ? name : obj . className . replace ( / \s+$ / , '' ) + ' ' + name ; } }
752	function ( obj , name ) { if ( obj . className ) { var regExp = new RegExp ( "(^|\\s+)" + \\ + name ) ; "(\\s+|$)" } }
753	function ( obj , name ) { if ( obj . currentStyle ) { return obj . currentStyle [ name ] ; } else if ( window . getComputedStyle ) { return window . getComputedStyle ( obj , null ) [ name ] ; } }
754	function ( node , root ) { var x = 0 , y = 0 , parent , doc = document , nodeRect , rootRect ; node = node ; root = root || doc . body ; function getIEPos ( node ) { var bodyElm , rect , x = 0 , y = 0 ; if ( node ) { rect = node . getBoundingClientRect ( ) ; bodyElm = doc . compatMode === "CSS1Compat" ? doc . documentElement : doc . body ; x = rect . left + bodyElm . scrollLeft ; y = rect . top + bodyElm . scrollTop ; } return { x : x , y : y } ; } if ( node && node . getBoundingClientRect && Env . browser === 'IE' && ( ! doc . documentMode || doc . documentMode < 8 ) ) { nodeRect = getIEPos ( node ) ; rootRect = getIEPos ( root ) ; return { x : nodeRect . x - rootRect . x , y : nodeRect . y - rootRect . y } ; } parent = node ; while ( parent && parent != root && parent . nodeType ) { x += parent . offsetLeft || 0 ; y += parent . offsetTop || 0 ; parent = parent . offsetParent ; } parent = node . parentNode ; while ( parent && parent != root && parent . nodeType ) { x -= parent . scrollLeft || 0 ; y -= parent . scrollTop || 0 ; parent = parent . parentNode ; } return { x : x , y : y } ; }
755	function getIEPos ( node ) { var bodyElm , rect , x = 0 , y = 0 ; if ( node ) { rect = node . getBoundingClientRect ( ) ; bodyElm = doc . compatMode === "CSS1Compat" ? doc . documentElement : doc . body ; x = rect . left + bodyElm . scrollLeft ; y = rect . top + bodyElm . scrollTop ; } return { x : x , y : y } ; }
756	function ( node ) { return { w : node . offsetWidth || node . clientWidth , h : node . offsetHeight || node . clientHeight } ; }
757	function ( obj , key ) { if ( ! obj || ! obj [ uid ] ) { return ; } Basic . each ( eventhash [ obj [ uid ] ] , function ( events , name ) { removeEvent ( obj , name , key ) ; } ) ; }
758	function _preloadAndSend ( meta , data ) { var target = this , blob , fr ; blob = data . getBlob ( ) . getSource ( ) ; fr = new window . FileReader ( ) ; fr . onload = function ( ) { data . append ( data . getBlobName ( ) , new Blob ( null , { type : blob . type , data : fr . result } ) ) ; self . send . call ( target , meta , data ) ; } ; fr . readAsBinaryString ( blob ) ; }
759	function _rotateToOrientaion ( img , orientation ) { var RADIANS = Math . PI / 180 ; var canvas = document . createElement ( 'canvas' ) ; var ctx = canvas . getContext ( '2d' ) ; var width = img . width ; var height = img . height ; if ( Basic . inArray ( orientation , [ 5 , 6 , 7 , 8 ] ) > - 1 ) { canvas . width = height ; canvas . height = width ; } else { canvas . width = width ; canvas . height = height ; } switch ( orientation ) { case 2 : ctx . translate ( width , 0 ) ; ctx . scale ( - 1 , 1 ) ; break ; case 3 : ctx . translate ( width , height ) ; ctx . rotate ( 180 * RADIANS ) ; break ; case 4 : ctx . translate ( 0 , height ) ; ctx . scale ( 1 , - 1 ) ; break ; case 5 : ctx . rotate ( 90 * RADIANS ) ; ctx . scale ( 1 , - 1 ) ; break ; case 6 : ctx . rotate ( 90 * RADIANS ) ; ctx . translate ( 0 , - height ) ; break ; case 7 : ctx . rotate ( 90 * RADIANS ) ; ctx . translate ( width , - height ) ; ctx . scale ( - 1 , 1 ) ; break ; case 8 : ctx . rotate ( - 90 * RADIANS ) ; ctx . translate ( - width , 0 ) ; break ; } ctx . drawImage ( img , 0 , 0 , width , height ) ; return canvas ; }
760	function getEntries ( cbcb ) { dirReader . readEntries ( function ( moreEntries ) { if ( moreEntries . length ) { [ ] . push . apply ( entries , moreEntries ) ; getEntries ( cbcb ) ; } else { cbcb ( ) ; } } , cbcb ) ; }
761	function ( method , url , async , user , password ) { var urlp ; if ( ! method || ! url ) { throw new x . DOMException ( x . DOMException . SYNTAX_ERR ) ; } if ( / [\u0100-\uffff] / . test ( method ) || Encode . utf8_encode ( method ) !== method ) { throw new x . DOMException ( x . DOMException . SYNTAX_ERR ) ; } if ( ! ! ~ Basic . inArray ( method . toUpperCase ( ) , [ 'CONNECT' , 'DELETE' , 'GET' , 'HEAD' , 'OPTIONS' , 'POST' , 'PUT' , 'TRACE' , 'TRACK' ] ) ) { _method = method . toUpperCase ( ) ; } if ( ! ! ~ Basic . inArray ( _method , [ 'CONNECT' , 'TRACE' , 'TRACK' ] ) ) { throw new x . DOMException ( x . DOMException . SECURITY_ERR ) ; } url = Encode . utf8_encode ( url ) ; urlp = Url . parseUrl ( url ) ; _same_origin_flag = Url . hasSameOrigin ( urlp ) ; _url = Url . resolveUrl ( url ) ; if ( ( user || password ) && ! _same_origin_flag ) { throw new x . DOMException ( x . DOMException . INVALID_ACCESS_ERR ) ; } _user = user || urlp . user ; _password = password || urlp . pass ; _async = async || true ; if ( _async === false && ( _p ( 'timeout' ) || _p ( 'withCredentials' ) || _p ( 'responseType' ) !== "" ) ) { throw new x . DOMException ( x . DOMException . INVALID_ACCESS_ERR ) ; } _sync_flag = ! _async ; _send_flag = false ; _headers = { } ; _reset . call ( this ) ; _p ( 'readyState' , XMLHttpRequest . OPENED ) ; this . dispatchEvent ( 'readystatechange' ) ; }
762	function ( header , value ) { var uaHeaders = [ "accept-charset" , "accept-encoding" , "access-control-request-headers" , "access-control-request-method" , "connection" , "content-length" , "cookie" , "cookie2" , "content-transfer-encoding" , "date" , "expect" , "host" , "keep-alive" , "origin" , "referer" , "te" , "trailer" , "transfer-encoding" , "upgrade" , "user-agent" , "via" ] ; if ( _p ( 'readyState' ) !== XMLHttpRequest . OPENED || _send_flag ) { throw new x . DOMException ( x . DOMException . INVALID_STATE_ERR ) ; } if ( / [\u0100-\uffff] / . test ( header ) || Encode . utf8_encode ( header ) !== header ) { throw new x . DOMException ( x . DOMException . SYNTAX_ERR ) ; } header = Basic . trim ( header ) . toLowerCase ( ) ; if ( ! ! ~ Basic . inArray ( header , uaHeaders ) || / ^(proxy\-|sec\-) / . test ( header ) ) { return false ; } if ( ! _headers [ header ] ) { _headers [ header ] = value ; } else { _headers [ header ] += ', ' + value ; } return true ; }
763	function ( header ) { header = header . toLowerCase ( ) ; if ( _error_flag || ! ! ~ Basic . inArray ( header , [ 'set-cookie' , 'set-cookie2' ] ) ) { return null ; } if ( _responseHeaders && _responseHeaders !== '' ) { if ( ! _responseHeadersBag ) { _responseHeadersBag = { } ; Basic . each ( _responseHeaders . split ( / \r\n / ) , function ( line ) { var pair = line . split ( / :\s+ / ) ; if ( pair . length === 2 ) { pair [ 0 ] = Basic . trim ( pair [ 0 ] ) ; _responseHeadersBag [ pair [ 0 ] . toLowerCase ( ) ] = { header : pair [ 0 ] , value : Basic . trim ( pair [ 1 ] ) } ; } } ) ; } if ( _responseHeadersBag . hasOwnProperty ( header ) ) { return _responseHeadersBag [ header ] . header + ': ' + _responseHeadersBag [ header ] . value ; } } return null ; }
764	function ( mime ) { var matches , charset ; if ( ! ! ~ Basic . inArray ( _p ( 'readyState' ) , [ XMLHttpRequest . LOADING , XMLHttpRequest . DONE ] ) ) { throw new x . DOMException ( x . DOMException . INVALID_STATE_ERR ) ; } mime = Basic . trim ( mime . toLowerCase ( ) ) ; if ( / ; / . test ( mime ) && ( matches = mime . match ( / ^([^;]+)(?:;\scharset\=)?(.*)$ / ) ) ) { mime = matches [ 1 ] ; if ( matches [ 2 ] ) { charset = matches [ 2 ] ; } } if ( ! Mime . mimes [ mime ] ) { throw new x . DOMException ( x . DOMException . SYNTAX_ERR ) ; } _finalMime = mime ; _finalCharset = charset ; }
765	function ( data , options ) { if ( Basic . typeOf ( options ) === 'string' ) { _options = { ruid : options } ; } else if ( ! options ) { _options = { } ; } else { _options = options ; } if ( this . readyState !== XMLHttpRequest . OPENED || _send_flag ) { throw new x . DOMException ( x . DOMException . INVALID_STATE_ERR ) ; } if ( data instanceof Blob ) { _options . ruid = data . ruid ; _mimeType = data . type || 'application/octet-stream' ; } else if ( data instanceof FormData ) { if ( data . hasBlob ( ) ) { var blob = data . getBlob ( ) ; _options . ruid = blob . ruid ; _mimeType = blob . type || 'application/octet-stream' ; } } else if ( typeof data === 'string' ) { _encoding = 'UTF-8' ; _mimeType = 'text/plain;charset=UTF-8' ; data = Encode . utf8_encode ( data ) ; } if ( ! this . withCredentials ) { this . withCredentials = ( _options . required_caps && _options . required_caps . send_browser_cookies ) && ! _same_origin_flag ; } _upload_events_flag = ( ! _sync_flag && this . upload . hasEventListener ( ) ) ; _error_flag = false ; _upload_complete_flag = ! data ; if ( ! _sync_flag ) { _send_flag = true ; } _doXHR . call ( this , data ) ; }
766	function ( ) { _error_flag = true ; _sync_flag = false ; if ( ! ~ Basic . inArray ( _p ( 'readyState' ) , [ XMLHttpRequest . UNSENT , XMLHttpRequest . OPENED , XMLHttpRequest . DONE ] ) ) { _p ( 'readyState' , XMLHttpRequest . DONE ) ; _send_flag = false ; if ( _xhr ) { _xhr . getRuntime ( ) . exec . call ( _xhr , 'XMLHttpRequest' , 'abort' , _upload_complete_flag ) ; } else { throw new x . DOMException ( x . DOMException . INVALID_STATE_ERR ) ; } _upload_complete_flag = true ; } else { _p ( 'readyState' , XMLHttpRequest . UNSENT ) ; } }
767	function ( target ) { var undef ; each ( arguments , function ( arg , i ) { if ( i > 0 ) { each ( arg , function ( value , key ) { if ( value !== undef ) { if ( typeof ( target [ key ] ) === typeof ( value ) && ( typeof ( value ) === 'object' || util . isArray ( value ) ) ) { extend ( target [ key ] , value ) ; } else { target [ key ] = value ; } } } ) ; } } ) ; return target ; }
768	function ( ) { if ( this . ruid ) { this . getRuntime ( ) . exec . call ( this , 'Image' , 'destroy' ) ; this . disconnectRuntime ( ) ; } if ( this . meta && this . meta . thumb ) { this . meta . thumb . data . destroy ( ) ; } this . unbindAll ( ) ; }
769	function ( obj , prop , desc ) { if ( o . typeOf ( desc ) === 'object' ) { defineGSetter . call ( obj , prop , desc , 'get' ) ; if ( ! Object . defineProperty ) { defineGSetter . call ( obj , prop , desc , 'set' ) ; } } }
770	function ( prop , desc , type ) { var defaults = { enumerable : true , configurable : true } , fn , camelType , self = this ; type = type . toLowerCase ( ) ; camelType = type . replace ( / ^[gs] / , function ( $1 ) { return $1 . toUpperCase ( ) ; } ) ; if ( o . typeOf ( desc ) === 'function' ) { fn = desc ; desc = { } ; desc [ type ] = fn ; } else if ( o . typeOf ( desc [ type ] ) === 'function' ) { fn = desc [ type ] ; } else { return ; } if ( Env . can ( 'define_property' ) ) { if ( Object . defineProperty ) { return Object . defineProperty ( this , prop , o . extend ( { } , defaults , desc ) ) ; } else { return self [ '__define' + camelType + 'ter__' ] ( prop , fn ) ; } } }
771	function SyntaxError ( message , expected , found , offset , line , column ) { Error . call ( this , message ) this . name = 'SyntaxError' this . message = message this . expected = expected this . found = found this . offset = offset this . line = line this . column = column }
772	function ( twist ) { var i , m , o , ori , parity , v ; if ( twist != null ) { parity = 0 ; for ( i = m = 6 ; m >= 0 ; i = -- m ) { ori = twist % 3 ; twist = ( twist / 3 ) | 0 ; this . co [ i ] = ori ; parity += ori ; } this . co [ 7 ] = ( 3 - parity % 3 ) % 3 ; return this ; } else { v = 0 ; for ( i = o = 0 ; o <= 6 ; i = ++ o ) { v = 3 * v + this . co [ i ] ; } return v ; } }
773	function ( flip ) { var i , m , o , ori , parity , v ; if ( flip != null ) { parity = 0 ; for ( i = m = 10 ; m >= 0 ; i = -- m ) { ori = flip % 2 ; flip = flip / 2 | 0 ; this . eo [ i ] = ori ; parity += ori ; } this . eo [ 11 ] = ( 2 - parity % 2 ) % 2 ; return this ; } else { v = 0 ; for ( i = o = 0 ; o <= 10 ; i = ++ o ) { v = 2 * v + this . eo [ i ] ; } return v ; } }
774	function ( ) { var i , j , m , o , ref , ref1 , ref2 , ref3 , s ; s = 0 ; for ( i = m = ref = DRB , ref1 = URF + 1 ; ( ref <= ref1 ? m <= ref1 : m >= ref1 ) ; i = ref <= ref1 ? ++ m : -- m ) { for ( j = o = ref2 = i - 1 , ref3 = URF ; ( ref2 <= ref3 ? o <= ref3 : o >= ref3 ) ; j = ref2 <= ref3 ? ++ o : -- o ) { if ( this . cp [ j ] > this . cp [ i ] ) { s ++ ; } } } return s % 2 ; }
775	function ( ) { var i , j , m , o , ref , ref1 , ref2 , ref3 , s ; s = 0 ; for ( i = m = ref = BR , ref1 = UR + 1 ; ( ref <= ref1 ? m <= ref1 : m >= ref1 ) ; i = ref <= ref1 ? ++ m : -- m ) { for ( j = o = ref2 = i - 1 , ref3 = UR ; ( ref2 <= ref3 ? o <= ref3 : o >= ref3 ) ; j = ref2 <= ref3 ? ++ o : -- o ) { if ( this . ep [ j ] > this . ep [ i ] ) { s ++ ; } } } return s % 2 ; }
776	function all_modulo ( tickValues , interval ) { var maxDecimals = reduce ( tickValues , function ( prevMax , tick ) { if ( ( tick % 1 ) !== 0 ) { return Math . max ( prevMax , tick . toString ( ) . split ( "." ) [ 1 ] . length ) ; } else { return prevMax ; } } , 0 ) ; var decimalOffset = Math . pow ( 10 , maxDecimals ) ; interval = interval * decimalOffset ; return reduce ( tickValues , function ( prev , curr ) { return prev && ( ( curr * decimalOffset ) % interval === 0 ) ; } , true ) ; }
777	function autoDateFormatAndFrequency ( minDate , maxDate , dateFormat , availableWidth ) { var timespan = Math . abs ( maxDate - minDate ) ; var years = timespan / 31536000000 ; var months = timespan / 2628000000 ; var days = timespan / 86400000 ; var yearGap ; var hourGap ; var interval ; var targetPixelGap = 64 ; var maximum_ticks = Math . max ( Math . floor ( availableWidth / targetPixelGap ) , 1 ) ; var time_gap = timespan / maximum_ticks ; if ( dateFormat == "auto" ) { if ( days <= 2 ) { dateFormat = "h" ; } else if ( days <= 91 ) { dateFormat = "M1d" ; } else if ( months < 36 ) { dateFormat = "M" ; } else { dateFormat = "yy" ; } } var gapInYears = humanReadableNumber ( Math . floor ( time_gap / 31536000000 ) ) ; var gapInMonths = Math . ceil ( time_gap / 2628000000 ) ; var gapInDays = humanReadableNumber ( time_gap / 86400000 ) ; var gapInHours = humanReadableNumber ( time_gap / 3600000 ) ; maxDate . addMilliseconds ( 0.1 ) ; switch ( dateFormat ) { case "yy" : maxDate = d3 . time . day . offset ( maxDate , 1 ) ; interval = d3 . time . year . range ( minDate , maxDate , gapInYears ) ; break ; case "yyyy" : maxDate = d3 . time . day . offset ( maxDate , 1 ) ; interval = d3 . time . year . range ( minDate , maxDate , gapInYears ) ; break ; case "MM" : interval = d3 . time . month . range ( minDate , maxDate , gapInMonths ) ; break ; case "M" : interval = d3 . time . month . range ( minDate , maxDate , gapInMonths ) ; break ; case "Mdd" : interval = d3 . time . day . range ( minDate , maxDate , gapInDays ) ; break ; case "M1d" : interval = d3 . time . day . range ( minDate , maxDate , gapInDays ) ; break ; case "YY" : interval = d3 . time . year . range ( minDate , maxDate , gapInYears ) ; break ; case "QJan" : interval = d3 . time . month . range ( minDate , maxDate , 4 ) ; break ; case "QJul" : interval = d3 . time . month . range ( minDate , maxDate , 4 ) ; break ; case "h" : interval = d3 . time . hour . range ( minDate , maxDate , gapInHours ) ; break ; default : interval = d3 . time . year . range ( minDate , maxDate , 1 ) ; } interval = cleanInterval ( interval ) ; return { "format" : dateFormat , "frequency" : interval } ; }
778	function validate_chart_model ( modelStr ) { var parsed ; try { parsed = JSON . parse ( modelStr ) ; } catch ( e ) { throw new TypeError ( "Chart model is not valid JSON" ) ; } var isValidChartModel = ( parsed . hasOwnProperty ( "chartProps" ) && parsed . hasOwnProperty ( "metadata" ) ) ; if ( isValidChartModel ) { return parsed ; } else { throw new TypeError ( "Not a valid Chartbuilder model" ) ; } }
779	function exact_ticks ( domain , numticks ) { numticks -= 1 ; var ticks = [ ] ; var delta = domain [ 1 ] - domain [ 0 ] ; var i ; for ( i = 0 ; i < numticks ; i ++ ) { ticks . push ( domain [ 0 ] + ( delta / numticks ) * i ) ; } ticks . push ( domain [ 1 ] ) ; if ( domain [ 1 ] * domain [ 0 ] < 0 ) { var hasZero = false ; for ( i = ticks . length - 1 ; i >= 0 ; i -- ) { if ( ticks [ i ] === 0 ) { hasZero = true ; } } if ( ! hasZero ) { ticks . push ( 0 ) ; } } return ticks ; }
780	function round_to_precision ( num , precision , supress_thou_sep ) { if ( num === 0 ) return "0" ; var s = Math . round ( num * Math . pow ( 10 , precision ) ) / Math . pow ( 10 , precision ) ; s = s + "" ; s = s . split ( "." ) ; if ( s . length == 1 ) { s [ 1 ] = "" ; } if ( s [ 1 ] . length < precision ) { s [ 1 ] += Array ( precision - s [ 1 ] . length + 1 ) . join ( "0" ) ; } if ( ! supress_thou_sep ) { s [ 0 ] = d3 . format ( "," ) ( parseInt ( s [ 0 ] ) ) ; } if ( precision === 0 ) { return s [ 0 ] ; } return s . join ( "." ) ; }
781	function merge_or_apply ( defaults , source ) { var defaultKeys = keys ( defaults ) ; var sourceKeys = keys ( source ) ; return reduce ( defaultKeys , function ( result , key ) { if ( sourceKeys . indexOf ( key ) > - 1 ) { result [ key ] = source [ key ] ; return result ; } else { result [ key ] = defaults [ key ] ; return result ; } } , { } ) ; }
782	function suggest_tick_num ( domain ) { var MAX_TICKS = 10 ; var INTERVAL_BASE_VALS = [ 1 , 2 , 2.5 , 5 , 10 , 25 ] ; var range = Math . abs ( domain [ 0 ] - domain [ 1 ] ) var minimum = range / MAX_TICKS ; var digits = Math . floor ( range ) . toString ( ) . length ; var multiplier = Math . pow ( 10 , ( digits - 2 ) ) ; var acceptable_intervals = reduce ( INTERVAL_BASE_VALS , function ( prev , curr ) { var mult = curr * multiplier ; if ( mult >= minimum ) { prev = prev . concat ( [ mult ] ) ; } return prev ; } , [ ] ) ; for ( var i = 0 ; i < acceptable_intervals . length ; i ++ ) { var interval = acceptable_intervals [ i ] if ( range % interval == 0 ) { return ( range / interval ) + 1 } } ; return 11 ; }
783	function detectNumberSeparators ( ) { var n = 1000.50 ; var l = n . toLocaleString ( ) ; var s = n . toString ( ) ; var o = { decimal : l . substring ( 5 , 6 ) , thousands : l . substring ( 1 , 2 ) } ; if ( l . substring ( 5 , 6 ) == s . substring ( 5 , 6 ) ) { o . decimal = "." ; } if ( l . substring ( 1 , 2 ) == s . substring ( 1 , 2 ) ) { o . thousands = "," ; } return o ; }
784	function transformerFactory ( fileSet , info ) { return transformer function transformer ( ast , file ) { var filePath = file . path var space = file . data var links = [ ] var landmarks = { } var references var current var link var pathname if ( ! filePath ) { return } references = gatherReferences ( file , ast , info , fileSet ) current = getPathname ( filePath ) for ( link in references ) { pathname = getPathname ( link ) if ( fileSet && pathname !== current && getHash ( link ) && links . indexOf ( pathname ) === - 1 ) { links . push ( pathname ) fileSet . add ( pathname ) } } landmarks [ filePath ] = true slugs . reset ( ) visit ( ast , mark ) space [ referenceId ] = references space [ landmarkId ] = landmarks function mark ( node ) { var data = node . data || { } var props = data . hProperties || { } var id = props . name || props . id || data . id if ( ! id && node . type === 'heading' ) { id = slugs . slug ( toString ( node ) ) } if ( id ) { landmarks [ filePath + '#' + id ] = true } } } }
785	function validate ( exposed , file ) { var references = file . data [ referenceId ] var filePath = file . path var reference var nodes var real var hash var pathname var warning var suggestion var ruleId for ( reference in references ) { nodes = references [ reference ] real = exposed [ reference ] hash = getHash ( reference ) if ( ( real === undefined || real === null ) && ! hash && fs ) { real = fs . existsSync ( path . join ( file . cwd , decodeURI ( reference ) ) ) references [ reference ] = real } if ( ! real ) { if ( hash ) { pathname = getPathname ( reference ) warning = 'Link to unknown heading' ruleId = headingRuleId if ( pathname !== filePath ) { warning += ' in `' + pathname + '`' ruleId = headingInFileRuleId } warning += ': `' + hash + '`' } else { warning = 'Link to unknown file: `' + decodeURI ( reference ) + '`' ruleId = fileRuleId } suggestion = getClosest ( reference , exposed ) if ( suggestion ) { warning += '. Did you mean `' + suggestion + '`' } warnAll ( file , nodes , warning , ruleId ) } } }
786	function onresource ( node ) { var link = node . url var definition var index var uri var pathname var hash if ( node . identifier ) { definition = getDefinition ( node . identifier ) link = definition && definition . url } if ( ! link ) { return } uri = parse ( link ) uri . search = '' link = format ( uri ) if ( ! fileSet && ( uri . hostname || uri . pathname ) ) { return } if ( ! uri . hostname ) { if ( lines && lineExpression . test ( uri . hash ) ) { uri . hash = '' } if ( ! uri . pathname && uri . hash ) { link = file . path + uri . hash uri = parse ( link ) } else { link = urljoin ( file . dirname , link ) if ( uri . hash ) { link += uri . hash } uri = parse ( link ) } } if ( uri . hostname ) { if ( ! prefix || ! fileSet ) { return } if ( uri . hostname !== info . domain || uri . pathname . slice ( 0 , prefix . length ) !== prefix ) { return } link = uri . pathname . slice ( prefix . length ) + ( uri . hash || '' ) link = link . slice ( link . indexOf ( '/' ) + 1 ) } index = link . indexOf ( headingPrefix ) if ( index === - 1 ) { pathname = link hash = null } else { pathname = link . slice ( 0 , index ) hash = link . slice ( index + headingPrefix . length ) if ( lines && lineExpression . test ( hash ) ) { hash = null } } if ( ! cache [ pathname ] ) { cache [ pathname ] = [ ] } cache [ pathname ] . push ( node ) if ( hash ) { link = pathname + '#' + hash if ( ! cache [ link ] ) { cache [ link ] = [ ] } cache [ link ] . push ( node ) } }
787	function warnAll ( file , nodes , reason , ruleId ) { nodes . forEach ( one ) function one ( node ) { file . message ( reason , node , [ sourceId , ruleId ] . join ( ':' ) ) } }
788	function getClosest ( pathname , references ) { var hash = getHash ( pathname ) var base = getPathname ( pathname ) var dictionary = [ ] var reference var subhash var subbase for ( reference in references ) { subbase = getPathname ( reference ) subhash = getHash ( reference ) if ( getPathname ( reference ) === base ) { if ( subhash && hash ) { dictionary . push ( subhash ) } } else if ( ! subhash && ! hash ) { dictionary . push ( subbase ) } } return propose ( hash ? hash : base , dictionary , { threshold : 0.7 } ) }
789	function getHash ( uri ) { var hash = parse ( uri ) . hash return hash ? hash . slice ( 1 ) : null }
790	function getPrevMap ( from ) { if ( typeof options . map . prev === 'string' ) { var mapPath = options . map . prev + path . basename ( from ) + '.map' ; if ( grunt . file . exists ( mapPath ) ) { return grunt . file . read ( mapPath ) ; } } }
791	function ( req , res , next ) { if ( req . url . indexOf ( '.' ) === - 1 && req . url . indexOf ( startDir ) > - 1 ) { req . url = startPath ; } return next ( ) ; }
792	function parseIPv4 ( addr ) { if ( typeof ( addr ) !== 'string' ) throw new TypeError ( 'addr (string) is required' ) ; var octets = addr . split ( / \. / ) . map ( function ( octet ) { return ( parseInt ( octet , 10 ) ) ; } ) ; if ( octets . length !== 4 ) throw new TypeError ( 'valid IP address required' ) ; var uint32 = ( ( octets [ 0 ] * Math . pow ( 256 , 3 ) ) + ( octets [ 1 ] * Math . pow ( 256 , 2 ) ) + ( octets [ 2 ] * 256 ) + octets [ 3 ] ) ; return ( uint32 ) ; }
793	function getNested ( obj , prop ) { var service = obj [ prop ] ; if ( service === undefined && Bottle . config . strict ) { throw new Error ( 'Bottle was unable to resolve a service. `' + prop + '` is undefined.' ) ; } return service ; }
794	function getNestedBottle ( name ) { var bottle ; if ( ! this . nested [ name ] ) { bottle = Bottle . pop ( ) ; this . nested [ name ] = bottle ; this . factory ( name , function SubProviderFactory ( ) { return bottle . container ; } ) ; } return this . nested [ name ] ; }
795	function applyMiddleware ( middleware , name , instance , container ) { var descriptor = { configurable : true , enumerable : true } ; if ( middleware . length ) { descriptor . get = function getWithMiddlewear ( ) { var index = 0 ; var next = function nextMiddleware ( err ) { if ( err ) { throw err ; } if ( middleware [ index ] ) { middleware [ index ++ ] ( instance , next ) ; } } ; next ( ) ; return instance ; } ; } else { descriptor . value = instance ; descriptor . writable = true ; } Object . defineProperty ( container , name , descriptor ) ; return container [ name ] ; }
796	function middleware ( fullname , func ) { var parts , name ; if ( typeof fullname === FUNCTION_TYPE ) { func = fullname ; fullname = GLOBAL_NAME ; } parts = fullname . split ( DELIMITER ) ; name = parts . shift ( ) ; if ( parts . length ) { getNestedBottle . call ( this , name ) . middleware ( parts . join ( DELIMITER ) , func ) ; } else { if ( ! this . middlewares [ name ] ) { this . middlewares [ name ] = [ ] ; } this . middlewares [ name ] . push ( func ) ; } return this ; }
797	function createProvider ( name , Provider ) { var providerName , properties , container , id , decorators , middlewares ; id = this . id ; container = this . container ; decorators = this . decorators ; middlewares = this . middlewares ; providerName = name + PROVIDER_SUFFIX ; properties = Object . create ( null ) ; properties [ providerName ] = { configurable : true , enumerable : true , get : function getProvider ( ) { var instance = new Provider ( ) ; delete container [ providerName ] ; container [ providerName ] = instance ; return instance ; } } ; properties [ name ] = { configurable : true , enumerable : true , get : function getService ( ) { var provider = container [ providerName ] ; var instance ; if ( provider ) { instance = getWithGlobal ( decorators , name ) . reduce ( reducer , provider . $get ( container ) ) ; delete container [ providerName ] ; delete container [ name ] ; } return instance === undefined ? instance : applyMiddleware ( getWithGlobal ( middlewares , name ) , name , instance , container ) ; } } ; Object . defineProperties ( container , properties ) ; return this ; }
798	function provider ( fullname , Provider ) { var parts , name ; parts = fullname . split ( DELIMITER ) ; if ( this . providerMap [ fullname ] && parts . length === 1 && ! this . container [ fullname + PROVIDER_SUFFIX ] ) { return console . error ( fullname + ' provider already instantiated.' ) ; } this . originalProviders [ fullname ] = Provider ; this . providerMap [ fullname ] = true ; name = parts . shift ( ) ; if ( parts . length ) { getNestedBottle . call ( this , name ) . provider ( parts . join ( DELIMITER ) , Provider ) ; return this ; } return createProvider . call ( this , name , Provider ) ; }
799	function createService ( name , Service , isClass ) { var deps = arguments . length > 3 ? slice . call ( arguments , 3 ) : [ ] ; var bottle = this ; return factory . call ( this , name , function GenericFactory ( ) { var serviceFactory = Service ; var args = deps . map ( getNestedService , bottle . container ) ; if ( ! isClass ) { return serviceFactory . apply ( null , args ) ; } return new ( Service . bind . apply ( Service , [ null ] . concat ( args ) ) ) ( ) ; } ) ; }
800	function service ( name , Service ) { return createService . apply ( this , [ name , Service , true ] . concat ( slice . call ( arguments , 2 ) ) ) ; }
801	function serviceFactory ( name , factoryService ) { return createService . apply ( this , [ name , factoryService , false ] . concat ( slice . call ( arguments , 2 ) ) ) ; }
802	function defineValue ( name , val ) { Object . defineProperty ( this , name , { configurable : true , enumerable : true , value : val , writable : true } ) ; }
803	function setValueObject ( container , name ) { var nestedContainer = container [ name ] ; if ( ! nestedContainer ) { nestedContainer = { } ; defineValue . call ( container , name , nestedContainer ) ; } return nestedContainer ; }
804	function value ( name , val ) { var parts ; parts = name . split ( DELIMITER ) ; name = parts . pop ( ) ; defineValue . call ( parts . reduce ( setValueObject , this . container ) , name , val ) ; return this ; }
805	function constant ( name , value ) { var parts = name . split ( DELIMITER ) ; name = parts . pop ( ) ; defineConstant . call ( parts . reduce ( setValueObject , this . container ) , name , value ) ; return this ; }
806	function decorator ( fullname , func ) { var parts , name ; if ( typeof fullname === FUNCTION_TYPE ) { func = fullname ; fullname = GLOBAL_NAME ; } parts = fullname . split ( DELIMITER ) ; name = parts . shift ( ) ; if ( parts . length ) { getNestedBottle . call ( this , name ) . decorator ( parts . join ( DELIMITER ) , func ) ; } else { if ( ! this . decorators [ name ] ) { this . decorators [ name ] = [ ] ; } this . decorators [ name ] . push ( func ) ; } return this ; }
807	function instanceFactory ( name , Factory ) { return factory . call ( this , name , function GenericInstanceFactory ( container ) { return { instance : Factory . bind ( Factory , container ) } ; } ) ; }
808	function pop ( name ) { var instance ; if ( typeof name === STRING_TYPE ) { instance = bottles [ name ] ; if ( ! instance ) { bottles [ name ] = instance = new Bottle ( ) ; instance . constant ( 'BOTTLE_NAME' , name ) ; } return instance ; } return new Bottle ( ) ; }
809	function register ( Obj ) { var value = Obj . $value === undefined ? Obj : Obj . $value ; return this [ Obj . $type || 'service' ] . apply ( this , [ Obj . $name , value ] . concat ( Obj . $inject || [ ] ) ) ; }
810	function resetProviders ( names ) { var tempProviders = this . originalProviders ; var shouldFilter = Array . isArray ( names ) ; Object . keys ( this . originalProviders ) . forEach ( function resetProvider ( originalProviderName ) { if ( shouldFilter && names . indexOf ( originalProviderName ) === - 1 ) { return ; } var parts = originalProviderName . split ( DELIMITER ) ; if ( parts . length > 1 ) { parts . forEach ( removeProviderMap , getNestedBottle . call ( this , parts [ 0 ] ) ) ; } removeProviderMap . call ( this , originalProviderName ) ; this . provider ( originalProviderName , tempProviders [ originalProviderName ] ) ; } , this ) ; }
811	function throwIfInvalidNode ( node , functionName ) { if ( ! exports . isASTNode ( node ) ) { throw new Error ( functionName + "(): " + util . inspect ( node ) + " is not a valid AST node." ) ; } }
812	function isEvent ( expr , eventDeclarations ) { for ( let { node , enclosingContract } of eventDeclarations ) { if ( expr . callee . name === node . name && sourceCode . isAChildOf ( expr , enclosingContract ) ) { return true ; } } return false ; }
813	function registerEventName ( emitted ) { const { node } = emitted ; ( ! emitted . exit ) && events . push ( { node , enclosingContract : sourceCode . getParent ( node ) } ) ; }
814	function inspectVariableDeclarator ( emitted ) { let node = emitted . node ; if ( ! emitted . exit ) { allVariableDeclarations [ node . id . name ] = node ; } }
815	function inspectProgram ( emitted ) { if ( emitted . exit ) { Object . keys ( allVariableDeclarations ) . forEach ( function ( name ) { context . report ( { node : allVariableDeclarations [ name ] , message : "Variable '" + name + "' is declared but never used." } ) ; } ) ; } }
816	function inspectIdentifier ( emitted ) { if ( ! emitted . exit ) { let node = emitted . node , sourceCode = context . getSourceCode ( ) ; if ( allVariableDeclarations [ node . name ] && sourceCode . getParent ( node ) . type !== "VariableDeclarator" ) { delete allVariableDeclarations [ node . name ] ; } } }
817	function inspectFunctionsOfContract ( emitted ) { if ( emitted . exit ) { return ; } const { node } = emitted , { body } = node ; let cursor = 0 ; body . filter ( child => { return [ "FunctionDeclaration" , "ConstructorDeclaration" ] . includes ( child . type ) ; } ) . forEach ( funcNode => { if ( ( context . options && isIgnored ( funcNode , node , context . options [ 0 ] . ignore ) ) || isFunctionVisibility ( node , funcNode , functionOrder [ cursor ] ) ) { return ; } const funcPosInOrder = findFuncPosInOrder ( node , funcNode ) ; if ( funcPosInOrder > cursor ) { cursor = funcPosInOrder ; return ; } context . report ( { node : funcNode , message : errorMessage } ) ; } ) ; }
818	function inspectCallExpression ( emitted ) { let node = emitted . node , callArgs = node . arguments ; if ( emitted . exit ) { return ; } let nodeCode = sourceCode . getText ( node ) ; if ( ! callArgs . length ) { for ( let i = nodeCode . length ; i > 0 ; i -- ) { if ( nodeCode [ i ] === ")" && nodeCode [ i - 1 ] === "(" ) { return ; } if ( / [\s\(\)] / . test ( nodeCode [ i ] ) ) { break ; } } return context . report ( { node : node , message : "\"" + \" + nodeCode + "\": " } ) ; } \" "A call without arguments should have brackets without any whitespace between them, like 'functionName ()'." let lastCallArg = callArgs . slice ( - 1 ) [ 0 ] ; if ( sourceCode . getLine ( node ) !== sourceCode . getEndingLine ( lastCallArg ) ) { return ; } let charBeforeFirstArg = sourceCode . getPrevChar ( callArgs [ 0 ] ) , charAfterLastCallArg = sourceCode . getNextChar ( lastCallArg ) ; }
819	function inspectExperimentalPragmaStatement ( emitted ) { if ( emitted . exit ) { return ; } const { node } = emitted , nodesAllowedAbove = [ "ExperimentalPragmaStatement" , "PragmaStatement" ] , programNode = context . getSourceCode ( ) . getParent ( node ) ; for ( let childNode of programNode . body ) { if ( node . start === childNode . start ) { return ; } const pragmaCode = context . getSourceCode ( ) . getText ( node ) ; if ( nodesAllowedAbove . indexOf ( childNode . type ) < 0 ) { const errObject = { node , fix ( fixer ) { return [ fixer . remove ( node ) , fixer . insertTextBefore ( childNode , ` ${ pragmaCode } ${ EOL } ` ) ] ; } , message : "Experimental Pragma must precede everything except Solidity Pragma." } ; return context . report ( errObject ) ; } } }
820	function ( sourceCode , errorMessages ) { let fixedSourceCode = "" , fixes = [ ] , fixesApplied = [ ] , remainingMessages = [ ] ; let cursor = Number . NEGATIVE_INFINITY ; function attemptFix ( fix ) { let start = fix . range [ 0 ] , end = fix . range [ 1 ] ; if ( cursor > start || start > end ) { return false ; } fixedSourceCode += sourceCode . slice ( Math . max ( 0 , cursor ) , Math . max ( 0 , start ) ) ; fixedSourceCode += fix . text ; cursor = end ; return true ; } errorMessages . forEach ( function ( msg ) { if ( msg . fix ) { try { msg . fix = mergeFixes ( msg . fix , sourceCode ) ; } catch ( e ) { throw new Error ( "An error occured while applying fix of rule \"" + \" + msg . ruleName + "\" for error \"" + \" + \" ) ; } msg . message } "\": " } ) ; \" e . message return fixes . push ( msg ) ; remainingMessages . push ( msg ) ; }
821	function inspectTopLevelDeclaration ( emitted ) { let body = emitted . node . body || [ ] , levelOneIndentRegExp = new RegExp ( "^\\n" + \\ + BASE_INDENTATION_STYLE ) , "$" , endingLineRegExp = new RegExp ( "^" + BASE_INDENTATION_STYLE + "(\\S| \\*)$" ) ; \\ \\ endingLineExtraIndentRegExp = new RegExp ( "^" + BASE_INDENTATION_STYLE . repeat ( 2 ) + "(\\S| \\*)$" ) }
822	function inspectBlockStatement ( emitted ) { let node = emitted . node ; if ( emitted . exit || ( sourceCode . getLine ( node ) === sourceCode . getEndingLine ( node ) ) ) { return ; } let parent = sourceCode . getParent ( node ) , parentDeclarationLine = sourceCode . getLine ( parent ) , parentDeclarationLineText = sourceCode . getTextOnLine ( parentDeclarationLine ) , currentIndent , currentIndentLevel ; function inspectBlockItem ( blockIndent , blockIndentDesc , blockItem ) { let prevChars = sourceCode . getPrevChars ( blockItem , blockIndent . length + 1 ) , endingLineNum = sourceCode . getEndingLine ( blockItem ) , endingLineRegExp = new RegExp ( "^" + blockIndent + "(" + BASE_INDENTATION_STYLE + ")?\\S.*$" ) ; \\ if ( prevChars !== ( "\n" + \n ) ) blockIndent } { context . report ( { node : blockItem , message : ` ${ blockIndentDesc } ` } ) ; } if ( blockItem . type !== "IfStatement" && sourceCode . getLine ( blockItem ) !== endingLineNum && ! endingLineRegExp . test ( sourceCode . getTextOnLine ( endingLineNum ) ) ) { context . report ( { node : blockItem , location : { line : endingLineNum , column : 0 } , message : ` ${ blockIndentDesc } ` } ) ; } currentIndent = parentDeclarationLineText . slice ( 0 , parentDeclarationLineText . indexOf ( parentDeclarationLineText . trim ( ) ) ) ; currentIndentLevel = ( currentIndent . match ( BASE_INDENTATION_STYLE_REGEXP_GLOBAL ) || [ ] ) . length ; if ( getIndentString ( BASE_INDENTATION_STYLE , currentIndentLevel ) !== currentIndent ) { return ; } const blockIndent = getIndentString ( BASE_INDENTATION_STYLE , currentIndentLevel + 1 ) ; }
823	function ( node , beforeCount , afterCount ) { let sourceCodeText = this . text ; if ( node ) { if ( astUtils . isASTNode ( node ) ) { return this . text . slice ( Math . max ( 0 , node . start - ( Math . abs ( beforeCount ) || 0 ) ) , node . end + ( Math . abs ( afterCount ) || 0 ) ) ; } throw new Error ( "Invalid Node object" ) ; } return sourceCodeText ; }
824	function inspectVariableDeclaration ( emitted ) { let node = emitted . node , code = sourceCode . getText ( node ) ; if ( emitted . exit ) { return ; } for ( let i = 2 ; i < code . length ; i ++ ) { if ( code [ i ] === "=" ) { ( ! / ^[^\/\s] $ / . test ( code . slice ( i - 2 , i ) ) ) && context . report ( { node : node , message : "There should be only a single space between assignment operator '=' and its left side." } ) ; ( ! / ^ [^\/\s]$ / . test ( code . slice ( i + 1 , i + 3 ) ) ) && context . report ( { node : node , message : "There should be only a single space between assignment operator '=' and its right side." } ) ; } } }
825	function RuleContext ( ruleName , ruleDesc , ruleMeta , Solium ) { let contextObject = this ; ruleDesc . options && Object . assign ( contextObject , { options : ruleDesc . options } ) ; Object . defineProperties ( contextObject , { name : { value : ruleName , writable : false } , meta : { value : ruleDesc , writable : false } } ) ; INHERITABLE_METHODS . forEach ( function ( methodName ) { contextObject [ methodName ] = function ( s , z , a , b , o ) { return Solium [ methodName ] . call ( Solium , s , z , a , b , o ) ; } ; } ) ; contextObject . report = function ( error ) { if ( ! isErrObjectValid ( error ) ) { throw new Error ( ` ${ ruleName } ${ EOL } ${ util . inspect ( isErrObjectValid . errors ) } ` ) ; } Object . assign ( error , { ruleName : ruleName , ruleMeta : ruleMeta , type : contextObject . meta . type } ) ; Solium . report ( error ) ; } ; }
826	function resolveUpstream ( upstream ) { let coreRulesetRegExp = / ^solium:[a-z_]+$ / ; if ( coreRulesetRegExp . test ( upstream ) ) { try { return require ( "../../config/rulesets/solium-" + upstream . split ( ":" ) [ 1 ] ) . rules ; } catch ( e ) { throw new Error ( "\"" + \" + upstream ) ; } } "\" is not a core ruleset." \" let configName = constants . SOLIUM_SHARABLE_CONFIG_PREFIX + upstream , config ; try { config = require ( configName ) ; } catch ( e ) { if ( e . code === "MODULE_NOT_FOUND" ) { throw new Error ( "The sharable config \"" + \" + configName + "\" is not installed. " + \" + "If Solium is installed globally, install the config globally using " + "\"npm install -g " + \" + configName + "\". Else install locally using " ) ; } \" } }
827	function resolvePluginConfig ( name , plugin ) { let config = { } ; Object . keys ( plugin . rules ) . forEach ( function ( ruleName ) { config [ name + "/" + ruleName ] = plugin . rules [ ruleName ] . meta . docs . type ; } ) ; return config ; }
828	function writeConfigFile ( config ) { try { fs . writeFileSync ( SOLIUMRC_FILENAME_ABSOLUTE , JSON . stringify ( config , null , 2 ) ) ; } catch ( e ) { errorReporter . reportFatal ( ` ${ SOLIUMRC_FILENAME_ABSOLUTE } ${ EOL } ${ e . message } ` ) ; process . exit ( errorCodes . WRITE_FAILED ) ; } }
829	function lintString ( sourceCode , userConfig , errorReporter , fileName ) { let lintErrors , fixesApplied ; try { if ( userConfig . options . autofix || userConfig . options . autofixDryrun ) { let result = solium . lintAndFix ( sourceCode , userConfig ) ; lintErrors = result . errorMessages ; if ( userConfig . options . autofix ) { applyFixes ( fileName , result ) ; fixesApplied = result . fixesApplied ; } else { errorReporter . reportDiff ( fileName , sourceCode , result . fixedSourceCode , result . fixesApplied . length ) ; } } else { lintErrors = solium . lint ( sourceCode , userConfig ) ; } } catch ( e ) { if ( e . name !== "SyntaxError" ) { const messageOrStackrace = userConfig . options . debug ? e . stack : e . message ; errorReporter . reportFatal ( ` ${ fileName } ${ EOL } ${ messageOrStackrace } ` ) ; process . exit ( errorCodes . ERRORS_FOUND ) ; } lintErrors = [ { ruleName : "" , type : "error" , message : ` ${ e . found } ` , line : e . location . start . line , column : e . location . start . column } ] ; } lintErrors . length && errorReporter . report ( fileName , sourceCode , lintErrors , fixesApplied ) ; return lintErrors . reduce ( function ( numOfErrors , err ) { return err . type === "error" ? numOfErrors + 1 : numOfErrors ; } , 0 ) ; }
830	function lintFile ( fileName , userConfig , errorReporter ) { let sourceCode ; try { sourceCode = fs . readFileSync ( fileName , "utf8" ) ; } catch ( e ) { errorReporter . reportFatal ( "Unable to read " + fileName + ": " + e . message ) ; process . exit ( errorCodes . FILE_NOT_FOUND ) ; } return lintString ( sourceCode , userConfig , errorReporter , fileName ) ; }
831	function createCliOptions ( cliObject ) { function collect ( val , memo ) { memo . push ( val ) ; return memo ; } cliObject . version ( ` ${ version } ` ) . description ( "Linter to find & fix style and security issues in Solidity smart contracts." ) . usage ( "[options] <keyword>" ) . option ( "-i, --init" , "Create default rule configuration files" ) . option ( "-f, --file [filepath::String]" , "Solidity file to lint" ) . option ( "-d, --dir [dirpath::String]" , "Directory containing Solidity files to lint" ) . option ( "-R, --reporter [name::String]" , "Format to report lint issues in (pretty | gcc)" , "pretty" ) . option ( "-c, --config [filepath::String]" , "Path to the .soliumrc configuration file" ) . option ( "-, --stdin" , "Read input file from stdin" ) . option ( "--fix" , "Fix Lint issues where possible" ) . option ( "--fix-dry-run" , "Output fix diff without applying it" ) . option ( "--debug" , "Display debug information" ) . option ( "--watch" , "Watch for file changes" ) . option ( "--hot" , "(Deprecated) Same as --watch" ) . option ( "--no-soliumignore" , "Do not look for .soliumignore file" ) . option ( "--no-soliumrc" , "Do not look for soliumrc configuration file" ) . option ( "--rule [rule]" , "Rule to execute. This overrides the specified rule's configuration in soliumrc if present" , collect , [ ] ) . option ( "--plugin [plugin]" , "Plugin to execute. This overrides the specified plugin's configuration in soliumrc if present" , collect , [ ] ) ; }
832	function ( options , listItemsSchema ) { let validateOptionsList = SchemaValidator . compile ( { type : "array" , minItems : listItemsSchema . length , additionalItems : false , items : listItemsSchema } ) ; return validateOptionsList ( options ) ; }
833	function inspectFD ( emitted ) { const { node } = emitted , visibilityModifiers = [ "public" , "external" , "internal" , "private" ] ; const modifiers = ( node . modifiers || [ ] ) , firstVisibilityModifierIndex = modifiers . findIndex ( m => visibilityModifiers . includes ( m . name ) ) ; if ( emitted . exit || firstVisibilityModifierIndex === - 1 ) { return ; } const firstNonVisModifBeforeFirstVisModif = modifiers . slice ( 0 , firstVisibilityModifierIndex ) . find ( m => ! visibilityModifiers . includes ( m . name ) ) ; if ( firstNonVisModifBeforeFirstVisModif ) { const issue = { node : modifiers [ firstVisibilityModifierIndex ] , message : ` ${ modifiers [ firstVisibilityModifierIndex ] . name } ` } ; context . report ( issue ) ; } }
834	function isHex ( literal ) { let reg = / ^[0-9a-f]+$ / i ; if ( literal . slice ( 0 , 2 ) !== "0x" ) { return false ; } return reg . test ( literal . slice ( 2 ) ) ; }
835	function Soundfont ( ctx , nameToUrl ) { console . warn ( 'new Soundfont() is deprected' ) console . log ( 'Please use Soundfont.instrument() instead of new Soundfont().instrument()' ) if ( ! ( this instanceof Soundfont ) ) return new Soundfont ( ctx ) this . nameToUrl = nameToUrl || Soundfont . nameToUrl this . ctx = ctx this . instruments = { } this . promises = [ ] }
836	function oscillatorPlayer ( ctx , defaultOptions ) { defaultOptions = defaultOptions || { } return function ( note , time , duration , options ) { console . warn ( 'The oscillator player is deprecated.' ) console . log ( 'Starting with version 0.9.0 you will have to wait until the soundfont is loaded to play sounds.' ) var midi = note > 0 && note < 129 ? + note : parser . midi ( note ) var freq = midi ? parser . midiToFreq ( midi , 440 ) : null if ( ! freq ) return duration = duration || 0.2 options = options || { } var destination = options . destination || defaultOptions . destination || ctx . destination var vcoType = options . vcoType || defaultOptions . vcoType || 'sine' var gain = options . gain || defaultOptions . gain || 0.4 var vco = ctx . createOscillator ( ) vco . type = vcoType vco . frequency . value = freq var vca = ctx . createGain ( ) vca . gain . value = gain vco . connect ( vca ) vca . connect ( destination ) vco . start ( time ) if ( duration > 0 ) vco . stop ( time + duration ) return vco } }
837	function instrument ( ac , name , options ) { if ( arguments . length === 1 ) return function ( n , o ) { return instrument ( ac , n , o ) } var opts = options || { } var isUrl = opts . isSoundfontURL || isSoundfontURL var toUrl = opts . nameToUrl || nameToUrl var url = isUrl ( name ) ? name : toUrl ( name , opts . soundfont , opts . format ) return load ( ac , url , { only : opts . only || opts . notes } ) . then ( function ( buffers ) { var p = player ( ac , buffers , opts ) . connect ( opts . destination ? opts . destination : ac . destination ) p . url = url p . name = name return p } ) }
838	function hasSystemLib ( lib ) { var libName = 'lib' + lib + '.+(so|dylib)' var libNameRegex = new RegExp ( libName ) if ( hasLdconfig ( ) ) { try { if ( childProcess . execSync ( 'ldconfig -p 2>/dev/null | grep -E "' + libName + '"' ) . length ) { return true } } catch ( err ) { } } return SYSTEM_PATHS . some ( function ( systemPath ) { try { var dirListing = fs . readdirSync ( systemPath ) return dirListing . some ( function ( file ) { return libNameRegex . test ( file ) } ) } catch ( err ) { return false } } ) }
839	async function thenify ( fn ) { return await new Promise ( function ( resolve , reject ) { function callback ( err , res ) { if ( err ) return reject ( err ) ; return resolve ( res ) ; } fn ( callback ) ; } ) ; }
840	function startWatching ( opts ) { var chokidarOpts = createChokidarOpts ( opts ) ; var watcher = chokidar . watch ( opts . patterns , chokidarOpts ) ; var throttledRun = _ . throttle ( run , opts . throttle ) ; var debouncedRun = _ . debounce ( throttledRun , opts . debounce ) ; watcher . on ( 'all' , function ( event , path ) { var description = EVENT_DESCRIPTIONS [ event ] + ':' ; if ( opts . verbose ) { console . error ( description , path ) ; } else { if ( ! opts . silent ) { console . log ( event + ':' + path ) ; } } if ( opts . command ) { debouncedRun ( opts . command . replace ( / \{path\} / ig , path ) . replace ( / \{event\} / ig , event ) ) ; } } ) ; watcher . on ( 'error' , function ( error ) { console . error ( 'Error:' , error ) ; console . error ( error . stack ) ; } ) ; watcher . once ( 'ready' , function ( ) { var list = opts . patterns . join ( '", "' ) ; if ( ! opts . silent ) { console . error ( 'Watching' , '"' + list + '" ..' ) ; } } ) ; }
841	function _resolveIgnoreOpt ( ignoreOpt ) { if ( ! ignoreOpt ) { return ignoreOpt ; } var ignores = ! _ . isArray ( ignoreOpt ) ? [ ignoreOpt ] : ignoreOpt ; return _ . map ( ignores , function ( ignore ) { var isRegex = ignore [ 0 ] === '/' && ignore [ ignore . length - 1 ] === '/' ; if ( isRegex ) { var match = ignore . match ( new RegExp ( '^/(.*)/(.*?)$' ) ) ; return new RegExp ( match [ 1 ] , match [ 2 ] ) ; } return ignore ; } ) ; }
842	function requireProp ( props , propName , componentName ) { return isEmpty ( props [ propName ] ) ? new Error ( ` \` ${ propName } \` \` ${ componentName } \` ` ) : null }
843	function _0to1 ( props , propName , componentName ) { if ( isEmpty ( props [ propName ] ) ) { return null } if ( typeof props [ propName ] === 'number' && props [ propName ] >= 0 && props [ propName ] <= 1 ) { return null } return new Error ( ` \` ${ propName } \` \` ${ componentName } \` ` ) }
844	function babel ( options = { } ) { return ( context , { addLoader } ) => addLoader ( { test : / \.(js|jsx)$ / , use : [ { loader : 'thread-loader' , options : { ... ( process . env . NODE_ENV === 'development' && { poolTimeout : Infinity } ) , } , } , { loader : 'babel-loader' , options : Object . assign ( babelLoaderOptions , options ) , } , ] , ... context . match , } ) }
845	function imageLoader ( ) { return ( context , { addLoader } ) => addLoader ( { test : / \.(gif|ico|jpg|jpeg|png|webp)$ / , loader : 'url-loader' , options : { limit : 10000 , name : fileNameTemplate , } , } ) }
846	function csvLoader ( ) { return ( context , { addLoader } ) => addLoader ( { test : / \.csv$ / , loader : 'csv-loader' , options : { dynamicTyping : true , header : true , skipEmptyLines : true , } , } ) }
847	function cssSvgLoader ( ) { return ( context , { addLoader } ) => addLoader ( { test : / (.*)\.svg$ / , issuer : { test : / \.css$ / , } , loader : 'url-loader' , options : { limit : 10000 , name : fileNameTemplate , } , } ) }
848	function prependEntry ( entry ) { const blockFunction = ( context , util ) => { if ( ! context . entriesToPrepend ) context . entriesToPrepend = [ ] context . entriesToPrepend . unshift ( entry ) return config => config } return Object . assign ( blockFunction , { post : prependEntryPostHook , } ) }
849	function build ( ) { log . info ( ` ` ) const compiler = createWebpackCompiler ( ( ) => { log . ok ( ` ${ chalk . cyan ( relativeAppBuildPath ) } ` ) } , ( ) => { log . err ( ` ` ) process . exit ( 2 ) } ) return new Promise ( ( resolve , reject ) => { compiler . run ( ( err , stats ) => { if ( err ) { return reject ( err ) } return resolve ( stats ) } ) } ) }
850	function mergeData ( to , from ) { if ( ! from ) { return to } var key , toVal , fromVal ; var keys = Object . keys ( from ) ; for ( var i = 0 ; i < keys . length ; i ++ ) { key = keys [ i ] ; toVal = to [ key ] ; fromVal = from [ key ] ; if ( ! hasOwn ( to , key ) ) { set ( to , key , fromVal ) ; } else if ( toVal !== fromVal && isPlainObject ( toVal ) && isPlainObject ( fromVal ) ) { mergeData ( toVal , fromVal ) ; } } return to }
851	function withDefault ( type ) { return Object . defineProperty ( type , 'def' , { value : function value ( def ) { if ( def === undefined && ! this . default ) { return this ; } if ( ! isFunction ( def ) && ! validateType ( this , def ) ) { warn ( this . _vueTypes_name + " - invalid default value: \"" + \" + def , "\"" ) ; \" } def return this ; } , if ( isArray ( def ) ) { this . default = function ( ) { return [ ] . concat ( def ) ; } ; } else if ( isPlainObject_1 ( def ) ) { this . default = function ( ) { return Object . assign ( { } , def ) ; } ; } else { this . default = def ; } , return this ; } ) ; }
852	function withValidate ( type ) { return Object . defineProperty ( type , 'validate' , { value : function value ( fn ) { this . validator = fn . bind ( this ) ; return this ; } , enumerable : false } ) ; }
853	function toType ( name , obj , validateFn ) { if ( validateFn === void 0 ) { validateFn = false ; } Object . defineProperty ( obj , '_vueTypes_name' , { enumerable : false , writable : false , value : name } ) ; withDefault ( withRequired ( obj ) ) ; if ( validateFn ) { withValidate ( obj ) ; } if ( isFunction ( obj . validator ) ) { obj . validator = obj . validator . bind ( obj ) ; } return obj ; }
854	function validateType ( type , value , silent ) { if ( silent === void 0 ) { silent = false ; } var typeToCheck = type ; var valid = true ; var expectedType ; if ( ! isPlainObject_1 ( type ) ) { typeToCheck = { type : type } ; } var namePrefix = typeToCheck . _vueTypes_name ? typeToCheck . _vueTypes_name + ' - ' : '' ; if ( hasOwn . call ( typeToCheck , 'type' ) && typeToCheck . type !== null ) { if ( isArray ( typeToCheck . type ) ) { valid = typeToCheck . type . some ( function ( type ) { return validateType ( type , value , true ) ; } ) ; expectedType = typeToCheck . type . map ( function ( type ) { return getType ( type ) ; } ) . join ( ' or ' ) ; } else { expectedType = getType ( typeToCheck ) ; if ( expectedType === 'Array' ) { valid = isArray ( value ) ; } else if ( expectedType === 'Object' ) { valid = isPlainObject_1 ( value ) ; } else if ( expectedType === 'String' || expectedType === 'Number' || expectedType === 'Boolean' || expectedType === 'Function' ) { valid = getNativeType ( value ) === expectedType ; } else { valid = value instanceof typeToCheck . type ; } } } if ( ! valid ) { silent === false && warn ( namePrefix + "value \"" + \" + value + "\" should be of type \"" + \" ) ; \" } expectedType "\"" }
855	function CustomEvent ( type , eventInitDict ) { var event = document . createEvent ( eventName ) ; if ( typeof type != 'string' ) { throw new Error ( 'An event name must be provided' ) ; } if ( eventName == 'Event' ) { event . initCustomEvent = initCustomEvent ; } if ( eventInitDict == null ) { eventInitDict = defaultInitDict ; } event . initCustomEvent ( type , eventInitDict . bubbles , eventInitDict . cancelable , eventInitDict . detail ) ; return event ; }
856	function initCustomEvent ( type , bubbles , cancelable , detail ) { this . initEvent ( type , bubbles , cancelable ) ; this . detail = detail ; }
857	function cleanUpRuntimeEvents ( ) { document . removeEventListener ( 'touchmove' , onMove , getPassiveSupported ( ) ? { passive : false } : false ) ; document . removeEventListener ( 'touchend' , onUp ) ; document . removeEventListener ( 'touchcancel' , stopTracking ) ; document . removeEventListener ( 'mousemove' , onMove , getPassiveSupported ( ) ? { passive : false } : false ) ; document . removeEventListener ( 'mouseup' , onUp ) ; }
858	function addRuntimeEvents ( ) { cleanUpRuntimeEvents ( ) ; document . addEventListener ( 'touchmove' , onMove , getPassiveSupported ( ) ? { passive : false } : false ) ; document . addEventListener ( 'touchend' , onUp ) ; document . addEventListener ( 'touchcancel' , stopTracking ) ; document . addEventListener ( 'mousemove' , onMove , getPassiveSupported ( ) ? { passive : false } : false ) ; document . addEventListener ( 'mouseup' , onUp ) ; }
859	function normalizeEvent ( ev ) { if ( ev . type === 'touchmove' || ev . type === 'touchstart' || ev . type === 'touchend' ) { var touch = ev . targetTouches [ 0 ] || ev . changedTouches [ 0 ] ; return { x : touch . clientX , y : touch . clientY , id : touch . identifier } ; } else { return { x : ev . clientX , y : ev . clientY , id : null } ; } }
860	function onDown ( ev ) { var event = normalizeEvent ( ev ) ; if ( ! pointerActive && ! paused ) { pointerActive = true ; decelerating = false ; pointerId = event . id ; pointerLastX = pointerCurrentX = event . x ; pointerLastY = pointerCurrentY = event . y ; trackingPoints = [ ] ; addTrackingPoint ( pointerLastX , pointerLastY ) ; addRuntimeEvents ( ) ; } }
861	function onMove ( ev ) { ev . preventDefault ( ) ; var event = normalizeEvent ( ev ) ; if ( pointerActive && event . id === pointerId ) { pointerCurrentX = event . x ; pointerCurrentY = event . y ; addTrackingPoint ( pointerLastX , pointerLastY ) ; requestTick ( ) ; } }
862	function addTrackingPoint ( x , y ) { var time = Date . now ( ) ; while ( trackingPoints . length > 0 ) { if ( time - trackingPoints [ 0 ] . time <= 100 ) { break ; } trackingPoints . shift ( ) ; } trackingPoints . push ( { x : x , y : y , time : time } ) ; }
863	function updateAndRender ( ) { var pointerChangeX = pointerCurrentX - pointerLastX ; var pointerChangeY = pointerCurrentY - pointerLastY ; targetX += pointerChangeX * multiplier ; targetY += pointerChangeY * multiplier ; if ( bounce ) { var diff = checkBounds ( ) ; if ( diff . x !== 0 ) { targetX -= pointerChangeX * dragOutOfBoundsMultiplier ( diff . x ) * multiplier ; } if ( diff . y !== 0 ) { targetY -= pointerChangeY * dragOutOfBoundsMultiplier ( diff . y ) * multiplier ; } } else { checkBounds ( true ) ; } callUpdateCallback ( ) ; pointerLastX = pointerCurrentX ; pointerLastY = pointerCurrentY ; ticking = false ; }
864	function startDecelAnim ( ) { var firstPoint = trackingPoints [ 0 ] ; var lastPoint = trackingPoints [ trackingPoints . length - 1 ] ; var xOffset = lastPoint . x - firstPoint . x ; var yOffset = lastPoint . y - firstPoint . y ; var timeOffset = lastPoint . time - firstPoint . time ; var D = timeOffset / 15 / multiplier ; decVelX = xOffset / D || 0 ; decVelY = yOffset / D || 0 ; var diff = checkBounds ( ) ; if ( Math . abs ( decVelX ) > 1 || Math . abs ( decVelY ) > 1 || ! diff . inBounds ) { decelerating = true ; requestAnimFrame ( stepDecelAnim ) ; } }
865	function stepDecelAnim ( ) { if ( ! decelerating ) { return ; } decVelX *= friction ; decVelY *= friction ; targetX += decVelX ; targetY += decVelY ; var diff = checkBounds ( ) ; if ( Math . abs ( decVelX ) > stopThreshold || Math . abs ( decVelY ) > stopThreshold || ! diff . inBounds ) { if ( bounce ) { var reboundAdjust = 2.5 ; if ( diff . x !== 0 ) { if ( diff . x * decVelX <= 0 ) { decVelX += diff . x * bounceDeceleration ; } else { var adjust = diff . x > 0 ? reboundAdjust : - reboundAdjust ; decVelX = ( diff . x + adjust ) * bounceAcceleration ; } } if ( diff . y !== 0 ) { if ( diff . y * decVelY <= 0 ) { decVelY += diff . y * bounceDeceleration ; } else { var adjust = diff . y > 0 ? reboundAdjust : - reboundAdjust ; decVelY = ( diff . y + adjust ) * bounceAcceleration ; } } } else { if ( diff . x !== 0 ) { if ( diff . x > 0 ) { targetX = boundXmin ; } else { targetX = boundXmax ; } decVelX = 0 ; } if ( diff . y !== 0 ) { if ( diff . y > 0 ) { targetY = boundYmin ; } else { targetY = boundYmax ; } decVelY = 0 ; } } callUpdateCallback ( ) ; requestAnimFrame ( stepDecelAnim ) ; } else { decelerating = false ; } }
866	function checkBounds ( restrict ) { var xDiff = 0 ; var yDiff = 0 ; if ( boundXmin !== undefined && targetX < boundXmin ) { xDiff = boundXmin - targetX ; } else if ( boundXmax !== undefined && targetX > boundXmax ) { xDiff = boundXmax - targetX ; } if ( boundYmin !== undefined && targetY < boundYmin ) { yDiff = boundYmin - targetY ; } else if ( boundYmax !== undefined && targetY > boundYmax ) { yDiff = boundYmax - targetY ; } if ( restrict ) { if ( xDiff !== 0 ) { targetX = ( xDiff > 0 ) ? boundXmin : boundXmax ; } if ( yDiff !== 0 ) { targetY = ( yDiff > 0 ) ? boundYmin : boundYmax ; } } return { x : xDiff , y : yDiff , inBounds : xDiff === 0 && yDiff === 0 } ; }
867	function initCompDirs ( ) { var compRoot = path . resolve ( process . cwd ( ) , 'src/components' ) , compReg = / ^[A-Z]\w+$ / ; compDirs = fs . readdirSync ( compRoot ) . filter ( function ( filename ) { return compReg . test ( filename ) } ) return compDirs }
868	function appendLogToFileStream ( fileName , newLog , headerLineCount ) { const filePath = path . join ( __dirname , '../../' , fileName ) const oldChangelog = grunt . file . read ( filePath ) . toString ( ) . split ( '\n' ) ; \n let wStr = fs . createWriteStream ( filePath ) let logHeader = oldChangelog . slice ( 0 , headerLineCount ) ; let prevLogs = oldChangelog . slice ( headerLineCount ) ; var s = new Readable ; s . pipe ( wStr ) ; s . push ( logHeader . join ( '\n' ) + \n ) ; '\n' \n s . push ( newLog ) ; }
869	function doSeek ( length , eocdrNotFoundCallback ) { reader . readUint8Array ( reader . size - length , length , function ( bytes ) { for ( var i = bytes . length - EOCDR_MIN ; i >= 0 ; i -- ) { if ( bytes [ i ] === 0x50 && bytes [ i + 1 ] === 0x4b && bytes [ i + 2 ] === 0x05 && bytes [ i + 3 ] === 0x06 ) { eocdrCallback ( new DataView ( bytes . buffer , i , EOCDR_MIN ) ) ; return ; } } eocdrNotFoundCallback ( ) ; } , function ( ) { onerror ( ERR_READ ) ; } ) ; }
870	function CronJob ( sandbox , job ) { assign ( this , job ) ; if ( job . token ) { this . claims = Decode ( job . token ) ; } else { this . claims = { jtn : job . name , ten : this . container , } ; } this . sandbox = sandbox ; Object . defineProperty ( this , 'url' , { enumerable : true , get : function ( ) { return this . sandbox . url + '/api/run/' + this . container + '/' + this . name ; } } ) ; }
871	function Sandbox ( options ) { var securityVersion = 'v1' ; this . url = options . url ; this . container = options . container ; this . token = options . token ; this . onBeforeRequest = [ ] . concat ( options . onBeforeRequest ) . filter ( hook => typeof hook === 'function' ) ; try { var typ = Decode ( options . token , { header : true } ) . typ ; if ( typ && typ . toLowerCase ( ) === 'jwt' ) { securityVersion = 'v2' ; } } catch ( _ ) { } this . securityVersion = securityVersion ; }
872	function Webtask ( sandbox , token , options ) { if ( ! options ) options = { } ; if ( sandbox . securityVersion === 'v1' ) { try { this . claims = Decode ( token ) ; this . token = token ; } catch ( _ ) { throw new Error ( 'token must be a valid JWT' ) ; } } if ( sandbox . securityVersion === 'v2' ) { if ( typeof options . name !== 'string' ) { throw new Error ( 'name must be a valid string' ) ; } this . claims = { jtn : options . name , ten : options . container || sandbox . container , } } this . sandbox = sandbox ; this . meta = options . meta || { } ; this . secrets = options . secrets ; this . code = options . code ; Object . defineProperty ( this , 'container' , { enumerable : true , get : function ( ) { return options . container || this . sandbox . container ; } } ) ; Object . defineProperty ( this , 'url' , { enumerable : true , get : function ( ) { var url = options . webtask_url ; if ( ! url ) { if ( this . claims . host ) { var surl = Url . parse ( this . sandbox . url ) ; url = surl . protocol + '//' + this . claims . host + ( surl . port ? ( ':' + surl . port ) : '' ) + '/' + this . sandbox . container ; } else { url = this . sandbox . url + '/api/run/' + this . sandbox . container ; } if ( this . claims . jtn ) url += '/' + this . claims . jtn ; else url += '?key=' + this . token ; } return url ; } } ) ; }
873	function wrappedPromise ( executor ) { if ( ! ( this instanceof wrappedPromise ) ) { return Promise ( executor ) ; } if ( typeof executor !== 'function' ) { return new Promise ( executor ) ; } var context , args ; var promise = new Promise ( wrappedExecutor ) ; promise . __proto__ = wrappedPromise . prototype ; try { executor . apply ( context , args ) ; } catch ( err ) { args [ 1 ] ( err ) ; } return promise ; function wrappedExecutor ( resolve , reject ) { context = this ; args = [ wrappedResolve , wrappedReject ] ; function wrappedResolve ( val ) { ensureAslWrapper ( promise , false ) ; return resolve ( val ) ; } function wrappedReject ( val ) { ensureAslWrapper ( promise , false ) ; return reject ( val ) ; } } }
874	function union ( dest , added ) { var destLength = dest . length ; var addedLength = added . length ; var returned = [ ] ; if ( destLength === 0 && addedLength === 0 ) return returned ; for ( var j = 0 ; j < destLength ; j ++ ) returned [ j ] = dest [ j ] ; if ( addedLength === 0 ) return returned ; for ( var i = 0 ; i < addedLength ; i ++ ) { var missing = true ; for ( j = 0 ; j < destLength ; j ++ ) { if ( dest [ j ] . uid === added [ i ] . uid ) { missing = false ; break ; } } if ( missing ) returned . push ( added [ i ] ) ; } return returned ; }
875	function simpleWrap ( original , list , length ) { inAsyncTick = true ; for ( var i = 0 ; i < length ; ++ i ) { var listener = list [ i ] ; if ( listener . create ) listener . create ( listener . data ) ; } inAsyncTick = false ; return function ( ) { listenerStack . push ( listeners ) ; listeners = union ( list , listeners ) ; var returned = original . apply ( this , arguments ) ; listeners = listenerStack . pop ( ) ; return returned ; } ; }
876	function wrapCallback ( original ) { var length = listeners . length ; if ( length === 0 ) return original ; var list = listeners . slice ( ) ; for ( var i = 0 ; i < length ; ++ i ) { if ( list [ i ] . flags > 0 ) return asyncWrap ( original , list , length ) ; } return simpleWrap ( original , list , length ) ; }
877	function ( dir , options , internal ) { options = options || largest . options ; return fs . readdirAsync ( dir ) . then ( function ( files ) { var paths = _ . map ( files , function ( file ) { return path . join ( dir , file ) ; } ) ; return Promise . all ( _ . map ( paths , function ( path ) { return fs . statAsync ( path ) ; } ) ) . then ( function ( stats ) { return [ paths , stats ] ; } ) ; } ) . spread ( function ( paths , stats ) { return Promise . all ( _ . map ( stats , function ( stat , i ) { if ( stat . isFile ( ) ) return Promise . resolve ( { path : paths [ i ] , size : stat . size , searched : 1 } ) ; return options . recurse ? largest ( paths [ i ] , options , true ) : Promise . resolve ( null ) ; } ) ) ; } ) . then ( function ( candidates ) { return _ ( candidates ) . compact ( ) . reduce ( function ( best , cand ) { if ( cand . size > best . size ) var temp = cand , cand = best , best = temp ; best . searched += cand . searched ; return best ; } ) ; } ) . then ( function ( result ) { if ( result && options . preview && ! internal ) { var fd_ ; return fs . openAsync ( result . path , 'r' ) . then ( function ( fd ) { fd_ = fd ; var buffer = new Buffer ( 40 ) ; return fs . readAsync ( fd , buffer , 0 , 40 , 0 ) ; } ) . spread ( function ( bytesRead , buffer ) { result . preview = buffer . toString ( 'utf-8' , 0 , bytesRead ) ; return fs . closeAsync ( fd_ ) ; } ) . then ( function ( ) { return result ; } ) ; } else { return result ; } } ) ; }
878	function makeAsyncFunc ( config ) { config . validate ( ) ; var result = function async ( bodyFunc ) { var semaphore = config . maxConcurrency ? new Semaphore ( config . maxConcurrency ) : Semaphore . unlimited ; var makeFunc = config . isIterable ? makeAsyncIterator : makeAsyncNonIterator ; var result = makeFunc ( bodyFunc , config , semaphore ) ; var arity = bodyFunc . length ; if ( config . acceptsCallback ) ++ arity ; result = makeFuncWithArity ( result , arity ) ; return result ; } ; result . mod = makeModFunc ( config ) ; return result ; }
879	function makeAsyncIterator ( bodyFunc , config , semaphore ) { return function iterable ( ) { var startupArgs = new Array ( arguments . length + 1 ) ; for ( var i = 0 , len = arguments . length ; i < len ; ++ i ) startupArgs [ i + 1 ] = arguments [ i ] ; var yield_ = function ( expr ) { if ( ! Fiber . current ) { throw new Error ( 'await functions, yield functions, and value-returning suspendable ' + 'functions may only be called from inside a suspendable function. ' ) ; } if ( runContext . callback ) runContext . callback ( null , { value : expr , done : false } ) ; if ( runContext . resolver ) runContext . resolver . resolve ( { value : expr , done : false } ) ; Fiber . yield ( ) ; } ; startupArgs [ 0 ] = yield_ ; var runContext = new RunContext ( bodyFunc , this , startupArgs ) ; var iterator = new AsyncIterator ( runContext , semaphore , config . returnValue , config . acceptsCallback ) ; runContext . wrapped = function ( ) { var len = arguments . length , args = new Array ( len ) ; for ( var i = 0 ; i < len ; ++ i ) args [ i ] = arguments [ i ] ; bodyFunc . apply ( this , args ) ; iterator . destroy ( ) ; return { done : true } ; } ; return iterator ; } ; }
880	function makeAsyncNonIterator ( bodyFunc , config , semaphore ) { return function nonIterable ( ) { var argsAsArray = new Array ( arguments . length ) ; for ( var i = 0 ; i < argsAsArray . length ; ++ i ) argsAsArray [ i ] = arguments [ i ] ; if ( FiberMgr . isExecutingInFiber ( ) ) this . _semaphore = Semaphore . unlimited ; var runContext = new RunContext ( bodyFunc , this , argsAsArray , function ( ) { return semaphore . leave ( ) ; } ) ; if ( config . returnValue !== Config . NONE ) { var resolver = defer ( ) ; runContext . resolver = resolver ; } if ( config . acceptsCallback && argsAsArray . length && _ . isFunction ( argsAsArray [ argsAsArray . length - 1 ] ) ) { var callback = argsAsArray . pop ( ) ; runContext . callback = callback ; } if ( config . returnValue === Config . THUNK ) { var thunk = function ( done ) { if ( done ) resolver . promise . then ( function ( val ) { return done ( null , val ) ; } , function ( err ) { return done ( err ) ; } ) ; semaphore . enter ( function ( ) { return FiberMgr . create ( ) . run ( runContext ) ; } ) ; } ; } else { semaphore . enter ( function ( ) { return FiberMgr . create ( ) . run ( runContext ) ; } ) ; } switch ( config . returnValue ) { case Config . PROMISE : return resolver . promise ; case Config . THUNK : return thunk ; case Config . RESULT : return await ( resolver . promise ) ; case Config . NONE : return ; } } ; }
881	function traverseClone ( o , visitor ) { var result ; if ( _ . isArray ( o ) ) { var len = o . length ; result = new Array ( len ) ; for ( var i = 0 ; i < len ; ++ i ) { result [ i ] = traverseClone ( o [ i ] , visitor ) ; visitor ( result , i ) ; } } else if ( _ . isPlainObject ( o ) ) { result = { } ; for ( var key in o ) { if ( o . hasOwnProperty ( key ) ) { result [ key ] = traverseClone ( o [ key ] , visitor ) ; visitor ( result , key ) ; } } } else { result = o ; } return result ; }
882	function thunkToPromise ( thunk ) { return new Promise ( function ( resolve , reject ) { var callback = function ( err , val ) { return ( err ? reject ( err ) : resolve ( val ) ) ; } ; thunk ( callback ) ; } ) ; }
883	function ( dir ) { var files = fs . readdirSync ( dir ) ; var paths = _ . map ( files , function ( file ) { return path . join ( dir , file ) ; } ) ; var stats = _ . map ( paths , function ( path ) { return fs . statSync ( path ) ; } ) ; return _ . filter ( stats , function ( stat ) { return stat . isFile ( ) ; } ) . length ; }
884	async function scopedCopyIndex ( client , sourceIndex , targetIndex ) { const { taskID } = await client . copyIndex ( sourceIndex . indexName , targetIndex . indexName , [ 'settings' , 'synonyms' , 'rules' ] ) ; return targetIndex . waitTask ( taskID ) ; }
885	async function moveIndex ( client , sourceIndex , targetIndex ) { const { taskID } = await client . moveIndex ( sourceIndex . indexName , targetIndex . indexName ) ; return targetIndex . waitTask ( taskID ) ; }
886	async function indexExists ( index ) { try { const { nbHits } = await index . search ( ) ; return nbHits > 0 ; } catch ( e ) { return false ; } }
887	function loadModule ( moduleName ) { var module = modules [ moduleName ] ; if ( module !== undefined ) { return module ; } switch ( moduleName ) { case 'charset' : module = require ( './lib/charset' ) ; break ; case 'encoding' : module = require ( './lib/encoding' ) ; break ; case 'language' : module = require ( './lib/language' ) ; break ; case 'mediaType' : module = require ( './lib/mediaType' ) ; break ; default : throw new Error ( 'Cannot find module \'' + \' + moduleName ) ; } '\'' \' }
888	function parseAcceptLanguage ( accept ) { var accepts = accept . split ( ',' ) ; for ( var i = 0 , j = 0 ; i < accepts . length ; i ++ ) { var language = parseLanguage ( accepts [ i ] . trim ( ) , i ) ; if ( language ) { accepts [ j ++ ] = language ; } } accepts . length = j ; return accepts ; }
889	function parseLanguage ( str , i ) { var match = simpleLanguageRegExp . exec ( str ) ; if ( ! match ) return null ; var prefix = match [ 1 ] , suffix = match [ 2 ] , full = prefix ; if ( suffix ) full += "-" + suffix ; var q = 1 ; if ( match [ 3 ] ) { var params = match [ 3 ] . split ( ';' ) for ( var j = 0 ; j < params . length ; j ++ ) { var p = params [ j ] . split ( '=' ) ; if ( p [ 0 ] === 'q' ) q = parseFloat ( p [ 1 ] ) ; } } return { prefix : prefix , suffix : suffix , q : q , i : i , full : full } ; }
890	function getLanguagePriority ( language , accepted , index ) { var priority = { o : - 1 , q : 0 , s : 0 } ; for ( var i = 0 ; i < accepted . length ; i ++ ) { var spec = specify ( language , accepted [ i ] , index ) ; if ( spec && ( priority . s - spec . s || priority . q - spec . q || priority . o - spec . o ) < 0 ) { priority = spec ; } } return priority ; }
891	function specify ( language , spec , index ) { var p = parseLanguage ( language ) if ( ! p ) return null ; var s = 0 ; if ( spec . full . toLowerCase ( ) === p . full . toLowerCase ( ) ) { s |= 4 ; } else if ( spec . prefix . toLowerCase ( ) === p . full . toLowerCase ( ) ) { s |= 2 ; } else if ( spec . full . toLowerCase ( ) === p . prefix . toLowerCase ( ) ) { s |= 1 ; } else if ( spec . full !== '*' ) { return null } return { i : index , o : spec . i , q : spec . q , s : s } }
892	function preferredLanguages ( accept , provided ) { var accepts = parseAcceptLanguage ( accept === undefined ? '*' : accept || '' ) ; if ( ! provided ) { return accepts . filter ( isQuality ) . sort ( compareSpecs ) . map ( getFullLanguage ) ; } var priorities = provided . map ( function getPriority ( type , index ) { return getLanguagePriority ( type , accepts , index ) ; } ) ; return priorities . filter ( isQuality ) . sort ( compareSpecs ) . map ( function getLanguage ( priority ) { return provided [ priorities . indexOf ( priority ) ] ; } ) ; }
893	function compareSpecs ( a , b ) { return ( b . q - a . q ) || ( b . s - a . s ) || ( a . o - b . o ) || ( a . i - b . i ) || 0 ; }
894	function parseAcceptCharset ( accept ) { var accepts = accept . split ( ',' ) ; for ( var i = 0 , j = 0 ; i < accepts . length ; i ++ ) { var charset = parseCharset ( accepts [ i ] . trim ( ) , i ) ; if ( charset ) { accepts [ j ++ ] = charset ; } } accepts . length = j ; return accepts ; }
895	function parseCharset ( str , i ) { var match = simpleCharsetRegExp . exec ( str ) ; if ( ! match ) return null ; var charset = match [ 1 ] ; var q = 1 ; if ( match [ 2 ] ) { var params = match [ 2 ] . split ( ';' ) for ( var j = 0 ; j < params . length ; j ++ ) { var p = params [ j ] . trim ( ) . split ( '=' ) ; if ( p [ 0 ] === 'q' ) { q = parseFloat ( p [ 1 ] ) ; break ; } } } return { charset : charset , q : q , i : i } ; }
896	function getCharsetPriority ( charset , accepted , index ) { var priority = { o : - 1 , q : 0 , s : 0 } ; for ( var i = 0 ; i < accepted . length ; i ++ ) { var spec = specify ( charset , accepted [ i ] , index ) ; if ( spec && ( priority . s - spec . s || priority . q - spec . q || priority . o - spec . o ) < 0 ) { priority = spec ; } } return priority ; }
897	function specify ( charset , spec , index ) { var s = 0 ; if ( spec . charset . toLowerCase ( ) === charset . toLowerCase ( ) ) { s |= 1 ; } else if ( spec . charset !== '*' ) { return null } return { i : index , o : spec . i , q : spec . q , s : s } }
898	function preferredCharsets ( accept , provided ) { var accepts = parseAcceptCharset ( accept === undefined ? '*' : accept || '' ) ; if ( ! provided ) { return accepts . filter ( isQuality ) . sort ( compareSpecs ) . map ( getFullCharset ) ; } var priorities = provided . map ( function getPriority ( type , index ) { return getCharsetPriority ( type , accepts , index ) ; } ) ; return priorities . filter ( isQuality ) . sort ( compareSpecs ) . map ( function getCharset ( priority ) { return provided [ priorities . indexOf ( priority ) ] ; } ) ; }
899	function parseEncoding ( str , i ) { var match = simpleEncodingRegExp . exec ( str ) ; if ( ! match ) return null ; var encoding = match [ 1 ] ; var q = 1 ; if ( match [ 2 ] ) { var params = match [ 2 ] . split ( ';' ) ; for ( var j = 0 ; j < params . length ; j ++ ) { var p = params [ j ] . trim ( ) . split ( '=' ) ; if ( p [ 0 ] === 'q' ) { q = parseFloat ( p [ 1 ] ) ; break ; } } } return { encoding : encoding , q : q , i : i } ; }
900	function getEncodingPriority ( encoding , accepted , index ) { var priority = { o : - 1 , q : 0 , s : 0 } ; for ( var i = 0 ; i < accepted . length ; i ++ ) { var spec = specify ( encoding , accepted [ i ] , index ) ; if ( spec && ( priority . s - spec . s || priority . q - spec . q || priority . o - spec . o ) < 0 ) { priority = spec ; } } return priority ; }
901	function preferredEncodings ( accept , provided ) { var accepts = parseAcceptEncoding ( accept || '' ) ; if ( ! provided ) { return accepts . filter ( isQuality ) . sort ( compareSpecs ) . map ( getFullEncoding ) ; } var priorities = provided . map ( function getPriority ( type , index ) { return getEncodingPriority ( type , accepts , index ) ; } ) ; return priorities . filter ( isQuality ) . sort ( compareSpecs ) . map ( function getEncoding ( priority ) { return provided [ priorities . indexOf ( priority ) ] ; } ) ; }
902	function parseAccept ( accept ) { var accepts = splitMediaTypes ( accept ) ; for ( var i = 0 , j = 0 ; i < accepts . length ; i ++ ) { var mediaType = parseMediaType ( accepts [ i ] . trim ( ) , i ) ; if ( mediaType ) { accepts [ j ++ ] = mediaType ; } } accepts . length = j ; return accepts ; }
903	function parseMediaType ( str , i ) { var match = simpleMediaTypeRegExp . exec ( str ) ; if ( ! match ) return null ; var params = Object . create ( null ) ; var q = 1 ; var subtype = match [ 2 ] ; var type = match [ 1 ] ; if ( match [ 3 ] ) { var kvps = splitParameters ( match [ 3 ] ) . map ( splitKeyValuePair ) ; for ( var j = 0 ; j < kvps . length ; j ++ ) { var pair = kvps [ j ] ; var key = pair [ 0 ] . toLowerCase ( ) ; var val = pair [ 1 ] ; var value = val && val [ 0 ] === '"' && val [ val . length - 1 ] === '"' ? val . substr ( 1 , val . length - 2 ) : val ; if ( key === 'q' ) { q = parseFloat ( value ) ; break ; } params [ key ] = value ; } } return { type : type , subtype : subtype , params : params , q : q , i : i } ; }
904	function getMediaTypePriority ( type , accepted , index ) { var priority = { o : - 1 , q : 0 , s : 0 } ; for ( var i = 0 ; i < accepted . length ; i ++ ) { var spec = specify ( type , accepted [ i ] , index ) ; if ( spec && ( priority . s - spec . s || priority . q - spec . q || priority . o - spec . o ) < 0 ) { priority = spec ; } } return priority ; }
905	function specify ( type , spec , index ) { var p = parseMediaType ( type ) ; var s = 0 ; if ( ! p ) { return null ; } if ( spec . type . toLowerCase ( ) == p . type . toLowerCase ( ) ) { s |= 4 } else if ( spec . type != '*' ) { return null ; } if ( spec . subtype . toLowerCase ( ) == p . subtype . toLowerCase ( ) ) { s |= 2 } else if ( spec . subtype != '*' ) { return null ; } var keys = Object . keys ( spec . params ) ; if ( keys . length > 0 ) { if ( keys . every ( function ( k ) { return spec . params [ k ] == '*' || ( spec . params [ k ] || '' ) . toLowerCase ( ) == ( p . params [ k ] || '' ) . toLowerCase ( ) ; } ) ) { s |= 1 } else { return null } } return { i : index , o : spec . i , q : spec . q , s : s , } }
906	function preferredMediaTypes ( accept , provided ) { var accepts = parseAccept ( accept === undefined ? '*/*' : accept || '' ) ; if ( ! provided ) { return accepts . filter ( isQuality ) . sort ( compareSpecs ) . map ( getFullType ) ; } var priorities = provided . map ( function getPriority ( type , index ) { return getMediaTypePriority ( type , accepts , index ) ; } ) ; return priorities . filter ( isQuality ) . sort ( compareSpecs ) . map ( function getType ( priority ) { return provided [ priorities . indexOf ( priority ) ] ; } ) ; }
907	function quoteCount ( string ) { var count = 0 ; var index = 0 ; while ( ( index = string . indexOf ( '"' , index ) ) !== - 1 ) { count ++ ; index ++ ; } return count ; }
908	function splitKeyValuePair ( str ) { var index = str . indexOf ( '=' ) ; var key ; var val ; if ( index === - 1 ) { key = str ; } else { key = str . substr ( 0 , index ) ; val = str . substr ( index + 1 ) ; } return [ key , val ] ; }
909	function splitMediaTypes ( accept ) { var accepts = accept . split ( ',' ) ; for ( var i = 1 , j = 0 ; i < accepts . length ; i ++ ) { if ( quoteCount ( accepts [ j ] ) % 2 == 0 ) { accepts [ ++ j ] = accepts [ i ] ; } else { accepts [ j ] += ',' + accepts [ i ] ; } } accepts . length = j + 1 ; return accepts ; }
910	function splitParameters ( str ) { var parameters = str . split ( ';' ) ; for ( var i = 1 , j = 0 ; i < parameters . length ; i ++ ) { if ( quoteCount ( parameters [ j ] ) % 2 == 0 ) { parameters [ ++ j ] = parameters [ i ] ; } else { parameters [ j ] += ';' + parameters [ i ] ; } } parameters . length = j + 1 ; for ( var i = 0 ; i < parameters . length ; i ++ ) { parameters [ i ] = parameters [ i ] . trim ( ) ; } return parameters ; }
911	function loadWebpackConfig ( ) { var webpackConfig = require ( './webpack.config.js' ) ; webpackConfig . devtool = 'inline-source-map' ; webpackConfig . module . preLoaders = [ { test : / \.jsx?$ / , include : path . resolve ( 'lib' ) , loader : 'isparta' } ] ; return webpackConfig ; }
912	function assign ( obj , keyPath , value ) { const lastKeyIndex = keyPath . length - 1 for ( let i = 0 ; i < lastKeyIndex ; ++ i ) { const key = keyPath [ i ] if ( ! ( key in obj ) ) obj [ key ] = { } obj = obj [ key ] } obj [ keyPath [ lastKeyIndex ] ] = value }
913	function getFilterString ( selectedValues ) { if ( selectedValues && Object . keys ( selectedValues ) . length ) { return Object . entries ( selectedValues ) . filter ( ( [ , componentValues ] ) => filterComponents . includes ( componentValues . componentType ) && ( ( componentValues . value && componentValues . value . length ) || componentValues . value . start || componentValues . value . end ) ) . map ( ( [ componentId , componentValues ] ) => parseFilterValue ( componentId , componentValues ) ) . join ( ) ; } return null ; }
914	function evaluatePage ( page , fn ) { var args = Array . prototype . slice . call ( arguments , 2 ) ; return this . ready . then ( function ( ) { var stack ; page = page || this . page ; var res = HorsemanPromise . fromCallback ( function ( done ) { stack = HorsemanPromise . reject ( new Error ( 'See next line' ) ) ; return page . evaluate ( function evaluatePage ( fnstr , args ) { try { var fn ; eval ( 'fn = ' + fnstr ) ; var res = fn . apply ( this , args ) ; return { res : res } ; } catch ( err ) { return { err : err , iserr : err instanceof Error } ; } } , fn . toString ( ) , args , done ) ; } ) . then ( function handleErrback ( args ) { return stack . catch ( function ( err ) { if ( args . err ) { if ( args . iserr ) { var stack = err . stack . split ( '\n' ) . \n slice ; ( 1 ) } args . err . stack += '\n' + \n ; } stack . join ( '\n' ) } ) ; } ) ; \n return HorsemanPromise . reject ( args . err ) ; } ) ; }
915	function waitForPage ( page , optsOrFn ) { var self = this ; var args , value , fname , timeout = self . options . timeout , fn ; if ( typeof optsOrFn === "function" ) { fn = optsOrFn ; args = Array . prototype . slice . call ( arguments ) ; value = args . pop ( ) ; fname = fn . name || '<anonymous>' ; } else if ( typeof optsOrFn === "object" ) { fn = optsOrFn . fn ; args = [ page , fn ] . concat ( optsOrFn . args || [ ] ) ; value = optsOrFn . value ; fname = fn . name || '<anonymous>' ; if ( optsOrFn . timeout ) { timeout = optsOrFn . timeout ; } } debug . apply ( debug , [ '.waitFor()' , fname ] . concat ( args . slice ( 2 ) ) ) ; return this . ready . then ( function ( ) { return new HorsemanPromise ( function ( resolve , reject ) { var start = Date . now ( ) ; var checkInterval = setInterval ( function waitForCheck ( ) { var _page = page || self . page ; var diff = Date . now ( ) - start ; if ( diff > timeout ) { clearInterval ( checkInterval ) ; debug ( '.waitFor() timed out' ) ; if ( typeof _page . onTimeout === 'function' ) { _page . onTimeout ( 'waitFor' ) ; } reject ( new TimeoutError ( 'timeout during .waitFor() after ' + diff + ' ms' ) ) ; } else { return evaluatePage . apply ( self , args ) . tap ( function ( res ) { debugv ( '.waitFor() iteration' , fname , res , diff , self . id ) ; } ) . then ( function ( res ) { if ( res === value ) { debug ( '.waitFor() completed successfully' ) ; clearInterval ( checkInterval ) ; resolve ( ) ; } } ) . catch ( function ( err ) { clearInterval ( checkInterval ) ; reject ( err ) ; } ) ; } } , self . options . interval ) ; } ) ; } ) ; }
916	function Horseman ( options ) { this . ready = false ; if ( ! ( this instanceof Horseman ) ) { return new Horseman ( options ) ; } this . options = defaults ( clone ( options ) || { } , DEFAULTS ) ; this . id = ++ instanceId ; debug ( '.setup() creating phantom instance %s' , this . id ) ; var phantomOptions = { 'load-images' : this . options . loadImages , 'ssl-protocol' : this . options . sslProtocol } ; if ( typeof this . options . ignoreSSLErrors !== 'undefined' ) { phantomOptions [ 'ignore-ssl-errors' ] = this . options . ignoreSSLErrors ; } if ( typeof this . options . webSecurity !== 'undefined' ) { phantomOptions [ 'web-security' ] = this . options . webSecurity ; } if ( typeof this . options . proxy !== 'undefined' ) { phantomOptions . proxy = this . options . proxy ; } if ( typeof this . options . proxyType !== 'undefined' ) { phantomOptions [ 'proxy-type' ] = this . options . proxyType ; } if ( typeof this . options . proxyAuth !== 'undefined' ) { phantomOptions [ 'proxy-auth' ] = this . options . proxyAuth ; } if ( typeof this . options . diskCache !== 'undefined' ) { phantomOptions [ 'disk-cache' ] = this . options . diskCache ; } if ( typeof this . options . diskCachePath !== 'undefined' ) { phantomOptions [ 'disk-cache-path' ] = this . options . diskCachePath ; } if ( typeof this . options . cookiesFile !== 'undefined' ) { phantomOptions [ 'cookies-file' ] = this . options . cookiesFile ; } if ( this . options . debugPort ) { phantomOptions [ 'remote-debugger-port' ] = this . options . debugPort ; phantomOptions [ 'remote-debugger-autorun' ] = 'no' ; if ( this . options . debugAutorun !== false ) { phantomOptions [ 'remote-debugger-autorun' ] = 'yes' ; } } Object . keys ( this . options . phantomOptions || { } ) . forEach ( function ( key ) { if ( typeof phantomOptions [ key ] !== 'undefined' ) { debug ( 'Horseman option ' + key + ' overridden by phantomOptions' ) ; } phantomOptions [ key ] = this . options . phantomOptions [ key ] ; } . bind ( this ) ) ; var instantiationOptions = { parameters : phantomOptions } ; if ( typeof this . options . phantomPath !== 'undefined' ) { instantiationOptions [ 'path' ] = this . options . phantomPath ; } this . targetUrl = null ; this . responses = { } ; this . tabs = [ ] ; this . onTabCreated = noop ; this . onTabClosed = noop ; this . ready = prepare ( this , instantiationOptions ) ; }
917	function getColors ( image , cb ) { var data = [ ] ; var img = createImage ( image ) ; var promise = new Promise ( function ( resolve ) { img . onload = function ( ) { var canvas = document . createElement ( 'canvas' ) ; canvas . width = img . width ; canvas . height = img . height ; canvas . getContext ( '2d' ) . drawImage ( img , 0 , 0 , img . width , img . height ) ; var ctx = canvas . getContext ( '2d' ) ; var imageData = ctx . getImageData ( 0 , 0 , img . width , 1 ) . data ; for ( var i = 0 ; i < img . width ; i ++ ) { data . push ( [ imageData [ i * 4 ] / 255 , imageData [ i * 4 + 1 ] / 255 , imageData [ i * 4 + 2 ] / 255 ] ) ; } resolve ( data ) ; } ; } ) ; return promise ; }
918	function createCubehelix ( steps , opts ) { var data = [ ] ; for ( var i = 0 ; i < steps ; i ++ ) { data . push ( cubehelix . rgb ( i / steps , opts ) . map ( ( v ) => v / 255 ) ) ; } return data ; }
919	function toImageData ( colors ) { return colors . map ( ( color ) => color . map ( ( v ) => v * 255 ) . concat ( 255 ) ) . reduce ( ( prev , curr ) => prev . concat ( curr ) ) ; }
920	function compress ( colors , factor ) { var data = [ ] ; var len = ( colors . length ) / factor ; var step = ( colors . length - 1 ) / len ; for ( var i = 0 ; i < colors . length ; i += step ) { data . push ( colors [ i | 0 ] ) ; } return data ; }
921	function toColormap ( data ) { var stops = [ ] ; for ( var i = 0 ; i < data . length ; i ++ ) { stops . push ( { index : Math . round ( i * 100 / ( data . length - 1 ) ) / 100 , rgb : data [ i ] . map ( ( v ) => Math . round ( v * 255 ) ) } ) ; } return stops ; }
922	function startDownload ( src , storageFile ) { var uri = Windows . Foundation . Uri ( src ) ; var downloader = new Windows . Networking . BackgroundTransfer . BackgroundDownloader ( ) ; var download = downloader . createDownload ( uri , storageFile ) ; return download . startAsync ( ) ; }
923	function ( options ) { this . _handlers = { 'progress' : [ ] , 'cancel' : [ ] , 'error' : [ ] , 'complete' : [ ] } ; if ( typeof options === 'undefined' ) { throw new Error ( 'The options argument is required.' ) ; } if ( typeof options . src === 'undefined' && options . type !== "local" ) { throw new Error ( 'The options.src argument is required for merge replace types.' ) ; } if ( typeof options . id === 'undefined' ) { throw new Error ( 'The options.id argument is required.' ) ; } if ( typeof options . type === 'undefined' ) { options . type = 'replace' ; } if ( typeof options . headers === 'undefined' ) { options . headers = null ; } if ( typeof options . copyCordovaAssets === 'undefined' ) { options . copyCordovaAssets = false ; } if ( typeof options . copyRootApp === 'undefined' ) { options . copyRootApp = false ; } if ( typeof options . timeout === 'undefined' ) { options . timeout = 15.0 ; } if ( typeof options . trustHost === 'undefined' ) { options . trustHost = false ; } if ( typeof options . manifest === 'undefined' ) { options . manifest = "" ; } if ( typeof options . validateSrc === 'undefined' ) { options . validateSrc = true ; } this . options = options ; var that = this ; var success = function ( result ) { if ( result && typeof result . progress !== 'undefined' ) { that . emit ( 'progress' , result ) ; } else if ( result && typeof result . localPath !== 'undefined' ) { that . emit ( 'complete' , result ) ; } } ; var fail = function ( msg ) { var e = ( typeof msg === 'string' ) ? new Error ( msg ) : msg ; that . emit ( 'error' , e ) ; } ; setTimeout ( function ( ) { exec ( success , fail , 'Sync' , 'sync' , [ options . src , options . id , options . type , options . headers , options . copyCordovaAssets , options . copyRootApp , options . timeout , options . trustHost , options . manifest , options . validateSrc ] ) ; } , 10 ) ; }
924	function createAppChannel ( app , key ) { assert ( ~ [ 'consumerChannel' , 'publisherChannel' ] . indexOf ( key ) , 'Channel key must be "consumerChannel" or "publisherChannel"' ) assert ( app . connection , 'Cannot create a channel without a connection' ) assert ( ! app [ key ] , 'Channel "' + key + '" already exists' ) return co ( function * ( ) { const channel = app [ key ] = yield app . connection . createChannel ( ) channel . __coworkersCloseHandler = module . exports . closeHandler . bind ( null , app , key ) channel . __coworkersErrorHandler = module . exports . errorHandler . bind ( null , app , key ) channel . once ( 'close' , channel . __coworkersCloseHandler ) channel . once ( 'error' , channel . __coworkersErrorHandler ) app . emit ( 'channel:create' , channel ) if ( key === 'consumerChannel' ) { if ( app . prefetchOpts ) { channel . prefetch ( app . prefetchOpts . count , app . prefetchOpts . global ) } wrap ( channel , [ 'ack' , 'nack' ] , function ( fn , args ) { const message = args [ 0 ] assert ( ! message . messageAcked , 'Messages cannot be acked/nacked more than once (will close channel)' ) const ret = fn . apply ( this , args ) message . messageAcked = true return ret } ) } return channel } ) }
925	function errorHandler ( app , key , err ) { delete app [ key ] const msg = ` ${ key } ${ err . message } ` debug ( msg , err ) err . message = msg throw err }
926	function createAppConnection ( app , url , socketOptions ) { assert ( ! app . connection , 'Cannot create connection if it already exists' ) return co ( function * ( ) { const conn = app . connection = yield amqplib . connect ( url , socketOptions ) conn . __coworkersCloseHandler = module . exports . closeHandler . bind ( null , app ) conn . __coworkersErrorHandler = module . exports . errorHandler . bind ( null , app ) conn . once ( 'close' , conn . __coworkersCloseHandler ) conn . once ( 'error' , conn . __coworkersErrorHandler ) app . emit ( 'connection:create' , conn ) return conn } ) }
927	function errorHandler ( app , err ) { delete app . connection const msg = ` ${ err . message } ` debug ( msg , err ) err . message = msg throw err }
928	function Application ( options ) { if ( ! ( this instanceof Application ) ) return new Application ( options ) EventEmitter . call ( this ) const env = getEnv ( ) const COWORKERS_CLUSTER = env . COWORKERS_CLUSTER const COWORKERS_QUEUE = env . COWORKERS_QUEUE const COWORKERS_QUEUE_WORKER_NUM = env . COWORKERS_QUEUE_WORKER_NUM || 1 options = options || { } if ( options . constructor . name === 'Schema' ) { options = { schema : options } } defaults ( options , { cluster : COWORKERS_CLUSTER , queueName : COWORKERS_QUEUE , queueWorkerNum : COWORKERS_QUEUE_WORKER_NUM } ) defaults ( options , { cluster : true } ) this . schema = options . schema this . queueName = options . queueName this . queueWorkerNum = options . queueWorkerNum if ( options . cluster && cluster . isMaster ) { this . clusterManager = new ClusterManager ( this ) if ( exists ( options . queueName ) ) { console . warn ( 'warn: "queueName" is not required when clustering is enabled' ) } } else { assert ( exists ( options . queueName ) , '"queueName" is required for consumer processes' ) } this . context = { } this . middlewares = [ ] this . queueMiddlewares = { } Object . defineProperty ( this , 'queueNames' , { get ( ) { return Object . keys ( this . queueMiddlewares ) } } ) }
929	function assertAndConsumeAppQueue ( app , queueName ) { return co ( function * ( ) { const queue = app . queueMiddlewares [ queueName ] const queueOpts = queue . queueOpts const consumeOpts = queue . consumeOpts const handler = app . messageHandler ( queueName ) yield app . consumerChannel . assertQueue ( queueName , queueOpts ) return yield app . consumerChannel . consume ( queueName , handler , consumeOpts ) } ) }
930	function parseShardFun ( str ) { str = str . trim ( ) if ( str . length === 0 ) { throw new Error ( 'empty shard string' ) } if ( ! str . startsWith ( PREFIX ) ) { throw new Error ( ` ${ str } ` ) } const parts = str . slice ( PREFIX . length ) . split ( '/' ) const version = parts [ 0 ] if ( version !== 'v1' ) { throw new Error ( ` ${ version } ` ) } const name = parts [ 1 ] if ( ! parts [ 2 ] ) { throw new Error ( 'missing param' ) } const param = parseInt ( parts [ 2 ] , 10 ) switch ( name ) { case 'prefix' : return new Prefix ( param ) case 'suffix' : return new Suffix ( param ) case 'next-to-last' : return new NextToLast ( param ) default : throw new Error ( ` ${ name } ` ) } }
931	function isEqualNode ( a , b ) { return ( ( isIgnored ( a ) && isIgnored ( b ) ) || ( getCheckSum ( a ) === getCheckSum ( b ) ) || a . isEqualNode ( b ) ) }
932	function dispatch ( node , type ) { if ( getKey ( node ) ) { var ev = document . createEvent ( 'Event' ) var prop = { value : node } ev . initEvent ( type , false , false ) Object . defineProperty ( ev , 'target' , prop ) Object . defineProperty ( ev , 'srcElement' , prop ) node . dispatchEvent ( ev ) } var child = node . firstChild while ( child ) child = dispatch ( child , type ) . nextSibling return node }
933	function join ( socket , multiaddr , pub , cb ) { const log = socket . log = config . log . bind ( config . log , '[' + socket . id + ']' ) if ( getConfig ( ) . strictMultiaddr && ! util . validateMa ( multiaddr ) ) { joinsTotal . inc ( ) joinsFailureTotal . inc ( ) return cb ( 'Invalid multiaddr' ) } if ( getConfig ( ) . cryptoChallenge ) { if ( ! pub . length ) { joinsTotal . inc ( ) joinsFailureTotal . inc ( ) return cb ( 'Crypto Challenge required but no Id provided' ) } if ( ! nonces [ socket . id ] ) { nonces [ socket . id ] = { } } if ( nonces [ socket . id ] [ multiaddr ] ) { log ( 'response cryptoChallenge' , multiaddr ) nonces [ socket . id ] [ multiaddr ] . key . verify ( Buffer . from ( nonces [ socket . id ] [ multiaddr ] . nonce ) , Buffer . from ( pub , 'hex' ) , ( err , ok ) => { if ( err || ! ok ) { joinsTotal . inc ( ) joinsFailureTotal . inc ( ) } if ( err ) { return cb ( 'Crypto error' ) } if ( ! ok ) { return cb ( 'Signature Invalid' ) } joinFinalize ( socket , multiaddr , cb ) } ) } else { joinsTotal . inc ( ) const addr = multiaddr . split ( 'ipfs/' ) . pop ( ) log ( 'do cryptoChallenge' , multiaddr , addr ) util . getIdAndValidate ( pub , addr , ( err , key ) => { if ( err ) { joinsFailureTotal . inc ( ) ; return cb ( err ) } const nonce = uuid ( ) + uuid ( ) socket . once ( 'disconnect' , ( ) => { delete nonces [ socket . id ] } ) nonces [ socket . id ] [ multiaddr ] = { nonce : nonce , key : key } cb ( null , nonce ) } ) } } else { joinsTotal . inc ( ) joinFinalize ( socket , multiaddr , cb ) } }
934	function dataType ( value ) { if ( ! value ) return null if ( value [ 'anyOf' ] || value [ 'allOf' ] || value [ 'oneOf' ] ) { return '' } if ( ! value . type ) { return 'object' } if ( value . type === 'array' ) { return dataType ( value . items || { } ) + '[]' } return value . type }
935	function pd ( event ) { const retv = privateData . get ( event ) ; console . assert ( retv != null , "'this' is expected an Event object, but got" , event ) ; return retv }
936	function defineRedirectDescriptor ( key ) { return { get ( ) { return pd ( this ) . event [ key ] } , set ( value ) { pd ( this ) . event [ key ] = value ; } , configurable : true , enumerable : true , } }
937	function defineCallDescriptor ( key ) { return { value ( ) { const event = pd ( this ) . event ; return event [ key ] . apply ( event , arguments ) } , configurable : true , enumerable : true , } }
938	function defineWrapper ( BaseEvent , proto ) { const keys = Object . keys ( proto ) ; if ( keys . length === 0 ) { return BaseEvent } function CustomEvent ( eventTarget , event ) { BaseEvent . call ( this , eventTarget , event ) ; } CustomEvent . prototype = Object . create ( BaseEvent . prototype , { constructor : { value : CustomEvent , configurable : true , writable : true } , } ) ; for ( let i = 0 ; i < keys . length ; ++ i ) { const key = keys [ i ] ; if ( ! ( key in BaseEvent . prototype ) ) { const descriptor = Object . getOwnPropertyDescriptor ( proto , key ) ; const isFunc = typeof descriptor . value === "function" ; Object . defineProperty ( CustomEvent . prototype , key , isFunc ? defineCallDescriptor ( key ) : defineRedirectDescriptor ( key ) ) ; } } return CustomEvent }
939	function getWrapper ( proto ) { if ( proto == null || proto === Object . prototype ) { return Event } let wrapper = wrappers . get ( proto ) ; if ( wrapper == null ) { wrapper = defineWrapper ( getWrapper ( Object . getPrototypeOf ( proto ) ) , proto ) ; wrappers . set ( proto , wrapper ) ; } return wrapper }
940	function wrapEvent ( eventTarget , event ) { const Wrapper = getWrapper ( Object . getPrototypeOf ( event ) ) ; return new Wrapper ( eventTarget , event ) }
941	function getListeners ( eventTarget ) { const listeners = listenersMap . get ( eventTarget ) ; if ( listeners == null ) { throw new TypeError ( "'this' is expected an EventTarget object, but got another value." ) } return listeners }
942	function defineEventAttributeDescriptor ( eventName ) { return { get ( ) { const listeners = getListeners ( this ) ; let node = listeners . get ( eventName ) ; while ( node != null ) { if ( node . listenerType === ATTRIBUTE ) { return node . listener } node = node . next ; } return null } , set ( listener ) { if ( typeof listener !== "function" && ! isObject ( listener ) ) { listener = null ; } const listeners = getListeners ( this ) ; let prev = null ; let node = listeners . get ( eventName ) ; while ( node != null ) { if ( node . listenerType === ATTRIBUTE ) { if ( prev !== null ) { prev . next = node . next ; } else if ( node . next !== null ) { listeners . set ( eventName , node . next ) ; } else { listeners . delete ( eventName ) ; } } else { prev = node ; } node = node . next ; } if ( listener !== null ) { const newNode = { listener , listenerType : ATTRIBUTE , passive : false , once : false , next : null , } ; if ( prev === null ) { listeners . set ( eventName , newNode ) ; } else { prev . next = newNode ; } } } , configurable : true , enumerable : true , } }
943	function defineCustomEventTarget ( eventNames ) { function CustomEventTarget ( ) { EventTarget . call ( this ) ; } CustomEventTarget . prototype = Object . create ( EventTarget . prototype , { constructor : { value : CustomEventTarget , configurable : true , writable : true , } , } ) ; for ( let i = 0 ; i < eventNames . length ; ++ i ) { defineEventAttribute ( CustomEventTarget . prototype , eventNames [ i ] ) ; } return CustomEventTarget }
944	function ( fileName , retrying ) { let file = assets [ fileName ] || { } ; let key = path . posix . join ( uploadPath , fileName ) ; let putPolicy = new qiniu . rs . PutPolicy ( { scope : bucket + ':' + key } ) ; let uploadToken = putPolicy . uploadToken ( mac ) ; let formUploader = new qiniu . form_up . FormUploader ( qiniuConfig ) ; let putExtra = new qiniu . form_up . PutExtra ( ) ; return new Promise ( ( resolve ) => { let begin = Date . now ( ) ; formUploader . putFile ( uploadToken , key , file . existsAt , putExtra , function ( err , body ) { if ( err ) { console . log ( ` ${ fileName } ${ err . message || err . name || err . stack } ` ) ; if ( ! ~ retryFiles . indexOf ( fileName ) ) retryFiles . push ( fileName ) ; } else { uploadedFiles ++ ; } spinner . text = tip ( uploadedFiles , retryFiles . length , totalFiles , retrying ) ; body . duration = Date . now ( ) - begin ; resolve ( body ) ; } ) ; } ) ; }
945	function ( err ) { if ( err ) { console . log ( '\n' ) ; \n } return Promise . reject ( err ) ; if ( retryFilesCountDown < 0 ) retryFilesCountDown = 0 ; let _files = retryFiles . splice ( 0 , batch <= retryFilesCountDown ? batch : retryFilesCountDown ) ; retryFilesCountDown = retryFilesCountDown - _files . length ; }
946	function ( ev ) { var nextPointers if ( ! ev . defaultPrevented ) { if ( _preventDefault ) { ev . preventDefault ( ) } if ( ! _mouseDown ) { _mouseDown = true nextPointers = utils . clone ( _currPointers ) nextPointers [ 'mouse' ] = [ ev . pageX , ev . pageY ] if ( ! _started ) { _started = true _handlers . start ( nextPointers ) } _currPointers = nextPointers } } }
947	function teamcity ( runner ) { Base . call ( this , runner ) ; var stats = this . stats ; var flowId = document . title || new Date ( ) . getTime ( ) ; runner . on ( 'suite' , function ( suite ) { if ( suite . root ) return ; suite . startDate = new Date ( ) ; log ( '##teamcity[testSuiteStarted name=\'' + \' + escape ( suite . title ) + '\' flowId=\'' + \' ) ; } ) ; \' flowId '\']' \' runner . on ( 'test' , function ( test ) { log ( '##teamcity[testStarted name=\'' + \' + escape ( test . title ) + '\' flowId=\'' + \' ) ; } ) ; \' }
948	function convert ( integer ) { var str = Number ( integer ) . toString ( 16 ) ; return str . length === 1 ? '0' + str : str ; }
949	function parse ( text , options ) { options = Object . assign ( { } , { relaxed : true } , options ) ; if ( typeof options . relaxed === 'boolean' ) options . strict = ! options . relaxed ; if ( typeof options . strict === 'boolean' ) options . relaxed = ! options . strict ; return JSON . parse ( text , ( key , value ) => deserializeValue ( this , key , value , options ) ) ; }
950	function stringify ( value , replacer , space , options ) { if ( space != null && typeof space === 'object' ) ( options = space ) , ( space = 0 ) ; if ( replacer != null && typeof replacer === 'object' ) ( options = replacer ) , ( replacer = null ) , ( space = 0 ) ; options = Object . assign ( { } , { relaxed : true } , options ) ; const doc = Array . isArray ( value ) ? serializeArray ( value , options ) : serializeDocument ( value , options ) ; return JSON . stringify ( doc , replacer , space ) ; }
951	function serialize ( bson , options ) { options = options || { } ; return JSON . parse ( stringify ( bson , options ) ) ; }
952	function makeDefineVirtualModule ( loader , load , addDep , args ) { function namer ( loadName ) { var baseName = loadName . substr ( 0 , loadName . indexOf ( "!" ) ) ; return function ( part , plugin ) { return baseName + "-" + part + ( plugin ? ( "." + plugin ) : "" ) ; } ; } function addresser ( loadAddress ) { return function ( part , plugin ) { var base = loadAddress + "." + part ; return base + ( plugin ? ( "." + plugin ) : "" ) ; } ; } var name = namer ( load . name ) ; var address = addresser ( load . address ) ; var disposeModule = function ( moduleName ) { if ( loader . has ( moduleName ) ) loader [ "delete" ] ( moduleName ) ; } ; if ( loader . liveReloadInstalled || loader . has ( "live-reload" ) ) { loader . import ( "live-reload" , { name : module . id } ) . then ( function ( reload ) { disposeModule = reload . disposeModule || disposeModule ; } ) ; } return function ( defn ) { if ( defn . condition ) { if ( defn . arg ) { args . push ( defn . arg ) ; } var moduleName = typeof defn . name === "function" ? defn . name ( name ) : name ( defn . name ) ; var moduleAddress = typeof defn . address === "function" ? defn . address ( address ) : address ( defn . address ) ; if ( defn . from ) { addDep ( defn . from , false ) ; } else if ( defn . getLoad ) { var moduleSource = defn . source ( ) ; return defn . getLoad ( moduleName ) . then ( function ( newLoad ) { moduleName = newLoad . name || moduleName ; disposeModule ( moduleName ) ; loader . define ( moduleName , moduleSource , { metadata : newLoad . metadata , address : moduleAddress } ) ; addDep ( moduleName ) ; } ) ; } else if ( defn . source ) { addDep ( moduleName ) ; if ( loader . has ( moduleName ) ) loader [ "delete" ] ( moduleName ) ; if ( typeof defn . source !== "string" ) { return Promise . resolve ( defn . source ) . then ( function ( source ) { loader . define ( moduleName , source , { address : address ( defn . name ) , metadata : defn . metadata } ) ; } ) ; } return loader . define ( moduleName , defn . source , { address : address ( defn . name ) } ) ; } } } }
953	function getFilename ( name ) { var hash = name . indexOf ( '#' ) ; var bang = name . indexOf ( '!' ) ; return name . slice ( hash < bang ? ( hash + 1 ) : 0 , bang ) ; }
954	function matchSemver ( myProtocol , senderProtocol , callback ) { const mps = myProtocol . split ( '/' ) const sps = senderProtocol . split ( '/' ) const myName = mps [ 1 ] const myVersion = mps [ 2 ] const senderName = sps [ 1 ] const senderVersion = sps [ 2 ] if ( myName !== senderName ) { return callback ( null , false ) } const valid = semver . satisfies ( myVersion , '~' + senderVersion ) callback ( null , valid ) }
955	function matchExact ( myProtocol , senderProtocol , callback ) { const result = myProtocol === senderProtocol callback ( null , result ) }
956	function diffArrays ( arr1 , arr2 ) { if ( ! Array . isArray ( arr1 ) || ! Array . isArray ( arr2 ) ) { return true ; } if ( arr1 . length !== arr2 . length ) { return true ; } for ( var i = 0 , len = arr1 . length ; i < len ; i ++ ) { if ( arr1 [ i ] !== arr2 [ i ] ) { return true ; } } return false ; }
957	function getSourceRuleString ( sourceRule ) { function getRuleString ( rule ) { if ( rule . length === 1 ) { return '"' + rule + '"' ; } return '("' + rule . join ( '" AND "' ) + '")' ; } return sourceRule . map ( getRuleString ) . join ( ' OR ' ) ; }
958	function getTimelineArgs ( scope ) { var timelineArgs = { sourceType : scope . sourceType } ; if ( rules . hasOwnProperty ( scope . sourceType ) ) { var sourceRules = rules [ scope . sourceType ] ; var valid = false ; for ( var i = 0 , len = sourceRules . length ; i < len ; i ++ ) { var rule = sourceRules [ i ] ; var params = { } ; for ( var j = 0 , ruleLen = rule . length ; j < ruleLen ; j ++ ) { if ( angular . isDefined ( scope [ rule [ j ] ] ) ) { params [ rule [ j ] ] = scope [ rule [ j ] ] ; } } if ( Object . keys ( params ) . length === ruleLen ) { angular . merge ( timelineArgs , params ) ; valid = true ; break ; } } if ( ! valid ) { throw new TimelineArgumentException ( scope . sourceType , 'args: ' + getSourceRuleString ( sourceRules ) ) ; } } else { throw new TimelineArgumentException ( scope . sourceType , 'unknown type' ) ; } return timelineArgs ; }
959	function ( method , klass ) { while ( ! ! klass ) { var key = null , pro = klass . prototype ; Object . keys ( pro ) . some ( function ( name ) { if ( method === pro [ name ] ) { key = name ; return ! 0 ; } } ) ; if ( key != null ) { return { name : key , klass : klass } ; } klass = klass . supor ; } }
960	function ( config ) { _logger . info ( 'begin dump files ...' ) ; var map = { } ; [ 'fileInclude' , 'fileExclude' ] . forEach ( function ( name ) { var value = config [ name ] ; if ( ! ! value ) { if ( typeof value === 'string' ) { var reg = new RegExp ( value , 'i' ) ; config [ name ] = function ( file ) { return reg . test ( file ) ; } ; } else if ( ! ! value . test ) { config [ name ] = function ( file ) { return value . test ( file ) ; } } } if ( ! _util . isFunction ( config [ name ] ) ) { var flag = name !== 'fileExclude' ; config [ name ] = function ( file ) { return flag ; } ; } } ) ; ( config . resRoot || '' ) . split ( ',' ) . forEach ( function ( dir ) { if ( ! dir ) { return ; } var ret = _fs . lsfile ( dir , function ( name , file ) { return ! config . fileExclude ( file ) && config . fileInclude ( file ) ; } ) ; ret . forEach ( function ( v ) { map [ v ] = v . replace ( config . webRoot , config . temp ) ; } ) ; } ) ; _logger . debug ( 'package file map -> %j' , map ) ; Object . keys ( map ) . forEach ( function ( src ) { var dst = map [ src ] ; _fs . copy ( src , dst , function ( a ) { _logger . info ( 'copy file %s' , a ) ; } ) ; } ) ; }
961	function ( config ) { _logger . info ( 'begin zip package ...' ) ; var cmd = [ 'java' , '-jar' , JSON . stringify ( config . zip ) , JSON . stringify ( config . temp ) , JSON . stringify ( config . output ) ] . join ( ' ' ) ; _logger . debug ( 'do command: %s' , cmd ) ; exec ( cmd , function ( error , stdout , stderr ) { if ( error ) { _logger . error ( 'zip package error for reason:\n%s' , \n ) ; error . stack process . abort ( ) ; } return ; if ( stdout ) { _logger . info ( stdout ) ; } if ( stderr ) { _logger . error ( stderr ) ; } } ) ; }
962	function ( config ) { if ( ! _fs . exist ( config . output ) ) { return abortProcess ( config , 'no package to be uploaded' ) ; } _logger . info ( 'begin build upload form ...' ) ; var form = new FormData ( ) ; var ex = _util . merge ( { version : '0.1' , platform : 'ios&android' } , config . extension ) ; Object . keys ( ex ) . forEach ( function ( name ) { form . append ( name , ex [ name ] ) ; } ) ; form . append ( 'token' , config . token ) ; form . append ( 'resID' , config . appid ) ; form . append ( 'appID' , config . nativeId ) ; form . append ( 'userData' , JSON . stringify ( { domains : config . domains } ) ) ; form . append ( 'zip' , fs . createReadStream ( config . output ) ) ; _logger . info ( 'begin upload package to web cache server ...' ) ; form . submit ( config . api , function ( err , res ) { if ( err ) { return abortProcess ( config , 'upload failed for reason:\n%s' , \n ) ; } err . stack var arr = [ ] ; res . on ( 'data' , function ( chunk ) { arr . push ( chunk ) ; } ) ; res . on ( 'end' , function ( ) { var ret = null , txt = arr . join ( '' ) ; try { ret = JSON . parse ( txt ) ; } catch ( ex ) { return abortProcess ( config , '[%s] %s\n%s' , \n , res . statusCode , txt ) ; } ex . stack } ) ; } ) ; }
963	function ( config ) { _logger . info ( 'clear temporary directory and files' ) ; _fs . rmdir ( config . temp ) ; _fs . rm ( config . output ) ; }
964	function ( config ) { var args = [ ] . slice . call ( arguments , 0 ) ; clearTemp ( args . shift ( ) ) ; _logger . error . apply ( _logger , args ) ; process . abort ( ) ; }
965	function ( content ) { var ret , handler = function ( map ) { ret = map ; } , sandbox = { NEJ : { deps : handler , config : handler } } ; try { vm . createContext ( sandbox ) ; vm . runInContext ( content , sandbox ) ; } catch ( ex ) { } return ret || null ; }
966	function ( patform , deps , func ) { var args = exports . formatARG . apply ( exports , arguments ) ; if ( ! this . patches ) { this . patches = [ ] ; } if ( ! args [ 0 ] ) { return ; } this . patches . push ( { expression : args [ 0 ] , dependency : args [ 1 ] , source : ( args [ 2 ] || '' ) . toString ( ) } ) ; }
967	function ( content ) { var ret = { } , sandbox = { NEJ : { patch : _doPatch . bind ( ret ) } } ; try { vm . createContext ( sandbox ) ; vm . runInContext ( util . format ( '(%s)();' , content ) , sandbox ) ; } catch ( ex ) { } return ret . patches ; }
968	function ( uri , deps , func ) { var args = exports . formatARG . apply ( exports , arguments ) ; this . isNEJ = ! 0 ; this . dependency = args [ 1 ] ; this . source = ( args [ 2 ] || '' ) . toString ( ) ; }
969	function ( event ) { if ( event . type == 'script' ) { event . value = this . _checkResInScript ( event . file , event . content , options ) ; } }
970	function ( uri , config ) { return this . _formatURI ( uri , { fromPage : config . fromPage , pathRoot : config . output , webRoot : config . webRoot } ) ; }
971	function ( uri , config ) { uri = uri . replace ( config . srcRoot , config . outHtmlRoot ) ; return this . _formatURI ( uri , { pathRoot : config . output , webRoot : config . webRoot , domain : config . mdlRoot } ) ; }
972	function ( uri , config ) { return uri . replace ( config . srcRoot , config . outHtmlRoot ) . replace ( config . webRoot , '/' ) ; }
973	function global ( map ) { Object . keys ( map ) . forEach ( function ( key ) { var file = map [ key ] , arr = file . split ( '#' ) , mdl = require ( './lib/' + arr [ 0 ] + '.js' ) ; if ( ! ! arr [ 1 ] ) { var brr = arr [ 1 ] . split ( ',' ) ; if ( brr . length > 1 ) { var ret = { } ; brr . forEach ( function ( name ) { ret [ name ] = mdl [ name ] ; } ) ; mdl = ret ; } else { mdl = mdl [ brr [ 0 ] ] ; } } exports [ key ] = mdl ; } ) ; }
974	function fmix32 ( hash ) { hash ^= hash >>> 16 hash = multiply ( hash , 0x85ebca6b ) hash ^= hash >>> 13 hash = multiply ( hash , 0xc2b2ae35 ) hash ^= hash >>> 16 return hash }
975	function fmix32_pure ( hash ) { hash = ( hash ^ ( hash >>> 16 ) ) >>> 0 hash = multiply ( hash , 0x85ebca6b ) hash = ( hash ^ ( hash >>> 13 ) ) >>> 0 hash = multiply ( hash , 0xc2b2ae35 ) hash = ( hash ^ ( hash >>> 16 ) ) >>> 0 return hash }
976	function bindKeys ( scope , obj , def , parentNode , path ) { var meta , key if ( typeof obj !== 'object' || obj === null ) throw new TypeError ( 'Invalid type of value "' + obj + '", object expected.' ) Object . defineProperty ( obj , memoizedObjectKey , { value : { } , configurable : true } ) Object . defineProperty ( obj , metaKey , { value : { } , configurable : true } ) meta = obj [ metaKey ] for ( key in def ) { meta [ key ] = { keyPath : { key : key , root : path . root , target : obj } , activeNodes : [ ] , previousValues : [ ] , currentMarker : def [ key ] [ markerKey ] , valueIsArray : null } bindKey ( scope , obj , def , key , parentNode ) } }
977	function parentSetter ( x ) { var previousValue = memoizedObject [ key ] var returnValue memoizedObject [ key ] = x if ( x === previousValue ) return x if ( definition && x !== null && x !== void 0 ) bindKeys ( scope , x , definition , parentNode , keyPath ) else if ( change ) { returnValue = change ( parentNode , x , previousValue === void 0 ? null : previousValue , keyPath ) if ( returnValue !== void 0 ) changeValue ( parentNode , returnValue , branch [ replaceAttributeKey ] ) } return x }
978	function replaceNode ( value , previousValue , i ) { var activeNode = activeNodes [ i ] var currentNode = node var returnValue if ( value === void 0 ) value = null if ( previousValue === void 0 ) previousValue = null if ( value === null ) { removeNode ( null , previousValue , i ) return null } if ( valueIsArray ) keyPath . index = i else delete keyPath . index previousValues [ i ] = value if ( definition ) { if ( activeNode ) removeNode ( value , previousValue , i ) currentNode = processNodes ( scope , node , definition ) keyPath . target = valueIsArray ? value [ i ] : value bindKeys ( scope , value , definition , currentNode , keyPath ) if ( mount ) { keyPath . target = value mount ( currentNode , value , null , keyPath ) } } else { currentNode = activeNode || node . cloneNode ( true ) if ( change ) { returnValue = change ( currentNode , value , previousValue , keyPath ) if ( returnValue !== void 0 ) changeValue ( currentNode , returnValue , branch [ replaceAttributeKey ] ) } else { if ( previousValue === null && ~ updateTags . indexOf ( currentNode . tagName ) ) currentNode . addEventListener ( 'input' , updateChange ( branch [ replaceAttributeKey ] , keyPath , key ) ) changeValue ( currentNode , value , branch [ replaceAttributeKey ] ) } if ( activeNode ) return null } activeNodes [ i ] = currentNode return currentNode }
979	function pop ( ) { var i = this . length - 1 var previousValue = previousValues [ i ] var value = Array . prototype . pop . call ( this ) removeNode ( null , previousValue , i ) previousValues . length = activeNodes . length = this . length return value }
980	function changeValue ( node , value , attribute ) { var firstChild switch ( attribute ) { case 'textContent' : firstChild = node . firstChild if ( firstChild && ! firstChild . nextSibling && firstChild . nodeType === TEXT_NODE ) firstChild . textContent = value else node . textContent = value break case 'checked' : node . checked = Boolean ( value ) break case 'value' : if ( node . value !== value ) node . value = value break default : break } }
981	function getNextNode ( index , activeNodes ) { var i , j , nextNode for ( i = index , j = activeNodes . length ; i < j ; i ++ ) if ( activeNodes [ i ] ) { nextNode = activeNodes [ i ] break } return nextNode }
982	function updateChange ( targetKey , path , key ) { var target = path . target var index = path . index var replaceKey = key if ( typeof index === 'number' ) { target = target [ key ] replaceKey = index } return function handleChange ( event ) { target [ replaceKey ] = event . target [ targetKey ] } }
983	function simulacra ( obj , def , matchNode ) { var document = this ? this . document : window . document var Node = this ? this . Node : window . Node var node , query featureCheck ( this || window , features ) if ( obj === null || typeof obj !== 'object' || isArray ( obj ) ) throw new TypeError ( 'First argument must be a singular object.' ) if ( ! isArray ( def ) ) throw new TypeError ( 'Second argument must be an array.' ) if ( typeof def [ 0 ] === 'string' ) { query = def [ 0 ] def [ 0 ] = document . querySelector ( query ) if ( ! def [ 0 ] ) throw new Error ( 'Top-level Node "' + query + '" could not be found in the document.' ) } else if ( ! ( def [ 0 ] instanceof Node ) ) throw new TypeError ( 'The first position of the top-level must be either a Node or a CSS ' + 'selector string.' ) if ( ! def [ isProcessedKey ] ) { if ( 'content' in def [ 0 ] ) def [ 0 ] = def [ 0 ] . content def [ 0 ] = def [ 0 ] . cloneNode ( true ) cleanNode ( this , def [ 0 ] ) ensureNodes ( def [ 0 ] , def [ 1 ] ) setProperties ( def ) } node = processNodes ( this , def [ 0 ] , def [ 1 ] ) bindKeys ( this , obj , def [ 1 ] , node , { root : obj } ) if ( matchNode ) { rehydrate ( this , obj , def [ 1 ] , node , matchNode ) return matchNode } return node }
984	function cleanNode ( scope , node ) { var showText = 0x00000004 var document = scope ? scope . document : window . document var treeWalker = document . createTreeWalker ( node , showText , processNodes . acceptNode , false ) var textNode while ( treeWalker . nextNode ( ) ) { textNode = treeWalker . currentNode textNode . textContent = textNode . textContent . trim ( ) } node . normalize ( ) }
985	function processNodes ( scope , node , def ) { var document = scope ? scope . document : window . document var key , branch , result , mirrorNode , parent , marker , indices var i , j , treeWalker , orderedKeys result = def [ templateKey ] if ( ! result ) { node = node . cloneNode ( true ) indices = [ ] matchNodes ( scope , node , def ) orderedKeys = Object . keys ( def ) . sort ( function ( a , b ) { var nodeA = def [ a ] [ 0 ] [ matchedNodeKey ] var nodeB = def [ b ] [ 0 ] [ matchedNodeKey ] if ( nodeA && nodeB ) return nodeA . index - nodeB . index return 0 } ) for ( i = 0 ; i < orderedKeys . length ; i ++ ) { key = orderedKeys [ i ] branch = def [ key ] if ( branch [ isBoundToParentKey ] ) continue result = branch [ 0 ] [ matchedNodeKey ] indices . push ( result . index ) mirrorNode = result . node parent = mirrorNode . parentNode if ( mirrorNode . nextElementSibling === null ) branch [ isMarkerLastKey ] = true if ( processNodes . useCommentNode ) { marker = parent . insertBefore ( document . createComment ( ' end "' + key + '" ' ) , mirrorNode ) parent . insertBefore ( document . createComment ( ' begin "' + key + '" ' ) , marker ) } else marker = parent . insertBefore ( document . createTextNode ( '' ) , mirrorNode ) branch [ markerKey ] = marker parent . removeChild ( mirrorNode ) } Object . defineProperty ( def , templateKey , { value : { node : node . cloneNode ( true ) , indices : indices } } ) } else { node = result . node . cloneNode ( true ) indices = result . indices i = 0 j = 0 treeWalker = document . createTreeWalker ( node , showAll , acceptNode , false ) for ( key in def ) { branch = def [ key ] if ( branch [ isBoundToParentKey ] ) continue while ( treeWalker . nextNode ( ) ) { if ( i === indices [ j ] ) { branch [ markerKey ] = treeWalker . currentNode i ++ break } i ++ } j ++ } } return node }
986	function matchNodes ( scope , node , def ) { var document = scope ? scope . document : window . document var treeWalker = document . createTreeWalker ( node , showAll , acceptNode , false ) var nodes = [ ] var i , j , key , currentNode , childWalker var nodeIndex = 0 var offset = processNodes . useCommentNode ? 1 : 0 for ( key in def ) nodes . push ( def [ key ] [ 0 ] ) while ( treeWalker . nextNode ( ) && nodes . length ) { for ( i = 0 , j = nodes . length ; i < j ; i ++ ) { currentNode = nodes [ i ] if ( treeWalker . currentNode . isEqualNode ( currentNode ) ) { Object . defineProperty ( currentNode , matchedNodeKey , { value : { index : nodeIndex + offset , node : treeWalker . currentNode } } ) if ( processNodes . useCommentNode ) offset ++ childWalker = document . createTreeWalker ( currentNode , showAll , acceptNode , false ) while ( childWalker . nextNode ( ) ) offset -- nodes . splice ( i , 1 ) break } } nodeIndex ++ } }
987	function rehydrate ( scope , obj , def , node , matchNode ) { var document = scope ? scope . document : window . document var key , branch , x , value , change , definition , mount , keyPath var meta , valueIsArray , activeNodes , index , treeWalker , currentNode for ( key in def ) { branch = def [ key ] meta = obj [ metaKey ] [ key ] change = ! branch [ hasDefinitionKey ] && branch [ 1 ] definition = branch [ hasDefinitionKey ] && branch [ 1 ] mount = branch [ 2 ] keyPath = meta . keyPath if ( branch [ isBoundToParentKey ] ) { x = obj [ key ] if ( definition && x !== null && x !== void 0 ) bindKeys ( scope , x , definition , matchNode , keyPath ) else if ( change ) change ( matchNode , x , null , keyPath ) continue } activeNodes = meta . activeNodes if ( ! activeNodes . length ) continue valueIsArray = meta . valueIsArray x = valueIsArray ? obj [ key ] : [ obj [ key ] ] index = 0 treeWalker = document . createTreeWalker ( matchNode , whatToShow , acceptNode , false ) while ( index < activeNodes . length && treeWalker . nextNode ( ) ) { currentNode = activeNodes [ index ] if ( treeWalker . currentNode . isEqualNode ( currentNode ) ) { activeNodes . splice ( index , 1 , treeWalker . currentNode ) value = x [ index ] if ( valueIsArray ) keyPath . index = index else delete keyPath . index if ( definition ) { rehydrate ( scope , value , definition , currentNode , treeWalker . currentNode ) if ( mount ) { keyPath . target = value mount ( treeWalker . currentNode , value , null , keyPath ) } } else if ( change ) change ( treeWalker . currentNode , value , null , keyPath ) index ++ } } if ( index !== activeNodes . length ) throw new Error ( 'Matching nodes could not be found on key "' + key + '", expected ' + activeNodes . length + ', found ' + index + '.' ) currentNode = treeWalker . currentNode if ( processNodes . useCommentNode && currentNode . nextSibling !== null && currentNode . nextSibling . nodeType === COMMENT_NODE ) branch [ markerKey ] = currentNode . nextSibling else branch [ markerKey ] = currentNode . parentNode . insertBefore ( document . createTextNode ( '' ) , currentNode . nextSibling ) } }
988	function render ( obj , def , html ) { var i , nodes , handler , parser , element , elementPrototype if ( Array . isArray ( def ) ) def = def [ 1 ] if ( renderFnKey in def ) return def [ renderFnKey ] ( obj ) handler = new htmlParser . DomHandler ( function ( error , result ) { if ( error ) throw error nodes = result } , handlerOptions ) parser = new htmlParser . Parser ( handler ) parser . write ( html ) parser . end ( ) for ( i = nodes . length ; i -- ; ) if ( nodes [ i ] . type === 'tag' ) { element = nodes [ i ] break } if ( ! element ) throw new Error ( 'No element found!' ) elementPrototype = Object . getPrototypeOf ( element ) Element . prototype = elementPrototype Object . defineProperties ( elementPrototype , elementExtension ) processDefinition ( def , nodes ) def [ renderFnKey ] = makeRender ( def , nodes ) return def [ renderFnKey ] ( obj ) }
989	function featureCheck ( globalScope , features ) { var i , j , k , l , feature , path for ( i = 0 , j = features . length ; i < j ; i ++ ) { path = features [ i ] if ( typeof path [ 0 ] === 'string' ) { feature = globalScope for ( k = 0 , l = path . length ; k < l ; k ++ ) { if ( ! ( path [ k ] in feature ) ) throw new Error ( 'Missing ' + path . slice ( 0 , k + 1 ) . join ( '.' ) + ' feature which is required.' ) feature = feature [ path [ k ] ] } } else { feature = path [ 0 ] for ( k = 1 , l = path . length ; k < l ; k ++ ) { if ( k > 1 ) feature = feature [ path [ k ] ] if ( typeof feature === 'undefined' ) throw new Error ( 'Missing ' + path [ 0 ] . name + path . slice ( 1 , k + 1 ) . join ( '.' ) + ' feature which is required.' ) } } } }
990	function bemNames ( entitys , delimiters ) { var resultString = '' ; var names = entitys || { mods : { } , mixin : '' } ; var delims = _extends ( { ns : '' , el : '__' , mod : '--' , modVal : '-' } , delimiters ) ; var mixin = isString ( names . mixin ) ? ' ' + names . mixin : '' ; if ( ! names . block ) return '' ; resultString = delims . ns ? delims . ns + names . block : names . block ; if ( names . el ) resultString += delims . el + names . el ; if ( isPObject ( names . mods ) ) { resultString += Object . keys ( names . mods ) . reduce ( function ( prev , name ) { var val = names . mods [ name ] ; if ( val === true ) { prev += ' ' + resultString + delims . mod + name ; } else if ( isString ( val ) || isNumber ( val ) ) { prev += ' ' + resultString + delims . mod + name + delims . modVal + names . mods [ name ] ; } return prev ; } , '' ) ; } return resultString + mixin ; }
991	function deepMergeConfigs ( configs , options ) { return merge . all ( configs . filter ( config => config ) , options ) ; }
992	async function loadYaml ( context , params ) { try { const response = await context . github . repos . getContents ( params ) ; return parseConfig ( response . data . content ) ; } catch ( e ) { if ( e . code === 404 ) { return null ; } throw e ; } }
993	function getBaseParams ( params , base ) { if ( typeof base !== 'string' ) { throw new Error ( ` ${ BASE_KEY } ` ) ; } const match = base . match ( BASE_REGEX ) ; if ( match == null ) { throw new Error ( ` ${ BASE_KEY } ${ base } ` ) ; } return { owner : match [ 1 ] || params . owner , repo : match [ 2 ] , path : match [ 3 ] || params . path , } ; }
994	async function getConfig ( context , fileName , defaultConfig , deepMergeOptions ) { const filePath = path . posix . join ( CONFIG_PATH , fileName ) ; const params = context . repo ( { path : filePath , } ) ; const config = await loadYaml ( context , params ) ; let baseRepo ; if ( config == null ) { baseRepo = DEFAULT_BASE ; } else if ( config != null && BASE_KEY in config ) { baseRepo = config [ BASE_KEY ] ; delete config [ BASE_KEY ] ; } let baseConfig ; if ( baseRepo ) { const baseParams = getBaseParams ( params , baseRepo ) ; baseConfig = await loadYaml ( context , baseParams ) ; } if ( config == null && baseConfig == null && ! defaultConfig ) { return null ; } return deepMergeConfigs ( [ defaultConfig , baseConfig , config ] , deepMergeOptions ) ; }
995	function defineProperty ( obj , name , value ) { var enumerable = ! ! obj [ name ] && obj . propertyIsEnumerable ( name ) Object . defineProperty ( obj , name , { configurable : true , enumerable : enumerable , writable : true , value : value } ) }
996	function shimmer ( options ) { if ( options && options . logger ) { if ( ! isFunction ( options . logger ) ) logger ( "new logger isn't a function, not replacing" ) else logger = options . logger } }
997	function injectManifest ( data ) { let manifestHtml = ` ${ hexo . config . pwa . manifest . path } ` ; if ( data . indexOf ( manifestHtml ) === - 1 ) { data = data . replace ( '<head>' , manifestHtml ) ; } return data ; }
998	function injectSWRegister ( data ) { let swHtml = ` ${ compiledSWRegTpl } ` ; if ( data . indexOf ( compiledSWRegTpl ) === - 1 ) { data = data . replace ( '</body>' , swHtml ) ; } return data ; }
999	function injectAsyncLoadPageJS ( data ) { let injectHtml = ` ${ asyncLoadPageJSTpl } ` ; if ( data . indexOf ( injectHtml ) === - 1 ) { data = data . replace ( '</head>' , injectHtml ) ; } return data ; }
1000	function rehype2react ( options ) { var settings = options || { } ; var createElement = settings . createElement ; var components = settings . components || { } ; this . Compiler = compiler ; function compiler ( node ) { if ( node . type === 'root' ) { if ( node . children . length === 1 && node . children [ 0 ] . type === 'element' ) { node = node . children [ 0 ] ; } else { node = { type : 'element' , tagName : 'div' , properties : node . properties || { } , children : node . children } ; } } return toH ( h , tableCellStyle ( node ) , settings . prefix ) ; } function h ( name , props , children ) { var component = has ( components , name ) ? components [ name ] : name ; return createElement ( component , props , children ) ; } }
1001	function doExec ( method , args ) { var cp ; var cpPromise = new ChildProcessPromise ( ) ; var reject = cpPromise . _cpReject ; var resolve = cpPromise . _cpResolve ; var finalArgs = slice . call ( args , 0 ) ; finalArgs . push ( callback ) ; cp = child_process [ method ] . apply ( child_process , finalArgs ) ; function callback ( err , stdout , stderr ) { if ( err ) { var commandStr = args [ 0 ] + ( Array . isArray ( args [ 1 ] ) ? ( ' ' + args [ 1 ] . join ( ' ' ) ) : '' ) ; err . message += ' `' + commandStr + '` (exited with error code ' + err . code + ')' ; err . stdout = stdout ; err . stderr = stderr ; var cpError = new ChildProcessError ( err . message , err . code , child_process , stdout , stderr ) ; reject ( cpError ) ; } else { resolve ( { childProcess : cp , stdout : stdout , stderr : stderr } ) ; } } cpPromise . childProcess = cp ; return cpPromise ; }
1002	function doSpawn ( method , command , args , options ) { var result = { } ; var cp ; var cpPromise = new ChildProcessPromise ( ) ; var reject = cpPromise . _cpReject ; var resolve = cpPromise . _cpResolve ; var successfulExitCodes = ( options && options . successfulExitCodes ) || [ 0 ] ; cp = method ( command , args , options ) ; var captureStdout = false ; var captureStderr = false ; var capture = options && options . capture ; if ( capture ) { for ( var i = 0 , len = capture . length ; i < len ; i ++ ) { var cur = capture [ i ] ; if ( cur === 'stdout' ) { captureStdout = true ; } else if ( cur === 'stderr' ) { captureStderr = true ; } } } result . childProcess = cp ; if ( captureStdout ) { result . stdout = '' ; cp . stdout . on ( 'data' , function ( data ) { result . stdout += data ; } ) ; } if ( captureStderr ) { result . stderr = '' ; cp . stderr . on ( 'data' , function ( data ) { result . stderr += data ; } ) ; } cp . on ( 'error' , reject ) ; cp . on ( 'close' , function ( code ) { if ( successfulExitCodes . indexOf ( code ) === - 1 ) { var commandStr = command + ( args . length ? ( ' ' + args . join ( ' ' ) ) : '' ) ; var message = '`' + commandStr + '` failed with code ' + code ; var err = new ChildProcessError ( message , code , cp ) ; if ( captureStderr ) { err . stderr = result . stderr . toString ( ) ; } if ( captureStdout ) { err . stdout = result . stdout . toString ( ) ; } reject ( err ) ; } else { result . code = code ; resolve ( result ) ; } } ) ; cpPromise . childProcess = cp ; return cpPromise ; }
1003	function slope2 ( that , t ) { var h = that . _x1 - that . _x0 ; return h ? ( 3 * ( that . _y1 - that . _y0 ) / h - t ) / 2 : t ; }
1004	function shouldSetAttribute ( name , value ) { if ( isReservedProp ( name ) ) { return false ; } if ( name . length > 2 && ( name [ 0 ] === 'o' || name [ 0 ] === 'O' ) && ( name [ 1 ] === 'n' || name [ 1 ] === 'N' ) ) { return false ; } if ( value === null ) { return true ; } switch ( typeof value ) { case 'boolean' : return shouldAttributeAcceptBooleanValue ( name ) ; case 'undefined' : case 'number' : case 'string' : case 'object' : return true ; default : return false ; } }
1005	function createMarkupForProperty ( name , value ) { var propertyInfo = getPropertyInfo ( name ) ; if ( propertyInfo ) { if ( shouldIgnoreValue ( propertyInfo , value ) ) { return '' ; } var attributeName = propertyInfo . attributeName ; if ( propertyInfo . hasBooleanValue || propertyInfo . hasOverloadedBooleanValue && value === true ) { return attributeName + '=""' ; } else if ( typeof value !== 'boolean' || shouldAttributeAcceptBooleanValue ( name ) ) { return attributeName + '=' + quoteAttributeValueForBrowser ( value ) ; } } else if ( shouldSetAttribute ( name , value ) ) { if ( value == null ) { return '' ; } return name + '=' + quoteAttributeValueForBrowser ( value ) ; } return null ; }
1006	function trapBubbledEvent ( topLevelType , handlerBaseName , element ) { if ( ! element ) { return null ; } return EventListener . listen ( element , handlerBaseName , dispatchEvent . bind ( null , topLevelType ) ) ; }
1007	function createUpdateQueue ( baseState ) { var queue = { baseState : baseState , expirationTime : NoWork , first : null , last : null , callbackList : null , hasForceUpdate : false , isInitialized : false } ; { queue . isProcessing = false ; } return queue ; }
1008	function mountClassInstance ( workInProgress , renderExpirationTime ) { var current = workInProgress . alternate ; { checkClassInstance ( workInProgress ) ; } var instance = workInProgress . stateNode ; var state = instance . state || null ; var props = workInProgress . pendingProps ; ! props ? invariant ( false , 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.' ) : void 0 ; var unmaskedContext = getUnmaskedContext ( workInProgress ) ; instance . props = props ; instance . state = workInProgress . memoizedState = state ; instance . refs = emptyObject ; instance . context = getMaskedContext ( workInProgress , unmaskedContext ) ; if ( enableAsyncSubtreeAPI && workInProgress . type != null && workInProgress . type . prototype != null && workInProgress . type . prototype . unstable_isAsyncReactComponent === true ) { workInProgress . internalContextTag |= AsyncUpdates ; } if ( typeof instance . componentWillMount === 'function' ) { callComponentWillMount ( workInProgress , instance ) ; var updateQueue = workInProgress . updateQueue ; if ( updateQueue !== null ) { instance . state = processUpdateQueue ( current , workInProgress , updateQueue , instance , props , renderExpirationTime ) ; } } if ( typeof instance . componentDidMount === 'function' ) { workInProgress . effectTag |= Update ; } }
1009	function requestWork ( root , expirationTime ) { if ( nestedUpdateCount > NESTED_UPDATE_LIMIT ) { invariant ( false , 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.' ) ; } if ( root . nextScheduledRoot === null ) { root . remainingExpirationTime = expirationTime ; if ( lastScheduledRoot === null ) { firstScheduledRoot = lastScheduledRoot = root ; root . nextScheduledRoot = root ; } else { lastScheduledRoot . nextScheduledRoot = root ; lastScheduledRoot = root ; lastScheduledRoot . nextScheduledRoot = firstScheduledRoot ; } } else { var remainingExpirationTime = root . remainingExpirationTime ; if ( remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime ) { root . remainingExpirationTime = expirationTime ; } } if ( isRendering ) { return ; } if ( isBatchingUpdates ) { if ( isUnbatchingUpdates ) { performWorkOnRoot ( root , Sync ) ; } return ; } if ( expirationTime === Sync ) { performWork ( Sync , null ) ; } else if ( ! isCallbackScheduled ) { isCallbackScheduled = true ; startRequestCallbackTimer ( ) ; scheduleDeferredCallback ( performAsyncWork ) ; } }
1010	function shouldYield ( ) { if ( deadline === null ) { return false ; } if ( deadline . timeRemaining ( ) > timeHeuristicForUnitOfWork ) { return false ; } deadlineDidExpire = true ; return true ; }
1011	function deleteValueForProperty ( node , name ) { var propertyInfo = getPropertyInfo ( name ) ; if ( propertyInfo ) { var mutationMethod = propertyInfo . mutationMethod ; if ( mutationMethod ) { mutationMethod ( node , undefined ) ; } else if ( propertyInfo . mustUseProperty ) { var propName = propertyInfo . propertyName ; if ( propertyInfo . hasBooleanValue ) { node [ propName ] = false ; } else { node [ propName ] = '' ; } } else { node . removeAttribute ( propertyInfo . attributeName ) ; } } else { node . removeAttribute ( name ) ; } }
1012	function updateProperties$1 ( domElement , updatePayload , tag , lastRawProps , nextRawProps ) { var wasCustomComponentTag = isCustomComponent ( tag , lastRawProps ) ; var isCustomComponentTag = isCustomComponent ( tag , nextRawProps ) ; updateDOMProperties ( domElement , updatePayload , wasCustomComponentTag , isCustomComponentTag ) ; switch ( tag ) { case 'input' : updateWrapper ( domElement , nextRawProps ) ; updateValueIfChanged ( domElement ) ; break ; case 'textarea' : updateWrapper$1 ( domElement , nextRawProps ) ; break ; case 'select' : postUpdateWrapper ( domElement , nextRawProps ) ; break ; } }
1013	async function sympact ( code , options ) { if ( typeof code !== 'string' ) { throw new TypeError ( "The 'code' paramater must a string'" ) ; } if ( typeof options === 'undefined' ) { options = { } ; } if ( typeof options !== 'object' ) { throw new TypeError ( "The 'options' paramater must an object'" ) ; } const interval = options . interval || 125 ; const cwd = options . cwd || path . dirname ( caller ( ) ) ; if ( interval < 1 ) { throw new TypeError ( "The 'interval' paramater must be greater than 0'" ) ; } return new Promise ( ( resolve , reject ) => { const slave = new Worker ( code , cwd ) ; const probe = new Profiler ( slave . pid ( ) , interval ) ; slave . on ( 'ready' , async ( ) => { await probe . watch ( ) ; slave . run ( ) ; } ) ; slave . on ( 'after' , async ( start , end ) => { await probe . unwatch ( ) ; slave . kill ( ) ; resolve ( probe . report ( start , end ) ) ; } ) ; slave . on ( 'error' , async err => { await probe . unwatch ( ) ; slave . kill ( ) ; reject ( err ) ; } ) ; } ) ; }
1014	function ExponentialBackoffStrategy ( options ) { BackoffStrategy . call ( this , options ) ; this . backoffDelay_ = 0 ; this . nextBackoffDelay_ = this . getInitialDelay ( ) ; this . factor_ = ExponentialBackoffStrategy . DEFAULT_FACTOR ; if ( options && options . factor !== undefined ) { precond . checkArgument ( options . factor > 1 , 'Exponential factor should be greater than 1 but got %s.' , options . factor ) ; this . factor_ = options . factor ; } }
1015	function Backoff ( backoffStrategy ) { events . EventEmitter . call ( this ) ; this . backoffStrategy_ = backoffStrategy ; this . maxNumberOfRetry_ = - 1 ; this . backoffNumber_ = 0 ; this . backoffDelay_ = 0 ; this . timeoutID_ = - 1 ; this . handlers = { backoff : this . onBackoff_ . bind ( this ) } ; }
1016	function FunctionCall ( fn , args , callback ) { events . EventEmitter . call ( this ) ; precond . checkIsFunction ( fn , 'Expected fn to be a function.' ) ; precond . checkIsArray ( args , 'Expected args to be an array.' ) ; precond . checkIsFunction ( callback , 'Expected callback to be a function.' ) ; this . function_ = fn ; this . arguments_ = args ; this . callback_ = callback ; this . lastResult_ = [ ] ; this . numRetries_ = 0 ; this . backoff_ = null ; this . strategy_ = null ; this . failAfter_ = - 1 ; this . retryPredicate_ = FunctionCall . DEFAULT_RETRY_PREDICATE_ ; this . state_ = FunctionCall . State_ . PENDING ; }
1017	function Channel ( connection , name , options ) { options || ( options = { } ) ; options . capped = true ; options . autoIndexId = true ; options . size || ( options . size = 1024 * 1024 * 5 ) ; options . strict = false ; this . options = options ; this . connection = connection ; this . closed = false ; this . listening = null ; this . name = name || 'mubsub' ; this . create ( ) . listen ( ) ; this . setMaxListeners ( 0 ) ; }
1018	function Connection ( uri , options ) { var self = this ; options || ( options = { } ) ; options . autoReconnect != null || ( options . autoReconnect = true ) ; if ( uri . collection ) { this . db = uri ; } else { MongoClient . connect ( uri , options , function ( err , db ) { if ( err ) return self . emit ( 'error' , err ) ; self . db = db ; self . emit ( 'connect' , db ) ; db . on ( 'error' , function ( err ) { self . emit ( 'error' , err ) ; } ) ; } ) ; } this . destroyed = false ; this . channels = { } ; }
1019	function Draggable ( target , options ) { if ( ! ( this instanceof Draggable ) ) { return new Draggable ( target , options ) ; } var that = this ; var instance = draggableCache . get ( target ) ; if ( instance ) { instance . state = 'reset' ; extend ( instance , options ) ; instance . update ( ) ; return instance ; } else { that . id = getUid ( ) ; that . _ns = '.draggy_' + that . id ; that . element = target ; draggableCache . set ( target , that ) ; } defineState ( that , 'state' , that . state ) ; that . currentHandles = [ ] ; extend ( that , options ) ; if ( that . handle === undefined ) { that . handle = that . element ; } if ( that . droppable ) { that . initDroppable ( ) ; } that . update ( ) ; that . state = 'idle' ; }
1020	function ConjunctionMap ( ) { let _conjunctions = [ ] ; this . add = function add ( conjunction , value ) { if ( value === undefined ) { return ; } let map = new LiteralTreeMap ( ) ; conjunction . forEach ( ( conjunct ) => { map . add ( conjunct ) ; } ) ; _conjunctions . push ( [ map . size ( ) , map , value ] ) ; } ; this . get = function get ( conjunction ) { let result ; for ( let i = 0 ; i < _conjunctions . length ; i += 1 ) { let pair = _conjunctions [ i ] ; let containMismatch = false ; if ( conjunction . length !== pair [ 0 ] ) { continue ; } for ( let j = 0 ; j < conjunction . length ; j += 1 ) { let conjunct = conjunction [ j ] ; if ( ! pair [ 1 ] . contains ( conjunct ) ) { containMismatch = true ; break ; } } if ( ! containMismatch ) { result = pair [ 2 ] ; break ; } } return result ; } ; }
1021	function sortTimables ( conjunction , forTime ) { let earlyConjuncts = [ ] ; let laterConjuncts = [ ] ; let dependentTimeVariables = { } ; for ( let k = 0 ; k < conjunction . length ; k += 1 ) { let conjunct = conjunction [ k ] ; if ( ! ( conjunct instanceof Timable ) ) { if ( conjunct instanceof Functor && comparisonTerms . indexOf ( conjunct . getId ( ) ) !== - 1 ) { conjunct . getVariables ( ) . forEach ( ( v ) => { dependentTimeVariables [ v ] = true ; } ) ; } continue ; } let conjunctStartTime = conjunct . getStartTime ( ) ; let conjunctEndTime = conjunct . getEndTime ( ) ; if ( conjunctEndTime instanceof Variable ) { let endTimeName = conjunctEndTime . evaluate ( ) ; if ( conjunctStartTime instanceof Value || ( conjunctStartTime instanceof Variable && conjunctStartTime . evaluate ( ) !== endTimeName ) ) { dependentTimeVariables [ endTimeName ] = true ; } } } for ( let k = 0 ; k < conjunction . length ; k += 1 ) { let conjunct = conjunction [ k ] ; if ( ! ( conjunct instanceof Timable ) ) { if ( laterConjuncts . length > 0 ) { laterConjuncts . push ( conjunct ) ; continue ; } earlyConjuncts . push ( conjunct ) ; continue ; } if ( ! conjunct . isInRange ( forTime ) ) { laterConjuncts . push ( conjunct ) ; continue ; } let conjunctStartTime = conjunct . getStartTime ( ) ; if ( conjunctStartTime instanceof Variable ) { if ( dependentTimeVariables [ conjunctStartTime . evaluate ( ) ] !== undefined ) { laterConjuncts . push ( conjunct ) ; continue ; } } earlyConjuncts . push ( conjunct ) ; } return [ earlyConjuncts , laterConjuncts ] ; }
1022	function ( programArgs ) { let _programArgs = programArgs ; if ( programArgs === undefined ) { _programArgs = [ ] ; } _programArgs = _programArgs . map ( arg => new Value ( arg ) ) ; let argsList = new List ( _programArgs ) ; let theta = { List : argsList } ; return programArgsPredicate . substitute ( theta ) ; }
1023	function createProgramArgsUpdaterFunc ( programArgs ) { return ( program ) => { let programArgsFact = buildProgramArgsPredicate ( programArgs ) ; program . getFacts ( ) . add ( programArgsFact ) ; return Promise . resolve ( program ) ; } ; }
1024	function processCycleObservations ( ) { let activeObservations = new LiteralTreeMap ( ) ; if ( _observations [ _currentTime ] === undefined ) { return activeObservations ; } let cloneProgram = _program . clone ( ) ; cloneProgram . setExecutedActions ( activeObservations ) ; const nextTime = _currentTime + 1 ; _observations [ _currentTime ] . forEach ( ( ob ) => { let action = ob . action ; let tempTreeMap = new LiteralTreeMap ( ) ; tempTreeMap . add ( action ) ; activeObservations . add ( action ) ; let postCloneProgram = cloneProgram . clone ( ) ; let postState = postCloneProgram . getState ( ) ; postCloneProgram . setExecutedActions ( new LiteralTreeMap ( ) ) ; updateStateWithFluentActors ( this , tempTreeMap , postState ) ; postCloneProgram . setState ( postState ) ; if ( ! checkConstraintSatisfaction . call ( this , cloneProgram ) || ! checkConstraintSatisfaction . call ( this , postCloneProgram ) ) { activeObservations . remove ( action ) ; _engineEventManager . notify ( 'warning' , { type : 'observation.reject' , message : stringLiterals ( 'engine.rejectObservationWarning' , action , _currentTime , nextTime ) } ) ; } if ( ob . endTime > nextTime ) { if ( _observations [ nextTime ] === undefined ) { _observations [ nextTime ] = [ ] ; } _observations [ nextTime ] . push ( ob ) ; } } ) ; return activeObservations ; }
1025	function actionsSelector ( goalTrees ) { const recursiveActionsSelector = ( actionsSoFar , programSoFar , l ) => { if ( l >= goalTrees . length ) { let actions = new LiteralTreeMap ( ) ; actionsSoFar . forEach ( ( map ) => { map . forEach ( ( literal ) => { actions . add ( literal ) ; } ) ; } ) ; return actions ; } let goalTree = goalTrees [ l ] ; let resultSet = null ; goalTree . forEachCandidateActions ( _currentTime , ( candidateActions ) => { let cloneProgram = programSoFar . clone ( ) ; let cloneExecutedActions = cloneProgram . getExecutedActions ( ) ; candidateActions . forEach ( ( a ) => { cloneExecutedActions . add ( a ) ; } ) ; if ( ! checkConstraintSatisfaction . call ( this , cloneProgram ) ) { return false ; } let clonePostProgram = programSoFar . clone ( ) ; clonePostProgram . setExecutedActions ( new LiteralTreeMap ( ) ) ; let postState = clonePostProgram . getState ( ) ; updateStateWithFluentActors ( this , candidateActions , postState ) ; clonePostProgram . setState ( postState ) ; if ( ! checkConstraintSatisfaction . call ( this , clonePostProgram ) ) { return false ; } resultSet = recursiveActionsSelector ( actionsSoFar . concat ( [ candidateActions ] ) , cloneProgram , l + 1 ) ; return true ; } ) ; if ( resultSet !== null ) { return resultSet ; } return recursiveActionsSelector ( actionsSoFar , programSoFar , l + 1 ) ; } ; return recursiveActionsSelector ( [ ] , _program , 0 ) ; }
1026	function performCycle ( ) { _currentTime += 1 ; let selectedAndExecutedActions = new LiteralTreeMap ( ) ; let executedObservations = new LiteralTreeMap ( ) ; let updatedState = _program . getState ( ) . clone ( ) ; updateStateWithFluentActors ( this , _program . getExecutedActions ( ) , updatedState ) ; _program . setState ( updatedState ) ; _nextCycleObservations . forEach ( ( obs ) => { executedObservations . add ( obs ) ; } ) ; _nextCycleActions . forEach ( ( act ) => { selectedAndExecutedActions . add ( act ) ; } ) ; let newFiredGoals = processRules ( this , _program , _currentTime , _profiler ) ; _goals = _goals . concat ( newFiredGoals ) ; return evaluateGoalTrees ( _currentTime , _goals , _profiler ) . then ( ( newGoals ) => { _goals = newGoals ; _program . setExecutedActions ( new LiteralTreeMap ( ) ) ; _goals . sort ( goalTreeSorter ( _currentTime ) ) ; return actionsSelector . call ( this , _goals ) ; } ) . then ( ( nextCycleActions ) => { _nextCycleActions = new LiteralTreeMap ( ) ; nextCycleActions . forEach ( ( l ) => { _nextCycleActions . add ( l ) ; } ) ; _nextCycleObservations = new LiteralTreeMap ( ) ; let cycleObservations = processCycleObservations . call ( this ) ; cycleObservations . forEach ( ( observation ) => { nextCycleActions . add ( observation ) ; _nextCycleObservations . add ( observation ) ; } ) ; _program . setExecutedActions ( nextCycleActions ) ; _lastCycleActions = selectedAndExecutedActions ; _lastCycleObservations = executedObservations ; return Promise . resolve ( ) ; } ) ; }
1027	function applyArgs ( func , thisObj , args ) { return func . apply ( thisObj , Array . prototype . slice . call ( args ) ) ; }
1028	function define ( ) { var thisFlow = function ( ) { applyArgs ( thisFlow . exec , thisFlow , arguments ) ; } thisFlow . blocks = arguments ; thisFlow . exec = function ( ) { var flowState = function ( ) { if ( flowState . __frozen ) return ; if ( flowState . __timeoutId ) { clearTimeout ( flowState . __timeoutId ) ; delete flowState . __timeoutId ; } var blockIdx = flowState . __nextBlockIdx ++ ; var block = thisFlow . blocks [ blockIdx ] ; if ( block === undefined ) { return ; } else { applyArgs ( block , flowState , arguments ) ; } } flowState . __nextBlockIdx = 0 ; flowState . __multiCount = 0 ; flowState . __multiOutputs = [ ] ; flowState . REWIND = function ( ) { flowState . __nextBlockIdx -= 1 ; } flowState . MULTI = function ( resultId ) { flowState . __multiCount += 1 ; return function ( ) { flowState . __multiCount -= 1 ; flowState . __multiOutputs . push ( arguments ) ; if ( resultId ) { var result = arguments . length <= 1 ? arguments [ 0 ] : arguments flowState . __multiOutputs [ resultId ] = result ; } if ( flowState . __multiCount === 0 ) { var multiOutputs = flowState . __multiOutputs ; flowState . __multiOutputs = [ ] ; flowState ( multiOutputs ) ; } } } flowState . TIMEOUT = function ( milliseconds , timeoutCallback ) { if ( flowState . __timeoutId !== undefined ) { throw new Error ( "timeout already set for this flow step" ) ; } flowState . __timeoutId = setTimeout ( function ( ) { flowState . __frozen = true ; timeoutCallback ( ) ; } , milliseconds ) ; } applyArgs ( flowState , this , arguments ) ; } return thisFlow ; }
1029	function ( ) { if ( flowState . __frozen ) return ; if ( flowState . __timeoutId ) { clearTimeout ( flowState . __timeoutId ) ; delete flowState . __timeoutId ; } var blockIdx = flowState . __nextBlockIdx ++ ; var block = thisFlow . blocks [ blockIdx ] ; if ( block === undefined ) { return ; } else { applyArgs ( block , flowState , arguments ) ; } }
1030	function exec ( ) { var flow = typeof exports != 'undefined' ? exports : window . flow ; applyArgs ( flow . define , flow , arguments ) ( ) ; }
1031	function padStart ( str , length , padChar ) { if ( str . length >= length ) { return str ; } else { return padChar . repeat ( length - str . length ) + str ; } }
1032	function SM2Curve ( params ) { if ( ! ( this instanceof SM2Curve ) ) { return new SM2Curve ( params ) ; } elliptic . curve . short . call ( this , params ) ; }
1033	function SM2KeyPair ( pub , pri ) { if ( ! ( this instanceof SM2KeyPair ) ) { return new SM2KeyPair ( pub , pri ) ; } this . curve = SM2 ; this . pub = null ; this . pri = null ; var validPub = false ; var validPri = false ; if ( pub != null ) { if ( typeof pub === 'string' ) { this . _pubFromString ( pub ) ; } else if ( Array . isArray ( pub ) ) { this . _pubFromBytes ( pub ) ; } else if ( 'x' in pub && pub . x instanceof BN && 'y' in pub && pub . y instanceof BN ) { this . pub = pub ; validPub = true ; } else { throw 'invalid public key' ; } } if ( pri != null ) { if ( typeof pri === 'string' ) { this . pri = new BN ( pri , 16 ) ; } else if ( pri instanceof BN ) { this . pri = pri ; validPri = true ; } else { throw 'invalid private key' ; } if ( this . pub == null ) { this . pub = SM2 . g . mul ( this . pri ) ; } } if ( ! ( validPub && validPri ) && ! this . validate ( ) ) { throw 'invalid key' ; } }
1034	function gulpStaticI18n ( options ) { return through . obj ( function ( target , encoding , cb ) { var stream = this ; var build = new StaticI18n ( target , options , stream ) ; build . translate ( cb ) ; } ) ; }
1035	function ( obj , type , fn , scope ) { scope = scope || obj ; var wrappedFn = function ( e ) { fn . call ( scope , e ) ; } ; obj . addEventListener ( type , wrappedFn , false ) ; cache . push ( [ obj , type , fn , wrappedFn ] ) ; }
1036	function ( obj , type , fn ) { var wrappedFn , item , len = cache . length , i ; for ( i = 0 ; i < len ; i ++ ) { item = cache [ i ] ; if ( item [ 0 ] === obj && item [ 1 ] === type && item [ 2 ] === fn ) { wrappedFn = item [ 3 ] ; if ( wrappedFn ) { obj . removeEventListener ( type , wrappedFn , false ) ; cache = cache . slice ( i ) ; return true ; } } } }
1037	function View ( model ) { var wrapper ; this . el = wrapper = document . createElement ( 'div' ) ; this . model = model ; this . isShowing = false ; wrapper . id = config . name ; config . parent . appendChild ( wrapper ) ; css . inject ( document . getElementsByTagName ( 'head' ) [ 0 ] , config . styles ) ; events . add ( document , ( 'ontouchstart' in window ) ? 'touchstart' : 'click' , viewevents . click , this ) ; events . add ( document , 'keyup' , viewevents . keyup , this ) ; events . add ( document , 'readystatechange' , viewevents . readystatechange , this ) ; events . add ( window , 'pageshow' , viewevents . pageshow , this ) ; }
1038	function Product ( data ) { data . quantity = parser . quantity ( data . quantity ) ; data . amount = parser . amount ( data . amount ) ; data . href = parser . href ( data . href ) ; this . _data = data ; this . _options = null ; this . _discount = null ; this . _amount = null ; this . _total = null ; Pubsub . call ( this ) ; }
1039	function Cart ( name , duration ) { var data , items , settings , len , i ; this . _items = [ ] ; this . _settings = { bn : constants . BN } ; Pubsub . call ( this ) ; Storage . call ( this , name , duration ) ; if ( ( data = this . load ( ) ) ) { items = data . items ; settings = data . settings ; if ( settings ) { this . _settings = settings ; } if ( items ) { for ( i = 0 , len = items . length ; i < len ; i ++ ) { this . add ( items [ i ] ) ; } } } }
1040	function onRejected ( error ) { attemts_left -= 1 ; if ( attemts_left < 1 ) { throw error ; } console . log ( "A retried call failed. Retrying " + attemts_left + " more time(s)." ) ; var fullArguments = [ attemts_left , promiseFunction ] . concat ( promiseFunctionArguments ) ; return module . exports . retryPromise . apply ( undefined , fullArguments ) ; }
1041	function fixDate ( type , value , hash ) { if ( type !== "commit" && type !== "tag" ) return ; var clone = JSON . parse ( JSON . stringify ( value ) ) ; for ( var x = 0 ; x < 3 ; x ++ ) { for ( var i = - 720 ; i < 720 ; i += 30 ) { if ( type === "commit" ) { clone . author . date . offset = i ; clone . committer . date . offset = i ; } else if ( type === "tag" ) { clone . tagger . date . offset = i ; } if ( hash !== hashAs ( type , clone ) ) continue ; value . message = clone . message ; if ( type === "commit" ) { value . author . date . offset = clone . author . date . offset ; value . committer . date . offset = clone . committer . date . offset ; } else if ( type === "tag" ) { value . tagger . date . offset = clone . tagger . date . offset ; } return true ; } clone . message += "\n" ; } \n }
1042	function ( ) { var $this = this ; $this . removeData ( ) ; $ ( document ) . unbind ( 'mousemove.nstSlider' ) . unbind ( 'mouseup.nstSlider' ) ; $this . parent ( ) . unbind ( 'mousedown.nstSlider' ) . unbind ( 'touchstart.nstSlider' ) . unbind ( 'touchmove.nstSlider' ) . unbind ( 'touchend.nstSlider' ) ; $this . unbind ( 'keydown.nstSlider' ) . unbind ( 'keyup.nstSlider' ) ; return $this ; }
1043	function ( ) { var $this = this ; var lastStepHistogram = $this . data ( 'last_step_histogram' ) ; if ( typeof lastStepHistogram !== 'undefined' ) { methods . set_step_histogram . call ( $this , lastStepHistogram ) ; } _methods . set_position_from_val . call ( $this , methods . get_current_min_value . call ( $this ) , methods . get_current_max_value . call ( $this ) ) ; var highlightRangeMin = $this . data ( 'highlightedRangeMin' ) ; if ( typeof highlightRangeMin === 'number' ) { var highlightRangeMax = $this . data ( 'highlightedRangeMax' ) ; methods . highlight_range . call ( $this , highlightRangeMin , highlightRangeMax ) ; } _methods . notify_changed_implicit . call ( $this , 'refresh' ) ; return $this ; }
1044	function GoogleLogin ( ) { if ( ! ( this instanceof GoogleLogin ) ) { return new GoogleLogin ( ) ; } const self = this ; const GOOGLE_LOGIN_ANDROID_ID = '9774d56d682e549c' ; const GOOGLE_LOGIN_SERVICE = 'audience:server:client_id:848232511240-7so421jotr2609rmqakceuu1luuq0ptb.apps.googleusercontent.com' ; const GOOGLE_LOGIN_APP = 'com.nianticlabs.pokemongo' ; const GOOGLE_LOGIN_CLIENT_SIG = '321187995bc7cdc2b5fc91b11a96e2baa8602c62' ; this . setProxy = function ( proxy ) { google . setProxy ( proxy ) ; } ; this . login = function ( username , password ) { return self . getMasterToken ( username , password ) . then ( loginData => self . getToken ( username , loginData ) ) . then ( authData => authData . Auth ) ; } ; this . loginWithToken = function ( username , token ) { var loginData = { androidId : GOOGLE_LOGIN_ANDROID_ID , masterToken : token } ; return self . getToken ( username , loginData ) . then ( authData => authData . Auth ) ; } ; this . getMasterToken = function ( username , password ) { return new Promise ( ( resolve , reject ) => { google . login ( username , password , GOOGLE_LOGIN_ANDROID_ID , ( err , data ) => { if ( err ) { if ( err . response . statusCode === 403 ) { reject ( Error ( 'Received code 403 from Google login. This could be because your account has ' + '2-Step-Verification enabled. If that is the case, you need to generate an ' + 'App Password and use that instead of your regular password: ' + 'https://security.google.com/settings/security/apppasswords' ) ) ; } else { reject ( Error ( err . response . statusCode + ': ' + err . response . statusMessage ) ) ; } return ; } resolve ( data ) ; } ) ; } ) ; } ; this . getToken = function ( username , loginData ) { return new Promise ( ( resolve , reject ) => { google . oauth ( username , loginData . masterToken , loginData . androidId , GOOGLE_LOGIN_SERVICE , GOOGLE_LOGIN_APP , GOOGLE_LOGIN_CLIENT_SIG , ( err , data ) => { if ( err ) { reject ( Error ( err . response . statusCode + ': ' + err . response . statusMessage ) ) ; return ; } resolve ( data ) ; } ) ; } ) ; } ; }
1045	function ( lat , lng , radius , level ) { if ( typeof radius === 'undefined' ) radius = 3 ; if ( typeof level === 'undefined' ) level = 15 ; var origin = s2 . S2Cell . FromLatLng ( { lat : lat , lng : lng } , level ) ; var cells = [ ] ; cells . push ( origin . toHilbertQuadkey ( ) ) ; for ( var i = 1 ; i < radius ; i ++ ) { cells . push ( s2 . S2Cell . FromFaceIJ ( origin . face , [ origin . ij [ 0 ] , origin . ij [ 1 ] - i ] , origin . level ) . toHilbertQuadkey ( ) ) ; cells . push ( s2 . S2Cell . FromFaceIJ ( origin . face , [ origin . ij [ 0 ] , origin . ij [ 1 ] + i ] , origin . level ) . toHilbertQuadkey ( ) ) ; cells . push ( s2 . S2Cell . FromFaceIJ ( origin . face , [ origin . ij [ 0 ] - i , origin . ij [ 1 ] ] , origin . level ) . toHilbertQuadkey ( ) ) ; cells . push ( s2 . S2Cell . FromFaceIJ ( origin . face , [ origin . ij [ 0 ] + i , origin . ij [ 1 ] ] , origin . level ) . toHilbertQuadkey ( ) ) ; for ( var j = 1 ; j < radius ; j ++ ) { cells . push ( s2 . S2Cell . FromFaceIJ ( origin . face , [ origin . ij [ 0 ] - j , origin . ij [ 1 ] - i ] , origin . level ) . toHilbertQuadkey ( ) ) ; cells . push ( s2 . S2Cell . FromFaceIJ ( origin . face , [ origin . ij [ 0 ] + j , origin . ij [ 1 ] - i ] , origin . level ) . toHilbertQuadkey ( ) ) ; cells . push ( s2 . S2Cell . FromFaceIJ ( origin . face , [ origin . ij [ 0 ] - j , origin . ij [ 1 ] + i ] , origin . level ) . toHilbertQuadkey ( ) ) ; cells . push ( s2 . S2Cell . FromFaceIJ ( origin . face , [ origin . ij [ 0 ] + j , origin . ij [ 1 ] + i ] , origin . level ) . toHilbertQuadkey ( ) ) ; } } return cells . map ( s2 . toId ) ; }
1046	function ( enumObj , val ) { for ( var key of Object . keys ( enumObj ) ) { if ( enumObj [ key ] === val ) { return key . split ( '_' ) . map ( word => word . charAt ( 0 ) . toUpperCase ( ) + word . slice ( 1 ) . toLowerCase ( ) ) . join ( ' ' ) ; } } return null ; }
1047	function ( object ) { if ( ! object || typeof object !== 'object' ) return object ; if ( object instanceof ByteBuffer ) return object ; if ( Long . isLong ( object ) ) { return object . lessThanOrEqual ( Number . MAX_SAFE_INTEGER ) && object . greaterThanOrEqual ( Number . MIN_SAFE_INTEGER ) ? object . toNumber ( ) : object . toString ( ) ; } for ( var i in object ) { if ( object . hasOwnProperty ( i ) ) { if ( Long . isLong ( object [ i ] ) ) { object [ i ] = object [ i ] . lessThanOrEqual ( Number . MAX_SAFE_INTEGER ) && object [ i ] . greaterThanOrEqual ( Number . MIN_SAFE_INTEGER ) ? object [ i ] . toNumber ( ) : object [ i ] . toString ( ) ; } else if ( typeof object [ i ] === 'object' ) { object [ i ] = this . convertLongs ( object [ i ] ) ; } } } return object ; }
1048	function Random ( seed ) { this . multiplier = 16807 ; this . modulus = 0x7fffffff ; this . seed = seed ; this . mq = Math . floor ( this . modulus / this . multiplier ) ; this . mr = this . modulus % this . multiplier ; }
1049	function prettyDate ( time ) { var diff = ( ( ( new Date ( ) ) . getTime ( ) - time ) / 1000 ) , day_diff = Math . floor ( diff / 86400 ) ; if ( isNaN ( day_diff ) || day_diff < 0 || day_diff >= 31 ) return ; return day_diff == 0 && ( diff < 60 && "just now" || diff < 120 && "1 minute ago" || diff < 3600 && Math . floor ( diff / 60 ) + " minutes ago" || diff < 7200 && "1 hour ago" || diff < 86400 && Math . floor ( diff / 3600 ) + " hours ago" ) || day_diff == 1 && "Yesterday" || day_diff < 7 && day_diff + " days ago" || day_diff < 31 && Math . ceil ( day_diff / 7 ) + " weeks ago" ; }
1050	function LoggerFactory ( options ) { options = options || { prefix : true } ; if ( typeof console !== 'object' || typeof console . log !== 'function' || typeof console . log . bind !== 'function' ) { return function noop ( ) { } ; } return function log ( ) { var args = Array . prototype . slice . call ( arguments ) ; if ( io . sails . environment === 'production' ) return ; var PREFIX = '' ; if ( options . prefix ) { args . unshift ( PREFIX ) ; } console . log . bind ( console ) . apply ( this , args ) ; } ; }
1051	function runRequestQueue ( socket ) { var queue = socket . requestQueue ; if ( ! queue ) return ; for ( var i in queue ) { var isSafeToDereference = ( { } ) . hasOwnProperty . call ( queue , i ) ; if ( isSafeToDereference ) { var requestArgs = queue [ i ] ; socket . request . apply ( socket , requestArgs ) ; } } socket . requestQueue = null ; }
1052	function jsonp ( opts , cb ) { opts = opts || { } ; if ( typeof window === 'undefined' ) { return cb ( ) ; } var scriptEl = document . createElement ( 'script' ) ; window . _sailsIoJSConnect = function ( response ) { if ( scriptEl && scriptEl . parentNode ) { scriptEl . parentNode . removeChild ( scriptEl ) ; } cb ( response ) ; } ; scriptEl . src = opts . url ; document . getElementsByTagName ( 'head' ) [ 0 ] . appendChild ( scriptEl ) ; }
1053	function validateParameterValue ( parameter , type , format , value ) { if ( type === 'integer' ) { const parsedValue = Number . parseInt ( value ) if ( _ . isNaN ( parsedValue ) ) { throw new Error ( ` ${ parameter } ${ value } ` ) } return parsedValue } else if ( type === 'number' ) { const parsedValue = Number . parseFloat ( value ) if ( _ . isNaN ( parsedValue ) ) { throw new Error ( ` ${ parameter } ${ value } ` ) } return Number . isInteger ( parsedValue ) ? Number . parseInt ( value ) : parsedValue } else if ( type === 'string' && format ) { if ( format === 'date-time' && ! moment ( value , moment . ISO_8601 ) . isValid ( ) ) { throw new Error ( ` ${ parameter } ${ value } ` ) } else if ( format === 'date' && ! moment ( value , 'YYYY-MM-DD' ) . isValid ( ) ) { throw new Error ( ` ${ parameter } ${ value } ` ) } return value } return value }
1054	function parameterDeclarationToYargs ( yargs , parameter , declaration ) { const optionName = _ . kebabCase ( parameter ) let option = { } if ( declaration . description ) { option . describe = declaration . description } if ( declaration . type ) { if ( declaration . type === 'integer' ) { option . type = 'number' } else { option . type = declaration . type } } if ( declaration . enum ) { option . choices = declaration . enum } if ( declaration . default ) { option . default = declaration . default } if ( declaration . required ) { option . demandOption = declaration . required } if ( declaration . conflicts ) { option . conflicts = declaration . conflicts } yargs . option ( optionName , option ) yargs . coerce ( optionName , ( value ) => { if ( declaration . type === 'array' ) { return _ . map ( value , ( value ) => { return validateParameterValue ( ` ${ optionName } ` , declaration . item , declaration . format , value ) } ) } return validateParameterValue ( optionName , declaration . type , declaration . format , value ) } ) }
1055	function configDeclarationToYargs ( yargs , configDeclaration ) { _ . forOwn ( configDeclaration , ( parameter , parameterName ) => { parameterDeclarationToYargs ( yargs , parameterName , parameter ) } ) return yargs }
1056	function NGramParser ( theNgramList , theByteMap ) { var N_GRAM_MASK = 0xFFFFFF ; this . byteIndex = 0 ; this . ngram = 0 ; this . ngramList = theNgramList ; this . byteMap = theByteMap ; this . ngramCount = 0 ; this . hitCount = 0 ; this . spaceChar ; this . search = function ( table , value ) { var index = 0 ; if ( table [ index + 32 ] <= value ) index += 32 ; if ( table [ index + 16 ] <= value ) index += 16 ; if ( table [ index + 8 ] <= value ) index += 8 ; if ( table [ index + 4 ] <= value ) index += 4 ; if ( table [ index + 2 ] <= value ) index += 2 ; if ( table [ index + 1 ] <= value ) index += 1 ; if ( table [ index ] > value ) index -= 1 ; if ( index < 0 || table [ index ] != value ) return - 1 ; return index ; } ; this . lookup = function ( thisNgram ) { this . ngramCount += 1 ; if ( this . search ( this . ngramList , thisNgram ) >= 0 ) { this . hitCount += 1 ; } } ; this . addByte = function ( b ) { this . ngram = ( ( this . ngram << 8 ) + ( b & 0xFF ) ) & N_GRAM_MASK ; this . lookup ( this . ngram ) ; } this . nextByte = function ( det ) { if ( this . byteIndex >= det . fInputLen ) return - 1 ; return det . fInputBytes [ this . byteIndex ++ ] & 0xFF ; } this . parse = function ( det , spaceCh ) { var b , ignoreSpace = false ; this . spaceChar = spaceCh ; while ( ( b = this . nextByte ( det ) ) >= 0 ) { var mb = this . byteMap [ b ] ; if ( mb != 0 ) { if ( ! ( mb == this . spaceChar && ignoreSpace ) ) { this . addByte ( mb ) ; } ignoreSpace = ( mb == this . spaceChar ) ; } } this . addByte ( this . spaceChar ) ; var rawPercent = this . hitCount / this . ngramCount ; if ( rawPercent > 0.33 ) return 98 ; return Math . floor ( rawPercent * 300.0 ) ; } ; }
1057	function collectScenariosFromElement ( parentElement ) { var scenarios = [ ] ; var templates = [ ] ; var elements = parentElement . children ( ) ; var i = 0 ; angular . forEach ( elements , function ( el ) { var elem = angular . element ( el ) ; if ( ! elem . attr ( 'src' ) || ! elem . attr ( 'src' ) . match ( / .html$ / ) ) { templates [ i ] = elem ; scenarios [ i ] = { media : elem . attr ( 'media' ) , templ : i } ; } else { scenarios [ i ] = { media : elem . attr ( 'media' ) , src : elem . attr ( 'src' ) } ; } i ++ ; } ) ; return { scenarios : scenarios , templates : templates } ; }
1058	function changed ( done ) { const files = [ ] . slice . call ( arguments ) ; if ( typeof files [ files . length - 1 ] === 'function' ) done = files . pop ( ) ; done = typeof done === 'function' ? done : ( ) => { } ; debug ( 'Notifying %d servers - Files: ' , servers . length , files ) ; servers . forEach ( srv => { const params = { params : { files : files } } ; srv && srv . changed ( params ) ; } ) ; done ( ) ; }
1059	function ( children , element ) { this . portalNode = document . createElement ( 'div' ) ; ( element || document . body ) . appendChild ( this . portalNode ) ; ReactDOM . render ( children , this . portalNode ) ; }
1060	function ( ) { var close = typeof this . portalConfirmOnCloseMessage === 'string' ? confirm ( this . portalConfirmOnCloseMessage ) : true ; if ( this . portalNode && this . portalNode . parentNode && close ) { ReactDOM . unmountComponentAtNode ( this . portalNode ) ; this . portalNode . parentNode . removeChild ( this . portalNode ) ; this . portalNode = null ; } }
1061	function ( data ) { if ( this . filterValue ) { data = this . quickFilterData ( data , this . filterValue ) ; } if ( this . advancedFilters ) { data = this . advancedFilterData ( data , this . advancedFilters ) ; } this . dataCount = data . length ; return data ; }
1062	function ( id , definition , dataFormatter ) { this . collection [ id ] = new Table ( id , definition , dataFormatter ) ; return this . collection [ id ] ; }
1063	function ( payload ) { var action = payload . action ; if ( ! this . shouldHandleAction ( action . component ) ) { return ; } switch ( action . actionType ) { case ActionTypes . REQUEST_DATA : this . handleRequestDataAction ( action ) ; break ; case ActionTypes . TABLE_SORT : this . collection [ action . id ] . sortData ( action . data . colIndex , action . data . direction ) ; this . emitChange ( action . id ) ; break ; case ActionTypes . FILTER : this . collection [ action . id ] . setFilterValue ( action . data . value ) ; this . emitChange ( action . id ) ; break ; case ActionTypes . ADVANCED_FILTER : this . collection [ action . id ] . setAdvancedFilters ( action . data . advancedFilters ) ; this . emitChange ( action . id ) ; break ; case ActionTypes . PAGINATE : this . collection [ action . id ] . paginate ( action . data . direction ) ; this . emitChange ( action . id ) ; break ; case ActionTypes . TOGGLE_BULK_SELECT : this . collection [ action . id ] . updateBulkSelection ( action . data . deselect ) ; this . emitChange ( action . id ) ; break ; case ActionTypes . TOGGLE_ROW_SELECT : this . collection [ action . id ] . updateRowSelection ( action . data . rowIndex ) ; this . emitChange ( action . id ) ; break ; case ActionTypes . DESTROY_INSTANCE : this . destroyInstance ( action . id ) ; break ; } }
1064	function ( nextProps ) { if ( this . props . filters !== nextProps . filters && JSON . stringify ( this . props . filters ) !== JSON . stringify ( nextProps . filters ) ) { setTimeout ( function ( ) { this . requestData ( ) ; } . bind ( this ) , 0 ) ; } }
1065	function ( store ) { return { componentDidMount : function ( ) { store . on ( 'change:' + this . props . componentId , this . onDataReceived ) ; store . on ( 'fail:' + this . props . componentId , this . onError ) ; } , componentWillUnmount : function ( ) { store . removeListener ( 'change:' + this . props . componentId , this . onDataReceived ) ; store . removeListener ( 'fail:' + this . props . componentId , this . onError ) ; } } ; }
1066	function ( ) { store . on ( 'change:' + this . props . componentId , this . onDataReceived ) ; store . on ( 'fail:' + this . props . componentId , this . onError ) ; }
1067	function ( ) { store . removeListener ( 'change:' + this . props . componentId , this . onDataReceived ) ; store . removeListener ( 'fail:' + this . props . componentId , this . onError ) ; }
1068	function ( id , definition , dataFormatter , filters ) { AppDispatcher . dispatchAction ( { actionType : this . actionTypes . REQUEST_DATA , component : 'Table' , id : id , data : { definition : definition , dataFormatter : dataFormatter , filters : filters } } ) ; }
1069	function ( id , value ) { AppDispatcher . dispatchAction ( { actionType : this . actionTypes . FILTER , component : 'Table' , id : id , data : { value : value } } ) ; }
1070	function ( id , direction ) { AppDispatcher . dispatchAction ( { actionType : this . actionTypes . PAGINATE , component : 'Table' , id : id , data : { direction : direction } } ) ; }
1071	function ( id , deselect ) { AppDispatcher . dispatchAction ( { actionType : this . actionTypes . TOGGLE_BULK_SELECT , component : 'Table' , id : id , data : { deselect : deselect } } ) ; }
1072	function ( id , rowIndex ) { AppDispatcher . dispatchAction ( { actionType : this . actionTypes . TOGGLE_ROW_SELECT , component : 'Table' , id : id , data : { rowIndex : rowIndex } } ) ; }
1073	function extractValue ( attr , node ) { if ( attr === 'translate' ) { return node . html ( ) || getAttr ( attr ) || '' ; } return getAttr ( attr ) || node . html ( ) || '' ; }
1074	function ( obj , callback , thisArg ) { return obj . map ? obj . map . call ( obj , callback , thisArg ) : map . call ( obj , callback , thisArg ) ; }
1075	function ( obj , callback , thisArg ) { return obj . filter ? obj . filter . call ( obj , callback , thisArg ) : filter . call ( obj , callback , thisArg ) ; }
1076	function ( obj , elements ) { return elements === undefined ? [ ] : utils . map ( elements , function ( item ) { return utils . indexOf ( obj , item ) ; } ) ; }
1077	function ( array , item ) { var index = utils . indexOf ( array , item ) ; if ( index === - 1 ) { array . push ( item ) ; } }
1078	function ( array , idx , amt , objects ) { if ( array . replace ) { return array . replace ( idx , amt , objects ) ; } else { return utils . _replace ( array , idx , amt , objects ) ; } }
1079	function ( array1 , array2 ) { var intersection = [ ] ; utils . forEach ( array1 , function ( element ) { if ( utils . indexOf ( array2 , element ) >= 0 ) { intersection . push ( element ) ; } } ) ; return intersection ; }
1080	function removeListener ( obj , eventName , target , method ) { Ember . assert ( "You must pass at least an object and event name to Ember.removeListener" , ! ! obj && ! ! eventName ) ; if ( ! method && 'function' === typeof target ) { method = target ; target = null ; } function _removeListener ( target , method ) { var actions = actionsFor ( obj , eventName ) , actionIndex = indexOf ( actions , target , method ) ; if ( actionIndex === - 1 ) { return ; } actions . splice ( actionIndex , 3 ) ; if ( 'function' === typeof obj . didRemoveListener ) { obj . didRemoveListener ( eventName , target , method ) ; } } if ( method ) { _removeListener ( target , method ) ; } else { var meta = obj [ META_KEY ] , actions = meta && meta . listeners && meta . listeners [ eventName ] ; if ( ! actions ) { return ; } for ( var i = actions . length - 3 ; i >= 0 ; i -= 3 ) { _removeListener ( actions [ i ] , actions [ i + 1 ] ) ; } } }
1081	function suspendListener ( obj , eventName , target , method , callback ) { if ( ! method && 'function' === typeof target ) { method = target ; target = null ; } var actions = actionsFor ( obj , eventName ) , actionIndex = indexOf ( actions , target , method ) ; if ( actionIndex !== - 1 ) { actions [ actionIndex + 2 ] |= SUSPENDED ; } function tryable ( ) { return callback . call ( target ) ; } function finalizer ( ) { if ( actionIndex !== - 1 ) { actions [ actionIndex + 2 ] &= ~ SUSPENDED ; } } return Ember . tryFinally ( tryable , finalizer ) ; }
1082	function dependentKeysDidChange ( obj , depKey , meta ) { if ( obj . isDestroying ) { return ; } var seen = DID_SEEN , top = ! seen ; if ( top ) { seen = DID_SEEN = { } ; } iterDeps ( propertyDidChange , obj , depKey , seen , meta ) ; if ( top ) { DID_SEEN = null ; } }
1083	function set ( obj , keyName , value , tolerant ) { if ( typeof obj === 'string' ) { Ember . assert ( "Path '" + obj + "' must be global if no obj is given." , IS_GLOBAL . test ( obj ) ) ; value = keyName ; keyName = obj ; obj = null ; } Ember . assert ( "Cannot call set with " + keyName + " key." , ! ! keyName ) ; if ( ! obj || keyName . indexOf ( '.' ) !== - 1 ) { return setPath ( obj , keyName , value , tolerant ) ; } Ember . assert ( "You need to provide an object and key to `set`." , ! ! obj && keyName !== undefined ) ; Ember . assert ( 'calling set on destroyed object' , ! obj . isDestroyed ) ; var meta = obj [ META_KEY ] , desc = meta && meta . descs [ keyName ] , isUnknown , currentValue ; if ( desc ) { desc . set ( obj , keyName , value ) ; } else { isUnknown = 'object' === typeof obj && ! ( keyName in obj ) ; if ( isUnknown && 'function' === typeof obj . setUnknownProperty ) { obj . setUnknownProperty ( keyName , value ) ; } else if ( meta && meta . watching [ keyName ] > 0 ) { if ( MANDATORY_SETTER ) { currentValue = meta . values [ keyName ] ; } else { currentValue = obj [ keyName ] ; } if ( value !== currentValue ) { Ember . propertyWillChange ( obj , keyName ) ; if ( MANDATORY_SETTER ) { if ( ( currentValue === undefined && ! ( keyName in obj ) ) || ! obj . propertyIsEnumerable ( keyName ) ) { Ember . defineProperty ( obj , keyName , null , value ) ; } else { meta . values [ keyName ] = value ; } } else { obj [ keyName ] = value ; } Ember . propertyDidChange ( obj , keyName ) ; } } else { obj [ keyName ] = value ; } } return value ; }
1084	function ( key , value ) { var keys = this . keys , values = this . values , guid = guidFor ( key ) ; keys . add ( key ) ; values [ guid ] = value ; set ( this , 'length' , keys . list . length ) ; }
1085	function ( key ) { var keys = this . keys , values = this . values , guid = guidFor ( key ) ; if ( values . hasOwnProperty ( guid ) ) { keys . remove ( key ) ; delete values [ guid ] ; set ( this , 'length' , keys . list . length ) ; return true ; } else { return false ; } }
1086	function ( callback , self ) { var keys = this . keys , values = this . values ; keys . forEach ( function ( key ) { var guid = guidFor ( key ) ; callback . call ( self , key , values [ guid ] ) ; } ) ; }
1087	function ( obj ) { Ember . assert ( 'Must pass a valid object to Ember.Binding.disconnect()' , ! ! obj ) ; var twoWay = ! this . _oneWay ; Ember . removeObserver ( obj , this . _from , this , this . fromDidChange ) ; if ( twoWay ) { Ember . removeObserver ( obj , this . _to , this , this . toDidChange ) ; } this . _readyToSync = false ; return this ; }
1088	function filter ( promises , filterFn , label ) { return all ( promises , label ) . then ( function ( values ) { if ( ! isArray ( promises ) ) { throw new TypeError ( 'You must pass an array to filter.' ) ; } if ( ! isFunction ( filterFn ) ) { throw new TypeError ( "You must pass a function to filter's second argument." ) ; } return map ( promises , filterFn , label ) . then ( function ( filterResults ) { var i , valuesLen = values . length , filtered = [ ] ; for ( i = 0 ; i < valuesLen ; i ++ ) { if ( filterResults [ i ] ) filtered . push ( values [ i ] ) ; } return filtered ; } ) ; } ) ; }
1089	function Container ( parent ) { this . parent = parent ; this . children = [ ] ; this . resolver = parent && parent . resolver || function ( ) { } ; this . registry = new InheritingDict ( parent && parent . registry ) ; this . cache = new InheritingDict ( parent && parent . cache ) ; this . factoryCache = new InheritingDict ( parent && parent . factoryCache ) ; this . resolveCache = new InheritingDict ( parent && parent . resolveCache ) ; this . typeInjections = new InheritingDict ( parent && parent . typeInjections ) ; this . injections = { } ; this . factoryTypeInjections = new InheritingDict ( parent && parent . factoryTypeInjections ) ; this . factoryInjections = { } ; this . _options = new InheritingDict ( parent && parent . _options ) ; this . _typeOptions = new InheritingDict ( parent && parent . _typeOptions ) ; }
1090	function ( fullName , factory , options ) { validateFullName ( fullName ) ; if ( factory === undefined ) { throw new TypeError ( 'Attempting to register an unknown factory: `' + fullName + '`' ) ; } var normalizedName = this . normalize ( fullName ) ; if ( this . cache . has ( normalizedName ) ) { throw new Error ( 'Cannot re-register: `' + fullName + '`, as it has already been looked up.' ) ; } this . registry . set ( normalizedName , factory ) ; this . _options . set ( normalizedName , options || { } ) ; }
1091	function ( fullName ) { validateFullName ( fullName ) ; var normalizedName = this . normalize ( fullName ) ; this . registry . remove ( normalizedName ) ; this . cache . remove ( normalizedName ) ; this . factoryCache . remove ( normalizedName ) ; this . resolveCache . remove ( normalizedName ) ; this . _options . remove ( normalizedName ) ; }
1092	function ( fullName ) { validateFullName ( fullName ) ; var normalizedName = this . normalize ( fullName ) ; var cached = this . resolveCache . get ( normalizedName ) ; if ( cached ) { return cached ; } var resolved = this . resolver ( normalizedName ) || this . registry . get ( normalizedName ) ; this . resolveCache . set ( normalizedName , resolved ) ; return resolved ; }
1093	function ( type , property , fullName ) { validateFullName ( fullName ) ; if ( this . parent ) { illegalChildOperation ( 'typeInjection' ) ; } addTypeInjection ( this . typeInjections , type , property , fullName ) ; }
1094	function ( fullName , property , injectionName ) { if ( this . parent ) { illegalChildOperation ( 'injection' ) ; } validateFullName ( injectionName ) ; var normalizedInjectionName = this . normalize ( injectionName ) ; if ( fullName . indexOf ( ':' ) === - 1 ) { return this . typeInjection ( fullName , property , normalizedInjectionName ) ; } validateFullName ( fullName ) ; var normalizedName = this . normalize ( fullName ) ; addInjection ( this . injections , normalizedName , property , normalizedInjectionName ) ; }
1095	function ( type , property , fullName ) { if ( this . parent ) { illegalChildOperation ( 'factoryTypeInjection' ) ; } addTypeInjection ( this . factoryTypeInjections , type , property , this . normalize ( fullName ) ) ; }
1096	function ( key ) { var dict = this . dict ; if ( dict . hasOwnProperty ( key ) ) { return dict [ key ] ; } if ( this . parent ) { return this . parent . get ( key ) ; } }
1097	function ( key ) { var dict = this . dict ; if ( dict . hasOwnProperty ( key ) ) { return true ; } if ( this . parent ) { return this . parent . has ( key ) ; } return false ; }
1098	function ( callback , binding ) { var dict = this . dict ; for ( var prop in dict ) { if ( dict . hasOwnProperty ( prop ) ) { callback . call ( binding , prop , dict [ prop ] ) ; } } }
1099	function ( str ) { var cache = STRING_DASHERIZE_CACHE , hit = cache . hasOwnProperty ( str ) , ret ; if ( hit ) { return cache [ str ] ; } else { ret = Ember . String . decamelize ( str ) . replace ( STRING_DASHERIZE_REGEXP , '-' ) ; cache [ str ] = ret ; } return ret ; }
1100	function ( keyName , increment ) { if ( Ember . isNone ( increment ) ) { increment = 1 ; } Ember . assert ( "Must pass a numeric value to incrementProperty" , ( ! isNaN ( parseFloat ( increment ) ) && isFinite ( increment ) ) ) ; set ( this , keyName , ( get ( this , keyName ) || 0 ) + increment ) ; return get ( this , keyName ) ; }
1101	function ( keyName , decrement ) { if ( Ember . isNone ( decrement ) ) { decrement = 1 ; } Ember . assert ( "Must pass a numeric value to decrementProperty" , ( ! isNaN ( parseFloat ( decrement ) ) && isFinite ( decrement ) ) ) ; set ( this , keyName , ( get ( this , keyName ) || 0 ) - decrement ) ; return get ( this , keyName ) ; }
1102	function ( ) { var Class = makeCtor ( ) , proto ; Class . ClassMixin = Mixin . create ( this . ClassMixin ) ; Class . PrototypeMixin = Mixin . create ( this . PrototypeMixin ) ; Class . ClassMixin . ownerConstructor = Class ; Class . PrototypeMixin . ownerConstructor = Class ; reopen . apply ( Class . PrototypeMixin , arguments ) ; Class . superclass = this ; Class . __super__ = this . prototype ; proto = Class . prototype = o_create ( this . prototype ) ; proto . constructor = Class ; generateGuid ( proto ) ; meta ( proto ) . proto = proto ; Class . ClassMixin . apply ( Class ) ; return Class ; }
1103	function ( key ) { var meta = this . proto ( ) [ META_KEY ] , desc = meta && meta . descs [ key ] ; Ember . assert ( "metaForProperty() could not find a computed property with key '" + key + "'." , ! ! desc && desc instanceof Ember . ComputedProperty ) ; return desc . _meta || { } ; }
1104	function ( key , value ) { var exactValue = function ( item ) { return get ( item , key ) === value ; } , hasValue = function ( item ) { return ! ! get ( item , key ) ; } , use = ( arguments . length === 2 ? exactValue : hasValue ) ; return this . reject ( use ) ; }
1105	function ( value ) { if ( ! this . contains ( value ) ) return this ; var ret = Ember . A ( ) ; this . forEach ( function ( k ) { if ( k !== value ) ret [ ret . length ] = k ; } ) ; return ret ; }
1106	function ( ) { var ret = Ember . A ( ) ; this . forEach ( function ( k ) { if ( a_indexOf ( ret , k ) < 0 ) ret . push ( k ) ; } ) ; return ret ; }
1107	function ( startIdx , removeAmt , addAmt ) { if ( startIdx === undefined ) { startIdx = 0 ; removeAmt = addAmt = - 1 ; } else { if ( removeAmt === undefined ) removeAmt = - 1 ; if ( addAmt === undefined ) addAmt = - 1 ; } if ( Ember . isWatching ( this , '@each' ) ) { get ( this , '@each' ) ; } Ember . sendEvent ( this , '@array:before' , [ this , startIdx , removeAmt , addAmt ] ) ; var removing , lim ; if ( startIdx >= 0 && removeAmt >= 0 && get ( this , 'hasEnumerableObservers' ) ) { removing = [ ] ; lim = startIdx + removeAmt ; for ( var idx = startIdx ; idx < lim ; idx ++ ) removing . push ( this . objectAt ( idx ) ) ; } else { removing = removeAmt ; } this . enumerableContentWillChange ( removing , addAmt ) ; return this ; }
1108	function ( startIdx , removeAmt , addAmt ) { if ( startIdx === undefined ) { startIdx = 0 ; removeAmt = addAmt = - 1 ; } else { if ( removeAmt === undefined ) removeAmt = - 1 ; if ( addAmt === undefined ) addAmt = - 1 ; } var adding , lim ; if ( startIdx >= 0 && addAmt >= 0 && get ( this , 'hasEnumerableObservers' ) ) { adding = [ ] ; lim = startIdx + addAmt ; for ( var idx = startIdx ; idx < lim ; idx ++ ) adding . push ( this . objectAt ( idx ) ) ; } else { adding = addAmt ; } this . enumerableContentDidChange ( removeAmt , adding ) ; Ember . sendEvent ( this , '@array:change' , [ this , startIdx , removeAmt , addAmt ] ) ; var length = get ( this , 'length' ) , cachedFirst = cacheFor ( this , 'firstObject' ) , cachedLast = cacheFor ( this , 'lastObject' ) ; if ( this . objectAt ( 0 ) !== cachedFirst ) { Ember . propertyWillChange ( this , 'firstObject' ) ; Ember . propertyDidChange ( this , 'firstObject' ) ; } if ( this . objectAt ( length - 1 ) !== cachedLast ) { Ember . propertyWillChange ( this , 'lastObject' ) ; Ember . propertyDidChange ( this , 'lastObject' ) ; } return this ; }
1109	function ReduceComputedProperty ( options ) { var cp = this ; this . options = options ; this . _dependentKeys = null ; this . _itemPropertyKeys = { } ; this . _previousItemPropertyKeys = { } ; this . readOnly ( ) ; this . cacheable ( ) ; this . recomputeOnce = function ( propertyName ) { Ember . run . once ( this , recompute , propertyName ) ; } ; var recompute = function ( propertyName ) { var dependentKeys = cp . _dependentKeys , meta = cp . _instanceMeta ( this , propertyName ) , callbacks = cp . _callbacks ( ) ; reset . call ( this , cp , propertyName ) ; meta . dependentArraysObserver . suspendArrayObservers ( function ( ) { forEach ( cp . _dependentKeys , function ( dependentKey ) { Ember . assert ( "dependent array " + dependentKey + " must be an `Ember.Array`. " + "If you are not extending arrays, you will need to wrap native arrays with `Ember.A`" , ! ( Ember . isArray ( get ( this , dependentKey ) ) && ! Ember . Array . detect ( get ( this , dependentKey ) ) ) ) ; if ( ! partiallyRecomputeFor ( this , dependentKey ) ) { return ; } var dependentArray = get ( this , dependentKey ) , previousDependentArray = meta . dependentArrays [ dependentKey ] ; if ( dependentArray === previousDependentArray ) { if ( cp . _previousItemPropertyKeys [ dependentKey ] ) { delete cp . _previousItemPropertyKeys [ dependentKey ] ; meta . dependentArraysObserver . setupPropertyObservers ( dependentKey , cp . _itemPropertyKeys [ dependentKey ] ) ; } } else { meta . dependentArrays [ dependentKey ] = dependentArray ; if ( previousDependentArray ) { meta . dependentArraysObserver . teardownObservers ( previousDependentArray , dependentKey ) ; } if ( dependentArray ) { meta . dependentArraysObserver . setupObservers ( dependentArray , dependentKey ) ; } } } , this ) ; } , this ) ; forEach ( cp . _dependentKeys , function ( dependentKey ) { if ( ! partiallyRecomputeFor ( this , dependentKey ) ) { return ; } var dependentArray = get ( this , dependentKey ) ; if ( dependentArray ) { addItems . call ( this , dependentArray , callbacks , cp , propertyName , meta ) ; } } , this ) ; } ; this . func = function ( propertyName ) { Ember . assert ( "Computed reduce values require at least one dependent key" , cp . _dependentKeys ) ; recompute . call ( this , propertyName ) ; return cp . _instanceMeta ( this , propertyName ) . getValue ( ) ; } ; }
1110	function ( objects ) { Ember . beginPropertyChanges ( this ) ; forEach ( objects , function ( obj ) { this . addObject ( obj ) ; } , this ) ; Ember . endPropertyChanges ( this ) ; return this ; }
1111	function ( objects ) { Ember . beginPropertyChanges ( this ) ; forEach ( objects , function ( obj ) { this . removeObject ( obj ) ; } , this ) ; Ember . endPropertyChanges ( this ) ; return this ; }
1112	function ( name ) { var args = [ ] , i , l ; for ( i = 1 , l = arguments . length ; i < l ; i ++ ) { args . push ( arguments [ i ] ) ; } Ember . sendEvent ( this , name , args ) ; }
1113	function ( resolve , reject , label ) { var deferred , promise , entity ; entity = this ; deferred = get ( this , '_deferred' ) ; promise = deferred . promise ; function fulfillmentHandler ( fulfillment ) { if ( fulfillment === promise ) { return resolve ( entity ) ; } else { return resolve ( fulfillment ) ; } } return promise . then ( resolve && fulfillmentHandler , reject , label ) ; }
1114	function ( value ) { var deferred , promise ; deferred = get ( this , '_deferred' ) ; promise = deferred . promise ; if ( value === this ) { deferred . resolve ( promise ) ; } else { deferred . resolve ( value ) ; } }
1115	function ( props ) { var hashName ; if ( ! props . _actions ) { Ember . assert ( "'actions' should not be a function" , typeof ( props . actions ) !== 'function' ) ; if ( typeOf ( props . actions ) === 'object' ) { hashName = 'actions' ; } else if ( typeOf ( props . events ) === 'object' ) { Ember . deprecate ( 'Action handlers contained in an `events` object are deprecated in favor of putting them in an `actions` object' , false ) ; hashName = 'events' ; } if ( hashName ) { props . _actions = Ember . merge ( props . _actions || { } , props [ hashName ] ) ; } delete props [ hashName ] ; } }
1116	function ( actionName ) { var args = [ ] . slice . call ( arguments , 1 ) , target ; if ( this . _actions && this . _actions [ actionName ] ) { if ( this . _actions [ actionName ] . apply ( this , args ) === true ) { } else { return ; } } else if ( ! Ember . FEATURES . isEnabled ( 'ember-routing-drop-deprecated-action-style' ) && this . deprecatedSend && this . deprecatedSendHandles && this . deprecatedSendHandles ( actionName ) ) { Ember . warn ( "The current default is deprecated but will prefer to handle actions directly on the controller instead of a similarly named action in the actions hash. To turn off this deprecated feature set: Ember.FEATURES['ember-routing-drop-deprecated-action-style'] = true" ) ; if ( this . deprecatedSend . apply ( this , [ ] . slice . call ( arguments ) ) === true ) { } else { return ; } } if ( target = get ( this , 'target' ) ) { Ember . assert ( "The `target` for " + this + " (" + target + ") does not have a `send` method" , typeof target . send === 'function' ) ; target . send . apply ( target , arguments ) ; } }
1117	function ( index , newItems ) { var count = get ( newItems , 'length' ) ; if ( count < 1 ) { return ; } var match = this . _findArrayOperation ( index ) , arrayOperation = match . operation , arrayOperationIndex = match . index , arrayOperationRangeStart = match . rangeStart , composeIndex , splitIndex , splitItems , splitArrayOperation , newArrayOperation ; newArrayOperation = new ArrayOperation ( INSERT , count , newItems ) ; if ( arrayOperation ) { if ( ! match . split ) { this . _operations . splice ( arrayOperationIndex , 0 , newArrayOperation ) ; composeIndex = arrayOperationIndex ; } else { this . _split ( arrayOperationIndex , index - arrayOperationRangeStart , newArrayOperation ) ; composeIndex = arrayOperationIndex + 1 ; } } else { this . _operations . push ( newArrayOperation ) ; composeIndex = arrayOperationIndex ; } this . _composeInsert ( composeIndex ) ; }
1118	function ( index , count ) { if ( count < 1 ) { return ; } var match = this . _findArrayOperation ( index ) , arrayOperation = match . operation , arrayOperationIndex = match . index , arrayOperationRangeStart = match . rangeStart , newArrayOperation , composeIndex ; newArrayOperation = new ArrayOperation ( DELETE , count ) ; if ( ! match . split ) { this . _operations . splice ( arrayOperationIndex , 0 , newArrayOperation ) ; composeIndex = arrayOperationIndex ; } else { this . _split ( arrayOperationIndex , index - arrayOperationRangeStart , newArrayOperation ) ; composeIndex = arrayOperationIndex + 1 ; } return this . _composeDelete ( composeIndex ) ; }
1119	function ( index ) { var newArrayOperation = this . _operations [ index ] , leftArrayOperation = this . _operations [ index - 1 ] , rightArrayOperation = this . _operations [ index + 1 ] , leftOp = leftArrayOperation && leftArrayOperation . type , rightOp = rightArrayOperation && rightArrayOperation . type ; if ( leftOp === INSERT ) { leftArrayOperation . count += newArrayOperation . count ; leftArrayOperation . items = leftArrayOperation . items . concat ( newArrayOperation . items ) ; if ( rightOp === INSERT ) { leftArrayOperation . count += rightArrayOperation . count ; leftArrayOperation . items = leftArrayOperation . items . concat ( rightArrayOperation . items ) ; this . _operations . splice ( index , 2 ) ; } else { this . _operations . splice ( index , 1 ) ; } } else if ( rightOp === INSERT ) { newArrayOperation . count += rightArrayOperation . count ; newArrayOperation . items = newArrayOperation . items . concat ( rightArrayOperation . items ) ; this . _operations . splice ( index + 1 , 1 ) ; } }
1120	function ArrayOperation ( operation , count , items ) { this . type = operation ; this . count = count ; this . items = items ; }
1121	function ArrayOperationMatch ( operation , index , split , rangeStart ) { this . operation = operation ; this . index = index ; this . split = split ; this . rangeStart = rangeStart ; }
1122	function ( index , match ) { var returnValue = - 1 , itemType = match ? RETAIN : FILTER , self = this ; this . _findOperation ( index , function ( operation , operationIndex , rangeStart , rangeEnd , seenInSubArray ) { var newOperation , splitOperation ; if ( itemType === operation . type ) { ++ operation . count ; } else if ( index === rangeStart ) { self . _operations . splice ( operationIndex , 0 , new Operation ( itemType , 1 ) ) ; } else { newOperation = new Operation ( itemType , 1 ) ; splitOperation = new Operation ( operation . type , rangeEnd - index + 1 ) ; operation . count = index - rangeStart ; self . _operations . splice ( operationIndex + 1 , 0 , newOperation , splitOperation ) ; } if ( match ) { if ( operation . type === RETAIN ) { returnValue = seenInSubArray + ( index - rangeStart ) ; } else { returnValue = seenInSubArray ; } } self . _composeAt ( operationIndex ) ; } , function ( seenInSubArray ) { self . _operations . push ( new Operation ( itemType , 1 ) ) ; if ( match ) { returnValue = seenInSubArray ; } self . _composeAt ( self . _operations . length - 1 ) ; } ) ; return returnValue ; }
1123	function ( index ) { var returnValue = - 1 , self = this ; this . _findOperation ( index , function ( operation , operationIndex , rangeStart , rangeEnd , seenInSubArray ) { if ( operation . type === RETAIN ) { returnValue = seenInSubArray + ( index - rangeStart ) ; } if ( operation . count > 1 ) { -- operation . count ; } else { self . _operations . splice ( operationIndex , 1 ) ; self . _composeAt ( operationIndex ) ; } } , function ( ) { throw new Ember . Error ( "Can't remove an item that has never been added." ) ; } ) ; return returnValue ; }
1124	function ( keyName , value ) { var ret ; ret = new EachArray ( this . _content , keyName , this ) ; Ember . defineProperty ( this , keyName , null , ret ) ; this . beginObservingContentKey ( keyName ) ; return ret ; }
1125	function ( idx , amt , objects ) { if ( this . isFrozen ) throw Ember . FROZEN_ERROR ; var len = objects ? get ( objects , 'length' ) : 0 ; this . arrayContentWillChange ( idx , amt , len ) ; if ( len === 0 ) { this . splice ( idx , amt ) ; } else { replace ( this , idx , amt , objects ) ; } this . arrayContentDidChange ( idx , amt , len ) ; return this ; }
1126	function ( ) { if ( this . isFrozen ) { throw new Ember . Error ( Ember . FROZEN_ERROR ) ; } var len = get ( this , 'length' ) ; if ( len === 0 ) { return this ; } var guid ; this . enumerableContentWillChange ( len , 0 ) ; Ember . propertyWillChange ( this , 'firstObject' ) ; Ember . propertyWillChange ( this , 'lastObject' ) ; for ( var i = 0 ; i < len ; i ++ ) { guid = guidFor ( this [ i ] ) ; delete this [ guid ] ; delete this [ i ] ; } set ( this , 'length' , 0 ) ; Ember . propertyDidChange ( this , 'firstObject' ) ; Ember . propertyDidChange ( this , 'lastObject' ) ; this . enumerableContentDidChange ( len , 0 ) ; return this ; }
1127	function ( ) { if ( get ( this , 'isFrozen' ) ) throw new Ember . Error ( Ember . FROZEN_ERROR ) ; var obj = this . length > 0 ? this [ this . length - 1 ] : null ; this . remove ( obj ) ; return obj ; }
1128	function ( element , id ) { if ( element . getAttribute ( 'id' ) === id ) { return element ; } var len = element . childNodes . length , idx , node , found ; for ( idx = 0 ; idx < len ; idx ++ ) { node = element . childNodes [ idx ] ; found = node . nodeType === 1 && findChildById ( node , id ) ; if ( found ) { return found ; } } }
1129	function ( className ) { this . elementClasses = ( this . elementClasses || new ClassSet ( ) ) ; this . elementClasses . add ( className ) ; this . classes = this . elementClasses . list ; return this ; }
1130	function ( name , value ) { var attributes = this . elementAttributes = ( this . elementAttributes || { } ) ; if ( arguments . length === 1 ) { return attributes [ name ] ; } else { attributes [ name ] = value ; } return this ; }
1131	function ( name , value ) { var properties = this . elementProperties = ( this . elementProperties || { } ) ; if ( arguments . length === 1 ) { return properties [ name ] ; } else { properties [ name ] = value ; } return this ; }
1132	function ( ) { if ( this . _hasElement && this . _element ) { var thisElement = this . element ( ) , outerHTML = thisElement . outerHTML ; if ( typeof outerHTML === 'undefined' ) { return Ember . $ ( '<div/>' ) . append ( thisElement ) . html ( ) ; } return outerHTML ; } else { return this . innerString ( ) ; } }
1133	function ( addedEvents , rootElement ) { var event , events = get ( this , 'events' ) ; Ember . $ . extend ( events , addedEvents || { } ) ; if ( ! Ember . isNone ( rootElement ) ) { set ( this , 'rootElement' , rootElement ) ; } rootElement = Ember . $ ( get ( this , 'rootElement' ) ) ; Ember . assert ( fmt ( 'You cannot use the same root element (%@) multiple times in an Ember.Application' , [ rootElement . selector || rootElement [ 0 ] . tagName ] ) , ! rootElement . is ( '.ember-application' ) ) ; Ember . assert ( 'You cannot make a new Ember.Application using a root element that is a descendent of an existing Ember.Application' , ! rootElement . closest ( '.ember-application' ) . length ) ; Ember . assert ( 'You cannot make a new Ember.Application using a root element that is an ancestor of an existing Ember.Application' , ! rootElement . find ( '.ember-application' ) . length ) ; rootElement . addClass ( 'ember-application' ) ; Ember . assert ( 'Unable to add "ember-application" class to rootElement. Make sure you set rootElement to the body or an element in the body.' , rootElement . is ( '.ember-application' ) ) ; for ( event in events ) { if ( events . hasOwnProperty ( event ) ) { this . setupHandler ( rootElement , event , events [ event ] ) ; } } }
1134	function ( rootElement , event , eventName ) { var self = this ; rootElement . on ( event + '.ember' , '.ember-view' , function ( evt , triggeringManager ) { var view = Ember . View . views [ this . id ] , result = true , manager = null ; manager = self . _findNearestEventManager ( view , eventName ) ; if ( manager && manager !== triggeringManager ) { result = self . _dispatchEvent ( manager , evt , eventName , view ) ; } else if ( view ) { result = self . _bubbleEvent ( view , evt , eventName ) ; } else { evt . stopPropagation ( ) ; } return result ; } ) ; rootElement . on ( event + '.ember' , '[data-ember-action]' , function ( evt ) { var actionId = Ember . $ ( evt . currentTarget ) . attr ( 'data-ember-action' ) , action = Ember . Handlebars . ActionHelper . registeredActions [ actionId ] ; if ( action && action . eventName === eventName ) { return action . handler ( evt ) ; } } ) ; }
1135	function ( klass ) { Ember . deprecate ( "nearestInstanceOf is deprecated and will be removed from future releases. Use nearestOfType." ) ; var view = get ( this , 'parentView' ) ; while ( view ) { if ( view instanceof klass ) { return view ; } view = get ( view , 'parentView' ) ; } }
1136	function ( property ) { var view = get ( this , 'parentView' ) ; while ( view ) { if ( property in view ) { return view ; } view = get ( view , 'parentView' ) ; } }
1137	function ( klass ) { var view = get ( this , 'parentView' ) ; while ( view ) { if ( get ( view , 'parentView' ) instanceof klass ) { return view ; } view = get ( view , 'parentView' ) ; } }
1138	function ( buffer ) { var template = get ( this , 'layout' ) || get ( this , 'template' ) ; if ( template ) { var context = get ( this , 'context' ) ; var keywords = this . cloneKeywords ( ) ; var output ; var data = { view : this , buffer : buffer , isRenderData : true , keywords : keywords , insideGroup : get ( this , 'templateData.insideGroup' ) } ; Ember . assert ( 'template must be a function. Did you mean to call Ember.Handlebars.compile("...") or specify templateName instead?' , typeof template === 'function' ) ; output = template ( context , { data : data } ) ; if ( output !== undefined ) { buffer . push ( output ) ; } } }
1139	function ( ) { newClass = this . _classStringForProperty ( binding ) ; elem = this . $ ( ) ; if ( oldClass ) { elem . removeClass ( oldClass ) ; classNames . removeObject ( oldClass ) ; } if ( newClass ) { elem . addClass ( newClass ) ; oldClass = newClass ; } else { oldClass = null ; } }
1140	function ( buffer , attributeBindings ) { var attributeValue , unspecifiedAttributeBindings = this . _unspecifiedAttributeBindings = this . _unspecifiedAttributeBindings || { } ; a_forEach ( attributeBindings , function ( binding ) { var split = binding . split ( ':' ) , property = split [ 0 ] , attributeName = split [ 1 ] || property ; if ( property in this ) { this . _setupAttributeBindingObservation ( property , attributeName ) ; attributeValue = get ( this , property ) ; Ember . View . applyAttributeBindings ( buffer , attributeName , attributeValue ) ; } else { unspecifiedAttributeBindings [ property ] = attributeName ; } } , this ) ; this . setUnknownProperty = this . _setUnknownProperty ; }
1141	function ( key , value ) { var attributeName = this . _unspecifiedAttributeBindings && this . _unspecifiedAttributeBindings [ key ] ; if ( attributeName ) { this . _setupAttributeBindingObservation ( key , attributeName ) ; } defineProperty ( this , key ) ; return set ( this , key , value ) ; }
1142	function ( path ) { var split = path . split ( ':' ) , propertyPath = split [ 0 ] , classNames = "" , className , falsyClassName ; if ( split . length > 1 ) { className = split [ 1 ] ; if ( split . length === 3 ) { falsyClassName = split [ 2 ] ; } classNames = ':' + className ; if ( falsyClassName ) { classNames += ":" + falsyClassName ; } } return { path : propertyPath , classNames : classNames , className : ( className === '' ) ? undefined : className , falsyClassName : falsyClassName } ; }
1143	function ( view , childView , options ) { var buffer = view . buffer , _childViews = view . _childViews ; childView = view . createChildView ( childView , options ) ; if ( ! _childViews . length ) { _childViews = view . _childViews = _childViews . slice ( ) ; } _childViews . push ( childView ) ; childView . renderToBuffer ( buffer ) ; view . propertyDidChange ( 'childViews' ) ; return childView ; }
1144	function ( view ) { view . clearBuffer ( ) ; var viewCollection = view . _notifyWillDestroyElement ( ) ; viewCollection . transitionTo ( 'preRender' , false ) ; return view ; }
1145	function ( view ) { view . triggerRecursively ( 'willClearRender' ) ; view . clearRenderedChildren ( ) ; view . domManager . replace ( view ) ; return view ; }
1146	function ( view ) { view . _notifyWillDestroyElement ( ) ; view . domManager . remove ( view ) ; set ( view , 'element' , null ) ; if ( view . _scheduledInsert ) { Ember . run . cancel ( view . _scheduledInsert ) ; view . _scheduledInsert = null ; } return view ; }
1147	function ( view , eventName , evt ) { if ( view . has ( eventName ) ) { return view . trigger ( eventName , evt ) ; } else { return true ; } }
1148	function ( views , start , removed ) { this . propertyWillChange ( 'childViews' ) ; if ( removed > 0 ) { var changedViews = views . slice ( start , start + removed ) ; this . currentState . childViewsWillChange ( this , views , start , removed ) ; this . initializeViews ( changedViews , null , null ) ; } }
1149	function ( views , start , removed , added ) { if ( added > 0 ) { var changedViews = views . slice ( start , start + added ) ; this . initializeViews ( changedViews , this , get ( this , 'templateData' ) ) ; this . currentState . childViewsDidChange ( this , views , start , added ) ; } this . propertyDidChange ( 'childViews' ) ; }
1150	function ( content , start , removedCount ) { var emptyView = get ( this , 'emptyView' ) ; if ( emptyView && emptyView instanceof Ember . View ) { emptyView . removeFromParent ( ) ; } var childViews = this . _childViews , childView , idx , len ; len = this . _childViews . length ; var removingAll = removedCount === len ; if ( removingAll ) { this . currentState . empty ( this ) ; this . invokeRecursively ( function ( view ) { view . removedFromDOM = true ; } , false ) ; } for ( idx = start + removedCount - 1 ; idx >= start ; idx -- ) { childView = childViews [ idx ] ; childView . destroy ( ) ; } }
1151	function ( content , start , removed , added ) { var addedViews = [ ] , view , item , idx , len , itemViewClass , emptyView ; len = content ? get ( content , 'length' ) : 0 ; if ( len ) { itemViewClass = get ( this , 'itemViewClass' ) ; if ( 'string' === typeof itemViewClass ) { itemViewClass = get ( itemViewClass ) || itemViewClass ; } Ember . assert ( fmt ( "itemViewClass must be a subclass of Ember.View, not %@" , [ itemViewClass ] ) , 'string' === typeof itemViewClass || Ember . View . detect ( itemViewClass ) ) ; for ( idx = start ; idx < start + added ; idx ++ ) { item = content . objectAt ( idx ) ; view = this . createChildView ( itemViewClass , { content : item , contentIndex : idx } ) ; addedViews . push ( view ) ; } } else { emptyView = get ( this , 'emptyView' ) ; if ( ! emptyView ) { return ; } if ( 'string' === typeof emptyView ) { emptyView = get ( emptyView ) || emptyView ; } emptyView = this . createChildView ( emptyView ) ; addedViews . push ( emptyView ) ; set ( this , 'emptyView' , emptyView ) ; if ( Ember . CoreView . detect ( emptyView ) ) { this . _createdEmptyView = emptyView ; } } this . replace ( start , 0 , addedViews ) ; }
1152	function ( action ) { var actionName , contexts = a_slice . call ( arguments , 1 ) ; if ( action === undefined ) { actionName = get ( this , 'action' ) ; Ember . assert ( "The default action was triggered on the component " + this . toString ( ) + ", but the action name (" + actionName + ") was not a string." , isNone ( actionName ) || typeof actionName === 'string' ) ; } else { actionName = get ( this , action ) ; Ember . assert ( "The " + action + " action was triggered on the component " + this . toString ( ) + ", but the action name (" + actionName + ") was not a string." , isNone ( actionName ) || typeof actionName === 'string' ) ; } if ( actionName === undefined ) { return ; } this . triggerAction ( { action : actionName , actionContext : contexts } ) ; }
1153	function evaluateUnboundHelper ( context , fn , normalizedProperties , options ) { var args = [ ] , hash = options . hash , boundOptions = hash . boundOptions , types = slice . call ( options . types , 1 ) , loc , len , property , propertyType , boundOption ; for ( boundOption in boundOptions ) { if ( ! boundOptions . hasOwnProperty ( boundOption ) ) { continue ; } hash [ boundOption ] = Ember . Handlebars . get ( context , boundOptions [ boundOption ] , options ) ; } for ( loc = 0 , len = normalizedProperties . length ; loc < len ; ++ loc ) { property = normalizedProperties [ loc ] ; propertyType = types [ loc ] ; if ( propertyType === "ID" ) { args . push ( Ember . Handlebars . get ( property . root , property . path , options ) ) ; } else { args . push ( property . path ) ; } } args . push ( options ) ; return fn . apply ( context , args ) ; }
1154	function ( view ) { var morph = view . morph ; view . transitionTo ( 'preRender' ) ; Ember . run . schedule ( 'render' , this , function renderMetamorphView ( ) { if ( view . isDestroying ) { return ; } view . clearRenderedChildren ( ) ; var buffer = view . renderToBuffer ( ) ; view . invokeRecursively ( function ( view ) { view . propertyWillChange ( 'element' ) ; } ) ; view . triggerRecursively ( 'willInsertElement' ) ; morph . replaceWith ( buffer . string ( ) ) ; view . transitionTo ( 'inDOM' ) ; view . invokeRecursively ( function ( view ) { view . propertyDidChange ( 'element' ) ; } ) ; view . triggerRecursively ( 'didInsertElement' ) ; notifyMutationListeners ( ) ; } ) ; }
1155	function bind ( property , options , preserveContext , shouldDisplay , valueNormalizer , childProperties ) { var data = options . data , fn = options . fn , inverse = options . inverse , view = data . view , currentContext = this , normalized , observer , i ; normalized = normalizePath ( currentContext , property , data ) ; if ( 'object' === typeof this ) { if ( data . insideGroup ) { observer = function ( ) { Ember . run . once ( view , 'rerender' ) ; } ; var template , context , result = handlebarsGet ( currentContext , property , options ) ; result = valueNormalizer ? valueNormalizer ( result ) : result ; context = preserveContext ? currentContext : result ; if ( shouldDisplay ( result ) ) { template = fn ; } else if ( inverse ) { template = inverse ; } template ( context , { data : options . data } ) ; } else { var bindView = view . createChildView ( Ember . _HandlebarsBoundView , { preserveContext : preserveContext , shouldDisplayFunc : shouldDisplay , valueNormalizerFunc : valueNormalizer , displayTemplate : fn , inverseTemplate : inverse , path : property , pathRoot : currentContext , previousContext : currentContext , isEscaped : ! options . hash . unescaped , templateData : options . data } ) ; if ( options . hash . controller ) { bindView . set ( '_contextController' , this . container . lookupFactory ( 'controller:' + options . hash . controller ) . create ( { container : currentContext . container , parentController : currentContext , target : currentContext } ) ) ; } view . appendChild ( bindView ) ; observer = function ( ) { Ember . run . scheduleOnce ( 'render' , bindView , 'rerenderIfNeeded' ) ; } ; } if ( normalized . path !== '' ) { view . registerObserver ( normalized . root , normalized . path , observer ) ; if ( childProperties ) { for ( i = 0 ; i < childProperties . length ; i ++ ) { view . registerObserver ( normalized . root , normalized . path + '.' + childProperties [ i ] , observer ) ; } } } } else { data . buffer . push ( handlebarsGetEscaped ( currentContext , property , options ) ) ; } }
1156	function _addMetamorphCheck ( ) { Ember . Handlebars . EachView . reopen ( { _checkMetamorph : Ember . on ( 'didInsertElement' , function ( ) { Ember . assert ( "The metamorph tags, " + this . morph . start + " and " + this . morph . end + ", have different parents.\nThe browser has fixed your template to output valid HTML (for example, check that you have properly closed all tags and have used a TBODY tag when creating a table with '{{#each}}')" , \n ) ; } ) } ) ; }
1157	function ( ) { if ( this . state ) { forEach ( this . state . handlerInfos , function ( handlerInfo ) { var handler = handlerInfo . handler ; if ( handler . exit ) { handler . exit ( ) ; } } ) ; } this . state = new TransitionState ( ) ; this . currentHandlerInfos = null ; }
1158	function ( ) { this . router = this . router || this . constructor . map ( Ember . K ) ; var router = this . router , location = get ( this , 'location' ) , container = this . container , self = this , initialURL = get ( this , 'initialURL' ) ; if ( get ( location , 'cancelRouterSetup' ) ) { return ; } this . _setupRouter ( router , location ) ; container . register ( 'view:default' , DefaultView ) ; container . register ( 'view:toplevel' , Ember . View . extend ( ) ) ; location . onUpdateURL ( function ( url ) { self . handleURL ( url ) ; } ) ; if ( typeof initialURL === "undefined" ) { initialURL = location . getURL ( ) ; } this . handleURL ( initialURL ) ; }
1159	function ( context , transition ) { var controllerName = this . controllerName || this . routeName , controller = this . controllerFor ( controllerName , true ) ; if ( ! controller ) { controller = this . generateController ( controllerName , context ) ; } this . controller = controller ; if ( this . setupControllers ) { Ember . deprecate ( "Ember.Route.setupControllers is deprecated. Please use Ember.Route.setupController(controller, model) instead." ) ; this . setupControllers ( controller , context ) ; } else { this . setupController ( controller , context ) ; } if ( this . renderTemplates ) { Ember . deprecate ( "Ember.Route.renderTemplates is deprecated. Please use Ember.Route.renderTemplate(controller, model) instead." ) ; this . renderTemplates ( context ) ; } else { this . renderTemplate ( controller , context ) ; } }
1160	function ( params , transition ) { var match , name , sawParams , value ; for ( var prop in params ) { if ( prop === 'queryParams' ) { continue ; } if ( match = prop . match ( / ^(.*)_id$ / ) ) { name = match [ 1 ] ; value = params [ prop ] ; } sawParams = true ; } if ( ! name && sawParams ) { return Ember . copy ( params ) ; } else if ( ! name ) { if ( transition . resolveIndex !== transition . state . handlerInfos . length - 1 ) { return ; } var parentModel = transition . state . handlerInfos [ transition . resolveIndex - 1 ] . context ; return parentModel ; } return this . findModel ( name , value ) ; }
1161	function ( model , params ) { if ( params . length < 1 ) { return ; } if ( ! model ) { return ; } var name = params [ 0 ] , object = { } ; if ( / _id$ / . test ( name ) && params . length === 1 ) { object [ name ] = get ( model , "id" ) ; } else { object = getProperties ( model , params ) ; } return object ; }
1162	function ( name , _skipAssert ) { var container = this . container , route = container . lookup ( 'route:' + name ) , controller ; if ( route && route . controllerName ) { name = route . controllerName ; } controller = container . lookup ( 'controller:' + name ) ; Ember . assert ( "The controller named '" + name + "' could not be found. Make sure " + "that this route exists and has already been entered at least " + "once. If you are accessing a controller not associated with a " + "route, make sure the controller class is explicitly defined." , controller || _skipAssert === true ) ; return controller ; }
1163	function ( options ) { if ( ! options || typeof options === "string" ) { var outletName = options ; options = { } ; options . outlet = outletName ; } options . parentView = options . parentView ? options . parentView . replace ( / \/ / g , '.' ) : parentTemplate ( this ) ; options . outlet = options . outlet || 'main' ; var parentView = this . router . _lookupActiveView ( options . parentView ) ; if ( parentView ) { parentView . disconnectOutlet ( options . outlet ) ; } }
1164	function ( ) { var helperParameters = this . parameters , linkTextPath = helperParameters . options . linkTextPath , paths = getResolvedPaths ( helperParameters ) , length = paths . length , path , i , normalizedPath ; if ( linkTextPath ) { normalizedPath = Ember . Handlebars . normalizePath ( helperParameters . context , linkTextPath , helperParameters . options . data ) ; this . registerObserver ( normalizedPath . root , normalizedPath . path , this , this . rerender ) ; } for ( i = 0 ; i < length ; i ++ ) { path = paths [ i ] ; if ( null === path ) { continue ; } normalizedPath = Ember . Handlebars . normalizePath ( helperParameters . context , path , helperParameters . options . data ) ; this . registerObserver ( normalizedPath . root , normalizedPath . path , this , this . _paramsChanged ) ; } var queryParamsObject = this . queryParamsObject ; if ( queryParamsObject ) { var values = queryParamsObject . values ; for ( var k in values ) { if ( ! values . hasOwnProperty ( k ) ) { continue ; } if ( queryParamsObject . types [ k ] === 'ID' ) { normalizedPath = Ember . Handlebars . normalizePath ( helperParameters . context , values [ k ] , helperParameters . options . data ) ; this . registerObserver ( normalizedPath . root , normalizedPath . path , this , this . _paramsChanged ) ; } } } }
1165	function ( event ) { if ( ! isSimpleClick ( event ) ) { return true ; } if ( this . preventDefault !== false ) { event . preventDefault ( ) ; } if ( this . bubbles === false ) { event . stopPropagation ( ) ; } if ( get ( this , '_isDisabled' ) ) { return false ; } if ( get ( this , 'loading' ) ) { Ember . Logger . warn ( "This link-to is in an inactive loading state because at least one of its parameters presently has a null/undefined value, or the provided route name is invalid." ) ; return false ; } var router = get ( this , 'router' ) , routeArgs = get ( this , 'routeArgs' ) ; var transition ; if ( get ( this , 'replace' ) ) { transition = router . replaceWith . apply ( router , routeArgs ) ; } else { transition = router . transitionTo . apply ( router , routeArgs ) ; } var url = router . router . generate . apply ( router . router , get ( this , 'routeArgs' ) ) ; Ember . run . scheduleOnce ( 'routerTransitions' , this , this . _eagerUpdateUrl , transition , url ) ; }
1166	function ( ) { var target = get ( this , 'target' ) , method = target . replaceRoute || target . replaceWith ; return method . apply ( target , arguments ) ; }
1167	function ( outletName , view ) { var existingView = get ( this , '_outlets.' + outletName ) ; return existingView && existingView . constructor === view . constructor && existingView . get ( 'template' ) === view . get ( 'template' ) && existingView . get ( 'context' ) === view . get ( 'context' ) ; }
1168	function ( ) { if ( this . isDestroyed ) return ; var outlets = get ( this , '_outlets' ) ; var pendingDisconnections = this . _pendingDisconnections ; this . _pendingDisconnections = null ; for ( var outletName in pendingDisconnections ) { set ( outlets , outletName , null ) ; } }
1169	function ( ) { var href = ( this . _location || this . location ) . href , hashIndex = href . indexOf ( '#' ) ; if ( hashIndex === - 1 ) { return '' ; } else { return href . substr ( hashIndex ) ; } }
1170	function ( path ) { var state = { path : path } ; get ( this , 'history' ) . replaceState ( state , null , path ) ; if ( ! supportsHistoryState ) { this . _historyState = state ; } this . _previousURL = this . getURL ( ) ; }
1171	function ( callback ) { var guid = Ember . guidFor ( this ) , self = this ; Ember . $ ( window ) . on ( 'popstate.ember-location-' + guid , function ( e ) { if ( ! popstateFired ) { popstateFired = true ; if ( self . getURL ( ) === self . _previousURL ) { return ; } } callback ( self . getURL ( ) ) ; } ) ; }
1172	function ( options ) { if ( options && options . rootURL ) { Ember . assert ( 'rootURL must end with a trailing forward slash e.g. "/app/"' , options . rootURL . charAt ( options . rootURL . length - 1 ) === '/' ) ; this . rootURL = options . rootURL ; } var historyPath , hashPath , cancelRouterSetup = false , implementationClass = this . _NoneLocation , currentPath = this . _getFullPath ( ) ; if ( this . _getSupportsHistory ( ) ) { historyPath = this . _getHistoryPath ( ) ; if ( currentPath === historyPath ) { implementationClass = this . _HistoryLocation ; } else { cancelRouterSetup = true ; this . _replacePath ( historyPath ) ; } } else if ( this . _getSupportsHashChange ( ) ) { hashPath = this . _getHashPath ( ) ; if ( currentPath === hashPath || ( currentPath === '/' && hashPath === '/#/' ) ) { implementationClass = this . _HashLocation ; } else { cancelRouterSetup = true ; this . _replacePath ( hashPath ) ; } } var implementation = implementationClass . create . apply ( implementationClass , arguments ) ; if ( cancelRouterSetup ) { set ( implementation , 'cancelRouterSetup' , true ) ; } return implementation ; }
1173	function ( fullName ) { var parsedName = this . parseName ( fullName ) , resolveMethodName = parsedName . resolveMethodName ; if ( ! ( parsedName . name && parsedName . type ) ) { throw new TypeError ( "Invalid fullName: `" + fullName + "`, must be of the form `type:name` " ) ; } if ( this [ resolveMethodName ] ) { var resolved = this [ resolveMethodName ] ( parsedName ) ; if ( resolved ) { return resolved ; } } return this . resolveOther ( parsedName ) ; }
1174	function ( parsedName ) { var templateName = parsedName . fullNameWithoutType . replace ( / \. / g , '/' ) ; if ( Ember . TEMPLATES [ templateName ] ) { return Ember . TEMPLATES [ templateName ] ; } templateName = decamelize ( templateName ) ; if ( Ember . TEMPLATES [ templateName ] ) { return Ember . TEMPLATES [ templateName ] ; } }
1175	function ( ) { if ( this . Router === false ) { return ; } var container = this . __container__ ; if ( this . Router ) { container . unregister ( 'router:main' ) ; container . register ( 'router:main' , this . Router ) ; } return container . lookupFactory ( 'router:main' ) ; }
1176	function ( ) { var self = this ; if ( ! this . $ || this . $ . isReady ) { Ember . run . schedule ( 'actions' , self , '_initialize' ) ; } else { this . $ ( ) . ready ( function runInitialize ( ) { Ember . run ( self , '_initialize' ) ; } ) ; } }
1177	function ( ) { Ember . assert ( "You must call advanceReadiness on an instance of Ember.Application" , this instanceof Ember . Application ) ; this . _readinessDeferrals -- ; if ( this . _readinessDeferrals === 0 ) { Ember . run . once ( this , this . didBecomeReady ) ; } }
1178	function ( ) { var customEvents = get ( this , 'customEvents' ) , rootElement = get ( this , 'rootElement' ) , dispatcher = this . __container__ . lookup ( 'event_dispatcher:main' ) ; set ( this , 'eventDispatcher' , dispatcher ) ; dispatcher . setup ( customEvents , rootElement ) ; }
1179	function ( namespace ) { var container = new Ember . Container ( ) ; Ember . Container . defaultContainer = new DeprecatedContainer ( container ) ; container . set = Ember . set ; container . resolver = resolverFor ( namespace ) ; container . normalize = container . resolver . normalize ; container . describe = container . resolver . describe ; container . makeToString = container . resolver . makeToString ; container . optionsForType ( 'component' , { singleton : false } ) ; container . optionsForType ( 'view' , { singleton : false } ) ; container . optionsForType ( 'template' , { instantiate : false } ) ; container . optionsForType ( 'helper' , { instantiate : false } ) ; container . register ( 'application:main' , namespace , { instantiate : false } ) ; container . register ( 'controller:basic' , Ember . Controller , { instantiate : false } ) ; container . register ( 'controller:object' , Ember . ObjectController , { instantiate : false } ) ; container . register ( 'controller:array' , Ember . ArrayController , { instantiate : false } ) ; container . register ( 'route:basic' , Ember . Route , { instantiate : false } ) ; container . register ( 'event_dispatcher:main' , Ember . EventDispatcher ) ; container . register ( 'router:main' , Ember . Router ) ; container . injection ( 'router:main' , 'namespace' , 'application:main' ) ; container . register ( 'location:auto' , Ember . AutoLocation ) ; container . register ( 'location:hash' , Ember . HashLocation ) ; container . register ( 'location:history' , Ember . HistoryLocation ) ; container . register ( 'location:none' , Ember . NoneLocation ) ; container . injection ( 'controller' , 'target' , 'router:main' ) ; container . injection ( 'controller' , 'namespace' , 'application:main' ) ; container . injection ( 'route' , 'router' , 'router:main' ) ; container . injection ( 'location' , 'rootURL' , '-location-setting:root-url' ) ; container . register ( 'resolver-for-debugging:main' , container . resolver . __resolver__ , { instantiate : false } ) ; container . injection ( 'container-debug-adapter:main' , 'resolver' , 'resolver-for-debugging:main' ) ; container . injection ( 'data-adapter:main' , 'containerDebugAdapter' , 'container-debug-adapter:main' ) ; container . register ( 'container-debug-adapter:main' , Ember . ContainerDebugAdapter ) ; return container ; }
1180	function ( type , recordsAdded , recordsUpdated , recordsRemoved ) { var self = this , releaseMethods = Ember . A ( ) , records = this . getRecords ( type ) , release ; var recordUpdated = function ( updatedRecord ) { recordsUpdated ( [ updatedRecord ] ) ; } ; var recordsToSend = records . map ( function ( record ) { releaseMethods . push ( self . observeRecord ( record , recordUpdated ) ) ; return self . wrapRecord ( record ) ; } ) ; var contentDidChange = function ( array , idx , removedCount , addedCount ) { for ( var i = idx ; i < idx + addedCount ; i ++ ) { var record = array . objectAt ( i ) ; var wrapped = self . wrapRecord ( record ) ; releaseMethods . push ( self . observeRecord ( record , recordUpdated ) ) ; recordsAdded ( [ wrapped ] ) ; } if ( removedCount ) { recordsRemoved ( idx , removedCount ) ; } } ; var observer = { didChange : contentDidChange , willChange : Ember . K } ; records . addArrayObserver ( self , observer ) ; release = function ( ) { releaseMethods . forEach ( function ( fn ) { fn ( ) ; } ) ; records . removeArrayObserver ( self , observer ) ; self . releaseMethods . removeObject ( release ) ; } ; recordsAdded ( recordsToSend ) ; this . releaseMethods . pushObject ( release ) ; return release ; }
1181	function ( type , typesUpdated ) { var self = this , records = this . getRecords ( type ) ; var onChange = function ( ) { typesUpdated ( [ self . wrapModelType ( type ) ] ) ; } ; var observer = { didChange : function ( ) { Ember . run . scheduleOnce ( 'actions' , this , onChange ) ; } , willChange : Ember . K } ; records . addArrayObserver ( this , observer ) ; var release = function ( ) { records . removeArrayObserver ( self , observer ) ; } ; return release ; }
1182	function ( ) { var namespaces = Ember . A ( Ember . Namespace . NAMESPACES ) , types = Ember . A ( ) ; namespaces . forEach ( function ( namespace ) { for ( var key in namespace ) { if ( ! namespace . hasOwnProperty ( key ) ) { continue ; } var name = Ember . String . dasherize ( key ) ; if ( ! ( namespace instanceof Ember . Application ) && namespace . toString ( ) ) { name = namespace + '/' + name ; } types . push ( name ) ; } } ) ; return types ; }
1183	function ( context , callback ) { if ( arguments . length === 1 ) { callback = context ; context = null ; } if ( ! this . waiters ) { this . waiters = Ember . A ( ) ; } this . waiters . push ( [ context , callback ] ) ; }
1184	function ( context , callback ) { var pair ; if ( ! this . waiters ) { return ; } if ( arguments . length === 1 ) { callback = context ; context = null ; } pair = [ context , callback ] ; this . waiters = Ember . A ( this . waiters . filter ( function ( elt ) { return Ember . compare ( elt , pair ) !== 0 ; } ) ) ; }
1185	function ( ) { for ( var name in helpers ) { this . helperContainer [ name ] = this . originalMethods [ name ] ; delete this . testHelpers [ name ] ; delete this . originalMethods [ name ] ; } }
1186	function protoWrap ( proto , name , callback , isAsync ) { proto [ name ] = function ( ) { var args = arguments ; if ( isAsync ) { return callback . apply ( this , args ) ; } else { return this . then ( function ( ) { return callback . apply ( this , args ) ; } ) ; } } ; }
1187	function toPropertyDescriptor ( obj ) { if ( Object ( obj ) !== obj ) { throw new TypeError ( "property descriptor should be an Object, given: " + obj ) ; } var desc = { } ; if ( 'enumerable' in obj ) { desc . enumerable = ! ! obj . enumerable ; } if ( 'configurable' in obj ) { desc . configurable = ! ! obj . configurable ; } if ( 'value' in obj ) { desc . value = obj . value ; } if ( 'writable' in obj ) { desc . writable = ! ! obj . writable ; } if ( 'get' in obj ) { var getter = obj . get ; if ( getter !== undefined && typeof getter !== "function" ) { throw new TypeError ( "property descriptor 'get' attribute must be " + "callable or undefined, given: " + getter ) ; } desc . get = getter ; } if ( 'set' in obj ) { var setter = obj . set ; if ( setter !== undefined && typeof setter !== "function" ) { throw new TypeError ( "property descriptor 'set' attribute must be " + "callable or undefined, given: " + setter ) ; } desc . set = setter ; } if ( 'get' in desc || 'set' in desc ) { if ( 'value' in desc || 'writable' in desc ) { throw new TypeError ( "property descriptor cannot be both a data and an " + "accessor descriptor: " + obj ) ; } } return desc ; }
1188	function normalizePropertyDescriptor ( attributes ) { var desc = toPropertyDescriptor ( attributes ) ; for ( var name in attributes ) { if ( ! isStandardAttribute ( name ) ) { Object . defineProperty ( desc , name , { value : attributes [ name ] , writable : true , enumerable : true , configurable : true } ) ; } } return desc ; }
1189	function isCompatibleDescriptor ( extensible , current , desc ) { if ( current === undefined && extensible === false ) { return false ; } if ( current === undefined && extensible === true ) { return true ; } if ( isEmptyDescriptor ( desc ) ) { return true ; } if ( isEquivalentDescriptor ( current , desc ) ) { return true ; } if ( current . configurable === false ) { if ( desc . configurable === true ) { return false ; } if ( 'enumerable' in desc && desc . enumerable !== current . enumerable ) { return false ; } } if ( isGenericDescriptor ( desc ) ) { return true ; } if ( isDataDescriptor ( current ) !== isDataDescriptor ( desc ) ) { if ( current . configurable === false ) { return false ; } return true ; } if ( isDataDescriptor ( current ) && isDataDescriptor ( desc ) ) { if ( current . configurable === false ) { if ( current . writable === false && desc . writable === true ) { return false ; } if ( current . writable === false ) { if ( 'value' in desc && ! sameValue ( desc . value , current . value ) ) { return false ; } } } return true ; } if ( isAccessorDescriptor ( current ) && isAccessorDescriptor ( desc ) ) { if ( current . configurable === false ) { if ( 'set' in desc && ! sameValue ( desc . set , current . set ) ) { return false ; } if ( 'get' in desc && ! sameValue ( desc . get , current . get ) ) { return false ; } } } return true ; }
1190	function ( trapName ) { var trap = this . handler [ trapName ] ; if ( trap === undefined ) { return undefined ; } if ( typeof trap !== "function" ) { throw new TypeError ( trapName + " trap is not callable: " + trap ) ; } return trap ; }
1191	function ( name ) { var handler = this ; if ( ! handler . has ( name ) ) return undefined ; return { get : function ( ) { return handler . get ( this , name ) ; } , set : function ( val ) { if ( handler . set ( this , name , val ) ) { return val ; } else { throw new TypeError ( "failed assignment to " + name ) ; } } , enumerable : true , configurable : true } ; }
1192	function ( ) { var trap = this . getTrap ( "freeze" ) ; if ( trap === undefined ) { return Reflect . freeze ( this . target ) ; } var success = trap . call ( this . handler , this . target ) ; success = ! ! success ; if ( success ) { if ( ! Object_isFrozen ( this . target ) ) { throw new TypeError ( "can't report non-frozen object as frozen: " + this . target ) ; } } return success ; }
1193	function ( ) { var trap = this . getTrap ( "seal" ) ; if ( trap === undefined ) { return Reflect . seal ( this . target ) ; } var success = trap . call ( this . handler , this . target ) ; success = ! ! success ; if ( success ) { if ( ! Object_isSealed ( this . target ) ) { throw new TypeError ( "can't report non-sealed object as sealed: " + this . target ) ; } } return success ; }
1194	function ( ) { var trap = this . getTrap ( "preventExtensions" ) ; if ( trap === undefined ) { return Reflect . preventExtensions ( this . target ) ; } var success = trap . call ( this . handler , this . target ) ; success = ! ! success ; if ( success ) { if ( Object_isExtensible ( this . target ) ) { throw new TypeError ( "can't report extensible object as non-extensible: " + this . target ) ; } } return success ; }
1195	function ( name ) { "use strict" ; var trap = this . getTrap ( "deleteProperty" ) ; if ( trap === undefined ) { return Reflect . deleteProperty ( this . target , name ) ; } name = String ( name ) ; var res = trap . call ( this . handler , this . target , name ) ; res = ! ! res ; if ( res === true ) { if ( isSealed ( name , this . target ) ) { throw new TypeError ( "property '" + name + "' is non-configurable " + "and can't be deleted" ) ; } } return res ; }
1196	function ( ) { var trap = this . getTrap ( "iterate" ) ; if ( trap === undefined ) { return Reflect . iterate ( this . target ) ; } var trapResult = trap . call ( this . handler , this . target ) ; if ( Object ( trapResult ) !== trapResult ) { throw new TypeError ( "iterate trap should return an iterator object, " + "got: " + trapResult ) ; } return trapResult ; }
1197	function ( ) { var trap = this . getTrap ( "keys" ) ; if ( trap === undefined ) { return Reflect . keys ( this . target ) ; } var trapResult = trap . call ( this . handler , this . target ) ; var propNames = Object . create ( null ) ; var numProps = + trapResult . length ; var result = new Array ( numProps ) ; for ( var i = 0 ; i < numProps ; i ++ ) { var s = String ( trapResult [ i ] ) ; if ( propNames [ s ] ) { throw new TypeError ( "keys trap cannot list a " + "duplicate property '" + s + "'" ) ; } if ( ! Object . isExtensible ( this . target ) && ! isFixed ( s , this . target ) ) { throw new TypeError ( "keys trap cannot list a new " + "property '" + s + "' on a non-extensible object" ) ; } propNames [ s ] = true ; result [ i ] = s ; } var ownEnumerableProps = Object . keys ( this . target ) ; var target = this . target ; ownEnumerableProps . forEach ( function ( ownEnumerableProp ) { if ( ! propNames [ ownEnumerableProp ] ) { if ( isSealed ( ownEnumerableProp , target ) ) { throw new TypeError ( "keys trap failed to include " + "non-configurable enumerable property '" + ownEnumerableProp + "'" ) ; } if ( ! Object . isExtensible ( target ) && isFixed ( ownEnumerableProp , target ) ) { throw new TypeError ( "cannot report existing own property '" + ownEnumerableProp + "' as non-existent on a " + "non-extensible object" ) ; } } } ) ; return result ; }
1198	function ( ) { var trap = this . getTrap ( "ownKeys" ) ; if ( trap === undefined ) { return Reflect . ownKeys ( this . target ) ; } var trapResult = trap . call ( this . handler , this . target ) ; if ( trapResult === null || typeof trapResult !== "object" ) { throw new TypeError ( "ownKeys should return an iterator object, got " + trapResult ) ; } return trapResult ; }
1199	function makeUnwrapping0ArgMethod ( primitive ) { return function builtin ( ) { var vHandler = safeWeakMapGet ( directProxies , this ) ; if ( vHandler !== undefined ) { return builtin . call ( vHandler . target ) ; } else { return primitive . call ( this ) ; } } }
1200	function load ( obj ) { var name , root ; root = typeof global !== "undefined" && global !== null ? global : this ; for ( name in obj ) { if ( obj . hasOwnProperty ( name ) ) { root [ name ] = obj [ name ] ; } } }
1201	function ( record , options ) { var json = { } ; if ( options && options . includeId ) { var id = get ( record , 'id' ) ; if ( id ) { json [ get ( this , 'primaryKey' ) ] = id ; } } record . eachAttribute ( function ( key , attribute ) { this . serializeAttribute ( record , json , key , attribute ) ; } , this ) ; record . eachRelationship ( function ( key , relationship ) { if ( relationship . kind === 'belongsTo' ) { this . serializeBelongsTo ( record , json , relationship ) ; } else if ( relationship . kind === 'hasMany' ) { this . serializeHasMany ( record , json , relationship ) ; } } , this ) ; return json ; }
1202	function ( record , json , key , attribute ) { var attrs = get ( this , 'attrs' ) ; var value = get ( record , key ) , type = attribute . type ; if ( type ) { var transform = this . transformFor ( type ) ; value = transform . serialize ( value ) ; } key = attrs && attrs [ key ] || ( this . keyForAttribute ? this . keyForAttribute ( key ) : key ) ; json [ key ] = value ; }
1203	function ( record , json , relationship ) { var key = relationship . key ; var belongsTo = get ( record , key ) ; key = this . keyForRelationship ? this . keyForRelationship ( key , "belongsTo" ) : key ; if ( isNone ( belongsTo ) ) { json [ key ] = belongsTo ; } else { json [ key ] = get ( belongsTo , 'id' ) ; } if ( relationship . options . polymorphic ) { this . serializePolymorphicType ( record , json , relationship ) ; } }
1204	function ( record , json , relationship ) { var key = relationship . key ; var relationshipType = DS . RelationshipChange . determineRelationshipType ( record . constructor , relationship ) ; if ( relationshipType === 'manyToNone' || relationshipType === 'manyToMany' ) { json [ key ] = get ( record , key ) . mapBy ( 'id' ) ; } }
1205	function ( store , type , payload , id , requestType ) { this . extractMeta ( store , type , payload ) ; var specificExtract = "extract" + requestType . charAt ( 0 ) . toUpperCase ( ) + requestType . substr ( 1 ) ; return this [ specificExtract ] ( store , type , payload , id , requestType ) ; }
1206	function ( store , type , payload ) { if ( payload && payload . meta ) { store . metaForType ( type , payload . meta ) ; delete payload . meta ; } }
1207	function ( ) { var promiseLabel = "DS: RecordArray#save " + get ( this , 'type' ) ; var promise = Ember . RSVP . all ( this . invoke ( "save" ) , promiseLabel ) . then ( function ( array ) { return Ember . A ( array ) ; } , null , "DS: RecordArray#save apply Ember.NativeArray" ) ; return DS . PromiseArray . create ( { promise : promise } ) ; }
1208	function ( index , removed , added ) { added = map ( added , function ( record ) { Ember . assert ( "You cannot add '" + record . constructor . typeKey + "' records to this relationship (only '" + this . type . typeKey + "' allowed)" , ! this . type || record instanceof this . type ) ; return record ; } , this ) ; this . _super ( index , removed , added ) ; }
1209	function ( hash ) { var owner = get ( this , 'owner' ) , store = get ( owner , 'store' ) , type = get ( this , 'type' ) , record ; Ember . assert ( "You cannot add '" + type . typeKey + "' records to this polymorphic relationship." , ! get ( this , 'isPolymorphic' ) ) ; record = store . createRecord . call ( store , type , hash ) ; this . pushObject ( record ) ; return record ; }
1210	function ( type ) { var adapter = this . adapterFor ( type ) ; if ( adapter && adapter . generateIdForRecord ) { return adapter . generateIdForRecord ( this ) ; } return null ; }
1211	function ( type , id ) { type = this . modelFor ( type ) ; var record = this . recordForId ( type , id ) ; var promise = this . fetchRecord ( record ) || resolve ( record , "DS: Store#findById " + type + " with id: " + id ) ; return promiseObject ( promise ) ; }
1212	function ( type , ids ) { var store = this ; var promiseLabel = "DS: Store#findByIds " + type ; return promiseArray ( Ember . RSVP . all ( map ( ids , function ( id ) { return store . findById ( type , id ) ; } ) ) . then ( Ember . A , null , "DS: Store#findByIds of " + type + " complete" ) ) ; }
1213	function ( record ) { var type = record . constructor , adapter = this . adapterFor ( type ) , id = get ( record , 'id' ) ; Ember . assert ( "You cannot reload a record without an ID" , id ) ; Ember . assert ( "You tried to reload a record but you have no adapter (for " + type + ")" , adapter ) ; Ember . assert ( "You tried to reload a record but your adapter does not implement `find`" , adapter . find ) ; return _find ( adapter , this , type , id ) ; }
1214	function ( records , owner , resolver ) { if ( ! records . length ) { return ; } var recordsByTypeMap = Ember . MapWithDefault . create ( { defaultValue : function ( ) { return Ember . A ( ) ; } } ) ; forEach ( records , function ( record ) { recordsByTypeMap . get ( record . constructor ) . push ( record ) ; } ) ; forEach ( recordsByTypeMap , function ( type , records ) { var ids = records . mapProperty ( 'id' ) , adapter = this . adapterFor ( type ) ; Ember . assert ( "You tried to load many records but you have no adapter (for " + type + ")" , adapter ) ; Ember . assert ( "You tried to load many records but your adapter does not implement `findMany`" , adapter . findMany ) ; resolver . resolve ( _findMany ( adapter , this , type , ids , owner ) ) ; } , this ) ; }
1215	function ( type , id ) { id = coerceId ( id ) ; type = this . modelFor ( type ) ; return ! ! this . typeMapFor ( type ) . idToRecord [ id ] ; }
1216	function ( type , id ) { type = this . modelFor ( type ) ; id = coerceId ( id ) ; var record = this . typeMapFor ( type ) . idToRecord [ id ] ; if ( ! record ) { record = this . buildRecord ( type , id ) ; } return record ; }
1217	function ( type , query ) { type = this . modelFor ( type ) ; var array = this . recordArrayManager . createAdapterPopulatedRecordArray ( type , query ) ; var adapter = this . adapterFor ( type ) , promiseLabel = "DS: Store#findQuery " + type , resolver = Ember . RSVP . defer ( promiseLabel ) ; Ember . assert ( "You tried to load a query but you have no adapter (for " + type + ")" , adapter ) ; Ember . assert ( "You tried to load a query but your adapter does not implement `findQuery`" , adapter . findQuery ) ; resolver . resolve ( _findQuery ( adapter , this , type , query , array ) ) ; return promiseArray ( resolver . promise ) ; }
1218	function ( type ) { type = this . modelFor ( type ) ; var typeMap = this . typeMapFor ( type ) , findAllCache = typeMap . findAllCache ; if ( findAllCache ) { return findAllCache ; } var array = this . recordArrayManager . createRecordArray ( type ) ; typeMap . findAllCache = array ; return array ; }
1219	function ( type ) { type = this . modelFor ( type ) ; var typeMap = this . typeMapFor ( type ) , records = typeMap . records , record ; while ( record = records . pop ( ) ) { record . unloadRecord ( ) ; } typeMap . findAllCache = null ; }
1220	function ( type , query , filter ) { var promise ; if ( arguments . length === 3 ) { promise = this . findQuery ( type , query ) ; } else if ( arguments . length === 2 ) { filter = query ; } type = this . modelFor ( type ) ; var array = this . recordArrayManager . createFilteredRecordArray ( type , filter ) ; promise = promise || resolve ( array ) ; return promiseArray ( promise . then ( function ( ) { return array ; } , null , "DS: Store#filter of " + type ) ) ; }
1221	function ( ) { var pending = this . _pendingSave . slice ( ) ; this . _pendingSave = [ ] ; forEach ( pending , function ( tuple ) { var record = tuple [ 0 ] , resolver = tuple [ 1 ] , adapter = this . adapterFor ( record . constructor ) , operation ; if ( get ( record , 'isNew' ) ) { operation = 'createRecord' ; } else if ( get ( record , 'isDeleted' ) ) { operation = 'deleteRecord' ; } else { operation = 'updateRecord' ; } resolver . resolve ( _commit ( adapter , this , operation , record ) ) ; } , this ) ; }
1222	function ( record , data ) { if ( data ) { data = normalizeRelationships ( this , record . constructor , data , record ) ; this . updateId ( record , data ) ; } record . adapterDidCommit ( data ) ; }
1223	function ( record , data ) { var oldId = get ( record , 'id' ) , id = coerceId ( data . id ) ; Ember . assert ( "An adapter cannot assign a new id to a record that already has an id. " + record + " had id: " + oldId + " and you tried to update it with " + id + ". This likely happened because your server returned data in response to a find or update that had a different id than the one you sent." , oldId === null || id === oldId ) ; this . typeMapFor ( record . constructor ) . idToRecord [ id ] = record ; set ( record , 'id' , id ) ; }
1224	function ( type ) { var typeMaps = get ( this , 'typeMaps' ) , guid = Ember . guidFor ( type ) , typeMap ; typeMap = typeMaps [ guid ] ; if ( typeMap ) { return typeMap ; } typeMap = { idToRecord : { } , records : [ ] , metadata : { } } ; typeMaps [ guid ] = typeMap ; return typeMap ; }
1225	function ( type , data , _partial ) { Ember . assert ( "You must include an `id` in a hash passed to `push`" , data . id != null ) ; type = this . modelFor ( type ) ; data = normalizeRelationships ( this , type , data ) ; this . _load ( type , data , _partial ) ; return this . recordForId ( type , data . id ) ; }
1226	function ( type , payload ) { var serializer ; if ( ! payload ) { payload = type ; serializer = defaultSerializer ( this . container ) ; Ember . assert ( "You cannot use `store#pushPayload` without a type unless your default serializer defines `pushPayload`" , serializer . pushPayload ) ; } else { serializer = this . serializerFor ( type ) ; } serializer . pushPayload ( this , payload ) ; }
1227	function ( type , metadata ) { type = this . modelFor ( type ) ; Ember . merge ( this . typeMapFor ( type ) . metadata , metadata ) ; }
1228	function ( type , id , data ) { var typeMap = this . typeMapFor ( type ) , idToRecord = typeMap . idToRecord ; Ember . assert ( 'The id ' + id + ' has already been used with another record of type ' + type . toString ( ) + '.' , ! id || ! idToRecord [ id ] ) ; var record = type . _create ( { id : id , store : this , container : this . container } ) ; if ( data ) { record . setupData ( data ) ; } if ( id ) { idToRecord [ id ] = record ; } typeMap . records . push ( record ) ; return record ; }
1229	function addUnsavedRecords ( record , key , data ) { if ( record ) { data . pushObjects ( record . get ( key ) . filterBy ( 'isNew' ) ) ; } }
1230	function deepClone ( object ) { var clone = { } , value ; for ( var prop in object ) { value = object [ prop ] ; if ( value && typeof value === 'object' ) { clone [ prop ] = deepClone ( value ) ; } else { clone [ prop ] = value ; } } return clone ; }
1231	function ( attribute , messages ) { var wasEmpty = get ( this , 'isEmpty' ) ; messages = this . _findOrCreateMessages ( attribute , messages ) ; get ( this , 'content' ) . addObjects ( messages ) ; this . notifyPropertyChange ( attribute ) ; this . enumerableContentDidChange ( ) ; if ( wasEmpty && ! get ( this , 'isEmpty' ) ) { this . trigger ( 'becameInvalid' ) ; } }
1232	function ( attribute ) { if ( get ( this , 'isEmpty' ) ) { return ; } var content = get ( this , 'content' ) . rejectBy ( 'attribute' , attribute ) ; get ( this , 'content' ) . setObjects ( content ) ; this . notifyPropertyChange ( attribute ) ; this . enumerableContentDidChange ( ) ; if ( get ( this , 'isEmpty' ) ) { this . trigger ( 'becameValid' ) ; } }
1233	function ( data ) { set ( this , 'isError' , false ) ; if ( data ) { this . _data = data ; } else { Ember . mixin ( this . _data , this . _inFlightAttributes ) ; } this . _inFlightAttributes = { } ; this . send ( 'didCommit' ) ; this . updateRecordArraysLater ( ) ; if ( ! data ) { return ; } this . suspendRelationshipObservers ( function ( ) { this . notifyPropertyChange ( 'data' ) ; } ) ; }
1234	function ( ) { this . _attributes = { } ; if ( get ( this , 'isError' ) ) { this . _inFlightAttributes = { } ; set ( this , 'isError' , false ) ; } if ( ! get ( this , 'isValid' ) ) { this . _inFlightAttributes = { } ; } this . send ( 'rolledBack' ) ; this . suspendRelationshipObservers ( function ( ) { this . notifyPropertyChange ( 'data' ) ; } ) ; }
1235	function ( callback , binding ) { var observers = get ( this . constructor , 'relationshipNames' ) . belongsTo ; var self = this ; try { this . _suspendedRelationships = true ; Ember . _suspendObservers ( self , observers , null , 'belongsToDidChange' , function ( ) { Ember . _suspendBeforeObservers ( self , observers , null , 'belongsToWillChange' , function ( ) { callback . call ( binding || self ) ; } ) ; } ) ; } finally { this . _suspendedRelationships = false ; } }
1236	function ( ) { var promiseLabel = "DS: Model#save " + this ; var resolver = Ember . RSVP . defer ( promiseLabel ) ; this . get ( 'store' ) . scheduleSave ( this , resolver ) ; this . _inFlightAttributes = this . _attributes ; this . _attributes = { } ; return DS . PromiseObject . create ( { promise : resolver . promise } ) ; }
1237	function ( ) { set ( this , 'isReloading' , true ) ; var record = this ; var promiseLabel = "DS: Model#reload of " + this ; var promise = new Ember . RSVP . Promise ( function ( resolve ) { record . send ( 'reloadRecord' , resolve ) ; } , promiseLabel ) . then ( function ( ) { record . set ( 'isReloading' , false ) ; record . set ( 'isError' , false ) ; return record ; } , function ( reason ) { record . set ( 'isError' , true ) ; throw reason ; } , "DS: Model#reload complete, update flags" ) ; return DS . PromiseObject . create ( { promise : promise } ) ; }
1238	function ( attributeName , value ) { if ( value !== undefined ) { this . _data [ attributeName ] = value ; this . notifyPropertyChange ( attributeName ) ; } else { this . _data [ attributeName ] = this . _inFlightAttributes [ attributeName ] ; } this . updateRecordArraysLater ( ) ; }
1239	function ( callback , binding ) { get ( this , 'attributes' ) . forEach ( function ( name , meta ) { callback . call ( binding , name , meta ) ; } , binding ) ; }
1240	function ( callback , binding ) { get ( this , 'transformedAttributes' ) . forEach ( function ( name , type ) { callback . call ( binding , name , type ) ; } ) ; }
1241	function ( proto , key , value ) { if ( value instanceof Ember . Descriptor ) { var meta = value . meta ( ) ; if ( meta . isRelationship && meta . kind === 'belongsTo' ) { Ember . addObserver ( proto , key , null , 'belongsToDidChange' ) ; Ember . addBeforeObserver ( proto , key , null , 'belongsToWillChange' ) ; } meta . parentType = proto . constructor ; } }
1242	function ( callback , binding ) { get ( this , 'relationshipsByName' ) . forEach ( function ( name , relationship ) { callback . call ( binding , name , relationship ) ; } ) ; }
1243	function ( ) { forEach ( this . changedRecords , function ( record ) { if ( get ( record , 'isDeleted' ) ) { this . _recordWasDeleted ( record ) ; } else { this . _recordWasChanged ( record ) ; } } , this ) ; this . changedRecords = [ ] ; }
1244	function ( array , filter , type , record ) { var shouldBeInArray ; if ( ! filter ) { shouldBeInArray = true ; } else { shouldBeInArray = filter ( record ) ; } var recordArrays = this . recordArraysForRecord ( record ) ; if ( shouldBeInArray ) { recordArrays . add ( array ) ; array . addRecord ( record ) ; } else if ( ! shouldBeInArray ) { recordArrays . remove ( array ) ; array . removeRecord ( record ) ; } }
1245	function ( array , type , filter ) { var typeMap = this . store . typeMapFor ( type ) , records = typeMap . records , record ; for ( var i = 0 , l = records . length ; i < l ; i ++ ) { record = records [ i ] ; if ( ! get ( record , 'isDeleted' ) && ! get ( record , 'isEmpty' ) ) { this . updateRecordArray ( array , filter , type , record ) ; } } }
1246	function ( type , records ) { var manyArray = DS . ManyArray . create ( { type : type , content : records , store : this . store } ) ; forEach ( records , function ( record ) { var arrays = this . recordArraysForRecord ( record ) ; arrays . add ( manyArray ) ; } , this ) ; return manyArray ; }
1247	function ( type ) { var array = DS . RecordArray . create ( { type : type , content : Ember . A ( ) , store : this . store , isLoaded : true } ) ; this . registerFilteredRecordArray ( array , type ) ; return array ; }
1248	function ( type , filter ) { var array = DS . FilteredRecordArray . create ( { type : type , content : Ember . A ( ) , store : this . store , manager : this , filterFunction : filter } ) ; this . registerFilteredRecordArray ( array , type , filter ) ; return array ; }
1249	function ( type , query ) { return DS . AdapterPopulatedRecordArray . create ( { type : type , query : query , content : Ember . A ( ) , store : this . store } ) ; }
1250	function ( array , type , filter ) { var recordArrays = this . filteredRecordArrays . get ( type ) ; recordArrays . push ( array ) ; this . updateFilter ( array , type , filter ) ; }
1251	function ( record , array ) { var loadingRecordArrays = record . _loadingRecordArrays || [ ] ; loadingRecordArrays . push ( array ) ; record . _loadingRecordArrays = loadingRecordArrays ; }
1252	function ( record , options ) { return get ( record , 'store' ) . serializerFor ( record . constructor . typeKey ) . serialize ( record , options ) ; }
1253	function ( store , type , ids ) { var promises = map . call ( ids , function ( id ) { return this . find ( store , type , id ) ; } , this ) ; return Ember . RSVP . all ( promises ) ; }
1254	function ( type ) { if ( type . FIXTURES ) { var fixtures = Ember . A ( type . FIXTURES ) ; return fixtures . map ( function ( fixture ) { var fixtureIdType = typeof fixture . id ; if ( fixtureIdType !== "number" && fixtureIdType !== "string" ) { throw new Error ( fmt ( 'the id property must be defined as a number or string for fixture %@' , [ fixture ] ) ) ; } fixture . id = fixture . id + '' ; return fixture ; } ) ; } return null ; }
1255	function ( store , type , record ) { return store . serializerFor ( type ) . serialize ( record , { includeId : true } ) ; }
1256	function ( type , hash , prop ) { this . normalizeId ( hash ) ; this . normalizeAttributes ( type , hash ) ; this . normalizeRelationships ( type , hash ) ; this . normalizeUsingDeclaredMapping ( type , hash ) ; if ( this . normalizeHash && this . normalizeHash [ prop ] ) { this . normalizeHash [ prop ] ( hash ) ; } return this . _super ( type , hash , prop ) ; }
1257	function ( store , primaryType , payload , recordId , requestType ) { payload = this . normalizePayload ( primaryType , payload ) ; var primaryTypeName = primaryType . typeKey , primaryRecord ; for ( var prop in payload ) { var typeName = this . typeForRoot ( prop ) , isPrimary = typeName === primaryTypeName ; if ( isPrimary && Ember . typeOf ( payload [ prop ] ) !== "array" ) { primaryRecord = this . normalize ( primaryType , payload [ prop ] , prop ) ; continue ; } var type = store . modelFor ( typeName ) ; forEach . call ( payload [ prop ] , function ( hash ) { var typeName = this . typeForRoot ( prop ) , type = store . modelFor ( typeName ) , typeSerializer = store . serializerFor ( type ) ; hash = typeSerializer . normalize ( type , hash , prop ) ; var isFirstCreatedRecord = isPrimary && ! recordId && ! primaryRecord , isUpdatedRecord = isPrimary && coerceId ( hash . id ) === recordId ; if ( isFirstCreatedRecord || isUpdatedRecord ) { primaryRecord = hash ; } else { store . push ( typeName , hash ) ; } } , this ) ; } return primaryRecord ; }
1258	function ( store , primaryType , payload ) { payload = this . normalizePayload ( primaryType , payload ) ; var primaryTypeName = primaryType . typeKey , primaryArray ; for ( var prop in payload ) { var typeKey = prop , forcedSecondary = false ; if ( prop . charAt ( 0 ) === '_' ) { forcedSecondary = true ; typeKey = prop . substr ( 1 ) ; } var typeName = this . typeForRoot ( typeKey ) , type = store . modelFor ( typeName ) , typeSerializer = store . serializerFor ( type ) , isPrimary = ( ! forcedSecondary && ( typeName === primaryTypeName ) ) ; var normalizedArray = map . call ( payload [ prop ] , function ( hash ) { return typeSerializer . normalize ( type , hash , prop ) ; } , this ) ; if ( isPrimary ) { primaryArray = normalizedArray ; } else { store . pushMany ( typeName , normalizedArray ) ; } } return primaryArray ; }
1259	function ( store , payload ) { payload = this . normalizePayload ( null , payload ) ; for ( var prop in payload ) { var typeName = this . typeForRoot ( prop ) , type = store . modelFor ( typeName ) ; var normalizedArray = map . call ( Ember . makeArray ( payload [ prop ] ) , function ( hash ) { return this . normalize ( type , hash , prop ) ; } , this ) ; store . pushMany ( typeName , normalizedArray ) ; } }
1260	function ( hash , type , record , options ) { hash [ type . typeKey ] = this . serialize ( record , options ) ; }
1261	function ( record , json , relationship ) { var key = relationship . key , belongsTo = get ( record , key ) ; key = this . keyForAttribute ? this . keyForAttribute ( key ) : key ; json [ key + "Type" ] = belongsTo . constructor . typeKey ; }
1262	function ( store , type , sinceToken ) { var query ; if ( sinceToken ) { query = { since : sinceToken } ; } return this . ajax ( this . buildURL ( type . typeKey ) , 'GET' , { data : query } ) ; }
1263	function ( store , type , ids ) { return this . ajax ( this . buildURL ( type . typeKey ) , 'GET' , { data : { ids : ids } } ) ; }
1264	function ( store , type , record ) { var data = { } ; var serializer = store . serializerFor ( type . typeKey ) ; serializer . serializeIntoHash ( data , type , record , { includeId : true } ) ; return this . ajax ( this . buildURL ( type . typeKey ) , "POST" , { data : data } ) ; }
1265	function ( store , type , record ) { var data = { } ; var serializer = store . serializerFor ( type . typeKey ) ; serializer . serializeIntoHash ( data , type , record ) ; var id = get ( record , 'id' ) ; return this . ajax ( this . buildURL ( type . typeKey , id ) , "PUT" , { data : data } ) ; }
1266	function ( store , type , record ) { var id = get ( record , 'id' ) ; return this . ajax ( this . buildURL ( type . typeKey , id ) , "DELETE" ) ; }
1267	function ( type , id ) { var url = [ ] , host = get ( this , 'host' ) , prefix = this . urlPrefix ( ) ; if ( type ) { url . push ( this . pathForType ( type ) ) ; } if ( id ) { url . push ( id ) ; } if ( prefix ) { url . unshift ( prefix ) ; } url = url . join ( '/' ) ; if ( ! host && url ) { url = '/' + url ; } return url ; }
1268	function ( url , type , hash ) { var adapter = this ; return new Ember . RSVP . Promise ( function ( resolve , reject ) { hash = adapter . ajaxOptions ( url , type , hash ) ; hash . success = function ( json ) { Ember . run ( null , resolve , json ) ; } ; hash . error = function ( jqXHR , textStatus , errorThrown ) { Ember . run ( null , reject , adapter . ajaxError ( jqXHR ) ) ; } ; Ember . $ . ajax ( hash ) ; } , "DS: RestAdapter#ajax " + type + " to " + url ) ; }
1269	function Inflector ( ruleSet ) { ruleSet = ruleSet || { } ; ruleSet . uncountable = ruleSet . uncountable || { } ; ruleSet . irregularPairs = ruleSet . irregularPairs || { } ; var rules = this . rules = { plurals : ruleSet . plurals || [ ] , singular : ruleSet . singular || [ ] , irregular : { } , irregularInverse : { } , uncountable : { } } ; loadUncountable ( rules , ruleSet . uncountable ) ; loadIrregular ( rules , ruleSet . irregularPairs ) ; }
1270	function ( key , kind ) { key = Ember . String . decamelize ( key ) ; if ( kind === "belongsTo" ) { return key + "_id" ; } else if ( kind === "hasMany" ) { return Ember . String . singularize ( key ) + "_ids" ; } else { return key ; } }
1271	function ( data , type , record , options ) { var root = Ember . String . decamelize ( type . typeKey ) ; data [ root ] = this . serialize ( record , options ) ; }
1272	function ( record , json , relationship ) { var key = relationship . key , belongsTo = get ( record , key ) ; key = this . keyForAttribute ( key ) ; json [ key + "_type" ] = Ember . String . capitalize ( belongsTo . constructor . typeKey ) ; }
1273	function ( root ) { var camelized = Ember . String . camelize ( root ) ; return Ember . String . singularize ( camelized ) ; }
1274	function ( data ) { if ( data . links ) { var links = data . links ; for ( var link in links ) { var camelizedLink = Ember . String . camelize ( link ) ; if ( camelizedLink !== link ) { links [ camelizedLink ] = links [ link ] ; delete links [ link ] ; } } } }
1275	function ( type , hash ) { var payloadKey , payload ; if ( this . keyForRelationship ) { type . eachRelationship ( function ( key , relationship ) { if ( relationship . options . polymorphic ) { payloadKey = this . keyForAttribute ( key ) ; payload = hash [ payloadKey ] ; if ( payload && payload . type ) { payload . type = this . typeForRoot ( payload . type ) ; } else if ( payload && relationship . kind === "hasMany" ) { var self = this ; forEach ( payload , function ( single ) { single . type = self . typeForRoot ( single . type ) ; } ) ; } } else { payloadKey = this . keyForRelationship ( key , relationship . kind ) ; payload = hash [ payloadKey ] ; } hash [ key ] = payload ; if ( key !== payloadKey ) { delete hash [ payloadKey ] ; } } , this ) ; } }
1276	function ( record , json , relationship ) { var key = relationship . key , attrs = get ( this , 'attrs' ) , embed = attrs && attrs [ key ] && attrs [ key ] . embedded === 'always' ; if ( embed ) { json [ this . keyForAttribute ( key ) ] = get ( record , key ) . map ( function ( relation ) { var data = relation . serialize ( ) , primaryKey = get ( this , 'primaryKey' ) ; data [ primaryKey ] = get ( relation , primaryKey ) ; return data ; } , this ) ; } }
1277	function ( store , primaryType , payload , recordId , requestType ) { var root = this . keyForAttribute ( primaryType . typeKey ) , partial = payload [ root ] ; updatePayloadWithEmbedded ( store , this , primaryType , partial , payload ) ; return this . _super ( store , primaryType , payload , recordId , requestType ) ; }
1278	function ( store , type , payload ) { var root = this . keyForAttribute ( type . typeKey ) , partials = payload [ Ember . String . pluralize ( root ) ] ; forEach ( partials , function ( partial ) { updatePayloadWithEmbedded ( store , this , type , partial , payload ) ; } , this ) ; return this . _super ( store , type , payload ) ; }
1279	function ( type ) { var decamelized = Ember . String . decamelize ( type ) ; return Ember . String . pluralize ( decamelized ) ; }
1280	function ( jqXHR ) { var error = this . _super ( jqXHR ) ; if ( jqXHR && jqXHR . status === 422 ) { var jsonErrors = Ember . $ . parseJSON ( jqXHR . responseText ) [ "errors" ] , errors = { } ; forEach ( Ember . keys ( jsonErrors ) , function ( key ) { errors [ Ember . String . camelize ( key ) ] = jsonErrors [ key ] ; } ) ; return new DS . InvalidError ( errors ) ; } else { return error ; } }
1281	function parseKeyValue ( keyValue ) { var obj = { } , key_value , key ; forEach ( ( keyValue || "" ) . split ( '&' ) , function ( keyValue ) { if ( keyValue ) { key_value = keyValue . split ( '=' ) ; key = tryDecodeURIComponent ( key_value [ 0 ] ) ; if ( isDefined ( key ) ) { var val = isDefined ( key_value [ 1 ] ) ? tryDecodeURIComponent ( key_value [ 1 ] ) : true ; if ( ! obj [ key ] ) { obj [ key ] = val ; } else if ( isArray ( obj [ key ] ) ) { obj [ key ] . push ( val ) ; } else { obj [ key ] = [ obj [ key ] , val ] ; } } } } ) ; return obj ; }
1282	function ( key , value , writeAttr , attrName ) { if ( key == 'class' ) { value = value || '' ; var current = this . $$element . attr ( 'class' ) || '' ; this . $removeClass ( tokenDifference ( current , value ) . join ( ' ' ) ) ; this . $addClass ( tokenDifference ( value , current ) . join ( ' ' ) ) ; } else { var booleanKey = getBooleanAttrName ( this . $$element [ 0 ] , key ) , normalizedVal , nodeName ; if ( booleanKey ) { this . $$element . prop ( key , value ) ; attrName = booleanKey ; } this [ key ] = value ; if ( attrName ) { this . $attr [ key ] = attrName ; } else { attrName = this . $attr [ key ] ; if ( ! attrName ) { this . $attr [ key ] = attrName = snake_case ( key , '-' ) ; } } nodeName = nodeName_ ( this . $$element ) ; if ( ( nodeName === 'A' && key === 'href' ) || ( nodeName === 'IMG' && key === 'src' ) ) { if ( ! msie || msie >= 8 ) { normalizedVal = $$urlUtils . resolve ( value ) ; if ( normalizedVal !== '' ) { if ( ( key === 'href' && ! normalizedVal . match ( aHrefSanitizationWhitelist ) ) || ( key === 'src' && ! normalizedVal . match ( imgSrcSanitizationWhitelist ) ) ) { this [ key ] = value = 'unsafe:' + normalizedVal ; } } } } if ( writeAttr !== false ) { if ( value === null || value === undefined ) { this . $$element . removeAttr ( attrName ) ; } else { this . $$element . attr ( attrName , value ) ; } } } var $$observers = this . $$observers ; $$observers && forEach ( $$observers [ key ] , function ( fn ) { try { fn ( value ) ; } catch ( e ) { $exceptionHandler ( e ) ; } } ) ; function tokenDifference ( str1 , str2 ) { var values = [ ] , tokens1 = str1 . split ( / \s+ / ) , tokens2 = str2 . split ( / \s+ / ) ; outer : for ( var i = 0 ; i < tokens1 . length ; i ++ ) { var token = tokens1 [ i ] ; for ( var j = 0 ; j < tokens2 . length ; j ++ ) { if ( token == tokens2 [ j ] ) continue outer ; } values . push ( token ) ; } return values ; } ; }
1283	function compileNodes ( nodeList , transcludeFn , $rootElement , maxPriority , ignoreDirective ) { var linkFns = [ ] , nodeLinkFn , childLinkFn , directives , attrs , linkFnFound ; for ( var i = 0 ; i < nodeList . length ; i ++ ) { attrs = new Attributes ( ) ; directives = collectDirectives ( nodeList [ i ] , [ ] , attrs , i == 0 ? maxPriority : undefined , ignoreDirective ) ; nodeLinkFn = ( directives . length ) ? applyDirectivesToNode ( directives , nodeList [ i ] , attrs , transcludeFn , $rootElement ) : null ; childLinkFn = ( nodeLinkFn && nodeLinkFn . terminal || ! nodeList [ i ] . childNodes || ! nodeList [ i ] . childNodes . length ) ? null : compileNodes ( nodeList [ i ] . childNodes , nodeLinkFn ? nodeLinkFn . transclude : transcludeFn ) ; linkFns . push ( nodeLinkFn ) ; linkFns . push ( childLinkFn ) ; linkFnFound = ( linkFnFound || nodeLinkFn || childLinkFn ) ; } return linkFnFound ? compositeLinkFn : null ; function compositeLinkFn ( scope , nodeList , $rootElement , boundTranscludeFn ) { var nodeLinkFn , childLinkFn , node , childScope , childTranscludeFn , i , ii , n ; var stableNodeList = [ ] ; for ( i = 0 , ii = nodeList . length ; i < ii ; i ++ ) { stableNodeList . push ( nodeList [ i ] ) ; } for ( i = 0 , n = 0 , ii = linkFns . length ; i < ii ; n ++ ) { node = stableNodeList [ n ] ; nodeLinkFn = linkFns [ i ++ ] ; childLinkFn = linkFns [ i ++ ] ; if ( nodeLinkFn ) { if ( nodeLinkFn . scope ) { childScope = scope . $new ( isObject ( nodeLinkFn . scope ) ) ; jqLite ( node ) . data ( '$scope' , childScope ) ; } else { childScope = scope ; } childTranscludeFn = nodeLinkFn . transclude ; if ( childTranscludeFn || ( ! boundTranscludeFn && transcludeFn ) ) { nodeLinkFn ( childLinkFn , childScope , node , $rootElement , ( function ( transcludeFn ) { return function ( cloneFn ) { var transcludeScope = scope . $new ( ) ; transcludeScope . $$transcluded = true ; return transcludeFn ( transcludeScope , cloneFn ) . on ( '$destroy' , bind ( transcludeScope , transcludeScope . $destroy ) ) ; } ; } ) ( childTranscludeFn || transcludeFn ) ) ; } else { nodeLinkFn ( childLinkFn , childScope , node , undefined , boundTranscludeFn ) ; } } else if ( childLinkFn ) { childLinkFn ( scope , node . childNodes , undefined , boundTranscludeFn ) ; } } } }
1284	function groupElementsLinkFnWrapper ( linkFn , attrStart , attrEnd ) { return function ( scope , element , attrs , controllers ) { element = groupScan ( element [ 0 ] , attrStart , attrEnd ) ; return linkFn ( scope , element , attrs , controllers ) ; } }
1285	function replaceWith ( $rootElement , elementsToRemove , newNode ) { var firstElementToRemove = elementsToRemove [ 0 ] , removeCount = elementsToRemove . length , parent = firstElementToRemove . parentNode , i , ii ; if ( $rootElement ) { for ( i = 0 , ii = $rootElement . length ; i < ii ; i ++ ) { if ( $rootElement [ i ] == firstElementToRemove ) { $rootElement [ i ++ ] = newNode ; for ( var j = i , j2 = j + removeCount - 1 , jj = $rootElement . length ; j < jj ; j ++ , j2 ++ ) { if ( j2 < jj ) { $rootElement [ j ] = $rootElement [ j2 ] ; } else { delete $rootElement [ j ] ; } } $rootElement . length -= removeCount - 1 ; break ; } } } if ( parent ) { parent . replaceChild ( newNode , firstElementToRemove ) ; } var fragment = document . createDocumentFragment ( ) ; fragment . appendChild ( firstElementToRemove ) ; newNode [ jqLite . expando ] = firstElementToRemove [ jqLite . expando ] ; for ( var k = 1 , kk = elementsToRemove . length ; k < kk ; k ++ ) { var element = elementsToRemove [ k ] ; jqLite ( element ) . remove ( ) ; fragment . appendChild ( element ) ; delete elementsToRemove [ k ] ; } elementsToRemove [ 0 ] = newNode ; elementsToRemove . length = 1 }
1286	function arrayDeclaration ( ) { var elementFns = [ ] ; var allConstant = true ; if ( peekToken ( ) . text != ']' ) { do { var elementFn = expression ( ) ; elementFns . push ( elementFn ) ; if ( ! elementFn . constant ) { allConstant = false ; } } while ( expect ( ',' ) ) ; } consume ( ']' ) ; return extend ( function ( self , locals ) { var array = [ ] ; for ( var i = 0 ; i < elementFns . length ; i ++ ) { array . push ( elementFns [ i ] ( self , locals ) ) ; } return array ; } , { literal : true , constant : allConstant } ) ; }
1287	function isSameOrigin ( requestUrl ) { var parsed = ( typeof requestUrl === 'string' ) ? resolve ( requestUrl , true ) : requestUrl ; return ( parsed . protocol === originUrl . protocol && parsed . host === originUrl . host ) ; }
1288	function traverse ( node , opt_onEnter , opt_onLeave ) { if ( opt_onEnter ) opt_onEnter ( node ) ; var childNodes = _collectChildNodes ( node ) ; childNodes . forEach ( function ( childNode ) { traverse ( childNode , opt_onEnter , opt_onLeave ) ; } ) ; if ( opt_onLeave ) opt_onLeave ( node ) ; }
1289	function Client ( ) { logger ( 'new Client' ) ; this . type = 'client' ; this . id = uuid ( ) ; this . browser = ( WebSocket . Server === undefined ) ; Base . call ( this ) ; }
1290	function Connection ( socket , parent ) { logger ( 'new Connection to %s' , parent . type ) ; this . id = uuid ( ) ; this . socket = socket ; this . parent = parent ; this . responseHandlers = { } ; if ( this . parent . browser ) { this . socket . onmessage = this . message . bind ( this ) ; this . socket . onclose = socketClosed . bind ( this ) ; this . socket . onerror = socketError . bind ( this ) ; } else { this . socket . on ( 'message' , this . message . bind ( this ) ) ; this . socket . once ( 'close' , this . close . bind ( this ) ) ; this . socket . once ( 'error' , this . close . bind ( this ) ) ; } }
1291	function mark ( type , attrs ) { return function ( ... args ) { let mark = type . create ( takeAttrs ( attrs , args ) ) let { nodes , tag } = flatten ( type . schema , args , n => mark . type . isInSet ( n . marks ) ? n : n . mark ( mark . addToSet ( n . marks ) ) ) return { flat : nodes , tag } } }
1292	function serverRequest ( config ) { var defer = $q . defer ( ) ; if ( provider . debug ) $log . info ( '$sails ' + config . method + ' ' + config . url , config . data || '' ) ; if ( config . timeout > 0 ) { $timeout ( timeoutRequest , config . timeout ) ; } else if ( isPromiseLike ( config . timeout ) ) { config . timeout . then ( timeoutRequest ) ; } socket [ 'legacy_' + config . method . toLowerCase ( ) ] ( config . url , config . data , serverResponse ) ; function timeoutRequest ( ) { serverResponse ( null ) ; } function serverResponse ( result , jwr ) { if ( ! jwr ) { jwr = { body : result , headers : result . headers || { } , statusCode : result . statusCode || result . status || 0 , error : ( function ( ) { if ( this . statusCode < 200 || this . statusCode >= 400 ) { return this . body || this . statusCode ; } } ) ( ) } ; } jwr . data = jwr . body ; jwr . status = jwr . statusCode ; jwr . socket = socket ; jwr . url = config . url ; jwr . method = config . method ; jwr . config = config . config ; if ( jwr . error ) { if ( provider . debug ) $log . warn ( '$sails response ' + jwr . statusCode + ' ' + config . url , jwr ) ; defer . reject ( jwr ) ; } else { if ( provider . debug ) $log . info ( '$sails response ' + config . url , jwr ) ; defer . resolve ( jwr ) ; } } return defer . promise ; }
1293	function processBootStrap ( file ) { var data = fs . readFileSync ( file ) . toString ( ) ; var idx = data . indexOf ( 'bootstrap(' ) ; if ( idx === - 1 ) { return null ; } else { idx += 10 ; } var odx1 = data . indexOf ( ',' , idx ) ; var odx2 = data . indexOf ( ')' , idx ) ; if ( odx2 < odx1 && odx2 !== - 1 || odx1 === - 1 ) { odx1 = odx2 ; } if ( odx1 === - 1 ) { return null ; } var componentRef = data . substring ( idx , odx1 ) ; var exp = "import\\s+\\{(" + \\ + \\ ; componentRef ")\\}\\s+from+\\s+[\'|\"](\\S+)[\'|\"][;?]" \\ \\ \\ }
1294	function fixTsConfig ( ) { var tsConfig = { } , tsFile = '../../tsconfig.json' ; if ( fs . existsSync ( tsFile ) ) { tsConfig = require ( tsFile ) ; } if ( ! tsConfig . compilerOptions || ! tsConfig . compilerOptions . typeRoots ) { tsConfig . compilerOptions = { target : "es5" , module : "commonjs" , declaration : false , removeComments : true , noLib : false , emitDecoratorMetadata : true , experimentalDecorators : true , lib : [ "dom" ] , sourceMap : true , pretty : true , allowUnreachableCode : false , allowUnusedLabels : false , noImplicitAny : false , noImplicitReturns : true , noImplicitUseStrict : false , noFallthroughCasesInSwitch : true , typeRoots : [ "node_modules/@types" , "node_modules" ] , types : [ "jasmine" ] } ; } if ( ! tsConfig . exclude ) { tsConfig . exclude = [ ] ; } if ( tsConfig . exclude . indexOf ( 'node_modules' ) === - 1 ) { tsConfig . exclude . push ( 'node_modules' ) ; } if ( tsConfig . exclude . indexOf ( 'platforms' ) === - 1 ) { tsConfig . exclude . push ( 'platforms' ) ; } fs . writeFileSync ( tsFile , JSON . stringify ( tsConfig , null , 4 ) , 'utf8' ) ; }
1295	function fixRefFile ( ) { var existingRef = '' , refFile = '../../references.d.ts' ; if ( fs . existsSync ( refFile ) ) { existingRef = fs . readFileSync ( refFile ) . toString ( ) ; } if ( existingRef . indexOf ( 'typescript/lib/lib.d.ts' ) === - 1 ) { var fix = '/// <reference path="./node_modules/tns-core-modules/tns-core-modules.d.ts" />\n' + \n ; '/// <reference path="./node_modules/typescript/lib/lib.d.ts" />\n' } }
1296	function fixNativeScriptPackage ( ) { var packageJSON = { } , packageFile = '../../package.json' ; packageJSON . name = "NativeScriptApp" ; packageJSON . version = "0.0.0" ; if ( fs . existsSync ( packageFile ) ) { packageJSON = require ( packageFile ) ; } else { console . log ( "This should not happen, your are missing your package.json file!" ) ; return ; } packageJSON . nativescript [ 'tns-ios' ] = { version : "2.3.0" } ; packageJSON . nativescript [ 'tns-android' ] = { version : "2.3.0" } ; if ( ! packageJSON . devDependencies ) { packageJSON . devDependencies = { } ; } packageJSON . devDependencies [ "@types/jasmine" ] = "^2.5.35" ; packageJSON . devDependencies [ "babel-traverse" ] = "6.12.0" ; packageJSON . devDependencies [ "babel-types" ] = "6.11.1" ; packageJSON . devDependencies . babylon = "6.8.4" ; packageJSON . devDependencies . filewalker = "0.1.2" ; packageJSON . devDependencies . lazy = "1.0.11" ; packageJSON . devDependencies . typescript = "^2.0.2" ; fs . writeFileSync ( packageFile , JSON . stringify ( packageJSON , null , 4 ) , 'utf8' ) ; }
1297	function fixAngularPackage ( ) { var packageJSON = { } , packageFile = '../../../package.json' ; if ( fs . existsSync ( packageFile ) ) { packageJSON = require ( packageFile ) ; } else { console . log ( "This should not happen, your are missing your main package.json file!" ) ; return ; } if ( ! packageJSON . scripts ) { packageJSON . scripts = { } ; } packageJSON . scripts [ "start.ios" ] = "cd nativescript && tns emulate ios" ; packageJSON . scripts [ "start.livesync.ios" ] = "cd nativescript && tns livesync ios --emulator --watch" ; packageJSON . scripts [ "start.android" ] = "cd nativescript && tns emulate android" ; packageJSON . scripts [ "start.livesync.android" ] = "cd nativescript && tns livesync android --emulator --watch" ; fs . writeFileSync ( packageFile , JSON . stringify ( packageJSON , null , 4 ) , 'utf8' ) ; }
1298	function fixMainFile ( component ) { var mainTS = '' , mainFile = '../../app/main.ts' ; if ( fs . existsSync ( mainFile ) ) { mainTS = fs . readFileSync ( mainFile ) . toString ( ) ; } if ( mainTS . indexOf ( 'MagicService' ) === - 1 ) { var fix = '// this import should be first in order to load some required settings (like globals and reflect-metadata)\n' + \n + 'import { platformNativeScriptDynamic, NativeScriptModule } from "nativescript-angular/platform";\n' + \n + 'import { NgModule } from "@angular/core";\n' + \n + 'import { AppComponent } from "./app/app.component";\n' + \n + '\n' + \n + '@NgModule({\n' + \n ; ' declarations: [AppComponent],\n' } }
1299	function fixGitIgnore ( ignorePattern ) { var fileString = '' , ignoreFile = '../../../.gitignore' ; if ( fs . existsSync ( ignoreFile ) ) { fileString = fs . readFileSync ( ignoreFile ) . toString ( ) ; } if ( fileString . indexOf ( ignorePattern ) === - 1 ) { var fix = fileString + '\n' + \n ; ignorePattern } }
1300	function displayFinalHelp ( ) { console . log ( "-------------- Welcome to the Magical World of NativeScript -----------------------------" ) ; console . log ( "To finish, follow this guide https://github.com/NathanWalker/nativescript-ng2-magic#usage" ) ; console . log ( "After you have completed the steps in the usage guide, you can then:" ) ; console . log ( "" ) ; console . log ( "Run your app in the iOS Simulator with these options:" ) ; console . log ( " npm run start.ios" ) ; console . log ( " npm run start.livesync.ios" ) ; console . log ( "" ) ; console . log ( "Run your app in an Android emulator with these options:" ) ; console . log ( " npm run start.android" ) ; console . log ( " npm run start.livesync.android" ) ; console . log ( "-----------------------------------------------------------------------------------------" ) ; console . log ( "" ) ; }
1301	function bind ( func , thisObject , var_args ) { var args = slice ( arguments , 2 ) ; function bound ( var_args ) { return InjectedScriptHost . callFunction ( func , thisObject , concat ( args , slice ( arguments ) ) ) ; } bound . toString = function ( ) { return "bound: " + toString ( func ) ; } ; return bound ; }
1302	function ( object , objectGroupName , forceValueType , generatePreview , columnNames , isTable , doNotBind , customObjectConfig ) { try { return new InjectedScript . RemoteObject ( object , objectGroupName , doNotBind , forceValueType , generatePreview , columnNames , isTable , undefined , customObjectConfig ) ; } catch ( e ) { try { var description = injectedScript . _describe ( e ) ; } catch ( ex ) { var description = "<failed to convert exception to string>" ; } return new InjectedScript . RemoteObject ( description ) ; } }
1303	function ( callArgumentJson ) { callArgumentJson = nullifyObjectProto ( callArgumentJson ) ; var objectId = callArgumentJson . objectId ; if ( objectId ) { var parsedArgId = this . _parseObjectId ( objectId ) ; if ( ! parsedArgId || parsedArgId [ "injectedScriptId" ] !== injectedScriptId ) throw "Arguments should belong to the same JavaScript world as the target object." ; var resolvedArg = this . _objectForId ( parsedArgId ) ; if ( ! this . _isDefined ( resolvedArg ) ) throw "Could not find object with given id" ; return resolvedArg ; } else if ( "value" in callArgumentJson ) { var value = callArgumentJson . value ; if ( callArgumentJson . type === "number" && typeof value !== "number" ) value = Number ( value ) ; return value ; } return undefined ; }
1304	function ( topCallFrame , callFrameId , functionObjectId , scopeNumber , variableName , newValueJsonString ) { try { var newValueJson = ( InjectedScriptHost . eval ( "(" + newValueJsonString + ")" ) ) ; var resolvedValue = this . _resolveCallArgument ( newValueJson ) ; if ( typeof callFrameId === "string" ) { var callFrame = this . _callFrameForId ( topCallFrame , callFrameId ) ; if ( ! callFrame ) return "Could not find call frame with given id" ; callFrame . setVariableValue ( scopeNumber , variableName , resolvedValue ) } else { var parsedFunctionId = this . _parseObjectId ( ( functionObjectId ) ) ; var func = this . _objectForId ( parsedFunctionId ) ; if ( typeof func !== "function" ) return "Could not resolve function by id" ; InjectedScriptHost . setFunctionVariableValue ( func , scopeNumber , variableName , resolvedValue ) ; } } catch ( e ) { return toString ( e ) ; } return undefined ; }
1305	function validate ( str ) { let tj ; if ( typeof str === 'object' ) { tj = str ; } else if ( typeof str === 'string' ) { try { tj = jsonlint . parse ( str ) ; } catch ( err ) { return false ; } } else { return false ; } return tilejsonValidateObject . validate ( tj ) ; }
1306	function _loop2 ( _name ) { var klass = resolve ( associations [ _name ] . klass ) ; var data = associated [ _name ] ; if ( ! data ) { model [ _name ] = null ; return "continue" ; } if ( associations [ _name ] . type === 'hasOne' ) { var other = ( typeof data === "undefined" ? "undefined" : _typeof ( data ) ) === 'object' ? klass . load ( data ) : klass . local ( data ) ; model [ _name ] = other ; } else if ( associations [ _name ] . type === 'hasMany' ) { var others = [ ] ; data . forEach ( function ( o ) { others . push ( ( typeof o === "undefined" ? "undefined" : _typeof ( o ) ) === 'object' ? klass . load ( o ) : klass . local ( o ) ) ; } ) ; model [ _name ] = others ; } }
1307	function handleErrors ( errors , data ) { const message = errors [ 0 ] . message ; const error = new Error ( ` ${ message } ` ) ; error . rawError = errors ; error . rawData = data ; throw error ; }
1308	function zip ( zipFile , srcList , dstPath ) { if ( ! dstPath ) { dstPath = false ; } const output = fs . createWriteStream ( zipFile ) ; const archive = archiver ( 'zip' , { zlib : { level : 9 } } ) ; return new Promise ( ( resolve , reject ) => { output . on ( 'close' , function ( ) { return resolve ( ) ; } ) ; archive . on ( 'warning' , function ( err ) { if ( err . code === 'ENOENT' ) { console . log ( err ) ; } else { return reject ( err ) ; } } ) ; archive . on ( 'error' , function ( err ) { return reject ( err ) ; } ) ; archive . pipe ( output ) ; srcList . forEach ( ( src ) => { const stat = fs . lstatSync ( src ) ; if ( stat . isFile ( ) ) { archive . file ( src ) ; } else if ( stat . isDirectory ( ) || stat . isSymbolicLink ( ) ) { archive . directory ( src , dstPath ) ; } else { return reject ( new Error ( 'Invalid path' ) ) ; } } ) ; archive . finalize ( ) ; } ) ; }
1309	function exec ( cmd , verbose ) { verbose = verbose === false ? verbose : true ; const stdout = execSync ( cmd ) ; if ( verbose ) { console . log ( stdout . toString ( ) ) ; } return stdout ; }
1310	function fileToString ( file ) { try { const stat = fs . lstatSync ( file ) ; if ( stat . isFile ( ) ) { const content = fs . readFileSync ( file , 'utf8' ) ; return content . toString ( ) ; } } catch ( e ) { if ( ! e . message . includes ( 'ENOENT' ) && ! e . message . includes ( 'name too long, lstat' ) ) { throw e ; } } return file ; }
1311	function mergeYamls ( file1 , file2 ) { const obj1 = yaml . safeLoad ( fileToString ( file1 ) , { schema : yamlfiles . YAML_FILES_SCHEMA } ) ; const obj2 = yaml . safeLoad ( fileToString ( file2 ) , { schema : yamlfiles . YAML_FILES_SCHEMA } ) ; return yaml . safeDump ( merge ( { } , obj1 , obj2 ) ) ; }
1312	function loadKesOverride ( kesFolder , kesClass = 'kes.js' ) { let kesOverridePath = path . resolve ( kesFolder , kesClass ) ; let KesOverride ; try { KesOverride = require ( kesOverridePath ) ; } catch ( e ) { const fileExists = fs . existsSync ( kesOverridePath ) ; if ( fileExists ) { throw e ; } console . log ( ` ${ kesOverridePath } ` ) ; } return KesOverride ; }
1313	function determineKesClass ( options , Kes ) { let KesOverride ; const kesClass = get ( options , 'kesClass' ) ; if ( kesClass ) { KesOverride = loadKesOverride ( process . cwd ( ) , kesClass ) ; } else { let kesFolder ; if ( options . kesFolder ) { kesFolder = options . kesFolder ; } else { kesFolder = path . join ( process . cwd ( ) , '.kes' ) ; } KesOverride = loadKesOverride ( kesFolder ) ; if ( ! KesOverride ) { const template = get ( options , 'template' , '/path/to/nowhere' ) ; kesFolder = path . join ( process . cwd ( ) , template ) ; KesOverride = loadKesOverride ( kesFolder ) ; } } return KesOverride || Kes ; }
1314	function failure ( e ) { if ( e . message ) { console . log ( e . message ) ; } else { console . log ( e ) ; } process . exit ( 1 ) ; }
1315	function getSystemBucket ( config ) { let bucket = get ( config , 'buckets.internal' ) ; if ( bucket && typeof bucket === 'string' ) { return bucket ; } bucket = get ( config , 'system_bucket' ) ; if ( bucket && typeof bucket === 'string' ) { return bucket ; } return undefined ; }
1316	function buildNestedCfs ( config , KesClass , options ) { const limit = pLimit ( 1 ) ; if ( config . nested_templates ) { const nested = config . nested_templates ; console . log ( 'Nested templates are found!' ) ; const ps = Object . keys ( nested ) . map ( ( name ) => limit ( ( ) => { console . log ( ` ${ name } ` ) ; const newOptions = Object . assign ( { } , options ) ; newOptions . cfFile = nested [ name ] . cfFile ; newOptions . configFile = nested [ name ] . configFile ; delete newOptions . template ; delete newOptions . deployment ; newOptions . stack = config . stack ; newOptions . parent = config ; const nestedConfig = new Config ( newOptions ) ; if ( ! nestedConfig . bucket ) { nestedConfig . bucket = utils . getSystemBucket ( config ) ; } nestedConfig . nested_cf_name = name ; const kes = new KesClass ( nestedConfig ) ; return kes . uploadCF ( ) . then ( ( uri ) => { config . nested_templates [ name ] . url = uri ; } ) ; } ) ) ; return Promise . all ( ps ) . then ( ( ) => config ) . catch ( utils . failure ) ; } return Promise . resolve ( config ) ; }
1317	function buildCf ( options , cmd ) { const KesClass = utils . determineKesClass ( options , Kes ) ; let parentConfig ; try { parentConfig = new Config ( options ) ; } catch ( e ) { return Promise . reject ( e ) ; } return buildNestedCfs ( parentConfig , KesClass , options ) . then ( ( config ) => { const kes = new KesClass ( config ) ; switch ( cmd ) { case 'create' : deprecate ( '"kes cf create" command is deprecated. Use "kes cf deploy" instead' ) ; return kes . createStack ( ) ; case 'update' : deprecate ( '"kes cf update" command is deprecated. Use "kes cf deploy" instead' ) ; return kes . updateStack ( ) ; case 'upsert' : deprecate ( '"kes cf upsert" command is deprecated. Use "kes cf deploy" instead' ) ; return kes . upsertStack ( ) ; case 'deploy' : return kes . deployStack ( ) ; case 'validate' : return kes . validateTemplate ( ) ; case 'compile' : return kes . compileCF ( ) ; case 'delete' : return kes . deleteStack ( ) ; default : console . log ( 'Wrong choice. Accepted arguments: [create|update|upsert|deploy|validate|compile]' ) ; } } ) ; }
1318	function buildLambda ( options , cmd ) { if ( cmd ) { const KesClass = utils . determineKesClass ( options , Kes ) ; const config = new Config ( options ) ; const kes = new KesClass ( config ) ; kes . updateSingleLambda ( cmd ) . then ( r => utils . success ( r ) ) . catch ( e => utils . failure ( e ) ) ; } else { utils . failure ( new Error ( 'Lambda name is missing' ) ) ; } }
1319	function sendResponse ( event , context , responseStatus , responseData ) { const responseBody = JSON . stringify ( { Status : responseStatus , Reason : 'See the details in CloudWatch Log Stream: ' + context . logStreamName , PhysicalResourceId : context . logStreamName , StackId : event . StackId , RequestId : event . RequestId , LogicalResourceId : event . LogicalResourceId , Data : responseData } ) ; console . log ( 'RESPONSE BODY:\n' , \n ) ; responseBody const https = require ( 'https' ) ; const url = require ( 'url' ) ; const parsedUrl = url . parse ( event . ResponseURL ) ; const options = { hostname : parsedUrl . hostname , port : 443 , path : parsedUrl . path , method : 'PUT' , headers : { 'content-type' : '' , 'content-length' : responseBody . length } } ; console . log ( 'SENDING RESPONSE...\n' ) ; \n const request = https . request ( options , function ( response ) { console . log ( 'STATUS: ' + response . statusCode ) ; console . log ( 'HEADERS: ' + JSON . stringify ( response . headers ) ) ; context . done ( ) ; } ) ; request . on ( 'error' , function ( error ) { console . log ( 'sendResponse Error:' + error ) ; context . done ( ) ; } ) ; }
1320	function optionsToString ( options ) { return Object . keys ( options ) . map ( function processOption ( key ) { return key + "=" + options [ key ] ; } ) . join ( "," ) ; }
1321	function assign ( target ) { var sources = Array . prototype . slice . call ( arguments , 1 ) ; function assignArgument ( previous , source ) { Object . keys ( source ) . forEach ( function assignItem ( key ) { previous [ key ] = source [ key ] ; } ) ; return previous ; } return sources . reduce ( assignArgument , target ) ; }
1322	function openPopupWithPost ( url , postData , name , options ) { var form = document . createElement ( "form" ) ; var win ; form . setAttribute ( "method" , "post" ) ; form . setAttribute ( "action" , url ) ; form . setAttribute ( "target" , name ) ; Object . keys ( postData ) . forEach ( function addFormItem ( key ) { var input = document . createElement ( "input" ) ; input . type = "hidden" ; input . name = key ; input . value = postData [ key ] ; form . appendChild ( input ) ; } ) ; document . body . appendChild ( form ) ; win = window . open ( "/" , name , options ) ; win . document . write ( "Loading..." ) ; form . submit ( ) ; document . body . removeChild ( form ) ; return win ; }
1323	function popupExecute ( execute , url , name , options , callback ) { var popupName = name || defaultPopupName ( ) ; var popupOptions = optionsResolveCentered ( assign ( { } , defaultOptions , options ) ) ; var popupCallback = callback || function noop ( ) { } ; var optionsString = optionsToString ( popupOptions ) ; var win = execute ( url , popupName , optionsString ) ; var isMessageSent = false ; var interval ; function popupCallbackOnce ( err , data ) { if ( ! isMessageSent ) { isMessageSent = true ; popupCallback ( err , data ) ; } } function onMessage ( message ) { var data = message ? message . data : undefined ; if ( data ) { popupCallbackOnce ( undefined , data ) ; window . removeEventListener ( "message" , onMessage ) ; } } window . addEventListener ( "message" , onMessage , false ) ; if ( win ) { interval = setInterval ( function closePopupCallback ( ) { if ( win == null || win . closed ) { setTimeout ( function delayWindowClosing ( ) { clearInterval ( interval ) ; popupCallbackOnce ( new Error ( "Popup closed" ) ) ; } , 500 ) ; } } , 100 ) ; } else { popupCallbackOnce ( new Error ( "Popup blocked" ) ) ; } return win ; }
1324	function popup ( url , name , options , callback ) { return popupExecute ( window . open , url , name , options , callback ) ; }
1325	function popupWithPost ( url , postData , name , options , callback ) { function openWithPostData ( popupUrl , popupName , optionsString ) { return openPopupWithPost ( popupUrl , postData , popupName , optionsString ) ; } return popupExecute ( openWithPostData , url , name , options , callback ) ; }
1326	function getWrappingContentRange ( editor ) { if ( editor . somethingSelected ( ) ) { const sel = editor . listSelections ( ) . filter ( sel => sel . anchor !== sel . head ) [ 0 ] ; if ( sel ) { return comparePos ( sel . anchor , sel . head ) < 0 ? { from : sel . anchor , to : sel . head } : { from : sel . head , to : sel . anchor } ; } } return getTagRangeForPos ( editor , editor . getCursor ( ) ) ; }
1327	function betweenTags ( editor , range ) { if ( equalCursorPos ( range . anchor , range . head ) ) { const cursor = range . anchor ; const mode = editor . getModeAt ( cursor ) ; if ( mode . name === 'xml' ) { const left = editor . getTokenAt ( cursor ) ; const right = editor . getTokenAt ( Object . assign ( { } , cursor , { ch : cursor . ch + 1 } ) ) ; return left . type === 'tag bracket' && left . string === '>' && right . type === 'tag bracket' && right . string === '</' ; } } }
1328	function canExtract ( editor , pos , config ) { const tokenType = editor . getTokenTypeAt ( pos ) ; if ( config . type === 'stylesheet' ) { return tokenType !== 'comment' && tokenType !== 'string' ; } if ( config . syntax === 'html' ) { return tokenType === null ; } if ( config . syntax === 'slim' || config . syntax === 'pug' ) { return tokenType === null || tokenType === 'tag' || ( tokenType && / attribute / . test ( tokenType ) ) ; } if ( config . syntax === 'haml' ) { return tokenType === null || tokenType === 'attribute' ; } if ( config . syntax === 'jsx' ) { return true ; } return false ; }
1329	function getStylesheetCompletions ( editor , pos , config ) { const line = editor . getLine ( pos . line ) . slice ( 0 , pos . ch ) ; const prefix = extractPrefix ( line , / [\w-@$] / ) ; if ( prefix ) { const prefixRange = { from : { line : pos . line , ch : pos . ch - prefix . length } , to : pos } ; if ( config . options && config . options . property ) { const lowerProp = config . options . property . toLowerCase ( ) ; const completion = getSnippetCompletions ( editor , pos , config ) . find ( item => item . property && item . property === lowerProp ) ; if ( completion && completion . keywords . length ) { return completion . keywords . map ( kw => { return kw . key . indexOf ( prefix ) === 0 && new EmmetCompletion ( 'value' , editor , prefixRange , kw . key , kw . preview , kw . snippet ) ; } ) . filter ( Boolean ) ; } } else { return getSnippetCompletions ( editor , pos , config ) . filter ( completion => completion . key !== prefix && completion . key . indexOf ( prefix ) === 0 ) . map ( completion => new EmmetCompletion ( 'snippet' , editor , prefixRange , completion . key , completion . preview , completion . snippet ) ) ; } } return [ ] ; }
1330	function getSnippetCompletions ( editor , pos , config ) { const { type , syntax } = config ; if ( ! editor . state . emmetCompletions ) { editor . state . emmetCompletions = { } ; } const cache = editor . state . emmetCompletions ; if ( ! ( syntax in cache ) ) { const registry = createSnippetsRegistry ( type , syntax , config . snippets ) ; cache [ syntax ] = type === 'stylesheet' ? getStylesheetSnippets ( registry , config ) : getMarkupSnippets ( registry , config ) ; } return cache [ syntax ] ; }
1331	function getStylesheetSnippets ( registry ) { return convertToCSSSnippets ( registry ) . map ( snippet => { let preview = snippet . property ; const keywords = snippet . keywords ( ) ; if ( keywords . length ) { preview += ` ${ removeFields ( keywords . join ( ' | ' ) ) } ` ; } else if ( snippet . value ) { preview += ` ${ removeFields ( snippet . value ) } ` ; } return { key : snippet . key , value : snippet . value , snippet : snippet . key , property : snippet . property , keywords : keywords . map ( kw => { const m = kw . match ( / ^[\w-]+ / ) ; return m && { key : m [ 0 ] , preview : removeFields ( kw ) , snippet : kw } ; } ) . filter ( Boolean ) , preview } ; } ) ; }
1332	function getMarkupSnippets ( registry , config ) { return registry . all ( { type : 'string' } ) . map ( snippet => ( { key : snippet . key , value : snippet . value , preview : removeFields ( expand ( snippet . value , config ) ) , snippet : snippet . key } ) ) ; }
1333	function extractPrefix ( str , match ) { let offset = str . length ; while ( offset > 0 ) { if ( ! match . test ( str [ offset - 1 ] ) ) { break ; } offset -- ; } return str . slice ( offset ) ; }
1334	function isValidMarker ( editor , marker ) { const range = marker . find ( ) ; if ( range . from . line !== range . to . line ) { return false ; } let text = editor . getRange ( range . from , range . to ) ; if ( ! text || / ^\s|\s$ / g . test ( text ) ) { return false ; } if ( marker . model && marker . model . config . syntax === 'jsx' && text [ 0 ] === '<' ) { text = text . slice ( 1 ) ; } if ( ! marker . model || marker . model . abbreviation !== text ) { try { marker . model = new Abbreviation ( text , range , marker . model . config ) ; if ( ! marker . model . valid ( editor , true ) ) { marker . model = null ; } } catch ( err ) { console . warn ( err ) ; marker . model = null ; } } return Boolean ( marker . model && marker . model . snippet ) ; }
1335	function ( property ) { var def = this . _definition [ property ] ; if ( def . type === 'boolean' ) { this [ property ] = ! this [ property ] ; } else if ( def && def . values ) { this [ property ] = arrayNext ( def . values , this [ property ] ) ; } else { throw new TypeError ( 'Can only toggle properties that are type `boolean` or have `values` array.' ) ; } return this ; }
1336	function ( attr ) { if ( attr == null ) return ! ! Object . keys ( this . _changed ) . length ; if ( has ( this . _derived , attr ) ) { return this . _derived [ attr ] . depList . some ( function ( dep ) { return this . hasChanged ( dep ) ; } , this ) ; } return has ( this . _changed , attr ) ; }
1337	function ( propertyName ) { if ( ! this . _eventBubblingHandlerCache [ propertyName ] ) { this . _eventBubblingHandlerCache [ propertyName ] = function ( name , model , newValue ) { if ( changeRE . test ( name ) ) { this . trigger ( 'change:' + propertyName + '.' + name . split ( ':' ) [ 1 ] , model , newValue ) ; } else if ( name === 'change' ) { this . trigger ( 'change' , this ) ; } } . bind ( this ) ; } return this . _eventBubblingHandlerCache [ propertyName ] ; }
1338	function createDerivedProperty ( modelProto , name , definition ) { var def = modelProto . _derived [ name ] = { fn : isFunction ( definition ) ? definition : definition . fn , cache : ( definition . cache !== false ) , depList : definition . deps || [ ] } ; def . depList . forEach ( function ( dep ) { modelProto . _deps [ dep ] = union ( modelProto . _deps [ dep ] || [ ] , [ name ] ) ; } ) ; Object . defineProperty ( modelProto , name , { get : function ( ) { return this . _getDerivedProperty ( name ) ; } , set : function ( ) { throw new TypeError ( "`" + name + "` is a derived property, it can't be set directly." ) ; } } ) ; }
1339	function Image ( image , address ) { var at = this . attributes = image . attribs ; this . name = path . basename ( at . src , path . extname ( at . src ) ) ; this . saveTo = path . dirname ( require . main . filename ) + "/" ; this . extension = path . extname ( at . src ) ; this . address = url . resolve ( address , at . src ) ; this . fromAddress = address ; }
1340	function shipitTask ( grunt ) { 'use strict' ; grunt . shipit = new Shipit ( ) ; grunt . registerTask ( 'shipit' , 'Shipit Task' , function ( env ) { var config = grunt . config . get ( 'shipit' ) ; grunt . shipit . environment = env ; if ( ! config . default && config . options ) config . default = config . options ; grunt . shipit . initConfig ( config ) . initialize ( ) ; } ) ; }
1341	function injectTemplate ( s , node , offset , id ) { const t = node . src ? readSrc ( id , node . src ) : node . content const compiled = compiler . compile ( t ) const renderFuncs = '\nrender: ' + \n + toFunction ( compiled . render ) + ',' + '\nstaticRenderFns: [' + \n compiled . staticRenderFns . map ( toFunction ) . join ( ',' ) '],' }
1342	function _defaultCheckSize ( size ) { return function ( raw ) { if ( raw . length < size ) { return false ; } this . buffer = raw . substr ( size ) ; return raw . substr ( 0 , size ) ; } ; }
1343	function int64add5 ( dst , a , b , c , d , e ) { var w0 = ( a . l & 0xffff ) + ( b . l & 0xffff ) + ( c . l & 0xffff ) + ( d . l & 0xffff ) + ( e . l & 0xffff ) ; var w1 = ( a . l >>> 16 ) + ( b . l >>> 16 ) + ( c . l >>> 16 ) + ( d . l >>> 16 ) + ( e . l >>> 16 ) + ( w0 >>> 16 ) ; var w2 = ( a . h & 0xffff ) + ( b . h & 0xffff ) + ( c . h & 0xffff ) + ( d . h & 0xffff ) + ( e . h & 0xffff ) + ( w1 >>> 16 ) ; var w3 = ( a . h >>> 16 ) + ( b . h >>> 16 ) + ( c . h >>> 16 ) + ( d . h >>> 16 ) + ( e . h >>> 16 ) + ( w2 >>> 16 ) ; dst . l = ( w0 & 0xffff ) | ( w1 << 16 ) ; dst . h = ( w2 & 0xffff ) | ( w3 << 16 ) ; }
1344	function ( configFile , options ) { DataStream . call ( this ) ; this . options = options || { } ; var self = this ; this . configFile = configFile ; this . init ( ) ; this . bundles = { } ; this . buildConfig = this . compileConfig ( configFile , self . options ) ; this . makeEmptyStreamsUnreadable ( this . buildConfig ) ; var isFatalErrors = ! this . isAllModulesExists ( this . buildConfig ) ; if ( isFatalErrors ) { this . readable = false ; this . style . readable = false ; this . sourceMap . readable = false ; } else { this . _initBundlesStreams ( this . buildConfig . bundles ) ; } process . nextTick ( function ( ) { if ( ! isFatalErrors ) { if ( configFile ) { var buildResult = self . build ( self . buildConfig ) ; self . write ( buildResult . source ) ; self . style . write ( buildResult . style ) ; self . sourceMap . write ( buildResult . sourceMap . toString ( ) ) ; self . _streamBundles ( buildResult . bundles ) ; } else { self . log . write ( 'lmd usage:\n\t ' + \n + \t + 'lmd' . blue + ' ' ) ; } } else 'config.lmd.js(on)' . green ' [output.lmd.js]\n' } ) ; }
1345	function getSandboxMap ( ast ) { var map = { } ; walker . with_walkers ( { "var" : function ( vars ) { for ( var i = 0 , c = vars . length , varItem ; i < c ; i ++ ) { varItem = vars [ i ] ; if ( varItem [ 0 ] === 'sandbox' ) { varItem [ 1 ] [ 1 ] . forEach ( function ( objectVar ) { map [ objectVar [ 0 ] ] = objectVar [ 1 ] [ 1 ] ; } ) ; throw 0 ; } } } } , function ( ) { try { return walker . walk ( ast ) ; } catch ( e ) { } } ) ; return map ; }
1346	function breakSandbox ( ast , replaceMap ) { var sandboxName = ast [ 2 ] [ 0 ] || 'sb' ; var newAst = walker . with_walkers ( { "dot" : function ( ) { if ( this [ 1 ] && this [ 1 ] [ 0 ] === "name" && this [ 1 ] [ 1 ] === sandboxName ) { var sourceName = this [ 2 ] ; return [ "name" , replaceMap [ sourceName ] ] ; } } } , function ( ) { return walker . walk ( ast ) ; } ) ; newAst [ 1 ] [ 2 ] = [ ] ; return newAst ; }
1347	function ( ) { if ( isSandboxVariableWiped ) { return ; } for ( var i = 0 , c = this [ 1 ] . length , varItem ; i < c ; i ++ ) { varItem = this [ 1 ] [ i ] ; if ( varItem [ 0 ] === 'sandbox' ) { isSandboxVariableWiped = true ; this [ 1 ] . splice ( i , 1 ) ; return this ; } } }
1348	function getEvents ( ast ) { var usage = { } , eventIndex = 0 ; walker . with_walkers ( { "call" : function ( ) { if ( this [ 1 ] && this [ 2 ] [ 0 ] ) { var functionName = this [ 1 ] [ 1 ] ; switch ( functionName ) { case "lmd_on" : case "lmd_trigger" : var eventName = this [ 2 ] [ 0 ] [ 1 ] ; if ( ! usage [ eventName ] ) { usage [ eventName ] = { on : 0 , trigger : 0 , eventIndex : eventIndex } ; eventIndex ++ ; } if ( functionName === "lmd_on" ) { usage [ eventName ] . on ++ ; } else { usage [ eventName ] . trigger ++ ; } break ; } } } } , function ( ) { return walker . walk ( ast ) ; } ) ; return usage ; }
1349	function wipeLmdEvents ( ast ) { var itemsToWipe = [ 'lmd_on' , 'lmd_trigger' , 'lmd_events' ] ; return walker . with_walkers ( { "var" : function ( ) { if ( ! itemsToWipe . length ) { return ; } for ( var i = 0 , c = this [ 1 ] . length , varItem ; i < c ; i ++ ) { varItem = this [ 1 ] [ i ] ; if ( varItem ) { var itemIndex = itemsToWipe . indexOf ( varItem [ 0 ] ) ; if ( itemIndex !== - 1 ) { itemsToWipe . splice ( itemIndex , 1 ) ; this [ 1 ] . splice ( i , 1 ) ; i -- ; } } } } } , function ( ) { return walker . walk ( ast ) ; } ) ; }
1350	function ( ) { if ( ! itemsToWipe . length ) { return ; } for ( var i = 0 , c = this [ 1 ] . length , varItem ; i < c ; i ++ ) { varItem = this [ 1 ] [ i ] ; if ( varItem ) { var itemIndex = itemsToWipe . indexOf ( varItem [ 0 ] ) ; if ( itemIndex !== - 1 ) { itemsToWipe . splice ( itemIndex , 1 ) ; this [ 1 ] . splice ( i , 1 ) ; i -- ; } } } }
1351	function ( optionName , isApply , isInline ) { var inlinePreprocessorBlock = isInline ? '/*if (' + optionName + ') {*/' : 'if (' + optionName + ') {' , bracesCounter = 0 , startIndex = lmd_js . indexOf ( inlinePreprocessorBlock ) , startLength = inlinePreprocessorBlock . length , endIndex = startIndex + inlinePreprocessorBlock . length , endLength = isInline ? 5 : 1 ; if ( startIndex === - 1 ) { return false ; } while ( lmd_js . length > endIndex ) { if ( lmd_js [ endIndex ] === '{' ) { bracesCounter ++ ; } if ( lmd_js [ endIndex ] === '}' ) { bracesCounter -- ; } if ( bracesCounter === - 1 ) { if ( isInline ) { endIndex -= 2 ; } else { while ( startIndex ) { startIndex -- ; startLength ++ ; if ( lmd_js [ startIndex ] !== '\t' && \t ) lmd_js [ startIndex ] !== ' ' } { startIndex ++ ; startLength -- ; break ; } while ( endIndex ) { endIndex -- ; endLength ++ ; if ( lmd_js [ endIndex ] !== '\t' && \t ) lmd_js [ endIndex ] !== ' ' } { endIndex ++ ; endLength -- ; break ; } } endLength ++ ; startLength ++ ; } if ( isApply ) { lmd_js = lmd_js . substr ( 0 , startIndex ) + lmd_js . substr ( startIndex + startLength ) ; lmd_js = lmd_js . substr ( 0 , endIndex - startLength ) + lmd_js . substr ( endIndex + endLength - startLength ) ; if ( ! isInline ) { var blockForIndent = lmd_js . substr ( startIndex , endIndex - startLength - startIndex ) ; blockForIndent = blockForIndent . split ( '\n' ) . \n map . ( function ( line ) { return line . replace ( / ^\s{4} / , '' ) ; } ) join ; ( '\n' ) } } else \n } lmd_js = lmd_js . substr ( 0 , startIndex ) + blockForIndent + lmd_js . substr ( endIndex - startLength ) ; }
1352	function ( e ) { if ( isNotLoaded ) { isNotLoaded = 0 ; link . removeAttribute ( 'id' ) ; if ( ! e ) { sb . trigger ( '*:request-error' , moduleName , module ) ; } callback ( e ? sb . register ( moduleName , link ) : head . removeChild ( link ) && sb . undefined ) ; } }
1353	function d3_layout_hierarchyRebind ( object , hierarchy ) { object . sort = d3 . rebind ( object , hierarchy . sort ) ; object . children = d3 . rebind ( object , hierarchy . children ) ; object . links = d3_layout_hierarchyLinks ; object . value = d3 . rebind ( object , hierarchy . value ) ; object . nodes = function ( d ) { d3_layout_hierarchyInline = true ; return ( object . nodes = object ) ( d ) ; } ; return object ; }
1354	function position ( row , u , rect , flush ) { var i = - 1 , n = row . length , x = rect . x , y = rect . y , v = u ? round ( row . area / u ) : 0 , o ; if ( u == rect . dx ) { if ( flush || v > rect . dy ) v = v ? rect . dy : 0 ; while ( ++ i < n ) { o = row [ i ] ; o . x = x ; o . y = y ; o . dy = v ; x += o . dx = v ? round ( o . area / v ) : 0 ; } o . z = true ; o . dx += rect . x + rect . dx - x ; rect . y += v ; rect . dy -= v ; } else { if ( flush || v > rect . dx ) v = v ? rect . dx : 0 ; while ( ++ i < n ) { o = row [ i ] ; o . x = x ; o . y = y ; o . dx = v ; y += o . dy = v ? round ( o . area / v ) : 0 ; } o . z = false ; o . dy += rect . y + rect . dy - y ; rect . x += v ; rect . dx -= v ; } }
1355	function ( classes ) { var map = { } ; function find ( name , data ) { var node = map [ name ] , i ; if ( ! node ) { node = map [ name ] = data || { name : name , children : [ ] } ; if ( name . length ) { node . parent = find ( "" ) ; node . parent . children . push ( node ) ; node . name = name ; node . key = escapeId ( name ) ; } } return node ; } classes . forEach ( function ( d ) { find ( d . name , d ) ; } ) ; return map [ "" ] ; }
1356	function stringify ( object ) { var properties = [ ] ; for ( var key in object ) { if ( object . hasOwnProperty ( key ) ) { properties . push ( quote ( key ) + ':' + getValue ( object [ key ] ) ) ; } } return "{" + properties . join ( "," ) + "}" ; }
1357	function countIf ( ) { var self = this , ret ; if ( self [ 0 ] . start && analyzing . indexOf ( self ) < 0 ) { var decision = self [ 1 ] ; var lineId = self [ 0 ] . name + ':' + ( self [ 0 ] . start . line + lineOffset ) ; self [ 1 ] = wrapCondition ( decision , lineId ) ; if ( self [ 2 ] && self [ 2 ] [ 0 ] . start && self [ 2 ] [ 0 ] . start . value != "{" ) { self [ 2 ] = [ "block" , [ self [ 2 ] ] ] ; } if ( self [ 3 ] && self [ 3 ] [ 0 ] . start && self [ 3 ] [ 0 ] . start . value != "{" ) { self [ 3 ] = [ "block" , [ self [ 3 ] ] ] ; } } ret = countLine . call ( self ) ; if ( decision ) { analyzing . pop ( decision ) ; } return ret ; }
1358	function wrapCondition ( decision , lineId , parentPos ) { if ( options . condition === false ) { return decision ; } if ( isSingleCondition ( decision ) ) { var pos = getPositionStart ( decision , parentPos ) ; var condId = lineId + ":" + pos ; analyzing . push ( decision ) ; allConditions . push ( condId ) ; return [ "call" , [ "dot" , [ "name" , "require" ] , "coverage_condition" ] , [ [ "string" , moduleName ] , [ "string" , condId ] , decision ] ] ; } else { decision [ 2 ] = wrapCondition ( decision [ 2 ] , lineId , getPositionStart ( decision , parentPos ) ) ; decision [ 3 ] = wrapCondition ( decision [ 3 ] , lineId , getPositionEnd ( decision , parentPos ) ) ; return decision ; } }
1359	function isSingleCondition ( decision ) { if ( decision [ 0 ] . start && decision [ 0 ] . name != "binary" ) { return true ; } else if ( decision [ 1 ] == "&&" || decision [ 1 ] == "||" ) { return false ; } else { return true ; } }
1360	function countLabel ( ) { var ret ; if ( this [ 0 ] . start && analyzing . indexOf ( this ) < 0 ) { var content = this [ 2 ] ; if ( content [ 0 ] . name == "for" && content [ 4 ] && content [ 4 ] . name != "block" ) { content [ 4 ] = [ "block" , [ content [ 4 ] ] ] ; } analyzing . push ( content ) ; var ret = countLine . call ( this ) ; analyzing . pop ( content ) ; } return ret ; }
1361	function giveNameToAnonymousFunction ( ) { var node = this ; if ( node [ 0 ] . name == "var" || node [ 0 ] . name == "object" ) { node [ 1 ] . forEach ( function ( assignemt ) { if ( assignemt [ 1 ] ) { if ( assignemt [ 1 ] [ 0 ] . name === "function" ) { assignemt [ 1 ] [ 0 ] . anonymousName = assignemt [ 0 ] ; } else if ( assignemt [ 1 ] [ 0 ] . name === "conditional" ) { if ( assignemt [ 1 ] [ 2 ] [ 0 ] && assignemt [ 1 ] [ 2 ] [ 0 ] . name === "function" ) { assignemt [ 1 ] [ 2 ] [ 0 ] . anonymousName = assignemt [ 0 ] ; } if ( assignemt [ 1 ] [ 3 ] [ 0 ] && assignemt [ 1 ] [ 3 ] [ 0 ] . name === "function" ) { assignemt [ 1 ] [ 3 ] [ 0 ] . anonymousName = assignemt [ 0 ] ; } } } } ) ; } else if ( node [ 0 ] . name == "assign" && node [ 1 ] === true ) { if ( node [ 3 ] [ 0 ] . name === "function" ) { node [ 3 ] [ 0 ] . anonymousName = getNameFromAssign ( node ) ; } else if ( node [ 3 ] [ 0 ] === "conditional" ) { if ( node [ 3 ] [ 2 ] [ 0 ] && node [ 3 ] [ 2 ] [ 0 ] . name === "function" ) { node [ 3 ] [ 2 ] [ 0 ] . anonymousName = getNameFromAssign ( node ) ; } if ( node [ 3 ] [ 3 ] [ 0 ] && node [ 3 ] [ 3 ] [ 0 ] . name === "function" ) { node [ 3 ] [ 3 ] [ 0 ] . anonymousName = getNameFromAssign ( node ) ; } } } }
1362	function wrapConditionals ( ) { if ( options . condition === false ) { return ; } var self = this , ret ; if ( self [ 0 ] . start && analyzing . indexOf ( self ) < 0 ) { analyzing . push ( self ) ; var lineId = self [ 0 ] . name + ':' + ( self [ 0 ] . start . line + lineOffset ) ; self [ 1 ] = wrapCondition ( self [ 1 ] , lineId ) ; self [ 2 ] = walker . walk ( self [ 2 ] ) ; self [ 3 ] = walker . walk ( self [ 3 ] ) ; analyzing . pop ( self ) ; return self ; } else if ( self [ 1 ] ) { self [ 1 ] = wrapCondition ( self [ 1 ] , lineId ) ; } }
1363	function ( name , deps , module ) { switch ( arguments . length ) { case 1 : module = name ; deps = name = sb . undefined ; break ; case 2 : module = deps ; deps = name ; name = sb . undefined ; break ; case 3 : } if ( typeof module !== "function" ) { amdModules [ currentModule ] = module ; return ; } var output = { 'exports' : { } } ; if ( ! deps ) { deps = [ "require" , "exports" , "module" ] ; } for ( var i = 0 , c = deps . length ; i < c ; i ++ ) { switch ( deps [ i ] ) { case "require" : deps [ i ] = currentRequire ; break ; case "module" : deps [ i ] = output ; break ; case "exports" : deps [ i ] = output . exports ; break ; default : deps [ i ] = currentRequire && currentRequire ( deps [ i ] ) ; } } module = module . apply ( this , deps ) || output . exports ; amdModules [ currentModule ] = module ; }
1364	function stats_calculate_coverage ( moduleName ) { var stats = sb . trigger ( '*:stats-get' , moduleName , null ) [ 1 ] , total , covered , lineId , lineNum , parts ; var lineReport = { } ; if ( ! stats . lines ) { return ; } stats . coverage = { } ; covered = 0 ; total = stats . lines . length ; for ( lineId in stats . runLines ) { if ( stats . runLines [ lineId ] > 0 ) { covered ++ ; } else { lineNum = lineId ; if ( ! lineReport [ lineNum ] ) { lineReport [ lineNum ] = { } ; } lineReport [ lineNum ] . lines = false ; } } stats . coverage . lines = { total : total , covered : covered , percentage : 100.0 * ( total ? covered / total : 1 ) } ; covered = 0 ; total = stats . functions . length ; for ( lineId in stats . runFunctions ) { if ( stats . runFunctions [ lineId ] > 0 ) { covered ++ ; } else { parts = lineId . split ( ':' ) ; lineNum = parts [ 1 ] ; if ( ! lineReport [ lineNum ] ) { lineReport [ lineNum ] = { } ; } if ( ! lineReport [ lineNum ] . functions ) { lineReport [ lineNum ] . functions = [ ] ; } lineReport [ lineNum ] . functions . push ( parts [ 0 ] ) ; } } stats . coverage . functions = { total : total , covered : covered , percentage : 100.0 * ( total ? covered / total : 1 ) } ; covered = 0 ; total = stats . conditions . length ; for ( lineId in stats . runConditions ) { if ( stats . runConditions [ lineId ] [ 1 ] > 0 ) { covered += 1 ; } if ( stats . runConditions [ lineId ] [ 1 ] === 0 ) { parts = lineId . split ( ':' ) ; lineNum = parts [ 1 ] ; if ( ! lineReport [ lineNum ] ) { lineReport [ lineNum ] = { } ; } if ( ! lineReport [ lineNum ] . conditions ) { lineReport [ lineNum ] . conditions = [ ] ; } lineReport [ lineNum ] . conditions . push ( stats . runConditions [ lineId ] ) ; } } stats . coverage . conditions = { total : total , covered : covered , percentage : 100.0 * ( total ? covered / total : 1 ) } ; stats . coverage . report = lineReport ; }
1365	function ( config , mixins ) { if ( Array . isArray ( config . mixins ) && Array . isArray ( mixins ) ) { config . mixins . push . apply ( config . mixins , mixins ) ; return config ; } return deepDestructableMerge ( config , { mixins : mixins } ) ; }
1366	function ( left , right ) { for ( var prop in right ) { if ( right . hasOwnProperty ( prop ) ) { if ( typeof left [ prop ] === "object" ) { deepDestructableMerge ( left [ prop ] , right [ prop ] ) ; } else { left [ prop ] = right [ prop ] ; } } } return left ; }
1367	function ( config , configDir ) { config = config || { } ; if ( typeof config . extends !== "string" ) { return config ; } var parentConfig = tryExtend ( readConfig ( configDir , config . extends ) , configDir ) ; return deepDestructableMerge ( parentConfig , config ) ; }
1368	function ( modulePath , dependsFileMask ) { modulePath = [ ] . concat ( modulePath ) ; return modulePath . map ( function ( modulePath ) { var fileName = modulePath . replace ( / ^.*\/|\.[a-z0-9]+$ / g , '' ) ; return path . join ( path . dirname ( modulePath ) , dependsFileMask . replace ( '*' , fileName ) ) ; } ) ; }
1369	function ( configA , configB , flagsNames , isMasterConfig ) { flagsNames . forEach ( function ( optionsName ) { if ( typeof configB [ optionsName ] === "undefined" ) { return ; } if ( isMasterConfig ) { configA [ optionsName ] = configB [ optionsName ] ; } else { if ( configB [ optionsName ] instanceof Array && ! ( configA [ optionsName ] instanceof Array ) ) { configA [ optionsName ] = configB [ optionsName ] ; } else if ( configB [ optionsName ] instanceof Array && configA [ optionsName ] instanceof Array ) { configA [ optionsName ] = configA [ optionsName ] . concat ( configB [ optionsName ] ) ; } else { configA [ optionsName ] = configA [ optionsName ] || configB [ optionsName ] ; } } } ) ; }
1370	function addPluginsFromBundles ( resultConfig ) { if ( resultConfig . bundles ) { var bundles = Object . keys ( resultConfig . bundles ) , lmdPlugins = Object . keys ( LMD_PLUGINS ) ; bundles . forEach ( function ( bundleName ) { mergeFlags ( resultConfig , resultConfig . bundles [ bundleName ] , lmdPlugins , false ) ; } ) ; if ( bundles . length ) { resultConfig . bundle = true ; } } }
1371	function ( code , options ) { var exports = [ ] , requires = [ ] , bind = [ ] , extra_exports = options . extra_exports , extra_require = options . extra_require , extra_bind = options . extra_bind , exportCode , bindModuleName ; if ( typeof extra_exports === "object" ) { for ( var exportName in extra_exports ) { exportCode = extra_exports [ exportName ] ; exports . push ( ' ' + JSON . stringify ( exportName ) + ': ' + exportCode ) ; } code += '\n\n/* added by builder */\nreturn {\n' + \n + \n ; } else \n \n exports . join ( ',\n' ) \n }
1372	function ( code , moduleOptions , moduleType ) { switch ( moduleType ) { case "3-party" : code = wrap3partyModule ( code , moduleOptions ) ; break ; case "plain" : code = wrapPlainModule ( code ) ; break ; case "amd" : code = wrapAmdModule ( code ) ; break ; case "fd" : case "fe" : code = removeTailSemicolons ( code ) ; } return code ; }
1373	function getModuleType ( code ) { var ast ; if ( typeof code === "object" ) { ast = code ; } else { try { JSON . parse ( code ) ; return "json" ; } catch ( e ) { } try { ast = parser . parse ( code ) ; } catch ( e ) { return "string" ; } } if ( ast . length === 2 && ! ast [ 1 ] . length && ast [ 0 ] === 'toplevel' ) return "plain" ; if ( ast && ast . length === 2 && ast [ 1 ] && ast [ 1 ] . length === 1 && ast [ 1 ] [ 0 ] [ 0 ] === "defun" ) { return "fd" ; } if ( ast && ast . length === 2 && ast [ 1 ] && ast [ 1 ] . length === 1 && ast [ 1 ] [ 0 ] [ 0 ] === "stat" && ast [ 1 ] [ 0 ] [ 1 ] && ast [ 1 ] [ 0 ] [ 1 ] [ 0 ] === "function" ) { return "fe" ; } if ( ast ) { var isAmd = ast [ 1 ] . every ( function ( ast ) { return ast [ 0 ] === "stat" && ast [ 1 ] [ 0 ] === "call" && ast [ 1 ] [ 1 ] [ 0 ] === "name" && ast [ 1 ] [ 1 ] [ 1 ] === "define" ; } ) ; if ( isAmd ) { return "amd" ; } } return "plain" ; }
1374	function d3_transform ( m ) { var r0 = [ m . a , m . b ] , r1 = [ m . c , m . d ] , kx = d3_transformNormalize ( r0 ) , kz = d3_transformDot ( r0 , r1 ) , ky = d3_transformNormalize ( d3_transformCombine ( r1 , r0 , - kz ) ) ; this . translate = [ m . e , m . f ] ; this . rotate = Math . atan2 ( m . b , m . a ) * d3_transformDegrees ; this . scale = [ kx , ky || 0 ] ; this . skew = ky ? kz / ky * d3_transformDegrees : 0 ; }
1375	function mousewheel ( ) { start . apply ( this , arguments ) ; if ( ! d3_behavior_zoomZooming ) d3_behavior_zoomZooming = d3_behavior_zoomLocation ( d3 . svg . mouse ( d3_behavior_zoomTarget ) ) ; d3_behavior_zoomTo ( d3_behavior_zoomDelta ( ) + xyz [ 2 ] , d3 . svg . mouse ( d3_behavior_zoomTarget ) , d3_behavior_zoomZooming ) ; }
1376	function d3_behavior_zoomDelta ( ) { if ( ! d3_behavior_zoomDiv ) { d3_behavior_zoomDiv = d3 . select ( "body" ) . append ( "div" ) . style ( "visibility" , "hidden" ) . style ( "top" , 0 ) . style ( "height" , 0 ) . style ( "width" , 0 ) . style ( "overflow-y" , "scroll" ) . append ( "div" ) . style ( "height" , "2000px" ) . node ( ) . parentNode ; } var e = d3 . event , delta ; try { d3_behavior_zoomDiv . scrollTop = 1000 ; d3_behavior_zoomDiv . dispatchEvent ( e ) ; delta = 1000 - d3_behavior_zoomDiv . scrollTop ; } catch ( error ) { delta = e . wheelDelta || ( - e . detail * 5 ) ; } return delta * .005 ; }
1377	function ( data ) { var config ; if ( typeof data === "string" ) { config = parseArgv ( data ) ; if ( Object . keys ( config ) . length ) { config . mode = config . mode || config . m ; config . output = config . output || config . o ; config . log = config . log || config . l ; config . config = config . config || config . c ; config [ 'no-warn' ] = config [ 'no-warn' ] || config [ 'no-w' ] ; config [ 'source-map' ] = config [ 'source-map' ] || config [ 'sm' ] ; config [ 'source-map-root' ] = config [ 'source-map-root' ] || config [ 'sm-root' ] ; config [ 'source-map-www' ] = config [ 'source-map-www' ] || config [ 'sm-www' ] ; config [ 'source-map-inline' ] = config [ 'source-map-inline' ] || config [ 'sm-inline' ] ; } else { data = data . split ( ' ' ) ; if ( availableModes . indexOf ( data [ 2 ] ) === - 1 ) { config = { mode : 'main' , config : data [ 2 ] , output : data [ 3 ] } ; } else { config = { mode : data [ 2 ] , config : data [ 3 ] , output : data [ 4 ] } ; } } } else if ( typeof config === "object" ) { config = data ; } else { throw new Error ( 'Bad config data' ) ; } config . mode = config . mode || 'main' ; config . warn = ! config [ 'no-warn' ] ; config . sourcemap = config [ 'source-map' ] || false ; config . www_root = config [ 'source-map-root' ] || "" ; config . sourcemap_www = config [ 'source-map-www' ] || "" ; config . sourcemap_inline = config [ 'source-map-inline' ] || false ; config . log = config . log || false ; return config ; }
1378	function parse ( options , document , callback ) { xml2js . parseString ( document , { trim : true , normalizeTags : true , normalize : true } , function ( err , result ) { var source = options . source ; if ( ! err ) { _ . find ( result . urlset . url , function ( urlNode ) { var url , process = ! options . sitemapPolicy || ! stillCurrent ( urlNode , options ) ; if ( process ) { url = urlm . parse ( urlNode . loc [ 0 ] ) ; if ( ! base . input ( _ . extend ( { } , options , { protocol : url . protocol , auth : url . auth , hostname : url . hostname , port : url . port } ) , urlNode . loc [ 0 ] ) ) { source = urlNode . loc [ 0 ] ; err = base . generatorError ( ) ; } } return err ; } ) ; } callback ( common . prependMsgToErr ( err , source , true ) ) ; } ) ; }
1379	function convert ( options , buffer , next , callback ) { var gunzip = path . extname ( options . source ) === ".gz" ; if ( gunzip ) { zlib . gunzip ( buffer , function ( err , result ) { if ( err ) { callback ( common . prependMsgToErr ( err , options . source , true ) ) ; } else { next ( options , result && result . toString ( ) , callback ) ; } } ) ; } else { next ( options , buffer . toString ( ) , callback ) ; } }
1380	function getUrl ( options , parseFn , callback ) { request ( { url : options . source , encoding : null , timeout : options . timeout ( ) } , function ( err , res , body ) { var error = err || common . checkResponse ( res , [ "text/xml" , "application/xml" ] ) ; if ( error ) { callback ( common . prependMsgToErr ( error , options . source , true ) ) ; } else { convert ( options , body , parseFn , callback ) ; } } ) ; }
1381	function getFile ( options , parseFn , callback ) { fs . readFile ( options . source , function ( err , data ) { if ( err ) { callback ( common . prependMsgToErr ( err , options . source , true ) ) ; } else { convert ( options , data , parseFn , callback ) ; } } ) ; }
1382	function ( error , message , quoteInput ) { var result , prepend , empty = "" , quote = "'" ; if ( error ) { if ( message ) { prepend = quoteInput ? empty . concat ( quote , message , quote ) : message ; } error = error instanceof Error ? error : new Error ( empty + error ) ; error . message = prepend ? empty . concat ( prepend , ": " , error . message ) : error . message ; result = error ; } return result ; }
1383	function ( res , mediaTypes ) { var contentTypeOk , result = "status: '" + res . statusCode + "', GET failed." ; mediaTypes = ! Array . isArray ( mediaTypes ) ? [ mediaTypes ] : mediaTypes ; if ( res . statusCode === 200 ) { contentTypeOk = res . headers [ "content-type" ] && ! mediaTypes . every ( function ( mediaType ) { return ! ~ res . headers [ "content-type" ] . indexOf ( mediaType ) ; } ) ; result = contentTypeOk ? "" : "content-type not one of '" + mediaTypes . join ( "," ) + "'" ; } return result ; }
1384	function nodeCall ( nodeFunc ) { var nodeArgs = Array . prototype . slice . call ( arguments , 1 ) ; return new Promise ( function ( resolve , reject ) { function nodeResolver ( err , value ) { if ( err ) { reject ( err ) ; } else { resolve ( value ) ; } } nodeArgs . push ( nodeResolver ) ; nodeFunc . apply ( nodeFunc , nodeArgs ) ; } ) ; }
1385	function prepareWrite ( outputPath , callback ) { var path = pathLib . parse ( outputPath ) ; var dir = pathLib . join ( path . root , path . dir ) ; mkdirp ( dir , callback ) ; }
1386	function parse ( options , document , callback ) { xml2js . parseString ( document , { trim : true , normalizeTags : true , normalize : true } , function ( err , result ) { var sitemapUrls = [ ] ; var sitemapIndexOptions = Object . assign ( { } , options , { outputPath : undefined } ) ; if ( ! err ) { _ . forEach ( result . sitemapindex . sitemap , function ( sitemapNode ) { var shouldProcess = ! options . sitemapPolicy || ! smLib . stillCurrent ( sitemapNode , sitemapIndexOptions ) ; if ( shouldProcess ) { sitemapUrls . push ( sitemapNode . loc [ 0 ] ) ; } } ) ; if ( sitemapUrls . length === 0 ) { console . log ( "[*] No sitemaps qualified for processing" ) ; } Promise . all ( sitemapUrls . map ( function ( sitemapUrl ) { var sitemapOptions = Object . assign ( { } , options , { source : sitemapUrl , input : "sitemap" , sitemapOutputDir : false , __sitemapIndex : sitemapIndexOptions } ) ; console . log ( "[+] Loading the sitemap: '" + sitemapUrl + "'" ) ; return nodeCall ( smLib . getUrl , sitemapOptions , processSitemap ) ; } ) ) . then ( function ( ) { callback ( ) ; } ) . catch ( callback ) ; } else { callback ( err ) ; } } ) ; }
1387	function ( options , listener ) { var opts = Object . assign ( { } , base . defaults ( defaults ) , options ) ; return base . run ( opts , generateInput , listener ) ; }
1388	function generateInput ( options ) { return nodeCall ( fs . readFile , options . source ) . catch ( function ( err ) { options . _abort ( err ) ; } ) . then ( function ( data ) { var error ; if ( data ) { data . toString ( ) . split ( '\n' ) . \n every ; ( function ( line ) { var page = line . replace ( / ^\s+|\s+$ / g , "" ) ; if ( ! base . input ( options , page ) ) { error = common . prependMsgToErr ( base . generatorError ( ) , page , true ) ; return false ; } return true ; } ) } if ( error ) { console . error ( error ) ; options . _abort ( error ) ; } } ) ; }
1389	function generateInput ( options ) { var result = new Promise ( function ( resolve , reject ) { var all ; if ( Array . isArray ( options . source ) ) { all = options . source . every ( function ( sourceUrl ) { var url = urlm . parse ( sourceUrl ) ; var opts = Object . assign ( { } , options , { protocol : url . protocol , auth : url . auth , hostname : url . hostname , port : url . port } ) ; if ( ! base . input ( opts , sourceUrl ) ) { reject ( common . prependMsgToErr ( base . generatorError ( ) , sourceUrl , true ) ) ; return false ; } return true ; } ) ; if ( all ) { resolve ( ) ; } } else { reject ( new Error ( "options.source must be an array" ) ) ; } } ) ; return result . catch ( function ( error ) { options . _abort ( error ) ; } ) . then ( function ( ) { base . EOI ( array ) ; } ) ; }
1390	function normalize ( obj ) { var result = obj ; if ( typeof obj !== "function" ) { if ( typeof obj !== "undefined" ) { if ( Object . prototype . toString . call ( obj ) !== "[object Object]" ) { result = ( function ( value ) { return function ( ) { return value ; } ; } ( obj ) ) ; } else { result = ( function ( o ) { return function ( key , passthru ) { if ( o [ key ] === void 0 ) { return o . __default || ( passthru ? key : undefined ) ; } else { return o [ key ] ; } } ; } ( obj ) ) ; } } else { result = function ( passthru ) { return passthru ; } ; } } return result ; }
1391	function supplyMissingDefault ( options , name ) { if ( options [ name ] ( ) === void 0 ) { options [ name ] = _ . wrap ( options [ name ] , function ( func , key ) { var res = func ( key ) ; return res === void 0 ? defaults [ name ] : res ; } ) ; } }
1392	function prepOptions ( options , listener ) { common . ensure ( options , defaults ) ; [ "selector" , "timeout" , "useJQuery" , "verbose" , "phantomjsOptions" ] . forEach ( function ( perPageOption ) { options [ perPageOption ] = normalize ( options [ perPageOption ] ) ; supplyMissingDefault ( options , perPageOption ) ; } ) ; options . _inputEmitter = new EventEmitter ( ) ; options . _inputEmitter . on ( "input" , listener ) ; }
1393	function getOutputPath ( options , page , parse ) { var pagePart = urlm . parse ( page ) , outputPath = options . outputPath ( page , true ) ; if ( ! outputPath ) { return false ; } if ( common . isUrl ( outputPath ) ) { outputPath = pagePart . path + ( pagePart . hash ? pagePart . hash : "" ) ; } if ( parse ) { parse . url = pagePart ; } return outputPath ; }
1394	function mapOutputFile ( options , page , parse ) { if ( ! _ . isFunction ( options . outputPath ) ) { options . outputPath = normalize ( options . outputPath ) ; } var outputPath = getOutputPath ( options , page , parse ) ; var outputDir = options . outputDir ; var fileName = "index.html" ; if ( options . sitemapOutputDir ) { outputDir = path . join ( options . outputDir , options . sitemapOutputDir ) ; fileName = "" ; } return ( outputPath && path . join ( outputDir , outputPath , fileName ) ) || false ; }
1395	function ( options , generator , listener ) { options = options || { } ; prepOptions ( options , listener ) ; return generator ( options ) ; }
1396	function ( options , page ) { var parse = { } ; var outputFile = mapOutputFile ( options , page , parse ) ; if ( outputFile ) { options . _inputEmitter . emit ( "input" , { outputFile : outputFile , url : urlm . format ( { protocol : options . protocol , auth : options . auth , hostname : options . hostname , port : options . port , pathname : parse . url . pathname , search : parse . url . search , hash : parse . url . hash } ) , selector : options . selector ( page ) , timeout : options . timeout ( page ) , checkInterval : options . checkInterval , useJQuery : options . useJQuery ( page ) , verbose : options . verbose ( page ) , phantomjsOptions : options . phantomjsOptions ( page ) , __page : page } ) ; } return outputFile ; }
1397	function pathExists ( path , options ) { options = options || { returnFile : false } ; return nodeCall ( fs . access , path ) . then ( function ( ) { return options . returnFile ? path : true ; } ) . catch ( function ( ) { if ( fs . existsSync ( path ) ) { return options . returnFile ? path : true ; } return false ; } ) ; }
1398	function ( ) { var phantomSource = require ( "phantomjs-prebuilt" ) . path ; if ( path . extname ( phantomSource ) . toLowerCase ( ) === ".cmd" ) { return path . join ( path . dirname ( phantomSource ) , "//node_modules//phantomjs-prebuilt//lib//phantom//bin//phantomjs.exe" ) ; } return phantomSource ; }
1399	function worker ( input , options , notifier , qcb ) { var cp , customModule , snapshotScript = options . snapshotScript , phantomjsOptions = Array . isArray ( input . phantomjsOptions ) ? input . phantomjsOptions : [ input . phantomjsOptions ] ; if ( ! notifier . known ( input . outputFile ) ) { if ( _ . isObject ( options . snapshotScript ) ) { snapshotScript = path . join ( __dirname , phantomDir , options . snapshotScript . script ) + ".js" ; customModule = options . snapshotScript . module ; } cp = spawn ( options . phantomjs , phantomjsOptions . concat ( [ snapshotScript , input . outputFile , input . url , input . selector , input . timeout , input . checkInterval , input . useJQuery , input . verbose , customModule ] ) , { cwd : process . cwd ( ) , stdio : "inherit" , detached : true } ) ; cp . on ( "error" , function ( e ) { notifier . remove ( input . outputFile ) ; notifier . setError ( e ) ; console . error ( e ) ; qcb ( e ) ; } ) ; cp . on ( "exit" , function ( code ) { qcb ( code ) ; } ) ; notifier . add ( input . outputFile , input . timeout ) ; } else { qcb ( 0 ) ; } }
1400	function prepOptions ( options ) { common . ensure ( options , defaults ) ; if ( Array . isArray ( options . source ) ) { options . input = "array" ; } }
1401	function ( options , listener ) { var inputGenerator , notifier , started , result , q , emitter , completion ; options = options || { } ; prepOptions ( options ) ; inputGenerator = inputFactory . create ( options . input ) ; if ( options . outputDirClean ) { rimraf ( options . outputDir ) ; } notifier = new Notifier ( ) ; emitter = new EventEmitter ( ) ; started = notifier . start ( options . pollInterval , inputGenerator , function ( err , completed ) { emitter . emit ( "complete" , err , completed ) ; } ) ; if ( started ) { completion = new Promise ( function ( resolve , reject ) { function completionResolver ( err , completed ) { try { _ . isFunction ( listener ) && listener ( err , completed ) ; } catch ( e ) { console . error ( "User supplied listener exception" , e ) ; } if ( err ) { err . notCompleted = notifier . filesNotDone ; err . completed = completed ; reject ( err ) ; } else { resolve ( completed ) ; } } emitter . addListener ( "complete" , completionResolver ) ; } ) ; q = asyncLib . queue ( function ( task , callback ) { task ( _ . once ( callback ) ) ; } , options . processLimit ) ; q . empty = notifier . qEmpty . bind ( notifier ) ; options . _abort = function ( err ) { notifier . abort ( q , err ) ; } ; result = inputGenerator . run ( options , function ( input ) { q . push ( _ . partial ( worker , input , options , notifier ) ) ; } ) . then ( function ( ) { return completion ; } ) ; } else { result = Promise . reject ( "failed to start async notifier" ) ; } return result ; }
1402	function createLockFactory ( ) { var lock = new AsyncLock ( ) ; var rid = crypto . randomBytes ( 16 ) . toString ( "hex" ) ; return function lockFactory ( fn , timeout ) { return function protectedContext ( ) { lock . acquire ( "cs-guard-" + rid , function ( done ) { fn ( function ( ) { done ( null , 0 ) ; } ) ; } , NOOP , { timeout : timeout } ) ; } ; } ; }
1403	function Notifier ( ) { this . csFactory = createLockFactory ( ) ; this . files = { } ; this . filesDone = [ ] ; this . filesNotDone = [ ] ; this . errors = [ ] ; this . padTimeout = TIMEOUT_PAD_FLOOR ; this . callback = null ; this . qempty = false ; }
1404	function start ( pollInterval , input , listener ) { var result = ( pollInterval > 0 && typeof listener === "function" && ( ! ! input ) ) ; if ( result ) { if ( this . isStarted ( ) ) { throw new Error ( "Notifier already started" ) ; } this . callback = listener ; this . interval = parseInt ( pollInterval , 10 ) ; this . watcher = setInterval ( this . csFactory ( function ( done ) { var self = this ; var eoi = typeof input . EOI === "function" && input . EOI ( ) ; if ( eoi ) { Promise . all ( Object . keys ( self . files ) . map ( function ( file ) { return pathExists ( file , { returnFile : true } ) ; } ) ) . then ( function ( files ) { var callback = self . callback ; try { files . forEach ( function ( file ) { file && self . _remove ( file , true ) ; } ) ; if ( self . _isDone ( ) ) { self . _closeWatcher ( ) ; if ( self . callback ) { self . callback = null ; setImmediate ( function ( ) { callback ( self . getError ( ) , self . filesDone ) ; } ) ; } } } catch ( e ) { console . error ( e ) ; } done ( ) ; } ) ; } else { done ( ) ; } } . bind ( this ) , L_WAIT ) , this . interval ) ; } else { console . error ( "Bad poll interval, async listener, or input generator supplied" ) ; } return result ; }
1405	function add ( outputFile , timeout ) { var failTimeout = timeout ; var timer ; if ( ! this . isStarted ( ) ) { throw new Error ( "MUST call `start` before `add`" ) ; } if ( ! this . _exists ( outputFile ) ) { failTimeout = parseInt ( timeout , 10 ) + parseInt ( this . padTimeout , 10 ) ; this . padTimeout += 100 ; timer = setTimeout ( this . csFactory ( function ( done ) { var self = this ; if ( self . _exists ( outputFile ) ) { pathExists ( outputFile ) . then ( function ( fsExists ) { var callback = self . callback ; try { if ( ! fsExists ) { self . _setError ( new Error ( "'" + outputFile + "' did not get a snapshot before timeout" ) ) ; } self . _remove ( outputFile , fsExists ) ; if ( self . _isDone ( ) ) { self . _closeWatcher ( ) ; if ( self . callback ) { self . callback = null ; setImmediate ( function ( ) { callback ( self . getError ( ) , self . filesDone ) ; } ) ; } } } catch ( e ) { console . error ( e ) ; } done ( ) ; } ) ; } else { done ( ) ; } } . bind ( this ) , L_WAIT ) , parseInt ( failTimeout , 10 ) ) ; this . files [ outputFile ] = { timer : timer } ; } }
1406	function known ( outputFile ) { var result = false ; this . csFactory ( function ( done ) { result = this . _exists ( outputFile ) || this . filesDone . indexOf ( outputFile ) > - 1 ; done ( ) ; } . bind ( this ) , L_WAIT ) ( ) ; return result ; }
1407	function _remove ( outputFile , done ) { if ( this . _exists ( outputFile ) ) { if ( done ) { this . filesDone . push ( outputFile ) ; } else { this . filesNotDone . push ( outputFile ) ; } clearTimeout ( this . files [ outputFile ] . timer ) ; delete this . files [ outputFile ] ; } }
1408	function remove ( outputFile , done ) { this . csFactory ( function ( _done ) { this . _remove ( outputFile , done ) ; _done ( ) ; } . bind ( this ) , L_WAIT ) ( ) ; }
1409	function ( time ) { fs . write ( options . outputFile , filter ( page . content ) , "w" ) ; globals . exit ( 0 , "snapshot for " + options . url + " finished in " + time + " ms\n written to " + \n ) ; }
1410	function oneline ( line , options ) { var key = "Allow: " , index = line . indexOf ( key ) ; if ( index !== - 1 ) { var page = line . substr ( index + key . length ) . replace ( / ^\s+|\s+$ / g , "" ) ; return page . indexOf ( "*" ) === - 1 && base . input ( options , page ) ; } return true ; }
1411	function getRobotsUrl ( options , callback ) { request ( { url : options . source , timeout : options . timeout ( ) } , function ( err , res , body ) { var error = err || common . checkResponse ( res , "text/plain" ) ; if ( error ) { callback ( common . prependMsgToErr ( error , options . source , true ) ) ; } else { body . toString ( ) . split ( '\n' ) . \n every ; ( function ( line ) { if ( ! oneline ( line , options ) ) { error = common . prependMsgToErr ( base . generatorError ( ) , line , true ) ; return false ; } return true ; } ) } } ) ; }
1412	function getRobotsFile ( options , callback ) { fs . readFile ( options . source , function ( err , data ) { if ( ! err ) { data . toString ( ) . split ( '\n' ) . \n every ; } ( function ( line ) { if ( ! oneline ( line , options ) ) { err = common . prependMsgToErr ( base . generatorError ( ) , line , true ) ; return false ; } return true ; } ) } ) ; }
1413	function bubble ( values ) { return values . map ( d => { if ( d . key && d . values ) { if ( d . values [ 0 ] . key === "undefined" ) return d . values [ 0 ] . values [ 0 ] ; else d . values = bubble ( d . values ) ; } return d ; } ) ; }
1414	function exclude ( a , b , v ) { const aStart = a . start ( { type : "bigInteger" } ) ; const bStart = b . start ( { type : "bigInteger" } ) ; const aEnd = a . end ( { type : "bigInteger" } ) ; const bEnd = b . end ( { type : "bigInteger" } ) ; const parts = [ ] ; if ( aStart . compareTo ( bEnd ) > 0 || aEnd . compareTo ( bStart ) < 0 ) { return [ a . cidr ] ; } if ( aStart . compareTo ( bStart ) === 0 && aEnd . compareTo ( bEnd ) === 0 ) { return [ ] ; } if ( aStart . compareTo ( bStart ) > 0 && aEnd . compareTo ( bEnd ) < 0 ) { return [ ] ; } if ( aStart . compareTo ( bStart ) < 0 && aEnd . compareTo ( bEnd ) <= 0 ) { parts . push ( { start : aStart , end : bStart . subtract ( one ) , } ) ; } if ( aStart . compareTo ( bStart ) >= 0 && aEnd . compareTo ( bEnd ) > 0 ) { parts . push ( { start : bEnd . add ( one ) , end : aEnd , } ) ; } if ( aStart . compareTo ( bStart ) < 0 && aEnd . compareTo ( bEnd ) > 0 ) { parts . push ( { start : aStart , end : bStart . subtract ( one ) , } ) ; parts . push ( { start : bEnd . add ( one ) , end : aEnd , } ) ; } const remaining = [ ] ; for ( const part of parts ) { for ( const subpart of subparts ( part , v ) ) { remaining . push ( formatPart ( subpart , v ) ) ; } } return cidrTools . merge ( remaining ) ; }
1415	function getMsTimestamp ( ) { var ts = new Date ( ) . getTime ( ) ; if ( lastMsTs >= ts ) { lastMsTs ++ ; } else { lastMsTs = ts ; } return lastMsTs ; }
1416	function parseUrl ( url ) { var serverOptions = { host : "localhost" , port : 80 } ; if ( url . indexOf ( "https" ) === 0 ) { serverOptions . port = 443 ; } var host = url . split ( "://" ) . pop ( ) ; serverOptions . host = host ; var lastPos = host . indexOf ( ":" ) ; if ( lastPos > - 1 ) { serverOptions . host = host . slice ( 0 , lastPos ) ; serverOptions . port = Number ( host . slice ( lastPos + 1 , host . length ) ) ; } return serverOptions ; }
1417	function prepareParams ( params ) { var str = [ ] ; for ( var i in params ) { str . push ( i + "=" + encodeURIComponent ( params [ i ] ) ) ; } return str . join ( "&" ) ; }
1418	function stripTrailingSlash ( str ) { if ( str . substr ( str . length - 1 ) === "/" ) { return str . substr ( 0 , str . length - 1 ) ; } return str ; }
1419	function getProperties ( orig , props ) { var ob = { } ; var prop ; for ( var i = 0 ; i < props . length ; i ++ ) { prop = props [ i ] ; if ( typeof orig [ prop ] !== "undefined" ) { ob [ prop ] = orig [ prop ] ; } } return ob ; }
1420	function add_cly_events ( event ) { if ( ! event . key ) { log ( "Event must have key property" ) ; return ; } if ( cluster . isMaster ) { if ( ! event . count ) { event . count = 1 ; } var props = [ "key" , "count" , "sum" , "dur" , "segmentation" ] ; var e = getProperties ( event , props ) ; e . timestamp = getMsTimestamp ( ) ; var date = new Date ( ) ; e . hour = date . getHours ( ) ; e . dow = date . getDay ( ) ; log ( "Adding event: " , event ) ; eventQueue . push ( e ) ; storeSet ( "cly_event" , eventQueue ) ; } else { process . send ( { cly : { event : event } } ) ; } }
1421	function prepareRequest ( request ) { request . app_key = Countly . app_key ; request . device_id = Countly . device_id ; request . sdk_name = SDK_NAME ; request . sdk_version = SDK_VERSION ; if ( Countly . check_consent ( "location" ) ) { if ( Countly . country_code ) { request . country_code = Countly . country_code ; } if ( Countly . city ) { request . city = Countly . city ; } if ( Countly . ip_address !== null ) { request . ip_address = Countly . ip_address ; } } else { request . location = "" ; } request . timestamp = getMsTimestamp ( ) ; var date = new Date ( ) ; request . hour = date . getHours ( ) ; request . dow = date . getDay ( ) ; }
1422	function toRequestQueue ( request ) { if ( cluster . isMaster ) { if ( ! Countly . app_key || ! Countly . device_id ) { log ( "app_key or device_id is missing" ) ; return ; } prepareRequest ( request ) ; if ( requestQueue . length > queueSize ) { requestQueue . shift ( ) ; } requestQueue . push ( request ) ; storeSet ( "cly_queue" , requestQueue ) ; } else { process . send ( { cly : { cly_queue : request } } ) ; } }
1423	function getMetrics ( ) { var m = JSON . parse ( JSON . stringify ( metrics ) ) ; m . _app_version = m . _app_version || Countly . app_version ; m . _os = m . _os || os . type ( ) ; m . _os_version = m . _os_version || os . release ( ) ; platform = os . type ( ) ; log ( "Got metrics" , m ) ; return m ; }
1424	function makeRequest ( url , path , params , callback ) { try { log ( "Sending HTTP request" ) ; var serverOptions = parseUrl ( url ) ; var data = prepareParams ( params ) ; var method = "GET" ; var options = { host : serverOptions . host , port : serverOptions . port , path : path + "?" + data , method : "GET" } ; if ( data . length >= 2000 ) { method = "POST" ; } else if ( Countly . force_post ) { method = "POST" ; } if ( method === "POST" ) { options . method = "POST" ; options . path = path ; options . headers = { "Content-Type" : "application/x-www-form-urlencoded" , "Content-Length" : Buffer . byteLength ( data ) } ; } var protocol = http ; if ( url . indexOf ( "https" ) === 0 ) { protocol = https ; } var req = protocol . request ( options , function ( res ) { var str = "" ; res . on ( "data" , function ( chunk ) { str += chunk ; } ) ; res . on ( "end" , function ( ) { if ( res . statusCode >= 200 && res . statusCode < 300 ) { callback ( false , params , str ) ; } else { callback ( true , params ) ; } } ) ; } ) ; if ( method === "POST" ) { req . write ( data ) ; } req . on ( "error" , function ( err ) { log ( "Connection failed." , err ) ; if ( typeof callback === "function" ) { callback ( true , params ) ; } } ) ; req . end ( ) ; } catch ( e ) { log ( "Failed HTTP request" , e ) ; if ( typeof callback === "function" ) { callback ( true , params ) ; } } }
1425	function allSettled ( promises ) { "use strict" ; const wrappedPromises = promises . map ( ( curPromise ) => curPromise . reflect ( ) ) ; return Promise . all ( wrappedPromises ) ; }
1426	function after ( parent , index ) { var siblings = parent . children var sibling = siblings [ ++ index ] var other if ( is ( 'WhiteSpaceNode' , sibling ) ) { sibling = siblings [ ++ index ] if ( is ( 'PunctuationNode' , sibling ) && punctuation . test ( toString ( sibling ) ) ) { sibling = siblings [ ++ index ] } if ( is ( 'WordNode' , sibling ) ) { other = sibling } } return other }
1427	function classify ( value ) { var type = null var normal value = value . replace ( digits , toWords ) . split ( split , 1 ) [ 0 ] normal = lower ( value ) if ( requiresA ( value ) ) { type = 'a' } if ( requiresAn ( value ) ) { type = type === 'a' ? 'a-or-an' : 'an' } if ( ! type && normal === value ) { type = vowel . test ( normal . charAt ( 0 ) ) ? 'an' : 'a' } return type }
1428	function factory ( list ) { var expressions = [ ] var sensitive = [ ] var insensitive = [ ] construct ( ) return test function construct ( ) { var length = list . length var index = - 1 var value var normal while ( ++ index < length ) { value = list [ index ] normal = value === lower ( value ) if ( value . charAt ( value . length - 1 ) === '*' ) { expressions . push ( new RegExp ( '^' + value . slice ( 0 , - 1 ) , 'i' ) ) } else if ( normal ) { insensitive . push ( value ) } else { sensitive . push ( value ) } } } function test ( value ) { var normal = lower ( value ) var length var index if ( sensitive . indexOf ( value ) !== - 1 || insensitive . indexOf ( normal ) !== - 1 ) { return true } length = expressions . length index = - 1 while ( ++ index < length ) { if ( expressions [ index ] . test ( value ) ) { return true } } return false } }
1429	function ( rcb ) { return function ( ) { if ( frc || ! db [ cname ] ) { bindColCtls ( db ) ; } if ( rcb ) { rcb . apply ( this , arguments ) ; } } }
1430	function ( ) { Object . defineProperty ( this , "_impl" , { value : new EJDBImpl ( ) , configurable : false , enumerable : false , writable : false } ) ; return this ; }
1431	function dummyText ( opts ) { var corpus = opts . corpus || 'lorem' , i = opts . start , isRandom = typeof ( i ) === 'undefined' , mustReset = typeof ( origin ) === 'undefined' , skip = opts . skip || 1 , sentences = opts . sentences || 1 , words = opts . words , text = texts [ corpus ] || texts . lorem , len = text . length , output = [ ] , s ; if ( isRandom ) { i = Math . floor ( Math . random ( ) * len ) ; } if ( mustReset ) { origin = i ; } if ( isRandom ) { i = ( ( i + len - origin ) % len + len ) % len ; } while ( sentences -- ) { s = text [ i ] ; if ( words ) { s = s . split ( ' ' ) . slice ( 0 , words ) . join ( ' ' ) ; } output . push ( s ) ; i = ( i + skip ) % len ; } return output . join ( ' ' ) ; }
1432	function Back ( options ) { if ( ! ( this instanceof Back ) ) { return new Back ( options ) ; } this . settings = extend ( options ) ; this . reconnect = null ; }
1433	function css ( files , output , options ) { options = Object . assign ( { banner : false } , options ) ; return ( ) => { var build = gulp . src ( files ) if ( options . banner ) build = build . pipe ( $ . header ( banner , { pkg } ) ) ; build = build . pipe ( $ . rename ( 'd3.compose.css' ) ) . pipe ( gulp . dest ( output ) ) ; return build ; } ; }
1434	function series ( ) { const tasks = Array . prototype . slice . call ( arguments ) ; var fn = cb => cb ( ) ; if ( typeof tasks [ tasks . length - 1 ] === 'function' ) fn = tasks . pop ( ) ; return ( cb ) => { const tasks_with_cb = tasks . concat ( [ ( err ) => { if ( err ) return cb ( err ) ; fn ( cb ) ; } ] ) ; runSequence . apply ( this , tasks_with_cb ) ; } }
1435	function simpleTypeFilter ( doc , oldDoc , candidateDocType ) { if ( oldDoc ) { if ( doc . _deleted ) { return oldDoc . type === candidateDocType ; } else { return doc . type === oldDoc . type && oldDoc . type === candidateDocType ; } } else { return doc . type === candidateDocType ; } }
1436	function padRight ( value , desiredLength , padding ) { while ( value . length < desiredLength ) { value += padding ; } return value ; }
1437	function resolveCollectionDefinition ( doc , oldDoc , collectionDefinition , itemPrefix ) { if ( utils . isValueNullOrUndefined ( collectionDefinition ) ) { return [ ] ; } else { if ( typeof collectionDefinition === 'function' ) { var fnResults = collectionDefinition ( doc , oldDoc ) ; return resolveCollectionItems ( fnResults , itemPrefix ) ; } else { return resolveCollectionItems ( collectionDefinition , itemPrefix ) ; } } }
1438	function assignRolesToUsers ( doc , oldDoc , accessAssignmentDefinition ) { var users = resolveCollectionDefinition ( doc , oldDoc , accessAssignmentDefinition . users ) ; var roles = resolveRoleCollectionDefinition ( doc , oldDoc , accessAssignmentDefinition . roles ) ; role ( users , roles ) ; return { type : 'role' , users : users , roles : roles } ; }
1439	function getAllDocChannels ( docDefinition ) { var docChannelMap = utils . resolveDocumentConstraint ( docDefinition . channels ) ; var allChannels = [ ] ; if ( docChannelMap ) { appendToAuthorizationList ( allChannels , docChannelMap . view ) ; appendToAuthorizationList ( allChannels , docChannelMap . write ) ; appendToAuthorizationList ( allChannels , docChannelMap . add ) ; appendToAuthorizationList ( allChannels , docChannelMap . replace ) ; appendToAuthorizationList ( allChannels , docChannelMap . remove ) ; } return allChannels ; }
1440	function outputHelpIfNecessary ( cmd , options ) { options = options || [ ] ; for ( var i = 0 ; i < options . length ; i ++ ) { if ( options [ i ] === '--help' || options [ i ] === '-h' ) { cmd . outputHelp ( ) ; process . exit ( 0 ) ; } } }
1441	function humanReadableArgName ( arg ) { var nameOutput = arg . name + ( arg . variadic === true ? '...' : '' ) ; return arg . required ? '<' + nameOutput + '>' : '[' + nameOutput + ']' ; }
1442	function validateObjectProperties ( propertyValidators , allowUnknownProperties , ignoreInternalProperties ) { var currentItemEntry = itemStack [ itemStack . length - 1 ] ; var objectValue = currentItemEntry . itemValue ; var oldObjectValue = currentItemEntry . oldItemValue ; var supportedProperties = [ ] ; for ( var propertyValidatorName in propertyValidators ) { var validator = propertyValidators [ propertyValidatorName ] ; if ( utils . isValueNullOrUndefined ( validator ) || utils . isValueNullOrUndefined ( resolveItemConstraint ( validator . type ) ) ) { continue ; } var propertyValue = objectValue [ propertyValidatorName ] ; var oldPropertyValue ; if ( ! utils . isValueNullOrUndefined ( oldObjectValue ) ) { oldPropertyValue = oldObjectValue [ propertyValidatorName ] ; } supportedProperties . push ( propertyValidatorName ) ; itemStack . push ( { itemValue : propertyValue , oldItemValue : oldPropertyValue , itemName : propertyValidatorName } ) ; validateItemValue ( validator ) ; itemStack . pop ( ) ; } if ( ! allowUnknownProperties ) { for ( var propertyName in objectValue ) { if ( ignoreInternalProperties && propertyName . indexOf ( '_' ) === 0 ) { continue ; } if ( supportedProperties . indexOf ( propertyName ) < 0 ) { var objectPath = buildItemPath ( itemStack ) ; var fullPropertyPath = objectPath ? objectPath + '.' + propertyName : propertyName ; validationErrors . push ( 'property "' + fullPropertyPath + '" is not supported' ) ; } } } }
1443	function buildItemPath ( itemStack ) { var nameComponents = [ ] ; for ( var i = 0 ; i < itemStack . length ; i ++ ) { var itemName = itemStack [ i ] . itemName ; if ( ! itemName ) { continue ; } else if ( nameComponents . length < 1 || itemName . indexOf ( '[' ) === 0 ) { nameComponents . push ( itemName ) ; } else { nameComponents . push ( '.' + itemName ) ; } } return nameComponents . join ( '' ) ; }
1444	function getBusinessId ( doc , oldDoc ) { var regex = / ^biz\.([A-Za-z0-9_-]+)(?:\..+)?$ / ; var matchGroups = regex . exec ( doc . _id ) ; if ( matchGroups ) { return matchGroups [ 1 ] ; } else if ( oldDoc && oldDoc . businessId ) { return oldDoc . businessId || null ; } else { return doc . businessId || null ; } }
1445	function toDefaultSyncChannels ( doc , oldDoc , basePrivilegeName ) { var businessId = getBusinessId ( doc , oldDoc ) ; return function ( doc , oldDoc ) { return { view : [ toSyncChannel ( businessId , 'VIEW_' + basePrivilegeName ) ] , add : [ toSyncChannel ( businessId , 'ADD_' + basePrivilegeName ) ] , replace : [ toSyncChannel ( businessId , 'CHANGE_' + basePrivilegeName ) ] , remove : [ toSyncChannel ( businessId , 'REMOVE_' + basePrivilegeName ) ] } ; } ; }
1446	function isIso8601DateTimeString ( value ) { var dateAndTimePieces = splitDateAndTime ( value ) ; var date = extractDateStructureFromDateAndTime ( dateAndTimePieces ) ; if ( date ) { var timeAndTimezone = extractTimeStructuresFromDateAndTime ( dateAndTimePieces ) ; var time = timeAndTimezone . time ; var timezone = timeAndTimezone . timezone ; return isValidDateStructure ( date ) && isValidTimeStructure ( time ) && ( timezone === null || isValidTimeZoneStructure ( timezone ) ) ; } else { return false ; } }
1447	function normalizeIso8601Time ( time , timezoneOffsetMinutes ) { var msPerSecond = 1000 ; var msPerMinute = 60000 ; var msPerHour = 3600000 ; var effectiveTimezoneOffset = timezoneOffsetMinutes || 0 ; var rawTimeMs = ( time . hour * msPerHour ) + ( time . minute * msPerMinute ) + ( time . second * msPerSecond ) + time . millisecond ; return rawTimeMs - ( effectiveTimezoneOffset * msPerMinute ) ; }
1448	function compareTimes ( a , b ) { if ( typeof a !== 'string' || typeof b !== 'string' ) { return NaN ; } return normalizeIso8601Time ( parseIso8601Time ( a ) ) - normalizeIso8601Time ( parseIso8601Time ( b ) ) ; }
1449	function compareDates ( a , b ) { var aPieces = extractDatePieces ( a ) ; var bPieces = extractDatePieces ( b ) ; if ( aPieces === null || bPieces === null ) { return NaN ; } for ( var pieceIndex = 0 ; pieceIndex < aPieces . length ; pieceIndex ++ ) { if ( aPieces [ pieceIndex ] < bPieces [ pieceIndex ] ) { return - 1 ; } else if ( aPieces [ pieceIndex ] > bPieces [ pieceIndex ] ) { return 1 ; } } return 0 ; }
1450	function normalizeIso8601TimeZone ( value ) { return value ? value . multiplicationFactor * ( ( value . hour * 60 ) + value . minute ) : - ( new Date ( ) . getTimezoneOffset ( ) ) ; }
1451	async function start ( ) { log . i ( '--Nexus/Start' ) ; let startArray = [ ] ; for ( let pid in Start ) { startArray . push ( new Promise ( ( resolve , _reject ) => { let com = { } ; com . Cmd = Start [ pid ] ; com . Passport = { } ; com . Passport . To = pid ; com . Passport . Pid = genPid ( ) ; sendMessage ( com , resolve ) ; } ) ) ; } await Promise . all ( startArray ) ; log . v ( '--Nexus: All Starts Complete' ) ; }
1452	async function exit ( code = 0 ) { log . i ( '--Nexus/Stop' ) ; let stopTasks = [ ] ; log . i ( 'Nexus unloading node modules' ) ; log . v ( Object . keys ( require . cache ) . join ( '\n' ) ) ; \n for ( let pid in Stop ) { stopTasks . push ( new Promise ( ( resolve , _reject ) => { let com = { } ; com . Cmd = Stop [ pid ] ; com . Passport = { } ; com . Passport . To = pid ; com . Passport . Pid = genPid ( ) ; sendMessage ( com , resolve ) ; } ) ) ; } await Promise . all ( stopTasks ) ; log . v ( '--Nexus: All Stops Complete' ) ; }
1453	function sendMessage ( com , fun = _ => _ ) { if ( ! ( 'Passport' in com ) ) { log . w ( 'Message has no Passport, ignored' ) ; log . w ( ' ' + JSON . stringify ( com ) ) ; fun ( 'No Passport' ) ; return ; } if ( ! ( 'To' in com . Passport ) || ! com . Passport . To ) { log . w ( 'Message has no destination entity, ignored' ) ; log . w ( ' ' + JSON . stringify ( com ) ) ; fun ( 'No recipient in message' , com ) ; return ; } if ( ! ( 'Pid' in com . Passport ) ) { log . w ( 'Message has no message id, ignored' ) ; log . w ( ' ' + JSON . stringify ( com ) ) ; fun ( 'No message id' , com ) ; return ; } let pid = com . Passport . To ; let apx = com . Passport . Apex || pid ; if ( pid in EntCache ) { done ( null , EntCache [ pid ] ) ; return ; } else { getEntityContext ( pid , done ) ; } async function done ( err , entContextVolatile ) { let entApex = await new Promise ( res => entContextVolatile . lock ( ( val ) => { res ( val . Apex ) ; return val ; } ) ) ; if ( err ) { log . w ( err ) ; log . w ( JSON . stringify ( com , null , 2 ) ) ; fun ( err , com ) ; return ; } if ( ( EntCache [ pid ] . Apex == EntCache [ pid ] . Pid ) || ( entApex == apx ) ) { let entContext = await new Promise ( res => entContextVolatile . lock ( ( context ) => { res ( context ) ; return context ; } ) ) ; entContext . instance . dispatch ( com , reply ) ; } else { let err = 'Trying to send a message to a non-Apex' + 'entity outside of the sending module' ; log . w ( err ) ; log . w ( JSON . stringify ( com , null , 2 ) ) ; fun ( err , com ) ; } } function reply ( err , q ) { fun ( err , q ) ; } }
1454	function deleteEntity ( pid , fun = ( err , _pid ) => { if ( err ) log . e ( err ) ; } ) { cacheInterface . deleteEntity ( pid , ( err , removedPidArray ) => { for ( let i = 0 ; i < removedPidArray . length ; i ++ ) { let entPid = removedPidArray [ i ] ; if ( entPid in EntCache ) { delete EntCache [ entPid ] ; } } log . v ( ` ${ ( removedPidArray . length == 1 ) ? 'Entity' : 'Entities' } ${ removedPidArray . join ( ' ' ) } ` ) ; fun ( err , pid ) ; } ) ; }
1455	async function saveEntity ( par , fun = ( err , _pid ) => { if ( err ) log . e ( err ) ; } ) { let saveEntity = ( async ( par ) => { await new Promise ( ( res , rej ) => { cacheInterface . saveEntityPar ( par , ( err , pid ) => { if ( err ) { log . e ( err , 'saving ' , pid ) ; rej ( err ) ; } log . v ( ` ${ par . Pid } ` ) ; res ( ) ; } ) ; } ) ; } ) ; if ( par . Pid != par . Apex ) { cacheInterface . getEntityPar ( par . Apex , async ( err ) => { if ( err ) { let apexPar = await new Promise ( ( res , _rej ) => { EntCache [ par . Apex ] . lock ( ( entityContext ) => { res ( entityContext . Par ) ; return entityContext ; } ) ; } ) ; log . v ( 'Must first save the Apex -- Saving...' ) ; await saveEntity ( apexPar ) ; await saveEntity ( par ) ; fun ( null , par . Pid ) ; } else { await saveEntity ( par ) ; fun ( null , par . Pid ) ; } } ) ; } else { await saveEntity ( par ) ; fun ( null , par . Pid ) ; } }
1456	function getFile ( module , filename , fun = _ => _ ) { let mod = ModCache [ module ] ; if ( filename in mod . files ) { mod . file ( filename ) . async ( 'string' ) . then ( ( dat ) => { fun ( null , dat ) ; } ) ; return ; } let err = ` ${ filename } ${ module } ` ; log . e ( err ) ; fun ( err ) ; }
1457	async function getEntityContext ( pid , fun = _ => _ ) { EntCache [ pid ] = new Volatile ( { } ) ; await EntCache [ pid ] . lock ( ( _entityContext ) => { return new Promise ( ( res , _rej ) => { cacheInterface . getEntityPar ( pid , ( err , data ) => { let par = JSON . parse ( data . toString ( ) ) ; if ( err ) { log . e ( ` ${ data . moduleType } ${ pid } ` ) ; log . e ( err ) ; fun ( 'Unavailable' ) ; return ; } let impkey = par . Module + '/' + par . Entity ; if ( impkey in ImpCache ) { BuildEnt ( ) ; return ; } GetModule ( par . Module , async function ( err , mod ) { if ( err ) { log . e ( 'Module <' + par . Module + '> not available' ) ; fun ( 'Module not available' ) ; return ; } if ( ! ( par . Entity in mod . files ) ) { log . e ( '<' + par . Entity + '> not in module <' + par . Module + '>' ) ; fun ( 'Null entity' ) ; return ; } let entString = await new Promise ( async ( res , _rej ) => { mod . file ( par . Entity ) . async ( 'string' ) . then ( ( string ) => res ( string ) ) ; } ) ; log . v ( ` ${ par . Module } ${ par . Entity . split ( '.' ) [ 0 ] } ` ) ; ImpCache [ impkey ] = indirectEvalImp ( impkey , entString , log , createRequireFromModuleType ( par . Module ) ) ; BuildEnt ( ) ; } ) ; function BuildEnt ( ) { res ( new Entity ( Nxs , ImpCache [ impkey ] , par , log ) ) ; } } ) ; } ) ; } ) ; fun ( null , EntCache [ pid ] ) ; }
1458	function GetModule ( ModName , fun = _ => _ ) { ModName = ModName . replace ( / :\/ / g , '.' ) ; if ( ModName in ModCache ) return fun ( null , ModCache [ ModName ] ) ; else cacheInterface . getModule ( ModName , ( err , moduleZip ) => { if ( err ) return fun ( err ) ; ModCache [ ModName ] = moduleZip ; return fun ( null , ModCache [ ModName ] ) ; } ) ; }
1459	function processSources ( cfg ) { if ( typeof cfg [ 'Sources' ] === 'undefined' ) { log . e ( 'You must defined a Sources object.\n' ) ; \n rejectSetup ( 'You must defined a Sources object.' ) ; } return ; let val , sources , subval ; }
1460	function generateModuleCatalog ( ) { let keys = Object . keys ( Config . Modules ) ; for ( let i = 0 ; i < keys . length ; i ++ ) { let key = keys [ i ] ; if ( key == 'Deferred' ) { let arr = Config . Modules [ 'Deferred' ] ; for ( let idx = 0 ; idx < arr . length ; idx ++ ) { let mod = arr [ idx ] ; log . v ( ` ${ mod . Module || mod } ` ) ; if ( typeof mod == 'string' ) { log . w ( 'Adding Module names directly to Deferred is deprecated' ) ; log . w ( ` ${ mod } ` ) ; mod = { Module : mod } ; } if ( ! ( 'Module' in mod ) ) { log . e ( 'Malformed Deferred Module listing' , mod ) ; rejectSetup ( 'Malformed Deferred Module listing' ) ; return ; } logModule ( key , mod ) ; } } else { if ( typeof Config . Modules [ key ] . Module != 'string' ) { log . e ( 'Malformed Module Definition' ) ; log . e ( JSON . stringify ( Config . Modules [ key ] , null , 2 ) ) ; } logModule ( key , Config . Modules [ key ] ) ; } } function logModule ( key , mod ) { let folder = mod . Module . replace ( / [/:] / g , '.' ) ; if ( ! ( 'Source' in mod ) ) { log . e ( ` ${ key } ${ mod . Module } ` ) ; rejectSetup ( ` ${ key } ` ) ; return ; } let source = { Source : mod . Source , Version : mod . Version } ; if ( ! ( folder in Modules ) ) { Modules [ folder ] = source ; } else { if ( Modules [ folder ] . Source != source . Source || ( Modules [ folder ] . Version != source . Version ) ) { log . e ( ` ${ key } \n ` + ` ${ JSON . stringify ( Modules [ folder ] , null , 2 ) } ` + ` \n ${ JSON . stringify ( source , null , 2 ) } ` ) ; rejectSetup ( 'Broker Mismatch Exception' ) ; return ; } } } }
1461	function logModule ( key , mod ) { let folder = mod . Module . replace ( / [/:] / g , '.' ) ; if ( ! ( 'Source' in mod ) ) { log . e ( ` ${ key } ${ mod . Module } ` ) ; rejectSetup ( ` ${ key } ` ) ; return ; } let source = { Source : mod . Source , Version : mod . Version } ; if ( ! ( folder in Modules ) ) { Modules [ folder ] = source ; } else { if ( Modules [ folder ] . Source != source . Source || ( Modules [ folder ] . Version != source . Version ) ) { log . e ( ` ${ key } \n ` + ` ${ JSON . stringify ( Modules [ folder ] , null , 2 ) } ` + ` \n ${ JSON . stringify ( source , null , 2 ) } ` ) ; rejectSetup ( 'Broker Mismatch Exception' ) ; return ; } } }
1462	async function buildApexInstances ( processPidReferences ) { if ( processPidReferences ) { for ( let instname in Config . Modules ) { if ( instname == 'Deferred' ) continue ; Apex [ instname ] = genPid ( ) ; } log . v ( 'Apex List' , JSON . stringify ( Apex , null , 2 ) ) ; } for ( let instname in Config . Modules ) { if ( instname === 'Deferred' ) continue ; await processApexPar ( Apex [ instname ] , Config . Modules [ instname ] , processPidReferences ) ; } }
1463	async function buildDir ( path ) { let dirObj = { } ; if ( fs . existsSync ( path ) ) { let files = fs . readdirSync ( path ) ; let itemPromises = [ ] ; for ( let file of files ) { itemPromises . push ( new Promise ( async ( resolve ) => { let curPath = path + '/' + file ; if ( fs . lstatSync ( curPath ) . isDirectory ( ) ) { dirObj [ file ] = await buildDir ( curPath ) ; resolve ( ) ; } else { fs . readFile ( curPath , function ( err , data ) { dirObj [ file ] = data . toString ( ) ; resolve ( ) ; } ) ; } } ) ) ; } await Promise . all ( itemPromises ) ; return dirObj ; } }
1464	function genPid ( ) { if ( ! Uuid ) { Uuid = require ( 'uuid/v4' ) ; } let str = Uuid ( ) ; let pid = str . replace ( / - / g , '' ) . toUpperCase ( ) ; return pid ; }
1465	async function genesis ( system ) { log . i ( ' [Save Cache]' . padStart ( 80 , '=' ) ) ; log . i ( 'Genesis Compile Start:' ) ; let cacheState = null ; if ( fs . existsSync ( CacheDir ) ) cacheState = 'exists' ; cacheInterface = new CacheInterface ( { path : CacheDir , log } ) ; cleanCache ( ) ; log . i ( 'Saving modules and updating dependencies ...' ) ; await cacheModules ( system . ModCache ) ; if ( ! ( __options . state == 'updateOnly' ) ) { log . i ( 'Saving entities ...' ) ; await cacheApexes ( system . Apex , system . Config . Modules ) ; } Stop ( ) ; function cleanCache ( ) { if ( __options . state == 'development' && cacheState ) { __options . state = 'updateOnly' ; return ; } log . v ( 'Removing the old cache.' ) ; cacheInterface . clean ( ) ; } async function cacheModules ( ModCache ) { let timer = log . time ( 'cacheModules' ) ; let ModulePromiseArray = [ ] ; for ( let folder in ModCache ) { ModulePromiseArray . push ( new Promise ( async ( res ) => { await cacheInterface . addModule ( folder , ModCache [ folder ] ) ; log . v ( ` ${ folder } ` ) ; res ( ) ; } ) ) ; } await Promise . all ( ModulePromiseArray ) ; log . timeEnd ( timer ) ; } async function cacheApexes ( Apexes , ModuleDefinitions ) { let ModulePromiseArray = [ ] ; for ( let moduleId in Apexes ) { ModulePromiseArray . push ( await cacheInterface . createInstance ( ModuleDefinitions [ moduleId ] , Apexes [ moduleId ] ) ) ; } await Promise . all ( ModulePromiseArray ) ; } async function Stop ( ) { log . i ( ` ${ new Date ( ) . toString ( ) } ` ) ; log . i ( ' [Finished]' . padStart ( 80 , '=' ) ) ; for ( const xgrl in BrokerCache ) { const broker = BrokerCache [ xgrl ] ; broker . cleanup ( ) ; } log . timeEnd ( compileTimer ) ; resolveMain ( ) ; } }
1466	async function cacheModules ( ModCache ) { let timer = log . time ( 'cacheModules' ) ; let ModulePromiseArray = [ ] ; for ( let folder in ModCache ) { ModulePromiseArray . push ( new Promise ( async ( res ) => { await cacheInterface . addModule ( folder , ModCache [ folder ] ) ; log . v ( ` ${ folder } ` ) ; res ( ) ; } ) ) ; } await Promise . all ( ModulePromiseArray ) ; log . timeEnd ( timer ) ; }
1467	async function cacheApexes ( Apexes , ModuleDefinitions ) { let ModulePromiseArray = [ ] ; for ( let moduleId in Apexes ) { ModulePromiseArray . push ( await cacheInterface . createInstance ( ModuleDefinitions [ moduleId ] , Apexes [ moduleId ] ) ) ; } await Promise . all ( ModulePromiseArray ) ; }
1468	async function Stop ( ) { log . i ( ` ${ new Date ( ) . toString ( ) } ` ) ; log . i ( ' [Finished]' . padStart ( 80 , '=' ) ) ; for ( const xgrl in BrokerCache ) { const broker = BrokerCache [ xgrl ] ; broker . cleanup ( ) ; } log . timeEnd ( compileTimer ) ; resolveMain ( ) ; }
1469	function getProtocolModule ( protocol ) { return new Promise ( function ( resolve , reject ) { let cacheFilepath = path . join ( appdata , protocol ) ; if ( fs . existsSync ( cacheFilepath ) ) { return resolve ( JSON . parse ( fs . readFileSync ( cacheFilepath ) . toString ( ) ) ) ; } let options = { host : 'protocols.xgraphdev.com' , port : 443 , path : '/' + protocol , method : 'GET' , rejectUnauthorized : false , } ; let req = https . request ( options , function ( res ) { res . setEncoding ( 'utf8' ) ; let response = '' ; res . on ( 'data' , function ( chunk ) { response += chunk ; } ) ; res . on ( 'end' , _ => { try { resolve ( JSON . parse ( response ) ) ; try { fs . writeFileSync ( cacheFilepath , response ) ; } catch ( e ) { reject ( { code : 1 , text : ` ${ cacheFilepath } ` + '\n delete file and try again' } ) ; } } \n } ) ; } ) ; catch ( e ) { reject ( { code : 0 , text : 'try and retrieve locally' } ) ; } req . on ( 'error' , function ( e ) { log . e ( 'problem with request: ' + e . message ) ; reject ( { code : 1 , text : 'problem with request: ' + e . message } ) ; } ) ; } ) ; }
1470	function remDir ( path ) { return ( new Promise ( async ( resolve , _reject ) => { if ( fs . existsSync ( path ) ) { let files = fs . readdirSync ( path ) ; let promiseArray = [ ] ; for ( let fileIndex = 0 ; fileIndex < files . length ; fileIndex ++ ) { promiseArray . push ( new Promise ( async ( resolve2 , _reject2 ) => { let curPath = path + '/' + files [ fileIndex ] ; if ( fs . lstatSync ( curPath ) . isDirectory ( ) ) { await remDir ( curPath ) ; resolve2 ( ) ; } else { log . v ( 'Removing Entity ' , files [ fileIndex ] . split ( '.' ) [ 0 ] ) ; fs . unlinkSync ( curPath ) ; resolve2 ( ) ; } } ) ) ; } await Promise . all ( promiseArray ) ; log . v ( 'Removing Module Directory ' , path ) ; fs . rmdirSync ( path ) ; resolve ( ) ; } else { log . v ( 'trying to remove nonexistant path ' , path ) ; resolve ( ) ; } } ) ) ; }
1471	function getMousePosition ( e ) { var mouseObj = void 0 , originalEvent = e . originalEvent ? e . originalEvent : e ; mouseObj = 'changedTouches' in originalEvent && originalEvent . changedTouches ? originalEvent . changedTouches [ 0 ] : originalEvent ; return { clientX : mouseObj . pageX , clientY : mouseObj . pageY } ; }
1472	function proxyRequest ( req , res , rule ) { var router , target , path ; injectProxyHeaders ( req , rule ) ; path = req . url . replace ( rule . regexp , rule . target . path ) ; if ( useGateway ) { req . url = url . parse ( util . format ( '%s//%s:%s%s' , rule . target . protocol , rule . target . host , rule . target . port , path ) ) . href ; req . headers [ 'X-Forwarded-Url' ] = req . url ; target = config . gateway ; logger . info ( 'proxy: %s %s , req . method , req . url , config . gateway . host , config . gateway . port , rule . target . protocol , rule . target . host , rule . target . port , path ) ; } else { target = rule . target ; logger . info ( 'proxy: %s %s , req . method , req . url , rule . target . protocol , rule . target . host , rule . target . port , path ) ; req . url = path ; } var errorCallback = function errorCallback ( err , proxyRequest , proxyResponse ) { var status = 500 ; if ( proxyResponse !== undefined && proxyResponse !== null && proxyResponse . statusCode >= 400 ) { status = proxyResponse . statusCode ; } logger . error ( 'proxy: error - %s %s - %s' , proxyRequest . method , proxyRequest . url , err . message ) ; if ( res . status && typeof res . status === 'function' ) { res . status ( status ) . json ( { error : status , message : err . message } ) ; } } ; router = createRouter ( target ) ; router . web ( req , res , errorCallback ) ; }
1473	function injectProxyHeaders ( req , rule ) { req . headers [ 'host' ] = rule . target . host + ( rule . target . originalPort ? util . format ( ':%d' , rule . target . originalPort ) : '' ) ; req . headers [ 'via' ] = util . format ( 'http://%s:%s' , req . connection . address ( ) . address , req . connection . address ( ) . port ) ; config . headers . forEach ( function ( header ) { var value = header . value , name = header . name ; if ( typeof ( value ) === 'function' ) { value = value . call ( undefined , req ) ; } if ( typeof ( value ) !== 'string' ) { value = '' ; } if ( typeof ( name ) === 'string' ) { req . headers [ name . toLowerCase ( ) ] = value ; } } ) ; injectAuthHeader ( req ) ; }
1474	function parseFile ( filepath , config ) { var contents ; filepath = filepath || path . join ( process . cwd ( ) , '/json-proxy.json' ) ; if ( fs . existsSync ( filepath ) ) { try { var data = fs . readFileSync ( filepath ) ; contents = JSON . parse ( data . toString ( ) ) ; config = parseConfig ( contents , config ) ; if ( config . server . webroot && config . server . webroot . length > 0 ) { config . server . webroot = config . server . webroot . replace ( "$config_dir" , path . dirname ( filepath ) ) ; } } catch ( ex ) { throw new Error ( 'Cannot parse the config file "' + filepath + '": ' + ex ) ; } } return config ; }
1475	function parseConfig ( contents , config ) { contents . server = contents . server || { } ; contents . proxy = contents . proxy || { } ; if ( contents . proxy . gateway && typeof ( contents . proxy . gateway ) === "string" && contents . proxy . gateway . length > 0 ) { contents . proxy . gateway = parseGateway ( contents . proxy . gateway ) ; } contents . proxy . forward = parseConfigMap ( contents . proxy . forward , parseForwardRule ) ; contents . proxy . headers = parseConfigMap ( contents . proxy . headers , parseHeaderRule ) ; config . server . port = contents . server . port || config . server . port ; config . server . webroot = contents . server . webroot || config . server . webroot ; config . server . html5mode = contents . server . html5mode || config . server . html5mode ; config . proxy . gateway = contents . proxy . gateway || config . proxy . gateway ; config . proxy . forward = contents . proxy . forward || config . proxy . forward ; config . proxy . headers = contents . proxy . headers || config . proxy . headers ; return config ; }
1476	function parseConfigMap ( map , callback ) { var result = [ ] ; if ( ! ( map instanceof Object ) ) { return map ; } for ( var property in map ) { if ( map . hasOwnProperty ( property ) ) { result . push ( callback ( property , map [ property ] ) ) ; } } return result ; }
1477	function parseCommandLine ( argv , config ) { if ( argv ) { parseCommandLineArgument ( argv . port , function ( item ) { config . server . port = item ; } ) ; parseCommandLineArgument ( argv . html5mode , function ( item ) { config . server . html5mode = item ; } ) ; parseCommandLineArgument ( argv . _ , function ( item ) { config . server . webroot = path . normalize ( item ) ; } ) ; parseCommandLineArgument ( argv . gateway , function ( item ) { config . proxy . gateway = parseGateway ( item ) ; } ) ; parseCommandLineArgument ( argv . forward , function ( item ) { var rule = parseForwardRule ( item ) ; var match = false ; config . proxy . forward . forEach ( function ( item ) { if ( item . regexp . source === rule . regexp . source ) { item . target = rule . target ; match = true ; } } ) ; if ( ! match ) { config . proxy . forward . push ( rule ) ; } } ) ; parseCommandLineArgument ( argv . header , function ( item ) { var rule = parseHeaderRule ( item ) ; var match = false ; config . proxy . headers . forEach ( function ( item ) { if ( item . name === rule . name ) { item . value = rule . value ; match = true ; } } ) ; if ( ! match ) { config . proxy . headers . push ( rule ) ; } } ) ; } return config ; }
1478	function parseCommandLineArgument ( arg , fn ) { if ( typeof ( fn ) !== 'function' ) return ; if ( Array . isArray ( arg ) ) { arg . forEach ( function ( item ) { fn . call ( null , item ) ; } ) ; } else { if ( arg !== null && arg !== undefined ) { fn . call ( null , arg ) ; } } }
1479	function parseForwardRule ( ) { var token , rule ; if ( arguments [ 0 ] === undefined || arguments [ 0 ] === null ) { return ; } if ( typeof ( arguments [ 0 ] ) === "object" ) { return arguments [ 0 ] ; } try { token = tokenize . apply ( null , arguments ) ; rule = { regexp : new RegExp ( '^' + token . name , 'i' ) , target : parseTargetServer ( token . value ) } ; } catch ( e ) { throw new Error ( 'cannot parse the forwarding rule ' + arguments [ 0 ] + ' - ' + e ) ; } return rule ; }
1480	function withCode ( code , msg ) { const err = new Error ( msg ) ; err . code = code ; return err ; }
1481	function updateWorkingState ( repoState , branch , newWorkingState ) { let workingStates = repoState . getWorkingStates ( ) ; const key = branch . getFullName ( ) ; if ( newWorkingState === null ) { workingStates = workingStates . delete ( key ) ; } else { workingStates = workingStates . set ( key , newWorkingState ) ; } return repoState . set ( 'workingStates' , workingStates ) ; }
1482	function fetchBranches ( repoState , driver ) { const oldBranches = repoState . getBranches ( ) ; return driver . fetchBranches ( ) . then ( ( branches ) => { return repoState . set ( 'branches' , branches ) ; } ) . then ( function refreshWorkingStates ( repoState ) { return oldBranches . reduce ( ( repoState , oldBranch ) => { const fullName = oldBranch . getFullName ( ) ; const newBranch = repoState . getBranch ( fullName ) ; if ( newBranch === null || newBranch . getSha ( ) !== oldBranch . getSha ( ) ) { return updateWorkingState ( repoState , oldBranch , null ) ; } else { return repoState ; } } , repoState ) ; } ) ; }
1483	function initialize ( driver ) { const repoState = RepositoryState . createEmpty ( ) ; return fetchBranches ( repoState , driver ) . then ( ( repoState ) => { const branches = repoState . getBranches ( ) ; const master = branches . find ( function isMaster ( branch ) { return branch . getFullName ( ) === 'master' ; } ) ; const branch = master || branches . first ( ) ; return fetchTree ( repoState , driver , branch ) . then ( ( repoState ) => { return checkout ( repoState , branch ) ; } ) ; } ) ; }
1484	function enforceArrayBuffer ( b , encoding ) { if ( isArrayBuffer ( b ) ) return b ; else if ( isBuffer ( b ) ) return fromBuffer ( b ) ; else return fromString ( b , encoding ) ; }
1485	function enforceString ( b , encoding ) { if ( is . string ( b ) ) return b ; if ( isArrayBuffer ( b ) ) b = toBuffer ( b ) ; return b . toString ( encoding ) ; }
1486	function equals ( buf1 , buf2 ) { if ( buf1 . byteLength != buf2 . byteLength ) return false ; const dv1 = new Int8Array ( buf1 ) ; const dv2 = new Int8Array ( buf2 ) ; for ( let i = 0 ; i != buf1 . byteLength ; i ++ ) { if ( dv1 [ i ] != dv2 [ i ] ) return false ; } return true ; }
1487	function getMergedFileSet ( workingState ) { return Immutable . Set . fromKeys ( getMergedTreeEntries ( workingState ) . filter ( treeEntry => treeEntry . getType ( ) === TreeEntry . TYPES . BLOB ) ) ; }
1488	function getMergedTreeEntries ( workingState ) { const removedOrModified = workingState . getChanges ( ) . groupBy ( ( change , path ) => { if ( change . getType ( ) === CHANGES . REMOVE ) { return 'remove' ; } else { return 'modified' ; } } ) ; const setToRemove = Immutable . Set . fromKeys ( removedOrModified . get ( 'remove' , [ ] ) ) ; const withoutRemoved = workingState . getTreeEntries ( ) . filter ( ( treeEntry , path ) => { return ! setToRemove . contains ( path ) ; } ) ; const addedTreeEntries = removedOrModified . get ( 'modified' , [ ] ) . map ( function toTreeEntry ( change ) { return new TreeEntry ( { sha : change . hasSha ( ) ? change . getSha ( ) : null , mode : '100644' } ) ; } ) ; return withoutRemoved . concat ( addedTreeEntries ) ; }
1489	function findSha ( workingState , filepath ) { const change = workingState . getChanges ( ) . get ( filepath ) ; const treeEntry = workingState . getTreeEntries ( ) . get ( filepath ) ; if ( change ) { if ( change . getType ( ) == CHANGES . REMOVE ) { throw error . fileNotFound ( filepath ) ; } else { return change . getSha ( ) ; } } else if ( treeEntry ) { return treeEntry . getSha ( ) ; } else { throw error . fileNotFound ( filepath ) ; } }
1490	function prepare ( repoState , opts ) { const workingState = repoState . getCurrentState ( ) ; const changes = workingState . getChanges ( ) ; opts . empty = workingState . isClean ( ) ; opts . parents = new Immutable . List ( [ workingState . getHead ( ) ] ) ; opts . treeEntries = WorkingUtils . getMergedTreeEntries ( workingState ) ; opts . blobs = changes . filter ( ( change ) => { return ! change . hasSha ( ) ; } ) . map ( ( change ) => { return change . getContent ( ) ; } ) ; return CommitBuilder . create ( opts ) ; }
1491	function flush ( repoState , driver , commitBuilder , options = { } ) { options = Object . assign ( { branch : repoState . getCurrentBranch ( ) , ignoreEmpty : true } , options ) ; if ( options . ignoreEmpty && commitBuilder . isEmpty ( ) && commitBuilder . getParents ( ) . count ( ) < 2 ) { return Q ( repoState ) ; } return driver . flushCommit ( commitBuilder ) . then ( ( commit ) => { return driver . forwardBranch ( options . branch , commit . getSha ( ) ) . then ( function updateBranch ( ) { const updated = options . branch . merge ( { commit } ) ; return repoState . updateBranch ( options . branch , updated ) ; } , function nonFF ( err ) { if ( err . code === ERRORS . NOT_FAST_FORWARD ) { err . commit = commit ; } throw err ; } ) ; } ) . then ( function updateWorkingState ( forwardedRepoState ) { const forwardedBranch = forwardedRepoState . getBranch ( options . branch . getFullName ( ) ) ; return RepoUtils . fetchTree ( forwardedRepoState , driver , forwardedBranch ) ; } ) ; }
1492	function format ( color , messages ) { var length = messages . length ; if ( length === 0 || typeof ( color ) !== 'string' ) { return ; } return ( util . format . apply ( null , messages ) [ color ] ) ; }
1493	function push ( repoState , driver , opts = { } ) { opts = Object . assign ( { branch : repoState . getCurrentBranch ( ) , force : false , remote : { name : 'origin' } } , opts ) ; return driver . push ( opts ) . thenResolve ( repoState ) ; }
1494	function pull ( repoState , driver , opts = { } ) { opts = Object . assign ( { branch : repoState . getCurrentBranch ( ) , force : false , remote : { name : 'origin' } } , opts ) ; return driver . pull ( opts ) . then ( ( ) => { return driver . fetchBranches ( ) ; } ) . then ( ( branches ) => { const updatedBranch = branches . find ( ( br ) => { return br . name === opts . branch . name ; } ) ; repoState = repoState . updateBranch ( opts . branch , updatedBranch ) ; return RepoUtils . fetchTree ( repoState , driver , updatedBranch ) ; } ) ; }
1495	function compareRefs ( driver , base , head ) { const baseRef = base instanceof Branch ? base . getFullName ( ) : base ; const headRef = head instanceof Branch ? head . getFullName ( ) : head ; return driver . findParentCommit ( baseRef , headRef ) . then ( ( parentCommit ) => { return Q . all ( [ parentCommit ? parentCommit . getSha ( ) : null , baseRef , headRef ] . map ( ( ref ) => { return ref ? driver . fetchWorkingState ( ref ) : WorkingState . createEmpty ( ) ; } ) ) ; } ) . spread ( ( parent , base , head ) => { const conflicts = _compareTrees ( parent . getTreeEntries ( ) , base . getTreeEntries ( ) , head . getTreeEntries ( ) ) ; return new TreeConflict ( { base , head , parent , conflicts } ) ; } ) ; }
1496	function solveTree ( treeConflict , solved ) { solved = treeConflict . getConflicts ( ) . merge ( solved ) . map ( function defaultSolve ( conflict ) { if ( ! conflict . isSolved ( ) ) { return conflict . keepBase ( ) ; } else { return conflict ; } } ) ; return treeConflict . set ( 'conflicts' , solved ) ; }
1497	function mergeCommit ( treeConflict , parents , options ) { options = options || { } ; const opts = { } ; opts . empty = false ; opts . parents = new Immutable . List ( parents ) ; opts . author = options . author ; opts . message = options . message || 'Merged commit' ; const solvedEntries = _getSolvedEntries ( treeConflict ) ; opts . treeEntries = solvedEntries ; const solvedConflicts = treeConflict . getConflicts ( ) ; opts . blobs = solvedEntries . filter ( ( treeEntry ) => { return ! treeEntry . hasSha ( ) ; } ) . map ( ( treeEntry , path ) => { return solvedConflicts . get ( path ) . getSolvedContent ( ) ; } ) ; return CommitBuilder . create ( opts ) ; }
1498	function _getSolvedEntries ( treeConflict ) { const parentEntries = treeConflict . getParent ( ) . getTreeEntries ( ) ; const baseEntries = treeConflict . getBase ( ) . getTreeEntries ( ) ; const headEntries = treeConflict . getHead ( ) . getTreeEntries ( ) ; const baseDiff = _diffEntries ( parentEntries , baseEntries ) ; const headDiff = _diffEntries ( parentEntries , headEntries ) ; const resolvedEntries = treeConflict . getConflicts ( ) . map ( ( solvedConflict ) => { if ( solvedConflict . isDeleted ( ) ) { return null ; } else { return new TreeEntry ( { sha : solvedConflict . getSolvedSha ( ) || null } ) ; } } ) ; return parentEntries . merge ( baseDiff , headDiff , resolvedEntries ) . filter ( function nonNull ( entry ) { return entry !== null ; } ) ; }
1499	function addBlob ( cache , sha , blob ) { const blobs = cache . getBlobs ( ) ; const newBlobs = blobs . set ( sha , blob ) ; const newCache = cache . set ( 'blobs' , newBlobs ) ; return newCache ; }
1500	function get ( repoState , dirPath ) { const normDirPath = Path . join ( dirPath , '.' ) ; const filepaths = DirUtils . readFilenamesRecursive ( repoState , normDirPath ) ; const tree = { value : File . createDir ( normDirPath ) , children : { } } ; for ( let i = 0 ; i < filepaths . length ; i ++ ) { const relativePath = Path . relative ( normDirPath , filepaths [ i ] ) ; const parts = relativePath . split ( '/' ) ; let node = tree ; let prefix = normDirPath ; for ( let j = 0 ; j < parts . length ; j ++ ) { const head = parts [ j ] ; const isLeaf = ( j === parts . length - 1 ) ; prefix = Path . join ( prefix , head ) ; if ( ! node . children [ head ] ) { if ( isLeaf ) { node . children [ head ] = { value : FileUtils . stat ( repoState , filepaths [ i ] ) } ; } else { node . children [ head ] = { value : File . createDir ( prefix ) , children : { } } ; } } node = node . children [ head ] ; } } return TreeNode . fromJS ( tree ) ; }
1501	function normCreatedCommit ( ghCommit ) { const commit = Commit . create ( { sha : ghCommit . sha , message : ghCommit . message , author : getSimpleAuthor ( ghCommit . author ) , date : ghCommit . author . date , parents : ghCommit . parents . map ( function getSha ( o ) { return o . sha ; } ) } ) ; return commit ; }
1502	function normListedCommit ( ghCommit ) { const commit = Commit . create ( { sha : ghCommit . sha , message : ghCommit . commit . message , author : getCompleteAuthor ( ghCommit ) , date : ghCommit . commit . author . date , files : ghCommit . files , parents : ghCommit . parents . map ( c => c . sha ) } ) ; return commit ; }
1503	function stat ( repoState , filepath ) { const workingState = repoState . getCurrentState ( ) ; const change = workingState . getChanges ( ) . get ( filepath ) ; const treeEntry = workingState . getTreeEntries ( ) . get ( filepath ) ; let blobSHA ; if ( change ) { blobSHA = change . getSha ( ) ; } else { blobSHA = treeEntry . getSha ( ) ; } let blob ; if ( blobSHA ) { blob = repoState . getCache ( ) . getBlob ( blobSHA ) ; } else { blob = change . getContent ( ) ; } let fileSize ; if ( blob ) { fileSize = blob . getByteLength ( ) ; } else { const originalEntry = workingState . getTreeEntries ( ) . find ( ( entry ) => { return entry . getSha ( ) === blobSHA ; } ) ; fileSize = originalEntry . getBlobSize ( ) ; } return new File ( { type : FILETYPE . FILE , fileSize , path : filepath , content : blob } ) ; }
1504	function readAsString ( repoState , filepath , encoding ) { const blob = read ( repoState , filepath ) ; return blob . getAsString ( encoding ) ; }
1505	function exists ( repoState , filepath ) { const workingState = repoState . getCurrentState ( ) ; const mergedFileSet = WorkingUtils . getMergedTreeEntries ( workingState ) ; return mergedFileSet . has ( filepath ) ; }
1506	function remove ( repoState , filepath ) { if ( ! exists ( repoState , filepath ) ) { throw error . fileNotFound ( filepath ) ; } const change = Change . createRemove ( ) ; return ChangeUtils . setChange ( repoState , filepath , change ) ; }
1507	function move ( repoState , filepath , newFilepath ) { if ( filepath === newFilepath ) { return repoState ; } const initialWorkingState = repoState . getCurrentState ( ) ; const sha = WorkingUtils . findSha ( initialWorkingState , filepath ) ; let changeNewFile ; if ( sha ) { changeNewFile = Change . createCreateFromSha ( sha ) ; } else { const blob = read ( repoState , filepath ) ; const contentBuffer = blob . getAsBuffer ( ) ; changeNewFile = Change . createCreate ( contentBuffer ) ; } const removedRepoState = remove ( repoState , filepath ) ; return ChangeUtils . setChange ( removedRepoState , newFilepath , changeNewFile ) ; }
1508	function hasChanged ( previousState , newState , filepath ) { const previouslyExists = exists ( previousState , filepath ) ; const newExists = exists ( newState , filepath ) ; if ( ! previouslyExists && ! newExists ) { return false ; } else if ( exists ( previousState , filepath ) !== exists ( newState , filepath ) ) { return true ; } else { const prevWorking = previousState . getCurrentState ( ) ; const newWorking = newState . getCurrentState ( ) ; const prevSha = WorkingUtils . findSha ( prevWorking , filepath ) ; const newSha = WorkingUtils . findSha ( newWorking , filepath ) ; if ( prevSha === null && newSha === null ) { return read ( previousState , filepath ) . getAsString ( ) !== read ( newState , filepath ) . getAsString ( ) ; } else { return prevSha !== newSha ; } } }
1509	function setup ( connection , done ) { var config = createDefaultConfig ( ) , options = { proxy : false , headers : { } } ; handles = { } ; if ( connection !== 'direct' ) { options . proxy = true ; config . proxy . gateway = { protocol : 'http:' , host : 'localhost' , port : 0 , auth : 'proxyuser:C0mp13x_!d0rd$$@P!' } ; if ( connection === 'non-rfc-proxy' ) { config . proxy . headers [ 'Via' ] = 'http://jedi.example.com' ; config . proxy . headers [ 'Host' ] = 'force.example.com' ; } options . headers = require ( 'util' ) . _extend ( config . proxy . headers ) ; configureLanProxy ( options , config , function ( ) { configureNock ( options , config ) ; configureExpress ( config , done ) ; } ) } else { configureNock ( options , config ) ; configureExpress ( config , done ) ; } }
1510	function configureNock ( options , config ) { var result = { } ; nock . disableNetConnect ( ) ; nock . enableNetConnect ( 'localhost' ) ; function createNock ( url ) { var instance = nock ( url ) , expectedViaHeader = options . headers [ 'Via' ] || 'http://localhost:' + config . proxy . gateway . port , expectedHostHeader = options . headers [ 'Host' ] || / .* / ; if ( options . proxy === true ) { instance . matchHeader ( 'via' , expectedViaHeader ) ; instance . matchHeader ( 'host' , expectedHostHeader ) ; } instance . matchHeader ( 'x-test-header' , 'John Doe' ) ; return instance ; } rules = [ createNock ( 'http://api.example.com' ) . get ( '/api/hello' ) . reply ( 200 , '{ "hello": "world" }' ) . get ( '/account?id=1&email=2&sort=asc' ) . reply ( 200 , '{ "email": "john.doe@example.com" }' ) . get ( '/api/notfound' ) . reply ( 404 ) , createNock ( 'http://rewrite.example.com' ) . get ( '/hello' ) . reply ( 200 , '{ "hello": "world" }' ) . get ( '/foo/bar' ) . reply ( 200 , '{ "foo": "bar" }' ) , createNock ( 'http://www.example.com' ) . get ( '/foo/12345/bar' ) . reply ( 200 , '{ "foo": "bar" }' ) . get ( '/subapp/junction/customer/1' ) . reply ( 200 , '{ "id": 1 }' ) , createNock ( 'https://api.example.biz' ) . get ( '/issue/8' ) . reply ( 200 , '{ "reporter": "@heygrady" }' ) , createNock ( 'https://secure.example.com' ) . get ( '/secure/api/hello' ) . reply ( 200 , '{ "hello": "world" }' ) . get ( '/secure/api/notfound' ) . reply ( 404 ) , createNock ( 'https://authorization.example.com' ) . matchHeader ( 'X-Test-Header-Function' , 'Bearer 0123456789abcdef' ) . get ( '/token' ) . reply ( 200 , '{ "author": "ehtb" }' ) ] ; }
1511	function configureExpress ( config , done ) { var portfinder = require ( 'portfinder' ) ; tmp . dir ( function ( err , filepath ) { handles . filepath = filepath ; portfinder . getPort ( function ( err , port ) { if ( err ) throw ( err ) ; handles . port = port ; fs . writeFileSync ( path . join ( handles . filepath , 'index.txt' ) , 'hello, world' ) ; app . use ( proxy . initialize ( config ) ) ; app . use ( express . static ( handles . filepath ) ) ; handles . server = require ( 'http' ) . createServer ( app ) ; handles . server . listen ( handles . port , function ( ) { done ( null , handles . port ) ; } ) ; } ) ; } ) ; }
1512	function configureLanProxy ( options , config , done ) { var portfinder = require ( 'portfinder' ) , request = require ( 'request' ) , credentials = config . proxy . gateway . auth , gatewayPort , expectedAuthorizationHeader , requestViaHeader , responseViaHeader ; handles = handles || { } ; handles . gatewayServer = require ( 'http' ) . createServer ( function ( req , res ) { expectedAuthorizationHeader = 'Basic ' + new Buffer ( credentials ) . toString ( 'base64' ) ; if ( req . url . charAt ( 0 ) === '/' ) { req . url = req . url . substr ( 1 ) ; } if ( req . url !== req . headers [ 'x-forwarded-url' ] ) { res . writeHead ( 500 ) ; res . end ( '{ "error": 500, "message": "invalid proxy request, expected X-Forwarded-Url header ' + req . headers [ 'x-forwarded-url' ] + '" }' ) ; return ; } if ( req . headers [ 'authorization' ] !== expectedAuthorizationHeader ) { res . writeHead ( 401 ) ; res . end ( '{ "error": 401, "message": "invalid proxy credentials, expected ' + expectedAuthorizationHeader + '" }' ) ; return ; } requestViaHeader = options . headers [ 'Via' ] || '127.0.0.1:' + handles . port ; responseHostHeader = options . headers [ 'Host' ] || req . headers [ 'host' ] ; responseViaHeader = options . headers [ 'Via' ] || 'http://localhost:' + gatewayPort ; if ( req . headers [ 'via' ] === undefined || req . headers [ 'via' ] === null || req . headers [ 'via' ] . indexOf ( requestViaHeader ) === - 1 ) { res . writeHead ( 400 ) ; res . end ( '{ "error": 400, "message": "invalid via header, expected ' + requestViaHeader + '" }' ) ; return ; } req . headers [ 'authorization' ] = null ; req . headers [ 'x-forwarded-for' ] = [ req . headers [ 'x-forwarded-for' ] , req . headers [ 'via' ] ] . join ( ', ' ) ; req . headers [ 'via' ] = responseViaHeader ; req . headers [ 'host' ] = responseHostHeader ; var errorCallback = function errorCallback ( err , repsonse , body ) { if ( err ) { res . writeHead ( 500 ) ; res . end ( JSON . stringify ( { "error" : 500 , "message" : err . message } ) ) ; return ; } } request ( req , errorCallback ) . pipe ( res ) ; } ) ; portfinder . getPort ( function ( err , port ) { if ( err ) done ( err ) ; config . proxy . gateway . port = port ; gatewayPort = port ; handles . gatewayServer . listen ( port , function ( ) { done ( null ) ; } ) ; } ) ; }
1513	function cleanup ( done ) { config = null ; rules . forEach ( function ( rule ) { rule . done ( ) ; } ) ; nock . cleanAll ( ) ; handles . server . close ( ) ; if ( handles . gatewayServer !== undefined && handles . gatewayServer !== null ) { handles . gatewayServer . close ( ) ; } fs . unlinkSync ( path . join ( handles . filepath , '/index.txt' ) ) ; handles = null ; done ( ) ; }
1514	function setChange ( repoState , filepath , change ) { let workingState = repoState . getCurrentState ( ) ; let changes = workingState . getChanges ( ) ; const type = change . getType ( ) ; if ( type === CHANGE_TYPE . REMOVE && ! workingState . getTreeEntries ( ) . has ( filepath ) ) { changes = changes . delete ( filepath ) ; } else if ( type === CHANGE_TYPE . CREATE && workingState . getTreeEntries ( ) . has ( filepath ) ) { changes = changes . set ( filepath , change . set ( 'type' , CHANGE_TYPE . UPDATE ) ) ; } else { changes = changes . set ( filepath , change ) ; } workingState = workingState . set ( 'changes' , changes ) ; return RepoUtils . updateCurrentWorkingState ( repoState , workingState ) ; }
1515	function revertAll ( repoState ) { let workingState = repoState . getCurrentState ( ) ; const changes = new Immutable . OrderedMap ( ) ; workingState = workingState . set ( 'changes' , changes ) ; return RepoUtils . updateCurrentWorkingState ( repoState , workingState ) ; }
1516	function revertForFile ( repoState , filePath ) { let workingState = repoState . getCurrentState ( ) ; const changes = workingState . getChanges ( ) . delete ( filePath ) ; workingState = workingState . set ( 'changes' , changes ) ; return RepoUtils . updateCurrentWorkingState ( repoState , workingState ) ; }
1517	function revertForDir ( repoState , dirPath ) { let workingState = repoState . getCurrentState ( ) ; let changes = workingState . getChanges ( ) ; changes = changes . filter ( ( change , filePath ) => { return ! PathUtils . contains ( dirPath , filePath ) ; } ) ; workingState = workingState . set ( 'changes' , changes ) ; return RepoUtils . updateCurrentWorkingState ( repoState , workingState ) ; }
1518	function revertAllRemoved ( repoState ) { let workingState = repoState . getCurrentState ( ) ; const changes = workingState . getChanges ( ) . filter ( ( change ) => { return change . getType ( ) === CHANGE_TYPE . REMOVE ; } ) ; workingState = workingState . set ( 'changes' , changes ) ; return RepoUtils . updateCurrentWorkingState ( repoState , workingState ) ; }
1519	function normPath ( p ) { p = path . normalize ( p ) ; if ( p [ 0 ] == '/' ) p = p . slice ( 1 ) ; if ( p [ p . length - 1 ] == '/' ) p = p . slice ( 0 , - 1 ) ; if ( p == '.' ) p = '' ; return p ; }
1520	function pathContains ( dir , path ) { dir = dir ? normPath ( dir ) + '/' : dir ; path = normPath ( path ) ; return path . indexOf ( dir ) === 0 ; }
1521	function readFilenamesRecursive ( repoState , dirName ) { dirName = PathUtils . norm ( dirName ) ; const workingState = repoState . getCurrentState ( ) ; const fileSet = WorkingUtils . getMergedFileSet ( workingState ) ; return fileSet . filter ( ( path ) => { return PathUtils . contains ( dirName , path ) ; } ) . toArray ( ) ; }
1522	function move ( repoState , dirName , newDirName ) { const filesToMove = readFilenamesRecursive ( repoState , dirName ) ; return filesToMove . reduce ( ( repoState , oldPath ) => { const newPath = Path . join ( newDirName , Path . relative ( dirName , oldPath ) ) ; return FileUtils . move ( repoState , oldPath , newPath ) ; } , repoState ) ; }
1523	function create ( repositoryState , driver , name , opts = { } ) { const { base = repositoryState . getCurrentBranch ( ) , checkout = true , clean = true , cleanBase = false } = opts ; let createdBranch ; return driver . createBranch ( base , name ) . then ( ( branch ) => { createdBranch = branch ; let branches = repositoryState . getBranches ( ) ; branches = branches . push ( createdBranch ) ; return repositoryState . set ( 'branches' , branches ) ; } ) . then ( ( repoState ) => { let baseWk = repoState . getWorkingStateForBranch ( base ) ; if ( ! baseWk ) { return checkout ? RepoUtils . fetchTree ( repoState , driver , createdBranch ) : repoState ; } const headWk = clean ? baseWk . asClean ( ) : baseWk ; repoState = RepoUtils . updateWorkingState ( repoState , createdBranch , headWk ) ; baseWk = cleanBase ? baseWk . asClean ( ) : baseWk ; repoState = RepoUtils . updateWorkingState ( repoState , base , baseWk ) ; return repoState ; } ) . then ( ( repoState ) => { if ( ! checkout ) { return repoState ; } return RepoUtils . checkout ( repoState , createdBranch ) ; } ) ; }
1524	function update ( repoState , driver , branchName ) { branchName = Normalize . branchName ( branchName || repoState . getCurrentBranch ( ) ) ; return driver . fetchBranches ( ) . then ( ( branches ) => { const newBranch = branches . find ( ( branch ) => { return branch . getFullName ( ) === branchName ; } ) ; if ( ! newBranch ) { return repoState ; } else { return RepoUtils . fetchTree ( repoState , driver , newBranch ) ; } } ) ; }
1525	function remove ( repoState , driver , branch ) { return driver . deleteBranch ( branch ) . then ( ( ) => { return repoState . updateBranch ( branch , null ) ; } ) ; }
1526	function fetch ( repoState , driver , sha ) { if ( isFetched ( repoState , sha ) ) { return Q ( repoState ) ; } const cache = repoState . getCache ( ) ; return driver . fetchBlob ( sha ) . then ( ( blob ) => { const newCache = CacheUtils . addBlob ( cache , sha , blob ) ; return repoState . set ( 'cache' , newCache ) ; } ) ; }
1527	function ( context , options , callback ) { context . retryQueue . push ( [ options , callback ] ) ; if ( context . refreshActive ) { return false ; } context . refreshActive = true ; return request ( { uri : baseUrl + '/oauth2/token' , method : 'POST' , headers : { 'Authorization' : 'Basic ' + new Buffer ( context . clientId + ':' + context . clientSecret ) . toString ( 'base64' ) , 'User-Agent' : userAgent } , form : { grant_type : 'client_credentials' } } , function ( err , res , body ) { context . refreshActive = false ; if ( res . statusCode != 200 ) { context . retryQueue = [ ] ; return callback && callback ( res . body , res ) ; } var token = JSON . parse ( body ) ; context . accessToken = token . access_token ; while ( 0 < context . retryQueue . length ) { var reqArgs = context . retryQueue . pop ( ) ; context . apiRequest ( reqArgs [ 0 ] , reqArgs [ 1 ] ) ; } } ) ; }
1528	function PokitDok ( clientId , clientSecret , version ) { this . clientId = clientId ; this . clientSecret = clientSecret ; this . version = version || 'v4' ; this . refreshActive = false ; this . retryQueue = [ ] ; this . accessToken = null ; }
1529	function featureArrayToFeatureString ( features , bias , firstFeatureNumber ) { if ( ! Array . isArray ( features ) ) throw new Error ( "Expected an array, but got " + JSON . stringify ( features ) ) var line = ( bias ? " " + firstFeatureNumber + ":" + bias : "" ) ; for ( var feature = 0 ; feature < features . length ; ++ feature ) { var value = features [ feature ] ; if ( value ) line += ( " " + ( feature + firstFeatureNumber + ( bias ? 1 : 0 ) ) + ":" + value . toPrecision ( 5 ) ) ; } return line ; }
1530	function ( feature ) { if ( ! ( feature in this . featureNameToFeatureIndex ) ) { var newIndex = this . featureIndexToFeatureName . length ; this . featureIndexToFeatureName . push ( feature ) ; this . featureNameToFeatureIndex [ feature ] = newIndex ; } }
1531	function ( hash ) { if ( hash instanceof Array ) { for ( var index in hash ) this . addFeature ( hash [ index ] ) ; } else if ( hash instanceof Object ) { for ( var feature in hash ) this . addFeature ( feature ) ; } else throw new Error ( "FeatureLookupTable.addFeatures expects a hash or an array, but got: " + JSON . stringify ( hash ) ) ; }
1532	function ( hash ) { this . addFeatures ( hash ) ; var array = [ ] ; for ( var featureIndex = 0 ; featureIndex < this . featureIndexToFeatureName . length ; ++ featureIndex ) array [ featureIndex ] = 0 ; if ( hash instanceof Array ) { for ( var i in hash ) array [ this . featureNameToFeatureIndex [ hash [ i ] ] ] = true ; } else if ( hash instanceof Object ) { for ( var feature in hash ) array [ this . featureNameToFeatureIndex [ feature ] ] = hash [ feature ] ; } else throw new Error ( "Unsupported type: " + JSON . stringify ( hash ) ) ; return array ; }
1533	function ( hashes ) { this . addFeaturess ( hashes ) ; var arrays = [ ] ; for ( var i = 0 ; i < hashes . length ; ++ i ) { arrays [ i ] = [ ] ; for ( var feature in this . featureNameToFeatureIndex ) arrays [ i ] [ this . featureNameToFeatureIndex [ feature ] ] = hashes [ i ] [ feature ] || 0 ; } return arrays ; }
1534	function ( array ) { var hash = { } ; for ( var feature in this . featureNameToFeatureIndex ) { if ( array [ this . featureNameToFeatureIndex [ feature ] ] ) hash [ feature ] = array [ this . featureNameToFeatureIndex [ feature ] ] ; } return hash ; }
1535	function ( arrays ) { var hashes = [ ] ; for ( var i = 0 ; i < arrays . length ; ++ i ) hashes [ i ] = this . arrayToHash ( arrays [ i ] ) ; return hashes ; }
1536	function ( sample , splitLabels , treeNode ) { var superlabels = { } ; var mapSuperlabelToRest = { } ; for ( var i in splitLabels ) { var splitLabel = splitLabels [ i ] ; var superlabel = splitLabel [ 0 ] ; superlabels [ superlabel ] = true ; if ( splitLabel . length > 1 ) { if ( ! mapSuperlabelToRest [ superlabel ] ) mapSuperlabelToRest [ superlabel ] = [ ] ; mapSuperlabelToRest [ superlabel ] . push ( splitLabel . slice ( 1 ) ) ; } } treeNode . superlabelClassifier . trainOnline ( sample , Object . keys ( superlabels ) ) ; for ( var superlabel in mapSuperlabelToRest ) { if ( ! ( superlabel in treeNode . mapSuperlabelToBranch ) ) { treeNode . mapSuperlabelToBranch [ superlabel ] = { superlabelClassifier : this . newMultilabelClassifier ( ) , mapSuperlabelToBranch : { } } } this . trainOnlineRecursive ( sample , mapSuperlabelToRest [ superlabel ] , treeNode . mapSuperlabelToBranch [ superlabel ] ) ; } }
1537	function ( dataset , treeNode ) { var superlabelsDataset = [ ] ; var mapSuperlabelToRestDataset = { } ; dataset . forEach ( function ( datum ) { var splitLabels = datum . output ; var superlabels = { } ; var mapSuperlabelToRest = { } ; for ( var i in splitLabels ) { var splitLabel = splitLabels [ i ] ; var superlabel = splitLabel [ 0 ] ; superlabels [ superlabel ] = true ; if ( splitLabel . length > 1 ) { if ( ! mapSuperlabelToRest [ superlabel ] ) mapSuperlabelToRest [ superlabel ] = [ ] ; mapSuperlabelToRest [ superlabel ] . push ( splitLabel . slice ( 1 ) ) ; } } superlabelsDataset . push ( { input : datum . input , output : Object . keys ( superlabels ) } ) ; for ( var superlabel in mapSuperlabelToRest ) { if ( ! ( superlabel in mapSuperlabelToRestDataset ) ) mapSuperlabelToRestDataset [ superlabel ] = [ ] ; mapSuperlabelToRestDataset [ superlabel ] . push ( { input : datum . input , output : mapSuperlabelToRest [ superlabel ] } ) ; } } , this ) ; treeNode . superlabelClassifier . trainBatch ( superlabelsDataset ) ; for ( var superlabel in mapSuperlabelToRestDataset ) { if ( ! ( superlabel in treeNode . mapSuperlabelToBranch ) ) { treeNode . mapSuperlabelToBranch [ superlabel ] = { superlabelClassifier : this . newMultilabelClassifier ( ) , mapSuperlabelToBranch : { } } } this . trainBatchRecursive ( mapSuperlabelToRestDataset [ superlabel ] , treeNode . mapSuperlabelToBranch [ superlabel ] ) ; } }
1538	function ( sample , explain , treeNode , depth ) { if ( ! depth ) depth = 1 ; var superlabelsWithExplain = treeNode . superlabelClassifier . classify ( sample , explain ) ; var superlabels = ( explain > 0 ? superlabelsWithExplain . classes : superlabelsWithExplain ) ; var splitLabels = [ ] ; if ( explain > 0 ) { var explanations = [ "depth=" + depth + ": " + superlabels , superlabelsWithExplain . explanation ] ; } for ( var i in superlabels ) { var superlabel = superlabels [ i ] ; var splitLabel = [ superlabel ] ; var branch = treeNode . mapSuperlabelToBranch [ superlabel ] ; if ( branch ) { var branchLabelsWithExplain = this . classifyRecursive ( sample , explain , branch , depth + 1 ) ; var branchLabels = ( explain > 0 ? branchLabelsWithExplain . classes : branchLabelsWithExplain ) ; for ( var j in branchLabels ) splitLabels . push ( splitLabel . concat ( branchLabels [ j ] ) ) ; if ( explain > 0 ) explanations = explanations . concat ( branchLabelsWithExplain . explanation ) ; } else { splitLabels . push ( splitLabel ) ; } } return ( explain > 0 ? { classes : splitLabels , explanation : explanations } : splitLabels ) ; }
1539	function ( opts ) { if ( ! ( 'binaryClassifierType' in opts ) ) { console . dir ( opts ) ; throw new Error ( "opts must contain binaryClassifierType" ) ; } if ( ! opts . binaryClassifierType ) { console . dir ( opts ) ; throw new Error ( "opts.binaryClassifierType is null" ) ; } this . binaryClassifierType = opts . binaryClassifierType ; this . classifier = new this . binaryClassifierType ( ) ; switch ( opts . segmentSplitStrategy ) { case 'shortestSegment' : this . segmentSplitStrategy = this . shortestSegmentSplitStrategy ; break ; case 'longestSegment' : this . segmentSplitStrategy = this . longestSegmentSplitStrategy ; break ; case 'cheapestSegment' : this . segmentSplitStrategy = this . cheapestSegmentSplitStrategy ; break ; default : this . segmentSplitStrategy = null ; } this . mapClassnameToClassifier = { } ; }
1540	function ( opts ) { this . retrain_count = opts . retrain_count || 10 ; this . Constant = opts . Constant || 5.0 ; this . weights = { } ; this . weights_sum = { } ; this . seenFeatures = { } ; this . num_iterations = 0 }
1541	function ( classes ) { classes = hash . normalized ( classes ) ; for ( var aClass in classes ) { if ( ! ( aClass in this . weights ) ) { this . weights [ aClass ] = { } ; this . weights_sum [ aClass ] = { } ; } } }
1542	function ( opts ) { opts = opts || { } ; if ( ! opts . multilabelClassifierType ) { console . dir ( opts ) ; throw new Error ( "opts.multilabelClassifierType is null" ) ; } if ( ! opts . numberofclassifiers ) { console . dir ( opts ) ; throw new Error ( "opts.numberofclassifiers is null" ) ; } this . classifier = this . intializeClassifiers ( opts . numberofclassifiers , opts . multilabelClassifierType ) }
1543	function ( expected , actual ) { this . count ++ ; if ( expected && actual ) this . TP ++ ; if ( ! expected && actual ) this . FP ++ ; if ( expected && ! actual ) this . FN ++ ; if ( ! expected && ! actual ) this . TN ++ ; if ( expected == actual ) this . TRUE ++ ; }
1544	function ( expectedClasses , actualClasses ) { var explanations = [ ] ; actualClasses = hash . normalized ( actualClasses ) ; expectedClasses = hash . normalized ( expectedClasses ) ; var allTrue = true ; if ( ! ( Object . keys ( expectedClasses ) [ 0 ] in this . confusion ) ) this . confusion [ Object . keys ( expectedClasses ) [ 0 ] ] = { } if ( ! ( Object . keys ( actualClasses ) [ 0 ] in this . confusion [ Object . keys ( expectedClasses ) [ 0 ] ] ) ) this . confusion [ Object . keys ( expectedClasses ) [ 0 ] ] [ Object . keys ( actualClasses ) [ 0 ] ] = 0 this . confusion [ Object . keys ( expectedClasses ) [ 0 ] ] [ Object . keys ( actualClasses ) [ 0 ] ] += 1 for ( var actualClass in actualClasses ) { if ( ! ( actualClass in this . confusion ) ) this . confusion [ actualClass ] = { } if ( ! ( actualClass in this . labels ) ) { this . labels [ actualClass ] = { } this . labels [ actualClass ] [ 'TP' ] = 0 this . labels [ actualClass ] [ 'FP' ] = 0 this . labels [ actualClass ] [ 'FN' ] = 0 } if ( actualClass in expectedClasses ) { this . labels [ actualClass ] [ 'TP' ] += 1 } else { this . labels [ actualClass ] [ 'FP' ] += 1 } } for ( var expectedClass in expectedClasses ) { if ( ! ( expectedClass in this . labels ) ) { this . labels [ expectedClass ] = { } this . labels [ expectedClass ] [ 'TP' ] = 0 this . labels [ expectedClass ] [ 'FP' ] = 0 this . labels [ expectedClass ] [ 'FN' ] = 0 } if ( ! ( expectedClass in actualClasses ) ) { this . labels [ expectedClass ] [ 'FN' ] += 1 } } }
1545	function ( expectedClasses , actualClasses , logTruePositives ) { var explanations = [ ] ; actualClasses = hash . normalized ( actualClasses ) ; expectedClasses = hash . normalized ( expectedClasses ) ; var allTrue = true ; for ( var actualClass in actualClasses ) { if ( actualClass in expectedClasses ) { if ( logTruePositives ) explanations . push ( "\t\t+++ TRUE POSITIVE: " + \t ) ; \t } else actualClass } this . TP ++ ; { explanations . push ( "\t\t--- FALSE POSITIVE: " + \t ) ; \t actualClass } this . FP ++ ; allTrue = false ; }
1546	function ( expectedClasses , actualClasses , logTruePositives ) { var explanations = { } ; explanations [ 'TP' ] = [ ] ; explanations [ 'FP' ] = [ ] ; explanations [ 'FN' ] = [ ] ; actualClasses = hash . normalized ( actualClasses ) ; expectedClasses = hash . normalized ( expectedClasses ) ; var allTrue = true ; for ( var actualClass in actualClasses ) { if ( actualClass in expectedClasses ) { if ( logTruePositives ) explanations [ 'TP' ] . push ( actualClass ) ; this . TP ++ ; } else { explanations [ 'FP' ] . push ( actualClass ) ; this . FP ++ ; allTrue = false ; } } for ( var expectedClass in expectedClasses ) { if ( ! ( expectedClass in actualClasses ) ) { explanations [ 'FN' ] . push ( expectedClass ) ; this . FN ++ ; allTrue = false ; } } if ( allTrue ) { this . TRUE ++ ; } this . count ++ ; _ . each ( explanations , function ( value , key , list ) { explanations [ key ] . sort ( ) } , this ) if ( explanations [ 'FP' ] . length == 0 ) delete explanations [ 'FP' ] if ( explanations [ 'FN' ] . length == 0 ) delete explanations [ 'FN' ] return explanations ; }
1547	function ( dataset ) { if ( this . debug ) console . log ( "trainBatch start" ) ; var timestamp = new Date ( ) . getTime ( ) + "_" + process . pid var learnFile = svmcommon . writeDatasetToFile ( dataset , this . bias , true , this . model_file_prefix + "_" + timestamp , "SvmPerf" , FIRST_FEATURE_NUMBER ) ; var modelFile = learnFile . replace ( / [.]learn / , ".model" ) ; var command = "svm_perf_learn " + this . learn_args + " " + learnFile + " " + modelFile ; if ( this . debug ) console . log ( "running " + command ) ; console . log ( command ) var result = execSync ( command ) ; if ( result . code > 0 ) { console . dir ( result ) ; console . log ( fs . readFileSync ( learnFile , 'utf-8' ) ) ; throw new Error ( "Failed to execute: " + command ) ; } this . setModel ( fs . readFileSync ( modelFile , "utf-8" ) ) ; if ( this . debug ) console . log ( "trainBatch end" ) ; }
1548	function modelStringToModelMap ( modelString ) { var matches = SVM_PERF_MODEL_PATTERN . exec ( modelString ) ; if ( ! matches ) { console . log ( modelString ) ; throw new Error ( "Model does not match SVM-perf format" ) ; } ; var featuresAndWeights = matches [ 2 ] . split ( " " ) ; var mapFeatureToWeight = { } ; for ( var i = 1 ; i < featuresAndWeights . length ; ++ i ) { var featureAndWeight = featuresAndWeights [ i ] ; var featureWeight = featureAndWeight . split ( ":" ) ; if ( featureWeight . length != 2 ) throw new Error ( "Model featureAndWeight doesn't match svm-perf pattern: featureAndWeight=" + featureAndWeight ) ; var feature = parseInt ( featureWeight [ 0 ] ) ; if ( feature <= 0 ) throw new IllegalArgumentException ( "Non-positive feature id: featureAndWeight=" + featureAndWeight ) ; var weight = parseFloat ( featureWeight [ 1 ] ) ; if ( Math . abs ( weight ) >= MIN_WEIGHT ) mapFeatureToWeight [ feature - FIRST_FEATURE_NUMBER ] = weight ; } return mapFeatureToWeight ; }
1549	function ( dataset , relationName , featureLookupTable ) { var arff = "% Automatically generated by Node.js\n" ; \n arff += "@relation " + relationName + "\n" ; \n featureLookupTable . featureIndexToFeatureName . forEach ( function ( featureName ) { if ( _ . isUndefined ( featureName ) ) arff += "@attribute undefined {0,1}" + "\n" ; else \n } ) ; if ( ! _ . isString ( featureName ) ) throw new Error ( "Expected featureName to be a string, but found " + JSON . stringify ( featureName ) ) ; else arff += "@attribute " + featureName . replace ( / [^a-zA-Z0-9] / g , "_" ) + " " + "{0,1}" + "\n" ; }
1550	function SvmLinear ( opts ) { this . learn_args = opts . learn_args || "" ; this . model_file_prefix = opts . model_file_prefix || null ; this . bias = opts . bias || 1.0 ; this . multiclass = opts . multiclass || false ; this . debug = opts . debug || false ; this . train_command = opts . train_command || 'liblinear_train' ; this . test_command = opts . test_command || 'liblinear_test' ; this . timestamp = "" if ( ! SvmLinear . isInstalled ( ) ) { var msg = "Cannot find the executable 'liblinear_train'. Please download it from the LibLinear website, and put a link to it in your path." ; console . error ( msg ) throw new Error ( msg ) ; } }
1551	function ( dataset ) { this . timestamp = new Date ( ) . getTime ( ) + "_" + process . pid _ . each ( dataset , function ( datum , key , list ) { if ( _ . isArray ( datum . output ) ) if ( datum . output . length > 1 ) { console . log ( "Multi-label is not allowed" ) console . log ( JSON . stringify ( darum . output , null , 4 ) ) process . exit ( 0 ) } } , this ) dataset = _ . map ( dataset , function ( datum ) { if ( _ . isArray ( datum . output ) ) datum . output = datum . output [ 0 ] return datum } ) ; this . allLabels = _ ( dataset ) . map ( function ( datum ) { return datum . output } ) ; this . allLabels = _ . uniq ( _ . flatten ( this . allLabels ) ) if ( this . allLabels . length == 1 ) return ; if ( this . debug ) console . log ( "trainBatch start" ) ; var learnFile = svmcommon . writeDatasetToFile ( dataset , this . bias , false , this . model_file_prefix + "_" + this . timestamp , "SvmLinear" , FIRST_FEATURE_NUMBER ) ; var modelFile = learnFile . replace ( / [.]learn / , ".model" ) ; var command = this . train_command + " " + this . learn_args + " " + learnFile + " " + modelFile ; console . log ( "running " + command ) ; var result = child_process . execSync ( command ) ; if ( result . code > 0 ) { console . dir ( result ) ; console . log ( fs . readFileSync ( learnFile , 'utf-8' ) ) ; throw new Error ( "Failed to execute: " + command ) ; } this . modelFileString = modelFile ; if ( this . debug ) console . log ( "trainBatch end" ) ; }
1552	function modelStringToModelMap ( modelString ) { var matches = LIB_LINEAR_MODEL_PATTERN . exec ( modelString ) ; if ( ! matches ) { console . log ( modelString ) ; throw new Error ( "Model does not match SVM-Linear format" ) ; } ; var labels = matches [ 1 ] . split ( / \s+ / ) ; var mapLabelToMapFeatureToWeight = { } ; for ( var iLabel in labels ) { var label = labels [ iLabel ] ; mapLabelToMapFeatureToWeight [ label ] = { } ; } var weightsMatrix = matches [ 3 ] ; var weightsLines = weightsMatrix . split ( NEWLINE ) ; for ( var feature in weightsLines ) { var weights = weightsLines [ feature ] . split ( / \s+ / ) ; weights . pop ( ) ; if ( weights . length == 0 ) continue ; if ( weights . length == 1 && labels . length == 2 ) weights [ 1 ] = - weights [ 0 ] ; if ( weights . length != labels . length ) throw new Error ( "Model does not match SVM-Linear format: there are " + labels . length + " labels (" + labels + ") and " + weights . length + " weights (" + weights + ")" ) ; for ( var iLabel in labels ) { var label = labels [ iLabel ] ; var weight = parseFloat ( weights [ iLabel ] ) ; if ( Math . abs ( weight ) >= MIN_WEIGHT ) mapLabelToMapFeatureToWeight [ label ] [ feature ] = weight ; } } return mapLabelToMapFeatureToWeight ; }
1553	function ( sample , labels ) { labels = multilabelutils . normalizeOutputLabels ( labels ) ; for ( var l in labels ) { var positiveLabel = labels [ l ] ; this . makeSureClassifierExists ( positiveLabel ) ; this . mapClassnameToClassifier [ positiveLabel ] . trainOnline ( sample , 1 ) ; } for ( var negativeLabel in this . mapClassnameToClassifier ) { if ( labels . indexOf ( negativeLabel ) < 0 ) this . mapClassnameToClassifier [ negativeLabel ] . trainOnline ( sample , 0 ) ; } }
1554	function ( opts ) { if ( ! opts . multiclassClassifierType ) { console . dir ( opts ) ; throw new Error ( "opts.multiclassClassifierType not found" ) ; } this . multiclassClassifierType = opts . multiclassClassifierType ; this . featureExtractor = FeaturesUnit . normalize ( opts . featureExtractor ) ; this . multiclassClassifier = new this . multiclassClassifierType ( ) ; }
1555	function concatOptionDataArrays ( options , data , prop ) { if ( ! _ . has ( options , prop ) && ! _ . has ( data , prop ) ) { return ; } var combined = [ ] ; if ( _ . isArray ( options [ prop ] ) ) { combined = combined . concat ( options [ prop ] ) ; } if ( _ . isArray ( data [ prop ] ) ) { combined = combined . concat ( data [ prop ] ) ; } options [ prop ] = combined ; }
1556	function preorder ( node , nodeIndex , parent ) { var children var length var index var position var child if ( is ( test , node , nodeIndex , parent ) ) { return null } children = node . children if ( ! children || children . length === 0 ) { return node } position = 0 length = children . length index = - 1 while ( ++ index < length ) { child = preorder ( children [ index ] , index , node ) if ( child ) { children [ position ++ ] = child } } if ( cascade && position === 0 ) { return null } children . length = position return node }
1557	function filterRelations ( relation ) { var mappedData = includedData . find ( function ( inc ) { return inc . id === relation . id ; } ) ; var RelationModel = getModel ( relation . type ) ; var modeledData = new RelationModel ( mappedData ) ; return checkForRelations ( modeledData , modeledData . data ) ; }
1558	function ( bundleName , filter ) { var bundle , files = [ ] ; bundle = this . _bundles [ bundleName ] ; if ( ! bundle ) { throw new Error ( 'Unknown bundle "' + bundleName + '"' ) ; } Object . keys ( bundle . files ) . forEach ( function ( fullpath ) { var res = { ext : libpath . extname ( fullpath ) . substr ( 1 ) } ; if ( this . _filterResource ( res , filter ) ) { files . push ( fullpath ) ; } } , this ) ; return files ; }
1559	function ( bundleName , filter ) { var bundle = this . _bundles [ bundleName ] ; if ( ! bundle ) { throw new Error ( 'Unknown bundle "' + bundleName + '"' ) ; } return this . _walkBundleResources ( bundle , filter ) ; }
1560	function ( filter ) { var self = this , ress = [ ] ; Object . keys ( this . _bundles ) . forEach ( function ( bundleName ) { var bundle = self . _bundles [ bundleName ] ; self . _walkBundleResources ( bundle , filter ) . forEach ( function ( res ) { ress . push ( res ) ; } ) ; } ) ; return ress ; }
1561	function ( filter ) { var bundleName , bundles = this . _bundles , bundleNames = [ ] ; if ( 'function' !== typeof filter ) { return Object . keys ( this . _bundles ) ; } for ( bundleName in bundles ) { if ( bundles . hasOwnProperty ( bundleName ) ) { if ( filter ( bundles [ bundleName ] ) ) { bundleNames . push ( bundleName ) ; } } } return bundleNames ; }
1562	function ( findPath ) { var found = { } , longest ; findPath = libfs . realpathSync ( findPath ) ; Object . keys ( this . _bundlePaths ) . forEach ( function ( bundlePath ) { if ( 0 === findPath . indexOf ( bundlePath ) && ( findPath . length === bundlePath . length || libpath . sep === findPath . charAt ( bundlePath . length ) ) ) { found [ bundlePath . length ] = bundlePath ; } } ) ; longest = Math . max . apply ( Math , Object . keys ( found ) ) ; return this . _bundlePaths [ found [ longest ] ] ; }
1563	function ( baseDirectory , name , version , pkg , options ) { var seed ; seed = { baseDirectory : baseDirectory , name : name , version : version } ; if ( pkg ) { seed . name = ( pkg . locator && pkg . locator . name ? pkg . locator . name : pkg . name ) ; seed . version = pkg . version ; seed . options = pkg . locator ; seed . pkg = pkg ; } if ( options ) { if ( seed . options ) { mix ( seed . options , options ) ; } else { seed . options = options ; } } return seed ; }
1564	function ( seed , parent ) { var bundle , ruleset = this . _loadRuleset ( seed ) , msg ; if ( seed . options . location ) { seed . baseDirectory = libpath . resolve ( seed . baseDirectory , seed . options . location ) ; } if ( ! ruleset ) { msg = 'Bundle "' + seed . name + '" has unknown ruleset ' + JSON . stringify ( seed . options . ruleset ) ; if ( seed . options . rulesets ) { msg += ' in rulesets ' + JSON . stringify ( seed . options . rulesets ) ; } throw new Error ( msg ) ; } bundle = new Bundle ( seed . baseDirectory , seed . options ) ; bundle . name = seed . name ; bundle . version = seed . version ; bundle . type = ruleset . _name ; this . _bundles [ bundle . name ] = bundle ; this . _bundlePaths [ libfs . realpathSync ( bundle . baseDirectory ) ] = bundle . name ; if ( parent ) { if ( ! parent . bundles ) { parent . bundles = { } ; } parent . bundles [ bundle . name ] = bundle ; } return bundle ; }
1565	function ( fullPath ) { var bundleName , bundle , ruleset , relativePath , pathParts , subBundleSeed , res ; bundleName = this . _getBundleNameByPath ( fullPath ) ; bundle = this . _bundles [ bundleName ] ; if ( bundle . baseDirectory === fullPath . substr ( 0 , bundle . baseDirectory . length ) ) { relativePath = fullPath . substr ( bundle . baseDirectory . length + 1 ) ; } if ( relativePath . indexOf ( 'node_modules' ) === 0 ) { pathParts = relativePath . split ( libpath . sep ) ; while ( pathParts [ 0 ] === 'node_modules' && pathParts . length >= 2 ) { pathParts . shift ( ) ; bundleName = pathParts . shift ( ) ; } relativePath = pathParts . join ( libpath . sep ) ; bundle = this . _bundles [ bundleName ] ; if ( ! relativePath ) { return ; } if ( ! bundle ) { return ; } } ruleset = this . _loadRuleset ( bundle ) ; if ( ruleset . _skip && this . _ruleSkip ( fullPath , relativePath , ruleset . _skip ) ) { return ; } if ( ruleset . _bundles ) { subBundleSeed = this . _ruleBundles ( fullPath , relativePath , ruleset . _bundles , bundle ) ; if ( subBundleSeed ) { if ( ! subBundleSeed . options ) { subBundleSeed . options = { } ; } if ( ! subBundleSeed . options . rulesets ) { subBundleSeed . options . rulesets = bundle . options . rulesets ; } this . _makeBundle ( subBundleSeed , bundle ) ; return ; } } res = { bundleName : bundleName , fullPath : fullPath , relativePath : relativePath , ext : libpath . extname ( fullPath ) . substr ( 1 ) } ; this . _onFile ( res , ruleset ) ; }
1566	function ( fullPath , relativePath , rule ) { var r , regex ; relativePath = BundleLocator . _toUnixPath ( relativePath ) ; for ( r = 0 ; r < rule . length ; r += 1 ) { regex = rule [ r ] ; if ( regex . test ( relativePath ) ) { return true ; } } return false ; }
1567	function ( res , ruleset ) { var bundle = this . _bundles [ res . bundleName ] , ruleName , rule , relativePath = BundleLocator . _toUnixPath ( res . relativePath ) , match ; bundle . files [ res . fullPath ] = true ; for ( ruleName in ruleset ) { if ( ruleset . hasOwnProperty ( ruleName ) ) { if ( '_' !== ruleName . charAt ( 0 ) ) { rule = ruleset [ ruleName ] ; match = relativePath . match ( rule . regex ) ; if ( match ) { res . name = match [ rule . nameKey || 1 ] ; res . type = ruleName ; if ( rule . subtypeKey ) { res . subtype = match [ rule . subtypeKey ] || '' ; } if ( rule . selectorKey && match [ rule . selectorKey ] ) { res . selector = match [ rule . selectorKey ] ; } else { res . selector = DEFAULT_SELECTOR ; } return this . _onResource ( res ) ; } } } } }
1568	function ( res ) { var bundle = this . _bundles [ res . bundleName ] , type = res . type , subtype , selector = res . selector , name = res . name ; if ( ! bundle . resources [ selector ] ) { bundle . resources [ selector ] = { } ; } if ( ! bundle . resources [ selector ] [ type ] ) { bundle . resources [ selector ] [ type ] = { } ; } if ( res . hasOwnProperty ( 'subtype' ) ) { subtype = res . subtype ; if ( ! bundle . resources [ selector ] [ type ] [ subtype ] ) { bundle . resources [ selector ] [ type ] [ subtype ] = { } ; } bundle . resources [ selector ] [ type ] [ subtype ] [ name ] = res ; } else { bundle . resources [ selector ] [ type ] [ name ] = res ; } }
1569	function ( res , filter ) { if ( ! filter || Object . keys ( filter ) . length === 0 ) { return true ; } var prop ; for ( prop in filter ) { if ( 'extensions' === prop ) { if ( 'string' === typeof filter . extensions ) { filter . extensions = filter . extensions . split ( ',' ) ; } if ( ! filter . extensions || filter . extensions . indexOf ( res . ext ) === - 1 ) { return false ; } } else if ( 'types' === prop ) { if ( 'string' === typeof filter . types ) { filter . types = filter . types . split ( ',' ) ; } if ( ! filter . types || filter . types . indexOf ( res . type ) === - 1 ) { return false ; } } else { return false ; } } return true ; }
1570	function ( pkgDepths ) { var depths , minDepth , maxDepth , seeds ; depths = Object . keys ( pkgDepths ) ; minDepth = Math . min . apply ( Math , depths ) ; maxDepth = Math . max . apply ( Math , depths ) ; seeds = pkgDepths [ minDepth ] ; if ( 1 === seeds . length ) { if ( minDepth !== maxDepth ) { debug ( 'multiple "' + seeds [ 0 ] . name + '" packages found, using version ' + seeds [ 0 ] . version + ' from ' + seeds [ 0 ] . baseDirectory ) ; } return seeds [ 0 ] ; } seeds . sort ( function ( a , b ) { return libsemver . rcompare ( a . version , b . version ) ; } ) ; debug ( 'multiple "' + seeds [ 0 ] . name + '" packages found, using version ' + seeds [ 0 ] . version + ' from ' + seeds [ 0 ] . baseDirectory ) ; return seeds [ 0 ] ; }
1571	function ( all ) { var byDepth = { } ; all . forEach ( function ( seed ) { if ( ! byDepth [ seed . name ] ) { byDepth [ seed . name ] = { } ; } if ( ! byDepth [ seed . name ] [ seed . npmDepth ] ) { byDepth [ seed . name ] [ seed . npmDepth ] = [ ] ; } byDepth [ seed . name ] [ seed . npmDepth ] . push ( seed ) ; } ) ; return Object . keys ( byDepth ) . map ( function ( name ) { return this . _dedupeSeeds ( byDepth [ name ] ) ; } , this ) ; }
1572	function ( bundleSeed ) { var self = this , parentName , parent , bundle , filters ; parentName = this . _getBundleNameByPath ( libpath . dirname ( bundleSeed . baseDirectory ) ) ; parent = this . _bundles [ parentName ] ; bundle = this . _makeBundle ( bundleSeed , parent ) ; this . _bundles [ bundle . name ] = bundle ; filters = this . _options . exclude . concat ( [ 'node_modules' , / ^\. / ] ) ; this . _processFile ( bundle . baseDirectory ) ; walk . walkSync ( bundle . baseDirectory , { filters : [ ] , listeners : { directories : function ( root , dirStatsArray , next ) { var i , dirStats , exclude ; function filterDir ( filter ) { if ( dirStats . name . match ( filter ) ) { return true ; } } for ( i = dirStatsArray . length - 1 ; i >= 0 ; i -= 1 ) { dirStats = dirStatsArray [ i ] ; exclude = filters . some ( filterDir ) ; if ( exclude ) { dirStatsArray . splice ( i , 1 ) ; } else { self . _processFile ( libpath . join ( root , dirStats . name ) ) ; } } next ( ) ; } , file : function ( root , fileStats , next ) { self . _processFile ( libpath . join ( root , fileStats . name ) ) ; next ( ) ; } , errors : function ( root , nodeStatsArray , next ) { next ( ) ; } } } ) ; return bundle ; }
1573	function ( srcObject , excludeKeys ) { var destObject = { } , key ; for ( key in srcObject ) { if ( srcObject . hasOwnProperty ( key ) ) { if ( - 1 === excludeKeys . indexOf ( key ) ) { destObject [ key ] = srcObject [ key ] ; } } } return destObject ; }
1574	function Bundle ( baseDirectory , options ) { this . options = options || { } ; this . name = libpath . basename ( baseDirectory ) ; this . baseDirectory = baseDirectory ; this . type = undefined ; this . files = { } ; this . resources = { } ; }
1575	function getBaseScales ( type , domain , range , nice , tickCount ) { const factory = ( type === 'time' && scaleUtc ) || ( type === 'log' && scaleLog ) || scaleLinear const scale = createScale ( factory , domain , range ) if ( nice ) scale . nice ( tickCount ) return scale }
1576	function BufferingTracer ( tracer , options ) { options = options || { } ; var self = this ; this . _tracer = tracer ; this . _maxTraces = options . maxTraces || 50 ; this . _sendInterval = options . sendInterval ? ( options . sendInterval * 1000 ) : 10 * 1000 ; this . _lastSentTs = Date . now ( ) ; this . _buffer = [ ] ; this . _stopped = false ; this . _periodSendTimeoutId = setTimeout ( this . _periodicSendFunction . bind ( this ) , this . _sendInterval ) ; }
1577	function build ( gulp ) { var source = OPTIONS . isTypescript ? fs . readFileSync ( 'gulpfile.ts' ) . toString ( ) : OPTIONS . gulpfile ? fs . readFileSync ( OPTIONS . gulpfile ) . toString ( ) : Object . keys ( require . cache || { 'gulpfile.js' : '' } ) . map ( function ( file ) { if ( ! / node_modules|\.json$ / . test ( file ) ) { return fs . readFileSync ( file ) . toString ( ) + '\n' ; } } ) . \n join ; ( '' ) var rxDoc = '\\/\\*\\*\\r?\n(((?!\\*\\/)[\\s\\S])*?)' + \\ ; \\ \\ \\ \n \\ \\ \\ \\ '@task\\s+\\{(.*)?\\}((?!\\*\\/)[\\s\\S])*?\\*\\/' \\ \\ \\ \\ \\ \\ \\ \\ }
1578	function chunk ( str , maxLen ) { var len = maxLen || OPTIONS . lineWidth ; var curr = len ; var prev = 0 ; var out = [ ] ; while ( str [ curr ] ) { if ( str [ curr ++ ] == ' ' ) { out . push ( str . substring ( prev , curr ) ) ; prev = curr ; curr += len ; } } out . push ( str . substr ( prev ) ) ; return out ; }
1579	function usage ( gulp , options ) { if ( options ) { Object . assign ( OPTIONS , options ) ; } return new Promise ( function ( resolve ) { build ( gulp ) ; print ( ) ; resolve ( ) ; } ) ; }
1580	function filterArray ( arr , toKeep ) { var i = 0 while ( i < arr . length ) { if ( toKeep ( arr [ i ] ) ) { i ++ } else { arr . splice ( i , 1 ) } } }
1581	function cssExtract ( bundle , opts ) { opts = opts || { } var outFile = opts . out || opts . o || 'bundle.css' var sourceMap = d ( opts . sourceMap , bundle && bundle . _options && bundle . _options . debug , false ) assert . equal ( typeof bundle , 'object' , 'bundle should be an object' ) assert . equal ( typeof opts , 'object' , 'opts should be an object' ) bundle . on ( 'reset' , addHooks ) addHooks ( ) function addHooks ( ) { const extractStream = through . obj ( write , flush ) const writeStream = ( typeof outFile === 'function' ) ? outFile ( ) : bl ( writeComplete ) bundle . pipeline . get ( 'label' ) . unshift ( extractStream ) function write ( chunk , enc , cb ) { if ( ! / (insert-css|sheetify\/insert) / . test ( chunk . source ) ) { return cb ( null , chunk ) } var source = from2 ( chunk . source ) var sm = staticModule ( { 'insert-css' : function ( src ) { writeStream . write ( String ( src ) + '\n' ) \n } , return from2 ( 'null' ) } , 'sheetify/insert' : function ( src ) { writeStream . write ( String ( src ) + '\n' ) \n } ) return from2 ( 'null' ) { sourceMap : sourceMap } } source . pipe ( sm ) . pipe ( bl ( complete ) ) function complete ( err , source ) { if ( err ) return extractStream . emit ( 'error' , err ) chunk . source = String ( source ) cb ( null , chunk ) } } }
1582	function validatePlaceholders ( { id , idPlural , translations } , validationErrors ) { let pattern = / {{\s*(\S+?)\s*?}} / g ; let placeholders = id . match ( pattern ) || [ ] ; if ( idPlural ) { let pluralPlaceholders = idPlural . match ( pattern ) || [ ] ; pluralPlaceholders . forEach ( ( placeholder ) => { if ( ! placeholders . includes ( placeholder ) ) { placeholders . push ( placeholder ) ; } } ) ; } if ( ! placeholders . length ) { return ; } translations . forEach ( ( translation ) => { let translatedPlaceholders = translation . match ( pattern ) || [ ] ; let invalidPlaceholder = translatedPlaceholders . find ( ( placeholder ) => ! placeholders . includes ( placeholder ) ) ; if ( invalidPlaceholder ) { validationErrors . push ( { id , translation , message : ` ${ invalidPlaceholder } ${ placeholders . join ( ', ' ) } ` , level : 'ERROR' } ) ; } } ) ; }
1583	function groupGettextItems ( gettextItems ) { return gettextItems . filter ( ( item ) => item . messageId ) . sort ( ( item1 , item2 ) => { return ( item1 . loc . fileName . localeCompare ( item2 . loc . fileName ) || item1 . loc . line - item2 . loc . line ) ; } ) . reduce ( ( allGroups , item ) => { let group = allGroups . find ( ( group ) => { return ( group . messageId === item . messageId && group . messageContext === item . messageContext ) ; } ) ; if ( group ) { group . locs . push ( item . loc ) ; if ( ! group . messageIdPlural && item . messageIdPlural ) { group . messageIdPlural = item . messageIdPlural ; } } else { group = Object . assign ( { } , item ) ; group . locs = [ item . loc ] ; delete group . loc ; allGroups . push ( group ) ; } return allGroups ; } , [ ] ) ; }
1584	function traverseJson ( json , callback ) { let { translations } = json ; Object . keys ( translations ) . forEach ( ( namespace ) => { Object . keys ( translations [ namespace ] ) . forEach ( ( k ) => { callback ( translations [ namespace ] [ k ] , translations [ namespace ] , k ) ; } ) ; } ) ; }
1585	function findAllDependencies ( file , knownDependencies , sourceDirectories , knownFiles ) { if ( ! knownDependencies ) { knownDependencies = [ ] ; } if ( typeof knownFiles === "undefined" ) { knownFiles = [ ] ; } else if ( knownFiles . indexOf ( file ) > - 1 ) { return knownDependencies ; } if ( sourceDirectories ) { return findAllDependenciesHelp ( file , knownDependencies , sourceDirectories , knownFiles ) . then ( function ( thing ) { return thing . knownDependencies ; } ) ; } else { return getBaseDir ( file ) . then ( getElmPackageSourceDirectories ) . then ( function ( newSourceDirs ) { return findAllDependenciesHelp ( file , knownDependencies , newSourceDirs , knownFiles ) . then ( function ( thing ) { return thing . knownDependencies ; } ) ; } ) ; } }
1586	function parse ( query ) { if ( query [ 0 ] == "?" ) query = query . slice ( 1 ) ; var pairs = query . split ( "&" ) , obj = { } ; for ( var i in pairs ) { var pair = pairs [ i ] . split ( "=" ) , key = decodeURIComponent ( pair [ 0 ] ) , value = pair [ 1 ] ? decodeURIComponent ( pair [ 1 ] ) : "" ; obj [ key ] = value ; } return obj ; }
1587	function stringify ( obj ) { var arr = [ ] ; for ( var x in obj ) { arr . push ( encodeURIComponent ( x ) + "=" + encodeURIComponent ( obj [ x ] ) ) ; } return arr . join ( "&" ) ; }
1588	function _compileAny ( any , options ) { if ( oj . isArray ( any ) ) _compileTag ( any , options ) else if ( oj . isString ( any ) ) { if ( options . html != null ) options . html . push ( any ) if ( any . length > 0 && any [ 0 ] === '<' ) { var root = document . createElement ( 'div' ) root . innerHTML = any if ( options . dom != null ) options . dom . appendChild ( root ) } else { if ( options . dom != null ) options . dom . appendChild ( document . createTextNode ( any ) ) } } else if ( oj . isBoolean ( any ) || oj . isNumber ( any ) ) { if ( options . html != null ) options . html . push ( "" + any ) if ( options . dom != null ) options . dom . appendChild ( document . createTextNode ( "" + any ) ) } else if ( oj . isFunction ( any ) ) { _compileAny ( oj ( any ) , options ) } else if ( oj . isDate ( any ) ) { if ( options . html != null ) options . html . push ( "" + ( any . toLocaleString ( ) ) ) if ( options . dom != null ) options . dom . appendChild ( document . createTextNode ( "" + ( any . toLocaleString ( ) ) ) ) } else if ( oj . isOJ ( any ) ) { if ( options . types != null ) options . types . push ( any ) if ( options . html != null ) options . html . push ( any . toHTML ( options ) ) if ( options . dom != null ) options . dom . appendChild ( any . toDOM ( options ) ) if ( options . css != null ) _extend ( options . css , any . toCSSMap ( options ) ) } }
1589	function _attributesBindEventsToDOM ( events , el , inserts ) { var ek , ev , _results = [ ] for ( ek in events ) { ev = events [ ek ] _a ( oj . $ != null , "jquery is missing when binding a '" + ek + "' event" ) if ( ek == 'insert' && inserts ) inserts . push ( function ( ) { ev . call ( el , el ) } ) else if ( oj . isArray ( ev ) ) _results . push ( oj . $ ( el ) [ ek ] . apply ( this , ev ) ) else _results . push ( oj . $ ( el ) [ ek ] ( ev ) ) } return _results }
1590	function ( ) { _a ( oj . isDOM ( this . el ) , this . typeName , 'constructor did not set this.el' ) _setInstanceOnElement ( this . el , this ) var u = oj . unionArguments ( arguments ) , options = u . options , args = u . args if ( this . __autonew__ && ! options . __quiet__ ) this . emit ( ) if ( options . __quiet__ != null ) delete options . __quiet__ this . $el . addClass ( "oj-" + this . typeName ) this . set ( options ) options = _clone ( options ) this . properties . forEach ( function ( v ) { return delete options [ v ] } ) this . addAttributes ( options ) return this . _isConstructed = true }
1591	function ( $el , args ) { if ( args . length === 0 ) return $el [ 0 ] . oj var r = oj . compile . apply ( oj , [ { dom : 1 , html : 0 , cssMap : 1 } ] . concat ( slice . call ( args ) ) ) _insertStyles ( r . cssMap , { global : 0 } ) $el . html ( '' ) if ( ! oj . isArray ( r . dom ) ) r . dom = [ r . dom ] for ( var ix = 0 ; ix < r . dom . length ; ix ++ ) $el . append ( r . dom [ ix ] ) _triggerInserted ( r . types , r . inserts ) }
1592	function _jqGetValue ( $el , args ) { var el = $el [ 0 ] , child = el . firstChild if ( oj . isOJInstance ( _getInstanceOnElement ( el ) ) ) return _getInstanceOnElement ( el ) else if ( oj . isDOMText ( child ) ) return oj . parse ( child . nodeValue ) else if ( oj . isDOMElement ( child ) ) return _d ( _getInstanceOnElement ( child ) , child ) }
1593	function ( describe ) { if ( ! Array . isArray ( describe . m ) ) { return when . reject ( 'no modules in describe message' ) ; } var allDeps = [ ] ; var modules = describe . m ; for ( var i = 0 ; i < modules . length ; i ++ ) { var checkModule = modules [ i ] ; for ( var d = 0 ; d < checkModule . d . length ; d ++ ) { var moduleNeeds = checkModule . d [ d ] ; var deps = this . _walkChain ( modules , moduleNeeds ) ; if ( deps && ( deps . length > 0 ) ) { allDeps = allDeps . concat ( deps ) ; } } } var keyFn = function ( dep ) { return [ dep . f , dep . n , dep . v ] . join ( '_' ) ; } ; return utilities . dedupArray ( allDeps , keyFn ) ; }
1594	async function main ( ) { process . title = 'Coveralls.js' ; program . name ( 'coveralls' ) . description ( 'Send a coverage report to the Coveralls service.' ) . version ( packageVersion , '-v, --version' ) . arguments ( '<file>' ) . action ( file => program . file = file ) . parse ( process . argv ) ; if ( ! program . file ) { program . outputHelp ( ) ; process . exitCode = 64 ; return null ; } const client = new Client ( 'COVERALLS_ENDPOINT' in process . env ? new URL ( process . env . COVERALLS_ENDPOINT ) : Client . defaultEndPoint ) ; const coverage = await promises . readFile ( program . file , 'utf8' ) ; console . log ( ` ${ client . endPoint } ` ) ; return client . upload ( coverage ) ; }
1595	function Shortline ( options ) { const self = this ; self . _input = ( options && options . input ) || process . stdin ; self . _output = ( options && options . output ) || process . stderr ; self . inputError = null ; self . _input . on ( 'end' , ( ) => { self . inputError = new EOFError ( EOF_MESSAGE ) ; } ) ; }
1596	function findElements ( node , name ) { return name in node && Array . isArray ( node [ name ] ) ? node [ name ] : [ ] ; }
1597	async function main ( ) { try { const coverage = await promises . readFile ( '/path/to/coverage.report' , 'utf8' ) ; await new Client ( ) . upload ( coverage ) ; console . log ( 'The report was sent successfully.' ) ; } catch ( error ) { console . log ( ` ${ error . message } ` ) ; if ( error instanceof ClientError ) console . log ( ` ${ error . uri } ` ) ; } }
1598	function TravisStatusHttp ( endpoint , options ) { if ( endpoint && typeof endpoint !== 'string' ) { throw new TypeError ( 'endpoint must be a string' ) ; } endpoint = endpoint && trimSlash ( endpoint ) ; if ( options && typeof options !== 'object' ) { throw new TypeError ( 'options must be an object' ) ; } options = Object . assign ( { gzip : true } , options ) ; options . headers = Object . assign ( { } , options . headers ) ; const caselessHeaders = caseless ( options . headers ) ; if ( ! caselessHeaders . has ( 'Accept' ) ) { options . headers . Accept = 'application/vnd.travis-ci.2+json, application/json' ; } if ( ! caselessHeaders . has ( 'User-Agent' ) ) { options . headers [ 'User-Agent' ] = DEFAULT_USER_AGENT ; } TravisHttp . call ( this , endpoint === constants . PRO_URI , options . headers ) ; this . _endpoint = endpoint || constants . ORG_URI ; this . _headers = options . headers ; delete options . headers ; this . _options = options ; }
1599	function git ( ... args ) { return new Promise ( ( resolve , reject ) => { const child = execFile ( 'git' , args , ( err , stdout , stderr ) => { if ( err ) { reject ( err ) ; } else { resolve ( [ stdout , stderr ] ) ; } } ) ; child . stdin . end ( ) ; } ) ; }
1600	function SlugDetectionError ( message ) { if ( ! ( this instanceof SlugDetectionError ) ) { return new SlugDetectionError ( message ) ; } Error . captureStackTrace ( this , SlugDetectionError ) ; if ( message !== undefined ) { Object . defineProperty ( this , 'message' , { value : String ( message ) , configurable : true , writable : true } ) ; } }
1601	function createScopedCss ( html , scope , filepath , cssVariables ) { scope = typeof scope === 'string' ? { ns : scope , vars : new Map ( ) } : scope ; const style = html . match ( styleMatcher ) ; if ( ! style ) { return [ { } , scope . vars , '' ] ; } const cssom = css . parse ( style [ 1 ] , { source : filepath } ) ; const vars = new Map ( scope . vars . entries ( ) ) ; getVariables ( cssom ) . forEach ( ( value , key ) => vars . set ( key , value ) ) ; if ( cssVariables ) { resolveScopeVariables ( cssom , vars ) ; } const [ classes , transformMap ] = rewriteSelectors ( ` ${ decamelize ( scope . ns , '-' ) } ` , cssom ) ; return [ classes , vars , css . stringify ( cssom ) , transformMap ] ; }
1602	function combineCss ( templates , scopedCss ) { if ( ! Array . isArray ( scopedCss ) ) { scopedCss = [ scopedCss ] ; } return [ ... Object . keys ( templates ) . map ( name => templates [ name ] . css ) , ... scopedCss ] . join ( '\n' ) . \n trim ; }
1603	function InvalidSlugError ( message ) { if ( ! ( this instanceof InvalidSlugError ) ) { return new InvalidSlugError ( message ) ; } Error . captureStackTrace ( this , InvalidSlugError ) ; if ( message !== undefined ) { Object . defineProperty ( this , 'message' , { value : String ( message ) , configurable : true , writable : true } ) ; } }
1604	function checkBuildCommit ( build , localCommit ) { const buildCommit = build . commit ; let message = ` ${ buildCommit . sha } ${ localCommit . sha } ` ; if ( localCommit . name ) { message += ` ${ localCommit . name } ` ; } assert . strictEqual ( buildCommit . sha , localCommit . sha , message ) ; return build ; }
1605	function trimSlash ( string ) { if ( typeof string !== 'string' ) { return string ; } if ( string . length > 0 && string . charAt ( string . length - 1 ) === '/' ) { return string . slice ( 0 , string . length - 1 ) ; } return string ; }
1606	function parseOptions ( opts ) { return removeEmpty ( { plugins : convertFn . call ( this , opts . plugins ) , locals : convertFn . call ( this , opts . locals ) , filename : convertFn . call ( this , opts . filename ) , parserOptions : convertFn . call ( this , opts . parserOptions ) , generatorOptions : convertFn . call ( this , opts . generatorOptions ) , runtime : convertFn . call ( this , opts . runtime ) , parser : convertFnSpecial . call ( this , opts . parser ) , multi : convertFn . call ( this , opts . multi ) } ) }
1607	function serializeVerbatim ( obj ) { let i = 0 const fns = [ ] let res = JSON . stringify ( obj , ( k , v ) => { if ( typeof v === 'function' ) { fns . push ( v . toString ( ) ) return ` ${ i ++ } ` } else { return v } } ) res = res . replace ( / "__REPLACE(\d{1})" / g , ( m , v ) => { return fns [ v ] } ) return res }
1608	function renderPages ( filepaths , dest , { templates , vars , statics , disableValidation , cssVariables , host } ) { console . log ( ` \n ` ) ; return Promise . all ( filepaths . map ( filepath => { return sander . readFile ( filepath ) . then ( content => renderPage ( content , filepath , { templates , vars , dest , cssVariables } ) ) . then ( ( [ html , destinationPath , cssParts ] ) => sander . writeFile ( destinationPath , html ) . then ( ( ) => [ destinationPath , cssParts ] ) ) . then ( ( [ destinationPath , cssParts ] ) => { console . log ( ` ${ chalk . bold . green ( figures . tick ) } ${ filepath } ${ destinationPath } ` ) ; return [ destinationPath , cssParts ] ; } ) ; } ) ) . then ( pageResults => disableValidation || validatePages ( host , dest , pageResults . map ( result => result [ 0 ] ) , statics ) . then ( ( ) => pageResults . map ( result => result [ 1 ] ) ) ) ; }
1609	function gitUrlPath ( gitUrl ) { const foreignParts = / ^([A-Za-z0-9][A-Za-z0-9+.-]*)::(.*)$ / . exec ( gitUrl ) ; if ( foreignParts ) { return foreignParts [ 2 ] ; } const gitUrlObj = url . parse ( gitUrl ) ; if ( gitUrlObj . protocol ) { return gitUrlObj . path ; } const scpParts = / ^([^@/]+)@(\[[^]\/]+\]|[^:/]+):(.*)$ / . exec ( gitUrl ) ; if ( scpParts ) { return scpParts [ 3 ] ; } return gitUrl ; }
1610	function ( ) { var appEnv = this . app . env ; if ( process . env . DEPLOY_TARGET ) { appEnv = process . env . DEPLOY_TARGET ; } var publicFiles = new Funnel ( this . app . trees . public ) ; this . _requireBuildPackages ( ) ; fs . stat ( path . join ( this . project . root , 'public' , 'robots.txt' ) , function ( err , stats ) { if ( stats && stats . isFile ( ) ) { console . log ( chalk . yellow ( 'There is a robots.txt in /public and ENV specific robots.txt are ignored!' ) ) ; } } ) ; publicFiles = stew . rename ( publicFiles , 'robots-' + appEnv + '.txt' , 'robots.txt' ) ; return new Funnel ( publicFiles , { srcDir : '/' , destDir : '/' } ) ; }
1611	function compileIndex ( ) { fs . readFile ( path . join ( __dirname , 'templates' , 'index.hogan' ) , function ( err , data ) { if ( err ) throw err ; fs . writeFile ( path . join ( __dirname , 'index.html' ) , hogan . compile ( data . toString ( ) ) . render ( { 'schemes' : schemes , 'variations' : variations , 'colors' : colors , 'variants' : variants , } ) , function ( err ) { if ( err ) throw err } ) ; open ( path . join ( __dirname , 'index.html' ) ) ; } ) ; }
1612	function sortMentions ( mentions ) { return mentions . slice ( ) . sort ( ( a , b ) => b . length - a . length ) ; }
1613	function findEmoji ( names , match ) { const compare = match . toLowerCase ( ) ; for ( let i = 0 ; i < names . length ; i += 1 ) { const name = names [ i ] . toLowerCase ( ) ; if ( name === compare ) { return names [ i ] ; } } return null ; }
1614	function fiberize ( fn ) { return function ( done ) { var self = this ; Fiber ( function ( ) { try { if ( fn . length == 1 ) { fn . call ( self , done ) ; } else { fn . call ( self ) ; done ( ) ; } } catch ( e ) { process . nextTick ( function ( ) { throw ( e ) ; } ) ; } } ) . run ( ) ; } ; }
1615	function ( regex , type , types , selector ) { var matches = selector . match ( regex ) ; if ( matches ) { for ( var i = 0 ; i < matches . length ; i ++ ) { types [ type ] ++ ; selector = selector . replace ( matches [ i ] , ' ' ) ; } } return selector ; }
1616	function ( selector ) { var commaIndex = selector . indexOf ( ',' ) ; if ( commaIndex !== - 1 ) { selector = selector . substring ( 0 , commaIndex ) ; } var types = { a : 0 , b : 0 , c : 0 } ; selector = selector . replace ( notRegex , ' $1 ' ) ; selector = selector . replace ( ruleRegex , ' ' ) ; selector = findMatch ( attributeRegex , 'b' , types , selector ) ; selector = findMatch ( idRegex , 'a' , types , selector ) ; selector = findMatch ( classRegex , 'b' , types , selector ) ; selector = findMatch ( pseudoElementRegex , 'c' , types , selector ) ; selector = findMatch ( pseudoClassRegex , 'b' , types , selector ) ; selector = selector . replace ( separatorRegex , ' ' ) ; selector = selector . replace ( straysRegex , ' ' ) ; findMatch ( elementRegex , 'c' , types , selector ) ; return ( types . a * 100 ) + ( types . b * 10 ) + ( types . c * 1 ) ; }
1617	function ( collectionName , indexName , columns , unique , callback ) { var options = { indexName : indexName , columns : columns , unique : unique } ; return this . _run ( 'createIndex' , collectionName , options ) . nodeify ( callback ) ; }
1618	function ( name , callback ) { return this . _run ( 'insert' , this . internals . migrationTable , { name : name , run_on : new Date ( ) } ) . nodeify ( callback ) ; }
1619	function ( name , callback ) { return this . _run ( 'insert' , this . internals . seedTable , { name : name , run_on : new Date ( ) } ) . nodeify ( callback ) ; }
1620	function ( err , data ) { if ( err ) { prCB ( err ) ; } prCB ( null , data ) ; db . close ( ) ; }
1621	function parseParameters ( options ) { var opt = { maximumAge : 0 , enableHighAccuracy : true , timeout : Infinity , interval : 6000 , fastInterval : 1000 , priority : PRIORITY_HIGH_ACCURACY } ; if ( options ) { if ( options . maximumAge !== undefined && ! isNaN ( options . maximumAge ) && options . maximumAge > 0 ) { opt . maximumAge = options . maximumAge ; } if ( options . enableHighAccuracy !== undefined ) { opt . enableHighAccuracy = options . enableHighAccuracy ; } if ( options . timeout !== undefined && ! isNaN ( options . timeout ) ) { if ( options . timeout < 0 ) { opt . timeout = 0 ; } else { opt . timeout = options . timeout ; } } if ( options . interval !== undefined && ! isNaN ( options . interval ) && options . interval > 0 ) { opt . interval = options . interval ; } if ( options . fastInterval !== undefined && ! isNaN ( options . fastInterval ) && options . fastInterval > 0 ) { opt . fastInterval = options . fastInterval ; } if ( options . priority !== undefined && ! isNaN ( options . priority ) && options . priority >= PRIORITY_NO_POWER && options . priority <= PRIORITY_HIGH_ACCURACY ) { if ( options . priority === PRIORITY_NO_POWER ) { opt . priority = PRIORITY_NO_POWER ; } if ( options . priority === PRIORITY_LOW_POWER ) { opt . priority = PRIORITY_LOW_POWER ; } if ( options . priority === PRIORITY_BALANCED_POWER_ACCURACY ) { opt . priority = PRIORITY_BALANCED_POWER_ACCURACY ; } if ( options . priority === PRIORITY_HIGH_ACCURACY ) { opt . priority = PRIORITY_HIGH_ACCURACY ; } } } return opt ; }
1622	function noProp ( props , propNameOrFunction ) { if ( ! props ) { throw new Error ( 'Headful: You must pass all declared props when you use headful.props.x() calls.' ) ; } const propName = typeof propNameOrFunction === 'function' ? propNameOrFunction . name : propNameOrFunction ; return ! props . hasOwnProperty ( propName ) ; }
1623	function GifCli ( path , callback ) { var frames = [ ] ; OneByOne ( [ Tmp . dir , function ( next , tmpDir ) { var str = Fs . createReadStream ( path ) , isFinished = false , complete = [ ] , i = 0 ; str . on ( "end" , function ( ) { isFinished = true ; } ) ; str . pipe ( GifExplode ( function ( frame ) { Tmp . file ( { postfix : ".gif" , } , function ( err , cImg ) { ( function ( i , cImg ) { if ( err ) { return next ( err ) ; } var wStr = Fs . createWriteStream ( cImg ) ; frame . pipe ( wStr ) ; complete [ i ] = false ; wStr . on ( "close" , function ( ) { ImageToAscii ( cImg , function ( err , asciified ) { complete [ i ] = true ; frames [ i ] = asciified || "" ; if ( ! isFinished ) { return ; } if ( ! complete . filter ( function ( c ) { return c !== true } ) . length ) { next ( ) ; } } ) ; } ) ; } ) ( i ++ , cImg ) ; } ) ; } ) ) ; } , function ( next ) { frames = frames . filter ( Boolean ) ; next ( ) ; } ] , function ( err ) { if ( err ) { return callback ( err ) ; } callback ( null , frames ) ; } ) ; }
1624	function shouldLog ( testlevel , thresholdLevel ) { var allowed = logLevelAllowedGranular ( testlevel ) ; if ( allowed ) { return true ; } return logLevelAllowed ( testlevel , thresholdLevel ) ; }
1625	function ( ) { if ( attrs . type === 'radio' ) { return attrs . value || $parse ( attrs . ngValue ) ( scope ) || true ; } var trueValue = ( $parse ( attrs . ngTrueValue ) ( scope ) ) ; if ( angular . isUndefined ( trueValue ) ) { trueValue = true ; } return trueValue ; }
1626	function ( attrName ) { var map = { 'switchRadioOff' : getBooleanFromStringDefTrue , 'switchActive' : function ( value ) { return ! getBooleanFromStringDefTrue ( value ) ; } , 'switchAnimate' : getBooleanFromStringDefTrue , 'switchLabel' : function ( value ) { return value ? value : '&nbsp;' ; } , 'switchIcon' : function ( value ) { if ( value ) { return '<span class=\'' + \' + value ; } } , '\'></span>' , \' , 'switchWrapper' : function ( value ) { return value || 'wrapper' ; } , 'switchInverse' : getBooleanFromString } ; 'switchReadonly' : getBooleanFromString 'switchChange' : getExprFromString }
1627	function ( ) { if ( ! isInit ) { var viewValue = ( controller . $modelValue === getTrueValue ( ) ) ; isInit = ! isInit ; element . bootstrapSwitch ( { radioAllOff : getSwitchAttrValue ( 'switchRadioOff' ) , disabled : getSwitchAttrValue ( 'switchActive' ) , state : viewValue , onText : getSwitchAttrValue ( 'switchOnText' ) , offText : getSwitchAttrValue ( 'switchOffText' ) , onColor : getSwitchAttrValue ( 'switchOnColor' ) , offColor : getSwitchAttrValue ( 'switchOffColor' ) , animate : getSwitchAttrValue ( 'switchAnimate' ) , size : getSwitchAttrValue ( 'switchSize' ) , labelText : attrs . switchLabel ? getSwitchAttrValue ( 'switchLabel' ) : getSwitchAttrValue ( 'switchIcon' ) , wrapperClass : getSwitchAttrValue ( 'switchWrapper' ) , handleWidth : getSwitchAttrValue ( 'switchHandleWidth' ) , labelWidth : getSwitchAttrValue ( 'switchLabelWidth' ) , inverse : getSwitchAttrValue ( 'switchInverse' ) , readonly : getSwitchAttrValue ( 'switchReadonly' ) } ) ; if ( attrs . type === 'radio' ) { controller . $setViewValue ( controller . $modelValue ) ; } else { controller . $setViewValue ( viewValue ) ; } } }
1628	function ( ) { attrs . $observe ( 'switchActive' , function ( newValue ) { var active = getBooleanFromStringDefTrue ( newValue ) ; if ( ! active ) { $timeout ( setActive ) ; } else { setActive ( ) ; } } ) ; controller . $render = function ( ) { initMaybe ( ) ; var newValue = controller . $modelValue ; if ( newValue !== undefined && newValue !== null ) { element . bootstrapSwitch ( 'state' , newValue === getTrueValue ( ) , true ) ; } else { element . bootstrapSwitch ( 'indeterminate' , true , true ) ; controller . $setViewValue ( undefined ) ; } switchChange ( ) ; } ; var bindings = { 'switchRadioOff' : 'radioAllOff' , 'switchOnText' : 'onText' , 'switchOffText' : 'offText' , 'switchOnColor' : 'onColor' , 'switchOffColor' : 'offColor' , 'switchAnimate' : 'animate' , 'switchSize' : 'size' , 'switchLabel' : 'labelText' , 'switchIcon' : 'labelText' , 'switchWrapper' : 'wrapperClass' , 'switchHandleWidth' : 'handleWidth' , 'switchLabelWidth' : 'labelWidth' , 'switchInverse' : 'inverse' , 'switchReadonly' : 'readonly' } ; var observeProp = function ( prop , bindings ) { return function ( ) { attrs . $observe ( prop , function ( ) { setSwitchParamMaybe ( element , bindings [ prop ] , prop ) ; } ) ; } ; } ; for ( var prop in bindings ) { attrs . $observe ( prop , observeProp ( prop , bindings ) ) ; } }
1629	function ( ) { if ( attrs . type === 'radio' ) { element . on ( 'change.bootstrapSwitch' , function ( e ) { if ( ( controller . $modelValue === controller . $viewValue ) && ( e . target . checked !== $ ( e . target ) . bootstrapSwitch ( 'state' ) ) ) { if ( e . target . checked ) { controller . $setViewValue ( getTrueValue ( ) ) ; } else if ( getTrueValue ( ) === controller . $viewValue ) { controller . $setViewValue ( undefined ) ; } switchChange ( ) ; } } ) ; } else { element . on ( 'switchChange.bootstrapSwitch' , function ( e ) { controller . $setViewValue ( e . target . checked ) ; switchChange ( ) ; } ) ; } }
1630	function ( n ) { var r , i , c = parseCookies ( ) ; if ( typeof n === 'string' ) { r = ( c [ n ] !== undef ) ? c [ n ] : null ; } else if ( typeof n === 'object' && n !== null ) { r = { } ; for ( i in n ) { if ( Object . prototype . hasOwnProperty . call ( n , i ) ) { if ( c [ n [ i ] ] !== undef ) { r [ n [ i ] ] = c [ n [ i ] ] ; } else { r [ n [ i ] ] = null ; } } } } else { r = c ; } return r ; }
1631	function ( p ) { var n , r = { } , c = parseCookies ( ) ; if ( typeof p === 'string' ) { p = new RegExp ( p ) ; } for ( n in c ) { if ( Object . prototype . hasOwnProperty . call ( c , n ) && n . match ( p ) ) { r [ n ] = c [ n ] ; } } return r ; }
1632	function ( n , v , o ) { if ( typeof o !== 'object' || o === null ) { o = { } ; } if ( v === undef || v === null ) { v = '' ; o . expires = new Date ( ) ; o . expires . setFullYear ( 1978 ) ; } else { v = ( v === true ) ? 'true' : ( v === false ) ? 'false' : ! isNaN ( v ) ? String ( v ) : v ; if ( typeof v !== 'string' ) { if ( typeof JSON === 'object' && JSON !== null && typeof JSON . stringify === 'function' ) { v = JSON . stringify ( v ) ; } else { throw new Error ( 'cookies.set() could not be serialize the value' ) ; } } } document . cookie = n + '=' + encodeURIComponent ( v ) + cookieOptions ( o ) ; }
1633	function ( ) { var r = false , n = 'test_cookies_jaaulde_js' , v = 'data' ; this . set ( n , v ) ; if ( this . get ( n ) === v ) { this . del ( n ) ; r = true ; } return r ; }
1634	function formatMessage ( str ) { return String ( str ) . split ( '\n' ) . \n map . ( function ( s ) { return s . magenta ; } ) join ; }
1635	function createZoomRangePath ( options ) { if ( ! angular . isObject ( options . state ) ) { options . state = { } ; } if ( ! angular . isObject ( options . state . range ) ) { options . state . range = [ ] ; } }
1636	function synchronizeZoom ( options , configuration , watcher ) { if ( angular . isObject ( options . chart ) && angular . isObject ( options . chart . zoom ) && options . chart . zoom . enabled === true ) { configuration . zoom . onzoomend = function ( domain ) { AngularChartWatcher . updateState ( watcher , function ( ) { createZoomRangePath ( options ) ; options . state . range = domain ; } ) ; if ( angular . isFunction ( options . chart . zoom . onzoomend ) ) { AngularChartWatcher . applyFunction ( watcher , function ( ) { options . chart . zoom . onzoomend ( domain ) ; } ) ; } } ; } if ( angular . isObject ( options . chart ) && angular . isObject ( options . chart . subchart ) && options . chart . subchart . show === true ) { configuration . subchart . onbrush = function ( domain ) { AngularChartWatcher . updateState ( watcher , function ( ) { createZoomRangePath ( options ) ; options . state . range = domain ; } ) ; if ( angular . isFunction ( options . chart . subchart . onbrush ) ) { AngularChartWatcher . applyFunction ( watcher , function ( ) { options . chart . subchart . onbrush ( domain ) ; } ) ; } } ; } }
1637	function addSelections ( chart , selections ) { service . disableSelectionListener = true ; selections . forEach ( function ( selection ) { chart . select ( [ selection . id ] , [ selection . index ] ) ; } ) ; service . disableSelectionListener = false ; }
1638	function applySelection ( options , chart ) { if ( angular . isObject ( options . state ) && angular . isArray ( options . state . selected ) ) { addSelections ( chart , options . state . selected ) ; } else { removeAllSelections ( chart ) ; } }
1639	function createSelectionsPath ( options ) { if ( ! angular . isObject ( options . state ) ) { options . state = { } ; } if ( ! angular . isArray ( options . state . selected ) ) { options . state . selected = [ ] ; } }
1640	function synchronizeSelection ( options , configuration , watcher ) { if ( angular . isObject ( options . chart ) && angular . isObject ( options . chart . data ) && angular . isObject ( options . chart . data . selection ) && options . chart . data . selection . enabled === true ) { configuration . data . onselected = function ( data , element ) { if ( service . disableSelectionListener ) { return ; } AngularChartWatcher . updateState ( watcher , function ( ) { createSelectionsPath ( options ) ; options . state . selected . push ( data ) ; } ) ; if ( angular . isFunction ( options . chart . data . onselected ) ) { AngularChartWatcher . applyFunction ( watcher , function ( ) { options . chart . data . onselected ( data , element ) ; } ) ; } } ; configuration . data . onunselected = function ( data , element ) { if ( service . disableSelectionListener ) { return ; } AngularChartWatcher . updateState ( watcher , function ( ) { createSelectionsPath ( options ) ; options . state . selected = options . state . selected . filter ( function ( selected ) { return selected . id !== data . id || selected . index !== data . index ; } ) ; } ) ; if ( angular . isFunction ( options . chart . data . onunselected ) ) { AngularChartWatcher . applyFunction ( watcher , function ( ) { options . chart . data . onunselected ( data , element ) ; } ) ; } } ; } }
1641	function setupDataSmallWatcher ( watcher ) { return watcher . scope . $watch ( 'options.data' , function ( ) { if ( angular . isFunction ( watcher . dataCallback ) ) { watcher . dataCallback ( ) ; } setupDataWatcher ( watcher ) ; } , true ) ; }
1642	function setupDataBigWatcher ( watcher ) { return watcher . scope . $watch ( function ( ) { if ( watcher . scope . options . data && angular . isArray ( watcher . scope . options . data ) ) { return watcher . scope . options . data . length ; } else { return 0 ; } } , function ( ) { if ( angular . isFunction ( watcher . dataCallback ) ) { watcher . dataCallback ( ) ; } setupDataWatcher ( watcher ) ; } ) ; }
1643	function addIdentifier ( ) { $scope . dataAttributeChartID = 'chartid' + Math . floor ( Math . random ( ) * 1000000001 ) ; angular . element ( $element ) . attr ( 'id' , $scope . dataAttributeChartID ) ; configuration . bindto = '#' + $scope . dataAttributeChartID ; }
1644	function loadEntity ( name , promise , options ) { if ( ! name || typeof name !== 'string' ) throw new Error ( 'Missing required entity name' ) ; if ( ! promise || ! promise . then ) throw new Error ( 'Missing required entity promise' ) ; try { ! ( 0 , _validateOptions . default ) ( options ) ; } catch ( error ) { throw error ; } var entityLifecycle = new _entityLifecycle . default ( name , options ) ; return function ( dispatch , getState ) { entityLifecycle . setDispatch ( dispatch ) ; entityLifecycle . setGetState ( getState ) ; entityLifecycle . onLoad ( ) ; return new Promise ( function ( resolve , reject ) { promise . then ( function ( data ) { resolve ( entityLifecycle . onSuccess ( data ) ) ; } ) . catch ( function ( error ) { reject ( entityLifecycle . onFailure ( error ) ) ; } ) ; } ) ; } ; }
1645	function generateAction ( action , keys , values ) { var generatedAction = Object . assign ( { } , action ) ; keys . forEach ( function ( arg , index ) { generatedAction [ keys [ index ] ] = values [ index ] ; } ) ; return generatedAction ; }
1646	function makeActionCreator ( type ) { for ( var _len = arguments . length , keys = new Array ( _len > 1 ? _len - 1 : 0 ) , _key = 1 ; _key < _len ; _key ++ ) { keys [ _key - 1 ] = arguments [ _key ] ; } if ( ! type ) throw new Error ( 'Type cannot be null/undefined' ) ; return function ( ) { for ( var _len2 = arguments . length , values = new Array ( _len2 ) , _key2 = 0 ; _key2 < _len2 ; _key2 ++ ) { values [ _key2 ] = arguments [ _key2 ] ; } return generateAction ( { type : type } , keys , values ) ; } ; }
1647	function _getRandomDelayBetween ( min , max , roundTo ) { return Number ( Math . random ( ) * ( max - min ) + min ) . toFixed ( roundTo ) ; }
1648	function _logDetails ( action ) { if ( action ) { console . log ( ` ${ chalk . white . bgRed ( ' Prev State:' ) } ${ __toString ( state ) } ` ) ; console . log ( ` ${ chalk . white . bgBlue ( ' Action:' ) } ${ __toString ( action ) } ` ) ; } else { console . log ( ` ${ chalk . white . bgGreen ( ' Next State:' ) } ${ __toString ( state ) } ` ) ; console . log ( '\n' ) ; } }
1649	function _removeSubscribers ( aSubscribers , oSubscriber ) { let nUnsubscribed = 0 ; if ( ! isTypeOf ( aSubscribers , sNotDefined ) ) { let nIndex = aSubscribers . length - 1 ; for ( ; nIndex >= 0 ; nIndex -- ) { if ( aSubscribers [ nIndex ] . subscriber === oSubscriber ) { nUnsubscribed ++ ; aSubscribers . splice ( nIndex , 1 ) ; } } } return nUnsubscribed ; }
1650	function _removeSubscribersPerEvent ( oEventsCallbacks , sChannelId , oSubscriber ) { let nUnsubscribed = 0 ; iterateObject ( oEventsCallbacks , function ( oItem , sEvent ) { const aEventsParts = sEvent . split ( ':' ) ; let sChannel = sChannelId ; let sEventType = sEvent ; if ( aEventsParts [ 0 ] === 'global' ) { sChannel = aEventsParts [ 0 ] ; sEventType = aEventsParts [ 1 ] ; } nUnsubscribed += _removeSubscribers ( oChannels [ sChannel ] [ sEventType ] , oSubscriber ) ; } ) ; return nUnsubscribed ; }
1651	function _addSubscribers ( oEventsCallbacks , sChannelId , oSubscriber ) { iterateObject ( oEventsCallbacks , function ( oItem , sEvent ) { subscribeTo ( sChannelId , sEvent , oItem , oSubscriber ) ; } ) ; }
1652	function _getChannelEvents ( sChannelId , sEvent ) { if ( oChannels [ sChannelId ] === und ) { oChannels [ sChannelId ] = { } ; } if ( oChannels [ sChannelId ] [ sEvent ] === und ) { oChannels [ sChannelId ] [ sEvent ] = [ ] ; } return oChannels [ sChannelId ] [ sEvent ] ; }
1653	function subscribersByEvent ( oChannel , sEventName ) { let aSubscribers = [ ] ; if ( ! isTypeOf ( oChannel , sNotDefined ) ) { iterateObject ( oChannel , function ( oItem , sKey ) { if ( sKey === sEventName ) { aSubscribers = oItem ; } } ) ; } return aSubscribers ; }
1654	function subscribeTo ( sChannelId , sEventType , fpHandler , oSubscriber ) { const aChannelEvents = _getChannelEvents ( sChannelId , sEventType ) ; aChannelEvents . push ( { subscriber : oSubscriber , handler : fpHandler } ) ; }
1655	function unsubscribeFrom ( sChannelId , sEventType , oSubscriber ) { const aChannelEvents = _getChannelEvents ( sChannelId , sEventType ) ; for ( let nEvent = aChannelEvents . length - 1 ; nEvent >= 0 ; nEvent -- ) { const oItem = aChannelEvents [ nEvent ] ; if ( oItem . subscriber === oSubscriber ) { aChannelEvents . splice ( nEvent , 1 ) ; } } }
1656	function subscribe ( oSubscriber ) { const oEventsCallbacks = oSubscriber . events ; if ( ! oSubscriber || oEventsCallbacks === und ) { return false ; } iterateObject ( oEventsCallbacks , function ( oItem , sChannelId ) { if ( oChannels [ sChannelId ] === und ) { oChannels [ sChannelId ] = { } ; } _addSubscribers ( oItem , sChannelId , oSubscriber ) ; } ) ; return true ; }
1657	function unsubscribe ( oSubscriber ) { let nUnsubscribed = 0 ; const oEventsCallbacks = oSubscriber . events ; if ( ! oSubscriber || oEventsCallbacks === und ) { return false ; } iterateObject ( oEventsCallbacks , function ( oItem , sChannelId ) { if ( oChannels [ sChannelId ] === und ) { oChannels [ sChannelId ] = { } ; } nUnsubscribed = _removeSubscribersPerEvent ( oItem , sChannelId , oSubscriber ) ; } ) ; return nUnsubscribed > 0 ; }
1658	function _executeHandler ( oHandlerObject , oData , sChannelId , sEvent ) { oHandlerObject . handler . call ( oHandlerObject . subscriber , oData ) ; if ( getDebug ( ) ) { const ErrorHandler = errorHandler ( ) ; ErrorHandler . log ( sChannelId , sEvent , oHandlerObject ) ; } }
1659	function publish ( sChannelId , sEvent , oData ) { const aSubscribers = copyArray ( this . subscribers ( sChannelId , sEvent ) ) ; let oSubscriber ; const nLenSubscribers = aSubscribers . length ; if ( nLenSubscribers === 0 ) { return false ; } oData = preprocessorsPublishData ( oData ) ; while ( ! ! ( oSubscriber = aSubscribers . shift ( ) ) ) { _executeHandler ( oSubscriber , oData , sChannelId , sEvent ) ; } return true ; }
1660	function resolveNamespace ( sNamespace ) { var oObj = root , aElements = sNamespace . split ( '.' ) , sElement ; while ( ! ! ( sElement = aElements . shift ( ) ) ) { oObj = oObj [ sElement ] !== und ? oObj [ sElement ] : oObj [ sElement ] = { } ; } return oObj ; }
1661	function getResolveDICallback ( oMapping ) { return function ( sDependency ) { var oPromise = getPromise ( ) ; if ( ! oMapping . __map__ [ sDependency ] ) { return false ; } oPromise . resolve ( oMapping . __map__ [ sDependency ] ) ; return oPromise ; } ; }
1662	function getPromiseCallbacks ( oContext , sType ) { return function ( ) { var aCompleted , nLenPromises , oDeferred , aPromises , nPromise , oPromise , aResults = [ ] ; oContext . bCompleted = true ; oContext . sType = sType ; oContext . oResult = arguments ; while ( oContext . aPending [ 0 ] ) { oContext . aPending . shift ( ) [ sType ] . apply ( oContext , arguments ) ; } oDeferred = oContext . oDeferred ; if ( oDeferred ) { aCompleted = [ ] ; aPromises = oDeferred . aPromises ; nLenPromises = aPromises . length ; aResults = [ ] ; for ( nPromise = 0 ; nPromise < nLenPromises ; nPromise ++ ) { oPromise = aPromises [ nPromise ] ; aCompleted . push ( Number ( oPromise . bCompleted ) ) ; aResults . push ( oPromise . oResult ) ; } if ( aCompleted . join ( '' ) . indexOf ( '0' ) === - 1 ) { oDeferred [ sType ] . apply ( oDeferred , aResults ) ; } } } ; }
1663	function ( fpSuccess , fpFailure ) { var oResult = this . oResult ; if ( this . bCompleted ) { if ( this . sType === 'resolve' ) { fpSuccess . apply ( fpSuccess , oResult ) ; } else { fpFailure . apply ( fpFailure , oResult ) ; } } else { this . aPending . push ( { resolve : fpSuccess , reject : fpFailure } ) ; } return this ; }
1664	function FakeModule ( sModuleId , fpCreator ) { if ( isTypeOf ( fpCreator , sNotDefined ) ) { throw new Error ( 'Something goes wrong!' ) ; } this . creator = fpCreator ; this . instances = { } ; this . sModuleId = sModuleId ; }
1665	function isJqueryObject ( oObj ) { var isJquery = false , $ = getRoot ( ) . jQuery ; if ( $ ) { isJquery = isInstanceOf ( oObj , $ ) ; } return isJquery ; }
1666	function isEvent ( oObj ) { try { return isInstanceOf ( oObj , Event ) ; } catch ( erError ) { if ( oObj . altKey !== und && ( oObj . srcElement || oObj . target ) ) { return true ; } } return false ; }
1667	function addPropertiesAndMethodsToModule ( sModuleId , aDependencies , fpCallback ) { var oPromise ; function success ( mapping ) { const oModules = getModules ( ) ; var oModule , fpInitProxy ; oModule = oModules [ sModuleId ] . creator . apply ( oModules [ sModuleId ] , [ ] . slice . call ( arguments , 1 ) ) ; oModule . __children__ = [ ] ; oModule . dependencies = aDependencies || [ ] . slice . call ( arguments , 1 ) ; oModule . resolvedDependencies = mapping ; oModule . __module_id__ = sModuleId ; fpInitProxy = oModule . init || nullFunc ; oModule . __action__ = oModule . __sandbox__ = Bus ; oModule . events = oModule . events || { } ; oModule . init = function ( ) { var aArgs = copyArray ( arguments ) . concat ( getVars ( ) ) ; if ( oModule . __children__ . length === 0 ) { Bus . subscribe ( oModule ) ; } return fpInitProxy . apply ( this , aArgs ) ; } ; oModule . handleAction = function ( oNotifier ) { var fpCallback = this . events [ oNotifier . type ] ; if ( isTypeOf ( fpCallback , sNotDefined ) ) { return ; } fpCallback . call ( this , oNotifier ) ; } ; oModule . onDestroy = oModule . onDestroy || oModule . destroy || function ( ) { } ; oModule . destroy = function ( ) { this . onDestroy ( ) ; Bus . unsubscribe ( oModule ) ; delete oModules [ sModuleId ] . instances [ oModule . __instance_id__ ] ; } ; fpCallback ( oModule ) ; } oPromise = resolveDependencies ( sModuleId , aDependencies ) ; oPromise . then ( function ( ) { success . apply ( success , arguments ) ; } ) ; }
1668	function wrapMethod ( oInstance , sName , sModuleId , fpMethod ) { oInstance [ sName ] = ( function ( sName , fpMethod ) { return function ( ) { var aArgs = copyArray ( arguments ) ; try { return fpMethod . apply ( this , aArgs ) ; } catch ( erError ) { const ErrorHandler = errorHandler ( ) ; ErrorHandler . error ( sModuleId , sName , erError ) ; return false ; } } ; } ( sName , fpMethod ) ) ; }
1669	function register ( sModuleId , aDependencies , fpCreator ) { const oModules = getModules ( ) ; if ( isFunction ( aDependencies ) ) { fpCreator = aDependencies ; aDependencies = [ '$$_bus' , '$$_module' , '$$_log' , 'gl_Hydra' ] ; } oModules [ sModuleId ] = new FakeModule ( sModuleId , fpCreator ) ; oModules [ sModuleId ] . dependencies = aDependencies ; return oModules [ sModuleId ] ; }
1670	function setInstance ( sModuleId , sIdInstance , oInstance ) { const oModules = getModules ( ) ; var oModule = oModules [ sModuleId ] ; if ( ! oModule ) { fpThrowErrorModuleNotRegistered ( sModuleId , true ) ; } oModule . instances [ sIdInstance ] = oInstance ; return oModule ; }
1671	function _multiModuleStart ( oInstance , aModulesIds , sIdInstance , oData , bSingle ) { var aInstancesIds , aData , aSingle , nIndex , nLenModules , sModuleId ; if ( isArray ( sIdInstance ) ) { aInstancesIds = copyArray ( sIdInstance ) ; } if ( isArray ( oData ) ) { aData = copyArray ( oData ) ; } if ( isArray ( bSingle ) ) { aSingle = copyArray ( bSingle ) ; } for ( nIndex = 0 , nLenModules = aModulesIds . length ; nIndex < nLenModules ; nIndex ++ ) { sModuleId = aModulesIds [ nIndex ] ; sIdInstance = aInstancesIds && aInstancesIds [ nIndex ] || generateUniqueKey ( ) ; oData = aData && aData [ nIndex ] || oData ; bSingle = aSingle && aSingle [ nIndex ] || bSingle ; startSingleModule ( oInstance , sModuleId , sIdInstance , oData , bSingle ) ; } }
1672	function beforeInit ( oInstance , oData , bSingle ) { iterateObject ( oModifyInit , function ( oMember ) { if ( oMember && isTypeOf ( oMember , sFunctionType ) ) { oMember ( oInstance , oData , bSingle ) ; } } ) ; }
1673	function startSingleModule ( oWrapper , sModuleId , sIdInstance , oData , bSingle ) { const oModules = getModules ( ) ; var oModule ; oModule = oModules [ sModuleId ] ; if ( ( bSingle && isModuleStarted ( sModuleId ) ) || isModuleStarted ( sModuleId , sIdInstance ) ) { oWrapper . stop ( sModuleId , sIdInstance ) ; } if ( ! isTypeOf ( oModule , sNotDefined ) ) { createInstance ( sModuleId , undefined , function ( oInstance ) { oModule . instances [ sIdInstance ] = oInstance ; oInstance . __instance_id__ = sIdInstance ; beforeInit ( oInstance , oData , bSingle ) ; if ( ! isTypeOf ( oData , sNotDefined ) ) { oInstance . init ( oData ) ; } else { oInstance . init ( ) ; } } ) ; } else { const ErrorHandler = errorHandler ( ) ; ErrorHandler . error ( new Error ( ) , fpThrowErrorModuleNotRegistered ( sModuleId ) ) ; } }
1674	function _singleModuleStart ( oInstance , sModuleId , sIdInstance , oData , bSingle ) { if ( ! isTypeOf ( sIdInstance , 'string' ) ) { bSingle = oData ; oData = sIdInstance ; sIdInstance = generateUniqueKey ( ) ; } startSingleModule ( oInstance , sModuleId , sIdInstance , oData , bSingle ) ; }
1675	function createInstance ( sModuleId , aDependencies , fpCallback ) { const oModules = getModules ( ) ; if ( isTypeOf ( oModules [ sModuleId ] , sNotDefined ) ) { fpThrowErrorModuleNotRegistered ( sModuleId , true ) ; } addPropertiesAndMethodsToModule ( sModuleId , aDependencies , function ( oInstance ) { if ( ! getDebug ( ) ) { iterateObject ( oInstance , function ( oItem , sName ) { if ( isFunction ( oItem ) ) { wrapMethod ( oInstance , sName , sModuleId , oInstance [ sName ] ) ; } } ) ; } fpCallback ( oInstance ) ; } ) ; }
1676	function getCallbackToSetObjectFromTemplate ( oMethodsObject , oPropertiesObject ) { return function ( oValue , sKey ) { if ( typeof oValue === 'function' ) { oMethodsObject [ sKey ] = getSimpleFunction ( oValue ) ; } else if ( isArray ( oValue ) ) { oPropertiesObject [ sKey ] = copyArray ( oValue ) ; } else if ( typeof oValue === 'object' && oValue !== null ) { oPropertiesObject [ sKey ] = simpleMerge ( { } , oValue ) ; } else if ( isInstanceOf ( oValue , Date ) ) { oPropertiesObject [ sKey ] = new Date ( ) ; oPropertiesObject [ sKey ] . setTime ( oValue . getTime ( ) ) ; } else { oPropertiesObject [ sKey ] = oValue ; } } ; }
1677	function startAll ( ) { const oModules = getModules ( ) ; iterateObject ( oModules , function ( _oModule , sModuleId ) { if ( ! isTypeOf ( _oModule , sNotDefined ) ) { start ( sModuleId , generateUniqueKey ( ) ) ; } } ) ; }
1678	function stop ( sModuleId , sInstanceId ) { const oModules = getModules ( ) ; var oModule ; oModule = oModules [ sModuleId ] ; if ( isTypeOf ( oModule , sNotDefined ) ) { return false ; } if ( ! isTypeOf ( sInstanceId , sNotDefined ) ) { _singleModuleStop ( oModule , sInstanceId ) ; } else { _multiModuleStop ( oModule ) ; } return true ; }
1679	function _multiModuleStop ( oModule ) { iterateObject ( oModule . instances , function ( oInstance ) { if ( ! isTypeOf ( oModule , sNotDefined ) && ! isTypeOf ( oInstance , sNotDefined ) ) { oInstance . destroy ( ) ; } } ) ; oModule . instances = { } ; }
1680	function _singleModuleStop ( oModule , sInstanceId ) { var oInstance = oModule . instances [ sInstanceId ] ; if ( ! isTypeOf ( oModule , sNotDefined ) && ! isTypeOf ( oInstance , sNotDefined ) ) { oInstance . destroy ( ) ; delete oModule . instances [ sInstanceId ] ; } }
1681	function stopAll ( ) { const oModules = getModules ( ) ; iterateObject ( oModules , function ( _oModule , sModuleId ) { if ( ! isTypeOf ( _oModule , sNotDefined ) ) { _stopOneByOne ( _oModule , sModuleId ) ; } } ) ; }
1682	function _stopOneByOne ( oModule , sModuleId ) { iterateObject ( oModule . instances , function ( oItem , sInstanceId ) { stop ( sModuleId , sInstanceId ) ; } ) ; }
1683	function remove ( sModuleId ) { const oModules = getModules ( ) ; var oModule = oModules [ sModuleId ] ; if ( isTypeOf ( oModule , sNotDefined ) ) { return null ; } if ( ! isTypeOf ( oModule , sNotDefined ) ) { try { return Module ; } finally { _delete ( sModuleId ) ; createMapping ( getMappingMaps ( ) , 'hm_' , oModules ) ; } } return null ; }
1684	function _delete ( sModuleId ) { const oModules = getModules ( ) ; if ( ! isTypeOf ( oModules [ sModuleId ] , sNotDefined ) ) { delete oModules [ sModuleId ] ; return true ; } return false ; }
1685	function main ( ) { return __awaiter ( this , void 0 , void 0 , function ( ) { var outputDataSize , interval , dataFrame , dateFormat , api ; return __generator ( this , function ( _a ) { switch ( _a . label ) { case 0 : outputDataSize = "compact" ; if ( argv . outputDataSize ) { outputDataSize = argv . outputDataSize ; } interval = '60min' ; if ( argv . interval ) { interval = argv . interval ; } api = new index_1 . AlphaVantageAPI ( argv . apiKey , outputDataSize , argv . verbose ) ; if ( ! ( argv . type === 'daily' ) ) return [ 3 , 2 ] ; return [ 4 , api . getDailyDataFrame ( argv . symbol ) ] ; case 1 : dataFrame = _a . sent ( ) ; dateFormat = 'YYYY-MM-DD' ; return [ 3 , 5 ] ; case 2 : if ( ! ( argv . type === 'intraday' ) ) return [ 3 , 4 ] ; return [ 4 , api . getIntradayDataFrame ( argv . symbol , interval ) ] ; case 3 : dataFrame = _a . sent ( ) ; dateFormat = "YYYY-MM-DD HH:mm:ss" ; return [ 3 , 5 ] ; case 4 : throw new Error ( "Unexpected data type: " + argv . type + ", expected it to be either 'daily' or 'intrday'" ) ; case 5 : if ( ! argv . verbose ) { console . log ( '>> ' + argv . out ) ; } dataFrame . transformSeries ( { Timestamp : function ( t ) { return moment ( t ) . format ( dateFormat ) ; } , } ) . asCSV ( ) . writeFileSync ( argv . out ) ; return [ 2 ] ; } } ) ; } ) ; }
1686	function ( val ) { var valueInPicker = this . options . itemProperty ? this . pickerValue [ this . options . itemProperty ] : this . pickerValue ; return ( val ? val : valueInPicker ) ; }
1687	function ( val ) { val = this . setValue ( val ) ; if ( ( val !== false ) && ( val !== '' ) ) { if ( this . hasInput ( ) ) { this . input . val ( this . getValue ( ) ) ; } else { this . element . data ( 'pickerValue' , this . getValue ( ) ) ; } this . _trigger ( 'pickerSetSourceValue' , { pickerValue : val } ) ; } return val ; }
1688	function ( defaultValue ) { defaultValue = defaultValue || this . options . defaultValue ; var val = defaultValue ; if ( this . hasInput ( ) ) { val = this . input . val ( ) ; } else { val = this . element . data ( 'pickerValue' ) ; val = this . options . itemProperty ? val [ this . options . itemProperty ] : val ; } if ( ( val === undefined ) || ( val === '' ) || ( val === null ) || ( val === false ) ) { val = defaultValue ; } return val ; }
1689	function createMarkdownSerializer ( indentCodeBlocks ) { return { serialize : ( name , suite ) => snapshotToMarkdown ( name , suite , indentCodeBlocks ) , deserialize : markdownToSnapshot , } ; }
1690	function markdownToSnapshot ( content ) { const tree = mdParser . parse ( content ) ; const state = { name : null , suite : null , suiteStack : [ ] , currentSuite : null , currentSnapshotList : null , depth : 0 } ; const children = tree . children ; for ( let i = 0 ; i < children . length ; i ++ ) { const c = children [ i ] ; switch ( c . type ) { case 'heading' : if ( c . depth === 1 ) { enterRootSuite ( state , c ) ; } else if ( c . depth === 2 ) { tryExit ( state , suiteDepth ( c ) ) ; enterSuite ( state , c ) ; } else if ( c . depth === 4 ) { enterSnapshot ( state , c ) ; } break ; case 'code' : pushSnapshotCode ( state , c ) ; break ; } } return { name : state . name , suite : state . suite } ; }
1691	function tryExit ( state , depth ) { while ( state . depth >= depth ) { state . suiteStack . pop ( ) ; state . currentSuite = state . suiteStack [ state . suiteStack . length - 1 ] ; state . currentSnapshotList = null ; state . depth -- ; } }
1692	function enterRootSuite ( state , node ) { const inlineCode = node . children [ 0 ] ; const name = inlineCode . value ; const suite = { children : { } , snapshots : { } } state . name = name ; state . suite = suite ; state . suiteStack . push ( suite ) ; state . currentSuite = suite ; state . currentSnapshotList = null ; state . depth = 0 ; }
1693	function enterSnapshot ( state , node ) { const inlineCode = node . children [ 0 ] ; const name = inlineCode . value ; const snapshotList = [ ] ; state . currentSuite . snapshots [ name ] = snapshotList ; state . currentSnapshotList = snapshotList ; }
1694	function pushSnapshotCode ( state , node ) { state . currentSnapshotList . push ( { lang : node . lang , code : normalizeNewlines ( node . value ) } ) ; }
1695	function transformSuite ( name , suite , depth , indentCodeBlocks ) { const children = suite . children ; const snapshots = suite . snapshots ; const nextDepth = depth + 1 ; let result = suiteHeader ( name , depth ) ; let keys , i ; keys = Object . keys ( snapshots ) ; for ( i = 0 ; i < keys . length ; i ++ ) { const key = keys [ i ] ; const snapshotList = snapshots [ key ] ; result += transformSnapshotList ( key , snapshotList , nextDepth , indentCodeBlocks ) ; } keys = Object . keys ( children ) ; for ( i = 0 ; i < keys . length ; i ++ ) { const key = keys [ i ] ; result += transformSuite ( key , children [ key ] , nextDepth , indentCodeBlocks ) ; } return result ; }
1696	function transformSnapshotList ( name , snapshotList , depth , indentCodeBlocks ) { let result = snapshotHeader ( name , depth ) ; for ( let i = 0 ; i < snapshotList . length ; i ++ ) { if ( i > 0 && indentCodeBlocks ) { result += '---\n\n' ; } \n \n const snapshot = snapshotList [ i ] ; const lang = snapshot . lang ; const code = snapshot . code ; const delimiter = safeDelimiter ( code ) ; } if ( indentCodeBlocks ) { const lines = code . split ( '\n' ) ; \n } else for ( let i = 0 ; i < lines . length ; i ++ ) { result += ' ' + lines [ i ] + '\n' ; } }
1697	function suiteHeader ( name , depth ) { if ( depth === - 1 ) { return "# " + serializeName ( name ) + "\n\n" ; } \n }
1698	function safeDelimiter ( s , delimiter ) { if ( delimiter === undefined ) { delimiter = '```' ; } while ( s . indexOf ( delimiter ) !== - 1 ) { delimiter += '`' ; } return delimiter ; }
1699	function defaultPathResolver ( basePath , suiteName ) { const suiteSourcePath = path . join ( basePath , suiteName ) ; const suiteSourceDir = path . dirname ( suiteSourcePath ) ; const sourceFileName = path . basename ( suiteName ) ; return path . join ( suiteSourceDir , "__snapshots__" , sourceFileName + ".md" ) ; }
1700	function formatSnapshotList ( list , limit ) { limit = ( typeof limit != 'undefined' ) ? limit : - 1 ; const limitedList = limit > 0 ? list . slice ( 0 , limit ) : list ; const hasMore = list . length > limitedList . length ; const buildList = ( snapshots ) => snapshots . map ( ( s ) => s . join ( ' > ' ) ) . join ( '\n' ) ; \n if ( hasMore ) { return buildList ( limitedList . slice ( 0 , - 1 ) ) + ` \n ${ list . length - limitedList . length + 1 } ` ; } }
1701	function formatUnusedSnapshotsWarning ( list , limit ) { if ( limit == 0 ) { return ` ${ list . length } ` ; } const prunedList = formatSnapshotList ( list , limit ) ; return ` ${ list . length } \n ${ prunedList } ` ; }
1702	function snapshotPreprocessor ( basePath , loggerFactory ) { const logger = loggerFactory . create ( 'preprocessor.snapshot' ) ; return function ( content , file , done ) { const root = snapshotSerializer . deserialize ( content ) ; done ( iifeWrapper ( 'window.__snapshot__.addSuite("' + root . name + '",' + JSON . stringify ( root . suite ) + ');' ) ) ; } ; }
1703	function singleLinePlugin ( options = { } ) { options = Object . assign ( { } , defaultOptions , options ) return { blockRenderMap : Map ( { 'unstyled' : { element : 'div' , } , } ) , onChange ( editorState ) { const blocks = editorState . getCurrentContent ( ) . getBlocksAsArray ( ) if ( blocks . length > 1 ) { editorState = condenseBlocks ( editorState , blocks , options ) } else { let contentBlock = blocks [ 0 ] let text = contentBlock . getText ( ) let characterList = contentBlock . getCharacterList ( ) let hasEntitiesToStrip = options . stripEntities && characterListhasEntities ( characterList ) if ( NEWLINE_REGEX . test ( text ) || hasEntitiesToStrip ) { text = replaceNewlines ( text ) if ( options . stripEntities ) { characterList = characterList . map ( stripEntityFromCharacterMetadata ) } contentBlock = new ContentBlock ( { key : genKey ( ) , text : text , type : 'unstyled' , characterList : characterList , depth : 0 , } ) const newContentState = ContentState . createFromBlockArray ( [ contentBlock ] ) editorState = EditorState . push ( editorState , newContentState , 'insert-characters' ) } } return editorState } , handleReturn ( e ) { return 'handled' } , } }
1704	function replaceNewlines ( str ) { var replacement = arguments . length <= 1 || arguments [ 1 ] === undefined ? ' ' : arguments [ 1 ] ; return str . replace ( NEWLINE_REGEX , replacement ) ; }
1705	function condenseBlocks ( editorState , blocks , options ) { blocks = blocks || editorState . getCurrentContent ( ) . getBlocksAsArray ( ) ; var text = ( 0 , _immutable . List ) ( ) ; var characterList = ( 0 , _immutable . List ) ( ) ; blocks . forEach ( function ( block ) { if ( block . getType ( ) !== 'atomic' ) { text = text . push ( replaceNewlines ( block . getText ( ) ) ) ; characterList = characterList . concat ( block . getCharacterList ( ) ) ; } } ) ; if ( options . stripEntities ) { characterList = characterList . map ( stripEntityFromCharacterMetadata ) ; } var contentBlock = new _draftJs . ContentBlock ( { key : ( 0 , _draftJs . genKey ) ( ) , text : text . join ( '' ) , type : 'unstyled' , characterList : characterList , depth : 0 } ) ; var newContentState = _draftJs . ContentState . createFromBlockArray ( [ contentBlock ] ) ; editorState = _draftJs . EditorState . push ( editorState , newContentState , 'remove-range' ) ; return _draftJs . EditorState . moveFocusToEnd ( editorState ) ; }
1706	function characterListhasEntities ( characterList ) { var hasEntities = false ; characterList . forEach ( function ( characterMeta ) { if ( characterMeta . get ( 'entity' ) !== null ) { hasEntities = true ; } } ) ; return hasEntities ; }
1707	function hexRgb ( hex ) { let shorthandCheck = / ^([a-f\d])([a-f\d])([a-f\d])$ / i , rgbRegex = / ^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$ / i , rgb ; hex = hex . replace ( shorthandCheck , function ( m , r , g , b ) { return r + r + g + g + b + b ; } ) ; rgb = hex . replace ( / ^\s+|\s+$ / g , '' ) . match ( rgbRegex ) ; return rgb ? [ parseInt ( rgb [ 1 ] , 16 ) , parseInt ( rgb [ 2 ] , 16 ) , parseInt ( rgb [ 3 ] , 16 ) ] : false ; }
1708	function ruleHandler ( decl , result ) { let input = decl . value ; let output = input . replace ( / rgba\(#(.*?), / g , ( match , hex ) => { let rgb = hexRgb ( hex ) , matchHex = new RegExp ( '#' + hex ) ; if ( ! rgb ) { result . warn ( 'not a valid hex' , { node : decl } ) ; return match ; } rgb = rgb . toString ( ) ; return match . replace ( matchHex , rgb ) ; } ) ; decl . replaceWith ( { prop : decl . prop , value : output , important : decl . important } ) ; }
1709	function ( ) { for ( var i = 0 ; i < this . config . methods . length ; i ++ ) { var key = this . config . methods [ i ] ; if ( ! analytics [ key ] ) { analytics [ key ] = analytics . factory ( key ) ; } this [ key ] = this . factory ( key ) ; } }
1710	function debug ( namespace ) { function disabled ( ) { } disabled . enabled = false ; function enabled ( ) { var self = enabled ; var curr = + new Date ( ) ; var ms = curr - ( prevTime || curr ) ; self . diff = ms ; self . prev = prevTime ; self . curr = curr ; prevTime = curr ; if ( null == self . useColors ) self . useColors = exports . useColors ( ) ; if ( null == self . color && self . useColors ) self . color = selectColor ( ) ; var args = new Array ( arguments . length ) ; for ( var i = 0 ; i < args . length ; i ++ ) { args [ i ] = arguments [ i ] ; } args [ 0 ] = exports . coerce ( args [ 0 ] ) ; if ( 'string' !== typeof args [ 0 ] ) { args = [ '%o' ] . concat ( args ) ; } var index = 0 ; args [ 0 ] = args [ 0 ] . replace ( / %([a-z%]) / g , function ( match , format ) { if ( match === '%%' ) return match ; index ++ ; var formatter = exports . formatters [ format ] ; if ( 'function' === typeof formatter ) { var val = args [ index ] ; match = formatter . call ( self , val ) ; args . splice ( index , 1 ) ; index -- ; } return match ; } ) ; args = exports . formatArgs . apply ( self , args ) ; var logFn = enabled . log || exports . log || console . log . bind ( console ) ; logFn . apply ( self , args ) ; } enabled . enabled = true ; var fn = exports . enabled ( namespace ) ? enabled : disabled ; fn . namespace = namespace ; return fn ; }
1711	function isBuf$1 ( obj ) { return ( commonjsGlobal . Buffer && commonjsGlobal . Buffer . isBuffer ( obj ) ) || ( commonjsGlobal . ArrayBuffer && obj instanceof ArrayBuffer ) ; }
1712	function encode$1 ( num ) { var encoded = '' ; do { encoded = alphabet [ num % length ] + encoded ; num = Math . floor ( num / length ) ; } while ( num > 0 ) ; return encoded ; }
1713	function decode$1 ( str ) { var decoded = 0 ; for ( i = 0 ; i < str . length ; i ++ ) { decoded = decoded * length + map [ str . charAt ( i ) ] ; } return decoded ; }
1714	function Polling$1 ( opts ) { var forceBase64 = ( opts && opts . forceBase64 ) ; if ( ! hasXHR2 || forceBase64 ) { this . supportsBinary = false ; } Transport . call ( this , opts ) ; }
1715	function onupgrade ( to ) { if ( transport$$1 && to . name !== transport$$1 . name ) { debug$2 ( '"%s" works - aborting "%s"' , to . name , transport$$1 . name ) ; freezeTransport ( ) ; } }
1716	function cleanup ( ) { transport$$1 . removeListener ( 'open' , onTransportOpen ) ; transport$$1 . removeListener ( 'error' , onerror ) ; transport$$1 . removeListener ( 'close' , onTransportClose ) ; self . removeListener ( 'close' , onclose ) ; self . removeListener ( 'upgrading' , onupgrade ) ; }
1717	function Backoff$1 ( opts ) { opts = opts || { } ; this . ms = opts . min || 100 ; this . max = opts . max || 10000 ; this . factor = opts . factor || 2 ; this . jitter = opts . jitter > 0 && opts . jitter <= 1 ? opts . jitter : 0 ; this . attempts = 0 ; }
1718	function extract ( str , options ) { const res = babylon . parse ( str , options ) ; return res . comments ; }
1719	function bindNgModelControls ( api ) { ngModel . $render = ( ) => { api . set ( ngModel . $modelValue ) ; } ; api . on ( 'update' , ( ) => { const positions = api . get ( ) ; ngModel . $setViewValue ( positions ) ; } ) ; }
1720	function createInstance ( ) { const api = extendApi ( noUiSlider . create ( htmlElement , options ) ) ; setCreatedWatcher ( api ) ; setOptionsWatcher ( api ) ; if ( ngModel !== null ) { bindNgModelControls ( api ) ; } }
1721	function ( w ) { let vow = / [aeiouy]$ / ; let chars = w . split ( '' ) ; let before = '' ; let after = '' ; let current = '' ; for ( let i = 0 ; i < chars . length ; i ++ ) { before = chars . slice ( 0 , i ) . join ( '' ) ; current = chars [ i ] ; after = chars . slice ( i + 1 , chars . length ) . join ( '' ) ; let candidate = before + chars [ i ] ; if ( before . match ( ends_with_vowel ) && ! current . match ( ends_with_vowel ) ) { if ( after . match ( starts_with_e_then_specials ) ) { candidate += 'e' ; after = after . replace ( starts_with_e , '' ) ; } all . push ( candidate ) ; return doer ( after ) ; } if ( candidate . match ( ends_with_noisy_vowel_combos ) ) { all . push ( before ) ; all . push ( current ) ; return doer ( after ) ; } if ( candidate . match ( ends_with_vowel ) && after . match ( starts_with_consonant_vowel ) ) { all . push ( candidate ) ; return doer ( after ) ; } } if ( str . match ( aiouy ) || str . match ( ends_with_ee ) ) { all . push ( w ) ; } else { all [ all . length - 1 ] = ( all [ all . length - 1 ] || '' ) + w ; } return null ; }
1722	function addApi ( self , apiName , api ) { for ( var name in api ) { var fn = api [ name ] ; if ( typeof fn === "function" ) api [ name ] = api [ name ] . bind ( self ) ; } var tmp = null ; api . replied = new Promise ( ( resolve , reject ) => { tmp = { resolve , reject } ; } ) ; api . replied . resolve = tmp . resolve ; api . replied . reject = tmp . reject ; self [ apiName ] = api ; }
1723	function getJson ( path ) { return httpGet ( { hostname : t . options . remoteClientHostname , port : t . options . remoteClientPort , path : path , method : 'GET' } ) . then ( ( obj ) => { var contentType = getContentType ( obj . response ) ; if ( contentType !== "application/json" ) LOG . warn ( "Expecting JSON from " + path + " but found wrong content type: " + contentType ) ; try { return JSON . parse ( obj . data ) ; } catch ( ex ) { LOG . warn ( "Cannot parse JSON returned from " + path ) ; return null ; } } ) ; }
1724	function splitName ( method ) { var pos = method . indexOf ( '.' ) ; if ( pos < 0 ) return [ null , method ] ; var domainName = method . substring ( 0 , pos ) ; var methodName = method . substring ( pos + 1 ) ; return [ domainName , methodName ] ; }
1725	function copyToClient ( req , res ) { return httpGet ( { hostname : t . options . remoteClientHostname , port : t . options . remoteClientPort , path : req . originalUrl , method : 'GET' } ) . then ( function ( obj ) { var contentType = getContentType ( obj . response ) ; if ( contentType ) res . set ( "Content-Type" , contentType ) ; res . send ( obj . data ) ; } ) ; }
1726	function ( ) { const origPrepareStackTrace = Error . prepareStackTrace Error . prepareStackTrace = ( _ , stack ) => stack const err = new Error ( ) const stack = err . stack Error . prepareStackTrace = origPrepareStackTrace stack . shift ( ) return stack }
1727	function captureStdio ( opts , exec ) { var streams = [ process . stdout , process . stderr ] ; var outputs = capture ( streams , opts , exec ) ; return { stdout : outputs . shift ( ) , stderr : outputs . shift ( ) } ; }
1728	function hook ( stream , opts , exec ) { var args = _shift ( opts , exec ) ; opts = args [ 0 ] ; exec = args [ 1 ] ; var old_write = stream . write ; stream . write = ( function override ( stream , writer ) { return function write ( string , encoding , fd ) { exec ( string , encoding , fd ) ; if ( ! opts [ 'quiet' ] ) { writer . apply ( stream , [ string , encoding , fd ] ) ; } } } ) ( stream , stream . write ) ; return function unhook ( ) { stream . write = old_write ; return true ; } }
1729	function startCapture ( stream , opts , exec ) { var unhook = hook ( stream , opts , exec ) ; var str_id = random . generate ( ) ; unhooks [ str_id ] = unhook ; stream . _id = str_id ; return true ; }
1730	function _wrapIntercept ( func , stream , opts , exec ) { var idex = Number ( arguments . length > 3 ) ; var args = _shift ( arguments [ idex + 1 ] , arguments [ idex + 2 ] ) ; opts = args [ 0 ] ; exec = args [ 1 ] ; opts . quiet = true ; return idex ? func ( stream , opts , exec ) : func ( opts , exec ) ; }
1731	function getNearest ( $select , value ) { var delta = { } ; $select . children ( 'option' ) . each ( function ( i , opt ) { var optValue = $ ( opt ) . attr ( 'value' ) , distance ; if ( optValue === '' ) return ; distance = Math . abs ( optValue - value ) ; if ( typeof delta . distance === 'undefined' || distance < delta . distance ) { delta = { value : optValue , distance : distance } ; } } ) ; return delta . value ; }
1732	function evenRound ( x ) { if ( ( x > 0 && ( x % 1 ) === + 0.5 && ( x & 1 ) === 0 ) || ( x < 0 && ( x % 1 ) === - 0.5 && ( x & 1 ) === 1 ) ) { return censorNegativeZero ( Math . floor ( x ) ) ; } return censorNegativeZero ( Math . round ( x ) ) ; }
1733	function addFrameAt ( time , value , delay , array ) { array . push ( { time : time , value : value , delay : delay } ) ; }
1734	function sentiment ( options ) { return transformer function transformer ( node ) { var concatenate = concatenateFactory ( ) visit ( node , any ( options ) ) visit ( node , concatenate ) concatenate . done ( ) } }
1735	function concatenateFactory ( ) { var queue = [ ] concatenate . done = done return concatenate function concatenate ( node , index , parent ) { if ( parent && parent . type !== 'WordNode' && queue . indexOf ( parent ) === - 1 ) { queue . push ( parent ) } } function one ( node ) { var children = node . children var length = children . length var polarity = 0 var index = - 1 var child var hasNegation while ( ++ index < length ) { child = children [ index ] if ( child . data && child . data . polarity ) { polarity += ( hasNegation ? - 1 : 1 ) * child . data . polarity } if ( child . type === 'WordNode' ) { if ( hasNegation ) { hasNegation = false } else if ( isNegation ( child ) ) { hasNegation = true } } } patch ( node , polarity ) } function done ( ) { var length = queue . length var index = - 1 queue . reverse ( ) while ( ++ index < length ) { one ( queue [ index ] ) } } }
1736	function one ( node ) { var children = node . children var length = children . length var polarity = 0 var index = - 1 var child var hasNegation while ( ++ index < length ) { child = children [ index ] if ( child . data && child . data . polarity ) { polarity += ( hasNegation ? - 1 : 1 ) * child . data . polarity } if ( child . type === 'WordNode' ) { if ( hasNegation ) { hasNegation = false } else if ( isNegation ( child ) ) { hasNegation = true } } } patch ( node , polarity ) }
1737	function done ( ) { var length = queue . length var index = - 1 queue . reverse ( ) while ( ++ index < length ) { one ( queue [ index ] ) } }
1738	function any ( config ) { return setter function setter ( node ) { var value var polarity if ( 'value' in node || node . type === 'WordNode' ) { value = nlcstToString ( node ) if ( config && own . call ( config , value ) ) { polarity = config [ value ] } else if ( own . call ( polarities , value ) ) { polarity = polarities [ value ] } if ( polarity ) { patch ( node , polarity ) } } } }
1739	function patch ( node , polarity ) { var data = node . data || { } data . polarity = polarity || 0 data . valence = classify ( polarity ) node . data = data }
1740	function fire ( event , target , listener ) { var returned , oldData ; if ( listener . d !== null ) { oldData = event . data ; event . data = listener . d ; returned = listener . h . call ( target , event , target ) ; event . data = oldData ; } else { returned = listener . h . call ( target , event , target ) ; } return returned ; }
1741	function Delegate ( root ) { var that = this , listenerList = { } ; if ( typeof root === 'string' ) { root = document . querySelector ( root ) ; } if ( ! root || ! root . addEventListener ) { throw new TypeError ( 'Root node not specified' ) ; } this . on = function ( ) { Array . prototype . unshift . call ( arguments , that , listenerList , root ) ; on . apply ( that , arguments ) ; return this ; } ; this . off = function ( ) { Array . prototype . unshift . call ( arguments , that , listenerList , root ) ; off . apply ( that , arguments ) ; return this ; } ; this . handle = function ( event ) { handle . call ( that , listenerList , root , event ) ; } ; }
1742	function fm ( options ) { var Module = fm . modules [ options . module ] ; if ( Module ) { return new Module ( options ) ; } throw new Error ( "Unable to find module '" + options . module + "'" ) ; }
1743	function ( structure = [ ] ) { return new Promise ( ( resolve , reject ) => { if ( Array . isArray ( structure ) === false ) { throw new Error ( ` ` ) } parseStructure ( structure , opts . cwd ) . then ( ( parsedStructure ) => writeStructure ( parsedStructure ) ) . then ( ( parsedStructure ) => binStructure ( parsedStructure , bin , opts . persistent ) ) . then ( resolve , reject ) } ) }
1744	function addAndWhereDate ( queryBuilder , column , from , to ) { if ( from && to ) { queryBuilder . whereBetween ( column , [ from , to ] ) ; } else if ( from ) { queryBuilder . andWhere ( column , '>=' , from ) ; } else if ( to ) { queryBuilder . andWhere ( column , '<=' , to ) ; } }
1745	function _handleMultiValuedParameters ( knexBuilder , attrName , parameter ) { if ( parameter instanceof Set ) { knexBuilder = knexBuilder . whereIn ( attrName , Array . from ( parameter ) ) ; } else if ( Array . isArray ( parameter ) ) { knexBuilder = knexBuilder . whereIn ( attrName , parameter ) ; } else { knexBuilder = knexBuilder . where ( attrName , parameter ) ; } return knexBuilder ; }
1746	function getKnexInstance ( config , registry = _registry , logger = console ) { validate . notNil ( config , 'Config is null or undefined' ) ; validate . notNil ( config . client , 'DB client is null or undefined' ) ; const { host , database , user } = config . connection ; const connectionTimeout = config . acquireConnectionTimeout ; logger . info ( ` ${ user } ${ host } ${ database } ` ) ; logger . info ( ` ${ connectionTimeout } ` ) ; const knex = module . exports . _initKnexInstance ( config ) ; module . exports . registerKnexInstance ( knex , registry ) ; return knex ; }
1747	function closeAllInstances ( registry = _registry ) { const promises = [ ] ; const errors = [ ] ; while ( registry . length > 0 ) { const knex = registry . pop ( ) ; const destructionPromise = knex . destroy ( ) . catch ( e => { errors . push ( { knex , cause : e } ) ; } ) ; promises . push ( destructionPromise ) ; } return Promise . all ( promises ) . then ( ( ) => { return errors ; } ) ; }
1748	function remarkHljs ( { aliases } ) { return ast => visit ( ast , 'code' , node => { if ( ! node . data ) { node . data = { } ; } const lang = node . lang ; const highlighted = lang ? low . highlight ( aliases [ lang ] || lang , node . value ) . value : low . highlightAuto ( node . value ) . value ; node . data . hChildren = highlighted ; node . data . hProperties = { className : [ 'hljs' , lang && ` ${ lang } ` ] , } ; } ) ; }
1749	function render ( processor , source ) { try { return processor . processSync ( source ) . contents ; } catch ( exception ) { const error = ` ${ exception . message } ` ; console . error ( error ) ; return errorInlineHtml ( error ) . toString ( ) ; } }
1750	function createColorArrow ( defElement , color ) { defElement . append ( "marker" ) . attr ( "id" , "arrow-" + color ) . attr ( "viewBox" , "0 -5 10 10" ) . attr ( "refX" , 8 ) . attr ( "markerWidth" , 6 ) . attr ( "markerHeight" , 6 ) . attr ( "fill" , color ) . attr ( "orient" , "auto" ) . append ( "path" ) . attr ( "d" , "M0,-5L10,0L0,5" ) . attr ( "class" , "arrowHead" ) ; }
1751	function valueParserNodesLength ( length , operator = '===' ) { return t . binaryExpression ( operator , valueParserASTNodesLength , t . numericLiteral ( length ) ) ; }
1752	function sliceThen ( file , offset , len ) { var p = new Promise ( function ( _resolve ) { fs . open ( file , 'r' , function ( err , fd ) { if ( err ) { throw err ; } var res = new Buffer ( len ) ; fs . read ( fd , res , 0 , len , offset , function ( err , bytesRead , buffer ) { if ( err ) { throw err ; } _resolve ( buffer ) ; } ) ; } ) ; } ) ; p . exec = function ( proc ) { var args = Array . prototype . slice . call ( arguments , 1 ) ; return p . then ( function ( data ) { args . unshift ( data ) ; var ret = proc . apply ( null , args ) ; return resolve ( ret !== UNDEFINED && ret . _spreadus_ ? ret : [ ret ] ) ; } ) ; } ; return p ; }
1753	function harvest ( outcomes ) { return Promise . settle ( outcomes ) . then ( function ( results ) { if ( results . length === 0 ) { return reject ( "** NOT FOUND **" ) ; } var solved = [ ] , failed = [ ] ; for ( var i = 0 ; i < results . length ; i ++ ) { if ( results [ i ] . isResolved ( ) ) { solved . push ( results [ i ] . value ( ) ) ; } else { failed . push ( results [ i ] . reason ( ) ) ; } } return solved . length ? solved : failed ; } ) ; }
1754	function ( keyAt ) { var hi = ( arr . length >> 1 ) - 1 , lo = 0 , i = ( lo + hi ) >> 1 , val = arr [ ( i << 1 ) + 1 ] ; if ( keyAt > arr [ ( hi << 1 ) + 1 ] || keyAt < 0 ) { return ; } while ( true ) { if ( hi - lo <= 1 ) { if ( i < hi ) { return { block_no : i , comp_offset : arr [ i <<= 1 ] , comp_size : arr [ i + 2 ] - arr [ i ] , decomp_offset : arr [ i + 1 ] , decomp_size : arr [ i + 3 ] - arr [ i + 1 ] } ; } else { return ; } } ( keyAt < val ) ? hi = i : lo = i ; i = ( lo + hi ) >> 1 ; val = arr [ ( i << 1 ) + 1 ] ; } }
1755	function ( len ) { len *= _bpu ; var read = conseq ( _decoder . decode ( newUint8Array ( buf , offset , len ) ) , this . forward ( len + _tail ) ) ; return read ; }
1756	function ( len ) { return conseq ( newUint8Array ( buf , offset , len ) , this . forward ( len === UNDEFINED ? buf . length - offset : len ) ) ; }
1757	function read_header_sect ( input , len ) { var scanner = Scanner ( input ) , header_str = scanner . readUTF16 ( len ) . replace ( / \0$ / , '' ) ; var doc = new DOMParser ( ) . parseFromString ( header_str , 'text/xml' ) ; var elem = doc . getElementsByTagName ( 'Dictionary' ) [ 0 ] ; if ( ! elem ) { elem = doc . getElementsByTagName ( 'Library_Data' ) [ 0 ] ; } for ( var i = 0 , item ; i < elem . attributes . length ; i ++ ) { item = elem . attributes [ i ] ; attrs [ item . nodeName ] = item . nodeValue ; } attrs . Encrypted = parseInt ( attrs . Encrypted , 10 ) || 0 ; config ( ) ; return spreadus ( len + 4 , input ) ; }
1758	function read_keyword_summary ( input , offset ) { var scanner = Scanner ( input ) ; scanner . forward ( offset ) ; return { num_blocks : scanner . readNum ( ) , num_entries : scanner . readNum ( ) , key_index_decomp_len : _v2 && scanner . readNum ( ) , key_index_comp_len : scanner . readNum ( ) , key_blocks_len : scanner . readNum ( ) , chksum : scanner . checksum_v2 ( ) , len : scanner . offset ( ) - offset , } ; }
1759	function read_keyword_index ( input , keyword_summary ) { var scanner = Scanner ( input ) . readBlock ( keyword_summary . key_index_comp_len , keyword_summary . key_index_decomp_len , _decryptors [ 1 ] ) , keyword_index = Array ( keyword_summary . num_blocks ) , offset = 0 ; for ( var i = 0 , size ; i < keyword_summary . num_blocks ; i ++ ) { keyword_index [ i ] = { num_entries : conseq ( scanner . readNum ( ) , size = scanner . readShort ( ) ) , first_word : conseq ( scanner . readTextSized ( size ) , size = scanner . readShort ( ) ) , last_word : scanner . readTextSized ( size ) , comp_size : size = scanner . readNum ( ) , decomp_size : scanner . readNum ( ) , offset : offset , index : i } ; offset += size ; } return spreadus ( keyword_summary , keyword_index ) ; }
1760	function read_key_block ( scanner , kdx ) { var scanner = scanner . readBlock ( kdx . comp_size , kdx . decomp_size ) ; for ( var i = 0 ; i < kdx . num_entries ; i ++ ) { var kk = [ scanner . readNum ( ) , scanner . readText ( ) ] ; } }
1761	function willScanKeyTable ( slicedKeyBlock , num_entries , keyword_index , delay ) { slicedKeyBlock . delay ( delay ) . then ( function ( input ) { var scanner = Scanner ( input ) ; for ( var i = 0 , size = keyword_index . length ; i < size ; i ++ ) { read_key_block ( scanner , keyword_index [ i ] ) ; } } ) ; }
1762	function read_record_summary ( input , pos ) { var scanner = Scanner ( input ) , record_summary = { num_blocks : scanner . readNum ( ) , num_entries : scanner . readNum ( ) , index_len : scanner . readNum ( ) , blocks_len : scanner . readNum ( ) , len : scanner . offset ( ) , } ; record_summary . block_pos = pos + record_summary . index_len + record_summary . len ; return record_summary ; }
1763	function read_record_block ( input , record_summary ) { var scanner = Scanner ( input ) , size = record_summary . num_blocks , record_index = Array ( size ) , p0 = record_summary . block_pos , p1 = 0 ; RECORD_BLOCK_TABLE . alloc ( size + 1 ) ; for ( var i = 0 , rdx ; i < size ; i ++ ) { record_index [ i ] = rdx = { comp_size : scanner . readNum ( ) , decomp_size : scanner . readNum ( ) } ; RECORD_BLOCK_TABLE . put ( p0 , p1 ) ; p0 += rdx . comp_size ; p1 += rdx . decomp_size ; } RECORD_BLOCK_TABLE . put ( p0 , p1 ) ; }
1764	function read_definition ( input , block , keyinfo ) { var scanner = Scanner ( input ) . readBlock ( block . comp_size , block . decomp_size ) ; scanner . forward ( keyinfo . offset - block . decomp_offset ) ; return scanner . readText ( ) ; }
1765	function read_object ( input , block , keyinfo ) { if ( input . byteLength > 0 ) { var scanner = Scanner ( input ) . readBlock ( block . comp_size , block . decomp_size ) ; scanner . forward ( keyinfo . offset - block . decomp_offset ) ; return scanner . readRaw ( keyinfo . size ) ; } else { throw '* OUT OF FILE RANGE * ' + keyinfo + ' @offset=' + block . comp_offset ; } }
1766	function findWord ( keyinfo ) { var block = RECORD_BLOCK_TABLE . find ( keyinfo . offset ) ; return _slice ( block . comp_offset , block . comp_size ) . exec ( read_definition , block , keyinfo ) . spread ( function ( definition ) { return resolve ( followLink ( definition , LOOKUP . mdx ) ) ; } ) ; }
1767	function reduce ( arr , phrase ) { var len = arr . length ; if ( len > 1 ) { len = len >> 1 ; return phrase > _adaptKey ( arr [ len - 1 ] . last_word ) ? reduce ( arr . slice ( len ) , phrase ) : reduce ( arr . slice ( 0 , len ) , phrase ) ; } else { return arr [ 0 ] ; } }
1768	function shrink ( arr , phrase ) { var len = arr . length , sub ; if ( len > 1 ) { len = len >> 1 ; var key = _adaptKey ( arr [ len ] ) ; if ( phrase < key ) { sub = arr . slice ( 0 , len ) ; sub . pos = arr . pos ; } else { sub = arr . slice ( len ) ; sub . pos = ( arr . pos || 0 ) + len ; } return shrink ( sub , phrase ) ; } else { return ( arr . pos || 0 ) + ( phrase <= _adaptKey ( arr [ 0 ] ) ? 0 : 1 ) ; } }
1769	function seekVanguard ( phrase ) { phrase = _adaptKey ( phrase ) ; var kdx = reduce ( KEY_INDEX , phrase ) ; if ( phrase <= _adaptKey ( kdx . last_word ) ) { var index = kdx . index - 1 , prev ; while ( prev = KEY_INDEX [ index ] ) { if ( _adaptKey ( prev . last_word ) !== _adaptKey ( kdx . last_word ) ) { break ; } kdx = prev ; index -- ; } } return loadKeys ( kdx ) . then ( function ( list ) { var idx = shrink ( list , phrase ) ; while ( idx > 0 ) { if ( _adaptKey ( list [ -- idx ] ) !== _adaptKey ( phrase ) ) { idx ++ ; break ; } } return [ kdx , Math . min ( idx , list . length - 1 ) , list ] ; } ) ; }
1770	function matchOffset ( list , offset ) { return list . some ( function ( el ) { return el . offset === offset ? list = [ el ] : false ; } ) ? list : [ ] ; }
1771	function isValidModifierKeyCombo ( modifierKeys , e ) { var modifierKeyNames = [ 'alt' , 'ctrl' , 'meta' , 'shift' ] , numModKeys = modifierKeys . length , i , j , currModifierKey , isValid = true ; for ( i = 0 ; i < numModKeys ; i += 1 ) { if ( ! e [ modifierKeys [ i ] ] ) { isValid = false ; break ; } } if ( isValid ) { for ( i = 0 ; i < modifierKeyNames . length ; i += 1 ) { currModifierKey = modifierKeyNames [ i ] + 'Key' ; if ( e [ currModifierKey ] ) { if ( numModKeys ) { isValid = false ; for ( j = 0 ; j < numModKeys ; j += 1 ) { if ( currModifierKey === modifierKeys [ j ] ) { isValid = true ; break ; } } } else { isValid = false ; } } if ( ! isValid ) { break ; } } } return isValid ; }
1772	function createKeyComboFunction ( keyFunc , modifierKeys ) { return function ( keyCode , modifierKeyNames ) { var i , keyCombo = '' ; if ( arguments . length ) { if ( typeof keyCode === 'number' ) { keyFunc ( keyCode ) ; modifierKeys . length = 0 ; if ( modifierKeyNames && modifierKeyNames . length ) { for ( i = 0 ; i < modifierKeyNames . length ; i += 1 ) { modifierKeys . push ( modifierKeyNames [ i ] + 'Key' ) ; } } } return this ; } for ( i = 0 ; i < modifierKeys . length ; i += 1 ) { keyCombo += modifierKeys [ i ] . slice ( 0 , - 3 ) + '+' ; } return keyCombo + keyFunc ( ) ; } ; }
1773	function overrideKeyDown ( e ) { e = e || event ; var target = e . currentTarget || e . srcElement , key = e . keyCode , tab , tabLen , text , range , tempRange , preNewlines , selNewlines , initScrollTop , selStart , selEnd , sel , startLine , endLine , numTabs , startTab , preTab , whitespace , whitespaceLen , CHARACTER = 'character' ; if ( ( target . nodeName && target . nodeName . toLowerCase ( ) !== 'textarea' ) || ( key !== tabKey && key !== untabKey && ( key !== 13 || ! autoIndent ) ) ) { return ; } inWhitespace = false ; text = target . value ; initScrollTop = target . scrollTop ; if ( typeof target . selectionStart === 'number' ) { selStart = target . selectionStart ; selEnd = target . selectionEnd ; sel = text . slice ( selStart , selEnd ) ; } else if ( document . selection ) { range = document . selection . createRange ( ) ; sel = range . text ; tempRange = range . duplicate ( ) ; tempRange . moveToElementText ( target ) ; tempRange . setEndPoint ( 'EndToEnd' , range ) ; selEnd = tempRange . text . length ; selStart = selEnd - sel . length ; if ( newlineLen > 1 ) { preNewlines = text . slice ( 0 , selStart ) . split ( newline ) . length - 1 ; selNewlines = sel . split ( newline ) . length - 1 ; } else { preNewlines = selNewlines = 0 ; } } else { return ; } if ( key === tabKey || key === untabKey ) { tab = aTab ; tabLen = tab . length ; numTabs = 0 ; startTab = 0 ; preTab = 0 ; if ( selStart !== selEnd && sel . indexOf ( '\n' ) !== \n ) - 1 else { if ( selStart === 0 || text . charAt ( selStart - 1 ) === '\n' ) \n else { startLine = selStart ; } { startLine = text . lastIndexOf ( '\n' , \n ) + selStart - 1 ; } 1 } } else if ( selEnd === text . length || text . charAt ( selEnd ) === '\n' ) \n else { endLine = selEnd ; } if ( text . charAt ( selEnd - 1 ) === '\n' ) \n else { endLine = selEnd - 1 ; } }
1774	function overrideKeyPress ( e ) { e = e || event ; var key = e . keyCode ; if ( tabKeyComboPressed ( key , e ) || untabKeyComboPressed ( key , e ) || ( key === 13 && autoIndent && ! inWhitespace ) ) { if ( e . preventDefault ) { e . preventDefault ( ) ; } else { e . returnValue = false ; return false ; } } }
1775	function executeExtensions ( hook , args ) { var i , extensions = hooks [ hook ] || [ ] , len = extensions . length ; for ( i = 0 ; i < len ; i += 1 ) { extensions [ i ] . apply ( null , args ) ; } }
1776	function ( imapMessage ) { var deferred = Q . defer ( ) ; var message = new Message ( ) ; imapMessage . on ( 'body' , function ( stream , info ) { var buffer = '' ; stream . on ( 'data' , function ( chunk ) { buffer += chunk . toString ( 'utf8' ) ; } ) ; stream . on ( 'end' , function ( ) { if ( info . which === 'TEXT' ) { message . body = buffer ; } else { message . headers = Imap . parseHeader ( buffer ) ; } } ) ; } ) ; imapMessage . on ( 'attributes' , function ( attrs ) { message . attributes = attrs ; } ) ; imapMessage . on ( 'end' , function ( ) { deferred . resolve ( message ) ; } ) ; return deferred . promise ; }
1777	function GPT ( options ) { if ( ! ( this instanceof GPT ) ) { return new GPT ( options ) } options = options != null ? options : { } this . blockSize = options . blockSize || 512 this . guid = options . guid || GPT . GUID . ZERO this . revision = options . revision || 0 this . headerSize = options . headerSize || GPT . HEADER_SIZE this . headerChecksum = 0 this . currentLBA = options . currentLBA || 1 this . backupLBA = options . backupLBA || 0 this . firstLBA = options . firstLBA || 34 this . lastLBA = options . lastLBA || 0 this . tableOffset = options . tableOffset || GPT . TABLE_OFFSET this . entries = options . entries || GPT . TABLE_ENTRIES this . entrySize = options . entrySize || GPT . TABLE_ENTRY_SIZE this . tableChecksum = 0 this . partitions = [ ] }
1778	function readBackupGPT ( primaryGPT ) { var backupGPT = new GPT ( { blockSize : primaryGPT . blockSize } ) var buffer = Buffer . alloc ( 33 * primaryGPT . blockSize ) var offset = ( ( primaryGPT . backupLBA - 32 ) * blockSize ) fs . readSync ( fd , buffer , 0 , buffer . length , offset ) backupGPT . parseBackup ( buffer ) return backupGPT }
1779	function stopcock ( fn , options ) { options = Object . assign ( { queueSize : Math . pow ( 2 , 32 ) - 1 , bucketSize : 40 , interval : 1000 , limit : 2 } , options ) ; const bucket = new TokenBucket ( options ) ; const queue = [ ] ; let timer = null ; function shift ( ) { clearTimeout ( timer ) ; while ( queue . length ) { const delay = bucket . consume ( ) ; if ( delay > 0 ) { timer = setTimeout ( shift , delay ) ; break ; } const data = queue . shift ( ) ; data [ 2 ] ( fn . apply ( data [ 0 ] , data [ 1 ] ) ) ; } } function limiter ( ) { const args = arguments ; return new Promise ( ( resolve , reject ) => { if ( queue . length === options . queueSize ) { return reject ( new Error ( 'Queue is full' ) ) ; } queue . push ( [ this , args , resolve ] ) ; shift ( ) ; } ) ; } Object . defineProperty ( limiter , 'size' , { get : ( ) => queue . length } ) ; return limiter ; }
1780	function formatQuantity ( value , encode , pad ) { if ( [ 'string' , 'number' , 'object' ] . indexOf ( typeof value ) === - 1 || value === null ) { return value ; } const numberValue = numberToBN ( value ) ; const numPadding = numberValue . lt ( ten ) && pad === true && ! numberValue . isZero ( ) ? '0' : '' ; if ( numberToBN ( value ) . isNeg ( ) ) { throw new Error ( ` ${ numberValue . toString ( 10 ) } ` ) ; } return encode ? ` ${ numPadding } ${ numberValue . toString ( 16 ) } ` : numberValue ; }
1781	function formatQuantityOrTag ( value , encode ) { var output = value ; if ( schema . tags . indexOf ( value ) === - 1 ) { output = formatQuantity ( value , encode ) ; } return output ; }
1782	function formatData ( value , byteLength ) { var output = value ; var outputByteLength = 0 ; if ( typeof value === 'string' ) { output = ` ${ padToEven ( stripHexPrefix ( value ) ) } ` ; outputByteLength = getBinarySize ( output ) ; } if ( output === '0x00' ) { output = '0x0' ; } if ( typeof byteLength === 'number' && value !== null && output !== '0x' && output !== '0x0' && ( ! / ^[0-9A-Fa-f]+$ / . test ( stripHexPrefix ( output ) ) || outputByteLength !== 2 + byteLength * 2 ) ) { throw new Error ( ` ${ output } ${ 2 + byteLength * 2 } ${ outputByteLength } ` ) ; } return output ; }
1783	function formatObject ( formatter , value , encode ) { var output = Object . assign ( { } , value ) ; var formatObject = null ; if ( typeof formatter === 'string' ) { if ( formatter === 'Boolean|EthSyncing' ) { formatObject = Object . assign ( { } , schema . objects . EthSyncing ) ; } else if ( formatter === 'DATA|Transaction' ) { formatObject = Object . assign ( { } , schema . objects . Transaction ) ; } else { formatObject = Object . assign ( { } , schema . objects [ formatter ] ) ; } } if ( ! arrayContainsArray ( Object . keys ( value ) , formatObject . __required ) ) { throw new Error ( ` ${ JSON . stringify ( value ) } ${ formatObject . __required . join ( ', ' ) } ` ) ; } Object . keys ( formatObject ) . forEach ( ( valueKey ) => { if ( valueKey !== '__required' && typeof value [ valueKey ] !== 'undefined' ) { output [ valueKey ] = format ( formatObject [ valueKey ] , value [ valueKey ] , encode ) ; } } ) ; return output ; }
1784	function format ( formatter , value , encode , lengthRequirement ) { var output = value ; if ( formatter === 'Q' ) { output = formatQuantity ( value , encode ) ; } else if ( formatter === 'QP' ) { output = formatQuantity ( value , encode , true ) ; } else if ( formatter === 'Q|T' ) { output = formatQuantityOrTag ( value , encode ) ; } else if ( formatter === 'D' ) { output = formatData ( value ) ; } else if ( formatter === 'D20' ) { output = formatData ( value , 20 ) ; } else if ( formatter === 'D32' ) { output = formatData ( value , 32 ) ; } else { if ( typeof value === 'object' && value !== null && Array . isArray ( value ) === false ) { output = formatObject ( formatter , value , encode ) ; } else if ( Array . isArray ( value ) ) { output = formatArray ( formatter , value , encode , lengthRequirement ) ; } } return output ; }
1785	function formatInputs ( method , inputs ) { return format ( schema . methods [ method ] [ 0 ] , inputs , true , schema . methods [ method ] [ 2 ] ) ; }
1786	function ( files ) { if ( ! _ . isArray ( files ) ) { throw new Error ( 'Arguments to config-helper.mergeConfig should be an array' ) ; } var appConfig = { } ; files . forEach ( function ( filePath ) { if ( gruntFile . exists ( filePath ) ) { var fileConfig = gruntFile . readYAML ( filePath ) ; _ . merge ( appConfig , fileConfig ) ; } } ) ; return appConfig ; }
1787	function parseProperties ( node ) { consume ( ) ; while ( true ) { clear ( ) ; if ( peek ( ) === '.' ) { parseProperty ( node , false ) ; } else if ( peek ( ) === ':' ) { parseProperty ( node , true ) ; } else { unexpectedTokenException ( '. or :' ) ; } clear ( ) ; if ( peek ( ) !== ',' ) { break ; } consume ( ) ; } }
1788	function extractStringLiteral ( ) { var literal = [ ] , enclosing = next ( ) ; if ( ! ( enclosing === '"' || enclosing === "'" ) ) { throw "Unexpected token at index " + index + " expected 'string' but found " + enclosing ; } while ( hasNext ( ) && peek ( ) !== enclosing ) { literal [ literal . length ] = next ( ) ; } consume ( ) ; return literal . join ( '' ) ; }
1789	function parseStringLiteral ( AST ) { if ( peek ( ) === '/' ) { newNode ( extractRegex ( ) , newNode ( 'r=' , AST ) . nodes ) ; } else { newNode ( extractStringLiteral ( ) , newNode ( '=' , AST ) . nodes ) ; } }
1790	function parseNumericLiteral ( AST ) { var literal = [ ] , value ; while ( hasNext ( ) && validNum ( peek ( ) ) ) { literal [ literal . length ] = next ( ) ; } value = parseFloat ( literal . join ( '' ) ) ; if ( ! isNaN ( value ) && isFinite ( value ) ) { newNode ( value , newNode ( '=' , AST ) . nodes ) ; } else { unexpectedTokenException ( 'numeric' ) ; } }
1791	function stage1 ( AST ) { if ( hasNext ( ) ) { switch ( peek ( ) ) { case 'a' : parseArray ( AST ) ; break ; case 'o' : parseObject ( AST ) ; break ; default : if ( / [nsSbfdr_] / . test ( peek ( ) ) ) { parseGeneric ( AST , peek ( ) ) ; } else { unexpectedTokenException ( 'one of (a,o,n,s,S,b,f,d,r,_)' ) ; } } } return AST ; }
1792	function curry ( fun , args ) { return function ( x ) { return fun . apply ( bindingContext , args . concat ( [ x ] ) ) ; } ; }
1793	function matchArray ( m , a ) { var from = 0 , rest = false , restBindingResult , index , matcher , item , matchResult , restOfArray = [ ] , i , result = { result : false , param : a } ; if ( ! is ( a , '[object Array]' ) ) { return result ; } if ( m . length > a . length && ! m [ m . length - 1 ] . name ) { return result ; } if ( m . length === 0 ) { result . result = true ; return result ; } for ( index = 0 ; index < a . length ; index ++ ) { matcher = m [ index ] ; item = a [ index ] ; if ( ! matcher ) { return result ; } matchResult = matcher ( item ) ; if ( ! matchResult . result ) { return result ; } if ( matchResult . rest ) { restBindingResult = matchResult ; from = index ; rest = true ; break ; } } if ( rest && restBindingResult . this_binding ) { for ( i = from ; i < a . length ; i ++ ) { restOfArray [ restOfArray . length ] = a [ i ] ; } bindingContext [ restBindingResult . this_binding ] = restOfArray ; } result . result = true ; return result ; }
1794	function compileNode ( ast ) { var result = [ ] , index , node , matcher ; for ( index = 0 ; index < ast . length ; index ++ ) { node = ast [ index ] ; switch ( node . type ) { case 'a' : matcher = curry ( matchArray , [ compileNode ( node . nodes ) ] ) ; break ; case 'o' : matcher = curry ( matchObject , [ compileNode ( node . nodes ) ] ) ; break ; case '.' : matcher = curry ( hasProperty , [ compileNode ( node . nodes ) , node . name ] ) ; break ; case ':' : matcher = curry ( hasPrototypeProperty , [ compileNode ( node . nodes ) , node . name ] ) ; break ; case '=' : matcher = curry ( equals , [ node . nodes [ 0 ] . type ] ) ; break ; case 'd=' : matcher = curry ( equalsDate , [ node . nodes [ 0 ] . type ] ) ; break ; case 'r=' : matcher = curry ( matchesRegex , [ node . nodes [ 0 ] . type ] ) ; break ; case '||' : matcher = curry ( or , [ compileNode ( node . nodes ) ] ) ; break ; case 'n' : matcher = curry ( matchType , [ 'number' ] ) ; break ; case 's' : matcher = curry ( matchType , [ 'string' ] ) ; break ; case 'S' : matcher = matchNonBlankString ; break ; case 'b' : matcher = curry ( matchType , [ 'boolean' ] ) ; break ; case 'f' : matcher = curry ( matchType , [ 'function' ] ) ; break ; case '_' : matcher = any ; break ; case '|' : matcher = rest ; break ; case '()' : matcher = matchEmptyArray ; break ; case 'd' : matcher = curry ( matchInstanceOf , [ '[object Date]' ] ) ; break ; case 'r' : matcher = curry ( matchInstanceOf , [ '[object RegExp]' ] ) ; break ; default : throw "Unknown AST entity: " + node . type ; } if ( node . binding ) { matcher = curry ( bind , [ node . binding , matcher ] ) ; } result [ result . length ] = matcher ; } return result ; }
1795	function getName ( tag ) { return tag . name ? tag . name . value . toLowerCase ( ) : ` ${ tag . type } ` ; }
1796	function eatAttributeValue ( stream ) { const start = stream . pos ; if ( eatQuoted ( stream ) ) { const current = stream . pos ; let valueStart , valueEnd ; stream . pos = start ; stream . next ( ) ; valueStart = stream . start = stream . pos ; stream . pos = current ; stream . backUp ( 1 ) ; valueEnd = stream . pos ; const result = token ( stream , valueStart , valueEnd ) ; stream . pos = current ; return result ; } return eatPaired ( stream ) || eatUnquoted ( stream ) ; }
1797	function isUnquoted ( code ) { return ! isNaN ( code ) && ! isQuote ( code ) && ! isSpace ( code ) && ! isTerminator ( code ) ; }
1798	function setDefault ( obj , key , val ) { if ( _ . isUndefined ( obj [ key ] ) ) { obj [ key ] = val ; return val ; } return obj [ key ] ; }
1799	function getXml ( path , finish ) { fs . readFile ( path , function ( err , data ) { if ( err ) throw err ; xmlParser . parseString ( data , function ( err , result ) { if ( err ) throw err ; finish ( result ) ; } ) ; } ) ; }
1800	function appendUISource ( client ) { angoose . getLogger ( 'angoose' ) . debug ( "Appending angoose-ui sources" ) ; var output = "" ; output += readFile ( path . resolve ( __dirname , 'angular-modules.js' ) ) ; output += concatFilesInDirectory ( [ 'services' , 'controllers' , 'directives' , 'filters' ] ) ; output += concatTemplates ( ) ; client . source += "\n\n" + \n ; }
1801	function error ( msg , addHint ) { console . log ( '\x1b[31m' ) ; \x1b console . log ( 'The compiler has stopped on an error' ) console . log ( ` \x1b ${ msg } \x1b ` ) ; if ( addHint ) console . log ( ` \n ` ) ; }
1802	function compile ( modelName , schema , dependencies ) { logger . trace ( "Compiling schema " , modelName ) var model = function AngooseModule ( data ) { for ( var i in data ) { this [ i ] = data [ i ] ; } } ; model . toString = function ( ) { return "PROXY: function " + modelName + "()" ; } for ( var name in schema . statics ) { model [ name ] = createProxy ( model , name , schema . statics [ name ] , 'static' ) ; } for ( var name in schema . methods ) { model . prototype [ name ] = createProxy ( model , name , schema . methods [ name ] , 'instance' ) ; } model . dependencies$ = dependencies ; model . schema = schema ; model . prototype . get = getter ; model . prototype . set = setter ; model . modelName = modelName ; model . name = modelName ; model . prototype . mergeData = function ( source ) { if ( typeof source != "object" ) throw "Invalid source object, must be an model instance" ; for ( var i in source ) { this [ i ] = source [ i ] ; } } AngooseClient . models = AngooseClient . models || { } ; AngooseClient . models [ modelName ] = model ; return model ; }
1803	function addProps ( props , options ) { if ( ! props ) return '## No props' const keys = Object . keys ( props ) . filter ( key => filterProps ( key , props [ key ] , options ) , ) const filteredProps = keys . reduce ( ( last , key ) => ( { ... last , [ key ] : props [ key ] } ) , { } , ) let output = '\n## Props\n' \n \n let isFlow = false const items = [ TABLE_HEADERS , ... keys . map ( key => { const prop = filteredProps [ key ] if ( isFlowType ( prop ) ) isFlow = true const row = [ isFlowType ( prop ) ? key : getKey ( key , getType ( prop ) ) , getTypeName ( getType ( prop ) ) , getDefaultValue ( prop ) , prop . required , prop . description , ] return row . map ( rowValue => { if ( typeof rowValue === 'string' ) { return rowValue . split ( '\n' ) . \n join } ( '<br>' ) } ) } ) , ] return rowValue }
1804	function debounce ( quietMillis , fn , ctx ) { ctx = ctx || undefined ; var timeout ; return function ( ) { var args = arguments ; clearTimeout ( timeout ) ; timeout = setTimeout ( function ( ) { fn . apply ( ctx , args ) ; } , quietMillis ) ; } ; }
1805	function matroshka ( fn ) { var babushka = fn ; Object . keys ( process . namespaces ) . forEach ( function ( name ) { babushka = process . namespaces [ name ] . bind ( babushka ) ; } ) ; return babushka ; }
1806	function findTagged ( modelClass , tag ) { if ( ! modelClass || ! modelClass . schema ) return [ ] ; var cols = [ ] ; Object . keys ( modelClass . schema . paths ) . forEach ( function ( path ) { var data = modelClass . schema . paths [ path ] ; if ( data . options . tags && data . options . tags . indexOf ( tag ) >= 0 ) cols . push ( data ) ; } ) ; return cols ; }
1807	function error ( msg ) { if ( exports . error ) exports . error ( msg ) ; else console . log ( 'Error: ' + msg ) ; }
1808	function call ( name , isLong ) { var obj = isLong ? long [ name ] : short [ name ] ; if ( ! obj ) return error ( ` ${ name } ` ) ; if ( n + obj . length > count ) return error ( ` ${ name } ` ) ; var arr = process . argv . slice ( n , n + obj . length ) ; n += obj . length ; obj . callback ( arr ) ; }
1809	function findInputElement ( templateElement ) { return angular . element ( templateElement . find ( 'input' ) [ 0 ] || templateElement . find ( 'select' ) [ 0 ] || templateElement . find ( 'textarea' ) [ 0 ] ) ; }
1810	function getValidationMessageMap ( originalElement ) { var validationMessages = { } ; angular . forEach ( originalElement . find ( 'validator' ) , function ( element ) { element = angular . element ( element ) ; validationMessages [ element . attr ( 'key' ) ] = $interpolate ( element . text ( ) ) ; } ) ; return validationMessages ; }
1811	function registerClass ( nameOrOpts , claz ) { var opts = typeof ( nameOrOpts ) == 'object' ? nameOrOpts : { name : nameOrOpts } ; var className = opts . name ; if ( ! className ) throw "Missing module name: " + className if ( beans [ className ] ) logger . warn ( "Overriding existing bean: " , className ) ; if ( claz . _angoosemeta && ( claz . _angoosemeta . baseClass == 'Service' || claz . _angoosemeta . baseClass == 'Model' ) ) { } else { if ( typeof ( claz ) === 'function' && claz . schema && claz . modelName ) opts . baseClass = 'Model' ; else if ( claz instanceof getMongoose ( ) . Schema ) { opts . baseClass = 'Model' ; claz = getMongoose ( ) . model ( className , claz ) ; } else opts . baseClass = 'Service' ; angoose . Remotable . mixin ( opts , claz ) ; } _ . extend ( claz . _angoosemeta , nameOrOpts ) ; beans [ className ] = claz ; logger . debug ( "Registered module" , claz . _angoosemeta . baseClass , className ) ; return claz ; }
1812	function config ( path , val ) { if ( ! path ) return options ; if ( ! angoose . initialized && typeof ( path ) == 'string' ) throw "Cannot call config(" + path + ") before angoose is intialized" ; if ( typeof ( path ) === 'string' ) { if ( val === undefined ) return toolbox . getter ( options , path ) ; toolbox . setter ( options , path , val ) ; } if ( typeof ( path ) === 'object' ) { options = toolbox . merge ( options , path ) ; } }
1813	function connect ( url , next ) { log ( 'connecting to %s' , url ) ; mongo . Db . connect ( url , { db : { w : 1 } } , next ) ; }
1814	function startShell ( db , program , files ) { var repl = global . repl = term ( db ) ; createContext ( db , repl , function ( ) { var code = program . eval ; if ( code ) { executeJS ( code ) ; if ( ! program . shell ) { repl . emit ( 'exit' ) ; return ; } } if ( files . length ) { executeFiles ( files ) ; printCloseMsg ( ) ; } repl . prompt = prompt ; repl . displayPrompt ( ) } ) ; }
1815	function executeFiles ( files ) { var dir = process . cwd ( ) ; files . forEach ( function ( file ) { require ( dir + '/' + file ) ; } ) ; }
1816	function wrap ( proto , name ) { var old = proto [ name ] ; proto [ name ] = function ( ) { if ( global . repl ) global . repl . bufferStart ( ) ; var args = slice ( arguments ) ; var last = args [ args . length - 1 ] ; if ( 'function' == typeof last ) { args [ args . length - 1 ] = function ( ) { if ( global . repl ) global . repl . bufferEnd ( ) if ( p != last ) console . log ( ) ; last . apply ( null , arguments ) if ( global . repl ) { global . repl . displayPrompt ( ) ; global . repl . moveCursorToEnd ( ) ; } } } else { args . push ( function ( ) { if ( global . repl ) global . repl . bufferEnd ( ) p . apply ( null , arguments ) ; if ( global . repl ) global . repl . moveCursorToEnd ( ) ; } ) ; } old . apply ( this , args ) ; } if ( old . help ) { proto [ name ] . help = old . help ; } }
1817	function handleError ( err , cb ) { if ( err ) { if ( cb ) { return process . nextTick ( function ( ) { cb ( err ) ; } ) ; } console . error ( err ) ; } }
1818	function tablature ( conf ) { const { keys = [ ] , data = [ ] , headings = { } , replacements = { } , centerValues = [ ] , centerHeadings = [ ] , } = conf const [ i ] = data if ( ! i ) return '' const cv = makeBinaryHash ( centerValues ) const hv = makeBinaryHash ( centerHeadings ) const k = Object . keys ( i ) . reduce ( ( acc , key ) => { const h = headings [ key ] return { ... acc , [ key ] : h ? h . length : key . length , } } , { } ) const widths = data . reduce ( ( dac , d ) => { const res = Object . keys ( d ) . reduce ( ( acc , key ) => { const maxLength = dac [ key ] const val = d [ key ] const r = getReplacement ( replacements , key ) const { length } = r ( val ) return { ... acc , [ key ] : Math . max ( length , maxLength ) , } } , { } ) return res } , k ) const kk = keys . reduce ( ( acc , key ) => { const h = headings [ key ] return { ... acc , [ key ] : h || key , } } , { } ) const hr = keys . reduce ( ( acc , key ) => { return { ... acc , [ key ] : heading , } } , { } ) const hl = getLine ( keys , kk , widths , hr , hv ) const rl = data . map ( ( row ) => { const line = getLine ( keys , row , widths , replacements , cv ) return line } ) return [ hl , ... rl , ] . join ( '\n' ) }
1819	function _save ( ) { if ( db . source && db . write && writeOnChange ) { var str = JSON . stringify ( db . object ) ; if ( str !== db . _checksum ) { db . _checksum = str ; return db . write ( db . source , db . object ) ; } } }
1820	function Picklr ( startDir , options ) { options = options || { } ; let defaultExcludeDirsRe ; if ( / ^\. / . test ( startDir ) ) { defaultExcludeDirsRe = / \/\.|node_modules / i ; } else { defaultExcludeDirsRe = / ^\.|\/\.|node_modules / i ; } this . totalFileCount = 0 ; this . matchedFileCount = 0 ; this . startDir = startDir || '.' ; this . targetText = options . targetText || '' ; this . replacementText = options . replacementText || '' ; this . action = options . action || 'echo' ; this . includeExts = options . includeExts || [ '.js' ] ; this . excludeDirs = options . excludeDirsRe || defaultExcludeDirsRe ; this . logger = options . logger || console . log ; this . picklrActions = picklrActions ; }
1821	function ( p ) { fs . readdirSync ( p ) . forEach ( function ( file ) { const curPath = path . join ( p , path . sep , file ) ; const stats = fs . statSync ( curPath ) ; if ( this . isDirectory ( stats , curPath ) ) { this . recurseFiles ( curPath ) ; } else if ( this . isFile ( stats , curPath ) ) { this . picklrActions [ this . action ] . call ( this , curPath ) ; } } , this ) ; if ( p === this . startDir ) { this . logger ( 'Total file count = ' + this . totalFileCount ) ; if ( this . action !== 'echo' ) { this . logger ( 'Matched file count = ' + this . matchedFileCount ) ; } } }
1822	function ( stats , p ) { let result = stats . isFile ( ) ; if ( result ) { const ext = path . extname ( p ) ; result = this . includeExts . indexOf ( ext ) !== - 1 ; } return result ; }
1823	function ( stats , p ) { let result = stats . isDirectory ( ) ; if ( result ) { result = ! this . excludeDirs . test ( p ) ; } return result ; }
1824	function processAllFiles ( startDir , options ) { const picklr = new Picklr ( startDir , options ) ; picklr . recurseFiles ( startDir ) ; }
1825	function processFile ( filePath , update ) { let change , found = false ; const lines = fs . readFileSync ( filePath , { encoding : 'utf8' } ) . split ( '\n' ) ; \n for ( let i = 0 ; i < lines . length ; i ++ ) { if ( lines [ i ] . indexOf ( this . targetText ) !== - 1 ) { found = true ; change = lines [ i ] . replace ( this . targetText , this . replacementText ) ; if ( update ) { lines [ i ] = change ; } else { this . logger ( '*** File: ' + filePath ) ; this . logger ( '@@@ Found: ' + lines [ i ] ) ; this . logger ( '--- Change: ' + change ) ; } this . matchedFileCount ++ ; break ; } } if ( ! found && ! update ) { this . logger ( '*** Omitted: ' + filePath ) ; } if ( found && update ) { fs . writeFileSync ( filePath , lines . join ( '\n' ) , \n ) ; { encoding : 'utf8' } } }
1826	async function initHTTPServer ( { ENV = { } , HOST = '127.0.0.1' , PORT = 8080 , MAX_HEADERS_COUNT = 800 , KEEP_ALIVE_TIMEOUT = ms ( '5m' ) , TIMEOUT = ms ( '2m' ) , MAX_CONNECTIONS , httpRouter , log = noop , } ) { const sockets = ENV . DESTROY_SOCKETS ? new Set ( ) : { } . undef ; const httpServer = http . createServer ( httpRouter ) ; const listenPromise = new Promise ( resolve => { httpServer . listen ( PORT , HOST , ( ) => { log ( 'info' , ` ${ HOST } ${ PORT } ` ) ; resolve ( httpServer ) ; } ) ; } ) ; const errorPromise = new Promise ( ( resolve , reject ) => { httpServer . once ( 'error' , reject ) ; } ) ; httpServer . timeout = TIMEOUT ; httpServer . keepAliveTimeout = KEEP_ALIVE_TIMEOUT ; httpServer . maxHeadersCount = MAX_HEADERS_COUNT ; httpServer . maxConnections = MAX_CONNECTIONS ; if ( 'undefined' !== typeof MAX_CONNECTIONS ) { httpServer . maxConnections = MAX_CONNECTIONS ; } if ( ENV . DESTROY_SOCKETS ) { httpServer . on ( 'connection' , socket => { sockets . add ( socket ) ; socket . on ( 'close' , ( ) => { sockets . delete ( socket ) ; } ) ; } ) ; } return Promise . race ( [ listenPromise , errorPromise ] ) . then ( ( ) => ( { service : httpServer , errorPromise , dispose : ( ) => new Promise ( ( resolve , reject ) => { log ( 'debug' , 'Closing HTTP server.' ) ; httpServer . timeout = 1 ; httpServer . keepAliveTimeout = 1 ; httpServer . close ( err => { if ( err ) { reject ( err ) ; return ; } log ( 'debug' , 'HTTP server closed' ) ; resolve ( ) ; } ) ; if ( ENV . DESTROY_SOCKETS ) { for ( const socket of sockets . values ( ) ) { socket . destroy ( ) ; } } } ) , } ) ) ; }
1827	function sortAndAddFirstElement ( array , sortBy , element ) { return _ ( array ) . sortBy ( sortBy ) . unshift ( element ) . value ( ) ; }
1828	function objectInterface ( config ) { return function ( obj ) { var result = { } ; for ( var i = 0 ; i < config . length ; i ++ ) { var OR , NEXT , REAL ; if ( ( OR = config [ i ] . split ( '/' ) ) && OR [ 1 ] ) { result [ OR [ 0 ] ] = obj [ OR [ 0 ] ] || Function ( 'return ' + OR [ 1 ] ) ( ) ; } else if ( ( NEXT = config [ i ] . split ( '|' ) ) && NEXT [ 1 ] ) { result [ NEXT [ 0 ] ] = Function ( 'return ' + NEXT [ 1 ] ) . call ( obj ) ; } else if ( ( REAL = config [ i ] . split ( ':' ) ) && REAL [ 1 ] ) { result [ REAL [ 0 ] ] = Function ( 'return ' + REAL [ 1 ] ) ( ) ; } else { result [ config [ i ] ] = obj [ config [ i ] ] ; } } return result ; } }
1829	function httpTransaction ( req , res ) { let initializationPromise ; return Promise . resolve ( ) . then ( ( ) => { const request = { url : req . url , method : req . method . toLowerCase ( ) , headers : req . headers , body : req , } ; const transaction = { protocol : req . connection . encrypted ? 'https' : 'http' , ip : ( req . headers [ 'x-forwarded-for' ] || '' ) . split ( ',' ) [ 0 ] || req . connection . remoteAddress , startInBytes : req . socket . bytesRead , startOutBytes : req . socket . bytesWritten , startTime : time ( ) , url : req . url , method : req . method , reqHeaders : req . headers , errored : false , } ; const delayPromise = delay . create ( TIMEOUT ) ; let id = req . headers [ 'transaction-id' ] || uniqueId ( ) ; if ( TRANSACTIONS [ id ] ) { initializationPromise = Promise . reject ( new HTTPError ( 400 , 'E_TRANSACTION_ID_NOT_UNIQUE' , id ) , ) ; id = uniqueId ( ) ; } else { initializationPromise = Promise . resolve ( ) ; } transaction . id = id ; TRANSACTIONS [ id ] = transaction ; return [ request , { id , start : startTransaction . bind ( null , { id , req , res , delayPromise } , initializationPromise , ) , catch : catchTransaction . bind ( null , { id , req , res } ) , end : endTransaction . bind ( null , { id , req , res , delayPromise } ) , } , ] ; } ) ; }
1830	function dateDifference ( date1 , date2 , differenceType ) { var diffMilliseconds = Math . abs ( date1 - date2 ) ; switch ( differenceType ) { case 'days' : return dates . _getDaysDiff ( diffMilliseconds ) ; case 'hours' : return dates . _differenceInHours ( diffMilliseconds ) ; case 'minutes' : return dates . _differenceInMinutes ( diffMilliseconds ) ; case 'milliseconds' : return diffMilliseconds ; default : return { days : dates . _getDaysDiff ( diffMilliseconds ) , hours : dates . _getHoursDiff ( diffMilliseconds ) , minutes : dates . _getMinutesDiff ( diffMilliseconds ) , milliseconds : diffMilliseconds } } }
1831	function initErrorHandler ( { ENV = { } , DEBUG_NODE_ENVS = DEFAULT_DEBUG_NODE_ENVS , STRINGIFYERS = DEFAULT_STRINGIFYERS , } ) { return Promise . resolve ( errorHandler ) ; function errorHandler ( transactionId , responseSpec , err ) { return Promise . resolve ( ) . then ( ( ) => { const response = { } ; response . status = err . httpCode || 500 ; response . headers = Object . assign ( { } , err . headers || { } , { 'cache-control' : 'private' , 'content-type' : responseSpec && responseSpec . contentTypes [ 0 ] && STRINGIFYERS [ responseSpec . contentTypes [ 0 ] ] ? responseSpec . contentTypes [ 0 ] : Object . keys ( STRINGIFYERS ) [ 0 ] , } ) ; response . body = { error : { code : err . code || 'E_UNEXPECTED' , guruMeditation : transactionId , } , } ; if ( ENV && DEBUG_NODE_ENVS . includes ( ENV . NODE_ENV ) ) { response . body . error . stack = err . stack ; response . body . error . params = err . params ; } return response ; } ) ; } }
1832	function dateDifferenceFromNow ( date , differenceType ) { var now = new Date ( ) , diffMilliseconds = Math . abs ( date - now ) ; switch ( differenceType ) { case 'days' : return dates . _getDaysDiff ( diffMilliseconds ) ; case 'hours' : return dates . _differenceInHours ( diffMilliseconds ) ; case 'minutes' : return dates . _differenceInMinutes ( diffMilliseconds ) ; case 'milliseconds' : return diffMilliseconds ; default : return { days : dates . _getDaysDiff ( diffMilliseconds ) , hours : dates . _getHoursDiff ( diffMilliseconds ) , minutes : dates . _getMinutesDiff ( diffMilliseconds ) , milliseconds : diffMilliseconds } } }
1833	function consumePair ( stream , close , open ) { const start = stream . pos ; if ( stream . eat ( close ) ) { while ( ! stream . sol ( ) ) { if ( stream . eat ( open ) ) { return true ; } stream . pos -- ; } } stream . pos = start ; return false ; }
1834	function consumeArray ( stream , arr ) { const start = stream . pos ; let consumed = false ; for ( let i = arr . length - 1 ; i >= 0 && ! stream . sol ( ) ; i -- ) { if ( ! stream . eat ( arr [ i ] ) ) { break ; } consumed = i === 0 ; } if ( ! consumed ) { stream . pos = start ; } return consumed ; }
1835	function isIdent ( c ) { return c === COLON || c === DASH || isAlpha ( c ) || isNumber ( c ) ; }
1836	function onCycle ( event ) { if ( objectPool . length == 0 ) { throw new Error ( 'Pool ran out of objects' ) ; } console . log ( String ( event . target ) ) ; initPool ( ) ; }
1837	function json ( file ) { var filename = path . basename ( file . path , path . extname ( file . path ) ) + ".json" ; return optional ( path . join ( path . dirname ( file . path ) , filename ) ) || { } ; }
1838	function ( event ) { if ( event . name === 'goToLevel' && event . level !== self . level ) { self . pushLevel ( event . level ) ; } }
1839	function ( event ) { if ( event . name === 'goToLevel' ) { if ( event . level === self . level ) { this . transitionTo ( open ) ; } else { self . pushLevel ( event . level ) ; this . transitionTo ( moving ) ; } } }
1840	function decryptGCM ( encryptedComponents , keyDerivationInfo ) { const encryptedContent = encryptedComponents . content ; const iv = new Buffer ( encryptedComponents . iv , "hex" ) ; const { auth : tagHex , salt } = encryptedComponents ; const decryptTool = crypto . createDecipheriv ( ENC_ALGORITHM_GCM , keyDerivationInfo . key , iv ) ; decryptTool . setAAD ( new Buffer ( ` ${ encryptedComponents . iv } ${ keyDerivationInfo . salt } ` , "utf8" ) ) ; decryptTool . setAuthTag ( new Buffer ( tagHex , "hex" ) ) ; const decryptedText = decryptTool . update ( encryptedContent , "base64" , "utf8" ) ; return Promise . resolve ( ` ${ decryptedText } ${ decryptTool . final ( "utf8" ) } ` ) ; }
1841	function encryptCBC ( text , keyDerivationInfo , iv ) { return Promise . resolve ( ) . then ( ( ) => { const ivHex = iv . toString ( "hex" ) ; const encryptTool = crypto . createCipheriv ( ENC_ALGORITHM_CBC , keyDerivationInfo . key , iv ) ; const hmacTool = crypto . createHmac ( HMAC_ALGORITHM , keyDerivationInfo . hmac ) ; const { rounds } = keyDerivationInfo ; let encryptedContent = encryptTool . update ( text , "utf8" , "base64" ) ; encryptedContent += encryptTool . final ( "base64" ) ; hmacTool . update ( encryptedContent ) ; hmacTool . update ( ivHex ) ; hmacTool . update ( keyDerivationInfo . salt ) ; const hmacHex = hmacTool . digest ( "hex" ) ; return { mode : "cbc" , auth : hmacHex , iv : ivHex , salt : keyDerivationInfo . salt , rounds , content : encryptedContent } ; } ) ; }
1842	function encryptGCM ( text , keyDerivationInfo , iv ) { return Promise . resolve ( ) . then ( ( ) => { const ivHex = iv . toString ( "hex" ) ; const { rounds } = keyDerivationInfo ; const encryptTool = crypto . createCipheriv ( ENC_ALGORITHM_GCM , keyDerivationInfo . key , iv ) ; encryptTool . setAAD ( new Buffer ( ` ${ ivHex } ${ keyDerivationInfo . salt } ` , "utf8" ) ) ; let encryptedContent = encryptTool . update ( text , "utf8" , "base64" ) ; encryptedContent += encryptTool . final ( "base64" ) ; const tag = encryptTool . getAuthTag ( ) ; return { mode : "gcm" , iv : ivHex , salt : keyDerivationInfo . salt , rounds , content : encryptedContent , auth : tag . toString ( "hex" ) } ; } ) ; }
1843	function unpackEncryptedContent ( encryptedContent ) { const [ content , iv , salt , auth , roundsRaw , methodRaw ] = encryptedContent . split ( "$" ) ; const rounds = roundsRaw ? parseInt ( roundsRaw , 10 ) : PBKDF2_ROUND_DEFAULT ; const method = methodRaw || "cbc" ; return { content , iv , salt , auth , rounds , method } ; }
1844	function deriveFromPassword ( pbkdf2Gen , password , salt , rounds , generateHMAC = true ) { if ( ! password ) { return Promise . reject ( new Error ( "Failed deriving key: Password must be provided" ) ) ; } if ( ! salt ) { return Promise . reject ( new Error ( "Failed deriving key: Salt must be provided" ) ) ; } if ( ! rounds || rounds <= 0 ) { return Promise . reject ( new Error ( "Failed deriving key: Rounds must be greater than 0" ) ) ; } const bits = generateHMAC ? ( PASSWORD_KEY_SIZE + HMAC_KEY_SIZE ) * 8 : PASSWORD_KEY_SIZE * 8 ; return pbkdf2Gen ( password , salt , rounds , bits ) . then ( derivedKeyData => derivedKeyData . toString ( "hex" ) ) . then ( function ( derivedKeyHex ) { const dkhLength = derivedKeyHex . length ; const keyBuffer = generateHMAC ? new Buffer ( derivedKeyHex . substr ( 0 , dkhLength / 2 ) , "hex" ) : new Buffer ( derivedKeyHex , "hex" ) ; const output = { salt : salt , key : keyBuffer , rounds : rounds } ; if ( generateHMAC ) { output . hmac = new Buffer ( derivedKeyHex . substr ( dkhLength / 2 , dkhLength / 2 ) , "hex" ) ; } return output ; } ) ; }
1845	function pbkdf2 ( password , salt , rounds , bits ) { return new Promise ( ( resolve , reject ) => { deriveKey ( password , salt , rounds , bits / 8 , DERIVED_KEY_ALGORITHM , ( err , key ) => { if ( err ) { return reject ( err ) ; } return resolve ( key ) ; } ) ; } ) ; }
1846	function createEncodeStream ( schema ) { const stream = new BinaryStream ( { readableObjectMode : false , writableObjectMode : true , transform : transformEncode , } ) ; stream [ kschema ] = schema ; return stream ; }
1847	function createDecodeStream ( bufOrSchema ) { let schema = null ; const isBuffer = Buffer . isBuffer ( bufOrSchema ) ; if ( ! isBuffer ) { schema = bufOrSchema ; } const stream = new BinaryStream ( { transform : transformDecode , readableObjectMode : true , writableObjectMode : false , } ) ; stream [ kschema ] = schema ; if ( isBuffer ) { stream . append ( bufOrSchema ) ; } return stream ; }
1848	function erdosRenyi ( GraphClass , options ) { if ( ! isGraphConstructor ( GraphClass ) ) throw new Error ( 'graphology-generators/random/erdos-renyi: invalid Graph constructor.' ) ; var order = options . order , probability = options . probability , rng = options . rng || Math . random ; var graph = new GraphClass ( ) ; if ( typeof options . approximateSize === 'number' ) { var densityFunction = density [ graph . type + 'Density' ] ; probability = densityFunction ( order , options . approximateSize ) ; } if ( typeof order !== 'number' || order <= 0 ) throw new Error ( 'graphology-generators/random/erdos-renyi: invalid `order`. Should be a positive number.' ) ; if ( typeof probability !== 'number' || probability < 0 || probability > 1 ) throw new Error ( 'graphology-generators/random/erdos-renyi: invalid `probability`. Should be a number between 0 and 1. Or maybe you gave an `approximateSize` exceeding the graph\'s density.' ) ; \' if ( typeof rng !== 'function' ) throw new Error ( 'graphology-generators/random/erdos-renyi: invalid `rng`. Should be a function.' ) ; for ( var i = 0 ; i < order ; i ++ ) graph . addNode ( i ) ; if ( probability <= 0 ) return graph ; if ( order > 1 ) { var iterator = combinations ( range ( order ) , 2 ) , path , step ; while ( ( step = iterator . next ( ) , ! step . done ) ) { path = step . value ; if ( graph . type !== 'directed' ) { if ( rng ( ) < probability ) graph . addUndirectedEdge ( path [ 0 ] , path [ 1 ] ) ; } if ( graph . type !== 'undirected' ) { if ( rng ( ) < probability ) graph . addDirectedEdge ( path [ 0 ] , path [ 1 ] ) ; if ( rng ( ) < probability ) graph . addDirectedEdge ( path [ 1 ] , path [ 0 ] ) ; } } } }
1849	function erdosRenyiSparse ( GraphClass , options ) { if ( ! isGraphConstructor ( GraphClass ) ) throw new Error ( 'graphology-generators/random/erdos-renyi: invalid Graph constructor.' ) ; var order = options . order , probability = options . probability , rng = options . rng || Math . random ; var graph = new GraphClass ( ) ; if ( typeof options . approximateSize === 'number' ) { var densityFunction = density [ graph . type + 'Density' ] ; probability = densityFunction ( order , options . approximateSize ) ; } if ( typeof order !== 'number' || order <= 0 ) throw new Error ( 'graphology-generators/random/erdos-renyi: invalid `order`. Should be a positive number.' ) ; if ( typeof probability !== 'number' || probability < 0 || probability > 1 ) throw new Error ( 'graphology-generators/random/erdos-renyi: invalid `probability`. Should be a number between 0 and 1. Or maybe you gave an `approximateSize` exceeding the graph\'s density.' ) ; \' if ( typeof rng !== 'function' ) throw new Error ( 'graphology-generators/random/erdos-renyi: invalid `rng`. Should be a function.' ) ; for ( var i = 0 ; i < order ; i ++ ) graph . addNode ( i ) ; if ( probability <= 0 ) return graph ; var w = - 1 , lp = Math . log ( 1 - probability ) , lr , v ; if ( graph . type !== 'undirected' ) { v = 0 ; while ( v < order ) { lr = Math . log ( 1 - rng ( ) ) ; w += 1 + ( ( lr / lp ) | 0 ) ; if ( v === w ) { w ++ ; } while ( v < order && order <= w ) { w -= order ; v ++ ; if ( v === w ) w ++ ; } if ( v < order ) graph . addDirectedEdge ( v , w ) ; } } w = - 1 ; if ( graph . type !== 'directed' ) { v = 1 ; while ( v < order ) { lr = Math . log ( 1 - rng ( ) ) ; w += 1 + ( ( lr / lp ) | 0 ) ; while ( w >= v && v < order ) { w -= v ; v ++ ; } if ( v < order ) graph . addUndirectedEdge ( v , w ) ; } } }
1850	function single_curve ( d , ctx ) { var centroids = compute_centroids ( d ) ; var cps = compute_control_points ( centroids ) ; ctx . moveTo ( cps [ 0 ] . e ( 1 ) , cps [ 0 ] . e ( 2 ) ) ; for ( var i = 1 ; i < cps . length ; i += 3 ) { if ( __ . showControlPoints ) { for ( var j = 0 ; j < 3 ; j ++ ) { ctx . fillRect ( cps [ i + j ] . e ( 1 ) , cps [ i + j ] . e ( 2 ) , 2 , 2 ) ; } } ctx . bezierCurveTo ( cps [ i ] . e ( 1 ) , cps [ i ] . e ( 2 ) , cps [ i + 1 ] . e ( 1 ) , cps [ i + 1 ] . e ( 2 ) , cps [ i + 2 ] . e ( 1 ) , cps [ i + 2 ] . e ( 2 ) ) ; } }
1851	function color_path ( d , ctx ) { ctx . beginPath ( ) ; if ( ( __ . bundleDimension !== null && __ . bundlingStrength > 0 ) || __ . smoothness > 0 ) { single_curve ( d , ctx ) ; } else { single_path ( d , ctx ) ; } ctx . stroke ( ) ; }
1852	function paths ( data , ctx ) { ctx . clearRect ( - 1 , - 1 , w ( ) + 2 , h ( ) + 2 ) ; ctx . beginPath ( ) ; data . forEach ( function ( d ) { if ( ( __ . bundleDimension !== null && __ . bundlingStrength > 0 ) || __ . smoothness > 0 ) { single_curve ( d , ctx ) ; } else { single_path ( d , ctx ) ; } } ) ; ctx . stroke ( ) ; }
1853	function brushUpdated ( newSelection ) { __ . brushed = newSelection ; events . brush . call ( pc , __ . brushed ) ; pc . renderBrushed ( ) ; }
1854	function selected ( ) { var actives = d3 . keys ( __ . dimensions ) . filter ( is_brushed ) , extents = actives . map ( function ( p ) { return brushes [ p ] . extent ( ) ; } ) ; if ( actives . length === 0 ) return __ . data ; var within = { "date" : function ( d , p , dimension ) { if ( typeof __ . dimensions [ p ] . yscale . rangePoints === "function" ) { return extents [ dimension ] [ 0 ] <= __ . dimensions [ p ] . yscale ( d [ p ] ) && __ . dimensions [ p ] . yscale ( d [ p ] ) <= extents [ dimension ] [ 1 ] } else { return extents [ dimension ] [ 0 ] <= d [ p ] && d [ p ] <= extents [ dimension ] [ 1 ] } } , "number" : function ( d , p , dimension ) { if ( typeof __ . dimensions [ p ] . yscale . rangePoints === "function" ) { return extents [ dimension ] [ 0 ] <= __ . dimensions [ p ] . yscale ( d [ p ] ) && __ . dimensions [ p ] . yscale ( d [ p ] ) <= extents [ dimension ] [ 1 ] } else { return extents [ dimension ] [ 0 ] <= d [ p ] && d [ p ] <= extents [ dimension ] [ 1 ] } } , "string" : function ( d , p , dimension ) { return extents [ dimension ] [ 0 ] <= __ . dimensions [ p ] . yscale ( d [ p ] ) && __ . dimensions [ p ] . yscale ( d [ p ] ) <= extents [ dimension ] [ 1 ] } } ; return __ . data . filter ( function ( d ) { switch ( brush . predicate ) { case "AND" : return actives . every ( function ( p , dimension ) { return within [ __ . dimensions [ p ] . type ] ( d , p , dimension ) ; } ) ; case "OR" : return actives . some ( function ( p , dimension ) { return within [ __ . dimensions [ p ] . type ] ( d , p , dimension ) ; } ) ; default : throw new Error ( "Unknown brush predicate " + __ . brushPredicate ) ; } } ) ; }
1855	function consecutive ( first , second ) { var length = d3 . keys ( __ . dimensions ) . length ; return d3 . keys ( __ . dimensions ) . some ( function ( d , i ) { return ( d === first ) ? i + i < length && __ . dimensions [ i + 1 ] === second : false ; } ) ; }
1856	function convertProperty ( originalKey , originalValue , isRtl ) { const key = getPropertyDoppelganger ( originalKey , isRtl ) const value = getValueDoppelganger ( key , originalValue , isRtl ) return { key , value } }
1857	function getPropertyDoppelganger ( property , isRtl ) { const convertedProperty = isRtl ? propertiesToConvert . rtl [ property ] : propertiesToConvert . ltr [ property ] return convertedProperty || property }
1858	function ReadFileCache ( sourceDir , charset ) { assert . ok ( this instanceof ReadFileCache ) ; assert . strictEqual ( typeof sourceDir , "string" ) ; this . charset = charset ; EventEmitter . call ( this ) ; Object . defineProperties ( this , { sourceDir : { value : sourceDir } , sourceCache : { value : { } } } ) ; }
1859	function done ( err , resource ) { totalRequestElapsed += ( ( new Date ( ) . getTime ( ) ) - started ) ; ++ totalRequests ; stats . avgFetchTime = parseInt ( totalRequestElapsed / totalRequests ) ; if ( err || verbose ) util . log ( 'cache|execute|done|err=' + err + '|result=' + ( resource ? 'found' : 'null' ) ) ; if ( err ) { ++ stats . failed ; } if ( ! err && defaultCacheTTL ) { if ( stats . inCache >= defaultCacheSize ) { weedOutCache ( ) ; } var now = new Date ( ) . getTime ( ) ; resourceCache [ key ] = { 'key' : key , 'epoch' : now , 'access' : now , 'expire' : defaultCacheTTL , 'hits' : 0 , 'data' : resource } ; ++ stats . inCache ; } var pendingRequests = requestQueue [ key ] ; delete requestQueue [ key ] ; for ( var i = 0 , size = pendingRequests . length ; i < size ; ++ i ) { if ( debug ) util . log ( 'cache|calling=' + i + '|err=' + err + '|resource=' + ( resource ? 'found' : 'null' ) ) ; if ( ! err && defaultCacheTTL ) { ++ resourceCache [ key ] . hits ; } pendingRequests [ i ] . call ( this , err , resource , resourceCache [ key ] ) ; -- stats . waiting ; } -- stats . fetching ; if ( stats . fetching === 0 && stats . waiting === 0 ) { self . emit ( 'stats' , stats ) ; } else { bufferedEmitter . call ( self , 'stats' , stats ) ; } }
1860	function ( options ) { options = ( options || { } ) ; this . agent = options . agent ; this . defaults = options . defaults || { } ; this . log = options . logger || ( new Ax ( { level : "info" } ) ) ; this . _sharedCookieJar = new CookieJar ( ) ; this . logCurl = options . logCurl || false ; }
1861	function ( level , message ) { var debug = ( level == "debug" || level == "error" ) ; if ( ! message ) { return message . toString ( ) ; } if ( typeof ( message ) == "object" ) { if ( message instanceof Error && debug ) { return message . stack ; } else { return inspect ( message ) ; } } else { return message . toString ( ) ; } }
1862	function ( options ) { this . log = options . logger ; this . cookieJar = options . cookieJar ; this . encoding = options . encoding ; this . logCurl = options . logCurl ; processOptions ( this , options || { } ) ; createRequest ( this ) ; }
1863	function ( request , options ) { request . log . debug ( "Processing request options .." ) ; request . emitter = ( new Emitter ) ; request . agent = options . agent ; if ( options . on ) { for ( var key in options . on ) { if ( options . on . hasOwnProperty ( key ) ) { request . emitter . on ( key , options . on [ key ] ) ; } } } if ( ! options . url && ! options . host ) { request . emitter . emit ( "request_error" , new Error ( "No url or url options (host, port, etc.)" ) ) ; return ; } if ( options . url ) { if ( options . proxy ) { request . url = options . proxy ; request . path = options . url ; } else { request . url = options . url ; } } request . query = options . query || options . parameters || request . query ; request . method = options . method ; request . setHeader ( "user-agent" , options . agent || "Shred" ) ; request . setHeaders ( options . headers ) ; if ( request . cookieJar ) { var cookies = request . cookieJar . getCookies ( CookieAccessInfo ( request . host , request . path ) ) ; if ( cookies . length ) { var cookieString = request . getHeader ( 'cookie' ) || '' ; for ( var cookieIndex = 0 ; cookieIndex < cookies . length ; ++ cookieIndex ) { if ( cookieString . length && cookieString [ cookieString . length - 1 ] != ';' ) { cookieString += ';' ; } cookieString += cookies [ cookieIndex ] . name + '=' + cookies [ cookieIndex ] . value + ';' ; } request . setHeader ( "cookie" , cookieString ) ; } } if ( options . body || options . content ) { request . content = options . body || options . content ; } request . timeout = options . timeout ; }
1864	function ( event ) { var emitter = request . emitter ; var textStatus = STATUS_CODES [ response . status ] ? STATUS_CODES [ response . status ] . toLowerCase ( ) : null ; if ( emitter . listeners ( response . status ) . length > 0 || emitter . listeners ( textStatus ) . length > 0 ) { emitter . emit ( response . status , response ) ; emitter . emit ( textStatus , response ) ; } else { if ( emitter . listeners ( event ) . length > 0 ) { emitter . emit ( event , response ) ; } else if ( ! response . isRedirect ) { emitter . emit ( "response" , response ) ; } } }
1865	function ( req ) { var headers = req . getHeaders ( ) ; var headerString = "" ; for ( var key in headers ) { headerString += '-H "' + key + ": " + headers [ key ] + '" ' ; } var bodyString = "" if ( req . content ) { bodyString += "-d '" + req . content . body + "' " ; } var query = req . query ? '?' + req . query : "" ; console . log ( "curl " + "-X " + req . method . toUpperCase ( ) + " " + req . scheme + "://" + req . host + ":" + req . port + req . path + query + " " + headerString + bodyString ) ; }
1866	function ( raw , request , callback ) { var response = this ; this . _raw = raw ; this . _setHeaders . call ( this , raw . headers ) ; if ( request . cookieJar && this . getHeader ( 'set-cookie' ) ) { var cookieStrings = this . getHeader ( 'set-cookie' ) ; var cookieObjs = [ ] , cookie ; for ( var i = 0 ; i < cookieStrings . length ; i ++ ) { var cookieString = cookieStrings [ i ] ; if ( ! cookieString ) { continue ; } if ( ! cookieString . match ( / domain\= / i ) ) { cookieString += '; domain=' + request . host ; } if ( ! cookieString . match ( / path\= / i ) ) { cookieString += '; path=' + request . path ; } try { cookie = new Cookie ( cookieString ) ; if ( cookie ) { cookieObjs . push ( cookie ) ; } } catch ( e ) { console . warn ( "Tried to set bad cookie: " + cookieString ) ; } } request . cookieJar . setCookies ( cookieObjs ) ; } this . request = request ; this . client = request . client ; this . log = this . request . log ; var chunkBuffers = [ ] ; var dataLength = 0 ; raw . on ( "data" , function ( chunk ) { chunkBuffers . push ( chunk ) ; dataLength += chunk . length ; } ) ; raw . on ( "end" , function ( ) { var body ; if ( typeof Buffer === 'undefined' ) { body = chunkBuffers . join ( '' ) ; } else { body = new Buffer ( dataLength ) ; for ( var i = 0 , pos = 0 ; i < chunkBuffers . length ; i ++ ) { chunkBuffers [ i ] . copy ( body , pos ) ; pos += chunkBuffers [ i ] . length ; } } var setBodyAndFinish = function ( body ) { response . _body = new Content ( { body : body , type : response . getHeader ( "Content-Type" ) } ) ; callback ( response ) ; } if ( zlib && response . getHeader ( "Content-Encoding" ) === 'gzip' ) { zlib . gunzip ( body , function ( err , gunzippedBody ) { if ( Iconv && response . request . encoding ) { body = Iconv . fromEncoding ( gunzippedBody , response . request . encoding ) ; } else { body = gunzippedBody . toString ( ) ; } setBodyAndFinish ( body ) ; } ) } else { if ( response . request . encoding ) { body = Iconv . fromEncoding ( body , response . request . encoding ) ; } setBodyAndFinish ( body ) ; } } ) ; }
1867	function ( constructor ) { constructor . prototype . getHeader = function ( name ) { return getHeader ( this , name ) ; } ; constructor . prototype . getHeaders = function ( ) { return getHeaders ( this , arguments ) ; } ; }
1868	function ( constructor ) { constructor . prototype . _setHeader = function ( key , value ) { return setHeader ( this , key , value ) ; } ; constructor . prototype . _setHeaders = function ( hash ) { return setHeaders ( this , hash ) ; } ; }
1869	function ( constructor ) { constructor . prototype . setHeader = function ( key , value ) { return setHeader ( this , key , value ) ; } ; constructor . prototype . setHeaders = function ( hash ) { return setHeaders ( this , hash ) ; } ; }
1870	function ( constructor ) { constructor . prototype . getHeader = function ( name ) { return getHeader ( this , name ) ; } ; constructor . prototype . getHeaders = function ( ) { return getHeaders ( this , arguments ) ; } ; constructor . prototype . setHeader = function ( key , value ) { return setHeader ( this , key , value ) ; } ; constructor . prototype . setHeaders = function ( hash ) { return setHeaders ( this , hash ) ; } ; }
1871	function ( encoding ) { var enc = encoding || "utf8" ; var codecOptions = undefined ; while ( 1 ) { if ( getType ( enc ) === "String" ) enc = enc . replace ( / [- ] / g , "" ) . toLowerCase ( ) ; var codec = iconv . encodings [ enc ] ; var type = getType ( codec ) ; if ( type === "String" ) { codecOptions = { originalEncoding : enc } ; enc = codec ; } else if ( type === "Object" && codec . type != undefined ) { codecOptions = codec ; enc = codec . type ; } else if ( type === "Function" ) return codec ( codecOptions ) ; else throw new Error ( "Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')" ) ; } }
1872	function ( options ) { if ( ! options . chars || ( options . chars . length !== 128 && options . chars . length !== 256 ) ) throw new Error ( "Encoding '" + options . type + "' has incorrect 'chars' (must be of len 128 or 256)" ) ; if ( options . chars . length === 128 ) options . chars = asciiString + options . chars ; if ( ! options . charsBuf ) { options . charsBuf = new Buffer ( options . chars , 'ucs2' ) ; } if ( ! options . revCharsBuf ) { options . revCharsBuf = new Buffer ( 65536 ) ; var defChar = iconv . defaultCharSingleByte . charCodeAt ( 0 ) ; for ( var i = 0 ; i < options . revCharsBuf . length ; i ++ ) options . revCharsBuf [ i ] = defChar ; for ( var i = 0 ; i < options . chars . length ; i ++ ) options . revCharsBuf [ options . chars . charCodeAt ( i ) ] = i ; } return { toEncoding : function ( str ) { str = ensureString ( str ) ; var buf = new Buffer ( str . length ) ; var revCharsBuf = options . revCharsBuf ; for ( var i = 0 ; i < str . length ; i ++ ) buf [ i ] = revCharsBuf [ str . charCodeAt ( i ) ] ; return buf ; } , fromEncoding : function ( buf ) { buf = ensureBuffer ( buf ) ; var charsBuf = options . charsBuf ; var newBuf = new Buffer ( buf . length * 2 ) ; var idx1 = 0 , idx2 = 0 ; for ( var i = 0 , _len = buf . length ; i < _len ; i ++ ) { idx1 = buf [ i ] * 2 ; idx2 = i * 2 ; newBuf [ idx2 ] = charsBuf [ idx1 ] ; newBuf [ idx2 + 1 ] = charsBuf [ idx1 + 1 ] ; } return newBuf . toString ( 'ucs2' ) ; } } ; }
1873	function ( options ) { var table = options . table , key , revCharsTable = options . revCharsTable ; if ( ! table ) { throw new Error ( "Encoding '" + options . type + "' has incorect 'table' option" ) ; } if ( ! revCharsTable ) { revCharsTable = options . revCharsTable = { } ; for ( key in table ) { revCharsTable [ table [ key ] ] = parseInt ( key ) ; } } return { toEncoding : function ( str ) { str = ensureString ( str ) ; var strLen = str . length ; var bufLen = strLen ; for ( var i = 0 ; i < strLen ; i ++ ) if ( str . charCodeAt ( i ) >> 7 ) bufLen ++ ; var newBuf = new Buffer ( bufLen ) , gbkcode , unicode , defaultChar = revCharsTable [ iconv . defaultCharUnicode . charCodeAt ( 0 ) ] ; for ( var i = 0 , j = 0 ; i < strLen ; i ++ ) { unicode = str . charCodeAt ( i ) ; if ( unicode >> 7 ) { gbkcode = revCharsTable [ unicode ] || defaultChar ; newBuf [ j ++ ] = gbkcode >> 8 ; newBuf [ j ++ ] = gbkcode & 0xFF ; } else { newBuf [ j ++ ] = unicode ; } } return newBuf ; } , fromEncoding : function ( buf ) { buf = ensureBuffer ( buf ) ; var bufLen = buf . length , strLen = 0 ; for ( var i = 0 ; i < bufLen ; i ++ ) { strLen ++ ; if ( buf [ i ] & 0x80 ) i ++ ; } var newBuf = new Buffer ( strLen * 2 ) , unicode , gbkcode , defaultChar = iconv . defaultCharUnicode . charCodeAt ( 0 ) ; for ( var i = 0 , j = 0 ; i < bufLen ; i ++ , j += 2 ) { gbkcode = buf [ i ] ; if ( gbkcode & 0x80 ) { gbkcode = ( gbkcode << 8 ) + buf [ ++ i ] ; unicode = table [ gbkcode ] || defaultChar ; } else { unicode = gbkcode ; } newBuf [ j ] = unicode & 0xFF ; newBuf [ j + 1 ] = unicode >> 8 ; } return newBuf . toString ( 'ucs2' ) ; } } }
1874	function encodeUserAuth ( user ) { if ( ! user ) { return null ; } var token = user . token ; if ( token ) { var sha1 = typeof token === 'object' ? token . sha1 : token ; return 'token ' + sha1 ; } return 'Basic ' + base64 . encode ( user . username + ':' + user . password ) }
1875	function Vec4 ( ) { switch ( arguments . length ) { case 1 : var argument = arguments [ 0 ] ; this . x = argument . x || argument [ 0 ] || 0.0 ; this . y = argument . y || argument [ 1 ] || 0.0 ; this . z = argument . z || argument [ 2 ] || 0.0 ; this . w = argument . w || argument [ 3 ] || 0.0 ; break ; case 4 : this . x = arguments [ 0 ] ; this . y = arguments [ 1 ] ; this . z = arguments [ 2 ] ; this . w = arguments [ 3 ] || 0.0 ; break ; default : this . x = 0.0 ; this . y = 0.0 ; this . z = 0.0 ; this . w = 0.0 ; break ; } }
1876	function create ( EConstructor ) { FormattedError . displayName = EConstructor . displayName || EConstructor . name return FormattedError function FormattedError ( format ) { if ( format ) { format = formatter . apply ( null , arguments ) } return new EConstructor ( format ) } }
1877	function Mat44 ( that ) { that = that || [ 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ] ; if ( that instanceof Array ) { this . data = that ; } else { this . data = new Array ( 16 ) ; this . data [ 0 ] = that . data [ 0 ] ; this . data [ 1 ] = that . data [ 1 ] ; this . data [ 2 ] = that . data [ 2 ] ; this . data [ 3 ] = that . data [ 3 ] ; this . data [ 4 ] = that . data [ 4 ] ; this . data [ 5 ] = that . data [ 5 ] ; this . data [ 6 ] = that . data [ 6 ] ; this . data [ 7 ] = that . data [ 7 ] ; this . data [ 8 ] = that . data [ 8 ] ; this . data [ 9 ] = that . data [ 9 ] ; this . data [ 10 ] = that . data [ 10 ] ; this . data [ 11 ] = that . data [ 11 ] ; this . data [ 12 ] = that . data [ 12 ] ; this . data [ 13 ] = that . data [ 13 ] ; this . data [ 14 ] = that . data [ 14 ] ; this . data [ 15 ] = that . data [ 15 ] ; } }
1878	function Vec2 ( ) { switch ( arguments . length ) { case 1 : var argument = arguments [ 0 ] ; this . x = argument . x || argument [ 0 ] || 0.0 ; this . y = argument . y || argument [ 1 ] || 0.0 ; break ; case 2 : this . x = arguments [ 0 ] ; this . y = arguments [ 1 ] ; break ; default : this . x = 0 ; this . y = 0 ; break ; } }
1879	function Quaternion ( ) { switch ( arguments . length ) { case 1 : var argument = arguments [ 0 ] ; if ( argument . w !== undefined ) { this . w = argument . w ; } else if ( argument [ 0 ] !== undefined ) { this . w = argument [ 0 ] ; } else { this . w = 1.0 ; } this . x = argument . x || argument [ 1 ] || 0.0 ; this . y = argument . y || argument [ 2 ] || 0.0 ; this . z = argument . z || argument [ 3 ] || 0.0 ; break ; case 4 : this . w = arguments [ 0 ] ; this . x = arguments [ 1 ] ; this . y = arguments [ 2 ] ; this . z = arguments [ 3 ] ; break ; default : this . w = 1 ; this . x = 0 ; this . y = 0 ; this . z = 0 ; break ; } }
1880	function Vec3 ( ) { switch ( arguments . length ) { case 1 : var argument = arguments [ 0 ] ; this . x = argument . x || argument [ 0 ] || 0.0 ; this . y = argument . y || argument [ 1 ] || 0.0 ; this . z = argument . z || argument [ 2 ] || 0.0 ; break ; case 3 : this . x = arguments [ 0 ] ; this . y = arguments [ 1 ] ; this . z = arguments [ 2 ] ; break ; default : this . x = 0.0 ; this . y = 0.0 ; this . z = 0.0 ; break ; } }
1881	function ( ) { if ( ! document . getElementById ( "snackbar-container" ) ) { var snackbarContainer = document . createElement ( "div" ) ; snackbarContainer . setAttribute ( "id" , "snackbar-container" ) ; document . body . appendChild ( snackbarContainer ) ; } }
1882	function ( element ) { var __self = this ; element . addEventListener ( "click" , function ( ) { if ( typeof __self . callback == "function" ) { __self . callback ( ) ; } element . setAttribute ( "class" , "snackbar" ) ; __self . destroy ( element ) ; } ) ; element . addEventListener ( "mouseenter" , function ( ) { __self . timer . pause ( ) ; } ) ; element . addEventListener ( "mouseout" , function ( ) { __self . timer . resume ( ) ; } ) ; }
1883	function ( newOptions ) { var __self = this , options = newOptions || { } ; for ( var opt in this . options ) { if ( __self . options . hasOwnProperty ( opt ) && ! options . hasOwnProperty ( opt ) ) { options [ opt ] = __self . options [ opt ] ; } } return options ; }
1884	function ( Vue ) { var __self = this ; Vue . prototype . $snackbar = { } ; Vue . prototype . $snackbar . create = function ( data , options , callback ) { __self . create ( data , options , callback ) ; } ; }
1885	function Transform ( that ) { that = that || { } ; if ( that . data instanceof Array ) { that = that . decompose ( ) ; this . rotation = that . rotation ; this . translation = that . translation || new Vec3 ( ) ; this . scale = that . scale ; } else { this . rotation = that . rotation ? new Quaternion ( that . rotation ) : new Quaternion ( ) ; this . translation = that . translation ? new Vec3 ( that . translation ) : new Vec3 ( ) ; if ( typeof that . scale === 'number' ) { this . scale = new Vec3 ( that . scale , that . scale , that . scale ) ; } else { this . scale = that . scale ? new Vec3 ( that . scale ) : new Vec3 ( 1 , 1 , 1 ) ; } } }
1886	function Triangle ( ) { switch ( arguments . length ) { case 1 : var arg = arguments [ 0 ] ; this . a = new Vec3 ( arg [ 0 ] || arg . a ) ; this . b = new Vec3 ( arg [ 1 ] || arg . b ) ; this . c = new Vec3 ( arg [ 2 ] || arg . c ) ; break ; case 3 : this . a = new Vec3 ( arguments [ 0 ] ) ; this . b = new Vec3 ( arguments [ 1 ] ) ; this . c = new Vec3 ( arguments [ 2 ] ) ; break ; default : this . a = new Vec3 ( 0 , 0 , 0 ) ; this . b = new Vec3 ( 1 , 0 , 0 ) ; this . c = new Vec3 ( 1 , 1 , 0 ) ; break ; } }
1887	function bash ( str , pattern , options ) { if ( typeof str !== 'string' ) { throw new TypeError ( 'expected a string' ) ; } if ( typeof pattern !== 'string' ) { throw new TypeError ( 'expected a string' ) ; } if ( isWindows ( ) ) { throw new Error ( 'bash-match does not work on windows' ) ; } try { var opts = createOptions ( pattern , options ) ; var res = spawn . sync ( getBashPath ( ) , cmd ( str , pattern , opts ) , opts ) ; var err = toString ( res . stderr ) ; if ( err ) { return handleError ( err , opts ) ; } return ! ! toString ( res . stdout ) ; } catch ( err ) { return handleError ( err , opts ) ; } }
1888	function cmd ( str , pattern , options ) { var valid = [ 'dotglob' , 'extglob' , 'failglob' , 'globstar' , 'nocaseglob' , 'nullglob' ] ; var args = [ ] ; for ( var key in options ) { if ( options . hasOwnProperty ( key ) && valid . indexOf ( key ) !== - 1 ) { args . push ( '-O' , key ) ; } } args . push ( '-c' , 'IFS=$"\n"; if [[ "' + \n + str + '" = ' + pattern ) ; ' ]]; then echo true; fi' }
1889	function createOptions ( pattern , options ) { if ( options && options . normalized === true ) return options ; var opts = extend ( { cwd : process . cwd ( ) } , options ) ; if ( opts . nocase === true ) opts . nocaseglob = true ; if ( opts . nonull === true ) opts . nullglob = true ; if ( opts . dot === true ) opts . dotglob = true ; if ( ! opts . hasOwnProperty ( 'globstar' ) && pattern . indexOf ( '**' ) !== - 1 ) { opts . globstar = true ; } if ( ! opts . hasOwnProperty ( 'extglob' ) && isExtglob ( pattern ) ) { opts . extglob = true ; } opts . normalized = true ; return opts ; }
1890	function getBashPath ( ) { if ( bashPath ) return bashPath ; if ( fs . existsSync ( '/usr/local/bin/bash' ) ) { bashPath = '/usr/local/bin/bash' ; } else if ( fs . existsSync ( '/bin/bash' ) ) { bashPath = '/bin/bash' ; } else { bashPath = 'bash' ; } return bashPath ; }
1891	function Memory ( options ) { options = options || { } ; var self = this ; self . flush = options . db . _db . _memory . flush || false ; self . flushInterval = options . db . _db . _memory . flushInterval || 10000 ; self . flushFile = options . file ; self . memoryTable = [ ] ; console . log ( 'Data will be handled using \'Memory\' driver' ) ; \' \' var content = util . fileSystem . readSync ( self . flushFile ) ; }
1892	function deductcost ( ) { var cost = [ ] ; if ( ! giving . have || giving . have . length < 1 ) return ; var cost = [ ] ; for ( var i = 0 ; i < giving . have . length ; i ++ ) { for ( var j = 0 ; j < giving . have [ i ] . length ; j ++ ) { cost . push ( giving . have [ i ] [ j ] ) ; } } if ( typeof cost [ 0 ] === 'string' ) cost = [ cost ] ; function deduct ( from , amt ) { var current = parseInt ( from . getAttribute ( 'data-quantity' ) ) ; current -= amt ; from . setAttribute ( 'data-quantity' , current ) ; updateAmounts ( from ) ; if ( current < 1 ) { from . setAttribute ( 'data-type' , 'none' ) ; from . innerHTML = '' ; } } [ ] . forEach . call ( craftable . querySelectorAll ( 'li' ) , function ( li , i ) { var row = Math . floor ( i / 3 ) ; var has = ( li . getAttribute ( 'data-type' ) || 'none' ) . toLowerCase ( ) ; for ( var c = 0 ; c < cost . length ; c ++ ) { if ( cost [ c ] [ 0 ] . toLowerCase ( ) === has ) { var price = cost [ c ] [ 1 ] ; cost . splice ( c , 1 ) ; deduct ( li , price ) ; return false ; } } } ) ; }
1893	function ( sub_node ) { if ( sub_node ) { walk ( sub_node , depth + 1 ) ; } else if ( node . pages ) { node . pages . forEach ( function ( sub_node , name ) { walk ( sub_node , depth + 1 ) ; } ) ; } }
1894	function ( provides ) { if ( _ . isArray ( provides ) ) { this . _arguments = this . _provides = ( ! this . _provides ) ? provides : this . _provides . concat ( provides ) ; } else { this . _provides = _ . extend ( { } , this . _provides , provides ) ; this . _arguments = _ . map ( this . deps , function ( key ) { return this . _provides [ key ] ; } , this ) ; } return this ; }
1895	function ( context , callback ) { if ( arguments . length === 1 ) { callback = context ; context = this . _context ; } if ( this . isAsync ) { var asyncArgs = this . _arguments . slice ( ) ; asyncArgs . push ( callback ) ; this . fn . apply ( context , asyncArgs ) ; } else { if ( callback ) { try { callback ( null , this . fn . apply ( context , this . _arguments ) ) ; } catch ( e ) { callback ( e ) ; } } else { return this . fn . apply ( context , this . _arguments ) ; } } }
1896	function each ( arr , callback ) { var wrapper = this ; if ( this . isAsync ) { return async . each ( arr , function ( item , cb ) { wrapper . call ( item , cb ) ; } , callback ) ; } else { arr . each ( function ( item ) { wrapper . call ( item ) ; } ) ; if ( callback ) { callback ( ) ; } } }
1897	function map ( arr , callback ) { var wrapper = this ; if ( this . isAsync ) { async . map ( arr , function ( item , cb ) { wrapper . call ( item , cb ) ; } , callback ) ; } else { callback ( null , arr . map ( function ( item ) { return wrapper . call ( item ) ; } ) ) ; } }
1898	function ( selectedDates , dateStr , instance ) { that . setProperty ( "dateValue" , selectedDates , true ) ; that . fireOnChange ( { selectedDates : selectedDates , dateStr : dateStr , instance : instance } ) ; }
1899	function startServer ( options ) { options = initOptions ( options ) ; var app = connect ( ) , root = options . root , TEST = process . env . TEST , isSilent = options . silent || TEST ; if ( ! isSilent ) { app . use ( log ) ; } var smOpts = { } ; var smOptMap = { ftpl : 'template' , style : 'style' } ; Object . keys ( smOptMap ) . forEach ( function ( key ) { if ( options [ key ] !== undefined ) smOpts [ smOptMap [ key ] ] = options [ key ] ; } ) ; app . use ( serveMarkdown ( root , smOpts ) ) ; app . use ( serveStatic ( root , { index : [ 'index.html' ] } ) ) ; app . use ( serveIndex ( root , { icon : true , template : options . dtpl , stylesheet : options . style , view : options . view } ) ) ; debug ( 'server run in ' + ( process . env . TEST ? 'TEST' : 'PRODUCTION' ) + ' mode' ) if ( ! TEST ) { app . listen ( options . port ) ; showSuccessInfo ( options ) ; } return app ; }
1900	function showSuccessInfo ( options ) { if ( options . silent ) return ; console . log ( chalk . blue ( 'serve start Success: ' ) + '\n' + \n + chalk . green ( '\t url ' ) + \t + chalk . grey ( 'http://127.0.0.1:' ) + chalk . red ( options . port ) + chalk . grey ( '/' ) + '\n' ) ; }
1901	function log ( req , res , next ) { console . log ( '[' + chalk . grey ( ts ( ) ) + '] ' + chalk . white ( decodeURI ( req . url ) ) ) ; next ( ) ; }
1902	function ( valueToSet , type , iface , propertyKeys ) { type = type . toLowerCase ( ) ; propertyKeys . forEach ( function ( propertyKey ) { if ( type == 'get' ) valueToSet [ 'Get' + propertyKey ] = function ( callback ) { iface . getProperty ( propertyKey , callback ) ; } else valueToSet [ 'Set' + propertyKey ] = function ( value , callback ) { iface . setProperty ( propertyKey , value , callback ) ; } } ) ; }
1903	function init ( user_id , secret , storage ) { API_USER_ID = user_id ; API_SECRET = secret ; TOKEN_STORAGE = storage ; var hashName = md5 ( API_USER_ID + '::' + API_SECRET ) ; if ( fs . existsSync ( TOKEN_STORAGE + hashName ) ) { TOKEN = fs . readFileSync ( TOKEN_STORAGE + hashName , { encoding : 'utf8' } ) ; } if ( ! TOKEN . length ) { getToken ( ) ; } }
1904	function sendRequest ( path , method , data , useToken , callback ) { var headers = { } headers [ 'Content-Type' ] = 'application/json' ; headers [ 'Content-Length' ] = Buffer . byteLength ( JSON . stringify ( data ) ) ; if ( useToken && TOKEN . length ) { headers [ 'Authorization' ] = 'Bearer ' + TOKEN ; } if ( method === undefined ) { method = 'POST' ; } if ( useToken === undefined ) { useToken = false ; } var options = { path : '/' + path , port : 443 , hostname : API_URL , method : method , headers : headers , } ; var req = https . request ( options , function ( response ) { var str = '' ; response . on ( 'data' , function ( chunk ) { if ( response . statusCode == 401 ) { getToken ( ) ; sendRequest ( path , method , data , true , callback ) ; } else { str += chunk ; } } ) ; response . on ( 'end' , function ( ) { if ( response . statusCode != 401 ) { try { var answer = JSON . parse ( str ) ; } catch ( ex ) { var answer = returnError ( ) ; } callback ( answer ) ; } } ) ; } ) ; req . write ( JSON . stringify ( data ) ) ; req . end ( ) ; }
1905	function getToken ( ) { var data = { grant_type : 'client_credentials' , client_id : API_USER_ID , client_secret : API_SECRET } sendRequest ( 'oauth/access_token' , 'POST' , data , false , saveToken ) ; function saveToken ( data ) { TOKEN = data . access_token ; var hashName = md5 ( API_USER_ID + '::' + API_SECRET ) ; fs . writeFileSync ( TOKEN_STORAGE + hashName , TOKEN ) ; } }
1906	function returnError ( message ) { var data = { is_error : 1 } ; if ( message !== undefined && message . length ) { data [ 'message' ] = message } return data ; }
1907	function createAddressBook ( callback , bookName ) { if ( ( bookName === undefined ) || ( ! bookName . length ) ) { return callback ( returnError ( "Empty book name" ) ) ; } var data = { bookName : bookName } ; sendRequest ( 'addressbooks' , 'POST' , data , true , callback ) ; }
1908	function editAddressBook ( callback , id , bookName ) { if ( ( id === undefined ) || ( bookName === undefined ) || ( ! bookName . length ) ) { return callback ( returnError ( "Empty book name or book id" ) ) ; } var data = { name : bookName } ; sendRequest ( 'addressbooks/' + id , 'PUT' , data , true , callback ) ; }
1909	function removeAddressBook ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty book id' ) ) ; } sendRequest ( 'addressbooks/' + id , 'DELETE' , { } , true , callback ) ; }
1910	function getBookInfo ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty book id' ) ) ; } sendRequest ( 'addressbooks/' + id , 'GET' , { } , true , callback ) ; }
1911	function getEmailsFromBook ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty book id' ) ) ; } sendRequest ( 'addressbooks/' + id + '/emails' , 'GET' , { } , true , callback ) ; }
1912	function addEmails ( callback , id , emails ) { if ( ( id === undefined ) || ( emails === undefined ) || ( ! emails . length ) ) { return callback ( returnError ( "Empty email or book id" ) ) ; } var data = { emails : serialize ( emails ) } ; sendRequest ( 'addressbooks/' + id + '/emails' , 'POST' , data , true , callback ) ; }
1913	function getEmailInfo ( callback , id , email ) { if ( ( id === undefined ) || ( email === undefined ) || ( ! email . length ) ) { return callback ( returnError ( "Empty email or book id" ) ) ; } sendRequest ( 'addressbooks/' + id + '/emails/' + email , 'GET' , { } , true , callback ) ; }
1914	function campaignCost ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty book id' ) ) ; } sendRequest ( 'addressbooks/' + id + '/cost' , 'GET' , { } , true , callback ) ; }
1915	function listCampaigns ( callback , limit , offset ) { var data = { } if ( limit === undefined ) { limit = null ; } else { data [ 'limit' ] = limit ; } if ( offset === undefined ) { offset = null ; } else { data [ 'offset' ] = offset ; } sendRequest ( 'campaigns' , 'GET' , data , true , callback ) ; }
1916	function getCampaignInfo ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty book id' ) ) ; } sendRequest ( 'campaigns/' + id , 'GET' , { } , true , callback ) ; }
1917	function campaignStatByCountries ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty book id' ) ) ; } sendRequest ( 'campaigns/' + id + '/countries' , 'GET' , { } , true , callback ) ; }
1918	function campaignStatByReferrals ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty book id' ) ) ; } sendRequest ( 'campaigns/' + id + '/referrals' , 'GET' , { } , true , callback ) ; }
1919	function createCampaign ( callback , senderName , senderEmail , subject , body , bookId , name , attachments ) { if ( ( senderName === undefined ) || ( ! senderName . length ) || ( senderEmail === undefined ) || ( ! senderEmail . length ) || ( subject === undefined ) || ( ! subject . length ) || ( body === undefined ) || ( ! body . length ) || ( bookId === undefined ) ) { return callback ( returnError ( 'Not all data.' ) ) ; } if ( name === undefined ) { name = '' ; } if ( attachments === undefined ) { attachments = '' ; } if ( attachments . length ) { attachments = serialize ( attachments ) ; } var data = { sender_name : senderName , sender_email : senderEmail , subject : subject , body : base64 ( body ) , list_id : bookId , name : name , attachments : attachments } sendRequest ( 'campaigns' , 'POST' , data , true , callback ) ; }
1920	function addSender ( callback , senderName , senderEmail ) { if ( ( senderEmail === undefined ) || ( ! senderEmail . length ) || ( senderName === undefined ) || ( ! senderName . length ) ) { return callback ( returnError ( 'Empty sender name or email' ) ) ; } var data = { email : senderEmail , name : senderName } sendRequest ( 'senders' , 'POST' , data , true , callback ) ; }
1921	function activateSender ( callback , senderEmail , code ) { if ( ( senderEmail === undefined ) || ( ! senderEmail . length ) || ( code === undefined ) || ( ! code . length ) ) { return callback ( returnError ( 'Empty email or activation code' ) ) ; } var data = { code : code } sendRequest ( 'senders/' + senderEmail + '/code' , 'POST' , data , true , callback ) ; }
1922	function getSenderActivationMail ( callback , senderEmail ) { if ( ( senderEmail === undefined ) || ( ! senderEmail . length ) ) { return callback ( returnError ( 'Empty email' ) ) ; } sendRequest ( 'senders/' + senderEmail + '/code' , 'GET' , { } , true , callback ) ; }
1923	function getEmailGlobalInfo ( callback , email ) { if ( ( email === undefined ) || ( ! email . length ) ) { return callback ( returnError ( 'Empty email' ) ) ; } sendRequest ( 'emails/' + email , 'GET' , { } , true , callback ) ; }
1924	function removeEmailFromAllBooks ( callback , email ) { if ( ( email === undefined ) || ( ! email . length ) ) { return callback ( returnError ( 'Empty email' ) ) ; } sendRequest ( 'emails/' + email , 'DELETE' , { } , true , callback ) ; }
1925	function emailStatByCampaigns ( callback , email ) { if ( ( email === undefined ) || ( ! email . length ) ) { return callback ( returnError ( 'Empty email' ) ) ; } sendRequest ( 'emails/' + email + '/campaigns' , 'GET' , { } , true , callback ) ; }
1926	function addToBlackList ( callback , emails , comment ) { if ( ( emails === undefined ) || ( ! emails . length ) ) { return callback ( returnError ( 'Empty email' ) ) ; } if ( comment === undefined ) { comment = '' ; } var data = { emails : base64 ( emails ) , comment : comment } sendRequest ( 'blacklist' , 'POST' , data , true , callback ) ; }
1927	function removeFromBlackList ( callback , emails ) { if ( ( emails === undefined ) || ( ! emails . length ) ) { return callback ( returnError ( 'Empty emails' ) ) ; } var data = { emails : base64 ( emails ) , } sendRequest ( 'blacklist' , 'DELETE' , data , true , callback ) ; }
1928	function smtpGetEmailInfoById ( callback , id ) { if ( ( id === undefined ) || ( ! id . length ) ) { return callback ( returnError ( 'Empty id' ) ) ; } sendRequest ( 'smtp/emails/' + id , 'GET' , { } , true , callback ) ; }
1929	function minifyFile ( resHtml , outputPath ) { var resHtml = minify ( resHtml , opt , function ( err ) { if ( err ) { console . error ( 'error will processing file.' ) ; } } ) ; console . log ( '' ) ; console . log ( 'Output file name : ' + outputPath ) ; console . log ( '' ) ; writeFile ( resHtml , outputPath ) ; }
1930	function writeFile ( resHtml , outputPath ) { fs . writeFile ( outputPath , resHtml , function ( err ) { if ( err ) { console . log ( '' ) ; console . log ( 'File error: ' + err + '. Exit.' ) ; } else { console . log ( '' ) ; console . log ( 'All done. Exit.' . green ) ; } } ) ; }
1931	function Cookie ( options ) { this . options = options || { } ; this . options . expires = typeof this . options . expires === 'number' ? this . options . expires : 30 ; this . options . path = this . options . path !== undefined ? this . options . path : '/' ; this . options . secure = typeof this . options . secure === 'boolean' ? this . options . secure : false ; }
1932	function set ( key , value , options ) { options = options || this . options ; var days = parseInt ( options . expires || - 1 ) ; if ( value !== undefined && typeof value !== 'function' ) { var t = new Date ( ) ; t . setDate ( ( t . getDate ( ) + days ) ) ; var res = ( document . cookie = [ this . encode ( key ) , '=' , this . stringify ( value ) , options . expires ? '; expires=' + t . toUTCString ( ) : '' , options . path ? '; path=' + options . path : '' , options . domain ? '; domain=' + options . domain : '' , options . secure ? '; secure' : '' ] . join ( '' ) ) ; return res ; } }
1933	function get ( key , value ) { var i , parts , name , cookie ; var result = key ? undefined : { } ; var cookies = ( document . cookie || '' ) . split ( '; ' ) ; for ( i = 0 ; i < cookies . length ; i ++ ) { parts = cookies [ i ] . split ( '=' ) ; name = this . decode ( parts . shift ( ) ) ; cookie = parts . join ( '=' ) ; if ( key && key === name ) { result = this . read ( cookie , value ) ; break ; } if ( ! key && ( cookie = this . read ( cookie ) ) !== undefined ) { result [ name ] = cookie ; } } return result ; }
1934	function del ( key , options ) { if ( ! options ) { options = { } ; for ( var z in this . options ) { options [ z ] = this . options [ z ] ; } } options . expires = - 1 ; this . set ( key , '' , options ) ; }
1935	function clear ( except , options ) { var keys = this . get ( ) , z ; except = except || [ ] ; for ( z in keys ) { if ( ~ except . indexOf ( z ) ) { continue ; } this . del ( z , options ) ; } }
1936	function curry2 ( fn , self ) { var out = function ( ) { if ( arguments . length === 0 ) return out return arguments . length > 1 ? fn . apply ( self , arguments ) : bind . call ( fn , self , arguments [ 0 ] ) } out . uncurry = function uncurry ( ) { return fn } return out }
1937	function cloneGalleryItem ( inst , element ) { const clone = element . cloneNode ( true ) clone . removeAttribute ( 'id' ) clone . classList . add ( 'mh-gallery-item--sort-helper' ) return clone }
1938	function ( localFilePath ) { let contentType = mime . lookup ( localFilePath ) ; let standerFilePath = localFilePath . replace ( / \\ / g , '/' ) ; fs . readFile ( localFilePath , function ( readFileErr , fileData ) { if ( readFileErr ) { throw readFileErr ; } const putConfig = { Bucket : bucket . Name , Body : fileData , Key : standerFilePath , ContentType : contentType , AccessControlAllowOrigin : options . AccessControlAllowOrigin || '*' , CacheControl : options . CacheControl || 'no-cache' , Expires : options . Expires || null } ; if ( options . contentEncoding ) { putConfig . ContentEncoding = options . contentEncoding ; } oss . putObject ( putConfig , function ( putObjectErr ) { if ( putObjectErr ) { console . error ( 'error:' , putObjectErr ) ; return putObjectErr ; } console . log ( 'upload success: ' + localFilePath ) ; if ( bucketPaths . indexOf ( standerFilePath ) === - 1 ) { bucketPaths . push ( standerFilePath ) ; } if ( localPaths . indexOf ( standerFilePath ) === - 1 ) { localPaths . push ( standerFilePath ) ; } if ( options . oss . autoRefreshCDN && cdn ) { if ( options . cdn . refreshQuota < 1 ) { console . error ( 'There is no refresh cdn url quota today.' ) ; return ; } let cdnDomain = '' ; if ( / ^http / . test ( options . cdn . domain ) ) { cdnDomain = options . cdn . domain . replace ( / ^https?:?\/?\/? / , '' ) ; options . cdn . secure === undefined && ( options . cdn . secure = / ^https / . test ( options . cdn . domein ) ) ; } else { cdnDomain = options . cdn . domain ; } let cdnObjectPath = url . format ( { protocol : options . oss . secure ? 'https' : 'http' , hostname : cdnDomain , pathname : standerFilePath } ) ; options . debug && console . log ( 'Refreshing CDN file: ' , cdnObjectPath ) ; cdn . refreshObjectCaches ( { ObjectType : 'File' , ObjectPath : cdnObjectPath } , function ( refreshCDNErr ) { if ( refreshCDNErr ) { console . error ( 'refresh cdn error: ' , refreshCDNErr ) ; } else { options . cdn . refreshQuota -- ; console . log ( 'Refresh cdn file success: ' , cdnObjectPath ) ; } } ) ; } } ) ; } ) ; }
1939	function ( filePath ) { let standerPath = filePath . replace ( / \\ / g , '/' ) ; oss . deleteObject ( { Bucket : bucket . Name , Key : standerPath } , function ( err ) { if ( err ) { console . log ( 'error:' , err ) ; return err ; } let bucketIndex = bucketPaths . indexOf ( standerPath ) ; if ( bucketIndex !== - 1 ) { bucketPaths . splice ( bucketIndex , 1 ) ; } let localIndex = localPaths . indexOf ( standerPath ) ; if ( localIndex !== - 1 ) { localPaths . splice ( localIndex , 1 ) ; } console . log ( 'delete success:' + standerPath ) ; } ) ; }
1940	function setupDispatch ( { actions : actionHandlers = { } , schemas = { } , services = { } , middlewares = [ ] , identOptions = { } } ) { const getService = setupGetService ( schemas , services ) let dispatch = async ( action ) => { debug ( 'Dispatch: %o' , action ) return handleAction ( action , { schemas , services , dispatch , identOptions , getService } , actionHandlers ) } if ( middlewares . length > 0 ) { dispatch = compose ( ... middlewares ) ( dispatch ) } return dispatch }
1941	function nextSchedule ( schedule , allowNow = false ) { if ( schedule ) { try { const dates = later . schedule ( schedule ) . next ( 2 ) return nextDate ( dates , allowNow ) } catch ( error ) { throw TypeError ( 'Invalid schedule definition' ) } } return null }
1942	async function deleteFn ( action , { getService } = { } ) { debug ( 'Action: DELETE' ) const { type , id , service : serviceId , endpoint } = action . payload const service = ( typeof getService === 'function' ) ? getService ( type , serviceId ) : null if ( ! service ) { return createUnknownServiceError ( type , serviceId , 'DELETE' ) } const data = prepareData ( action . payload ) if ( data . length === 0 ) { return createError ( ` ${ service . id } ` , 'noaction' ) } const endpointDebug = ( endpoint ) ? ` ${ endpoint } ` : ` ${ type } ${ id } ` debug ( 'DELETE: Delete from service \'%s\' at %s.' , \' , \' ) service . id endpointDebug }
1943	async function request ( action , { getService , dispatch } ) { debug ( 'Action: REQUEST' ) const { type , service : serviceId = null , endpoint } = action . payload const service = getService ( type , serviceId ) if ( ! service ) { return createUnknownServiceError ( type , serviceId , 'GET' ) } const endpointDebug = ( endpoint ) ? ` ${ endpoint } ` : ` ${ type } ` debug ( 'REQUEST: Fetch from service %s at %s' , service . id , endpointDebug ) const { response } = await service . receive ( action , dispatch ) return response }
1944	async function getIdent ( { payload , meta } , { getService , identOptions = { } } ) { if ( ! meta . ident ) { return createError ( 'GET_IDENT: The request has no ident' , 'noaction' ) } const { type } = identOptions if ( ! type ) { return createError ( 'GET_IDENT: Integreat is not set up with authentication' , 'noaction' ) } const service = getService ( type ) if ( ! service ) { return createUnknownServiceError ( type , null , 'GET_IDENT' ) } const propKeys = preparePropKeys ( identOptions . props ) const params = prepareParams ( meta . ident , propKeys ) if ( ! params ) { return createError ( 'GET_IDENT: The request has no ident with id or withToken' , 'noaction' ) } const { response } = await service . send ( { type : 'GET' , payload : { type , ... params } , meta : { ident : { root : true } } } ) return prepareResponse ( response , payload , propKeys ) }
1945	function integreat ( { schemas : typeDefs , services : serviceDefs , mappings = [ ] , auths : authDefs = [ ] , ident : identOptions = { } } , { adapters = { } , authenticators = { } , filters = { } , transformers = { } , actions = { } } = { } , middlewares = [ ] ) { if ( ! serviceDefs || ! typeDefs ) { throw new TypeError ( 'Call integreat with at least services and schemas' ) } actions = { ... builtinActions , ... actions } const schemas = R . compose ( R . indexBy ( R . prop ( 'id' ) ) , R . map ( schema ) ) ( typeDefs ) const pluralTypes = Object . keys ( schemas ) . reduce ( ( plurals , type ) => ( { ... plurals , [ schemas [ type ] . plural ] : type } ) , { } ) const auths = authDefs . reduce ( ( auths , def ) => ( def ) ? { ... auths , [ def . id ] : { authenticator : authenticators [ def && def . authenticator ] , options : def . options , authentication : null } } : auths , { } ) const services = R . compose ( R . indexBy ( R . prop ( 'id' ) ) , R . map ( createService ( { adapters , auths , transformers , schemas , setupMapping : setupMapping ( { filters , transformers , schemas , mappings } ) } ) ) ) ( serviceDefs ) return { version , schemas , services , identType : identOptions . type , dispatch : setupDispatch ( { actions , services , schemas , middlewares , identOptions } ) , on ( eventName , serviceId , listener ) { const service = services [ serviceId ] if ( service && service . on ) { service . on ( eventName , listener ) } } , typeFromPlural ( plural ) { return pluralTypes [ plural ] } } }
1946	function scheduleToAction ( def ) { if ( ! def ) { return null } const id = def . id || null const schedule = parseSchedule ( def . schedule ) const nextTime = nextSchedule ( schedule , true ) return { ... def . action , meta : { id , schedule , queue : ( nextTime ) ? nextTime . getTime ( ) : true } } }
1947	async function get ( action , { getService } = { } ) { const { type , service : serviceId = null , onlyMappedValues = false , endpoint } = action . payload const service = ( typeof getService === 'function' ) ? getService ( type , serviceId ) : null if ( ! service ) { return createUnknownServiceError ( type , serviceId , 'GET' ) } const id = getIdFromPayload ( action . payload ) if ( Array . isArray ( id ) && ! hasCollectionEndpoint ( service . endpoints ) ) { return getIndividualItems ( id , action , getService ) } const endpointDebug = ( endpoint ) ? ` ${ endpoint } ` : ` ${ type } ${ id } ` debug ( 'GET: Fetch from service %s at %s' , service . id , endpointDebug ) const { response } = await service . send ( appendToAction ( action , { id , onlyMappedValues } ) ) return response }
1948	function sendRequest ( { adapter , serviceId } ) { return async ( { request , response , connection } ) => { if ( response ) { return response } try { response = await adapter . send ( request , connection ) return { ... response , access : request . access } } catch ( error ) { return createError ( ` ${ serviceId } ${ error } ` ) } } }
1949	function schema ( { id , plural , service , attributes : attrDefs , relationships : relDefs , access , internal = false } ) { const attributes = { ... expandFields ( attrDefs || { } ) , id : { type : 'string' } , type : { type : 'string' } , createdAt : { type : 'date' } , updatedAt : { type : 'date' } } const relationships = expandFields ( relDefs || { } ) const defaultAttrs = prepareDefaultAttrs ( attributes , attrDefs ) const defaultRels = prepareDefaultRels ( relationships , relDefs ) const castFn = cast ( { id , attributes , relationships , defaultAttrs , defaultRels } ) return { id , plural : plural || ` ${ id } ` , service , internal , attributes , relationships , access , cast ( data , { onlyMappedValues = false } = { } ) { return mapAny ( ( data ) => castFn ( data , { onlyMappedValues } ) , data ) } , castQueryParams ( relId , data ) { return castQueryParams ( relId , data , { relationships } ) } } }
1950	function mapping ( { filters , transformers , schemas = { } , mappings : mappingsArr = [ ] } = { } ) { const mappings = mappingsArr . reduce ( ( mappings , def ) => ( { ... mappings , [ def . id ] : def } ) , { } ) const createPipelineFn = createPipeline ( filters , transformers , schemas , mappings ) return ( mapping , overrideType ) => { const { id , type , schema , pipeline } = createPipelineFn ( mapping , overrideType ) if ( ! pipeline ) { return null } const mapper = mapTransform ( [ fwd ( 'data' ) , ... pipeline , rev ( set ( 'data' ) ) ] ) return { id , type , schema , fromService ( data , { onlyMappedValues = true } = { } ) { return data ? ensureArray ( ( onlyMappedValues ) ? mapper . onlyMappedValues ( data ) : mapper ( data ) ) : [ ] } , toService ( data , target = null ) { const mapped = mapper . rev . onlyMappedValues ( data ) return ( ( target ? Array . isArray ( target ) ? [ ... target ] . concat ( mapped ) : mergeDeepWith ( concatOrRight , target , mapped ) : mapped ) || null ) } } } }
1951	function mapFromService ( ) { return ( { response , request , responseMapper , mappings } ) => { if ( response . status !== 'ok' ) { return response } const type = request . params . type || Object . keys ( mappings ) const { onlyMappedValues , unmapped = false } = request . params if ( unmapped ) { return response } const { data , status = response . status , error , paging , params } = mapWithEndpoint ( responseMapper , response , request . action ) if ( status !== 'ok' ) { return removeDataProp ( { ... response , status , error } ) } const mapType = ( type ) => ( mappings [ type ] ) ? mappings [ type ] . fromService ( { ... request , data } , { onlyMappedValues } ) : [ ] return { ... response , status , ... ( ( paging ) ? { paging } : { } ) , ... ( ( params ) ? { params } : { } ) , data : ( data ) ? flatten ( mapAny ( mapType , type ) ) : undefined } } }
1952	function ( tailInfo ) { var z = this ; if ( tailInfo ) { z . q . push ( tailInfo ) ; } var ti ; for ( var i = 0 ; i < z . q . length ; ++ i ) { ti = z . q [ i ] ; if ( ti . reading ) { continue ; } if ( ! z . tails [ ti . stat . ino ] ) { z . q . splice ( i , 1 ) ; -- i ; continue ; } if ( ti . stat . size < ti . pos ) { ti . pos = 0 ; } var len = ti . stat . size - ti . pos ; z . q . splice ( i , 1 ) ; -- i ; z . readTail ( ti , len ) ; } }
1953	function ( ) { var z = this ; var l = 0 ; Object . keys ( z . tails ) . forEach ( function ( k ) { l += ( z . tails [ k ] . buf || '' ) . length ; } ) ; return l ; }
1954	function preparePipeline ( pipeline , collection = { } ) { pipeline = [ ] . concat ( pipeline ) const replaceWithFunction = ( key ) => ( typeof key === 'string' ) ? collection [ key ] : key const isFunctionOrObject = ( obj ) => obj && [ 'function' , 'object' ] . includes ( typeof obj ) return pipeline . map ( replaceWithFunction ) . filter ( isFunctionOrObject ) }
1955	function castQueryParams ( relId , data , { relationships } ) { const relationship = relationships [ relId ] if ( ! relationship . query ) { return { } } return Object . keys ( relationship . query ) . reduce ( ( params , key ) => { const value = getField ( data , relationship . query [ key ] ) if ( value === undefined ) { throw new TypeError ( 'Missing value for query param' ) } return { ... params , [ key ] : value } } , { } ) }
1956	function setupQueue ( queue ) { let dispatch = null let subscribed = false return { queue , setDispatch ( dispatchFn ) { dispatch = dispatchFn if ( ! subscribed && typeof dispatch === 'function' ) { queue . subscribe ( dispatch ) subscribed = true } } , middleware ( next ) { return middleware ( next , queue ) } , async schedule ( defs ) { return schedule ( defs , queue ) } } }
1957	async function getMeta ( { payload , meta } , { getService } ) { debug ( 'Action: GET_META' ) const { service : serviceId , endpoint , keys } = payload const id = ` ${ serviceId } ` const service = getService ( null , serviceId ) if ( ! service ) { debug ( ` ${ serviceId } ` ) return createError ( ` ${ serviceId } ` ) } const type = service . meta const metaService = getService ( type ) if ( ! metaService ) { return createError ( ` ${ service . id } ${ service . meta } ` ) } const endpointDebug = ( endpoint ) ? ` ${ endpoint } ` : ` ${ type } ${ id } ` debug ( 'GET_META: Get meta %s for service \'%s\' on service \'%s\' at %s' , \' , \' , \' , \' ) keys service . id }
1958	async function set ( action , { getService , schemas } ) { debug ( 'Action: SET' ) const { service : serviceId , data , endpoint , onlyMappedValues = true } = action . payload const type = extractType ( action , data ) const id = extractId ( data ) const service = getService ( type , serviceId ) if ( ! service ) { return createUnknownServiceError ( type , serviceId , 'SET' ) } const endpointDebug = ( endpoint ) ? ` ${ endpoint } ` : '' debug ( 'SET: Send to service %s %s' , service . id , endpointDebug ) const { response , authorizedRequestData } = await service . send ( appendToAction ( action , { id , type , onlyMappedValues } ) ) return mergeRequestAndResponseData ( response , authorizedRequestData ) }
1959	async function setMeta ( { payload , meta } , { getService } ) { debug ( 'Action: SET_META' ) const { service : serviceId , meta : metaAttrs , endpoint } = payload const id = ` ${ serviceId } ` const service = getService ( null , serviceId ) if ( ! service ) { debug ( ` ${ serviceId } ` ) return createError ( ` ${ serviceId } ` ) } const type = service . meta const metaService = getService ( type ) if ( ! metaService ) { debug ( ` ${ service . id } ${ service . meta } ` ) return { status : 'noaction' } } const endpointDebug = ( endpoint ) ? ` ${ endpoint } ` : ` ${ type } ${ id } ` debug ( 'SET_META: Send metadata %o for service \'%s\' on service \'%s\' %s' , \' , \' , \' , \' ) metaAttrs service . id metaService . id }
1960	function exportToJSONSchema ( expSpecifications , baseSchemaURL , baseTypeURL , flat = false ) { const namespaceResults = { } ; const endOfTypeURL = baseTypeURL [ baseTypeURL . length - 1 ] ; if ( endOfTypeURL !== '#' && endOfTypeURL !== '/' ) { baseTypeURL += '/' ; } for ( const ns of expSpecifications . namespaces . all ) { const lastLogger = logger ; logger = logger . child ( { shrId : ns . namespace } ) ; try { logger . debug ( 'Exporting namespace.' ) ; if ( flat ) { const { schemaId , schema } = flatNamespaceToSchema ( ns , expSpecifications . dataElements , baseSchemaURL , baseTypeURL ) ; namespaceResults [ schemaId ] = schema ; } else { const { schemaId , schema } = namespaceToSchema ( ns , expSpecifications . dataElements , baseSchemaURL , baseTypeURL ) ; namespaceResults [ schemaId ] = schema ; } logger . debug ( 'Finished exporting namespace.' ) ; } finally { logger = lastLogger ; } } return namespaceResults ; }
1961	function makeRef ( id , enclosingNamespace , baseSchemaURL ) { if ( id . namespace === enclosingNamespace . namespace ) { return '#/definitions/' + id . name ; } else { return makeShrDefinitionURL ( id , baseSchemaURL ) ; } }
1962	function isOrWasAList ( value ) { if ( value . card . isList ) { return true ; } const cardConstraints = value . constraintsFilter . own . card . constraints ; return cardConstraints . some ( ( oneCard ) => oneCard . isList ) ; }
1963	function findOptionInChoice ( choice , optionId , dataElementSpecs ) { for ( const option of choice . aggregateOptions ) { if ( optionId . equals ( option . identifier ) ) { return option ; } } for ( const option of choice . aggregateOptions ) { if ( checkHasBaseType ( optionId , option . identifier , dataElementSpecs ) ) { return option ; } } return null ; }
1964	function supportsCodeConstraint ( identifier , dataElementSpecs ) { if ( CODE . equals ( identifier ) || checkHasBaseType ( identifier , new Identifier ( 'shr.core' , 'Coding' ) , dataElementSpecs ) || checkHasBaseType ( identifier , new Identifier ( 'shr.core' , 'CodeableConcept' ) , dataElementSpecs ) ) { return true ; } const element = dataElementSpecs . findByIdentifier ( identifier ) ; if ( element . value ) { if ( element . value instanceof IdentifiableValue ) { return CODE . equals ( element . value . identifier ) || checkHasBaseType ( element . value . identifier , new Identifier ( 'shr.core' , 'Coding' ) , dataElementSpecs ) || checkHasBaseType ( element . value . identifier , new Identifier ( 'shr.core' , 'CodeableConcept' ) , dataElementSpecs ) ; } else if ( element . value instanceof ChoiceValue ) { for ( const value of element . value . aggregateOptions ) { if ( value instanceof IdentifiableValue ) { if ( CODE . equals ( value . identifier ) || checkHasBaseType ( value . identifier , new Identifier ( 'shr.core' , 'Coding' ) , dataElementSpecs ) || checkHasBaseType ( value . identifier , new Identifier ( 'shr.core' , 'CodeableConcept' ) , dataElementSpecs ) ) { return true ; } } } } } return false ; }
1965	async function expire ( { payload , meta = { } } , { dispatch } ) { const { service } = payload const { ident } = meta if ( ! service ) { return createError ( ` ` ) } if ( ! payload . endpoint ) { return createError ( ` ${ service } ` ) } if ( ! payload . type ) { return createError ( ` ${ service } ` ) } const response = await getExpired ( payload , ident , dispatch ) return deleteExpired ( response , service , ident , dispatch ) }
1966	function transformRange ( range , ops ) { var rangeComps = range . split ( ':' ) , newRange var start = rangeComps [ 0 ] ops . forEach ( op => start = transformRangeAnchor ( start , op , true ) ) var end = rangeComps [ 1 ] ops . forEach ( op => end = transformRangeAnchor ( end , op , false ) ) if ( start === end ) return start return start + ':' + end }
1967	function transformRangeAnchor ( target , op , isStart ) { var thisCell = parseCell ( target ) if ( op instanceof InsertCol ) { var otherCell = parseCell ( op . newCol ) if ( otherCell [ 0 ] <= thisCell [ 0 ] ) return column . fromInt ( thisCell [ 0 ] + 1 ) + thisCell [ 1 ] } else if ( op instanceof DeleteCol ) { var otherCell = parseCell ( op . col ) if ( otherCell [ 0 ] < thisCell [ 0 ] ) return column . fromInt ( thisCell [ 0 ] - 1 ) + thisCell [ 1 ] if ( otherCell [ 0 ] === thisCell [ 0 ] ) { if ( ! isStart ) return column . fromInt ( thisCell [ 0 ] - 1 ) + thisCell [ 1 ] } } else if ( op instanceof InsertRow ) { var otherCell = parseCell ( op . newRow ) if ( otherCell [ 1 ] <= thisCell [ 1 ] ) return column . fromInt ( thisCell [ 0 ] ) + ( thisCell [ 1 ] + 1 ) } else if ( op instanceof DeleteRow ) { var otherCell = parseCell ( op . col ) if ( otherCell [ 1 ] < thisCell [ 1 ] ) return column . fromInt ( thisCell [ 0 ] ) + ( thisCell [ 1 ] - 1 ) if ( otherCell [ 1 ] === thisCell [ 1 ] ) { if ( ! isStart ) return column . fromInt ( thisCell [ 0 ] ) + ( thisCell [ 1 ] - 1 ) } } return target }
1968	function matchEndpoint ( endpoints ) { return ( { type , payload , meta } ) => endpoints . find ( ( endpoint ) => matchId ( endpoint , { type , payload } ) && matchType ( endpoint , { type , payload } ) && matchScope ( endpoint , { type , payload } ) && matchAction ( endpoint , { type , payload } ) && matchParams ( endpoint , { type , payload } ) && matchFilters ( endpoint , { type , payload , meta } ) ) }
1969	function createAction ( type , payload = { } , meta ) { if ( ! type ) { return null } const action = { type , payload } if ( meta ) { action . meta = meta } return action }
1970	function authorizeRequest ( { schemas } ) { return ( { request } ) => { const { access = { } , params = { } , action } = request const { ident = null } = access if ( ident && ident . root ) { return authItemsAndWrap ( request , { status : 'granted' , ident , scheme : 'root' } , schemas ) } if ( ! params . type ) { return authItemsAndWrap ( request , { status : 'granted' , ident , scheme : null } , schemas ) } const requireAuth = ! ! request . auth const schema = schemas [ params . type ] const scheme = getScheme ( schema , action ) const status = ( doAuth ( scheme , ident , requireAuth ) ) ? 'granted' : 'refused' return authItemsAndWrap ( request , { status , ident , scheme } , schemas ) } }
1971	function requestFromAction ( { type : action , payload , meta = { } } , { endpoint , schemas = { } } = { } ) { const { data , ... params } = payload const { ident = null } = meta const typePlural = getPluralType ( params . type , schemas ) return { action , params , data , endpoint : ( endpoint && endpoint . options ) || null , access : { ident } , meta : { typePlural } } }
1972	function getService ( schemas , services ) { return ( type , service ) => { if ( ! service && schemas [ type ] ) { service = schemas [ type ] . service } return services [ service ] || null } }
1973	async function sync ( { payload , meta = { } } , { dispatch } ) { debug ( 'Action: SYNC' ) const fromParams = await generateFromParams ( payload , meta , dispatch ) const toParams = generateToParams ( payload , fromParams ) const lastSyncedAt = new Date ( ) const results = await Promise . all ( fromParams . map ( getFromService ( dispatch , payload . type , meta ) ) ) if ( results . some ( ( result ) => result . status !== 'ok' ) ) { return ( results . length === 1 ) ? results [ 0 ] : createError ( makeErrorString ( results ) ) } const data = flatten ( results . map ( ( result ) => result . data ) ) . filter ( Boolean ) if ( data . length === 0 && payload . syncNoData !== true ) { return createError ( ` ${ fromParams [ 0 ] . service } ` , 'noaction' ) } return Promise . all ( [ ... createSetMetas ( fromParams , lastSyncedAt , meta . ident , dispatch ) , dispatch ( action ( 'SET' , { data , ... toParams } , { ... meta , queue : true } ) ) ] ) . then ( ( responses ) => { return { status : 'ok' , data : responses } } ) }
1974	function ( gulp , cwd , config ) { if ( util . isNullOrUndefined ( gulp ) ) { throw 'gulp must be defined' ; } this . _config = config || { } , this . _cwd = cwd || __dirname ; this . _root = path . relative ( this . _cwd , __dirname ) ; this . _gulp = gulp ; }
1975	function ( bg ) { bg = bg ? bg : false return ( ... args ) => { return this . output ( args . join ( ' ' ) , this . colors ( bg ) ) } }
1976	function ( browserify , name , source ) { if ( utility . isNullOrUndefined ( browserify ) ) { throw 'browserify must be defined.' ; } if ( ! utility . isNonEmptyString ( name ) ) { throw 'name must be defined.' ; } if ( utility . isNullOrUndefined ( source ) ) { throw 'source must be defined.' ; } this . _browserify = browserify ; this . _name = name ; this . _source = source ; this . _hasModule = false ; this . _hasResolver = false ; }
1977	function mapToService ( ) { return ( { request , requestMapper , mappings } ) => { const data = mapData ( request . data , request , mappings ) return { ... request , data : applyEndpointMapper ( data , request , requestMapper ) } } }
1978	async function processMessengerBody ( body , context ) { const allMessages = getAllMessages ( body ) if ( ! allMessages || ! allMessages . length ) return false context = context || { } for ( let message of allMessages ) { message = _ . cloneDeep ( message ) const messageContext = Object . assign ( { } , context ) try { for ( let plugin of middleware ) { await plugin ( message , messageContext ) } } catch ( error ) { const logError = ( messageContext . log && messageContext . log . error instanceof Function ) ? messageContext . log . error : console . error logError ( 'Error running middleware' , error ) } } return true }
1979	function create ( prop ) { if ( typeof prop !== 'string' ) { throw new Error ( 'expected the first argument to be a string.' ) ; } return function ( app ) { if ( this . isRegistered ( 'base-' + prop ) ) return ; var config = utils . mapper ( app ) . map ( 'store' , store ( app . store ) ) . map ( 'data' ) . map ( 'enable' ) . map ( 'disable' ) . map ( 'option' ) . alias ( 'options' , 'option' ) . map ( 'set' ) . map ( 'del' ) app . define ( prop , proxy ( config ) ) ; app [ prop ] . process = config . process ; } ; function store ( app ) { if ( ! app ) return { } ; var mapper = utils . mapper ( app ) ; app . define ( prop , proxy ( mapper ) ) ; return mapper ; } }
1980	function ElementMatrix ( top ) { CommanalityMatrix . call ( this , top ) ; this . row ( ' ' ) ; this . collum ( ' ' ) ; this . classlist = top . root . classlist ; }
1981	function publicS3URI ( string ) { return encodeURIComponent ( string ) . replace ( / %20 / img , '+' ) . replace ( / %2F / img , '/' ) . replace ( / \" / img , "%22" ) . replace ( / \# / img , "%23" ) . replace ( / \$ / img , "%24" ) . replace ( / \& / img , "%26" ) . replace ( / \' / img , "%27" ) . replace ( / \( / img , "%28" ) . replace ( / \) / img , "%29" ) . replace ( / \, / img , "%2C" ) . replace ( / \: / img , "%3A" ) . replace ( / \; / img , "%3B" ) . replace ( / \= / img , "%3D" ) . replace ( / \? / img , "%3F" ) . replace ( / \@ / img , "%40" ) ; }
1982	function ( done ) { fs . writeFile ( path . resolve ( __dirname , '../../test/reallife/expected/' + item . key + '.json' ) , JSON . stringify ( { 'title' : item . title , 'text' : item . text } , null , '\t' ) + \t , '\n' ) ; }
1983	function ( done ) { fs . writeFile ( path . resolve ( __dirname , '../../test/reallife/source/' + item . key + '.html' ) , SOURCES [ item . key ] , done ) ; }
1984	function ( done ) { datamap [ item . index ] . labeled = true ; fs . writeFile ( path . resolve ( __dirname , '../../test/reallife/datamap.json' ) , JSON . stringify ( datamap , null , '\t' ) + \t , '\n' ) ; }
1985	function Node ( type , parent ) { this . type = type ; this . parent = parent ; this . root = parent ? parent . root : this ; this . identifyer = parent ? ( ++ parent . root . _counter ) : 0 ; this . _textLength = 0 ; this . tags = 0 ; this . density = - 1 ; this . children = [ ] ; this . _text = '' ; this . _textCompiled = false ; this . _noneStyleText = '' ; this . _noneStyleTextCompiled = false ; this . blocky = false ; this . blockyChildren = false ; this . inTree = true ; }
1986	function TextNode ( parent , text ) { Node . call ( this , 'text' , parent ) ; this . children = null ; this . _text = text ; this . _noneStyleText = text ; }
1987	function ElementNode ( parent , tagname , attributes ) { Node . call ( this , 'element' , parent ) ; this . tags = ( tagname === 'br' || tagname === 'wbr' ) ? 0 : 1 ; this . tagname = tagname ; this . attr = attributes ; this . classes = attributes . hasOwnProperty ( 'class' ) ? attributes [ 'class' ] . trim ( ) . split ( WHITE_SPACE ) : [ ] ; this . root . classlist . addNode ( this ) ; this . _blockySelfCache = domHelpers . BLOCK_ELEMENTS . hasOwnProperty ( tagname ) ; this . _countTagnames = { } ; }
1988	function ( ) { var r ; if ( Util . isnt . instanceof ( NewClass , this ) ) { return ClassUtil . construct ( NewClass , arguments ) ; } if ( Util . is . Function ( this . initialize ) ) { r = this . initialize . apply ( this , arguments ) ; } this . callInitHooks ( ) ; return typeof r != 'undefined' ? r : this ; }
1989	function distribute ( filename , content ) { content = content ; fs . appendFile ( filename , content + "\n" ) ; \n }
1990	function detectTakeout ( selectors ) { var properties = { takeout : false } ; options . takeout . forEach ( function ( takeout ) { selectors . forEach ( function ( selector ) { if ( selector . indexOf ( takeout . ruleprefix ) === 0 ) { properties . takeout = true ; properties . filename = takeout . filename ; } } ) ; } ) ; return properties ; }
1991	function parseLineByLine ( text ) { var lines = text . trim ( ) . split ( "\n" ) ; \n var bookmarks = lines . splice ( 0 , lines . length * 3 / 4 ) ; }
1992	function CommonalityInterface ( MatrixConstructor , top ) { this . top = top ; this . length = null ; this . matrix = null ; this . MatrixConstructor = MatrixConstructor ; }
1993	function CommanalityMatrix ( classlist ) { this . rowKeys = { } ; this . rowNames = [ ] ; this . collumKeys = { } ; this . collumNames = [ ] ; this . nodeMatrix = [ ] ; this . summaryMatrix = [ ] ; this . dim = [ 0 , 0 ] ; this . bestIndex = [ - 1 , - 1 ] ; this . _bestNodes = { } ; }
1994	function arrayVector ( size ) { var vec = new Array ( size ) ; for ( var i = 0 ; i < size ; i ++ ) vec [ i ] = [ ] ; return vec ; }
1995	function buildAttributeMatcher ( match ) { var keys = Object . keys ( match ) ; var jskey , i , l ; var transform = '' ; var bool = '' ; transform = 'transform = {\n' ; \n for ( i = 0 , l = keys . length ; i < l ; i ++ ) { jskey = JSON . stringify ( keys [ i ] ) ; transform += ' ' + jskey + ': attr.hasOwnProperty(' + jskey + ') ? attr[' + jskey + '].toLowerCase() : false' ; if ( i !== l - 1 ) transform += ',' ; transform += '\n' ; } \n transform += '};\n' ; \n bool = 'return !!(' ; for ( i = 0 , l = keys . length ; i < l ; i ++ ) { jskey = JSON . stringify ( keys [ i ] ) ; if ( i > 0 ) bool += ' || ' ; bool += ' ( transform[' + jskey + ']' ; if ( Array . isArray ( match [ keys [ i ] ] ) ) { bool += ' && ( ' ; for ( var j = 0 , s = match [ keys [ i ] ] . length ; j < s ; j ++ ) { if ( j > 0 ) bool += ' || ' ; if ( typeof match [ keys [ i ] ] [ j ] === 'string' ) { bool += 'transform[' + jskey + '] === \'' + \' + match [ keys [ i ] ] [ j ] . toLowerCase ( ) ; } else '\'' } \' } if ( util . isRegExp ( match [ keys [ i ] ] [ j ] ) ) { bool += 'match[' + jskey + '][' + j + '].test(transform[' + jskey + '])' ; } } }
1996	function containerOf ( a , b ) { while ( b = b . parent ) { if ( a === b ) return true ; } return false ; }
1997	function commonParent ( a , b ) { if ( a === b ) { return a ; } else if ( containerOf ( a , b ) ) { return a ; } else if ( containerOf ( b , a ) ) { return b ; } else { while ( b = b . parent ) { if ( containerOf ( b , a ) ) return b ; } } }
1998	function styleParser ( style ) { style = style || '' ; var tokens = style . trim ( ) . split ( / \s*(?:;|:)\s* / ) ; var output = { } ; for ( var i = 1 , l = tokens . length ; i < l ; i += 2 ) { output [ tokens [ i - 1 ] ] = tokens [ i ] ; } return output ; }
1999	function treeDistance ( a , b ) { if ( a === b ) return 0 ; var parent = commonParent ( a , b ) ; var aParent = a ; var aCount = 0 ; var bParent = b ; var bCount = 0 ; if ( parent !== a ) { while ( parent !== aParent . parent ) { aCount += 1 ; aParent = aParent . parent ; } } else { bCount += 1 ; } if ( parent !== b ) { while ( parent !== bParent . parent ) { bCount += 1 ; bParent = bParent . parent ; } } else { aCount += 1 ; } var abCount = 0 ; if ( parent !== a && parent !== b ) { abCount = Math . abs ( parent . children . indexOf ( aParent ) - parent . children . indexOf ( bParent ) ) ; } return aCount + bCount + abCount ; }
2000	function Lexer ( file , options ) { this . options = utils . extend ( { } , options ) ; this . file = file ; this . regex = new RegexCache ( ) ; this . names = [ ] ; this . ast = { tags : { } , type : 'root' , name : 'root' , nodes : [ ] } ; this . unknown = { tags : [ ] , blocks : [ ] } ; this . known = { tags : [ 'extends' , 'layout' ] , blocks : [ 'block' ] } ; this . delimiters = { variable : [ '{{' , '}}' ] , block : [ '{%' , '%}' ] , es6 : [ '${' , '}' ] , } ; this . tokens = [ this . ast ] ; this . errors = [ ] ; this . stack = [ ] ; this . stash = [ ] ; this . lexers = { } ; this . fns = [ ] ; }
2001	function ( ) { if ( this . isInitialized ) return ; this . isInitialized = true ; var lexer = this ; this . lineno = 1 ; this . column = 1 ; this . lexed = '' ; this . file = utils . normalize ( this . file ) ; this . file . orig = this . file . contents ; this . input = this . file . contents . toString ( ) ; this . file . ast = this . ast ; this . file . ast . variables = { } ; this . file . ast . blocks = { } ; this . input = this . input . split ( '{% body %}' ) . join ( '{% block "body" %}{% endblock %}' ) ; if ( this . file . extends ) { this . prependNode ( this . file , 'extends' ) ; } this . captureTag ( 'extends' ) ; this . captureTag ( 'layout' ) ; this . captureBlock ( 'block' ) ; this . capture ( 'text' , utils . negateDelims ( this . delimiters ) ) ; this . capture ( 'newline' , / ^\n+ / ) ; this . capture ( 'es6' , / ^\$\{([^\\}]*(?:\\.[^\\}]*)*)\} / ) ; this . capture ( 'variable' , / ^\{{2,}([^\\}]*(?:\\.[^\\}]*)*)\}{2,} / ) ; this . capture ( 'escape' , / ^\\(.) / ) ; this . capture ( 'space' , / ^[ \t]+ / ) ; var helpers = this . options . helpers || { } ; if ( utils . isObject ( helpers ) ) { helpers = Object . keys ( helpers ) ; } helpers . forEach ( function ( key ) { lexer . known . blocks . push ( key ) ; lexer . captureBlock ( key ) ; } ) ; var matches = this . input . match ( / \{%\s*([^%}]+) / g ) ; var names = utils . getNames ( matches ) ; names . tags . forEach ( function ( key ) { if ( ! utils . isRegistered ( lexer , key ) ) { lexer . unknown . tags . push ( key ) ; lexer . captureTag ( key ) ; } } ) ; names . blocks . forEach ( function ( key ) { if ( ! utils . isRegistered ( lexer , key ) ) { lexer . unknown . blocks . push ( key ) ; lexer . captureBlock ( key ) ; } } ) ; }
2002	function ( msg ) { var message = this . file . relative + ' line:' + this . lineno + ' column:' + this . column + ': ' + msg ; var err = new Error ( message ) ; err . reason = msg ; err . line = this . lineno ; err . column = this . column ; err . source = this . input ; err . path = this . file . path ; if ( this . options . silent ) { this . errors . push ( err ) ; } else { throw err ; } }
2003	function ( type ) { var cached = this . regex . createVariable ( type ) ; var file = this . file ; var lexer = this ; var fn = this . lexers [ type ] = function ( ) { var pos = lexer . position ( ) ; var m = lexer . match ( cached . strict ) ; if ( ! m ) return ; var parent = this . prev ( ) ; var node = pos ( { type : type , known : utils . has ( lexer . known . tags , type ) , val : m [ 0 ] . trim ( ) } ) ; parent . known = node . known ; var nodes = parent . nodes ; Object . defineProperty ( file . ast . variables , type , { configurable : true , set : function ( val ) { nodes = val ; } , get : function ( ) { return nodes ; } } ) ; Object . defineProperty ( parent , 'nodes' , { configurable : true , set : function ( val ) { nodes = val ; } , get : function ( ) { return nodes ; } } ) ; utils . define ( node , 'parent' , parent ) ; parent . nodes . push ( node ) ; } ; this . addLexer ( fn ) ; return this ; }
2004	function ( type ) { this . ast . tags [ type ] = null ; this . names . push ( type ) ; var cached = this . regex . createTag ( type ) ; var file = this . file ; var lexer = this ; var fn = this . lexers [ type ] = function ( ) { var pos = lexer . position ( ) ; var m = lexer . match ( cached . strict ) ; if ( ! m ) return ; var name = utils . getName ( m [ 1 ] ) ; if ( this . options . strict ) { var isKnown = utils . has ( lexer . known . tags , type ) ; if ( isKnown && file . hasOwnProperty ( type ) && ! file . hasOwnProperty ( 'isParsed' ) ) { throw new Error ( ` ${ type } ` ) ; } } file [ type ] = name ; lexer . ast . tags [ type ] = name ; lexer . createNode ( type , name , m , pos ) ; } ; this . addLexer ( fn ) ; return this ; }
2005	function ( type , name , m , pos ) { var parent = this . prev ( ) ; var val = m [ 1 ] ; var tok = { type : 'args' , val : val } ; var node = pos ( { type : type , name : name , known : utils . has ( this . known . tags , type ) , val : val . trim ( ) , nodes : [ tok ] } ) ; utils . define ( node , 'parent' , parent ) ; utils . define ( tok , 'parent' , node ) ; parent . nodes . push ( node ) ; }
2006	function ( type ) { this . names . push ( type ) ; var cached = this . regex . createOpen ( type ) ; var file = this . file ; var lexer = this ; return function ( ) { var pos = lexer . position ( ) ; var m = lexer . match ( cached . strict ) ; if ( ! m ) return ; var name = utils . getName ( m [ 1 ] ) ; var action = utils . getAction ( m [ 1 ] ) ; var val = m [ 0 ] ; if ( ! name && lexer . options [ type ] && lexer . options [ type ] . args === 'required' ) { throw new Error ( ` ${ type } ${ m [ 0 ] } ` ) ; } if ( ! name ) name = 'unnamed' ; var node = pos ( { type : ` ${ type } ` , known : utils . has ( lexer . known . blocks , type ) , name : name , val : val . trim ( ) } ) ; var parent = lexer . prev ( ) ; if ( parent && parent . name && parent . name !== 'root' ) { name = parent . name + '.' + name ; } var block = { type : type , name : name , known : node . known , action : action , nodes : [ node ] } ; utils . define ( node , 'parent' , block ) ; utils . define ( block , 'parent' , parent ) ; block . rawArgs = m [ 1 ] ; block . args = utils . parseArgs ( m [ 1 ] ) ; Object . defineProperty ( file . ast . blocks [ type ] , name , { configurable : true , enumerable : true , set : function ( val ) { block = val ; } , get : function ( ) { return block ; } } ) ; parent . nodes . push ( block ) ; lexer . tokens . push ( block ) ; return block ; } ; }
2007	function ( type ) { var cached = this . regex . createClose ( type ) ; var file = this . file ; var lexer = this ; return function ( ) { var pos = lexer . position ( ) ; var m = lexer . match ( cached . strict ) ; if ( ! m ) return ; var block = lexer . tokens . pop ( ) ; if ( typeof block === 'undefined' || block . type !== type ) { throw new Error ( ` ${ type } ` ) ; } if ( block . name === 'body' ) { lexer . ast . isLayout = true ; file . ast . isLayout = true ; } var nodes = block . nodes ; Object . defineProperty ( file . ast . blocks , block . name , { configurable : true , set : function ( val ) { nodes = val ; } , get : function ( ) { return nodes ; } } ) ; Object . defineProperty ( block , 'nodes' , { configurable : true , set : function ( val ) { nodes = val ; } , get : function ( ) { return nodes ; } } ) ; var tok = pos ( { known : block . known , type : ` ${ type } ` , val : m [ 0 ] . trim ( ) } ) ; utils . define ( block , 'position' , tok . position ) ; utils . define ( tok , 'parent' , block ) ; block . nodes . push ( tok ) ; return block ; } ; }
2008	function ( type ) { this . file . ast . blocks [ type ] = this . file . ast . blocks [ type ] || { } ; this . addLexer ( this . captureOpen ( type ) ) ; this . addLexer ( this . captureClose ( type ) ) ; return this ; }
2009	function ( file , prop ) { return this . createNode ( prop , file [ prop ] , ` ${ prop } ${ file [ prop ] } ` , this . position ( ) ) ; }
2010	function ( str , len ) { var lines = str . match ( / \n / g ) ; if ( lines ) this . lineno += lines . length ; var i = str . lastIndexOf ( '\n' ) ; \n this . column = ~ i ? len - i : this . column + len ; this . lexed += str ; }
2011	function ( ) { var len = this . fns . length ; var idx = - 1 ; while ( ++ idx < len ) { this . fns [ idx ] . call ( this ) ; if ( ! this . input ) { break ; } } }
2012	function ( ) { while ( this . input ) { var prev = this . input ; this . advance ( ) ; if ( this . input && prev === this . input ) { throw new Error ( ` ${ this . input . substr ( 0 , 10 ) } ` ) ; } } }
2013	function ( file ) { debug ( 'lexing <%s>' , this . file . path ) ; if ( file ) this . file = file ; this . init ( ) ; while ( this . input ) this . next ( ) ; return this . ast ; }
2014	function notifyHook ( e ) { message_count ++ ; var message ; if ( ! options . enabled ) { return ; } if ( ! e ) { return ; } if ( e && e . length === 1 ) { e = e [ 0 ] ; } if ( / Task .* failed\. / . test ( e . message ) ) { message = e . message ; } else if ( e . message && e . stack ) { message = exception ( e ) ; } else { message = e + '' ; } if ( message_count > 0 && message === 'Aborted due to warnings.' ) { return ; } message = message . replace ( cwd , '' ) . replace ( '\x07' , \x07 ) ; '' }
2015	function ( ) { if ( this . _initialized && this . _isPaused ) { return false ; } this . _isPaused = true ; raf . cancel ( this . _requestID ) ; this . _pauseTime = now ( ) ; this . _onPause ( ) ; return true ; }
2016	function ( ) { if ( this . _initialized && ! this . _isPaused ) { return false ; } var pauseDuration ; this . _isPaused = false ; this . _prevTime = now ( ) ; pauseDuration = this . _prevTime - this . _pauseTime ; this . _onResume ( pauseDuration ) ; this . _requestID = raf . request ( this . _tick ) ; return true ; }
2017	function mktmpdir ( prefixSuffix , tmpdir , callback , onend ) { if ( 'function' == typeof prefixSuffix ) { onend = tmpdir ; callback = prefixSuffix ; tmpdir = null ; prefixSuffix = null ; } else if ( 'function' == typeof tmpdir ) { onend = callback ; callback = tmpdir ; tmpdir = null ; } prefixSuffix = prefixSuffix || 'd' ; onend = onend || function ( ) { } ; tmpname . create ( prefixSuffix , tmpdir , function ( err , path , next ) { if ( err ) return callback ( err ) ; fs . mkdir ( path , 0700 , next ) ; } , function ( err , path ) { if ( err ) return callback ( err ) ; callback ( null , path , function ( err ) { if ( ! path ) return onend ( err ) ; rimraf ( path , function ( _err ) { onend ( err || _err , path ) ; } ) ; } ) ; } ) ; }
2018	function copyString ( buffer , length , offsetBegin , offsetEnd ) { if ( length > 2048 ) { return buffer . toString ( 'utf-8' , offsetBegin , offsetEnd ) ; } var string = '' ; while ( offsetBegin < offsetEnd ) { string += String . fromCharCode ( buffer [ offsetBegin ++ ] ) ; } return string ; }
2019	function parseSimpleString ( parser ) { var offset = parser . offset ; var length = parser . buffer . length ; var string = '' ; while ( offset < length ) { var c1 = parser . buffer [ offset ++ ] ; if ( c1 === 13 ) { var c2 = parser . buffer [ offset ++ ] ; if ( c2 === 10 ) { parser . offset = offset ; return string ; } string += String . fromCharCode ( c1 ) + String . fromCharCode ( c2 ) ; continue ; } string += String . fromCharCode ( c1 ) ; } return undefined ; }
2020	function getBaseConfig ( isProd ) { const libraryEntryPoint = path . join ( 'src' , LIBRARY_DESC . entry ) ; return { entry : [ path . join ( __dirname , libraryEntryPoint ) , ] , output : { devtoolLineToLine : true , pathinfo : true , } , module : { preLoaders : [ { test : / \.js$ / , exclude : / (node_modules|bower_components) / , loader : "eslint-loader" , } , ] , loaders : [ { exclude : / (node_modules|bower_components) / , loader : "babel-loader" , plugins : [ "transform-runtime" , ] , query : { presets : [ "es2015" , "stage-0" , "stage-1" , "stage-2" , ] , cacheDirectory : false , } , test : / \.js$ / , } , ] , } , eslint : { configFile : './.eslintrc' , } , resolve : { root : path . resolve ( './src' ) , extensions : [ '' , '.js' ] , } , devtool : isProd ? "source-map" : "source-map" , debug : ! isProd , plugins : isProd ? [ new webpack . DefinePlugin ( { 'process.env' : { NODE_ENV : '"production"' } } ) , new UglifyJsPlugin ( { compress : { warnings : true } , minimize : true , sourceMap : true , } ) , ] : [ new webpack . DefinePlugin ( { 'process.env' : { NODE_ENV : '"development"' } } ) , new UglifyJsPlugin ( { compress : { warnings : true } , minimize : true , sourceMap : true , } ) , ] , } ; }
2021	function postNotification ( options , cb ) { options . title = removeColor ( options . title ) ; options . message = removeColor ( options . message ) ; if ( ! options . message ) { return cb && cb ( ! options . message && 'Message is required' ) ; } if ( ! notifyPlatform ) { notifyPlatform = choosePlatform ( ) ; } function resetPreviousTimer ( newMessage ) { previousMessage = newMessage ; clearTimeout ( previousMessageTimer ) ; previousMessageTimer = setTimeout ( function ( ) { previousMessage = false ; } , previousMessageTimeoutMS ) ; } if ( options . message === previousMessage ) { resetPreviousTimer ( options . message ) ; if ( typeof cb === 'function' ) { cb ( err ) ; } return ; } resetPreviousTimer ( options . message ) ; options . debug = debug ( notifyPlatform . name ) ; return notifyPlatform . notify ( options , function ( err ) { if ( err ) { options . debug ( { return_code : err } ) ; } if ( typeof cb === 'function' ) { cb ( err ) ; } } ) ; }
2022	function generateUsername ( base ) { base = base . toLowerCase ( ) ; var entries = [ ] ; var finalName ; return userDB . allDocs ( { startkey : base , endkey : base + '\uffff' , \uffff } ) . include_docs : false then ; }
2023	function linkSuccess ( req , res , next ) { var provider = getProvider ( req . path ) ; var result = { error : null , session : null , link : provider } ; var template ; if ( config . getItem ( 'testMode.oauthTest' ) ) { template = fs . readFileSync ( path . join ( __dirname , '../templates/oauth/auth-callback-test.ejs' ) , 'utf8' ) ; } else { template = fs . readFileSync ( path . join ( __dirname , '../templates/oauth/auth-callback.ejs' ) , 'utf8' ) ; } var html = ejs . render ( template , result ) ; res . status ( 200 ) . send ( html ) ; }
2024	function linkTokenSuccess ( req , res , next ) { var provider = getProviderToken ( req . path ) ; res . status ( 200 ) . json ( { ok : true , success : util . capitalizeFirstLetter ( provider ) + ' successfully linked' , provider : provider } ) ; }
2025	function oauthErrorHandler ( err , req , res , next ) { var template ; if ( config . getItem ( 'testMode.oauthTest' ) ) { template = fs . readFileSync ( path . join ( __dirname , '../templates/oauth/auth-callback-test.ejs' ) , 'utf8' ) ; } else { template = fs . readFileSync ( path . join ( __dirname , '../templates/oauth/auth-callback.ejs' ) , 'utf8' ) ; } var html = ejs . render ( template , { error : err . message , session : null , link : null } ) ; console . error ( err ) ; if ( err . stack ) { console . error ( err . stack ) ; } res . status ( 400 ) . send ( html ) ; }
2026	function tokenAuthErrorHandler ( err , req , res , next ) { var status ; if ( req . user && req . user . _id ) { status = 403 ; } else { status = 401 ; } console . error ( err ) ; if ( err . stack ) { console . error ( err . stack ) ; delete err . stack ; } res . status ( status ) . json ( err ) ; }
2027	function registerProvider ( provider , configFunction ) { provider = provider . toLowerCase ( ) ; var configRef = 'providers.' + provider ; if ( config . getItem ( configRef + '.credentials' ) ) { var credentials = config . getItem ( configRef + '.credentials' ) ; credentials . passReqToCallback = true ; var options = config . getItem ( configRef + '.options' ) || { } ; configFunction . call ( null , credentials , passport , authHandler ) ; router . get ( '/' + provider , passportCallback ( provider , options , 'login' ) ) ; router . get ( '/' + provider + '/callback' , passportCallback ( provider , options , 'login' ) , initSession , oauthErrorHandler ) ; if ( ! config . getItem ( 'security.disableLinkAccounts' ) ) { router . get ( '/link/' + provider , passport . authenticate ( 'bearer' , { session : false } ) , passportCallback ( provider , options , 'link' ) ) ; router . get ( '/link/' + provider + '/callback' , passport . authenticate ( 'bearer' , { session : false } ) , passportCallback ( provider , options , 'link' ) , linkSuccess , oauthErrorHandler ) ; } console . log ( provider + ' loaded.' ) ; } }
2028	function registerOAuth2 ( providerName , Strategy ) { registerProvider ( providerName , function ( credentials , passport , authHandler ) { passport . use ( new Strategy ( credentials , function ( req , accessToken , refreshToken , profile , done ) { authHandler ( req , providerName , { accessToken : accessToken , refreshToken : refreshToken } , profile ) . asCallback ( done ) ; } ) ) ; } ) ; }
2029	function registerTokenProvider ( providerName , Strategy ) { providerName = providerName . toLowerCase ( ) ; var configRef = 'providers.' + providerName ; if ( config . getItem ( configRef + '.credentials' ) ) { var credentials = config . getItem ( configRef + '.credentials' ) ; credentials . passReqToCallback = true ; var options = config . getItem ( configRef + '.options' ) || { } ; passport . use ( providerName + '-token' , new Strategy ( credentials , function ( req , accessToken , refreshToken , profile , done ) { authHandler ( req , providerName , { accessToken : accessToken , refreshToken : refreshToken } , profile ) . asCallback ( done ) ; } ) ) ; router . post ( '/' + providerName + '/token' , passportTokenCallback ( providerName , options ) , initTokenSession , tokenAuthErrorHandler ) ; if ( ! config . getItem ( 'security.disableLinkAccounts' ) ) { router . post ( '/link/' + providerName + '/token' , passport . authenticate ( 'bearer' , { session : false } ) , passportTokenCallback ( providerName , options ) , linkTokenSuccess , tokenAuthErrorHandler ) ; } console . log ( providerName + '-token loaded.' ) ; } }
2030	function authHandler ( req , provider , auth , profile ) { if ( req . user && req . user . _id && req . user . key ) { return user . linkSocial ( req . user . _id , provider , auth , profile , req ) ; } else { return user . socialAuth ( provider , auth , profile , req ) ; } }
2031	function passportCallback ( provider , options , operation ) { return function ( req , res , next ) { var theOptions = extend ( { } , options ) ; if ( provider === 'linkedin' ) { theOptions . state = true ; } var accessToken = req . query . bearer_token || req . query . state ; if ( accessToken && ( stateRequired . indexOf ( provider ) > - 1 || config . getItem ( 'providers.' + provider + '.stateRequired' ) === true ) ) { theOptions . state = accessToken ; } theOptions . callbackURL = getLinkCallbackURLs ( provider , req , operation , accessToken ) ; theOptions . session = false ; passport . authenticate ( provider , theOptions ) ( req , res , next ) ; } ; }
2032	function passportTokenCallback ( provider , options ) { return function ( req , res , next ) { var theOptions = extend ( { } , options ) ; theOptions . session = false ; passport . authenticate ( provider + '-token' , theOptions ) ( req , res , next ) ; } ; }
2033	function getProvider ( pathname ) { var items = pathname . split ( '/' ) ; var index = items . indexOf ( 'callback' ) ; if ( index > 0 ) { return items [ index - 1 ] ; } }
2034	function getProviderToken ( pathname ) { var items = pathname . split ( '/' ) ; var index = items . indexOf ( 'token' ) ; if ( index > 0 ) { return items [ index - 1 ] ; } }
2035	function requireRole ( requiredRole ) { return function ( req , res , next ) { if ( ! req . user ) { return next ( superloginError ) ; } var roles = req . user . roles ; if ( ! roles || ! roles . length || roles . indexOf ( requiredRole ) === - 1 ) { res . status ( forbiddenError . status ) ; res . json ( forbiddenError ) ; } else { next ( ) ; } } ; }
2036	function ( ) { var foundLayer = null ; $ . each ( projectedTiles , function ( layerName , layer ) { if ( map . hasLayer ( layer ) ) { foundLayer = layer ; } } ) ; return foundLayer ; }
2037	function ( crs , options ) { switch ( crs ) { case "EPSG:3857" : return L . CRS . EPSG3857 ; case "EPSG:3395" : return L . CRS . EPSG3395 ; case "EPSG:4326" : return L . CRS . EPSG4326 ; default : return this . _defineMapCRS ( crs , options ) ; } }
2038	function ( group ) { var map = this ; if ( group . eachLayer ) { group . eachLayer ( function ( layer ) { map . _updateAllLayers ( layer ) ; } ) ; } else { if ( group . redraw ) { group . redraw ( ) ; } else if ( group . update ) { group . update ( ) ; } else { console . log ( "Don't know how to update" , group ) ; } } }
2039	function ( layersArray ) { var fg = this . _featureGroup , npg = this . _nonPointGroup , chunked = this . options . chunkedLoading , chunkInterval = this . options . chunkInterval , chunkProgress = this . options . chunkProgress , newMarkers , i , l , m ; if ( this . _map ) { var offset = 0 , started = ( new Date ( ) ) . getTime ( ) ; var process = L . bind ( function ( ) { var start = ( new Date ( ) ) . getTime ( ) ; for ( ; offset < layersArray . length ; offset ++ ) { if ( chunked && offset % 200 === 0 ) { var elapsed = ( new Date ( ) ) . getTime ( ) - start ; if ( elapsed > chunkInterval ) { break ; } } m = layersArray [ offset ] ; if ( ! m . getLatLng ) { npg . addLayer ( m ) ; continue ; } if ( this . hasLayer ( m ) ) { continue ; } this . _addLayer ( m , this . _maxZoom ) ; if ( m . __parent ) { if ( m . __parent . getChildCount ( ) === 2 ) { var markers = m . __parent . getAllChildMarkers ( ) , otherMarker = markers [ 0 ] === m ? markers [ 1 ] : markers [ 0 ] ; fg . removeLayer ( otherMarker ) ; } } } if ( chunkProgress ) { chunkProgress ( offset , layersArray . length , ( new Date ( ) ) . getTime ( ) - started ) ; } if ( offset === layersArray . length ) { this . _featureGroup . eachLayer ( function ( c ) { if ( c instanceof L . MarkerCluster && c . _iconNeedsUpdate ) { c . _updateIcon ( ) ; } } ) ; this . _topClusterLevel . _recursivelyAddChildrenToMap ( null , this . _zoom , this . _currentShownBounds ) ; } else { setTimeout ( process , this . options . chunkDelay ) ; } } , this ) ; process ( ) ; } else { newMarkers = [ ] ; for ( i = 0 , l = layersArray . length ; i < l ; i ++ ) { m = layersArray [ i ] ; if ( ! m . getLatLng ) { npg . addLayer ( m ) ; continue ; } if ( this . hasLayer ( m ) ) { continue ; } newMarkers . push ( m ) ; } this . _needsClustering = this . _needsClustering . concat ( newMarkers ) ; } return this ; }
2040	function ( layersArray ) { var i , l , m , fg = this . _featureGroup , npg = this . _nonPointGroup ; if ( ! this . _map ) { for ( i = 0 , l = layersArray . length ; i < l ; i ++ ) { m = layersArray [ i ] ; this . _arraySplice ( this . _needsClustering , m ) ; npg . removeLayer ( m ) ; } return this ; } for ( i = 0 , l = layersArray . length ; i < l ; i ++ ) { m = layersArray [ i ] ; if ( ! m . __parent ) { npg . removeLayer ( m ) ; continue ; } this . _removeLayer ( m , true , true ) ; if ( fg . hasLayer ( m ) ) { fg . removeLayer ( m ) ; if ( m . setOpacity ) { m . setOpacity ( 1 ) ; } } } this . _topClusterLevel . _recursivelyAddChildrenToMap ( null , this . _zoom , this . _currentShownBounds ) ; fg . eachLayer ( function ( c ) { if ( c instanceof L . MarkerCluster ) { c . _updateIcon ( ) ; } } ) ; return this ; }
2041	function ( ) { var bounds = new L . LatLngBounds ( ) ; if ( this . _topClusterLevel ) { bounds . extend ( this . _topClusterLevel . _bounds ) ; } for ( var i = this . _needsClustering . length - 1 ; i >= 0 ; i -- ) { bounds . extend ( this . _needsClustering [ i ] . getLatLng ( ) ) ; } bounds . extend ( this . _nonPointGroup . getBounds ( ) ) ; return bounds ; }
2042	function ( method , context ) { var markers = this . _needsClustering . slice ( ) , i ; if ( this . _topClusterLevel ) { this . _topClusterLevel . getAllChildMarkers ( markers ) ; } for ( i = markers . length - 1 ; i >= 0 ; i -- ) { method . call ( context , markers [ i ] ) ; } this . _nonPointGroup . eachLayer ( method , context ) ; }
2043	function ( layer ) { if ( ! layer ) { return false ; } var i , anArray = this . _needsClustering ; for ( i = anArray . length - 1 ; i >= 0 ; i -- ) { if ( anArray [ i ] === layer ) { return true ; } } anArray = this . _needsRemoving ; for ( i = anArray . length - 1 ; i >= 0 ; i -- ) { if ( anArray [ i ] === layer ) { return false ; } } return ! ! ( layer . __parent && layer . __parent . _group === this ) || this . _nonPointGroup . hasLayer ( layer ) ; }
2044	function ( map ) { this . _map = map ; var i , l , layer ; if ( ! isFinite ( this . _map . getMaxZoom ( ) ) ) { throw "Map has no maxZoom specified" ; } this . _featureGroup . onAdd ( map ) ; this . _nonPointGroup . onAdd ( map ) ; if ( ! this . _gridClusters ) { this . _generateInitialClusters ( ) ; } for ( i = 0 , l = this . _needsRemoving . length ; i < l ; i ++ ) { layer = this . _needsRemoving [ i ] ; this . _removeLayer ( layer , true ) ; } this . _needsRemoving = [ ] ; this . _zoom = this . _map . getZoom ( ) ; this . _currentShownBounds = this . _getExpandedVisibleBounds ( ) ; this . _map . on ( 'zoomend' , this . _zoomEnd , this ) ; this . _map . on ( 'moveend' , this . _moveEnd , this ) ; if ( this . _spiderfierOnAdd ) { this . _spiderfierOnAdd ( ) ; } this . _bindEvents ( ) ; l = this . _needsClustering ; this . _needsClustering = [ ] ; this . addLayers ( l ) ; }
2045	function ( map ) { map . off ( 'zoomend' , this . _zoomEnd , this ) ; map . off ( 'moveend' , this . _moveEnd , this ) ; this . _unbindEvents ( ) ; this . _map . _mapPane . className = this . _map . _mapPane . className . replace ( ' leaflet-cluster-anim' , '' ) ; if ( this . _spiderfierOnRemove ) { this . _spiderfierOnRemove ( ) ; } this . _hideCoverage ( ) ; this . _featureGroup . onRemove ( map ) ; this . _nonPointGroup . onRemove ( map ) ; this . _featureGroup . clearLayers ( ) ; this . _map = null ; }
2046	function ( anArray , obj ) { for ( var i = anArray . length - 1 ; i >= 0 ; i -- ) { if ( anArray [ i ] === obj ) { anArray . splice ( i , 1 ) ; return true ; } } }
2047	function ( layer , newCluster ) { if ( newCluster === layer ) { this . _featureGroup . addLayer ( layer ) ; } else if ( newCluster . _childCount === 2 ) { newCluster . _addToMap ( ) ; var markers = newCluster . getAllChildMarkers ( ) ; this . _featureGroup . removeLayer ( markers [ 0 ] ) ; this . _featureGroup . removeLayer ( markers [ 1 ] ) ; } else { newCluster . _updateIcon ( ) ; } }
2048	function ( storageArray ) { storageArray = storageArray || [ ] ; for ( var i = this . _childClusters . length - 1 ; i >= 0 ; i -- ) { this . _childClusters [ i ] . getAllChildMarkers ( storageArray ) ; } for ( var j = this . _markers . length - 1 ; j >= 0 ; j -- ) { storageArray . push ( this . _markers [ j ] ) ; } return storageArray ; }
2049	function ( ) { var childClusters = this . _childClusters . slice ( ) , map = this . _group . _map , boundsZoom = map . getBoundsZoom ( this . _bounds ) , zoom = this . _zoom + 1 , mapZoom = map . getZoom ( ) , i ; while ( childClusters . length > 0 && boundsZoom > zoom ) { zoom ++ ; var newClusters = [ ] ; for ( i = 0 ; i < childClusters . length ; i ++ ) { newClusters = newClusters . concat ( childClusters [ i ] . _childClusters ) ; } childClusters = newClusters ; } if ( boundsZoom > zoom ) { this . _group . _map . setView ( this . _latlng , zoom ) ; } else if ( boundsZoom <= mapZoom ) { this . _group . _map . setView ( this . _latlng , mapZoom + 1 ) ; } else { this . _group . _map . fitBounds ( this . _bounds ) ; } }
2050	function ( marker ) { var addedCount , addedLatLng = marker . _wLatLng || marker . _latlng ; if ( marker instanceof L . MarkerCluster ) { this . _bounds . extend ( marker . _bounds ) ; addedCount = marker . _childCount ; } else { this . _bounds . extend ( addedLatLng ) ; addedCount = 1 ; } if ( ! this . _cLatLng ) { this . _cLatLng = marker . _cLatLng || addedLatLng ; } var totalCount = this . _childCount + addedCount ; if ( ! this . _wLatLng ) { this . _latlng = this . _wLatLng = new L . LatLng ( addedLatLng . lat , addedLatLng . lng ) ; } else { this . _wLatLng . lat = ( addedLatLng . lat * addedCount + this . _wLatLng . lat * this . _childCount ) / totalCount ; this . _wLatLng . lng = ( addedLatLng . lng * addedCount + this . _wLatLng . lng * this . _childCount ) / totalCount ; } }
2051	function ( ) { if ( this . _group . _spiderfied === this || this . _group . _inZoomAnimation ) { return ; } var childMarkers = this . getAllChildMarkers ( ) , group = this . _group , map = group . _map , center = map . latLngToLayerPoint ( this . _latlng ) , positions ; this . _group . _unspiderfy ( ) ; this . _group . _spiderfied = this ; if ( childMarkers . length >= this . _circleSpiralSwitchover ) { positions = this . _generatePointsSpiral ( childMarkers . length , center ) ; } else { center . y += 10 ; positions = this . _generatePointsCircle ( childMarkers . length , center ) ; } this . _animationSpiderfy ( childMarkers , positions ) ; }
2052	function ( childMarkers , positions ) { var group = this . _group , map = group . _map , fg = group . _featureGroup , i , m , leg , newPos ; for ( i = childMarkers . length - 1 ; i >= 0 ; i -- ) { newPos = map . layerPointToLatLng ( positions [ i ] ) ; m = childMarkers [ i ] ; m . _preSpiderfyLatlng = m . _latlng ; m . setLatLng ( newPos ) ; if ( m . setZIndexOffset ) { m . setZIndexOffset ( 1000000 ) ; } fg . addLayer ( m ) ; leg = new L . Polyline ( [ this . _latlng , newPos ] , { weight : 1.5 , color : '#222' } ) ; map . addLayer ( leg ) ; m . _spiderLeg = leg ; } this . setOpacity ( 0.3 ) ; group . fire ( 'spiderfied' ) ; }
2053	function ( layer ) { if ( layer . _spiderLeg ) { this . _featureGroup . removeLayer ( layer ) ; layer . setOpacity ( 1 ) ; layer . setZIndexOffset ( 0 ) ; this . _map . removeLayer ( layer . _spiderLeg ) ; delete layer . _spiderLeg ; } }
2054	function addToMap ( location , map ) { var marker = L . marker ( location . coordinates ) ; marker . addTo ( map ) ; }
2055	function interpolate ( path , data ) { return path . replace ( / :(\w+) / g , function ( match , param ) { return data [ param ] } ) }
2056	function createPagesUtility ( pages , index ) { return function getPages ( number ) { var offset = Math . floor ( number / 2 ) var start , end if ( index + offset >= pages . length ) { start = Math . max ( 0 , pages . length - number ) end = pages . length } else { start = Math . max ( 0 , index - offset ) end = Math . min ( start + number , pages . length ) } return pages . slice ( start , end ) } }
2057	function ( ) { var templates = { data : { } } ; var stringTemplateSource = function ( template ) { this . text = function ( value ) { if ( arguments . length === 0 ) { return templates [ template ] ; } templates [ template ] = value ; } ; } ; var templateEngine = new ko . nativeTemplateEngine ( ) ; templateEngine . makeTemplateSource = function ( template ) { return new stringTemplateSource ( template ) ; } ; templateEngine . addTemplate = function ( key , value ) { templates [ key ] = value ; } ; return templateEngine ; }
2058	function Job ( collection , data ) { this . collection = collection ; if ( data ) { data . __proto__ = JobData . prototype ; this . data = data ; } else { this . data = new JobData ( ) ; } }
2059	function Worker ( queues , options ) { options || ( options = { } ) ; this . empty = 0 ; this . queues = queues || [ ] ; this . interval = options . interval || 5000 ; this . callbacks = options . callbacks || { } ; this . strategies = options . strategies || { } ; this . universal = options . universal || false ; this . strategies . linear || ( this . strategies . linear = linear ) ; this . strategies . exponential || ( this . strategies . exponential = exponential ) ; this . minPriority = options . minPriority ; }
2060	function handleDragEvents ( e ) { e . stopPropagation ( ) ; e . preventDefault ( ) ; return this . emit ( e . type , e ) ; }
2061	function ( value ) { if ( value != value || value === 0 ) { for ( var i = this . length ; i -- && ! is ( this [ i ] , value ) ; ) { } } else { i = [ ] . indexOf . call ( this , value ) ; } return i ; }
2062	function Tor ( child , port , dir ) { this . process = child ; this . port = port ; this . dir = dir ; }
2063	function getIncluded ( ) { var args = config . files ( ) . included || getDefaultArgs ( ) || getPackageJsonArgs ( ) || getBowerJsonArgs ( ) || [ ] ; return _expandGlobs ( args ) ; }
2064	function getDefaultArgs ( ) { var results = [ ] ; DEFAULT_PATHS . forEach ( function ( dir ) { if ( fs . existsSync ( dir ) ) results . push ( dir ) ; } ) ; return results . length == 0 ? null : results ; }
2065	function getPackageJsonArgs ( ) { var results = [ ] ; var config = _loadJson ( 'package.json' ) ; if ( config . main ) results = results . concat ( getMainFieldAsArray ( config . main ) ) ; if ( config . files ) results = results . concat ( config . files ) ; return results . length == 0 ? null : results . filter ( _uniqfilter ) ; }
2066	function getBowerJsonArgs ( ) { var results = [ ] ; var config = _loadJson ( 'bower.json' ) ; if ( config . main ) results = results . concat ( getMainFieldAsArray ( config . main ) ) ; return results . length == 0 ? null : results . filter ( _uniqfilter ) ; }
2067	function getMainFieldAsArray ( main ) { if ( main . constructor === Array ) { return main ; } else { if ( fs . existsSync ( main ) ) { return [ main ] ; } else if ( fs . existsSync ( main + '.js' ) ) { return [ main + '.js' ] ; } else { return [ ] ; } } }
2068	function TorAgent ( opts ) { if ( ! ( this instanceof TorAgent ) ) { return new TorAgent ( ) ; } http . Agent . call ( this , opts ) ; this . socksHost = opts . socksHost || 'localhost' ; this . socksPort = opts . socksPort || 9050 ; this . defaultPort = 80 ; this . tor = opts . tor ; this . protocol = null ; this . defaultDestroy = this . destroy ; this . destroy = this . destroyWrapper ; }
2069	function run ( inch_args , options ) { var callback = function ( filename ) { LocalInch . run ( inch_args || [ 'suggest' ] , filename , noop ) ; } if ( options . dry_run ) callback = noop ; retriever . run ( PathExtractor . extractPaths ( inch_args ) , callback ) ; }
2070	function shutdown ( addr , b ) { if ( addr < 0 || addr >= maxDevices ) throw 'address out of range' ; if ( b ) spiTransfer ( addr , OP_SHUTDOWN , 0 ) ; else spiTransfer ( addr , OP_SHUTDOWN , 1 ) ; }
2071	function setScanLimit ( addr , limit ) { if ( addr < 0 || addr >= maxDevices ) return ; if ( limit >= 0 && limit < 8 ) spiTransfer ( addr , OP_SCANLIMIT , limit ) ; }
2072	function setBrightness ( addr , intensity ) { if ( addr < 0 || addr >= maxDevices ) return ; if ( typeof intensity == 'undefined' ) return ; intensity = constrain ( intensity , 0 , 15 ) ; spiTransfer ( addr , OP_INTENSITY , intensity ) ; }
2073	function clearDisplay ( addr ) { if ( addr < 0 || addr >= maxDevices ) throw 'address out of range' ; var offset ; offset = addr * 8 ; for ( var i = 0 ; i < 8 ; i ++ ) { status [ offset + i ] = 0 ; spiTransfer ( addr , i + 1 , status [ offset + i ] ) ; } }
2074	function showNumber ( addr , num , decimalplaces , mindigits , leftjustified , pos , dontclear ) { if ( addr < 0 || addr >= maxDevices ) throw 'address out of range' ; num = formatNumber ( num , decimalplaces , mindigits ) ; if ( typeof pos === 'undefined' ) { if ( leftjustified ) { pos = 7 ; } else { pos = 0 ; } } else pos = 7 - pos ; var decimalplace ; if ( num . indexOf ( '.' ) < 0 ) decimalplace = - 1 ; else { decimalplace = num . length - num . indexOf ( '.' ) - 1 ; num = num . split ( '.' ) . join ( '' ) ; } if ( leftjustified ) { pos -= ( num . length - 1 ) ; } for ( var i = 0 ; i < 8 ; i ++ ) { var offset = i + pos ; var char = num . charAt ( num . length - 1 - i ) ; if ( ( offset < 8 && offset >= 0 ) && ( ! dontclear || char != '' ) ) { if ( char == '-' ) setChar ( addr , offset , char , i > 0 && i == decimalplace ) ; else setDigit ( addr , offset , parseInt ( char ) , i > 0 && i == decimalplace ) ; } } }
2075	function getExampleCode ( comment ) { var expectedResult = comment . expectedResult ; var isAsync = comment . isAsync ; var testCase = comment . testCase ; if ( isAsync ) { return '\nfunction cb(err, result) {' + \n + 'if(err) return done(err);' + 'result.should.eql(' + expectedResult + ');' + 'done();' + '}\n' + \n + 'var returnValue = ' + testCase + ';' + 'if(returnValue && returnValue.then && typeof returnValue.then === \'function\') {' ; } else \' }
2076	function ( options ) { "use strict" ; if ( ( options . setter && options . setter . indexOf ( '.' ) > - 1 ) || ( options . getter && options . getter . indexOf ( '.' ) > - 1 ) ) { throw new Error ( 'Getter (' + options . getter + ') and setter (' + options . setter + ') methods cannot be nested, so they cannot contain dot(.)' ) ; } this . options = Joi . attempt ( options , optionsSchema ) ; this . locales = this . getAvailableLocales ( ) ; this . default = this . options . default || this . locales [ 0 ] ; }
2077	function fileExists ( path , shouldBeDir ) { "use strict" ; try { var lstat = fs . lstatSync ( path ) ; if ( shouldBeDir && lstat . isDirectory ( ) ) { return true ; } if ( ! shouldBeDir && lstat . isFile ( ) ) { return true ; } } catch ( err ) { return false ; } return false ; }
2078	async function ( server , options ) { try { var internal = new Internal ( options ) ; } catch ( err ) { throw new Boom ( err ) ; } server . expose ( 'getLocales' , function getLocales ( ) { return internal . locales ; } ) ; server . expose ( 'getDefaultLocale' , function getDefaultLocale ( ) { return internal . default ; } ) ; server . expose ( 'getLocale' , function getLocale ( request ) { try { return lodash . get ( request , internal . options . getter ) ( ) ; } catch ( err ) { return null ; } } ) ; server . ext ( internal . options . onEvent , internal . processRequest , { bind : internal } ) ; }
2079	function ( currDeps , loc ) { loc . deps = loc . deps || [ ] ; var covered = [ ] ; currDeps . forEach ( function ( obj ) { if ( covered . indexOf ( obj . path ) < 0 ) { covered . push ( obj . path ) ; var key = obj . name , isRelative = ( [ '\\' , \\ , '/' ] . '.' indexOf >= ( key [ 0 ] ) ) , 0 , notCovered = notCoveredInArray ( loc . deps , key ) , isRecorded = ( ! isRelative || opts . showLocal ) && notCovered ; res = isRecorded ? { name : key } : loc if ( isRecorded ) { res . path = obj . path ; loc . deps . push ( res ) ; } } } ) ; }
2080	function ( ms , cycles ) { var removed = { } ; cycles . forEach ( function ( c ) { var last = c [ c . length - 1 ] ; var depsInCycle = ms [ last ] . filter ( function ( deps ) { return deps . path && c . indexOf ( deps . path ) >= 0 ; } ) ; if ( ! depsInCycle . length ) { throw new Error ( "logic fail2" ) ; } var depToRemove = depsInCycle [ 0 ] . path ; for ( var i = 0 ; i < ms [ last ] . length ; i += 1 ) { var dep = ms [ last ] [ i ] ; if ( dep . path && dep . path === depToRemove ) { removed [ last ] = dep . name ; ms [ last ] . splice ( i , 1 ) ; } } } ) ; return removed ; }
2081	function ( options ) { assert ( options , "options are required" ) ; assert ( options . name , "Series must be named" ) ; options = _ . defaults ( { } , options , { columns : { } , additionalColumns : null } ) ; this . _options = options ; }
2082	function whenRead ( args ) { let value = getValue ( args ) if ( value && typeof value . then === 'function' ) { value . then ( ( val ) => whenTest ( args , val ) ) . catch ( ( error ) => { console . error ( ` ${ action . displayName } ` , error ) } ) } else { whenTest ( args , value ) } }
2083	function findAndDelete ( target , value ) { if ( ! isIterable ( target ) ) return false ; if ( isArray ( target ) ) { for ( let i = 0 ; i < target . length ; i ++ ) { if ( deep_equal_1 . default ( target [ i ] , value ) ) { target . splice ( i , 1 ) ; return true ; } } } else if ( isObject ( target ) ) { const keys = Object . keys ( target ) ; for ( let i = 0 ; i < keys . length ; i ++ ) { if ( deep_equal_1 . default ( target [ keys [ i ] ] , value ) ) { delete target [ keys [ i ] ] ; return true ; } } } return false ; }
2084	function findAndDeleteAll ( target , value ) { let flag = false ; while ( findAndDelete ( target , value ) ) { flag = true ; } return flag ; }
2085	function ( options ) { assert ( options , "options are required" ) ; assert ( options . connectionString , "options.connectionString is missing" ) ; assert ( url . parse ( options . connectionString ) . protocol === 'https:' || options . allowHTTP , "InfluxDB connectionString must use HTTPS!" ) ; options = _ . defaults ( { } , options , { maxDelay : 60 * 5 , maxPendingPoints : 250 } ) ; this . _options = options ; this . _pendingPoints = { } ; this . _nbPendingPoints = 0 ; this . _flushTimeout = setTimeout ( this . flush . bind ( this , true ) , options . maxDelay * 1000 ) ; }
2086	function ( handler , options ) { assert ( handler instanceof Function , "A handler must be provided" ) ; assert ( options , "options required" ) ; assert ( options . drain , "options.drain is required" ) ; assert ( options . component , "options.component is required" ) ; var reporter = series . HandlerReports . reporter ( options . drain ) ; return function ( message ) { var point = { component : options . component , duration : undefined , exchange : message . exchange || '' , redelivered : ( message . redelivered ? 'true' : 'false' ) , error : 'false' } ; var start = process . hrtime ( ) ; return Promise . resolve ( handler ( message ) ) . then ( function ( ) { var d = process . hrtime ( start ) ; point . duration = d [ 0 ] * 1000 + ( d [ 1 ] / 1000000 ) ; reporter ( point ) ; } , function ( err ) { var d = process . hrtime ( start ) ; point . duration = d [ 0 ] * 1000 + ( d [ 1 ] / 1000000 ) ; point . error = 'true' ; reporter ( point ) ; throw err ; } ) ; } ; }
2087	function ( options ) { assert ( options , "Options are required" ) ; assert ( options . drain , "A drain for the measurements must be provided!" ) ; assert ( options . component , "A component must be specified" ) ; assert ( options . process , "A process name must be specified" ) ; options = _ . defaults ( { } , options , { interval : 60 } ) ; if ( _processUsageReportingInterval ) { debug ( "WARNING: startProcessUsageReporting() already started!" ) ; clearInterval ( _processUsageReportingInterval ) ; _processUsageReportingInterval = null ; } var usage = require ( 'usage' ) ; var reporter = series . UsageReports . reporter ( options . drain ) ; _processUsageReportingInterval = setInterval ( function ( ) { usage . lookup ( process . pid , { keepHistory : true } , function ( err , result ) { if ( err ) { debug ( "Failed to get usage statistics, err: %s, %j" , err , err , err . stack ) ; return ; } reporter ( { component : options . component , process : options . process , cpu : result . cpu , memory : result . memory } ) ; } ) ; } , options . interval * 1000 ) ; }
2088	function ( options ) { options = _ . defaults ( { } , options || { } , { tags : { } , drain : undefined } ) ; assert ( options . drain , "options.drain is required" ) ; assert ( typeof options . tags === 'object' , "options.tags is required" ) ; assert ( _ . intersection ( _ . keys ( options . tags ) , series . APIClientCalls . columns ( ) ) . length === 0 , "Can't used reserved tag names!" ) ; return series . APIClientCalls . reporter ( options . drain , options . tags ) ; }
2089	function buildOptions ( options ) { var result = [ ] ; var keys = Object . keys ( options ) ; keys . forEach ( function ( key ) { var props = options [ key ] ; if ( is . string ( props ) ) { props = { type : props } ; } var name = [ format ( '--%s' , dasherize ( key ) ) ] ; var aliases = props . alias || props . aliases || [ ] ; if ( is . not . array ( aliases ) ) { aliases = [ aliases ] ; } aliases . forEach ( function ( alias ) { alias = format ( '-%s' , alias ) ; name . unshift ( alias ) ; } ) ; result . push ( [ name . join ( ', ' ) , props . desc || '' ] ) ; } ) ; return table ( result ) ; }
2090	function buildCommands ( commands ) { var result = [ ] ; commands . forEach ( function ( command ) { result . push ( [ command . name , command . desc || '' ] ) ; } ) ; return table ( result ) ; }
2091	function Router ( options ) { const logPrefix = topLogPrefix + 'Router() - ' ; const that = this ; let defaultRouteFound = false ; that . options = options || { } ; if ( ! that . options . paths ) { that . options . paths = { 'controller' : { 'path' : 'controllers' , 'exts' : 'js' } , 'static' : { 'path' : 'public' , 'exts' : false } , 'template' : { 'path' : 'public/templates' , 'exts' : [ 'tmpl' , 'tmp' , 'ejs' , 'pug' ] } } ; } if ( ! that . options . routes ) that . options . routes = [ ] ; if ( ! that . options . basePath ) that . options . basePath = process . cwd ( ) ; if ( ! that . options . log ) { const lUtils = new LUtils ( ) ; that . options . log = new lUtils . Log ( ) ; } for ( const key of Object . keys ( that . options . paths ) ) { if ( ! Array . isArray ( that . options . paths [ key ] . exts ) && that . options . paths [ key ] . exts !== false ) { that . options . paths [ key ] . exts = [ that . options . paths [ key ] . exts ] ; } } if ( ! that . options . lfs ) { that . options . lfs = new Lfs ( { 'basePath' : that . options . basePath , 'log' : that . options . log } ) ; } for ( let i = 0 ; that . options . routes [ i ] !== undefined ; i ++ ) { if ( that . options . routes [ i ] . regex === '^/$' ) { defaultRouteFound = true ; break ; } } if ( defaultRouteFound === false ) { that . options . routes . push ( { 'regex' : '^/$' , 'controllerPath' : 'default.js' , 'templatePath' : 'default.tmpl' } ) ; } for ( const key of Object . keys ( that . options ) ) { that [ key ] = that . options [ key ] ; } that . log . debug ( logPrefix + 'Instantiated with options: ' + JSON . stringify ( that . options ) ) ; }
2092	function getDefaultPortByProtocol ( rawProtocol ) { const protocol = rawProtocol . endsWith ( ':' ) ? rawProtocol . slice ( 0 , - 1 ) : rawProtocol const portByProtocol = portNumbers . getPort ( protocol ) return portByProtocol ? Promise . resolve ( String ( portByProtocol . port ) ) : Promise . reject ( new Error ( 'Has no port' ) ) }
2093	function clearScripts ( node ) { var rslt = { } ; for ( var key in node ) { var val = node [ key ] ; if ( _ . isString ( val ) ) { if ( val . trim ( ) ) rslt [ key ] = "..." ; } else { var childScripts = clearScripts ( val ) ; if ( ! _ . isEmpty ( childScripts ) ) rslt [ key ] = childScripts ; } } return rslt ; }
2094	function ( obj , array ) { if ( ! Array . prototype . indexOf ) { for ( var i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] === obj ) { return i ; } } return - 1 ; } else { return array . indexOf ( obj ) ; } }
2095	function getElementValues ( nodeList , initialScope ) { const valueList = [ ] for ( let i = 0 ; i < nodeList . length ; ++ i ) { const elementNode = nodeList [ i ] if ( elementNode == null ) { valueList . length = i + 1 } else if ( elementNode . type === "SpreadElement" ) { const argument = getStaticValueR ( elementNode . argument , initialScope ) if ( argument == null ) { return null } valueList . push ( ... argument . value ) } else { const element = getStaticValueR ( elementNode , initialScope ) if ( element == null ) { return null } valueList . push ( element . value ) } } return valueList }
2096	function getStaticValueR ( node , initialScope ) { if ( node != null && Object . hasOwnProperty . call ( operations , node . type ) ) { return operations [ node . type ] ( node , initialScope ) } return null }
2097	function isModifiedGlobal ( variable ) { return ( variable == null || variable . defs . length !== 0 || variable . references . some ( r => r . isWrite ( ) ) ) }
2098	function config ( ext ) { return { input : "src/index.js" , output : { file : ` ${ ext } ` , format : ext === ".mjs" ? "es" : "cjs" , sourcemap : true , sourcemapFile : ` ${ ext } ` , strict : true , banner : ` ` , } , plugins : [ sourcemaps ( ) ] , external : Object . keys ( require ( "./package.json" ) . dependencies ) , } }
2099	function isEscaped ( str , index ) { let escaped = false for ( let i = index - 1 ; i >= 0 && str . charCodeAt ( i ) === 0x5c ; -- i ) { escaped = ! escaped } return escaped }
2100	function replaceS ( matcher , str , replacement ) { const chunks = [ ] let index = 0 let match = null function replacer ( key ) { switch ( key ) { case "$$" : return "$" case "$&" : return match [ 0 ] case "$`" : return str . slice ( 0 , match . index ) case "$'" : return str . slice ( match . index + match [ 0 ] . length ) default : { const i = key . slice ( 1 ) if ( i in match ) { return match [ i ] } return key } } } for ( match of matcher . execAll ( str ) ) { chunks . push ( str . slice ( index , match . index ) ) chunks . push ( replacement . replace ( placeholder , replacer ) ) index = match . index + match [ 0 ] . length } chunks . push ( str . slice ( index ) ) return chunks . join ( "" ) }
2101	function replaceF ( matcher , str , replace ) { const chunks = [ ] let index = 0 for ( const match of matcher . execAll ( str ) ) { chunks . push ( str . slice ( index , match . index ) ) chunks . push ( String ( replace ( ... match , match . index , match . input ) ) ) index = match . index + match [ 0 ] . length } chunks . push ( str . slice ( index ) ) return chunks . join ( "" ) }
2102	function send ( msg ) { switch ( ps . readyState ) { case 0 : setTimeout ( function ( ) { send ( msg ) ; } , 1000 ) ; break ; case 2 : case 3 : _event ( 'dev' , 'pubsub - reconnect: send() - closing/closed state' ) ; connect ( ) ; setTimeout ( function ( ) { send ( msg ) ; } , 2000 ) ; break ; case 1 : try { ps . send ( msg ) ; } catch ( err ) { console . error ( err ) ; setTimeout ( function ( ) { send ( msg ) ; } , 1500 ) ; } break ; default : break ; } }
2103	function parseMessage ( data ) { switch ( data . topic ) { case 'channel-bits-events-v1.' + state . channel_id : bits ( ) ; break ; case 'chat_moderator_actions.' + state . id + '.' + state . id : moderation ( ) ; break ; case 'whispers.' + state . id : whisper ( ) ; break ; default : break ; } function bits ( ) { let bits = JSON . parse ( data . message ) ; _event ( 'bits' , bits ) ; } function moderation ( ) { let moderation = JSON . parse ( data . message ) . data ; _event ( 'moderation' , moderation ) ; } function whisper ( ) { let message = JSON . parse ( data . message ) . data_object ; } }
2104	function JWT ( secret , options ) { this . token = '' ; this . payload = { } ; this . secret = secret ; this . options = options ; this . valid = false ; this . expired = false ; this . stale = true ; }
2105	function ( payload ) { payload . stales = Date . now ( ) + this . options . stales ; this . payload = payload ; this . token = utils . sign ( this . payload , this . secret , this . options . signOptions ) ; this . valid = true ; this . expired = false ; this . stale = false ; return this ; }
2106	function ( res ) { if ( this . options . cookies ) { res . cookie ( this . options . cookie , this . token , this . options . cookieOptions ) ; } return this ; }
2107	function ( ) { return { token : this . token , payload : this . payload , valid : this . valid , expired : this . expired , stale : this . stale } ; }
2108	function ( token ) { this . token = token || '' ; try { this . payload = utils . verify ( this . token , this . secret , this . options . verifyOptions ) ; this . valid = true ; } catch ( err ) { this . payload = utils . decode ( this . token ) || { } ; if ( err . name == 'TokenExpiredError' ) { this . expired = true ; } } if ( this . valid && ! this . options . verify ( this ) ) { this . valid = false ; } if ( this . payload . stales && Date . now ( ) <= this . payload . stales ) { this . stale = false ; } return this ; }
2109	function ( secret , options ) { if ( ! secret ) { throw new ReferenceError ( 'secret must be defined' ) ; } if ( typeof secret == 'string' ) { var _secret = secret ; secret = function ( req ) { return _secret } ; } options = options || { } ; var defaults = { cookie : 'jwt-express' , cookieOptions : { httpOnly : true } , cookies : true , refresh : true , reqProperty : 'jwt' , revoke : function ( jwt ) { } , signOptions : { } , stales : 900000 , verify : function ( jwt ) { return true } , verifyOptions : { } } ; for ( var key in defaults ) { this . options [ key ] = options [ key ] !== undefined ? options [ key ] : defaults [ key ] ; } return function ( req , res , next ) { var token ; if ( this . options . cookies ) { token = req . cookies [ this . options . cookie ] ; } else if ( req . headers . authorization ) { token = req . headers . authorization . split ( ' ' ) [ 1 ] ; } var jwt = new JWT ( secret ( req ) , this . options ) ; req [ this . options . reqProperty ] = jwt . verify ( token ) ; if ( jwt . valid && ! jwt . stale && jwt . options . refresh ) { jwt . resign ( ) . store ( res ) ; } res . jwt = function ( payload ) { var jwt = new JWT ( secret ( req ) , this . options ) ; return jwt . sign ( payload ) . store ( res ) ; } . bind ( this ) ; this . clear = function ( ) { if ( this . options . cookies ) { res . clearCookie ( this . options . cookie ) ; } } . bind ( this ) ; next ( ) ; } . bind ( this ) ; }
2110	function ( ) { return function ( req , res , next ) { var jwt = req [ this . options . reqProperty ] || { } ; if ( ! jwt . valid ) { next ( new JWTExpressError ( 'JWT is invalid' ) ) ; } else { next ( ) ; } } . bind ( this ) ; }
2111	function setupComponent ( fixture , options ) { if ( this . component ) { this . component . teardown ( ) ; this . $node . remove ( ) ; } if ( fixture instanceof jQuery || typeof fixture === 'string' ) { this . $node = $ ( fixture ) . addClass ( 'component-root' ) ; } else { this . $node = $ ( '<div class="component-root" />' ) ; options = fixture ; fixture = null ; } $ ( 'body' ) . append ( this . $node ) ; options = options === undefined ? { } : options ; this . component = ( new this . Component ( ) ) . initialize ( this . $node , options ) ; }
2112	function describeModuleFactory ( modulePath , specDefinitions ) { return function ( ) { beforeEach ( function ( done ) { this . module = null ; var requireCallback = function ( module ) { this . module = module ; done ( ) ; } . bind ( this ) ; require ( [ modulePath ] , requireCallback ) ; } ) ; specDefinitions . apply ( this ) ; } ; }
2113	function consul ( options , resilient ) { defineResilientOptions ( params , options ) return { 'in' : function inHandler ( err , res , next ) { if ( err ) return next ( ) if ( Array . isArray ( res . data ) && Object ( res . data [ 0 ] ) === res . data [ 0 ] ) { res . data = mapServers ( res . data ) } next ( ) } , 'out' : function outHandler ( options , next ) { options . params = options . params || { } if ( params . datacenter ) { options . params . dc = params . datacenter } if ( params . onlyHealthy ) { options . params . passing = true } if ( params . tag ) { options . params . tag = params . tag } next ( ) } } }
2114	function inHandler ( err , res , next ) { if ( err ) return next ( ) if ( Array . isArray ( res . data ) && Object ( res . data [ 0 ] ) === res . data [ 0 ] ) { res . data = mapServers ( res . data ) } next ( ) }
2115	function outHandler ( options , next ) { options . params = options . params || { } if ( params . datacenter ) { options . params . dc = params . datacenter } if ( params . onlyHealthy ) { options . params . passing = true } if ( params . tag ) { options . params . tag = params . tag } next ( ) }
2116	function ( categoryId , event ) { event . preventDefault ( ) ; this . refs . scroller . prepareAnimationSync ( ) ; this . setState ( { mode : 'single' , selected : categoryId , previousScrollPosition : this . refs . scroller . scrollTop , } , function ( ) { this . refs . scroller . animateAndResetScroll ( 0 , 0 ) ; } ) ; }
2117	function ( event ) { event . preventDefault ( ) ; this . setState ( { mode : 'all' , selected : null , } , function ( ) { this . refs . scroller . animateAndResetScroll ( 0 , this . state . previousScrollPosition ) ; } ) ; }
2118	function Service ( displayName , UUID , subtype ) { if ( ! UUID ) throw new Error ( "Services must be created with a valid UUID." ) ; this . displayName = displayName ; this . UUID = UUID ; this . subtype = subtype ; this . iid = null ; this . characteristics = [ ] ; this . optionalCharacteristics = [ ] ; if ( displayName ) { var nameCharacteristic = this . getCharacteristic ( Characteristic . Name ) || this . addCharacteristic ( Characteristic . Name ) ; nameCharacteristic . setValue ( displayName ) ; } }
2119	function Characteristic ( displayName , UUID , props ) { this . displayName = displayName ; this . UUID = UUID ; this . iid = null ; this . value = null ; this . props = props || { format : null , unit : null , minValue : null , maxValue : null , minStep : null , perms : [ ] } ; }
2120	function migrateDatabase ( nativeDatabase , nativeTransaction , schemaDescriptors , currentVersion ) { let descriptorsToProcess = schemaDescriptors . filter ( ( descriptor ) => { return descriptor . version > currentVersion } ) if ( ! descriptorsToProcess . length ) { return PromiseSync . resolve ( undefined ) } return migrateDatabaseVersion ( nativeDatabase , nativeTransaction , descriptorsToProcess [ 0 ] ) . then ( ( ) => { return migrateDatabase ( nativeDatabase , nativeTransaction , descriptorsToProcess , descriptorsToProcess [ 0 ] . version ) } ) }
2121	function migrateDatabaseVersion ( nativeDatabase , nativeTransaction , descriptor ) { let fetchPromise if ( descriptor . fetchBefore && descriptor . fetchBefore . length ) { let fetcher = new RecordFetcher ( ) let objectStores = normalizeFetchBeforeObjectStores ( descriptor . fetchBefore ) fetchPromise = fetcher . fetchRecords ( nativeTransaction , objectStores ) } else { fetchPromise = PromiseSync . resolve ( { } ) } return fetchPromise . then ( ( recordsMap ) => { let versionMigrator = new DatabaseVersionMigrator ( nativeDatabase , nativeTransaction , descriptor . objectStores ) return versionMigrator . executeMigration ( descriptor . after || ( ( ) => { } ) , recordsMap ) } ) }
2122	function normalizeFetchBeforeObjectStores ( objectStores ) { return objectStores . map ( ( objectStore ) => { if ( typeof objectStore === "string" ) { return { objectStore , preprocessor : record => record } } else if ( ! objectStore . preprocessor ) { return { objectStore : objectStore . objectStore , preprocessor : record => record } } else { return objectStore } } ) }
2123	function checkSchemaDescriptorTypes ( schemaDescriptors ) { let onlyPlainObjects = schemaDescriptors . every ( ( descriptor ) => { return descriptor . constructor === Object } ) if ( onlyPlainObjects ) { return } if ( ! ( schemaDescriptors [ 0 ] instanceof DatabaseSchema ) ) { throw new TypeError ( "The schema descriptor of the lowest described " + ` ${ schemaDescriptors [ 0 ] . version } ` + "DatabaseSchema instance, or all schema descriptors must be plain " + "objects" ) } schemaDescriptors . slice ( 1 ) . forEach ( ( descriptor ) => { if ( ! ( descriptor instanceof UpgradedDatabaseSchema ) ) { throw new TypeError ( "The schema descriptors of the upgraded database " + "versions must be UpgradedDatabaseSchema instances, but the " + ` ${ descriptor . version } ` + "UpgradedDatabaseSchema instance, or all schema descriptors must " + "be plain objects" ) } } ) }
2124	function list ( storage , keyRange , filter , direction , unique , pageSize , storageFactory ) { return new Promise ( ( resolve , reject ) => { let items = [ ] storage . createCursorFactory ( keyRange , direction ) ( ( cursor ) => { if ( ! filter || filter ( cursor . record , cursor . primaryKey , cursor . key ) ) { if ( items . length === pageSize ) { finalize ( true , cursor . key , cursor . primaryKey ) return } else { items . push ( cursor . record ) } } cursor . continue ( ) } ) . then ( ( ) => finalize ( false , null , null ) ) . catch ( error => reject ( error ) ) function finalize ( hasNextPage , nextKey , nextPrimaryKey ) { resolve ( new RecordList ( items , storageFactory , nextKey , nextPrimaryKey , direction , unique , filter , pageSize , hasNextPage ) ) } } ) }
2125	function normalizeCompoundObjectKey ( keyPaths , key ) { let normalizedKey = [ ] keyPaths . forEach ( ( keyPath ) => { let keyValue = key keyPath . split ( "." ) . forEach ( ( fieldName ) => { if ( ! keyValue . hasOwnProperty ( fieldName ) ) { throw new Error ( ` ${ keyPath } ` + "provided compound key" ) } keyValue = keyValue [ fieldName ] } ) normalizedKey . push ( keyValue ) } ) return normalizedKey }
2126	function iterateCursor ( request , cursorConstructor , recordCallback ) { return new PromiseSync ( ( resolve , reject ) => { let traversedRecords = 0 let canIterate = true request . onerror = ( ) => reject ( request . error ) request . onsuccess = ( ) => { if ( ! canIterate ) { console . warn ( "Cursor iteration was requested asynchronously, " + "ignoring the new cursor position" ) return } if ( ! request . result ) { resolve ( traversedRecords ) return } traversedRecords ++ let iterationRequested = handleCursorIteration ( request , cursorConstructor , recordCallback , reject ) if ( ! iterationRequested ) { canIterate = false resolve ( traversedRecords ) } } } ) }
2127	function handleCursorIteration ( request , cursorConstructor , recordCallback , reject ) { let iterationRequested = false let cursor = new cursorConstructor ( request , ( ) => { iterationRequested = true } , ( subRequest ) => { return PromiseSync . resolve ( subRequest ) . catch ( ( error ) => { reject ( error ) throw error } ) } ) try { recordCallback ( cursor ) } catch ( error ) { iterationRequested = false reject ( error ) } return iterationRequested }
2128	function fetchAllRecords ( transaction , objectStores ) { return PromiseSync . all ( objectStores . map ( ( descriptor ) => { return fetchRecords ( transaction . getObjectStore ( descriptor . objectStore ) , descriptor . preprocessor ) } ) ) . then ( ( fetchedRecords ) => { let recordsMap = { } for ( let i = 0 ; i < objectStores . length ; i ++ ) { recordsMap [ objectStores [ i ] . objectStore ] = fetchedRecords [ i ] } return recordsMap } ) }
2129	function fetchRecords ( objectStore , preprocessor ) { return new PromiseSync ( ( resolve , reject ) => { let records = [ ] objectStore . openCursor ( null , CursorDirection . NEXT , ( cursor ) => { let primaryKey = cursor . primaryKey if ( primaryKey instanceof Object ) { Object . freeze ( primaryKey ) } let preprocessedRecord = preprocessor ( cursor . record , primaryKey ) if ( preprocessedRecord === UpgradedDatabaseSchema . DELETE_RECORD ) { cursor . delete ( ) cursor . continue ( ) return } else if ( preprocessedRecord !== UpgradedDatabaseSchema . SKIP_RECORD ) { records . push ( { key : primaryKey , record : preprocessedRecord } ) } else { } cursor . continue ( ) } ) . then ( ( ) => resolve ( records ) ) . catch ( error => reject ( error ) ) } ) }
2130	function writeFileP ( outputPath , data , cb ) { outputPath = abs ( outputPath ) ; let dirname = path . dirname ( outputPath ) ; mkdirp ( dirname , err => { if ( err ) { return cb ( err ) ; } let str = data ; if ( typpy ( data , Array ) || typpy ( data , Object ) ) { str = JSON . stringify ( data , null , 2 ) ; } fs . writeFile ( outputPath , str , err => cb ( err , data ) ) ; } ) ; }
2131	function runTransaction ( transaction , objectStoreNames , transactionOperations ) { let callbackArguments = objectStoreNames . map ( ( objectStoreName ) => { return transaction . getObjectStore ( objectStoreName ) } ) callbackArguments . push ( ( ) => transaction . abort ( ) ) let resultPromise = transactionOperations ( ... callbackArguments ) return Promise . resolve ( resultPromise ) . then ( ( result ) => { return transaction . completionPromise . then ( ( ) => result ) } ) }
2132	function toNativeCursorDirection ( direction , unique ) { if ( typeof direction === "string" ) { if ( CURSOR_DIRECTIONS . indexOf ( direction . toUpperCase ( ) ) === - 1 ) { throw new Error ( "When using a string as cursor direction, use NEXT " + ` ${ direction } ` ) ; } } else { direction = direction . value } let cursorDirection = direction . toLowerCase ( ) . substring ( 0 , 4 ) if ( unique ) { cursorDirection += "unique" } return cursorDirection }
2133	function createIndex ( objectStore , indexSchema ) { let indexNames = Array . from ( objectStore . indexNames ) if ( indexNames . indexOf ( indexSchema . name ) !== - 1 ) { return } objectStore . createIndex ( indexSchema . name , indexSchema . keyPath , { unique : indexSchema . unique , multiEntry : indexSchema . multiEntry } ) }
2134	function fetchNextPage ( storageFactory , keyRange , cursorDirection , unique , firstPrimaryKey , filter , pageSize ) { let storage = storageFactory ( ) let nextItems = [ ] return new Promise ( ( resolve , reject ) => { let idb = idbProvider ( ) let cursorFactory = storage . createCursorFactory ( keyRange , cursorDirection , unique ) cursorFactory ( ( cursor ) => { if ( ! unique ) { let shouldSkip = ( ( cursorDirection === CursorDirection . NEXT ) && ( idb . cmp ( firstPrimaryKey , cursor . primaryKey ) > 0 ) ) || ( ( cursorDirection === CursorDirection . PREVIOUS ) && ( idb . cmp ( firstPrimaryKey , cursor . primaryKey ) < 0 ) ) if ( shouldSkip ) { cursor . continue ( ) return } } if ( ! filter || filter ( cursor . record , cursor . primaryKey , cursor . key ) ) { if ( nextItems . length === pageSize ) { finalize ( true , cursor . key , cursor . primaryKey ) return } else { nextItems . push ( cursor . record ) } } cursor . continue ( ) } ) . then ( ( ) => finalize ( false , null , null ) ) . catch ( error => reject ( error ) ) function finalize ( hasNextPage , nextKey , nextPrimaryKey ) { resolve ( new RecordList ( nextItems , storageFactory , nextKey , nextPrimaryKey , cursorDirection , unique , filter , pageSize , hasNextPage ) ) } } ) }
2135	function executeEventListeners ( listeners , ... parameters ) { listeners . forEach ( ( listener ) => { try { listener . apply ( null , parameters ) } catch ( error ) { console . error ( "An event listener threw an error" , error ) } } ) }
2136	function resolve ( instance , newState , value ) { if ( instance [ FIELDS . state ] !== STATE . PENDING ) { return } instance [ FIELDS . state ] = newState instance [ FIELDS . value ] = value let listeners if ( newState === STATE . RESOLVED ) { listeners = instance [ FIELDS . fulfillListeners ] } else { listeners = instance [ FIELDS . errorListeners ] } for ( let listener of listeners ) { listener ( ) } }
2137	function runQuery ( cursorFactory , filter , comparator , offset , limit , callback ) { let records = [ ] let recordIndex = - 1 return cursorFactory ( ( cursor ) => { if ( ! filter && offset && ( ( recordIndex + 1 ) < offset ) ) { recordIndex = offset - 1 cursor . advance ( offset ) return } let primaryKey = cursor . primaryKey if ( filter && ! filter ( cursor . record , primaryKey ) ) { cursor . continue ( ) return } if ( comparator ) { insertSorted ( records , cursor . record , primaryKey , comparator ) if ( offset || limit ) { if ( records . length > ( offset + limit ) ) { records . pop ( ) } } cursor . continue ( ) return } recordIndex ++ if ( recordIndex < offset ) { cursor . continue ( ) return } callback ( cursor . record , primaryKey ) if ( ! limit || ( ( recordIndex + 1 ) < ( offset + limit ) ) ) { cursor . continue ( ) } } ) . then ( ( ) => { if ( ! comparator ) { return } records = records . slice ( offset ) for ( let { record , primaryKey } of records ) { callback ( record , primaryKey ) } } ) }
2138	function insertSorted ( records , record , primaryKey , comparator ) { let index = findInsertIndex ( records , record , comparator ) records . splice ( index , 0 , { record , primaryKey } ) }
2139	function findInsertIndex ( records , record , comparator ) { if ( ! records . length ) { return 0 } if ( records . length === 1 ) { let comparison = comparator ( records [ 0 ] . record , record ) return ( comparison > 0 ) ? 0 : 1 } let comparison = comparator ( records [ 0 ] . record , record ) if ( comparison > 0 ) { return 0 } let bottom = 1 let top = records . length - 1 while ( bottom <= top ) { let pivotIndex = Math . floor ( ( bottom + top ) / 2 ) let comparison = comparator ( records [ pivotIndex ] . record , record ) if ( comparison > 0 ) { let previousElement = records [ pivotIndex - 1 ] . record if ( comparator ( previousElement , record ) <= 0 ) { return pivotIndex } top = pivotIndex - 1 } else { bottom = pivotIndex + 1 } } return records . length }
2140	function prepareQuery ( thisStorage , filter , order ) { order = normalizeKeyPath ( order ) let expectedSortingDirection = order [ 0 ] . charAt ( 0 ) === "!" let canSortingBeOptimized canSortingBeOptimized = canOptimizeSorting ( expectedSortingDirection , order ) let storages = new Map ( ) storages . set ( normalizeKeyPath ( thisStorage . keyPath ) , { storage : thisStorage , score : 1 } ) for ( let indexName of thisStorage . indexNames ) { let index = thisStorage . getIndex ( indexName ) if ( ! index . multiEntry ) { storages . set ( normalizeKeyPath ( index . keyPath ) , { storage : index , score : 0 } ) } } let simplifiedOrderFieldPaths = simplifyOrderingFieldPaths ( order ) if ( canSortingBeOptimized ) { prepareSortingOptimization ( storages , simplifiedOrderFieldPaths ) } prepareFilteringOptimization ( storages , filter ) return chooseStorageForQuery ( storages , order , simplifiedOrderFieldPaths , canSortingBeOptimized , expectedSortingDirection ) }
2141	function prepareSortingOptimization ( storages , simplifiedOrderFieldPaths ) { let idb = idbProvider ( ) for ( let [ keyPath , storageAndScore ] of storages ) { let keyPathSlice = keyPath . slice ( 0 , simplifiedOrderFieldPaths . length ) if ( idb . cmp ( keyPathSlice , simplifiedOrderFieldPaths ) === 0 ) { storageAndScore . score += 4 } } }
2142	function prepareFilteringOptimization ( storages , filter ) { if ( filter instanceof Function ) { for ( let [ keyPath , storageAndScore ] of storages ) { storageAndScore . filter = filter } return } for ( let [ keyPath , storageAndScore ] of storages ) { let normalizedFilter = normalizeFilter ( filter , keyPath ) if ( normalizedFilter instanceof Function ) { let isOptimizableFilter = ( filter instanceof Object ) && ! ( filter instanceof Date ) && ! ( filter instanceof Array ) && ! ( filter instanceof IDBKeyRange ) if ( isOptimizableFilter ) { let partialOptimization = partiallyOptimizeFilter ( filter , keyPath ) storageAndScore . keyRange = partialOptimization . keyRange storageAndScore . filter = partialOptimization . filter if ( partialOptimization . score ) { storageAndScore . score += 1 + partialOptimization . score } } else { storageAndScore . filter = normalizedFilter } } else { storageAndScore . keyRange = normalizedFilter storageAndScore . score += 2 } } }
2143	function chooseStorageForQuery ( storages , order , simplifiedOrderFieldPaths , canSortingBeOptimized , expectedSortingDirection ) { let sortedStorages = Array . from ( storages . values ( ) ) sortedStorages . sort ( ( storage1 , storage2 ) => { return storage2 . score - storage1 . score } ) let chosenStorageDetails = sortedStorages [ 0 ] let chosenStorage = chosenStorageDetails . storage let chosenStorageKeyPath = normalizeKeyPath ( chosenStorage . keyPath ) let storageKeyPathSlice = chosenStorageKeyPath . slice ( 0 , simplifiedOrderFieldPaths . length ) let optimizeSorting = canSortingBeOptimized && ( idbProvider ( ) . cmp ( storageKeyPathSlice , simplifiedOrderFieldPaths ) === 0 ) return { storage : chosenStorage , direction : optimizeSorting ? ( CursorDirection [ expectedSortingDirection ? "PREVIOUS" : "NEXT" ] ) : CursorDirection . NEXT , comparator : optimizeSorting ? null : compileOrderingFieldPaths ( order ) , keyRange : chosenStorageDetails . keyRange , filter : chosenStorageDetails . filter } }
2144	function prepareOrderingSpecificationForQuery ( order , keyPath ) { if ( order === null ) { order = CursorDirection . NEXT } let isCursorDirection = ( ( typeof order === "string" ) && ( CURSOR_DIRECTIONS . indexOf ( order . toUpperCase ( ) ) > - 1 ) ) || ( CURSOR_DIRECTIONS . indexOf ( order ) > - 1 ) if ( isCursorDirection && ( typeof order === "string" ) ) { order = CursorDirection [ order . toUpperCase ( ) ] || CursorDirection . PREVIOUS } if ( order instanceof CursorDirection ) { keyPath = normalizeKeyPath ( keyPath ) if ( order === CursorDirection . NEXT ) { return keyPath } else { return keyPath . map ( fieldPath => ` ${ fieldPath } ` ) } } return order }
2145	function openConnection ( databaseName , sortedSchemaDescriptors ) { let version = sortedSchemaDescriptors . slice ( ) . pop ( ) . version let request = NativeDBAccessor . indexedDB . open ( databaseName , version ) return new Promise ( ( resolve , reject ) => { let wasBlocked = false let upgradeTriggered = false let migrationPromiseResolver , migrationPromiseRejector let migrationPromise = new Promise ( ( resolve , reject ) => { migrationPromiseResolver = resolve migrationPromiseRejector = reject } ) migrationPromise . catch ( ( ) => { } ) request . onsuccess = ( ) => { let database = new Database ( request . result ) resolve ( database ) migrationPromiseResolver ( ) } request . onupgradeneeded = ( event ) => { if ( ! wasBlocked ) { upgradeTriggered = true } let database = request . result let transaction = request . transaction if ( wasBlocked ) { transaction . abort ( ) return } upgradeDatabaseSchema ( databaseName , event , migrationPromise , database , transaction , sortedSchemaDescriptors , migrationPromiseResolver , migrationPromiseRejector ) . catch ( ( error ) => { transaction . abort ( ) } ) } request . onerror = ( event ) => { handleConnectionError ( event , request . error , wasBlocked , upgradeTriggered , reject , migrationPromiseRejector ) } request . onblocked = ( ) => { wasBlocked = true let error = new Error ( "A database upgrade was needed, but could not " + "be performed, because the attempt was blocked by a connection " + "that remained opened after receiving the notification" ) reject ( error ) migrationPromiseRejector ( error ) } } ) }
2146	function handleConnectionError ( event , error , wasBlocked , upgradeTriggered , reject , migrationPromiseRejector ) { if ( wasBlocked || upgradeTriggered ) { event . preventDefault ( ) return } reject ( request . error ) migrationPromiseRejector ( request . error ) }
2147	function executeMigrationListeners ( databaseName , oldVersion , newVersion , completionPromise ) { for ( let listener of migrationListeners ) { try { listener ( databaseName , oldVersion , newVersion , completionPromise ) } catch ( e ) { console . warn ( "A schema migration event listener threw an error" , e ) ; } } }
2148	function splitFilteringObject ( filter , filterFieldPaths , storageKeyPath ) { let fieldsToOptimize = { } let fieldsToCompile = { } filterFieldPaths . forEach ( ( fieldPath ) => { let value = getFieldValue ( filter , fieldPath ) if ( storageKeyPath . indexOf ( fieldPath ) > - 1 ) { setFieldValue ( fieldsToOptimize , fieldPath , value ) } else { setFieldValue ( fieldsToCompile , fieldPath , value ) } } ) return { fieldsToOptimize , fieldsToCompile } }
2149	function getFieldPaths ( object , stopOnKeyRange = true ) { let fieldPaths = [ ] fieldPaths . containsKeyRange = false generateFieldPaths ( object , [ ] ) return fieldPaths function generateFieldPaths ( object , parts ) { Object . keys ( object ) . some ( ( fieldName ) => { let value = object [ fieldName ] if ( stopOnKeyRange && ( value instanceof IDBKeyRange ) ) { fieldPaths = null return true } let isTerminalValue = ! ( value instanceof Object ) || ( value instanceof Date ) || ( value instanceof Array ) || ( value instanceof IDBKeyRange ) let fieldPath = parts . slice ( ) fieldPath . push ( fieldName ) if ( isTerminalValue ) { fieldPaths . push ( fieldPath . join ( "." ) ) } else { generateFieldPaths ( value , fieldPath ) } } ) } }
2150	function setFieldValue ( object , fieldPath , value ) { let parts = fieldPath . split ( "." ) let done = [ ] let currentObject = object while ( parts . length ) { let field = parts . shift ( ) if ( ! parts . length ) { if ( currentObject . hasOwnProperty ( field ) ) { throw new Error ( ` ${ fieldPath } ` ) } currentObject [ field ] = value break } if ( ! currentObject . hasOwnProperty ( field ) ) { currentObject [ field ] = { } } if ( ! ( currentObject [ field ] instanceof Object ) ) { throw new Error ( ` ${ fieldPath } ` + ` ${ done . join ( "." ) } ` ) } currentObject = currentObject [ field ] done . push ( field ) } }
2151	function getFieldValue ( object , fieldPath ) { if ( ! fieldPath ) { return object } let currentObject = object fieldPath . split ( "." ) . forEach ( ( fieldName ) => { if ( ! currentObject . hasOwnProperty ( fieldName ) ) { throw new Error ( ` ${ fieldPath } ` + "provided object" ) } currentObject = currentObject [ fieldName ] } ) return currentObject }
2152	function upgradeSchema ( nativeDatabase , nativeTransaction , descriptors ) { let objectStoreNames = Array . from ( nativeDatabase . objectStoreNames ) let newObjectStoreNames = descriptors . map ( ( objectStore ) => { return objectStore . name } ) objectStoreNames . forEach ( ( objectStoreName ) => { if ( newObjectStoreNames . indexOf ( objectStoreName ) === - 1 ) { nativeDatabase . deleteObjectStore ( objectStoreName ) } } ) descriptors . forEach ( ( objectStoreDescriptor ) => { let objectStoreName = objectStoreDescriptor . name let nativeObjectStore = objectStoreNames . indexOf ( objectStoreName ) > - 1 ? nativeTransaction . objectStore ( objectStoreName ) : null let objectStoreMigrator = new ObjectStoreMigrator ( nativeDatabase , nativeObjectStore , objectStoreDescriptor ) objectStoreMigrator . executeMigration ( ) } ) }
2153	function container ( width , height , position , elem ) { return new Element ( new ContainerElement ( position , elem ) , width , height ) }
2154	function mainSection ( state ) { var todos = state . todos var route = state . route return h ( "section.main" , { hidden : todos . length === 0 } , [ toggleAllPool . change ( h ( "input#toggle-all.toggle-all" , { type : "checkbox" , checked : todos . every ( function ( todo ) { return todo . completed } ) } ) ) , h ( "label" , { htmlFor : "toggle-all" } , "Mark all as complete" ) , h ( "ul.todo-list" , todos . filter ( function ( todo ) { return route === "completed" && todo . completed || route === "active" && ! todo . completed || route === "all" } ) . map ( todoItem ) ) ] ) }
2155	function Client ( ) { EventEmitter . call ( this ) ; this . debug = true ; this . socket = dgram . createSocket ( 'udp4' ) ; this . isSocketBound = false ; this . devices = { } ; this . port = constants . DREAMSCREEN_PORT ; this . discoveryTimer = null ; this . messageHandlers = [ ] ; this . messageHandlerTimeout = 5000 ; this . broadcastIp = constants . DEFAULT_BROADCAST_IP ; }
2156	function Light ( constr ) { this . client = constr . client ; this . ipAddress = constr . ipAddress ; this . serialNumber = constr . serialNumber ; this . productId = constr . productId ; this . lastSeen = constr . lastSeen ; this . isReachable = constr . isReachable ; this . name = constr . name ; this . groupName = constr . groupName ; this . groupNumber = constr . groupNumber ; this . mode = constr . mode ; this . brightness = constr . brightness ; this . ambientColor = constr . ambientColor ; this . ambientShow = constr . ambientShow ; this . ambientModeType = constr . ambientModeType ; this . hdmiInput = constr . hdmiInput ; this . hdmiInputName1 = constr . hdmiInputName1 ; this . hdmiInputName2 = constr . hdmiInputName2 ; this . hdmiInputName3 = constr . hdmiInputName3 ; }
2157	function plainText ( content ) { var textSize = getTextSize ( content ) return new Element ( new TextElement ( "left" , content ) , textSize . width , textSize . height ) }
2158	function ( json ) { var output = '[<ul class="array collapsible">' ; var hasContents = false ; for ( var prop in json ) { hasContents = true ; output += '<li>' ; output += this . valueToHTML ( json [ prop ] ) ; output += '</li>' ; } output += '</ul>]' ; if ( ! hasContents ) { output = "[ ]" ; } return output ; }
2159	function ( error , data , uri ) { var output = '<div id="error">Error parsing JSON: ' + error . message + '</div>' output += '<h1>' + error . stack + ':</h1>' ; output += '<div id="jsonview">' + this . htmlEncode ( data ) + '</div>' ; return this . toHTML ( output , uri + ' - Error' ) ; }
2160	function write ( chunk , encoding , callback ) { if ( typeof encoding === 'function' ) { callback = encoding encoding = null } if ( ended ) { throw new Error ( 'Did not expect `write` after `end`' ) } chunks . push ( ( chunk || '' ) . toString ( encoding || 'utf8' ) ) if ( callback ) { callback ( ) } return true }
2161	function end ( ) { write . apply ( null , arguments ) ended = true processor . process ( chunks . join ( '' ) , done ) return true function done ( err , file ) { var messages = file ? file . messages : [ ] var length = messages . length var index = - 1 chunks = null while ( ++ index < length ) { if ( messages [ index ] !== err ) { emitter . emit ( 'warning' , messages [ index ] ) } } if ( err ) { global . setTimeout ( function ( ) { emitter . emit ( 'error' , err ) } , 4 ) } else { emitter . emit ( 'data' , file . contents ) emitter . emit ( 'end' ) } } }
2162	function cleanup ( ) { emitter . removeListener ( 'data' , ondata ) emitter . removeListener ( 'end' , onend ) emitter . removeListener ( 'error' , onerror ) emitter . removeListener ( 'end' , cleanup ) emitter . removeListener ( 'close' , cleanup ) dest . removeListener ( 'error' , onerror ) dest . removeListener ( 'close' , cleanup ) }
2163	function onerror ( err ) { var handlers = emitter . _events . error cleanup ( ) if ( ! handlers || handlers . length === 0 || handlers === onerror ) { throw err } }
2164	function clean ( root , name ) { const blacklist = [ '.git' , 'node_modules' ] ; for ( const item of blacklist ) { const pathToItem = path . join ( root , item ) ; if ( fs . pathExistsSync ( pathToItem ) ) { fs . removeSync ( pathToItem ) ; console . log ( ` ${ chalk . dim . redBright ( item ) } ${ chalk . yellow ( name ) } ` ) ; } } }
2165	function ls ( ) { const vault = path . join ( os . homedir ( ) , '.snap' ) ; const list = shell . ls ( vault ) ; if ( ! list . length ) { console . log ( "\nIt seems you don't have anything saved..." ) ; \n console . log ( ` ${ chalk . yellow ( 'snap save' ) } ` ) ; console . log ( ` ${ chalk . yellow ( 'snap save -h' ) } \n ` ) ; } return ; console . log ( '\nThe following boilerplates have been saved...' ) ; \n console . log ( ` ${ chalk . yellow ( 'snap <boilerplate-name> <project-directory>' ) } ` ) ; }
2166	function sessionData ( req , res , session , cb ) { const now = new Date ( ) ; if ( session . continued ) return cb ( null , req , res , session ) ; async . parallelLimit ( [ getIp , getLocation , getSystem ] , 2 , function ( err ) { cb ( err , this . req , this . res , this . session ) ; if ( opts . log_all ) log . timer ( 'sessionData' , now ) ; } . bind ( { req : req , res : res , session : session } ) ) ; function getIp ( cb ) { session . ip = get_ip ( req ) . clientIp ; cb ( null ) } function getLocation ( cb ) { if ( ! geo_lookup ) return cb ( null ) ; const loc = geo_lookup . get ( session . ip ) ; if ( ! session . geo ) session . geo = { } ; if ( loc ) { try { if ( loc . city ) session . geo . city = loc . city . names . en ; if ( loc . subdivisions ) session . geo . state = loc . subdivisions [ 0 ] . iso_code ; if ( loc . country ) session . geo . country = loc . country . iso_code ; if ( loc . continent ) session . geo . continent = loc . continent . code ; if ( loc . location ) session . geo . time_zone = loc . location . time_zone ; } catch ( e ) { log . error ( 'geoIP error:' , e ) ; } } cb ( null ) } function getSystem ( cb ) { var agent = useragent . parse ( req . headers [ 'user-agent' ] ) ; var os = agent . os ; if ( ! session . system ) session . system = { } ; if ( ! session . system . browser ) session . system . browser = { } ; if ( ! session . system . os ) session . system . os = { } ; session . system . browser . name = agent . family ; session . system . browser . version = agent . major + '.' + agent . minor + '.' + agent . patch ; session . system . os . name = os . family ; session . system . os . version = os . major + '.' + os . minor + '.' + os . patch ; cb ( null ) } }
2167	function newRequest ( req , res , session , cb ) { const now = new Date ( ) ; const request = { _id : ` ${ crypto . randomBytes ( 16 ) . toString ( 'hex' ) } ${ Date . now ( ) } ` , host : req . hostname , url : req . url , method : req . method , referrer : req . get ( 'Referrer' ) || req . get ( 'Referer' ) } ; for ( let field in req . query ) { if ( field === 'ref' ) request . ref = req . query [ field ] ; else { if ( ! request . query ) request . query = [ ] ; request . query . push ( { field : field , value : req . query [ field ] } ) } } res . cookie ( 'na_req' , AES . encrypt ( request . _id ) , { maxAge : 1000 * 60 * 15 , httpOnly : true , secure : opts . secure } ) ; cb ( null , req , res , session , request ) ; if ( opts . log_all ) log . timer ( 'newRequest' , now ) ; }
2168	function ( packet ) { this . updatePayload = function ( packet ) { this . p_previous = this . p ; this . p = packet . payload ; this . changed = this . p_previous != this . p ; this . retained = packet . retain ; this . lastChange = this . currentChange ; this . currentChange = new Date ( ) ; } ; this . changedFromTo = function ( from , to ) { return this . changed && this . p_previous == from && this . p == to ; } ; this . changedTo = function ( to ) { return this . changed && this . p == to ; } ; this . changedFrom = function ( from ) { return this . changed && this . p_previous == from ; } ; this . t = packet . topic ; this . updatePayload ( packet ) ; this . currentChange = new Date ( ) ; this . lastChange = undefined ; this . payload = this . p ; this . topic = this . t ; }
2169	function ( ) { this . date = new Date ( ) ; this . getHours = function ( ) { return this . date . getHours ( ) ; } ; this . getMinutes = function ( ) { return this . date . getMinutes ( ) ; } ; this . hoursIsBetween = function ( a , b ) { if ( a <= b ) return this . date . getHours ( ) >= a && this . date . getHours ( ) <= b ; else return this . date . getHours ( ) >= a || this . date . getHours ( ) <= b ; } ; this . step = function ( ) { this . date = new Date ( ) ; this . isMorning = this . hoursIsBetween ( 6 , 11 ) ; this . isNoon = this . hoursIsBetween ( 12 , 14 ) ; this . isAfternoon = this . hoursIsBetween ( 15 , 17 ) ; this . isEvening = this . hoursIsBetween ( 18 , 23 ) ; this . isNight = this . hoursIsBetween ( 0 , 5 ) ; return this ; } ; }
2170	function ( req , cb ) { req = request . normalizeRequest ( req ) ; var page ; try { page = this . createPageForRequest ( req ) ; } catch ( err ) { if ( cb ) return cb ( err ) else throw err ; } var needData = typeof page . fetchData === 'function' && ! this . state . request . data ; if ( request . isEqual ( this . state . request , req ) && ! needData ) return ; fetchDataForRequest ( this , page , req , function ( err , req ) { if ( err ) { if ( cb ) return cb ( err ) else throw err ; } this . setState ( { request : req , page : page } ) ; } . bind ( this ) ) ; }
2171	function create ( format , options ) { const ogrFormat = ogrFormats [ format ] const output = format === 'zip' ? ` ${ options . path || '.' } ${ options . name } ` : '/vsistdout/' const input = options . input || 'layer.vrt' let cmd = [ '--config' , 'SHAPE_ENCODING' , 'UTF-8' , '-f' , ogrFormat , output , input ] options . geometry = options . geometry && options . geometry . toUpperCase ( ) || 'NONE' if ( format === 'csv' ) cmd = csvParams ( cmd , options ) if ( format === 'zip' ) cmd = shapefileParams ( cmd , options ) if ( format === 'georss' ) cmd = georssParams ( cmd , options ) return finishOgrParams ( cmd ) }
2172	function csvParams ( cmd , options ) { cmd . push ( '-lco' , 'WRITE_BOM=YES' ) const hasPointGeom = options . geometry === 'POINT' const fields = options . fields . join ( '|' ) . toLowerCase ( ) . split ( '|' ) const hasXY = fields . indexOf ( 'x' ) > - 1 && fields . indexOf ( 'y' ) > - 1 if ( hasPointGeom && ! hasXY ) cmd = cmd . concat ( [ '-lco' , 'GEOMETRY=AS_XY' ] ) return cmd }
2173	function shapefileParams ( cmd , options ) { if ( options . geometry !== 'NONE' ) cmd . push ( '-nlt' , options . geometry . toUpperCase ( ) ) cmd . push ( '-fieldmap' , 'identity' ) if ( ! options . ignoreShpLimit ) cmd . push ( '-lco' , '2GB_LIMIT=yes' ) if ( options . srs ) cmd . push ( '-t_srs' , options . srs ) return cmd }
2174	function watcherFn ( schemaFilepath , watchInterval , reinitBabelRelayPlugin , prevMtime ) { try { let stats ; try { stats = fs . statSync ( schemaFilepath ) ; } catch ( e ) { } if ( stats ) { if ( ! prevMtime ) prevMtime = stats . mtime ; if ( stats . mtime . getTime ( ) !== prevMtime . getTime ( ) ) { prevMtime = stats . mtime ; reinitBabelRelayPlugin ( ) ; } } setTimeout ( ( ) => { watcherFn ( schemaFilepath , watchInterval , reinitBabelRelayPlugin , prevMtime ) ; } , watchInterval ) . unref ( ) ; } catch ( e ) { log ( e ) ; } }
2175	function AkamaiPurge ( username , password , objects , options ) { var auth = { } , requestBody = { } , requestOptions ; if ( options === undefined || ! lodash . isPlainObject ( options ) ) { options = { } ; } auth . username = username ; auth . password = password ; if ( - 1 !== constants . VALID_TYPES . indexOf ( options . type ) ) { requestBody . type = options . type ; } else if ( options . hasOwnProperty ( 'type' ) ) { warn ( 'Invalid purge request type. Valid types: [' + constants . VALID_TYPES . join ( ', ' ) + ']. Given: ' + options . type ) ; } if ( - 1 !== constants . VALID_DOMAINS . indexOf ( options . domain ) ) { requestBody . domain = options . domain ; } else if ( options . hasOwnProperty ( 'domain' ) ) { warn ( 'Invalid purge request domain. Valid domains: [' + constants . VALID_DOMAINS . join ( ', ' ) + ']. Given: ' + options . domain ) ; } if ( - 1 !== constants . VALID_ACTIONS . indexOf ( options . action ) ) { requestBody . action = options . action ; } else if ( options . hasOwnProperty ( 'action' ) ) { warn ( 'Invalid purge request action. Valid actions: [' + constants . VALID_ACTIONS . join ( ', ' ) + ']. Given: ' + options . action ) ; } requestBody . objects = objects ; requestOptions = { uri : constants . AKAMAI_API_QUEUE , method : 'POST' , json : requestBody , auth : auth } ; applyModifiers ( AkamaiPurge ) ; return AkamaiRequest ( requestOptions ) . then ( function ( response ) { response . requestBody = requestBody ; response . status = function ( ) { if ( ! response . hasOwnProperty ( 'progressUri' ) ) { return when . reject ( new Error ( 'Missing progressUri from response' ) ) ; } return AkamaiStatus ( username , password , response . progressUri ) ; } ; return response ; } ) ; }
2176	function ( ) { options = lodash . assign ( options , modifier ) ; var AkamaiPurgeChain = function AkamaiPurgeChain ( username , password , objects ) { return AkamaiPurge ( username , password , objects , options ) ; } ; applyModifiers ( AkamaiPurgeChain , options ) ; AkamaiPurgeChain . options = options ; return AkamaiPurgeChain ; }
2177	function Mock ( mount , options ) { this . mount = mount ; this . options = options || { } ; this . options . params = this . options . params === undefined ? true : this . options . params ; this . locator = new Locator ( mount ) ; debug ( 'mount at %s' , this . mount ) ; }
2178	function forEach ( object , block , context ) { if ( object ) { let resolve = Object ; if ( object instanceof Function ) { resolve = Function ; } else if ( object . forEach instanceof Function ) { object . forEach ( block , context ) ; return ; } else if ( typeof object === "string" ) { resolve = String ; } else if ( typeof object . length === "number" ) { resolve = Array ; } resolve . forEach ( object , block , context ) ; } }
2179	function ( target , source ) { var skeys = _ . keys ( source ) ; _ . each ( skeys , function ( skey ) { if ( ! target [ skey ] ) { target [ skey ] = source [ skey ] ; } } ) ; return target ; }
2180	function createObject ( proto , args ) { var instance = Object . create ( proto ) ; if ( instance . $meta . constructors ) { instance . $meta . constructors . forEach ( function ( constructor ) { constructor . apply ( instance , args ) ; } ) ; } return instance ; }
2181	function mergeProperty ( destination , source , property ) { if ( source [ property ] instanceof Array ) { mergeAsArray ( destination , source , property ) ; } else if ( isPrimitive ( source [ property ] ) || ! isLiteral ( source [ property ] ) ) { overrideIfNotExists ( destination , source , property ) ; } else { mergeAsObject ( destination , source , property ) ; } }
2182	function mergeAsArray ( destination , source , property ) { destination [ property ] = source [ property ] . concat ( destination [ property ] || [ ] ) ; }
2183	function mergeAsObject ( destination , source , property ) { destination [ property ] = destination [ property ] || { } ; merge ( destination [ property ] , source [ property ] ) ; }
2184	function mixin ( instance , mixins ) { mixins . forEach ( function ( Mixin ) { mix ( instance , Mixin ) ; } ) ; return instance ; }
2185	function mkdirp ( dir , made ) { var mode = 0777 & ( ~ process . umask ( ) ) ; if ( ! made ) made = null ; dir = path . resolve ( dir ) ; try { fs . mkdirSync ( dir , mode ) ; made = made || dir ; } catch ( err0 ) { switch ( err0 . code ) { case 'ENOENT' : made = mkdirp ( path . dirname ( dir ) , made ) ; mkdirp ( dir , made ) ; break ; default : var stat ; try { stat = fs . statSync ( dir ) ; } catch ( err1 ) { throw err0 ; } if ( ! stat . isDirectory ( ) ) throw err0 ; break ; } } return made ; }
2186	function ( identifier , target , cb ) { var systemId = _sr . findSystem ( identifier ) ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } fetchTarget ( systemId , target , function ( err , target ) { if ( err ) { return cb ( err ) ; } logger . info ( { systemId : systemId , target : target } , 'get deployed system' ) ; _sr . getDeployedRevision ( systemId , target , cb ) ; } ) ; }
2187	function ( user , name , namespace , cwd , cb ) { logger . info ( 'create system name: ' + name + ', namespace: ' + namespace + ', cwd: ' + cwd ) ; _sr . createSystem ( user , namespace , name , cwd , cb ) ; }
2188	function ( user , path , cwd , cb ) { logger . info ( 'link system: ' + path + ', ' + cwd ) ; _sr . linkSystem ( user , path , cwd , cb ) ; }
2189	function ( identifier , revisionId , out , cb ) { logger . info ( 'list containers: ' + identifier ) ; var systemId = _sr . findSystem ( identifier ) ; var containers = { } ; if ( ! systemId ) { return cb ( new Error ( ERR_NOSYSID ) ) ; } _builder . loadTargets ( systemId , revisionId , function ( err , targets ) { if ( err ) { return cb ( err ) ; } _ . each ( targets , function ( target ) { _ . each ( target . containerDefinitions , function ( cdef ) { containers [ cdef . id ] = cdef ; } ) ; } ) ; cb ( null , _ . values ( containers ) ) ; } ) ; }
2190	function ( user , identifier , containerIdentifier , revision , target , out , cb ) { var containerDef ; var systemId ; systemId = _sr . findSystem ( identifier ) ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } var systemRoot = _sr . repoPath ( systemId ) ; out . initProgress ( 9 , ' ) ; fetchTarget ( systemId , target , revision , function ( err , target ) { if ( err ) { return cb ( err ) ; } _builder . loadMatchingTargets ( systemId , revision , target , function ( err , targets ) { if ( err ) { return cb ( err ) ; } _builder . findContainer ( systemId , revision , targets , containerIdentifier , function ( err , containerDefId , targets ) { if ( err ) { out . stdout ( err ) ; logger . error ( err ) ; return cb ( err ) ; } if ( ! containerDefId ) { out . stdout ( ERR_NOCDEF ) ; logger . error ( ERR_NOCDEF ) ; return cb ( ERR_NOCDEF ) ; } async . eachSeries ( _ . values ( targets ) , function ( json , cb ) { var root = buildSys ( json ) ; containerDef = root . containerDefByDefId ( containerDefId ) ; json . repoPath = systemRoot ; if ( ! containerDef . specific || ! containerDef . specific . repositoryUrl ) { return _builder . build ( user , systemId , targets , json , containerDef , target , out , cb ) ; } _synchrotron . synch ( json , containerDef , out , function ( err ) { if ( err ) { out . stdout ( err ) ; logger . error ( err ) ; return cb ( err ) ; } _builder . build ( user , systemId , targets , json , containerDef , target , out , cb ) ; } ) ; } , cb ) ; } ) ; } ) ; } ) ; }
2191	function ( user , systemName , revision , target , out , cb ) { var systemId = _sr . findSystem ( systemName ) ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } logger . info ( { systemId : systemId , revision : revision } , 'building all containers' ) ; fetchTarget ( systemId , target , revision , function ( err , target ) { if ( err ) { return cb ( err ) ; } _builder . loadMatchingTargets ( systemId , revision , target , function ( err , targets ) { if ( err ) { return cb ( err ) ; } out . stdout ( ' + targets [ Object . keys ( targets ) [ 0 ] ] . name + ' revision ' + revision + ' target ' + target ) ; var containers = _ . chain ( targets ) . filter ( function ( value , key ) { return target === 'alltargets' || key === target ; } ) . map ( function ( target ) { return _ . map ( target . containerDefinitions , function ( cdef ) { return { id : cdef . id , target : target . topology . name , type : cdef . type } ; } ) ; } ) . flatten ( ) . reduce ( function ( acc , cont ) { var notPresent = ! _ . find ( acc , function ( found ) { return found . id === cont . id && found . type === cont . type ; } ) ; if ( notPresent ) { acc . push ( cont ) ; } return acc ; } , [ ] ) . value ( ) ; async . eachSeries ( containers , function ( cont , next ) { buildContainer ( user , systemId , cont . id , revision , cont . target , out , function ( err ) { if ( err ) { out . stderr ( err ) ; } next ( err ) ; } ) ; } , cb ) ; } ) ; } ) ; }
2192	function ( systemId , target , revision , cb ) { if ( target === 'alltargets' ) { cb ( null , target ) ; } else { _sr . getDeployedRevisionId ( systemId , target , function ( err , deployedRevId ) { if ( typeof revision === 'function' ) { cb = revision ; if ( ! err ) { revision = deployedRevId ; } else { revision = 'latest' ; } } _builder . loadTargets ( systemId , revision , function ( err , targets ) { if ( err ) { return cb ( err ) ; } var candidates = Object . keys ( targets ) . filter ( function ( candidate ) { return candidate . indexOf ( target ) >= 0 ; } ) ; if ( candidates . length === 0 || candidates . length > 1 ) { logger . error ( ERR_NOTARGET ) ; return cb ( new Error ( ERR_NOTARGET ) ) ; } else { target = candidates [ 0 ] ; } cb ( null , target ) ; } ) ; } ) ; } }
2193	function ( user , identifier , revisionIdentifier , target , mode , out , cb ) { var systemId = _sr . findSystem ( identifier ) ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } fetchTarget ( systemId , target , revisionIdentifier , function ( err , target ) { if ( err ) { return cb ( err ) ; } _sr . findRevision ( systemId , revisionIdentifier , function ( err , revisionId ) { if ( err ) { out . stdout ( ERR_NOREV ) ; logger . error ( ERR_NOREV ) ; return cb ( ERR_NOREV ) ; } logger . info ( { systemId : systemId , revisionId : revisionId , environment : target } , 'deploy revision' ) ; if ( ! mode ) { mode = 'live' ; } if ( ! revisionId ) { return cb ( new Error ( 'revisionId is needed to deploy' ) ) ; } return createAnalyzeAndDeployTask ( user , systemId , revisionId , target , mode , out , cb ) ; } ) ; } ) ; }
2194	function ( user , identifier , revisionIdentifier , target , out , cb ) { logger . info ( 'preview revision: ' + identifier + ', ' + revisionIdentifier + ' ' + target ) ; deployRevision ( user , identifier , revisionIdentifier , target , 'preview' , out , function ( err ) { cb ( err , { plan : out . getPlan ( ) , ops : out . operations ( ) } ) ; } ) ; }
2195	function ( identifier , cb ) { logger . info ( 'list revisions: ' + identifier ) ; if ( ! identifier ) { return cb ( new Error ( 'no identifier' ) ) ; } var systemId = _sr . findSystem ( identifier ) ; if ( ! systemId ) { return cb ( new Error ( 'system not found' ) ) ; } _sr . listRevisions ( systemId , function ( err , revisions ) { cb ( err , _ . first ( revisions , 20 ) ) ; } ) ; }
2196	function ( identifier , revisionIdentifier , target , cb ) { logger . info ( 'get revision: ' + identifier + ', ' + revisionIdentifier ) ; var systemId = _sr . findSystem ( identifier ) ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } fetchTarget ( systemId , target , revisionIdentifier , function ( err , target ) { if ( err ) { return cb ( err ) ; } _sr . findRevision ( systemId , revisionIdentifier , function ( err , revisionId ) { if ( err ) { return cb ( err ) ; } _sr . getRevision ( systemId , revisionId , target , cb ) ; } ) ; } ) ; }
2197	function ( user , identifier , comment , out , cb ) { logger . info ( 'compile system: ' + identifier ) ; var systemId = _sr . findSystem ( identifier ) ; var system ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } var repoPath = _sr . repoPath ( systemId ) ; _compiler . compile ( systemId , repoPath , out , function ( err , systems ) { if ( err ) { return cb ( err ) ; } async . eachSeries ( _ . keys ( systems ) , function ( key , next ) { system = systems [ key ] ; _sr . writeFile ( system . id , key + '.json' , JSON . stringify ( system , null , 2 ) , next ) ; } , function ( err ) { cb ( err ) ; } ) ; } ) ; }
2198	function ( user , identifier , comment , out , cb ) { logger . info ( 'commit system: ' + identifier ) ; var systemId = _sr . findSystem ( identifier ) ; _sr . commitRevision ( user , systemId , comment , function ( err , revisionId ) { _sr . getDeployedTargets ( systemId , function ( err , targets ) { if ( targets ) { async . eachSeries ( targets , function ( target , next ) { if ( target . commit === 'edits' ) { _sr . markDeployedRevision ( user , systemId , revisionId , target . env , function ( ) { next ( ) ; } ) ; } else { next ( ) ; } } , function ( ) { cb ( err , revisionId ) ; } ) ; } else { cb ( err , revisionId ) ; } } ) ; } ) ; }
2199	function finalizeBuild ( sourceReport ) { if ( errorCount > 0 ) { grunt . fail . warn ( "Coffeeification failed." ) ; } else { done ( "Coffeified " + sourceReport . count + ": " + sourceReport . locations ) ; } }
2200	function injectCode ( ) { var fullpath = path . join ( rootpath , "app.js" ) ; var source = fs . readFileSync ( fullpath , 'utf8' ) ; var test = / \/\/ALLOY-RESOLVER / . test ( source ) ; logger . trace ( "CODE INJECTED ALREADY: " + test ) ; if ( ! test ) { source = source . replace ( / (var\s+Alloy[^;]+;) / g , "$1\n//ALLOY-RESOLVER\nvar process=require('/process');\nAlloy.resolve=new (require('/resolver'))().resolve;\n" ) ; \n } }
2201	function fixFiles ( ) { logger . trace ( "inside fixFiles()" ) ; _ . each ( registry . files , function ( file ) { var fullpath = path . join ( rootpath , file ) ; var basepath = path . posix . dirname ( file ) ; var basefile = path . posix . resolve ( file ) ; var source = fs . readFileSync ( fullpath , 'utf8' ) ; logger . trace ( "fixing file: " + fullpath ) ; var requireRegex = / (require)\s*\(((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*)\) / g ; var staticRequireRegex = / (require)(?:\(\s*['"])([^'"]+)(?:['"]\s*\)) / g ; source = source . replace ( requireRegex , function ( $1 , $2 , $3 ) { var requestedModule = $2 ; if ( staticRequireRegex . test ( $1 ) ) { var staticRequireSource = $1 ; staticRequireSource = staticRequireSource . replace ( staticRequireRegex , function ( $1 , $2 , $3 ) { var resolved_path = resolver . resolve ( $3 , basepath ) ; return 'require("' + resolved_path + '")' ; } ) ; return staticRequireSource ; } else { return 'require(Alloy.resolve(' + $3 + ', "' + basepath + '"))' ; } } ) ; fs . writeFileSync ( fullpath , source , { mode : 0o755 } ) ; } ) ; }
2202	function findFiles ( rootpath , patterns ) { logger . trace ( "inside findFiles()" ) ; var patterns = patterns || [ '**' ] ; if ( _ . isString ( patterns ) ) { patterns = [ patterns ] ; } var files = _ . map ( wrench . readdirSyncRecursive ( rootpath ) , function ( filename ) { return path . posix . sep + replaceBackSlashes ( filename ) ; } ) ; var matchedFiles = match ( files , patterns , { nocase : true , matchBase : true , dot : true , } ) ; return _ . filter ( matchedFiles , function ( file ) { return ! fs . statSync ( path . join ( rootpath , file ) ) . isDirectory ( ) ; } ) || [ ] ; }
2203	function loadFiles ( ) { logger . trace ( "inside loadFiles()" ) ; var allfiles = findFiles ( rootpath , includes ) ; var filepaths = _ . filter ( allfiles , function ( filepath ) { return ! / .+(package\.json) / . test ( filepath ) ; } ) ; _ . forEach ( filepaths , function ( filepath ) { registry . files . push ( filepath ) ; } ) ; var packagepaths = _ . filter ( allfiles , function ( filepath ) { return ( / .+(package\.json) / . test ( filepath ) ) ; } ) ; _ . forEach ( packagepaths , function ( filepath ) { var content = fs . readFileSync ( path . posix . join ( rootpath , filepath ) , 'utf8' ) ; var json = JSON . parse ( content ) ; if ( json . main ) { registry . directories . push ( { id : path . posix . dirname ( filepath ) , path : path . posix . resolve ( path . posix . join ( path . posix . dirname ( filepath ) , json . main ) ) } ) ; } } ) ; var indexpaths = _ . filter ( allfiles , function ( filepath ) { return ( / .+(index\.js) / . test ( filepath ) ) ; } ) ; _ . forEach ( indexpaths , function ( filepath ) { var existingdir = _ . find ( registry . directories , function ( dir ) { return dir . id === path . posix . dirname ( filepath ) ; } ) ; if ( ! existingdir ) { registry . directories . push ( { id : path . posix . dirname ( filepath ) , path : filepath } ) ; } } ) ; return registry ; }
2204	function writeRegistry ( ) { logger . trace ( "inside writeRegistry()" ) ; var filepath = path . join ( rootpath , "resolver.js" ) ; var content = fs . readFileSync ( filepath , 'utf8' ) ; var regex = / (var\s+registry\s+=\s+)[^;]*(;) / g ; var modified = content . replace ( regex , "$1" + JSON . stringify ( registry ) + "$2" ) ; fs . writeFileSync ( filepath , modified ) ; }
2205	function build ( mode , system , cdef , out , cb ) { _containers . getHandler ( system , cdef . type , function ( err , container ) { if ( err ) { return cb ( err ) ; } if ( ! container ) { err = new Error ( 'no matching container available for type: ' + cdef . type ) ; logger . error ( err . message ) ; return cb ( err ) ; } if ( container . build ) { out . progress ( ' + cdef . id ) ; logger . info ( { containerDefinition : cdef . id } , 'executing container specific build' ) ; container . build ( mode , system , cdef , out , function ( err , specific ) { if ( err ) { logger . error ( err ) ; out . stdout ( err ) ; return cb ( err ) ; } out . progress ( ' + cdef . id + ' built' ) ; logger . info ( { containerDefinition : cdef . id } , 'built' ) ; cb ( err ) ; } ) ; } else { out . progress ( ' + cdef . id ) ; cb ( null , { } ) ; } } ) ; }
2206	function findContainer ( systemId , revision , targets , containerIdentifier , cb ) { var cdefId ; var types = [ ] ; async . filter ( _ . keys ( targets ) , function ( key , next ) { _sr . findContainer ( systemId , revision , containerIdentifier , key , function ( err , containerDefId , cdef ) { var def ; if ( ! err && containerDefId ) { cdefId = containerDefId ; def = _ . find ( targets [ key ] . containerDefinitions , function ( def ) { return def . id === cdefId ; } ) ; if ( types . indexOf ( def . type ) < 0 ) { types . push ( def . type ) ; return next ( true ) ; } } next ( false ) ; } ) ; } , function ( keys ) { var result = keys . reduce ( function ( acc , key ) { acc [ key ] = targets [ key ] ; return acc ; } , { } ) ; cb ( null , cdefId , result ) ; } ) ; }
2207	function setAppConsts ( ) { var mergedConstants = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : ( 0 , _seamlessImmutable2 . default ) ( appConsts ) ; if ( typeof self === 'undefined' && typeof global !== 'undefined' ) { global . appConsts = global . appConsts ? _seamlessImmutable2 . default . merge ( global . appConsts , mergedConstants ) : mergedConstants ; return global . appConsts ; } else if ( typeof self !== 'undefined' ) { self . appConsts = self . appConsts ? _seamlessImmutable2 . default . merge ( self . appConsts , mergedConstants ) : mergedConstants ; return self . appConsts ; } return { } ; }
2208	function ( cb ) { fse . readFile ( systemsJsonPath , 'utf8' , function ( err , data ) { if ( err ) { if ( err . code !== 'ENOENT' ) { return cb ( err ) ; } fse . mkdirpSync ( sysRepoPath ) ; fse . writeFileSync ( systemsJsonPath , JSON . stringify ( blank , null , 2 ) , 'utf8' ) ; return git . createRepository ( sysRepoPath , 'system' , 'system@nfd.com' , function ( err_ ) { _systems = blank ; cb ( err_ ) ; } ) ; } _systems = JSON . parse ( data ) ; cb ( ) ; } ) ; }
2209	function ( user , namespace , name , repoName , repoPath , systemId , cb ) { if ( ! _systems [ systemId ] ) { _systems [ systemId ] = { name : name , namespace : namespace , repoName : repoName , repoPath : repoPath } ; fse . writeFileSync ( systemsJsonPath , JSON . stringify ( _systems , null , 2 ) , 'utf8' ) ; git . commit ( sysRepoPath , 'registered system: ' + repoPath , user . name , user . email , cb ) ; } else { cb ( null ) ; } }
2210	function ( user , systemId , cb ) { if ( ! _systems [ systemId ] ) { return cb ( ) ; } var newSystems = _ . clone ( _systems ) ; delete newSystems [ systemId ] ; fse . writeFileSync ( systemsJsonPath , JSON . stringify ( newSystems , null , 2 ) , 'utf8' ) ; _systems = newSystems ; git . commit ( sysRepoPath , 'unregistered system: ' + systemId , user . name , user . email , cb ) ; }
2211	function ( ) { var domWrapper ; this . _children = [ ] ; this . _createRootHtml ( ) ; domWrapper = utils . html . parseHTML ( this . html ) ; if ( domWrapper . childNodes . length > 1 ) { throw new Error ( "Component should have only one root element" ) ; } this . root = domWrapper . firstChild ; this . processInstance ( ) ; }
2212	function ( ) { var i , elements , element , value ; if ( this . _root ) { ( this . $meta . domProcessors || [ ] ) . forEach ( function ( processor ) { elements = this . _root . querySelectorAll ( "[" + processor . attribute + "]" ) ; for ( i = 0 ; i < elements . length ; i ++ ) { element = elements [ i ] ; value = element . getAttribute ( processor . attribute ) ; processor . process ( this , element , value ) ; } } , this ) ; } }
2213	function ( child ) { this . _validateChild ( child ) ; if ( child . parent ) { child . parent . remove ( child ) ; } child . parent = this ; this . _children . push ( child ) ; this . root . appendChild ( child . root ) ; if ( this . __fastinject__ ) { this . __fastinject__ ( child ) ; } }
2214	function ( child ) { var index = this . _children . indexOf ( child ) ; if ( index !== - 1 ) { this . _children . splice ( index , 1 ) ; child . root . parentNode . removeChild ( child . root ) ; child . destroy ( ) ; } }
2215	function ( child , element , root ) { this . _children . push ( child ) ; ( root || this . root ) . insertBefore ( child . root , element ) ; ( root || this . root ) . removeChild ( element ) ; }
2216	function ( repoPath , doc , done ) { generify ( path . join ( __dirname , 'template' ) , repoPath , { name : doc . name , namespace : doc . namespace , id : doc . id } , done ) ; }
2217	function ( repoPath ) { var sys ; if ( fse . existsSync ( path . join ( repoPath , 'system.js' ) ) ) { sys = require ( repoPath + '/system.js' ) ; delete require . cache [ repoPath + '/system.js' ] ; } if ( ! sys ) { return new Error ( 'missing system.js, is this an nscale repository?' ) ; } if ( ! sys . name ) { return new Error ( 'missing name in system.js, correct and try again' ) ; } if ( ! sys . namespace ) { return new Error ( 'missing namespace in system.js, correct and try again' ) ; } if ( ! sys . id ) { return new Error ( 'missing id in system.js, correct and try again' ) ; } }
2218	function ( user , namespace , name , cwd , cb ) { var repoName = name ; var doc = _ . extend ( { } , blank ) ; var repoPath = path . join ( cwd , repoName ) ; doc . name = name ; doc . namespace = namespace ; doc . id = uuid . v4 ( ) ; if ( ! fse . existsSync ( repoPath ) ) { fse . mkdirpSync ( repoPath ) ; initNscaleFiles ( repoPath , doc , function ( ) { git . createRepository ( repoPath , user . name , user . email , function ( err ) { if ( err ) { return cb ( err ) ; } _meta . register ( user , namespace , name , repoName , cwd + '/' + repoName , doc . id , function ( err ) { writeTimeline ( user , doc . id , 'create' , 'system created' , function ( ) { cb ( err , { id : doc . id , err : err } ) ; } ) ; } ) ; } ) ; } ) ; } else { cb ( null , { id : _meta . repoId ( repoName ) , err : null } ) ; } }
2219	function ( user , path_ , cwd , cb ) { var repoPath = path . resolve ( cwd , path_ ) ; var sys ; var validationError = validateSystem ( repoPath ) ; if ( validationError ) { return cb ( validationError ) ; } sys = require ( repoPath + '/system.js' ) ; delete require . cache [ repoPath + '/system.js' ] ; _meta . register ( user , sys . namespace , sys . name , path . basename ( repoPath ) , repoPath , sys . id , function ( err ) { writeTimeline ( user , sys . id , 'link' , 'system linked' , function ( ) { cb ( err , { id : sys . id , err : err } ) ; } ) ; } ) ; }
2220	function ( user , systemId , cb ) { writeTimeline ( user , systemId , 'system unlinked' , function ( ) { _meta . unregister ( user , systemId , function ( err ) { cb ( err ) ; } ) ; } ) ; }
2221	function ( systemId , fileName , contents , cb ) { var repoPath = _meta . repoPath ( systemId ) ; fse . writeFile ( path . join ( repoPath , fileName ) , contents , 'utf8' , cb ) ; }
2222	function ( systemId , target , cb ) { listRevisions ( systemId , function ( err , revs ) { if ( err ) { return cb ( err ) ; } getRevision ( systemId , revs [ 0 ] . id , target , cb ) ; } ) ; }
2223	function ( systemId , revisionId , target , cb ) { var repoPath = _meta . repoPath ( systemId ) ; git . getFileRevision ( repoPath , revisionId , target + '.json' , function ( err , rev ) { if ( err ) { return cb ( err ) ; } var s ; try { s = JSON . parse ( rev ) ; } catch ( e ) { return cb ( new Error ( 'invalid system definition: ' + e . message ) , null ) ; } cb ( err , s ) ; } ) ; }
2224	function ( systemId , revisionId , target , cb ) { if ( revisionId === EDITS ) { _getOnDiskVersion ( systemId , revisionId , target , cb ) ; } else { findRevision ( systemId , revisionId , function ( err , rev ) { if ( err ) { return cb ( err ) ; } if ( rev === EDITS ) { _getOnDiskVersion ( systemId , revisionId , target , cb ) ; } else { _getRevision ( systemId , rev , target , cb ) ; } } ) ; } }
2225	function ( systemId , env , cb ) { var repoPath = _meta . repoPath ( systemId ) ; var tagName = baseTag + env ; var editsTagName = editsTag + env ; ngit . Repository . open ( repoPath , function ( err , repo ) { if ( err ) { return cb ( err ) ; } ngit . Reference . nameToId ( repo , tagName , function ( err , head ) { if ( err && ( ! err . message || err . message . indexOf ( 'not found' ) === - 1 ) ) { return cb ( err ) ; } if ( head ) { cb ( null , head . toString ( ) ) ; } else { ngit . Reference . nameToId ( repo , editsTagName , function ( err ) { if ( err ) { return cb ( err ) ; } cb ( null , EDITS ) ; } ) ; } } ) ; } ) ; }
2226	function ( systemId , cb ) { var repoPath = _meta . repoPath ( systemId ) ; getDeployedTargets ( systemId , function ( err , targets ) { if ( err ) { return cb ( err ) ; } git . listRevisions ( repoPath , function ( err , revisions ) { revisions . forEach ( function ( revision ) { var deployedTo = _ . find ( targets , function ( target ) { return target . commit === revision . id ; } ) ; if ( deployedTo ) { revision . deployedTo = deployedTo . env ; } } ) ; cb ( err , revisions ) ; } ) ; } ) ; }
2227	function ( systemId , identifier , cb ) { var re = new RegExp ( '^' + identifier + '.*' , [ 'i' ] ) ; var revision ; if ( identifier !== 'head' && identifier !== 'latest' ) { listRevisions ( systemId , function ( err , revisions ) { revision = _ . find ( revisions , function ( revision ) { return re . test ( revision . id ) ; } ) ; if ( revision ) { cb ( err , revision . id ) ; } else { cb ( new Error ( 'revision not found' ) ) ; } } ) ; } else { getHeadRevisionId ( systemId , cb ) ; } }
2228	function ( environment , baseConfig ) { if ( 'emoji' in baseConfig ) { if ( ! baseConfig . emoji ) { _emojiConfig = false ; } else { Object . keys ( _defaultEmojiConfig ) . forEach ( function ( key ) { _emojiConfig [ key ] = baseConfig . emoji . hasOwnProperty ( key ) ? baseConfig . emoji [ key ] : _defaultEmojiConfig [ key ] ; } ) ; } } else { _emojiConfig = _defaultEmojiConfig ; } if ( environment === 'development' ) { return { emoji : _emojiConfig , contentSecurityPolicy : { 'script-src' : "'self' 'unsafe-eval' 'unsafe-inline'" } } ; } return { emoji : _emojiConfig } ; }
2229	function ( analyzed ) { var containers = analyzed . topology . containers ; var targets = [ ] ; _ . each ( containers , function ( c ) { if ( c . containerDefinitionId . indexOf ( '__proxy' ) === 0 ) { var cdef = _ . find ( analyzed . containerDefinitions , function ( cdef ) { return cdef . id === c . containerDefinitionId ; } ) ; targets . push ( { containerDef : cdef , container : c } ) ; } } ) ; return targets ; }
2230	function ( model , relation , options ) { var type = ! _ . isString ( relation . type ) ? relation . type : Backbone [ relation . type ] || this . getObjectByName ( relation . type ) ; if ( type && type . prototype instanceof Backbone . Relation ) { new type ( model , relation , options ) ; } else { Backbone . Relational . showWarnings && typeof console !== 'undefined' && console . warn ( 'Relation=%o; missing or invalid relation type!' , relation ) ; } }
2231	function ( modelType ) { _ . find ( this . _subModels , function ( subModelDef ) { return _ . find ( subModelDef . subModels || [ ] , function ( subModelTypeName , typeValue ) { var subModelType = this . getObjectByName ( subModelTypeName ) ; if ( modelType === subModelType ) { subModelDef . superModelType . _subModels [ typeValue ] = modelType ; modelType . _superModel = subModelDef . superModelType ; modelType . _subModelTypeValue = typeValue ; modelType . _subModelTypeAttribute = subModelDef . superModelType . prototype . subModelTypeAttribute ; return true ; } } , this ) ; } , this ) ; }
2232	function ( relation ) { var exists = _ . any ( this . _reverseRelations , function ( rel ) { return _ . all ( relation || [ ] , function ( val , key ) { return val === rel [ key ] ; } ) ; } ) ; if ( ! exists && relation . model && relation . type ) { this . _reverseRelations . push ( relation ) ; this . _addRelation ( relation . model , relation ) ; this . retroFitRelation ( relation ) ; } }
2233	function ( relation ) { var exists = _ . any ( this . _orphanRelations , function ( rel ) { return _ . all ( relation || [ ] , function ( val , key ) { return val === rel [ key ] ; } ) ; } ) ; if ( ! exists && relation . model && relation . type ) { this . _orphanRelations . push ( relation ) ; } }
2234	function ( ) { _ . each ( this . _orphanRelations . slice ( 0 ) , function ( rel ) { var relatedModel = Backbone . Relational . store . getObjectByName ( rel . relatedModel ) ; if ( relatedModel ) { this . initializeRelation ( null , rel ) ; this . _orphanRelations = _ . without ( this . _orphanRelations , rel ) ; } } , this ) ; }
2235	function ( relation ) { var coll = this . getCollection ( relation . model , false ) ; coll && coll . each ( function ( model ) { if ( ! ( model instanceof relation . model ) ) { return ; } new relation . type ( model , relation ) ; } , this ) ; }
2236	function ( type , create ) { if ( type instanceof Backbone . RelationalModel ) { type = type . constructor ; } var rootModel = type ; while ( rootModel . _superModel ) { rootModel = rootModel . _superModel ; } var coll = _ . find ( this . _collections , function ( item ) { return item . model === rootModel ; } ) ; if ( ! coll && create !== false ) { coll = this . _createCollection ( rootModel ) ; } return coll ; }
2237	function ( name ) { var parts = name . split ( '.' ) , type = null ; _ . find ( this . _modelScopes , function ( scope ) { type = _ . reduce ( parts || [ ] , function ( memo , val ) { return memo ? memo [ val ] : undefined ; } , scope ) ; if ( type && type !== scope ) { return true ; } } , this ) ; return type ; }
2238	function ( type , item ) { var id = _ . isString ( item ) || _ . isNumber ( item ) ? item : null ; if ( id === null ) { if ( item instanceof Backbone . RelationalModel ) { id = item . id ; } else if ( _ . isObject ( item ) ) { id = item [ type . prototype . idAttribute ] ; } } if ( ! id && id !== 0 ) { id = null ; } return id ; }
2239	function ( type , item ) { var id = this . resolveIdForItem ( type , item ) ; var coll = this . getCollection ( type ) ; if ( coll ) { var obj = coll . get ( id ) ; if ( obj instanceof type ) { return obj ; } } return null ; }
2240	function ( model ) { var coll = this . getCollection ( model ) ; if ( coll ) { var modelColl = model . collection ; coll . add ( model ) ; this . listenTo ( model , 'destroy' , this . unregister , this ) ; this . listenTo ( model , 'relational:unregister' , this . unregister , this ) ; model . collection = modelColl ; } }
2241	function ( model , id ) { var coll = this . getCollection ( model ) , duplicate = coll && coll . get ( id ) ; if ( duplicate && model !== duplicate ) { if ( Backbone . Relational . showWarnings && typeof console !== 'undefined' ) { console . warn ( 'Duplicate id! Old RelationalModel=%o, new RelationalModel=%o' , duplicate , model ) ; } throw new Error ( "Cannot instantiate more than one Backbone.RelationalModel with the same id per type!" ) ; } }
2242	function ( model , collection , options ) { this . stopListening ( model ) ; var coll = this . getCollection ( model ) ; coll && coll . remove ( model , options ) ; }
2243	function ( ) { var i = this . instance , k = this . key , m = this . model , rm = this . relatedModel , warn = Backbone . Relational . showWarnings && typeof console !== 'undefined' ; if ( ! m || ! k || ! rm ) { warn && console . warn ( 'Relation=%o: missing model, key or relatedModel (%o, %o, %o).' , this , m , k , rm ) ; return false ; } if ( ! ( m . prototype instanceof Backbone . RelationalModel ) ) { warn && console . warn ( 'Relation=%o: model does not inherit from Backbone.RelationalModel (%o).' , this , i ) ; return false ; } if ( ! ( rm . prototype instanceof Backbone . RelationalModel ) ) { warn && console . warn ( 'Relation=%o: relatedModel does not inherit from Backbone.RelationalModel (%o).' , this , rm ) ; return false ; } if ( this instanceof Backbone . HasMany && this . reverseRelation . type === Backbone . HasMany ) { warn && console . warn ( 'Relation=%o: relation is a HasMany, and the reverseRelation is HasMany as well.' , this ) ; return false ; } if ( i && _ . keys ( i . _relations ) . length ) { var existing = _ . find ( i . _relations , function ( rel ) { return rel . key === k ; } , this ) ; if ( existing ) { warn && console . warn ( 'Cannot create relation=%o on %o for model=%o: already taken by relation=%o.' , this , k , i , existing ) ; return false ; } } return true ; }
2244	function ( ) { this . stopListening ( ) ; if ( this instanceof Backbone . HasOne ) { this . setRelated ( null ) ; } else if ( this instanceof Backbone . HasMany ) { this . setRelated ( this . _prepareCollection ( ) ) ; } _ . each ( this . getReverseRelations ( ) , function ( relation ) { relation . removeRelated ( this . instance ) ; } , this ) ; }
2245	function ( keyContents ) { this . keyContents = keyContents ; this . keyId = Backbone . Relational . store . resolveIdForItem ( this . relatedModel , this . keyContents ) ; }
2246	function ( model , coll , options ) { if ( ( this . keyId || this . keyId === 0 ) && model . id === this . keyId ) { this . addRelated ( model , options ) ; this . keyId = null ; } }
2247	function ( collection ) { if ( this . related ) { this . stopListening ( this . related ) ; } if ( ! collection || ! ( collection instanceof Backbone . Collection ) ) { var options = _ . isFunction ( this . options . collectionOptions ) ? this . options . collectionOptions ( this . instance ) : this . options . collectionOptions ; collection = new this . collectionType ( null , options ) ; } collection . model = this . relatedModel ; if ( this . options . collectionKey ) { var key = this . options . collectionKey === true ? this . options . reverseRelation . key : this . options . collectionKey ; if ( collection [ key ] && collection [ key ] !== this . instance ) { if ( Backbone . Relational . showWarnings && typeof console !== 'undefined' ) { console . warn ( 'Relation=%o; collectionKey=%s already exists on collection=%o' , this , key , this . options . collectionKey ) ; } } else if ( key ) { collection [ key ] = this . instance ; } } this . listenTo ( collection , 'relational:add' , this . handleAddition ) . listenTo ( collection , 'relational:remove' , this . handleRemoval ) . listenTo ( collection , 'relational:reset' , this . handleReset ) ; return collection ; }
2248	function ( keyContents ) { this . keyContents = keyContents instanceof Backbone . Collection ? keyContents : null ; this . keyIds = [ ] ; if ( ! this . keyContents && ( keyContents || keyContents === 0 ) ) { this . keyContents = _ . isArray ( keyContents ) ? keyContents : [ keyContents ] ; _ . each ( this . keyContents , function ( item ) { var itemId = Backbone . Relational . store . resolveIdForItem ( this . relatedModel , item ) ; if ( itemId || itemId === 0 ) { this . keyIds . push ( itemId ) ; } } , this ) ; } }
2249	function ( key , options , refresh ) { options = _ . extend ( { update : true , remove : false } , options ) ; var setUrl , requests = [ ] , rel = this . getRelation ( key ) , idsToFetch = rel && ( ( rel . keyIds && rel . keyIds . slice ( 0 ) ) || ( ( rel . keyId || rel . keyId === 0 ) ? [ rel . keyId ] : [ ] ) ) ; if ( refresh ) { var models = rel . related instanceof Backbone . Collection ? rel . related . models : [ rel . related ] ; _ . each ( models , function ( model ) { if ( model . id || model . id === 0 ) { idsToFetch . push ( model . id ) ; } } ) ; } if ( idsToFetch && idsToFetch . length ) { var created = [ ] , models = _ . map ( idsToFetch , function ( id ) { var model = Backbone . Relational . store . find ( rel . relatedModel , id ) ; if ( ! model ) { var attrs = { } ; attrs [ rel . relatedModel . prototype . idAttribute ] = id ; model = rel . relatedModel . findOrCreate ( attrs , options ) ; created . push ( model ) ; } return model ; } , this ) ; if ( rel . related instanceof Backbone . Collection && _ . isFunction ( rel . related . url ) ) { setUrl = rel . related . url ( models ) ; } if ( setUrl && setUrl !== rel . related . url ( ) ) { var opts = _ . defaults ( { error : function ( ) { var args = arguments ; _ . each ( created , function ( model ) { model . trigger ( 'destroy' , model , model . collection , options ) ; options . error && options . error . apply ( model , args ) ; } ) ; } , url : setUrl } , options ) ; requests = [ rel . related . fetch ( opts ) ] ; } else { requests = _ . map ( models , function ( model ) { var opts = _ . defaults ( { error : function ( ) { if ( _ . contains ( created , model ) ) { model . trigger ( 'destroy' , model , model . collection , options ) ; options . error && options . error . apply ( model , arguments ) ; } } } , options ) ; return model . fetch ( opts ) ; } , this ) ; } } return requests ; }
2250	function ( options ) { if ( this . isLocked ( ) ) { return this . id ; } this . acquire ( ) ; var json = Backbone . Model . prototype . toJSON . call ( this , options ) ; if ( this . constructor . _superModel && ! ( this . constructor . _subModelTypeAttribute in json ) ) { json [ this . constructor . _subModelTypeAttribute ] = this . constructor . _subModelTypeValue ; } _ . each ( this . _relations , function ( rel ) { var related = json [ rel . key ] , includeInJSON = rel . options . includeInJSON , value = null ; if ( includeInJSON === true ) { if ( related && _ . isFunction ( related . toJSON ) ) { value = related . toJSON ( options ) ; } } else if ( _ . isString ( includeInJSON ) ) { if ( related instanceof Backbone . Collection ) { value = related . pluck ( includeInJSON ) ; } else if ( related instanceof Backbone . Model ) { value = related . get ( includeInJSON ) ; } if ( includeInJSON === rel . relatedModel . prototype . idAttribute ) { if ( rel instanceof Backbone . HasMany ) { value = value . concat ( rel . keyIds ) ; } else if ( rel instanceof Backbone . HasOne ) { value = value || rel . keyId ; } } } else if ( _ . isArray ( includeInJSON ) ) { if ( related instanceof Backbone . Collection ) { value = [ ] ; related . each ( function ( model ) { var curJson = { } ; _ . each ( includeInJSON , function ( key ) { curJson [ key ] = model . get ( key ) ; } ) ; value . push ( curJson ) ; } ) ; } else if ( related instanceof Backbone . Model ) { value = { } ; _ . each ( includeInJSON , function ( key ) { value [ key ] = related . get ( key ) ; } ) ; } } else { delete json [ rel . key ] ; } if ( includeInJSON ) { json [ rel . keyDestination ] = value ; } if ( rel . keyDestination !== rel . key ) { delete json [ rel . key ] ; } } ) ; this . release ( ) ; return json ; }
2251	function ( attributes , options ) { options || ( options = { } ) ; options . create = false ; return this . findOrCreate ( attributes , options ) ; }
2252	function XtallatX ( superClass ) { return class extends superClass { constructor ( ) { super ( ... arguments ) ; this . _evCount = { } ; } static get observedAttributes ( ) { return [ disabled ] ; } get disabled ( ) { return this . _disabled ; } set disabled ( val ) { this . attr ( disabled , val , '' ) ; } attr ( name , val , trueVal ) { const v = val ? 'set' : 'remove' ; this [ v + 'Attribute' ] ( name , trueVal || val ) ; } to$ ( n ) { const mod = n % 2 ; return ( n - mod ) / 2 + '-' + mod ; } incAttr ( name ) { const ec = this . _evCount ; if ( name in ec ) { ec [ name ] ++ ; } else { ec [ name ] = 0 ; } this . attr ( 'data-' + name , this . to$ ( ec [ name ] ) ) ; } attributeChangedCallback ( name , oldVal , newVal ) { switch ( name ) { case disabled : this . _disabled = newVal !== null ; break ; } } de ( name , detail , asIs = false ) { const eventName = name + ( asIs ? '' : '-changed' ) ; const newEvent = new CustomEvent ( eventName , { detail : detail , bubbles : true , composed : false , } ) ; this . dispatchEvent ( newEvent ) ; this . incAttr ( eventName ) ; return newEvent ; } _upgradeProperties ( props ) { props . forEach ( prop => { if ( this . hasOwnProperty ( prop ) ) { let value = this [ prop ] ; delete this [ prop ] ; this [ prop ] = value ; } } ) ; } } ; }
2253	function Bitmap ( imageOrUri ) { this . DisplayObject_constructor ( ) ; if ( typeof imageOrUri == "string" ) { this . image = document . createElement ( "img" ) ; this . image . src = imageOrUri ; } else { this . image = imageOrUri ; } this . sourceRect = null ; this . _webGLRenderStyle = createjs . DisplayObject . _StageGL_BITMAP ; }
2254	function canonicalize ( value , stack ) { var canonicalizedObj ; var prop ; var type = getType ( value ) ; function withStack ( value , fn ) { stack . push ( value ) ; fn ( ) ; stack . pop ( ) ; } stack = stack || [ ] ; if ( stack . indexOf ( value ) !== - 1 ) { return '[Circular]' ; } switch ( type ) { case 'undefined' : case 'buffer' : case 'null' : canonicalizedObj = value ; break ; case 'array' : withStack ( value , function ( ) { canonicalizedObj = value . map ( function ( item ) { return canonicalize ( item , stack ) ; } ) ; } ) ; break ; case 'function' : for ( prop in value ) { canonicalizedObj = { } ; break ; } if ( ! canonicalizedObj ) { canonicalizedObj = emptyRepresentation ( value , type ) ; break ; } case 'object' : canonicalizedObj = canonicalizedObj || { } ; withStack ( value , function ( ) { Object . keys ( value ) . sort ( ) . forEach ( function ( key ) { canonicalizedObj [ key ] = canonicalize ( value [ key ] , stack ) ; } ) ; } ) ; break ; case 'date' : case 'number' : case 'regexp' : case 'boolean' : canonicalizedObj = value ; break ; default : canonicalizedObj = value . toString ( ) ; } return canonicalizedObj ; }
2255	function emptyRepresentation ( value , type ) { type = type || getType ( value ) ; switch ( type ) { case 'function' : return '[Function]' ; case 'object' : return '{}' ; case 'array' : return '[]' ; default : return value . toString ( ) ; } }
2256	function ( doc , first , last ) { var f = doc . WordPos [ first ] ; var l ; if ( last == doc . WordPos . length - 1 ) l = doc . DocLength ; else l = doc . WordPos [ last + 1 ] ; return l - f ; }
2257	function compile ( ) { var buf = '' ; buf += '(function() {\n' ; \n buf += '\n// CommonJS require()\n\n' ; \n \n \n buf += browser . require + '\n\n' ; \n \n buf += 'require.modules = {};\n\n' ; \n }
2258	function fp ( ) { var args = Array . prototype . slice . call ( arguments , 0 ) ; if ( args . length ) { if ( ! args . every ( isStringOrFunction ) ) { var signature = args . map ( humanizeArgument ) . join ( '\n\t' ) ; \n } \t throw new Error ( 'Invalid arguments to functional pipeline - not a string or function\n\t' + \n ) ; } }
2259	function ( tickRate ) { events . EventEmitter . call ( this ) ; this . _milliseconds = 0 ; this . _setState ( 'stopped' ) ; this . _timer = new NanoTimer ( ) ; tickRate = tickRate || 100 ; Object . defineProperty ( this , 'tickRate' , { enumerable : true , configurable : false , writable : false , value : tickRate } ) ; }
2260	function onProcessed ( err , processed ) { if ( err ) return callback ( err ) ; _this . _tokenize ( processed , onTokenized ) ; }
2261	function Template ( str , options ) { if ( _ . isObject ( str ) && ! options ) { options = str ; str = null ; } options = options ? _ . clone ( options ) : { } ; if ( ! _ . isBoolean ( options . cache ) ) { options . cache = process . env . NODE_ENV === 'production' ; } options = _ . defaults ( options , DEFAULTS ) ; options . cacheContext = options . cacheContext || Template ; this . template = str ; this . options = options ; this . _compiled = null ; if ( options . cache && ! ( this . _getCache ( ) instanceof options . cacheHandler ) ) { var cacheOptions = [ options . cacheHandler ] . concat ( options . cacheOptions ) ; options . cacheContext [ options . _cacheProp ] = typeof window !== 'undefined' ? new options . cacheHandler ( ) : construct . apply ( this , cacheOptions ) ; } }
2262	function ( fn , rate ) { var allowed = true ; return function ( ) { if ( allowed ) { allowed = false ; fn . apply ( null , [ ] . slice . call ( arguments , 0 ) ) ; setTimeout ( function ( ) { allowed = true ; } , rate ) ; } } }
2263	function get_data ( callback ) { var data ; try { data = program . data ? JSON . parse ( program . data ) : { } ; callback ( data ) ; } catch ( err ) { fs . readFile ( program . data , function ( err , str ) { str = '' + str ; if ( ! err ) { try { data = JSON . parse ( str ) ; callback ( data ) ; } catch ( err ) { data = eval ( str ) ; callback ( data ) ; } } } ) ; } return data ; }
2264	function secureWebhookEndpoints ( ) { var authenticationMiddleware = require ( __dirname + '/middleware/slack_authentication.js' ) ; var tokens = Array . prototype . slice . call ( arguments ) ; var webserver = tokens . shift ( ) ; slack_botkit . logger . info ( '** Requiring token authentication for webhook endpoints for Slash commands ' + 'and outgoing webhooks; configured ' + tokens . length + ' token(s)' ) ; webserver . use ( authenticationMiddleware ( tokens ) ) ; }
2265	function postForm ( url , formData , cb , multipart ) { cb = cb || noop ; bot . logger . info ( '** API CALL: ' + url ) ; var params = { url : url , headers : { 'User-Agent' : bot . userAgent ( ) , } } ; if ( multipart === true ) { params . formData = formData ; } else { params . form = formData ; } request . post ( params , function ( error , response , body ) { bot . logger . debug ( 'Got response' , error , body ) ; if ( error ) { return cb ( error ) ; } if ( response . statusCode == 200 ) { var json ; try { json = JSON . parse ( body ) ; } catch ( parseError ) { return cb ( parseError ) ; } return cb ( ( json . ok ? null : json . error ) , json ) ; } else if ( response . statusCode == 429 ) { return cb ( new Error ( 'Rate limit exceeded' ) ) ; } else { return cb ( new Error ( 'Invalid response' ) ) ; } } ) ; }
2266	function verifyRequest ( req , res , buf , encoding ) { var expected = req . headers [ 'x-hub-signature' ] ; var calculated = getSignature ( buf ) ; if ( expected !== calculated ) { throw new Error ( 'Invalid signature on incoming request' ) ; } else { } }
2267	function ( ) { if ( ! this . selfUpdating ) { this . deferred = true ; } var i = this . refs . length ; while ( i -- ) { this . refs [ i ] . update ( ) ; } if ( this . deferred ) { this . update ( ) ; this . deferred = false ; } }
2268	function DockerCmdManager ( dockerdescPath ) { dockerdescPath = dockerdescPath || './dockerdesc.json' ; if ( ! fs . existsSync ( dockerdescPath ) ) { throw new Error ( util . format ( 'The path "%s" does not exists.' , dockerdescPath ) ) ; } this . dockerdescDir = path . dirname ( dockerdescPath ) ; var dockerdescPathStat = fs . statSync ( dockerdescPath ) ; if ( dockerdescPathStat . isDirectory ( ) ) { this . dockerdescDir = dockerdescPath ; dockerdescPath = path . join ( dockerdescPath , 'dockerdesc.json' ) ; } var dockerdescContent = fs . readFileSync ( dockerdescPath ) ; try { this . dockerdesc = JSON . parse ( dockerdescContent ) ; } catch ( err ) { throw new Error ( 'Problem in the dockerdesc.json file format.\n' + \n ) ; } }
2269	function dd ( object , _context , _key , _root , _rootPath ) { _root = _root || object ; _rootPath = _rootPath || [ ] ; var drill = function ( key ) { var nextObject = ( object && object . hasOwnProperty ( key ) && object [ key ] || undefined ) ; return dd ( nextObject , object , key , _root , _rootPath . concat ( key ) ) ; } ; drill . val = object ; drill . exists = object !== undefined ; drill . set = function ( value ) { if ( _rootPath . length === 0 ) { return ; } var contextIterator = _root ; for ( var depth = 0 ; depth < _rootPath . length ; depth ++ ) { var key = _rootPath [ depth ] ; var isFinalDepth = ( depth === _rootPath . length - 1 ) ; if ( ! isFinalDepth ) { contextIterator [ key ] = ( contextIterator . hasOwnProperty ( key ) && typeof contextIterator [ key ] === 'object' ? contextIterator [ key ] : { } ) ; contextIterator = contextIterator [ key ] ; } else { _context = contextIterator ; _key = key ; } } _context [ _key ] = value ; drill . val = value ; drill . exists = value !== undefined ; return value ; } ; drill . update = function ( value ) { if ( drill . exists ) { _context [ _key ] = value ; drill . val = value ; return value ; } } ; drill . invoke = isFunction ( object ) ? Function . prototype . bind . call ( object , _context ) : function ( ) { } ; return drill ; }
2270	function printTasks ( tasks , verbose ) { tasks = tasks . filterHidden ( verbose ) . sort ( ) ; var results = [ 'Usage: gulp [task] [task2] ...' , '' , 'Tasks: ' ] ; var fieldTaskLen = tasks . getLongestNameLength ( ) ; tasks . forEach ( function ( task ) { var comment = task . comment || { } ; var lines = comment . lines || [ ] ; results . push ( formatColumn ( task . name , fieldTaskLen ) + ( lines [ 0 ] || '' ) ) ; for ( var i = 1 ; i < lines . length ; i ++ ) { results . push ( formatColumn ( '' , fieldTaskLen ) + ' ' + lines [ i ] ) ; } } ) ; return results . join ( '\n' ) ; }
2271	function formatColumn ( text , width , offsetLeft , offsetRight ) { offsetLeft = undefined !== offsetLeft ? offsetLeft : 3 ; offsetRight = undefined !== offsetRight ? offsetRight : 3 ; return new Array ( offsetLeft + 1 ) . join ( ' ' ) + text + new Array ( Math . max ( width - text . length , 0 ) + 1 ) . join ( ' ' ) + new Array ( offsetRight + 1 ) . join ( ' ' ) ; }
2272	function inheritGulp ( ) { function TaskDoc ( ) { this . taskList = new TaskList ( ) ; gulp . Gulp . call ( this ) ; } TaskDoc . prototype = gulp ; return new TaskDoc ( ) ; }
2273	function _log ( level ) { return function ( ) { var meta = null ; var args = arguments ; if ( arguments . length === 0 ) { return this . _winston . level === level ; } else if ( arguments [ 0 ] instanceof Error ) { meta = arguments [ 0 ] . toString ( ) ; args = Array . prototype . slice . call ( arguments , 1 ) ; args . push ( meta ) ; } else if ( typeof ( args [ 0 ] ) === 'string' ) { args = Array . prototype . slice . call ( arguments ) ; } else { meta = arguments [ 0 ] ; args = Array . prototype . slice . call ( arguments , 1 ) ; args . push ( meta ) ; } args . unshift ( level ) ; this . _winston . log . apply ( this . _winston , args ) ; } }
2274	function isPromise ( item ) { if ( ! item ) return false ; return ( ( util . types && util . types . isPromise && util . types . isPromise ( item ) ) || ( item . constructor && item . constructor . name == 'Promise' ) || ( ! item instanceof objectInstance && item . then && typeof item . then == 'function' ) ) ; }
2275	function hasCallback ( fn ) { var fnString = fn . toString ( ) ; var bits , fnArgs ; if ( / ^async / . test ( fnString ) ) { return false ; } else if ( bits = / ^function\s*(?:.*?)\s*\((.*?)\) / . exec ( fnString ) ) { fnArgs = bits [ 1 ] ; } else if ( / ^\(\s*\)\s*=> / . test ( fnString ) ) { return false ; } else if ( bits = / ^\s\((.*?)\)\s*?=> / . exec ( fnString ) ) { fnArgs = bits [ 1 ] ; } else if ( bits = / ^(.*?)\s*=> / . exec ( fnString ) ) { fnArgs = bits [ 1 ] ; } else { return false ; } fnArgs = fnArgs . replace ( / ^\s+ / , '' ) . replace ( / \s+$ / , '' ) ; return ! ! fnArgs ; }
2276	function race ( ) { var self = this ; argy ( arguments ) . ifForm ( '' , function ( ) { } ) . ifForm ( 'array' , function ( tasks ) { self . _struct . push ( { type : 'race' , payload : tasks } ) ; } ) . ifForm ( 'string array' , function ( id , tasks ) { self . _struct . push ( { type : 'race' , id : arguments [ 0 ] , payload : arguments [ 1 ] } ) ; } ) . ifFormElse ( function ( form ) { throw new Error ( 'Unknown call style for .parallel(): ' + form ) ; } ) return self ; }
2277	function deferAdd ( id , task , parentChain ) { var self = this ; parentChain . waitingOn = ( parentChain . waitingOn || 0 ) + 1 ; if ( ! parentChain . waitingOnIds ) parentChain . waitingOnIds = [ ] ; parentChain . waitingOnIds . push ( id ) ; self . _deferred . push ( { id : id || null , prereq : parentChain . prereq || [ ] , payload : function ( next ) { self . _context . _id = id ; run ( self . _options . context , task , function ( err , value ) { if ( id ) self . _context [ id ] = value ; self . _deferredRunning -- ; if ( -- parentChain . waitingOn == 0 ) { parentChain . completed = true ; if ( self . _struct . length && self . _struct [ self . _structPointer ] . type == 'await' ) self . _execute ( err ) ; } self . _execute ( err ) ; } , ( parentChain . prereq || [ ] ) . map ( function ( pre ) { return self . _context [ pre ] ; } ) ) ; } } ) ; }
2278	function await ( ) { var payload = [ ] ; argy ( arguments ) . getForm ( ) . split ( ',' ) . forEach ( function ( type , offset ) { switch ( type ) { case '' : break ; case 'string' : payload . push ( args [ offset ] ) ; break ; case 'array' : payload . concat ( args [ offset ] ) ; break ; default : throw new Error ( 'Unknown argument type passed to .await(): ' + type ) ; } } ) ; this . _struct . push ( { type : 'await' , payload : payload } ) ; return this ; }
2279	function timeout ( newTimeout ) { var self = this ; argy ( arguments ) . ifForm ( '' , function ( ) { self . _struct . push ( { type : 'timeout' , delay : false } ) ; } ) . ifForm ( 'boolean' , function ( setTimeout ) { if ( setTimeout ) throw new Error ( 'When calling .timeout(Boolean) only False is accepted to disable the timeout' ) ; self . _struct . push ( { type : 'timeout' , delay : false } ) ; } ) . ifForm ( 'number' , function ( delay ) { self . _struct . push ( { type : 'timeout' , delay : delay } ) ; } ) . ifForm ( 'function' , function ( callback ) { self . _struct . push ( { type : 'timeout' , callback : callback } ) ; } ) . ifForm ( 'number function' , function ( delay , callback ) { self . _struct . push ( { type : 'timeout' , delay : delay , callback : callback } ) ; } ) . ifForm ( 'function number' , function ( delay , callback ) { self . _struct . push ( { type : 'timeout' , delay : delay , callback : callback } ) ; } ) . ifFormElse ( function ( form ) { throw new Error ( 'Unknown call style for .timeout():' + form ) ; } ) ; return self ; }
2280	function _timeoutHandler ( ) { var currentTaskIndex = this . _struct . findIndex ( function ( task ) { return ! task . completed } ) ; if ( ! currentTaskIndex < 0 ) { console . log ( 'Async-Chainable timeout on unknown task' ) ; console . log ( 'Full structure:' , this . _struct ) ; } else { console . log ( 'Async-Chainable timeout: Task #' , currentTaskIndex + 1 , '(' + this . _struct [ currentTaskIndex ] . type + ')' , 'elapsed timeout of' , this . _options . timeout + 'ms' ) ; } this . fire ( 'timeout' ) ; }
2281	function run ( context , fn , finish , args ) { if ( typeof context == 'function' ) { args = finish ; finish = fn ; fn = context ; context = this ; } if ( isPromise ( fn ) ) { fn . then ( function ( value ) { finish . apply ( context , [ null , value ] ) ; } ) . catch ( function ( err ) { finish . call ( context , err || 'An error occured' ) ; } ) ; } else if ( hasCallback ( fn ) ) { var result = fn . apply ( context , args ? [ finish ] . concat ( args ) : [ finish ] ) ; if ( isPromise ( result ) ) { result . then ( function ( value ) { finish . apply ( context , [ null , value ] ) ; } ) . catch ( function ( err ) { finish . call ( context , err || 'An error occured' ) ; } ) ; } } else { var result ; try { result = fn . apply ( context , args || [ ] ) ; } catch ( e ) { finish . call ( context , e ) ; } if ( isPromise ( result ) ) { result . then ( function ( value ) { finish . apply ( context , [ null , value ] ) ; } ) . catch ( function ( err ) { finish . call ( context , err || 'An error occured' ) ; } ) ; } else { finish . apply ( context , [ null , result ] ) ; } } }
2282	function runWhile ( iter , limit , callback ) { var index = 0 ; var hasExited = false ; var err ; var running = 0 ; if ( ! Number . isFinite ( limit ) ) limit = 10 ; var invoke = function ( ) { iter . call ( this . _context , function ( taskErr , taskResult ) { if ( taskErr ) err = taskErr ; if ( taskErr || ! taskResult ) hasExited = true ; -- running ; if ( err && ! running ) { callback ( err , res ) ; } else if ( running <= 0 && hasExited ) { callback ( err ) ; } else if ( ! hasExited ) { setTimeout ( invoke ) ; } } , index ++ ) ; } ; for ( var i = 0 ; i < limit ; i ++ ) { running ++ ; setTimeout ( invoke ) ; } return this ; }
2283	function reset ( ) { this . _struct = [ ] ; this . _structPointer = 0 ; var reAttachContext = ( this . _options . context == this . _context ) ; this . _context = { _struct : this . _struct , _structPointer : this . _structPointer , _options : this . _options , _deferredRunning : this . _deferredRunning , hook : this . hook . bind ( this ) , fire : this . fire . bind ( this ) , } ; if ( reAttachContext ) this . _options . context = this . _context ; }
2284	function hook ( ) { var self = this ; argy ( arguments ) . ifForm ( '' , function ( ) { } ) . ifForm ( 'string function' , function ( hook , callback ) { if ( ! self . _hooks [ hook ] ) self . _hooks [ hook ] = [ ] ; self . _hooks [ hook ] . push ( { cb : callback } ) ; } ) . ifForm ( 'string string function' , function ( hook , id , callback ) { if ( ! self . _hooks [ hook ] ) self . _hooks [ hook ] = [ ] ; self . _hooks [ hook ] . push ( { id : id , cb : callback } ) ; } ) . ifForm ( 'string array function' , function ( hook , prereqs , callback ) { if ( ! self . _hooks [ hook ] ) self . _hooks [ hook ] = [ ] ; self . _hooks [ hook ] . push ( { prereqs : prereqs , cb : callback } ) ; } ) . ifForm ( 'string string array function' , function ( hook , id , prereqs , callback ) { if ( ! self . _hooks [ hook ] ) self . _hooks [ hook ] = [ ] ; self . _hooks [ hook ] . push ( { id : id , prereqs : prereqs , cb : callback } ) ; } ) . ifForm ( 'array function' , function ( hooks , callback ) { hooks . forEach ( function ( hook ) { if ( ! self . _hooks [ hook ] ) self . _hooks [ hook ] = [ ] ; self . _hooks [ hook ] . push ( { cb : callback } ) ; } ) ; } ) . ifFormElse ( function ( form ) { throw new Error ( 'Unknown call style for .on(): ' + form ) ; } ) ; return self ; }
2285	function tag ( name ) { if ( ! this . comment || ! this . comment . tags ) { return null ; } for ( var i = 0 ; i < this . comment . tags . length ; i ++ ) { var tagObj = this . comment . tags [ i ] ; if ( tagObj . name === name ) { return tagObj . value ; } } return null ; }
2286	function checkPattern ( file , blackList , whiteList ) { if ( util . isRegExp ( blackList ) && blackList . test ( file ) ) { return false ; } if ( util . isRegExp ( whiteList ) ) { if ( whiteList . test ( file ) ) { return true ; } return false ; } return true ; }
2287	function Seven ( _a ) { var _b = _a === void 0 ? { } : _a , height = _b . height , width = _b . width , _c = _b . angle , angle = _c === void 0 ? 10 : _c , _d = _b . ratioLtoW , ratioLtoW = _d === void 0 ? 4 : _d , _e = _b . ratioLtoS , ratioLtoS = _e === void 0 ? 32 : _e , _f = _b . digit , digit = _f === void 0 ? Digit . BLANK : _f ; this . _horizontalSegmentGeometry = [ { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } ] ; this . _verticalSegmentGeometry = [ { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } ] ; this . _translations = [ { x : 0 , y : 0 , a : this . _horizontalSegmentGeometry } , { x : 0 , y : 0 , a : this . _verticalSegmentGeometry } , { x : 0 , y : 0 , a : this . _verticalSegmentGeometry } , { x : 0 , y : 0 , a : this . _horizontalSegmentGeometry } , { x : 0 , y : 0 , a : this . _verticalSegmentGeometry } , { x : 0 , y : 0 , a : this . _verticalSegmentGeometry } , { x : 0 , y : 0 , a : this . _horizontalSegmentGeometry } ] ; this . segments = [ new Segment ( ) , new Segment ( ) , new Segment ( ) , new Segment ( ) , new Segment ( ) , new Segment ( ) , new Segment ( ) ] ; this . _angleDegree = angle ; this . digit = digit ; this . _ratioLtoW = ratioLtoW ; this . _ratioLtoS = ratioLtoS ; this . _height = this . _width = 100 ; this . _isHeightFixed = true ; if ( height !== undefined ) { this . _height = height ; } else if ( width !== undefined ) { this . _width = width ; this . _isHeightFixed = false ; } this . _positionSegments ( ) ; }
2288	function onChange ( event ) { try { if ( remove ( ) ) { return ; } resolve ( Array . from ( input . files ) ) ; } catch ( error ) { reject ( error ) ; } }
2289	function RemoveObserver_init ( ref , node ) { let self = Self . get ( node ) ; if ( ! self ) { self = new RemoveObserverPrivate ( node ) ; Self . set ( node , self ) ; } Self . set ( ref , self ) ; }
2290	function parsePropertyChains ( expr ) { var parsedExpr = '' , chain ; var prevCurrentIndex = currentIndex ; var prevLastIndex = propertyRegex . lastIndex ; currentIndex = 0 ; propertyRegex . lastIndex = 0 ; while ( ( chain = nextChain ( expr ) ) !== false ) { parsedExpr += chain ; } currentIndex = prevCurrentIndex ; propertyRegex . lastIndex = prevLastIndex ; return parsedExpr ; }
2291	function parseFunction ( link , index , expr ) { var call = getFunctionCall ( expr ) ; if ( index === 0 ) { link = addThisOrGlobal ( link ) ; } else { link = '_ref' + currentReference + link ; } var calledLink = link + '(~~insideParens~~)' ; link = 'typeof ' + link + ' !== \'function\' ? void 0 : ' + \' ; \' calledLink var insideParens = call . slice ( 1 , - 1 ) ; if ( expr . charAt ( propertyRegex . lastIndex ) === '.' ) { currentReference = ++ referenceCount ; var ref = '_ref' + currentReference ; link = '(' + ref + ' = (' + link + ')) == null ? void 0 : ' ; } var ref = currentReference ; link = link . replace ( '~~insideParens~~' , parsePropertyChains ( insideParens ) ) ; }
2292	function parseBrackets ( link , index , expr ) { var call = getFunctionCall ( expr ) ; var insideBrackets = call . slice ( 1 , - 1 ) ; var evaledLink = parsePart ( link , index ) ; index += 1 ; link = '[~~insideBrackets~~]' ; if ( expr . charAt ( propertyRegex . lastIndex ) === '.' ) { link = parsePart ( link , index ) ; } else { link = '_ref' + currentReference + link ; } link = evaledLink + link ; var ref = currentReference ; link = link . replace ( '~~insideBrackets~~' , parsePropertyChains ( insideBrackets ) ) ; currentReference = ref ; return link ; }
2293	function addReferences ( expr ) { if ( referenceCount ) { var refs = [ ] ; for ( var i = 1 ; i <= referenceCount ; i ++ ) { refs . push ( '_ref' + i ) ; } expr = 'var ' + refs . join ( ', ' ) + ';\n' + \n ; } expr }
2294	function ( fn ) { var pending var hasNext function next ( ) { setTimeout ( function ( ) { if ( pending === false ) return pending = false if ( hasNext ) { hasNext = false fn ( next ) } } , 50 ) } return function ( ) { if ( pending ) return ( hasNext = true ) pending = true fn ( next ) } }
2295	function assert ( t , m ) { if ( ! t ) { var err = new AssertionError ( m ) if ( Error . captureStackTrace ) Error . captureStackTrace ( err , assert ) throw err } }
2296	function bindArguments ( func ) { function binder ( ) { return func . apply ( this , args . concat ( slice . call ( arguments ) ) ) ; } var args = slice . call ( arguments , 1 ) ; return binder ; }
2297	function getExceptions ( ) { const openers = [ ] ; const closers = [ ] ; if ( options . braceException ) { openers . push ( '{' ) ; closers . push ( '}' ) ; } if ( options . bracketException ) { openers . push ( '[' ) ; closers . push ( ']' ) ; } if ( options . parenException ) { openers . push ( '(' ) ; closers . push ( ')' ) ; } if ( options . empty ) { openers . push ( ')' ) ; closers . push ( '(' ) ; } return { openers , closers } ; }
2298	function shouldOpenerHaveSpace ( left , right ) { if ( sourceCode . isSpaceBetweenTokens ( left , right ) ) { return false ; } if ( ALWAYS ) { if ( astUtils . isClosingParenToken ( right ) ) { return false ; } return ! isOpenerException ( right ) ; } return isOpenerException ( right ) ; }
2299	function shouldCloserHaveSpace ( left , right ) { if ( astUtils . isOpeningParenToken ( left ) ) { return false ; } if ( sourceCode . isSpaceBetweenTokens ( left , right ) ) { return false ; } if ( ALWAYS ) { return ! isCloserException ( left ) ; } return isCloserException ( left ) ; }
2300	function shouldOpenerRejectSpace ( left , right ) { if ( right . type === 'Line' ) { return false ; } if ( ! astUtils . isTokenOnSameLine ( left , right ) ) { return false ; } if ( ! sourceCode . isSpaceBetweenTokens ( left , right ) ) { return false ; } if ( ALWAYS ) { return isOpenerException ( right ) ; } return ! isOpenerException ( right ) ; }
2301	function shouldCloserRejectSpace ( left , right ) { if ( astUtils . isOpeningParenToken ( left ) ) { return false ; } if ( ! astUtils . isTokenOnSameLine ( left , right ) ) { return false ; } if ( ! sourceCode . isSpaceBetweenTokens ( left , right ) ) { return false ; } if ( ALWAYS ) { return isCloserException ( left ) ; } return ! isCloserException ( left ) ; }
2302	function defineConfigurable ( obj , key , val ) { Object . defineProperty ( obj , key , { configurable : true , enumerable : false , writable : true , value : val } ) ; }
2303	function ToInteger ( argument ) { var number = + argument ; if ( number !== number ) { return 0 ; } if ( number === 0 || number === Infinity || number === - Infinity ) { return number ; } return ( number >= 0 ? 1 : - 1 ) * Math . floor ( Math . abs ( number ) ) ; }
2304	function ToLength ( argument ) { var len = ToInteger ( argument ) ; return len <= 0 ? 0 : Math . min ( len , Math . pow ( 2 , 53 ) - 1 ) ; }
2305	function CreateArrayIterator ( array , kind ) { var O = ToObject ( array ) , iterator = Object . create ( ArrayIteratorPrototype ) ; defineInternal ( iterator , '[[IteratedObject]]' , O ) ; defineInternal ( iterator , '[[ArrayIteratorNextIndex]]' , 0 ) ; defineInternal ( iterator , '[[ArrayIteratorKind]]' , kind ) ; return iterator ; }
2306	function PromiseResolve ( ) { return function F ( resolution ) { var promise = F [ '[[Promise]]' ] , reactions ; if ( Type ( promise ) !== 'object' ) { throw TypeError ( ) ; } if ( promise [ '[[PromiseStatus]]' ] !== 'unresolved' ) { return undefined ; } reactions = promise [ '[[PromiseResolveReactions]]' ] ; defineInternal ( promise , '[[PromiseResult]]' , resolution ) ; defineInternal ( promise , '[[PromiseResolveReactions]]' , undefined ) ; defineInternal ( promise , '[[PromiseRejectReactions]]' , undefined ) ; defineInternal ( promise , '[[PromiseStatus]]' , 'has-resolution' ) ; return TriggerPromiseReactions ( reactions , resolution ) ; } ; }
2307	function GetCapabilitiesExecutor ( ) { return function F ( resolve , reject ) { var promiseCapability = F [ '[[Capability]]' ] ; if ( Type ( promiseCapability [ '[[Resolve]]' ] ) !== 'undefined' ) { throw TypeError ( ) ; } if ( Type ( promiseCapability [ '[[Reject]]' ] ) !== 'undefined' ) { throw TypeError ( ) ; } defineInternal ( promiseCapability , '[[Resolve]]' , resolve ) ; defineInternal ( promiseCapability , '[[Reject]]' , reject ) ; } ; }
2308	function PromiseResolutionHandlerFunction ( ) { return function F ( x ) { var promise = F [ '[[Promise]]' ] , fulfillmentHandler = F [ '[[FulfillmentHandler]]' ] , rejectionHandler = F [ '[[RejectionHandler]]' ] , selfResolutionError , C , promiseCapability , updateResult ; if ( SameValue ( x , promise ) ) { selfResolutionError = TypeError ( ) ; return rejectionHandler . call ( undefined , selfResolutionError ) ; } C = promise [ '[[PromiseConstructor]]' ] ; try { promiseCapability = NewPromiseCapability ( C ) ; } catch ( e ) { return e ; } try { updateResult = UpdatePromiseFromPotentialThenable ( x , promiseCapability ) ; } catch ( e ) { return e ; } if ( updateResult !== 'not a thenable' ) { return promiseCapability [ '[[Promise]]' ] . then ( fulfillmentHandler , rejectionHandler ) ; } return fulfillmentHandler . call ( undefined , x ) ; } ; }
2309	function ( target , sequence , t ) { sequence = sequence . split ( _ . splitRE ) ; for ( var i = 0 , e , props ; i < sequence . length && ( ! e || ! e . isSequenceStopped ( ) ) ; i ++ ) { props = _ . parse ( sequence [ i ] ) ; if ( props ) { props . sequence = sequence ; if ( e ) { props . previousEvent = e ; } if ( t ) { props . trigger = t ; } _ . controls ( props , target , sequence , i ) ; e = _ . event ( target , props ) ; } } return e ; }
2310	function ( e ) { var el = e . target , attr , type = e . type , key = type . indexOf ( 'key' ) === 0 ? e . which || e . keyCode || '' : '' , special = _ . special [ type + key ] ; if ( el && special ) { type = special ( e , el , el . nodeName . toLowerCase ( ) ) ; if ( ! type ) { return ; } } el = _ . find ( el , type ) , attr = _ . attr ( el , type ) ; if ( attr ) { _ . all ( el , attr , e ) ; if ( type === 'click' && ! _ . boxRE . test ( el . type ) ) { e . preventDefault ( ) ; } } }
2311	function reportNoEndingSpace ( node , token , tokenBefore ) { context . report ( { node : node , loc : token . loc . start , message : 'There should be no space before \'' + \' + token . value , '\'' } ) ; }
2312	function reportRequiredBeginningSpace ( node , token ) { context . report ( { node : node , loc : token . loc . start , message : 'A space is required after \'' + \' + token . value , '\'' } ) ; }
2313	function reportRequiredEndingSpace ( node , token ) { context . report ( { node : node , loc : token . loc . start , message : 'A space is required before \'' + \' + token . value , '\'' } ) ; }
2314	function generateDestinationLonLat ( { lat , lon } ) { const latOffset = ( getDistance ( ) / LAT_DEGREE ) * getSign ( ) const lonOffset = ( getDistance ( ) / ( LAT_DEGREE * Math . cos ( lat ) ) ) * getSign ( ) return { lat : lat + latOffset , lon : lon + lonOffset } }
2315	function ( keyParts , hash ) { for ( var i = 0 ; i < keyParts . length - 1 ; ++ i ) { hash = getValue ( keyParts [ i ] , hash ) ; if ( typeof ( hash ) === 'undefined' ) { return undefined ; } } var lastKeyPartIndex = keyParts . length - 1 ; return getValue ( keyParts [ lastKeyPartIndex ] , hash ) }
2316	function gitAuthors ( cb ) { return exec ( 'git log --pretty="%an <%ae>"' , function ( er , stdout , stderr ) { if ( er || stderr ) throw new Error ( er || stderr ) return cb ( null , stdout . split ( '\n' ) . \n reverse ) } ) }
2317	function lookupGithubLogin ( p , print , callback ) { var apiURI = 'https://api.github.com/search/users?q=' var options = { json : true , headers : { 'user-agent' : pkg . name + '/' + pkg . version } } if ( process . env . OAUTH_TOKEN ) { options . headers [ 'Authorization' ] = 'token ' + process . env . OAUTH_TOKEN . trim ( ) } function cb ( err , p ) { callback ( err , p ) } if ( print ) process . stdout . write ( '.' ) request ( apiURI + encodeURIComponent ( p . email + ' in:email type:user' ) , options , onEmail ) function onEmail ( err , data ) { rateLimitExceeded = rateLimitExceeded || data . body . message if ( ! err && data . body . items && data . body . items [ 0 ] ) { p . login = data . body . items [ 0 ] . login return cb ( err , p ) } request ( apiURI + encodeURIComponent ( p . name + ' in:fullname type:user' ) , options , onName ) } function onName ( err , data ) { rateLimitExceeded = rateLimitExceeded || data . body . message if ( ! err && data . body . items && data . body . items [ 0 ] ) { p . login = data . body . items [ 0 ] . login return cb ( err , p ) } cb ( err , p ) } }
2318	function _unpackOutput ( message ) { if ( message . charAt ( 0 ) != keyczar_util . VERSION_BYTE ) { throw new Error ( 'Unsupported version byte: ' + message . charCodeAt ( 0 ) ) ; } var keyhash = message . substr ( 1 , keyczar_util . KEYHASH_LENGTH ) ; message = message . substr ( 1 + keyczar_util . KEYHASH_LENGTH ) ; return { keyhash : keyhash , message : message } ; }
2319	function _rsaHash ( publicKey ) { var md = forge . md . sha1 . create ( ) ; _hashBigNumber ( md , publicKey . n ) ; _hashBigNumber ( md , publicKey . e ) ; var digest = md . digest ( ) ; return digest . getBytes ( keyczar_util . KEYHASH_LENGTH ) ; }
2320	function _makeRsaKey ( rsaKey ) { var key = { keyhash : _rsaHash ( rsaKey ) , size : rsaKey . n . bitLength ( ) } ; key . encrypt = function ( plaintext ) { var tempKey = forge . pki . setRsaPublicKey ( rsaKey . n , rsaKey . e ) ; var ciphertext = tempKey . encrypt ( plaintext , 'RSA-OAEP' ) ; return _packOutput ( key . keyhash , ciphertext ) ; } ; key . verify = function ( message , signature ) { signature = _unpackOutput ( signature ) ; _checkKeyHash ( key . keyhash , signature ) ; var digest = _mdForSignature ( message ) . digest ( ) . getBytes ( ) ; var tempKey = forge . pki . setRsaPublicKey ( rsaKey . n , rsaKey . e ) ; return tempKey . verify ( digest , signature . message ) ; } ; return key ; }
2321	function ( ) { if ( ! result ) { var exec = grunt . config . get ( 'exec' ) ; for ( var key in exec ) { exec [ key ] . cmd = nvmUse + ' && ' + exec [ key ] . cmd ; } grunt . config . set ( 'exec' , exec ) ; } }
2322	function ( callback ) { var command = '. ' + nvmPath ; childProcess . exec ( command , cmdOpts , function ( err , stdout , stderr ) { if ( stderr . indexOf ( 'No such file or directory' ) !== - 1 ) { if ( nvmPath === home + '/.nvm/nvm.sh' ) { nvmPath = home + '/nvm/nvm.sh' ; nvmInit = '. ' + nvmPath + ' && ' ; checkNVM ( callback ) ; } else { grunt [ options . errorLevel ] ( 'Expected node ' + expected + ', but found v' + actual + '\nNVM does not appear to be installed.\nPlease install (https://github.com/creationix/nvm#installation), or update the NVM path.' ) ; } } else \n } ) ; }
2323	function ( thisPackage , callback ) { var command = nvmUse + ' && npm install -g ' + thisPackage ; childProcess . exec ( command , cmdOpts , function ( err , stdout , stderr ) { if ( err ) { throw err ; } grunt . verbose . writeln ( stdout ) ; grunt . log . oklns ( 'Installed ' + thisPackage ) ; callback ( ) ; } ) ; }
2324	function ( ) { prompt . start ( ) ; var prop = { name : 'yesno' , message : 'You do not have any node versions installed that satisfy this project\'s requirements (' . \' + white + expected . yellow , '). Would you like to install the latest compatible version? (y/n)' . white , validator : / y[es]*|n[o]? / , required : true } ; warning : 'Must respond yes or no' }
2325	function ( ) { nvmLs ( 'remote' , function ( ) { bestMatch = semver . maxSatisfying ( remotes , expected ) ; nvmUse = nvmInit + 'nvm use ' + bestMatch ; var command = nvmInit + 'nvm install ' + bestMatch ; childProcess . exec ( command , cmdOpts , function ( err , stdout , stderr ) { if ( err ) { throw err ; } var nodeVersion = stdout . split ( ' ' ) [ 3 ] ; grunt . log . ok ( 'Installed node v' + bestMatch ) ; printVersion ( nodeVersion ) ; extendExec ( ) ; checkPackages ( options . globals ) ; } ) ; } ) ; }
2326	function ( loc , callback ) { var command = nvmInit + 'nvm ls' ; if ( loc === 'remote' ) { command += '-remote' ; } childProcess . exec ( command , cmdOpts , function ( err , stdout , stderr ) { var data = stripColorCodes ( stdout . toString ( ) ) . replace ( / \s+ / g , '|' ) , available = data . split ( '|' ) ; for ( var i = 0 ; i < available . length ; i ++ ) { available [ i ] = available [ i ] . replace ( / \s / g , '' ) ; var ver = semver . valid ( available [ i ] ) ; if ( ver ) { if ( loc === 'remote' ) { remotes . push ( ver ) ; } else if ( loc === 'local' ) { locals . push ( ver ) ; } } } callback ( ) ; } ) ; }
2327	function ( ) { nvmLs ( 'local' , function ( ) { var matches = semver . maxSatisfying ( locals , expected ) ; if ( matches ) { bestMatch = matches ; nvmUse = nvmInit + 'nvm use ' + bestMatch ; childProcess . exec ( nvmUse , cmdOpts , function ( err , stdout , stderr ) { printVersion ( stdout . split ( ' ' ) [ 3 ] ) ; extendExec ( ) ; checkPackages ( options . globals ) ; } ) ; } else { if ( options . alwaysInstall ) { nvmInstall ( ) ; } else { askInstall ( ) ; } } } ) ; }
2328	function EachSubject ( subject , elements , elementName , opt_noIndex ) { ProxyBase . call ( this ) ; this . elementSubjects = [ ] ; for ( var i = 0 ; i < elements . length ; ++ i ) { var es = subjectFactory . newSubject ( subject . failureStrategy , elements [ i ] ) ; es . named ( elementName + ( opt_noIndex ? '' : ( ' ' + i ) ) + ' of ' + subject . describe ( ) ) ; es . failureMessage = subject . failureMessage ; this . elementSubjects . push ( es ) ; } }
2329	function EventualSubject ( subject , promise ) { DeferredSubject . call ( this ) ; this . subject = subject ; var self = this ; this . promise = promise . then ( function ( value ) { var valueSubject = subjectFactory . newSubject ( subject . failureStrategy , value ) ; valueSubject . failureMessage = subject . failureMessage ; self . run ( valueSubject ) ; return value ; } , function ( reason ) { subject . fail ( 'Expected promise ' + subject . describe ( ) + ' to succeed, but failed with ' + this . format ( reason ) + '.' ) ; return reason ; } ) ; this . then = this . promise . then . bind ( this . promise ) ; this . catch = this . promise . catch . bind ( this . promise ) ; }
2330	function PromiseSubject ( failureStrategy , value ) { Subject . call ( this , failureStrategy , value ) ; this . then = this . value . then . bind ( this . value ) ; this . catch = this . value . catch . bind ( this . value ) ; }
2331	function doGet ( store , key , options = { } ) { key = store . _resolveRefKey ( key ) ; const { referenceDepth = 1 } = options ; const cacheKey = ` ${ key } ${ referenceDepth } ` ; const shouldCache = ! store . _isWritable ; if ( shouldCache ) { if ( store . _getCache [ cacheKey ] ) { return store . _getCache [ cacheKey ] ; } } let value = property . get ( store . _data , key ) ; if ( referenceDepth > 0 ) { value = resolveReferences ( store , value , referenceDepth ) ; } if ( shouldCache ) { store . _getCache [ cacheKey ] = value ; } return value ; }
2332	function resolveReferences ( store , value , depth ) { if ( -- depth < 0 ) { return value ; } if ( Array . isArray ( value ) ) { const n = value . length ; const v = new Array ( n ) ; let item ; for ( let i = n - 1 ; i >= 0 ; i -- ) { item = value [ i ] ; v [ i ] = resolveReferences ( store , store . _isRefValue ( item ) ? property . get ( store . _data , store . _parseRefKey ( item ) ) : item , depth ) ; } value = v ; } else if ( isPlainObject ( value ) ) { const v = { } ; let item ; for ( const prop in value ) { item = value [ prop ] ; v [ prop ] = resolveReferences ( store , store . _isRefValue ( item ) ? property . get ( store . _data , store . _parseRefKey ( item ) ) : item , depth ) ; } value = v ; } return value ; }
2333	function formatString ( value , options ) { var opts = options || { } ; var result = value . replace ( / [\0-\37] / g , function ( ch ) { switch ( ch ) { case '\n' : \n return '\\n' ; \\ case '\r' : \r return '\\r' ; \\ case '\t' : \t } } ) ; return '\\t' ; \\ }
2334	function formatObject ( value , options ) { if ( value === undefined ) { return 'undefined' ; } if ( value === null ) { return 'null' ; } if ( typeof ( value ) == 'object' ) { if ( value instanceof RegExp || value instanceof Date ) { return value + '' ; } var opts = options || { } ; var innerOpts = Object . assign ( { } , opts , { clip : false } ) ; var proto = Object . getPrototypeOf ( value ) ; if ( proto === Object . prototype || proto === null ) { var keys = [ ] ; for ( var k in value ) { keys . push ( k ) ; } keys . sort ( ) ; var parts = [ '{' ] ; var length = 4 ; for ( var i = 0 ; i < keys . length ; ++ i ) { var key = keys [ i ] ; var sep = i > 0 ? ', ' : ' ' ; var s = registry . format ( value [ key ] , innerOpts ) ; length += sep . length + key . length + 2 + s . length ; if ( opts . clip && opts . clip < length ) { parts . push ( ', ...' ) ; break ; } parts . push ( sep ) ; parts . push ( key ) ; parts . push ( ': ' ) ; parts . push ( s ) ; } if ( keys . length > 0 ) { parts . push ( ' ' ) ; } parts . push ( '}' ) ; return parts . join ( '' ) ; } if ( typeof value . toString == 'function' ) { return value . toString ( ) ; } return String ( value ) ; } throw new Error ( 'Implement' ) ; }
2335	function _exportPublicKey ( key ) { var t = key . metadata . type ; var p = key . metadata . purpose ; if ( ! ( t == keyczar . TYPE_RSA_PRIVATE && ( p == keyczar . PURPOSE_DECRYPT_ENCRYPT || p == keyczar . PURPOSE_SIGN_VERIFY ) ) ) { throw new Error ( 'Unsupported key type/purpose:' + t + '/' + p ) ; } var publicPurpose = keyczar . PURPOSE_ENCRYPT ; if ( p == keyczar . PURPOSE_SIGN_VERIFY ) { publicPurpose = keyczar . PURPOSE_VERIFY ; } var metadata = { name : key . metadata . name , purpose : publicPurpose , type : keyczar . TYPE_RSA_PUBLIC , encrypted : false , versions : key . metadata . versions } ; if ( key . metadata . versions . length != 1 ) { throw new Error ( 'TODO: Support key sets with multiple keys' ) ; } var primaryVersion = _getPrimaryVersion ( key . metadata ) ; var data = { meta : JSON . stringify ( metadata ) } ; data [ String ( primaryVersion ) ] = key . primary . exportPublicKeyJson ( ) ; return _makeKeyczar ( data ) ; }
2336	function _getPrimaryVersion ( metadata ) { var primaryVersion = null ; for ( var i = 0 ; i < metadata . versions . length ; i ++ ) { if ( metadata . versions [ i ] . status == STATUS_PRIMARY ) { if ( primaryVersion !== null ) { throw new Error ( 'Invalid key: multiple primary keys' ) ; } primaryVersion = metadata . versions [ i ] . versionNumber ; } } if ( primaryVersion === null ) { throw new Error ( 'No primary key' ) ; } return primaryVersion ; }
2337	function formatMap ( value , options ) { return 'Map(' + registry . format ( Array . from ( value . entries ( ) ) , options ) + ')' ; }
2338	function load ( store , key , url , options ) { const { cacheControl , rejectOnError , retry , timeout } = options ; options . id = key ; store . debug ( 'load %s from %s' , key , url ) ; return agent . get ( url , options ) . timeout ( timeout ) . retry ( retry ) . then ( res => { if ( store . destroyed ) { throw Error ( 'store destroyed' ) ; } store . debug ( 'loaded "%s" in %dms' , key , res . duration ) ; if ( res . body ) { if ( res . headers && 'expires' in res . headers ) { res . body [ store . EXPIRY_KEY ] = generateExpiry ( res . headers , cacheControl ) ; } store . set ( key , res . body , options ) ; } return res ; } ) . catch ( err => { if ( store . destroyed ) { throw err ; } store . debug ( 'unable to load "%s" from %s' , key , url ) ; if ( rejectOnError ) { store . set ( key , undefined , options ) ; } throw err ; } ) ; }
2339	function mergeCacheControl ( cacheControl , defaultCacheControl ) { if ( cacheControl == null ) { return Object . assign ( { } , defaultCacheControl ) ; } return { maxAge : 'maxAge' in cacheControl ? cacheControl . maxAge : defaultCacheControl . maxAge , staleIfError : 'staleIfError' in cacheControl ? cacheControl . staleIfError : defaultCacheControl . staleIfError } ; }
2340	function generateExpiry ( headers = { } , defaultCacheControl ) { const cacheControl = mergeCacheControl ( parseCacheControl ( headers [ 'cache-control' ] ) , defaultCacheControl ) ; const now = Date . now ( ) ; let expires = now ; if ( headers . expires ) { expires = typeof headers . expires === 'string' ? Number ( new Date ( headers . expires ) ) : headers . expires ; } if ( now >= expires ) { expires = now + cacheControl . maxAge ; } return { expires , expiresIfError : expires + cacheControl . staleIfError } ; }
2341	function generateResponseHeaders ( expiry = { } , defaultCacheControl , isError ) { const now = Date . now ( ) ; let maxAge ; if ( isError ) { maxAge = expiry && expiry . expiresIfError > now && expiry . expiresIfError - now < defaultCacheControl . maxAge ? Math . ceil ( ( expiry . expiresIfError - now ) / 1000 ) : defaultCacheControl . maxAge / 1000 ; } else { maxAge = expiry && expiry . expires > now ? Math . ceil ( ( expiry . expires - now ) / 1000 ) : defaultCacheControl . maxAge / 1000 ; } return { 'cache-control' : ` ${ maxAge } ` , expires : new Date ( now + maxAge * 1000 ) . toUTCString ( ) } ; }
2342	function hasExpired ( expiry , isError ) { if ( ! expiry ) { return true ; } return Math . ceil ( Date . now ( ) / 1000 ) * 1000 > ( isError ? expiry . expiresIfError : expiry . expires ) ; }
2343	function formatSet ( value , options ) { return 'Set(' + registry . format ( Array . from ( value . values ( ) ) , options ) + ')' ; }
2344	function formatArray ( value , options ) { var opts = options || { } ; var innerOpts = Object . assign ( { } , opts , { clip : false } ) ; var parts = [ '[' ] ; var length = 2 ; for ( var i = 0 ; i < value . length ; ++ i ) { var sep = i > 0 ? ', ' : '' ; var s = registry . format ( value [ i ] , innerOpts ) ; length += sep . length + s . length ; if ( opts . clip && opts . clip < length ) { parts . push ( ', ...' ) ; break ; } parts . push ( sep ) ; parts . push ( s ) ; } parts . push ( ']' ) ; return parts . join ( '' ) ; }
2345	function reset ( store , data ) { store . debug ( 'reset' ) ; store . _data = data ; store . changed = true ; }
2346	function serialise ( key , data , config ) { if ( isPlainObject ( data ) ) { const obj = { } ; for ( const prop in data ) { const keyChain = key ? ` ${ key } ${ prop } ` : prop ; const value = data [ prop ] ; if ( config [ keyChain ] !== false ) { if ( isPlainObject ( value ) ) { obj [ prop ] = serialise ( keyChain , value , config ) ; } else if ( value != null && typeof value === 'object' && 'toJSON' in value ) { obj [ prop ] = value . toJSON ( ) ; } else { obj [ prop ] = value ; } } } return obj ; } return config [ key ] !== false ? data : null ; }
2347	function explode ( store , data ) { if ( isPlainObject ( data ) ) { const obj = { } ; for ( const prop in data ) { obj [ prop ] = explode ( store , data [ prop ] ) ; } return obj ; } else if ( Array . isArray ( data ) ) { return data . map ( value => explode ( store , value ) ) ; } else if ( store . _isRefValue ( data ) ) { return explode ( store , store . get ( store . _parseRefKey ( data ) ) ) ; } return data ; }
2348	function Subject ( failureStrategy , value ) { this . failureStrategy = failureStrategy ; this . value = value ; this . name = null ; this . format = format ; this . failureMessage = null ; }
2349	function ( json ) { if ( ! ( this instanceof User ) ) { return new User ( json ) ; } if ( User . isInstance ( json ) ) { return json ; } this . init ( json ) ; }
2350	function ( ) { for ( var fls in configs ) { dirName = utils . folderName ( configs [ fls ] [ 'input' ] , configs [ fls ] [ 'folderName' ] ) ; dirType = configs [ fls ] [ 'type' ] ; destFolderDir = path . join ( configs [ fls ] [ 'destinationSourcePath' ] , dirName ) ; destDir = configs [ fls ] [ 'destinationSourcePath' ] ; tmpDir = configs [ fls ] [ 'tempFolderPath' ] ; tempFolderName = utils . getBaseFolderName ( tmpDir ) ; refSrcDir = configs [ fls ] [ 'refrenceSourcePath' ] ; ignoreExtentions = configs [ fls ] [ 'ignoreExts' ] || [ ] ; ignoreFolders = configs [ fls ] [ 'ignoreFolders' ] || [ ] ; contentReplaceRegx = new RegExp ( utils . regxContent ( configs [ fls ] [ 'replaceContent' ] ) , 'g' ) ; if ( configs [ fls ] [ 'replaceContent' ] ) { replaceContentLength = Object . keys ( configs [ fls ] [ 'replaceContent' ] ) . length ; } console . log ( ':::~~' + fls + ':::~~' ) ; folderSync ( configs [ fls ] ) ; } }
2351	function ( fls ) { if ( fs . existsSync ( destFolderDir ) ) { console . log ( ':::~~' + dirName + ' exists, please pick another name or delete previous to create new~~:::' ) deferred . reject ( fls . type + ' exists, please pick another name.' ) ; } else { console . log ( ':::~~' + dirName + ' does not exists, creating new~~:::' ) ; if ( ! fs . existsSync ( destFolderDir ) ) { fse . ensureDirSync ( destFolderDir ) ; console . log ( ':::~~Created new directory:' + fls . type + "/" + dirName + '~~:::' ) ; } copyRefToTemp ( ) ; updateTempSubDirNames ( fls ) ; copyTempToDest ( ) ; deferred . resolve ( 'successfuly created directory' ) ; } return deferred . promise ; }
2352	function ( ) { fse . emptyDirSync ( tmpDir ) ; fse . copySync ( refSrcDir , tmpDir , { overwrite : true } , err => { if ( err ) { console . log ( ':::~~error in copying to temp directory:' + err + '~~:::' ) ; fse . removeSync ( destFolderDir ) ; fse . emptyDirSync ( tmpDir ) ; deferred . reject ( 'Error in copying to temp directory' ) ; } console . log ( ':::~~ temp directory created~~:::' ) ; } ) ; }
2353	function ( oldPath , fls ) { console . log ( ":::~~processing your temp folder and file~~:::" + oldPath ) ; var parsedPath = updateFileNamePath ( path . parse ( oldPath ) , fls ) ; var newPath = path . format ( parsedPath ) ; var firstFolderName = utils . getFirstFolderName ( oldPath , tempFolderName ) ; fs . renameSync ( oldPath , newPath ) ; if ( replaceContentLength > 0 && ignoreExtentions . indexOf ( parsedPath . ext ) < 0 && ignoreFolders . indexOf ( firstFolderName ) < 0 ) { console . log ( ":::~~writing your temp file~~:::" + newPath ) ; var oldContent = fs . readFileSync ( newPath , 'utf8' ) ; var newContent = updateFileContent ( oldContent , fls . replaceContent , fls ) ; fs . writeFileSync ( newPath , newContent ) ; } else { console . log ( ":::~~skipping writing of your temp file~~:::" + newPath ) ; } }
2354	function ( parsedPath , fls ) { var newName = "" ; var fileConfigs = "" ; var folderDirArray = getNestedFolderName ( parsedPath ) ; parsedPath [ 'folderName' ] = utils . getBaseFolderName ( parsedPath . dir ) != tempFolderName ? utils . getBaseFolderName ( parsedPath . dir ) : "" ; if ( folderDirArray == "base" && fls . replaceFileName [ parsedPath . base ] ) { fileConfigs = fls . replaceFileName [ parsedPath . base ] ; } else if ( Array . isArray ( folderDirArray ) ) { var replaceFileNameArray = fls . replaceFileName ; for ( var i in folderDirArray ) { if ( replaceFileNameArray [ folderDirArray [ i ] ] && Object . keys ( replaceFileNameArray [ folderDirArray [ i ] ] ) . length > 0 ) { replaceFileNameArray = replaceFileNameArray [ folderDirArray [ i ] ] ; } else { replaceFileNameArray = [ ] ; break ; } } if ( replaceFileNameArray && replaceFileNameArray [ parsedPath . base ] ) { fileConfigs = replaceFileNameArray [ parsedPath . base ] ; } else { fileConfigs = [ ] ; } } else { fileConfigs = [ ] } console . log ( ":::~~Configurations from replaceFileName~~:::" + fileConfigs ) ; newName = utils . getupdatedFileName ( parsedPath . name , fileConfigs , fls . input ) ; parsedPath . base = newName + parsedPath . ext ; parsedPath . name = newName ; return parsedPath ; }
2355	function ( parsedPath ) { var tempPathArray = tmpDir . split ( "\\" ) ; \\ var parsedPathArray = parsedPath . dir . split ( "\\" ) ; }
2356	function ( oldContent , replaceConfig , fls ) { var newContent = oldContent . replace ( contentReplaceRegx , function ( e ) { for ( var cont in replaceConfig ) { var contRegex = new RegExp ( cont , 'g' ) ; if ( e . match ( contRegex ) ) { var replaceValue = utils . getReplacableContent ( fls . input , replaceConfig [ cont ] ) ; return replaceValue ; } } } ) ; return newContent ; }
2357	function ( ) { fse . emptyDirSync ( destFolderDir ) ; fse . copySync ( tmpDir , destFolderDir , { overwrite : true } , err => { if ( err ) { console . log ( ':::~~error in copying to destination directory:' + err + '~~:::' ) ; fse . removeSync ( destFolderDir ) ; fse . emptyDirSync ( tmpDir ) ; deferred . reject ( 'Error in copying to destination directory' ) ; } console . log ( ':::~~ destination directory created:' + dirName + '~~:::' ) ; } ) ; fse . emptyDirSync ( tmpDir ) ; console . log ( ':::~~Created new ' + dirType + " / " + dirName + ':::~~' ) ; }
2358	function scan ( text ) { let sr = SReader . create ( text ) ; let tokens = [ ] ; while ( ! sr . isDone ( ) ) { tokens . push ( readNext ( sr ) ) ; } return tokens ; }
2359	function KeystoneClient ( url , options ) { options = options || { } ; if ( options . username ) { if ( ! options . password && ! options . apiKey ) { throw new Error ( 'If username is provided you also need to provide password or apiKey' ) ; } } this . _url = url ; this . _username = options . username ; this . _apiKey = options . apiKey ; this . _password = options . password ; this . _extraArgs = options . extraArgs || { } ; this . _cacheTokenFor = options . cacheTokenFor || DEFAULT_CACHE_TOKEN_FOR ; this . _token = null ; this . _tokenExpires = null ; this . _refreshTokenCompletions = [ ] ; this . _tokenUpdated = 0 ; this . _tenantId = null ; this . _serviceCatalog = [ ] ; }
2360	function findAllParents ( p ) { var lastParent = p [ 0 ] ; var lastParentsParent = parents [ lastParent ] ; if ( lastParentsParent === undefined ) { return p ; } else { p . unshift ( lastParentsParent ) ; return findAllParents ( p ) ; } }
2361	function findDirectChildren ( className ) { var children = [ ] ; for ( var longname in parents ) { if ( parents [ longname ] === className ) { children . push ( longname ) ; } } return children ; }
2362	function makeHierarchyList ( classes ) { if ( classes . length === 0 ) { return '' ; } else { var className = classes . shift ( ) ; return '<ul><li>' + linkTo ( className ) + ' ' + makeHierarchyList ( classes ) + '</li></ul>' } }
2363	function makeChildrenList ( classes ) { var list = '<ul>' ; classes . forEach ( function ( className ) { list += '<li>' + linkTo ( className ) + '</li>' ; } ) list += '</ul>' ; return list ; }
2364	function ( e ) { var doclet = e . doclet ; if ( doclet . kind === 'class' && doclet . augments !== undefined && doclet . augments . length > 0 ) { parents [ doclet . longname ] = doclet . augments [ 0 ] ; } }
2365	function ( json ) { if ( ! ( this instanceof Tag ) ) { return new Tag ( json ) ; } if ( Tag . isInstance ( json ) ) { return json ; } this . init ( json ) ; }
2366	function gotOption ( option ) { if ( map [ option ] ) { option = map [ option ] var name = option [ 0 ] var value = true var count = option [ 2 ] while ( count -- ) { value = argv [ ++ index ] if ( argv . length === index ) { return cli . error ( 'The "' + name + '" option requires an argument.' ) } } var type = option [ 1 ] if ( type === 'Array' ) { value = value . split ( ',' ) } else if ( type === 'RegExp' ) { try { value = new RegExp ( value ) } catch ( e ) { return cli . error ( 'The "' + name + '" option received an invalid expression: "' + value + '".' ) } } else if ( type === 'Number' ) { var number = value * 1 if ( isNaN ( number ) ) { return cli . error ( 'The "' + name + '" option received a non-numerical argument: "' + value + '".' ) } } args [ name ] = value } else { return cli . error ( 'Unknown option: "' + option + '".' ) } }
2367	function ( json ) { if ( ! ( this instanceof Error ) ) { return new Error ( json ) ; } if ( Error . isInstance ( json ) ) { return json ; } this . init ( json ) ; }
2368	function ( json ) { if ( ! ( this instanceof ChildAndParentsRelationship ) ) { return new ChildAndParentsRelationship ( json ) ; } if ( ChildAndParentsRelationship . isInstance ( json ) ) { return json ; } this . init ( json ) ; }
2369	function ( json ) { if ( ! ( this instanceof ArtifactMetadata ) ) { return new ArtifactMetadata ( json ) ; } if ( ArtifactMetadata . isInstance ( json ) ) { return json ; } this . init ( json ) ; }
2370	function ( json ) { if ( ! ( this instanceof FeatureSet ) ) { return new FeatureSet ( json ) ; } if ( FeatureSet . isInstance ( json ) ) { return json ; } this . init ( json ) ; }
2371	function ( key ) { var tmp = window . document . cookie . match ( ( new RegExp ( key + '=[^;]+($|;)' , 'gi' ) ) ) ; if ( ! tmp || ! tmp [ 0 ] ) { return null ; } else { return window . unescape ( tmp [ 0 ] . substring ( key . length + 1 , tmp [ 0 ] . length ) . replace ( ';' , '' ) ) || null ; } }
2372	function ( name , func , pluginName ) { if ( pluginName !== undefined ) { currentPluginName = pluginName ; } var eventCurrentPluginName = currentPluginName , myEventFunc = function ( ) { var pubsubCore = pubsub . getCore ( ) ; currentPluginName = eventCurrentPluginName ; func . apply ( ( pubsubCore ? pubsubCore ( ) : pubsub ) , arguments ) ; } ; pluginBindings [ this . pluginName ] = pluginBindings [ this . pluginName ] || [ ] ; pluginBindings [ this . pluginName ] . push ( { name : name , func : myEventFunc } ) ; pubsub . on ( name , myEventFunc ) ; }
2373	function ( json ) { if ( ! ( this instanceof ChangeInfo ) ) { return new ChangeInfo ( json ) ; } if ( ChangeInfo . isInstance ( json ) ) { return json ; } this . init ( json ) ; }
2374	function ( repo ) { return p . spawn ( 'git' , [ 'remote' , 'show' , program . remote ] , CHILD_IGNORE ) . then ( function ( ) { } , function ( e ) { return p . spawn ( 'git' , [ 'remote' , 'add' , program . remote , 'git@github.com:' + repo ] ) ; } ) ; }
2375	function ( repo , branchname ) { return ensureRemote ( repo ) . then ( function ( ) { return p . spawn ( 'git' , [ 'push' , program . remote , 'HEAD:refs/heads/' + branchname ] , CHILD_IGNORE ) ; } ) ; }
2376	function runSync ( ) { for ( runIndex = 0 ; runIndex < sampleSize ; runIndex ++ ) { fn . call ( child ) } setTimeout ( finishChild , 0 ) }
2377	function runAsync ( ) { if ( runIndex ++ < sampleSize ) { fn . call ( child , function ( ) { setTimeout ( runAsync , 0 ) } ) } else { setTimeout ( finishChild , 0 ) } }
2378	function ( json ) { if ( ! ( this instanceof Comment ) ) { return new Comment ( json ) ; } if ( Comment . isInstance ( json ) ) { return json ; } this . init ( json ) ; }
2379	function watch ( dir ) { if ( ! ignoreDir . test ( dir ) && ! map [ dir ] ) { fs . lstat ( dir , function ( e , stat ) { if ( ! e ) { if ( stat . isSymbolicLink ( ) ) { var source = dir fs . readlink ( source , function ( e , link ) { if ( ! e ) { var dest = link if ( dest [ 0 ] !== '/' ) { while ( dest . substr ( 0 , 3 ) === '../' ) { dest = dest . substr ( 3 ) source = source . replace ( / \/[^\/]+$ / , '' ) } if ( dest . substr ( 0 , 2 ) === './' ) { dest = dest . substr ( 2 ) } dest = source + '/' + dest } watch ( dest ) } } ) } else if ( stat . isDirectory ( ) ) { addDir ( dir , stat ) } else { dir = dirname ( dir ) map [ dir ] = Math . max ( map [ dir ] , stat . mtime . getTime ( ) ) } } } ) } }
2380	function addDir ( dir , stat ) { var mtime = stat . mtime . getTime ( ) if ( ! map [ dir ] && list . length <= maxListSize ) { map [ dir ] = mtime list . push ( dir ) clearTimeout ( sortList . timer ) sortList . timer = setTimeout ( sortList , checkInterval ) fs . readdir ( dir , function ( e , files ) { if ( ! e ) { files . forEach ( function ( file ) { watch ( dir + '/' + file ) } ) } } ) } }
2381	function startWatches ( ) { list . forEach ( function ( dir , i ) { if ( i < maxFsWatches ) { try { fs . watch ( dir , function ( op , file ) { notify ( dir + '/' + file ) } ) } catch ( e ) { } } } ) }
2382	function checkDir ( ) { var n = indexes [ i ] if ( i > 44 ) { indexes [ i ] = ( indexes [ i ] + 5 ) % list . length } i = ( i + 1 ) % indexes . length var dir = list [ n ] if ( dir ) { fs . stat ( dir , function ( e , stat ) { if ( ! e && ( stat . mtime > okToNotifyAfter ) ) { fs . readdir ( dir , function ( e , files ) { if ( ! e ) { files . forEach ( function ( file ) { var path = dir + '/' + file fs . stat ( path , function ( e , stat ) { if ( ! e && ( stat . mtime > okToNotifyAfter ) ) { notify ( path ) } } ) } ) } } ) } } ) } }
2383	function notify ( path ) { var now = Date . now ( ) if ( ( now > okToNotifyAfter ) && ! ignoreFile . test ( path ) ) { process . send ( path ) okToNotifyAfter = now + notifyInterval sortList ( ) } }
2384	function decorateFn ( fn ) { fn . returns = function ( value ) { fn . _returns = value return fn } return fn }
2385	function MockDate ( value ) { var innerDate if ( arguments . length ) { innerDate = new timers . Date ( value ) } else if ( global . Date === timers . Date ) { innerDate = new timers . Date ( ) } else { innerDate = new timers . Date ( mock . time . _CURRENT_TIME ) } Object . defineProperty ( this , '_INNER_DATE' , { enumerable : false , value : innerDate } ) }
2386	function moveTime ( ) { if ( mock . time . _SPEED ) { mock . time . _PREVIOUS_TIME = realNow ( ) setTimeout ( function ( ) { var now = realNow ( ) var elapsed = now - mock . time . _PREVIOUS_TIME if ( elapsed ) { var add = elapsed * mock . time . _SPEED mock . time . add ( add ) } moveTime ( ) } , 0 ) } }
2387	function getScheduler ( isInterval ) { return function ( fn , time ) { schedules . push ( { id : ++ schedules . id , fn : fn , time : Date . now ( ) + time , interval : isInterval ? time : false } ) } }
2388	function getUnscheduler ( ) { return function ( id ) { for ( var i = 0 , l = schedules . length ; i < l ; i ++ ) { var schedule = schedules [ i ] if ( schedule . id === id ) { schedules . splice ( i , 1 ) break } } } }
2389	function runSchedules ( ) { schedules . sort ( function ( a , b ) { return b . time - a . time } ) var minNewTime = Number . MAX_VALUE var i = schedules . length - 1 var schedule = schedules [ i ] while ( schedule && ( schedule . time <= mock . time . _CURRENT_TIME ) ) { schedule . fn ( ) if ( ! schedule . interval ) { schedules . splice ( i , 1 ) } else { schedule . time += schedule . interval minNewTime = Math . min ( minNewTime , schedule . time ) } schedule = schedules [ -- i ] } if ( minNewTime <= mock . time . _CURRENT_TIME ) { process . nextTick ( runSchedules ) } }
2390	function startGc ( db , options ) { this . options = options || { } var freqMs = options . gcFreqMs || 60000 var maxVersions = options . gcMaxVersions var maxAge = options . gcMaxAge var backup = options . gcBackup var callback = options . gcCallback if ( maxAge || maxVersions ) { maxAge = maxAge || Math . pow ( 2 , 53 ) maxVersion = maxVersions || Math . pow ( 2 , 53 ) function filter ( record ) { if ( record . version != null ) { if ( Date . now ( ) - record . version > maxAge ) return true } if ( record . key != this . currentKey ) { this . currentKey = record . key this . currentCount = 0 } return this . currentCount ++ >= maxVersions } this . scanner = gc ( db , filter , backup ) return looseInterval ( scanner . run . bind ( scanner ) , freqMs , callback ) } }
2391	function ( json ) { if ( ! ( this instanceof NameFormInfo ) ) { return new NameFormInfo ( json ) ; } if ( NameFormInfo . isInstance ( json ) ) { return json ; } this . init ( json ) ; }
2392	function ( json ) { if ( ! ( this instanceof OAuth2 ) ) { return new OAuth2 ( json ) ; } if ( OAuth2 . isInstance ( json ) ) { return json ; } this . init ( json ) ; }
2393	function forceInRange ( value , min , max ) { if ( value > max ) { return max ; } else if ( value < min ) { return min ; } else { return value ; } }
2394	function insertIntoList ( item , position , list ) { var before = list . slice ( 0 , position ) ; var after = list . slice ( position ) ; return before . push ( item ) . concat ( after ) }
2395	function validateProps ( token ) { Object . keys ( token . props ) . forEach ( key => { if ( ! validateProp ( key , token . props [ key ] ) ) { throw Tools . syntaxError ( ` ${ key } ` , token ) ; } } ) ; }
2396	function Event ( name , attributes ) { this . _name = name ; this . _stopped = false ; this . _attrs = { } ; if ( attributes ) { this . setAttributes ( attributes ) ; } }
2397	function create ( text ) { return Tools . instance ( { text , pos : 0 } , { isDone , getPos , expect , accept , expectRE , acceptRE , goto } ) ; }
2398	function ( json ) { if ( ! ( this instanceof FeedbackInfo ) ) { return new FeedbackInfo ( json ) ; } if ( FeedbackInfo . isInstance ( json ) ) { return json ; } this . init ( json ) ; }
2399	function ( json ) { if ( ! ( this instanceof Reservation ) ) { return new Reservation ( json ) ; } if ( Reservation . isInstance ( json ) ) { return json ; } this . init ( json ) ; }
2400	function ( json ) { if ( ! ( this instanceof SearchInfo ) ) { return new SearchInfo ( json ) ; } if ( SearchInfo . isInstance ( json ) ) { return json ; } this . init ( json ) ; }
2401	function asyncForEach ( array , iterator , done ) { if ( array . length === 0 ) { done ( ) ; return ; } let pending = array . length ; array . forEach ( item => { iterator ( item , ( ) => { if ( -- pending === 0 ) { done ( ) ; } } ) ; } ) ; }
2402	function safeCall ( fn , args ) { args = Array . prototype . slice . call ( arguments , 1 ) ; let callback = call . once ( args . pop ( ) ) ; args . push ( callback ) ; try { fn . apply ( null , args ) ; } catch ( err ) { callback ( err ) ; } }
2403	function callOnce ( fn ) { let fulfilled = false ; return function onceWrapper ( err ) { if ( ! fulfilled ) { fulfilled = true ; return fn . apply ( this , arguments ) ; } else if ( err ) { throw err ; } } ; }
2404	function uniqNoSet ( arr ) { var ret = [ ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( ret . indexOf ( arr [ i ] ) === - 1 ) { ret . push ( arr [ i ] ) ; } } return ret ; }
2405	function uniqSetWithForEach ( arr ) { var ret = [ ] ; ( new Set ( arr ) ) . forEach ( function ( el ) { ret . push ( el ) ; } ) ; return ret ; }
2406	function Base ( config , options ) { if ( ! ( this instanceof Base ) ) { return new Base ( config , options ) ; } Cache . call ( this , config ) ; this . is ( 'base' ) ; this . initBase ( config , options ) ; }
2407	function memoize ( type , pattern , options , fn ) { var key = utils . createKey ( type + ':' + pattern , options ) ; var disabled = options && options . cache === false ; if ( disabled ) { braces . clearCache ( ) ; return fn ( pattern , options ) ; } if ( cache . hasOwnProperty ( key ) ) { return cache [ key ] ; } var res = fn ( pattern , options ) ; cache [ key ] = res ; return res ; }
2408	function multiply ( queue , n , options ) { return utils . flatten ( utils . repeat ( utils . arrayify ( queue ) , n ) ) ; }
2409	function noInner ( node , type ) { if ( node . parent . queue . length === 1 ) { return true ; } var nodes = node . parent . nodes ; return nodes . length === 3 && isType ( nodes [ 0 ] , 'brace.open' ) && ! isType ( nodes [ 1 ] , 'text' ) && isType ( nodes [ 2 ] , 'brace.close' ) ; }
2410	function brackets ( pattern , options ) { debug ( 'initializing from <%s>' , __filename ) ; var res = brackets . create ( pattern , options ) ; return res . output ; }
2411	function wrap ( arr , sep , opts ) { if ( sep === '~' ) { sep = '-' ; } var str = arr . join ( sep ) ; var pre = opts && opts . regexPrefix ; if ( sep === '|' ) { str = pre ? pre + str : str ; str = '(' + str + ')' ; } if ( sep === '-' ) { str = ( pre && pre === '^' ) ? pre + str : str ; str = '[' + str + ']' ; } return [ str ] ; }
2412	function formatPadding ( ch , pad ) { var res = pad ? pad + ch : ch ; if ( pad && ch . toString ( ) . charAt ( 0 ) === '-' ) { res = '-' + pad + ch . toString ( ) . substr ( 1 ) ; } return res . toString ( ) ; }
2413	function isPadded ( origA , origB ) { if ( hasZeros ( origA ) || hasZeros ( origB ) ) { var alen = length ( origA ) ; var blen = length ( origB ) ; var len = alen >= blen ? alen : blen ; return function ( a ) { return repeatStr ( '0' , len - length ( a ) ) ; } ; } return false ; }
2414	function Extglob ( options ) { this . options = extend ( { source : 'extglob' } , options ) ; this . snapdragon = this . options . snapdragon || new Snapdragon ( this . options ) ; this . snapdragon . patterns = this . snapdragon . patterns || { } ; this . compiler = this . snapdragon . compiler ; this . parser = this . snapdragon . parser ; compilers ( this . snapdragon ) ; parsers ( this . snapdragon ) ; define ( this . snapdragon , 'parse' , function ( str , options ) { var parsed = Snapdragon . prototype . parse . apply ( this , arguments ) ; parsed . input = str ; var last = this . parser . stack . pop ( ) ; if ( last && this . options . strict !== true ) { var node = last . nodes [ 0 ] ; node . val = '\\' + \\ ; node . val var sibling = node . parent . nodes [ 1 ] ; } if ( sibling . type === 'star' ) { sibling . loose = true ; } define ( parsed , 'parser' , this . parser ) ; } ) ; return parsed ; define ( this , 'parse' , function ( ast , options ) { return this . snapdragon . parse . apply ( this . snapdragon , arguments ) ; } ) ; }
2415	function micromatch ( list , patterns , options ) { patterns = utils . arrayify ( patterns ) ; list = utils . arrayify ( list ) ; var len = patterns . length ; if ( list . length === 0 || len === 0 ) { return [ ] ; } if ( len === 1 ) { return micromatch . match ( list , patterns [ 0 ] , options ) ; } var omit = [ ] ; var keep = [ ] ; var idx = - 1 ; while ( ++ idx < len ) { var pattern = patterns [ idx ] ; if ( typeof pattern === 'string' && pattern . charCodeAt ( 0 ) === 33 ) { omit . push . apply ( omit , micromatch . match ( list , pattern . slice ( 1 ) , options ) ) ; } else { keep . push . apply ( keep , micromatch . match ( list , pattern , options ) ) ; } } var matches = utils . diff ( keep , omit ) ; if ( ! options || options . nodupes !== false ) { return utils . unique ( matches ) ; } return matches ; }
2416	function sync ( source , opts ) { var works = getWorks ( source , reader_sync_1 . default , opts ) ; return arrayUtils . flatten ( works ) ; }
2417	function stream ( source , opts ) { var works = getWorks ( source , reader_stream_1 . default , opts ) ; return merge2 ( works ) ; }
2418	function generateTasks ( source , opts ) { var patterns = [ ] . concat ( source ) ; var options = optionsManager . prepare ( opts ) ; return taskManager . generate ( patterns , options ) ; }
2419	function getWorks ( source , _Reader , opts ) { var patterns = [ ] . concat ( source ) ; var options = optionsManager . prepare ( opts ) ; var tasks = taskManager . generate ( patterns , options ) ; var reader = new _Reader ( options ) ; return tasks . map ( reader . read , reader ) ; }
2420	function generate ( patterns , options ) { var unixPatterns = patterns . map ( patternUtils . unixifyPattern ) ; var unixIgnore = options . ignore . map ( patternUtils . unixifyPattern ) ; var positivePatterns = getPositivePatterns ( unixPatterns ) ; var negativePatterns = getNegativePatternsAsPositive ( unixPatterns , unixIgnore ) ; var staticPatterns = positivePatterns . filter ( patternUtils . isStaticPattern ) ; var dynamicPatterns = positivePatterns . filter ( patternUtils . isDynamicPattern ) ; var staticTasks = convertPatternsToTasks ( staticPatterns , negativePatterns , false ) ; var dynamicTasks = convertPatternsToTasks ( dynamicPatterns , negativePatterns , true ) ; return staticTasks . concat ( dynamicTasks ) ; }
2421	function convertPatternsToTasks ( positive , negative , dynamic ) { var positivePatternsGroup = groupPatternsByBaseDirectory ( positive ) ; var negativePatternsGroup = groupPatternsByBaseDirectory ( negative ) ; if ( '.' in positivePatternsGroup ) { var task = convertPatternGroupToTask ( '.' , positive , negative , dynamic ) ; return [ task ] ; } return convertPatternGroupsToTasks ( positivePatternsGroup , negativePatternsGroup , dynamic ) ; }
2422	function getNegativePatternsAsPositive ( patterns , ignore ) { var negative = patternUtils . getNegativePatterns ( patterns ) . concat ( ignore ) ; var positive = negative . map ( patternUtils . convertToPositivePattern ) ; return positive ; }
2423	function groupPatternsByBaseDirectory ( patterns ) { return patterns . reduce ( function ( collection , pattern ) { var base = patternUtils . getBaseDirectory ( pattern ) ; if ( base in collection ) { collection [ base ] . push ( pattern ) ; } else { collection [ base ] = [ pattern ] ; } return collection ; } , { } ) ; }
2424	function convertPatternGroupsToTasks ( positive , negative , dynamic ) { var globalNegative = '.' in negative ? negative [ '.' ] : [ ] ; return Object . keys ( positive ) . map ( function ( base ) { var localNegative = findLocalNegativePatterns ( base , negative ) ; var fullNegative = localNegative . concat ( globalNegative ) ; return convertPatternGroupToTask ( base , positive [ base ] , fullNegative , dynamic ) ; } ) ; }
2425	function findLocalNegativePatterns ( positiveBase , negative ) { return Object . keys ( negative ) . reduce ( function ( collection , base ) { if ( base . startsWith ( positiveBase ) ) { collection . push . apply ( collection , __spread ( negative [ base ] ) ) ; } return collection ; } , [ ] ) ; }
2426	function convertPatternGroupToTask ( base , positive , negative , dynamic ) { return { base : base , dynamic : dynamic , patterns : [ ] . concat ( positive , negative . map ( patternUtils . convertToNegativePattern ) ) , positive : positive , negative : negative } ; }
2427	function matchAny ( entry , patternsRe ) { try { for ( var patternsRe_1 = __values ( patternsRe ) , patternsRe_1_1 = patternsRe_1 . next ( ) ; ! patternsRe_1_1 . done ; patternsRe_1_1 = patternsRe_1 . next ( ) ) { var regexp = patternsRe_1_1 . value ; if ( regexp . test ( entry ) ) { return true ; } } } catch ( e_1_1 ) { e_1 = { error : e_1_1 } ; } finally { try { if ( patternsRe_1_1 && ! patternsRe_1_1 . done && ( _a = patternsRe_1 . return ) ) _a . call ( patternsRe_1 ) ; } finally { if ( e_1 ) throw e_1 . error ; } } return false ; var e_1 , _a ; }
2428	function ( ) { removeNotFoundFiles ( ) ; var entries = normalizedEntries ; var keys = Object . keys ( entries ) ; if ( keys . length === 0 ) { return ; } keys . forEach ( function ( entryName ) { var cacheEntry = entries [ entryName ] ; try { var stat = fs . statSync ( cacheEntry . key ) ; var meta = assign ( cacheEntry . meta , { size : stat . size , mtime : stat . mtime . getTime ( ) } ) ; cache . setKey ( entryName , meta ) ; } catch ( err ) { if ( err . code !== 'ENOENT' ) { throw err ; } } } ) ; cache . save ( true ) ; }
2429	function ( pathToFile ) { var me = this ; var dir = path . dirname ( pathToFile ) ; var fName = path . basename ( pathToFile ) ; me . load ( fName , dir ) ; }
2430	function ( noPrune ) { var me = this ; ( ! noPrune ) && me . _prune ( ) ; writeJSON ( me . _pathToFile , me . _persisted ) ; }
2431	function ( docId , cacheDir ) { var obj = Object . create ( cache ) ; obj . load ( docId , cacheDir ) ; return obj ; }
2432	function ( docId , cacheDir ) { var filePath = cacheDir ? path . resolve ( cacheDir , docId ) : path . resolve ( __dirname , './.cache/' , docId ) ; return del ( filePath , { force : true } ) . length > 0 ; }
2433	function ( cacheName , key , val ) { var cache = this . cache ( cacheName ) ; cache . set ( key , val ) ; return cache ; }
2434	function LOOP ( ) { if ( pos >= p . length ) { if ( cache ) cache [ original ] = p ; return cb ( null , p ) ; } nextPartRe . lastIndex = pos ; var result = nextPartRe . exec ( p ) ; previous = current ; current += result [ 0 ] ; base = previous + result [ 1 ] ; pos = nextPartRe . lastIndex ; if ( knownHard [ base ] || ( cache && cache [ base ] === base ) ) { return process . nextTick ( LOOP ) ; } if ( cache && Object . prototype . hasOwnProperty . call ( cache , base ) ) { return gotResolvedLink ( cache [ base ] ) ; } return fs . lstat ( base , gotStat ) ; }
2435	function micromatch ( files , patterns , opts ) { if ( ! files || ! patterns ) return [ ] ; opts = opts || { } ; if ( typeof opts . cache === 'undefined' ) { opts . cache = true ; } if ( ! Array . isArray ( patterns ) ) { return match ( files , patterns , opts ) ; } var len = patterns . length , i = 0 ; var omit = [ ] , keep = [ ] ; while ( len -- ) { var glob = patterns [ i ++ ] ; if ( typeof glob === 'string' && glob . charCodeAt ( 0 ) === 33 ) { omit . push . apply ( omit , match ( files , glob . slice ( 1 ) , opts ) ) ; } else { keep . push . apply ( keep , match ( files , glob , opts ) ) ; } } return utils . diff ( keep , omit ) ; }
2436	function match ( files , pattern , opts ) { if ( utils . typeOf ( files ) !== 'string' && ! Array . isArray ( files ) ) { throw new Error ( msg ( 'match' , 'files' , 'a string or array' ) ) ; } files = utils . arrayify ( files ) ; opts = opts || { } ; var negate = opts . negate || false ; var orig = pattern ; if ( typeof pattern === 'string' ) { negate = pattern . charAt ( 0 ) === '!' ; if ( negate ) { pattern = pattern . slice ( 1 ) ; } if ( opts . nonegate === true ) { negate = false ; } } var _isMatch = matcher ( pattern , opts ) ; var len = files . length , i = 0 ; var res = [ ] ; while ( i < len ) { var file = files [ i ++ ] ; var fp = utils . unixify ( file , opts ) ; if ( ! _isMatch ( fp ) ) { continue ; } res . push ( fp ) ; } if ( res . length === 0 ) { if ( opts . failglob === true ) { throw new Error ( 'micromatch.match() found no matches for: "' + orig + '".' ) ; } if ( opts . nonull || opts . nullglob ) { res . push ( utils . unescapeGlob ( orig ) ) ; } } if ( negate ) { res = utils . diff ( files , res ) ; } if ( opts . ignore && opts . ignore . length ) { pattern = opts . ignore ; opts = utils . omit ( opts , [ 'ignore' ] ) ; res = utils . diff ( res , micromatch ( res , pattern , opts ) ) ; } if ( opts . nodupes ) { return utils . unique ( res ) ; } return res ; }
2437	function isMatch ( fp , pattern , opts ) { if ( typeof fp !== 'string' ) { throw new TypeError ( msg ( 'isMatch' , 'filepath' , 'a string' ) ) ; } fp = utils . unixify ( fp , opts ) ; if ( utils . typeOf ( pattern ) === 'object' ) { return matcher ( fp , pattern ) ; } return matcher ( pattern , opts ) ( fp ) ; }
2438	function contains ( fp , pattern , opts ) { if ( typeof fp !== 'string' ) { throw new TypeError ( msg ( 'contains' , 'pattern' , 'a string' ) ) ; } opts = opts || { } ; opts . contains = ( pattern !== '' ) ; fp = utils . unixify ( fp , opts ) ; if ( opts . contains && ! utils . isGlob ( pattern ) ) { return fp . indexOf ( pattern ) !== - 1 ; } return matcher ( pattern , opts ) ( fp ) ; }
2439	function any ( fp , patterns , opts ) { if ( ! Array . isArray ( patterns ) && typeof patterns !== 'string' ) { throw new TypeError ( msg ( 'any' , 'patterns' , 'a string or array' ) ) ; } patterns = utils . arrayify ( patterns ) ; var len = patterns . length ; fp = utils . unixify ( fp , opts ) ; while ( len -- ) { var isMatch = matcher ( patterns [ len ] , opts ) ; if ( isMatch ( fp ) ) { return true ; } } return false ; }
2440	function matchKeys ( obj , glob , options ) { if ( utils . typeOf ( obj ) !== 'object' ) { throw new TypeError ( msg ( 'matchKeys' , 'first argument' , 'an object' ) ) ; } var fn = matcher ( glob , options ) ; var res = { } ; for ( var key in obj ) { if ( obj . hasOwnProperty ( key ) && fn ( key ) ) { res [ key ] = obj [ key ] ; } } return res ; }
2441	function matcher ( pattern , opts ) { if ( typeof pattern === 'function' ) { return pattern ; } if ( pattern instanceof RegExp ) { return function ( fp ) { return pattern . test ( fp ) ; } ; } if ( typeof pattern !== 'string' ) { throw new TypeError ( msg ( 'matcher' , 'pattern' , 'a string, regex, or function' ) ) ; } pattern = utils . unixify ( pattern , opts ) ; if ( ! utils . isGlob ( pattern ) ) { return utils . matchPath ( pattern , opts ) ; } var re = makeRe ( pattern , opts ) ; if ( opts && opts . matchBase ) { return utils . hasFilename ( re , opts ) ; } return function ( fp ) { fp = utils . unixify ( fp , opts ) ; return re . test ( fp ) ; } ; }
2442	function toRegex ( glob , options ) { var opts = Object . create ( options || { } ) ; var flags = opts . flags || '' ; if ( opts . nocase && flags . indexOf ( 'i' ) === - 1 ) { flags += 'i' ; } var parsed = expand ( glob , opts ) ; opts . negated = opts . negated || parsed . negated ; opts . negate = opts . negated ; glob = wrapGlob ( parsed . pattern , opts ) ; var re ; try { re = new RegExp ( glob , flags ) ; return re ; } catch ( err ) { err . reason = 'micromatch invalid regex: (' + re + ')' ; if ( opts . strict ) throw new SyntaxError ( err ) ; } return / $^ / ; }
2443	function wrapGlob ( glob , opts ) { var prefix = ( opts && ! opts . contains ) ? '^' : '' ; var after = ( opts && ! opts . contains ) ? '$' : '' ; glob = ( '(?:' + glob + ')' + after ) ; if ( opts && opts . negate ) { return prefix + ( '(?!^' + glob + ').*$' ) ; } return prefix + glob ; }
2444	function makeRe ( glob , opts ) { if ( utils . typeOf ( glob ) !== 'string' ) { throw new Error ( msg ( 'makeRe' , 'glob' , 'a string' ) ) ; } return utils . cache ( toRegex , glob , opts ) ; }
2445	function collapse ( str , ch ) { var res = str . split ( ch ) ; var isFirst = res [ 0 ] === '' ; var isLast = res [ res . length - 1 ] === '' ; res = res . filter ( Boolean ) ; if ( isFirst ) res . unshift ( '' ) ; if ( isLast ) res . push ( '' ) ; return res . join ( ch ) ; }
2446	function exponential ( str , options , fn ) { if ( typeof options === 'function' ) { fn = options ; options = null ; } var opts = options || { } ; var esc = '__ESC_EXP__' ; var exp = 0 ; var res ; var parts = str . split ( '{,}' ) ; if ( opts . nodupes ) { return fn ( parts . join ( '' ) , opts ) ; } exp = parts . length - 1 ; res = fn ( parts . join ( esc ) , opts ) ; var len = res . length ; var arr = [ ] ; var i = 0 ; while ( len -- ) { var ele = res [ i ++ ] ; var idx = ele . indexOf ( esc ) ; if ( idx === - 1 ) { arr . push ( ele ) ; } else { ele = ele . split ( '__ESC_EXP__' ) . join ( '' ) ; if ( ! ! ele && opts . nodupes !== false ) { arr . push ( ele ) ; } else { var num = Math . pow ( 2 , exp ) ; arr . push . apply ( arr , repeat ( ele , num ) ) ; } } } return arr ; }
2447	function splitWhitespace ( str ) { var segs = str . split ( ' ' ) ; var len = segs . length ; var res = [ ] ; var i = 0 ; while ( len -- ) { res . push . apply ( res , braces ( segs [ i ++ ] ) ) ; } return res ; }
2448	function filter ( arr , cb ) { if ( arr == null ) return [ ] ; if ( typeof cb !== 'function' ) { throw new TypeError ( 'braces: filter expects a callback function.' ) ; } var len = arr . length ; var res = arr . slice ( ) ; var i = 0 ; while ( len -- ) { if ( ! cb ( arr [ len ] , i ++ ) ) { res . splice ( len , 1 ) ; } } return res ; }
2449	function extglob ( str , opts ) { opts = opts || { } ; var o = { } , i = 0 ; str = str . replace ( / !\(([^\w*()]) / g , '$1!(' ) ; str = str . replace ( / ([*\/])\.!\([*]\) / g , function ( m , ch ) { if ( ch === '/' ) { return escape ( '\\/[^.]+' ) ; } \\ } ) ; return escape ( '[^.]+' ) ; var key = str + String ( ! ! opts . regex ) + String ( ! ! opts . contains ) + String ( ! ! opts . escape ) ; if ( cache . hasOwnProperty ( key ) ) { return cache [ key ] ; } if ( ! ( re instanceof RegExp ) ) { re = regex ( ) ; } opts . negate = false ; var m ; while ( m = re . exec ( str ) ) { var prefix = m [ 1 ] ; var inner = m [ 3 ] ; if ( prefix === '!' ) { opts . negate = true ; } var id = '__EXTGLOB_' + ( i ++ ) + '__' ; o [ id ] = wrap ( inner , prefix , opts . escape ) ; str = str . split ( m [ 0 ] ) . join ( id ) ; } var keys = Object . keys ( o ) ; var len = keys . length ; while ( len -- ) { var prop = keys [ len ] ; str = str . split ( prop ) . join ( o [ prop ] ) ; } var result = opts . regex ? toRegex ( str , opts . contains , opts . negate ) : str ; result = result . split ( '.' ) . join ( '\\.' ) ; }
2450	function wrap ( inner , prefix , esc ) { if ( esc ) inner = escape ( inner ) ; switch ( prefix ) { case '!' : return '(?!' + inner + ')[^/]' + ( esc ? '%%%~' : '*?' ) ; case '@' : return '(?:' + inner + ')' ; case '+' : return '(?:' + inner + ')+' ; case '*' : return '(?:' + inner + ')' + ( esc ? '%%' : '*' ) case '?' : return '(?:' + inner + '|)' ; default : return inner ; } }
2451	function toRegex ( pattern , contains , isNegated ) { var prefix = contains ? '^' : '' ; var after = contains ? '$' : '' ; pattern = ( '(?:' + pattern + ')' + after ) ; if ( isNegated ) { pattern = prefix + negate ( pattern ) ; } return new RegExp ( prefix + pattern ) ; }
2452	function copy ( val , key ) { if ( key === '__proto__' ) { return ; } var obj = this [ key ] ; if ( isObject ( val ) && isObject ( obj ) ) { mixinDeep ( obj , val ) ; } else { this [ key ] = val ; } }
2453	function advanceTo ( input , endChar ) { var ch = input . charAt ( 0 ) ; var tok = { len : 1 , val : '' , esc : '' } ; var idx = 0 ; function advance ( ) { if ( ch !== '\\' ) \\ { tok . esc += '\\' + \\ ; ch } tok . val += ch ; ch = input . charAt ( ++ idx ) ; } tok . len ++ ; if ( ch === '\\' ) \\ }
2454	function BasicSourceMapConsumer ( aSourceMap , aSourceMapURL ) { var sourceMap = aSourceMap ; if ( typeof aSourceMap === 'string' ) { sourceMap = util . parseSourceMapInput ( aSourceMap ) ; } var version = util . getArg ( sourceMap , 'version' ) ; var sources = util . getArg ( sourceMap , 'sources' ) ; var names = util . getArg ( sourceMap , 'names' , [ ] ) ; var sourceRoot = util . getArg ( sourceMap , 'sourceRoot' , null ) ; var sourcesContent = util . getArg ( sourceMap , 'sourcesContent' , null ) ; var mappings = util . getArg ( sourceMap , 'mappings' ) ; var file = util . getArg ( sourceMap , 'file' , null ) ; if ( version != this . _version ) { throw new Error ( 'Unsupported version: ' + version ) ; } if ( sourceRoot ) { sourceRoot = util . normalize ( sourceRoot ) ; } sources = sources . map ( String ) . map ( util . normalize ) . map ( function ( source ) { return sourceRoot && util . isAbsolute ( sourceRoot ) && util . isAbsolute ( source ) ? util . relative ( sourceRoot , source ) : source ; } ) ; this . _names = ArraySet . fromArray ( names . map ( String ) , true ) ; this . _sources = ArraySet . fromArray ( sources , true ) ; this . _absoluteSources = this . _sources . toArray ( ) . map ( function ( s ) { return util . computeSourceURL ( sourceRoot , s , aSourceMapURL ) ; } ) ; this . sourceRoot = sourceRoot ; this . sourcesContent = sourcesContent ; this . _mappings = mappings ; this . _sourceMapURL = aSourceMapURL ; this . file = file ; }
2455	function compareByOriginalPositions ( mappingA , mappingB , onlyCompareOriginal ) { var cmp = strcmp ( mappingA . source , mappingB . source ) ; if ( cmp !== 0 ) { return cmp ; } cmp = mappingA . originalLine - mappingB . originalLine ; if ( cmp !== 0 ) { return cmp ; } cmp = mappingA . originalColumn - mappingB . originalColumn ; if ( cmp !== 0 || onlyCompareOriginal ) { return cmp ; } cmp = mappingA . generatedColumn - mappingB . generatedColumn ; if ( cmp !== 0 ) { return cmp ; } cmp = mappingA . generatedLine - mappingB . generatedLine ; if ( cmp !== 0 ) { return cmp ; } return strcmp ( mappingA . name , mappingB . name ) ; }
2456	function compareByGeneratedPositionsDeflated ( mappingA , mappingB , onlyCompareGenerated ) { var cmp = mappingA . generatedLine - mappingB . generatedLine ; if ( cmp !== 0 ) { return cmp ; } cmp = mappingA . generatedColumn - mappingB . generatedColumn ; if ( cmp !== 0 || onlyCompareGenerated ) { return cmp ; } cmp = strcmp ( mappingA . source , mappingB . source ) ; if ( cmp !== 0 ) { return cmp ; } cmp = mappingA . originalLine - mappingB . originalLine ; if ( cmp !== 0 ) { return cmp ; } cmp = mappingA . originalColumn - mappingB . originalColumn ; if ( cmp !== 0 ) { return cmp ; } return strcmp ( mappingA . name , mappingB . name ) ; }
2457	function computeSourceURL ( sourceRoot , sourceURL , sourceMapURL ) { sourceURL = sourceURL || '' ; if ( sourceRoot ) { if ( sourceRoot [ sourceRoot . length - 1 ] !== '/' && sourceURL [ 0 ] !== '/' ) { sourceRoot += '/' ; } sourceURL = sourceRoot + sourceURL ; } if ( sourceMapURL ) { var parsed = urlParse ( sourceMapURL ) ; if ( ! parsed ) { throw new Error ( "sourceMapURL could not be parsed" ) ; } if ( parsed . path ) { var index = parsed . path . lastIndexOf ( '/' ) ; if ( index >= 0 ) { parsed . path = parsed . path . substring ( 0 , index + 1 ) ; } } sourceURL = join ( urlGenerate ( parsed ) , sourceURL ) ; } return normalize ( sourceURL ) ; }
2458	function CorkedRequest ( state ) { var _this = this ; this . next = null ; this . entry = null ; this . finish = function ( ) { onCorkedFinish ( _this , state ) ; } ; }
2459	function clearBuffer ( stream , state ) { state . bufferProcessing = true ; var entry = state . bufferedRequest ; if ( stream . _writev && entry && entry . next ) { var l = state . bufferedRequestCount ; var buffer = new Array ( l ) ; var holder = state . corkedRequestsFree ; holder . entry = entry ; var count = 0 ; var allBuffers = true ; while ( entry ) { buffer [ count ] = entry ; if ( ! entry . isBuf ) allBuffers = false ; entry = entry . next ; count += 1 ; } buffer . allBuffers = allBuffers ; doWrite ( stream , state , true , state . length , buffer , '' , holder . finish ) ; state . pendingcb ++ ; state . lastBufferedRequest = null ; if ( holder . next ) { state . corkedRequestsFree = holder . next ; holder . next = null ; } else { state . corkedRequestsFree = new CorkedRequest ( state ) ; } state . bufferedRequestCount = 0 ; } else { while ( entry ) { var chunk = entry . chunk ; var encoding = entry . encoding ; var cb = entry . callback ; var len = state . objectMode ? 1 : chunk . length ; doWrite ( stream , state , false , len , chunk , encoding , cb ) ; entry = entry . next ; state . bufferedRequestCount -- ; if ( state . writing ) { break ; } } if ( entry === null ) state . lastBufferedRequest = null ; } state . bufferedRequest = entry ; state . bufferProcessing = false ; }
2460	function Node ( val , type , parent ) { if ( typeof type !== 'string' ) { parent = type ; type = null ; } define ( this , 'parent' , parent ) ; define ( this , 'isNode' , true ) ; define ( this , 'expect' , null ) ; if ( typeof type !== 'string' && isObject ( val ) ) { lazyKeys ( ) ; var keys = Object . keys ( val ) ; for ( var i = 0 ; i < keys . length ; i ++ ) { var key = keys [ i ] ; if ( ownNames . indexOf ( key ) === - 1 ) { this [ key ] = val [ key ] ; } } } else { this . type = type ; this . val = val ; } }
2461	function append ( compiler , val , node ) { if ( typeof compiler . append !== 'function' ) { return compiler . emit ( val , node ) ; } return compiler . append ( val , node ) ; }
2462	function Snapdragon ( options ) { Base . call ( this , null , options ) ; this . options = utils . extend ( { source : 'string' } , this . options ) ; this . compiler = new Compiler ( this . options ) ; this . parser = new Parser ( this . options ) ; Object . defineProperty ( this , 'compilers' , { get : function ( ) { return this . compiler . compilers ; } } ) ; Object . defineProperty ( this , 'parsers' , { get : function ( ) { return this . parser . parsers ; } } ) ; Object . defineProperty ( this , 'regex' , { get : function ( ) { return this . parser . regex ; } } ) ; }
2463	function ( msg , node ) { var pos = node . position || { start : { column : 0 } } ; var message = this . options . source + ' column:' + pos . start . column + ': ' + msg ; var err = new Error ( message ) ; err . reason = msg ; err . column = pos . start . column ; err . source = this . pattern ; if ( this . options . silent ) { this . errors . push ( err ) ; } else { throw err ; } }
2464	function ( node , nodes , i ) { var fn = this . compilers [ node . type ] ; this . idx = i ; if ( typeof fn !== 'function' ) { throw this . error ( 'compiler "' + node . type + '" is not registered' , node ) ; } return fn . call ( this , node , nodes , i ) ; }
2465	function ( ast , options ) { var opts = utils . extend ( { } , this . options , options ) ; this . ast = ast ; this . parsingErrors = this . ast . errors ; this . output = '' ; if ( opts . sourcemap ) { var sourcemaps = require ( './source-maps' ) ; sourcemaps ( this ) ; this . mapVisit ( this . ast . nodes ) ; this . applySourceMaps ( ) ; this . map = opts . sourcemap === 'generator' ? this . map : this . map . toJSON ( ) ; return this ; } this . mapVisit ( this . ast . nodes ) ; return this ; }
2466	function Parser ( options ) { debug ( 'initializing' , __filename ) ; this . options = utils . extend ( { source : 'string' } , options ) ; this . init ( this . options ) ; use ( this ) ; }
2467	function ( type , fn ) { if ( this . types . indexOf ( type ) === - 1 ) { this . types . push ( type ) ; } this . parsers [ type ] = fn . bind ( this ) ; return this ; }
2468	function ( type , token ) { this . sets [ type ] = this . sets [ type ] || [ ] ; this . count ++ ; this . stack . push ( token ) ; return this . sets [ type ] . push ( token ) ; }
2469	function ( type ) { this . sets [ type ] = this . sets [ type ] || [ ] ; this . count -- ; this . stack . pop ( ) ; return this . sets [ type ] . pop ( ) ; }
2470	function ( n ) { return this . stack . length > 0 ? utils . last ( this . stack , n ) : utils . last ( this . nodes , n ) ; }
2471	function ( str , len ) { var lines = str . match ( / \n / g ) ; if ( lines ) this . line += lines . length ; var i = str . lastIndexOf ( '\n' ) ; \n this . column = ~ i ? len - i : this . column + len ; this . parsed += str ; }
2472	function ( type , openRegex , closeRegex , fn ) { this . sets [ type ] = this . sets [ type ] || [ ] ; this . set ( type + '.open' , function ( ) { var parsed = this . parsed ; var pos = this . position ( ) ; var m = this . match ( openRegex ) ; if ( ! m || ! m [ 0 ] ) return ; var val = m [ 0 ] ; this . setCount ++ ; this . specialChars = true ; var open = pos ( { type : type + '.open' , val : val , rest : this . input } ) ; if ( typeof m [ 1 ] !== 'undefined' ) { open . inner = m [ 1 ] ; } var prev = this . prev ( ) ; var node = pos ( { type : type , nodes : [ open ] } ) ; define ( node , 'rest' , this . input ) ; define ( node , 'parsed' , parsed ) ; define ( node , 'prefix' , m [ 1 ] ) ; define ( node , 'parent' , prev ) ; define ( open , 'parent' , node ) ; if ( typeof fn === 'function' ) { fn . call ( this , open , node ) ; } this . push ( type , node ) ; prev . nodes . push ( node ) ; } ) ; this . set ( type + '.close' , function ( ) { var pos = this . position ( ) ; var m = this . match ( closeRegex ) ; if ( ! m || ! m [ 0 ] ) return ; var parent = this . pop ( type ) ; var node = pos ( { type : type + '.close' , rest : this . input , suffix : m [ 1 ] , val : m [ 0 ] } ) ; if ( ! this . isType ( parent , type ) ) { if ( this . options . strict ) { throw new Error ( 'missing opening "' + type + '"' ) ; } this . setCount -- ; node . escaped = true ; return node ; } if ( node . suffix === '\\' ) \\ { parent . escaped = true ; node . escaped = true ; } parent . nodes . push ( node ) ; } ) ; define ( node , 'parent' , parent ) ; }
2473	function ( ) { var pos = this . position ( ) ; if ( this . input ) return ; var prev = this . prev ( ) ; while ( prev . type !== 'root' && ! prev . visited ) { if ( this . options . strict === true ) { throw new SyntaxError ( 'invalid syntax:' + util . inspect ( prev , null , 2 ) ) ; } if ( ! hasDelims ( prev ) ) { prev . parent . escaped = true ; prev . escaped = true ; } visit ( prev , function ( node ) { if ( ! hasDelims ( node . parent ) ) { node . parent . escaped = true ; node . escaped = true ; } } ) ; prev = prev . parent ; } var tok = pos ( { type : 'eos' , val : this . append || '' } ) ; define ( tok , 'parent' , this . ast ) ; return tok ; }
2474	function ( ) { var parsed = this . parsed ; var len = this . types . length ; var idx = - 1 ; var tok ; while ( ++ idx < len ) { if ( ( tok = this . parsers [ this . types [ idx ] ] . call ( this ) ) ) { define ( tok , 'rest' , this . input ) ; define ( tok , 'parsed' , parsed ) ; this . last = tok ; return tok ; } } }
2475	function ( input ) { if ( typeof input !== 'string' ) { throw new TypeError ( 'expected a string' ) ; } this . init ( this . options ) ; this . orig = input ; this . input = input ; var self = this ; function parse ( ) { input = self . input ; var node = self . next ( ) ; if ( node ) { var prev = self . prev ( ) ; if ( prev ) { define ( node , 'parent' , prev ) ; if ( prev . nodes ) { prev . nodes . push ( node ) ; } } if ( self . sets . hasOwnProperty ( prev . type ) ) { self . currentType = prev . type ; } } if ( self . input && input === self . input ) { throw new Error ( 'no parsers registered for: "' + self . input . slice ( 0 , 5 ) + '"' ) ; } } while ( this . input ) parse ( ) ; if ( this . stack . length && this . options . strict ) { var node = this . stack . pop ( ) ; throw this . error ( 'missing opening ' + node . type + ': "' + this . orig + '"' ) ; } var eos = this . eos ( ) ; var tok = this . prev ( ) ; if ( tok . type !== 'eos' ) { this . ast . nodes . push ( eos ) ; } return this . ast ; }
2476	function mixin ( compiler ) { define ( compiler , '_comment' , compiler . comment ) ; compiler . map = new utils . SourceMap . SourceMapGenerator ( ) ; compiler . position = { line : 1 , column : 1 } ; compiler . content = { } ; compiler . files = { } ; for ( var key in exports ) { define ( compiler , key , exports [ key ] ) ; } }
2477	function utf8End ( buf ) { var r = buf && buf . length ? this . write ( buf ) : '' ; if ( this . lastNeed ) return r + '\ufffd' ; \ufffd }
2478	function rangeToPattern ( start , stop , options ) { if ( start === stop ) { return { pattern : String ( start ) , digits : [ ] } ; } var zipped = zip ( String ( start ) , String ( stop ) ) ; var len = zipped . length , i = - 1 ; var pattern = '' ; var digits = 0 ; while ( ++ i < len ) { var numbers = zipped [ i ] ; var startDigit = numbers [ 0 ] ; var stopDigit = numbers [ 1 ] ; if ( startDigit === stopDigit ) { pattern += startDigit ; } else if ( startDigit !== '0' || stopDigit !== '9' ) { pattern += toCharacterClass ( startDigit , stopDigit ) ; } else { digits += 1 ; } } if ( digits ) { pattern += options . shorthand ? '\\d' : \\ ; } '[0-9]' }
2479	function use ( type , fn , options ) { var offset = 1 ; if ( typeof type === 'string' || Array . isArray ( type ) ) { fn = wrap ( type , fn ) ; offset ++ ; } else { options = fn ; fn = type ; } if ( typeof fn !== 'function' ) { throw new TypeError ( 'expected a function' ) ; } var self = this || app ; var fns = self [ prop ] ; var args = [ ] . slice . call ( arguments , offset ) ; args . unshift ( self ) ; if ( typeof opts . hook === 'function' ) { opts . hook . apply ( self , args ) ; } var val = fn . apply ( self , args ) ; if ( typeof val === 'function' && fns . indexOf ( val ) === - 1 ) { fns . push ( val ) ; } return self ; }
2480	function wrap ( type , fn ) { return function plugin ( ) { return this . type === type ? fn . apply ( this , arguments ) : plugin ; } ; }
2481	function memoize ( fun ) { const cache = { } ; if ( fun . length === 1 ) { return ( arg ) => { if ( arg in cache ) { return cache [ arg ] ; } const result = fun ( arg ) ; cache [ arg ] = result ; return result ; } ; } return ( arg1 , arg2 ) => { if ( cache [ arg1 ] && arg2 in cache [ arg1 ] ) { return cache [ arg1 ] [ arg2 ] ; } const result = fun ( arg1 , arg2 ) ; if ( ! cache [ arg1 ] ) { cache [ arg1 ] = { } ; } cache [ arg1 ] [ arg2 ] = result ; return result ; } ; }
2482	function keyblade ( obj , opts ) { opts = Object . assign ( { message : _defaultMessage , logBeforeThrow : true , ignore : [ ] } , opts ) opts . ignore = ( opts . ignore && Array . isArray ( opts . ignore ) ) ? opts . ignore : [ ] return new Proxy ( obj , { get ( target , propKey , receiver ) { const useGetter = Reflect . has ( target , propKey , receiver ) || _isReserved ( propKey , opts . ignore ) if ( useGetter ) { return Reflect . get ( target , propKey , receiver ) } if ( typeof propKey === 'symbol' ) { return Reflect . get ( target , propKey , receiver ) } const message = opts . message ( propKey ) if ( opts . logBeforeThrow ) { if ( typeof opts . logBeforeThrow === 'function' ) { opts . logBeforeThrow ( message , propKey ) } else { console . error ( message ) } } throw new UndefinedKeyError ( message ) } } ) }
2483	function subRegister ( obj , name ) { var res ; res = isPrimitive ( obj [ name ] ) ? { } : obj [ name ] ; return obj [ name ] = mixable ( res ) . mixin ( proto , 'register' , 'extend' ) ; }
2484	function registerDir ( leaf , dir , name ) { var files ; try { files = fs . readdirSync ( dir ) ; } catch ( _error ) { } if ( files == null ) { return false ; } if ( name != null ) { leaf = subRegister ( leaf , name ) ; } for ( var i = 0 , len = files . length ; i < len ; i ++ ) { name = files [ i ] ; leaf . register ( dir , name ) ; } return true ; }
2485	function containerStatus ( original , status , parent ) { var state = { topology : { containers : { } } } ; var container = { id : original . id } ; if ( parent === null ) { } else if ( parent !== undefined ) { container . containedBy = parent ; } else { container . containedBy = original . containedBy ; } if ( typeof status === 'string' ) { switch ( status ) { case 'detached' : container . added = false ; container . started = false ; container . running = false ; break ; case 'added' : container . added = true ; break ; case 'started' : container . started = true ; break ; case 'running' : container . running = true ; break ; default : throw new Error ( 'unknown state' ) ; } } else { _ . forIn ( status , function ( value , key ) { container [ key ] = value ; } ) ; } if ( container . added === false ) { delete container . containedBy ; } state . topology . containers [ container . id ] = container ; return state ; }
2486	async function lstatFiles ( dirPath , dirContent ) { const readFiles = dirContent . map ( async ( relativePath ) => { const path = join ( dirPath , relativePath ) const ls = await makePromise ( lstat , path ) return { lstat : ls , path , relativePath , } } ) const res = await Promise . all ( readFiles ) return res }
2487	async function readDirStructure ( dirPath ) { if ( ! dirPath ) { throw new Error ( 'Please specify a path to the directory' ) } const ls = await makePromise ( lstat , dirPath ) if ( ! ls . isDirectory ( ) ) { const err = new Error ( 'Path is not a directory' ) err . code = 'ENOTDIR' throw err } const dir = ( await makePromise ( readdir , dirPath ) ) const lsr = await lstatFiles ( dirPath , dir ) const directories = lsr . filter ( isDirectory ) const notDirectories = lsr . filter ( isNotDirectory ) const files = notDirectories . reduce ( ( acc , current ) => { const type = getType ( current ) return { ... acc , [ current . relativePath ] : { type , } , } } , { } ) const dirs = await directories . reduce ( async ( acc , { path , relativePath } ) => { const res = await acc const structure = await readDirStructure ( path ) return { ... res , [ relativePath ] : structure , } } , { } ) const content = { ... files , ... dirs , } return { content , type : 'Directory' , } }
2488	function propertyNameToAttribute ( name ) { var result = name . replace ( / ([A-Z]) / g , function ( match , letter ) { return '-' + letter . toLowerCase ( ) ; } ) ; return 'data-' + result ; }
2489	function generateCommands ( origin , dest ) { var destCmds = _ . chain ( dest . topology . containers ) . values ( ) . filter ( function ( container ) { return container . containedBy === container . id || ! container . containedBy ; } ) . map ( function ( container ) { return { cmd : 'configure' , id : container . id } ; } ) . value ( ) ; var originCmds = _ . chain ( origin . topology . containers ) . values ( ) . map ( function ( container ) { if ( ! dest . topology . containers [ container . id ] ) { return { cmd : 'detach' , id : container . id } ; } return null ; } ) . filter ( function ( container ) { return container !== null ; } ) . value ( ) ; return destCmds . concat ( originCmds ) ; }
2490	function Limon ( input , options ) { if ( ! ( this instanceof Limon ) ) { return new Limon ( input , options ) } lazy . use ( this , { fn : function ( app , opts ) { app . options = lazy . utils . extend ( app . options , opts ) } } ) this . defaults ( input , options ) this . use ( lazy . plugin . prevNext ( ) ) }
2491	function planner ( origin , dest , opts ) { var tasks = new TaskPlanner ( ) ; var cmds = generateCommands ( origin , dest ) ; var state = _ . cloneDeep ( origin ) ; var result ; opts = xtend ( defaults , opts ) ; assert ( opts . mode === 'quick' || opts . mode === 'safe' , 'unknown mode' ) ; tasks . addTask ( { cmd : 'nop' } , { } ) ; generateDetachTasks ( tasks , origin , opts ) ; generateDetachTasks ( tasks , dest , opts ) ; generateConfigureTasks ( tasks , origin , dest , opts ) ; _ . forIn ( state . topology . containers , function ( container ) { container . running = true ; container . started = true ; container . added = true ; } ) ; _ . forIn ( dest . topology . containers , function ( container ) { var containers = state . topology . containers ; if ( ! containers [ container . id ] ) { containers [ container . id ] = { id : container . id , containedBy : container . containedBy , running : false , started : false , added : false } ; } } ) ; result = cmds . reduce ( function ( acc , cmd ) { var plan = tasks . plan ( state , cmd ) ; if ( ! plan ) { throw new Error ( 'unable to generate ' + cmd . cmd + ' for id ' + cmd . id ) ; } return acc . concat ( plan ) ; } , [ ] ) . filter ( function ( cmd ) { return cmd && cmd . cmd !== 'nop' ; } ) ; if ( ! opts . noLinkUnlinkRemove ) { result = linkFilter ( result ) ; } return result ; }
2492	function ( strip ) { if ( ! strip ) { console . log ( messagingTexts . noStrip ) ; } if ( ! ( strip instanceof pixel . Strip ) ) { console . log ( messagingTexts . wrongStrip ) ; } pattern . reset ( strip , interval ) ; interval = pattern . domino ( strip , 'white' ) ; }
2493	function ( strip ) { if ( ! strip ) { console . log ( messagingTexts . noStrip ) ; } if ( ! ( strip instanceof pixel . Strip ) ) { console . log ( messagingTexts . wrongStrip ) ; } pattern . reset ( strip , interval ) ; setTimeout ( function ( ) { pattern . flash ( strip , 'green' , 2 ) ; } , 10 ) ; }
2494	function create ( parent , baseUrl , params , callback ) { parent . getClient ( ) . post ( baseUrl , params , function ( err , definition , response ) { if ( err ) return callback ( err ) ; callback ( null , new this ( parent , definition ) ) ; } . bind ( this ) ) ; }
2495	function register ( type , lang , handler ) { if ( Array . isArray ( lang ) ) { lang . forEach ( ( v ) => store [ type ] . langs [ v ] = handler ) ; return ; } store [ type ] . langs [ lang ] = handler ; }
2496	function ( kind , promisesDfd ) { return function ( ) { var dfd = promisesDfd || this ; var fnSet = [ ] . slice . call ( arguments ) ; if ( kind === 'progress' || dfd . state === 'pending' ) { dfd [ kind + 's' ] . push ( fnSet ) ; } else { callSet . call ( dfd , fnSet , this [ kind + 'Args' ] ) ; } if ( promisesDfd ) { return dfd . promise ; } return dfd ; } ; }
2497	function ( set , args ) { if ( set . length < 1 ) { return ; } var apply = [ ] ; if ( set . length > 1 ) { for ( var i = 1 ; i < set . length ; i ++ ) { if ( set [ i ] instanceof Argument ) { apply [ i ] = args [ set [ i ] . num ] ; } else { apply [ i ] = set [ i ] ; } apply = apply . slice ( 1 ) ; } } else { apply = args ; } set [ 0 ] . apply ( this , apply ) ; }
2498	function ( kind , args ) { var bucket = this [ kind + 's' ] ; for ( var i = 0 ; i < bucket . length ; i ++ ) { callSet . call ( this , bucket [ i ] , args ) ; } }
2499	function ( ) { var dfd = this ; var promise = function ( ) { return promise ; } ; promise . done = stackNFire ( 'done' , dfd ) ; promise . fail = stackNFire ( 'fail' , dfd ) ; promise . progress = stackNFire ( 'progress' , dfd ) ; promise . state = dfd . state ; return promise ; }
2500	function ( kind ) { return function ( ) { if ( this . state === 'pending' ) { if ( kind !== 'progress' ) { this [ kind + 'Args' ] = arguments ; this . state = this . promise . state = kind ; } callSets . call ( this , kind , arguments ) ; } return this ; } ; }
2501	function ( ) { this . dones = [ ] ; this . doneArgs = [ ] ; this . fails = [ ] ; this . failArgs = [ ] ; this . pendings = [ ] ; this . pendingArgs = [ ] ; this . state = 'pending' ; this . promise = iPromise . call ( this ) ; }
2502	function ( performer ) { var state = performer . state ; if ( state . allCount === 0 ) { var args = [ ] ; for ( var i = 0 ; i < performer . args . length ; i ++ ) { args = args . concat ( [ ] . concat ( performer . args [ i ] . args ) ) ; } if ( state . targetCount === 0 ) { performer . _dfd . resolve . apply ( performer . _dfd , args ) ; } else { performer . _dfd . reject . apply ( performer . _dfd , args ) ; } } }
2503	function ( schema ) { this . _decoders = decoders ; this . _encoders = encoders ; this . _schemas = { } ; if ( Object . keys ( schema ) . join ( ',' ) !== 'name,fields' ) { schema = { name : '_auto-' + new Date ( ) . getTime ( ) , fields : schema } ; } this . _schema = schema ; this . _fieldIndex = Object . keys ( schema . fields ) ; this . _schemas [ schema . name ] = schema ; }
2504	function ( selector , properties , value ) { let rule = postcss . rule ( { selector : selector } ) let decls = _ . map ( properties , function ( property ) { return postcss . decl ( { prop : property , value : value } ) } ) rule . append ( decls ) return rule }
2505	function ( breakpoints , spacingScale ) { return _ . map ( breakpoints , function ( breakpointValue , breakpointKey ) { let mediaQuery = postcss . atRule ( { name : 'media' , params : breakpointValue , } ) let rules = _ . flatMap ( spacingScale , function ( scaleValue , scaleKey ) { return _ . map ( helpers , function ( helperValues , helperKey ) { return makeFunctionalRule ( ` ${ breakpointKey } ${ helperKey } ${ scaleKey } ` , helperValues , scaleValue ) } ) } ) return mediaQuery . append ( rules ) } ) }
2506	function destroy ( callback ) { this . getClient ( ) . destroy ( this . definition . _links . self . href , function ( err , definition , response ) { if ( err ) return callback ( err ) ; callback ( ) ; } . bind ( this ) ) ; }
2507	function load_config ( ) { let config = { } ; if ( fs . existsSync ( pgrunner_config_file ) ) { config = JSON . parse ( fs . readFileSync ( pgrunner_config_file , { 'encoding' : 'utf8' } ) ) ; if ( argv . v ) { debug . log ( 'Loaded from ' , pgrunner_config_file ) ; } } if ( ! is . array ( config . servers ) ) { config . servers = [ ] ; } return config ; }
2508	function save_config ( config ) { fs . writeFileSync ( pgrunner_config_file , JSON . stringify ( config , null , 2 ) , { 'encoding' : 'utf8' } ) ; if ( argv . v ) { debug . log ( 'Saved to ' , pgrunner_config_file ) ; } }
2509	function get_server_opts ( opts ) { debug . assert ( opts ) . is ( 'object' ) ; debug . assert ( opts . settings ) . is ( 'object' ) ; return { 'dbconfig' : opts . dbconfig , 'host' : opts . settings . host , 'port' : opts . settings . port , 'user' : opts . settings . user , 'database' : opts . settings . database } ; }
2510	function getResources ( domains ) { return store . getResources ( ) . then ( rsrcs => { return rsrcs . filter ( e => domains . includes ( e . domain ) ) ; } ) ; }
2511	function urlFormat ( obj ) { if ( isString ( obj ) ) { obj = urlParse ( obj ) ; } else if ( ! isObject ( obj ) || isNull ( obj ) ) { throw new TypeError ( 'Parameter "urlObj" must be an object, not ' + isNull ( obj ) ? 'null' : typeof obj ) ; } else if ( ! ( obj instanceof Url ) ) { return Url . prototype . format . call ( obj ) ; } else { return obj . format ( ) ; } }
2512	function rayLineVsCircle ( ray , circle ) { var rayLine = new Line2 ( ray . start . x , ray . start . y , ray . end . x , ray . end . y ) ; return rayLine . intersectCircle ( circle . position , circle . radius ) ; }
2513	function scopeUrl ( options , inst ) { options = _ . extend ( _ . clone ( options || { } ) , inst ) if ( typeof options !== 'object' && ( ! options . tournament_id || ! options . flight_id ) ) throw new Error ( 'tournament_id or flight_id required to make tibreak preference api calls' ) var url = '' if ( options . tournament_id ) { url += ngin . Tournament . urlRoot ( ) + '/' + options . tournament_id } else if ( options . flight_id ) { url += ngin . Flight . urlRoot ( ) + '/' + options . flight_id } return url + TiebreakPreference . urlRoot ( ) }
2514	function ( options , callback ) { var url = scopeUrl ( options , this ) return Super . fetch . call ( this , url , options , callback ) }
2515	function ( module , debug ) { this . debug = debug || false ; this . jsonrpc = "2.0" ; this . methods = module ; if ( handy . getType ( module ) == 'string' ) { this . methods = require ( module ) ; } if ( this . debug ) { logger . debug ( 'Loaded with methods:' + _ . functions ( this . methods ) ) ; } }
2516	function _getParamNames ( func ) { var funStr = func . toString ( ) ; return funStr . slice ( funStr . indexOf ( '(' ) + 1 , funStr . indexOf ( ')' ) ) . match ( / ([^\s,]+) / g ) ; }
2517	function _getChangedProperties ( ) { var retVal = { } , key ; for ( key in this . _changed ) { retVal [ key ] = this . _changed [ key ] ; } return retVal ; }
2518	function update ( properties , callback ) { if ( typeof properties == 'function' ) { callback = properties ; properties = { } ; } var key , changed ; var exceptions = [ 'addresses_update_action' , 'emails_update_action' , 'phone_numbers_update_action' ] ; for ( key in properties ) { if ( 'set' + inflection . camelize ( key ) in this ) { this [ 'set' + inflection . camelize ( key ) ] ( properties [ key ] ) ; } else if ( exceptions . indexOf ( key ) != - 1 ) { this . _changed [ key ] = properties [ key ] ; } } changed = this . _getChangedProperties ( ) ; this . getClient ( ) . patch ( this . definition . _links . self . href , changed , function ( err , definition , response ) { if ( err ) return callback ( err ) ; this . definition = definition ; this . _setup ( ) ; callback ( null , this ) ; } . bind ( this ) ) ; }
2519	function byClass ( c ) { c = classnames ( c ) if ( / ^\. / . test ( c ) ) { throw new Error ( 'No need to "." on start' ) } return bySelector ( ` ${ c } ` ) }
2520	function subtemplate ( template , data ) { try { return new JSDOC . JsPlate ( publish . conf . templatesDir + template ) . process ( data ) ; } catch ( e ) { print ( e . message ) ; quit ( ) ; } }
2521	function makeSignature ( params ) { if ( ! params ) return "()" ; var signature = "(" + params . filter ( function ( $ ) { return ! / \w+\.\w+ / . test ( $ . name ) ; } ) . map ( function ( $ ) { var name = $ . isOptional ? '[' + $ . name + ']' : $ . name ; return name ; } ) . join ( ", " ) + ")" ; return signature ; }
2522	function approach ( index , x , onAxis ) { while ( 0 <= x && x <= 1 ) { candidateHSVA [ index ] = x ; WebInspector . Color . hsva2rgba ( candidateHSVA , candidateRGBA ) ; WebInspector . Color . blendColors ( candidateRGBA , bgRGBA , blendedRGBA ) ; var fgLuminance = WebInspector . Color . luminance ( blendedRGBA ) ; var dLuminance = fgLuminance - desiredLuminance ; if ( Math . abs ( dLuminance ) < ( onAxis ? epsilon / 10 : epsilon ) ) return x ; else x += ( index === V ? - dLuminance : dLuminance ) ; } return null ; }
2523	function updateNodeColor ( data ) { d3 . selectAll ( '.node' ) . select ( '.node-symbol' ) . style ( 'fill' , d => d3scale . scaleFunction ( data . scale ) ( d [ data . column . key ] ) ) ; }
2524	function mainControlBox ( ) { d3 . select ( '#show-struct' ) . on ( 'change' , function ( ) { const data = nodeContentInput ( ) ; d3 . select ( '#main-control' ) . datum ( data ) ; updateNodeStructure ( data ) ; } ) . dispatch ( 'change' ) ; }
2525	function centerGraph ( newScale , duration , delay ) { if ( typeof delay === 'function' ) { delay = delay . call ( this ) ; } delay = typeof delay === 'number' ? delay : 0 ; setTimeout ( function ( ) { if ( typeof newScale === 'function' ) { newScale = newScale . call ( this ) ; } if ( typeof duration === 'function' ) { duration = duration . call ( this ) ; } newScale = typeof newScale === 'number' ? newScale : zoom . scale ( ) ; duration = typeof duration === 'number' ? duration : 200 ; if ( typeof newScale !== 'number' ) { throw new TypeError ( "centerGraph error: 'newScale' is not a 'number'." ) ; } if ( typeof duration !== 'number' ) { throw new TypeError ( "centerGraph error: 'duration' is not a 'number'." ) ; } var bounds = graph . node ( ) . getBBox ( ) ; var centerSVGX = ( graphWidth * newScale / 2 ) ; var centerSVGY = ( graphHeight * newScale / 2 ) ; var centerGraphX = ( bounds . x * newScale ) + ( bounds . width * newScale / 2 ) ; var centerGraphY = ( bounds . y * newScale ) + ( bounds . height * newScale / 2 ) ; var centerTranslate = [ ( graphWidth / 2 ) - centerSVGX + ( centerSVGX - centerGraphX ) , ( graphHeight / 2 ) - centerSVGY + ( centerSVGY - centerGraphY ) ] ; zoom . translate ( centerTranslate ) . scale ( newScale ) ; graph . transition ( ) . duration ( duration ) . attr ( 'transform' , 'translate(' + zoom . translate ( ) + ')' + ' scale(' + zoom . scale ( ) + ')' ) ; hideNodeContextMenu ( ) ; } , delay ) ; }
2526	function detectAllNodesFixed ( ) { if ( data ) { var currentNodesFixed = data . allNodesFixed ; var allNodesFixed = true ; data . nodes . forEach ( function ( node ) { if ( ! node . fixed ) { allNodesFixed = false ; } } ) ; data . allNodesFixed = allNodesFixed ; if ( currentNodesFixed !== allNodesFixed ) { updateMenuUI ( ) ; } } }
2527	function fadeRelatedNodes ( targetNode , selected , nodes , links ) { var opacity = selected ? 0.1 : 1 ; var elm = findElementByNode ( 'circle' , targetNode ) ; elm . classed ( 'selected' , opacity < 1 ) ; $ ( 'path.link' ) . removeAttr ( 'data-show' ) ; nodes . style ( 'stroke-opacity' , function ( otherNode ) { var thisOpacity = isConnected ( targetNode , otherNode ) ? 1 : opacity ; this . setAttribute ( 'fill-opacity' , thisOpacity ) ; this . setAttribute ( 'stroke-opacity' , thisOpacity ) ; this . classList [ thisOpacity === 1 ? 'remove' : 'add' ] ( 'dimmed' ) ; return thisOpacity ; } ) ; links . style ( 'stroke-opacity' , function ( otherNode ) { if ( otherNode . source === targetNode ) { var elmNodes = graph . selectAll ( '.' + formatClassName ( 'node' , otherNode . target ) ) ; elmNodes . attr ( 'fill-opacity' , 1 ) ; elmNodes . attr ( 'stroke-opacity' , 1 ) ; elmNodes . classed ( 'dimmed' , false ) ; var elmCurrentLink = $ ( 'path.link[data-source=' + otherNode . source . index + ']' ) ; elmCurrentLink . attr ( 'data-show' , true ) ; elmCurrentLink . attr ( 'marker-end' , 'url(#regular)' ) ; return 1 ; } else { return opacity ; } } ) ; var elmAllLinks = $ ( 'path.link:not([data-show])' ) ; elmAllLinks . attr ( 'marker-end' , opacity === 1 ? 'url(#regular)' : '' ) ; }
2528	function findElementByNode ( prefix , node ) { var selector = '.' + formatClassName ( prefix , node ) ; return graph . select ( selector ) ; }
2529	function getElementCoords ( element ) { var ctm = element . getCTM ( ) ; return { x : ctm . e + element . getAttribute ( 'cx' ) * ctm . a , y : ctm . f + element . getAttribute ( 'cy' ) * ctm . d } ; }
2530	function getSVG ( elementType ) { var returnVal ; var svgElement ; var cached ; switch ( elementType ) { case 'circle' : case 'g' : case 'path' : case 'text' : returnVal = function ( data ) { svgElement = svgElementMap [ elementType ] . pop ( ) ; cached = svgElement != null ; svgElement = svgElement != null ? svgElement : document . createElementNS ( 'http://www.w3.org/2000/svg' , elementType ) ; if ( typeof data === 'object' ) { for ( var key in data ) { svgElement . setAttribute ( key , data [ key ] ) ; } } return svgElement ; } ; break ; default : throw new TypeError ( 'getSVG error: unknown elementType.' ) ; } return returnVal ; }
2531	function hideNodeContextMenu ( event ) { if ( typeof selectedContextNode === 'undefined' ) { return ; } var contextMenuButton = $ ( '#context-menu' ) ; var popupmenu = $ ( '#contextpopup .mdl-menu__container' ) ; if ( event ) { event . preventDefault ( ) ; if ( ! $ ( event . target ) . parents ( '#contextpopup' ) . length > 0 ) { if ( popupmenu . hasClass ( 'is-visible' ) ) { contextMenuButton . click ( ) ; } fadeRelatedNodes ( selectedContextNode , false , nodes , links ) ; selectedContextNode = undefined ; } } else { if ( popupmenu . hasClass ( 'is-visible' ) ) { contextMenuButton . click ( ) ; } fadeRelatedNodes ( selectedContextNode , false , nodes , links ) ; selectedContextNode = undefined ; } }
2532	function isConnected ( targetNode , otherNode ) { return targetNode . index === otherNode . index || linkedByIndex [ targetNode . index + ',' + otherNode . index ] ; }
2533	function onControlDepsClicked ( ) { if ( this . value === appOptions . currentScope ) { return ; } if ( appOptions . maxDepthSticky && appOptions . currentLevel === dataPackageMap [ appOptions . currentScope ] . maxLevel ) { appOptions . currentLevel = dataPackageMap [ this . value ] . maxLevel } appOptions . currentScope = this . value ; var maxLevel = dataPackageMap [ appOptions . currentScope ] . maxLevel ; if ( appOptions . currentLevel > maxLevel ) { appOptions . currentLevel = maxLevel ; } $ ( '.control-level input' ) . attr ( { max : maxLevel } ) ; $ ( '.control-level input' ) . val ( appOptions . currentLevel ) ; $ ( '.control-level label' ) . html ( appOptions . currentLevel ) ; updateAll ( { redrawOnly : true } ) ; centerGraph ( zoomFit , 1000 , data . allNodesFixed ? 0 : 2000 ) ; }
2534	function onControlLevelChanged ( ) { appOptions . currentLevel = parseInt ( this . value ) ; $ ( '.control-level input' ) . val ( appOptions . currentLevel ) ; $ ( '.control-level label' ) . html ( appOptions . currentLevel ) ; updateAll ( { redrawOnly : true } ) ; centerGraph ( zoomFit , 1000 , data . allNodesFixed ? 0 : 2000 ) ; }
2535	function onControlMenuClicked ( ) { switch ( $ ( this ) . data ( 'action' ) ) { case 'toggleFreezeAllNodes' : setNodesFixed ( ! data . allNodesFixed ) ; break ; case 'showFullNames' : appOptions . showFullNames = ! appOptions . showFullNames ; updateAll ( { redrawOnly : true } ) ; break ; case 'showTableView' : appOptions . showTableView = ! appOptions . showTableView ; $ ( '.control-table' ) . toggleClass ( 'hidden' , ! appOptions . showTableView ) ; updateTableUIExtent ( ) ; break ; case 'maxDepthSticky' : appOptions . maxDepthSticky = ! appOptions . maxDepthSticky ; break ; } setTimeout ( updateMenuUI , 200 ) ; }
2536	function onControlTableRowContextClick ( node , event ) { event . preventDefault ( ) ; onNodeContextClick ( node , { x : event . pageX , y : event . pageY } ) ; }
2537	function onControlTableRowMouseOver ( nodes , links , node , enter ) { if ( node !== selectedContextNode ) { hideNodeContextMenu ( event ) ; } onNodeMouseOverOut ( nodes , links , enter , node ) ; }
2538	function onControlZoomClicked ( ) { var newScale = 1 ; var scalePercentile = 0.20 ; switch ( $ ( this ) . data ( 'action' ) ) { case 'zoom_in' : newScale = Math . max ( Math . min ( zoom . scale ( ) * ( 1 + scalePercentile ) , maxScaleExtent ) , minScaleExtent ) ; break ; case 'zoom_out' : newScale = Math . max ( zoom . scale ( ) * ( 1 - scalePercentile ) , minScaleExtent ) ; break ; case 'zoom_all_out' : newScale = zoomFit ( ) ; break ; } centerGraph ( newScale ) ; }
2539	function onNodeContextMenuClick ( ) { hideNodeContextMenu ( ) ; console . log ( '!! action: ' + $ ( this ) . data ( 'action' ) + '; link: ' + $ ( this ) . data ( 'link' ) ) ; switch ( $ ( this ) . data ( 'action' ) ) { case 'openLink' : var link = $ ( this ) . data ( 'link' ) ; if ( typeof link === 'string' ) { window . open ( link , '_blank' , 'location=yes,menubar=yes,scrollbars=yes,status=yes' ) ; } break ; } }
2540	function onNodeContextClick ( targetNode , coords ) { hideNodeContextMenu ( ) ; if ( typeof coords !== 'object' ) { coords = getElementCoords ( this ) ; } var popupmenu = $ ( '#contextpopup .mdl-menu__container' ) ; var packageData = targetNode . packageData ; var packageLink , packageType , scmLink , scmType ; if ( packageData ) { if ( packageData . packageLink ) { packageLink = packageData . packageLink . link ; packageType = packageData . packageLink . type ; switch ( packageType ) { case 'npm' : packageType = 'NPM' ; break ; } } if ( packageData . scmLink ) { scmLink = packageData . scmLink . link ; scmType = packageData . scmLink . type ; switch ( scmType ) { case 'github' : scmType = 'Github' ; break ; } } } popupmenu . find ( 'li' ) . each ( function ( index ) { var liTarget = $ ( this ) ; switch ( index ) { case 0 : if ( scmLink && scmType ) { liTarget . text ( 'Open on ' + scmType ) ; liTarget . data ( 'link' , scmLink ) ; liTarget . removeClass ( 'hidden' ) ; } else { liTarget . addClass ( 'hidden' ) ; } break ; case 1 : if ( packageLink && packageType ) { liTarget . text ( 'Open on ' + packageType ) ; liTarget . data ( 'link' , packageLink ) ; liTarget . removeClass ( 'hidden' ) ; } else { liTarget . addClass ( 'hidden' ) ; } break ; case 2 : if ( packageData && packageData . version ) { liTarget . text ( 'Version: ' + packageData . version ) ; liTarget . removeClass ( 'hidden' ) ; } else { liTarget . addClass ( 'hidden' ) ; } break ; } } ) ; setTimeout ( function ( ) { selectedContextNode = targetNode ; fadeRelatedNodes ( selectedContextNode , true , nodes , links ) ; var contextMenuButton = $ ( "#context-menu" ) ; contextMenuButton . click ( ) ; setTimeout ( function ( ) { popupmenu . parent ( ) . css ( { position : 'relative' } ) ; popupmenu . css ( { left : coords . x , top : coords . y , position : 'absolute' } ) ; } , 0 ) ; } , 100 ) ; }
2541	function onNodeMouseDown ( nodes , links , targetNode ) { hideNodeContextMenu ( ) ; if ( d3 . event . button === 0 ) { selectedDragNode = targetNode ; fadeRelatedNodes ( targetNode , true , nodes , links ) ; } else { d3 . event . stopPropagation ( ) ; } }
2542	function onNodeMouseOverOut ( nodes , links , enter , targetNode ) { if ( isNodeSelected ( ) ) { return ; } fadeRelatedNodes ( targetNode , enter , nodes , links ) ; }
2543	function onResize ( ) { graphWidth = window . innerWidth ; graphHeight = window . innerHeight ; graph . attr ( 'width' , graphWidth ) . attr ( 'height' , graphHeight ) ; layout . size ( [ graphWidth , graphHeight ] ) . resume ( ) ; updateMenuUI ( ) ; updateTableUIExtent ( ) ; hideNodeContextMenu ( ) ; centerGraph ( zoomFit , 1000 , data . allNodesFixed ? 0 : 2000 ) ; }
2544	function onTick ( ) { nodes . attr ( 'cx' , function ( node ) { return node . x ; } ) . attr ( 'cy' , function ( node ) { return node . y ; } ) . attr ( 'transform' , function ( node ) { return 'translate(' + node . x + ',' + node . y + ')' ; } ) ; links . attr ( 'd' , function ( link ) { var sourceX = data . nodes [ link . source . index ] . x ; var sourceY = data . nodes [ link . source . index ] . y ; var targetX = data . nodes [ link . target . index ] . x ; var targetY = data . nodes [ link . target . index ] . y ; var dx = targetX - sourceX , dy = targetY - sourceY , dr = Math . sqrt ( dx * dx + dy * dy ) ; return 'M' + sourceX + ',' + sourceY + 'A' + dr + ',' + dr + ' 0 0,1 ' + targetX + ',' + targetY ; } ) ; }
2545	function recycleGraph ( ) { var childNodes = graph . selectAll ( 'g > *' ) . remove ( ) ; if ( ! Array . isArray ( childNodes ) && ! Array . isArray ( childNodes [ '0' ] ) ) { return ; } childNodes = childNodes [ '0' ] ; for ( var cntr = 0 ; cntr < childNodes . length ; cntr ++ ) { var childNode = childNodes [ cntr ] ; if ( childNode instanceof SVGPathElement ) { svgElementMap [ 'path' ] . push ( childNode ) ; } else if ( childNode instanceof SVGCircleElement ) { svgElementMap [ 'circle' ] . push ( childNode ) ; } else if ( childNode instanceof SVGTextElement ) { svgElementMap [ 'text' ] . push ( childNode ) ; } else if ( childNode instanceof SVGGElement ) { childNode . removeAttribute ( 'transform' ) ; svgElementMap [ 'g' ] . push ( childNode ) ; } } }
2546	function reverseGraphLinks ( ) { for ( var key in dataPackageMap ) { var graphData = dataPackageMap [ key ] ; graphData . links . forEach ( function ( link ) { var linkSource = link . source ; link . source = link . target ; link . target = linkSource ; } ) ; } }
2547	function updateMenuUI ( ) { if ( data ) { $ ( '.control-menu li[data-action=toggleFreezeAllNodes]' ) . html ( data . allNodesFixed ? 'Unfreeze nodes' : 'Freeze nodes' ) ; } appMenuToggleOptions . forEach ( function ( key ) { var icon = appOptions [ key ] ? 'check_box' : 'check_box_outline_blank' ; $ ( '.control-menu li[data-action=' + key + '] i' ) . html ( icon ) ; } ) ; }
2548	function updateTableUI ( ) { var table = $ ( '.control-table tbody' ) ; table . off ( 'mouseenter' , 'tr' , onControlTableRowMouseOver ) ; table . off ( 'mouseleave' , 'tr' , onControlTableRowMouseOver ) ; table . off ( 'contextmenu' , 'tr' , onControlTableRowContextClick ) ; table . empty ( ) ; if ( data ) { data . nodes . forEach ( function ( node ) { var nd = node . packageData ; var name = appOptions . showFullNames ? nd . actualPackageName : nd . packageName ; var isAliased = nd . isAlias ? ' isAliased' : '' ; var tr = $ ( '<tr>' + '<td class="mdl-data-table__cell--non-numeric' + isAliased + '">' + name + '</td>' + '<td class="mdl-data-table__cell--non-numeric">' + nd . jspmType + '</td>' + '<td class="mdl-data-table__cell--non-numeric">' + nd . version + '</td>' + '<td class="mdl-data-table__cell--non-numeric">' + node . minLevel + '</td>' + '</tr>' ) ; table . append ( tr ) ; tr . on ( 'mouseenter' , onControlTableRowMouseOver . bind ( this , nodes , links , node , true ) ) ; tr . on ( 'mouseleave' , onControlTableRowMouseOver . bind ( this , nodes , links , node , false ) ) ; tr . on ( 'contextmenu' , onControlTableRowContextClick . bind ( this , node ) ) ; } ) ; $ ( '#nodeTable th' ) . removeClass ( 'headerSortDown' ) ; $ ( '#nodeTable th' ) . removeClass ( 'headerSortUp' ) ; $ ( '#nodeTable' ) . trigger ( 'update' ) ; updateTableUIExtent ( ) ; } }
2549	function updateTableUIExtent ( ) { var tableDiv = $ ( '.control-table-inner' ) ; var nodeTable = $ ( '#nodeTable' ) ; var tableHeight = nodeTable . height ( ) ; var offset = tableDiv . offset ( ) ; var maxTableHeight = window . innerHeight - offset . top - 20 ; tableDiv . css ( 'max-height' , maxTableHeight ) ; nodeTable . css ( 'margin-right' , tableHeight > maxTableHeight ? '10px' : '0px' ) ; }
2550	function zoomFit ( ) { var bounds = graph . node ( ) . getBBox ( ) ; var parent = graph . node ( ) . parentElement ; var fullWidth = parent . clientWidth , fullHeight = parent . clientHeight ; var width = bounds . width , height = bounds . height ; if ( width === 0 || height === 0 ) { return 1 ; } var scale = 0.75 / Math . max ( width / fullWidth , height / fullHeight ) ; scale = Math . max ( Math . min ( scale , maxScaleExtent ) , minScaleExtent ) ; return scale ; }
2551	function getWindowWidth ( ) { if ( window . innerWidth ) { return window . innerWidth ; } else if ( document . documentElement . clientWidth ) { return document . documentElement . clientWidth ; } else if ( document . body . clientWidth ) { return document . body . clientWidth ; } else { return 0 ; } }
2552	function ( cssScreen , cssHandheld , mobileMaxWidth ) { if ( typeof ( cssScreen ) != "undefined" ) { config . cssScreen = cssScreen ; } if ( typeof ( cssHandheld ) != "undefined" ) { config . cssHandheld = cssHandheld ; } if ( typeof ( mobileMaxWidth ) != "undefined" ) { config . mobileMaxWidth = mobileMaxWidth ; } var cssloadCheckNode = document . createElement ( 'div' ) ; cssloadCheckNode . className = config . testDivClass ; document . getElementsByTagName ( "body" ) [ 0 ] . appendChild ( cssloadCheckNode ) ; if ( cssloadCheckNode . offsetWidth != 100 && noMediaQuery == false ) { noMediaQuery = true ; } cssloadCheckNode . parentNode . removeChild ( cssloadCheckNode ) if ( noMediaQuery == true ) { var cssHref = "" ; if ( getWindowWidth ( ) <= config . mobileMaxWidth ) { cssHref = config . cssHandheld ; newCssMediaType = "handheld" ; } else { cssHref = config . cssScreen ; newCssMediaType = "screen" ; } if ( cssHref != "" && currentCssMediaType != newCssMediaType ) { var currentCssLinks = document . styleSheets for ( var i = 0 ; i < currentCssLinks . length ; i ++ ) { for ( var ii = 0 ; ii < currentCssLinks [ i ] . media . length ; ii ++ ) { if ( typeof ( currentCssLinks [ i ] . media ) == "object" ) { if ( currentCssLinks [ i ] . media . item ( ii ) == "fallback" ) { currentCssLinks [ i ] . ownerNode . parentNode . removeChild ( currentCssLinks [ i ] . ownerNode ) i -- break ; } } else { if ( currentCssLinks [ i ] . media . indexOf ( "fallback" ) >= 0 ) { currentCssLinks [ i ] . owningElement . parentNode . removeChild ( currentCssLinks [ i ] . owningElement ) i -- break ; } } } } if ( typeof ( cssHref ) == "object" ) { for ( var i = 0 ; i < cssHref . length ; i ++ ) { addCssLink ( cssHref [ i ] ) } } else { addCssLink ( cssHref ) } currentCssMediaType = newCssMediaType ; } addEvent ( window , wbos . CssTools . MediaQueryFallBack . LoadCssDelayed , 'onresize' ) } }
2553	function do_success ( req , res , msg ) { res . writeHead ( 200 , { 'Content-Type' : ( ( typeof msg === 'string' ) ? 'text/plain' : 'application/json' ) } ) ; msg = ( typeof msg === 'string' ) ? msg : helpers . stringify ( msg ) ; res . end ( msg ) ; }
2554	function do_failure ( req , res , opts ) { opts = opts || { } ; var obj = { 'type' : opts . type || 'error' , 'code' : opts . code || 501 , 'desc' : opts . desc || ( '' + opts ) } ; res . writeHead ( obj . code , { 'Content-Type' : 'application/json' } ) ; res . end ( helpers . stringify ( obj ) + '\n' ) ; }
2555	function do_create_req ( config , routes ) { routes = routes || { } ; var version = routes . version || { } ; if ( version && ( typeof version === 'object' ) ) { } else { version = { 'self' : routes . version || config . pkg . version } ; } if ( ! version . api ) { version . api = api_config . pkg . version ; } routes . version = version ; var router = new RequestRouter ( routes ) ; var req_counter = 0 ; function do_req ( req , res ) { req_counter += 1 ; return router . resolve ( req , res ) ; } return do_req ; }
2556	function do_create_server ( config , do_req ) { var http = require ( 'http' ) ; if ( config . host ) { http . createServer ( do_req ) . listen ( config . port , config . host ) ; } else { http . createServer ( do_req ) . listen ( config . port ) ; } return http ; }
2557	function setup_server ( config , opts ) { config . _def ( 'port' , 3000 ) ; var req_handler = do_create_req ( config , opts ) ; var server = do_create_server ( config , function ( req , res ) { req_handler ( req , res ) . then ( function ( obj ) { if ( obj === api . replySent ) { return ; } else if ( obj === api . notFound ) { do_failure ( req , res , { 'verb' : 'notFound' , 'desc' : 'The requested resource could not be found.' , 'code' : 404 } ) ; } else { do_success ( req , res , obj ) ; } } ) . fail ( function ( err ) { do_failure ( req , res , err ) ; if ( ! ( err instanceof errors . HTTPError ) ) { require ( 'prettified' ) . errors . print ( err ) ; } } ) . done ( ) ; } ) ; return server ; }
2558	function ( element , ev , fn ) { if ( element . addEventListener ) element . addEventListener ( ev , fn , false ) ; else element . attachEvent ( "on" + ev , fn ) ; }
2559	function Reply ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } Reply . super_ . apply ( this , arguments ) ; }
2560	function serveGitFile ( repo , tree , parts , res , next ) { var thisPart = parts . shift ( ) ; var isLastPart = parts . length === 0 ; var entryIndex = - 1 ; for ( var i = 0 ; i < tree . entries . length ; i ++ ) { if ( tree . entries [ i ] . name === thisPart ) { entryIndex = i ; break ; } } if ( entryIndex < 0 ) return next ( ) ; var entry = tree . entries [ entryIndex ] ; if ( isLastPart ) { repo . getBlob ( entry . id , function ( err , buf ) { if ( err ) return next ( err ) ; if ( ! buf . data ) return next ( ) ; serveBuffer ( buf . data , res , thisPart ) ; } ) ; } else { repo . getTree ( entry . id , function ( err , entryTree ) { if ( err ) return next ( err ) ; serveGitFile ( repo , entryTree , parts , res , next ) ; } ) ; } }
2561	function processFileList ( files , base , settings , state ) { for ( var i = 0 ; i < files . length ; i ++ ) { var modulePath = path . join ( base , files [ i ] ) ; var stats = fs . statSync ( modulePath ) ; if ( stats . isFile ( ) ) { var module = require ( modulePath ) ; var relative = path . relative ( settings . source , modulePath ) ; __log ( 'Relative path: %s' , relative ) ; var pathWithoutExtension = relative . substr ( 0 , relative . lastIndexOf ( '.' ) ) ; var routeName = pathWithoutExtension . replace ( / \\ / g , '/' ) . replace ( / \. / g , '_' ) ; var isRoot = new RegExp ( settings . rootModule + '/?$' , 'g' ) . test ( routeName ) ; var routePath = routeName ; if ( isRoot ) { if ( routePath . lastIndexOf ( '/' ) > - 1 ) routePath = routePath . substr ( 0 , routePath . lastIndexOf ( '/' ) ) ; else routePath = undefined ; } __log ( '%s (%s)' , routeName , routePath ) ; var apiPath = utils . combineApiPath ( settings . root , routePath ) ; state . endpoints [ routeName ] = { baseUrl : apiPath , filename : modulePath , routeName : routeName } ; __log ( state . endpoints [ routeName ] ) ; settings . app . use ( apiPath , module ) ; } else if ( stats . isDirectory ( ) ) { var dirFiles = fs . readdirSync ( modulePath ) ; processFileList ( dirFiles , modulePath , settings , state ) ; } } }
2562	function packageModule ( global , name , api ) { if ( global . define && global . define . amd ) { define ( [ ] , api ) ; } else if ( typeof exports !== "undefined" ) { module . exports = api ; } else { global [ name ] = api ; } }
2563	function Ebus ( p ) { "use strict" ; this . debug = false ; this . yields = false ; this . handlers = { } ; if ( p ) { this . priorities = p ; } else { this . priorities = { } ; } }
2564	function ApiClient ( config ) { var self = this this . config = _ . extend ( { } , config , { client : this } ) config . headers = _ . extend ( { } , config . headers , { Accept : 'application/json' } ) this . auth = config . auth models . sync = require ( './sync' ) models . Model = require ( './modelbase' ) models . NginModel = require ( './nginModel' ) Object . keys ( models ) . forEach ( function ( modelName ) { Object . defineProperty ( self , modelName , { get : function ( ) { return models [ modelName ] ( self ) } , enumerable : true , configurable : true } ) } ) _ . extend ( this , models ) }
2565	function getFirstIndexOf ( value , array ) { error_if_not_primitive_or_array_1 . errorIfNotPrimitiveOrArray ( value ) ; if ( isArray_notArray_1 . isArray ( value ) ) { return getFirstIndexOfArray_1 . getFirstIndexOfArray ( value , array ) ; } else { return getIndexOfPrimitive_1 . getIndexOfPrimitive ( value , array ) ; } }
2566	function scopeUrl ( options , inst ) { options = _ . extend ( { } , inst , options ) if ( ! options . season_id ) throw new Error ( 'season_id required to make division instance api calls' ) return ngin . Season . urlRoot ( ) + '/' + options . season_id + Division . urlRoot ( ) }
2567	function Customer ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } Customer . super_ . apply ( this , arguments ) ; }
2568	function copy ( obj ) { return Object . getOwnPropertyNames ( obj || { } ) . reduce ( ( a , c ) => { a [ c ] = obj [ c ] ; return a ; } , { } ) ; }
2569	function formatWith ( options ) { options = Object . assign ( { } , DEFAULTS , options ) ; return ( message , ... args ) => { return _formatter ( options , message , ... args ) ; } ; }
2570	function ( sourceDir , destFile , opts ) { opts = opts || { archive_path : '/' } ; return new Promise ( function ( resolve , reject ) { try { var archive = archiver . create ( 'zip' , { zlib : { level : 9 } } ) ; var output = fs . createWriteStream ( destFile ) ; output . on ( 'finish' , function ( ) { resolve ( destFile ) ; } ) ; archive . pipe ( output ) ; archive . directory ( sourceDir , opts . archive_path ) ; archive . finalize ( ) ; } catch ( err ) { reject ( err ) ; } } ) ; }
2571	function ( sourceFile , destDir ) { return new Promise ( function ( resolve , reject ) { var zip = new AdmZip ( sourceFile ) ; try { zip . extractAllTo ( destDir ) ; resolve ( destDir ) ; } catch ( err ) { reject ( err ) ; } } ) ; }
2572	function ( sourceDir , destFile , opts ) { opts = opts || { archive_path : '/' } ; return new Promise ( function ( resolve , reject ) { var tempFile = destFile + '.tmp.tar' ; try { var archive = archiver . create ( 'tar' ) ; var output = fs . createWriteStream ( tempFile ) ; output . on ( 'finish' , function ( ) { resolve ( tempFile ) ; } ) ; archive . pipe ( output ) ; archive . directory ( sourceDir , opts . archive_path ) ; archive . finalize ( ) ; } catch ( err ) { reject ( err ) ; } } ) . then ( function ( tempFile ) { try { var data = new Buffer ( fs . readFileSync ( tempFile ) , 'utf8' ) ; var compressed = new Buffer ( Bzip2 . compressFile ( data ) ) ; fs . writeFileSync ( destFile , compressed ) ; return destFile ; } catch ( err ) { throw err ; } finally { rimraf . sync ( tempFile ) ; } } ) ; }
2573	function ( sourceFile , destDir ) { return new Promise ( function ( resolve , reject ) { var tempFile = sourceFile + '.tmp.tar' ; try { var data = new Buffer ( fs . readFileSync ( sourceFile ) ) ; var expanded = Bzip2 . decompressFile ( data ) ; fs . writeFileSync ( tempFile , new Buffer ( expanded ) ) ; resolve ( tempFile ) ; } catch ( err ) { reject ( err ) ; } } ) . then ( function ( tempFile ) { return new Promise ( function ( resolve , reject ) { try { var rs = fs . createReadStream ( tempFile ) ; rs . pipe ( tar . extract ( destDir ) . on ( 'finish' , function ( ) { rimraf . sync ( tempFile ) ; resolve ( destDir ) ; } ) ) ; } catch ( err ) { rimraf . sync ( tempFile ) ; reject ( err ) ; } } ) ; } ) ; }
2574	async function make ( dir ) { try { await makePromise ( mkdir , dir ) } catch ( err ) { if ( err . code == 'ENOENT' ) { const parentDir = dirname ( dir ) await make ( parentDir ) await make ( dir ) } else if ( err . code != 'EEXIST' ) { throw err } } }
2575	function fabricator ( stack , options ) { options = options || { } ; if ( empty ( stack ) ) return [ ] ; switch ( is ( stack ) ) { case 'string' : stack = read ( stack , options ) ; break ; case 'object' : stack = Object . keys ( stack ) . reduce ( iterator ( read , stack , options ) , [ ] ) ; break ; case 'array' : stack = stack . reduce ( iterator ( read , null , options ) , [ ] ) ; break ; default : if ( 'function' !== typeof stack ) { throw new Error ( 'Unsupported type, cannot fabricate an: ' + is ( stack ) ) ; } stack = [ init ( stack , undefined , options ) ] ; } return ( stack || [ ] ) . filter ( Boolean ) ; }
2576	function read ( filepath , options ) { if ( 'string' !== is ( filepath ) ) return fabricator ( filepath , options ) ; if ( options . source ) filepath = path . resolve ( options . source , filepath ) ; if ( js ( filepath ) || options . recursive === false ) return [ init ( filepath , path . basename ( filepath , '.js' ) , options ) ] ; if ( ! fs . existsSync ( filepath ) ) return false ; return fs . readdirSync ( filepath ) . map ( function locate ( file ) { file = path . resolve ( filepath , file ) ; var stat = fs . statSync ( file ) ; if ( stat . isDirectory ( ) && fs . existsSync ( path . join ( file , 'index.js' ) ) ) { return init ( path . join ( file , 'index.js' ) , path . basename ( file , '.js' ) , options ) ; } if ( ! stat . isFile ( ) || ! js ( file ) ) return ; return init ( file , path . basename ( file , '.js' ) , options ) ; } ) ; }
2577	function iterator ( traverse , obj , options ) { return function reduce ( stack , entity ) { var base = obj ? obj [ entity ] : entity , name = options . name || entity ; if ( obj ) options . name = entity ; if ( js ( base ) ) { return stack . concat ( init ( base , 'string' === is ( name ) ? name : '' , options ) ) ; } if ( Array . isArray ( base ) ) { options . name = name ; stack . push ( traverse ( base , options ) ) ; return stack ; } return stack . concat ( traverse ( base , options ) ) ; } ; }
2578	function js ( file ) { var type = is ( file ) ; return 'function' === type || 'string' === type && path . extname ( file ) === '.js' ; }
2579	function empty ( value ) { if ( ! value ) return true ; switch ( is ( value ) ) { case "object" : return ! Object . keys ( value ) . length ; case "array" : return ! value . length ; default : return ! value ; } }
2580	function click ( e ) { var op = 'remove' ; if ( this . className === 'menuLink' ) { op = document . body . classList . contains ( 'menu-open' ) ? 'remove' : 'add' ; e . preventDefault ( ) ; } document . body . classList [ op ] ( 'menu-open' ) ; }
2581	function ShellStream ( args ) { if ( this instanceof ShellStream === false ) { return new ShellStream ( args ) ; } this . _command = args ; this . _events = [ ] ; var self = this ; streams . forEach ( function ( stream ) { self [ stream ] = { on : this . on , _events : [ ] } ; } ) ; }
2582	function ( name , specs ) { this . name = name ; this . id = 0 ; this . properties = specs . properties || [ ] ; this . extends = specs . extends || null ; this . depends = specs . depends || null ; this . factory = specs . factory || "new" ; this . init = specs . init || "default" ; this . frequent = false ; this . keepUsedProperties = false ; this . initProperties = true ; this . initConstructorArgs = [ ] ; this . propCustomAssign = { } ; this . propAssign = "" ; this . propCustomGet = { } ; this . propGet = "" ; this . postInit = specs . postInit || "" ; this . embed = specs . embed || [ ] ; if ( this . postInit ) this . postInit += "\n" ; \n this . safeName = name . replace ( / [,\.\- \_] / g , '_' ) ; if ( this . init instanceof Array ) { this . initConstructorArgs = this . init ; this . init = "constructor" ; this . factory = "create" } else if ( this . init instanceof { } . constructor ) { this . propCustomAssign = this . init ; this . init = "default" ; if ( this . propCustomAssign [ 'default' ] ) { this . propAssign = this . propCustomAssign [ 'default' ] ; delete this . propCustomAssign [ 'default' ] ; } } else if ( this . init !== "default" ) { if ( this . factory === "new" ) this . factory = "create" ; } if ( specs . getter ) { if ( typeof specs == 'object' ) { this . propCustomGet = specs . getter ; if ( this . propCustomGet [ 'default' ] ) { this . propGet = this . propCustomGet [ 'default' ] ; delete this . propCustomGet [ 'default' ] ; } } else { this . propGet = specs . getter ; } } if ( specs . frequent !== undefined ) { this . frequent = ( [ "yes" , "true" , "1" ] . indexOf ( specs . frequent . toString ( ) . toLowerCase ( ) ) >= 0 ) ; } if ( specs . initProperties !== undefined ) { this . initProperties = ( [ "yes" , "true" , "1" ] . indexOf ( specs . initProperties . toString ( ) . toLowerCase ( ) ) >= 0 ) ; } }
2583	function ( o ) { if ( this . extends ) { this . embed = o . embed . concat ( this . embed ) ; this . properties = o . properties . concat ( this . properties ) ; this . postInit = o . postInit + this . postInit ; if ( this . init === "default" ) this . init = o . init ; if ( this . factory === "new" ) this . factory = o . factory ; if ( ! this . propAssign ) this . propAssign = o . propAssign ; for ( var k in o . propCustomAssign ) { if ( ! this . propCustomAssign [ k ] ) { this . propCustomAssign [ k ] = o . propCustomAssign [ k ] ; } } } }
2584	function ( instVar , prefix ) { var code = "[" , getCode = "" , prop = "" , defaultGet = "$inst.$prop" ; if ( this . defaultGet ) defaultGet = defaultGet ; for ( var i = 0 , l = this . properties . length ; i < l ; ++ i ) { prop = this . properties [ i ] ; if ( i > 0 ) code += "," ; if ( this . propCustomGet [ prop ] ) { getCode = this . propCustomGet [ prop ] . replace ( / \$inst / g , instVar ) . replace ( / \$prop / g , prop ) ; } else { getCode = defaultGet . replace ( / \$inst / g , instVar ) . replace ( / \$prop / g , prop ) ; } if ( this . embed . indexOf ( prop ) === - 1 ) { code += "\n" + \n + prefix ; } else getCode } { code += "\n" + \n + prefix + "new BinaryEncoder.FileResource( " + getCode ; } " )" }
2585	function ( ) { var props = this . properties . slice ( ) . sort ( ) ; return 'init' + crypto . createHash ( 'md5' ) . update ( props . join ( "," ) ) . digest ( "hex" ) ; }
2586	function ( instVar , valVar , pageszVar , offsetVar , prefix , indent ) { var code = "" , usedProps = { } , defaultAssign = "$inst.$prop = $value" , replaceVariableMacro = ( function ( s , v ) { var i = this . properties . indexOf ( v ) ; if ( i >= 0 ) { usedProps [ v ] = true ; } else { throw "Macro " + s + " refers to a property not part of property table!" ; } } ) . bind ( this ) ; if ( this . init == "default" ) { } else if ( this . init == 'constructor' ) { code += prefix + this . name + ".call(" + instVar ; for ( var i = 0 , l = this . initConstructorArgs . length ; i < l ; i ++ ) { var arg = this . initConstructorArgs [ i ] , partIdx = arg . search ( / [\.\[] / ) , part = "" , found = false ; if ( partIdx == - 1 ) partIdx = arg . length ; part = arg . substr ( 0 , partIdx ) ; for ( var j = 0 , jl = this . properties . length ; j < jl ; ++ j ) { if ( this . properties [ j ] == part ) { arg = valVar + "[" + offsetVar + '+' + pageszVar + '*' + j + "]" + arg . substr ( partIdx ) ; usedProps [ part ] = true ; found = true ; break ; } } if ( ! found ) { console . warn ( "Could not find property '" + arg + "' in " + this . name + ". Assuming literal" ) ; } code += ",\n" + \n + prefix + indent ; } arg } else code += ");\n" ; \n { console . warn ( "Using custom init function for " + this . name ) ; code += prefix + this . init + "(" + instVar + ", " + valVar + ");\n" ; } \n for ( var k in this . propCustomAssign ) { this . propCustomAssign [ k ] = this . propCustomAssign [ k ] . replace ( / \$\$(\w+) / g , replaceVariableMacro ) ; } if ( this . propAssign ) defaultAssign = this . propAssign ; defaultAssign = defaultAssign . replace ( / \$\$(\w+) / g , replaceVariableMacro ) ; }
2587	function bufferMode ( contents , options , callback ) { ProfileCompiler ( contents . toString ( 'utf-8' ) , options , function ( err , encBuf , decBuf ) { if ( err ) { callback ( err ) ; return ; } callback ( null , new Buffer ( encBuf , 'utf8' ) , new Buffer ( decBuf , 'utf8' ) ) ; } ) ; }
2588	function streamMode ( contents , options , callback ) { toArray ( contents , function ( err , chunks ) { if ( err ) { callback ( err ) ; return ; } bufferMode ( Buffer . concat ( chunks ) , options , function ( err , encBuf , decBuf ) { if ( err ) { callback ( err ) ; return ; } var encStream = new Readable ( ) ; encStream . push ( encBuf ) ; encStream . push ( null ) ; var decStream = new Readable ( ) ; decStream . push ( decBuf ) ; decStream . push ( null ) ; callback ( null , encStream , decStream ) ; } ) ; } ) ; }
2589	function ( err , encContents , decContents ) { if ( err ) { var error = new PluginError ( PLUGIN_NAME , err , { showStack : true } ) ; self . emit ( 'error' , error ) ; done ( ) ; return ; } var dir = path . dirname ( originalFile . path ) ; var name = path . basename ( originalFile . path ) ; var parts = name . split ( "." ) ; parts . pop ( ) ; var baseName = self . config . name || parts . join ( "." ) ; var f = originalFile . clone ( ) ; f . contents = encContents ; f . path = path . join ( dir , baseName + '-encode.js' ) ; self . push ( f ) ; var f = originalFile . clone ( ) ; f . contents = decContents ; f . path = path . join ( dir , baseName + '-decode.js' ) ; self . push ( f ) ; done ( ) ; return ; }
2590	function journal ( ) { 'use strict' ; var fs = require ( 'fs' ) ; var eventList = { 'creationEvents' : { } , 'executionEvents' : { } } ; var logMode ; function setLogMode ( mode ) { logMode = mode ; } function logCreationEvent ( id , type , message , time ) { if ( logMode === 'l' ) { if ( ! eventList . creationEvents [ id ] ) { eventList . creationEvents [ id ] = [ ] ; } eventList . creationEvents [ id ] . push ( { 'type' : type , 'event' : message , "timestamp" : time } ) ; } else if ( logMode === 'v' ) { console . log ( type + ': Agent ' + id + ' ' + message + ' on ' + time ) ; } } function logExecutionEvent ( id , type , message , time ) { if ( logMode === 'l' ) { if ( ! eventList . executionEvents [ id ] ) { eventList . executionEvents [ id ] = [ ] ; } eventList . executionEvents [ id ] . push ( { 'type' : type , 'event' : message , "timestamp" : time } ) ; } else if ( logMode === 'v' ) { console . log ( type + ': Agent ' + id + ' ' + message + ' on ' + time ) ; } } function report ( logFile ) { var defaultLogFile = ( new Date ( ) ) . toJSON ( ) + '.log' ; var data = JSON . stringify ( eventList , null , 3 ) ; if ( logFile ) { fs . writeFile ( logFile , data , function ( err ) { if ( err ) { console . log ( '\nCould not write log to file "' + \n + logFile + '"\n' ) ; \n } } ) ; } else err } fs . writeFile ( defaultLogFile , data , function ( err ) { if ( err ) { console . log ( 'Could not write log file: ' + err ) ; } else { console . log ( 'Log was written on default file "' + defaultLogFile + '"' ) ; } } ) ; }
2591	function logCreationEvent ( id , type , message , time ) { if ( logMode === 'l' ) { if ( ! eventList . creationEvents [ id ] ) { eventList . creationEvents [ id ] = [ ] ; } eventList . creationEvents [ id ] . push ( { 'type' : type , 'event' : message , "timestamp" : time } ) ; } else if ( logMode === 'v' ) { console . log ( type + ': Agent ' + id + ' ' + message + ' on ' + time ) ; } }
2592	function logExecutionEvent ( id , type , message , time ) { if ( logMode === 'l' ) { if ( ! eventList . executionEvents [ id ] ) { eventList . executionEvents [ id ] = [ ] ; } eventList . executionEvents [ id ] . push ( { 'type' : type , 'event' : message , "timestamp" : time } ) ; } else if ( logMode === 'v' ) { console . log ( type + ': Agent ' + id + ' ' + message + ' on ' + time ) ; } }
2593	function report ( logFile ) { var defaultLogFile = ( new Date ( ) ) . toJSON ( ) + '.log' ; var data = JSON . stringify ( eventList , null , 3 ) ; if ( logFile ) { fs . writeFile ( logFile , data , function ( err ) { if ( err ) { console . log ( '\nCould not write log to file "' + \n + logFile + '"\n' ) ; \n } } ) ; } else err }
2594	function scopeUrl ( options , inst ) { options = _ . extend ( { } , inst , options ) if ( ! options . teamcenter_team_id ) throw new Error ( 'teamcenter_team_id required to make TeamCenterContact instance api calls' ) if ( ! options . teamcenter_member_id ) throw new Error ( 'teamcenter_member_id require to make TeamCenterContact instance api calls' ) return ngin . TeamCenterTeam . urlRoot ( ) + '/' + options . teamcenter_team_id + ngin . TeamCenterMember . urlRoot ( ) + '/' + options . teamcenter_member_id + TeamCenterContact . urlRoot ( ) }
2595	function ArticleTranslation ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } ArticleTranslation . super_ . apply ( this , arguments ) ; }
2596	function MacroAction ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } MacroAction . super_ . apply ( this , arguments ) ; }
2597	function map ( obj , source , target , isRecursive = true ) { if ( ( typeof obj ) != "object" ) throw new TypeError ( "The object should be JSON" ) ; if ( ( typeof source ) != "string" && ( typeof source ) != "array" ) throw new TypeError ( "Source should be aither string or array" ) ; if ( ( typeof target ) != "string" && ( typeof target ) != "array" ) throw new TypeError ( "Target should be aither string or array" ) ; let res = { } ; let propS = ( typeof source == "string" ) ? source . replace ( / / g , '' ) . split ( "," ) : source ; let propT = ( typeof target == "string" ) ? target . replace ( / / g , '' ) . split ( "," ) : target ; for ( let propertyName in obj ) { let propIndexInSource = propS . indexOf ( propertyName ) ; let newName = ( propIndexInSource != - 1 ) ? propT [ propIndexInSource ] : propertyName ; if ( isRecursive && obj [ propertyName ] instanceof Array ) { res [ newName ] = [ ] ; for ( var i = 0 ; i < obj [ propertyName ] . length ; i ++ ) { let mappedItem = map ( obj [ propertyName ] [ i ] , source , target , isRecursive ) res [ newName ] . push ( mappedItem ) ; } continue ; } if ( isRecursive && ( ( typeof obj [ propertyName ] ) == "object" ) ) res [ newName ] = map ( obj [ propertyName ] , source , target , isRecursive ) ; else res [ newName ] = obj [ propertyName ] ; } return res ; }
2598	function ( visit , onFail , opts ) { var fail = onFail ? onFail : utils . ret ( false ) , config = opts || { compact : true } ; return function ( list ) { var p = Promise . resolve ( false ) , results = [ ] ; list . forEach ( function ( l , i ) { p = p . then ( visit . bind ( null , l ) ) . catch ( function ( err ) { return fail ( err , l ) ; } ) . then ( function ( result ) { results . push ( result ) ; if ( config . onProgress ) config . onProgress ( list . length , i + 1 , l ) ; } ) ; } ) ; return p . then ( function ( ) { return config . compact ? results . filter ( Boolean ) : results ; } ) ; } ; }
2599	function ( ) { console . warn ( 'Code is using deprecated teams_advancing, switch to teamsAdvancing' ) var where = ( new Error ( ) . stack || '' ) . split ( '\n' , \n ) [ 3 ] 2 if ( where ) console . warn ( where ) }
2600	function getIndexOfPrimitive ( primitive , array , startingPosition ) { if ( startingPosition === void 0 ) { startingPosition = 0 ; } errorIfNotPrimitive_1 . errorIfNotPrimitive ( primitive ) ; error_if_not_populated_array_1 . errorIfNotPopulatedArray ( array ) ; errorIfNotInteger_1 . errorIfNotInteger ( startingPosition ) ; return array . indexOf ( primitive , startingPosition ) ; }
2601	function loads ( xhr , ee ) { var onreadystatechange , onprogress , ontimeout , onabort , onerror , onload , timer ; onerror = xhr . onerror = one ( function onerror ( evt ) { var status = statuscode ( xhr ) , err = fail ( new Error ( 'Network request failed' ) , status ) ; ee . emit ( 'error' , err ) ; ee . emit ( 'end' , err , status ) ; } ) ; onabort = xhr . onabort = function onabort ( evt ) { onerror ( evt ) ; } ; onreadystatechange = xhr . onreadystatechange = function change ( evt ) { var target = evt . target ; if ( 4 === target . readyState ) return onload ( evt ) ; } ; ontimeout = xhr . ontimeout = one ( function timeout ( evt ) { ee . emit ( 'timeout' , evt ) ; if ( xhr . abort ) xhr . abort ( ) ; onerror ( evt ) ; } ) ; if ( xhr . timeout ) timer = setTimeout ( ontimeout , + xhr . timeout ) ; onprogress = xhr . onprogress = function progress ( evt ) { var status = statuscode ( xhr ) , data ; ee . emit ( 'progress' , evt , status ) ; if ( xhr . readyState >= 3 && status . code === 200 && ( data = response ( xhr ) ) ) { ee . emit ( 'stream' , data , status ) ; } } ; onload = xhr . onload = one ( function load ( evt ) { var status = statuscode ( xhr ) , data = response ( xhr ) ; if ( status . code < 100 || status . code > 599 ) return onerror ( evt ) ; if ( data && status . code !== 204 ) { ee . emit ( 'stream' , data , status ) ; } ee . emit ( 'end' , undefined , status ) ; } ) ; ee . once ( 'end' , function cleanup ( ) { xhr . onreadystatechange = onreadystatechange = xhr . onprogress = onprogress = xhr . ontimeout = ontimeout = xhr . onerror = onerror = xhr . onabort = onabort = xhr . onload = onload = nope ; if ( timer ) clearTimeout ( timer ) ; } ) ; return xhr ; }
2602	function addWithDependencies ( allFiles , newFile , dependencies , currentFiles , cycleCheck ) { if ( cycleCheck . indexOf ( newFile ) >= 0 ) { throw new Error ( 'Dependency cycle found ' + JSON . stringify ( cycleCheck ) ) } cycleCheck . push ( newFile ) try { if ( dependencies [ newFile ] ) { dependencies [ newFile ] . forEach ( function ( dependency ) { if ( allFiles . indexOf ( dependency ) < 0 ) { throw new Error ( 'Dependency "' + dependency + '" of file "' + newFile + '" is not part of ' + JSON . stringify ( allFiles ) ) } addWithDependencies ( allFiles , dependency , dependencies , currentFiles , cycleCheck ) } ) } if ( currentFiles . indexOf ( newFile ) < 0 ) { currentFiles . push ( newFile ) } } finally { cycleCheck . pop ( ) } return currentFiles }
2603	function batchForms ( batch , form , merkle ) { var stringified = stringify ( form ) var digest = merkle . digest batch . put ( digest , stringified ) form . content . forEach ( function ( element , index ) { if ( isChild ( element ) ) { var childForm = element . form var childMerkle = merkle . content [ index ] batchForms ( batch , childForm , childMerkle ) } } ) }
2604	function parseJSON ( input , callback ) { var error var result try { result = JSON . parse ( input ) } catch ( e ) { error = e } callback ( error , result ) }
2605	function scopeUrl ( options , inst ) { options = _ . extend ( _ . clone ( options || { } ) , inst ) var route = [ ] if ( options . season_id ) route . push ( 'seasons' , options . season_id ) if ( options . flight_stage_id ) route . push ( 'flight_stages' , options . flight_stage_id ) else if ( options . division_id ) route . push ( 'divisions' , options . division_id ) else if ( options . pool_id ) route . push ( 'pools' , options . pool_id ) route . push ( 'standings' ) var base = config . urls && config . urls . sports || config . url return Url . resolve ( base , route . join ( '/' ) ) }
2606	function ReconnectingWebSocket ( url , opts ) { if ( ! ( this instanceof ReconnectingWebSocket ) ) { throw new TypeError ( 'Cannot call a constructor as a function' ) ; } opts = opts || { } ; var self = this ; function getOpt ( name , def ) { return opts . hasOwnProperty ( name ) ? opts [ name ] : def ; } var timeout = getOpt ( 'timeout' , 100 ) ; var maxRetries = getOpt ( 'maxRetries' , 5 ) ; var curRetries = 0 ; self . onmessage = noop ; self . onopen = noop ; self . onclose = noop ; function unreliableOnOpen ( e ) { self . onopen ( e ) ; curRetries = 0 ; } function unreliableOnClose ( e ) { self . onclose ( e ) ; if ( curRetries < maxRetries ) { ++ curRetries ; setTimeout ( connect , timeout ) ; } } function unreliableOnMessage ( e ) { self . onmessage ( e ) ; } function connect ( ) { if ( opts . protocols ) { self . ws = new WebSocket ( url , opts . protocols ) ; } else { self . ws = new WebSocket ( url ) ; } self . ws . onopen = unreliableOnOpen ; self . ws . onclose = unreliableOnClose ; self . ws . onmessage = unreliableOnMessage ; } connect ( ) ; this . connect = connect ; }
2607	function getFirstIndexOfArray ( arrayToSearchFor , arrayToSearchInside ) { errorIfNotArray_1 . errorIfNotArray ( arrayToSearchFor ) ; error_if_not_populated_array_1 . errorIfNotPopulatedArray ( arrayToSearchInside ) ; return arrayToSearchInside . findIndex ( function ( value ) { return ( isArray_notArray_1 . isArray ( value ) && arrays_match_1 . arraysMatch ( value , arrayToSearchFor ) ) ; } ) ; }
2608	function writePath ( parentDir , path , data ) { let files = path . split ( '/' ) ; let file = files . shift ( ) ; if ( ! parentDir [ file ] ) parentDir [ file ] = { content : undefined , tree : { } } ; if ( files . length > 0 ) { writePath ( parentDir [ file ] . tree , files . join ( '/' ) , data ) ; } else if ( data ) { parentDir [ file ] . content = data . toString ( ) ; } }
2609	function ( mainFiles ) { for ( var i = 0 ; i < mainFiles . length ; i ++ ) { var parts = mainFiles [ i ] . split ( '.' ) , ext = parts . pop ( ) , min = parts . pop ( ) , fName ; if ( min == 'min' ) { parts . push ( ext ) ; fName = parts . join ( '.' ) ; if ( grunt . file . exists ( fName ) ) mainFiles [ i ] = fName ; } } return mainFiles ; }
2610	function ( ) { this . objects = { } ; this . index = [ ] ; this . _objTree = [ ] ; this . _objList = [ ] ; this . _properties = { } ; this . _propID = 0 ; this . _decodeIndex = [ ] ; this . _objFreq = [ ] ; this . _objInfeq = [ ] ; this . shortNames = true ; this . indent = "\t" ; \t }
2611	function ( po ) { this . objects [ po . name ] = po ; if ( po . extends ) { this . _objTree . push ( [ po . extends , po . name ] ) ; } else if ( po . depends ) { this . _objTree . push ( [ po . depends , po . name ] ) ; } else { this . _objList . push ( po . name ) ; } }
2612	function ( index_offset , size , depth , prefix , testVar , callback ) { if ( size == 0 ) return prefix + this . indent + "/* No items */\n" ; \n var code = "" ; genChunk = ( function ( s , e , d , pf ) { if ( d === 0 ) { code += pf + "switch (" + testVar + ") {\n" ; \n for ( var i = s ; i < e ; ++ i ) { code += pf + this . indent + "case " + ( index_offset + i ) + ": return " + callback ( i ) ; } } else code += pf + "}\n" ; } ) . \n { if ( e == s ) { } else if ( e == s + 1 ) { code += pf + "if (" + testVar + " === " + ( index_offset + s ) + ")\n" ; \n } else code += pf + this . indent + "return " + callback ( s ) ; } ; { var mid = Math . round ( ( s + e ) / 2 ) ; code += pf + "if (" + testVar + " < " + ( index_offset + mid ) + ") {\n" ; \n genChunk ( s , mid , d - 1 , pf + this . indent ) ; code += pf + "} else {\n" ; \n } }
2613	function ( name ) { var id = this . _properties [ name ] ; if ( id === undefined ) { if ( this . shortNames ) { id = this . _properties [ name ] = 'p' + ( this . _propID ++ ) . toString ( ) } else { id = this . _properties [ name ] = 'p' + name [ 0 ] . toUpperCase ( ) + name . substr ( 1 ) . toLowerCase ( ) . replace ( / [,\.\- \_] / g , '_' ) } } }
2614	function ( ) { this . index = [ ] ; for ( var i = 0 , l = this . _objTree . length ; i < l ; ++ i ) { if ( this . objects [ this . _objTree [ i ] [ 0 ] ] === undefined ) { throw "Extending unknown object " + this . _objTree [ i ] [ 0 ] ; } this . objects [ this . _objTree [ i ] [ 1 ] ] . applyExtend ( this . objects [ this . _objTree [ i ] [ 0 ] ] ) ; } var deps = toposort ( this . _objTree ) . reverse ( ) , used = { } ; for ( var i = 0 , l = deps . length ; i < l ; ++ i ) { used [ deps [ i ] ] = 1 ; this . objects [ deps [ i ] ] . id = this . index . length ; this . index . push ( this . objects [ deps [ i ] ] ) ; } for ( var i = 0 , l = this . _objList . length ; i < l ; ++ i ) { if ( ! used [ this . _objList [ i ] ] ) { this . index . push ( this . objects [ this . _objList [ i ] ] ) ; } } for ( var i = 0 , l = this . index . length ; i < l ; ++ i ) { var pp = this . index [ i ] . properties ; for ( var j = 0 , jl = pp . length ; j < jl ; ++ j ) { this . propertyVar ( pp [ j ] ) ; } if ( this . index [ i ] . embed . length > 0 ) { this . hasEmbed = true ; } } for ( var i = 0 , l = this . index . length ; i < l ; ++ i ) { var obj = this . index [ i ] , isFreq = obj . frequent ; if ( isFreq ) { if ( this . _objFreq . length >= MAX_FREQ_ITEMS ) { isFreq = false ; } } if ( isFreq ) { obj . id = this . _objFreq . length ; this . _objFreq . push ( obj ) ; } else { obj . id = this . _objInfeq . length + MAX_FREQ_ITEMS ; this . _objInfeq . push ( obj ) ; } } }
2615	function ( ) { var pn = Object . keys ( this . _properties ) ; var code = "var " ; for ( var i = 0 , l = pn . length ; i < l ; ++ i ) { if ( i !== 0 ) code += ",\n" ; \n } code += this . indent + this . _properties [ pn [ i ] ] + " = '" + pn [ i ] + "'" ; code += ";\n" ; }
2616	function ( ) { var code = "" ; for ( var i = 0 , l = this . index . length ; i < l ; ++ i ) { var o = this . index [ i ] ; code += "/**\n * Factory & Initializer of " + \n + o . name ; "\n */\n" \n \n code += "var factory_" + o . safeName + " = {\n" ; \n code += this . indent + "props: " + o . properties . length + ",\n" ; \n code += this . indent + "create: function() {\n" ; \n } code += this . indent + this . indent + "return " + o . generateFactory ( ) + ";\n" ; }
2617	function ( prefix ) { var code = "function( id ) {\n" ; \n code += prefix + this . indent + "if (id < " + MAX_FREQ_ITEMS + ") {\n" ; \n code += this . generateDnCif ( 0 , this . _objFreq . length , 3 , prefix + this . indent , 'id' , ( function ( i ) { return "factory_" + this . _objFreq [ i ] . safeName + ";\n" } ) . \n bind ) ; ( this ) code += prefix + this . indent + "} else {\n" ; \n }
2618	function ( prefix ) { var code = "function( inst ) {\n" ; \n for ( var i = 0 , l = this . index . length ; i < l ; ++ i ) { var o = this . index [ i ] ; if ( i === 0 ) code += prefix + this . indent + "if" ; else code += prefix + this . indent + "} else if" ; code += " (inst instanceof " + o . name + ") {\n" ; \n } code += prefix + this . indent + this . indent + "return [" + o . id + ", getter_" + o . safeName + "];\n" ; \n }
2619	function ( ) { var code = "" ; for ( var i = 0 , l = this . index . length ; i < l ; ++ i ) { var o = this . index [ i ] ; code += "/**\n * Property getter " + \n + o . name ; "\n */\n" \n \n } code += "function getter_" + o . safeName + "(inst) {\n" ; \n }
2620	function Client ( options ) { options = options || { } ; this . isClient = true ; this . subdomain = options . subdomain ; this . endpoint = options . endpoint ; if ( ! this . subdomain && ! this . endpoint ) throw new Error ( 'No subdomain was specified.' ) ; if ( this . endpoint && typeof this . endpoint !== 'undefined' ) { this . baseUrl = this . endpoint ; } else { this . baseUrl = 'https://' + this . subdomain + '.desk.com' ; } if ( options . username && options . password ) { this . auth = { username : options . username , password : options . password , sendImmediately : true } ; } else if ( options . consumerKey && options . consumerSecret && options . token && options . tokenSecret ) { this . auth = { consumer_key : options . consumerKey , consumer_secret : options . consumerSecret , token : options . token , token_secret : options . tokenSecret } ; } else { throw new Error ( 'No authentication specified, use either Basic Authentication or OAuth.' ) ; } this . retry = options . retry || false ; this . maxRetry = options . maxRetry || 3 ; this . timeout = options . timeout ; this . logger = options . logger || null ; this . queue = async . queue ( this . request . bind ( this ) , 60 ) ; linkMixin . call ( this , JSON . parse ( fs . readFileSync ( __dirname + '/resources.json' , 'utf-8' ) ) ) ; }
2621	function Imagesloader ( opts ) { var self = { } ; var opts = opts || { } ; var imageloader = Imageloader ( ) ; var imgs = [ ] ; var srcs = [ ] ; var def ; function load ( images ) { def = Deferred ( ) ; srcs = convertImagesToSrc ( images ) ; for ( var i = 0 ; i < srcs . length ; i ++ ) { imageloader . load ( srcs [ i ] ) . success ( function ( img ) { imageLoaded ( img ) ; } ) . error ( function ( msg ) { def . reject ( msg + ' couldn\'t be loaded' ) ; } ) ; } \' ; } return def . promise ; function imageLoaded ( img ) { def . notify ( "notify" ) ; imgs . push ( img ) ; if ( imgs . length == srcs . length ) { sortImages ( ) ; def . resolve ( imgs ) ; } } function convertImagesToSrc ( imgs ) { var src = [ ] ; for ( var i = 0 ; i < imgs . length ; i ++ ) { if ( typeof imgs [ i ] == 'object' ) { src . push ( imgs [ i ] . src ) ; } } ; return src . length ? src : imgs ; } function sortImages ( ) { var arr = [ ] ; for ( var i = 0 ; i < srcs . length ; i ++ ) { for ( var j = 0 ; j < imgs . length ; j ++ ) { var str = imgs [ j ] . src . toString ( ) ; var reg = new RegExp ( srcs [ i ] ) if ( str . match ( reg ) ) arr . push ( imgs [ j ] ) ; } ; } ; imgs = arr ; } self . load = load ; }
2622	function load ( images ) { def = Deferred ( ) ; srcs = convertImagesToSrc ( images ) ; for ( var i = 0 ; i < srcs . length ; i ++ ) { imageloader . load ( srcs [ i ] ) . success ( function ( img ) { imageLoaded ( img ) ; } ) . error ( function ( msg ) { def . reject ( msg + ' couldn\'t be loaded' ) ; } ) ; } \' ; }
2623	function imageLoaded ( img ) { def . notify ( "notify" ) ; imgs . push ( img ) ; if ( imgs . length == srcs . length ) { sortImages ( ) ; def . resolve ( imgs ) ; } }
2624	function convertImagesToSrc ( imgs ) { var src = [ ] ; for ( var i = 0 ; i < imgs . length ; i ++ ) { if ( typeof imgs [ i ] == 'object' ) { src . push ( imgs [ i ] . src ) ; } } ; return src . length ? src : imgs ; }
2625	function sortImages ( ) { var arr = [ ] ; for ( var i = 0 ; i < srcs . length ; i ++ ) { for ( var j = 0 ; j < imgs . length ; j ++ ) { var str = imgs [ j ] . src . toString ( ) ; var reg = new RegExp ( srcs [ i ] ) if ( str . match ( reg ) ) arr . push ( imgs [ j ] ) ; } ; } ; imgs = arr ; }
2626	function builder ( envList , envName ) { if ( envList == null ) { envList = DEFAULT_ENV_LIST ; } if ( envName == null ) { envName = DEFAULT_ENV_NAME ; } if ( ! Array . isArray ( envList ) ) { throw new Error ( 'envList must be an array' ) ; } if ( typeof envName !== 'string' ) { throw new Error ( 'envName must be a string' ) ; } const index = envList . indexOf ( env . get ( envName , DEFAULT_ENV ) . required ( ) . asString ( ) ) ; let body ; if ( index < 0 ) { body = 'return function defaults() {}' ; } else { body = ` ${ index } ` ; } return new Function ( body ) ( ) ; }
2627	function validateId ( id ) { if ( id && id . trim ( ) && / ^[a-zA-Z0-9_]+$ / . test ( id ) ) { if ( agency . isIdInUse ( id ) ) { err . name = 'DuplicateIdError' ; err . message = 'duplication (use a different id)' ; return err ; } else { return id ; } } else { err . name = 'ValidateIdError' ; err . message = 'failed id validation (please use alphanumeric characters and underscore)' ; return err ; } }
2628	function arrayGetUniques ( arr ) { var a = [ ] ; for ( var i = 0 , l = arr . length ; i < l ; i ++ ) { if ( a . indexOf ( arr [ i ] ) === - 1 && arr [ i ] !== '' ) a . push ( arr [ i ] ) ; } return a ; }
2629	function setFunction ( f ) { if ( canExecute ) { if ( Object . getPrototypeOf ( f ) === Function . prototype ) { func = f ; jn . logCreationEvent ( id , 'INFO' , 'function definition completed' , ( new Date ( ) ) . toJSON ( ) ) ; } else { setCanExecute ( false ) ; jn . logCreationEvent ( id , 'ERROR' , 'function definition failed' , ( new Date ( ) ) . toJSON ( ) ) ; } } }
2630	function setCallback ( cb ) { if ( canExecute ) { if ( Object . getPrototypeOf ( cb ) === Function . prototype ) { callback = cb ; jn . logCreationEvent ( id , 'INFO' , 'callback definition completed' , ( new Date ( ) ) . toJSON ( ) ) ; } else { setCanExecute ( false ) ; jn . logCreationEvent ( id , 'ERROR' , 'callback definition failed' , ( new Date ( ) ) . toJSON ( ) ) ; } } }
2631	function Case ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } Case . super_ . apply ( this , arguments ) ; }
2632	function Resource ( parent , definition ) { this . parent = parent ; this . definition = definition ; this . _link = linkMixin ; this . _setup ( ) ; }
2633	function containerSlug ( language_slug , project_slug , resource_slug ) { if ( ! language_slug || ! project_slug || ! resource_slug ) throw new Error ( 'Invalid resource container slug parameters' ) ; return language_slug + '_' + project_slug + '_' + resource_slug ; }
2634	function ( ) { let dir = path . join ( container_directory , content_dir ) ; return fs . readdirSync ( dir ) . filter ( function ( file ) { try { return fs . statSync ( file ) . isDirectory ( ) ; } catch ( err ) { console . log ( err ) ; return false ; } } ) ; }
2635	function ( chapterSlug , chunkSlug ) { let file = path . join ( container_directory , content_dir , chapterSlug , chunkSlug + '.' + this . chunkExt ) ; return fs . readFileSync ( file , { encoding : 'utf8' } ) ; }
2636	function makeContainer ( container_directory , opts ) { return new Promise ( function ( resolve , reject ) { if ( fileUtils . fileExists ( container_directory ) ) { reject ( new Error ( 'Container already exists' ) ) ; return ; } let package_json = { } ; reject ( new Error ( 'Not implemented yet.' ) ) ; } ) ; }
2637	function openContainer ( container_archive , container_directory , opts ) { opts = opts || { compression_method : 'tar' } ; if ( fileUtils . fileExists ( container_directory ) ) { return loadContainer ( container_directory ) ; } if ( ! fileUtils . fileExists ( container_archive ) ) return Promise . reject ( new Error ( 'Missing resource container' ) ) ; if ( opts . compression_method === 'zip' ) { return compressionUtils . unzip ( container_archive , container_directory ) . then ( function ( dir ) { return loadContainer ( dir ) ; } ) ; } else { return compressionUtils . untar ( container_archive , container_directory ) . then ( function ( dir ) { return loadContainer ( dir ) ; } ) ; } }
2638	function inspectContainer ( container_path , opts ) { return new Promise ( function ( resolve , reject ) { if ( path . extname ( container_path ) !== '.' + spec . file_ext ) { reject ( new Error ( 'Invalid resource container file extension' ) ) ; return ; } try { resolve ( fs . statSync ( container_path ) . isFile ( ) ) ; } catch ( err ) { reject ( new Error ( 'The resource container does not exist at' , container_path ) ) ; } } ) . then ( function ( isFile ) { if ( isFile ) { let containerDir = path . join ( path . dirname ( container_path ) , path . basename ( container_path , '.' + spec . file_ext ) ) ; return openContainer ( container_path , containerDir , opts ) . then ( function ( container ) { return closeContainer ( containerDir , opts ) . then ( function ( ) { return Promise . resolve ( container . info ) ; } ) ; } ) ; } else { loadContainer ( container_path ) . then ( function ( container ) { return Promise . resolve ( container . info ) ; } ) ; } } ) ; }
2639	function UserPreference ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } UserPreference . super_ . apply ( this , arguments ) ; }
2640	function getUpdater ( errorFn ) { errorFn = errorFn || new Function ( ) ; return updater ; function updater ( file , ast ) { if ( ast . comments ) { ast . comments . filter ( testDocTag ) . map ( getAnnotatedNode ) . concat ( inferAngular ( ast ) ) . filter ( testFirstOccurrence ) . forEach ( processNode ) ; } else { errorFn ( 'Esprima AST is required to have top-level comments array' ) ; } return ast ; } function getAnnotatedNode ( comment ) { var result ; if ( comment . annotates ) { var candidateTrees ; var parent = comment . annotates . parent ; if ( testNode . isBlockOrProgram ( parent ) ) { var body = parent . body ; var index = body . indexOf ( comment . annotates ) ; var candidates = body . slice ( index ) ; var length = candidates . map ( testNode . isGeneratedCode ) . indexOf ( false ) + 1 ; candidateTrees = candidates . slice ( 0 , length || candidates . length ) ; } else { candidateTrees = [ comment . annotates ] ; } while ( ! result && candidateTrees . length ) { result = esprimaTools . orderNodes ( candidateTrees . shift ( ) ) . filter ( testNode . isFunctionNotIFFE ) . shift ( ) ; } } if ( result ) { return result ; } else { errorFn ( 'Doc-tag @ngInject does not annotate anything' ) ; } } }
2641	function updater ( file , ast ) { if ( ast . comments ) { ast . comments . filter ( testDocTag ) . map ( getAnnotatedNode ) . concat ( inferAngular ( ast ) ) . filter ( testFirstOccurrence ) . forEach ( processNode ) ; } else { errorFn ( 'Esprima AST is required to have top-level comments array' ) ; } return ast ; }
2642	function getAnnotatedNode ( comment ) { var result ; if ( comment . annotates ) { var candidateTrees ; var parent = comment . annotates . parent ; if ( testNode . isBlockOrProgram ( parent ) ) { var body = parent . body ; var index = body . indexOf ( comment . annotates ) ; var candidates = body . slice ( index ) ; var length = candidates . map ( testNode . isGeneratedCode ) . indexOf ( false ) + 1 ; candidateTrees = candidates . slice ( 0 , length || candidates . length ) ; } else { candidateTrees = [ comment . annotates ] ; } while ( ! result && candidateTrees . length ) { result = esprimaTools . orderNodes ( candidateTrees . shift ( ) ) . filter ( testNode . isFunctionNotIFFE ) . shift ( ) ; } } if ( result ) { return result ; } else { errorFn ( 'Doc-tag @ngInject does not annotate anything' ) ; } }
2643	function locationStr ( runtime , line ) { var loc ; loc = 'line: ' + ( line !== undefined ? line : runtime . lineNumber ) ; if ( runtime . file ) { loc += ' -- file: ' + runtime . file ; } return loc ; }
2644	function Macro ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } this . destroy = destroyMixin ; Macro . super_ . apply ( this , arguments ) ; }
2645	function quickSort ( a , l , h , k , c ) { const s = [ ] ; let t = 0 ; s [ t ++ ] = l ; s [ t ++ ] = h ; while ( t > 0 ) { h = s [ -- t ] ; l = s [ -- t ] ; if ( h - l > k ) { const p = partition ( a , l , h , c ) ; if ( p > l ) { s [ t ++ ] = l ; s [ t ++ ] = p ; } if ( p + 1 < h ) { s [ t ++ ] = p + 1 ; s [ t ++ ] = h ; } } } }
2646	function pivot ( a , l , h , c ) { const p = ( l + ( ( h - l ) / 2 ) ) | 0 ; if ( c ( a [ h ] , a [ l ] ) < 0 ) { [ a [ l ] , a [ h ] ] = [ a [ h ] , a [ l ] ] ; } if ( c ( a [ p ] , a [ l ] ) < 0 ) { [ a [ l ] , a [ p ] ] = [ a [ p ] , a [ l ] ] ; } if ( c ( a [ h ] , a [ p ] ) < 0 ) { [ a [ h ] , a [ p ] ] = [ a [ p ] , a [ h ] ] ; } return p ; }
2647	function partition ( a , l , h , c ) { const p = a [ pivot ( a , l , h , c ) ] ; let i = l - 1 ; let j = h + 1 ; for ( ; ; ) { do { i ++ ; } while ( c ( a [ i ] , p ) < 0 ) ; do { j -- ; } while ( c ( a [ j ] , p ) > 0 ) ; if ( i < j ) { [ a [ i ] , a [ j ] ] = [ a [ j ] , a [ i ] ] ; } else { return j ; } } }
2648	function insertionSort ( a , l , h , c ) { for ( let i = l + 1 ; i <= h ; i ++ ) { const x = a [ i ] ; let j = i - 1 ; while ( j >= 0 && c ( a [ j ] , x ) > 0 ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = x ; } }
2649	function search ( parent , baseUrl , callback ) { var resource = new ( getResource ( 'page' ) ) ( parent , { _links : { self : { href : baseUrl , 'class' : 'page' } } } ) ; if ( typeof callback == 'function' ) return resource . exec ( callback ) ; return resource ; }
2650	function createPipeStream ( cmd ) { var proc ; var command ; if ( Array . isArray ( cmd ) ) { var firstCmd = cmd . shift ( ) ; var open = Array . isArray ( firstCmd ) ? createPipeStream . apply ( { } , firstCmd ) : createPipeStream ( firstCmd ) ; cmd . forEach ( function ( p ) { open = open . pipe ( p ) ; } ) ; return open ; } else if ( cmd instanceof EventEmitter ) { proc = cmd ; command = 'pre-defined' ; } else if ( typeof cmd === 'object' ) { throw new TypeError ( 'Invalid input, expected object type -> EventEmitter' ) ; } else { var input = utils . normalizeInput . apply ( this , arguments ) ; command = utils . getCommand ( input ) ; proc = spawn . apply ( { } , input ) ; } proc . _command = command ; if ( proc . exitCode ) { throw new Error ( 'Process already dead' ) ; } return PipeStream ( proc ) ; }
2651	function wrapMethods ( self ) { var methods = [ 'on' ] ; var childObjects = [ 'stdin' , 'stdout' , 'stderr' ] ; methods . forEach ( function ( m ) { var old = self [ m ] ; self [ m ] = function ( ) { old . apply ( self , arguments ) ; return self ; } ; } ) ; if ( utils . isSpawn ( self ) ) { childObjects . forEach ( function ( child ) { methods . forEach ( function ( m ) { var old = self [ child ] [ m ] ; self [ child ] [ m ] = function ( ) { old . apply ( self [ child ] , arguments ) ; return self ; } ; } ) ; } ) ; } }
2652	function connectEvents ( self ) { if ( self . stdout ) { self . stdout . on ( 'data' , function ( d ) { self . emit ( 'data' , d ) ; } ) ; self . stderr . on ( 'data' , function ( d ) { self . emit ( 'error' , d ) ; } ) ; } }
2653	function addEventHandlers ( self ) { self . on ( 'error' , function ( d ) { var fn = self . _error ; self . _cleanUp ( ) ; if ( fn ) { fn ( 'pipeline[' + self . _nr + ']:"' + self . _command + '" failed with: ' + d . toString ( ) ) ; } } ) ; }
2654	function _resolve ( routes , path , req , res ) { return Q . fcall ( function ( ) { path = path || [ ] ; var obj = routes ; if ( IS . obj ( obj ) && IS . fun ( obj . then ) ) { var p = obj . then ( function ( ret ) { return _resolve ( ret , path , req , res ) ; } ) ; return p ; } if ( IS . fun ( obj ) ) { var p2 = Q . when ( obj ( req , res ) ) . then ( function ( ret ) { return _resolve ( ret , path , req , res ) ; } ) ; return p2 ; } if ( obj === undefined ) { return flags . notFound ; } if ( path . length === 0 ) { return obj ; } if ( IS . array ( obj ) ) { var k = path [ 0 ] , n = parseInt ( path . shift ( ) , 10 ) ; if ( k === "length" ) { return _resolve ( obj . length , path . shift ( ) , req , res ) ; } if ( k !== "" + n ) { return Q . fcall ( function ( ) { throw new errors . HTTPError ( { 'code' : 400 , 'desc' : 'Bad Request' } ) ; } ) ; } return _resolve ( obj [ n ] , path . shift ( ) , req , res ) ; } if ( IS . obj ( obj ) ) { var k2 = path [ 0 ] ; if ( obj [ k2 ] === undefined ) { return flags . notFound ; } if ( ! obj . hasOwnProperty ( k2 ) ) { return Q . fcall ( function ( ) { throw new errors . HTTPError ( { 'code' : 403 , 'desc' : 'Forbidden' } ) ; } ) ; } return _resolve ( obj [ path . shift ( ) ] , path , req , res ) ; } return flags . notFound ; } ) ; }
2655	function _buildFunction ( resource ) { return function ( callback ) { if ( typeof callback == 'function' ) { if ( resource !== null ) return resource . exec . call ( resource , callback ) ; else return callback ( null , null ) ; } return resource ; } }
2656	function getApiKey ( ) { if ( isLocal ( ) && pkg . apiKey ) { log . trace ( 'using apiKey in fhconfig' ) ; return pkg . apiKey ; } else { log . trace ( 'using api key in FH_APP_API_KEY env var' ) ; return env ( 'FH_APP_API_KEY' ) . asString ( ) ; } }
2657	function getResource ( name ) { if ( name in resources ) return resources [ name ] ; try { return resources [ name ] = require ( '../resource/' + name ) ; } catch ( err ) { return resources [ name ] = require ( '../resource' ) ; } }
2658	function signMsg ( msg , key , alg ) { var signer = crypto . createSign ( alg ) ; signer . update ( msg ) ; return signer . sign ( key ) ; }
2659	function hashMsg ( msg , alg ) { var hash = crypto . createHash ( alg ) ; hash . update ( msg ) ; return hash . digest ( ) ; }
2660	function addSignatureHeaders ( body , headers , keyId , key ) { if ( ! headers ) { headers = { } ; } if ( ! headers . date ) { headers . date = ( new Date ( ) ) . toUTCString ( ) ; } if ( ! headers . digest ) { headers . digest = 'SHA256=' + hashMsg ( JSON . stringify ( body ) , 'sha256' ) . toString ( 'base64' ) ; } var combine = function ( names , headers ) { var parts = [ ] ; names . forEach ( function ( e ) { parts . push ( e + ': ' + headers [ e ] ) ; } ) ; return parts . join ( '\n' ) ; } ; \n headers . authorization = 'Signature ' + 'keyId="' + keyId + '", ' + 'headers="date digest", ' + 'algorithm="rsa-sha256", ' + 'signature="' + signMsg ( combine ( [ 'date' , 'digest' ] , headers ) , key , 'RSA-SHA256' ) . toString ( 'base64' ) + '"' ; }
2661	async function waitVariableToBe ( variableExpression , value , timeout ) { return await this . waitUntil ( async ( ) => { const result = await this . execute ( ` ${ variableExpression } ${ JSON . stringify ( value ) } ` ) return result . value } , timeout , ` \` ${ variableExpression } \` \` ${ JSON . stringify ( value ) } \` ` ) }
2662	async function waitAttributeToBe ( selector , key , value , timeout ) { return await this . waitUntil ( async ( ) => { const got = await this . element ( selector ) . getAttribute ( key ) return [ ] . concat ( value ) . some ( ( value ) => got === value || String ( got ) === String ( value ) ) } , timeout , ` ${ key } \` ${ selector } \` \` ${ JSON . stringify ( value ) } \` ` ) }
2663	function ( view ) { this . unmount ( ) ; this . currentView = view ; var renderReturnsView = this . currentView . render ( ) ; if ( renderReturnsView ) { $ ( SpecialK . mainContainer ) . empty ( ) . append ( renderReturnsView . el ) . fadeIn ( 'slow' ) ; } }
2664	function ( ) { if ( ! this . currentView ) return false ; $ ( SpecialK . container ) . hide ( ) ; this . currentView . unbind ( ) ; this . currentView . remove ( ) ; this . currentView = null ; return true ; }
2665	function mergeAll ( safe , obj ) { let args = toArray ( arguments ) . slice ( 2 ) ; for ( let i = 0 ; i < args . length ; i ++ ) { obj = merge ( obj , args [ i ] , safe ) ; } return obj ; }
2666	function quality ( str ) { var parts = str . split ( / *; * / ) , val = parts [ 0 ] ; var q = parts [ 1 ] ? parseFloat ( parts [ 1 ] . split ( / *= * / ) [ 1 ] ) : 1 ; return { value : val , quality : q } ; }
2667	function getBrightness ( hex ) { var r = parseInt ( hex . substr ( 2 + 0 * 2 , 2 ) , 16 ) , g = parseInt ( hex . substr ( 2 + 1 * 2 , 2 ) , 16 ) , b = parseInt ( hex . substr ( 2 + 2 * 2 , 2 ) , 16 ) ; function lin2log ( n ) { return n <= 0.0031308 ? n * 12.92 : 1.055 * Math . pow ( n , 1 / 2.4 ) - 0.055 ; } function log2lin ( n ) { return n <= 0.04045 ? n / 12.92 : Math . pow ( ( ( n + 0.055 ) / 1.055 ) , 2.4 ) ; } r = log2lin ( r / 255 ) ; g = log2lin ( g / 255 ) ; b = log2lin ( b / 255 ) ; return lin2log ( 0.2126 * r + 0.7152 * g + 0.0722 * b ) * 100 ; }
2668	function command_exists ( paths , name ) { if ( is . string ( paths ) ) { paths = paths . split ( ':' ) ; } debug . assert ( paths ) . is ( 'array' ) ; return paths . some ( dir => fs . existsSync ( PATH . join ( dir , name ) ) ) ; }
2669	function qExec ( command , options ) { var d = Q . defer ( ) ; exec ( command , options , function ( err , stdout , stderr ) { if ( err ) { err . stdout = stdout ; err . stderr = stderr ; return d . reject ( err ) ; } return d . resolve ( stdout , stderr ) ; } ) ; return d . promise ; }
2670	function initDynamic ( ) { $ ( 'a[data-toggle=popover]' ) . popover ( ) . click ( function ( e ) { e . preventDefault ( ) ; } ) ; var version = $ ( '#version strong' ) . html ( ) ; $ ( '#sidenav li' ) . removeClass ( 'is-new' ) ; if ( apiProject . template . withCompare ) { $ ( '#sidenav li[data-version=\'' + \' + version ) . '\']' \' ; } each ( function ( ) { var group = $ ( this ) . data ( 'group' ) ; var name = $ ( this ) . data ( 'name' ) ; var length = $ ( '#sidenav li[data-group=\'' + \' + group + '\'][data-name=\'' + \' ) . \' ; name '\']' } ) \' length }
2671	function changeAllVersionCompareTo ( e ) { e . preventDefault ( ) ; $ ( 'article:visible .versions' ) . each ( function ( ) { var $root = $ ( this ) . parents ( 'article' ) ; var currentVersion = $root . data ( 'version' ) ; var $foundElement = null ; $ ( this ) . find ( 'li.version a' ) . each ( function ( ) { var selectVersion = $ ( this ) . html ( ) ; if ( selectVersion < currentVersion && ! $foundElement ) $foundElement = $ ( this ) ; } ) ; if ( $foundElement ) $foundElement . trigger ( 'click' ) ; } ) ; initDynamic ( ) ; }
2672	function addArticleSettings ( fields , entry ) { fields . id = fields . article . group + '-' + fields . article . name + '-' + fields . article . version ; fields . id = fields . id . replace ( / \. / g , '_' ) ; if ( entry . header && entry . header . fields ) fields . _hasTypeInHeaderFields = _hasTypeInFields ( entry . header . fields ) ; if ( entry . parameter && entry . parameter . fields ) fields . _hasTypeInParameterFields = _hasTypeInFields ( entry . parameter . fields ) ; if ( entry . error && entry . error . fields ) fields . _hasTypeInErrorFields = _hasTypeInFields ( entry . error . fields ) ; if ( entry . success && entry . success . fields ) fields . _hasTypeInSuccessFields = _hasTypeInFields ( entry . success . fields ) ; if ( entry . info && entry . info . fields ) fields . _hasTypeInInfoFields = _hasTypeInFields ( entry . info . fields ) ; fields . template = apiProject . template ; }
2673	function renderArticle ( group , name , version ) { var entry = { } ; $ . each ( apiByGroupAndName [ group ] [ name ] , function ( index , currentEntry ) { if ( currentEntry . version === version ) entry = currentEntry ; } ) ; var fields = { article : entry , versions : articleVersions [ group ] [ name ] } ; addArticleSettings ( fields , entry ) ; return templateArticle ( fields ) ; }
2674	function resetArticle ( group , name , version ) { var $root = $ ( 'article[data-group=\'' + \' + group + '\'][data-name=\'' + \' ) ; \' name '\']:visible' \' var content = renderArticle ( group , name , version ) ; $root . after ( content ) ; var $content = $root . next ( ) ; }
2675	function loadGoogleFontCss ( ) { var host = document . location . hostname . toLowerCase ( ) ; var protocol = document . location . protocol . toLowerCase ( ) ; var googleCss = '//fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:400,600,700' ; if ( host == 'localhost' || ! host . length || protocol === 'file:' ) googleCss = 'http:' + googleCss ; $ ( '<link/>' , { rel : 'stylesheet' , type : 'text/css' , href : googleCss } ) . appendTo ( 'head' ) ; }
2676	function sortByOrder ( elements , order , splitBy ) { var results = [ ] ; order . forEach ( function ( name ) { if ( splitBy ) elements . forEach ( function ( element ) { var parts = element . split ( splitBy ) ; var key = parts [ 1 ] ; if ( key == name ) results . push ( element ) ; } ) ; else elements . forEach ( function ( key ) { if ( key == name ) results . push ( name ) ; } ) ; } ) ; elements . forEach ( function ( element ) { if ( results . indexOf ( element ) === - 1 ) results . push ( element ) ; } ) ; return results ; }
2677	function browserifyNgInject ( opt ) { var options = defaults ( opt , { filter : defaultFilter } ) , updater = getUpdater ( throwError ) ; return esprimaTools . createTransform ( updater , options ) ; }
2678	function ( scope ) { if ( scope . model ) { var modelInData = false ; for ( var i = 0 ; i < scope . data . length ; i ++ ) { if ( angular . equals ( scope . data [ i ] , scope . model ) ) { scope . model = scope . data [ i ] ; modelInData = true ; break ; } } if ( ! modelInData ) { scope . model = null ; } } if ( ! scope . model && ! scope . chooseText && scope . data . length ) { scope . model = scope . data [ 0 ] ; } }
2679	function scopeUrl ( options , inst ) { options = _ . extend ( options || { } , inst ) if ( ! options . url && ! options . user_id && ! options . group_id && ! ( options . query || options . query . owner_type && options . query . owner_id ) ) { return callback ( new Error ( 'user_id or group_id or (owner_type and owner_id) are required' ) ) } if ( options . user_id ) { return ngin . User . urlRoot ( ) + '/' + options . user_id + '/personas' } if ( options . group_id ) { return ngin . Group . urlRoot ( ) + '/' + options . group_id + '/personas' } if ( options . url || options . query . owner_type && options . query . owner_id ) { return Persona . urlRoot ( ) } }
2680	function processNode ( node ) { var isVarAssignment = ( node . parent . type === 'VariableDeclarator' ) ; var params = node . params . map ( paramToLiteral ) ; if ( ( node . type === 'FunctionExpression' ) && ! isVarAssignment ) { esprimaTools . nodeSplicer ( node ) ( { parent : node . parent , type : 'ArrayExpression' , elements : params . concat ( node ) } ) ; } else { var appendTo = isVarAssignment ? node . parent . parent : node ; esprimaTools . nodeSplicer ( appendTo , offset ) ( { type : 'ExpressionStatement' , expression : { type : 'AssignmentExpression' , operator : '=' , left : { type : 'MemberExpression' , computed : false , object : { type : 'Identifier' , name : node . id . name } , property : { type : 'Identifier' , name : '$inject' } } , right : { type : 'ArrayExpression' , elements : params } } } ) ; } }
2681	function createApplication ( ) { function app ( req , res ) { app . handle ( req , res ) ; } utils . merge ( app , application ) ; utils . merge ( app , EventEmitter . prototype ) ; app . request = { __proto__ : req } ; app . response = { __proto__ : res } ; app . init ( ) ; return app ; }
2682	function ( ) { var chai = require ( 'chai' ) ; chai . should ( ) ; global . assert = chai . assert ; global . expect = chai . expect ; }
2683	function Company ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } Company . super_ . apply ( this , arguments ) ; }
2684	function inferAngular ( ast ) { return esprimaTools . breadthFirst ( ast ) . map ( getAnnotationCandidates ) . filter ( Boolean ) . map ( followReference ) . filter ( Boolean ) ; }
2685	function getAnnotationCandidates ( node ) { var callExpression = testNode . isModuleExpression ( node ) && node . parent ; if ( callExpression ) { return callExpression [ 'arguments' ] . filter ( testNode . anyOf ( testNode . isFunction , testNode . isIdentifier ) ) . pop ( ) ; } else { return null ; } }
2686	function followReference ( node ) { var result ; if ( testNode . isFunction ( node ) ) { return node ; } else { var name = node . name ; while ( node . parent && ! result ) { node = node . parent ; var isBlock = testNode . isBlockOrProgram ( node ) ; if ( isBlock ) { esprimaTools . breadthFirst ( node ) . some ( function eachNode ( subNode ) { switch ( subNode . type ) { case 'FunctionDeclaration' : if ( subNode . id . name === name ) { result = subNode ; } break ; case 'VariableDeclarator' : if ( subNode . id . name === name ) { result = subNode . init ; } break ; case 'AssignmentExpression' : if ( ( subNode . left . type === 'Identifier' ) && ( subNode . left . name === name ) ) { result = subNode . right ; } break ; } return ! ! result ; } ) ; } } return result ? followReference ( result ) : null ; } }
2687	function ( callback ) { try { TacitServer . app_server . close ( ) ; console . log ( TacitServer . configs . server_prefix + " - Shutdown app successful." ) ; } catch ( ex ) { console . log ( TacitServer . configs . server_prefix + " - Shutdown app failed." ) ; console . log ( ex ) ; } try { TacitServer . api_server . close ( ) ; console . log ( TacitServer . configs . server_prefix + " - Shutdown api successful." ) ; } catch ( ex ) { console . log ( TacitServer . configs . server_prefix + " - Shutdown api failed." ) ; console . log ( ex ) ; } console . log ( TacitServer . configs . server_prefix + " - All preparations for shutdown completed." ) ; callback ( ) ; }
2688	function transformBody ( req , input ) { req . log . debug ( 'attempting transformation' , input ) ; const body = input . data ; const { attributes } = body ; const { password , referral } = attributes ; const { autoGeneratePassword } = config ; if ( autoGeneratePassword === true && password ) { throw new Errors . ValidationError ( 'password is auto-generated, do not pass it' , 400 ) ; } if ( autoGeneratePassword === false && ! password ) { throw new Errors . ValidationError ( 'password must be provided' , 400 ) ; } const { country } = body ; if ( country && ! countryData . info ( country , 'ISO3' ) ) { const err = ` ` ; throw new Errors . ValidationError ( err , 400 , 'data.country' ) ; } const message = { username : body . id , metadata : ld . pick ( attributes , WHITE_LIST ) , activate : config . usersRequireActivate !== true || ! password , audience : getAudience ( ) , ipaddress : proxyaddr ( req , config . trustProxy ) , } ; if ( password ) { message . password = password ; } if ( attributes . alias ) { message . alias = attributes . alias . toLowerCase ( ) ; } if ( referral ) { message . referral = referral ; } if ( attributes . additionalInformation && ! message . metadata . longDescription ) { message . metadata . longDescription = attributes . additionalInformation ; } return message ; }
2689	function ( val , num , max ) { if ( max ) { var indx , len = val ? val . length : 0 , n = max + num ; for ( indx = 0 ; indx < len ; indx ++ ) { n += val . charCodeAt ( indx ) ; } return num * n ; } return 0 ; }
2690	function ( table ) { table = $ ( table ) [ 0 ] ; var overallWidth , percent , $tbodies , len , index , c = table . config , $colgroup = c . $table . children ( 'colgroup' ) ; if ( $colgroup . length && $colgroup . hasClass ( ts . css . colgroup ) ) { $colgroup . remove ( ) ; } if ( c . widthFixed && c . $table . children ( 'colgroup' ) . length === 0 ) { $colgroup = $ ( '<colgroup class="' + ts . css . colgroup + '">' ) ; overallWidth = c . $table . width ( ) ; $tbodies = c . $tbodies . find ( 'tr:first' ) . children ( ':visible' ) ; len = $tbodies . length ; for ( index = 0 ; index < len ; index ++ ) { percent = parseInt ( ( $tbodies . eq ( index ) . width ( ) / overallWidth ) * 1000 , 10 ) / 10 + '%' ; $colgroup . append ( $ ( '<col>' ) . css ( 'width' , percent ) ) ; } c . $table . prepend ( $colgroup ) ; } }
2691	function ( str ) { str = ( str || '' ) . replace ( ts . regex . spaces , ' ' ) . replace ( ts . regex . shortDateReplace , '/' ) ; return ts . regex . shortDateTest . test ( str ) ; }
2692	function checkCallExpression ( node ) { var callee = node . callee ; if ( callee . type === 'Identifier' && callee . name === 'require' ) { var pathNode = node . arguments [ 0 ] ; if ( pathNode . type === 'Literal' ) { var p = pathNode . value ; if ( startswith ( p , [ '/' , './' , '../' ] ) ) { return ! endswith ( p , '.js' ) ; } } } return true ; }
2693	function ( event , listener ) { switch ( event ) { case "log" : bus . subscribe ( EVENT_BUSLINE , { onRemoteLogReceived : function ( logObj ) { listener ( logObj ) ; } } ) ; break ; default : console . error ( "[LOGIA] Unknown event name: '" + event + "'" ) ; } }
2694	function createGitRepository ( basePath , options ) { if ( typeof ( options ) === "undefined" ) options = defaultRepositoryOptions ; var gitRepository = new GitRepository ( ) ; configureGitRepository ( gitRepository , basePath , options ) ; return gitRepository ; }
2695	function recoverPubKey ( curve , e , signature , i ) { assert . strictEqual ( i & 3 , i , 'Recovery param is more than two bits' ) var n = curve . n var G = curve . G var r = signature . r var s = signature . s assert ( r . signum ( ) > 0 && r . compareTo ( n ) < 0 , 'Invalid r value' ) assert ( s . signum ( ) > 0 && s . compareTo ( n ) < 0 , 'Invalid s value' ) var isYOdd = i & 1 var isSecondKey = i >> 1 var x = isSecondKey ? r . add ( n ) : r var R = curve . pointFromX ( isYOdd , x ) var nR = R . multiply ( n ) assert ( curve . isInfinity ( nR ) , 'nR is not a valid curve point' ) var eNeg = e . negate ( ) . mod ( n ) var rInv = r . modInverse ( n ) var Q = R . multiplyTwo ( s , G , eNeg ) . multiply ( rInv ) curve . validate ( Q ) return Q }
2696	function calcPubKeyRecoveryParam ( curve , e , signature , Q ) { for ( var i = 0 ; i < 4 ; i ++ ) { var Qprime = recoverPubKey ( curve , e , signature , i ) if ( Qprime . equals ( Q ) ) { return i } } throw new Error ( 'Unable to find valid recovery factor' ) }
2697	function ( permissions ) { _ . merge ( this . permissions , permissions , function ( a , b ) { return _ . isArray ( a ) ? a . concat ( b ) : undefined ; } ) ; return this ; }
2698	function ( roles ) { if ( ! Array . isArray ( roles ) ) { roles = [ roles ] ; } this . permissions = _ . reduce ( this . permissions , function ( result , actions , key ) { if ( roles . indexOf ( key ) === - 1 ) { result [ key ] = actions ; } return result ; } , { } ) ; return this ; }
2699	function DAOImplementation ( config ) { let basePath = config . basePath || 'backend/persistence/catalog/' ; let isDBloaded = true ; if ( config . filename ) { config . filename = basePath + config . filename ; } if ( config . schema ) { this . schema = fs . readJSON ( path . join ( appRoot . toString ( ) , basePath , config . schema ) ) ; } else { this . schema = { } ; } let db = new DataStore ( config ) ; if ( config . filename && ! config . autoload ) { isDBloaded = false ; } this . collection = db ; this . isDBloaded = isDBloaded ; }
2700	function Model ( attributes ) { this . _events = { } ; EventEmitter . call ( this ) ; attributes = attributes || { } ; this . _separator = ':' ; this . attributes = { } ; this . _changed = { } ; this . _silent = { } ; this . _pending = { } ; this . set ( attributes , { silent : true } ) ; this . _changes = { } ; this . _silent = { } ; this . _pending = { } ; this . _previous = _ . clone ( this . attributes ) ; this . initialize . apply ( this , arguments ) ; }
2701	function ProxiedModel ( attributes ) { var model ; if ( attributes instanceof Model ) { model = attributes ; } else { model = new Model ( attributes ) ; } return createModelProxy ( model ) ; }
2702	function createModelProxy ( model ) { var handle = { getOwnPropertyDescriptor : function ( target , name ) { return ObjProto . getOwnPropertyDescriptor . call ( model . attributes , name ) ; } , getOwnPropertyNames : function ( target ) { return ObjProto . getOwnPropertyNames . call ( model . attributes ) ; } , defineProperty : function ( name , propertyDescriptor ) { return Object . defineProperty ( model . attributes , name , propertyDescriptor ) ; } , get : function ( target , name , reciever ) { if ( model [ name ] ) { return model [ name ] ; } return model . get ( name ) ; } , set : function ( target , name , value , receiver ) { return model . set ( name , value ) ; } , delete : function ( name ) { model . unset ( name ) ; } , has : function ( target , name ) { return model . has ( 'name' ) ; } , hasOwn : function ( target , name ) { return this . has ( target , name ) ; } , enumerate : function ( target ) { return model . attributes ; } , keys : function ( target ) { return Object . keys ( model . attributes ) ; } } ; return ProxyCtor . create ( handle , Model ) ; }
2703	function ( target , name , reciever ) { if ( model [ name ] ) { return model [ name ] ; } return model . get ( name ) ; }
2704	function detectDestType ( dest ) { if ( grunt . util . _ . endsWith ( dest , '/' ) ) { return cnst . directory ; } else { return cnst . file ; } }
2705	function ( ) { return { r : Math . floor ( Math . random ( ) * 256 ) , g : Math . floor ( Math . random ( ) * 256 ) , b : Math . floor ( Math . random ( ) * 256 ) , a : 255 } ; }
2706	function ( fn ) { for ( var y = 0 ; y < this . getHeight ( ) ; y ++ ) { for ( var x = 0 ; x < this . getWidth ( ) ; x ++ ) { var rgba = this . getColor ( x , y ) ; var out = fn . call ( this , x , y , rgba ) ; this . setColor ( x , y , ( out || rgba ) ) ; } } return this ; }
2707	function ( x , y ) { var i = this . _getIndex ( x , y ) ; return { r : this . _png . data [ i + 0 ] , g : this . _png . data [ i + 1 ] , b : this . _png . data [ i + 2 ] , a : this . _png . data [ i + 3 ] } ; }
2708	function ( x , y , rgba ) { var i = this . _getIndex ( x , y ) ; var prev = this . getColor ( x , y ) ; this . _png . data [ i + 0 ] = is_num ( rgba . r ) ? to_rgba_int ( rgba . r ) : prev . r ; this . _png . data [ i + 1 ] = is_num ( rgba . g ) ? to_rgba_int ( rgba . g ) : prev . g ; this . _png . data [ i + 2 ] = is_num ( rgba . b ) ? to_rgba_int ( rgba . b ) : prev . b ; this . _png . data [ i + 3 ] = is_num ( rgba . a ) ? to_rgba_int ( rgba . a ) : prev . a ; return this . getColor ( x , y ) ; }
2709	function ( factor ) { factor = clamp ( to_int ( factor ) , 1 ) ; var width = this . getWidth ( ) * factor ; var height = this . getHeight ( ) * factor ; var buf = new buffer ( width , height ) ; for ( var y = 0 ; y < height ; y ++ ) { for ( var x = 0 ; x < width ; x ++ ) { var i = get_index ( width , x , y ) ; var rgba = this . getColor ( to_int ( x / factor ) , to_int ( y / factor ) ) ; buf [ i + 0 ] = rgba . r ; buf [ i + 1 ] = rgba . g ; buf [ i + 2 ] = rgba . b ; buf [ i + 3 ] = rgba . a ; } } this . _png . width = width ; this . _png . height = height ; this . _png . data = buf ; return this ; }
2710	function ( fn ) { fn = fn || console . log . bind ( console ) ; var buffers = [ ] ; var base64 = new Stream ( ) ; base64 . readable = base64 . writable = true ; base64 . write = function ( data ) { buffers . push ( data ) ; } ; base64 . end = function ( ) { fn ( Buffer . concat ( buffers ) . toString ( 'base64' ) ) ; } this . _png . pack ( ) . pipe ( base64 ) ; }
2711	function ( fn ) { fn = fn || console . log . bind ( console ) ; return this . toBase64 ( function ( str ) { fn ( 'data:image/png;base64,' + str ) ; } ) ; }
2712	function deepest ( a , b , ca , cb ) { if ( a === b ) { return true ; } else if ( typeof a !== 'object' || typeof b !== 'object' ) { return false ; } else if ( a === null || b === null ) { return false ; } else if ( Buffer . isBuffer ( a ) && Buffer . isBuffer ( b ) ) { if ( fastEqual ) { return fastEqual . call ( a , b ) ; } else { if ( a . length !== b . length ) return false ; for ( var i = 0 ; i < a . length ; i ++ ) if ( a [ i ] !== b [ i ] ) return false ; return true ; } } else if ( a instanceof Date && b instanceof Date ) { return a . getTime ( ) === b . getTime ( ) ; } else if ( isArguments ( a ) || isArguments ( b ) ) { if ( ! ( isArguments ( a ) && isArguments ( b ) ) ) return false ; var slice = Array . prototype . slice ; return deepest ( slice . call ( a ) , slice . call ( b ) , ca , cb ) ; } else { if ( a . constructor !== b . constructor ) return false ; var pa = Object . getOwnPropertyNames ( a ) ; var pb = Object . getOwnPropertyNames ( b ) ; if ( pa . length !== pb . length ) return false ; var cal = ca . length ; while ( cal -- ) if ( ca [ cal ] === a ) return cb [ cal ] === b ; ca . push ( a ) ; cb . push ( b ) ; pa . sort ( ) ; pb . sort ( ) ; for ( var j = pa . length - 1 ; j >= 0 ; j -- ) if ( pa [ j ] !== pb [ j ] ) return false ; var name , da , db ; for ( var k = pa . length - 1 ; k >= 0 ; k -- ) { name = pa [ k ] ; da = Object . getOwnPropertyDescriptor ( a , name ) ; db = Object . getOwnPropertyDescriptor ( b , name ) ; if ( da . enumerable !== db . enumerable || da . writable !== db . writable || da . configurable !== db . configurable || da . get !== db . get || da . set !== db . set ) { return false ; } if ( ! deepest ( da . value , db . value , ca , cb ) ) return false ; } ca . pop ( ) ; cb . pop ( ) ; return true ; } }
2713	function assertParasite ( fn ) { return function _deeperAssert ( ) { if ( this . _bailedOut ) return ; var res = fn . apply ( tap . assert , arguments ) ; this . result ( res ) ; return res ; } ; }
2714	function getIgnored ( filepath ) { for ( var i in options . ignore ) { if ( filepath . indexOf ( options . ignore [ i ] ) !== - 1 ) { return options . ignore [ i ] ; } } return null ; }
2715	function renderInputPrompt ( ) { process . stdout . write ( prefix ) ; process . stdout . write ( textToRender . join ( '' ) ) ; }
2716	function calculateFieldColor ( selectedColor , nonSelectedColor , focusedColor , index , out ) { if ( selected . indexOf ( index ) !== - 1 && focused == index ) return chalk . bold . rgb ( selectedColor . r , selectedColor . g , selectedColor . b ) ( out ) ; if ( selected . indexOf ( index ) !== - 1 ) return chalk . rgb ( selectedColor . r , selectedColor . g , selectedColor . b ) ( out ) ; if ( focused == index ) return chalk . bold . rgb ( focusedColor . r , focusedColor . g , focusedColor . b ) ( out ) ; return chalk . rgb ( nonSelectedColor . r , nonSelectedColor . g , nonSelectedColor . b ) ( out ) ; }
2717	function render ( errors ) { if ( ! errors ) { return '' ; } ; return errors . map ( function ( error ) { return error . line + ':' + error . column + ' ' + ' - ' + error . message + ' (' + error . ruleId + ')' ; } ) . join ( '\n' ) ; }
2718	function ( url ) { let request = parseRequest ( url ) ; let resource = getRequestedResource ( request ) ; return resource . get ( request ) . then ( returnGetResponse ) ; function returnGetResponse ( result ) { return new RESTResponse ( url , "GET" , result ) ; } }
2719	function ( url , data ) { let request = parseRequest ( url , data ) ; let resource = getRequestedResource ( request ) ; return resource . put ( request ) . then ( returnResponse ) ; function returnResponse ( result ) { return new RESTResponse ( url , "PUT" , result ) ; } }
2720	function mapPrune ( input , schema ) { var result = { } ; _ . forOwn ( schema , function ( value , key ) { if ( _ . isPlainObject ( value ) ) { result [ key ] = mapPrune ( input [ key ] || { } , value ) ; } else { result [ key ] = input [ key ] || null ; } } ) ; return result ; }
2721	function createYamlSchema ( customTypes ) { var yamlTypes = [ ] ; _ . each ( customTypes , function ( resolver , tagAndKindString ) { var tagAndKind = tagAndKindString . split ( / \s+ / ) , yamlType = new yaml . Type ( tagAndKind [ 0 ] , { kind : tagAndKind [ 1 ] , construct : function ( data ) { var result = resolver . call ( this , data , loadYamlFile ) ; if ( _ . isUndefined ( result ) || _ . isFunction ( result ) ) { return null ; } else { return result ; } } } ) ; yamlTypes . push ( yamlType ) ; } ) ; return yaml . Schema . create ( yamlTypes ) ; }
2722	function loadYamlFile ( filepath ) { try { return yaml . safeLoad ( fs . readFileSync ( filepath ) , { schema : yamlSchema , filename : filepath } ) ; } catch ( err ) { return null ; } }
2723	function loadTheme ( props ) { var relPath = '/' + props . join ( '/' ) + '.yml' , defaultsPath = path . resolve ( base + '/scss/themes/default' + relPath ) , customPath = ( custom ) ? custom + relPath : null , defaultVars = { } , customVars = null , result = { } ; customVars = loadYamlFile ( customPath ) ; if ( customVars && customVars [ 'merge-mode' ] === 'replace' ) { result = _ . omit ( customVars , 'merge-mode' ) ; } else { defaultVars = loadYamlFile ( defaultsPath ) ; result = _ . merge ( defaultVars , customVars ) ; } _ . set ( theme , props . join ( '.' ) , result ) ; return result ; }
2724	function luiTheme ( props ) { var propsS = ( _ . isArray ( props ) ) ? props . join ( '.' ) : props , propsA = ( _ . isString ( props ) ) ? props . split ( '.' ) : props , objectVars , objectPath = [ ] ; objectVars = _ . result ( theme , propsS ) ; if ( objectVars ) { return objectVars ; } else { _ . each ( propsA , function ( prop ) { if ( _ . result ( build , _ . union ( objectPath , [ prop ] ) . join ( '.' ) ) || ( _ . includes ( _ . result ( build , objectPath . join ( '.' ) ) , prop ) ) ) { objectPath . push ( prop ) ; } else { return objectPath ; } } ) ; loadTheme ( objectPath ) ; return _ . result ( theme , propsS ) ; } }
2725	function write ( destination , data , callback ) { mkdirp ( path . dirname ( destination ) , null , ( err , made ) => { if ( err ) { console . error ( err ) ; } else { fs . writeFile ( destination , data , ( err ) => { if ( err ) { console . error ( err ) ; } if ( typeof ( callback ) == 'function' ) { callback ( destination , data ) ; } } ) ; } } ) ; return destination ; }
2726	function init ( _options ) { var options = _ . merge ( defaults , _options ) ; base = options . base ; custom = options . custom ; build = options . build = ( typeof options . build === 'object' ) ? options . build : require ( options . build ) ; yamlSchema = createYamlSchema ( options . customTypes ) ; return options ; }
2727	function redact ( _options , callback ) { var imports = [ ] , output = '' , errors = [ ] ; theme [ 'core' ] = { } ; _ . each ( _options . build . core , function ( objects , family ) { theme [ 'core' ] [ family ] = { } ; _ . each ( objects , function ( objectName ) { luiTheme ( 'core.' + family + '.' + objectName ) ; imports . push ( 'core/' + family + '/' + objectName ) ; } ) ; } ) ; if ( _options . build . plugins ) { theme [ 'plugins' ] = { } ; _ . each ( _options . build . plugins , function ( plugin ) { luiTheme ( 'plugins.' + plugin ) ; } ) ; } output = tosass . format ( { theme : theme , imports : imports } ) ; if ( typeof ( callback ) === 'function' ) { callback ( output ) ; } return output ; }
2728	function ( _options , callback ) { var options = init ( _options ) ; return write ( options . dest , redact ( options ) , callback ) ; }
2729	function ( map ) { return '(' + Object . keys ( map ) . map ( function ( key ) { return key + ': ' + parseValue ( map [ key ] ) ; } ) . join ( ',' ) + ')' ; }
2730	function objectToSass ( object ) { return Object . keys ( object ) . map ( function ( key ) { return '$' + key + ': ' + parseValue ( object [ key ] ) + ';' ; } ) . join ( '\n' ) ; }
2731	function parseValue ( value ) { if ( _ . isArray ( value ) ) return converters . list ( value ) ; else if ( _ . isPlainObject ( value ) ) return converters . map ( value ) ; else return value ; }
2732	function domSafeRandomGuid ( ) { var _arguments = arguments ; var _again = true ; _function : while ( _again ) { numberOfBlocks = output = num = undefined ; var s4 = function s4 ( ) { return Math . floor ( ( 1 + Math . random ( ) ) * 65536 ) . toString ( 16 ) . substring ( 1 ) ; } ; _again = false ; var numberOfBlocks = _arguments [ 0 ] === undefined ? 4 : _arguments [ 0 ] ; var output = '' ; var num = numberOfBlocks ; while ( num > 0 ) { output += s4 ( ) ; if ( num > 1 ) output += '-' ; num -- ; } if ( null === document . getElementById ( output ) ) { return output ; } else { _arguments = [ numberOfBlocks ] ; _again = true ; continue _function ; } } }
2733	function objectProperty ( obj , indentLength = 1 , inArray = 0 ) { if ( Object . keys ( obj ) . length === 0 ) { return ' {}' ; } let str = '\n' ; \n const objectPrefix = getPrefix ( indentLength , indentChars ) ; Object . keys ( obj ) . forEach ( ( name ) => { const value = obj [ name ] ; const type = typeOf ( value ) ; const inArrayPrefix = getPrefix ( inArray , ' ' ) ; const afterPropsIndent = NO_INDENT_TYPES . includes ( type ) ? '' : ' ' ; const valueString = checkCircular ( value ) ? ' [Circular]' : typifiedString ( type , value , indentLength + 1 , inArray ) ; str += ` ${ inArrayPrefix } ${ objectPrefix } ${ name } ${ afterPropsIndent } ${ valueString } \n ` ; } ) ; }
2734	function arrayProperty ( values , indentLength = 1 , inArray = 0 ) { if ( values . length === 0 ) { return ' []' ; } let str = '\n' ; \n const arrayPrefix = getPrefix ( indentLength , indentChars ) ; values . forEach ( ( value ) => { const type = typeOf ( value ) ; const inArrayPrefix = getPrefix ( inArray , ' ' ) ; const valueString = checkCircular ( value ) ? '[Circular]' : typifiedString ( type , value , indentLength , inArray + 1 ) . toString ( ) . trimLeft ( ) ; str += ` ${ inArrayPrefix } ${ arrayPrefix } ${ valueString } \n ` ; } ) ; }
2735	function RESTResponse ( url , method , body ) { this . request = { url : url , method : method } ; this . body = body || "" ; this . status = "200" ; }
2736	function ( map , receive ) { var entries = mapEntries . call ( map ) ; var next ; do { next = entries . next ( ) ; } while ( ! next . done && receive ( next . value ) ) ; }
2737	function ( component ) { var id = component . getId ( ) ; if ( this . map [ id ] ) { Ext . Logger . warn ( 'Registering a component with a id (`' + id + '`) which has already been used. Please ensure the existing component has been destroyed (`Ext.Component#destroy()`.' ) ; } this . map [ component . getId ( ) ] = component ; }
2738	function ( component , defaultType ) { if ( component . isComponent ) { return component ; } else if ( Ext . isString ( component ) ) { return Ext . createByAlias ( 'widget.' + component ) ; } else { var type = component . xtype || defaultType ; return Ext . createByAlias ( 'widget.' + type , component ) ; } }
2739	function rns ( ) { let jargv = _ . $ ( 'env.jargv' ) let key = _ . get ( jargv , '_[0]' ) let prop = key ? _ . get ( snapptop , key ) : null if ( ! _ . isFunction ( prop ) ) return _ . log ( ` \n ${ key || 'NO KEY' } \n ` ) _ . log ( ` \n ${ key } \n ` ) _ . log ( jargv ) _ . log ( ) jargv = _ . omit ( jargv , [ '_' ] ) var ret = _ . attempt ( prop , jargv , ( err , result ) => { if ( err ) return _ . log ( err ) _ . log ( result ) } ) if ( _ . isError ( ret ) ) _ . log ( ret ) return ret }
2740	function ( node ) { var result = '' , i , n , attr , child ; if ( node . nodeType === document . TEXT_NODE ) { return node . nodeValue ; } result += '<' + node . nodeName ; if ( node . attributes . length ) { for ( i = 0 , n = node . attributes . length ; i < n ; i ++ ) { attr = node . attributes [ i ] ; result += ' ' + attr . name + '="' + attr . value + '"' ; } } result += '>' ; if ( node . childNodes && node . childNodes . length ) { for ( i = 0 , n = node . childNodes . length ; i < n ; i ++ ) { child = node . childNodes [ i ] ; result += this . serializeNode ( child ) ; } } result += '</' + node . nodeName + '>' ; return result ; }
2741	function ( name , namespace ) { var dom = this . dom ; return dom . getAttributeNS ( namespace , name ) || dom . getAttribute ( namespace + ":" + name ) || dom . getAttribute ( name ) || dom [ name ] ; }
2742	function ( rules ) { this . _instantiatedDate = new Date ( ) ; this . _instanceCount = 0 ; this . _propertyCount = 0 ; this . _collatedInstances = null ; this . _rules = ( rules && this . _checkRules ( rules ) ) || [ ] ; this . initEventualSchema ( ) ; }
2743	function ( sorters , defaultDirection ) { var currentSorters = this . getSorters ( ) ; return this . insertSorters ( currentSorters ? currentSorters . length : 0 , sorters , defaultDirection ) ; }
2744	function ( index , sorters , defaultDirection ) { if ( ! Ext . isArray ( sorters ) ) { sorters = [ sorters ] ; } var ln = sorters . length , direction = defaultDirection || this . getDefaultSortDirection ( ) , sortRoot = this . getSortRoot ( ) , currentSorters = this . getSorters ( ) , newSorters = [ ] , sorterConfig , i , sorter , currentSorter ; if ( ! currentSorters ) { currentSorters = this . createSortersCollection ( ) ; } for ( i = 0 ; i < ln ; i ++ ) { sorter = sorters [ i ] ; sorterConfig = { direction : direction , root : sortRoot } ; if ( typeof sorter === 'string' ) { currentSorter = currentSorters . get ( sorter ) ; if ( ! currentSorter ) { sorterConfig . property = sorter ; } else { if ( defaultDirection ) { currentSorter . setDirection ( defaultDirection ) ; } else { currentSorter . toggle ( ) ; } continue ; } } else if ( Ext . isFunction ( sorter ) ) { sorterConfig . sorterFn = sorter ; } else if ( Ext . isObject ( sorter ) ) { if ( ! sorter . isSorter ) { if ( sorter . fn ) { sorter . sorterFn = sorter . fn ; delete sorter . fn ; } sorterConfig = Ext . apply ( sorterConfig , sorter ) ; } else { newSorters . push ( sorter ) ; if ( ! sorter . getRoot ( ) ) { sorter . setRoot ( sortRoot ) ; } continue ; } } else { Ext . Logger . warn ( 'Invalid sorter specified:' , sorter ) ; } sorter = Ext . create ( 'Ext.util.Sorter' , sorterConfig ) ; newSorters . push ( sorter ) ; } for ( i = 0 , ln = newSorters . length ; i < ln ; i ++ ) { currentSorters . insert ( index + i , newSorters [ i ] ) ; } this . dirtySortFn = true ; if ( currentSorters . length ) { this . sorted = true ; } return currentSorters ; }
2745	function ( sorters ) { if ( ! Ext . isArray ( sorters ) ) { sorters = [ sorters ] ; } var ln = sorters . length , currentSorters = this . getSorters ( ) , i , sorter ; for ( i = 0 ; i < ln ; i ++ ) { sorter = sorters [ i ] ; if ( typeof sorter === 'string' ) { currentSorters . removeAtKey ( sorter ) ; } else if ( typeof sorter === 'function' ) { currentSorters . each ( function ( item ) { if ( item . getSorterFn ( ) === sorter ) { currentSorters . remove ( item ) ; } } ) ; } else if ( sorter . isSorter ) { currentSorters . remove ( sorter ) ; } } if ( ! currentSorters . length ) { this . sorted = false ; } }
2746	function ( items , item , sortFn , containsItem ) { var start = 0 , end = items . length - 1 , sorterFn = sortFn || this . getSortFn ( ) , middle , comparison ; while ( start < end || start === end && ! containsItem ) { middle = ( start + end ) >> 1 ; var middleItem = items [ middle ] ; if ( middleItem === item ) { start = middle ; break ; } comparison = sorterFn ( item , middleItem ) ; if ( comparison > 0 || ( ! containsItem && comparison === 0 ) ) { start = middle + 1 ; } else if ( comparison < 0 ) { end = middle - 1 ; } else if ( containsItem && ( start !== end ) ) { start = middle + 1 ; } } return start ; }
2747	function ( attribute , newValue ) { var input = this . input ; if ( ! Ext . isEmpty ( newValue , true ) ) { input . dom . setAttribute ( attribute , newValue ) ; } else { input . dom . removeAttribute ( attribute ) ; } }
2748	function ( ) { var el = this . input , checked ; if ( el ) { checked = el . dom . checked ; this . _checked = checked ; } return checked ; }
2749	function ( ) { var me = this , el = me . input ; if ( el && el . dom . focus ) { el . dom . focus ( ) ; } return me ; }
2750	function ( ) { var me = this , el = this . input ; if ( el && el . dom . blur ) { el . dom . blur ( ) ; } return me ; }
2751	function ( ) { var me = this , el = me . input ; if ( el && el . dom . setSelectionRange ) { el . dom . setSelectionRange ( 0 , 9999 ) ; } return me ; }
2752	function ( date , format ) { if ( utilDate . formatFunctions [ format ] == null ) { utilDate . createFormat ( format ) ; } var result = utilDate . formatFunctions [ format ] . call ( date ) ; return result + '' ; }
2753	function ( date , interval , value ) { var d = Ext . Date . clone ( date ) ; if ( ! interval || value === 0 ) return d ; switch ( interval . toLowerCase ( ) ) { case Ext . Date . MILLI : d = new Date ( d . valueOf ( ) + value ) ; break ; case Ext . Date . SECOND : d = new Date ( d . valueOf ( ) + value * 1000 ) ; break ; case Ext . Date . MINUTE : d = new Date ( d . valueOf ( ) + value * 60000 ) ; break ; case Ext . Date . HOUR : d = new Date ( d . valueOf ( ) + value * 3600000 ) ; break ; case Ext . Date . DAY : d = new Date ( d . valueOf ( ) + value * 86400000 ) ; break ; case Ext . Date . MONTH : var day = date . getDate ( ) ; if ( day > 28 ) { day = Math . min ( day , Ext . Date . getLastDateOfMonth ( Ext . Date . add ( Ext . Date . getFirstDateOfMonth ( date ) , 'mo' , value ) ) . getDate ( ) ) ; } d . setDate ( day ) ; d . setMonth ( date . getMonth ( ) + value ) ; break ; case Ext . Date . YEAR : d . setFullYear ( date . getFullYear ( ) + value ) ; break ; } return d ; }
2754	function ( min , max , unit ) { var ExtDate = Ext . Date , est , diff = + max - min ; switch ( unit ) { case ExtDate . MILLI : return diff ; case ExtDate . SECOND : return Math . floor ( diff / 1000 ) ; case ExtDate . MINUTE : return Math . floor ( diff / 60000 ) ; case ExtDate . HOUR : return Math . floor ( diff / 3600000 ) ; case ExtDate . DAY : return Math . floor ( diff / 86400000 ) ; case 'w' : return Math . floor ( diff / 604800000 ) ; case ExtDate . MONTH : est = ( max . getFullYear ( ) * 12 + max . getMonth ( ) ) - ( min . getFullYear ( ) * 12 + min . getMonth ( ) ) ; if ( Ext . Date . add ( min , unit , est ) > max ) { return est - 1 ; } else { return est ; } case ExtDate . YEAR : est = max . getFullYear ( ) - min . getFullYear ( ) ; if ( Ext . Date . add ( min , unit , est ) > max ) { return est - 1 ; } else { return est ; } } }
2755	function ( date , unit , step ) { var num = new Date ( + date ) ; switch ( unit . toLowerCase ( ) ) { case Ext . Date . MILLI : return num ; break ; case Ext . Date . SECOND : num . setUTCSeconds ( num . getUTCSeconds ( ) - num . getUTCSeconds ( ) % step ) ; num . setUTCMilliseconds ( 0 ) ; return num ; break ; case Ext . Date . MINUTE : num . setUTCMinutes ( num . getUTCMinutes ( ) - num . getUTCMinutes ( ) % step ) ; num . setUTCSeconds ( 0 ) ; num . setUTCMilliseconds ( 0 ) ; return num ; break ; case Ext . Date . HOUR : num . setUTCHours ( num . getUTCHours ( ) - num . getUTCHours ( ) % step ) ; num . setUTCMinutes ( 0 ) ; num . setUTCSeconds ( 0 ) ; num . setUTCMilliseconds ( 0 ) ; return num ; break ; case Ext . Date . DAY : if ( step == 7 || step == 14 ) { num . setUTCDate ( num . getUTCDate ( ) - num . getUTCDay ( ) + 1 ) ; } num . setUTCHours ( 0 ) ; num . setUTCMinutes ( 0 ) ; num . setUTCSeconds ( 0 ) ; num . setUTCMilliseconds ( 0 ) ; return num ; break ; case Ext . Date . MONTH : num . setUTCMonth ( num . getUTCMonth ( ) - ( num . getUTCMonth ( ) - 1 ) % step , 1 ) ; num . setUTCHours ( 0 ) ; num . setUTCMinutes ( 0 ) ; num . setUTCSeconds ( 0 ) ; num . setUTCMilliseconds ( 0 ) ; return num ; break ; case Ext . Date . YEAR : num . setUTCFullYear ( num . getUTCFullYear ( ) - num . getUTCFullYear ( ) % step , 1 , 1 ) ; num . setUTCHours ( 0 ) ; num . setUTCMinutes ( 0 ) ; num . setUTCSeconds ( 0 ) ; num . setUTCMilliseconds ( 0 ) ; return date ; break ; } }
2756	function getOptions ( messageType ) { const options = Object . assign ( { } , _defaults ) ; if ( messageType in _options ) { Object . assign ( options , _options [ messageType ] ) ; } return options ; }
2757	function parse ( messageType , args ) { const options = getOptions ( messageType ) ; if ( typeof options . interpreter === "function" ) { for ( const index in args ) { if ( typeof args [ index ] === "string" ) { continue ; } args [ index ] = options . interpreter ( args [ index ] ) ; } } if ( options . labels ) { args . unshift ( ` ${ messageType . toUpperCase ( ) } ` ) ; } if ( options . timestamp ) { switch ( typeof options . timestamp ) { case "boolean" : args . unshift ( ` ${ new Date ( ) . toLocaleString ( ) } ` ) ; break ; case "string" : args . unshift ( ` ${ moment ( ) . format ( options . timestamp ) } ` ) ; break ; default : throw new Error ( ` ${ typeof options . timestamp } ` ) ; } } return args . join ( " " ) ; }
2758	function stdout ( messageType ) { return ( ... args ) => { const options = getOptions ( messageType ) ; let message = parse ( messageType , args ) ; if ( messageType === "trace" ) { message += ` \n ${ getTrace ( ) } ` ; } if ( ! options . fileOnly ) { _console . log ( message ) ; } if ( typeof options . filePath === "string" && options . filePath . length > 0 ) { fs . appendFileSync ( options . filePath , ` ${ message } \n ` ) ; } } ; }
2759	function assignOptions ( defaults , userDefined ) { for ( const optionKey in userDefined ) { if ( defaults . hasOwnProperty ( optionKey ) ) { defaults [ optionKey ] = userDefined [ optionKey ] ; } else { throw new Error ( ` ${ optionKey } ` ) ; } } return defaults ; }
2760	function ( pagesPath , allPartials ) { if ( options . verbose ) { grunt . log . writeln ( '- using pages path: %s' , pagesPath ) ; } var allPages = { } ; if ( grunt . file . exists ( options . src + '/globals.json' ) ) { fileGlobals = grunt . file . readJSON ( options . src + '/globals.json' ) ; gruntGlobals = mergeObj ( gruntGlobals , fileGlobals ) ; } grunt . file . recurse ( pagesPath , function ( absPath , rootDir , subDir , fileName ) { if ( ! fileName . match ( tplMatcher ) ) { if ( options . verbose ) { grunt . log . writeln ( '-- ignoring file: %s' , fileName ) ; } return ; } var pageName = absPath . replace ( rootDir , '' ) . replace ( tplMatcher , '' ) . substring ( 1 ) , pageSrc = grunt . file . read ( absPath ) , pageJson = { } , dataPath = absPath . replace ( tplMatcher , '.json' ) , compiledPage = Hogan . compile ( pageSrc ) ; if ( options . verbose ) { grunt . log . writeln ( '-- compiled page: %s' , pageName ) ; } if ( grunt . file . exists ( dataPath ) ) { if ( options . verbose ) { grunt . log . writeln ( '--- using page data from: %s' , dataPath ) ; } pageJson = grunt . file . readJSON ( dataPath ) ; pageData [ pageName ] = mergeObj ( gruntGlobals , pageJson ) ; if ( options . verbose ) { grunt . log . writeln ( '--- json for %s' , pageName , pageData [ pageName ] ) ; } } else { pageData [ pageName ] = gruntGlobals ; } allPages [ pageName ] = compiledPage . render ( pageData [ pageName ] , allPartials ) ; } ) ; return allPages ; }
2761	function ( result ) { if ( fd && result . slice ( 0 , 3 ) !== '[D]' && result . match ( / \u001b\[ / g ) === null ) { fs . writeSync ( fd , result ) ; } if ( options . quiet ) { return hooker . preempt ( ) ; } }
2762	function ( cb , param ) { return function ( ) { var args = Array . prototype . slice . call ( arguments , 1 ) ; if ( typeof param !== 'undefined' ) { args . unshift ( param ) ; } else if ( arguments . length === 1 ) { args . unshift ( arguments [ 0 ] ) ; } args . unshift ( null ) ; cb . apply ( null , args ) ; } ; }
2763	function ( callback ) { if ( tunnel ) { return callback ( null ) ; } grunt . log . debug ( 'checking if selenium is running' ) ; var options = { host : capabilities . host || 'localhost' , port : capabilities . port || 4444 , path : '/wd/hub/status' } ; http . get ( options , function ( ) { grunt . log . debug ( 'selenium is running' ) ; isSeleniumServerRunning = true ; callback ( null ) ; } ) . on ( 'error' , function ( ) { grunt . log . debug ( 'selenium is not running' ) ; callback ( null ) ; } ) ; }
2764	function ( callback ) { if ( tunnel || isSeleniumServerRunning ) { return callback ( null ) ; } grunt . log . debug ( 'installing driver if needed' ) ; selenium . install ( options . seleniumInstallOptions , function ( err ) { if ( err ) { return callback ( err ) ; } grunt . log . debug ( 'driver installed' ) ; callback ( null ) ; } ) ; }
2765	function ( ) { var callback = arguments [ arguments . length - 1 ] ; grunt . log . debug ( 'init WebdriverIO instance' ) ; GLOBAL . browser . init ( function ( err ) { callback ( err ) ; } ) ; }
2766	function ( callback ) { grunt . log . debug ( 'run mocha tests' ) ; sessionID = GLOBAL . browser . requestHandler . sessionID ; mocha . run ( next ( callback ) ) ; }
2767	function ( result , callback ) { grunt . log . debug ( 'end selenium session' ) ; unmanageExceptions ( ) ; GLOBAL . browser . end ( next ( callback , result === 0 ) ) ; }
2768	function ( result ) { var callback = arguments [ arguments . length - 1 ] ; if ( ! options . user && ! options . key && ! options . updateSauceJob ) { return callback ( null , result ) ; } grunt . log . debug ( 'update job on Sauce Labs' ) ; var sauceAccount = new SauceLabs ( { username : options . user , password : options . key } ) ; sauceAccount . updateJob ( sessionID , { passed : result , public : true } , next ( callback , result ) ) ; }
2769	function ( result ) { var callback = arguments [ arguments . length - 1 ] ; grunt . log . debug ( 'finish grunt task' ) ; if ( isLastTask ) { if ( fd ) { fs . closeSync ( fd ) ; } hooker . unhook ( process . stdout , 'write' ) ; } done ( result ) ; callback ( ) ; }
2770	function render ( req , res , body ) { var response = { } ; var parsedURL = parseURL ( req . url ) ; for ( var prop in parsedURL ) response [ prop ] = parsedURL [ prop ] ; [ 'method' , 'url' ] . forEach ( function ( prop ) { response [ prop ] = req [ prop ] ; } ) ; [ 'headers' , 'statusCode' ] . forEach ( function ( prop ) { response [ prop ] = res [ prop ] ; } ) ; response . body = body ; return response ; }
2771	function ( val , key ) { const optVal = _M . _option . getIn ( key ) ; if ( optVal !== null ) { if ( _ . isObject ( optVal ) ) { _M . _option . mergeIn ( key , _ . defaultsDeep ( val , _M . _option . getIn ( key ) ) ) ; } else { _M . _option . mergeIn ( key , val ) ; } } }
2772	function ( optionObj ) { if ( _ . hasIn ( optionObj , [ 'transitionDefault' ] ) ) { _M . _option . updateTransDefault ( optionObj . transitionDefault ) ; delete optionObj . transitionDefault ; } _ . each ( optionObj , function ( val , key ) { if ( _ . isObject ( val ) ) { _ . each ( val , function ( _val , _key ) { mergeOption ( _val , [ key , _key ] ) ; } ) ; } else { mergeOption ( val , [ key ] ) ; } } ) ; }
2773	function ( key , keyType , funk , passKey = true ) { if ( _H . util . regularExp . keyTest ( key , keyType ) ) { const data = self . doNotUse ( objectArgs . get ( key ) , keyType ) ; if ( ! data ) { return true ; } if ( passKey ) { funk ( key , data , target , keyType ) ; } else { funk ( data , target , keyType , key ) ; } return true ; } }
2774	function ( sourceObj ) { for ( const property in sourceObj ) { if ( sourceObj . hasOwnProperty ( property ) ) { if ( _ . isPlainObject ( sourceObj [ property ] ) ) { const use = _ . get ( sourceObj [ property ] , 'use' ) ; if ( useIsFalse ( use ) ) { sourceObj = _ . omit ( sourceObj , property ) ; } else { if ( useIsTrue ( use ) ) { sourceObj [ property ] = _ . omit ( sourceObj [ property ] , 'use' ) ; } sourceObj [ property ] = searchObject ( sourceObj [ property ] ) ; } } } } return sourceObj ; }
2775	function add ( reducers , scope , defaultState ) { if ( scope === undefined ) scope = "general" ; _combines [ scope ] !== undefined || defineReducer ( scope ) ; var scopeReducers = _reducers [ scope ] || { } ; for ( var type in reducers ) { var reducer = reducers [ type ] ; if ( typeof reducer === 'function' ) { if ( scopeReducers [ type ] === undefined ) { scopeReducers [ type ] = [ reducer ] ; } else { scopeReducers [ type ] . push ( reducer ) ; } } } if ( defaultState !== undefined ) { scopeReducers . _default = defaultState ; } _reducers [ scope ] = scopeReducers ; }
2776	function remove ( scope , type ) { if ( scope === undefined ) scope = "general" ; if ( type === undefined ) { delete _combines [ scope ] ; delete _reducers [ scope ] ; } else { delete _reducers [ scope ] [ type ] ; } }
2777	function replace ( reducers , scope , defaultState ) { remove ( scope ) ; add ( reducers , scope , defaultState ) ; }
2778	function toInteger ( value ) { if ( ! value ) { return value === 0 ? value : 0 ; } value = toNumber ( value ) ; if ( value === INFINITY || value === - INFINITY ) { var sign = ( value < 0 ? - 1 : 1 ) ; return sign * MAX_INTEGER ; } var remainder = value % 1 ; return value === value ? ( remainder ? value - remainder : value ) : 0 ; }
2779	function writeError ( type , file , line , message ) { if ( ! messages [ type ] ) { messages [ type ] = [ ] ; } messages [ type ] . push ( { type : type , file : file , line : line , message : message } ) ; }
2780	function flushMessages ( ) { Object . keys ( messages ) . forEach ( function ( type ) { messages [ type ] . forEach ( function ( msg ) { writeLine ( msg . type + " error: [" + msg . file + ":" + msg . line + "] " + msg . message ) ; } ) ; } ) ; }
2781	function getConfig ( file ) { var config = { } , subConfig ; try { config = JSON . parse ( fs . readFileSync ( file , "utf8" ) ) ; if ( config . extends ) { subConfig = JSON . parse ( fs . readFileSync ( config . extends , "utf8" ) ) ; util . _extend ( subConfig , config ) ; delete subConfig . extends ; config = subConfig ; } } catch ( e ) { } return config ; }
2782	function isIgnored ( file ) { return ignorePatterns . some ( function ( pattern ) { return minimatch ( file , pattern , { nocase : true , matchBase : true } ) ; } ) ; }
2783	function extractStyles ( src ) { var isInBlock = false , lines = [ ] ; src . replace ( / \r / g , "" ) . split ( "\n" ) . \n forEach ; ( function ( l ) { if ( l . indexOf ( "</style" ) > - 1 ) { lines [ lines . length ] = "" ; isInBlock = false ; return ; } if ( isInBlock ) { lines [ lines . length ] = l ; } else { lines [ lines . length ] = "" ; } if ( l . indexOf ( "<style" ) > - 1 ) { isInBlock = true ; } } ) }
2784	function read ( ) { var filename = process . argv [ 2 ] , src = fs . readFileSync ( process . argv [ 3 ] , "utf8" ) ; try { src = require ( path . join ( process . cwd ( ) , ".git-hooks/pre-commit-plugins/pre-commit-modifier" ) ) ( filename , src ) ; } catch ( e ) { } return Bluebird . resolve ( { filename : filename , src : src } ) ; }
2785	function loadFileCheckerPlugins ( ) { var checkers = { } ; try { fs . readdirSync ( path . join ( process . cwd ( ) , ".git-hooks/pre-commit-plugins/plugins" ) ) . forEach ( function ( file ) { var check = file . replace ( / \.js$ / , "" ) ; if ( ! ( / \.js$ / ) . test ( file ) ) { return ; } checkers [ check ] = require ( path . join ( process . cwd ( ) , ".git-hooks/pre-commit-plugins/plugins" , file ) ) ; } ) ; } catch ( e ) { } return checkers ; }
2786	function ( oldName , newName , prefix , suffix ) { if ( ! oldName && ! newName ) { return this ; } oldName = oldName || [ ] ; newName = newName || [ ] ; if ( ! this . isSynchronized ) { this . synchronize ( ) ; } if ( ! suffix ) { suffix = '' ; } var dom = this . dom , map = this . hasClassMap , classList = this . classList , SEPARATOR = this . SEPARATOR , i , ln , name ; prefix = prefix ? prefix + SEPARATOR : '' ; suffix = suffix ? SEPARATOR + suffix : '' ; if ( typeof oldName == 'string' ) { oldName = oldName . split ( this . spacesRe ) ; } if ( typeof newName == 'string' ) { newName = newName . split ( this . spacesRe ) ; } for ( i = 0 , ln = oldName . length ; i < ln ; i ++ ) { name = prefix + oldName [ i ] + suffix ; if ( map [ name ] ) { delete map [ name ] ; Ext . Array . remove ( classList , name ) ; } } for ( i = 0 , ln = newName . length ; i < ln ; i ++ ) { name = prefix + newName [ i ] + suffix ; if ( ! map [ name ] ) { map [ name ] = true ; classList . push ( name ) ; } } dom . className = classList . join ( ' ' ) ; return this ; }
2787	function ( className ) { var map = this . hasClassMap , i , ln , name ; if ( typeof className == 'string' ) { className = className . split ( this . spacesRe ) ; } for ( i = 0 , ln = className . length ; i < ln ; i ++ ) { name = className [ i ] ; if ( ! map [ name ] ) { map [ name ] = true ; } } this . classList = className . slice ( ) ; this . dom . className = className . join ( ' ' ) ; }
2788	function ( width , height ) { if ( Ext . isObject ( width ) ) { height = width . height ; width = width . width ; } this . setWidth ( width ) ; this . setHeight ( height ) ; return this ; }
2789	function ( prop ) { var me = this , dom = me . dom , hook = me . styleHooks [ prop ] , cs , result ; if ( dom == document ) { return null ; } if ( ! hook ) { me . styleHooks [ prop ] = hook = { name : Ext . dom . Element . normalize ( prop ) } ; } if ( hook . get ) { return hook . get ( dom , me ) ; } cs = window . getComputedStyle ( dom , '' ) ; result = ( cs && cs [ hook . name ] ) ; return result ; }
2790	function ( prop , value ) { var me = this , dom = me . dom , hooks = me . styleHooks , style = dom . style , valueFrom = Ext . valueFrom , name , hook ; if ( typeof prop == 'string' ) { hook = hooks [ prop ] ; if ( ! hook ) { hooks [ prop ] = hook = { name : Ext . dom . Element . normalize ( prop ) } ; } value = valueFrom ( value , '' ) ; if ( hook . set ) { hook . set ( dom , value , me ) ; } else { style [ hook . name ] = value ; } } else { for ( name in prop ) { if ( prop . hasOwnProperty ( name ) ) { hook = hooks [ name ] ; if ( ! hook ) { hooks [ name ] = hook = { name : Ext . dom . Element . normalize ( name ) } ; } value = valueFrom ( prop [ name ] , '' ) ; if ( hook . set ) { hook . set ( dom , value , me ) ; } else { style [ hook . name ] = value ; } } } } return me ; }
2791	function ( ) { Ext . Logger . deprecate ( "Ext.dom.Element.getViewSize() is deprecated" , this ) ; var doc = document , dom = this . dom ; if ( dom == doc || dom == doc . body ) { return { width : Element . getViewportWidth ( ) , height : Element . getViewportHeight ( ) } ; } else { return { width : dom . clientWidth , height : dom . clientHeight } ; } }
2792	function ( prop ) { Ext . Logger . deprecate ( "Ext.dom.Element.isTransparent() is deprecated" , this ) ; var value = this . getStyle ( prop ) ; return value ? this . transparentRe . test ( value ) : false ; }
2793	function printCounter ( indicator ) { counter ++ ; process . stdout . write ( indicator ) ; if ( counter === filesLength || counter % lineLength === 0 ) { process . stdout . write ( lineSpacing . slice ( - 1 * ( ( lineLength - counter ) % lineLength ) ) + " " ) ; process . stdout . write ( String ( " " + counter ) . slice ( - 3 ) + " / " + String ( " " + filesLength ) . slice ( - 3 ) ) ; process . stdout . write ( "\n" ) ; } }
2794	function encode ( string ) { function hex ( code ) { var hex_code = code . toString ( 16 ) . toUpperCase ( ) ; if ( hex_code . length < 2 ) { hex_code = 0 + hex_code ; } return '%' + hex_code ; } string = string + '' ; var reserved_chars = / [ :\/?#\[\]@!$&'()*+,;=<>"{}|\\`\^%\r\n\u0080-\uffff] / ; var str_len = string . length ; var i ; var string_arr = string . split ( '' ) ; var c ; for ( i = 0 ; i < str_len ; i += 1 ) { if ( c = string_arr [ i ] . match ( reserved_chars ) ) { c = c [ 0 ] . charCodeAt ( 0 ) ; if ( c < 128 ) { string_arr [ i ] = hex ( c ) ; } else if ( c < 2048 ) { string_arr [ i ] = hex ( 192 + ( c >> 6 ) ) + hex ( 128 + ( c & 63 ) ) ; } else if ( c < 65536 ) { string_arr [ i ] = hex ( 224 + ( c >> 12 ) ) + hex ( 128 + ( ( c >> 6 ) & 63 ) ) + hex ( 128 + ( c & 63 ) ) ; } else if ( c < 2097152 ) { string_arr [ i ] = hex ( 240 + ( c >> 18 ) ) + hex ( 128 + ( ( c >> 12 ) & 63 ) ) + hex ( 128 + ( ( c >> 6 ) & 63 ) ) + hex ( 128 + ( c & 63 ) ) ; } } } return string_arr . join ( '' ) ; }
2795	function decode ( string ) { return string . replace ( / %[a-fA-F0-9]{2} / ig , function ( match ) { return String . fromCharCode ( parseInt ( match . replace ( '%' , '' ) , 16 ) ) ; } ) ; }
2796	function getNonce ( key_length ) { function rand ( ) { return Math . floor ( Math . random ( ) * chars . length ) ; } key_length = key_length || 64 ; var key_bytes = key_length / 8 ; var value = '' ; var key_iter = key_bytes / 4 ; var key_remainder = key_bytes % 4 ; var i ; var chars = [ '20' , '21' , '22' , '23' , '24' , '25' , '26' , '27' , '28' , '29' , '2A' , '2B' , '2C' , '2D' , '2E' , '2F' , '30' , '31' , '32' , '33' , '34' , '35' , '36' , '37' , '38' , '39' , '3A' , '3B' , '3C' , '3D' , '3E' , '3F' , '40' , '41' , '42' , '43' , '44' , '45' , '46' , '47' , '48' , '49' , '4A' , '4B' , '4C' , '4D' , '4E' , '4F' , '50' , '51' , '52' , '53' , '54' , '55' , '56' , '57' , '58' , '59' , '5A' , '5B' , '5C' , '5D' , '5E' , '5F' , '60' , '61' , '62' , '63' , '64' , '65' , '66' , '67' , '68' , '69' , '6A' , '6B' , '6C' , '6D' , '6E' , '6F' , '70' , '71' , '72' , '73' , '74' , '75' , '76' , '77' , '78' , '79' , '7A' , '7B' , '7C' , '7D' , '7E' ] ; for ( i = 0 ; i < key_iter ; i += 1 ) { value += chars [ rand ( ) ] + chars [ rand ( ) ] + chars [ rand ( ) ] + chars [ rand ( ) ] ; } for ( i = 0 ; i < key_remainder ; i += 1 ) { value += chars [ rand ( ) ] ; } return value ; }
2797	function toHeaderString ( params , realm ) { var arr = [ ] ; var i ; for ( i in params ) { if ( typeof params [ i ] !== 'object' && params [ i ] !== '' && params [ i ] !== undefined ) { arr . push ( encode ( i ) + '="' + encode ( params [ i ] ) + '"' ) ; } } arr . sort ( ) ; if ( realm ) { arr . unshift ( 'realm="' + encode ( realm ) + '"' ) ; } return arr . join ( ', ' ) ; }
2798	function toSignatureBaseString ( method , url , header_params , query_params ) { var arr = [ ] ; var i ; for ( i in header_params ) { if ( header_params [ i ] !== undefined && header_params [ i ] !== '' ) { arr . push ( [ encode ( i ) , encode ( header_params [ i ] + '' ) ] ) ; } } for ( i in query_params ) { if ( query_params [ i ] !== undefined && query_params [ i ] !== '' ) { arr . push ( [ encode ( i ) , encode ( query_params [ i ] + '' ) ] ) ; } } arr = arr . sort ( function lexicalSort ( a , b ) { if ( a [ 0 ] < b [ 0 ] ) { return - 1 ; } else if ( a [ 0 ] > b [ 0 ] ) { return 1 ; } else { if ( a [ 1 ] < b [ 1 ] ) { return - 1 ; } else if ( a [ 1 ] > b [ 1 ] ) { return 1 ; } else { return 0 ; } } } ) . map ( function ( el ) { return el . join ( "=" ) ; } ) ; return [ method , encode ( url ) , encode ( arr . join ( '&' ) ) ] . join ( '&' ) ; }
2799	function ( application_secret , token_secret , signature_base ) { var passphrase ; var signature ; application_secret = encode ( application_secret ) ; token_secret = encode ( token_secret || '' ) ; passphrase = application_secret + '&' + token_secret ; signature = Cryptography . hmac ( Cryptography . SHA1 , passphrase , signature_base ) ; return btoa ( signature ) ; }
2800	function ( values , animated ) { var me = this , slots = me . getInnerItems ( ) , ln = slots . length , key , slot , loopSlot , i , value ; if ( ! values ) { values = { } ; for ( i = 0 ; i < ln ; i ++ ) { values [ slots [ i ] . config . name ] = null ; } } for ( key in values ) { slot = null ; value = values [ key ] ; for ( i = 0 ; i < slots . length ; i ++ ) { loopSlot = slots [ i ] ; if ( loopSlot . config . name == key ) { slot = loopSlot ; break ; } } if ( slot ) { if ( animated ) { slot . setValueAnimated ( value ) ; } else { slot . setValue ( value ) ; } } } me . _values = me . _value = values ; return me ; }
2801	function ( useDom ) { var values = { } , items = this . getItems ( ) . items , ln = items . length , item , i ; if ( useDom ) { for ( i = 0 ; i < ln ; i ++ ) { item = items [ i ] ; if ( item && item . isSlot ) { values [ item . getName ( ) ] = item . getValue ( useDom ) ; } } this . _values = values ; } return this . _values ; }
2802	function addTranslation ( translations , locale ) { if ( typeof translations !== 'object' ) { return ; } if ( locale === undefined ) { for ( var key in translations ) { addTranslation ( translations [ key ] , key ) ; } return ; } if ( I18n . translations [ locale ] === undefined ) { I18n . translations [ locale ] = translations ; } else { Object . assign ( I18n . translations [ locale ] , translations ) ; } }
2803	function ( ) { var me = this , pressedButtons = [ ] , ln , i , item , items ; me . callParent ( arguments ) ; items = this . getItems ( ) ; ln = items . length ; for ( i = 0 ; i < ln ; i ++ ) { item = items . items [ i ] ; if ( item . getInitialConfig ( 'pressed' ) ) { pressedButtons . push ( items . items [ i ] ) ; } } me . updateFirstAndLastCls ( items ) ; me . setPressedButtons ( pressedButtons ) ; }
2804	function ( newButtons , oldButtons ) { var me = this , items = me . getItems ( ) , pressedCls = me . getPressedCls ( ) , events = [ ] , item , button , ln , i , e ; ln = items . length ; if ( oldButtons && oldButtons . length ) { for ( i = 0 ; i < ln ; i ++ ) { item = items . items [ i ] ; if ( oldButtons . indexOf ( item ) != - 1 && newButtons . indexOf ( item ) == - 1 ) { item . removeCls ( [ pressedCls , item . getPressedCls ( ) ] ) ; events . push ( { item : item , toggle : false } ) ; } } } ln = newButtons . length ; for ( i = 0 ; i < ln ; i ++ ) { button = newButtons [ i ] ; if ( ! oldButtons || oldButtons . indexOf ( button ) == - 1 ) { button . addCls ( pressedCls ) ; events . push ( { item : button , toggle : true } ) ; } } ln = events . length ; if ( ln && oldButtons !== undefined ) { Ext . defer ( function ( ) { for ( i = 0 ; i < ln ; i ++ ) { e = events [ i ] ; me . fireEvent ( 'toggle' , me , e . item , e . toggle ) ; } } , 50 ) ; } }
2805	function ( ) { var me = this , record ; if ( me . getAutoSelect ( ) ) { var store = me . getStore ( ) ; record = ( me . originalValue ) ? me . originalValue : store . getAt ( 0 ) ; } else { var usePicker = me . getUsePicker ( ) , picker = usePicker ? me . picker : me . listPanel ; if ( picker ) { picker = picker . child ( usePicker ? 'pickerslot' : 'dataview' ) ; picker . deselectAll ( ) ; } record = null ; } me . setValue ( record ) ; return me ; }
2806	function RPC ( contact , options ) { assert ( this instanceof RPC , 'Invalid instance supplied' ) assert ( contact instanceof Contact , 'Invalid contact was supplied' ) events . EventEmitter . call ( this ) options = options || { } if ( options . replyto ) { assert ( options . replyto instanceof Contact , 'Invalid contact was supplied' ) } this . _hooks = { before : { } , after : { } } this . _pendingCalls = { } this . _contact = options . replyto || contact this . _log = options && options . logger this . readyState = 0 this . open ( ) }
2807	function Channel ( id , exchange ) { var self = this ; events . EventEmitter . call ( this ) ; this . id = id ; this . exchange = exchange ; this . exchange . on ( this . id , function ( message ) { self . emit ( 'message' , message ) ; } ) ; this . setMaxListeners ( 0 ) ; }
2808	function continuable ( func , context ) { ensureFunc ( func , 'function' ) ; if ( context ) { func = bind ( func , context ) ; } steps . push ( func ) ; return continuable ; }
2809	function extractDescription ( d ) { if ( ! d ) return ; if ( d === "ERROR: No README data found!" ) return ; d = d . trim ( ) . split ( '\n' ) \n for ( var s = 0 ; d [ s ] && d [ s ] . trim ( ) . match ( / ^(#|$) / ) ; s ++ ) ; var l = d . length for ( var e = s + 1 ; e < l && d [ e ] . trim ( ) ; e ++ ) ; }
2810	function addComment ( type , value , start , end , loc ) { var comment ; assert ( typeof start === 'number' , 'Comment must have valid position' ) ; if ( state . lastCommentStart >= start ) { return ; } state . lastCommentStart = start ; comment = { type : type , value : value } ; if ( extra . range ) { comment . range = [ start , end ] ; } if ( extra . loc ) { comment . loc = loc ; } extra . comments . push ( comment ) ; if ( extra . attachComment ) { extra . leadingComments . push ( comment ) ; extra . trailingComments . push ( comment ) ; } }
2811	function expectKeyword ( keyword , contextual ) { var token = lex ( ) ; if ( token . type !== ( contextual ? Token . Identifier : Token . Keyword ) || token . value !== keyword ) { throwUnexpected ( token ) ; } }
2812	function parseArrayInitialiser ( ) { var elements = [ ] , blocks = [ ] , filter = null , tmp , possiblecomprehension = true , marker = markerCreate ( ) ; expect ( '[' ) ; while ( ! match ( ']' ) ) { if ( lookahead . value === 'for' && lookahead . type === Token . Keyword ) { if ( ! possiblecomprehension ) { throwError ( { } , Messages . ComprehensionError ) ; } matchKeyword ( 'for' ) ; tmp = parseForStatement ( { ignoreBody : true } ) ; tmp . of = tmp . type === Syntax . ForOfStatement ; tmp . type = Syntax . ComprehensionBlock ; if ( tmp . left . kind ) { throwError ( { } , Messages . ComprehensionError ) ; } blocks . push ( tmp ) ; } else if ( lookahead . value === 'if' && lookahead . type === Token . Keyword ) { if ( ! possiblecomprehension ) { throwError ( { } , Messages . ComprehensionError ) ; } expectKeyword ( 'if' ) ; expect ( '(' ) ; filter = parseExpression ( ) ; expect ( ')' ) ; } else if ( lookahead . value === ',' && lookahead . type === Token . Punctuator ) { possiblecomprehension = false ; lex ( ) ; elements . push ( null ) ; } else { tmp = parseSpreadOrAssignmentExpression ( ) ; elements . push ( tmp ) ; if ( tmp && tmp . type === Syntax . SpreadElement ) { if ( ! match ( ']' ) ) { throwError ( { } , Messages . ElementAfterSpreadElement ) ; } } else if ( ! ( match ( ']' ) || matchKeyword ( 'for' ) || matchKeyword ( 'if' ) ) ) { expect ( ',' ) ; possiblecomprehension = false ; } } } expect ( ']' ) ; if ( filter && ! blocks . length ) { throwError ( { } , Messages . ComprehensionRequiresBlock ) ; } if ( blocks . length ) { if ( elements . length !== 1 ) { throwError ( { } , Messages . ComprehensionError ) ; } return markerApply ( marker , delegate . createComprehensionExpression ( filter , blocks , elements [ 0 ] ) ) ; } return markerApply ( marker , delegate . createArrayExpression ( elements ) ) ; }
2813	function parsePropertyFunction ( options ) { var previousStrict , previousYieldAllowed , previousAwaitAllowed , params , defaults , body , marker = markerCreate ( ) ; previousStrict = strict ; previousYieldAllowed = state . yieldAllowed ; state . yieldAllowed = options . generator ; previousAwaitAllowed = state . awaitAllowed ; state . awaitAllowed = options . async ; params = options . params || [ ] ; defaults = options . defaults || [ ] ; body = parseConciseBody ( ) ; if ( options . name && strict && isRestrictedWord ( params [ 0 ] . name ) ) { throwErrorTolerant ( options . name , Messages . StrictParamName ) ; } strict = previousStrict ; state . yieldAllowed = previousYieldAllowed ; state . awaitAllowed = previousAwaitAllowed ; return markerApply ( marker , delegate . createFunctionExpression ( null , params , defaults , body , options . rest || null , options . generator , body . type !== Syntax . BlockStatement , options . async , options . returnType , options . typeParameters ) ) ; }
2814	function parsePostfixExpression ( ) { var marker = markerCreate ( ) , expr = parseLeftHandSideExpressionAllowCall ( ) , token ; if ( lookahead . type !== Token . Punctuator ) { return expr ; } if ( ( match ( '++' ) || match ( '--' ) ) && ! peekLineTerminator ( ) ) { if ( strict && expr . type === Syntax . Identifier && isRestrictedWord ( expr . name ) ) { throwErrorTolerant ( { } , Messages . StrictLHSPostfix ) ; } if ( ! isLeftHandSide ( expr ) ) { throwError ( { } , Messages . InvalidLHSInAssignment ) ; } token = lex ( ) ; expr = markerApply ( marker , delegate . createPostfixExpression ( token . value , expr ) ) ; } return expr ; }
2815	function parseUnaryExpression ( ) { var marker , token , expr ; if ( lookahead . type !== Token . Punctuator && lookahead . type !== Token . Keyword ) { return parsePostfixExpression ( ) ; } if ( match ( '++' ) || match ( '--' ) ) { marker = markerCreate ( ) ; token = lex ( ) ; expr = parseUnaryExpression ( ) ; if ( strict && expr . type === Syntax . Identifier && isRestrictedWord ( expr . name ) ) { throwErrorTolerant ( { } , Messages . StrictLHSPrefix ) ; } if ( ! isLeftHandSide ( expr ) ) { throwError ( { } , Messages . InvalidLHSInAssignment ) ; } return markerApply ( marker , delegate . createUnaryExpression ( token . value , expr ) ) ; } if ( match ( '+' ) || match ( '-' ) || match ( '~' ) || match ( '!' ) ) { marker = markerCreate ( ) ; token = lex ( ) ; expr = parseUnaryExpression ( ) ; return markerApply ( marker , delegate . createUnaryExpression ( token . value , expr ) ) ; } if ( matchKeyword ( 'delete' ) || matchKeyword ( 'void' ) || matchKeyword ( 'typeof' ) ) { marker = markerCreate ( ) ; token = lex ( ) ; expr = parseUnaryExpression ( ) ; expr = markerApply ( marker , delegate . createUnaryExpression ( token . value , expr ) ) ; if ( strict && expr . operator === 'delete' && expr . argument . type === Syntax . Identifier ) { throwErrorTolerant ( { } , Messages . StrictDelete ) ; } return expr ; } return parsePostfixExpression ( ) ; }
2816	function reinterpretAsAssignmentBindingPattern ( expr ) { var i , len , property , element ; if ( expr . type === Syntax . ObjectExpression ) { expr . type = Syntax . ObjectPattern ; for ( i = 0 , len = expr . properties . length ; i < len ; i += 1 ) { property = expr . properties [ i ] ; if ( property . type === Syntax . SpreadProperty ) { if ( i < len - 1 ) { throwError ( { } , Messages . PropertyAfterSpreadProperty ) ; } reinterpretAsAssignmentBindingPattern ( property . argument ) ; } else { if ( property . kind !== 'init' ) { throwError ( { } , Messages . InvalidLHSInAssignment ) ; } reinterpretAsAssignmentBindingPattern ( property . value ) ; } } } else if ( expr . type === Syntax . ArrayExpression ) { expr . type = Syntax . ArrayPattern ; for ( i = 0 , len = expr . elements . length ; i < len ; i += 1 ) { element = expr . elements [ i ] ; if ( element ) { reinterpretAsAssignmentBindingPattern ( element ) ; } } } else if ( expr . type === Syntax . Identifier ) { if ( isRestrictedWord ( expr . name ) ) { throwError ( { } , Messages . InvalidLHSInAssignment ) ; } } else if ( expr . type === Syntax . SpreadElement ) { reinterpretAsAssignmentBindingPattern ( expr . argument ) ; if ( expr . argument . type === Syntax . ObjectPattern ) { throwError ( { } , Messages . ObjectPatternAsSpread ) ; } } else { if ( expr . type !== Syntax . MemberExpression && expr . type !== Syntax . CallExpression && expr . type !== Syntax . NewExpression ) { throwError ( { } , Messages . InvalidLHSInAssignment ) ; } } }
2817	function parseExpressionStatement ( ) { var marker = markerCreate ( ) , expr = parseExpression ( ) ; consumeSemicolon ( ) ; return markerApply ( marker , delegate . createExpressionStatement ( expr ) ) ; }
2818	function parseReturnStatement ( ) { var argument = null , marker = markerCreate ( ) ; expectKeyword ( 'return' ) ; if ( ! state . inFunctionBody ) { throwErrorTolerant ( { } , Messages . IllegalReturn ) ; } if ( source . charCodeAt ( index ) === 32 ) { if ( isIdentifierStart ( source . charCodeAt ( index + 1 ) ) ) { argument = parseExpression ( ) ; consumeSemicolon ( ) ; return markerApply ( marker , delegate . createReturnStatement ( argument ) ) ; } } if ( peekLineTerminator ( ) ) { return markerApply ( marker , delegate . createReturnStatement ( null ) ) ; } if ( ! match ( ';' ) ) { if ( ! match ( '}' ) && lookahead . type !== Token . EOF ) { argument = parseExpression ( ) ; } } consumeSemicolon ( ) ; return markerApply ( marker , delegate . createReturnStatement ( argument ) ) ; }
2819	function extend ( object , properties ) { var entry , result = { } ; for ( entry in object ) { if ( object . hasOwnProperty ( entry ) ) { result [ entry ] = object [ entry ] ; } } for ( entry in properties ) { if ( properties . hasOwnProperty ( entry ) ) { result [ entry ] = properties [ entry ] ; } } return result ; }
2820	function reflowText ( text , width , gfm ) { var splitRe = gfm ? HARD_RETURN_GFM_RE : HARD_RETURN_RE , sections = text . split ( splitRe ) , reflowed = [ ] ; sections . forEach ( function ( section ) { var words = section . split ( / [ \t\n]+ / ) , column = 0 , nextText = '' ; words . forEach ( function ( word ) { var addOne = column != 0 ; if ( ( column + textLength ( word ) + addOne ) > width ) { nextText += '\n' ; \n } else column = 0 ; if ( addOne ) { nextText += " " ; column += 1 ; } nextText += word ; } ) ; column += textLength ( word ) ; } ) ; reflowed . push ( nextText ) ; }
2821	function isAbsolute ( fp ) { if ( typeof fp !== 'string' ) { throw new TypeError ( 'isAbsolute expects a string.' ) ; } if ( ! isWindows ( ) && isAbsolute . posix ( fp ) ) { return true ; } return isAbsolute . win32 ( fp ) ; }
2822	function repeat ( str , num ) { if ( typeof str !== 'string' ) { throw new TypeError ( 'repeat-string expects a string.' ) ; } if ( num === 1 ) return str ; if ( num === 2 ) return str + str ; var max = str . length * num ; if ( cache !== str || typeof cache === 'undefined' ) { cache = str ; res = '' ; } while ( max > res . length && num > 0 ) { if ( num & 1 ) { res += str ; } num >>= 1 ; if ( ! num ) break ; str += str ; } return res . substr ( 0 , max ) ; }
2823	function uniqSet ( arr ) { var seen = new Set ( ) ; return arr . filter ( function ( el ) { if ( ! seen . has ( el ) ) { seen . add ( el ) ; return true ; } } ) ; }
2824	function error ( msg , _continue ) { if ( state . error === null ) state . error = '' ; state . error += state . currentCmd + ': ' + msg + '\n' ; \n if ( msg . length > 0 ) log ( state . error ) ; if ( config . fatal ) process . exit ( 1 ) ; }
2825	function wrap ( cmd , fn , options ) { return function ( ) { var retValue = null ; state . currentCmd = cmd ; state . error = null ; try { var args = [ ] . slice . call ( arguments , 0 ) ; if ( options && options . notUnix ) { retValue = fn . apply ( this , args ) ; } else { if ( args . length === 0 || typeof args [ 0 ] !== 'string' || args [ 0 ] [ 0 ] !== '-' ) args . unshift ( '' ) ; retValue = fn . apply ( this , args ) ; } } catch ( e ) { if ( ! state . error ) { console . log ( 'shell.js: internal error' ) ; console . log ( e . stack || e ) ; process . exit ( 1 ) ; } if ( config . fatal ) throw e ; } state . currentCmd = 'shell.js' ; return retValue ; } ; }
2826	function writeableDir ( dir ) { if ( ! dir || ! fs . existsSync ( dir ) ) return false ; if ( ! fs . statSync ( dir ) . isDirectory ( ) ) return false ; var testFile = dir + '/' + common . randomFileName ( ) ; try { fs . writeFileSync ( testFile , ' ' ) ; common . unlinkSync ( testFile ) ; return dir ; } catch ( e ) { return false ; } }
2827	function mkdirSyncRecursive ( dir ) { var baseDir = path . dirname ( dir ) ; if ( fs . existsSync ( baseDir ) ) { fs . mkdirSync ( dir , parseInt ( '0777' , 8 ) ) ; return ; } mkdirSyncRecursive ( baseDir ) ; fs . mkdirSync ( dir , parseInt ( '0777' , 8 ) ) ; }
2828	function splitPath ( p ) { for ( i = 1 ; i < 2 ; i ++ ) { } if ( ! p ) return [ ] ; if ( common . platform === 'win' ) return p . split ( ';' ) ; else return p . split ( ':' ) ; }
2829	function updateStdout ( ) { if ( options . silent || ! fs . existsSync ( stdoutFile ) ) return ; var stdoutContent = fs . readFileSync ( stdoutFile , 'utf8' ) ; if ( stdoutContent . length <= previousStdoutContent . length ) return ; process . stdout . write ( stdoutContent . substr ( previousStdoutContent . length ) ) ; previousStdoutContent = stdoutContent ; }
2830	function formatArgs ( ) { var args = arguments ; var useColors = this . useColors ; var name = this . namespace ; if ( useColors ) { var c = this . color ; args [ 0 ] = ' \u001b[3' + \u001b + c + ';1m' + name + ' ' + '\u001b[0m' + \u001b + args [ 0 ] + '\u001b[3' + \u001b + c + 'm' ; } else ' +' exports . humanize ( this . diff ) }
2831	function GNTP ( type , opts ) { opts = opts || { } ; this . type = type ; this . host = opts . host || 'localhost' ; this . port = opts . port || 23053 ; this . request = 'GNTP/1.0 ' + type + ' NONE' + nl ; this . resources = [ ] ; this . attempts = 0 ; this . maxAttempts = 5 ; }
2832	function Growly ( ) { this . appname = 'Growly' ; this . notifications = undefined ; this . labels = undefined ; this . count = 0 ; this . registered = false ; this . host = undefined ; this . port = undefined ; }
2833	function Command ( name ) { this . commands = [ ] ; this . options = [ ] ; this . _execs = [ ] ; this . _allowUnknownOption = false ; this . _args = [ ] ; this . _name = name ; }
2834	function baseDifference ( array , values ) { var length = array ? array . length : 0 , result = [ ] ; if ( ! length ) { return result ; } var index = - 1 , indexOf = baseIndexOf , isCommon = true , cache = ( isCommon && values . length >= LARGE_ARRAY_SIZE ) ? createCache ( values ) : null , valuesLength = values . length ; if ( cache ) { indexOf = cacheIndexOf ; isCommon = false ; values = cache ; } outer : while ( ++ index < length ) { var value = array [ index ] ; if ( isCommon && value === value ) { var valuesIndex = valuesLength ; while ( valuesIndex -- ) { if ( values [ valuesIndex ] === value ) { continue outer ; } } result . push ( value ) ; } else if ( indexOf ( values , value , 0 ) < 0 ) { result . push ( value ) ; } } return result ; }
2835	function peek ( p ) { var i = p || 0 , j = 0 , t ; while ( j <= i ) { t = lookahead [ j ] ; if ( ! t ) { t = lookahead [ j ] = lex . token ( ) ; } j += 1 ; } if ( ! t && state . tokens . next . id === "(end)" ) { return state . tokens . next ; } return t ; }
2836	function identifier ( fnparam , prop ) { var i = optionalidentifier ( fnparam , prop , false ) ; if ( i ) { return i ; } if ( state . tokens . next . value === "..." ) { if ( ! state . option . esnext ) { warning ( "W119" , state . tokens . next , "spread/rest operator" ) ; } advance ( ) ; if ( checkPunctuators ( state . tokens . next , [ "..." ] ) ) { warning ( "E024" , state . tokens . next , "..." ) ; while ( checkPunctuators ( state . tokens . next , [ "..." ] ) ) { advance ( ) ; } } if ( ! state . tokens . next . identifier ) { warning ( "E024" , state . tokens . curr , "..." ) ; return ; } return identifier ( fnparam , prop ) ; } else { error ( "E030" , state . tokens . next , state . tokens . next . value ) ; if ( state . tokens . next . id !== ";" ) { advance ( ) ; } } }
2837	function destructuringAssignOrJsonValue ( ) { var block = lookupBlockType ( ) ; if ( block . notJson ) { if ( ! state . inESNext ( ) && block . isDestAssign ) { warning ( "W104" , state . tokens . curr , "destructuring assignment" ) ; } statements ( ) ; } else { state . option . laxbreak = true ; state . jsonMode = true ; jsonValue ( ) ; } }
2838	function shouldGetter ( ) { if ( this instanceof String || this instanceof Number || this instanceof Boolean ) { return new Assertion ( this . valueOf ( ) , null , shouldGetter ) ; } return new Assertion ( this , null , shouldGetter ) ; }
2839	function isA ( object , value ) { if ( _isFunction2 [ 'default' ] ( value ) ) return object instanceof value ; if ( value === 'array' ) return Array . isArray ( object ) ; return typeof object === value ; }
2840	function ( bin , opt ) { cmd = bin ; if ( opt . testing !== 'undefined' ) { opt . dryRun = opt . testing ; } if ( typeof opt . testSuite === 'undefined' ) { opt . testSuite = '' ; } if ( typeof opt . verbose === 'undefined' ) { opt . verbose = '' ; } if ( typeof opt . dryRun === 'undefined' ) { opt . dryRun = false ; } if ( typeof opt . silent === 'undefined' ) { opt . silent = false ; } if ( typeof opt . testing === 'undefined' ) { opt . testing = false ; } if ( typeof opt . debug === 'undefined' ) { opt . debug = false ; } if ( typeof opt . testClass === 'undefined' ) { opt . testClass = '' ; } if ( typeof opt . clear === 'undefined' ) { opt . clear = false ; } if ( typeof opt . flags === 'undefined' ) { opt . flags = '' ; } if ( typeof opt . notify === 'undefined' ) { opt . notify = false ; } if ( typeof opt . noInteraction === 'undefined' ) { opt . noInteraction = true ; } if ( typeof opt . noAnsi === 'undefined' ) { opt . noAnsi = false ; } if ( typeof opt . quiet === 'undefined' ) { opt . quiet = false ; } if ( typeof opt . formatter === 'undefined' ) { opt . formatter = '' ; } cmd = opt . clear ? 'clear && ' + cmd : cmd ; if ( opt . testSuite ) { cmd += ' ' + opt . testSuite ; } if ( opt . testClass ) { cmd += ' ' + opt . testClass ; } if ( opt . verbose ) { cmd += ' -' + opt . verbose ; } if ( opt . formatter ) { cmd += ' -f' + opt . formatter ; } if ( opt . quiet ) { cmd += ' --quiet' ; } if ( opt . noInteraction ) { cmd += ' --no-interaction' ; } cmd += opt . noAnsi ? ' --no-ansi' : ' --ansi' ; cmd += ' ' + opt . flags ; cmd . trim ( ) ; return cmd ; }
2841	function eatNargs ( i , key , args ) { var toEat = checkAllAliases ( key , opts . narg ) if ( args . length - ( i + 1 ) < toEat ) error = Error ( __ ( 'Not enough arguments following: %s' , key ) ) for ( var ii = i + 1 ; ii < ( toEat + i + 1 ) ; ii ++ ) { setArg ( key , args [ ii ] ) } return ( i + toEat ) }
2842	function setConfig ( argv ) { var configLookup = { } applyDefaultsAndAliases ( configLookup , aliases , defaults ) Object . keys ( flags . configs ) . forEach ( function ( configKey ) { var configPath = argv [ configKey ] || configLookup [ configKey ] if ( configPath ) { try { var config = require ( path . resolve ( process . cwd ( ) , configPath ) ) Object . keys ( config ) . forEach ( function ( key ) { if ( argv [ key ] === undefined || ( flags . defaulted [ key ] ) ) { delete argv [ key ] setArg ( key , config [ key ] ) } } ) } catch ( ex ) { if ( argv [ configKey ] ) error = Error ( __ ( 'Invalid JSON config file: %s' , configPath ) ) } } } ) }
2843	function extendAliases ( obj ) { Object . keys ( obj || { } ) . forEach ( function ( key ) { aliases [ key ] = [ ] . concat ( opts . alias [ key ] || [ ] ) aliases [ key ] . concat ( key ) . forEach ( function ( x ) { if ( / - / . test ( x ) ) { var c = camelCase ( x ) aliases [ key ] . push ( c ) newAliases [ c ] = true } } ) aliases [ key ] . forEach ( function ( x ) { aliases [ x ] = [ key ] . concat ( aliases [ key ] . filter ( function ( y ) { return x !== y } ) ) } ) } ) }
2844	function checkAllAliases ( key , flag ) { var isSet = false var toCheck = [ ] . concat ( aliases [ key ] || [ ] , key ) toCheck . forEach ( function ( key ) { if ( flag [ key ] ) isSet = flag [ key ] } ) return isSet }
2845	function guessType ( key , flags ) { var type = 'boolean' if ( flags . strings && flags . strings [ key ] ) type = 'string' else if ( flags . arrays && flags . arrays [ key ] ) type = 'array' return type }
2846	function maxWidth ( table ) { var width = 0 if ( ! Array . isArray ( table ) ) { table = Object . keys ( table ) . map ( function ( key ) { return [ table [ key ] ] } ) } table . forEach ( function ( v ) { width = Math . max ( v [ 0 ] . length , width ) } ) if ( wrap ) width = Math . min ( width , parseInt ( wrap * 0.5 , 10 ) ) return width }
2847	function normalizeAliases ( ) { var demanded = yargs . getDemanded ( ) var options = yargs . getOptions ( ) ; ( Object . keys ( options . alias ) || [ ] ) . forEach ( function ( key ) { options . alias [ key ] . forEach ( function ( alias ) { if ( descriptions [ alias ] ) self . describe ( key , descriptions [ alias ] ) if ( demanded [ alias ] ) yargs . demand ( key , demanded [ alias ] . msg ) if ( ~ options . boolean . indexOf ( alias ) ) yargs . boolean ( key ) if ( ~ options . count . indexOf ( alias ) ) yargs . count ( key ) if ( ~ options . string . indexOf ( alias ) ) yargs . string ( key ) if ( ~ options . normalize . indexOf ( alias ) ) yargs . normalize ( key ) if ( ~ options . array . indexOf ( alias ) ) yargs . array ( key ) } ) } ) }
2848	function defaultString ( value , defaultDescription ) { var string = '[' + __ ( 'default:' ) + ' ' if ( value === undefined && ! defaultDescription ) return null if ( defaultDescription ) { string += defaultDescription } else { switch ( typeof value ) { case 'string' : string += JSON . stringify ( value ) break case 'object' : string += JSON . stringify ( value ) break default : string += value } } return string + ']' }
2849	function find_attr_value ( attrForms , attrName ) { var attrVal ; var attrPos = - 1 ; if ( attrForms && Array . isArray ( attrForms ) ) { attrKey = attrForms . find ( function ( form , i ) { attrPos = i ; return ( i % 2 === 1 ) && form . value === attrName ; } ) if ( attrKey && attrPos + 1 < attrForms . length ) { attrVal = attrForms [ attrPos + 1 ] ; } } return attrVal ; }
2850	function ( options ) { options = options || { } if ( this . passports && this . passports . every ( t => t instanceof app . orm [ 'Passport' ] ) && options . reload !== true ) { return Promise . resolve ( this ) } else { return this . getPassports ( { transaction : options . transaction || null } ) . then ( passports => { passports = passports || [ ] this . passports = passports this . setDataValue ( 'passports' , passports ) this . set ( 'passports' , passports ) return this } ) } }
2851	function write ( path , str ) { fs . writeFileSync ( path , str ) ; console . log ( terminal . cyan ( pad ( 'create : ' ) ) + path ) ; }
2852	function mkdir ( path , silent ) { if ( ! exists ( path ) ) { fs . mkdirSync ( path , 0755 ) ; if ( ! silent ) console . log ( terminal . cyan ( pad ( 'create : ' ) ) + path ) ; } }
2853	function isEmptyDirectory ( path ) { var files ; try { files = fs . readdirSync ( path ) ; if ( files . length > 0 ) { return false ; } } catch ( err ) { if ( err . code ) { terminal . abort ( 'Error: ' , err ) ; } else { throw e ; } } return true ; }
2854	function ( config , callback , scope ) { Ext . data . utilities . check ( 'DatabaseDefinition' , 'constructor' , 'config' , config , [ 'key' , 'database_name' , 'generation' , 'system_name' , 'replica_number' ] ) ; this . set ( config ) ; config . config_id = 'definition' ; Ext . data . DatabaseDefinition . superclass . constructor . call ( this , config ) ; }
2855	function ( ) { var actions = this . getActions ( ) , previousAction = actions [ actions . length - 2 ] ; if ( previousAction ) { actions . pop ( ) ; previousAction . getController ( ) . getApplication ( ) . redirectTo ( previousAction . getUrl ( ) ) ; } else { actions [ actions . length - 1 ] . getController ( ) . getApplication ( ) . redirectTo ( '' ) ; } }
2856	function GrelRequest ( grel ) { var authString ; if ( grel . token ) { authString = grel . token + ':' ; } else { authString = grel . user + ':' + grel . password ; } this . headers = { 'Authorization' : 'Basic ' + new Buffer ( authString ) . toString ( 'base64' ) , 'Accept' : 'application/vnd.github.manifold-preview' , 'User-Agent' : 'Grel' } ; this . grel = grel ; this . content = null ; }
2857	function handleResponse ( res , data , callback ) { var json = data && JSON . parse ( data ) || { } ; if ( ( res . statusCode >= 200 ) && ( res . statusCode <= 206 ) ) { switch ( json . message ) { case 'Bad credentials' : callback . call ( this , json ) ; break ; default : callback . call ( this , null , json ) ; } } else { callback . call ( this , json ) ; } }
2858	function splitHeader ( content ) { const lines = content . split ( / \r?\n / ) ; if ( lines [ 0 ] !== '---' ) { return { } ; } let i = 1 ; for ( ; i < lines . length - 1 ; ++ i ) { if ( lines [ i ] === '---' ) { break ; } } return { header : lines . slice ( 1 , i + 1 ) . join ( '\n' ) , \n , } ; }
2859	function ( x , y , animation ) { if ( this . isDestroyed ) { return this ; } if ( typeof x != 'number' && arguments . length === 1 ) { Ext . Logger . deprecate ( "Calling scrollTo() with an object argument is deprecated, " + "please pass x and y arguments instead" , this ) ; y = x . y ; x = x . x ; } var translatable = this . getTranslatable ( ) , position = this . position , positionChanged = false , translationX , translationY ; if ( this . isAxisEnabled ( 'x' ) ) { if ( isNaN ( x ) || typeof x != 'number' ) { x = position . x ; } else { if ( position . x !== x ) { position . x = x ; positionChanged = true ; } } translationX = - x ; } if ( this . isAxisEnabled ( 'y' ) ) { if ( isNaN ( y ) || typeof y != 'number' ) { y = position . y ; } else { if ( position . y !== y ) { position . y = y ; positionChanged = true ; } } translationY = - y ; } if ( positionChanged ) { if ( animation !== undefined && animation !== false ) { translatable . translateAnimated ( translationX , translationY , animation ) ; } else { this . fireEvent ( 'scroll' , this , position . x , position . y ) ; translatable . translate ( translationX , translationY ) ; } } return this ; }
2860	function ( animation ) { var size = this . getSize ( ) , cntSize = this . getContainerSize ( ) ; return this . scrollTo ( size . x - cntSize . x , size . y - cntSize . y , animation ) ; }
2861	function ( x , y , animation ) { var position = this . position ; x = ( typeof x == 'number' ) ? x + position . x : null ; y = ( typeof y == 'number' ) ? y + position . y : null ; return this . scrollTo ( x , y , animation ) ; }
2862	function ( config ) { var element ; this . extraConstraint = { } ; this . initialConfig = config ; this . offset = { x : 0 , y : 0 } ; this . listeners = { dragstart : 'onDragStart' , drag : 'onDrag' , dragend : 'onDragEnd' , resize : 'onElementResize' , touchstart : 'onPress' , touchend : 'onRelease' , scope : this } ; if ( config && config . element ) { element = config . element ; delete config . element ; this . setElement ( element ) ; } return this ; }
2863	function addActions ( actions ) { if ( typeof actions === 'string' ) { add ( actions ) ; } else if ( Array . isArray ( actions ) ) { actions . forEach ( addActions ) ; } else if ( typeof actions === 'object' ) { for ( var type in actions ) { add ( type , actions [ type ] ) ; } } }
2864	function ( pattern , count , sep ) { for ( var buf = [ ] , i = count ; i -- ; ) { buf . push ( pattern ) ; } return buf . join ( sep || '' ) ; }
2865	function ( config ) { var options = new FileUploadOptions ( ) ; options . fileKey = config . fileKey || "file" ; options . fileName = this . path . substr ( this . path . lastIndexOf ( '/' ) + 1 ) ; options . mimeType = config . mimeType || "image/jpeg" ; options . params = config . params || { } ; options . headers = config . headers || { } ; options . chunkMode = config . chunkMode || true ; var fileTransfer = new FileTransfer ( ) ; fileTransfer . upload ( this . path , encodeURI ( config . url ) , config . success , config . failure , options , config . trustAllHosts || false ) ; return fileTransfer ; }
2866	function ( config ) { var fileTransfer = new FileTransfer ( ) ; fileTransfer . download ( encodeURI ( config . source ) , this . path , config . success , config . failure , config . trustAllHosts || false , config . options || { } ) ; return fileTransfer ; }
2867	function ( property , value , anyMatch , caseSensitive ) { if ( property ) { if ( Ext . isString ( property ) ) { this . addFilters ( { property : property , value : value , anyMatch : anyMatch , caseSensitive : caseSensitive } ) ; return this . items ; } else { this . addFilters ( property ) ; return this . items ; } } this . items = this . mixins . filterable . filter . call ( this , this . all . slice ( ) ) ; this . updateAfterFilter ( ) ; if ( this . sorted && this . getAutoSort ( ) ) { this . sort ( ) ; } }
2868	function ( fn , scope ) { var keys = this . keys , items = this . items , ln = keys . length , i ; for ( i = 0 ; i < ln ; i ++ ) { fn . call ( scope || window , keys [ i ] , items [ i ] , i , ln ) ; } }
2869	function ( fn , scope ) { var me = this , newCollection = new this . self ( ) , keys = me . keys , items = me . all , length = items . length , i ; newCollection . getKey = me . getKey ; for ( i = 0 ; i < length ; i ++ ) { if ( fn . call ( scope || me , items [ i ] , me . getKey ( items [ i ] ) ) ) { newCollection . add ( keys [ i ] , items [ i ] ) ; } } return newCollection ; }
2870	function ( item ) { var index = this . items . indexOf ( item ) ; if ( index === - 1 ) { Ext . Array . remove ( this . all , item ) ; if ( typeof this . getKey == 'function' ) { var key = this . getKey ( item ) ; if ( key !== undefined ) { delete this . map [ key ] ; } } return item ; } return this . removeAt ( this . items . indexOf ( item ) ) ; }
2871	function ( items ) { if ( items ) { var ln = items . length , i ; for ( i = 0 ; i < ln ; i ++ ) { this . remove ( items [ i ] ) ; } } return this ; }
2872	function ( item ) { if ( this . dirtyIndices ) { this . updateIndices ( ) ; } var index = item ? this . indices [ this . getKey ( item ) ] : - 1 ; return ( index === undefined ) ? - 1 : index ; }
2873	function ( item ) { var key = this . getKey ( item ) ; if ( key ) { return this . containsKey ( key ) ; } else { return Ext . Array . contains ( this . items , item ) ; } }
2874	function ( start , end ) { var me = this , items = me . items , range = [ ] , i ; if ( items . length < 1 ) { return range ; } start = start || 0 ; end = Math . min ( typeof end == 'undefined' ? me . length - 1 : end , me . length - 1 ) ; if ( start <= end ) { for ( i = start ; i <= end ; i ++ ) { range [ range . length ] = items [ i ] ; } } else { for ( i = start ; i >= end ; i -- ) { range [ range . length ] = items [ i ] ; } } return range ; }
2875	function ( fn , scope , start ) { var me = this , keys = me . keys , items = me . items , i = start || 0 , ln = items . length ; for ( ; i < ln ; i ++ ) { if ( fn . call ( scope || me , items [ i ] , keys [ i ] ) ) { return i ; } } return - 1 ; }
2876	function ( ) { var me = this , copy = new this . self ( ) , keys = me . keys , items = me . items , i = 0 , ln = items . length ; for ( ; i < ln ; i ++ ) { copy . add ( keys [ i ] , items [ i ] ) ; } copy . getKey = me . getKey ; return copy ; }
2877	function ( newMonthText , oldMonthText ) { var innerItems = this . getInnerItems , ln = innerItems . length , item , i ; if ( this . initialized ) { for ( i = 0 ; i < ln ; i ++ ) { item = innerItems [ i ] ; if ( ( typeof item . title == "string" && item . title == oldMonthText ) || ( item . title . html == oldMonthText ) ) { item . setTitle ( newMonthText ) ; } } } }
2878	function ( yearText ) { var innerItems = this . getInnerItems , ln = innerItems . length , item , i ; if ( this . initialized ) { for ( i = 0 ; i < ln ; i ++ ) { item = innerItems [ i ] ; if ( item . title == this . yearText ) { item . setTitle ( yearText ) ; } } } }
2879	function ( ) { var me = this , slotOrder = me . getSlotOrder ( ) , yearsFrom = me . getYearFrom ( ) , yearsTo = me . getYearTo ( ) , years = [ ] , days = [ ] , months = [ ] , reverse = yearsFrom > yearsTo , ln , i , daysInMonth ; while ( yearsFrom ) { years . push ( { text : yearsFrom , value : yearsFrom } ) ; if ( yearsFrom === yearsTo ) { break ; } if ( reverse ) { yearsFrom -- ; } else { yearsFrom ++ ; } } daysInMonth = me . getDaysInMonth ( 1 , new Date ( ) . getFullYear ( ) ) ; for ( i = 0 ; i < daysInMonth ; i ++ ) { days . push ( { text : i + 1 , value : i + 1 } ) ; } for ( i = 0 , ln = Ext . Date . monthNames . length ; i < ln ; i ++ ) { months . push ( { text : Ext . Date . monthNames [ i ] , value : i + 1 } ) ; } var slots = [ ] ; slotOrder . forEach ( function ( item ) { slots . push ( me . createSlot ( item , days , months , years ) ) ; } ) ; me . setSlots ( slots ) ; }
2880	function ( name , days , months , years ) { switch ( name ) { case 'year' : return { name : 'year' , align : 'center' , data : years , title : this . getYearText ( ) , flex : 3 } ; case 'month' : return { name : name , align : 'right' , data : months , title : this . getMonthText ( ) , flex : 4 } ; case 'day' : return { name : 'day' , align : 'center' , data : days , title : this . getDayText ( ) , flex : 2 } ; } }
2881	function ( user ) { if ( user ) { if ( ! ! ~ this . roles . indexOf ( '*' ) ) { return true ; } else { for ( var userRoleIndex in user . roles ) { for ( var roleIndex in this . roles ) { if ( this . roles [ roleIndex ] === user . roles [ userRoleIndex ] ) { return true ; } } } } } else { return this . isPublic ; } return false ; }
2882	function ( ) { var text = this . backButtonStack [ this . backButtonStack . length - 2 ] , useTitleForBackButtonText = this . getUseTitleForBackButtonText ( ) ; if ( ! useTitleForBackButtonText ) { if ( text ) { text = this . getDefaultBackButtonText ( ) ; } } return text ; }
2883	function ( element ) { var ghost , x , y , left , width ; ghost = element . dom . cloneNode ( true ) ; ghost . id = element . id + '-proxy' ; element . getParent ( ) . dom . appendChild ( ghost ) ; ghost = Ext . get ( ghost ) ; x = element . getX ( ) ; y = element . getY ( ) ; left = element . getLeft ( ) ; width = element . getWidth ( ) ; ghost . setStyle ( 'position' , 'absolute' ) ; ghost . setX ( x ) ; ghost . setY ( y ) ; ghost . setHeight ( element . getHeight ( ) ) ; ghost . setWidth ( width ) ; return { x : x , y : y , left : left , width : width , ghost : ghost } ; }
2884	function plugin ( options ) { options = options || { } ; options . key = options . key || 'untemplatized' ; return function ( files , metalsmith , done ) { setImmediate ( done ) ; Object . keys ( files ) . forEach ( function ( file ) { debug ( 'checking file: %s' , file ) ; var data = files [ file ] ; var contents = data . contents . toString ( ) . replace ( / ^\n+ / g , '' ) ; debug ( 'storing untemplatized content: %s' , file ) ; data [ options . key ] = new Buffer ( contents ) ; } ) ; } ; }
2885	function defaultMapFn ( data ) { return Object . keys ( data ) . slice ( 0 , this . headers . length ) . map ( function ( key ) { return data [ key ] } ) }
2886	function scheduleJob ( trigger , jobFunc , jobData ) { const job = Job . createJob ( trigger , jobFunc , jobData ) ; const excuteTime = job . excuteTime ( ) ; const id = job . id ; map [ id ] = job ; const element = { id : id , time : excuteTime } ; const curJob = queue . peek ( ) ; if ( ! curJob || excuteTime < curJob . time ) { queue . offer ( element ) ; setTimer ( job ) ; return job . id ; } queue . offer ( element ) ; return job . id ; }
2887	function defineType ( type , validator ) { var typeDef ; var regKey ; if ( type instanceof Function ) { validator = _customValidator ( type ) ; type = type . name ; } else if ( ! ( validator instanceof Function ) ) { throw TypeException ( 'Validator must be a function for `{{type}}`' , null , null , { type : type } ) ; } typeDef = parseTypeDef ( type ) ; regKey = typeDef . name . toLocaleLowerCase ( ) ; if ( primitives [ regKey ] ) { throw TypeException ( 'Cannot override primitive type `{{type}}`' , null , null , { type : typeDef . name } ) ; } else if ( registry [ regKey ] && ( registry [ regKey ] . validator !== validator ) ) { throw TypeException ( 'Validator conflict for type `{{type}}` ' , null , null , { type : typeDef . name } ) ; } registry [ regKey ] = { type : typeDef . name , validator : validator } ; return validator ; }
2888	function undefineType ( type ) { var validator ; var typeDef = parseTypeDef ( type ) ; var regKey = typeDef . name . toLocaleLowerCase ( ) ; if ( primitives [ regKey ] ) { throw TypeException ( 'Cannot undefine primitive type `{{type}}`' , null , null , { type : typeDef . name } ) ; } validator = registry [ regKey ] && registry [ regKey ] . validator ; delete registry [ regKey ] ; return validator || false ; }
2889	function checkType ( type , value , previous , attributeName ) { var typeDef = parseTypeDef ( type ) ; var regKey = typeDef . name . toLocaleLowerCase ( ) ; validator = primitives [ regKey ] || ( registry [ regKey ] && registry [ regKey ] . validator ) ; if ( ! validator ) { throw TypeException ( 'Unknown type `{{type}}`' , null , [ attributeName ] , { type : typeDef . name } ) ; } else if ( typeDef . indexes ) { return arrayValidation ( typeDef , 0 , value , previous , attributeName , validator ) ; } return validator ( value , previous , attributeName ) ; }
2890	function getDefinedNames ( ) { return Object . keys ( primitives ) . concat ( Object . keys ( registry ) . map ( function ( type ) { return registry [ type ] . type ; } ) ) ; }
2891	function ( comment ) { const isLicense = comment . toLowerCase ( ) . includes ( "license" ) || comment . toLowerCase ( ) . includes ( "copyright" ) ; if ( isLicense === false ) { return false ; } if ( lastLicense !== comment ) { lastLicense = comment ; return true ; } else { return false ; } }
2892	function get ( k ) { if ( ! k ) return _SETTINGS let v = _ . get ( _SETTINGS , k ) if ( ! v ) return if ( _ . isString ( k ) && k . indexOf ( 'paths.' ) !== 0 ) return v let args = _ . drop ( _ . toArray ( arguments ) ) let argsLength = args . unshift ( v ) return path . join . apply ( path , args ) }
2893	function load ( src ) { if ( ! src || ! _ . isString ( src ) ) return let file = _ . attempt ( require , src ) if ( ! file || _ . isError ( file ) || ! _ . isPlainObject ( file ) ) return return _ . merge ( _SETTINGS , file ) }
2894	function ( size , units ) { if ( size === "" || size == "auto" || size === undefined || size === null ) { return size || '' ; } if ( Ext . isNumber ( size ) || this . numberRe . test ( size ) ) { return size + ( units || this . defaultUnit || 'px' ) ; } else if ( ! this . unitRe . test ( size ) ) { Ext . Logger . warn ( "Warning, size detected (" + size + ") not a valid property value on Element.addUnits." ) ; return size || '' ; } return size ; }
2895	function ( form ) { var fElements = form . elements || ( document . forms [ form ] || Ext . getDom ( form ) ) . elements , hasSubmit = false , encoder = encodeURIComponent , name , data = '' , type , hasValue ; Ext . each ( fElements , function ( element ) { name = element . name ; type = element . type ; if ( ! element . disabled && name ) { if ( / select-(one|multiple) / i . test ( type ) ) { Ext . each ( element . options , function ( opt ) { if ( opt . selected ) { hasValue = opt . hasAttribute ? opt . hasAttribute ( 'value' ) : opt . getAttributeNode ( 'value' ) . specified ; data += Ext . String . format ( "{0}={1}&" , encoder ( name ) , encoder ( hasValue ? opt . value : opt . text ) ) ; } } ) ; } else if ( ! ( / file|undefined|reset|button / i . test ( type ) ) ) { if ( ! ( / radio|checkbox / i . test ( type ) && ! element . checked ) && ! ( type == 'submit' && hasSubmit ) ) { data += encoder ( name ) + '=' + encoder ( element . value ) + '&' ; hasSubmit = / submit / i . test ( type ) ; } } } } ) ; return data . substr ( 0 , data . length - 1 ) ; }
2896	function ( ) { Ext . Logger . deprecate ( "Ext.Element.getDocumentWidth() is no longer supported. " + "Please use Ext.Viewport#getWindowWidth() instead" , this ) ; return Math . max ( ! Ext . isStrict ? document . body . scrollWidth : document . documentElement . scrollWidth , this . getViewportWidth ( ) ) ; }
2897	function ( ) { Ext . Logger . deprecate ( "Ext.Element.getOrientation() is no longer supported. " + "Please use Ext.Viewport#getOrientation() instead" , this ) ; if ( Ext . supports . OrientationChange ) { return ( window . orientation == 0 ) ? 'portrait' : 'landscape' ; } return ( window . innerHeight > window . innerWidth ) ? 'portrait' : 'landscape' ; }
2898	function ( el , config ) { config = config || { } ; Ext . apply ( this , config ) ; this . addEvents ( 'sortstart' , 'sortend' , 'sortchange' ) ; this . el = Ext . get ( el ) ; this . callParent ( ) ; this . mixins . observable . constructor . call ( this ) ; if ( this . direction == 'horizontal' ) { this . horizontal = true ; } else if ( this . direction == 'vertical' ) { this . vertical = true ; } else { this . horizontal = this . vertical = true ; } this . el . addCls ( this . baseCls ) ; this . startEventName = ( this . getDelay ( ) > 0 ) ? 'taphold' : 'tapstart' ; if ( ! this . disabled ) { this . enable ( ) ; } }
2899	function ( ) { this . el . on ( this . startEventName , this . onStart , this , { delegate : this . itemSelector , holdThreshold : this . getDelay ( ) } ) ; this . disabled = false ; }
2900	function _compareMaps ( a , b , options ) { debug ( a , b ) ; let alength = a . size === undefined ? a . length : a . size ; let blength = b . size === undefined ? b . length : b . size ; if ( alength === 0 && blength === 0 ) return ops . NOP ; if ( alength === 0 || blength === 0 ) return new ops . Map ( [ ... b ] ) ; let patch = [ ] ; if ( ! options . sorted ) { a = Array . from ( a ) . sort ( ( a , b ) => utils . compare ( a , b , options ) ) ; b = Array . from ( b ) . sort ( ( a , b ) => utils . compare ( a , b , options ) ) ; } let ai = 1 , bi = 1 ; let ao = a [ 0 ] , bo = b [ 0 ] let element_options = options . getArrayElementOptions ( ) ; do { let comparison = utils . compare ( ao , bo , options ) ; debug ( "comparing items" , ao , bo , comparison ) ; if ( comparison < 0 ) { debug ( 'skip' ) ; ao = a [ ai ++ ] ; } else if ( comparison > 0 ) { debug ( 'insert' ) ; patch . push ( [ options . key ( bo ) , new ops . Ins ( options . value ( bo ) ) ] ) ; bo = b [ bi ++ ] ; } else { if ( options . value ( ao ) !== options . value ( bo ) ) { let element_patch = compare ( options . value ( ao ) , options . value ( bo ) , element_options ) if ( element_patch != ops . NOP ) patch . push ( [ options . key ( bo ) , element_patch ] ) ; } else debug ( 'skip2' ) ; ao = a [ ai ++ ] ; bo = b [ bi ++ ] ; } } while ( ai <= a . length && bi <= b . length ) ; while ( ai <= a . length ) { patch . push ( [ options . key ( ao ) , ops . DEL ] ) ; ao = a [ ai ++ ] ; } while ( bi <= b . length ) { patch . push ( [ options . key ( bo ) , new ops . Ins ( options . value ( bo ) ) ] ) ; bo = b [ bi ++ ] ; } return new ops . Map ( patch ) ; }
2901	function compare ( a , b , options ) { debug ( 'compare %j,%j options: %j' , a , b , options ) ; options = Options . addDefaults ( options ) ; debug ( 'compare - options %j' , options ) ; if ( a === b ) return ops . NOP ; if ( b === undefined ) return ops . DEL ; if ( a === undefined ) return new ops . Rpl ( b ) ; if ( typeof a === 'object' && typeof b === 'object' ) { if ( utils . isArrayLike ( a ) && utils . isArrayLike ( b ) ) { if ( options . map ) { return _compareMaps ( a , b , options ) ; } else { return _compareArrays ( a , b , options ) ; } } else if ( a instanceof Map && b instanceof Map ) { return _compareMaps ( a , b , options ) ; } else if ( a . constructor === b . constructor ) { return _compareObjects ( a , b , options ) ; } } return new ops . Rpl ( b ) ; }
2902	function fromJSON ( object ) { if ( object instanceof ops . Op ) return object ; if ( object === undefined ) return ops . NOP ; if ( object . op ) { if ( object . op === ops . Rpl . name ) return new ops . Rpl ( object . data ) ; if ( object . op === ops . Ins . name ) return new ops . Ins ( object . data ) ; else if ( object . op === ops . NOP . name ) return ops . NOP ; else if ( object . op === ops . DEL . name ) return ops . DEL ; else if ( object . op === ops . Mrg . name ) return new ops . Mrg ( utils . map ( object . data , fromJSON ) ) ; else if ( object . op === ops . Map . name ) return new ops . Map ( object . data . map ( ( [ key , op ] ) => [ key , fromJSON ( op ) ] ) ) ; else if ( object . op === ops . Arr . name ) return new ops . Arr ( object . data . map ( ( [ key , op ] ) => [ key , fromJSON ( op ) ] ) ) ; else throw new Error ( 'unknown diff.op ' + object . op ) ; } else { return new ops . Rpl ( object ) ; } }
2903	function ( sorterFn ) { var me = this , items = me . items , keys = me . keys , length = items . length , temp = [ ] , i ; for ( i = 0 ; i < length ; i ++ ) { temp [ i ] = { key : keys [ i ] , value : items [ i ] , index : i } ; } Ext . Array . sort ( temp , function ( a , b ) { var v = sorterFn ( a . value , b . value ) ; if ( v === 0 ) { v = ( a . index < b . index ? - 1 : 1 ) ; } return v ; } ) ; for ( i = 0 ; i < length ; i ++ ) { items [ i ] = temp [ i ] . value ; keys [ i ] = temp [ i ] . key ; } me . fireEvent ( 'sort' , me , items , keys ) ; }
2904	function ( mapping ) { var me = this , items = me . items , index = 0 , length = items . length , order = [ ] , remaining = [ ] , oldIndex ; me . suspendEvents ( ) ; for ( oldIndex in mapping ) { order [ mapping [ oldIndex ] ] = items [ oldIndex ] ; } for ( index = 0 ; index < length ; index ++ ) { if ( mapping [ index ] == undefined ) { remaining . push ( items [ index ] ) ; } } for ( index = 0 ; index < length ; index ++ ) { if ( order [ index ] == undefined ) { order [ index ] = remaining . shift ( ) ; } } me . clear ( ) ; me . addAll ( order ) ; me . resumeEvents ( ) ; me . fireEvent ( 'sort' , me ) ; }
2905	function apply ( func , args , self ) { return ( typeof func === 'function' ) ? func . apply ( self , array ( args ) ) : func }
2906	function detectDeviceClass ( ) { var body = document . body ; if ( isMobile . any ( ) ) { body . classList . add ( 'mobile' ) ; } if ( isMobile . Android ( ) ) { body . classList . add ( 'android' ) ; } if ( isTablet . any ( ) ) { body . classList . add ( 'tablet' ) ; } }
2907	function detectWindowWidth ( ) { var mobileWidth = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : 730 ; var isMobileWidth = window . innerWidth < mobileWidth ; var body = document . body ; if ( isMobileWidth ) { body . classList . add ( 'is-mobile-width' ) ; } else { body . classList . remove ( 'is-mobile-width' ) ; } }
2908	function ( config , callback , scope ) { var changed = false ; if ( config ) { config . config_id = 'csv' ; Ext . data . CSV . superclass . constructor . call ( this , config ) ; if ( config . v ) { this . v = [ ] ; this . do_add ( config . v ) ; } } if ( this . v === undefined ) { this . v = [ ] ; changed = true ; } this . writeAndCallback ( changed , callback , scope ) ; }
2909	function ( array , insert , at ) { at = Math . min ( Math . max ( at , 0 ) , array . length ) ; var tail = Array ( array . length - at ) ; var length = insert . length ; for ( var i = 0 ; i < tail . length ; i ++ ) tail [ i ] = array [ i + at ] ; for ( i = 0 ; i < length ; i ++ ) array [ i + at ] = insert [ i ] ; for ( i = 0 ; i < tail . length ; i ++ ) array [ i + length + at ] = tail [ i ] ; }
2910	function ( models , options ) { options = _ . extend ( { } , options ) ; var singular = ! _ . isArray ( models ) ; models = singular ? [ models ] : _ . clone ( models ) ; var removed = this . _removeModels ( models , options ) ; if ( ! options . silent && removed ) this . trigger ( 'update' , this , options ) ; return singular ? removed [ 0 ] : removed ; }
2911	function ( models , options ) { var removed = [ ] ; for ( var i = 0 ; i < models . length ; i ++ ) { var model = this . get ( models [ i ] ) ; if ( ! model ) continue ; var index = this . indexOf ( model ) ; this . models . splice ( index , 1 ) ; this . length -- ; if ( ! options . silent ) { options . index = index ; model . trigger ( 'remove' , model , this , options ) ; } removed . push ( model ) ; this . _removeReference ( model , options ) ; } return removed . length ? removed : false ; }
2912	function ( ) { var path = this . decodeFragment ( this . location . pathname ) ; var root = path . slice ( 0 , this . root . length - 1 ) + '/' ; return root === this . root ; }
2913	function getViewTemplateData ( view , viewOptions ) { var data , meta = view . declarativeViews . meta ; if ( ! meta . processed ) { if ( view . template && _ . isString ( view . template ) ) { meta . originalTemplateProp = view . template ; data = getTemplateData ( view . template , view , viewOptions ) ; meta . processed = true ; meta . inGlobalCache = true ; if ( data ) events . trigger ( "cacheEntry:view:process" , _copyCacheEntry ( data ) , meta . originalTemplateProp , view , viewOptions ) ; } else { data = undefined ; meta . processed = true ; meta . inGlobalCache = false ; } } else { data = meta . inGlobalCache ? getTemplateData ( meta . originalTemplateProp , view , viewOptions ) : undefined ; } if ( data ) events . trigger ( "cacheEntry:view:fetch" , data , meta . originalTemplateProp , view , viewOptions ) ; return data ; }
2914	function clearCache ( fromMarionette ) { templateCache = { } ; if ( ! fromMarionette && Backbone . Marionette && Backbone . Marionette . TemplateCache ) Backbone . Marionette . TemplateCache . clear ( ) ; }
2915	function clearCachedTemplate ( templateProp ) { var fromMarionette = false , args = _ . toArray ( arguments ) , lastArg = _ . last ( args ) ; if ( args . length && _ . isBoolean ( lastArg ) ) fromMarionette = args . pop ( ) ; if ( args . length > 1 ) { _ . each ( args , function ( singleProp ) { clearCachedTemplate ( singleProp , fromMarionette ) ; } ) ; } else if ( _ . isArray ( templateProp ) || _ . isArguments ( templateProp ) ) { _ . each ( templateProp , function ( singleProp ) { clearCachedTemplate ( singleProp , fromMarionette ) ; } ) ; } else { if ( ! templateProp ) throw new GenericError ( "Missing argument: string identifying the template. The string should be a template selector or the raw HTML of a template, as provided to the template property of a view when the cache entry was created" ) ; if ( _ . isString ( templateProp ) ) { _clearCachedTemplate ( templateProp ) ; if ( ! fromMarionette && Backbone . Marionette && Backbone . Marionette . TemplateCache ) { try { Backbone . Marionette . TemplateCache . clear ( templateProp ) ; } catch ( err ) { } } } } }
2916	function clearViewTemplateCache ( view ) { var meta = view . declarativeViews . meta ; if ( meta . processed ) { if ( meta . inGlobalCache ) _clearCachedTemplate ( meta . originalTemplateProp ) ; } else if ( view . template && _ . isString ( view . template ) ) { _clearCachedTemplate ( view . template ) ; } }
2917	function _copyCacheEntry ( cacheEntry ) { var copy = _ . clone ( cacheEntry ) ; if ( _ . isObject ( copy . attributes ) ) copy . attributes = _ . clone ( copy . attributes ) ; return copy ; }
2918	function _createTemplateCache ( templateProp , view , viewOptions ) { var $template , data , html , customLoader = Backbone . DeclarativeViews . custom . loadTemplate , defaultLoader = Backbone . DeclarativeViews . defaults . loadTemplate , modifiedDefaultLoader = defaultLoader !== loadTemplate , cacheId = templateProp ; try { $template = customLoader ? customLoader ( templateProp , view , viewOptions ) : defaultLoader ( templateProp , view , viewOptions ) ; } catch ( err ) { if ( _isDeclarativeViewsErrorType ( err ) ) throw err ; $template = "" ; } if ( ( customLoader || modifiedDefaultLoader ) && $template !== "" && ! ( $template instanceof Backbone . $ ) ) { throw new CustomizationError ( "Invalid return value. The " + ( customLoader ? "custom" : "default" ) + " loadTemplate function must return a jQuery instance, but it hasn't" ) ; } if ( $template . length ) { data = _getDataAttributes ( $template ) ; html = $template . html ( ) ; templateCache [ cacheId ] = { html : html , compiled : _tryCompileTemplate ( html , $template ) , tagName : data . tagName , className : data . className , id : data . id , attributes : data . attributes , _pluginData : { } } ; events . trigger ( "cacheEntry:create" , templateCache [ cacheId ] , templateProp , view , viewOptions ) ; } else { templateCache [ cacheId ] = { invalid : true } ; } return templateCache [ cacheId ] ; }
2919	function _updateJQueryDataCache ( $elem ) { var add = { } , remove = [ ] ; if ( $ . hasData ( $elem [ 0 ] ) ) { _ . each ( registeredDataAttributes . primitives , function ( attributeName ) { var attributeValue = $elem . attr ( "data-" + attributeName ) ; if ( attributeValue === undefined ) { remove . push ( attributeName ) ; } else { add [ toCamelCase ( attributeName ) ] = attributeValue ; } } ) ; _ . each ( registeredDataAttributes . json , function ( attributeName ) { var attributeValue = $elem . attr ( "data-" + attributeName ) ; if ( attributeValue === undefined ) { remove . push ( attributeName ) ; } else { try { add [ toCamelCase ( attributeName ) ] = $ . parseJSON ( attributeValue ) ; } catch ( err ) { remove . push ( attributeName ) ; } } } ) ; if ( remove . length ) $elem . removeData ( remove ) ; if ( _ . size ( add ) ) $elem . data ( add ) ; } }
2920	function _registerCacheAlias ( namespaceObject , instanceCachePropertyName ) { namespaceObject . getCachedTemplate = Backbone . DeclarativeViews . getCachedTemplate ; namespaceObject . clearCachedTemplate = Backbone . DeclarativeViews . clearCachedTemplate ; namespaceObject . clearCache = Backbone . DeclarativeViews . clearCache ; namespaceObject . custom = Backbone . DeclarativeViews . custom ; if ( instanceCachePropertyName ) { instanceCacheAliases . push ( instanceCachePropertyName ) ; instanceCacheAliases = _ . unique ( instanceCacheAliases ) ; } }
2921	function _isDeclarativeViewsErrorType ( error ) { return error instanceof GenericError || error instanceof TemplateError || error instanceof CompilerError || error instanceof CustomizationError || error instanceof ConfigurationError ; }
2922	function createCustomErrorType ( name ) { function CustomError ( message ) { this . message = message ; if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , this . constructor ) ; } else { this . stack = ( new Error ( ) ) . stack ; } } CustomError . prototype = new Error ( ) ; CustomError . prototype . name = name ; CustomError . prototype . constructor = CustomError ; return CustomError ; }
2923	function ( name ) { var config = this . _wreqrHandlers [ name ] ; if ( ! config ) { return ; } return function ( ) { return config . callback . apply ( config . context , arguments ) ; } ; }
2924	function ( name ) { name = arguments [ 0 ] ; var args = _ . rest ( arguments ) ; if ( this . hasHandler ( name ) ) { this . getHandler ( name ) . apply ( this , args ) ; } else { this . storage . addCommand ( name , args ) ; } }
2925	function ( type , hash , context ) { if ( ! hash ) { return ; } context = context || this ; var method = type === "vent" ? "on" : "setHandler" ; _ . each ( hash , function ( fn , eventName ) { this [ type ] [ method ] ( eventName , _ . bind ( fn , context ) ) ; } , this ) ; }
2926	function iterateEvents ( target , entity , bindings , functionCallback , stringCallback ) { if ( ! entity || ! bindings ) { return ; } if ( ! _ . isObject ( bindings ) ) { throw new Marionette . Error ( { message : 'Bindings must be an object or function.' , url : 'marionette.functions.html#marionettebindentityevents' } ) ; } bindings = Marionette . _getValue ( bindings , target ) ; _ . each ( bindings , function ( methods , evt ) { if ( _ . isFunction ( methods ) ) { functionCallback ( target , entity , evt , methods ) ; } else { stringCallback ( target , entity , evt , methods ) ; } } ) ; }
2927	function ( callback , contextOverride ) { var promise = _ . result ( this . _deferred , 'promise' ) ; this . _callbacks . push ( { cb : callback , ctx : contextOverride } ) ; promise . then ( function ( args ) { if ( contextOverride ) { args . context = contextOverride ; } callback . call ( args . context , args . options ) ; } ) ; }
2928	function ( view , options ) { if ( ! this . _ensureElement ( ) ) { return ; } this . _ensureViewIsIntact ( view ) ; Marionette . MonitorDOMRefresh ( view ) ; var showOptions = options || { } ; var isDifferentView = view !== this . currentView ; var preventDestroy = ! ! showOptions . preventDestroy ; var forceShow = ! ! showOptions . forceShow ; var isChangingView = ! ! this . currentView ; var _shouldDestroyView = isDifferentView && ! preventDestroy ; var _shouldShowView = isDifferentView || forceShow ; if ( isChangingView ) { this . triggerMethod ( 'before:swapOut' , this . currentView , this , options ) ; } if ( this . currentView && isDifferentView ) { delete this . currentView . _parent ; } if ( _shouldDestroyView ) { this . empty ( ) ; } else if ( isChangingView && _shouldShowView ) { this . currentView . off ( 'destroy' , this . empty , this ) ; } if ( _shouldShowView ) { view . once ( 'destroy' , this . empty , this ) ; view . _parent = this ; this . _renderView ( view ) ; if ( isChangingView ) { this . triggerMethod ( 'before:swap' , view , this , options ) ; } this . triggerMethod ( 'before:show' , view , this , options ) ; Marionette . triggerMethodOn ( view , 'before:show' , view , this , options ) ; if ( isChangingView ) { this . triggerMethod ( 'swapOut' , this . currentView , this , options ) ; } var attachedRegion = Marionette . isNodeAttached ( this . el ) ; var displayedViews = [ ] ; var attachOptions = _ . extend ( { triggerBeforeAttach : this . triggerBeforeAttach , triggerAttach : this . triggerAttach } , showOptions ) ; if ( attachedRegion && attachOptions . triggerBeforeAttach ) { displayedViews = this . _displayedViews ( view ) ; this . _triggerAttach ( displayedViews , 'before:' ) ; } this . attachHtml ( view ) ; this . currentView = view ; if ( attachedRegion && attachOptions . triggerAttach ) { displayedViews = this . _displayedViews ( view ) ; this . _triggerAttach ( displayedViews ) ; } if ( isChangingView ) { this . triggerMethod ( 'swap' , view , this , options ) ; } this . triggerMethod ( 'show' , view , this , options ) ; Marionette . triggerMethodOn ( view , 'show' , view , this , options ) ; return this ; } return this ; }
2929	function ( options ) { var view = this . currentView ; var emptyOptions = options || { } ; var preventDestroy = ! ! emptyOptions . preventDestroy ; if ( ! view ) { return this ; } view . off ( 'destroy' , this . empty , this ) ; this . triggerMethod ( 'before:empty' , view ) ; if ( ! preventDestroy ) { this . _destroyView ( ) ; } this . triggerMethod ( 'empty' , view ) ; delete this . currentView ; if ( preventDestroy ) { this . $el . contents ( ) . detach ( ) ; } return this ; }
2930	function ( regionDefinitions , defaults ) { regionDefinitions = Marionette . _getValue ( regionDefinitions , this , arguments ) ; return _ . reduce ( regionDefinitions , function ( regions , definition , name ) { if ( _ . isString ( definition ) ) { definition = { selector : definition } ; } if ( definition . selector ) { definition = _ . defaults ( { } , definition , defaults ) ; } regions [ name ] = this . addRegion ( name , definition ) ; return regions ; } , { } , this ) ; }
2931	function ( name , definition ) { var region ; if ( definition instanceof Marionette . Region ) { region = definition ; } else { region = Marionette . Region . buildRegion ( definition , Marionette . Region ) ; } this . triggerMethod ( 'before:add:region' , name , region ) ; region . _parent = this ; this . _store ( name , region ) ; this . triggerMethod ( 'add:region' , name , region ) ; return region ; }
2932	function ( ) { var regions = this . getRegions ( ) ; _ . each ( this . _regions , function ( region , name ) { this . _remove ( name , region ) ; } , this ) ; return regions ; }
2933	function ( name , region ) { this . triggerMethod ( 'before:remove:region' , name , region ) ; region . empty ( ) ; region . stopListening ( ) ; delete region . _parent ; delete this . _regions [ name ] ; this . length -- ; this . triggerMethod ( 'remove:region' , name , region ) ; }
2934	function ( templateId , options ) { var cachedTemplate = this . templateCaches [ templateId ] ; if ( ! cachedTemplate ) { cachedTemplate = new Marionette . TemplateCache ( templateId ) ; this . templateCaches [ templateId ] = cachedTemplate ; } return cachedTemplate . load ( options ) ; }
2935	function ( options ) { if ( this . compiledTemplate ) { return this . compiledTemplate ; } var template = this . loadTemplate ( this . templateId , options ) ; this . compiledTemplate = this . compileTemplate ( template , options ) ; return this . compiledTemplate ; }
2936	function ( template , data ) { if ( ! template ) { throw new Marionette . Error ( { name : 'TemplateNotFoundError' , message : 'Cannot render the template since its false, null or undefined.' } ) ; } var templateFunc = _ . isFunction ( template ) ? template : Marionette . TemplateCache . get ( template ) ; return templateFunc ( data ) ; }
2937	function ( target ) { target = target || { } ; var templateHelpers = this . getOption ( 'templateHelpers' ) ; templateHelpers = Marionette . _getValue ( templateHelpers , this ) ; return _ . extend ( target , templateHelpers ) ; }
2938	function ( events ) { this . _delegateDOMEvents ( events ) ; this . bindEntityEvents ( this . model , this . getOption ( 'modelEvents' ) ) ; this . bindEntityEvents ( this . collection , this . getOption ( 'collectionEvents' ) ) ; _ . each ( this . _behaviors , function ( behavior ) { behavior . bindEntityEvents ( this . model , behavior . getOption ( 'modelEvents' ) ) ; behavior . bindEntityEvents ( this . collection , behavior . getOption ( 'collectionEvents' ) ) ; } , this ) ; return this ; }
2939	function ( eventsArg ) { var events = Marionette . _getValue ( eventsArg || this . events , this ) ; events = this . normalizeUIKeys ( events ) ; if ( _ . isUndefined ( eventsArg ) ) { this . events = events ; } var combinedEvents = { } ; var behaviorEvents = _ . result ( this , 'behaviorEvents' ) || { } ; var triggers = this . configureTriggers ( ) ; var behaviorTriggers = _ . result ( this , 'behaviorTriggers' ) || { } ; _ . extend ( combinedEvents , behaviorEvents , events , triggers , behaviorTriggers ) ; Backbone . View . prototype . delegateEvents . call ( this , combinedEvents ) ; }
2940	function ( ) { Backbone . View . prototype . undelegateEvents . apply ( this , arguments ) ; this . unbindEntityEvents ( this . model , this . getOption ( 'modelEvents' ) ) ; this . unbindEntityEvents ( this . collection , this . getOption ( 'collectionEvents' ) ) ; _ . each ( this . _behaviors , function ( behavior ) { behavior . unbindEntityEvents ( this . model , behavior . getOption ( 'modelEvents' ) ) ; behavior . unbindEntityEvents ( this . collection , behavior . getOption ( 'collectionEvents' ) ) ; } , this ) ; return this ; }
2941	function ( ) { if ( this . isDestroyed ) { return this ; } var args = _ . toArray ( arguments ) ; this . triggerMethod . apply ( this , [ 'before:destroy' ] . concat ( args ) ) ; this . isDestroyed = true ; this . triggerMethod . apply ( this , [ 'destroy' ] . concat ( args ) ) ; this . unbindUIElements ( ) ; this . isRendered = false ; this . remove ( ) ; _ . invoke ( this . _behaviors , 'destroy' , args ) ; return this ; }
2942	function ( ) { if ( ! this . ui ) { return ; } if ( ! this . _uiBindings ) { this . _uiBindings = this . ui ; } var bindings = _ . result ( this , '_uiBindings' ) ; this . ui = { } ; _ . each ( bindings , function ( selector , key ) { this . ui [ key ] = this . $ ( selector ) ; } , this ) ; }
2943	function ( ) { var ret = Marionette . _triggerMethod ( this , arguments ) ; this . _triggerEventOnBehaviors ( arguments ) ; this . _triggerEventOnParentLayout ( arguments [ 0 ] , _ . rest ( arguments ) ) ; return ret ; }
2944	function ( ) { var children = this . _getImmediateChildren ( ) ; if ( ! children . length ) { return children ; } return _ . reduce ( children , function ( memo , view ) { if ( ! view . _getNestedViews ) { return memo ; } return memo . concat ( view . _getNestedViews ( ) ) ; } , children ) ; }
2945	function ( ) { if ( ! this . model && ! this . collection ) { return { } ; } var args = [ this . model || this . collection ] ; if ( arguments . length ) { args . push . apply ( args , arguments ) ; } if ( this . model ) { return this . serializeModel . apply ( this , args ) ; } else { return { items : this . serializeCollection . apply ( this , args ) } ; } }
2946	function ( ) { var template = this . getTemplate ( ) ; if ( template === false ) { return ; } if ( ! template ) { throw new Marionette . Error ( { name : 'UndefinedTemplateError' , message : 'Cannot render the template since it is null or undefined.' } ) ; } var data = this . mixinTemplateHelpers ( this . serializeData ( ) ) ; var html = Marionette . Renderer . render ( template , data , this ) ; this . attachElContent ( html ) ; return this ; }
2947	function ( ) { if ( this . collection ) { this . listenTo ( this . collection , 'add' , this . _onCollectionAdd ) ; this . listenTo ( this . collection , 'remove' , this . _onCollectionRemove ) ; this . listenTo ( this . collection , 'reset' , this . render ) ; if ( this . getOption ( 'sort' ) ) { this . listenTo ( this . collection , 'sort' , this . _sortViews ) ; } } }
2948	function ( child , collection , opts ) { var index = opts . at !== undefined && ( opts . index || collection . indexOf ( child ) ) ; if ( this . getOption ( 'filter' ) || index === false ) { index = _ . indexOf ( this . _filteredSortedModels ( index ) , child ) ; } if ( this . _shouldAddChild ( child , index ) ) { this . destroyEmptyView ( ) ; var ChildView = this . getChildView ( child ) ; this . addChild ( child , ChildView , index ) ; } }
2949	function ( ) { var models = this . _filteredSortedModels ( ) ; var orderChanged = _ . find ( models , function ( item , index ) { var view = this . children . findByModel ( item ) ; return ! view || view . _index !== index ; } , this ) ; if ( orderChanged ) { this . resortView ( ) ; } }
2950	function ( ) { this . destroyEmptyView ( ) ; this . destroyChildren ( { checkEmpty : false } ) ; if ( this . isEmpty ( this . collection ) ) { this . showEmptyView ( ) ; } else { this . triggerMethod ( 'before:render:collection' , this ) ; this . startBuffering ( ) ; this . showCollection ( ) ; this . endBuffering ( ) ; this . triggerMethod ( 'render:collection' , this ) ; if ( this . children . isEmpty ( ) && this . getOption ( 'filter' ) ) { this . showEmptyView ( ) ; } } }
2951	function ( ) { var ChildView ; var models = this . _filteredSortedModels ( ) ; _ . each ( models , function ( child , index ) { ChildView = this . getChildView ( child ) ; this . addChild ( child , ChildView , index ) ; } , this ) ; }
2952	function ( addedAt ) { var viewComparator = this . getViewComparator ( ) ; var models = this . collection . models ; addedAt = Math . min ( Math . max ( addedAt , 0 ) , models . length - 1 ) ; if ( viewComparator ) { var addedModel ; if ( addedAt ) { addedModel = models [ addedAt ] ; models = models . slice ( 0 , addedAt ) . concat ( models . slice ( addedAt + 1 ) ) ; } models = this . _sortModelsBy ( models , viewComparator ) ; if ( addedModel ) { models . splice ( addedAt , 0 , addedModel ) ; } } if ( this . getOption ( 'filter' ) ) { models = _ . filter ( models , function ( model , index ) { return this . _shouldAddChild ( model , index ) ; } , this ) ; } return models ; }
2953	function ( ) { var EmptyView = this . getEmptyView ( ) ; if ( EmptyView && ! this . _showingEmptyView ) { this . triggerMethod ( 'before:render:empty' ) ; this . _showingEmptyView = true ; var model = new Backbone . Model ( ) ; this . addEmptyView ( model , EmptyView ) ; this . triggerMethod ( 'render:empty' ) ; } }
2954	function ( child , ChildView , index ) { var childViewOptions = this . getOption ( 'childViewOptions' ) ; childViewOptions = Marionette . _getValue ( childViewOptions , this , [ child , index ] ) ; var view = this . buildChildView ( child , ChildView , childViewOptions ) ; this . _updateIndices ( view , true , index ) ; this . triggerMethod ( 'before:add:child' , view ) ; this . _addChildView ( view , index ) ; this . triggerMethod ( 'add:child' , view ) ; view . _parent = this ; return view ; }
2955	function ( view , index ) { var canTriggerAttach = this . _isShown && ! this . isBuffering && Marionette . isNodeAttached ( this . el ) ; var nestedViews ; this . proxyChildEvents ( view ) ; view . once ( 'render' , function ( ) { if ( this . _isShown && ! this . isBuffering ) { Marionette . triggerMethodOn ( view , 'before:show' , view ) ; } if ( canTriggerAttach && this . _triggerBeforeAttach ) { nestedViews = this . _getViewAndNested ( view ) ; this . _triggerMethodMany ( nestedViews , this , 'before:attach' ) ; } } , this ) ; this . children . add ( view ) ; this . renderChildView ( view , index ) ; if ( canTriggerAttach && this . _triggerAttach ) { nestedViews = this . _getViewAndNested ( view ) ; this . _triggerMethodMany ( nestedViews , this , 'attach' ) ; } if ( this . _isShown && ! this . isBuffering ) { Marionette . triggerMethodOn ( view , 'show' , view ) ; } }
2956	function ( view , index ) { if ( ! view . supportsRenderLifecycle ) { Marionette . triggerMethodOn ( view , 'before:render' , view ) ; } view . render ( ) ; if ( ! view . supportsRenderLifecycle ) { Marionette . triggerMethodOn ( view , 'render' , view ) ; } this . attachHtml ( this , view , index ) ; return view ; }
2957	function ( child , ChildViewClass , childViewOptions ) { var options = _ . extend ( { model : child } , childViewOptions ) ; var childView = new ChildViewClass ( options ) ; Marionette . MonitorDOMRefresh ( childView ) ; return childView ; }
2958	function ( view ) { if ( ! view ) { return view ; } this . triggerMethod ( 'before:remove:child' , view ) ; if ( ! view . supportsDestroyLifecycle ) { Marionette . triggerMethodOn ( view , 'before:destroy' , view ) ; } if ( view . destroy ) { view . destroy ( ) ; } else { view . remove ( ) ; } if ( ! view . supportsDestroyLifecycle ) { Marionette . triggerMethodOn ( view , 'destroy' , view ) ; } delete view . _parent ; this . stopListening ( view ) ; this . children . remove ( view ) ; this . triggerMethod ( 'remove:child' , view ) ; this . _updateIndices ( view , false ) ; return view ; }
2959	function ( ) { var elBuffer = document . createDocumentFragment ( ) ; _ . each ( this . _bufferedChildren , function ( b ) { elBuffer . appendChild ( b . el ) ; } ) ; return elBuffer ; }
2960	function ( collectionView , childView , index ) { if ( collectionView . isBuffering ) { collectionView . _bufferedChildren . splice ( index , 0 , childView ) ; } else { if ( ! collectionView . _insertBefore ( childView , index ) ) { collectionView . _insertAfter ( childView ) ; } } }
2961	function ( childView , index ) { var currentView ; var findPosition = this . getOption ( 'sort' ) && ( index < this . children . length - 1 ) ; if ( findPosition ) { currentView = this . children . find ( function ( view ) { return view . _index === index + 1 ; } ) ; } if ( currentView ) { currentView . $el . before ( childView . el ) ; return true ; } return false ; }
2962	function ( ) { if ( this . isDestroyed ) { return this ; } this . triggerMethod ( 'before:destroy:collection' ) ; this . destroyChildren ( { checkEmpty : false } ) ; this . triggerMethod ( 'destroy:collection' ) ; return Marionette . View . prototype . destroy . apply ( this , arguments ) ; }
2963	function ( options ) { var destroyOptions = options || { } ; var shouldCheckEmpty = true ; var childViews = this . children . map ( _ . identity ) ; if ( ! _ . isUndefined ( destroyOptions . checkEmpty ) ) { shouldCheckEmpty = destroyOptions . checkEmpty ; } this . children . each ( this . removeChildView , this ) ; if ( shouldCheckEmpty ) { this . checkEmpty ( ) ; } return childViews ; }
2964	function ( ) { if ( this . collection ) { this . listenTo ( this . collection , 'add' , this . _onCollectionAdd ) ; this . listenTo ( this . collection , 'remove' , this . _onCollectionRemove ) ; this . listenTo ( this . collection , 'reset' , this . _renderChildren ) ; if ( this . getOption ( 'sort' ) ) { this . listenTo ( this . collection , 'sort' , this . _sortViews ) ; } } }
2965	function ( ) { var data = { } ; if ( this . model ) { data = _ . partial ( this . serializeModel , this . model ) . apply ( this , arguments ) ; } return data ; }
2966	function ( ) { this . _ensureViewIsIntact ( ) ; this . _isRendering = true ; this . resetChildViewContainer ( ) ; this . triggerMethod ( 'before:render' , this ) ; this . _renderTemplate ( ) ; this . _renderChildren ( ) ; this . _isRendering = false ; this . isRendered = true ; this . triggerMethod ( 'render' , this ) ; return this ; }
2967	function ( ) { var data = { } ; data = this . serializeData ( ) ; data = this . mixinTemplateHelpers ( data ) ; this . triggerMethod ( 'before:render:template' ) ; var template = this . getTemplate ( ) ; var html = Marionette . Renderer . render ( template , data , this ) ; this . attachElContent ( html ) ; this . bindUIElements ( ) ; this . triggerMethod ( 'render:template' ) ; }
2968	function ( options ) { options = options || { } ; this . _firstRender = true ; this . _initializeRegions ( options ) ; Marionette . ItemView . call ( this , options ) ; }
2969	function ( ) { this . _ensureViewIsIntact ( ) ; if ( this . _firstRender ) { this . _firstRender = false ; } else { this . _reInitializeRegions ( ) ; } return Marionette . ItemView . prototype . render . apply ( this , arguments ) ; }
2970	function ( ) { if ( this . isDestroyed ) { return this ; } if ( this . getOption ( 'destroyImmediate' ) === true ) { this . $el . remove ( ) ; } this . regionManager . destroy ( ) ; return Marionette . ItemView . prototype . destroy . apply ( this , arguments ) ; }
2971	function ( regions ) { var defaults = { regionClass : this . getOption ( 'regionClass' ) , parentEl : _ . partial ( _ . result , this , 'el' ) } ; return this . regionManager . addRegions ( regions , defaults ) ; }
2972	function ( options ) { var regions ; this . _initRegionManager ( ) ; regions = Marionette . _getValue ( this . regions , this , [ options ] ) || { } ; var regionOptions = this . getOption . call ( options , 'regions' ) ; regionOptions = Marionette . _getValue ( regionOptions , this , [ options ] ) ; _ . extend ( regions , regionOptions ) ; regions = this . normalizeUIValues ( regions , [ 'selector' , 'el' ] ) ; this . addRegions ( regions ) ; }
2973	function ( ) { this . regionManager = this . getRegionManager ( ) ; this . regionManager . _parent = this ; this . listenTo ( this . regionManager , 'before:add:region' , function ( name ) { this . triggerMethod ( 'before:add:region' , name ) ; } ) ; this . listenTo ( this . regionManager , 'add:region' , function ( name , region ) { this [ name ] = region ; this . triggerMethod ( 'add:region' , name , region ) ; } ) ; this . listenTo ( this . regionManager , 'before:remove:region' , function ( name ) { this . triggerMethod ( 'before:remove:region' , name ) ; } ) ; this . listenTo ( this . regionManager , 'remove:region' , function ( name , region ) { delete this [ name ] ; this . triggerMethod ( 'remove:region' , name , region ) ; } ) ; }
2974	function ( options , key ) { if ( options . behaviorClass ) { return options . behaviorClass ; } return Marionette . _getValue ( Behaviors . behaviorsLookup , this , [ options , key ] ) [ key ] ; }
2975	function ( view , behaviors ) { return _ . chain ( behaviors ) . map ( function ( options , key ) { var BehaviorClass = Behaviors . getBehaviorClass ( options , key ) ; var behavior = new BehaviorClass ( options , view ) ; var nestedBehaviors = Behaviors . parseBehaviors ( view , _ . result ( behavior , 'behaviors' ) ) ; return [ behavior ] . concat ( nestedBehaviors ) ; } ) . flatten ( ) . value ( ) ; }
2976	function ( behavior , i ) { var triggersHash = _ . clone ( _ . result ( behavior , 'triggers' ) ) || { } ; triggersHash = Marionette . normalizeUIKeys ( triggersHash , getBehaviorsUI ( behavior ) ) ; _ . each ( triggersHash , _ . bind ( this . _setHandlerForBehavior , this , behavior , i ) ) ; }
2977	function ( behavior , i , eventName , trigger ) { var triggerKey = trigger . replace ( / ^\S+ / , function ( triggerName ) { return triggerName + '.' + 'behaviortriggers' + i ; } ) ; this . _triggers [ triggerKey ] = this . _view . _buildViewTrigger ( eventName ) ; }
2978	function ( routeName , routeArgs ) { if ( _ . isFunction ( this . onRoute ) ) { var routePath = _ . invert ( this . getOption ( 'appRoutes' ) ) [ routeName ] ; this . onRoute ( routeName , routePath , routeArgs ) ; } }
2979	function ( moduleNames , moduleDefinition ) { var ModuleClass = Marionette . Module . getClass ( moduleDefinition ) ; var args = _ . toArray ( arguments ) ; args . unshift ( this ) ; return ModuleClass . create . apply ( ModuleClass , args ) ; }
2980	function ( options ) { var regions = _ . isFunction ( this . regions ) ? this . regions ( options ) : this . regions || { } ; this . _initRegionManager ( ) ; var optionRegions = Marionette . getOption ( options , 'regions' ) ; if ( _ . isFunction ( optionRegions ) ) { optionRegions = optionRegions . call ( this , options ) ; } _ . extend ( regions , optionRegions ) ; this . addRegions ( regions ) ; return this ; }
2981	function ( ) { this . _regionManager = this . getRegionManager ( ) ; this . _regionManager . _parent = this ; this . listenTo ( this . _regionManager , 'before:add:region' , function ( ) { Marionette . _triggerMethod ( this , 'before:add:region' , arguments ) ; } ) ; this . listenTo ( this . _regionManager , 'add:region' , function ( name , region ) { this [ name ] = region ; Marionette . _triggerMethod ( this , 'add:region' , arguments ) ; } ) ; this . listenTo ( this . _regionManager , 'before:remove:region' , function ( ) { Marionette . _triggerMethod ( this , 'before:remove:region' , arguments ) ; } ) ; this . listenTo ( this . _regionManager , 'remove:region' , function ( name ) { delete this [ name ] ; Marionette . _triggerMethod ( this , 'remove:region' , arguments ) ; } ) ; }
2982	function ( ) { this . channelName = _ . result ( this , 'channelName' ) || 'global' ; this . channel = _ . result ( this , 'channel' ) || Backbone . Wreqr . radio . channel ( this . channelName ) ; this . vent = _ . result ( this , 'vent' ) || this . channel . vent ; this . commands = _ . result ( this , 'commands' ) || this . channel . commands ; this . reqres = _ . result ( this , 'reqres' ) || this . channel . reqres ; }
2983	function ( ) { if ( ! this . _isInitialized ) { return ; } this . _isInitialized = false ; this . triggerMethod ( 'before:stop' ) ; _ . invoke ( this . submodules , 'stop' ) ; this . _finalizerCallbacks . run ( undefined , this ) ; this . _initializerCallbacks . reset ( ) ; this . _finalizerCallbacks . reset ( ) ; this . triggerMethod ( 'stop' ) ; }
2984	function ( app , moduleNames , moduleDefinition ) { var module = app ; var customArgs = _ . drop ( arguments , 3 ) ; moduleNames = moduleNames . split ( '.' ) ; var length = moduleNames . length ; var moduleDefinitions = [ ] ; moduleDefinitions [ length - 1 ] = moduleDefinition ; _ . each ( moduleNames , function ( moduleName , i ) { var parentModule = module ; module = this . _getModule ( parentModule , moduleName , app , moduleDefinition ) ; this . _addModuleDefinition ( parentModule , module , moduleDefinitions [ i ] , customArgs ) ; } , this ) ; return module ; }
2985	function ( parentModule , module , def , args ) { var fn = this . _getDefine ( def ) ; var startWithParent = this . _getStartWithParent ( def , module ) ; if ( fn ) { module . addDefinition ( fn , args ) ; } this . _addStartWithParent ( parentModule , module , startWithParent ) ; }
2986	function _sigName ( src ) { if ( ! _ . isFunction ( src ) ) return '' let ret = _ . trim ( _ . replace ( src . toString ( ) , 'function' , '' ) ) ret = ret . substr ( 0 , ret . indexOf ( '(' ) ) return ret || '' }
2987	function ( ) { var components = this . path . split ( '/' ) ; for ( var i = components . length - 1 ; i >= 0 ; -- i ) { if ( components [ i ] . length > 0 ) { return components [ i ] ; } } return '/' ; }
2988	function ( config ) { if ( config . parent == null ) { Ext . Logger . error ( 'Ext.device.filesystem.Entry#moveTo: You must specify a new `parent` of the entry.' ) ; return null ; } var me = this ; this . getEntry ( { options : config . options || { } , success : function ( sourceEntry ) { config . parent . getEntry ( { options : config . options || { } , success : function ( destinationEntry ) { if ( config . copy ) { sourceEntry . copyTo ( destinationEntry , config . newName , function ( entry ) { config . success . call ( config . scope || me , entry . isDirectory ? Ext . create ( 'Ext.device.filesystem.DirectoryEntry' , entry . fullPath , me . fileSystem ) : Ext . create ( 'Ext.device.filesystem.FileEntry' , entry . fullPath , me . fileSystem ) ) ; } , config . failure ) ; } else { sourceEntry . moveTo ( destinationEntry , config . newName , function ( entry ) { config . success . call ( config . scope || me , entry . isDirectory ? Ext . create ( 'Ext.device.filesystem.DirectoryEntry' , entry . fullPath , me . fileSystem ) : Ext . create ( 'Ext.device.filesystem.FileEntry' , entry . fullPath , me . fileSystem ) ) ; } , config . failure ) ; } } , failure : config . failure } ) ; } , failure : config . failure } ) ; }
2989	function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'Ext.device.filesystem.Entry#getParent: You must specify a `success` callback.' ) ; return null ; } var me = this ; this . getEntry ( { options : config . options || { } , success : function ( entry ) { entry . getParent ( function ( parentEntry ) { config . success . call ( config . scope || me , parentEntry . isDirectory ? Ext . create ( 'Ext.device.filesystem.DirectoryEntry' , parentEntry . fullPath , me . fileSystem ) : Ext . create ( 'Ext.device.filesystem.FileEntry' , parentEntry . fullPath , me . fileSystem ) ) } , config . failure ) } , failure : config . failure } ) }
2990	function ( config ) { var me = this ; var callback = config . success ; if ( ( config . options && config . options . create ) && this . path ) { var folders = this . path . split ( "/" ) ; if ( folders [ 0 ] == '.' || folders [ 0 ] == '' ) { folders = folders . slice ( 1 ) ; } var recursiveCreation = function ( dirEntry ) { if ( folders . length ) { dirEntry . getDirectory ( folders . shift ( ) , config . options , recursiveCreation , config . failure ) ; } else { callback ( dirEntry ) ; } } ; recursiveCreation ( this . fileSystem . fs . root ) ; } else { this . fileSystem . fs . root . getDirectory ( this . path , config . options , function ( directory ) { config . success . call ( config . scope || me , directory ) ; } , config . failure ) ; } }
2991	function ( config ) { var me = this ; var originalConfig = Ext . applyIf ( { } , config ) ; if ( this . fileSystem ) { var failure = function ( evt ) { if ( ( config . options && config . options . create ) && Ext . isString ( this . path ) ) { var folders = this . path . split ( "/" ) ; if ( folders [ 0 ] == '.' || folders [ 0 ] == '' ) { folders = folders . slice ( 1 ) ; } if ( folders . length > 1 && ! config . recursive === true ) { folders . pop ( ) ; var dirEntry = Ext . create ( 'Ext.device.filesystem.DirectoryEntry' , folders . join ( "/" ) , me . fileSystem ) ; dirEntry . getEntry ( { options : config . options , success : function ( ) { originalConfig . recursive = true ; me . getEntry ( originalConfig ) ; } , failure : config . failure } ) ; } else { if ( config . failure ) { config . failure . call ( config . scope || me , evt ) ; } } } else { if ( config . failure ) { config . failure . call ( config . scope || me , evt ) ; } } } ; this . fileSystem . fs . root . getFile ( this . path , config . options || null , function ( fileEntry ) { fileEntry . file ( function ( file ) { me . length = file . size ; originalConfig . success . call ( config . scope || me , fileEntry ) ; } , function ( error ) { failure . call ( config . scope || me , error ) ; } ) ; } , function ( error ) { failure . call ( config . scope || me , error ) ; } ) ; } else { config . failure ( { code : - 1 , message : "FileSystem not Initialized" } ) ; } }
2992	function ( config ) { if ( config . size == null ) { Ext . Logger . error ( 'Ext.device.filesystem.FileEntry#write: You must specify a `size` of the file.' ) ; return null ; } var me = this ; this . getEntry ( { success : function ( fileEntry ) { fileEntry . createWriter ( function ( writer ) { writer . truncate ( config . size ) ; config . success . call ( config . scope || me , me ) ; } , function ( error ) { config . failure . call ( config . scope || me , error ) } ) } , failure : function ( error ) { config . failure . call ( config . scope || me , error ) } } ) }
2993	function ( obj ) { const keys = _ . sortBy ( _ . keys ( obj ) , function ( key ) { return key ; } ) ; return _ . zipObject ( keys , _ . map ( keys , function ( key ) { return obj [ key ] ; } ) ) ; }
2994	function ( err ) { if ( err ) return done ( err ) ; var ret ; if ( typeof leave == 'function' ) { try { ret = leave . call ( this , child , parent ) ; } catch ( err ) { return done ( err ) ; } } done ( null , ret ) ; }
2995	function MultiKeyCache ( options ) { options = options || { } ; var self = this ; var dispose = options . dispose ; options . dispose = function ( key , value ) { self . _dispose ( key ) ; if ( dispose ) { dispose ( key , value ) ; } } ; this . cache = new LRU ( options ) ; this . _keyMap = { } ; }
2996	function pipe ( ) { for ( var _len6 = arguments . length , fs = Array ( _len6 ) , _key6 = 0 ; _key6 < _len6 ; _key6 ++ ) { fs [ _key6 ] = arguments [ _key6 ] ; } return function ( ) { var _this3 = this ; var first = fs . shift ( ) ; for ( var _len7 = arguments . length , args = Array ( _len7 ) , _key7 = 0 ; _key7 < _len7 ; _key7 ++ ) { args [ _key7 ] = arguments [ _key7 ] ; } return fs . reduce ( function ( acc , f ) { return f . call ( _this3 , acc ) ; } , first . apply ( this , args ) ) ; } ; }
2997	function createRawHtml ( createTemplateFn , templateLanguage , elCommentConfig , dataAttributes ) { var comment = elCommentConfig . noComment ? "" : "<!-- " + elCommentConfig . createContent ( dataAttributes ) + " , insertion = elCommentConfig . among ? comment : "" , isLeading = ! elCommentConfig . trailing && ! elCommentConfig . among , isTrailing = elCommentConfig . trailing , baseTemplate = createTemplateFn ( templateLanguage , insertion ) ; return isLeading ? comment + baseTemplate : isTrailing ? baseTemplate + comment : baseTemplate ; }
2998	function createComplexTemplate ( templateLanguage , options ) { var t = getTemplateLanguageConstructs ( templateLanguage ) , indent = options && options . indentation || "" , insert = options && options . insertion || "" , lines = [ '<!-- top-level comment (single line) , '<!--' , ' top-level' , ' comment' , ' (multi-line)' , ' , t . if , '<p>This is a %%paragraph' , 'Some random %%text&& with different line breaks.<br><br/><br />' , t . else , '<h1 class="header">This is a %%header&&</h1> ' , t . endIf , t . if , '</p>' , t . endIf , insert , 'Some top-level %%text&&, not wrapped in a tag.<br><br/><br />' , '<!-- comment containing a <div> tag , "<" + "script>alert( 'foo' );</" + "script>" , '<p class="significantWhitespaceExpected">' , ' some text </p>' , '<%%tagName&& %%attrs&&>lorem ipsum</%%tagName&&>' , '<p><h1>Invalid nesting</h1></p>' , t . partial , '<dl class="%%dl_class&&">' , ' ' + t . loop , ' <dt class="dtclass">%%dd_name&&</dt>' , ' <dd class="ddclass">%%dd_content&&</dd>' , ' ' + t . endLoop , '</dl>' ] , innerContent = _ . map ( lines , function ( line ) { return indent + line ; } ) . join ( "\n" ) ; \n }
2999	function getTemplateLanguageConstructs ( templateLanguage ) { var constructs ; switch ( templateLanguage . toLowerCase ( ) ) { case "handlebars" : constructs = { startDelimiter : "{{" , endDelimiter : "}}" , if : "{{#if isActive}}" , else : "{{else}}" , endIf : "{{/if}}" , loop : "{{#each looped as |value index|}}" , endLoop : "{{/each}}" , partial : '{{> userMessage tagName="h2" }}' } ; break ; case "ejs" : constructs = { startDelimiter : "<%= " , endDelimiter : " %>" , if : "<% if (isActive) { %>" , else : "<% } else { %>" , endIf : "<% } %>" , loop : "<% looped.forEach(function(item) { %>" , endLoop : "<% }); %>" , partial : "<%- include('user/show', {user: user}); %>" } ; break ; case "es6" : constructs = { startDelimiter : "${" , endDelimiter : "}" , if : "" , else : "" , endIf : "" , loop : "" , endLoop : "" , partial : "" } ; break ; default : throw new Error ( 'Unsupported template language "' + templateLanguage + '"' ) ; } return constructs ; }
3000	function defineModel ( modelType , options ) { var primaryAttributes ; var attributes ; var prototype ; var staticProto ; var ModelConstructor ; var typeName ; var namespace ; if ( types . isValidType ( modelType ) . indexes ) { throw ModelException ( 'Model type cannot be an array `{{type}}`' , null , null , { type : String ( modelType ) } ) ; } else if ( models [ modelType ] ) { throw ModelException ( 'Model already defined `{{type}}`' , null , null , { type : String ( modelType ) } ) ; } options = options || { } ; primaryAttributes = [ ] ; namespace = _getNamespace ( modelType ) ; typeName = _getTypeName ( modelType ) ; attributes = _prepareAttributes ( options . attributes || { } , primaryAttributes ) ; prototype = _preparePrototype ( options . methods || { } , primaryAttributes , modelType , namespace , typeName ) ; staticProto = _prepareStaticProto ( options . staticMethods || { } , primaryAttributes , options . attributes , prototype . _type ) ; ModelConstructor = Function ( 'Model, events, attributes' , 'return function ' + typeName + 'Model(data) { ' + 'if (!(this instanceof ' + typeName + 'Model)){' + 'return new ' + typeName + 'Model(data);' + '}' + ( attributes ? 'Object.defineProperties(this, attributes);' : '' ) + 'events.emit("create", data);' + 'Model.call(this, data);' + ' }' ) ( Model , events , attributes ) ; util . inherits ( ModelConstructor , Model ) ; Object . defineProperties ( ModelConstructor . prototype , prototype ) ; Object . defineProperties ( ModelConstructor , staticProto ) ; if ( ! types . isDefined ( modelType ) ) { types . define ( modelType , options . typeValidator || _modelTypeValidator ( ModelConstructor ) ) ; } models [ modelType ] = ModelConstructor ; events . emit ( 'define' , { modelType : modelType , namespace : namespace , typeName : typeName , attributes : attributes , constructor : ModelConstructor , options : options } ) ; for ( var attr in attributes ) { Object . freeze ( attributes [ attr ] ) ; } if ( options . attributes ) { Object . freeze ( options . attributes ) ; } if ( attributes ) { Object . freeze ( attributes ) ; } Object . freeze ( primaryAttributes ) ; return ModelConstructor ; }
3001	function Model ( data ) { var attributes = this . __proto__ . constructor . attributes ; var i , ilen ; var dirty = false ; Object . defineProperties ( this , { _id : { configurable : false , enumerable : true , writable : false , value : ++ uniqueId } , _isDirty : { configurable : false , enumerable : true , get : function isDirty ( ) { return dirty ; } , set : function isDirty ( d ) { dirty = d ; if ( ! d && this . _previousData ) { this . _previousData = undefined ; } } } , _isNew : { configurable : false , enumerable : true , get : function isNewModel ( ) { var newModel = false ; var attrValue ; if ( this . _primaryAttributes ) { for ( i = 0 , ilen = this . _primaryAttributes . length ; i < ilen && ! newModel ; ++ i ) { attrValue = this [ this . _primaryAttributes [ i ] ] ; if ( ( attrValue === undefined ) || ( attrValue === null ) ) { newModel = true ; } } } return newModel ; } } } ) ; if ( attributes ) { Object . defineProperties ( this , attributes ) ; Object . defineProperty ( this , '_data' , { configurable : false , enumerable : false , writable : false , value : _defaultData ( attributes ) } ) ; } if ( Array . isArray ( data ) ) { for ( i = 0 , ilen = data . length ; i < ilen ; ++ i ) { if ( this . _primaryAttributes [ i ] ) { this [ this . _primaryAttributes [ i ] ] = data [ i ] ; } } } else if ( data ) { this . fromJSON ( data ) ; } this . _isDirty = false ; }
3002	function Point ( masterApikey , feedID , streamID ) { this . masterApiKey = masterApikey ; this . feedID = feedID . toString ( ) ; this . streamID = streamID . toString ( ) ; }
3003	function ( tabBar , newTab ) { var oldActiveItem = this . getActiveItem ( ) , newActiveItem ; this . setActiveItem ( tabBar . indexOf ( newTab ) ) ; newActiveItem = this . getActiveItem ( ) ; return this . forcedChange || oldActiveItem !== newActiveItem ; }
3004	function ( point1 , point2 ) { var Point = Ext . util . Point ; this . point1 = Point . from ( point1 ) ; this . point2 = Point . from ( point2 ) ; }
3005	function ( lineSegment ) { var point1 = this . point1 , point2 = this . point2 , point3 = lineSegment . point1 , point4 = lineSegment . point2 , x1 = point1 . x , x2 = point2 . x , x3 = point3 . x , x4 = point4 . x , y1 = point1 . y , y2 = point2 . y , y3 = point3 . y , y4 = point4 . y , d = ( x1 - x2 ) * ( y3 - y4 ) - ( y1 - y2 ) * ( x3 - x4 ) , xi , yi ; if ( d == 0 ) { return null ; } xi = ( ( x3 - x4 ) * ( x1 * y2 - y1 * x2 ) - ( x1 - x2 ) * ( x3 * y4 - y3 * x4 ) ) / d ; yi = ( ( y3 - y4 ) * ( x1 * y2 - y1 * x2 ) - ( y1 - y2 ) * ( x3 * y4 - y3 * x4 ) ) / d ; if ( xi < Math . min ( x1 , x2 ) || xi > Math . max ( x1 , x2 ) || xi < Math . min ( x3 , x4 ) || xi > Math . max ( x3 , x4 ) || yi < Math . min ( y1 , y2 ) || yi > Math . max ( y1 , y2 ) || yi < Math . min ( y3 , y4 ) || yi > Math . max ( y3 , y4 ) ) { return null ; } return new Ext . util . Point ( xi , yi ) ; }
3006	function SteroidsSocket ( options ) { var finalTarget ; if ( options . target && net . isIPv6 ( options . target ) ) { finalTarget = normalize6 ( options . target ) ; } else { finalTarget = options . target ; } this . target = finalTarget ; this . port = options . port || 80 ; this . transport = options . transport || 'TCP' ; this . lport = options . lport || null ; this . timeout = options . timeout || 8000 ; this . allowHalfOpen = options . allowHalfOpen || null ; this . wsProto = options . wsProto || 'sip' ; this . wsPath = options . wsPath || null ; }
3007	function timeoutCb ( ) { if ( ! received ) { self . emit ( 'error' , { type : 'socket: timeout' , data : 'Connection problem: No response' } ) ; } wsError = true ; self . close ( ) ; }
3008	function realWidth ( str ) { if ( str == null ) return 0 ; str = stripANSI ( str ) ; return str . length + ( stripEmoji ( str ) . match ( / [^\x00-\xff] / g ) || [ ] ) . length ; }
3009	function ( source , destination ) { gulp . src ( source ) . pipe ( conflict ( destination ) ) . pipe ( gulp . dest ( destination ) ) ; }
3010	function ( source , destination ) { if ( ! fs . existsSync ( destination ) ) mkdir ( '-p' , destination ) ; cp ( '-R' , source , destination ) ; }
3011	function ( tracker , propList ) { var trackingData = tracker [ trackingKeyName ] ; propList . forEach ( function ( name ) { Object . defineProperty ( tracker , name , { enumerable : true , configurable : true , get : function ( ) { return trackingData . object [ name ] ; } , set : function ( x ) { trackingData . actions . push ( { key : name , set : x , } ) ; trackingData . object [ name ] = x ; } , } ) ; } ) ; }
3012	function ( tracker , methodList ) { var trackingData = tracker [ trackingKeyName ] ; methodList . forEach ( function ( name ) { tracker [ name ] = function ( ) { var context = this ; var argsArray = Array . prototype . slice . call ( arguments ) ; if ( this === tracker ) { context = trackingData . object ; trackingData . actions . push ( { key : name , arguments : argsArray , } ) ; } return trackingData . object [ name ] . apply ( context , argsArray ) ; } ; } ) ; }
3013	function ( object ) { var propList = [ ] ; var methodList = [ ] ; for ( var k in object ) { if ( typeof object [ k ] === "function" ) { methodList . push ( k ) ; } else { propList . push ( k ) ; } } return { propList : propList , methodList : methodList , } ; }
3014	function ( config , callback , scope ) { Ext . data . utilities . check ( 'SyncProxy' , 'constructor' , 'config' , config , [ 'store' , 'database_name' , 'key' ] ) ; Ext . data . SyncProxy . superclass . constructor . call ( this , config ) ; this . store = config . store ; this . store . readValue ( 'Sencha.Sync.system_name' , function ( system_name ) { config . system_name = system_name || Ext . data . UUIDGenerator . generate ( ) ; this . store . writeValue ( 'Sencha.Sync.system_name' , config . system_name , function ( ) { Ext . data . utilities . apply ( this , [ 'readConfig_DatabaseDefinition' , 'readConfig_CSV' , 'readConfig_Generator' ] , [ config ] , function ( ) { if ( this . definition . system_name === undefined ) { this . definition . set ( { system_name : Ext . data . UUIDGenerator . generate ( ) } ) ; } console . log ( "SyncProxy - Opened database '" + config . key + "/" + config . database_name + "/" + config . datastore_name + "'" ) if ( callback ) { callback . call ( scope , this ) } } , this ) ; } , this ) ; } , this ) ; }
3015	function ( content ) { content = trim ( content ) ; if ( this . mounted ) { invoke ( this , [ Constants . BLOCK , 'setMountedContent' ] , content ) ; } else { dom . contentNode ( this ) . innerHTML = content ; this . upgrade ( ) ; } }
3016	function ( ) { const props = dom . attrs . toObject ( this ) ; const xprops = this . xprops ; const eprops = get ( xtag , [ 'tags' , this [ Constants . TAGNAME ] , 'accessors' ] , { } ) ; for ( let prop in eprops ) { if ( xprops . hasOwnProperty ( prop ) && eprops . hasOwnProperty ( prop ) && ! BLOCK_COMMON_ACCESSORS . hasOwnProperty ( prop ) ) { props [ prop ] = this [ prop ] ; } } dom . attrs . typeConversion ( props , xprops ) ; return props ; }
3017	function ( deep ) { const node = dom . cloneNode ( this , false ) ; dom . upgrade ( node ) ; node [ Constants . TMPL ] = this [ Constants . TMPL ] ; node [ Constants . INSERTED ] = false ; if ( deep ) { node . content = this . content ; } return node ; }
3018	function blockInit ( node ) { if ( ! node [ Constants . TAGNAME ] ) { node [ Constants . INSERTED ] = false ; node [ Constants . TAGNAME ] = node . tagName . toLowerCase ( ) ; node [ Constants . TMPL ] = { } ; node [ Constants . UID ] = uniqueId ( ) ; return true ; } return false ; }
3019	function blockCreate ( node ) { if ( node . hasChildNodes ( ) ) { Array . prototype . forEach . call ( node . querySelectorAll ( 'script[type="text/x-template"][ref],template[ref]' ) , tmplCompileIterator , node ) ; } node [ Constants . BLOCK ] = new XBElement ( node ) ; }
3020	function accessorsCustomizer ( objValue , srcValue ) { const objSetter = get ( objValue , 'set' ) ; const srcSetter = get ( srcValue , 'set' ) ; return merge ( { } , objValue , srcValue , { set : wrap ( objSetter , wrap ( srcSetter , wrapperFunction ) ) } ) ; }
3021	function wrapperEvents ( srcFunc , objFunc , ... args ) { const event = ( args [ 0 ] instanceof Event ) && args [ 0 ] ; const isStopped = event ? ( ) => event . immediatePropagationStopped : stubFalse ; if ( ! isStopped ( ) && isFunction ( objFunc ) ) { objFunc . apply ( this , args ) ; } if ( ! isStopped ( ) && isFunction ( srcFunc ) ) { srcFunc . apply ( this , args ) ; } }
3022	function accessorsIterator ( options , name , accessors ) { const optionsSetter = get ( options , 'set' ) ; const updateSetter = wrap ( name , wrapperAccessorsSetUpdate ) ; accessors [ name ] = merge ( { } , options , { set : wrap ( optionsSetter , wrap ( updateSetter , wrapperFunction ) ) } ) ; }
3023	function wrapperAccessorsSetUpdate ( accessorName , nextValue , prevValue ) { if ( nextValue !== prevValue && this . xprops . hasOwnProperty ( accessorName ) && this . mounted ) { this [ Constants . BLOCK ] . update ( ) ; } }
3024	function lifecycleRemoved ( ) { this [ Constants . INSERTED ] = false ; const block = this [ Constants . BLOCK ] ; if ( block ) { block . destroy ( ) ; this [ Constants . BLOCK ] = undefined ; } }
3025	function lifecycleInserted ( ) { if ( this [ Constants . INSERTED ] ) { return ; } blockInit ( this ) ; this [ Constants . INSERTED ] = true ; const isScriptContent = Boolean ( this . querySelector ( 'script' ) ) ; if ( isScriptContent ) { lazy ( blockCreateLazy , this ) ; } else { blockCreate ( this ) ; } }
3026	function ( obj , removeProp ) { var newObj = { } ; for ( var prop in obj ) { if ( ! obj . hasOwnProperty ( prop ) || prop === removeProp ) { continue ; } newObj [ prop ] = obj [ prop ] ; } return newObj ; }
3027	function toDashedProperties ( hash ) { var transformed = { } ; _ . each ( hash , function ( value , key ) { transformed [ toDashed ( key ) ] = value ; } ) ; return transformed ; }
3028	function toCamelCasedProperties ( hash ) { var transformed = { } ; _ . each ( hash , function ( value , key ) { transformed [ toCamelCase ( key ) ] = value ; } ) ; return transformed ; }
3029	function dashedKeyAlternatives ( hash ) { var keys = _ . keys ( toDashedProperties ( hash ) ) ; return _ . filter ( keys , function ( key ) { return key . search ( / [^-]-[a-z] / ) !== - 1 ; } ) ; }
3030	function ( selector , root ) { var selectors = selector . split ( ',' ) , length = selectors . length , i = 0 , results = [ ] , noDupResults = [ ] , dupMatcher = { } , query , resultsLn , cmp ; for ( ; i < length ; i ++ ) { selector = Ext . String . trim ( selectors [ i ] ) ; query = this . parse ( selector ) ; results = results . concat ( query . execute ( root ) ) ; } if ( length > 1 ) { resultsLn = results . length ; for ( i = 0 ; i < resultsLn ; i ++ ) { cmp = results [ i ] ; if ( ! dupMatcher [ cmp . id ] ) { noDupResults . push ( cmp ) ; dupMatcher [ cmp . id ] = true ; } } results = noDupResults ; } return results ; }
3031	function ( component , selector ) { if ( ! selector ) { return true ; } var query = this . cache [ selector ] ; if ( ! query ) { this . cache [ selector ] = query = this . parse ( selector ) ; } return query . is ( component ) ; }
3032	function RouterDecorator ( Router ) { function TelemetryRouter ( options ) { if ( ! ( this instanceof TelemetryRouter ) ) { return new TelemetryRouter ( options ) } Router . call ( this , options ) } inherits ( TelemetryRouter , Router ) TelemetryRouter . prototype . getNearestContacts = function ( key , limit , id , cb ) { var self = this var callback = function ( err , shortlist ) { if ( ! err ) { self . _log . debug ( 'sorting shortlist based on telemetry score' ) var profiles = { } each ( shortlist , function ( contact , iteratorCallback ) { var profileCallback = function ( err , profile ) { profiles [ contact . nodeID ] = profile iteratorCallback ( err ) } self . _rpc . telemetry . getProfile ( contact , profileCallback ) } , function ( err ) { if ( err ) { cb ( null , shortlist ) } else { shortlist . sort ( self . _compare . bind ( self , profiles ) ) cb ( null , shortlist ) } } ) } else { cb ( err , null ) } } Router . prototype . getNearestContacts . call ( this , key , limit , id , callback ) } TelemetryRouter . prototype . _compare = function ( profiles , cA , cB ) { var profileA = profiles [ cA . nodeID ] var profileB = profiles [ cB . nodeID ] var scoresA = { } var scoresB = { } this . _rpc . _telopts . metrics . forEach ( function ( Metric ) { var m = new Metric ( ) scoresA [ m . key ] = Metric . score ( m . getMetric ( profileA ) ) scoresB [ m . key ] = Metric . score ( m . getMetric ( profileB ) ) } ) var resultA = TelemetryRouter . getSuccessProbability ( scoresA ) var resultB = TelemetryRouter . getSuccessProbability ( scoresB ) this . _log . debug ( 'success probability is %d% vs %d%' , ( resultA * 100 ) . toFixed ( 3 ) , ( resultB * 100 ) . toFixed ( 3 ) ) if ( Math . abs ( resultB - resultA ) <= 0.005 ) { this . _log . debug ( 'score difference is within threshold, selecting based on throughput' ) return scoresB . throughput - scoresA . throughput } return resultB - resultA } TelemetryRouter . getSuccessProbability = function ( score ) { return ( score . reliability + score . availability + score . latency ) / 3 } return TelemetryRouter }
3033	function ( config ) { if ( ! this . active ) { Ext . Logger . error ( 'Ext.device.sqlite.SQLTransaction#executeSql: An attempt was made to use a SQLTransaction that is no longer usable.' ) ; return null ; } if ( config . sqlStatement == null ) { Ext . Logger . error ( 'Ext.device.sqlite.SQLTransaction#executeSql: You must specify a `sqlStatement` for the transaction.' ) ; return null ; } this . statements . push ( { sqlStatement : config . sqlStatement , arguments : config . arguments , callback : config . callback , failure : config . failure , scope : config . scope } ) ; }
3034	function ( index ) { if ( index < this . getLength ( ) ) { var item = { } ; var row = this . rows [ index ] ; this . names . forEach ( function ( name , index ) { item [ name ] = row [ index ] ; } ) ; return item ; } return null ; }
3035	function createPayload ( name , level , data ) { return { date : getDate ( ) , level : level , name : name , data : data } ; }
3036	function __ENFORCETYPE ( a , ... types ) { if ( env . application_env !== "development" ) return ; let hasError = false ; let expecting ; let got ; let i = 0 ; types . map ( ( t , index ) => { if ( a [ index ] === null ) { hasError = true ; expecting = t ; got = "null" ; i = index ; return ; } switch ( t ) { case "mixed" : break ; case "jsx" : if ( ! React . isValidElement ( a [ index ] ) ) { hasError = true ; expecting = "jsx" ; got = typeof a [ index ] ; i = index ; } case "array" : if ( ! Array . isArray ( a [ index ] ) ) { hasError = true ; expecting = "array" ; got = typeof a [ index ] ; i = index ; } break ; case "object" : if ( typeof a [ index ] !== 'object' || Array . isArray ( a [ index ] ) || a [ index ] === null ) { hasError = true ; expecting = "object" ; i = index ; if ( a [ index ] === null ) { got = 'null' ; } else { got = Array . isArray ( a [ index ] ) ? "array" : typeof a [ index ] ; } } default : if ( typeof a [ index ] !== t ) { hasError = true ; { expecting = t ; got = typeof a [ index ] ; } i = index ; } } } ) ; if ( hasError ) { let err = new Error ( ) ; console . error ( ` ${ i + 1 } ${ expecting } ${ got } ` , err . stack ) ; } }
3037	function assign ( parent , val , keyOpts ) { var target = parent , keyParts = keyOpts . val . toString ( ) . split ( '.' ) ; keyParts . forEach ( function ( keyPart , idx ) { if ( keyParts . length === idx + 1 ) { if ( val !== undefined ) { if ( Array . isArray ( val ) && Array . isArray ( target [ keyPart ] ) ) { val = target [ keyPart ] . concat ( val ) ; } if ( ! ( ( Array . isArray ( val ) && ! val . length ) || ( typeof val === 'object' && ! Object . keys ( val || { } ) . length ) ) ) { target [ keyPart ] = val ; } } } else if ( ! ( keyPart in target ) ) { target [ keyPart ] = { } ; } } ) ; }
3038	function ( node1 , node2 ) { if ( node1 . parentNode === node2 . parentNode ) { return ( node1 . data . index < node2 . data . index ) ? - 1 : 1 ; } var weight1 = 0 , weight2 = 0 , parent1 = node1 , parent2 = node2 ; while ( parent1 ) { weight1 += ( Math . pow ( 10 , ( parent1 . data . depth + 1 ) * - 4 ) * ( parent1 . data . index + 1 ) ) ; parent1 = parent1 . parentNode ; } while ( parent2 ) { weight2 += ( Math . pow ( 10 , ( parent2 . data . depth + 1 ) * - 4 ) * ( parent2 . data . index + 1 ) ) ; parent2 = parent2 . parentNode ; } if ( weight1 > weight2 ) { return 1 ; } else if ( weight1 < weight2 ) { return - 1 ; } return ( node1 . data . index > node2 . data . index ) ? 1 : - 1 ; }
3039	function ( root ) { var node = this . getNode ( ) , recursive = this . getRecursive ( ) , added = [ ] , child = root ; if ( ! root . childNodes . length || ( ! recursive && root !== node ) ) { return added ; } if ( ! recursive ) { return root . childNodes ; } while ( child ) { if ( child . _added ) { delete child . _added ; if ( child === root ) { break ; } else { child = child . nextSibling || child . parentNode ; } } else { if ( child !== root ) { added . push ( child ) ; } if ( child . firstChild ) { child . _added = true ; child = child . firstChild ; } else { child = child . nextSibling || child . parentNode ; } } } return added ; }
3040	function ( config ) { var me = this ; config = Ext . device . filesystem . Abstract . prototype . requestFileSystem ( config ) ; var successCallback = function ( fs ) { var fileSystem = Ext . create ( 'Ext.device.filesystem.FileSystem' , fs ) ; config . success . call ( config . scope || me , fileSystem ) ; } ; if ( config . type == window . PERSISTENT ) { if ( navigator . webkitPersistentStorage ) { navigator . webkitPersistentStorage . requestQuota ( config . size , function ( grantedBytes ) { window . webkitRequestFileSystem ( config . type , grantedBytes , successCallback , config . failure ) ; } ) } else { window . webkitStorageInfo . requestQuota ( window . PERSISTENT , config . size , function ( grantedBytes ) { window . webkitRequestFileSystem ( config . type , grantedBytes , successCallback , config . failure ) ; } ) } } else { window . webkitRequestFileSystem ( config . type , config . size , successCallback , config . failure ) ; } }
3041	function ( operation , callback , scope ) { var me = this , writer = me . getWriter ( ) , request = me . buildRequest ( operation ) ; request . setConfig ( { headers : me . getHeaders ( ) , timeout : me . getTimeout ( ) , method : me . getMethod ( request ) , callback : me . createRequestCallback ( request , operation , callback , scope ) , scope : me , proxy : me , useDefaultXhrHeader : me . getUseDefaultXhrHeader ( ) } ) ; if ( operation . getWithCredentials ( ) || me . getWithCredentials ( ) ) { request . setWithCredentials ( true ) ; request . setUsername ( me . getUsername ( ) ) ; request . setPassword ( me . getPassword ( ) ) ; } request = writer . write ( request ) ; Ext . Ajax . request ( request . getCurrentConfig ( ) ) ; return request ; }
3042	function ( err ) { var output ; try { var fieldName = err . err . substring ( err . err . lastIndexOf ( '.$' ) + 2 , err . err . lastIndexOf ( '_1' ) ) ; output = fieldName . charAt ( 0 ) . toUpperCase ( ) + fieldName . slice ( 1 ) + ' already exists' ; } catch ( ex ) { output = 'Unique field already exists' ; } return output ; }
3043	function ( project ) { var current = process . cwd ( ) ; console . log ( '\nCreating folder "' + \n + project ) ; '"...' fs . mkdirSync ( path . join ( current , project ) ) ; console . log ( '\nCopying the files in "' + \n + project ) ; '"...' wrench . copyDirSyncRecursive ( path . join ( __dirname , 'default' , 'project' ) , path . join ( current , project ) ) ; console . log ( '\nCreating the package.json file...' ) ; \n var packagePath = path . join ( current , project , 'package.json' ) ; var pack = JSON . parse ( fs . readFileSync ( packagePath ) ) ; pack . name = project ; pack . version = '0.0.1' ; }
3044	function prewatch ( theOptions ) { if ( config . watch ) { return _ . defaults ( theOptions , watchify . args ) ; } return theOptions ; }
3045	function ( index , filters ) { if ( ! Ext . isArray ( filters ) ) { filters = [ filters ] ; } var ln = filters . length , filterRoot = this . getFilterRoot ( ) , currentFilters = this . getFilters ( ) , newFilters = [ ] , filterConfig , i , filter ; if ( ! currentFilters ) { currentFilters = this . createFiltersCollection ( ) ; } for ( i = 0 ; i < ln ; i ++ ) { filter = filters [ i ] ; filterConfig = { root : filterRoot } ; if ( Ext . isFunction ( filter ) ) { filterConfig . filterFn = filter ; } else if ( Ext . isObject ( filter ) ) { if ( ! filter . isFilter ) { if ( filter . fn ) { filter . filterFn = filter . fn ; delete filter . fn ; } filterConfig = Ext . apply ( filterConfig , filter ) ; } else { newFilters . push ( filter ) ; if ( ! filter . getRoot ( ) ) { filter . setRoot ( filterRoot ) ; } continue ; } } else { Ext . Logger . warn ( 'Invalid filter specified:' , filter ) ; } filter = Ext . create ( 'Ext.util.Filter' , filterConfig ) ; newFilters . push ( filter ) ; } for ( i = 0 , ln = newFilters . length ; i < ln ; i ++ ) { currentFilters . insert ( index + i , newFilters [ i ] ) ; } this . dirtyFilterFn = true ; if ( currentFilters . length ) { this . filtered = true ; } return currentFilters ; }
3046	function ( filters ) { if ( ! Ext . isArray ( filters ) ) { filters = [ filters ] ; } var ln = filters . length , currentFilters = this . getFilters ( ) , i , filter ; for ( i = 0 ; i < ln ; i ++ ) { filter = filters [ i ] ; if ( typeof filter === 'string' ) { currentFilters . each ( function ( item ) { if ( item . getProperty ( ) === filter ) { currentFilters . remove ( item ) ; } } ) ; } else if ( typeof filter === 'function' ) { currentFilters . each ( function ( item ) { if ( item . getFilterFn ( ) === filter ) { currentFilters . remove ( item ) ; } } ) ; } else { if ( filter . isFilter ) { currentFilters . remove ( filter ) ; } else if ( filter . property !== undefined && filter . value !== undefined ) { currentFilters . each ( function ( item ) { if ( item . getProperty ( ) === filter . property && item . getValue ( ) === filter . value ) { currentFilters . remove ( item ) ; } } ) ; } } } if ( ! currentFilters . length ) { this . filtered = false ; } }
3047	function wrapperMergeResult ( srcFunc , objFunc , ... args ) { let resultObjFunction = { } ; let resultSrcFunction = { } ; if ( isFunction ( objFunc ) ) { resultObjFunction = objFunc . apply ( this , args ) ; } if ( isFunction ( srcFunc ) ) { resultSrcFunction = srcFunc . apply ( this , args ) ; } return merge ( { } , resultObjFunction , resultSrcFunction ) ; }
3048	function wrapperOrResult ( srcFunc , objFunc , ... args ) { let resultObjFunction = false ; let resultSrcFunction = false ; if ( isFunction ( objFunc ) ) { resultObjFunction = objFunc . apply ( this , args ) ; } if ( isFunction ( srcFunc ) ) { resultSrcFunction = srcFunc . apply ( this , args ) ; } return resultObjFunction || resultSrcFunction ; }
3049	function ( instance ) { this . _model = instance . _model ; this . _instance = instance ; this . id = instance . id ; this . eachAttribute = function ( cb ) { return this . _model . eachAttribute ( cb ) ; } ; this . eachRelationship = function ( cb ) { return this . _model . eachRelationship ( cb ) ; } this . attr = function ( name ) { return this . _instance [ name ] ; } ; this . belongsTo = function ( name , opts ) { return ( opts . id ? this . _instance [ name ] . id : new Snapshot ( this . _instance [ name ] ) ) ; } ; }
3050	function ( val ) { var trimmed = val . trim ( ) ; if ( trimmed . indexOf ( "'" ) === 0 && trimmed . lastIndexOf ( "'" ) === ( trimmed . length - 1 ) ) return '"' + trimmed . substring ( 1 , trimmed . length - 1 ) + '"' ; return val ; }
3051	function ( typeName , obj ) { this . type = typeName ; if ( typeof obj !== 'undefined' ) for ( var key in obj ) this [ key ] = obj [ key ] ; }
3052	function ( ) { var idStr = '' + sforce . db . id ++ ; return sforce . db . _idTemplate . substring ( 0 , 18 - idStr . length ) + idStr ; }
3053	function ( select ) { var chars = new antlr4 . InputStream ( input ) ; var lexer = new SelectLexer ( chars ) ; var tokens = new antlr4 . CommonTokenStream ( lexer ) ; var parser = new SelectParser ( tokens ) ; parser . buildParseTrees = true ; return parser . select ( ) ; }
3054	function ( obj ) { var schema = sforce . db . schema ; var objDesc = schema [ obj . type ] ; if ( typeof objDesc === 'undefined' ) throw 'No type exists by the name: ' + obj . type ; for ( var key in obj ) { if ( { Id : false , type : true } [ key ] ) continue ; var fieldDesc = null ; for ( var i = 0 ; i < objDesc . fields . length ; i ++ ) { var fd = objDesc . fields [ i ] ; if ( fd . name === key ) { fieldDesc = fd ; break ; } } if ( fieldDesc == null ) throw 'No field exists by the name: ' + key + 'in the type: ' + obj . type ; } }
3055	function ( type , fields ) { for ( var i = 0 ; i < fields . length ; i ++ ) sforce . db . validateField ( type , fields [ i ] ) ; }
3056	function ( type , field ) { var objDesc = sforce . db . schema [ type ] ; for ( var i = 0 ; i < objDesc . fields . length ; i ++ ) if ( objDesc . fields [ i ] . name === field ) return ; throw 'No field exists by the name: ' + field + 'in the type: ' + type ; }
3057	function ( type , rel ) { var objDesc = sforce . db . schema [ type ] ; for ( var i = 0 ; i < objDesc . childRelationships . length ; i ++ ) if ( objDesc . childRelationships [ i ] . relationshipName === rel ) return ; throw 'No child relationship exists by the name: ' + rel + 'in the type: ' + type ; }
3058	function ( type ) { var sos = sforce . db . sobjects ; if ( typeof sos [ type ] !== 'object' ) sos [ type ] = { } ; return sos [ type ] ; }
3059	function ( resultAry , isRoot ) { if ( resultAry . length == 0 ) { if ( isRoot ) return { done : 'true' , queryLocator : null , size : 0 , } ; return null ; } var records = null ; if ( resultAry . length == 1 ) records = resultAry [ 0 ] ; else records = resultAry ; return { done : 'true' , queryLocator : null , records : records , size : resultAry . length , } ; }
3060	function ( obj ) { var matches = this . sequence [ 0 ] . matches ( obj ) ; for ( var i = 1 ; i < this . sequence . length ; i += 2 ) { if ( this . sequence [ i ] === '&' ) matches = matches && this . sequence [ i + 1 ] . matches ( obj ) ; else matches = matches || this . sequence [ i + 1 ] . matches ( obj ) ; } return matches ; }
3061	function addContents ( $ , contents ) { console . log ( 'addContents' , contents ) ; var body = document . getElementsByTagName ( 'BODY' ) ; if ( ! body ) return ; var $body = $ ( body [ 0 ] ) , contentsStyle = [ 'position:fixed;right:1em;top:1em;' , 'padding:0.5em;min-width:120px;' , 'font-size:90%;line-height:18px;' , 'border:1px solid #aaa;background: #F9F9F9;' ] . join ( '' ) , html = [ ] , order = [ ] , hash = [ ] ; for ( var i = 0 ; i < contents . length ; ++ i ) { order [ i ] = 0 ; hash [ i ] = '' ; } function indexOf ( tag ) { for ( var i = 0 ; i < contents . length && contents [ i ] . toLowerCase ( ) !== tag ; ++ i ) ; return i ; } $ ( contents . join ( ',' ) ) . each ( function ( i , obj ) { var index = indexOf ( obj . tagName . toLowerCase ( ) ) ; order [ index ] ++ ; hash [ index ] = $ ( obj ) . text ( ) ; for ( var j = index + 1 ; j < contents . length ; ++ j ) { order [ j ] = 0 ; hash [ j ] = '' ; } var anchor = hash . slice ( 0 , index + 1 ) . join ( '-' ) ; $ ( obj ) . append ( fm ( '<a name="{0}" style="color:#333;"></a>' , anchor ) ) ; html . push ( fm ( '<div style="padding-left:{0}em;"><a href="#{2}" style="text-decoration:none;">{1}</a></div>' , index * 1.5 , order . slice ( 0 , index + 1 ) . join ( '.' ) + ' ' + hash [ index ] , anchor ) ) ; } ) ; var $contentsWrap = $ ( fm ( [ '<div style="{0}">' , '<div style="text-align: center;height:22px;line-height:22px;">' , '<b>Contents</b> <a href="javascript:;">hide</a>' , '</div>' , '<div>{1}</div>' , '</div>' ] . join ( '' ) , contentsStyle , html . join ( '' ) ) ) . prependTo ( $body ) , $toggle = $contentsWrap . find ( '> :first' ) . find ( '> :last' ) , $contents = $contentsWrap . find ( '> :last' ) ; console . log ( $contentsWrap , $toggle , $contents ) ; $toggle . click ( function ( ) { $contents . slideToggle ( ) ; $toggle . html ( $toggle . html ( ) === 'show' ? 'hide' : 'show' ) ; } ) ; }
3062	function addTop ( $ , top ) { console . log ( 'addTop' , top ) ; $ ( top . join ( ',' ) ) . each ( function ( i , obj ) { $ ( obj ) . prepend ( [ '<div style="position: relative;width: 1px;">' , '<a href="javascript:;" style="position:absolute;width:1.2em;left:-1.2em;font-size:0.8em;display:inline-block;visibility:hidden;color:#333;text-align:left;text-decoration: none;">' , '&#10022;</a>' , '</div>' ] . join ( '' ) ) ; var $prefix = $ ( this ) . find ( ':first' ) . find ( ':first' ) ; var rawCol = $ ( obj ) . css ( 'background-color' ) ; $ ( obj ) . mouseover ( function ( ) { $prefix . css ( 'height' , $ ( this ) . css ( 'height' ) ) ; $prefix . css ( 'line-height' , $ ( this ) . css ( 'line-height' ) ) ; $prefix . css ( 'visibility' , 'visible' ) ; $ ( this ) . css ( 'background-color' , '#FFF8D7' ) ; } ) . mouseout ( function ( ) { $prefix . css ( 'visibility' , 'hidden' ) ; $ ( this ) . css ( 'background-color' , rawCol ) ; } ) ; } ) ; }
3063	function ( ) { var actions = this . getActions ( ) , namespace = this . getNamespace ( ) , action , cls , methods , i , ln , method ; for ( action in actions ) { if ( actions . hasOwnProperty ( action ) ) { cls = namespace [ action ] ; if ( ! cls ) { cls = namespace [ action ] = { } ; } methods = actions [ action ] ; for ( i = 0 , ln = methods . length ; i < ln ; ++ i ) { method = Ext . create ( 'Ext.direct.RemotingMethod' , methods [ i ] ) ; cls [ method . getName ( ) ] = this . createHandler ( action , method ) ; } } } }
3064	function ( transaction , event ) { var success = ! ! event . getStatus ( ) , functionName = success ? 'success' : 'failure' , callback = transaction && transaction . getCallback ( ) , result ; if ( callback ) { result = event . getResult ( ) ; if ( Ext . isFunction ( callback ) ) { callback ( result , event , success ) ; } else { Ext . callback ( callback [ functionName ] , callback . scope , [ result , event , success ] ) ; Ext . callback ( callback . callback , callback . scope , [ result , event , success ] ) ; } } }
3065	function ( options , success , response ) { var me = this , i = 0 , ln , events , event , transaction , transactions ; if ( success ) { events = me . createEvents ( response ) ; for ( ln = events . length ; i < ln ; ++ i ) { event = events [ i ] ; transaction = me . getTransaction ( event ) ; me . fireEvent ( 'data' , me , event ) ; if ( transaction ) { me . runCallback ( transaction , event , true ) ; Ext . direct . Manager . removeTransaction ( transaction ) ; } } } else { transactions = [ ] . concat ( options . transaction ) ; for ( ln = transactions . length ; i < ln ; ++ i ) { transaction = me . getTransaction ( transactions [ i ] ) ; if ( transaction && transaction . getRetryCount ( ) < me . getMaxRetries ( ) ) { transaction . retry ( ) ; } else { event = Ext . create ( 'Ext.direct.ExceptionEvent' , { data : null , transaction : transaction , code : Ext . direct . Manager . exceptions . TRANSPORT , message : 'Unable to connect to the server.' , xhr : response } ) ; me . fireEvent ( 'data' , me , event ) ; if ( transaction ) { me . runCallback ( transaction , event , false ) ; Ext . direct . Manager . removeTransaction ( transaction ) ; } } } } }
3066	function ( options ) { return options && options . getTid ? Ext . direct . Manager . getTransaction ( options . getTid ( ) ) : null ; }
3067	function ( action , method , args ) { var me = this , callData = method . getCallData ( args ) , data = callData . data , callback = callData . callback , scope = callData . scope , transaction ; transaction = Ext . create ( 'Ext.direct.Transaction' , { provider : me , args : args , action : action , method : method . getName ( ) , data : data , callback : scope && Ext . isFunction ( callback ) ? Ext . Function . bind ( callback , scope ) : callback } ) ; if ( me . fireEvent ( 'beforecall' , me , transaction , method ) !== false ) { Ext . direct . Manager . addTransaction ( transaction ) ; me . queueTransaction ( transaction ) ; me . fireEvent ( 'call' , me , transaction , method ) ; } }
3068	function ( transaction ) { return { action : transaction . getAction ( ) , method : transaction . getMethod ( ) , data : transaction . getData ( ) , type : 'rpc' , tid : transaction . getId ( ) } ; }
3069	function ( transaction ) { var me = this , enableBuffer = me . getEnableBuffer ( ) ; if ( transaction . getForm ( ) ) { me . sendFormRequest ( transaction ) ; return ; } me . callBuffer . push ( transaction ) ; if ( enableBuffer ) { if ( ! me . callTask ) { me . callTask = Ext . create ( 'Ext.util.DelayedTask' , me . combineAndSend , me ) ; } me . callTask . delay ( Ext . isNumber ( enableBuffer ) ? enableBuffer : 10 ) ; } else { me . combineAndSend ( ) ; } }
3070	function ( ) { var buffer = this . callBuffer , ln = buffer . length ; if ( ln > 0 ) { this . sendRequest ( ln == 1 ? buffer [ 0 ] : buffer ) ; this . callBuffer = [ ] ; } }
3071	function ( action , method , form , callback , scope ) { var me = this , transaction , isUpload , params ; transaction = new Ext . direct . Transaction ( { provider : me , action : action , method : method . getName ( ) , args : [ form , callback , scope ] , callback : scope && Ext . isFunction ( callback ) ? Ext . Function . bind ( callback , scope ) : callback , isForm : true } ) ; if ( me . fireEvent ( 'beforecall' , me , transaction , method ) !== false ) { Ext . direct . Manager . addTransaction ( transaction ) ; isUpload = String ( form . getAttribute ( 'enctype' ) ) . toLowerCase ( ) == 'multipart/form-data' ; params = { extTID : transaction . id , extAction : action , extMethod : method . getName ( ) , extType : 'rpc' , extUpload : String ( isUpload ) } ; Ext . apply ( transaction , { form : Ext . getDom ( form ) , isUpload : isUpload , params : callback && Ext . isObject ( callback . params ) ? Ext . apply ( params , callback . params ) : params } ) ; me . fireEvent ( 'call' , me , transaction , method ) ; me . sendFormRequest ( transaction ) ; } }
3072	function ( transaction ) { var me = this ; Ext . Ajax . request ( { url : me . getUrl ( ) , params : transaction . params , callback : me . onData , scope : me , form : transaction . form , isUpload : transaction . isUpload , transaction : transaction } ) ; }
3073	function inlineBlockFix ( decl ) { var origRule = decl . parent ; origRule . append ( { prop : '*display' , value : 'inline' } , { prop : '*zoom' , value : '1' } ) ; }
3074	function stubPlainTextFiles ( resourceRoots , destination ) { _ . forEach ( resourceRoots , function ( resource ) { var filePath = resource . replace ( 'file://$PROJECT_DIR$' , destination ) ; filePath = filePath . replace ( '.idea/' , '' ) ; var location = filePath . replace ( / [^\/]*$ / , '' ) ; if ( ! fs . existsSync ( location ) ) mkdir ( '-p' , location ) ; if ( ! fs . existsSync ( filePath ) ) fs . writeFileSync ( filePath , ' ' , 'utf8' ) ; } ) ; }
3075	function resolveJetbrainsExe ( jetbrainsDirectory ) { var exists = false ; var webstormInstallPaths = io . resolveDirMatches ( jetbrainsDirectory , / ^WebStorm\s*[.\d]+$ / ) ; for ( var j = 0 ; j < webstormInstallPaths . length ; j ++ ) { var webstormPath = [ jetbrainsDirectory , webstormInstallPaths [ j ] , 'bin' ] ; var resolvedWebstorm = resolveMaxedPath ( webstormPath ) ; if ( resolvedWebstorm === null ) break ; exists = path . resolve ( resolvedWebstorm . join ( path . sep ) , 'Webstorm.exe' ) ; if ( fs . existsSync ( exists ) ) { return exists ; } } return exists ; }
3076	function Route ( method , path , callback , options ) { this . path = path ; this . method = method ; this . callback = callback ; this . regexp = utils . pathRegexp ( path , this . keys = [ ] , options . sensitive , options . strict ) ; }
3077	function TransportDecorator ( Transport ) { function TelemetryTransport ( contact , options ) { if ( ! ( this instanceof TelemetryTransport ) ) { return new TelemetryTransport ( contact , options ) } assert . ok ( options , 'Missing required options parameter' ) this . _telopts = options . telemetry this . telemetry = new Persistence ( this . _telopts . storage ) Transport . call ( this , contact , options ) } inherits ( TelemetryTransport , Transport ) TelemetryTransport . DEFAULT_METRICS = [ metrics . Latency , metrics . Availability , metrics . Reliability , metrics . Throughput ] TelemetryTransport . prototype . _open = function ( callback ) { var self = this var metrics = this . _telopts . metrics if ( ! metrics || metrics . length === 0 ) { this . _telopts . metrics = TelemetryTransport . DEFAULT_METRICS } this . _telopts . metrics . forEach ( function ( Metric ) { var metric = new Metric ( ) metric . hooks . forEach ( function ( hook ) { self [ hook . trigger ] ( hook . event , hook . handler ( metric , self . telemetry ) ) } ) } ) return Transport . prototype . _open . call ( this , callback ) } return TelemetryTransport }
3078	function getRandomArrValue ( arr , min = 0 , max = arr . length - 1 ) { return arr [ getRandomInt ( min , max ) ] ; }
3079	function random ( number = 1 ) { if ( 1 > number ) { throw Error ( ` ${ number } ` ) ; } if ( number === 1 ) { return getRandomArrValue ( dinosaurs ) ; } else { const l = dinosaurs . length - 1 ; return new Array ( number ) . fill ( ) . map ( ( ) => getRandomArrValue ( dinosaurs , 0 , l ) ) ; } }
3080	function Response ( ghosttrain , callback ) { this . charset = '' ; this . headers = { } ; this . statusCode = 200 ; this . app = ghosttrain ; this . _callback = callback ; }
3081	function ( ) { var body ; var app = this . app ; if ( typeof arguments [ 0 ] === 'number' ) { this . status ( arguments [ 0 ] ) ; body = arguments [ 1 ] ; } else { body = arguments [ 0 ] ; } var type = this . get ( 'Content-Type' ) ; if ( ! body && type !== 'application/json' ) { body = utils . STATUS_CODES [ this . statusCode ] ; if ( ! type ) this . type ( 'txt' ) ; } else if ( typeof body === 'string' ) { if ( ! type ) { this . charset = this . charset || 'utf-8' ; this . type ( 'html' ) ; } } else if ( typeof body === 'object' ) { if ( body === null ) body = '' ; else if ( ! type || type === 'application/json' ) { this . contentType ( 'application/json' ) ; var replacer = app . get ( 'json replacer' ) ; var spaces = app . get ( 'json spaces' ) ; body = JSON . stringify ( body , replacer , spaces ) ; } } this . end ( body ) ; return this ; }
3082	function ( ) { var data ; if ( arguments . length === 2 ) { this . status ( arguments [ 0 ] ) ; data = arguments [ 1 ] ; } else { data = arguments [ 0 ] ; } if ( ! this . get ( 'Content-Type' ) ) this . contentType ( 'application/json' ) ; return this . send ( data ) ; }
3083	function ( field , value ) { if ( arguments . length === 2 ) this . headers [ field ] = value ; else { for ( var prop in field ) this . headers [ prop ] = field [ prop ] ; } return this ; }
3084	function ( body ) { var type = this . get ( 'Content-Type' ) ; if ( type === 'application/json' ) this . _callback ( JSON . parse ( body || '{}' ) ) ; else this . _callback ( body ) ; }
3085	function ( args ) { var expected = Array . prototype . slice . call ( arguments , 1 ) ; var minimum = expected . length var hasOptionalTypes = false ; for ( var i = 0 ; i < expected . length ; i ++ ) { if ( ! isValidType ( expected [ i ] ) ) { throw Error ( 'Expected argument ' + i + ' is not a valid type.' ) ; } if ( isOptionalType ( expected [ i ] ) ) { minimum -- ; hasOptionalTypes = true ; } } ; if ( isDisabled && ! hasOptionalTypes ) { return [ ] ; } if ( minimum == expected . length && args . length != expected . length ) { throw Error ( getExpectedVsRecieved_ ( expected , args ) ) ; } if ( args . length < minimum || args . length > expected . length ) { throw Error ( getExpectedVsRecieved_ ( expected , args ) ) ; } if ( args . length === expected . length ) { for ( var i = 0 ; i < expected . length ; i ++ ) { if ( ! isOfType ( args [ i ] , expected [ i ] ) ) { throw Error ( getExpectedVsRecieved_ ( expected , args ) ) ; } } ; return args ; } return shiftArguments_ ( expected , args , minimum ) ; }
3086	function ( expected , args , minimum ) { var shiftedArgs = [ ] ; var curArg = args . length - 1 ; var remainingOptionalArgs = expected . length - minimum ; var optionalIndiceSegments = [ ] ; var optionalIndiceSegment = [ ] ; var availableArgsSegments = [ ] ; var availableArgsSegment = [ ] ; for ( var i = 0 ; i < expected . length ; i ++ ) shiftedArgs [ i ] = null ; var advanceArg = function ( ) { availableArgsSegment . unshift ( curArg ) ; curArg -- ; remainingOptionalArgs -- ; if ( curArg < 0 || remainingOptionalArgs < 0 ) { throw Error ( getExpectedVsRecieved_ ( expected , args ) ) ; } } ; for ( i = expected . length - 1 ; i >= 0 ; i -- ) { var type = expected [ i ] ; if ( isOptionalType ( type ) ) { optionalIndiceSegment . unshift ( i ) ; continue ; } while ( ! isOfType ( args [ curArg ] , type ) ) { advanceArg ( ) ; } if ( checkIfShouldLeaveArgument_ ( expected , i , args , curArg ) ) { advanceArg ( ) ; i ++ ; continue ; } optionalIndiceSegments . unshift ( optionalIndiceSegment ) ; optionalIndiceSegment = [ ] ; availableArgsSegments . unshift ( availableArgsSegment ) ; availableArgsSegment = [ ] shiftedArgs [ i ] = args [ curArg -- ] ; } while ( curArg >= 0 ) availableArgsSegment . unshift ( curArg -- ) ; availableArgsSegments . unshift ( availableArgsSegment ) ; optionalIndiceSegments . unshift ( optionalIndiceSegment ) ; if ( availableArgsSegments . length != optionalIndiceSegments . length ) { throw Error ( getExpectedVsRecieved_ ( expected , args ) ) ; } optionalIndiceSegments . forEach ( function ( optionalIndices , index ) { availableArgsSegment = availableArgsSegments [ index ] ; i = 0 ; availableArgsSegment . forEach ( function ( argIndex ) { arg = args [ argIndex ] while ( ! isOfType ( arg , expected [ optionalIndices [ i ] ] ) && i < optionalIndices . length ) { i ++ ; } if ( i >= optionalIndices . length ) { throw Error ( getExpectedVsRecieved_ ( expected , args ) ) ; } shiftedArgs [ optionalIndices [ i ++ ] ] = arg ; } ) ; } ) ; return shiftedArgs ; }
3087	function ( ) { availableArgsSegment . unshift ( curArg ) ; curArg -- ; remainingOptionalArgs -- ; if ( curArg < 0 || remainingOptionalArgs < 0 ) { throw Error ( getExpectedVsRecieved_ ( expected , args ) ) ; } }
3088	function ( expected , expectedIndex , actual , actualIndex ) { var consecutiveOptionals = countTrailingOptionals_ ( expected , expectedIndex , actual [ actualIndex ] ) ; var matchingRequires = countLeadingMatchingRequires_ ( expected , expectedIndex , actual [ actualIndex ] ) ; var matchesRequired = 1 + matchingRequires ; var availableDistance = matchingRequires + consecutiveOptionals ; var i = actualIndex - 1 ; var type = expected [ expectedIndex ] ; while ( i >= 0 && availableDistance > 0 && matchesRequired > 0 ) { if ( isOfType ( actual [ i ] , type ) ) { matchesRequired -- ; } availableDistance -- ; i -- ; } return matchesRequired <= 0 ; }
3089	function ( expected , expectedIndex , value ) { var i = expectedIndex + 1 ; var matchingOptionals = 0 ; var inBetweenOptionals = 0 ; var tmpInBetween = 0 ; while ( i < expected . length && isOptionalType ( expected [ i ] ) ) { if ( isOfType ( value , expected [ i ] ) ) { matchingOptionals ++ ; inBetweenOptionals += tmpInBetween ; tmpInBetween = 0 ; } else { tmpInBetween ++ ; } i ++ ; } return matchingOptionals + inBetweenOptionals ; }
3090	function ( expected , expectedIndex , value ) { var i = expectedIndex - 1 ; var matchingRequires = 0 while ( i >= 0 ) { if ( ! isOptionalType ( expected [ i ] ) && isOfType ( value , expected [ i ] ) ) { matchingRequires ++ ; } i -- ; } return matchingRequires ; }
3091	function ( expected , actual ) { var argNames = [ ] ; var expectedNames = [ ] ; for ( var i = 0 ; i < actual . length ; i ++ ) { argNames . push ( getNameForValue ( actual [ i ] ) ) ; } ; for ( var i = 0 ; i < expected . length ; i ++ ) { expectedNames . push ( getNameForType ( expected [ i ] ) ) ; } ; return 'Expected arguments to be (' + expectedNames . join ( ', ' ) + ') but received (' + argNames . join ( ', ' ) + ') instead.' ; }
3092	function ( value , type ) { if ( ! isValidType ( type ) ) { throw Error ( 'Invalid type supplied.' ) ; } if ( ! isOfType ( value , type ) ) { argName = getNameForValue ( value ) ; typeName = getNameForType ( type ) ; throw Error ( 'Expected ' + argName + ' to be an instance of ' + typeName + '.' ) ; } }
3093	function ( type ) { if ( type === null ) return true ; if ( type === undefined ) return true ; if ( type instanceof AnyType ) return true ; if ( type instanceof Array ) { if ( ! type . length ) return false ; for ( var i = 0 ; i < type . length ; i ++ ) { if ( ! isValidType ( type [ i ] ) ) return false ; } ; return true ; } if ( type instanceof ArrayOf ) return isValidType ( type . type ) ; if ( type instanceof EnumType ) return ( type . enumerable instanceof Object ) ; return ( type instanceof Object ) ; }
3094	function ( value ) { if ( value === undefined ) return 'undefined' ; if ( value === null ) return 'null' ; if ( value instanceof Array ) { if ( ! value . length ) return 'Array(empty)' ; var innerType = undefined ; for ( var i = 0 ; i < value . length ; i ++ ) { type = getNameForValue ( value [ i ] ) ; if ( innerType !== undefined && innerType !== type ) { return 'Array(mixed)' ; } innerType = type ; } ; return 'Array<' + innerType + '>' ; } if ( value instanceof Function ) { if ( value . name ) return value . name ; return 'Anonymous function' ; } if ( value instanceof Object ) { if ( value . constructor ) return value . constructor . name ; return 'Object' ; } name = typeof value ; return name [ 0 ] . toUpperCase ( ) + name . substring ( 1 ) ; }
3095	function ( type ) { if ( type === undefined ) return 'undefined' ; if ( type === null ) return 'null' ; if ( type instanceof Array ) { if ( ! type . length ) return 'None' ; var possibleTypes = [ ] ; for ( var i = 0 ; i < type . length ; i ++ ) { possibleTypes . push ( getNameForType ( type [ i ] ) ) ; } ; return possibleTypes . join ( ' or ' ) ; } if ( type instanceof ArrayOf ) { return 'Array<' + getNameForType ( type . type ) + '>' ; } if ( type instanceof Function ) return type . name return 'Invalid type' ; }
3096	function ( request ) { var me = this , url = me . callParent ( arguments ) , params = Ext . apply ( { } , request . getParams ( ) ) , filters = params . filters , filter , i , value ; delete params . filters ; if ( me . getAutoAppendParams ( ) ) { url = Ext . urlAppend ( url , Ext . Object . toQueryString ( params ) ) ; } if ( filters && filters . length ) { for ( i = 0 ; i < filters . length ; i ++ ) { filter = filters [ i ] ; value = filter . getValue ( ) ; if ( value ) { url = Ext . urlAppend ( url , filter . getProperty ( ) + "=" + value ) ; } } } return url ; }
3097	function getStateFromOptions ( options , propertyName ) { propertyName = propertyName || 'state' ; const stateName = options [ propertyName ] || options . resource . defaultState ; let stateObj = options . resource . states [ stateName ] || { validate : false } ; stateObj . name = stateName ; return stateObj ; }
3098	function validate ( resource , doc , doValidate ) { return new Promise ( ( resolve , reject ) => { if ( doValidate !== true ) { return resolve ( ) ; } if ( resource . validate ( doc ) ) { return resolve ( ) ; } else { debug ( 'model have %d error(s)' , resource . validate . errors . length ) ; return reject ( resource . validate . errors ) ; } } ) ; }
3099	function prune ( str , max , nice , suf ) { max = max || 140 nice = _ . isBoolean ( nice ) ? nice : false if ( ! str || max <= 0 || str . length <= max ) return str suf = suf || "..." str = str . substr ( 0 , max ) return nice ? str . substr ( 0 , Math . min ( str . length , str . lastIndexOf ( " " ) ) ) + suf : str }
3100	function attemptRender ( reporter , filename , src , resolve , reject , globals ) { globals = globals || { } ; less . render ( src , { paths : [ "public/static/less" ] , filename : filename , modifyVars : globals , compress : false } , function ( e , css ) { if ( e ) { if ( ( / ^variable @(.+?) is undefined$ / ) . test ( e . message ) ) { globals [ ( / ^variable @(.+?) is undefined$ / ) . exec ( e . message ) [ 1 ] ] = "1" ; attemptRender ( reporter , filename , src , resolve , reject , globals ) ; return ; } reporter ( "LESS" , filename , e . line , e . message ) ; reject ( ) ; return ; } resolve ( { filename : filename , src : css . css || css } ) ; } ) ; }
3101	function validateArray ( indexes ) { var valid = false ; if ( typeof indexes === 'string' ) { if ( indexes . match ( TYPE_ARRAY_REGEX ) ) { valid = true ; } } return valid ; }
3102	function addRoutes ( pies , pie , routes , app ) { if ( 'get' in routes ) { routes . get . forEach ( function ( route ) { Object . keys ( route ) . forEach ( function ( r ) { var middlewares = true ; if ( typeof route [ r ] === 'string' ) { middlewares = false ; } loadRoute ( app , 'get' , r , pies [ pie ] . path , route [ r ] , middlewares ) ; } ) ; } ) ; } if ( 'post' in routes ) { routes . post . forEach ( function ( route ) { Object . keys ( route ) . forEach ( function ( r ) { var middlewares = true ; if ( typeof route [ r ] === 'string' ) { middlewares = false ; } loadRoute ( app , 'post' , r , pies [ pie ] . path , route [ r ] , middlewares ) ; } ) ; } ) ; } }
3103	function generateUUID ( ) { let dat = new Date ( ) . getTime ( ) ; return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx' . replace ( / [xy] / g , ( cha ) => { const ran = ( dat + ( Math . random ( ) * 16 ) ) % 16 | 0 ; dat = Math . floor ( dat / 16 ) ; return ( cha === 'x' ? ran : ran & 0x3 | 0x8 ) . toString ( 16 ) ; } ) ; }
3104	function randomString ( length , charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' ) { let str = '' , isAllNumeric = false , isNegative = false , useCharSet = charSet ; if ( + length ) { if ( ! isString ( charSet ) ) { if ( isNumber ( charSet ) ) { if ( + charSet ) { isAllNumeric = true ; isNegative = + charSet < 0 ; useCharSet = ` ${ Math . abs ( + charSet ) } ` ; } else { useCharSet = ALPHANUMERIC_CHARS ; } } else { useCharSet = ALPHANUMERIC_CHARS ; } } const generateChar = function gc ( len ) { return Math . round ( Math . random ( ) * ( len - 1 ) ) ; } . bind ( null , useCharSet . length ) ; str = Array ( + length ) . fill ( ) . map ( ( v , index ) => { const newChar = generateChar ( ) ; if ( ! index && isAllNumeric && ! newChar ) { return useCharSet . charAt ( newChar + 1 ) ; } return useCharSet . charAt ( newChar ) ; } ) . join ( '' ) ; } if ( isAllNumeric ) { return isNegative ? - + str : + str ; } return str ; }
3105	function toUint ( str ) { const string = window . btoa ( unescape ( encodeURIComponent ( str ) ) ) , chars = string . split ( '' ) , len = chars . length , uintArray = [ ] ; Array ( len ) . fill ( ) . forEach ( ( val , i ) => uintArray . push ( chars [ i ] . charCodeAt ( 0 ) ) ) ; return new Uint8Array ( uintArray ) ; }
3106	function toArrayBuffer ( str ) { const len = isString ( str ) ? str . length : 0 , buf = new ArrayBuffer ( len ) , view = new Uint8Array ( buf ) ; Array ( len ) . fill ( ) . forEach ( ( val , i ) => ( view [ i ] = str . charCodeAt ( i ) & 0xFF ) ) ; return view ; }
3107	function ( ) { if ( ! this . $backButtonContainer ) { return ; } var i = 0 , backButtonContainer = this . $backButtonContainer , items = backButtonContainer . items , item ; for ( ; i < items . length ; i ++ ) { item = items . get ( i ) ; if ( ! item . isHidden ( ) ) { this . $backButtonContainer . show ( ) ; return ; } } this . $backButtonContainer . hide ( ) ; }
3108	function ( message , priority , callerId ) { if ( ! this . getEnabled ( ) ) { return this ; } var statics = Logger , priorities = statics . priorities , priorityValue = priorities [ priority ] , caller = this . log . caller , callerDisplayName = '' , writers = this . getWriters ( ) , event , i , originalCaller ; if ( ! priority ) { priority = 'info' ; } if ( priorities [ this . getMinPriority ( ) ] > priorityValue ) { return this ; } if ( ! callerId ) { callerId = 1 ; } if ( Ext . isArray ( message ) ) { message = message . join ( " " ) ; } else { message = String ( message ) ; } if ( typeof callerId == 'number' ) { i = callerId ; do { i -- ; caller = caller . caller ; if ( ! caller ) { break ; } if ( ! originalCaller ) { originalCaller = caller . caller ; } if ( i <= 0 && caller . displayName ) { break ; } } while ( caller !== originalCaller ) ; callerDisplayName = Ext . getDisplayName ( caller ) ; } else { caller = caller . caller ; callerDisplayName = Ext . getDisplayName ( callerId ) + '#' + caller . $name ; } event = { time : Ext . Date . now ( ) , priority : priorityValue , priorityName : priority , message : message , caller : caller , callerDisplayName : callerDisplayName } ; for ( i in writers ) { if ( writers . hasOwnProperty ( i ) ) { writers [ i ] . write ( Ext . merge ( { } , event ) ) ; } } return this ; }
3109	function copyFileSync ( source , destination ) { if ( validateFileSync ( source ) ) { fs . writeFileSync ( destination , fs . readFileSync ( source ) ) ; } }
3110	function copyFilesMatchSync ( match , source , destination ) { fs . readdirSync ( source ) . forEach ( function eachTemplate ( filename ) { var sourceFile = path . join ( source , filename ) ; var destinationFile = path . join ( destination , filename ) ; if ( match . test ( path . basename ( filename ) ) ) { fs . writeFileSync ( destinationFile , fs . readFileSync ( sourceFile ) ) ; } } ) ; }
3111	function replaceMatchFilesSync ( match , source , destination ) { unlinkFilesMatchSync ( match , destination ) ; copyFilesMatchSync ( match , source , destination ) ; }
3112	function unlinkFilesMatchSync ( match , location ) { fs . readdirSync ( location ) . forEach ( function eachTemplate ( filename ) { if ( match . test ( path . basename ( filename ) ) ) { var filePath = path . join ( location , filename ) ; if ( validateFileSync ( filePath ) ) { fs . unlinkSync ( filePath ) ; } } } ) ; }
3113	function validateDirectorySync ( path , errorMessage ) { errorMessage = errorMessage || 'Error validateDirectorySync() the directory path is not valid ' + path ; var isValid = existsDirectorySync ( path ) ; if ( ! isValid ) { console . error ( errorMessage ) ; } return isValid ; }
3114	function validateFileSync ( path , errorMessage ) { errorMessage = errorMessage || 'Error validateFileSync() the file path is not valid ' + path ; var isValid = existsFileSync ( path ) ; if ( ! isValid ) { console . error ( errorMessage ) ; } return isValid ; }
3115	function subDirectoriesWithFile ( base , filename ) { var result = [ ] ; if ( fs . existsSync ( base ) && fs . statSync ( base ) . isDirectory ( ) ) { if ( fs . existsSync ( path . join ( base , filename ) ) ) { result . push ( base ) ; } fs . readdirSync ( base ) . forEach ( function ( subdir ) { result . push . apply ( result , subDirectoriesWithFile ( path . join ( base , subdir ) , filename ) ) ; } ) ; } return result ; }
3116	function maximisePath ( ) { var elements = Array . prototype . slice . call ( arguments ) ; for ( var i = 1 ; i < elements . length ; i ++ ) { var directory = path . resolve ( path . join . apply ( path , elements . slice ( 0 , i ) ) ) ; if ( ! fs . existsSync ( directory ) ) { return null ; } else if ( ( typeof elements [ i ] !== 'string' ) && ( 'test' in elements [ i ] ) ) { var matches = resolveDirMatches ( directory , elements [ i ] ) ; if ( matches . length === 0 ) { return null ; } else { elements [ i ] = matches [ 0 ] ; } } else { elements [ i ] = String ( elements [ i ] ) ; } } var result = path . resolve ( elements . join ( path . sep ) ) ; return fs . existsSync ( result ) && result ; }
3117	function resolveDirMatches ( directory , match ) { if ( validateDirectorySync ( directory ) ) { return fs . readdirSync ( directory ) . filter ( function eachDirectoryItem ( item ) { var resolved = path . resolve ( path . join ( directory , item ) ) ; return match . test ( item ) && fs . statSync ( resolved ) . isDirectory ( ) ; } ) . sort ( compareHigher ) ; } else { return [ ] ; } }
3118	function compareHigher ( a , b ) { var numA = parseFloat ( / [\d\.]+$ / . exec ( a ) [ 0 ] ) ; var numB = parseFloat ( / [\d\.]+$ / . exec ( b ) [ 0 ] ) ; if ( isNaN ( numA ) || ( numB > numA ) ) { return + 1 ; } else if ( isNaN ( numB ) || ( numA > numB ) ) { return - 1 ; } else { return 0 ; } }
3119	function reduceDirectories ( ) { return Array . prototype . slice . call ( arguments ) . map ( function ( candidate ) { return path . normalize ( candidate ) ; } ) . filter ( function ( candidate ) { return fs . existsSync ( candidate ) && fs . statSync ( candidate ) . isDirectory ( ) ; } ) . shift ( ) ; }
3120	function ( side ) { var menus = this . getMenus ( ) || { } , menu = menus [ side ] ; if ( menu ) this . hideMenu ( side ) ; delete menus [ side ] ; this . setMenus ( menus ) ; }
3121	function ( side ) { var menus = this . getMenus ( ) , menu = menus [ side ] , before , after , viewportBefore , viewportAfter ; if ( ! menu || menu . isAnimating ) { return ; } this . hideOtherMenus ( side ) ; before = { translateX : 0 , translateY : 0 } ; after = { translateX : 0 , translateY : 0 } ; viewportBefore = { translateX : 0 , translateY : 0 } ; viewportAfter = { translateX : 0 , translateY : 0 } ; if ( menu . $reveal ) { Ext . getBody ( ) . insertFirst ( menu . element ) ; } else { Ext . Viewport . add ( menu ) ; } menu . show ( ) ; menu . addCls ( 'x-' + side ) ; var size = ( side == 'left' || side == 'right' ) ? menu . element . getWidth ( ) : menu . element . getHeight ( ) ; if ( side == 'left' ) { before . translateX = - size ; viewportAfter . translateX = size ; } else if ( side == 'right' ) { before . translateX = size ; viewportAfter . translateX = - size ; } else if ( side == 'top' ) { before . translateY = - size ; viewportAfter . translateY = size ; } else if ( side == 'bottom' ) { before . translateY = size ; viewportAfter . translateY = - size ; } if ( menu . $reveal ) { if ( Ext . browser . getPreferredTranslationMethod ( ) != 'scrollposition' ) { menu . translate ( 0 , 0 ) ; } } else { menu . translate ( before . translateX , before . translateY ) ; } if ( menu . $cover ) { menu . getTranslatable ( ) . on ( 'animationend' , function ( ) { menu . isAnimating = false ; } , this , { single : true } ) ; menu . translate ( after . translateX , after . translateY , { preserveEndState : true , duration : 200 } ) ; } else { this . translate ( viewportBefore . translateX , viewportBefore . translateY ) ; this . getTranslatable ( ) . on ( 'animationend' , function ( ) { menu . isAnimating = false ; } , this , { single : true } ) ; this . translate ( viewportAfter . translateX , viewportAfter . translateY , { preserveEndState : true , duration : 200 } ) ; } menu . isAnimating = true ; }
3122	function ( side , animate ) { var menus = this . getMenus ( ) , menu = menus [ side ] , after , viewportAfter , size ; animate = ( animate === false ) ? false : true ; if ( ! menu || ( menu . isHidden ( ) || menu . isAnimating ) ) { return ; } after = { translateX : 0 , translateY : 0 } ; viewportAfter = { translateX : 0 , translateY : 0 } ; size = ( side == 'left' || side == 'right' ) ? menu . element . getWidth ( ) : menu . element . getHeight ( ) ; if ( side == 'left' ) { after . translateX = - size ; } else if ( side == 'right' ) { after . translateX = size ; } else if ( side == 'top' ) { after . translateY = - size ; } else if ( side == 'bottom' ) { after . translateY = size ; } if ( menu . $cover ) { if ( animate ) { menu . getTranslatable ( ) . on ( 'animationend' , function ( ) { menu . isAnimating = false ; menu . hide ( ) ; } , this , { single : true } ) ; menu . translate ( after . translateX , after . translateY , { preserveEndState : true , duration : 200 } ) ; } else { menu . translate ( after . translateX , after . translateY ) ; menu . hide ( ) } } else { if ( animate ) { this . getTranslatable ( ) . on ( 'animationend' , function ( ) { menu . isAnimating = false ; menu . hide ( ) ; } , this , { single : true } ) ; this . translate ( viewportAfter . translateX , viewportAfter . translateY , { preserveEndState : true , duration : 200 } ) ; } else { this . translate ( viewportAfter . translateX , viewportAfter . translateY ) ; menu . hide ( ) ; } } }
3123	function ( side , animation ) { var menus = this . getMenus ( ) ; for ( var menu in menus ) { if ( side != menu ) { this . hideMenu ( menu , animation ) ; } } }
3124	function ( side ) { var menus = this . getMenus ( ) , menu ; if ( menus [ side ] ) { menu = menus [ side ] ; if ( menu . isHidden ( ) ) { this . showMenu ( side ) ; } else { this . hideMenu ( side ) ; } } }
3125	function init ( adapter , config ) { if ( ! fs ) { var Adapter = require ( './adapters/' + adapter ) ; fs = new Adapter ( config ) ; } }
3126	function getHierarchy ( cb ) { getConfig ( function ( err , config ) { if ( err ) { cb ( err ) ; return ; } cb ( null , config [ ':hierarchy' ] ) ; } ) ; }
3127	function getBackends ( cb ) { getConfig ( function ( err , config ) { if ( err ) { cb ( err ) ; return ; } cb ( null , config [ ':backends' ] ) ; } ) ; }
3128	function getBackendConfig ( backend , cb ) { getConfig ( function ( err , config ) { if ( err ) { cb ( err ) ; return ; } cb ( null , config [ ':' + backend ] ) ; } ) ; }
3129	function getFile ( backend , file , cb ) { getBackendConfig ( backend , function ( err , config ) { file = [ config [ ':datadir' ] , '/' , file ] . join ( '' ) ; fs . readFile ( file , cb ) ; } ) ; }
3130	function saveFile ( backend , file , data , cb ) { cb = typeof ( cb ) === 'function' ? cb : function ( ) { } ; getBackendConfig ( backend , function ( err , config ) { var datadir = config [ ':datadir' ] ; file = path . join ( datadir , file ) ; fs . writeFile ( file , data , cb ) ; } ) ; }
3131	function getOverrides ( backend , file , cb ) { async . parallel ( [ function hierarchy ( cb ) { getHierarchy ( cb ) ; } , function backendConfig ( cb ) { getBackendConfig ( backend , cb ) ; } ] , function ( err , results ) { var hierarchy , datadir , filename , tasks , pos , searchHierarchy , tasks ; hierarchy = results [ 0 ] ; datadir = results [ 1 ] [ ':datadir' ] ; filename = file . remove ( '.' + backend ) ; tasks = [ ] ; pos = hierarchy . findIndex ( filename ) ; searchHierarchy = hierarchy . to ( pos ) ; getFile ( backend , file , function ( err , data ) { var sourceData ; if ( err ) { cb ( err ) ; return ; } sourceData = yaml . safeLoad ( data ) ; _ . each ( searchHierarchy , function ( hierarchy ) { tasks . push ( hierarchy + '.' + backend ) ; } ) ; async . map ( tasks , function ( f , cb ) { getFile ( backend , f , function ( err , data ) { cb ( null , { file : f , data : yaml . safeLoad ( data ) } ) ; } ) ; } , function ( err , comparisonData ) { var list = { } ; if ( err ) { cb ( err ) ; return ; } _ . each ( sourceData , function ( key , value ) { _ . each ( comparisonData , function ( set ) { _ . each ( set . data , function ( cKey , cValue ) { if ( cKey === key ) { list [ cKey ] = { file : set . file , value : cValue } ; } } ) ; if ( list [ key ] ) { return false ; } } ) ; } ) ; cb ( null , list ) ; } ) ; } ) ; } ) ; }
3132	function done ( result , callback ) { if ( ! _ . isFunction ( callback ) ) return process . nextTick ( function ( ) { callback ( null , result ) } ) }
3133	function fail ( err , callback ) { if ( ! _ . isFunction ( callback ) ) return let uError = new Error ( 'Unknown Error' ) err = err ? _ . isError ( err ) ? err : _ . isString ( err ) ? new Error ( err ) : uError : uError process . nextTick ( function ( ) { callback ( err ) } ) }
3134	function ( data ) { var fieldsCollection = this . getModel ( ) . getFields ( ) ; if ( fieldsCollection . isDirty ) { this . buildExtractors ( true ) ; delete fieldsCollection . isDirty ; } if ( this . rootAccessor ) { return this . rootAccessor . call ( this , data ) ; } else { return data ; } }
3135	function arrIncludes ( arr , values ) { if ( ! Array . isArray ( values ) ) { return inArray ( arr , values ) } var len = values . length ; var i = - 1 ; while ( i ++ < len ) { var j = inArray ( arr , values [ i ] ) ; if ( j ) { return j } } return false }
3136	function clean ( src ) { let pidx = src . indexOf ( 'http' ) if ( pidx > 0 ) src = src . substr ( pidx ) return src ? pidx >= 0 || src . indexOf ( '//' ) >= 0 ? src : '/' + src : '' }
3137	function jquery ( src ) { src = clean ( src ) ; let params = { } let match = null if ( ! url || ! _ . isString ( src ) ) return params while ( match = REGX_QUERY_OBJECT . exec ( src ) ) { params [ match [ 1 ] ] = match [ 2 ] } return params }
3138	function ( el , options ) { events . EventEmitter . call ( this ) ; this . el = el ; this . options = extend ( { } , this . options ) ; extend ( this . options , options ) ; this . showTab = this . _show ; this . _init ( ) ; }
3139	function toParam ( obj , dontEncode ) { const arr = [ ] ; let vals ; if ( isObject ( obj ) && ! isArray ( obj ) ) { Object . keys ( obj ) . forEach ( ( val ) => { if ( isArray ( obj [ val ] ) ) { vals = ` ${ obj [ val ] . map ( v => ( isNaN ( v ) ? ` ${ v } ` : v ) ) . join ( ',' ) } ` ; } else { vals = isNaN ( obj [ val ] ) ? ` ${ obj [ val ] } ` : obj [ val ] ; } arr . push ( ` ${ val } ${ vals } ` ) ; } ) ; if ( dontEncode ) { return ` ${ arr . join ( ',' ) } ` ; } return encodeURIComponent ( ` ${ arr . join ( ',' ) } ` ) ; } return '' ; }
3140	function ( anchor , local , size ) { Ext . Logger . deprecate ( "getAnchorXY() is no longer available for Ext.Element. Please see Ext.Component#showBy() " + "to do anchoring at Component level instead" , this ) ; anchor = ( anchor || "tl" ) . toLowerCase ( ) ; size = size || { } ; var me = this , vp = me . dom == document . body || me . dom == document , width = size . width || vp ? window . innerWidth : me . getWidth ( ) , height = size . height || vp ? window . innerHeight : me . getHeight ( ) , xy , rnd = Math . round , myXY = me . getXY ( ) , extraX = vp ? 0 : ! local ? myXY [ 0 ] : 0 , extraY = vp ? 0 : ! local ? myXY [ 1 ] : 0 , hash = { c : [ rnd ( width * 0.5 ) , rnd ( height * 0.5 ) ] , t : [ rnd ( width * 0.5 ) , 0 ] , l : [ 0 , rnd ( height * 0.5 ) ] , r : [ width , rnd ( height * 0.5 ) ] , b : [ rnd ( width * 0.5 ) , height ] , tl : [ 0 , 0 ] , bl : [ 0 , height ] , br : [ width , height ] , tr : [ width , 0 ] } ; xy = hash [ anchor ] ; return [ xy [ 0 ] + extraX , xy [ 1 ] + extraY ] ; }
3141	function ( fn , scope ) { var items = [ ] . concat ( this . items ) , i = 0 , len = items . length , item ; for ( ; i < len ; i ++ ) { item = items [ i ] ; if ( fn . call ( scope || item , item , i , len ) === false ) { break ; } } }
3142	function ( config ) { if ( config . path == null ) { Ext . Logger . error ( 'Ext.device.filesystem.DirectoryEntry#getFile: You must specify a `path` of the file.' ) ; return null ; } if ( config . options == null ) { config . options = { } ; } var me = this ; Ext . device . Communicator . send ( { command : 'FileSystem#getEntry' , path : this . path , fileSystemId : this . fileSystem . id , newPath : config . path , directory : config . directory , create : config . options . create , exclusive : config . options . exclusive , callbacks : { success : function ( path ) { if ( config . success ) { var entry = config . directory ? Ext . create ( 'Ext.device.filesystem.DirectoryEntry' , path , me . fileSystem ) : Ext . create ( 'Ext.device.filesystem.FileEntry' , path , me . fileSystem ) ; config . success . call ( config . scope || this , entry ) ; } } , failure : function ( error ) { if ( config . failure ) { config . failure . call ( config . scope || this , error ) ; } } } , scope : config . scope || this } ) ; }
3143	function toHaveText ( ) { return { compare : function compare ( element , text ) { var regexp = text instanceof RegExp ? text : new RegExp ( text , 'ig' ) ; var pass = element . getDOMNode ( ) . textContent . match ( regexp ) ; var message = pass ? 'Text "' + text + '" is found within an element' : 'Text "' + text + '" is not found within an element' ; return { pass : pass , message : message } ; } } ; }
3144	function ( ) { var me = this , container = me . container , baseCls = me . getBaseCls ( ) , scrollable , scrollViewElement , pinnedHeader ; Ext . apply ( me , { listItems : [ ] , headerItems : [ ] , updatedItems : [ ] , headerMap : [ ] , scrollDockItems : { top : [ ] , bottom : [ ] } } ) ; this . translationMethod = Ext . browser . is . AndroidStock2 ? 'cssposition' : 'csstransform' ; if ( ! container ) { container = me . container = Ext . factory ( { xtype : 'container' , scrollable : { scroller : { autoRefresh : ! me . getInfinite ( ) , direction : 'vertical' } } } ) ; } me . add ( container ) ; scrollable = container . getScrollable ( ) ; scrollViewElement = me . scrollViewElement = scrollable . getElement ( ) ; me . scrollElement = scrollable . getScroller ( ) . getElement ( ) ; me . setScrollable ( scrollable ) ; me . scrollableBehavior = container . getScrollableBehavior ( ) ; pinnedHeader = me . pinnedHeader = Ext . factory ( { xtype : 'listitemheader' , html : '&nbsp;' , translatable : { translationMethod : this . translationMethod } , cls : [ baseCls + '-header' , baseCls + '-header-swap' ] } ) ; pinnedHeader . translate ( 0 , - 10000 ) ; pinnedHeader . $position = - 10000 ; scrollViewElement . insertFirst ( pinnedHeader . renderElement ) ; me . bind ( scrollable . getScroller ( ) . getTranslatable ( ) , 'doTranslate' , 'onTranslate' ) ; }
3145	function ( ) { var me = this , container = me . container , scrollViewElement = me . scrollViewElement , indexBar = me . getIndexBar ( ) , triggerEvent = me . getTriggerEvent ( ) , triggerCtEvent = me . getTriggerCtEvent ( ) ; if ( indexBar ) { scrollViewElement . appendChild ( indexBar . renderElement ) ; } if ( triggerEvent ) { me . on ( triggerEvent , me . onItemTrigger , me ) ; } if ( triggerCtEvent ) { me . on ( triggerCtEvent , me . onContainerTrigger , me ) ; } container . element . on ( { delegate : '.' + me . getBaseCls ( ) + '-disclosure' , tap : 'handleItemDisclosure' , scope : me } ) ; container . element . on ( { resize : 'onContainerResize' , scope : me } ) ; container . innerElement . on ( { touchstart : 'onItemTouchStart' , touchend : 'onItemTouchEnd' , tap : 'onItemTap' , taphold : 'onItemTapHold' , singletap : 'onItemSingleTap' , doubletap : 'onItemDoubleTap' , swipe : 'onItemSwipe' , delegate : '.' + Ext . baseCSSPrefix + 'list-item' , scope : me } ) ; if ( me . getStore ( ) ) { me . refresh ( ) ; } }
3146	function ( index ) { var listItems = this . listItems , ln = listItems . length , i , listItem ; for ( i = 0 ; i < ln ; i ++ ) { listItem = listItems [ i ] ; if ( listItem . $dataIndex == index ) { return listItem ; } } }
3147	function ( url , onLoad , onError , scope , charset ) { var script = document . createElement ( 'script' ) , me = this , onLoadFn = function ( ) { me . cleanupScriptElement ( script ) ; onLoad . call ( scope ) ; } , onErrorFn = function ( ) { me . cleanupScriptElement ( script ) ; onError . call ( scope ) ; } ; script . type = 'text/javascript' ; script . src = url ; script . onload = onLoadFn ; script . onerror = onErrorFn ; script . onreadystatechange = function ( ) { if ( this . readyState === 'loaded' || this . readyState === 'complete' ) { onLoadFn ( ) ; } } ; if ( charset ) { script . charset = charset ; } this . documentHead . appendChild ( script ) ; return script ; }
3148	function ( url , onLoad , onError , scope , synchronous ) { var me = this , isFileLoaded = this . isFileLoaded , scriptElements = this . scriptElements , noCacheUrl = url + ( this . getConfig ( 'disableCaching' ) ? ( '?' + this . getConfig ( 'disableCachingParam' ) + '=' + Ext . Date . now ( ) ) : '' ) , xhr , status , content , onScriptError ; if ( isFileLoaded [ url ] ) { return this ; } scope = scope || this ; this . isLoading = true ; if ( ! synchronous ) { onScriptError = function ( ) { onError . call ( scope , "Failed loading '" + url + "', please verify that the file exists" , synchronous ) ; } ; if ( ! Ext . isReady && Ext . onDocumentReady ) { Ext . onDocumentReady ( function ( ) { if ( ! isFileLoaded [ url ] ) { scriptElements [ url ] = me . injectScriptElement ( noCacheUrl , onLoad , onScriptError , scope ) ; } } ) ; } else { scriptElements [ url ] = this . injectScriptElement ( noCacheUrl , onLoad , onScriptError , scope ) ; } } else { if ( typeof XMLHttpRequest != 'undefined' ) { xhr = new XMLHttpRequest ( ) ; } else { xhr = new ActiveXObject ( 'Microsoft.XMLHTTP' ) ; } try { xhr . open ( 'GET' , noCacheUrl , false ) ; xhr . send ( null ) ; } catch ( e ) { onError . call ( this , "Failed loading synchronously via XHR: '" + url + "'; It's likely that the file is either " + "being loaded from a different domain or from the local file system whereby cross origin " + "requests are not allowed due to security reasons. Use asynchronous loading with " + "Ext.require instead." , synchronous ) ; } status = ( xhr . status == 1223 ) ? 204 : xhr . status ; content = xhr . responseText ; if ( ( status >= 200 && status < 300 ) || status == 304 || ( status == 0 && content . length > 0 ) ) { Ext . globalEval ( content + "\n//@ sourceURL=" + \n ) ; url } else onLoad . call ( scope ) ; { onError . call ( this , "Failed loading synchronously via XHR: '" + url + "'; please " + "verify that the file exists. " + "XHR status code: " + status , synchronous ) ; } } }
3149	async function ( fname , attrs ) { let partialDirs ; if ( typeof module . exports . configuration . partialDirs === 'undefined' || ! module . exports . configuration . partialDirs || module . exports . configuration . partialDirs . length <= 0 ) { partialDirs = [ __dirname ] ; } else { partialDirs = module . exports . configuration . partialDirs ; } var partialFound = await globfs . findAsync ( partialDirs , fname ) ; if ( ! partialFound ) throw new Error ( ` ${ fname } ${ util . inspect ( partialDirs ) } ` ) ; partialFound = partialFound [ 0 ] ; if ( ! partialFound ) throw new Error ( ` ${ fname } ${ util . inspect ( partialDirs ) } ` ) ; var partialFname = path . join ( partialFound . basedir , partialFound . path ) ; var stats = await fs . stat ( partialFname ) ; if ( ! stats . isFile ( ) ) { throw new Error ( ` ${ fname } ${ partialFname } ` ) ; } var partialText = await fs . readFile ( partialFname , 'utf8' ) ; if ( / \.ejs$ / i . test ( partialFname ) ) { try { return ejs . render ( partialText , attrs ) ; } catch ( e ) { throw new Error ( ` ${ fname } ${ e } ` ) ; } } else if ( / \.html$ / i . test ( partialFname ) ) { return partialText ; } else { throw new Error ( "No rendering support for ${fname}" ) ; } }
3150	function ( record ) { var me = this , fields = record . getFields ( ) , idProperty = record . getIdProperty ( ) , uniqueIdStrategy = me . getUniqueIdStrategy ( ) , data = { } , name , value ; fields . each ( function ( field ) { if ( field . getPersist ( ) ) { name = field . getName ( ) ; if ( name === idProperty && ! uniqueIdStrategy ) { return ; } value = record . get ( name ) ; if ( field . getType ( ) . type == 'date' ) { value = me . writeDate ( field , value ) ; } data [ name ] = value ; } } , me ) ; return data ; }
3151	function ( provider ) { var me = this , args = Ext . toArray ( arguments ) , i = 0 , ln ; if ( args . length > 1 ) { for ( ln = args . length ; i < ln ; ++ i ) { me . addProvider ( args [ i ] ) ; } return ; } if ( ! provider . isProvider ) { provider = Ext . create ( 'direct.' + provider . type + 'provider' , provider ) ; } me . providers . add ( provider ) ; provider . on ( 'data' , me . onProviderData , me ) ; if ( ! provider . isConnected ( ) ) { provider . connect ( ) ; } return provider ; }
3152	function ( provider ) { var me = this , providers = me . providers ; provider = provider . isProvider ? provider : providers . get ( provider ) ; if ( provider ) { provider . un ( 'data' , me . onProviderData , me ) ; providers . remove ( provider ) ; return provider ; } return null ; }
3153	function ( config ) { config = config || { } ; Ext . applyIf ( config , { application : this } ) ; this . initConfig ( config ) ; for ( var key in config ) { this [ key ] = config [ key ] ; } if ( config . autoCreateViewport ) { Ext . Logger . deprecate ( '[Ext.app.Application] autoCreateViewport has been deprecated in Sencha Touch 2. Please implement a ' + 'launch function on your Application instead and use Ext.create("MyApp.view.Main") to create your initial UI.' ) ; } Ext . Loader . setConfig ( { enabled : true } ) ; Ext . require ( this . getRequires ( ) , function ( ) { if ( this . getEnableLoader ( ) !== false ) { Ext . require ( this . getProfiles ( ) , this . onProfilesLoaded , this ) ; } } , this ) ; }
3154	function ( name , profileName ) { var instances = this . getControllerInstances ( ) , appName = this . getName ( ) , format = Ext . String . format , topLevelName ; if ( name instanceof Ext . app . Controller ) { return name ; } if ( instances [ name ] ) { return instances [ name ] ; } else { topLevelName = format ( "{0}.controller.{1}" , appName , name ) ; profileName = format ( "{0}.controller.{1}.{2}" , appName , profileName , name ) ; return instances [ profileName ] || instances [ topLevelName ] ; } }
3155	function ( ) { delete this . onItemAdd ; if ( this . innerHtmlElement && ! this . getHtml ( ) ) { this . innerHtmlElement . destroy ( ) ; delete this . innerHtmlElement ; } this . on ( 'innerstatechange' , 'onItemInnerStateChange' , this , { delegate : '> component' } ) ; return this . onItemAdd . apply ( this , arguments ) ; }
3156	function ( item , destroy ) { var me = this , index = me . indexOf ( item ) , innerItems = me . getInnerItems ( ) ; if ( destroy === undefined ) { destroy = me . getAutoDestroy ( ) ; } if ( index !== - 1 ) { if ( ! me . removingAll && innerItems . length > 1 && item === me . getActiveItem ( ) ) { me . on ( { activeitemchange : 'doRemove' , scope : me , single : true , order : 'after' , args : [ item , index , destroy ] } ) ; me . doResetActiveItem ( innerItems . indexOf ( item ) ) ; } else { me . doRemove ( item , index , destroy ) ; if ( innerItems . length === 0 ) { me . setActiveItem ( null ) ; } } } return me ; }
3157	function ( destroy , everything ) { var items = this . items , ln = items . length , i = 0 , item ; if ( typeof destroy != 'boolean' ) { destroy = this . getAutoDestroy ( ) ; } everything = Boolean ( everything ) ; this . removingAll = true ; for ( ; i < ln ; i ++ ) { item = items . getAt ( i ) ; if ( item && ( everything || item . isInnerItem ( ) ) ) { this . doRemove ( item , i , destroy ) ; i -- ; ln -- ; } } this . setActiveItem ( null ) ; this . removingAll = false ; return this ; }
3158	function ( activeItem , animation ) { var layout = this . getLayout ( ) , defaultAnimation ; if ( this . activeItemAnimation ) { this . activeItemAnimation . destroy ( ) ; } this . activeItemAnimation = animation = new Ext . fx . layout . Card ( animation ) ; if ( animation && layout . isCard ) { animation . setLayout ( layout ) ; defaultAnimation = layout . getAnimation ( ) ; if ( defaultAnimation ) { defaultAnimation . disable ( ) ; } animation . on ( 'animationend' , function ( ) { if ( defaultAnimation ) { defaultAnimation . enable ( ) ; } animation . destroy ( ) ; } , this ) ; } return this . setActiveItem ( activeItem ) ; }
3159	function ( deep ) { var items = this . getItems ( ) . items . slice ( ) , ln = items . length , i , item ; if ( deep ) { for ( i = 0 ; i < ln ; i ++ ) { item = items [ i ] ; if ( item . getRefItems ) { items = items . concat ( item . getRefItems ( true ) ) ; } } } return items ; }
3160	function ( e ) { var srcElement = e . srcElement . nodeName . toUpperCase ( ) , selectableElements = [ 'INPUT' , 'TEXTAREA' ] ; if ( selectableElements . indexOf ( srcElement ) == - 1 ) { return false ; } }
3161	function ( number , min , max ) { number = parseFloat ( number ) ; if ( ! isNaN ( min ) ) { number = Math . max ( number , min ) ; } if ( ! isNaN ( max ) ) { number = Math . min ( number , max ) ; } return number ; }
3162	function ( value , increment , minValue , maxValue ) { var newValue = value , m ; if ( ! ( increment && value ) ) { return value ; } m = value % increment ; if ( m !== 0 ) { newValue -= m ; if ( m * 2 >= increment ) { newValue += increment ; } else if ( m * 2 < - increment ) { newValue -= increment ; } } return Ext . Number . constrain ( newValue , minValue , maxValue ) ; }
3163	function ( value , precision ) { if ( isToFixedBroken ) { precision = precision || 0 ; var pow = Math . pow ( 10 , precision ) ; return ( Math . round ( value * pow ) / pow ) . toFixed ( precision ) ; } return value . toFixed ( precision ) ; }
3164	function logger ( req , res , next ) { if ( req . url . substr ( 0 , 2 ) === "/r" ) { console . log ( req . method , decodeURIComponent ( req . url ) , req . body ? JSON . stringify ( req . body ) : "" ) ; } next ( ) ; }
3165	function typeConvert ( obj , onlyDate ) { var i , res ; if ( typeof obj === "object" ) { for ( i in obj ) { if ( obj . hasOwnProperty ( i ) ) { obj [ i ] = typeConvert ( obj [ i ] , onlyDate ) ; } } } else if ( typeof obj === "string" ) { if ( ! onlyDate && obj . match ( / ^([0-9.]+|true|false|undefined|null)$ / ) ) { obj = eval ( obj ) ; } else { res = obj . match ( / ^"?(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)"?$ / ) ; if ( res ) { obj = new Date ( res [ 1 ] ) ; } } } return obj ; }
3166	function typeConvertMiddleware ( req , res , next ) { typeConvert ( req . params ) ; typeConvert ( req . body , true ) ; next ( ) ; }
3167	function defineRoute ( method , route , handler ) { server [ method ] ( route , function ( req , res ) { var store = stores . get ( req . params . resource ) ; delete req . params . resource ; handler ( req , store , function ( error , docs ) { if ( error ) { res . status ( 500 ) ; res . end ( error ) ; } else if ( ! docs ) { res . status ( 404 ) ; res . end ( "Not found" ) ; } else { res . json ( docs ) ; } } ) ; } ) ; }
3168	function routeURL ( ) { var prefix = options . prefix || "" , args = [ "/" + prefix , ":resource" ] . concat ( Array . prototype . slice . call ( arguments ) ) ; return path . join . apply ( path , args ) ; }
3169	function createPasswordHash ( object ) { if ( ! object ) return object ; var password = object . password ; if ( password ) { delete object . password ; object . passwordSalt = sha1 ( Math . random ( ) . toString ( ) ) ; object . passwordHash = sha1 ( "restify-magic" + object . passwordSalt + password ) ; } return object ; }
3170	function ( json , typeSpecification , array ) { var keys , current = json , nested = [ ] , nestedKeys = [ ] , levels = [ ] , query = 'COLUMN_CREATE(' , root = true , curNest = '' , curItem , item = 0 , level = 0 ; while ( current ) { keys = Object . keys ( current ) ; var len = keys . length ; var _l ; var deepestLevel = 1 ; for ( var i = 0 ; i < len ; ++ i ) { if ( ( _l = current [ keys [ i ] ] ) === null || _l === undefined ) { continue ; } if ( typeof ( _l ) === 'object' ) { if ( ! Object . keys ( _l ) . length ) { _l = null ; if ( ! typeSpecification ) { query += '\'' + \' + keys [ i ] . replace ( / \\ / g , '\\\\' ) . \\ \\ . replace ( / \u0008 / g , '\\b' ) . \\ replace ; } else ( / ' / g , '\\\'' ) \\ } \' replace ( / \u0000 / g , '\\0' ) } else \\ } '\', NULL, ' \' { query += '?, NULL, ' ; array . push ( keys [ i ] ) ; } continue ; nested . push ( _l ) ; nestedKeys . push ( keys [ i ] ) ; if ( curItem !== item ) { curItem = item ; ++ level ; levels . push ( { level : level - 1 , nestSep : curNest + ')' } ) ; } else { levels . push ( { level : level - 1 , nestSep : ')' } ) ; } } { var queryType = typeof ( _l ) ; if ( ! typeSpecification ) { query += '\'' + \' + keys [ i ] . replace ( / \\ / g , '\\\\' ) . \\ \\ . replace ( / \u0008 / g , '\\b' ) . \\ replace ; } else ( / ' / g , '\\\'' ) \\ } \' }
3171	function ( node ) { if ( Ext . isObject ( node ) && ! node . isModel ) { node = Ext . data . ModelManager . create ( node , this . modelName ) ; } return Ext . data . NodeInterface . decorate ( node ) ; }
3172	function ( silent ) { var me = this , parentNode = me . parentNode , isFirst = ( ! parentNode ? true : parentNode . firstChild == me ) , isLast = ( ! parentNode ? true : parentNode . lastChild == me ) , depth = 0 , parent = me , children = me . childNodes , ln = children . length , i ; while ( parent . parentNode ) { ++ depth ; parent = parent . parentNode ; } me . beginEdit ( ) ; me . set ( { isFirst : isFirst , isLast : isLast , depth : depth , index : parentNode ? parentNode . indexOf ( me ) : 0 , parentId : parentNode ? parentNode . getId ( ) : null } ) ; me . endEdit ( silent ) ; if ( silent ) { me . commit ( silent ) ; } for ( i = 0 ; i < ln ; i ++ ) { children [ i ] . updateInfo ( silent ) ; } }
3173	function ( node , destroy , suppressEvents , suppressNodeUpdate ) { var me = this , index = me . indexOf ( node ) ; if ( index == - 1 || ( suppressEvents !== true && me . fireEvent ( "beforeremove" , me , node ) === false ) ) { return false ; } Ext . Array . erase ( me . childNodes , index , 1 ) ; if ( me . firstChild == node ) { me . setFirstChild ( node . nextSibling ) ; } if ( me . lastChild == node ) { me . setLastChild ( node . previousSibling ) ; } if ( suppressEvents !== true ) { me . fireEvent ( "remove" , me , node ) ; } if ( node . previousSibling ) { node . previousSibling . nextSibling = node . nextSibling ; node . previousSibling . updateInfo ( suppressNodeUpdate ) ; } if ( node . nextSibling ) { node . nextSibling . previousSibling = node . previousSibling ; node . nextSibling . updateInfo ( suppressNodeUpdate ) ; } if ( ! me . childNodes . length ) { me . set ( 'loaded' , me . isLoaded ( ) ) ; } if ( destroy ) { node . destroy ( true ) ; } else { node . clear ( ) ; } return node ; }
3174	function ( destroy ) { var me = this ; me . parentNode = me . previousSibling = me . nextSibling = null ; if ( destroy ) { me . firstChild = me . lastChild = null ; } }
3175	function ( silent ) { var me = this , options = me . destroyOptions ; if ( silent === true ) { me . clear ( true ) ; Ext . each ( me . childNodes , function ( n ) { n . destroy ( true ) ; } ) ; me . childNodes = null ; delete me . destroyOptions ; me . callOverridden ( [ options ] ) ; } else { me . destroyOptions = silent ; me . remove ( true ) ; } }
3176	function ( node , refNode , suppressEvents ) { var me = this , index = me . indexOf ( refNode ) , oldParent = node . parentNode , refIndex = index , ps ; if ( ! refNode ) { return me . appendChild ( node ) ; } if ( node == refNode ) { return false ; } node = me . createNode ( node ) ; if ( suppressEvents !== true && me . fireEvent ( "beforeinsert" , me , node , refNode ) === false ) { return false ; } if ( oldParent == me && me . indexOf ( node ) < index ) { refIndex -- ; } if ( oldParent ) { if ( suppressEvents !== true && node . fireEvent ( "beforemove" , node , oldParent , me , index , refNode ) === false ) { return false ; } oldParent . removeChild ( node ) ; } if ( refIndex === 0 ) { me . setFirstChild ( node ) ; } Ext . Array . splice ( me . childNodes , refIndex , 0 , node ) ; node . parentNode = me ; node . nextSibling = refNode ; refNode . previousSibling = node ; ps = me . childNodes [ refIndex - 1 ] ; if ( ps ) { node . previousSibling = ps ; ps . nextSibling = node ; ps . updateInfo ( ) ; } else { node . previousSibling = null ; } node . updateInfo ( ) ; if ( ! me . isLoaded ( ) ) { me . set ( 'loaded' , true ) ; } else if ( me . childNodes . length === 1 ) { me . set ( 'loaded' , me . isLoaded ( ) ) ; } if ( suppressEvents !== true ) { me . fireEvent ( "insert" , me , node , refNode ) ; if ( oldParent ) { node . fireEvent ( "move" , node , oldParent , me , refIndex , refNode ) ; } } return node ; }
3177	function ( destroy , suppressEvents ) { var parentNode = this . parentNode ; if ( parentNode ) { parentNode . removeChild ( this , destroy , suppressEvents , true ) ; } return this ; }
3178	function ( destroy , suppressEvents ) { var cn = this . childNodes , n ; while ( ( n = cn [ 0 ] ) ) { this . removeChild ( n , destroy , suppressEvents ) ; } return this ; }
3179	function ( sortFn , recursive , suppressEvent ) { var cs = this . childNodes , ln = cs . length , i , n ; if ( ln > 0 ) { Ext . Array . sort ( cs , sortFn ) ; for ( i = 0 ; i < ln ; i ++ ) { n = cs [ i ] ; n . previousSibling = cs [ i - 1 ] ; n . nextSibling = cs [ i + 1 ] ; if ( i === 0 ) { this . setFirstChild ( n ) ; } if ( i == ln - 1 ) { this . setLastChild ( n ) ; } n . updateInfo ( suppressEvent ) ; if ( recursive && ! n . isLeaf ( ) ) { n . sort ( sortFn , true , true ) ; } } this . notifyStores ( 'afterEdit' , [ 'sorted' ] , { sorted : 'sorted' } ) ; if ( suppressEvent !== true ) { this . fireEvent ( 'sort' , this , cs ) ; } } }
3180	function ( recursive , callback , scope ) { var me = this ; if ( ! me . isLeaf ( ) ) { if ( me . isLoading ( ) ) { me . on ( 'expand' , function ( ) { me . expand ( recursive , callback , scope ) ; } , me , { single : true } ) ; } else { if ( ! me . isExpanded ( ) ) { me . fireAction ( 'expand' , [ this ] , function ( ) { me . set ( 'expanded' , true ) ; Ext . callback ( callback , scope || me , [ me . childNodes ] ) ; } ) ; } else { Ext . callback ( callback , scope || me , [ me . childNodes ] ) ; } } } else { Ext . callback ( callback , scope || me ) ; } }
3181	function ( recursive , callback , scope ) { var me = this ; if ( ! me . isLeaf ( ) && me . isExpanded ( ) ) { this . fireAction ( 'collapse' , [ me ] , function ( ) { me . set ( 'expanded' , false ) ; Ext . callback ( callback , scope || me , [ me . childNodes ] ) ; } ) ; } else { Ext . callback ( callback , scope || me , [ me . childNodes ] ) ; } }
3182	function ( nextTargetFn , fnOpt ) { tail . next = { fns : [ nextTargetFn ] , opts : [ fnOpt ] } ; tail = tail . next ; dispatch ( ) ; return controller ; }
3183	function ( ) { var mask = Ext . getBody ( ) . createChild ( { cls : Ext . baseCSSPrefix + 'mask ' + Ext . baseCSSPrefix + 'mask-transparent' } ) ; setTimeout ( function ( ) { mask . destroy ( ) ; } , 0 ) ; }
3184	function ( el , prefix ) { if ( el && el . id ) { return el . id ; } el = Ext . getDom ( el ) || { } ; if ( el === document || el === document . documentElement ) { el . id = 'ext-app' ; } else if ( el === document . body ) { el . id = 'ext-body' ; } else if ( el === window ) { el . id = 'ext-window' ; } el . id = el . id || ( ( prefix || 'ext-' ) + ( ++ Ext . idSeed ) ) ; return el . id ; }
3185	function ( dest , source , names , usePrototypeKeys ) { if ( typeof names == 'string' ) { names = names . split ( / [,;\s] / ) ; } Ext . each ( names , function ( name ) { if ( usePrototypeKeys || source . hasOwnProperty ( name ) ) { dest [ name ] = source [ name ] ; } } , this ) ; return dest ; }
3186	function ( node ) { if ( node && node . parentNode && node . tagName != 'BODY' ) { Ext . get ( node ) . clearListeners ( ) ; node . parentNode . removeChild ( node ) ; delete Ext . cache [ node . id ] ; } }
3187	function addAction ( name , fn ) { if ( typeof name === "object" && fn == null ) { _ . each ( name , function ( fn , n ) { this . addAction ( n , fn ) ; } , this ) ; return this ; } if ( typeof name !== "string" || name === "" ) throw new Error ( "Expecting non-empty string for action name." ) ; if ( typeof fn !== "function" ) throw new Error ( "Expecting function for action." ) ; if ( this . _actions == null ) this . _actions = { } ; if ( this . _actions [ name ] == null ) this . _actions [ name ] = [ ] ; if ( ! ~ this . _actions [ name ] . indexOf ( fn ) ) this . _actions [ name ] . push ( fn ) ; return this ; }
3188	function ( property , obj , newProperty ) { if ( config . hasOwnProperty ( property ) ) { if ( obj ) { config [ obj ] = config [ obj ] || { } ; config [ obj ] [ ( newProperty ) ? newProperty : property ] = config [ obj ] [ ( newProperty ) ? newProperty : property ] || config [ property ] ; } else { config [ newProperty ] = config [ property ] ; } delete config [ property ] ; Ext . Logger . deprecate ( "'" + property + "' config is deprecated, use the '" + ( ( obj ) ? obj + "." : "" ) + ( ( newProperty ) ? newProperty : property ) + "' config instead" , 2 ) ; } }
3189	function Store ( name , items ) { if ( ! name ) { throw new Error ( 'Please give the store a name!' ) ; } this . name = name ; this . items = items || { } ; this . type = 'object' ; this . setType ( ) ; return this ; }
3190	function node ( content , type , name , indent ) { this . type = type ; if ( name ) this . name = name ; this . content = content ; if ( indent ) { this . indent = indent ; if ( ~ eol . indexOf ( indent [ 0 ] ) ) { delete this . indent ; } } var loc = location ( ) ; var bol = loc . start . column == 1 ; if ( bol ) this . bol = true ; this . line = loc . start . line ; this . column = loc . start . column ; }
3191	function f ( arr ) { if ( arr ) { var merged = [ ] ; return merged . concat . apply ( merged , arr ) . join ( "" ) } }
3192	function configureStore ( onComplete ) { var middlewares = [ thunk ] ; events . emit ( 'middlewaresWillApply' , middlewares ) ; if ( __DEV__ && ! ! window . navigator . userAgent ) { middlewares . push ( createLogger ( { collapsed : true , duration : true , } ) ) ; } var storeCreator = applyMiddleware . apply ( null , middlewares ) ( createStore ) ; var result = { } ; events . emit ( 'storeWillCreate' , storeCreator , reducers , onComplete , result ) ; if ( result . store === undefined ) { result . store = storeCreator ( reducers ) ; setTimeout ( onComplete , 0 ) ; } global . reduxStore = result . store ; return reduxStore ; }
3193	function ( el , config ) { var me = this ; config = config || { } ; Ext . apply ( me , config ) ; me . el = Ext . get ( el ) ; me . callParent ( ) ; me . mixins . observable . constructor . call ( me ) ; if ( ! me . disabled ) { me . enable ( ) ; } me . el . addCls ( me . baseCls ) ; }
3194	function ( ) { if ( ! this . mgr ) { this . mgr = Ext . util . Observable . observe ( Ext . util . Draggable ) ; } this . mgr . on ( { dragstart : this . onDragStart , scope : this } ) ; this . disabled = false ; }
3195	function rel ( root , src , sep ) { if ( ! root || ! _ . isString ( root ) || ! src || ! _ . isString ( src ) ) return let root_split = root . split ( path . sep ) , src_split = src . split ( path . sep ) return _ . join ( _ . difference ( src_split , root_split ) , sep || '/' ) }
3196	function rebase ( root , src , dest ) { let relp = rel ( root , src ) return relp ? path . join ( dest , relp ) : '' }
3197	function lookupLevel ( level ) { if ( typeof level === 'string' ) { var levelMap = _utils . indexOf ( logger . methodMap , level . toLowerCase ( ) ) ; if ( levelMap >= 0 ) { level = levelMap ; } else { level = parseInt ( level , 10 ) ; } } return level ; }
3198	function log ( level ) { level = logger . lookupLevel ( level ) ; if ( typeof console !== 'undefined' && logger . lookupLevel ( logger . level ) <= level ) { var method = logger . methodMap [ level ] ; if ( ! console [ method ] ) { method = 'log' ; } for ( var _len = arguments . length , message = Array ( _len > 1 ? _len - 1 : 0 ) , _key = 1 ; _key < _len ; _key ++ ) { message [ _key - 1 ] = arguments [ _key ] ; } console [ method ] . apply ( console , message ) ; } }
3199	function simpleId ( path ) { return path . parts . length === 1 && ! AST . helpers . scopedId ( path ) && ! path . depth ; }
3200	function acceptKey ( node , name ) { var value = this . accept ( node [ name ] ) ; if ( this . mutating ) { if ( value && ! Visitor . prototype [ value . type ] ) { throw new _exception2 [ 'default' ] ( 'Unexpected node type "' + value . type + '" found when accepting ' + name + ' on ' + node . type ) ; } node [ name ] = value ; } }
3201	function acceptRequired ( node , name ) { this . acceptKey ( node , name ) ; if ( ! node [ name ] ) { throw new _exception2 [ 'default' ] ( node . type + ' requires ' + name ) ; } }
3202	function acceptArray ( array ) { for ( var i = 0 , l = array . length ; i < l ; i ++ ) { this . acceptKey ( array , i ) ; if ( ! array [ i ] ) { array . splice ( i , 1 ) ; i -- ; l -- ; } } }
3203	function ret ( context , execOptions ) { if ( ! compiled ) { compiled = compileInput ( ) ; } return compiled . call ( this , context , execOptions ) ; }
3204	function reduceChildListMutation ( mutationContent , record ) { const isAdded = Boolean ( record . addedNodes . length ) ; const isNext = Boolean ( record . nextSibling ) ; const isPrev = Boolean ( record . previousSibling ) ; const isRemoved = Boolean ( record . removedNodes . length ) ; if ( isAdded && ( isRemoved || ( ! isRemoved && ! isNext && ! isPrev ) ) ) { while ( mutationContent . firstChild ) { mutationContent . removeChild ( mutationContent . firstChild ) ; } forEach ( record . addedNodes , function ( node ) { mutationContent . appendChild ( node ) ; } ) ; } else if ( isAdded && ! isRemoved && ! isNext && isPrev ) { forEach ( record . addedNodes , function ( node ) { mutationContent . appendChild ( node ) ; } ) ; } else if ( isAdded && ! isRemoved && isNext && ! isPrev ) { forEach ( record . addedNodes , function ( node ) { mutationContent . insertBefore ( node , mutationContent . firstChild ) ; } ) ; } return mutationContent ; }
3205	function Node ( options ) { if ( ! ( this instanceof Node ) ) { return new Node ( options ) } events . EventEmitter . call ( this ) this . _setStorageAdapter ( options . storage ) this . _log = options . logger this . _rpc = options . transport this . _self = this . _rpc . _contact this . _validator = options . validator this . _router = options . router || new Router ( { logger : this . _log , transport : this . _rpc , validator : this . _validateKeyValuePair . bind ( this ) } ) this . _bindRouterEventHandlers ( ) this . _bindRPCMessageHandlers ( ) this . _startReplicationInterval ( ) this . _startExpirationInterval ( ) this . _log . info ( 'node created' , { nodeID : this . _self . nodeID } ) }
3206	function ( ) { var deferred ; deferred = Q . defer ( ) ; if ( running . length < limit ) { running . push ( deferred ) ; deferred . resolve ( ) ; } else { queue . push ( deferred ) ; } return deferred . promise ; }
3207	function ( ) { var next ; running . pop ( ) ; if ( queue . length > 0 && running . length < limit ) { switch ( type ) { case "lifo" : next = queue . pop ( ) ; break ; default : next = queue . shift ( ) ; } running . push ( next ) ; return next . resolve ( ) ; } }
3208	function ( ) { var promise ; while ( promise = queue . pop ( ) ) { promise . reject ( "flush" ) ; } while ( promise = running . pop ( ) ) { promise . reject ( "flush" ) ; } }
3209	function ( record ) { var me = this ; me . _record = record ; if ( record && record . data ) { me . setValues ( record . data ) ; } return this ; }
3210	function ( ) { var fields = [ ] ; var getFieldsFrom = function ( item ) { if ( item . isField ) { fields . push ( item ) ; } if ( item . isContainer ) { item . items . each ( getFieldsFrom ) ; } } ; this . items . each ( getFieldsFrom ) ; return fields ; }
3211	function ( ) { var fields = this . getFieldsArray ( ) , ln = fields . length , field , i ; for ( i = 0 ; i < ln ; i ++ ) { field = fields [ i ] ; if ( field . isFocused ) { return field ; } } return null ; }
3212	function ( point , threshold ) { if ( typeof threshold == 'number' ) { threshold = { x : threshold } ; threshold . y = threshold . x ; } var x = point . x , y = point . y , thresholdX = threshold . x , thresholdY = threshold . y ; return ( this . x <= x + thresholdX && this . x >= x - thresholdX && this . y <= y + thresholdY && this . y >= y - thresholdY ) ; }
3213	function sshCommandSequence ( connection , commands , fnOutput ) { var allResults = [ ] ; var successHandler = function ( nextPromise ) { return function ( result ) { if ( result !== true ) { allResults . push ( result ) ; } return nextPromise ( ) ; } ; } ; var errorHandler = function ( nextPromise ) { return function ( error ) { allResults . push ( error ) ; return nextPromise ( ) ; } ; } ; var result = Q ( true ) ; commands . map ( function ( command ) { return function ( ) { return sshExecSingleCommand ( connection , command , fnOutput ) ; } ; } ) . forEach ( function ( f ) { result = result . then ( successHandler ( f ) , errorHandler ( f ) ) ; } ) ; return result . then ( function ( finalResult ) { allResults . push ( finalResult ) ; return allResults ; } , function ( error ) { allResults . push ( error ) ; return allResults ; } ) ; }
3214	function replaceRefs ( parsed , options ) { var topLevel = topLevelDeclsAndRefs ( parsed ) , refsToReplace = topLevel . refs . filter ( ref => shouldRefBeCaptured ( ref , topLevel , options ) ) , locallyIgnored = [ ] ; const replaced = ReplaceVisitor . run ( parsed , ( node , path ) => { if ( node . type === "Property" && refsToReplace . includes ( node . key ) && node . shorthand ) return prop ( id ( node . key . name ) , node . value ) ; if ( node . type === "ExportNamedDeclaration" ) { var { declaration , specifiers } = node ; if ( declaration ) { if ( declaration . id ) locallyIgnored . push ( declaration . id ) else if ( declaration . declarations ) locallyIgnored . push ( ... declaration . declarations . map ( ( { id } ) => id ) ) } specifiers && specifiers . forEach ( ( { local } ) => locallyIgnored . push ( local ) ) ; return node ; } if ( node . type === "AssignmentExpression" && refsToReplace . includes ( node . left ) && options . declarationWrapper ) return { ... node , right : declarationWrapperCall ( options . declarationWrapper , null , literal ( node . left . name ) , literal ( "assignment" ) , node . right , options . captureObj , options ) } ; return node } ) ; return ReplaceVisitor . run ( replaced , ( node , path , parent ) => refsToReplace . includes ( node ) && ! locallyIgnored . includes ( node ) ? member ( options . captureObj , node ) : node ) ; }
3215	function generateUniqueName ( declaredNames , hint ) { var unique = hint , n = 1 ; while ( declaredNames . indexOf ( unique ) > - 1 ) { if ( n > 1000 ) throw new Error ( "Endless loop searching for unique variable " + unique ) ; unique = unique . replace ( / _[0-9]+$|$ / , "_" + ( ++ n ) ) ; } return unique ; }
3216	function replaceClassDecls ( parsed , options ) { if ( options . classToFunction ) return classToFunctionTransform ( parsed , options . classToFunction ) ; var topLevel = topLevelDeclsAndRefs ( parsed ) ; if ( ! topLevel . classDecls . length ) return parsed ; for ( var i = parsed . body . length - 1 ; i >= 0 ; i -- ) { var stmt = parsed . body [ i ] ; if ( stmt . id && topLevel . classDecls . includes ( stmt ) ) parsed . body . splice ( i + 1 , 0 , assignExpr ( options . captureObj , stmt . id , stmt . id , false ) ) ; } return parsed ; }
3217	function varDeclOrAssignment ( parsed , declarator , kind ) { var topLevel = topLevelDeclsAndRefs ( parsed ) , name = declarator . id . name return topLevel . declaredNames . indexOf ( name ) > - 1 ? exprStmt ( assign ( declarator . id , declarator . init ) ) : { declarations : [ declarator ] , kind : kind || "var" , type : "VariableDeclaration" } }
3218	function Item ( key , value , publisher , timestamp ) { if ( ! ( this instanceof Item ) ) { return new Item ( key , value , publisher , timestamp ) } assert ( typeof key === 'string' , 'Invalid key supplied' ) assert ( utils . isValidKey ( publisher ) , 'Invalid publisher nodeID supplied' ) if ( timestamp ) { assert ( typeof timestamp === 'number' , 'Invalid timestamp supplied' ) assert ( Date . now ( ) >= timestamp , 'Timestamp cannot be in the future' ) } this . key = key this . value = value this . publisher = publisher this . timestamp = timestamp || Date . now ( ) }
3219	function on ( top ) { top = typeof top === 'string' ? document . querySelector ( top ) : top ; var h = handle . bind ( this , top ) ; h . once = once . bind ( this , top ) ; return h ; }
3220	function handleElements ( elements , type , fn , capture ) { if ( ! elements || typeof elements . length !== 'number' ) throw new TypeError ( 'Cannot bind event ' + inspect ( type ) + ' to ' + inspect ( elements ) ) ; if ( typeof type !== 'string' ) throw new TypeError ( 'Event type must be a string, e.g. "click", not ' + inspect ( type ) ) ; if ( typeof fn !== 'function' ) throw new TypeError ( '`fn` (the function to call when the event is triggered) must be a function, not ' + inspect ( fn ) ) ; if ( capture !== undefined && capture !== false && capture !== true ) { throw new TypeError ( '`capture` must be `undefined` (defaults to `false`), `false` or `true`, not ' + inspect ( capture ) ) ; } var handles = [ ] ; for ( var i = 0 ; i < elements . length ; i ++ ) { handles . push ( handleElement ( elements [ i ] , type , fn , capture ) ) ; } return function dispose ( ) { for ( var i = 0 ; i < handles . length ; i ++ ) { handles [ i ] ( ) ; } } ; }
3221	function ( opt ) { this . disable ( ) ; if ( opt ) this . set ( opt ) ; var jNode = new JSYG ( this . node ) , dim = jNode . getDim ( ) , color = jNode . fill ( ) , svg = jNode . offsetParent ( ) , id = 'idpattern' + JSYG . rand ( 0 , 5000 ) , g , rect , selection ; if ( ! color || color == 'transparent' || color == 'none' ) color = 'white' ; if ( dim . width < this . boxInit . width ) this . boxInit . width = dim . width ; if ( dim . height < this . boxInit . height ) this . boxInit . height = dim . height ; rect = new JSYG ( '<rect>' ) . fill ( color ) ; g = new JSYG ( '<g>' ) . append ( rect ) ; new JSYG ( this . pattern ) . attr ( { id : id , patternUnits : 'userSpaceOnUse' } ) . append ( g ) . appendTo ( svg ) ; new JSYG ( this . mask ) . css ( 'fill-opacity' , 0.5 ) . appendTo ( svg ) ; if ( this . keepRatio ) this . boxInit . height = dim . height * this . boxInit . width / dim . width ; selection = new JSYG ( this . selection ) . attr ( this . boxInit ) . attr ( 'fill' , "url(#" + id + ")" ) . appendTo ( svg ) ; this . editor . target ( selection ) ; this . editor . displayShadow = false ; new JSYG ( this . editor . pathBox ) . css ( 'fill-opacity' , 0 ) ; this . editor . ctrlsDrag . enable ( { bounds : 0 } ) ; this . editor . ctrlsResize . enable ( { keepRatio : this . keepRatio , bounds : 0 } ) ; this . editor . show ( ) ; this . enabled = true ; this . update ( ) ; return this ; }
3222	function without ( toRemove ) { return function ( prev , curr ) { if ( ! Array . isArray ( prev ) ) { prev = ! testValue ( prev , toRemove ) ? [ prev ] : [ ] } if ( ! testValue ( curr , toRemove ) ) prev . push ( curr ) return prev } }
3223	function initDhtmlxToolbar ( container ) { var impl = null ; if ( Util . isNode ( container ) ) { impl = new dhtmlXToolbarObject ( container , SKIN ) ; } else if ( container . type === OBJECT_TYPE . LAYOUT_CELL || container . type === OBJECT_TYPE . ACCORDION_CELL || container . type === OBJECT_TYPE . LAYOUT || container . type === OBJECT_TYPE . WINDOW || container . type === OBJECT_TYPE . TAB ) { impl = container . impl . attachToolbar ( ) ; impl . setSkin ( SKIN ) ; } else { throw new Error ( 'initDhtmlxToolbar: container is not valid.' ) ; } return impl ; }
3224	function ( data , track ) { if ( track !== false ) data = $track ( data , track ) ; this . data = data ; this . _dep . changed ( ) ; return this ; }
3225	function ( ) { var models = [ this ] , model = this ; while ( model . parent ) { models . unshift ( model = model . parent ) ; } return models }
3226	function ( index ) { if ( ! _ . isNumber ( index ) || isNaN ( index ) ) index = 0 ; if ( index < 0 ) return this . getAllModels ( ) [ ~ index ] ; var model = this ; while ( index && model ) { model = model . parent ; index -- ; } return model ; }
3227	function ( fn ) { var index = 0 , model = this ; while ( model != null ) { if ( fn . call ( this , model , index ++ ) ) return model ; model = model . parent ; } }
3228	function ( path ) { if ( typeof path === "string" ) path = parse ( path , { startRule : "path" } ) ; if ( ! _ . isObject ( path ) ) throw new Error ( "Expecting string or object for path." ) ; var self = this ; this . _dep . depend ( ) ; return _ . reduce ( path . parts , function ( target , part ) { target = self . _get ( target , part . key ) ; _ . each ( part . children , function ( k ) { if ( _ . isObject ( k ) ) k = self . get ( k ) ; target = self . _get ( target , k ) ; } ) ; return target ; } , this . data ) ; }
3229	function ( paths ) { var self = this ; if ( typeof paths === "string" ) paths = parse ( paths , { startRule : "pathQuery" } ) ; if ( ! _ . isArray ( paths ) ) paths = paths != null ? [ paths ] : [ ] ; if ( ! paths . length ) { var model = this . findModel ( function ( m ) { return ! _ . isUndefined ( m . data ) ; } ) ; if ( model == null ) return ; var val = model . data ; if ( _ . isFunction ( val ) ) val = val . call ( this , null ) ; return val ; } return _ . reduce ( paths , function ( result , path , index ) { var model = self , scope = true , val ; if ( path . type === "root" ) { model = self . getRootModel ( ) ; } else if ( path . type === "parent" ) { model = self . getModelAtOffset ( path . distance ) ; scope = false ; } else if ( path . type === "all" ) { scope = false ; } if ( model == null ) return ; while ( _ . isUndefined ( val ) && model != null ) { val = model . getLocal ( path ) ; model = model . parent ; if ( scope ) break ; } if ( _ . isFunction ( val ) ) { val = val . call ( self , index === 0 ? null : result ) ; } return val ; } , void 0 ) ; }
3230	function ( done ) { crypto . randomBytes ( 20 , function ( err , buffer ) { var token = buffer . toString ( 'hex' ) ; done ( err , token ) ; } ) ; }
3231	function ( token , done ) { if ( req . body . username ) { User . findOne ( { username : req . body . username } , '-salt -password' , function ( err , user ) { if ( ! user ) { return res . status ( 400 ) . send ( { message : 'No account with that username has been found' } ) ; } else if ( user . provider !== 'local' ) { return res . status ( 400 ) . send ( { message : 'It seems like you signed up using your ' + user . provider + ' account' } ) ; } else { user . resetPasswordToken = token ; user . resetPasswordExpires = Date . now ( ) + 3600000 ; user . save ( function ( err ) { done ( err , token , user ) ; } ) ; } } ) ; } else { return res . status ( 400 ) . send ( { message : 'Username field must not be blank' } ) ; } }
3232	function ( emailHTML , user , done ) { var smtpTransport = nodemailer . createTransport ( config . mailer . options ) ; var mailOptions = { to : user . email , from : config . mailer . from , subject : 'Your password has been changed' , html : emailHTML } ; smtpTransport . sendMail ( mailOptions , function ( err ) { done ( err , 'done' ) ; } ) ; }
3233	function sortIssues ( issues ) { var sorted ; if ( Object . keys ( issues ) . indexOf ( 'supers' ) > - 1 ) { issues . supers = _ . sortBy ( issues . supers , function ( issue ) { return new Date ( issue . updated_at ) ; } ) . reverse ( ) ; issues . singletons = _ . sortBy ( issues . singletons , function ( issue ) { return new Date ( issue . updated_at ) ; } ) . reverse ( ) ; sorted = issues ; } else { sorted = _ . sortBy ( issues , function ( issue ) { return new Date ( issue . updated_at ) ; } ) . reverse ( ) ; } return sorted ; }
3234	function deduplicateCollaborators ( collaborators ) { var foundLogins = [ ] ; return _ . filter ( collaborators , function ( collaborator ) { var duplicate = false , login = collaborator . login ; if ( foundLogins . indexOf ( login ) > - 1 ) { duplicate = true ; } else { foundLogins . push ( login ) ; } return ! duplicate ; } ) ; }
3235	function extractSuperIssueSubTaskNumbers ( superIssue ) { var matches = superIssue . body . match ( markdownTasksRegex ) , subTaskIds = [ ] ; _ . each ( matches , function ( line ) { var match = line . match ( subtaskRegex ) ; if ( match ) { subTaskIds . push ( parseInt ( match [ 3 ] ) ) ; } } ) ; return subTaskIds ; }
3236	function formatIssues ( format , issues ) { var formattedIssues , partition , superIssues , singletonIssues , removedSubtasks = [ ] ; if ( format == 'network' ) { formattedIssues = { supers : [ ] , singletons : [ ] , all : issues } ; partition = _ . partition ( issues , function ( issue ) { return _ . find ( issue . labels , function ( label ) { return label . name == 'super' ; } ) ; } ) ; superIssues = partition . shift ( ) ; singletonIssues = partition . shift ( ) ; _ . each ( superIssues , function ( superIssue ) { var subTaskNumbers = extractSuperIssueSubTaskNumbers ( superIssue ) ; superIssue . subtasks = _ . filter ( singletonIssues , function ( issue ) { var isSubtask = _ . contains ( subTaskNumbers , issue . number ) ; if ( isSubtask ) { removedSubtasks . push ( issue . number ) ; } return isSubtask ; } ) ; } ) ; formattedIssues . supers = superIssues ; _ . each ( singletonIssues , function ( issue ) { if ( ! _ . contains ( removedSubtasks , issue . number ) ) { formattedIssues . singletons . push ( issue ) ; } } ) ; } else { formattedIssues = issues ; } return formattedIssues ; }
3237	function mergeIssuesAndPrs ( issues , prs ) { _ . each ( issues , function ( issue ) { var targetPr , targetPrIndex = _ . findIndex ( prs , function ( pr ) { return pr && pr . number == issue . number ; } ) ; if ( targetPrIndex > - 1 ) { targetPr = prs [ targetPrIndex ] ; prs [ targetPrIndex ] = _ . merge ( targetPr , issue ) ; } } ) ; return prs ; }
3238	function Sprinter ( username , password , repoSlugs , cache ) { if ( ! username ) { throw new Error ( 'Missing username.' ) ; } if ( ! password ) { throw new Error ( 'Missing password.' ) ; } if ( ! repoSlugs ) { throw new Error ( 'Missing repositories.' ) ; } this . username = username ; this . password = password ; this . repos = convertSlugsToObjects ( repoSlugs ) ; this . gh = new GitHubApi ( { version : '3.0.0' , timeout : 5000 } ) ; this . gh . authenticate ( { type : 'basic' , username : this . username , password : this . password } ) ; this . _CACHE = { } ; this . setCacheDuration ( cache ) ; this . _setupCaching ( ) ; }
3239	function getFetchByStateCallback ( callback ) { return function ( err , data ) { if ( err ) { asyncErrors . push ( err ) ; } callback ( null , data ) ; } ; }
3240	function listAvailables ( forceRefresh ) { forceRefresh && ( adaptersCache = [ ] ) ; if ( adaptersCache . length ) { return adaptersCache ; } adaptersCache = fs . readdirSync ( __dirname ) . filter ( function ( fileOrDirName ) { return isDir ( __dirname + '/' + fileOrDirName ) ; } ) ; return adaptersCache ; }
3241	function readConfig ( adapterName , path ) { var adapter = getAdapterInstance ( adapterName ) ; return adapter . configLoader ( normalizeAdapterConfigPath ( adapter , path ) ) ; }
3242	function writeConfig ( adapterName , path , config ) { var adapter = getAdapterInstance ( adapterName ) ; return adapter . configWriter ( normalizeAdapterConfigPath ( adapter , path ) , config ) ; }
3243	function handleFiles ( files ) { files . forEach ( function ( f ) { f . src . filter ( srcExists ) . map ( function ( filepath ) { var pathInfo = getPathInfo ( filepath , f . dest ) , context = getContext ( f . context , pathInfo ) ; renderFile ( pathInfo . outfile , filepath , context ) ; } ) ; } ) ; }
3244	function handleI18nFiles ( files ) { options . locales . forEach ( function ( locale ) { grunt . registerTask ( 'swigtemplatesSubtask-' + locale , function ( ) { var done = this . async ( ) ; var translatorFactory = options . translateFunction ( locale ) ; Q . when ( translatorFactory , function ( translator ) { doTranslations ( files , locale , translator ) } ) . done ( done ) ; } ) ; grunt . task . run ( 'swigtemplatesSubtask-' + locale ) ; } ) ; }
3245	function getContext ( context , pathInfo ) { var globalContext , templateContext ; try { globalContext = grunt . file . readJSON ( path . join ( options . templatesDir , "global.json" ) ) ; } catch ( err ) { globalContext = { } ; } try { templateContext = grunt . file . readJSON ( path . join ( pathInfo . dirName , pathInfo . outfileName ) + ".json" ) ; } catch ( err ) { templateContext = { } ; } return _ . extend ( { } , globalContext , templateContext , options . defaultContext , context ) ; }
3246	function render ( url ) { return async page => { try { const template = ` ${ page . template || 'schedule' } ` ; const filePath = path . join ( process . cwd ( ) , config . theme || 'theme' , config . template || 'templates' , template , ) ; const output = Handlebars . compile ( await fs . readFile ( filePath , 'utf-8' ) ) ( page ) ; await fs . ensureDir ( outputDir ) ; const dir = url !== 'index' ? path . join ( outputDir , url ) : outputDir ; await fs . ensureDir ( dir ) ; await fs . writeFile ( path . join ( dir , 'index.html' ) , output , 'utf8' ) ; } catch ( err ) { throw err ; } } ; }
3247	function isNamedFunction ( node ) { if ( node . id ) return true ; const { parent } = node ; const { type } = parent ; const namedFunction = type === 'MethodDefinition' || type === 'Property' && ( parent . kind === 'get' || parent . kind === 'set' || parent . method ) ; return namedFunction ; }
3248	function getConfigForFunction ( node ) { if ( isNamedFunction ( node ) ) return 'never' ; if ( node . type === 'ArrowFunctionExpression' ) { if ( ! node . async || ! astUtils . isOpeningParenToken ( sourceCode . getFirstToken ( node , { skip : 1 } ) ) ) return 'ignore' ; } return 'always' ; }
3249	function checkFunction ( node ) { const functionConfig = getConfigForFunction ( node ) ; if ( functionConfig === 'ignore' ) return ; const rightToken = sourceCode . getFirstToken ( node , astUtils . isOpeningParenToken ) ; const leftToken = sourceCode . getTokenBefore ( rightToken ) ; const text = sourceCode . text . slice ( leftToken . range [ 1 ] , rightToken . range [ 0 ] ) . replace ( / \/\*[^]*?\*\/ / g , '' ) ; if ( astUtils . LINEBREAK_MATCHER . test ( text ) ) return ; const hasSpacing = / \s / . test ( text ) ; if ( hasSpacing && functionConfig === 'never' ) { const report = { node , loc : leftToken . loc . end , message : 'Unexpected space before function parentheses.' , fix : fixer => fixer . removeRange ( [ leftToken . range [ 1 ] , rightToken . range [ 0 ] ] ) , } ; context . report ( report ) ; } else if ( ! hasSpacing && functionConfig === 'always' ) { const report = { node , loc : leftToken . loc . end , message : 'Missing space before function parentheses.' , fix : fixer => fixer . insertTextAfter ( leftToken , ' ' ) , } ; context . report ( report ) ; } }
3250	function ( config ) { var me = this ; for ( var configName in config ) { if ( me . self . prototype . config && ! ( configName in me . self . prototype . config ) ) { me [ configName ] = config [ configName ] ; Ext . Logger . warn ( 'Applied config as instance property: "' + configName + '"' , me ) ; } } me . initConfig ( config ) ; }
3251	function bindEventMap ( eventMap , eventEmitter ) { var eventNames = Object . keys ( eventMap ) ; eventNames . map ( function ( eventName ) { eventEmitter . on ( eventName , eventMap [ eventName ] ) ; } ) ; }
3252	function ( delay , newFn , newScope , newArgs ) { var me = this ; me . cancel ( ) ; if ( Ext . isNumber ( delay ) ) { me . setDelay ( delay ) ; } if ( Ext . isFunction ( newFn ) ) { me . setFn ( newFn ) ; } if ( newScope ) { me . setScope ( newScope ) ; } if ( newScope ) { me . setArgs ( newArgs ) ; } var call = function ( ) { me . getFn ( ) . apply ( me . getScope ( ) , me . getArgs ( ) || [ ] ) ; me . cancel ( ) ; } ; me . setInterval ( setInterval ( call , me . getDelay ( ) ) ) ; }
3253	function ( success , operation , request , response , callback , scope ) { var me = this , action = operation . getAction ( ) , reader , resultSet ; if ( success === true ) { reader = me . getReader ( ) ; try { resultSet = reader . process ( me . getResponseResult ( response ) ) ; } catch ( e ) { operation . setException ( e . message ) ; me . fireEvent ( 'exception' , me , response , operation ) ; return ; } if ( ! operation . getModel ( ) ) { operation . setModel ( this . getModel ( ) ) ; } if ( operation . process ( action , resultSet , request , response ) === false ) { me . setException ( operation , response ) ; me . fireEvent ( 'exception' , me , response , operation ) ; } } else { me . setException ( operation , response ) ; me . fireEvent ( 'exception' , this , response , operation ) ; } if ( typeof callback == 'function' ) { callback . call ( scope || me , operation ) ; } me . afterRequest ( request , success ) ; }
3254	function ( operation , response ) { if ( Ext . isObject ( response ) ) { operation . setException ( { status : response . status , statusText : response . statusText } ) ; } }
3255	function ( request ) { var me = this , url = me . getUrl ( request ) ; if ( ! url ) { Ext . Logger . error ( "You are using a ServerProxy but have not supplied it with a url." ) ; } if ( me . getNoCache ( ) ) { url = Ext . urlAppend ( url , Ext . String . format ( "{0}={1}" , me . getCacheString ( ) , Ext . Date . now ( ) ) ) ; } return url ; }
3256	function ( newDateFormat , oldDateFormat ) { var value = this . getValue ( ) ; if ( newDateFormat != oldDateFormat && Ext . isDate ( value ) ) { this . getComponent ( ) . setValue ( Ext . Date . format ( value , newDateFormat || Ext . util . Format . defaultDateFormat ) ) ; } }
3257	function ( picker , value ) { var me = this , oldValue = me . getValue ( ) ; me . setValue ( value ) ; me . fireEvent ( 'select' , me , value ) ; me . onChange ( me , value , oldValue ) ; }
3258	function clone ( obj ) { var newObj = { } ; if ( ! obj || typeof obj !== 'object' || Array . isArray ( obj ) ) return newObj ; for ( var prop in obj ) newObj [ prop ] = obj [ prop ] ; return newObj ; }
3259	function ImpulseBin ( ) { this . settings = { adapter : 'commander' , quietOption : 'quiet' , requiredOptionTmpl : '--%s is required' , verboseOption : 'verbose' , verboseLogName : '[verbose]' , stdoutLogName : '[stdout]' , stderrLogName : '[stderr]' } ; this . console = require ( 'long-con' ) . create ( ) ; this . adapter = null ; this . options = null ; this . provider = null ; }
3260	function ( config ) { var me = this , currentConfig = me . config , id ; me . onInitializedListeners = [ ] ; me . initialConfig = config ; if ( config !== undefined && 'id' in config ) { id = config . id ; } else if ( 'id' in currentConfig ) { id = currentConfig . id ; } else { id = me . getId ( ) ; } me . id = id ; me . setId ( id ) ; Ext . ComponentManager . register ( me ) ; me . initElement ( ) ; me . initConfig ( me . initialConfig ) ; me . refreshSizeState = me . doRefreshSizeState ; me . refreshFloating = me . doRefreshFloating ; if ( me . refreshSizeStateOnInitialized ) { me . refreshSizeState ( ) ; } if ( me . refreshFloatingOnInitialized ) { me . refreshFloating ( ) ; } me . initialize ( ) ; me . triggerInitialized ( ) ; if ( me . config . fullscreen ) { me . fireEvent ( 'fullscreen' , me ) ; } me . fireEvent ( 'initialize' , me ) ; }
3261	function ( className , force ) { var oldCls = this . getCls ( ) , newCls = ( oldCls ) ? oldCls . slice ( ) : [ ] ; if ( force || newCls . indexOf ( className ) == - 1 ) { newCls . push ( className ) ; } else { Ext . Array . remove ( newCls , className ) ; } this . setCls ( newCls ) ; return this ; }
3262	function ( animation ) { this . setCurrentAlignmentInfo ( null ) ; if ( ! this . getHidden ( ) ) { if ( animation === undefined || ( animation && animation . isComponent ) ) { animation = this . getHideAnimation ( ) ; } if ( animation ) { if ( animation === true ) { animation = 'fadeOut' ; } this . onBefore ( { hiddenchange : 'animateFn' , scope : this , single : true , args : [ animation ] } ) ; } this . setHidden ( true ) ; } return this ; }
3263	function ( animation ) { if ( this . activeAnimation ) { this . activeAnimation . on ( { animationend : function ( ) { this . show ( animation ) ; } , scope : this , single : true } ) ; return this ; } var hidden = this . getHidden ( ) ; if ( hidden || hidden === null ) { if ( animation === true ) { animation = 'fadeIn' ; } else if ( animation === undefined || ( animation && animation . isComponent ) ) { animation = this . getShowAnimation ( ) ; } if ( animation ) { this . beforeShowAnimation ( ) ; this . onBefore ( { hiddenchange : 'animateFn' , scope : this , single : true , args : [ animation ] } ) ; } this . setHidden ( false ) ; } return this ; }
3264	function ( width , height ) { if ( width != undefined ) { this . setWidth ( width ) ; } if ( height != undefined ) { this . setHeight ( height ) ; } }
3265	function ( component , alignment ) { var me = this , viewport = Ext . Viewport , parent = me . getParent ( ) ; me . setVisibility ( false ) ; if ( parent !== viewport ) { viewport . add ( me ) ; } me . show ( ) ; me . on ( { hide : 'onShowByErased' , destroy : 'onShowByErased' , single : true , scope : me } ) ; viewport . on ( 'resize' , 'alignTo' , me , { args : [ component , alignment ] } ) ; me . alignTo ( component , alignment ) ; me . setVisibility ( true ) ; }
3266	function ( component , alignment ) { var alignToElement = component . isComponent ? component . renderElement : component , alignToBox = alignToElement . getPageBox ( ) , element = this . renderElement , box = element . getPageBox ( ) , stats = { alignToBox : alignToBox , alignment : alignment , top : alignToBox . top , left : alignToBox . left , alignToWidth : alignToBox . width , alignToHeight : alignToBox . height , width : box . width , height : box . height } , currentAlignmentInfo = this . getCurrentAlignmentInfo ( ) , isAligned = true ; if ( ! Ext . isEmpty ( currentAlignmentInfo ) ) { Ext . Object . each ( stats , function ( key , value ) { if ( ! Ext . isObject ( value ) && currentAlignmentInfo [ key ] != value ) { isAligned = false ; return false ; } return true ; } ) ; } else { isAligned = false ; } return { isAligned : isAligned , stats : stats } ; }
3267	function ( alignmentInfo ) { this . $currentAlignmentInfo = Ext . isEmpty ( alignmentInfo ) ? null : Ext . merge ( { } , alignmentInfo . stats ? alignmentInfo . stats : alignmentInfo ) ; }
3268	function ( selector ) { var result = this . parent ; if ( selector ) { for ( ; result ; result = result . parent ) { if ( Ext . ComponentQuery . is ( result , selector ) ) { return result ; } } } return result ; }
3269	function ( ) { this . destroy = Ext . emptyFn ; var parent = this . getParent ( ) , referenceList = this . referenceList , i , ln , reference ; this . isDestroying = true ; Ext . destroy ( this . getTranslatable ( ) , this . getPlugins ( ) ) ; if ( parent ) { parent . remove ( this , false ) ; } for ( i = 0 , ln = referenceList . length ; i < ln ; i ++ ) { reference = referenceList [ i ] ; this [ reference ] . destroy ( ) ; delete this [ reference ] ; } Ext . destroy ( this . innerHtmlElement ) ; this . setRecord ( null ) ; this . callSuper ( ) ; Ext . ComponentManager . unregister ( this ) ; }
3270	function ( list , index , target , record , e ) { var me = this , store = list . getStore ( ) , node = store . getAt ( index ) ; me . fireEvent ( 'itemtap' , this , list , index , target , record , e ) ; if ( node . isLeaf ( ) ) { me . fireEvent ( 'leafitemtap' , this , list , index , target , record , e ) ; me . goToLeaf ( node ) ; } else { this . goToNode ( node ) ; } }
3271	function ( ) { var me = this , node = me . getLastNode ( ) , detailCard = me . getDetailCard ( ) , detailCardActive = detailCard && me . getActiveItem ( ) == detailCard , lastActiveList = me . getLastActiveList ( ) ; this . fireAction ( 'back' , [ this , node , lastActiveList , detailCardActive ] , 'doBack' ) ; }
3272	function ( node ) { if ( ! node . isLeaf ( ) ) { throw new Error ( 'goToLeaf: passed a node which is not a leaf.' ) ; } var me = this , card = me . getDetailCard ( node ) , container = me . getDetailContainer ( ) , sharedContainer = container == this , layout = me . getLayout ( ) , animation = ( layout ) ? layout . getAnimation ( ) : false ; if ( card ) { if ( container . getItems ( ) . indexOf ( card ) === - 1 ) { container . add ( card ) ; } if ( sharedContainer ) { if ( me . getActiveItem ( ) instanceof Ext . dataview . List ) { me . setLastActiveList ( me . getActiveItem ( ) ) ; } me . setLastNode ( node ) ; } if ( animation ) { animation . setReverse ( false ) ; } container . setActiveItem ( card ) ; me . syncToolbar ( ) ; } }
3273	function hoistFunctions ( program ) { var functions = [ ] ; var body = [ ] ; for ( let line of program . body ) { if ( line . type === 'ExportDefaultDeclaration' ) { if ( line . declaration . type === 'FunctionDeclaration' ) { functions . push ( line ) ; } else { body . push ( line ) ; } continue ; } if ( line . type === 'ExportNamedDeclaration' ) { if ( ! ! line . declaration && line . declaration . type === 'FunctionDeclaration' ) { functions . push ( line ) ; } else { body . push ( line ) ; } continue ; } if ( line . type === 'FunctionDeclaration' ) { functions . push ( line ) ; } else { body . push ( line ) ; } } return makeProgram ( [ ... functions , ... body ] ) ; }
3274	function parseVehicleID ( $ , item ) { let fields = $ ( item ) . find ( 'td' ) ; let id = $ ( fields [ 1 ] ) . find ( 'a' ) . attr ( 'href' ) . replace ( 'Detail.aspx?id=' , '' ) ; return id ; }
3275	function formatDetails ( details ) { let result = { results : details , count : details . length , time : new Date ( ) . toISOString ( ) } ; return result ; }
3276	function getByID ( id ) { var url = ` ${ APP_BASE_URL } ${ id } ` ; return request ( url ) . then ( function ( body ) { let $ = cheerio . load ( body ) ; let info = { url : url , id : id } ; $ ( 'table#searchTableResults tr' ) . each ( ( i , item ) => { let span = $ ( item ) . find ( 'span' ) ; let key = $ ( span ) . attr ( 'id' ) . replace ( 'ctl00_Application_lbl' , '' ) . toLowerCase ( ) ; let value = $ ( span ) . text ( ) . trim ( ) ; info [ translations [ key ] || key ] = value ; } ) ; info . stolendate = getStandardizedDateStr ( info . stolendate ) ; return info ; } ) ; }
3277	function ( config ) { if ( ! config . callback ) { Ext . Logger . error ( 'You must specify a `callback` for `#canMakePayments` to work.' ) ; return false ; } Ext . device . Communicator . send ( { command : 'Purchase#canMakePayments' , callbacks : { callback : function ( flag ) { config . callback . call ( config . scope || this , flag ) ; } } , scope : config . scope || this } ) ; }
3278	function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'You must specify a `success` callback for `#purchase` to work.' ) ; return false ; } if ( ! config . failure ) { Ext . Logger . error ( 'You must specify a `failure` callback for `#purchase` to work.' ) ; return false ; } Ext . device . Communicator . send ( { command : 'Purchase#purchase' , identifier : this . get ( 'productIdentifier' ) , callbacks : { success : config . success , failure : config . failure } , scope : config . scope || this } ) ; }
3279	function ( config ) { var me = this ; if ( ! config . success ) { Ext . Logger . error ( 'You must specify a `success` callback for `#complete` to work.' ) ; return false ; } if ( ! config . failure ) { Ext . Logger . error ( 'You must specify a `failure` callback for `#complete` to work.' ) ; return false ; } if ( this . get ( 'state' ) != 'charged' ) { config . failure . call ( config . scope || this , 'purchase is not charged' ) ; } Ext . device . Communicator . send ( { command : 'Purchase#complete' , identifier : me . get ( 'transactionIdentifier' ) , callbacks : { success : function ( ) { me . set ( 'state' , 'completed' ) ; config . success . call ( config . scope || this ) ; } , failure : function ( ) { me . set ( 'state' , 'charged' ) ; config . failure . call ( config . scope || this ) ; } } , scope : config . scope || this } ) ; }
3280	function ( key ) { this . key = key ; this . keyType = key . split ( " " ) [ 0 ] ; this . rawkey = key . split ( " " ) [ 1 ] ; try { this . keyComment = key . split ( " " ) [ 2 ] ; } catch ( err ) { this . keyComment = null ; } this . byteArray = this . _stringToBytes ( atob ( this . rawkey ) ) ; this . slicedArray = [ ] ; this . wordLength = 4 ; this . _load ( ) ; }
3281	function ( sourceFunc , boundFunc , context , callingContext , args ) { if ( ! ( callingContext instanceof boundFunc ) ) return sourceFunc . apply ( context , args ) ; Ctor . prototype = sourceFunc . prototype ; var self = new Ctor ; Ctor . prototype = null ; var result = sourceFunc . apply ( self , args ) ; if ( _ . isObject ( result ) ) return result ; return self ; }
3282	function ( e ) { var me = this , oldChecked = me . _checked , newChecked = me . getChecked ( ) ; if ( oldChecked != newChecked ) { if ( newChecked ) { me . fireEvent ( 'check' , me , e ) ; } else { me . fireEvent ( 'uncheck' , me , e ) ; } me . fireEvent ( 'change' , me , newChecked , oldChecked ) ; } }
3283	function ( ) { var values = [ ] ; this . getSameGroupFields ( ) . forEach ( function ( field ) { if ( field . getChecked ( ) ) { values . push ( field . getValue ( ) ) ; } } ) ; return values ; }
3284	function ( values ) { this . getSameGroupFields ( ) . forEach ( function ( field ) { field . setChecked ( ( values . indexOf ( field . getValue ( ) ) !== - 1 ) ) ; } ) ; return this ; }
3285	function ( ) { var me = this , container = me . container ; if ( ! me . getStore ( ) ) { if ( ! me . hasLoadedStore && ! me . getDeferEmptyText ( ) ) { me . showEmptyText ( ) ; } return ; } if ( container ) { me . fireAction ( 'refresh' , [ me ] , 'doRefresh' ) ; } }
3286	function processParams ( paramsString ) { var individualParams = paramsString . split ( "&" ) , resultObject = { } ; individualParams . forEach ( function ( item ) { var itemParts = item . split ( "=" ) , paramName = itemParts [ 0 ] , paramValue = decodeURIComponent ( itemParts [ 1 ] || "" ) ; var paramObject = { } ; paramObject [ paramName ] = paramValue ; $ . extend ( resultObject , paramObject ) ; } ) ; return resultObject ; }
3287	function ( config ) { if ( ! this . _store ) { this . _store = [ { first : 'Robert' , last : 'Dougan' , emails : { work : 'rob@sencha.com' } } , { first : 'Jamie' , last : 'Avins' , emails : { work : 'jamie@sencha.com' } } ] ; } config . success . call ( config . scope || this , this . _store ) ; }
3288	function Collection ( options ) { if ( ! ( this instanceof Collection ) ) { return new Collection ( options ) ; } options = options || { } ; if ( options instanceof Array ) { this . modelType = undefined ; this . items = options ; } else { this . modelType = options . modelType ; this . items = options . items || [ ] ; if ( ! ( this . items instanceof Array ) ) { throw new CollectionException ( 'Items must be an array' ) ; } } }
3289	function find ( filter ) { var item ; var i ; var ilen ; var keys ; var key ; var k ; var klen ; var found ; if ( filter instanceof Function ) { for ( i = 0 , ilen = this . items . length ; i < ilen ; ++ i ) { item = this . items [ i ] ; if ( filter ( item , i ) ) { return item ; } } } else if ( filter !== null && filter !== undefined ) { if ( typeof filter === 'object' ) { keys = Object . keys ( filter ) ; klen = keys . length ; for ( i = 0 , ilen = this . items . length ; i < ilen ; ++ i ) { item = this . items [ i ] ; found = true ; for ( k = 0 ; k < klen && found ; ++ k ) { key = keys [ k ] ; if ( filter [ key ] !== item [ key ] ) { found = false ; } } if ( found ) { return item ; } } } else if ( this . modelType ) { keys = Object . keys ( this . modelType . attributes ) ; klen = keys . length ; for ( i = 0 , ilen = this . items . length ; i < ilen ; ++ i ) { item = this . items [ i ] ; found = false ; for ( k = 0 ; k < klen && ! found ; ++ k ) { key = keys [ k ] ; if ( filter === item [ key ] ) { found = true ; } } if ( found ) { return item ; } } } else { for ( i = 0 , ilen = this . items . length ; i < ilen ; ++ i ) { item = this . items [ i ] ; found = false ; keys = Object . keys ( item ) ; for ( k = 0 , klen = keys . length ; k < klen && ! found ; ++ k ) { key = keys [ k ] ; if ( filter === item [ key ] ) { found = true ; } } if ( found ) { return item ; } } } } return undefined ; }
3290	function ( context , grunt ) { this . context = context ; this . grunt = grunt ; this . options = context . options ( defaultOptions ) ; }
