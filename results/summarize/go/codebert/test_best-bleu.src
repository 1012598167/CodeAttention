0	func NewSTM ( c * v3 . Client , apply func ( STM ) error , so ... stmOption ) ( * v3 . TxnResponse , error ) { opts := & stmOptions { ctx : c . Ctx ( ) } for _ , f := range so { f ( opts ) } if len ( opts . prefetch ) != 0 { f := apply apply = func ( s STM ) error { s . Get ( opts . prefetch ... ) return f ( s ) } } return runSTM ( mkSTM ( c , opts ) , apply ) }
1	func ( rs readSet ) first ( ) int64 { ret := int64 ( math . MaxInt64 - 1 ) for _ , resp := range rs { if rev := resp . Header . Revision ; rev < ret { ret = rev } } return ret }
2	func ( ws writeSet ) cmps ( rev int64 ) [ ] v3 . Cmp { cmps := make ( [ ] v3 . Cmp , 0 , len ( ws ) ) for key := range ws { cmps = append ( cmps , v3 . Compare ( v3 . ModRevision ( key ) , "<" , rev ) ) } return cmps }
3	func NewSTMRepeatable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( RepeatableReads ) ) }
4	func NewSTMSerializable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( Serializable ) ) }
5	func NewSTMReadCommitted ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( ReadCommitted ) ) }
6	func NewCertPool ( CAFiles [ ] string ) ( * x509 . CertPool , error ) { certPool := x509 . NewCertPool ( ) for _ , CAFile := range CAFiles { pemByte , err := ioutil . ReadFile ( CAFile ) if err != nil { return nil , err } for { var block * pem . Block block , pemByte = pem . Decode ( pemByte ) if block == nil { break } cert , err := x509 . ParseCertificate ( block . Bytes ) if err != nil { return nil , err } certPool . AddCert ( cert ) } } return certPool , nil }
7	func NewCert ( certfile , keyfile string , parseFunc func ( [ ] byte , [ ] byte ) ( tls . Certificate , error ) ) ( * tls . Certificate , error ) { cert , err := ioutil . ReadFile ( certfile ) if err != nil { return nil , err } key , err := ioutil . ReadFile ( keyfile ) if err != nil { return nil , err } if parseFunc == nil { parseFunc = tls . X509KeyPair } tlsCert , err := parseFunc ( cert , key ) if err != nil { return nil , err } return & tlsCert , nil }
8	func ( p * peer ) Pause ( ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) p . paused = true p . msgAppReader . pause ( ) p . msgAppV2Reader . pause ( ) }
9	func ( p * peer ) Resume ( ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) p . paused = false p . msgAppReader . resume ( ) p . msgAppV2Reader . resume ( ) }
10	func ( p * peer ) pick ( m raftpb . Message ) ( writec chan <- raftpb . Message , picked string ) { var ok bool if isMsgSnap ( m ) { return p . pipeline . msgc , pipelineMsg } else if writec , ok = p . msgAppV2Writer . writec ( ) ; ok && isMsgApp ( m ) { return writec , streamAppV2 } else if writec , ok = p . writer . writec ( ) ; ok { return writec , streamMsg } return p . pipeline . msgc , pipelineMsg }
11	func ( s * snapshotSender ) post ( req * http . Request ) ( err error ) { ctx , cancel := context . WithCancel ( context . Background ( ) ) req = req . WithContext ( ctx ) defer cancel ( ) type responseAndError struct { resp * http . Response body [ ] byte err error } result := make ( chan responseAndError , 1 ) go func ( ) { resp , err := s . tr . pipelineRt . RoundTrip ( req ) if err != nil { result <- responseAndError { resp , nil , err } return } time . AfterFunc ( snapResponseReadTimeout , func ( ) { httputil . GracefulClose ( resp ) } ) body , err := ioutil . ReadAll ( resp . Body ) result <- responseAndError { resp , body , err } } ( ) select { case <- s . stopc : return errStopped case r := <- result : if r . err != nil { return r . err } return checkPostResponse ( r . resp , r . body , req , s . to ) } }
12	func newTxnResp ( rt * pb . TxnRequest , txnPath [ ] bool ) ( txnResp * pb . TxnResponse , txnCount int ) { reqs := rt . Success if ! txnPath [ 0 ] { reqs = rt . Failure } resps := make ( [ ] * pb . ResponseOp , len ( reqs ) ) txnResp = & pb . TxnResponse { Responses : resps , Succeeded : txnPath [ 0 ] , Header : & pb . ResponseHeader { } , } for i , req := range reqs { switch tv := req . Request . ( type ) { case * pb . RequestOp_RequestRange : resps [ i ] = & pb . ResponseOp { Response : & pb . ResponseOp_ResponseRange { } } case * pb . RequestOp_RequestPut : resps [ i ] = & pb . ResponseOp { Response : & pb . ResponseOp_ResponsePut { } } case * pb . RequestOp_RequestDeleteRange : resps [ i ] = & pb . ResponseOp { Response : & pb . ResponseOp_ResponseDeleteRange { } } case * pb . RequestOp_RequestTxn : resp , txns := newTxnResp ( tv . RequestTxn , txnPath [ 1 : ] ) resps [ i ] = & pb . ResponseOp { Response : & pb . ResponseOp_ResponseTxn { ResponseTxn : resp } } txnPath = txnPath [ 1 + txns : ] txnCount += txns + 1 default : } } return txnResp , txnCount }
13	func applyCompare ( rv mvcc . ReadView , c * pb . Compare ) bool { rr , err := rv . Range ( c . Key , mkGteRange ( c . RangeEnd ) , mvcc . RangeOptions { } ) if err != nil { return false } if len ( rr . KVs ) == 0 { if c . Target == pb . Compare_VALUE { return false } return compareKV ( c , mvccpb . KeyValue { } ) } for _ , kv := range rr . KVs { if ! compareKV ( c , kv ) { return false } } return true }
14	func OpCompact ( rev int64 , opts ... CompactOption ) CompactOp { ret := CompactOp { revision : rev } ret . applyCompactOpts ( opts ) return ret }
15	func NewPriorityQueue ( client * v3 . Client , key string ) * PriorityQueue { return & PriorityQueue { client , context . TODO ( ) , key + "/" } }
16	func ( q * PriorityQueue ) Enqueue ( val string , pr uint16 ) error { prefix := fmt . Sprintf ( "%s%05d" , q . key , pr ) _ , err := newSequentialKV ( q . client , prefix , val ) return err }
17	func NewLeaderStats ( id string ) * LeaderStats { return & LeaderStats { leaderStats : leaderStats { Leader : id , Followers : make ( map [ string ] * FollowerStats ) , } , } }
18	func ( fs * FollowerStats ) Succ ( d time . Duration ) { fs . Lock ( ) defer fs . Unlock ( ) total := float64 ( fs . Counts . Success ) * fs . Latency . Average totalSquare := float64 ( fs . Counts . Success ) * fs . Latency . averageSquare fs . Counts . Success ++ fs . Latency . Current = float64 ( d ) / ( 1000000.0 ) if fs . Latency . Current > fs . Latency . Maximum { fs . Latency . Maximum = fs . Latency . Current } if fs . Latency . Current < fs . Latency . Minimum { fs . Latency . Minimum = fs . Latency . Current } fs . Latency . Average = ( total + fs . Latency . Current ) / float64 ( fs . Counts . Success ) fs . Latency . averageSquare = ( totalSquare + fs . Latency . Current * fs . Latency . Current ) / float64 ( fs . Counts . Success ) fs . Latency . StandardDeviation = math . Sqrt ( fs . Latency . averageSquare - fs . Latency . Average * fs . Latency . Average ) }
19	func ( fs * FollowerStats ) Fail ( ) { fs . Lock ( ) defer fs . Unlock ( ) fs . Counts . Fail ++ }
20	func ( wbs * watchBroadcasts ) delete ( w * watcher ) int { wbs . mu . Lock ( ) defer wbs . mu . Unlock ( ) wb , ok := wbs . watchers [ w ] if ! ok { panic ( "deleting missing watcher from broadcasts" ) } delete ( wbs . watchers , w ) wb . delete ( w ) if wb . empty ( ) { delete ( wbs . bcasts , wb ) wb . stop ( ) } return len ( wbs . bcasts ) }
21	func startStreamWriter ( lg * zap . Logger , local , id types . ID , status * peerStatus , fs * stats . FollowerStats , r Raft ) * streamWriter { w := & streamWriter { lg : lg , localID : local , peerID : id , status : status , fs : fs , r : r , msgc : make ( chan raftpb . Message , streamBufSize ) , connc : make ( chan * outgoingConn ) , stopc : make ( chan struct { } ) , done : make ( chan struct { } ) , } go w . run ( ) return w }
22	func checkStreamSupport ( v * semver . Version , t streamType ) bool { nv := & semver . Version { Major : v . Major , Minor : v . Minor } for _ , s := range supportedStream [ nv . String ( ) ] { if s == t { return true } } return false }
23	func ( pr * Progress ) maybeUpdate ( n uint64 ) bool { var updated bool if pr . Match < n { pr . Match = n updated = true pr . resume ( ) } if pr . Next < n + 1 { pr . Next = n + 1 } return updated }
24	func ( pr * Progress ) IsPaused ( ) bool { switch pr . State { case ProgressStateProbe : return pr . Paused case ProgressStateReplicate : return pr . ins . full ( ) case ProgressStateSnapshot : return true default : panic ( "unexpected state" ) } }
25	func ( pr * Progress ) needSnapshotAbort ( ) bool { return pr . State == ProgressStateSnapshot && pr . Match >= pr . PendingSnapshot }
26	func ( in * inflights ) add ( inflight uint64 ) { if in . full ( ) { panic ( "cannot add into a full inflights" ) } next := in . start + in . count size := in . size if next >= size { next -= size } if next >= len ( in . buffer ) { in . growBuf ( ) } in . buffer [ next ] = inflight in . count ++ }
27	func ( in * inflights ) growBuf ( ) { newSize := len ( in . buffer ) * 2 if newSize == 0 { newSize = 1 } else if newSize > in . size { newSize = in . size } newBuffer := make ( [ ] uint64 , newSize ) copy ( newBuffer , in . buffer ) in . buffer = newBuffer }
28	func ( in * inflights ) freeTo ( to uint64 ) { if in . count == 0 || to < in . buffer [ in . start ] { return } idx := in . start var i int for i = 0 ; i < in . count ; i ++ { if to < in . buffer [ idx ] { break } size := in . size if idx ++ ; idx >= size { idx -= size } } in . count -= i in . start = idx if in . count == 0 { in . start = 0 } }
29	func ( s * Snapshotter ) SaveDBFrom ( r io . Reader , id uint64 ) ( int64 , error ) { start := time . Now ( ) f , err := ioutil . TempFile ( s . dir , "tmp" ) if err != nil { return 0 , err } var n int64 n , err = io . Copy ( f , r ) if err == nil { fsyncStart := time . Now ( ) err = fileutil . Fsync ( f ) snapDBFsyncSec . Observe ( time . Since ( fsyncStart ) . Seconds ( ) ) } f . Close ( ) if err != nil { os . Remove ( f . Name ( ) ) return n , err } fn := s . dbFilePath ( id ) if fileutil . Exist ( fn ) { os . Remove ( f . Name ( ) ) return n , nil } err = os . Rename ( f . Name ( ) , fn ) if err != nil { os . Remove ( f . Name ( ) ) return n , err } if s . lg != nil { s . lg . Info ( "saved database snapshot to disk" , zap . String ( "path" , fn ) , zap . Int64 ( "bytes" , n ) , zap . String ( "size" , humanize . Bytes ( uint64 ( n ) ) ) , ) } else { plog . Infof ( "saved database snapshot to disk [total bytes: %d]" , n ) } snapDBSaveSec . Observe ( time . Since ( start ) . Seconds ( ) ) return n , nil }
30	func ( s * Snapshotter ) DBFilePath ( id uint64 ) ( string , error ) { if _ , err := fileutil . ReadDir ( s . dir ) ; err != nil { return "" , err } fn := s . dbFilePath ( id ) if fileutil . Exist ( fn ) { return fn , nil } if s . lg != nil { s . lg . Warn ( "failed to find [SNAPSHOT-INDEX].snap.db" , zap . Uint64 ( "snapshot-index" , id ) , zap . String ( "snapshot-file-path" , fn ) , zap . Error ( ErrNoDBSnapshot ) , ) } return "" , ErrNoDBSnapshot }
31	func ( us * UniqueStringsValue ) Set ( s string ) error { us . Values = make ( map [ string ] struct { } ) for _ , v := range strings . Split ( s , "," ) { us . Values [ v ] = struct { } { } } return nil }
32	func NewUniqueStringsValue ( s string ) ( us * UniqueStringsValue ) { us = & UniqueStringsValue { Values : make ( map [ string ] struct { } ) } if s == "" { return us } if err := us . Set ( s ) ; err != nil { plog . Panicf ( "new UniqueStringsValue should never fail: %v" , err ) } return us }
33	func UniqueStringsFromFlag ( fs * flag . FlagSet , flagName string ) [ ] string { return ( * fs . Lookup ( flagName ) . Value . ( * UniqueStringsValue ) ) . stringSlice ( ) }
34	func UniqueStringsMapFromFlag ( fs * flag . FlagSet , flagName string ) map [ string ] struct { } { return ( * fs . Lookup ( flagName ) . Value . ( * UniqueStringsValue ) ) . Values }
35	func Percentiles ( nums [ ] float64 ) ( pcs [ ] float64 , data [ ] float64 ) { return pctls , percentiles ( nums ) }
36	func ( c * ServerConfig ) VerifyBootstrap ( ) error { if err := c . hasLocalMember ( ) ; err != nil { return err } if err := c . advertiseMatchesCluster ( ) ; err != nil { return err } if checkDuplicateURL ( c . InitialPeerURLsMap ) { return fmt . Errorf ( "initial cluster %s has duplicate url" , c . InitialPeerURLsMap ) } if c . InitialPeerURLsMap . String ( ) == "" && c . DiscoveryURL == "" { return fmt . Errorf ( "initial cluster unset and no discovery URL found" ) } return nil }
37	func ( c * ServerConfig ) VerifyJoinExisting ( ) error { if err := c . hasLocalMember ( ) ; err != nil { return err } if checkDuplicateURL ( c . InitialPeerURLsMap ) { return fmt . Errorf ( "initial cluster %s has duplicate url" , c . InitialPeerURLsMap ) } if c . DiscoveryURL != "" { return fmt . Errorf ( "discovery URL should not be set when joining existing initial cluster" ) } return nil }
38	func ( c * ServerConfig ) hasLocalMember ( ) error { if urls := c . InitialPeerURLsMap [ c . Name ] ; urls == nil { return fmt . Errorf ( "couldn't find local name %q in the initial cluster configuration" , c . Name ) } return nil }
39	func ( c * ServerConfig ) advertiseMatchesCluster ( ) error { urls , apurls := c . InitialPeerURLsMap [ c . Name ] , c . PeerURLs . StringSlice ( ) urls . Sort ( ) sort . Strings ( apurls ) ctx , cancel := context . WithTimeout ( context . TODO ( ) , 30 * time . Second ) defer cancel ( ) ok , err := netutil . URLStringsEqual ( ctx , c . Logger , apurls , urls . StringSlice ( ) ) if ok { return nil } initMap , apMap := make ( map [ string ] struct { } ) , make ( map [ string ] struct { } ) for _ , url := range c . PeerURLs { apMap [ url . String ( ) ] = struct { } { } } for _ , url := range c . InitialPeerURLsMap [ c . Name ] { initMap [ url . String ( ) ] = struct { } { } } missing := [ ] string { } for url := range initMap { if _ , ok := apMap [ url ] ; ! ok { missing = append ( missing , url ) } } if len ( missing ) > 0 { for i := range missing { missing [ i ] = c . Name + "=" + missing [ i ] } mstr := strings . Join ( missing , "," ) apStr := strings . Join ( apurls , "," ) return fmt . Errorf ( "--initial-cluster has %s but missing from --initial-advertise-peer-urls=%s (%v)" , mstr , apStr , err ) } for url := range apMap { if _ , ok := initMap [ url ] ; ! ok { missing = append ( missing , url ) } } if len ( missing ) > 0 { mstr := strings . Join ( missing , "," ) umap := types . URLsMap ( map [ string ] types . URLs { c . Name : c . PeerURLs } ) return fmt . Errorf ( "--initial-advertise-peer-urls has %s but missing from --initial-cluster=%s" , mstr , umap . String ( ) ) } apStr := strings . Join ( apurls , "," ) umap := types . URLsMap ( map [ string ] types . URLs { c . Name : c . PeerURLs } ) return fmt . Errorf ( "failed to resolve %s to match --initial-cluster=%s (%v)" , apStr , umap . String ( ) , err ) }
40	func ( c * ServerConfig ) ReqTimeout ( ) time . Duration { return 5 * time . Second + 2 * time . Duration ( c . ElectionTicks * int ( c . TickMs ) ) * time . Millisecond }
41	func getStatus ( r * raft ) Status { s := getStatusWithoutProgress ( r ) if s . RaftState == StateLeader { s . Progress = getProgressCopy ( r ) } return s }
42	func GetDefaultHost ( ) ( string , error ) { rmsgs , rerr := getDefaultRoutes ( ) if rerr != nil { return "" , rerr } if rmsg , ok := rmsgs [ syscall . AF_INET ] ; ok { if host , err := chooseHost ( syscall . AF_INET , rmsg ) ; host != "" || err != nil { return host , err } delete ( rmsgs , syscall . AF_INET ) } var families [ ] int for family := range rmsgs { families = append ( families , int ( family ) ) } sort . Ints ( families ) for _ , f := range families { family := uint8 ( f ) if host , err := chooseHost ( family , rmsgs [ family ] ) ; host != "" || err != nil { return host , err } } return "" , errNoDefaultHost }
43	func getIfaceAddr ( idx uint32 , family uint8 ) ( * syscall . NetlinkMessage , error ) { dat , err := syscall . NetlinkRIB ( syscall . RTM_GETADDR , int ( family ) ) if err != nil { return nil , err } msgs , msgErr := syscall . ParseNetlinkMessage ( dat ) if msgErr != nil { return nil , msgErr } ifaddrmsg := syscall . IfAddrmsg { } for _ , m := range msgs { if m . Header . Type != syscall . RTM_NEWADDR { continue } buf := bytes . NewBuffer ( m . Data [ : syscall . SizeofIfAddrmsg ] ) if rerr := binary . Read ( buf , cpuutil . ByteOrder ( ) , & ifaddrmsg ) ; rerr != nil { continue } if ifaddrmsg . Index == idx { return & m , nil } } return nil , fmt . Errorf ( "could not find address for interface index %v" , idx ) }
44	func getIfaceLink ( idx uint32 ) ( * syscall . NetlinkMessage , error ) { dat , err := syscall . NetlinkRIB ( syscall . RTM_GETLINK , syscall . AF_UNSPEC ) if err != nil { return nil , err } msgs , msgErr := syscall . ParseNetlinkMessage ( dat ) if msgErr != nil { return nil , msgErr } ifinfomsg := syscall . IfInfomsg { } for _ , m := range msgs { if m . Header . Type != syscall . RTM_NEWLINK { continue } buf := bytes . NewBuffer ( m . Data [ : syscall . SizeofIfInfomsg ] ) if rerr := binary . Read ( buf , cpuutil . ByteOrder ( ) , & ifinfomsg ) ; rerr != nil { continue } if ifinfomsg . Index == int32 ( idx ) { return & m , nil } } return nil , fmt . Errorf ( "could not find link for interface index %v" , idx ) }
45	func lsCommandFunc ( c * cli . Context , ki client . KeysAPI ) { key := "/" if len ( c . Args ( ) ) != 0 { key = c . Args ( ) [ 0 ] } sort := c . Bool ( "sort" ) recursive := c . Bool ( "recursive" ) quorum := c . Bool ( "quorum" ) ctx , cancel := contextWithTotalTimeout ( c ) resp , err := ki . Get ( ctx , key , & client . GetOptions { Sort : sort , Recursive : recursive , Quorum : quorum } ) cancel ( ) if err != nil { handleError ( c , ExitServerError , err ) } printLs ( c , resp ) }
46	func printLs ( c * cli . Context , resp * client . Response ) { if c . GlobalString ( "output" ) == "simple" { if ! resp . Node . Dir { fmt . Println ( resp . Node . Key ) } for _ , node := range resp . Node . Nodes { rPrint ( c , node ) } } else { printResponseKey ( resp , c . GlobalString ( "output" ) ) } }
47	func rPrint ( c * cli . Context , n * client . Node ) { if n . Dir && c . Bool ( "p" ) { fmt . Println ( fmt . Sprintf ( "%v/" , n . Key ) ) } else { fmt . Println ( n . Key ) } for _ , node := range n . Nodes { rPrint ( c , node ) } }
48	func NewLeaseRenewerCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "lease-renewer" , Short : "Performs lease renew operation" , Run : runLeaseRenewerFunc , } cmd . Flags ( ) . Int64Var ( & leaseTTL , "ttl" , 5 , "lease's ttl" ) return cmd }
49	func Read ( lg * zap . Logger , snapname string ) ( * raftpb . Snapshot , error ) { b , err := ioutil . ReadFile ( snapname ) if err != nil { if lg != nil { lg . Warn ( "failed to read a snap file" , zap . String ( "path" , snapname ) , zap . Error ( err ) ) } else { plog . Errorf ( "cannot read file %v: %v" , snapname , err ) } return nil , err } if len ( b ) == 0 { if lg != nil { lg . Warn ( "failed to read empty snapshot file" , zap . String ( "path" , snapname ) ) } else { plog . Errorf ( "unexpected empty snapshot" ) } return nil , ErrEmptySnapshot } var serializedSnap snappb . Snapshot if err = serializedSnap . Unmarshal ( b ) ; err != nil { if lg != nil { lg . Warn ( "failed to unmarshal snappb.Snapshot" , zap . String ( "path" , snapname ) , zap . Error ( err ) ) } else { plog . Errorf ( "corrupted snapshot file %v: %v" , snapname , err ) } return nil , err } if len ( serializedSnap . Data ) == 0 || serializedSnap . Crc == 0 { if lg != nil { lg . Warn ( "failed to read empty snapshot data" , zap . String ( "path" , snapname ) ) } else { plog . Errorf ( "unexpected empty snapshot" ) } return nil , ErrEmptySnapshot } crc := crc32 . Update ( 0 , crcTable , serializedSnap . Data ) if crc != serializedSnap . Crc { if lg != nil { lg . Warn ( "snap file is corrupt" , zap . String ( "path" , snapname ) , zap . Uint32 ( "prev-crc" , serializedSnap . Crc ) , zap . Uint32 ( "new-crc" , crc ) , ) } else { plog . Errorf ( "corrupted snapshot file %v: crc mismatch" , snapname ) } return nil , ErrCRCMismatch } var snap raftpb . Snapshot if err = snap . Unmarshal ( serializedSnap . Data ) ; err != nil { if lg != nil { lg . Warn ( "failed to unmarshal raftpb.Snapshot" , zap . String ( "path" , snapname ) , zap . Error ( err ) ) } else { plog . Errorf ( "corrupted snapshot file %v: %v" , snapname , err ) } return nil , err } return & snap , nil }
50	func GetCipherSuite ( s string ) ( uint16 , bool ) { v , ok := cipherSuites [ s ] return v , ok }
51	func ( p * pipeline ) post ( data [ ] byte ) ( err error ) { u := p . picker . pick ( ) req := createPostRequest ( u , RaftPrefix , bytes . NewBuffer ( data ) , "application/protobuf" , p . tr . URLs , p . tr . ID , p . tr . ClusterID ) done := make ( chan struct { } , 1 ) ctx , cancel := context . WithCancel ( context . Background ( ) ) req = req . WithContext ( ctx ) go func ( ) { select { case <- done : case <- p . stopc : waitSchedule ( ) cancel ( ) } } ( ) resp , err := p . tr . pipelineRt . RoundTrip ( req ) done <- struct { } { } if err != nil { p . picker . unreachable ( u ) return err } defer resp . Body . Close ( ) b , err := ioutil . ReadAll ( resp . Body ) if err != nil { p . picker . unreachable ( u ) return err } err = checkPostResponse ( resp , b , req , p . peerID ) if err != nil { p . picker . unreachable ( u ) if err == errMemberRemoved { reportCriticalError ( err , p . errorc ) } return err } return nil }
52	func ( r * raft ) send ( m pb . Message ) { m . From = r . id if m . Type == pb . MsgVote || m . Type == pb . MsgVoteResp || m . Type == pb . MsgPreVote || m . Type == pb . MsgPreVoteResp { if m . Term == 0 { panic ( fmt . Sprintf ( "term should be set when sending %s" , m . Type ) ) } } else { if m . Term != 0 { panic ( fmt . Sprintf ( "term should not be set when sending %s (was %d)" , m . Type , m . Term ) ) } if m . Type != pb . MsgProp && m . Type != pb . MsgReadIndex { m . Term = r . Term } } r . msgs = append ( r . msgs , m ) }
53	func ( r * raft ) sendHeartbeat ( to uint64 , ctx [ ] byte ) { commit := min ( r . getProgress ( to ) . Match , r . raftLog . committed ) m := pb . Message { To : to , Type : pb . MsgHeartbeat , Commit : commit , Context : ctx , } r . send ( m ) }
54	func ( r * raft ) bcastAppend ( ) { r . forEachProgress ( func ( id uint64 , _ * Progress ) { if id == r . id { return } r . sendAppend ( id ) } ) }
55	func ( r * raft ) bcastHeartbeat ( ) { lastCtx := r . readOnly . lastPendingRequestCtx ( ) if len ( lastCtx ) == 0 { r . bcastHeartbeatWithCtx ( nil ) } else { r . bcastHeartbeatWithCtx ( [ ] byte ( lastCtx ) ) } }
56	func ( r * raft ) tickElection ( ) { r . electionElapsed ++ if r . promotable ( ) && r . pastElectionTimeout ( ) { r . electionElapsed = 0 r . Step ( pb . Message { From : r . id , Type : pb . MsgHup } ) } }
57	func ( r * raft ) tickHeartbeat ( ) { r . heartbeatElapsed ++ r . electionElapsed ++ if r . electionElapsed >= r . electionTimeout { r . electionElapsed = 0 if r . checkQuorum { r . Step ( pb . Message { From : r . id , Type : pb . MsgCheckQuorum } ) } if r . state == StateLeader && r . leadTransferee != None { r . abortLeaderTransfer ( ) } } if r . state != StateLeader { return } if r . heartbeatElapsed >= r . heartbeatTimeout { r . heartbeatElapsed = 0 r . Step ( pb . Message { From : r . id , Type : pb . MsgBeat } ) } }
58	func stepCandidate ( r * raft , m pb . Message ) error { var myVoteRespType pb . MessageType if r . state == StatePreCandidate { myVoteRespType = pb . MsgPreVoteResp } else { myVoteRespType = pb . MsgVoteResp } switch m . Type { case pb . MsgProp : r . logger . Infof ( "%x no leader at term %d; dropping proposal" , r . id , r . Term ) return ErrProposalDropped case pb . MsgApp : r . becomeFollower ( m . Term , m . From ) r . handleAppendEntries ( m ) case pb . MsgHeartbeat : r . becomeFollower ( m . Term , m . From ) r . handleHeartbeat ( m ) case pb . MsgSnap : r . becomeFollower ( m . Term , m . From ) r . handleSnapshot ( m ) case myVoteRespType : gr := r . poll ( m . From , m . Type , ! m . Reject ) r . logger . Infof ( "%x [quorum:%d] has received %d %s votes and %d vote rejections" , r . id , r . quorum ( ) , gr , m . Type , len ( r . votes ) - gr ) switch r . quorum ( ) { case gr : if r . state == StatePreCandidate { r . campaign ( campaignElection ) } else { r . becomeLeader ( ) r . bcastAppend ( ) } case len ( r . votes ) - gr : r . becomeFollower ( r . Term , None ) } case pb . MsgTimeoutNow : r . logger . Debugf ( "%x [term %d state %v] ignored MsgTimeoutNow from %x" , r . id , r . Term , r . state , m . From ) } return nil }
59	func ( r * raft ) restore ( s pb . Snapshot ) bool { if s . Metadata . Index <= r . raftLog . committed { return false } if r . raftLog . matchTerm ( s . Metadata . Index , s . Metadata . Term ) { r . logger . Infof ( "%x [commit: %d, lastindex: %d, lastterm: %d] fast-forwarded commit to snapshot [index: %d, term: %d]" , r . id , r . raftLog . committed , r . raftLog . lastIndex ( ) , r . raftLog . lastTerm ( ) , s . Metadata . Index , s . Metadata . Term ) r . raftLog . commitTo ( s . Metadata . Index ) return false } if ! r . isLearner { for _ , id := range s . Metadata . ConfState . Learners { if id == r . id { r . logger . Errorf ( "%x can't become learner when restores snapshot [index: %d, term: %d]" , r . id , s . Metadata . Index , s . Metadata . Term ) return false } } } r . logger . Infof ( "%x [commit: %d, lastindex: %d, lastterm: %d] starts to restore snapshot [index: %d, term: %d]" , r . id , r . raftLog . committed , r . raftLog . lastIndex ( ) , r . raftLog . lastTerm ( ) , s . Metadata . Index , s . Metadata . Term ) r . raftLog . restore ( s ) r . prs = make ( map [ uint64 ] * Progress ) r . learnerPrs = make ( map [ uint64 ] * Progress ) r . restoreNode ( s . Metadata . ConfState . Nodes , false ) r . restoreNode ( s . Metadata . ConfState . Learners , true ) return true }
60	func ( r * raft ) promotable ( ) bool { _ , ok := r . prs [ r . id ] return ok }
61	func ( r * raft ) checkQuorumActive ( ) bool { var act int r . forEachProgress ( func ( id uint64 , pr * Progress ) { if id == r . id { act ++ return } if pr . RecentActive && ! pr . IsLearner { act ++ } pr . RecentActive = false } ) return act >= r . quorum ( ) }
62	func ( r * raft ) increaseUncommittedSize ( ents [ ] pb . Entry ) bool { var s uint64 for _ , e := range ents { s += uint64 ( PayloadSize ( e ) ) } if r . uncommittedSize > 0 && r . uncommittedSize + s > r . maxUncommittedSize { return false } r . uncommittedSize += s return true }
63	func ( r * raft ) reduceUncommittedSize ( ents [ ] pb . Entry ) { if r . uncommittedSize == 0 { return } var s uint64 for _ , e := range ents { s += uint64 ( PayloadSize ( e ) ) } if s > r . uncommittedSize { r . uncommittedSize = 0 } else { r . uncommittedSize -= s } }
64	func newPeriodic ( lg * zap . Logger , clock clockwork . Clock , h time . Duration , rg RevGetter , c Compactable ) * Periodic { pc := & Periodic { lg : lg , clock : clock , period : h , rg : rg , c : c , revs : make ( [ ] int64 , 0 ) , } pc . ctx , pc . cancel = context . WithCancel ( context . Background ( ) ) return pc }
65	func ( pc * Periodic ) Pause ( ) { pc . mu . Lock ( ) pc . paused = true pc . mu . Unlock ( ) }
66	func ( pc * Periodic ) Resume ( ) { pc . mu . Lock ( ) pc . paused = false pc . mu . Unlock ( ) }
67	func ( m * Mutex ) Lock ( ctx context . Context ) error { s := m . s client := m . s . Client ( ) m . myKey = fmt . Sprintf ( "%s%x" , m . pfx , s . Lease ( ) ) cmp := v3 . Compare ( v3 . CreateRevision ( m . myKey ) , "=" , 0 ) put := v3 . OpPut ( m . myKey , "" , v3 . WithLease ( s . Lease ( ) ) ) get := v3 . OpGet ( m . myKey ) getOwner := v3 . OpGet ( m . pfx , v3 . WithFirstCreate ( ) ... ) resp , err := client . Txn ( ctx ) . If ( cmp ) . Then ( put , getOwner ) . Else ( get , getOwner ) . Commit ( ) if err != nil { return err } m . myRev = resp . Header . Revision if ! resp . Succeeded { m . myRev = resp . Responses [ 0 ] . GetResponseRange ( ) . Kvs [ 0 ] . CreateRevision } ownerKey := resp . Responses [ 1 ] . GetResponseRange ( ) . Kvs if len ( ownerKey ) == 0 || ownerKey [ 0 ] . CreateRevision == m . myRev { m . hdr = resp . Header return nil } hdr , werr := waitDeletes ( ctx , client , m . pfx , m . myRev - 1 ) if werr != nil { m . Unlock ( client . Ctx ( ) ) } else { m . hdr = hdr } return werr }
68	func NewLocker ( s * Session , pfx string ) sync . Locker { return & lockerMutex { NewMutex ( s , pfx ) } }
69	func NewFIFOScheduler ( ) Scheduler { f := & fifo { resume : make ( chan struct { } , 1 ) , donec : make ( chan struct { } , 1 ) , } f . finishCond = sync . NewCond ( & f . mu ) f . ctx , f . cancel = context . WithCancel ( context . Background ( ) ) go f . run ( ) return f }
70	func ( f * fifo ) Schedule ( j Job ) { f . mu . Lock ( ) defer f . mu . Unlock ( ) if f . cancel == nil { panic ( "schedule: schedule to stopped scheduler" ) } if len ( f . pendings ) == 0 { select { case f . resume <- struct { } { } : default : } } f . pendings = append ( f . pendings , j ) }
71	func ( f * fifo ) Stop ( ) { f . mu . Lock ( ) f . cancel ( ) f . cancel = nil f . mu . Unlock ( ) <- f . donec }
72	func NewServer ( lg * zap . Logger , network string , address string , ) * Server { return & Server { lg : lg , network : network , address : address , last : rpcpb . Operation_NOT_STARTED , advertiseClientPortToProxy : make ( map [ int ] proxy . Server ) , advertisePeerPortToProxy : make ( map [ int ] proxy . Server ) , } }
73	func ( srv * Server ) StartServe ( ) error { var err error srv . ln , err = net . Listen ( srv . network , srv . address ) if err != nil { return err } var opts [ ] grpc . ServerOption opts = append ( opts , grpc . MaxRecvMsgSize ( int ( maxRequestBytes + grpcOverheadBytes ) ) ) opts = append ( opts , grpc . MaxSendMsgSize ( maxSendBytes ) ) opts = append ( opts , grpc . MaxConcurrentStreams ( maxStreams ) ) srv . grpcServer = grpc . NewServer ( opts ... ) rpcpb . RegisterTransportServer ( srv . grpcServer , srv ) srv . lg . Info ( "gRPC server started" , zap . String ( "address" , srv . address ) , zap . String ( "listener-address" , srv . ln . Addr ( ) . String ( ) ) , ) err = srv . grpcServer . Serve ( srv . ln ) if err != nil && strings . Contains ( err . Error ( ) , "use of closed network connection" ) { srv . lg . Info ( "gRPC server is shut down" , zap . String ( "address" , srv . address ) , zap . Error ( err ) , ) } else { srv . lg . Warn ( "gRPC server returned with error" , zap . String ( "address" , srv . address ) , zap . Error ( err ) , ) } return err }
74	func ( srv * Server ) Stop ( ) { srv . lg . Info ( "gRPC server stopping" , zap . String ( "address" , srv . address ) ) srv . grpcServer . Stop ( ) srv . lg . Info ( "gRPC server stopped" , zap . String ( "address" , srv . address ) ) }
75	func ( srv * Server ) Transport ( stream rpcpb . Transport_TransportServer ) ( err error ) { errc := make ( chan error ) go func ( ) { for { var req * rpcpb . Request req , err = stream . Recv ( ) if err != nil { errc <- err return } if req . Member != nil { srv . Member = req . Member } if req . Tester != nil { srv . Tester = req . Tester } var resp * rpcpb . Response resp , err = srv . handleTesterRequest ( req ) if err != nil { errc <- err return } if err = stream . Send ( resp ) ; err != nil { errc <- err return } } } ( ) select { case err = <- errc : case <- stream . Context ( ) . Done ( ) : err = stream . Context ( ) . Err ( ) } return err }
76	func RegisterInterruptHandler ( h InterruptHandler ) { interruptRegisterMu . Lock ( ) defer interruptRegisterMu . Unlock ( ) interruptHandlers = append ( interruptHandlers , h ) }
77	func HandleInterrupts ( lg * zap . Logger ) { notifier := make ( chan os . Signal , 1 ) signal . Notify ( notifier , syscall . SIGINT , syscall . SIGTERM ) go func ( ) { sig := <- notifier interruptRegisterMu . Lock ( ) ihs := make ( [ ] InterruptHandler , len ( interruptHandlers ) ) copy ( ihs , interruptHandlers ) interruptRegisterMu . Unlock ( ) interruptExitMu . Lock ( ) if lg != nil { lg . Info ( "received signal; shutting down" , zap . String ( "signal" , sig . String ( ) ) ) } else { plog . Noticef ( "received %v signal, shutting down..." , sig ) } for _ , h := range ihs { h ( ) } signal . Stop ( notifier ) pid := syscall . Getpid ( ) if pid == 1 { os . Exit ( 0 ) } setDflSignal ( sig . ( syscall . Signal ) ) syscall . Kill ( pid , sig . ( syscall . Signal ) ) } ( ) }
78	func OpGet ( key string , opts ... OpOption ) Op { if isWithPrefix ( opts ) && isWithFromKey ( opts ) { panic ( "`WithPrefix` and `WithFromKey` cannot be set at the same time, choose one" ) } ret := Op { t : tRange , key : [ ] byte ( key ) } ret . applyOpts ( opts ) return ret }
79	func OpDelete ( key string , opts ... OpOption ) Op { if isWithPrefix ( opts ) && isWithFromKey ( opts ) { panic ( "`WithPrefix` and `WithFromKey` cannot be set at the same time, choose one" ) } ret := Op { t : tDeleteRange , key : [ ] byte ( key ) } ret . applyOpts ( opts ) switch { case ret . leaseID != 0 : panic ( "unexpected lease in delete" ) case ret . limit != 0 : panic ( "unexpected limit in delete" ) case ret . rev != 0 : panic ( "unexpected revision in delete" ) case ret . sort != nil : panic ( "unexpected sort in delete" ) case ret . serializable : panic ( "unexpected serializable in delete" ) case ret . countOnly : panic ( "unexpected countOnly in delete" ) case ret . minModRev != 0 , ret . maxModRev != 0 : panic ( "unexpected mod revision filter in delete" ) case ret . minCreateRev != 0 , ret . maxCreateRev != 0 : panic ( "unexpected create revision filter in delete" ) case ret . filterDelete , ret . filterPut : panic ( "unexpected filter in delete" ) case ret . createdNotify : panic ( "unexpected createdNotify in delete" ) } return ret }
80	func OpPut ( key , val string , opts ... OpOption ) Op { ret := Op { t : tPut , key : [ ] byte ( key ) , val : [ ] byte ( val ) } ret . applyOpts ( opts ) switch { case ret . end != nil : panic ( "unexpected range in put" ) case ret . limit != 0 : panic ( "unexpected limit in put" ) case ret . rev != 0 : panic ( "unexpected revision in put" ) case ret . sort != nil : panic ( "unexpected sort in put" ) case ret . serializable : panic ( "unexpected serializable in put" ) case ret . countOnly : panic ( "unexpected countOnly in put" ) case ret . minModRev != 0 , ret . maxModRev != 0 : panic ( "unexpected mod revision filter in put" ) case ret . minCreateRev != 0 , ret . maxCreateRev != 0 : panic ( "unexpected create revision filter in put" ) case ret . filterDelete , ret . filterPut : panic ( "unexpected filter in put" ) case ret . createdNotify : panic ( "unexpected createdNotify in put" ) } return ret }
81	func OpTxn ( cmps [ ] Cmp , thenOps [ ] Op , elseOps [ ] Op ) Op { return Op { t : tTxn , cmps : cmps , thenOps : thenOps , elseOps : elseOps } }
82	func WithFromKey ( ) OpOption { return func ( op * Op ) { if len ( op . key ) == 0 { op . key = [ ] byte { 0 } } op . end = [ ] byte ( "\x00" ) } }
83	func withTop ( target SortTarget , order SortOrder ) [ ] OpOption { return [ ] OpOption { WithPrefix ( ) , WithSort ( target , order ) , WithLimit ( 1 ) } }
84	func Exist ( dir string ) bool { names , err := fileutil . ReadDir ( dir , fileutil . WithExt ( ".wal" ) ) if err != nil { return false } return len ( names ) != 0 }
85	func searchIndex ( lg * zap . Logger , names [ ] string , index uint64 ) ( int , bool ) { for i := len ( names ) - 1 ; i >= 0 ; i -- { name := names [ i ] _ , curIndex , err := parseWALName ( name ) if err != nil { if lg != nil { lg . Panic ( "failed to parse WAL file name" , zap . String ( "path" , name ) , zap . Error ( err ) ) } else { plog . Panicf ( "parse correct name should never fail: %v" , err ) } } if index >= curIndex { return i , true } } return - 1 , false }
86	func isValidSeq ( lg * zap . Logger , names [ ] string ) bool { var lastSeq uint64 for _ , name := range names { curSeq , _ , err := parseWALName ( name ) if err != nil { if lg != nil { lg . Panic ( "failed to parse WAL file name" , zap . String ( "path" , name ) , zap . Error ( err ) ) } else { plog . Panicf ( "parse correct name should never fail: %v" , err ) } } if lastSeq != 0 && lastSeq != curSeq - 1 { return false } lastSeq = curSeq } return true }
87	func NewListener ( addr , scheme string , tlsinfo * TLSInfo ) ( l net . Listener , err error ) { if l , err = newListener ( addr , scheme ) ; err != nil { return nil , err } return wrapTLS ( scheme , tlsinfo , l ) }
88	func ( info TLSInfo ) cafiles ( ) [ ] string { cs := make ( [ ] string , 0 ) if info . TrustedCAFile != "" { cs = append ( cs , info . TrustedCAFile ) } return cs }
89	func ( info TLSInfo ) ServerConfig ( ) ( * tls . Config , error ) { cfg , err := info . baseConfig ( ) if err != nil { return nil , err } cfg . ClientAuth = tls . NoClientCert if info . TrustedCAFile != "" || info . ClientCertAuth { cfg . ClientAuth = tls . RequireAndVerifyClientCert } cs := info . cafiles ( ) if len ( cs ) > 0 { cp , err := tlsutil . NewCertPool ( cs ) if err != nil { return nil , err } cfg . ClientCAs = cp } cfg . NextProtos = [ ] string { "h2" } return cfg , nil }
90	func ( info TLSInfo ) ClientConfig ( ) ( * tls . Config , error ) { var cfg * tls . Config var err error if ! info . Empty ( ) { cfg , err = info . baseConfig ( ) if err != nil { return nil , err } } else { cfg = & tls . Config { ServerName : info . ServerName } } cfg . InsecureSkipVerify = info . InsecureSkipVerify cs := info . cafiles ( ) if len ( cs ) > 0 { cfg . RootCAs , err = tlsutil . NewCertPool ( cs ) if err != nil { return nil , err } } if info . selfCert { cfg . InsecureSkipVerify = true } if info . EmptyCN { hasNonEmptyCN := false cn := "" tlsutil . NewCert ( info . CertFile , info . KeyFile , func ( certPEMBlock [ ] byte , keyPEMBlock [ ] byte ) ( tls . Certificate , error ) { var block * pem . Block block , _ = pem . Decode ( certPEMBlock ) cert , err := x509 . ParseCertificate ( block . Bytes ) if err != nil { return tls . Certificate { } , err } if len ( cert . Subject . CommonName ) != 0 { hasNonEmptyCN = true cn = cert . Subject . CommonName } return tls . X509KeyPair ( certPEMBlock , keyPEMBlock ) } ) if hasNonEmptyCN { return nil , fmt . Errorf ( "cert has non empty Common Name (%s)" , cn ) } } return cfg , nil }
91	func newTLSKeepaliveListener ( inner net . Listener , config * tls . Config ) net . Listener { l := & tlsKeepaliveListener { } l . Listener = inner l . config = config return l }
92	func ( s * EtcdServer ) applyV2Request ( r * RequestV2 ) Response { defer warnOfExpensiveRequest ( s . getLogger ( ) , time . Now ( ) , r , nil , nil ) switch r . Method { case "POST" : return s . applyV2 . Post ( r ) case "PUT" : return s . applyV2 . Put ( r ) case "DELETE" : return s . applyV2 . Delete ( r ) case "QGET" : return s . applyV2 . QGet ( r ) case "SYNC" : return s . applyV2 . Sync ( r ) default : return Response { Err : ErrUnknownMethod } } }
93	func NewRoleCommand ( ) * cobra . Command { ac := & cobra . Command { Use : "role <subcommand>" , Short : "Role related commands" , } ac . AddCommand ( newRoleAddCommand ( ) ) ac . AddCommand ( newRoleDeleteCommand ( ) ) ac . AddCommand ( newRoleGetCommand ( ) ) ac . AddCommand ( newRoleListCommand ( ) ) ac . AddCommand ( newRoleGrantPermissionCommand ( ) ) ac . AddCommand ( newRoleRevokePermissionCommand ( ) ) return ac }
94	func roleAddCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 1 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "role add command requires role name as its argument" ) ) } resp , err := mustClientFromCmd ( cmd ) . Auth . RoleAdd ( context . TODO ( ) , args [ 0 ] ) if err != nil { ExitWithError ( ExitError , err ) } display . RoleAdd ( args [ 0 ] , * resp ) }
95	func roleGetCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 1 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "role get command requires role name as its argument" ) ) } name := args [ 0 ] resp , err := mustClientFromCmd ( cmd ) . Auth . RoleGet ( context . TODO ( ) , name ) if err != nil { ExitWithError ( ExitError , err ) } display . RoleGet ( name , * resp ) }
96	func roleGrantPermissionCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) < 3 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "role grant command requires role name, permission type, and key [endkey] as its argument" ) ) } perm , err := clientv3 . StrToPermissionType ( args [ 1 ] ) if err != nil { ExitWithError ( ExitBadArgs , err ) } key , rangeEnd := permRange ( args [ 2 : ] ) resp , err := mustClientFromCmd ( cmd ) . Auth . RoleGrantPermission ( context . TODO ( ) , args [ 0 ] , key , rangeEnd , perm ) if err != nil { ExitWithError ( ExitError , err ) } display . RoleGrantPermission ( args [ 0 ] , * resp ) }
97	func roleRevokePermissionCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) < 2 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "role revoke-permission command requires role name and key [endkey] as its argument" ) ) } key , rangeEnd := permRange ( args [ 1 : ] ) resp , err := mustClientFromCmd ( cmd ) . Auth . RoleRevokePermission ( context . TODO ( ) , args [ 0 ] , key , rangeEnd ) if err != nil { ExitWithError ( ExitError , err ) } display . RoleRevokePermission ( args [ 0 ] , args [ 1 ] , rangeEnd , * resp ) }
98	func NewCluster ( t testing . TB , size int ) * cluster { return newCluster ( t , & ClusterConfig { Size : size } ) }
99	func NewClusterByConfig ( t testing . TB , cfg * ClusterConfig ) * cluster { return newCluster ( t , cfg ) }
100	func ( c * cluster ) HTTPMembers ( ) [ ] client . Member { ms := [ ] client . Member { } for _ , m := range c . Members { pScheme := schemeFromTLSInfo ( m . PeerTLSInfo ) cScheme := schemeFromTLSInfo ( m . ClientTLSInfo ) cm := client . Member { Name : m . Name } for _ , ln := range m . PeerListeners { cm . PeerURLs = append ( cm . PeerURLs , pScheme + "://" + ln . Addr ( ) . String ( ) ) } for _ , ln := range m . ClientListeners { cm . ClientURLs = append ( cm . ClientURLs , cScheme + "://" + ln . Addr ( ) . String ( ) ) } ms = append ( ms , cm ) } return ms }
101	func ( c * cluster ) waitLeader ( t testing . TB , membs [ ] * member ) int { possibleLead := make ( map [ uint64 ] bool ) var lead uint64 for _ , m := range membs { possibleLead [ uint64 ( m . s . ID ( ) ) ] = true } cc := MustNewHTTPClient ( t , getMembersURLs ( membs ) , nil ) kapi := client . NewKeysAPI ( cc ) for { ctx , cancel := context . WithTimeout ( context . Background ( ) , 10 * tickDuration + time . Second ) _ , err := kapi . Get ( ctx , "0" , & client . GetOptions { Quorum : true } ) cancel ( ) if err == nil || strings . Contains ( err . Error ( ) , "Key not found" ) { break } } for lead == 0 || ! possibleLead [ lead ] { lead = 0 for _ , m := range membs { select { case <- m . s . StopNotify ( ) : continue default : } if lead != 0 && lead != m . s . Lead ( ) { lead = 0 time . Sleep ( 10 * tickDuration ) break } lead = m . s . Lead ( ) } } for i , m := range membs { if uint64 ( m . s . ID ( ) ) == lead { return i } } return - 1 }
102	func ( c * cluster ) waitNoLeader ( membs [ ] * member ) { noLeader := false for ! noLeader { noLeader = true for _ , m := range membs { select { case <- m . s . StopNotify ( ) : continue default : } if m . s . Lead ( ) != 0 { noLeader = false time . Sleep ( 10 * tickDuration ) break } } } }
103	func isMembersEqual ( membs [ ] client . Member , wmembs [ ] client . Member ) bool { sort . Sort ( SortableMemberSliceByPeerURLs ( membs ) ) sort . Sort ( SortableMemberSliceByPeerURLs ( wmembs ) ) for i := range membs { membs [ i ] . ID = "" } return reflect . DeepEqual ( membs , wmembs ) }
104	func ( m * member ) listenGRPC ( ) error { m . grpcAddr = "localhost:" + m . Name if m . useIP { m . grpcAddr = "127.0.0.1:" + m . Name } l , err := transport . NewUnixListener ( m . grpcAddr ) if err != nil { return fmt . Errorf ( "listen failed on grpc socket %s (%v)" , m . grpcAddr , err ) } m . grpcBridge , err = newBridge ( m . grpcAddr ) if err != nil { l . Close ( ) return err } m . grpcAddr = schemeFromTLSInfo ( m . ClientTLSInfo ) + "://" + m . grpcBridge . inaddr m . grpcListener = l return nil }
105	func NewClientV3 ( m * member ) ( * clientv3 . Client , error ) { if m . grpcAddr == "" { return nil , fmt . Errorf ( "member not configured for grpc" ) } cfg := clientv3 . Config { Endpoints : [ ] string { m . grpcAddr } , DialTimeout : 5 * time . Second , DialOptions : [ ] grpc . DialOption { grpc . WithBlock ( ) } , MaxCallSendMsgSize : m . clientMaxCallSendMsgSize , MaxCallRecvMsgSize : m . clientMaxCallRecvMsgSize , } if m . ClientTLSInfo != nil { tls , err := m . ClientTLSInfo . ClientConfig ( ) if err != nil { return nil , err } cfg . TLS = tls } if m . DialOptions != nil { cfg . DialOptions = append ( cfg . DialOptions , m . DialOptions ... ) } return newClientV3 ( cfg ) }
106	func ( m * member ) Clone ( t testing . TB ) * member { mm := & member { } mm . ServerConfig = m . ServerConfig var err error clientURLStrs := m . ClientURLs . StringSlice ( ) mm . ClientURLs , err = types . NewURLs ( clientURLStrs ) if err != nil { panic ( err ) } peerURLStrs := m . PeerURLs . StringSlice ( ) mm . PeerURLs , err = types . NewURLs ( peerURLStrs ) if err != nil { panic ( err ) } clusterStr := m . InitialPeerURLsMap . String ( ) mm . InitialPeerURLsMap , err = types . NewURLsMap ( clusterStr ) if err != nil { panic ( err ) } mm . InitialClusterToken = m . InitialClusterToken mm . ElectionTicks = m . ElectionTicks mm . PeerTLSInfo = m . PeerTLSInfo mm . ClientTLSInfo = m . ClientTLSInfo return mm }
107	func ( m * member ) Close ( ) { if m . grpcBridge != nil { m . grpcBridge . Close ( ) m . grpcBridge = nil } if m . serverClient != nil { m . serverClient . Close ( ) m . serverClient = nil } if m . grpcServer != nil { m . grpcServer . Stop ( ) m . grpcServer . GracefulStop ( ) m . grpcServer = nil m . grpcServerPeer . Stop ( ) m . grpcServerPeer . GracefulStop ( ) m . grpcServerPeer = nil } m . s . HardStop ( ) for _ , f := range m . serverClosers { f ( ) } }
108	func ( m * member ) Stop ( t testing . TB ) { lg . Info ( "stopping a member" , zap . String ( "name" , m . Name ) , zap . Strings ( "advertise-peer-urls" , m . PeerURLs . StringSlice ( ) ) , zap . Strings ( "listen-client-urls" , m . ClientURLs . StringSlice ( ) ) , zap . String ( "grpc-address" , m . grpcAddr ) , ) m . Close ( ) m . serverClosers = nil lg . Info ( "stopped a member" , zap . String ( "name" , m . Name ) , zap . Strings ( "advertise-peer-urls" , m . PeerURLs . StringSlice ( ) ) , zap . Strings ( "listen-client-urls" , m . ClientURLs . StringSlice ( ) ) , zap . String ( "grpc-address" , m . grpcAddr ) , ) }
109	func checkLeaderTransition ( m * member , oldLead uint64 ) uint64 { interval := time . Duration ( m . s . Cfg . TickMs ) * time . Millisecond for m . s . Lead ( ) == 0 || ( m . s . Lead ( ) == oldLead ) { time . Sleep ( interval ) } return m . s . Lead ( ) }
110	func ( m * member ) Restart ( t testing . TB ) error { lg . Info ( "restarting a member" , zap . String ( "name" , m . Name ) , zap . Strings ( "advertise-peer-urls" , m . PeerURLs . StringSlice ( ) ) , zap . Strings ( "listen-client-urls" , m . ClientURLs . StringSlice ( ) ) , zap . String ( "grpc-address" , m . grpcAddr ) , ) newPeerListeners := make ( [ ] net . Listener , 0 ) for _ , ln := range m . PeerListeners { newPeerListeners = append ( newPeerListeners , NewListenerWithAddr ( t , ln . Addr ( ) . String ( ) ) ) } m . PeerListeners = newPeerListeners newClientListeners := make ( [ ] net . Listener , 0 ) for _ , ln := range m . ClientListeners { newClientListeners = append ( newClientListeners , NewListenerWithAddr ( t , ln . Addr ( ) . String ( ) ) ) } m . ClientListeners = newClientListeners if m . grpcListener != nil { if err := m . listenGRPC ( ) ; err != nil { t . Fatal ( err ) } } err := m . Launch ( ) lg . Info ( "restarted a member" , zap . String ( "name" , m . Name ) , zap . Strings ( "advertise-peer-urls" , m . PeerURLs . StringSlice ( ) ) , zap . Strings ( "listen-client-urls" , m . ClientURLs . StringSlice ( ) ) , zap . String ( "grpc-address" , m . grpcAddr ) , zap . Error ( err ) , ) return err }
111	func ( m * member ) Terminate ( t testing . TB ) { lg . Info ( "terminating a member" , zap . String ( "name" , m . Name ) , zap . Strings ( "advertise-peer-urls" , m . PeerURLs . StringSlice ( ) ) , zap . Strings ( "listen-client-urls" , m . ClientURLs . StringSlice ( ) ) , zap . String ( "grpc-address" , m . grpcAddr ) , ) m . Close ( ) if ! m . keepDataDirTerminate { if err := os . RemoveAll ( m . ServerConfig . DataDir ) ; err != nil { t . Fatal ( err ) } } lg . Info ( "terminated a member" , zap . String ( "name" , m . Name ) , zap . Strings ( "advertise-peer-urls" , m . PeerURLs . StringSlice ( ) ) , zap . Strings ( "listen-client-urls" , m . ClientURLs . StringSlice ( ) ) , zap . String ( "grpc-address" , m . grpcAddr ) , ) }
112	func ( m * member ) Metric ( metricName string ) ( string , error ) { cfgtls := transport . TLSInfo { } tr , err := transport . NewTimeoutTransport ( cfgtls , time . Second , time . Second , time . Second ) if err != nil { return "" , err } cli := & http . Client { Transport : tr } resp , err := cli . Get ( m . ClientURLs [ 0 ] . String ( ) + "/metrics" ) if err != nil { return "" , err } defer resp . Body . Close ( ) b , rerr := ioutil . ReadAll ( resp . Body ) if rerr != nil { return "" , rerr } lines := strings . Split ( string ( b ) , "\n" ) \n for _ , l := range lines { if strings . HasPrefix ( l , metricName ) { return strings . Split ( l , " " ) [ 1 ] , nil } } }
113	func ( m * member ) InjectPartition ( t testing . TB , others ... * member ) { for _ , other := range others { m . s . CutPeer ( other . s . ID ( ) ) other . s . CutPeer ( m . s . ID ( ) ) } }
114	func ( m * member ) RecoverPartition ( t testing . TB , others ... * member ) { for _ , other := range others { m . s . MendPeer ( other . s . ID ( ) ) other . s . MendPeer ( m . s . ID ( ) ) } }
115	func NewClusterV3 ( t testing . TB , cfg * ClusterConfig ) * ClusterV3 { cfg . UseGRPC = true if os . Getenv ( "CLIENT_DEBUG" ) != "" { clientv3 . SetLogger ( grpclog . NewLoggerV2WithVerbosity ( os . Stderr , os . Stderr , os . Stderr , 4 ) ) } clus := & ClusterV3 { cluster : NewClusterByConfig ( t , cfg ) , } clus . Launch ( t ) if ! cfg . SkipCreatingClient { for _ , m := range clus . Members { client , err := NewClientV3 ( m ) if err != nil { t . Fatalf ( "cannot create client: %v" , err ) } clus . clients = append ( clus . clients , client ) } } return clus }
116	func ( opts * jwtOptions ) ParseWithDefaults ( optMap map [ string ] string ) error { if opts . TTL == 0 && optMap [ optTTL ] == "" { opts . TTL = DefaultTTL } return opts . Parse ( optMap ) }
117	func ( opts * jwtOptions ) Parse ( optMap map [ string ] string ) error { var err error if ttl := optMap [ optTTL ] ; ttl != "" { opts . TTL , err = time . ParseDuration ( ttl ) if err != nil { return err } } if file := optMap [ optPublicKey ] ; file != "" { opts . PublicKey , err = ioutil . ReadFile ( file ) if err != nil { return err } } if file := optMap [ optPrivateKey ] ; file != "" { opts . PrivateKey , err = ioutil . ReadFile ( file ) if err != nil { return err } } method := optMap [ optSignMethod ] opts . SignMethod = jwt . GetSigningMethod ( method ) if opts . SignMethod == nil { return ErrInvalidAuthMethod } return nil }
118	func ( opts * jwtOptions ) Key ( ) ( interface { } , error ) { switch opts . SignMethod . ( type ) { case * jwt . SigningMethodRSA , * jwt . SigningMethodRSAPSS : return opts . rsaKey ( ) case * jwt . SigningMethodECDSA : return opts . ecKey ( ) case * jwt . SigningMethodHMAC : return opts . hmacKey ( ) default : return nil , fmt . Errorf ( "unsupported signing method: %T" , opts . SignMethod ) } }
119	func ( h * header ) fill ( rh * pb . ResponseHeader ) { if rh == nil { plog . Panic ( "unexpected nil resp.Header" ) } rh . ClusterId = uint64 ( h . clusterID ) rh . MemberId = uint64 ( h . memberID ) rh . RaftTerm = h . sg . Term ( ) if rh . Revision == 0 { rh . Revision = h . rev ( ) } }
120	func ( wb * watchBroadcast ) add ( w * watcher ) bool { wb . mu . Lock ( ) defer wb . mu . Unlock ( ) if wb . nextrev > w . nextrev || ( wb . nextrev == 0 && w . nextrev != 0 ) { return false } if wb . responses == 0 { wb . receivers [ w ] = struct { } { } return true } ok := w . post ( & pb . WatchResponse { Header : & pb . ResponseHeader { Revision : w . nextrev , } , WatchId : w . id , Created : true , } ) if ! ok { return false } wb . receivers [ w ] = struct { } { } watchersCoalescing . Inc ( ) return true }
121	func ( ws * watchStream ) Watch ( id WatchID , key , end [ ] byte , startRev int64 , fcs ... FilterFunc ) ( WatchID , error ) { if len ( end ) != 0 && bytes . Compare ( key , end ) != - 1 { return - 1 , ErrEmptyWatcherRange } ws . mu . Lock ( ) defer ws . mu . Unlock ( ) if ws . closed { return - 1 , ErrEmptyWatcherRange } if id == AutoWatchID { for ws . watchers [ ws . nextID ] != nil { ws . nextID ++ } id = ws . nextID ws . nextID ++ } else if _ , ok := ws . watchers [ id ] ; ok { return - 1 , ErrWatcherDuplicateID } w , c := ws . watchable . watch ( key , end , startRev , id , ws . ch , fcs ... ) ws . cancels [ id ] = c ws . watchers [ id ] = w return id , nil }
122	func newFileEncoder ( f * os . File , prevCrc uint32 ) ( * encoder , error ) { offset , err := f . Seek ( 0 , io . SeekCurrent ) if err != nil { return nil , err } return newEncoder ( f , prevCrc , int ( offset ) ) , nil }
123	func purgeFile ( lg * zap . Logger , dirname string , suffix string , max uint , interval time . Duration , stop <- chan struct { } , purgec chan <- string ) <- chan error { errC := make ( chan error , 1 ) go func ( ) { for { fnames , err := ReadDir ( dirname ) if err != nil { errC <- err return } newfnames := make ( [ ] string , 0 ) for _ , fname := range fnames { if strings . HasSuffix ( fname , suffix ) { newfnames = append ( newfnames , fname ) } } sort . Strings ( newfnames ) fnames = newfnames for len ( newfnames ) > int ( max ) { f := filepath . Join ( dirname , newfnames [ 0 ] ) l , err := TryLockFile ( f , os . O_WRONLY , PrivateFileMode ) if err != nil { break } if err = os . Remove ( f ) ; err != nil { errC <- err return } if err = l . Close ( ) ; err != nil { if lg != nil { lg . Warn ( "failed to unlock/close" , zap . String ( "path" , l . Name ( ) ) , zap . Error ( err ) ) } else { plog . Errorf ( "error unlocking %s when purging file (%v)" , l . Name ( ) , err ) } errC <- err return } if lg != nil { lg . Info ( "purged" , zap . String ( "path" , f ) ) } else { plog . Infof ( "purged file %s successfully" , f ) } newfnames = newfnames [ 1 : ] } if purgec != nil { for i := 0 ; i < len ( fnames ) - len ( newfnames ) ; i ++ { purgec <- fnames [ i ] } } select { case <- time . After ( interval ) : case <- stop : return } } } ( ) return errC }
124	func ( ss * StringsValue ) Set ( s string ) error { * ss = strings . Split ( s , "," ) return nil }
125	func NewStringsValue ( s string ) ( ss * StringsValue ) { if s == "" { return & StringsValue { } } ss = new ( StringsValue ) if err := ss . Set ( s ) ; err != nil { plog . Panicf ( "new StringsValue should never fail: %v" , err ) } return ss }
126	func StringsFromFlag ( fs * flag . FlagSet , flagName string ) [ ] string { return [ ] string ( * fs . Lookup ( flagName ) . Value . ( * StringsValue ) ) }
127	func Cluster ( v string ) string { vs := strings . Split ( v , "." ) if len ( vs ) <= 2 { return v } return fmt . Sprintf ( "%s.%s" , vs [ 0 ] , vs [ 1 ] ) }
128	func NewPageWriter ( w io . Writer , pageBytes , pageOffset int ) * PageWriter { return & PageWriter { w : w , pageOffset : pageOffset , pageBytes : pageBytes , buf : make ( [ ] byte , defaultBufferBytes + pageBytes ) , bufWatermarkBytes : defaultBufferBytes , } }
129	func ( wh * watcherHub ) watch ( key string , recursive , stream bool , index , storeIndex uint64 ) ( Watcher , * v2error . Error ) { reportWatchRequest ( ) event , err := wh . EventHistory . scan ( key , recursive , index ) if err != nil { err . Index = storeIndex return nil , err } w := & watcher { eventChan : make ( chan * Event , 100 ) , recursive : recursive , stream : stream , sinceIndex : index , startIndex : storeIndex , hub : wh , } wh . mutex . Lock ( ) defer wh . mutex . Unlock ( ) if event != nil { ne := event . Clone ( ) ne . EtcdIndex = storeIndex w . eventChan <- ne return w , nil } l , ok := wh . watchers [ key ] var elem * list . Element if ok { elem = l . PushBack ( w ) } else { l = list . New ( ) elem = l . PushBack ( w ) wh . watchers [ key ] = l } w . remove = func ( ) { if w . removed { return } w . removed = true l . Remove ( elem ) atomic . AddInt64 ( & wh . count , - 1 ) reportWatcherRemoved ( ) if l . Len ( ) == 0 { delete ( wh . watchers , key ) } } atomic . AddInt64 ( & wh . count , 1 ) reportWatcherAdded ( ) return w , nil }
130	func ( wh * watcherHub ) notify ( e * Event ) { e = wh . EventHistory . addEvent ( e ) segments := strings . Split ( e . Node . Key , "/" ) currPath := "/" for _ , segment := range segments { currPath = path . Join ( currPath , segment ) wh . notifyWatchers ( e , currPath , false ) } }
131	func ( wh * watcherHub ) clone ( ) * watcherHub { clonedHistory := wh . EventHistory . clone ( ) return & watcherHub { EventHistory : clonedHistory , } }
132	func isHidden ( watchPath , keyPath string ) bool { if len ( watchPath ) > len ( keyPath ) { return false } afterPath := path . Clean ( "/" + keyPath [ len ( watchPath ) : ] ) return strings . Contains ( afterPath , "/_" ) }
133	func ( srv * Server ) createEtcdLogFile ( ) error { var err error srv . etcdLogFile , err = os . Create ( srv . Member . Etcd . LogOutputs [ 0 ] ) if err != nil { return err } srv . lg . Info ( "created etcd log file" , zap . String ( "path" , srv . Member . Etcd . LogOutputs [ 0 ] ) ) return nil }
134	func ( srv * Server ) runEtcd ( ) error { errc := make ( chan error ) go func ( ) { time . Sleep ( 5 * time . Second ) errc <- srv . startProxy ( ) } ( ) if srv . etcdCmd != nil { srv . lg . Info ( "starting etcd command" , zap . String ( "command-path" , srv . etcdCmd . Path ) , ) err := srv . etcdCmd . Start ( ) perr := <- errc srv . lg . Info ( "started etcd command" , zap . String ( "command-path" , srv . etcdCmd . Path ) , zap . Errors ( "errors" , [ ] error { err , perr } ) , ) if err != nil { return err } return perr } select { case <- srv . etcdServer . Server . ReadyNotify ( ) : srv . lg . Info ( "embedded etcd is ready" ) case <- time . After ( time . Minute ) : srv . etcdServer . Close ( ) return fmt . Errorf ( "took too long to start %v" , <- srv . etcdServer . Err ( ) ) } return <- errc }
135	func ( srv * Server ) stopEtcd ( sig os . Signal ) error { srv . stopProxy ( ) if srv . etcdCmd != nil { srv . lg . Info ( "stopping etcd command" , zap . String ( "command-path" , srv . etcdCmd . Path ) , zap . String ( "signal" , sig . String ( ) ) , ) err := srv . etcdCmd . Process . Signal ( sig ) if err != nil { return err } errc := make ( chan error ) go func ( ) { _ , ew := srv . etcdCmd . Process . Wait ( ) errc <- ew close ( errc ) } ( ) select { case <- time . After ( 5 * time . Second ) : srv . etcdCmd . Process . Kill ( ) case e := <- errc : return e } err = <- errc srv . lg . Info ( "stopped etcd command" , zap . String ( "command-path" , srv . etcdCmd . Path ) , zap . String ( "signal" , sig . String ( ) ) , zap . Error ( err ) , ) return err } srv . lg . Info ( "stopping embedded etcd" ) srv . etcdServer . Server . HardStop ( ) srv . etcdServer . Close ( ) srv . lg . Info ( "stopped embedded etcd" ) return nil }
136	func ( srv * Server ) handle_SIGQUIT_ETCD_AND_REMOVE_DATA_AND_STOP_AGENT ( ) ( * rpcpb . Response , error ) { err := srv . stopEtcd ( syscall . SIGQUIT ) if err != nil { return nil , err } if srv . etcdServer != nil { srv . etcdServer . GetLogger ( ) . Sync ( ) } else { srv . etcdLogFile . Sync ( ) srv . etcdLogFile . Close ( ) } err = os . RemoveAll ( srv . Member . BaseDir ) if err != nil { return nil , err } srv . lg . Info ( "removed base directory" , zap . String ( "dir" , srv . Member . BaseDir ) ) srv . Stop ( ) return & rpcpb . Response { Success : true , Status : "destroyed etcd and agent" , } , nil }
137	func LimitListener ( l net . Listener , n int ) net . Listener { return & limitListener { l , make ( chan struct { } , n ) } }
138	func allowMethod ( w http . ResponseWriter , m string , ms ... string ) bool { for _ , meth := range ms { if m == meth { return true } } w . Header ( ) . Set ( "Allow" , strings . Join ( ms , "," ) ) http . Error ( w , "Method Not Allowed" , http . StatusMethodNotAllowed ) return false }
139	func NewWatchServer ( s * etcdserver . EtcdServer ) pb . WatchServer { return & watchServer { lg : s . Cfg . Logger , clusterID : int64 ( s . Cluster ( ) . ID ( ) ) , memberID : int64 ( s . ID ( ) ) , maxRequestBytes : int ( s . Cfg . MaxRequestBytes + grpcOverheadBytes ) , sg : s , watchable : s . Watchable ( ) , ag : s , } }
140	func FiltersFromRequest ( creq * pb . WatchCreateRequest ) [ ] mvcc . FilterFunc { filters := make ( [ ] mvcc . FilterFunc , 0 , len ( creq . Filters ) ) for _ , ft := range creq . Filters { switch ft { case pb . WatchCreateRequest_NOPUT : filters = append ( filters , filterNoPut ) case pb . WatchCreateRequest_NODELETE : filters = append ( filters , filterNoDelete ) default : } } return filters }
141	func newPipelineHandler ( t * Transport , r Raft , cid types . ID ) http . Handler { return & pipelineHandler { lg : t . Logger , localID : t . ID , tr : t , r : r , cid : cid , } }
142	func checkClusterCompatibilityFromHeader ( lg * zap . Logger , localID types . ID , header http . Header , cid types . ID ) error { remoteName := header . Get ( "X-Server-From" ) remoteServer := serverVersion ( header ) remoteVs := "" if remoteServer != nil { remoteVs = remoteServer . String ( ) } remoteMinClusterVer := minClusterVersion ( header ) remoteMinClusterVs := "" if remoteMinClusterVer != nil { remoteMinClusterVs = remoteMinClusterVer . String ( ) } localServer , localMinCluster , err := checkVersionCompatibility ( remoteName , remoteServer , remoteMinClusterVer ) localVs := "" if localServer != nil { localVs = localServer . String ( ) } localMinClusterVs := "" if localMinCluster != nil { localMinClusterVs = localMinCluster . String ( ) } if err != nil { if lg != nil { lg . Warn ( "failed to check version compatibility" , zap . String ( "local-member-id" , localID . String ( ) ) , zap . String ( "local-member-cluster-id" , cid . String ( ) ) , zap . String ( "local-member-server-version" , localVs ) , zap . String ( "local-member-server-minimum-cluster-version" , localMinClusterVs ) , zap . String ( "remote-peer-server-name" , remoteName ) , zap . String ( "remote-peer-server-version" , remoteVs ) , zap . String ( "remote-peer-server-minimum-cluster-version" , remoteMinClusterVs ) , zap . Error ( err ) , ) } else { plog . Errorf ( "request version incompatibility (%v)" , err ) } return errIncompatibleVersion } if gcid := header . Get ( "X-Etcd-Cluster-ID" ) ; gcid != cid . String ( ) { if lg != nil { lg . Warn ( "request cluster ID mismatch" , zap . String ( "local-member-id" , localID . String ( ) ) , zap . String ( "local-member-cluster-id" , cid . String ( ) ) , zap . String ( "local-member-server-version" , localVs ) , zap . String ( "local-member-server-minimum-cluster-version" , localMinClusterVs ) , zap . String ( "remote-peer-server-name" , remoteName ) , zap . String ( "remote-peer-server-version" , remoteVs ) , zap . String ( "remote-peer-server-minimum-cluster-version" , remoteMinClusterVs ) , zap . String ( "remote-peer-cluster-id" , gcid ) , ) } else { plog . Errorf ( "request cluster ID mismatch (got %s want %s)" , gcid , cid ) } return errClusterIDMismatch } return nil }
143	func KeyExists ( key string ) clientv3 . Cmp { return clientv3 . Compare ( clientv3 . Version ( key ) , ">" , 0 ) }
144	func KeyMissing ( key string ) clientv3 . Cmp { return clientv3 . Compare ( clientv3 . Version ( key ) , "=" , 0 ) }
145	func ValidateSecureEndpoints ( tlsInfo TLSInfo , eps [ ] string ) ( [ ] string , error ) { t , err := NewTransport ( tlsInfo , 5 * time . Second ) if err != nil { return nil , err } var errs [ ] string var endpoints [ ] string for _ , ep := range eps { if ! strings . HasPrefix ( ep , "https://" ) { errs = append ( errs , fmt . Sprintf ( "%q is insecure" , ep ) ) continue } conn , cerr := t . Dial ( "tcp" , ep [ len ( "https://" ) : ] ) if cerr != nil { errs = append ( errs , fmt . Sprintf ( "%q failed to dial (%v)" , ep , cerr ) ) continue } conn . Close ( ) endpoints = append ( endpoints , ep ) } if len ( errs ) != 0 { err = fmt . Errorf ( "%s" , strings . Join ( errs , "," ) ) } return endpoints , err }
146	func putNewKV ( kv v3 . KV , key , val string , leaseID v3 . LeaseID ) ( int64 , error ) { cmp := v3 . Compare ( v3 . Version ( key ) , "=" , 0 ) req := v3 . OpPut ( key , val , v3 . WithLease ( leaseID ) ) txnresp , err := kv . Txn ( context . TODO ( ) ) . If ( cmp ) . Then ( req ) . Commit ( ) if err != nil { return 0 , err } if ! txnresp . Succeeded { return 0 , ErrKeyExists } return txnresp . Header . Revision , nil }
147	func newUniqueEphemeralKey ( s * concurrency . Session , prefix string ) ( * EphemeralKV , error ) { return newUniqueEphemeralKV ( s , prefix , "" ) }
148	func NewUpdateDirCommand ( ) cli . Command { return cli . Command { Name : "updatedir" , Usage : "update an existing directory" , ArgsUsage : "<key> <value>" , Flags : [ ] cli . Flag { cli . IntFlag { Name : "ttl" , Value : 0 , Usage : "key time-to-live in seconds" } , } , Action : func ( c * cli . Context ) error { updatedirCommandFunc ( c , mustNewKeyAPI ( c ) ) return nil } , } }
149	func updatedirCommandFunc ( c * cli . Context , ki client . KeysAPI ) { if len ( c . Args ( ) ) == 0 { handleError ( c , ExitBadArgs , errors . New ( "key required" ) ) } key := c . Args ( ) [ 0 ] ttl := c . Int ( "ttl" ) ctx , cancel := contextWithTotalTimeout ( c ) resp , err := ki . Set ( ctx , key , "" , & client . SetOptions { TTL : time . Duration ( ttl ) * time . Second , Dir : true , PrevExist : client . PrevExist } ) cancel ( ) if err != nil { handleError ( c , ExitServerError , err ) } if c . GlobalString ( "output" ) != "simple" { printResponseKey ( resp , c . GlobalString ( "output" ) ) } }
150	func handleBackup ( c * cli . Context ) error { var srcWAL string var destWAL string withV3 := c . Bool ( "with-v3" ) srcSnap := filepath . Join ( c . String ( "data-dir" ) , "member" , "snap" ) destSnap := filepath . Join ( c . String ( "backup-dir" ) , "member" , "snap" ) if c . String ( "wal-dir" ) != "" { srcWAL = c . String ( "wal-dir" ) } else { srcWAL = filepath . Join ( c . String ( "data-dir" ) , "member" , "wal" ) } if c . String ( "backup-wal-dir" ) != "" { destWAL = c . String ( "backup-wal-dir" ) } else { destWAL = filepath . Join ( c . String ( "backup-dir" ) , "member" , "wal" ) } if err := fileutil . CreateDirAll ( destSnap ) ; err != nil { log . Fatalf ( "failed creating backup snapshot dir %v: %v" , destSnap , err ) } walsnap := saveSnap ( destSnap , srcSnap ) metadata , state , ents := loadWAL ( srcWAL , walsnap , withV3 ) saveDB ( filepath . Join ( destSnap , "db" ) , filepath . Join ( srcSnap , "db" ) , state . Commit , withV3 ) idgen := idutil . NewGenerator ( 0 , time . Now ( ) ) metadata . NodeID = idgen . Next ( ) metadata . ClusterID = idgen . Next ( ) neww , err := wal . Create ( zap . NewExample ( ) , destWAL , pbutil . MustMarshal ( & metadata ) ) if err != nil { log . Fatal ( err ) } defer neww . Close ( ) if err := neww . Save ( state , ents ) ; err != nil { log . Fatal ( err ) } if err := neww . SaveSnapshot ( walsnap ) ; err != nil { log . Fatal ( err ) } return nil }
151	func saveDB ( destDB , srcDB string , idx uint64 , v3 bool ) { if v3 { var src * bolt . DB ch := make ( chan * bolt . DB , 1 ) go func ( ) { db , err := bolt . Open ( srcDB , 0444 , & bolt . Options { ReadOnly : true } ) if err != nil { log . Fatal ( err ) } ch <- db } ( ) select { case src = <- ch : case <- time . After ( time . Second ) : log . Println ( "waiting to acquire lock on" , srcDB ) src = <- ch } defer src . Close ( ) tx , err := src . Begin ( false ) if err != nil { log . Fatal ( err ) } dest , err := os . Create ( destDB ) if err != nil { log . Fatal ( err ) } if _ , err := tx . WriteTo ( dest ) ; err != nil { log . Fatal ( err ) } dest . Close ( ) if err := tx . Rollback ( ) ; err != nil { log . Fatal ( err ) } } db , err := bolt . Open ( destDB , 0644 , & bolt . Options { } ) if err != nil { log . Fatal ( err ) } tx , err := db . Begin ( true ) if err != nil { log . Fatal ( err ) } for _ , bucket := range [ ] string { "members" , "members_removed" , "cluster" } { tx . DeleteBucket ( [ ] byte ( bucket ) ) } if ! v3 { idxBytes := make ( [ ] byte , 8 ) binary . BigEndian . PutUint64 ( idxBytes , idx ) b , err := tx . CreateBucketIfNotExists ( [ ] byte ( "meta" ) ) if err != nil { log . Fatal ( err ) } b . Put ( [ ] byte ( "consistent_index" ) , idxBytes ) } if err := tx . Commit ( ) ; err != nil { log . Fatal ( err ) } if err := db . Close ( ) ; err != nil { log . Fatal ( err ) } }
152	func NewWatchCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "watcher" , Short : "Performs watch operation" , Run : runWatcherFunc , } cmd . Flags ( ) . DurationVar ( & runningTime , "running-time" , 60 , "number of seconds to run" ) cmd . Flags ( ) . StringVar ( & watchPrefix , "prefix" , "" , "the prefix to append on all keys" ) cmd . Flags ( ) . IntVar ( & noOfPrefixes , "total-prefixes" , 10 , "total no of prefixes to use" ) cmd . Flags ( ) . IntVar ( & watchPerPrefix , "watch-per-prefix" , 10 , "number of watchers per prefix" ) cmd . Flags ( ) . IntVar ( & totalKeys , "total-keys" , 1000 , "total number of keys to watch" ) return cmd }
153	func NewV3 ( lg * zap . Logger ) Manager { if lg == nil { lg = zap . NewExample ( ) } return & v3Manager { lg : lg } }
154	func ( s * v3Manager ) Save ( ctx context . Context , cfg clientv3 . Config , dbPath string ) error { if len ( cfg . Endpoints ) != 1 { return fmt . Errorf ( "snapshot must be requested to one selected node, not multiple %v" , cfg . Endpoints ) } cli , err := clientv3 . New ( cfg ) if err != nil { return err } defer cli . Close ( ) partpath := dbPath + ".part" defer os . RemoveAll ( partpath ) var f * os . File f , err = os . OpenFile ( partpath , os . O_WRONLY | os . O_CREATE | os . O_TRUNC , fileutil . PrivateFileMode ) if err != nil { return fmt . Errorf ( "could not open %s (%v)" , partpath , err ) } s . lg . Info ( "created temporary db file" , zap . String ( "path" , partpath ) , ) now := time . Now ( ) var rd io . ReadCloser rd , err = cli . Snapshot ( ctx ) if err != nil { return err } s . lg . Info ( "fetching snapshot" , zap . String ( "endpoint" , cfg . Endpoints [ 0 ] ) , ) if _ , err = io . Copy ( f , rd ) ; err != nil { return err } if err = fileutil . Fsync ( f ) ; err != nil { return err } if err = f . Close ( ) ; err != nil { return err } s . lg . Info ( "fetched snapshot" , zap . String ( "endpoint" , cfg . Endpoints [ 0 ] ) , zap . Duration ( "took" , time . Since ( now ) ) , ) if err = os . Rename ( partpath , dbPath ) ; err != nil { return fmt . Errorf ( "could not rename %s to %s (%v)" , partpath , dbPath , err ) } s . lg . Info ( "saved" , zap . String ( "path" , dbPath ) ) return nil }
155	func ( s * v3Manager ) Status ( dbPath string ) ( ds Status , err error ) { if _ , err = os . Stat ( dbPath ) ; err != nil { return ds , err } db , err := bolt . Open ( dbPath , 0400 , & bolt . Options { ReadOnly : true } ) if err != nil { return ds , err } defer db . Close ( ) h := crc32 . New ( crc32 . MakeTable ( crc32 . Castagnoli ) ) if err = db . View ( func ( tx * bolt . Tx ) error { var dbErrStrings [ ] string for dbErr := range tx . Check ( ) { dbErrStrings = append ( dbErrStrings , dbErr . Error ( ) ) } if len ( dbErrStrings ) > 0 { return fmt . Errorf ( "snapshot file integrity check failed. %d errors found.\n" + \n , strings . Join ( dbErrStrings , "\n" ) ) } \n len ( dbErrStrings ) ds . TotalSize = tx . Size ( ) c := tx . Cursor ( ) } ) ; for next , _ := c . First ( ) ; next != nil ; next , _ = c . Next ( ) { b := tx . Bucket ( next ) if b == nil { return fmt . Errorf ( "cannot get hash of bucket %s" , string ( next ) ) } h . Write ( next ) iskeyb := ( string ( next ) == "key" ) b . ForEach ( func ( k , v [ ] byte ) error { h . Write ( k ) h . Write ( v ) if iskeyb { rev := bytesToRev ( k ) ds . Revision = rev . main } ds . TotalKey ++ return nil } ) } return nil err != nil { return ds , err } }
156	func ( s * v3Manager ) Restore ( cfg RestoreConfig ) error { pURLs , err := types . NewURLs ( cfg . PeerURLs ) if err != nil { return err } var ics types . URLsMap ics , err = types . NewURLsMap ( cfg . InitialCluster ) if err != nil { return err } srv := etcdserver . ServerConfig { Logger : s . lg , Name : cfg . Name , PeerURLs : pURLs , InitialPeerURLsMap : ics , InitialClusterToken : cfg . InitialClusterToken , } if err = srv . VerifyBootstrap ( ) ; err != nil { return err } s . cl , err = membership . NewClusterFromURLsMap ( s . lg , cfg . InitialClusterToken , ics ) if err != nil { return err } dataDir := cfg . OutputDataDir if dataDir == "" { dataDir = cfg . Name + ".etcd" } if fileutil . Exist ( dataDir ) { return fmt . Errorf ( "data-dir %q exists" , dataDir ) } walDir := cfg . OutputWALDir if walDir == "" { walDir = filepath . Join ( dataDir , "member" , "wal" ) } else if fileutil . Exist ( walDir ) { return fmt . Errorf ( "wal-dir %q exists" , walDir ) } s . name = cfg . Name s . dbPath = cfg . SnapshotPath s . walDir = walDir s . snapDir = filepath . Join ( dataDir , "member" , "snap" ) s . skipHashCheck = cfg . SkipHashCheck s . lg . Info ( "restoring snapshot" , zap . String ( "path" , s . dbPath ) , zap . String ( "wal-dir" , s . walDir ) , zap . String ( "data-dir" , dataDir ) , zap . String ( "snap-dir" , s . snapDir ) , ) if err = s . saveDB ( ) ; err != nil { return err } if err = s . saveWALAndSnap ( ) ; err != nil { return err } s . lg . Info ( "restored snapshot" , zap . String ( "path" , s . dbPath ) , zap . String ( "wal-dir" , s . walDir ) , zap . String ( "data-dir" , dataDir ) , zap . String ( "snap-dir" , s . snapDir ) , ) return nil }
157	func NewAuthStore ( lg * zap . Logger , be backend . Backend , tp TokenProvider , bcryptCost int ) * authStore { if bcryptCost < bcrypt . MinCost || bcryptCost > bcrypt . MaxCost { if lg != nil { lg . Warn ( "use default bcrypt cost instead of the invalid given cost" , zap . Int ( "min-cost" , bcrypt . MinCost ) , zap . Int ( "max-cost" , bcrypt . MaxCost ) , zap . Int ( "default-cost" , bcrypt . DefaultCost ) , zap . Int ( "given-cost" , bcryptCost ) ) } else { plog . Warningf ( "Use default bcrypt-cost %d instead of the invalid value %d" , bcrypt . DefaultCost , bcryptCost ) } bcryptCost = bcrypt . DefaultCost } tx := be . BatchTx ( ) tx . Lock ( ) tx . UnsafeCreateBucket ( authBucketName ) tx . UnsafeCreateBucket ( authUsersBucketName ) tx . UnsafeCreateBucket ( authRolesBucketName ) enabled := false _ , vs := tx . UnsafeRange ( authBucketName , enableFlagKey , nil , 0 ) if len ( vs ) == 1 { if bytes . Equal ( vs [ 0 ] , authEnabled ) { enabled = true } } as := & authStore { revision : getRevision ( tx ) , lg : lg , be : be , enabled : enabled , rangePermCache : make ( map [ string ] * unifiedRangePermissions ) , tokenProvider : tp , bcryptCost : bcryptCost , } if enabled { as . tokenProvider . enable ( ) } if as . Revision ( ) == 0 { as . commitRevision ( tx ) } tx . Unlock ( ) be . ForceCommit ( ) return as }
158	func NewTokenProvider ( lg * zap . Logger , tokenOpts string , indexWaiter func ( uint64 ) <- chan struct { } ) ( TokenProvider , error ) { tokenType , typeSpecificOpts , err := decomposeOpts ( lg , tokenOpts ) if err != nil { return nil , ErrInvalidAuthOpts } switch tokenType { case tokenTypeSimple : if lg != nil { lg . Warn ( "simple token is not cryptographically signed" ) } else { plog . Warningf ( "simple token is not cryptographically signed" ) } return newTokenProviderSimple ( lg , indexWaiter ) , nil case tokenTypeJWT : return newTokenProviderJWT ( lg , typeSpecificOpts ) case "" : return newTokenProviderNop ( ) default : if lg != nil { lg . Warn ( "unknown token type" , zap . String ( "type" , tokenType ) , zap . Error ( ErrInvalidAuthOpts ) , ) } else { plog . Errorf ( "unknown token type: %s" , tokenType ) } return nil , ErrInvalidAuthOpts } }
159	func ( t * Transport ) MendPeer ( id types . ID ) { t . mu . RLock ( ) p , pok := t . peers [ id ] g , gok := t . remotes [ id ] t . mu . RUnlock ( ) if pok { p . ( Pausable ) . Resume ( ) } if gok { g . Resume ( ) } }
160	func ( t * Transport ) removePeer ( id types . ID ) { if peer , ok := t . peers [ id ] ; ok { peer . stop ( ) } else { if t . Logger != nil { t . Logger . Panic ( "unexpected removal of unknown remote peer" , zap . String ( "remote-peer-id" , id . String ( ) ) ) } else { plog . Panicf ( "unexpected removal of unknown peer '%d'" , id ) } } delete ( t . peers , id ) delete ( t . LeaderStats . Followers , id . String ( ) ) t . pipelineProber . Remove ( id . String ( ) ) t . streamProber . Remove ( id . String ( ) ) if t . Logger != nil { t . Logger . Info ( "removed remote peer" , zap . String ( "local-member-id" , t . ID . String ( ) ) , zap . String ( "removed-remote-peer-id" , id . String ( ) ) , ) } else { plog . Infof ( "removed peer %s" , id ) } }
161	func ( t * Transport ) ActivePeers ( ) ( cnt int ) { t . mu . RLock ( ) defer t . mu . RUnlock ( ) for _ , p := range t . peers { if ! p . activeSince ( ) . IsZero ( ) { cnt ++ } } return cnt }
162	func resolveTCPAddrDefault ( ctx context . Context , addr string ) ( * net . TCPAddr , error ) { host , port , serr := net . SplitHostPort ( addr ) if serr != nil { return nil , serr } portnum , perr := net . DefaultResolver . LookupPort ( ctx , "tcp" , port ) if perr != nil { return nil , perr } var ips [ ] net . IPAddr if ip := net . ParseIP ( host ) ; ip != nil { ips = [ ] net . IPAddr { { IP : ip } } } else { ipss , err := net . DefaultResolver . LookupIPAddr ( ctx , host ) if err != nil { return nil , err } ips = ipss } ip := ips [ 0 ] return & net . TCPAddr { IP : ip . IP , Port : portnum , Zone : ip . Zone } , nil }
163	func resolveTCPAddrs ( ctx context . Context , lg * zap . Logger , urls [ ] [ ] url . URL ) ( [ ] [ ] url . URL , error ) { newurls := make ( [ ] [ ] url . URL , 0 ) for _ , us := range urls { nus := make ( [ ] url . URL , len ( us ) ) for i , u := range us { nu , err := url . Parse ( u . String ( ) ) if err != nil { return nil , fmt . Errorf ( "failed to parse %q (%v)" , u . String ( ) , err ) } nus [ i ] = * nu } for i , u := range nus { h , err := resolveURL ( ctx , lg , u ) if err != nil { return nil , fmt . Errorf ( "failed to resolve %q (%v)" , u . String ( ) , err ) } if h != "" { nus [ i ] . Host = h } } newurls = append ( newurls , nus ) } return newurls , nil }
164	func urlsEqual ( ctx context . Context , lg * zap . Logger , a [ ] url . URL , b [ ] url . URL ) ( bool , error ) { if len ( a ) != len ( b ) { return false , fmt . Errorf ( "len(%q) != len(%q)" , urlsToStrings ( a ) , urlsToStrings ( b ) ) } urls , err := resolveTCPAddrs ( ctx , lg , [ ] [ ] url . URL { a , b } ) if err != nil { return false , err } preva , prevb := a , b a , b = urls [ 0 ] , urls [ 1 ] sort . Sort ( types . URLs ( a ) ) sort . Sort ( types . URLs ( b ) ) for i := range a { if ! reflect . DeepEqual ( a [ i ] , b [ i ] ) { return false , fmt . Errorf ( "%q(resolved from %q) != %q(resolved from %q)" , a [ i ] . String ( ) , preva [ i ] . String ( ) , b [ i ] . String ( ) , prevb [ i ] . String ( ) , ) } } return true , nil }
165	func URLStringsEqual ( ctx context . Context , lg * zap . Logger , a [ ] string , b [ ] string ) ( bool , error ) { if len ( a ) != len ( b ) { return false , fmt . Errorf ( "len(%q) != len(%q)" , a , b ) } urlsA := make ( [ ] url . URL , 0 ) for _ , str := range a { u , err := url . Parse ( str ) if err != nil { return false , fmt . Errorf ( "failed to parse %q" , str ) } urlsA = append ( urlsA , * u ) } urlsB := make ( [ ] url . URL , 0 ) for _ , str := range b { u , err := url . Parse ( str ) if err != nil { return false , fmt . Errorf ( "failed to parse %q" , str ) } urlsB = append ( urlsB , * u ) } if lg == nil { lg , _ = zap . NewProduction ( ) if lg == nil { lg = zap . NewExample ( ) } } return urlsEqual ( ctx , lg , urlsA , urlsB ) }
166	func NewLeaseCommand ( ) * cobra . Command { lc := & cobra . Command { Use : "lease <subcommand>" , Short : "Lease related commands" , } lc . AddCommand ( NewLeaseGrantCommand ( ) ) lc . AddCommand ( NewLeaseRevokeCommand ( ) ) lc . AddCommand ( NewLeaseTimeToLiveCommand ( ) ) lc . AddCommand ( NewLeaseListCommand ( ) ) lc . AddCommand ( NewLeaseKeepAliveCommand ( ) ) return lc }
167	func NewLeaseGrantCommand ( ) * cobra . Command { lc := & cobra . Command { Use : "grant <ttl>" , Short : "Creates leases" , Run : leaseGrantCommandFunc , } return lc }
168	func leaseGrantCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 1 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "lease grant command needs TTL argument" ) ) } ttl , err := strconv . ParseInt ( args [ 0 ] , 10 , 64 ) if err != nil { ExitWithError ( ExitBadArgs , fmt . Errorf ( "bad TTL (%v)" , err ) ) } ctx , cancel := commandCtx ( cmd ) resp , err := mustClientFromCmd ( cmd ) . Grant ( ctx , ttl ) cancel ( ) if err != nil { ExitWithError ( ExitError , fmt . Errorf ( "failed to grant lease (%v)" , err ) ) } display . Grant ( * resp ) }
169	func NewLeaseRevokeCommand ( ) * cobra . Command { lc := & cobra . Command { Use : "revoke <leaseID>" , Short : "Revokes leases" , Run : leaseRevokeCommandFunc , } return lc }
170	func leaseRevokeCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 1 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "lease revoke command needs 1 argument" ) ) } id := leaseFromArgs ( args [ 0 ] ) ctx , cancel := commandCtx ( cmd ) resp , err := mustClientFromCmd ( cmd ) . Revoke ( ctx , id ) cancel ( ) if err != nil { ExitWithError ( ExitError , fmt . Errorf ( "failed to revoke lease (%v)" , err ) ) } display . Revoke ( id , * resp ) }
171	func NewLeaseTimeToLiveCommand ( ) * cobra . Command { lc := & cobra . Command { Use : "timetolive <leaseID> [options]" , Short : "Get lease information" , Run : leaseTimeToLiveCommandFunc , } lc . Flags ( ) . BoolVar ( & timeToLiveKeys , "keys" , false , "Get keys attached to this lease" ) return lc }
172	func leaseTimeToLiveCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 1 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "lease timetolive command needs lease ID as argument" ) ) } var opts [ ] v3 . LeaseOption if timeToLiveKeys { opts = append ( opts , v3 . WithAttachedKeys ( ) ) } resp , rerr := mustClientFromCmd ( cmd ) . TimeToLive ( context . TODO ( ) , leaseFromArgs ( args [ 0 ] ) , opts ... ) if rerr != nil { ExitWithError ( ExitBadConnection , rerr ) } display . TimeToLive ( * resp , timeToLiveKeys ) }
173	func NewLeaseListCommand ( ) * cobra . Command { lc := & cobra . Command { Use : "list" , Short : "List all active leases" , Run : leaseListCommandFunc , } return lc }
174	func leaseListCommandFunc ( cmd * cobra . Command , args [ ] string ) { resp , rerr := mustClientFromCmd ( cmd ) . Leases ( context . TODO ( ) ) if rerr != nil { ExitWithError ( ExitBadConnection , rerr ) } display . Leases ( * resp ) }
175	func NewLeaseKeepAliveCommand ( ) * cobra . Command { lc := & cobra . Command { Use : "keep-alive [options] <leaseID>" , Short : "Keeps leases alive (renew)" , Run : leaseKeepAliveCommandFunc , } lc . Flags ( ) . BoolVar ( & leaseKeepAliveOnce , "once" , false , "Resets the keep-alive time to its original value and exits immediately" ) return lc }
176	func leaseKeepAliveCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 1 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "lease keep-alive command needs lease ID as argument" ) ) } id := leaseFromArgs ( args [ 0 ] ) if leaseKeepAliveOnce { respc , kerr := mustClientFromCmd ( cmd ) . KeepAliveOnce ( context . TODO ( ) , id ) if kerr != nil { ExitWithError ( ExitBadConnection , kerr ) } display . KeepAlive ( * respc ) return } respc , kerr := mustClientFromCmd ( cmd ) . KeepAlive ( context . TODO ( ) , id ) if kerr != nil { ExitWithError ( ExitBadConnection , kerr ) } for resp := range respc { display . KeepAlive ( * resp ) } if _ , ok := ( display ) . ( * simplePrinter ) ; ok { fmt . Printf ( "lease %016x expired or revoked.\n" , \n ) } }
177	func NewAlarmCommand ( ) * cobra . Command { ac := & cobra . Command { Use : "alarm <subcommand>" , Short : "Alarm related commands" , } ac . AddCommand ( NewAlarmDisarmCommand ( ) ) ac . AddCommand ( NewAlarmListCommand ( ) ) return ac }
178	func alarmDisarmCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 0 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "alarm disarm command accepts no arguments" ) ) } ctx , cancel := commandCtx ( cmd ) resp , err := mustClientFromCmd ( cmd ) . AlarmDisarm ( ctx , & v3 . AlarmMember { } ) cancel ( ) if err != nil { ExitWithError ( ExitError , err ) } display . Alarm ( * resp ) }
179	func alarmListCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 0 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "alarm list command accepts no arguments" ) ) } ctx , cancel := commandCtx ( cmd ) resp , err := mustClientFromCmd ( cmd ) . AlarmList ( ctx ) cancel ( ) if err != nil { ExitWithError ( ExitError , err ) } display . Alarm ( * resp ) }
180	func ( e * Etcd ) Flags ( ) ( fs [ ] string ) { tp := reflect . TypeOf ( * e ) vo := reflect . ValueOf ( * e ) for _ , name := range etcdFields { field , ok := tp . FieldByName ( name ) if ! ok { panic ( fmt . Errorf ( "field %q not found" , name ) ) } fv := reflect . Indirect ( vo ) . FieldByName ( name ) var sv string switch fv . Type ( ) . Kind ( ) { case reflect . String : sv = fv . String ( ) case reflect . Slice : n := fv . Len ( ) sl := make ( [ ] string , n ) for i := 0 ; i < n ; i ++ { sl [ i ] = fv . Index ( i ) . String ( ) } sv = strings . Join ( sl , "," ) case reflect . Int64 : sv = fmt . Sprintf ( "%d" , fv . Int ( ) ) case reflect . Bool : sv = fmt . Sprintf ( "%v" , fv . Bool ( ) ) default : panic ( fmt . Errorf ( "field %q (%v) cannot be parsed" , name , fv . Type ( ) . Kind ( ) ) ) } fname := field . Tag . Get ( "yaml" ) if fname == "initial-corrupt-check" { fname = "experimental-" + fname } if sv != "" { fs = append ( fs , fmt . Sprintf ( "--%s=%s" , fname , sv ) ) } } return fs }
181	func ( e * Etcd ) EmbedConfig ( ) ( cfg * embed . Config , err error ) { var lcURLs types . URLs lcURLs , err = types . NewURLs ( e . ListenClientURLs ) if err != nil { return nil , err } var acURLs types . URLs acURLs , err = types . NewURLs ( e . AdvertiseClientURLs ) if err != nil { return nil , err } var lpURLs types . URLs lpURLs , err = types . NewURLs ( e . ListenPeerURLs ) if err != nil { return nil , err } var apURLs types . URLs apURLs , err = types . NewURLs ( e . AdvertisePeerURLs ) if err != nil { return nil , err } cfg = embed . NewConfig ( ) cfg . Name = e . Name cfg . Dir = e . DataDir cfg . WalDir = e . WALDir cfg . TickMs = uint ( e . HeartbeatIntervalMs ) cfg . ElectionMs = uint ( e . ElectionTimeoutMs ) cfg . LCUrls = lcURLs cfg . ACUrls = acURLs cfg . ClientAutoTLS = e . ClientAutoTLS cfg . ClientTLSInfo = transport . TLSInfo { ClientCertAuth : e . ClientCertAuth , CertFile : e . ClientCertFile , KeyFile : e . ClientKeyFile , TrustedCAFile : e . ClientTrustedCAFile , } cfg . LPUrls = lpURLs cfg . APUrls = apURLs cfg . PeerAutoTLS = e . PeerAutoTLS cfg . PeerTLSInfo = transport . TLSInfo { ClientCertAuth : e . PeerClientCertAuth , CertFile : e . PeerCertFile , KeyFile : e . PeerKeyFile , TrustedCAFile : e . PeerTrustedCAFile , } cfg . InitialCluster = e . InitialCluster cfg . ClusterState = e . InitialClusterState cfg . InitialClusterToken = e . InitialClusterToken cfg . SnapshotCount = uint64 ( e . SnapshotCount ) cfg . QuotaBackendBytes = e . QuotaBackendBytes cfg . PreVote = e . PreVote cfg . ExperimentalInitialCorruptCheck = e . InitialCorruptCheck cfg . Logger = e . Logger cfg . LogOutputs = e . LogOutputs cfg . Debug = e . Debug return cfg , nil }
182	func PProfHandlers ( ) map [ string ] http . Handler { if runtime . SetMutexProfileFraction ( - 1 ) == 0 { runtime . SetMutexProfileFraction ( 5 ) } m := make ( map [ string ] http . Handler ) m [ HTTPPrefixPProf + "/" ] = http . HandlerFunc ( pprof . Index ) m [ HTTPPrefixPProf + "/profile" ] = http . HandlerFunc ( pprof . Profile ) m [ HTTPPrefixPProf + "/symbol" ] = http . HandlerFunc ( pprof . Symbol ) m [ HTTPPrefixPProf + "/cmdline" ] = http . HandlerFunc ( pprof . Cmdline ) m [ HTTPPrefixPProf + "/trace " ] = http . HandlerFunc ( pprof . Trace ) m [ HTTPPrefixPProf + "/heap" ] = pprof . Handler ( "heap" ) m [ HTTPPrefixPProf + "/goroutine" ] = pprof . Handler ( "goroutine" ) m [ HTTPPrefixPProf + "/threadcreate" ] = pprof . Handler ( "threadcreate" ) m [ HTTPPrefixPProf + "/block" ] = pprof . Handler ( "block" ) m [ HTTPPrefixPProf + "/mutex" ] = pprof . Handler ( "mutex" ) return m }
183	func NewBackendQuota ( s * EtcdServer , name string ) Quota { lg := s . getLogger ( ) quotaBackendBytes . Set ( float64 ( s . Cfg . QuotaBackendBytes ) ) if s . Cfg . QuotaBackendBytes < 0 { quotaLogOnce . Do ( func ( ) { if lg != nil { lg . Info ( "disabled backend quota" , zap . String ( "quota-name" , name ) , zap . Int64 ( "quota-size-bytes" , s . Cfg . QuotaBackendBytes ) , ) } else { plog . Warningf ( "disabling backend quota" ) } } ) return & passthroughQuota { } } if s . Cfg . QuotaBackendBytes == 0 { quotaLogOnce . Do ( func ( ) { if lg != nil { lg . Info ( "enabled backend quota with default value" , zap . String ( "quota-name" , name ) , zap . Int64 ( "quota-size-bytes" , DefaultQuotaBytes ) , zap . String ( "quota-size" , DefaultQuotaSize ) , ) } } ) quotaBackendBytes . Set ( float64 ( DefaultQuotaBytes ) ) return & backendQuota { s , DefaultQuotaBytes } } quotaLogOnce . Do ( func ( ) { if s . Cfg . QuotaBackendBytes > MaxQuotaBytes { if lg != nil { lg . Warn ( "quota exceeds the maximum value" , zap . String ( "quota-name" , name ) , zap . Int64 ( "quota-size-bytes" , s . Cfg . QuotaBackendBytes ) , zap . String ( "quota-size" , humanize . Bytes ( uint64 ( s . Cfg . QuotaBackendBytes ) ) ) , zap . Int64 ( "quota-maximum-size-bytes" , MaxQuotaBytes ) , zap . String ( "quota-maximum-size" , maxQuotaSize ) , ) } else { plog . Warningf ( "backend quota %v exceeds maximum recommended quota %v" , s . Cfg . QuotaBackendBytes , MaxQuotaBytes ) } } if lg != nil { lg . Info ( "enabled backend quota" , zap . String ( "quota-name" , name ) , zap . Int64 ( "quota-size-bytes" , s . Cfg . QuotaBackendBytes ) , zap . String ( "quota-size" , humanize . Bytes ( uint64 ( s . Cfg . QuotaBackendBytes ) ) ) , ) } } ) return & backendQuota { s , s . Cfg . QuotaBackendBytes } }
184	func NewClusterProxy ( c * clientv3 . Client , advaddr string , prefix string ) ( pb . ClusterServer , <- chan struct { } ) { cp := & clusterProxy { clus : c . Cluster , ctx : c . Ctx ( ) , gr : & naming . GRPCResolver { Client : c } , advaddr : advaddr , prefix : prefix , umap : make ( map [ string ] gnaming . Update ) , } donec := make ( chan struct { } ) if advaddr != "" && prefix != "" { go func ( ) { defer close ( donec ) cp . resolve ( prefix ) } ( ) return cp , donec } close ( donec ) return cp , donec }
185	func NewHandler ( l lease . Lessor , waitch func ( ) <- chan struct { } ) http . Handler { return & leaseHandler { l , waitch } }
186	func TimeToLiveHTTP ( ctx context . Context , id lease . LeaseID , keys bool , url string , rt http . RoundTripper ) ( * leasepb . LeaseInternalResponse , error ) { lreq , err := ( & leasepb . LeaseInternalRequest { LeaseTimeToLiveRequest : & pb . LeaseTimeToLiveRequest { ID : int64 ( id ) , Keys : keys , } , } ) . Marshal ( ) if err != nil { return nil , err } req , err := http . NewRequest ( "POST" , url , bytes . NewReader ( lreq ) ) if err != nil { return nil , err } req . Header . Set ( "Content-Type" , "application/protobuf" ) req = req . WithContext ( ctx ) cc := & http . Client { Transport : rt } var b [ ] byte resp , err := cc . Do ( req ) if err != nil { return nil , err } b , err = readResponse ( resp ) if err != nil { return nil , err } if resp . StatusCode == http . StatusRequestTimeout { return nil , ErrLeaseHTTPTimeout } if resp . StatusCode == http . StatusNotFound { return nil , lease . ErrLeaseNotFound } if resp . StatusCode != http . StatusOK { return nil , fmt . Errorf ( "lease: unknown error(%s)" , string ( b ) ) } lresp := & leasepb . LeaseInternalResponse { } if err := lresp . Unmarshal ( b ) ; err != nil { return nil , fmt . Errorf ( `lease: %v. data = "%s"` , err , string ( b ) ) } if lresp . LeaseTimeToLiveResponse . ID != int64 ( id ) { return nil , fmt . Errorf ( "lease: renew id mismatch" ) } return lresp , nil }
187	func newWatcherBatch ( wg * watcherGroup , evs [ ] mvccpb . Event ) watcherBatch { if len ( wg . watchers ) == 0 { return nil } wb := make ( watcherBatch ) for _ , ev := range evs { for w := range wg . watcherSetByKey ( string ( ev . Kv . Key ) ) { if ev . Kv . ModRevision >= w . minRev { wb . add ( w , ev ) } } } return wb }
188	func ( wg * watcherGroup ) add ( wa * watcher ) { wg . watchers . add ( wa ) if wa . end == nil { wg . keyWatchers . add ( wa ) return } ivl := adt . NewStringAffineInterval ( string ( wa . key ) , string ( wa . end ) ) if iv := wg . ranges . Find ( ivl ) ; iv != nil { iv . Val . ( watcherSet ) . add ( wa ) return } ws := make ( watcherSet ) ws . add ( wa ) wg . ranges . Insert ( ivl , ws ) }
189	func ( wg * watcherGroup ) contains ( key string ) bool { _ , ok := wg . keyWatchers [ key ] return ok || wg . ranges . Intersects ( adt . NewStringAffinePoint ( key ) ) }
190	func ( wg * watcherGroup ) delete ( wa * watcher ) bool { if _ , ok := wg . watchers [ wa ] ; ! ok { return false } wg . watchers . delete ( wa ) if wa . end == nil { wg . keyWatchers . delete ( wa ) return true } ivl := adt . NewStringAffineInterval ( string ( wa . key ) , string ( wa . end ) ) iv := wg . ranges . Find ( ivl ) if iv == nil { return false } ws := iv . Val . ( watcherSet ) delete ( ws , wa ) if len ( ws ) == 0 { if ok := wg . ranges . Delete ( ivl ) ; ! ok { panic ( "could not remove watcher from interval tree" ) } } return true }
191	func ( wg * watcherGroup ) choose ( maxWatchers int , curRev , compactRev int64 ) ( * watcherGroup , int64 ) { if len ( wg . watchers ) < maxWatchers { return wg , wg . chooseAll ( curRev , compactRev ) } ret := newWatcherGroup ( ) for w := range wg . watchers { if maxWatchers <= 0 { break } maxWatchers -- ret . add ( w ) } return & ret , ret . chooseAll ( curRev , compactRev ) }
192	func ( wg * watcherGroup ) watcherSetByKey ( key string ) watcherSet { wkeys := wg . keyWatchers [ key ] wranges := wg . ranges . Stab ( adt . NewStringAffinePoint ( key ) ) switch { case len ( wranges ) == 0 : return wkeys case len ( wranges ) == 0 && len ( wkeys ) == 0 : return nil case len ( wranges ) == 1 && len ( wkeys ) == 0 : return wranges [ 0 ] . Val . ( watcherSet ) } ret := make ( watcherSet ) ret . union ( wg . keyWatchers [ key ] ) for _ , item := range wranges { ret . union ( item . Val . ( watcherSet ) ) } return ret }
193	func ( ivl * Interval ) Compare ( c Comparable ) int { ivl2 := c . ( * Interval ) ivbCmpBegin := ivl . Begin . Compare ( ivl2 . Begin ) ivbCmpEnd := ivl . Begin . Compare ( ivl2 . End ) iveCmpBegin := ivl . End . Compare ( ivl2 . Begin ) if ivbCmpBegin < 0 && iveCmpBegin <= 0 { return - 1 } if ivbCmpEnd >= 0 { return 1 } return 0 }
194	func ( x * intervalNode ) successor ( ) * intervalNode { if x . right != nil { return x . right . min ( ) } y := x . parent for y != nil && x == y . right { x = y y = y . parent } return y }
195	func ( x * intervalNode ) updateMax ( ) { for x != nil { oldmax := x . max max := x . iv . Ivl . End if x . left != nil && x . left . max . Compare ( max ) > 0 { max = x . left . max } if x . right != nil && x . right . max . Compare ( max ) > 0 { max = x . right . max } if oldmax . Compare ( max ) == 0 { break } x . max = max x = x . parent } }
196	func ( x * intervalNode ) visit ( iv * Interval , nv nodeVisitor ) bool { if x == nil { return true } v := iv . Compare ( & x . iv . Ivl ) switch { case v < 0 : if ! x . left . visit ( iv , nv ) { return false } case v > 0 : maxiv := Interval { x . iv . Ivl . Begin , x . max } if maxiv . Compare ( iv ) == 0 { if ! x . left . visit ( iv , nv ) || ! x . right . visit ( iv , nv ) { return false } } default : if ! x . left . visit ( iv , nv ) || ! nv ( x ) || ! x . right . visit ( iv , nv ) { return false } } return true }
197	func ( ivt * IntervalTree ) Delete ( ivl Interval ) bool { z := ivt . find ( ivl ) if z == nil { return false } y := z if z . left != nil && z . right != nil { y = z . successor ( ) } x := y . left if x == nil { x = y . right } if x != nil { x . parent = y . parent } if y . parent == nil { ivt . root = x } else { if y == y . parent . left { y . parent . left = x } else { y . parent . right = x } y . parent . updateMax ( ) } if y != z { z . iv = y . iv z . updateMax ( ) } if y . color ( ) == black && x != nil { ivt . deleteFixup ( x ) } ivt . count -- return true }
198	func ( ivt * IntervalTree ) Insert ( ivl Interval , val interface { } ) { var y * intervalNode z := & intervalNode { iv : IntervalValue { ivl , val } , max : ivl . End , c : red } x := ivt . root for x != nil { y = x if z . iv . Ivl . Begin . Compare ( x . iv . Ivl . Begin ) < 0 { x = x . left } else { x = x . right } } z . parent = y if y == nil { ivt . root = z } else { if z . iv . Ivl . Begin . Compare ( y . iv . Ivl . Begin ) < 0 { y . left = z } else { y . right = z } y . updateMax ( ) } z . c = red ivt . insertFixup ( z ) ivt . count ++ }
199	func ( ivt * IntervalTree ) rotateLeft ( x * intervalNode ) { y := x . right x . right = y . left if y . left != nil { y . left . parent = x } x . updateMax ( ) ivt . replaceParent ( x , y ) y . left = x y . updateMax ( ) }
200	func ( ivt * IntervalTree ) replaceParent ( x * intervalNode , y * intervalNode ) { y . parent = x . parent if x . parent == nil { ivt . root = y } else { if x == x . parent . left { x . parent . left = y } else { x . parent . right = y } x . parent . updateMax ( ) } x . parent = y }
201	func ( ivt * IntervalTree ) MaxHeight ( ) int { return int ( ( 2 * math . Log2 ( float64 ( ivt . Len ( ) + 1 ) ) ) + 0.5 ) }
202	func ( ivt * IntervalTree ) Visit ( ivl Interval , ivv IntervalVisitor ) { ivt . root . visit ( & ivl , func ( n * intervalNode ) bool { return ivv ( & n . iv ) } ) }
203	func ( ivt * IntervalTree ) find ( ivl Interval ) ( ret * intervalNode ) { f := func ( n * intervalNode ) bool { if n . iv . Ivl != ivl { return true } ret = n return false } ivt . root . visit ( & ivl , f ) return ret }
204	func ( ivt * IntervalTree ) Find ( ivl Interval ) ( ret * IntervalValue ) { n := ivt . find ( ivl ) if n == nil { return nil } return & n . iv }
205	func ( ivt * IntervalTree ) Intersects ( iv Interval ) bool { x := ivt . root for x != nil && iv . Compare ( & x . iv . Ivl ) != 0 { if x . left != nil && x . left . max . Compare ( iv . Begin ) > 0 { x = x . left } else { x = x . right } } return x != nil }
206	func ( ivt * IntervalTree ) Contains ( ivl Interval ) bool { var maxEnd , minBegin Comparable isContiguous := true ivt . Visit ( ivl , func ( n * IntervalValue ) bool { if minBegin == nil { minBegin = n . Ivl . Begin maxEnd = n . Ivl . End return true } if maxEnd . Compare ( n . Ivl . Begin ) < 0 { isContiguous = false return false } if n . Ivl . End . Compare ( maxEnd ) > 0 { maxEnd = n . Ivl . End } return true } ) return isContiguous && minBegin != nil && maxEnd . Compare ( ivl . End ) >= 0 && minBegin . Compare ( ivl . Begin ) <= 0 }
207	func ( ivt * IntervalTree ) Stab ( iv Interval ) ( ivs [ ] * IntervalValue ) { if ivt . count == 0 { return nil } f := func ( n * IntervalValue ) bool { ivs = append ( ivs , n ) ; return true } ivt . Visit ( iv , f ) return ivs }
208	func ( ivt * IntervalTree ) Union ( inIvt IntervalTree , ivl Interval ) { f := func ( n * IntervalValue ) bool { ivt . Insert ( n . Ivl , n . Val ) return true } inIvt . Visit ( ivl , f ) }
209	func NewExactReadCloser ( rc io . ReadCloser , totalBytes int64 ) io . ReadCloser { return & exactReadCloser { rc : rc , totalBytes : totalBytes } }
210	func NewElection ( s * Session , pfx string ) * Election { return & Election { session : s , keyPrefix : pfx + "/" } }
211	func ResumeElection ( s * Session , pfx string , leaderKey string , leaderRev int64 ) * Election { return & Election { keyPrefix : pfx , session : s , leaderKey : leaderKey , leaderRev : leaderRev , leaderSession : s , } }
212	func ( e * Election ) Proclaim ( ctx context . Context , val string ) error { if e . leaderSession == nil { return ErrElectionNotLeader } client := e . session . Client ( ) cmp := v3 . Compare ( v3 . CreateRevision ( e . leaderKey ) , "=" , e . leaderRev ) txn := client . Txn ( ctx ) . If ( cmp ) txn = txn . Then ( v3 . OpPut ( e . leaderKey , val , v3 . WithLease ( e . leaderSession . Lease ( ) ) ) ) tresp , terr := txn . Commit ( ) if terr != nil { return terr } if ! tresp . Succeeded { e . leaderKey = "" return ErrElectionNotLeader } e . hdr = tresp . Header return nil }
213	func ( e * Election ) Resign ( ctx context . Context ) ( err error ) { if e . leaderSession == nil { return nil } client := e . session . Client ( ) cmp := v3 . Compare ( v3 . CreateRevision ( e . leaderKey ) , "=" , e . leaderRev ) resp , err := client . Txn ( ctx ) . If ( cmp ) . Then ( v3 . OpDelete ( e . leaderKey ) ) . Commit ( ) if err == nil { e . hdr = resp . Header } e . leaderKey = "" e . leaderSession = nil return err }
214	func ( e * Election ) Leader ( ctx context . Context ) ( * v3 . GetResponse , error ) { client := e . session . Client ( ) resp , err := client . Get ( ctx , e . keyPrefix , v3 . WithFirstCreate ( ) ... ) if err != nil { return nil , err } else if len ( resp . Kvs ) == 0 { return nil , ErrElectionNoLeader } return resp , nil }
215	func ( e * Election ) Observe ( ctx context . Context ) <- chan v3 . GetResponse { retc := make ( chan v3 . GetResponse ) go e . observe ( ctx , retc ) return retc }
216	func ( qa * quotaAlarmer ) check ( ctx context . Context , r interface { } ) error { if qa . q . Available ( r ) { return nil } req := & pb . AlarmRequest { MemberID : uint64 ( qa . id ) , Action : pb . AlarmRequest_ACTIVATE , Alarm : pb . AlarmType_NOSPACE , } qa . a . Alarm ( ctx , req ) return rpctypes . ErrGRPCNoSpace }
217	func NewExecWatchCommand ( ) cli . Command { return cli . Command { Name : "exec-watch" , Usage : "watch a key for changes and exec an executable" , ArgsUsage : "<key> <command> [args...]" , Flags : [ ] cli . Flag { cli . IntFlag { Name : "after-index" , Value : 0 , Usage : "watch after the given index" } , cli . BoolFlag { Name : "recursive, r" , Usage : "watch all values for key and child keys" } , } , Action : func ( c * cli . Context ) error { execWatchCommandFunc ( c , mustNewKeyAPI ( c ) ) return nil } , } }
218	func execWatchCommandFunc ( c * cli . Context , ki client . KeysAPI ) { args := c . Args ( ) argslen := len ( args ) if argslen < 2 { handleError ( c , ExitBadArgs , errors . New ( "key and command to exec required" ) ) } var ( key string cmdArgs [ ] string ) foundSep := false for i := range args { if args [ i ] == "--" && i != 0 { foundSep = true break } } if foundSep { key = args [ 0 ] cmdArgs = args [ 2 : ] } else { key = args [ argslen - 1 ] cmdArgs = args [ : argslen - 1 ] } index := 0 if c . Int ( "after-index" ) != 0 { index = c . Int ( "after-index" ) } recursive := c . Bool ( "recursive" ) sigch := make ( chan os . Signal , 1 ) signal . Notify ( sigch , os . Interrupt ) go func ( ) { <- sigch os . Exit ( 0 ) } ( ) w := ki . Watcher ( key , & client . WatcherOptions { AfterIndex : uint64 ( index ) , Recursive : recursive } ) for { resp , err := w . Next ( context . TODO ( ) ) if err != nil { handleError ( c , ExitServerError , err ) } if resp . Node . Dir { fmt . Fprintf ( os . Stderr , "Ignored dir %s change\n" , \n ) resp . Node . Key } continue cmd := exec . Command ( cmdArgs [ 0 ] , cmdArgs [ 1 : ] ... ) cmd . Env = environResponse ( resp , os . Environ ( ) ) cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr } }
219	func NewListener ( u url . URL , tlsinfo * transport . TLSInfo ) ( net . Listener , error ) { return transport . NewTimeoutListener ( u . Host , u . Scheme , tlsinfo , ConnReadTimeout , ConnWriteTimeout ) }
220	func NewRoundTripper ( tlsInfo transport . TLSInfo , dialTimeout time . Duration ) ( http . RoundTripper , error ) { return transport . NewTimeoutTransport ( tlsInfo , dialTimeout , 0 , 0 ) }
221	func createPostRequest ( u url . URL , path string , body io . Reader , ct string , urls types . URLs , from , cid types . ID ) * http . Request { uu := u uu . Path = path req , err := http . NewRequest ( "POST" , uu . String ( ) , body ) if err != nil { plog . Panicf ( "unexpected new request error (%v)" , err ) } req . Header . Set ( "Content-Type" , ct ) req . Header . Set ( "X-Server-From" , from . String ( ) ) req . Header . Set ( "X-Server-Version" , version . Version ) req . Header . Set ( "X-Min-Cluster-Version" , version . MinClusterVersion ) req . Header . Set ( "X-Etcd-Cluster-ID" , cid . String ( ) ) setPeerURLsHeader ( req , urls ) return req }
222	func checkPostResponse ( resp * http . Response , body [ ] byte , req * http . Request , to types . ID ) error { switch resp . StatusCode { case http . StatusPreconditionFailed : switch strings . TrimSuffix ( string ( body ) , "\n" ) { \n case errIncompatibleVersion . Error ( ) : plog . Errorf ( "request sent was ignored by peer %s (server version incompatible)" , to ) return errIncompatibleVersion case errClusterIDMismatch . Error ( ) : plog . Errorf ( "request sent was ignored (cluster ID mismatch: remote[%s]=%s, local=%s)" , to , resp . Header . Get ( "X-Etcd-Cluster-ID" ) , req . Header . Get ( "X-Etcd-Cluster-ID" ) ) return errClusterIDMismatch } default : return fmt . Errorf ( "unhandled error %q when precondition failed" , string ( body ) ) case http . StatusForbidden : return errMemberRemoved case http . StatusNoContent : return nil } }
223	func serverVersion ( h http . Header ) * semver . Version { verStr := h . Get ( "X-Server-Version" ) if verStr == "" { verStr = "2.0.0" } return semver . Must ( semver . NewVersion ( verStr ) ) }
224	func checkVersionCompatibility ( name string , server , minCluster * semver . Version ) ( localServer * semver . Version , localMinCluster * semver . Version , err error ) { localServer = semver . Must ( semver . NewVersion ( version . Version ) ) localMinCluster = semver . Must ( semver . NewVersion ( version . MinClusterVersion ) ) if compareMajorMinorVersion ( server , localMinCluster ) == - 1 { return localServer , localMinCluster , fmt . Errorf ( "remote version is too low: remote[%s]=%s, local=%s" , name , server , localServer ) } if compareMajorMinorVersion ( minCluster , localServer ) == 1 { return localServer , localMinCluster , fmt . Errorf ( "local version is too low: remote[%s]=%s, local=%s" , name , server , localServer ) } return localServer , localMinCluster , nil }
225	func setPeerURLsHeader ( req * http . Request , urls types . URLs ) { if urls == nil { return } peerURLs := make ( [ ] string , urls . Len ( ) ) for i := range urls { peerURLs [ i ] = urls [ i ] . String ( ) } req . Header . Set ( "X-PeerURLs" , strings . Join ( peerURLs , "," ) ) }
226	func addRemoteFromRequest ( tr Transporter , r * http . Request ) { if from , err := types . IDFromString ( r . Header . Get ( "X-Server-From" ) ) ; err == nil { if urls := r . Header . Get ( "X-PeerURLs" ) ; urls != "" { tr . AddRemote ( from , strings . Split ( urls , "," ) ) } } }
227	func NewKeysAPIWithPrefix ( c Client , p string ) KeysAPI { return & httpKeysAPI { client : c , prefix : p , } }
228	func ( n * Node ) TTLDuration ( ) time . Duration { return time . Duration ( n . TTL ) * time . Second }
229	func SetPflagsFromEnv ( prefix string , fs * pflag . FlagSet ) error { var err error alreadySet := make ( map [ string ] bool ) usedEnvKey := make ( map [ string ] bool ) fs . VisitAll ( func ( f * pflag . Flag ) { if f . Changed { alreadySet [ FlagToEnv ( prefix , f . Name ) ] = true } if serr := setFlagFromEnv ( fs , prefix , f . Name , usedEnvKey , alreadySet , false ) ; serr != nil { err = serr } } ) verifyEnv ( prefix , usedEnvKey , alreadySet ) return err }
230	func FlagToEnv ( prefix , name string ) string { return prefix + "_" + strings . ToUpper ( strings . Replace ( name , "-" , "_" , - 1 ) ) }
231	func excerpt ( str string , pre , suf int ) string { if pre + suf > len ( str ) { return fmt . Sprintf ( "%q" , str ) } return fmt . Sprintf ( "%q...%q" , str [ : pre ] , str [ len ( str ) - suf : ] ) }
232	func passConfChange ( entry raftpb . Entry ) ( bool , string ) { return entry . Type == raftpb . EntryConfChange , "ConfigChange" }
233	func printInternalRaftRequest ( entry raftpb . Entry ) { var rr etcdserverpb . InternalRaftRequest if err := rr . Unmarshal ( entry . Data ) ; err == nil { fmt . Printf ( "%4d\t%10d\tnorm\t%s" , \t , \t , \t ) } }
234	func listEntriesType ( entrytype string , streamdecoder string , ents [ ] raftpb . Entry ) { entryFilters := evaluateEntrytypeFlag ( entrytype ) printerMap := map [ string ] EntryPrinter { "InternalRaftRequest" : printInternalRaftRequest , "Request" : printRequest , "ConfigChange" : printConfChange , "UnknownNormal" : printUnknownNormal } var stderr bytes . Buffer args := strings . Split ( streamdecoder , " " ) cmd := exec . Command ( args [ 0 ] , args [ 1 : ] ... ) stdin , err := cmd . StdinPipe ( ) if err != nil { log . Panic ( err ) } stdout , err := cmd . StdoutPipe ( ) if err != nil { log . Panic ( err ) } cmd . Stderr = & stderr if streamdecoder != "" { err = cmd . Start ( ) if err != nil { log . Panic ( err ) } } cnt := 0 for _ , e := range ents { passed := false currtype := "" for _ , filter := range entryFilters { passed , currtype = filter ( e ) if passed { cnt ++ break } } if passed { printer := printerMap [ currtype ] printer ( e ) if streamdecoder == "" { fmt . Println ( ) continue } io . WriteString ( stdin , hex . EncodeToString ( e . Data ) ) io . WriteString ( stdin , "\n" ) \n outputReader := bufio . NewReader ( stdout ) decoderoutput , currerr := outputReader . ReadString ( '\n' ) if currerr != nil { fmt . Println ( currerr ) return } decoder_status , decoded_data := parseDecoderOutput ( decoderoutput ) } } fmt . Printf ( "\t%s\t%s" , \t , \t ) decoder_status decoded_data stdin . Close ( ) }
235	func newLog ( storage Storage , logger Logger ) * raftLog { return newLogWithSize ( storage , logger , noLimit ) }
236	func newLogWithSize ( storage Storage , logger Logger , maxNextEntsSize uint64 ) * raftLog { if storage == nil { log . Panic ( "storage must not be nil" ) } log := & raftLog { storage : storage , logger : logger , maxNextEntsSize : maxNextEntsSize , } firstIndex , err := storage . FirstIndex ( ) if err != nil { panic ( err ) } lastIndex , err := storage . LastIndex ( ) if err != nil { panic ( err ) } log . unstable . offset = lastIndex + 1 log . unstable . logger = logger log . committed = firstIndex - 1 log . applied = firstIndex - 1 return log }
237	func ( l * raftLog ) findConflict ( ents [ ] pb . Entry ) uint64 { for _ , ne := range ents { if ! l . matchTerm ( ne . Index , ne . Term ) { if ne . Index <= l . lastIndex ( ) { l . logger . Infof ( "found conflict at index %d [existing term: %d, conflicting term: %d]" , ne . Index , l . zeroTermOnErrCompacted ( l . term ( ne . Index ) ) , ne . Term ) } return ne . Index } } return 0 }
238	func ( l * raftLog ) nextEnts ( ) ( ents [ ] pb . Entry ) { off := max ( l . applied + 1 , l . firstIndex ( ) ) if l . committed + 1 > off { ents , err := l . slice ( off , l . committed + 1 , l . maxNextEntsSize ) if err != nil { l . logger . Panicf ( "unexpected error when getting unapplied entries (%v)" , err ) } return ents } return nil }
239	func ( l * raftLog ) allEntries ( ) [ ] pb . Entry { ents , err := l . entries ( l . firstIndex ( ) , noLimit ) if err == nil { return ents } if err == ErrCompacted { return l . allEntries ( ) } panic ( err ) }
240	func ( l * raftLog ) slice ( lo , hi , maxSize uint64 ) ( [ ] pb . Entry , error ) { err := l . mustCheckOutOfBounds ( lo , hi ) if err != nil { return nil , err } if lo == hi { return nil , nil } var ents [ ] pb . Entry if lo < l . unstable . offset { storedEnts , err := l . storage . Entries ( lo , min ( hi , l . unstable . offset ) , maxSize ) if err == ErrCompacted { return nil , err } else if err == ErrUnavailable { l . logger . Panicf ( "entries[%d:%d) is unavailable from storage" , lo , min ( hi , l . unstable . offset ) ) } else if err != nil { panic ( err ) } if uint64 ( len ( storedEnts ) ) < min ( hi , l . unstable . offset ) - lo { return storedEnts , nil } ents = storedEnts } if hi > l . unstable . offset { unstable := l . unstable . slice ( max ( lo , l . unstable . offset ) , hi ) if len ( ents ) > 0 { combined := make ( [ ] pb . Entry , len ( ents ) + len ( unstable ) ) n := copy ( combined , ents ) copy ( combined [ n : ] , unstable ) ents = combined } else { ents = unstable } } return limitSize ( ents , maxSize ) , nil }
241	func NewSession ( client * v3 . Client , opts ... SessionOption ) ( * Session , error ) { ops := & sessionOptions { ttl : defaultSessionTTL , ctx : client . Ctx ( ) } for _ , opt := range opts { opt ( ops ) } id := ops . leaseID if id == v3 . NoLease { resp , err := client . Grant ( ops . ctx , int64 ( ops . ttl ) ) if err != nil { return nil , err } id = v3 . LeaseID ( resp . ID ) } ctx , cancel := context . WithCancel ( ops . ctx ) keepAlive , err := client . KeepAlive ( ctx , id ) if err != nil || keepAlive == nil { cancel ( ) return nil , err } donec := make ( chan struct { } ) s := & Session { client : client , opts : ops , id : id , cancel : cancel , donec : donec } go func ( ) { defer close ( donec ) for range keepAlive { } } ( ) return s , nil }
242	func ( s * Session ) Close ( ) error { s . Orphan ( ) ctx , cancel := context . WithTimeout ( s . opts . ctx , time . Duration ( s . opts . ttl ) * time . Second ) _ , err := s . client . Revoke ( ctx , s . id ) cancel ( ) return err }
243	func WithTTL ( ttl int ) SessionOption { return func ( so * sessionOptions ) { if ttl > 0 { so . ttl = ttl } } }
244	func WithLease ( leaseID v3 . LeaseID ) SessionOption { return func ( so * sessionOptions ) { so . leaseID = leaseID } }
245	func ( ro * readOnly ) addRequest ( index uint64 , m pb . Message ) { ctx := string ( m . Entries [ 0 ] . Data ) if _ , ok := ro . pendingReadIndex [ ctx ] ; ok { return } ro . pendingReadIndex [ ctx ] = & readIndexStatus { index : index , req : m , acks : make ( map [ uint64 ] struct { } ) } ro . readIndexQueue = append ( ro . readIndexQueue , ctx ) }
246	func ( ro * readOnly ) recvAck ( m pb . Message ) int { rs , ok := ro . pendingReadIndex [ string ( m . Context ) ] if ! ok { return 0 } rs . acks [ m . From ] = struct { } { } return len ( rs . acks ) + 1 }
247	func ( ro * readOnly ) advance ( m pb . Message ) [ ] * readIndexStatus { var ( i int found bool ) ctx := string ( m . Context ) rss := [ ] * readIndexStatus { } for _ , okctx := range ro . readIndexQueue { i ++ rs , ok := ro . pendingReadIndex [ okctx ] if ! ok { panic ( "cannot find corresponding read state from pending map" ) } rss = append ( rss , rs ) if okctx == ctx { found = true break } } if found { ro . readIndexQueue = ro . readIndexQueue [ i : ] for _ , rs := range rss { delete ( ro . pendingReadIndex , string ( rs . req . Entries [ 0 ] . Data ) ) } return rss } return nil }
248	func ( ro * readOnly ) lastPendingRequestCtx ( ) string { if len ( ro . readIndexQueue ) == 0 { return "" } return ro . readIndexQueue [ len ( ro . readIndexQueue ) - 1 ] }
249	func ( s * EtcdServer ) Start ( ) { s . start ( ) s . goAttach ( func ( ) { s . adjustTicks ( ) } ) s . goAttach ( func ( ) { s . publish ( s . Cfg . ReqTimeout ( ) ) } ) s . goAttach ( s . purgeFile ) s . goAttach ( func ( ) { monitorFileDescriptor ( s . getLogger ( ) , s . stopping ) } ) s . goAttach ( s . monitorVersions ) s . goAttach ( s . linearizableReadLoop ) s . goAttach ( s . monitorKVHash ) }
250	func ( s * EtcdServer ) start ( ) { lg := s . getLogger ( ) if s . Cfg . SnapshotCount == 0 { if lg != nil { lg . Info ( "updating snapshot-count to default" , zap . Uint64 ( "given-snapshot-count" , s . Cfg . SnapshotCount ) , zap . Uint64 ( "updated-snapshot-count" , DefaultSnapshotCount ) , ) } else { plog . Infof ( "set snapshot count to default %d" , DefaultSnapshotCount ) } s . Cfg . SnapshotCount = DefaultSnapshotCount } if s . Cfg . SnapshotCatchUpEntries == 0 { if lg != nil { lg . Info ( "updating snapshot catch-up entries to default" , zap . Uint64 ( "given-snapshot-catchup-entries" , s . Cfg . SnapshotCatchUpEntries ) , zap . Uint64 ( "updated-snapshot-catchup-entries" , DefaultSnapshotCatchUpEntries ) , ) } s . Cfg . SnapshotCatchUpEntries = DefaultSnapshotCatchUpEntries } s . w = wait . New ( ) s . applyWait = wait . NewTimeList ( ) s . done = make ( chan struct { } ) s . stop = make ( chan struct { } ) s . stopping = make ( chan struct { } ) s . ctx , s . cancel = context . WithCancel ( context . Background ( ) ) s . readwaitc = make ( chan struct { } , 1 ) s . readNotifier = newNotifier ( ) s . leaderChanged = make ( chan struct { } ) if s . ClusterVersion ( ) != nil { if lg != nil { lg . Info ( "starting etcd server" , zap . String ( "local-member-id" , s . ID ( ) . String ( ) ) , zap . String ( "local-server-version" , version . Version ) , zap . String ( "cluster-id" , s . Cluster ( ) . ID ( ) . String ( ) ) , zap . String ( "cluster-version" , version . Cluster ( s . ClusterVersion ( ) . String ( ) ) ) , ) } else { plog . Infof ( "starting server... [version: %v, cluster version: %v]" , version . Version , version . Cluster ( s . ClusterVersion ( ) . String ( ) ) ) } membership . ClusterVersionMetrics . With ( prometheus . Labels { "cluster_version" : s . ClusterVersion ( ) . String ( ) } ) . Set ( 1 ) } else { if lg != nil { lg . Info ( "starting etcd server" , zap . String ( "local-member-id" , s . ID ( ) . String ( ) ) , zap . String ( "local-server-version" , version . Version ) , zap . String ( "cluster-version" , "to_be_decided" ) , ) } else { plog . Infof ( "starting server... [version: %v, cluster version: to_be_decided]" , version . Version ) } } go s . run ( ) }
251	func ( s * EtcdServer ) Process ( ctx context . Context , m raftpb . Message ) error { if s . cluster . IsIDRemoved ( types . ID ( m . From ) ) { if lg := s . getLogger ( ) ; lg != nil { lg . Warn ( "rejected Raft message from removed member" , zap . String ( "local-member-id" , s . ID ( ) . String ( ) ) , zap . String ( "removed-member-id" , types . ID ( m . From ) . String ( ) ) , ) } else { plog . Warningf ( "reject message from removed member %s" , types . ID ( m . From ) . String ( ) ) } return httptypes . NewHTTPError ( http . StatusForbidden , "cannot process message from removed member" ) } if m . Type == raftpb . MsgApp { s . stats . RecvAppendReq ( types . ID ( m . From ) . String ( ) , m . Size ( ) ) } return s . r . Step ( ctx , m ) }
252	func ( s * EtcdServer ) ReportSnapshot ( id uint64 , status raft . SnapshotStatus ) { s . r . ReportSnapshot ( id , status ) }
253	func ( s * EtcdServer ) MoveLeader ( ctx context . Context , lead , transferee uint64 ) error { now := time . Now ( ) interval := time . Duration ( s . Cfg . TickMs ) * time . Millisecond if lg := s . getLogger ( ) ; lg != nil { lg . Info ( "leadership transfer starting" , zap . String ( "local-member-id" , s . ID ( ) . String ( ) ) , zap . String ( "current-leader-member-id" , types . ID ( lead ) . String ( ) ) , zap . String ( "transferee-member-id" , types . ID ( transferee ) . String ( ) ) , ) } else { plog . Infof ( "%s starts leadership transfer from %s to %s" , s . ID ( ) , types . ID ( lead ) , types . ID ( transferee ) ) } s . r . TransferLeadership ( ctx , lead , transferee ) for s . Lead ( ) != transferee { select { case <- ctx . Done ( ) : return ErrTimeoutLeaderTransfer case <- time . After ( interval ) : } } if lg := s . getLogger ( ) ; lg != nil { lg . Info ( "leadership transfer finished" , zap . String ( "local-member-id" , s . ID ( ) . String ( ) ) , zap . String ( "old-leader-member-id" , types . ID ( lead ) . String ( ) ) , zap . String ( "new-leader-member-id" , types . ID ( transferee ) . String ( ) ) , zap . Duration ( "took" , time . Since ( now ) ) , ) } else { plog . Infof ( "%s finished leadership transfer from %s to %s (took %v)" , s . ID ( ) , types . ID ( lead ) , types . ID ( transferee ) , time . Since ( now ) ) } return nil }
254	func ( s * EtcdServer ) TransferLeadership ( ) error { if ! s . isLeader ( ) { if lg := s . getLogger ( ) ; lg != nil { lg . Info ( "skipped leadership transfer; local server is not leader" , zap . String ( "local-member-id" , s . ID ( ) . String ( ) ) , zap . String ( "current-leader-member-id" , types . ID ( s . Lead ( ) ) . String ( ) ) , ) } else { plog . Printf ( "skipped leadership transfer for stopping non-leader member" ) } return nil } if ! s . isMultiNode ( ) { if lg := s . getLogger ( ) ; lg != nil { lg . Info ( "skipped leadership transfer; it's a single-node cluster" , zap . String ( "local-member-id" , s . ID ( ) . String ( ) ) , zap . String ( "current-leader-member-id" , types . ID ( s . Lead ( ) ) . String ( ) ) , ) } else { plog . Printf ( "skipped leadership transfer for single member cluster" ) } return nil } transferee , ok := longestConnected ( s . r . transport , s . cluster . MemberIDs ( ) ) if ! ok { return ErrUnhealthy } tm := s . Cfg . ReqTimeout ( ) ctx , cancel := context . WithTimeout ( s . ctx , tm ) err := s . MoveLeader ( ctx , s . Lead ( ) , uint64 ( transferee ) ) cancel ( ) return err }
255	func ( s * EtcdServer ) configure ( ctx context . Context , cc raftpb . ConfChange ) ( [ ] * membership . Member , error ) { cc . ID = s . reqIDGen . Next ( ) ch := s . w . Register ( cc . ID ) start := time . Now ( ) if err := s . r . ProposeConfChange ( ctx , cc ) ; err != nil { s . w . Trigger ( cc . ID , nil ) return nil , err } select { case x := <- ch : if x == nil { if lg := s . getLogger ( ) ; lg != nil { lg . Panic ( "failed to configure" ) } else { plog . Panicf ( "configure trigger value should never be nil" ) } } resp := x . ( * confChangeResponse ) if lg := s . getLogger ( ) ; lg != nil { lg . Info ( "applied a configuration change through raft" , zap . String ( "local-member-id" , s . ID ( ) . String ( ) ) , zap . String ( "raft-conf-change" , cc . Type . String ( ) ) , zap . String ( "raft-conf-change-node-id" , types . ID ( cc . NodeID ) . String ( ) ) , ) } return resp . membs , resp . err case <- ctx . Done ( ) : s . w . Trigger ( cc . ID , nil ) return nil , s . parseProposeCtxErr ( ctx . Err ( ) , start ) case <- s . stopping : return nil , ErrStopped } }
256	func ( s * EtcdServer ) sync ( timeout time . Duration ) { req := pb . Request { Method : "SYNC" , ID : s . reqIDGen . Next ( ) , Time : time . Now ( ) . UnixNano ( ) , } data := pbutil . MustMarshal ( & req ) ctx , cancel := context . WithTimeout ( s . ctx , timeout ) s . goAttach ( func ( ) { s . r . Propose ( ctx , data ) cancel ( ) } ) }
257	func ( s * EtcdServer ) publish ( timeout time . Duration ) { b , err := json . Marshal ( s . attributes ) if err != nil { if lg := s . getLogger ( ) ; lg != nil { lg . Panic ( "failed to marshal JSON" , zap . Error ( err ) ) } else { plog . Panicf ( "json marshal error: %v" , err ) } return } req := pb . Request { Method : "PUT" , Path : membership . MemberAttributesStorePath ( s . id ) , Val : string ( b ) , } for { ctx , cancel := context . WithTimeout ( s . ctx , timeout ) _ , err := s . Do ( ctx , req ) cancel ( ) switch err { case nil : close ( s . readych ) if lg := s . getLogger ( ) ; lg != nil { lg . Info ( "published local member to cluster through raft" , zap . String ( "local-member-id" , s . ID ( ) . String ( ) ) , zap . String ( "local-member-attributes" , fmt . Sprintf ( "%+v" , s . attributes ) ) , zap . String ( "request-path" , req . Path ) , zap . String ( "cluster-id" , s . cluster . ID ( ) . String ( ) ) , zap . Duration ( "publish-timeout" , timeout ) , ) } else { plog . Infof ( "published %+v to cluster %s" , s . attributes , s . cluster . ID ( ) ) } return case ErrStopped : if lg := s . getLogger ( ) ; lg != nil { lg . Warn ( "stopped publish because server is stopped" , zap . String ( "local-member-id" , s . ID ( ) . String ( ) ) , zap . String ( "local-member-attributes" , fmt . Sprintf ( "%+v" , s . attributes ) ) , zap . Duration ( "publish-timeout" , timeout ) , zap . Error ( err ) , ) } else { plog . Infof ( "aborting publish because server is stopped" ) } return default : if lg := s . getLogger ( ) ; lg != nil { lg . Warn ( "failed to publish local member to cluster through raft" , zap . String ( "local-member-id" , s . ID ( ) . String ( ) ) , zap . String ( "local-member-attributes" , fmt . Sprintf ( "%+v" , s . attributes ) ) , zap . String ( "request-path" , req . Path ) , zap . Duration ( "publish-timeout" , timeout ) , zap . Error ( err ) , ) } else { plog . Errorf ( "publish error: %v" , err ) } } } }
258	func ( s * EtcdServer ) applyEntryNormal ( e * raftpb . Entry ) { shouldApplyV3 := false if e . Index > s . consistIndex . ConsistentIndex ( ) { s . consistIndex . setConsistentIndex ( e . Index ) shouldApplyV3 = true } if len ( e . Data ) == 0 { select { case s . forceVersionC <- struct { } { } : default : } if s . isLeader ( ) { s . lessor . Promote ( s . Cfg . electionTimeout ( ) ) } return } var raftReq pb . InternalRaftRequest if ! pbutil . MaybeUnmarshal ( & raftReq , e . Data ) { var r pb . Request rp := & r pbutil . MustUnmarshal ( rp , e . Data ) s . w . Trigger ( r . ID , s . applyV2Request ( ( * RequestV2 ) ( rp ) ) ) return } if raftReq . V2 != nil { req := ( * RequestV2 ) ( raftReq . V2 ) s . w . Trigger ( req . ID , s . applyV2Request ( req ) ) return } if ! shouldApplyV3 { return } id := raftReq . ID if id == 0 { id = raftReq . Header . ID } var ar * applyResult needResult := s . w . IsRegistered ( id ) if needResult || ! noSideEffect ( & raftReq ) { if ! needResult && raftReq . Txn != nil { removeNeedlessRangeReqs ( raftReq . Txn ) } ar = s . applyV3 . Apply ( & raftReq ) } if ar == nil { return } if ar . err != ErrNoSpace || len ( s . alarmStore . Get ( pb . AlarmType_NOSPACE ) ) > 0 { s . w . Trigger ( id , ar ) return } if lg := s . getLogger ( ) ; lg != nil { lg . Warn ( "message exceeded backend quota; raising alarm" , zap . Int64 ( "quota-size-bytes" , s . Cfg . QuotaBackendBytes ) , zap . String ( "quota-size" , humanize . Bytes ( uint64 ( s . Cfg . QuotaBackendBytes ) ) ) , zap . Error ( ar . err ) , ) } else { plog . Errorf ( "applying raft message exceeded backend quota" ) } s . goAttach ( func ( ) { a := & pb . AlarmRequest { MemberID : uint64 ( s . ID ( ) ) , Action : pb . AlarmRequest_ACTIVATE , Alarm : pb . AlarmType_NOSPACE , } s . raftRequest ( s . ctx , pb . InternalRaftRequest { Alarm : a } ) s . w . Trigger ( id , ar ) } ) }
259	func ( s * EtcdServer ) applyConfChange ( cc raftpb . ConfChange , confState * raftpb . ConfState ) ( bool , error ) { if err := s . cluster . ValidateConfigurationChange ( cc ) ; err != nil { cc . NodeID = raft . None s . r . ApplyConfChange ( cc ) return false , err } lg := s . getLogger ( ) * confState = * s . r . ApplyConfChange ( cc ) switch cc . Type { case raftpb . ConfChangeAddNode : m := new ( membership . Member ) if err := json . Unmarshal ( cc . Context , m ) ; err != nil { if lg != nil { lg . Panic ( "failed to unmarshal member" , zap . Error ( err ) ) } else { plog . Panicf ( "unmarshal member should never fail: %v" , err ) } } if cc . NodeID != uint64 ( m . ID ) { if lg != nil { lg . Panic ( "got different member ID" , zap . String ( "member-id-from-config-change-entry" , types . ID ( cc . NodeID ) . String ( ) ) , zap . String ( "member-id-from-message" , m . ID . String ( ) ) , ) } else { plog . Panicf ( "nodeID should always be equal to member ID" ) } } s . cluster . AddMember ( m ) if m . ID != s . id { s . r . transport . AddPeer ( m . ID , m . PeerURLs ) } case raftpb . ConfChangeRemoveNode : id := types . ID ( cc . NodeID ) s . cluster . RemoveMember ( id ) if id == s . id { return true , nil } s . r . transport . RemovePeer ( id ) case raftpb . ConfChangeUpdateNode : m := new ( membership . Member ) if err := json . Unmarshal ( cc . Context , m ) ; err != nil { if lg != nil { lg . Panic ( "failed to unmarshal member" , zap . Error ( err ) ) } else { plog . Panicf ( "unmarshal member should never fail: %v" , err ) } } if cc . NodeID != uint64 ( m . ID ) { if lg != nil { lg . Panic ( "got different member ID" , zap . String ( "member-id-from-config-change-entry" , types . ID ( cc . NodeID ) . String ( ) ) , zap . String ( "member-id-from-message" , m . ID . String ( ) ) , ) } else { plog . Panicf ( "nodeID should always be equal to member ID" ) } } s . cluster . UpdateRaftAttributes ( m . ID , m . RaftAttributes ) if m . ID != s . id { s . r . transport . UpdatePeer ( m . ID , m . PeerURLs ) } } return false , nil }
260	func ( s * EtcdServer ) monitorVersions ( ) { for { select { case <- s . forceVersionC : case <- time . After ( monitorVersionInterval ) : case <- s . stopping : return } if s . Leader ( ) != s . ID ( ) { continue } v := decideClusterVersion ( s . getLogger ( ) , getVersions ( s . getLogger ( ) , s . cluster , s . id , s . peerRt ) ) if v != nil { v = & semver . Version { Major : v . Major , Minor : v . Minor , } } if s . cluster . Version ( ) == nil { verStr := version . MinClusterVersion if v != nil { verStr = v . String ( ) } s . goAttach ( func ( ) { s . updateClusterVersion ( verStr ) } ) continue } if v != nil && s . cluster . Version ( ) . LessThan ( * v ) { s . goAttach ( func ( ) { s . updateClusterVersion ( v . String ( ) ) } ) } } }
261	func ( s * EtcdServer ) goAttach ( f func ( ) ) { s . wgMu . RLock ( ) defer s . wgMu . RUnlock ( ) select { case <- s . stopping : if lg := s . getLogger ( ) ; lg != nil { lg . Warn ( "server has stopped; skipping goAttach" ) } else { plog . Warning ( "server has stopped (skipping goAttach)" ) } return default : } s . wg . Add ( 1 ) go func ( ) { defer s . wg . Done ( ) f ( ) } ( ) }
262	func NewRoundrobinBalanced ( lg * zap . Logger , scs [ ] balancer . SubConn , addrToSc map [ resolver . Address ] balancer . SubConn , scToAddr map [ balancer . SubConn ] resolver . Address , ) Picker { return & rrBalanced { lg : lg , scs : scs , addrToSc : addrToSc , scToAddr : scToAddr , } }
263	func ( rb * rrBalanced ) Pick ( ctx context . Context , opts balancer . PickOptions ) ( balancer . SubConn , func ( balancer . DoneInfo ) , error ) { rb . mu . RLock ( ) n := len ( rb . scs ) rb . mu . RUnlock ( ) if n == 0 { return nil , nil , balancer . ErrNoSubConnAvailable } rb . mu . Lock ( ) cur := rb . next sc := rb . scs [ cur ] picked := rb . scToAddr [ sc ] . Addr rb . next = ( rb . next + 1 ) % len ( rb . scs ) rb . mu . Unlock ( ) rb . lg . Debug ( "picked" , zap . String ( "address" , picked ) , zap . Int ( "subconn-index" , cur ) , zap . Int ( "subconn-size" , n ) , ) doneFunc := func ( info balancer . DoneInfo ) { fss := [ ] zapcore . Field { zap . Error ( info . Err ) , zap . String ( "address" , picked ) , zap . Bool ( "success" , info . Err == nil ) , zap . Bool ( "bytes-sent" , info . BytesSent ) , zap . Bool ( "bytes-received" , info . BytesReceived ) , } if info . Err == nil { rb . lg . Debug ( "balancer done" , fss ... ) } else { rb . lg . Warn ( "balancer failed" , fss ... ) } } return sc , doneFunc , nil }
264	func NewTLSListener ( l net . Listener , tlsinfo * TLSInfo ) ( net . Listener , error ) { check := func ( context . Context , * tls . Conn ) error { return nil } return newTLSListener ( l , tlsinfo , check ) }
265	func ( l * tlsListener ) acceptLoop ( ) { var wg sync . WaitGroup var pendingMu sync . Mutex pending := make ( map [ net . Conn ] struct { } ) ctx , cancel := context . WithCancel ( context . Background ( ) ) defer func ( ) { cancel ( ) pendingMu . Lock ( ) for c := range pending { c . Close ( ) } pendingMu . Unlock ( ) wg . Wait ( ) close ( l . donec ) } ( ) for { conn , err := l . Listener . Accept ( ) if err != nil { l . err = err return } pendingMu . Lock ( ) pending [ conn ] = struct { } { } pendingMu . Unlock ( ) wg . Add ( 1 ) go func ( ) { defer func ( ) { if conn != nil { conn . Close ( ) } wg . Done ( ) } ( ) tlsConn := conn . ( * tls . Conn ) herr := tlsConn . Handshake ( ) pendingMu . Lock ( ) delete ( pending , conn ) pendingMu . Unlock ( ) if herr != nil { l . handshakeFailure ( tlsConn , herr ) return } if err := l . check ( ctx , tlsConn ) ; err != nil { l . handshakeFailure ( tlsConn , err ) return } select { case l . connc <- tlsConn : conn = nil case <- ctx . Done ( ) : } } ( ) } }
266	func ( e * ResolverGroup ) SetEndpoints ( endpoints [ ] string ) { addrs := epsToAddrs ( endpoints ... ) e . mu . Lock ( ) e . endpoints = endpoints for _ , r := range e . resolvers { r . cc . NewAddress ( addrs ) } e . mu . Unlock ( ) }
267	func ( e * ResolverGroup ) Target ( endpoint string ) string { return Target ( e . id , endpoint ) }
268	func Target ( id , endpoint string ) string { return fmt . Sprintf ( "%s://%s/%s" , scheme , id , endpoint ) }
269	func ( b * builder ) Build ( target resolver . Target , cc resolver . ClientConn , opts resolver . BuildOption ) ( resolver . Resolver , error ) { if len ( target . Authority ) < 1 { return nil , fmt . Errorf ( "'etcd' target scheme requires non-empty authority identifying etcd cluster being routed to" ) } id := target . Authority es , err := b . getResolverGroup ( id ) if err != nil { return nil , fmt . Errorf ( "failed to build resolver: %v" , err ) } r := & Resolver { endpointID : id , cc : cc , } es . addResolver ( r ) return r , nil }
270	func ( r * RequestV2 ) Handle ( ctx context . Context , v2api RequestV2Handler ) ( Response , error ) { if r . Method == "GET" && r . Quorum { r . Method = "QGET" } switch r . Method { case "POST" : return v2api . Post ( ctx , r ) case "PUT" : return v2api . Put ( ctx , r ) case "DELETE" : return v2api . Delete ( ctx , r ) case "QGET" : return v2api . QGet ( ctx , r ) case "GET" : return v2api . Get ( ctx , r ) case "HEAD" : return v2api . Head ( ctx , r ) } return Response { } , ErrUnknownMethod }
271	func NewElectionCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "election [election name (defaults to 'elector')]" , Short : "Performs election operation" , Run : runElectionFunc , } cmd . Flags ( ) . IntVar ( & totalClientConnections , "total-client-connections" , 10 , "total number of client connections" ) return cmd }
272	func nodeToMember ( n * v2store . NodeExtern ) ( * Member , error ) { m := & Member { ID : MustParseMemberIDFromKey ( n . Key ) } attrs := make ( map [ string ] [ ] byte ) raftAttrKey := path . Join ( n . Key , raftAttributesSuffix ) attrKey := path . Join ( n . Key , attributesSuffix ) for _ , nn := range n . Nodes { if nn . Key != raftAttrKey && nn . Key != attrKey { return nil , fmt . Errorf ( "unknown key %q" , nn . Key ) } attrs [ nn . Key ] = [ ] byte ( * nn . Value ) } if data := attrs [ raftAttrKey ] ; data != nil { if err := json . Unmarshal ( data , & m . RaftAttributes ) ; err != nil { return nil , fmt . Errorf ( "unmarshal raftAttributes error: %v" , err ) } } else { return nil , fmt . Errorf ( "raftAttributes key doesn't exist" ) } if data := attrs [ attrKey ] ; data != nil { if err := json . Unmarshal ( data , & m . Attributes ) ; err != nil { return m , fmt . Errorf ( "unmarshal attributes error: %v" , err ) } } return m , nil }
273	func NewTmpBackend ( batchInterval time . Duration , batchLimit int ) ( * backend , string ) { dir , err := ioutil . TempDir ( os . TempDir ( ) , "etcd_backend_test" ) if err != nil { panic ( err ) } tmpPath := filepath . Join ( dir , "database" ) bcfg := DefaultBackendConfig ( ) bcfg . Path , bcfg . BatchInterval , bcfg . BatchLimit = tmpPath , batchInterval , batchLimit return newBackend ( bcfg ) , tmpPath }
274	func newRevision ( lg * zap . Logger , clock clockwork . Clock , retention int64 , rg RevGetter , c Compactable ) * Revision { rc := & Revision { lg : lg , clock : clock , retention : retention , rg : rg , c : c , } rc . ctx , rc . cancel = context . WithCancel ( context . Background ( ) ) return rc }
275	func ( rc * Revision ) Run ( ) { prev := int64 ( 0 ) go func ( ) { for { select { case <- rc . ctx . Done ( ) : return case <- rc . clock . After ( revInterval ) : rc . mu . Lock ( ) p := rc . paused rc . mu . Unlock ( ) if p { continue } } rev := rc . rg . Rev ( ) - rc . retention if rev <= 0 || rev == prev { continue } now := time . Now ( ) if rc . lg != nil { rc . lg . Info ( "starting auto revision compaction" , zap . Int64 ( "revision" , rev ) , zap . Int64 ( "revision-compaction-retention" , rc . retention ) , ) } else { plog . Noticef ( "Starting auto-compaction at revision %d (retention: %d revisions)" , rev , rc . retention ) } _ , err := rc . c . Compact ( rc . ctx , & pb . CompactionRequest { Revision : rev } ) if err == nil || err == mvcc . ErrCompacted { prev = rev if rc . lg != nil { rc . lg . Info ( "completed auto revision compaction" , zap . Int64 ( "revision" , rev ) , zap . Int64 ( "revision-compaction-retention" , rc . retention ) , zap . Duration ( "took" , time . Since ( now ) ) , ) } else { plog . Noticef ( "Finished auto-compaction at revision %d" , rev ) } } else { if rc . lg != nil { rc . lg . Warn ( "failed auto revision compaction" , zap . Int64 ( "revision" , rev ) , zap . Int64 ( "revision-compaction-retention" , rc . retention ) , zap . Duration ( "retry-interval" , revInterval ) , zap . Error ( err ) , ) } else { plog . Noticef ( "Failed auto-compaction at revision %d (%v)" , rev , err ) plog . Noticef ( "Retry after %v" , revInterval ) } } } } ( ) }
276	func ( rc * Revision ) Pause ( ) { rc . mu . Lock ( ) rc . paused = true rc . mu . Unlock ( ) }
277	func ( rc * Revision ) Resume ( ) { rc . mu . Lock ( ) rc . paused = false rc . mu . Unlock ( ) }
278	func voteRespMsgType ( msgt pb . MessageType ) pb . MessageType { switch msgt { case pb . MsgVote : return pb . MsgVoteResp case pb . MsgPreVote : return pb . MsgPreVoteResp default : panic ( fmt . Sprintf ( "not a vote message: %s" , msgt ) ) } }
279	func DescribeMessage ( m pb . Message , f EntryFormatter ) string { var buf bytes . Buffer fmt . Fprintf ( & buf , "%x->%x %v Term:%d Log:%d/%d" , m . From , m . To , m . Type , m . Term , m . LogTerm , m . Index ) if m . Reject { fmt . Fprintf ( & buf , " Rejected (Hint: %d)" , m . RejectHint ) } if m . Commit != 0 { fmt . Fprintf ( & buf , " Commit:%d" , m . Commit ) } if len ( m . Entries ) > 0 { fmt . Fprintf ( & buf , " Entries:[" ) for i , e := range m . Entries { if i != 0 { buf . WriteString ( ", " ) } buf . WriteString ( DescribeEntry ( e , f ) ) } fmt . Fprintf ( & buf , "]" ) } if ! IsEmptySnap ( m . Snapshot ) { fmt . Fprintf ( & buf , " Snapshot:%v" , m . Snapshot ) } return buf . String ( ) }
280	func DescribeEntry ( e pb . Entry , f EntryFormatter ) string { var formatted string if e . Type == pb . EntryNormal && f != nil { formatted = f ( e . Data ) } else { formatted = fmt . Sprintf ( "%q" , e . Data ) } return fmt . Sprintf ( "%d/%d %s %s" , e . Term , e . Index , e . Type , formatted ) }
281	func DescribeEntries ( ents [ ] pb . Entry , f EntryFormatter ) string { var buf bytes . Buffer for _ , e := range ents { _ , _ = buf . WriteString ( DescribeEntry ( e , f ) + "\n" ) } \n }
282	func SetLogger ( l grpclog . LoggerV2 ) { lgMu . Lock ( ) lg = logutil . NewLogger ( l ) grpclog . SetLoggerV2 ( lg ) lgMu . Unlock ( ) }
283	func GetLogger ( ) logutil . Logger { lgMu . RLock ( ) l := lg lgMu . RUnlock ( ) return l }
284	func ( u * unstable ) maybeFirstIndex ( ) ( uint64 , bool ) { if u . snapshot != nil { return u . snapshot . Metadata . Index + 1 , true } return 0 , false }
285	func ( u * unstable ) maybeLastIndex ( ) ( uint64 , bool ) { if l := len ( u . entries ) ; l != 0 { return u . offset + uint64 ( l ) - 1 , true } if u . snapshot != nil { return u . snapshot . Metadata . Index , true } return 0 , false }
286	func ( u * unstable ) maybeTerm ( i uint64 ) ( uint64 , bool ) { if i < u . offset { if u . snapshot == nil { return 0 , false } if u . snapshot . Metadata . Index == i { return u . snapshot . Metadata . Term , true } return 0 , false } last , ok := u . maybeLastIndex ( ) if ! ok { return 0 , false } if i > last { return 0 , false } return u . entries [ i - u . offset ] . Term , true }
287	func ( u * unstable ) shrinkEntriesArray ( ) { const lenMultiple = 2 if len ( u . entries ) == 0 { u . entries = nil } else if len ( u . entries ) * lenMultiple < cap ( u . entries ) { newEntries := make ( [ ] pb . Entry , len ( u . entries ) ) copy ( newEntries , u . entries ) u . entries = newEntries } }
288	func ( st * storage ) SaveSnap ( snap raftpb . Snapshot ) error { walsnap := walpb . Snapshot { Index : snap . Metadata . Index , Term : snap . Metadata . Term , } err := st . WAL . SaveSnapshot ( walsnap ) if err != nil { return err } err = st . Snapshotter . SaveSnap ( snap ) if err != nil { return err } return st . WAL . ReleaseLockTo ( snap . Metadata . Index ) }
289	func New ( cfg Config ) ( * Client , error ) { if len ( cfg . Endpoints ) == 0 { return nil , ErrNoAvailableEndpoints } return newClient ( & cfg ) }
290	func NewCtxClient ( ctx context . Context ) * Client { cctx , cancel := context . WithCancel ( ctx ) return & Client { ctx : cctx , cancel : cancel } }
291	func NewFromURL ( url string ) ( * Client , error ) { return New ( Config { Endpoints : [ ] string { url } } ) }
292	func ( c * Client ) Close ( ) error { c . cancel ( ) c . Watcher . Close ( ) c . Lease . Close ( ) if c . resolverGroup != nil { c . resolverGroup . Close ( ) } if c . conn != nil { return toErr ( c . ctx , c . conn . Close ( ) ) } return c . ctx . Err ( ) }
293	func ( c * Client ) Endpoints ( ) [ ] string { c . mu . RLock ( ) defer c . mu . RUnlock ( ) eps := make ( [ ] string , len ( c . cfg . Endpoints ) ) copy ( eps , c . cfg . Endpoints ) return eps }
294	func ( c * Client ) SetEndpoints ( eps ... string ) { c . mu . Lock ( ) defer c . mu . Unlock ( ) c . cfg . Endpoints = eps c . resolverGroup . SetEndpoints ( eps ) }
295	func ( c * Client ) Sync ( ctx context . Context ) error { mresp , err := c . MemberList ( ctx ) if err != nil { return err } var eps [ ] string for _ , m := range mresp . Members { eps = append ( eps , m . ClientURLs ... ) } c . SetEndpoints ( eps ... ) return nil }
296	func ( c * Client ) dialSetupOpts ( creds * credentials . TransportCredentials , dopts ... grpc . DialOption ) ( opts [ ] grpc . DialOption , err error ) { if c . cfg . DialKeepAliveTime > 0 { params := keepalive . ClientParameters { Time : c . cfg . DialKeepAliveTime , Timeout : c . cfg . DialKeepAliveTimeout , PermitWithoutStream : c . cfg . PermitWithoutStream , } opts = append ( opts , grpc . WithKeepaliveParams ( params ) ) } opts = append ( opts , dopts ... ) f := func ( dialEp string , t time . Duration ) ( net . Conn , error ) { proto , host , _ := endpoint . ParseEndpoint ( dialEp ) select { case <- c . ctx . Done ( ) : return nil , c . ctx . Err ( ) default : } dialer := & net . Dialer { Timeout : t } return dialer . DialContext ( c . ctx , proto , host ) } opts = append ( opts , grpc . WithDialer ( f ) ) if creds != nil { opts = append ( opts , grpc . WithTransportCredentials ( * creds ) ) } else { opts = append ( opts , grpc . WithInsecure ( ) ) } rrBackoff := withBackoff ( c . roundRobinQuorumBackoff ( defaultBackoffWaitBetween , defaultBackoffJitterFraction ) ) opts = append ( opts , grpc . WithStreamInterceptor ( c . streamClientInterceptor ( c . lg , withMax ( 0 ) , rrBackoff ) ) , grpc . WithUnaryInterceptor ( c . unaryClientInterceptor ( c . lg , withMax ( defaultUnaryMaxRetries ) , rrBackoff ) ) , ) return opts , nil }
297	func ( c * Client ) Dial ( ep string ) ( * grpc . ClientConn , error ) { creds := c . directDialCreds ( ep ) return c . dial ( fmt . Sprintf ( "passthrough:///%s" , ep ) , creds ) }
298	func ( c * Client ) dialWithBalancer ( ep string , dopts ... grpc . DialOption ) ( * grpc . ClientConn , error ) { _ , host , _ := endpoint . ParseEndpoint ( ep ) target := c . resolverGroup . Target ( host ) creds := c . dialWithBalancerCreds ( ep ) return c . dial ( target , creds , dopts ... ) }
299	func ( c * Client ) dial ( target string , creds * credentials . TransportCredentials , dopts ... grpc . DialOption ) ( * grpc . ClientConn , error ) { opts , err := c . dialSetupOpts ( creds , dopts ... ) if err != nil { return nil , fmt . Errorf ( "failed to configure dialer: %v" , err ) } if c . Username != "" && c . Password != "" { c . tokenCred = & authTokenCredential { tokenMu : & sync . RWMutex { } , } ctx , cancel := c . ctx , func ( ) { } if c . cfg . DialTimeout > 0 { ctx , cancel = context . WithTimeout ( ctx , c . cfg . DialTimeout ) } err = c . getToken ( ctx ) if err != nil { if toErr ( ctx , err ) != rpctypes . ErrAuthNotEnabled { if err == ctx . Err ( ) && ctx . Err ( ) != c . ctx . Err ( ) { err = context . DeadlineExceeded } cancel ( ) return nil , err } } else { opts = append ( opts , grpc . WithPerRPCCredentials ( c . tokenCred ) ) } cancel ( ) } opts = append ( opts , c . cfg . DialOptions ... ) dctx := c . ctx if c . cfg . DialTimeout > 0 { var cancel context . CancelFunc dctx , cancel = context . WithTimeout ( c . ctx , c . cfg . DialTimeout ) defer cancel ( ) } conn , err := grpc . DialContext ( dctx , target , opts ... ) if err != nil { return nil , err } return conn , nil }
300	func WithRequireLeader ( ctx context . Context ) context . Context { md := metadata . Pairs ( rpctypes . MetadataRequireLeaderKey , rpctypes . MetadataHasLeader ) return metadata . NewOutgoingContext ( ctx , md ) }
301	func ( c * Client ) roundRobinQuorumBackoff ( waitBetween time . Duration , jitterFraction float64 ) backoffFunc { return func ( attempt uint ) time . Duration { n := uint ( len ( c . Endpoints ( ) ) ) quorum := ( n / 2 + 1 ) if attempt % quorum == 0 { c . lg . Debug ( "backoff" , zap . Uint ( "attempt" , attempt ) , zap . Uint ( "quorum" , quorum ) , zap . Duration ( "waitBetween" , waitBetween ) , zap . Float64 ( "jitterFraction" , jitterFraction ) ) return jitterUp ( waitBetween , jitterFraction ) } c . lg . Debug ( "backoff skipped" , zap . Uint ( "attempt" , attempt ) , zap . Uint ( "quorum" , quorum ) ) return 0 } }
302	func isHaltErr ( ctx context . Context , err error ) bool { if ctx != nil && ctx . Err ( ) != nil { return true } if err == nil { return false } ev , _ := status . FromError ( err ) return ev . Code ( ) != codes . Unavailable && ev . Code ( ) != codes . Internal }
303	func NewLease ( l clientv3 . Lease , prefix string ) clientv3 . Lease { return & leasePrefix { l , [ ] byte ( prefix ) } }
304	func ( e * Event ) IsCreate ( ) bool { return e . Type == EventTypePut && e . Kv . CreateRevision == e . Kv . ModRevision }
305	func ( wr * WatchResponse ) Err ( ) error { switch { case wr . closeErr != nil : return v3rpc . Error ( wr . closeErr ) case wr . CompactRevision != 0 : return v3rpc . ErrCompacted case wr . Canceled : if len ( wr . cancelReason ) != 0 { return v3rpc . Error ( status . Error ( codes . FailedPrecondition , wr . cancelReason ) ) } return v3rpc . ErrFutureRev } return nil }
306	func ( wr * WatchResponse ) IsProgressNotify ( ) bool { return len ( wr . Events ) == 0 && ! wr . Canceled && ! wr . Created && wr . CompactRevision == 0 && wr . Header . Revision != 0 }
307	func ( w * watcher ) RequestProgress ( ctx context . Context ) ( err error ) { ctxKey := streamKeyFromCtx ( ctx ) w . mu . Lock ( ) if w . streams == nil { return fmt . Errorf ( "no stream found for context" ) } wgs := w . streams [ ctxKey ] if wgs == nil { wgs = w . newWatcherGrpcStream ( ctx ) w . streams [ ctxKey ] = wgs } donec := wgs . donec reqc := wgs . reqc w . mu . Unlock ( ) pr := & progressRequest { } select { case reqc <- pr : return nil case <- ctx . Done ( ) : if err == nil { return ctx . Err ( ) } return err case <- donec : if wgs . closeErr != nil { return wgs . closeErr } return w . RequestProgress ( ctx ) } }
308	func ( w * watchGrpcStream ) nextResume ( ) * watcherStream { for len ( w . resuming ) != 0 { if w . resuming [ 0 ] != nil { return w . resuming [ 0 ] } w . resuming = w . resuming [ 1 : len ( w . resuming ) ] } return nil }
309	func ( w * watchGrpcStream ) dispatchEvent ( pbresp * pb . WatchResponse ) bool { events := make ( [ ] * Event , len ( pbresp . Events ) ) for i , ev := range pbresp . Events { events [ i ] = ( * Event ) ( ev ) } wr := & WatchResponse { Header : * pbresp . Header , Events : events , CompactRevision : pbresp . CompactRevision , Created : pbresp . Created , Canceled : pbresp . Canceled , cancelReason : pbresp . CancelReason , } if wr . IsProgressNotify ( ) && pbresp . WatchId == - 1 { return w . broadcastResponse ( wr ) } return w . unicastResponse ( wr , pbresp . WatchId ) }
310	func ( w * watchGrpcStream ) broadcastResponse ( wr * WatchResponse ) bool { for _ , ws := range w . substreams { select { case ws . recvc <- wr : case <- ws . donec : } } return true }
311	func ( w * watchGrpcStream ) unicastResponse ( wr * WatchResponse , watchId int64 ) bool { ws , ok := w . substreams [ watchId ] if ! ok { return false } select { case ws . recvc <- wr : case <- ws . donec : return false } return true }
312	func ( w * watchGrpcStream ) joinSubstreams ( ) { for _ , ws := range w . substreams { <- ws . donec } for _ , ws := range w . resuming { if ws != nil { <- ws . donec } } }
313	func ( wr * watchRequest ) toPB ( ) * pb . WatchRequest { req := & pb . WatchCreateRequest { StartRevision : wr . rev , Key : [ ] byte ( wr . key ) , RangeEnd : [ ] byte ( wr . end ) , ProgressNotify : wr . progressNotify , Filters : wr . filters , PrevKv : wr . prevKV , Fragment : wr . fragment , } cr := & pb . WatchRequest_CreateRequest { CreateRequest : req } return & pb . WatchRequest { RequestUnion : cr } }
314	func ( pr * progressRequest ) toPB ( ) * pb . WatchRequest { req := & pb . WatchProgressRequest { } cr := & pb . WatchRequest_ProgressRequest { ProgressRequest : req } return & pb . WatchRequest { RequestUnion : cr } }
315	func ( us * unsafeSet ) Contains ( value string ) ( exists bool ) { _ , exists = us . d [ value ] return exists }
316	func ( us * unsafeSet ) ContainsAll ( values [ ] string ) bool { for _ , s := range values { if ! us . Contains ( s ) { return false } } return true }
317	func ( us * unsafeSet ) Equals ( other Set ) bool { v1 := sort . StringSlice ( us . Values ( ) ) v2 := sort . StringSlice ( other . Values ( ) ) v1 . Sort ( ) v2 . Sort ( ) return reflect . DeepEqual ( v1 , v2 ) }
318	func ( us * unsafeSet ) Values ( ) ( values [ ] string ) { values = make ( [ ] string , 0 ) for val := range us . d { values = append ( values , val ) } return values }
319	func ( us * unsafeSet ) Copy ( ) Set { cp := NewUnsafeSet ( ) for val := range us . d { cp . Add ( val ) } return cp }
320	func ( us * unsafeSet ) Sub ( other Set ) Set { oValues := other . Values ( ) result := us . Copy ( ) . ( * unsafeSet ) for _ , val := range oValues { if _ , ok := result . d [ val ] ; ! ok { continue } delete ( result . d , val ) } return result }
321	func v2MembersURL ( ep url . URL ) * url . URL { ep . Path = path . Join ( ep . Path , defaultV2MembersPrefix ) return & ep }
322	func NewMigrateCommand ( ) * cobra . Command { mc := & cobra . Command { Use : "migrate" , Short : "Migrates keys in a v2 store to a mvcc store" , Run : migrateCommandFunc , } mc . Flags ( ) . BoolVar ( & migrateExcludeTTLKey , "no-ttl" , false , "Do not convert TTL keys" ) mc . Flags ( ) . StringVar ( & migrateDatadir , "data-dir" , "" , "Path to the data directory" ) mc . Flags ( ) . StringVar ( & migrateWALdir , "wal-dir" , "" , "Path to the WAL directory" ) mc . Flags ( ) . StringVar ( & migrateTransformer , "transformer" , "" , "Path to the user-provided transformer program" ) return mc }
323	func ( rc * raftNode ) publishEntries ( ents [ ] raftpb . Entry ) bool { for i := range ents { switch ents [ i ] . Type { case raftpb . EntryNormal : if len ( ents [ i ] . Data ) == 0 { break } s := string ( ents [ i ] . Data ) select { case rc . commitC <- & s : case <- rc . stopc : return false } case raftpb . EntryConfChange : var cc raftpb . ConfChange cc . Unmarshal ( ents [ i ] . Data ) rc . confState = * rc . node . ApplyConfChange ( cc ) switch cc . Type { case raftpb . ConfChangeAddNode : if len ( cc . Context ) > 0 { rc . transport . AddPeer ( types . ID ( cc . NodeID ) , [ ] string { string ( cc . Context ) } ) } case raftpb . ConfChangeRemoveNode : if cc . NodeID == uint64 ( rc . id ) { log . Println ( "I've been removed from the cluster! Shutting down." ) return false } rc . transport . RemovePeer ( types . ID ( cc . NodeID ) ) } } rc . appliedIndex = ents [ i ] . Index if ents [ i ] . Index == rc . lastIndex { select { case rc . commitC <- nil : case <- rc . stopc : return false } } } return true }
324	func ( rc * raftNode ) openWAL ( snapshot * raftpb . Snapshot ) * wal . WAL { if ! wal . Exist ( rc . waldir ) { if err := os . Mkdir ( rc . waldir , 0750 ) ; err != nil { log . Fatalf ( "raftexample: cannot create dir for wal (%v)" , err ) } w , err := wal . Create ( zap . NewExample ( ) , rc . waldir , nil ) if err != nil { log . Fatalf ( "raftexample: create wal error (%v)" , err ) } w . Close ( ) } walsnap := walpb . Snapshot { } if snapshot != nil { walsnap . Index , walsnap . Term = snapshot . Metadata . Index , snapshot . Metadata . Term } log . Printf ( "loading WAL at term %d and index %d" , walsnap . Term , walsnap . Index ) w , err := wal . Open ( zap . NewExample ( ) , rc . waldir , walsnap ) if err != nil { log . Fatalf ( "raftexample: error loading wal (%v)" , err ) } return w }
325	func ( rc * raftNode ) replayWAL ( ) * wal . WAL { log . Printf ( "replaying WAL of member %d" , rc . id ) snapshot := rc . loadSnapshot ( ) w := rc . openWAL ( snapshot ) _ , st , ents , err := w . ReadAll ( ) if err != nil { log . Fatalf ( "raftexample: failed to read WAL (%v)" , err ) } rc . raftStorage = raft . NewMemoryStorage ( ) if snapshot != nil { rc . raftStorage . ApplySnapshot ( * snapshot ) } rc . raftStorage . SetHardState ( st ) rc . raftStorage . Append ( ents ) if len ( ents ) > 0 { rc . lastIndex = ents [ len ( ents ) - 1 ] . Index } else { rc . commitC <- nil } return w }
326	func ( rc * raftNode ) stop ( ) { rc . stopHTTP ( ) close ( rc . commitC ) close ( rc . errorC ) rc . node . Stop ( ) }
327	func NewWatchCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "watch [options] [key or prefix] [range_end] [--] [exec-command arg1 arg2 ...]" , Short : "Watches events stream on keys or prefixes" , Run : watchCommandFunc , } cmd . Flags ( ) . BoolVarP ( & watchInteractive , "interactive" , "i" , false , "Interactive mode" ) cmd . Flags ( ) . BoolVar ( & watchPrefix , "prefix" , false , "Watch on a prefix if prefix is set" ) cmd . Flags ( ) . Int64Var ( & watchRev , "rev" , 0 , "Revision to start watching" ) cmd . Flags ( ) . BoolVar ( & watchPrevKey , "prev-kv" , false , "get the previous key-value pair before the event happens" ) return cmd }
328	func ( ms * MemoryStorage ) InitialState ( ) ( pb . HardState , pb . ConfState , error ) { return ms . hardState , ms . snapshot . Metadata . ConfState , nil }
329	func ( ms * MemoryStorage ) SetHardState ( st pb . HardState ) error { ms . Lock ( ) defer ms . Unlock ( ) ms . hardState = st return nil }
330	func ( ms * MemoryStorage ) Entries ( lo , hi , maxSize uint64 ) ( [ ] pb . Entry , error ) { ms . Lock ( ) defer ms . Unlock ( ) offset := ms . ents [ 0 ] . Index if lo <= offset { return nil , ErrCompacted } if hi > ms . lastIndex ( ) + 1 { raftLogger . Panicf ( "entries' hi(%d) is out of bound lastindex(%d)" , hi , ms . lastIndex ( ) ) } if len ( ms . ents ) == 1 { return nil , ErrUnavailable } ents := ms . ents [ lo - offset : hi - offset ] return limitSize ( ents , maxSize ) , nil }
331	func ( ms * MemoryStorage ) Term ( i uint64 ) ( uint64 , error ) { ms . Lock ( ) defer ms . Unlock ( ) offset := ms . ents [ 0 ] . Index if i < offset { return 0 , ErrCompacted } if int ( i - offset ) >= len ( ms . ents ) { return 0 , ErrUnavailable } return ms . ents [ i - offset ] . Term , nil }
332	func ( ms * MemoryStorage ) LastIndex ( ) ( uint64 , error ) { ms . Lock ( ) defer ms . Unlock ( ) return ms . lastIndex ( ) , nil }
333	func ( ms * MemoryStorage ) FirstIndex ( ) ( uint64 , error ) { ms . Lock ( ) defer ms . Unlock ( ) return ms . firstIndex ( ) , nil }
334	func ( ms * MemoryStorage ) Snapshot ( ) ( pb . Snapshot , error ) { ms . Lock ( ) defer ms . Unlock ( ) return ms . snapshot , nil }
335	func ( ms * MemoryStorage ) ApplySnapshot ( snap pb . Snapshot ) error { ms . Lock ( ) defer ms . Unlock ( ) msIndex := ms . snapshot . Metadata . Index snapIndex := snap . Metadata . Index if msIndex >= snapIndex { return ErrSnapOutOfDate } ms . snapshot = snap ms . ents = [ ] pb . Entry { { Term : snap . Metadata . Term , Index : snap . Metadata . Index } } return nil }
336	func ( ms * MemoryStorage ) Compact ( compactIndex uint64 ) error { ms . Lock ( ) defer ms . Unlock ( ) offset := ms . ents [ 0 ] . Index if compactIndex <= offset { return ErrCompacted } if compactIndex > ms . lastIndex ( ) { raftLogger . Panicf ( "compact %d is out of bound lastindex(%d)" , compactIndex , ms . lastIndex ( ) ) } i := compactIndex - offset ents := make ( [ ] pb . Entry , 1 , 1 + uint64 ( len ( ms . ents ) ) - i ) ents [ 0 ] . Index = ms . ents [ i ] . Index ents [ 0 ] . Term = ms . ents [ i ] . Term ents = append ( ents , ms . ents [ i + 1 : ] ... ) ms . ents = ents return nil }
337	func ( p * urlPicker ) unreachable ( u url . URL ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) if u == p . urls [ p . picked ] { p . picked = ( p . picked + 1 ) % len ( p . urls ) } }
338	func NewEndpointCommand ( ) * cobra . Command { ec := & cobra . Command { Use : "endpoint <subcommand>" , Short : "Endpoint related commands" , } ec . PersistentFlags ( ) . BoolVar ( & epClusterEndpoints , "cluster" , false , "use all endpoints from the cluster member list" ) ec . AddCommand ( newEpHealthCommand ( ) ) ec . AddCommand ( newEpStatusCommand ( ) ) ec . AddCommand ( newEpHashKVCommand ( ) ) return ec }
339	func epHealthCommandFunc ( cmd * cobra . Command , args [ ] string ) { flags . SetPflagsFromEnv ( "ETCDCTL" , cmd . InheritedFlags ( ) ) initDisplayFromCmd ( cmd ) sec := secureCfgFromCmd ( cmd ) dt := dialTimeoutFromCmd ( cmd ) ka := keepAliveTimeFromCmd ( cmd ) kat := keepAliveTimeoutFromCmd ( cmd ) auth := authCfgFromCmd ( cmd ) cfgs := [ ] * v3 . Config { } for _ , ep := range endpointsFromCluster ( cmd ) { cfg , err := newClientCfg ( [ ] string { ep } , dt , ka , kat , sec , auth ) if err != nil { ExitWithError ( ExitBadArgs , err ) } cfgs = append ( cfgs , cfg ) } var wg sync . WaitGroup hch := make ( chan epHealth , len ( cfgs ) ) for _ , cfg := range cfgs { wg . Add ( 1 ) go func ( cfg * v3 . Config ) { defer wg . Done ( ) ep := cfg . Endpoints [ 0 ] cli , err := v3 . New ( * cfg ) if err != nil { hch <- epHealth { Ep : ep , Health : false , Error : err . Error ( ) } return } st := time . Now ( ) ctx , cancel := commandCtx ( cmd ) _ , err = cli . Get ( ctx , "health" ) cancel ( ) eh := epHealth { Ep : ep , Health : false , Took : time . Since ( st ) . String ( ) } if err == nil || err == rpctypes . ErrPermissionDenied { eh . Health = true } else { eh . Error = err . Error ( ) } hch <- eh } ( cfg ) } wg . Wait ( ) close ( hch ) errs := false healthList := [ ] epHealth { } for h := range hch { healthList = append ( healthList , h ) if h . Error != "" { errs = true } } display . EndpointHealth ( healthList ) if errs { ExitWithError ( ExitError , fmt . Errorf ( "unhealthy cluster" ) ) } }
340	func NewElectCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "elect <election-name> [proposal]" , Short : "Observes and participates in leader election" , Run : electCommandFunc , } cmd . Flags ( ) . BoolVarP ( & electListen , "listen" , "l" , false , "observation mode" ) return cmd }
341	func NewDefragCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "defrag" , Short : "Defragments the storage of the etcd members with given endpoints" , Run : defragCommandFunc , } cmd . PersistentFlags ( ) . BoolVar ( & epClusterEndpoints , "cluster" , false , "use all endpoints from the cluster member list" ) cmd . Flags ( ) . StringVar ( & defragDataDir , "data-dir" , "" , "Optional. If present, defragments a data directory not in use by etcd." ) return cmd }
342	func RegisterBuilder ( cfg Config ) { bb := & builder { cfg } balancer . Register ( bb ) bb . cfg . Logger . Debug ( "registered balancer" , zap . String ( "policy" , bb . cfg . Policy . String ( ) ) , zap . String ( "name" , bb . cfg . Name ) , ) }
343	func ( b * builder ) Build ( cc balancer . ClientConn , opt balancer . BuildOptions ) balancer . Balancer { bb := & baseBalancer { id : strconv . FormatInt ( time . Now ( ) . UnixNano ( ) , 36 ) , policy : b . cfg . Policy , name : b . cfg . Name , lg : b . cfg . Logger , addrToSc : make ( map [ resolver . Address ] balancer . SubConn ) , scToAddr : make ( map [ balancer . SubConn ] resolver . Address ) , scToSt : make ( map [ balancer . SubConn ] connectivity . State ) , currentConn : nil , csEvltr : & connectivityStateEvaluator { } , Picker : picker . NewErr ( balancer . ErrNoSubConnAvailable ) , } if bb . lg == nil { bb . lg = zap . NewNop ( ) } bb . mu . Lock ( ) bb . currentConn = cc bb . mu . Unlock ( ) bb . lg . Info ( "built balancer" , zap . String ( "balancer-id" , bb . id ) , zap . String ( "policy" , bb . policy . String ( ) ) , zap . String ( "resolver-target" , cc . Target ( ) ) , ) return bb }
344	func ( cse * connectivityStateEvaluator ) recordTransition ( oldState , newState connectivity . State ) connectivity . State { for idx , state := range [ ] connectivity . State { oldState , newState } { updateVal := 2 * uint64 ( idx ) - 1 switch state { case connectivity . Ready : cse . numReady += updateVal case connectivity . Connecting : cse . numConnecting += updateVal case connectivity . TransientFailure : cse . numTransientFailure += updateVal } } if cse . numReady > 0 { return connectivity . Ready } if cse . numConnecting > 0 { return connectivity . Connecting } return connectivity . TransientFailure }
345	func ( s * EtcdServer ) doSerialize ( ctx context . Context , chk func ( * auth . AuthInfo ) error , get func ( ) ) error { ai , err := s . AuthInfoFromCtx ( ctx ) if err != nil { return err } if ai == nil { ai = & auth . AuthInfo { } } if err = chk ( ai ) ; err != nil { return err } get ( ) if ai . Revision != 0 && ai . Revision != s . authStore . Revision ( ) { return auth . ErrAuthOldRevision } return nil }
346	func ( w * watcher ) send ( wr clientv3 . WatchResponse ) { if wr . IsProgressNotify ( ) && ! w . progress { return } if w . nextrev > wr . Header . Revision && len ( wr . Events ) > 0 { return } if w . nextrev == 0 { w . nextrev = wr . Header . Revision + 1 } events := make ( [ ] * mvccpb . Event , 0 , len ( wr . Events ) ) var lastRev int64 for i := range wr . Events { ev := ( * mvccpb . Event ) ( wr . Events [ i ] ) if ev . Kv . ModRevision < w . nextrev { continue } else { lastRev = ev . Kv . ModRevision } filtered := false for _ , filter := range w . filters { if filter ( * ev ) { filtered = true break } } if filtered { continue } if ! w . prevKV { evCopy := * ev evCopy . PrevKv = nil ev = & evCopy } events = append ( events , ev ) } if lastRev >= w . nextrev { w . nextrev = lastRev + 1 } if ! wr . IsProgressNotify ( ) && ! wr . Created && len ( events ) == 0 && wr . CompactRevision == 0 { return } w . lastHeader = wr . Header w . post ( & pb . WatchResponse { Header : & wr . Header , Created : wr . Created , CompactRevision : wr . CompactRevision , Canceled : wr . Canceled , WatchId : w . id , Events : events , } ) }
347	func ( w * watcher ) post ( wr * pb . WatchResponse ) bool { select { case w . wps . watchCh <- wr : case <- time . After ( 50 * time . Millisecond ) : w . wps . cancel ( ) return false } return true }
348	func ( ac * AccessController ) OriginAllowed ( origin string ) bool { ac . corsMu . RLock ( ) defer ac . corsMu . RUnlock ( ) if len ( ac . CORS ) == 0 { return true } _ , ok := ac . CORS [ "*" ] if ok { return true } _ , ok = ac . CORS [ origin ] return ok }
349	func ( ac * AccessController ) IsHostWhitelisted ( host string ) bool { ac . hostWhitelistMu . RLock ( ) defer ac . hostWhitelistMu . RUnlock ( ) if len ( ac . HostWhitelist ) == 0 { return true } _ , ok := ac . HostWhitelist [ "*" ] if ok { return true } _ , ok = ac . HostWhitelist [ host ] return ok }
350	func ( ss * SelectiveStringValue ) Valids ( ) [ ] string { s := make ( [ ] string , 0 , len ( ss . valids ) ) for k := range ss . valids { s = append ( s , k ) } sort . Strings ( s ) return s }
351	func NewSelectiveStringsValue ( valids ... string ) * SelectiveStringsValue { vm := make ( map [ string ] struct { } ) for _ , v := range valids { vm [ v ] = struct { } { } } return & SelectiveStringsValue { valids : vm , vs : [ ] string { } } }
352	func NewKV ( kv clientv3 . KV , prefix string ) clientv3 . KV { return & kvPrefix { kv , prefix } }
353	func NewURLsValue ( s string ) * URLsValue { if s == "" { return & URLsValue { } } v := & URLsValue { } if err := v . Set ( s ) ; err != nil { plog . Panicf ( "new URLsValue should never fail: %v" , err ) } return v }
354	func URLsFromFlag ( fs * flag . FlagSet , urlsFlagName string ) [ ] url . URL { return [ ] url . URL ( * fs . Lookup ( urlsFlagName ) . Value . ( * URLsValue ) ) }
355	func ( e * Etcd ) servePeers ( ) ( err error ) { ph := etcdhttp . NewPeerHandler ( e . GetLogger ( ) , e . Server ) var peerTLScfg * tls . Config if ! e . cfg . PeerTLSInfo . Empty ( ) { if peerTLScfg , err = e . cfg . PeerTLSInfo . ServerConfig ( ) ; err != nil { return err } } for _ , p := range e . Peers { u := p . Listener . Addr ( ) . String ( ) gs := v3rpc . Server ( e . Server , peerTLScfg ) m := cmux . New ( p . Listener ) go gs . Serve ( m . Match ( cmux . HTTP2 ( ) ) ) srv := & http . Server { Handler : grpcHandlerFunc ( gs , ph ) , ReadTimeout : 5 * time . Minute , ErrorLog : defaultLog . New ( ioutil . Discard , "" , 0 ) , } go srv . Serve ( m . Match ( cmux . Any ( ) ) ) p . serve = func ( ) error { return m . Serve ( ) } p . close = func ( ctx context . Context ) error { if e . cfg . logger != nil { e . cfg . logger . Info ( "stopping serving peer traffic" , zap . String ( "address" , u ) , ) } stopServers ( ctx , & servers { secure : peerTLScfg != nil , grpc : gs , http : srv } ) if e . cfg . logger != nil { e . cfg . logger . Info ( "stopped serving peer traffic" , zap . String ( "address" , u ) , ) } return nil } } for _ , pl := range e . Peers { go func ( l * peerListener ) { u := l . Addr ( ) . String ( ) if e . cfg . logger != nil { e . cfg . logger . Info ( "serving peer traffic" , zap . String ( "address" , u ) , ) } else { plog . Info ( "listening for peers on " , u ) } e . errHandler ( l . serve ( ) ) } ( pl ) } return nil }
356	func NewStore ( lg * zap . Logger , b backend . Backend , le lease . Lessor , ig ConsistentIndexGetter ) * store { s := & store { b : b , ig : ig , kvindex : newTreeIndex ( lg ) , le : le , currentRev : 1 , compactMainRev : - 1 , bytesBuf8 : make ( [ ] byte , 8 ) , fifoSched : schedule . NewFIFOScheduler ( ) , stopc : make ( chan struct { } ) , lg : lg , } s . ReadView = & readView { s } s . WriteView = & writeView { s } if s . le != nil { s . le . SetRangeDeleter ( func ( ) lease . TxnDelete { return s . Write ( ) } ) } tx := s . b . BatchTx ( ) tx . Lock ( ) tx . UnsafeCreateBucket ( keyBucketName ) tx . UnsafeCreateBucket ( metaBucketName ) tx . Unlock ( ) s . b . ForceCommit ( ) s . mu . Lock ( ) defer s . mu . Unlock ( ) if err := s . restore ( ) ; err != nil { panic ( "failed to recover store from backend" ) } return s }
357	func appendMarkTombstone ( lg * zap . Logger , b [ ] byte ) [ ] byte { if len ( b ) != revBytesLen { if lg != nil { lg . Panic ( "cannot append tombstone mark to non-normal revision bytes" , zap . Int ( "expected-revision-bytes-size" , revBytesLen ) , zap . Int ( "given-revision-bytes-size" , len ( b ) ) , ) } else { plog . Panicf ( "cannot append mark to non normal revision bytes" ) } } return append ( b , markTombstone ) }
358	func IsDirWriteable ( dir string ) error { f := filepath . Join ( dir , ".touch" ) if err := ioutil . WriteFile ( f , [ ] byte ( "" ) , PrivateFileMode ) ; err != nil { return err } return os . Remove ( f ) }
359	func TouchDirAll ( dir string ) error { err := os . MkdirAll ( dir , PrivateDirMode ) if err != nil { return err } return IsDirWriteable ( dir ) }
360	func CreateDirAll ( dir string ) error { err := TouchDirAll ( dir ) if err == nil { var ns [ ] string ns , err = ReadDir ( dir ) if err != nil { return err } if len ( ns ) != 0 { err = fmt . Errorf ( "expected %q to be empty, got %q" , dir , ns ) } } return err }
361	func ZeroToEnd ( f * os . File ) error { off , err := f . Seek ( 0 , io . SeekCurrent ) if err != nil { return err } lenf , lerr := f . Seek ( 0 , io . SeekEnd ) if lerr != nil { return lerr } if err = f . Truncate ( off ) ; err != nil { return err } if err = Preallocate ( f , lenf , true ) ; err != nil { return err } _ , err = f . Seek ( off , io . SeekStart ) return err }
362	func ( fp * filePipeline ) Open ( ) ( f * fileutil . LockedFile , err error ) { select { case f = <- fp . filec : case err = <- fp . errc : } return f , err }
363	func NewRaftLoggerFromZapCore ( cr zapcore . Core , syncer zapcore . WriteSyncer ) raft . Logger { lg := zap . New ( cr , zap . AddCaller ( ) , zap . AddCallerSkip ( 1 ) , zap . ErrorOutput ( syncer ) ) return & zapRaftLogger { lg : lg , sugar : lg . Sugar ( ) } }
364	func NewConfig ( fpath string ) ( * clientv3 . Config , error ) { b , err := ioutil . ReadFile ( fpath ) if err != nil { return nil , err } yc := & yamlConfig { } err = yaml . Unmarshal ( b , yc ) if err != nil { return nil , err } if yc . InsecureTransport { return & yc . Config , nil } var ( cert * tls . Certificate cp * x509 . CertPool ) if yc . Certfile != "" && yc . Keyfile != "" { cert , err = tlsutil . NewCert ( yc . Certfile , yc . Keyfile , nil ) if err != nil { return nil , err } } if yc . TrustedCAfile != "" { cp , err = tlsutil . NewCertPool ( [ ] string { yc . TrustedCAfile } ) if err != nil { return nil , err } } tlscfg := & tls . Config { MinVersion : tls . VersionTLS12 , InsecureSkipVerify : yc . InsecureSkipTLSVerify , RootCAs : cp , } if cert != nil { tlscfg . Certificates = [ ] tls . Certificate { * cert } } yc . Config . TLS = tlscfg return & yc . Config , nil }
365	func RegisterElectionHandler ( ctx context . Context , mux * runtime . ServeMux , conn * grpc . ClientConn ) error { return RegisterElectionHandlerClient ( ctx , mux , v3electionpb . NewElectionClient ( conn ) ) }
366	func UpdateCapability ( lg * zap . Logger , v * semver . Version ) { if v == nil { return } enableMapMu . Lock ( ) if curVersion != nil && ! curVersion . LessThan ( * v ) { enableMapMu . Unlock ( ) return } curVersion = v enabledMap = capabilityMaps [ curVersion . String ( ) ] enableMapMu . Unlock ( ) if lg != nil { lg . Info ( "enabled capabilities for version" , zap . String ( "cluster-version" , version . Cluster ( v . String ( ) ) ) , ) } else { plog . Infof ( "enabled capabilities for version %s" , version . Cluster ( v . String ( ) ) ) } }
367	func NewLockCommand ( ) * cobra . Command { c := & cobra . Command { Use : "lock <lockname> [exec-command arg1 arg2 ...]" , Short : "Acquires a named lock" , Run : lockCommandFunc , } c . Flags ( ) . IntVarP ( & lockTTL , "ttl" , "" , lockTTL , "timeout for session" ) return c }
368	func ( r * raftNode ) tick ( ) { r . tickMu . Lock ( ) r . Tick ( ) r . tickMu . Unlock ( ) }
369	func ( r * raftNode ) advanceTicks ( ticks int ) { for i := 0 ; i < ticks ; i ++ { r . tick ( ) } }
370	func NewAuthCommand ( ) * cobra . Command { ac := & cobra . Command { Use : "auth <enable or disable>" , Short : "Enable or disable authentication" , } ac . AddCommand ( newAuthEnableCommand ( ) ) ac . AddCommand ( newAuthDisableCommand ( ) ) return ac }
371	func authEnableCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 0 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "auth enable command does not accept any arguments" ) ) } ctx , cancel := commandCtx ( cmd ) cli := mustClientFromCmd ( cmd ) var err error for err == nil { if _ , err = cli . AuthEnable ( ctx ) ; err == nil { break } if err == rpctypes . ErrRootRoleNotExist { if _ , err = cli . RoleAdd ( ctx , "root" ) ; err != nil { break } if _ , err = cli . UserGrantRole ( ctx , "root" , "root" ) ; err != nil { break } } } cancel ( ) if err != nil { ExitWithError ( ExitError , err ) } fmt . Println ( "Authentication Enabled" ) }
372	func authDisableCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 0 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "auth disable command does not accept any arguments" ) ) } ctx , cancel := commandCtx ( cmd ) _ , err := mustClientFromCmd ( cmd ) . Auth . AuthDisable ( ctx ) cancel ( ) if err != nil { ExitWithError ( ExitError , err ) } fmt . Println ( "Authentication Disabled" ) }
373	func RetryKVClient ( c * Client ) pb . KVClient { return & retryKVClient { kc : pb . NewKVClient ( c . conn ) , } }
374	func RetryLeaseClient ( c * Client ) pb . LeaseClient { return & retryLeaseClient { lc : pb . NewLeaseClient ( c . conn ) , } }
375	func RetryClusterClient ( c * Client ) pb . ClusterClient { return & retryClusterClient { cc : pb . NewClusterClient ( c . conn ) , } }
376	func RetryMaintenanceClient ( c * Client , conn * grpc . ClientConn ) pb . MaintenanceClient { return & retryMaintenanceClient { mc : pb . NewMaintenanceClient ( conn ) , } }
377	func RetryAuthClient ( c * Client ) pb . AuthClient { return & retryAuthClient { ac : pb . NewAuthClient ( c . conn ) , } }
378	func NewSetDirCommand ( ) cli . Command { return cli . Command { Name : "setdir" , Usage : "create a new directory or update an existing directory TTL" , ArgsUsage : "<key>" , Flags : [ ] cli . Flag { cli . IntFlag { Name : "ttl" , Value : 0 , Usage : "key time-to-live in seconds" } , } , Action : func ( c * cli . Context ) error { mkdirCommandFunc ( c , mustNewKeyAPI ( c ) , client . PrevIgnore ) return nil } , } }
379	func ( b * DoubleBarrier ) Enter ( ) error { client := b . s . Client ( ) ek , err := newUniqueEphemeralKey ( b . s , b . key + "/waiters" ) if err != nil { return err } b . myKey = ek resp , err := client . Get ( b . ctx , b . key + "/waiters" , clientv3 . WithPrefix ( ) ) if err != nil { return err } if len ( resp . Kvs ) > b . count { return ErrTooManyClients } if len ( resp . Kvs ) == b . count { _ , err = client . Put ( b . ctx , b . key + "/ready" , "" ) return err } _ , err = WaitEvents ( client , b . key + "/ready" , ek . Revision ( ) , [ ] mvccpb . Event_EventType { mvccpb . PUT } ) return err }
380	func ( b * DoubleBarrier ) Leave ( ) error { client := b . s . Client ( ) resp , err := client . Get ( b . ctx , b . key + "/waiters" , clientv3 . WithPrefix ( ) ) if err != nil { return err } if len ( resp . Kvs ) == 0 { return nil } lowest , highest := resp . Kvs [ 0 ] , resp . Kvs [ 0 ] for _ , k := range resp . Kvs { if k . ModRevision < lowest . ModRevision { lowest = k } if k . ModRevision > highest . ModRevision { highest = k } } isLowest := string ( lowest . Key ) == b . myKey . Key ( ) if len ( resp . Kvs ) == 1 { if _ , err = client . Delete ( b . ctx , b . key + "/ready" ) ; err != nil { return err } return b . myKey . Delete ( ) } if isLowest { _ , err = WaitEvents ( client , string ( highest . Key ) , highest . ModRevision , [ ] mvccpb . Event_EventType { mvccpb . DELETE } ) if err != nil { return err } return b . Leave ( ) } if err = b . myKey . Delete ( ) ; err != nil { return err } key := string ( lowest . Key ) _ , err = WaitEvents ( client , key , lowest . ModRevision , [ ] mvccpb . Event_EventType { mvccpb . DELETE } ) if err != nil { return err } return b . Leave ( ) }
381	func HandleBasic ( mux * http . ServeMux , server etcdserver . ServerPeer ) { mux . HandleFunc ( varsPath , serveVars ) mux . HandleFunc ( configPath + "/local/log" , logHandleFunc ) HandleMetricsHealth ( mux , server ) mux . HandleFunc ( versionPath , versionHandler ( server . Cluster ( ) , serveVersion ) ) }
382	func WriteError ( lg * zap . Logger , w http . ResponseWriter , r * http . Request , err error ) { if err == nil { return } switch e := err . ( type ) { case * v2error . Error : e . WriteTo ( w ) case * httptypes . HTTPError : if et := e . WriteTo ( w ) ; et != nil { if lg != nil { lg . Debug ( "failed to write v2 HTTP error" , zap . String ( "remote-addr" , r . RemoteAddr ) , zap . String ( "internal-server-error" , e . Error ( ) ) , zap . Error ( et ) , ) } else { plog . Debugf ( "error writing HTTPError (%v) to %s" , et , r . RemoteAddr ) } } default : switch err { case etcdserver . ErrTimeoutDueToLeaderFail , etcdserver . ErrTimeoutDueToConnectionLost , etcdserver . ErrNotEnoughStartedMembers , etcdserver . ErrUnhealthy : if lg != nil { lg . Warn ( "v2 response error" , zap . String ( "remote-addr" , r . RemoteAddr ) , zap . String ( "internal-server-error" , err . Error ( ) ) , ) } else { mlog . MergeError ( err ) } default : if lg != nil { lg . Warn ( "unexpected v2 response error" , zap . String ( "remote-addr" , r . RemoteAddr ) , zap . String ( "internal-server-error" , err . Error ( ) ) , ) } else { mlog . MergeErrorf ( "got unexpected response error (%v)" , err ) } } herr := httptypes . NewHTTPError ( http . StatusInternalServerError , "Internal Server Error" ) if et := herr . WriteTo ( w ) ; et != nil { if lg != nil { lg . Debug ( "failed to write v2 HTTP error" , zap . String ( "remote-addr" , r . RemoteAddr ) , zap . String ( "internal-server-error" , err . Error ( ) ) , zap . Error ( et ) , ) } else { plog . Debugf ( "error writing HTTPError (%v) to %s" , et , r . RemoteAddr ) } } } }
383	func ( c * RaftCluster ) MemberByName ( name string ) * Member { c . Lock ( ) defer c . Unlock ( ) var memb * Member for _ , m := range c . members { if m . Name == name { if memb != nil { if c . lg != nil { c . lg . Panic ( "two member with same name found" , zap . String ( "name" , name ) ) } else { plog . Panicf ( "two members with the given name %q exist" , name ) } } memb = m } } return memb . Clone ( ) }
384	func ( c * RaftCluster ) PeerURLs ( ) [ ] string { c . Lock ( ) defer c . Unlock ( ) urls := make ( [ ] string , 0 ) for _ , p := range c . members { urls = append ( urls , p . PeerURLs ... ) } sort . Strings ( urls ) return urls }
385	func ( c * RaftCluster ) ValidateConfigurationChange ( cc raftpb . ConfChange ) error { members , removed := membersFromStore ( c . lg , c . v2store ) id := types . ID ( cc . NodeID ) if removed [ id ] { return ErrIDRemoved } switch cc . Type { case raftpb . ConfChangeAddNode : if members [ id ] != nil { return ErrIDExists } urls := make ( map [ string ] bool ) for _ , m := range members { for _ , u := range m . PeerURLs { urls [ u ] = true } } m := new ( Member ) if err := json . Unmarshal ( cc . Context , m ) ; err != nil { if c . lg != nil { c . lg . Panic ( "failed to unmarshal member" , zap . Error ( err ) ) } else { plog . Panicf ( "unmarshal member should never fail: %v" , err ) } } for _ , u := range m . PeerURLs { if urls [ u ] { return ErrPeerURLexists } } case raftpb . ConfChangeRemoveNode : if members [ id ] == nil { return ErrIDNotFound } case raftpb . ConfChangeUpdateNode : if members [ id ] == nil { return ErrIDNotFound } urls := make ( map [ string ] bool ) for _ , m := range members { if m . ID == id { continue } for _ , u := range m . PeerURLs { urls [ u ] = true } } m := new ( Member ) if err := json . Unmarshal ( cc . Context , m ) ; err != nil { if c . lg != nil { c . lg . Panic ( "failed to unmarshal member" , zap . Error ( err ) ) } else { plog . Panicf ( "unmarshal member should never fail: %v" , err ) } } for _ , u := range m . PeerURLs { if urls [ u ] { return ErrPeerURLexists } } default : if c . lg != nil { c . lg . Panic ( "unknown ConfChange type" , zap . String ( "type" , cc . Type . String ( ) ) ) } else { plog . Panicf ( "ConfChange type should be either AddNode, RemoveNode or UpdateNode" ) } } return nil }
386	func ( c * RaftCluster ) AddMember ( m * Member ) { c . Lock ( ) defer c . Unlock ( ) if c . v2store != nil { mustSaveMemberToStore ( c . v2store , m ) } if c . be != nil { mustSaveMemberToBackend ( c . be , m ) } c . members [ m . ID ] = m if c . lg != nil { c . lg . Info ( "added member" , zap . String ( "cluster-id" , c . cid . String ( ) ) , zap . String ( "local-member-id" , c . localID . String ( ) ) , zap . String ( "added-peer-id" , m . ID . String ( ) ) , zap . Strings ( "added-peer-peer-urls" , m . PeerURLs ) , ) } else { plog . Infof ( "added member %s %v to cluster %s" , m . ID , m . PeerURLs , c . cid ) } }
387	func ( c * RaftCluster ) RemoveMember ( id types . ID ) { c . Lock ( ) defer c . Unlock ( ) if c . v2store != nil { mustDeleteMemberFromStore ( c . v2store , id ) } if c . be != nil { mustDeleteMemberFromBackend ( c . be , id ) } m , ok := c . members [ id ] delete ( c . members , id ) c . removed [ id ] = true if c . lg != nil { if ok { c . lg . Info ( "removed member" , zap . String ( "cluster-id" , c . cid . String ( ) ) , zap . String ( "local-member-id" , c . localID . String ( ) ) , zap . String ( "removed-remote-peer-id" , id . String ( ) ) , zap . Strings ( "removed-remote-peer-urls" , m . PeerURLs ) , ) } else { c . lg . Warn ( "skipped removing already removed member" , zap . String ( "cluster-id" , c . cid . String ( ) ) , zap . String ( "local-member-id" , c . localID . String ( ) ) , zap . String ( "removed-remote-peer-id" , id . String ( ) ) , ) } } else { plog . Infof ( "removed member %s from cluster %s" , id , c . cid ) } }
388	func ValidateClusterAndAssignIDs ( lg * zap . Logger , local * RaftCluster , existing * RaftCluster ) error { ems := existing . Members ( ) lms := local . Members ( ) if len ( ems ) != len ( lms ) { return fmt . Errorf ( "member count is unequal" ) } sort . Sort ( MembersByPeerURLs ( ems ) ) sort . Sort ( MembersByPeerURLs ( lms ) ) ctx , cancel := context . WithTimeout ( context . TODO ( ) , 30 * time . Second ) defer cancel ( ) for i := range ems { if ok , err := netutil . URLStringsEqual ( ctx , lg , ems [ i ] . PeerURLs , lms [ i ] . PeerURLs ) ; ! ok { return fmt . Errorf ( "unmatched member while checking PeerURLs (%v)" , err ) } lms [ i ] . ID = ems [ i ] . ID } local . members = make ( map [ types . ID ] * Member ) for _ , m := range lms { local . members [ m . ID ] = m } return nil }
389	func ( ti * treeIndex ) Keep ( rev int64 ) map [ revision ] struct { } { available := make ( map [ revision ] struct { } ) ti . RLock ( ) defer ti . RUnlock ( ) ti . tree . Ascend ( func ( i btree . Item ) bool { keyi := i . ( * keyIndex ) keyi . keep ( rev , available ) return true } ) return available }
390	func ( l * lessor ) closeRequireLeader ( ) { l . mu . Lock ( ) defer l . mu . Unlock ( ) for _ , ka := range l . keepAlives { reqIdxs := 0 for i , ctx := range ka . ctxs { md , ok := metadata . FromOutgoingContext ( ctx ) if ! ok { continue } ks := md [ rpctypes . MetadataRequireLeaderKey ] if len ( ks ) < 1 || ks [ 0 ] != rpctypes . MetadataHasLeader { continue } close ( ka . chs [ i ] ) ka . chs [ i ] = nil reqIdxs ++ } if reqIdxs == 0 { continue } newChs := make ( [ ] chan <- * LeaseKeepAliveResponse , len ( ka . chs ) - reqIdxs ) newCtxs := make ( [ ] context . Context , len ( newChs ) ) newIdx := 0 for i := range ka . chs { if ka . chs [ i ] == nil { continue } newChs [ newIdx ] , newCtxs [ newIdx ] = ka . chs [ i ] , ka . ctxs [ newIdx ] newIdx ++ } ka . chs , ka . ctxs = newChs , newCtxs } }
391	func ( l * lessor ) resetRecv ( ) ( pb . Lease_LeaseKeepAliveClient , error ) { sctx , cancel := context . WithCancel ( l . stopCtx ) stream , err := l . remote . LeaseKeepAlive ( sctx , append ( l . callOpts , withMax ( 0 ) ) ... ) if err != nil { cancel ( ) return nil , err } l . mu . Lock ( ) defer l . mu . Unlock ( ) if l . stream != nil && l . streamCancel != nil { l . streamCancel ( ) } l . streamCancel = cancel l . stream = stream go l . sendKeepAliveLoop ( stream ) return stream , nil }
392	func ( l * lessor ) recvKeepAlive ( resp * pb . LeaseKeepAliveResponse ) { karesp := & LeaseKeepAliveResponse { ResponseHeader : resp . GetHeader ( ) , ID : LeaseID ( resp . ID ) , TTL : resp . TTL , } l . mu . Lock ( ) defer l . mu . Unlock ( ) ka , ok := l . keepAlives [ karesp . ID ] if ! ok { return } if karesp . TTL <= 0 { delete ( l . keepAlives , karesp . ID ) ka . close ( ) return } nextKeepAlive := time . Now ( ) . Add ( ( time . Duration ( karesp . TTL ) * time . Second ) / 3.0 ) ka . deadline = time . Now ( ) . Add ( time . Duration ( karesp . TTL ) * time . Second ) for _ , ch := range ka . chs { select { case ch <- karesp : default : if l . lg != nil { l . lg . Warn ( "lease keepalive response queue is full; dropping response send" , zap . Int ( "queue-size" , len ( ch ) ) , zap . Int ( "queue-capacity" , cap ( ch ) ) , ) } } ka . nextKeepAlive = nextKeepAlive } }
393	func ( l * lessor ) deadlineLoop ( ) { for { select { case <- time . After ( time . Second ) : case <- l . donec : return } now := time . Now ( ) l . mu . Lock ( ) for id , ka := range l . keepAlives { if ka . deadline . Before ( now ) { ka . close ( ) delete ( l . keepAlives , id ) } } l . mu . Unlock ( ) } }
394	func ( l * lessor ) sendKeepAliveLoop ( stream pb . Lease_LeaseKeepAliveClient ) { for { var tosend [ ] LeaseID now := time . Now ( ) l . mu . Lock ( ) for id , ka := range l . keepAlives { if ka . nextKeepAlive . Before ( now ) { tosend = append ( tosend , id ) } } l . mu . Unlock ( ) for _ , id := range tosend { r := & pb . LeaseKeepAliveRequest { ID : int64 ( id ) } if err := stream . Send ( r ) ; err != nil { return } } select { case <- time . After ( retryConnWait ) : case <- stream . Context ( ) . Done ( ) : return case <- l . donec : return case <- l . stopCtx . Done ( ) : return } } }
395	func NewKV ( cl * v3 . Client , pfx string , opts ... concurrency . SessionOption ) ( v3 . KV , func ( ) , error ) { cctx , cancel := context . WithCancel ( cl . Ctx ( ) ) lkv := & leasingKV { cl : cl , kv : cl . KV , pfx : pfx , leases : leaseCache { revokes : make ( map [ string ] time . Time ) } , ctx : cctx , cancel : cancel , sessionOpts : opts , sessionc : make ( chan struct { } ) , } lkv . wg . Add ( 2 ) go func ( ) { defer lkv . wg . Done ( ) lkv . monitorSession ( ) } ( ) go func ( ) { defer lkv . wg . Done ( ) lkv . leases . clearOldRevokes ( cctx ) } ( ) return lkv , lkv . Close , lkv . waitSession ( cctx ) }
396	func ( lkv * leasingKV ) rescind ( ctx context . Context , key string , rev int64 ) { if lkv . leases . Evict ( key ) > rev { return } cmp := v3 . Compare ( v3 . CreateRevision ( lkv . pfx + key ) , "<" , rev ) op := v3 . OpDelete ( lkv . pfx + key ) for ctx . Err ( ) == nil { if _ , err := lkv . kv . Txn ( ctx ) . If ( cmp ) . Then ( op ) . Commit ( ) ; err == nil { return } } }
397	func LeaseValue ( key string ) Cmp { return Cmp { Key : [ ] byte ( key ) , Target : pb . Compare_LEASE } }
398	func ( cmp * Cmp ) ValueBytes ( ) [ ] byte { if tu , ok := cmp . TargetUnion . ( * pb . Compare_Value ) ; ok { return tu . Value } return nil }
399	func ( cmp Cmp ) WithRange ( end string ) Cmp { cmp . RangeEnd = [ ] byte ( end ) return cmp }
400	func ( cmp Cmp ) WithPrefix ( ) Cmp { cmp . RangeEnd = getPrefix ( cmp . Key ) return cmp }
401	func mustInt64 ( val interface { } ) int64 { if v , ok := val . ( int64 ) ; ok { return v } if v , ok := val . ( int ) ; ok { return int64 ( v ) } panic ( "bad value" ) }
402	func mustInt64orLeaseID ( val interface { } ) int64 { if v , ok := val . ( LeaseID ) ; ok { return int64 ( v ) } return mustInt64 ( val ) }
403	func ( gw * gRPCWatcher ) Next ( ) ( [ ] * naming . Update , error ) { if gw . wch == nil { return gw . firstNext ( ) } if gw . err != nil { return nil , gw . err } wr , ok := <- gw . wch if ! ok { gw . err = status . Error ( codes . Unavailable , ErrWatcherClosed . Error ( ) ) return nil , gw . err } if gw . err = wr . Err ( ) ; gw . err != nil { return nil , gw . err } updates := make ( [ ] * naming . Update , 0 , len ( wr . Events ) ) for _ , e := range wr . Events { var jupdate naming . Update var err error switch e . Type { case etcd . EventTypePut : err = json . Unmarshal ( e . Kv . Value , & jupdate ) jupdate . Op = naming . Add case etcd . EventTypeDelete : err = json . Unmarshal ( e . PrevKv . Value , & jupdate ) jupdate . Op = naming . Delete default : continue } if err == nil { updates = append ( updates , & jupdate ) } } return updates , nil }
404	func getJournalWriteSyncer ( ) ( zapcore . WriteSyncer , error ) { jw , err := logutil . NewJournalWriter ( os . Stderr ) if err != nil { return nil , fmt . Errorf ( "can't find journal (%v)" , err ) } return zapcore . AddSync ( jw ) , nil }
405	func newKV ( store * store , nodePath string , value string , createdIndex uint64 , parent * node , expireTime time . Time ) * node { return & node { Path : nodePath , CreatedIndex : createdIndex , ModifiedIndex : createdIndex , Parent : parent , store : store , ExpireTime : expireTime , Value : value , } }
406	func newDir ( store * store , nodePath string , createdIndex uint64 , parent * node , expireTime time . Time ) * node { return & node { Path : nodePath , CreatedIndex : createdIndex , ModifiedIndex : createdIndex , Parent : parent , ExpireTime : expireTime , Children : make ( map [ string ] * node ) , store : store , } }
407	func ( n * node ) Read ( ) ( string , * v2error . Error ) { if n . IsDir ( ) { return "" , v2error . NewError ( v2error . EcodeNotFile , "" , n . store . CurrentIndex ) } return n . Value , nil }
408	func ( n * node ) Write ( value string , index uint64 ) * v2error . Error { if n . IsDir ( ) { return v2error . NewError ( v2error . EcodeNotFile , "" , n . store . CurrentIndex ) } n . Value = value n . ModifiedIndex = index return nil }
409	func ( n * node ) List ( ) ( [ ] * node , * v2error . Error ) { if ! n . IsDir ( ) { return nil , v2error . NewError ( v2error . EcodeNotDir , "" , n . store . CurrentIndex ) } nodes := make ( [ ] * node , len ( n . Children ) ) i := 0 for _ , node := range n . Children { nodes [ i ] = node i ++ } return nodes , nil }
410	func ( n * node ) GetChild ( name string ) ( * node , * v2error . Error ) { if ! n . IsDir ( ) { return nil , v2error . NewError ( v2error . EcodeNotDir , n . Path , n . store . CurrentIndex ) } child , ok := n . Children [ name ] if ok { return child , nil } return nil , nil }
411	func ( n * node ) Add ( child * node ) * v2error . Error { if ! n . IsDir ( ) { return v2error . NewError ( v2error . EcodeNotDir , "" , n . store . CurrentIndex ) } _ , name := path . Split ( child . Path ) if _ , ok := n . Children [ name ] ; ok { return v2error . NewError ( v2error . EcodeNodeExist , "" , n . store . CurrentIndex ) } n . Children [ name ] = child return nil }
412	func ( n * node ) Remove ( dir , recursive bool , callback func ( path string ) ) * v2error . Error { if ! n . IsDir ( ) { _ , name := path . Split ( n . Path ) if n . Parent != nil && n . Parent . Children [ name ] == n { delete ( n . Parent . Children , name ) } if callback != nil { callback ( n . Path ) } if ! n . IsPermanent ( ) { n . store . ttlKeyHeap . remove ( n ) } return nil } if ! dir { return v2error . NewError ( v2error . EcodeNotFile , n . Path , n . store . CurrentIndex ) } if len ( n . Children ) != 0 && ! recursive { return v2error . NewError ( v2error . EcodeDirNotEmpty , n . Path , n . store . CurrentIndex ) } for _ , child := range n . Children { child . Remove ( true , true , callback ) } _ , name := path . Split ( n . Path ) if n . Parent != nil && n . Parent . Children [ name ] == n { delete ( n . Parent . Children , name ) if callback != nil { callback ( n . Path ) } if ! n . IsPermanent ( ) { n . store . ttlKeyHeap . remove ( n ) } } return nil }
413	func ( n * node ) Compare ( prevValue string , prevIndex uint64 ) ( ok bool , which int ) { indexMatch := prevIndex == 0 || n . ModifiedIndex == prevIndex valueMatch := prevValue == "" || n . Value == prevValue ok = valueMatch && indexMatch switch { case valueMatch && indexMatch : which = CompareMatch case indexMatch && ! valueMatch : which = CompareValueNotMatch case valueMatch && ! indexMatch : which = CompareIndexNotMatch default : which = CompareNotMatch } return ok , which }
414	func ( n * node ) Clone ( ) * node { if ! n . IsDir ( ) { newkv := newKV ( n . store , n . Path , n . Value , n . CreatedIndex , n . Parent , n . ExpireTime ) newkv . ModifiedIndex = n . ModifiedIndex return newkv } clone := newDir ( n . store , n . Path , n . CreatedIndex , n . Parent , n . ExpireTime ) clone . ModifiedIndex = n . ModifiedIndex for key , child := range n . Children { clone . Children [ key ] = child . Clone ( ) } return clone }
415	func isConnectedToQuorumSince ( transport rafthttp . Transporter , since time . Time , self types . ID , members [ ] * membership . Member ) bool { return numConnectedSince ( transport , since , self , members ) >= ( len ( members ) / 2 ) + 1 }
416	func isConnectedSince ( transport rafthttp . Transporter , since time . Time , remote types . ID ) bool { t := transport . ActiveSince ( remote ) return ! t . IsZero ( ) && t . Before ( since ) }
417	func numConnectedSince ( transport rafthttp . Transporter , since time . Time , self types . ID , members [ ] * membership . Member ) int { connectedNum := 0 for _ , m := range members { if m . ID == self || isConnectedSince ( transport , since , m . ID ) { connectedNum ++ } } return connectedNum }
418	func longestConnected ( tp rafthttp . Transporter , membs [ ] types . ID ) ( types . ID , bool ) { var longest types . ID var oldest time . Time for _ , id := range membs { tm := tp . ActiveSince ( id ) if tm . IsZero ( ) { continue } if oldest . IsZero ( ) { oldest = tm longest = id } if tm . Before ( oldest ) { oldest = tm longest = id } } if uint64 ( longest ) == 0 { return longest , false } return longest , true }
419	func ( d * decoder ) isTornEntry ( data [ ] byte ) bool { if len ( d . brs ) != 1 { return false } fileOff := d . lastValidOff + frameSizeBytes curOff := 0 chunks := [ ] [ ] byte { } for curOff < len ( data ) { chunkLen := int ( minSectorSize - ( fileOff % minSectorSize ) ) if chunkLen > len ( data ) - curOff { chunkLen = len ( data ) - curOff } chunks = append ( chunks , data [ curOff : curOff + chunkLen ] ) fileOff += int64 ( chunkLen ) curOff += chunkLen } for _ , sect := range chunks { isZero := true for _ , v := range sect { if v != 0 { isZero = false break } } if isZero { return true } } return false }
420	func StartMockServersOnNetwork ( count int , network string ) ( ms * MockServers , err error ) { switch network { case "tcp" : return startMockServersTcp ( count ) case "unix" : return startMockServersUnix ( count ) default : return nil , fmt . Errorf ( "unsupported network type: %s" , network ) } }
421	func ( ms * MockServers ) StartAt ( idx int ) ( err error ) { ms . mu . Lock ( ) defer ms . mu . Unlock ( ) if ms . Servers [ idx ] . ln == nil { ms . Servers [ idx ] . ln , err = net . Listen ( ms . Servers [ idx ] . Network , ms . Servers [ idx ] . Address ) if err != nil { return fmt . Errorf ( "failed to listen %v" , err ) } } svr := grpc . NewServer ( ) pb . RegisterKVServer ( svr , & mockKVServer { } ) ms . Servers [ idx ] . GrpcServer = svr ms . wg . Add ( 1 ) go func ( svr * grpc . Server , l net . Listener ) { svr . Serve ( l ) } ( ms . Servers [ idx ] . GrpcServer , ms . Servers [ idx ] . ln ) return nil }
422	func ( ms * MockServers ) StopAt ( idx int ) { ms . mu . Lock ( ) defer ms . mu . Unlock ( ) if ms . Servers [ idx ] . ln == nil { return } ms . Servers [ idx ] . GrpcServer . Stop ( ) ms . Servers [ idx ] . GrpcServer = nil ms . Servers [ idx ] . ln = nil ms . wg . Done ( ) }
423	func ( ms * MockServers ) Stop ( ) { for idx := range ms . Servers { ms . StopAt ( idx ) } ms . wg . Wait ( ) }
424	func NewCheckCommand ( ) * cobra . Command { cc := & cobra . Command { Use : "check <subcommand>" , Short : "commands for checking properties of the etcd cluster" , } cc . AddCommand ( NewCheckPerfCommand ( ) ) cc . AddCommand ( NewCheckDatascaleCommand ( ) ) return cc }
425	func NewCheckPerfCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "perf [options]" , Short : "Check the performance of the etcd cluster" , Run : newCheckPerfCommand , } cmd . Flags ( ) . StringVar ( & checkPerfLoad , "load" , "s" , "The performance check's workload model. Accepted workloads: s(small), m(medium), l(large), xl(xLarge)" ) cmd . Flags ( ) . StringVar ( & checkPerfPrefix , "prefix" , "/etcdctl-check-perf/" , "The prefix for writing the performance check's keys." ) cmd . Flags ( ) . BoolVar ( & autoCompact , "auto-compact" , false , "Compact storage with last revision after test is finished." ) cmd . Flags ( ) . BoolVar ( & autoDefrag , "auto-defrag" , false , "Defragment storage after test is finished." ) return cmd }
426	func NewCheckDatascaleCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "datascale [options]" , Short : "Check the memory usage of holding data for different workloads on a given server endpoint." , Long : "If no endpoint is provided, localhost will be used. If multiple endpoints are provided, first endpoint will be used." , Run : newCheckDatascaleCommand , } cmd . Flags ( ) . StringVar ( & checkDatascaleLoad , "load" , "s" , "The datascale check's workload model. Accepted workloads: s(small), m(medium), l(large), xl(xLarge)" ) cmd . Flags ( ) . StringVar ( & checkDatascalePrefix , "prefix" , "/etcdctl-check-datascale/" , "The prefix for writing the datascale check's keys." ) cmd . Flags ( ) . BoolVar ( & autoCompact , "auto-compact" , false , "Compact storage with last revision after test is finished." ) cmd . Flags ( ) . BoolVar ( & autoDefrag , "auto-defrag" , false , "Defragment storage after test is finished." ) return cmd }
427	func NewGetCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "get [options] <key> [range_end]" , Short : "Gets the key or a range of keys" , Run : getCommandFunc , } cmd . Flags ( ) . StringVar ( & getConsistency , "consistency" , "l" , "Linearizable(l) or Serializable(s)" ) cmd . Flags ( ) . StringVar ( & getSortOrder , "order" , "" , "Order of results; ASCEND or DESCEND (ASCEND by default)" ) cmd . Flags ( ) . StringVar ( & getSortTarget , "sort-by" , "" , "Sort target; CREATE, KEY, MODIFY, VALUE, or VERSION" ) cmd . Flags ( ) . Int64Var ( & getLimit , "limit" , 0 , "Maximum number of results" ) cmd . Flags ( ) . BoolVar ( & getPrefix , "prefix" , false , "Get keys with matching prefix" ) cmd . Flags ( ) . BoolVar ( & getFromKey , "from-key" , false , "Get keys that are greater than or equal to the given key using byte compare" ) cmd . Flags ( ) . Int64Var ( & getRev , "rev" , 0 , "Specify the kv revision" ) cmd . Flags ( ) . BoolVar ( & getKeysOnly , "keys-only" , false , "Get only the keys" ) cmd . Flags ( ) . BoolVar ( & printValueOnly , "print-value-only" , false , `Only write values when using the "simple" output format` ) return cmd }
428	func NewGetCommand ( ) cli . Command { return cli . Command { Name : "get" , Usage : "retrieve the value of a key" , ArgsUsage : "<key>" , Flags : [ ] cli . Flag { cli . BoolFlag { Name : "sort" , Usage : "returns result in sorted order" } , cli . BoolFlag { Name : "quorum, q" , Usage : "require quorum for get request" } , } , Action : func ( c * cli . Context ) error { getCommandFunc ( c , mustNewKeyAPI ( c ) ) return nil } , } }
429	func ( m * Member ) PickPeerURL ( ) string { if len ( m . PeerURLs ) == 0 { panic ( "member should always have some peer url" ) } return m . PeerURLs [ rand . Intn ( len ( m . PeerURLs ) ) ] }
430	func HandleMetricsHealth ( mux * http . ServeMux , srv etcdserver . ServerV2 ) { mux . Handle ( PathMetrics , promhttp . Handler ( ) ) mux . Handle ( PathHealth , NewHealthHandler ( func ( ) Health { return checkHealth ( srv ) } ) ) }
431	func NewRemoveCommand ( ) cli . Command { return cli . Command { Name : "rm" , Usage : "remove a key or a directory" , ArgsUsage : "<key>" , Flags : [ ] cli . Flag { cli . BoolFlag { Name : "dir" , Usage : "removes the key if it is an empty directory or a key-value pair" } , cli . BoolFlag { Name : "recursive, r" , Usage : "removes the key and all child keys(if it is a directory)" } , cli . StringFlag { Name : "with-value" , Value : "" , Usage : "previous value" } , cli . IntFlag { Name : "with-index" , Value : 0 , Usage : "previous index" } , } , Action : func ( c * cli . Context ) error { rmCommandFunc ( c , mustNewKeyAPI ( c ) ) return nil } , } }
432	func rmCommandFunc ( c * cli . Context , ki client . KeysAPI ) { if len ( c . Args ( ) ) == 0 { handleError ( c , ExitBadArgs , errors . New ( "key required" ) ) } key := c . Args ( ) [ 0 ] recursive := c . Bool ( "recursive" ) dir := c . Bool ( "dir" ) prevValue := c . String ( "with-value" ) prevIndex := c . Int ( "with-index" ) ctx , cancel := contextWithTotalTimeout ( c ) resp , err := ki . Delete ( ctx , key , & client . DeleteOptions { PrevIndex : uint64 ( prevIndex ) , PrevValue : prevValue , Dir : dir , Recursive : recursive } ) cancel ( ) if err != nil { handleError ( c , ExitServerError , err ) } if ! resp . Node . Dir || c . GlobalString ( "output" ) != "simple" { printResponseKey ( resp , c . GlobalString ( "output" ) ) } }
433	func checkIntervals ( reqs [ ] * pb . RequestOp ) ( map [ string ] struct { } , adt . IntervalTree , error ) { var dels adt . IntervalTree for _ , req := range reqs { tv , ok := req . Request . ( * pb . RequestOp_RequestDeleteRange ) if ! ok { continue } dreq := tv . RequestDeleteRange if dreq == nil { continue } var iv adt . Interval if len ( dreq . RangeEnd ) != 0 { iv = adt . NewStringAffineInterval ( string ( dreq . Key ) , string ( dreq . RangeEnd ) ) } else { iv = adt . NewStringAffinePoint ( string ( dreq . Key ) ) } dels . Insert ( iv , struct { } { } ) } puts := make ( map [ string ] struct { } ) for _ , req := range reqs { tv , ok := req . Request . ( * pb . RequestOp_RequestTxn ) if ! ok { continue } putsThen , delsThen , err := checkIntervals ( tv . RequestTxn . Success ) if err != nil { return nil , dels , err } putsElse , delsElse , err := checkIntervals ( tv . RequestTxn . Failure ) if err != nil { return nil , dels , err } for k := range putsThen { if _ , ok := puts [ k ] ; ok { return nil , dels , rpctypes . ErrGRPCDuplicateKey } if dels . Intersects ( adt . NewStringAffinePoint ( k ) ) { return nil , dels , rpctypes . ErrGRPCDuplicateKey } puts [ k ] = struct { } { } } for k := range putsElse { if _ , ok := puts [ k ] ; ok { if _ , isSafe := putsThen [ k ] ; ! isSafe { return nil , dels , rpctypes . ErrGRPCDuplicateKey } } if dels . Intersects ( adt . NewStringAffinePoint ( k ) ) { return nil , dels , rpctypes . ErrGRPCDuplicateKey } puts [ k ] = struct { } { } } dels . Union ( delsThen , adt . NewStringAffineInterval ( "\x00" , \x00 ) ) "" } dels . Union ( delsElse , adt . NewStringAffineInterval ( "\x00" , \x00 ) ) "" }
434	func ReportEventReceived ( n int ) { pendingEventsGauge . Sub ( float64 ( n ) ) totalEventsCounter . Add ( float64 ( n ) ) }
435	func RegisterKVHandler ( ctx context . Context , mux * runtime . ServeMux , conn * grpc . ClientConn ) error { return RegisterKVHandlerClient ( ctx , mux , etcdserverpb . NewKVClient ( conn ) ) }
436	func RegisterWatchHandler ( ctx context . Context , mux * runtime . ServeMux , conn * grpc . ClientConn ) error { return RegisterWatchHandlerClient ( ctx , mux , etcdserverpb . NewWatchClient ( conn ) ) }
437	func RegisterLeaseHandler ( ctx context . Context , mux * runtime . ServeMux , conn * grpc . ClientConn ) error { return RegisterLeaseHandlerClient ( ctx , mux , etcdserverpb . NewLeaseClient ( conn ) ) }
438	func RegisterClusterHandler ( ctx context . Context , mux * runtime . ServeMux , conn * grpc . ClientConn ) error { return RegisterClusterHandlerClient ( ctx , mux , etcdserverpb . NewClusterClient ( conn ) ) }
439	func RegisterMaintenanceHandler ( ctx context . Context , mux * runtime . ServeMux , conn * grpc . ClientConn ) error { return RegisterMaintenanceHandlerClient ( ctx , mux , etcdserverpb . NewMaintenanceClient ( conn ) ) }
440	func RegisterAuthHandler ( ctx context . Context , mux * runtime . ServeMux , conn * grpc . ClientConn ) error { return RegisterAuthHandlerClient ( ctx , mux , etcdserverpb . NewAuthClient ( conn ) ) }
441	func startEtcd ( cfg * embed . Config ) ( <- chan struct { } , <- chan error , error ) { e , err := embed . StartEtcd ( cfg ) if err != nil { return nil , nil , err } osutil . RegisterInterruptHandler ( e . Close ) select { case <- e . Server . ReadyNotify ( ) : case <- e . Server . StopNotify ( ) : } return e . Server . StopNotify ( ) , e . Err ( ) , nil }
442	func identifyDataDirOrDie ( lg * zap . Logger , dir string ) dirType { names , err := fileutil . ReadDir ( dir ) if err != nil { if os . IsNotExist ( err ) { return dirEmpty } if lg != nil { lg . Fatal ( "failed to list data directory" , zap . String ( "dir" , dir ) , zap . Error ( err ) ) } else { plog . Fatalf ( "error listing data dir: %s" , dir ) } } var m , p bool for _ , name := range names { switch dirType ( name ) { case dirMember : m = true case dirProxy : p = true default : if lg != nil { lg . Warn ( "found invalid file under data directory" , zap . String ( "filename" , name ) , zap . String ( "data-dir" , dir ) , ) } else { plog . Warningf ( "found invalid file/dir %s under data dir %s (Ignore this if you are upgrading etcd)" , name , dir ) } } } if m && p { if lg != nil { lg . Fatal ( "invalid datadir; both member and proxy directories exist" ) } else { plog . Fatal ( "invalid datadir. Both member and proxy directories exist." ) } } if m { return dirMember } if p { return dirProxy } return dirEmpty }
443	func openLast ( lg * zap . Logger , dirpath string ) ( * fileutil . LockedFile , error ) { names , err := readWALNames ( lg , dirpath ) if err != nil { return nil , err } last := filepath . Join ( dirpath , names [ len ( names ) - 1 ] ) return fileutil . LockFile ( last , os . O_RDWR , fileutil . PrivateFileMode ) }
444	func ( l * leader ) gotLeader ( ) { l . mu . Lock ( ) defer l . mu . Unlock ( ) select { case <- l . leaderc : l . leaderc = make ( chan struct { } ) default : } }
445	func ( l * leader ) lostNotify ( ) <- chan struct { } { l . mu . RLock ( ) defer l . mu . RUnlock ( ) return l . leaderc }
446	func newGRPCProxyCommand ( ) * cobra . Command { lpc := & cobra . Command { Use : "grpc-proxy <subcommand>" , Short : "grpc-proxy related command" , } lpc . AddCommand ( newGRPCProxyStartCommand ( ) ) return lpc }
447	func NewMemberCommand ( ) * cobra . Command { mc := & cobra . Command { Use : "member <subcommand>" , Short : "Membership related commands" , } mc . AddCommand ( NewMemberAddCommand ( ) ) mc . AddCommand ( NewMemberRemoveCommand ( ) ) mc . AddCommand ( NewMemberUpdateCommand ( ) ) mc . AddCommand ( NewMemberListCommand ( ) ) return mc }
448	func NewMemberAddCommand ( ) * cobra . Command { cc := & cobra . Command { Use : "add <memberName> [options]" , Short : "Adds a member into the cluster" , Run : memberAddCommandFunc , } cc . Flags ( ) . StringVar ( & memberPeerURLs , "peer-urls" , "" , "comma separated peer URLs for the new member." ) return cc }
449	func NewMemberRemoveCommand ( ) * cobra . Command { cc := & cobra . Command { Use : "remove <memberID>" , Short : "Removes a member from the cluster" , Run : memberRemoveCommandFunc , } return cc }
450	func NewMemberUpdateCommand ( ) * cobra . Command { cc := & cobra . Command { Use : "update <memberID> [options]" , Short : "Updates a member in the cluster" , Run : memberUpdateCommandFunc , } cc . Flags ( ) . StringVar ( & memberPeerURLs , "peer-urls" , "" , "comma separated peer URLs for the updated member." ) return cc }
451	func NewMemberListCommand ( ) * cobra . Command { cc := & cobra . Command { Use : "list" , Short : "Lists all members in the cluster" , Long : `When --write-out is set to simple, this command prints out comma-separated member lists for each endpoint.The items in the lists are ID, Status, Name, Peer Addrs, Client Addrs.` , Run : memberListCommandFunc , } return cc }
452	func memberAddCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) < 1 { ExitWithError ( ExitBadArgs , errors . New ( "member name not provided" ) ) } if len ( args ) > 1 { ev := "too many arguments" for _ , s := range args { if strings . HasPrefix ( strings . ToLower ( s ) , "http" ) { ev += fmt . Sprintf ( `, did you mean --peer-urls=%s` , s ) } } ExitWithError ( ExitBadArgs , errors . New ( ev ) ) } newMemberName := args [ 0 ] if len ( memberPeerURLs ) == 0 { ExitWithError ( ExitBadArgs , errors . New ( "member peer urls not provided" ) ) } urls := strings . Split ( memberPeerURLs , "," ) ctx , cancel := commandCtx ( cmd ) cli := mustClientFromCmd ( cmd ) resp , err := cli . MemberAdd ( ctx , urls ) cancel ( ) if err != nil { ExitWithError ( ExitError , err ) } newID := resp . Member . ID display . MemberAdd ( * resp ) if _ , ok := ( display ) . ( * simplePrinter ) ; ok { ctx , cancel = commandCtx ( cmd ) listResp , err := cli . MemberList ( ctx ) for { if err != nil { ExitWithError ( ExitError , err ) } if listResp . Header . MemberId == resp . Header . MemberId { break } gresp , gerr := cli . Get ( ctx , "_" ) if gerr != nil { ExitWithError ( ExitError , err ) } resp . Header . MemberId = gresp . Header . MemberId listResp , err = cli . MemberList ( ctx ) } cancel ( ) conf := [ ] string { } for _ , memb := range listResp . Members { for _ , u := range memb . PeerURLs { n := memb . Name if memb . ID == newID { n = newMemberName } conf = append ( conf , fmt . Sprintf ( "%s=%s" , n , u ) ) } } fmt . Print ( "\n" ) \n fmt . Printf ( "ETCD_NAME=%q\n" , \n ) newMemberName fmt . Printf ( "ETCD_INITIAL_CLUSTER=%q\n" , \n ) } }
453	func memberRemoveCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 1 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "member ID is not provided" ) ) } id , err := strconv . ParseUint ( args [ 0 ] , 16 , 64 ) if err != nil { ExitWithError ( ExitBadArgs , fmt . Errorf ( "bad member ID arg (%v), expecting ID in Hex" , err ) ) } ctx , cancel := commandCtx ( cmd ) resp , err := mustClientFromCmd ( cmd ) . MemberRemove ( ctx , id ) cancel ( ) if err != nil { ExitWithError ( ExitError , err ) } display . MemberRemove ( id , * resp ) }
454	func memberUpdateCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 1 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "member ID is not provided" ) ) } id , err := strconv . ParseUint ( args [ 0 ] , 16 , 64 ) if err != nil { ExitWithError ( ExitBadArgs , fmt . Errorf ( "bad member ID arg (%v), expecting ID in Hex" , err ) ) } if len ( memberPeerURLs ) == 0 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "member peer urls not provided" ) ) } urls := strings . Split ( memberPeerURLs , "," ) ctx , cancel := commandCtx ( cmd ) resp , err := mustClientFromCmd ( cmd ) . MemberUpdate ( ctx , id , urls ) cancel ( ) if err != nil { ExitWithError ( ExitError , err ) } display . MemberUpdate ( id , * resp ) }
455	func memberListCommandFunc ( cmd * cobra . Command , args [ ] string ) { ctx , cancel := commandCtx ( cmd ) resp , err := mustClientFromCmd ( cmd ) . MemberList ( ctx ) cancel ( ) if err != nil { ExitWithError ( ExitError , err ) } display . MemberList ( * resp ) }
456	func Open ( lg * zap . Logger , dirpath string , snap walpb . Snapshot ) ( * WAL , error ) { w , err := openAtIndex ( lg , dirpath , snap , true ) if err != nil { return nil , err } if w . dirFile , err = fileutil . OpenDir ( w . dir ) ; err != nil { return nil , err } return w , nil }
457	func OpenForRead ( lg * zap . Logger , dirpath string , snap walpb . Snapshot ) ( * WAL , error ) { return openAtIndex ( lg , dirpath , snap , false ) }
458	func Verify ( lg * zap . Logger , walDir string , snap walpb . Snapshot ) error { var metadata [ ] byte var err error var match bool rec := & walpb . Record { } names , nameIndex , err := selectWALFiles ( lg , walDir , snap ) if err != nil { return err } rs , _ , closer , err := openWALFiles ( lg , walDir , names , nameIndex , false ) if err != nil { return err } decoder := newDecoder ( rs ... ) for err = decoder . decode ( rec ) ; err == nil ; err = decoder . decode ( rec ) { switch rec . Type { case metadataType : if metadata != nil && ! bytes . Equal ( metadata , rec . Data ) { return ErrMetadataConflict } metadata = rec . Data case crcType : crc := decoder . crc . Sum32 ( ) if crc != 0 && rec . Validate ( crc ) != nil { return ErrCRCMismatch } decoder . updateCRC ( rec . Crc ) case snapshotType : var loadedSnap walpb . Snapshot pbutil . MustUnmarshal ( & loadedSnap , rec . Data ) if loadedSnap . Index == snap . Index { if loadedSnap . Term != snap . Term { return ErrSnapshotMismatch } match = true } case entryType : case stateType : default : return fmt . Errorf ( "unexpected block type %d" , rec . Type ) } } if closer != nil { closer ( ) } if err != io . EOF && err != io . ErrUnexpectedEOF { return err } if ! match { return ErrSnapshotNotFound } return nil }
459	func ( w * WAL ) Close ( ) error { w . mu . Lock ( ) defer w . mu . Unlock ( ) if w . fp != nil { w . fp . Close ( ) w . fp = nil } if w . tail ( ) != nil { if err := w . sync ( ) ; err != nil { return err } } for _ , l := range w . locks { if l == nil { continue } if err := l . Close ( ) ; err != nil { if w . lg != nil { w . lg . Warn ( "failed to close WAL" , zap . Error ( err ) ) } else { plog . Errorf ( "failed to unlock during closing wal: %s" , err ) } } } return w . dirFile . Close ( ) }
460	func ( w * watcher ) notify ( e * Event , originalPath bool , deleted bool ) bool { if ( w . recursive || originalPath || deleted ) && e . Index ( ) >= w . sinceIndex { select { case w . eventChan <- e : default : w . remove ( ) } return true } return false }
461	func ( w * watcher ) Remove ( ) { w . hub . mutex . Lock ( ) defer w . hub . mutex . Unlock ( ) close ( w . eventChan ) if w . remove != nil { w . remove ( ) } }
462	func ( s * v2v3Store ) mkPathDepth ( nodePath string , depth int ) string { normalForm := path . Clean ( path . Join ( "/" , nodePath ) ) n := strings . Count ( normalForm , "/" ) + depth return fmt . Sprintf ( "%s/%03d/k/%s" , s . pfx , n , normalForm ) }
463	func ( s * v2v3Store ) mkV2Node ( kv * mvccpb . KeyValue ) * v2store . NodeExtern { if kv == nil { return nil } n := & v2store . NodeExtern { Key : s . mkNodePath ( string ( kv . Key ) ) , Dir : kv . Key [ len ( kv . Key ) - 1 ] == '/' , CreatedIndex : mkV2Rev ( kv . CreateRevision ) , ModifiedIndex : mkV2Rev ( kv . ModRevision ) , } if ! n . Dir { v := string ( kv . Value ) n . Value = & v } return n }
464	func prevKeyFromPuts ( resp * clientv3 . TxnResponse ) * mvccpb . KeyValue { for _ , r := range resp . Responses { pkv := r . GetResponsePut ( ) . PrevKv if pkv != nil && pkv . CreateRevision > 0 { return pkv } } return nil }
465	func NewWeightedReport ( r Report , precision string ) Report { return & weightedReport { baseReport : r , report : newReport ( precision ) , results : make ( chan Result , 16 ) , } }
466	func NewURLsMapFromStringMap ( m map [ string ] string , sep string ) ( URLsMap , error ) { var err error um := URLsMap { } for k , v := range m { um [ k ] , err = NewURLs ( strings . Split ( v , sep ) ) if err != nil { return nil , err } } return um , nil }
467	func ( c URLsMap ) String ( ) string { var pairs [ ] string for name , urls := range c { for _ , url := range urls { pairs = append ( pairs , fmt . Sprintf ( "%s=%s" , name , url . String ( ) ) ) } } sort . Strings ( pairs ) return strings . Join ( pairs , "," ) }
468	func ( c URLsMap ) URLs ( ) [ ] string { var urls [ ] string for _ , us := range c { for _ , u := range us { urls = append ( urls , u . String ( ) ) } } sort . Strings ( urls ) return urls }
469	func parse ( s string ) map [ string ] [ ] string { m := make ( map [ string ] [ ] string ) for s != "" { key := s if i := strings . IndexAny ( key , "," ) ; i >= 0 { key , s = key [ : i ] , key [ i + 1 : ] } else { s = "" } if key == "" { continue } value := "" if i := strings . Index ( key , "=" ) ; i >= 0 { key , value = key [ : i ] , key [ i + 1 : ] } m [ key ] = append ( m [ key ] , value ) } return m }
470	func NewClientHandler ( lg * zap . Logger , server etcdserver . ServerPeer , timeout time . Duration ) http . Handler { mux := http . NewServeMux ( ) etcdhttp . HandleBasic ( mux , server ) handleV2 ( lg , mux , server , timeout ) return requestLogger ( lg , mux ) }
471	func writeKeyEvent ( w http . ResponseWriter , resp etcdserver . Response , noValueOnSuccess bool ) error { ev := resp . Event if ev == nil { return errors . New ( "cannot write empty Event" ) } w . Header ( ) . Set ( "Content-Type" , "application/json" ) w . Header ( ) . Set ( "X-Etcd-Index" , fmt . Sprint ( ev . EtcdIndex ) ) w . Header ( ) . Set ( "X-Raft-Index" , fmt . Sprint ( resp . Index ) ) w . Header ( ) . Set ( "X-Raft-Term" , fmt . Sprint ( resp . Term ) ) if ev . IsCreated ( ) { w . WriteHeader ( http . StatusCreated ) } ev = trimEventPrefix ( ev , etcdserver . StoreKeysPrefix ) if noValueOnSuccess && ( ev . Action == v2store . Set || ev . Action == v2store . CompareAndSwap || ev . Action == v2store . Create || ev . Action == v2store . Update ) { ev . Node = nil ev . PrevNode = nil } return json . NewEncoder ( w ) . Encode ( ev ) }
472	func writeKeyError ( lg * zap . Logger , w http . ResponseWriter , err error ) { if err == nil { return } switch e := err . ( type ) { case * v2error . Error : e . WriteTo ( w ) default : switch err { case etcdserver . ErrTimeoutDueToLeaderFail , etcdserver . ErrTimeoutDueToConnectionLost : if lg != nil { lg . Warn ( "v2 response error" , zap . String ( "internal-server-error" , err . Error ( ) ) , ) } else { mlog . MergeError ( err ) } default : if lg != nil { lg . Warn ( "unexpected v2 response error" , zap . String ( "internal-server-error" , err . Error ( ) ) , ) } else { mlog . MergeErrorf ( "got unexpected response error (%v)" , err ) } } ee := v2error . NewError ( v2error . EcodeRaftInternal , err . Error ( ) , 0 ) ee . WriteTo ( w ) } }
473	func getUint64 ( form url . Values , key string ) ( i uint64 , err error ) { if vals , ok := form [ key ] ; ok { i , err = strconv . ParseUint ( vals [ 0 ] , 10 , 64 ) } return }
474	func getBool ( form url . Values , key string ) ( b bool , err error ) { if vals , ok := form [ key ] ; ok { b , err = strconv . ParseBool ( vals [ 0 ] ) } return }
475	func waitDeletes ( ctx context . Context , client * v3 . Client , pfx string , maxCreateRev int64 ) ( * pb . ResponseHeader , error ) { getOpts := append ( v3 . WithLastCreate ( ) , v3 . WithMaxCreateRev ( maxCreateRev ) ) for { resp , err := client . Get ( ctx , pfx , getOpts ... ) if err != nil { return nil , err } if len ( resp . Kvs ) == 0 { return resp . Header , nil } lastKey := string ( resp . Kvs [ 0 ] . Key ) if err = waitDelete ( ctx , client , lastKey , resp . Header . Revision ) ; err != nil { return nil , err } } }
476	func AddOutputPaths ( cfg zap . Config , outputPaths , errorOutputPaths [ ] string ) zap . Config { outputs := make ( map [ string ] struct { } ) for _ , v := range cfg . OutputPaths { outputs [ v ] = struct { } { } } for _ , v := range outputPaths { outputs [ v ] = struct { } { } } outputSlice := make ( [ ] string , 0 ) if _ , ok := outputs [ "/dev/null" ] ; ok { outputSlice = [ ] string { "/dev/null" } } else { for k := range outputs { outputSlice = append ( outputSlice , k ) } } cfg . OutputPaths = outputSlice sort . Strings ( cfg . OutputPaths ) errOutputs := make ( map [ string ] struct { } ) for _ , v := range cfg . ErrorOutputPaths { errOutputs [ v ] = struct { } { } } for _ , v := range errorOutputPaths { errOutputs [ v ] = struct { } { } } errOutputSlice := make ( [ ] string , 0 ) if _ , ok := errOutputs [ "/dev/null" ] ; ok { errOutputSlice = [ ] string { "/dev/null" } } else { for k := range errOutputs { errOutputSlice = append ( errOutputSlice , k ) } } cfg . ErrorOutputPaths = errOutputSlice sort . Strings ( cfg . ErrorOutputPaths ) return cfg }
477	func NewConfig ( ) * Config { lpurl , _ := url . Parse ( DefaultListenPeerURLs ) apurl , _ := url . Parse ( DefaultInitialAdvertisePeerURLs ) lcurl , _ := url . Parse ( DefaultListenClientURLs ) acurl , _ := url . Parse ( DefaultAdvertiseClientURLs ) cfg := & Config { MaxSnapFiles : DefaultMaxSnapshots , MaxWalFiles : DefaultMaxWALs , Name : DefaultName , SnapshotCount : etcdserver . DefaultSnapshotCount , SnapshotCatchUpEntries : etcdserver . DefaultSnapshotCatchUpEntries , MaxTxnOps : DefaultMaxTxnOps , MaxRequestBytes : DefaultMaxRequestBytes , GRPCKeepAliveMinTime : DefaultGRPCKeepAliveMinTime , GRPCKeepAliveInterval : DefaultGRPCKeepAliveInterval , GRPCKeepAliveTimeout : DefaultGRPCKeepAliveTimeout , TickMs : 100 , ElectionMs : 1000 , InitialElectionTickAdvance : true , LPUrls : [ ] url . URL { * lpurl } , LCUrls : [ ] url . URL { * lcurl } , APUrls : [ ] url . URL { * apurl } , ACUrls : [ ] url . URL { * acurl } , ClusterState : ClusterStateFlagNew , InitialClusterToken : "etcd-cluster" , StrictReconfigCheck : DefaultStrictReconfigCheck , Metrics : "basic" , EnableV2 : DefaultEnableV2 , CORS : map [ string ] struct { } { "*" : { } } , HostWhitelist : map [ string ] struct { } { "*" : { } } , AuthToken : "simple" , BcryptCost : uint ( bcrypt . DefaultCost ) , PreVote : false , loggerMu : new ( sync . RWMutex ) , logger : nil , Logger : "capnslog" , DeprecatedLogOutput : [ ] string { DefaultLogOutput } , LogOutputs : [ ] string { DefaultLogOutput } , Debug : false , LogPkgLevels : "" , } cfg . InitialCluster = cfg . InitialClusterFromName ( cfg . Name ) return cfg }
478	func ( cfg * Config ) PeerURLsMapAndToken ( which string ) ( urlsmap types . URLsMap , token string , err error ) { token = cfg . InitialClusterToken switch { case cfg . Durl != "" : urlsmap = types . URLsMap { } urlsmap [ cfg . Name ] = cfg . APUrls token = cfg . Durl case cfg . DNSCluster != "" : clusterStrs , cerr := cfg . GetDNSClusterNames ( ) lg := cfg . logger if cerr != nil { if lg != nil { lg . Warn ( "failed to resolve during SRV discovery" , zap . Error ( cerr ) ) } else { plog . Errorf ( "couldn't resolve during SRV discovery (%v)" , cerr ) } return nil , "" , cerr } for _ , s := range clusterStrs { if lg != nil { lg . Info ( "got bootstrap from DNS for etcd-server" , zap . String ( "node" , s ) ) } else { plog . Noticef ( "got bootstrap from DNS for etcd-server at %s" , s ) } } clusterStr := strings . Join ( clusterStrs , "," ) if strings . Contains ( clusterStr , "https://" ) && cfg . PeerTLSInfo . TrustedCAFile == "" { cfg . PeerTLSInfo . ServerName = cfg . DNSCluster } urlsmap , err = types . NewURLsMap ( clusterStr ) if which == "etcd" { if _ , ok := urlsmap [ cfg . Name ] ; ! ok { return nil , "" , fmt . Errorf ( "cannot find local etcd member %q in SRV records" , cfg . Name ) } } default : urlsmap , err = types . NewURLsMap ( cfg . InitialCluster ) } return urlsmap , token , err }
479	func ( cfg * Config ) GetDNSClusterNames ( ) ( [ ] string , error ) { var ( clusterStrs [ ] string cerr error serviceNameSuffix string ) if cfg . DNSClusterServiceName != "" { serviceNameSuffix = "-" + cfg . DNSClusterServiceName } lg := cfg . GetLogger ( ) clusterStrs , cerr = srv . GetCluster ( "https" , "etcd-server-ssl" + serviceNameSuffix , cfg . Name , cfg . DNSCluster , cfg . APUrls ) if cerr != nil { clusterStrs = make ( [ ] string , 0 ) } if lg != nil { lg . Info ( "get cluster for etcd-server-ssl SRV" , zap . String ( "service-scheme" , "https" ) , zap . String ( "service-name" , "etcd-server-ssl" + serviceNameSuffix ) , zap . String ( "server-name" , cfg . Name ) , zap . String ( "discovery-srv" , cfg . DNSCluster ) , zap . Strings ( "advertise-peer-urls" , cfg . getAPURLs ( ) ) , zap . Strings ( "found-cluster" , clusterStrs ) , zap . Error ( cerr ) , ) } defaultHTTPClusterStrs , httpCerr := srv . GetCluster ( "http" , "etcd-server" + serviceNameSuffix , cfg . Name , cfg . DNSCluster , cfg . APUrls ) if httpCerr != nil { clusterStrs = append ( clusterStrs , defaultHTTPClusterStrs ... ) } if lg != nil { lg . Info ( "get cluster for etcd-server SRV" , zap . String ( "service-scheme" , "http" ) , zap . String ( "service-name" , "etcd-server" + serviceNameSuffix ) , zap . String ( "server-name" , cfg . Name ) , zap . String ( "discovery-srv" , cfg . DNSCluster ) , zap . Strings ( "advertise-peer-urls" , cfg . getAPURLs ( ) ) , zap . Strings ( "found-cluster" , clusterStrs ) , zap . Error ( httpCerr ) , ) } return clusterStrs , cerr }
480	func checkBindURLs ( urls [ ] url . URL ) error { for _ , url := range urls { if url . Scheme == "unix" || url . Scheme == "unixs" { continue } host , _ , err := net . SplitHostPort ( url . Host ) if err != nil { return err } if host == "localhost" { continue } if net . ParseIP ( host ) == nil { return fmt . Errorf ( "expected IP in URL for binding (%s)" , url . String ( ) ) } } return nil }
481	func GetCluster ( serviceScheme , service , name , dns string , apurls types . URLs ) ( [ ] string , error ) { tempName := int ( 0 ) tcp2ap := make ( map [ string ] url . URL ) for _ , url := range apurls { tcpAddr , err := resolveTCPAddr ( "tcp" , url . Host ) if err != nil { return nil , err } tcp2ap [ tcpAddr . String ( ) ] = url } stringParts := [ ] string { } updateNodeMap := func ( service , scheme string ) error { _ , addrs , err := lookupSRV ( service , "tcp" , dns ) if err != nil { return err } for _ , srv := range addrs { port := fmt . Sprintf ( "%d" , srv . Port ) host := net . JoinHostPort ( srv . Target , port ) tcpAddr , terr := resolveTCPAddr ( "tcp" , host ) if terr != nil { err = terr continue } n := "" url , ok := tcp2ap [ tcpAddr . String ( ) ] if ok { n = name } if n == "" { n = fmt . Sprintf ( "%d" , tempName ) tempName ++ } shortHost := strings . TrimSuffix ( srv . Target , "." ) urlHost := net . JoinHostPort ( shortHost , port ) if ok && url . Scheme != scheme { err = fmt . Errorf ( "bootstrap at %s from DNS for %s has scheme mismatch with expected peer %s" , scheme + "://" + urlHost , service , url . String ( ) ) } else { stringParts = append ( stringParts , fmt . Sprintf ( "%s=%s://%s" , n , scheme , urlHost ) ) } } if len ( stringParts ) == 0 { return err } return nil } err := updateNodeMap ( service , serviceScheme ) if err != nil { return nil , fmt . Errorf ( "error querying DNS SRV records for _%s %s" , service , err ) } return stringParts , nil }
482	func GetClient ( service , domain string , serviceName string ) ( * SRVClients , error ) { var urls [ ] * url . URL var srvs [ ] * net . SRV updateURLs := func ( service , scheme string ) error { _ , addrs , err := lookupSRV ( service , "tcp" , domain ) if err != nil { return err } for _ , srv := range addrs { urls = append ( urls , & url . URL { Scheme : scheme , Host : net . JoinHostPort ( srv . Target , fmt . Sprintf ( "%d" , srv . Port ) ) , } ) } srvs = append ( srvs , addrs ... ) return nil } errHTTPS := updateURLs ( GetSRVService ( service , serviceName , "https" ) , "https" ) errHTTP := updateURLs ( GetSRVService ( service , serviceName , "http" ) , "http" ) if errHTTPS != nil && errHTTP != nil { return nil , fmt . Errorf ( "dns lookup errors: %s and %s" , errHTTPS , errHTTP ) } endpoints := make ( [ ] string , len ( urls ) ) for i := range urls { endpoints [ i ] = urls [ i ] . String ( ) } return & SRVClients { Endpoints : endpoints , SRVs : srvs } , nil }
483	func GetSRVService ( service , serviceName string , scheme string ) ( SRVService string ) { if scheme == "https" { service = fmt . Sprintf ( "%s-ssl" , service ) } if serviceName != "" { return fmt . Sprintf ( "%s-%s" , service , serviceName ) } return service }
484	func ReadDir ( d string , opts ... ReadDirOption ) ( [ ] string , error ) { op := & ReadDirOp { } op . applyOpts ( opts ) dir , err := os . Open ( d ) if err != nil { return nil , err } defer dir . Close ( ) names , err := dir . Readdirnames ( - 1 ) if err != nil { return nil , err } sort . Strings ( names ) if op . ext != "" { tss := make ( [ ] string , 0 ) for _ , v := range names { if filepath . Ext ( v ) == op . ext { tss = append ( tss , v ) } } names = tss } return names , nil }
485	func compact ( c * v3 . Client , rev int64 ) { fmt . Printf ( "Compacting with revision %d\n" , \n ) rev ctx , cancel := context . WithTimeout ( context . Background ( ) , 30 * time . Second ) _ , err := c . Compact ( ctx , rev , v3 . WithCompactPhysical ( ) ) cancel ( ) if err != nil { ExitWithError ( ExitError , err ) } }
486	func defrag ( c * v3 . Client , ep string ) { fmt . Printf ( "Defragmenting %q\n" , \n ) ep ctx , cancel := context . WithTimeout ( context . Background ( ) , 30 * time . Second ) _ , err := c . Defragment ( ctx , ep ) cancel ( ) if err != nil { ExitWithError ( ExitError , err ) } }
487	func NewUserCommand ( ) * cobra . Command { ac := & cobra . Command { Use : "user <subcommand>" , Short : "User related commands" , } ac . AddCommand ( newUserAddCommand ( ) ) ac . AddCommand ( newUserDeleteCommand ( ) ) ac . AddCommand ( newUserGetCommand ( ) ) ac . AddCommand ( newUserListCommand ( ) ) ac . AddCommand ( newUserChangePasswordCommand ( ) ) ac . AddCommand ( newUserGrantRoleCommand ( ) ) ac . AddCommand ( newUserRevokeRoleCommand ( ) ) return ac }
488	func userAddCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 1 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "user add command requires user name as its argument" ) ) } var password string var user string if passwordFromFlag != "" { user = args [ 0 ] password = passwordFromFlag } else { splitted := strings . SplitN ( args [ 0 ] , ":" , 2 ) if len ( splitted ) < 2 { user = args [ 0 ] if ! passwordInteractive { fmt . Scanf ( "%s" , & password ) } else { password = readPasswordInteractive ( args [ 0 ] ) } } else { user = splitted [ 0 ] password = splitted [ 1 ] if len ( user ) == 0 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "empty user name is not allowed" ) ) } } } resp , err := mustClientFromCmd ( cmd ) . Auth . UserAdd ( context . TODO ( ) , user , password ) if err != nil { ExitWithError ( ExitError , err ) } display . UserAdd ( user , * resp ) }
489	func userGetCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 1 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "user get command requires user name as its argument" ) ) } name := args [ 0 ] client := mustClientFromCmd ( cmd ) resp , err := client . Auth . UserGet ( context . TODO ( ) , name ) if err != nil { ExitWithError ( ExitError , err ) } if userShowDetail { fmt . Printf ( "User: %s\n" , \n ) name } else for _ , role := range resp . Roles { fmt . Printf ( "\n" ) \n roleResp , err := client . Auth . RoleGet ( context . TODO ( ) , role ) if err != nil { ExitWithError ( ExitError , err ) } } }
490	func userChangePasswordCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 1 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "user passwd command requires user name as its argument" ) ) } var password string if ! passwordInteractive { fmt . Scanf ( "%s" , & password ) } else { password = readPasswordInteractive ( args [ 0 ] ) } resp , err := mustClientFromCmd ( cmd ) . Auth . UserChangePassword ( context . TODO ( ) , args [ 0 ] , password ) if err != nil { ExitWithError ( ExitError , err ) } display . UserChangePassword ( * resp ) }
491	func ( eh * EventHistory ) addEvent ( e * Event ) * Event { eh . rwl . Lock ( ) defer eh . rwl . Unlock ( ) eh . Queue . insert ( e ) eh . LastIndex = e . Index ( ) eh . StartIndex = eh . Queue . Events [ eh . Queue . Front ] . Index ( ) return e }
492	func ( eh * EventHistory ) scan ( key string , recursive bool , index uint64 ) ( * Event , * v2error . Error ) { eh . rwl . RLock ( ) defer eh . rwl . RUnlock ( ) if index < eh . StartIndex { return nil , v2error . NewError ( v2error . EcodeEventIndexCleared , fmt . Sprintf ( "the requested history has been cleared [%v/%v]" , eh . StartIndex , index ) , 0 ) } if index > eh . LastIndex { return nil , nil } offset := index - eh . StartIndex i := ( eh . Queue . Front + int ( offset ) ) % eh . Queue . Capacity for { e := eh . Queue . Events [ i ] if ! e . Refresh { ok := e . Node . Key == key if recursive { nkey := path . Clean ( key ) if nkey [ len ( nkey ) - 1 ] != '/' { nkey = nkey + "/" } ok = ok || strings . HasPrefix ( e . Node . Key , nkey ) } if ( e . Action == Delete || e . Action == Expire ) && e . PrevNode != nil && e . PrevNode . Dir { ok = ok || strings . HasPrefix ( key , e . PrevNode . Key ) } if ok { return e , nil } } i = ( i + 1 ) % eh . Queue . Capacity if i == eh . Queue . Back { return nil , nil } } }
493	func ( eh * EventHistory ) clone ( ) * EventHistory { clonedQueue := eventQueue { Capacity : eh . Queue . Capacity , Events : make ( [ ] * Event , eh . Queue . Capacity ) , Size : eh . Queue . Size , Front : eh . Queue . Front , Back : eh . Queue . Back , } copy ( clonedQueue . Events , eh . Queue . Events ) return & EventHistory { StartIndex : eh . StartIndex , Queue : clonedQueue , LastIndex : eh . LastIndex , } }
494	func openSnapshotBackend ( cfg ServerConfig , ss * snap . Snapshotter , snapshot raftpb . Snapshot ) ( backend . Backend , error ) { snapPath , err := ss . DBFilePath ( snapshot . Metadata . Index ) if err != nil { return nil , fmt . Errorf ( "failed to find database snapshot file (%v)" , err ) } if err := os . Rename ( snapPath , cfg . backendPath ( ) ) ; err != nil { return nil , fmt . Errorf ( "failed to rename database snapshot file (%v)" , err ) } return openBackend ( cfg ) , nil }
495	func openBackend ( cfg ServerConfig ) backend . Backend { fn := cfg . backendPath ( ) now , beOpened := time . Now ( ) , make ( chan backend . Backend ) go func ( ) { beOpened <- newBackend ( cfg ) } ( ) select { case be := <- beOpened : if cfg . Logger != nil { cfg . Logger . Info ( "opened backend db" , zap . String ( "path" , fn ) , zap . Duration ( "took" , time . Since ( now ) ) ) } return be case <- time . After ( 10 * time . Second ) : if cfg . Logger != nil { cfg . Logger . Info ( "db file is flocked by another process, or taking too long" , zap . String ( "path" , fn ) , zap . Duration ( "took" , time . Since ( now ) ) , ) } else { plog . Warningf ( "another etcd process is using %q and holds the file lock, or loading backend file is taking >10 seconds" , fn ) plog . Warningf ( "waiting for it to exit before starting..." ) } } return <- beOpened }
496	func recoverSnapshotBackend ( cfg ServerConfig , oldbe backend . Backend , snapshot raftpb . Snapshot ) ( backend . Backend , error ) { var cIndex consistentIndex kv := mvcc . New ( cfg . Logger , oldbe , & lease . FakeLessor { } , & cIndex ) defer kv . Close ( ) if snapshot . Metadata . Index <= kv . ConsistentIndex ( ) { return oldbe , nil } oldbe . Close ( ) return openSnapshotBackend ( cfg , snap . New ( cfg . Logger , cfg . SnapDir ( ) ) , snapshot ) }
497	func NewUpdateCommand ( ) cli . Command { return cli . Command { Name : "update" , Usage : "update an existing key with a given value" , ArgsUsage : "<key> <value>" , Flags : [ ] cli . Flag { cli . IntFlag { Name : "ttl" , Value : 0 , Usage : "key time-to-live in seconds" } , } , Action : func ( c * cli . Context ) error { updateCommandFunc ( c , mustNewKeyAPI ( c ) ) return nil } , } }
498	func updateCommandFunc ( c * cli . Context , ki client . KeysAPI ) { if len ( c . Args ( ) ) == 0 { handleError ( c , ExitBadArgs , errors . New ( "key required" ) ) } key := c . Args ( ) [ 0 ] value , err := argOrStdin ( c . Args ( ) , os . Stdin , 1 ) if err != nil { handleError ( c , ExitBadArgs , errors . New ( "value required" ) ) } ttl := c . Int ( "ttl" ) ctx , cancel := contextWithTotalTimeout ( c ) resp , err := ki . Set ( ctx , key , value , & client . SetOptions { TTL : time . Duration ( ttl ) * time . Second , PrevExist : client . PrevExist } ) cancel ( ) if err != nil { handleError ( c , ExitServerError , err ) } printResponseKey ( resp , c . GlobalString ( "output" ) ) }
499	func ( q * statsQueue ) frontAndBack ( ) ( * RequestStats , * RequestStats ) { q . rwl . RLock ( ) defer q . rwl . RUnlock ( ) if q . size != 0 { return q . items [ q . front ] , q . items [ q . back ] } return nil , nil }
500	func ( q * statsQueue ) Insert ( p * RequestStats ) { q . rwl . Lock ( ) defer q . rwl . Unlock ( ) q . back = ( q . back + 1 ) % queueCapacity if q . size == queueCapacity { q . totalReqSize -= q . items [ q . front ] . Size q . front = ( q . back + 1 ) % queueCapacity } else { q . size ++ } q . items [ q . back ] = p q . totalReqSize += q . items [ q . back ] . Size }
501	func ( q * statsQueue ) Rate ( ) ( float64 , float64 ) { front , back := q . frontAndBack ( ) if front == nil || back == nil { return 0 , 0 } if time . Since ( back . SendingTime ) > time . Second { q . Clear ( ) return 0 , 0 } sampleDuration := back . SendingTime . Sub ( front . SendingTime ) pr := float64 ( q . Len ( ) ) / float64 ( sampleDuration ) * float64 ( time . Second ) br := float64 ( q . ReqSize ( ) ) / float64 ( sampleDuration ) * float64 ( time . Second ) return pr , br }
502	func ( q * statsQueue ) Clear ( ) { q . rwl . Lock ( ) defer q . rwl . Unlock ( ) q . back = - 1 q . front = 0 q . size = 0 q . totalReqSize = 0 }
503	func UniqueStrings ( slen uint , n int ) ( ss [ ] string ) { exist := make ( map [ string ] struct { } ) ss = make ( [ ] string , 0 , n ) for len ( ss ) < n { s := randString ( slen ) if _ , ok := exist [ s ] ; ! ok { ss = append ( ss , s ) exist [ s ] = struct { } { } } } return ss }
504	func RandomStrings ( slen uint , n int ) ( ss [ ] string ) { ss = make ( [ ] string , 0 , n ) for i := 0 ; i < n ; i ++ { ss = append ( ss , randString ( slen ) ) } return ss }
505	func IsKeyNotFound ( err error ) bool { if cErr , ok := err . ( Error ) ; ok { return cErr . Code == ErrorCodeKeyNotFound } return false }
506	func IsRoleNotFound ( err error ) bool { if ae , ok := err . ( authError ) ; ok { return roleNotFoundRegExp . MatchString ( ae . Message ) } return false }
507	func IsUserNotFound ( err error ) bool { if ae , ok := err . ( authError ) ; ok { return userNotFoundRegExp . MatchString ( ae . Message ) } return false }
508	func JoinCluster ( lg * zap . Logger , durl , dproxyurl string , id types . ID , config string ) ( string , error ) { d , err := newDiscovery ( lg , durl , dproxyurl , id ) if err != nil { return "" , err } return d . joinCluster ( config ) }
509	func GetCluster ( lg * zap . Logger , durl , dproxyurl string ) ( string , error ) { d , err := newDiscovery ( lg , durl , dproxyurl , 0 ) if err != nil { return "" , err } return d . getCluster ( ) }
510	func newProxyFunc ( lg * zap . Logger , proxy string ) ( func ( * http . Request ) ( * url . URL , error ) , error ) { if proxy == "" { return nil , nil } proxyURL , err := url . Parse ( proxy ) if err != nil || ! strings . HasPrefix ( proxyURL . Scheme , "http" ) { var err2 error proxyURL , err2 = url . Parse ( "http://" + proxy ) if err2 == nil { err = nil } } if err != nil { return nil , fmt . Errorf ( "invalid proxy address %q: %v" , proxy , err ) } if lg != nil { lg . Info ( "running proxy with discovery" , zap . String ( "proxy-url" , proxyURL . String ( ) ) ) } else { plog . Infof ( "using proxy %q" , proxyURL . String ( ) ) } return http . ProxyURL ( proxyURL ) , nil }
511	func isSafeRetry ( lg * zap . Logger , err error , callOpts * options ) bool { if isContextError ( err ) { return false } switch callOpts . retryPolicy { case repeatable : return isSafeRetryImmutableRPC ( err ) case nonRepeatable : return isSafeRetryMutableRPC ( err ) default : lg . Warn ( "unrecognized retry policy" , zap . String ( "retryPolicy" , callOpts . retryPolicy . String ( ) ) ) return false } }
512	func withRetryPolicy ( rp retryPolicy ) retryOption { return retryOption { applyFunc : func ( o * options ) { o . retryPolicy = rp } } }
513	func withAuthRetry ( retryAuth bool ) retryOption { return retryOption { applyFunc : func ( o * options ) { o . retryAuth = retryAuth } } }
514	func withMax ( maxRetries uint ) retryOption { return retryOption { applyFunc : func ( o * options ) { o . max = maxRetries } } }
515	func withBackoff ( bf backoffFunc ) retryOption { return retryOption { applyFunc : func ( o * options ) { o . backoffFunc = bf } } }
516	func ( ss * ServerStats ) RecvAppendReq ( leader string , reqSize int ) { ss . Lock ( ) defer ss . Unlock ( ) now := time . Now ( ) ss . State = raft . StateFollower if leader != ss . LeaderInfo . Name { ss . LeaderInfo . Name = leader ss . LeaderInfo . StartTime = now } ss . recvRateQueue . Insert ( & RequestStats { SendingTime : now , Size : reqSize , } , ) ss . RecvAppendRequestCnt ++ }
517	func ( ss * ServerStats ) SendAppendReq ( reqSize int ) { ss . Lock ( ) defer ss . Unlock ( ) ss . becomeLeader ( ) ss . sendRateQueue . Insert ( & RequestStats { SendingTime : time . Now ( ) , Size : reqSize , } , ) ss . SendAppendRequestCnt ++ }
518	func ( bb * bucketBuffer ) merge ( bbsrc * bucketBuffer ) { for i := 0 ; i < bbsrc . used ; i ++ { bb . add ( bbsrc . buf [ i ] . key , bbsrc . buf [ i ] . val ) } if bb . used == bbsrc . used { return } if bytes . Compare ( bb . buf [ ( bb . used - bbsrc . used ) - 1 ] . key , bbsrc . buf [ 0 ] . key ) < 0 { return } sort . Stable ( bb ) widx := 0 for ridx := 1 ; ridx < bb . used ; ridx ++ { if ! bytes . Equal ( bb . buf [ ridx ] . key , bb . buf [ widx ] . key ) { widx ++ } bb . buf [ widx ] = bb . buf [ ridx ] } bb . used = widx + 1 }
519	func deleteRevKey ( kv v3 . KV , key string , rev int64 ) ( bool , error ) { cmp := v3 . Compare ( v3 . ModRevision ( key ) , "=" , rev ) req := v3 . OpDelete ( key ) txnresp , err := kv . Txn ( context . TODO ( ) ) . If ( cmp ) . Then ( req ) . Commit ( ) if err != nil { return false , err } else if ! txnresp . Succeeded { return false , nil } return true , nil }
520	func isMemberBootstrapped ( lg * zap . Logger , cl * membership . RaftCluster , member string , rt http . RoundTripper , timeout time . Duration ) bool { rcl , err := getClusterFromRemotePeers ( lg , getRemotePeerURLs ( cl , member ) , timeout , false , rt ) if err != nil { return false } id := cl . MemberByName ( member ) . ID m := rcl . Member ( id ) if m == nil { return false } if len ( m . ClientURLs ) > 0 { return true } return false }
521	func GetClusterFromRemotePeers ( lg * zap . Logger , urls [ ] string , rt http . RoundTripper ) ( * membership . RaftCluster , error ) { return getClusterFromRemotePeers ( lg , urls , 10 * time . Second , true , rt ) }
522	func getClusterFromRemotePeers ( lg * zap . Logger , urls [ ] string , timeout time . Duration , logerr bool , rt http . RoundTripper ) ( * membership . RaftCluster , error ) { cc := & http . Client { Transport : rt , Timeout : timeout , } for _ , u := range urls { addr := u + "/members" resp , err := cc . Get ( addr ) if err != nil { if logerr { if lg != nil { lg . Warn ( "failed to get cluster response" , zap . String ( "address" , addr ) , zap . Error ( err ) ) } else { plog . Warningf ( "could not get cluster response from %s: %v" , u , err ) } } continue } b , err := ioutil . ReadAll ( resp . Body ) resp . Body . Close ( ) if err != nil { if logerr { if lg != nil { lg . Warn ( "failed to read body of cluster response" , zap . String ( "address" , addr ) , zap . Error ( err ) ) } else { plog . Warningf ( "could not read the body of cluster response: %v" , err ) } } continue } var membs [ ] * membership . Member if err = json . Unmarshal ( b , & membs ) ; err != nil { if logerr { if lg != nil { lg . Warn ( "failed to unmarshal cluster response" , zap . String ( "address" , addr ) , zap . Error ( err ) ) } else { plog . Warningf ( "could not unmarshal cluster response: %v" , err ) } } continue } id , err := types . IDFromString ( resp . Header . Get ( "X-Etcd-Cluster-ID" ) ) if err != nil { if logerr { if lg != nil { lg . Warn ( "failed to parse cluster ID" , zap . String ( "address" , addr ) , zap . String ( "header" , resp . Header . Get ( "X-Etcd-Cluster-ID" ) ) , zap . Error ( err ) , ) } else { plog . Warningf ( "could not parse the cluster ID from cluster res: %v" , err ) } } continue } if len ( membs ) > 0 { return membership . NewClusterFromMembers ( lg , "" , id , membs ) , nil } return nil , fmt . Errorf ( "failed to get raft cluster member(s) from the given URLs" ) } return nil , fmt . Errorf ( "could not retrieve cluster information from the given URLs" ) }
523	func getRemotePeerURLs ( cl * membership . RaftCluster , local string ) [ ] string { us := make ( [ ] string , 0 ) for _ , m := range cl . Members ( ) { if m . Name == local { continue } us = append ( us , m . PeerURLs ... ) } sort . Strings ( us ) return us }
524	func getVersions ( lg * zap . Logger , cl * membership . RaftCluster , local types . ID , rt http . RoundTripper ) map [ string ] * version . Versions { members := cl . Members ( ) vers := make ( map [ string ] * version . Versions ) for _ , m := range members { if m . ID == local { cv := "not_decided" if cl . Version ( ) != nil { cv = cl . Version ( ) . String ( ) } vers [ m . ID . String ( ) ] = & version . Versions { Server : version . Version , Cluster : cv } continue } ver , err := getVersion ( lg , m , rt ) if err != nil { if lg != nil { lg . Warn ( "failed to get version" , zap . String ( "remote-member-id" , m . ID . String ( ) ) , zap . Error ( err ) ) } else { plog . Warningf ( "cannot get the version of member %s (%v)" , m . ID , err ) } vers [ m . ID . String ( ) ] = nil } else { vers [ m . ID . String ( ) ] = ver } } return vers }
525	func decideClusterVersion ( lg * zap . Logger , vers map [ string ] * version . Versions ) * semver . Version { var cv * semver . Version lv := semver . Must ( semver . NewVersion ( version . Version ) ) for mid , ver := range vers { if ver == nil { return nil } v , err := semver . NewVersion ( ver . Server ) if err != nil { if lg != nil { lg . Warn ( "failed to parse server version of remote member" , zap . String ( "remote-member-id" , mid ) , zap . String ( "remote-member-version" , ver . Server ) , zap . Error ( err ) , ) } else { plog . Errorf ( "cannot understand the version of member %s (%v)" , mid , err ) } return nil } if lv . LessThan ( * v ) { if lg != nil { lg . Warn ( "leader found higher-versioned member" , zap . String ( "local-member-version" , lv . String ( ) ) , zap . String ( "remote-member-id" , mid ) , zap . String ( "remote-member-version" , ver . Server ) , ) } else { plog . Warningf ( "the local etcd version %s is not up-to-date" , lv . String ( ) ) plog . Warningf ( "member %s has a higher version %s" , mid , ver . Server ) } } if cv == nil { cv = v } else if v . LessThan ( * cv ) { cv = v } } return cv }
526	func getVersion ( lg * zap . Logger , m * membership . Member , rt http . RoundTripper ) ( * version . Versions , error ) { cc := & http . Client { Transport : rt , } var ( err error resp * http . Response ) for _ , u := range m . PeerURLs { addr := u + "/version" resp , err = cc . Get ( addr ) if err != nil { if lg != nil { lg . Warn ( "failed to reach the peer URL" , zap . String ( "address" , addr ) , zap . String ( "remote-member-id" , m . ID . String ( ) ) , zap . Error ( err ) , ) } else { plog . Warningf ( "failed to reach the peerURL(%s) of member %s (%v)" , u , m . ID , err ) } continue } var b [ ] byte b , err = ioutil . ReadAll ( resp . Body ) resp . Body . Close ( ) if err != nil { if lg != nil { lg . Warn ( "failed to read body of response" , zap . String ( "address" , addr ) , zap . String ( "remote-member-id" , m . ID . String ( ) ) , zap . Error ( err ) , ) } else { plog . Warningf ( "failed to read out the response body from the peerURL(%s) of member %s (%v)" , u , m . ID , err ) } continue } var vers version . Versions if err = json . Unmarshal ( b , & vers ) ; err != nil { if lg != nil { lg . Warn ( "failed to unmarshal response" , zap . String ( "address" , addr ) , zap . String ( "remote-member-id" , m . ID . String ( ) ) , zap . Error ( err ) , ) } else { plog . Warningf ( "failed to unmarshal the response body got from the peerURL(%s) of member %s (%v)" , u , m . ID , err ) } continue } return & vers , nil } return nil , err }
527	func NewTimeoutDetector ( maxDuration time . Duration ) * TimeoutDetector { return & TimeoutDetector { maxDuration : maxDuration , records : make ( map [ uint64 ] time . Time ) , } }
528	func ( td * TimeoutDetector ) Reset ( ) { td . mu . Lock ( ) defer td . mu . Unlock ( ) td . records = make ( map [ uint64 ] time . Time ) }
529	func ( td * TimeoutDetector ) Observe ( which uint64 ) ( bool , time . Duration ) { td . mu . Lock ( ) defer td . mu . Unlock ( ) ok := true now := time . Now ( ) exceed := time . Duration ( 0 ) if pt , found := td . records [ which ] ; found { exceed = now . Sub ( pt ) - td . maxDuration if exceed > 0 { ok = false } } td . records [ which ] = now return ok , exceed }
530	func NewPeerHandler ( lg * zap . Logger , s etcdserver . ServerPeer ) http . Handler { return newPeerHandler ( lg , s . Cluster ( ) , s . RaftHandler ( ) , s . LeaseHandler ( ) ) }
531	func ( ki * keyIndex ) put ( lg * zap . Logger , main int64 , sub int64 ) { rev := revision { main : main , sub : sub } if ! rev . GreaterThan ( ki . modified ) { if lg != nil { lg . Panic ( "'put' with an unexpected smaller revision" , zap . Int64 ( "given-revision-main" , rev . main ) , zap . Int64 ( "given-revision-sub" , rev . sub ) , zap . Int64 ( "modified-revision-main" , ki . modified . main ) , zap . Int64 ( "modified-revision-sub" , ki . modified . sub ) , ) } else { plog . Panicf ( "store.keyindex: put with unexpected smaller revision [%v / %v]" , rev , ki . modified ) } } if len ( ki . generations ) == 0 { ki . generations = append ( ki . generations , generation { } ) } g := & ki . generations [ len ( ki . generations ) - 1 ] if len ( g . revs ) == 0 { keysGauge . Inc ( ) g . created = rev } g . revs = append ( g . revs , rev ) g . ver ++ ki . modified = rev }
532	func ( ki * keyIndex ) tombstone ( lg * zap . Logger , main int64 , sub int64 ) error { if ki . isEmpty ( ) { if lg != nil { lg . Panic ( "'tombstone' got an unexpected empty keyIndex" , zap . String ( "key" , string ( ki . key ) ) , ) } else { plog . Panicf ( "store.keyindex: unexpected tombstone on empty keyIndex %s" , string ( ki . key ) ) } } if ki . generations [ len ( ki . generations ) - 1 ] . isEmpty ( ) { return ErrRevisionNotFound } ki . put ( lg , main , sub ) ki . generations = append ( ki . generations , generation { } ) keysGauge . Dec ( ) return nil }
533	func ( ki * keyIndex ) get ( lg * zap . Logger , atRev int64 ) ( modified , created revision , ver int64 , err error ) { if ki . isEmpty ( ) { if lg != nil { lg . Panic ( "'get' got an unexpected empty keyIndex" , zap . String ( "key" , string ( ki . key ) ) , ) } else { plog . Panicf ( "store.keyindex: unexpected get on empty keyIndex %s" , string ( ki . key ) ) } } g := ki . findGeneration ( atRev ) if g . isEmpty ( ) { return revision { } , revision { } , 0 , ErrRevisionNotFound } n := g . walk ( func ( rev revision ) bool { return rev . main > atRev } ) if n != - 1 { return g . revs [ n ] , g . created , g . ver - int64 ( len ( g . revs ) - n - 1 ) , nil } return revision { } , revision { } , 0 , ErrRevisionNotFound }
534	func ( ki * keyIndex ) since ( lg * zap . Logger , rev int64 ) [ ] revision { if ki . isEmpty ( ) { if lg != nil { lg . Panic ( "'since' got an unexpected empty keyIndex" , zap . String ( "key" , string ( ki . key ) ) , ) } else { plog . Panicf ( "store.keyindex: unexpected get on empty keyIndex %s" , string ( ki . key ) ) } } since := revision { rev , 0 } var gi int for gi = len ( ki . generations ) - 1 ; gi > 0 ; gi -- { g := ki . generations [ gi ] if g . isEmpty ( ) { continue } if since . GreaterThan ( g . created ) { break } } var revs [ ] revision var last int64 for ; gi < len ( ki . generations ) ; gi ++ { for _ , r := range ki . generations [ gi ] . revs { if since . GreaterThan ( r ) { continue } if r . main == last { revs [ len ( revs ) - 1 ] = r continue } revs = append ( revs , r ) last = r . main } } return revs }
535	func ( ki * keyIndex ) keep ( atRev int64 , available map [ revision ] struct { } ) { if ki . isEmpty ( ) { return } genIdx , revIndex := ki . doCompact ( atRev , available ) g := & ki . generations [ genIdx ] if ! g . isEmpty ( ) { if revIndex == len ( g . revs ) - 1 && genIdx != len ( ki . generations ) - 1 { delete ( available , g . revs [ revIndex ] ) } } }
536	func ( ki * keyIndex ) findGeneration ( rev int64 ) * generation { lastg := len ( ki . generations ) - 1 cg := lastg for cg >= 0 { if len ( ki . generations [ cg ] . revs ) == 0 { cg -- continue } g := ki . generations [ cg ] if cg != lastg { if tomb := g . revs [ len ( g . revs ) - 1 ] . main ; tomb <= rev { return nil } } if g . revs [ 0 ] . main <= rev { return & ki . generations [ cg ] } cg -- } return nil }
537	func ( s * watchableStore ) cancelWatcher ( wa * watcher ) { for { s . mu . Lock ( ) if s . unsynced . delete ( wa ) { slowWatcherGauge . Dec ( ) break } else if s . synced . delete ( wa ) { break } else if wa . compacted { break } else if wa . ch == nil { break } if ! wa . victim { panic ( "watcher not victim but not in watch groups" ) } var victimBatch watcherBatch for _ , wb := range s . victims { if wb [ wa ] != nil { victimBatch = wb break } } if victimBatch != nil { slowWatcherGauge . Dec ( ) delete ( victimBatch , wa ) break } s . mu . Unlock ( ) time . Sleep ( time . Millisecond ) } watcherGauge . Dec ( ) wa . ch = nil s . mu . Unlock ( ) }
538	func ( s * watchableStore ) syncWatchersLoop ( ) { defer s . wg . Done ( ) for { s . mu . RLock ( ) st := time . Now ( ) lastUnsyncedWatchers := s . unsynced . size ( ) s . mu . RUnlock ( ) unsyncedWatchers := 0 if lastUnsyncedWatchers > 0 { unsyncedWatchers = s . syncWatchers ( ) } syncDuration := time . Since ( st ) waitDuration := 100 * time . Millisecond if unsyncedWatchers != 0 && lastUnsyncedWatchers > unsyncedWatchers { waitDuration = syncDuration } select { case <- time . After ( waitDuration ) : case <- s . stopc : return } } }
539	func ( s * watchableStore ) syncVictimsLoop ( ) { defer s . wg . Done ( ) for { for s . moveVictims ( ) != 0 { } s . mu . RLock ( ) isEmpty := len ( s . victims ) == 0 s . mu . RUnlock ( ) var tickc <- chan time . Time if ! isEmpty { tickc = time . After ( 10 * time . Millisecond ) } select { case <- tickc : case <- s . victimc : case <- s . stopc : return } } }
540	func ( s * watchableStore ) moveVictims ( ) ( moved int ) { s . mu . Lock ( ) victims := s . victims s . victims = nil s . mu . Unlock ( ) var newVictim watcherBatch for _ , wb := range victims { for w , eb := range wb { rev := w . minRev - 1 if w . send ( WatchResponse { WatchID : w . id , Events : eb . evs , Revision : rev } ) { pendingEventsGauge . Add ( float64 ( len ( eb . evs ) ) ) } else { if newVictim == nil { newVictim = make ( watcherBatch ) } newVictim [ w ] = eb continue } moved ++ } s . mu . Lock ( ) s . store . revMu . RLock ( ) curRev := s . store . currentRev for w , eb := range wb { if newVictim != nil && newVictim [ w ] != nil { continue } w . victim = false if eb . moreRev != 0 { w . minRev = eb . moreRev } if w . minRev <= curRev { s . unsynced . add ( w ) } else { slowWatcherGauge . Dec ( ) s . synced . add ( w ) } } s . store . revMu . RUnlock ( ) s . mu . Unlock ( ) } if len ( newVictim ) > 0 { s . mu . Lock ( ) s . victims = append ( s . victims , newVictim ) s . mu . Unlock ( ) } return moved }
541	func kvsToEvents ( lg * zap . Logger , wg * watcherGroup , revs , vals [ ] [ ] byte ) ( evs [ ] mvccpb . Event ) { for i , v := range vals { var kv mvccpb . KeyValue if err := kv . Unmarshal ( v ) ; err != nil { if lg != nil { lg . Panic ( "failed to unmarshal mvccpb.KeyValue" , zap . Error ( err ) ) } else { plog . Panicf ( "cannot unmarshal event: %v" , err ) } } if ! wg . contains ( string ( kv . Key ) ) { continue } ty := mvccpb . PUT if isTombstone ( revs [ i ] ) { ty = mvccpb . DELETE kv . ModRevision = bytesToRev ( revs [ i ] ) . main } evs = append ( evs , mvccpb . Event { Kv : & kv , Type : ty } ) } return evs }
542	func ( s * watchableStore ) notify ( rev int64 , evs [ ] mvccpb . Event ) { var victim watcherBatch for w , eb := range newWatcherBatch ( & s . synced , evs ) { if eb . revs != 1 { if s . store != nil && s . store . lg != nil { s . store . lg . Panic ( "unexpected multiple revisions in watch notification" , zap . Int ( "number-of-revisions" , eb . revs ) , ) } else { plog . Panicf ( "unexpected multiple revisions in notification" ) } } if w . send ( WatchResponse { WatchID : w . id , Events : eb . evs , Revision : rev } ) { pendingEventsGauge . Add ( float64 ( len ( eb . evs ) ) ) } else { w . minRev = rev + 1 if victim == nil { victim = make ( watcherBatch ) } w . victim = true victim [ w ] = eb s . synced . delete ( w ) slowWatcherGauge . Inc ( ) } } s . addVictim ( victim ) }
543	func isOpFuncCalled ( op string , opts [ ] OpOption ) bool { for _ , opt := range opts { v := reflect . ValueOf ( opt ) if v . Kind ( ) == reflect . Func { if opFunc := runtime . FuncForPC ( v . Pointer ( ) ) ; opFunc != nil { if strings . Contains ( opFunc . Name ( ) , op ) { return true } } } } return false }
544	func ( t * batchTx ) UnsafePut ( bucketName [ ] byte , key [ ] byte , value [ ] byte ) { t . unsafePut ( bucketName , key , value , false ) }
545	func ( t * batchTx ) UnsafeSeqPut ( bucketName [ ] byte , key [ ] byte , value [ ] byte ) { t . unsafePut ( bucketName , key , value , true ) }
546	func ( t * batchTx ) UnsafeRange ( bucketName , key , endKey [ ] byte , limit int64 ) ( [ ] [ ] byte , [ ] [ ] byte ) { bucket := t . tx . Bucket ( bucketName ) if bucket == nil { if t . backend . lg != nil { t . backend . lg . Fatal ( "failed to find a bucket" , zap . String ( "bucket-name" , string ( bucketName ) ) , ) } else { plog . Fatalf ( "bucket %s does not exist" , bucketName ) } } return unsafeRange ( bucket . Cursor ( ) , key , endKey , limit ) }
547	func ( t * batchTx ) UnsafeDelete ( bucketName [ ] byte , key [ ] byte ) { bucket := t . tx . Bucket ( bucketName ) if bucket == nil { if t . backend . lg != nil { t . backend . lg . Fatal ( "failed to find a bucket" , zap . String ( "bucket-name" , string ( bucketName ) ) , ) } else { plog . Fatalf ( "bucket %s does not exist" , bucketName ) } } err := bucket . Delete ( key ) if err != nil { if t . backend . lg != nil { t . backend . lg . Fatal ( "failed to delete a key" , zap . String ( "bucket-name" , string ( bucketName ) ) , zap . Error ( err ) , ) } else { plog . Fatalf ( "cannot delete key from bucket (%v)" , err ) } } t . pending ++ }
548	func ( t * batchTx ) UnsafeForEach ( bucketName [ ] byte , visitor func ( k , v [ ] byte ) error ) error { return unsafeForEach ( t . tx , bucketName , visitor ) }
549	func ( t * batchTx ) Commit ( ) { t . Lock ( ) t . commit ( false ) t . Unlock ( ) }
550	func ( t * batchTx ) CommitAndStop ( ) { t . Lock ( ) t . commit ( true ) t . Unlock ( ) }
551	func ( le * lessor ) Renew ( id LeaseID ) ( int64 , error ) { le . mu . RLock ( ) if ! le . isPrimary ( ) { le . mu . RUnlock ( ) return - 1 , ErrNotPrimary } demotec := le . demotec l := le . leaseMap [ id ] if l == nil { le . mu . RUnlock ( ) return - 1 , ErrLeaseNotFound } clearRemainingTTL := le . cp != nil && l . remainingTTL > 0 le . mu . RUnlock ( ) if l . expired ( ) { select { case <- l . revokec : return - 1 , ErrLeaseNotFound case <- demotec : return - 1 , ErrNotPrimary case <- le . stopC : return - 1 , ErrNotPrimary } } if clearRemainingTTL { le . cp ( context . Background ( ) , & pb . LeaseCheckpointRequest { Checkpoints : [ ] * pb . LeaseCheckpoint { { ID : int64 ( l . ID ) , Remaining_TTL : 0 } } } ) } le . mu . Lock ( ) l . refresh ( 0 ) item := & LeaseWithTime { id : l . ID , time : l . expiry . UnixNano ( ) } heap . Push ( & le . leaseHeap , item ) le . mu . Unlock ( ) leaseRenewed . Inc ( ) return l . ttl , nil }
552	func ( le * lessor ) Attach ( id LeaseID , items [ ] LeaseItem ) error { le . mu . Lock ( ) defer le . mu . Unlock ( ) l := le . leaseMap [ id ] if l == nil { return ErrLeaseNotFound } l . mu . Lock ( ) for _ , it := range items { l . itemSet [ it ] = struct { } { } le . itemMap [ it ] = id } l . mu . Unlock ( ) return nil }
553	func ( le * lessor ) revokeExpiredLeases ( ) { var ls [ ] * Lease revokeLimit := leaseRevokeRate / 2 le . mu . RLock ( ) if le . isPrimary ( ) { ls = le . findExpiredLeases ( revokeLimit ) } le . mu . RUnlock ( ) if len ( ls ) != 0 { select { case <- le . stopC : return case le . expiredC <- ls : default : } } }
554	func ( le * lessor ) checkpointScheduledLeases ( ) { var cps [ ] * pb . LeaseCheckpoint for i := 0 ; i < leaseCheckpointRate / 2 ; i ++ { le . mu . Lock ( ) if le . isPrimary ( ) { cps = le . findDueScheduledCheckpoints ( maxLeaseCheckpointBatchSize ) } le . mu . Unlock ( ) if len ( cps ) != 0 { le . cp ( context . Background ( ) , & pb . LeaseCheckpointRequest { Checkpoints : cps } ) } if len ( cps ) < maxLeaseCheckpointBatchSize { return } } }
555	func ( le * lessor ) expireExists ( ) ( l * Lease , ok bool , next bool ) { if le . leaseHeap . Len ( ) == 0 { return nil , false , false } item := le . leaseHeap [ 0 ] l = le . leaseMap [ item . id ] if l == nil { heap . Pop ( & le . leaseHeap ) return nil , false , true } if time . Now ( ) . UnixNano ( ) < item . time { return l , false , false } heap . Pop ( & le . leaseHeap ) return l , true , false }
556	func ( le * lessor ) findExpiredLeases ( limit int ) [ ] * Lease { leases := make ( [ ] * Lease , 0 , 16 ) for { l , ok , next := le . expireExists ( ) if ! ok && ! next { break } if ! ok { continue } if next { continue } if l . expired ( ) { leases = append ( leases , l ) if len ( leases ) == limit { break } } } return leases }
557	func ( l * Lease ) refresh ( extend time . Duration ) { newExpiry := time . Now ( ) . Add ( extend + time . Duration ( l . RemainingTTL ( ) ) * time . Second ) l . expiryMu . Lock ( ) defer l . expiryMu . Unlock ( ) l . expiry = newExpiry }
558	func ( l * Lease ) forever ( ) { l . expiryMu . Lock ( ) defer l . expiryMu . Unlock ( ) l . expiry = forever }
559	func ( l * Lease ) Keys ( ) [ ] string { l . mu . RLock ( ) keys := make ( [ ] string , 0 , len ( l . itemSet ) ) for k := range l . itemSet { keys = append ( keys , k . Key ) } l . mu . RUnlock ( ) return keys }
560	func ( l * Lease ) Remaining ( ) time . Duration { l . expiryMu . RLock ( ) defer l . expiryMu . RUnlock ( ) if l . expiry . IsZero ( ) { return time . Duration ( math . MaxInt64 ) } return time . Until ( l . expiry ) }
561	func NewCompactionCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "compaction [options] <revision>" , Short : "Compacts the event history in etcd" , Run : compactionCommandFunc , } cmd . Flags ( ) . BoolVar ( & compactPhysical , "physical" , false , "'true' to wait for compaction to physically remove all old revisions" ) return cmd }
562	func compactionCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 1 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "compaction command needs 1 argument" ) ) } rev , err := strconv . ParseInt ( args [ 0 ] , 10 , 64 ) if err != nil { ExitWithError ( ExitError , err ) } var opts [ ] clientv3 . CompactOption if compactPhysical { opts = append ( opts , clientv3 . WithCompactPhysical ( ) ) } c := mustClientFromCmd ( cmd ) ctx , cancel := commandCtx ( cmd ) _ , cerr := c . Compact ( ctx , rev , opts ... ) cancel ( ) if cerr != nil { ExitWithError ( ExitError , cerr ) } fmt . Println ( "compacted revision" , rev ) }
563	func NewPutCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "put [options] <key> <value> (<value> can also be given from stdin)" , Short : "Puts the given key into the store" , Long : `Puts the given key into the store.When <value> begins with '-', <value> is interpreted as a flag.Insert '--' for workaround:$ put <key> -- <value>$ put -- <key> <value>If <value> isn't given as a command line argument and '--ignore-value' is not specified,this command tries to read the value from standard input.If <lease> isn't given as a command line argument and '--ignore-lease' is not specified,this command tries to read the value from standard input.For example,$ cat file | put <key>will store the content of the file to <key>.` , Run : putCommandFunc , } cmd . Flags ( ) . StringVar ( & leaseStr , "lease" , "0" , "lease ID (in hexadecimal) to attach to the key" ) cmd . Flags ( ) . BoolVar ( & putPrevKV , "prev-kv" , false , "return the previous key-value pair before modification" ) cmd . Flags ( ) . BoolVar ( & putIgnoreVal , "ignore-value" , false , "updates the key using its current value" ) cmd . Flags ( ) . BoolVar ( & putIgnoreLease , "ignore-lease" , false , "updates the key using its current lease" ) return cmd }
564	func putCommandFunc ( cmd * cobra . Command , args [ ] string ) { key , value , opts := getPutOp ( args ) ctx , cancel := commandCtx ( cmd ) resp , err := mustClientFromCmd ( cmd ) . Put ( ctx , key , value , opts ... ) cancel ( ) if err != nil { ExitWithError ( ExitError , err ) } display . Put ( * resp ) }
565	func NewHandler ( t * http . Transport , urlsFunc GetProxyURLs , failureWait time . Duration , refreshInterval time . Duration ) http . Handler { if t . TLSClientConfig != nil { err := http2 . ConfigureTransport ( t ) if err != nil { plog . Infof ( "Error enabling Transport HTTP/2 support: %v" , err ) } } p := & reverseProxy { director : newDirector ( urlsFunc , failureWait , refreshInterval ) , transport : t , } mux := http . NewServeMux ( ) mux . Handle ( "/" , p ) mux . HandleFunc ( "/v2/config/local/proxy" , p . configHandler ) return mux }
566	func NewReadonlyHandler ( hdlr http . Handler ) http . Handler { readonly := readonlyHandlerFunc ( hdlr ) return http . HandlerFunc ( readonly ) }
567	func NewSetCommand ( ) cli . Command { return cli . Command { Name : "set" , Usage : "set the value of a key" , ArgsUsage : "<key> <value>" , Description : `Set sets the value of a key. When <value> begins with '-', <value> is interpreted as a flag. Insert '--' for workaround: $ set -- <key> <value>` , Flags : [ ] cli . Flag { cli . IntFlag { Name : "ttl" , Value : 0 , Usage : "key time-to-live in seconds" } , cli . StringFlag { Name : "swap-with-value" , Value : "" , Usage : "previous value" } , cli . IntFlag { Name : "swap-with-index" , Value : 0 , Usage : "previous index" } , } , Action : func ( c * cli . Context ) error { setCommandFunc ( c , mustNewKeyAPI ( c ) ) return nil } , } }
568	func setCommandFunc ( c * cli . Context , ki client . KeysAPI ) { if len ( c . Args ( ) ) == 0 { handleError ( c , ExitBadArgs , errors . New ( "key required" ) ) } key := c . Args ( ) [ 0 ] value , err := argOrStdin ( c . Args ( ) , os . Stdin , 1 ) if err != nil { handleError ( c , ExitBadArgs , errors . New ( "value required" ) ) } ttl := c . Int ( "ttl" ) prevValue := c . String ( "swap-with-value" ) prevIndex := c . Int ( "swap-with-index" ) ctx , cancel := contextWithTotalTimeout ( c ) resp , err := ki . Set ( ctx , key , value , & client . SetOptions { TTL : time . Duration ( ttl ) * time . Second , PrevIndex : uint64 ( prevIndex ) , PrevValue : prevValue } ) cancel ( ) if err != nil { handleError ( c , ExitServerError , err ) } printResponseKey ( resp , c . GlobalString ( "output" ) ) }
569	func ( rwm * RWMutex ) waitOnLastRev ( pfx string ) ( bool , error ) { client := rwm . s . Client ( ) opts := append ( v3 . WithLastRev ( ) , v3 . WithMaxModRev ( rwm . myKey . Revision ( ) - 1 ) ) lastKey , err := client . Get ( rwm . ctx , pfx , opts ... ) if err != nil { return false , err } if len ( lastKey . Kvs ) == 0 { return true , nil } _ , err = WaitEvents ( client , string ( lastKey . Kvs [ 0 ] . Key ) , rwm . myKey . Revision ( ) , [ ] mvccpb . Event_EventType { mvccpb . DELETE } ) return false , err }
570	func GetDefaultInterfaces ( ) ( map [ string ] uint8 , error ) { return nil , fmt . Errorf ( "default host not supported on %s_%s" , runtime . GOOS , runtime . GOARCH ) }
571	func NewSnapshotCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "snapshot <subcommand>" , Short : "Manages etcd node snapshots" , } cmd . AddCommand ( NewSnapshotSaveCommand ( ) ) cmd . AddCommand ( NewSnapshotRestoreCommand ( ) ) cmd . AddCommand ( newSnapshotStatusCommand ( ) ) return cmd }
572	func NewMoveLeaderCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "move-leader <transferee-member-id>" , Short : "Transfers leadership to another etcd cluster member." , Run : transferLeadershipCommandFunc , } return cmd }
573	func transferLeadershipCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 1 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "move-leader command needs 1 argument" ) ) } target , err := strconv . ParseUint ( args [ 0 ] , 16 , 64 ) if err != nil { ExitWithError ( ExitBadArgs , err ) } c := mustClientFromCmd ( cmd ) eps := c . Endpoints ( ) c . Close ( ) ctx , cancel := commandCtx ( cmd ) var leaderCli * clientv3 . Client var leaderID uint64 for _ , ep := range eps { cfg := clientConfigFromCmd ( cmd ) cfg . endpoints = [ ] string { ep } cli := cfg . mustClient ( ) resp , serr := cli . Status ( ctx , ep ) if serr != nil { ExitWithError ( ExitError , serr ) } if resp . Header . GetMemberId ( ) == resp . Leader { leaderCli = cli leaderID = resp . Leader break } cli . Close ( ) } if leaderCli == nil { ExitWithError ( ExitBadArgs , fmt . Errorf ( "no leader endpoint given at %v" , eps ) ) } var resp * clientv3 . MoveLeaderResponse resp , err = leaderCli . MoveLeader ( ctx , target ) cancel ( ) if err != nil { ExitWithError ( ExitError , err ) } display . MoveLeader ( leaderID , target , * resp ) }
574	func OpenDir ( path string ) ( * os . File , error ) { fd , err := openDir ( path ) if err != nil { return nil , err } return os . NewFile ( uintptr ( fd ) , path ) , nil }
575	func NewRemoveDirCommand ( ) cli . Command { return cli . Command { Name : "rmdir" , Usage : "removes the key if it is an empty directory or a key-value pair" , ArgsUsage : "<key>" , Action : func ( c * cli . Context ) error { rmdirCommandFunc ( c , mustNewKeyAPI ( c ) ) return nil } , } }
576	func rmdirCommandFunc ( c * cli . Context , ki client . KeysAPI ) { if len ( c . Args ( ) ) == 0 { handleError ( c , ExitBadArgs , errors . New ( "key required" ) ) } key := c . Args ( ) [ 0 ] ctx , cancel := contextWithTotalTimeout ( c ) resp , err := ki . Delete ( ctx , key , & client . DeleteOptions { Dir : true } ) cancel ( ) if err != nil { handleError ( c , ExitServerError , err ) } if ! resp . Node . Dir || c . GlobalString ( "output" ) != "simple" { printResponseKey ( resp , c . GlobalString ( "output" ) ) } }
577	func NewDelCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "del [options] <key> [range_end]" , Short : "Removes the specified key or range of keys [key, range_end)" , Run : delCommandFunc , } cmd . Flags ( ) . BoolVar ( & delPrefix , "prefix" , false , "delete keys with matching prefix" ) cmd . Flags ( ) . BoolVar ( & delPrevKV , "prev-kv" , false , "return deleted key-value pairs" ) cmd . Flags ( ) . BoolVar ( & delFromKey , "from-key" , false , "delete keys that are greater than or equal to the given key using byte compare" ) return cmd }
578	func delCommandFunc ( cmd * cobra . Command , args [ ] string ) { key , opts := getDelOp ( args ) ctx , cancel := commandCtx ( cmd ) resp , err := mustClientFromCmd ( cmd ) . Delete ( ctx , key , opts ... ) cancel ( ) if err != nil { ExitWithError ( ExitError , err ) } display . Del ( * resp ) }
579	func NewExpect ( name string , arg ... string ) ( ep * ExpectProcess , err error ) { return NewExpectWithEnv ( name , arg , nil ) }
580	func NewExpectWithEnv ( name string , args [ ] string , env [ ] string ) ( ep * ExpectProcess , err error ) { cmd := exec . Command ( name , args ... ) cmd . Env = env ep = & ExpectProcess { cmd : cmd , StopSignal : syscall . SIGKILL , } ep . cond = sync . NewCond ( & ep . mu ) ep . cmd . Stderr = ep . cmd . Stdout ep . cmd . Stdin = nil if ep . fpty , err = pty . Start ( ep . cmd ) ; err != nil { return nil , err } ep . wg . Add ( 1 ) go ep . read ( ) return ep , nil }
581	func ( ep * ExpectProcess ) ExpectFunc ( f func ( string ) bool ) ( string , error ) { ep . mu . Lock ( ) for { for len ( ep . lines ) == 0 && ep . err == nil { ep . cond . Wait ( ) } if len ( ep . lines ) == 0 { break } l := ep . lines [ 0 ] ep . lines = ep . lines [ 1 : ] if f ( l ) { ep . mu . Unlock ( ) return l , nil } } ep . mu . Unlock ( ) return "" , ep . err }
582	func ( ep * ExpectProcess ) Expect ( s string ) ( string , error ) { return ep . ExpectFunc ( func ( txt string ) bool { return strings . Contains ( txt , s ) } ) }
583	func ( ep * ExpectProcess ) LineCount ( ) int { ep . mu . Lock ( ) defer ep . mu . Unlock ( ) return ep . count }
584	func ( ep * ExpectProcess ) Signal ( sig os . Signal ) error { return ep . cmd . Process . Signal ( sig ) }
585	func keyFunc ( req * pb . RangeRequest ) string { b , err := req . Marshal ( ) if err != nil { panic ( err ) } return string ( b ) }
586	func ( c * cache ) Add ( req * pb . RangeRequest , resp * pb . RangeResponse ) { key := keyFunc ( req ) c . mu . Lock ( ) defer c . mu . Unlock ( ) if req . Revision > c . compactedRev { c . lru . Add ( key , resp ) } if req . Revision != 0 { return } var ( iv * adt . IntervalValue ivl adt . Interval ) if len ( req . RangeEnd ) != 0 { ivl = adt . NewStringAffineInterval ( string ( req . Key ) , string ( req . RangeEnd ) ) } else { ivl = adt . NewStringAffinePoint ( string ( req . Key ) ) } iv = c . cachedRanges . Find ( ivl ) if iv == nil { val := map [ string ] struct { } { key : { } } c . cachedRanges . Insert ( ivl , val ) } else { val := iv . Val . ( map [ string ] struct { } ) val [ key ] = struct { } { } iv . Val = val } }
587	func ( c * cache ) Get ( req * pb . RangeRequest ) ( * pb . RangeResponse , error ) { key := keyFunc ( req ) c . mu . Lock ( ) defer c . mu . Unlock ( ) if req . Revision > 0 && req . Revision < c . compactedRev { c . lru . Remove ( key ) return nil , ErrCompacted } if resp , ok := c . lru . Get ( key ) ; ok { return resp . ( * pb . RangeResponse ) , nil } return nil , errors . New ( "not exist" ) }
588	func ( c * cache ) Invalidate ( key , endkey [ ] byte ) { c . mu . Lock ( ) defer c . mu . Unlock ( ) var ( ivs [ ] * adt . IntervalValue ivl adt . Interval ) if len ( endkey ) == 0 { ivl = adt . NewStringAffinePoint ( string ( key ) ) } else { ivl = adt . NewStringAffineInterval ( string ( key ) , string ( endkey ) ) } ivs = c . cachedRanges . Stab ( ivl ) for _ , iv := range ivs { keys := iv . Val . ( map [ string ] struct { } ) for key := range keys { c . lru . Remove ( key ) } } c . cachedRanges . Delete ( ivl ) }
589	func ( c * cache ) Compact ( revision int64 ) { c . mu . Lock ( ) defer c . mu . Unlock ( ) if revision > c . compactedRev { c . compactedRev = revision } }
590	func NewUniqueURLsWithExceptions ( s string , exceptions ... string ) * UniqueURLs { us := & UniqueURLs { Values : make ( map [ string ] struct { } ) , Allowed : make ( map [ string ] struct { } ) } for _ , v := range exceptions { us . Allowed [ v ] = struct { } { } } if s == "" { return us } if err := us . Set ( s ) ; err != nil { plog . Panicf ( "new UniqueURLs should never fail: %v" , err ) } return us }
591	func UniqueURLsFromFlag ( fs * flag . FlagSet , urlsFlagName string ) [ ] url . URL { return ( * fs . Lookup ( urlsFlagName ) . Value . ( * UniqueURLs ) ) . uss }
592	func UniqueURLsMapFromFlag ( fs * flag . FlagSet , urlsFlagName string ) map [ string ] struct { } { return ( * fs . Lookup ( urlsFlagName ) . Value . ( * UniqueURLs ) ) . Values }
593	func ( b * Barrier ) Hold ( ) error { _ , err := newKey ( b . client , b . key , v3 . NoLease ) return err }
594	func ( b * Barrier ) Release ( ) error { _ , err := b . client . Delete ( b . ctx , b . key ) return err }
595	func ( b * Barrier ) Wait ( ) error { resp , err := b . client . Get ( b . ctx , b . key , v3 . WithFirstKey ( ) ... ) if err != nil { return err } if len ( resp . Kvs ) == 0 { return nil } _ , err = WaitEvents ( b . client , b . key , resp . Header . Revision , [ ] mvccpb . Event_EventType { mvccpb . PUT , mvccpb . DELETE } ) return err }
596	func NewLockRacerCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "lock-racer [name of lock (defaults to 'racers')]" , Short : "Performs lock race operation" , Run : runRacerFunc , } cmd . Flags ( ) . IntVar ( & totalClientConnections , "total-client-connections" , 10 , "total number of client connections" ) return cmd }
597	func ( m * Member ) ElectionTimeout ( ) time . Duration { return time . Duration ( m . Etcd . ElectionTimeoutMs ) * time . Millisecond }
598	func ( m * Member ) DialEtcdGRPCServer ( opts ... grpc . DialOption ) ( * grpc . ClientConn , error ) { dialOpts := [ ] grpc . DialOption { grpc . WithTimeout ( 5 * time . Second ) , grpc . WithBlock ( ) , } secure := false for _ , cu := range m . Etcd . AdvertiseClientURLs { u , err := url . Parse ( cu ) if err != nil { return nil , err } if u . Scheme == "https" { secure = true } } if secure { tlsInfo := transport . TLSInfo { CertFile : m . ClientCertPath , KeyFile : m . ClientKeyPath , TrustedCAFile : m . ClientTrustedCAPath , InsecureSkipVerify : true , } tlsConfig , err := tlsInfo . ClientConfig ( ) if err != nil { return nil , err } creds := credentials . NewTLS ( tlsConfig ) dialOpts = append ( dialOpts , grpc . WithTransportCredentials ( creds ) ) } else { dialOpts = append ( dialOpts , grpc . WithInsecure ( ) ) } dialOpts = append ( dialOpts , opts ... ) return grpc . Dial ( m . EtcdClientEndpoint , dialOpts ... ) }
599	func ( m * Member ) CreateEtcdClientConfig ( opts ... grpc . DialOption ) ( cfg * clientv3 . Config , err error ) { secure := false for _ , cu := range m . Etcd . AdvertiseClientURLs { var u * url . URL u , err = url . Parse ( cu ) if err != nil { return nil , err } if u . Scheme == "https" { secure = true } } cfg = & clientv3 . Config { Endpoints : [ ] string { m . EtcdClientEndpoint } , DialTimeout : 10 * time . Second , DialOptions : opts , } if secure { tlsInfo := transport . TLSInfo { CertFile : m . ClientCertPath , KeyFile : m . ClientKeyPath , TrustedCAFile : m . ClientTrustedCAPath , InsecureSkipVerify : true , } var tlsConfig * tls . Config tlsConfig , err = tlsInfo . ClientConfig ( ) if err != nil { return nil , err } cfg . TLS = tlsConfig } return cfg , err }
600	func ( m * Member ) CreateEtcdClient ( opts ... grpc . DialOption ) ( * clientv3 . Client , error ) { cfg , err := m . CreateEtcdClientConfig ( opts ... ) if err != nil { return nil , err } return clientv3 . New ( * cfg ) }
601	func ( m * Member ) CheckCompact ( rev int64 ) error { cli , err := m . CreateEtcdClient ( ) if err != nil { return fmt . Errorf ( "%v (%q)" , err , m . EtcdClientEndpoint ) } defer cli . Close ( ) ctx , cancel := context . WithTimeout ( context . Background ( ) , 5 * time . Second ) wch := cli . Watch ( ctx , "\x00" , \x00 , clientv3 . WithFromKey ( ) ) clientv3 . WithRev ( rev - 1 ) wr , ok := <- wch cancel ( ) if ! ok { return fmt . Errorf ( "watch channel terminated (endpoint %q)" , m . EtcdClientEndpoint ) } if wr . CompactRevision != rev { return fmt . Errorf ( "got compact revision %v, wanted %v (endpoint %q)" , wr . CompactRevision , rev , m . EtcdClientEndpoint ) } }
602	func ( m * Member ) Defrag ( ) error { cli , err := m . CreateEtcdClient ( ) if err != nil { return fmt . Errorf ( "%v (%q)" , err , m . EtcdClientEndpoint ) } defer cli . Close ( ) ctx , cancel := context . WithTimeout ( context . Background ( ) , 5 * time . Minute ) _ , err = cli . Defragment ( ctx , m . EtcdClientEndpoint ) cancel ( ) return err }
603	func ( m * Member ) RevHash ( ) ( int64 , int64 , error ) { conn , err := m . DialEtcdGRPCServer ( ) if err != nil { return 0 , 0 , err } defer conn . Close ( ) mt := pb . NewMaintenanceClient ( conn ) ctx , cancel := context . WithTimeout ( context . Background ( ) , 5 * time . Second ) resp , err := mt . Hash ( ctx , & pb . HashRequest { } , grpc . FailFast ( false ) ) cancel ( ) if err != nil { return 0 , 0 , err } return resp . Header . Revision , int64 ( resp . Hash ) , nil }
604	func ( m * Member ) Rev ( ctx context . Context ) ( int64 , error ) { cli , err := m . CreateEtcdClient ( ) if err != nil { return 0 , fmt . Errorf ( "%v (%q)" , err , m . EtcdClientEndpoint ) } defer cli . Close ( ) resp , err := cli . Status ( ctx , m . EtcdClientEndpoint ) if err != nil { return 0 , err } return resp . Header . Revision , nil }
605	func ( m * Member ) Compact ( rev int64 , timeout time . Duration ) error { cli , err := m . CreateEtcdClient ( ) if err != nil { return fmt . Errorf ( "%v (%q)" , err , m . EtcdClientEndpoint ) } defer cli . Close ( ) ctx , cancel := context . WithTimeout ( context . Background ( ) , timeout ) _ , err = cli . Compact ( ctx , rev , clientv3 . WithCompactPhysical ( ) ) cancel ( ) return err }
606	func ( m * Member ) IsLeader ( ) ( bool , error ) { cli , err := m . CreateEtcdClient ( ) if err != nil { return false , fmt . Errorf ( "%v (%q)" , err , m . EtcdClientEndpoint ) } defer cli . Close ( ) resp , err := cli . Status ( context . Background ( ) , m . EtcdClientEndpoint ) if err != nil { return false , err } return resp . Header . MemberId == resp . Leader , nil }
607	func ( m * Member ) WriteHealthKey ( ) error { cli , err := m . CreateEtcdClient ( ) if err != nil { return fmt . Errorf ( "%v (%q)" , err , m . EtcdClientEndpoint ) } defer cli . Close ( ) ctx , cancel := context . WithTimeout ( context . Background ( ) , 5 * time . Second ) _ , err = cli . Put ( ctx , "health" , "good" ) cancel ( ) if err != nil { return fmt . Errorf ( "%v (%q)" , err , m . EtcdClientEndpoint ) } return nil }
608	func ( m * Member ) SaveSnapshot ( lg * zap . Logger ) ( err error ) { if err = os . RemoveAll ( m . SnapshotPath ) ; err != nil { return err } var ccfg * clientv3 . Config ccfg , err = m . CreateEtcdClientConfig ( ) if err != nil { return fmt . Errorf ( "%v (%q)" , err , m . EtcdClientEndpoint ) } lg . Info ( "snapshot save START" , zap . String ( "member-name" , m . Etcd . Name ) , zap . Strings ( "member-client-urls" , m . Etcd . AdvertiseClientURLs ) , zap . String ( "snapshot-path" , m . SnapshotPath ) , ) now := time . Now ( ) mgr := snapshot . NewV3 ( lg ) if err = mgr . Save ( context . Background ( ) , * ccfg , m . SnapshotPath ) ; err != nil { return err } took := time . Since ( now ) var fi os . FileInfo fi , err = os . Stat ( m . SnapshotPath ) if err != nil { return err } var st snapshot . Status st , err = mgr . Status ( m . SnapshotPath ) if err != nil { return err } m . SnapshotInfo = & SnapshotInfo { MemberName : m . Etcd . Name , MemberClientURLs : m . Etcd . AdvertiseClientURLs , SnapshotPath : m . SnapshotPath , SnapshotFileSize : humanize . Bytes ( uint64 ( fi . Size ( ) ) ) , SnapshotTotalSize : humanize . Bytes ( uint64 ( st . TotalSize ) ) , SnapshotTotalKey : int64 ( st . TotalKey ) , SnapshotHash : int64 ( st . Hash ) , SnapshotRevision : st . Revision , Took : fmt . Sprintf ( "%v" , took ) , } lg . Info ( "snapshot save END" , zap . String ( "member-name" , m . SnapshotInfo . MemberName ) , zap . Strings ( "member-client-urls" , m . SnapshotInfo . MemberClientURLs ) , zap . String ( "snapshot-path" , m . SnapshotPath ) , zap . String ( "snapshot-file-size" , m . SnapshotInfo . SnapshotFileSize ) , zap . String ( "snapshot-total-size" , m . SnapshotInfo . SnapshotTotalSize ) , zap . Int64 ( "snapshot-total-key" , m . SnapshotInfo . SnapshotTotalKey ) , zap . Int64 ( "snapshot-hash" , m . SnapshotInfo . SnapshotHash ) , zap . Int64 ( "snapshot-revision" , m . SnapshotInfo . SnapshotRevision ) , zap . String ( "took" , m . SnapshotInfo . Took ) , ) return nil }
609	func ( m * Member ) RestoreSnapshot ( lg * zap . Logger ) ( err error ) { if err = os . RemoveAll ( m . EtcdOnSnapshotRestore . DataDir ) ; err != nil { return err } if err = os . RemoveAll ( m . EtcdOnSnapshotRestore . WALDir ) ; err != nil { return err } lg . Info ( "snapshot restore START" , zap . String ( "member-name" , m . Etcd . Name ) , zap . Strings ( "member-client-urls" , m . Etcd . AdvertiseClientURLs ) , zap . String ( "snapshot-path" , m . SnapshotPath ) , ) now := time . Now ( ) mgr := snapshot . NewV3 ( lg ) err = mgr . Restore ( snapshot . RestoreConfig { SnapshotPath : m . SnapshotInfo . SnapshotPath , Name : m . EtcdOnSnapshotRestore . Name , OutputDataDir : m . EtcdOnSnapshotRestore . DataDir , OutputWALDir : m . EtcdOnSnapshotRestore . WALDir , PeerURLs : m . EtcdOnSnapshotRestore . AdvertisePeerURLs , InitialCluster : m . EtcdOnSnapshotRestore . InitialCluster , InitialClusterToken : m . EtcdOnSnapshotRestore . InitialClusterToken , SkipHashCheck : false , } ) took := time . Since ( now ) lg . Info ( "snapshot restore END" , zap . String ( "member-name" , m . SnapshotInfo . MemberName ) , zap . Strings ( "member-client-urls" , m . SnapshotInfo . MemberClientURLs ) , zap . String ( "snapshot-path" , m . SnapshotPath ) , zap . String ( "snapshot-file-size" , m . SnapshotInfo . SnapshotFileSize ) , zap . String ( "snapshot-total-size" , m . SnapshotInfo . SnapshotTotalSize ) , zap . Int64 ( "snapshot-total-key" , m . SnapshotInfo . SnapshotTotalKey ) , zap . Int64 ( "snapshot-hash" , m . SnapshotInfo . SnapshotHash ) , zap . Int64 ( "snapshot-revision" , m . SnapshotInfo . SnapshotRevision ) , zap . String ( "took" , took . String ( ) ) , zap . Error ( err ) , ) return err }
610	func NewWatcher ( w clientv3 . Watcher , prefix string ) clientv3 . Watcher { return & watcherPrefix { Watcher : w , pfx : prefix , stopc : make ( chan struct { } ) } }
611	func NewRawNode ( config * Config , peers [ ] Peer ) ( * RawNode , error ) { if config . ID == 0 { panic ( "config.ID must not be zero" ) } r := newRaft ( config ) rn := & RawNode { raft : r , } lastIndex , err := config . Storage . LastIndex ( ) if err != nil { panic ( err ) } if lastIndex == 0 { r . becomeFollower ( 1 , None ) ents := make ( [ ] pb . Entry , len ( peers ) ) for i , peer := range peers { cc := pb . ConfChange { Type : pb . ConfChangeAddNode , NodeID : peer . ID , Context : peer . Context } data , err := cc . Marshal ( ) if err != nil { panic ( "unexpected marshal error" ) } ents [ i ] = pb . Entry { Type : pb . EntryConfChange , Term : 1 , Index : uint64 ( i + 1 ) , Data : data } } r . raftLog . append ( ents ... ) r . raftLog . committed = uint64 ( len ( ents ) ) for _ , peer := range peers { r . addNode ( peer . ID ) } } rn . prevSoftSt = r . softState ( ) if lastIndex == 0 { rn . prevHardSt = emptyState } else { rn . prevHardSt = r . hardState ( ) } return rn , nil }
612	func ( rn * RawNode ) Campaign ( ) error { return rn . raft . Step ( pb . Message { Type : pb . MsgHup , } ) }
613	func ( rn * RawNode ) Propose ( data [ ] byte ) error { return rn . raft . Step ( pb . Message { Type : pb . MsgProp , From : rn . raft . id , Entries : [ ] pb . Entry { { Data : data } , } } ) }
614	func ( rn * RawNode ) ProposeConfChange ( cc pb . ConfChange ) error { data , err := cc . Marshal ( ) if err != nil { return err } return rn . raft . Step ( pb . Message { Type : pb . MsgProp , Entries : [ ] pb . Entry { { Type : pb . EntryConfChange , Data : data } , } , } ) }
615	func ( rn * RawNode ) ApplyConfChange ( cc pb . ConfChange ) * pb . ConfState { if cc . NodeID == None { return & pb . ConfState { Nodes : rn . raft . nodes ( ) , Learners : rn . raft . learnerNodes ( ) } } switch cc . Type { case pb . ConfChangeAddNode : rn . raft . addNode ( cc . NodeID ) case pb . ConfChangeAddLearnerNode : rn . raft . addLearner ( cc . NodeID ) case pb . ConfChangeRemoveNode : rn . raft . removeNode ( cc . NodeID ) case pb . ConfChangeUpdateNode : default : panic ( "unexpected conf type" ) } return & pb . ConfState { Nodes : rn . raft . nodes ( ) , Learners : rn . raft . learnerNodes ( ) } }
616	func ( rn * RawNode ) Step ( m pb . Message ) error { if IsLocalMsg ( m . Type ) { return ErrStepLocalMsg } if pr := rn . raft . getProgress ( m . From ) ; pr != nil || ! IsResponseMsg ( m . Type ) { return rn . raft . Step ( m ) } return ErrStepPeerNotFound }
617	func ( rn * RawNode ) Ready ( ) Ready { rd := rn . newReady ( ) rn . raft . msgs = nil rn . raft . reduceUncommittedSize ( rd . CommittedEntries ) return rd }
618	func ( rn * RawNode ) WithProgress ( visitor func ( id uint64 , typ ProgressType , pr Progress ) ) { for id , pr := range rn . raft . prs { pr := * pr pr . ins = nil visitor ( id , ProgressTypePeer , pr ) } for id , pr := range rn . raft . learnerPrs { pr := * pr pr . ins = nil visitor ( id , ProgressTypeLearner , pr ) } }
619	func ( rn * RawNode ) ReportUnreachable ( id uint64 ) { _ = rn . raft . Step ( pb . Message { Type : pb . MsgUnreachable , From : id } ) }
620	func ( rn * RawNode ) ReportSnapshot ( id uint64 , status SnapshotStatus ) { rej := status == SnapshotFailure _ = rn . raft . Step ( pb . Message { Type : pb . MsgSnapStatus , From : id , Reject : rej } ) }
621	func ( rn * RawNode ) TransferLeader ( transferee uint64 ) { _ = rn . raft . Step ( pb . Message { Type : pb . MsgTransferLeader , From : transferee } ) }
622	func ( rn * RawNode ) ReadIndex ( rctx [ ] byte ) { _ = rn . raft . Step ( pb . Message { Type : pb . MsgReadIndex , Entries : [ ] pb . Entry { { Data : rctx } } } ) }
623	func printcURL ( req * http . Request ) error { if ! cURLDebug { return nil } var ( command string b [ ] byte err error ) if req . URL != nil { command = fmt . Sprintf ( "curl -X %s %s" , req . Method , req . URL . String ( ) ) } if req . Body != nil { b , err = ioutil . ReadAll ( req . Body ) if err != nil { return err } command += fmt . Sprintf ( " -d %q" , string ( b ) ) } fmt . Fprintf ( os . Stderr , "cURL Command: %s\n" , \n ) command body := bytes . NewBuffer ( b ) req . Body = ioutil . NopCloser ( body ) }
624	func StartNode ( c * Config , peers [ ] Peer ) Node { r := newRaft ( c ) r . becomeFollower ( 1 , None ) for _ , peer := range peers { cc := pb . ConfChange { Type : pb . ConfChangeAddNode , NodeID : peer . ID , Context : peer . Context } d , err := cc . Marshal ( ) if err != nil { panic ( "unexpected marshal error" ) } e := pb . Entry { Type : pb . EntryConfChange , Term : 1 , Index : r . raftLog . lastIndex ( ) + 1 , Data : d } r . raftLog . append ( e ) } r . raftLog . committed = r . raftLog . lastIndex ( ) for _ , peer := range peers { r . addNode ( peer . ID ) } n := newNode ( ) n . logger = c . Logger go n . run ( r ) return & n }
625	func RestartNode ( c * Config ) Node { r := newRaft ( c ) n := newNode ( ) n . logger = c . Logger go n . run ( r ) return & n }
626	func ( n * node ) Tick ( ) { select { case n . tickc <- struct { } { } : case <- n . done : default : n . logger . Warningf ( "A tick missed to fire. Node blocks too long!" ) } }
627	func MustSync ( st , prevst pb . HardState , entsnum int ) bool { return entsnum != 0 || st . Vote != prevst . Vote || st . Term != prevst . Term }
628	func NewGRPC17Health ( eps [ ] string , timeout time . Duration , dialFunc DialFunc , ) * GRPC17Health { notifyCh := make ( chan [ ] grpc . Address ) addrs := eps2addrs ( eps ) hb := & GRPC17Health { addrs : addrs , eps : eps , notifyCh : notifyCh , readyc : make ( chan struct { } ) , healthCheck : func ( ep string ) ( bool , error ) { return grpcHealthCheck ( ep , dialFunc ) } , unhealthyHostPorts : make ( map [ string ] time . Time ) , upc : make ( chan struct { } ) , stopc : make ( chan struct { } ) , downc : make ( chan struct { } ) , donec : make ( chan struct { } ) , updateAddrsC : make ( chan NotifyMsg ) , hostPort2ep : getHostPort2ep ( eps ) , } if timeout < minHealthRetryDuration { timeout = minHealthRetryDuration } hb . healthCheckTimeout = timeout close ( hb . downc ) go hb . updateNotifyLoop ( ) hb . wg . Add ( 1 ) go func ( ) { defer hb . wg . Done ( ) hb . updateUnhealthy ( ) } ( ) return hb }
629	func ( b * GRPC17Health ) NeedUpdate ( ) bool { b . mu . RLock ( ) update := ! hasAddr ( b . addrs , b . pinAddr ) b . mu . RUnlock ( ) return update }
630	func dflSignal ( sig syscall . Signal ) { var sigactBuf [ 32 ] uint64 ptr := unsafe . Pointer ( & sigactBuf ) syscall . Syscall6 ( uintptr ( syscall . SYS_RT_SIGACTION ) , uintptr ( sig ) , uintptr ( ptr ) , 0 , 8 , 0 , 0 ) }
631	func New ( namespaces ... string ) Store { s := newStore ( namespaces ... ) s . clock = clockwork . NewRealClock ( ) return s }
632	func ( s * store ) Index ( ) uint64 { s . worldLock . RLock ( ) defer s . worldLock . RUnlock ( ) return s . CurrentIndex }
633	func ( s * store ) Get ( nodePath string , recursive , sorted bool ) ( * Event , error ) { var err * v2error . Error s . worldLock . RLock ( ) defer s . worldLock . RUnlock ( ) defer func ( ) { if err == nil { s . Stats . Inc ( GetSuccess ) if recursive { reportReadSuccess ( GetRecursive ) } else { reportReadSuccess ( Get ) } return } s . Stats . Inc ( GetFail ) if recursive { reportReadFailure ( GetRecursive ) } else { reportReadFailure ( Get ) } } ( ) n , err := s . internalGet ( nodePath ) if err != nil { return nil , err } e := newEvent ( Get , nodePath , n . ModifiedIndex , n . CreatedIndex ) e . EtcdIndex = s . CurrentIndex e . Node . loadInternalNode ( n , recursive , sorted , s . clock ) return e , nil }
634	func ( s * store ) Create ( nodePath string , dir bool , value string , unique bool , expireOpts TTLOptionSet ) ( * Event , error ) { var err * v2error . Error s . worldLock . Lock ( ) defer s . worldLock . Unlock ( ) defer func ( ) { if err == nil { s . Stats . Inc ( CreateSuccess ) reportWriteSuccess ( Create ) return } s . Stats . Inc ( CreateFail ) reportWriteFailure ( Create ) } ( ) e , err := s . internalCreate ( nodePath , dir , value , unique , false , expireOpts . ExpireTime , Create ) if err != nil { return nil , err } e . EtcdIndex = s . CurrentIndex s . WatcherHub . notify ( e ) return e , nil }
635	func ( s * store ) Set ( nodePath string , dir bool , value string , expireOpts TTLOptionSet ) ( * Event , error ) { var err * v2error . Error s . worldLock . Lock ( ) defer s . worldLock . Unlock ( ) defer func ( ) { if err == nil { s . Stats . Inc ( SetSuccess ) reportWriteSuccess ( Set ) return } s . Stats . Inc ( SetFail ) reportWriteFailure ( Set ) } ( ) n , getErr := s . internalGet ( nodePath ) if getErr != nil && getErr . ErrorCode != v2error . EcodeKeyNotFound { err = getErr return nil , err } if expireOpts . Refresh { if getErr != nil { err = getErr return nil , err } value = n . Value } e , err := s . internalCreate ( nodePath , dir , value , false , true , expireOpts . ExpireTime , Set ) if err != nil { return nil , err } e . EtcdIndex = s . CurrentIndex if getErr == nil { prev := newEvent ( Get , nodePath , n . ModifiedIndex , n . CreatedIndex ) prev . Node . loadInternalNode ( n , false , false , s . clock ) e . PrevNode = prev . Node } if ! expireOpts . Refresh { s . WatcherHub . notify ( e ) } else { e . SetRefresh ( ) s . WatcherHub . add ( e ) } return e , nil }
636	func getCompareFailCause ( n * node , which int , prevValue string , prevIndex uint64 ) string { switch which { case CompareIndexNotMatch : return fmt . Sprintf ( "[%v != %v]" , prevIndex , n . ModifiedIndex ) case CompareValueNotMatch : return fmt . Sprintf ( "[%v != %v]" , prevValue , n . Value ) default : return fmt . Sprintf ( "[%v != %v] [%v != %v]" , prevValue , n . Value , prevIndex , n . ModifiedIndex ) } }
637	func ( s * store ) Delete ( nodePath string , dir , recursive bool ) ( * Event , error ) { var err * v2error . Error s . worldLock . Lock ( ) defer s . worldLock . Unlock ( ) defer func ( ) { if err == nil { s . Stats . Inc ( DeleteSuccess ) reportWriteSuccess ( Delete ) return } s . Stats . Inc ( DeleteFail ) reportWriteFailure ( Delete ) } ( ) nodePath = path . Clean ( path . Join ( "/" , nodePath ) ) if s . readonlySet . Contains ( nodePath ) { return nil , v2error . NewError ( v2error . EcodeRootROnly , "/" , s . CurrentIndex ) } if recursive { dir = true } n , err := s . internalGet ( nodePath ) if err != nil { return nil , err } nextIndex := s . CurrentIndex + 1 e := newEvent ( Delete , nodePath , nextIndex , n . CreatedIndex ) e . EtcdIndex = nextIndex e . PrevNode = n . Repr ( false , false , s . clock ) eNode := e . Node if n . IsDir ( ) { eNode . Dir = true } callback := func ( path string ) { s . WatcherHub . notifyWatchers ( e , path , true ) } err = n . Remove ( dir , recursive , callback ) if err != nil { return nil , err } s . CurrentIndex ++ s . WatcherHub . notify ( e ) return e , nil }
638	func ( s * store ) walk ( nodePath string , walkFunc func ( prev * node , component string ) ( * node , * v2error . Error ) ) ( * node , * v2error . Error ) { components := strings . Split ( nodePath , "/" ) curr := s . Root var err * v2error . Error for i := 1 ; i < len ( components ) ; i ++ { if len ( components [ i ] ) == 0 { return curr , nil } curr , err = walkFunc ( curr , components [ i ] ) if err != nil { return nil , err } } return curr , nil }
639	func ( s * store ) internalGet ( nodePath string ) ( * node , * v2error . Error ) { nodePath = path . Clean ( path . Join ( "/" , nodePath ) ) walkFunc := func ( parent * node , name string ) ( * node , * v2error . Error ) { if ! parent . IsDir ( ) { err := v2error . NewError ( v2error . EcodeNotDir , parent . Path , s . CurrentIndex ) return nil , err } child , ok := parent . Children [ name ] if ok { return child , nil } return nil , v2error . NewError ( v2error . EcodeKeyNotFound , path . Join ( parent . Path , name ) , s . CurrentIndex ) } f , err := s . walk ( nodePath , walkFunc ) if err != nil { return nil , err } return f , nil }
640	func ( s * store ) DeleteExpiredKeys ( cutoff time . Time ) { s . worldLock . Lock ( ) defer s . worldLock . Unlock ( ) for { node := s . ttlKeyHeap . top ( ) if node == nil || node . ExpireTime . After ( cutoff ) { break } s . CurrentIndex ++ e := newEvent ( Expire , node . Path , s . CurrentIndex , node . CreatedIndex ) e . EtcdIndex = s . CurrentIndex e . PrevNode = node . Repr ( false , false , s . clock ) if node . IsDir ( ) { e . Node . Dir = true } callback := func ( path string ) { s . WatcherHub . notifyWatchers ( e , path , true ) } s . ttlKeyHeap . pop ( ) node . Remove ( true , true , callback ) reportExpiredKey ( ) s . Stats . Inc ( ExpireCount ) s . WatcherHub . notify ( e ) } }
641	func ( s * store ) checkDir ( parent * node , dirName string ) ( * node , * v2error . Error ) { node , ok := parent . Children [ dirName ] if ok { if node . IsDir ( ) { return node , nil } return nil , v2error . NewError ( v2error . EcodeNotDir , node . Path , s . CurrentIndex ) } n := newDir ( s , path . Join ( parent . Path , dirName ) , s . CurrentIndex + 1 , parent , Permanent ) parent . Children [ dirName ] = n return n , nil }
642	func ( s * store ) Save ( ) ( [ ] byte , error ) { b , err := json . Marshal ( s . Clone ( ) ) if err != nil { return nil , err } return b , nil }
643	func ( s * store ) Recovery ( state [ ] byte ) error { s . worldLock . Lock ( ) defer s . worldLock . Unlock ( ) err := json . Unmarshal ( state , s ) if err != nil { return err } s . ttlKeyHeap = newTtlKeyHeap ( ) s . Root . recoverAndclean ( ) return nil }
644	func ( g * Generator ) Next ( ) uint64 { suffix := atomic . AddUint64 ( & g . suffix , 1 ) id := g . prefix | lowbit ( suffix , suffixLen ) return id }
645	func NewMakeMirrorCommand ( ) * cobra . Command { c := & cobra . Command { Use : "make-mirror [options] <destination>" , Short : "Makes a mirror at the destination etcd cluster" , Run : makeMirrorCommandFunc , } c . Flags ( ) . StringVar ( & mmprefix , "prefix" , "" , "Key-value prefix to mirror" ) c . Flags ( ) . StringVar ( & mmdestprefix , "dest-prefix" , "" , "destination prefix to mirror a prefix to a different prefix in the destination cluster" ) c . Flags ( ) . BoolVar ( & mmnodestprefix , "no-dest-prefix" , false , "mirror key-values to the root of the destination cluster" ) c . Flags ( ) . StringVar ( & mmcert , "dest-cert" , "" , "Identify secure client using this TLS certificate file for the destination cluster" ) c . Flags ( ) . StringVar ( & mmkey , "dest-key" , "" , "Identify secure client using this TLS key file" ) c . Flags ( ) . StringVar ( & mmcacert , "dest-cacert" , "" , "Verify certificates of TLS enabled secure servers using this CA bundle" ) c . Flags ( ) . BoolVar ( & mminsecureTr , "dest-insecure-transport" , true , "Disable transport security for client connections" ) return c }
646	func NewZapCoreLoggerBuilder ( lg * zap . Logger , cr zapcore . Core , syncer zapcore . WriteSyncer ) func ( * Config ) error { return func ( cfg * Config ) error { cfg . loggerMu . Lock ( ) defer cfg . loggerMu . Unlock ( ) cfg . logger = lg cfg . loggerConfig = nil cfg . loggerCore = cr cfg . loggerWriteSyncer = syncer grpcLogOnce . Do ( func ( ) { grpclog . SetLoggerV2 ( logutil . NewGRPCLoggerV2FromZapCore ( cr , syncer ) ) } ) return nil } }
647	func NewSyncer ( c * clientv3 . Client , prefix string , rev int64 ) Syncer { return & syncer { c : c , prefix : prefix , rev : rev } }
648	func DropPort ( port int ) error { cmdStr := fmt . Sprintf ( "sudo iptables -A OUTPUT -p tcp --destination-port %d -j DROP" , port ) if _ , err := exec . Command ( "/bin/sh" , "-c" , cmdStr ) . Output ( ) ; err != nil { return err } cmdStr = fmt . Sprintf ( "sudo iptables -A INPUT -p tcp --destination-port %d -j DROP" , port ) _ , err := exec . Command ( "/bin/sh" , "-c" , cmdStr ) . Output ( ) return err }
649	func SetLatency ( ms , rv int ) error { ifces , err := GetDefaultInterfaces ( ) if err != nil { return err } if rv > ms { rv = 1 } for ifce := range ifces { cmdStr := fmt . Sprintf ( "sudo tc qdisc add dev %s root netem delay %dms %dms distribution normal" , ifce , ms , rv ) _ , err = exec . Command ( "/bin/sh" , "-c" , cmdStr ) . Output ( ) if err != nil { cmdStr = fmt . Sprintf ( "sudo tc qdisc change dev %s root netem delay %dms %dms distribution normal" , ifce , ms , rv ) _ , err = exec . Command ( "/bin/sh" , "-c" , cmdStr ) . Output ( ) if err != nil { return err } } } return nil }
650	func RemoveLatency ( ) error { ifces , err := GetDefaultInterfaces ( ) if err != nil { return err } for ifce := range ifces { _ , err = exec . Command ( "/bin/sh" , "-c" , fmt . Sprintf ( "sudo tc qdisc del dev %s root netem" , ifce ) ) . Output ( ) if err != nil { return err } } return nil }
651	func NewTxnCommand ( ) * cobra . Command { cmd := & cobra . Command { Use : "txn [options]" , Short : "Txn processes all the requests in one transaction" , Run : txnCommandFunc , } cmd . Flags ( ) . BoolVarP ( & txnInteractive , "interactive" , "i" , false , "Input transaction in interactive mode" ) return cmd }
652	func txnCommandFunc ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != 0 { ExitWithError ( ExitBadArgs , fmt . Errorf ( "txn command does not accept argument" ) ) } reader := bufio . NewReader ( os . Stdin ) txn := mustClientFromCmd ( cmd ) . Txn ( context . Background ( ) ) promptInteractive ( "compares:" ) txn . If ( readCompares ( reader ) ... ) promptInteractive ( "success requests (get, put, del):" ) txn . Then ( readOps ( reader ) ... ) promptInteractive ( "failure requests (get, put, del):" ) txn . Else ( readOps ( reader ) ... ) resp , err := txn . Commit ( ) if err != nil { ExitWithError ( ExitError , err ) } display . Txn ( * resp ) }
653	func New ( lg * zap . Logger , mode string , retention time . Duration , rg RevGetter , c Compactable , ) ( Compactor , error ) { switch mode { case ModePeriodic : return newPeriodic ( lg , clockwork . NewRealClock ( ) , retention , rg , c ) , nil case ModeRevision : return newRevision ( lg , clockwork . NewRealClock ( ) , int64 ( retention ) , rg , c ) , nil default : return nil , fmt . Errorf ( "unsupported compaction mode %s" , mode ) } }
654	func printResponseKey ( resp * client . Response , format string ) { switch format { case "simple" : if resp . Action != "delete" { fmt . Println ( resp . Node . Value ) } else { fmt . Println ( "PrevNode.Value:" , resp . PrevNode . Value ) } case "extended" : fmt . Println ( "Key:" , resp . Node . Key ) fmt . Println ( "Created-Index:" , resp . Node . CreatedIndex ) fmt . Println ( "Modified-Index:" , resp . Node . ModifiedIndex ) if resp . PrevNode != nil { fmt . Println ( "PrevNode.Value:" , resp . PrevNode . Value ) } fmt . Println ( "TTL:" , resp . Node . TTL ) fmt . Println ( "Index:" , resp . Index ) if resp . Action != "delete" { fmt . Println ( "" ) fmt . Println ( resp . Node . Value ) } case "json" : b , err := json . Marshal ( resp ) if err != nil { panic ( err ) } fmt . Println ( string ( b ) ) default : fmt . Fprintln ( os . Stderr , "Unsupported output format:" , format ) } }
655	func RegisterLockHandler ( ctx context . Context , mux * runtime . ServeMux , conn * grpc . ClientConn ) error { return RegisterLockHandlerClient ( ctx , mux , v3lockpb . NewLockClient ( conn ) ) }
656	func grpcHandlerFunc ( grpcServer * grpc . Server , otherHandler http . Handler ) http . Handler { if otherHandler == nil { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { grpcServer . ServeHTTP ( w , r ) } ) } return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { if r . ProtoMajor == 2 && strings . Contains ( r . Header . Get ( "Content-Type" ) , "application/grpc" ) { grpcServer . ServeHTTP ( w , r ) } else { otherHandler . ServeHTTP ( w , r ) } } ) }
657	func addCORSHeader ( w http . ResponseWriter , origin string ) { w . Header ( ) . Add ( "Access-Control-Allow-Methods" , "POST, GET, OPTIONS, PUT, DELETE" ) w . Header ( ) . Add ( "Access-Control-Allow-Origin" , origin ) w . Header ( ) . Add ( "Access-Control-Allow-Headers" , "accept, content-type, authorization" ) }
658	func ( txn * txnLeasing ) fallback ( ops [ ] v3 . Op ) ( fbOps [ ] v3 . Op ) { for _ , op := range ops { if op . IsGet ( ) { continue } lkey , lend := txn . lkv . pfx + string ( op . KeyBytes ( ) ) , "" if len ( op . RangeBytes ( ) ) > 0 { lend = txn . lkv . pfx + string ( op . RangeBytes ( ) ) } fbOps = append ( fbOps , v3 . OpGet ( lkey , v3 . WithRange ( lend ) ) ) } return fbOps }
659	func IDFromString ( s string ) ( ID , error ) { i , err := strconv . ParseUint ( s , 16 , 64 ) return ID ( i ) , err }
660	func ( guard * directoryLockGuard ) release ( ) error { var err error if ! guard . readOnly { err = os . Remove ( guard . path ) } if closeErr := guard . f . Close ( ) ; err == nil { err = closeErr } guard . path = "" guard . f = nil return err }
661	func ( v * ValueStruct ) EncodedSize ( ) uint16 { sz := len ( v . Value ) + 2 if v . ExpiresAt == 0 { return uint16 ( sz + 1 ) } enc := sizeVarint ( v . ExpiresAt ) return uint16 ( sz + enc ) }
662	func ( v * ValueStruct ) Decode ( b [ ] byte ) { v . Meta = b [ 0 ] v . UserMeta = b [ 1 ] var sz int v . ExpiresAt , sz = binary . Uvarint ( b [ 2 : ] ) v . Value = b [ 2 + sz : ] }
663	func NewMergeIterator ( iters [ ] Iterator , reversed bool ) * MergeIterator { m := & MergeIterator { all : iters , reversed : reversed } m . h = make ( elemHeap , 0 , len ( iters ) ) m . initHeap ( ) return m }
664	func ( s * MergeIterator ) initHeap ( ) { s . h = s . h [ : 0 ] for idx , itr := range s . all { if ! itr . Valid ( ) { continue } e := & elem { itr : itr , nice : idx , reversed : s . reversed } s . h = append ( s . h , e ) } heap . Init ( & s . h ) for len ( s . h ) > 0 { it := s . h [ 0 ] . itr if it == nil || ! it . Valid ( ) { heap . Pop ( & s . h ) continue } s . storeKey ( s . h [ 0 ] . itr ) break } }
665	func ( s * MergeIterator ) Valid ( ) bool { if s == nil { return false } if len ( s . h ) == 0 { return false } return s . h [ 0 ] . itr . Valid ( ) }
666	func ( s * MergeIterator ) Key ( ) [ ] byte { if len ( s . h ) == 0 { return nil } return s . h [ 0 ] . itr . Key ( ) }
667	func ( s * MergeIterator ) Value ( ) ValueStruct { if len ( s . h ) == 0 { return ValueStruct { } } return s . h [ 0 ] . itr . Value ( ) }
668	func ( s * MergeIterator ) Next ( ) { if len ( s . h ) == 0 { return } smallest := s . h [ 0 ] . itr smallest . Next ( ) for len ( s . h ) > 0 { smallest = s . h [ 0 ] . itr if ! smallest . Valid ( ) { heap . Pop ( & s . h ) continue } heap . Fix ( & s . h , 0 ) smallest = s . h [ 0 ] . itr if smallest . Valid ( ) { if ! bytes . Equal ( smallest . Key ( ) , s . curKey ) { break } smallest . Next ( ) } } if ! smallest . Valid ( ) { return } s . storeKey ( smallest ) }
669	func ( s * MergeIterator ) Seek ( key [ ] byte ) { for _ , itr := range s . all { itr . Seek ( key ) } s . initHeap ( ) }
670	func ( s * MergeIterator ) Close ( ) error { for _ , itr := range s . all { if err := itr . Close ( ) ; err != nil { return errors . Wrap ( err , "MergeIterator" ) } } return nil }
671	func ( p valuePointer ) Encode ( b [ ] byte ) [ ] byte { binary . BigEndian . PutUint32 ( b [ : 4 ] , p . Fid ) binary . BigEndian . PutUint32 ( b [ 4 : 8 ] , p . Len ) binary . BigEndian . PutUint32 ( b [ 8 : 12 ] , p . Offset ) return b [ : vptrSize ] }
672	func ( h * header ) Decode ( buf [ ] byte ) { h . klen = binary . BigEndian . Uint32 ( buf [ 0 : 4 ] ) h . vlen = binary . BigEndian . Uint32 ( buf [ 4 : 8 ] ) h . expiresAt = binary . BigEndian . Uint64 ( buf [ 8 : 16 ] ) h . meta = buf [ 16 ] h . userMeta = buf [ 17 ] }
673	func encodeEntry ( e * Entry , buf * bytes . Buffer ) ( int , error ) { h := header { klen : uint32 ( len ( e . Key ) ) , vlen : uint32 ( len ( e . Value ) ) , expiresAt : e . ExpiresAt , meta : e . meta , userMeta : e . UserMeta , } var headerEnc [ headerBufSize ] byte h . Encode ( headerEnc [ : ] ) hash := crc32 . New ( y . CastagnoliCrcTable ) buf . Write ( headerEnc [ : ] ) hash . Write ( headerEnc [ : ] ) buf . Write ( e . Key ) hash . Write ( e . Key ) buf . Write ( e . Value ) hash . Write ( e . Value ) var crcBuf [ crc32 . Size ] byte binary . BigEndian . PutUint32 ( crcBuf [ : ] , hash . Sum32 ( ) ) buf . Write ( crcBuf [ : ] ) return len ( headerEnc ) + len ( e . Key ) + len ( e . Value ) + len ( crcBuf ) , nil }
674	func ( wb * WriteBatch ) SetEntry ( e * Entry ) error { wb . Lock ( ) defer wb . Unlock ( ) if err := wb . txn . SetEntry ( e ) ; err != ErrTxnTooBig { return err } if cerr := wb . commit ( ) ; cerr != nil { return cerr } if err := wb . txn . SetEntry ( e ) ; err != nil { wb . err = err return err } return nil }
675	func ( wb * WriteBatch ) Set ( k , v [ ] byte , meta byte ) error { e := & Entry { Key : k , Value : v , UserMeta : meta } return wb . SetEntry ( e ) }
676	func ( wb * WriteBatch ) SetWithTTL ( key , val [ ] byte , dur time . Duration ) error { expire := time . Now ( ) . Add ( dur ) . Unix ( ) e := & Entry { Key : key , Value : val , ExpiresAt : uint64 ( expire ) } return wb . SetEntry ( e ) }
677	func ( wb * WriteBatch ) Delete ( k [ ] byte ) error { wb . Lock ( ) defer wb . Unlock ( ) if err := wb . txn . Delete ( k ) ; err != ErrTxnTooBig { return err } if err := wb . commit ( ) ; err != nil { return err } if err := wb . txn . Delete ( k ) ; err != nil { wb . err = err return err } return nil }
678	func ( wb * WriteBatch ) commit ( ) error { if wb . err != nil { return wb . err } wb . wg . Add ( 1 ) wb . txn . CommitWith ( wb . callback ) wb . txn = wb . db . newTransaction ( true , true ) wb . txn . readTs = wb . db . orc . readMark . DoneUntil ( ) return wb . err }
679	func ( wb * WriteBatch ) Flush ( ) error { wb . Lock ( ) _ = wb . commit ( ) wb . txn . Discard ( ) wb . Unlock ( ) wb . wg . Wait ( ) return wb . err }
680	func ( wb * WriteBatch ) Error ( ) error { wb . Lock ( ) defer wb . Unlock ( ) return wb . err }
681	func ( db * DB ) getMemTables ( ) ( [ ] * skl . Skiplist , func ( ) ) { db . RLock ( ) defer db . RUnlock ( ) tables := make ( [ ] * skl . Skiplist , len ( db . imm ) + 1 ) tables [ 0 ] = db . mt tables [ 0 ] . IncrRef ( ) last := len ( db . imm ) - 1 for i := range db . imm { tables [ i + 1 ] = db . imm [ last - i ] tables [ i + 1 ] . IncrRef ( ) } return tables , func ( ) { for _ , tbl := range tables { tbl . DecrRef ( ) } } }
682	func ( db * DB ) writeRequests ( reqs [ ] * request ) error { if len ( reqs ) == 0 { return nil } done := func ( err error ) { for _ , r := range reqs { r . Err = err r . Wg . Done ( ) } } db . elog . Printf ( "writeRequests called. Writing to value log" ) err := db . vlog . write ( reqs ) if err != nil { done ( err ) return err } db . elog . Printf ( "Writing to memtable" ) var count int for _ , b := range reqs { if len ( b . Entries ) == 0 { continue } count += len ( b . Entries ) var i uint64 for err = db . ensureRoomForWrite ( ) ; err == errNoRoom ; err = db . ensureRoomForWrite ( ) { i ++ if i % 100 == 0 { db . elog . Printf ( "Making room for writes" ) } time . Sleep ( 10 * time . Millisecond ) } if err != nil { done ( err ) return errors . Wrap ( err , "writeRequests" ) } if err := db . writeToLSM ( b ) ; err != nil { done ( err ) return errors . Wrap ( err , "writeRequests" ) } db . updateHead ( b . Ptrs ) } done ( nil ) db . elog . Printf ( "%d entries written" , count ) return nil }
683	func ( db * DB ) ensureRoomForWrite ( ) error { var err error db . Lock ( ) defer db . Unlock ( ) if db . mt . MemSize ( ) < db . opt . MaxTableSize { return nil } y . AssertTrue ( db . mt != nil ) select { case db . flushChan <- flushTask { mt : db . mt , vptr : db . vhead } : db . elog . Printf ( "Flushing value log to disk if async mode." ) err = db . vlog . sync ( db . vhead . Fid ) if err != nil { return err } db . elog . Printf ( "Flushing memtable, mt.size=%d size of flushChan: %d\n" , \n , db . mt . MemSize ( ) ) len ( db . flushChan ) db . imm = append ( db . imm , db . mt ) db . mt = skl . NewSkiplist ( arenaSize ( db . opt ) ) return nil } }
684	func writeLevel0Table ( ft flushTask , f io . Writer ) error { iter := ft . mt . NewIterator ( ) defer iter . Close ( ) b := table . NewTableBuilder ( ) defer b . Close ( ) for iter . SeekToFirst ( ) ; iter . Valid ( ) ; iter . Next ( ) { if len ( ft . dropPrefix ) > 0 && bytes . HasPrefix ( iter . Key ( ) , ft . dropPrefix ) { continue } if err := b . Add ( iter . Key ( ) , iter . Value ( ) ) ; err != nil { return err } } _ , err := f . Write ( b . Finish ( ) ) return err }
685	func ( db * DB ) handleFlushTask ( ft flushTask ) error { if ! ft . mt . Empty ( ) { db . opt . Debugf ( "Storing value log head: %+v\n" , \n ) ft . vptr db . elog . Printf ( "Storing offset: %+v\n" , \n ) ft . vptr offset := make ( [ ] byte , vptrSize ) ft . vptr . Encode ( offset ) headTs := y . KeyWithTs ( head , db . orc . nextTs ( ) ) ft . mt . Put ( headTs , y . ValueStruct { Value : offset } ) } discardStatsKey := y . KeyWithTs ( lfDiscardStatsKey , 1 ) ft . mt . Put ( discardStatsKey , y . ValueStruct { Value : db . vlog . encodedDiscardStats ( ) } ) fileID := db . lc . reserveFileID ( ) fd , err := y . CreateSyncedFile ( table . NewFilename ( fileID , db . opt . Dir ) , true ) if err != nil { return y . Wrap ( err ) } dirSyncCh := make ( chan error ) go func ( ) { dirSyncCh <- syncDir ( db . opt . Dir ) } ( ) err = writeLevel0Table ( ft , fd ) dirSyncErr := <- dirSyncCh if err != nil { db . elog . Errorf ( "ERROR while writing to level 0: %v" , err ) return err } if dirSyncErr != nil { db . elog . Errorf ( "ERROR while syncing level directory: %v" , dirSyncErr ) } tbl , err := table . OpenTable ( fd , db . opt . TableLoadingMode , nil ) if err != nil { db . elog . Printf ( "ERROR while opening table: %v" , err ) return err } err = db . lc . addLevel0Table ( tbl ) }
686	func ( db * DB ) flushMemtable ( lc * y . Closer ) error { defer lc . Done ( ) for ft := range db . flushChan { if ft . mt == nil { continue } for { err := db . handleFlushTask ( ft ) if err == nil { db . Lock ( ) y . AssertTrue ( ft . mt == db . imm [ 0 ] ) db . imm = db . imm [ 1 : ] ft . mt . DecrRef ( ) db . Unlock ( ) break } db . opt . Errorf ( "Failure while flushing memtable to disk: %v. Retrying...\n" , \n ) err } } time . Sleep ( time . Second ) }
687	func ( db * DB ) calculateSize ( ) { newInt := func ( val int64 ) * expvar . Int { v := new ( expvar . Int ) v . Add ( val ) return v } totalSize := func ( dir string ) ( int64 , int64 ) { var lsmSize , vlogSize int64 err := filepath . Walk ( dir , func ( path string , info os . FileInfo , err error ) error { if err != nil { return err } ext := filepath . Ext ( path ) if ext == ".sst" { lsmSize += info . Size ( ) } else if ext == ".vlog" { vlogSize += info . Size ( ) } return nil } ) if err != nil { db . elog . Printf ( "Got error while calculating total size of directory: %s" , dir ) } return lsmSize , vlogSize } lsmSize , vlogSize := totalSize ( db . opt . Dir ) y . LSMSize . Set ( db . opt . Dir , newInt ( lsmSize ) ) if db . opt . ValueDir != db . opt . Dir { _ , vlogSize = totalSize ( db . opt . ValueDir ) } y . VlogSize . Set ( db . opt . Dir , newInt ( vlogSize ) ) }
688	func ( db * DB ) Size ( ) ( lsm , vlog int64 ) { if y . LSMSize . Get ( db . opt . Dir ) == nil { lsm , vlog = 0 , 0 return } lsm = y . LSMSize . Get ( db . opt . Dir ) . ( * expvar . Int ) . Value ( ) vlog = y . VlogSize . Get ( db . opt . Dir ) . ( * expvar . Int ) . Value ( ) return }
689	func ( seq * Sequence ) Next ( ) ( uint64 , error ) { seq . Lock ( ) defer seq . Unlock ( ) if seq . next >= seq . leased { if err := seq . updateLease ( ) ; err != nil { return 0 , err } } val := seq . next seq . next ++ return val , nil }
690	func ( seq * Sequence ) Release ( ) error { seq . Lock ( ) defer seq . Unlock ( ) err := seq . db . Update ( func ( txn * Txn ) error { var buf [ 8 ] byte binary . BigEndian . PutUint64 ( buf [ : ] , seq . next ) return txn . Set ( seq . key , buf [ : ] ) } ) if err != nil { return err } seq . leased = seq . next return nil }
691	func ( db * DB ) KeySplits ( prefix [ ] byte ) [ ] string { var splits [ ] string for _ , ti := range db . Tables ( ) { if bytes . HasPrefix ( ti . Right , prefix ) { splits = append ( splits , string ( ti . Right ) ) } } sort . Strings ( splits ) return splits }
692	func ( db * DB ) Flatten ( workers int ) error { db . stopCompactions ( ) defer db . startCompactions ( ) compactAway := func ( cp compactionPriority ) error { db . opt . Infof ( "Attempting to compact with %+v\n" , \n ) cp errCh := make ( chan error , 1 ) for i := 0 ; i < workers ; i ++ { go func ( ) { errCh <- db . lc . doCompact ( cp ) } ( ) } var success int var rerr error for i := 0 ; i < workers ; i ++ { err := <- errCh if err != nil { rerr = err db . opt . Warningf ( "While running doCompact with %+v. Error: %v\n" , \n , cp ) } else err } { success ++ } if success == 0 { return rerr } } db . opt . Infof ( "%d compactor(s) succeeded. One or more tables from level %d compacted.\n" , \n , success ) cp . level }
693	func Mmap ( fd * os . File , writable bool , size int64 ) ( [ ] byte , error ) { mtype := unix . PROT_READ if writable { mtype |= unix . PROT_WRITE } return unix . Mmap ( int ( fd . Fd ( ) ) , 0 , int ( size ) , mtype , unix . MAP_SHARED ) }
694	func Madvise ( b [ ] byte , readahead bool ) error { flags := unix . MADV_NORMAL if ! readahead { flags = unix . MADV_RANDOM } return madvise ( b , flags ) }
695	func ( o * oracle ) setDiscardTs ( ts uint64 ) { o . Lock ( ) defer o . Unlock ( ) o . discardTs = ts }
696	func ( o * oracle ) hasConflict ( txn * Txn ) bool { if len ( txn . reads ) == 0 { return false } for _ , ro := range txn . reads { if ts , has := o . commits [ ro ] ; has && ts > txn . readTs { return true } } return false }
697	func ( txn * Txn ) Set ( key , val [ ] byte ) error { e := & Entry { Key : key , Value : val , } return txn . SetEntry ( e ) }
698	func ( txn * Txn ) SetWithMeta ( key , val [ ] byte , meta byte ) error { e := & Entry { Key : key , Value : val , UserMeta : meta } return txn . SetEntry ( e ) }
699	func ( txn * Txn ) Delete ( key [ ] byte ) error { e := & Entry { Key : key , meta : bitDelete , } return txn . modify ( e ) }
700	func ( txn * Txn ) Get ( key [ ] byte ) ( item * Item , rerr error ) { if len ( key ) == 0 { return nil , ErrEmptyKey } else if txn . discarded { return nil , ErrDiscardedTxn } item = new ( Item ) if txn . update { if e , has := txn . pendingWrites [ string ( key ) ] ; has && bytes . Equal ( key , e . Key ) { if isDeletedOrExpired ( e . meta , e . ExpiresAt ) { return nil , ErrKeyNotFound } item . meta = e . meta item . val = e . Value item . userMeta = e . UserMeta item . key = key item . status = prefetched item . version = txn . readTs item . expiresAt = e . ExpiresAt return item , nil } txn . addReadKey ( key ) } seek := y . KeyWithTs ( key , txn . readTs ) vs , err := txn . db . get ( seek ) if err != nil { return nil , errors . Wrapf ( err , "DB::Get key: %q" , key ) } if vs . Value == nil && vs . Meta == 0 { return nil , ErrKeyNotFound } if isDeletedOrExpired ( vs . Meta , vs . ExpiresAt ) { return nil , ErrKeyNotFound } item . key = key item . version = vs . Version item . meta = vs . Meta item . userMeta = vs . UserMeta item . db = txn . db item . vptr = vs . Value item . txn = txn item . expiresAt = vs . ExpiresAt return item , nil }
701	func ( txn * Txn ) CommitWith ( cb func ( error ) ) { txn . commitPrecheck ( ) defer txn . Discard ( ) if cb == nil { panic ( "Nil callback provided to CommitWith" ) } if len ( txn . writes ) == 0 { go runTxnCallback ( & txnCb { user : cb , err : nil } ) return } commitCb , err := txn . commitAndSend ( ) if err != nil { go runTxnCallback ( & txnCb { user : cb , err : err } ) return } go runTxnCallback ( & txnCb { user : cb , commit : commitCb } ) }
702	func ( db * DB ) View ( fn func ( txn * Txn ) error ) error { var txn * Txn if db . opt . managedTxns { txn = db . NewTransactionAt ( math . MaxUint64 , false ) } else { txn = db . NewTransaction ( false ) } defer txn . Discard ( ) return fn ( txn ) }
703	func ( db * DB ) Update ( fn func ( txn * Txn ) error ) error { if db . opt . managedTxns { panic ( "Update can only be used with managedDB=false." ) } txn := db . NewTransaction ( true ) defer txn . Discard ( ) if err := fn ( txn ) ; err != nil { return err } return txn . Commit ( ) }
704	func ( itr * blockIterator ) Seek ( key [ ] byte , whence int ) { itr . err = nil switch whence { case origin : itr . Reset ( ) case current : } var done bool for itr . Init ( ) ; itr . Valid ( ) ; itr . Next ( ) { k := itr . Key ( ) if y . CompareKeys ( k , key ) >= 0 { done = true break } } if ! done { itr . err = io . EOF } }
705	func ( itr * blockIterator ) SeekToLast ( ) { itr . err = nil for itr . Init ( ) ; itr . Valid ( ) ; itr . Next ( ) { } itr . Prev ( ) }
706	func ( itr * blockIterator ) parseKV ( h header ) { if cap ( itr . key ) < int ( h . plen + h . klen ) { sz := int ( h . plen ) + int ( h . klen ) itr . key = make ( [ ] byte , 2 * sz ) } itr . key = itr . key [ : h . plen + h . klen ] copy ( itr . key , itr . baseKey [ : h . plen ] ) copy ( itr . key [ h . plen : ] , itr . data [ itr . pos : itr . pos + uint32 ( h . klen ) ] ) itr . pos += uint32 ( h . klen ) if itr . pos + uint32 ( h . vlen ) > uint32 ( len ( itr . data ) ) { itr . err = errors . Errorf ( "Value exceeded size of block: %d %d %d %d %v" , itr . pos , h . klen , h . vlen , len ( itr . data ) , h ) return } itr . val = y . SafeCopy ( itr . val , itr . data [ itr . pos : itr . pos + uint32 ( h . vlen ) ] ) itr . pos += uint32 ( h . vlen ) }
707	func ( t * Table ) NewIterator ( reversed bool ) * Iterator { t . IncrRef ( ) ti := & Iterator { t : t , reversed : reversed } ti . next ( ) return ti }
708	func ( itr * Iterator ) seekFrom ( key [ ] byte , whence int ) { itr . err = nil switch whence { case origin : itr . reset ( ) case current : } idx := sort . Search ( len ( itr . t . blockIndex ) , func ( idx int ) bool { ko := itr . t . blockIndex [ idx ] return y . CompareKeys ( ko . key , key ) > 0 } ) if idx == 0 { itr . seekHelper ( 0 , key ) return } itr . seekHelper ( idx - 1 , key ) if itr . err == io . EOF { if idx == len ( itr . t . blockIndex ) { return } itr . seekHelper ( idx , key ) } }
709	func ( itr * Iterator ) seekForPrev ( key [ ] byte ) { itr . seekFrom ( key , origin ) if ! bytes . Equal ( itr . Key ( ) , key ) { itr . prev ( ) } }
710	func ( itr * Iterator ) Value ( ) ( ret y . ValueStruct ) { ret . Decode ( itr . bi . Value ( ) ) return }
711	func ( itr * Iterator ) Seek ( key [ ] byte ) { if ! itr . reversed { itr . seek ( key ) } else { itr . seekForPrev ( key ) } }
712	func NewConcatIterator ( tbls [ ] * Table , reversed bool ) * ConcatIterator { iters := make ( [ ] * Iterator , len ( tbls ) ) for i := 0 ; i < len ( tbls ) ; i ++ { iters [ i ] = tbls [ i ] . NewIterator ( reversed ) } return & ConcatIterator { reversed : reversed , iters : iters , tables : tbls , idx : - 1 , } }
713	func ( s * ConcatIterator ) Valid ( ) bool { return s . cur != nil && s . cur . Valid ( ) }
714	func ( s * ConcatIterator ) Next ( ) { s . cur . Next ( ) if s . cur . Valid ( ) { return } for { if ! s . reversed { s . setIdx ( s . idx + 1 ) } else { s . setIdx ( s . idx - 1 ) } if s . cur == nil { return } s . cur . Rewind ( ) if s . cur . Valid ( ) { break } } }
715	func ( s * ConcatIterator ) Close ( ) error { for _ , it := range s . iters { if err := it . Close ( ) ; err != nil { return errors . Wrap ( err , "ConcatIterator" ) } } return nil }
716	func OpenExistingFile ( filename string , flags uint32 ) ( * os . File , error ) { openFlags := os . O_RDWR if flags & ReadOnly != 0 { openFlags = os . O_RDONLY } if flags & Sync != 0 { openFlags |= datasyncFileFlag } return os . OpenFile ( filename , openFlags , 0 ) }
717	func Copy ( a [ ] byte ) [ ] byte { b := make ( [ ] byte , len ( a ) ) copy ( b , a ) return b }
718	func KeyWithTs ( key [ ] byte , ts uint64 ) [ ] byte { out := make ( [ ] byte , len ( key ) + 8 ) copy ( out , key ) binary . BigEndian . PutUint64 ( out [ len ( key ) : ] , math . MaxUint64 - ts ) return out }
719	func ParseTs ( key [ ] byte ) uint64 { if len ( key ) <= 8 { return 0 } return math . MaxUint64 - binary . BigEndian . Uint64 ( key [ len ( key ) - 8 : ] ) }
720	func ParseKey ( key [ ] byte ) [ ] byte { if key == nil { return nil } AssertTrue ( len ( key ) > 8 ) return key [ : len ( key ) - 8 ] }
721	func SameKey ( src , dst [ ] byte ) bool { if len ( src ) != len ( dst ) { return false } return bytes . Equal ( ParseKey ( src ) , ParseKey ( dst ) ) }
722	func FixedDuration ( d time . Duration ) string { str := fmt . Sprintf ( "%02ds" , int ( d . Seconds ( ) ) % 60 ) if d >= time . Minute { str = fmt . Sprintf ( "%02dm" , int ( d . Minutes ( ) ) % 60 ) + str } if d >= time . Hour { str = fmt . Sprintf ( "%02dh" , int ( d . Hours ( ) ) ) + str } return str }
723	func NewCloser ( initial int ) * Closer { ret := & Closer { closed : make ( chan struct { } ) } ret . waiting . Add ( initial ) return ret }
724	func NewThrottle ( max int ) * Throttle { return & Throttle { ch : make ( chan struct { } , max ) , errCh : make ( chan error , max ) , } }
725	func ( t * Throttle ) Do ( ) error { for { select { case t . ch <- struct { } { } : t . wg . Add ( 1 ) return nil case err := <- t . errCh : if err != nil { return err } } } }
726	func ( t * Throttle ) Done ( err error ) { if err != nil { t . errCh <- err } select { case <- t . ch : default : panic ( "Throttle Do Done mismatch" ) } t . wg . Done ( ) }
727	func ( t * Throttle ) Finish ( ) error { t . wg . Wait ( ) close ( t . ch ) close ( t . errCh ) for err := range t . errCh { if err != nil { return err } } return nil }
728	func ( db * DB ) SetDiscardTs ( ts uint64 ) { if ! db . opt . managedTxns { panic ( "Cannot use SetDiscardTs with managedDB=false." ) } db . orc . setDiscardTs ( ts ) }
729	func ( lf * logFile ) openReadOnly ( ) error { var err error lf . fd , err = os . OpenFile ( lf . path , os . O_RDONLY , 0666 ) if err != nil { return errors . Wrapf ( err , "Unable to open %q as RDONLY." , lf . path ) } fi , err := lf . fd . Stat ( ) if err != nil { return errors . Wrapf ( err , "Unable to check stat for %q" , lf . path ) } y . AssertTrue ( fi . Size ( ) <= math . MaxUint32 ) lf . size = uint32 ( fi . Size ( ) ) if err = lf . mmap ( fi . Size ( ) ) ; err != nil { _ = lf . fd . Close ( ) return y . Wrapf ( err , "Unable to map file" ) } return nil }
730	func ( vlog * valueLog ) iterate ( lf * logFile , offset uint32 , fn logEntry ) ( uint32 , error ) { fi , err := lf . fd . Stat ( ) if err != nil { return 0 , err } if int64 ( offset ) == fi . Size ( ) { return offset , nil } if vlog . opt . ReadOnly { return 0 , ErrReplayNeeded } if _ , err := lf . fd . Seek ( int64 ( offset ) , io . SeekStart ) ; err != nil { return 0 , errFile ( err , lf . path , "Unable to seek" ) } reader := bufio . NewReader ( lf . fd ) read := & safeRead { k : make ( [ ] byte , 10 ) , v : make ( [ ] byte , 10 ) , recordOffset : offset , } var lastCommit uint64 var validEndOffset uint32 for { e , err := read . Entry ( reader ) if err == io . EOF { break } else if err == io . ErrUnexpectedEOF || err == errTruncate { break } else if err != nil { return 0 , err } else if e == nil { continue } var vp valuePointer vp . Len = uint32 ( headerBufSize + len ( e . Key ) + len ( e . Value ) + crc32 . Size ) read . recordOffset += vp . Len vp . Offset = e . offset vp . Fid = lf . fid if e . meta & bitTxn > 0 { txnTs := y . ParseTs ( e . Key ) if lastCommit == 0 { lastCommit = txnTs } if lastCommit != txnTs { break } } else if e . meta & bitFinTxn > 0 { txnTs , err := strconv . ParseUint ( string ( e . Value ) , 10 , 64 ) if err != nil || lastCommit != txnTs { break } lastCommit = 0 validEndOffset = read . recordOffset } else { if lastCommit != 0 { break } validEndOffset = read . recordOffset } if err := fn ( * e , vp ) ; err != nil { if err == errStop { break } return 0 , errFile ( err , lf . path , "Iteration function" ) } } return validEndOffset , nil }
731	func ( vlog * valueLog ) sortedFids ( ) [ ] uint32 { toBeDeleted := make ( map [ uint32 ] struct { } ) for _ , fid := range vlog . filesToBeDeleted { toBeDeleted [ fid ] = struct { } { } } ret := make ( [ ] uint32 , 0 , len ( vlog . filesMap ) ) for fid := range vlog . filesMap { if _ , ok := toBeDeleted [ fid ] ; ! ok { ret = append ( ret , fid ) } } sort . Slice ( ret , func ( i , j int ) bool { return ret [ i ] < ret [ j ] } ) return ret }
732	func ( vlog * valueLog ) write ( reqs [ ] * request ) error { vlog . filesLock . RLock ( ) maxFid := atomic . LoadUint32 ( & vlog . maxFid ) curlf := vlog . filesMap [ maxFid ] vlog . filesLock . RUnlock ( ) var buf bytes . Buffer toDisk := func ( ) error { if buf . Len ( ) == 0 { return nil } vlog . elog . Printf ( "Flushing %d blocks of total size: %d" , len ( reqs ) , buf . Len ( ) ) n , err := curlf . fd . Write ( buf . Bytes ( ) ) if err != nil { return errors . Wrapf ( err , "Unable to write to value log file: %q" , curlf . path ) } buf . Reset ( ) y . NumWrites . Add ( 1 ) y . NumBytesWritten . Add ( int64 ( n ) ) vlog . elog . Printf ( "Done" ) atomic . AddUint32 ( & vlog . writableLogOffset , uint32 ( n ) ) if vlog . woffset ( ) > uint32 ( vlog . opt . ValueLogFileSize ) || vlog . numEntriesWritten > vlog . opt . ValueLogMaxEntries { var err error if err = curlf . doneWriting ( vlog . woffset ( ) ) ; err != nil { return err } newid := atomic . AddUint32 ( & vlog . maxFid , 1 ) y . AssertTruef ( newid > 0 , "newid has overflown uint32: %v" , newid ) newlf , err := vlog . createVlogFile ( newid ) if err != nil { return err } curlf = newlf } return nil } for i := range reqs { b := reqs [ i ] b . Ptrs = b . Ptrs [ : 0 ] for j := range b . Entries { e := b . Entries [ j ] var p valuePointer p . Fid = curlf . fid p . Offset = vlog . woffset ( ) + uint32 ( buf . Len ( ) ) plen , err := encodeEntry ( e , & buf ) if err != nil { return err } p . Len = uint32 ( plen ) b . Ptrs = append ( b . Ptrs , p ) } vlog . numEntriesWritten += uint32 ( len ( b . Entries ) ) writeNow := vlog . woffset ( ) + uint32 ( buf . Len ( ) ) > uint32 ( vlog . opt . ValueLogFileSize ) || vlog . numEntriesWritten > uint32 ( vlog . opt . ValueLogMaxEntries ) if writeNow { if err := toDisk ( ) ; err != nil { return err } } } return toDisk ( ) }
733	func ( vlog * valueLog ) populateDiscardStats ( ) error { discardStatsKey := y . KeyWithTs ( lfDiscardStatsKey , math . MaxUint64 ) vs , err := vlog . db . get ( discardStatsKey ) if err != nil { return err } if vs . Value == nil || len ( vs . Value ) == 0 { vlog . lfDiscardStats = & lfDiscardStats { m : make ( map [ uint32 ] int64 ) } return nil } var statsMap map [ uint32 ] int64 if err := json . Unmarshal ( vs . Value , & statsMap ) ; err != nil { return err } vlog . opt . Debugf ( "Value Log Discard stats: %v" , statsMap ) vlog . lfDiscardStats = & lfDiscardStats { m : statsMap } return nil }
734	func ( db * DB ) Backup ( w io . Writer , since uint64 ) ( uint64 , error ) { stream := db . NewStream ( ) stream . LogPrefix = "DB.Backup" return stream . Backup ( w , since ) }
735	func ( st * Stream ) ToList ( key [ ] byte , itr * Iterator ) ( * pb . KVList , error ) { list := & pb . KVList { } for ; itr . Valid ( ) ; itr . Next ( ) { item := itr . Item ( ) if item . IsDeletedOrExpired ( ) { break } if ! bytes . Equal ( key , item . Key ( ) ) { break } valCopy , err := item . ValueCopy ( nil ) if err != nil { return nil , err } kv := & pb . KV { Key : item . KeyCopy ( nil ) , Value : valCopy , UserMeta : [ ] byte { item . UserMeta ( ) } , Version : item . Version ( ) , ExpiresAt : item . ExpiresAt ( ) , } list . Kv = append ( list . Kv , kv ) if st . db . opt . NumVersionsToKeep == 1 { break } if item . DiscardEarlierVersions ( ) { break } } return list , nil }
736	func ( st * Stream ) produceRanges ( ctx context . Context ) { splits := st . db . KeySplits ( st . Prefix ) start := y . SafeCopy ( nil , st . Prefix ) for _ , key := range splits { st . rangeCh <- keyRange { left : start , right : y . SafeCopy ( nil , [ ] byte ( key ) ) } start = y . SafeCopy ( nil , [ ] byte ( key ) ) } st . rangeCh <- keyRange { left : start } close ( st . rangeCh ) }
737	func ( st * Stream ) produceKVs ( ctx context . Context ) error { var size int var txn * Txn if st . readTs > 0 { txn = st . db . NewTransactionAt ( st . readTs , false ) } else { txn = st . db . NewTransaction ( false ) } defer txn . Discard ( ) iterate := func ( kr keyRange ) error { iterOpts := DefaultIteratorOptions iterOpts . AllVersions = true iterOpts . Prefix = st . Prefix iterOpts . PrefetchValues = false itr := txn . NewIterator ( iterOpts ) defer itr . Close ( ) outList := new ( pb . KVList ) var prevKey [ ] byte for itr . Seek ( kr . left ) ; itr . Valid ( ) ; { item := itr . Item ( ) if bytes . Equal ( item . Key ( ) , prevKey ) { itr . Next ( ) continue } prevKey = append ( prevKey [ : 0 ] , item . Key ( ) ... ) if len ( kr . right ) > 0 && bytes . Compare ( item . Key ( ) , kr . right ) >= 0 { break } if st . ChooseKey != nil && ! st . ChooseKey ( item ) { continue } list , err := st . KeyToList ( item . KeyCopy ( nil ) , itr ) if err != nil { return err } if list == nil || len ( list . Kv ) == 0 { continue } outList . Kv = append ( outList . Kv , list . Kv ... ) size += list . Size ( ) if size >= pageSize { st . kvChan <- outList outList = new ( pb . KVList ) size = 0 } } if len ( outList . Kv ) > 0 { st . kvChan <- outList } return nil } for { select { case kr , ok := <- st . rangeCh : if ! ok { return nil } if err := iterate ( kr ) ; err != nil { return err } case <- ctx . Done ( ) : return ctx . Err ( ) } } }
738	func ( st * Stream ) Orchestrate ( ctx context . Context ) error { st . rangeCh = make ( chan keyRange , 3 ) st . kvChan = make ( chan * pb . KVList , 16 ) if st . KeyToList == nil { st . KeyToList = st . ToList } go st . produceRanges ( ctx ) errCh := make ( chan error , 1 ) var wg sync . WaitGroup for i := 0 ; i < st . NumGo ; i ++ { wg . Add ( 1 ) go func ( ) { defer wg . Done ( ) if err := st . produceKVs ( ctx ) ; err != nil { select { case errCh <- err : default : } } } ( ) } kvErr := make ( chan error , 1 ) go func ( ) { kvErr <- st . streamKVs ( ctx ) } ( ) wg . Wait ( ) close ( st . kvChan ) select { case err := <- errCh : return err default : } err := <- kvErr return err }
739	func ( db * DB ) NewStream ( ) * Stream { if db . opt . managedTxns { panic ( "This API can not be called in managed mode." ) } return db . newStream ( ) }
740	func ( db * DB ) NewStreamAt ( readTs uint64 ) * Stream { if ! db . opt . managedTxns { panic ( "This API can only be called in managed mode." ) } stream := db . newStream ( ) stream . readTs = readTs return stream }
741	func ( t * Table ) DecrRef ( ) error { newRef := atomic . AddInt32 ( & t . ref , - 1 ) if newRef == 0 { if t . loadingMode == options . MemoryMap { y . Munmap ( t . mmap ) } if err := t . fd . Truncate ( 0 ) ; err != nil { return err } filename := t . fd . Name ( ) if err := t . fd . Close ( ) ; err != nil { return err } if err := os . Remove ( filename ) ; err != nil { return err } } return nil }
742	func ParseFileID ( name string ) ( uint64 , bool ) { name = path . Base ( name ) if ! strings . HasSuffix ( name , fileSuffix ) { return 0 , false } name = strings . TrimSuffix ( name , fileSuffix ) id , err := strconv . Atoi ( name ) if err != nil { return 0 , false } y . AssertTrue ( id >= 0 ) return uint64 ( id ) , true }
743	func ( db * DB ) PrintHistogram ( keyPrefix [ ] byte ) { if db == nil { fmt . Println ( "\nCannot build histogram: DB is nil." ) \n } return histogram := db . buildHistogram ( keyPrefix ) fmt . Printf ( "Histogram of key sizes (in bytes)\n" ) \n histogram . keySizeHistogram . printHistogram ( ) }
744	func newSizeHistogram ( ) * sizeHistogram { keyBins := createHistogramBins ( 1 , 16 ) valueBins := createHistogramBins ( 1 , 30 ) return & sizeHistogram { keySizeHistogram : histogramData { bins : keyBins , countPerBin : make ( [ ] int64 , len ( keyBins ) + 1 ) , max : math . MinInt64 , min : math . MaxInt64 , sum : 0 , } , valueSizeHistogram : histogramData { bins : valueBins , countPerBin : make ( [ ] int64 , len ( valueBins ) + 1 ) , max : math . MinInt64 , min : math . MaxInt64 , sum : 0 , } , } }
745	func ( db * DB ) buildHistogram ( keyPrefix [ ] byte ) * sizeHistogram { txn := db . NewTransaction ( false ) defer txn . Discard ( ) itr := txn . NewIterator ( DefaultIteratorOptions ) defer itr . Close ( ) badgerHistogram := newSizeHistogram ( ) for itr . Seek ( keyPrefix ) ; itr . ValidForPrefix ( keyPrefix ) ; itr . Next ( ) { item := itr . Item ( ) badgerHistogram . keySizeHistogram . Update ( item . KeySize ( ) ) badgerHistogram . valueSizeHistogram . Update ( item . ValueSize ( ) ) } return badgerHistogram }
746	func ( histogram histogramData ) printHistogram ( ) { fmt . Printf ( "Total count: %d\n" , \n ) histogram . totalCount fmt . Printf ( "Min value: %d\n" , \n ) histogram . min fmt . Printf ( "Max value: %d\n" , \n ) histogram . max fmt . Printf ( "Mean: %.2f\n" , \n ) float64 ( histogram . sum ) / float64 ( histogram . totalCount ) }
747	func ( w * WaterMark ) Init ( closer * Closer ) { w . markCh = make ( chan mark , 100 ) w . elog = trace . NewEventLog ( "Watermark" , w . Name ) go w . process ( closer ) }
748	func ( w * WaterMark ) Begin ( index uint64 ) { atomic . StoreUint64 ( & w . lastIndex , index ) w . markCh <- mark { index : index , done : false } }
749	func ( w * WaterMark ) BeginMany ( indices [ ] uint64 ) { atomic . StoreUint64 ( & w . lastIndex , indices [ len ( indices ) - 1 ] ) w . markCh <- mark { index : 0 , indices : indices , done : false } }
750	func ( w * WaterMark ) Done ( index uint64 ) { w . markCh <- mark { index : index , done : true } }
751	func ( w * WaterMark ) DoneMany ( indices [ ] uint64 ) { w . markCh <- mark { index : 0 , indices : indices , done : true } }
752	func ( w * WaterMark ) SetDoneUntil ( val uint64 ) { atomic . StoreUint64 ( & w . doneUntil , val ) }
753	func ( w * WaterMark ) WaitForMark ( ctx context . Context , index uint64 ) error { if w . DoneUntil ( ) >= index { return nil } waitCh := make ( chan struct { } ) w . markCh <- mark { index : index , waiter : waitCh } select { case <- ctx . Done ( ) : return ctx . Err ( ) case <- waitCh : return nil } }
754	func ( h header ) Encode ( b [ ] byte ) { binary . BigEndian . PutUint16 ( b [ 0 : 2 ] , h . plen ) binary . BigEndian . PutUint16 ( b [ 2 : 4 ] , h . klen ) binary . BigEndian . PutUint16 ( b [ 4 : 6 ] , h . vlen ) binary . BigEndian . PutUint32 ( b [ 6 : 10 ] , h . prev ) }
755	func ( h * header ) Decode ( buf [ ] byte ) int { h . plen = binary . BigEndian . Uint16 ( buf [ 0 : 2 ] ) h . klen = binary . BigEndian . Uint16 ( buf [ 2 : 4 ] ) h . vlen = binary . BigEndian . Uint16 ( buf [ 4 : 6 ] ) h . prev = binary . BigEndian . Uint32 ( buf [ 6 : 10 ] ) return h . Size ( ) }
756	func NewTableBuilder ( ) * Builder { return & Builder { keyBuf : newBuffer ( 1 << 20 ) , buf : newBuffer ( 1 << 20 ) , prevOffset : math . MaxUint32 , } }
757	func ( b Builder ) keyDiff ( newKey [ ] byte ) [ ] byte { var i int for i = 0 ; i < len ( newKey ) && i < len ( b . baseKey ) ; i ++ { if newKey [ i ] != b . baseKey [ i ] { break } } return newKey [ i : ] }
758	func ( b * Builder ) Add ( key [ ] byte , value y . ValueStruct ) error { if b . counter >= restartInterval { b . finishBlock ( ) b . restarts = append ( b . restarts , uint32 ( b . buf . Len ( ) ) ) b . counter = 0 b . baseKey = [ ] byte { } b . baseOffset = uint32 ( b . buf . Len ( ) ) b . prevOffset = math . MaxUint32 } b . addHelper ( key , value ) return nil }
759	func ( b * Builder ) blockIndex ( ) [ ] byte { b . restarts = append ( b . restarts , uint32 ( b . buf . Len ( ) ) ) sz := 4 * len ( b . restarts ) + 4 out := make ( [ ] byte , sz ) buf := out for _ , r := range b . restarts { binary . BigEndian . PutUint32 ( buf [ : 4 ] , r ) buf = buf [ 4 : ] } binary . BigEndian . PutUint32 ( buf [ : 4 ] , uint32 ( len ( b . restarts ) ) ) return out }
760	func ( b * Builder ) Finish ( ) [ ] byte { bf := bbloom . New ( float64 ( b . keyCount ) , 0.01 ) var klen [ 2 ] byte key := make ( [ ] byte , 1024 ) for { if _ , err := b . keyBuf . Read ( klen [ : ] ) ; err == io . EOF { break } else if err != nil { y . Check ( err ) } kl := int ( binary . BigEndian . Uint16 ( klen [ : ] ) ) if cap ( key ) < kl { key = make ( [ ] byte , 2 * int ( kl ) ) } key = key [ : kl ] y . Check2 ( b . keyBuf . Read ( key ) ) bf . Add ( key ) } b . finishBlock ( ) index := b . blockIndex ( ) b . buf . Write ( index ) bdata := bf . JSONMarshal ( ) n , err := b . buf . Write ( bdata ) y . Check ( err ) var buf [ 4 ] byte binary . BigEndian . PutUint32 ( buf [ : ] , uint32 ( n ) ) b . buf . Write ( buf [ : ] ) return b . buf . Bytes ( ) }
761	func ( opt * Options ) Errorf ( format string , v ... interface { } ) { if opt . Logger == nil { return } opt . Logger . Errorf ( format , v ... ) }
762	func ( opt * Options ) Infof ( format string , v ... interface { } ) { if opt . Logger == nil { return } opt . Logger . Infof ( format , v ... ) }
763	func ( s * Skiplist ) DecrRef ( ) { newRef := atomic . AddInt32 ( & s . ref , - 1 ) if newRef > 0 { return } s . arena . reset ( ) s . arena = nil }
764	func NewSkiplist ( arenaSize int64 ) * Skiplist { arena := newArena ( arenaSize ) head := newNode ( arena , nil , y . ValueStruct { } , maxHeight ) return & Skiplist { height : 1 , head : head , arena : arena , ref : 1 , } }
765	func ( s * Skiplist ) Put ( key [ ] byte , v y . ValueStruct ) { listHeight := s . getHeight ( ) var prev [ maxHeight + 1 ] * node var next [ maxHeight + 1 ] * node prev [ listHeight ] = s . head next [ listHeight ] = nil for i := int ( listHeight ) - 1 ; i >= 0 ; i -- { prev [ i ] , next [ i ] = s . findSpliceForLevel ( key , prev [ i + 1 ] , i ) if prev [ i ] == next [ i ] { prev [ i ] . setValue ( s . arena , v ) return } } height := randomHeight ( ) x := newNode ( s . arena , key , v , height ) listHeight = s . getHeight ( ) for height > int ( listHeight ) { if atomic . CompareAndSwapInt32 ( & s . height , listHeight , int32 ( height ) ) { break } listHeight = s . getHeight ( ) } for i := 0 ; i < height ; i ++ { for { if prev [ i ] == nil { y . AssertTrue ( i > 1 ) prev [ i ] , next [ i ] = s . findSpliceForLevel ( key , s . head , i ) y . AssertTrue ( prev [ i ] != next [ i ] ) } nextOffset := s . arena . getNodeOffset ( next [ i ] ) x . tower [ i ] = nextOffset if prev [ i ] . casNextOffset ( i , nextOffset , s . arena . getNodeOffset ( x ) ) { break } prev [ i ] , next [ i ] = s . findSpliceForLevel ( key , prev [ i ] , i ) if prev [ i ] == next [ i ] { y . AssertTruef ( i == 0 , "Equality can happen only on base level: %d" , i ) prev [ i ] . setValue ( s . arena , v ) return } } } }
766	func ( s * Skiplist ) Get ( key [ ] byte ) y . ValueStruct { n , _ := s . findNear ( key , false , true ) if n == nil { return y . ValueStruct { } } nextKey := s . arena . getKey ( n . keyOffset , n . keySize ) if ! y . SameKey ( key , nextKey ) { return y . ValueStruct { } } valOffset , valSize := n . getValueOffset ( ) vs := s . arena . getVal ( valOffset , valSize ) vs . Version = y . ParseTs ( nextKey ) return vs }
767	func ( s * Iterator ) Key ( ) [ ] byte { return s . list . arena . getKey ( s . n . keyOffset , s . n . keySize ) }
768	func ( s * Iterator ) Value ( ) y . ValueStruct { valOffset , valSize := s . n . getValueOffset ( ) return s . list . arena . getVal ( valOffset , valSize ) }
769	func ( s * Iterator ) Next ( ) { y . AssertTrue ( s . Valid ( ) ) s . n = s . list . getNext ( s . n , 0 ) }
770	func ( s * Iterator ) Prev ( ) { y . AssertTrue ( s . Valid ( ) ) s . n , _ = s . list . findNear ( s . Key ( ) , true , false ) }
771	func ( s * Iterator ) Seek ( target [ ] byte ) { s . n , _ = s . list . findNear ( target , false , true ) }
772	func ( s * Iterator ) SeekForPrev ( target [ ] byte ) { s . n , _ = s . list . findNear ( target , true , true ) }
773	func ( s * Skiplist ) NewUniIterator ( reversed bool ) * UniIterator { return & UniIterator { iter : s . NewIterator ( ) , reversed : reversed , } }
774	func ( s * UniIterator ) Next ( ) { if ! s . reversed { s . iter . Next ( ) } else { s . iter . Prev ( ) } }
775	func ( s * UniIterator ) Seek ( key [ ] byte ) { if ! s . reversed { s . iter . Seek ( key ) } else { s . iter . SeekForPrev ( key ) } }
776	func ( m * Manifest ) asChanges ( ) [ ] * pb . ManifestChange { changes := make ( [ ] * pb . ManifestChange , 0 , len ( m . Tables ) ) for id , tm := range m . Tables { changes = append ( changes , newCreateChange ( id , int ( tm . Level ) , tm . Checksum ) ) } return changes }
777	func ( mf * manifestFile ) rewrite ( ) error { if err := mf . fp . Close ( ) ; err != nil { return err } fp , netCreations , err := helpRewrite ( mf . directory , & mf . manifest ) if err != nil { return err } mf . fp = fp mf . manifest . Creations = netCreations mf . manifest . Deletions = 0 return nil }
778	func ( s * levelHandler ) validate ( ) error { if s . level == 0 { return nil } s . RLock ( ) defer s . RUnlock ( ) numTables := len ( s . tables ) for j := 1 ; j < numTables ; j ++ { if j >= len ( s . tables ) { return errors . Errorf ( "Level %d, j=%d numTables=%d" , s . level , j , numTables ) } if y . CompareKeys ( s . tables [ j - 1 ] . Biggest ( ) , s . tables [ j ] . Smallest ( ) ) >= 0 { return errors . Errorf ( "Inter: Biggest(j-1) \n%s\n vs Smallest(j): \n%s\n: level=%d j=%d numTables=%d" , \n , \n , \n , \n , hex . Dump ( s . tables [ j - 1 ] . Biggest ( ) ) ) } hex . Dump ( s . tables [ j ] . Smallest ( ) ) } s . level }
779	func acquireDirectoryLock ( dirPath string , pidFileName string , readOnly bool ) ( * directoryLockGuard , error ) { if readOnly { return nil , ErrWindowsNotSupported } absLockFilePath , err := filepath . Abs ( filepath . Join ( dirPath , pidFileName ) ) if err != nil { return nil , errors . Wrap ( err , "Cannot get absolute path for pid lock file" ) } h , err := syscall . CreateFile ( syscall . StringToUTF16Ptr ( absLockFilePath ) , 0 , 0 , nil , syscall . OPEN_ALWAYS , uint32 ( FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE ) , 0 ) if err != nil { return nil , errors . Wrapf ( err , "Cannot create lock file %q. Another process is using this Badger database" , absLockFilePath ) } return & directoryLockGuard { h : h , path : absLockFilePath } , nil }
780	func ( g * directoryLockGuard ) release ( ) error { g . path = "" return syscall . CloseHandle ( g . h ) }
781	func AssertTruef ( b bool , format string , args ... interface { } ) { if ! b { log . Fatalf ( "%+v" , errors . Errorf ( format , args ... ) ) } }
782	func Wrapf ( err error , format string , args ... interface { } ) error { if ! debugMode { if err == nil { return nil } return fmt . Errorf ( format + " error: %+v" , append ( args , err ) ... ) } return errors . Wrapf ( err , format , args ... ) }
783	func ( s * levelHandler ) initTables ( tables [ ] * table . Table ) { s . Lock ( ) defer s . Unlock ( ) s . tables = tables s . totalSize = 0 for _ , t := range tables { s . totalSize += t . Size ( ) } if s . level == 0 { sort . Slice ( s . tables , func ( i , j int ) bool { return s . tables [ i ] . ID ( ) < s . tables [ j ] . ID ( ) } ) } else { sort . Slice ( s . tables , func ( i , j int ) bool { return y . CompareKeys ( s . tables [ i ] . Smallest ( ) , s . tables [ j ] . Smallest ( ) ) < 0 } ) } }
784	func ( s * levelHandler ) deleteTables ( toDel [ ] * table . Table ) error { s . Lock ( ) toDelMap := make ( map [ uint64 ] struct { } ) for _ , t := range toDel { toDelMap [ t . ID ( ) ] = struct { } { } } var newTables [ ] * table . Table for _ , t := range s . tables { _ , found := toDelMap [ t . ID ( ) ] if ! found { newTables = append ( newTables , t ) continue } s . totalSize -= t . Size ( ) } s . tables = newTables s . Unlock ( ) return decrRefs ( toDel ) }
785	func ( s * levelHandler ) tryAddLevel0Table ( t * table . Table ) bool { y . AssertTrue ( s . level == 0 ) s . Lock ( ) defer s . Unlock ( ) if len ( s . tables ) >= s . db . opt . NumLevelZeroTablesStall { return false } s . tables = append ( s . tables , t ) t . IncrRef ( ) s . totalSize += t . Size ( ) return true }
786	func ( s * levelHandler ) getTableForKey ( key [ ] byte ) ( [ ] * table . Table , func ( ) error ) { s . RLock ( ) defer s . RUnlock ( ) if s . level == 0 { out := make ( [ ] * table . Table , 0 , len ( s . tables ) ) for i := len ( s . tables ) - 1 ; i >= 0 ; i -- { out = append ( out , s . tables [ i ] ) s . tables [ i ] . IncrRef ( ) } return out , func ( ) error { for _ , t := range out { if err := t . DecrRef ( ) ; err != nil { return err } } return nil } } idx := sort . Search ( len ( s . tables ) , func ( i int ) bool { return y . CompareKeys ( s . tables [ i ] . Biggest ( ) , key ) >= 0 } ) if idx >= len ( s . tables ) { return nil , func ( ) error { return nil } } tbl := s . tables [ idx ] tbl . IncrRef ( ) return [ ] * table . Table { tbl } , tbl . DecrRef }
787	func ( s * levelHandler ) get ( key [ ] byte ) ( y . ValueStruct , error ) { tables , decr := s . getTableForKey ( key ) keyNoTs := y . ParseKey ( key ) var maxVs y . ValueStruct for _ , th := range tables { if th . DoesNotHave ( keyNoTs ) { y . NumLSMBloomHits . Add ( s . strLevel , 1 ) continue } it := th . NewIterator ( false ) defer it . Close ( ) y . NumLSMGets . Add ( s . strLevel , 1 ) it . Seek ( key ) if ! it . Valid ( ) { continue } if y . SameKey ( key , it . Key ( ) ) { if version := y . ParseTs ( it . Key ( ) ) ; maxVs . Version < version { maxVs = it . Value ( ) maxVs . Version = version } } } return maxVs , decr ( ) }
788	func ( s * levelHandler ) overlappingTables ( _ levelHandlerRLocked , kr keyRange ) ( int , int ) { if len ( kr . left ) == 0 || len ( kr . right ) == 0 { return 0 , 0 } left := sort . Search ( len ( s . tables ) , func ( i int ) bool { return y . CompareKeys ( kr . left , s . tables [ i ] . Biggest ( ) ) <= 0 } ) right := sort . Search ( len ( s . tables ) , func ( i int ) bool { return y . CompareKeys ( kr . right , s . tables [ i ] . Smallest ( ) ) < 0 } ) return left , right }
789	func ( item * Item ) String ( ) string { return fmt . Sprintf ( "key=%q, version=%d, meta=%x" , item . Key ( ) , item . Version ( ) , item . meta ) }
790	func ( item * Item ) KeyCopy ( dst [ ] byte ) [ ] byte { return y . SafeCopy ( dst , item . key ) }
791	func ( item * Item ) ValueSize ( ) int64 { if ! item . hasValue ( ) { return 0 } if ( item . meta & bitValuePointer ) == 0 { return int64 ( len ( item . vptr ) ) } var vp valuePointer vp . Decode ( item . vptr ) klen := int64 ( len ( item . key ) + 8 ) return int64 ( vp . Len ) - klen - headerBufSize - crc32 . Size }
792	func ( txn * Txn ) NewKeyIterator ( key [ ] byte , opt IteratorOptions ) * Iterator { if len ( opt . Prefix ) > 0 { panic ( "opt.Prefix should be nil for NewKeyIterator." ) } opt . Prefix = key opt . prefixIsKey = true return txn . NewIterator ( opt ) }
793	func ( it * Iterator ) Valid ( ) bool { if it . item == nil { return false } return bytes . HasPrefix ( it . item . key , it . opt . Prefix ) }
794	func ( it * Iterator ) ValidForPrefix ( prefix [ ] byte ) bool { return it . Valid ( ) && bytes . HasPrefix ( it . item . key , prefix ) }
795	func ( it * Iterator ) Close ( ) { if it . closed { return } it . closed = true it . iitr . Close ( ) waitFor := func ( l list ) { item := l . pop ( ) for item != nil { item . wg . Wait ( ) item = l . pop ( ) } } waitFor ( it . waste ) waitFor ( it . data ) _ = it . txn . db . vlog . decrIteratorCount ( ) atomic . AddInt32 ( & it . txn . numIterators , - 1 ) }
796	func ( it * Iterator ) parseItem ( ) bool { mi := it . iitr key := mi . Key ( ) setItem := func ( item * Item ) { if it . item == nil { it . item = item } else { it . data . push ( item ) } } if ! it . opt . internalAccess && bytes . HasPrefix ( key , badgerPrefix ) { mi . Next ( ) return false } version := y . ParseTs ( key ) if version > it . readTs { mi . Next ( ) return false } if it . opt . AllVersions { item := it . newItem ( ) it . fill ( item ) setItem ( item ) mi . Next ( ) return true } if ! it . opt . Reverse { if y . SameKey ( it . lastKey , key ) { mi . Next ( ) return false } it . lastKey = y . SafeCopy ( it . lastKey , mi . Key ( ) ) } FILL : vs := mi . Value ( ) if isDeletedOrExpired ( vs . Meta , vs . ExpiresAt ) { mi . Next ( ) return false } item := it . newItem ( ) it . fill ( item ) mi . Next ( ) if ! it . opt . Reverse || ! mi . Valid ( ) { setItem ( item ) return true } nextTs := y . ParseTs ( mi . Key ( ) ) mik := y . ParseKey ( mi . Key ( ) ) if nextTs <= it . readTs && bytes . Equal ( mik , item . key ) { goto FILL } setItem ( item ) return true }
797	func ( it * Iterator ) Seek ( key [ ] byte ) { for i := it . data . pop ( ) ; i != nil ; i = it . data . pop ( ) { i . wg . Wait ( ) it . waste . push ( i ) } it . lastKey = it . lastKey [ : 0 ] if len ( key ) == 0 { key = it . opt . Prefix } if len ( key ) == 0 { it . iitr . Rewind ( ) it . prefetch ( ) return } if ! it . opt . Reverse { key = y . KeyWithTs ( key , it . txn . readTs ) } else { key = y . KeyWithTs ( key , 0 ) } it . iitr . Seek ( key ) it . prefetch ( ) }
798	func ( db * DB ) GetMergeOperator ( key [ ] byte , f MergeFunc , dur time . Duration ) * MergeOperator { op := & MergeOperator { f : f , db : db , key : key , closer : y . NewCloser ( 1 ) , } go op . runCompactions ( dur ) return op }
799	func ( op * MergeOperator ) Get ( ) ( [ ] byte , error ) { op . RLock ( ) defer op . RUnlock ( ) var existing [ ] byte err := op . db . View ( func ( txn * Txn ) ( err error ) { existing , err = op . iterateAndMerge ( txn ) return err } ) if err == errNoMerge { return existing , nil } return existing , err }
800	func ( cs * compactStatus ) compareAndAdd ( _ thisAndNextLevelRLocked , cd compactDef ) bool { cs . Lock ( ) defer cs . Unlock ( ) level := cd . thisLevel . level y . AssertTruef ( level < len ( cs . levels ) - 1 , "Got level %d. Max levels: %d" , level , len ( cs . levels ) ) thisLevel := cs . levels [ level ] nextLevel := cs . levels [ level + 1 ] if thisLevel . overlapsWith ( cd . thisRange ) { return false } if nextLevel . overlapsWith ( cd . nextRange ) { return false } thisLevel . ranges = append ( thisLevel . ranges , cd . thisRange ) nextLevel . ranges = append ( nextLevel . ranges , cd . nextRange ) thisLevel . delSize += cd . thisSize return true }
801	func newArena ( n int64 ) * Arena { out := & Arena { n : 1 , buf : make ( [ ] byte , n ) , } return out }
802	func ( s * Arena ) putNode ( height int ) uint32 { unusedSize := ( maxHeight - height ) * offsetSize l := uint32 ( MaxNodeSize - unusedSize + nodeAlign ) n := atomic . AddUint32 ( & s . n , l ) y . AssertTruef ( int ( n ) <= len ( s . buf ) , "Arena too small, toWrite:%d newTotal:%d limit:%d" , l , n , len ( s . buf ) ) m := ( n - l + uint32 ( nodeAlign ) ) & ^ uint32 ( nodeAlign ) return m }
803	func ( s * Arena ) getNode ( offset uint32 ) * node { if offset == 0 { return nil } return ( * node ) ( unsafe . Pointer ( & s . buf [ offset ] ) ) }
804	func ( s * Arena ) getKey ( offset uint32 , size uint16 ) [ ] byte { return s . buf [ offset : offset + uint32 ( size ) ] }
805	func ( s * Arena ) getVal ( offset uint32 , size uint16 ) ( ret y . ValueStruct ) { ret . Decode ( s . buf [ offset : offset + uint32 ( size ) ] ) return }
806	func ( s * Arena ) getNodeOffset ( nd * node ) uint32 { if nd == nil { return 0 } return uint32 ( uintptr ( unsafe . Pointer ( nd ) ) - uintptr ( unsafe . Pointer ( & s . buf [ 0 ] ) ) ) }
807	func init ( ) { NumReads = expvar . NewInt ( "badger_disk_reads_total" ) NumWrites = expvar . NewInt ( "badger_disk_writes_total" ) NumBytesRead = expvar . NewInt ( "badger_read_bytes" ) NumBytesWritten = expvar . NewInt ( "badger_written_bytes" ) NumLSMGets = expvar . NewMap ( "badger_lsm_level_gets_total" ) NumLSMBloomHits = expvar . NewMap ( "badger_lsm_bloom_hits_total" ) NumGets = expvar . NewInt ( "badger_gets_total" ) NumPuts = expvar . NewInt ( "badger_puts_total" ) NumBlockedPuts = expvar . NewInt ( "badger_blocked_puts_total" ) NumMemtableGets = expvar . NewInt ( "badger_memtable_gets_total" ) LSMSize = expvar . NewMap ( "badger_lsm_size_bytes" ) VlogSize = expvar . NewMap ( "badger_vlog_size_bytes" ) PendingWrites = expvar . NewMap ( "badger_pending_writes_total" ) }
808	func revertToManifest ( kv * DB , mf * Manifest , idMap map [ uint64 ] struct { } ) error { for id := range mf . Tables { if _ , ok := idMap [ id ] ; ! ok { return fmt . Errorf ( "file does not exist for table %d" , id ) } } for id := range idMap { if _ , ok := mf . Tables [ id ] ; ! ok { kv . elog . Printf ( "Table file %d not referenced in MANIFEST\n" , \n ) id filename := table . NewFilename ( id , kv . opt . Dir ) } } if err := os . Remove ( filename ) ; err != nil { return y . Wrapf ( err , "While removing table %d" , id ) } }
809	func ( s * levelsController ) dropTree ( ) ( int , error ) { var all [ ] * table . Table for _ , l := range s . levels { l . RLock ( ) all = append ( all , l . tables ... ) l . RUnlock ( ) } if len ( all ) == 0 { return 0 , nil } changes := [ ] * pb . ManifestChange { } for _ , table := range all { changes = append ( changes , newDeleteChange ( table . ID ( ) ) ) } changeSet := pb . ManifestChangeSet { Changes : changes } if err := s . kv . manifest . addChanges ( changeSet . Changes ) ; err != nil { return 0 , err } for _ , l := range s . levels { l . Lock ( ) l . totalSize = 0 l . tables = l . tables [ : 0 ] l . Unlock ( ) } for _ , table := range all { if err := table . DecrRef ( ) ; err != nil { return 0 , err } } return len ( all ) , nil }
810	func ( s * levelsController ) dropPrefix ( prefix [ ] byte ) error { opt := s . kv . opt for _ , l := range s . levels { l . RLock ( ) if l . level == 0 { size := len ( l . tables ) l . RUnlock ( ) if size > 0 { cp := compactionPriority { level : 0 , score : 1.74 , dropPrefix : prefix , } if err := s . doCompact ( cp ) ; err != nil { opt . Warningf ( "While compacting level 0: %v" , err ) return nil } } continue } var tables [ ] * table . Table for _ , table := range l . tables { var absent bool switch { case bytes . HasPrefix ( table . Smallest ( ) , prefix ) : case bytes . HasPrefix ( table . Biggest ( ) , prefix ) : case bytes . Compare ( prefix , table . Smallest ( ) ) > 0 && bytes . Compare ( prefix , table . Biggest ( ) ) < 0 : default : absent = true } if ! absent { tables = append ( tables , table ) } } l . RUnlock ( ) if len ( tables ) == 0 { continue } cd := compactDef { elog : trace . New ( fmt . Sprintf ( "Badger.L%d" , l . level ) , "Compact" ) , thisLevel : l , nextLevel : l , top : [ ] * table . Table { } , bot : tables , dropPrefix : prefix , } if err := s . runCompactDef ( l . level , cd ) ; err != nil { opt . Warningf ( "While running compact def: %+v. Error: %v" , cd , err ) return err } } return nil }
811	func ( s * levelsController ) isLevel0Compactable ( ) bool { return s . levels [ 0 ] . numTables ( ) >= s . kv . opt . NumLevelZeroTables }
812	func ( s * levelsController ) doCompact ( p compactionPriority ) error { l := p . level y . AssertTrue ( l + 1 < s . kv . opt . MaxLevels ) cd := compactDef { elog : trace . New ( fmt . Sprintf ( "Badger.L%d" , l ) , "Compact" ) , thisLevel : s . levels [ l ] , nextLevel : s . levels [ l + 1 ] , dropPrefix : p . dropPrefix , } cd . elog . SetMaxEvents ( 100 ) defer cd . elog . Finish ( ) s . kv . opt . Infof ( "Got compaction priority: %+v" , p ) if l == 0 { if ! s . fillTablesL0 ( & cd ) { return errFillTables } } else { if ! s . fillTables ( & cd ) { return errFillTables } } defer s . cstatus . delete ( cd ) s . kv . opt . Infof ( "Running for level: %d\n" , \n ) cd . thisLevel . level s . cstatus . toLog ( cd . elog ) if err := s . runCompactDef ( l , cd ) ; err != nil { s . kv . opt . Warningf ( "LOG Compact FAILED with error: %+v: %+v" , err , cd ) return err } s . cstatus . toLog ( cd . elog ) s . kv . opt . Infof ( "Compaction for level: %d DONE" , cd . thisLevel . level ) }
813	func ( s * levelsController ) get ( key [ ] byte , maxVs * y . ValueStruct ) ( y . ValueStruct , error ) { version := y . ParseTs ( key ) for _ , h := range s . levels { vs , err := h . get ( key ) if err != nil { return y . ValueStruct { } , errors . Wrapf ( err , "get key: %q" , key ) } if vs . Value == nil && vs . Meta == 0 { continue } if maxVs == nil || vs . Version == version { return vs , nil } if maxVs . Version < vs . Version { * maxVs = vs } } if maxVs != nil { return * maxVs , nil } return y . ValueStruct { } , nil }
814	func seekTotal ( txn * badger . Txn ) ( [ ] account , error ) { expected := uint64 ( numAccounts ) * uint64 ( initialBal ) var accounts [ ] account var total uint64 for i := 0 ; i < numAccounts ; i ++ { item , err := txn . Get ( key ( i ) ) if err != nil { log . Printf ( "Error for account: %d. err=%v. key=%q\n" , \n , i , err ) key ( i ) } return accounts , err val , err := item . ValueCopy ( nil ) if err != nil { return accounts , err } acc := account { Id : i , Bal : toUint64 ( val ) , } accounts = append ( accounts , acc ) } total += acc . Bal if total != expected { log . Printf ( "Balance did NOT match up. Expected: %d. Received: %d" , expected , total ) atomic . AddInt32 ( & stopAll , 1 ) return accounts , errFailure } }
815	func findFirstInvalidTxn ( db * badger . DB , lowTs , highTs uint64 ) uint64 { checkAt := func ( ts uint64 ) error { txn := db . NewTransactionAt ( ts , false ) _ , err := seekTotal ( txn ) txn . Discard ( ) return err } if highTs - lowTs < 1 { log . Printf ( "Checking at lowTs: %d\n" , \n ) lowTs err := checkAt ( lowTs ) if err == errFailure { fmt . Printf ( "Violation at ts: %d\n" , \n ) lowTs } else return lowTs if err != nil { log . Printf ( "Error at lowTs: %d. Err=%v\n" , \n , lowTs ) err } } return 0 fmt . Printf ( "No violation found at ts: %d\n" , \n ) lowTs return 0 midTs := ( lowTs + highTs ) / 2 log . Println ( ) }
816	func ( m * InmemSnapshotStore ) Create ( version SnapshotVersion , index , term uint64 , configuration Configuration , configurationIndex uint64 , trans Transport ) ( SnapshotSink , error ) { if version != 1 { return nil , fmt . Errorf ( "unsupported snapshot version %d" , version ) } name := snapshotName ( term , index ) m . Lock ( ) defer m . Unlock ( ) sink := & InmemSnapshotSink { meta : SnapshotMeta { Version : version , ID : name , Index : index , Term : term , Peers : encodePeers ( configuration , trans ) , Configuration : configuration , ConfigurationIndex : configurationIndex , } , contents : & bytes . Buffer { } , } m . hasSnapshot = true m . latest = sink return sink , nil }
817	func ( m * InmemSnapshotStore ) List ( ) ( [ ] * SnapshotMeta , error ) { m . RLock ( ) defer m . RUnlock ( ) if ! m . hasSnapshot { return [ ] * SnapshotMeta { } , nil } return [ ] * SnapshotMeta { & m . latest . meta } , nil }
818	func ( m * InmemSnapshotStore ) Open ( id string ) ( * SnapshotMeta , io . ReadCloser , error ) { m . RLock ( ) defer m . RUnlock ( ) if m . latest . meta . ID != id { return nil , nil , fmt . Errorf ( "[ERR] snapshot: failed to open snapshot id: %s" , id ) } return & m . latest . meta , ioutil . NopCloser ( m . latest . contents ) , nil }
819	func ( s * InmemSnapshotSink ) Write ( p [ ] byte ) ( n int , err error ) { written , err := io . Copy ( s . contents , bytes . NewReader ( p ) ) s . meta . Size += written return int ( written ) , err }
820	func NewFileSnapshotStoreWithLogger ( base string , retain int , logger * log . Logger ) ( * FileSnapshotStore , error ) { if retain < 1 { return nil , fmt . Errorf ( "must retain at least one snapshot" ) } if logger == nil { logger = log . New ( os . Stderr , "" , log . LstdFlags ) } path := filepath . Join ( base , snapPath ) if err := os . MkdirAll ( path , 0755 ) ; err != nil && ! os . IsExist ( err ) { return nil , fmt . Errorf ( "snapshot path not accessible: %v" , err ) } store := & FileSnapshotStore { path : path , retain : retain , logger : logger , } if err := store . testPermissions ( ) ; err != nil { return nil , fmt . Errorf ( "permissions test failed: %v" , err ) } return store , nil }
821	func NewFileSnapshotStore ( base string , retain int , logOutput io . Writer ) ( * FileSnapshotStore , error ) { if logOutput == nil { logOutput = os . Stderr } return NewFileSnapshotStoreWithLogger ( base , retain , log . New ( logOutput , "" , log . LstdFlags ) ) }
822	func snapshotName ( term , index uint64 ) string { now := time . Now ( ) msec := now . UnixNano ( ) / int64 ( time . Millisecond ) return fmt . Sprintf ( "%d-%d-%d" , term , index , msec ) }
823	func ( f * FileSnapshotStore ) Create ( version SnapshotVersion , index , term uint64 , configuration Configuration , configurationIndex uint64 , trans Transport ) ( SnapshotSink , error ) { if version != 1 { return nil , fmt . Errorf ( "unsupported snapshot version %d" , version ) } name := snapshotName ( term , index ) path := filepath . Join ( f . path , name + tmpSuffix ) f . logger . Printf ( "[INFO] snapshot: Creating new snapshot at %s" , path ) if err := os . MkdirAll ( path , 0755 ) ; err != nil { f . logger . Printf ( "[ERR] snapshot: Failed to make snapshot directory: %v" , err ) return nil , err } sink := & FileSnapshotSink { store : f , logger : f . logger , dir : path , parentDir : f . path , meta : fileSnapshotMeta { SnapshotMeta : SnapshotMeta { Version : version , ID : name , Index : index , Term : term , Peers : encodePeers ( configuration , trans ) , Configuration : configuration , ConfigurationIndex : configurationIndex , } , CRC : nil , } , } if err := sink . writeMeta ( ) ; err != nil { f . logger . Printf ( "[ERR] snapshot: Failed to write metadata: %v" , err ) return nil , err } statePath := filepath . Join ( path , stateFilePath ) fh , err := os . Create ( statePath ) if err != nil { f . logger . Printf ( "[ERR] snapshot: Failed to create state file: %v" , err ) return nil , err } sink . stateFile = fh sink . stateHash = crc64 . New ( crc64 . MakeTable ( crc64 . ECMA ) ) multi := io . MultiWriter ( sink . stateFile , sink . stateHash ) sink . buffered = bufio . NewWriter ( multi ) return sink , nil }
824	func ( f * FileSnapshotStore ) List ( ) ( [ ] * SnapshotMeta , error ) { snapshots , err := f . getSnapshots ( ) if err != nil { f . logger . Printf ( "[ERR] snapshot: Failed to get snapshots: %v" , err ) return nil , err } var snapMeta [ ] * SnapshotMeta for _ , meta := range snapshots { snapMeta = append ( snapMeta , & meta . SnapshotMeta ) if len ( snapMeta ) == f . retain { break } } return snapMeta , nil }
825	func ( f * FileSnapshotStore ) getSnapshots ( ) ( [ ] * fileSnapshotMeta , error ) { snapshots , err := ioutil . ReadDir ( f . path ) if err != nil { f . logger . Printf ( "[ERR] snapshot: Failed to scan snapshot dir: %v" , err ) return nil , err } var snapMeta [ ] * fileSnapshotMeta for _ , snap := range snapshots { if ! snap . IsDir ( ) { continue } dirName := snap . Name ( ) if strings . HasSuffix ( dirName , tmpSuffix ) { f . logger . Printf ( "[WARN] snapshot: Found temporary snapshot: %v" , dirName ) continue } meta , err := f . readMeta ( dirName ) if err != nil { f . logger . Printf ( "[WARN] snapshot: Failed to read metadata for %v: %v" , dirName , err ) continue } if meta . Version < SnapshotVersionMin || meta . Version > SnapshotVersionMax { f . logger . Printf ( "[WARN] snapshot: Snapshot version for %v not supported: %d" , dirName , meta . Version ) continue } snapMeta = append ( snapMeta , meta ) } sort . Sort ( sort . Reverse ( snapMetaSlice ( snapMeta ) ) ) return snapMeta , nil }
826	func ( f * FileSnapshotStore ) readMeta ( name string ) ( * fileSnapshotMeta , error ) { metaPath := filepath . Join ( f . path , name , metaFilePath ) fh , err := os . Open ( metaPath ) if err != nil { return nil , err } defer fh . Close ( ) buffered := bufio . NewReader ( fh ) meta := & fileSnapshotMeta { } dec := json . NewDecoder ( buffered ) if err := dec . Decode ( meta ) ; err != nil { return nil , err } return meta , nil }
827	func ( f * FileSnapshotStore ) Open ( id string ) ( * SnapshotMeta , io . ReadCloser , error ) { meta , err := f . readMeta ( id ) if err != nil { f . logger . Printf ( "[ERR] snapshot: Failed to get meta data to open snapshot: %v" , err ) return nil , nil , err } statePath := filepath . Join ( f . path , id , stateFilePath ) fh , err := os . Open ( statePath ) if err != nil { f . logger . Printf ( "[ERR] snapshot: Failed to open state file: %v" , err ) return nil , nil , err } stateHash := crc64 . New ( crc64 . MakeTable ( crc64 . ECMA ) ) _ , err = io . Copy ( stateHash , fh ) if err != nil { f . logger . Printf ( "[ERR] snapshot: Failed to read state file: %v" , err ) fh . Close ( ) return nil , nil , err } computed := stateHash . Sum ( nil ) if bytes . Compare ( meta . CRC , computed ) != 0 { f . logger . Printf ( "[ERR] snapshot: CRC checksum failed (stored: %v computed: %v)" , meta . CRC , computed ) fh . Close ( ) return nil , nil , fmt . Errorf ( "CRC mismatch" ) } if _ , err := fh . Seek ( 0 , 0 ) ; err != nil { f . logger . Printf ( "[ERR] snapshot: State file seek failed: %v" , err ) fh . Close ( ) return nil , nil , err } buffered := & bufferedFile { bh : bufio . NewReader ( fh ) , fh : fh , } return & meta . SnapshotMeta , buffered , nil }
828	func ( f * FileSnapshotStore ) ReapSnapshots ( ) error { snapshots , err := f . getSnapshots ( ) if err != nil { f . logger . Printf ( "[ERR] snapshot: Failed to get snapshots: %v" , err ) return err } for i := f . retain ; i < len ( snapshots ) ; i ++ { path := filepath . Join ( f . path , snapshots [ i ] . ID ) f . logger . Printf ( "[INFO] snapshot: reaping snapshot %v" , path ) if err := os . RemoveAll ( path ) ; err != nil { f . logger . Printf ( "[ERR] snapshot: Failed to reap snapshot %v: %v" , path , err ) return err } } return nil }
829	func ( s * FileSnapshotSink ) Write ( b [ ] byte ) ( int , error ) { return s . buffered . Write ( b ) }
830	func ( s * FileSnapshotSink ) Close ( ) error { if s . closed { return nil } s . closed = true if err := s . finalize ( ) ; err != nil { s . logger . Printf ( "[ERR] snapshot: Failed to finalize snapshot: %v" , err ) if delErr := os . RemoveAll ( s . dir ) ; delErr != nil { s . logger . Printf ( "[ERR] snapshot: Failed to delete temporary snapshot directory at path %v: %v" , s . dir , delErr ) return delErr } return err } if err := s . writeMeta ( ) ; err != nil { s . logger . Printf ( "[ERR] snapshot: Failed to write metadata: %v" , err ) return err } newPath := strings . TrimSuffix ( s . dir , tmpSuffix ) if err := os . Rename ( s . dir , newPath ) ; err != nil { s . logger . Printf ( "[ERR] snapshot: Failed to move snapshot into place: %v" , err ) return err } if runtime . GOOS != "windows" { parentFH , err := os . Open ( s . parentDir ) defer parentFH . Close ( ) if err != nil { s . logger . Printf ( "[ERR] snapshot: Failed to open snapshot parent directory %v, error: %v" , s . parentDir , err ) return err } if err = parentFH . Sync ( ) ; err != nil { s . logger . Printf ( "[ERR] snapshot: Failed syncing parent directory %v, error: %v" , s . parentDir , err ) return err } } if err := s . store . ReapSnapshots ( ) ; err != nil { return err } return nil }
831	func ( s * FileSnapshotSink ) Cancel ( ) error { if s . closed { return nil } s . closed = true if err := s . finalize ( ) ; err != nil { s . logger . Printf ( "[ERR] snapshot: Failed to finalize snapshot: %v" , err ) return err } return os . RemoveAll ( s . dir ) }
832	func ( s * FileSnapshotSink ) finalize ( ) error { if err := s . buffered . Flush ( ) ; err != nil { return err } if err := s . stateFile . Sync ( ) ; err != nil { return err } stat , statErr := s . stateFile . Stat ( ) if err := s . stateFile . Close ( ) ; err != nil { return err } if statErr != nil { return statErr } s . meta . Size = stat . Size ( ) s . meta . CRC = s . stateHash . Sum ( nil ) return nil }
833	func ( s * FileSnapshotSink ) writeMeta ( ) error { metaPath := filepath . Join ( s . dir , metaFilePath ) fh , err := os . Create ( metaPath ) if err != nil { return err } defer fh . Close ( ) buffered := bufio . NewWriter ( fh ) enc := json . NewEncoder ( buffered ) if err := enc . Encode ( & s . meta ) ; err != nil { return err } if err = buffered . Flush ( ) ; err != nil { return err } if err = fh . Sync ( ) ; err != nil { return err } return nil }
834	func NewNetworkTransportWithConfig ( config * NetworkTransportConfig , ) * NetworkTransport { if config . Logger == nil { config . Logger = log . New ( os . Stderr , "" , log . LstdFlags ) } trans := & NetworkTransport { connPool : make ( map [ ServerAddress ] [ ] * netConn ) , consumeCh : make ( chan RPC ) , logger : config . Logger , maxPool : config . MaxPool , shutdownCh : make ( chan struct { } ) , stream : config . Stream , timeout : config . Timeout , TimeoutScale : DefaultTimeoutScale , serverAddressProvider : config . ServerAddressProvider , } trans . setupStreamContext ( ) go trans . listen ( ) return trans }
835	func ( n * NetworkTransport ) setupStreamContext ( ) { ctx , cancel := context . WithCancel ( context . Background ( ) ) n . streamCtx = ctx n . streamCancel = cancel }
836	func ( n * NetworkTransport ) getStreamContext ( ) context . Context { n . streamCtxLock . RLock ( ) defer n . streamCtxLock . RUnlock ( ) return n . streamCtx }
837	func ( n * NetworkTransport ) SetHeartbeatHandler ( cb func ( rpc RPC ) ) { n . heartbeatFnLock . Lock ( ) defer n . heartbeatFnLock . Unlock ( ) n . heartbeatFn = cb }
838	func ( n * NetworkTransport ) CloseStreams ( ) { n . connPoolLock . Lock ( ) defer n . connPoolLock . Unlock ( ) for k , e := range n . connPool { for _ , conn := range e { conn . Release ( ) } delete ( n . connPool , k ) } n . streamCtxLock . Lock ( ) n . streamCancel ( ) n . setupStreamContext ( ) n . streamCtxLock . Unlock ( ) }
839	func ( n * NetworkTransport ) Close ( ) error { n . shutdownLock . Lock ( ) defer n . shutdownLock . Unlock ( ) if ! n . shutdown { close ( n . shutdownCh ) n . stream . Close ( ) n . shutdown = true } return nil }
840	func ( n * NetworkTransport ) getPooledConn ( target ServerAddress ) * netConn { n . connPoolLock . Lock ( ) defer n . connPoolLock . Unlock ( ) conns , ok := n . connPool [ target ] if ! ok || len ( conns ) == 0 { return nil } var conn * netConn num := len ( conns ) conn , conns [ num - 1 ] = conns [ num - 1 ] , nil n . connPool [ target ] = conns [ : num - 1 ] return conn }
841	func ( n * NetworkTransport ) getConnFromAddressProvider ( id ServerID , target ServerAddress ) ( * netConn , error ) { address := n . getProviderAddressOrFallback ( id , target ) return n . getConn ( address ) }
842	func ( n * NetworkTransport ) getConn ( target ServerAddress ) ( * netConn , error ) { if conn := n . getPooledConn ( target ) ; conn != nil { return conn , nil } conn , err := n . stream . Dial ( target , n . timeout ) if err != nil { return nil , err } netConn := & netConn { target : target , conn : conn , r : bufio . NewReader ( conn ) , w : bufio . NewWriter ( conn ) , } netConn . dec = codec . NewDecoder ( netConn . r , & codec . MsgpackHandle { } ) netConn . enc = codec . NewEncoder ( netConn . w , & codec . MsgpackHandle { } ) return netConn , nil }
843	func ( n * NetworkTransport ) returnConn ( conn * netConn ) { n . connPoolLock . Lock ( ) defer n . connPoolLock . Unlock ( ) key := conn . target conns , _ := n . connPool [ key ] if ! n . IsShutdown ( ) && len ( conns ) < n . maxPool { n . connPool [ key ] = append ( conns , conn ) } else { conn . Release ( ) } }
844	func ( n * NetworkTransport ) listen ( ) { const baseDelay = 5 * time . Millisecond const maxDelay = 1 * time . Second var loopDelay time . Duration for { conn , err := n . stream . Accept ( ) if err != nil { if loopDelay == 0 { loopDelay = baseDelay } else { loopDelay *= 2 } if loopDelay > maxDelay { loopDelay = maxDelay } if ! n . IsShutdown ( ) { n . logger . Printf ( "[ERR] raft-net: Failed to accept connection: %v" , err ) } select { case <- n . shutdownCh : return case <- time . After ( loopDelay ) : continue } } loopDelay = 0 n . logger . Printf ( "[DEBUG] raft-net: %v accepted connection from: %v" , n . LocalAddr ( ) , conn . RemoteAddr ( ) ) go n . handleConn ( n . getStreamContext ( ) , conn ) } }
845	func ( n * NetworkTransport ) handleConn ( connCtx context . Context , conn net . Conn ) { defer conn . Close ( ) r := bufio . NewReader ( conn ) w := bufio . NewWriter ( conn ) dec := codec . NewDecoder ( r , & codec . MsgpackHandle { } ) enc := codec . NewEncoder ( w , & codec . MsgpackHandle { } ) for { select { case <- connCtx . Done ( ) : n . logger . Println ( "[DEBUG] raft-net: stream layer is closed" ) return default : } if err := n . handleCommand ( r , dec , enc ) ; err != nil { if err != io . EOF { n . logger . Printf ( "[ERR] raft-net: Failed to decode incoming command: %v" , err ) } return } if err := w . Flush ( ) ; err != nil { n . logger . Printf ( "[ERR] raft-net: Failed to flush response: %v" , err ) return } } }
846	func ( n * NetworkTransport ) handleCommand ( r * bufio . Reader , dec * codec . Decoder , enc * codec . Encoder ) error { rpcType , err := r . ReadByte ( ) if err != nil { return err } respCh := make ( chan RPCResponse , 1 ) rpc := RPC { RespChan : respCh , } isHeartbeat := false switch rpcType { case rpcAppendEntries : var req AppendEntriesRequest if err := dec . Decode ( & req ) ; err != nil { return err } rpc . Command = & req if req . Term != 0 && req . Leader != nil && req . PrevLogEntry == 0 && req . PrevLogTerm == 0 && len ( req . Entries ) == 0 && req . LeaderCommitIndex == 0 { isHeartbeat = true } case rpcRequestVote : var req RequestVoteRequest if err := dec . Decode ( & req ) ; err != nil { return err } rpc . Command = & req case rpcInstallSnapshot : var req InstallSnapshotRequest if err := dec . Decode ( & req ) ; err != nil { return err } rpc . Command = & req rpc . Reader = io . LimitReader ( r , req . Size ) default : return fmt . Errorf ( "unknown rpc type %d" , rpcType ) } if isHeartbeat { n . heartbeatFnLock . Lock ( ) fn := n . heartbeatFn n . heartbeatFnLock . Unlock ( ) if fn != nil { fn ( rpc ) goto RESP } } select { case n . consumeCh <- rpc : case <- n . shutdownCh : return ErrTransportShutdown } RESP : select { case resp := <- respCh : respErr := "" if resp . Error != nil { respErr = resp . Error . Error ( ) } if err := enc . Encode ( respErr ) ; err != nil { return err } if err := enc . Encode ( resp . Response ) ; err != nil { return err } case <- n . shutdownCh : return ErrTransportShutdown } return nil }
847	func decodeResponse ( conn * netConn , resp interface { } ) ( bool , error ) { var rpcError string if err := conn . dec . Decode ( & rpcError ) ; err != nil { conn . Release ( ) return false , err } if err := conn . dec . Decode ( resp ) ; err != nil { conn . Release ( ) return false , err } if rpcError != "" { return true , fmt . Errorf ( rpcError ) } return true , nil }
848	func sendRPC ( conn * netConn , rpcType uint8 , args interface { } ) error { if err := conn . w . WriteByte ( rpcType ) ; err != nil { conn . Release ( ) return err } if err := conn . enc . Encode ( args ) ; err != nil { conn . Release ( ) return err } if err := conn . w . Flush ( ) ; err != nil { conn . Release ( ) return err } return nil }
849	func newNetPipeline ( trans * NetworkTransport , conn * netConn ) * netPipeline { n := & netPipeline { conn : conn , trans : trans , doneCh : make ( chan AppendFuture , rpcMaxPipeline ) , inprogressCh : make ( chan * appendFuture , rpcMaxPipeline ) , shutdownCh : make ( chan struct { } ) , } go n . decodeResponses ( ) return n }
850	func ( n * netPipeline ) decodeResponses ( ) { timeout := n . trans . timeout for { select { case future := <- n . inprogressCh : if timeout > 0 { n . conn . conn . SetReadDeadline ( time . Now ( ) . Add ( timeout ) ) } _ , err := decodeResponse ( n . conn , future . resp ) future . respond ( err ) select { case n . doneCh <- future : case <- n . shutdownCh : return } case <- n . shutdownCh : return } } }
851	func ( n * netPipeline ) AppendEntries ( args * AppendEntriesRequest , resp * AppendEntriesResponse ) ( AppendFuture , error ) { future := & appendFuture { start : time . Now ( ) , args : args , resp : resp , } future . init ( ) if timeout := n . trans . timeout ; timeout > 0 { n . conn . conn . SetWriteDeadline ( time . Now ( ) . Add ( timeout ) ) } if err := sendRPC ( n . conn , rpcAppendEntries , future . args ) ; err != nil { return nil , err } select { case n . inprogressCh <- future : return future , nil case <- n . shutdownCh : return nil , ErrPipelineShutdown } }
852	func ( n * netPipeline ) Close ( ) error { n . shutdownLock . Lock ( ) defer n . shutdownLock . Unlock ( ) if n . shutdown { return nil } n . conn . Release ( ) n . shutdown = true close ( n . shutdownCh ) return nil }
853	func NewObserver ( channel chan Observation , blocking bool , filter FilterFn ) * Observer { return & Observer { channel : channel , blocking : blocking , filter : filter , id : atomic . AddUint64 ( & nextObserverID , 1 ) , } }
854	func ( r * Raft ) RegisterObserver ( or * Observer ) { r . observersLock . Lock ( ) defer r . observersLock . Unlock ( ) r . observers [ or . id ] = or }
855	func ( r * Raft ) DeregisterObserver ( or * Observer ) { r . observersLock . Lock ( ) defer r . observersLock . Unlock ( ) delete ( r . observers , or . id ) }
856	func ( r * Raft ) observe ( o interface { } ) { r . observersLock . RLock ( ) defer r . observersLock . RUnlock ( ) for _ , or := range r . observers { ob := Observation { Raft : r , Data : o } if or . filter != nil && ! or . filter ( & ob ) { continue } if or . channel == nil { continue } if or . blocking { or . channel <- ob atomic . AddUint64 ( & or . numObserved , 1 ) } else { select { case or . channel <- ob : atomic . AddUint64 ( & or . numObserved , 1 ) default : atomic . AddUint64 ( & or . numDropped , 1 ) } } } }
857	func NewInmemStore ( ) * InmemStore { i := & InmemStore { logs : make ( map [ uint64 ] * Log ) , kv : make ( map [ string ] [ ] byte ) , kvInt : make ( map [ string ] uint64 ) , } return i }
858	func ( i * InmemStore ) FirstIndex ( ) ( uint64 , error ) { i . l . RLock ( ) defer i . l . RUnlock ( ) return i . lowIndex , nil }
859	func ( i * InmemStore ) LastIndex ( ) ( uint64 , error ) { i . l . RLock ( ) defer i . l . RUnlock ( ) return i . highIndex , nil }
860	func ( i * InmemStore ) GetLog ( index uint64 , log * Log ) error { i . l . RLock ( ) defer i . l . RUnlock ( ) l , ok := i . logs [ index ] if ! ok { return ErrLogNotFound } * log = * l return nil }
861	func ( i * InmemStore ) StoreLog ( log * Log ) error { return i . StoreLogs ( [ ] * Log { log } ) }
862	func ( i * InmemStore ) StoreLogs ( logs [ ] * Log ) error { i . l . Lock ( ) defer i . l . Unlock ( ) for _ , l := range logs { i . logs [ l . Index ] = l if i . lowIndex == 0 { i . lowIndex = l . Index } if l . Index > i . highIndex { i . highIndex = l . Index } } return nil }
863	func ( i * InmemStore ) DeleteRange ( min , max uint64 ) error { i . l . Lock ( ) defer i . l . Unlock ( ) for j := min ; j <= max ; j ++ { delete ( i . logs , j ) } if min <= i . lowIndex { i . lowIndex = max + 1 } if max >= i . highIndex { i . highIndex = min - 1 } if i . lowIndex > i . highIndex { i . lowIndex = 0 i . highIndex = 0 } return nil }
864	func ( i * InmemStore ) Set ( key [ ] byte , val [ ] byte ) error { i . l . Lock ( ) defer i . l . Unlock ( ) i . kv [ string ( key ) ] = val return nil }
865	func ( i * InmemStore ) Get ( key [ ] byte ) ( [ ] byte , error ) { i . l . RLock ( ) defer i . l . RUnlock ( ) val := i . kv [ string ( key ) ] if val == nil { return nil , errors . New ( "not found" ) } return val , nil }
866	func ( i * InmemStore ) SetUint64 ( key [ ] byte , val uint64 ) error { i . l . Lock ( ) defer i . l . Unlock ( ) i . kvInt [ string ( key ) ] = val return nil }
867	func ( i * InmemStore ) GetUint64 ( key [ ] byte ) ( uint64 , error ) { i . l . RLock ( ) defer i . l . RUnlock ( ) return i . kvInt [ string ( key ) ] , nil }
868	func NewLogCache ( capacity int , store LogStore ) ( * LogCache , error ) { if capacity <= 0 { return nil , fmt . Errorf ( "capacity must be positive" ) } c := & LogCache { store : store , cache : make ( [ ] * Log , capacity ) , } return c , nil }
869	func ( i * InmemTransport ) Connect ( peer ServerAddress , t Transport ) { trans := t . ( * InmemTransport ) i . Lock ( ) defer i . Unlock ( ) i . peers [ peer ] = trans }
870	func ( i * InmemTransport ) Disconnect ( peer ServerAddress ) { i . Lock ( ) defer i . Unlock ( ) delete ( i . peers , peer ) n := len ( i . pipelines ) for idx := 0 ; idx < n ; idx ++ { if i . pipelines [ idx ] . peerAddr == peer { i . pipelines [ idx ] . Close ( ) i . pipelines [ idx ] , i . pipelines [ n - 1 ] = i . pipelines [ n - 1 ] , nil idx -- n -- } } i . pipelines = i . pipelines [ : n ] }
871	func ( i * InmemTransport ) DisconnectAll ( ) { i . Lock ( ) defer i . Unlock ( ) i . peers = make ( map [ ServerAddress ] * InmemTransport ) for _ , pipeline := range i . pipelines { pipeline . Close ( ) } i . pipelines = nil }
872	func ( r * RPC ) Respond ( resp interface { } , err error ) { r . RespChan <- RPCResponse { resp , err } }
873	func ( u * userSnapshotFuture ) Open ( ) ( * SnapshotMeta , io . ReadCloser , error ) { if u . opener == nil { return nil , nil , fmt . Errorf ( "no snapshot available" ) } else { defer func ( ) { u . opener = nil } ( ) return u . opener ( ) } }
874	func ( v * verifyFuture ) vote ( leader bool ) { v . voteLock . Lock ( ) defer v . voteLock . Unlock ( ) if v . notifyCh == nil { return } if leader { v . votes ++ if v . votes >= v . quorumSize { v . notifyCh <- v v . notifyCh = nil } } else { v . notifyCh <- v v . notifyCh = nil } }
875	func ( s * followerReplication ) notifyAll ( leader bool ) { s . notifyLock . Lock ( ) n := s . notify s . notify = make ( map [ * verifyFuture ] struct { } ) s . notifyLock . Unlock ( ) for v , _ := range n { v . vote ( leader ) } }
876	func ( s * followerReplication ) cleanNotify ( v * verifyFuture ) { s . notifyLock . Lock ( ) delete ( s . notify , v ) s . notifyLock . Unlock ( ) }
877	func ( s * followerReplication ) LastContact ( ) time . Time { s . lastContactLock . RLock ( ) last := s . lastContact s . lastContactLock . RUnlock ( ) return last }
878	func ( s * followerReplication ) setLastContact ( ) { s . lastContactLock . Lock ( ) s . lastContact = time . Now ( ) s . lastContactLock . Unlock ( ) }
879	func ( r * Raft ) replicate ( s * followerReplication ) { stopHeartbeat := make ( chan struct { } ) defer close ( stopHeartbeat ) r . goFunc ( func ( ) { r . heartbeat ( s , stopHeartbeat ) } ) RPC : shouldStop := false for ! shouldStop { select { case maxIndex := <- s . stopCh : if maxIndex > 0 { r . replicateTo ( s , maxIndex ) } return case <- s . triggerCh : lastLogIdx , _ := r . getLastLog ( ) shouldStop = r . replicateTo ( s , lastLogIdx ) case <- randomTimeout ( r . conf . CommitTimeout ) : lastLogIdx , _ := r . getLastLog ( ) shouldStop = r . replicateTo ( s , lastLogIdx ) } if ! shouldStop && s . allowPipeline { goto PIPELINE } } return PIPELINE : s . allowPipeline = false if err := r . pipelineReplicate ( s ) ; err != nil { if err != ErrPipelineReplicationNotSupported { r . logger . Error ( fmt . Sprintf ( "Failed to start pipeline replication to %s: %s" , s . peer , err ) ) } } goto RPC }
880	func ( r * Raft ) pipelineReplicate ( s * followerReplication ) error { pipeline , err := r . trans . AppendEntriesPipeline ( s . peer . ID , s . peer . Address ) if err != nil { return err } defer pipeline . Close ( ) r . logger . Info ( fmt . Sprintf ( "pipelining replication to peer %v" , s . peer ) ) defer r . logger . Info ( fmt . Sprintf ( "aborting pipeline replication to peer %v" , s . peer ) ) stopCh := make ( chan struct { } ) finishCh := make ( chan struct { } ) r . goFunc ( func ( ) { r . pipelineDecode ( s , pipeline , stopCh , finishCh ) } ) nextIndex := s . nextIndex shouldStop := false SEND : for ! shouldStop { select { case <- finishCh : break SEND case maxIndex := <- s . stopCh : if maxIndex > 0 { r . pipelineSend ( s , pipeline , & nextIndex , maxIndex ) } break SEND case <- s . triggerCh : lastLogIdx , _ := r . getLastLog ( ) shouldStop = r . pipelineSend ( s , pipeline , & nextIndex , lastLogIdx ) case <- randomTimeout ( r . conf . CommitTimeout ) : lastLogIdx , _ := r . getLastLog ( ) shouldStop = r . pipelineSend ( s , pipeline , & nextIndex , lastLogIdx ) } } close ( stopCh ) select { case <- finishCh : case <- r . shutdownCh : } return nil }
881	func ( r * Raft ) pipelineSend ( s * followerReplication , p AppendPipeline , nextIdx * uint64 , lastIndex uint64 ) ( shouldStop bool ) { req := new ( AppendEntriesRequest ) if err := r . setupAppendEntries ( s , req , * nextIdx , lastIndex ) ; err != nil { return true } if _ , err := p . AppendEntries ( req , new ( AppendEntriesResponse ) ) ; err != nil { r . logger . Error ( fmt . Sprintf ( "Failed to pipeline AppendEntries to %v: %v" , s . peer , err ) ) return true } if n := len ( req . Entries ) ; n > 0 { last := req . Entries [ n - 1 ] * nextIdx = last . Index + 1 } return false }
882	func ( r * Raft ) pipelineDecode ( s * followerReplication , p AppendPipeline , stopCh , finishCh chan struct { } ) { defer close ( finishCh ) respCh := p . Consumer ( ) for { select { case ready := <- respCh : req , resp := ready . Request ( ) , ready . Response ( ) appendStats ( string ( s . peer . ID ) , ready . Start ( ) , float32 ( len ( req . Entries ) ) ) if resp . Term > req . Term { r . handleStaleTerm ( s ) return } s . setLastContact ( ) if ! resp . Success { return } updateLastAppended ( s , req ) case <- stopCh : return } } }
883	func ( r * Raft ) setupAppendEntries ( s * followerReplication , req * AppendEntriesRequest , nextIndex , lastIndex uint64 ) error { req . RPCHeader = r . getRPCHeader ( ) req . Term = s . currentTerm req . Leader = r . trans . EncodePeer ( r . localID , r . localAddr ) req . LeaderCommitIndex = r . getCommitIndex ( ) if err := r . setPreviousLog ( req , nextIndex ) ; err != nil { return err } if err := r . setNewLogs ( req , nextIndex , lastIndex ) ; err != nil { return err } return nil }
884	func ( r * Raft ) setPreviousLog ( req * AppendEntriesRequest , nextIndex uint64 ) error { lastSnapIdx , lastSnapTerm := r . getLastSnapshot ( ) if nextIndex == 1 { req . PrevLogEntry = 0 req . PrevLogTerm = 0 } else if ( nextIndex - 1 ) == lastSnapIdx { req . PrevLogEntry = lastSnapIdx req . PrevLogTerm = lastSnapTerm } else { var l Log if err := r . logs . GetLog ( nextIndex - 1 , & l ) ; err != nil { r . logger . Error ( fmt . Sprintf ( "Failed to get log at index %d: %v" , nextIndex - 1 , err ) ) return err } req . PrevLogEntry = l . Index req . PrevLogTerm = l . Term } return nil }
885	func ( r * Raft ) setNewLogs ( req * AppendEntriesRequest , nextIndex , lastIndex uint64 ) error { req . Entries = make ( [ ] * Log , 0 , r . conf . MaxAppendEntries ) maxIndex := min ( nextIndex + uint64 ( r . conf . MaxAppendEntries ) - 1 , lastIndex ) for i := nextIndex ; i <= maxIndex ; i ++ { oldLog := new ( Log ) if err := r . logs . GetLog ( i , oldLog ) ; err != nil { r . logger . Error ( fmt . Sprintf ( "Failed to get log at index %d: %v" , i , err ) ) return err } req . Entries = append ( req . Entries , oldLog ) } return nil }
886	func appendStats ( peer string , start time . Time , logs float32 ) { metrics . MeasureSince ( [ ] string { "raft" , "replication" , "appendEntries" , "rpc" , peer } , start ) metrics . IncrCounter ( [ ] string { "raft" , "replication" , "appendEntries" , "logs" , peer } , logs ) }
887	func ( r * Raft ) handleStaleTerm ( s * followerReplication ) { r . logger . Error ( fmt . Sprintf ( "peer %v has newer term, stopping replication" , s . peer ) ) s . notifyAll ( false ) asyncNotifyCh ( s . stepDown ) }
888	func ( t * transport ) AppendEntries ( id raft . ServerID , target raft . ServerAddress , args * raft . AppendEntriesRequest , resp * raft . AppendEntriesResponse ) error { ae := appendEntries { source : t . node , target : target , firstIndex : firstIndex ( args ) , lastIndex : lastIndex ( args ) , commitIndex : args . LeaderCommitIndex , } if len ( t . ae ) < cap ( t . ae ) { t . ae = append ( t . ae , ae ) } return t . sendRPC ( string ( target ) , args , resp ) }
889	func ( t * transport ) RequestVote ( id raft . ServerID , target raft . ServerAddress , args * raft . RequestVoteRequest , resp * raft . RequestVoteResponse ) error { return t . sendRPC ( string ( target ) , args , resp ) }
890	func ( t * transport ) InstallSnapshot ( id raft . ServerID , target raft . ServerAddress , args * raft . InstallSnapshotRequest , resp * raft . InstallSnapshotResponse , data io . Reader ) error { t . log . Printf ( "INSTALL SNAPSHOT *************************************" ) return errors . New ( "huh" ) }
891	func ( t * transport ) EncodePeer ( id raft . ServerID , p raft . ServerAddress ) [ ] byte { return [ ] byte ( p ) }
892	func ( t * transport ) DecodePeer ( p [ ] byte ) raft . ServerAddress { return raft . ServerAddress ( p ) }
893	func ( p * pipeline ) AppendEntries ( args * raft . AppendEntriesRequest , resp * raft . AppendEntriesResponse ) ( raft . AppendFuture , error ) { e := & appendEntry { req : args , res : resp , start : time . Now ( ) , ready : make ( chan error ) , consumer : p . consumer , } p . work <- e return e , nil }
894	func ReadPeersJSON ( path string ) ( Configuration , error ) { buf , err := ioutil . ReadFile ( path ) if err != nil { return Configuration { } , err } var peers [ ] string dec := json . NewDecoder ( bytes . NewReader ( buf ) ) if err := dec . Decode ( & peers ) ; err != nil { return Configuration { } , err } var configuration Configuration for _ , peer := range peers { server := Server { Suffrage : Voter , ID : ServerID ( peer ) , Address : ServerAddress ( peer ) , } configuration . Servers = append ( configuration . Servers , server ) } if err := checkConfiguration ( configuration ) ; err != nil { return Configuration { } , err } return configuration , nil }
895	func ReadConfigJSON ( path string ) ( Configuration , error ) { buf , err := ioutil . ReadFile ( path ) if err != nil { return Configuration { } , err } var peers [ ] configEntry dec := json . NewDecoder ( bytes . NewReader ( buf ) ) if err := dec . Decode ( & peers ) ; err != nil { return Configuration { } , err } var configuration Configuration for _ , peer := range peers { suffrage := Voter if peer . NonVoter { suffrage = Nonvoter } server := Server { Suffrage : suffrage , ID : peer . ID , Address : peer . Address , } configuration . Servers = append ( configuration . Servers , server ) } if err := checkConfiguration ( configuration ) ; err != nil { return Configuration { } , err } return configuration , nil }
896	func NewTCPTransport ( bindAddr string , advertise net . Addr , maxPool int , timeout time . Duration , logOutput io . Writer , ) ( * NetworkTransport , error ) { return newTCPTransport ( bindAddr , advertise , func ( stream StreamLayer ) * NetworkTransport { return NewNetworkTransport ( stream , maxPool , timeout , logOutput ) } ) }
897	func NewTCPTransportWithLogger ( bindAddr string , advertise net . Addr , maxPool int , timeout time . Duration , logger * log . Logger , ) ( * NetworkTransport , error ) { return newTCPTransport ( bindAddr , advertise , func ( stream StreamLayer ) * NetworkTransport { return NewNetworkTransportWithLogger ( stream , maxPool , timeout , logger ) } ) }
898	func NewTCPTransportWithConfig ( bindAddr string , advertise net . Addr , config * NetworkTransportConfig , ) ( * NetworkTransport , error ) { return newTCPTransport ( bindAddr , advertise , func ( stream StreamLayer ) * NetworkTransport { config . Stream = stream return NewNetworkTransportWithConfig ( config ) } ) }
899	func ( t * TCPStreamLayer ) Dial ( address ServerAddress , timeout time . Duration ) ( net . Conn , error ) { return net . DialTimeout ( "tcp" , string ( address ) , timeout ) }
900	func ( t * TCPStreamLayer ) Accept ( ) ( c net . Conn , err error ) { return t . listener . Accept ( ) }
901	func ( t * TCPStreamLayer ) Addr ( ) net . Addr { if t . advertise != nil { return t . advertise } return t . listener . Addr ( ) }
902	func ( r * Raft ) restoreSnapshot ( ) error { snapshots , err := r . snapshots . List ( ) if err != nil { r . logger . Error ( fmt . Sprintf ( "Failed to list snapshots: %v" , err ) ) return err } for _ , snapshot := range snapshots { _ , source , err := r . snapshots . Open ( snapshot . ID ) if err != nil { r . logger . Error ( fmt . Sprintf ( "Failed to open snapshot %v: %v" , snapshot . ID , err ) ) continue } defer source . Close ( ) if err := r . fsm . Restore ( source ) ; err != nil { r . logger . Error ( fmt . Sprintf ( "Failed to restore snapshot %v: %v" , snapshot . ID , err ) ) continue } r . logger . Info ( fmt . Sprintf ( "Restored from snapshot %v" , snapshot . ID ) ) r . setLastApplied ( snapshot . Index ) r . setLastSnapshot ( snapshot . Index , snapshot . Term ) if snapshot . Version > 0 { r . configurations . committed = snapshot . Configuration r . configurations . committedIndex = snapshot . ConfigurationIndex r . configurations . latest = snapshot . Configuration r . configurations . latestIndex = snapshot . ConfigurationIndex } else { configuration := decodePeers ( snapshot . Peers , r . trans ) r . configurations . committed = configuration r . configurations . committedIndex = snapshot . Index r . configurations . latest = configuration r . configurations . latestIndex = snapshot . Index } return nil } if len ( snapshots ) > 0 { return fmt . Errorf ( "failed to load any existing snapshots" ) } return nil }
903	func ( r * Raft ) BootstrapCluster ( configuration Configuration ) Future { bootstrapReq := & bootstrapFuture { } bootstrapReq . init ( ) bootstrapReq . configuration = configuration select { case <- r . shutdownCh : return errorFuture { ErrRaftShutdown } case r . bootstrapCh <- bootstrapReq : return bootstrapReq } }
904	func ( r * Raft ) Leader ( ) ServerAddress { r . leaderLock . RLock ( ) leader := r . leader r . leaderLock . RUnlock ( ) return leader }
905	func ( r * Raft ) Apply ( cmd [ ] byte , timeout time . Duration ) ApplyFuture { metrics . IncrCounter ( [ ] string { "raft" , "apply" } , 1 ) var timer <- chan time . Time if timeout > 0 { timer = time . After ( timeout ) } logFuture := & logFuture { log : Log { Type : LogCommand , Data : cmd , } , } logFuture . init ( ) select { case <- timer : return errorFuture { ErrEnqueueTimeout } case <- r . shutdownCh : return errorFuture { ErrRaftShutdown } case r . applyCh <- logFuture : return logFuture } }
906	func ( r * Raft ) Barrier ( timeout time . Duration ) Future { metrics . IncrCounter ( [ ] string { "raft" , "barrier" } , 1 ) var timer <- chan time . Time if timeout > 0 { timer = time . After ( timeout ) } logFuture := & logFuture { log : Log { Type : LogBarrier , } , } logFuture . init ( ) select { case <- timer : return errorFuture { ErrEnqueueTimeout } case <- r . shutdownCh : return errorFuture { ErrRaftShutdown } case r . applyCh <- logFuture : return logFuture } }
907	func ( r * Raft ) VerifyLeader ( ) Future { metrics . IncrCounter ( [ ] string { "raft" , "verify_leader" } , 1 ) verifyFuture := & verifyFuture { } verifyFuture . init ( ) select { case <- r . shutdownCh : return errorFuture { ErrRaftShutdown } case r . verifyCh <- verifyFuture : return verifyFuture } }
908	func ( r * Raft ) AddVoter ( id ServerID , address ServerAddress , prevIndex uint64 , timeout time . Duration ) IndexFuture { if r . protocolVersion < 2 { return errorFuture { ErrUnsupportedProtocol } } return r . requestConfigChange ( configurationChangeRequest { command : AddStaging , serverID : id , serverAddress : address , prevIndex : prevIndex , } , timeout ) }
909	func ( r * Raft ) RemoveServer ( id ServerID , prevIndex uint64 , timeout time . Duration ) IndexFuture { if r . protocolVersion < 2 { return errorFuture { ErrUnsupportedProtocol } } return r . requestConfigChange ( configurationChangeRequest { command : RemoveServer , serverID : id , prevIndex : prevIndex , } , timeout ) }
910	func ( r * Raft ) Shutdown ( ) Future { r . shutdownLock . Lock ( ) defer r . shutdownLock . Unlock ( ) if ! r . shutdown { close ( r . shutdownCh ) r . shutdown = true r . setState ( Shutdown ) return & shutdownFuture { r } } return & shutdownFuture { nil } }
911	func ( r * Raft ) Snapshot ( ) SnapshotFuture { future := & userSnapshotFuture { } future . init ( ) select { case r . userSnapshotCh <- future : return future case <- r . shutdownCh : future . respond ( ErrRaftShutdown ) return future } }
912	func ( r * Raft ) Restore ( meta * SnapshotMeta , reader io . Reader , timeout time . Duration ) error { metrics . IncrCounter ( [ ] string { "raft" , "restore" } , 1 ) var timer <- chan time . Time if timeout > 0 { timer = time . After ( timeout ) } restore := & userRestoreFuture { meta : meta , reader : reader , } restore . init ( ) select { case <- timer : return ErrEnqueueTimeout case <- r . shutdownCh : return ErrRaftShutdown case r . userRestoreCh <- restore : if err := restore . Error ( ) ; err != nil { return err } } noop := & logFuture { log : Log { Type : LogNoop , } , } noop . init ( ) select { case <- timer : return ErrEnqueueTimeout case <- r . shutdownCh : return ErrRaftShutdown case r . applyCh <- noop : return noop . Error ( ) } }
913	func ( r * Raft ) String ( ) string { return fmt . Sprintf ( "Node at %s [%v]" , r . localAddr , r . getState ( ) ) }
914	func ( r * Raft ) LastContact ( ) time . Time { r . lastContactLock . RLock ( ) last := r . lastContact r . lastContactLock . RUnlock ( ) return last }
915	func ( a * LoggerAdapter ) Logf ( s string , v ... interface { } ) { a . log . Printf ( s , v ... ) }
916	func containsNode ( nodes [ ] * raftNode , n * raftNode ) bool { for _ , rn := range nodes { if rn == n { return true } } return false }
917	func ( c * cluster ) LeaderPlus ( n int ) [ ] * raftNode { r := make ( [ ] * raftNode , 0 , n + 1 ) ldr := c . Leader ( time . Second ) if ldr != nil { r = append ( r , ldr ) } if len ( r ) >= n { return r } for _ , node := range c . nodes { if ! containsNode ( r , node ) { r = append ( r , node ) if len ( r ) >= n { return r } } } return r }
918	func ( c * cluster ) WaitTilUptoDate ( t * testing . T , maxWait time . Duration ) { idx := c . lastApplySuccess . Index ( ) start := time . Now ( ) for true { allAtIdx := true for i := 0 ; i < len ( c . nodes ) ; i ++ { nodeAppliedIdx := c . nodes [ i ] . raft . AppliedIndex ( ) if nodeAppliedIdx < idx { allAtIdx = false break } else if nodeAppliedIdx > idx { allAtIdx = false idx = nodeAppliedIdx break } } if allAtIdx { t . Logf ( "All nodes have appliedIndex=%d" , idx ) return } if time . Now ( ) . Sub ( start ) > maxWait { t . Fatalf ( "Gave up waiting for all nodes to reach raft Index %d, [currently at %v]" , idx , c . appliedIndexes ( ) ) } time . Sleep ( time . Millisecond * 10 ) } }
919	func assertLogEntryEqual ( t * testing . T , node string , exp * raft . Log , act * raft . Log ) bool { res := true if exp . Term != act . Term { t . Errorf ( "Log Entry at Index %d for node %v has mismatched terms %d/%d" , exp . Index , node , exp . Term , act . Term ) res = false } if exp . Index != act . Index { t . Errorf ( "Node %v, Log Entry should be Index %d,but is %d" , node , exp . Index , act . Index ) res = false } if exp . Type != act . Type { t . Errorf ( "Node %v, Log Entry at Index %d should have type %v but is %v" , node , exp . Index , exp . Type , act . Type ) res = false } if ! bytes . Equal ( exp . Data , act . Data ) { t . Errorf ( "Node %v, Log Entry at Index %d should have data %v, but has %v" , node , exp . Index , exp . Data , act . Data ) res = false } return res }
920	func ( r * Raft ) runFSM ( ) { var lastIndex , lastTerm uint64 commit := func ( req * commitTuple ) { var resp interface { } if req . log . Type == LogCommand { start := time . Now ( ) resp = r . fsm . Apply ( req . log ) metrics . MeasureSince ( [ ] string { "raft" , "fsm" , "apply" } , start ) } lastIndex = req . log . Index lastTerm = req . log . Term if req . future != nil { req . future . response = resp req . future . respond ( nil ) } } restore := func ( req * restoreFuture ) { meta , source , err := r . snapshots . Open ( req . ID ) if err != nil { req . respond ( fmt . Errorf ( "failed to open snapshot %v: %v" , req . ID , err ) ) return } start := time . Now ( ) if err := r . fsm . Restore ( source ) ; err != nil { req . respond ( fmt . Errorf ( "failed to restore snapshot %v: %v" , req . ID , err ) ) source . Close ( ) return } source . Close ( ) metrics . MeasureSince ( [ ] string { "raft" , "fsm" , "restore" } , start ) lastIndex = meta . Index lastTerm = meta . Term req . respond ( nil ) } snapshot := func ( req * reqSnapshotFuture ) { if lastIndex == 0 { req . respond ( ErrNothingNewToSnapshot ) return } start := time . Now ( ) snap , err := r . fsm . Snapshot ( ) metrics . MeasureSince ( [ ] string { "raft" , "fsm" , "snapshot" } , start ) req . index = lastIndex req . term = lastTerm req . snapshot = snap req . respond ( err ) } for { select { case ptr := <- r . fsmMutateCh : switch req := ptr . ( type ) { case * commitTuple : commit ( req ) case * restoreFuture : restore ( req ) default : panic ( fmt . Errorf ( "bad type passed to fsmMutateCh: %#v" , ptr ) ) } case req := <- r . fsmSnapshotCh : snapshot ( req ) case <- r . shutdownCh : return } } }
921	func ( c * Configuration ) Clone ( ) ( copy Configuration ) { copy . Servers = append ( copy . Servers , c . Servers ... ) return }
922	func ( c * configurations ) Clone ( ) ( copy configurations ) { copy . committed = c . committed . Clone ( ) copy . committedIndex = c . committedIndex copy . latest = c . latest . Clone ( ) copy . latestIndex = c . latestIndex return }
923	func hasVote ( configuration Configuration , id ServerID ) bool { for _ , server := range configuration . Servers { if server . ID == id { return server . Suffrage == Voter } } return false }
924	func checkConfiguration ( configuration Configuration ) error { idSet := make ( map [ ServerID ] bool ) addressSet := make ( map [ ServerAddress ] bool ) var voters int for _ , server := range configuration . Servers { if server . ID == "" { return fmt . Errorf ( "Empty ID in configuration: %v" , configuration ) } if server . Address == "" { return fmt . Errorf ( "Empty address in configuration: %v" , server ) } if idSet [ server . ID ] { return fmt . Errorf ( "Found duplicate ID in configuration: %v" , server . ID ) } idSet [ server . ID ] = true if addressSet [ server . Address ] { return fmt . Errorf ( "Found duplicate address in configuration: %v" , server . Address ) } addressSet [ server . Address ] = true if server . Suffrage == Voter { voters ++ } } if voters == 0 { return fmt . Errorf ( "Need at least one voter in configuration: %v" , configuration ) } return nil }
925	func nextConfiguration ( current Configuration , currentIndex uint64 , change configurationChangeRequest ) ( Configuration , error ) { if change . prevIndex > 0 && change . prevIndex != currentIndex { return Configuration { } , fmt . Errorf ( "Configuration changed since %v (latest is %v)" , change . prevIndex , currentIndex ) } configuration := current . Clone ( ) switch change . command { case AddStaging : newServer := Server { Suffrage : Voter , ID : change . serverID , Address : change . serverAddress , } found := false for i , server := range configuration . Servers { if server . ID == change . serverID { if server . Suffrage == Voter { configuration . Servers [ i ] . Address = change . serverAddress } else { configuration . Servers [ i ] = newServer } found = true break } } if ! found { configuration . Servers = append ( configuration . Servers , newServer ) } case AddNonvoter : newServer := Server { Suffrage : Nonvoter , ID : change . serverID , Address : change . serverAddress , } found := false for i , server := range configuration . Servers { if server . ID == change . serverID { if server . Suffrage != Nonvoter { configuration . Servers [ i ] . Address = change . serverAddress } else { configuration . Servers [ i ] = newServer } found = true break } } if ! found { configuration . Servers = append ( configuration . Servers , newServer ) } case DemoteVoter : for i , server := range configuration . Servers { if server . ID == change . serverID { configuration . Servers [ i ] . Suffrage = Nonvoter break } } case RemoveServer : for i , server := range configuration . Servers { if server . ID == change . serverID { configuration . Servers = append ( configuration . Servers [ : i ] , configuration . Servers [ i + 1 : ] ... ) break } } case Promote : for i , server := range configuration . Servers { if server . ID == change . serverID && server . Suffrage == Staging { configuration . Servers [ i ] . Suffrage = Voter break } } } if err := checkConfiguration ( configuration ) ; err != nil { return Configuration { } , err } return configuration , nil }
926	func encodePeers ( configuration Configuration , trans Transport ) [ ] byte { var encPeers [ ] [ ] byte for _ , server := range configuration . Servers { if server . Suffrage == Voter { encPeers = append ( encPeers , trans . EncodePeer ( server . ID , server . Address ) ) } } buf , err := encodeMsgPack ( encPeers ) if err != nil { panic ( fmt . Errorf ( "failed to encode peers: %v" , err ) ) } return buf . Bytes ( ) }
927	func decodePeers ( buf [ ] byte , trans Transport ) Configuration { var encPeers [ ] [ ] byte if err := decodeMsgPack ( buf , & encPeers ) ; err != nil { panic ( fmt . Errorf ( "failed to decode peers: %v" , err ) ) } var servers [ ] Server for _ , enc := range encPeers { p := trans . DecodePeer ( enc ) servers = append ( servers , Server { Suffrage : Voter , ID : ServerID ( p ) , Address : ServerAddress ( p ) , } ) } return Configuration { Servers : servers , } }
928	func encodeConfiguration ( configuration Configuration ) [ ] byte { buf , err := encodeMsgPack ( configuration ) if err != nil { panic ( fmt . Errorf ( "failed to encode configuration: %v" , err ) ) } return buf . Bytes ( ) }
929	func decodeConfiguration ( buf [ ] byte ) Configuration { var configuration Configuration if err := decodeMsgPack ( buf , & configuration ) ; err != nil { panic ( fmt . Errorf ( "failed to decode configuration: %v" , err ) ) } return configuration }
930	func ( r * raftState ) goFunc ( f func ( ) ) { r . routinesGroup . Add ( 1 ) go func ( ) { defer r . routinesGroup . Done ( ) f ( ) } ( ) }
931	func ( r * raftState ) getLastIndex ( ) uint64 { r . lastLock . Lock ( ) defer r . lastLock . Unlock ( ) return max ( r . lastLogIndex , r . lastSnapshotIndex ) }
932	func ( r * raftState ) getLastEntry ( ) ( uint64 , uint64 ) { r . lastLock . Lock ( ) defer r . lastLock . Unlock ( ) if r . lastLogIndex >= r . lastSnapshotIndex { return r . lastLogIndex , r . lastLogTerm } return r . lastSnapshotIndex , r . lastSnapshotTerm }
933	func ( r * Raft ) checkRPCHeader ( rpc RPC ) error { wh , ok := rpc . Command . ( WithRPCHeader ) if ! ok { return fmt . Errorf ( "RPC does not have a header" ) } header := wh . GetRPCHeader ( ) if header . ProtocolVersion < ProtocolVersionMin || header . ProtocolVersion > ProtocolVersionMax { return ErrUnsupportedProtocol } if header . ProtocolVersion < r . conf . ProtocolVersion - 1 { return ErrUnsupportedProtocol } return nil }
934	func ( r * Raft ) setLeader ( leader ServerAddress ) { r . leaderLock . Lock ( ) oldLeader := r . leader r . leader = leader r . leaderLock . Unlock ( ) if oldLeader != leader { r . observe ( LeaderObservation { leader : leader } ) } }
935	func ( r * Raft ) requestConfigChange ( req configurationChangeRequest , timeout time . Duration ) IndexFuture { var timer <- chan time . Time if timeout > 0 { timer = time . After ( timeout ) } future := & configurationChangeFuture { req : req , } future . init ( ) select { case <- timer : return errorFuture { ErrEnqueueTimeout } case r . configurationChangeCh <- future : return future case <- r . shutdownCh : return errorFuture { ErrRaftShutdown } } }
936	func ( r * Raft ) run ( ) { for { select { case <- r . shutdownCh : r . setLeader ( "" ) return default : } switch r . getState ( ) { case Follower : r . runFollower ( ) case Candidate : r . runCandidate ( ) case Leader : r . runLeader ( ) } } }
937	func ( r * Raft ) runFollower ( ) { didWarn := false r . logger . Info ( fmt . Sprintf ( "%v entering Follower state (Leader: %q)" , r , r . Leader ( ) ) ) metrics . IncrCounter ( [ ] string { "raft" , "state" , "follower" } , 1 ) heartbeatTimer := randomTimeout ( r . conf . HeartbeatTimeout ) for { select { case rpc := <- r . rpcCh : r . processRPC ( rpc ) case c := <- r . configurationChangeCh : c . respond ( ErrNotLeader ) case a := <- r . applyCh : a . respond ( ErrNotLeader ) case v := <- r . verifyCh : v . respond ( ErrNotLeader ) case r := <- r . userRestoreCh : r . respond ( ErrNotLeader ) case c := <- r . configurationsCh : c . configurations = r . configurations . Clone ( ) c . respond ( nil ) case b := <- r . bootstrapCh : b . respond ( r . liveBootstrap ( b . configuration ) ) case <- heartbeatTimer : heartbeatTimer = randomTimeout ( r . conf . HeartbeatTimeout ) lastContact := r . LastContact ( ) if time . Now ( ) . Sub ( lastContact ) < r . conf . HeartbeatTimeout { continue } lastLeader := r . Leader ( ) r . setLeader ( "" ) if r . configurations . latestIndex == 0 { if ! didWarn { r . logger . Warn ( "no known peers, aborting election" ) didWarn = true } } else if r . configurations . latestIndex == r . configurations . committedIndex && ! hasVote ( r . configurations . latest , r . localID ) { if ! didWarn { r . logger . Warn ( "not part of stable configuration, aborting election" ) didWarn = true } } else { r . logger . Warn ( fmt . Sprintf ( "Heartbeat timeout from %q reached, starting election" , lastLeader ) ) metrics . IncrCounter ( [ ] string { "raft" , "transition" , "heartbeat_timeout" } , 1 ) r . setState ( Candidate ) return } case <- r . shutdownCh : return } } }
938	func ( r * Raft ) liveBootstrap ( configuration Configuration ) error { err := BootstrapCluster ( & r . conf , r . logs , r . stable , r . snapshots , r . trans , configuration ) if err != nil { return err } var entry Log if err := r . logs . GetLog ( 1 , & entry ) ; err != nil { panic ( err ) } r . setCurrentTerm ( 1 ) r . setLastLog ( entry . Index , entry . Term ) r . processConfigurationLogEntry ( & entry ) return nil }
939	func ( r * Raft ) runCandidate ( ) { r . logger . Info ( fmt . Sprintf ( "%v entering Candidate state in term %v" , r , r . getCurrentTerm ( ) + 1 ) ) metrics . IncrCounter ( [ ] string { "raft" , "state" , "candidate" } , 1 ) voteCh := r . electSelf ( ) electionTimer := randomTimeout ( r . conf . ElectionTimeout ) grantedVotes := 0 votesNeeded := r . quorumSize ( ) r . logger . Debug ( fmt . Sprintf ( "Votes needed: %d" , votesNeeded ) ) for r . getState ( ) == Candidate { select { case rpc := <- r . rpcCh : r . processRPC ( rpc ) case vote := <- voteCh : if vote . Term > r . getCurrentTerm ( ) { r . logger . Debug ( "Newer term discovered, fallback to follower" ) r . setState ( Follower ) r . setCurrentTerm ( vote . Term ) return } if vote . Granted { grantedVotes ++ r . logger . Debug ( fmt . Sprintf ( "Vote granted from %s in term %v. Tally: %d" , vote . voterID , vote . Term , grantedVotes ) ) } if grantedVotes >= votesNeeded { r . logger . Info ( fmt . Sprintf ( "Election won. Tally: %d" , grantedVotes ) ) r . setState ( Leader ) r . setLeader ( r . localAddr ) return } case c := <- r . configurationChangeCh : c . respond ( ErrNotLeader ) case a := <- r . applyCh : a . respond ( ErrNotLeader ) case v := <- r . verifyCh : v . respond ( ErrNotLeader ) case r := <- r . userRestoreCh : r . respond ( ErrNotLeader ) case c := <- r . configurationsCh : c . configurations = r . configurations . Clone ( ) c . respond ( nil ) case b := <- r . bootstrapCh : b . respond ( ErrCantBootstrap ) case <- electionTimer : r . logger . Warn ( "Election timeout reached, restarting election" ) return case <- r . shutdownCh : return } } }
940	func ( r * Raft ) runLeader ( ) { r . logger . Info ( fmt . Sprintf ( "%v entering Leader state" , r ) ) metrics . IncrCounter ( [ ] string { "raft" , "state" , "leader" } , 1 ) asyncNotifyBool ( r . leaderCh , true ) if notify := r . conf . NotifyCh ; notify != nil { select { case notify <- true : case <- r . shutdownCh : } } r . leaderState . commitCh = make ( chan struct { } , 1 ) r . leaderState . commitment = newCommitment ( r . leaderState . commitCh , r . configurations . latest , r . getLastIndex ( ) + 1 ) r . leaderState . inflight = list . New ( ) r . leaderState . replState = make ( map [ ServerID ] * followerReplication ) r . leaderState . notify = make ( map [ * verifyFuture ] struct { } ) r . leaderState . stepDown = make ( chan struct { } , 1 ) defer func ( ) { r . setLastContact ( ) for _ , p := range r . leaderState . replState { close ( p . stopCh ) } for e := r . leaderState . inflight . Front ( ) ; e != nil ; e = e . Next ( ) { e . Value . ( * logFuture ) . respond ( ErrLeadershipLost ) } for future := range r . leaderState . notify { future . respond ( ErrLeadershipLost ) } r . leaderState . commitCh = nil r . leaderState . commitment = nil r . leaderState . inflight = nil r . leaderState . replState = nil r . leaderState . notify = nil r . leaderState . stepDown = nil r . leaderLock . Lock ( ) if r . leader == r . localAddr { r . leader = "" } r . leaderLock . Unlock ( ) asyncNotifyBool ( r . leaderCh , false ) if notify := r . conf . NotifyCh ; notify != nil { select { case notify <- false : case <- r . shutdownCh : select { case notify <- false : default : } } } } ( ) r . startStopReplication ( ) noop := & logFuture { log : Log { Type : LogNoop , } , } r . dispatchLogs ( [ ] * logFuture { noop } ) r . leaderLoop ( ) }
941	func ( r * Raft ) startStopReplication ( ) { inConfig := make ( map [ ServerID ] bool , len ( r . configurations . latest . Servers ) ) lastIdx := r . getLastIndex ( ) for _ , server := range r . configurations . latest . Servers { if server . ID == r . localID { continue } inConfig [ server . ID ] = true if _ , ok := r . leaderState . replState [ server . ID ] ; ! ok { r . logger . Info ( fmt . Sprintf ( "Added peer %v, starting replication" , server . ID ) ) s := & followerReplication { peer : server , commitment : r . leaderState . commitment , stopCh : make ( chan uint64 , 1 ) , triggerCh : make ( chan struct { } , 1 ) , currentTerm : r . getCurrentTerm ( ) , nextIndex : lastIdx + 1 , lastContact : time . Now ( ) , notify : make ( map [ * verifyFuture ] struct { } ) , notifyCh : make ( chan struct { } , 1 ) , stepDown : r . leaderState . stepDown , } r . leaderState . replState [ server . ID ] = s r . goFunc ( func ( ) { r . replicate ( s ) } ) asyncNotifyCh ( s . triggerCh ) } } for serverID , repl := range r . leaderState . replState { if inConfig [ serverID ] { continue } r . logger . Info ( fmt . Sprintf ( "Removed peer %v, stopping replication after %v" , serverID , lastIdx ) ) repl . stopCh <- lastIdx close ( repl . stopCh ) delete ( r . leaderState . replState , serverID ) } }
942	func ( r * Raft ) configurationChangeChIfStable ( ) chan * configurationChangeFuture { if r . configurations . latestIndex == r . configurations . committedIndex && r . getCommitIndex ( ) >= r . leaderState . commitment . startIndex { return r . configurationChangeCh } return nil }
943	func ( r * Raft ) verifyLeader ( v * verifyFuture ) { v . votes = 1 v . quorumSize = r . quorumSize ( ) if v . quorumSize == 1 { v . respond ( nil ) return } v . notifyCh = r . verifyCh r . leaderState . notify [ v ] = struct { } { } for _ , repl := range r . leaderState . replState { repl . notifyLock . Lock ( ) repl . notify [ v ] = struct { } { } repl . notifyLock . Unlock ( ) asyncNotifyCh ( repl . notifyCh ) } }
944	func ( r * Raft ) checkLeaderLease ( ) time . Duration { contacted := 1 var maxDiff time . Duration now := time . Now ( ) for peer , f := range r . leaderState . replState { diff := now . Sub ( f . LastContact ( ) ) if diff <= r . conf . LeaderLeaseTimeout { contacted ++ if diff > maxDiff { maxDiff = diff } } else { if diff <= 3 * r . conf . LeaderLeaseTimeout { r . logger . Warn ( fmt . Sprintf ( "Failed to contact %v in %v" , peer , diff ) ) } else { r . logger . Debug ( fmt . Sprintf ( "Failed to contact %v in %v" , peer , diff ) ) } } metrics . AddSample ( [ ] string { "raft" , "leader" , "lastContact" } , float32 ( diff / time . Millisecond ) ) } quorum := r . quorumSize ( ) if contacted < quorum { r . logger . Warn ( "Failed to contact quorum of nodes, stepping down" ) r . setState ( Follower ) metrics . IncrCounter ( [ ] string { "raft" , "transition" , "leader_lease_timeout" } , 1 ) } return maxDiff }
945	func ( r * Raft ) restoreUserSnapshot ( meta * SnapshotMeta , reader io . Reader ) error { defer metrics . MeasureSince ( [ ] string { "raft" , "restoreUserSnapshot" } , time . Now ( ) ) version := meta . Version if version < SnapshotVersionMin || version > SnapshotVersionMax { return fmt . Errorf ( "unsupported snapshot version %d" , version ) } committedIndex := r . configurations . committedIndex latestIndex := r . configurations . latestIndex if committedIndex != latestIndex { return fmt . Errorf ( "cannot restore snapshot now, wait until the configuration entry at %v has been applied (have applied %v)" , latestIndex , committedIndex ) } for { e := r . leaderState . inflight . Front ( ) if e == nil { break } e . Value . ( * logFuture ) . respond ( ErrAbortedByRestore ) r . leaderState . inflight . Remove ( e ) } term := r . getCurrentTerm ( ) lastIndex := r . getLastIndex ( ) if meta . Index > lastIndex { lastIndex = meta . Index } lastIndex ++ sink , err := r . snapshots . Create ( version , lastIndex , term , r . configurations . latest , r . configurations . latestIndex , r . trans ) if err != nil { return fmt . Errorf ( "failed to create snapshot: %v" , err ) } n , err := io . Copy ( sink , reader ) if err != nil { sink . Cancel ( ) return fmt . Errorf ( "failed to write snapshot: %v" , err ) } if n != meta . Size { sink . Cancel ( ) return fmt . Errorf ( "failed to write snapshot, size didn't match (%d != %d)" , n , meta . Size ) } if err := sink . Close ( ) ; err != nil { return fmt . Errorf ( "failed to close snapshot: %v" , err ) } r . logger . Info ( fmt . Sprintf ( "Copied %d bytes to local snapshot" , n ) ) fsm := & restoreFuture { ID : sink . ID ( ) } fsm . init ( ) select { case r . fsmMutateCh <- fsm : case <- r . shutdownCh : return ErrRaftShutdown } if err := fsm . Error ( ) ; err != nil { panic ( fmt . Errorf ( "failed to restore snapshot: %v" , err ) ) } r . setLastLog ( lastIndex , term ) r . setLastApplied ( lastIndex ) r . setLastSnapshot ( lastIndex , term ) r . logger . Info ( fmt . Sprintf ( "Restored user snapshot (index %d)" , lastIndex ) ) return nil }
946	func ( r * Raft ) appendConfigurationEntry ( future * configurationChangeFuture ) { configuration , err := nextConfiguration ( r . configurations . latest , r . configurations . latestIndex , future . req ) if err != nil { future . respond ( err ) return } r . logger . Info ( fmt . Sprintf ( "Updating configuration with %s (%v, %v) to %+v" , future . req . command , future . req . serverID , future . req . serverAddress , configuration . Servers ) ) if r . protocolVersion < 2 { future . log = Log { Type : LogRemovePeerDeprecated , Data : encodePeers ( configuration , r . trans ) , } } else { future . log = Log { Type : LogConfiguration , Data : encodeConfiguration ( configuration ) , } } r . dispatchLogs ( [ ] * logFuture { & future . logFuture } ) index := future . Index ( ) r . configurations . latest = configuration r . configurations . latestIndex = index r . leaderState . commitment . setConfiguration ( configuration ) r . startStopReplication ( ) }
947	func ( r * Raft ) dispatchLogs ( applyLogs [ ] * logFuture ) { now := time . Now ( ) defer metrics . MeasureSince ( [ ] string { "raft" , "leader" , "dispatchLog" } , now ) term := r . getCurrentTerm ( ) lastIndex := r . getLastIndex ( ) n := len ( applyLogs ) logs := make ( [ ] * Log , n ) metrics . SetGauge ( [ ] string { "raft" , "leader" , "dispatchNumLogs" } , float32 ( n ) ) for idx , applyLog := range applyLogs { applyLog . dispatch = now lastIndex ++ applyLog . log . Index = lastIndex applyLog . log . Term = term logs [ idx ] = & applyLog . log r . leaderState . inflight . PushBack ( applyLog ) } if err := r . logs . StoreLogs ( logs ) ; err != nil { r . logger . Error ( fmt . Sprintf ( "Failed to commit logs: %v" , err ) ) for _ , applyLog := range applyLogs { applyLog . respond ( err ) } r . setState ( Follower ) return } r . leaderState . commitment . match ( r . localID , lastIndex ) r . setLastLog ( lastIndex , term ) for _ , f := range r . leaderState . replState { asyncNotifyCh ( f . triggerCh ) } }
948	func ( r * Raft ) processLogs ( index uint64 , future * logFuture ) { lastApplied := r . getLastApplied ( ) if index <= lastApplied { r . logger . Warn ( fmt . Sprintf ( "Skipping application of old log: %d" , index ) ) return } for idx := r . getLastApplied ( ) + 1 ; idx <= index ; idx ++ { if future != nil && future . log . Index == idx { r . processLog ( & future . log , future ) } else { l := new ( Log ) if err := r . logs . GetLog ( idx , l ) ; err != nil { r . logger . Error ( fmt . Sprintf ( "Failed to get log at %d: %v" , idx , err ) ) panic ( err ) } r . processLog ( l , nil ) } r . setLastApplied ( idx ) } }
949	func ( r * Raft ) processLog ( l * Log , future * logFuture ) { switch l . Type { case LogBarrier : fallthrough case LogCommand : select { case r . fsmMutateCh <- & commitTuple { l , future } : case <- r . shutdownCh : if future != nil { future . respond ( ErrRaftShutdown ) } } return case LogConfiguration : case LogAddPeerDeprecated : case LogRemovePeerDeprecated : case LogNoop : default : panic ( fmt . Errorf ( "unrecognized log type: %#v" , l ) ) } if future != nil { future . respond ( nil ) } }
950	func ( r * Raft ) processRPC ( rpc RPC ) { if err := r . checkRPCHeader ( rpc ) ; err != nil { rpc . Respond ( nil , err ) return } switch cmd := rpc . Command . ( type ) { case * AppendEntriesRequest : r . appendEntries ( rpc , cmd ) case * RequestVoteRequest : r . requestVote ( rpc , cmd ) case * InstallSnapshotRequest : r . installSnapshot ( rpc , cmd ) default : r . logger . Error ( fmt . Sprintf ( "Got unexpected command: %#v" , rpc . Command ) ) rpc . Respond ( nil , fmt . Errorf ( "unexpected command" ) ) } }
951	func ( r * Raft ) processHeartbeat ( rpc RPC ) { defer metrics . MeasureSince ( [ ] string { "raft" , "rpc" , "processHeartbeat" } , time . Now ( ) ) select { case <- r . shutdownCh : return default : } switch cmd := rpc . Command . ( type ) { case * AppendEntriesRequest : r . appendEntries ( rpc , cmd ) default : r . logger . Error ( fmt . Sprintf ( "Expected heartbeat, got command: %#v" , rpc . Command ) ) rpc . Respond ( nil , fmt . Errorf ( "unexpected command" ) ) } }
952	func ( r * Raft ) setLastContact ( ) { r . lastContactLock . Lock ( ) r . lastContact = time . Now ( ) r . lastContactLock . Unlock ( ) }
953	func ( r * Raft ) persistVote ( term uint64 , candidate [ ] byte ) error { if err := r . stable . SetUint64 ( keyLastVoteTerm , term ) ; err != nil { return err } if err := r . stable . Set ( keyLastVoteCand , candidate ) ; err != nil { return err } return nil }
954	func ( r * Raft ) setCurrentTerm ( t uint64 ) { if err := r . stable . SetUint64 ( keyCurrentTerm , t ) ; err != nil { panic ( fmt . Errorf ( "failed to save current term: %v" , err ) ) } r . raftState . setCurrentTerm ( t ) }
955	func ( r * Raft ) setState ( state RaftState ) { r . setLeader ( "" ) oldState := r . raftState . getState ( ) r . raftState . setState ( state ) if oldState != state { r . observe ( state ) } }
956	func ( c * commitment ) getCommitIndex ( ) uint64 { c . Lock ( ) defer c . Unlock ( ) return c . commitIndex }
957	func ( c * commitment ) recalculate ( ) { if len ( c . matchIndexes ) == 0 { return } matched := make ( [ ] uint64 , 0 , len ( c . matchIndexes ) ) for _ , idx := range c . matchIndexes { matched = append ( matched , idx ) } sort . Sort ( uint64Slice ( matched ) ) quorumMatchIndex := matched [ ( len ( matched ) - 1 ) / 2 ] if quorumMatchIndex > c . commitIndex && quorumMatchIndex >= c . startIndex { c . commitIndex = quorumMatchIndex asyncNotifyCh ( c . commitCh ) } }
958	func randomTimeout ( minVal time . Duration ) <- chan time . Time { if minVal == 0 { return nil } extra := ( time . Duration ( rand . Int63 ( ) ) % minVal ) return time . After ( minVal + extra ) }
959	func generateUUID ( ) string { buf := make ( [ ] byte , 16 ) if _ , err := crand . Read ( buf ) ; err != nil { panic ( fmt . Errorf ( "failed to read random bytes: %v" , err ) ) } return fmt . Sprintf ( "%08x-%04x-%04x-%04x-%12x" , buf [ 0 : 4 ] , buf [ 4 : 6 ] , buf [ 6 : 8 ] , buf [ 8 : 10 ] , buf [ 10 : 16 ] ) }
960	func decodeMsgPack ( buf [ ] byte , out interface { } ) error { r := bytes . NewBuffer ( buf ) hd := codec . MsgpackHandle { } dec := codec . NewDecoder ( r , & hd ) return dec . Decode ( out ) }
961	func encodeMsgPack ( in interface { } ) ( * bytes . Buffer , error ) { buf := bytes . NewBuffer ( nil ) hd := codec . MsgpackHandle { } enc := codec . NewEncoder ( buf , & hd ) err := enc . Encode ( in ) return buf , err }
962	func backoff ( base time . Duration , round , limit uint64 ) time . Duration { power := min ( round , limit ) for power > 2 { base *= 2 power -- } return base }
963	func newApplySource ( seed string ) * applySource { h := fnv . New32 ( ) h . Write ( [ ] byte ( seed ) ) s := & applySource { seed : int64 ( h . Sum32 ( ) ) } s . reset ( ) return s }
964	func ( a * applySource ) reset ( ) { a . rnd = rand . New ( rand . NewSource ( a . seed ) ) }
965	func DefaultConfig ( ) * Config { return & Config { ProtocolVersion : ProtocolVersionMax , HeartbeatTimeout : 1000 * time . Millisecond , ElectionTimeout : 1000 * time . Millisecond , CommitTimeout : 50 * time . Millisecond , MaxAppendEntries : 64 , ShutdownOnRemove : true , TrailingLogs : 10240 , SnapshotInterval : 120 * time . Second , SnapshotThreshold : 8192 , LeaderLeaseTimeout : 500 * time . Millisecond , LogLevel : "DEBUG" , } }
966	func ValidateConfig ( config * Config ) error { protocolMin := ProtocolVersionMin if protocolMin == 0 { protocolMin = 1 } if config . ProtocolVersion < protocolMin || config . ProtocolVersion > ProtocolVersionMax { return fmt . Errorf ( "Protocol version %d must be >= %d and <= %d" , config . ProtocolVersion , protocolMin , ProtocolVersionMax ) } if len ( config . LocalID ) == 0 { return fmt . Errorf ( "LocalID cannot be empty" ) } if config . HeartbeatTimeout < 5 * time . Millisecond { return fmt . Errorf ( "Heartbeat timeout is too low" ) } if config . ElectionTimeout < 5 * time . Millisecond { return fmt . Errorf ( "Election timeout is too low" ) } if config . CommitTimeout < time . Millisecond { return fmt . Errorf ( "Commit timeout is too low" ) } if config . MaxAppendEntries <= 0 { return fmt . Errorf ( "MaxAppendEntries must be positive" ) } if config . MaxAppendEntries > 1024 { return fmt . Errorf ( "MaxAppendEntries is too large" ) } if config . SnapshotInterval < 5 * time . Millisecond { return fmt . Errorf ( "Snapshot interval is too low" ) } if config . LeaderLeaseTimeout < 5 * time . Millisecond { return fmt . Errorf ( "Leader lease timeout is too low" ) } if config . LeaderLeaseTimeout > config . HeartbeatTimeout { return fmt . Errorf ( "Leader lease timeout cannot be larger than heartbeat timeout" ) } if config . ElectionTimeout < config . HeartbeatTimeout { return fmt . Errorf ( "Election timeout must be equal or greater than Heartbeat Timeout" ) } return nil }
967	func ( r * Raft ) runSnapshots ( ) { for { select { case <- randomTimeout ( r . conf . SnapshotInterval ) : if ! r . shouldSnapshot ( ) { continue } if _ , err := r . takeSnapshot ( ) ; err != nil { r . logger . Error ( fmt . Sprintf ( "Failed to take snapshot: %v" , err ) ) } case future := <- r . userSnapshotCh : id , err := r . takeSnapshot ( ) if err != nil { r . logger . Error ( fmt . Sprintf ( "Failed to take snapshot: %v" , err ) ) } else { future . opener = func ( ) ( * SnapshotMeta , io . ReadCloser , error ) { return r . snapshots . Open ( id ) } } future . respond ( err ) case <- r . shutdownCh : return } } }
968	func ( r * Raft ) shouldSnapshot ( ) bool { lastSnap , _ := r . getLastSnapshot ( ) lastIdx , err := r . logs . LastIndex ( ) if err != nil { r . logger . Error ( fmt . Sprintf ( "Failed to get last log index: %v" , err ) ) return false } delta := lastIdx - lastSnap return delta >= r . conf . SnapshotThreshold }
969	func ( r * Raft ) takeSnapshot ( ) ( string , error ) { defer metrics . MeasureSince ( [ ] string { "raft" , "snapshot" , "takeSnapshot" } , time . Now ( ) ) snapReq := & reqSnapshotFuture { } snapReq . init ( ) select { case r . fsmSnapshotCh <- snapReq : case <- r . shutdownCh : return "" , ErrRaftShutdown } if err := snapReq . Error ( ) ; err != nil { if err != ErrNothingNewToSnapshot { err = fmt . Errorf ( "failed to start snapshot: %v" , err ) } return "" , err } defer snapReq . snapshot . Release ( ) configReq := & configurationsFuture { } configReq . init ( ) select { case r . configurationsCh <- configReq : case <- r . shutdownCh : return "" , ErrRaftShutdown } if err := configReq . Error ( ) ; err != nil { return "" , err } committed := configReq . configurations . committed committedIndex := configReq . configurations . committedIndex if snapReq . index < committedIndex { return "" , fmt . Errorf ( "cannot take snapshot now, wait until the configuration entry at %v has been applied (have applied %v)" , committedIndex , snapReq . index ) } r . logger . Info ( fmt . Sprintf ( "Starting snapshot up to %d" , snapReq . index ) ) start := time . Now ( ) version := getSnapshotVersion ( r . protocolVersion ) sink , err := r . snapshots . Create ( version , snapReq . index , snapReq . term , committed , committedIndex , r . trans ) if err != nil { return "" , fmt . Errorf ( "failed to create snapshot: %v" , err ) } metrics . MeasureSince ( [ ] string { "raft" , "snapshot" , "create" } , start ) start = time . Now ( ) if err := snapReq . snapshot . Persist ( sink ) ; err != nil { sink . Cancel ( ) return "" , fmt . Errorf ( "failed to persist snapshot: %v" , err ) } metrics . MeasureSince ( [ ] string { "raft" , "snapshot" , "persist" } , start ) if err := sink . Close ( ) ; err != nil { return "" , fmt . Errorf ( "failed to close snapshot: %v" , err ) } r . setLastSnapshot ( snapReq . index , snapReq . term ) if err := r . compactLogs ( snapReq . index ) ; err != nil { return "" , err } r . logger . Info ( fmt . Sprintf ( "Snapshot to %d complete" , snapReq . index ) ) return sink . ID ( ) , nil }
970	func ( r * Raft ) compactLogs ( snapIdx uint64 ) error { defer metrics . MeasureSince ( [ ] string { "raft" , "compactLogs" } , time . Now ( ) ) minLog , err := r . logs . FirstIndex ( ) if err != nil { return fmt . Errorf ( "failed to get first log index: %v" , err ) } lastLogIdx , _ := r . getLastLog ( ) if lastLogIdx <= r . conf . TrailingLogs { return nil } maxLog := min ( snapIdx , lastLogIdx - r . conf . TrailingLogs ) r . logger . Info ( fmt . Sprintf ( "Compacting logs from %d to %d" , minLog , maxLog ) ) if err := r . logs . DeleteRange ( minLog , maxLog ) ; err != nil { return fmt . Errorf ( "log compaction failed: %v" , err ) } return nil }
971	func WebpackCheck ( r * Runner ) error { fmt . Println ( "~~~ Checking webpack.config.js ~~~" ) if ! r . App . WithWebpack { return nil } box := webpack . Templates f , err := box . FindString ( "webpack.config.js.tmpl" ) if err != nil { return err } tmpl , err := template . New ( "webpack" ) . Parse ( f ) if err != nil { return err } bb := & bytes . Buffer { } err = tmpl . Execute ( bb , map [ string ] interface { } { "opts" : & webpack . Options { App : r . App , } , } ) if err != nil { return err } b , err := ioutil . ReadFile ( "webpack.config.js" ) if err != nil { return err } if string ( b ) == bb . String ( ) { return nil } if ! ask ( "Your webpack.config.js file is different from the latest Buffalo template.\nWould you like to replace yours with the latest template?" ) \n { fmt . Println ( "\tSkipping webpack.config.js" ) \t } return nil wf , err := os . Create ( "webpack.config.js" ) if err != nil { return err } _ , err = wf . Write ( bb . Bytes ( ) ) }
972	func New ( opts * Options ) ( * genny . Generator , error ) { g := genny . New ( ) if err := opts . Validate ( ) ; err != nil { return g , err } if opts . Provider == "none" { return g , nil } box := packr . New ( "buffalo:genny:vcs" , "../vcs/templates" ) s , err := box . FindString ( "ignore.tmpl" ) if err != nil { return g , err } p := opts . Provider n := fmt . Sprintf ( ".%signore" , p ) g . File ( genny . NewFileS ( n , s ) ) g . Command ( exec . Command ( p , "init" ) ) args := [ ] string { "add" , "." } if p == "bzr" { args = append ( args , "-q" ) } g . Command ( exec . Command ( p , args ... ) ) g . Command ( exec . Command ( p , "commit" , "-q" , "-m" , "Initial Commit" ) ) return g , nil }
973	func UnixSocket ( addr string ) ( * Listener , error ) { listener , err := net . Listen ( "unix" , addr ) if err != nil { return nil , err } return & Listener { Server : & http . Server { } , Listener : listener , } , nil }
974	func ( e ErrorHandlers ) Get ( status int ) ErrorHandler { if eh , ok := e [ status ] ; ok { return eh } if eh , ok := e [ 0 ] ; ok { return eh } return defaultErrorHandler }
975	func ( a * App ) PanicHandler ( next Handler ) Handler { return func ( c Context ) error { defer func ( ) { r := recover ( ) var err error if r != nil { switch t := r . ( type ) { case error : err = t case string : err = errors . New ( t ) default : err = errors . New ( fmt . Sprint ( t ) ) } err = err events . EmitError ( events . ErrPanic , err , map [ string ] interface { } { "context" : c , "app" : a , } , ) eh := a . ErrorHandlers . Get ( 500 ) eh ( 500 , err , c ) } } ( ) return next ( c ) } }
976	func ( s templateRenderer ) partialFeeder ( name string ) ( string , error ) { ct := strings . ToLower ( s . contentType ) d , f := filepath . Split ( name ) name = filepath . Join ( d , "_" + f ) name = fixExtension ( name , ct ) return s . TemplatesBox . FindString ( name ) }
977	func New ( opts Options ) * Engine { if opts . Helpers == nil { opts . Helpers = map [ string ] interface { } { } } if opts . TemplateEngines == nil { opts . TemplateEngines = map [ string ] TemplateEngine { } } if _ , ok := opts . TemplateEngines [ "html" ] ; ! ok { opts . TemplateEngines [ "html" ] = plush . BuffaloRenderer } if _ , ok := opts . TemplateEngines [ "text" ] ; ! ok { opts . TemplateEngines [ "text" ] = plush . BuffaloRenderer } if _ , ok := opts . TemplateEngines [ "txt" ] ; ! ok { opts . TemplateEngines [ "txt" ] = plush . BuffaloRenderer } if _ , ok := opts . TemplateEngines [ "js" ] ; ! ok { opts . TemplateEngines [ "js" ] = plush . BuffaloRenderer } if _ , ok := opts . TemplateEngines [ "md" ] ; ! ok { opts . TemplateEngines [ "md" ] = MDTemplateEngine } if _ , ok := opts . TemplateEngines [ "tmpl" ] ; ! ok { opts . TemplateEngines [ "tmpl" ] = GoTemplateEngine } if opts . DefaultContentType == "" { opts . DefaultContentType = "text/html; charset=utf-8" } e := & Engine { Options : opts , } return e }
978	func ( m * Message ) WriteTo ( w io . Writer ) ( int64 , error ) { mw := & messageWriter { w : w } mw . writeMessage ( m ) return mw . n , mw . err }
979	func ( sm SMTPSender ) Send ( message Message ) error { gm := gomail . NewMessage ( ) gm . SetHeader ( "From" , message . From ) gm . SetHeader ( "To" , message . To ... ) gm . SetHeader ( "Subject" , message . Subject ) gm . SetHeader ( "Cc" , message . CC ... ) gm . SetHeader ( "Bcc" , message . Bcc ... ) sm . addBodies ( message , gm ) sm . addAttachments ( message , gm ) for field , value := range message . Headers { gm . SetHeader ( field , value ) } err := sm . Dialer . DialAndSend ( gm ) if err != nil { return err } return nil }
980	func NewSMTPSender ( host string , port string , user string , password string ) ( SMTPSender , error ) { iport , err := strconv . Atoi ( port ) if err != nil { return SMTPSender { } , errors . New ( "invalid port for the SMTP mail" ) } dialer := & gomail . Dialer { Host : host , Port : iport , } if user != "" { dialer . Username = user dialer . Password = password } return SMTPSender { Dialer : dialer , } , nil }
981	func ( d * DefaultContext ) Param ( key string ) string { return d . Params ( ) . Get ( key ) }
982	func ( d * DefaultContext ) Set ( key string , value interface { } ) { d . moot . Lock ( ) d . data [ key ] = value d . moot . Unlock ( ) }
983	func ( d * DefaultContext ) Value ( key interface { } ) interface { } { if k , ok := key . ( string ) ; ok { d . moot . RLock ( ) defer d . moot . RUnlock ( ) if v , ok := d . data [ k ] ; ok { return v } } return d . Context . Value ( key ) }
984	func ( d * DefaultContext ) Redirect ( status int , url string , args ... interface { } ) error { d . Flash ( ) . persist ( d . Session ( ) ) if strings . HasSuffix ( url , "Path()" ) { if len ( args ) > 1 { return fmt . Errorf ( "you must pass only a map[string]interface{} to a route path: %T" , args ) } var m map [ string ] interface { } if len ( args ) == 1 { rv := reflect . Indirect ( reflect . ValueOf ( args [ 0 ] ) ) if ! rv . Type ( ) . ConvertibleTo ( mapType ) { return fmt . Errorf ( "you must pass only a map[string]interface{} to a route path: %T" , args ) } m = rv . Convert ( mapType ) . Interface ( ) . ( map [ string ] interface { } ) } h , ok := d . Value ( strings . TrimSuffix ( url , "()" ) ) . ( RouteHelperFunc ) if ! ok { return fmt . Errorf ( "could not find a route helper named %s" , url ) } url , err := h ( m ) if err != nil { return err } http . Redirect ( d . Response ( ) , d . Request ( ) , string ( url ) , status ) return nil } if len ( args ) > 0 { url = fmt . Sprintf ( url , args ... ) } http . Redirect ( d . Response ( ) , d . Request ( ) , url , status ) return nil }
985	func ( d * DefaultContext ) File ( name string ) ( binding . File , error ) { req := d . Request ( ) if err := req . ParseMultipartForm ( 5 * 1024 * 1024 ) ; err != nil { return binding . File { } , err } f , h , err := req . FormFile ( name ) bf := binding . File { File : f , FileHeader : h , } if err != nil { return bf , err } return bf , nil }
986	func ( d * DefaultContext ) MarshalJSON ( ) ( [ ] byte , error ) { m := map [ string ] interface { } { } data := d . Data ( ) for k , v := range data { if _ , ok := v . ( * DefaultContext ) ; ok { continue } if _ , err := json . Marshal ( v ) ; err == nil { m [ k ] = v } } return json . Marshal ( m ) }
987	func New ( opts * Options ) ( * genny . Group , error ) { if err := opts . Validate ( ) ; err != nil { return nil , err } gg , err := core . New ( opts . Options ) if err != nil { return gg , err } g := genny . New ( ) data := map [ string ] interface { } { "opts" : opts , } helpers := template . FuncMap { } t := gogen . TemplateTransformer ( data , helpers ) g . Transformer ( t ) g . Box ( packr . New ( "buffalo:genny:newapp:api" , "../api/templates" ) ) gg . Add ( g ) return gg , nil }
988	func New ( opts Options ) * App { LoadPlugins ( ) envy . Load ( ) opts = optionsWithDefaults ( opts ) a := & App { Options : opts , ErrorHandlers : ErrorHandlers { 404 : defaultErrorHandler , 500 : defaultErrorHandler , } , router : mux . NewRouter ( ) , moot : & sync . RWMutex { } , routes : RouteList { } , children : [ ] * App { } , } dem := a . defaultErrorMiddleware a . Middleware = newMiddlewareStack ( dem ) notFoundHandler := func ( errorf string , code int ) http . HandlerFunc { return func ( res http . ResponseWriter , req * http . Request ) { c := a . newContext ( RouteInfo { } , res , req ) err := fmt . Errorf ( errorf , req . Method , req . URL . Path ) a . ErrorHandlers . Get ( code ) ( code , err , c ) } } a . router . NotFoundHandler = notFoundHandler ( "path not found: %s %s" , 404 ) a . router . MethodNotAllowedHandler = notFoundHandler ( "method not found: %s %s" , 405 ) if a . MethodOverride == nil { a . MethodOverride = MethodOverride } a . Use ( a . PanicHandler ) a . Use ( RequestLogger ) a . Use ( sessionSaver ) return a }
989	func DeprecrationsCheck ( r * Runner ) error { fmt . Println ( "~~~ Checking for deprecations ~~~" ) b , err := ioutil . ReadFile ( "main.go" ) if err != nil { return err } if bytes . Contains ( b , [ ] byte ( "app.Start" ) ) { r . Warnings = append ( r . Warnings , "app.Start has been removed in v0.11.0. Use app.Serve Instead. [main.go]" ) } return filepath . Walk ( filepath . Join ( r . App . Root , "actions" ) , func ( path string , info os . FileInfo , _ error ) error { if info . IsDir ( ) { return nil } if filepath . Ext ( path ) != ".go" { return nil } b , err := ioutil . ReadFile ( path ) if err != nil { return err } if bytes . Contains ( b , [ ] byte ( "Websocket()" ) ) { r . Warnings = append ( r . Warnings , fmt . Sprintf ( "buffalo.Context#Websocket has been deprecated in v0.11.0, and removed in v0.12.0. Use github.com/gorilla/websocket directly. [%s]" , path ) ) } if bytes . Contains ( b , [ ] byte ( "meta.Name" ) ) { r . Warnings = append ( r . Warnings , fmt . Sprintf ( "meta.Name has been deprecated in v0.11.0, and removed in v0.12.0. Use github.com/markbates/inflect.Name directly. [%s]" , path ) ) } if bytes . Contains ( b , [ ] byte ( "generators.Find(" ) ) { r . Warnings = append ( r . Warnings , fmt . Sprintf ( "generators.Find(string) has been deprecated in v0.11.0, and removed in v0.12.0. Use generators.FindByBox() instead. [%s]" , path ) ) } if bytes . Contains ( b , [ ] byte ( "T.CookieName" ) ) { b = bytes . Replace ( b , [ ] byte ( "T.CookieName" ) , [ ] byte ( "T.LanguageExtractorOptions[\"CookieName\"]" ) , \" ) } \" - 1 if bytes . Contains ( b , [ ] byte ( "T.SessionName" ) ) { b = bytes . Replace ( b , [ ] byte ( "T.SessionName" ) , [ ] byte ( "T.LanguageExtractorOptions[\"SessionName\"]" ) , \" ) } \" } ) }
990	func ( v BaseResource ) List ( c Context ) error { return c . Error ( 404 , errors . New ( "resource not implemented" ) ) }
991	func ( s funcRenderer ) Render ( w io . Writer , data Data ) error { return s . renderFunc ( w , data ) }
992	func ( s * Session ) Save ( ) error { return s . Session . Save ( s . req , s . res ) }
993	func ( s * Session ) GetOnce ( name interface { } ) interface { } { if x , ok := s . Session . Values [ name ] ; ok { s . Delete ( name ) return x } return nil }
994	func ( s * Session ) Set ( name , value interface { } ) { s . Session . Values [ name ] = value }
995	func ( s * Session ) Clear ( ) { for k := range s . Session . Values { s . Delete ( k ) } }
996	func ( a * App ) getSession ( r * http . Request , w http . ResponseWriter ) * Session { if a . root != nil { return a . root . getSession ( r , w ) } session , _ := a . SessionStore . Get ( r , a . SessionName ) return & Session { Session : session , req : r , res : w , } }
997	func New ( opts * Options ) ( * genny . Generator , error ) { g := genny . New ( ) if err := opts . Validate ( ) ; err != nil { return g , err } data := map [ string ] interface { } { "opts" : opts , } t := gogen . TemplateTransformer ( data , template . FuncMap { } ) g . Transformer ( t ) g . RunFn ( func ( r * genny . Runner ) error { return genFile ( r , opts ) } ) return g , nil }
998	func New ( opts * Options ) ( * genny . Generator , error ) { g := genny . New ( ) if err := opts . Validate ( ) ; err != nil { return g , err } g . RunFn ( func ( r * genny . Runner ) error { if _ , err := r . LookPath ( "npm" ) ; err != nil { return errors . New ( "could not find npm executable" ) } return nil } ) g . Box ( Templates ) data := map [ string ] interface { } { "opts" : opts , } t := gogen . TemplateTransformer ( data , gogen . TemplateHelpers ) g . Transformer ( t ) g . Transformer ( genny . Dot ( ) ) g . RunFn ( func ( r * genny . Runner ) error { return installPkgs ( r , opts ) } ) return g , nil }
999	func New ( opts * Options ) ( * genny . Generator , error ) { g := genny . New ( ) if err := opts . Validate ( ) ; err != nil { return g , err } g . Box ( packr . New ( "buffalo:genny:refresh" , "../refresh/templates" ) ) ctx := plush . NewContext ( ) ctx . Set ( "app" , opts . App ) g . Transformer ( plushgen . Transformer ( ctx ) ) g . Transformer ( genny . Dot ( ) ) return g , nil }
1000	func NewMessage ( settings ... MessageSetting ) * Message { m := & Message { header : make ( header ) , charset : "UTF-8" , encoding : QuotedPrintable , } m . applySettings ( settings ) if m . encoding == Base64 { m . hEncoder = bEncoding } else { m . hEncoder = qEncoding } return m }
1001	func ( m * Message ) Reset ( ) { for k := range m . header { delete ( m . header , k ) } m . parts = nil m . attachments = nil m . embedded = nil }
1002	func ( m * Message ) SetHeader ( field string , value ... string ) { m . encodeHeader ( value ) m . header [ field ] = value }
1003	func ( m * Message ) SetHeaders ( h map [ string ] [ ] string ) { for k , v := range h { m . SetHeader ( k , v ... ) } }
1004	func ( m * Message ) SetAddressHeader ( field , address , name string ) { m . header [ field ] = [ ] string { m . FormatAddress ( address , name ) } }
1005	func ( m * Message ) FormatAddress ( address , name string ) string { if name == "" { return address } enc := m . encodeString ( name ) if enc == name { m . buf . WriteByte ( '"' ) for i := 0 ; i < len ( name ) ; i ++ { b := name [ i ] if b == '\\' || b == '"' { m . buf . WriteByte ( '\\' ) } m . buf . WriteByte ( b ) } m . buf . WriteByte ( '"' ) } else if hasSpecials ( name ) { m . buf . WriteString ( bEncoding . Encode ( m . charset , name ) ) } else { m . buf . WriteString ( enc ) } m . buf . WriteString ( " <" ) m . buf . WriteString ( address ) m . buf . WriteByte ( '>' ) addr := m . buf . String ( ) m . buf . Reset ( ) return addr }
1006	func ( m * Message ) SetDateHeader ( field string , date time . Time ) { m . header [ field ] = [ ] string { m . FormatDate ( date ) } }
1007	func ( m * Message ) FormatDate ( date time . Time ) string { return date . Format ( time . RFC1123Z ) }
1008	func ( m * Message ) SetBody ( contentType , body string , settings ... PartSetting ) { m . SetBodyWriter ( contentType , newCopier ( body ) , settings ... ) }
1009	func SetPartEncoding ( e Encoding ) PartSetting { return PartSetting ( func ( p * part ) { p . encoding = e } ) }
1010	func SetHeader ( h map [ string ] [ ] string ) FileSetting { return func ( f * file ) { for k , v := range h { f . Header [ k ] = v } } }
1011	func SetCopyFunc ( f func ( io . Writer ) error ) FileSetting { return func ( fi * file ) { fi . CopyFunc = f } }
1012	func ( m * Message ) AttachReader ( name string , r io . Reader , settings ... FileSetting ) { m . attachments = m . appendFile ( m . attachments , fileFromReader ( name , r ) , settings ) }
1013	func ( m * Message ) Attach ( filename string , settings ... FileSetting ) { m . attachments = m . appendFile ( m . attachments , fileFromFilename ( filename ) , settings ) }
1014	func ( m * Message ) EmbedReader ( name string , r io . Reader , settings ... FileSetting ) { m . embedded = m . appendFile ( m . embedded , fileFromReader ( name , r ) , settings ) }
1015	func ( m * Message ) Embed ( filename string , settings ... FileSetting ) { m . embedded = m . appendFile ( m . embedded , fileFromFilename ( filename ) , settings ) }
1016	func ValidateTemplates ( walk packd . Walker , tvs [ ] TemplateValidator ) genny . RunFn { if len ( tvs ) == 0 { return func ( r * genny . Runner ) error { return nil } } return func ( r * genny . Runner ) error { var errs [ ] string err := packd . SkipWalker ( walk , packd . CommonSkipPrefixes , func ( path string , file packd . File ) error { info , err := file . FileInfo ( ) if err != nil { return err } if info . IsDir ( ) { return nil } f := genny . NewFile ( path , file ) for _ , tv := range tvs { err := safe . Run ( func ( ) { if err := tv ( f ) ; err != nil { errs = append ( errs , fmt . Sprintf ( "template error in file %s: %s" , path , err . Error ( ) ) ) } } ) if err != nil { return err } } return nil } ) if err != nil { return err } if len ( errs ) == 0 { return nil } return errors . New ( strings . Join ( errs , "\n" ) ) } }
1017	func PlushValidator ( f genny . File ) error { if ! genny . HasExt ( f , ".html" , ".md" , ".plush" ) { return nil } _ , err := plush . Parse ( f . String ( ) ) return err }
1018	func ( opts * Options ) Validate ( ) error { if opts . App . IsZero ( ) { opts . App = meta . New ( "." ) } if len ( opts . Name . String ( ) ) == 0 { return errors . New ( "you must supply a name for your mailer" ) } return nil }
1019	func LoadPlugins ( ) error { var err error oncer . Do ( "events.LoadPlugins" , func ( ) { if envy . Get ( "GO_ENV" , "development" ) == "test" { return } plugs , err := plugins . Available ( ) if err != nil { err = err return } for _ , cmds := range plugs { for _ , c := range cmds { if c . BuffaloCommand != "events" { continue } err := func ( c plugins . Command ) error { return safe . RunE ( func ( ) error { n := fmt . Sprintf ( "[PLUGIN] %s %s" , c . Binary , c . Name ) fn := func ( e events . Event ) { b , err := json . Marshal ( e ) if err != nil { fmt . Println ( "error trying to marshal event" , e , err ) return } cmd := exec . Command ( c . Binary , c . UseCommand , string ( b ) ) cmd . Stderr = os . Stderr cmd . Stdout = os . Stdout cmd . Stdin = os . Stdin if err := cmd . Run ( ) ; err != nil { fmt . Println ( "error trying to send event" , strings . Join ( cmd . Args , " " ) , err ) } } _ , err := events . NamedListen ( n , events . Filter ( c . ListenFor , fn ) ) if err != nil { return err } return nil } ) } ( c ) if err != nil { err = err return } } } } ) return err }
1020	func ( w * Response ) WriteHeader ( i int ) { w . Status = i w . ResponseWriter . WriteHeader ( i ) }
1021	func ( w * Response ) Write ( b [ ] byte ) ( int , error ) { w . Size = binary . Size ( b ) return w . ResponseWriter . Write ( b ) }
1022	func ( w * Response ) Flush ( ) { if f , ok := w . ResponseWriter . ( http . Flusher ) ; ok { f . Flush ( ) } }
1023	func ( w * Response ) CloseNotify ( ) <- chan bool { if cn , ok := w . ResponseWriter . ( closeNotifier ) ; ok { return cn . CloseNotify ( ) } return nil }
1024	func Run ( ) error { fmt . Printf ( "! This updater will attempt to update your application to Buffalo version: %s\n" , \n ) runtime . Version if ! ask ( "Do you wish to continue?" ) { fmt . Println ( "~~~ cancelling update ~~~" ) return nil } r := & Runner { App : meta . New ( "." ) , Warnings : [ ] string { } , } defer func ( ) { if len ( r . Warnings ) == 0 { return } fmt . Println ( "\n\n----------------------------" ) \n \n } fmt . Printf ( "!!! (%d) Warnings Were Found !!!\n\n" , \n ) \n }
1025	func onlyRelevantFiles ( p string , fi os . FileInfo , err error , fn func ( p string ) error ) error { if err != nil { return err } if fi . IsDir ( ) { base := filepath . Base ( p ) if strings . HasPrefix ( base , "_" ) { return filepath . SkipDir } for _ , n := range [ ] string { "vendor" , "node_modules" , ".git" } { if base == n { return filepath . SkipDir } } return nil } ext := filepath . Ext ( p ) if ext != ".go" { return nil } return fn ( p ) }
1026	func GoTemplateEngine ( input string , data map [ string ] interface { } , helpers map [ string ] interface { } ) ( string , error ) { data [ "nilOpts" ] = map [ string ] interface { } { } t := template . New ( input ) if helpers != nil { t = t . Funcs ( helpers ) } t , err := t . Parse ( input ) if err != nil { return "" , err } bb := & bytes . Buffer { } err = t . Execute ( bb , data ) return bb . String ( ) , err }
1027	func ( a * App ) GET ( p string , h Handler ) * RouteInfo { return a . addRoute ( "GET" , p , h ) }
1028	func ( a * App ) Redirect ( status int , from , to string ) * RouteInfo { return a . GET ( from , func ( c Context ) error { return c . Redirect ( status , to ) } ) }
1029	func ( a * App ) ANY ( p string , h Handler ) { a . GET ( p , h ) a . POST ( p , h ) a . PUT ( p , h ) a . PATCH ( p , h ) a . HEAD ( p , h ) a . OPTIONS ( p , h ) a . DELETE ( p , h ) }
1030	func ( a * App ) buildRouteName ( p string ) string { if p == "/" || p == "" { return "root" } resultParts := [ ] string { } parts := strings . Split ( p , "/" ) for index , part := range parts { if strings . Contains ( part , "{" ) || part == "" { continue } shouldSingularize := ( len ( parts ) > index + 1 ) && strings . Contains ( parts [ index + 1 ] , "{" ) if shouldSingularize { part = flect . Singularize ( part ) } if parts [ index ] == "new" || parts [ index ] == "edit" { resultParts = append ( [ ] string { part } , resultParts ... ) continue } if index > 0 && strings . Contains ( parts [ index - 1 ] , "}" ) { resultParts = append ( resultParts , part ) continue } resultParts = append ( resultParts , part ) } if len ( resultParts ) == 0 { return "unnamed" } underscore := strings . TrimSpace ( strings . Join ( resultParts , "_" ) ) return name . VarCase ( underscore ) }
1031	func New ( opts * Options ) ( * genny . Group , error ) { gg := & genny . Group { } if err := opts . Validate ( ) ; err != nil { return gg , err } if ! opts . SkipInit { g , err := initGenerator ( opts ) if err != nil { return gg , err } gg . Add ( g ) } g := genny . New ( ) h := template . FuncMap { } data := map [ string ] interface { } { "opts" : opts , } t := gogen . TemplateTransformer ( data , h ) g . Transformer ( t ) fn := opts . Name . File ( ) . String ( ) g . File ( genny . NewFileS ( "mailers/" + fn + ".go.tmpl" , mailerTmpl ) ) g . File ( genny . NewFileS ( "templates/mail/" + fn + ".html.tmpl" , mailTmpl ) ) gg . Add ( g ) return gg , nil }
1032	func NewDialer ( host string , port int , username , password string ) * Dialer { return & Dialer { Host : host , Port : port , Username : username , Password : password , SSL : port == 465 , Timeout : 10 * time . Second , RetryFailure : true , } }
1033	func ( d * Dialer ) Dial ( ) ( SendCloser , error ) { conn , err := NetDialTimeout ( "tcp" , addr ( d . Host , d . Port ) , d . Timeout ) if err != nil { return nil , err } if d . SSL { conn = tlsClient ( conn , d . tlsConfig ( ) ) } c , err := smtpNewClient ( conn , d . Host ) if err != nil { return nil , err } if d . Timeout > 0 { conn . SetDeadline ( time . Now ( ) . Add ( d . Timeout ) ) } if d . LocalName != "" { if err := c . Hello ( d . LocalName ) ; err != nil { return nil , err } } if ! d . SSL && d . StartTLSPolicy != NoStartTLS { ok , _ := c . Extension ( "STARTTLS" ) if ! ok && d . StartTLSPolicy == MandatoryStartTLS { err := StartTLSUnsupportedError { Policy : d . StartTLSPolicy } return nil , err } if ok { if err := c . StartTLS ( d . tlsConfig ( ) ) ; err != nil { c . Close ( ) return nil , err } } } if d . Auth == nil && d . Username != "" { if ok , auths := c . Extension ( "AUTH" ) ; ok { if strings . Contains ( auths , "CRAM-MD5" ) { d . Auth = smtp . CRAMMD5Auth ( d . Username , d . Password ) } else if strings . Contains ( auths , "LOGIN" ) && ! strings . Contains ( auths , "PLAIN" ) { d . Auth = & loginAuth { username : d . Username , password : d . Password , host : d . Host , } } else { d . Auth = smtp . PlainAuth ( "" , d . Username , d . Password , d . Host ) } } } if d . Auth != nil { if err = c . Auth ( d . Auth ) ; err != nil { c . Close ( ) return nil , err } } return & smtpSender { c , conn , d } , nil }
1034	func ( d * Dialer ) DialAndSend ( m ... * Message ) error { s , err := d . Dial ( ) if err != nil { return err } defer s . Close ( ) return Send ( s , m ... ) }
1035	func ( f Flash ) Set ( key string , values [ ] string ) { f . data [ key ] = values }
1036	func ( f Flash ) Add ( key , value string ) { if len ( f . data [ key ] ) == 0 { f . data [ key ] = [ ] string { value } return } f . data [ key ] = append ( f . data [ key ] , value ) }
1037	func ( f Flash ) persist ( session * Session ) { b , _ := json . Marshal ( f . data ) session . Set ( flashKey , b ) session . Save ( ) }
1038	func newFlash ( session * Session ) * Flash { result := & Flash { data : map [ string ] [ ] string { } , } if session . Session != nil { if f := session . Get ( flashKey ) ; f != nil { json . Unmarshal ( f . ( [ ] byte ) , & result . data ) } } return result }
1039	func ( c * Cookies ) Get ( name string ) ( string , error ) { ck , err := c . req . Cookie ( name ) if err != nil { return "" , err } return ck . Value , nil }
1040	func ( c * Cookies ) Set ( name , value string , maxAge time . Duration ) { ck := http . Cookie { Name : name , Value : value , MaxAge : int ( maxAge . Seconds ( ) ) , } http . SetCookie ( c . res , & ck ) }
1041	func ( c * Cookies ) SetWithExpirationTime ( name , value string , expires time . Time ) { ck := http . Cookie { Name : name , Value : value , Expires : expires , } http . SetCookie ( c . res , & ck ) }
1042	func ( c * Cookies ) Delete ( name string ) { ck := http . Cookie { Name : name , Value : "v" , Expires : time . Unix ( 0 , 0 ) , } http . SetCookie ( c . res , & ck ) }
1043	func NewMessage ( ) Message { return Message { Context : context . Background ( ) , Headers : map [ string ] string { } , Data : render . Data { } , moot : & sync . RWMutex { } , } }
1044	func NewFromData ( data render . Data ) Message { d := render . Data { } for k , v := range data { d [ k ] = v } m := NewMessage ( ) m . Data = d return m }
1045	func New ( c buffalo . Context ) Message { m := NewFromData ( c . Data ( ) ) m . Context = c return m }
1046	func ( es * EventSource ) CloseNotify ( ) <- chan bool { if cn , ok := es . w . ( closeNotifier ) ; ok { return cn . CloseNotify ( ) } return nil }
1047	func NewEventSource ( w http . ResponseWriter ) ( * EventSource , error ) { es := & EventSource { w : w } var ok bool es . fl , ok = w . ( http . Flusher ) if ! ok { return es , errors . New ( "streaming is not supported" ) } es . w . Header ( ) . Set ( "Content-Type" , "text/event-stream" ) es . w . Header ( ) . Set ( "Cache-Control" , "no-cache" ) es . w . Header ( ) . Set ( "Connection" , "keep-alive" ) es . w . Header ( ) . Set ( "Access-Control-Allow-Origin" , "*" ) return es , nil }
1048	func NewSimpleWithContext ( ctx context . Context ) * Simple { ctx , cancel := context . WithCancel ( ctx ) l := logrus . New ( ) l . Level = logrus . InfoLevel l . Formatter = & logrus . TextFormatter { } return & Simple { Logger : l , ctx : ctx , cancel : cancel , handlers : map [ string ] Handler { } , moot : & sync . Mutex { } , } }
1049	func ( w * Simple ) Register ( name string , h Handler ) error { w . moot . Lock ( ) defer w . moot . Unlock ( ) if _ , ok := w . handlers [ name ] ; ok { return fmt . Errorf ( "handler already mapped for name %s" , name ) } w . handlers [ name ] = h return nil }
1050	func ( w * Simple ) Start ( ctx context . Context ) error { w . Logger . Info ( "Starting Simple Background Worker" ) w . ctx , w . cancel = context . WithCancel ( ctx ) return nil }
1051	func ( w Simple ) Stop ( ) error { w . Logger . Info ( "Stopping Simple Background Worker" ) w . cancel ( ) return nil }
1052	func ( w Simple ) Perform ( job Job ) error { w . Logger . Debugf ( "Performing job %s" , job ) if job . Handler == "" { err := fmt . Errorf ( "no handler name given for %s" , job ) w . Logger . Error ( err ) return err } w . moot . Lock ( ) defer w . moot . Unlock ( ) if h , ok := w . handlers [ job . Handler ] ; ok { go func ( ) { err := safe . RunE ( func ( ) error { return h ( job . Args ) } ) if err != nil { w . Logger . Error ( err ) } w . Logger . Debugf ( "Completed job %s" , job ) } ( ) return nil } err := fmt . Errorf ( "no handler mapped for name %s" , job . Handler ) w . Logger . Error ( err ) return err }
1053	func ( w Simple ) PerformAt ( job Job , t time . Time ) error { return w . PerformIn ( job , time . Until ( t ) ) }
1054	func ( w Simple ) PerformIn ( job Job , d time . Duration ) error { go func ( ) { select { case <- time . After ( d ) : w . Perform ( job ) case <- w . ctx . Done ( ) : w . cancel ( ) } } ( ) return nil }
1055	func ( ri RouteInfo ) String ( ) string { b , _ := json . MarshalIndent ( ri , "" , " " ) return string ( b ) }
1056	func ( ri * RouteInfo ) Alias ( aliases ... string ) * RouteInfo { ri . Aliases = append ( ri . Aliases , aliases ... ) for _ , a := range aliases { ri . App . router . Handle ( a , ri ) . Methods ( ri . Method ) } return ri }
1057	func ( ri * RouteInfo ) Name ( name string ) * RouteInfo { routeIndex := - 1 for index , route := range ri . App . Routes ( ) { if route . Path == ri . Path && route . Method == ri . Method { routeIndex = index break } } name = flect . Camelize ( name ) if ! strings . HasSuffix ( name , "Path" ) { name = name + "Path" } ri . PathName = name if routeIndex != - 1 { ri . App . Routes ( ) [ routeIndex ] = reflect . ValueOf ( ri ) . Interface ( ) . ( * RouteInfo ) } return ri }
1058	func ( ri * RouteInfo ) BuildPathHelper ( ) RouteHelperFunc { cRoute := ri return func ( opts map [ string ] interface { } ) ( template . HTML , error ) { pairs := [ ] string { } for k , v := range opts { pairs = append ( pairs , k ) pairs = append ( pairs , fmt . Sprintf ( "%v" , v ) ) } url , err := cRoute . MuxRoute . URL ( pairs ... ) if err != nil { return "" , errors . Wrapf ( err , "missing parameters for %v" , cRoute . Path ) } result := url . Path result = addExtraParamsTo ( result , opts ) return template . HTML ( result ) , nil } }
1059	func New ( opts * Options ) ( * genny . Generator , error ) { g := genny . New ( ) if err := opts . Validate ( ) ; err != nil { return g , err } g . Transformer ( genny . Replace ( "-no-pop" , "" ) ) g . Transformer ( genny . Dot ( ) ) box := packr . New ( "buffalo:genny:ci" , "../ci/templates" ) var fname string switch opts . Provider { case "travis" , "travis-ci" : fname = "-dot-travis.yml.tmpl" case "gitlab" , "gitlab-ci" : if opts . App . WithPop { fname = "-dot-gitlab-ci.yml.tmpl" } else { fname = "-dot-gitlab-ci-no-pop.yml.tmpl" } default : return g , fmt . Errorf ( "could not find a template for %s" , opts . Provider ) } f , err := box . FindString ( fname ) if err != nil { return g , err } g . File ( genny . NewFileS ( fname , f ) ) data := map [ string ] interface { } { "opts" : opts , } if opts . DBType == "postgres" { data [ "testDbUrl" ] = "postgres://postgres:postgres@postgres:5432/" + opts . App . Name . File ( ) . String ( ) + "_test?sslmode=disable" } else if opts . DBType == "mysql" { data [ "testDbUrl" ] = "mysql://root:root@(mysql:3306)/" + opts . App . Name . File ( ) . String ( ) + "_test?parseTime=true&multiStatements=true&readTimeout=1s" } else { data [ "testDbUrl" ] = "" } helpers := template . FuncMap { } t := gogen . TemplateTransformer ( data , helpers ) g . Transformer ( t ) return g , nil }
1060	func New ( opts * Options ) ( * genny . Generator , error ) { g := genny . New ( ) if err := opts . Validate ( ) ; err != nil { return g , err } g . RunFn ( construct ( opts ) ) return g , nil }
1061	func RegisterCustomDecoder ( fn CustomTypeDecoder , types [ ] interface { } , fields [ ] interface { } ) { rawFunc := ( func ( [ ] string ) ( interface { } , error ) ) ( fn ) decoder . RegisterCustomType ( rawFunc , types , fields ) }
1062	func ( ms * MiddlewareStack ) Replace ( mw1 MiddlewareFunc , mw2 MiddlewareFunc ) { m1k := funcKey ( mw1 ) stack := [ ] MiddlewareFunc { } for _ , mw := range ms . stack { if funcKey ( mw ) == m1k { stack = append ( stack , mw2 ) } else { stack = append ( stack , mw ) } } ms . stack = stack }
1063	func ( a * App ) Routes ( ) RouteList { if a . root != nil { return a . root . routes } return a . routes }
1064	func WrapBuffaloHandler ( h Handler ) http . Handler { a := New ( Options { } ) ri := a . GET ( "/" , h ) return ri }
1065	func PackageJSONCheck ( r * Runner ) error { fmt . Println ( "~~~ Checking package.json ~~~" ) if ! r . App . WithWebpack { return nil } box := webpack . Templates f , err := box . FindString ( "package.json.tmpl" ) if err != nil { return err } tmpl , err := template . New ( "package.json" ) . Parse ( f ) if err != nil { return err } bb := & bytes . Buffer { } err = tmpl . Execute ( bb , map [ string ] interface { } { "opts" : & webpack . Options { App : r . App , } , } ) if err != nil { return err } b , err := ioutil . ReadFile ( "package.json" ) if err != nil { return err } if string ( b ) == bb . String ( ) { return nil } if ! ask ( "Your package.json file is different from the latest Buffalo template.\nWould you like to REPLACE yours with the latest template?" ) \n { fmt . Println ( "\tskipping package.json" ) \t } return nil pf , err := os . Create ( "package.json" ) if err != nil { return err } _ , err = pf . Write ( bb . Bytes ( ) ) if err != nil { return err } err = pf . Close ( ) if err != nil { return err } os . RemoveAll ( filepath . Join ( r . App . Root , "node_modules" ) ) var cmd * exec . Cmd if r . App . WithYarn { cmd = exec . Command ( "yarnpkg" , "install" ) } else { cmd = exec . Command ( "npm" , "install" ) } cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout }
1066	func ( c ImportConverter ) match ( importpath string ) ( string , bool ) { for key , value := range c . Data { if ! strings . HasPrefix ( importpath , key ) { continue } result := strings . Replace ( importpath , key , value , 1 ) return result , true } return importpath , false }
1067	func Send ( s Sender , msg ... * Message ) error { for i , m := range msg { if err := send ( s , m ) ; err != nil { return & SendError { Cause : err , Index : uint ( i ) } } } return nil }
1068	func ( opts Options ) Last ( n name . Ident ) bool { return opts . Parts [ len ( opts . Parts ) - 1 ] . String ( ) == n . String ( ) }
1069	func ( a * App ) Stop ( err error ) error { a . cancel ( ) if err != nil && errors . Cause ( err ) != context . Canceled { a . Logger . Error ( err ) return err } return nil }
1070	func DepEnsure ( r * Runner ) error { if r . App . WithPop { upkg = append ( upkg , "github.com/gobuffalo/fizz" , "github.com/gobuffalo/pop" ) } if ! r . App . WithDep { fmt . Println ( "~~~ Running go get ~~~" ) return modGetUpdate ( r ) } fmt . Println ( "~~~ Running dep ensure ~~~" ) return runDepEnsure ( r ) }
1071	func ( b BuildInfo ) String ( ) string { return fmt . Sprintf ( "%s (%s)" , b . Version , b . Time ) }
1072	func New ( opts * Options ) ( * genny . Generator , error ) { g := genny . New ( ) if err := opts . Validate ( ) ; err != nil { return g , err } if ! opts . SkipTemplates { core := packr . New ( "github.com/gobuffalo/buffalo/genny/resource/templates/core" , "../resource/templates/core" ) if err := g . Box ( core ) ; err != nil { return g , err } } var abox packd . Box if opts . SkipModel { abox = packr . New ( "github.com/gobuffalo/buffalo/genny/resource/templates/standard" , "../resource/templates/standard" ) } else { abox = packr . New ( "github.com/gobuffalo/buffalo/genny/resource/templates/use_model" , "../resource/templates/use_model" ) } if err := g . Box ( abox ) ; err != nil { return g , err } pres := presenter { App : opts . App , Name : name . New ( opts . Name ) , Model : name . New ( opts . Model ) , Attrs : opts . Attrs , } x := pres . Name . Resource ( ) . File ( ) . String ( ) folder := pres . Name . Folder ( ) . Pluralize ( ) . String ( ) g . Transformer ( genny . Replace ( "resource-name" , x ) ) g . Transformer ( genny . Replace ( "resource-use_model" , x ) ) g . Transformer ( genny . Replace ( "folder-name" , folder ) ) data := map [ string ] interface { } { "opts" : pres , "actions" : actions ( opts ) , "folder" : folder , } helpers := template . FuncMap { "camelize" : func ( s string ) string { return flect . Camelize ( s ) } , } g . Transformer ( gogen . TemplateTransformer ( data , helpers ) ) g . RunFn ( installPop ( opts ) ) g . RunFn ( addResource ( pres ) ) return g , nil }
1073	func ( m * Message ) AddBody ( r render . Renderer , data render . Data ) error { buf := bytes . NewBuffer ( [ ] byte { } ) err := r . Render ( buf , m . merge ( data ) ) if err != nil { return err } m . Bodies = append ( m . Bodies , Body { Content : buf . String ( ) , ContentType : r . ContentType ( ) , } ) return nil }
1074	func ( m * Message ) AddBodies ( data render . Data , renderers ... render . Renderer ) error { for _ , r := range renderers { err := m . AddBody ( r , data ) if err != nil { return err } } return nil }
1075	func ( m * Message ) AddAttachment ( name , contentType string , r io . Reader ) error { m . Attachments = append ( m . Attachments , Attachment { Name : name , ContentType : contentType , Reader : r , Embedded : false , } ) return nil }
1076	func ( m * Message ) AddEmbedded ( name string , r io . Reader ) error { m . Attachments = append ( m . Attachments , Attachment { Name : name , Reader : r , Embedded : true , } ) return nil }
1077	func ( m * Message ) SetHeader ( field , value string ) { m . Headers [ field ] = value }
1078	func New ( opts * Options ) ( * genny . Group , error ) { if err := opts . Validate ( ) ; err != nil { return nil , err } gg , err := core . New ( opts . Options ) if err != nil { return gg , err } g := genny . New ( ) g . Transformer ( genny . Dot ( ) ) data := map [ string ] interface { } { "opts" : opts , } helpers := template . FuncMap { } t := gogen . TemplateTransformer ( data , helpers ) g . Transformer ( t ) g . Box ( packr . New ( "buffalo:genny:newapp:web" , "../web/templates" ) ) gg . Add ( g ) if opts . Webpack != nil { g , err = webpack . New ( opts . Webpack ) if err != nil { return gg , err } gg . Add ( g ) } if opts . Standard != nil { g , err = standard . New ( opts . Standard ) if err != nil { return gg , err } gg . Add ( g ) } return gg , nil }
1079	func New ( opts * Options ) ( * genny . Generator , error ) { g := genny . New ( ) g . Box ( packr . New ( "buffalo:genny:assets:standard" , "../standard/templates" ) ) data := map [ string ] interface { } { } h := template . FuncMap { } t := gogen . TemplateTransformer ( data , h ) g . Transformer ( t ) g . RunFn ( func ( r * genny . Runner ) error { f , err := r . FindFile ( "templates/application.html" ) if err != nil { return err } s := strings . Replace ( f . String ( ) , "</title>" , "</title>\n" + \n , bs4 ) 1 } ) return r . File ( genny . NewFileS ( f . Name ( ) , s ) ) }
1080	func New ( opts * Options ) ( * genny . Generator , error ) { g := genny . New ( ) if err := opts . Validate ( ) ; err != nil { return g , errors . WithStack ( err ) } g . RunFn ( appDetails ( opts ) ) cBox := packr . Folder ( filepath . Join ( opts . App . Root , "config" ) ) g . RunFn ( configs ( opts , cBox ) ) aBox := packr . Folder ( opts . App . Root ) g . RunFn ( pkgChecks ( opts , aBox ) ) return g , nil }
1081	func Cleanup ( opts * Options ) genny . RunFn { return func ( r * genny . Runner ) error { defer os . RemoveAll ( filepath . Join ( opts . Root , "a" ) ) if err := jam . Clean ( ) ; err != nil { return err } var err error opts . rollback . Range ( func ( k , v interface { } ) bool { f := genny . NewFileS ( k . ( string ) , v . ( string ) ) r . Logger . Debugf ( "Rollback: %s" , f . Name ( ) ) if err = r . File ( f ) ; err != nil { return false } r . Disk . Remove ( f . Name ( ) ) return true } ) if err != nil { return err } for _ , f := range r . Disk . Files ( ) { if err := r . Disk . Delete ( f . Name ( ) ) ; err != nil { return err } } if envy . Mods ( ) { if err := r . Exec ( exec . Command ( genny . GoBin ( ) , "mod" , "tidy" ) ) ; err != nil { return err } } return nil } }
1082	func MDTemplateEngine ( input string , data map [ string ] interface { } , helpers map [ string ] interface { } ) ( string , error ) { if ct , ok := data [ "contentType" ] . ( string ) ; ok && ct == "text/plain" { return plush . BuffaloRenderer ( input , data , helpers ) } source := github_flavored_markdown . Markdown ( [ ] byte ( input ) ) source = [ ] byte ( html . UnescapeString ( string ( source ) ) ) return plush . BuffaloRenderer ( string ( source ) , data , helpers ) }
1083	func Update ( fg FileGetter , kc corev1 . ConfigMapInterface , name , namespace string , updates [ ] ConfigMapUpdate , logger * logrus . Entry ) error { cm , getErr := kc . Get ( name , metav1 . GetOptions { } ) isNotFound := errors . IsNotFound ( getErr ) if getErr != nil && ! isNotFound { return fmt . Errorf ( "failed to fetch current state of configmap: %v" , getErr ) } if cm == nil || isNotFound { cm = & coreapi . ConfigMap { ObjectMeta : metav1 . ObjectMeta { Name : name , Namespace : namespace , } , } } if cm . Data == nil { cm . Data = map [ string ] string { } } if cm . BinaryData == nil { cm . BinaryData = map [ string ] [ ] byte { } } for _ , upd := range updates { if upd . Filename == "" { logger . WithField ( "key" , upd . Key ) . Debug ( "Deleting key." ) delete ( cm . Data , upd . Key ) delete ( cm . BinaryData , upd . Key ) continue } content , err := fg . GetFile ( upd . Filename ) if err != nil { return fmt . Errorf ( "get file err: %v" , err ) } logger . WithFields ( logrus . Fields { "key" : upd . Key , "filename" : upd . Filename } ) . Debug ( "Populating key." ) value := content if upd . GZIP { buff := bytes . NewBuffer ( [ ] byte { } ) z := gzip . NewWriter ( buff ) if _ , err := z . Write ( content ) ; err != nil { logger . WithError ( err ) . Error ( "failed to gzip content, falling back to raw" ) } else { if err := z . Close ( ) ; err != nil { logger . WithError ( err ) . Error ( "failed to flush gzipped content (!?), falling back to raw" ) } else { value = buff . Bytes ( ) } } } if utf8 . ValidString ( string ( value ) ) { delete ( cm . BinaryData , upd . Key ) cm . Data [ upd . Key ] = string ( value ) } else { delete ( cm . Data , upd . Key ) cm . BinaryData [ upd . Key ] = value } } var updateErr error var verb string if getErr != nil && isNotFound { verb = "create" _ , updateErr = kc . Create ( cm ) } else { verb = "update" _ , updateErr = kc . Update ( cm ) } if updateErr != nil { return fmt . Errorf ( "%s config map err: %v" , verb , updateErr ) } return nil }
1084	func FilterChanges ( cfg plugins . ConfigUpdater , changes [ ] github . PullRequestChange , log * logrus . Entry ) map [ ConfigMapID ] [ ] ConfigMapUpdate { toUpdate := map [ ConfigMapID ] [ ] ConfigMapUpdate { } for _ , change := range changes { var cm plugins . ConfigMapSpec found := false for key , configMap := range cfg . Maps { var matchErr error found , matchErr = zglob . Match ( key , change . Filename ) if matchErr != nil { log . WithError ( matchErr ) . Info ( "key matching error" ) continue } if found { cm = configMap break } } if ! found { continue } for _ , ns := range append ( cm . Namespaces ) { id := ConfigMapID { Name : cm . Name , Namespace : ns } key := cm . Key if key == "" { key = path . Base ( change . Filename ) if change . Status == github . PullRequestFileRenamed { oldKey := path . Base ( change . PreviousFilename ) toUpdate [ id ] = append ( toUpdate [ id ] , ConfigMapUpdate { Key : oldKey } ) } } if change . Status == github . PullRequestFileRemoved { toUpdate [ id ] = append ( toUpdate [ id ] , ConfigMapUpdate { Key : key } ) } else { gzip := cfg . GZIP if cm . GZIP != nil { gzip = * cm . GZIP } toUpdate [ id ] = append ( toUpdate [ id ] , ConfigMapUpdate { Key : key , Filename : change . Filename , GZIP : gzip } ) } } } return toUpdate }
1085	func getLabelsFromREMatches ( matches [ ] [ ] string ) ( labels [ ] string ) { for _ , match := range matches { for _ , label := range strings . Split ( match [ 0 ] , " " ) [ 1 : ] { label = strings . ToLower ( match [ 1 ] + "/" + strings . TrimSpace ( label ) ) labels = append ( labels , label ) } } return }
1086	func getLabelsFromGenericMatches ( matches [ ] [ ] string , additionalLabels [ ] string ) [ ] string { if len ( additionalLabels ) == 0 { return nil } var labels [ ] string for _ , match := range matches { parts := strings . Split ( match [ 0 ] , " " ) if ( ( parts [ 0 ] != "/label" ) && ( parts [ 0 ] != "/remove-label" ) ) || len ( parts ) != 2 { continue } for _ , l := range additionalLabels { if l == parts [ 1 ] { labels = append ( labels , parts [ 1 ] ) } } } return labels }
1087	func ( ca * Agent ) Start ( prowConfig , jobConfig string ) error { c , err := Load ( prowConfig , jobConfig ) if err != nil { return err } ca . Set ( c ) go func ( ) { var lastModTime time . Time skips := 0 for range time . Tick ( 1 * time . Second ) { if skips < 600 { prowStat , err := os . Stat ( prowConfig ) if err != nil { logrus . WithField ( "prowConfig" , prowConfig ) . WithError ( err ) . Error ( "Error loading prow config." ) continue } recentModTime := prowStat . ModTime ( ) if jobConfig != "" { jobConfigStat , err := os . Stat ( jobConfig ) if err != nil { logrus . WithField ( "jobConfig" , jobConfig ) . WithError ( err ) . Error ( "Error loading job configs." ) continue } if jobConfigStat . ModTime ( ) . After ( recentModTime ) { recentModTime = jobConfigStat . ModTime ( ) } } if ! recentModTime . After ( lastModTime ) { skips ++ continue } lastModTime = recentModTime } if c , err := Load ( prowConfig , jobConfig ) ; err != nil { logrus . WithField ( "prowConfig" , prowConfig ) . WithField ( "jobConfig" , jobConfig ) . WithError ( err ) . Error ( "Error loading config." ) } else { skips = 0 ca . Set ( c ) } } } ( ) return nil }
1088	func ( ca * Agent ) Subscribe ( subscription DeltaChan ) { ca . mut . Lock ( ) defer ca . mut . Unlock ( ) ca . subscriptions = append ( ca . subscriptions , subscription ) }
1089	func ( ca * Agent ) Config ( ) * Config { ca . mut . RLock ( ) defer ca . mut . RUnlock ( ) return ca . c }
1090	func ( ca * Agent ) Set ( c * Config ) { ca . mut . Lock ( ) defer ca . mut . Unlock ( ) var oldConfig Config if ca . c != nil { oldConfig = * ca . c } delta := Delta { oldConfig , * c } ca . c = c for _ , subscription := range ca . subscriptions { go func ( sub DeltaChan ) { end := time . NewTimer ( time . Minute ) select { case sub <- delta : case <- end . C : } if ! end . Stop ( ) { <- end . C } } ( subscription ) } }
1091	func ( f * FakeClient ) IsMember ( org , user string ) ( bool , error ) { for _ , m := range f . OrgMembers [ org ] { if m == user { return true , nil } } return false , nil }
1092	func ( f * FakeClient ) ListIssueComments ( owner , repo string , number int ) ( [ ] github . IssueComment , error ) { return append ( [ ] github . IssueComment { } , f . IssueComments [ number ] ... ) , nil }
1093	func ( f * FakeClient ) ListPullRequestComments ( owner , repo string , number int ) ( [ ] github . ReviewComment , error ) { return append ( [ ] github . ReviewComment { } , f . PullRequestComments [ number ] ... ) , nil }
1094	func ( f * FakeClient ) ListReviews ( owner , repo string , number int ) ( [ ] github . Review , error ) { return append ( [ ] github . Review { } , f . Reviews [ number ] ... ) , nil }
1095	func ( f * FakeClient ) ListIssueEvents ( owner , repo string , number int ) ( [ ] github . ListedIssueEvent , error ) { return append ( [ ] github . ListedIssueEvent { } , f . IssueEvents [ number ] ... ) , nil }
1096	func ( f * FakeClient ) CreateComment ( owner , repo string , number int , comment string ) error { f . IssueCommentsAdded = append ( f . IssueCommentsAdded , fmt . Sprintf ( "%s/%s#%d:%s" , owner , repo , number , comment ) ) f . IssueComments [ number ] = append ( f . IssueComments [ number ] , github . IssueComment { ID : f . IssueCommentID , Body : comment , User : github . User { Login : botName } , } ) f . IssueCommentID ++ return nil }
1097	func ( f * FakeClient ) CreateReview ( org , repo string , number int , r github . DraftReview ) error { f . Reviews [ number ] = append ( f . Reviews [ number ] , github . Review { ID : f . ReviewID , User : github . User { Login : botName } , Body : r . Body , } ) f . ReviewID ++ return nil }
1098	func ( f * FakeClient ) CreateCommentReaction ( org , repo string , ID int , reaction string ) error { f . CommentReactionsAdded = append ( f . CommentReactionsAdded , fmt . Sprintf ( "%s/%s#%d:%s" , org , repo , ID , reaction ) ) return nil }
1099	func ( f * FakeClient ) CreateIssueReaction ( org , repo string , ID int , reaction string ) error { f . IssueReactionsAdded = append ( f . IssueReactionsAdded , fmt . Sprintf ( "%s/%s#%d:%s" , org , repo , ID , reaction ) ) return nil }
1100	func ( f * FakeClient ) DeleteComment ( owner , repo string , ID int ) error { f . IssueCommentsDeleted = append ( f . IssueCommentsDeleted , fmt . Sprintf ( "%s/%s#%d" , owner , repo , ID ) ) for num , ics := range f . IssueComments { for i , ic := range ics { if ic . ID == ID { f . IssueComments [ num ] = append ( ics [ : i ] , ics [ i + 1 : ] ... ) return nil } } } return fmt . Errorf ( "could not find issue comment %d" , ID ) }
1101	func ( f * FakeClient ) DeleteStaleComments ( org , repo string , number int , comments [ ] github . IssueComment , isStale func ( github . IssueComment ) bool ) error { if comments == nil { comments , _ = f . ListIssueComments ( org , repo , number ) } for _ , comment := range comments { if isStale ( comment ) { if err := f . DeleteComment ( org , repo , comment . ID ) ; err != nil { return fmt . Errorf ( "failed to delete stale comment with ID '%d'" , comment . ID ) } } } return nil }
1102	func ( f * FakeClient ) GetPullRequest ( owner , repo string , number int ) ( * github . PullRequest , error ) { val , exists := f . PullRequests [ number ] if ! exists { return nil , fmt . Errorf ( "Pull request number %d does not exit" , number ) } return val , nil }
1103	func ( f * FakeClient ) GetPullRequestChanges ( org , repo string , number int ) ( [ ] github . PullRequestChange , error ) { return f . PullRequestChanges [ number ] , nil }
1104	func ( f * FakeClient ) GetRef ( owner , repo , ref string ) ( string , error ) { return TestRef , nil }
1105	func ( f * FakeClient ) DeleteRef ( owner , repo , ref string ) error { f . RefsDeleted = append ( f . RefsDeleted , struct { Org , Repo , Ref string } { Org : owner , Repo : repo , Ref : ref } ) return nil }
1106	func ( f * FakeClient ) GetSingleCommit ( org , repo , SHA string ) ( github . SingleCommit , error ) { return f . Commits [ SHA ] , nil }
1107	func ( f * FakeClient ) CreateStatus ( owner , repo , SHA string , s github . Status ) error { if f . CreatedStatuses == nil { f . CreatedStatuses = make ( map [ string ] [ ] github . Status ) } statuses := f . CreatedStatuses [ SHA ] var updated bool for i := range statuses { if statuses [ i ] . Context == s . Context { statuses [ i ] = s updated = true } } if ! updated { statuses = append ( statuses , s ) } f . CreatedStatuses [ SHA ] = statuses return nil }
1108	func ( f * FakeClient ) ListStatuses ( org , repo , ref string ) ( [ ] github . Status , error ) { return f . CreatedStatuses [ ref ] , nil }
1109	func ( f * FakeClient ) GetCombinedStatus ( owner , repo , ref string ) ( * github . CombinedStatus , error ) { return f . CombinedStatuses [ ref ] , nil }
1110	func ( f * FakeClient ) GetRepoLabels ( owner , repo string ) ( [ ] github . Label , error ) { la := [ ] github . Label { } for _ , l := range f . RepoLabelsExisting { la = append ( la , github . Label { Name : l } ) } return la , nil }
1111	func ( f * FakeClient ) GetIssueLabels ( owner , repo string , number int ) ( [ ] github . Label , error ) { re := regexp . MustCompile ( fmt . Sprintf ( `^%s/%s#%d:(.*)$` , owner , repo , number ) ) la := [ ] github . Label { } allLabels := sets . NewString ( f . IssueLabelsExisting ... ) allLabels . Insert ( f . IssueLabelsAdded ... ) allLabels . Delete ( f . IssueLabelsRemoved ... ) for _ , l := range allLabels . List ( ) { groups := re . FindStringSubmatch ( l ) if groups != nil { la = append ( la , github . Label { Name : groups [ 1 ] } ) } } return la , nil }
1112	func ( f * FakeClient ) AddLabel ( owner , repo string , number int , label string ) error { labelString := fmt . Sprintf ( "%s/%s#%d:%s" , owner , repo , number , label ) if sets . NewString ( f . IssueLabelsAdded ... ) . Has ( labelString ) { return fmt . Errorf ( "cannot add %v to %s/%s/#%d" , label , owner , repo , number ) } if f . RepoLabelsExisting == nil { f . IssueLabelsAdded = append ( f . IssueLabelsAdded , labelString ) return nil } for _ , l := range f . RepoLabelsExisting { if label == l { f . IssueLabelsAdded = append ( f . IssueLabelsAdded , labelString ) return nil } } return fmt . Errorf ( "cannot add %v to %s/%s/#%d" , label , owner , repo , number ) }
1113	func ( f * FakeClient ) RemoveLabel ( owner , repo string , number int , label string ) error { labelString := fmt . Sprintf ( "%s/%s#%d:%s" , owner , repo , number , label ) if ! sets . NewString ( f . IssueLabelsRemoved ... ) . Has ( labelString ) { f . IssueLabelsRemoved = append ( f . IssueLabelsRemoved , labelString ) return nil } return fmt . Errorf ( "cannot remove %v from %s/%s/#%d" , label , owner , repo , number ) }
1114	func ( f * FakeClient ) FindIssues ( query , sort string , asc bool ) ( [ ] github . Issue , error ) { return f . Issues , nil }
1115	func ( f * FakeClient ) AssignIssue ( owner , repo string , number int , assignees [ ] string ) error { var m github . MissingUsers for _ , a := range assignees { if a == "not-in-the-org" { m . Users = append ( m . Users , a ) continue } f . AssigneesAdded = append ( f . AssigneesAdded , fmt . Sprintf ( "%s/%s#%d:%s" , owner , repo , number , a ) ) } if m . Users == nil { return nil } return m }
1116	func ( f * FakeClient ) GetFile ( org , repo , file , commit string ) ( [ ] byte , error ) { contents , ok := f . RemoteFiles [ file ] if ! ok { return nil , fmt . Errorf ( "could not find file %s" , file ) } if commit == "" { if master , ok := contents [ "master" ] ; ok { return [ ] byte ( master ) , nil } return nil , fmt . Errorf ( "could not find file %s in master" , file ) } if content , ok := contents [ commit ] ; ok { return [ ] byte ( content ) , nil } return nil , fmt . Errorf ( "could not find file %s with ref %s" , file , commit ) }
1117	func ( f * FakeClient ) ListTeams ( org string ) ( [ ] github . Team , error ) { return [ ] github . Team { { ID : 0 , Name : "Admins" , } , { ID : 42 , Name : "Leads" , } , } , nil }
1118	func ( f * FakeClient ) ListTeamMembers ( teamID int , role string ) ( [ ] github . TeamMember , error ) { if role != github . RoleAll { return nil , fmt . Errorf ( "unsupported role %v (only all supported)" , role ) } teams := map [ int ] [ ] github . TeamMember { 0 : { { Login : "default-sig-lead" } } , 42 : { { Login : "sig-lead" } } , } members , ok := teams [ teamID ] if ! ok { return [ ] github . TeamMember { } , nil } return members , nil }
1119	func ( f * FakeClient ) IsCollaborator ( org , repo , login string ) ( bool , error ) { normed := github . NormLogin ( login ) for _ , collab := range f . Collaborators { if github . NormLogin ( collab ) == normed { return true , nil } } return false , nil }
1120	func ( f * FakeClient ) ListCollaborators ( org , repo string ) ( [ ] github . User , error ) { result := make ( [ ] github . User , 0 , len ( f . Collaborators ) ) for _ , login := range f . Collaborators { result = append ( result , github . User { Login : login } ) } return result , nil }
1121	func ( f * FakeClient ) ClearMilestone ( org , repo string , issueNum int ) error { f . Milestone = 0 return nil }
1122	func ( f * FakeClient ) SetMilestone ( org , repo string , issueNum , milestoneNum int ) error { if milestoneNum < 0 { return fmt . Errorf ( "Milestone Numbers Cannot Be Negative" ) } f . Milestone = milestoneNum return nil }
1123	func ( f * FakeClient ) ListMilestones ( org , repo string ) ( [ ] github . Milestone , error ) { milestones := [ ] github . Milestone { } for k , v := range f . MilestoneMap { milestones = append ( milestones , github . Milestone { Title : k , Number : v } ) } return milestones , nil }
1124	func ( f * FakeClient ) ListPRCommits ( org , repo string , prNumber int ) ( [ ] github . RepositoryCommit , error ) { k := fmt . Sprintf ( "%s/%s#%d" , org , repo , prNumber ) return f . CommitMap [ k ] , nil }
1125	func ( f * FakeClient ) GetRepoProjects ( owner , repo string ) ( [ ] github . Project , error ) { return f . RepoProjects [ fmt . Sprintf ( "%s/%s" , owner , repo ) ] , nil }
1126	func ( f * FakeClient ) GetOrgProjects ( org string ) ( [ ] github . Project , error ) { return f . RepoProjects [ fmt . Sprintf ( "%s/*" , org ) ] , nil }
1127	func ( f * FakeClient ) GetProjectColumns ( projectID int ) ( [ ] github . ProjectColumn , error ) { for _ , projects := range f . RepoProjects { for _ , project := range projects { if projectID == project . ID { return f . ProjectColumnsMap [ project . Name ] , nil } } } return nil , fmt . Errorf ( "Cannot find project ID" ) }
1128	func ( f * FakeClient ) CreateProjectCard ( columnID int , projectCard github . ProjectCard ) ( * github . ProjectCard , error ) { if f . ColumnCardsMap == nil { f . ColumnCardsMap = make ( map [ int ] [ ] github . ProjectCard ) } for project , columnIDMap := range f . ColumnIDMap { columnName , exists := columnIDMap [ columnID ] if exists { f . ColumnCardsMap [ columnID ] = append ( f . ColumnCardsMap [ columnID ] , projectCard , ) f . Column = columnName f . Project = project return & projectCard , nil } } return nil , fmt . Errorf ( "Provided column %d does not exist, ColumnIDMap is %v" , columnID , f . ColumnIDMap ) }
1129	func ( f * FakeClient ) DeleteProjectCard ( projectCardID int ) error { if f . ColumnCardsMap == nil { return fmt . Errorf ( "Project card doesn't exist" ) } f . Project = "" f . Column = "" newCards := [ ] github . ProjectCard { } oldColumnID := - 1 for column , cards := range f . ColumnCardsMap { removalIndex := - 1 for i , existingCard := range cards { if existingCard . ContentID == projectCardID { oldColumnID = column removalIndex = i break } } if removalIndex != - 1 { newCards = cards newCards [ removalIndex ] = newCards [ len ( newCards ) - 1 ] newCards = newCards [ : len ( newCards ) - 1 ] break } } if oldColumnID != - 1 { f . ColumnCardsMap [ oldColumnID ] = newCards } return nil }
1130	func ( f * FakeClient ) MoveProjectCard ( projectCardID int , newColumnID int ) error { newCards := [ ] github . ProjectCard { } oldColumnID := - 1 projectCard := github . ProjectCard { } for column , cards := range f . ColumnCardsMap { removalIndex := - 1 for i , existingCard := range cards { if existingCard . ContentID == projectCardID { oldColumnID = column removalIndex = i projectCard = existingCard break } } if removalIndex != - 1 { newCards = cards newCards [ removalIndex ] = newCards [ len ( newCards ) - 1 ] newCards = newCards [ : len ( newCards ) - 1 ] } } if oldColumnID != - 1 { f . ColumnCardsMap [ oldColumnID ] = newCards } for project , columnIDMap := range f . ColumnIDMap { if columnName , exists := columnIDMap [ newColumnID ] ; exists { f . ColumnCardsMap [ newColumnID ] = append ( f . ColumnCardsMap [ newColumnID ] , projectCard , ) f . Column = columnName f . Project = project break } } return nil }
1131	func ( config * InfluxConfig ) CreateDatabaseClient ( ) ( * InfluxDB , error ) { client , err := influxdb . NewHTTPClient ( influxdb . HTTPConfig { Addr : config . Host , Username : config . User , Password : config . Password , } ) if err != nil { return nil , err } return & InfluxDB { client : client , database : config . DB , } , nil }
1132	func ( i * InfluxDB ) Push ( measurement string , tags map [ string ] string , fields map [ string ] interface { } , date time . Time ) error { batch , err := influxdb . NewBatchPoints ( influxdb . BatchPointsConfig { Database : i . database , Precision : "s" , } ) if err != nil { return err } pt , err := influxdb . NewPoint ( measurement , tags , fields , date ) if err != nil { return err } batch . AddPoint ( pt ) err = i . client . Write ( batch ) if err != nil { return err } glog . Infof ( "Sent to influx: %s %+v %+v %s" , measurement , tags , fields , date ) return nil }
1133	func NewProwJobWithAnnotation ( spec prowapi . ProwJobSpec , labels , annotations map [ string ] string ) prowapi . ProwJob { return newProwJob ( spec , labels , annotations ) }
1134	func NewProwJob ( spec prowapi . ProwJobSpec , labels map [ string ] string ) prowapi . ProwJob { return newProwJob ( spec , labels , nil ) }
1135	func NewPresubmit ( pr github . PullRequest , baseSHA string , job config . Presubmit , eventGUID string ) prowapi . ProwJob { refs := createRefs ( pr , baseSHA ) labels := make ( map [ string ] string ) for k , v := range job . Labels { labels [ k ] = v } labels [ github . EventGUID ] = eventGUID return NewProwJob ( PresubmitSpec ( job , refs ) , labels ) }
1136	func PresubmitSpec ( p config . Presubmit , refs prowapi . Refs ) prowapi . ProwJobSpec { pjs := specFromJobBase ( p . JobBase ) pjs . Type = prowapi . PresubmitJob pjs . Context = p . Context pjs . Report = ! p . SkipReport pjs . RerunCommand = p . RerunCommand if p . JenkinsSpec != nil { pjs . JenkinsSpec = & prowapi . JenkinsSpec { GitHubBranchSourceJob : p . JenkinsSpec . GitHubBranchSourceJob , } } pjs . Refs = completePrimaryRefs ( refs , p . JobBase ) return pjs }
1137	func PostsubmitSpec ( p config . Postsubmit , refs prowapi . Refs ) prowapi . ProwJobSpec { pjs := specFromJobBase ( p . JobBase ) pjs . Type = prowapi . PostsubmitJob pjs . Context = p . Context pjs . Report = ! p . SkipReport pjs . Refs = completePrimaryRefs ( refs , p . JobBase ) if p . JenkinsSpec != nil { pjs . JenkinsSpec = & prowapi . JenkinsSpec { GitHubBranchSourceJob : p . JenkinsSpec . GitHubBranchSourceJob , } } return pjs }
1138	func PeriodicSpec ( p config . Periodic ) prowapi . ProwJobSpec { pjs := specFromJobBase ( p . JobBase ) pjs . Type = prowapi . PeriodicJob return pjs }
1139	func BatchSpec ( p config . Presubmit , refs prowapi . Refs ) prowapi . ProwJobSpec { pjs := specFromJobBase ( p . JobBase ) pjs . Type = prowapi . BatchJob pjs . Context = p . Context pjs . Refs = completePrimaryRefs ( refs , p . JobBase ) return pjs }
1140	func PartitionActive ( pjs [ ] prowapi . ProwJob ) ( pending , triggered chan prowapi . ProwJob ) { pendingCount , triggeredCount := 0 , 0 for _ , pj := range pjs { switch pj . Status . State { case prowapi . PendingState : pendingCount ++ case prowapi . TriggeredState : triggeredCount ++ } } pending = make ( chan prowapi . ProwJob , pendingCount ) triggered = make ( chan prowapi . ProwJob , triggeredCount ) for _ , pj := range pjs { switch pj . Status . State { case prowapi . PendingState : pending <- pj case prowapi . TriggeredState : triggered <- pj } } close ( pending ) close ( triggered ) return pending , triggered }
1141	func ProwJobFields ( pj * prowapi . ProwJob ) logrus . Fields { fields := make ( logrus . Fields ) fields [ "name" ] = pj . ObjectMeta . Name fields [ "job" ] = pj . Spec . Job fields [ "type" ] = pj . Spec . Type if len ( pj . ObjectMeta . Labels [ github . EventGUID ] ) > 0 { fields [ github . EventGUID ] = pj . ObjectMeta . Labels [ github . EventGUID ] } if pj . Spec . Refs != nil && len ( pj . Spec . Refs . Pulls ) == 1 { fields [ github . PrLogField ] = pj . Spec . Refs . Pulls [ 0 ] . Number fields [ github . RepoLogField ] = pj . Spec . Refs . Repo fields [ github . OrgLogField ] = pj . Spec . Refs . Org } if pj . Spec . JenkinsSpec != nil { fields [ "github_based_job" ] = pj . Spec . JenkinsSpec . GitHubBranchSourceJob } return fields }
1142	func ClusterToCtx ( cluster string ) string { if cluster == kube . InClusterContext { return kube . DefaultClusterAlias } return cluster }
1143	func ( pluginHelp * PluginHelp ) AddCommand ( command Command ) { pluginHelp . Commands = append ( pluginHelp . Commands , command ) }
1144	func ( c * FakeProwJobs ) Get ( name string , options v1 . GetOptions ) ( result * prowjobsv1 . ProwJob , err error ) { obj , err := c . Fake . Invokes ( testing . NewGetAction ( prowjobsResource , c . ns , name ) , & prowjobsv1 . ProwJob { } ) if obj == nil { return nil , err } return obj . ( * prowjobsv1 . ProwJob ) , err }
1145	func ( c * FakeProwJobs ) Watch ( opts v1 . ListOptions ) ( watch . Interface , error ) { return c . Fake . InvokesWatch ( testing . NewWatchAction ( prowjobsResource , c . ns , opts ) ) }
1146	func ( c * FakeProwJobs ) Delete ( name string , options * v1 . DeleteOptions ) error { _ , err := c . Fake . Invokes ( testing . NewDeleteAction ( prowjobsResource , c . ns , name ) , & prowjobsv1 . ProwJob { } ) return err }
1147	func ( c * FakeProwJobs ) Patch ( name string , pt types . PatchType , data [ ] byte , subresources ... string ) ( result * prowjobsv1 . ProwJob , err error ) { obj , err := c . Fake . Invokes ( testing . NewPatchSubresourceAction ( prowjobsResource , c . ns , name , data , subresources ... ) , & prowjobsv1 . ProwJob { } ) if obj == nil { return nil , err } return obj . ( * prowjobsv1 . ProwJob ) , err }
1148	func ( t * Tide ) MergeMethod ( org , repo string ) github . PullRequestMergeType { name := org + "/" + repo v , ok := t . MergeType [ name ] if ! ok { if ov , found := t . MergeType [ org ] ; found { return ov } return github . MergeMerge } return v }
1149	func ( tq * TideQuery ) Query ( ) string { toks := [ ] string { "is:pr" , "state:open" } for _ , o := range tq . Orgs { toks = append ( toks , fmt . Sprintf ( "org:\"%s\"" , \" ) ) } \" o for _ , r := range tq . Repos { toks = append ( toks , fmt . Sprintf ( "repo:\"%s\"" , \" ) ) } \" r for _ , r := range tq . ExcludedRepos { toks = append ( toks , fmt . Sprintf ( "-repo:\"%s\"" , \" ) ) } \" r for _ , b := range tq . ExcludedBranches { toks = append ( toks , fmt . Sprintf ( "-base:\"%s\"" , \" ) ) } }
1150	func ( tq TideQuery ) ForRepo ( org , repo string ) bool { fullName := fmt . Sprintf ( "%s/%s" , org , repo ) for _ , queryOrg := range tq . Orgs { if queryOrg != org { continue } for _ , excludedRepo := range tq . ExcludedRepos { if excludedRepo == fullName { return false } } return true } for _ , queryRepo := range tq . Repos { if queryRepo == fullName { return true } } return false }
1151	func ( tqs TideQueries ) OrgExceptionsAndRepos ( ) ( map [ string ] sets . String , sets . String ) { orgs := make ( map [ string ] sets . String ) for i := range tqs { for _ , org := range tqs [ i ] . Orgs { applicableRepos := sets . NewString ( reposInOrg ( org , tqs [ i ] . ExcludedRepos ) ... ) if excepts , ok := orgs [ org ] ; ! ok { orgs [ org ] = applicableRepos } else { orgs [ org ] = excepts . Intersection ( applicableRepos ) } } } repos := sets . NewString ( ) for i := range tqs { repos . Insert ( tqs [ i ] . Repos ... ) } reposList := repos . UnsortedList ( ) for _ , excepts := range orgs { excepts . Delete ( reposList ... ) } return orgs , repos }
1152	func ( tqs TideQueries ) QueryMap ( ) * QueryMap { return & QueryMap { queries : tqs , cache : make ( map [ string ] TideQueries ) , } }
1153	func ( qm * QueryMap ) ForRepo ( org , repo string ) TideQueries { res := TideQueries ( nil ) fullName := fmt . Sprintf ( "%s/%s" , org , repo ) qm . Lock ( ) defer qm . Unlock ( ) if qs , ok := qm . cache [ fullName ] ; ok { return append ( res , qs ... ) } for _ , query := range qm . queries { if query . ForRepo ( org , repo ) { res = append ( res , query ) } } qm . cache [ fullName ] = res return res }
1154	func ( cp * TideContextPolicy ) Validate ( ) error { if inter := sets . NewString ( cp . RequiredContexts ... ) . Intersection ( sets . NewString ( cp . OptionalContexts ... ) ) ; inter . Len ( ) > 0 { return fmt . Errorf ( "contexts %s are defined as required and optional" , strings . Join ( inter . List ( ) , ", " ) ) } if inter := sets . NewString ( cp . RequiredContexts ... ) . Intersection ( sets . NewString ( cp . RequiredIfPresentContexts ... ) ) ; inter . Len ( ) > 0 { return fmt . Errorf ( "contexts %s are defined as required and required if present" , strings . Join ( inter . List ( ) , ", " ) ) } if inter := sets . NewString ( cp . OptionalContexts ... ) . Intersection ( sets . NewString ( cp . RequiredIfPresentContexts ... ) ) ; inter . Len ( ) > 0 { return fmt . Errorf ( "contexts %s are defined as optional and required if present" , strings . Join ( inter . List ( ) , ", " ) ) } return nil }
1155	func ( c Config ) GetTideContextPolicy ( org , repo , branch string ) ( * TideContextPolicy , error ) { options := parseTideContextPolicyOptions ( org , repo , branch , c . Tide . ContextOptions ) required := sets . NewString ( options . RequiredContexts ... ) requiredIfPresent := sets . NewString ( options . RequiredIfPresentContexts ... ) optional := sets . NewString ( options . OptionalContexts ... ) prowRequired , prowRequiredIfPresent , prowOptional := BranchRequirements ( org , repo , branch , c . Presubmits ) required . Insert ( prowRequired ... ) requiredIfPresent . Insert ( prowRequiredIfPresent ... ) optional . Insert ( prowOptional ... ) if options . FromBranchProtection != nil && * options . FromBranchProtection { bp , err := c . GetBranchProtection ( org , repo , branch ) if err != nil { logrus . WithError ( err ) . Warningf ( "Error getting branch protection for %s/%s+%s" , org , repo , branch ) } else if bp != nil && bp . Protect != nil && * bp . Protect && bp . RequiredStatusChecks != nil { required . Insert ( bp . RequiredStatusChecks . Contexts ... ) } } t := & TideContextPolicy { RequiredContexts : required . List ( ) , RequiredIfPresentContexts : requiredIfPresent . List ( ) , OptionalContexts : optional . List ( ) , SkipUnknownContexts : options . SkipUnknownContexts , } if err := t . Validate ( ) ; err != nil { return t , err } return t , nil }
1156	func ( cp * TideContextPolicy ) IsOptional ( c string ) bool { if sets . NewString ( cp . OptionalContexts ... ) . Has ( c ) { return true } if sets . NewString ( cp . RequiredContexts ... ) . Has ( c ) { return false } if sets . NewString ( cp . RequiredIfPresentContexts ... ) . Has ( c ) { return false } if cp . SkipUnknownContexts != nil && * cp . SkipUnknownContexts { return true } return false }
1157	func ( cp * TideContextPolicy ) MissingRequiredContexts ( contexts [ ] string ) [ ] string { if len ( cp . RequiredContexts ) == 0 { return nil } existingContexts := sets . NewString ( ) for _ , c := range contexts { existingContexts . Insert ( c ) } var missingContexts [ ] string for c := range sets . NewString ( cp . RequiredContexts ... ) . Difference ( existingContexts ) { missingContexts = append ( missingContexts , c ) } return missingContexts }
1158	func ValidateWebhook ( w http . ResponseWriter , r * http . Request , hmacSecret [ ] byte ) ( string , string , [ ] byte , bool , int ) { defer r . Body . Close ( ) if r . Method == http . MethodGet { return "" , "" , nil , false , http . StatusOK } if r . Method != http . MethodPost { responseHTTPError ( w , http . StatusMethodNotAllowed , "405 Method not allowed" ) return "" , "" , nil , false , http . StatusMethodNotAllowed } eventType := r . Header . Get ( "X-GitHub-Event" ) if eventType == "" { responseHTTPError ( w , http . StatusBadRequest , "400 Bad Request: Missing X-GitHub-Event Header" ) return "" , "" , nil , false , http . StatusBadRequest } eventGUID := r . Header . Get ( "X-GitHub-Delivery" ) if eventGUID == "" { responseHTTPError ( w , http . StatusBadRequest , "400 Bad Request: Missing X-GitHub-Delivery Header" ) return "" , "" , nil , false , http . StatusBadRequest } sig := r . Header . Get ( "X-Hub-Signature" ) if sig == "" { responseHTTPError ( w , http . StatusForbidden , "403 Forbidden: Missing X-Hub-Signature" ) return "" , "" , nil , false , http . StatusForbidden } contentType := r . Header . Get ( "content-type" ) if contentType != "application/json" { responseHTTPError ( w , http . StatusBadRequest , "400 Bad Request: Hook only accepts content-type: application/json - please reconfigure this hook on GitHub" ) return "" , "" , nil , false , http . StatusBadRequest } payload , err := ioutil . ReadAll ( r . Body ) if err != nil { responseHTTPError ( w , http . StatusInternalServerError , "500 Internal Server Error: Failed to read request body" ) return "" , "" , nil , false , http . StatusInternalServerError } if ! ValidatePayload ( payload , sig , hmacSecret ) { responseHTTPError ( w , http . StatusForbidden , "403 Forbidden: Invalid X-Hub-Signature" ) return "" , "" , nil , false , http . StatusForbidden } return eventType , eventGUID , payload , true , http . StatusOK }
1159	func HelpProvider ( enabledRepos [ ] string ) ( * pluginhelp . PluginHelp , error ) { return & pluginhelp . PluginHelp { Description : `The needs-rebase plugin manages the '` + labels . NeedsRebase + `' label by removing it from Pull Requests that are mergeable and adding it to those which are not.The plugin reacts to commit changes on PRs in addition to periodically scanning all open PRs for any changes to mergeability that could have resulted from changes in other PRs.` , } , nil }
1160	func HandleEvent ( log * logrus . Entry , ghc githubClient , pre * github . PullRequestEvent ) error { if pre . Action != github . PullRequestActionOpened && pre . Action != github . PullRequestActionSynchronize && pre . Action != github . PullRequestActionReopened { return nil } sleep ( time . Second * 5 ) org := pre . Repo . Owner . Login repo := pre . Repo . Name number := pre . Number sha := pre . PullRequest . Head . SHA mergeable , err := ghc . IsMergeable ( org , repo , number , sha ) if err != nil { return err } issueLabels , err := ghc . GetIssueLabels ( org , repo , number ) if err != nil { return err } hasLabel := github . HasLabel ( labels . NeedsRebase , issueLabels ) return takeAction ( log , ghc , org , repo , number , pre . PullRequest . User . Login , hasLabel , mergeable ) }
1161	func HandleAll ( log * logrus . Entry , ghc githubClient , config * plugins . Configuration ) error { log . Info ( "Checking all PRs." ) orgs , repos := config . EnabledReposForExternalPlugin ( PluginName ) if len ( orgs ) == 0 && len ( repos ) == 0 { log . Warnf ( "No repos have been configured for the %s plugin" , PluginName ) return nil } var buf bytes . Buffer fmt . Fprint ( & buf , "is:pr is:open" ) for _ , org := range orgs { fmt . Fprintf ( & buf , " org:\"%s\"" , \" ) } \" org for _ , repo := range repos { fmt . Fprintf ( & buf , " repo:\"%s\"" , \" ) } \" repo prs , err := search ( context . Background ( ) , log , ghc , buf . String ( ) ) }
1162	func NewDryRunProwJobClient ( deckURL string ) prowv1 . ProwJobInterface { return & dryRunProwJobClient { deckURL : deckURL , client : & http . Client { } , } }
1163	func ( c * dryRunProwJobClient ) Create ( * prowapi . ProwJob ) ( * prowapi . ProwJob , error ) { return nil , nil }
1164	func ( c * dryRunProwJobClient ) Update ( * prowapi . ProwJob ) ( * prowapi . ProwJob , error ) { return nil , nil }
1165	func ( c * dryRunProwJobClient ) UpdateStatus ( * prowapi . ProwJob ) ( * prowapi . ProwJob , error ) { return nil , nil }
1166	func ( c * dryRunProwJobClient ) Delete ( name string , options * metav1 . DeleteOptions ) error { return nil }
1167	func ( c * dryRunProwJobClient ) DeleteCollection ( options * metav1 . DeleteOptions , listOptions metav1 . ListOptions ) error { return nil }
1168	func ( c * dryRunProwJobClient ) Get ( name string , options metav1 . GetOptions ) ( * prowapi . ProwJob , error ) { return nil , nil }
1169	func ( c * dryRunProwJobClient ) List ( opts metav1 . ListOptions ) ( * prowapi . ProwJobList , error ) { var jl prowapi . ProwJobList err := c . request ( "/prowjobs.js" , map [ string ] string { "labelSelector" : opts . LabelSelector } , & jl ) return & jl , err }
1170	func ( c * dryRunProwJobClient ) Watch ( opts metav1 . ListOptions ) ( watch . Interface , error ) { return nil , nil }
1171	func ( c * dryRunProwJobClient ) Patch ( name string , pt types . PatchType , data [ ] byte , subresources ... string ) ( result * prowapi . ProwJob , err error ) { return nil , nil }
1172	func ( c * controller ) hasSynced ( ) bool { if ! c . pjInformer . HasSynced ( ) { if c . wait != "prowjobs" { c . wait = "prowjobs" ns := c . pjNamespace ( ) if ns == "" { ns = "controllers" } logrus . Infof ( "Waiting on prowjobs in %s namespace..." , ns ) } return false } if ! c . prowJobsDone { c . prowJobsDone = true logrus . Info ( "Synced prow jobs" ) } if c . pipelinesDone == nil { c . pipelinesDone = map [ string ] bool { } } for n , cfg := range c . pipelines { if ! cfg . informer . Informer ( ) . HasSynced ( ) { if c . wait != n { c . wait = n logrus . Infof ( "Waiting on %s pipelines..." , n ) } return false } else if ! c . pipelinesDone [ n ] { c . pipelinesDone [ n ] = true logrus . Infof ( "Synced %s pipelines" , n ) } } return true }
1173	func ( c * controller ) Run ( threads int , stop <- chan struct { } ) error { defer runtime . HandleCrash ( ) defer c . workqueue . ShutDown ( ) logrus . Info ( "Starting Pipeline controller" ) logrus . Info ( "Waiting for informer caches to sync" ) if ok := cache . WaitForCacheSync ( stop , c . hasSynced ) ; ! ok { return fmt . Errorf ( "failed to wait for caches to sync" ) } logrus . Info ( "Starting workers" ) for i := 0 ; i < threads ; i ++ { go wait . Until ( c . runWorker , time . Second , stop ) } logrus . Info ( "Started workers" ) <- stop logrus . Info ( "Shutting down workers" ) return nil }
1174	func ( c * controller ) runWorker ( ) { for { key , shutdown := c . workqueue . Get ( ) if shutdown { return } func ( ) { defer c . workqueue . Done ( key ) if err := reconcile ( c , key . ( string ) ) ; err != nil { runtime . HandleError ( fmt . Errorf ( "failed to reconcile %s: %v" , key , err ) ) return } c . workqueue . Forget ( key ) } ( ) } }
1175	func fromKey ( key string ) ( string , string , string , error ) { parts := strings . Split ( key , "/" ) if len ( parts ) != 3 { return "" , "" , "" , fmt . Errorf ( "bad key: %q" , key ) } return parts [ 0 ] , parts [ 1 ] , parts [ 2 ] , nil }
1176	func ( c * controller ) enqueueKey ( ctx string , obj interface { } ) { switch o := obj . ( type ) { case * prowjobv1 . ProwJob : ns := o . Spec . Namespace if ns == "" { ns = o . Namespace } c . workqueue . AddRateLimited ( toKey ( ctx , ns , o . Name ) ) case * pipelinev1alpha1 . PipelineRun : c . workqueue . AddRateLimited ( toKey ( ctx , o . Namespace , o . Name ) ) default : logrus . Warnf ( "cannot enqueue unknown type %T: %v" , o , obj ) return } }
1177	func finalState ( status prowjobv1 . ProwJobState ) bool { switch status { case "" , prowjobv1 . PendingState , prowjobv1 . TriggeredState : return false } return true }
1178	func description ( cond duckv1alpha1 . Condition , fallback string ) string { switch { case cond . Message != "" : return cond . Message case cond . Reason != "" : return cond . Reason } return fallback }
1179	func prowJobStatus ( ps pipelinev1alpha1 . PipelineRunStatus ) ( prowjobv1 . ProwJobState , string ) { started := ps . StartTime finished := ps . CompletionTime pcond := ps . GetCondition ( duckv1alpha1 . ConditionSucceeded ) if pcond == nil { if ! finished . IsZero ( ) { return prowjobv1 . ErrorState , descMissingCondition } return prowjobv1 . TriggeredState , descScheduling } cond := * pcond switch { case cond . Status == untypedcorev1 . ConditionTrue : return prowjobv1 . SuccessState , description ( cond , descSucceeded ) case cond . Status == untypedcorev1 . ConditionFalse : return prowjobv1 . FailureState , description ( cond , descFailed ) case started . IsZero ( ) : return prowjobv1 . TriggeredState , description ( cond , descInitializing ) case cond . Status == untypedcorev1 . ConditionUnknown , finished . IsZero ( ) : return prowjobv1 . PendingState , description ( cond , descRunning ) } logrus . Warnf ( "Unknown condition %#v" , cond ) return prowjobv1 . ErrorState , description ( cond , descUnknown ) }
1180	func pipelineMeta ( pj prowjobv1 . ProwJob ) metav1 . ObjectMeta { labels , annotations := decorate . LabelsAndAnnotationsForJob ( pj ) return metav1 . ObjectMeta { Annotations : annotations , Name : pj . Name , Namespace : pj . Spec . Namespace , Labels : labels , } }
1181	func sourceURL ( pj prowjobv1 . ProwJob ) string { if pj . Spec . Refs == nil { return "" } sourceURL := pj . Spec . Refs . CloneURI if sourceURL == "" { sourceURL = fmt . Sprintf ( "%s.git" , pj . Spec . Refs . RepoLink ) } return sourceURL }
1182	func makePipelineGitResource ( pj prowjobv1 . ProwJob ) * pipelinev1alpha1 . PipelineResource { var revision string if pj . Spec . Refs != nil { if len ( pj . Spec . Refs . Pulls ) > 0 { revision = pj . Spec . Refs . Pulls [ 0 ] . SHA } else { revision = pj . Spec . Refs . BaseSHA } } pr := pipelinev1alpha1 . PipelineResource { ObjectMeta : pipelineMeta ( pj ) , Spec : pipelinev1alpha1 . PipelineResourceSpec { Type : pipelinev1alpha1 . PipelineResourceTypeGit , Params : [ ] pipelinev1alpha1 . Param { { Name : "url" , Value : sourceURL ( pj ) , } , { Name : "revision" , Value : revision , } , } , } , } return & pr }
1183	func makePipelineRun ( pj prowjobv1 . ProwJob , pr * pipelinev1alpha1 . PipelineResource ) ( * pipelinev1alpha1 . PipelineRun , error ) { if pj . Spec . PipelineRunSpec == nil { return nil , errors . New ( "no PipelineSpec defined" ) } p := pipelinev1alpha1 . PipelineRun { ObjectMeta : pipelineMeta ( pj ) , Spec : * pj . Spec . PipelineRunSpec . DeepCopy ( ) , } buildID := pj . Status . BuildID if buildID == "" { return nil , errors . New ( "empty BuildID in status" ) } p . Spec . Params = append ( p . Spec . Params , pipelinev1alpha1 . Param { Name : "build_id" , Value : buildID , } ) rb := pipelinev1alpha1 . PipelineResourceBinding { Name : pr . Name , ResourceRef : pipelinev1alpha1 . PipelineResourceRef { Name : pr . Name , APIVersion : pr . APIVersion , } , } p . Spec . Resources = append ( p . Spec . Resources , rb ) return & p , nil }
1184	func matchingConfigs ( org , repo , branch , label string , allConfigs [ ] plugins . RequireMatchingLabel ) [ ] plugins . RequireMatchingLabel { var filtered [ ] plugins . RequireMatchingLabel for _ , cfg := range allConfigs { if ( branch == "" && ! cfg . Issues ) || ( branch != "" && ! cfg . PRs ) { continue } if org != cfg . Org || ( cfg . Repo != "" && cfg . Repo != repo ) || ( cfg . Branch != "" && branch != "" && cfg . Branch != branch ) { continue } if label != "" && ! cfg . Re . MatchString ( label ) { continue } filtered = append ( filtered , cfg ) } return filtered }
1185	func SuggestCodeChange ( p lint . Problem ) string { var suggestion = "" for regex , handler := range lintHandlersMap { matches := regex . FindStringSubmatch ( p . Text ) suggestion = handler ( p , matches ) if suggestion != "" && suggestion != p . LineText { return formatSuggestion ( suggestion ) } } return "" }
1186	func ServeExternalPluginHelp ( mux * http . ServeMux , log * logrus . Entry , provider ExternalPluginHelpProvider ) { mux . HandleFunc ( "/help" , func ( w http . ResponseWriter , r * http . Request ) { w . Header ( ) . Set ( "Cache-Control" , "no-cache" ) serverError := func ( action string , err error ) { log . WithError ( err ) . Errorf ( "Error %s." , action ) msg := fmt . Sprintf ( "500 Internal server error %s: %v" , action , err ) http . Error ( w , msg , http . StatusInternalServerError ) } if r . Method != http . MethodPost { log . Errorf ( "Invalid request method: %v." , r . Method ) http . Error ( w , "405 Method not allowed" , http . StatusMethodNotAllowed ) return } b , err := ioutil . ReadAll ( r . Body ) if err != nil { serverError ( "reading request body" , err ) return } var enabledRepos [ ] string if err := json . Unmarshal ( b , & enabledRepos ) ; err != nil { serverError ( "unmarshaling request body" , err ) return } if provider == nil { serverError ( "generating plugin help" , errors . New ( "help provider is nil" ) ) return } help , err := provider ( enabledRepos ) if err != nil { serverError ( "generating plugin help" , err ) return } b , err = json . Marshal ( help ) if err != nil { serverError ( "marshaling plugin help" , err ) return } fmt . Fprint ( w , string ( b ) ) } , ) }
1187	func ( p * protector ) protect ( ) { bp := p . cfg . BranchProtection for orgName := range bp . Orgs { org := bp . GetOrg ( orgName ) if err := p . UpdateOrg ( orgName , * org ) ; err != nil { p . errors . add ( fmt . Errorf ( "update %s: %v" , orgName , err ) ) } } if ! bp . ProtectTested { return } for repo := range p . cfg . Presubmits { if p . completedRepos [ repo ] == true { continue } parts := strings . Split ( repo , "/" ) if len ( parts ) != 2 { p . errors . add ( fmt . Errorf ( "bad presubmit repo: %s" , repo ) ) continue } orgName := parts [ 0 ] repoName := parts [ 1 ] repo := bp . GetOrg ( orgName ) . GetRepo ( repoName ) if err := p . UpdateRepo ( orgName , repoName , * repo ) ; err != nil { p . errors . add ( fmt . Errorf ( "update %s/%s: %v" , orgName , repoName , err ) ) } } }
1188	func ( p * protector ) UpdateOrg ( orgName string , org config . Org ) error { var repos [ ] string if org . Protect != nil { rs , err := p . client . GetRepos ( orgName , false ) if err != nil { return fmt . Errorf ( "list repos: %v" , err ) } for _ , r := range rs { if ! r . Archived { repos = append ( repos , r . Name ) } } } else { for r := range org . Repos { repos = append ( repos , r ) } } for _ , repoName := range repos { repo := org . GetRepo ( repoName ) if err := p . UpdateRepo ( orgName , repoName , * repo ) ; err != nil { return fmt . Errorf ( "update %s: %v" , repoName , err ) } } return nil }
1189	func ( p * protector ) UpdateRepo ( orgName string , repoName string , repo config . Repo ) error { p . completedRepos [ orgName + "/" + repoName ] = true githubRepo , err := p . client . GetRepo ( orgName , repoName ) if err != nil { return fmt . Errorf ( "could not get repo to check for archival: %v" , err ) } if githubRepo . Archived { return nil } branches := map [ string ] github . Branch { } for _ , onlyProtected := range [ ] bool { false , true } { bs , err := p . client . GetBranches ( orgName , repoName , onlyProtected ) if err != nil { return fmt . Errorf ( "list branches: %v" , err ) } for _ , b := range bs { branches [ b . Name ] = b } } for bn , githubBranch := range branches { if branch , err := repo . GetBranch ( bn ) ; err != nil { return fmt . Errorf ( "get %s: %v" , bn , err ) } else if err = p . UpdateBranch ( orgName , repoName , bn , * branch , githubBranch . Protected ) ; err != nil { return fmt . Errorf ( "update %s from protected=%t: %v" , bn , githubBranch . Protected , err ) } } return nil }
1190	func ( p * protector ) UpdateBranch ( orgName , repo string , branchName string , branch config . Branch , protected bool ) error { bp , err := p . cfg . GetPolicy ( orgName , repo , branchName , branch ) if err != nil { return fmt . Errorf ( "get policy: %v" , err ) } if bp == nil || bp . Protect == nil { return nil } if ! protected && ! * bp . Protect { logrus . Infof ( "%s/%s=%s: already unprotected" , orgName , repo , branchName ) return nil } var req * github . BranchProtectionRequest if * bp . Protect { r := makeRequest ( * bp ) req = & r } p . updates <- requirements { Org : orgName , Repo : repo , Branch : branchName , Request : req , } return nil }
1191	func ( o * Options ) LoadConfig ( config string ) error { return json . Unmarshal ( [ ] byte ( config ) , o ) }
1192	func ( o * Options ) Run ( ) error { clusterConfig , err := loadClusterConfig ( ) if err != nil { return fmt . Errorf ( "failed to load cluster config: %v" , err ) } client , err := kubernetes . NewForConfig ( clusterConfig ) if err != nil { return err } prowJobClient , err := kube . NewClientInCluster ( o . ProwJobNamespace ) if err != nil { return err } controller := artifact_uploader . NewController ( client . CoreV1 ( ) , prowJobClient , o . Options ) stop := make ( chan struct { } ) defer close ( stop ) go controller . Run ( o . NumWorkers , stop ) select { } }
1193	func ( a * Agent ) Start ( paths [ ] string ) error { secretsMap , err := LoadSecrets ( paths ) if err != nil { return err } a . secretsMap = secretsMap for secretPath := range secretsMap { go a . reloadSecret ( secretPath ) } return nil }
1194	func ( a * Agent ) reloadSecret ( secretPath string ) { var lastModTime time . Time logger := logrus . NewEntry ( logrus . StandardLogger ( ) ) skips := 0 for range time . Tick ( 1 * time . Second ) { if skips < 600 { secretStat , err := os . Stat ( secretPath ) if err != nil { logger . WithField ( "secret-path" , secretPath ) . WithError ( err ) . Error ( "Error loading secret file." ) continue } recentModTime := secretStat . ModTime ( ) if ! recentModTime . After ( lastModTime ) { skips ++ continue } lastModTime = recentModTime } if secretValue , err := LoadSingleSecret ( secretPath ) ; err != nil { logger . WithField ( "secret-path: " , secretPath ) . WithError ( err ) . Error ( "Error loading secret." ) } else { a . setSecret ( secretPath , secretValue ) skips = 0 } } }
1195	func ( a * Agent ) GetSecret ( secretPath string ) [ ] byte { a . RLock ( ) defer a . RUnlock ( ) return a . secretsMap [ secretPath ] }
1196	func ( a * Agent ) setSecret ( secretPath string , secretValue [ ] byte ) { a . Lock ( ) defer a . Unlock ( ) a . secretsMap [ secretPath ] = secretValue }
1197	func ( a * Agent ) GetTokenGenerator ( secretPath string ) func ( ) [ ] byte { return func ( ) [ ] byte { return a . GetSecret ( secretPath ) } }
1198	func New ( maxRecordsPerKey int , opener io . Opener , path string ) ( * History , error ) { hist := & History { logs : map [ string ] * recordLog { } , logSizeLimit : maxRecordsPerKey , opener : opener , path : path , } if path != "" { var err error start := time . Now ( ) hist . logs , err = readHistory ( maxRecordsPerKey , hist . opener , hist . path ) if err != nil { return nil , err } logrus . WithFields ( logrus . Fields { "duration" : time . Since ( start ) . String ( ) , "path" : hist . path , } ) . Debugf ( "Successfully read action history for %d pools." , len ( hist . logs ) ) } return hist , nil }
1199	func ( h * History ) Record ( poolKey , action , baseSHA , err string , targets [ ] prowapi . Pull ) { t := now ( ) sort . Sort ( ByNum ( targets ) ) h . addRecord ( poolKey , & Record { Time : t , Action : action , BaseSHA : baseSHA , Target : targets , Err : err , } , ) }
1200	func ( h * History ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { b , err := json . Marshal ( h . AllRecords ( ) ) if err != nil { logrus . WithError ( err ) . Error ( "Encoding JSON history." ) b = [ ] byte ( "{}" ) } if _ , err = w . Write ( b ) ; err != nil { logrus . WithError ( err ) . Error ( "Writing JSON history response." ) } }
1201	func ( h * History ) Flush ( ) { if h . path == "" { return } records := h . AllRecords ( ) start := time . Now ( ) err := writeHistory ( h . opener , h . path , records ) log := logrus . WithFields ( logrus . Fields { "duration" : time . Since ( start ) . String ( ) , "path" : h . path , } ) if err != nil { log . WithError ( err ) . Error ( "Error flushing action history to GCS." ) } else { log . Debugf ( "Successfully flushed action history for %d pools." , len ( h . logs ) ) } }
1202	func ( h * History ) AllRecords ( ) map [ string ] [ ] * Record { h . Lock ( ) defer h . Unlock ( ) res := make ( map [ string ] [ ] * Record , len ( h . logs ) ) for key , log := range h . logs { res [ key ] = log . toSlice ( ) } return res }
1203	func MakeCommand ( ) * cobra . Command { flags := & flags { } cmd := & cobra . Command { Use : "download [bucket] [prowjob]" , Short : "Finds and downloads the coverage profile file from the latest healthy build" , Long : `Finds and downloads the coverage profile file from the latest healthy build stored in given gcs directory.` , Run : func ( cmd * cobra . Command , args [ ] string ) { run ( flags , cmd , args ) } , } cmd . Flags ( ) . StringVarP ( & flags . outputFile , "output" , "o" , "-" , "output file" ) cmd . Flags ( ) . StringVarP ( & flags . artifactsDirName , "artifactsDir" , "a" , "artifacts" , "artifact directory name in GCS" ) cmd . Flags ( ) . StringVarP ( & flags . profileName , "profile" , "p" , "coverage-profile" , "code coverage profile file name in GCS" ) return cmd }
1204	func ( c * CommentCounterPlugin ) CheckFlags ( ) error { for _ , pattern := range c . pattern { matcher , err := regexp . Compile ( pattern ) if err != nil { return err } c . matcher = append ( c . matcher , matcher ) } return nil }
1205	func ( c * CommentCounterPlugin ) ReceiveComment ( comment sql . Comment ) [ ] Point { points := [ ] Point { } for _ , matcher := range c . matcher { if matcher . MatchString ( comment . Body ) { points = append ( points , Point { Values : map [ string ] interface { } { "comment" : 1 , } , Date : comment . CommentCreatedAt , } ) } } return points }
1206	func NewController ( pjclientset clientset . Interface , queue workqueue . RateLimitingInterface , informer pjinformers . ProwJobInformer , reporter reportClient , numWorkers int , wg * sync . WaitGroup ) * Controller { return & Controller { pjclientset : pjclientset , queue : queue , informer : informer , reporter : reporter , numWorkers : numWorkers , wg : wg , } }
1207	func ( c * Controller ) Run ( stopCh <- chan struct { } ) { defer utilruntime . HandleCrash ( ) defer c . queue . ShutDown ( ) logrus . Info ( "Initiating controller" ) c . informer . Informer ( ) . AddEventHandler ( cache . ResourceEventHandlerFuncs { AddFunc : func ( obj interface { } ) { key , err := cache . MetaNamespaceKeyFunc ( obj ) logrus . WithField ( "prowjob" , key ) . Infof ( "Add prowjob" ) if err != nil { logrus . WithError ( err ) . Error ( "Cannot get key from object meta" ) return } c . queue . AddRateLimited ( key ) } , UpdateFunc : func ( oldObj , newObj interface { } ) { key , err := cache . MetaNamespaceKeyFunc ( newObj ) logrus . WithField ( "prowjob" , key ) . Infof ( "Update prowjob" ) if err != nil { logrus . WithError ( err ) . Error ( "Cannot get key from object meta" ) return } c . queue . AddRateLimited ( key ) } , } ) go c . informer . Informer ( ) . Run ( stopCh ) if ! cache . WaitForCacheSync ( stopCh , c . HasSynced ) { utilruntime . HandleError ( fmt . Errorf ( "Error syncing cache" ) ) return } logrus . Info ( "Controller.Run: cache sync complete" ) for i := 0 ; i < c . numWorkers ; i ++ { go wait . Until ( c . runWorker , time . Second , stopCh ) } logrus . Infof ( "Started %d workers" , c . numWorkers ) <- stopCh logrus . Info ( "Shutting down workers" ) }
1208	func ( c * Controller ) runWorker ( ) { c . wg . Add ( 1 ) for c . processNextItem ( ) { } c . wg . Done ( ) }
1209	func New ( ) ( * LocalGit , * git . Client , error ) { g , err := exec . LookPath ( "git" ) if err != nil { return nil , nil , err } t , err := ioutil . TempDir ( "" , "localgit" ) if err != nil { return nil , nil , err } c , err := git . NewClient ( ) if err != nil { os . RemoveAll ( t ) return nil , nil , err } getSecret := func ( ) [ ] byte { return [ ] byte ( "" ) } c . SetCredentials ( "" , getSecret ) c . SetRemote ( t ) return & LocalGit { Dir : t , Git : g , } , c , nil }
1210	func ( lg * LocalGit ) MakeFakeRepo ( org , repo string ) error { rdir := filepath . Join ( lg . Dir , org , repo ) if err := os . MkdirAll ( rdir , os . ModePerm ) ; err != nil { return err } if err := runCmd ( lg . Git , rdir , "init" ) ; err != nil { return err } if err := runCmd ( lg . Git , rdir , "config" , "user.email" , "test@test.test" ) ; err != nil { return err } if err := runCmd ( lg . Git , rdir , "config" , "user.name" , "test test" ) ; err != nil { return err } if err := runCmd ( lg . Git , rdir , "config" , "commit.gpgsign" , "false" ) ; err != nil { return err } if err := lg . AddCommit ( org , repo , map [ string ] [ ] byte { "initial" : { } } ) ; err != nil { return err } return nil }
1211	func ( lg * LocalGit ) AddCommit ( org , repo string , files map [ string ] [ ] byte ) error { rdir := filepath . Join ( lg . Dir , org , repo ) for f , b := range files { path := filepath . Join ( rdir , f ) if err := os . MkdirAll ( filepath . Dir ( path ) , os . ModePerm ) ; err != nil { return err } if err := ioutil . WriteFile ( path , b , os . ModePerm ) ; err != nil { return err } if err := runCmd ( lg . Git , rdir , "add" , f ) ; err != nil { return err } } return runCmd ( lg . Git , rdir , "commit" , "-m" , "wow" ) }
1212	func ( lg * LocalGit ) CheckoutNewBranch ( org , repo , branch string ) error { rdir := filepath . Join ( lg . Dir , org , repo ) return runCmd ( lg . Git , rdir , "checkout" , "-b" , branch ) }
1213	func ( lg * LocalGit ) Checkout ( org , repo , commitlike string ) error { rdir := filepath . Join ( lg . Dir , org , repo ) return runCmd ( lg . Git , rdir , "checkout" , commitlike ) }
1214	func ( lg * LocalGit ) RevParse ( org , repo , commitlike string ) ( string , error ) { rdir := filepath . Join ( lg . Dir , org , repo ) return runCmdOutput ( lg . Git , rdir , "rev-parse" , commitlike ) }
1215	func CleanAll ( sess * session . Session , region string ) error { acct , err := account . GetAccount ( sess , regions . Default ) if err != nil { return errors . Wrap ( err , "Failed to retrieve account" ) } klog . V ( 1 ) . Infof ( "Account: %s" , acct ) var regionList [ ] string if region == "" { regionList , err = regions . GetAll ( sess ) if err != nil { return errors . Wrap ( err , "Couldn't retrieve list of regions" ) } } else { regionList = [ ] string { region } } klog . Infof ( "Regions: %+v" , regionList ) for _ , r := range regionList { for _ , typ := range RegionalTypeList { set , err := typ . ListAll ( sess , acct , r ) if err != nil { return errors . Wrapf ( err , "Failed to list resources of type %T" , typ ) } if err := typ . MarkAndSweep ( sess , acct , r , set ) ; err != nil { return errors . Wrapf ( err , "Couldn't sweep resources of type %T" , typ ) } } } for _ , typ := range GlobalTypeList { set , err := typ . ListAll ( sess , acct , regions . Default ) if err != nil { return errors . Wrapf ( err , "Failed to list resources of type %T" , typ ) } if err := typ . MarkAndSweep ( sess , acct , regions . Default , set ) ; err != nil { return errors . Wrapf ( err , "Couldn't sweep resources of type %T" , typ ) } } return nil }
1216	func optionsForRepo ( config * plugins . Configuration , org , repo string ) * plugins . Lgtm { fullName := fmt . Sprintf ( "%s/%s" , org , repo ) for i := range config . Lgtm { if ! strInSlice ( org , config . Lgtm [ i ] . Repos ) && ! strInSlice ( fullName , config . Lgtm [ i ] . Repos ) { continue } return & config . Lgtm [ i ] } return & plugins . Lgtm { } }
1217	func getChangedFiles ( gc githubClient , org , repo string , number int ) ( [ ] string , error ) { changes , err := gc . GetPullRequestChanges ( org , repo , number ) if err != nil { return nil , fmt . Errorf ( "cannot get PR changes for %s/%s#%d" , org , repo , number ) } var filenames [ ] string for _ , change := range changes { filenames = append ( filenames , change . Filename ) } return filenames , nil }
1218	func loadReviewers ( ro repoowners . RepoOwner , filenames [ ] string ) sets . String { reviewers := sets . String { } for _ , filename := range filenames { reviewers = reviewers . Union ( ro . Approvers ( filename ) ) . Union ( ro . Reviewers ( filename ) ) } return reviewers }
1219	func NewController ( lastSyncFallback , cookiefilePath string , projects map [ string ] [ ] string , kc * kube . Client , cfg config . Getter ) ( * Controller , error ) { if lastSyncFallback == "" { return nil , errors . New ( "empty lastSyncFallback" ) } var lastUpdate time . Time if buf , err := ioutil . ReadFile ( lastSyncFallback ) ; err == nil { unix , err := strconv . ParseInt ( string ( buf ) , 10 , 64 ) if err != nil { return nil , err } lastUpdate = time . Unix ( unix , 0 ) } else if err != nil && ! os . IsNotExist ( err ) { return nil , fmt . Errorf ( "failed to read lastSyncFallback: %v" , err ) } else { logrus . Warnf ( "lastSyncFallback not found: %s" , lastSyncFallback ) lastUpdate = time . Now ( ) } c , err := client . NewClient ( projects ) if err != nil { return nil , err } c . Start ( cookiefilePath ) return & Controller { kc : kc , config : cfg , gc : c , lastUpdate : lastUpdate , lastSyncFallback : lastSyncFallback , } , nil }
1220	func ( c * Controller ) SaveLastSync ( lastSync time . Time ) error { if c . lastSyncFallback == "" { return nil } lastSyncUnix := strconv . FormatInt ( lastSync . Unix ( ) , 10 ) logrus . Infof ( "Writing last sync: %s" , lastSyncUnix ) tempFile , err := ioutil . TempFile ( filepath . Dir ( c . lastSyncFallback ) , "temp" ) if err != nil { return err } defer os . Remove ( tempFile . Name ( ) ) err = ioutil . WriteFile ( tempFile . Name ( ) , [ ] byte ( lastSyncUnix ) , 0644 ) if err != nil { return err } err = os . Rename ( tempFile . Name ( ) , c . lastSyncFallback ) if err != nil { logrus . WithError ( err ) . Info ( "Rename failed, fallback to copyfile" ) return copyFile ( tempFile . Name ( ) , c . lastSyncFallback ) } return nil }
1221	func ( c * Controller ) Sync ( ) error { syncTime := c . lastUpdate for instance , changes := range c . gc . QueryChanges ( c . lastUpdate , c . config ( ) . Gerrit . RateLimit ) { for _ , change := range changes { if err := c . ProcessChange ( instance , change ) ; err != nil { logrus . WithError ( err ) . Errorf ( "Failed process change %v" , change . CurrentRevision ) } if syncTime . Before ( change . Updated . Time ) { syncTime = change . Updated . Time } } logrus . Infof ( "Processed %d changes for instance %s" , len ( changes ) , instance ) } c . lastUpdate = syncTime if err := c . SaveLastSync ( syncTime ) ; err != nil { logrus . WithError ( err ) . Errorf ( "last sync %v, cannot save to path %v" , syncTime , c . lastSyncFallback ) } return nil }
1222	func ( e * EventCounterPlugin ) AddFlags ( cmd * cobra . Command ) { cmd . Flags ( ) . StringVar ( & e . desc , "event" , "" , "Match event (eg: `opened`)" ) }
1223	func ( e * EventCounterPlugin ) CheckFlags ( ) error { e . matcher = NewEventMatcher ( e . desc ) return nil }
1224	func ( e * EventCounterPlugin ) ReceiveIssueEvent ( event sql . IssueEvent ) [ ] Point { var label string if event . Label != nil { label = * event . Label } if ! e . matcher . Match ( event . Event , label ) { return nil } return [ ] Point { { Values : map [ string ] interface { } { "event" : 1 } , Date : event . EventCreatedAt , } , } }
1225	func Upload ( bucket * storage . BucketHandle , uploadTargets map [ string ] UploadFunc ) error { errCh := make ( chan error , len ( uploadTargets ) ) group := & sync . WaitGroup { } group . Add ( len ( uploadTargets ) ) for dest , upload := range uploadTargets { obj := bucket . Object ( dest ) logrus . WithField ( "dest" , dest ) . Info ( "Queued for upload" ) go func ( f UploadFunc , obj * storage . ObjectHandle , name string ) { defer group . Done ( ) if err := f ( obj ) ; err != nil { errCh <- err } logrus . WithField ( "dest" , name ) . Info ( "Finished upload" ) } ( upload , obj , dest ) } group . Wait ( ) close ( errCh ) if len ( errCh ) != 0 { var uploadErrors [ ] error for err := range errCh { uploadErrors = append ( uploadErrors , err ) } return fmt . Errorf ( "encountered errors during upload: %v" , uploadErrors ) } return nil }
1226	func FileUploadWithMetadata ( file string , metadata map [ string ] string ) UploadFunc { return func ( obj * storage . ObjectHandle ) error { reader , err := os . Open ( file ) if err != nil { return err } uploadErr := DataUploadWithMetadata ( reader , metadata ) ( obj ) closeErr := reader . Close ( ) return errorutil . NewAggregate ( uploadErr , closeErr ) } }
1227	func DataUploadWithMetadata ( src io . Reader , metadata map [ string ] string ) UploadFunc { return func ( obj * storage . ObjectHandle ) error { writer := obj . NewWriter ( context . Background ( ) ) writer . Metadata = metadata _ , copyErr := io . Copy ( writer , src ) closeErr := writer . Close ( ) return errorutil . NewAggregate ( copyErr , closeErr ) } }
1228	func HasLabel ( label string , issueLabels [ ] Label ) bool { for _ , l := range issueLabels { if strings . ToLower ( l . Name ) == strings . ToLower ( label ) { return true } } return false }
1229	func ImageTooBig ( url string ) ( bool , error ) { limit := 10000000 resp , err := http . Head ( url ) if err != nil { return true , fmt . Errorf ( "HEAD error: %v" , err ) } if sc := resp . StatusCode ; sc != http . StatusOK { return true , fmt . Errorf ( "failing %d response" , sc ) } size , _ := strconv . Atoi ( resp . Header . Get ( "Content-Length" ) ) if size > limit { return true , nil } return false , nil }
1230	func LevelFromPermissions ( permissions RepoPermissions ) RepoPermissionLevel { if permissions . Admin { return Admin } else if permissions . Push { return Write } else if permissions . Pull { return Read } else { return None } }
1231	func PermissionsFromLevel ( permission RepoPermissionLevel ) RepoPermissions { switch permission { case None : return RepoPermissions { } case Read : return RepoPermissions { Pull : true } case Write : return RepoPermissions { Pull : true , Push : true } case Admin : return RepoPermissions { Pull : true , Push : true , Admin : true } default : return RepoPermissions { } } }
1232	func newProwJobs ( c * ProwV1Client , namespace string ) * prowJobs { return & prowJobs { client : c . RESTClient ( ) , ns : namespace , } }
1233	func ( b Blockers ) GetApplicable ( org , repo , branch string ) [ ] Blocker { var res [ ] Blocker res = append ( res , b . Repo [ orgRepo { org : org , repo : repo } ] ... ) res = append ( res , b . Branch [ orgRepoBranch { org : org , repo : repo , branch : branch } ] ... ) sort . Slice ( res , func ( i , j int ) bool { return res [ i ] . Number < res [ j ] . Number } ) return res }
1234	func serve ( jc * jenkins . Client ) { http . Handle ( "/" , gziphandler . GzipHandler ( handleLog ( jc ) ) ) http . Handle ( "/metrics" , promhttp . Handler ( ) ) logrus . WithError ( http . ListenAndServe ( ":8080" , nil ) ) . Fatal ( "ListenAndServe returned." ) }
1235	func NewCountPlugin ( runner func ( Plugin ) error ) * cobra . Command { stateCounter := & StatePlugin { } eventCounter := & EventCounterPlugin { } commentsAsEvents := NewFakeCommentPluginWrapper ( eventCounter ) commentCounter := & CommentCounterPlugin { } authorLoggable := NewMultiplexerPluginWrapper ( commentsAsEvents , commentCounter , ) authorLogged := NewAuthorLoggerPluginWrapper ( authorLoggable ) fullMultiplex := NewMultiplexerPluginWrapper ( authorLogged , stateCounter ) fakeOpen := NewFakeOpenPluginWrapper ( fullMultiplex ) typeFilter := NewTypeFilterWrapperPlugin ( fakeOpen ) authorFilter := NewAuthorFilterPluginWrapper ( typeFilter ) cmd := & cobra . Command { Use : "count" , Short : "Count events and number of issues in given state, and for how long" , RunE : func ( cmd * cobra . Command , args [ ] string ) error { if err := eventCounter . CheckFlags ( ) ; err != nil { return err } if err := stateCounter . CheckFlags ( ) ; err != nil { return err } if err := typeFilter . CheckFlags ( ) ; err != nil { return err } if err := commentCounter . CheckFlags ( ) ; err != nil { return err } return runner ( authorFilter ) } , } eventCounter . AddFlags ( cmd ) stateCounter . AddFlags ( cmd ) commentCounter . AddFlags ( cmd ) typeFilter . AddFlags ( cmd ) authorFilter . AddFlags ( cmd ) authorLogged . AddFlags ( cmd ) return cmd }
1236	func ( o * FakeCommentPluginWrapper ) ReceiveComment ( comment sql . Comment ) [ ] Point { fakeEvent := sql . IssueEvent { IssueID : comment . IssueID , Event : "commented" , EventCreatedAt : comment . CommentCreatedAt , Actor : & comment . User , } return append ( o . plugin . ReceiveComment ( comment ) , o . plugin . ReceiveIssueEvent ( fakeEvent ) ... , ) }
1237	func updateMetrics ( interval time . Duration , diskRoot string ) { logger := logrus . WithField ( "sync-loop" , "updateMetrics" ) ticker := time . NewTicker ( interval ) for ; true ; <- ticker . C { logger . Info ( "tick" ) _ , bytesFree , bytesUsed , err := diskutil . GetDiskUsage ( diskRoot ) if err != nil { logger . WithError ( err ) . Error ( "Failed to get disk metrics" ) } else { promMetrics . DiskFree . Set ( float64 ( bytesFree ) / 1e9 ) promMetrics . DiskUsed . Set ( float64 ( bytesUsed ) / 1e9 ) promMetrics . DiskTotal . Set ( float64 ( bytesFree + bytesUsed ) / 1e9 ) } } }
1238	func ( r * Ranch ) LogStatus ( ) { resources , err := r . Storage . GetResources ( ) if err != nil { return } resJSON , err := json . Marshal ( resources ) if err != nil { logrus . WithError ( err ) . Errorf ( "Fail to marshal Resources. %v" , resources ) } logrus . Infof ( "Current Resources : %v" , string ( resJSON ) ) }
1239	func ( r * Ranch ) SyncConfig ( config string ) error { resources , err := ParseConfig ( config ) if err != nil { return err } if err := r . Storage . SyncResources ( resources ) ; err != nil { return err } return nil }
1240	func ( r * Ranch ) Metric ( rtype string ) ( common . Metric , error ) { metric := common . Metric { Type : rtype , Current : map [ string ] int { } , Owners : map [ string ] int { } , } resources , err := r . Storage . GetResources ( ) if err != nil { logrus . WithError ( err ) . Error ( "cannot find resources" ) return metric , & ResourceNotFound { rtype } } for _ , res := range resources { if res . Type != rtype { continue } if _ , ok := metric . Current [ res . State ] ; ! ok { metric . Current [ res . State ] = 0 } if _ , ok := metric . Owners [ res . Owner ] ; ! ok { metric . Owners [ res . Owner ] = 0 } metric . Current [ res . State ] ++ metric . Owners [ res . Owner ] ++ } if len ( metric . Current ) == 0 && len ( metric . Owners ) == 0 { return metric , & ResourceNotFound { rtype } } return metric , nil }
1241	func FormatURL ( dogURL string ) ( string , error ) { if dogURL == "" { return "" , errors . New ( "empty url" ) } src , err := url . ParseRequestURI ( dogURL ) if err != nil { return "" , fmt . Errorf ( "invalid url %s: %v" , dogURL , err ) } return fmt . Sprintf ( "[![dog image](%s)](%s)" , src , src ) , nil }
1242	func runAndSkipJobs ( c Client , pr * github . PullRequest , requestedJobs [ ] config . Presubmit , skippedJobs [ ] config . Presubmit , eventGUID string , elideSkippedContexts bool ) error { if err := validateContextOverlap ( requestedJobs , skippedJobs ) ; err != nil { c . Logger . WithError ( err ) . Warn ( "Could not run or skip requested jobs, overlapping contexts." ) return err } runErr := RunRequested ( c , pr , requestedJobs , eventGUID ) var skipErr error if ! elideSkippedContexts { skipErr = skipRequested ( c , pr , skippedJobs ) } return errorutil . NewAggregate ( runErr , skipErr ) }
1243	func validateContextOverlap ( toRun , toSkip [ ] config . Presubmit ) error { requestedContexts := sets . NewString ( ) for _ , job := range toRun { requestedContexts . Insert ( job . Context ) } skippedContexts := sets . NewString ( ) for _ , job := range toSkip { skippedContexts . Insert ( job . Context ) } if overlap := requestedContexts . Intersection ( skippedContexts ) . List ( ) ; len ( overlap ) > 0 { return fmt . Errorf ( "the following contexts are both triggered and skipped: %s" , strings . Join ( overlap , ", " ) ) } return nil }
1244	func RunRequested ( c Client , pr * github . PullRequest , requestedJobs [ ] config . Presubmit , eventGUID string ) error { baseSHA , err := c . GitHubClient . GetRef ( pr . Base . Repo . Owner . Login , pr . Base . Repo . Name , "heads/" + pr . Base . Ref ) if err != nil { return err } var errors [ ] error for _ , job := range requestedJobs { c . Logger . Infof ( "Starting %s build." , job . Name ) pj := pjutil . NewPresubmit ( * pr , baseSHA , job , eventGUID ) c . Logger . WithFields ( pjutil . ProwJobFields ( & pj ) ) . Info ( "Creating a new prowjob." ) if _ , err := c . ProwJobClient . Create ( & pj ) ; err != nil { c . Logger . WithError ( err ) . Error ( "Failed to create prowjob." ) errors = append ( errors , err ) } } return errorutil . NewAggregate ( errors ... ) }
1245	func skipRequested ( c Client , pr * github . PullRequest , skippedJobs [ ] config . Presubmit ) error { var errors [ ] error for _ , job := range skippedJobs { if job . SkipReport { continue } c . Logger . Infof ( "Skipping %s build." , job . Name ) if err := c . GitHubClient . CreateStatus ( pr . Base . Repo . Owner . Login , pr . Base . Repo . Name , pr . Head . SHA , skippedStatusFor ( job . Context ) ) ; err != nil { errors = append ( errors , err ) } } return errorutil . NewAggregate ( errors ... ) }
1246	func ( l LabelEvent ) Match ( eventName , label string ) bool { return eventName == "labeled" && label == l . Label }
1247	func ( u UnlabelEvent ) Match ( eventName , label string ) bool { return eventName == "unlabeled" && label == u . Label }
1248	func ( o * GitHubOptions ) AddFlags ( fs * flag . FlagSet ) { o . addFlags ( true , fs ) }
1249	func ( o * GitHubOptions ) AddFlagsWithoutDefaultGitHubTokenPath ( fs * flag . FlagSet ) { o . addFlags ( false , fs ) }
1250	func ( o * GitHubOptions ) Validate ( dryRun bool ) error { for _ , uri := range o . endpoint . Strings ( ) { if uri == "" { uri = github . DefaultAPIEndpoint } else if _ , err := url . ParseRequestURI ( uri ) ; err != nil { return fmt . Errorf ( "invalid -github-endpoint URI: %q" , uri ) } } if o . graphqlEndpoint == "" { o . graphqlEndpoint = github . DefaultGraphQLEndpoint } else if _ , err := url . Parse ( o . graphqlEndpoint ) ; err != nil { return fmt . Errorf ( "invalid -github-graphql-endpoint URI: %q" , o . graphqlEndpoint ) } if o . deprecatedTokenFile != "" { o . TokenPath = o . deprecatedTokenFile logrus . Error ( "-github-token-file is deprecated and may be removed anytime after 2019-01-01. Use -github-token-path instead." ) } if o . TokenPath == "" { logrus . Warn ( "empty -github-token-path, will use anonymous github client" ) } return nil }
1251	func ( o * GitHubOptions ) GitHubClientWithLogFields ( secretAgent * secret . Agent , dryRun bool , fields logrus . Fields ) ( client * github . Client , err error ) { var generator * func ( ) [ ] byte if o . TokenPath == "" { generatorFunc := func ( ) [ ] byte { return [ ] byte { } } generator = & generatorFunc } else { if secretAgent == nil { return nil , fmt . Errorf ( "cannot store token from %q without a secret agent" , o . TokenPath ) } generatorFunc := secretAgent . GetTokenGenerator ( o . TokenPath ) generator = & generatorFunc } if dryRun { return github . NewDryRunClientWithFields ( fields , * generator , o . graphqlEndpoint , o . endpoint . Strings ( ) ... ) , nil } return github . NewClientWithFields ( fields , * generator , o . graphqlEndpoint , o . endpoint . Strings ( ) ... ) , nil }
1252	func ( o * GitHubOptions ) GitHubClient ( secretAgent * secret . Agent , dryRun bool ) ( client * github . Client , err error ) { return o . GitHubClientWithLogFields ( secretAgent , dryRun , logrus . Fields { } ) }
1253	func ( o * GitHubOptions ) GitClient ( secretAgent * secret . Agent , dryRun bool ) ( client * git . Client , err error ) { client , err = git . NewClient ( ) if err != nil { return nil , err } defer func ( client * git . Client ) { if err != nil { client . Clean ( ) } } ( client ) githubClient , err := o . GitHubClient ( secretAgent , dryRun ) if err != nil { return nil , fmt . Errorf ( "error getting GitHub client: %v" , err ) } botName , err := githubClient . BotName ( ) if err != nil { return nil , fmt . Errorf ( "error getting bot name: %v" , err ) } client . SetCredentials ( botName , secretAgent . GetTokenGenerator ( o . TokenPath ) ) return client , nil }
1254	func toMap ( g * calculation . CoverageList ) map [ string ] calculation . Coverage { m := make ( map [ string ] calculation . Coverage ) for _ , cov := range g . Group { m [ cov . Name ] = cov } return m }
1255	func findChanges ( baseList * calculation . CoverageList , newList * calculation . CoverageList ) [ ] * coverageChange { var changes [ ] * coverageChange baseFilesMap := toMap ( baseList ) for _ , newCov := range newList . Group { baseCov , ok := baseFilesMap [ newCov . Name ] var baseRatio float32 if ! ok { baseRatio = - 1 } else { baseRatio = baseCov . Ratio ( ) } newRatio := newCov . Ratio ( ) if isChangeSignificant ( baseRatio , newRatio ) { changes = append ( changes , & coverageChange { name : newCov . Name , baseRatio : baseRatio , newRatio : newRatio , } ) } } return changes }
1256	func ( config * MySQLConfig ) CreateDatabase ( ) ( * gorm . DB , error ) { db , err := gorm . Open ( "mysql" , config . getDSN ( "" ) ) if err != nil { return nil , err } db . Exec ( fmt . Sprintf ( "CREATE DATABASE IF NOT EXISTS %v;" , config . Db ) ) db . Close ( ) db , err = gorm . Open ( "mysql" , config . getDSN ( config . Db ) ) err = db . AutoMigrate ( & Assignee { } , & Issue { } , & IssueEvent { } , & Label { } , & Comment { } ) . Error if err != nil { return nil , err } return db , nil }
1257	func ( c * Client ) ShouldReport ( pj * v1 . ProwJob ) bool { if ! pj . Spec . Report { return false } if pj . Spec . Type != v1 . PresubmitJob && pj . Spec . Type != v1 . PostsubmitJob { return false } if c . reportAgent != "" && pj . Spec . Agent != c . reportAgent { return false } return true }
1258	func ( c * Client ) Report ( pj * v1 . ProwJob ) ( [ ] * v1 . ProwJob , error ) { return [ ] * v1 . ProwJob { pj } , report . Report ( c . gc , c . config ( ) . Plank . ReportTemplate , * pj , c . config ( ) . GitHubReporter . JobTypesToReport ) }
1259	func ( s * Set ) MarkComplete ( ) int { var gone [ ] string for key := range s . firstSeen { if ! s . marked [ key ] { gone = append ( gone , key ) } } for _ , key := range gone { klog . V ( 1 ) . Infof ( "%s: deleted since last run" , key ) delete ( s . firstSeen , key ) } if len ( s . swept ) > 0 { klog . Errorf ( "%d resources swept: %v" , len ( s . swept ) , s . swept ) } return len ( s . swept ) }
1260	func NewJobAgent ( kc serviceClusterClient , plClients map [ string ] PodLogClient , cfg config . Getter ) * JobAgent { return & JobAgent { kc : kc , pkcs : plClients , config : cfg , } }
1261	func ( ja * JobAgent ) Start ( ) { ja . tryUpdate ( ) go func ( ) { t := time . Tick ( period ) for range t { ja . tryUpdate ( ) } } ( ) }
1262	func ( ja * JobAgent ) Jobs ( ) [ ] Job { ja . mut . Lock ( ) defer ja . mut . Unlock ( ) res := make ( [ ] Job , len ( ja . jobs ) ) copy ( res , ja . jobs ) return res }
1263	func ( ja * JobAgent ) ProwJobs ( ) [ ] prowapi . ProwJob { ja . mut . Lock ( ) defer ja . mut . Unlock ( ) res := make ( [ ] prowapi . ProwJob , len ( ja . prowJobs ) ) copy ( res , ja . prowJobs ) return res }
1264	func ( ja * JobAgent ) GetProwJob ( job , id string ) ( prowapi . ProwJob , error ) { if ja == nil { return prowapi . ProwJob { } , fmt . Errorf ( "Prow job agent doesn't exist (are you running locally?)" ) } var j prowapi . ProwJob ja . mut . Lock ( ) idMap , ok := ja . jobsIDMap [ job ] if ok { j , ok = idMap [ id ] } ja . mut . Unlock ( ) if ! ok { return prowapi . ProwJob { } , errProwjobNotFound } return j , nil }
1265	func ( ja * JobAgent ) GetJobLog ( job , id string ) ( [ ] byte , error ) { j , err := ja . GetProwJob ( job , id ) if err != nil { return nil , fmt . Errorf ( "error getting prowjob: %v" , err ) } if j . Spec . Agent == prowapi . KubernetesAgent { client , ok := ja . pkcs [ j . ClusterAlias ( ) ] if ! ok { return nil , fmt . Errorf ( "cannot get logs for prowjob %q with agent %q: unknown cluster alias %q" , j . ObjectMeta . Name , j . Spec . Agent , j . ClusterAlias ( ) ) } return client . GetLogs ( j . Status . PodName , & coreapi . PodLogOptions { Container : kube . TestContainerName } ) } for _ , agentToTmpl := range ja . config ( ) . Deck . ExternalAgentLogs { if agentToTmpl . Agent != string ( j . Spec . Agent ) { continue } if ! agentToTmpl . Selector . Matches ( labels . Set ( j . ObjectMeta . Labels ) ) { continue } var b bytes . Buffer if err := agentToTmpl . URLTemplate . Execute ( & b , & j ) ; err != nil { return nil , fmt . Errorf ( "cannot execute URL template for prowjob %q with agent %q: %v" , j . ObjectMeta . Name , j . Spec . Agent , err ) } resp , err := http . Get ( b . String ( ) ) if err != nil { return nil , err } defer resp . Body . Close ( ) return ioutil . ReadAll ( resp . Body ) } return nil , fmt . Errorf ( "cannot get logs for prowjob %q with agent %q: the agent is missing from the prow config file" , j . ObjectMeta . Name , j . Spec . Agent ) }
1266	func unionStrings ( parent , child [ ] string ) [ ] string { if child == nil { return parent } if parent == nil { return child } s := sets . NewString ( parent ... ) s . Insert ( child ... ) return s . List ( ) }
1267	func ( p Policy ) Apply ( child Policy ) Policy { return Policy { Protect : selectBool ( p . Protect , child . Protect ) , RequiredStatusChecks : mergeContextPolicy ( p . RequiredStatusChecks , child . RequiredStatusChecks ) , Admins : selectBool ( p . Admins , child . Admins ) , Restrictions : mergeRestrictions ( p . Restrictions , child . Restrictions ) , RequiredPullRequestReviews : mergeReviewPolicy ( p . RequiredPullRequestReviews , child . RequiredPullRequestReviews ) , } }
1268	func ( bp BranchProtection ) GetOrg ( name string ) * Org { o , ok := bp . Orgs [ name ] if ok { o . Policy = bp . Apply ( o . Policy ) } else { o . Policy = bp . Policy } return & o }
1269	func ( o Org ) GetRepo ( name string ) * Repo { r , ok := o . Repos [ name ] if ok { r . Policy = o . Apply ( r . Policy ) } else { r . Policy = o . Policy } return & r }
1270	func ( r Repo ) GetBranch ( name string ) ( * Branch , error ) { b , ok := r . Branches [ name ] if ok { b . Policy = r . Apply ( b . Policy ) if b . Protect == nil { return nil , errors . New ( "defined branch policies must set protect" ) } } else { b . Policy = r . Policy } return & b , nil }
1271	func ( c * Config ) GetPolicy ( org , repo , branch string , b Branch ) ( * Policy , error ) { policy := b . Policy if prowContexts , _ , _ := BranchRequirements ( org , repo , branch , c . Presubmits ) ; len ( prowContexts ) > 0 { if policy . Protect != nil && ! * policy . Protect { return nil , fmt . Errorf ( "required prow jobs require branch protection" ) } ps := Policy { RequiredStatusChecks : & ContextPolicy { Contexts : prowContexts , } , } if c . BranchProtection . ProtectTested { yes := true ps . Protect = & yes } policy = policy . Apply ( ps ) } if policy . Protect != nil && ! * policy . Protect { var old * bool old , policy . Protect = policy . Protect , old switch { case policy . defined ( ) && c . BranchProtection . AllowDisabledPolicies : logrus . Warnf ( "%s/%s=%s defines a policy but has protect: false" , org , repo , branch ) policy = Policy { Protect : policy . Protect , } case policy . defined ( ) : return nil , fmt . Errorf ( "%s/%s=%s defines a policy, which requires protect: true" , org , repo , branch ) } policy . Protect = old } if ! policy . defined ( ) { return nil , nil } return & policy , nil }
1272	func UpdateIssueEvents ( issueID int , db * gorm . DB , client ClientInterface ) { latest , err := findLatestEvent ( issueID , db , client . RepositoryName ( ) ) if err != nil { glog . Error ( "Failed to find last event: " , err ) return } c := make ( chan * github . IssueEvent , 500 ) go client . FetchIssueEvents ( issueID , latest , c ) for event := range c { eventOrm , err := NewIssueEvent ( event , issueID , client . RepositoryName ( ) ) if err != nil { glog . Error ( "Failed to create issue-event" , err ) } db . Create ( eventOrm ) } }
1273	func ( c * controller ) enqueueKey ( ctx string , obj interface { } ) { switch o := obj . ( type ) { case * prowjobv1 . ProwJob : c . workqueue . AddRateLimited ( toKey ( ctx , o . Spec . Namespace , o . Name ) ) case * buildv1alpha1 . Build : c . workqueue . AddRateLimited ( toKey ( ctx , o . Namespace , o . Name ) ) default : logrus . Warnf ( "cannot enqueue unknown type %T: %v" , o , obj ) return } }
1274	func prowJobStatus ( bs buildv1alpha1 . BuildStatus ) ( prowjobv1 . ProwJobState , string ) { started := bs . StartTime finished := bs . CompletionTime pcond := bs . GetCondition ( buildv1alpha1 . BuildSucceeded ) if pcond == nil { if ! finished . IsZero ( ) { return prowjobv1 . ErrorState , descMissingCondition } return prowjobv1 . TriggeredState , descScheduling } cond := * pcond switch { case cond . Status == coreapi . ConditionTrue : return prowjobv1 . SuccessState , description ( cond , descSucceeded ) case cond . Status == coreapi . ConditionFalse : return prowjobv1 . FailureState , description ( cond , descFailed ) case started . IsZero ( ) : return prowjobv1 . TriggeredState , description ( cond , descInitializing ) case cond . Status == coreapi . ConditionUnknown , finished . IsZero ( ) : return prowjobv1 . PendingState , description ( cond , descRunning ) } logrus . Warnf ( "Unknown condition %#v" , cond ) return prowjobv1 . ErrorState , description ( cond , descUnknown ) }
1275	func buildEnv ( pj prowjobv1 . ProwJob , buildID string ) ( map [ string ] string , error ) { return downwardapi . EnvForSpec ( downwardapi . NewJobSpec ( pj . Spec , buildID , pj . Name ) ) }
1276	func defaultArguments ( t * buildv1alpha1 . TemplateInstantiationSpec , rawEnv map [ string ] string ) { keys := sets . String { } for _ , arg := range t . Arguments { keys . Insert ( arg . Name ) } for _ , k := range sets . StringKeySet ( rawEnv ) . List ( ) { if keys . Has ( k ) { continue } t . Arguments = append ( t . Arguments , buildv1alpha1 . ArgumentSpec { Name : k , Value : rawEnv [ k ] } ) } }
1277	func defaultEnv ( c * coreapi . Container , rawEnv map [ string ] string ) { keys := sets . String { } for _ , arg := range c . Env { keys . Insert ( arg . Name ) } for _ , k := range sets . StringKeySet ( rawEnv ) . List ( ) { if keys . Has ( k ) { continue } c . Env = append ( c . Env , coreapi . EnvVar { Name : k , Value : rawEnv [ k ] } ) } }
1278	func injectSource ( b * buildv1alpha1 . Build , pj prowjobv1 . ProwJob ) ( bool , error ) { if b . Spec . Source != nil { return false , nil } srcContainer , refs , cloneVolumes , err := decorate . CloneRefs ( pj , codeMount , logMount ) if err != nil { return false , fmt . Errorf ( "clone source error: %v" , err ) } if srcContainer == nil { return false , nil } else { srcContainer . Name = "" } b . Spec . Source = & buildv1alpha1 . SourceSpec { Custom : srcContainer , } b . Spec . Volumes = append ( b . Spec . Volumes , cloneVolumes ... ) wd := workDir ( refs [ 0 ] ) for i := range b . Spec . Steps { if b . Spec . Steps [ i ] . WorkingDir != "" { continue } b . Spec . Steps [ i ] . WorkingDir = wd . Value } if b . Spec . Template != nil { b . Spec . Template . Arguments = append ( b . Spec . Template . Arguments , wd ) } return true , nil }
1279	func injectedSteps ( encodedJobSpec string , dc prowjobv1 . DecorationConfig , injectedSource bool , toolsMount coreapi . VolumeMount , entries [ ] wrapper . Options ) ( [ ] coreapi . Container , * coreapi . Container , * coreapi . Volume , error ) { gcsVol , gcsMount , gcsOptions := decorate . GCSOptions ( dc ) sidecar , err := decorate . Sidecar ( dc . UtilityImages . Sidecar , gcsOptions , gcsMount , logMount , encodedJobSpec , decorate . RequirePassingEntries , entries ... ) if err != nil { return nil , nil , nil , fmt . Errorf ( "inject sidecar: %v" , err ) } var cloneLogMount * coreapi . VolumeMount if injectedSource { cloneLogMount = & logMount } initUpload , err := decorate . InitUpload ( dc . UtilityImages . InitUpload , gcsOptions , gcsMount , cloneLogMount , encodedJobSpec ) if err != nil { return nil , nil , nil , fmt . Errorf ( "inject initupload: %v" , err ) } placer := decorate . PlaceEntrypoint ( dc . UtilityImages . Entrypoint , toolsMount ) return [ ] coreapi . Container { placer , * initUpload } , sidecar , & gcsVol , nil }
1280	func determineTimeout ( spec * buildv1alpha1 . BuildSpec , dc * prowjobv1 . DecorationConfig , defaultTimeout time . Duration ) time . Duration { switch { case spec . Timeout != nil : return spec . Timeout . Duration case dc != nil && dc . Timeout . Duration > 0 : return dc . Timeout . Duration default : return defaultTimeout } }
1281	func makeBuild ( pj prowjobv1 . ProwJob , defaultTimeout time . Duration ) ( * buildv1alpha1 . Build , error ) { if pj . Spec . BuildSpec == nil { return nil , errors . New ( "nil BuildSpec in spec" ) } buildID := pj . Status . BuildID if buildID == "" { return nil , errors . New ( "empty BuildID in status" ) } b := buildv1alpha1 . Build { ObjectMeta : buildMeta ( pj ) , Spec : * pj . Spec . BuildSpec . DeepCopy ( ) , } rawEnv , err := buildEnv ( pj , buildID ) if err != nil { return nil , fmt . Errorf ( "environment error: %v" , err ) } injectEnvironment ( & b , rawEnv ) injectedSource , err := injectSource ( & b , pj ) if err != nil { return nil , fmt . Errorf ( "inject source: %v" , err ) } injectTimeout ( & b . Spec , pj . Spec . DecorationConfig , defaultTimeout ) if pj . Spec . DecorationConfig != nil { encodedJobSpec := rawEnv [ downwardapi . JobSpecEnv ] err = decorateBuild ( & b . Spec , encodedJobSpec , * pj . Spec . DecorationConfig , injectedSource ) if err != nil { return nil , fmt . Errorf ( "decorate build: %v" , err ) } } return & b , nil }
1282	func newLabels ( issueID int , gLabels [ ] github . Label , repository string ) ( [ ] sql . Label , error ) { labels := [ ] sql . Label { } repository = strings . ToLower ( repository ) for _ , label := range gLabels { if label . Name == nil { return nil , fmt . Errorf ( "Label is missing name field" ) } labels = append ( labels , sql . Label { IssueID : strconv . Itoa ( issueID ) , Name : * label . Name , Repository : repository , } ) } return labels , nil }
1283	func newAssignees ( issueID int , gAssignees [ ] * github . User , repository string ) ( [ ] sql . Assignee , error ) { assignees := [ ] sql . Assignee { } repository = strings . ToLower ( repository ) for _ , assignee := range gAssignees { if assignee != nil && assignee . Login == nil { return nil , fmt . Errorf ( "Assignee is missing Login field" ) } assignees = append ( assignees , sql . Assignee { IssueID : strconv . Itoa ( issueID ) , Name : * assignee . Login , Repository : repository , } ) } return assignees , nil }
1284	func NewIssueComment ( issueID int , gComment * github . IssueComment , repository string ) ( * sql . Comment , error ) { if gComment . ID == nil || gComment . Body == nil || gComment . CreatedAt == nil || gComment . UpdatedAt == nil { return nil , fmt . Errorf ( "IssueComment is missing mandatory field: %s" , gComment ) } var login string if gComment . User != nil && gComment . User . Login != nil { login = * gComment . User . Login } return & sql . Comment { ID : itoa ( * gComment . ID ) , IssueID : strconv . Itoa ( issueID ) , Body : * gComment . Body , User : login , CommentCreatedAt : * gComment . CreatedAt , CommentUpdatedAt : * gComment . UpdatedAt , PullRequest : false , Repository : strings . ToLower ( repository ) , } , nil }
1285	func messageFilter ( lastUpdate time . Time , change client . ChangeInfo , presubmits [ ] config . Presubmit ) ( pjutil . Filter , error ) { var filters [ ] pjutil . Filter currentRevision := change . Revisions [ change . CurrentRevision ] . Number for _ , message := range change . Messages { messageTime := message . Date . Time if message . RevisionNumber != currentRevision || ! messageTime . After ( lastUpdate ) { continue } if ! pjutil . TestAllRe . MatchString ( message . Message ) { for _ , presubmit := range presubmits { if presubmit . TriggerMatches ( message . Message ) { logrus . Infof ( "Change %d: Comment %s matches triggering regex, for %s." , change . Number , message . Message , presubmit . Name ) filters = append ( filters , pjutil . CommandFilter ( message . Message ) ) } } } else { filters = append ( filters , pjutil . TestAllFilter ( ) ) } } return pjutil . AggregateFilter ( filters ) , nil }
1286	func ( jb * Build ) IsSuccess ( ) bool { return jb . Result != nil && * jb . Result == success }
1287	func ( jb * Build ) IsFailure ( ) bool { return jb . Result != nil && ( * jb . Result == failure || * jb . Result == unstable ) }
1288	func ( jb * Build ) IsAborted ( ) bool { return jb . Result != nil && * jb . Result == aborted }
1289	func ( jb * Build ) ProwJobID ( ) string { for _ , action := range jb . Actions { for _ , p := range action . Parameters { if p . Name == prowJobID { value , ok := p . Value . ( string ) if ! ok { logrus . Errorf ( "Cannot determine %s value for %#v" , p . Name , jb ) continue } return value } } } return "" }
1290	func ( jb * Build ) BuildID ( ) string { var buildID string hasProwJobID := false for _ , action := range jb . Actions { for _ , p := range action . Parameters { hasProwJobID = hasProwJobID || p . Name == prowJobID if p . Name == statusBuildID { value , ok := p . Value . ( string ) if ! ok { logrus . Errorf ( "Cannot determine %s value for %#v" , p . Name , jb ) continue } buildID = value } } } if ! hasProwJobID { return "" } return buildID }
1291	func ( c * Client ) CrumbRequest ( ) error { if c . authConfig . csrfToken != "" && c . authConfig . csrfRequestField != "" { return nil } c . logger . Debug ( "CrumbRequest" ) data , err := c . GetSkipMetrics ( "/crumbIssuer/api/json" ) if err != nil { return err } crumbResp := struct { Crumb string `json:"crumb"` CrumbRequestField string `json:"crumbRequestField"` } { } if err := json . Unmarshal ( data , & crumbResp ) ; err != nil { return fmt . Errorf ( "cannot unmarshal crumb response: %v" , err ) } c . authConfig . csrfToken = crumbResp . Crumb c . authConfig . csrfRequestField = crumbResp . CrumbRequestField return nil }
1292	func ( c * Client ) measure ( method , path string , code int , start time . Time ) { if c . metrics == nil { return } c . metrics . RequestLatency . WithLabelValues ( method , path ) . Observe ( time . Since ( start ) . Seconds ( ) ) c . metrics . Requests . WithLabelValues ( method , path , fmt . Sprintf ( "%d" , code ) ) . Inc ( ) }
1293	func ( c * Client ) GetSkipMetrics ( path string ) ( [ ] byte , error ) { resp , err := c . request ( http . MethodGet , path , nil , false ) if err != nil { return nil , err } return readResp ( resp ) }
1294	func ( c * Client ) Get ( path string ) ( [ ] byte , error ) { resp , err := c . request ( http . MethodGet , path , nil , true ) if err != nil { return nil , err } return readResp ( resp ) }
1295	func ( c * Client ) request ( method , path string , params url . Values , measure bool ) ( * http . Response , error ) { var resp * http . Response var err error backoff := retryDelay urlPath := fmt . Sprintf ( "%s%s" , c . baseURL , path ) if params != nil { urlPath = fmt . Sprintf ( "%s?%s" , urlPath , params . Encode ( ) ) } start := time . Now ( ) for retries := 0 ; retries < maxRetries ; retries ++ { resp , err = c . doRequest ( method , urlPath ) if err == nil && resp . StatusCode < 500 { break } else if err == nil && retries + 1 < maxRetries { resp . Body . Close ( ) } if measure && c . metrics != nil { c . metrics . RequestRetries . Inc ( ) } time . Sleep ( backoff ) backoff *= 2 } if measure && resp != nil { c . measure ( method , path , resp . StatusCode , start ) } return resp , err }
1296	func ( c * Client ) doRequest ( method , path string ) ( * http . Response , error ) { req , err := http . NewRequest ( method , path , nil ) if err != nil { return nil , err } if c . authConfig != nil { if c . authConfig . Basic != nil { req . SetBasicAuth ( c . authConfig . Basic . User , string ( c . authConfig . Basic . GetToken ( ) ) ) } if c . authConfig . BearerToken != nil { req . Header . Set ( "Authorization" , fmt . Sprintf ( "Bearer %s" , c . authConfig . BearerToken . GetToken ( ) ) ) } if c . authConfig . CSRFProtect && c . authConfig . csrfRequestField != "" && c . authConfig . csrfToken != "" { req . Header . Set ( c . authConfig . csrfRequestField , c . authConfig . csrfToken ) } } return c . client . Do ( req ) }
1297	func getJobName ( spec * prowapi . ProwJobSpec ) string { if spec . JenkinsSpec != nil && spec . JenkinsSpec . GitHubBranchSourceJob && spec . Refs != nil { if len ( spec . Refs . Pulls ) > 0 { return fmt . Sprintf ( "%s/view/change-requests/job/PR-%d" , spec . Job , spec . Refs . Pulls [ 0 ] . Number ) } return fmt . Sprintf ( "%s/job/%s" , spec . Job , spec . Refs . BaseRef ) } return spec . Job }
1298	func getBuildPath ( spec * prowapi . ProwJobSpec ) string { jenkinsJobName := getJobName ( spec ) jenkinsPath := fmt . Sprintf ( "/job/%s/build" , jenkinsJobName ) return jenkinsPath }
1299	func ( c * Client ) GetJobInfo ( spec * prowapi . ProwJobSpec ) ( * JobInfo , error ) { path := getJobInfoPath ( spec ) c . logger . Debugf ( "getJobInfoPath: %s" , path ) data , err := c . Get ( path ) if err != nil { c . logger . Errorf ( "Failed to get job info: %v" , err ) return nil , err } var jobInfo JobInfo if err := json . Unmarshal ( data , & jobInfo ) ; err != nil { return nil , fmt . Errorf ( "Cannot unmarshal job info from API: %v" , err ) } c . logger . Tracef ( "JobInfo: %+v" , jobInfo ) return & jobInfo , nil }
1300	func ( c * Client ) JobParameterized ( jobInfo * JobInfo ) bool { for _ , prop := range jobInfo . Property { if prop . ParameterDefinitions != nil && len ( prop . ParameterDefinitions ) > 0 { return true } } return false }
1301	func ( c * Client ) EnsureBuildableJob ( spec * prowapi . ProwJobSpec ) error { var jobInfo * JobInfo getJobInfoBackoff := wait . Backoff { Duration : time . Duration ( 10 ) * time . Second , Factor : 1 , Jitter : 0 , Steps : 2 , } getJobErr := wait . ExponentialBackoff ( getJobInfoBackoff , func ( ) ( bool , error ) { var jobErr error jobInfo , jobErr = c . GetJobInfo ( spec ) if jobErr != nil && ! strings . Contains ( strings . ToLower ( jobErr . Error ( ) ) , "404 not found" ) { return false , jobErr } return jobInfo != nil , nil } ) if getJobErr != nil { return fmt . Errorf ( "Job %v does not exist" , spec . Job ) } isParameterized := c . JobParameterized ( jobInfo ) c . logger . Tracef ( "JobHasParameters: %v" , isParameterized ) if isParameterized || len ( jobInfo . Builds ) > 0 { return nil } buildErr := c . LaunchBuild ( spec , nil ) if buildErr != nil { return buildErr } backoff := wait . Backoff { Duration : time . Duration ( 5 ) * time . Second , Factor : 1 , Jitter : 1 , Steps : 10 , } return wait . ExponentialBackoff ( backoff , func ( ) ( bool , error ) { c . logger . Debugf ( "Waiting for job %v to become parameterized" , spec . Job ) jobInfo , _ := c . GetJobInfo ( spec ) isParameterized := false if jobInfo != nil { isParameterized = c . JobParameterized ( jobInfo ) if isParameterized && jobInfo . LastBuild != nil { c . logger . Debugf ( "Job %v is now parameterized, aborting the build" , spec . Job ) err := c . Abort ( getJobName ( spec ) , jobInfo . LastBuild ) if err != nil { c . logger . Infof ( "Couldn't abort build #%v for job %v: %v" , jobInfo . LastBuild . Number , spec . Job , err ) } } } return isParameterized , nil } ) }
1302	func ( c * Client ) LaunchBuild ( spec * prowapi . ProwJobSpec , params url . Values ) error { var path string if params != nil { path = getBuildWithParametersPath ( spec ) } else { path = getBuildPath ( spec ) } c . logger . Debugf ( "getBuildPath/getBuildWithParametersPath: %s" , path ) resp , err := c . request ( http . MethodPost , path , params , true ) if err != nil { return err } defer resp . Body . Close ( ) if resp . StatusCode != 201 { return fmt . Errorf ( "response not 201: %s" , resp . Status ) } return nil }
1303	func ( c * Client ) Build ( pj * prowapi . ProwJob , buildID string ) error { c . logger . WithFields ( pjutil . ProwJobFields ( pj ) ) . Info ( "Build" ) return c . BuildFromSpec ( & pj . Spec , buildID , pj . ObjectMeta . Name ) }
1304	func ( c * Client ) BuildFromSpec ( spec * prowapi . ProwJobSpec , buildID , prowJobID string ) error { if c . dryRun { return nil } env , err := downwardapi . EnvForSpec ( downwardapi . NewJobSpec ( * spec , buildID , prowJobID ) ) if err != nil { return err } params := url . Values { } for key , value := range env { params . Set ( key , value ) } if err := c . EnsureBuildableJob ( spec ) ; err != nil { return fmt . Errorf ( "Job %v cannot be build: %v" , spec . Job , err ) } return c . LaunchBuild ( spec , params ) }
1305	func ( c * Client ) GetEnqueuedBuilds ( jobs [ ] BuildQueryParams ) ( map [ string ] Build , error ) { c . logger . Debug ( "GetEnqueuedBuilds" ) data , err := c . Get ( "/queue/api/json?tree=items[task[name],actions[parameters[name,value]]]" ) if err != nil { return nil , fmt . Errorf ( "cannot list builds from the queue: %v" , err ) } page := struct { QueuedBuilds [ ] Build `json:"items"` } { } if err := json . Unmarshal ( data , & page ) ; err != nil { return nil , fmt . Errorf ( "cannot unmarshal builds from the queue: %v" , err ) } jenkinsBuilds := make ( map [ string ] Build ) for _ , jb := range page . QueuedBuilds { prowJobID := jb . ProwJobID ( ) if prowJobID == "" { continue } var exists bool for _ , job := range jobs { if prowJobID == job . ProwJobID { exists = true break } } if ! exists { continue } jb . enqueued = true jenkinsBuilds [ prowJobID ] = jb } return jenkinsBuilds , nil }
1306	func ( c * Client ) Abort ( job string , build * Build ) error { c . logger . Debugf ( "Abort(%v %v)" , job , build . Number ) if c . dryRun { return nil } resp , err := c . request ( http . MethodPost , fmt . Sprintf ( "/job/%s/%d/stop" , job , build . Number ) , nil , false ) if err != nil { return err } defer resp . Body . Close ( ) if resp . StatusCode < 200 || resp . StatusCode >= 300 { return fmt . Errorf ( "response not 2XX: %s" , resp . Status ) } return nil }
1307	func PresubmitToJobSpec ( pre config . Presubmit ) * downwardapi . JobSpec { return & downwardapi . JobSpec { Type : prowapi . PresubmitJob , Job : pre . Name , } }
1308	func PostsubmitToJobSpec ( post config . Postsubmit ) * downwardapi . JobSpec { return & downwardapi . JobSpec { Type : prowapi . PostsubmitJob , Job : post . Name , } }
1309	func PeriodicToJobSpec ( periodic config . Periodic ) * downwardapi . JobSpec { return & downwardapi . JobSpec { Type : prowapi . PeriodicJob , Job : periodic . Name , } }
1310	func GetBuildID ( name , totURL string ) ( string , error ) { if totURL == "" { return node . Generate ( ) . String ( ) , nil } var err error url , err := url . Parse ( totURL ) if err != nil { return "" , fmt . Errorf ( "invalid tot url: %v" , err ) } url . Path = path . Join ( url . Path , "vend" , name ) sleepDuration := 100 * time . Millisecond for retries := 0 ; retries < 10 ; retries ++ { if retries > 0 { sleep ( sleepDuration ) sleepDuration = sleepDuration * 2 } var resp * http . Response resp , err = http . Get ( url . String ( ) ) if err != nil { continue } defer resp . Body . Close ( ) if resp . StatusCode != 200 { err = fmt . Errorf ( "got unexpected response from tot: %v" , resp . Status ) continue } var buf [ ] byte buf , err = ioutil . ReadAll ( resp . Body ) if err == nil { return string ( buf ) , nil } return "" , err } return "" , err }
1311	func listGcsObjects ( ctx context . Context , client * storage . Client , bucketName , prefix , delim string ) ( [ ] string , error ) { var objects [ ] string it := client . Bucket ( bucketName ) . Objects ( ctx , & storage . Query { Prefix : prefix , Delimiter : delim , } ) for { attrs , err := it . Next ( ) if err == iterator . Done { break } if err != nil { return objects , fmt . Errorf ( "error iterating: %v" , err ) } if attrs . Prefix != "" { objects = append ( objects , path . Base ( attrs . Prefix ) ) } } logrus . Info ( "end of listGcsObjects(...)" ) return objects , nil }
1312	func FindBaseProfile ( ctx context . Context , client * storage . Client , bucket , prowJobName , artifactsDirName , covProfileName string ) ( [ ] byte , error ) { dirOfJob := path . Join ( "logs" , prowJobName ) strBuilds , err := listGcsObjects ( ctx , client , bucket , dirOfJob + "/" , "/" ) if err != nil { return nil , fmt . Errorf ( "error listing gcs objects: %v" , err ) } builds := sortBuilds ( strBuilds ) profilePath := "" for _ , build := range builds { buildDirPath := path . Join ( dirOfJob , strconv . Itoa ( build ) ) dirOfStatusJSON := path . Join ( buildDirPath , statusJSON ) statusText , err := readGcsObject ( ctx , client , bucket , dirOfStatusJSON ) if err != nil { logrus . Infof ( "Cannot read finished.json (%s) in bucket '%s'" , dirOfStatusJSON , bucket ) } else if isBuildSucceeded ( statusText ) { artifactsDirPath := path . Join ( buildDirPath , artifactsDirName ) profilePath = path . Join ( artifactsDirPath , covProfileName ) break } } if profilePath == "" { return nil , fmt . Errorf ( "no healthy build found for job '%s' in bucket '%s'; total # builds = %v" , dirOfJob , bucket , len ( builds ) ) } return readGcsObject ( ctx , client , bucket , profilePath ) }
1313	func sortBuilds ( strBuilds [ ] string ) [ ] int { var res [ ] int for _ , buildStr := range strBuilds { num , err := strconv . Atoi ( buildStr ) if err != nil { logrus . Infof ( "Non-int build number found: '%s'" , buildStr ) } else { res = append ( res , num ) } } sort . Sort ( sort . Reverse ( sort . IntSlice ( res ) ) ) return res }
1314	func GetAll ( sess * session . Session ) ( [ ] string , error ) { var regions [ ] string svc := ec2 . New ( sess , & aws . Config { Region : aws . String ( Default ) } ) resp , err := svc . DescribeRegions ( nil ) if err != nil { return nil , err } for _ , region := range resp . Regions { regions = append ( regions , * region . RegionName ) } return regions , nil }
1315	func NewEventClient ( ghc githubClient , log * logrus . Entry , org , repo string , number int ) * EventClient { return & EventClient { org : org , repo : repo , number : number , ghc : ghc , log : log , } }
1316	func ( c * EventClient ) PruneComments ( shouldPrune func ( github . IssueComment ) bool ) { c . once . Do ( func ( ) { botName , err := c . ghc . BotName ( ) if err != nil { c . log . WithError ( err ) . Error ( "failed to get the bot's name. Pruning will consider all comments." ) } comments , err := c . ghc . ListIssueComments ( c . org , c . repo , c . number ) if err != nil { c . log . WithError ( err ) . Errorf ( "failed to list comments for %s/%s#%d" , c . org , c . repo , c . number ) } if botName != "" { for _ , comment := range comments { if comment . User . Login == botName { c . comments = append ( c . comments , comment ) } } } } ) c . lock . Lock ( ) defer c . lock . Unlock ( ) var remaining [ ] github . IssueComment for _ , comment := range c . comments { removed := false if shouldPrune ( comment ) { if err := c . ghc . DeleteComment ( c . org , c . repo , comment . ID ) ; err != nil { c . log . WithError ( err ) . Errorf ( "failed to delete stale comment with ID '%d'" , comment . ID ) } else { removed = true } } if ! removed { remaining = append ( remaining , comment ) } } c . comments = remaining }
1317	func FormatResponse ( to , message , reason string ) string { format := `@%s: %s<details>%s%s</details>` return fmt . Sprintf ( format , to , message , reason , AboutThisBotWithoutCommands ) }
1318	func FormatSimpleResponse ( to , message string ) string { format := `@%s: %s<details>%s</details>` return fmt . Sprintf ( format , to , message , AboutThisBotWithoutCommands ) }
1319	func FormatICResponse ( ic github . IssueComment , s string ) string { return FormatResponseRaw ( ic . Body , ic . HTMLURL , ic . User . Login , s ) }
1320	func FormatResponseRaw ( body , bodyURL , login , reply string ) string { format := `In response to [this](%s):%s` var quoted [ ] string for _ , l := range strings . Split ( body , "\n" ) \n { quoted = append ( quoted , ">" + l ) } }
1321	func ( o * Options ) Validate ( ) error { if o . gcsPath . String ( ) != "" { o . Bucket = o . gcsPath . Bucket ( ) o . PathPrefix = o . gcsPath . Object ( ) } if ! o . DryRun { if o . Bucket == "" { return errors . New ( "GCS upload was requested no GCS bucket was provided" ) } if o . GcsCredentialsFile == "" { return errors . New ( "GCS upload was requested but no GCS credentials file was provided" ) } } return o . GCSConfiguration . Validate ( ) }
1322	func Encode ( options Options ) ( string , error ) { encoded , err := json . Marshal ( options ) return string ( encoded ) , err }
1323	func RegisterIssueHandler ( name string , fn IssueHandler , help HelpProvider ) { pluginHelp [ name ] = help issueHandlers [ name ] = fn }
1324	func RegisterIssueCommentHandler ( name string , fn IssueCommentHandler , help HelpProvider ) { pluginHelp [ name ] = help issueCommentHandlers [ name ] = fn }
1325	func RegisterPullRequestHandler ( name string , fn PullRequestHandler , help HelpProvider ) { pluginHelp [ name ] = help pullRequestHandlers [ name ] = fn }
1326	func RegisterStatusEventHandler ( name string , fn StatusEventHandler , help HelpProvider ) { pluginHelp [ name ] = help statusEventHandlers [ name ] = fn }
1327	func RegisterPushEventHandler ( name string , fn PushEventHandler , help HelpProvider ) { pluginHelp [ name ] = help pushEventHandlers [ name ] = fn }
1328	func RegisterReviewEventHandler ( name string , fn ReviewEventHandler , help HelpProvider ) { pluginHelp [ name ] = help reviewEventHandlers [ name ] = fn }
1329	func RegisterReviewCommentEventHandler ( name string , fn ReviewCommentEventHandler , help HelpProvider ) { pluginHelp [ name ] = help reviewCommentEventHandlers [ name ] = fn }
1330	func RegisterGenericCommentHandler ( name string , fn GenericCommentHandler , help HelpProvider ) { pluginHelp [ name ] = help genericCommentHandlers [ name ] = fn }
1331	func NewAgent ( configAgent * config . Agent , pluginConfigAgent * ConfigAgent , clientAgent * ClientAgent , logger * logrus . Entry ) Agent { prowConfig := configAgent . Config ( ) pluginConfig := pluginConfigAgent . Config ( ) return Agent { GitHubClient : clientAgent . GitHubClient , KubernetesClient : clientAgent . KubernetesClient , ProwJobClient : clientAgent . ProwJobClient , GitClient : clientAgent . GitClient , SlackClient : clientAgent . SlackClient , OwnersClient : clientAgent . OwnersClient , Config : prowConfig , PluginConfig : pluginConfig , Logger : logger , } }
1332	func ( a * Agent ) InitializeCommentPruner ( org , repo string , pr int ) { a . commentPruner = commentpruner . NewEventClient ( a . GitHubClient , a . Logger . WithField ( "client" , "commentpruner" ) , org , repo , pr , ) }
1333	func ( a * Agent ) CommentPruner ( ) ( * commentpruner . EventClient , error ) { if a . commentPruner == nil { return nil , errors . New ( "comment pruner client never initialized" ) } return a . commentPruner , nil }
1334	func ( pa * ConfigAgent ) Load ( path string ) error { b , err := ioutil . ReadFile ( path ) if err != nil { return err } np := & Configuration { } if err := yaml . Unmarshal ( b , np ) ; err != nil { return err } if err := np . Validate ( ) ; err != nil { return err } pa . Set ( np ) return nil }
1335	func ( pa * ConfigAgent ) Config ( ) * Configuration { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) return pa . configuration }
1336	func ( pa * ConfigAgent ) Set ( pc * Configuration ) { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) pa . configuration = pc }
1337	func ( pa * ConfigAgent ) Start ( path string ) error { if err := pa . Load ( path ) ; err != nil { return err } ticker := time . Tick ( 1 * time . Minute ) go func ( ) { for range ticker { if err := pa . Load ( path ) ; err != nil { logrus . WithField ( "path" , path ) . WithError ( err ) . Error ( "Error loading plugin config." ) } } } ( ) return nil }
1338	func ( pa * ConfigAgent ) GenericCommentHandlers ( owner , repo string ) map [ string ] GenericCommentHandler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs := map [ string ] GenericCommentHandler { } for _ , p := range pa . getPlugins ( owner , repo ) { if h , ok := genericCommentHandlers [ p ] ; ok { hs [ p ] = h } } return hs }
1339	func ( pa * ConfigAgent ) IssueHandlers ( owner , repo string ) map [ string ] IssueHandler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs := map [ string ] IssueHandler { } for _ , p := range pa . getPlugins ( owner , repo ) { if h , ok := issueHandlers [ p ] ; ok { hs [ p ] = h } } return hs }
1340	func ( pa * ConfigAgent ) IssueCommentHandlers ( owner , repo string ) map [ string ] IssueCommentHandler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs := map [ string ] IssueCommentHandler { } for _ , p := range pa . getPlugins ( owner , repo ) { if h , ok := issueCommentHandlers [ p ] ; ok { hs [ p ] = h } } return hs }
1341	func ( pa * ConfigAgent ) PullRequestHandlers ( owner , repo string ) map [ string ] PullRequestHandler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs := map [ string ] PullRequestHandler { } for _ , p := range pa . getPlugins ( owner , repo ) { if h , ok := pullRequestHandlers [ p ] ; ok { hs [ p ] = h } } return hs }
1342	func ( pa * ConfigAgent ) ReviewEventHandlers ( owner , repo string ) map [ string ] ReviewEventHandler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs := map [ string ] ReviewEventHandler { } for _ , p := range pa . getPlugins ( owner , repo ) { if h , ok := reviewEventHandlers [ p ] ; ok { hs [ p ] = h } } return hs }
1343	func ( pa * ConfigAgent ) ReviewCommentEventHandlers ( owner , repo string ) map [ string ] ReviewCommentEventHandler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs := map [ string ] ReviewCommentEventHandler { } for _ , p := range pa . getPlugins ( owner , repo ) { if h , ok := reviewCommentEventHandlers [ p ] ; ok { hs [ p ] = h } } return hs }
1344	func ( pa * ConfigAgent ) StatusEventHandlers ( owner , repo string ) map [ string ] StatusEventHandler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs := map [ string ] StatusEventHandler { } for _ , p := range pa . getPlugins ( owner , repo ) { if h , ok := statusEventHandlers [ p ] ; ok { hs [ p ] = h } } return hs }
1345	func ( pa * ConfigAgent ) PushEventHandlers ( owner , repo string ) map [ string ] PushEventHandler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs := map [ string ] PushEventHandler { } for _ , p := range pa . getPlugins ( owner , repo ) { if h , ok := pushEventHandlers [ p ] ; ok { hs [ p ] = h } } return hs }
1346	func EventsForPlugin ( name string ) [ ] string { var events [ ] string if _ , ok := issueHandlers [ name ] ; ok { events = append ( events , "issue" ) } if _ , ok := issueCommentHandlers [ name ] ; ok { events = append ( events , "issue_comment" ) } if _ , ok := pullRequestHandlers [ name ] ; ok { events = append ( events , "pull_request" ) } if _ , ok := pushEventHandlers [ name ] ; ok { events = append ( events , "push" ) } if _ , ok := reviewEventHandlers [ name ] ; ok { events = append ( events , "pull_request_review" ) } if _ , ok := reviewCommentEventHandlers [ name ] ; ok { events = append ( events , "pull_request_review_comment" ) } if _ , ok := statusEventHandlers [ name ] ; ok { events = append ( events , "status" ) } if _ , ok := genericCommentHandlers [ name ] ; ok { events = append ( events , "GenericCommentEvent (any event for user text)" ) } return events }
1347	func insertLink ( started * gcs . Started , viewURL string ) ( bool , error ) { if started . Metadata == nil { started . Metadata = metadata . Metadata { } } meta := started . Metadata var changed bool top , present := meta . String ( resultstoreKey ) if ! present || top == nil || * top != viewURL { changed = true meta [ resultstoreKey ] = viewURL } links , present := meta . Meta ( linksKey ) if present && links == nil { return false , fmt . Errorf ( "metadata.links is not a Metadata value: %v" , meta [ linksKey ] ) } if links == nil { links = & metadata . Metadata { } changed = true } resultstoreMeta , present := links . Meta ( resultstoreKey ) if present && resultstoreMeta == nil { return false , fmt . Errorf ( "metadata.links.resultstore is not a Metadata value: %v" , ( * links ) [ resultstoreKey ] ) } if resultstoreMeta == nil { resultstoreMeta = & metadata . Metadata { } changed = true } val , present := resultstoreMeta . String ( urlKey ) if present && val == nil { return false , fmt . Errorf ( "metadata.links.resultstore.url is not a string value: %v" , ( * resultstoreMeta ) [ urlKey ] ) } if ! changed && val != nil && * val == viewURL { return false , nil } ( * resultstoreMeta ) [ urlKey ] = viewURL ( * links ) [ resultstoreKey ] = * resultstoreMeta meta [ linksKey ] = * links return true , nil }
1348	func HelpProvider ( enabledRepos [ ] string ) ( * pluginhelp . PluginHelp , error ) { pluginHelp := & pluginhelp . PluginHelp { Description : `The cherrypick plugin is used for cherrypicking PRs across branches. For every successful cherrypick invocation a new PR is opened against the target branch and assigned to the requester. If the parent PR contains a release note, it is copied to the cherrypick PR.` , } pluginHelp . AddCommand ( pluginhelp . Command { Usage : "/cherrypick [branch]" , Description : "Cherrypick a PR to a different branch. This command works both in merged PRs (the cherrypick PR is opened immediately) and open PRs (the cherrypick PR opens as soon as the original PR merges)." , Featured : true , WhoCanUse : "Members of the trusted organization for the repo." , Examples : [ ] string { "/cherrypick release-3.9" } , } ) return pluginHelp , nil }
1349	func ( s * Server ) getPatch ( org , repo , targetBranch string , num int ) ( string , error ) { patch , err := s . ghc . GetPullRequestPatch ( org , repo , num ) if err != nil { return "" , err } localPath := fmt . Sprintf ( "/tmp/%s_%s_%d_%s.patch" , org , repo , num , normalize ( targetBranch ) ) out , err := os . Create ( localPath ) if err != nil { return "" , err } defer out . Close ( ) if _ , err := io . Copy ( out , bytes . NewBuffer ( patch ) ) ; err != nil { return "" , err } return localPath , nil }
1350	func releaseNoteFromParentPR ( body string ) string { potentialMatch := releaseNoteRe . FindStringSubmatch ( body ) if potentialMatch == nil { return "" } return fmt . Sprintf ( "```release-note\n%s\n```" , \n ) }
1351	func ValidatePayload ( payload [ ] byte , sig string , key [ ] byte ) bool { if ! strings . HasPrefix ( sig , "sha1=" ) { return false } sig = sig [ 5 : ] sb , err := hex . DecodeString ( sig ) if err != nil { return false } mac := hmac . New ( sha1 . New , key ) mac . Write ( payload ) expected := mac . Sum ( nil ) return hmac . Equal ( sb , expected ) }
1352	func PayloadSignature ( payload [ ] byte , key [ ] byte ) string { mac := hmac . New ( sha1 . New , key ) mac . Write ( payload ) sum := mac . Sum ( nil ) return "sha1=" + hex . EncodeToString ( sum ) }
1353	func updateString ( have , want * string ) bool { switch { case have == nil : panic ( "have must be non-nil" ) case want == nil : return false case * have == * want : return false } * have = * want return true }
1354	func updateBool ( have , want * bool ) bool { switch { case have == nil : panic ( "have must not be nil" ) case want == nil : return false case * have == * want : return false } * have = * want return true }
1355	func configureOrgMeta ( client orgMetadataClient , orgName string , want org . Metadata ) error { cur , err := client . GetOrg ( orgName ) if err != nil { return fmt . Errorf ( "failed to get %s metadata: %v" , orgName , err ) } change := false change = updateString ( & cur . BillingEmail , want . BillingEmail ) || change change = updateString ( & cur . Company , want . Company ) || change change = updateString ( & cur . Email , want . Email ) || change change = updateString ( & cur . Name , want . Name ) || change change = updateString ( & cur . Description , want . Description ) || change change = updateString ( & cur . Location , want . Location ) || change if want . DefaultRepositoryPermission != nil { w := string ( * want . DefaultRepositoryPermission ) change = updateString ( & cur . DefaultRepositoryPermission , & w ) } change = updateBool ( & cur . HasOrganizationProjects , want . HasOrganizationProjects ) || change change = updateBool ( & cur . HasRepositoryProjects , want . HasRepositoryProjects ) || change change = updateBool ( & cur . MembersCanCreateRepositories , want . MembersCanCreateRepositories ) || change if change { if _ , err := client . EditOrg ( orgName , * cur ) ; err != nil { return fmt . Errorf ( "failed to edit %s metadata: %v" , orgName , err ) } } return nil }
1356	func configureTeamRepos ( client teamRepoClient , githubTeams map [ string ] github . Team , name , orgName string , team org . Team ) error { gt , ok := githubTeams [ name ] if ! ok { return fmt . Errorf ( "%s not found in id list" , name ) } want := team . Repos have := map [ string ] github . RepoPermissionLevel { } repos , err := client . ListTeamRepos ( gt . ID ) if err != nil { return fmt . Errorf ( "failed to list team %d(%s) repos: %v" , gt . ID , name , err ) } for _ , repo := range repos { have [ repo . Name ] = github . LevelFromPermissions ( repo . Permissions ) } actions := map [ string ] github . RepoPermissionLevel { } for wantRepo , wantPermission := range want { if havePermission , haveRepo := have [ wantRepo ] ; haveRepo && havePermission == wantPermission { continue } actions [ wantRepo ] = wantPermission } for haveRepo := range have { if _ , wantRepo := want [ haveRepo ] ; ! wantRepo { actions [ haveRepo ] = github . None } } var updateErrors [ ] error for repo , permission := range actions { var err error if permission == github . None { err = client . RemoveTeamRepo ( gt . ID , orgName , repo ) } else { err = client . UpdateTeamRepo ( gt . ID , orgName , repo , permission ) } if err != nil { updateErrors = append ( updateErrors , fmt . Errorf ( "failed to update team %d(%s) permissions on repo %s to %s: %v" , gt . ID , name , repo , permission , err ) ) } } return errorutil . NewAggregate ( updateErrors ... ) }
1357	func ( c * Client ) ShouldReport ( pj * prowapi . ProwJob ) bool { pubSubMap := findLabels ( pj , PubSubProjectLabel , PubSubTopicLabel ) return pubSubMap [ PubSubProjectLabel ] != "" && pubSubMap [ PubSubTopicLabel ] != "" }
1358	func ( o Options ) Run ( spec * downwardapi . JobSpec , extra map [ string ] gcs . UploadFunc ) error { uploadTargets := o . assembleTargets ( spec , extra ) if ! o . DryRun { ctx := context . Background ( ) gcsClient , err := storage . NewClient ( ctx , option . WithCredentialsFile ( o . GcsCredentialsFile ) ) if err != nil { return fmt . Errorf ( "could not connect to GCS: %v" , err ) } if err := gcs . Upload ( gcsClient . Bucket ( o . Bucket ) , uploadTargets ) ; err != nil { return fmt . Errorf ( "failed to upload to GCS: %v" , err ) } } else { for destination := range uploadTargets { logrus . WithField ( "dest" , destination ) . Info ( "Would upload" ) } } logrus . Info ( "Finished upload to GCS" ) return nil }
1359	func ( d * DefaultFieldsFormatter ) Format ( entry * logrus . Entry ) ( [ ] byte , error ) { data := make ( logrus . Fields , len ( entry . Data ) + len ( d . DefaultFields ) ) for k , v := range d . DefaultFields { data [ k ] = v } for k , v := range entry . Data { data [ k ] = v } return d . WrappedFormatter . Format ( & logrus . Entry { Logger : entry . Logger , Data : data , Time : entry . Time , Level : entry . Level , Message : entry . Message , } ) }
1360	func ( issue * Issue ) FindLabels ( regex * regexp . Regexp ) [ ] Label { labels := [ ] Label { } for _ , label := range issue . Labels { if regex . MatchString ( label . Name ) { labels = append ( labels , label ) } } return labels }
1361	func ( o * Options ) AddFlags ( flags * flag . FlagSet ) { flags . StringVar ( & o . Log , "clone-log" , "" , "Path to the clone records log" ) o . Options . AddFlags ( flags ) }
1362	func NewAgent ( config * config . GitHubOAuthConfig , logger * logrus . Entry ) * Agent { return & Agent { gc : config , logger : logger , } }
1363	func ( ga * Agent ) HandleLogin ( client OAuthClient ) http . HandlerFunc { return func ( w http . ResponseWriter , r * http . Request ) { stateToken := xsrftoken . Generate ( ga . gc . ClientSecret , "" , "" ) state := hex . EncodeToString ( [ ] byte ( stateToken ) ) oauthSession , err := ga . gc . CookieStore . New ( r , oauthSessionCookie ) oauthSession . Options . Secure = true oauthSession . Options . HttpOnly = true if err != nil { ga . serverError ( w , "Creating new OAuth session" , err ) return } oauthSession . Options . MaxAge = 10 * 60 oauthSession . Values [ stateKey ] = state if err := oauthSession . Save ( r , w ) ; err != nil { ga . serverError ( w , "Save oauth session" , err ) return } redirectURL := client . AuthCodeURL ( state , oauth2 . ApprovalForce , oauth2 . AccessTypeOnline ) http . Redirect ( w , r , redirectURL , http . StatusFound ) } }
1364	func ( ga * Agent ) HandleLogout ( client OAuthClient ) http . HandlerFunc { return func ( w http . ResponseWriter , r * http . Request ) { accessTokenSession , err := ga . gc . CookieStore . Get ( r , tokenSession ) if err != nil { ga . serverError ( w , "get cookie" , err ) return } accessTokenSession . Options . MaxAge = - 1 if err := accessTokenSession . Save ( r , w ) ; err != nil { ga . serverError ( w , "Save invalidated session on log out" , err ) return } loginCookie , err := r . Cookie ( loginSession ) if err == nil { loginCookie . MaxAge = - 1 loginCookie . Expires = time . Now ( ) . Add ( - time . Hour * 24 ) http . SetCookie ( w , loginCookie ) } http . Redirect ( w , r , ga . gc . FinalRedirectURL , http . StatusFound ) } }
1365	func ( ga * Agent ) serverError ( w http . ResponseWriter , action string , err error ) { ga . logger . WithError ( err ) . Errorf ( "Error %s." , action ) msg := fmt . Sprintf ( "500 Internal server error %s: %v" , action , err ) http . Error ( w , msg , http . StatusInternalServerError ) }
1366	func ( in * ResourcesConfigObject ) FromItem ( i common . Item ) { c , err := common . ItemToResourcesConfig ( i ) if err == nil { in . fromConfig ( c ) } }
1367	func ( in * ResourcesConfigCollection ) GetItems ( ) [ ] Object { var items [ ] Object for _ , i := range in . Items { items = append ( items , i ) } return items }
1368	func ( in * ResourcesConfigCollection ) SetItems ( objects [ ] Object ) { var items [ ] * ResourcesConfigObject for _ , b := range objects { items = append ( items , b . ( * ResourcesConfigObject ) ) } in . Items = items }
1369	func ( l * RepoPermissionLevel ) UnmarshalText ( text [ ] byte ) error { v := RepoPermissionLevel ( text ) if _ , ok := repoPermissionLevels [ v ] ; ! ok { return fmt . Errorf ( "bad repo permission: %s not in %v" , v , repoPermissionLevels ) } * l = v return nil }
1370	func ( i Issue ) IsAssignee ( login string ) bool { for _ , assignee := range i . Assignees { if NormLogin ( login ) == NormLogin ( assignee . Login ) { return true } } return false }
1371	func ( i Issue ) IsAuthor ( login string ) bool { return NormLogin ( i . User . Login ) == NormLogin ( login ) }
1372	func ( i Issue ) HasLabel ( labelToFind string ) bool { for _ , label := range i . Labels { if strings . ToLower ( label . Name ) == strings . ToLower ( labelToFind ) { return true } } return false }
1373	func ( pe PushEvent ) Branch ( ) string { ref := strings . TrimPrefix ( pe . Ref , "refs/heads/" ) ref = strings . TrimPrefix ( ref , "refs/tags/" ) return ref }
1374	func truncate ( in string ) string { const ( half = ( maxLen - len ( elide ) ) / 2 ) if len ( in ) <= maxLen { return in } return in [ : half ] + elide + in [ len ( in ) - half : ] }
1375	func reportStatus ( ghc GitHubClient , pj prowapi . ProwJob ) error { refs := pj . Spec . Refs if pj . Spec . Report { contextState , err := prowjobStateToGitHubStatus ( pj . Status . State ) if err != nil { return err } sha := refs . BaseSHA if len ( refs . Pulls ) > 0 { sha = refs . Pulls [ 0 ] . SHA } if err := ghc . CreateStatus ( refs . Org , refs . Repo , sha , github . Status { State : contextState , Description : truncate ( pj . Status . Description ) , Context : pj . Spec . Context , TargetURL : pj . Status . URL , } ) ; err != nil { return err } } return nil }
1376	func parseIssueComments ( pj prowapi . ProwJob , botName string , ics [ ] github . IssueComment ) ( [ ] int , [ ] string , int ) { var delete [ ] int var previousComments [ ] int var latestComment int var entries [ ] string for _ , ic := range ics { if ic . User . Login != botName { continue } if strings . HasPrefix ( ic . Body , pj . Spec . Context ) { delete = append ( delete , ic . ID ) } if ! strings . Contains ( ic . Body , commentTag ) { continue } if latestComment != 0 { previousComments = append ( previousComments , latestComment ) } latestComment = ic . ID var tracking bool for _ , line := range strings . Split ( ic . Body , "\n" ) \n } { line = strings . TrimSpace ( line ) if strings . HasPrefix ( line , "---" ) { tracking = true } else if len ( line ) == 0 { tracking = false } else if tracking { entries = append ( entries , line ) } } var newEntries [ ] string for i := range entries { keep := true f1 := strings . Split ( entries [ i ] , " | " ) for j := range entries { if i == j { continue } f2 := strings . Split ( entries [ j ] , " | " ) if j > i && f2 [ 0 ] == f1 [ 0 ] { keep = false } } if pj . Spec . Context == f1 [ 0 ] { keep = false } if keep { newEntries = append ( newEntries , entries [ i ] ) } } var createNewComment bool if string ( pj . Status . State ) == github . StatusFailure { newEntries = append ( newEntries , createEntry ( pj ) ) createNewComment = true } delete = append ( delete , previousComments ... ) if ( createNewComment || len ( newEntries ) == 0 ) && latestComment != 0 { delete = append ( delete , latestComment ) latestComment = 0 } }
1377	func createComment ( reportTemplate * template . Template , pj prowapi . ProwJob , entries [ ] string ) ( string , error ) { plural := "" if len ( entries ) > 1 { plural = "s" } var b bytes . Buffer if reportTemplate != nil { if err := reportTemplate . Execute ( & b , & pj ) ; err != nil { return "" , err } } lines := [ ] string { fmt . Sprintf ( "@%s: The following test%s **failed**, say `/retest` to rerun them all:" , pj . Spec . Refs . Pulls [ 0 ] . Author , plural ) , "" , "Test name | Commit | Details | Rerun command" , "--- | --- | --- | ---" , } lines = append ( lines , entries ... ) if reportTemplate != nil { lines = append ( lines , "" , b . String ( ) ) } lines = append ( lines , [ ] string { "" , "<details>" , "" , plugins . AboutThisBot , "</details>" , commentTag , } ... ) return strings . Join ( lines , "\n" ) , nil }
1378	func ( lens Lens ) Config ( ) lenses . LensConfig { return lenses . LensConfig { Name : name , Title : title , Priority : priority , } }
1379	func ( lens Lens ) Callback ( artifacts [ ] lenses . Artifact , resourceDir string , data string ) string { return "" }
1380	func FormatRecord ( record Record ) string { output := bytes . Buffer { } if record . Failed { fmt . Fprintln ( & output , "# FAILED!" ) } fmt . Fprintf ( & output , "# Cloning %s/%s at %s" , record . Refs . Org , record . Refs . Repo , record . Refs . BaseRef ) if record . Refs . BaseSHA != "" { fmt . Fprintf ( & output , "(%s)" , record . Refs . BaseSHA ) } output . WriteString ( "\n" ) \n if len ( record . Refs . Pulls ) > 0 { output . WriteString ( "# Checking out pulls:\n" ) \n } for _ , pull := range record . Refs . Pulls { fmt . Fprintf ( & output , "#\t%d" , \t ) pull . Number if pull . SHA != "" { fmt . Fprintf ( & output , "(%s)" , pull . SHA ) } } }
1381	func ( c * Client ) Namespace ( ns string ) * Client { nc := * c nc . namespace = ns return & nc }
1382	func NewFakeClient ( deckURL string ) * Client { return & Client { namespace : "default" , deckURL : deckURL , client : & http . Client { } , fake : true , } }
1383	func NewClientInCluster ( namespace string ) ( * Client , error ) { tokenFile := "/var/run/secrets/kubernetes.io/serviceaccount/token" token , err := ioutil . ReadFile ( tokenFile ) if err != nil { return nil , err } rootCAFile := "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt" certData , err := ioutil . ReadFile ( rootCAFile ) if err != nil { return nil , err } cp := x509 . NewCertPool ( ) cp . AppendCertsFromPEM ( certData ) tr := & http . Transport { TLSClientConfig : & tls . Config { MinVersion : tls . VersionTLS12 , RootCAs : cp , } , } return & Client { logger : logrus . WithField ( "client" , "kube" ) , baseURL : inClusterBaseURL , client : & http . Client { Transport : tr , Timeout : requestTimeout } , token : string ( token ) , namespace : namespace , } , nil }
1384	func NewClientFromFile ( clusterPath , namespace string ) ( * Client , error ) { data , err := ioutil . ReadFile ( clusterPath ) if err != nil { return nil , err } var c Cluster if err := yaml . Unmarshal ( data , & c ) ; err != nil { return nil , err } return NewClient ( & c , namespace ) }
1385	func NewClient ( c * Cluster , namespace string ) ( * Client , error ) { cc := c . ClientCertificate ck := c . ClientKey ca := c . ClusterCACertificate cert , err := tls . X509KeyPair ( cc , ck ) if err != nil { return nil , err } cp := x509 . NewCertPool ( ) cp . AppendCertsFromPEM ( ca ) tr := & http . Transport { TLSClientConfig : & tls . Config { MinVersion : tls . VersionTLS12 , Certificates : [ ] tls . Certificate { cert } , RootCAs : cp , } , } return & Client { logger : logrus . WithField ( "client" , "kube" ) , baseURL : c . Endpoint , client : & http . Client { Transport : tr , Timeout : requestTimeout } , namespace : namespace , } , nil }
1386	func ( c * Client ) ReplaceConfigMap ( name string , config ConfigMap ) ( ConfigMap , error ) { c . log ( "ReplaceConfigMap" , name ) namespace := c . namespace if config . Namespace != "" { namespace = config . Namespace } var retConfigMap ConfigMap err := c . request ( & request { method : http . MethodPut , path : fmt . Sprintf ( "/api/v1/namespaces/%s/configmaps/%s" , namespace , name ) , requestBody : & config , } , & retConfigMap ) return retConfigMap , err }
1387	func GetDiskUsage ( path string ) ( percentBlocksFree float64 , bytesFree , bytesUsed uint64 , err error ) { var stat syscall . Statfs_t err = syscall . Statfs ( path , & stat ) if err != nil { return 0 , 0 , 0 , err } percentBlocksFree = float64 ( stat . Bfree ) / float64 ( stat . Blocks ) * 100 bytesFree = stat . Bfree * uint64 ( stat . Bsize ) bytesUsed = ( stat . Blocks - stat . Bfree ) * uint64 ( stat . Bsize ) return percentBlocksFree , bytesFree , bytesUsed , nil }
1388	func GetATime ( path string , defaultTime time . Time ) time . Time { at , err := atime . Stat ( path ) if err != nil { log . WithError ( err ) . Errorf ( "Could not get atime for %s" , path ) return defaultTime } return at }
1389	func RegisterLens ( lens Lens ) error { config := lens . Config ( ) _ , ok := lensReg [ config . Name ] if ok { return fmt . Errorf ( "viewer already registered with name %s" , config . Name ) } if config . Title == "" { return errors . New ( "empty title field in view metadata" ) } if config . Priority < 0 { return errors . New ( "priority must be >=0" ) } lensReg [ config . Name ] = lens logrus . Infof ( "Spyglass registered viewer %s with title %s." , config . Name , config . Title ) return nil }
1390	func GetLens ( name string ) ( Lens , error ) { lens , ok := lensReg [ name ] if ! ok { return nil , ErrInvalidLensName } return lens , nil }
1391	func LastNLines ( a Artifact , n int64 ) ( [ ] string , error ) { return LastNLinesChunked ( a , n , 300 * n + 1 ) }
1392	func NewClient ( tokenGenerator func ( ) [ ] byte ) * Client { return & Client { logger : logrus . WithField ( "client" , "slack" ) , tokenGenerator : tokenGenerator , } }
1393	func ( sl * Client ) WriteMessage ( text , channel string ) error { sl . log ( "WriteMessage" , text , channel ) if sl . fake { return nil } var uv = sl . urlValues ( ) uv . Add ( "channel" , channel ) uv . Add ( "text" , text ) _ , err := sl . postMessage ( chatPostMessage , uv ) return err }
1394	func ( NATGateway ) MarkAndSweep ( sess * session . Session , acct string , region string , set * Set ) error { svc := ec2 . New ( sess , & aws . Config { Region : aws . String ( region ) } ) inp := & ec2 . DescribeNatGatewaysInput { } if err := svc . DescribeNatGatewaysPages ( inp , func ( page * ec2 . DescribeNatGatewaysOutput , _ bool ) bool { for _ , gw := range page . NatGateways { g := & natGateway { Account : acct , Region : region , ID : * gw . NatGatewayId , } if set . Mark ( g ) { inp := & ec2 . DeleteNatGatewayInput { NatGatewayId : gw . NatGatewayId } if _ , err := svc . DeleteNatGateway ( inp ) ; err != nil { klog . Warningf ( "%v: delete failed: %v" , g . ARN ( ) , err ) } } } return true } ) ; err != nil { return err } return nil }
1395	func ( NATGateway ) ListAll ( sess * session . Session , acct , region string ) ( * Set , error ) { svc := ec2 . New ( sess , & aws . Config { Region : aws . String ( region ) } ) set := NewSet ( 0 ) inp := & ec2 . DescribeNatGatewaysInput { } err := svc . DescribeNatGatewaysPages ( inp , func ( page * ec2 . DescribeNatGatewaysOutput , _ bool ) bool { for _ , gw := range page . NatGateways { now := time . Now ( ) arn := natGateway { Account : acct , Region : region , ID : * gw . NatGatewayId , } . ARN ( ) set . firstSeen [ arn ] = now } return true } ) return set , errors . Wrapf ( err , "couldn't describe nat gateways for %q in %q" , acct , region ) }
1396	func NewClient ( owner string , url string ) * Client { client := & Client { url : url , owner : owner , storage : storage . NewMemoryStorage ( ) , } client . Dialer . RetryCount = 3 client . Dialer . RetrySleep = time . Second * 10 client . Dialer . Timeout = 30 * time . Second client . Dialer . KeepAlive = 30 * time . Second client . Dialer . DualStack = true client . http . Transport = & http . Transport { Proxy : http . ProxyFromEnvironment , Dial : client . Dialer . Dial , DialContext : client . Dialer . DialContext , MaxIdleConns : 100 , IdleConnTimeout : 90 * time . Second , TLSHandshakeTimeout : 10 * time . Second , ExpectContinueTimeout : 1 * time . Second , } return client }
1397	func ( c * Client ) Acquire ( rtype , state , dest string ) ( * common . Resource , error ) { r , err := c . acquire ( rtype , state , dest ) if err != nil { return nil , err } c . lock . Lock ( ) defer c . lock . Unlock ( ) if r != nil { c . storage . Add ( * r ) } return r , nil }
1398	func ( c * Client ) AcquireWait ( ctx context . Context , rtype , state , dest string ) ( * common . Resource , error ) { if ctx == nil { return nil , ErrContextRequired } for { r , err := c . Acquire ( rtype , state , dest ) if err != nil { if err == ErrAlreadyInUse || err == ErrNotFound { select { case <- ctx . Done ( ) : return nil , err case <- time . After ( 3 * time . Second ) : continue } } return nil , err } return r , nil } }
1399	func ( c * Client ) AcquireByState ( state , dest string , names [ ] string ) ( [ ] common . Resource , error ) { resources , err := c . acquireByState ( state , dest , names ) if err != nil { return nil , err } c . lock . Lock ( ) defer c . lock . Unlock ( ) for _ , r := range resources { c . storage . Add ( r ) } return resources , nil }
1400	func ( c * Client ) ReleaseAll ( dest string ) error { c . lock . Lock ( ) defer c . lock . Unlock ( ) resources , err := c . storage . List ( ) if err != nil { return err } if len ( resources ) == 0 { return fmt . Errorf ( "no holding resource" ) } var allErrors error for _ , r := range resources { c . storage . Delete ( r . GetName ( ) ) err := c . release ( r . GetName ( ) , dest ) if err != nil { allErrors = multierror . Append ( allErrors , err ) } } return allErrors }
1401	func ( c * Client ) ReleaseOne ( name , dest string ) error { c . lock . Lock ( ) defer c . lock . Unlock ( ) if _ , err := c . storage . Get ( name ) ; err != nil { return fmt . Errorf ( "no resource name %v" , name ) } c . storage . Delete ( name ) if err := c . release ( name , dest ) ; err != nil { return err } return nil }
1402	func ( c * Client ) UpdateAll ( state string ) error { c . lock . Lock ( ) defer c . lock . Unlock ( ) resources , err := c . storage . List ( ) if err != nil { return err } if len ( resources ) == 0 { return fmt . Errorf ( "no holding resource" ) } var allErrors error for _ , r := range resources { if err := c . update ( r . GetName ( ) , state , nil ) ; err != nil { allErrors = multierror . Append ( allErrors , err ) continue } if err := c . updateLocalResource ( r , state , nil ) ; err != nil { allErrors = multierror . Append ( allErrors , err ) } } return allErrors }
1403	func ( c * Client ) SyncAll ( ) error { c . lock . Lock ( ) defer c . lock . Unlock ( ) resources , err := c . storage . List ( ) if err != nil { return err } if len ( resources ) == 0 { logrus . Info ( "no resource to sync" ) return nil } var allErrors error for _ , i := range resources { r , err := common . ItemToResource ( i ) if err != nil { allErrors = multierror . Append ( allErrors , err ) continue } if err := c . update ( r . Name , r . State , nil ) ; err != nil { allErrors = multierror . Append ( allErrors , err ) continue } if err := c . storage . Update ( r ) ; err != nil { allErrors = multierror . Append ( allErrors , err ) } } return allErrors }
1404	func ( c * Client ) UpdateOne ( name , state string , userData * common . UserData ) error { c . lock . Lock ( ) defer c . lock . Unlock ( ) r , err := c . storage . Get ( name ) if err != nil { return fmt . Errorf ( "no resource name %v" , name ) } if err := c . update ( r . GetName ( ) , state , userData ) ; err != nil { return err } return c . updateLocalResource ( r , state , userData ) }
1405	func ( c * Client ) Metric ( rtype string ) ( common . Metric , error ) { return c . metric ( rtype ) }
1406	func ( c * Client ) HasResource ( ) bool { resources , _ := c . storage . List ( ) return len ( resources ) > 0 }
1407	func ( d * DialerWithRetry ) DialContext ( ctx context . Context , network , address string ) ( net . Conn , error ) { count := d . RetryCount + 1 sleep := d . RetrySleep i := uint ( 0 ) for { conn , err := d . Dialer . DialContext ( ctx , network , address ) if err != nil { if isDialErrorRetriable ( err ) { if i < count - 1 { select { case <- time . After ( sleep ) : i ++ continue case <- ctx . Done ( ) : return nil , err } } } return nil , err } return conn , nil } }
1408	func NewDashboardAgent ( repos [ ] string , config * config . GitHubOAuthConfig , log * logrus . Entry ) * DashboardAgent { return & DashboardAgent { repos : repos , goac : config , log : log , } }
1409	func ( da * DashboardAgent ) QueryPullRequests ( ctx context . Context , ghc githubClient , query string ) ( [ ] PullRequest , error ) { var prs [ ] PullRequest vars := map [ string ] interface { } { "query" : ( githubql . String ) ( query ) , "searchCursor" : ( * githubql . String ) ( nil ) , } var totalCost int var remaining int for { sq := searchQuery { } if err := ghc . Query ( ctx , & sq , vars ) ; err != nil { return nil , err } totalCost += int ( sq . RateLimit . Cost ) remaining = int ( sq . RateLimit . Remaining ) for _ , n := range sq . Search . Nodes { prs = append ( prs , n . PullRequest ) } if ! sq . Search . PageInfo . HasNextPage { break } vars [ "searchCursor" ] = githubql . NewString ( sq . Search . PageInfo . EndCursor ) } da . log . Infof ( "Search for query \"%s\" cost %d point(s). %d remaining." , \" , \" , query ) totalCost }
1410	func ( da * DashboardAgent ) GetHeadContexts ( ghc githubClient , pr PullRequest ) ( [ ] Context , error ) { org := string ( pr . Repository . Owner . Login ) repo := string ( pr . Repository . Name ) combined , err := ghc . GetCombinedStatus ( org , repo , string ( pr . HeadRefOID ) ) if err != nil { return nil , fmt . Errorf ( "failed to get the combined status: %v" , err ) } contexts := make ( [ ] Context , 0 , len ( combined . Statuses ) ) for _ , status := range combined . Statuses { contexts = append ( contexts , Context { Context : status . Context , Description : status . Description , State : strings . ToUpper ( status . State ) , } , ) } return contexts , nil }
1411	func ( da * DashboardAgent ) ConstructSearchQuery ( login string ) string { tokens := [ ] string { "is:pr" , "state:open" , "author:" + login } for i := range da . repos { tokens = append ( tokens , fmt . Sprintf ( "repo:\"%s\"" , \" ) ) } \" }
1412	func NewBundledStates ( description string ) BundledStates { return BundledStates { description : description , states : map [ string ] State { } , } }
1413	func ( b BundledStates ) ReceiveEvent ( ID string , eventName , label string , t time . Time ) bool { state , ok := b . states [ ID ] if ! ok { state = NewState ( b . description ) } state , changed := state . ReceiveEvent ( eventName , label , t ) b . states [ ID ] = state return changed }
1414	func ( b BundledStates ) ages ( t time . Time ) map [ string ] time . Duration { ages := map [ string ] time . Duration { } for id , state := range b . states { if ! state . Active ( ) { continue } ages [ id ] = state . Age ( t ) } return ages }
1415	func ( b BundledStates ) Percentile ( t time . Time , percentile int ) time . Duration { if percentile > 100 || percentile <= 0 { panic ( fmt . Errorf ( "percentile %d is out of scope" , percentile ) ) } ages := [ ] time . Duration { } for _ , age := range b . ages ( t ) { ages = append ( ages , age ) } if len ( ages ) == 0 { return 0 } sort . Sort ( ByDuration ( ages ) ) index := int ( math . Ceil ( float64 ( percentile ) * float64 ( len ( ages ) ) / 100 ) - 1 ) if index >= len ( ages ) { panic ( fmt . Errorf ( "Index is out of range: %d/%d" , index , len ( ages ) ) ) } return ages [ index ] }
1416	func NewMetrics ( ) * Metrics { return & Metrics { ClientMetrics : & ClientMetrics { Requests : requests , RequestRetries : requestRetries , RequestLatency : requestLatency , } , ResyncPeriod : resyncPeriod , } }
1417	func NewDiskCache ( delegate http . RoundTripper , cacheDir string , cacheSizeGB , maxConcurrency int ) http . RoundTripper { return NewFromCache ( delegate , diskcache . NewWithDiskv ( diskv . New ( diskv . Options { BasePath : path . Join ( cacheDir , "data" ) , TempDir : path . Join ( cacheDir , "temp" ) , CacheSizeMax : uint64 ( cacheSizeGB ) * uint64 ( 1000000000 ) , } ) ) , maxConcurrency , ) }
1418	func NewMemCache ( delegate http . RoundTripper , maxConcurrency int ) http . RoundTripper { return NewFromCache ( delegate , httpcache . NewMemoryCache ( ) , maxConcurrency ) }
1419	func NewFromCache ( delegate http . RoundTripper , cache httpcache . Cache , maxConcurrency int ) http . RoundTripper { cacheTransport := httpcache . NewTransport ( cache ) cacheTransport . Transport = newThrottlingTransport ( maxConcurrency , upstreamTransport { delegate : delegate } ) return & requestCoalescer { keys : make ( map [ string ] * responseWaiter ) , delegate : cacheTransport , } }
1420	func ( c * Clientset ) ProwV1 ( ) prowv1 . ProwV1Interface { return & fakeprowv1 . FakeProwV1 { Fake : & c . Fake } }
1421	func ( c * Clientset ) Prow ( ) prowv1 . ProwV1Interface { return & fakeprowv1 . FakeProwV1 { Fake : & c . Fake } }
1422	func NewOwners ( log * logrus . Entry , filenames [ ] string , r Repo , s int64 ) Owners { return Owners { filenames : filenames , repo : r , seed : s , log : log } }
1423	func ( o Owners ) GetApprovers ( ) map [ string ] sets . String { ownersToApprovers := map [ string ] sets . String { } for fn := range o . GetOwnersSet ( ) { ownersToApprovers [ fn ] = o . repo . Approvers ( fn ) } return ownersToApprovers }
1424	func ( o Owners ) GetAllPotentialApprovers ( ) [ ] string { approversOnly := [ ] string { } for _ , approverList := range o . GetLeafApprovers ( ) { for approver := range approverList { approversOnly = append ( approversOnly , approver ) } } sort . Strings ( approversOnly ) if len ( approversOnly ) == 0 { o . log . Debug ( "No potential approvers exist. Does the repo have OWNERS files?" ) } return approversOnly }
1425	func ( o Owners ) GetReverseMap ( approvers map [ string ] sets . String ) map [ string ] sets . String { approverOwnersfiles := map [ string ] sets . String { } for ownersFile , approvers := range approvers { for approver := range approvers { if _ , ok := approverOwnersfiles [ approver ] ; ok { approverOwnersfiles [ approver ] . Insert ( ownersFile ) } else { approverOwnersfiles [ approver ] = sets . NewString ( ownersFile ) } } } return approverOwnersfiles }
1426	func ( o Owners ) temporaryUnapprovedFiles ( approvers sets . String ) sets . String { ap := NewApprovers ( o ) for approver := range approvers { ap . AddApprover ( approver , "" , false ) } return ap . UnapprovedFiles ( ) }
1427	func ( o Owners ) KeepCoveringApprovers ( reverseMap map [ string ] sets . String , knownApprovers sets . String , potentialApprovers [ ] string ) sets . String { if len ( potentialApprovers ) == 0 { o . log . Debug ( "No potential approvers exist to filter for relevance. Does this repo have OWNERS files?" ) } keptApprovers := sets . NewString ( ) unapproved := o . temporaryUnapprovedFiles ( knownApprovers ) for _ , suggestedApprover := range o . GetSuggestedApprovers ( reverseMap , potentialApprovers ) . List ( ) { if reverseMap [ suggestedApprover ] . Intersection ( unapproved ) . Len ( ) != 0 { keptApprovers . Insert ( suggestedApprover ) } } return keptApprovers }
1428	func ( o Owners ) GetSuggestedApprovers ( reverseMap map [ string ] sets . String , potentialApprovers [ ] string ) sets . String { ap := NewApprovers ( o ) for ! ap . RequirementsMet ( ) { newApprover := findMostCoveringApprover ( potentialApprovers , reverseMap , ap . UnapprovedFiles ( ) ) if newApprover == "" { o . log . Warnf ( "Couldn't find/suggest approvers for each files. Unapproved: %q" , ap . UnapprovedFiles ( ) . List ( ) ) return ap . GetCurrentApproversSet ( ) } ap . AddApprover ( newApprover , "" , false ) } return ap . GetCurrentApproversSet ( ) }
1429	func ( o Owners ) GetOwnersSet ( ) sets . String { owners := sets . NewString ( ) for _ , fn := range o . filenames { owners . Insert ( o . repo . FindApproverOwnersForFile ( fn ) ) } o . removeSubdirs ( owners ) return owners }
1430	func ( o Owners ) GetShuffledApprovers ( ) [ ] string { approversList := o . GetAllPotentialApprovers ( ) order := rand . New ( rand . NewSource ( o . seed ) ) . Perm ( len ( approversList ) ) people := make ( [ ] string , 0 , len ( approversList ) ) for _ , i := range order { people = append ( people , approversList [ i ] ) } return people }
1431	func ( a Approval ) String ( ) string { return fmt . Sprintf ( `*<a href="%s" title="%s">%s</a>*` , a . Reference , a . How , a . Login , ) }
1432	func IntersectSetsCase ( one , other sets . String ) sets . String { lower := sets . NewString ( ) for item := range other { lower . Insert ( strings . ToLower ( item ) ) } intersection := sets . NewString ( ) for item := range one { if lower . Has ( strings . ToLower ( item ) ) { intersection . Insert ( item ) } } return intersection }
1433	func NewApprovers ( owners Owners ) Approvers { return Approvers { owners : owners , approvers : map [ string ] Approval { } , assignees : sets . NewString ( ) , ManuallyApproved : func ( ) bool { return false } , } }
1434	func ( ap * Approvers ) AddLGTMer ( login , reference string , noIssue bool ) { if ap . shouldNotOverrideApproval ( login , noIssue ) { return } ap . approvers [ strings . ToLower ( login ) ] = Approval { Login : login , How : "LGTM" , Reference : reference , NoIssue : noIssue , } }
1435	func ( ap * Approvers ) RemoveApprover ( login string ) { delete ( ap . approvers , strings . ToLower ( login ) ) }
1436	func ( ap * Approvers ) AddAssignees ( logins ... string ) { for _ , login := range logins { ap . assignees . Insert ( strings . ToLower ( login ) ) } }
1437	func ( ap Approvers ) GetCurrentApproversSetCased ( ) sets . String { currentApprovers := sets . NewString ( ) for _ , approval := range ap . approvers { currentApprovers . Insert ( approval . Login ) } return currentApprovers }
1438	func ( ap Approvers ) GetFilesApprovers ( ) map [ string ] sets . String { filesApprovers := map [ string ] sets . String { } currentApprovers := ap . GetCurrentApproversSetCased ( ) for fn , potentialApprovers := range ap . owners . GetApprovers ( ) { filesApprovers [ fn ] = IntersectSetsCase ( currentApprovers , potentialApprovers ) } return filesApprovers }
1439	func ( ap Approvers ) NoIssueApprovers ( ) map [ string ] Approval { nia := map [ string ] Approval { } reverseMap := ap . owners . GetReverseMap ( ap . owners . GetApprovers ( ) ) for login , approver := range ap . approvers { if ! approver . NoIssue { continue } if len ( reverseMap [ login ] ) == 0 { continue } nia [ login ] = approver } return nia }
1440	func ( ap Approvers ) UnapprovedFiles ( ) sets . String { unapproved := sets . NewString ( ) for fn , approvers := range ap . GetFilesApprovers ( ) { if len ( approvers ) == 0 { unapproved . Insert ( fn ) } } return unapproved }
1441	func ( ap Approvers ) GetFiles ( baseURL * url . URL , branch string ) [ ] File { allOwnersFiles := [ ] File { } filesApprovers := ap . GetFilesApprovers ( ) for _ , file := range ap . owners . GetOwnersSet ( ) . List ( ) { if len ( filesApprovers [ file ] ) == 0 { allOwnersFiles = append ( allOwnersFiles , UnapprovedFile { baseURL : baseURL , filepath : file , branch : branch , } ) } else { allOwnersFiles = append ( allOwnersFiles , ApprovedFile { baseURL : baseURL , filepath : file , approvers : filesApprovers [ file ] , branch : branch , } ) } } return allOwnersFiles }
1442	func ( ap Approvers ) IsApproved ( ) bool { reqsMet := ap . RequirementsMet ( ) if ! reqsMet && ap . ManuallyApproved ( ) { return true } return reqsMet }
1443	func ( ap Approvers ) ListApprovals ( ) [ ] Approval { approvals := [ ] Approval { } for _ , approver := range ap . GetCurrentApproversSet ( ) . List ( ) { approvals = append ( approvals , ap . approvers [ approver ] ) } return approvals }
1444	func ( ap Approvers ) ListNoIssueApprovals ( ) [ ] Approval { approvals := [ ] Approval { } for _ , approver := range ap . GetNoIssueApproversSet ( ) . List ( ) { approvals = append ( approvals , ap . approvers [ approver ] ) } return approvals }
1445	func GenerateTemplate ( templ , name string , data interface { } ) ( string , error ) { buf := bytes . NewBufferString ( "" ) if messageTempl , err := template . New ( name ) . Parse ( templ ) ; err != nil { return "" , fmt . Errorf ( "failed to parse template for %s: %v" , name , err ) } else if err := messageTempl . Execute ( buf , data ) ; err != nil { return "" , fmt . Errorf ( "failed to execute template for %s: %v" , name , err ) } return buf . String ( ) , nil }
1446	func writeTemplate ( templatePath string , outputPath string , data interface { } ) error { funcMap := template . FuncMap { "anchor" : func ( input string ) string { return strings . Replace ( input , ":" , " " , - 1 ) } , } t , err := template . New ( filepath . Base ( templatePath ) ) . Funcs ( funcMap ) . ParseFiles ( templatePath ) if err != nil { return err } if ! pathExists ( outputPath ) { _ , err = os . Create ( outputPath ) if err != nil { return err } } f , err := os . OpenFile ( outputPath , os . O_RDWR , 0644 ) if err != nil { return err } defer f . Close ( ) f . Truncate ( 0 ) err = t . Execute ( f , data ) if err != nil { return err } return nil }
1447	func ( c Configuration ) Labels ( ) [ ] Label { var labelarrays [ ] [ ] Label labelarrays = append ( labelarrays , c . Default . Labels ) for _ , repo := range c . Repos { labelarrays = append ( labelarrays , repo . Labels ) } labelmap := make ( map [ string ] Label ) for _ , labels := range labelarrays { for _ , l := range labels { name := strings . ToLower ( l . Name ) if _ , ok := labelmap [ name ] ; ! ok { labelmap [ name ] = l } } } var labels [ ] Label for _ , label := range labelmap { labels = append ( labels , label ) } sort . Slice ( labels , func ( i , j int ) bool { return labels [ i ] . Name < labels [ j ] . Name } ) return labels }
1448	func LabelsForTarget ( labels [ ] Label , target LabelTarget ) ( filteredLabels [ ] Label ) { for _ , label := range labels { if target == label . Target { filteredLabels = append ( filteredLabels , label ) } } sort . Slice ( filteredLabels , func ( i , j int ) bool { return filteredLabels [ i ] . Name < filteredLabels [ j ] . Name } ) return }
1449	func LoadConfig ( path string , orgs string ) ( * Configuration , error ) { if path == "" { return nil , errors . New ( "empty path" ) } var c Configuration data , err := ioutil . ReadFile ( path ) if err != nil { return nil , err } if err = yaml . Unmarshal ( data , & c ) ; err != nil { return nil , err } if err = c . validate ( orgs ) ; err != nil { return nil , err } return & c , nil }
1450	func loadLabels ( gc client , org string , repos [ ] string ) ( * RepoLabels , error ) { repoChan := make ( chan string , len ( repos ) ) for _ , repo := range repos { repoChan <- repo } close ( repoChan ) wg := sync . WaitGroup { } wg . Add ( maxConcurrentWorkers ) labels := make ( chan RepoLabels , len ( repos ) ) errChan := make ( chan error , len ( repos ) ) for i := 0 ; i < maxConcurrentWorkers ; i ++ { go func ( repositories <- chan string ) { defer wg . Done ( ) for repository := range repositories { logrus . WithField ( "org" , org ) . WithField ( "repo" , repository ) . Info ( "Listing labels for repo" ) repoLabels , err := gc . GetRepoLabels ( org , repository ) if err != nil { logrus . WithField ( "org" , org ) . WithField ( "repo" , repository ) . Error ( "Failed listing labels for repo" ) errChan <- err } labels <- RepoLabels { repository : repoLabels } } } ( repoChan ) } wg . Wait ( ) close ( labels ) close ( errChan ) rl := RepoLabels { } for data := range labels { for repo , repoLabels := range data { rl [ repo ] = repoLabels } } var overallErr error if len ( errChan ) > 0 { var listErrs [ ] error for listErr := range errChan { listErrs = append ( listErrs , listErr ) } overallErr = fmt . Errorf ( "failed to list labels: %v" , listErrs ) } return & rl , overallErr }
1451	func kill ( repo string , label Label ) Update { logrus . WithField ( "repo" , repo ) . WithField ( "label" , label . Name ) . Info ( "kill" ) return Update { Why : "dead" , Current : & label , repo : repo } }
1452	func create ( repo string , label Label ) Update { logrus . WithField ( "repo" , repo ) . WithField ( "label" , label . Name ) . Info ( "create" ) return Update { Why : "missing" , Wanted : & label , repo : repo } }
1453	func classifyLabels ( labels [ ] Label , required , archaic , dead map [ string ] Label , now time . Time , parent * Label ) ( map [ string ] Label , map [ string ] Label , map [ string ] Label ) { newRequired := copyLabelMap ( required ) newArchaic := copyLabelMap ( archaic ) newDead := copyLabelMap ( dead ) for i , l := range labels { first := parent if first == nil { first = & labels [ i ] } lower := strings . ToLower ( l . Name ) switch { case parent == nil && l . DeleteAfter == nil : newRequired [ lower ] = l case l . DeleteAfter != nil && now . After ( * l . DeleteAfter ) : newDead [ lower ] = l case parent != nil : l . parent = parent newArchaic [ lower ] = l } newRequired , newArchaic , newDead = classifyLabels ( l . Previously , newRequired , newArchaic , newDead , now , first ) } return newRequired , newArchaic , newDead }
1454	func linkify ( text string ) string { link := strings . Replace ( text , " " , "-" , - 1 ) discard , _ := regexp . Compile ( "[,/]" ) link = discard . ReplaceAllString ( link , "" ) return strings . ToLower ( link ) }
1455	func NewCache ( diskRoot string ) * Cache { return & Cache { diskRoot : strings . TrimSuffix ( diskRoot , string ( os . PathListSeparator ) ) , } }
1456	func ( c * Cache ) KeyToPath ( key string ) string { return filepath . Join ( c . diskRoot , key ) }
1457	func ensureDir ( dir string ) error { if exists ( dir ) { return nil } return os . MkdirAll ( dir , os . FileMode ( 0744 ) ) }
1458	func ( c * Cache ) Put ( key string , content io . Reader , contentSHA256 string ) error { path := c . KeyToPath ( key ) dir := filepath . Dir ( path ) err := ensureDir ( dir ) if err != nil { logrus . WithError ( err ) . Errorf ( "error ensuring directory '%s' exists" , dir ) } temp , err := ioutil . TempFile ( dir , "temp-put" ) if err != nil { return fmt . Errorf ( "failed to create cache entry: %v" , err ) } if contentSHA256 == "" { _ , err = io . Copy ( temp , content ) if err != nil { removeTemp ( temp . Name ( ) ) return fmt . Errorf ( "failed to copy into cache entry: %v" , err ) } } else { hasher := sha256 . New ( ) _ , err = io . Copy ( io . MultiWriter ( temp , hasher ) , content ) if err != nil { removeTemp ( temp . Name ( ) ) return fmt . Errorf ( "failed to copy into cache entry: %v" , err ) } actualContentSHA256 := hex . EncodeToString ( hasher . Sum ( nil ) ) if actualContentSHA256 != contentSHA256 { removeTemp ( temp . Name ( ) ) return fmt . Errorf ( "hashes did not match for '%s', given: '%s' actual: '%s" , key , contentSHA256 , actualContentSHA256 ) } } err = temp . Sync ( ) if err != nil { removeTemp ( temp . Name ( ) ) return fmt . Errorf ( "failed to sync cache entry: %v" , err ) } temp . Close ( ) err = os . Rename ( temp . Name ( ) , path ) if err != nil { removeTemp ( temp . Name ( ) ) return fmt . Errorf ( "failed to insert contents into cache: %v" , err ) } return nil }
1459	func ( c * Cache ) Get ( key string , readHandler ReadHandler ) error { path := c . KeyToPath ( key ) f , err := os . Open ( path ) if err != nil { if os . IsNotExist ( err ) { return readHandler ( false , nil ) } return fmt . Errorf ( "failed to get key: %v" , err ) } return readHandler ( true , f ) }
1460	func ( c * Cache ) Delete ( key string ) error { return os . Remove ( c . KeyToPath ( key ) ) }
1461	func NewGCSArtifact ( ctx context . Context , handle artifactHandle , link string , path string , sizeLimit int64 ) * GCSArtifact { return & GCSArtifact { handle : handle , link : link , path : path , sizeLimit : sizeLimit , ctx : ctx , } }
1462	func ( a * GCSArtifact ) Size ( ) ( int64 , error ) { attrs , err := a . handle . Attrs ( a . ctx ) if err != nil { return 0 , fmt . Errorf ( "error getting gcs attributes for artifact: %v" , err ) } return attrs . Size , nil }
1463	func ( a * GCSArtifact ) ReadAll ( ) ( [ ] byte , error ) { size , err := a . Size ( ) if err != nil { return nil , fmt . Errorf ( "error getting artifact size: %v" , err ) } if size > a . sizeLimit { return nil , lenses . ErrFileTooLarge } reader , err := a . handle . NewReader ( a . ctx ) if err != nil { return nil , fmt . Errorf ( "error getting artifact reader: %v" , err ) } defer reader . Close ( ) p , err := ioutil . ReadAll ( reader ) if err != nil { return nil , fmt . Errorf ( "error reading all from artifact: %v" , err ) } return p , nil }
1464	func ( a * GCSArtifact ) ReadTail ( n int64 ) ( [ ] byte , error ) { gzipped , err := a . gzipped ( ) if err != nil { return nil , fmt . Errorf ( "error checking artifact for gzip compression: %v" , err ) } if gzipped { return nil , lenses . ErrGzipOffsetRead } size , err := a . Size ( ) if err != nil { return nil , fmt . Errorf ( "error getting artifact size: %v" , err ) } var offset int64 if n >= size { offset = 0 } else { offset = size - n } reader , err := a . handle . NewRangeReader ( a . ctx , offset , - 1 ) defer reader . Close ( ) if err != nil && err != io . EOF { return nil , fmt . Errorf ( "error getting artifact reader: %v" , err ) } read , err := ioutil . ReadAll ( reader ) if err != nil { return nil , fmt . Errorf ( "error reading all from artiact: %v" , err ) } return read , nil }
1465	func ( a * GCSArtifact ) gzipped ( ) ( bool , error ) { attrs , err := a . handle . Attrs ( a . ctx ) if err != nil { return false , fmt . Errorf ( "error getting gcs attributes for artifact: %v" , err ) } return attrs . ContentEncoding == "gzip" , nil }
1466	func optionsForRepo ( config * plugins . Configuration , org , repo string ) * plugins . Welcome { fullName := fmt . Sprintf ( "%s/%s" , org , repo ) for _ , c := range config . Welcome { if ! strInSlice ( fullName , c . Repos ) { continue } return & c } for _ , c := range config . Welcome { if ! strInSlice ( org , c . Repos ) { continue } return & c } return & plugins . Welcome { } }
1467	func ( s * prowJobLister ) List ( selector labels . Selector ) ( ret [ ] * v1 . ProwJob , err error ) { err = cache . ListAll ( s . indexer , selector , func ( m interface { } ) { ret = append ( ret , m . ( * v1 . ProwJob ) ) } ) return ret , err }
1468	func ( s * prowJobLister ) ProwJobs ( namespace string ) ProwJobNamespaceLister { return prowJobNamespaceLister { indexer : s . indexer , namespace : namespace } }
1469	func ( s prowJobNamespaceLister ) List ( selector labels . Selector ) ( ret [ ] * v1 . ProwJob , err error ) { err = cache . ListAllByNamespace ( s . indexer , s . namespace , selector , func ( m interface { } ) { ret = append ( ret , m . ( * v1 . ProwJob ) ) } ) return ret , err }
1470	func ( br Brancher ) RunsAgainstAllBranch ( ) bool { return len ( br . SkipBranches ) == 0 && len ( br . Branches ) == 0 }
1471	func ( br Brancher ) Intersects ( other Brancher ) bool { if br . RunsAgainstAllBranch ( ) || other . RunsAgainstAllBranch ( ) { return true } if len ( br . Branches ) > 0 { baseBranches := sets . NewString ( br . Branches ... ) if len ( other . Branches ) > 0 { otherBranches := sets . NewString ( other . Branches ... ) if baseBranches . Intersection ( otherBranches ) . Len ( ) > 0 { return true } return false } for _ , b := range baseBranches . List ( ) { if other . ShouldRun ( b ) { return true } } return false } if len ( other . Branches ) == 0 { return true } return other . Intersects ( br ) }
1472	func ( cm RegexpChangeMatcher ) ShouldRun ( changes ChangedFilesProvider ) ( determined bool , shouldRun bool , err error ) { if cm . CouldRun ( ) { changeList , err := changes ( ) if err != nil { return true , false , err } return true , cm . RunsAgainstChanges ( changeList ) , nil } return false , false , nil }
1473	func ( cm RegexpChangeMatcher ) RunsAgainstChanges ( changes [ ] string ) bool { for _ , change := range changes { if cm . reChanges . MatchString ( change ) { return true } } return false }
1474	func ( ps Postsubmit ) CouldRun ( baseRef string ) bool { return ps . Brancher . ShouldRun ( baseRef ) }
1475	func ( ps Postsubmit ) ShouldRun ( baseRef string , changes ChangedFilesProvider ) ( bool , error ) { if ! ps . CouldRun ( baseRef ) { return false , nil } if determined , shouldRun , err := ps . RegexpChangeMatcher . ShouldRun ( changes ) ; err != nil { return false , err } else if determined { return shouldRun , nil } return true , nil }
1476	func ( ps Presubmit ) CouldRun ( baseRef string ) bool { return ps . Brancher . ShouldRun ( baseRef ) }
1477	func ( ps Presubmit ) ShouldRun ( baseRef string , changes ChangedFilesProvider , forced , defaults bool ) ( bool , error ) { if ! ps . CouldRun ( baseRef ) { return false , nil } if ps . AlwaysRun { return true , nil } if forced { return true , nil } if determined , shouldRun , err := ps . RegexpChangeMatcher . ShouldRun ( changes ) ; err != nil { return false , err } else if determined { return shouldRun , nil } return defaults , nil }
1478	func ( c * JobConfig ) GetPresubmit ( repo , jobName string ) * Presubmit { presubmits := c . AllPresubmits ( [ ] string { repo } ) for i := range presubmits { ps := presubmits [ i ] if ps . Name == jobName { return & ps } } return nil }
1479	func ( c * JobConfig ) SetPresubmits ( jobs map [ string ] [ ] Presubmit ) error { nj := map [ string ] [ ] Presubmit { } for k , v := range jobs { nj [ k ] = make ( [ ] Presubmit , len ( v ) ) copy ( nj [ k ] , v ) if err := SetPresubmitRegexes ( nj [ k ] ) ; err != nil { return err } } c . Presubmits = nj return nil }
1480	func ( c * JobConfig ) SetPostsubmits ( jobs map [ string ] [ ] Postsubmit ) error { nj := map [ string ] [ ] Postsubmit { } for k , v := range jobs { nj [ k ] = make ( [ ] Postsubmit , len ( v ) ) copy ( nj [ k ] , v ) if err := SetPostsubmitRegexes ( nj [ k ] ) ; err != nil { return err } } c . Postsubmits = nj return nil }
1481	func ( c * JobConfig ) AllPresubmits ( repos [ ] string ) [ ] Presubmit { var res [ ] Presubmit for repo , v := range c . Presubmits { if len ( repos ) == 0 { res = append ( res , v ... ) } else { for _ , r := range repos { if r == repo { res = append ( res , v ... ) break } } } } return res }
1482	func ( c * JobConfig ) AllPostsubmits ( repos [ ] string ) [ ] Postsubmit { var res [ ] Postsubmit for repo , v := range c . Postsubmits { if len ( repos ) == 0 { res = append ( res , v ... ) } else { for _ , r := range repos { if r == repo { res = append ( res , v ... ) break } } } } return res }
1483	func ( c * JobConfig ) AllPeriodics ( ) [ ] Periodic { var listPeriodic func ( ps [ ] Periodic ) [ ] Periodic listPeriodic = func ( ps [ ] Periodic ) [ ] Periodic { var res [ ] Periodic for _ , p := range ps { res = append ( res , p ) } return res } return listPeriodic ( c . Periodics ) }
1484	func ClearCompiledRegexes ( presubmits [ ] Presubmit ) { for i := range presubmits { presubmits [ i ] . re = nil presubmits [ i ] . Brancher . re = nil presubmits [ i ] . Brancher . reSkip = nil presubmits [ i ] . RegexpChangeMatcher . reChanges = nil } }
1485	func ( s * SimpleConfig ) Empty ( ) bool { return len ( s . Approvers ) == 0 && len ( s . Reviewers ) == 0 && len ( s . RequiredReviewers ) == 0 && len ( s . Labels ) == 0 }
1486	func NewClient ( gc * git . Client , ghc * github . Client , mdYAMLEnabled func ( org , repo string ) bool , skipCollaborators func ( org , repo string ) bool , ownersDirBlacklist func ( ) prowConf . OwnersDirBlacklist , ) * Client { return & Client { git : gc , ghc : ghc , logger : logrus . WithField ( "client" , "repoowners" ) , cache : make ( map [ string ] cacheEntry ) , mdYAMLEnabled : mdYAMLEnabled , skipCollaborators : skipCollaborators , ownersDirBlacklist : ownersDirBlacklist , } }
1487	func ( a RepoAliases ) ExpandAlias ( alias string ) sets . String { if a == nil { return nil } return a [ github . NormLogin ( alias ) ] }
1488	func ( a RepoAliases ) ExpandAliases ( logins sets . String ) sets . String { if a == nil { return logins } logins = logins . Union ( nil ) for _ , login := range logins . List ( ) { if expanded := a . ExpandAlias ( login ) ; len ( expanded ) > 0 { logins . Delete ( login ) logins = logins . Union ( expanded ) } } return logins }
1489	func ParseFullConfig ( b [ ] byte ) ( FullConfig , error ) { full := new ( FullConfig ) err := yaml . Unmarshal ( b , full ) return * full , err }
1490	func ParseSimpleConfig ( b [ ] byte ) ( SimpleConfig , error ) { simple := new ( SimpleConfig ) err := yaml . Unmarshal ( b , simple ) return * simple , err }
1491	func decodeOwnersMdConfig ( path string , config * SimpleConfig ) error { fileBytes , err := ioutil . ReadFile ( path ) if err != nil { return err } meta := mdStructuredHeaderRegex . FindString ( string ( fileBytes ) ) return yaml . Unmarshal ( [ ] byte ( meta ) , & config ) }
1492	func findOwnersForFile ( log * logrus . Entry , path string , ownerMap map [ string ] map [ * regexp . Regexp ] sets . String ) string { d := path for ; d != baseDirConvention ; d = canonicalize ( filepath . Dir ( d ) ) { relative , err := filepath . Rel ( d , path ) if err != nil { log . WithError ( err ) . WithField ( "path" , path ) . Errorf ( "Unable to find relative path between %q and path." , d ) return "" } for re , n := range ownerMap [ d ] { if re != nil && ! re . MatchString ( relative ) { continue } if len ( n ) != 0 { return d } } } return "" }
1493	func ( o * RepoOwners ) FindApproverOwnersForFile ( path string ) string { return findOwnersForFile ( o . log , path , o . approvers ) }
1494	func ( o * RepoOwners ) FindReviewersOwnersForFile ( path string ) string { return findOwnersForFile ( o . log , path , o . reviewers ) }
1495	func ( o * RepoOwners ) FindLabelsForFile ( path string ) sets . String { return o . entriesForFile ( path , o . labels , false ) }
1496	func ( o * RepoOwners ) IsNoParentOwners ( path string ) bool { return o . options [ path ] . NoParentOwners }
1497	func ( c * Coverage ) Ratio ( ) float32 { if c . NumAllStmts == 0 { return 1 } return float32 ( c . NumCoveredStmts ) / float32 ( c . NumAllStmts ) }
1498	func ( pe * PeriodicProwJobEvent ) FromPayload ( data [ ] byte ) error { if err := json . Unmarshal ( data , pe ) ; err != nil { return err } return nil }
1499	func ( pe * PeriodicProwJobEvent ) ToMessage ( ) ( * pubsub . Message , error ) { data , err := json . Marshal ( pe ) if err != nil { return nil , err } message := pubsub . Message { Data : data , Attributes : map [ string ] string { prowEventType : periodicProwJobEvent , } , } return & message , nil }
1500	func ( p * Privacy ) UnmarshalText ( text [ ] byte ) error { v := Privacy ( text ) if _ , ok := privacySettings [ v ] ; ! ok { return fmt . Errorf ( "bad privacy setting: %s" , v ) } * p = v return nil }
1501	func compileApplicableBlockades ( org , repo string , log * logrus . Entry , blockades [ ] plugins . Blockade ) [ ] blockade { if len ( blockades ) == 0 { return nil } orgRepo := fmt . Sprintf ( "%s/%s" , org , repo ) var compiled [ ] blockade for _ , raw := range blockades { if ! stringInSlice ( org , raw . Repos ) && ! stringInSlice ( orgRepo , raw . Repos ) { continue } b := blockade { } for _ , str := range raw . BlockRegexps { if reg , err := regexp . Compile ( str ) ; err != nil { log . WithError ( err ) . Errorf ( "Failed to compile the blockade regexp '%s'." , str ) } else { b . blockRegexps = append ( b . blockRegexps , reg ) } } if len ( b . blockRegexps ) == 0 { continue } if raw . Explanation == "" { b . explanation = "Files are protected" } else { b . explanation = raw . Explanation } for _ , str := range raw . ExceptionRegexps { if reg , err := regexp . Compile ( str ) ; err != nil { log . WithError ( err ) . Errorf ( "Failed to compile the blockade regexp '%s'." , str ) } else { b . exceptionRegexps = append ( b . exceptionRegexps , reg ) } } compiled = append ( compiled , b ) } return compiled }
1502	func calculateBlocks ( changes [ ] github . PullRequestChange , blockades [ ] blockade ) summary { sum := make ( summary ) for _ , change := range changes { for _ , b := range blockades { if b . isBlocked ( change . Filename ) { sum [ b . explanation ] = append ( sum [ b . explanation ] , change ) } } } return sum }
1503	func MergeMultipleProfiles ( profiles [ ] [ ] * cover . Profile ) ( [ ] * cover . Profile , error ) { if len ( profiles ) < 1 { return nil , errors . New ( "can't merge zero profiles" ) } result := profiles [ 0 ] for _ , profile := range profiles [ 1 : ] { var err error if result , err = MergeProfiles ( result , profile ) ; err != nil { return nil , err } } return result , nil }
1504	func ( o * Options ) AddFlags ( fs * flag . FlagSet ) { fs . StringVar ( & o . ProcessLog , "process-log" , "" , "path to the log where stdout and stderr are streamed for the process we execute" ) fs . StringVar ( & o . MarkerFile , "marker-file" , "" , "file we write the return code of the process we execute once it has finished running" ) fs . StringVar ( & o . MetadataFile , "metadata-file" , "" , "path to the metadata file generated from the job" ) }
1505	func ( c * Controller ) processNextItem ( ) bool { key , quit := c . queue . Get ( ) if quit { return false } defer c . queue . Done ( key ) workItem := key . ( item ) prowJob , err := c . prowJobClient . GetProwJob ( workItem . prowJobId ) if err != nil { c . handleErr ( err , workItem ) return true } spec := downwardapi . NewJobSpec ( prowJob . Spec , prowJob . Status . BuildID , prowJob . Name ) result := c . client . Pods ( workItem . namespace ) . GetLogs ( workItem . podName , & api . PodLogOptions { Container : workItem . containerName } ) . Do ( ) if err := result . Error ( ) ; err != nil { c . handleErr ( err , workItem ) return true } log , _ := result . Raw ( ) var target string if workItem . podName == workItem . prowJobId { target = path . Join ( ContainerLogDir , fmt . Sprintf ( "%s.txt" , workItem . containerName ) ) } else { target = path . Join ( ContainerLogDir , workItem . podName , fmt . Sprintf ( "%s.txt" , workItem . containerName ) ) } data := gcs . DataUpload ( bytes . NewReader ( log ) ) if err := c . gcsConfig . Run ( & spec , map [ string ] gcs . UploadFunc { target : data } ) ; err != nil { c . handleErr ( err , workItem ) return true } c . queue . Forget ( key ) return true }
1506	func ( c * Controller ) handleErr ( err error , key item ) { if c . queue . NumRequeues ( key ) < 5 { glog . Infof ( "Error uploading logs for container %v in pod %v: %v" , key . containerName , key . podName , err ) c . queue . AddRateLimited ( key ) return } c . queue . Forget ( key ) glog . Infof ( "Giving up on upload of logs for container %v in pod %v: %v" , key . containerName , key . podName , err ) }
1507	func AggregateFilter ( filters [ ] Filter ) Filter { return func ( presubmit config . Presubmit ) ( bool , bool , bool ) { for _ , filter := range filters { if shouldRun , forced , defaults := filter ( presubmit ) ; shouldRun { return shouldRun , forced , defaults } } return false , false , false } }
1508	func FilterPresubmits ( filter Filter , changes config . ChangedFilesProvider , branch string , presubmits [ ] config . Presubmit , logger * logrus . Entry ) ( [ ] config . Presubmit , [ ] config . Presubmit , error ) { var toTrigger [ ] config . Presubmit var toSkip [ ] config . Presubmit for _ , presubmit := range presubmits { matches , forced , defaults := filter ( presubmit ) if ! matches { continue } shouldRun , err := presubmit . ShouldRun ( branch , changes , forced , defaults ) if err != nil { return nil , nil , err } if shouldRun { toTrigger = append ( toTrigger , presubmit ) } else { toSkip = append ( toSkip , presubmit ) } } logger . WithFields ( logrus . Fields { "to-trigger" : toTrigger , "to-skip" : toSkip } ) . Debugf ( "Filtered %d jobs, found %d to trigger and %d to skip." , len ( presubmits ) , len ( toTrigger ) , len ( toSkip ) ) return toTrigger , toSkip , nil }
1509	func MakeCommand ( ) * cobra . Command { flags := & flags { } cmd := & cobra . Command { Use : "filter [file]" , Short : "Filters a Go coverage file." , Long : `Filters a Go coverage file, removing entries that do not match the given flags.` , Run : func ( cmd * cobra . Command , args [ ] string ) { run ( flags , cmd , args ) } , } cmd . Flags ( ) . StringVarP ( & flags . OutputFile , "output" , "o" , "-" , "output file" ) cmd . Flags ( ) . StringSliceVar ( & flags . IncludePaths , "include-path" , nil , "If specified at least once, only files with paths matching one of these regexes are included." ) cmd . Flags ( ) . StringSliceVar ( & flags . ExcludePaths , "exclude-path" , nil , "Files with paths matching one of these regexes are excluded. Can be used repeatedly." ) return cmd }
1510	func ( t * EventTimeHeap ) Push ( x interface { } ) { * t = append ( * t , x . ( sql . IssueEvent ) ) }
1511	func ( t * EventTimeHeap ) Pop ( ) interface { } { old := * t n := len ( old ) x := old [ n - 1 ] * t = old [ 0 : n - 1 ] return x }
1512	func NewFakeOpenPluginWrapper ( plugin Plugin ) * FakeOpenPluginWrapper { return & FakeOpenPluginWrapper { plugin : plugin , alreadyOpen : map [ string ] bool { } , } }
1513	func ( o * FakeOpenPluginWrapper ) ReceiveIssue ( issue sql . Issue ) [ ] Point { if _ , ok := o . alreadyOpen [ issue . ID ] ; ! ok { heap . Push ( & o . openEvents , sql . IssueEvent { Event : "opened" , IssueID : issue . ID , Actor : & issue . User , EventCreatedAt : issue . IssueCreatedAt , } ) o . alreadyOpen [ issue . ID ] = true } return o . plugin . ReceiveIssue ( issue ) }
1514	func ( o * Options ) Validate ( ) error { if o . SrcRoot == "" { return errors . New ( "no source root specified" ) } if o . Log == "" { return errors . New ( "no log file specified" ) } if len ( o . GitRefs ) == 0 { return errors . New ( "no refs specified to clone" ) } seen := map [ string ] sets . String { } for _ , ref := range o . GitRefs { if _ , seenOrg := seen [ ref . Org ] ; seenOrg { if seen [ ref . Org ] . Has ( ref . Repo ) { return errors . New ( "sync config for %s/%s provided more than once" ) } seen [ ref . Org ] . Insert ( ref . Repo ) } else { seen [ ref . Org ] = sets . NewString ( ref . Repo ) } } return nil }
1515	func ( o * Options ) Complete ( args [ ] string ) { o . GitRefs = o . refs . gitRefs o . KeyFiles = o . keys . data for _ , ref := range o . GitRefs { alias , err := o . clonePath . Execute ( OrgRepo { Org : ref . Org , Repo : ref . Repo } ) if err != nil { panic ( err ) } ref . PathAlias = alias alias , err = o . cloneURI . Execute ( OrgRepo { Org : ref . Org , Repo : ref . Repo } ) if err != nil { panic ( err ) } ref . CloneURI = alias } }
1516	func ( a * orgRepoFormat ) Set ( value string ) error { templ , err := template . New ( "format" ) . Parse ( value ) if err != nil { return err } a . raw = value a . format = templ return nil }
1517	func ensure ( binary , install string ) error { if _ , err := exec . LookPath ( binary ) ; err != nil { return fmt . Errorf ( "%s: %s" , binary , install ) } return nil }
1518	func output ( args ... string ) ( string , error ) { cmd := exec . Command ( args [ 0 ] , args [ 1 : ] ... ) cmd . Stderr = os . Stderr cmd . Stdin = os . Stdin b , err := cmd . Output ( ) return strings . TrimSpace ( string ( b ) ) , err }
1519	func projects ( max int ) ( [ ] string , error ) { out , err := output ( "gcloud" , "projects" , "list" , fmt . Sprintf ( "--limit=%d" , max ) , "--format=value(project_id)" ) if err != nil { return nil , err } return strings . Split ( out , "\n" ) , nil }
1520	func selectProject ( choice string ) ( string , error ) { fmt . Print ( "Getting active GCP account..." ) who , err := currentAccount ( ) if err != nil { logrus . Warn ( "Run gcloud auth login to initialize gcloud" ) return "" , err } fmt . Println ( who ) var projs [ ] string if choice == "" { fmt . Printf ( "Projects available to %s:" , who ) fmt . Println ( ) const max = 20 projs , err = projects ( max ) for _ , proj := range projs { fmt . Println ( " *" , proj ) } if err != nil { return "" , fmt . Errorf ( "list projects: %v" , err ) } if len ( projs ) == 0 { fmt . Println ( "Create a project at https://console.cloud.google.com/" ) return "" , errors . New ( "no projects" ) } if len ( projs ) == max { fmt . Println ( " ... Wow, that is a lot of projects!" ) fmt . Println ( "Type the name of any project, including ones not in this truncated list" ) } def , err := currentProject ( ) if err != nil { return "" , fmt . Errorf ( "get current project: %v" , err ) } fmt . Printf ( "Select project [%s]: " , def ) fmt . Scanln ( & choice ) if choice == "" { return def , nil } } for _ , p := range projs { if p == choice { return choice , nil } } fmt . Printf ( "Ensuring %s has access to %s..." , who , choice ) fmt . Println ( ) if err = exec . Command ( "gcloud" , "projects" , "describe" , choice ) . Run ( ) ; err != nil { return "" , fmt . Errorf ( "%s cannot describe project: %v" , who , err ) } return choice , nil }
1521	func createCluster ( proj , choice string ) ( * cluster , error ) { const def = "prow" if choice == "" { fmt . Printf ( "Cluster name [%s]: " , def ) fmt . Scanln ( & choice ) if choice == "" { choice = def } } cmd := exec . Command ( "gcloud" , "container" , "clusters" , "create" , choice ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr if err := cmd . Run ( ) ; err != nil { return nil , fmt . Errorf ( "create cluster: %v" , err ) } out , err := output ( "gcloud" , "container" , "clusters" , "describe" , choice , "--format=value(name,zone)" ) if err != nil { return nil , fmt . Errorf ( "describe cluster: %v" , err ) } parts := strings . Split ( out , "\t" ) \t if len ( parts ) != 2 { return nil , fmt . Errorf ( "bad describe cluster output: %s" , out ) } }
1522	func createContext ( co contextOptions ) ( string , error ) { proj , err := selectProject ( co . project ) if err != nil { logrus . Info ( "Run gcloud auth login to initialize gcloud" ) return "" , fmt . Errorf ( "get current project: %v" , err ) } fmt . Printf ( "Existing GKE clusters in %s:" , proj ) fmt . Println ( ) clusters , err := currentClusters ( proj ) if err != nil { return "" , fmt . Errorf ( "list %s clusters: %v" , proj , err ) } for name := range clusters { fmt . Println ( " *" , name ) } if len ( clusters ) == 0 { fmt . Println ( " No clusters" ) } var choice string create := co . create reuse := co . reuse switch { case create != "" && reuse != "" : return "" , errors . New ( "Cannot use both --create and --reuse" ) case create != "" : fmt . Println ( "Creating new " + create + " cluster..." ) choice = "new" case reuse != "" : fmt . Println ( "Reusing existing " + reuse + " cluster..." ) choice = reuse default : fmt . Print ( "Get credentials for existing cluster or [create new]: " ) fmt . Scanln ( & choice ) } if choice == "" || choice == "new" { cluster , err := createCluster ( proj , create ) if err != nil { return "" , fmt . Errorf ( "create cluster in %s: %v" , proj , err ) } return cluster . context ( ) , nil } cluster , ok := clusters [ choice ] if ! ok { return "" , fmt . Errorf ( "cluster not found: %s" , choice ) } cmd := exec . Command ( "gcloud" , "container" , "clusters" , "get-credentials" , cluster . name , "--project=" + cluster . project , "--zone=" + cluster . zone ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr if err := cmd . Run ( ) ; err != nil { return "" , fmt . Errorf ( "get credentials: %v" , err ) } return cluster . context ( ) , nil }
1523	func contextConfig ( ) ( clientcmd . ClientConfigLoader , * clientcmdapi . Config , error ) { if err := ensureKubectl ( ) ; err != nil { fmt . Println ( "Prow's tackler requires kubectl, please install:" ) fmt . Println ( " *" , err ) if gerr := ensureGcloud ( ) ; gerr != nil { fmt . Println ( " *" , gerr ) } return nil , nil , errors . New ( "missing kubectl" ) } l := clientcmd . NewDefaultClientConfigLoadingRules ( ) c , err := l . Load ( ) return l , c , err }
1524	func selectContext ( co contextOptions ) ( string , error ) { fmt . Println ( "Existing kubernetes contexts:" ) _ , cfg , err := contextConfig ( ) if err != nil { logrus . WithError ( err ) . Fatal ( "Failed to load ~/.kube/config from any obvious location" ) } options := map [ int ] string { } var ctxs [ ] string for ctx := range cfg . Contexts { ctxs = append ( ctxs , ctx ) } sort . Strings ( ctxs ) for idx , ctx := range ctxs { options [ idx ] = ctx if ctx == cfg . CurrentContext { fmt . Printf ( "* %d: %s (current)" , idx , ctx ) } else { fmt . Printf ( " %d: %s" , idx , ctx ) } fmt . Println ( ) } fmt . Println ( ) choice := co . context switch { case choice != "" : fmt . Println ( "Reuse " + choice + " context..." ) case co . create != "" || co . reuse != "" : choice = "create" fmt . Println ( "Create new context..." ) default : fmt . Print ( "Choose context or [create new]: " ) fmt . Scanln ( & choice ) } if choice == "create" || choice == "" || choice == "create new" || choice == "new" { ctx , err := createContext ( co ) if err != nil { return "" , fmt . Errorf ( "create context: %v" , err ) } return ctx , nil } if _ , ok := cfg . Contexts [ choice ] ; ok { return choice , nil } idx , err := strconv . Atoi ( choice ) if err != nil { return "" , fmt . Errorf ( "invalid context: %q" , choice ) } if ctx , ok := options [ idx ] ; ok { return ctx , nil } return "" , fmt . Errorf ( "invalid index: %d" , idx ) }
1525	func applyCreate ( ctx string , args ... string ) error { create := exec . Command ( "kubectl" , append ( [ ] string { "--dry-run=true" , "--output=yaml" , "create" } , args ... ) ... ) create . Stderr = os . Stderr obj , err := create . StdoutPipe ( ) if err != nil { return fmt . Errorf ( "rolebinding pipe: %v" , err ) } if err := create . Start ( ) ; err != nil { return fmt . Errorf ( "start create: %v" , err ) } if err := apply ( ctx , obj ) ; err != nil { return fmt . Errorf ( "apply: %v" , err ) } if err := create . Wait ( ) ; err != nil { return fmt . Errorf ( "create: %v" , err ) } return nil }
1526	func determineSkippedPresubmits ( toTrigger , toSkipSuperset [ ] config . Presubmit , logger * logrus . Entry ) [ ] config . Presubmit { triggeredContexts := sets . NewString ( ) for _ , presubmit := range toTrigger { triggeredContexts . Insert ( presubmit . Context ) } var toSkip [ ] config . Presubmit for _ , presubmit := range toSkipSuperset { if triggeredContexts . Has ( presubmit . Context ) { logger . WithFields ( logrus . Fields { "context" : presubmit . Context , "job" : presubmit . Name } ) . Debug ( "Not skipping job as context will be created by a triggered job." ) continue } toSkip = append ( toSkip , presubmit ) } return toSkip }
1527	func Dispatch ( plugin plugins . Plugin , DB * InfluxDB , issues chan sql . Issue , eventsCommentsChannel chan interface { } ) { for { var points [ ] plugins . Point select { case issue , ok := <- issues : if ! ok { return } points = plugin . ReceiveIssue ( issue ) case event , ok := <- eventsCommentsChannel : if ! ok { return } switch event := event . ( type ) { case sql . IssueEvent : points = plugin . ReceiveIssueEvent ( event ) case sql . Comment : points = plugin . ReceiveComment ( event ) default : glog . Fatal ( "Received invalid object: " , event ) } } for _ , point := range points { if err := DB . Push ( point . Tags , point . Values , point . Date ) ; err != nil { glog . Fatal ( "Failed to push point: " , err ) } } } }
1528	func ( c * Client ) CreateIssue ( org , repo , title , body string , labels , assignees [ ] string ) ( * github . Issue , error ) { glog . Infof ( "CreateIssue(dry=%t) Title:%q, Labels:%q, Assignees:%q\n" , \n , c . dryRun , title , labels ) assignees if c . dryRun { return nil , nil } issue := & github . IssueRequest { Title : & title , Body : & body , } if len ( labels ) > 0 { issue . Labels = & labels } if len ( assignees ) > 0 { issue . Assignees = & assignees } var result * github . Issue _ , err := c . retry ( fmt . Sprintf ( "creating issue '%s'" , title ) , func ( ) ( * github . Response , error ) { var resp * github . Response var err error result , resp , err = c . issueService . Create ( context . Background ( ) , org , repo , issue ) return resp , err } , ) }
1529	func ( c * Client ) CreateStatus ( owner , repo , ref string , status * github . RepoStatus ) ( * github . RepoStatus , error ) { glog . Infof ( "CreateStatus(dry=%t) ref:%s: %s:%s" , c . dryRun , ref , * status . Context , * status . State ) if c . dryRun { return nil , nil } var result * github . RepoStatus msg := fmt . Sprintf ( "creating status for ref '%s'" , ref ) _ , err := c . retry ( msg , func ( ) ( * github . Response , error ) { var resp * github . Response var err error result , resp , err = c . repoService . CreateStatus ( context . Background ( ) , owner , repo , ref , status ) return resp , err } ) return result , err }
1530	func ( c * Client ) ForEachPR ( owner , repo string , opts * github . PullRequestListOptions , continueOnError bool , mungePR PRMungeFunc ) error { var lastPage int _ , err := c . depaginate ( "processing PRs" , & opts . ListOptions , func ( ) ( [ ] interface { } , * github . Response , error ) { list , resp , err := c . prService . List ( context . Background ( ) , owner , repo , opts ) if err == nil { for _ , pr := range list { if pr == nil { glog . Errorln ( "Received a nil PR from go-github while listing PRs. Skipping..." ) } if mungeErr := mungePR ( pr ) ; mungeErr != nil { if pr . Number == nil { mungeErr = fmt . Errorf ( "error munging pull request with nil Number field: %v" , mungeErr ) } else { mungeErr = fmt . Errorf ( "error munging pull request #%d: %v" , * pr . Number , mungeErr ) } if ! continueOnError { return nil , resp , & retryAbort { mungeErr } } glog . Errorf ( "%v\n" , \n ) } } mungeErr if resp . LastPage > 0 { lastPage = resp . LastPage } } glog . Infof ( "ForEachPR processed page %d/%d\n" , \n , opts . ListOptions . Page ) } , ) lastPage }
1531	func ( c * Client ) GetCollaborators ( org , repo string ) ( [ ] * github . User , error ) { opts := & github . ListCollaboratorsOptions { } collaborators , err := c . depaginate ( fmt . Sprintf ( "getting collaborators for '%s/%s'" , org , repo ) , & opts . ListOptions , func ( ) ( [ ] interface { } , * github . Response , error ) { page , resp , err := c . repoService . ListCollaborators ( context . Background ( ) , org , repo , opts ) var interfaceList [ ] interface { } if err == nil { interfaceList = make ( [ ] interface { } , 0 , len ( page ) ) for _ , user := range page { interfaceList = append ( interfaceList , user ) } } return interfaceList , resp , err } , ) result := make ( [ ] * github . User , 0 , len ( collaborators ) ) for _ , user := range collaborators { result = append ( result , user . ( * github . User ) ) } return result , err }
1532	func ( c * Client ) GetCombinedStatus ( owner , repo , ref string ) ( * github . CombinedStatus , error ) { var result * github . CombinedStatus listOpts := & github . ListOptions { } statuses , err := c . depaginate ( fmt . Sprintf ( "getting combined status for ref '%s'" , ref ) , listOpts , func ( ) ( [ ] interface { } , * github . Response , error ) { combined , resp , err := c . repoService . GetCombinedStatus ( context . Background ( ) , owner , repo , ref , listOpts , ) if result == nil { result = combined } var interfaceList [ ] interface { } if err == nil { interfaceList = make ( [ ] interface { } , 0 , len ( combined . Statuses ) ) for _ , status := range combined . Statuses { interfaceList = append ( interfaceList , status ) } } return interfaceList , resp , err } , ) if result != nil { result . Statuses = make ( [ ] github . RepoStatus , 0 , len ( statuses ) ) for _ , status := range statuses { result . Statuses = append ( result . Statuses , status . ( github . RepoStatus ) ) } } return result , err }
1533	func ( c * Client ) GetIssues ( org , repo string , opts * github . IssueListByRepoOptions ) ( [ ] * github . Issue , error ) { issues , err := c . depaginate ( fmt . Sprintf ( "getting issues from '%s/%s'" , org , repo ) , & opts . ListOptions , func ( ) ( [ ] interface { } , * github . Response , error ) { page , resp , err := c . issueService . ListByRepo ( context . Background ( ) , org , repo , opts ) var interfaceList [ ] interface { } if err == nil { interfaceList = make ( [ ] interface { } , 0 , len ( page ) ) for _ , issue := range page { interfaceList = append ( interfaceList , issue ) } } return interfaceList , resp , err } , ) result := make ( [ ] * github . Issue , 0 , len ( issues ) ) for _ , issue := range issues { result = append ( result , issue . ( * github . Issue ) ) } return result , err }
1534	func ( c * Client ) GetRepoLabels ( org , repo string ) ( [ ] * github . Label , error ) { opts := & github . ListOptions { } labels , err := c . depaginate ( fmt . Sprintf ( "getting valid labels for '%s/%s'" , org , repo ) , opts , func ( ) ( [ ] interface { } , * github . Response , error ) { page , resp , err := c . issueService . ListLabels ( context . Background ( ) , org , repo , opts ) var interfaceList [ ] interface { } if err == nil { interfaceList = make ( [ ] interface { } , 0 , len ( page ) ) for _ , label := range page { interfaceList = append ( interfaceList , label ) } } return interfaceList , resp , err } , ) result := make ( [ ] * github . Label , 0 , len ( labels ) ) for _ , label := range labels { result = append ( result , label . ( * github . Label ) ) } return result , err }
1535	func ( c * Client ) GetUser ( login string ) ( * github . User , error ) { var result * github . User _ , err := c . retry ( fmt . Sprintf ( "getting user '%s'" , login ) , func ( ) ( * github . Response , error ) { var resp * github . Response var err error result , resp , err = c . userService . Get ( context . Background ( ) , login ) return resp , err } , ) return result , err }
1536	func checkConfigValidity ( ) error { glog . Info ( "Verifying if a valid config has been provided through the flags" ) if * nodeName == "" { return fmt . Errorf ( "Flag --node-name has its value unspecified" ) } if * gcsPath == "" { return fmt . Errorf ( "Flag --gcs-path has its value unspecified" ) } if _ , err := os . Stat ( * gcloudAuthFilePath ) ; err != nil { return fmt . Errorf ( "Could not find the gcloud service account file: %v" , err ) } else { glog . Infof ( "Running gcloud auth activate-service-account --key-file=%s\n" , \n ) * gcloudAuthFilePath cmd := exec . Command ( "gcloud" , "auth" , "activate-service-account" , "--key-file=" + * gcloudAuthFilePath ) var stderr , stdout bytes . Buffer cmd . Stderr , cmd . Stdout = & stderr , & stdout err = cmd . Run ( ) glog . Infof ( "Stdout:\n%s\n" , \n ) \n } stdout . String ( ) }
1537	func createSystemdLogfile ( service string , outputMode string , outputDir string ) error { journalCmdArgs := [ ] string { fmt . Sprintf ( "--output=%v" , outputMode ) , "-D" , * journalPath } if service == "kern" { journalCmdArgs = append ( journalCmdArgs , "-k" ) } else { journalCmdArgs = append ( journalCmdArgs , "-u" , fmt . Sprintf ( "%v.service" , service ) ) } cmd := exec . Command ( "journalctl" , journalCmdArgs ... ) output , err := cmd . Output ( ) if err != nil { return fmt . Errorf ( "Journalctl command for '%v' service failed: %v" , service , err ) } logfile := filepath . Join ( outputDir , service + ".log" ) if err := ioutil . WriteFile ( logfile , output , 0444 ) ; err != nil { return fmt . Errorf ( "Writing to file of journalctl logs for '%v' service failed: %v" , service , err ) } return nil }
1538	func createFullSystemdLogfile ( outputDir string ) error { cmd := exec . Command ( "journalctl" , "--output=short-precise" , "-D" , * journalPath ) output , err := cmd . Output ( ) if err != nil { return fmt . Errorf ( "Journalctl command failed: %v" , err ) } logfile := filepath . Join ( outputDir , "systemd.log" ) if err := ioutil . WriteFile ( logfile , output , 0444 ) ; err != nil { return fmt . Errorf ( "Writing full journalctl logs to file failed: %v" , err ) } return nil }
1539	func createSystemdLogfiles ( outputDir string ) { services := append ( systemdServices , nodeSystemdServices ... ) for _ , service := range services { if err := createSystemdLogfile ( service , "cat" , outputDir ) ; err != nil { glog . Warningf ( "Failed to record journalctl logs: %v" , err ) } } for _ , service := range systemdSetupServices { if err := createSystemdLogfile ( service , "short-precise" , outputDir ) ; err != nil { glog . Warningf ( "Failed to record journalctl logs: %v" , err ) } } if * dumpSystemdJournal { if err := createFullSystemdLogfile ( outputDir ) ; err != nil { glog . Warningf ( "Failed to record journalctl logs: %v" , err ) } } }
1540	func prepareLogfiles ( logDir string ) { glog . Info ( "Preparing logfiles relevant to this node" ) logfiles := nodeLogs [ : ] switch * cloudProvider { case "gce" , "gke" : logfiles = append ( logfiles , gceLogs ... ) case "aws" : logfiles = append ( logfiles , awsLogs ... ) default : glog . Errorf ( "Unknown cloud provider '%v' provided, skipping any provider specific logs" , * cloudProvider ) } if * enableHollowNodeLogs { logfiles = append ( logfiles , kubemarkLogs ... ) } if _ , err := os . Stat ( "/workspace/etc/systemd/journald.conf" ) ; err == nil { glog . Info ( "Journalctl found on host. Collecting systemd logs" ) createSystemdLogfiles ( logDir ) } else { glog . Infof ( "Journalctl not found on host (%v). Collecting supervisord logs instead" , err ) logfiles = append ( logfiles , kernelLog ) logfiles = append ( logfiles , initdLogs ... ) logfiles = append ( logfiles , supervisordLogs ... ) } for _ , logfile := range logfiles { logfileFullPath := filepath . Join ( localLogPath , logfile + ".log*" ) cmd := exec . Command ( "/bin/sh" , "-c" , fmt . Sprintf ( "cp %v %v" , logfileFullPath , logDir ) ) if err := cmd . Run ( ) ; err != nil { glog . Warningf ( "Failed to copy any logfiles with pattern '%v': %v" , logfileFullPath , err ) } } }
1541	func writeSuccessMarkerFile ( ) error { markerFilePath := * gcsPath + "/logexported-nodes-registry/" + * nodeName + ".txt" cmd := exec . Command ( "gsutil" , "-q" , "cp" , "-a" , "public-read" , "-" , markerFilePath ) stdin , err := cmd . StdinPipe ( ) if err != nil { return fmt . Errorf ( "Failed to get stdin pipe to write marker file: %v" , err ) } io . WriteString ( stdin , "" ) stdin . Close ( ) if err = cmd . Run ( ) ; err != nil { return fmt . Errorf ( "Failed to write marker file to GCS: %v" , err ) } return nil }
1542	func MakeCommand ( ) * cobra . Command { flags := & flags { } cmd := & cobra . Command { Use : "junit [profile]" , Short : "Summarize coverage profile and produce the result in junit xml format." , Long : `Summarize coverage profile and produce the result in junit xml format.Summary done at per-file and per-package level. Any coverage below coverage-threshold will be markedwith a <failure> tag in the xml produced.` , Run : func ( cmd * cobra . Command , args [ ] string ) { run ( flags , cmd , args ) } , } cmd . Flags ( ) . StringVarP ( & flags . outputFile , "output" , "o" , "-" , "output file" ) cmd . Flags ( ) . Float32VarP ( & flags . threshold , "threshold" , "t" , .8 , "code coverage threshold" ) return cmd }
1543	func warnDeprecated ( last * time . Time , freq time . Duration , msg string ) { warnLock . RLock ( ) fresh := time . Now ( ) . Sub ( * last ) <= freq warnLock . RUnlock ( ) if fresh { return } warnLock . Lock ( ) defer warnLock . Unlock ( ) now := time . Now ( ) if now . Sub ( * last ) <= freq { return } * last = now logrus . Warn ( msg ) }
1544	func ( r RequireMatchingLabel ) Describe ( ) string { str := & strings . Builder { } fmt . Fprintf ( str , "Applies the '%s' label " , r . MissingLabel ) if r . MissingComment == "" { fmt . Fprint ( str , "to " ) } else { fmt . Fprint ( str , "and comments on " ) } if r . Issues { fmt . Fprint ( str , "Issues " ) if r . PRs { fmt . Fprint ( str , "and " ) } } if r . PRs { if r . Branch != "" { fmt . Fprintf ( str , "'%s' branch " , r . Branch ) } fmt . Fprint ( str , "PRs " ) } if r . Repo == "" { fmt . Fprintf ( str , "in the '%s' GitHub org " , r . Org ) } else { fmt . Fprintf ( str , "in the '%s/%s' GitHub repo " , r . Org , r . Repo ) } fmt . Fprintf ( str , "that have no labels matching the regular expression '%s'." , r . Regexp ) return str . String ( ) }
1545	func ( c * Configuration ) TriggerFor ( org , repo string ) Trigger { for _ , tr := range c . Triggers { for _ , r := range tr . Repos { if r == org || r == fmt . Sprintf ( "%s/%s" , org , repo ) { return tr } } } return Trigger { } }
1546	func ( c * Configuration ) EnabledReposForPlugin ( plugin string ) ( orgs , repos [ ] string ) { for repo , plugins := range c . Plugins { found := false for _ , candidate := range plugins { if candidate == plugin { found = true break } } if found { if strings . Contains ( repo , "/" ) { repos = append ( repos , repo ) } else { orgs = append ( orgs , repo ) } } } return }
1547	func ( c * Configuration ) EnabledReposForExternalPlugin ( plugin string ) ( orgs , repos [ ] string ) { for repo , plugins := range c . ExternalPlugins { found := false for _ , candidate := range plugins { if candidate . Name == plugin { found = true break } } if found { if strings . Contains ( repo , "/" ) { repos = append ( repos , repo ) } else { orgs = append ( orgs , repo ) } } } return }
1548	func ( c * ConfigUpdater ) SetDefaults ( ) { if len ( c . Maps ) == 0 { cf := c . ConfigFile if cf == "" { cf = "prow/config.yaml" } else { logrus . Warnf ( `config_file is deprecated, please switch to "maps": {"%s": "config"} before July 2018` , cf ) } pf := c . PluginFile if pf == "" { pf = "prow/plugins.yaml" } else { logrus . Warnf ( `plugin_file is deprecated, please switch to "maps": {"%s": "plugins"} before July 2018` , pf ) } c . Maps = map [ string ] ConfigMapSpec { cf : { Name : "config" , } , pf : { Name : "plugins" , } , } } for name , spec := range c . Maps { spec . Namespaces = append ( [ ] string { spec . Namespace } , spec . AdditionalNamespaces ... ) c . Maps [ name ] = spec } }
1549	func validatePlugins ( plugins map [ string ] [ ] string ) error { var errors [ ] string for _ , configuration := range plugins { for _ , plugin := range configuration { if _ , ok := pluginHelp [ plugin ] ; ! ok { errors = append ( errors , fmt . Sprintf ( "unknown plugin: %s" , plugin ) ) } } } for repo , repoConfig := range plugins { if strings . Contains ( repo , "/" ) { org := strings . Split ( repo , "/" ) [ 0 ] if dupes := findDuplicatedPluginConfig ( repoConfig , plugins [ org ] ) ; len ( dupes ) > 0 { errors = append ( errors , fmt . Sprintf ( "plugins %v are duplicated for %s and %s" , dupes , repo , org ) ) } } } if len ( errors ) > 0 { return fmt . Errorf ( "invalid plugin configuration:\n\t%v" , \n ) } \t }
1550	func ( c * Client ) ShouldReport ( pj * v1 . ProwJob ) bool { if pj . Status . State == v1 . TriggeredState || pj . Status . State == v1 . PendingState { logrus . WithField ( "prowjob" , pj . ObjectMeta . Name ) . Info ( "PJ not finished" ) return false } if pj . Status . State == v1 . AbortedState { logrus . WithField ( "prowjob" , pj . ObjectMeta . Name ) . Info ( "PJ aborted" ) return false } if pj . ObjectMeta . Annotations [ client . GerritID ] == "" || pj . ObjectMeta . Annotations [ client . GerritInstance ] == "" || pj . ObjectMeta . Labels [ client . GerritRevision ] == "" { logrus . WithField ( "prowjob" , pj . ObjectMeta . Name ) . Info ( "Not a gerrit job" ) return false } selector := labels . Set { client . GerritRevision : pj . ObjectMeta . Labels [ client . GerritRevision ] , kube . ProwJobTypeLabel : pj . ObjectMeta . Labels [ kube . ProwJobTypeLabel ] , } if pj . ObjectMeta . Labels [ client . GerritReportLabel ] == "" { logrus . Errorf ( "Gerrit report label not set for job %s" , pj . Spec . Job ) } else { selector [ client . GerritReportLabel ] = pj . ObjectMeta . Labels [ client . GerritReportLabel ] } pjs , err := c . lister . List ( selector . AsSelector ( ) ) if err != nil { logrus . WithError ( err ) . Errorf ( "Cannot list prowjob with selector %v" , selector ) return false } for _ , pjob := range pjs { if pjob . Status . State == v1 . TriggeredState || pjob . Status . State == v1 . PendingState { logrus . WithField ( "prowjob" , pjob . ObjectMeta . Name ) . Info ( "Other jobs with same label are still running on this revision" ) return false } } return true }
1551	func Run ( refs prowapi . Refs , dir , gitUserName , gitUserEmail , cookiePath string , env [ ] string ) Record { logrus . WithFields ( logrus . Fields { "refs" : refs } ) . Info ( "Cloning refs" ) record := Record { Refs : refs } runCommands := func ( commands [ ] cloneCommand ) error { for _ , command := range commands { formattedCommand , output , err := command . run ( ) logrus . WithFields ( logrus . Fields { "command" : formattedCommand , "output" : output , "error" : err } ) . Info ( "Ran command" ) message := "" if err != nil { message = err . Error ( ) record . Failed = true } record . Commands = append ( record . Commands , Command { Command : formattedCommand , Output : output , Error : message } ) if err != nil { return err } } return nil } g := gitCtxForRefs ( refs , dir , env ) if err := runCommands ( g . commandsForBaseRef ( refs , gitUserName , gitUserEmail , cookiePath ) ) ; err != nil { return record } timestamp , err := g . gitHeadTimestamp ( ) if err != nil { timestamp = int ( time . Now ( ) . Unix ( ) ) } if err := runCommands ( g . commandsForPullRefs ( refs , timestamp ) ) ; err != nil { return record } finalSHA , err := g . gitRevParse ( ) if err != nil { logrus . WithError ( err ) . Warnf ( "Cannot resolve finalSHA for ref %#v" , refs ) } else { record . FinalSHA = finalSHA } return record }
1552	func PathForRefs ( baseDir string , refs prowapi . Refs ) string { var clonePath string if refs . PathAlias != "" { clonePath = refs . PathAlias } else { clonePath = fmt . Sprintf ( "github.com/%s/%s" , refs . Org , refs . Repo ) } return fmt . Sprintf ( "%s/src/%s" , baseDir , clonePath ) }
1553	func gitCtxForRefs ( refs prowapi . Refs , baseDir string , env [ ] string ) gitCtx { g := gitCtx { cloneDir : PathForRefs ( baseDir , refs ) , env : env , repositoryURI : fmt . Sprintf ( "https://github.com/%s/%s.git" , refs . Org , refs . Repo ) , } if refs . CloneURI != "" { g . repositoryURI = refs . CloneURI } return g }
1554	func ( g * gitCtx ) commandsForBaseRef ( refs prowapi . Refs , gitUserName , gitUserEmail , cookiePath string ) [ ] cloneCommand { commands := [ ] cloneCommand { { dir : "/" , env : g . env , command : "mkdir" , args : [ ] string { "-p" , g . cloneDir } } } commands = append ( commands , g . gitCommand ( "init" ) ) if gitUserName != "" { commands = append ( commands , g . gitCommand ( "config" , "user.name" , gitUserName ) ) } if gitUserEmail != "" { commands = append ( commands , g . gitCommand ( "config" , "user.email" , gitUserEmail ) ) } if cookiePath != "" { commands = append ( commands , g . gitCommand ( "config" , "http.cookiefile" , cookiePath ) ) } commands = append ( commands , g . gitCommand ( "fetch" , g . repositoryURI , "--tags" , "--prune" ) ) commands = append ( commands , g . gitCommand ( "fetch" , g . repositoryURI , refs . BaseRef ) ) var target string if refs . BaseSHA != "" { target = refs . BaseSHA } else { target = "FETCH_HEAD" } commands = append ( commands , g . gitCommand ( "checkout" , target ) ) commands = append ( commands , g . gitCommand ( "branch" , "--force" , refs . BaseRef , target ) ) commands = append ( commands , g . gitCommand ( "checkout" , refs . BaseRef ) ) return commands }
1555	func gitTimestampEnvs ( timestamp int ) [ ] string { return [ ] string { fmt . Sprintf ( "GIT_AUTHOR_DATE=%d" , timestamp ) , fmt . Sprintf ( "GIT_COMMITTER_DATE=%d" , timestamp ) , } }
1556	func ( g * gitCtx ) gitRevParse ( ) ( string , error ) { gitRevParseCommand := g . gitCommand ( "rev-parse" , "HEAD" ) _ , commit , err := gitRevParseCommand . run ( ) if err != nil { logrus . WithError ( err ) . Error ( "git rev-parse HEAD failed!" ) return "" , err } return strings . TrimSpace ( commit ) , nil }
1557	func ( g * gitCtx ) commandsForPullRefs ( refs prowapi . Refs , fakeTimestamp int ) [ ] cloneCommand { var commands [ ] cloneCommand for _ , prRef := range refs . Pulls { ref := fmt . Sprintf ( "pull/%d/head" , prRef . Number ) if prRef . Ref != "" { ref = prRef . Ref } commands = append ( commands , g . gitCommand ( "fetch" , g . repositoryURI , ref ) ) var prCheckout string if prRef . SHA != "" { prCheckout = prRef . SHA } else { prCheckout = "FETCH_HEAD" } fakeTimestamp ++ gitMergeCommand := g . gitCommand ( "merge" , "--no-ff" , prCheckout ) gitMergeCommand . env = append ( gitMergeCommand . env , gitTimestampEnvs ( fakeTimestamp ) ... ) commands = append ( commands , gitMergeCommand ) } if ! refs . SkipSubmodules { commands = append ( commands , g . gitCommand ( "submodule" , "update" , "--init" , "--recursive" ) ) } return commands }
1558	func ProduceCovList ( profiles [ ] * cover . Profile ) * CoverageList { covList := newCoverageList ( "summary" ) for _ , prof := range profiles { covList . Group = append ( covList . Group , summarizeBlocks ( prof ) ) } return covList }
1559	func popRandom ( set sets . String ) string { list := set . List ( ) sort . Strings ( list ) sel := list [ rand . Intn ( len ( list ) ) ] set . Delete ( sel ) return sel }
1560	func ( o * ExperimentalKubernetesOptions ) resolve ( dryRun bool ) ( err error ) { if o . resolved { return nil } o . dryRun = dryRun if dryRun { return nil } clusterConfigs , err := kube . LoadClusterConfigs ( o . kubeconfig , o . buildCluster ) if err != nil { return fmt . Errorf ( "load --kubeconfig=%q --build-cluster=%q configs: %v" , o . kubeconfig , o . buildCluster , err ) } clients := map [ string ] kubernetes . Interface { } for context , config := range clusterConfigs { client , err := kubernetes . NewForConfig ( & config ) if err != nil { return fmt . Errorf ( "create %s kubernetes client: %v" , context , err ) } clients [ context ] = client } localCfg := clusterConfigs [ kube . InClusterContext ] pjClient , err := prow . NewForConfig ( & localCfg ) if err != nil { return err } o . prowJobClientset = pjClient o . kubernetesClientsByContext = clients o . resolved = true return nil }
1561	func ( o * ExperimentalKubernetesOptions ) ProwJobClientset ( namespace string , dryRun bool ) ( prowJobClientset prow . Interface , err error ) { if err := o . resolve ( dryRun ) ; err != nil { return nil , err } if o . dryRun { return nil , errors . New ( "no dry-run prowjob clientset is supported in dry-run mode" ) } return o . prowJobClientset , nil }
1562	func ( o * ExperimentalKubernetesOptions ) ProwJobClient ( namespace string , dryRun bool ) ( prowJobClient prowv1 . ProwJobInterface , err error ) { if err := o . resolve ( dryRun ) ; err != nil { return nil , err } if o . dryRun { return kube . NewDryRunProwJobClient ( o . DeckURI ) , nil } return o . prowJobClientset . ProwV1 ( ) . ProwJobs ( namespace ) , nil }
1563	func ( o * ExperimentalKubernetesOptions ) InfrastructureClusterClient ( dryRun bool ) ( kubernetesClient kubernetes . Interface , err error ) { if err := o . resolve ( dryRun ) ; err != nil { return nil , err } if o . dryRun { return nil , errors . New ( "no dry-run kubernetes client is supported in dry-run mode" ) } return o . kubernetesClientsByContext [ kube . InClusterContext ] , nil }
1564	func ( o * ExperimentalKubernetesOptions ) BuildClusterClients ( namespace string , dryRun bool ) ( buildClusterClients map [ string ] corev1 . PodInterface , err error ) { if err := o . resolve ( dryRun ) ; err != nil { return nil , err } if o . dryRun { return nil , errors . New ( "no dry-run pod client is supported for build clusters in dry-run mode" ) } buildClients := map [ string ] corev1 . PodInterface { } for context , client := range o . kubernetesClientsByContext { buildClients [ context ] = client . CoreV1 ( ) . Pods ( namespace ) } return buildClients , nil }
1565	func ( a * ActiveState ) Age ( t time . Time ) time . Duration { return t . Sub ( a . startTime ) }
1566	func ( a * ActiveState ) ReceiveEvent ( eventName , label string , t time . Time ) ( State , bool ) { if a . exit . Match ( eventName , label ) { return & InactiveState { entry : a . exit . Opposite ( ) , } , true } return a , false }
1567	func ( i * InactiveState ) ReceiveEvent ( eventName , label string , t time . Time ) ( State , bool ) { if i . entry . Match ( eventName , label ) { return & ActiveState { startTime : t , exit : i . entry . Opposite ( ) , } , true } return i , false }
1568	func ( m * MultiState ) Active ( ) bool { for _ , state := range m . states { if ! state . Active ( ) { return false } } return true }
1569	func ( m * MultiState ) Age ( t time . Time ) time . Duration { minAge := time . Duration ( 1 << 63 - 1 ) for _ , state := range m . states { stateAge := state . Age ( t ) if stateAge < minAge { minAge = stateAge } } return minAge }
1570	func ( m * MultiState ) ReceiveEvent ( eventName , label string , t time . Time ) ( State , bool ) { oneChanged := false for i := range m . states { state , changed := m . states [ i ] . ReceiveEvent ( eventName , label , t ) if changed { oneChanged = true } m . states [ i ] = state } return m , oneChanged }
1571	func ( v * version ) ProwJobs ( ) ProwJobInformer { return & prowJobInformer { factory : v . factory , namespace : v . namespace , tweakListOptions : v . tweakListOptions } }
1572	func ItemToResourcesConfig ( i Item ) ( ResourcesConfig , error ) { conf , ok := i . ( ResourcesConfig ) if ! ok { return ResourcesConfig { } , fmt . Errorf ( "cannot construct Resource from received object %v" , i ) } return conf , nil }
1573	func ( t TypeToResources ) Copy ( ) TypeToResources { n := TypeToResources { } for k , v := range t { n [ k ] = v } return n }
1574	func MakeCommand ( ) * cobra . Command { flags := & flags { } cmd := & cobra . Command { Use : "aggregate [files...]" , Short : "Aggregates multiple Go coverage files." , Long : `Given multiple Go coverage files from identical binaries recorded in"count" or "atomic" mode, produces a new Go coverage file in the same modethat counts how many of those coverage profiles hit a block at least once.` , Run : func ( cmd * cobra . Command , args [ ] string ) { run ( flags , cmd , args ) } , } cmd . Flags ( ) . StringVarP ( & flags . OutputFile , "output" , "o" , "-" , "output file" ) return cmd }
1575	func ( c * Controller ) incrementNumPendingJobs ( job string ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . pendingJobs [ job ] ++ }
1576	func ( c * Controller ) setPreviousReportState ( pj prowapi . ProwJob ) error { latestPJ , err := c . kc . GetProwJob ( pj . ObjectMeta . Name ) if err != nil { return err } if latestPJ . Status . PrevReportStates == nil { latestPJ . Status . PrevReportStates = map [ string ] prowapi . ProwJobState { } } latestPJ . Status . PrevReportStates [ reporter . GitHubReporterName ] = latestPJ . Status . State _ , err = c . kc . ReplaceProwJob ( latestPJ . ObjectMeta . Name , latestPJ ) return err }
1577	func ( c * Controller ) SyncMetrics ( ) { c . pjLock . RLock ( ) defer c . pjLock . RUnlock ( ) kube . GatherProwJobMetrics ( c . pjs ) }
1578	func DumpProfile ( profiles [ ] * cover . Profile , writer io . Writer ) error { if len ( profiles ) == 0 { return errors . New ( "can't write an empty profile" ) } if _ , err := io . WriteString ( writer , "mode: " + profiles [ 0 ] . Mode + "\n" ) ; \n err != nil { return err } for _ , profile := range profiles { for _ , block := range profile . Blocks { if _ , err := fmt . Fprintf ( writer , "%s:%d.%d,%d.%d %d %d\n" , \n , profile . FileName , block . StartLine , block . StartCol , block . EndLine , block . EndCol , block . NumStmt ) ; block . Count err != nil } } }
1579	func blocksEqual ( a cover . ProfileBlock , b cover . ProfileBlock ) bool { return a . StartCol == b . StartCol && a . StartLine == b . StartLine && a . EndCol == b . EndCol && a . EndLine == b . EndLine && a . NumStmt == b . NumStmt }
1580	func NewProwJobInformer ( client versioned . Interface , namespace string , resyncPeriod time . Duration , indexers cache . Indexers ) cache . SharedIndexInformer { return NewFilteredProwJobInformer ( client , namespace , resyncPeriod , indexers , nil ) }
1581	func NewFilteredProwJobInformer ( client versioned . Interface , namespace string , resyncPeriod time . Duration , indexers cache . Indexers , tweakListOptions internalinterfaces . TweakListOptionsFunc ) cache . SharedIndexInformer { return cache . NewSharedIndexInformer ( & cache . ListWatch { ListFunc : func ( options metav1 . ListOptions ) ( runtime . Object , error ) { if tweakListOptions != nil { tweakListOptions ( & options ) } return client . ProwV1 ( ) . ProwJobs ( namespace ) . List ( options ) } , WatchFunc : func ( options metav1 . ListOptions ) ( watch . Interface , error ) { if tweakListOptions != nil { tweakListOptions ( & options ) } return client . ProwV1 ( ) . ProwJobs ( namespace ) . Watch ( options ) } , } , & prowjobsv1 . ProwJob { } , resyncPeriod , indexers , ) }
1582	func New ( ja * jobs . JobAgent , cfg config . Getter , c * storage . Client , ctx context . Context ) * Spyglass { return & Spyglass { JobAgent : ja , config : cfg , PodLogArtifactFetcher : NewPodLogArtifactFetcher ( ja ) , GCSArtifactFetcher : NewGCSArtifactFetcher ( c ) , testgrid : & TestGrid { conf : cfg , client : c , ctx : ctx , } , } }
1583	func ( s * Spyglass ) Lenses ( matchCache map [ string ] [ ] string ) [ ] lenses . Lens { ls := [ ] lenses . Lens { } for lensName , matches := range matchCache { if len ( matches ) == 0 { continue } lens , err := lenses . GetLens ( lensName ) if err != nil { logrus . WithField ( "lensName" , lens ) . WithError ( err ) . Error ( "Could not find artifact lens" ) } else { ls = append ( ls , lens ) } } sort . Slice ( ls , func ( i , j int ) bool { iconf := ls [ i ] . Config ( ) jconf := ls [ j ] . Config ( ) iname := iconf . Name jname := jconf . Name pi := iconf . Priority pj := jconf . Priority if pi == pj { return iname < jname } return pi < pj } ) return ls }
1584	func ( s * Spyglass ) JobPath ( src string ) ( string , error ) { src = strings . TrimSuffix ( src , "/" ) keyType , key , err := splitSrc ( src ) if err != nil { return "" , fmt . Errorf ( "error parsing src: %v" , src ) } split := strings . Split ( key , "/" ) switch keyType { case gcsKeyType : if len ( split ) < 4 { return "" , fmt . Errorf ( "invalid key %s: expected <bucket-name>/<log-type>/.../<job-name>/<build-id>" , key ) } bktName := split [ 0 ] logType := split [ 1 ] jobName := split [ len ( split ) - 2 ] if logType == gcs . NonPRLogs { return path . Dir ( key ) , nil } else if logType == gcs . PRLogs { return path . Join ( bktName , gcs . PRLogs , "directory" , jobName ) , nil } return "" , fmt . Errorf ( "unrecognized GCS key: %s" , key ) case prowKeyType : if len ( split ) < 2 { return "" , fmt . Errorf ( "invalid key %s: expected <job-name>/<build-id>" , key ) } jobName := split [ 0 ] buildID := split [ 1 ] job , err := s . jobAgent . GetProwJob ( jobName , buildID ) if err != nil { return "" , fmt . Errorf ( "failed to get prow job from src %q: %v" , key , err ) } if job . Spec . DecorationConfig == nil { return "" , fmt . Errorf ( "failed to locate GCS upload bucket for %s: job is undecorated" , jobName ) } if job . Spec . DecorationConfig . GCSConfiguration == nil { return "" , fmt . Errorf ( "failed to locate GCS upload bucket for %s: missing GCS configuration" , jobName ) } bktName := job . Spec . DecorationConfig . GCSConfiguration . Bucket if job . Spec . Type == prowapi . PresubmitJob { return path . Join ( bktName , gcs . PRLogs , "directory" , jobName ) , nil } return path . Join ( bktName , gcs . NonPRLogs , jobName ) , nil default : return "" , fmt . Errorf ( "unrecognized key type for src: %v" , src ) } }
1585	func ( s * Spyglass ) RunPath ( src string ) ( string , error ) { src = strings . TrimSuffix ( src , "/" ) keyType , key , err := splitSrc ( src ) if err != nil { return "" , fmt . Errorf ( "error parsing src: %v" , src ) } switch keyType { case gcsKeyType : return key , nil case prowKeyType : return s . prowToGCS ( key ) default : return "" , fmt . Errorf ( "unrecognized key type for src: %v" , src ) } }
1586	func ( sg * Spyglass ) ExtraLinks ( src string ) ( [ ] ExtraLink , error ) { artifacts , err := sg . FetchArtifacts ( src , "" , 1000000 , [ ] string { "started.json" } ) if err != nil || len ( artifacts ) == 0 { logrus . WithError ( err ) . Debugf ( "Failed to find started.json while looking for extra links." ) return nil , nil } content , err := artifacts [ 0 ] . ReadAll ( ) if err != nil { return nil , err } started := metadata . Started { } if err := json . Unmarshal ( content , & started ) ; err != nil { return nil , err } links , ok := started . Metadata . Meta ( "links" ) if ! ok { return nil , nil } extraLinks := make ( [ ] ExtraLink , 0 , len ( * links ) ) for _ , name := range links . Keys ( ) { m , ok := links . Meta ( name ) if ! ok { logrus . Debugf ( "Got bad link key %q from %s, but that should be impossible." , name , artifacts [ 0 ] . CanonicalLink ( ) ) continue } s := m . Strings ( ) link := ExtraLink { Name : name , URL : s [ "url" ] , Description : s [ "description" ] , } if link . URL == "" || link . Name == "" { continue } extraLinks = append ( extraLinks , link ) } return extraLinks , nil }
1587	func ( s * Server ) needDemux ( eventType , srcRepo string ) [ ] plugins . ExternalPlugin { var matching [ ] plugins . ExternalPlugin srcOrg := strings . Split ( srcRepo , "/" ) [ 0 ] for repo , plugins := range s . Plugins . Config ( ) . ExternalPlugins { if repo != srcRepo && repo != srcOrg { continue } for _ , p := range plugins { if len ( p . Events ) == 0 { matching = append ( matching , p ) } else { for _ , et := range p . Events { if et != eventType { continue } matching = append ( matching , p ) break } } } } return matching }
1588	func ( s * Server ) demuxExternal ( l * logrus . Entry , externalPlugins [ ] plugins . ExternalPlugin , payload [ ] byte , h http . Header ) { h . Set ( "User-Agent" , "ProwHook" ) for _ , p := range externalPlugins { s . wg . Add ( 1 ) go func ( p plugins . ExternalPlugin ) { defer s . wg . Done ( ) if err := s . dispatch ( p . Endpoint , payload , h ) ; err != nil { l . WithError ( err ) . WithField ( "external-plugin" , p . Name ) . Error ( "Error dispatching event to external plugin." ) } else { l . WithField ( "external-plugin" , p . Name ) . Info ( "Dispatched event to external plugin" ) } } ( p ) } }
1589	func ( s * Server ) dispatch ( endpoint string , payload [ ] byte , h http . Header ) error { req , err := http . NewRequest ( http . MethodPost , endpoint , bytes . NewBuffer ( payload ) ) if err != nil { return err } req . Header = h resp , err := s . do ( req ) if err != nil { return err } defer resp . Body . Close ( ) rb , err := ioutil . ReadAll ( resp . Body ) if err != nil { return err } if resp . StatusCode < 200 || resp . StatusCode > 299 { return fmt . Errorf ( "response has status %q and body %q" , resp . Status , string ( rb ) ) } return nil }
1590	func ( s * StatePlugin ) AddFlags ( cmd * cobra . Command ) { cmd . Flags ( ) . StringVar ( & s . desc , "state" , "" , "Description of the state (eg: `opened,!merged,labeled:cool`)" ) cmd . Flags ( ) . IntSliceVar ( & s . percentiles , "percentiles" , [ ] int { } , "Age percentiles for state" ) }
1591	func ( s * StatePlugin ) CheckFlags ( ) error { s . states = NewBundledStates ( s . desc ) return nil }
1592	func ( s * StatePlugin ) ReceiveIssueEvent ( event sql . IssueEvent ) [ ] Point { label := "" if event . Label != nil { label = * event . Label } if ! s . states . ReceiveEvent ( event . IssueID , event . Event , label , event . EventCreatedAt ) { return nil } total , sum := s . states . Total ( event . EventCreatedAt ) values := map [ string ] interface { } { "count" : total , "sum" : int ( sum ) , } for _ , percentile := range s . percentiles { values [ fmt . Sprintf ( "%d%%" , percentile ) ] = int ( s . states . Percentile ( event . EventCreatedAt , percentile ) ) } return [ ] Point { { Values : values , Date : event . EventCreatedAt , } , } }
1593	func Load ( prowConfig , jobConfig string ) ( c * Config , err error ) { defer func ( ) { if r := recover ( ) ; r != nil { c , err = nil , fmt . Errorf ( "panic loading config: %v" , r ) } } ( ) c , err = loadConfig ( prowConfig , jobConfig ) if err != nil { return nil , err } if err := c . finalizeJobConfig ( ) ; err != nil { return nil , err } if err := c . validateComponentConfig ( ) ; err != nil { return nil , err } if err := c . validateJobConfig ( ) ; err != nil { return nil , err } return c , nil }
1594	func loadConfig ( prowConfig , jobConfig string ) ( * Config , error ) { stat , err := os . Stat ( prowConfig ) if err != nil { return nil , err } if stat . IsDir ( ) { return nil , fmt . Errorf ( "prowConfig cannot be a dir - %s" , prowConfig ) } var nc Config if err := yamlToConfig ( prowConfig , & nc ) ; err != nil { return nil , err } if err := parseProwConfig ( & nc ) ; err != nil { return nil , err } if jobConfig == "" { return & nc , nil } stat , err = os . Stat ( jobConfig ) if err != nil { return nil , err } if ! stat . IsDir ( ) { var jc JobConfig if err := yamlToConfig ( jobConfig , & jc ) ; err != nil { return nil , err } if err := nc . mergeJobConfig ( jc ) ; err != nil { return nil , err } return & nc , nil } uniqueBasenames := sets . String { } err = filepath . Walk ( jobConfig , func ( path string , info os . FileInfo , err error ) error { if err != nil { logrus . WithError ( err ) . Errorf ( "walking path %q." , path ) return nil } if strings . HasPrefix ( info . Name ( ) , ".." ) { if info . IsDir ( ) { return filepath . SkipDir } return nil } if filepath . Ext ( path ) != ".yaml" && filepath . Ext ( path ) != ".yml" { return nil } if info . IsDir ( ) { return nil } base := filepath . Base ( path ) if uniqueBasenames . Has ( base ) { return fmt . Errorf ( "duplicated basename is not allowed: %s" , base ) } uniqueBasenames . Insert ( base ) var subConfig JobConfig if err := yamlToConfig ( path , & subConfig ) ; err != nil { return err } return nc . mergeJobConfig ( subConfig ) } ) if err != nil { return nil , err } return & nc , nil }
1595	func yamlToConfig ( path string , nc interface { } ) error { b , err := ReadFileMaybeGZIP ( path ) if err != nil { return fmt . Errorf ( "error reading %s: %v" , path , err ) } if err := yaml . Unmarshal ( b , nc ) ; err != nil { return fmt . Errorf ( "error unmarshaling %s: %v" , path , err ) } var jc * JobConfig switch v := nc . ( type ) { case * JobConfig : jc = v case * Config : jc = & v . JobConfig } for rep := range jc . Presubmits { var fix func ( * Presubmit ) fix = func ( job * Presubmit ) { job . SourcePath = path } for i := range jc . Presubmits [ rep ] { fix ( & jc . Presubmits [ rep ] [ i ] ) } } for rep := range jc . Postsubmits { var fix func ( * Postsubmit ) fix = func ( job * Postsubmit ) { job . SourcePath = path } for i := range jc . Postsubmits [ rep ] { fix ( & jc . Postsubmits [ rep ] [ i ] ) } } var fix func ( * Periodic ) fix = func ( job * Periodic ) { job . SourcePath = path } for i := range jc . Periodics { fix ( & jc . Periodics [ i ] ) } return nil }
1596	func ReadFileMaybeGZIP ( path string ) ( [ ] byte , error ) { b , err := ioutil . ReadFile ( path ) if err != nil { return nil , err } if ! bytes . HasPrefix ( b , [ ] byte ( "\x1F\x8B" ) ) \x1F \x8B { return b , nil } gzipReader , err := gzip . NewReader ( bytes . NewBuffer ( b ) ) }
1597	func ( c * Config ) finalizeJobConfig ( ) error { if c . decorationRequested ( ) { if c . Plank . DefaultDecorationConfig == nil { return errors . New ( "no default decoration config provided for plank" ) } if c . Plank . DefaultDecorationConfig . UtilityImages == nil { return errors . New ( "no default decoration image pull specs provided for plank" ) } if c . Plank . DefaultDecorationConfig . GCSConfiguration == nil { return errors . New ( "no default GCS decoration config provided for plank" ) } if c . Plank . DefaultDecorationConfig . GCSCredentialsSecret == "" { return errors . New ( "no default GCS credentials secret provided for plank" ) } for _ , vs := range c . Presubmits { for i := range vs { setPresubmitDecorationDefaults ( c , & vs [ i ] ) } } for _ , js := range c . Postsubmits { for i := range js { setPostsubmitDecorationDefaults ( c , & js [ i ] ) } } for i := range c . Periodics { setPeriodicDecorationDefaults ( c , & c . Periodics [ i ] ) } } for _ , vs := range c . Presubmits { c . defaultPresubmitFields ( vs ) if err := SetPresubmitRegexes ( vs ) ; err != nil { return fmt . Errorf ( "could not set regex: %v" , err ) } } for _ , js := range c . Postsubmits { c . defaultPostsubmitFields ( js ) if err := SetPostsubmitRegexes ( js ) ; err != nil { return fmt . Errorf ( "could not set regex: %v" , err ) } } c . defaultPeriodicFields ( c . Periodics ) for _ , v := range c . AllPresubmits ( nil ) { if err := resolvePresets ( v . Name , v . Labels , v . Spec , v . BuildSpec , c . Presets ) ; err != nil { return err } } for _ , v := range c . AllPostsubmits ( nil ) { if err := resolvePresets ( v . Name , v . Labels , v . Spec , v . BuildSpec , c . Presets ) ; err != nil { return err } } for _ , v := range c . AllPeriodics ( ) { if err := resolvePresets ( v . Name , v . Labels , v . Spec , v . BuildSpec , c . Presets ) ; err != nil { return err } } return nil }
1598	func ( c * Config ) validateComponentConfig ( ) error { if c . Plank . JobURLPrefix != "" && c . Plank . JobURLPrefixConfig [ "*" ] != "" { return errors . New ( `Planks job_url_prefix must be unset when job_url_prefix_config["*"] is set. The former is deprecated, use the latter` ) } for k , v := range c . Plank . JobURLPrefixConfig { if _ , err := url . Parse ( v ) ; err != nil { return fmt . Errorf ( `Invalid value for Planks job_url_prefix_config["%s"]: %v` , k , err ) } } if c . SlackReporter != nil { if err := c . SlackReporter . DefaultAndValidate ( ) ; err != nil { return fmt . Errorf ( "failed to validate slackreporter config: %v" , err ) } } return nil }
1599	func ConfigPath ( value string ) string { if value != "" { return value } logrus . Warningf ( "defaulting to %s until 15 July 2019, please migrate" , DefaultConfigPath ) return DefaultConfigPath }
1600	func ValidateController ( c * Controller ) error { urlTmpl , err := template . New ( "JobURL" ) . Parse ( c . JobURLTemplateString ) if err != nil { return fmt . Errorf ( "parsing template: %v" , err ) } c . JobURLTemplate = urlTmpl reportTmpl , err := template . New ( "Report" ) . Parse ( c . ReportTemplateString ) if err != nil { return fmt . Errorf ( "parsing template: %v" , err ) } c . ReportTemplate = reportTmpl if c . MaxConcurrency < 0 { return fmt . Errorf ( "controller has invalid max_concurrency (%d), it needs to be a non-negative number" , c . MaxConcurrency ) } if c . MaxGoroutines == 0 { c . MaxGoroutines = 20 } if c . MaxGoroutines <= 0 { return fmt . Errorf ( "controller has invalid max_goroutines (%d), it needs to be a positive number" , c . MaxGoroutines ) } return nil }
1601	func ( c * ProwConfig ) defaultJobBase ( base * JobBase ) { if base . Agent == "" { base . Agent = string ( prowapi . KubernetesAgent ) } if base . Namespace == nil || * base . Namespace == "" { s := c . PodNamespace base . Namespace = & s } if base . Cluster == "" { base . Cluster = kube . DefaultClusterAlias } }
1602	func SetPresubmitRegexes ( js [ ] Presubmit ) error { for i , j := range js { if re , err := regexp . Compile ( j . Trigger ) ; err == nil { js [ i ] . re = re } else { return fmt . Errorf ( "could not compile trigger regex for %s: %v" , j . Name , err ) } if ! js [ i ] . re . MatchString ( j . RerunCommand ) { return fmt . Errorf ( "for job %s, rerun command \"%s\" does not match trigger \"%s\"" , \" , \" , \" ) } \" j . Name j . RerunCommand j . Trigger b , err := setBrancherRegexes ( j . Brancher ) if err != nil { return fmt . Errorf ( "could not set branch regexes for %s: %v" , j . Name , err ) } } js [ i ] . Brancher = b }
1603	func setBrancherRegexes ( br Brancher ) ( Brancher , error ) { if len ( br . Branches ) > 0 { if re , err := regexp . Compile ( strings . Join ( br . Branches , `|` ) ) ; err == nil { br . re = re } else { return br , fmt . Errorf ( "could not compile positive branch regex: %v" , err ) } } if len ( br . SkipBranches ) > 0 { if re , err := regexp . Compile ( strings . Join ( br . SkipBranches , `|` ) ) ; err == nil { br . reSkip = re } else { return br , fmt . Errorf ( "could not compile negative branch regex: %v" , err ) } } return br , nil }
1604	func SetPostsubmitRegexes ( ps [ ] Postsubmit ) error { for i , j := range ps { b , err := setBrancherRegexes ( j . Brancher ) if err != nil { return fmt . Errorf ( "could not set branch regexes for %s: %v" , j . Name , err ) } ps [ i ] . Brancher = b c , err := setChangeRegexes ( j . RegexpChangeMatcher ) if err != nil { return fmt . Errorf ( "could not set change regexes for %s: %v" , j . Name , err ) } ps [ i ] . RegexpChangeMatcher = c } return nil }
1605	func ( lens Lens ) Body ( artifacts [ ] lenses . Artifact , resourceDir string , data string ) string { var buf bytes . Buffer type MetadataViewData struct { Status string StartTime time . Time FinishedTime time . Time Elapsed time . Duration Metadata map [ string ] string } metadataViewData := MetadataViewData { Status : "Pending" } started := gcs . Started { } finished := gcs . Finished { } for _ , a := range artifacts { read , err := a . ReadAll ( ) if err != nil { logrus . WithError ( err ) . Error ( "Failed reading from artifact." ) } if a . JobPath ( ) == "started.json" { if err = json . Unmarshal ( read , & started ) ; err != nil { logrus . WithError ( err ) . Error ( "Error unmarshaling started.json" ) } metadataViewData . StartTime = time . Unix ( started . Timestamp , 0 ) } else if a . JobPath ( ) == "finished.json" { if err = json . Unmarshal ( read , & finished ) ; err != nil { logrus . WithError ( err ) . Error ( "Error unmarshaling finished.json" ) } if finished . Timestamp != nil { metadataViewData . FinishedTime = time . Unix ( * finished . Timestamp , 0 ) } metadataViewData . Status = finished . Result } } if ! metadataViewData . StartTime . IsZero ( ) { if metadataViewData . FinishedTime . IsZero ( ) { metadataViewData . Elapsed = time . Now ( ) . Sub ( metadataViewData . StartTime ) } else { metadataViewData . Elapsed = metadataViewData . FinishedTime . Sub ( metadataViewData . StartTime ) } metadataViewData . Elapsed = metadataViewData . Elapsed . Round ( time . Second ) } metadataViewData . Metadata = map [ string ] string { "node" : started . Node } metadatas := [ ] metadata . Metadata { started . Metadata , finished . Metadata } for _ , m := range metadatas { for k , v := range m { if s , ok := v . ( string ) ; ok && v != "" { metadataViewData . Metadata [ k ] = s } } } metadataTemplate , err := template . ParseFiles ( filepath . Join ( resourceDir , "template.html" ) ) if err != nil { return fmt . Sprintf ( "Failed to load template: %v" , err ) } if err := metadataTemplate . ExecuteTemplate ( & buf , "body" , metadataViewData ) ; err != nil { logrus . WithError ( err ) . Error ( "Error executing template." ) } return buf . String ( ) }
1606	func NewBoskosHandler ( r * ranch . Ranch ) * http . ServeMux { mux := http . NewServeMux ( ) mux . Handle ( "/" , handleDefault ( r ) ) mux . Handle ( "/acquire" , handleAcquire ( r ) ) mux . Handle ( "/acquirebystate" , handleAcquireByState ( r ) ) mux . Handle ( "/release" , handleRelease ( r ) ) mux . Handle ( "/reset" , handleReset ( r ) ) mux . Handle ( "/update" , handleUpdate ( r ) ) mux . Handle ( "/metric" , handleMetric ( r ) ) return mux }
1607	func ErrorToStatus ( err error ) int { switch err . ( type ) { default : return http . StatusInternalServerError case * ranch . OwnerNotMatch : return http . StatusUnauthorized case * ranch . ResourceNotFound : return http . StatusNotFound case * ranch . ResourceTypeNotFound : return http . StatusNotFound case * ranch . StateNotMatch : return http . StatusConflict } }
1608	func DumpProfile ( destination string , profile [ ] * cover . Profile ) error { var output io . Writer if destination == "-" { output = os . Stdout } else { f , err := os . Create ( destination ) if err != nil { return fmt . Errorf ( "failed to open %s: %v" , destination , err ) } defer f . Close ( ) output = f } err := cov . DumpProfile ( profile , output ) if err != nil { return fmt . Errorf ( "failed to dump profile: %v" , err ) } return nil }
1609	func LoadProfile ( origin string ) ( [ ] * cover . Profile , error ) { filename := origin if origin == "-" { tf , err := ioutil . TempFile ( "" , "" ) if err != nil { return nil , fmt . Errorf ( "failed to create temp file: %v" , err ) } defer tf . Close ( ) defer os . Remove ( tf . Name ( ) ) if _ , err := io . Copy ( tf , os . Stdin ) ; err != nil { return nil , fmt . Errorf ( "failed to copy stdin to temp file: %v" , err ) } filename = tf . Name ( ) } return cover . ParseProfiles ( filename ) }
1610	func NewClient ( ) ( * Client , error ) { g , err := exec . LookPath ( "git" ) if err != nil { return nil , err } t , err := ioutil . TempDir ( "" , "git" ) if err != nil { return nil , err } return & Client { logger : logrus . WithField ( "client" , "git" ) , dir : t , git : g , base : fmt . Sprintf ( "https://%s" , github ) , repoLocks : make ( map [ string ] * sync . Mutex ) , } , nil }
1611	func ( c * Client ) SetCredentials ( user string , tokenGenerator func ( ) [ ] byte ) { c . credLock . Lock ( ) defer c . credLock . Unlock ( ) c . user = user c . tokenGenerator = tokenGenerator }
1612	func ( r * Repo ) Checkout ( commitlike string ) error { r . logger . Infof ( "Checkout %s." , commitlike ) co := r . gitCommand ( "checkout" , commitlike ) if b , err := co . CombinedOutput ( ) ; err != nil { return fmt . Errorf ( "error checking out %s: %v. output: %s" , commitlike , err , string ( b ) ) } return nil }
1613	func ( r * Repo ) CheckoutNewBranch ( branch string ) error { r . logger . Infof ( "Create and checkout %s." , branch ) co := r . gitCommand ( "checkout" , "-b" , branch ) if b , err := co . CombinedOutput ( ) ; err != nil { return fmt . Errorf ( "error checking out %s: %v. output: %s" , branch , err , string ( b ) ) } return nil }
1614	func ( r * Repo ) Merge ( commitlike string ) ( bool , error ) { r . logger . Infof ( "Merging %s." , commitlike ) co := r . gitCommand ( "merge" , "--no-ff" , "--no-stat" , "-m merge" , commitlike ) b , err := co . CombinedOutput ( ) if err == nil { return true , nil } r . logger . WithError ( err ) . Infof ( "Merge failed with output: %s" , string ( b ) ) if b , err := r . gitCommand ( "merge" , "--abort" ) . CombinedOutput ( ) ; err != nil { return false , fmt . Errorf ( "error aborting merge for commitlike %s: %v. output: %s" , commitlike , err , string ( b ) ) } return false , nil }
1615	func ( r * Repo ) CheckoutPullRequest ( number int ) error { r . logger . Infof ( "Fetching and checking out %s#%d." , r . repo , number ) if b , err := retryCmd ( r . logger , r . Dir , r . git , "fetch" , r . base + "/" + r . repo , fmt . Sprintf ( "pull/%d/head:pull%d" , number , number ) ) ; err != nil { return fmt . Errorf ( "git fetch failed for PR %d: %v. output: %s" , number , err , string ( b ) ) } co := r . gitCommand ( "checkout" , fmt . Sprintf ( "pull%d" , number ) ) if b , err := co . CombinedOutput ( ) ; err != nil { return fmt . Errorf ( "git checkout failed for PR %d: %v. output: %s" , number , err , string ( b ) ) } return nil }
1616	func ( r * Repo ) Config ( key , value string ) error { r . logger . Infof ( "Running git config %s %s" , key , value ) if b , err := r . gitCommand ( "config" , key , value ) . CombinedOutput ( ) ; err != nil { return fmt . Errorf ( "git config %s %s failed: %v. output: %s" , key , value , err , string ( b ) ) } return nil }
1617	func retryCmd ( l * logrus . Entry , dir , cmd string , arg ... string ) ( [ ] byte , error ) { var b [ ] byte var err error sleepyTime := time . Second for i := 0 ; i < 3 ; i ++ { c := exec . Command ( cmd , arg ... ) c . Dir = dir b , err = c . CombinedOutput ( ) if err != nil { l . Warningf ( "Running %s %v returned error %v with output %s." , cmd , arg , err , string ( b ) ) time . Sleep ( sleepyTime ) sleepyTime *= 2 continue } break } return b , err }
1618	func LabelsAndAnnotationsForSpec ( spec prowapi . ProwJobSpec , extraLabels , extraAnnotations map [ string ] string ) ( map [ string ] string , map [ string ] string ) { jobNameForLabel := spec . Job if len ( jobNameForLabel ) > validation . LabelValueMaxLength { jobNameForLabel = strings . TrimRight ( spec . Job [ : validation . LabelValueMaxLength ] , ".-" ) logrus . WithFields ( logrus . Fields { "job" : spec . Job , "key" : kube . ProwJobAnnotation , "value" : spec . Job , "truncated" : jobNameForLabel , } ) . Info ( "Cannot use full job name, will truncate." ) } labels := map [ string ] string { kube . CreatedByProw : "true" , kube . ProwJobTypeLabel : string ( spec . Type ) , kube . ProwJobAnnotation : jobNameForLabel , } if spec . Type != prowapi . PeriodicJob && spec . Refs != nil { labels [ kube . OrgLabel ] = spec . Refs . Org labels [ kube . RepoLabel ] = spec . Refs . Repo if len ( spec . Refs . Pulls ) > 0 { labels [ kube . PullLabel ] = strconv . Itoa ( spec . Refs . Pulls [ 0 ] . Number ) } } for k , v := range extraLabels { labels [ k ] = v } for key , value := range labels { if errs := validation . IsValidLabelValue ( value ) ; len ( errs ) > 0 { base := filepath . Base ( value ) if errs := validation . IsValidLabelValue ( base ) ; len ( errs ) == 0 { labels [ key ] = base continue } logrus . WithFields ( logrus . Fields { "key" : key , "value" : value , "errors" : errs , } ) . Warn ( "Removing invalid label" ) delete ( labels , key ) } } annotations := map [ string ] string { kube . ProwJobAnnotation : spec . Job , } for k , v := range extraAnnotations { annotations [ k ] = v } return labels , annotations }
1619	func ProwJobToPod ( pj prowapi . ProwJob , buildID string ) ( * coreapi . Pod , error ) { if pj . Spec . PodSpec == nil { return nil , fmt . Errorf ( "prowjob %q lacks a pod spec" , pj . Name ) } rawEnv , err := downwardapi . EnvForSpec ( downwardapi . NewJobSpec ( pj . Spec , buildID , pj . Name ) ) if err != nil { return nil , err } spec := pj . Spec . PodSpec . DeepCopy ( ) spec . RestartPolicy = "Never" spec . Containers [ 0 ] . Name = kube . TestContainerName if spec . AutomountServiceAccountToken == nil && spec . ServiceAccountName == "" { myFalse := false spec . AutomountServiceAccountToken = & myFalse } if pj . Spec . DecorationConfig == nil { spec . Containers [ 0 ] . Env = append ( spec . Containers [ 0 ] . Env , kubeEnv ( rawEnv ) ... ) } else { if err := decorate ( spec , & pj , rawEnv ) ; err != nil { return nil , fmt . Errorf ( "error decorating podspec: %v" , err ) } } podLabels , annotations := LabelsAndAnnotationsForJob ( pj ) return & coreapi . Pod { ObjectMeta : metav1 . ObjectMeta { Name : pj . ObjectMeta . Name , Labels : podLabels , Annotations : annotations , } , Spec : * spec , } , nil }
1620	func CloneLogPath ( logMount coreapi . VolumeMount ) string { return filepath . Join ( logMount . MountPath , cloneLogPath ) }
1621	func cloneEnv ( opt clonerefs . Options ) ( [ ] coreapi . EnvVar , error ) { cloneConfigEnv , err := clonerefs . Encode ( opt ) if err != nil { return nil , err } return kubeEnv ( map [ string ] string { clonerefs . JSONConfigEnvVar : cloneConfigEnv } ) , nil }
1622	func sshVolume ( secret string ) ( coreapi . Volume , coreapi . VolumeMount ) { var sshKeyMode int32 = 0400 name := strings . Join ( [ ] string { "ssh-keys" , secret } , "-" ) mountPath := path . Join ( "/secrets/ssh" , secret ) v := coreapi . Volume { Name : name , VolumeSource : coreapi . VolumeSource { Secret : & coreapi . SecretVolumeSource { SecretName : secret , DefaultMode : & sshKeyMode , } , } , } vm := coreapi . VolumeMount { Name : name , MountPath : mountPath , ReadOnly : true , } return v , vm }
1623	func InjectEntrypoint ( c * coreapi . Container , timeout , gracePeriod time . Duration , prefix , previousMarker string , exitZero bool , log , tools coreapi . VolumeMount ) ( * wrapper . Options , error ) { wrapperOptions := & wrapper . Options { Args : append ( c . Command , c . Args ... ) , ProcessLog : processLog ( log , prefix ) , MarkerFile : markerFile ( log , prefix ) , MetadataFile : metadataFile ( log , prefix ) , } entrypointConfigEnv , err := entrypoint . Encode ( entrypoint . Options { ArtifactDir : artifactsDir ( log ) , GracePeriod : gracePeriod , Options : wrapperOptions , Timeout : timeout , AlwaysZero : exitZero , PreviousMarker : previousMarker , } ) if err != nil { return nil , err } c . Command = [ ] string { entrypointLocation ( tools ) } c . Args = nil c . Env = append ( c . Env , kubeEnv ( map [ string ] string { entrypoint . JSONConfigEnvVar : entrypointConfigEnv } ) ... ) c . VolumeMounts = append ( c . VolumeMounts , log , tools ) return wrapperOptions , nil }
1624	func PlaceEntrypoint ( image string , toolsMount coreapi . VolumeMount ) coreapi . Container { return coreapi . Container { Name : "place-entrypoint" , Image : image , Command : [ ] string { "/bin/cp" } , Args : [ ] string { "/entrypoint" , entrypointLocation ( toolsMount ) } , VolumeMounts : [ ] coreapi . VolumeMount { toolsMount } , } }
1625	func kubeEnv ( environment map [ string ] string ) [ ] coreapi . EnvVar { var keys [ ] string for key := range environment { keys = append ( keys , key ) } sort . Strings ( keys ) var kubeEnvironment [ ] coreapi . EnvVar for _ , key := range keys { kubeEnvironment = append ( kubeEnvironment , coreapi . EnvVar { Name : key , Value : environment [ key ] , } ) } return kubeEnvironment }
1626	func ( o * KubernetesOptions ) Client ( namespace string , dryRun bool ) ( * kube . Client , error ) { if dryRun { return kube . NewFakeClient ( o . DeckURI ) , nil } if o . cluster == "" { return kube . NewClientInCluster ( namespace ) } return kube . NewClientFromFile ( o . cluster , namespace ) }
1627	func handle ( gc githubClient , le * logrus . Entry , e * event ) error { needsLabel := e . draft || titleRegex . MatchString ( e . title ) if needsLabel && ! e . hasLabel { if err := gc . AddLabel ( e . org , e . repo , e . number , labels . WorkInProgress ) ; err != nil { le . Warnf ( "error while adding Label %q: %v" , labels . WorkInProgress , err ) return err } } else if ! needsLabel && e . hasLabel { if err := gc . RemoveLabel ( e . org , e . repo , e . number , labels . WorkInProgress ) ; err != nil { le . Warnf ( "error while removing Label %q: %v" , labels . WorkInProgress , err ) return err } } return nil }
1628	func SendHook ( address , eventType string , payload , hmac [ ] byte ) error { req , err := http . NewRequest ( http . MethodPost , address , bytes . NewBuffer ( payload ) ) if err != nil { return err } req . Header . Set ( "X-GitHub-Event" , eventType ) req . Header . Set ( "X-GitHub-Delivery" , "GUID" ) req . Header . Set ( "X-Hub-Signature" , github . PayloadSignature ( payload , hmac ) ) req . Header . Set ( "content-type" , "application/json" ) c := & http . Client { } resp , err := c . Do ( req ) if err != nil { return err } defer resp . Body . Close ( ) rb , err := ioutil . ReadAll ( resp . Body ) if err != nil { return err } if resp . StatusCode != 200 { return fmt . Errorf ( "response from hook has status %d and body %s" , resp . StatusCode , string ( bytes . TrimSpace ( rb ) ) ) } return nil }
1629	func janitorClean ( resource * common . Resource , flags [ ] string ) error { args := append ( [ ] string { fmt . Sprintf ( "--%s=%s" , format ( resource . Type ) , resource . Name ) } , flags ... ) logrus . Infof ( "executing janitor: %s %s" , * janitorPath , strings . Join ( args , " " ) ) cmd := exec . Command ( * janitorPath , args ... ) b , err := cmd . CombinedOutput ( ) if err != nil { logrus . WithError ( err ) . Errorf ( "failed to clean up project %s, error info: %s" , resource . Name , string ( b ) ) } else { logrus . Tracef ( "output from janitor: %s" , string ( b ) ) logrus . Infof ( "successfully cleaned up resource %s" , resource . Name ) } return err }
1630	func janitor ( c boskosClient , buffer <- chan * common . Resource , fn clean , flags [ ] string ) { for { resource := <- buffer dest := common . Free if err := fn ( resource , flags ) ; err != nil { logrus . WithError ( err ) . Errorf ( "%s failed!" , * janitorPath ) dest = common . Dirty } if err := c . ReleaseOne ( resource . Name , dest ) ; err != nil { logrus . WithError ( err ) . Error ( "boskos release failed!" ) } } }
1631	func ( s * PullServer ) Run ( ctx context . Context ) error { configEvent := make ( chan config . Delta , 2 ) s . Subscriber . ConfigAgent . Subscribe ( configEvent ) var err error defer func ( ) { if err != nil { logrus . WithError ( ctx . Err ( ) ) . Error ( "Pull server shutting down" ) } logrus . Warn ( "Pull server shutting down" ) } ( ) currentConfig := s . Subscriber . ConfigAgent . Config ( ) . PubSubSubscriptions errGroup , derivedCtx , err := s . handlePulls ( ctx , currentConfig ) if err != nil { return err } for { select { case <- ctx . Done ( ) : return ctx . Err ( ) case <- derivedCtx . Done ( ) : err = errGroup . Wait ( ) return err case event := <- configEvent : newConfig := event . After . PubSubSubscriptions logrus . Info ( "Received new config" ) if ! reflect . DeepEqual ( currentConfig , newConfig ) { logrus . Warn ( "New config found, reloading pull Server" ) errGroup . Wait ( ) errGroup , derivedCtx , err = s . handlePulls ( ctx , newConfig ) if err != nil { return err } currentConfig = newConfig } } } }
1632	func specToStarted ( spec * downwardapi . JobSpec , mainRefSHA string ) gcs . Started { started := gcs . Started { Timestamp : time . Now ( ) . Unix ( ) , RepoVersion : downwardapi . GetRevisionFromSpec ( spec ) , } if mainRefSHA != "" { started . RepoVersion = mainRefSHA } if spec . Refs != nil && len ( spec . Refs . Pulls ) > 0 { started . Pull = strconv . Itoa ( spec . Refs . Pulls [ 0 ] . Number ) } started . Repos = map [ string ] string { } if spec . Refs != nil { started . Repos [ spec . Refs . Org + "/" + spec . Refs . Repo ] = spec . Refs . String ( ) } for _ , ref := range spec . ExtraRefs { started . Repos [ ref . Org + "/" + ref . Repo ] = ref . String ( ) } return started }
1633	func ( o Options ) Run ( ) error { spec , err := downwardapi . ResolveSpecFromEnv ( ) if err != nil { return fmt . Errorf ( "could not resolve job spec: %v" , err ) } uploadTargets := map [ string ] gcs . UploadFunc { } var failed bool var mainRefSHA string if o . Log != "" { if failed , mainRefSHA , err = processCloneLog ( o . Log , uploadTargets ) ; err != nil { return err } } started := specToStarted ( spec , mainRefSHA ) startedData , err := json . Marshal ( & started ) if err != nil { return fmt . Errorf ( "could not marshal starting data: %v" , err ) } uploadTargets [ "started.json" ] = gcs . DataUpload ( bytes . NewReader ( startedData ) ) if err := o . Options . Run ( spec , uploadTargets ) ; err != nil { return fmt . Errorf ( "failed to upload to GCS: %v" , err ) } if failed { return errors . New ( "cloning the appropriate refs failed" ) } return nil }
1634	func hasPRChanged ( pr github . PullRequestEvent ) bool { switch pr . Action { case github . PullRequestActionOpened : return true case github . PullRequestActionReopened : return true case github . PullRequestActionSynchronize : return true default : return false } }
1635	func UpdateIssues ( db * gorm . DB , client ClientInterface ) { latest , err := findLatestIssueUpdate ( db , client . RepositoryName ( ) ) if err != nil { glog . Error ( "Failed to find last issue update: " , err ) return } c := make ( chan * github . Issue , 200 ) go client . FetchIssues ( latest , c ) for issue := range c { issueOrm , err := NewIssue ( issue , client . RepositoryName ( ) ) if err != nil { glog . Error ( "Can't create issue:" , err ) continue } if db . Create ( issueOrm ) . Error != nil { db . Delete ( sql . Label { } , "issue_id = ? AND repository = ?" , issueOrm . ID , client . RepositoryName ( ) ) db . Delete ( sql . Assignee { } , "issue_id = ? AND repository = ?" , issueOrm . ID , client . RepositoryName ( ) ) if err := db . Save ( issueOrm ) . Error ; err != nil { glog . Error ( "Failed to update database issue: " , err ) } } UpdateComments ( * issue . Number , issueOrm . IsPR , db , client ) UpdateIssueEvents ( * issue . Number , db , client ) } }
1636	func handleReviewEvent ( pc plugins . Agent , re github . ReviewEvent ) error { return handleReview ( pc . Logger , pc . GitHubClient , pc . OwnersClient , pc . Config . GitHubOptions , pc . PluginConfig , & re , ) }
1637	func findAssociatedIssue ( body , org string ) ( int , error ) { associatedIssueRegex , err := regexp . Compile ( fmt . Sprintf ( associatedIssueRegexFormat , org ) ) if err != nil { return 0 , err } match := associatedIssueRegex . FindStringSubmatch ( body ) if len ( match ) == 0 { return 0 , nil } v , err := strconv . Atoi ( match [ 1 ] ) if err != nil { return 0 , err } return v , nil }
1638	func optionsForRepo ( config * plugins . Configuration , org , repo string ) * plugins . Approve { fullName := fmt . Sprintf ( "%s/%s" , org , repo ) a := func ( ) * plugins . Approve { for _ , c := range config . Approve { if ! strInSlice ( fullName , c . Repos ) { continue } return & c } for _ , c := range config . Approve { if ! strInSlice ( org , c . Repos ) { continue } return & c } return & plugins . Approve { } } ( ) if a . DeprecatedImplicitSelfApprove == nil && a . RequireSelfApproval == nil && config . UseDeprecatedSelfApprove { no := false a . DeprecatedImplicitSelfApprove = & no } if a . DeprecatedReviewActsAsApprove == nil && a . IgnoreReviewState == nil && config . UseDeprecatedReviewApprove { no := false a . DeprecatedReviewActsAsApprove = & no } return a }
1639	func localOnlyMain ( cfg config . Getter , o options , mux * http . ServeMux ) * http . ServeMux { mux . Handle ( "/github-login" , gziphandler . GzipHandler ( handleSimpleTemplate ( o , cfg , "github-login.html" , nil ) ) ) if o . spyglass { initSpyglass ( cfg , o , mux , nil ) } return mux }
1640	func ( covList * CoverageList ) summarize ( ) { covList . NumCoveredStmts = 0 covList . NumAllStmts = 0 for _ , item := range covList . Group { covList . NumCoveredStmts += item . NumCoveredStmts covList . NumAllStmts += item . NumAllStmts } }
1641	func ( covList * CoverageList ) Subset ( prefix string ) * CoverageList { s := newCoverageList ( "Filtered Summary" ) for _ , c := range covList . Group { if strings . HasPrefix ( c . Name , prefix ) { covList . Group = append ( covList . Group , c ) } } return s }
1642	func ( covList CoverageList ) ListDirectories ( ) [ ] string { dirSet := map [ string ] bool { } for _ , cov := range covList . Group { dirSet [ path . Dir ( cov . Name ) ] = true } var result [ ] string for key := range dirSet { result = append ( result , key ) } return result }
1643	func readRequest ( r io . Reader , contentType string ) ( * admissionapi . AdmissionRequest , error ) { if contentType != contentTypeJSON { return nil , fmt . Errorf ( "Content-Type=%s, expected %s" , contentType , contentTypeJSON ) } if r == nil { return nil , fmt . Errorf ( "no body" ) } body , err := ioutil . ReadAll ( r ) if err != nil { return nil , fmt . Errorf ( "read body: %v" , err ) } var ar admissionapi . AdmissionReview deserializer := codecs . UniversalDeserializer ( ) if _ , _ , err := deserializer . Decode ( body , nil , & ar ) ; err != nil { return nil , fmt . Errorf ( "decode body: %v" , err ) } return ar . Request , nil }
1644	func handle ( w http . ResponseWriter , r * http . Request ) { req , err := readRequest ( r . Body , r . Header . Get ( "Content-Type" ) ) if err != nil { logrus . WithError ( err ) . Error ( "read" ) } if err := writeResponse ( * req , w , onlyUpdateStatus ) ; err != nil { logrus . WithError ( err ) . Error ( "write" ) } }
1645	func writeResponse ( ar admissionapi . AdmissionRequest , w io . Writer , decide decider ) error { response , err := decide ( ar ) if err != nil { logrus . WithError ( err ) . Error ( "failed decision" ) response = & admissionapi . AdmissionResponse { Result : & meta . Status { Message : err . Error ( ) , } , } } var result admissionapi . AdmissionReview result . Response = response result . Response . UID = ar . UID out , err := json . Marshal ( result ) if err != nil { return fmt . Errorf ( "encode response: %v" , err ) } if _ , err := w . Write ( out ) ; err != nil { return fmt . Errorf ( "write response: %v" , err ) } return nil }
1646	func onlyUpdateStatus ( req admissionapi . AdmissionRequest ) ( * admissionapi . AdmissionResponse , error ) { logger := logrus . WithFields ( logrus . Fields { "resource" : req . Resource , "subresource" : req . SubResource , "name" : req . Name , "namespace" : req . Namespace , "operation" : req . Operation , } ) if req . SubResource == "status" { logrus . Info ( "accept status update" ) return & allow , nil } var new prowjobv1 . ProwJob if _ , _ , err := codecs . UniversalDeserializer ( ) . Decode ( req . Object . Raw , nil , & new ) ; err != nil { return nil , fmt . Errorf ( "decode new: %v" , err ) } var old prowjobv1 . ProwJob if _ , _ , err := codecs . UniversalDeserializer ( ) . Decode ( req . OldObject . Raw , nil , & old ) ; err != nil { return nil , fmt . Errorf ( "decode old: %v" , err ) } if equality . Semantic . DeepEqual ( old . Spec , new . Spec ) { logrus . Info ( "accept update with equivalent spec" ) return & allow , nil } logger . Info ( "reject" ) return & reject , nil }
1647	func convertSuiteMeta ( suiteMeta gcs . SuitesMeta ) resultstore . Suite { out := resultstore . Suite { Name : path . Base ( suiteMeta . Path ) , Files : [ ] resultstore . File { { ContentType : "text/xml" , ID : resultstore . UUID ( ) , URL : suiteMeta . Path , } , } , } for _ , suite := range suiteMeta . Suites . Suites { child := resultstore . Suite { Name : suite . Name , Duration : dur ( suite . Time ) , } switch { case suite . Failures > 0 && suite . Tests >= suite . Failures : child . Failures = append ( child . Failures , resultstore . Failure { Message : fmt . Sprintf ( "%d out of %d tests failed (%.1f%% passing)" , suite . Failures , suite . Tests , float64 ( suite . Tests - suite . Failures ) * 100.0 / float64 ( suite . Tests ) ) , } ) case suite . Failures > 0 : child . Failures = append ( child . Failures , resultstore . Failure { Message : fmt . Sprintf ( "%d tests failed" , suite . Failures ) , } ) } for _ , result := range suite . Results { name , tags := stripTags ( result . Name ) class := result . ClassName if class == "" { class = strings . Join ( tags , " " ) } else { class += " " + strings . Join ( tags , " " ) } c := resultstore . Case { Name : name , Class : class , Duration : dur ( result . Time ) , Result : resultstore . Completed , } const max = 5000 msg := result . Message ( max ) switch { case result . Failure != nil : if msg == "" { msg = "unknown failure" } c . Failures = append ( c . Failures , resultstore . Failure { Message : msg , } ) case result . Skipped != nil : c . Result = resultstore . Skipped if msg != "" { c . Errors = append ( c . Errors , resultstore . Error { Message : msg , } ) } } child . Cases = append ( child . Cases , c ) if c . Duration > child . Duration { child . Duration = c . Duration } } if child . Duration > out . Duration { out . Duration = child . Duration } out . Suites = append ( out . Suites , child ) } return out }
1648	func NewHealth ( ) * Health { healthMux := http . NewServeMux ( ) healthMux . HandleFunc ( "/healthz" , func ( w http . ResponseWriter , r * http . Request ) { fmt . Fprint ( w , "OK" ) } ) go func ( ) { logrus . WithError ( http . ListenAndServe ( ":" + strconv . Itoa ( healthPort ) , healthMux ) ) . Fatal ( "ListenAndServe returned." ) } ( ) return & Health { healthMux : healthMux , } }
1649	func ( h * Health ) ServeReady ( ) { h . healthMux . HandleFunc ( "/healthz/ready" , func ( w http . ResponseWriter , r * http . Request ) { fmt . Fprint ( w , "OK" ) } ) }
1650	func NewController ( ghcSync , ghcStatus * github . Client , prowJobClient prowv1 . ProwJobInterface , cfg config . Getter , gc * git . Client , maxRecordsPerPool int , opener io . Opener , historyURI , statusURI string , logger * logrus . Entry ) ( * Controller , error ) { if logger == nil { logger = logrus . NewEntry ( logrus . StandardLogger ( ) ) } hist , err := history . New ( maxRecordsPerPool , opener , historyURI ) if err != nil { return nil , fmt . Errorf ( "error initializing history client from %q: %v" , historyURI , err ) } sc := & statusController { logger : logger . WithField ( "controller" , "status-update" ) , ghc : ghcStatus , config : cfg , newPoolPending : make ( chan bool , 1 ) , shutDown : make ( chan bool ) , opener : opener , path : statusURI , } go sc . run ( ) return & Controller { logger : logger . WithField ( "controller" , "sync" ) , ghc : ghcSync , prowJobClient : prowJobClient , config : cfg , gc : gc , sc : sc , changedFiles : & changedFilesAgent { ghc : ghcSync , nextChangeCache : make ( map [ changeCacheKey ] [ ] string ) , } , History : hist , } , nil }
1651	func newExpectedContext ( c string ) Context { return Context { Context : githubql . String ( c ) , State : githubql . StatusStateExpected , Description : githubql . String ( "" ) , } }
1652	func contextsToStrings ( contexts [ ] Context ) [ ] string { var names [ ] string for _ , c := range contexts { names = append ( names , string ( c . Context ) ) } return names }
1653	func ( c * Controller ) filterSubpools ( goroutines int , raw map [ string ] * subpool ) map [ string ] * subpool { filtered := make ( map [ string ] * subpool ) var lock sync . Mutex subpoolsInParallel ( goroutines , raw , func ( sp * subpool ) { if err := c . initSubpoolData ( sp ) ; err != nil { sp . log . WithError ( err ) . Error ( "Error initializing subpool." ) return } key := poolKey ( sp . org , sp . repo , sp . branch ) if spFiltered := filterSubpool ( c . ghc , sp ) ; spFiltered != nil { sp . log . WithField ( "key" , key ) . WithField ( "pool" , spFiltered ) . Debug ( "filtered sub-pool" ) lock . Lock ( ) filtered [ key ] = spFiltered lock . Unlock ( ) } else { sp . log . WithField ( "key" , key ) . WithField ( "pool" , spFiltered ) . Debug ( "filtering sub-pool removed all PRs" ) } } , ) return filtered }
1654	func filterSubpool ( ghc githubClient , sp * subpool ) * subpool { var toKeep [ ] PullRequest for _ , pr := range sp . prs { if ! filterPR ( ghc , sp , & pr ) { toKeep = append ( toKeep , pr ) } } if len ( toKeep ) == 0 { return nil } sp . prs = toKeep return sp }
1655	func poolPRMap ( subpoolMap map [ string ] * subpool ) map [ string ] PullRequest { prs := make ( map [ string ] PullRequest ) for _ , sp := range subpoolMap { for _ , pr := range sp . prs { prs [ prKey ( & pr ) ] = pr } } return prs }
1656	func unsuccessfulContexts ( contexts [ ] Context , cc contextChecker , log * logrus . Entry ) [ ] Context { var failed [ ] Context for _ , ctx := range contexts { if string ( ctx . Context ) == statusContext { continue } if cc . IsOptional ( string ( ctx . Context ) ) { continue } if ctx . State != githubql . StatusStateSuccess { failed = append ( failed , ctx ) } } for _ , c := range cc . MissingRequiredContexts ( contextsToStrings ( contexts ) ) { failed = append ( failed , newExpectedContext ( c ) ) } log . Debugf ( "from %d total contexts (%v) found %d failing contexts: %v" , len ( contexts ) , contextsToStrings ( contexts ) , len ( failed ) , contextsToStrings ( failed ) ) return failed }
1657	func accumulate ( presubmits map [ int ] [ ] config . Presubmit , prs [ ] PullRequest , pjs [ ] prowapi . ProwJob , log * logrus . Entry ) ( successes , pendings , nones [ ] PullRequest ) { for _ , pr := range prs { psStates := make ( map [ string ] simpleState ) for _ , pj := range pjs { if pj . Spec . Type != prowapi . PresubmitJob { continue } if pj . Spec . Refs . Pulls [ 0 ] . Number != int ( pr . Number ) { continue } if pj . Spec . Refs . Pulls [ 0 ] . SHA != string ( pr . HeadRefOID ) { continue } name := pj . Spec . Context oldState := psStates [ name ] newState := toSimpleState ( pj . Status . State ) if oldState == failureState || oldState == "" { psStates [ name ] = newState } else if oldState == pendingState && newState == successState { psStates [ name ] = successState } } overallState := successState for _ , ps := range presubmits [ int ( pr . Number ) ] { if s , ok := psStates [ ps . Context ] ; ! ok { overallState = failureState log . WithFields ( pr . logFields ( ) ) . Debugf ( "missing presubmit %s" , ps . Context ) break } else if s == failureState { overallState = failureState log . WithFields ( pr . logFields ( ) ) . Debugf ( "presubmit %s not passing" , ps . Context ) break } else if s == pendingState { log . WithFields ( pr . logFields ( ) ) . Debugf ( "presubmit %s pending" , ps . Context ) overallState = pendingState } } if overallState == successState { successes = append ( successes , pr ) } else if overallState == pendingState { pendings = append ( pendings , pr ) } else { nones = append ( nones , pr ) } } return }
1658	func tryMerge ( mergeFunc func ( ) error ) ( bool , error ) { var err error const maxRetries = 3 backoff := time . Second * 4 for retry := 0 ; retry < maxRetries ; retry ++ { if err = mergeFunc ( ) ; err == nil { return true , nil } if _ , ok := err . ( github . ModifiedHeadError ) ; ok { return true , fmt . Errorf ( "PR was modified: %v" , err ) } else if _ , ok = err . ( github . UnmergablePRBaseChangedError ) ; ok { err = fmt . Errorf ( "base branch was modified: %v" , err ) if retry + 1 < maxRetries { sleep ( backoff ) backoff *= 2 } } else if _ , ok = err . ( github . UnauthorizedToPushError ) ; ok { return false , fmt . Errorf ( "branch needs to be configured to allow this robot to push: %v" , err ) } else if _ , ok = err . ( github . MergeCommitsForbiddenError ) ; ok { return false , fmt . Errorf ( "Tide needs to be configured to use the 'rebase' merge method for this repo or the repo needs to allow merge commits: %v" , err ) } else if _ , ok = err . ( github . UnmergablePRError ) ; ok { return true , fmt . Errorf ( "PR is unmergable. Do the Tide merge requirements match the GitHub settings for the repo? %v" , err ) } else { return true , err } } return true , err }
1659	func ( c * changedFilesAgent ) prChanges ( pr * PullRequest ) config . ChangedFilesProvider { return func ( ) ( [ ] string , error ) { cacheKey := changeCacheKey { org : string ( pr . Repository . Owner . Login ) , repo : string ( pr . Repository . Name ) , number : int ( pr . Number ) , sha : string ( pr . HeadRefOID ) , } c . RLock ( ) changedFiles , ok := c . changeCache [ cacheKey ] if ok { c . RUnlock ( ) c . Lock ( ) c . nextChangeCache [ cacheKey ] = changedFiles c . Unlock ( ) return changedFiles , nil } if changedFiles , ok = c . nextChangeCache [ cacheKey ] ; ok { c . RUnlock ( ) return changedFiles , nil } c . RUnlock ( ) changes , err := c . ghc . GetPullRequestChanges ( string ( pr . Repository . Owner . Login ) , string ( pr . Repository . Name ) , int ( pr . Number ) , ) if err != nil { return nil , fmt . Errorf ( "error getting PR changes for #%d: %v" , int ( pr . Number ) , err ) } changedFiles = make ( [ ] string , 0 , len ( changes ) ) for _ , change := range changes { changedFiles = append ( changedFiles , change . Filename ) } c . Lock ( ) c . nextChangeCache [ cacheKey ] = changedFiles c . Unlock ( ) return changedFiles , nil } }
1660	func ( c * changedFilesAgent ) prune ( ) { c . Lock ( ) defer c . Unlock ( ) c . changeCache = c . nextChangeCache c . nextChangeCache = make ( map [ changeCacheKey ] [ ] string ) }
1661	func ( c * Controller ) dividePool ( pool map [ string ] PullRequest , pjs [ ] prowapi . ProwJob ) ( map [ string ] * subpool , error ) { sps := make ( map [ string ] * subpool ) for _ , pr := range pool { org := string ( pr . Repository . Owner . Login ) repo := string ( pr . Repository . Name ) branch := string ( pr . BaseRef . Name ) branchRef := string ( pr . BaseRef . Prefix ) + string ( pr . BaseRef . Name ) fn := poolKey ( org , repo , branch ) if sps [ fn ] == nil { sha , err := c . ghc . GetRef ( org , repo , strings . TrimPrefix ( branchRef , "refs/" ) ) if err != nil { return nil , err } sps [ fn ] = & subpool { log : c . logger . WithFields ( logrus . Fields { "org" : org , "repo" : repo , "branch" : branch , "base-sha" : sha , } ) , org : org , repo : repo , branch : branch , sha : sha , } } sps [ fn ] . prs = append ( sps [ fn ] . prs , pr ) } for _ , pj := range pjs { if pj . Spec . Type != prowapi . PresubmitJob && pj . Spec . Type != prowapi . BatchJob { continue } fn := poolKey ( pj . Spec . Refs . Org , pj . Spec . Refs . Repo , pj . Spec . Refs . BaseRef ) if sps [ fn ] == nil || pj . Spec . Refs . BaseSHA != sps [ fn ] . sha { continue } sps [ fn ] . pjs = append ( sps [ fn ] . pjs , pj ) } return sps , nil }
1662	func AggregateProfiles ( profiles [ ] [ ] * cover . Profile ) ( [ ] * cover . Profile , error ) { setProfiles := make ( [ ] [ ] * cover . Profile , 0 , len ( profiles ) ) for _ , p := range profiles { c := countToBoolean ( p ) setProfiles = append ( setProfiles , c ) } aggregateProfiles , err := MergeMultipleProfiles ( setProfiles ) if err != nil { return nil , err } return aggregateProfiles , nil }
1663	func countToBoolean ( profile [ ] * cover . Profile ) [ ] * cover . Profile { setProfile := make ( [ ] * cover . Profile , 0 , len ( profile ) ) for _ , p := range profile { pc := deepCopyProfile ( * p ) for i := range pc . Blocks { if pc . Blocks [ i ] . Count > 0 { pc . Blocks [ i ] . Count = 1 } } setProfile = append ( setProfile , & pc ) } return setProfile }
1664	func NewStorage ( r storage . PersistenceLayer , storage string ) ( * Storage , error ) { s := & Storage { resources : r , } if storage != "" { var data struct { Resources [ ] common . Resource } buf , err := ioutil . ReadFile ( storage ) if err == nil { logrus . Infof ( "Current state: %s." , string ( buf ) ) err = json . Unmarshal ( buf , & data ) if err != nil { return nil , err } } else if ! os . IsNotExist ( err ) { return nil , err } logrus . Info ( "Before adding resource loop" ) for _ , res := range data . Resources { if err := s . AddResource ( res ) ; err != nil { logrus . WithError ( err ) . Errorf ( "Failed Adding Resources: %s - %s." , res . Name , res . State ) } logrus . Infof ( "Successfully Added Resources: %s - %s." , res . Name , res . State ) } } return s , nil }
1665	func ( s * Storage ) AddResource ( resource common . Resource ) error { return s . resources . Add ( resource ) }
1666	func ( s * Storage ) DeleteResource ( name string ) error { return s . resources . Delete ( name ) }
1667	func ( s * Storage ) UpdateResource ( resource common . Resource ) error { return s . resources . Update ( resource ) }
1668	func ( s * Storage ) GetResource ( name string ) ( common . Resource , error ) { i , err := s . resources . Get ( name ) if err != nil { return common . Resource { } , err } var res common . Resource res , err = common . ItemToResource ( i ) if err != nil { return common . Resource { } , err } return res , nil }
1669	func ( s * Storage ) GetResources ( ) ( [ ] common . Resource , error ) { var resources [ ] common . Resource items , err := s . resources . List ( ) if err != nil { return resources , err } for _ , i := range items { var res common . Resource res , err = common . ItemToResource ( i ) if err != nil { return nil , err } resources = append ( resources , res ) } sort . Stable ( common . ResourceByUpdateTime ( resources ) ) return resources , nil }
1670	func ( s * Storage ) SyncResources ( data [ ] common . Resource ) error { s . resourcesLock . Lock ( ) defer s . resourcesLock . Unlock ( ) resources , err := s . GetResources ( ) if err != nil { logrus . WithError ( err ) . Error ( "cannot find resources" ) return err } var finalError error valid := 0 for _ , res := range resources { if res . Owner != "" { resources [ valid ] = res valid ++ continue } toDelete := true for _ , newRes := range data { if res . Name == newRes . Name { resources [ valid ] = res valid ++ toDelete = false break } } if toDelete { logrus . Infof ( "Deleting resource %s" , res . Name ) if err := s . DeleteResource ( res . Name ) ; err != nil { finalError = multierror . Append ( finalError , err ) logrus . WithError ( err ) . Errorf ( "unable to delete resource %s" , res . Name ) } } } resources = resources [ : valid ] for _ , p := range data { found := false for idx := range resources { exist := resources [ idx ] if p . Name == exist . Name { found = true logrus . Infof ( "Keeping resource %s" , p . Name ) break } } if ! found { if p . State == "" { p . State = common . Free } logrus . Infof ( "Adding resource %s" , p . Name ) resources = append ( resources , p ) if err := s . AddResource ( p ) ; err != nil { logrus . WithError ( err ) . Errorf ( "unable to add resource %s" , p . Name ) finalError = multierror . Append ( finalError , err ) } } } return finalError }
1671	func ParseConfig ( configPath string ) ( [ ] common . Resource , error ) { file , err := ioutil . ReadFile ( configPath ) if err != nil { return nil , err } var data common . BoskosConfig err = yaml . Unmarshal ( file , & data ) if err != nil { return nil , err } var resources [ ] common . Resource for _ , entry := range data . Resources { resources = append ( resources , common . NewResourcesFromConfig ( entry ) ... ) } return resources , nil }
1672	func problemsInFiles ( r * git . Repo , files map [ string ] string ) ( map [ string ] [ ] string , error ) { problems := make ( map [ string ] [ ] string ) for f := range files { src , err := ioutil . ReadFile ( filepath . Join ( r . Dir , f ) ) if err != nil { return nil , err } content , err := build . Parse ( f , src ) if err != nil { return nil , fmt . Errorf ( "parsing as Bazel file %v" , err ) } beforeRewrite := build . Format ( content ) var info build . RewriteInfo build . Rewrite ( content , & info ) ndata := build . Format ( content ) if ! bytes . Equal ( src , ndata ) && ! bytes . Equal ( src , beforeRewrite ) { problems [ f ] = uniqProblems ( info . Log ) } } return problems , nil }
1673	func NewPodLogArtifact ( jobName string , buildID string , sizeLimit int64 , ja jobAgent ) ( * PodLogArtifact , error ) { if jobName == "" { return nil , errInsufficientJobInfo } if buildID == "" { return nil , errInsufficientJobInfo } if sizeLimit < 0 { return nil , errInvalidSizeLimit } return & PodLogArtifact { name : jobName , buildID : buildID , sizeLimit : sizeLimit , jobAgent : ja , } , nil }
1674	func ( a * PodLogArtifact ) CanonicalLink ( ) string { q := url . Values { "job" : [ ] string { a . name } , "id" : [ ] string { a . buildID } , } u := url . URL { Path : "/log" , RawQuery : q . Encode ( ) , } return u . String ( ) }
1675	func ( a * PodLogArtifact ) ReadAt ( p [ ] byte , off int64 ) ( n int , err error ) { logs , err := a . jobAgent . GetJobLog ( a . name , a . buildID ) if err != nil { return 0 , fmt . Errorf ( "error getting pod log: %v" , err ) } r := bytes . NewReader ( logs ) readBytes , err := r . ReadAt ( p , off ) if err == io . EOF { return readBytes , io . EOF } if err != nil { return 0 , fmt . Errorf ( "error reading pod logs: %v" , err ) } return readBytes , nil }
1676	func ( a * PodLogArtifact ) ReadAll ( ) ( [ ] byte , error ) { size , err := a . Size ( ) if err != nil { return nil , fmt . Errorf ( "error getting pod log size: %v" , err ) } if size > a . sizeLimit { return nil , lenses . ErrFileTooLarge } logs , err := a . jobAgent . GetJobLog ( a . name , a . buildID ) if err != nil { return nil , fmt . Errorf ( "error getting pod log: %v" , err ) } return logs , nil }
1677	func ( a * PodLogArtifact ) ReadAtMost ( n int64 ) ( [ ] byte , error ) { logs , err := a . jobAgent . GetJobLog ( a . name , a . buildID ) if err != nil { return nil , fmt . Errorf ( "error getting pod log: %v" , err ) } reader := bytes . NewReader ( logs ) var byteCount int64 var p [ ] byte for byteCount < n { b , err := reader . ReadByte ( ) if err == io . EOF { return p , io . EOF } if err != nil { return nil , fmt . Errorf ( "error reading pod log: %v" , err ) } p = append ( p , b ) byteCount ++ } return p , nil }
1678	func ( a * PodLogArtifact ) ReadTail ( n int64 ) ( [ ] byte , error ) { logs , err := a . jobAgent . GetJobLog ( a . name , a . buildID ) if err != nil { return nil , fmt . Errorf ( "error getting pod log tail: %v" , err ) } size := int64 ( len ( logs ) ) var off int64 if n > size { off = 0 } else { off = size - n } p := make ( [ ] byte , n ) readBytes , err := bytes . NewReader ( logs ) . ReadAt ( p , off ) if err != nil && err != io . EOF { return nil , fmt . Errorf ( "error reading pod log tail: %v" , err ) } return p [ : readBytes ] , nil }
1679	func newProblems ( cs [ ] github . ReviewComment , ps map [ string ] map [ int ] lint . Problem ) map [ string ] map [ int ] lint . Problem { res := make ( map [ string ] map [ int ] lint . Problem ) for f , ls := range ps { res [ f ] = make ( map [ int ] lint . Problem ) for l , p := range ls { res [ f ] [ l ] = p } } for _ , c := range cs { if c . Position == nil { continue } if ! strings . Contains ( c . Body , commentTag ) { continue } delete ( res [ c . Path ] , * c . Position ) } return res }
1680	func problemsInFiles ( r * git . Repo , files map [ string ] string ) ( map [ string ] map [ int ] lint . Problem , [ ] github . DraftReviewComment ) { problems := make ( map [ string ] map [ int ] lint . Problem ) var lintErrorComments [ ] github . DraftReviewComment l := new ( lint . Linter ) for f , patch := range files { problems [ f ] = make ( map [ int ] lint . Problem ) src , err := ioutil . ReadFile ( filepath . Join ( r . Dir , f ) ) if err != nil { lintErrorComments = append ( lintErrorComments , github . DraftReviewComment { Path : f , Body : fmt . Sprintf ( "%v" , err ) , } ) } ps , err := l . Lint ( f , src ) if err != nil { errLineIndexStart := strings . LastIndex ( err . Error ( ) , f ) + len ( f ) reNumber := regexp . MustCompile ( `:([0-9]+):` ) matches := reNumber . FindStringSubmatch ( err . Error ( ) [ errLineIndexStart : ] ) newComment := github . DraftReviewComment { Path : f , Body : err . Error ( ) , } if len ( matches ) > 1 { errLineString := matches [ 1 ] errLine , errAtoi := strconv . Atoi ( errLineString ) if errAtoi == nil { newComment . Position = errLine } reTrimError := regexp . MustCompile ( `(:[0-9]+:[0-9]+: )` ) matches = reTrimError . FindStringSubmatch ( err . Error ( ) ) if len ( matches ) > 0 { newComment . Body = err . Error ( ) [ len ( matches [ 0 ] ) + errLineIndexStart : ] } } lintErrorComments = append ( lintErrorComments , newComment ) } al , err := AddedLines ( patch ) if err != nil { lintErrorComments = append ( lintErrorComments , github . DraftReviewComment { Path : f , Body : fmt . Sprintf ( "computing added lines in %s: %v" , f , err ) , } ) } for _ , p := range ps { if pl , ok := al [ p . Position . Line ] ; ok { problems [ f ] [ pl ] = p } } } return problems , lintErrorComments }
1681	func undoPreset ( preset * config . Preset , labels map [ string ] string , pod * coreapi . PodSpec ) { for l , v := range preset . Labels { if v2 , ok := labels [ l ] ; ! ok || v2 != v { return } } removeEnvNames := sets . NewString ( ) for _ , e1 := range preset . Env { removeEnvNames . Insert ( e1 . Name ) } removeVolumeNames := sets . NewString ( ) for _ , volume := range preset . Volumes { removeVolumeNames . Insert ( volume . Name ) } removeVolumeMountNames := sets . NewString ( ) for _ , volumeMount := range preset . VolumeMounts { removeVolumeMountNames . Insert ( volumeMount . Name ) } filteredVolumes := [ ] coreapi . Volume { } for _ , volume := range pod . Volumes { if ! removeVolumeNames . Has ( volume . Name ) { filteredVolumes = append ( filteredVolumes , volume ) } } pod . Volumes = filteredVolumes for i := range pod . Containers { filteredEnv := [ ] coreapi . EnvVar { } for _ , env := range pod . Containers [ i ] . Env { if ! removeEnvNames . Has ( env . Name ) { filteredEnv = append ( filteredEnv , env ) } } pod . Containers [ i ] . Env = filteredEnv filteredVolumeMounts := [ ] coreapi . VolumeMount { } for _ , mount := range pod . Containers [ i ] . VolumeMounts { if ! removeVolumeMountNames . Has ( mount . Name ) { filteredVolumeMounts = append ( filteredVolumeMounts , mount ) } } pod . Containers [ i ] . VolumeMounts = filteredVolumeMounts } }
1682	func undoPresubmitPresets ( presets [ ] config . Preset , presubmit * config . Presubmit ) { if presubmit . Spec == nil { return } for _ , preset := range presets { undoPreset ( & preset , presubmit . Labels , presubmit . Spec ) } }
1683	func yamlBytesStripNulls ( yamlBytes [ ] byte ) [ ] byte { nullRE := regexp . MustCompile ( "(?m)[\n]+^[^\n]+: null$" ) \n }
1684	func monitorDiskAndEvict ( c * diskcache . Cache , interval time . Duration , minPercentBlocksFree , evictUntilPercentBlocksFree float64 , ) { diskRoot := c . DiskRoot ( ) ticker := time . NewTicker ( interval ) for ; true ; <- ticker . C { blocksFree , _ , _ , err := diskutil . GetDiskUsage ( diskRoot ) if err != nil { logrus . WithError ( err ) . Error ( "Failed to get disk usage!" ) continue } logger := logrus . WithFields ( logrus . Fields { "sync-loop" : "MonitorDiskAndEvict" , "blocks-free" : blocksFree , } ) logger . Info ( "tick" ) if blocksFree < minPercentBlocksFree { logger . Warn ( "Eviction triggered" ) files := c . GetEntries ( ) sort . Slice ( files , func ( i , j int ) bool { return files [ i ] . LastAccess . Before ( files [ j ] . LastAccess ) } ) for blocksFree < evictUntilPercentBlocksFree { if len ( files ) < 1 { logger . Fatal ( "Failed to find entries to evict!" ) } var entry diskcache . EntryInfo entry , files = files [ 0 ] , files [ 1 : ] err = c . Delete ( c . PathToKey ( entry . Path ) ) if err != nil { logger . WithError ( err ) . Errorf ( "Error deleting entry at path: %v" , entry . Path ) } else { promMetrics . FilesEvicted . Inc ( ) promMetrics . LastEvictedAccessAge . Set ( time . Now ( ) . Sub ( entry . LastAccess ) . Hours ( ) ) } blocksFree , _ , _ , err = diskutil . GetDiskUsage ( diskRoot ) logger = logrus . WithFields ( logrus . Fields { "sync-loop" : "MonitorDiskAndEvict" , "blocks-free" : blocksFree , } ) if err != nil { logrus . WithError ( err ) . Error ( "Failed to get disk usage!" ) continue } } logger . Info ( "Done evicting" ) } } }
1685	func ( c * orgRepoConfig ) difference ( c2 * orgRepoConfig ) * orgRepoConfig { res := & orgRepoConfig { orgExceptions : make ( map [ string ] sets . String ) , repos : sets . NewString ( ) . Union ( c . repos ) , } for org , excepts1 := range c . orgExceptions { if excepts2 , ok := c2 . orgExceptions [ org ] ; ok { res . repos . Insert ( excepts2 . Difference ( excepts1 ) . UnsortedList ( ) ... ) } else { excepts := sets . NewString ( ) . Union ( excepts1 ) for _ , repo := range c2 . repos . UnsortedList ( ) { if parts := strings . SplitN ( repo , "/" , 2 ) ; len ( parts ) == 2 && parts [ 0 ] == org { excepts . Insert ( repo ) } } res . orgExceptions [ org ] = excepts } } res . repos = res . repos . Difference ( c2 . repos ) for _ , repo := range res . repos . UnsortedList ( ) { if parts := strings . SplitN ( repo , "/" , 2 ) ; len ( parts ) == 2 { if excepts2 , ok := c2 . orgExceptions [ parts [ 0 ] ] ; ok && ! excepts2 . Has ( repo ) { res . repos . Delete ( repo ) } } } return res }
1686	func ( c * orgRepoConfig ) union ( c2 * orgRepoConfig ) * orgRepoConfig { res := & orgRepoConfig { orgExceptions : make ( map [ string ] sets . String ) , repos : sets . NewString ( ) , } for org , excepts1 := range c . orgExceptions { pruned := excepts1 . Difference ( c2 . repos ) if excepts2 , ok := c2 . orgExceptions [ org ] ; ok { res . orgExceptions [ org ] = pruned . Intersection ( excepts2 . Difference ( c . repos ) ) } else { res . orgExceptions [ org ] = pruned } } for org , excepts2 := range c2 . orgExceptions { if _ , exists := res . orgExceptions [ org ] ; ! exists { res . orgExceptions [ org ] = excepts2 . Difference ( c . repos ) } } for _ , repo := range c . repos . Union ( c2 . repos ) . UnsortedList ( ) { parts := strings . SplitN ( repo , "/" , 2 ) if len ( parts ) != 2 { logrus . Warnf ( "org/repo %q is formatted incorrectly" , repo ) continue } if _ , exists := res . orgExceptions [ parts [ 0 ] ] ; ! exists { res . repos . Insert ( repo ) } } return res }
1687	func clearStaleComments ( gc githubClient , log * logrus . Entry , pr * github . PullRequestEvent , prLabels sets . String , comments [ ] github . IssueComment ) error { if prMustFollowRelNoteProcess ( gc , log , pr , prLabels , false ) && ! releaseNoteAlreadyAdded ( prLabels ) { return nil } botName , err := gc . BotName ( ) if err != nil { return err } return gc . DeleteStaleComments ( pr . Repo . Owner . Login , pr . Repo . Name , pr . Number , comments , func ( c github . IssueComment ) bool { return c . User . Login == botName && ( strings . Contains ( c . Body , releaseNoteBody ) || strings . Contains ( c . Body , parentReleaseNoteBody ) ) } , ) }
1688	func determineReleaseNoteLabel ( body string ) string { composedReleaseNote := strings . ToLower ( strings . TrimSpace ( getReleaseNote ( body ) ) ) if composedReleaseNote == "" { return ReleaseNoteLabelNeeded } if noneRe . MatchString ( composedReleaseNote ) { return releaseNoteNone } if strings . Contains ( composedReleaseNote , actionRequiredNote ) { return releaseNoteActionRequired } return releaseNote }
1689	func getReleaseNote ( body string ) string { potentialMatch := noteMatcherRE . FindStringSubmatch ( body ) if potentialMatch == nil { return "" } return strings . TrimSpace ( potentialMatch [ 1 ] ) }
1690	func NewClient ( boskosClient boskosClient ) * Client { return & Client { basic : boskosClient , resources : map [ string ] common . Resource { } , } }
1691	func ( c * Client ) Acquire ( rtype , state , dest string ) ( * common . Resource , error ) { var resourcesToRelease [ ] common . Resource releaseOnFailure := func ( ) { for _ , r := range resourcesToRelease { if err := c . basic . ReleaseOne ( r . Name , common . Dirty ) ; err != nil { logrus . WithError ( err ) . Warningf ( "failed to release resource %s" , r . Name ) } } } res , err := c . basic . Acquire ( rtype , state , dest ) if err != nil { return nil , err } var leasedResources common . LeasedResources if err = res . UserData . Extract ( LeasedResources , & leasedResources ) ; err != nil { if _ , ok := err . ( * common . UserDataNotFound ) ; ! ok { logrus . WithError ( err ) . Errorf ( "cannot parse %s from User Data" , LeasedResources ) return nil , err } } resourcesToRelease = append ( resourcesToRelease , * res ) resources , err := c . basic . AcquireByState ( res . Name , dest , leasedResources ) if err != nil { releaseOnFailure ( ) return nil , err } resourcesToRelease = append ( resourcesToRelease , resources ... ) c . updateResource ( * res ) return res , nil }
1692	func ( c * Client ) ReleaseOne ( name , dest string ) ( allErrors error ) { res , err := c . getResource ( name ) if err != nil { allErrors = err return } resourceNames := [ ] string { name } var leasedResources common . LeasedResources if err := res . UserData . Extract ( LeasedResources , & leasedResources ) ; err != nil { if _ , ok := err . ( * common . UserDataNotFound ) ; ! ok { logrus . WithError ( err ) . Errorf ( "cannot parse %s from User Data" , LeasedResources ) allErrors = multierror . Append ( allErrors , err ) if err := c . basic . ReleaseOne ( name , dest ) ; err != nil { logrus . WithError ( err ) . Warningf ( "failed to release resource %s" , name ) allErrors = multierror . Append ( allErrors , err ) } return } } resourceNames = append ( resourceNames , leasedResources ... ) for _ , n := range resourceNames { if err := c . basic . ReleaseOne ( n , dest ) ; err != nil { logrus . WithError ( err ) . Warningf ( "failed to release resource %s" , n ) allErrors = multierror . Append ( allErrors , err ) } } c . deleteResource ( name ) return }
1693	func ( c * Client ) UpdateAll ( state string ) error { return c . basic . UpdateAll ( state ) }
1694	func GetGitHubClient ( token string ) * github . Client { return github . NewClient ( oauth2 . NewClient ( oauth2 . NoContext , oauth2 . StaticTokenSource ( & oauth2 . Token { AccessToken : token } ) , ) , ) }
1695	func GetUsername ( client * github . Client ) ( string , error ) { user , _ , err := client . Users . Get ( context . Background ( ) , "" ) if err != nil { return "" , err } if user . Login == nil { return "" , errors . New ( "Users.Get(\"\") returned empty login" ) } \" }
1696	func CreateTokenHandler ( tokenStream io . Reader , influxdb * InfluxDB ) ( * TokenHandler , error ) { token , err := ioutil . ReadAll ( tokenStream ) if err != nil { return nil , err } client := GetGitHubClient ( strings . TrimSpace ( string ( token ) ) ) login , err := GetUsername ( client ) if err != nil { return nil , err } return & TokenHandler { gClient : client , login : login , influxdb : influxdb , } , nil }
1697	func CreateTokenHandlers ( tokenFiles [ ] string , influxdb * InfluxDB ) ( [ ] TokenHandler , error ) { tokens := [ ] TokenHandler { } for _ , tokenFile := range tokenFiles { f , err := os . Open ( tokenFile ) if err != nil { return nil , fmt . Errorf ( "Can't open token-file (%s): %s" , tokenFile , err ) } token , err := CreateTokenHandler ( f , influxdb ) if err != nil { return nil , fmt . Errorf ( "Failed to create token (%s): %s" , tokenFile , err ) } tokens = append ( tokens , * token ) } return tokens , nil }
1698	func ( i * jobIndentifier ) String ( ) string { return fmt . Sprintf ( "%s %s/%s#%d" , i . job , i . organization , i . repository , i . pullRequest ) }
1699	func TerminateOlderPresubmitJobs ( pjc prowClient , log * logrus . Entry , pjs [ ] prowapi . ProwJob , cleanup ProwJobResourcesCleanup ) error { dupes := map [ jobIndentifier ] int { } for i , pj := range pjs { if pj . Complete ( ) || pj . Spec . Type != prowapi . PresubmitJob { continue } ji := jobIndentifier { job : pj . Spec . Job , organization : pj . Spec . Refs . Org , repository : pj . Spec . Refs . Repo , pullRequest : pj . Spec . Refs . Pulls [ 0 ] . Number , } prev , ok := dupes [ ji ] if ! ok { dupes [ ji ] = i continue } cancelIndex := i if ( & pjs [ prev ] . Status . StartTime ) . Before ( & pj . Status . StartTime ) { cancelIndex = prev dupes [ ji ] = i } toCancel := pjs [ cancelIndex ] if err := cleanup ( toCancel ) ; err != nil { log . WithError ( err ) . WithFields ( ProwJobFields ( & toCancel ) ) . Warn ( "Cannot clean up job resources" ) } toCancel . SetComplete ( ) prevState := toCancel . Status . State toCancel . Status . State = prowapi . AbortedState log . WithFields ( ProwJobFields ( & toCancel ) ) . WithField ( "from" , prevState ) . WithField ( "to" , toCancel . Status . State ) . Info ( "Transitioning states" ) npj , err := pjc . ReplaceProwJob ( toCancel . ObjectMeta . Name , toCancel ) if err != nil { return err } pjs [ cancelIndex ] = npj } return nil }
1700	func PushMetrics ( component , endpoint string , interval time . Duration ) { sig := make ( chan os . Signal , 1 ) signal . Notify ( sig , os . Interrupt , syscall . SIGTERM ) for { select { case <- time . Tick ( interval ) : if err := push . FromGatherer ( component , push . HostnameGroupingKey ( ) , endpoint , prometheus . DefaultGatherer ) ; err != nil { logrus . WithField ( "component" , component ) . WithError ( err ) . Error ( "Failed to push metrics." ) } case <- sig : logrus . WithField ( "component" , component ) . Infof ( "Metrics pusher shutting down..." ) return } } }
1701	func RateLimiter ( controllerName string ) workqueue . RateLimitingInterface { rl := workqueue . NewMaxOfRateLimiter ( workqueue . NewItemExponentialFailureRateLimiter ( 5 * time . Millisecond , 120 * time . Second ) , & workqueue . BucketRateLimiter { Limiter : rate . NewLimiter ( rate . Limit ( 1000 ) , 50000 ) } , ) return workqueue . NewNamedRateLimitingQueue ( rl , controllerName ) }
1702	func checkExistingStatus ( gc gitHubClient , l * logrus . Entry , org , repo , sha string ) ( string , error ) { statuses , err := gc . ListStatuses ( org , repo , sha ) if err != nil { return "" , fmt . Errorf ( "error listing pull request statuses: %v" , err ) } existingStatus := "" for _ , status := range statuses { if status . Context != dcoContextName { continue } existingStatus = status . State break } l . Debugf ( "Existing DCO status context status is %q" , existingStatus ) return existingStatus , nil }
1703	func checkExistingLabels ( gc gitHubClient , l * logrus . Entry , org , repo string , number int ) ( hasYesLabel , hasNoLabel bool , err error ) { labels , err := gc . GetIssueLabels ( org , repo , number ) if err != nil { return false , false , fmt . Errorf ( "error getting pull request labels: %v" , err ) } for _ , l := range labels { if l . Name == dcoYesLabel { hasYesLabel = true } if l . Name == dcoNoLabel { hasNoLabel = true } } return hasYesLabel , hasNoLabel , nil }
1704	func handle ( gc gitHubClient , cp commentPruner , log * logrus . Entry , org , repo string , pr github . PullRequest , addComment bool ) error { l := log . WithField ( "pr" , pr . Number ) commitsMissingDCO , err := checkCommitMessages ( gc , l , org , repo , pr . Number ) if err != nil { l . WithError ( err ) . Infof ( "Error running DCO check against commits in PR" ) return err } existingStatus , err := checkExistingStatus ( gc , l , org , repo , pr . Head . SHA ) if err != nil { l . WithError ( err ) . Infof ( "Error checking existing PR status" ) return err } hasYesLabel , hasNoLabel , err := checkExistingLabels ( gc , l , org , repo , pr . Number ) if err != nil { l . WithError ( err ) . Infof ( "Error checking existing PR labels" ) return err } return takeAction ( gc , cp , l , org , repo , pr , commitsMissingDCO , existingStatus , hasYesLabel , hasNoLabel , addComment ) }
1705	func MarkdownSHAList ( org , repo string , list [ ] github . GitCommit ) string { lines := make ( [ ] string , len ( list ) ) lineFmt := "- [%s](https://github.com/%s/%s/commits/%s) %s" for i , commit := range list { if commit . SHA == "" { continue } shortSHA := commit . SHA if len ( shortSHA ) > 7 { shortSHA = shortSHA [ : 7 ] } message := strings . Split ( commit . Message , "\n" ) [ \n ] 0 } lines [ i ] = fmt . Sprintf ( lineFmt , shortSHA , org , repo , commit . SHA , message ) }
1706	func PathForSpec ( spec * downwardapi . JobSpec , pathSegment RepoPathBuilder ) string { switch spec . Type { case prowapi . PeriodicJob , prowapi . PostsubmitJob : return path . Join ( NonPRLogs , spec . Job , spec . BuildID ) case prowapi . PresubmitJob : return path . Join ( PRLogs , "pull" , pathSegment ( spec . Refs . Org , spec . Refs . Repo ) , strconv . Itoa ( spec . Refs . Pulls [ 0 ] . Number ) , spec . Job , spec . BuildID ) case prowapi . BatchJob : return path . Join ( PRLogs , "pull" , "batch" , spec . Job , spec . BuildID ) default : logrus . Fatalf ( "unknown job spec type: %v" , spec . Type ) } return "" }
1707	func AliasForSpec ( spec * downwardapi . JobSpec ) string { switch spec . Type { case prowapi . PeriodicJob , prowapi . PostsubmitJob , prowapi . BatchJob : return "" case prowapi . PresubmitJob : return path . Join ( PRLogs , "directory" , spec . Job , fmt . Sprintf ( "%s.txt" , spec . BuildID ) ) default : logrus . Fatalf ( "unknown job spec type: %v" , spec . Type ) } return "" }
1708	func RootForSpec ( spec * downwardapi . JobSpec ) string { switch spec . Type { case prowapi . PeriodicJob , prowapi . PostsubmitJob : return path . Join ( NonPRLogs , spec . Job ) case prowapi . PresubmitJob , prowapi . BatchJob : return path . Join ( PRLogs , "directory" , spec . Job ) default : logrus . Errorf ( "unknown job spec type: %v" , spec . Type ) } return "" }
1709	func NewSingleDefaultRepoPathBuilder ( defaultOrg , defaultRepo string ) RepoPathBuilder { return func ( org , repo string ) string { if org == defaultOrg && repo == defaultRepo { return "" } repo = strings . Replace ( repo , "/" , "_" , - 1 ) return fmt . Sprintf ( "%s_%s" , org , repo ) } }
1710	func NewExplicitRepoPathBuilder ( ) RepoPathBuilder { return func ( org , repo string ) string { repo = strings . Replace ( repo , "/" , "_" , - 1 ) return fmt . Sprintf ( "%s_%s" , org , repo ) } }
1711	func RegisterSourceOrDie ( name string , src IssueSource ) { if _ , ok := sources [ name ] ; ok { glog . Fatalf ( "Cannot register an IssueSource with name %q, already exists!" , name ) } sources [ name ] = src glog . Infof ( "Registered issue source '%s'." , name ) }
1712	func ( c * IssueCreator ) CreateAndSync ( ) { var err error if err = c . initialize ( ) ; err != nil { glog . Fatalf ( "Error initializing IssueCreator: %v." , err ) } glog . Info ( "IssueCreator initialization complete." ) for srcName , src := range sources { glog . Infof ( "Generating issues from source: %s." , srcName ) var issues [ ] Issue if issues , err = src . Issues ( c ) ; err != nil { glog . Errorf ( "Error generating issues. Source: %s Msg: %v." , srcName , err ) continue } glog . Infof ( "Syncing issues from source: %s." , srcName ) created := 0 for _ , issue := range issues { if c . sync ( issue ) { created ++ } } glog . Infof ( "Created issues for %d of the %d issues synced from source: %s." , created , len ( issues ) , srcName , ) } }
1713	func ( c * IssueCreator ) loadCache ( ) error { user , err := c . client . GetUser ( "" ) if err != nil { return fmt . Errorf ( "failed to fetch the User struct for the current authenticated user. errmsg: %v" , err ) } if user == nil { return fmt . Errorf ( "received a nil User struct pointer when trying to look up the currently authenticated user" ) } if user . Login == nil { return fmt . Errorf ( "the user struct for the currently authenticated user does not specify a login" ) } c . authorName = * user . Login if validLabels , err := c . client . GetRepoLabels ( c . org , c . project ) ; err != nil { c . validLabels = nil glog . Errorf ( "Failed to retrieve the list of valid labels for repo '%s/%s'. Allowing all labels. errmsg: %v\n" , \n , c . org , c . project ) } else err { c . validLabels = make ( [ ] string , 0 , len ( validLabels ) ) for _ , label := range validLabels { if label . Name != nil && * label . Name != "" { c . validLabels = append ( c . validLabels , * label . Name ) } } } if collaborators , err := c . client . GetCollaborators ( c . org , c . project ) ; err != nil { c . Collaborators = nil glog . Errorf ( "Failed to retrieve the list of valid collaborators for repo '%s/%s'. Allowing all assignees. errmsg: %v\n" , \n , c . org , c . project ) } else err { c . Collaborators = make ( [ ] string , 0 , len ( collaborators ) ) for _ , user := range collaborators { if user . Login != nil && * user . Login != "" { c . Collaborators = append ( c . Collaborators , strings . ToLower ( * user . Login ) ) } } } issues , err := c . client . GetIssues ( c . org , c . project , & github . IssueListByRepoOptions { State : "all" , Creator : c . authorName , } , ) if err != nil { return fmt . Errorf ( "failed to refresh the list of all issues created by %s in repo '%s/%s'. errmsg: %v" , c . authorName , c . org , c . project , err ) } if len ( issues ) == 0 { glog . Warningf ( "IssueCreator found no issues in the repo '%s/%s' authored by '%s'.\n" , \n , c . org , c . project ) } c . authorName }
1714	func setIntersect ( a , b [ ] string ) ( filtered , removed [ ] string ) { for _ , elemA := range a { found := false for _ , elemB := range b { if elemA == elemB { found = true break } } if found { filtered = append ( filtered , elemA ) } else { removed = append ( removed , elemA ) } } return }
1715	func ( c * IssueCreator ) sync ( issue Issue ) bool { id := issue . ID ( ) var closedIssues [ ] * github . Issue for _ , i := range c . allIssues { if strings . Contains ( * i . Body , id ) { switch * i . State { case "open" : return false case "closed" : closedIssues = append ( closedIssues , i ) default : glog . Errorf ( "Unrecognized issue state '%s' for issue #%d. Ignoring this issue.\n" , \n , * i . State ) } } } * i . Number body := issue . Body ( closedIssues ) if body == "" { glog . Infof ( "Issue aborted sync by providing \"\" (empty) body. ID: %s." , \" ) \" } id return false if ! strings . Contains ( body , id ) { glog . Fatalf ( "Programmer error: The following body text does not contain id '%s'.\n%s\n" , \n , \n ) } id body title := issue . Title ( ) owners := issue . Owners ( ) if c . Collaborators != nil { var removedOwners [ ] string owners , removedOwners = setIntersect ( owners , c . Collaborators ) if len ( removedOwners ) > 0 { glog . Errorf ( "Filtered the following invalid assignees from issue %q: %q." , title , removedOwners ) } } labels := issue . Labels ( ) if prio , ok := issue . Priority ( ) ; ok { labels = append ( labels , "priority/" + prio ) } if c . validLabels != nil { var removedLabels [ ] string labels , removedLabels = setIntersect ( labels , c . validLabels ) if len ( removedLabels ) > 0 { glog . Errorf ( "Filtered the following invalid labels from issue %q: %q." , title , removedLabels ) } } glog . Infof ( "Create Issue: %q Assigned to: %q\n" , \n , title ) }
1716	func GetAWSCreds ( r * common . Resource ) ( credentials . Value , error ) { val := credentials . Value { } if r . Type != ResourceType { return val , fmt . Errorf ( "Wanted resource of type %q, got %q" , ResourceType , r . Type ) } accessKey , ok := r . UserData . Map . Load ( UserDataAccessIDKey ) if ! ok { return val , errors . New ( "No Access Key ID in UserData" ) } secretKey , ok := r . UserData . Map . Load ( UserDataSecretAccessKey ) if ! ok { return val , errors . New ( "No Secret Access Key in UserData" ) } val . AccessKeyID = accessKey . ( string ) val . SecretAccessKey = secretKey . ( string ) return val , nil }
1717	func stopper ( ) chan struct { } { stop := make ( chan struct { } ) c := make ( chan os . Signal , 2 ) signal . Notify ( c , os . Interrupt , syscall . SIGTERM ) go func ( ) { <- c logrus . Warn ( "Interrupt received, attempting clean shutdown..." ) close ( stop ) <- c logrus . Error ( "Second interrupt received, force exiting..." ) os . Exit ( 1 ) } ( ) return stop }
1718	func newPipelineConfig ( cfg rest . Config , stop chan struct { } ) ( * pipelineConfig , error ) { bc , err := pipelineset . NewForConfig ( & cfg ) if err != nil { return nil , err } if _ , err := bc . TektonV1alpha1 ( ) . PipelineRuns ( "" ) . List ( metav1 . ListOptions { Limit : 1 } ) ; err != nil { return nil , err } bif := pipelineinfo . NewSharedInformerFactory ( bc , 30 * time . Minute ) bif . Tekton ( ) . V1alpha1 ( ) . PipelineRuns ( ) . Lister ( ) go bif . Start ( stop ) return & pipelineConfig { client : bc , informer : bif . Tekton ( ) . V1alpha1 ( ) . PipelineRuns ( ) , } , nil }
1719	func ( o * KubernetesClientOptions ) KubeClient ( ) ( kubernetes . Interface , error ) { return kube . GetKubernetesClient ( o . masterURL , o . kubeConfig ) }
1720	func ( o * KubernetesClientOptions ) ProwJobClient ( ) ( versioned . Interface , error ) { return kube . GetProwJobClient ( o . masterURL , o . kubeConfig ) }
1721	func ( bucket gcsBucket ) resolveSymLink ( symLink string ) ( string , error ) { data , err := bucket . readObject ( symLink ) if err != nil { return "" , fmt . Errorf ( "failed to read %s: %v" , symLink , err ) } u := string ( data ) return prefixRe . ReplaceAllString ( u , "" ) , nil }
1722	func readJSON ( bucket storageBucket , key string , data interface { } ) error { rawData , err := bucket . readObject ( key ) if err != nil { return fmt . Errorf ( "failed to read %s: %v" , key , err ) } err = json . Unmarshal ( rawData , & data ) if err != nil { return fmt . Errorf ( "failed to parse %s: %v" , key , err ) } return nil }
1723	func ( bucket gcsBucket ) listSubDirs ( prefix string ) ( [ ] string , error ) { if ! strings . HasSuffix ( prefix , "/" ) { prefix += "/" } dirs := [ ] string { } it := bucket . Objects ( context . Background ( ) , & storage . Query { Prefix : prefix , Delimiter : "/" , } ) for { attrs , err := it . Next ( ) if err == iterator . Done { break } if err != nil { return dirs , err } if attrs . Prefix != "" { dirs = append ( dirs , attrs . Prefix ) } } return dirs , nil }
1724	func ( bucket gcsBucket ) listAll ( prefix string ) ( [ ] string , error ) { keys := [ ] string { } it := bucket . Objects ( context . Background ( ) , & storage . Query { Prefix : prefix , } ) for { attrs , err := it . Next ( ) if err == iterator . Done { break } if err != nil { return keys , err } keys = append ( keys , attrs . Name ) } return keys , nil }
1725	func ( bucket gcsBucket ) listBuildIDs ( root string ) ( [ ] int64 , error ) { ids := [ ] int64 { } if strings . HasPrefix ( root , logsPrefix ) { dirs , err := bucket . listSubDirs ( root ) if err != nil { return ids , fmt . Errorf ( "failed to list GCS directories: %v" , err ) } for _ , dir := range dirs { i , err := strconv . ParseInt ( path . Base ( dir ) , 10 , 64 ) if err == nil { ids = append ( ids , i ) } else { logrus . Warningf ( "unrecognized directory name (expected int64): %s" , dir ) } } } else { keys , err := bucket . listAll ( root ) if err != nil { return ids , fmt . Errorf ( "failed to list GCS keys: %v" , err ) } for _ , key := range keys { matches := linkRe . FindStringSubmatch ( key ) if len ( matches ) == 2 { i , err := strconv . ParseInt ( matches [ 1 ] , 10 , 64 ) if err == nil { ids = append ( ids , i ) } else { logrus . Warningf ( "unrecognized file name (expected <int64>.txt): %s" , key ) } } } } return ids , nil }
1726	func FilterProfilePaths ( profile [ ] * cover . Profile , paths [ ] string , include bool ) ( [ ] * cover . Profile , error ) { parenPaths := make ( [ ] string , len ( paths ) ) for i , path := range paths { parenPaths [ i ] = "(" + path + ")" } joined := strings . Join ( parenPaths , "|" ) re , err := regexp . Compile ( joined ) if err != nil { return nil , err } result := make ( [ ] * cover . Profile , 0 , len ( profile ) ) for _ , p := range profile { if re . MatchString ( p . FileName ) == include { result = append ( result , p ) } } return result , nil }
1727	func LoadSecrets ( paths [ ] string ) ( map [ string ] [ ] byte , error ) { secretsMap := make ( map [ string ] [ ] byte , len ( paths ) ) for _ , path := range paths { secretValue , err := LoadSingleSecret ( path ) if err != nil { return nil , err } secretsMap [ path ] = secretValue } return secretsMap , nil }
1728	func LoadSingleSecret ( path string ) ( [ ] byte , error ) { b , err := ioutil . ReadFile ( path ) if err != nil { return nil , fmt . Errorf ( "error reading %s: %v" , path , err ) } return bytes . TrimSpace ( b ) , nil }
1729	func ( b * Bool ) Set ( s string ) error { v , err := strconv . ParseBool ( s ) if err != nil { return err } b . Explicit = true b . Value = v return nil }
1730	func NewOpener ( ctx context . Context , creds string ) ( Opener , error ) { var options [ ] option . ClientOption if creds != "" { options = append ( options , option . WithCredentialsFile ( creds ) ) } client , err := storage . NewClient ( ctx , options ... ) if err != nil { if creds != "" { return nil , err } logrus . WithError ( err ) . Debug ( "Cannot load application default gcp credentials" ) client = nil } return opener { gcs : client } , nil }
1731	func IsNotExist ( err error ) bool { return os . IsNotExist ( err ) || err == storage . ErrObjectNotExist }
1732	func LogClose ( c io . Closer ) { if err := c . Close ( ) ; err != nil { logrus . WithError ( err ) . Error ( "Failed to close" ) } }
1733	func ( o opener ) Writer ( ctx context . Context , path string ) ( io . WriteCloser , error ) { g , err := o . openGCS ( path ) if err != nil { return nil , fmt . Errorf ( "bad gcs path: %v" , err ) } if g == nil { return os . Create ( path ) } return g . NewWriter ( ctx ) , nil }
1734	func ( gac * GitHubOAuthConfig ) InitGitHubOAuthConfig ( cookie * sessions . CookieStore ) { gob . Register ( & oauth2 . Token { } ) gac . CookieStore = cookie }
1735	func deltaDisplayed ( change * coverageChange ) string { if change . baseRatio < 0 { return "" } return fmt . Sprintf ( "%.1f" , ( change . newRatio - change . baseRatio ) * 100 ) }
1736	func makeTable ( baseCovList , newCovList * calculation . CoverageList , coverageThreshold float32 ) ( string , bool ) { var rows [ ] string isCoverageLow := false for _ , change := range findChanges ( baseCovList , newCovList ) { filePath := change . name rows = append ( rows , fmt . Sprintf ( "%s | %s | %s | %s" , filePath , formatPercentage ( change . baseRatio ) , formatPercentage ( change . newRatio ) , deltaDisplayed ( change ) ) ) if change . newRatio < coverageThreshold { isCoverageLow = true } } return strings . Join ( rows , "\n" ) , \n }
1737	func ContentForGitHubPost ( baseProfiles , newProfiles [ ] * cover . Profile , jobName string , coverageThreshold float32 ) ( string , bool ) { rows := [ ] string { "The following is the code coverage report" , fmt . Sprintf ( "Say `/test %s` to re-run this coverage report" , jobName ) , "" , "File | Old Coverage | New Coverage | Delta" , "---- |:------------:|:------------:|:-----:" , } table , isCoverageLow := makeTable ( calculation . ProduceCovList ( baseProfiles ) , calculation . ProduceCovList ( newProfiles ) , coverageThreshold ) if table == "" { return "" , false } rows = append ( rows , table ) rows = append ( rows , "" ) return strings . Join ( rows , "\n" ) , \n }
1738	func ( client * Client ) AddFlags ( cmd * cobra . Command ) { cmd . PersistentFlags ( ) . StringVar ( & client . Token , "token" , "" , "The OAuth Token to use for requests." ) cmd . PersistentFlags ( ) . StringVar ( & client . TokenFile , "token-file" , "" , "The file containing the OAuth Token to use for requests." ) cmd . PersistentFlags ( ) . StringVar ( & client . Org , "organization" , "" , "The github organization to scan" ) cmd . PersistentFlags ( ) . StringVar ( & client . Project , "project" , "" , "The github project to scan" ) }
1739	func ( client * Client ) CheckFlags ( ) error { if client . Org == "" { return fmt . Errorf ( "organization flag must be set" ) } client . Org = strings . ToLower ( client . Org ) if client . Project == "" { return fmt . Errorf ( "project flag must be set" ) } client . Project = strings . ToLower ( client . Project ) return nil }
1740	func ( client * Client ) getGitHubClient ( ) ( * github . Client , error ) { if client . githubClient != nil { return client . githubClient , nil } token := client . Token if len ( token ) == 0 && len ( client . TokenFile ) != 0 { data , err := ioutil . ReadFile ( client . TokenFile ) if err != nil { return nil , err } token = strings . TrimSpace ( string ( data ) ) } if len ( token ) > 0 { ts := oauth2 . StaticTokenSource ( & oauth2 . Token { AccessToken : token } ) tc := oauth2 . NewClient ( oauth2 . NoContext , ts ) client . githubClient = github . NewClient ( tc ) } else { client . githubClient = github . NewClient ( nil ) } return client . githubClient , nil }
1741	func ( client * Client ) limitsCheckAndWait ( ) { var sleep time . Duration githubClient , err := client . getGitHubClient ( ) if err != nil { glog . Error ( "Failed to get RateLimits: " , err ) sleep = time . Minute } else { limits , _ , err := githubClient . RateLimits ( context . Background ( ) ) if err != nil { glog . Error ( "Failed to get RateLimits:" , err ) sleep = time . Minute } if limits != nil && limits . Core != nil && limits . Core . Remaining < tokenLimit { sleep = limits . Core . Reset . Sub ( time . Now ( ) ) glog . Warning ( "RateLimits: reached. Sleeping for " , sleep ) } } time . Sleep ( sleep ) }
1742	func ( client * Client ) FetchIssues ( latest time . Time , c chan * github . Issue ) { opt := & github . IssueListByRepoOptions { Since : latest , Sort : "updated" , State : "all" , Direction : "asc" } githubClient , err := client . getGitHubClient ( ) if err != nil { close ( c ) glog . Error ( err ) return } count := 0 for { client . limitsCheckAndWait ( ) issues , resp , err := githubClient . Issues . ListByRepo ( context . Background ( ) , client . Org , client . Project , opt , ) if err != nil { close ( c ) glog . Error ( err ) return } for _ , issue := range issues { c <- issue count ++ } if resp . NextPage == 0 { break } opt . ListOptions . Page = resp . NextPage } glog . Infof ( "Fetched %d issues updated issue since %v." , count , latest ) close ( c ) }
1743	func hasID ( events [ ] * github . IssueEvent , id int ) bool { for _ , event := range events { if * event . ID == int64 ( id ) { return true } } return false }
1744	func ( client * Client ) FetchIssueEvents ( issueID int , latest * int , c chan * github . IssueEvent ) { opt := & github . ListOptions { PerPage : 100 } githubClient , err := client . getGitHubClient ( ) if err != nil { close ( c ) glog . Error ( err ) return } count := 0 for { client . limitsCheckAndWait ( ) events , resp , err := githubClient . Issues . ListIssueEvents ( context . Background ( ) , client . Org , client . Project , issueID , opt , ) if err != nil { glog . Errorf ( "ListIssueEvents failed: %s. Retrying..." , err ) time . Sleep ( time . Second ) continue } for _ , event := range events { c <- event count ++ } if resp . NextPage == 0 || ( latest != nil && hasID ( events , * latest ) ) { break } opt . Page = resp . NextPage } glog . Infof ( "Fetched %d events." , count ) close ( c ) }
1745	func isPRChanged ( pe github . PullRequestEvent ) bool { switch pe . Action { case github . PullRequestActionOpened : return true case github . PullRequestActionReopened : return true case github . PullRequestActionSynchronize : return true case github . PullRequestActionEdited : return true default : return false } }
1746	func NewFetcher ( repository string ) * Fetcher { return & Fetcher { IssuesChannel : make ( chan sql . Issue , 100 ) , EventsCommentsChannel : make ( chan interface { } , 100 ) , repository : repository , } }
1747	func ( f * Fetcher ) fetchRecentIssues ( db * gorm . DB ) error { glog . Infof ( "Fetching issues updated after %s" , f . lastIssue ) var issues [ ] sql . Issue query := db . Where ( "issue_updated_at >= ?" , f . lastIssue ) . Where ( "repository = ?" , f . repository ) . Order ( "issue_updated_at" ) . Preload ( "Labels" ) . Find ( & issues ) if query . Error != nil { return query . Error } count := len ( issues ) for _ , issue := range issues { f . IssuesChannel <- issue f . lastIssue = issue . IssueUpdatedAt } glog . Infof ( "Found and pushed %d updated/new issues" , count ) return nil }
1748	func ( f * Fetcher ) fetchRecentEventsAndComments ( db * gorm . DB ) error { glog . Infof ( "Fetching issue-events with id bigger than %s" , f . lastEvent ) glog . Infof ( "Fetching comments with id bigger than %s" , f . lastComment ) eventRows , err := db . Model ( sql . IssueEvent { } ) . Where ( "repository = ?" , f . repository ) . Where ( "event_created_at > ?" , f . lastEvent ) . Order ( "event_created_at asc" ) . Rows ( ) if err != nil { return fmt . Errorf ( "Failed to query events from database: %s" , err ) } commentRows , err := db . Model ( sql . Comment { } ) . Where ( "repository = ?" , f . repository ) . Where ( "comment_created_at > ?" , f . lastComment ) . Order ( "comment_created_at asc" ) . Rows ( ) if err != nil { return fmt . Errorf ( "Failed to query comments from database: %s" , err ) } count := 0 comment := & sql . Comment { } if commentRows . Next ( ) { db . ScanRows ( commentRows , comment ) } else { comment = nil } event := & sql . IssueEvent { } if eventRows . Next ( ) { db . ScanRows ( eventRows , event ) } else { event = nil } for event != nil || comment != nil { if event == nil || ( comment != nil && comment . CommentCreatedAt . Before ( event . EventCreatedAt ) ) { f . EventsCommentsChannel <- * comment f . lastComment = comment . CommentCreatedAt if commentRows . Next ( ) { db . ScanRows ( commentRows , comment ) } else { comment = nil } } else { f . EventsCommentsChannel <- * event f . lastEvent = event . EventCreatedAt if eventRows . Next ( ) { db . ScanRows ( eventRows , event ) } else { event = nil } } count ++ } glog . Infof ( "Found and pushed %d new events/comments" , count ) return nil }
1749	func ( f * Fetcher ) Fetch ( db * gorm . DB ) error { if err := f . fetchRecentIssues ( db ) ; err != nil { return err } if err := f . fetchRecentEventsAndComments ( db ) ; err != nil { return err } return nil }
1750	func ( fjr * FlakyJobReporter ) Issues ( c * creator . IssueCreator ) ( [ ] creator . Issue , error ) { fjr . creator = c json , err := ReadHTTP ( fjr . flakyJobDataURL ) if err != nil { return nil , err } flakyJobs , err := fjr . parseFlakyJobs ( json ) if err != nil { return nil , err } count := fjr . syncCount if len ( flakyJobs ) < count { count = len ( flakyJobs ) } issues := make ( [ ] creator . Issue , 0 , count ) for _ , fj := range flakyJobs [ 0 : count ] { issues = append ( issues , fj ) } return issues , nil }
1751	func ( fj * FlakyJob ) Title ( ) string { return fmt . Sprintf ( "%s flaked %d times in the past week" , fj . Name , * fj . FlakeCount ) }
1752	func ( fj * FlakyJob ) Labels ( ) [ ] string { labels := [ ] string { "kind/flake" } for sig := range fj . reporter . creator . TestsSIGs ( fj . TestsSorted ( ) ) { labels = append ( labels , "sig/" + sig ) } return labels }
1753	func ReadHTTP ( url string ) ( [ ] byte , error ) { var err error retryDelay := time . Duration ( 2 ) * time . Second for retryCount := 0 ; retryCount < 5 ; retryCount ++ { if retryCount > 0 { time . Sleep ( retryDelay ) retryDelay *= time . Duration ( 2 ) } resp , err := http . Get ( url ) if resp != nil && resp . StatusCode >= 500 { continue } if err != nil { return nil , err } defer resp . Body . Close ( ) body , err := ioutil . ReadAll ( resp . Body ) if err != nil { continue } return body , nil } return nil , fmt . Errorf ( "ran out of retries reading from '%s'. Last error was %v" , url , err ) }
1754	func ( l linesByTimestamp ) String ( ) string { sort . Sort ( l ) var log string for i , line := range l { switch i { case len ( l ) - 1 : log += string ( line . actual ) default : log += fmt . Sprintf ( "%s,\n" , \n ) } } strings . TrimSuffix ( string ( line . actual ) , "\n" ) }
1755	func NewJobSpec ( spec prowapi . ProwJobSpec , buildID , prowJobID string ) JobSpec { return JobSpec { Type : spec . Type , Job : spec . Job , BuildID : buildID , ProwJobID : prowJobID , Refs : spec . Refs , ExtraRefs : spec . ExtraRefs , agent : spec . Agent , } }
1756	func ResolveSpecFromEnv ( ) ( * JobSpec , error ) { specEnv , ok := os . LookupEnv ( JobSpecEnv ) if ! ok { return nil , fmt . Errorf ( "$%s unset" , JobSpecEnv ) } spec := & JobSpec { } if err := json . Unmarshal ( [ ] byte ( specEnv ) , spec ) ; err != nil { return nil , fmt . Errorf ( "malformed $%s: %v" , JobSpecEnv , err ) } return spec , nil }
1757	func EnvForSpec ( spec JobSpec ) ( map [ string ] string , error ) { env := map [ string ] string { jobNameEnv : spec . Job , buildIDEnv : spec . BuildID , prowJobIDEnv : spec . ProwJobID , jobTypeEnv : string ( spec . Type ) , } if spec . agent == prowapi . KubernetesAgent { env [ prowBuildIDEnv ] = spec . BuildID } raw , err := json . Marshal ( spec ) if err != nil { return env , fmt . Errorf ( "failed to marshal job spec: %v" , err ) } env [ JobSpecEnv ] = string ( raw ) if spec . Type == prowapi . PeriodicJob { return env , nil } env [ repoOwnerEnv ] = spec . Refs . Org env [ repoNameEnv ] = spec . Refs . Repo env [ pullBaseRefEnv ] = spec . Refs . BaseRef env [ pullBaseShaEnv ] = spec . Refs . BaseSHA env [ pullRefsEnv ] = spec . Refs . String ( ) if spec . Type == prowapi . PostsubmitJob || spec . Type == prowapi . BatchJob { return env , nil } env [ pullNumberEnv ] = strconv . Itoa ( spec . Refs . Pulls [ 0 ] . Number ) env [ pullPullShaEnv ] = spec . Refs . Pulls [ 0 ] . SHA return env , nil }
1758	func EnvForType ( jobType prowapi . ProwJobType ) [ ] string { baseEnv := [ ] string { jobNameEnv , JobSpecEnv , jobTypeEnv , prowJobIDEnv , buildIDEnv , prowBuildIDEnv } refsEnv := [ ] string { repoOwnerEnv , repoNameEnv , pullBaseRefEnv , pullBaseShaEnv , pullRefsEnv } pullEnv := [ ] string { pullNumberEnv , pullPullShaEnv } switch jobType { case prowapi . PeriodicJob : return baseEnv case prowapi . PostsubmitJob , prowapi . BatchJob : return append ( baseEnv , refsEnv ... ) case prowapi . PresubmitJob : return append ( append ( baseEnv , refsEnv ... ) , pullEnv ... ) default : return [ ] string { } } }
1759	func getRevisionFromRef ( refs * prowapi . Refs ) string { if len ( refs . Pulls ) > 0 { return refs . Pulls [ 0 ] . SHA } if refs . BaseSHA != "" { return refs . BaseSHA } return refs . BaseRef }
1760	func GetRevisionFromSpec ( spec * JobSpec ) string { if spec . Refs != nil { return getRevisionFromRef ( spec . Refs ) } else if len ( spec . ExtraRefs ) > 0 { return getRevisionFromRef ( & spec . ExtraRefs [ 0 ] ) } return "" }
1761	func helpProvider ( config * plugins . Configuration , enabledRepos [ ] string ) ( * pluginhelp . PluginHelp , error ) { return & pluginhelp . PluginHelp { Description : fmt . Sprintf ( "The merge commit blocker plugin adds the %s label to pull requests that contain merge commits" , labels . MergeCommits ) , } , nil }
1762	func ( g * Group ) load ( r io . Reader ) ( [ ] string , error ) { var repoPaths [ ] string s := bufio . NewScanner ( r ) for s . Scan ( ) { l := strings . TrimSpace ( s . Text ( ) ) if l == "" || l [ 0 ] == '#' { continue } fs := strings . Fields ( l ) if len ( fs ) != 2 { return repoPaths , & ParseError { line : l } } switch fs [ 0 ] { case "prefix" , "path-prefix" : g . PathPrefixes [ fs [ 1 ] ] = true case "file-prefix" : g . FilePrefixes [ fs [ 1 ] ] = true case "file-name" : g . FileNames [ fs [ 1 ] ] = true case "path" : g . FileNames [ fs [ 1 ] ] = true case "paths-from-repo" : repoPaths = append ( repoPaths , fs [ 1 ] ) default : return repoPaths , & ParseError { line : l } } } if err := s . Err ( ) ; err != nil { return repoPaths , err } return repoPaths , nil }
1763	func ( g * Group ) loadPaths ( r io . Reader ) error { s := bufio . NewScanner ( r ) for s . Scan ( ) { l := strings . TrimSpace ( s . Text ( ) ) if l == "" || l [ 0 ] == '#' { continue } g . Paths [ l ] = true } if err := s . Err ( ) ; err != nil { return fmt . Errorf ( "scan error: %v" , err ) } return nil }
1764	func ( g * Group ) Match ( path string ) bool { if g . Paths [ path ] { return true } for prefix := range g . PathPrefixes { if strings . HasPrefix ( path , prefix ) { return true } } base := filepath . Base ( path ) if g . FileNames [ base ] { return true } for prefix := range g . FilePrefixes { if strings . HasPrefix ( base , prefix ) { return true } } return false }
1765	func ( config * InfluxConfig ) CreateDatabase ( tags map [ string ] string , measurement string ) ( * InfluxDB , error ) { client , err := influxdb . NewHTTPClient ( influxdb . HTTPConfig { Addr : config . Host , Username : config . User , Password : config . Password , } ) if err != nil { return nil , err } err = dropSeries ( client , measurement , config . DB , tags ) if err != nil { return nil , err } bp , err := influxdb . NewBatchPoints ( influxdb . BatchPointsConfig { Database : config . DB , Precision : "s" , } ) if err != nil { return nil , err } return & InfluxDB { client : client , database : config . DB , batch : bp , tags : tags , measurement : measurement , } , err }
1766	func mergeTags ( defaultTags , extraTags map [ string ] string ) map [ string ] string { newTags := map [ string ] string { } for k , v := range defaultTags { newTags [ k ] = v } for k , v := range extraTags { newTags [ k ] = v } return newTags }
1767	func tagsToWhere ( tags map [ string ] string ) string { if len ( tags ) == 0 { return "" } sortedKeys := [ ] string { } for k := range tags { sortedKeys = append ( sortedKeys , k ) } sort . Strings ( sortedKeys ) conditions := [ ] string { } for _ , key := range sortedKeys { conditions = append ( conditions , fmt . Sprintf ( `"%s" = '%v'` , key , tags [ key ] ) ) } return "WHERE " + strings . Join ( conditions , " AND " ) }
1768	func ( i * InfluxDB ) Push ( tags map [ string ] string , fields map [ string ] interface { } , date time . Time ) error { pt , err := influxdb . NewPoint ( i . measurement , mergeTags ( i . tags , tags ) , fields , date ) if err != nil { return err } i . batch . AddPoint ( pt ) i . batchSize ++ return nil }
1769	func ( af * PodLogArtifactFetcher ) artifact ( jobName , buildID string , sizeLimit int64 ) ( lenses . Artifact , error ) { podLog , err := NewPodLogArtifact ( jobName , buildID , sizeLimit , af . jobAgent ) if err != nil { return nil , fmt . Errorf ( "Error accessing pod log from given source: %v" , err ) } return podLog , nil }
1770	func serve ( ) { http . Handle ( "/metrics" , promhttp . Handler ( ) ) logrus . WithError ( http . ListenAndServe ( ":8080" , nil ) ) . Fatal ( "ListenAndServe returned." ) }
1771	func gather ( c * plank . Controller ) { tick := time . Tick ( 30 * time . Second ) sig := make ( chan os . Signal , 1 ) signal . Notify ( sig , os . Interrupt , syscall . SIGTERM ) for { select { case <- tick : start := time . Now ( ) c . SyncMetrics ( ) logrus . WithField ( "metrics-duration" , fmt . Sprintf ( "%v" , time . Since ( start ) ) ) . Debug ( "Metrics synced" ) case <- sig : logrus . Debug ( "Plank gatherer is shutting down..." ) return } } }
1772	func makeRequest ( policy branchprotection . Policy ) github . BranchProtectionRequest { return github . BranchProtectionRequest { EnforceAdmins : makeAdmins ( policy . Admins ) , RequiredPullRequestReviews : makeReviews ( policy . RequiredPullRequestReviews ) , RequiredStatusChecks : makeChecks ( policy . RequiredStatusChecks ) , Restrictions : makeRestrictions ( policy . Restrictions ) , } }
1773	func makeReviews ( rp * branchprotection . ReviewPolicy ) * github . RequiredPullRequestReviews { switch { case rp == nil : return nil case rp . Approvals == nil : logrus . Warn ( "WARNING: required_pull_request_reviews policy does not specify required_approving_review_count, disabling" ) return nil case * rp . Approvals == 0 : return nil } rprr := github . RequiredPullRequestReviews { DismissStaleReviews : makeBool ( rp . DismissStale ) , RequireCodeOwnerReviews : makeBool ( rp . RequireOwners ) , RequiredApprovingReviewCount : * rp . Approvals , } if rp . DismissalRestrictions != nil { rprr . DismissalRestrictions = * makeRestrictions ( rp . DismissalRestrictions ) } return & rprr }
1774	func ( lens Lens ) Header ( artifacts [ ] lenses . Artifact , resourceDir string ) string { return executeTemplate ( resourceDir , "header" , BuildLogsView { } ) }
1775	func ( lens Lens ) Callback ( artifacts [ ] lenses . Artifact , resourceDir string , data string ) string { var request LineRequest err := json . Unmarshal ( [ ] byte ( data ) , & request ) if err != nil { return "failed to unmarshal request" } artifact , ok := artifactByName ( artifacts , request . Artifact ) if ! ok { return "no artifact named " + request . Artifact } var lines [ ] string if request . Offset == 0 && request . Length == - 1 { lines , err = logLinesAll ( artifact ) } else { lines , err = logLines ( artifact , request . Offset , request . Length ) } if err != nil { return fmt . Sprintf ( "failed to retrieve log lines: %v" , err ) } logLines := highlightLines ( lines , request . StartLine ) return executeTemplate ( resourceDir , "line group" , logLines ) }
1776	func logLinesAll ( artifact lenses . Artifact ) ( [ ] string , error ) { read , err := artifact . ReadAll ( ) if err != nil { return nil , fmt . Errorf ( "failed to read log %q: %v" , artifact . JobPath ( ) , err ) } logLines := strings . Split ( string ( read ) , "\n" ) \n }
1777	func executeTemplate ( resourceDir , templateName string , data interface { } ) string { t := template . New ( "template.html" ) _ , err := t . ParseFiles ( filepath . Join ( resourceDir , "template.html" ) ) if err != nil { return fmt . Sprintf ( "Failed to load template: %v" , err ) } var buf bytes . Buffer if err := t . ExecuteTemplate ( & buf , templateName , data ) ; err != nil { logrus . WithError ( err ) . Error ( "Error executing template." ) } return buf . String ( ) }
1778	func ( in * ResourceObject ) DeepCopyObject ( ) runtime . Object { if c := in . deepCopy ( ) ; c != nil { return c } return nil }
1779	func ( in * ResourceObject ) FromItem ( i common . Item ) { r , err := common . ItemToResource ( i ) if err == nil { in . fromResource ( r ) } }
1780	func ( in * ResourceCollection ) SetItems ( objects [ ] Object ) { var items [ ] * ResourceObject for _ , b := range objects { items = append ( items , b . ( * ResourceObject ) ) } in . Items = items }
1781	func ( in * ResourceCollection ) DeepCopyObject ( ) runtime . Object { if c := in . deepCopy ( ) ; c != nil { return c } return nil }
1782	func useContext ( o options , ctx string ) error { _ , cmd := command ( "kubectl" , "config" , "use-context" , ctx ) return cmd . Run ( ) }
1783	func currentContext ( o options ) ( string , error ) { _ , cmd := command ( "kubectl" , "config" , "current-context" ) b , err := cmd . Output ( ) return strings . TrimSpace ( string ( b ) ) , err }
1784	func command ( bin string , args ... string ) ( [ ] string , * exec . Cmd ) { cmd := exec . Command ( bin , args ... ) cmd . Stderr = os . Stderr return append ( [ ] string { bin } , args ... ) , cmd }
1785	func describeCluster ( o options ) ( * describe , error ) { if o . account != "" { act , err := getAccount ( ) if err != nil { return nil , fmt . Errorf ( "get current account: %v" , err ) } defer setAccount ( act ) if err = setAccount ( o . account ) ; err != nil { return nil , fmt . Errorf ( "set account %s: %v" , o . account , err ) } } args , cmd := command ( "gcloud" , "container" , "clusters" , "describe" , o . cluster , "--project" , o . project , "--zone" , o . zone , "--format=yaml" , ) data , err := cmd . Output ( ) if err != nil { return nil , fmt . Errorf ( "%s: %v" , strings . Join ( args , " " ) , err ) } var d describe if yaml . Unmarshal ( data , & d ) ; err != nil { return nil , fmt . Errorf ( "unmarshal gcloud: %v" , err ) } if d . Endpoint == "" { return nil , errors . New ( "empty endpoint" ) } if len ( d . Auth . ClusterCACertificate ) == 0 { return nil , errors . New ( "empty clusterCaCertificate" ) } if len ( d . Auth . ClientKey ) == 0 { return nil , errors . New ( "empty clientKey, consider running with --get-client-cert" ) } if len ( d . Auth . ClientCertificate ) == 0 { return nil , errors . New ( "empty clientCertificate, consider running with --get-client-cert" ) } return & d , nil }
1786	func ( ss * strslice ) Set ( value string ) error { * ss = append ( * ss , value ) return nil }
1787	func parseXML ( body [ ] byte , object string ) ( * gcsDir , error ) { dir := new ( gcsDir ) if err := xml . Unmarshal ( body , & dir ) ; err != nil { return nil , err } isDir := object == "/" || len ( dir . Contents ) + len ( dir . CommonPrefixes ) > 0 selfIndex := - 1 for i := range dir . Contents { rec := & dir . Contents [ i ] name := strings . TrimPrefix ( rec . Name , object ) if name == "" { selfIndex = i continue } rec . Name = name if strings . HasSuffix ( name , "/" ) { rec . isDir = true } } for i := range dir . CommonPrefixes { cp := & dir . CommonPrefixes [ i ] cp . Prefix = strings . TrimPrefix ( cp . Prefix , object ) } if ! isDir { return nil , nil } if selfIndex >= 0 { dir . Contents = append ( dir . Contents [ : selfIndex ] , dir . Contents [ selfIndex + 1 : ] ... ) } return dir , nil }
1788	func ( dir * gcsDir ) Render ( out http . ResponseWriter , inPath string ) { htmlPageHeader ( out , dir . Name ) if ! strings . HasSuffix ( inPath , "/" ) { inPath += "/" } htmlContentHeader ( out , dir . Name , inPath ) if dir . NextMarker != "" { htmlNextButton ( out , gcsPath + inPath , dir . NextMarker ) } htmlGridHeader ( out ) if parent := dirname ( inPath ) ; parent != "" { url := gcsPath + parent htmlGridItem ( out , iconBack , url , ".." , "-" , "-" ) } for i := range dir . CommonPrefixes { dir . CommonPrefixes [ i ] . Render ( out , inPath ) } for i := range dir . Contents { dir . Contents [ i ] . Render ( out , inPath ) } if dir . NextMarker != "" { htmlNextButton ( out , gcsPath + inPath , dir . NextMarker ) } htmlContentFooter ( out ) htmlPageFooter ( out ) }
1789	func ( rec * Record ) Render ( out http . ResponseWriter , inPath string ) { mtime := "<unknown>" ts , err := time . Parse ( time . RFC3339 , rec . MTime ) if err == nil { mtime = ts . Format ( "02 Jan 2006 15:04:05" ) } var url , size string if rec . isDir { url = gcsPath + inPath + rec . Name size = "-" } else { url = gcsBaseURL + inPath + rec . Name size = fmt . Sprintf ( "%v" , rec . Size ) } htmlGridItem ( out , iconFile , url , rec . Name , size , mtime ) }
1790	func ( pfx * Prefix ) Render ( out http . ResponseWriter , inPath string ) { url := gcsPath + inPath + pfx . Prefix htmlGridItem ( out , iconDir , url , pfx . Prefix , "-" , "-" ) }
1791	func ( tl txnLogger ) Printf ( fmt string , args ... interface { } ) { args = append ( [ ] interface { } { tl . nonce } , args ... ) log . Printf ( "[txn-%s] " + fmt , args ... ) }
1792	func NewClient ( instances map [ string ] [ ] string ) ( * Client , error ) { c := & Client { handlers : map [ string ] * gerritInstanceHandler { } , } for instance := range instances { gc , err := gerrit . NewClient ( instance , nil ) if err != nil { return nil , err } c . handlers [ instance ] = & gerritInstanceHandler { instance : instance , projects : instances [ instance ] , authService : gc . Authentication , accountService : gc . Accounts , changeService : gc . Changes , projectService : gc . Projects , } } return c , nil }
1793	func ( c * Client ) SetReview ( instance , id , revision , message string , labels map [ string ] string ) error { h , ok := c . handlers [ instance ] if ! ok { return fmt . Errorf ( "not activated gerrit instance: %s" , instance ) } if _ , _ , err := h . changeService . SetReview ( id , revision , & gerrit . ReviewInput { Message : message , Labels : labels , } ) ; err != nil { return fmt . Errorf ( "cannot comment to gerrit: %v" , err ) } return nil }
1794	func ( c * Client ) GetBranchRevision ( instance , project , branch string ) ( string , error ) { h , ok := c . handlers [ instance ] if ! ok { return "" , fmt . Errorf ( "not activated gerrit instance: %s" , instance ) } res , _ , err := h . projectService . GetBranch ( project , branch ) if err != nil { return "" , err } return res . Revision , nil }
1795	func ( h * gerritInstanceHandler ) queryAllChanges ( lastUpdate time . Time , rateLimit int ) [ ] gerrit . ChangeInfo { result := [ ] gerrit . ChangeInfo { } for _ , project := range h . projects { changes , err := h . queryChangesForProject ( project , lastUpdate , rateLimit ) if err != nil { logrus . WithError ( err ) . Errorf ( "fail to query changes for project %s" , project ) continue } result = append ( result , changes ... ) } return result }
1796	func NewTypeFilterWrapperPlugin ( plugin Plugin ) * TypeFilterWrapperPlugin { return & TypeFilterWrapperPlugin { plugin : plugin , pass : map [ string ] bool { } , } }
1797	func ( t * TypeFilterWrapperPlugin ) AddFlags ( cmd * cobra . Command ) { cmd . Flags ( ) . BoolVar ( & t . pullRequests , "no-pull-requests" , false , "Ignore pull-requests" ) cmd . Flags ( ) . BoolVar ( & t . issues , "no-issues" , false , "Ignore issues" ) }
1798	func ( t * TypeFilterWrapperPlugin ) CheckFlags ( ) error { if t . pullRequests && t . issues { return fmt . Errorf ( "you can't ignore both pull-requests and issues" ) } return nil }
1799	func ( o * KubernetesClientOptions ) AddFlags ( fs * flag . FlagSet ) { fs . StringVar ( & o . namespace , "namespace" , v1 . NamespaceDefault , "namespace to install on" ) fs . StringVar ( & o . kubeConfig , "kubeconfig" , "" , "absolute path to the kubeConfig file" ) fs . BoolVar ( & o . inMemory , "in_memory" , false , "Use in memory client instead of CRD" ) }
1800	func ( o * KubernetesClientOptions ) Validate ( ) error { if o . kubeConfig != "" { if _ , err := os . Stat ( o . kubeConfig ) ; err != nil { return err } } return nil }
1801	func ( o * KubernetesClientOptions ) Client ( t Type ) ( ClientInterface , error ) { if o . inMemory { return newDummyClient ( t ) , nil } return o . newCRDClient ( t ) }
1802	func ( o * KubernetesClientOptions ) newCRDClient ( t Type ) ( * Client , error ) { config , scheme , err := createRESTConfig ( o . kubeConfig , t ) if err != nil { return nil , err } if err = registerResource ( config , t ) ; err != nil { return nil , err } var restClient * rest . RESTClient restClient , err = rest . RESTClientFor ( config ) if err != nil { return nil , err } rc := Client { cl : restClient , ns : o . namespace , t : t , codec : runtime . NewParameterCodec ( scheme ) } return & rc , nil }
1803	func createRESTConfig ( kubeconfig string , t Type ) ( config * rest . Config , types * runtime . Scheme , err error ) { if kubeconfig == "" { config , err = rest . InClusterConfig ( ) } else { config , err = clientcmd . BuildConfigFromFlags ( "" , kubeconfig ) } if err != nil { return } version := schema . GroupVersion { Group : group , Version : version , } config . GroupVersion = & version config . APIPath = "/apis" config . ContentType = runtime . ContentTypeJSON types = runtime . NewScheme ( ) schemeBuilder := runtime . NewSchemeBuilder ( func ( scheme * runtime . Scheme ) error { scheme . AddKnownTypes ( version , t . Object , t . Collection ) v1 . AddToGroupVersion ( scheme , version ) return nil } ) err = schemeBuilder . AddToScheme ( types ) config . NegotiatedSerializer = serializer . DirectCodecFactory { CodecFactory : serializer . NewCodecFactory ( types ) } return }
1804	func registerResource ( config * rest . Config , t Type ) error { c , err := apiextensionsclient . NewForConfig ( config ) if err != nil { return err } crd := & apiextensionsv1beta1 . CustomResourceDefinition { ObjectMeta : v1 . ObjectMeta { Name : fmt . Sprintf ( "%s.%s" , t . Plural , group ) , } , Spec : apiextensionsv1beta1 . CustomResourceDefinitionSpec { Group : group , Version : version , Scope : apiextensionsv1beta1 . NamespaceScoped , Names : apiextensionsv1beta1 . CustomResourceDefinitionNames { Singular : t . Singular , Plural : t . Plural , Kind : t . Kind , ListKind : t . ListKind , } , } , } if _ , err := c . ApiextensionsV1beta1 ( ) . CustomResourceDefinitions ( ) . Create ( crd ) ; err != nil && ! apierrors . IsAlreadyExists ( err ) { return err } return nil }
1805	func newDummyClient ( t Type ) * dummyClient { c := & dummyClient { t : t , objects : make ( map [ string ] Object ) , } return c }
1806	func ( c * dummyClient ) Update ( obj Object ) ( Object , error ) { _ , ok := c . objects [ obj . GetName ( ) ] if ! ok { return nil , fmt . Errorf ( "cannot find object %s" , obj . GetName ( ) ) } c . objects [ obj . GetName ( ) ] = obj return obj , nil }
1807	func TrustedPullRequest ( ghc githubClient , trigger plugins . Trigger , author , org , repo string , num int , l [ ] github . Label ) ( [ ] github . Label , bool , error ) { if orgMember , err := TrustedUser ( ghc , trigger , author , org , repo ) ; err != nil { return l , false , fmt . Errorf ( "error checking %s for trust: %v" , author , err ) } else if orgMember { return l , true , nil } if l == nil { var err error l , err = ghc . GetIssueLabels ( org , repo , num ) if err != nil { return l , false , err } } return l , github . HasLabel ( labels . OkToTest , l ) , nil }
1808	func buildAll ( c Client , pr * github . PullRequest , eventGUID string , elideSkippedContexts bool ) error { org , repo , number , branch := pr . Base . Repo . Owner . Login , pr . Base . Repo . Name , pr . Number , pr . Base . Ref changes := config . NewGitHubDeferredChangedFilesProvider ( c . GitHubClient , org , repo , number ) toTest , toSkipSuperset , err := pjutil . FilterPresubmits ( pjutil . TestAllFilter ( ) , changes , branch , c . Config . Presubmits [ pr . Base . Repo . FullName ] , c . Logger ) if err != nil { return err } toSkip := determineSkippedPresubmits ( toTest , toSkipSuperset , c . Logger ) return runAndSkipJobs ( c , pr , toTest , toSkip , eventGUID , elideSkippedContexts ) }
1809	func ( o Options ) Run ( ctx context . Context ) ( int , error ) { spec , err := downwardapi . ResolveSpecFromEnv ( ) if err != nil { return 0 , fmt . Errorf ( "could not resolve job spec: %v" , err ) } ctx , cancel := context . WithCancel ( ctx ) interrupt := make ( chan os . Signal ) signal . Notify ( interrupt , os . Interrupt , syscall . SIGTERM ) go func ( ) { select { case s := <- interrupt : logrus . Errorf ( "Received an interrupt: %s, cancelling..." , s ) cancel ( ) case <- ctx . Done ( ) : } } ( ) if o . DeprecatedWrapperOptions != nil { logrus . Warnf ( "Using deprecated wrapper_options instead of entries. Please update prow/pod-utils/decorate before June 2019" ) } entries := o . entries ( ) passed , aborted , failures := wait ( ctx , entries ) cancel ( ) signal . Ignore ( os . Interrupt , syscall . SIGTERM ) buildLog := logReader ( entries ) metadata := combineMetadata ( entries ) return failures , o . doUpload ( spec , passed , aborted , metadata , buildLog ) }
1810	func ( s * Storage ) AddConfig ( conf common . ResourcesConfig ) error { return s . configs . Add ( conf ) }
1811	func ( s * Storage ) DeleteConfig ( name string ) error { return s . configs . Delete ( name ) }
1812	func ( s * Storage ) UpdateConfig ( conf common . ResourcesConfig ) error { return s . configs . Update ( conf ) }
1813	func ( s * Storage ) GetConfig ( name string ) ( common . ResourcesConfig , error ) { i , err := s . configs . Get ( name ) if err != nil { return common . ResourcesConfig { } , err } var conf common . ResourcesConfig conf , err = common . ItemToResourcesConfig ( i ) if err != nil { return common . ResourcesConfig { } , err } return conf , nil }
1814	func ( s * Storage ) GetConfigs ( ) ( [ ] common . ResourcesConfig , error ) { var configs [ ] common . ResourcesConfig items , err := s . configs . List ( ) if err != nil { return configs , err } for _ , i := range items { var conf common . ResourcesConfig conf , err = common . ItemToResourcesConfig ( i ) if err != nil { return nil , err } configs = append ( configs , conf ) } return configs , nil }
1815	func ( s * Storage ) SyncConfigs ( newConfigs [ ] common . ResourcesConfig ) error { s . configsLock . Lock ( ) defer s . configsLock . Unlock ( ) currentConfigs , err := s . GetConfigs ( ) if err != nil { logrus . WithError ( err ) . Error ( "cannot find configs" ) return err } currentSet := mapset . NewSet ( ) newSet := mapset . NewSet ( ) toUpdate := mapset . NewSet ( ) configs := map [ string ] common . ResourcesConfig { } for _ , c := range currentConfigs { currentSet . Add ( c . Name ) configs [ c . Name ] = c } for _ , c := range newConfigs { newSet . Add ( c . Name ) if old , exists := configs [ c . Name ] ; exists { if ! reflect . DeepEqual ( old , c ) { toUpdate . Add ( c . Name ) configs [ c . Name ] = c } } else { configs [ c . Name ] = c } } var finalError error toDelete := currentSet . Difference ( newSet ) toAdd := newSet . Difference ( currentSet ) for _ , n := range toDelete . ToSlice ( ) { logrus . Infof ( "Deleting config %s" , n . ( string ) ) if err := s . DeleteConfig ( n . ( string ) ) ; err != nil { logrus . WithError ( err ) . Errorf ( "failed to delete config %s" , n ) finalError = multierror . Append ( finalError , err ) } } for _ , n := range toAdd . ToSlice ( ) { rc := configs [ n . ( string ) ] logrus . Infof ( "Adding config %s" , n . ( string ) ) if err := s . AddConfig ( rc ) ; err != nil { logrus . WithError ( err ) . Errorf ( "failed to create resources %s" , n ) finalError = multierror . Append ( finalError , err ) } } for _ , n := range toUpdate . ToSlice ( ) { rc := configs [ n . ( string ) ] logrus . Infof ( "Updating config %s" , n . ( string ) ) if err := s . UpdateConfig ( rc ) ; err != nil { logrus . WithError ( err ) . Errorf ( "failed to update resources %s" , n ) finalError = multierror . Append ( finalError , err ) } } return finalError }
1816	func addKnownTypes ( scheme * runtime . Scheme ) error { scheme . AddKnownTypes ( SchemeGroupVersion , & ProwJob { } , & ProwJobList { } , ) metav1 . AddToGroupVersion ( scheme , SchemeGroupVersion ) return nil }
1817	func NewController ( continueOnError bool , addedPresubmitBlacklist sets . String , prowJobClient prowv1 . ProwJobInterface , githubClient * github . Client , configAgent * config . Agent , pluginAgent * plugins . ConfigAgent ) * Controller { return & Controller { continueOnError : continueOnError , addedPresubmitBlacklist : addedPresubmitBlacklist , prowJobTriggerer : & kubeProwJobTriggerer { prowJobClient : prowJobClient , githubClient : githubClient , configAgent : configAgent , } , githubClient : githubClient , statusMigrator : & gitHubMigrator { githubClient : githubClient , continueOnError : continueOnError , } , trustedChecker : & githubTrustedChecker { githubClient : githubClient , pluginAgent : pluginAgent , } , } }
1818	func ( c * Controller ) Run ( stop <- chan os . Signal , changes <- chan config . Delta ) { for { select { case change := <- changes : start := time . Now ( ) if err := c . reconcile ( change ) ; err != nil { logrus . WithError ( err ) . Error ( "Error reconciling statuses." ) } logrus . WithField ( "duration" , fmt . Sprintf ( "%v" , time . Since ( start ) ) ) . Info ( "Statuses reconciled" ) case <- stop : logrus . Info ( "status-reconciler is shutting down..." ) return } } }
1819	func addedBlockingPresubmits ( old , new map [ string ] [ ] config . Presubmit ) map [ string ] [ ] config . Presubmit { added := map [ string ] [ ] config . Presubmit { } for repo , oldPresubmits := range old { added [ repo ] = [ ] config . Presubmit { } for _ , newPresubmit := range new [ repo ] { if ! newPresubmit . ContextRequired ( ) || newPresubmit . NeedsExplicitTrigger ( ) { continue } var found bool for _ , oldPresubmit := range oldPresubmits { if oldPresubmit . Name == newPresubmit . Name { if oldPresubmit . SkipReport && ! newPresubmit . SkipReport { added [ repo ] = append ( added [ repo ] , newPresubmit ) logrus . WithFields ( logrus . Fields { "repo" : repo , "name" : oldPresubmit . Name , } ) . Debug ( "Identified a newly-reporting blocking presubmit." ) } if oldPresubmit . RunIfChanged != newPresubmit . RunIfChanged { added [ repo ] = append ( added [ repo ] , newPresubmit ) logrus . WithFields ( logrus . Fields { "repo" : repo , "name" : oldPresubmit . Name , } ) . Debug ( "Identified a blocking presubmit running over a different set of files." ) } found = true break } } if ! found { added [ repo ] = append ( added [ repo ] , newPresubmit ) logrus . WithFields ( logrus . Fields { "repo" : repo , "name" : newPresubmit . Name , } ) . Debug ( "Identified an added blocking presubmit." ) } } } var numAdded int for _ , presubmits := range added { numAdded += len ( presubmits ) } logrus . Infof ( "Identified %d added blocking presubmits." , numAdded ) return added }
1820	func removedBlockingPresubmits ( old , new map [ string ] [ ] config . Presubmit ) map [ string ] [ ] config . Presubmit { removed := map [ string ] [ ] config . Presubmit { } for repo , oldPresubmits := range old { removed [ repo ] = [ ] config . Presubmit { } for _ , oldPresubmit := range oldPresubmits { if ! oldPresubmit . ContextRequired ( ) { continue } var found bool for _ , newPresubmit := range new [ repo ] { if oldPresubmit . Name == newPresubmit . Name { found = true break } } if ! found { removed [ repo ] = append ( removed [ repo ] , oldPresubmit ) logrus . WithFields ( logrus . Fields { "repo" : repo , "name" : oldPresubmit . Name , } ) . Debug ( "Identified a removed blocking presubmit." ) } } } var numRemoved int for _ , presubmits := range removed { numRemoved += len ( presubmits ) } logrus . Infof ( "Identified %d removed blocking presubmits." , numRemoved ) return removed }
1821	func migratedBlockingPresubmits ( old , new map [ string ] [ ] config . Presubmit ) map [ string ] [ ] presubmitMigration { migrated := map [ string ] [ ] presubmitMigration { } for repo , oldPresubmits := range old { migrated [ repo ] = [ ] presubmitMigration { } for _ , newPresubmit := range new [ repo ] { if ! newPresubmit . ContextRequired ( ) { continue } for _ , oldPresubmit := range oldPresubmits { if oldPresubmit . Context != newPresubmit . Context && oldPresubmit . Name == newPresubmit . Name { migrated [ repo ] = append ( migrated [ repo ] , presubmitMigration { from : oldPresubmit , to : newPresubmit } ) logrus . WithFields ( logrus . Fields { "repo" : repo , "name" : oldPresubmit . Name , "from" : oldPresubmit . Context , "to" : newPresubmit . Context , } ) . Debug ( "Identified a migrated blocking presubmit." ) } } } } var numMigrated int for _ , presubmits := range migrated { numMigrated += len ( presubmits ) } logrus . Infof ( "Identified %d migrated blocking presubmits." , numMigrated ) return migrated }
1822	func Load ( loader OptionLoader ) error { if jsonConfig , provided := os . LookupEnv ( loader . ConfigVar ( ) ) ; provided { if err := loader . LoadConfig ( jsonConfig ) ; err != nil { return fmt . Errorf ( "could not load config from JSON var %s: %v" , loader . ConfigVar ( ) , err ) } return nil } fs := flag . NewFlagSet ( os . Args [ 0 ] , flag . ExitOnError ) loader . AddFlags ( fs ) fs . Parse ( os . Args [ 1 : ] ) loader . Complete ( fs . Args ( ) ) return nil }
1823	func ( c * Controller ) canExecuteConcurrently ( pj * prowapi . ProwJob ) bool { c . lock . Lock ( ) defer c . lock . Unlock ( ) if max := c . config ( ) . MaxConcurrency ; max > 0 { var running int for _ , num := range c . pendingJobs { running += num } if running >= max { c . log . WithFields ( pjutil . ProwJobFields ( pj ) ) . Debugf ( "Not starting another job, already %d running." , running ) return false } } if pj . Spec . MaxConcurrency == 0 { c . pendingJobs [ pj . Spec . Job ] ++ return true } numPending := c . pendingJobs [ pj . Spec . Job ] if numPending >= pj . Spec . MaxConcurrency { c . log . WithFields ( pjutil . ProwJobFields ( pj ) ) . Debugf ( "Not starting another instance of %s, already %d running." , pj . Spec . Job , numPending ) return false } c . pendingJobs [ pj . Spec . Job ] ++ return true }
1824	func getJenkinsJobs ( pjs [ ] prowapi . ProwJob ) [ ] BuildQueryParams { jenkinsJobs := [ ] BuildQueryParams { } for _ , pj := range pjs { if pj . Complete ( ) { continue } jenkinsJobs = append ( jenkinsJobs , BuildQueryParams { JobName : getJobName ( & pj . Spec ) , ProwJobID : pj . Name , } ) } return jenkinsJobs }
1825	func ( c * Controller ) terminateDupes ( pjs [ ] prowapi . ProwJob , jbs map [ string ] Build ) error { dupes := make ( map [ string ] int ) for i , pj := range pjs { if pj . Complete ( ) || pj . Spec . Type != prowapi . PresubmitJob { continue } n := fmt . Sprintf ( "%s %s/%s#%d" , pj . Spec . Job , pj . Spec . Refs . Org , pj . Spec . Refs . Repo , pj . Spec . Refs . Pulls [ 0 ] . Number ) prev , ok := dupes [ n ] if ! ok { dupes [ n ] = i continue } cancelIndex := i if ( & pjs [ prev ] . Status . StartTime ) . Before ( & pj . Status . StartTime ) { cancelIndex = prev dupes [ n ] = i } toCancel := pjs [ cancelIndex ] if c . config ( ) . AllowCancellations { build , buildExists := jbs [ toCancel . ObjectMeta . Name ] if buildExists && build . IsEnqueued ( ) { continue } if buildExists { if err := c . jc . Abort ( getJobName ( & toCancel . Spec ) , & build ) ; err != nil { c . log . WithError ( err ) . WithFields ( pjutil . ProwJobFields ( & toCancel ) ) . Warn ( "Cannot cancel Jenkins build" ) } } } toCancel . SetComplete ( ) prevState := toCancel . Status . State toCancel . Status . State = prowapi . AbortedState c . log . WithFields ( pjutil . ProwJobFields ( & toCancel ) ) . WithField ( "from" , prevState ) . WithField ( "to" , toCancel . Status . State ) . Info ( "Transitioning states." ) npj , err := c . prowJobClient . Update ( & toCancel ) if err != nil { return err } pjs [ cancelIndex ] = * npj } return nil }
1826	func ( c * Client ) Throttle ( hourlyTokens , burst int ) { c . log ( "Throttle" , hourlyTokens , burst ) c . throttle . lock . Lock ( ) defer c . throttle . lock . Unlock ( ) previouslyThrottled := c . throttle . ticker != nil if hourlyTokens <= 0 || burst <= 0 { if previouslyThrottled { c . client = c . throttle . http c . gqlc = c . throttle . graph c . throttle . ticker . Stop ( ) c . throttle . ticker = nil } return } rate := time . Hour / time . Duration ( hourlyTokens ) ticker := time . NewTicker ( rate ) throttle := make ( chan time . Time , burst ) for i := 0 ; i < burst ; i ++ { throttle <- time . Now ( ) } go func ( ) { for t := range ticker . C { select { case throttle <- t : default : } } } ( ) if ! previouslyThrottled { c . throttle . http = c . client c . throttle . graph = c . gqlc c . client = & c . throttle c . gqlc = & c . throttle } c . throttle . ticker = ticker c . throttle . throttle = throttle }
1827	func NewClientWithFields ( fields logrus . Fields , getToken func ( ) [ ] byte , graphqlEndpoint string , bases ... string ) * Client { return & Client { logger : logrus . WithFields ( fields ) . WithField ( "client" , "github" ) , time : & standardTime { } , gqlc : githubql . NewEnterpriseClient ( graphqlEndpoint , & http . Client { Timeout : maxRequestTime , Transport : & oauth2 . Transport { Source : newReloadingTokenSource ( getToken ) } , } ) , client : & http . Client { Timeout : maxRequestTime } , bases : bases , getToken : getToken , dry : false , } }
1828	func NewClient ( getToken func ( ) [ ] byte , graphqlEndpoint string , bases ... string ) * Client { return NewClientWithFields ( logrus . Fields { } , getToken , graphqlEndpoint , bases ... ) }
1829	func NewDryRunClient ( getToken func ( ) [ ] byte , graphqlEndpoint string , bases ... string ) * Client { return NewDryRunClientWithFields ( logrus . Fields { } , getToken , graphqlEndpoint , bases ... ) }
1830	func NewFakeClient ( ) * Client { return & Client { logger : logrus . WithField ( "client" , "github" ) , time : & standardTime { } , fake : true , dry : true , } }
1831	func ( c * Client ) request ( r * request , ret interface { } ) ( int , error ) { statusCode , b , err := c . requestRaw ( r ) if err != nil { return statusCode , err } if ret != nil { if err := json . Unmarshal ( b , ret ) ; err != nil { return statusCode , err } } return statusCode , nil }
1832	func ( c * Client ) requestRaw ( r * request ) ( int , [ ] byte , error ) { if c . fake || ( c . dry && r . method != http . MethodGet ) { return r . exitCodes [ 0 ] , nil , nil } resp , err := c . requestRetry ( r . method , r . path , r . accept , r . requestBody ) if err != nil { return 0 , nil , err } defer resp . Body . Close ( ) b , err := ioutil . ReadAll ( resp . Body ) if err != nil { return 0 , nil , err } var okCode bool for _ , code := range r . exitCodes { if code == resp . StatusCode { okCode = true break } } if ! okCode { clientError := unmarshalClientError ( b ) err = requestError { ClientError : clientError , ErrorString : fmt . Sprintf ( "status code %d not one of %v, body: %s" , resp . StatusCode , r . exitCodes , string ( b ) ) , } } return resp . StatusCode , b , err }
1833	func ( c * Client ) getUserData ( ) error { c . log ( "User" ) var u User _ , err := c . request ( & request { method : http . MethodGet , path : "/user" , exitCodes : [ ] int { 200 } , } , & u ) if err != nil { return err } c . botName = u . Login c . email = u . Email return nil }
1834	func ( c * Client ) readPaginatedResultsWithValues ( path string , values url . Values , accept string , newObj func ( ) interface { } , accumulate func ( interface { } ) ) error { pagedPath := path if len ( values ) > 0 { pagedPath += "?" + values . Encode ( ) } for { resp , err := c . requestRetry ( http . MethodGet , pagedPath , accept , nil ) if err != nil { return err } defer resp . Body . Close ( ) if resp . StatusCode < 200 || resp . StatusCode > 299 { return fmt . Errorf ( "return code not 2XX: %s" , resp . Status ) } b , err := ioutil . ReadAll ( resp . Body ) if err != nil { return err } obj := newObj ( ) if err := json . Unmarshal ( b , obj ) ; err != nil { return err } accumulate ( obj ) link := parseLinks ( resp . Header . Get ( "Link" ) ) [ "next" ] if link == "" { break } u , err := url . Parse ( link ) if err != nil { return fmt . Errorf ( "failed to parse 'next' link: %v" , err ) } pagedPath = u . RequestURI ( ) } return nil }
1835	func ( c * Client ) UpdatePullRequest ( org , repo string , number int , title , body * string , open * bool , branch * string , canModify * bool ) error { c . log ( "UpdatePullRequest" , org , repo , title ) data := struct { State * string `json:"state,omitempty"` Title * string `json:"title,omitempty"` Body * string `json:"body,omitempty"` Base * string `json:"base,omitempty"` MaintainerCanModify * bool `json:"maintainer_can_modify,omitempty"` } { Title : title , Body : body , Base : branch , MaintainerCanModify : canModify , } if open != nil && * open { op := "open" data . State = & op } else if open != nil { cl := "clossed" data . State = & cl } _ , err := c . request ( & request { accept : "application/vnd.github.symmetra-preview+json, application/vnd.github.shadow-cat-preview" , method : http . MethodPatch , path : fmt . Sprintf ( "/repos/%s/%s/pulls/%d" , org , repo , number ) , requestBody : & data , exitCodes : [ ] int { 200 } , } , nil ) return err }
1836	func ( c * Client ) getLabels ( path string ) ( [ ] Label , error ) { var labels [ ] Label if c . fake { return labels , nil } err := c . readPaginatedResults ( path , "application/vnd.github.symmetra-preview+json" , func ( ) interface { } { return & [ ] Label { } } , func ( obj interface { } ) { labels = append ( labels , * ( obj . ( * [ ] Label ) ) ... ) } , ) if err != nil { return nil , err } return labels , nil }
1837	func stateCannotBeChangedOrOriginalError ( err error ) error { requestErr , ok := err . ( requestError ) if ok { for _ , errorMsg := range requestErr . ErrorMessages ( ) { if strings . Contains ( errorMsg , stateCannotBeChangedMessagePrefix ) { return StateCannotBeChanged { Message : errorMsg , } } } } return err }
1838	func ( c * Client ) IsMergeable ( org , repo string , number int , SHA string ) ( bool , error ) { backoff := time . Second * 3 maxTries := 3 for try := 0 ; try < maxTries ; try ++ { pr , err := c . GetPullRequest ( org , repo , number ) if err != nil { return false , err } if pr . Head . SHA != SHA { return false , fmt . Errorf ( "pull request head changed while checking mergeability (%s -> %s)" , SHA , pr . Head . SHA ) } if pr . Merged { return false , errors . New ( "pull request was merged while checking mergeability" ) } if pr . Mergable != nil { return * pr . Mergable , nil } if try + 1 < maxTries { c . time . Sleep ( backoff ) backoff *= 2 } } return false , fmt . Errorf ( "reached maximum number of retries (%d) checking mergeability" , maxTries ) }
1839	func ( s * reloadingTokenSource ) Token ( ) ( * oauth2 . Token , error ) { return & oauth2 . Token { AccessToken : string ( s . getToken ( ) ) , } , nil }
1840	func ( s * Spyglass ) ListArtifacts ( src string ) ( [ ] string , error ) { keyType , key , err := splitSrc ( src ) if err != nil { return [ ] string { } , fmt . Errorf ( "error parsing src: %v" , err ) } gcsKey := "" switch keyType { case gcsKeyType : gcsKey = key case prowKeyType : if gcsKey , err = s . prowToGCS ( key ) ; err != nil { logrus . Warningf ( "Failed to get gcs source for prow job: %v" , err ) } default : return nil , fmt . Errorf ( "Unrecognized key type for src: %v" , src ) } artifactNames , err := s . GCSArtifactFetcher . artifacts ( gcsKey ) logFound := false for _ , name := range artifactNames { if name == "build-log.txt" { logFound = true break } } if err != nil || ! logFound { artifactNames = append ( artifactNames , "build-log.txt" ) } return artifactNames , nil }
1841	func ( * Spyglass ) KeyToJob ( src string ) ( jobName string , buildID string , err error ) { src = strings . Trim ( src , "/" ) parsed := strings . Split ( src , "/" ) if len ( parsed ) < 2 { return "" , "" , fmt . Errorf ( "expected at least two path components in %q" , src ) } jobName = parsed [ len ( parsed ) - 2 ] buildID = parsed [ len ( parsed ) - 1 ] return jobName , buildID , nil }
1842	func ( s * Spyglass ) prowToGCS ( prowKey string ) ( string , error ) { jobName , buildID , err := s . KeyToJob ( prowKey ) if err != nil { return "" , fmt . Errorf ( "could not get GCS src: %v" , err ) } job , err := s . jobAgent . GetProwJob ( jobName , buildID ) if err != nil { return "" , fmt . Errorf ( "Failed to get prow job from src %q: %v" , prowKey , err ) } url := job . Status . URL prefix := s . config ( ) . Plank . GetJobURLPrefix ( job . Spec . Refs ) if ! strings . HasPrefix ( url , prefix ) { return "" , fmt . Errorf ( "unexpected job URL %q when finding GCS path: expected something starting with %q" , url , prefix ) } return url [ len ( prefix ) : ] , nil }
1843	func ( s * Spyglass ) FetchArtifacts ( src string , podName string , sizeLimit int64 , artifactNames [ ] string ) ( [ ] lenses . Artifact , error ) { artStart := time . Now ( ) arts := [ ] lenses . Artifact { } keyType , key , err := splitSrc ( src ) if err != nil { return arts , fmt . Errorf ( "error parsing src: %v" , err ) } jobName , buildID , err := s . KeyToJob ( src ) if err != nil { return arts , fmt . Errorf ( "could not derive job: %v" , err ) } gcsKey := "" switch keyType { case gcsKeyType : gcsKey = strings . TrimSuffix ( key , "/" ) case prowKeyType : if gcsKey , err = s . prowToGCS ( key ) ; err != nil { logrus . Warningln ( err ) } default : return nil , fmt . Errorf ( "invalid src: %v" , src ) } podLogNeeded := false for _ , name := range artifactNames { art , err := s . GCSArtifactFetcher . artifact ( gcsKey , name , sizeLimit ) if err == nil { _ , err = art . Size ( ) } if err != nil { if name == "build-log.txt" { podLogNeeded = true } continue } arts = append ( arts , art ) } if podLogNeeded { art , err := s . PodLogArtifactFetcher . artifact ( jobName , buildID , sizeLimit ) if err != nil { logrus . Errorf ( "Failed to fetch pod log: %v" , err ) } else { arts = append ( arts , art ) } } logrus . WithField ( "duration" , time . Since ( artStart ) ) . Infof ( "Retrieved artifacts for %v" , src ) return arts , nil }
1844	func ( in * DecorationConfig ) DeepCopy ( ) * DecorationConfig { if in == nil { return nil } out := new ( DecorationConfig ) in . DeepCopyInto ( out ) return out }
1845	func ( in * GCSConfiguration ) DeepCopy ( ) * GCSConfiguration { if in == nil { return nil } out := new ( GCSConfiguration ) in . DeepCopyInto ( out ) return out }
1846	func ( in * JenkinsSpec ) DeepCopy ( ) * JenkinsSpec { if in == nil { return nil } out := new ( JenkinsSpec ) in . DeepCopyInto ( out ) return out }
1847	func ( in * ProwJob ) DeepCopy ( ) * ProwJob { if in == nil { return nil } out := new ( ProwJob ) in . DeepCopyInto ( out ) return out }
1848	func ( in * ProwJobList ) DeepCopy ( ) * ProwJobList { if in == nil { return nil } out := new ( ProwJobList ) in . DeepCopyInto ( out ) return out }
1849	func ( in * ProwJobSpec ) DeepCopy ( ) * ProwJobSpec { if in == nil { return nil } out := new ( ProwJobSpec ) in . DeepCopyInto ( out ) return out }
1850	func ( in * ProwJobStatus ) DeepCopy ( ) * ProwJobStatus { if in == nil { return nil } out := new ( ProwJobStatus ) in . DeepCopyInto ( out ) return out }
1851	func ( in * Pull ) DeepCopy ( ) * Pull { if in == nil { return nil } out := new ( Pull ) in . DeepCopyInto ( out ) return out }
1852	func ( in * Refs ) DeepCopy ( ) * Refs { if in == nil { return nil } out := new ( Refs ) in . DeepCopyInto ( out ) return out }
1853	func ( in * UtilityImages ) DeepCopy ( ) * UtilityImages { if in == nil { return nil } out := new ( UtilityImages ) in . DeepCopyInto ( out ) return out }
1854	func upload ( rsClient * resultstore . Client , inv resultstore . Invocation , target resultstore . Target , test resultstore . Test ) ( string , error ) { targetID := test . Name const configID = resultstore . Default invName , err := rsClient . Invocations ( ) . Create ( inv ) if err != nil { return "" , fmt . Errorf ( "create invocation: %v" , err ) } targetName , err := rsClient . Targets ( invName ) . Create ( targetID , target ) if err != nil { return resultstore . URL ( invName ) , fmt . Errorf ( "create target: %v" , err ) } url := resultstore . URL ( targetName ) _ , err = rsClient . Configurations ( invName ) . Create ( configID ) if err != nil { return url , fmt . Errorf ( "create configuration: %v" , err ) } ctName , err := rsClient . ConfiguredTargets ( targetName , configID ) . Create ( test . Action ) if err != nil { return url , fmt . Errorf ( "create configured target: %v" , err ) } _ , err = rsClient . Actions ( ctName ) . Create ( "primary" , test ) if err != nil { return url , fmt . Errorf ( "create action: %v" , err ) } return url , nil }
1855	func ( d * DecorationConfig ) ApplyDefault ( def * DecorationConfig ) * DecorationConfig { if d == nil && def == nil { return nil } var merged DecorationConfig if d != nil { merged = * d } else { merged = * def } if d == nil || def == nil { return & merged } merged . UtilityImages = merged . UtilityImages . ApplyDefault ( def . UtilityImages ) merged . GCSConfiguration = merged . GCSConfiguration . ApplyDefault ( def . GCSConfiguration ) if merged . Timeout . Duration == 0 { merged . Timeout = def . Timeout } if merged . GracePeriod . Duration == 0 { merged . GracePeriod = def . GracePeriod } if merged . GCSCredentialsSecret == "" { merged . GCSCredentialsSecret = def . GCSCredentialsSecret } if len ( merged . SSHKeySecrets ) == 0 { merged . SSHKeySecrets = def . SSHKeySecrets } if len ( merged . SSHHostFingerprints ) == 0 { merged . SSHHostFingerprints = def . SSHHostFingerprints } if merged . SkipCloning == nil { merged . SkipCloning = def . SkipCloning } if merged . CookiefileSecret == "" { merged . CookiefileSecret = def . CookiefileSecret } return & merged }
1856	func ( d * DecorationConfig ) Validate ( ) error { if d . UtilityImages == nil { return errors . New ( "utility image config is not specified" ) } var missing [ ] string if d . UtilityImages . CloneRefs == "" { missing = append ( missing , "clonerefs" ) } if d . UtilityImages . InitUpload == "" { missing = append ( missing , "initupload" ) } if d . UtilityImages . Entrypoint == "" { missing = append ( missing , "entrypoint" ) } if d . UtilityImages . Sidecar == "" { missing = append ( missing , "sidecar" ) } if len ( missing ) > 0 { return fmt . Errorf ( "the following utility images are not specified: %q" , missing ) } if d . GCSConfiguration == nil { return errors . New ( "GCS upload configuration is not specified" ) } if d . GCSCredentialsSecret == "" { return errors . New ( "GCS upload credential secret is not specified" ) } if err := d . GCSConfiguration . Validate ( ) ; err != nil { return fmt . Errorf ( "GCS configuration is invalid: %v" , err ) } return nil }
1857	func ( u * UtilityImages ) ApplyDefault ( def * UtilityImages ) * UtilityImages { if u == nil { return def } else if def == nil { return u } merged := * u if merged . CloneRefs == "" { merged . CloneRefs = def . CloneRefs } if merged . InitUpload == "" { merged . InitUpload = def . InitUpload } if merged . Entrypoint == "" { merged . Entrypoint = def . Entrypoint } if merged . Sidecar == "" { merged . Sidecar = def . Sidecar } return & merged }
1858	func ( g * GCSConfiguration ) ApplyDefault ( def * GCSConfiguration ) * GCSConfiguration { if g == nil && def == nil { return nil } var merged GCSConfiguration if g != nil { merged = * g } else { merged = * def } if g == nil || def == nil { return & merged } if merged . Bucket == "" { merged . Bucket = def . Bucket } if merged . PathPrefix == "" { merged . PathPrefix = def . PathPrefix } if merged . PathStrategy == "" { merged . PathStrategy = def . PathStrategy } if merged . DefaultOrg == "" { merged . DefaultOrg = def . DefaultOrg } if merged . DefaultRepo == "" { merged . DefaultRepo = def . DefaultRepo } return & merged }
1859	func ( g * GCSConfiguration ) Validate ( ) error { if g . PathStrategy != PathStrategyLegacy && g . PathStrategy != PathStrategyExplicit && g . PathStrategy != PathStrategySingle { return fmt . Errorf ( "gcs_path_strategy must be one of %q, %q, or %q" , PathStrategyLegacy , PathStrategyExplicit , PathStrategySingle ) } if g . PathStrategy != PathStrategyExplicit && ( g . DefaultOrg == "" || g . DefaultRepo == "" ) { return fmt . Errorf ( "default org and repo must be provided for GCS strategy %q" , g . PathStrategy ) } return nil }
1860	func ( j * ProwJob ) ClusterAlias ( ) string { if j . Spec . Cluster == "" { return DefaultClusterAlias } return j . Spec . Cluster }
1861	func NewResource ( name , rtype , state , owner string , t time . Time ) Resource { return Resource { Name : name , Type : rtype , State : state , Owner : owner , LastUpdate : t , UserData : & UserData { } , } }
1862	func NewResourcesFromConfig ( e ResourceEntry ) [ ] Resource { var resources [ ] Resource for _ , name := range e . Names { resources = append ( resources , NewResource ( name , e . Type , e . State , "" , time . Time { } ) ) } return resources }
1863	func UserDataFromMap ( m UserDataMap ) * UserData { ud := & UserData { } for k , v := range m { ud . Store ( k , v ) } return ud }
1864	func ( r * CommaSeparatedStrings ) Set ( value string ) error { if len ( * r ) > 0 { return errors . New ( "resTypes flag already set" ) } for _ , rtype := range strings . Split ( value , "," ) { * r = append ( * r , rtype ) } return nil }
1865	func ( ud * UserData ) UnmarshalJSON ( data [ ] byte ) error { tmpMap := UserDataMap { } if err := json . Unmarshal ( data , & tmpMap ) ; err != nil { return err } ud . FromMap ( tmpMap ) return nil }
1866	func ( ud * UserData ) Extract ( id string , out interface { } ) error { content , ok := ud . Load ( id ) if ! ok { return & UserDataNotFound { id } } return yaml . Unmarshal ( [ ] byte ( content . ( string ) ) , out ) }
1867	func ( ud * UserData ) Set ( id string , in interface { } ) error { b , err := yaml . Marshal ( in ) if err != nil { return err } ud . Store ( id , string ( b ) ) return nil }
1868	func ( ud * UserData ) Update ( new * UserData ) { if new == nil { return } new . Range ( func ( key , value interface { } ) bool { if value . ( string ) != "" { ud . Store ( key , value ) } else { ud . Delete ( key ) } return true } ) }
1869	func ( ud * UserData ) ToMap ( ) UserDataMap { m := UserDataMap { } ud . Range ( func ( key , value interface { } ) bool { m [ key . ( string ) ] = value . ( string ) return true } ) return m }
1870	func ( ud * UserData ) FromMap ( m UserDataMap ) { for key , value := range m { ud . Store ( key , value ) } }
1871	func ItemToResource ( i Item ) ( Resource , error ) { res , ok := i . ( Resource ) if ! ok { return Resource { } , fmt . Errorf ( "cannot construct Resource from received object %v" , i ) } return res , nil }
1872	func ( o Options ) Run ( ) error { var env [ ] string if len ( o . KeyFiles ) > 0 { var err error env , err = addSSHKeys ( o . KeyFiles ) if err != nil { logrus . WithError ( err ) . Error ( "Failed to add SSH keys." ) } } if len ( o . HostFingerprints ) > 0 { if err := addHostFingerprints ( o . HostFingerprints ) ; err != nil { logrus . WithError ( err ) . Error ( "failed to add host fingerprints" ) } } var numWorkers int if o . MaxParallelWorkers != 0 { numWorkers = o . MaxParallelWorkers } else { numWorkers = len ( o . GitRefs ) } wg := & sync . WaitGroup { } wg . Add ( numWorkers ) input := make ( chan prowapi . Refs ) output := make ( chan clone . Record , len ( o . GitRefs ) ) for i := 0 ; i < numWorkers ; i ++ { go func ( ) { defer wg . Done ( ) for ref := range input { output <- cloneFunc ( ref , o . SrcRoot , o . GitUserName , o . GitUserEmail , o . CookiePath , env ) } } ( ) } for _ , ref := range o . GitRefs { input <- ref } close ( input ) wg . Wait ( ) close ( output ) var results [ ] clone . Record for record := range output { results = append ( results , record ) } logData , err := json . Marshal ( results ) if err != nil { return fmt . Errorf ( "failed to marshal clone records: %v" , err ) } if err := ioutil . WriteFile ( o . Log , logData , 0755 ) ; err != nil { return fmt . Errorf ( "failed to write clone records: %v" , err ) } return nil }
1873	func addSSHKeys ( paths [ ] string ) ( [ ] string , error ) { vars , err := exec . Command ( "ssh-agent" ) . CombinedOutput ( ) if err != nil { return [ ] string { } , fmt . Errorf ( "failed to start ssh-agent: %v" , err ) } logrus . Info ( "Started SSH agent" ) parts := strings . Split ( string ( vars ) , ";" ) env := [ ] string { strings . TrimSpace ( parts [ 0 ] ) , strings . TrimSpace ( parts [ 2 ] ) } for _ , keyPath := range paths { if err := filepath . Walk ( keyPath , func ( path string , info os . FileInfo , err error ) error { if strings . HasPrefix ( info . Name ( ) , ".." ) { if info . IsDir ( ) { return filepath . SkipDir } return nil } if info . IsDir ( ) { return nil } cmd := exec . Command ( "ssh-add" , path ) cmd . Env = append ( cmd . Env , env ... ) if output , err := cmd . CombinedOutput ( ) ; err != nil { return fmt . Errorf ( "failed to add ssh key at %s: %v: %s" , path , err , output ) } logrus . Infof ( "Added SSH key at %s" , path ) return nil } ) ; err != nil { return env , fmt . Errorf ( "error walking path %q: %v" , keyPath , err ) } } return env , nil }
1874	func ( f * TriageFiler ) Issues ( c * creator . IssueCreator ) ( [ ] creator . Issue , error ) { f . creator = c rawjson , err := ReadHTTP ( clusterDataURL ) if err != nil { return nil , err } clusters , err := f . loadClusters ( rawjson ) if err != nil { return nil , err } topclusters := topClusters ( clusters , f . topClustersCount ) issues := make ( [ ] creator . Issue , 0 , len ( topclusters ) ) for _ , clust := range topclusters { issues = append ( issues , clust ) } return issues , nil }
1875	func ( f * TriageFiler ) loadClusters ( jsonIn [ ] byte ) ( [ ] * Cluster , error ) { var err error f . data , err = parseTriageData ( jsonIn ) if err != nil { return nil , err } if err = f . filterAndValidate ( f . windowDays ) ; err != nil { return nil , err } for _ , clust := range f . data . Clustered { clust . filer = f clust . jobs = make ( map [ string ] [ ] int ) for _ , test := range clust . Tests { for _ , job := range test . Jobs { for _ , buildnum := range job . Builds { found := false for _ , oldBuild := range clust . jobs [ job . Name ] { if oldBuild == buildnum { found = true break } } if ! found { clust . jobs [ job . Name ] = append ( clust . jobs [ job . Name ] , buildnum ) } } } } clust . totalJobs = len ( clust . jobs ) clust . totalTests = len ( clust . Tests ) clust . totalBuilds = 0 for _ , builds := range clust . jobs { clust . totalBuilds += len ( builds ) } } return f . data . Clustered , nil }
1876	func parseTriageData ( jsonIn [ ] byte ) ( * triageData , error ) { var data triageData if err := json . Unmarshal ( jsonIn , & data ) ; err != nil { return nil , err } if data . Builds . Cols . Started == nil { return nil , fmt . Errorf ( "triage data json is missing the builds.cols.started key" ) } if data . Builds . JobsRaw == nil { return nil , fmt . Errorf ( "triage data is missing the builds.jobs key" ) } if data . Builds . JobPaths == nil { return nil , fmt . Errorf ( "triage data is missing the builds.job_paths key" ) } if data . Clustered == nil { return nil , fmt . Errorf ( "triage data is missing the clustered key" ) } data . Builds . Jobs = make ( map [ string ] BuildIndexer ) for jobID , mapper := range data . Builds . JobsRaw { switch mapper := mapper . ( type ) { case [ ] interface { } : data . Builds . Jobs [ jobID ] = ContigIndexer { startBuild : int ( mapper [ 0 ] . ( float64 ) ) , count : int ( mapper [ 1 ] . ( float64 ) ) , startRow : int ( mapper [ 2 ] . ( float64 ) ) , } case map [ string ] interface { } : data . Builds . Jobs [ jobID ] = DictIndexer ( mapper ) default : return nil , fmt . Errorf ( "the build number to row index mapping for job '%s' is not an accepted type. Type is: %v" , jobID , reflect . TypeOf ( mapper ) ) } } return & data , nil }
1877	func topClusters ( clusters [ ] * Cluster , count int ) [ ] * Cluster { less := func ( i , j int ) bool { return clusters [ i ] . totalBuilds > clusters [ j ] . totalBuilds } sort . SliceStable ( clusters , less ) if len ( clusters ) < count { count = len ( clusters ) } return clusters [ 0 : count ] }
1878	func ( c * Cluster ) topJobsFailed ( count int ) [ ] * Job { slice := make ( [ ] * Job , len ( c . jobs ) ) i := 0 for jobName , builds := range c . jobs { slice [ i ] = & Job { Name : jobName , Builds : builds } i ++ } less := func ( i , j int ) bool { return len ( slice [ i ] . Builds ) > len ( slice [ j ] . Builds ) } sort . SliceStable ( slice , less ) if len ( slice ) < count { count = len ( slice ) } return slice [ 0 : count ] }
1879	func ( c * Cluster ) Title ( ) string { return fmt . Sprintf ( "Failure cluster [%s...] failed %d builds, %d jobs, and %d tests over %d days" , c . Identifier [ 0 : 6 ] , c . totalBuilds , c . totalJobs , c . totalTests , c . filer . windowDays , ) }
1880	func ( c * Cluster ) Labels ( ) [ ] string { labels := [ ] string { "kind/flake" } topTests := make ( [ ] string , len ( c . Tests ) ) for i , test := range c . topTestsFailed ( len ( c . Tests ) ) { topTests [ i ] = test . Name } for sig := range c . filer . creator . TestsSIGs ( topTests ) { labels = append ( labels , "sig/" + sig ) } return labels }
1881	func New ( ) * Cron { return & Cron { cronAgent : cron . New ( ) , jobs : map [ string ] * jobStatus { } , logger : logrus . WithField ( "client" , "cron" ) , } }
1882	func ( c * Cron ) QueuedJobs ( ) [ ] string { c . lock . Lock ( ) defer c . lock . Unlock ( ) res := [ ] string { } for k , v := range c . jobs { if v . triggered { res = append ( res , k ) } c . jobs [ k ] . triggered = false } return res }
1883	func ( c * Cron ) HasJob ( name string ) bool { c . lock . Lock ( ) defer c . lock . Unlock ( ) _ , ok := c . jobs [ name ] return ok }
1884	func ( c * Cron ) addJob ( name , cron string ) error { id , err := c . cronAgent . AddFunc ( "TZ=UTC " + cron , func ( ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . jobs [ name ] . triggered = true c . logger . Infof ( "Triggering cron job %s." , name ) } ) if err != nil { return fmt . Errorf ( "cronAgent fails to add job %s with cron %s: %v" , name , cron , err ) } c . jobs [ name ] = & jobStatus { entryID : id , cronStr : cron , triggered : strings . HasPrefix ( cron , "@every" ) , } c . logger . Infof ( "Added new cron job %s with trigger %s." , name , cron ) return nil }
1885	func ( c * Cron ) removeJob ( name string ) error { job , ok := c . jobs [ name ] if ! ok { return fmt . Errorf ( "job %s has not been added to cronAgent yet" , name ) } c . cronAgent . Remove ( job . entryID ) delete ( c . jobs , name ) c . logger . Infof ( "Removed previous cron job %s." , name ) return nil }
1886	func UpdateComments ( issueID int , pullRequest bool , db * gorm . DB , client ClientInterface ) { latest := findLatestCommentUpdate ( issueID , db , client . RepositoryName ( ) ) updateIssueComments ( issueID , latest , db , client ) if pullRequest { updatePullComments ( issueID , latest , db , client ) } }
1887	func GatherProwJobMetrics ( pjs [ ] prowapi . ProwJob ) { metricMap := make ( map [ string ] map [ string ] map [ string ] float64 ) for _ , pj := range pjs { if metricMap [ pj . Spec . Job ] == nil { metricMap [ pj . Spec . Job ] = make ( map [ string ] map [ string ] float64 ) } if metricMap [ pj . Spec . Job ] [ string ( pj . Spec . Type ) ] == nil { metricMap [ pj . Spec . Job ] [ string ( pj . Spec . Type ) ] = make ( map [ string ] float64 ) } metricMap [ pj . Spec . Job ] [ string ( pj . Spec . Type ) ] [ string ( pj . Status . State ) ] ++ } prowJobs . Reset ( ) for job , jobMap := range metricMap { for jobType , typeMap := range jobMap { for state , count := range typeMap { prowJobs . WithLabelValues ( job , jobType , state ) . Set ( count ) } } } }
1888	func optionOrDefault ( option , defaultValue time . Duration ) time . Duration { if option == 0 { return defaultValue } return option }
1889	func newGCSJobSource ( src string ) ( * gcsJobSource , error ) { gcsURL , err := url . Parse ( fmt . Sprintf ( "gs://%s" , src ) ) if err != nil { return & gcsJobSource { } , ErrCannotParseSource } gcsPath := & gcs . Path { } err = gcsPath . SetURL ( gcsURL ) if err != nil { return & gcsJobSource { } , ErrCannotParseSource } tokens := strings . FieldsFunc ( gcsPath . Object ( ) , func ( c rune ) bool { return c == '/' } ) if len ( tokens ) < 2 { return & gcsJobSource { } , ErrCannotParseSource } buildID := tokens [ len ( tokens ) - 1 ] name := tokens [ len ( tokens ) - 2 ] return & gcsJobSource { source : src , linkPrefix : "gs://" , bucket : gcsPath . Bucket ( ) , jobPrefix : path . Clean ( gcsPath . Object ( ) ) + "/" , jobName : name , buildID : buildID , } , nil }
1890	func ( af * GCSArtifactFetcher ) artifacts ( key string ) ( [ ] string , error ) { src , err := newGCSJobSource ( key ) if err != nil { return nil , fmt . Errorf ( "Failed to get GCS job source from %s: %v" , key , err ) } listStart := time . Now ( ) bucketName , prefix := extractBucketPrefixPair ( src . jobPath ( ) ) artifacts := [ ] string { } bkt := af . client . Bucket ( bucketName ) q := storage . Query { Prefix : prefix , Versions : false , } objIter := bkt . Objects ( context . Background ( ) , & q ) wait := [ ] time . Duration { 16 , 32 , 64 , 128 , 256 , 256 , 512 , 512 } for i := 0 ; ; { oAttrs , err := objIter . Next ( ) if err == iterator . Done { break } if err != nil { logrus . WithFields ( fieldsForJob ( src ) ) . WithError ( err ) . Error ( "Error accessing GCS artifact." ) if i >= len ( wait ) { return artifacts , fmt . Errorf ( "timed out: error accessing GCS artifact: %v" , err ) } time . Sleep ( ( wait [ i ] + time . Duration ( rand . Intn ( 10 ) ) ) * time . Millisecond ) i ++ continue } artifacts = append ( artifacts , strings . TrimPrefix ( oAttrs . Name , prefix ) ) i = 0 } listElapsed := time . Since ( listStart ) logrus . WithField ( "duration" , listElapsed ) . Infof ( "Listed %d artifacts." , len ( artifacts ) ) return artifacts , nil }
1891	func ( src * gcsJobSource ) canonicalLink ( ) string { return path . Join ( src . linkPrefix , src . bucket , src . jobPrefix ) }
1892	func ( src * gcsJobSource ) jobPath ( ) string { return fmt . Sprintf ( "%s/%s" , src . bucket , src . jobPrefix ) }
1893	func targetURL ( c config . Getter , pr * PullRequest , log * logrus . Entry ) string { var link string if tideURL := c ( ) . Tide . TargetURL ; tideURL != "" { link = tideURL } else if baseURL := c ( ) . Tide . PRStatusBaseURL ; baseURL != "" { parseURL , err := url . Parse ( baseURL ) if err != nil { log . WithError ( err ) . Error ( "Failed to parse PR status base URL" ) } else { prQuery := fmt . Sprintf ( "is:pr repo:%s author:%s head:%s" , pr . Repository . NameWithOwner , pr . Author . Login , pr . HeadRefName ) values := parseURL . Query ( ) values . Set ( "query" , prQuery ) parseURL . RawQuery = values . Encode ( ) link = parseURL . String ( ) } } return link }
1894	func newBuildConfig ( cfg rest . Config , stop chan struct { } ) ( * buildConfig , error ) { bc , err := buildset . NewForConfig ( & cfg ) if err != nil { return nil , err } _ , err = bc . BuildV1alpha1 ( ) . Builds ( "" ) . List ( metav1 . ListOptions { Limit : 1 } ) if err != nil { return nil , err } bif := buildinfo . NewSharedInformerFactory ( bc , 30 * time . Minute ) bif . Build ( ) . V1alpha1 ( ) . Builds ( ) . Lister ( ) go bif . Start ( stop ) return & buildConfig { client : bc , informer : bif . Build ( ) . V1alpha1 ( ) . Builds ( ) , } , nil }
1895	func NewClient ( token string , dryRun bool ) * Client { httpClient := & http . Client { Transport : & oauth2 . Transport { Base : http . DefaultTransport , Source : oauth2 . ReuseTokenSource ( nil , oauth2 . StaticTokenSource ( & oauth2 . Token { AccessToken : token } ) ) , } , } client := github . NewClient ( httpClient ) return & Client { issueService : client . Issues , prService : client . PullRequests , repoService : client . Repositories , userService : client . Users , retries : 5 , retryInitialBackoff : time . Second , tokenReserve : 50 , dryRun : dryRun , } }
1896	func ( c * Client ) retry ( action string , call func ( ) ( * github . Response , error ) ) ( * github . Response , error ) { var err error var resp * github . Response for retryCount := 0 ; retryCount <= c . retries ; retryCount ++ { if resp , err = call ( ) ; err == nil { c . limitRate ( & resp . Rate ) return resp , nil } switch err := err . ( type ) { case * github . RateLimitError : c . limitRate ( & err . Rate ) case * github . TwoFactorAuthError : return resp , err case * retryAbort : return resp , err } if retryCount == c . retries { return resp , err } glog . Errorf ( "error %s: %v. Will retry.\n" , \n , action ) err } c . sleepForAttempt ( retryCount ) }
1897	func ( c * Client ) depaginate ( action string , opts * github . ListOptions , call func ( ) ( [ ] interface { } , * github . Response , error ) ) ( [ ] interface { } , error ) { var allItems [ ] interface { } wrapper := func ( ) ( * github . Response , error ) { items , resp , err := call ( ) if err == nil { allItems = append ( allItems , items ... ) } return resp , err } opts . Page = 1 opts . PerPage = 100 lastPage := 1 for ; opts . Page <= lastPage ; opts . Page ++ { resp , err := c . retry ( action , wrapper ) if err != nil { return allItems , fmt . Errorf ( "error while depaginating page %d/%d: %v" , opts . Page , lastPage , err ) } if resp . LastPage > 0 { lastPage = resp . LastPage } } return allItems , nil }
1898	func NewHelpAgent ( pa pluginAgent , ghc githubClient ) * HelpAgent { l := logrus . WithField ( "client" , "plugin-help" ) return & HelpAgent { log : l , pa : pa , oa : newOrgAgent ( l , ghc , newRepoDetectionLimit ) , } }
1899	func ( ha * HelpAgent ) GeneratePluginHelp ( ) * pluginhelp . Help { config := ha . pa . Config ( ) orgToRepos := ha . oa . orgToReposMap ( config ) normalRevMap , externalRevMap := reversePluginMaps ( config , orgToRepos ) allPlugins , pluginHelp := ha . generateNormalPluginHelp ( config , normalRevMap ) allExternalPlugins , externalPluginHelp := ha . generateExternalPluginHelp ( config , externalRevMap ) repoPlugins := map [ string ] [ ] string { "" : allPlugins , } for repo , plugins := range config . Plugins { repoPlugins [ repo ] = plugins } repoExternalPlugins := map [ string ] [ ] string { "" : allExternalPlugins , } for repo , exts := range config . ExternalPlugins { for _ , ext := range exts { repoExternalPlugins [ repo ] = append ( repoExternalPlugins [ repo ] , ext . Name ) } } return & pluginhelp . Help { AllRepos : allRepos ( config , orgToRepos ) , RepoPlugins : repoPlugins , RepoExternalPlugins : repoExternalPlugins , PluginHelp : pluginHelp , ExternalPluginHelp : externalPluginHelp , } }
1900	func getPullCommitHash ( pull string ) ( string , error ) { match := pullCommitRe . FindStringSubmatch ( pull ) if len ( match ) != 2 { expected := "branch:hash,pullNumber:hash" return "" , fmt . Errorf ( "unable to parse pull %q (expected %q)" , pull , expected ) } return match [ 1 ] , nil }
1901	func listJobBuilds ( bucket storageBucket , jobPrefixes [ ] string ) [ ] jobBuilds { jobch := make ( chan jobBuilds ) defer close ( jobch ) for i , jobPrefix := range jobPrefixes { go func ( i int , jobPrefix string ) { buildPrefixes , err := bucket . listSubDirs ( jobPrefix ) if err != nil { logrus . WithError ( err ) . Warningf ( "Error getting builds for job %s" , jobPrefix ) } jobch <- jobBuilds { name : path . Base ( jobPrefix ) , buildPrefixes : buildPrefixes , } } ( i , jobPrefix ) } jobs := [ ] jobBuilds { } for range jobPrefixes { job := <- jobch jobs = append ( jobs , job ) } return jobs }
1902	func getPRBuildData ( bucket storageBucket , jobs [ ] jobBuilds ) [ ] buildData { buildch := make ( chan buildData ) defer close ( buildch ) expected := 0 for _ , job := range jobs { for j , buildPrefix := range job . buildPrefixes { go func ( j int , jobName , buildPrefix string ) { build , err := getBuildData ( bucket , buildPrefix ) if err != nil { logrus . WithError ( err ) . Warningf ( "build %s information incomplete" , buildPrefix ) } split := strings . Split ( strings . TrimSuffix ( buildPrefix , "/" ) , "/" ) build . SpyglassLink = path . Join ( spyglassPrefix , bucket . getName ( ) , buildPrefix ) build . ID = split [ len ( split ) - 1 ] build . jobName = jobName build . prefix = buildPrefix build . index = j buildch <- build } ( j , job . name , buildPrefix ) expected ++ } } builds := [ ] buildData { } for k := 0 ; k < expected ; k ++ { build := <- buildch builds = append ( builds , build ) } return builds }
1903	func getGCSDirsForPR ( config * config . Config , org , repo string , pr int ) ( map [ string ] sets . String , error ) { toSearch := make ( map [ string ] sets . String ) fullRepo := org + "/" + repo presubmits , ok := config . Presubmits [ fullRepo ] if ! ok { return toSearch , fmt . Errorf ( "couldn't find presubmits for %q in config" , fullRepo ) } for _ , presubmit := range presubmits { var gcsConfig * v1 . GCSConfiguration if presubmit . DecorationConfig != nil && presubmit . DecorationConfig . GCSConfiguration != nil { gcsConfig = presubmit . DecorationConfig . GCSConfiguration } else { gcsConfig = config . Plank . DefaultDecorationConfig . GCSConfiguration } gcsPath , _ , _ := gcsupload . PathsForJob ( gcsConfig , & downwardapi . JobSpec { Type : v1 . PresubmitJob , Job : presubmit . Name , Refs : & v1 . Refs { Repo : repo , Org : org , Pulls : [ ] v1 . Pull { { Number : pr } , } , } , } , "" ) gcsPath , _ = path . Split ( path . Clean ( gcsPath ) ) if _ , ok := toSearch [ gcsConfig . Bucket ] ; ! ok { toSearch [ gcsConfig . Bucket ] = sets . String { } } toSearch [ gcsConfig . Bucket ] . Insert ( gcsPath ) } return toSearch , nil }
1904	func imageDeleteFromDisk ( fingerprint string ) { fname := shared . VarPath ( "images" , fingerprint ) if shared . PathExists ( fname ) { err := os . Remove ( fname ) if err != nil && ! os . IsNotExist ( err ) { logger . Errorf ( "Error deleting image file %s: %s" , fname , err ) } } fname = shared . VarPath ( "images" , fingerprint ) + ".rootfs" if shared . PathExists ( fname ) { err := os . Remove ( fname ) if err != nil && ! os . IsNotExist ( err ) { logger . Errorf ( "Error deleting image file %s: %s" , fname , err ) } } }
1905	func doNetworksCreate ( d * Daemon , req api . NetworksPost , withDatabase bool ) error { n , err := networkLoadByName ( d . State ( ) , req . Name ) if err != nil { return err } err = n . Start ( ) if err != nil { n . Delete ( withDatabase ) return err } return nil }
1906	func networkLoadByName ( s * state . State , name string ) ( * network , error ) { id , dbInfo , err := s . Cluster . NetworkGet ( name ) if err != nil { return nil , err } n := network { state : s , id : id , name : name , description : dbInfo . Description , config : dbInfo . Config } return & n , nil }
1907	func ( n * Node ) Transaction ( f func ( * NodeTx ) error ) error { nodeTx := & NodeTx { } return query . Transaction ( n . db , func ( tx * sql . Tx ) error { nodeTx . tx = tx return f ( nodeTx ) } ) }
1908	func ForLocalInspectionWithPreparedStmts ( db * sql . DB ) ( * Cluster , error ) { c := ForLocalInspection ( db ) stmts , err := cluster . PrepareStmts ( c . db ) if err != nil { return nil , errors . Wrap ( err , "Prepare database statements" ) } c . stmts = stmts return c , nil }
1909	func ( c * Cluster ) SetDefaultTimeout ( timeout time . Duration ) { driver := c . db . Driver ( ) . ( * dqlite . Driver ) driver . SetContextTimeout ( timeout ) }
1910	func ( c * Cluster ) Transaction ( f func ( * ClusterTx ) error ) error { c . mu . RLock ( ) defer c . mu . RUnlock ( ) return c . transaction ( f ) }
1911	func ( c * Cluster ) EnterExclusive ( ) error { logger . Debug ( "Acquiring exclusive lock on cluster db" ) ch := make ( chan struct { } ) go func ( ) { c . mu . Lock ( ) ch <- struct { } { } } ( ) timeout := 20 * time . Second select { case <- ch : return nil case <- time . After ( timeout ) : return fmt . Errorf ( "timeout (%s)" , timeout ) } }
1912	func ( c * Cluster ) ExitExclusive ( f func ( * ClusterTx ) error ) error { logger . Debug ( "Releasing exclusive lock on cluster db" ) defer c . mu . Unlock ( ) return c . transaction ( f ) }
1913	func ( c * Cluster ) Close ( ) error { for _ , stmt := range c . stmts { stmt . Close ( ) } return c . db . Close ( ) }
1914	func TxCommit ( tx * sql . Tx ) error { err := tx . Commit ( ) if err == nil || err == sql . ErrTxDone { return nil } return err }
1915	func ( c * Config ) ParseRemote ( raw string ) ( string , string , error ) { result := strings . SplitN ( raw , ":" , 2 ) if len ( result ) == 1 { return c . DefaultRemote , raw , nil } _ , ok := c . Remotes [ result [ 0 ] ] if ! ok { if shared . IsSnapshot ( raw ) && shared . IsSnapshot ( result [ 0 ] ) { return c . DefaultRemote , raw , nil } return "" , "" , fmt . Errorf ( "The remote \"%s\" doesn't exist" , \" ) } \" }
1916	func ( c * Config ) GetContainerServer ( name string ) ( lxd . ContainerServer , error ) { remote , ok := c . Remotes [ name ] if ! ok { return nil , fmt . Errorf ( "The remote \"%s\" doesn't exist" , \" ) } \" name if remote . Public || remote . Protocol == "simplestreams" { return nil , fmt . Errorf ( "The remote isn't a private LXD server" ) } args , err := c . getConnectionArgs ( name ) if err != nil { return nil , err } if strings . HasPrefix ( remote . Addr , "unix:" ) { d , err := lxd . ConnectLXDUnix ( strings . TrimPrefix ( strings . TrimPrefix ( remote . Addr , "unix:" ) , "//" ) , args ) if err != nil { return nil , err } if remote . Project != "" && remote . Project != "default" { d = d . UseProject ( remote . Project ) } if c . ProjectOverride != "" { d = d . UseProject ( c . ProjectOverride ) } return d , nil } if remote . AuthType != "candid" && ( args . TLSClientCert == "" || args . TLSClientKey == "" ) { return nil , fmt . Errorf ( "Missing TLS client certificate and key" ) } d , err := lxd . ConnectLXD ( remote . Addr , args ) if err != nil { return nil , err } if remote . Project != "" && remote . Project != "default" { d = d . UseProject ( remote . Project ) } }
1917	func ( c * Config ) GetImageServer ( name string ) ( lxd . ImageServer , error ) { remote , ok := c . Remotes [ name ] if ! ok { return nil , fmt . Errorf ( "The remote \"%s\" doesn't exist" , \" ) } \" name args , err := c . getConnectionArgs ( name ) if err != nil { return nil , err } if strings . HasPrefix ( remote . Addr , "unix:" ) { d , err := lxd . ConnectLXDUnix ( strings . TrimPrefix ( strings . TrimPrefix ( remote . Addr , "unix:" ) , "//" ) , args ) if err != nil { return nil , err } if remote . Project != "" && remote . Project != "default" { d = d . UseProject ( remote . Project ) } if c . ProjectOverride != "" { d = d . UseProject ( c . ProjectOverride ) } return d , nil } if remote . Protocol == "simplestreams" { d , err := lxd . ConnectSimpleStreams ( remote . Addr , args ) if err != nil { return nil , err } return d , nil } if remote . Public { d , err := lxd . ConnectPublicLXD ( remote . Addr , args ) if err != nil { return nil , err } return d , nil } d , err := lxd . ConnectLXD ( remote . Addr , args ) if err != nil { return nil , err } if remote . Project != "" && remote . Project != "default" { d = d . UseProject ( remote . Project ) } }
1918	func ( s * OS ) initAppArmor ( ) { _ , err := exec . LookPath ( "apparmor_parser" ) if os . Getenv ( "LXD_SECURITY_APPARMOR" ) == "false" { logger . Warnf ( "AppArmor support has been manually disabled" ) } else if ! shared . IsDir ( "/sys/kernel/security/apparmor" ) { logger . Warnf ( "AppArmor support has been disabled because of lack of kernel support" ) } else if err != nil { logger . Warnf ( "AppArmor support has been disabled because 'apparmor_parser' couldn't be found" ) } else { s . AppArmorAvailable = true } s . AppArmorStacking = appArmorCanStack ( ) if shared . PathExists ( "/sys/kernel/security/apparmor/.ns_stacked" ) { contentBytes , err := ioutil . ReadFile ( "/sys/kernel/security/apparmor/.ns_stacked" ) if err == nil && string ( contentBytes ) == "yes\n" \n } { s . AppArmorStacked = true } if ! haveMacAdmin ( ) { if s . AppArmorAvailable { logger . Warnf ( "Per-container AppArmor profiles are disabled because the mac_admin capability is missing" ) } } else if s . RunningInUserNS && ! s . AppArmorStacked { if s . AppArmorAvailable { logger . Warnf ( "Per-container AppArmor profiles are disabled because LXD is running in an unprivileged container without stacking" ) } } else { s . AppArmorAdmin = true } profile := util . AppArmorProfile ( ) }
1919	func appArmorCanStack ( ) bool { contentBytes , err := ioutil . ReadFile ( "/sys/kernel/security/apparmor/features/domain/stack" ) if err != nil { return false } if string ( contentBytes ) != "yes\n" \n { return false } contentBytes , err = ioutil . ReadFile ( "/sys/kernel/security/apparmor/features/domain/version" ) if err != nil { return false } content := string ( contentBytes ) parts := strings . Split ( strings . TrimSpace ( content ) , "." ) if len ( parts ) == 0 { logger . Warn ( "Unknown apparmor domain version" , log . Ctx { "version" : content } ) return false } major , err := strconv . Atoi ( parts [ 0 ] ) if err != nil { logger . Warn ( "Unknown apparmor domain version" , log . Ctx { "version" : content } ) return false } minor := 0 if len ( parts ) == 2 { minor , err = strconv . Atoi ( parts [ 1 ] ) if err != nil { logger . Warn ( "Unknown apparmor domain version" , log . Ctx { "version" : content } ) return false } } }
1920	func containerDeviceAdd ( client lxd . ContainerServer , name string , devName string , dev map [ string ] string ) error { container , etag , err := client . GetContainer ( name ) if err != nil { return err } _ , ok := container . Devices [ devName ] if ok { return fmt . Errorf ( i18n . G ( "Device already exists: %s" ) , devName ) } container . Devices [ devName ] = dev op , err := client . UpdateContainer ( name , container . Writable ( ) , etag ) if err != nil { return err } return op . Wait ( ) }
1921	func profileDeviceAdd ( client lxd . ContainerServer , name string , devName string , dev map [ string ] string ) error { profile , profileEtag , err := client . GetProfile ( name ) if err != nil { return err } _ , ok := profile . Devices [ devName ] if ok { return fmt . Errorf ( i18n . G ( "Device already exists: %s" ) , devName ) } profile . Devices [ devName ] = dev err = client . UpdateProfile ( name , profile . Writable ( ) , profileEtag ) if err != nil { return err } return nil }
1922	func ensureImageAliases ( client lxd . ContainerServer , aliases [ ] api . ImageAlias , fingerprint string ) error { if len ( aliases ) == 0 { return nil } names := make ( [ ] string , len ( aliases ) ) for i , alias := range aliases { names [ i ] = alias . Name } sort . Strings ( names ) resp , err := client . GetImageAliases ( ) if err != nil { return err } for _ , alias := range GetExistingAliases ( names , resp ) { err := client . DeleteImageAlias ( alias . Name ) if err != nil { fmt . Println ( fmt . Sprintf ( i18n . G ( "Failed to remove alias %s" ) , alias . Name ) ) } } for _ , alias := range aliases { aliasPost := api . ImageAliasesPost { } aliasPost . Name = alias . Name aliasPost . Target = fingerprint err := client . CreateImageAlias ( aliasPost ) if err != nil { fmt . Println ( fmt . Sprintf ( i18n . G ( "Failed to create alias %s" ) , alias . Name ) ) } } return nil }
1923	func GetExistingAliases ( aliases [ ] string , allAliases [ ] api . ImageAliasesEntry ) [ ] api . ImageAliasesEntry { existing := [ ] api . ImageAliasesEntry { } for _ , alias := range allAliases { name := alias . Name pos := sort . SearchStrings ( aliases , name ) if pos < len ( aliases ) && aliases [ pos ] == name { existing = append ( existing , alias ) } } return existing }
1924	func ( o StatusCode ) String ( ) string { return map [ StatusCode ] string { OperationCreated : "Operation created" , Started : "Started" , Stopped : "Stopped" , Running : "Running" , Cancelling : "Cancelling" , Pending : "Pending" , Success : "Success" , Failure : "Failure" , Cancelled : "Cancelled" , Starting : "Starting" , Stopping : "Stopping" , Aborting : "Aborting" , Freezing : "Freezing" , Frozen : "Frozen" , Thawed : "Thawed" , Error : "Error" , } [ o ] }
1925	func ( c * Cluster ) ImagesGetExpired ( expiry int64 ) ( [ ] string , error ) { q := `SELECT fingerprint, last_use_date, upload_date FROM images WHERE cached=1` var fpStr string var useStr string var uploadStr string inargs := [ ] interface { } { } outfmt := [ ] interface { } { fpStr , useStr , uploadStr } dbResults , err := queryScan ( c . db , q , inargs , outfmt ) if err != nil { return [ ] string { } , err } results := [ ] string { } for _ , r := range dbResults { timestamp := r [ 2 ] if r [ 1 ] != "" { timestamp = r [ 1 ] } var imageExpiry time . Time err = imageExpiry . UnmarshalText ( [ ] byte ( timestamp . ( string ) ) ) if err != nil { return [ ] string { } , err } imageExpiry = imageExpiry . Add ( time . Duration ( expiry * 24 ) * time . Hour ) if imageExpiry . After ( time . Now ( ) ) { continue } results = append ( results , r [ 0 ] . ( string ) ) } return results , nil }
1926	func ( c * Cluster ) ImageSourceInsert ( id int , server string , protocol string , certificate string , alias string ) error { stmt := `INSERT INTO images_source (image_id, server, protocol, certificate, alias) values (?, ?, ?, ?, ?)` protocolInt := - 1 for protoInt , protoString := range ImageSourceProtocol { if protoString == protocol { protocolInt = protoInt } } if protocolInt == - 1 { return fmt . Errorf ( "Invalid protocol: %s" , protocol ) } err := exec ( c . db , stmt , id , server , protocolInt , certificate , alias ) return err }
1927	func ( c * Cluster ) ImageSourceGet ( imageID int ) ( int , api . ImageSource , error ) { q := `SELECT id, server, protocol, certificate, alias FROM images_source WHERE image_id=?` id := 0 protocolInt := - 1 result := api . ImageSource { } arg1 := [ ] interface { } { imageID } arg2 := [ ] interface { } { & id , & result . Server , & protocolInt , & result . Certificate , & result . Alias } err := dbQueryRowScan ( c . db , q , arg1 , arg2 ) if err != nil { if err == sql . ErrNoRows { return - 1 , api . ImageSource { } , ErrNoSuchObject } return - 1 , api . ImageSource { } , err } protocol , found := ImageSourceProtocol [ protocolInt ] if ! found { return - 1 , api . ImageSource { } , fmt . Errorf ( "Invalid protocol: %d" , protocolInt ) } result . Protocol = protocol return id , result , nil }
1928	func ( c * Cluster ) ImageExists ( project string , fingerprint string ) ( bool , error ) { err := c . Transaction ( func ( tx * ClusterTx ) error { enabled , err := tx . ProjectHasImages ( project ) if err != nil { return errors . Wrap ( err , "Check if project has images" ) } if ! enabled { project = "default" } return nil } ) if err != nil { return false , err } var exists bool query := `SELECT COUNT(*) > 0 FROM images JOIN projects ON projects.id = images.project_id WHERE projects.name = ? AND fingerprint=?` inargs := [ ] interface { } { project , fingerprint } outargs := [ ] interface { } { & exists } err = dbQueryRowScan ( c . db , query , inargs , outargs ) if err == sql . ErrNoRows { return exists , ErrNoSuchObject } return exists , err }
1929	func ( c * Cluster ) ImageGet ( project , fingerprint string , public bool , strictMatching bool ) ( int , * api . Image , error ) { err := c . Transaction ( func ( tx * ClusterTx ) error { enabled , err := tx . ProjectHasImages ( project ) if err != nil { return errors . Wrap ( err , "Check if project has images" ) } if ! enabled { project = "default" } return nil } ) if err != nil { return - 1 , nil , err } var create , expire , used , upload * time . Time image := api . Image { } id := - 1 arch := - 1 outfmt := [ ] interface { } { & id , & image . Fingerprint , & image . Filename , & image . Size , & image . Cached , & image . Public , & image . AutoUpdate , & arch , & create , & expire , & used , & upload } inargs := [ ] interface { } { project } query := ` SELECT images.id, fingerprint, filename, size, cached, public, auto_update, architecture, creation_date, expiry_date, last_use_date, upload_date FROM images JOIN projects ON projects.id = images.project_id WHERE projects.name = ?` if strictMatching { inargs = append ( inargs , fingerprint ) query += " AND fingerprint = ?" } else { inargs = append ( inargs , fingerprint + "%" ) query += " AND fingerprint LIKE ?" } if public { query += " AND public=1" } err = dbQueryRowScan ( c . db , query , inargs , outfmt ) if err != nil { if err == sql . ErrNoRows { return - 1 , nil , ErrNoSuchObject } return - 1 , nil , err } if ! strictMatching { query = `SELECT COUNT(images.id) FROM images JOIN projects ON projects.id = images.project_id WHERE projects.name = ? AND fingerprint LIKE ?` count := 0 outfmt := [ ] interface { } { & count } err = dbQueryRowScan ( c . db , query , inargs , outfmt ) if err != nil { return - 1 , nil , err } if count > 1 { return - 1 , nil , fmt . Errorf ( "Partial fingerprint matches more than one image" ) } } err = c . imageFill ( id , & image , create , expire , used , upload , arch ) if err != nil { return - 1 , nil , errors . Wrapf ( err , "Fill image details" ) } return id , & image , nil }
1930	func ( c * Cluster ) ImageGetFromAnyProject ( fingerprint string ) ( int , * api . Image , error ) { var create , expire , used , upload * time . Time image := api . Image { } id := - 1 arch := - 1 outfmt := [ ] interface { } { & id , & image . Fingerprint , & image . Filename , & image . Size , & image . Cached , & image . Public , & image . AutoUpdate , & arch , & create , & expire , & used , & upload } inargs := [ ] interface { } { fingerprint } query := ` SELECT images.id, fingerprint, filename, size, cached, public, auto_update, architecture, creation_date, expiry_date, last_use_date, upload_date FROM images WHERE fingerprint = ? LIMIT 1` err := dbQueryRowScan ( c . db , query , inargs , outfmt ) if err != nil { if err == sql . ErrNoRows { return - 1 , nil , ErrNoSuchObject } return - 1 , nil , err } err = c . imageFill ( id , & image , create , expire , used , upload , arch ) if err != nil { return - 1 , nil , errors . Wrapf ( err , "Fill image details" ) } return id , & image , nil }
1931	func ( c * Cluster ) imageFill ( id int , image * api . Image , create , expire , used , upload * time . Time , arch int ) error { if create != nil { image . CreatedAt = * create } else { image . CreatedAt = time . Time { } } if expire != nil { image . ExpiresAt = * expire } else { image . ExpiresAt = time . Time { } } if used != nil { image . LastUsedAt = * used } else { image . LastUsedAt = time . Time { } } image . Architecture , _ = osarch . ArchitectureName ( arch ) image . UploadedAt = * upload q := "SELECT key, value FROM images_properties where image_id=?" var key , value , name , desc string inargs := [ ] interface { } { id } outfmt := [ ] interface { } { key , value } results , err := queryScan ( c . db , q , inargs , outfmt ) if err != nil { return err } properties := map [ string ] string { } for _ , r := range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) properties [ key ] = value } image . Properties = properties q = "SELECT name, description FROM images_aliases WHERE image_id=?" inargs = [ ] interface { } { id } outfmt = [ ] interface { } { name , desc } results , err = queryScan ( c . db , q , inargs , outfmt ) if err != nil { return err } aliases := [ ] api . ImageAlias { } for _ , r := range results { name = r [ 0 ] . ( string ) desc = r [ 1 ] . ( string ) a := api . ImageAlias { Name : name , Description : desc } aliases = append ( aliases , a ) } image . Aliases = aliases _ , source , err := c . ImageSourceGet ( id ) if err == nil { image . UpdateSource = & source } return nil }
1932	func ( c * Cluster ) ImageLocate ( fingerprint string ) ( string , error ) { stmt := `SELECT nodes.address FROM nodes LEFT JOIN images_nodes ON images_nodes.node_id = nodes.id LEFT JOIN images ON images_nodes.image_id = images.idWHERE images.fingerprint = ?` var localAddress string var addresses [ ] string err := c . Transaction ( func ( tx * ClusterTx ) error { offlineThreshold , err := tx . NodeOfflineThreshold ( ) if err != nil { return err } localAddress , err = tx . NodeAddress ( ) if err != nil { return err } allAddresses , err := query . SelectStrings ( tx . tx , stmt , fingerprint ) if err != nil { return err } for _ , address := range allAddresses { node , err := tx . NodeByAddress ( address ) if err != nil { return err } if address != localAddress && node . IsOffline ( offlineThreshold ) { continue } addresses = append ( addresses , address ) } return err } ) if err != nil { return "" , err } if len ( addresses ) == 0 { return "" , fmt . Errorf ( "image not available on any online node" ) } for _ , address := range addresses { if address == localAddress { return "" , nil } } return addresses [ 0 ] , nil }
1933	func ( c * Cluster ) ImageAssociateNode ( project , fingerprint string ) error { imageID , _ , err := c . ImageGet ( project , fingerprint , false , true ) if err != nil { return err } err = c . Transaction ( func ( tx * ClusterTx ) error { _ , err := tx . tx . Exec ( "INSERT INTO images_nodes(image_id, node_id) VALUES(?, ?)" , imageID , c . nodeID ) return err } ) return err }
1934	func ( c * Cluster ) ImageDelete ( id int ) error { err := exec ( c . db , "DELETE FROM images WHERE id=?" , id ) if err != nil { return err } return nil }
1935	func ( c * Cluster ) ImageAliasesGet ( project string ) ( [ ] string , error ) { err := c . Transaction ( func ( tx * ClusterTx ) error { enabled , err := tx . ProjectHasImages ( project ) if err != nil { return errors . Wrap ( err , "Check if project has images" ) } if ! enabled { project = "default" } return nil } ) if err != nil { return nil , err } q := `SELECT images_aliases.name FROM images_aliases JOIN projects ON projects.id=images_aliases.project_id WHERE projects.name=?` var name string inargs := [ ] interface { } { project } outfmt := [ ] interface { } { name } results , err := queryScan ( c . db , q , inargs , outfmt ) if err != nil { return nil , err } names := [ ] string { } for _ , res := range results { names = append ( names , res [ 0 ] . ( string ) ) } return names , nil }
1936	func ( c * Cluster ) ImageAliasGet ( project , name string , isTrustedClient bool ) ( int , api . ImageAliasesEntry , error ) { id := - 1 entry := api . ImageAliasesEntry { } err := c . Transaction ( func ( tx * ClusterTx ) error { enabled , err := tx . ProjectHasImages ( project ) if err != nil { return errors . Wrap ( err , "Check if project has images" ) } if ! enabled { project = "default" } return nil } ) if err != nil { return id , entry , err } q := `SELECT images_aliases.id, images.fingerprint, images_aliases.description FROM images_aliases INNER JOIN images ON images_aliases.image_id=images.id INNER JOIN projects ON images_aliases.project_id=projects.id WHERE projects.name=? AND images_aliases.name=?` if ! isTrustedClient { q = q + ` AND images.public=1` } var fingerprint , description string arg1 := [ ] interface { } { project , name } arg2 := [ ] interface { } { & id , & fingerprint , & description } err = dbQueryRowScan ( c . db , q , arg1 , arg2 ) if err != nil { if err == sql . ErrNoRows { return - 1 , entry , ErrNoSuchObject } return - 1 , entry , err } entry . Name = name entry . Target = fingerprint entry . Description = description return id , entry , nil }
1937	func ( c * Cluster ) ImageAliasRename ( id int , name string ) error { err := exec ( c . db , "UPDATE images_aliases SET name=? WHERE id=?" , name , id ) return err }
1938	func ( c * Cluster ) ImageAliasDelete ( project , name string ) error { err := c . Transaction ( func ( tx * ClusterTx ) error { enabled , err := tx . ProjectHasImages ( project ) if err != nil { return errors . Wrap ( err , "Check if project has images" ) } if ! enabled { project = "default" } return nil } ) if err != nil { return err } err = exec ( c . db , `DELETE FROM images_aliases WHERE project_id = (SELECT id FROM projects WHERE name = ?) AND name = ?` , project , name ) return err }
1939	func ( c * Cluster ) ImageAliasesMove ( source int , destination int ) error { err := exec ( c . db , "UPDATE images_aliases SET image_id=? WHERE image_id=?" , destination , source ) return err }
1940	func ( c * Cluster ) ImageAliasAdd ( project , name string , imageID int , desc string ) error { err := c . Transaction ( func ( tx * ClusterTx ) error { enabled , err := tx . ProjectHasImages ( project ) if err != nil { return errors . Wrap ( err , "Check if project has images" ) } if ! enabled { project = "default" } return nil } ) if err != nil { return err } stmt := `INSERT INTO images_aliases (name, image_id, description, project_id) VALUES (?, ?, ?, (SELECT id FROM projects WHERE name = ?))` err = exec ( c . db , stmt , name , imageID , desc , project ) return err }
1941	func ( c * Cluster ) ImageAliasUpdate ( id int , imageID int , desc string ) error { stmt := `UPDATE images_aliases SET image_id=?, description=? WHERE id=?` err := exec ( c . db , stmt , imageID , desc , id ) return err }
1942	func ( c * Cluster ) ImageLastAccessUpdate ( fingerprint string , date time . Time ) error { stmt := `UPDATE images SET last_use_date=? WHERE fingerprint=?` err := exec ( c . db , stmt , date , fingerprint ) return err }
1943	func ( c * Cluster ) ImageLastAccessInit ( fingerprint string ) error { stmt := `UPDATE images SET cached=1, last_use_date=strftime("%s") WHERE fingerprint=?` err := exec ( c . db , stmt , fingerprint ) return err }
1944	func ( c * Cluster ) ImageUpdate ( id int , fname string , sz int64 , public bool , autoUpdate bool , architecture string , createdAt time . Time , expiresAt time . Time , properties map [ string ] string ) error { arch , err := osarch . ArchitectureId ( architecture ) if err != nil { arch = 0 } err = c . Transaction ( func ( tx * ClusterTx ) error { publicInt := 0 if public { publicInt = 1 } autoUpdateInt := 0 if autoUpdate { autoUpdateInt = 1 } stmt , err := tx . tx . Prepare ( `UPDATE images SET filename=?, size=?, public=?, auto_update=?, architecture=?, creation_date=?, expiry_date=? WHERE id=?` ) if err != nil { return err } defer stmt . Close ( ) _ , err = stmt . Exec ( fname , sz , publicInt , autoUpdateInt , arch , createdAt , expiresAt , id ) if err != nil { return err } _ , err = tx . tx . Exec ( `DELETE FROM images_properties WHERE image_id=?` , id ) if err != nil { return err } stmt2 , err := tx . tx . Prepare ( `INSERT INTO images_properties (image_id, type, key, value) VALUES (?, ?, ?, ?)` ) if err != nil { return err } defer stmt2 . Close ( ) for key , value := range properties { _ , err = stmt2 . Exec ( id , 0 , key , value ) if err != nil { return err } } return nil } ) return err }
1945	func ( c * Cluster ) ImageInsert ( project , fp string , fname string , sz int64 , public bool , autoUpdate bool , architecture string , createdAt time . Time , expiresAt time . Time , properties map [ string ] string ) error { err := c . Transaction ( func ( tx * ClusterTx ) error { enabled , err := tx . ProjectHasImages ( project ) if err != nil { return errors . Wrap ( err , "Check if project has images" ) } if ! enabled { project = "default" } return nil } ) if err != nil { return err } arch , err := osarch . ArchitectureId ( architecture ) if err != nil { arch = 0 } err = c . Transaction ( func ( tx * ClusterTx ) error { publicInt := 0 if public { publicInt = 1 } autoUpdateInt := 0 if autoUpdate { autoUpdateInt = 1 } stmt , err := tx . tx . Prepare ( `INSERT INTO images (project_id, fingerprint, filename, size, public, auto_update, architecture, creation_date, expiry_date, upload_date) VALUES ((SELECT id FROM projects WHERE name = ?), ?, ?, ?, ?, ?, ?, ?, ?, ?)` ) if err != nil { return err } defer stmt . Close ( ) result , err := stmt . Exec ( project , fp , fname , sz , publicInt , autoUpdateInt , arch , createdAt , expiresAt , time . Now ( ) . UTC ( ) ) if err != nil { return err } id64 , err := result . LastInsertId ( ) if err != nil { return err } id := int ( id64 ) if len ( properties ) > 0 { pstmt , err := tx . tx . Prepare ( `INSERT INTO images_properties (image_id, type, key, value) VALUES (?, 0, ?, ?)` ) if err != nil { return err } defer pstmt . Close ( ) for k , v := range properties { _ , err = pstmt . Exec ( id , k , v ) if err != nil { return err } } } _ , err = tx . tx . Exec ( "INSERT INTO images_nodes(image_id, node_id) VALUES(?, ?)" , id , c . nodeID ) if err != nil { return err } return nil } ) return err }
1946	func ( c * Cluster ) ImageGetPools ( imageFingerprint string ) ( [ ] int64 , error ) { poolID := int64 ( - 1 ) query := "SELECT storage_pool_id FROM storage_volumes WHERE node_id=? AND name=? AND type=?" inargs := [ ] interface { } { c . nodeID , imageFingerprint , StoragePoolVolumeTypeImage } outargs := [ ] interface { } { poolID } result , err := queryScan ( c . db , query , inargs , outargs ) if err != nil { return [ ] int64 { } , err } poolIDs := [ ] int64 { } for _ , r := range result { poolIDs = append ( poolIDs , r [ 0 ] . ( int64 ) ) } return poolIDs , nil }
1947	func ( c * Cluster ) ImageGetPoolNamesFromIDs ( poolIDs [ ] int64 ) ( [ ] string , error ) { var poolName string query := "SELECT name FROM storage_pools WHERE id=?" poolNames := [ ] string { } for _ , poolID := range poolIDs { inargs := [ ] interface { } { poolID } outargs := [ ] interface { } { poolName } result , err := queryScan ( c . db , query , inargs , outargs ) if err != nil { return [ ] string { } , err } for _ , r := range result { poolNames = append ( poolNames , r [ 0 ] . ( string ) ) } } return poolNames , nil }
1948	func ( c * Cluster ) ImageUploadedAt ( id int , uploadedAt time . Time ) error { err := exec ( c . db , "UPDATE images SET upload_date=? WHERE id=?" , uploadedAt , id ) return err }
1949	func ( c * Cluster ) ImagesGetOnCurrentNode ( ) ( map [ string ] [ ] string , error ) { return c . ImagesGetByNodeID ( c . nodeID ) }
1950	func ( c * Cluster ) ImagesGetByNodeID ( id int64 ) ( map [ string ] [ ] string , error ) { images := make ( map [ string ] [ ] string ) err := c . Transaction ( func ( tx * ClusterTx ) error { stmt := ` SELECT images.fingerprint, projects.name FROM images LEFT JOIN images_nodes ON images.id = images_nodes.image_id LEFT JOIN nodes ON images_nodes.node_id = nodes.id LEFT JOIN projects ON images.project_id = projects.id WHERE nodes.id = ? ` rows , err := tx . tx . Query ( stmt , id ) if err != nil { return err } var fingerprint string var projectName string for rows . Next ( ) { err := rows . Scan ( & fingerprint , & projectName ) if err != nil { return err } images [ fingerprint ] = append ( images [ fingerprint ] , projectName ) } return rows . Err ( ) } ) return images , err }
1951	func ( c * Cluster ) ImageGetNodesWithImage ( fingerprint string ) ( [ ] string , error ) { q := `SELECT DISTINCT nodes.address FROM nodes LEFT JOIN images_nodes ON images_nodes.node_id = nodes.id LEFT JOIN images ON images_nodes.image_id = images.idWHERE images.fingerprint = ? ` return c . getNodesByImageFingerprint ( q , fingerprint ) }
1952	func ( c * Cluster ) ImageGetNodesWithoutImage ( fingerprint string ) ( [ ] string , error ) { q := `SELECT DISTINCT nodes.address FROM nodes WHERE nodes.address NOT IN ( SELECT DISTINCT nodes.address FROM nodes LEFT JOIN images_nodes ON images_nodes.node_id = nodes.id LEFT JOIN images ON images_nodes.image_id = images.id WHERE images.fingerprint = ?)` return c . getNodesByImageFingerprint ( q , fingerprint ) }
1953	func ( g * Group ) Add ( f Func , schedule Schedule ) * Task { i := len ( g . tasks ) g . tasks = append ( g . tasks , Task { f : f , schedule : schedule , reset : make ( chan struct { } , 16 ) , } ) return & g . tasks [ i ] }
1954	func ( g * Group ) Start ( ) { ctx := context . Background ( ) ctx , g . cancel = context . WithCancel ( ctx ) g . wg . Add ( len ( g . tasks ) ) g . mu . Lock ( ) if g . running == nil { g . running = make ( map [ int ] bool ) } g . mu . Unlock ( ) for i := range g . tasks { g . mu . Lock ( ) if g . running [ i ] { g . mu . Unlock ( ) continue } g . running [ i ] = true task := g . tasks [ i ] g . mu . Unlock ( ) go func ( i int ) { task . loop ( ctx ) g . wg . Done ( ) g . mu . Lock ( ) g . running [ i ] = false g . mu . Unlock ( ) } ( i ) } }
1955	func zfsIsEnabled ( ) bool { out , err := exec . LookPath ( "zfs" ) if err != nil || len ( out ) == 0 { return false } return true }
1956	func zfsToolVersionGet ( ) ( string , error ) { out , err := shared . RunCommand ( "dpkg-query" , "--showformat=${Version}" , "--show" , "zfsutils-linux" ) if err != nil { return "" , err } return strings . TrimSpace ( string ( out ) ) , nil }
1957	func zfsModuleVersionGet ( ) ( string , error ) { var zfsVersion string if shared . PathExists ( "/sys/module/zfs/version" ) { out , err := ioutil . ReadFile ( "/sys/module/zfs/version" ) if err != nil { return "" , fmt . Errorf ( "Could not determine ZFS module version" ) } zfsVersion = string ( out ) } else { out , err := shared . RunCommand ( "modinfo" , "-F" , "version" , "zfs" ) if err != nil { return "" , fmt . Errorf ( "Could not determine ZFS module version" ) } zfsVersion = out } return strings . TrimSpace ( zfsVersion ) , nil }
1958	func zfsPoolVolumeCreate ( dataset string , properties ... string ) ( string , error ) { cmd := [ ] string { "zfs" , "create" } for _ , prop := range properties { cmd = append ( cmd , [ ] string { "-o" , prop } ... ) } cmd = append ( cmd , [ ] string { "-p" , dataset } ... ) return shared . RunCommand ( cmd [ 0 ] , cmd [ 1 : ] ... ) }
1959	func zfsPoolVolumeExists ( dataset string ) ( bool , error ) { output , err := shared . RunCommand ( "zfs" , "list" , "-Ho" , "name" ) if err != nil { return false , err } for _ , name := range strings . Split ( output , "\n" ) \n { if name == dataset { return true , nil } } }
1960	func ( c * ClusterTx ) NetworkIDsNotPending ( ) ( map [ string ] int64 , error ) { networks := [ ] struct { id int64 name string } { } dest := func ( i int ) [ ] interface { } { networks = append ( networks , struct { id int64 name string } { } ) return [ ] interface { } { & networks [ i ] . id , & networks [ i ] . name } } stmt , err := c . tx . Prepare ( "SELECT id, name FROM networks WHERE NOT state=?" ) if err != nil { return nil , err } defer stmt . Close ( ) err = query . SelectObjects ( stmt , dest , networkPending ) if err != nil { return nil , err } ids := map [ string ] int64 { } for _ , network := range networks { ids [ network . name ] = network . id } return ids , nil }
1961	func ( c * ClusterTx ) NetworkConfigAdd ( networkID , nodeID int64 , config map [ string ] string ) error { return networkConfigAdd ( c . tx , networkID , nodeID , config ) }
1962	func ( c * ClusterTx ) NetworkNodeJoin ( networkID , nodeID int64 ) error { columns := [ ] string { "network_id" , "node_id" } values := [ ] interface { } { networkID , nodeID } _ , err := query . UpsertObject ( c . tx , "networks_nodes" , columns , values ) return err }
1963	func ( c * ClusterTx ) NetworkCreatePending ( node , name string , conf map [ string ] string ) error { network := struct { id int64 state int } { } var errConsistency error dest := func ( i int ) [ ] interface { } { if i != 0 { errConsistency = fmt . Errorf ( "more than one network exists with the given name" ) } return [ ] interface { } { & network . id , & network . state } } stmt , err := c . tx . Prepare ( "SELECT id, state FROM networks WHERE name=?" ) if err != nil { return err } defer stmt . Close ( ) err = query . SelectObjects ( stmt , dest , name ) if err != nil { return err } if errConsistency != nil { return errConsistency } var networkID = network . id if networkID == 0 { columns := [ ] string { "name" } values := [ ] interface { } { name } networkID , err = query . UpsertObject ( c . tx , "networks" , columns , values ) if err != nil { return err } } else { if network . state != networkPending { return fmt . Errorf ( "network is not in pending state" ) } } nodeInfo , err := c . NodeByName ( node ) if err != nil { return err } count , err := query . Count ( c . tx , "networks_nodes" , "network_id=? AND node_id=?" , networkID , nodeInfo . ID ) if err != nil { return err } if count != 0 { return ErrAlreadyDefined } columns := [ ] string { "network_id" , "node_id" } values := [ ] interface { } { networkID , nodeInfo . ID } _ , err = query . UpsertObject ( c . tx , "networks_nodes" , columns , values ) if err != nil { return err } err = c . NetworkConfigAdd ( networkID , nodeInfo . ID , conf ) if err != nil { return err } return nil }
1964	func ( c * ClusterTx ) NetworkCreated ( name string ) error { return c . networkState ( name , networkCreated ) }
1965	func ( c * ClusterTx ) NetworkErrored ( name string ) error { return c . networkState ( name , networkErrored ) }
1966	func ( c * Cluster ) NetworkGet ( name string ) ( int64 , * api . Network , error ) { description := sql . NullString { } id := int64 ( - 1 ) state := 0 q := "SELECT id, description, state FROM networks WHERE name=?" arg1 := [ ] interface { } { name } arg2 := [ ] interface { } { & id , & description , & state } err := dbQueryRowScan ( c . db , q , arg1 , arg2 ) if err != nil { if err == sql . ErrNoRows { return - 1 , nil , ErrNoSuchObject } return - 1 , nil , err } config , err := c . NetworkConfigGet ( id ) if err != nil { return - 1 , nil , err } network := api . Network { Name : name , Managed : true , Type : "bridge" , } network . Description = description . String network . Config = config switch state { case networkPending : network . Status = "Pending" case networkCreated : network . Status = "Created" default : network . Status = "Unknown" } nodes , err := c . networkNodes ( id ) if err != nil { return - 1 , nil , err } network . Locations = nodes return id , & network , nil }
1967	func ( c * Cluster ) networkNodes ( networkID int64 ) ( [ ] string , error ) { stmt := `SELECT nodes.name FROM nodes JOIN networks_nodes ON networks_nodes.node_id = nodes.id WHERE networks_nodes.network_id = ?` var nodes [ ] string err := c . Transaction ( func ( tx * ClusterTx ) error { var err error nodes , err = query . SelectStrings ( tx . tx , stmt , networkID ) return err } ) if err != nil { return nil , err } return nodes , nil }
1968	func ( c * Cluster ) NetworkGetInterface ( devName string ) ( int64 , * api . Network , error ) { id := int64 ( - 1 ) name := "" value := "" q := "SELECT networks.id, networks.name, networks_config.value FROM networks LEFT JOIN networks_config ON networks.id=networks_config.network_id WHERE networks_config.key=\"bridge.external_interfaces\" AND networks_config.node_id=?" \" \" arg1 := [ ] interface { } { c . nodeID } arg2 := [ ] interface { } { id , name , value } result , err := queryScan ( c . db , q , arg1 , arg2 ) if err != nil { return - 1 , nil , err } for _ , r := range result { for _ , entry := range strings . Split ( r [ 2 ] . ( string ) , "," ) { entry = strings . TrimSpace ( entry ) if entry == devName { id = r [ 0 ] . ( int64 ) name = r [ 1 ] . ( string ) } } } if id == - 1 { return - 1 , nil , fmt . Errorf ( "No network found for interface: %s" , devName ) } config , err := c . NetworkConfigGet ( id ) if err != nil { return - 1 , nil , err } network := api . Network { Name : name , Managed : true , Type : "bridge" , } }
1969	func ( c * Cluster ) NetworkConfigGet ( id int64 ) ( map [ string ] string , error ) { var key , value string query := ` SELECT key, value FROM networks_config WHERE network_id=? AND (node_id=? OR node_id IS NULL)` inargs := [ ] interface { } { id , c . nodeID } outfmt := [ ] interface { } { key , value } results , err := queryScan ( c . db , query , inargs , outfmt ) if err != nil { return nil , fmt . Errorf ( "Failed to get network '%d'" , id ) } if len ( results ) == 0 { query := "SELECT id FROM networks WHERE id=?" var r int results , err := queryScan ( c . db , query , [ ] interface { } { id } , [ ] interface { } { r } ) if err != nil { return nil , err } if len ( results ) == 0 { return nil , ErrNoSuchObject } } config := map [ string ] string { } for _ , r := range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) config [ key ] = value } return config , nil }
1970	func ( c * Cluster ) NetworkCreate ( name , description string , config map [ string ] string ) ( int64 , error ) { var id int64 err := c . Transaction ( func ( tx * ClusterTx ) error { result , err := tx . tx . Exec ( "INSERT INTO networks (name, description, state) VALUES (?, ?, ?)" , name , description , networkCreated ) if err != nil { return err } id , err := result . LastInsertId ( ) if err != nil { return err } columns := [ ] string { "network_id" , "node_id" } values := [ ] interface { } { id , c . nodeID } _ , err = query . UpsertObject ( tx . tx , "networks_nodes" , columns , values ) if err != nil { return err } err = networkConfigAdd ( tx . tx , id , c . nodeID , config ) if err != nil { return err } return nil } ) if err != nil { id = - 1 } return id , err }
1971	func ( c * Cluster ) NetworkUpdate ( name , description string , config map [ string ] string ) error { id , _ , err := c . NetworkGet ( name ) if err != nil { return err } err = c . Transaction ( func ( tx * ClusterTx ) error { err = NetworkUpdateDescription ( tx . tx , id , description ) if err != nil { return err } err = NetworkConfigClear ( tx . tx , id , c . nodeID ) if err != nil { return err } err = networkConfigAdd ( tx . tx , id , c . nodeID , config ) if err != nil { return err } return nil } ) return err }
1972	func NetworkUpdateDescription ( tx * sql . Tx , id int64 , description string ) error { _ , err := tx . Exec ( "UPDATE networks SET description=? WHERE id=?" , description , id ) return err }
1973	func NetworkConfigClear ( tx * sql . Tx , networkID , nodeID int64 ) error { _ , err := tx . Exec ( "DELETE FROM networks_config WHERE network_id=? AND (node_id=? OR node_id IS NULL)" , networkID , nodeID ) if err != nil { return err } return nil }
1974	func ( c * Cluster ) NetworkDelete ( name string ) error { id , _ , err := c . NetworkGet ( name ) if err != nil { return err } err = exec ( c . db , "DELETE FROM networks WHERE id=?" , id ) if err != nil { return err } return nil }
1975	func ( c * Cluster ) NetworkRename ( oldName string , newName string ) error { id , _ , err := c . NetworkGet ( oldName ) if err != nil { return err } err = c . Transaction ( func ( tx * ClusterTx ) error { _ , err = tx . tx . Exec ( "UPDATE networks SET name=? WHERE id=?" , newName , id ) return err } ) return err }
1976	func ( r * ProtocolLXD ) GetContainers ( ) ( [ ] api . Container , error ) { containers := [ ] api . Container { } _ , err := r . queryStruct ( "GET" , "/containers?recursion=1" , nil , "" , & containers ) if err != nil { return nil , err } return containers , nil }
1977	func ( r * ProtocolLXD ) GetContainersFull ( ) ( [ ] api . ContainerFull , error ) { containers := [ ] api . ContainerFull { } if ! r . HasExtension ( "container_full" ) { return nil , fmt . Errorf ( "The server is missing the required \"container_full\" API extension" ) } \" \" _ , err := r . queryStruct ( "GET" , "/containers?recursion=2" , nil , "" , & containers ) }
1978	func ( r * ProtocolLXD ) GetContainer ( name string ) ( * api . Container , string , error ) { container := api . Container { } etag , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/containers/%s" , url . QueryEscape ( name ) ) , nil , "" , & container ) if err != nil { return nil , "" , err } return & container , etag , nil }
1979	func ( r * ProtocolLXD ) CreateContainerFromBackup ( args ContainerBackupArgs ) ( Operation , error ) { if ! r . HasExtension ( "container_backup" ) { return nil , fmt . Errorf ( "The server is missing the required \"container_backup\" API extension" ) } \" \" if args . PoolName == "" { op , _ , err := r . queryOperation ( "POST" , "/containers" , args . BackupFile , "" ) if err != nil { return nil , err } return op , nil } if ! r . HasExtension ( "container_backup_override_pool" ) { return nil , fmt . Errorf ( "The server is missing the required \"container_backup_override_pool\" API extension" ) } \" \" reqURL , err := r . setQueryAttributes ( fmt . Sprintf ( "%s/1.0/containers" , r . httpHost ) ) if err != nil { return nil , err } req , err := http . NewRequest ( "POST" , reqURL , args . BackupFile ) if err != nil { return nil , err } req . Header . Set ( "Content-Type" , "application/octet-stream" ) req . Header . Set ( "X-LXD-pool" , args . PoolName ) if r . httpUserAgent != "" { req . Header . Set ( "User-Agent" , r . httpUserAgent ) } resp , err := r . do ( req ) if err != nil { return nil , err } defer resp . Body . Close ( ) response , _ , err := lxdParseResponse ( resp ) if err != nil { return nil , err } }
1980	func ( r * ProtocolLXD ) CreateContainer ( container api . ContainersPost ) ( Operation , error ) { if container . Source . ContainerOnly { if ! r . HasExtension ( "container_only_migration" ) { return nil , fmt . Errorf ( "The server is missing the required \"container_only_migration\" API extension" ) } } \" \" op , _ , err := r . queryOperation ( "POST" , "/containers" , container , "" ) }
1981	func ( r * ProtocolLXD ) CreateContainerFromImage ( source ImageServer , image api . Image , req api . ContainersPost ) ( RemoteOperation , error ) { req . Source . Type = "image" if r == source { req . Source . Fingerprint = image . Fingerprint req . Source . Alias = "" op , err := r . CreateContainer ( req ) if err != nil { return nil , err } rop := remoteOperation { targetOp : op , chDone : make ( chan bool ) , } go func ( ) { rop . err = rop . targetOp . Wait ( ) close ( rop . chDone ) } ( ) return & rop , nil } req . Source . Mode = "pull" if req . Source . Alias != "" && image . Public { req . Source . Fingerprint = "" } else { req . Source . Fingerprint = image . Fingerprint req . Source . Alias = "" } info , err := source . GetConnectionInfo ( ) if err != nil { return nil , err } req . Source . Protocol = info . Protocol req . Source . Certificate = info . Certificate if ! image . Public { secret , err := source . GetImageSecret ( image . Fingerprint ) if err != nil { return nil , err } req . Source . Secret = secret } return r . tryCreateContainer ( req , info . Addresses ) }
1982	func ( r * ProtocolLXD ) UpdateContainer ( name string , container api . ContainerPut , ETag string ) ( Operation , error ) { op , _ , err := r . queryOperation ( "PUT" , fmt . Sprintf ( "/containers/%s" , url . QueryEscape ( name ) ) , container , ETag ) if err != nil { return nil , err } return op , nil }
1983	func ( r * ProtocolLXD ) RenameContainer ( name string , container api . ContainerPost ) ( Operation , error ) { if container . Migration { return nil , fmt . Errorf ( "Can't ask for a migration through RenameContainer" ) } op , _ , err := r . queryOperation ( "POST" , fmt . Sprintf ( "/containers/%s" , url . QueryEscape ( name ) ) , container , "" ) if err != nil { return nil , err } return op , nil }
1984	func ( r * ProtocolLXD ) ExecContainer ( containerName string , exec api . ContainerExecPost , args * ContainerExecArgs ) ( Operation , error ) { if exec . RecordOutput { if ! r . HasExtension ( "container_exec_recording" ) { return nil , fmt . Errorf ( "The server is missing the required \"container_exec_recording\" API extension" ) } } \" \" op , _ , err := r . queryOperation ( "POST" , fmt . Sprintf ( "/containers/%s/exec" , url . QueryEscape ( containerName ) ) , exec , "" ) if err != nil { return nil , err } opAPI := op . Get ( ) }
1985	func ( r * ProtocolLXD ) GetContainerFile ( containerName string , path string ) ( io . ReadCloser , * ContainerFileResponse , error ) { requestURL , err := shared . URLEncode ( fmt . Sprintf ( "%s/1.0/containers/%s/files" , r . httpHost , url . QueryEscape ( containerName ) ) , map [ string ] string { "path" : path } ) if err != nil { return nil , nil , err } requestURL , err = r . setQueryAttributes ( requestURL ) if err != nil { return nil , nil , err } req , err := http . NewRequest ( "GET" , requestURL , nil ) if err != nil { return nil , nil , err } if r . httpUserAgent != "" { req . Header . Set ( "User-Agent" , r . httpUserAgent ) } resp , err := r . do ( req ) if err != nil { return nil , nil , err } if resp . StatusCode != http . StatusOK { _ , _ , err := lxdParseResponse ( resp ) if err != nil { return nil , nil , err } } uid , gid , mode , fileType , _ := shared . ParseLXDFileHeaders ( resp . Header ) fileResp := ContainerFileResponse { UID : uid , GID : gid , Mode : mode , Type : fileType , } if fileResp . Type == "directory" { response := api . Response { } decoder := json . NewDecoder ( resp . Body ) err = decoder . Decode ( & response ) if err != nil { return nil , nil , err } entries := [ ] string { } err = response . MetadataAsStruct ( & entries ) if err != nil { return nil , nil , err } fileResp . Entries = entries return nil , & fileResp , err } return resp . Body , & fileResp , err }
1986	func ( r * ProtocolLXD ) CreateContainerFile ( containerName string , path string , args ContainerFileArgs ) error { if args . Type == "directory" { if ! r . HasExtension ( "directory_manipulation" ) { return fmt . Errorf ( "The server is missing the required \"directory_manipulation\" API extension" ) } } \" \" if args . Type == "symlink" { if ! r . HasExtension ( "file_symlinks" ) { return fmt . Errorf ( "The server is missing the required \"file_symlinks\" API extension" ) } } \" \" if args . WriteMode == "append" { if ! r . HasExtension ( "file_append" ) { return fmt . Errorf ( "The server is missing the required \"file_append\" API extension" ) } } \" \" requestURL := fmt . Sprintf ( "%s/1.0/containers/%s/files?path=%s" , r . httpHost , url . QueryEscape ( containerName ) , url . QueryEscape ( path ) ) requestURL , err := r . setQueryAttributes ( requestURL ) if err != nil { return err } req , err := http . NewRequest ( "POST" , requestURL , args . Content ) if err != nil { return err } if r . httpUserAgent != "" { req . Header . Set ( "User-Agent" , r . httpUserAgent ) } if args . UID > - 1 { req . Header . Set ( "X-LXD-uid" , fmt . Sprintf ( "%d" , args . UID ) ) } if args . GID > - 1 { req . Header . Set ( "X-LXD-gid" , fmt . Sprintf ( "%d" , args . GID ) ) } if args . Mode > - 1 { req . Header . Set ( "X-LXD-mode" , fmt . Sprintf ( "%04o" , args . Mode ) ) } if args . Type != "" { req . Header . Set ( "X-LXD-type" , args . Type ) } }
1987	func ( r * ProtocolLXD ) DeleteContainerFile ( containerName string , path string ) error { if ! r . HasExtension ( "file_delete" ) { return fmt . Errorf ( "The server is missing the required \"file_delete\" API extension" ) } \" \" _ , _ , err := r . query ( "DELETE" , fmt . Sprintf ( "/containers/%s/files?path=%s" , url . QueryEscape ( containerName ) , url . QueryEscape ( path ) ) , nil , "" ) }
1988	func ( r * ProtocolLXD ) GetContainerSnapshotNames ( containerName string ) ( [ ] string , error ) { urls := [ ] string { } _ , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/containers/%s/snapshots" , url . QueryEscape ( containerName ) ) , nil , "" , & urls ) if err != nil { return nil , err } names := [ ] string { } for _ , uri := range urls { fields := strings . Split ( uri , fmt . Sprintf ( "/containers/%s/snapshots/" , url . QueryEscape ( containerName ) ) ) names = append ( names , fields [ len ( fields ) - 1 ] ) } return names , nil }
1989	func ( r * ProtocolLXD ) GetContainerSnapshots ( containerName string ) ( [ ] api . ContainerSnapshot , error ) { snapshots := [ ] api . ContainerSnapshot { } _ , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/containers/%s/snapshots?recursion=1" , url . QueryEscape ( containerName ) ) , nil , "" , & snapshots ) if err != nil { return nil , err } return snapshots , nil }
1990	func ( r * ProtocolLXD ) GetContainerSnapshot ( containerName string , name string ) ( * api . ContainerSnapshot , string , error ) { snapshot := api . ContainerSnapshot { } etag , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/containers/%s/snapshots/%s" , url . QueryEscape ( containerName ) , url . QueryEscape ( name ) ) , nil , "" , & snapshot ) if err != nil { return nil , "" , err } return & snapshot , etag , nil }
1991	func ( r * ProtocolLXD ) CreateContainerSnapshot ( containerName string , snapshot api . ContainerSnapshotsPost ) ( Operation , error ) { if snapshot . ExpiresAt != nil && ! r . HasExtension ( "snapshot_expiry_creation" ) { return nil , fmt . Errorf ( "The server is missing the required \"snapshot_expiry_creation\" API extension" ) } \" \" op , _ , err := r . queryOperation ( "POST" , fmt . Sprintf ( "/containers/%s/snapshots" , url . QueryEscape ( containerName ) ) , snapshot , "" ) }
1992	func ( r * ProtocolLXD ) MigrateContainerSnapshot ( containerName string , name string , container api . ContainerSnapshotPost ) ( Operation , error ) { if ! container . Migration { return nil , fmt . Errorf ( "Can't ask for a rename through MigrateContainerSnapshot" ) } op , _ , err := r . queryOperation ( "POST" , fmt . Sprintf ( "/containers/%s/snapshots/%s" , url . QueryEscape ( containerName ) , url . QueryEscape ( name ) ) , container , "" ) if err != nil { return nil , err } return op , nil }
1993	func ( r * ProtocolLXD ) UpdateContainerSnapshot ( containerName string , name string , container api . ContainerSnapshotPut , ETag string ) ( Operation , error ) { if ! r . HasExtension ( "snapshot_expiry" ) { return nil , fmt . Errorf ( "The server is missing the required \"snapshot_expiry\" API extension" ) } \" \" op , _ , err := r . queryOperation ( "PUT" , fmt . Sprintf ( "/containers/%s/snapshots/%s" , url . QueryEscape ( containerName ) , url . QueryEscape ( name ) ) , container , ETag ) }
1994	func ( r * ProtocolLXD ) GetContainerState ( name string ) ( * api . ContainerState , string , error ) { state := api . ContainerState { } etag , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/containers/%s/state" , url . QueryEscape ( name ) ) , nil , "" , & state ) if err != nil { return nil , "" , err } return & state , etag , nil }
1995	func ( r * ProtocolLXD ) UpdateContainerState ( name string , state api . ContainerStatePut , ETag string ) ( Operation , error ) { op , _ , err := r . queryOperation ( "PUT" , fmt . Sprintf ( "/containers/%s/state" , url . QueryEscape ( name ) ) , state , ETag ) if err != nil { return nil , err } return op , nil }
1996	func ( r * ProtocolLXD ) GetContainerLogfiles ( name string ) ( [ ] string , error ) { urls := [ ] string { } _ , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/containers/%s/logs" , url . QueryEscape ( name ) ) , nil , "" , & urls ) if err != nil { return nil , err } logfiles := [ ] string { } for _ , uri := range logfiles { fields := strings . Split ( uri , fmt . Sprintf ( "/containers/%s/logs/" , url . QueryEscape ( name ) ) ) logfiles = append ( logfiles , fields [ len ( fields ) - 1 ] ) } return logfiles , nil }
1997	func ( r * ProtocolLXD ) GetContainerLogfile ( name string , filename string ) ( io . ReadCloser , error ) { url := fmt . Sprintf ( "%s/1.0/containers/%s/logs/%s" , r . httpHost , url . QueryEscape ( name ) , url . QueryEscape ( filename ) ) url , err := r . setQueryAttributes ( url ) if err != nil { return nil , err } req , err := http . NewRequest ( "GET" , url , nil ) if err != nil { return nil , err } if r . httpUserAgent != "" { req . Header . Set ( "User-Agent" , r . httpUserAgent ) } resp , err := r . do ( req ) if err != nil { return nil , err } if resp . StatusCode != http . StatusOK { _ , _ , err := lxdParseResponse ( resp ) if err != nil { return nil , err } } return resp . Body , err }
1998	func ( r * ProtocolLXD ) GetContainerMetadata ( name string ) ( * api . ImageMetadata , string , error ) { if ! r . HasExtension ( "container_edit_metadata" ) { return nil , "" , fmt . Errorf ( "The server is missing the required \"container_edit_metadata\" API extension" ) } \" \" metadata := api . ImageMetadata { } url := fmt . Sprintf ( "/containers/%s/metadata" , url . QueryEscape ( name ) ) etag , err := r . queryStruct ( "GET" , url , nil , "" , & metadata ) }
1999	func ( r * ProtocolLXD ) SetContainerMetadata ( name string , metadata api . ImageMetadata , ETag string ) error { if ! r . HasExtension ( "container_edit_metadata" ) { return fmt . Errorf ( "The server is missing the required \"container_edit_metadata\" API extension" ) } \" \" url := fmt . Sprintf ( "/containers/%s/metadata" , url . QueryEscape ( name ) ) _ , _ , err := r . query ( "PUT" , url , metadata , ETag ) }
2000	func ( r * ProtocolLXD ) GetContainerTemplateFiles ( containerName string ) ( [ ] string , error ) { if ! r . HasExtension ( "container_edit_metadata" ) { return nil , fmt . Errorf ( "The server is missing the required \"container_edit_metadata\" API extension" ) } \" \" templates := [ ] string { } url := fmt . Sprintf ( "/containers/%s/metadata/templates" , url . QueryEscape ( containerName ) ) _ , err := r . queryStruct ( "GET" , url , nil , "" , & templates ) }
2001	func ( r * ProtocolLXD ) CreateContainerTemplateFile ( containerName string , templateName string , content io . ReadSeeker ) error { return r . setContainerTemplateFile ( containerName , templateName , content , "POST" ) }
2002	func ( r * ProtocolLXD ) DeleteContainerTemplateFile ( name string , templateName string ) error { if ! r . HasExtension ( "container_edit_metadata" ) { return fmt . Errorf ( "The server is missing the required \"container_edit_metadata\" API extension" ) } \" \" }
2003	func ( r * ProtocolLXD ) ConsoleContainer ( containerName string , console api . ContainerConsolePost , args * ContainerConsoleArgs ) ( Operation , error ) { if ! r . HasExtension ( "console" ) { return nil , fmt . Errorf ( "The server is missing the required \"console\" API extension" ) } \" \" op , _ , err := r . queryOperation ( "POST" , fmt . Sprintf ( "/containers/%s/console" , url . QueryEscape ( containerName ) ) , console , "" ) if err != nil { return nil , err } opAPI := op . Get ( ) if args == nil || args . Terminal == nil { return nil , fmt . Errorf ( "A terminal must be set" ) } if args . Control == nil { return nil , fmt . Errorf ( "A control channel must be set" ) } fds := map [ string ] string { } value , ok := opAPI . Metadata [ "fds" ] if ok { values := value . ( map [ string ] interface { } ) for k , v := range values { fds [ k ] = v . ( string ) } } var controlConn * websocket . Conn if fds [ "control" ] == "" { return nil , fmt . Errorf ( "Did not receive a file descriptor for the control channel" ) } controlConn , err = r . GetOperationWebsocket ( opAPI . ID , fds [ "control" ] ) if err != nil { return nil , err } go args . Control ( controlConn ) conn , err := r . GetOperationWebsocket ( opAPI . ID , fds [ "0" ] ) if err != nil { return nil , err } go func ( consoleDisconnect <- chan bool ) { <- consoleDisconnect msg := websocket . FormatCloseMessage ( websocket . CloseNormalClosure , "Detaching from console" ) controlConn . WriteMessage ( websocket . CloseMessage , msg ) controlConn . Close ( ) } ( args . ConsoleDisconnect ) }
2004	func ( r * ProtocolLXD ) GetContainerConsoleLog ( containerName string , args * ContainerConsoleLogArgs ) ( io . ReadCloser , error ) { if ! r . HasExtension ( "console" ) { return nil , fmt . Errorf ( "The server is missing the required \"console\" API extension" ) } \" \" url := fmt . Sprintf ( "%s/1.0/containers/%s/console" , r . httpHost , url . QueryEscape ( containerName ) ) url , err := r . setQueryAttributes ( url ) if err != nil { return nil , err } req , err := http . NewRequest ( "GET" , url , nil ) if err != nil { return nil , err } if r . httpUserAgent != "" { req . Header . Set ( "User-Agent" , r . httpUserAgent ) } resp , err := r . do ( req ) if err != nil { return nil , err } }
2005	func ( r * ProtocolLXD ) DeleteContainerConsoleLog ( containerName string , args * ContainerConsoleLogArgs ) error { if ! r . HasExtension ( "console" ) { return fmt . Errorf ( "The server is missing the required \"console\" API extension" ) } \" \" _ , _ , err := r . query ( "DELETE" , fmt . Sprintf ( "/containers/%s/console" , url . QueryEscape ( containerName ) ) , nil , "" ) }
2006	func ( r * ProtocolLXD ) GetContainerBackups ( containerName string ) ( [ ] api . ContainerBackup , error ) { if ! r . HasExtension ( "container_backup" ) { return nil , fmt . Errorf ( "The server is missing the required \"container_backup\" API extension" ) } \" \" backups := [ ] api . ContainerBackup { } _ , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/containers/%s/backups?recursion=1" , url . QueryEscape ( containerName ) ) , nil , "" , & backups ) }
2007	func ( r * ProtocolLXD ) GetContainerBackup ( containerName string , name string ) ( * api . ContainerBackup , string , error ) { if ! r . HasExtension ( "container_backup" ) { return nil , "" , fmt . Errorf ( "The server is missing the required \"container_backup\" API extension" ) } \" \" backup := api . ContainerBackup { } etag , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/containers/%s/backups/%s" , url . QueryEscape ( containerName ) , url . QueryEscape ( name ) ) , nil , "" , & backup ) }
2008	func ( r * ProtocolLXD ) CreateContainerBackup ( containerName string , backup api . ContainerBackupsPost ) ( Operation , error ) { if ! r . HasExtension ( "container_backup" ) { return nil , fmt . Errorf ( "The server is missing the required \"container_backup\" API extension" ) } \" \" op , _ , err := r . queryOperation ( "POST" , fmt . Sprintf ( "/containers/%s/backups" , url . QueryEscape ( containerName ) ) , backup , "" ) }
2009	func ( r * ProtocolLXD ) RenameContainerBackup ( containerName string , name string , backup api . ContainerBackupPost ) ( Operation , error ) { if ! r . HasExtension ( "container_backup" ) { return nil , fmt . Errorf ( "The server is missing the required \"container_backup\" API extension" ) } \" \" op , _ , err := r . queryOperation ( "POST" , fmt . Sprintf ( "/containers/%s/backups/%s" , url . QueryEscape ( containerName ) , url . QueryEscape ( name ) ) , backup , "" ) }
2010	func ( r * ProtocolLXD ) DeleteContainerBackup ( containerName string , name string ) ( Operation , error ) { if ! r . HasExtension ( "container_backup" ) { return nil , fmt . Errorf ( "The server is missing the required \"container_backup\" API extension" ) } \" \" op , _ , err := r . queryOperation ( "DELETE" , fmt . Sprintf ( "/containers/%s/backups/%s" , url . QueryEscape ( containerName ) , url . QueryEscape ( name ) ) , nil , "" ) }
2011	func ( r * ProtocolLXD ) GetContainerBackupFile ( containerName string , name string , req * BackupFileRequest ) ( * BackupFileResponse , error ) { if ! r . HasExtension ( "container_backup" ) { return nil , fmt . Errorf ( "The server is missing the required \"container_backup\" API extension" ) } \" \" uri := fmt . Sprintf ( "%s/1.0/containers/%s/backups/%s/export" , r . httpHost , url . QueryEscape ( containerName ) , url . QueryEscape ( name ) ) if r . project != "" { uri += fmt . Sprintf ( "?project=%s" , url . QueryEscape ( r . project ) ) } request , err := http . NewRequest ( "GET" , uri , nil ) if err != nil { return nil , err } if r . httpUserAgent != "" { request . Header . Set ( "User-Agent" , r . httpUserAgent ) } response , doneCh , err := cancel . CancelableDownload ( req . Canceler , r . http , request ) if err != nil { return nil , err } defer response . Body . Close ( ) defer close ( doneCh ) if response . StatusCode != http . StatusOK { _ , _ , err := lxdParseResponse ( response ) if err != nil { return nil , err } } body := response . Body if req . ProgressHandler != nil { body = & ioprogress . ProgressReader { ReadCloser : response . Body , Tracker : & ioprogress . ProgressTracker { Length : response . ContentLength , Handler : func ( percent int64 , speed int64 ) { req . ProgressHandler ( ioprogress . ProgressData { Text : fmt . Sprintf ( "%d%% (%s/s)" , percent , shared . GetByteSizeString ( speed , 2 ) ) } ) } , } , } } size , err := io . Copy ( req . BackupFile , body ) if err != nil { return nil , err } resp := BackupFileResponse { } }
2012	func RsyncSend ( name string , path string , conn * websocket . Conn , readWrapper func ( io . ReadCloser ) io . ReadCloser , features [ ] string , bwlimit string , execPath string ) error { cmd , dataSocket , stderr , err := rsyncSendSetup ( name , path , bwlimit , execPath , features ) if err != nil { return err } if dataSocket != nil { defer dataSocket . Close ( ) } readPipe := io . ReadCloser ( dataSocket ) if readWrapper != nil { readPipe = readWrapper ( dataSocket ) } readDone , writeDone := shared . WebsocketMirror ( conn , dataSocket , readPipe , nil , nil ) chError := make ( chan error , 1 ) go func ( ) { err = cmd . Wait ( ) if err != nil { dataSocket . Close ( ) readPipe . Close ( ) } chError <- err } ( ) output , err := ioutil . ReadAll ( stderr ) if err != nil { cmd . Process . Kill ( ) } err = <- chError if err != nil { logger . Errorf ( "Rsync send failed: %s: %s: %s" , path , err , string ( output ) ) } <- readDone <- writeDone return err }
2013	func patchesGetNames ( ) [ ] string { names := make ( [ ] string , len ( patches ) ) for i , patch := range patches { names [ i ] = patch . name } return names }
2014	func patchRenameCustomVolumeLVs ( name string , d * Daemon ) error { pools , _ := d . cluster . StoragePools ( ) for _ , poolName := range pools { poolID , pool , err := d . cluster . StoragePoolGet ( poolName ) if err != nil { return err } sType , err := storageStringToType ( pool . Driver ) if err != nil { return err } if sType != storageTypeLvm { continue } volumes , err := d . cluster . StoragePoolNodeVolumesGetType ( storagePoolVolumeTypeCustom , poolID ) if err != nil { return err } vgName := poolName if pool . Config [ "lvm.vg_name" ] != "" { vgName = pool . Config [ "lvm.vg_name" ] } for _ , volume := range volumes { oldName := fmt . Sprintf ( "%s/custom_%s" , vgName , volume ) newName := fmt . Sprintf ( "%s/custom_%s" , vgName , containerNameToLVName ( volume ) ) exists , err := storageLVExists ( newName ) if err != nil { return err } if exists || oldName == newName { continue } err = lvmLVRename ( vgName , oldName , newName ) if err != nil { return err } logger . Info ( "Successfully renamed LV" , log . Ctx { "old_name" : oldName , "new_name" : newName } ) } } return nil }
2015	func patchLvmNodeSpecificConfigKeys ( name string , d * Daemon ) error { tx , err := d . cluster . Begin ( ) if err != nil { return errors . Wrap ( err , "failed to begin transaction" ) } nodeIDs , err := query . SelectIntegers ( tx , "SELECT id FROM nodes" ) if err != nil { return errors . Wrap ( err , "failed to get IDs of current nodes" ) } poolIDs , err := query . SelectIntegers ( tx , "SELECT id FROM storage_pools WHERE driver='lvm'" ) if err != nil { return errors . Wrap ( err , "failed to get IDs of current lvm pools" ) } for _ , poolID := range poolIDs { config , err := query . SelectConfig ( tx , "storage_pools_config" , "storage_pool_id=? AND node_id IS NULL" , poolID ) if err != nil { return errors . Wrap ( err , "failed to fetch of lvm pool config" ) } for _ , key := range [ ] string { "lvm.thinpool_name" , "lvm.vg_name" } { value , ok := config [ key ] if ! ok { continue } _ , err = tx . Exec ( `DELETE FROM storage_pools_config WHERE key=? AND storage_pool_id=? AND node_id IS NULL` , key , poolID ) if err != nil { return errors . Wrapf ( err , "failed to delete %s config" , key ) } for _ , nodeID := range nodeIDs { _ , err := tx . Exec ( `INSERT INTO storage_pools_config(storage_pool_id, node_id, key, value) VALUES(?, ?, ?, ?)` , poolID , nodeID , key , value ) if err != nil { return errors . Wrapf ( err , "failed to create %s node config" , key ) } } } } err = tx . Commit ( ) if err != nil { return errors . Wrap ( err , "failed to commit transaction" ) } return err }
2016	func ( r * ProtocolLXD ) GetHTTPClient ( ) ( * http . Client , error ) { if r . http == nil { return nil , fmt . Errorf ( "HTTP client isn't set, bad connection" ) } return r . http , nil }
2017	func ( r * ProtocolLXD ) do ( req * http . Request ) ( * http . Response , error ) { if r . bakeryClient != nil { r . addMacaroonHeaders ( req ) return r . bakeryClient . Do ( req ) } return r . http . Do ( req ) }
2018	func ( r * ProtocolLXD ) RawQuery ( method string , path string , data interface { } , ETag string ) ( * api . Response , string , error ) { url := fmt . Sprintf ( "%s%s" , r . httpHost , path ) return r . rawQuery ( method , url , data , ETag ) }
2019	func ( r * ProtocolLXD ) RawWebsocket ( path string ) ( * websocket . Conn , error ) { return r . websocket ( path ) }
2020	func ( r * ProtocolLXD ) RawOperation ( method string , path string , data interface { } , ETag string ) ( Operation , string , error ) { return r . queryOperation ( method , path , data , ETag ) }
2021	func ProfileToAPI ( profile * Profile ) * api . Profile { p := & api . Profile { Name : profile . Name , UsedBy : profile . UsedBy , } p . Description = profile . Description p . Config = profile . Config p . Devices = profile . Devices return p }
2022	func ( c * Cluster ) Profiles ( project string ) ( [ ] string , error ) { err := c . Transaction ( func ( tx * ClusterTx ) error { enabled , err := tx . ProjectHasProfiles ( project ) if err != nil { return errors . Wrap ( err , "Check if project has profiles" ) } if ! enabled { project = "default" } return nil } ) if err != nil { return nil , err } q := fmt . Sprintf ( `SELECT profiles.name FROM profiles JOIN projects ON projects.id = profiles.project_idWHERE projects.name = ?` ) inargs := [ ] interface { } { project } var name string outfmt := [ ] interface { } { name } result , err := queryScan ( c . db , q , inargs , outfmt ) if err != nil { return [ ] string { } , err } response := [ ] string { } for _ , r := range result { response = append ( response , r [ 0 ] . ( string ) ) } return response , nil }
2023	func ( c * Cluster ) ProfileGet ( project , name string ) ( int64 , * api . Profile , error ) { var result * api . Profile var id int64 err := c . Transaction ( func ( tx * ClusterTx ) error { enabled , err := tx . ProjectHasProfiles ( project ) if err != nil { return errors . Wrap ( err , "Check if project has profiles" ) } if ! enabled { project = "default" } profile , err := tx . ProfileGet ( project , name ) if err != nil { return err } result = ProfileToAPI ( profile ) id = int64 ( profile . ID ) return nil } ) if err != nil { return - 1 , nil , err } return id , result , nil }
2024	func ( c * Cluster ) ProfilesGet ( project string , names [ ] string ) ( [ ] api . Profile , error ) { profiles := make ( [ ] api . Profile , len ( names ) ) err := c . Transaction ( func ( tx * ClusterTx ) error { enabled , err := tx . ProjectHasProfiles ( project ) if err != nil { return errors . Wrap ( err , "Check if project has profiles" ) } if ! enabled { project = "default" } for i , name := range names { profile , err := tx . ProfileGet ( project , name ) if err != nil { return errors . Wrapf ( err , "Load profile %q" , name ) } profiles [ i ] = * ProfileToAPI ( profile ) } return nil } ) if err != nil { return nil , err } return profiles , nil }
2025	func ( c * Cluster ) ProfileConfig ( project , name string ) ( map [ string ] string , error ) { err := c . Transaction ( func ( tx * ClusterTx ) error { enabled , err := tx . ProjectHasProfiles ( project ) if err != nil { return errors . Wrap ( err , "Check if project has profiles" ) } if ! enabled { project = "default" } return nil } ) if err != nil { return nil , err } var key , value string query := ` SELECT key, value FROM profiles_config JOIN profiles ON profiles_config.profile_id=profiles.id JOIN projects ON projects.id = profiles.project_id WHERE projects.name=? AND profiles.name=?` inargs := [ ] interface { } { project , name } outfmt := [ ] interface { } { key , value } results , err := queryScan ( c . db , query , inargs , outfmt ) if err != nil { return nil , errors . Wrapf ( err , "Failed to get profile '%s'" , name ) } if len ( results ) == 0 { query := "SELECT id FROM profiles WHERE name=?" var id int results , err := queryScan ( c . db , query , [ ] interface { } { name } , [ ] interface { } { id } ) if err != nil { return nil , err } if len ( results ) == 0 { return nil , ErrNoSuchObject } } config := map [ string ] string { } for _ , r := range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) config [ key ] = value } return config , nil }
2026	func ProfileConfigClear ( tx * sql . Tx , id int64 ) error { _ , err := tx . Exec ( "DELETE FROM profiles_config WHERE profile_id=?" , id ) if err != nil { return err } _ , err = tx . Exec ( `DELETE FROM profiles_devices_config WHERE id IN (SELECT profiles_devices_config.id FROM profiles_devices_config JOIN profiles_devices ON profiles_devices_config.profile_device_id=profiles_devices.id WHERE profiles_devices.profile_id=?)` , id ) if err != nil { return err } _ , err = tx . Exec ( "DELETE FROM profiles_devices WHERE profile_id=?" , id ) if err != nil { return err } return nil }
2027	func ProfileConfigAdd ( tx * sql . Tx , id int64 , config map [ string ] string ) error { str := fmt . Sprintf ( "INSERT INTO profiles_config (profile_id, key, value) VALUES(?, ?, ?)" ) stmt , err := tx . Prepare ( str ) defer stmt . Close ( ) if err != nil { return err } for k , v := range config { if v == "" { continue } _ , err = stmt . Exec ( id , k , v ) if err != nil { return err } } return nil }
2028	func ( c * Cluster ) ProfileContainersGet ( project , profile string ) ( map [ string ] [ ] string , error ) { err := c . Transaction ( func ( tx * ClusterTx ) error { enabled , err := tx . ProjectHasProfiles ( project ) if err != nil { return errors . Wrap ( err , "Check if project has profiles" ) } if ! enabled { project = "default" } return nil } ) if err != nil { return nil , err } q := `SELECT containers.name, projects.name FROM containers JOIN containers_profiles ON containers.id == containers_profiles.container_id JOIN projects ON projects.id == containers.project_id WHERE containers_profiles.profile_id == (SELECT profiles.id FROM profiles JOIN projects ON projects.id == profiles.project_id WHERE profiles.name=? AND projects.name=?) AND containers.type == 0` results := map [ string ] [ ] string { } inargs := [ ] interface { } { profile , project } var name string outfmt := [ ] interface { } { name , name } output , err := queryScan ( c . db , q , inargs , outfmt ) if err != nil { return nil , err } for _ , r := range output { if results [ r [ 1 ] . ( string ) ] == nil { results [ r [ 1 ] . ( string ) ] = [ ] string { } } results [ r [ 1 ] . ( string ) ] = append ( results [ r [ 1 ] . ( string ) ] , r [ 0 ] . ( string ) ) } return results , nil }
2029	func ( c * Cluster ) ProfileCleanupLeftover ( ) error { stmt := `DELETE FROM profiles_config WHERE profile_id NOT IN (SELECT id FROM profiles);DELETE FROM profiles_devices WHERE profile_id NOT IN (SELECT id FROM profiles);DELETE FROM profiles_devices_config WHERE profile_device_id NOT IN (SELECT id FROM profiles_devices);` err := exec ( c . db , stmt ) if err != nil { return err } return nil }
2030	func ProfilesExpandConfig ( config map [ string ] string , profiles [ ] api . Profile ) map [ string ] string { expandedConfig := map [ string ] string { } profileConfigs := make ( [ ] map [ string ] string , len ( profiles ) ) for i , profile := range profiles { profileConfigs [ i ] = profile . Config } for i := range profileConfigs { for k , v := range profileConfigs [ i ] { expandedConfig [ k ] = v } } for k , v := range config { expandedConfig [ k ] = v } return expandedConfig }
2031	func ProfilesExpandDevices ( devices types . Devices , profiles [ ] api . Profile ) types . Devices { expandedDevices := types . Devices { } profileDevices := make ( [ ] types . Devices , len ( profiles ) ) for i , profile := range profiles { profileDevices [ i ] = profile . Devices } for i := range profileDevices { for k , v := range profileDevices [ i ] { expandedDevices [ k ] = v } } for k , v := range devices { expandedDevices [ k ] = v } return expandedDevices }
2032	func ( r * ProtocolLXD ) GetServer ( ) ( * api . Server , string , error ) { server := api . Server { } etag , err := r . queryStruct ( "GET" , "" , nil , "" , & server ) if err != nil { return nil , "" , err } if server . Environment . CertificateFingerprint == "" && server . Environment . Certificate != "" { var err error server . Environment . CertificateFingerprint , err = shared . CertFingerprintStr ( server . Environment . Certificate ) if err != nil { return nil , "" , err } } if ! server . Public && len ( server . AuthMethods ) == 0 { server . AuthMethods = [ ] string { "tls" } } r . server = & server return & server , etag , nil }
2033	func ( r * ProtocolLXD ) UpdateServer ( server api . ServerPut , ETag string ) error { _ , _ , err := r . query ( "PUT" , "" , server , ETag ) if err != nil { return err } return nil }
2034	func ( r * ProtocolLXD ) HasExtension ( extension string ) bool { if r . server == nil { return true } for _ , entry := range r . server . APIExtensions { if entry == extension { return true } } return false }
2035	func ( r * ProtocolLXD ) GetServerResources ( ) ( * api . Resources , error ) { if ! r . HasExtension ( "resources" ) { return nil , fmt . Errorf ( "The server is missing the required \"resources\" API extension" ) } \" \" resources := api . Resources { } _ , err := r . queryStruct ( "GET" , "/resources" , nil , "" , & resources ) }
2036	func ( r * ProtocolLXD ) UseProject ( name string ) ContainerServer { return & ProtocolLXD { server : r . server , http : r . http , httpCertificate : r . httpCertificate , httpHost : r . httpHost , httpProtocol : r . httpProtocol , httpUserAgent : r . httpUserAgent , bakeryClient : r . bakeryClient , bakeryInteractor : r . bakeryInteractor , requireAuthenticated : r . requireAuthenticated , clusterTarget : r . clusterTarget , project : name , } }
2037	func sqliteOpen ( path string ) ( * sql . DB , error ) { timeout := 5 openPath := fmt . Sprintf ( "%s?_busy_timeout=%d&_txlock=exclusive" , path , timeout * 1000 ) return sql . Open ( "sqlite3_with_fk" , openPath ) }
2038	func Rebalance ( state * state . State , gateway * Gateway ) ( string , [ ] db . RaftNode , error ) { currentRaftNodes , err := gateway . currentRaftNodes ( ) if err != nil { return "" , nil , errors . Wrap ( err , "failed to get current raft nodes" ) } if len ( currentRaftNodes ) >= membershipMaxRaftNodes { return "" , nil , nil } currentRaftAddresses := make ( [ ] string , len ( currentRaftNodes ) ) for i , node := range currentRaftNodes { currentRaftAddresses [ i ] = node . Address } address := "" err = state . Cluster . Transaction ( func ( tx * db . ClusterTx ) error { config , err := ConfigLoad ( tx ) if err != nil { return errors . Wrap ( err , "failed load cluster configuration" ) } nodes , err := tx . Nodes ( ) if err != nil { return errors . Wrap ( err , "failed to get cluster nodes" ) } for _ , node := range nodes { if shared . StringInSlice ( node . Address , currentRaftAddresses ) { continue } if node . IsOffline ( config . OfflineThreshold ( ) ) { continue } logger . Debugf ( "Found spare node %s (%s) to be promoted as database node" , node . Name , node . Address ) address = node . Address break } return nil } ) if err != nil { return "" , nil , err } if address == "" { return "" , nil , nil } updatedRaftNodes := currentRaftNodes err = gateway . db . Transaction ( func ( tx * db . NodeTx ) error { id , err := tx . RaftNodeAdd ( address ) if err != nil { return errors . Wrap ( err , "failed to add new raft node" ) } updatedRaftNodes = append ( updatedRaftNodes , db . RaftNode { ID : id , Address : address } ) err = tx . RaftNodesReplace ( updatedRaftNodes ) if err != nil { return errors . Wrap ( err , "failed to update raft nodes" ) } return nil } ) if err != nil { return "" , nil , err } return address , updatedRaftNodes , nil }
2039	func Promote ( state * state . State , gateway * Gateway , nodes [ ] db . RaftNode ) error { logger . Info ( "Promote node to database node" ) if gateway . IsDatabaseNode ( ) { return fmt . Errorf ( "this node is already a database node" ) } address := "" err := state . Cluster . Transaction ( func ( tx * db . ClusterTx ) error { var err error address , err = tx . NodeAddress ( ) if err != nil { return errors . Wrap ( err , "failed to fetch the address of this node" ) } return nil } ) if err != nil { return err } if address == "" { return fmt . Errorf ( "node is not exposed on the network" ) } id := "" target := "" for _ , node := range nodes { if node . Address == address { id = strconv . Itoa ( int ( node . ID ) ) } else { target = node . Address } } if id == "" { return fmt . Errorf ( "this node is not included in the given list of database nodes" ) } err = state . Node . Transaction ( func ( tx * db . NodeTx ) error { err = tx . RaftNodesReplace ( nodes ) if err != nil { return errors . Wrap ( err , "failed to set raft nodes" ) } return nil } ) if err != nil { return err } err = state . Cluster . EnterExclusive ( ) if err != nil { return errors . Wrap ( err , "failed to acquire cluster database lock" ) } err = os . RemoveAll ( state . OS . GlobalDatabaseDir ( ) ) if err != nil { return errors . Wrap ( err , "failed to remove existing raft data" ) } err = gateway . init ( ) if err != nil { return errors . Wrap ( err , "failed to re-initialize gRPC SQL gateway" ) } logger . Info ( "Joining dqlite raft cluster" , log15 . Ctx { "id" : id , "address" : address , "target" : target } ) changer := gateway . raft . MembershipChanger ( ) err = changer . Join ( raft . ServerID ( id ) , raft . ServerAddress ( target ) , 5 * time . Second ) if err != nil { return err } err = state . Cluster . ExitExclusive ( func ( tx * db . ClusterTx ) error { _ , err := tx . Nodes ( ) return err } ) if err != nil { return errors . Wrap ( err , "cluster database initialization failed" ) } return nil }
2040	func Purge ( cluster * db . Cluster , name string ) error { logger . Debugf ( "Remove node %s from the database" , name ) return cluster . Transaction ( func ( tx * db . ClusterTx ) error { node , err := tx . NodeByName ( name ) if err != nil { return errors . Wrapf ( err , "failed to get node %s" , name ) } err = tx . NodeClear ( node . ID ) if err != nil { return errors . Wrapf ( err , "failed to clear node %s" , name ) } err = tx . NodeRemove ( node . ID ) if err != nil { return errors . Wrapf ( err , "failed to remove node %s" , name ) } return nil } ) }
2041	func List ( state * state . State ) ( [ ] api . ClusterMember , error ) { addresses := [ ] string { } err := state . Node . Transaction ( func ( tx * db . NodeTx ) error { nodes , err := tx . RaftNodes ( ) if err != nil { return errors . Wrap ( err , "failed to fetch current raft nodes" ) } for _ , node := range nodes { addresses = append ( addresses , node . Address ) } return nil } ) if err != nil { return nil , err } var nodes [ ] db . NodeInfo var offlineThreshold time . Duration err = state . Cluster . Transaction ( func ( tx * db . ClusterTx ) error { nodes , err = tx . Nodes ( ) if err != nil { return err } offlineThreshold , err = tx . NodeOfflineThreshold ( ) if err != nil { return err } return nil } ) if err != nil { return nil , err } result := make ( [ ] api . ClusterMember , len ( nodes ) ) now := time . Now ( ) version := nodes [ 0 ] . Version ( ) for i , node := range nodes { result [ i ] . ServerName = node . Name result [ i ] . URL = fmt . Sprintf ( "https://%s" , node . Address ) result [ i ] . Database = shared . StringInSlice ( node . Address , addresses ) if node . IsOffline ( offlineThreshold ) { result [ i ] . Status = "Offline" result [ i ] . Message = fmt . Sprintf ( "no heartbeat since %s" , now . Sub ( node . Heartbeat ) ) } else { result [ i ] . Status = "Online" result [ i ] . Message = "fully operational" } n , err := util . CompareVersions ( version , node . Version ( ) ) if err != nil { result [ i ] . Status = "Broken" result [ i ] . Message = "inconsistent version" continue } if n == 1 { version = node . Version ( ) } } for i , node := range nodes { if result [ i ] . Status != "Online" { continue } n , err := util . CompareVersions ( version , node . Version ( ) ) if err != nil { continue } if n == 2 { result [ i ] . Status = "Blocked" result [ i ] . Message = "waiting for other nodes to be upgraded" } } return result , nil }
2042	func Count ( state * state . State ) ( int , error ) { var count int err := state . Cluster . Transaction ( func ( tx * db . ClusterTx ) error { var err error count , err = tx . NodesCount ( ) return err } ) return count , err }
2043	func Enabled ( node * db . Node ) ( bool , error ) { enabled := false err := node . Transaction ( func ( tx * db . NodeTx ) error { addresses , err := tx . RaftNodeAddresses ( ) if err != nil { return err } enabled = len ( addresses ) > 0 return nil } ) return enabled , err }
2044	func membershipCheckNodeStateForBootstrapOrJoin ( tx * db . NodeTx , address string ) error { nodes , err := tx . RaftNodes ( ) if err != nil { return errors . Wrap ( err , "failed to fetch current raft nodes" ) } hasClusterAddress := address != "" hasRaftNodes := len ( nodes ) > 0 if ! hasClusterAddress && hasRaftNodes { return fmt . Errorf ( "inconsistent state: found leftover entries in raft_nodes" ) } if ! hasClusterAddress { return fmt . Errorf ( "no cluster.https_address config is set on this node" ) } if hasRaftNodes { return fmt . Errorf ( "the node is already part of a cluster" ) } return nil }
2045	func membershipCheckClusterStateForBootstrapOrJoin ( tx * db . ClusterTx ) error { nodes , err := tx . Nodes ( ) if err != nil { return errors . Wrap ( err , "failed to fetch current cluster nodes" ) } if len ( nodes ) != 1 { return fmt . Errorf ( "inconsistent state: found leftover entries in nodes" ) } return nil }
2046	func membershipCheckClusterStateForAccept ( tx * db . ClusterTx , name string , address string , schema int , api int ) error { nodes , err := tx . Nodes ( ) if err != nil { return errors . Wrap ( err , "failed to fetch current cluster nodes" ) } if len ( nodes ) == 1 && nodes [ 0 ] . Address == "0.0.0.0" { return fmt . Errorf ( "clustering not enabled" ) } for _ , node := range nodes { if node . Name == name { return fmt . Errorf ( "cluster already has node with name %s" , name ) } if node . Address == address { return fmt . Errorf ( "cluster already has node with address %s" , address ) } if node . Schema != schema { return fmt . Errorf ( "schema version mismatch: cluster has %d" , node . Schema ) } if node . APIExtensions != api { return fmt . Errorf ( "API version mismatch: cluster has %d" , node . APIExtensions ) } } return nil }
2047	func membershipCheckClusterStateForLeave ( tx * db . ClusterTx , nodeID int64 ) error { message , err := tx . NodeIsEmpty ( nodeID ) if err != nil { return err } if message != "" { return fmt . Errorf ( message ) } nodes , err := tx . Nodes ( ) if err != nil { return err } if len ( nodes ) == 1 { return fmt . Errorf ( "node is the only node in the cluster" ) } return nil }
2048	func membershipCheckNoLeftoverClusterCert ( dir string ) error { for _ , basename := range [ ] string { "cluster.crt" , "cluster.key" , "cluster.ca" } { if shared . PathExists ( filepath . Join ( dir , basename ) ) { return fmt . Errorf ( "inconsistent state: found leftover cluster certificate" ) } } return nil }
2049	func ConfigLoad ( tx * db . NodeTx ) ( * Config , error ) { values , err := tx . Config ( ) if err != nil { return nil , fmt . Errorf ( "cannot fetch node config from database: %v" , err ) } m , err := config . SafeLoad ( ConfigSchema , values ) if err != nil { return nil , fmt . Errorf ( "failed to load node config: %v" , err ) } return & Config { tx : tx , m : m } , nil }
2050	func ( c * Config ) Replace ( values map [ string ] interface { } ) ( map [ string ] string , error ) { return c . update ( values ) }
2051	func ( c * Config ) Patch ( patch map [ string ] interface { } ) ( map [ string ] string , error ) { values := c . Dump ( ) for name , value := range patch { values [ name ] = value } return c . update ( values ) }
2052	func HTTPSAddress ( node * db . Node ) ( string , error ) { var config * Config err := node . Transaction ( func ( tx * db . NodeTx ) error { var err error config , err = ConfigLoad ( tx ) return err } ) if err != nil { return "" , err } return config . HTTPSAddress ( ) , nil }
2053	func ( c * Cluster ) CertificatesGet ( ) ( certs [ ] * CertInfo , err error ) { err = c . Transaction ( func ( tx * ClusterTx ) error { rows , err := tx . tx . Query ( "SELECT id, fingerprint, type, name, certificate FROM certificates" , ) if err != nil { return err } defer rows . Close ( ) for rows . Next ( ) { cert := new ( CertInfo ) rows . Scan ( & cert . ID , & cert . Fingerprint , & cert . Type , & cert . Name , & cert . Certificate , ) certs = append ( certs , cert ) } return rows . Err ( ) } ) if err != nil { return certs , err } return certs , nil }
2054	func ( c * Cluster ) CertificateGet ( fingerprint string ) ( cert * CertInfo , err error ) { cert = new ( CertInfo ) inargs := [ ] interface { } { fingerprint + "%" } outfmt := [ ] interface { } { & cert . ID , & cert . Fingerprint , & cert . Type , & cert . Name , & cert . Certificate , } query := ` SELECT id, fingerprint, type, name, certificate FROM certificates WHERE fingerprint LIKE ?` if err = dbQueryRowScan ( c . db , query , inargs , outfmt ) ; err != nil { if err == sql . ErrNoRows { return nil , ErrNoSuchObject } return nil , err } return cert , err }
2055	func ( c * Cluster ) CertSave ( cert * CertInfo ) error { err := c . Transaction ( func ( tx * ClusterTx ) error { stmt , err := tx . tx . Prepare ( ` INSERT INTO certificates ( fingerprint, type, name, certificate ) VALUES (?, ?, ?, ?)` , ) if err != nil { return err } defer stmt . Close ( ) _ , err = stmt . Exec ( cert . Fingerprint , cert . Type , cert . Name , cert . Certificate , ) if err != nil { return err } return nil } ) return err }
2056	func ( c * Cluster ) CertDelete ( fingerprint string ) error { err := exec ( c . db , "DELETE FROM certificates WHERE fingerprint=?" , fingerprint ) if err != nil { return err } return nil }
2057	func ( c * Cluster ) CertUpdate ( fingerprint string , certName string , certType int ) error { err := c . Transaction ( func ( tx * ClusterTx ) error { _ , err := tx . tx . Exec ( "UPDATE certificates SET name=?, type=? WHERE fingerprint=?" , certName , certType , fingerprint ) return err } ) return err }
2058	func createDevLxdlListener ( dir string ) ( net . Listener , error ) { path := filepath . Join ( dir , "devlxd" , "sock" ) err := socketUnixRemoveStale ( path ) if err != nil { return nil , err } listener , err := socketUnixListen ( path ) if err != nil { return nil , err } err = socketUnixSetPermissions ( path , 0666 ) if err != nil { listener . Close ( ) return nil , err } return listener , nil }
2059	func ( i * raftInstance ) Servers ( ) ( [ ] raft . Server , error ) { if i . raft . State ( ) != raft . Leader { return nil , raft . ErrNotLeader } future := i . raft . GetConfiguration ( ) err := future . Error ( ) if err != nil { return nil , err } configuration := future . Configuration ( ) return configuration . Servers , nil }
2060	func ( i * raftInstance ) Shutdown ( ) error { logger . Debug ( "Stop raft instance" ) timeout := 10 * time . Second errCh := make ( chan error ) timer := time . After ( timeout ) go func ( ) { errCh <- i . raft . Shutdown ( ) . Error ( ) } ( ) select { case err := <- errCh : if err != nil { return errors . Wrap ( err , "failed to shutdown raft" ) } case <- timer : logger . Debug ( "Timeout waiting for raft to shutdown" ) return fmt . Errorf ( "raft did not shutdown within %s" , timeout ) } err := i . logs . Close ( ) if err != nil { return errors . Wrap ( err , "failed to close boltdb logs store" ) } return nil }
2061	func raftNetworkTransport ( db * db . Node , address string , logger * log . Logger , timeout time . Duration , dial rafthttp . Dial ) ( raft . Transport , * rafthttp . Handler , * rafthttp . Layer , error ) { handler := rafthttp . NewHandlerWithLogger ( logger ) addr , err := net . ResolveTCPAddr ( "tcp" , address ) if err != nil { return nil , nil , nil , errors . Wrap ( err , "invalid node address" ) } layer := rafthttp . NewLayer ( raftEndpoint , addr , handler , dial ) config := & raft . NetworkTransportConfig { Logger : logger , Stream : layer , MaxPool : 2 , Timeout : timeout , ServerAddressProvider : & raftAddressProvider { db : db } , } transport := raft . NewNetworkTransportWithConfig ( config ) return transport , handler , layer , nil }
2062	func raftConfig ( latency float64 ) * raft . Config { config := raft . DefaultConfig ( ) scale := func ( duration * time . Duration ) { * duration = time . Duration ( ( math . Ceil ( float64 ( * duration ) * latency ) ) ) } durations := [ ] * time . Duration { & config . HeartbeatTimeout , & config . ElectionTimeout , & config . CommitTimeout , & config . LeaderLeaseTimeout , } for _ , duration := range durations { scale ( duration ) } config . SnapshotThreshold = 1024 config . TrailingLogs = 512 return config }
2063	func raftMaybeBootstrap ( conf * raft . Config , logs * raftboltdb . BoltStore , snaps raft . SnapshotStore , trans raft . Transport ) error { hasExistingState , err := raft . HasExistingState ( logs , logs , snaps ) if err != nil { return errors . Wrap ( err , "failed to check if raft has existing state" ) } if hasExistingState { return nil } server := raft . Server { ID : conf . LocalID , Address : trans . LocalAddr ( ) , } configuration := raft . Configuration { Servers : [ ] raft . Server { server } , } return raft . BootstrapCluster ( conf , logs , logs , snaps , trans , configuration ) }
2064	func CPUResource ( ) ( * api . ResourcesCPU , error ) { c := api . ResourcesCPU { } threads , err := getThreads ( ) if err != nil { return nil , err } var cur * api . ResourcesCPUSocket c . Total = uint64 ( len ( threads ) ) for _ , v := range threads { if uint64 ( len ( c . Sockets ) ) <= v . socketID { c . Sockets = append ( c . Sockets , api . ResourcesCPUSocket { } ) cur = & c . Sockets [ v . socketID ] socketCores := map [ uint64 ] bool { } for _ , thread := range threads { if thread . socketID != v . socketID { continue } socketCores [ thread . coreID ] = true } cur . Cores = uint64 ( len ( socketCores ) ) } else { cur = & c . Sockets [ v . socketID ] } cur . Socket = v . socketID cur . NUMANode = v . numaNode cur . Threads ++ cur . Name = v . name cur . Vendor = v . vendor cur . Frequency = v . frequency cur . FrequencyTurbo = v . frequencyTurbo } return & c , nil }
2065	func MemoryResource ( ) ( * api . ResourcesMemory , error ) { var buffers uint64 var cached uint64 var free uint64 var total uint64 f , err := os . Open ( "/proc/meminfo" ) if err != nil { return nil , err } defer f . Close ( ) cleanLine := func ( l string ) ( string , error ) { l = strings . TrimSpace ( l ) idx := strings . LastIndex ( l , "kB" ) if idx < 0 { return "" , fmt . Errorf ( `Failed to detect "kB" suffix` ) } return strings . TrimSpace ( l [ : idx ] ) , nil } mem := api . ResourcesMemory { } scanner := bufio . NewScanner ( f ) found := 0 for scanner . Scan ( ) { var err error line := scanner . Text ( ) if strings . HasPrefix ( line , "MemTotal:" ) { line , err = cleanLine ( line [ len ( "MemTotal:" ) : ] ) if err != nil { return nil , err } total , err = strconv . ParseUint ( line , 10 , 64 ) if err != nil { return nil , err } found ++ } else if strings . HasPrefix ( line , "MemFree:" ) { line , err = cleanLine ( line [ len ( "MemFree:" ) : ] ) if err != nil { return nil , err } free , err = strconv . ParseUint ( line , 10 , 64 ) if err != nil { return nil , err } found ++ } else if strings . HasPrefix ( line , "Cached:" ) { line , err = cleanLine ( line [ len ( "Cached:" ) : ] ) if err != nil { return nil , err } cached , err = strconv . ParseUint ( line , 10 , 64 ) if err != nil { return nil , err } found ++ } else if strings . HasPrefix ( line , "Buffers:" ) { line , err = cleanLine ( line [ len ( "Buffers:" ) : ] ) if err != nil { return nil , err } buffers , err = strconv . ParseUint ( line , 10 , 64 ) if err != nil { return nil , err } found ++ } if found == 4 { break } } mem . Total = total * 1024 mem . Used = ( total - free - cached - buffers ) * 1024 return & mem , err }
2066	func ( r * ProtocolLXD ) GetOperationUUIDs ( ) ( [ ] string , error ) { urls := [ ] string { } _ , err := r . queryStruct ( "GET" , "/operations" , nil , "" , & urls ) if err != nil { return nil , err } uuids := [ ] string { } for _ , url := range urls { fields := strings . Split ( url , "/operations/" ) uuids = append ( uuids , fields [ len ( fields ) - 1 ] ) } return uuids , nil }
2067	func ( r * ProtocolLXD ) GetOperations ( ) ( [ ] api . Operation , error ) { apiOperations := map [ string ] [ ] api . Operation { } _ , err := r . queryStruct ( "GET" , "/operations?recursion=1" , nil , "" , & apiOperations ) if err != nil { return nil , err } operations := [ ] api . Operation { } for _ , v := range apiOperations { for _ , operation := range v { operations = append ( operations , operation ) } } return operations , nil }
2068	func ( r * ProtocolLXD ) GetOperation ( uuid string ) ( * api . Operation , string , error ) { op := api . Operation { } etag , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/operations/%s" , url . QueryEscape ( uuid ) ) , nil , "" , & op ) if err != nil { return nil , "" , err } return & op , etag , nil }
2069	func ( r * ProtocolLXD ) GetOperationWebsocket ( uuid string , secret string ) ( * websocket . Conn , error ) { path := fmt . Sprintf ( "/operations/%s/websocket" , url . QueryEscape ( uuid ) ) if secret != "" { path = fmt . Sprintf ( "%s?secret=%s" , path , url . QueryEscape ( secret ) ) } return r . websocket ( path ) }
2070	func tryMount ( src string , dst string , fs string , flags uintptr , options string ) error { var err error for i := 0 ; i < 20 ; i ++ { err = syscall . Mount ( src , dst , fs , flags , options ) if err == nil { break } time . Sleep ( 500 * time . Millisecond ) } if err != nil { return err } return nil }
2071	func lxdUsesPool ( dbObj * db . Cluster , onDiskPoolName string , driver string , onDiskProperty string ) ( bool , string , error ) { pools , err := dbObj . StoragePools ( ) if err != nil && err != db . ErrNoSuchObject { return false , "" , err } for _ , pool := range pools { _ , pl , err := dbObj . StoragePoolGet ( pool ) if err != nil { continue } if pl . Driver != driver { continue } if pl . Config [ onDiskProperty ] == onDiskPoolName { return true , pl . Name , nil } } return false , "" , nil }
2072	func ( c * ClusterTx ) ProjectURIs ( filter ProjectFilter ) ( [ ] string , error ) { criteria := map [ string ] interface { } { } if filter . Name != "" { criteria [ "Name" ] = filter . Name } var stmt * sql . Stmt var args [ ] interface { } if criteria [ "Name" ] != nil { stmt = c . stmt ( projectNamesByName ) args = [ ] interface { } { filter . Name , } } else { stmt = c . stmt ( projectNames ) args = [ ] interface { } { } } code := cluster . EntityTypes [ "project" ] formatter := cluster . EntityFormatURIs [ code ] return query . SelectURIs ( stmt , formatter , args ... ) }
2073	func ( c * ClusterTx ) ProjectList ( filter ProjectFilter ) ( [ ] api . Project , error ) { objects := make ( [ ] api . Project , 0 ) criteria := map [ string ] interface { } { } if filter . Name != "" { criteria [ "Name" ] = filter . Name } var stmt * sql . Stmt var args [ ] interface { } if criteria [ "Name" ] != nil { stmt = c . stmt ( projectObjectsByName ) args = [ ] interface { } { filter . Name , } } else { stmt = c . stmt ( projectObjects ) args = [ ] interface { } { } } dest := func ( i int ) [ ] interface { } { objects = append ( objects , api . Project { } ) return [ ] interface { } { & objects [ i ] . Description , & objects [ i ] . Name , } } err := query . SelectObjects ( stmt , dest , args ... ) if err != nil { return nil , errors . Wrap ( err , "Failed to fetch projects" ) } configObjects , err := c . ProjectConfigRef ( filter ) if err != nil { return nil , errors . Wrap ( err , "Failed to fetch field Config" ) } for i := range objects { value := configObjects [ objects [ i ] . Name ] if value == nil { value = map [ string ] string { } } objects [ i ] . Config = value } usedByObjects , err := c . ProjectUsedByRef ( filter ) if err != nil { return nil , errors . Wrap ( err , "Failed to fetch field UsedBy" ) } for i := range objects { value := usedByObjects [ objects [ i ] . Name ] if value == nil { value = [ ] string { } } objects [ i ] . UsedBy = value } return objects , nil }
2074	func ( c * ClusterTx ) ProjectGet ( name string ) ( * api . Project , error ) { filter := ProjectFilter { } filter . Name = name objects , err := c . ProjectList ( filter ) if err != nil { return nil , errors . Wrap ( err , "Failed to fetch Project" ) } switch len ( objects ) { case 0 : return nil , ErrNoSuchObject case 1 : return & objects [ 0 ] , nil default : return nil , fmt . Errorf ( "More than one project matches" ) } }
2075	func ( c * ClusterTx ) ProjectExists ( name string ) ( bool , error ) { _ , err := c . ProjectID ( name ) if err != nil { if err == ErrNoSuchObject { return false , nil } return false , err } return true , nil }
2076	func ( c * ClusterTx ) ProjectCreate ( object api . ProjectsPost ) ( int64 , error ) { exists , err := c . ProjectExists ( object . Name ) if err != nil { return - 1 , errors . Wrap ( err , "Failed to check for duplicates" ) } if exists { return - 1 , fmt . Errorf ( "This project already exists" ) } args := make ( [ ] interface { } , 2 ) args [ 0 ] = object . Description args [ 1 ] = object . Name stmt := c . stmt ( projectCreate ) result , err := stmt . Exec ( args ... ) if err != nil { return - 1 , errors . Wrap ( err , "Failed to create project" ) } id , err := result . LastInsertId ( ) if err != nil { return - 1 , errors . Wrap ( err , "Failed to fetch project ID" ) } stmt = c . stmt ( projectCreateConfigRef ) for key , value := range object . Config { _ , err := stmt . Exec ( id , key , value ) if err != nil { return - 1 , errors . Wrap ( err , "Insert config for project" ) } } return id , nil }
2077	func ( c * ClusterTx ) ProjectUsedByRef ( filter ProjectFilter ) ( map [ string ] [ ] string , error ) { objects := make ( [ ] struct { Name string Value string } , 0 ) criteria := map [ string ] interface { } { } if filter . Name != "" { criteria [ "Name" ] = filter . Name } var stmt * sql . Stmt var args [ ] interface { } if criteria [ "Name" ] != nil { stmt = c . stmt ( projectUsedByRefByName ) args = [ ] interface { } { filter . Name , } } else { stmt = c . stmt ( projectUsedByRef ) args = [ ] interface { } { } } dest := func ( i int ) [ ] interface { } { objects = append ( objects , struct { Name string Value string } { } ) return [ ] interface { } { & objects [ i ] . Name , & objects [ i ] . Value , } } err := query . SelectObjects ( stmt , dest , args ... ) if err != nil { return nil , errors . Wrap ( err , "Failed to fetch string ref for projects" ) } index := map [ string ] [ ] string { } for _ , object := range objects { item , ok := index [ object . Name ] if ! ok { item = [ ] string { } } index [ object . Name ] = append ( item , object . Value ) } return index , nil }
2078	func ( c * ClusterTx ) ProjectRename ( name string , to string ) error { stmt := c . stmt ( projectRename ) result , err := stmt . Exec ( to , name ) if err != nil { return errors . Wrap ( err , "Rename project" ) } n , err := result . RowsAffected ( ) if err != nil { return errors . Wrap ( err , "Fetch affected rows" ) } if n != 1 { return fmt . Errorf ( "Query affected %d rows instead of 1" , n ) } return nil }
2079	func ( c * ClusterTx ) ProjectDelete ( name string ) error { stmt := c . stmt ( projectDelete ) result , err := stmt . Exec ( name ) if err != nil { return errors . Wrap ( err , "Delete project" ) } n , err := result . RowsAffected ( ) if err != nil { return errors . Wrap ( err , "Fetch affected rows" ) } if n != 1 { return fmt . Errorf ( "Query deleted %d rows instead of 1" , n ) } return nil }
2080	func PasswordCheck ( secret string , password string ) error { if secret == "" { return fmt . Errorf ( "No password is set" ) } buff , err := hex . DecodeString ( secret ) if err != nil { return err } salt := buff [ 0 : 32 ] hash , err := scrypt . Key ( [ ] byte ( password ) , salt , 1 << 14 , 8 , 1 , 64 ) if err != nil { return err } if ! bytes . Equal ( hash , buff [ 32 : ] ) { return fmt . Errorf ( "Bad password provided" ) } return nil }
2081	func LoadCert ( dir string ) ( * shared . CertInfo , error ) { prefix := "server" if shared . PathExists ( filepath . Join ( dir , "cluster.crt" ) ) { prefix = "cluster" } cert , err := shared . KeyPairAndCA ( dir , prefix , shared . CertServer ) if err != nil { return nil , errors . Wrap ( err , "failed to load TLS certificate" ) } return cert , nil }
2082	func WriteCert ( dir , prefix string , cert , key , ca [ ] byte ) error { err := ioutil . WriteFile ( filepath . Join ( dir , prefix + ".crt" ) , cert , 0644 ) if err != nil { return err } err = ioutil . WriteFile ( filepath . Join ( dir , prefix + ".key" ) , key , 0600 ) if err != nil { return err } if ca != nil { err = ioutil . WriteFile ( filepath . Join ( dir , prefix + ".ca" ) , ca , 0644 ) if err != nil { return err } } return nil }
2083	func NewDaemon ( config * DaemonConfig , os * sys . OS ) * Daemon { return & Daemon { config : config , os : os , setupChan : make ( chan struct { } ) , readyChan : make ( chan struct { } ) , shutdownChan : make ( chan struct { } ) , } }
2084	func DefaultDaemon ( ) * Daemon { config := DefaultDaemonConfig ( ) os := sys . DefaultOS ( ) return NewDaemon ( config , os ) }
2085	func AllowProjectPermission ( feature string , permission string ) func ( d * Daemon , r * http . Request ) Response { return func ( d * Daemon , r * http . Request ) Response { if d . userIsAdmin ( r ) { return EmptySyncResponse } project := projectParam ( r ) if ! d . userHasPermission ( r , project , permission ) { return Forbidden ( nil ) } return EmptySyncResponse } }
2086	func ( d * Daemon ) checkTrustedClient ( r * http . Request ) error { trusted , _ , _ , err := d . Authenticate ( r ) if ! trusted || err != nil { if err != nil { return err } return fmt . Errorf ( "Not authorized" ) } return nil }
2087	func ( d * Daemon ) Authenticate ( r * http . Request ) ( bool , string , string , error ) { if r . TLS != nil { cert , _ := x509 . ParseCertificate ( d . endpoints . NetworkCert ( ) . KeyPair ( ) . Certificate [ 0 ] ) clusterCerts := map [ string ] x509 . Certificate { "0" : * cert } for i := range r . TLS . PeerCertificates { trusted , _ := util . CheckTrustState ( * r . TLS . PeerCertificates [ i ] , clusterCerts ) if trusted { return true , "" , "cluster" , nil } } } if r . RemoteAddr == "@" { return true , "" , "unix" , nil } if r . RemoteAddr == "@devlxd" { return false , "" , "" , fmt . Errorf ( "Main API query can't come from /dev/lxd socket" ) } if isClusterNotification ( r ) { return false , "" , "" , fmt . Errorf ( "Cluster notification isn't using cluster certificate" ) } if r . TLS == nil { return false , "" , "" , fmt . Errorf ( "Bad/missing TLS on network query" ) } if d . externalAuth != nil && r . Header . Get ( httpbakery . BakeryProtocolHeader ) != "" { ctx := httpbakery . ContextWithRequest ( context . TODO ( ) , r ) authChecker := d . externalAuth . bakery . Checker . Auth ( httpbakery . RequestMacaroons ( r ) ... ) ops := [ ] bakery . Op { { Entity : r . URL . Path , Action : r . Method , } } info , err := authChecker . Allow ( ctx , ops ... ) if err != nil { return false , "" , "" , err } if info != nil && info . Identity != nil { return true , info . Identity . Id ( ) , "candid" , nil } return true , "" , "candid" , nil } for i := range r . TLS . PeerCertificates { trusted , username := util . CheckTrustState ( * r . TLS . PeerCertificates [ i ] , d . clientCerts ) if trusted { return true , username , "tls" , nil } } return false , "" , "" , nil }
2088	func ( d * Daemon ) State ( ) * state . State { return state . NewState ( d . db , d . cluster , d . maas , d . os , d . endpoints ) }
2089	func ( d * Daemon ) UnixSocket ( ) string { path := os . Getenv ( "LXD_SOCKET" ) if path != "" { return path } return filepath . Join ( d . os . VarDir , "unix.socket" ) }
2090	func ( d * Daemon ) Stop ( ) error { logger . Info ( "Starting shutdown sequence" ) errs := [ ] error { } trackError := func ( err error ) { if err != nil { errs = append ( errs , err ) } } if d . endpoints != nil { trackError ( d . endpoints . Down ( ) ) } trackError ( d . tasks . Stop ( 3 * time . Second ) ) trackError ( d . clusterTasks . Stop ( 3 * time . Second ) ) shouldUnmount := false if d . cluster != nil { ch := make ( chan bool ) go func ( ) { n , err := d . numRunningContainers ( ) ch <- err != nil || n == 0 } ( ) select { case shouldUnmount = <- ch : case <- time . After ( 2 * time . Second ) : shouldUnmount = true } logger . Infof ( "Closing the database" ) err := d . cluster . Close ( ) if errors . Cause ( err ) == driver . ErrBadConn { logger . Debugf ( "Could not close remote database cleanly: %v" , err ) } else { trackError ( err ) } } if d . db != nil { trackError ( d . db . Close ( ) ) } if d . gateway != nil { trackError ( d . gateway . Shutdown ( ) ) } if d . endpoints != nil { trackError ( d . endpoints . Down ( ) ) } if d . endpoints != nil { trackError ( d . endpoints . Down ( ) ) } if shouldUnmount { logger . Infof ( "Unmounting temporary filesystems" ) syscall . Unmount ( shared . VarPath ( "devlxd" ) , syscall . MNT_DETACH ) syscall . Unmount ( shared . VarPath ( "shmounts" ) , syscall . MNT_DETACH ) logger . Infof ( "Done unmounting temporary filesystems" ) } else { logger . Debugf ( "Not unmounting temporary filesystems (containers are still running)" ) } var err error if n := len ( errs ) ; n > 0 { format := "%v" if n > 1 { format += fmt . Sprintf ( " (and %d more errors)" , n ) } err = fmt . Errorf ( format , errs [ 0 ] ) } if err != nil { logger . Errorf ( "Failed to cleanly shutdown daemon: %v" , err ) } return err }
2091	func ( d * Daemon ) setupExternalAuthentication ( authEndpoint string , authPubkey string , expiry int64 , domains string ) error { authDomains := [ ] string { } for _ , domain := range strings . Split ( domains , "," ) { if domain == "" { continue } authDomains = append ( authDomains , strings . TrimSpace ( domain ) ) } if authEndpoint == "" { d . externalAuth = nil return nil } idmClient , err := candidclient . New ( candidclient . NewParams { BaseURL : authEndpoint , } ) if err != nil { return err } idmClientWrapper := & IdentityClientWrapper { client : idmClient , ValidDomains : authDomains , } key , err := bakery . GenerateKey ( ) if err != nil { return err } pkCache := bakery . NewThirdPartyStore ( ) pkLocator := httpbakery . NewThirdPartyLocator ( nil , pkCache ) if authPubkey != "" { pkKey := bakery . Key { } err := pkKey . UnmarshalText ( [ ] byte ( authPubkey ) ) if err != nil { return err } pkCache . AddInfo ( authEndpoint , bakery . ThirdPartyInfo { PublicKey : bakery . PublicKey { Key : pkKey } , Version : 3 , } ) if strings . HasPrefix ( authEndpoint , "http://" ) { pkLocator . AllowInsecure ( ) } } bakery := identchecker . NewBakery ( identchecker . BakeryParams { Key : key , Location : authEndpoint , Locator : pkLocator , Checker : httpbakery . NewChecker ( ) , IdentityClient : idmClientWrapper , Authorizer : identchecker . ACLAuthorizer { GetACL : func ( ctx context . Context , op bakery . Op ) ( [ ] string , bool , error ) { return [ ] string { identchecker . Everyone } , false , nil } , } , } ) d . externalAuth = & externalAuth { endpoint : authEndpoint , expiry : expiry , bakery : bakery , } return nil }
2092	func initializeDbObject ( d * Daemon ) ( * db . Dump , error ) { logger . Info ( "Initializing local database" ) if shared . PathExists ( d . os . LegacyLocalDatabasePath ( ) ) { if shared . PathExists ( d . os . LocalDatabasePath ( ) ) { return nil , fmt . Errorf ( "Both legacy and new local database files exists" ) } logger . Info ( "Renaming local database file from lxd.db to database/local.db" ) err := os . Rename ( d . os . LegacyLocalDatabasePath ( ) , d . os . LocalDatabasePath ( ) ) if err != nil { return nil , errors . Wrap ( err , "Failed to rename legacy local database file" ) } } legacy := map [ int ] * db . LegacyPatch { } for i , patch := range legacyPatches { legacy [ i ] = & db . LegacyPatch { Hook : func ( node * sql . DB ) error { cluster := d . cluster defer func ( ) { d . cluster = cluster } ( ) d . db = db . ForLegacyPatches ( node ) d . cluster = db . ForLocalInspection ( node ) return patch ( d ) } , } } for _ , i := range legacyPatchesNeedingDB { legacy [ i ] . NeedsDB = true } freshHook := func ( db * db . Node ) error { for _ , patchName := range patchesGetNames ( ) { err := db . PatchesMarkApplied ( patchName ) if err != nil { return err } } return nil } var err error var dump * db . Dump d . db , dump , err = db . OpenNode ( filepath . Join ( d . os . VarDir , "database" ) , freshHook , legacy ) if err != nil { return nil , fmt . Errorf ( "Error creating database: %s" , err ) } return dump , nil }
2093	func WriteJSON ( w http . ResponseWriter , body interface { } , debug bool ) error { var output io . Writer var captured * bytes . Buffer output = w if debug { captured = & bytes . Buffer { } output = io . MultiWriter ( w , captured ) } err := json . NewEncoder ( output ) . Encode ( body ) if captured != nil { shared . DebugJson ( captured ) } return err }
2094	func EtagHash ( data interface { } ) ( string , error ) { etag := sha256 . New ( ) err := json . NewEncoder ( etag ) . Encode ( data ) if err != nil { return "" , err } return fmt . Sprintf ( "%x" , etag . Sum ( nil ) ) , nil }
2095	func EtagCheck ( r * http . Request , data interface { } ) error { match := r . Header . Get ( "If-Match" ) if match == "" { return nil } hash , err := EtagHash ( data ) if err != nil { return err } if hash != match { return fmt . Errorf ( "ETag doesn't match: %s vs %s" , hash , match ) } return nil }
2096	func HTTPClient ( certificate string , proxy proxyFunc ) ( * http . Client , error ) { var err error var cert * x509 . Certificate if certificate != "" { certBlock , _ := pem . Decode ( [ ] byte ( certificate ) ) if certBlock == nil { return nil , fmt . Errorf ( "Invalid certificate" ) } cert , err = x509 . ParseCertificate ( certBlock . Bytes ) if err != nil { return nil , err } } tlsConfig , err := shared . GetTLSConfig ( "" , "" , "" , cert ) if err != nil { return nil , err } tr := & http . Transport { TLSClientConfig : tlsConfig , Dial : shared . RFC3493Dialer , Proxy : proxy , DisableKeepAlives : true , } myhttp := http . Client { Transport : tr , } myhttp . CheckRedirect = func ( req * http . Request , via [ ] * http . Request ) error { req . Header = via [ len ( via ) - 1 ] . Header return nil } return & myhttp , nil }
2097	func IsRecursionRequest ( r * http . Request ) bool { recursionStr := r . FormValue ( "recursion" ) recursion , err := strconv . Atoi ( recursionStr ) if err != nil { return false } return recursion != 0 }
2098	func GetListeners ( start int ) [ ] net . Listener { defer func ( ) { os . Unsetenv ( "LISTEN_PID" ) os . Unsetenv ( "LISTEN_FDS" ) } ( ) pid , err := strconv . Atoi ( os . Getenv ( "LISTEN_PID" ) ) if err != nil { return nil } if pid != os . Getpid ( ) { return nil } fds , err := strconv . Atoi ( os . Getenv ( "LISTEN_FDS" ) ) if err != nil { return nil } listeners := [ ] net . Listener { } for i := start ; i < start + fds ; i ++ { syscall . CloseOnExec ( i ) file := os . NewFile ( uintptr ( i ) , fmt . Sprintf ( "inherited-fd%d" , i ) ) listener , err := net . FileListener ( file ) if err != nil { continue } listeners = append ( listeners , listener ) } return listeners }
2099	func internalSQLGet ( d * Daemon , r * http . Request ) Response { database := r . FormValue ( "database" ) if ! shared . StringInSlice ( database , [ ] string { "local" , "global" } ) { return BadRequest ( fmt . Errorf ( "Invalid database" ) ) } schemaFormValue := r . FormValue ( "schema" ) schemaOnly , err := strconv . Atoi ( schemaFormValue ) if err != nil { schemaOnly = 0 } var schema string var db * sql . DB if database == "global" { db = d . cluster . DB ( ) schema = cluster . FreshSchema ( ) } else { db = d . db . DB ( ) schema = node . FreshSchema ( ) } tx , err := db . Begin ( ) if err != nil { return SmartError ( errors . Wrap ( err , "failed to start transaction" ) ) } defer tx . Rollback ( ) dump , err := query . Dump ( tx , schema , schemaOnly == 1 ) if err != nil { return SmartError ( errors . Wrapf ( err , "failed dump database %s" , database ) ) } return SyncResponse ( true , internalSQLDump { Text : dump } ) }
2100	func internalSQLPost ( d * Daemon , r * http . Request ) Response { req := & internalSQLQuery { } err := json . NewDecoder ( r . Body ) . Decode ( & req ) if err != nil { return BadRequest ( err ) } if ! shared . StringInSlice ( req . Database , [ ] string { "local" , "global" } ) { return BadRequest ( fmt . Errorf ( "Invalid database" ) ) } if req . Query == "" { return BadRequest ( fmt . Errorf ( "No query provided" ) ) } var db * sql . DB if req . Database == "global" { db = d . cluster . DB ( ) } else { db = d . db . DB ( ) } batch := internalSQLBatch { } if req . Query == ".sync" { d . gateway . Sync ( ) return SyncResponse ( true , batch ) } for _ , query := range strings . Split ( req . Query , ";" ) { query = strings . TrimLeft ( query , " " ) if query == "" { continue } result := internalSQLResult { } tx , err := db . Begin ( ) if err != nil { return SmartError ( err ) } if strings . HasPrefix ( strings . ToUpper ( query ) , "SELECT" ) { err = internalSQLSelect ( tx , query , & result ) tx . Rollback ( ) } else { err = internalSQLExec ( tx , query , & result ) if err != nil { tx . Rollback ( ) } else { err = tx . Commit ( ) } } if err != nil { return SmartError ( err ) } batch . Results = append ( batch . Results , result ) } return SyncResponse ( true , batch ) }
2101	func ( c * CertInfo ) PublicKey ( ) [ ] byte { data := c . KeyPair ( ) . Certificate [ 0 ] return pem . EncodeToMemory ( & pem . Block { Type : "CERTIFICATE" , Bytes : data } ) }
2102	func ( c * CertInfo ) PrivateKey ( ) [ ] byte { ecKey , ok := c . KeyPair ( ) . PrivateKey . ( * ecdsa . PrivateKey ) if ok { data , err := x509 . MarshalECPrivateKey ( ecKey ) if err != nil { return nil } return pem . EncodeToMemory ( & pem . Block { Type : "EC PRIVATE KEY" , Bytes : data } ) } rsaKey , ok := c . KeyPair ( ) . PrivateKey . ( * rsa . PrivateKey ) if ok { data := x509 . MarshalPKCS1PrivateKey ( rsaKey ) return pem . EncodeToMemory ( & pem . Block { Type : "RSA PRIVATE KEY" , Bytes : data } ) } return nil }
2103	func ( c * CertInfo ) Fingerprint ( ) string { fingerprint , err := CertFingerprintStr ( string ( c . PublicKey ( ) ) ) if err != nil { panic ( "invalid public key material" ) } return fingerprint }
2104	func GenCert ( certf string , keyf string , certtype bool ) error { dir := path . Dir ( certf ) err := os . MkdirAll ( dir , 0750 ) if err != nil { return err } dir = path . Dir ( keyf ) err = os . MkdirAll ( dir , 0750 ) if err != nil { return err } certBytes , keyBytes , err := GenerateMemCert ( certtype ) if err != nil { return err } certOut , err := os . Create ( certf ) if err != nil { return fmt . Errorf ( "Failed to open %s for writing: %v" , certf , err ) } certOut . Write ( certBytes ) certOut . Close ( ) keyOut , err := os . OpenFile ( keyf , os . O_WRONLY | os . O_CREATE | os . O_TRUNC , 0600 ) if err != nil { return fmt . Errorf ( "Failed to open %s for writing: %v" , keyf , err ) } keyOut . Write ( keyBytes ) keyOut . Close ( ) return nil }
2105	func PrintServerInfo ( c lxd . ContainerServer ) error { server , _ , err := c . GetServer ( ) if err != nil { return err } env := server . Environment fmt . Printf ( "Test environment:\n" ) \n fmt . Printf ( " Server backend: %s\n" , \n ) env . Server fmt . Printf ( " Server version: %s\n" , \n ) env . ServerVersion fmt . Printf ( " Kernel: %s\n" , \n ) env . Kernel fmt . Printf ( " Kernel architecture: %s\n" , \n ) env . KernelArchitecture fmt . Printf ( " Kernel version: %s\n" , \n ) env . KernelVersion }
2106	func LaunchContainers ( c lxd . ContainerServer , count int , parallel int , image string , privileged bool , start bool , freeze bool ) ( time . Duration , error ) { var duration time . Duration batchSize , err := getBatchSize ( parallel ) if err != nil { return duration , err } printTestConfig ( count , batchSize , image , privileged , freeze ) fingerprint , err := ensureImage ( c , image ) if err != nil { return duration , err } batchStart := func ( index int , wg * sync . WaitGroup ) { defer wg . Done ( ) name := getContainerName ( count , index ) err := createContainer ( c , fingerprint , name , privileged ) if err != nil { logf ( "Failed to launch container '%s': %s" , name , err ) return } if start { err := startContainer ( c , name ) if err != nil { logf ( "Failed to start container '%s': %s" , name , err ) return } if freeze { err := freezeContainer ( c , name ) if err != nil { logf ( "Failed to freeze container '%s': %s" , name , err ) return } } } } duration = processBatch ( count , batchSize , batchStart ) return duration , nil }
2107	func CreateContainers ( c lxd . ContainerServer , count int , parallel int , fingerprint string , privileged bool ) ( time . Duration , error ) { var duration time . Duration batchSize , err := getBatchSize ( parallel ) if err != nil { return duration , err } batchCreate := func ( index int , wg * sync . WaitGroup ) { defer wg . Done ( ) name := getContainerName ( count , index ) err := createContainer ( c , fingerprint , name , privileged ) if err != nil { logf ( "Failed to launch container '%s': %s" , name , err ) return } } duration = processBatch ( count , batchSize , batchCreate ) return duration , nil }
2108	func GetContainers ( c lxd . ContainerServer ) ( [ ] api . Container , error ) { containers := [ ] api . Container { } allContainers , err := c . GetContainers ( ) if err != nil { return containers , err } for _ , container := range allContainers { if container . Config [ userConfigKey ] == "true" { containers = append ( containers , container ) } } return containers , nil }
2109	func StartContainers ( c lxd . ContainerServer , containers [ ] api . Container , parallel int ) ( time . Duration , error ) { var duration time . Duration batchSize , err := getBatchSize ( parallel ) if err != nil { return duration , err } count := len ( containers ) logf ( "Starting %d containers" , count ) batchStart := func ( index int , wg * sync . WaitGroup ) { defer wg . Done ( ) container := containers [ index ] if ! container . IsActive ( ) { err := startContainer ( c , container . Name ) if err != nil { logf ( "Failed to start container '%s': %s" , container . Name , err ) return } } } duration = processBatch ( count , batchSize , batchStart ) return duration , nil }
2110	func setQueryParam ( uri , param , value string ) ( string , error ) { fields , err := url . Parse ( uri ) if err != nil { return "" , err } values := fields . Query ( ) values . Set ( param , url . QueryEscape ( value ) ) fields . RawQuery = values . Encode ( ) return fields . String ( ) , nil }
2111	func ( r * ProtocolLXD ) GetImages ( ) ( [ ] api . Image , error ) { images := [ ] api . Image { } _ , err := r . queryStruct ( "GET" , "/images?recursion=1" , nil , "" , & images ) if err != nil { return nil , err } return images , nil }
2112	func ( r * ProtocolLXD ) GetImageFile ( fingerprint string , req ImageFileRequest ) ( * ImageFileResponse , error ) { return r . GetPrivateImageFile ( fingerprint , "" , req ) }
2113	func ( r * ProtocolLXD ) GetImageSecret ( fingerprint string ) ( string , error ) { op , err := r . CreateImageSecret ( fingerprint ) if err != nil { return "" , err } opAPI := op . Get ( ) return opAPI . Metadata [ "secret" ] . ( string ) , nil }
2114	func ( r * ProtocolLXD ) GetPrivateImage ( fingerprint string , secret string ) ( * api . Image , string , error ) { image := api . Image { } path := fmt . Sprintf ( "/images/%s" , url . QueryEscape ( fingerprint ) ) var err error path , err = r . setQueryAttributes ( path ) if err != nil { return nil , "" , err } if secret != "" { path , err = setQueryParam ( path , "secret" , secret ) if err != nil { return nil , "" , err } } etag , err := r . queryStruct ( "GET" , path , nil , "" , & image ) if err != nil { return nil , "" , err } return & image , etag , nil }
2115	func ( r * ProtocolLXD ) GetPrivateImageFile ( fingerprint string , secret string , req ImageFileRequest ) ( * ImageFileResponse , error ) { if req . MetaFile == nil && req . RootfsFile == nil { return nil , fmt . Errorf ( "No file requested" ) } uri := fmt . Sprintf ( "/1.0/images/%s/export" , url . QueryEscape ( fingerprint ) ) var err error uri , err = r . setQueryAttributes ( uri ) if err != nil { return nil , err } if secret == "" && shared . PathExists ( "/dev/lxd/sock" ) && os . Geteuid ( ) == 0 { unixURI := fmt . Sprintf ( "http://unix.socket%s" , uri ) devlxdHTTP , err := unixHTTPClient ( nil , "/dev/lxd/sock" ) if err == nil { resp , err := lxdDownloadImage ( fingerprint , unixURI , r . httpUserAgent , devlxdHTTP , req ) if err == nil { return resp , nil } } } uri = fmt . Sprintf ( "%s%s" , r . httpHost , uri ) if secret != "" { uri , err = setQueryParam ( uri , "secret" , secret ) if err != nil { return nil , err } } return lxdDownloadImage ( fingerprint , uri , r . httpUserAgent , r . http , req ) }
2116	func ( r * ProtocolLXD ) GetImageAliases ( ) ( [ ] api . ImageAliasesEntry , error ) { aliases := [ ] api . ImageAliasesEntry { } _ , err := r . queryStruct ( "GET" , "/images/aliases?recursion=1" , nil , "" , & aliases ) if err != nil { return nil , err } return aliases , nil }
2117	func ( r * ProtocolLXD ) tryCopyImage ( req api . ImagesPost , urls [ ] string ) ( RemoteOperation , error ) { if len ( urls ) == 0 { return nil , fmt . Errorf ( "The source server isn't listening on the network" ) } rop := remoteOperation { chDone : make ( chan bool ) , } if ! r . HasExtension ( "image_create_aliases" ) && req . Aliases != nil { rop . chPost = make ( chan bool ) go func ( ) { defer close ( rop . chPost ) <- rop . chDone if rop . err != nil { return } op , err := rop . GetTarget ( ) if err != nil { return } fingerprint := op . Metadata [ "fingerprint" ] . ( string ) for _ , entry := range req . Aliases { alias := api . ImageAliasesPost { } alias . Name = entry . Name alias . Target = fingerprint r . CreateImageAlias ( alias ) } } ( ) } go func ( ) { success := false errors := map [ string ] error { } for _ , serverURL := range urls { req . Source . Server = serverURL op , err := r . CreateImage ( req , nil ) if err != nil { errors [ serverURL ] = err continue } rop . targetOp = op for _ , handler := range rop . handlers { rop . targetOp . AddHandler ( handler ) } err = rop . targetOp . Wait ( ) if err != nil { errors [ serverURL ] = err continue } success = true break } if ! success { rop . err = remoteOperationError ( "Failed remote image download" , errors ) } close ( rop . chDone ) } ( ) return & rop , nil }
2118	func ( r * ProtocolLXD ) CopyImage ( source ImageServer , image api . Image , args * ImageCopyArgs ) ( RemoteOperation , error ) { if r == source { return nil , fmt . Errorf ( "The source and target servers must be different" ) } info , err := source . GetConnectionInfo ( ) if err != nil { return nil , err } req := api . ImagesPost { Source : & api . ImagesPostSource { ImageSource : api . ImageSource { Certificate : info . Certificate , Protocol : info . Protocol , } , Fingerprint : image . Fingerprint , Mode : "pull" , Type : "image" , } , } if ! image . Public { secret , err := source . GetImageSecret ( image . Fingerprint ) if err != nil { return nil , err } req . Source . Secret = secret } if args != nil { req . Aliases = args . Aliases req . AutoUpdate = args . AutoUpdate req . Public = args . Public if args . CopyAliases { req . Aliases = image . Aliases if args . Aliases != nil { req . Aliases = append ( req . Aliases , args . Aliases ... ) } } } return r . tryCopyImage ( req , info . Addresses ) }
2119	func ( r * ProtocolLXD ) UpdateImage ( fingerprint string , image api . ImagePut , ETag string ) error { _ , _ , err := r . query ( "PUT" , fmt . Sprintf ( "/images/%s" , url . QueryEscape ( fingerprint ) ) , image , ETag ) if err != nil { return err } return nil }
2120	func ( r * ProtocolLXD ) DeleteImage ( fingerprint string ) ( Operation , error ) { op , _ , err := r . queryOperation ( "DELETE" , fmt . Sprintf ( "/images/%s" , url . QueryEscape ( fingerprint ) ) , nil , "" ) if err != nil { return nil , err } return op , nil }
2121	func ( r * ProtocolLXD ) RefreshImage ( fingerprint string ) ( Operation , error ) { if ! r . HasExtension ( "image_force_refresh" ) { return nil , fmt . Errorf ( "The server is missing the required \"image_force_refresh\" API extension" ) } \" \" op , _ , err := r . queryOperation ( "POST" , fmt . Sprintf ( "/images/%s/refresh" , url . QueryEscape ( fingerprint ) ) , nil , "" ) }
2122	func ( r * ProtocolLXD ) CreateImageAlias ( alias api . ImageAliasesPost ) error { _ , _ , err := r . query ( "POST" , "/images/aliases" , alias , "" ) if err != nil { return err } return nil }
2123	func ( r * ProtocolLXD ) UpdateImageAlias ( name string , alias api . ImageAliasesEntryPut , ETag string ) error { _ , _ , err := r . query ( "PUT" , fmt . Sprintf ( "/images/aliases/%s" , url . QueryEscape ( name ) ) , alias , ETag ) if err != nil { return err } return nil }
2124	func ( r * ProtocolLXD ) RenameImageAlias ( name string , alias api . ImageAliasesEntryPost ) error { _ , _ , err := r . query ( "POST" , fmt . Sprintf ( "/images/aliases/%s" , url . QueryEscape ( name ) ) , alias , "" ) if err != nil { return err } return nil }
2125	func ( r * ProtocolLXD ) DeleteImageAlias ( name string ) error { _ , _ , err := r . query ( "DELETE" , fmt . Sprintf ( "/images/aliases/%s" , url . QueryEscape ( name ) ) , nil , "" ) if err != nil { return err } return nil }
2126	func Open ( dir string ) ( * sql . DB , error ) { path := filepath . Join ( dir , "local.db" ) db , err := sqliteOpen ( path ) if err != nil { return nil , fmt . Errorf ( "cannot open node database: %v" , err ) } return db , nil }
2127	func EnsureSchema ( db * sql . DB , dir string , hook schema . Hook ) ( int , error ) { backupDone := false schema := Schema ( ) schema . File ( filepath . Join ( dir , "patch.local.sql" ) ) schema . Hook ( func ( version int , tx * sql . Tx ) error { if ! backupDone { logger . Infof ( "Updating the LXD database schema. Backup made as \"local.db.bak\"" ) \" \" path := filepath . Join ( dir , "local.db" ) err := shared . FileCopy ( path , path + ".bak" ) } if err != nil { return err } backupDone = true if version == - 1 { logger . Debugf ( "Running pre-update queries from file for local DB schema" ) } else { logger . Debugf ( "Updating DB schema from %d to %d" , version , version + 1 ) } } ) if hook != nil && version != - 1 { err := hook ( version , tx ) if err != nil { } } }
2128	func FilesystemDetect ( path string ) ( string , error ) { fs := syscall . Statfs_t { } err := syscall . Statfs ( path , & fs ) if err != nil { return "" , err } switch fs . Type { case FilesystemSuperMagicBtrfs : return "btrfs" , nil case FilesystemSuperMagicZfs : return "zfs" , nil case FilesystemSuperMagicTmpfs : return "tmpfs" , nil case FilesystemSuperMagicExt4 : return "ext4" , nil case FilesystemSuperMagicXfs : return "xfs" , nil case FilesystemSuperMagicNfs : return "nfs" , nil default : logger . Debugf ( "Unknown backing filesystem type: 0x%x" , fs . Type ) return string ( fs . Type ) , nil } }
2129	func Schema ( ) * schema . Schema { schema := schema . NewFromMap ( updates ) schema . Fresh ( freshSchema ) return schema }
2130	func updateFromV37 ( tx * sql . Tx ) error { count , err := query . Count ( tx , "raft_nodes" , "" ) if err != nil { return errors . Wrap ( err , "Fetch count of Raft nodes" ) } if count == 0 { return nil } _ , err = tx . Exec ( `INSERT INTO config (key, value) SELECT 'cluster.https_address', value FROM config WHERE key = 'core.https_address'` ) if err != nil { return errors . Wrap ( err , "Insert cluster.https_address config" ) } return nil }
2131	func ArchitectureGetLocal ( ) ( string , error ) { uname , err := shared . Uname ( ) if err != nil { return ArchitectureDefault , err } return uname . Machine , nil }
2132	func NewController ( url string , key string , machine string ) ( * Controller , error ) { baseURL := fmt . Sprintf ( "%s/api/2.0/" , url ) srv , err := gomaasapi . NewController ( gomaasapi . ControllerArgs { BaseURL : baseURL , APIKey : key , } ) if err != nil { if ! strings . Contains ( err . Error ( ) , "unsupported version" ) { return nil , err } return nil , fmt . Errorf ( "Unable to connect MAAS at '%s': %v" , baseURL , strings . Split ( strings . Split ( err . Error ( ) , "unsupported version: " ) [ 1 ] , " (" ) [ 0 ] ) } srvRaw , err := gomaasapi . NewAuthenticatedClient ( baseURL , key ) if err != nil { return nil , err } machines , err := srv . Machines ( gomaasapi . MachinesArgs { Hostnames : [ ] string { machine } } ) if err != nil { return nil , err } if len ( machines ) != 1 { return nil , fmt . Errorf ( "Couldn't find the specified machine: %s" , machine ) } c := Controller { } c . srv = srv c . srvRaw = * srvRaw c . machine = machines [ 0 ] c . url = baseURL return & c , err }
2133	func ( c * Controller ) CreateContainer ( name string , interfaces [ ] ContainerInterface ) error { macInterfaces , err := parseInterfaces ( interfaces ) if err != nil { return err } subnets , err := c . getSubnets ( ) if err != nil { return err } device , err := c . machine . CreateDevice ( gomaasapi . CreateMachineDeviceArgs { Hostname : name , InterfaceName : interfaces [ 0 ] . Name , MACAddress : interfaces [ 0 ] . MACAddress , VLAN : subnets [ interfaces [ 0 ] . Subnets [ 0 ] . Name ] . VLAN ( ) , } ) if err != nil { return err } success := false defer func ( ) { if success == true { return } c . DeleteContainer ( name ) } ( ) for _ , iface := range interfaces [ 1 : ] { _ , err := device . CreateInterface ( gomaasapi . CreateInterfaceArgs { Name : iface . Name , MACAddress : iface . MACAddress , VLAN : subnets [ iface . Subnets [ 0 ] . Name ] . VLAN ( ) , } ) if err != nil { return err } } device , err = c . getDevice ( name ) if err != nil { return err } for _ , entry := range device . InterfaceSet ( ) { iface , ok := macInterfaces [ entry . MACAddress ( ) ] if ! ok { return fmt . Errorf ( "MAAS created an interface with a bad MAC: %s" , entry . MACAddress ( ) ) } for _ , subnet := range iface . Subnets { err := entry . LinkSubnet ( gomaasapi . LinkSubnetArgs { Mode : gomaasapi . LinkModeStatic , Subnet : subnets [ subnet . Name ] , IPAddress : subnet . Address , } ) if err != nil { return err } } } success = true return nil }
2134	func ( c * Controller ) DefinedContainer ( name string ) ( bool , error ) { devs , err := c . machine . Devices ( gomaasapi . DevicesArgs { Hostname : [ ] string { name } } ) if err != nil { return false , err } if len ( devs ) == 1 { return true , nil } return false , nil }
2135	func ( c * Controller ) UpdateContainer ( name string , interfaces [ ] ContainerInterface ) error { macInterfaces , err := parseInterfaces ( interfaces ) if err != nil { return err } subnets , err := c . getSubnets ( ) if err != nil { return err } device , err := c . getDevice ( name ) if err != nil { return err } existingInterfaces := map [ string ] gomaasapi . Interface { } for _ , entry := range device . InterfaceSet ( ) { iface , ok := macInterfaces [ entry . MACAddress ( ) ] if ! ok { err = entry . Delete ( ) if err != nil { return err } continue } existingSubnets := map [ string ] gomaasapi . Subnet { } for _ , link := range entry . Links ( ) { found := false for _ , subnet := range iface . Subnets { if subnet . Name == link . Subnet ( ) . Name ( ) { if subnet . Address == "" || subnet . Address == link . IPAddress ( ) { found = true } break } } if ! found { err = entry . UnlinkSubnet ( link . Subnet ( ) ) if err != nil { return err } continue } existingSubnets [ link . Subnet ( ) . Name ( ) ] = link . Subnet ( ) } for _ , subnet := range iface . Subnets { _ , ok := existingSubnets [ subnet . Name ] if ok { continue } err := entry . LinkSubnet ( gomaasapi . LinkSubnetArgs { Mode : gomaasapi . LinkModeStatic , Subnet : subnets [ subnet . Name ] , IPAddress : subnet . Address , } ) if err != nil { return err } } existingInterfaces [ entry . MACAddress ( ) ] = entry } for _ , iface := range macInterfaces { _ , ok := existingInterfaces [ iface . MACAddress ] if ok { continue } entry , err := device . CreateInterface ( gomaasapi . CreateInterfaceArgs { Name : iface . Name , MACAddress : iface . MACAddress , VLAN : subnets [ iface . Subnets [ 0 ] . Name ] . VLAN ( ) , } ) if err != nil { return err } for _ , subnet := range iface . Subnets { err := entry . LinkSubnet ( gomaasapi . LinkSubnetArgs { Mode : gomaasapi . LinkModeStatic , Subnet : subnets [ subnet . Name ] , IPAddress : subnet . Address , } ) if err != nil { return err } } } return nil }
2136	func ( c * Controller ) RenameContainer ( name string , newName string ) error { device , err := c . getDevice ( name ) if err != nil { return err } uri , err := url . Parse ( fmt . Sprintf ( "%s/devices/%s/" , c . url , device . SystemID ( ) ) ) if err != nil { return err } values := url . Values { } values . Set ( "hostname" , newName ) _ , err = c . srvRaw . Put ( uri , values ) if err != nil { return err } return nil }
2137	func ( c * Controller ) DeleteContainer ( name string ) error { device , err := c . getDevice ( name ) if err != nil { return err } err = device . Delete ( ) if err != nil { return err } return nil }
2138	func ( s * Schema ) Add ( update Update ) { s . updates = append ( s . updates , update ) }
2139	func ensureSchemaTableExists ( tx * sql . Tx ) error { exists , err := DoesSchemaTableExist ( tx ) if err != nil { return fmt . Errorf ( "failed to check if schema table is there: %v" , err ) } if ! exists { err := createSchemaTable ( tx ) if err != nil { return fmt . Errorf ( "failed to create schema table: %v" , err ) } } return nil }
2140	func queryCurrentVersion ( tx * sql . Tx ) ( int , error ) { versions , err := selectSchemaVersions ( tx ) if err != nil { return - 1 , fmt . Errorf ( "failed to fetch update versions: %v" , err ) } hasVersion := func ( v int ) bool { return shared . IntInSlice ( v , versions ) } if hasVersion ( 30 ) && hasVersion ( 32 ) && ! hasVersion ( 31 ) { err = insertSchemaVersion ( tx , 31 ) if err != nil { return - 1 , fmt . Errorf ( "failed to insert missing schema version 31" ) } versions , err = selectSchemaVersions ( tx ) if err != nil { return - 1 , fmt . Errorf ( "failed to fetch update versions: %v" , err ) } } if hasVersion ( 37 ) && ! hasVersion ( 38 ) { count , err := query . Count ( tx , "config" , "key = 'cluster.https_address'" ) if err != nil { return - 1 , fmt . Errorf ( "Failed to check if cluster.https_address is set: %v" , err ) } if count == 1 { err := insertSchemaVersion ( tx , 38 ) if err != nil { return - 1 , fmt . Errorf ( "Failed to insert missing schema version 38" ) } versions = append ( versions , 38 ) } } current := 0 if len ( versions ) > 0 { err = checkSchemaVersionsHaveNoHoles ( versions ) if err != nil { return - 1 , err } current = versions [ len ( versions ) - 1 ] } return current , nil }
2141	func ensureUpdatesAreApplied ( tx * sql . Tx , current int , updates [ ] Update , hook Hook ) error { if current > len ( updates ) { return fmt . Errorf ( "schema version '%d' is more recent than expected '%d'" , current , len ( updates ) ) } if len ( updates ) == 0 { return nil } for _ , update := range updates [ current : ] { if hook != nil { err := hook ( current , tx ) if err != nil { return fmt . Errorf ( "failed to execute hook (version %d): %v" , current , err ) } } err := update ( tx ) if err != nil { return fmt . Errorf ( "failed to apply update %d: %v" , current , err ) } current ++ err = insertSchemaVersion ( tx , current ) if err != nil { return fmt . Errorf ( "failed to insert version %d" , current ) } } return nil }
2142	func checkSchemaVersionsHaveNoHoles ( versions [ ] int ) error { for i := range versions [ : len ( versions ) - 1 ] { if versions [ i + 1 ] != versions [ i ] + 1 { return fmt . Errorf ( "Missing updates: %d to %d" , versions [ i ] , versions [ i + 1 ] ) } } return nil }
2143	func checkAllUpdatesAreApplied ( tx * sql . Tx , updates [ ] Update ) error { versions , err := selectSchemaVersions ( tx ) if err != nil { return fmt . Errorf ( "failed to fetch update versions: %v" , err ) } if len ( versions ) == 0 { return fmt . Errorf ( "expected schema table to contain at least one row" ) } err = checkSchemaVersionsHaveNoHoles ( versions ) if err != nil { return err } current := versions [ len ( versions ) - 1 ] if current != len ( updates ) { return fmt . Errorf ( "update level is %d, expected %d" , current , len ( updates ) ) } return nil }
2144	func formatSQL ( statement string ) string { lines := strings . Split ( statement , "\n" ) \n for i , line := range lines { if strings . Contains ( line , "UNIQUE" ) { continue } lines [ i ] = strings . Replace ( line , ", " , ",\n " , \n ) } }
2145	func GetAllXattr ( path string ) ( xattrs map [ string ] string , err error ) { e1 := fmt . Errorf ( "Extended attributes changed during retrieval" ) pre , err := llistxattr ( path , nil ) if err != nil || pre < 0 { return nil , err } if pre == 0 { return nil , nil } dest := make ( [ ] byte , pre ) post , err := llistxattr ( path , dest ) if err != nil || post < 0 { return nil , err } if post != pre { return nil , e1 } split := strings . Split ( string ( dest ) , "\x00" ) \x00 if split == nil { return nil , fmt . Errorf ( "No valid extended attribute key found" ) } if split [ len ( split ) - 1 ] == "" { split = split [ : len ( split ) - 1 ] } xattrs = make ( map [ string ] string , len ( split ) ) for _ , x := range split { xattr := string ( x ) pre , err = syscall . Getxattr ( path , xattr , nil ) if err != nil || pre < 0 { return nil , err } dest = make ( [ ] byte , pre ) post := 0 if pre > 0 { post , err = syscall . Getxattr ( path , xattr , dest ) if err != nil || post < 0 { return nil , err } } if post != pre { return nil , e1 } xattrs [ xattr ] = string ( dest ) } }
2146	func GetErrno ( err error ) ( errno error , iserrno bool ) { sysErr , ok := err . ( * os . SyscallError ) if ok { return sysErr . Err , true } pathErr , ok := err . ( * os . PathError ) if ok { return pathErr . Err , true } tmpErrno , ok := err . ( syscall . Errno ) if ok { return tmpErrno , true } return nil , false }
2147	func Uname ( ) ( * Utsname , error ) { uname := syscall . Utsname { } err := syscall . Uname ( & uname ) if err != nil { return nil , err } return & Utsname { Sysname : intArrayToString ( uname . Sysname ) , Nodename : intArrayToString ( uname . Nodename ) , Release : intArrayToString ( uname . Release ) , Version : intArrayToString ( uname . Version ) , Machine : intArrayToString ( uname . Machine ) , Domainname : intArrayToString ( uname . Domainname ) , } , nil }
2148	func RegisterStmt ( sql string ) int { code := len ( stmts ) stmts [ code ] = sql return code }
2149	func PrepareStmts ( db * sql . DB ) ( map [ int ] * sql . Stmt , error ) { index := map [ int ] * sql . Stmt { } for code , sql := range stmts { stmt , err := db . Prepare ( sql ) if err != nil { return nil , errors . Wrapf ( err , "%q" , sql ) } index [ code ] = stmt } return index , nil }
2150	func NewGateway ( db * db . Node , cert * shared . CertInfo , options ... Option ) ( * Gateway , error ) { ctx , cancel := context . WithCancel ( context . Background ( ) ) o := newOptions ( ) for _ , option := range options { option ( o ) } gateway := & Gateway { db : db , cert : cert , options : o , ctx : ctx , cancel : cancel , upgradeCh : make ( chan struct { } , 16 ) , acceptCh : make ( chan net . Conn ) , store : & dqliteServerStore { } , } err := gateway . init ( ) if err != nil { return nil , err } return gateway , nil }
2151	func ( g * Gateway ) DialFunc ( ) dqlite . DialFunc { return func ( ctx context . Context , address string ) ( net . Conn , error ) { if g . memoryDial != nil { return g . memoryDial ( ctx , address ) } return dqliteNetworkDial ( ctx , address , g . cert ) } }
2152	func ( g * Gateway ) Shutdown ( ) error { logger . Debugf ( "Stop database gateway" ) if g . raft != nil { err := g . raft . Shutdown ( ) if err != nil { return errors . Wrap ( err , "Failed to shutdown raft" ) } } if g . server != nil { g . Sync ( ) g . server . Close ( ) g . memoryDial = nil } return nil }
2153	func ( g * Gateway ) Sync ( ) { if g . server == nil { return } dir := filepath . Join ( g . db . Dir ( ) , "global" ) err := g . server . Dump ( "db.bin" , dir ) if err != nil { logger . Warnf ( "Failed to dump database to disk: %v" , err ) } }
2154	func ( g * Gateway ) Reset ( cert * shared . CertInfo ) error { err := g . Shutdown ( ) if err != nil { return err } err = os . RemoveAll ( filepath . Join ( g . db . Dir ( ) , "global" ) ) if err != nil { return err } err = g . db . Transaction ( func ( tx * db . NodeTx ) error { return tx . RaftNodesReplace ( nil ) } ) if err != nil { return err } g . cert = cert return g . init ( ) }
2155	func ( g * Gateway ) LeaderAddress ( ) ( string , error ) { if g . memoryDial != nil { return "" , fmt . Errorf ( "Node is not clustered" ) } ctx , cancel := context . WithTimeout ( g . ctx , 5 * time . Second ) defer cancel ( ) if g . raft != nil { for ctx . Err ( ) == nil { address := string ( g . raft . Raft ( ) . Leader ( ) ) if address != "" { return address , nil } time . Sleep ( time . Second ) } return "" , ctx . Err ( ) } config , err := tlsClientConfig ( g . cert ) if err != nil { return "" , err } addresses := [ ] string { } err = g . db . Transaction ( func ( tx * db . NodeTx ) error { nodes , err := tx . RaftNodes ( ) if err != nil { return err } for _ , node := range nodes { addresses = append ( addresses , node . Address ) } return nil } ) if err != nil { return "" , errors . Wrap ( err , "Failed to fetch raft nodes addresses" ) } if len ( addresses ) == 0 { return "" , fmt . Errorf ( "No raft node known" ) } for _ , address := range addresses { url := fmt . Sprintf ( "https://%s%s" , address , databaseEndpoint ) request , err := http . NewRequest ( "GET" , url , nil ) if err != nil { return "" , err } request = request . WithContext ( ctx ) client := & http . Client { Transport : & http . Transport { TLSClientConfig : config } } response , err := client . Do ( request ) if err != nil { logger . Debugf ( "Failed to fetch leader address from %s" , address ) continue } if response . StatusCode != http . StatusOK { logger . Debugf ( "Request for leader address from %s failed" , address ) continue } info := map [ string ] string { } err = shared . ReadToJSON ( response . Body , & info ) if err != nil { logger . Debugf ( "Failed to parse leader address from %s" , address ) continue } leader := info [ "leader" ] if leader == "" { logger . Debugf ( "Raft node %s returned no leader address" , address ) continue } return leader , nil } return "" , fmt . Errorf ( "RAFT cluster is unavailable" ) }
2156	func ( g * Gateway ) waitLeadership ( ) error { n := 80 sleep := 250 * time . Millisecond for i := 0 ; i < n ; i ++ { if g . raft . raft . State ( ) == raft . Leader { return nil } time . Sleep ( sleep ) } return fmt . Errorf ( "RAFT node did not self-elect within %s" , time . Duration ( n ) * sleep ) }
2157	func ( g * Gateway ) currentRaftNodes ( ) ( [ ] db . RaftNode , error ) { if g . raft == nil { return nil , raft . ErrNotLeader } servers , err := g . raft . Servers ( ) if err != nil { return nil , err } provider := raftAddressProvider { db : g . db } nodes := make ( [ ] db . RaftNode , len ( servers ) ) for i , server := range servers { address , err := provider . ServerAddr ( server . ID ) if err != nil { if err != db . ErrNoSuchObject { return nil , errors . Wrap ( err , "Failed to fetch raft server address" ) } address = server . Address } id , err := strconv . Atoi ( string ( server . ID ) ) if err != nil { return nil , errors . Wrap ( err , "Non-numeric server ID" ) } nodes [ i ] . ID = int64 ( id ) nodes [ i ] . Address = string ( address ) } return nodes , nil }
2158	func ( g * Gateway ) cachedRaftNodes ( ) ( [ ] string , error ) { var addresses [ ] string err := g . db . Transaction ( func ( tx * db . NodeTx ) error { var err error addresses , err = tx . RaftNodeAddresses ( ) return err } ) if err != nil { return nil , errors . Wrap ( err , "Failed to fetch raft nodes" ) } return addresses , nil }
2159	func dqliteMemoryDial ( listener net . Listener ) dqlite . DialFunc { return func ( ctx context . Context , address string ) ( net . Conn , error ) { return net . Dial ( "unix" , listener . Addr ( ) . String ( ) ) } }
2160	func DqliteLog ( l dqlite . LogLevel , format string , a ... interface { } ) { format = fmt . Sprintf ( "Dqlite: %s" , format ) switch l { case dqlite . LogDebug : logger . Debugf ( format , a ... ) case dqlite . LogInfo : logger . Debugf ( format , a ... ) case dqlite . LogWarn : logger . Warnf ( format , a ... ) case dqlite . LogError : logger . Errorf ( format , a ... ) } }
2161	func ( r * Response ) MetadataAsMap ( ) ( map [ string ] interface { } , error ) { ret := map [ string ] interface { } { } err := r . MetadataAsStruct ( & ret ) if err != nil { return nil , err } return ret , nil }
2162	func ( r * Response ) MetadataAsOperation ( ) ( * Operation , error ) { op := Operation { } err := r . MetadataAsStruct ( & op ) if err != nil { return nil , err } return & op , nil }
2163	func ( r * Response ) MetadataAsStringSlice ( ) ( [ ] string , error ) { sl := [ ] string { } err := r . MetadataAsStruct ( & sl ) if err != nil { return nil , err } return sl , nil }
2164	func ( r * Response ) MetadataAsStruct ( target interface { } ) error { return json . Unmarshal ( r . Metadata , & target ) }
2165	func ( r * CSVReport ) Load ( ) error { file , err := os . Open ( r . Filename ) if err != nil { return err } defer file . Close ( ) reader := csv . NewReader ( file ) for line := 1 ; err != io . EOF ; line ++ { record , err := reader . Read ( ) if err == io . EOF { break } else if err != nil { return err } err = r . addRecord ( record ) if err != nil { return err } } logf ( "Loaded report file %s" , r . Filename ) return nil }
2166	func ( r * CSVReport ) Write ( ) error { file , err := os . OpenFile ( r . Filename , os . O_WRONLY | os . O_CREATE | os . O_TRUNC , 0640 ) if err != nil { return err } defer file . Close ( ) writer := csv . NewWriter ( file ) err = writer . WriteAll ( r . records ) if err != nil { return err } logf ( "Written report file %s" , r . Filename ) return nil }
2167	func ( r * CSVReport ) AddRecord ( label string , elapsed time . Duration ) error { if len ( r . records ) == 0 { r . addRecord ( csvFields ) } record := [ ] string { fmt . Sprintf ( "%d" , time . Now ( ) . UnixNano ( ) / int64 ( time . Millisecond ) ) , fmt . Sprintf ( "%d" , elapsed / time . Millisecond ) , label , "" , "true" , } return r . addRecord ( record ) }
2168	func LoadConfig ( path string ) ( * Config , error ) { content , err := ioutil . ReadFile ( path ) if err != nil { return nil , fmt . Errorf ( "Unable to read the configuration file: %v" , err ) } c := NewConfig ( filepath . Dir ( path ) , false ) err = yaml . Unmarshal ( content , & c ) if err != nil { return nil , fmt . Errorf ( "Unable to decode the configuration: %v" , err ) } for k , r := range c . Remotes { if ! r . Public && r . AuthType == "" { r . AuthType = "tls" c . Remotes [ k ] = r } } if c . Remotes == nil { c . Remotes = make ( map [ string ] Remote ) } for k , v := range StaticRemotes { if c . Remotes [ k ] . Project != "" { v . Project = c . Remotes [ k ] . Project } c . Remotes [ k ] = v } images , ok := c . Remotes [ "images" ] if ok && images . Protocol != ImagesRemote . Protocol && images . Addr == ImagesRemote . Addr { c . Remotes [ "images" ] = ImagesRemote c . SaveConfig ( path ) } return c , nil }
2169	func ( c * Config ) SaveConfig ( path string ) error { conf := Config { } err := shared . DeepCopy ( c , & conf ) if err != nil { return fmt . Errorf ( "Unable to copy the configuration: %v" , err ) } for k := range StaticRemotes { if k == "local" { continue } delete ( conf . Remotes , k ) } f , err := os . Create ( path ) if err != nil { return fmt . Errorf ( "Unable to create the configuration file: %v" , err ) } defer f . Close ( ) data , err := yaml . Marshal ( conf ) if err != nil { return fmt . Errorf ( "Unable to marshal the configuration: %v" , err ) } _ , err = f . Write ( data ) if err != nil { return fmt . Errorf ( "Unable to write the configuration: %v" , err ) } return nil }
2170	func ( l ChrootLoader ) Get ( path string ) ( io . Reader , error ) { path , err := filepath . EvalSymlinks ( path ) if err != nil { return nil , err } basePath , err := filepath . EvalSymlinks ( l . Path ) if err != nil { return nil , err } if ! strings . HasPrefix ( path , basePath ) { return nil , fmt . Errorf ( "Attempting to access a file outside the container" ) } buf , err := ioutil . ReadFile ( path ) if err != nil { return nil , err } return bytes . NewReader ( buf ) , nil }
2171	func ( c * Config ) ConfigPath ( paths ... string ) string { path := [ ] string { c . ConfigDir } path = append ( path , paths ... ) return filepath . Join ( path ... ) }
2172	func ( c * Config ) ServerCertPath ( remote string ) string { return c . ConfigPath ( "servercerts" , fmt . Sprintf ( "%s.crt" , remote ) ) }
2173	func NewConfig ( configDir string , defaults bool ) * Config { config := & Config { ConfigDir : configDir } if defaults { config . Remotes = DefaultRemotes config . DefaultRemote = "local" } return config }
2174	func ( s * migrationSourceWs ) checkForPreDumpSupport ( ) ( bool , int ) { criuMigrationArgs := CriuMigrationArgs { cmd : lxc . MIGRATE_FEATURE_CHECK , stateDir : "" , function : "feature-check" , stop : false , actionScript : false , dumpDir : "" , preDumpDir : "" , features : lxc . FEATURE_MEM_TRACK , } err := s . container . Migrate ( & criuMigrationArgs ) if err != nil { return false , 0 } use_pre_dumps := true tmp := s . container . ExpandedConfig ( ) [ "migration.incremental.memory" ] if tmp != "" { use_pre_dumps = shared . IsTrue ( tmp ) } var max_iterations int tmp = s . container . ExpandedConfig ( ) [ "migration.incremental.memory.iterations" ] if tmp != "" { max_iterations , _ = strconv . Atoi ( tmp ) } else { max_iterations = 10 } if max_iterations > 999 { max_iterations = 999 } logger . Debugf ( "Using maximal %d iterations for pre-dumping" , max_iterations ) return use_pre_dumps , max_iterations }
2175	func ( s * migrationSourceWs ) preDumpLoop ( args * preDumpLoopArgs ) ( bool , error ) { criuMigrationArgs := CriuMigrationArgs { cmd : lxc . MIGRATE_PRE_DUMP , stop : false , actionScript : false , preDumpDir : args . preDumpDir , dumpDir : args . dumpDir , stateDir : args . checkpointDir , function : "migration" , } logger . Debugf ( "Doing another pre-dump in %s" , args . preDumpDir ) final := args . final err := s . container . Migrate ( & criuMigrationArgs ) if err != nil { return final , err } ctName , _ , _ := containerGetParentAndSnapshotName ( s . container . Name ( ) ) state := s . container . DaemonState ( ) err = RsyncSend ( ctName , shared . AddSlash ( args . checkpointDir ) , s . criuConn , nil , args . rsyncFeatures , args . bwlimit , state . OS . ExecPath ) if err != nil { return final , err } dumpPath := shared . AddSlash ( args . checkpointDir ) dumpPath += shared . AddSlash ( args . dumpDir ) written , skipped_parent , err := readCriuStatsDump ( dumpPath ) if err != nil { return final , err } logger . Debugf ( "CRIU pages written %d" , written ) logger . Debugf ( "CRIU pages skipped %d" , skipped_parent ) total_pages := written + skipped_parent percentage_skipped := int ( 100 - ( ( 100 * written ) / total_pages ) ) logger . Debugf ( "CRIU pages skipped percentage %d%%" , percentage_skipped ) var threshold int tmp := s . container . ExpandedConfig ( ) [ "migration.incremental.memory.goal" ] if tmp != "" { threshold , _ = strconv . Atoi ( tmp ) } else { threshold = 70 } if percentage_skipped > threshold { logger . Debugf ( "Memory pages skipped (%d%%) due to pre-copy is larger than threshold (%d%%)" , percentage_skipped , threshold ) logger . Debugf ( "This was the last pre-dump; next dump is the final dump" ) final = true } logger . Debugf ( "Sending another header" ) sync := migration . MigrationSync { FinalPreDump : proto . Bool ( final ) , } data , err := proto . Marshal ( & sync ) if err != nil { return final , err } err = s . criuConn . WriteMessage ( websocket . BinaryMessage , data ) if err != nil { s . sendControl ( err ) return final , err } logger . Debugf ( "Sending another header done" ) return final , nil }
2176	func newRoot ( ) * cobra . Command { cmd := & cobra . Command { Use : "lxd-generate" , Short : "Code generation tool for LXD development" , Long : `This is the entry point for all "go:generate" directivesused in LXD's source code.` , RunE : func ( cmd * cobra . Command , args [ ] string ) error { return fmt . Errorf ( "Not implemented" ) } , } cmd . AddCommand ( newDb ( ) ) return cmd }
2177	func APIExtensionsCount ( ) int { count := len ( APIExtensions ) artificialBump := os . Getenv ( "LXD_ARTIFICIALLY_BUMP_API_EXTENSIONS" ) if artificialBump != "" { n , err := strconv . Atoi ( artificialBump ) if err == nil { count += n } } return count }
2178	func SelectURIs ( stmt * sql . Stmt , f func ( a ... interface { } ) string , args ... interface { } ) ( [ ] string , error ) { rows , err := stmt . Query ( args ... ) if err != nil { return nil , errors . Wrapf ( err , "Failed to query URIs" ) } defer rows . Close ( ) columns , err := rows . Columns ( ) if err != nil { return nil , errors . Wrap ( err , "Rows columns" ) } params := make ( [ ] interface { } , len ( columns ) ) dest := make ( [ ] interface { } , len ( params ) ) for i := range params { params [ i ] = "" dest [ i ] = & params [ i ] } uris := [ ] string { } for rows . Next ( ) { err := rows . Scan ( dest ... ) if err != nil { return nil , errors . Wrapf ( err , "Failed to scan URI params" ) } uri := f ( params ... ) uris = append ( uris , uri ) } err = rows . Err ( ) if err != nil { return nil , errors . Wrapf ( err , "Failed to close URI result set" ) } return uris , nil }
2179	func SelectStrings ( tx * sql . Tx , query string , args ... interface { } ) ( [ ] string , error ) { values := [ ] string { } scan := func ( rows * sql . Rows ) error { var value string err := rows . Scan ( & value ) if err != nil { return err } values = append ( values , value ) return nil } err := scanSingleColumn ( tx , query , args , "TEXT" , scan ) if err != nil { return nil , err } return values , nil }
2180	func scanSingleColumn ( tx * sql . Tx , query string , args [ ] interface { } , typeName string , scan scanFunc ) error { rows , err := tx . Query ( query , args ... ) if err != nil { return err } defer rows . Close ( ) for rows . Next ( ) { err := scan ( rows ) if err != nil { return err } } err = rows . Err ( ) if err != nil { return err } return nil }
2181	func LazyHandler ( h Handler ) Handler { return FuncHandler ( func ( r * Record ) error { hadErr := false for i := 1 ; i < len ( r . Ctx ) ; i += 2 { lz , ok := r . Ctx [ i ] . ( Lazy ) if ok { v , err := evaluateLazy ( lz ) if err != nil { hadErr = true r . Ctx [ i ] = err } else { if cs , ok := v . ( stack . Trace ) ; ok { v = cs . TrimBelow ( stack . Call ( r . CallPC [ 0 ] ) ) . TrimRuntime ( ) } r . Ctx [ i ] = v } } } if hadErr { r . Ctx = append ( r . Ctx , errorKey , "bad lazy" ) } return h . Log ( r ) } ) }
2182	func Callers ( ) Trace { pcs := poolBuf ( ) pcs = pcs [ : cap ( pcs ) ] n := runtime . Callers ( 2 , pcs ) cs := make ( [ ] Call , n ) for i , pc := range pcs [ : n ] { cs [ i ] = Call ( pc ) } putPoolBuf ( pcs ) return cs }
2183	func ( pc Call ) name ( ) string { pcFix := uintptr ( pc ) - 1 fn := runtime . FuncForPC ( pcFix ) if fn == nil { return "???" } return fn . Name ( ) }
2184	func ( pcs Trace ) TrimBelow ( pc Call ) Trace { for len ( pcs ) > 0 && pcs [ 0 ] != pc { pcs = pcs [ 1 : ] } return pcs }
2185	func ( pcs Trace ) TrimAbove ( pc Call ) Trace { for len ( pcs ) > 0 && pcs [ len ( pcs ) - 1 ] != pc { pcs = pcs [ : len ( pcs ) - 1 ] } return pcs }
2186	func ( pcs Trace ) TrimBelowName ( name string ) Trace { for len ( pcs ) > 0 && pcs [ 0 ] . name ( ) != name { pcs = pcs [ 1 : ] } return pcs }
2187	func ( pcs Trace ) TrimAboveName ( name string ) Trace { for len ( pcs ) > 0 && pcs [ len ( pcs ) - 1 ] . name ( ) != name { pcs = pcs [ : len ( pcs ) - 1 ] } return pcs }
2188	func ( pcs Trace ) TrimRuntime ( ) Trace { for len ( pcs ) > 0 && inGoroot ( pcs [ len ( pcs ) - 1 ] . file ( ) ) { pcs = pcs [ : len ( pcs ) - 1 ] } return pcs }
2189	func GetCaps ( path string ) ( [ ] byte , error ) { xattrs , err := shared . GetAllXattr ( path ) if err != nil { return nil , err } valueStr , ok := xattrs [ "security.capability" ] if ! ok { return nil , nil } return [ ] byte ( valueStr ) , nil }
2190	func SetCaps ( path string , caps [ ] byte , uid int64 ) error { cpath := C . CString ( path ) defer C . free ( unsafe . Pointer ( cpath ) ) ccaps := C . CString ( string ( caps ) ) defer C . free ( unsafe . Pointer ( ccaps ) ) r := C . set_vfs_ns_caps ( cpath , ccaps , C . ssize_t ( len ( caps ) ) , C . uint32_t ( uid ) ) if r != 0 { return fmt . Errorf ( "Failed to apply capabilities to: %s" , path ) } return nil }
2191	func ( pt * ProgressReader ) Read ( p [ ] byte ) ( int , error ) { n , err := pt . ReadCloser . Read ( p ) if pt . Tracker != nil { pt . Tracker . total += int64 ( n ) pt . Tracker . update ( n ) } return n , err }
2192	func Supported ( path string ) ( bool , error ) { devPath , err := devForPath ( path ) if err != nil { return false , err } cDevPath := C . CString ( devPath ) defer C . free ( unsafe . Pointer ( cDevPath ) ) return C . quota_supported ( cDevPath ) == 0 , nil }
2193	func GetProject ( path string ) ( uint32 , error ) { cPath := C . CString ( path ) defer C . free ( unsafe . Pointer ( cPath ) ) id := C . quota_get_path ( cPath ) if id < 0 { return 0 , fmt . Errorf ( "Failed to get project from '%s'" , path ) } return uint32 ( id ) , nil }
2194	func SetProject ( path string , id uint32 ) error { cPath := C . CString ( path ) defer C . free ( unsafe . Pointer ( cPath ) ) if C . quota_set_path ( cPath , C . uint32_t ( id ) ) != 0 { return fmt . Errorf ( "Failed to set project id '%d' on '%s'" , id , path ) } return nil }
2195	func DeleteProject ( path string , id uint32 ) error { err := SetProject ( path , 0 ) if err != nil { return err } err = SetProjectQuota ( path , id , 0 ) if err != nil { return err } return nil }
2196	func GetProjectUsage ( path string , id uint32 ) ( int64 , error ) { devPath , err := devForPath ( path ) if err != nil { return - 1 , err } cDevPath := C . CString ( devPath ) defer C . free ( unsafe . Pointer ( cDevPath ) ) size := C . quota_get_usage ( cDevPath , C . uint32_t ( id ) ) if size < 0 { return - 1 , fmt . Errorf ( "Failed to get project consumption for id '%d' on '%s'" , id , path ) } return int64 ( size ) , nil }
2197	func SetProjectQuota ( path string , id uint32 , bytes int64 ) error { devPath , err := devForPath ( path ) if err != nil { return err } cDevPath := C . CString ( devPath ) defer C . free ( unsafe . Pointer ( cDevPath ) ) if C . quota_set ( cDevPath , C . uint32_t ( id ) , C . int ( bytes / 1024 ) ) != 0 { return fmt . Errorf ( "Failed to set project quota for id '%d' on '%s'" , id , path ) } return nil }
2198	func backupLoadByName ( s * state . State , project , name string ) ( * backup , error ) { args , err := s . Cluster . ContainerGetBackup ( project , name ) if err != nil { return nil , errors . Wrap ( err , "Load backup from database" ) } c , err := containerLoadById ( s , args . ContainerID ) if err != nil { return nil , errors . Wrap ( err , "Load container from database" ) } return & backup { state : s , container : c , id : args . ID , name : name , creationDate : args . CreationDate , expiryDate : args . ExpiryDate , containerOnly : args . ContainerOnly , optimizedStorage : args . OptimizedStorage , } , nil }
2199	func backupCreate ( s * state . State , args db . ContainerBackupArgs , sourceContainer container ) error { err := s . Cluster . ContainerBackupCreate ( args ) if err != nil { if err == db . ErrAlreadyDefined { return fmt . Errorf ( "backup '%s' already exists" , args . Name ) } return errors . Wrap ( err , "Insert backup info into database" ) } b , err := backupLoadByName ( s , sourceContainer . Project ( ) , args . Name ) if err != nil { return errors . Wrap ( err , "Load backup object" ) } err = sourceContainer . Storage ( ) . ContainerBackupCreate ( * b , sourceContainer ) if err != nil { s . Cluster . ContainerBackupRemove ( args . Name ) return errors . Wrap ( err , "Backup storage" ) } return nil }
2200	func ( b * backup ) Rename ( newName string ) error { oldBackupPath := shared . VarPath ( "backups" , b . name ) newBackupPath := shared . VarPath ( "backups" , newName ) backupsPath := shared . VarPath ( "backups" , b . container . Name ( ) ) if ! shared . PathExists ( backupsPath ) { err := os . MkdirAll ( backupsPath , 0700 ) if err != nil { return err } } err := os . Rename ( oldBackupPath , newBackupPath ) if err != nil { return err } empty , _ := shared . PathIsEmpty ( backupsPath ) if empty { err := os . Remove ( backupsPath ) if err != nil { return err } } err = b . state . Cluster . ContainerBackupRename ( b . name , newName ) if err != nil { return err } return nil }
2201	func ( b * backup ) Delete ( ) error { return doBackupDelete ( b . state , b . name , b . container . Name ( ) ) }
2202	func backupFixStoragePool ( c * db . Cluster , b backupInfo , useDefaultPool bool ) error { var poolName string if useDefaultPool { _ , profile , err := c . ProfileGet ( "default" , "default" ) if err != nil { return err } _ , v , err := shared . GetRootDiskDevice ( profile . Devices ) if err != nil { return err } poolName = v [ "pool" ] } else { poolName = b . Pool } _ , pool , err := c . StoragePoolGet ( poolName ) if err != nil { return err } f := func ( path string ) error { backup , err := slurpBackupFile ( path ) if err != nil { return err } rootDiskDeviceFound := false backup . Pool = pool if backup . Container . Devices != nil { devName , _ , err := shared . GetRootDiskDevice ( backup . Container . Devices ) if err == nil { backup . Container . Devices [ devName ] [ "pool" ] = poolName rootDiskDeviceFound = true } } if backup . Container . ExpandedDevices != nil { devName , _ , err := shared . GetRootDiskDevice ( backup . Container . ExpandedDevices ) if err == nil { backup . Container . ExpandedDevices [ devName ] [ "pool" ] = poolName rootDiskDeviceFound = true } } if ! rootDiskDeviceFound { return fmt . Errorf ( "No root device could be found" ) } file , err := os . Create ( path ) if err != nil { return err } defer file . Close ( ) data , err := yaml . Marshal ( & backup ) if err != nil { return err } _ , err = file . Write ( data ) if err != nil { return err } return nil } err = f ( shared . VarPath ( "storage-pools" , pool . Name , "containers" , b . Name , "backup.yaml" ) ) if err != nil { return err } for _ , snap := range b . Snapshots { err = f ( shared . VarPath ( "storage-pools" , pool . Name , "containers-snapshots" , b . Name , snap , "backup.yaml" ) ) if err != nil { return err } } return nil }
2203	func Count ( tx * sql . Tx , table string , where string , args ... interface { } ) ( int , error ) { stmt := fmt . Sprintf ( "SELECT COUNT(*) FROM %s" , table ) if where != "" { stmt += fmt . Sprintf ( " WHERE %s" , where ) } rows , err := tx . Query ( stmt , args ... ) if err != nil { return - 1 , err } defer rows . Close ( ) if ! rows . Next ( ) { return - 1 , fmt . Errorf ( "no rows returned" ) } var count int err = rows . Scan ( & count ) if err != nil { return - 1 , fmt . Errorf ( "failed to scan count column" ) } if rows . Next ( ) { return - 1 , fmt . Errorf ( "more than one row returned" ) } err = rows . Err ( ) if err != nil { return - 1 , err } return count , nil }
2204	func CountAll ( tx * sql . Tx ) ( map [ string ] int , error ) { tables , err := SelectStrings ( tx , "SELECT name FROM sqlite_master WHERE type = 'table'" ) if err != nil { return nil , errors . Wrap ( err , "Failed to fetch table names" ) } counts := map [ string ] int { } for _ , table := range tables { count , err := Count ( tx , table , "" ) if err != nil { return nil , errors . Wrapf ( err , "Failed to count rows of %s" , table ) } counts [ table ] = count } return counts , nil }
2205	func InitTLSConfig ( ) * tls . Config { return & tls . Config { MinVersion : tls . VersionTLS12 , CipherSuites : [ ] uint16 { tls . TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 , tls . TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA , tls . TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 , tls . TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA , tls . TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 , tls . TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA , tls . TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 , tls . TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA , } , PreferServerCipherSuites : true , } }
2206	func ( s * storageLvm ) copyContainerThinpool ( target container , source container , readonly bool ) error { err := s . createSnapshotContainer ( target , source , readonly ) if err != nil { logger . Errorf ( "Error creating snapshot LV for copy: %s" , err ) return err } LVFilesystem := s . getLvmFilesystem ( ) poolName := s . getOnDiskPoolName ( ) containerName := target . Name ( ) containerLvmName := containerNameToLVName ( containerName ) containerLvDevPath := getLvmDevPath ( target . Project ( ) , poolName , storagePoolVolumeAPIEndpointContainers , containerLvmName ) if LVFilesystem == "btrfs" { ourUmount , err := s . ContainerUmount ( source , source . Path ( ) ) if err != nil { return err } if ourUmount { defer s . ContainerMount ( source ) } } msg , err := fsGenerateNewUUID ( LVFilesystem , containerLvDevPath ) if err != nil { logger . Errorf ( "Failed to create new \"%s\" UUID for container \"%s\" on storage pool \"%s\": %s" , \" , \" , \" , \" ) \" } \" }
2207	func ( s * storageLvm ) copyContainerLv ( target container , source container , readonly bool , refresh bool ) error { exists , err := storageLVExists ( getLvmDevPath ( target . Project ( ) , s . getOnDiskPoolName ( ) , storagePoolVolumeAPIEndpointContainers , containerNameToLVName ( target . Name ( ) ) ) ) if err != nil { return err } if ! exists { err := s . ContainerCreate ( target ) if err != nil { return err } } targetName := target . Name ( ) targetStart , err := target . StorageStart ( ) if err != nil { return err } if targetStart { defer target . StorageStop ( ) } sourceName := source . Name ( ) sourceStart , err := source . StorageStart ( ) if err != nil { return err } if sourceStart { defer source . StorageStop ( ) } sourcePool , err := source . StoragePool ( ) if err != nil { return err } sourceContainerMntPoint := getContainerMountPoint ( source . Project ( ) , sourcePool , sourceName ) if source . IsSnapshot ( ) { sourceContainerMntPoint = getSnapshotMountPoint ( source . Project ( ) , sourcePool , sourceName ) } targetContainerMntPoint := getContainerMountPoint ( target . Project ( ) , s . pool . Name , targetName ) if target . IsSnapshot ( ) { targetContainerMntPoint = getSnapshotMountPoint ( source . Project ( ) , s . pool . Name , targetName ) } if source . IsRunning ( ) { err = source . Freeze ( ) if err != nil { return err } defer source . Unfreeze ( ) } bwlimit := s . pool . Config [ "rsync.bwlimit" ] output , err := rsyncLocalCopy ( sourceContainerMntPoint , targetContainerMntPoint , bwlimit ) if err != nil { return fmt . Errorf ( "failed to rsync container: %s: %s" , string ( output ) , err ) } if readonly { targetLvmName := containerNameToLVName ( targetName ) poolName := s . getOnDiskPoolName ( ) output , err := shared . TryRunCommand ( "lvchange" , "-pr" , fmt . Sprintf ( "%s/%s_%s" , poolName , storagePoolVolumeAPIEndpointContainers , targetLvmName ) ) if err != nil { logger . Errorf ( "Failed to make LVM snapshot \"%s\" read-write: %s" , \" , \" ) targetName } } output }
2208	func ( s * storageLvm ) copyContainer ( target container , source container , refresh bool ) error { targetPool , err := target . StoragePool ( ) if err != nil { return err } targetContainerMntPoint := getContainerMountPoint ( target . Project ( ) , targetPool , target . Name ( ) ) err = createContainerMountpoint ( targetContainerMntPoint , target . Path ( ) , target . IsPrivileged ( ) ) if err != nil { return err } sourcePool , err := source . StoragePool ( ) if err != nil { return err } if s . useThinpool && targetPool == sourcePool && ! refresh { err = s . copyContainerThinpool ( target , source , false ) } else { err = s . copyContainerLv ( target , source , false , refresh ) } if err != nil { return err } err = target . TemplateApply ( "copy" ) if err != nil { return err } return nil }
2209	func ( s * storageLvm ) copyVolume ( sourcePool string , source string ) error { targetMntPoint := getStoragePoolVolumeMountPoint ( s . pool . Name , s . volume . Name ) err := os . MkdirAll ( targetMntPoint , 0711 ) if err != nil { return err } if s . useThinpool && sourcePool == s . pool . Name { err = s . copyVolumeThinpool ( source , s . volume . Name , false ) } else { err = s . copyVolumeLv ( sourcePool , source , s . volume . Name , false ) } if err != nil { return err } return nil }
2210	func ( r * ProtocolSimpleStreams ) GetPrivateImage ( fingerprint string , secret string ) ( * api . Image , string , error ) { return nil , "" , fmt . Errorf ( "Private images aren't supported by the simplestreams protocol" ) }
2211	func ( r * ProtocolSimpleStreams ) GetPrivateImageFile ( fingerprint string , secret string , req ImageFileRequest ) ( * ImageFileResponse , error ) { return nil , fmt . Errorf ( "Private images aren't supported by the simplestreams protocol" ) }
2212	func ( r * ProtocolSimpleStreams ) GetImageAliasNames ( ) ( [ ] string , error ) { aliases , err := r . ssClient . ListAliases ( ) if err != nil { return nil , err } names := [ ] string { } for _ , alias := range aliases { names = append ( names , alias . Name ) } return names , nil }
2213	func ProtoRecv ( ws * websocket . Conn , msg proto . Message ) error { mt , r , err := ws . NextReader ( ) if err != nil { return err } if mt != websocket . BinaryMessage { return fmt . Errorf ( "Only binary messages allowed" ) } buf , err := ioutil . ReadAll ( r ) if err != nil { return err } err = proto . Unmarshal ( buf , msg ) if err != nil { return err } return nil }
2214	func ProtoSend ( ws * websocket . Conn , msg proto . Message ) error { w , err := ws . NextWriter ( websocket . BinaryMessage ) if err != nil { return err } defer w . Close ( ) data , err := proto . Marshal ( msg ) if err != nil { return err } err = shared . WriteAll ( w , data ) if err != nil { return err } return nil }
2215	func ProtoSendControl ( ws * websocket . Conn , err error ) { message := "" if err != nil { message = err . Error ( ) } msg := MigrationControl { Success : proto . Bool ( err == nil ) , Message : proto . String ( message ) , } ProtoSend ( ws , & msg ) }
2216	func ( er stdinMirror ) Read ( p [ ] byte ) ( int , error ) { n , err := er . r . Read ( p ) v := rune ( p [ 0 ] ) if v == '\u0001' && ! * er . foundEscape { * er . foundEscape = true return 0 , err } if v == 'q' && * er . foundEscape { select { case er . consoleDisconnect <- true : return 0 , err default : return 0 , err } } * er . foundEscape = false return n , err }
2217	func doContainersGetFromNode ( project , node string , cert * shared . CertInfo ) ( [ ] api . Container , error ) { f := func ( ) ( [ ] api . Container , error ) { client , err := cluster . Connect ( node , cert , true ) if err != nil { return nil , errors . Wrapf ( err , "Failed to connect to node %s" , node ) } client = client . UseProject ( project ) containers , err := client . GetContainers ( ) if err != nil { return nil , errors . Wrapf ( err , "Failed to get containers from node %s" , node ) } return containers , nil } timeout := time . After ( 30 * time . Second ) done := make ( chan struct { } ) var containers [ ] api . Container var err error go func ( ) { containers , err = f ( ) done <- struct { } { } } ( ) select { case <- timeout : err = fmt . Errorf ( "Timeout getting containers from node %s" , node ) case <- done : } return containers , err }
2218	func Retry ( f func ( ) error ) error { var err error for i := 0 ; i < 5 ; i ++ { err = f ( ) if err != nil { logger . Debugf ( "Database error: %#v" , err ) if IsRetriableError ( err ) { logger . Debugf ( "Retry failed db interaction (%v)" , err ) time . Sleep ( 250 * time . Millisecond ) continue } } break } return err }
2219	func IsRetriableError ( err error ) bool { err = errors . Cause ( err ) if err == nil { return false } if err == sqlite3 . ErrLocked || err == sqlite3 . ErrBusy { return true } if strings . Contains ( err . Error ( ) , "database is locked" ) { return true } if strings . Contains ( err . Error ( ) , "bad connection" ) { return true } if strings . Contains ( err . Error ( ) , "disk I/O error" ) { return true } return false }
2220	func AppArmorProfile ( ) string { contents , err := ioutil . ReadFile ( "/proc/self/attr/current" ) if err == nil { return strings . TrimSpace ( string ( contents ) ) } return "" }
2221	func ( s * storageBtrfs ) StoragePoolVolumeCreate ( ) error { logger . Infof ( "Creating BTRFS storage volume \"%s\" on storage pool \"%s\"" , \" , \" ) \" \" s . volume . Name s . pool . Name _ , err := s . StoragePoolMount ( ) if err != nil { return err } isSnapshot := shared . IsSnapshot ( s . volume . Name ) var customSubvolumePath string if isSnapshot { customSubvolumePath = s . getCustomSnapshotSubvolumePath ( s . pool . Name ) } else { customSubvolumePath = s . getCustomSubvolumePath ( s . pool . Name ) } if ! shared . PathExists ( customSubvolumePath ) { err := os . MkdirAll ( customSubvolumePath , 0700 ) if err != nil { return err } } var customSubvolumeName string if isSnapshot { customSubvolumeName = getStoragePoolVolumeSnapshotMountPoint ( s . pool . Name , s . volume . Name ) } else { customSubvolumeName = getStoragePoolVolumeMountPoint ( s . pool . Name , s . volume . Name ) } err = btrfsSubVolumeCreate ( customSubvolumeName ) }
2222	func ( s * storageBtrfs ) ContainerStorageReady ( container container ) bool { containerMntPoint := getContainerMountPoint ( container . Project ( ) , s . pool . Name , container . Name ( ) ) return isBtrfsSubVolume ( containerMntPoint ) }
2223	func ( s * storageBtrfs ) ContainerCreateFromImage ( container container , fingerprint string , tracker * ioprogress . ProgressTracker ) error { logger . Debugf ( "Creating BTRFS storage volume for container \"%s\" on storage pool \"%s\"" , \" , \" ) \" \" s . volume . Name s . pool . Name source := s . pool . Config [ "source" ] if source == "" { return fmt . Errorf ( "no \"source\" property found for the storage pool" ) } \" \" _ , err := s . StoragePoolMount ( ) if err != nil { return errors . Wrap ( err , "Failed to mount storage pool" ) } containerSubvolumePath := s . getContainerSubvolumePath ( s . pool . Name ) if ! shared . PathExists ( containerSubvolumePath ) { err := os . MkdirAll ( containerSubvolumePath , containersDirMode ) if err != nil { return errors . Wrap ( err , "Failed to create volume directory" ) } } imageMntPoint := getImageMountPoint ( s . pool . Name , fingerprint ) imageStoragePoolLockID := getImageCreateLockID ( s . pool . Name , fingerprint ) lxdStorageMapLock . Lock ( ) if waitChannel , ok := lxdStorageOngoingOperationMap [ imageStoragePoolLockID ] ; ok { lxdStorageMapLock . Unlock ( ) if _ , ok := <- waitChannel ; ok { logger . Warnf ( "Received value over semaphore, this should not have happened" ) } } else { lxdStorageOngoingOperationMap [ imageStoragePoolLockID ] = make ( chan bool ) lxdStorageMapLock . Unlock ( ) var imgerr error if ! shared . PathExists ( imageMntPoint ) || ! isBtrfsSubVolume ( imageMntPoint ) { imgerr = s . ImageCreate ( fingerprint , tracker ) } lxdStorageMapLock . Lock ( ) if waitChannel , ok := lxdStorageOngoingOperationMap [ imageStoragePoolLockID ] ; ok { close ( waitChannel ) delete ( lxdStorageOngoingOperationMap , imageStoragePoolLockID ) } lxdStorageMapLock . Unlock ( ) if imgerr != nil { return errors . Wrap ( imgerr , "Failed to create image volume" ) } } containerSubvolumeName := getContainerMountPoint ( container . Project ( ) , s . pool . Name , container . Name ( ) ) err = s . btrfsPoolVolumesSnapshot ( imageMntPoint , containerSubvolumeName , false , false ) if err != nil { return errors . Wrap ( err , "Failed to storage pool volume snapshot" ) } }
2224	func ( s * storageBtrfs ) ContainerSnapshotRename ( snapshotContainer container , newName string ) error { logger . Debugf ( "Renaming BTRFS storage volume for snapshot \"%s\" from %s to %s" , \" , \" , s . volume . Name ) s . volume . Name newName _ , err := s . StoragePoolMount ( ) if err != nil { return err } oldSnapshotSubvolumeName := getSnapshotMountPoint ( snapshotContainer . Project ( ) , s . pool . Name , snapshotContainer . Name ( ) ) newSnapshotSubvolumeName := getSnapshotMountPoint ( snapshotContainer . Project ( ) , s . pool . Name , newName ) err = os . Rename ( oldSnapshotSubvolumeName , newSnapshotSubvolumeName ) if err != nil { return err } }
2225	func ( s * storageBtrfs ) ContainerSnapshotCreateEmpty ( snapshotContainer container ) error { logger . Debugf ( "Creating empty BTRFS storage volume for snapshot \"%s\" on storage pool \"%s\"" , \" , \" ) \" \" s . volume . Name s . pool . Name _ , err := s . StoragePoolMount ( ) if err != nil { return err } sourceName , _ , _ := containerGetParentAndSnapshotName ( snapshotContainer . Name ( ) ) snapshotSubvolumePath := getSnapshotSubvolumePath ( snapshotContainer . Project ( ) , s . pool . Name , sourceName ) snapshotSubvolumeName := getSnapshotMountPoint ( snapshotContainer . Project ( ) , s . pool . Name , snapshotContainer . Name ( ) ) if ! shared . PathExists ( snapshotSubvolumePath ) { err := os . MkdirAll ( snapshotSubvolumePath , containersDirMode ) if err != nil { return err } } err = btrfsSubVolumeCreate ( snapshotSubvolumeName ) if err != nil { return err } snapshotMntPointSymlinkTarget := shared . VarPath ( "storage-pools" , s . pool . Name , "containers-snapshots" , projectPrefix ( snapshotContainer . Project ( ) , sourceName ) ) }
2226	func btrfsSubVolumesDelete ( subvol string ) error { subsubvols , err := btrfsSubVolumesGet ( subvol ) if err != nil { return err } sort . Sort ( sort . Reverse ( sort . StringSlice ( subsubvols ) ) ) for _ , subsubvol := range subsubvols { err := btrfsSubVolumeDelete ( path . Join ( subvol , subsubvol ) ) if err != nil { return err } } err = btrfsSubVolumeDelete ( subvol ) if err != nil { return err } return nil }
2227	func isBtrfsSubVolume ( subvolPath string ) bool { fs := syscall . Stat_t { } err := syscall . Lstat ( subvolPath , & fs ) if err != nil { return false } if fs . Ino != 256 { return false } return true }
2228	func SelectConfig ( tx * sql . Tx , table string , where string , args ... interface { } ) ( map [ string ] string , error ) { query := fmt . Sprintf ( "SELECT key, value FROM %s" , table ) if where != "" { query += fmt . Sprintf ( " WHERE %s" , where ) } rows , err := tx . Query ( query , args ... ) if err != nil { return nil , err } defer rows . Close ( ) values := map [ string ] string { } for rows . Next ( ) { var key string var value string err := rows . Scan ( & key , & value ) if err != nil { return nil , err } values [ key ] = value } err = rows . Err ( ) if err != nil { return nil , err } return values , nil }
2229	func UpdateConfig ( tx * sql . Tx , table string , values map [ string ] string ) error { changes := map [ string ] string { } deletes := [ ] string { } for key , value := range values { if value == "" { deletes = append ( deletes , key ) continue } changes [ key ] = value } err := upsertConfig ( tx , table , changes ) if err != nil { return errors . Wrap ( err , "updating values failed" ) } err = deleteConfig ( tx , table , deletes ) if err != nil { return errors . Wrap ( err , "deleting values failed" ) } return nil }
2230	func deleteConfig ( tx * sql . Tx , table string , keys [ ] string ) error { n := len ( keys ) if n == 0 { return nil } query := fmt . Sprintf ( "DELETE FROM %s WHERE key IN %s" , table , Params ( n ) ) values := make ( [ ] interface { } , n ) for i , key := range keys { values [ i ] = key } _ , err := tx . Exec ( query , values ... ) return err }
2231	func FormatSection ( header string , content string ) string { out := "" if header != "" { out += header + ":\n" } \n for _ , line := range strings . Split ( content , "\n" ) \n { if line != "" { out += " " } out += line + "\n" } }
2232	func ( r * ProtocolLXD ) GetProjects ( ) ( [ ] api . Project , error ) { if ! r . HasExtension ( "projects" ) { return nil , fmt . Errorf ( "The server is missing the required \"projects\" API extension" ) } \" \" projects := [ ] api . Project { } _ , err := r . queryStruct ( "GET" , "/projects?recursion=1" , nil , "" , & projects ) }
2233	func ( r * ProtocolLXD ) GetProject ( name string ) ( * api . Project , string , error ) { if ! r . HasExtension ( "projects" ) { return nil , "" , fmt . Errorf ( "The server is missing the required \"projects\" API extension" ) } \" \" project := api . Project { } etag , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/projects/%s" , url . QueryEscape ( name ) ) , nil , "" , & project ) }
2234	func ( r * ProtocolLXD ) CreateProject ( project api . ProjectsPost ) error { if ! r . HasExtension ( "projects" ) { return fmt . Errorf ( "The server is missing the required \"projects\" API extension" ) } \" \" _ , _ , err := r . query ( "POST" , "/projects" , project , "" ) }
2235	func ( r * ProtocolLXD ) UpdateProject ( name string , project api . ProjectPut , ETag string ) error { if ! r . HasExtension ( "projects" ) { return fmt . Errorf ( "The server is missing the required \"projects\" API extension" ) } \" \" _ , _ , err := r . query ( "PUT" , fmt . Sprintf ( "/projects/%s" , url . QueryEscape ( name ) ) , project , ETag ) }
2236	func ( r * ProtocolLXD ) RenameProject ( name string , project api . ProjectPost ) ( Operation , error ) { if ! r . HasExtension ( "projects" ) { return nil , fmt . Errorf ( "The server is missing the required \"projects\" API extension" ) } \" \" op , _ , err := r . queryOperation ( "POST" , fmt . Sprintf ( "/projects/%s" , url . QueryEscape ( name ) ) , project , "" ) }
2237	func ( er Reader ) Read ( p [ ] byte ) ( int , error ) { again : n , err := er . Reader . Read ( p ) if err == nil { return n , nil } errno , ok := shared . GetErrno ( err ) if ok && ( errno == syscall . EAGAIN || errno == syscall . EINTR ) { goto again } return n , err }
2238	func ( ew Writer ) Write ( p [ ] byte ) ( int , error ) { again : n , err := ew . Writer . Write ( p ) if err == nil { return n , nil } errno , ok := shared . GetErrno ( err ) if ok && ( errno == syscall . EAGAIN || errno == syscall . EINTR ) { goto again } return n , err }
2239	func NewCanceler ( ) * Canceler { c := Canceler { } c . lock . Lock ( ) c . reqChCancel = make ( map [ * http . Request ] chan struct { } ) c . lock . Unlock ( ) return & c }
2240	func ( c * Canceler ) Cancelable ( ) bool { c . lock . Lock ( ) length := len ( c . reqChCancel ) c . lock . Unlock ( ) return length > 0 }
2241	func ( c * Canceler ) Cancel ( ) error { if ! c . Cancelable ( ) { return fmt . Errorf ( "This operation can't be canceled at this time" ) } c . lock . Lock ( ) for req , ch := range c . reqChCancel { close ( ch ) delete ( c . reqChCancel , req ) } c . lock . Unlock ( ) return nil }
2242	func CancelableDownload ( c * Canceler , client * http . Client , req * http . Request ) ( * http . Response , chan bool , error ) { chDone := make ( chan bool ) chCancel := make ( chan struct { } ) if c != nil { c . lock . Lock ( ) c . reqChCancel [ req ] = chCancel c . lock . Unlock ( ) } req . Cancel = chCancel go func ( ) { <- chDone if c != nil { c . lock . Lock ( ) delete ( c . reqChCancel , req ) c . lock . Unlock ( ) } } ( ) resp , err := client . Do ( req ) return resp , chDone , err }
2243	func clusterGet ( d * Daemon , r * http . Request ) Response { name := "" err := d . cluster . Transaction ( func ( tx * db . ClusterTx ) error { var err error name , err = tx . NodeName ( ) return err } ) if err != nil { return SmartError ( err ) } if name == "none" { name = "" } memberConfig , err := clusterGetMemberConfig ( d . cluster ) if err != nil { return SmartError ( err ) } cluster := api . Cluster { ServerName : name , Enabled : name != "" , MemberConfig : memberConfig , } return SyncResponseETag ( true , cluster , cluster ) }
2244	func clusterGetMemberConfig ( cluster * db . Cluster ) ( [ ] api . ClusterMemberConfigKey , error ) { var pools map [ string ] map [ string ] string var networks map [ string ] map [ string ] string keys := [ ] api . ClusterMemberConfigKey { } err := cluster . Transaction ( func ( tx * db . ClusterTx ) error { var err error pools , err = tx . StoragePoolsNodeConfig ( ) if err != nil { return errors . Wrapf ( err , "Failed to fetch storage pools configuration" ) } networks , err = tx . NetworksNodeConfig ( ) if err != nil { return errors . Wrapf ( err , "Failed to fetch networks configuration" ) } return nil } ) if err != nil { return nil , err } for pool , config := range pools { for key := range config { if strings . HasPrefix ( key , "volatile." ) { continue } key := api . ClusterMemberConfigKey { Entity : "storage-pool" , Name : pool , Key : key , Description : fmt . Sprintf ( "\"%s\" property for storage pool \"%s\"" , \" , \" ) , } \" } } \" key }
2245	func clusterPutDisable ( d * Daemon ) Response { err := d . cluster . Close ( ) if err != nil { return SmartError ( err ) } for _ , suffix := range [ ] string { "crt" , "key" , "ca" } { path := filepath . Join ( d . os . VarDir , "cluster." + suffix ) if ! shared . PathExists ( path ) { continue } err := os . Remove ( path ) if err != nil { return InternalError ( err ) } } cert , err := util . LoadCert ( d . os . VarDir ) if err != nil { return InternalError ( errors . Wrap ( err , "failed to parse node certificate" ) ) } d . endpoints . NetworkUpdateCert ( cert ) err = d . gateway . Reset ( cert ) if err != nil { return SmartError ( err ) } address , err := node . HTTPSAddress ( d . db ) if err != nil { return SmartError ( err ) } store := d . gateway . ServerStore ( ) d . cluster , err = db . OpenCluster ( "db.bin" , store , address , "/unused/db/dir" , d . config . DqliteSetupTimeout , dqlite . WithDialFunc ( d . gateway . DialFunc ( ) ) , dqlite . WithContext ( d . gateway . Context ( ) ) , ) if err != nil { return SmartError ( err ) } d . stopClusterTasks ( ) version . UserAgentFeatures ( nil ) return EmptySyncResponse }
2246	func tryClusterRebalance ( d * Daemon ) error { leader , err := d . gateway . LeaderAddress ( ) if err != nil { return errors . Wrap ( err , "failed to get current leader node" ) } cert := d . endpoints . NetworkCert ( ) client , err := cluster . Connect ( leader , cert , true ) if err != nil { return errors . Wrap ( err , "failed to connect to leader node" ) } _ , _ , err = client . RawQuery ( "POST" , "/internal/cluster/rebalance" , nil , "" ) if err != nil { return errors . Wrap ( err , "request to rebalance cluster failed" ) } return nil }
2247	func internalClusterPostRebalance ( d * Daemon , r * http . Request ) Response { localAddress , err := node . ClusterAddress ( d . db ) if err != nil { return SmartError ( err ) } leader , err := d . gateway . LeaderAddress ( ) if err != nil { return InternalError ( err ) } if localAddress != leader { logger . Debugf ( "Redirect cluster rebalance request to %s" , leader ) url := & url . URL { Scheme : "https" , Path : "/internal/cluster/rebalance" , Host : leader , } return SyncResponseRedirect ( url . String ( ) ) } logger . Debugf ( "Rebalance cluster" ) address , nodes , err := cluster . Rebalance ( d . State ( ) , d . gateway ) if err != nil { return SmartError ( err ) } if address == "" { return SyncResponse ( true , nil ) } post := & internalClusterPostPromoteRequest { } for _ , node := range nodes { post . RaftNodes = append ( post . RaftNodes , internalRaftNode { ID : node . ID , Address : node . Address , } ) } cert := d . endpoints . NetworkCert ( ) client , err := cluster . Connect ( address , cert , false ) if err != nil { return SmartError ( err ) } _ , _ , err = client . RawQuery ( "POST" , "/internal/cluster/promote" , post , "" ) if err != nil { return SmartError ( err ) } return SyncResponse ( true , nil ) }
2248	func internalClusterPostPromote ( d * Daemon , r * http . Request ) Response { req := internalClusterPostPromoteRequest { } err := json . NewDecoder ( r . Body ) . Decode ( & req ) if err != nil { return BadRequest ( err ) } if len ( req . RaftNodes ) == 0 { return BadRequest ( fmt . Errorf ( "No raft nodes provided" ) ) } nodes := make ( [ ] db . RaftNode , len ( req . RaftNodes ) ) for i , node := range req . RaftNodes { nodes [ i ] . ID = node . ID nodes [ i ] . Address = node . Address } err = cluster . Promote ( d . State ( ) , d . gateway , nodes ) if err != nil { return SmartError ( err ) } return SyncResponse ( true , nil ) }
2249	func Filters ( pkg * ast . Package , entity string ) [ ] [ ] string { objects := pkg . Scope . Objects filters := [ ] [ ] string { } prefix := fmt . Sprintf ( "%sObjectsBy" , entity ) for name := range objects { if ! strings . HasPrefix ( name , prefix ) { continue } rest := name [ len ( prefix ) : ] filters = append ( filters , strings . Split ( rest , "And" ) ) } sort . SliceStable ( filters , func ( i , j int ) bool { return len ( filters [ i ] ) > len ( filters [ j ] ) } ) return filters }
2250	func Parse ( pkg * ast . Package , name string ) ( * Mapping , error ) { str := findStruct ( pkg . Scope , name ) if str == nil { return nil , fmt . Errorf ( "No declaration found for %q" , name ) } fields , err := parseStruct ( str ) if err != nil { return nil , errors . Wrapf ( err , "Failed to parse %q" , name ) } m := & Mapping { Package : pkg . Name , Name : name , Fields : fields , } return m , nil }
2251	func findStruct ( scope * ast . Scope , name string ) * ast . StructType { obj := scope . Lookup ( name ) if obj == nil { return nil } typ , ok := obj . Decl . ( * ast . TypeSpec ) if ! ok { return nil } str , ok := typ . Type . ( * ast . StructType ) if ! ok { return nil } return str }
2252	func parseStruct ( str * ast . StructType ) ( [ ] * Field , error ) { fields := make ( [ ] * Field , 0 ) for _ , f := range str . Fields . List { if len ( f . Names ) == 0 { ident , ok := f . Type . ( * ast . Ident ) if ! ok { continue } typ , ok := ident . Obj . Decl . ( * ast . TypeSpec ) if ! ok { continue } parentStr , ok := typ . Type . ( * ast . StructType ) if ! ok { continue } parentFields , err := parseStruct ( parentStr ) if err != nil { return nil , errors . Wrapf ( err , "Failed to parse parent struct" ) } fields = append ( fields , parentFields ... ) continue } if len ( f . Names ) != 1 { return nil , fmt . Errorf ( "Expected a single field name, got %q" , f . Names ) } field , err := parseField ( f ) if err != nil { return nil , err } fields = append ( fields , field ) } return fields , nil }
2253	func ( r * ProtocolLXD ) GetProfileNames ( ) ( [ ] string , error ) { urls := [ ] string { } _ , err := r . queryStruct ( "GET" , "/profiles" , nil , "" , & urls ) if err != nil { return nil , err } names := [ ] string { } for _ , url := range urls { fields := strings . Split ( url , "/profiles/" ) names = append ( names , strings . Split ( fields [ len ( fields ) - 1 ] , "?" ) [ 0 ] ) } return names , nil }
2254	func ( r * ProtocolLXD ) GetProfiles ( ) ( [ ] api . Profile , error ) { profiles := [ ] api . Profile { } _ , err := r . queryStruct ( "GET" , "/profiles?recursion=1" , nil , "" , & profiles ) if err != nil { return nil , err } return profiles , nil }
2255	func ( r * ProtocolLXD ) GetProfile ( name string ) ( * api . Profile , string , error ) { profile := api . Profile { } etag , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/profiles/%s" , url . QueryEscape ( name ) ) , nil , "" , & profile ) if err != nil { return nil , "" , err } return & profile , etag , nil }
2256	func ( r * ProtocolLXD ) CreateProfile ( profile api . ProfilesPost ) error { _ , _ , err := r . query ( "POST" , "/profiles" , profile , "" ) if err != nil { return err } return nil }
2257	func ( r * ProtocolLXD ) UpdateProfile ( name string , profile api . ProfilePut , ETag string ) error { _ , _ , err := r . query ( "PUT" , fmt . Sprintf ( "/profiles/%s" , url . QueryEscape ( name ) ) , profile , ETag ) if err != nil { return err } return nil }
2258	func ( r * ProtocolLXD ) RenameProfile ( name string , profile api . ProfilePost ) error { _ , _ , err := r . query ( "POST" , fmt . Sprintf ( "/profiles/%s" , url . QueryEscape ( name ) ) , profile , "" ) if err != nil { return err } return nil }
2259	func Load ( schema Schema , values map [ string ] string ) ( Map , error ) { m := Map { schema : schema , } _ , err := m . update ( values ) return m , err }
2260	func ( m * Map ) Dump ( ) map [ string ] interface { } { values := map [ string ] interface { } { } for name , key := range m . schema { value := m . GetRaw ( name ) if value != key . Default { if key . Hidden { values [ name ] = true } else { values [ name ] = value } } } return values }
2261	func ( m * Map ) GetRaw ( name string ) string { key := m . schema . mustGetKey ( name ) value , ok := m . values [ name ] if ! ok { value = key . Default } return value }
2262	func ( m * Map ) GetString ( name string ) string { m . schema . assertKeyType ( name , String ) return m . GetRaw ( name ) }
2263	func ( m * Map ) GetBool ( name string ) bool { m . schema . assertKeyType ( name , Bool ) return shared . IsTrue ( m . GetRaw ( name ) ) }
2264	func ( m * Map ) GetInt64 ( name string ) int64 { m . schema . assertKeyType ( name , Int64 ) n , err := strconv . ParseInt ( m . GetRaw ( name ) , 10 , 64 ) if err != nil { panic ( fmt . Sprintf ( "cannot convert to int64: %v" , err ) ) } return n }
2265	func ( m * Map ) update ( values map [ string ] string ) ( [ ] string , error ) { initial := m . values == nil if initial { m . values = make ( map [ string ] string , len ( values ) ) } errors := ErrorList { } names := [ ] string { } for name , value := range values { changed , err := m . set ( name , value , initial ) if err != nil { errors . add ( name , value , err . Error ( ) ) continue } if changed { names = append ( names , name ) } } sort . Strings ( names ) var err error if errors . Len ( ) > 0 { errors . sort ( ) err = errors } return names , err }
2266	func ( m * Map ) set ( name string , value string , initial bool ) ( bool , error ) { key , ok := m . schema [ name ] if ! ok { return false , fmt . Errorf ( "unknown key" ) } err := key . validate ( value ) if err != nil { return false , err } current := m . GetRaw ( name ) if key . Type == Bool { value = normalizeBool ( value ) current = normalizeBool ( current ) } if value == current { return false , nil } if ! initial && key . Setter != nil { value , err = key . Setter ( value ) if err != nil { return false , err } } if value == "" { delete ( m . values , name ) } else { m . values [ name ] = value } return true , nil }
2267	func DoesSchemaTableExist ( tx * sql . Tx ) ( bool , error ) { statement := `SELECT COUNT(name) FROM sqlite_master WHERE type = 'table' AND name = 'schema'` rows , err := tx . Query ( statement ) if err != nil { return false , err } defer rows . Close ( ) if ! rows . Next ( ) { return false , fmt . Errorf ( "schema table query returned no rows" ) } var count int err = rows . Scan ( & count ) if err != nil { return false , err } return count == 1 , nil }
2268	func selectSchemaVersions ( tx * sql . Tx ) ( [ ] int , error ) { statement := `SELECT version FROM schema ORDER BY version` return query . SelectIntegers ( tx , statement ) }
2269	func selectTablesSQL ( tx * sql . Tx ) ( [ ] string , error ) { statement := `SELECT sql FROM sqlite_master WHERE type IN ('table', 'index', 'view') AND name != 'schema' AND name NOT LIKE 'sqlite_%'ORDER BY name` return query . SelectStrings ( tx , statement ) }
2270	func createSchemaTable ( tx * sql . Tx ) error { statement := `CREATE TABLE schema ( id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, version INTEGER NOT NULL, updated_at DATETIME NOT NULL, UNIQUE (version))` _ , err := tx . Exec ( statement ) return err }
2271	func insertSchemaVersion ( tx * sql . Tx , new int ) error { statement := `INSERT INTO schema (version, updated_at) VALUES (?, strftime("%s"))` _ , err := tx . Exec ( statement , new ) return err }
2272	func NewState ( node * db . Node , cluster * db . Cluster , maas * maas . Controller , os * sys . OS , endpoints * endpoints . Endpoints ) * State { return & State { Node : node , Cluster : cluster , MAAS : maas , OS : os , Endpoints : endpoints , } }
2273	func containerLXCUnload ( c * containerLXC ) { runtime . SetFinalizer ( c , nil ) if c . c != nil { c . c . Release ( ) c . c = nil } }
2274	func containerLXCInstantiate ( s * state . State , args db . ContainerArgs ) * containerLXC { return & containerLXC { state : s , id : args . ID , project : args . Project , name : args . Name , description : args . Description , ephemeral : args . Ephemeral , architecture : args . Architecture , cType : args . Ctype , creationDate : args . CreationDate , lastUsedDate : args . LastUsedDate , profiles : args . Profiles , localConfig : args . Config , localDevices : args . Devices , stateful : args . Stateful , node : args . Node , expiryDate : args . ExpiryDate , } }
2275	func ( c * containerLXC ) initStorage ( ) error { if c . storage != nil { return nil } s , err := storagePoolVolumeContainerLoadInit ( c . state , c . Project ( ) , c . Name ( ) ) if err != nil { return err } c . storage = s return nil }
2276	func ( c * containerLXC ) OnNetworkUp ( deviceName string , hostName string ) error { device := c . expandedDevices [ deviceName ] device [ "host_name" ] = hostName return c . setupHostVethDevice ( device ) }
2277	func ( c * containerLXC ) setupHostVethDevice ( device types . Device ) error { if device [ "host_name" ] == "" { device [ "host_name" ] = c . getHostInterface ( device [ "name" ] ) } if device [ "host_name" ] == "" { return fmt . Errorf ( "LXC doesn't know about this device and the host_name property isn't set, can't find host side veth name" ) } err := c . setNetworkLimits ( device ) if err != nil { return err } err = c . setNetworkRoutes ( device ) if err != nil { return err } return nil }
2278	func ( c * containerLXC ) getLxcState ( ) ( lxc . State , error ) { if c . IsSnapshot ( ) { return lxc . StateMap [ "STOPPED" ] , nil } err := c . initLXC ( false ) if err != nil { return lxc . StateMap [ "STOPPED" ] , err } monitor := make ( chan lxc . State , 1 ) go func ( c * lxc . Container ) { monitor <- c . State ( ) } ( c . c ) select { case state := <- monitor : return state , nil case <- time . After ( 5 * time . Second ) : return lxc . StateMap [ "FROZEN" ] , LxcMonitorStateError } }
2279	func ( c * containerLXC ) StorageStartSensitive ( ) ( bool , error ) { err := c . initStorage ( ) if err != nil { return false , err } var isOurOperation bool if c . IsSnapshot ( ) { isOurOperation , err = c . storage . ContainerSnapshotStart ( c ) } else { isOurOperation , err = c . storage . ContainerMount ( c ) } return isOurOperation , err }
2280	func ( c * containerLXC ) deviceExistsInDevicesFolder ( prefix string , path string ) bool { relativeDestPath := strings . TrimPrefix ( path , "/" ) devName := fmt . Sprintf ( "%s.%s" , strings . Replace ( prefix , "/" , "-" , - 1 ) , strings . Replace ( relativeDestPath , "/" , "-" , - 1 ) ) devPath := filepath . Join ( c . DevicesPath ( ) , devName ) return shared . PathExists ( devPath ) }
2281	func ( c * containerLXC ) createDiskDevice ( name string , m types . Device ) ( string , error ) { relativeDestPath := strings . TrimPrefix ( m [ "path" ] , "/" ) devName := fmt . Sprintf ( "disk.%s.%s" , strings . Replace ( name , "/" , "-" , - 1 ) , strings . Replace ( relativeDestPath , "/" , "-" , - 1 ) ) devPath := filepath . Join ( c . DevicesPath ( ) , devName ) srcPath := shared . HostPath ( m [ "source" ] ) isOptional := shared . IsTrue ( m [ "optional" ] ) isReadOnly := shared . IsTrue ( m [ "readonly" ] ) isRecursive := shared . IsTrue ( m [ "recursive" ] ) isFile := false if m [ "pool" ] == "" { isFile = ! shared . IsDir ( srcPath ) && ! deviceIsBlockdev ( srcPath ) } else { if filepath . IsAbs ( m [ "source" ] ) { return "" , fmt . Errorf ( "When the \"pool\" property is set \"source\" must specify the name of a volume, not a path" ) } \" \" \" \" volumeTypeName := "" volumeName := filepath . Clean ( m [ "source" ] ) slash := strings . Index ( volumeName , "/" ) if ( slash > 0 ) && ( len ( volumeName ) > slash ) { volumeName = m [ "source" ] [ ( slash + 1 ) : ] volumeTypeName = m [ "source" ] [ : slash ] } } switch volumeTypeName { case storagePoolVolumeTypeNameContainer : return "" , fmt . Errorf ( "Using container storage volumes is not supported" ) case "" : volumeTypeName = storagePoolVolumeTypeNameCustom fallthrough case storagePoolVolumeTypeNameCustom : srcPath = shared . VarPath ( "storage-pools" , m [ "pool" ] , volumeTypeName , volumeName ) case storagePoolVolumeTypeNameImage : return "" , fmt . Errorf ( "Using image storage volumes is not supported" ) default : return "" , fmt . Errorf ( "Unknown storage type prefix \"%s\" found" , \" ) } \" volumeTypeName volumeType , _ := storagePoolVolumeTypeNameToType ( volumeTypeName ) s , err := storagePoolVolumeAttachInit ( c . state , m [ "pool" ] , volumeName , volumeType , c ) if err != nil && ! isOptional { return "" , fmt . Errorf ( "Failed to initialize storage volume \"%s\" of type \"%s\" on storage pool \"%s\": %s" , \" , \" , \" , \" ) } else \" \" }
2282	func ( c * containerLXC ) setNetworkRoutes ( m types . Device ) error { if ! shared . PathExists ( fmt . Sprintf ( "/sys/class/net/%s" , m [ "host_name" ] ) ) { return fmt . Errorf ( "Unknown or missing host side veth: %s" , m [ "host_name" ] ) } _ , err := shared . RunCommand ( "ip" , "-4" , "route" , "flush" , "dev" , m [ "host_name" ] , "proto" , "static" ) if err != nil { return err } _ , err = shared . RunCommand ( "ip" , "-6" , "route" , "flush" , "dev" , m [ "host_name" ] , "proto" , "static" ) if err != nil { return err } if m [ "ipv4.routes" ] != "" { for _ , route := range strings . Split ( m [ "ipv4.routes" ] , "," ) { route = strings . TrimSpace ( route ) _ , err := shared . RunCommand ( "ip" , "-4" , "route" , "add" , "dev" , m [ "host_name" ] , route , "proto" , "static" ) if err != nil { return err } } } if m [ "ipv6.routes" ] != "" { for _ , route := range strings . Split ( m [ "ipv6.routes" ] , "," ) { route = strings . TrimSpace ( route ) _ , err := shared . RunCommand ( "ip" , "-6" , "route" , "add" , "dev" , m [ "host_name" ] , route , "proto" , "static" ) if err != nil { return err } } } return nil }
2283	func ( c * containerLXC ) Path ( ) string { name := projectPrefix ( c . Project ( ) , c . Name ( ) ) return containerPath ( name , c . IsSnapshot ( ) ) }
2284	func ( c * containerLXC ) maasInterfaces ( ) ( [ ] maas . ContainerInterface , error ) { interfaces := [ ] maas . ContainerInterface { } for k , m := range c . expandedDevices { if m [ "type" ] != "nic" { continue } if m [ "maas.subnet.ipv4" ] == "" && m [ "maas.subnet.ipv6" ] == "" { continue } m , err := c . fillNetworkDevice ( k , m ) if err != nil { return nil , err } subnets := [ ] maas . ContainerInterfaceSubnet { } if m [ "maas.subnet.ipv4" ] != "" { subnet := maas . ContainerInterfaceSubnet { Name : m [ "maas.subnet.ipv4" ] , Address : m [ "ipv4.address" ] , } subnets = append ( subnets , subnet ) } if m [ "maas.subnet.ipv6" ] != "" { subnet := maas . ContainerInterfaceSubnet { Name : m [ "maas.subnet.ipv6" ] , Address : m [ "ipv6.address" ] , } subnets = append ( subnets , subnet ) } iface := maas . ContainerInterface { Name : m [ "name" ] , MACAddress : m [ "hwaddr" ] , Subnets : subnets , } interfaces = append ( interfaces , iface ) } return interfaces , nil }
2285	func getSystemHandler ( syslog string , debug bool , format log . Format ) log . Handler { if syslog != "" { if ! debug { return log . LvlFilterHandler ( log . LvlInfo , log . Must . SyslogHandler ( syslog , format ) , ) } return log . Must . SyslogHandler ( syslog , format ) } return nil }
2286	func findNvidiaMinor ( pci string ) ( string , error ) { nvidiaPath := fmt . Sprintf ( "/proc/driver/nvidia/gpus/%s/information" , pci ) buf , err := ioutil . ReadFile ( nvidiaPath ) if err != nil { return "" , err } strBuf := strings . TrimSpace ( string ( buf ) ) idx := strings . Index ( strBuf , "Device Minor:" ) if idx != - 1 { idx += len ( "Device Minor:" ) strBuf = strBuf [ idx : ] strBuf = strings . TrimSpace ( strBuf ) parts := strings . SplitN ( strBuf , "\n" , \n ) 2 _ , err = strconv . Atoi ( parts [ 0 ] ) } if err == nil { return parts [ 0 ] , nil } minor , err := findNvidiaMinorOld ( ) if err == nil { return minor , nil } }
2287	func GetLogger ( syslog string , logfile string , verbose bool , debug bool , customHandler log . Handler ) ( logger . Logger , error ) { Log := log . New ( ) var handlers [ ] log . Handler var syshandler log . Handler syshandler = getSystemHandler ( syslog , debug , LogfmtFormat ( ) ) if syshandler != nil { handlers = append ( handlers , syshandler ) } if logfile != "" { if ! pathExists ( filepath . Dir ( logfile ) ) { return nil , fmt . Errorf ( "Log file path doesn't exist: %s" , filepath . Dir ( logfile ) ) } if ! debug { handlers = append ( handlers , log . LvlFilterHandler ( log . LvlInfo , log . Must . FileHandler ( logfile , LogfmtFormat ( ) ) , ) , ) } else { handlers = append ( handlers , log . Must . FileHandler ( logfile , LogfmtFormat ( ) ) ) } } format := LogfmtFormat ( ) if term . IsTty ( os . Stderr . Fd ( ) ) { format = TerminalFormat ( ) } if verbose || debug { if ! debug { handlers = append ( handlers , log . LvlFilterHandler ( log . LvlInfo , log . StreamHandler ( os . Stderr , format ) , ) , ) } else { handlers = append ( handlers , log . StreamHandler ( os . Stderr , format ) ) } } else { handlers = append ( handlers , log . LvlFilterHandler ( log . LvlWarn , log . StreamHandler ( os . Stderr , format ) , ) , ) } if customHandler != nil { handlers = append ( handlers , customHandler ) } Log . SetHandler ( log . MultiHandler ( handlers ... ) ) return Log , nil }
2288	func SetLogger ( newLogger logger . Logger ) func ( ) { origLog := logger . Log logger . Log = newLogger return func ( ) { logger . Log = origLog } }
2289	func WaitRecord ( ch chan * log . Record , timeout time . Duration ) * log . Record { select { case record := <- ch : return record case <- time . After ( timeout ) : return nil } }
2290	func AddContext ( logger logger . Logger , ctx log . Ctx ) logger . Logger { log15logger , ok := logger . ( log . Logger ) if ! ok { logger . Error ( "couldn't downcast logger to add context" , log . Ctx { "logger" : log15logger , "ctx" : ctx } ) return logger } return log15logger . New ( ctx ) }
2291	func NewDottedVersion ( versionString string ) ( * DottedVersion , error ) { formatError := fmt . Errorf ( "Invalid version format: %s" , versionString ) split := strings . Split ( versionString , "." ) if len ( split ) < 2 { return nil , formatError } maj , err := strconv . Atoi ( split [ 0 ] ) if err != nil { return nil , formatError } min , err := strconv . Atoi ( split [ 1 ] ) if err != nil { return nil , formatError } patch := - 1 if len ( split ) == 3 { patch , err = strconv . Atoi ( split [ 2 ] ) if err != nil { return nil , formatError } } return & DottedVersion { Major : maj , Minor : min , Patch : patch , } , nil }
2292	func Parse ( s string ) ( * DottedVersion , error ) { r , _ := regexp . Compile ( `^([0-9]+.[0-9]+(.[0-9]+))?.*` ) matches := r . FindAllStringSubmatch ( s , - 1 ) if len ( matches [ 0 ] ) < 2 { return nil , fmt . Errorf ( "Can't parse a version" ) } return NewDottedVersion ( matches [ 0 ] [ 1 ] ) }
2293	func ( v * DottedVersion ) String ( ) string { version := fmt . Sprintf ( "%d.%d" , v . Major , v . Minor ) if v . Patch != - 1 { version += fmt . Sprintf ( ".%d" , v . Patch ) } return version }
2294	func ( v * DottedVersion ) Compare ( other * DottedVersion ) int { result := compareInts ( v . Major , other . Major ) if result != 0 { return result } result = compareInts ( v . Minor , other . Minor ) if result != 0 { return result } return compareInts ( v . Patch , other . Patch ) }
2295	func projectCreateDefaultProfile ( tx * db . ClusterTx , project string ) error { profile := db . Profile { } profile . Project = project profile . Name = "default" profile . Description = fmt . Sprintf ( "Default LXD profile for project %s" , project ) profile . Config = map [ string ] string { } profile . Devices = types . Devices { } _ , err := tx . ProfileCreate ( profile ) if err != nil { return errors . Wrap ( err , "Add default profile to database" ) } return nil }
2296	func projectChange ( d * Daemon , project * api . Project , req api . ProjectPut ) Response { featuresChanged := req . Config [ "features.images" ] != project . Config [ "features.images" ] || req . Config [ "features.profiles" ] != project . Config [ "features.profiles" ] if project . Name == "default" && featuresChanged { return BadRequest ( fmt . Errorf ( "You can't change the features of the default project" ) ) } if ! projectIsEmpty ( project ) && featuresChanged { return BadRequest ( fmt . Errorf ( "Features can only be changed on empty projects" ) ) } err := projectValidateConfig ( req . Config ) if err != nil { return BadRequest ( err ) } err = d . cluster . Transaction ( func ( tx * db . ClusterTx ) error { err := tx . ProjectUpdate ( project . Name , req ) if err != nil { return errors . Wrap ( err , "Persist profile changes" ) } if req . Config [ "features.profiles" ] != project . Config [ "features.profiles" ] { if req . Config [ "features.profiles" ] == "true" { err = projectCreateDefaultProfile ( tx , project . Name ) if err != nil { return err } } else { err = tx . ProfileDelete ( project . Name , "default" ) if err != nil { return errors . Wrap ( err , "Delete project default profile" ) } } } return nil } ) if err != nil { return SmartError ( err ) } return EmptySyncResponse }
2297	func projectIsEmpty ( project * api . Project ) bool { if len ( project . UsedBy ) > 0 { if len ( project . UsedBy ) == 1 && strings . Contains ( project . UsedBy [ 0 ] , "/profiles/default" ) { return true } return false } return true }
2298	func ( r * ProtocolLXD ) GetCertificateFingerprints ( ) ( [ ] string , error ) { certificates := [ ] string { } _ , err := r . queryStruct ( "GET" , "/certificates" , nil , "" , & certificates ) if err != nil { return nil , err } fingerprints := [ ] string { } for _ , fingerprint := range certificates { fields := strings . Split ( fingerprint , "/certificates/" ) fingerprints = append ( fingerprints , fields [ len ( fields ) - 1 ] ) } return fingerprints , nil }
2299	func ( r * ProtocolLXD ) GetCertificates ( ) ( [ ] api . Certificate , error ) { certificates := [ ] api . Certificate { } _ , err := r . queryStruct ( "GET" , "/certificates?recursion=1" , nil , "" , & certificates ) if err != nil { return nil , err } return certificates , nil }
2300	func ( r * ProtocolLXD ) GetCertificate ( fingerprint string ) ( * api . Certificate , string , error ) { certificate := api . Certificate { } etag , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/certificates/%s" , url . QueryEscape ( fingerprint ) ) , nil , "" , & certificate ) if err != nil { return nil , "" , err } return & certificate , etag , nil }
2301	func ( r * ProtocolLXD ) CreateCertificate ( certificate api . CertificatesPost ) error { _ , _ , err := r . query ( "POST" , "/certificates" , certificate , "" ) if err != nil { return err } return nil }
2302	func ( r * ProtocolLXD ) UpdateCertificate ( fingerprint string , certificate api . CertificatePut , ETag string ) error { if ! r . HasExtension ( "certificate_update" ) { return fmt . Errorf ( "The server is missing the required \"certificate_update\" API extension" ) } \" \" _ , _ , err := r . query ( "PUT" , fmt . Sprintf ( "/certificates/%s" , url . QueryEscape ( fingerprint ) ) , certificate , ETag ) }
2303	func ( r * ProtocolLXD ) DeleteCertificate ( fingerprint string ) error { _ , _ , err := r . query ( "DELETE" , fmt . Sprintf ( "/certificates/%s" , url . QueryEscape ( fingerprint ) ) , nil , "" ) if err != nil { return err } return nil }
2304	func containerMetadataTemplatesGet ( d * Daemon , r * http . Request ) Response { project := projectParam ( r ) name := mux . Vars ( r ) [ "name" ] response , err := ForwardedResponseIfContainerIsRemote ( d , r , project , name ) if err != nil { return SmartError ( err ) } if response != nil { return response } c , err := containerLoadByProjectAndName ( d . State ( ) , project , name ) if err != nil { return SmartError ( err ) } ourStart , err := c . StorageStart ( ) if err != nil { return SmartError ( err ) } if ourStart { defer c . StorageStop ( ) } templateName := r . FormValue ( "path" ) if templateName == "" { templatesPath := filepath . Join ( c . Path ( ) , "templates" ) filesInfo , err := ioutil . ReadDir ( templatesPath ) if err != nil { return InternalError ( err ) } templates := [ ] string { } for _ , info := range filesInfo { if ! info . IsDir ( ) { templates = append ( templates , info . Name ( ) ) } } return SyncResponse ( true , templates ) } templatePath , err := getContainerTemplatePath ( c , templateName ) if err != nil { return SmartError ( err ) } if ! shared . PathExists ( templatePath ) { return NotFound ( fmt . Errorf ( "Path '%s' not found" , templatePath ) ) } template , err := os . Open ( templatePath ) if err != nil { return SmartError ( err ) } defer template . Close ( ) tempfile , err := ioutil . TempFile ( "" , "lxd_template" ) if err != nil { return SmartError ( err ) } defer tempfile . Close ( ) _ , err = io . Copy ( tempfile , template ) if err != nil { return InternalError ( err ) } files := make ( [ ] fileResponseEntry , 1 ) files [ 0 ] . identifier = templateName files [ 0 ] . path = tempfile . Name ( ) files [ 0 ] . filename = templateName return FileResponse ( r , files , nil , true ) }
2305	func containerMetadataTemplatesPostPut ( d * Daemon , r * http . Request ) Response { project := projectParam ( r ) name := mux . Vars ( r ) [ "name" ] response , err := ForwardedResponseIfContainerIsRemote ( d , r , project , name ) if err != nil { return SmartError ( err ) } if response != nil { return response } c , err := containerLoadByProjectAndName ( d . State ( ) , project , name ) if err != nil { return SmartError ( err ) } ourStart , err := c . StorageStart ( ) if err != nil { return SmartError ( err ) } if ourStart { defer c . StorageStop ( ) } templateName := r . FormValue ( "path" ) if templateName == "" { return BadRequest ( fmt . Errorf ( "missing path argument" ) ) } templatePath , err := getContainerTemplatePath ( c , templateName ) if err != nil { return SmartError ( err ) } if r . Method == "POST" && shared . PathExists ( templatePath ) { return BadRequest ( fmt . Errorf ( "Template already exists" ) ) } template , err := os . OpenFile ( templatePath , os . O_WRONLY | os . O_CREATE | os . O_TRUNC , 0644 ) if err != nil { return SmartError ( err ) } defer template . Close ( ) _ , err = io . Copy ( template , r . Body ) if err != nil { return InternalError ( err ) } return EmptySyncResponse }
2306	func containerMetadataTemplatesDelete ( d * Daemon , r * http . Request ) Response { project := projectParam ( r ) name := mux . Vars ( r ) [ "name" ] response , err := ForwardedResponseIfContainerIsRemote ( d , r , project , name ) if err != nil { return SmartError ( err ) } if response != nil { return response } c , err := containerLoadByProjectAndName ( d . State ( ) , project , name ) if err != nil { return SmartError ( err ) } ourStart , err := c . StorageStart ( ) if err != nil { return SmartError ( err ) } if ourStart { defer c . StorageStop ( ) } templateName := r . FormValue ( "path" ) if templateName == "" { return BadRequest ( fmt . Errorf ( "missing path argument" ) ) } templatePath , err := getContainerTemplatePath ( c , templateName ) if err != nil { return SmartError ( err ) } if ! shared . PathExists ( templatePath ) { return NotFound ( fmt . Errorf ( "Path '%s' not found" , templatePath ) ) } err = os . Remove ( templatePath ) if err != nil { return InternalError ( err ) } return EmptySyncResponse }
2307	func getContainerTemplatePath ( c container , filename string ) ( string , error ) { if strings . Contains ( filename , "/" ) { return "" , fmt . Errorf ( "Invalid template filename" ) } return filepath . Join ( c . Path ( ) , "templates" , filename ) , nil }
2308	func ( e Error ) Error ( ) string { message := fmt . Sprintf ( "cannot set '%s'" , e . Name ) if e . Value != nil { message += fmt . Sprintf ( " to '%v'" , e . Value ) } return message + fmt . Sprintf ( ": %s" , e . Reason ) }
2309	func ( l ErrorList ) Error ( ) string { switch len ( l ) { case 0 : return "no errors" case 1 : return l [ 0 ] . Error ( ) } return fmt . Sprintf ( "%s (and %d more errors)" , l [ 0 ] , len ( l ) - 1 ) }
2310	func ( l * ErrorList ) add ( name string , value interface { } , reason string ) { * l = append ( * l , & Error { name , value , reason } ) }
2311	func UpdateSchema ( ) error { err := cluster . SchemaDotGo ( ) if err != nil { return errors . Wrap ( err , "Update cluster database schema" ) } err = node . SchemaDotGo ( ) if err != nil { return errors . Wrap ( err , "Update node database schema" ) } return nil }
2312	func doProfileUpdateCluster ( d * Daemon , project , name string , old api . ProfilePut ) error { nodeName := "" err := d . cluster . Transaction ( func ( tx * db . ClusterTx ) error { var err error nodeName , err = tx . NodeName ( ) return err } ) if err != nil { return errors . Wrap ( err , "failed to query local node name" ) } containers , err := getProfileContainersInfo ( d . cluster , project , name ) if err != nil { return errors . Wrapf ( err , "failed to query containers associated with profile '%s'" , name ) } failures := map [ string ] error { } for _ , args := range containers { err := doProfileUpdateContainer ( d , name , old , nodeName , args ) if err != nil { failures [ args . Name ] = err } } if len ( failures ) != 0 { msg := "The following containers failed to update (profile change still saved):\n" \n for cname , err := range failures { msg += fmt . Sprintf ( " - %s: %s\n" , \n , cname ) } } err }
2313	func doProfileUpdateContainer ( d * Daemon , name string , old api . ProfilePut , nodeName string , args db . ContainerArgs ) error { if args . Node != "" && args . Node != nodeName { return nil } profiles , err := d . cluster . ProfilesGet ( args . Project , args . Profiles ) if err != nil { return err } for i , profileName := range args . Profiles { if profileName == name { profiles [ i ] . Config = old . Config profiles [ i ] . Devices = old . Devices break } } c := containerLXCInstantiate ( d . State ( ) , args ) c . expandConfig ( profiles ) c . expandDevices ( profiles ) return c . Update ( db . ContainerArgs { Architecture : c . Architecture ( ) , Config : c . LocalConfig ( ) , Description : c . Description ( ) , Devices : c . LocalDevices ( ) , Ephemeral : c . IsEphemeral ( ) , Profiles : c . Profiles ( ) , Project : c . Project ( ) , } , true ) }
2314	func getProfileContainersInfo ( cluster * db . Cluster , project , profile string ) ( [ ] db . ContainerArgs , error ) { names , err := cluster . ProfileContainersGet ( project , profile ) if err != nil { return nil , errors . Wrapf ( err , "failed to query containers with profile '%s'" , profile ) } containers := [ ] db . ContainerArgs { } err = cluster . Transaction ( func ( tx * db . ClusterTx ) error { for ctProject , ctNames := range names { for _ , ctName := range ctNames { container , err := tx . ContainerGet ( ctProject , ctName ) if err != nil { return err } containers = append ( containers , db . ContainerToArgs ( container ) ) } } return nil } ) if err != nil { return nil , errors . Wrapf ( err , "Failed to fetch containers" ) } return containers , nil }
2315	func ( r * ProtocolLXD ) GetNetworkNames ( ) ( [ ] string , error ) { if ! r . HasExtension ( "network" ) { return nil , fmt . Errorf ( "The server is missing the required \"network\" API extension" ) } \" \" urls := [ ] string { } _ , err := r . queryStruct ( "GET" , "/networks" , nil , "" , & urls ) if err != nil { return nil , err } names := [ ] string { } }
2316	func ( r * ProtocolLXD ) GetNetworks ( ) ( [ ] api . Network , error ) { if ! r . HasExtension ( "network" ) { return nil , fmt . Errorf ( "The server is missing the required \"network\" API extension" ) } \" \" networks := [ ] api . Network { } _ , err := r . queryStruct ( "GET" , "/networks?recursion=1" , nil , "" , & networks ) }
2317	func ( r * ProtocolLXD ) GetNetwork ( name string ) ( * api . Network , string , error ) { if ! r . HasExtension ( "network" ) { return nil , "" , fmt . Errorf ( "The server is missing the required \"network\" API extension" ) } \" \" network := api . Network { } etag , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/networks/%s" , url . QueryEscape ( name ) ) , nil , "" , & network ) }
2318	func ( r * ProtocolLXD ) GetNetworkLeases ( name string ) ( [ ] api . NetworkLease , error ) { if ! r . HasExtension ( "network_leases" ) { return nil , fmt . Errorf ( "The server is missing the required \"network_leases\" API extension" ) } \" \" leases := [ ] api . NetworkLease { } _ , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/networks/%s/leases" , url . QueryEscape ( name ) ) , nil , "" , & leases ) }
2319	func ( r * ProtocolLXD ) GetNetworkState ( name string ) ( * api . NetworkState , error ) { if ! r . HasExtension ( "network_state" ) { return nil , fmt . Errorf ( "The server is missing the required \"network_state\" API extension" ) } \" \" state := api . NetworkState { } _ , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/networks/%s/state" , url . QueryEscape ( name ) ) , nil , "" , & state ) }
2320	func ( r * ProtocolLXD ) CreateNetwork ( network api . NetworksPost ) error { if ! r . HasExtension ( "network" ) { return fmt . Errorf ( "The server is missing the required \"network\" API extension" ) } \" \" _ , _ , err := r . query ( "POST" , "/networks" , network , "" ) }
2321	func ( r * ProtocolLXD ) UpdateNetwork ( name string , network api . NetworkPut , ETag string ) error { if ! r . HasExtension ( "network" ) { return fmt . Errorf ( "The server is missing the required \"network\" API extension" ) } \" \" _ , _ , err := r . query ( "PUT" , fmt . Sprintf ( "/networks/%s" , url . QueryEscape ( name ) ) , network , ETag ) }
2322	func ( r * ProtocolLXD ) RenameNetwork ( name string , network api . NetworkPost ) error { if ! r . HasExtension ( "network" ) { return fmt . Errorf ( "The server is missing the required \"network\" API extension" ) } \" \" _ , _ , err := r . query ( "POST" , fmt . Sprintf ( "/networks/%s" , url . QueryEscape ( name ) ) , network , "" ) }
2323	func Open ( name string , store dqlite . ServerStore , options ... dqlite . DriverOption ) ( * sql . DB , error ) { driver , err := dqlite . NewDriver ( store , options ... ) if err != nil { return nil , errors . Wrap ( err , "Failed to create dqlite driver" ) } driverName := dqliteDriverName ( ) sql . Register ( driverName , driver ) if name == "" { name = "db.bin" } db , err := sql . Open ( driverName , name ) if err != nil { return nil , fmt . Errorf ( "cannot open cluster database: %v" , err ) } return db , nil }
2324	func URLEncode ( path string , query map [ string ] string ) ( string , error ) { u , err := url . Parse ( path ) if err != nil { return "" , err } params := url . Values { } for key , value := range query { params . Add ( key , value ) } u . RawQuery = params . Encode ( ) return u . String ( ) , nil }
2325	func IsUnixSocket ( path string ) bool { stat , err := os . Stat ( path ) if err != nil { return false } return ( stat . Mode ( ) & os . ModeSocket ) == os . ModeSocket }
2326	func HostPath ( path string ) string { if len ( path ) == 0 { return path } if path == "-" { return path } snap := os . Getenv ( "SNAP" ) snapName := os . Getenv ( "SNAP_NAME" ) if snap == "" || snapName != "lxd" { return path } if path [ 0 ] != os . PathSeparator { ppid := os . Getppid ( ) if ppid < 1 { return path } pwd , err := os . Readlink ( fmt . Sprintf ( "/proc/%d/cwd" , ppid ) ) if err != nil { return path } path = filepath . Clean ( strings . Join ( [ ] string { pwd , path } , string ( os . PathSeparator ) ) ) } for _ , prefix := range [ ] string { "/dev" , "/snap" , "/var/snap" , "/var/lib/snapd" } { if path == prefix || strings . HasPrefix ( path , fmt . Sprintf ( "%s/" , prefix ) ) { return path } } return fmt . Sprintf ( "/var/lib/snapd/hostfs%s" , path ) }
2327	func FileMove ( oldPath string , newPath string ) error { err := os . Rename ( oldPath , newPath ) if err == nil { return nil } err = FileCopy ( oldPath , newPath ) if err != nil { return err } os . Remove ( oldPath ) return nil }
2328	func DirCopy ( source string , dest string ) error { info , err := os . Stat ( source ) if err != nil { return errors . Wrapf ( err , "failed to get source directory info" ) } if ! info . IsDir ( ) { return fmt . Errorf ( "source is not a directory" ) } if PathExists ( dest ) { err := os . RemoveAll ( dest ) if err != nil { return errors . Wrapf ( err , "failed to remove destination directory %s" , dest ) } } err = os . MkdirAll ( dest , info . Mode ( ) ) if err != nil { return errors . Wrapf ( err , "failed to create destination directory %s" , dest ) } entries , err := ioutil . ReadDir ( source ) if err != nil { return errors . Wrapf ( err , "failed to read source directory %s" , source ) } for _ , entry := range entries { sourcePath := filepath . Join ( source , entry . Name ( ) ) destPath := filepath . Join ( dest , entry . Name ( ) ) if entry . IsDir ( ) { err := DirCopy ( sourcePath , destPath ) if err != nil { return errors . Wrapf ( err , "failed to copy sub-directory from %s to %s" , sourcePath , destPath ) } } else { err := FileCopy ( sourcePath , destPath ) if err != nil { return errors . Wrapf ( err , "failed to copy file from %s to %s" , sourcePath , destPath ) } } } return nil }
2329	func StringMapHasStringKey ( m map [ string ] string , keys ... string ) bool { for _ , k := range keys { if _ , ok := m [ k ] ; ok { return true } } return false }
2330	func TextEditor ( inPath string , inContent [ ] byte ) ( [ ] byte , error ) { var f * os . File var err error var path string editor := os . Getenv ( "VISUAL" ) if editor == "" { editor = os . Getenv ( "EDITOR" ) if editor == "" { for _ , p := range [ ] string { "editor" , "vi" , "emacs" , "nano" } { _ , err := exec . LookPath ( p ) if err == nil { editor = p break } } if editor == "" { return [ ] byte { } , fmt . Errorf ( "No text editor found, please set the EDITOR environment variable" ) } } } if inPath == "" { f , err = ioutil . TempFile ( "" , "lxd_editor_" ) if err != nil { return [ ] byte { } , err } err = os . Chmod ( f . Name ( ) , 0600 ) if err != nil { f . Close ( ) os . Remove ( f . Name ( ) ) return [ ] byte { } , err } f . Write ( inContent ) f . Close ( ) path = fmt . Sprintf ( "%s.yaml" , f . Name ( ) ) os . Rename ( f . Name ( ) , path ) defer os . Remove ( path ) } else { path = inPath } cmdParts := strings . Fields ( editor ) cmd := exec . Command ( cmdParts [ 0 ] , append ( cmdParts [ 1 : ] , path ) ... ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr err = cmd . Run ( ) if err != nil { return [ ] byte { } , err } content , err := ioutil . ReadFile ( path ) if err != nil { return [ ] byte { } , err } return content , nil }
2331	func WriteTempFile ( dir string , prefix string , content string ) ( string , error ) { f , err := ioutil . TempFile ( dir , prefix ) if err != nil { return "" , err } defer f . Close ( ) _ , err = f . WriteString ( content ) return f . Name ( ) , err }
2332	func RenderTemplate ( template string , ctx pongo2 . Context ) ( string , error ) { tpl , err := pongo2 . FromString ( "{% autoescape off %}" + template + "{% endautoescape %}" ) if err != nil { return "" , err } ret , err := tpl . Execute ( ctx ) if err != nil { return ret , err } if strings . Contains ( ret , "{{" ) || strings . Contains ( ret , "{%" ) { return RenderTemplate ( ret , ctx ) } return ret , err }
2333	func Every ( interval time . Duration , options ... EveryOption ) Schedule { every := & every { } for _ , option := range options { option ( every ) } first := true return func ( ) ( time . Duration , error ) { var err error if first && every . skipFirst { err = ErrSkip } first = false return interval , err } }
2334	func ( s * storageLvm ) StoragePoolMount ( ) ( bool , error ) { source := s . pool . Config [ "source" ] if source == "" { return false , fmt . Errorf ( "no \"source\" property found for the storage pool" ) } \" \" if ! filepath . IsAbs ( source ) { return true , nil } poolMountLockID := getPoolMountLockID ( s . pool . Name ) lxdStorageMapLock . Lock ( ) if waitChannel , ok := lxdStorageOngoingOperationMap [ poolMountLockID ] ; ok { lxdStorageMapLock . Unlock ( ) if _ , ok := <- waitChannel ; ok { logger . Warnf ( "Received value over semaphore, this should not have happened" ) } return false , nil } lxdStorageOngoingOperationMap [ poolMountLockID ] = make ( chan bool ) lxdStorageMapLock . Unlock ( ) removeLockFromMap := func ( ) { lxdStorageMapLock . Lock ( ) if waitChannel , ok := lxdStorageOngoingOperationMap [ poolMountLockID ] ; ok { close ( waitChannel ) delete ( lxdStorageOngoingOperationMap , poolMountLockID ) } lxdStorageMapLock . Unlock ( ) } defer removeLockFromMap ( ) }
2335	func Dump ( tx * sql . Tx , schema string , schemaOnly bool ) ( string , error ) { schemas := dumpParseSchema ( schema ) dump := `PRAGMA foreign_keys=OFF;BEGIN TRANSACTION;` tableDump , err := dumpTable ( tx , "schema" , dumpSchemaTable ) if err != nil { return "" , errors . Wrapf ( err , "failed to dump table schema" ) } dump += tableDump tables := make ( [ ] string , 0 ) for table := range schemas { tables = append ( tables , table ) } sort . Strings ( tables ) for _ , table := range tables { if schemaOnly { dump += schemas [ table ] + "\n" \n } continue tableDump , err := dumpTable ( tx , table , schemas [ table ] ) if err != nil { return "" , errors . Wrapf ( err , "failed to dump table %s" , table ) } } dump += tableDump if ! schemaOnly { tableDump , err = dumpTable ( tx , "sqlite_sequence" , "DELETE FROM sqlite_sequence;" ) if err != nil { return "" , errors . Wrapf ( err , "failed to dump table sqlite_sequence" ) } dump += tableDump } dump += "COMMIT;\n" }
2336	func dumpTable ( tx * sql . Tx , table , schema string ) ( string , error ) { statements := [ ] string { schema } rows , err := tx . Query ( fmt . Sprintf ( "SELECT * FROM %s ORDER BY rowid" , table ) ) if err != nil { return "" , errors . Wrap ( err , "failed to fetch rows" ) } defer rows . Close ( ) columns , err := rows . Columns ( ) if err != nil { return "" , errors . Wrap ( err , "failed to get columns" ) } for i := 0 ; rows . Next ( ) ; i ++ { raw := make ( [ ] interface { } , len ( columns ) ) row := make ( [ ] interface { } , len ( columns ) ) for i := range raw { row [ i ] = & raw [ i ] } err := rows . Scan ( row ... ) if err != nil { return "" , errors . Wrapf ( err , "failed to scan row %d" , i ) } values := make ( [ ] string , len ( columns ) ) for j , v := range raw { switch v := v . ( type ) { case int64 : values [ j ] = strconv . FormatInt ( v , 10 ) case string : values [ j ] = fmt . Sprintf ( "'%s'" , v ) case [ ] byte : values [ j ] = fmt . Sprintf ( "'%s'" , string ( v ) ) case time . Time : values [ j ] = strconv . FormatInt ( v . Unix ( ) , 10 ) default : if v != nil { return "" , fmt . Errorf ( "bad type in column %s of row %d" , columns [ j ] , i ) } values [ j ] = "NULL" } } statement := fmt . Sprintf ( "INSERT INTO %s VALUES(%s);" , table , strings . Join ( values , "," ) ) statements = append ( statements , statement ) } return strings . Join ( statements , "\n" ) + \n , nil }
2337	func ( c * ClusterTx ) ProjectHasProfiles ( name string ) ( bool , error ) { return projectHasProfiles ( c . tx , name ) }
2338	func ( c * ClusterTx ) ProjectNames ( ) ( [ ] string , error ) { stmt := "SELECT name FROM projects" names , err := query . SelectStrings ( c . tx , stmt ) if err != nil { return nil , errors . Wrap ( err , "Fetch project names" ) } return names , nil }
2339	func ( c * ClusterTx ) ProjectMap ( ) ( map [ int64 ] string , error ) { stmt := "SELECT id, name FROM projects" rows , err := c . tx . Query ( stmt ) if err != nil { return nil , err } defer rows . Close ( ) result := map [ int64 ] string { } for i := 0 ; rows . Next ( ) ; i ++ { var id int64 var name string err := rows . Scan ( & id , & name ) if err != nil { return nil , err } result [ id ] = name } err = rows . Err ( ) if err != nil { return nil , err } return result , nil }
2340	func ( c * ClusterTx ) ProjectHasImages ( name string ) ( bool , error ) { project , err := c . ProjectGet ( name ) if err != nil { return false , errors . Wrap ( err , "fetch project" ) } enabled := project . Config [ "features.images" ] == "true" return enabled , nil }
2341	func ( c * ClusterTx ) ProjectUpdate ( name string , object api . ProjectPut ) error { stmt := c . stmt ( projectUpdate ) result , err := stmt . Exec ( object . Description , name ) if err != nil { return errors . Wrap ( err , "Update project" ) } n , err := result . RowsAffected ( ) if err != nil { return errors . Wrap ( err , "Fetch affected rows" ) } if n != 1 { return fmt . Errorf ( "Query updated %d rows instead of 1" , n ) } id , err := c . ProjectID ( name ) if err != nil { return errors . Wrap ( err , "Fetch project ID" ) } _ , err = c . tx . Exec ( `DELETE FROM projects_config WHERE projects_config.project_id = ?` , id ) if err != nil { return errors . Wrap ( err , "Delete project config" ) } stmt = c . stmt ( projectCreateConfigRef ) for key , value := range object . Config { _ , err := stmt . Exec ( id , key , value ) if err != nil { return errors . Wrap ( err , "Insert config for project" ) } } return nil }
2342	func ( r * ProtocolLXD ) GetCluster ( ) ( * api . Cluster , string , error ) { if ! r . HasExtension ( "clustering" ) { return nil , "" , fmt . Errorf ( "The server is missing the required \"clustering\" API extension" ) } \" \" cluster := & api . Cluster { } etag , err := r . queryStruct ( "GET" , "/cluster" , nil , "" , & cluster ) }
2343	func ( r * ProtocolLXD ) UpdateCluster ( cluster api . ClusterPut , ETag string ) ( Operation , error ) { if ! r . HasExtension ( "clustering" ) { return nil , fmt . Errorf ( "The server is missing the required \"clustering\" API extension" ) } \" \" if cluster . ServerAddress != "" || cluster . ClusterPassword != "" || len ( cluster . MemberConfig ) > 0 { if ! r . HasExtension ( "clustering_join" ) { return nil , fmt . Errorf ( "The server is missing the required \"clustering_join\" API extension" ) } } \" }
2344	func ( r * ProtocolLXD ) GetClusterMemberNames ( ) ( [ ] string , error ) { if ! r . HasExtension ( "clustering" ) { return nil , fmt . Errorf ( "The server is missing the required \"clustering\" API extension" ) } \" \" urls := [ ] string { } _ , err := r . queryStruct ( "GET" , "/cluster/members" , nil , "" , & urls ) }
2345	func ( r * ProtocolLXD ) GetClusterMembers ( ) ( [ ] api . ClusterMember , error ) { if ! r . HasExtension ( "clustering" ) { return nil , fmt . Errorf ( "The server is missing the required \"clustering\" API extension" ) } \" \" members := [ ] api . ClusterMember { } _ , err := r . queryStruct ( "GET" , "/cluster/members?recursion=1" , nil , "" , & members ) }
2346	func ( r * ProtocolLXD ) GetClusterMember ( name string ) ( * api . ClusterMember , string , error ) { if ! r . HasExtension ( "clustering" ) { return nil , "" , fmt . Errorf ( "The server is missing the required \"clustering\" API extension" ) } \" \" member := api . ClusterMember { } etag , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/cluster/members/%s" , name ) , nil , "" , & member ) }
2347	func ( r * ProtocolLXD ) RenameClusterMember ( name string , member api . ClusterMemberPost ) error { if ! r . HasExtension ( "clustering" ) { return fmt . Errorf ( "The server is missing the required \"clustering\" API extension" ) } \" \" _ , _ , err := r . query ( "POST" , fmt . Sprintf ( "/cluster/members/%s" , name ) , member , "" ) }
2348	func ( e * EventListener ) Disconnect ( ) { if e . disconnected { return } e . r . eventListenersLock . Lock ( ) defer e . r . eventListenersLock . Unlock ( ) for i , listener := range e . r . eventListeners { if listener == e { copy ( e . r . eventListeners [ i : ] , e . r . eventListeners [ i + 1 : ] ) e . r . eventListeners [ len ( e . r . eventListeners ) - 1 ] = nil e . r . eventListeners = e . r . eventListeners [ : len ( e . r . eventListeners ) - 1 ] break } } e . err = nil e . disconnected = true close ( e . chActive ) }
2349	func CompareVersions ( version1 , version2 [ 2 ] int ) ( int , error ) { schema1 , extensions1 := version1 [ 0 ] , version1 [ 1 ] schema2 , extensions2 := version2 [ 0 ] , version2 [ 1 ] if schema1 == schema2 && extensions1 == extensions2 { return 0 , nil } if schema1 >= schema2 && extensions1 >= extensions2 { return 1 , nil } if schema1 <= schema2 && extensions1 <= extensions2 { return 2 , nil } return - 1 , fmt . Errorf ( "nodes have inconsistent versions" ) }
2350	func ( c * Config ) HasClientCertificate ( ) bool { certf := c . ConfigPath ( "client.crt" ) keyf := c . ConfigPath ( "client.key" ) if ! shared . PathExists ( certf ) || ! shared . PathExists ( keyf ) { return false } return true }
2351	func ( c * Config ) GenerateClientCertificate ( ) error { if c . HasClientCertificate ( ) { return nil } certf := c . ConfigPath ( "client.crt" ) keyf := c . ConfigPath ( "client.key" ) return shared . FindOrGenCert ( certf , keyf , true ) }
2352	func LoadModule ( module string ) error { if shared . PathExists ( fmt . Sprintf ( "/sys/module/%s" , module ) ) { return nil } _ , err := shared . RunCommand ( "modprobe" , module ) return err }
2353	func Parse ( name string ) ( * ast . Package , error ) { base := os . Getenv ( "GOPATH" ) if base == "" { base = "~/go" } dir := filepath . Join ( base , "src" , name ) fset := token . NewFileSet ( ) paths , err := filepath . Glob ( filepath . Join ( dir , "*.go" ) ) if err != nil { return nil , errors . Wrap ( err , "Search source file" ) } files := map [ string ] * ast . File { } for _ , path := range paths { if strings . Contains ( path , "_test.go" ) { continue } file , err := parser . ParseFile ( fset , path , nil , parser . ParseComments ) if err != nil { return nil , fmt . Errorf ( "Parse Go source file %q" , path ) } files [ path ] = file } pkg , _ := ast . NewPackage ( fset , files , nil , nil ) return pkg , nil }
2354	func ( e * Endpoints ) PprofAddress ( ) string { e . mu . RLock ( ) defer e . mu . RUnlock ( ) listener := e . listeners [ pprof ] if listener == nil { return "" } return listener . Addr ( ) . String ( ) }
2355	func ( e * Endpoints ) PprofUpdateAddress ( address string ) error { if address != "" { address = util . CanonicalNetworkAddress ( address ) } oldAddress := e . NetworkAddress ( ) if address == oldAddress { return nil } logger . Infof ( "Update pprof address" ) e . mu . Lock ( ) defer e . mu . Unlock ( ) e . closeListener ( pprof ) if address == "" { return nil } getListener := func ( address string ) ( * net . Listener , error ) { var err error var listener net . Listener for i := 0 ; i < 10 ; i ++ { listener , err = net . Listen ( "tcp" , address ) if err == nil { break } time . Sleep ( 100 * time . Millisecond ) } if err != nil { return nil , fmt . Errorf ( "Cannot listen on http socket: %v" , err ) } return & listener , nil } if address != "" { listener , err := getListener ( address ) if err != nil { listener , err1 := getListener ( oldAddress ) if err1 == nil { e . listeners [ pprof ] = * listener e . serveHTTP ( pprof ) } return err } e . listeners [ pprof ] = * listener e . serveHTTP ( pprof ) } return nil }
2356	func NewMethod ( database , pkg , entity , kind string , config map [ string ] string ) ( * Method , error ) { packages , err := Packages ( ) if err != nil { return nil , err } method := & Method { db : database , pkg : pkg , entity : entity , kind : kind , config : config , packages : packages , } return method , nil }
2357	func ( m * Method ) Generate ( buf * file . Buffer ) error { if strings . HasSuffix ( m . kind , "Ref" ) { return m . ref ( buf ) } switch m . kind { case "URIs" : return m . uris ( buf ) case "List" : return m . list ( buf ) case "Get" : return m . get ( buf ) case "ID" : return m . id ( buf ) case "Exists" : return m . exists ( buf ) case "Create" : return m . create ( buf ) case "Rename" : return m . rename ( buf ) case "Update" : return m . update ( buf ) case "Delete" : return m . delete ( buf ) default : return fmt . Errorf ( "Unknown method kind '%s'" , m . kind ) } }
2358	func ( m * Method ) fillSliceReferenceField ( buf * file . Buffer , nk [ ] * Field , field * Field ) error { objectsVar := fmt . Sprintf ( "%sObjects" , lex . Minuscule ( field . Name ) ) methodName := fmt . Sprintf ( "%s%sRef" , lex . Capital ( m . entity ) , field . Name ) buf . L ( "// Fill field %s." , field . Name ) buf . L ( "%s, err := c.%s(filter)" , objectsVar , methodName ) buf . L ( "if err != nil {" ) buf . L ( " return nil, errors.Wrap(err, \"Failed to fetch field %s\")" , \" ) \" field . Name buf . L ( "}" ) buf . N ( ) buf . L ( "for i := range objects {" ) needle := "" for i , key := range nk [ : len ( nk ) - 1 ] { needle += fmt . Sprintf ( "[objects[i].%s]" , key . Name ) subIndexTyp := indexType ( nk [ i + 1 : ] , field . Type . Name ) buf . L ( " _, ok := %s%s" , objectsVar , needle ) buf . L ( " if !ok {" ) buf . L ( " subIndex := %s{}" , subIndexTyp ) buf . L ( " %s%s = subIndex" , objectsVar , needle ) buf . L ( " }" ) buf . N ( ) } needle += fmt . Sprintf ( "[objects[i].%s]" , nk [ len ( nk ) - 1 ] . Name ) buf . L ( " value := %s%s" , objectsVar , needle ) buf . L ( " if value == nil {" ) buf . L ( " value = %s{}" , field . Type . Name ) buf . L ( " }" ) buf . L ( " objects[i].%s = value" , field . Name ) buf . L ( "}" ) }
2359	func ( c * ClusterTx ) StoragePoolID ( name string ) ( int64 , error ) { stmt := "SELECT id FROM storage_pools WHERE name=?" ids , err := query . SelectIntegers ( c . tx , stmt , name ) if err != nil { return - 1 , err } switch len ( ids ) { case 0 : return - 1 , ErrNoSuchObject case 1 : return int64 ( ids [ 0 ] ) , nil default : return - 1 , fmt . Errorf ( "more than one pool has the given name" ) } }
2360	func ( c * ClusterTx ) StoragePoolIDsNotPending ( ) ( map [ string ] int64 , error ) { pools := [ ] struct { id int64 name string } { } dest := func ( i int ) [ ] interface { } { pools = append ( pools , struct { id int64 name string } { } ) return [ ] interface { } { & pools [ i ] . id , & pools [ i ] . name } } stmt , err := c . tx . Prepare ( "SELECT id, name FROM storage_pools WHERE NOT state=?" ) if err != nil { return nil , err } defer stmt . Close ( ) err = query . SelectObjects ( stmt , dest , storagePoolPending ) if err != nil { return nil , err } ids := map [ string ] int64 { } for _ , pool := range pools { ids [ pool . name ] = pool . id } return ids , nil }
2361	func ( c * ClusterTx ) StoragePoolNodeJoin ( poolID , nodeID int64 ) error { columns := [ ] string { "storage_pool_id" , "node_id" } values := [ ] interface { } { poolID , nodeID } _ , err := query . UpsertObject ( c . tx , "storage_pools_nodes" , columns , values ) if err != nil { return errors . Wrap ( err , "failed to add storage pools node entry" ) } return nil }
2362	func ( c * ClusterTx ) StoragePoolNodeJoinCeph ( poolID , nodeID int64 ) error { stmt := "SELECT node_id FROM storage_pools_nodes WHERE storage_pool_id=?" nodeIDs , err := query . SelectIntegers ( c . tx , stmt , poolID ) if err != nil { return errors . Wrap ( err , "failed to fetch IDs of nodes with ceph pool" ) } if len ( nodeIDs ) == 0 { return fmt . Errorf ( "ceph pool is not linked to any node" ) } otherNodeID := nodeIDs [ 0 ] _ , err = c . tx . Exec ( `INSERT INTO storage_volumes(name, storage_pool_id, node_id, type, description, project_id) SELECT name, storage_pool_id, ?, type, description, 1 FROM storage_volumes WHERE storage_pool_id=? AND node_id=?` , nodeID , poolID , otherNodeID ) if err != nil { return errors . Wrap ( err , "failed to create node ceph volumes" ) } stmt = `SELECT id FROM storage_volumes WHERE storage_pool_id=? AND node_id=? ORDER BY name, type` volumeIDs , err := query . SelectIntegers ( c . tx , stmt , poolID , nodeID ) if err != nil { return errors . Wrap ( err , "failed to get joining node's ceph volume IDs" ) } otherVolumeIDs , err := query . SelectIntegers ( c . tx , stmt , poolID , otherNodeID ) if err != nil { return errors . Wrap ( err , "failed to get other node's ceph volume IDs" ) } if len ( volumeIDs ) != len ( otherVolumeIDs ) { return fmt . Errorf ( "not all ceph volumes were copied" ) } for i , otherVolumeID := range otherVolumeIDs { config , err := query . SelectConfig ( c . tx , "storage_volumes_config" , "storage_volume_id=?" , otherVolumeID ) if err != nil { return errors . Wrap ( err , "failed to get storage volume config" ) } for key , value := range config { _ , err := c . tx . Exec ( `INSERT INTO storage_volumes_config(storage_volume_id, key, value) VALUES(?, ?, ?)` , volumeIDs [ i ] , key , value ) if err != nil { return errors . Wrap ( err , "failed to copy volume config" ) } } } return nil }
2363	func ( c * ClusterTx ) StoragePoolConfigAdd ( poolID , nodeID int64 , config map [ string ] string ) error { return storagePoolConfigAdd ( c . tx , poolID , nodeID , config ) }
2364	func ( c * ClusterTx ) StoragePoolCreatePending ( node , name , driver string , conf map [ string ] string ) error { pool := struct { id int64 driver string state int } { } var errConsistency error dest := func ( i int ) [ ] interface { } { if i != 0 { errConsistency = fmt . Errorf ( "more than one pool exists with the given name" ) } return [ ] interface { } { & pool . id , & pool . driver , & pool . state } } stmt , err := c . tx . Prepare ( "SELECT id, driver, state FROM storage_pools WHERE name=?" ) if err != nil { return err } defer stmt . Close ( ) err = query . SelectObjects ( stmt , dest , name ) if err != nil { return err } if errConsistency != nil { return errConsistency } var poolID = pool . id if poolID == 0 { columns := [ ] string { "name" , "driver" } values := [ ] interface { } { name , driver } poolID , err = query . UpsertObject ( c . tx , "storage_pools" , columns , values ) if err != nil { return err } } else { if pool . driver != driver { return fmt . Errorf ( "pool already exists with a different driver" ) } if pool . state != storagePoolPending { return fmt . Errorf ( "pool is not in pending state" ) } } nodeInfo , err := c . NodeByName ( node ) if err != nil { return err } count , err := query . Count ( c . tx , "storage_pools_nodes" , "storage_pool_id=? AND node_id=?" , poolID , nodeInfo . ID ) if err != nil { return err } if count != 0 { return ErrAlreadyDefined } columns := [ ] string { "storage_pool_id" , "node_id" } values := [ ] interface { } { poolID , nodeInfo . ID } _ , err = query . UpsertObject ( c . tx , "storage_pools_nodes" , columns , values ) if err != nil { return err } err = c . StoragePoolConfigAdd ( poolID , nodeInfo . ID , conf ) if err != nil { return err } return nil }
2365	func ( c * ClusterTx ) StoragePoolCreated ( name string ) error { return c . storagePoolState ( name , storagePoolCreated ) }
2366	func ( c * ClusterTx ) StoragePoolErrored ( name string ) error { return c . storagePoolState ( name , storagePoolErrored ) }
2367	func ( c * ClusterTx ) StoragePoolNodeConfigs ( poolID int64 ) ( map [ string ] map [ string ] string , error ) { nodes , err := c . Nodes ( ) if err != nil { return nil , err } stmt := `SELECT nodes.name FROM nodes LEFT JOIN storage_pools_nodes ON storage_pools_nodes.node_id = nodes.id LEFT JOIN storage_pools ON storage_pools_nodes.storage_pool_id = storage_pools.idWHERE storage_pools.id = ? AND storage_pools.state = ?` defined , err := query . SelectStrings ( c . tx , stmt , poolID , storagePoolPending ) if err != nil { return nil , err } missing := [ ] string { } for _ , node := range nodes { if ! shared . StringInSlice ( node . Name , defined ) { missing = append ( missing , node . Name ) } } if len ( missing ) > 0 { return nil , fmt . Errorf ( "Pool not defined on nodes: %s" , strings . Join ( missing , ", " ) ) } configs := map [ string ] map [ string ] string { } for _ , node := range nodes { config , err := query . SelectConfig ( c . tx , "storage_pools_config" , "storage_pool_id=? AND node_id=?" , poolID , node . ID ) if err != nil { return nil , err } configs [ node . Name ] = config } return configs , nil }
2368	func ( c * Cluster ) StoragePoolsGetDrivers ( ) ( [ ] string , error ) { var poolDriver string query := "SELECT DISTINCT driver FROM storage_pools" inargs := [ ] interface { } { } outargs := [ ] interface { } { poolDriver } result , err := queryScan ( c . db , query , inargs , outargs ) if err != nil { return [ ] string { } , err } if len ( result ) == 0 { return [ ] string { } , ErrNoSuchObject } drivers := [ ] string { } for _ , driver := range result { drivers = append ( drivers , driver [ 0 ] . ( string ) ) } return drivers , nil }
2369	func ( c * Cluster ) StoragePoolGetID ( poolName string ) ( int64 , error ) { poolID := int64 ( - 1 ) query := "SELECT id FROM storage_pools WHERE name=?" inargs := [ ] interface { } { poolName } outargs := [ ] interface { } { & poolID } err := dbQueryRowScan ( c . db , query , inargs , outargs ) if err != nil { if err == sql . ErrNoRows { return - 1 , ErrNoSuchObject } } return poolID , nil }
2370	func ( c * Cluster ) StoragePoolGet ( poolName string ) ( int64 , * api . StoragePool , error ) { var poolDriver string poolID := int64 ( - 1 ) description := sql . NullString { } var state int query := "SELECT id, driver, description, state FROM storage_pools WHERE name=?" inargs := [ ] interface { } { poolName } outargs := [ ] interface { } { & poolID , & poolDriver , & description , & state } err := dbQueryRowScan ( c . db , query , inargs , outargs ) if err != nil { if err == sql . ErrNoRows { return - 1 , nil , ErrNoSuchObject } return - 1 , nil , err } config , err := c . StoragePoolConfigGet ( poolID ) if err != nil { return - 1 , nil , err } storagePool := api . StoragePool { Name : poolName , Driver : poolDriver , } storagePool . Description = description . String storagePool . Config = config switch state { case storagePoolPending : storagePool . Status = "Pending" case storagePoolCreated : storagePool . Status = "Created" default : storagePool . Status = "Unknown" } nodes , err := c . storagePoolNodes ( poolID ) if err != nil { return - 1 , nil , err } storagePool . Locations = nodes return poolID , & storagePool , nil }
2371	func ( c * Cluster ) storagePoolNodes ( poolID int64 ) ( [ ] string , error ) { stmt := `SELECT nodes.name FROM nodes JOIN storage_pools_nodes ON storage_pools_nodes.node_id = nodes.id WHERE storage_pools_nodes.storage_pool_id = ?` var nodes [ ] string err := c . Transaction ( func ( tx * ClusterTx ) error { var err error nodes , err = query . SelectStrings ( tx . tx , stmt , poolID ) return err } ) if err != nil { return nil , err } return nodes , nil }
2372	func ( c * Cluster ) StoragePoolConfigGet ( poolID int64 ) ( map [ string ] string , error ) { var key , value string query := "SELECT key, value FROM storage_pools_config WHERE storage_pool_id=? AND (node_id=? OR node_id IS NULL)" inargs := [ ] interface { } { poolID , c . nodeID } outargs := [ ] interface { } { key , value } results , err := queryScan ( c . db , query , inargs , outargs ) if err != nil { return nil , err } config := map [ string ] string { } for _ , r := range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) config [ key ] = value } return config , nil }
2373	func ( c * Cluster ) StoragePoolCreate ( poolName string , poolDescription string , poolDriver string , poolConfig map [ string ] string ) ( int64 , error ) { var id int64 err := c . Transaction ( func ( tx * ClusterTx ) error { result , err := tx . tx . Exec ( "INSERT INTO storage_pools (name, description, driver, state) VALUES (?, ?, ?, ?)" , poolName , poolDescription , poolDriver , storagePoolCreated ) if err != nil { return err } id , err = result . LastInsertId ( ) if err != nil { return err } columns := [ ] string { "storage_pool_id" , "node_id" } values := [ ] interface { } { id , c . nodeID } _ , err = query . UpsertObject ( tx . tx , "storage_pools_nodes" , columns , values ) if err != nil { return err } err = storagePoolConfigAdd ( tx . tx , id , c . nodeID , poolConfig ) if err != nil { return err } return nil } ) if err != nil { id = - 1 } return id , nil }
2374	func storagePoolConfigAdd ( tx * sql . Tx , poolID , nodeID int64 , poolConfig map [ string ] string ) error { str := "INSERT INTO storage_pools_config (storage_pool_id, node_id, key, value) VALUES(?, ?, ?, ?)" stmt , err := tx . Prepare ( str ) defer stmt . Close ( ) if err != nil { return err } for k , v := range poolConfig { if v == "" { continue } var nodeIDValue interface { } if ! shared . StringInSlice ( k , StoragePoolNodeConfigKeys ) { nodeIDValue = nil } else { nodeIDValue = nodeID } _ , err = stmt . Exec ( poolID , nodeIDValue , k , v ) if err != nil { return err } } return nil }
2375	func ( c * Cluster ) StoragePoolUpdate ( poolName , description string , poolConfig map [ string ] string ) error { poolID , _ , err := c . StoragePoolGet ( poolName ) if err != nil { return err } err = c . Transaction ( func ( tx * ClusterTx ) error { err = StoragePoolUpdateDescription ( tx . tx , poolID , description ) if err != nil { return err } err = StoragePoolConfigClear ( tx . tx , poolID , c . nodeID ) if err != nil { return err } err = storagePoolConfigAdd ( tx . tx , poolID , c . nodeID , poolConfig ) if err != nil { return err } return nil } ) return err }
2376	func StoragePoolConfigClear ( tx * sql . Tx , poolID , nodeID int64 ) error { _ , err := tx . Exec ( "DELETE FROM storage_pools_config WHERE storage_pool_id=? AND (node_id=? OR node_id IS NULL)" , poolID , nodeID ) if err != nil { return err } return nil }
2377	func ( c * Cluster ) StoragePoolDelete ( poolName string ) ( * api . StoragePool , error ) { poolID , pool , err := c . StoragePoolGet ( poolName ) if err != nil { return nil , err } err = exec ( c . db , "DELETE FROM storage_pools WHERE id=?" , poolID ) if err != nil { return nil , err } return pool , nil }
2378	func ( c * Cluster ) StoragePoolVolumesGetNames ( poolID int64 ) ( [ ] string , error ) { var volumeName string query := "SELECT name FROM storage_volumes WHERE storage_pool_id=? AND node_id=?" inargs := [ ] interface { } { poolID , c . nodeID } outargs := [ ] interface { } { volumeName } result , err := queryScan ( c . db , query , inargs , outargs ) if err != nil { return [ ] string { } , err } var out [ ] string for _ , r := range result { out = append ( out , r [ 0 ] . ( string ) ) } return out , nil }
2379	func ( c * Cluster ) StoragePoolVolumesGet ( project string , poolID int64 , volumeTypes [ ] int ) ( [ ] * api . StorageVolume , error ) { var nodeIDs [ ] int err := c . Transaction ( func ( tx * ClusterTx ) error { var err error nodeIDs , err = query . SelectIntegers ( tx . tx , `SELECT DISTINCT node_id FROM storage_volumes JOIN projects ON projects.id = storage_volumes.project_id WHERE (projects.name=? OR storage_volumes.type=?) AND storage_pool_id=?` , project , StoragePoolVolumeTypeCustom , poolID ) return err } ) if err != nil { return nil , err } volumes := [ ] * api . StorageVolume { } for _ , nodeID := range nodeIDs { nodeVolumes , err := c . storagePoolVolumesGet ( project , poolID , int64 ( nodeID ) , volumeTypes ) if err != nil { return nil , err } volumes = append ( volumes , nodeVolumes ... ) } return volumes , nil }
2380	func ( c * Cluster ) StoragePoolNodeVolumesGet ( poolID int64 , volumeTypes [ ] int ) ( [ ] * api . StorageVolume , error ) { return c . storagePoolVolumesGet ( "default" , poolID , c . nodeID , volumeTypes ) }
2381	func ( c * Cluster ) storagePoolVolumesGet ( project string , poolID , nodeID int64 , volumeTypes [ ] int ) ( [ ] * api . StorageVolume , error ) { result := [ ] * api . StorageVolume { } for _ , volumeType := range volumeTypes { volumeNames , err := c . StoragePoolVolumesGetType ( project , volumeType , poolID , nodeID ) if err != nil && err != sql . ErrNoRows { return nil , errors . Wrap ( err , "failed to fetch volume types" ) } for _ , volumeName := range volumeNames { _ , volume , err := c . StoragePoolVolumeGetType ( project , volumeName , volumeType , poolID , nodeID ) if err != nil { return nil , errors . Wrap ( err , "failed to fetch volume type" ) } result = append ( result , volume ) } } if len ( result ) == 0 { return result , ErrNoSuchObject } return result , nil }
2382	func ( c * Cluster ) StoragePoolVolumesGetType ( project string , volumeType int , poolID , nodeID int64 ) ( [ ] string , error ) { var poolName string query := `SELECT storage_volumes.name FROM storage_volumes JOIN projects ON projects.id=storage_volumes.project_id WHERE (projects.name=? OR storage_volumes.type=?) AND storage_pool_id=? AND node_id=? AND type=?` inargs := [ ] interface { } { project , StoragePoolVolumeTypeCustom , poolID , nodeID , volumeType } outargs := [ ] interface { } { poolName } result , err := queryScan ( c . db , query , inargs , outargs ) if err != nil { return [ ] string { } , err } response := [ ] string { } for _ , r := range result { response = append ( response , r [ 0 ] . ( string ) ) } return response , nil }
2383	func ( c * Cluster ) StoragePoolVolumeSnapshotsGetType ( volumeName string , volumeType int , poolID int64 ) ( [ ] string , error ) { result := [ ] string { } regexp := volumeName + shared . SnapshotDelimiter length := len ( regexp ) query := "SELECT name FROM storage_volumes WHERE storage_pool_id=? AND node_id=? AND type=? AND snapshot=? AND SUBSTR(name,1,?)=?" inargs := [ ] interface { } { poolID , c . nodeID , volumeType , true , length , regexp } outfmt := [ ] interface { } { volumeName } dbResults , err := queryScan ( c . db , query , inargs , outfmt ) if err != nil { return result , err } for _ , r := range dbResults { result = append ( result , r [ 0 ] . ( string ) ) } return result , nil }
2384	func ( c * Cluster ) StoragePoolNodeVolumesGetType ( volumeType int , poolID int64 ) ( [ ] string , error ) { return c . StoragePoolVolumesGetType ( "default" , volumeType , poolID , c . nodeID ) }
2385	func ( c * Cluster ) StoragePoolVolumeGetType ( project string , volumeName string , volumeType int , poolID , nodeID int64 ) ( int64 , * api . StorageVolume , error ) { if volumeType == StoragePoolVolumeTypeCustom { project = "default" } volumeID , err := c . StoragePoolVolumeGetTypeID ( project , volumeName , volumeType , poolID , nodeID ) if err != nil { return - 1 , nil , err } volumeNode , err := c . StorageVolumeNodeGet ( volumeID ) if err != nil { return - 1 , nil , err } volumeConfig , err := c . StorageVolumeConfigGet ( volumeID ) if err != nil { return - 1 , nil , err } volumeDescription , err := c . StorageVolumeDescriptionGet ( volumeID ) if err != nil { return - 1 , nil , err } volumeTypeName , err := StoragePoolVolumeTypeToName ( volumeType ) if err != nil { return - 1 , nil , err } storageVolume := api . StorageVolume { Type : volumeTypeName , } storageVolume . Name = volumeName storageVolume . Description = volumeDescription storageVolume . Config = volumeConfig storageVolume . Location = volumeNode return volumeID , & storageVolume , nil }
2386	func ( c * Cluster ) StoragePoolNodeVolumeGetType ( volumeName string , volumeType int , poolID int64 ) ( int64 , * api . StorageVolume , error ) { return c . StoragePoolNodeVolumeGetTypeByProject ( "default" , volumeName , volumeType , poolID ) }
2387	func ( c * Cluster ) StoragePoolNodeVolumeGetTypeByProject ( project , volumeName string , volumeType int , poolID int64 ) ( int64 , * api . StorageVolume , error ) { return c . StoragePoolVolumeGetType ( project , volumeName , volumeType , poolID , c . nodeID ) }
2388	func ( c * Cluster ) StoragePoolVolumeUpdate ( volumeName string , volumeType int , poolID int64 , volumeDescription string , volumeConfig map [ string ] string ) error { volumeID , _ , err := c . StoragePoolNodeVolumeGetType ( volumeName , volumeType , poolID ) if err != nil { return err } err = c . Transaction ( func ( tx * ClusterTx ) error { err = storagePoolVolumeReplicateIfCeph ( tx . tx , volumeID , "default" , volumeName , volumeType , poolID , func ( volumeID int64 ) error { err = StorageVolumeConfigClear ( tx . tx , volumeID ) if err != nil { return err } err = StorageVolumeConfigAdd ( tx . tx , volumeID , volumeConfig ) if err != nil { return err } return StorageVolumeDescriptionUpdate ( tx . tx , volumeID , volumeDescription ) } ) if err != nil { return err } return nil } ) return err }
2389	func ( c * Cluster ) StoragePoolVolumeDelete ( project , volumeName string , volumeType int , poolID int64 ) error { volumeID , _ , err := c . StoragePoolNodeVolumeGetTypeByProject ( project , volumeName , volumeType , poolID ) if err != nil { return err } err = c . Transaction ( func ( tx * ClusterTx ) error { err := storagePoolVolumeReplicateIfCeph ( tx . tx , volumeID , project , volumeName , volumeType , poolID , func ( volumeID int64 ) error { _ , err := tx . tx . Exec ( "DELETE FROM storage_volumes WHERE id=?" , volumeID ) return err } ) return err } ) return err }
2390	func ( c * Cluster ) StoragePoolVolumeRename ( project , oldVolumeName string , newVolumeName string , volumeType int , poolID int64 ) error { volumeID , _ , err := c . StoragePoolNodeVolumeGetTypeByProject ( project , oldVolumeName , volumeType , poolID ) if err != nil { return err } err = c . Transaction ( func ( tx * ClusterTx ) error { err := storagePoolVolumeReplicateIfCeph ( tx . tx , volumeID , project , oldVolumeName , volumeType , poolID , func ( volumeID int64 ) error { _ , err := tx . tx . Exec ( "UPDATE storage_volumes SET name=? WHERE id=? AND type=?" , newVolumeName , volumeID , volumeType ) return err } ) return err } ) return err }
2391	func storagePoolVolumeReplicateIfCeph ( tx * sql . Tx , volumeID int64 , project , volumeName string , volumeType int , poolID int64 , f func ( int64 ) error ) error { driver , err := storagePoolDriverGet ( tx , poolID ) if err != nil { return err } volumeIDs := [ ] int64 { volumeID } if driver == "ceph" { volumeIDs , err = storageVolumeIDsGet ( tx , project , volumeName , volumeType , poolID ) if err != nil { return err } } for _ , volumeID := range volumeIDs { err := f ( volumeID ) if err != nil { return err } } return nil }
2392	func ( c * Cluster ) StoragePoolVolumeCreate ( project , volumeName , volumeDescription string , volumeType int , snapshot bool , poolID int64 , volumeConfig map [ string ] string ) ( int64 , error ) { var thisVolumeID int64 err := c . Transaction ( func ( tx * ClusterTx ) error { nodeIDs := [ ] int { int ( c . nodeID ) } driver , err := storagePoolDriverGet ( tx . tx , poolID ) if err != nil { return err } if driver == "ceph" { nodeIDs , err = query . SelectIntegers ( tx . tx , "SELECT id FROM nodes" ) if err != nil { return err } } for _ , nodeID := range nodeIDs { result , err := tx . tx . Exec ( `INSERT INTO storage_volumes (storage_pool_id, node_id, type, snapshot, name, description, project_id) VALUES (?, ?, ?, ?, ?, ?, (SELECT id FROM projects WHERE name = ?))` , poolID , nodeID , volumeType , snapshot , volumeName , volumeDescription , project ) if err != nil { return err } volumeID , err := result . LastInsertId ( ) if err != nil { return err } if int64 ( nodeID ) == c . nodeID { thisVolumeID = volumeID } err = StorageVolumeConfigAdd ( tx . tx , volumeID , volumeConfig ) if err != nil { tx . tx . Rollback ( ) return err } } return nil } ) if err != nil { thisVolumeID = - 1 } return thisVolumeID , err }
2393	func ( c * Cluster ) StoragePoolVolumeGetTypeID ( project string , volumeName string , volumeType int , poolID , nodeID int64 ) ( int64 , error ) { volumeID := int64 ( - 1 ) query := `SELECT storage_volumes.idFROM storage_volumesJOIN storage_pools ON storage_volumes.storage_pool_id = storage_pools.idJOIN projects ON storage_volumes.project_id = projects.idWHERE projects.name=? AND storage_volumes.storage_pool_id=? AND storage_volumes.node_id=?AND storage_volumes.name=? AND storage_volumes.type=?` inargs := [ ] interface { } { project , poolID , nodeID , volumeName , volumeType } outargs := [ ] interface { } { & volumeID } err := dbQueryRowScan ( c . db , query , inargs , outargs ) if err != nil { if err == sql . ErrNoRows { return - 1 , ErrNoSuchObject } return - 1 , err } return volumeID , nil }
2394	func ( c * Cluster ) StoragePoolNodeVolumeGetTypeID ( volumeName string , volumeType int , poolID int64 ) ( int64 , error ) { return c . StoragePoolVolumeGetTypeID ( "default" , volumeName , volumeType , poolID , c . nodeID ) }
2395	func StoragePoolVolumeTypeToName ( volumeType int ) ( string , error ) { switch volumeType { case StoragePoolVolumeTypeContainer : return StoragePoolVolumeTypeNameContainer , nil case StoragePoolVolumeTypeImage : return StoragePoolVolumeTypeNameImage , nil case StoragePoolVolumeTypeCustom : return StoragePoolVolumeTypeNameCustom , nil } return "" , fmt . Errorf ( "invalid storage volume type" ) }
2396	func DevicesAdd ( tx * sql . Tx , w string , cID int64 , devices types . Devices ) error { str1 := fmt . Sprintf ( "INSERT INTO %ss_devices (%s_id, name, type) VALUES (?, ?, ?)" , w , w ) stmt1 , err := tx . Prepare ( str1 ) if err != nil { return err } defer stmt1 . Close ( ) str2 := fmt . Sprintf ( "INSERT INTO %ss_devices_config (%s_device_id, key, value) VALUES (?, ?, ?)" , w , w ) stmt2 , err := tx . Prepare ( str2 ) if err != nil { return err } defer stmt2 . Close ( ) for k , v := range devices { t , err := dbDeviceTypeToInt ( v [ "type" ] ) if err != nil { return err } result , err := stmt1 . Exec ( cID , k , t ) if err != nil { return err } id64 , err := result . LastInsertId ( ) if err != nil { return fmt . Errorf ( "Error inserting device %s into database" , k ) } id := int ( id64 ) for ck , cv := range v { if ck == "type" || cv == "" { continue } _ , err = stmt2 . Exec ( id , ck , cv ) if err != nil { return err } } } return nil }
2397	func ( c * Cluster ) Devices ( project , qName string , isprofile bool ) ( types . Devices , error ) { err := c . Transaction ( func ( tx * ClusterTx ) error { enabled , err := tx . ProjectHasProfiles ( project ) if err != nil { return err } if ! enabled { project = "default" } return nil } ) if err != nil { return nil , err } var q string if isprofile { q = `SELECT profiles_devices.id, profiles_devices.name, profiles_devices.type FROM profiles_devices JOIN profiles ON profiles_devices.profile_id = profiles.id JOIN projects ON projects.id=profiles.project_id WHERE projects.name=? AND profiles.name=?` } else { q = `SELECT containers_devices.id, containers_devices.name, containers_devices.type FROM containers_devices JOIN containers ON containers_devices.container_id = containers.id JOIN projects ON projects.id=containers.project_id WHERE projects.name=? AND containers.name=?` } var id , dtype int var name , stype string inargs := [ ] interface { } { project , qName } outfmt := [ ] interface { } { id , name , dtype } results , err := queryScan ( c . db , q , inargs , outfmt ) if err != nil { return nil , err } devices := types . Devices { } for _ , r := range results { id = r [ 0 ] . ( int ) name = r [ 1 ] . ( string ) stype , err = dbDeviceTypeToString ( r [ 2 ] . ( int ) ) if err != nil { return nil , err } newdev , err := dbDeviceConfig ( c . db , id , isprofile ) if err != nil { return nil , err } newdev [ "type" ] = stype devices [ name ] = newdev } return devices , nil }
2398	func ( n * Node ) Patches ( ) ( [ ] string , error ) { inargs := [ ] interface { } { } outfmt := [ ] interface { } { "" } query := fmt . Sprintf ( "SELECT name FROM patches" ) result , err := queryScan ( n . db , query , inargs , outfmt ) if err != nil { return [ ] string { } , err } response := [ ] string { } for _ , r := range result { response = append ( response , r [ 0 ] . ( string ) ) } return response , nil }
2399	func ( n * Node ) PatchesMarkApplied ( patch string ) error { stmt := `INSERT INTO patches (name, applied_at) VALUES (?, strftime("%s"));` _ , err := n . db . Exec ( stmt , patch ) return err }
2400	func entityType ( pkg string , entity string ) string { typ := lex . Capital ( entity ) if pkg != "db" { typ = pkg + "." + typ } return typ }
2401	func entityPost ( entity string ) string { return fmt . Sprintf ( "%sPost" , lex . Capital ( lex . Plural ( entity ) ) ) }
2402	func stmtCodeVar ( entity string , kind string , filters ... string ) string { name := fmt . Sprintf ( "%s%s" , entity , lex . Camel ( kind ) ) if len ( filters ) > 0 { name += "By" name += strings . Join ( filters , "And" ) } return name }
2403	func destFunc ( slice string , typ string , fields [ ] * Field ) string { f := fmt . Sprintf ( `func(i int) []interface{} { %s = append(%s, %s{}) return []interface{}{` , slice , slice , typ ) for _ , field := range fields { f += fmt . Sprintf ( "&%s[i].%s,\n" , \n , slice ) } field . Name f += " }\n" \n }
2404	func CompareConfigs ( config1 , config2 map [ string ] string , exclude [ ] string ) error { if exclude == nil { exclude = [ ] string { } } delta := [ ] string { } for key , value := range config1 { if shared . StringInSlice ( key , exclude ) { continue } if config2 [ key ] != value { delta = append ( delta , key ) } } for key , value := range config2 { if shared . StringInSlice ( key , exclude ) { continue } if config1 [ key ] != value { present := false for i := range delta { if delta [ i ] == key { present = true } break } if ! present { delta = append ( delta , key ) } } } sort . Strings ( delta ) if len ( delta ) > 0 { return fmt . Errorf ( "different values for keys: %s" , strings . Join ( delta , ", " ) ) } return nil }
2405	func CopyConfig ( config map [ string ] string ) map [ string ] string { copy := map [ string ] string { } for key , value := range config { copy [ key ] = value } return copy }
2406	func NewNotifier ( state * state . State , cert * shared . CertInfo , policy NotifierPolicy ) ( Notifier , error ) { address , err := node . ClusterAddress ( state . Node ) if err != nil { return nil , errors . Wrap ( err , "failed to fetch node address" ) } if address == "" { nullNotifier := func ( func ( lxd . ContainerServer ) error ) error { return nil } return nullNotifier , nil } peers := [ ] string { } err = state . Cluster . Transaction ( func ( tx * db . ClusterTx ) error { offlineThreshold , err := tx . NodeOfflineThreshold ( ) if err != nil { return err } nodes , err := tx . Nodes ( ) if err != nil { return err } for _ , node := range nodes { if node . Address == address || node . Address == "0.0.0.0" { continue } if node . IsOffline ( offlineThreshold ) { switch policy { case NotifyAll : return fmt . Errorf ( "peer node %s is down" , node . Address ) case NotifyAlive : continue } } peers = append ( peers , node . Address ) } return nil } ) if err != nil { return nil , err } notifier := func ( hook func ( lxd . ContainerServer ) error ) error { errs := make ( [ ] error , len ( peers ) ) wg := sync . WaitGroup { } wg . Add ( len ( peers ) ) for i , address := range peers { logger . Debugf ( "Notify node %s of state changes" , address ) go func ( i int , address string ) { defer wg . Done ( ) client , err := Connect ( address , cert , true ) if err != nil { errs [ i ] = errors . Wrapf ( err , "failed to connect to peer %s" , address ) return } err = hook ( client ) if err != nil { errs [ i ] = errors . Wrapf ( err , "failed to notify peer %s" , address ) } } ( i , address ) } wg . Wait ( ) for i , err := range errs { if err != nil { if isClientConnectionError ( err ) && policy == NotifyAlive { logger . Warnf ( "Could not notify node %s" , peers [ i ] ) continue } return err } } return nil } return notifier , nil }
2407	func Events ( endpoints * endpoints . Endpoints , cluster * db . Cluster , f func ( int64 , api . Event ) ) ( task . Func , task . Schedule ) { listeners := map [ int64 ] * lxd . EventListener { } update := func ( ctx context . Context ) { ch := make ( chan struct { } ) go func ( ) { eventsUpdateListeners ( endpoints , cluster , listeners , f ) ch <- struct { } { } } ( ) select { case <- ch : case <- ctx . Done ( ) : } } schedule := task . Every ( time . Second ) return update , schedule }
2408	func eventsConnect ( address string , cert * shared . CertInfo ) ( * lxd . EventListener , error ) { client , err := Connect ( address , cert , true ) if err != nil { return nil , err } client = client . UseProject ( "*" ) return client . GetEvents ( ) }
2409	func ( s * storageDir ) StoragePoolInit ( ) error { err := s . StorageCoreInit ( ) if err != nil { return err } return nil }
2410	func getAAProfileContent ( c container ) string { profile := strings . TrimLeft ( AA_PROFILE_BASE , "\n" ) \n if aaParserSupports ( "unix" ) { profile += ` ### Feature: unix # Allow receive via unix sockets from anywhere unix (receive), # Allow all unix in the container unix peer=(label=@{profile_name}),` } if shared . PathExists ( "/proc/self/ns/cgroup" ) { profile += "\n ### Feature: cgroup namespace\n" \n \n } profile += " mount fstype=cgroup -> /sys/fs/cgroup/**,\n" \n profile += " mount fstype=cgroup2 -> /sys/fs/cgroup/**,\n" \n state := c . DaemonState ( ) if state . OS . AppArmorStacking && ! state . OS . AppArmorStacked { profile += "\n ### Feature: apparmor stacking\n" \n \n profile += ` ### Configuration: apparmor profile loading (in namespace) deny /sys/k[^e]*{,/**} wklx, deny /sys/ke[^r]*{,/**} wklx, deny /sys/ker[^n]*{,/**} wklx, deny /sys/kern[^e]*{,/**} wklx, deny /sys/kerne[^l]*{,/**} wklx, deny /sys/kernel/[^s]*{,/**} wklx, deny /sys/kernel/s[^e]*{,/**} wklx, deny /sys/kernel/se[^c]*{,/**} wklx, deny /sys/kernel/sec[^u]*{,/**} wklx, deny /sys/kernel/secu[^r]*{,/**} wklx, deny /sys/kernel/secur[^i]*{,/**} wklx, deny /sys/kernel/securi[^t]*{,/**} wklx, deny /sys/kernel/securit[^y]*{,/**} wklx, deny /sys/kernel/security/[^a]*{,/**} wklx, deny /sys/kernel/security/a[^p]*{,/**} wklx, deny /sys/kernel/security/ap[^p]*{,/**} wklx, deny /sys/kernel/security/app[^a]*{,/**} wklx, deny /sys/kernel/security/appa[^r]*{,/**} wklx, deny /sys/kernel/security/appar[^m]*{,/**} wklx, deny /sys/kernel/security/apparm[^o]*{,/**} wklx, deny /sys/kernel/security/apparmo[^r]*{,/**} wklx, deny /sys/kernel/security/apparmor?*{,/**} wklx, deny /sys/kernel/security?*{,/**} wklx, deny /sys/kernel?*{,/**} wklx,` } else profile += fmt . Sprintf ( " change_profile -> \":%s:*\",\n" , \" ) }
2411	func AALoadProfile ( c container ) error { state := c . DaemonState ( ) if ! state . OS . AppArmorAdmin { return nil } if err := mkApparmorNamespace ( c , AANamespace ( c ) ) ; err != nil { return err } profile := path . Join ( aaPath , "profiles" , AAProfileShort ( c ) ) content , err := ioutil . ReadFile ( profile ) if err != nil && ! os . IsNotExist ( err ) { return err } updated := getAAProfileContent ( c ) if string ( content ) != string ( updated ) { if err := os . MkdirAll ( path . Join ( aaPath , "cache" ) , 0700 ) ; err != nil { return err } if err := os . MkdirAll ( path . Join ( aaPath , "profiles" ) , 0700 ) ; err != nil { return err } if err := ioutil . WriteFile ( profile , [ ] byte ( updated ) , 0600 ) ; err != nil { return err } } return runApparmor ( APPARMOR_CMD_LOAD , c ) }
2412	func AADestroy ( c container ) error { state := c . DaemonState ( ) if ! state . OS . AppArmorAdmin { return nil } if state . OS . AppArmorStacking && ! state . OS . AppArmorStacked { p := path . Join ( "/sys/kernel/security/apparmor/policy/namespaces" , AANamespace ( c ) ) if err := os . Remove ( p ) ; err != nil { logger . Error ( "Error removing apparmor namespace" , log . Ctx { "err" : err , "ns" : p } ) } } return runApparmor ( APPARMOR_CMD_UNLOAD , c ) }
2413	func AAParseProfile ( c container ) error { state := c . DaemonState ( ) if ! state . OS . AppArmorAvailable { return nil } return runApparmor ( APPARMOR_CMD_PARSE , c ) }
2414	func getSystemHandler ( syslog string , debug bool , format log . Format ) log . Handler { return nil }
2415	func NotifyUpgradeCompleted ( state * state . State , cert * shared . CertInfo ) error { notifier , err := NewNotifier ( state , cert , NotifyAll ) if err != nil { return err } return notifier ( func ( client lxd . ContainerServer ) error { info , err := client . GetConnectionInfo ( ) if err != nil { return errors . Wrap ( err , "failed to get connection info" ) } url := fmt . Sprintf ( "%s%s" , info . Addresses [ 0 ] , databaseEndpoint ) request , err := http . NewRequest ( "PATCH" , url , nil ) if err != nil { return errors . Wrap ( err , "failed to create database notify upgrade request" ) } httpClient , err := client . GetHTTPClient ( ) if err != nil { return errors . Wrap ( err , "failed to get HTTP client" ) } response , err := httpClient . Do ( request ) if err != nil { return errors . Wrap ( err , "failed to notify node about completed upgrade" ) } if response . StatusCode != http . StatusOK { return fmt . Errorf ( "database upgrade notification failed: %s" , response . Status ) } return nil } ) }
2416	func KeepUpdated ( state * state . State ) ( task . Func , task . Schedule ) { f := func ( ctx context . Context ) { ch := make ( chan struct { } ) go func ( ) { maybeUpdate ( state ) close ( ch ) } ( ) select { case <- ctx . Done ( ) : case <- ch : } } schedule := task . Every ( 5 * time . Minute ) return f , schedule }
2417	func maybeUpdate ( state * state . State ) { shouldUpdate := false enabled , err := Enabled ( state . Node ) if err != nil { logger . Errorf ( "Failed to check clustering is enabled: %v" , err ) return } if ! enabled { return } err = state . Cluster . Transaction ( func ( tx * db . ClusterTx ) error { outdated , err := tx . NodeIsOutdated ( ) if err != nil { return err } shouldUpdate = outdated return nil } ) if err != nil { logger . Errorf ( "Failed to check if this node is out-of-date: %v" , err ) return } if ! shouldUpdate { logger . Debugf ( "Cluster node is up-to-date" ) return } logger . Infof ( "Node is out-of-date with respect to other cluster nodes" ) updateExecutable := os . Getenv ( "LXD_CLUSTER_UPDATE" ) if updateExecutable == "" { logger . Debug ( "No LXD_CLUSTER_UPDATE variable set, skipping auto-update" ) return } logger . Infof ( "Triggering cluster update using: %s" , updateExecutable ) _ , err = shared . RunCommand ( updateExecutable ) if err != nil { logger . Errorf ( "Cluster upgrade failed: '%v'" , err . Error ( ) ) return } }
2418	func NewServer ( apiURL string , apiKey string , agentAuthURL string , agentUsername string , agentPrivateKey string , agentPublicKey string ) ( * Server , error ) { r := Server { apiURL : apiURL , apiKey : apiKey , lastSyncID : "" , lastChange : time . Time { } , resources : make ( map [ string ] string ) , permissions : make ( map [ string ] map [ string ] [ ] string ) , permissionsLock : & sync . Mutex { } , } var keyPair bakery . KeyPair keyPair . Private . UnmarshalText ( [ ] byte ( agentPrivateKey ) ) keyPair . Public . UnmarshalText ( [ ] byte ( agentPublicKey ) ) r . client = httpbakery . NewClient ( ) authInfo := agent . AuthInfo { Key : & keyPair , Agents : [ ] agent . Agent { { URL : agentAuthURL , Username : agentUsername , } , } , } err := agent . SetUpAuth ( r . client , & authInfo ) if err != nil { return nil , err } r . client . Client . Jar , err = cookiejar . New ( nil ) if err != nil { return nil , err } return & r , nil }
2419	func ( r * Server ) StartStatusCheck ( ) { r . hasStatusChanged ( ) r . statusDone = make ( chan int ) go func ( ) { for { select { case <- r . statusDone : return case <- time . After ( time . Minute ) : if r . hasStatusChanged ( ) { r . flushCache ( ) } } } } ( ) }
2420	func ( r * Server ) SyncProjects ( ) error { if r . ProjectsFunc == nil { return fmt . Errorf ( "ProjectsFunc isn't configured yet, cannot sync" ) } resources := [ ] rbacResource { } resourcesMap := map [ string ] string { } projects , err := r . ProjectsFunc ( ) if err != nil { return err } for id , name := range projects { resources = append ( resources , rbacResource { Name : name , Identifier : strconv . FormatInt ( id , 10 ) , } ) resourcesMap [ name ] = strconv . FormatInt ( id , 10 ) } err = r . postResources ( resources , nil , true ) if err != nil { return err } r . resourcesLock . Lock ( ) r . resources = resourcesMap r . resourcesLock . Unlock ( ) return nil }
2421	func ( r * Server ) AddProject ( id int64 , name string ) error { resource := rbacResource { Name : name , Identifier : strconv . FormatInt ( id , 10 ) , } err := r . postResources ( [ ] rbacResource { resource } , nil , false ) if err != nil { return err } r . resourcesLock . Lock ( ) r . resources [ name ] = strconv . FormatInt ( id , 10 ) r . resourcesLock . Unlock ( ) return nil }
2422	func ( r * Server ) DeleteProject ( id int64 ) error { err := r . postResources ( nil , [ ] string { strconv . FormatInt ( id , 10 ) } , false ) if err != nil { return err } r . resourcesLock . Lock ( ) for k , v := range r . resources { if v == strconv . FormatInt ( id , 10 ) { delete ( r . resources , k ) break } } r . resourcesLock . Unlock ( ) return nil }
2423	func ( r * Server ) RenameProject ( id int64 , name string ) error { return r . AddProject ( id , name ) }
2424	func ( r * Server ) IsAdmin ( username string ) bool { r . permissionsLock . Lock ( ) defer r . permissionsLock . Unlock ( ) _ , cached := r . permissions [ username ] if ! cached { r . syncPermissions ( username ) } return shared . StringInSlice ( "admin" , r . permissions [ username ] [ "" ] ) }
2425	func ( r * Server ) HasPermission ( username , project , permission string ) bool { r . permissionsLock . Lock ( ) defer r . permissionsLock . Unlock ( ) _ , cached := r . permissions [ username ] if ! cached { r . syncPermissions ( username ) } r . resourcesLock . Lock ( ) permissions := r . permissions [ username ] [ r . resources [ project ] ] r . resourcesLock . Unlock ( ) return shared . StringInSlice ( permission , permissions ) }
2426	func rsyncSend ( conn * websocket . Conn , path string , rsyncArgs string ) error { cmd , dataSocket , stderr , err := rsyncSendSetup ( path , rsyncArgs ) if err != nil { return err } if dataSocket != nil { defer dataSocket . Close ( ) } readDone , writeDone := shared . WebsocketMirror ( conn , dataSocket , io . ReadCloser ( dataSocket ) , nil , nil ) output , err := ioutil . ReadAll ( stderr ) if err != nil { cmd . Process . Kill ( ) cmd . Wait ( ) return fmt . Errorf ( "Failed to rsync: %v\n%s" , \n , err ) } output err = cmd . Wait ( ) <- readDone <- writeDone if err != nil { return fmt . Errorf ( "Failed to rsync: %v\n%s" , \n , err ) } }
2427	func rsyncSendSetup ( path string , rsyncArgs string ) ( * exec . Cmd , net . Conn , io . ReadCloser , error ) { auds := fmt . Sprintf ( "@lxd-p2c/%s" , uuid . NewRandom ( ) . String ( ) ) if len ( auds ) > shared . ABSTRACT_UNIX_SOCK_LEN - 1 { auds = auds [ : shared . ABSTRACT_UNIX_SOCK_LEN - 1 ] } l , err := net . Listen ( "unix" , auds ) if err != nil { return nil , nil , nil , err } execPath , err := os . Readlink ( "/proc/self/exe" ) if err != nil { return nil , nil , nil , err } if ! shared . PathExists ( execPath ) { execPath = os . Args [ 0 ] } rsyncCmd := fmt . Sprintf ( "sh -c \"%s netcat %s\"" , \" , \" ) execPath auds args := [ ] string { "-ar" , "--devices" , "--numeric-ids" , "--partial" , "--sparse" , "--xattrs" , "--delete" , "--compress" , "--compress-level=2" , } rsyncCheckVersion := func ( min string ) bool { out , err := shared . RunCommand ( "rsync" , "--version" ) if err != nil { return false } fields := strings . Split ( out , " " ) curVer , err := version . Parse ( fields [ 3 ] ) if err != nil { return false } minVer , err := version . Parse ( min ) if err != nil { return false } return curVer . Compare ( minVer ) >= 0 } if rsyncCheckVersion ( "3.1.0" ) { args = append ( args , "--ignore-missing-args" ) } if rsyncArgs != "" { args = append ( args , strings . Split ( rsyncArgs , " " ) ... ) } args = append ( args , [ ] string { path , "localhost:/tmp/foo" } ... ) args = append ( args , [ ] string { "-e" , rsyncCmd } ... ) cmd := exec . Command ( "rsync" , args ... ) cmd . Stdout = os . Stderr stderr , err := cmd . StderrPipe ( ) if err != nil { return nil , nil , nil , err } if err := cmd . Start ( ) ; err != nil { return nil , nil , nil , err } conn , err := l . Accept ( ) if err != nil { cmd . Process . Kill ( ) cmd . Wait ( ) return nil , nil , nil , err } }
2428	func tlsClientConfig ( info * shared . CertInfo ) ( * tls . Config , error ) { keypair := info . KeyPair ( ) ca := info . CA ( ) config := shared . InitTLSConfig ( ) config . Certificates = [ ] tls . Certificate { keypair } config . RootCAs = x509 . NewCertPool ( ) if ca != nil { config . RootCAs . AddCert ( ca ) } cert , err := x509 . ParseCertificate ( keypair . Certificate [ 0 ] ) if err != nil { return nil , err } cert . IsCA = true cert . KeyUsage = x509 . KeyUsageCertSign config . RootCAs . AddCert ( cert ) if cert . DNSNames != nil { config . ServerName = cert . DNSNames [ 0 ] } return config , nil }
2429	func tlsCheckCert ( r * http . Request , info * shared . CertInfo ) bool { cert , err := x509 . ParseCertificate ( info . KeyPair ( ) . Certificate [ 0 ] ) if err != nil { panic ( fmt . Sprintf ( "invalid keypair material: %v" , err ) ) } trustedCerts := map [ string ] x509 . Certificate { "0" : * cert } trusted , _ := util . CheckTrustState ( * r . TLS . PeerCertificates [ 0 ] , trustedCerts ) return r . TLS != nil && trusted }
2430	func internalClusterContainerMovedPost ( d * Daemon , r * http . Request ) Response { project := projectParam ( r ) containerName := mux . Vars ( r ) [ "name" ] err := containerPostCreateContainerMountPoint ( d , project , containerName ) if err != nil { return SmartError ( err ) } return EmptySyncResponse }
2431	func containerPostCreateContainerMountPoint ( d * Daemon , project , containerName string ) error { c , err := containerLoadByProjectAndName ( d . State ( ) , project , containerName ) if err != nil { return errors . Wrap ( err , "Failed to load moved container on target node" ) } poolName , err := c . StoragePool ( ) if err != nil { return errors . Wrap ( err , "Failed get pool name of moved container on target node" ) } snapshotNames , err := d . cluster . ContainerGetSnapshots ( project , containerName ) if err != nil { return errors . Wrap ( err , "Failed to create container snapshot names" ) } containerMntPoint := getContainerMountPoint ( c . Project ( ) , poolName , containerName ) err = createContainerMountpoint ( containerMntPoint , c . Path ( ) , c . IsPrivileged ( ) ) if err != nil { return errors . Wrap ( err , "Failed to create container mount point on target node" ) } for _ , snapshotName := range snapshotNames { mntPoint := getSnapshotMountPoint ( project , poolName , snapshotName ) snapshotsSymlinkTarget := shared . VarPath ( "storage-pools" , poolName , "containers-snapshots" , containerName ) snapshotMntPointSymlink := shared . VarPath ( "snapshots" , containerName ) err := createSnapshotMountpoint ( mntPoint , snapshotsSymlinkTarget , snapshotMntPointSymlink ) if err != nil { return errors . Wrap ( err , "Failed to create snapshot mount point on target node" ) } } return nil }
2432	func ( list Devices ) Contains ( k string , d Device ) bool { if list [ k ] == nil { return false } old := list [ k ] return deviceEquals ( old , d ) }
2433	func ( list Devices ) Update ( newlist Devices ) ( map [ string ] Device , map [ string ] Device , map [ string ] Device , [ ] string ) { rmlist := map [ string ] Device { } addlist := map [ string ] Device { } updatelist := map [ string ] Device { } for key , d := range list { if ! newlist . Contains ( key , d ) { rmlist [ key ] = d } } for key , d := range newlist { if ! list . Contains ( key , d ) { addlist [ key ] = d } } updateDiff := [ ] string { } for key , d := range addlist { srcOldDevice := rmlist [ key ] var oldDevice Device err := shared . DeepCopy ( & srcOldDevice , & oldDevice ) if err != nil { continue } srcNewDevice := newlist [ key ] var newDevice Device err = shared . DeepCopy ( & srcNewDevice , & newDevice ) if err != nil { continue } updateDiff = deviceEqualsDiffKeys ( oldDevice , newDevice ) for _ , k := range [ ] string { "limits.max" , "limits.read" , "limits.write" , "limits.egress" , "limits.ingress" , "ipv4.address" , "ipv6.address" , "ipv4.routes" , "ipv6.routes" } { delete ( oldDevice , k ) delete ( newDevice , k ) } if deviceEquals ( oldDevice , newDevice ) { delete ( rmlist , key ) delete ( addlist , key ) updatelist [ key ] = d } } return rmlist , addlist , updatelist , updateDiff }
2434	func ( list Devices ) DeviceNames ( ) [ ] string { sortable := sortableDevices { } for k , d := range list { sortable = append ( sortable , namedDevice { k , d } ) } sort . Sort ( sortable ) return sortable . Names ( ) }
2435	func Infof ( format string , args ... interface { } ) { if Log != nil { Log . Info ( fmt . Sprintf ( format , args ... ) ) } }
2436	func Debugf ( format string , args ... interface { } ) { if Log != nil { Log . Debug ( fmt . Sprintf ( format , args ... ) ) } }
2437	func Warnf ( format string , args ... interface { } ) { if Log != nil { Log . Warn ( fmt . Sprintf ( format , args ... ) ) } }
2438	func Errorf ( format string , args ... interface { } ) { if Log != nil { Log . Error ( fmt . Sprintf ( format , args ... ) ) } }
2439	func Critf ( format string , args ... interface { } ) { if Log != nil { Log . Crit ( fmt . Sprintf ( format , args ... ) ) } }
2440	func eventForward ( id int64 , event api . Event ) { if event . Type == "logging" { logEntry := api . EventLogging { } err := json . Unmarshal ( event . Metadata , & logEntry ) if err != nil { return } if ! debug && logEntry . Level == "dbug" { return } if ! debug && ! verbose && logEntry . Level == "info" { return } } err := eventBroadcast ( "" , event , true ) if err != nil { logger . Warnf ( "Failed to forward event from node %d: %v" , id , err ) } }
2441	func StorageProgressReader ( op * operation , key string , description string ) func ( io . ReadCloser ) io . ReadCloser { return func ( reader io . ReadCloser ) io . ReadCloser { if op == nil { return reader } progress := func ( progressInt int64 , speedInt int64 ) { progressWrapperRender ( op , key , description , progressInt , speedInt ) } readPipe := & ioprogress . ProgressReader { ReadCloser : reader , Tracker : & ioprogress . ProgressTracker { Handler : progress , } , } return readPipe } }
2442	func StorageProgressWriter ( op * operation , key string , description string ) func ( io . WriteCloser ) io . WriteCloser { return func ( writer io . WriteCloser ) io . WriteCloser { if op == nil { return writer } progress := func ( progressInt int64 , speedInt int64 ) { progressWrapperRender ( op , key , description , progressInt , speedInt ) } writePipe := & ioprogress . ProgressWriter { WriteCloser : writer , Tracker : & ioprogress . ProgressTracker { Handler : progress , } , } return writePipe } }
2443	func GetLSBRelease ( ) ( map [ string ] string , error ) { osRelease , err := getLSBRelease ( "/etc/os-release" ) if os . IsNotExist ( err ) { return getLSBRelease ( "/usr/lib/os-release" ) } return osRelease , err }
2444	func Reset ( path string , imports [ ] string ) error { content := fmt . Sprintf ( `package %s// The code below was generated by %s - DO NOT EDIT!import (` , os . Getenv ( "GOPACKAGE" ) , os . Args [ 0 ] ) for _ , uri := range imports { content += fmt . Sprintf ( "\t%q\n" , \t ) } \n uri content += ")\n\n" \n \n content += "var _ = api.ServerEnvironment{}\n" \n }
2445	func Append ( path string , snippet Snippet ) error { buffer := newBuffer ( ) buffer . N ( ) err := snippet . Generate ( buffer ) if err != nil { return errors . Wrap ( err , "Generate code snippet" ) } var file * os . File if path == "-" { file = os . Stdout } else { file , err = os . OpenFile ( path , os . O_APPEND | os . O_WRONLY , 0644 ) if err != nil { return errors . Wrapf ( err , "Open target source code file '%s'" , path ) } defer file . Close ( ) } bytes , err := buffer . code ( ) if err != nil { return err } _ , err = file . Write ( bytes ) if err != nil { return errors . Wrapf ( err , "Append snippet to target source code file '%s'" , path ) } return nil }
2446	func ContainerToArgs ( container * Container ) ContainerArgs { args := ContainerArgs { ID : container . ID , Project : container . Project , Name : container . Name , Node : container . Node , Ctype : ContainerType ( container . Type ) , Architecture : container . Architecture , Ephemeral : container . Ephemeral , CreationDate : container . CreationDate , Stateful : container . Stateful , LastUsedDate : container . LastUseDate , Description : container . Description , Config : container . Config , Devices : container . Devices , Profiles : container . Profiles , ExpiryDate : container . ExpiryDate , } if args . Devices == nil { args . Devices = types . Devices { } } return args }
2447	func ( c * ClusterTx ) ContainerNames ( project string ) ( [ ] string , error ) { stmt := `SELECT containers.name FROM containers JOIN projects ON projects.id = containers.project_id WHERE projects.name = ? AND containers.type = ?` return query . SelectStrings ( c . tx , stmt , project , CTypeRegular ) }
2448	func ( c * ClusterTx ) ContainerNodeAddress ( project string , name string ) ( string , error ) { stmt := `SELECT nodes.id, nodes.address FROM nodes JOIN containers ON containers.node_id = nodes.id JOIN projects ON projects.id = containers.project_id WHERE projects.name = ? AND containers.name = ?` var address string var id int64 rows , err := c . tx . Query ( stmt , project , name ) if err != nil { return "" , err } defer rows . Close ( ) if ! rows . Next ( ) { return "" , ErrNoSuchObject } err = rows . Scan ( & id , & address ) if err != nil { return "" , err } if rows . Next ( ) { return "" , fmt . Errorf ( "more than one node associated with container" ) } err = rows . Err ( ) if err != nil { return "" , err } if id == c . nodeID { return "" , nil } return address , nil }
2449	func ( c * ClusterTx ) ContainersListByNodeAddress ( project string ) ( map [ string ] [ ] string , error ) { offlineThreshold , err := c . NodeOfflineThreshold ( ) if err != nil { return nil , err } stmt := `SELECT containers.name, nodes.id, nodes.address, nodes.heartbeat FROM containers JOIN nodes ON nodes.id = containers.node_id JOIN projects ON projects.id = containers.project_id WHERE containers.type=? AND projects.name = ? ORDER BY containers.id` rows , err := c . tx . Query ( stmt , CTypeRegular , project ) if err != nil { return nil , err } defer rows . Close ( ) result := map [ string ] [ ] string { } for i := 0 ; rows . Next ( ) ; i ++ { var name string var nodeAddress string var nodeID int64 var nodeHeartbeat time . Time err := rows . Scan ( & name , & nodeID , & nodeAddress , & nodeHeartbeat ) if err != nil { return nil , err } if nodeID == c . nodeID { nodeAddress = "" } else if nodeIsOffline ( offlineThreshold , nodeHeartbeat ) { nodeAddress = "0.0.0.0" } result [ nodeAddress ] = append ( result [ nodeAddress ] , name ) } err = rows . Err ( ) if err != nil { return nil , err } return result , nil }
2450	func ( c * ClusterTx ) ContainerListExpanded ( ) ( [ ] Container , error ) { containers , err := c . ContainerList ( ContainerFilter { } ) if err != nil { return nil , errors . Wrap ( err , "Load containers" ) } profiles , err := c . ProfileList ( ProfileFilter { } ) if err != nil { return nil , errors . Wrap ( err , "Load profiles" ) } profilesByProjectAndName := map [ string ] map [ string ] Profile { } for _ , profile := range profiles { profilesByName , ok := profilesByProjectAndName [ profile . Project ] if ! ok { profilesByName = map [ string ] Profile { } profilesByProjectAndName [ profile . Project ] = profilesByName } profilesByName [ profile . Name ] = profile } for i , container := range containers { profiles := make ( [ ] api . Profile , len ( container . Profiles ) ) for j , name := range container . Profiles { profile := profilesByProjectAndName [ container . Project ] [ name ] profiles [ j ] = * ProfileToAPI ( & profile ) } containers [ i ] . Config = ProfilesExpandConfig ( container . Config , profiles ) containers [ i ] . Devices = ProfilesExpandDevices ( container . Devices , profiles ) } return containers , nil }
2451	func ( c * ClusterTx ) ContainersByNodeName ( project string ) ( map [ string ] string , error ) { stmt := `SELECT containers.name, nodes.name FROM containers JOIN nodes ON nodes.id = containers.node_id JOIN projects ON projects.id = containers.project_id WHERE containers.type=? AND projects.name = ?` rows , err := c . tx . Query ( stmt , CTypeRegular , project ) if err != nil { return nil , err } defer rows . Close ( ) result := map [ string ] string { } for i := 0 ; rows . Next ( ) ; i ++ { var name string var nodeName string err := rows . Scan ( & name , & nodeName ) if err != nil { return nil , err } result [ name ] = nodeName } err = rows . Err ( ) if err != nil { return nil , err } return result , nil }
2452	func ( c * ClusterTx ) SnapshotIDsAndNames ( name string ) ( map [ int ] string , error ) { prefix := name + shared . SnapshotDelimiter length := len ( prefix ) objects := make ( [ ] struct { ID int Name string } , 0 ) dest := func ( i int ) [ ] interface { } { objects = append ( objects , struct { ID int Name string } { } ) return [ ] interface { } { & objects [ i ] . ID , & objects [ i ] . Name } } stmt , err := c . tx . Prepare ( "SELECT id, name FROM containers WHERE SUBSTR(name,1,?)=? AND type=?" ) if err != nil { return nil , err } defer stmt . Close ( ) err = query . SelectObjects ( stmt , dest , length , prefix , CTypeSnapshot ) if err != nil { return nil , err } result := make ( map [ int ] string ) for i := range objects { result [ objects [ i ] . ID ] = strings . Split ( objects [ i ] . Name , shared . SnapshotDelimiter ) [ 1 ] } return result , nil }
2453	func ( c * ClusterTx ) ContainerNodeList ( ) ( [ ] Container , error ) { node , err := c . NodeName ( ) if err != nil { return nil , errors . Wrap ( err , "Local node name" ) } filter := ContainerFilter { Node : node , Type : int ( CTypeRegular ) , } return c . ContainerList ( filter ) }
2454	func ( c * ClusterTx ) ContainerNodeProjectList ( project string ) ( [ ] Container , error ) { node , err := c . NodeName ( ) if err != nil { return nil , errors . Wrap ( err , "Local node name" ) } filter := ContainerFilter { Project : project , Node : node , Type : int ( CTypeRegular ) , } return c . ContainerList ( filter ) }
2455	func ( c * Cluster ) ContainerRemove ( project , name string ) error { return c . Transaction ( func ( tx * ClusterTx ) error { return tx . ContainerDelete ( project , name ) } ) }
2456	func ( c * Cluster ) ContainerProjectAndName ( id int ) ( string , string , error ) { q := `SELECT projects.name, containers.name FROM containers JOIN projects ON projects.id = containers.project_idWHERE containers.id=?` project := "" name := "" arg1 := [ ] interface { } { id } arg2 := [ ] interface { } { & project , & name } err := dbQueryRowScan ( c . db , q , arg1 , arg2 ) if err == sql . ErrNoRows { return "" , "" , ErrNoSuchObject } return project , name , err }
2457	func ContainerConfigClear ( tx * sql . Tx , id int ) error { _ , err := tx . Exec ( "DELETE FROM containers_config WHERE container_id=?" , id ) if err != nil { return err } _ , err = tx . Exec ( "DELETE FROM containers_profiles WHERE container_id=?" , id ) if err != nil { return err } _ , err = tx . Exec ( `DELETE FROM containers_devices_config WHERE id IN (SELECT containers_devices_config.id FROM containers_devices_config JOIN containers_devices ON containers_devices_config.container_device_id=containers_devices.id WHERE containers_devices.container_id=?)` , id ) if err != nil { return err } _ , err = tx . Exec ( "DELETE FROM containers_devices WHERE container_id=?" , id ) return err }
2458	func ( c * Cluster ) ContainerConfigGet ( id int , key string ) ( string , error ) { q := "SELECT value FROM containers_config WHERE container_id=? AND key=?" value := "" arg1 := [ ] interface { } { id , key } arg2 := [ ] interface { } { & value } err := dbQueryRowScan ( c . db , q , arg1 , arg2 ) if err == sql . ErrNoRows { return "" , ErrNoSuchObject } return value , err }
2459	func ( c * Cluster ) ContainerConfigRemove ( id int , key string ) error { err := exec ( c . db , "DELETE FROM containers_config WHERE key=? AND container_id=?" , key , id ) return err }
2460	func ( c * Cluster ) ContainerSetStateful ( id int , stateful bool ) error { statefulInt := 0 if stateful { statefulInt = 1 } err := exec ( c . db , "UPDATE containers SET stateful=? WHERE id=?" , statefulInt , id ) return err }
2461	func ContainerProfilesInsert ( tx * sql . Tx , id int , project string , profiles [ ] string ) error { enabled , err := projectHasProfiles ( tx , project ) if err != nil { return errors . Wrap ( err , "Check if project has profiles" ) } if ! enabled { project = "default" } applyOrder := 1 str := `INSERT INTO containers_profiles (container_id, profile_id, apply_order) VALUES ( ?, (SELECT profiles.id FROM profiles JOIN projects ON projects.id=profiles.project_id WHERE projects.name=? AND profiles.name=?), ? )` stmt , err := tx . Prepare ( str ) if err != nil { return err } defer stmt . Close ( ) for _ , profile := range profiles { _ , err = stmt . Exec ( id , project , profile , applyOrder ) if err != nil { logger . Debugf ( "Error adding profile %s to container: %s" , profile , err ) return err } applyOrder = applyOrder + 1 } return nil }
2462	func ( c * Cluster ) ContainerProfiles ( id int ) ( [ ] string , error ) { var name string var profiles [ ] string query := ` SELECT name FROM containers_profiles JOIN profiles ON containers_profiles.profile_id=profiles.id WHERE container_id=? ORDER BY containers_profiles.apply_order` inargs := [ ] interface { } { id } outfmt := [ ] interface { } { name } results , err := queryScan ( c . db , query , inargs , outfmt ) if err != nil { return nil , err } for _ , r := range results { name = r [ 0 ] . ( string ) profiles = append ( profiles , name ) } return profiles , nil }
2463	func ( c * Cluster ) ContainerConfig ( id int ) ( map [ string ] string , error ) { var key , value string q := `SELECT key, value FROM containers_config WHERE container_id=?` inargs := [ ] interface { } { id } outfmt := [ ] interface { } { key , value } results , err := queryScan ( c . db , q , inargs , outfmt ) if err != nil { return nil , err } config := map [ string ] string { } for _ , r := range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) config [ key ] = value } return config , nil }
2464	func ( c * Cluster ) ContainerSetState ( id int , state string ) error { err := c . Transaction ( func ( tx * ClusterTx ) error { str := fmt . Sprintf ( "INSERT OR REPLACE INTO containers_config (container_id, key, value) VALUES (?, 'volatile.last_state.power', ?)" ) stmt , err := tx . tx . Prepare ( str ) if err != nil { return err } defer stmt . Close ( ) if _ , err = stmt . Exec ( id , state ) ; err != nil { return err } return nil } ) return err }
2465	func ContainerUpdate ( tx * sql . Tx , id int , description string , architecture int , ephemeral bool , expiryDate time . Time ) error { str := fmt . Sprintf ( "UPDATE containers SET description=?, architecture=?, ephemeral=?, expiry_date=? WHERE id=?" ) stmt , err := tx . Prepare ( str ) if err != nil { return err } defer stmt . Close ( ) ephemeralInt := 0 if ephemeral { ephemeralInt = 1 } if expiryDate . IsZero ( ) { _ , err = stmt . Exec ( description , architecture , ephemeralInt , "" , id ) } else { _ , err = stmt . Exec ( description , architecture , ephemeralInt , expiryDate , id ) } if err != nil { return err } return nil }
2466	func ( c * Cluster ) ContainerLastUsedUpdate ( id int , date time . Time ) error { stmt := `UPDATE containers SET last_use_date=? WHERE id=?` err := exec ( c . db , stmt , date , id ) return err }
2467	func ( c * Cluster ) ContainerGetSnapshots ( project , name string ) ( [ ] string , error ) { result := [ ] string { } regexp := name + shared . SnapshotDelimiter length := len ( regexp ) q := `SELECT containers.name FROM containers JOIN projects ON projects.id = containers.project_idWHERE projects.name=? AND containers.type=? AND SUBSTR(containers.name,1,?)=?` inargs := [ ] interface { } { project , CTypeSnapshot , length , regexp } outfmt := [ ] interface { } { name } dbResults , err := queryScan ( c . db , q , inargs , outfmt ) if err != nil { return result , err } for _ , r := range dbResults { result = append ( result , r [ 0 ] . ( string ) ) } return result , nil }
2468	func ( c * ClusterTx ) ContainerGetSnapshotsFull ( project string , name string ) ( [ ] Container , error ) { filter := ContainerFilter { Parent : name , Project : project , Type : int ( CTypeSnapshot ) , } return c . ContainerList ( filter ) }
2469	func ( c * Cluster ) ContainerNextSnapshot ( project string , name string , pattern string ) int { base := name + shared . SnapshotDelimiter length := len ( base ) q := `SELECT containers.name FROM containers JOIN projects ON projects.id = containers.project_id WHERE projects.name=? AND containers.type=? AND SUBSTR(containers.name,1,?)=?` var numstr string inargs := [ ] interface { } { project , CTypeSnapshot , length , base } outfmt := [ ] interface { } { numstr } results , err := queryScan ( c . db , q , inargs , outfmt ) if err != nil { return 0 } max := 0 for _ , r := range results { snapOnlyName := strings . SplitN ( r [ 0 ] . ( string ) , shared . SnapshotDelimiter , 2 ) [ 1 ] fields := strings . SplitN ( pattern , "%d" , 2 ) var num int count , err := fmt . Sscanf ( snapOnlyName , fmt . Sprintf ( "%s%%d%s" , fields [ 0 ] , fields [ 1 ] ) , & num ) if err != nil || count != 1 { continue } if num >= max { max = num + 1 } } return max }
2470	func ( c * ClusterTx ) ContainerPool ( project , containerName string ) ( string , error ) { poolName := "" query := `SELECT storage_pools.name FROM storage_pools JOIN storage_volumes ON storage_pools.id=storage_volumes.storage_pool_id JOIN containers ON containers.name=storage_volumes.name JOIN projects ON projects.id=containers.project_id WHERE projects.name=? AND storage_volumes.node_id=? AND storage_volumes.name=? AND storage_volumes.type=?` inargs := [ ] interface { } { project , c . nodeID , containerName , StoragePoolVolumeTypeContainer } outargs := [ ] interface { } { & poolName } err := c . tx . QueryRow ( query , inargs ... ) . Scan ( outargs ... ) if err != nil { if err == sql . ErrNoRows { return "" , ErrNoSuchObject } return "" , err } return poolName , nil }
2471	func ( c * Cluster ) ContainerGetBackup ( project , name string ) ( ContainerBackupArgs , error ) { args := ContainerBackupArgs { } args . Name = name containerOnlyInt := - 1 optimizedStorageInt := - 1 q := `SELECT containers_backups.id, containers_backups.container_id, containers_backups.creation_date, containers_backups.expiry_date, containers_backups.container_only, containers_backups.optimized_storage FROM containers_backups JOIN containers ON containers.id=containers_backups.container_id JOIN projects ON projects.id=containers.project_id WHERE projects.name=? AND containers_backups.name=?` arg1 := [ ] interface { } { project , name } arg2 := [ ] interface { } { & args . ID , & args . ContainerID , & args . CreationDate , & args . ExpiryDate , & containerOnlyInt , & optimizedStorageInt } err := dbQueryRowScan ( c . db , q , arg1 , arg2 ) if err != nil { if err == sql . ErrNoRows { return args , ErrNoSuchObject } return args , err } if containerOnlyInt == 1 { args . ContainerOnly = true } if optimizedStorageInt == 1 { args . OptimizedStorage = true } return args , nil }
2472	func ( c * Cluster ) ContainerGetBackups ( project , name string ) ( [ ] string , error ) { var result [ ] string q := `SELECT containers_backups.name FROM containers_backupsJOIN containers ON containers_backups.container_id=containers.idJOIN projects ON projects.id=containers.project_idWHERE projects.name=? AND containers.name=?` inargs := [ ] interface { } { project , name } outfmt := [ ] interface { } { name } dbResults , err := queryScan ( c . db , q , inargs , outfmt ) if err != nil { return nil , err } for _ , r := range dbResults { result = append ( result , r [ 0 ] . ( string ) ) } return result , nil }
2473	func ( c * Cluster ) ContainerBackupCreate ( args ContainerBackupArgs ) error { _ , err := c . ContainerBackupID ( args . Name ) if err == nil { return ErrAlreadyDefined } err = c . Transaction ( func ( tx * ClusterTx ) error { containerOnlyInt := 0 if args . ContainerOnly { containerOnlyInt = 1 } optimizedStorageInt := 0 if args . OptimizedStorage { optimizedStorageInt = 1 } str := fmt . Sprintf ( "INSERT INTO containers_backups (container_id, name, creation_date, expiry_date, container_only, optimized_storage) VALUES (?, ?, ?, ?, ?, ?)" ) stmt , err := tx . tx . Prepare ( str ) if err != nil { return err } defer stmt . Close ( ) result , err := stmt . Exec ( args . ContainerID , args . Name , args . CreationDate . Unix ( ) , args . ExpiryDate . Unix ( ) , containerOnlyInt , optimizedStorageInt ) if err != nil { return err } _ , err = result . LastInsertId ( ) if err != nil { return fmt . Errorf ( "Error inserting %s into database" , args . Name ) } return nil } ) return err }
2474	func ( c * Cluster ) ContainerBackupRemove ( name string ) error { id , err := c . ContainerBackupID ( name ) if err != nil { return err } err = exec ( c . db , "DELETE FROM containers_backups WHERE id=?" , id ) if err != nil { return err } return nil }
2475	func ( c * Cluster ) ContainerBackupRename ( oldName , newName string ) error { err := c . Transaction ( func ( tx * ClusterTx ) error { str := fmt . Sprintf ( "UPDATE containers_backups SET name = ? WHERE name = ?" ) stmt , err := tx . tx . Prepare ( str ) if err != nil { return err } defer stmt . Close ( ) logger . Debug ( "Calling SQL Query" , log . Ctx { "query" : "UPDATE containers_backups SET name = ? WHERE name = ?" , "oldName" : oldName , "newName" : newName } ) if _ , err := stmt . Exec ( newName , oldName ) ; err != nil { return err } return nil } ) return err }
2476	func ( c * Cluster ) ContainerBackupsGetExpired ( ) ( [ ] string , error ) { var result [ ] string var name string var expiryDate string q := `SELECT containers_backups.name, containers_backups.expiry_date FROM containers_backups` outfmt := [ ] interface { } { name , expiryDate } dbResults , err := queryScan ( c . db , q , nil , outfmt ) if err != nil { return nil , err } for _ , r := range dbResults { timestamp := r [ 1 ] var backupExpiry time . Time err = backupExpiry . UnmarshalText ( [ ] byte ( timestamp . ( string ) ) ) if err != nil { return [ ] string { } , err } if backupExpiry . IsZero ( ) { continue } if time . Now ( ) . Unix ( ) - backupExpiry . Unix ( ) >= 0 { result = append ( result , r [ 0 ] . ( string ) ) } } return result , nil }
2477	func DefaultOS ( ) * OS { newOS := & OS { VarDir : shared . VarPath ( ) , CacheDir : shared . CachePath ( ) , LogDir : shared . LogPath ( ) , } newOS . InotifyWatch . Fd = - 1 newOS . InotifyWatch . Targets = make ( map [ string ] * InotifyTargetInfo ) return newOS }
2478	func ( s * OS ) Init ( ) error { err := s . initDirs ( ) if err != nil { return err } s . Architectures , err = util . GetArchitectures ( ) if err != nil { return err } s . LxcPath = filepath . Join ( s . VarDir , "containers" ) s . BackingFS , err = util . FilesystemDetect ( s . LxcPath ) if err != nil { logger . Error ( "Error detecting backing fs" , log . Ctx { "err" : err } ) } s . IdmapSet = util . GetIdmapSet ( ) s . ExecPath = util . GetExecPath ( ) s . RunningInUserNS = shared . RunningInUserNS ( ) s . initAppArmor ( ) s . initCGroup ( ) return nil }
2479	func ( op * operation ) GetWebsocket ( secret string ) ( * websocket . Conn , error ) { return op . r . GetOperationWebsocket ( op . ID , secret ) }
2480	func ( op * operation ) Refresh ( ) error { newOp , _ , err := op . r . GetOperation ( op . ID ) if err != nil { return err } op . Operation = * newOp return nil }
2481	func ( op * remoteOperation ) CancelTarget ( ) error { if op . targetOp == nil { return fmt . Errorf ( "No associated target operation" ) } return op . targetOp . Cancel ( ) }
2482	func ( op * remoteOperation ) GetTarget ( ) ( * api . Operation , error ) { if op . targetOp == nil { return nil , fmt . Errorf ( "No associated target operation" ) } opAPI := op . targetOp . Get ( ) return & opAPI , nil }
2483	func ( e * Endpoints ) up ( config * Config ) error { e . mu . Lock ( ) defer e . mu . Unlock ( ) e . servers = map [ kind ] * http . Server { devlxd : config . DevLxdServer , local : config . RestServer , network : config . RestServer , cluster : config . RestServer , pprof : pprofCreateServer ( ) , } e . cert = config . Cert e . inherited = map [ kind ] bool { } var err error systemdListeners := util . GetListeners ( e . systemdListenFDsStart ) if len ( systemdListeners ) > 0 { e . listeners = activatedListeners ( systemdListeners , e . cert ) for kind := range e . listeners { e . inherited [ kind ] = true } } else { e . listeners = map [ kind ] net . Listener { } e . listeners [ local ] , err = localCreateListener ( config . UnixSocket , config . LocalUnixSocketGroup ) if err != nil { return fmt . Errorf ( "local endpoint: %v" , err ) } } e . listeners [ devlxd ] , err = createDevLxdlListener ( config . Dir ) if err != nil { return err } if config . NetworkAddress != "" { listener , ok := e . listeners [ network ] if ok { logger . Infof ( "Replacing inherited TCP socket with configured one" ) listener . Close ( ) e . inherited [ network ] = false } e . listeners [ network ] = networkCreateListener ( config . NetworkAddress , e . cert ) isCovered := util . IsAddressCovered ( config . ClusterAddress , config . NetworkAddress ) if config . ClusterAddress != "" && ! isCovered { e . listeners [ cluster ] , err = clusterCreateListener ( config . ClusterAddress , e . cert ) if err != nil { return err } logger . Infof ( "Starting cluster handler:" ) e . serveHTTP ( cluster ) } } if config . DebugAddress != "" { e . listeners [ pprof ] , err = pprofCreateListener ( config . DebugAddress ) if err != nil { return err } logger . Infof ( "Starting pprof handler:" ) e . serveHTTP ( pprof ) } logger . Infof ( "Starting /dev/lxd handler:" ) e . serveHTTP ( devlxd ) logger . Infof ( "REST API daemon:" ) e . serveHTTP ( local ) e . serveHTTP ( network ) return nil }
2484	func ( e * Endpoints ) Down ( ) error { e . mu . Lock ( ) defer e . mu . Unlock ( ) if e . listeners [ network ] != nil || e . listeners [ local ] != nil { logger . Infof ( "Stopping REST API handler:" ) err := e . closeListener ( network ) if err != nil { return err } err = e . closeListener ( local ) if err != nil { return err } } if e . listeners [ cluster ] != nil { logger . Infof ( "Stopping cluster handler:" ) err := e . closeListener ( cluster ) if err != nil { return err } } if e . listeners [ devlxd ] != nil { logger . Infof ( "Stopping /dev/lxd handler:" ) err := e . closeListener ( devlxd ) if err != nil { return err } } if e . listeners [ pprof ] != nil { logger . Infof ( "Stopping pprof handler:" ) err := e . closeListener ( pprof ) if err != nil { return err } } if e . tomb != nil { e . tomb . Kill ( nil ) e . tomb . Wait ( ) } return nil }
2485	func ( e * Endpoints ) serveHTTP ( kind kind ) { listener := e . listeners [ kind ] if listener == nil { return } ctx := log . Ctx { "socket" : listener . Addr ( ) } if e . inherited [ kind ] { ctx [ "inherited" ] = true } message := fmt . Sprintf ( " - binding %s" , descriptions [ kind ] ) logger . Info ( message , ctx ) server := e . servers [ kind ] if e . tomb == nil { e . tomb = & tomb . Tomb { } } e . tomb . Go ( func ( ) error { server . Serve ( listener ) return nil } ) }
2486	func ( e * Endpoints ) closeListener ( kind kind ) error { listener := e . listeners [ kind ] if listener == nil { return nil } delete ( e . listeners , kind ) logger . Info ( " - closing socket" , log . Ctx { "socket" : listener . Addr ( ) } ) return listener . Close ( ) }
2487	func activatedListeners ( systemdListeners [ ] net . Listener , cert * shared . CertInfo ) map [ kind ] net . Listener { listeners := map [ kind ] net . Listener { } for _ , listener := range systemdListeners { var kind kind switch listener . ( type ) { case * net . UnixListener : kind = local case * net . TCPListener : kind = network listener = networkTLSListener ( listener , cert ) default : continue } listeners [ kind ] = listener } return listeners }
2488	func ( c * Config ) CandidServer ( ) ( string , string , int64 , string ) { return c . m . GetString ( "candid.api.url" ) , c . m . GetString ( "candid.api.key" ) , c . m . GetInt64 ( "candid.expiry" ) , c . m . GetString ( "candid.domains" ) }
2489	func ( c * Config ) RBACServer ( ) ( string , string , int64 , string , string , string , string ) { return c . m . GetString ( "rbac.api.url" ) , c . m . GetString ( "rbac.api.key" ) , c . m . GetInt64 ( "rbac.expiry" ) , c . m . GetString ( "rbac.agent.url" ) , c . m . GetString ( "rbac.agent.username" ) , c . m . GetString ( "rbac.agent.private_key" ) , c . m . GetString ( "rbac.agent.public_key" ) }
2490	func ( c * Config ) AutoUpdateInterval ( ) time . Duration { n := c . m . GetInt64 ( "images.auto_update_interval" ) return time . Duration ( n ) * time . Hour }
2491	func ( c * Config ) MAASController ( ) ( string , string ) { url := c . m . GetString ( "maas.api.url" ) key := c . m . GetString ( "maas.api.key" ) return url , key }
2492	func ( c * Config ) OfflineThreshold ( ) time . Duration { n := c . m . GetInt64 ( "cluster.offline_threshold" ) return time . Duration ( n ) * time . Second }
2493	func ConfigGetString ( cluster * db . Cluster , key string ) ( string , error ) { config , err := configGet ( cluster ) if err != nil { return "" , err } return config . m . GetString ( key ) , nil }
2494	func ConfigGetBool ( cluster * db . Cluster , key string ) ( bool , error ) { config , err := configGet ( cluster ) if err != nil { return false , err } return config . m . GetBool ( key ) , nil }
2495	func ConfigGetInt64 ( cluster * db . Cluster , key string ) ( int64 , error ) { config , err := configGet ( cluster ) if err != nil { return 0 , err } return config . m . GetInt64 ( key ) , nil }
2496	func ( e * Endpoints ) ClusterAddress ( ) string { e . mu . RLock ( ) defer e . mu . RUnlock ( ) listener := e . listeners [ cluster ] if listener == nil { return "" } return listener . Addr ( ) . String ( ) }
2497	func Debug ( msg string , ctx ... interface { } ) { if Log != nil { pc , fn , line , _ := runtime . Caller ( 1 ) msg := fmt . Sprintf ( "%s: %d: %s: %s" , fn , line , runtime . FuncForPC ( pc ) . Name ( ) , msg ) Log . Debug ( msg , ctx ... ) } }
2498	func RestServer ( d * Daemon ) * http . Server { mux := mux . NewRouter ( ) mux . StrictSlash ( false ) mux . HandleFunc ( "/" , func ( w http . ResponseWriter , r * http . Request ) { w . Header ( ) . Set ( "Content-Type" , "application/json" ) SyncResponse ( true , [ ] string { "/1.0" } ) . Render ( w ) } ) for endpoint , f := range d . gateway . HandlerFuncs ( ) { mux . HandleFunc ( endpoint , f ) } for _ , c := range api10 { d . createCmd ( mux , "1.0" , c ) } for _ , c := range apiInternal { d . createCmd ( mux , "internal" , c ) } mux . NotFoundHandler = http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { logger . Info ( "Sending top level 404" , log . Ctx { "url" : r . URL } ) w . Header ( ) . Set ( "Content-Type" , "application/json" ) NotFound ( nil ) . Render ( w ) } ) return & http . Server { Handler : & lxdHttpServer { r : mux , d : d } } }
2499	func projectParam ( request * http . Request ) string { project := queryParam ( request , "project" ) if project == "" { project = "default" } return project }
2500	func queryParam ( request * http . Request , key string ) string { var values url . Values var err error if request . URL != nil { values , err = url . ParseQuery ( request . URL . RawQuery ) if err != nil { logger . Warnf ( "Failed to parse query string %q: %v" , request . URL . RawQuery , err ) return "" } } if values == nil { values = make ( url . Values ) } return values . Get ( key ) }
2501	func newDb ( ) * cobra . Command { cmd := & cobra . Command { Use : "db [sub-command]" , Short : "Database-related code generation." , RunE : func ( cmd * cobra . Command , args [ ] string ) error { return fmt . Errorf ( "Not implemented" ) } , } cmd . AddCommand ( newDbSchema ( ) ) cmd . AddCommand ( newDbMapper ( ) ) return cmd }
2502	func ( t OperationType ) Description ( ) string { switch t { case OperationClusterBootstrap : return "Creating bootstrap node" case OperationClusterJoin : return "Joining cluster" case OperationBackupCreate : return "Backing up container" case OperationBackupRename : return "Renaming container backup" case OperationBackupRestore : return "Restoring backup" case OperationBackupRemove : return "Removing container backup" case OperationConsoleShow : return "Showing console" case OperationContainerCreate : return "Creating container" case OperationContainerUpdate : return "Updating container" case OperationContainerRename : return "Renaming container" case OperationContainerMigrate : return "Migrating container" case OperationContainerLiveMigrate : return "Live-migrating container" case OperationContainerFreeze : return "Freezing container" case OperationContainerUnfreeze : return "Unfreezing container" case OperationContainerDelete : return "Deleting container" case OperationContainerStart : return "Starting container" case OperationContainerStop : return "Stopping container" case OperationContainerRestart : return "Restarting container" case OperationCommandExec : return "Executing command" case OperationSnapshotCreate : return "Snapshotting container" case OperationSnapshotRename : return "Renaming snapshot" case OperationSnapshotRestore : return "Restoring snapshot" case OperationSnapshotTransfer : return "Transferring snapshot" case OperationSnapshotUpdate : return "Updating snapshot" case OperationSnapshotDelete : return "Deleting snapshot" case OperationImageDownload : return "Downloading image" case OperationImageDelete : return "Deleting image" case OperationImageToken : return "Image download token" case OperationImageRefresh : return "Refreshing image" case OperationVolumeCopy : return "Copying storage volume" case OperationVolumeCreate : return "Creating storage volume" case OperationVolumeMigrate : return "Migrating storage volume" case OperationVolumeMove : return "Moving storage volume" case OperationVolumeSnapshotCreate : return "Creating storage volume snapshot" case OperationVolumeSnapshotDelete : return "Deleting storage volume snapshot" case OperationVolumeSnapshotUpdate : return "Updating storage volume snapshot" case OperationProjectRename : return "Renaming project" case OperationImagesExpire : return "Cleaning up expired images" case OperationImagesPruneLeftover : return "Pruning leftover image files" case OperationImagesUpdate : return "Updating images" case OperationImagesSynchronize : return "Synchronizing images" case OperationLogsExpire : return "Expiring log files" case OperationInstanceTypesUpdate : return "Updating instance types" case OperationBackupsExpire : return "Cleaning up expired backups" case OperationSnapshotsExpire : return "Cleaning up expired snapshots" default : return "Executing operation" } }
2503	func ( t OperationType ) Permission ( ) string { switch t { case OperationBackupCreate : return "operate-containers" case OperationBackupRename : return "operate-containers" case OperationBackupRestore : return "operate-containers" case OperationBackupRemove : return "operate-containers" case OperationConsoleShow : return "operate-containers" case OperationContainerFreeze : return "operate-containers" case OperationContainerUnfreeze : return "operate-containers" case OperationContainerStart : return "operate-containers" case OperationContainerStop : return "operate-containers" case OperationContainerRestart : return "operate-containers" case OperationCommandExec : return "operate-containers" case OperationSnapshotCreate : return "operate-containers" case OperationSnapshotRename : return "operate-containers" case OperationSnapshotTransfer : return "operate-containers" case OperationSnapshotUpdate : return "operate-containers" case OperationSnapshotDelete : return "operate-containers" case OperationContainerCreate : return "manage-containers" case OperationContainerUpdate : return "manage-containers" case OperationContainerRename : return "manage-containers" case OperationContainerMigrate : return "manage-containers" case OperationContainerLiveMigrate : return "manage-containers" case OperationContainerDelete : return "manage-containers" case OperationSnapshotRestore : return "manage-containers" case OperationImageDownload : return "manage-images" case OperationImageDelete : return "manage-images" case OperationImageToken : return "manage-images" case OperationImageRefresh : return "manage-images" case OperationImagesUpdate : return "manage-images" case OperationImagesSynchronize : return "manage-images" } return "" }
2504	func ( c * ClusterTx ) OperationsUUIDs ( ) ( [ ] string , error ) { stmt := "SELECT uuid FROM operations WHERE node_id=?" return query . SelectStrings ( c . tx , stmt , c . nodeID ) }
2505	func ( c * ClusterTx ) OperationNodes ( project string ) ( [ ] string , error ) { stmt := `SELECT DISTINCT nodes.address FROM operations LEFT OUTER JOIN projects ON projects.id = operations.project_id JOIN nodes ON nodes.id = operations.node_id WHERE projects.name = ? OR operations.project_id IS NULL` return query . SelectStrings ( c . tx , stmt , project ) }
2506	func ( c * ClusterTx ) OperationByUUID ( uuid string ) ( Operation , error ) { null := Operation { } operations , err := c . operations ( "uuid=?" , uuid ) if err != nil { return null , err } switch len ( operations ) { case 0 : return null , ErrNoSuchObject case 1 : return operations [ 0 ] , nil default : return null , fmt . Errorf ( "more than one node matches" ) } }
2507	func ( c * ClusterTx ) OperationAdd ( project , uuid string , typ OperationType ) ( int64 , error ) { var projectID interface { } if project != "" { var err error projectID , err = c . ProjectID ( project ) if err != nil { return - 1 , errors . Wrap ( err , "Fetch project ID" ) } } else { projectID = nil } columns := [ ] string { "uuid" , "node_id" , "type" , "project_id" } values := [ ] interface { } { uuid , c . nodeID , typ , projectID } return query . UpsertObject ( c . tx , "operations" , columns , values ) }
2508	func ( c * ClusterTx ) OperationRemove ( uuid string ) error { result , err := c . tx . Exec ( "DELETE FROM operations WHERE uuid=?" , uuid ) if err != nil { return err } n , err := result . RowsAffected ( ) if err != nil { return err } if n != 1 { return fmt . Errorf ( "query deleted %d rows instead of 1" , n ) } return nil }
2509	func ( c * ClusterTx ) operations ( where string , args ... interface { } ) ( [ ] Operation , error ) { operations := [ ] Operation { } dest := func ( i int ) [ ] interface { } { operations = append ( operations , Operation { } ) return [ ] interface { } { & operations [ i ] . ID , & operations [ i ] . UUID , & operations [ i ] . NodeAddress , & operations [ i ] . Type , } } sql := `SELECT operations.id, uuid, nodes.address, type FROM operations JOIN nodes ON nodes.id = node_id ` if where != "" { sql += fmt . Sprintf ( "WHERE %s " , where ) } sql += "ORDER BY operations.id" stmt , err := c . tx . Prepare ( sql ) if err != nil { return nil , err } defer stmt . Close ( ) err = query . SelectObjects ( stmt , dest , args ... ) if err != nil { return nil , errors . Wrap ( err , "Failed to fetch operations" ) } return operations , nil }
2510	func expireLogsTask ( state * state . State ) ( task . Func , task . Schedule ) { f := func ( ctx context . Context ) { opRun := func ( op * operation ) error { return expireLogs ( ctx , state ) } op , err := operationCreate ( state . Cluster , "" , operationClassTask , db . OperationLogsExpire , nil , nil , opRun , nil , nil ) if err != nil { logger . Error ( "Failed to start log expiry operation" , log . Ctx { "err" : err } ) return } logger . Infof ( "Expiring log files" ) _ , err = op . Run ( ) if err != nil { logger . Error ( "Failed to expire logs" , log . Ctx { "err" : err } ) } logger . Infof ( "Done expiring log files" ) } return f , task . Daily ( ) }
2511	func absPath ( path string ) string { _ , filename , _ , _ := runtime . Caller ( 1 ) elems := strings . Split ( filename , string ( filepath . Separator ) ) for i := len ( elems ) - 1 ; i >= 0 ; i -- { if elems [ i ] == "lxd" { elems = append ( [ ] string { string ( filepath . Separator ) } , elems [ : i ] ... ) elems = append ( elems , path ) return filepath . Join ( elems ... ) } } log . Fatalf ( "Could not found root dir of LXD tree source tree" ) return "" }
2512	func ( s Schema ) Keys ( ) [ ] string { keys := make ( [ ] string , len ( s ) ) i := 0 for key := range s { keys [ i ] = key i ++ } sort . Strings ( keys ) return keys }
2513	func ( s Schema ) Defaults ( ) map [ string ] interface { } { values := make ( map [ string ] interface { } , len ( s ) ) for name , key := range s { values [ name ] = key . Default } return values }
2514	func ( s Schema ) mustGetKey ( name string ) Key { key , ok := s [ name ] if ! ok { panic ( fmt . Sprintf ( "attempt to access unknown key '%s'" , name ) ) } return key }
2515	func ( s Schema ) assertKeyType ( name string , code Type ) { key := s . mustGetKey ( name ) if key . Type != code { panic ( fmt . Sprintf ( "key '%s' has type code %d, not %d" , name , key . Type , code ) ) } }
2516	func ( v * Key ) validate ( value string ) error { validator := v . Validator if validator == nil { validator = func ( string ) error { return nil } } if value == "" { return validator ( v . Default ) } switch v . Type { case String : case Bool : if ! shared . StringInSlice ( strings . ToLower ( value ) , booleans ) { return fmt . Errorf ( "invalid boolean" ) } case Int64 : _ , err := strconv . ParseInt ( value , 10 , 64 ) if err != nil { return fmt . Errorf ( "invalid integer" ) } default : panic ( fmt . Sprintf ( "unexpected value type: %d" , v . Type ) ) } if v . Deprecated != "" && value != v . Default { return fmt . Errorf ( "deprecated: %s" , v . Deprecated ) } return validator ( value ) }
2517	func ( r * ProtocolLXD ) GetStoragePoolVolumes ( pool string ) ( [ ] api . StorageVolume , error ) { if ! r . HasExtension ( "storage" ) { return nil , fmt . Errorf ( "The server is missing the required \"storage\" API extension" ) } \" \" volumes := [ ] api . StorageVolume { } _ , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/storage-pools/%s/volumes?recursion=1" , url . QueryEscape ( pool ) ) , nil , "" , & volumes ) }
2518	func ( r * ProtocolLXD ) GetStoragePoolVolume ( pool string , volType string , name string ) ( * api . StorageVolume , string , error ) { if ! r . HasExtension ( "storage" ) { return nil , "" , fmt . Errorf ( "The server is missing the required \"storage\" API extension" ) } \" \" volume := api . StorageVolume { } path := fmt . Sprintf ( "/storage-pools/%s/volumes/%s/%s" , url . QueryEscape ( pool ) , url . QueryEscape ( volType ) , url . QueryEscape ( name ) ) etag , err := r . queryStruct ( "GET" , path , nil , "" , & volume ) }
2519	func ( r * ProtocolLXD ) CreateStoragePoolVolume ( pool string , volume api . StorageVolumesPost ) error { if ! r . HasExtension ( "storage" ) { return fmt . Errorf ( "The server is missing the required \"storage\" API extension" ) } \" \" path := fmt . Sprintf ( "/storage-pools/%s/volumes/%s" , url . QueryEscape ( pool ) , url . QueryEscape ( volume . Type ) ) _ , _ , err := r . query ( "POST" , path , volume , "" ) }
2520	func ( r * ProtocolLXD ) CreateStoragePoolVolumeSnapshot ( pool string , volumeType string , volumeName string , snapshot api . StorageVolumeSnapshotsPost ) ( Operation , error ) { if ! r . HasExtension ( "storage_api_volume_snapshots" ) { return nil , fmt . Errorf ( "The server is missing the required \"storage_api_volume_snapshots\" API extension" ) } \" \" path := fmt . Sprintf ( "/storage-pools/%s/volumes/%s/%s/snapshots" , url . QueryEscape ( pool ) , url . QueryEscape ( volumeType ) , url . QueryEscape ( volumeName ) ) op , _ , err := r . queryOperation ( "POST" , path , snapshot , "" ) }
2521	func ( r * ProtocolLXD ) GetStoragePoolVolumeSnapshots ( pool string , volumeType string , volumeName string ) ( [ ] api . StorageVolumeSnapshot , error ) { if ! r . HasExtension ( "storage_api_volume_snapshots" ) { return nil , fmt . Errorf ( "The server is missing the required \"storage_api_volume_snapshots\" API extension" ) } \" \" snapshots := [ ] api . StorageVolumeSnapshot { } path := fmt . Sprintf ( "/storage-pools/%s/volumes/%s/%s/snapshots?recursion=1" , url . QueryEscape ( pool ) , url . QueryEscape ( volumeType ) , url . QueryEscape ( volumeName ) ) _ , err := r . queryStruct ( "GET" , path , nil , "" , & snapshots ) }
2522	func ( r * ProtocolLXD ) GetStoragePoolVolumeSnapshot ( pool string , volumeType string , volumeName string , snapshotName string ) ( * api . StorageVolumeSnapshot , string , error ) { if ! r . HasExtension ( "storage_api_volume_snapshots" ) { return nil , "" , fmt . Errorf ( "The server is missing the required \"storage_api_volume_snapshots\" API extension" ) } \" \" snapshot := api . StorageVolumeSnapshot { } path := fmt . Sprintf ( "/storage-pools/%s/volumes/%s/%s/snapshots/%s" , url . QueryEscape ( pool ) , url . QueryEscape ( volumeType ) , url . QueryEscape ( volumeName ) , url . QueryEscape ( snapshotName ) ) etag , err := r . queryStruct ( "GET" , path , nil , "" , & snapshot ) }
2523	func ( r * ProtocolLXD ) UpdateStoragePoolVolumeSnapshot ( pool string , volumeType string , volumeName string , snapshotName string , volume api . StorageVolumeSnapshotPut , ETag string ) error { if ! r . HasExtension ( "storage_api_volume_snapshots" ) { return fmt . Errorf ( "The server is missing the required \"storage_api_volume_snapshots\" API extension" ) } \" \" path := fmt . Sprintf ( "/storage-pools/%s/volumes/%s/%s/snapshots/%s" , url . QueryEscape ( pool ) , url . QueryEscape ( volumeType ) , url . QueryEscape ( volumeName ) , url . QueryEscape ( snapshotName ) ) _ , _ , err := r . queryOperation ( "PUT" , path , volume , ETag ) }
2524	func ( r * ProtocolLXD ) MigrateStoragePoolVolume ( pool string , volume api . StorageVolumePost ) ( Operation , error ) { if ! r . HasExtension ( "storage_api_remote_volume_handling" ) { return nil , fmt . Errorf ( "The server is missing the required \"storage_api_remote_volume_handling\" API extension" ) } \" \" if ! volume . Migration { return nil , fmt . Errorf ( "Can't ask for a rename through MigrateStoragePoolVolume" ) } path := fmt . Sprintf ( "/storage-pools/%s/volumes/custom/%s" , url . QueryEscape ( pool ) , volume . Name ) op , _ , err := r . queryOperation ( "POST" , path , volume , "" ) }
2525	func ( r * ProtocolLXD ) MoveStoragePoolVolume ( pool string , source ContainerServer , sourcePool string , volume api . StorageVolume , args * StoragePoolVolumeMoveArgs ) ( RemoteOperation , error ) { if ! r . HasExtension ( "storage_api_local_volume_handling" ) { return nil , fmt . Errorf ( "The server is missing the required \"storage_api_local_volume_handling\" API extension" ) } \" \" if r != source { return nil , fmt . Errorf ( "Moving storage volumes between remotes is not implemented" ) } req := api . StorageVolumePost { Name : args . Name , Pool : pool , } op , _ , err := r . queryOperation ( "POST" , fmt . Sprintf ( "/storage-pools/%s/volumes/%s/%s" , url . QueryEscape ( sourcePool ) , url . QueryEscape ( volume . Type ) , volume . Name ) , req , "" ) if err != nil { return nil , err } rop := remoteOperation { targetOp : op , chDone : make ( chan bool ) , } }
2526	func ( r * ProtocolLXD ) UpdateStoragePoolVolume ( pool string , volType string , name string , volume api . StorageVolumePut , ETag string ) error { if ! r . HasExtension ( "storage" ) { return fmt . Errorf ( "The server is missing the required \"storage\" API extension" ) } \" \" if volume . Restore != "" && ! r . HasExtension ( "storage_api_volume_snapshots" ) { return fmt . Errorf ( "The server is missing the required \"storage_api_volume_snapshots\" API extension" ) } \" \" }
2527	func ( r * ProtocolLXD ) DeleteStoragePoolVolume ( pool string , volType string , name string ) error { if ! r . HasExtension ( "storage" ) { return fmt . Errorf ( "The server is missing the required \"storage\" API extension" ) } \" \" path := fmt . Sprintf ( "/storage-pools/%s/volumes/%s/%s" , url . QueryEscape ( pool ) , url . QueryEscape ( volType ) , url . QueryEscape ( name ) ) _ , _ , err := r . query ( "DELETE" , path , nil , "" ) }
2528	func ( r * ProtocolLXD ) RenameStoragePoolVolume ( pool string , volType string , name string , volume api . StorageVolumePost ) error { if ! r . HasExtension ( "storage_api_volume_rename" ) { return fmt . Errorf ( "The server is missing the required \"storage_api_volume_rename\" API extension" ) } \" \" path := fmt . Sprintf ( "/storage-pools/%s/volumes/%s/%s" , url . QueryEscape ( pool ) , url . QueryEscape ( volType ) , url . QueryEscape ( name ) ) _ , _ , err := r . query ( "POST" , path , volume , "" ) }
2529	func doStoragePoolCreateInternal ( state * state . State , poolName , poolDescription string , driver string , config map [ string ] string , isNotification bool ) error { tryUndo := true s , err := storagePoolInit ( state , poolName ) if err != nil { return err } if s , ok := s . ( * storageCeph ) ; ok && isNotification { volumeMntPoint := getStoragePoolVolumeMountPoint ( s . pool . Name , s . volume . Name ) return os . MkdirAll ( volumeMntPoint , 0711 ) } err = s . StoragePoolCreate ( ) if err != nil { return err } defer func ( ) { if ! tryUndo { return } s . StoragePoolDelete ( ) } ( ) postCreateConfig := s . GetStoragePoolWritable ( ) . Config configDiff , _ := storageConfigDiff ( config , postCreateConfig ) if len ( configDiff ) > 0 { err = state . Cluster . StoragePoolUpdate ( poolName , poolDescription , postCreateConfig ) if err != nil { return fmt . Errorf ( "Error inserting %s into database: %s" , poolName , err ) } } tryUndo = false return nil }
2530	func containerGetParentAndSnapshotName ( name string ) ( string , string , bool ) { fields := strings . SplitN ( name , shared . SnapshotDelimiter , 2 ) if len ( fields ) == 1 { return name , "" , false } return fields [ 0 ] , fields [ 1 ] , true }
2531	func containerLoadFromAllProjects ( s * state . State ) ( [ ] container , error ) { var projects [ ] string err := s . Cluster . Transaction ( func ( tx * db . ClusterTx ) error { var err error projects , err = tx . ProjectNames ( ) return err } ) if err != nil { return nil , err } containers := [ ] container { } for _ , project := range projects { projectContainers , err := containerLoadByProject ( s , project ) if err != nil { return nil , errors . Wrapf ( nil , "Load containers in project %s" , project ) } containers = append ( containers , projectContainers ... ) } return containers , nil }
2532	func containerLoadNodeAll ( s * state . State ) ( [ ] container , error ) { var cts [ ] db . Container err := s . Cluster . Transaction ( func ( tx * db . ClusterTx ) error { var err error cts , err = tx . ContainerNodeList ( ) if err != nil { return err } return nil } ) if err != nil { return nil , err } return containerLoadAllInternal ( cts , s ) }
2533	func containerLoadNodeProjectAll ( s * state . State , project string ) ( [ ] container , error ) { var cts [ ] db . Container err := s . Cluster . Transaction ( func ( tx * db . ClusterTx ) error { var err error cts , err = tx . ContainerNodeProjectList ( project ) if err != nil { return err } return nil } ) if err != nil { return nil , err } return containerLoadAllInternal ( cts , s ) }
2534	func heartbeatNode ( taskCtx context . Context , address string , cert * shared . CertInfo , raftNodes [ ] db . RaftNode ) error { logger . Debugf ( "Sending heartbeat request to %s" , address ) config , err := tlsClientConfig ( cert ) if err != nil { return err } url := fmt . Sprintf ( "https://%s%s" , address , databaseEndpoint ) client := & http . Client { Transport : & http . Transport { TLSClientConfig : config } } buffer := bytes . Buffer { } err = json . NewEncoder ( & buffer ) . Encode ( raftNodes ) if err != nil { return err } request , err := http . NewRequest ( "PUT" , url , bytes . NewReader ( buffer . Bytes ( ) ) ) if err != nil { return err } ctx , cancel := context . WithTimeout ( context . Background ( ) , 2 * time . Second ) defer cancel ( ) request = request . WithContext ( ctx ) request . Close = true errCh := make ( chan error ) go func ( ) { response , err := client . Do ( request ) if err != nil { errCh <- errors . Wrap ( err , "failed to send HTTP request" ) return } defer response . Body . Close ( ) if response . StatusCode != http . StatusOK { errCh <- fmt . Errorf ( "HTTP request failed: %s" , response . Status ) return } errCh <- nil } ( ) select { case err := <- errCh : return err case <- taskCtx . Done ( ) : return taskCtx . Err ( ) } }
2535	func ( c * cmdList ) dotPrefixMatch ( short string , full string ) bool { fullMembs := strings . Split ( full , "." ) shortMembs := strings . Split ( short , "." ) if len ( fullMembs ) != len ( shortMembs ) { return false } for i := range fullMembs { if ! strings . HasPrefix ( fullMembs [ i ] , shortMembs [ i ] ) { return false } } return true }
2536	func ( s * storageZfs ) ContainerMount ( c container ) ( bool , error ) { return s . doContainerMount ( c . Project ( ) , c . Name ( ) , c . IsPrivileged ( ) ) }
2537	func ( s * storageZfs ) ContainerStorageReady ( container container ) bool { volumeName := projectPrefix ( container . Project ( ) , container . Name ( ) ) fs := fmt . Sprintf ( "containers/%s" , volumeName ) return zfsFilesystemEntityExists ( s . getOnDiskPoolName ( ) , fs ) }
2538	func AskChoice ( question string , choices [ ] string , defaultAnswer string ) string { for { answer := askQuestion ( question , defaultAnswer ) if shared . StringInSlice ( answer , choices ) { return answer } invalidInput ( ) } }
2539	func AskInt ( question string , min int64 , max int64 , defaultAnswer string ) int64 { for { answer := askQuestion ( question , defaultAnswer ) result , err := strconv . ParseInt ( answer , 10 , 64 ) if err == nil && ( min == - 1 || result >= min ) && ( max == - 1 || result <= max ) { return result } invalidInput ( ) } }
2540	func AskString ( question string , defaultAnswer string , validate func ( string ) error ) string { for { answer := askQuestion ( question , defaultAnswer ) if validate != nil { error := validate ( answer ) if error != nil { fmt . Fprintf ( os . Stderr , "Invalid input: %s\n\n" , \n ) \n } error } continue return answer } }
2541	func AskPassword ( question string ) string { for { fmt . Printf ( question ) pwd , _ := terminal . ReadPassword ( 0 ) fmt . Println ( "" ) inFirst := string ( pwd ) inFirst = strings . TrimSuffix ( inFirst , "\n" ) \n fmt . Printf ( "Again: " ) pwd , _ = terminal . ReadPassword ( 0 ) fmt . Println ( "" ) inSecond := string ( pwd ) inSecond = strings . TrimSuffix ( inSecond , "\n" ) \n } }
2542	func AskPasswordOnce ( question string ) string { fmt . Printf ( question ) pwd , _ := terminal . ReadPassword ( 0 ) fmt . Println ( "" ) return string ( pwd ) }
2543	func askQuestion ( question , defaultAnswer string ) string { fmt . Printf ( question ) return readAnswer ( defaultAnswer ) }
2544	func readAnswer ( defaultAnswer string ) string { answer , _ := stdin . ReadString ( '\n' ) answer = strings . TrimSuffix ( answer , "\n" ) \n answer = strings . TrimSpace ( answer ) if answer == "" { answer = defaultAnswer } }
2545	func profilePost ( d * Daemon , r * http . Request ) Response { project := projectParam ( r ) name := mux . Vars ( r ) [ "name" ] if name == "default" { return Forbidden ( errors . New ( "The 'default' profile cannot be renamed" ) ) } req := api . ProfilePost { } if err := json . NewDecoder ( r . Body ) . Decode ( & req ) ; err != nil { return BadRequest ( err ) } if req . Name == "" { return BadRequest ( fmt . Errorf ( "No name provided" ) ) } if strings . Contains ( req . Name , "/" ) { return BadRequest ( fmt . Errorf ( "Profile names may not contain slashes" ) ) } if shared . StringInSlice ( req . Name , [ ] string { "." , ".." } ) { return BadRequest ( fmt . Errorf ( "Invalid profile name '%s'" , req . Name ) ) } err := d . cluster . Transaction ( func ( tx * db . ClusterTx ) error { hasProfiles , err := tx . ProjectHasProfiles ( project ) if err != nil { return errors . Wrap ( err , "Check project features" ) } if ! hasProfiles { project = "default" } _ , err = tx . ProfileGet ( project , req . Name ) if err == nil { return fmt . Errorf ( "Name '%s' already in use" , req . Name ) } return tx . ProfileRename ( project , name , req . Name ) } ) if err != nil { return SmartError ( err ) } return SyncResponseLocation ( true , nil , fmt . Sprintf ( "/%s/profiles/%s" , version . APIVersion , req . Name ) ) }
2546	func profileDelete ( d * Daemon , r * http . Request ) Response { project := projectParam ( r ) name := mux . Vars ( r ) [ "name" ] if name == "default" { return Forbidden ( errors . New ( "The 'default' profile cannot be deleted" ) ) } err := d . cluster . Transaction ( func ( tx * db . ClusterTx ) error { hasProfiles , err := tx . ProjectHasProfiles ( project ) if err != nil { return errors . Wrap ( err , "Check project features" ) } if ! hasProfiles { project = "default" } profile , err := tx . ProfileGet ( project , name ) if err != nil { return err } if len ( profile . UsedBy ) > 0 { return fmt . Errorf ( "Profile is currently in use" ) } return tx . ProfileDelete ( project , name ) } ) if err != nil { return SmartError ( err ) } return EmptySyncResponse }
2547	func IsRootDiskDevice ( device map [ string ] string ) bool { if device [ "type" ] == "disk" && device [ "path" ] == "/" && device [ "source" ] == "" { return true } return false }
2548	func GetRootDiskDevice ( devices map [ string ] map [ string ] string ) ( string , map [ string ] string , error ) { var devName string var dev map [ string ] string for n , d := range devices { if IsRootDiskDevice ( d ) { if devName != "" { return "" , nil , fmt . Errorf ( "More than one root device found" ) } devName = n dev = d } } if devName != "" { return devName , dev , nil } return "" , nil , fmt . Errorf ( "No root device could be found" ) }
2549	func ForwardedResponse ( client lxd . ContainerServer , request * http . Request ) Response { return & forwardedResponse { client : client , request : request , } }
2550	func ForwardedResponseIfTargetIsRemote ( d * Daemon , request * http . Request ) Response { targetNode := queryParam ( request , "target" ) if targetNode == "" { return nil } address , err := cluster . ResolveTarget ( d . cluster , targetNode ) if err != nil { return SmartError ( err ) } if address != "" { cert := d . endpoints . NetworkCert ( ) client , err := cluster . Connect ( address , cert , false ) if err != nil { return SmartError ( err ) } return ForwardedResponse ( client , request ) } return nil }
2551	func ForwardedResponseIfContainerIsRemote ( d * Daemon , r * http . Request , project , name string ) ( Response , error ) { cert := d . endpoints . NetworkCert ( ) client , err := cluster . ConnectIfContainerIsRemote ( d . cluster , project , name , cert ) if err != nil { return nil , err } if client == nil { return nil , nil } return ForwardedResponse ( client , r ) , nil }
2552	func ForwardedOperationResponse ( project string , op * api . Operation ) Response { return & forwardedOperationResponse { op : op , project : project , } }
2553	func ( p * ProgressRenderer ) Done ( msg string ) { p . lock . Lock ( ) defer p . lock . Unlock ( ) if p . done { return } p . done = true if p . Quiet { msg = "" } msg = p . truncate ( msg ) if msg == "" && p . maxLength == 0 { return } if msg != "" { msg += "\n" } \n if len ( msg ) > p . maxLength { p . maxLength = len ( msg ) } else { fmt . Printf ( "\r%s" , \r ) } strings . Repeat ( " " , p . maxLength ) }
2554	func ( p * ProgressRenderer ) Update ( status string ) { timeout := p . wait . Sub ( time . Now ( ) ) if timeout . Seconds ( ) > 0 { time . Sleep ( timeout ) } p . lock . Lock ( ) defer p . lock . Unlock ( ) if p . done { return } if p . Quiet { return } if p . terminal == 0 { if ! termios . IsTerminal ( int ( os . Stdout . Fd ( ) ) ) { p . terminal = - 1 } p . terminal = 1 } if p . terminal != 1 { return } msg := "%s" if p . Format != "" { msg = p . Format } msg = fmt . Sprintf ( msg , status ) msg = "\r" + \r p . truncate ( msg ) if len ( msg ) == 1 && p . maxLength == 0 { return } if len ( msg ) > p . maxLength { p . maxLength = len ( msg ) } else { fmt . Printf ( "\r%s" , \r ) } }
2555	func ( p * ProgressRenderer ) Warn ( status string , timeout time . Duration ) { p . lock . Lock ( ) defer p . lock . Unlock ( ) if p . done { return } p . wait = time . Now ( ) . Add ( timeout ) msg := fmt . Sprintf ( "%s" , status ) msg = "\r" + \r p . truncate ( msg ) if len ( msg ) == 1 && p . maxLength == 0 { return } if len ( msg ) > p . maxLength { p . maxLength = len ( msg ) } else { fmt . Printf ( "\r%s" , \r ) } }
2556	func ( p * ProgressRenderer ) UpdateProgress ( progress ioprogress . ProgressData ) { p . Update ( progress . Text ) }
2557	func ( p * ProgressRenderer ) UpdateOp ( op api . Operation ) { if op . Metadata == nil { return } for key , value := range op . Metadata { if ! strings . HasSuffix ( key , "_progress" ) { continue } p . Update ( value . ( string ) ) break } }
2558	func updateFromV6 ( tx * sql . Tx ) error { nodeIDs , err := query . SelectIntegers ( tx , "SELECT id FROM nodes" ) if err != nil { return errors . Wrap ( err , "failed to get IDs of current nodes" ) } poolIDs , err := query . SelectIntegers ( tx , `SELECT id FROM storage_pools WHERE driver='zfs'` ) if err != nil { return errors . Wrap ( err , "failed to get IDs of current zfs pools" ) } for _ , poolID := range poolIDs { config , err := query . SelectConfig ( tx , "storage_pools_config" , "storage_pool_id=? AND node_id IS NULL" , poolID ) if err != nil { return errors . Wrap ( err , "failed to fetch of zfs pool config" ) } poolName , ok := config [ "zfs.pool_name" ] if ! ok { continue } _ , err = tx . Exec ( `DELETE FROM storage_pools_config WHERE key='zfs.pool_name' AND storage_pool_id=? AND node_id IS NULL` , poolID ) if err != nil { return errors . Wrap ( err , "failed to delete zfs.pool_name config" ) } for _ , nodeID := range nodeIDs { _ , err := tx . Exec ( `INSERT INTO storage_pools_config(storage_pool_id, node_id, key, value) VALUES(?, ?, 'zfs.pool_name', ?)` , poolID , nodeID , poolName ) if err != nil { return errors . Wrap ( err , "failed to create zfs.pool_name node config" ) } } } return nil }
2559	func localCreateListener ( path string , group string ) ( net . Listener , error ) { err := CheckAlreadyRunning ( path ) if err != nil { return nil , err } err = socketUnixRemoveStale ( path ) if err != nil { return nil , err } listener , err := socketUnixListen ( path ) if err != nil { return nil , err } err = localSetAccess ( path , group ) if err != nil { listener . Close ( ) return nil , err } return listener , nil }
2560	func NewStmt ( database , pkg , entity , kind string , config map [ string ] string ) ( * Stmt , error ) { packages , err := Packages ( ) if err != nil { return nil , err } stmt := & Stmt { db : database , pkg : pkg , entity : entity , kind : kind , config : config , packages : packages , } return stmt , nil }
2561	func ( s * Stmt ) Generate ( buf * file . Buffer ) error { if strings . HasPrefix ( s . kind , "objects" ) { return s . objects ( buf ) } if strings . HasPrefix ( s . kind , "create" ) && strings . HasSuffix ( s . kind , "-ref" ) { return s . createRef ( buf ) } if strings . HasSuffix ( s . kind , "-ref" ) || strings . Contains ( s . kind , "-ref-by-" ) { return s . ref ( buf ) } if strings . HasPrefix ( s . kind , "names" ) { return s . names ( buf ) } switch s . kind { case "create" : return s . create ( buf ) case "id" : return s . id ( buf ) case "rename" : return s . rename ( buf ) case "update" : return s . update ( buf ) case "delete" : return s . delete ( buf ) default : return fmt . Errorf ( "Unknown statement '%s'" , s . kind ) } }
2562	func ( s * Stmt ) register ( buf * file . Buffer , sql string , filters ... string ) { kind := strings . Replace ( s . kind , "-" , "_" , - 1 ) if kind == "id" { kind = "ID" } buf . L ( "var %s = %s.RegisterStmt(`\n%s\n`)" , \n , \n , stmtCodeVar ( s . entity , kind , filters ... ) ) }
2563	func httpsLXD ( url string , args * ConnectionArgs ) ( ContainerServer , error ) { if args == nil { args = & ConnectionArgs { } } server := ProtocolLXD { httpCertificate : args . TLSServerCert , httpHost : url , httpProtocol : "https" , httpUserAgent : args . UserAgent , bakeryInteractor : args . AuthInteractor , } if args . AuthType == "candid" { server . RequireAuthenticated ( true ) } httpClient , err := tlsHTTPClient ( args . HTTPClient , args . TLSClientCert , args . TLSClientKey , args . TLSCA , args . TLSServerCert , args . InsecureSkipVerify , args . Proxy ) if err != nil { return nil , err } if args . CookieJar != nil { httpClient . Jar = args . CookieJar } server . http = httpClient if args . AuthType == "candid" { server . setupBakeryClient ( ) } if ! args . SkipGetServer { _ , _ , err := server . GetServer ( ) if err != nil { return nil , err } } return & server , nil }
2564	func ( c Container ) IsActive ( ) bool { switch c . StatusCode { case Stopped : return false case Error : return false default : return true } }
2565	func ( n * NodeTx ) RaftNodeAddress ( id int64 ) ( string , error ) { stmt := "SELECT address FROM raft_nodes WHERE id=?" addresses , err := query . SelectStrings ( n . tx , stmt , id ) if err != nil { return "" , err } switch len ( addresses ) { case 0 : return "" , ErrNoSuchObject case 1 : return addresses [ 0 ] , nil default : return "" , fmt . Errorf ( "more than one match found" ) } }
2566	func ( n * NodeTx ) RaftNodeFirst ( address string ) error { columns := [ ] string { "id" , "address" } values := [ ] interface { } { int64 ( 1 ) , address } id , err := query . UpsertObject ( n . tx , "raft_nodes" , columns , values ) if err != nil { return err } if id != 1 { return fmt . Errorf ( "could not set raft node ID to 1" ) } return nil }
2567	func ( n * NodeTx ) RaftNodeAdd ( address string ) ( int64 , error ) { columns := [ ] string { "address" } values := [ ] interface { } { address } return query . UpsertObject ( n . tx , "raft_nodes" , columns , values ) }
2568	func ( n * NodeTx ) RaftNodeDelete ( id int64 ) error { deleted , err := query . DeleteObject ( n . tx , "raft_nodes" , id ) if err != nil { return err } if ! deleted { return ErrNoSuchObject } return nil }
2569	func ( n * NodeTx ) RaftNodesReplace ( nodes [ ] RaftNode ) error { _ , err := n . tx . Exec ( "DELETE FROM raft_nodes" ) if err != nil { return err } columns := [ ] string { "id" , "address" } for _ , node := range nodes { values := [ ] interface { } { node . ID , node . Address } _ , err := query . UpsertObject ( n . tx , "raft_nodes" , columns , values ) if err != nil { return err } } return nil }
2570	func ( s * OS ) initCGroup ( ) { flags := [ ] * bool { & s . CGroupBlkioController , & s . CGroupCPUController , & s . CGroupCPUacctController , & s . CGroupCPUsetController , & s . CGroupDevicesController , & s . CGroupFreezerController , & s . CGroupMemoryController , & s . CGroupNetPrioController , & s . CGroupPidsController , & s . CGroupSwapAccounting , } for i , flag := range flags { * flag = shared . PathExists ( "/sys/fs/cgroup/" + cGroups [ i ] . path ) if ! * flag { logger . Warnf ( cGroups [ i ] . warn ) } } }
2571	func sqliteDirectAccess ( conn * sqlite3 . SQLiteConn ) error { _ , err := conn . Exec ( "PRAGMA journal_mode=wal" , nil ) if err != nil { return err } _ , err = conn . Exec ( "PRAGMA journal_size_limit=-1" , nil ) if err != nil { return err } _ , err = conn . Exec ( "PRAGMA wal_autocheckpoint=0" , nil ) if err != nil { return err } return nil }
2572	func ( c * ClusterTx ) ContainerGet ( project string , name string ) ( * Container , error ) { filter := ContainerFilter { } filter . Project = project filter . Name = name filter . Type = - 1 objects , err := c . ContainerList ( filter ) if err != nil { return nil , errors . Wrap ( err , "Failed to fetch Container" ) } switch len ( objects ) { case 0 : return nil , ErrNoSuchObject case 1 : return & objects [ 0 ] , nil default : return nil , fmt . Errorf ( "More than one container matches" ) } }
2573	func ( c * ClusterTx ) ContainerID ( project string , name string ) ( int64 , error ) { stmt := c . stmt ( containerID ) rows , err := stmt . Query ( project , name ) if err != nil { return - 1 , errors . Wrap ( err , "Failed to get container ID" ) } defer rows . Close ( ) if ! rows . Next ( ) { return - 1 , ErrNoSuchObject } var id int64 err = rows . Scan ( & id ) if err != nil { return - 1 , errors . Wrap ( err , "Failed to scan ID" ) } if rows . Next ( ) { return - 1 , fmt . Errorf ( "More than one row returned" ) } err = rows . Err ( ) if err != nil { return - 1 , errors . Wrap ( err , "Result set failure" ) } return id , nil }
2574	func ( c * ClusterTx ) ContainerExists ( project string , name string ) ( bool , error ) { _ , err := c . ContainerID ( project , name ) if err != nil { if err == ErrNoSuchObject { return false , nil } return false , err } return true , nil }
2575	func ( m * Mapping ) ContainsFields ( fields [ ] * Field ) bool { matches := map [ * Field ] bool { } for _ , field := range m . Fields { for _ , other := range fields { if field . Name == other . Name && field . Type . Name == other . Type . Name { matches [ field ] = true } } } return len ( matches ) == len ( fields ) }
2576	func ( m * Mapping ) FieldByName ( name string ) * Field { for _ , field := range m . Fields { if field . Name == name { return field } } return nil }
2577	func ( m * Mapping ) FieldColumnName ( name string ) string { field := m . FieldByName ( name ) return fmt . Sprintf ( "%s.%s" , entityTable ( m . Name ) , field . Column ( ) ) }
2578	func ( m * Mapping ) FilterFieldByName ( name string ) ( * Field , error ) { field := m . FieldByName ( name ) if field == nil { return nil , fmt . Errorf ( "Unknown filter %q" , name ) } if field . Type . Code != TypeColumn { return nil , fmt . Errorf ( "Unknown filter %q not a column" , name ) } return field , nil }
2579	func ( m * Mapping ) ColumnFields ( exclude ... string ) [ ] * Field { fields := [ ] * Field { } for _ , field := range m . Fields { if shared . StringInSlice ( field . Name , exclude ) { continue } if field . Type . Code == TypeColumn { fields = append ( fields , field ) } } return fields }
2580	func ( m * Mapping ) ScalarFields ( ) [ ] * Field { fields := [ ] * Field { } for _ , field := range m . Fields { if field . Config . Get ( "join" ) != "" { fields = append ( fields , field ) } } return fields }
2581	func ( m * Mapping ) RefFields ( ) [ ] * Field { fields := [ ] * Field { } for _ , field := range m . Fields { if field . Type . Code == TypeSlice || field . Type . Code == TypeMap { fields = append ( fields , field ) } } return fields }
2582	func ( f * Field ) Column ( ) string { if f . Type . Code != TypeColumn { panic ( "attempt to get column name of non-column field" ) } column := lex . Snake ( f . Name ) join := f . Config . Get ( "join" ) if join != "" { column = fmt . Sprintf ( "%s AS %s" , join , column ) } return column }
2583	func ( f * Field ) ZeroValue ( ) string { if f . Type . Code != TypeColumn { panic ( "attempt to get zero value of non-column field" ) } switch f . Type . Name { case "string" : return `""` case "int" : return "-1" default : panic ( "unsupported zero value" ) } }
2584	func FieldColumns ( fields [ ] * Field ) string { columns := make ( [ ] string , len ( fields ) ) for i , field := range fields { columns [ i ] = field . Column ( ) } return strings . Join ( columns , ", " ) }
2585	func FieldArgs ( fields [ ] * Field ) string { args := make ( [ ] string , len ( fields ) ) for i , field := range fields { args [ i ] = fmt . Sprintf ( "%s %s" , lex . Minuscule ( field . Name ) , field . Type . Name ) } return strings . Join ( args , ", " ) }
2586	func FieldParams ( fields [ ] * Field ) string { args := make ( [ ] string , len ( fields ) ) for i , field := range fields { args [ i ] = lex . Minuscule ( field . Name ) } return strings . Join ( args , ", " ) }
2587	func FieldCriteria ( fields [ ] * Field ) string { criteria := make ( [ ] string , len ( fields ) ) for i , field := range fields { criteria [ i ] = fmt . Sprintf ( "%s = ?" , field . Column ( ) ) } return strings . Join ( criteria , " AND " ) }
2588	func initDataClusterApply ( d lxd . ContainerServer , config * initDataCluster ) error { if config == nil || ! config . Enabled { return nil } currentCluster , etag , err := d . GetCluster ( ) if err != nil { return errors . Wrap ( err , "Failed to retrieve current cluster config" ) } if ! currentCluster . Enabled { op , err := d . UpdateCluster ( config . ClusterPut , etag ) if err != nil { return errors . Wrap ( err , "Failed to configure cluster" ) } err = op . Wait ( ) if err != nil { return errors . Wrap ( err , "Failed to configure cluster" ) } } return nil }
2589	func JsonFormatEx ( pretty , lineSeparated bool ) Format { jsonMarshal := json . Marshal if pretty { jsonMarshal = func ( v interface { } ) ( [ ] byte , error ) { return json . MarshalIndent ( v , "" , " " ) } } return FormatFunc ( func ( r * Record ) [ ] byte { props := make ( map [ string ] interface { } ) props [ r . KeyNames . Time ] = r . Time props [ r . KeyNames . Lvl ] = r . Lvl props [ r . KeyNames . Msg ] = r . Msg for i := 0 ; i < len ( r . Ctx ) ; i += 2 { k , ok := r . Ctx [ i ] . ( string ) if ! ok { props [ errorKey ] = fmt . Sprintf ( "%+v is not a string key" , r . Ctx [ i ] ) } props [ k ] = formatJsonValue ( r . Ctx [ i + 1 ] ) } b , err := jsonMarshal ( props ) if err != nil { b , _ = jsonMarshal ( map [ string ] string { errorKey : err . Error ( ) , } ) return b } if lineSeparated { b = append ( b , '\n' ) } return b } ) }
2590	func formatLogfmtValue ( value interface { } ) string { if value == nil { return "nil" } value = formatShared ( value ) switch v := value . ( type ) { case bool : return strconv . FormatBool ( v ) case float32 : return strconv . FormatFloat ( float64 ( v ) , floatFormat , 3 , 64 ) case float64 : return strconv . FormatFloat ( v , floatFormat , 3 , 64 ) case int , int8 , int16 , int32 , int64 , uint , uint8 , uint16 , uint32 , uint64 : return fmt . Sprintf ( "%d" , value ) case string : return escapeString ( v ) default : return escapeString ( fmt . Sprintf ( "%+v" , value ) ) } }
2591	func ResolveTarget ( cluster * db . Cluster , target string ) ( string , error ) { address := "" err := cluster . Transaction ( func ( tx * db . ClusterTx ) error { name , err := tx . NodeName ( ) if err != nil { return err } if target == name { return nil } node , err := tx . NodeByName ( target ) if err != nil { if err == db . ErrNoSuchObject { return fmt . Errorf ( "No cluster member called '%s'" , target ) } return err } if node . Name != name { address = node . Address } return nil } ) return address , err }
2592	func ( pt * ProgressWriter ) Write ( p [ ] byte ) ( int , error ) { n , err := pt . WriteCloser . Write ( p ) if pt . Tracker != nil { pt . Tracker . total += int64 ( n ) pt . Tracker . update ( n ) } return n , err }
2593	func updateNodeVersion ( tx * sql . Tx , address string , apiExtensions int ) error { stmt := "UPDATE nodes SET schema=?, api_extensions=? WHERE address=?" result , err := tx . Exec ( stmt , len ( updates ) , apiExtensions , address ) if err != nil { return err } n , err := result . RowsAffected ( ) if err != nil { return err } if n != 1 { return fmt . Errorf ( "updated %d rows instead of 1" , n ) } return nil }
2594	func selectNodesVersions ( tx * sql . Tx ) ( [ ] [ 2 ] int , error ) { versions := [ ] [ 2 ] int { } dest := func ( i int ) [ ] interface { } { versions = append ( versions , [ 2 ] int { } ) return [ ] interface { } { & versions [ i ] [ 0 ] , & versions [ i ] [ 1 ] } } stmt , err := tx . Prepare ( "SELECT schema, api_extensions FROM nodes" ) if err != nil { return nil , err } defer stmt . Close ( ) err = query . SelectObjects ( stmt , dest ) if err != nil { return nil , err } return versions , nil }
2595	func GetArchitectures ( ) ( [ ] int , error ) { architectures := [ ] int { } architectureName , err := osarch . ArchitectureGetLocal ( ) if err != nil { return nil , err } architecture , err := osarch . ArchitectureId ( architectureName ) if err != nil { return nil , err } architectures = append ( architectures , architecture ) personalities , err := osarch . ArchitecturePersonalities ( architecture ) if err != nil { return nil , err } for _ , personality := range personalities { architectures = append ( architectures , personality ) } return architectures , nil }
2596	func RuntimeLiblxcVersionAtLeast ( major int , minor int , micro int ) bool { version := golxc . Version ( ) version = strings . Replace ( version , " (devel)" , "-devel" , 1 ) parts := strings . Split ( version , "." ) partsLen := len ( parts ) if partsLen == 0 { return false } develParts := strings . Split ( parts [ partsLen - 1 ] , "-" ) if len ( develParts ) == 2 && develParts [ 1 ] == "devel" { return true } maj := - 1 min := - 1 mic := - 1 for i , v := range parts { if i > 2 { break } num , err := strconv . Atoi ( v ) if err != nil { return false } switch i { case 0 : maj = num case 1 : min = num case 2 : mic = num } } if maj > major { return true } if maj < major { return false } if min > minor { return true } if min < minor { return false } if mic > micro { return true } if mic < micro { return false } return true }
2597	func GetExecPath ( ) string { execPath := os . Getenv ( "LXD_EXEC_PATH" ) if execPath != "" { return execPath } execPath , err := os . Readlink ( "/proc/self/exe" ) if err != nil { execPath = "bad-exec-path" } return execPath }
2598	func Connect ( address string , cert * shared . CertInfo , notify bool ) ( lxd . ContainerServer , error ) { args := & lxd . ConnectionArgs { TLSServerCert : string ( cert . PublicKey ( ) ) , TLSClientCert : string ( cert . PublicKey ( ) ) , TLSClientKey : string ( cert . PrivateKey ( ) ) , SkipGetServer : true , } if notify { args . UserAgent = "lxd-cluster-notifier" } url := fmt . Sprintf ( "https://%s" , address ) return lxd . ConnectLXD ( url , args ) }
2599	func ConnectIfContainerIsRemote ( cluster * db . Cluster , project , name string , cert * shared . CertInfo ) ( lxd . ContainerServer , error ) { var address string err := cluster . Transaction ( func ( tx * db . ClusterTx ) error { var err error address , err = tx . ContainerNodeAddress ( project , name ) return err } ) if err != nil { return nil , err } if address == "" { return nil , nil } return Connect ( address , cert , false ) }
2600	func ConnectIfVolumeIsRemote ( cluster * db . Cluster , poolID int64 , volumeName string , volumeType int , cert * shared . CertInfo ) ( lxd . ContainerServer , error ) { var addresses [ ] string err := cluster . Transaction ( func ( tx * db . ClusterTx ) error { var err error addresses , err = tx . StorageVolumeNodeAddresses ( poolID , "default" , volumeName , volumeType ) return err } ) if err != nil { return nil , err } if len ( addresses ) > 1 { var driver string err := cluster . Transaction ( func ( tx * db . ClusterTx ) error { var err error driver , err = tx . StoragePoolDriver ( poolID ) return err } ) if err != nil { return nil , err } if driver == "ceph" { return nil , nil } return nil , fmt . Errorf ( "more than one node has a volume named %s" , volumeName ) } address := addresses [ 0 ] if address == "" { return nil , nil } return Connect ( address , cert , false ) }
2601	func SetupTrust ( cert , targetAddress , targetCert , targetPassword string ) error { args := & lxd . ConnectionArgs { TLSServerCert : targetCert , } target , err := lxd . ConnectLXD ( fmt . Sprintf ( "https://%s" , targetAddress ) , args ) if err != nil { return errors . Wrap ( err , "failed to connect to target cluster node" ) } block , _ := pem . Decode ( [ ] byte ( cert ) ) if block == nil { return errors . Wrap ( err , "failed to decode certificate" ) } certificate := base64 . StdEncoding . EncodeToString ( block . Bytes ) post := api . CertificatesPost { Password : targetPassword , Certificate : certificate , } fingerprint , err := shared . CertFingerprintStr ( cert ) if err != nil { return errors . Wrap ( err , "failed to calculate fingerprint" ) } post . Name = fmt . Sprintf ( "lxd.cluster.%s" , fingerprint ) post . Type = "client" err = target . CreateCertificate ( post ) if err != nil && err . Error ( ) != "Certificate already in trust store" { return errors . Wrap ( err , "Failed to add client cert to cluster" ) } return nil }
2602	func ( r * ProtocolLXD ) GetStoragePools ( ) ( [ ] api . StoragePool , error ) { if ! r . HasExtension ( "storage" ) { return nil , fmt . Errorf ( "The server is missing the required \"storage\" API extension" ) } \" \" pools := [ ] api . StoragePool { } _ , err := r . queryStruct ( "GET" , "/storage-pools?recursion=1" , nil , "" , & pools ) }
2603	func ( r * ProtocolLXD ) GetStoragePool ( name string ) ( * api . StoragePool , string , error ) { if ! r . HasExtension ( "storage" ) { return nil , "" , fmt . Errorf ( "The server is missing the required \"storage\" API extension" ) } \" \" pool := api . StoragePool { } etag , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/storage-pools/%s" , url . QueryEscape ( name ) ) , nil , "" , & pool ) }
2604	func ( r * ProtocolLXD ) CreateStoragePool ( pool api . StoragePoolsPost ) error { if ! r . HasExtension ( "storage" ) { return fmt . Errorf ( "The server is missing the required \"storage\" API extension" ) } \" \" if pool . Driver == "ceph" && ! r . HasExtension ( "storage_driver_ceph" ) { return fmt . Errorf ( "The server is missing the required \"storage_driver_ceph\" API extension" ) } \" }
2605	func ( r * ProtocolLXD ) UpdateStoragePool ( name string , pool api . StoragePoolPut , ETag string ) error { if ! r . HasExtension ( "storage" ) { return fmt . Errorf ( "The server is missing the required \"storage\" API extension" ) } \" \" _ , _ , err := r . query ( "PUT" , fmt . Sprintf ( "/storage-pools/%s" , url . QueryEscape ( name ) ) , pool , ETag ) }
2606	func ( r * ProtocolLXD ) DeleteStoragePool ( name string ) error { if ! r . HasExtension ( "storage" ) { return fmt . Errorf ( "The server is missing the required \"storage\" API extension" ) } \" \" _ , _ , err := r . query ( "DELETE" , fmt . Sprintf ( "/storage-pools/%s" , url . QueryEscape ( name ) ) , nil , "" ) }
2607	func ( r * ProtocolLXD ) GetStoragePoolResources ( name string ) ( * api . ResourcesStoragePool , error ) { if ! r . HasExtension ( "resources" ) { return nil , fmt . Errorf ( "The server is missing the required \"resources\" API extension" ) } \" \" res := api . ResourcesStoragePool { } _ , err := r . queryStruct ( "GET" , fmt . Sprintf ( "/storage-pools/%s/resources" , url . QueryEscape ( name ) ) , nil , "" , & res ) }
2608	func ( s * OS ) initDirs ( ) error { dirs := [ ] struct { path string mode os . FileMode } { { s . VarDir , 0711 } , { filepath . Join ( s . VarDir , "backups" ) , 0700 } , { s . CacheDir , 0700 } , { filepath . Join ( s . VarDir , "containers" ) , 0711 } , { filepath . Join ( s . VarDir , "database" ) , 0700 } , { filepath . Join ( s . VarDir , "devices" ) , 0711 } , { filepath . Join ( s . VarDir , "devlxd" ) , 0755 } , { filepath . Join ( s . VarDir , "disks" ) , 0700 } , { filepath . Join ( s . VarDir , "images" ) , 0700 } , { s . LogDir , 0700 } , { filepath . Join ( s . VarDir , "networks" ) , 0711 } , { filepath . Join ( s . VarDir , "security" ) , 0700 } , { filepath . Join ( s . VarDir , "shmounts" ) , 0711 } , { filepath . Join ( s . VarDir , "snapshots" ) , 0700 } , { filepath . Join ( s . VarDir , "storage-pools" ) , 0711 } , } for _ , dir := range dirs { err := os . Mkdir ( dir . path , dir . mode ) if err != nil && ! os . IsExist ( err ) { return errors . Wrapf ( err , "failed to init dir %s" , dir . path ) } } return nil }
2609	func ( n * NodeTx ) Config ( ) ( map [ string ] string , error ) { return query . SelectConfig ( n . tx , "config" , "" ) }
2610	func ( n * NodeTx ) UpdateConfig ( values map [ string ] string ) error { return query . UpdateConfig ( n . tx , "config" , values ) }
2611	func ( c * ClusterTx ) Config ( ) ( map [ string ] string , error ) { return query . SelectConfig ( c . tx , "config" , "" ) }
2612	func ( c * ClusterTx ) UpdateConfig ( values map [ string ] string ) error { return query . UpdateConfig ( c . tx , "config" , values ) }
2613	func storagePoolClusterConfigForEtag ( dbConfig map [ string ] string ) map [ string ] string { config := util . CopyConfig ( dbConfig ) for _ , key := range db . StoragePoolNodeConfigKeys { delete ( config , key ) } return config }
2614	func ( r * ProtocolLXD ) GetEvents ( ) ( * EventListener , error ) { r . eventListenersLock . Lock ( ) defer r . eventListenersLock . Unlock ( ) listener := EventListener { r : r , chActive : make ( chan bool ) , } if r . eventListeners != nil { r . eventListeners = append ( r . eventListeners , & listener ) return & listener , nil } r . eventListeners = [ ] * EventListener { } url , err := r . setQueryAttributes ( "/events" ) if err != nil { return nil , err } conn , err := r . websocket ( url ) if err != nil { return nil , err } r . eventListeners = append ( r . eventListeners , & listener ) stopCh := make ( chan struct { } , 0 ) go func ( ) { for { select { case <- time . After ( time . Minute ) : case <- stopCh : break } r . eventListenersLock . Lock ( ) if len ( r . eventListeners ) == 0 { conn . Close ( ) r . eventListeners = nil r . eventListenersLock . Unlock ( ) break } r . eventListenersLock . Unlock ( ) } } ( ) go func ( ) { for { _ , data , err := conn . ReadMessage ( ) if err != nil { r . eventListenersLock . Lock ( ) defer r . eventListenersLock . Unlock ( ) for _ , listener := range r . eventListeners { listener . err = err listener . disconnected = true close ( listener . chActive ) } r . eventListeners = nil conn . Close ( ) close ( stopCh ) return } event := api . Event { } err = json . Unmarshal ( data , & event ) if err != nil { continue } if event . Type == "" { continue } r . eventListenersLock . Lock ( ) for _ , listener := range r . eventListeners { listener . targetsLock . Lock ( ) for _ , target := range listener . targets { if target . types != nil && ! shared . StringInSlice ( event . Type , target . types ) { continue } go target . function ( event ) } listener . targetsLock . Unlock ( ) } r . eventListenersLock . Unlock ( ) } } ( ) return & listener , nil }
2615	func LogfmtFormat ( ) log . Format { return log . FormatFunc ( func ( r * log . Record ) [ ] byte { common := [ ] interface { } { r . KeyNames . Time , r . Time , r . KeyNames . Lvl , r . Lvl , r . KeyNames . Msg , r . Msg } buf := & bytes . Buffer { } logfmt ( buf , common , 0 , false ) buf . Truncate ( buf . Len ( ) - 1 ) buf . WriteByte ( ' ' ) logfmt ( buf , r . Ctx , 0 , true ) return buf . Bytes ( ) } ) }
2616	func ( c * ClusterTx ) StorageVolumeNodeAddresses ( poolID int64 , project , name string , typ int ) ( [ ] string , error ) { nodes := [ ] struct { id int64 address string } { } dest := func ( i int ) [ ] interface { } { nodes = append ( nodes , struct { id int64 address string } { } ) return [ ] interface { } { & nodes [ i ] . id , & nodes [ i ] . address } } sql := `SELECT nodes.id, nodes.address FROM nodes JOIN storage_volumes ON storage_volumes.node_id=nodes.id JOIN projects ON projects.id = storage_volumes.project_id WHERE storage_volumes.storage_pool_id=? AND projects.name=? AND storage_volumes.name=? AND storage_volumes.type=?` stmt , err := c . tx . Prepare ( sql ) if err != nil { return nil , err } defer stmt . Close ( ) err = query . SelectObjects ( stmt , dest , poolID , project , name , typ ) if err != nil { return nil , err } addresses := [ ] string { } for _ , node := range nodes { address := node . address if node . id == c . nodeID { address = "" } addresses = append ( addresses , address ) } sort . Strings ( addresses ) if len ( addresses ) == 0 { return nil , ErrNoSuchObject } return addresses , nil }
2617	func ( c * Cluster ) StorageVolumeNodeGet ( volumeID int64 ) ( string , error ) { name := "" query := `SELECT nodes.name FROM storage_volumes JOIN nodes ON nodes.id=storage_volumes.node_id WHERE storage_volumes.id=?` inargs := [ ] interface { } { volumeID } outargs := [ ] interface { } { & name } err := dbQueryRowScan ( c . db , query , inargs , outargs ) if err != nil { if err == sql . ErrNoRows { return "" , ErrNoSuchObject } return "" , err } return name , nil }
2618	func ( c * Cluster ) StorageVolumeConfigGet ( volumeID int64 ) ( map [ string ] string , error ) { var key , value string query := "SELECT key, value FROM storage_volumes_config WHERE storage_volume_id=?" inargs := [ ] interface { } { volumeID } outargs := [ ] interface { } { key , value } results , err := queryScan ( c . db , query , inargs , outargs ) if err != nil { return nil , err } config := map [ string ] string { } for _ , r := range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) config [ key ] = value } return config , nil }
2619	func ( c * Cluster ) StorageVolumeDescriptionGet ( volumeID int64 ) ( string , error ) { description := sql . NullString { } query := "SELECT description FROM storage_volumes WHERE id=?" inargs := [ ] interface { } { volumeID } outargs := [ ] interface { } { & description } err := dbQueryRowScan ( c . db , query , inargs , outargs ) if err != nil { if err == sql . ErrNoRows { return "" , ErrNoSuchObject } return "" , err } return description . String , nil }
2620	func ( c * Cluster ) StorageVolumeIsAvailable ( pool , volume string ) ( bool , error ) { isAvailable := false err := c . Transaction ( func ( tx * ClusterTx ) error { id , err := tx . StoragePoolID ( pool ) if err != nil { return errors . Wrapf ( err , "Fetch storage pool ID for %q" , pool ) } driver , err := tx . StoragePoolDriver ( id ) if err != nil { return errors . Wrapf ( err , "Fetch storage pool driver for %q" , pool ) } if driver != "ceph" { isAvailable = true return nil } node , err := tx . NodeName ( ) if err != nil { return errors . Wrapf ( err , "Fetch node name" ) } containers , err := tx . ContainerListExpanded ( ) if err != nil { return errors . Wrapf ( err , "Fetch containers" ) } for _ , container := range containers { for _ , device := range container . Devices { if device [ "type" ] != "disk" { continue } if device [ "pool" ] != pool { continue } if device [ "source" ] != volume { continue } if container . Node != node { return nil } } } isAvailable = true return nil } ) if err != nil { return false , err } return isAvailable , nil }
2621	func StorageVolumeDescriptionUpdate ( tx * sql . Tx , volumeID int64 , description string ) error { _ , err := tx . Exec ( "UPDATE storage_volumes SET description=? WHERE id=?" , description , volumeID ) return err }
2622	func StorageVolumeConfigAdd ( tx * sql . Tx , volumeID int64 , volumeConfig map [ string ] string ) error { str := "INSERT INTO storage_volumes_config (storage_volume_id, key, value) VALUES(?, ?, ?)" stmt , err := tx . Prepare ( str ) defer stmt . Close ( ) if err != nil { return err } for k , v := range volumeConfig { if v == "" { continue } _ , err = stmt . Exec ( volumeID , k , v ) if err != nil { return err } } return nil }
2623	func StorageVolumeConfigClear ( tx * sql . Tx , volumeID int64 ) error { _ , err := tx . Exec ( "DELETE FROM storage_volumes_config WHERE storage_volume_id=?" , volumeID ) if err != nil { return err } return nil }
2624	func storageVolumeIDsGet ( tx * sql . Tx , project , volumeName string , volumeType int , poolID int64 ) ( [ ] int64 , error ) { ids , err := query . SelectIntegers ( tx , `SELECT storage_volumes.id FROM storage_volumes JOIN projects ON projects.id = storage_volumes.project_id WHERE projects.name=? AND storage_volumes.name=? AND storage_volumes.type=? AND storage_pool_id=?` , project , volumeName , volumeType , poolID ) if err != nil { return nil , err } ids64 := make ( [ ] int64 , len ( ids ) ) for i , id := range ids { ids64 [ i ] = int64 ( id ) } return ids64 , nil }
2625	func ( c * Cluster ) StorageVolumeCleanupImages ( fingerprints [ ] string ) error { stmt := fmt . Sprintf ( "DELETE FROM storage_volumes WHERE type=? AND name NOT IN %s" , query . Params ( len ( fingerprints ) ) ) args := [ ] interface { } { StoragePoolVolumeTypeImage } for _ , fingerprint := range fingerprints { args = append ( args , fingerprint ) } err := exec ( c . db , stmt , args ... ) return err }
2626	func ( c * Cluster ) StorageVolumeMoveToLVMThinPoolNameKey ( ) error { err := exec ( c . db , "UPDATE storage_pools_config SET key='lvm.thinpool_name' WHERE key='volume.lvm.thinpool_name';" ) if err != nil { return err } err = exec ( c . db , "DELETE FROM storage_volumes_config WHERE key='lvm.thinpool_name';" ) if err != nil { return err } return nil }
2627	func ( b * Buffer ) L ( format string , a ... interface { } ) { fmt . Fprintf ( b . buf , format , a ... ) b . N ( ) }
2628	func ( b * Buffer ) code ( ) ( [ ] byte , error ) { code , err := format . Source ( b . buf . Bytes ( ) ) if err != nil { return nil , errors . Wrap ( err , "Can't format generated source code" ) } return code , nil }
2629	func Pretty ( input interface { } ) string { pretty , err := json . MarshalIndent ( input , "\t" , \t ) "\t" \t }
2630	func ( e * Endpoints ) NetworkPublicKey ( ) [ ] byte { e . mu . RLock ( ) defer e . mu . RUnlock ( ) return e . cert . PublicKey ( ) }
2631	func ( e * Endpoints ) NetworkPrivateKey ( ) [ ] byte { e . mu . RLock ( ) defer e . mu . RUnlock ( ) return e . cert . PrivateKey ( ) }
2632	func ( e * Endpoints ) NetworkCert ( ) * shared . CertInfo { e . mu . RLock ( ) defer e . mu . RUnlock ( ) return e . cert }
2633	func ( e * Endpoints ) NetworkAddress ( ) string { e . mu . RLock ( ) defer e . mu . RUnlock ( ) listener := e . listeners [ network ] if listener == nil { return "" } return listener . Addr ( ) . String ( ) }
2634	func ( e * Endpoints ) NetworkUpdateAddress ( address string ) error { if address != "" { address = util . CanonicalNetworkAddress ( address ) } oldAddress := e . NetworkAddress ( ) if address == oldAddress { return nil } clusterAddress := e . ClusterAddress ( ) logger . Infof ( "Update network address" ) e . mu . Lock ( ) defer e . mu . Unlock ( ) e . closeListener ( network ) if address == "" { return nil } if clusterAddress != "" && util . IsAddressCovered ( clusterAddress , address ) { e . closeListener ( cluster ) } getListener := func ( address string ) ( * net . Listener , error ) { var err error var listener net . Listener for i := 0 ; i < 10 ; i ++ { listener , err = net . Listen ( "tcp" , address ) if err == nil { break } time . Sleep ( 100 * time . Millisecond ) } if err != nil { return nil , fmt . Errorf ( "cannot listen on https socket: %v" , err ) } return & listener , nil } if address != "" { listener , err := getListener ( address ) if err != nil { listener , err1 := getListener ( oldAddress ) if err1 == nil { e . listeners [ network ] = networkTLSListener ( * listener , e . cert ) e . serveHTTP ( network ) } return err } e . listeners [ network ] = networkTLSListener ( * listener , e . cert ) e . serveHTTP ( network ) } return nil }
2635	func ( e * Endpoints ) NetworkUpdateCert ( cert * shared . CertInfo ) { e . mu . Lock ( ) defer e . mu . Unlock ( ) e . cert = cert listener , ok := e . listeners [ network ] if ! ok { return } listener . ( * networkListener ) . Config ( cert ) listener , ok = e . listeners [ cluster ] if ! ok { return } listener . ( * networkListener ) . Config ( cert ) }
2636	func networkCreateListener ( address string , cert * shared . CertInfo ) net . Listener { listener , err := net . Listen ( "tcp" , util . CanonicalNetworkAddress ( address ) ) if err != nil { logger . Error ( "Cannot listen on https socket, skipping..." , log . Ctx { "err" : err } ) return nil } return networkTLSListener ( listener , cert ) }
2637	func ( l * networkListener ) Accept ( ) ( net . Conn , error ) { c , err := l . Listener . Accept ( ) if err != nil { return nil , err } l . mu . RLock ( ) defer l . mu . RUnlock ( ) config := l . config return tls . Server ( c , config ) , nil }
2638	func ( l * networkListener ) Config ( cert * shared . CertInfo ) { config := util . ServerTLSConfig ( cert ) l . mu . Lock ( ) defer l . mu . Unlock ( ) l . config = config }
2639	func ( n NodeInfo ) IsOffline ( threshold time . Duration ) bool { return nodeIsOffline ( threshold , n . Heartbeat ) }
2640	func ( c * ClusterTx ) NodeByAddress ( address string ) ( NodeInfo , error ) { null := NodeInfo { } nodes , err := c . nodes ( false , "address=?" , address ) if err != nil { return null , err } switch len ( nodes ) { case 0 : return null , ErrNoSuchObject case 1 : return nodes [ 0 ] , nil default : return null , fmt . Errorf ( "more than one node matches" ) } }
2641	func ( c * ClusterTx ) NodePendingByAddress ( address string ) ( NodeInfo , error ) { null := NodeInfo { } nodes , err := c . nodes ( true , "address=?" , address ) if err != nil { return null , err } switch len ( nodes ) { case 0 : return null , ErrNoSuchObject case 1 : return nodes [ 0 ] , nil default : return null , fmt . Errorf ( "more than one node matches" ) } }
2642	func ( c * ClusterTx ) NodeByName ( name string ) ( NodeInfo , error ) { null := NodeInfo { } nodes , err := c . nodes ( false , "name=?" , name ) if err != nil { return null , err } switch len ( nodes ) { case 0 : return null , ErrNoSuchObject case 1 : return nodes [ 0 ] , nil default : return null , fmt . Errorf ( "more than one node matches" ) } }
2643	func ( c * ClusterTx ) NodeName ( ) ( string , error ) { stmt := "SELECT name FROM nodes WHERE id=?" names , err := query . SelectStrings ( c . tx , stmt , c . nodeID ) if err != nil { return "" , err } switch len ( names ) { case 0 : return "" , nil case 1 : return names [ 0 ] , nil default : return "" , fmt . Errorf ( "inconsistency: non-unique node ID" ) } }
2644	func ( c * ClusterTx ) NodeAddress ( ) ( string , error ) { stmt := "SELECT address FROM nodes WHERE id=?" addresses , err := query . SelectStrings ( c . tx , stmt , c . nodeID ) if err != nil { return "" , err } switch len ( addresses ) { case 0 : return "" , nil case 1 : return addresses [ 0 ] , nil default : return "" , fmt . Errorf ( "inconsistency: non-unique node ID" ) } }
2645	func ( c * ClusterTx ) NodeIsOutdated ( ) ( bool , error ) { nodes , err := c . nodes ( false , "" ) if err != nil { return false , errors . Wrap ( err , "Failed to fetch nodes" ) } version := [ 2 ] int { } for _ , node := range nodes { if node . ID == c . nodeID { version = node . Version ( ) } } if version [ 0 ] == 0 || version [ 1 ] == 0 { return false , fmt . Errorf ( "Inconsistency: local node not found" ) } for _ , node := range nodes { if node . ID == c . nodeID { continue } n , err := util . CompareVersions ( node . Version ( ) , version ) if err != nil { errors . Wrapf ( err , "Failed to compare with version of node %s" , node . Name ) } if n == 1 { return true , nil } } return false , nil }
2646	func ( c * ClusterTx ) NodesCount ( ) ( int , error ) { count , err := query . Count ( c . tx , "nodes" , "" ) if err != nil { return 0 , errors . Wrap ( err , "failed to count existing nodes" ) } return count , nil }
2647	func ( c * ClusterTx ) NodeRename ( old , new string ) error { count , err := query . Count ( c . tx , "nodes" , "name=?" , new ) if err != nil { return errors . Wrap ( err , "failed to check existing nodes" ) } if count != 0 { return ErrAlreadyDefined } stmt := `UPDATE nodes SET name=? WHERE name=?` result , err := c . tx . Exec ( stmt , new , old ) if err != nil { return errors . Wrap ( err , "failed to update node name" ) } n , err := result . RowsAffected ( ) if err != nil { return errors . Wrap ( err , "failed to get rows count" ) } if n != 1 { return fmt . Errorf ( "expected to update one row, not %d" , n ) } return nil }
2648	func ( c * ClusterTx ) nodes ( pending bool , where string , args ... interface { } ) ( [ ] NodeInfo , error ) { nodes := [ ] NodeInfo { } dest := func ( i int ) [ ] interface { } { nodes = append ( nodes , NodeInfo { } ) return [ ] interface { } { & nodes [ i ] . ID , & nodes [ i ] . Name , & nodes [ i ] . Address , & nodes [ i ] . Description , & nodes [ i ] . Schema , & nodes [ i ] . APIExtensions , & nodes [ i ] . Heartbeat , } } if pending { args = append ( [ ] interface { } { 1 } , args ... ) } else { args = append ( [ ] interface { } { 0 } , args ... ) } sql := `SELECT id, name, address, description, schema, api_extensions, heartbeat FROM nodes WHERE pending=? ` if where != "" { sql += fmt . Sprintf ( "AND %s " , where ) } sql += "ORDER BY id" stmt , err := c . tx . Prepare ( sql ) if err != nil { return nil , err } defer stmt . Close ( ) err = query . SelectObjects ( stmt , dest , args ... ) if err != nil { return nil , errors . Wrap ( err , "Failed to fetch nodes" ) } return nodes , nil }
2649	func ( c * ClusterTx ) NodeAdd ( name string , address string ) ( int64 , error ) { columns := [ ] string { "name" , "address" , "schema" , "api_extensions" } values := [ ] interface { } { name , address , cluster . SchemaVersion , version . APIExtensionsCount ( ) } return query . UpsertObject ( c . tx , "nodes" , columns , values ) }
2650	func ( c * ClusterTx ) NodePending ( id int64 , pending bool ) error { value := 0 if pending { value = 1 } result , err := c . tx . Exec ( "UPDATE nodes SET pending=? WHERE id=?" , value , id ) if err != nil { return err } n , err := result . RowsAffected ( ) if err != nil { return err } if n != 1 { return fmt . Errorf ( "query updated %d rows instead of 1" , n ) } return nil }
2651	func ( c * ClusterTx ) NodeUpdate ( id int64 , name string , address string ) error { result , err := c . tx . Exec ( "UPDATE nodes SET name=?, address=? WHERE id=?" , name , address , id ) if err != nil { return err } n , err := result . RowsAffected ( ) if err != nil { return err } if n != 1 { return fmt . Errorf ( "query updated %d rows instead of 1" , n ) } return nil }
2652	func ( c * ClusterTx ) NodeRemove ( id int64 ) error { result , err := c . tx . Exec ( "DELETE FROM nodes WHERE id=?" , id ) if err != nil { return err } n , err := result . RowsAffected ( ) if err != nil { return err } if n != 1 { return fmt . Errorf ( "query deleted %d rows instead of 1" , n ) } return nil }
2653	func ( c * ClusterTx ) NodeHeartbeat ( address string , heartbeat time . Time ) error { stmt := "UPDATE nodes SET heartbeat=? WHERE address=?" result , err := c . tx . Exec ( stmt , heartbeat , address ) if err != nil { return err } n , err := result . RowsAffected ( ) if err != nil { return err } if n != 1 { return fmt . Errorf ( "expected to update one row and not %d" , n ) } return nil }
2654	func ( c * ClusterTx ) NodeIsEmpty ( id int64 ) ( string , error ) { containers , err := query . SelectStrings ( c . tx , "SELECT name FROM containers WHERE node_id=?" , id ) if err != nil { return "" , errors . Wrapf ( err , "Failed to get containers for node %d" , id ) } if len ( containers ) > 0 { message := fmt . Sprintf ( "Node still has the following containers: %s" , strings . Join ( containers , ", " ) ) return message , nil } images := [ ] struct { fingerprint string nodeID int64 } { } dest := func ( i int ) [ ] interface { } { images = append ( images , struct { fingerprint string nodeID int64 } { } ) return [ ] interface { } { & images [ i ] . fingerprint , & images [ i ] . nodeID } } stmt , err := c . tx . Prepare ( `SELECT fingerprint, node_id FROM images JOIN images_nodes ON images.id=images_nodes.image_id` ) if err != nil { return "" , err } defer stmt . Close ( ) err = query . SelectObjects ( stmt , dest ) if err != nil { return "" , errors . Wrapf ( err , "Failed to get image list for node %d" , id ) } index := map [ string ] [ ] int64 { } for _ , image := range images { index [ image . fingerprint ] = append ( index [ image . fingerprint ] , image . nodeID ) } fingerprints := [ ] string { } for fingerprint , ids := range index { if len ( ids ) > 1 { continue } if ids [ 0 ] == id { fingerprints = append ( fingerprints , fingerprint ) } } if len ( fingerprints ) > 0 { message := fmt . Sprintf ( "Node still has the following images: %s" , strings . Join ( fingerprints , ", " ) ) return message , nil } volumes , err := query . SelectStrings ( c . tx , "SELECT name FROM storage_volumes WHERE node_id=? AND type=?" , id , StoragePoolVolumeTypeCustom ) if err != nil { return "" , errors . Wrapf ( err , "Failed to get custom volumes for node %d" , id ) } if len ( volumes ) > 0 { message := fmt . Sprintf ( "Node still has the following custom volumes: %s" , strings . Join ( volumes , ", " ) ) return message , nil } return "" , nil }
2655	func ( c * ClusterTx ) NodeClear ( id int64 ) error { _ , err := c . tx . Exec ( "DELETE FROM containers WHERE node_id=?" , id ) if err != nil { return err } ids , err := query . SelectIntegers ( c . tx , "SELECT image_id FROM images_nodes WHERE node_id=?" , id ) if err != nil { return err } _ , err = c . tx . Exec ( "DELETE FROM images_nodes WHERE node_id=?" , id ) if err != nil { return err } for _ , id := range ids { count , err := query . Count ( c . tx , "images_nodes" , "image_id=?" , id ) if err != nil { return err } if count > 0 { continue } _ , err = c . tx . Exec ( "DELETE FROM images WHERE id=?" , id ) if err != nil { return err } } return nil }
2656	func ( c * ClusterTx ) NodeOfflineThreshold ( ) ( time . Duration , error ) { threshold := time . Duration ( DefaultOfflineThreshold ) * time . Second values , err := query . SelectStrings ( c . tx , "SELECT value FROM config WHERE key='cluster.offline_threshold'" ) if err != nil { return - 1 , err } if len ( values ) > 0 { seconds , err := strconv . Atoi ( values [ 0 ] ) if err != nil { return - 1 , err } threshold = time . Duration ( seconds ) * time . Second } return threshold , nil }
2657	func ( c * ClusterTx ) NodeUpdateVersion ( id int64 , version [ 2 ] int ) error { stmt := "UPDATE nodes SET schema=?, api_extensions=? WHERE id=?" result , err := c . tx . Exec ( stmt , version [ 0 ] , version [ 1 ] , id ) if err != nil { return errors . Wrap ( err , "Failed to update nodes table" ) } n , err := result . RowsAffected ( ) if err != nil { return errors . Wrap ( err , "Failed to get affected rows" ) } if n != 1 { return fmt . Errorf ( "Expected exactly one row to be updated" ) } return nil }
2658	func Transaction ( db * sql . DB , f func ( * sql . Tx ) error ) error { tx , err := db . Begin ( ) if err != nil { return errors . Wrap ( err , "failed to begin transaction" ) } err = f ( tx ) if err != nil { return rollback ( tx , err ) } err = tx . Commit ( ) if err == sql . ErrTxDone { err = nil } return err }
2659	func rollback ( tx * sql . Tx , reason error ) error { err := tx . Rollback ( ) if err != nil { logger . Warnf ( "Failed to rollback transaction after error (%v): %v" , reason , err ) } return reason }
2660	func ( c * ClusterTx ) ProfileURIs ( filter ProfileFilter ) ( [ ] string , error ) { criteria := map [ string ] interface { } { } if filter . Project != "" { criteria [ "Project" ] = filter . Project } if filter . Name != "" { criteria [ "Name" ] = filter . Name } var stmt * sql . Stmt var args [ ] interface { } if criteria [ "Project" ] != nil && criteria [ "Name" ] != nil { stmt = c . stmt ( profileNamesByProjectAndName ) args = [ ] interface { } { filter . Project , filter . Name , } } else if criteria [ "Project" ] != nil { stmt = c . stmt ( profileNamesByProject ) args = [ ] interface { } { filter . Project , } } else { stmt = c . stmt ( profileNames ) args = [ ] interface { } { } } code := cluster . EntityTypes [ "profile" ] formatter := cluster . EntityFormatURIs [ code ] return query . SelectURIs ( stmt , formatter , args ... ) }
2661	func ( c * ClusterTx ) ProfileGet ( project string , name string ) ( * Profile , error ) { filter := ProfileFilter { } filter . Project = project filter . Name = name objects , err := c . ProfileList ( filter ) if err != nil { return nil , errors . Wrap ( err , "Failed to fetch Profile" ) } switch len ( objects ) { case 0 : return nil , ErrNoSuchObject case 1 : return & objects [ 0 ] , nil default : return nil , fmt . Errorf ( "More than one profile matches" ) } }
2662	func ( c * ClusterTx ) ProfileExists ( project string , name string ) ( bool , error ) { _ , err := c . ProfileID ( project , name ) if err != nil { if err == ErrNoSuchObject { return false , nil } return false , err } return true , nil }
2663	func ( c * ClusterTx ) ProfileConfigRef ( filter ProfileFilter ) ( map [ string ] map [ string ] map [ string ] string , error ) { objects := make ( [ ] struct { Project string Name string Key string Value string } , 0 ) criteria := map [ string ] interface { } { } if filter . Project != "" { criteria [ "Project" ] = filter . Project } if filter . Name != "" { criteria [ "Name" ] = filter . Name } var stmt * sql . Stmt var args [ ] interface { } if criteria [ "Project" ] != nil && criteria [ "Name" ] != nil { stmt = c . stmt ( profileConfigRefByProjectAndName ) args = [ ] interface { } { filter . Project , filter . Name , } } else if criteria [ "Project" ] != nil { stmt = c . stmt ( profileConfigRefByProject ) args = [ ] interface { } { filter . Project , } } else { stmt = c . stmt ( profileConfigRef ) args = [ ] interface { } { } } dest := func ( i int ) [ ] interface { } { objects = append ( objects , struct { Project string Name string Key string Value string } { } ) return [ ] interface { } { & objects [ i ] . Project , & objects [ i ] . Name , & objects [ i ] . Key , & objects [ i ] . Value , } } err := query . SelectObjects ( stmt , dest , args ... ) if err != nil { return nil , errors . Wrap ( err , "Failed to fetch ref for profiles" ) } index := map [ string ] map [ string ] map [ string ] string { } for _ , object := range objects { _ , ok := index [ object . Project ] if ! ok { subIndex := map [ string ] map [ string ] string { } index [ object . Project ] = subIndex } item , ok := index [ object . Project ] [ object . Name ] if ! ok { item = map [ string ] string { } } index [ object . Project ] [ object . Name ] = item item [ object . Key ] = object . Value } return index , nil }
2664	func ( c * ClusterTx ) ProfileUsedByRef ( filter ProfileFilter ) ( map [ string ] map [ string ] [ ] string , error ) { objects := make ( [ ] struct { Project string Name string Value string } , 0 ) criteria := map [ string ] interface { } { } if filter . Project != "" { criteria [ "Project" ] = filter . Project } if filter . Name != "" { criteria [ "Name" ] = filter . Name } var stmt * sql . Stmt var args [ ] interface { } if criteria [ "Project" ] != nil && criteria [ "Name" ] != nil { stmt = c . stmt ( profileUsedByRefByProjectAndName ) args = [ ] interface { } { filter . Project , filter . Name , } } else if criteria [ "Project" ] != nil { stmt = c . stmt ( profileUsedByRefByProject ) args = [ ] interface { } { filter . Project , } } else { stmt = c . stmt ( profileUsedByRef ) args = [ ] interface { } { } } dest := func ( i int ) [ ] interface { } { objects = append ( objects , struct { Project string Name string Value string } { } ) return [ ] interface { } { & objects [ i ] . Project , & objects [ i ] . Name , & objects [ i ] . Value , } } err := query . SelectObjects ( stmt , dest , args ... ) if err != nil { return nil , errors . Wrap ( err , "Failed to fetch string ref for profiles" ) } index := map [ string ] map [ string ] [ ] string { } for _ , object := range objects { _ , ok := index [ object . Project ] if ! ok { subIndex := map [ string ] [ ] string { } index [ object . Project ] = subIndex } item , ok := index [ object . Project ] [ object . Name ] if ! ok { item = [ ] string { } } index [ object . Project ] [ object . Name ] = append ( item , object . Value ) } return index , nil }
2665	func ( c * ClusterTx ) ProfileCreate ( object Profile ) ( int64 , error ) { exists , err := c . ProfileExists ( object . Project , object . Name ) if err != nil { return - 1 , errors . Wrap ( err , "Failed to check for duplicates" ) } if exists { return - 1 , fmt . Errorf ( "This profile already exists" ) } args := make ( [ ] interface { } , 3 ) args [ 0 ] = object . Project args [ 1 ] = object . Name args [ 2 ] = object . Description stmt := c . stmt ( profileCreate ) result , err := stmt . Exec ( args ... ) if err != nil { return - 1 , errors . Wrap ( err , "Failed to create profile" ) } id , err := result . LastInsertId ( ) if err != nil { return - 1 , errors . Wrap ( err , "Failed to fetch profile ID" ) } stmt = c . stmt ( profileCreateConfigRef ) for key , value := range object . Config { _ , err := stmt . Exec ( id , key , value ) if err != nil { return - 1 , errors . Wrap ( err , "Insert config for profile" ) } } for name , config := range object . Devices { typ , ok := config [ "type" ] if ! ok { return - 1 , fmt . Errorf ( "No type for device %s" , name ) } typCode , err := dbDeviceTypeToInt ( typ ) if err != nil { return - 1 , errors . Wrapf ( err , "Device type code for %s" , typ ) } stmt = c . stmt ( profileCreateDevicesRef ) result , err := stmt . Exec ( id , name , typCode ) if err != nil { return - 1 , errors . Wrapf ( err , "Insert device %s" , name ) } deviceID , err := result . LastInsertId ( ) if err != nil { return - 1 , errors . Wrap ( err , "Failed to fetch device ID" ) } stmt = c . stmt ( profileCreateDevicesConfigRef ) for key , value := range config { _ , err := stmt . Exec ( deviceID , key , value ) if err != nil { return - 1 , errors . Wrap ( err , "Insert config for profile" ) } } } return id , nil }
2666	func ( c * ClusterTx ) ProfileRename ( project string , name string , to string ) error { stmt := c . stmt ( profileRename ) result , err := stmt . Exec ( to , project , name ) if err != nil { return errors . Wrap ( err , "Rename profile" ) } n , err := result . RowsAffected ( ) if err != nil { return errors . Wrap ( err , "Fetch affected rows" ) } if n != 1 { return fmt . Errorf ( "Query affected %d rows instead of 1" , n ) } return nil }
2667	func ( c * ClusterTx ) ProfileDelete ( project string , name string ) error { stmt := c . stmt ( profileDelete ) result , err := stmt . Exec ( project , name ) if err != nil { return errors . Wrap ( err , "Delete profile" ) } n , err := result . RowsAffected ( ) if err != nil { return errors . Wrap ( err , "Fetch affected rows" ) } if n != 1 { return fmt . Errorf ( "Query deleted %d rows instead of 1" , n ) } return nil }
2668	func ServerTLSConfig ( cert * shared . CertInfo ) * tls . Config { config := shared . InitTLSConfig ( ) config . ClientAuth = tls . RequestClientCert config . Certificates = [ ] tls . Certificate { cert . KeyPair ( ) } config . NextProtos = [ ] string { "h2" } if cert . CA ( ) != nil { pool := x509 . NewCertPool ( ) pool . AddCert ( cert . CA ( ) ) config . RootCAs = pool config . ClientCAs = pool logger . Infof ( "LXD is in CA mode, only CA-signed certificates will be allowed" ) } config . BuildNameToCertificate ( ) return config }
2669	func NetworkInterfaceAddress ( ) string { ifaces , err := net . Interfaces ( ) if err != nil { return "" } for _ , iface := range ifaces { if shared . IsLoopback ( & iface ) { continue } addrs , err := iface . Addrs ( ) if err != nil { continue } if len ( addrs ) == 0 { continue } addr , ok := addrs [ 0 ] . ( * net . IPNet ) if ! ok { continue } return addr . IP . String ( ) } return "" }
2670	func IsAddressCovered ( address1 , address2 string ) bool { if address1 == address2 { return true } host1 , port1 , err := net . SplitHostPort ( address1 ) if err != nil { return false } host2 , port2 , err := net . SplitHostPort ( address2 ) if err != nil { return false } if port2 != port1 { return false } if host2 == "0.0.0.0" { ip := net . ParseIP ( host1 ) if ip != nil && ip . To4 ( ) != nil { return true } return false } if host2 == "::" || host2 == "" { return true } return false }
2671	func SelectObjects ( stmt * sql . Stmt , dest Dest , args ... interface { } ) error { rows , err := stmt . Query ( args ... ) if err != nil { return err } defer rows . Close ( ) for i := 0 ; rows . Next ( ) ; i ++ { err := rows . Scan ( dest ( i ) ... ) if err != nil { return err } } err = rows . Err ( ) if err != nil { return err } return nil }
2672	func DeleteObject ( tx * sql . Tx , table string , id int64 ) ( bool , error ) { stmt := fmt . Sprintf ( "DELETE FROM %s WHERE id=?" , table ) result , err := tx . Exec ( stmt , id ) if err != nil { return false , err } n , err := result . RowsAffected ( ) if err != nil { return false , err } if n > 1 { return true , fmt . Errorf ( "more than one row was deleted" ) } return n == 1 , nil }
2673	func ( t * Task ) loop ( ctx context . Context ) { delay := immediately for { var timer <- chan time . Time schedule , err := t . schedule ( ) switch err { case ErrSkip : delay = schedule fallthrough case nil : if schedule > 0 { timer = time . After ( delay ) } else { timer = make ( chan time . Time ) } default : if schedule <= 0 { return } timer = time . After ( schedule ) } select { case <- timer : if err == nil { t . f ( ctx ) delay = schedule } else { delay = immediately } case <- ctx . Done ( ) : return case <- t . reset : delay = immediately } } }
2674	func IsTerminal ( fd int ) bool { _ , err := GetState ( fd ) return err == nil }
2675	func socketUnixListen ( path string ) ( net . Listener , error ) { addr , err := net . ResolveUnixAddr ( "unix" , path ) if err != nil { return nil , fmt . Errorf ( "cannot resolve socket address: %v" , err ) } listener , err := net . ListenUnix ( "unix" , addr ) if err != nil { return nil , fmt . Errorf ( "cannot bind socket: %v" , err ) } return listener , err }
2676	func socketUnixRemoveStale ( path string ) error { if ! shared . PathExists ( path ) { return nil } logger . Debugf ( "Detected stale unix socket, deleting" ) err := os . Remove ( path ) if err != nil { return fmt . Errorf ( "could not delete stale local socket: %v" , err ) } return nil }
2677	func socketUnixSetPermissions ( path string , mode os . FileMode ) error { err := os . Chmod ( path , mode ) if err != nil { return fmt . Errorf ( "cannot set permissions on local socket: %v" , err ) } return nil }
2678	func socketUnixSetOwnership ( path string , group string ) error { var gid int var err error if group != "" { gid , err = shared . GroupId ( group ) if err != nil { return fmt . Errorf ( "cannot get group ID of '%s': %v" , group , err ) } } else { gid = os . Getgid ( ) } err = os . Chown ( path , os . Getuid ( ) , gid ) if err != nil { return fmt . Errorf ( "cannot change ownership on local socket: %v" , err ) } return nil }
2679	func cephOSDPoolExists ( ClusterName string , poolName string , userName string ) bool { _ , err := shared . RunCommand ( "ceph" , "--name" , fmt . Sprintf ( "client.%s" , userName ) , "--cluster" , ClusterName , "osd" , "pool" , "get" , poolName , "size" ) if err != nil { return false } return true }
2680	func cephOSDPoolDestroy ( clusterName string , poolName string , userName string ) error { _ , err := shared . RunCommand ( "ceph" , "--name" , fmt . Sprintf ( "client.%s" , userName ) , "--cluster" , clusterName , "osd" , "pool" , "delete" , poolName , poolName , "--yes-i-really-really-mean-it" ) if err != nil { return err } return nil }
2681	func cephRBDVolumeExists ( clusterName string , poolName string , volumeName string , volumeType string , userName string ) bool { _ , err := shared . RunCommand ( "rbd" , "--id" , userName , "--cluster" , clusterName , "--pool" , poolName , "image-meta" , "list" , fmt . Sprintf ( "%s_%s" , volumeType , volumeName ) ) if err != nil { return false } return true }
2682	func cephRBDSnapshotProtect ( clusterName string , poolName string , volumeName string , volumeType string , snapshotName string , userName string ) error { _ , err := shared . RunCommand ( "rbd" , "--id" , userName , "--cluster" , clusterName , "--pool" , poolName , "snap" , "protect" , "--snap" , snapshotName , fmt . Sprintf ( "%s_%s" , volumeType , volumeName ) ) if err != nil { runError , ok := err . ( shared . RunError ) if ok { exitError , ok := runError . Err . ( * exec . ExitError ) if ok { waitStatus := exitError . Sys ( ) . ( syscall . WaitStatus ) if waitStatus . ExitStatus ( ) == 16 { return nil } } } return err } return nil }
2683	func cephRBDCloneCreate ( sourceClusterName string , sourcePoolName string , sourceVolumeName string , sourceVolumeType string , sourceSnapshotName string , targetPoolName string , targetVolumeName string , targetVolumeType string , userName string ) error { _ , err := shared . RunCommand ( "rbd" , "--id" , userName , "--cluster" , sourceClusterName , "--image-feature" , "layering" , "clone" , fmt . Sprintf ( "%s/%s_%s@%s" , sourcePoolName , sourceVolumeType , sourceVolumeName , sourceSnapshotName ) , fmt . Sprintf ( "%s/%s_%s" , targetPoolName , targetVolumeType , targetVolumeName ) ) if err != nil { return err } return nil }
2684	func cephRBDSnapshotListClones ( clusterName string , poolName string , volumeName string , volumeType string , snapshotName string , userName string ) ( [ ] string , error ) { msg , err := shared . RunCommand ( "rbd" , "--id" , userName , "--cluster" , clusterName , "--pool" , poolName , "children" , "--image" , fmt . Sprintf ( "%s_%s" , volumeType , volumeName ) , "--snap" , snapshotName ) if err != nil { return nil , err } msg = strings . TrimSpace ( msg ) clones := strings . Fields ( msg ) if len ( clones ) == 0 { return nil , db . ErrNoSuchObject } return clones , nil }
2685	func cephRBDVolumeMarkDeleted ( clusterName string , poolName string , volumeType string , oldVolumeName string , newVolumeName string , userName string , suffix string ) error { deletedName := fmt . Sprintf ( "%s/zombie_%s_%s" , poolName , volumeType , newVolumeName ) if suffix != "" { deletedName = fmt . Sprintf ( "%s_%s" , deletedName , suffix ) } _ , err := shared . RunCommand ( "rbd" , "--id" , userName , "--cluster" , clusterName , "mv" , fmt . Sprintf ( "%s/%s_%s" , poolName , volumeType , oldVolumeName ) , deletedName ) if err != nil { return err } return nil }
2686	func cephRBDVolumeUnmarkDeleted ( clusterName string , poolName string , volumeName string , volumeType string , userName string , oldSuffix string , newSuffix string ) error { oldName := fmt . Sprintf ( "%s/zombie_%s_%s" , poolName , volumeType , volumeName ) if oldSuffix != "" { oldName = fmt . Sprintf ( "%s_%s" , oldName , oldSuffix ) } newName := fmt . Sprintf ( "%s/%s_%s" , poolName , volumeType , volumeName ) if newSuffix != "" { newName = fmt . Sprintf ( "%s_%s" , newName , newSuffix ) } _ , err := shared . RunCommand ( "rbd" , "--id" , userName , "--cluster" , clusterName , "mv" , oldName , newName ) if err != nil { return err } return nil }
2687	func cephRBDVolumeRename ( clusterName string , poolName string , volumeType string , oldVolumeName string , newVolumeName string , userName string ) error { _ , err := shared . RunCommand ( "rbd" , "--id" , userName , "--cluster" , clusterName , "mv" , fmt . Sprintf ( "%s/%s_%s" , poolName , volumeType , oldVolumeName ) , fmt . Sprintf ( "%s/%s_%s" , poolName , volumeType , newVolumeName ) ) if err != nil { return err } return nil }
2688	func cephRBDVolumeSnapshotRename ( clusterName string , poolName string , volumeName string , volumeType string , oldSnapshotName string , newSnapshotName string , userName string ) error { _ , err := shared . RunCommand ( "rbd" , "--id" , userName , "--cluster" , clusterName , "snap" , "rename" , fmt . Sprintf ( "%s/%s_%s@%s" , poolName , volumeType , volumeName , oldSnapshotName ) , fmt . Sprintf ( "%s/%s_%s@%s" , poolName , volumeType , volumeName , newSnapshotName ) ) if err != nil { return err } return nil }
2689	func cephRBDSnapshotDelete ( clusterName string , poolName string , volumeName string , volumeType string , snapshotName string , userName string ) error { _ , err := shared . RunCommand ( "rbd" , "--id" , userName , "--cluster" , clusterName , "--pool" , poolName , "snap" , "rm" , fmt . Sprintf ( "%s_%s@%s" , volumeType , volumeName , snapshotName ) ) if err != nil { return err } return nil }
2690	func cephRBDVolumeCopy ( clusterName string , oldVolumeName string , newVolumeName string , userName string ) error { _ , err := shared . RunCommand ( "rbd" , "--id" , userName , "--cluster" , clusterName , "cp" , oldVolumeName , newVolumeName ) if err != nil { return err } return nil }
2691	func cephRBDVolumeListSnapshots ( clusterName string , poolName string , volumeName string , volumeType string , userName string ) ( [ ] string , error ) { msg , err := shared . RunCommand ( "rbd" , "--id" , userName , "--format" , "json" , "--cluster" , clusterName , "--pool" , poolName , "snap" , "ls" , fmt . Sprintf ( "%s_%s" , volumeType , volumeName ) ) if err != nil { return [ ] string { } , err } var data [ ] map [ string ] interface { } err = json . Unmarshal ( [ ] byte ( msg ) , & data ) if err != nil { return [ ] string { } , err } snapshots := [ ] string { } for _ , v := range data { _ , ok := v [ "name" ] if ! ok { return [ ] string { } , fmt . Errorf ( "No \"name\" property found" ) } \" \" name , ok := v [ "name" ] . ( string ) if ! ok { return [ ] string { } , fmt . Errorf ( "\"name\" property did not have string type" ) } } \" \" }
2692	func ( s * storageCeph ) getRBDSize ( ) ( string , error ) { sz , err := shared . ParseByteSizeString ( s . volume . Config [ "size" ] ) if err != nil { return "" , err } if sz == 0 { sz , _ = shared . ParseByteSizeString ( "10GB" ) } return fmt . Sprintf ( "%dB" , sz ) , nil }
2693	func ( s * storageCeph ) getRBDFilesystem ( ) string { if s . volume . Config [ "block.filesystem" ] != "" { return s . volume . Config [ "block.filesystem" ] } if s . pool . Config [ "volume.block.filesystem" ] != "" { return s . pool . Config [ "volume.block.filesystem" ] } return "ext4" }
2694	func ( s * storageCeph ) copyWithoutSnapshotsFull ( target container , source container ) error { logger . Debugf ( `Creating non-sparse copy of RBD storage volume for container "%s" to "%s" without snapshots` , source . Name ( ) , target . Name ( ) ) sourceIsSnapshot := source . IsSnapshot ( ) sourceContainerName := projectPrefix ( source . Project ( ) , source . Name ( ) ) targetContainerName := projectPrefix ( target . Project ( ) , target . Name ( ) ) oldVolumeName := fmt . Sprintf ( "%s/container_%s" , s . OSDPoolName , sourceContainerName ) newVolumeName := fmt . Sprintf ( "%s/container_%s" , s . OSDPoolName , targetContainerName ) if sourceIsSnapshot { sourceContainerOnlyName , sourceSnapshotOnlyName , _ := containerGetParentAndSnapshotName ( sourceContainerName ) oldVolumeName = fmt . Sprintf ( "%s/container_%s@snapshot_%s" , s . OSDPoolName , sourceContainerOnlyName , sourceSnapshotOnlyName ) } err := cephRBDVolumeCopy ( s . ClusterName , oldVolumeName , newVolumeName , s . UserName ) if err != nil { logger . Debugf ( `Failed to create full RBD copy "%s" to "%s": %s` , source . Name ( ) , target . Name ( ) , err ) return err } _ , err = cephRBDVolumeMap ( s . ClusterName , s . OSDPoolName , targetContainerName , storagePoolVolumeTypeNameContainer , s . UserName ) if err != nil { logger . Errorf ( `Failed to map RBD storage volume for image "%s" on storage pool "%s": %s` , targetContainerName , s . pool . Name , err ) return err } targetContainerMountPoint := getContainerMountPoint ( target . Project ( ) , s . pool . Name , target . Name ( ) ) err = createContainerMountpoint ( targetContainerMountPoint , target . Path ( ) , target . IsPrivileged ( ) ) if err != nil { return err } ourMount , err := target . StorageStart ( ) if err != nil { return err } if ourMount { defer target . StorageStop ( ) } err = target . TemplateApply ( "copy" ) if err != nil { logger . Errorf ( `Failed to apply copy template for container "%s": %s` , target . Name ( ) , err ) return err } logger . Debugf ( `Applied copy template for container "%s"` , target . Name ( ) ) logger . Debugf ( `Created non-sparse copy of RBD storage volume for container "%s" to "%s" without snapshots` , source . Name ( ) , target . Name ( ) ) return nil }
2695	func ( s * storageCeph ) copyWithoutSnapshotsSparse ( target container , source container ) error { logger . Debugf ( `Creating sparse copy of RBD storage volume for container "%s" to "%s" without snapshots` , source . Name ( ) , target . Name ( ) ) sourceIsSnapshot := source . IsSnapshot ( ) sourceContainerName := projectPrefix ( source . Project ( ) , source . Name ( ) ) targetContainerName := projectPrefix ( target . Project ( ) , target . Name ( ) ) sourceContainerOnlyName := sourceContainerName sourceSnapshotOnlyName := "" snapshotName := fmt . Sprintf ( "zombie_snapshot_%s" , uuid . NewRandom ( ) . String ( ) ) if sourceIsSnapshot { sourceContainerOnlyName , sourceSnapshotOnlyName , _ = containerGetParentAndSnapshotName ( sourceContainerName ) snapshotName = fmt . Sprintf ( "snapshot_%s" , sourceSnapshotOnlyName ) } else { err := cephRBDSnapshotCreate ( s . ClusterName , s . OSDPoolName , sourceContainerName , storagePoolVolumeTypeNameContainer , snapshotName , s . UserName ) if err != nil { logger . Errorf ( `Failed to create snapshot for RBD storage volume for image "%s" on storage pool "%s": %s` , targetContainerName , s . pool . Name , err ) return err } } err := cephRBDSnapshotProtect ( s . ClusterName , s . OSDPoolName , sourceContainerOnlyName , storagePoolVolumeTypeNameContainer , snapshotName , s . UserName ) if err != nil { logger . Errorf ( `Failed to protect snapshot for RBD storage volume for image "%s" on storage pool "%s": %s` , snapshotName , s . pool . Name , err ) return err } err = cephRBDCloneCreate ( s . ClusterName , s . OSDPoolName , sourceContainerOnlyName , storagePoolVolumeTypeNameContainer , snapshotName , s . OSDPoolName , targetContainerName , storagePoolVolumeTypeNameContainer , s . UserName ) if err != nil { logger . Errorf ( `Failed to clone new RBD storage volume for container "%s": %s` , targetContainerName , err ) return err } err = s . cephRBDGenerateUUID ( projectPrefix ( target . Project ( ) , target . Name ( ) ) , storagePoolVolumeTypeNameContainer ) if err != nil { return err } targetContainerMountPoint := getContainerMountPoint ( target . Project ( ) , s . pool . Name , target . Name ( ) ) err = createContainerMountpoint ( targetContainerMountPoint , target . Path ( ) , target . IsPrivileged ( ) ) if err != nil { return err } ourMount , err := target . StorageStart ( ) if err != nil { return err } if ourMount { defer target . StorageStop ( ) } err = target . TemplateApply ( "copy" ) if err != nil { logger . Errorf ( `Failed to apply copy template for container "%s": %s` , target . Name ( ) , err ) return err } logger . Debugf ( `Applied copy template for container "%s"` , target . Name ( ) ) logger . Debugf ( `Created sparse copy of RBD storage volume for container "%s" to "%s" without snapshots` , source . Name ( ) , target . Name ( ) ) return nil }
2696	func GetConfigCmd ( noPortForwarding * bool ) * cobra . Command { var format string getConfig := & cobra . Command { Short : "Retrieve Pachyderm's current auth configuration" , Long : "Retrieve Pachyderm's current auth configuration" , Run : cmdutil . RunFixedArgs ( 0 , func ( args [ ] string ) error { c , err := client . NewOnUserMachine ( true , ! * noPortForwarding , "user" ) if err != nil { return fmt . Errorf ( "could not connect: %v" , err ) } defer c . Close ( ) resp , err := c . GetConfiguration ( c . Ctx ( ) , & auth . GetConfigurationRequest { } ) if err != nil { return grpcutil . ScrubGRPC ( err ) } if resp . Configuration == nil { fmt . Println ( "no auth config set" ) return nil } output , err := json . MarshalIndent ( resp . Configuration , "" , " " ) if err != nil { return fmt . Errorf ( "could not marshal response:\n%v\ndue to: %v" , \n , \n ) } resp . Configuration err switch format { case "json" : case "yaml" : output , err = yaml . JSONToYAML ( output ) if err != nil { return fmt . Errorf ( "could not convert json to yaml: %v" , err ) } default : return fmt . Errorf ( "invalid output format: %v" , format ) } } ) , } fmt . Println ( string ( output ) ) return nil }
2697	func SetConfigCmd ( noPortForwarding * bool ) * cobra . Command { var file string setConfig := & cobra . Command { Short : "Set Pachyderm's current auth configuration" , Long : "Set Pachyderm's current auth configuration" , Run : cmdutil . RunFixedArgs ( 0 , func ( args [ ] string ) error { c , err := client . NewOnUserMachine ( true , ! * noPortForwarding , "user" ) if err != nil { return fmt . Errorf ( "could not connect: %v" , err ) } defer c . Close ( ) var configBytes [ ] byte if file == "-" { var err error configBytes , err = ioutil . ReadAll ( os . Stdin ) if err != nil { return fmt . Errorf ( "could not read config from stdin: %v" , err ) } } else if file != "" { var err error configBytes , err = ioutil . ReadFile ( file ) if err != nil { return fmt . Errorf ( "could not read config from %q: %v" , file , err ) } } else { return errors . New ( "must set input file (use \"-\" to read from stdin)" ) } \" \" var config auth . AuthConfig if err := yaml . Unmarshal ( configBytes , & config ) ; err != nil { return fmt . Errorf ( "could not parse config: %v" , err ) } } ) , } _ , err = c . SetConfiguration ( c . Ctx ( ) , & auth . SetConfigurationRequest { Configuration : & config , } ) return grpcutil . ScrubGRPC ( err ) }
2698	func NewSharder ( discoveryClient discovery . Client , numShards uint64 , namespace string ) Sharder { return newSharder ( discoveryClient , numShards , namespace ) }
2699	func NewRouter ( sharder Sharder , dialer grpcutil . Dialer , localAddress string , ) Router { return newRouter ( sharder , dialer , localAddress , ) }
2700	func renewUserCredentials ( ctx context . Context , pachdAddress string , adminToken string , userToken string , ttl time . Duration ) error { client , err := pclient . NewFromAddress ( pachdAddress ) if err != nil { return err } defer client . Close ( ) client = client . WithCtx ( ctx ) client . SetAuthToken ( adminToken ) _ , err = client . AuthAPIClient . ExtendAuthToken ( client . Ctx ( ) , & auth . ExtendAuthTokenRequest { Token : userToken , TTL : int64 ( ttl . Seconds ( ) ) , } ) if err != nil { return err } return nil }
2701	func NewLocalClient ( root string ) ( Client , error ) { if err := os . MkdirAll ( root , 0755 ) ; err != nil { return nil , err } return & localClient { root } , nil }
2702	func AddSpanToAnyExisting ( ctx context . Context , operation string , kvs ... interface { } ) ( opentracing . Span , context . Context ) { if parentSpan := opentracing . SpanFromContext ( ctx ) ; parentSpan != nil { span := opentracing . StartSpan ( operation , opentracing . ChildOf ( parentSpan . Context ( ) ) ) tagSpan ( span , kvs ) return span , opentracing . ContextWithSpan ( ctx , span ) } return nil , ctx }
2703	func InstallJaegerTracerFromEnv ( ) { jaegerOnce . Do ( func ( ) { jaegerEndpoint , onUserMachine := os . LookupEnv ( jaegerEndpointEnvVar ) if ! onUserMachine { if host , ok := os . LookupEnv ( "JAEGER_COLLECTOR_SERVICE_HOST" ) ; ok { port := os . Getenv ( "JAEGER_COLLECTOR_SERVICE_PORT_JAEGER_COLLECTOR_HTTP" ) jaegerEndpoint = fmt . Sprintf ( "%s:%s" , host , port ) } } if jaegerEndpoint == "" { return } jaegerEndpoint = strings . TrimPrefix ( jaegerEndpoint , "http://" ) jaegerEndpoint = strings . TrimSuffix ( jaegerEndpoint , "/api/traces" ) jaegerEndpoint = fmt . Sprintf ( "http://%s/api/traces" , jaegerEndpoint ) cfg := jaegercfg . Configuration { Sampler : & jaegercfg . SamplerConfig { Type : "const" , Param : 1 , } , Reporter : & jaegercfg . ReporterConfig { LogSpans : true , BufferFlushInterval : 1 * time . Second , CollectorEndpoint : jaegerEndpoint , } , } logger := jaeger . Logger ( jaeger . NullLogger ) if ! onUserMachine { logger = jaeger . StdLogger } tracer , _ , err := cfg . New ( JaegerServiceName , jaegercfg . Logger ( logger ) ) if err != nil { panic ( fmt . Sprintf ( "could not install Jaeger tracer: %v" , err ) ) } opentracing . SetGlobalTracer ( tracer ) } ) }
2704	func UnaryClientInterceptor ( ) grpc . UnaryClientInterceptor { return otgrpc . OpenTracingClientInterceptor ( opentracing . GlobalTracer ( ) , otgrpc . IncludingSpans ( addTraceIfTracingEnabled ) ) }
2705	func StreamClientInterceptor ( ) grpc . StreamClientInterceptor { return otgrpc . OpenTracingStreamClientInterceptor ( opentracing . GlobalTracer ( ) , otgrpc . IncludingSpans ( addTraceIfTracingEnabled ) ) }
2706	func UnaryServerInterceptor ( ) grpc . UnaryServerInterceptor { return otgrpc . OpenTracingServerInterceptor ( opentracing . GlobalTracer ( ) , otgrpc . IncludingSpans ( addTraceIfTracingEnabled ) ) }
2707	func StreamServerInterceptor ( ) grpc . StreamServerInterceptor { return otgrpc . OpenTracingStreamServerInterceptor ( opentracing . GlobalTracer ( ) , otgrpc . IncludingSpans ( addTraceIfTracingEnabled ) ) }
2708	func CloseAndReportTraces ( ) { if c , ok := opentracing . GlobalTracer ( ) . ( io . Closer ) ; ok { c . Close ( ) } }
2709	func newWriter ( ctx context . Context , objC obj . Client , prefix string ) * Writer { hash := buzhash64 . New ( ) hash . Write ( make ( [ ] byte , WindowSize ) ) return & Writer { ctx : ctx , objC : objC , prefix : prefix , cbs : [ ] func ( [ ] * DataRef ) error { } , buf : & bytes . Buffer { } , hash : hash , splitMask : ( 1 << uint64 ( AverageBits ) ) - 1 , } }
2710	func ( b * ConstantBackOff ) For ( maxElapsed time . Duration ) * ConstantBackOff { b . MaxElapsedTime = maxElapsed return b }
2711	func ( l * logger ) Log ( request interface { } , response interface { } , err error , duration time . Duration ) { if err != nil { l . LogAtLevelFromDepth ( request , response , err , duration , logrus . ErrorLevel , 4 ) } else { l . LogAtLevelFromDepth ( request , response , err , duration , logrus . InfoLevel , 4 ) } go l . ReportMetric ( getMethodName ( ) , duration , err ) }
2712	func ( f FormatterFunc ) Format ( entry * logrus . Entry ) ( [ ] byte , error ) { return f ( entry ) }
2713	func NewGRPCLogWriter ( logger * logrus . Logger , source string ) * GRPCLogWriter { return & GRPCLogWriter { logger : logger , source : source , } }
2714	func Read ( ) ( * Config , error ) { var c * Config p := configPath ( ) if raw , err := ioutil . ReadFile ( p ) ; err == nil { err = json . Unmarshal ( raw , & c ) if err != nil { return nil , err } } else if os . IsNotExist ( err ) { fmt . Println ( "no config detected at %q. Generating new config..." , p ) c = & Config { } } else { return nil , fmt . Errorf ( "fatal: could not read config at %q: %v" , p , err ) } if c . UserID == "" { fmt . Printf ( "No UserID present in config. Generating new UserID and " + "updating config at %s\n" , \n ) p uuid , err := uuid . NewV4 ( ) if err != nil { return nil , err } c . UserID = uuid . String ( ) } if err := c . Write ( ) ; err != nil { return nil , err } }
2715	func ( c * Config ) Write ( ) error { rawConfig , err := json . MarshalIndent ( c , "" , " " ) if err != nil { return err } p := configPath ( ) if _ , ok := os . LookupEnv ( configEnvVar ) ; ok { d := filepath . Dir ( p ) if _ , err := os . Stat ( d ) ; err != nil { return fmt . Errorf ( "cannot use config at %s: could not stat parent directory (%v)" , p , err ) } } else { err = os . MkdirAll ( defaultConfigDir , 0755 ) if err != nil { return err } } return ioutil . WriteFile ( p , rawConfig , 0644 ) }
2716	func ( r * readWriter ) Read ( val proto . Message ) error { buf , err := r . ReadBytes ( ) if err != nil { return err } return proto . Unmarshal ( buf , val ) }
2717	func ( r * readWriter ) Write ( val proto . Message ) ( int64 , error ) { bytes , err := proto . Marshal ( val ) if err != nil { return 0 , err } return r . WriteBytes ( bytes ) }
2718	func NewReadWriter ( rw io . ReadWriter ) ReadWriter { return & readWriter { r : rw , w : rw } }
2719	func RunGitHookServer ( address string , etcdAddress string , etcdPrefix string ) error { c , err := client . NewFromAddress ( address ) if err != nil { return err } etcdClient , err := etcd . New ( etcd . Config { Endpoints : [ ] string { etcdAddress } , DialOptions : client . DefaultDialOptions ( ) , } ) if err != nil { return err } hook , err := github . New ( ) if err != nil { return err } s := & gitHookServer { hook , c , etcdClient , ppsdb . Pipelines ( etcdClient , etcdPrefix ) , } return http . ListenAndServe ( fmt . Sprintf ( ":%d" , GitHookPort ) , s ) }
2720	func newLoggingPipe ( ) * loggingPipe { p := & loggingPipe { } p . clientReader , p . clientWriter = io . Pipe ( ) p . clientReader = io . TeeReader ( p . clientReader , & p . ServerToClientBuf ) p . serverReader , p . serverWriter = io . Pipe ( ) p . serverReader = io . TeeReader ( p . serverReader , & p . ClientToServerBuf ) return p }
2721	func ( l * loggingConn ) Read ( b [ ] byte ) ( n int , err error ) { return l . r . Read ( b ) }
2722	func ( l * loggingConn ) Write ( b [ ] byte ) ( n int , err error ) { return l . w . Write ( b ) }
2723	func ( l * TestListener ) Accept ( ) ( net . Conn , error ) { conn := <- l . connCh if conn == nil { return nil , errors . New ( "Accept() has already been called on this TestListener" ) } return conn , nil }
2724	func ( l * TestListener ) Close ( ) error { l . connMu . Lock ( ) defer l . connMu . Unlock ( ) c := <- l . connCh if c != nil { close ( l . connCh ) } return nil }
2725	func errorf ( c ErrCode , fmtStr string , args ... interface { } ) error { return & hashTreeError { code : c , s : fmt . Sprintf ( fmtStr , args ... ) , } }
2726	func InitWithKube ( config * Configuration ) * ServiceEnv { env := InitServiceEnv ( config ) env . kubeEg . Go ( env . initKubeClient ) return env }
2727	func ( env * ServiceEnv ) GetEtcdClient ( ) * etcd . Client { if err := env . etcdEg . Wait ( ) ; err != nil { panic ( err ) } if env . etcdClient == nil { panic ( "service env never connected to etcd" ) } return env . etcdClient }
2728	func ( env * ServiceEnv ) GetKubeClient ( ) * kube . Clientset { if err := env . kubeEg . Wait ( ) ; err != nil { panic ( err ) } if env . kubeClient == nil { panic ( "service env never connected to kubernetes" ) } return env . kubeClient }
2729	func NewHasher ( jobModulus uint64 , pipelineModulus uint64 ) * Hasher { return & Hasher { JobModulus : jobModulus , PipelineModulus : pipelineModulus , } }
2730	func ( s * Hasher ) HashJob ( jobID string ) uint64 { return uint64 ( adler32 . Checksum ( [ ] byte ( jobID ) ) ) % s . JobModulus }
2731	func ( s * Hasher ) HashPipeline ( pipelineName string ) uint64 { return uint64 ( adler32 . Checksum ( [ ] byte ( pipelineName ) ) ) % s . PipelineModulus }
2732	func Status ( ctx context . Context , pipelineRcName string , etcdClient * etcd . Client , etcdPrefix string , workerGrpcPort uint16 ) ( [ ] * pps . WorkerStatus , error ) { workerClients , err := Clients ( ctx , pipelineRcName , etcdClient , etcdPrefix , workerGrpcPort ) if err != nil { return nil , err } var result [ ] * pps . WorkerStatus for _ , workerClient := range workerClients { status , err := workerClient . Status ( ctx , & types . Empty { } ) if err != nil { return nil , err } result = append ( result , status ) } return result , nil }
2733	func Cancel ( ctx context . Context , pipelineRcName string , etcdClient * etcd . Client , etcdPrefix string , workerGrpcPort uint16 , jobID string , dataFilter [ ] string ) error { workerClients , err := Clients ( ctx , pipelineRcName , etcdClient , etcdPrefix , workerGrpcPort ) if err != nil { return err } success := false for _ , workerClient := range workerClients { resp , err := workerClient . Cancel ( ctx , & CancelRequest { JobID : jobID , DataFilters : dataFilter , } ) if err != nil { return err } if resp . Success { success = true } } if ! success { return fmt . Errorf ( "datum matching filter %+v could not be found for jobID %s" , dataFilter , jobID ) } return nil }
2734	func Conns ( ctx context . Context , pipelineRcName string , etcdClient * etcd . Client , etcdPrefix string , workerGrpcPort uint16 ) ( [ ] * grpc . ClientConn , error ) { resp , err := etcdClient . Get ( ctx , path . Join ( etcdPrefix , WorkerEtcdPrefix , pipelineRcName ) , etcd . WithPrefix ( ) ) if err != nil { return nil , err } var result [ ] * grpc . ClientConn for _ , kv := range resp . Kvs { conn , err := grpc . Dial ( fmt . Sprintf ( "%s:%d" , path . Base ( string ( kv . Key ) ) , workerGrpcPort ) , append ( client . DefaultDialOptions ( ) , grpc . WithInsecure ( ) ) ... ) if err != nil { return nil , err } result = append ( result , conn ) } return result , nil }
2735	func Clients ( ctx context . Context , pipelineRcName string , etcdClient * etcd . Client , etcdPrefix string , workerGrpcPort uint16 ) ( [ ] Client , error ) { conns , err := Conns ( ctx , pipelineRcName , etcdClient , etcdPrefix , workerGrpcPort ) if err != nil { return nil , err } var result [ ] Client for _ , conn := range conns { result = append ( result , newClient ( conn ) ) } return result , nil }
2736	func NewClient ( address string ) ( Client , error ) { port , err := strconv . Atoi ( os . Getenv ( client . PPSWorkerPortEnv ) ) if err != nil { return Client { } , err } conn , err := grpc . Dial ( fmt . Sprintf ( "%s:%d" , address , port ) , append ( client . DefaultDialOptions ( ) , grpc . WithInsecure ( ) ) ... ) if err != nil { return Client { } , err } return newClient ( conn ) , nil }
2737	func RunFixedArgs ( numArgs int , run func ( [ ] string ) error ) func ( * cobra . Command , [ ] string ) { return func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) != numArgs { fmt . Printf ( "expected %d arguments, got %d\n\n" , \n , \n ) numArgs } else len ( args ) } }
2738	func RunBoundedArgs ( min int , max int , run func ( [ ] string ) error ) func ( * cobra . Command , [ ] string ) { return func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) < min || len ( args ) > max { fmt . Printf ( "expected %d to %d arguments, got %d\n\n" , \n , \n , min ) max } else len ( args ) } }
2739	func Run ( run func ( args [ ] string ) error ) func ( * cobra . Command , [ ] string ) { return func ( _ * cobra . Command , args [ ] string ) { if err := run ( args ) ; err != nil { ErrorAndExit ( err . Error ( ) ) } } }
2740	func ErrorAndExit ( format string , args ... interface { } ) { if errString := strings . TrimSpace ( fmt . Sprintf ( format , args ... ) ) ; errString != "" { fmt . Fprintf ( os . Stderr , "%s\n" , \n ) } errString }
2741	func ParseCommit ( arg string ) ( * pfs . Commit , error ) { parts := strings . SplitN ( arg , "@" , 2 ) if parts [ 0 ] == "" { return nil , fmt . Errorf ( "invalid format \"%s\": repo cannot be empty" , \" ) } \" arg commit := & pfs . Commit { Repo : & pfs . Repo { Name : parts [ 0 ] , } , ID : "" , } }
2742	func ParseBranch ( arg string ) ( * pfs . Branch , error ) { commit , err := ParseCommit ( arg ) if err != nil { return nil , err } return & pfs . Branch { Repo : commit . Repo , Name : commit . ID } , nil }
2743	func ParseFile ( arg string ) ( * pfs . File , error ) { repoAndRest := strings . SplitN ( arg , "@" , 2 ) if repoAndRest [ 0 ] == "" { return nil , fmt . Errorf ( "invalid format \"%s\": repo cannot be empty" , \" ) } \" arg file := & pfs . File { Commit : & pfs . Commit { Repo : & pfs . Repo { Name : repoAndRest [ 0 ] , } , ID : "" , } , Path : "" , } }
2744	func ( r * RepeatedStringArg ) Set ( s string ) error { * r = append ( * r , s ) return nil }
2745	func SetDocsUsage ( command * cobra . Command ) { command . SetHelpTemplate ( `{{or .Long .Short}}{{.UsageString}}` ) command . SetUsageFunc ( func ( cmd * cobra . Command ) error { rootCmd := cmd . Root ( ) var associated [ ] * cobra . Command var walk func ( * cobra . Command ) walk = func ( cursor * cobra . Command ) { if cursor . Name ( ) == cmd . Name ( ) && cursor . CommandPath ( ) != cmd . CommandPath ( ) { associated = append ( associated , cursor ) } for _ , subcmd := range cursor . Commands ( ) { walk ( subcmd ) } } walk ( rootCmd ) var maxCommandPath int for _ , x := range associated { commandPathLen := len ( x . CommandPath ( ) ) if commandPathLen > maxCommandPath { maxCommandPath = commandPathLen } } templateFuncs := template . FuncMap { "pad" : func ( s string ) string { format := fmt . Sprintf ( "%%-%ds" , maxCommandPath + 1 ) return fmt . Sprintf ( format , s ) } , "associated" : func ( ) [ ] * cobra . Command { return associated } , } text := `Associated Commands:{{range associated}}{{if .IsAvailableCommand}} {{pad .CommandPath}} {{.Short}}{{end}}{{end}}` t := template . New ( "top" ) t . Funcs ( templateFuncs ) template . Must ( t . Parse ( text ) ) return t . Execute ( cmd . Out ( ) , cmd ) } ) }
2746	func ( a * apiServer ) makeCronCommits ( pachClient * client . APIClient , in * pps . Input ) error { schedule , err := cron . ParseStandard ( in . Cron . Spec ) if err != nil { return err } commitInfo , err := pachClient . InspectCommit ( in . Cron . Repo , "master" ) if err != nil && ! isNilBranchErr ( err ) { return err } else if commitInfo != nil && commitInfo . Finished == nil { if err = pachClient . DeleteCommit ( in . Cron . Repo , "master" ) ; err != nil { return err } } var latestTime time . Time files , err := pachClient . ListFile ( in . Cron . Repo , "master" , "" ) if err != nil && ! isNilBranchErr ( err ) { return err } else if err != nil || len ( files ) == 0 { latestTime , err = types . TimestampFromProto ( in . Cron . Start ) if err != nil { return err } } else { latestTime , err = time . Parse ( time . RFC3339 , path . Base ( files [ len ( files ) - 1 ] . File . Path ) ) if err != nil { return err } } for { next := schedule . Next ( latestTime ) time . Sleep ( time . Until ( next ) ) if err != nil { return err } _ , err = pachClient . StartCommit ( in . Cron . Repo , "master" ) if err != nil { return err } if in . Cron . Overwrite { err := pachClient . DeleteFile ( in . Cron . Repo , "master" , latestTime . Format ( time . RFC3339 ) ) if err != nil && ! isNotFoundErr ( err ) && ! isNilBranchErr ( err ) { return fmt . Errorf ( "delete error %v" , err ) } } _ , err = pachClient . PutFile ( in . Cron . Repo , "master" , next . Format ( time . RFC3339 ) , strings . NewReader ( "" ) ) if err != nil { return fmt . Errorf ( "put error %v" , err ) } err = pachClient . FinishCommit ( in . Cron . Repo , "master" ) if err != nil { return err } latestTime = next } }
2747	func ( o * tracingObjClient ) Writer ( ctx context . Context , name string ) ( io . WriteCloser , error ) { span , ctx := tracing . AddSpanToAnyExisting ( ctx , o . provider + ".Writer" , "name" , name ) if span != nil { defer span . Finish ( ) } return o . Client . Writer ( ctx , name ) }
2748	func ( o * tracingObjClient ) Reader ( ctx context . Context , name string , offset uint64 , size uint64 ) ( io . ReadCloser , error ) { span , ctx := tracing . AddSpanToAnyExisting ( ctx , o . provider + ".Reader" , "name" , name , "offset" , fmt . Sprintf ( "%d" , offset ) , "size" , fmt . Sprintf ( "%d" , size ) ) defer tracing . FinishAnySpan ( span ) return o . Client . Reader ( ctx , name , offset , size ) }
2749	func ( o * tracingObjClient ) Delete ( ctx context . Context , name string ) error { span , ctx := tracing . AddSpanToAnyExisting ( ctx , o . provider + ".Delete" , "name" , name ) defer tracing . FinishAnySpan ( span ) return o . Client . Delete ( ctx , name ) }
2750	func ( o * tracingObjClient ) Walk ( ctx context . Context , prefix string , fn func ( name string ) error ) error { span , ctx := tracing . AddSpanToAnyExisting ( ctx , o . provider + ".Walk" , "prefix" , prefix ) defer tracing . FinishAnySpan ( span ) return o . Client . Walk ( ctx , prefix , fn ) }
2751	func ( o * tracingObjClient ) Exists ( ctx context . Context , name string ) bool { span , ctx := tracing . AddSpanToAnyExisting ( ctx , o . provider + ".Exists" , "name" , name ) defer tracing . FinishAnySpan ( span ) return o . Client . Exists ( ctx , name ) }
2752	func GetBlock ( hash hash . Hash ) * Block { return & Block { Hash : base64 . URLEncoding . EncodeToString ( hash . Sum ( nil ) ) , } }
2753	func ( h * healthServer ) Health ( context . Context , * types . Empty ) ( * types . Empty , error ) { if ! h . ready { return nil , fmt . Errorf ( "server not ready" ) } return & types . Empty { } , nil }
2754	func split ( p string ) ( string , string ) { return clean ( path . Dir ( p ) ) , base ( p ) }
2755	func ValidatePath ( path string ) error { path = clean ( path ) match , _ := regexp . MatchString ( "^[ -~]+$" , path ) if ! match { return fmt . Errorf ( "path (%v) invalid: only printable ASCII characters allowed" , path ) } if IsGlob ( path ) { return fmt . Errorf ( "path (%v) invalid: globbing character (%v) not allowed in path" , path , globRegex . FindString ( path ) ) } return nil }
2756	func MatchDatum ( filter [ ] string , data [ ] * pps . InputFile ) bool { matchesData := true dataFilters : for _ , dataFilter := range filter { for _ , datum := range data { if dataFilter == datum . Path || dataFilter == base64 . StdEncoding . EncodeToString ( datum . Hash ) || dataFilter == hex . EncodeToString ( datum . Hash ) { continue dataFilters } } matchesData = false break } return matchesData }
2757	func NewCacheServer ( router shard . Router , shards uint64 ) CacheServer { server := & groupCacheServer { Logger : log . NewLogger ( "CacheServer" ) , router : router , localShards : make ( map [ uint64 ] bool ) , shards : shards , } groupcache . RegisterPeerPicker ( func ( ) groupcache . PeerPicker { return server } ) return server }
2758	func ( a * apiServer ) authorizePipelineOp ( pachClient * client . APIClient , operation pipelineOperation , input * pps . Input , output string ) error { ctx := pachClient . Ctx ( ) me , err := pachClient . WhoAmI ( ctx , & auth . WhoAmIRequest { } ) if auth . IsErrNotActivated ( err ) { return nil } else if err != nil { return err } if input != nil { var eg errgroup . Group done := make ( map [ string ] struct { } ) pps . VisitInput ( input , func ( in * pps . Input ) { var repo string if in . Pfs != nil { repo = in . Pfs . Repo } else { return } if _ , ok := done [ repo ] ; ok { return } done [ repo ] = struct { } { } eg . Go ( func ( ) error { resp , err := pachClient . Authorize ( ctx , & auth . AuthorizeRequest { Repo : repo , Scope : auth . Scope_READER , } ) if err != nil { return err } if ! resp . Authorized { return & auth . ErrNotAuthorized { Subject : me . Username , Repo : repo , Required : auth . Scope_READER , } } return nil } ) } ) if err := eg . Wait ( ) ; err != nil { return err } } var required auth . Scope switch operation { case pipelineOpCreate : if _ , err := pachClient . InspectRepo ( output ) ; err == nil { return fmt . Errorf ( "cannot overwrite repo \"%s\" with new output repo" , \" ) } else \" output if ! isNotFoundErr ( err ) { return err } case pipelineOpListDatum , pipelineOpGetLogs : required = auth . Scope_READER case pipelineOpUpdate : required = auth . Scope_WRITER } case pipelineOpDelete : required = auth . Scope_OWNER default : return fmt . Errorf ( "internal error, unrecognized operation %v" , operation ) }
2759	func ( a * apiServer ) sudo ( pachClient * client . APIClient , f func ( * client . APIClient ) error ) error { superUserTokenOnce . Do ( func ( ) { b := backoff . NewExponentialBackOff ( ) b . MaxElapsedTime = 60 * time . Second b . MaxInterval = 5 * time . Second if err := backoff . Retry ( func ( ) error { superUserTokenCol := col . NewCollection ( a . env . GetEtcdClient ( ) , ppsconsts . PPSTokenKey , nil , & types . StringValue { } , nil , nil ) . ReadOnly ( pachClient . Ctx ( ) ) var result types . StringValue if err := superUserTokenCol . Get ( "" , & result ) ; err != nil { return err } superUserToken = result . Value return nil } , b ) ; err != nil { panic ( fmt . Sprintf ( "couldn't get PPS superuser token: %v" , err ) ) } } ) superUserClient := pachClient . WithCtx ( pachClient . Ctx ( ) ) superUserClient . SetAuthToken ( superUserToken ) return f ( superUserClient ) }
2760	func setPipelineDefaults ( pipelineInfo * pps . PipelineInfo ) { now := time . Now ( ) if pipelineInfo . Transform . Image == "" { pipelineInfo . Transform . Image = DefaultUserImage } pps . VisitInput ( pipelineInfo . Input , func ( input * pps . Input ) { if input . Pfs != nil { if input . Pfs . Branch == "" { input . Pfs . Branch = "master" } if input . Pfs . Name == "" { input . Pfs . Name = input . Pfs . Repo } } if input . Cron != nil { if input . Cron . Start == nil { start , _ := types . TimestampProto ( now ) input . Cron . Start = start } if input . Cron . Repo == "" { input . Cron . Repo = fmt . Sprintf ( "%s_%s" , pipelineInfo . Pipeline . Name , input . Cron . Name ) } } if input . Git != nil { if input . Git . Branch == "" { input . Git . Branch = "master" } if input . Git . Name == "" { tokens := strings . Split ( path . Base ( input . Git . URL ) , "." ) input . Git . Name = tokens [ 0 ] } } } ) if pipelineInfo . OutputBranch == "" { pipelineInfo . OutputBranch = "master" } if pipelineInfo . CacheSize == "" { pipelineInfo . CacheSize = "64M" } if pipelineInfo . ResourceRequests == nil && pipelineInfo . CacheSize != "" { pipelineInfo . ResourceRequests = & pps . ResourceSpec { Memory : pipelineInfo . CacheSize , } } if pipelineInfo . MaxQueueSize < 1 { pipelineInfo . MaxQueueSize = 1 } if pipelineInfo . DatumTries == 0 { pipelineInfo . DatumTries = DefaultDatumTries } }
2761	func ( a * apiServer ) incrementGCGeneration ( ctx context . Context ) error { resp , err := a . env . GetEtcdClient ( ) . Get ( ctx , client . GCGenerationKey ) if err != nil { return err } if resp . Count == 0 { if _ , err := a . env . GetEtcdClient ( ) . Put ( ctx , client . GCGenerationKey , "1" ) ; err != nil { return err } } else { oldGen , err := strconv . Atoi ( string ( resp . Kvs [ 0 ] . Value ) ) if err != nil { return err } newGen := oldGen + 1 if _ , err := a . env . GetEtcdClient ( ) . Put ( ctx , client . GCGenerationKey , strconv . Itoa ( newGen ) ) ; err != nil { return err } } return nil }
2762	func NewDebugServer ( name string , etcdClient * etcd . Client , etcdPrefix string , workerGrpcPort uint16 ) debug . DebugServer { return & debugServer { name : name , etcdClient : etcdClient , etcdPrefix : etcdPrefix , workerGrpcPort : workerGrpcPort , } }
2763	func ( c APIClient ) Health ( ) error { _ , err := c . healthClient . Health ( c . Ctx ( ) , & types . Empty { } ) return grpcutil . ScrubGRPC ( err ) }
2764	func newObjBlockAPIServer ( dir string , cacheBytes int64 , etcdAddress string , objClient obj . Client , test bool ) ( * objBlockAPIServer , error ) { if err := obj . TestStorage ( context . Background ( ) , objClient ) ; err != nil { return nil , err } oneCacheShare := cacheBytes / ( objectCacheShares + tagCacheShares + objectInfoCacheShares + blockCacheShares ) s := & objBlockAPIServer { Logger : log . NewLogger ( "pfs.BlockAPI.Obj" ) , dir : dir , objClient : objClient , objectIndexes : make ( map [ string ] * pfsclient . ObjectIndex ) , objectCacheBytes : oneCacheShare * objectCacheShares , } objectGroupName := "object" tagGroupName := "tag" objectInfoGroupName := "objectInfo" blockGroupName := "block" if test { uuid := uuid . New ( ) objectGroupName += uuid tagGroupName += uuid objectInfoGroupName += uuid blockGroupName += uuid } s . objectCache = groupcache . NewGroup ( objectGroupName , oneCacheShare * objectCacheShares , groupcache . GetterFunc ( s . objectGetter ) ) s . tagCache = groupcache . NewGroup ( tagGroupName , oneCacheShare * tagCacheShares , groupcache . GetterFunc ( s . tagGetter ) ) s . objectInfoCache = groupcache . NewGroup ( objectInfoGroupName , oneCacheShare * objectInfoCacheShares , groupcache . GetterFunc ( s . objectInfoGetter ) ) s . blockCache = groupcache . NewGroup ( blockGroupName , oneCacheShare * blockCacheShares , groupcache . GetterFunc ( s . blockGetter ) ) if ! test { RegisterCacheStats ( "tag" , & s . tagCache . Stats ) RegisterCacheStats ( "object" , & s . objectCache . Stats ) RegisterCacheStats ( "object_info" , & s . objectInfoCache . Stats ) } go s . watchGC ( etcdAddress ) return s , nil }
2765	func ( s * objBlockAPIServer ) watchGC ( etcdAddress string ) { b := backoff . NewInfiniteBackOff ( ) backoff . RetryNotify ( func ( ) error { etcdClient , err := etcd . New ( etcd . Config { Endpoints : [ ] string { etcdAddress } , DialOptions : client . DefaultDialOptions ( ) , } ) if err != nil { return fmt . Errorf ( "error instantiating etcd client: %v" , err ) } watcher , err := watch . NewWatcher ( context . Background ( ) , etcdClient , "" , client . GCGenerationKey , nil ) if err != nil { return fmt . Errorf ( "error instantiating watch stream from generation number: %v" , err ) } defer watcher . Close ( ) for { ev , ok := <- watcher . Watch ( ) if ev . Err != nil { return fmt . Errorf ( "error from generation number watch: %v" , ev . Err ) } if ! ok { return fmt . Errorf ( "generation number watch stream closed unexpectedly" ) } newGen , err := strconv . Atoi ( string ( ev . Value ) ) if err != nil { return fmt . Errorf ( "error converting the generation number: %v" , err ) } s . setGeneration ( newGen ) } } , b , func ( err error , d time . Duration ) error { logrus . Errorf ( "error running GC watcher in block server: %v; retrying in %s" , err , d ) return nil } ) }
2766	func ( s * objBlockAPIServer ) splitKey ( key string ) string { gen := s . getGeneration ( ) if len ( key ) < prefixLength { return fmt . Sprintf ( "%s.%d" , key , gen ) } return fmt . Sprintf ( "%s.%s.%d" , key [ : prefixLength ] , key [ prefixLength : ] , gen ) }
2767	func NewWriter ( w io . Writer , header string ) * Writer { if header [ len ( header ) - 1 ] != '\n' { panic ( "header must end in a new line" ) } tabwriter := ansiterm . NewTabWriter ( w , 0 , 1 , 1 , ' ' , 0 ) tabwriter . Write ( [ ] byte ( header ) ) return & Writer { w : tabwriter , lines : 1 , header : [ ] byte ( header ) , } }
2768	func ( w * Writer ) Write ( buf [ ] byte ) ( int , error ) { if w . lines >= termHeight { if err := w . Flush ( ) ; err != nil { return 0 , err } if _ , err := w . w . Write ( w . header ) ; err != nil { return 0 , err } w . lines ++ } w . lines += bytes . Count ( buf , [ ] byte { '\n' } ) return w . w . Write ( buf ) }
2769	func PrintRepoHeader ( w io . Writer , printAuth bool ) { if printAuth { fmt . Fprint ( w , RepoAuthHeader ) return } fmt . Fprint ( w , RepoHeader ) }
2770	func PrintRepoInfo ( w io . Writer , repoInfo * pfs . RepoInfo , fullTimestamps bool ) { fmt . Fprintf ( w , "%s\t" , \t ) repoInfo . Repo . Name if fullTimestamps { fmt . Fprintf ( w , "%s\t" , \t ) } else repoInfo . Created . String ( ) { fmt . Fprintf ( w , "%s\t" , \t ) } pretty . Ago ( repoInfo . Created ) }
2771	func PrintDetailedRepoInfo ( repoInfo * PrintableRepoInfo ) error { template , err := template . New ( "RepoInfo" ) . Funcs ( funcMap ) . Parse ( `Name: {{.Repo.Name}}{{if .Description}}Description: {{.Description}}{{end}}{{if .FullTimestamps}}Created: {{.Created}}{{else}}Created: {{prettyAgo .Created}}{{end}}Size of HEAD on master: {{prettySize .SizeBytes}}{{if .AuthInfo}}Access level: {{ .AuthInfo.AccessLevel.String }}{{end}}` ) if err != nil { return err } err = template . Execute ( os . Stdout , repoInfo ) if err != nil { return err } return nil }
2772	func PrintBranch ( w io . Writer , branchInfo * pfs . BranchInfo ) { fmt . Fprintf ( w , "%s\t" , \t ) branchInfo . Branch . Name }
2773	func PrintCommitInfo ( w io . Writer , commitInfo * pfs . CommitInfo , fullTimestamps bool ) { fmt . Fprintf ( w , "%s\t" , \t ) commitInfo . Commit . Repo . Name fmt . Fprintf ( w , "%s\t" , \t ) commitInfo . Branch . Name fmt . Fprintf ( w , "%s\t" , \t ) commitInfo . Commit . ID }
2774	func PrintDetailedCommitInfo ( commitInfo * PrintableCommitInfo ) error { template , err := template . New ( "CommitInfo" ) . Funcs ( funcMap ) . Parse ( `Commit: {{.Commit.Repo.Name}}@{{.Commit.ID}}{{if .Branch}}Original Branch: {{.Branch.Name}}{{end}}{{if .Description}}Description: {{.Description}}{{end}}{{if .ParentCommit}}Parent: {{.ParentCommit.ID}}{{end}}{{if .FullTimestamps}}Started: {{.Started}}{{else}}Started: {{prettyAgo .Started}}{{end}}{{if .Finished}}{{if .FullTimestamps}}Finished: {{.Finished}}{{else}}Finished: {{prettyAgo .Finished}}{{end}}{{end}}Size: {{prettySize .SizeBytes}}{{if .Provenance}}Provenance: {{range .Provenance}} {{.Commit.Repo.Name}}@{{.Commit.ID}} ({{.Branch.Name}}) {{end}} {{end}}` ) if err != nil { return err } err = template . Execute ( os . Stdout , commitInfo ) if err != nil { return err } return nil }
2775	func PrintFileInfo ( w io . Writer , fileInfo * pfs . FileInfo , fullTimestamps bool ) { fmt . Fprintf ( w , "%s\t" , \t ) fileInfo . File . Commit . ID fmt . Fprintf ( w , "%s\t" , \t ) fileInfo . File . Path if fileInfo . FileType == pfs . FileType_FILE { fmt . Fprint ( w , "file\t" ) } else \t }
2776	func PrintDetailedFileInfo ( fileInfo * pfs . FileInfo ) error { template , err := template . New ( "FileInfo" ) . Funcs ( funcMap ) . Parse ( `Path: {{.File.Path}}Type: {{fileType .FileType}}Size: {{prettySize .SizeBytes}}Children: {{range .Children}} {{.}} {{end}}` ) if err != nil { return err } return template . Execute ( os . Stdout , fileInfo ) }
2777	func Add ( s string , ancestors int ) string { return fmt . Sprintf ( "%s~%d" , s , ancestors ) }
2778	func RetryNotify ( operation Operation , b BackOff , notify Notify ) error { var err error var next time . Duration b . Reset ( ) for { if err = operation ( ) ; err == nil { return nil } if next = b . NextBackOff ( ) ; next == Stop { return err } if notify != nil { if err := notify ( err , next ) ; err != nil { return err } } time . Sleep ( next ) } }
2779	func ( c * MergeCache ) Get ( id int64 , w io . Writer , filter Filter ) ( retErr error ) { r , err := c . Cache . Get ( fmt . Sprint ( id ) ) if err != nil { return err } defer func ( ) { if err := r . Close ( ) ; err != nil && retErr == nil { retErr = err } } ( ) return NewWriter ( w ) . Copy ( NewReader ( r , filter ) ) }
2780	func ( c * MergeCache ) Delete ( id int64 ) error { return c . Cache . Delete ( fmt . Sprint ( id ) ) }
2781	func PrintJobInfo ( w io . Writer , jobInfo * ppsclient . JobInfo , fullTimestamps bool ) { fmt . Fprintf ( w , "%s\t" , \t ) jobInfo . Job . ID fmt . Fprintf ( w , "%s\t" , \t ) jobInfo . Pipeline . Name if fullTimestamps { fmt . Fprintf ( w , "%s\t" , \t ) } else jobInfo . Started . String ( ) { fmt . Fprintf ( w , "%s\t" , \t ) } pretty . Ago ( jobInfo . Started ) if jobInfo . Finished != nil { fmt . Fprintf ( w , "%s\t" , \t ) } else pretty . TimeDifference ( jobInfo . Started , jobInfo . Finished ) { fmt . Fprintf ( w , "-\t" ) } }
2782	func PrintPipelineInfo ( w io . Writer , pipelineInfo * ppsclient . PipelineInfo , fullTimestamps bool ) { fmt . Fprintf ( w , "%s\t" , \t ) pipelineInfo . Pipeline . Name fmt . Fprintf ( w , "%s\t" , \t ) ShorthandInput ( pipelineInfo . Input ) }
2783	func PrintWorkerStatus ( w io . Writer , workerStatus * ppsclient . WorkerStatus , fullTimestamps bool ) { fmt . Fprintf ( w , "%s\t" , \t ) workerStatus . WorkerID fmt . Fprintf ( w , "%s\t" , \t ) workerStatus . JobID for _ , datum := range workerStatus . Data { fmt . Fprintf ( w , datum . Path ) } fmt . Fprintf ( w , "\t" ) }
2784	func PrintDetailedJobInfo ( jobInfo * PrintableJobInfo ) error { template , err := template . New ( "JobInfo" ) . Funcs ( funcMap ) . Parse ( `ID: {{.Job.ID}} {{if .Pipeline}}Pipeline: {{.Pipeline.Name}} {{end}} {{if .ParentJob}}Parent: {{.ParentJob.ID}} {{end}}{{if .FullTimestamps}}Started: {{.Started}}{{else}}Started: {{prettyAgo .Started}} {{end}}{{if .Finished}}Duration: {{prettyTimeDifference .Started .Finished}} {{end}}State: {{jobState .State}}Reason: {{.Reason}}Processed: {{.DataProcessed}}Failed: {{.DataFailed}}Skipped: {{.DataSkipped}}Recovered: {{.DataRecovered}}Total: {{.DataTotal}}Data Downloaded: {{prettySize .Stats.DownloadBytes}}Data Uploaded: {{prettySize .Stats.UploadBytes}}Download Time: {{prettyDuration .Stats.DownloadTime}}Process Time: {{prettyDuration .Stats.ProcessTime}}Upload Time: {{prettyDuration .Stats.UploadTime}}Datum Timeout: {{.DatumTimeout}}Job Timeout: {{.JobTimeout}}Worker Status:{{workerStatus .}}Restarts: {{.Restart}}ParallelismSpec: {{.ParallelismSpec}}{{ if .ResourceRequests }}ResourceRequests: CPU: {{ .ResourceRequests.Cpu }} Memory: {{ .ResourceRequests.Memory }} {{end}}{{ if .ResourceLimits }}ResourceLimits: CPU: {{ .ResourceLimits.Cpu }} Memory: {{ .ResourceLimits.Memory }} {{ if .ResourceLimits.Gpu }}GPU: Type: {{ .ResourceLimits.Gpu.Type }} Number: {{ .ResourceLimits.Gpu.Number }} {{end}} {{end}}{{ if .Service }}Service: {{ if .Service.InternalPort }}InternalPort: {{ .Service.InternalPort }} {{end}} {{ if .Service.ExternalPort }}ExternalPort: {{ .Service.ExternalPort }} {{end}} {{end}}Input:{{jobInput .}}Transform:{{prettyTransform .Transform}} {{if .OutputCommit}}Output Commit: {{.OutputCommit.ID}} {{end}} {{ if .StatsCommit }}Stats Commit: {{.StatsCommit.ID}} {{end}} {{ if .Egress }}Egress: {{.Egress.URL}} {{end}}` ) if err != nil { return err } err = template . Execute ( os . Stdout , jobInfo ) if err != nil { return err } return nil }
2785	func PrintDetailedPipelineInfo ( pipelineInfo * PrintablePipelineInfo ) error { template , err := template . New ( "PipelineInfo" ) . Funcs ( funcMap ) . Parse ( `Name: {{.Pipeline.Name}}{{if .Description}}Description: {{.Description}}{{end}}{{if .FullTimestamps }}Created: {{.CreatedAt}}{{ else }}Created: {{prettyAgo .CreatedAt}} {{end}}State: {{pipelineState .State}}Stopped: {{ .Stopped }}Reason: {{.Reason}}Parallelism Spec: {{.ParallelismSpec}}{{ if .ResourceRequests }}ResourceRequests: CPU: {{ .ResourceRequests.Cpu }} Memory: {{ .ResourceRequests.Memory }} {{end}}{{ if .ResourceLimits }}ResourceLimits: CPU: {{ .ResourceLimits.Cpu }} Memory: {{ .ResourceLimits.Memory }} {{ if .ResourceLimits.Gpu }}GPU: Type: {{ .ResourceLimits.Gpu.Type }} Number: {{ .ResourceLimits.Gpu.Number }} {{end}} {{end}}Datum Timeout: {{.DatumTimeout}}Job Timeout: {{.JobTimeout}}Input:{{pipelineInput .PipelineInfo}}{{ if .GithookURL }}Githook URL: {{.GithookURL}} {{end}}Output Branch: {{.OutputBranch}}Transform:{{prettyTransform .Transform}}{{ if .Egress }}Egress: {{.Egress.URL}} {{end}}{{if .RecentError}} Recent Error: {{.RecentError}} {{end}}Job Counts:{{jobCounts .JobCounts}}` ) if err != nil { return err } err = template . Execute ( os . Stdout , pipelineInfo ) if err != nil { return err } return nil }
2786	func PrintDatumInfo ( w io . Writer , datumInfo * ppsclient . DatumInfo ) { totalTime := "-" if datumInfo . Stats != nil { totalTime = units . HumanDuration ( client . GetDatumTotalTime ( datumInfo . Stats ) ) } fmt . Fprintf ( w , "%s\t%s\t%s\n" , \t , \t , \n ) }
2787	func PrintDetailedDatumInfo ( w io . Writer , datumInfo * ppsclient . DatumInfo ) { fmt . Fprintf ( w , "ID\t%s\n" , \t ) \n datumInfo . Datum . ID fmt . Fprintf ( w , "Job ID\t%s\n" , \t ) \n datumInfo . Datum . Job . ID fmt . Fprintf ( w , "State\t%s\n" , \t ) \n datumInfo . State fmt . Fprintf ( w , "Data Downloaded\t%s\n" , \t ) \n pretty . Size ( datumInfo . Stats . DownloadBytes ) fmt . Fprintf ( w , "Data Uploaded\t%s\n" , \t ) \n pretty . Size ( datumInfo . Stats . UploadBytes ) totalTime := client . GetDatumTotalTime ( datumInfo . Stats ) . String ( ) fmt . Fprintf ( w , "Total Time\t%s\n" , \t ) \n totalTime var downloadTime string dl , err := types . DurationFromProto ( datumInfo . Stats . DownloadTime ) if err != nil { downloadTime = err . Error ( ) } downloadTime = dl . String ( ) fmt . Fprintf ( w , "Download Time\t%s\n" , \t ) \n downloadTime var procTime string proc , err := types . DurationFromProto ( datumInfo . Stats . ProcessTime ) if err != nil { procTime = err . Error ( ) } procTime = proc . String ( ) fmt . Fprintf ( w , "Process Time\t%s\n" , \t ) \n }
2788	func PrintFile ( w io . Writer , file * pfsclient . File ) { fmt . Fprintf ( w , " %s\t%s\t%s\t\n" , \t , \t , \t ) }
2789	func ShorthandInput ( input * ppsclient . Input ) string { switch { case input == nil : return "none" case input . Pfs != nil : return fmt . Sprintf ( "%s:%s" , input . Pfs . Repo , input . Pfs . Glob ) case input . Cross != nil : var subInput [ ] string for _ , input := range input . Cross { subInput = append ( subInput , ShorthandInput ( input ) ) } return "(" + strings . Join ( subInput , " ⨯ ") + " " case input . Union != nil : var subInput [ ] string for _ , input := range input . Union { subInput = append ( subInput , ShorthandInput ( input ) ) } return "(" + strings . Join ( subInput , " ∪ ") + " } " }
2790	func ( v * vaultCredentialsProvider ) Retrieve ( ) ( credentials . Value , error ) { var emptyCreds , result credentials . Value vaultSecret , err := v . vaultClient . Logical ( ) . Read ( path . Join ( "aws" , "creds" , v . vaultRole ) ) if err != nil { return emptyCreds , fmt . Errorf ( "could not retrieve creds from vault: %v" , err ) } accessKeyIface , accessKeyOk := vaultSecret . Data [ "access_key" ] awsSecretIface , awsSecretOk := vaultSecret . Data [ "secret_key" ] if ! accessKeyOk || ! awsSecretOk { return emptyCreds , fmt . Errorf ( "aws creds not present in vault response" ) } result . AccessKeyID , accessKeyOk = accessKeyIface . ( string ) result . SecretAccessKey , awsSecretOk = awsSecretIface . ( string ) if ! accessKeyOk || ! awsSecretOk { return emptyCreds , fmt . Errorf ( "aws creds in vault response were not both strings (%T and %T)" , accessKeyIface , awsSecretIface ) } v . updateLease ( vaultSecret ) go func ( ) { for { renewInterval := v . getLeaseDuration ( ) if renewInterval . Seconds ( ) < oneDayInSeconds { renewInterval = oneDayInSeconds * time . Second } time . Sleep ( renewInterval ) backoff . RetryNotify ( func ( ) error { vaultSecret , err := v . vaultClient . Sys ( ) . Renew ( v . leaseID , twoDaysInSeconds ) if err != nil { return err } v . updateLease ( vaultSecret ) return nil } , backoff . NewExponentialBackOff ( ) , func ( err error , _ time . Duration ) error { log . Errorf ( "could not renew vault lease: %v" , err ) return nil } ) } } ( ) time . Sleep ( 10 * time . Second ) return result , nil }
2791	func ( v * vaultCredentialsProvider ) IsExpired ( ) bool { v . leaseMu . Lock ( ) defer v . leaseMu . Unlock ( ) return time . Now ( ) . After ( v . leaseLastRenew . Add ( v . leaseDuration ) ) }
2792	func NewBranch ( repoName string , branchName string ) * pfs . Branch { return & pfs . Branch { Repo : NewRepo ( repoName ) , Name : branchName , } }
2793	func NewCommit ( repoName string , commitID string ) * pfs . Commit { return & pfs . Commit { Repo : NewRepo ( repoName ) , ID : commitID , } }
2794	func NewCommitProvenance ( repoName string , branchName string , commitID string ) * pfs . CommitProvenance { return & pfs . CommitProvenance { Commit : NewCommit ( repoName , commitID ) , Branch : NewBranch ( repoName , branchName ) , } }
2795	func NewFile ( repoName string , commitID string , path string ) * pfs . File { return & pfs . File { Commit : NewCommit ( repoName , commitID ) , Path : path , } }
2796	func ( c APIClient ) CreateRepo ( repoName string ) error { _ , err := c . PfsAPIClient . CreateRepo ( c . Ctx ( ) , & pfs . CreateRepoRequest { Repo : NewRepo ( repoName ) , } , ) return grpcutil . ScrubGRPC ( err ) }
2797	func ( c APIClient ) InspectRepo ( repoName string ) ( * pfs . RepoInfo , error ) { resp , err := c . PfsAPIClient . InspectRepo ( c . Ctx ( ) , & pfs . InspectRepoRequest { Repo : NewRepo ( repoName ) , } , ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } return resp , nil }
2798	func ( c APIClient ) ListRepo ( ) ( [ ] * pfs . RepoInfo , error ) { request := & pfs . ListRepoRequest { } repoInfos , err := c . PfsAPIClient . ListRepo ( c . Ctx ( ) , request , ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } return repoInfos . RepoInfo , nil }
2799	func ( c APIClient ) DeleteRepo ( repoName string , force bool ) error { _ , err := c . PfsAPIClient . DeleteRepo ( c . Ctx ( ) , & pfs . DeleteRepoRequest { Repo : NewRepo ( repoName ) , Force : force , } , ) return grpcutil . ScrubGRPC ( err ) }
2800	func ( c APIClient ) BuildCommit ( repoName string , branch string , parent string , treeObject string ) ( * pfs . Commit , error ) { commit , err := c . PfsAPIClient . BuildCommit ( c . Ctx ( ) , & pfs . BuildCommitRequest { Parent : NewCommit ( repoName , parent ) , Branch : branch , Tree : & pfs . Object { Hash : treeObject } , } , ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } return commit , nil }
2801	func ( c APIClient ) StartCommitParent ( repoName string , branch string , parentCommit string ) ( * pfs . Commit , error ) { commit , err := c . PfsAPIClient . StartCommit ( c . Ctx ( ) , & pfs . StartCommitRequest { Parent : & pfs . Commit { Repo : & pfs . Repo { Name : repoName , } , ID : parentCommit , } , Branch : branch , } , ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } return commit , nil }
2802	func ( c APIClient ) FinishCommit ( repoName string , commitID string ) error { _ , err := c . PfsAPIClient . FinishCommit ( c . Ctx ( ) , & pfs . FinishCommitRequest { Commit : NewCommit ( repoName , commitID ) , } , ) return grpcutil . ScrubGRPC ( err ) }
2803	func ( c APIClient ) InspectCommit ( repoName string , commitID string ) ( * pfs . CommitInfo , error ) { return c . inspectCommit ( repoName , commitID , pfs . CommitState_STARTED ) }
2804	func ( c APIClient ) BlockCommit ( repoName string , commitID string ) ( * pfs . CommitInfo , error ) { return c . inspectCommit ( repoName , commitID , pfs . CommitState_FINISHED ) }
2805	func ( c APIClient ) ListCommit ( repoName string , to string , from string , number uint64 ) ( [ ] * pfs . CommitInfo , error ) { var result [ ] * pfs . CommitInfo if err := c . ListCommitF ( repoName , to , from , number , func ( ci * pfs . CommitInfo ) error { result = append ( result , ci ) return nil } ) ; err != nil { return nil , err } return result , nil }
2806	func ( c APIClient ) ListCommitF ( repoName string , to string , from string , number uint64 , f func ( * pfs . CommitInfo ) error ) error { req := & pfs . ListCommitRequest { Repo : NewRepo ( repoName ) , Number : number , } if from != "" { req . From = NewCommit ( repoName , from ) } if to != "" { req . To = NewCommit ( repoName , to ) } stream , err := c . PfsAPIClient . ListCommitStream ( c . Ctx ( ) , req ) if err != nil { return grpcutil . ScrubGRPC ( err ) } for { ci , err := stream . Recv ( ) if err == io . EOF { break } else if err != nil { return grpcutil . ScrubGRPC ( err ) } if err := f ( ci ) ; err != nil { if err == errutil . ErrBreak { return nil } return err } } return nil }
2807	func ( c APIClient ) ListCommitByRepo ( repoName string ) ( [ ] * pfs . CommitInfo , error ) { return c . ListCommit ( repoName , "" , "" , 0 ) }
2808	func ( c APIClient ) CreateBranch ( repoName string , branch string , commit string , provenance [ ] * pfs . Branch ) error { var head * pfs . Commit if commit != "" { head = NewCommit ( repoName , commit ) } _ , err := c . PfsAPIClient . CreateBranch ( c . Ctx ( ) , & pfs . CreateBranchRequest { Branch : NewBranch ( repoName , branch ) , Head : head , Provenance : provenance , } , ) return grpcutil . ScrubGRPC ( err ) }
2809	func ( c APIClient ) InspectBranch ( repoName string , branch string ) ( * pfs . BranchInfo , error ) { branchInfo , err := c . PfsAPIClient . InspectBranch ( c . Ctx ( ) , & pfs . InspectBranchRequest { Branch : NewBranch ( repoName , branch ) , } , ) return branchInfo , grpcutil . ScrubGRPC ( err ) }
2810	func ( c APIClient ) ListBranch ( repoName string ) ( [ ] * pfs . BranchInfo , error ) { branchInfos , err := c . PfsAPIClient . ListBranch ( c . Ctx ( ) , & pfs . ListBranchRequest { Repo : NewRepo ( repoName ) , } , ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } return branchInfos . BranchInfo , nil }
2811	func ( c APIClient ) SetBranch ( repoName string , commit string , branch string ) error { return c . CreateBranch ( repoName , branch , commit , nil ) }
2812	func ( c APIClient ) DeleteBranch ( repoName string , branch string , force bool ) error { _ , err := c . PfsAPIClient . DeleteBranch ( c . Ctx ( ) , & pfs . DeleteBranchRequest { Branch : NewBranch ( repoName , branch ) , Force : force , } , ) return grpcutil . ScrubGRPC ( err ) }
2813	func ( c APIClient ) DeleteCommit ( repoName string , commitID string ) error { _ , err := c . PfsAPIClient . DeleteCommit ( c . Ctx ( ) , & pfs . DeleteCommitRequest { Commit : NewCommit ( repoName , commitID ) , } , ) return grpcutil . ScrubGRPC ( err ) }
2814	func ( c APIClient ) FlushCommit ( commits [ ] * pfs . Commit , toRepos [ ] * pfs . Repo ) ( CommitInfoIterator , error ) { ctx , cancel := context . WithCancel ( c . Ctx ( ) ) stream , err := c . PfsAPIClient . FlushCommit ( ctx , & pfs . FlushCommitRequest { Commits : commits , ToRepos : toRepos , } , ) if err != nil { cancel ( ) return nil , grpcutil . ScrubGRPC ( err ) } return & commitInfoIterator { stream , cancel } , nil }
2815	func ( c APIClient ) FlushCommitF ( commits [ ] * pfs . Commit , toRepos [ ] * pfs . Repo , f func ( * pfs . CommitInfo ) error ) error { stream , err := c . PfsAPIClient . FlushCommit ( c . Ctx ( ) , & pfs . FlushCommitRequest { Commits : commits , ToRepos : toRepos , } , ) if err != nil { return grpcutil . ScrubGRPC ( err ) } for { ci , err := stream . Recv ( ) if err != nil { if err == io . EOF { return nil } return grpcutil . ScrubGRPC ( err ) } if err := f ( ci ) ; err != nil { return err } } }
2816	func ( c APIClient ) FlushCommitAll ( commits [ ] * pfs . Commit , toRepos [ ] * pfs . Repo ) ( [ ] * pfs . CommitInfo , error ) { var result [ ] * pfs . CommitInfo if err := c . FlushCommitF ( commits , toRepos , func ( ci * pfs . CommitInfo ) error { result = append ( result , ci ) return nil } ) ; err != nil { return nil , err } return result , nil }
2817	func ( c APIClient ) SubscribeCommit ( repo string , branch string , from string , state pfs . CommitState ) ( CommitInfoIterator , error ) { ctx , cancel := context . WithCancel ( c . Ctx ( ) ) req := & pfs . SubscribeCommitRequest { Repo : NewRepo ( repo ) , Branch : branch , State : state , } if from != "" { req . From = NewCommit ( repo , from ) } stream , err := c . PfsAPIClient . SubscribeCommit ( ctx , req ) if err != nil { cancel ( ) return nil , grpcutil . ScrubGRPC ( err ) } return & commitInfoIterator { stream , cancel } , nil }
2818	func ( c APIClient ) SubscribeCommitF ( repo , branch , from string , state pfs . CommitState , f func ( * pfs . CommitInfo ) error ) error { req := & pfs . SubscribeCommitRequest { Repo : NewRepo ( repo ) , Branch : branch , State : state , } if from != "" { req . From = NewCommit ( repo , from ) } stream , err := c . PfsAPIClient . SubscribeCommit ( c . Ctx ( ) , req ) if err != nil { return grpcutil . ScrubGRPC ( err ) } for { ci , err := stream . Recv ( ) if err != nil { return grpcutil . ScrubGRPC ( err ) } if err := f ( ci ) ; err != nil { return grpcutil . ScrubGRPC ( err ) } } }
2819	func ( c APIClient ) PutObjectAsync ( tags [ ] * pfs . Tag ) ( * PutObjectWriteCloserAsync , error ) { w , err := c . newPutObjectWriteCloserAsync ( tags ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } return w , nil }
2820	func ( c APIClient ) PutObject ( _r io . Reader , tags ... string ) ( object * pfs . Object , _ int64 , retErr error ) { r := grpcutil . ReaderWrapper { _r } w , err := c . newPutObjectWriteCloser ( tags ... ) if err != nil { return nil , 0 , grpcutil . ScrubGRPC ( err ) } defer func ( ) { if err := w . Close ( ) ; err != nil && retErr == nil { retErr = grpcutil . ScrubGRPC ( err ) } if retErr == nil { object = w . object } } ( ) buf := grpcutil . GetBuffer ( ) defer grpcutil . PutBuffer ( buf ) written , err := io . CopyBuffer ( w , r , buf ) if err != nil { return nil , 0 , grpcutil . ScrubGRPC ( err ) } return nil , written , nil }
2821	func ( c APIClient ) PutObjectSplit ( _r io . Reader ) ( objects [ ] * pfs . Object , _ int64 , retErr error ) { r := grpcutil . ReaderWrapper { _r } w , err := c . newPutObjectSplitWriteCloser ( ) if err != nil { return nil , 0 , grpcutil . ScrubGRPC ( err ) } defer func ( ) { if err := w . Close ( ) ; err != nil && retErr == nil { retErr = grpcutil . ScrubGRPC ( err ) } if retErr == nil { objects = w . objects } } ( ) buf := grpcutil . GetBuffer ( ) defer grpcutil . PutBuffer ( buf ) written , err := io . CopyBuffer ( w , r , buf ) if err != nil { return nil , 0 , grpcutil . ScrubGRPC ( err ) } return nil , written , nil }
2822	func ( c APIClient ) GetObject ( hash string , writer io . Writer ) error { getObjectClient , err := c . ObjectAPIClient . GetObject ( c . Ctx ( ) , & pfs . Object { Hash : hash } , ) if err != nil { return grpcutil . ScrubGRPC ( err ) } if err := grpcutil . WriteFromStreamingBytesClient ( getObjectClient , writer ) ; err != nil { return grpcutil . ScrubGRPC ( err ) } return nil }
2823	func ( c APIClient ) GetObjectReader ( hash string ) ( io . ReadCloser , error ) { ctx , cancel := context . WithCancel ( c . Ctx ( ) ) getObjectClient , err := c . ObjectAPIClient . GetObject ( ctx , & pfs . Object { Hash : hash } , ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } return grpcutil . NewStreamingBytesReader ( getObjectClient , cancel ) , nil }
2824	func ( c APIClient ) GetObjects ( hashes [ ] string , offset uint64 , size uint64 , totalSize uint64 , writer io . Writer ) error { var objects [ ] * pfs . Object for _ , hash := range hashes { objects = append ( objects , & pfs . Object { Hash : hash } ) } getObjectsClient , err := c . ObjectAPIClient . GetObjects ( c . Ctx ( ) , & pfs . GetObjectsRequest { Objects : objects , OffsetBytes : offset , SizeBytes : size , TotalSize : totalSize , } , ) if err != nil { return grpcutil . ScrubGRPC ( err ) } if err := grpcutil . WriteFromStreamingBytesClient ( getObjectsClient , writer ) ; err != nil { return grpcutil . ScrubGRPC ( err ) } return nil }
2825	func ( c APIClient ) TagObject ( hash string , tags ... string ) error { var _tags [ ] * pfs . Tag for _ , tag := range tags { _tags = append ( _tags , & pfs . Tag { Name : tag } ) } if _ , err := c . ObjectAPIClient . TagObject ( c . Ctx ( ) , & pfs . TagObjectRequest { Object : & pfs . Object { Hash : hash } , Tags : _tags , } , ) ; err != nil { return grpcutil . ScrubGRPC ( err ) } return nil }
2826	func ( c APIClient ) ListObject ( f func ( * pfs . Object ) error ) error { listObjectClient , err := c . ObjectAPIClient . ListObjects ( c . Ctx ( ) , & pfs . ListObjectsRequest { } ) if err != nil { return grpcutil . ScrubGRPC ( err ) } for { object , err := listObjectClient . Recv ( ) if err != nil { if err == io . EOF { return nil } return grpcutil . ScrubGRPC ( err ) } if err := f ( object ) ; err != nil { return err } } }
2827	func ( c APIClient ) InspectObject ( hash string ) ( * pfs . ObjectInfo , error ) { value , err := c . ObjectAPIClient . InspectObject ( c . Ctx ( ) , & pfs . Object { Hash : hash } , ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } return value , nil }
2828	func ( c APIClient ) GetTag ( tag string , writer io . Writer ) error { getTagClient , err := c . ObjectAPIClient . GetTag ( c . Ctx ( ) , & pfs . Tag { Name : tag } , ) if err != nil { return grpcutil . ScrubGRPC ( err ) } if err := grpcutil . WriteFromStreamingBytesClient ( getTagClient , writer ) ; err != nil { return grpcutil . ScrubGRPC ( err ) } return nil }
2829	func ( c APIClient ) GetTagReader ( tag string ) ( io . ReadCloser , error ) { ctx , cancel := context . WithCancel ( c . Ctx ( ) ) getTagClient , err := c . ObjectAPIClient . GetTag ( ctx , & pfs . Tag { Name : tag } , ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } return grpcutil . NewStreamingBytesReader ( getTagClient , cancel ) , nil }
2830	func ( c APIClient ) ListTag ( f func ( * pfs . ListTagsResponse ) error ) error { listTagClient , err := c . ObjectAPIClient . ListTags ( c . Ctx ( ) , & pfs . ListTagsRequest { IncludeObject : true } ) if err != nil { return grpcutil . ScrubGRPC ( err ) } for { listTagResponse , err := listTagClient . Recv ( ) if err != nil { if err == io . EOF { return nil } return grpcutil . ScrubGRPC ( err ) } if err := f ( listTagResponse ) ; err != nil { return err } } }
2831	func ( c APIClient ) Compact ( ) error { _ , err := c . ObjectAPIClient . Compact ( c . Ctx ( ) , & types . Empty { } , ) return err }
2832	func ( c APIClient ) NewPutFileClient ( ) ( PutFileClient , error ) { pfc , err := c . PfsAPIClient . PutFile ( c . Ctx ( ) ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } return & putFileClient { c : pfc } , nil }
2833	func ( c * putFileClient ) PutFileOverwrite ( repoName string , commitID string , path string , reader io . Reader , overwriteIndex int64 ) ( _ int , retErr error ) { writer , err := c . newPutFileWriteCloser ( repoName , commitID , path , pfs . Delimiter_NONE , 0 , 0 , 0 , & pfs . OverwriteIndex { Index : overwriteIndex } ) if err != nil { return 0 , grpcutil . ScrubGRPC ( err ) } defer func ( ) { if err := writer . Close ( ) ; err != nil && retErr == nil { retErr = err } } ( ) written , err := io . Copy ( writer , reader ) return int ( written ) , grpcutil . ScrubGRPC ( err ) }
2834	func ( c * putFileClient ) Close ( ) error { _ , err := c . c . CloseAndRecv ( ) return grpcutil . ScrubGRPC ( err ) }
2835	func ( c APIClient ) CopyFile ( srcRepo , srcCommit , srcPath , dstRepo , dstCommit , dstPath string , overwrite bool ) error { if _ , err := c . PfsAPIClient . CopyFile ( c . Ctx ( ) , & pfs . CopyFileRequest { Src : NewFile ( srcRepo , srcCommit , srcPath ) , Dst : NewFile ( dstRepo , dstCommit , dstPath ) , Overwrite : overwrite , } ) ; err != nil { return grpcutil . ScrubGRPC ( err ) } return nil }
2836	func ( c APIClient ) GetFile ( repoName string , commitID string , path string , offset int64 , size int64 , writer io . Writer ) error { if c . limiter != nil { c . limiter . Acquire ( ) defer c . limiter . Release ( ) } apiGetFileClient , err := c . getFile ( repoName , commitID , path , offset , size ) if err != nil { return grpcutil . ScrubGRPC ( err ) } if err := grpcutil . WriteFromStreamingBytesClient ( apiGetFileClient , writer ) ; err != nil { return grpcutil . ScrubGRPC ( err ) } return nil }
2837	func ( c APIClient ) GetFileReader ( repoName string , commitID string , path string , offset int64 , size int64 ) ( io . Reader , error ) { apiGetFileClient , err := c . getFile ( repoName , commitID , path , offset , size ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } return grpcutil . NewStreamingBytesReader ( apiGetFileClient , nil ) , nil }
2838	func ( c APIClient ) GetFileReadSeeker ( repoName string , commitID string , path string ) ( io . ReadSeeker , error ) { fileInfo , err := c . InspectFile ( repoName , commitID , path ) if err != nil { return nil , err } reader , err := c . GetFileReader ( repoName , commitID , path , 0 , 0 ) if err != nil { return nil , err } return & getFileReadSeeker { Reader : reader , file : NewFile ( repoName , commitID , path ) , offset : 0 , size : int64 ( fileInfo . SizeBytes ) , c : c , } , nil }
2839	func ( c APIClient ) InspectFile ( repoName string , commitID string , path string ) ( * pfs . FileInfo , error ) { return c . inspectFile ( repoName , commitID , path ) }
2840	func ( c APIClient ) ListFile ( repoName string , commitID string , path string ) ( [ ] * pfs . FileInfo , error ) { var result [ ] * pfs . FileInfo if err := c . ListFileF ( repoName , commitID , path , 0 , func ( fi * pfs . FileInfo ) error { result = append ( result , fi ) return nil } ) ; err != nil { return nil , err } return result , nil }
2841	func ( c APIClient ) ListFileHistory ( repoName string , commitID string , path string , history int64 ) ( [ ] * pfs . FileInfo , error ) { var result [ ] * pfs . FileInfo if err := c . ListFileF ( repoName , commitID , path , history , func ( fi * pfs . FileInfo ) error { result = append ( result , fi ) return nil } ) ; err != nil { return nil , err } return result , nil }
2842	func ( c APIClient ) ListFileF ( repoName string , commitID string , path string , history int64 , f func ( fi * pfs . FileInfo ) error ) error { fs , err := c . PfsAPIClient . ListFileStream ( c . Ctx ( ) , & pfs . ListFileRequest { File : NewFile ( repoName , commitID , path ) , History : history , } , ) if err != nil { return grpcutil . ScrubGRPC ( err ) } for { fi , err := fs . Recv ( ) if err == io . EOF { return nil } else if err != nil { return grpcutil . ScrubGRPC ( err ) } if err := f ( fi ) ; err != nil { if err == errutil . ErrBreak { return nil } return err } } }
2843	func ( c APIClient ) Walk ( repoName string , commitID string , path string , f WalkFn ) error { fs , err := c . PfsAPIClient . WalkFile ( c . Ctx ( ) , & pfs . WalkFileRequest { File : NewFile ( repoName , commitID , path ) } ) if err != nil { return grpcutil . ScrubGRPC ( err ) } for { fi , err := fs . Recv ( ) if err == io . EOF { return nil } else if err != nil { return grpcutil . ScrubGRPC ( err ) } if err := f ( fi ) ; err != nil { if err == errutil . ErrBreak { return nil } return err } } }
2844	func ( c APIClient ) DeleteFile ( repoName string , commitID string , path string ) error { _ , err := c . PfsAPIClient . DeleteFile ( c . Ctx ( ) , & pfs . DeleteFileRequest { File : NewFile ( repoName , commitID , path ) , } , ) return err }
2845	func ( w * PutObjectWriteCloserAsync ) Write ( p [ ] byte ) ( int , error ) { select { case err := <- w . errChan : if err != nil { return 0 , grpcutil . ScrubGRPC ( err ) } default : for len ( w . buf ) + len ( p ) > cap ( w . buf ) { i := cap ( w . buf ) - len ( w . buf ) w . buf = append ( w . buf , p [ : i ] ... ) p = p [ i : ] w . writeChan <- w . buf w . buf = grpcutil . GetBuffer ( ) [ : 0 ] } w . buf = append ( w . buf , p ... ) } return len ( p ) , nil }
2846	func ( w * PutObjectWriteCloserAsync ) Close ( ) error { w . writeChan <- w . buf close ( w . writeChan ) err := <- w . errChan if err != nil { return grpcutil . ScrubGRPC ( err ) } w . object , err = w . client . CloseAndRecv ( ) return grpcutil . ScrubGRPC ( err ) }
2847	func PrettyPrintVersionNoAdditional ( version * pb . Version ) string { return fmt . Sprintf ( "%d.%d.%d" , version . Major , version . Minor , version . Micro ) }
2848	func recursiveBlockQuoteExamples ( parent * cobra . Command ) { if parent . Example != "" { parent . Example = fmt . Sprintf ( "```sh\n%s\n```" , \n ) } \n }
2849	func errMissingField ( field string ) * logical . Response { return logical . ErrorResponse ( fmt . Sprintf ( "missing required field '%s'" , field ) ) }
2850	func validateFields ( req * logical . Request , data * framework . FieldData ) error { var unknownFields [ ] string for k := range req . Data { if _ , ok := data . Schema [ k ] ; ! ok { unknownFields = append ( unknownFields , k ) } } if len ( unknownFields ) > 0 { return fmt . Errorf ( "unknown fields: %q" , unknownFields ) } return nil }
2851	func putConfig ( ctx context . Context , s logical . Storage , cfg * config ) error { entry , err := logical . StorageEntryJSON ( "config" , cfg ) if err != nil { return fmt . Errorf ( "%v: failed to generate storage entry" , err ) } if err := s . Put ( ctx , entry ) ; err != nil { return fmt . Errorf ( "%v: failed to write configuration to storage" , err ) } return nil }
2852	func getConfig ( ctx context . Context , s logical . Storage ) ( * config , error ) { entry , err := s . Get ( ctx , "config" ) if err != nil { return nil , fmt . Errorf ( "%v: failed to get config from storage" , err ) } if entry == nil || len ( entry . Value ) == 0 { return nil , errors . New ( "no configuration in storage" ) } var result config if err := entry . DecodeJSON ( & result ) ; err != nil { return nil , fmt . Errorf ( "%v: failed to decode configuration" , err ) } return & result , nil }
2853	func Serve ( servers ... ServerOptions , ) ( retErr error ) { for _ , server := range servers { if server . RegisterFunc == nil { return ErrMustSpecifyRegisterFunc } if server . Port == 0 { return ErrMustSpecifyPort } opts := [ ] grpc . ServerOption { grpc . MaxConcurrentStreams ( math . MaxUint32 ) , grpc . MaxRecvMsgSize ( server . MaxMsgSize ) , grpc . MaxSendMsgSize ( server . MaxMsgSize ) , grpc . KeepaliveEnforcementPolicy ( keepalive . EnforcementPolicy { MinTime : 5 * time . Second , PermitWithoutStream : true , } ) , grpc . UnaryInterceptor ( tracing . UnaryServerInterceptor ( ) ) , grpc . StreamInterceptor ( tracing . StreamServerInterceptor ( ) ) , } if server . PublicPortTLSAllowed { certPath := path . Join ( TLSVolumePath , TLSCertFile ) keyPath := path . Join ( TLSVolumePath , TLSKeyFile ) _ , certPathStatErr := os . Stat ( certPath ) _ , keyPathStatErr := os . Stat ( keyPath ) if certPathStatErr != nil { log . Warnf ( "TLS disabled: could not stat public cert at %s: %v" , certPath , certPathStatErr ) } if keyPathStatErr != nil { log . Warnf ( "TLS disabled: could not stat private key at %s: %v" , keyPath , keyPathStatErr ) } if certPathStatErr == nil && keyPathStatErr == nil { transportCreds , err := credentials . NewServerTLSFromFile ( certPath , keyPath ) if err != nil { return fmt . Errorf ( "couldn't build transport creds: %v" , err ) } opts = append ( opts , grpc . Creds ( transportCreds ) ) } } grpcServer := grpc . NewServer ( opts ... ) if err := server . RegisterFunc ( grpcServer ) ; err != nil { return err } listener , err := net . Listen ( "tcp" , fmt . Sprintf ( ":%d" , server . Port ) ) if err != nil { return err } if server . Cancel != nil { go func ( ) { <- server . Cancel if err := listener . Close ( ) ; err != nil { fmt . Printf ( "listener.Close(): %v\n" , \n ) } } err } ( ) } if err := grpcServer . Serve ( listener ) ; err != nil { return err } }
2854	func NewPuller ( ) * Puller { return & Puller { errCh : make ( chan error , 1 ) , pipes : make ( map [ string ] bool ) , } }
2855	func ( p * Puller ) PullTree ( client * pachclient . APIClient , root string , tree hashtree . HashTree , pipes bool , concurrency int ) error { limiter := limit . New ( concurrency ) var eg errgroup . Group if err := tree . Walk ( "/" , func ( path string , node * hashtree . NodeProto ) error { if node . FileNode != nil { path := filepath . Join ( root , path ) var hashes [ ] string for _ , object := range node . FileNode . Objects { hashes = append ( hashes , object . Hash ) } if pipes { return p . makePipe ( path , func ( w io . Writer ) error { return client . GetObjects ( hashes , 0 , 0 , uint64 ( node . SubtreeSize ) , w ) } ) } limiter . Acquire ( ) eg . Go ( func ( ) ( retErr error ) { defer limiter . Release ( ) return p . makeFile ( path , func ( w io . Writer ) error { return client . GetObjects ( hashes , 0 , 0 , uint64 ( node . SubtreeSize ) , w ) } ) } ) } return nil } ) ; err != nil { return err } return eg . Wait ( ) }
2856	func Push ( client * pachclient . APIClient , root string , commit * pfs . Commit , overwrite bool ) error { var g errgroup . Group if err := filepath . Walk ( root , func ( path string , info os . FileInfo , err error ) error { g . Go ( func ( ) ( retErr error ) { if path == root || info . IsDir ( ) { return nil } f , err := os . Open ( path ) if err != nil { return err } defer func ( ) { if err := f . Close ( ) ; err != nil && retErr == nil { retErr = err } } ( ) relPath , err := filepath . Rel ( root , path ) if err != nil { return err } if overwrite { if err := client . DeleteFile ( commit . Repo . Name , commit . ID , relPath ) ; err != nil { return err } } _ , err = client . PutFile ( commit . Repo . Name , commit . ID , relPath , f ) return err } ) return nil } ) ; err != nil { return err } return g . Wait ( ) }
2857	func PushObj ( pachClient * pachclient . APIClient , commit * pfs . Commit , objClient obj . Client , root string ) error { var eg errgroup . Group sem := make ( chan struct { } , 200 ) if err := pachClient . Walk ( commit . Repo . Name , commit . ID , "" , func ( fileInfo * pfs . FileInfo ) error { if fileInfo . FileType != pfs . FileType_FILE { return nil } eg . Go ( func ( ) ( retErr error ) { sem <- struct { } { } defer func ( ) { <- sem } ( ) w , err := objClient . Writer ( pachClient . Ctx ( ) , filepath . Join ( root , fileInfo . File . Path ) ) if err != nil { return err } defer func ( ) { if err := w . Close ( ) ; err != nil && retErr == nil { retErr = err } } ( ) return pachClient . GetFile ( commit . Repo . Name , commit . ID , fileInfo . File . Path , 0 , 0 , w ) } ) return nil } ) ; err != nil { return err } return eg . Wait ( ) }
2858	func PushFile ( c * pachclient . APIClient , pfc pachclient . PutFileClient , pfsFile * pfs . File , osFile io . ReadSeeker ) error { fileInfo , err := c . InspectFile ( pfsFile . Commit . Repo . Name , pfsFile . Commit . ID , pfsFile . Path ) if err != nil && ! isNotExist ( err ) { return err } var i int var object * pfs . Object if fileInfo != nil { for i , object = range fileInfo . Objects { hash := pfs . NewHash ( ) if _ , err := io . CopyN ( hash , osFile , pfs . ChunkSize ) ; err != nil { if err == io . EOF { break } return err } if object . Hash != pfs . EncodeHash ( hash . Sum ( nil ) ) { break } } } if _ , err := osFile . Seek ( int64 ( i ) * pfs . ChunkSize , 0 ) ; err != nil { return err } _ , err = pfc . PutFileOverwrite ( pfsFile . Commit . Repo . Name , pfsFile . Commit . ID , pfsFile . Path , osFile , int64 ( i ) ) return err }
2859	func ( c APIClient ) Dump ( w io . Writer ) error { goroClient , err := c . DebugClient . Dump ( c . Ctx ( ) , & debug . DumpRequest { } ) if err != nil { return grpcutil . ScrubGRPC ( err ) } return grpcutil . ScrubGRPC ( grpcutil . WriteFromStreamingBytesClient ( goroClient , w ) ) }
2860	func ( c APIClient ) Profile ( profile string , duration time . Duration , w io . Writer ) error { var d * types . Duration if duration != 0 { d = types . DurationProto ( duration ) } profileClient , err := c . DebugClient . Profile ( c . Ctx ( ) , & debug . ProfileRequest { Profile : profile , Duration : d , } ) if err != nil { return grpcutil . ScrubGRPC ( err ) } return grpcutil . ScrubGRPC ( grpcutil . WriteFromStreamingBytesClient ( profileClient , w ) ) }
2861	func ( c APIClient ) Binary ( w io . Writer ) error { binaryClient , err := c . DebugClient . Binary ( c . Ctx ( ) , & debug . BinaryRequest { } ) if err != nil { return grpcutil . ScrubGRPC ( err ) } return grpcutil . ScrubGRPC ( grpcutil . WriteFromStreamingBytesClient ( binaryClient , w ) ) }
2862	func RegisterCacheStats ( cacheName string , groupCacheStats * groupcache . Stats ) { c := & cacheStats { cacheName : cacheName , descriptions : make ( map [ string ] * prometheus . Desc ) , stats : groupCacheStats , } if err := prometheus . Register ( c ) ; err != nil { if _ , ok := err . ( prometheus . AlreadyRegisteredError ) ; ! ok { logrus . Infof ( "error registering prometheus metric: %v" , err ) } } }
2863	func ( c * counter ) wait ( n int64 ) { c . mu . Lock ( ) defer c . mu . Unlock ( ) for c . n < n { c . cond . Wait ( ) } }
2864	func RunWorkload ( client * client . APIClient , rand * rand . Rand , size int , ) error { worker := newWorker ( rand ) for i := 0 ; i < size ; i ++ { if err := worker . work ( client ) ; err != nil { return err } } for _ , job := range worker . startedJobs { jobInfo , err := client . InspectJob ( job . ID , true ) if err != nil { return err } if jobInfo . State != pps . JobState_JOB_SUCCESS { return fmt . Errorf ( "job %s failed" , job . ID ) } } return nil }
2865	func ( w * worker ) createRepo ( c * client . APIClient ) error { repoName := w . randString ( 10 ) if err := c . CreateRepo ( repoName ) ; err != nil { return err } w . repos = append ( w . repos , & pfs . Repo { Name : repoName } ) commit , err := c . StartCommit ( repoName , "" ) if err != nil { return err } w . started = append ( w . started , commit ) return nil }
2866	func ( w * worker ) advanceCommit ( c * client . APIClient ) error { if len ( w . started ) >= maxStartedCommits || len ( w . finished ) == 0 { if len ( w . started ) == 0 { return nil } i := w . rand . Intn ( len ( w . started ) ) commit := w . started [ i ] if _ , err := c . PutFile ( commit . Repo . Name , commit . ID , w . randString ( 10 ) , w . reader ( ) ) ; err != nil { return err } if err := c . FinishCommit ( commit . Repo . Name , commit . ID ) ; err != nil { return err } w . started = append ( w . started [ : i ] , w . started [ i + 1 : ] ... ) w . finished = append ( w . finished , commit ) } else { commit := w . finished [ w . rand . Intn ( len ( w . finished ) ) ] commit , err := c . StartCommitParent ( commit . Repo . Name , "" , commit . ID ) if err != nil { return err } w . started = append ( w . started , commit ) } return nil }
2867	func RandString ( r * rand . Rand , n int ) string { b := make ( [ ] byte , n ) for i := range b { b [ i ] = letters [ r . Intn ( len ( letters ) ) ] } return string ( b ) }
2868	func NewReader ( rand * rand . Rand , bytes int64 ) io . Reader { return & reader { rand : rand , bytes : bytes , } }
2869	func iterDir ( tx * bolt . Tx , path string , f func ( k , v [ ] byte , c * bolt . Cursor ) error ) error { node , err := get ( tx , path ) if err != nil { return err } if node . DirNode == nil { return errorf ( PathConflict , "the file at \"%s\" is not a directory" , \" ) } \" path c := NewChildCursor ( tx , path ) }
2870	func ( h * dbHashTree ) FSSize ( ) int64 { rootNode , err := h . Get ( "/" ) if err != nil { return 0 } return rootNode . SubtreeSize }
2871	func ( h * dbHashTree ) Diff ( oldHashTree HashTree , newPath string , oldPath string , recursiveDepth int64 , f func ( path string , node * NodeProto , new bool ) error ) ( retErr error ) { old := oldHashTree . ( * dbHashTree ) if old == nil { return fmt . Errorf ( "unrecognized HashTree type" ) } rollback := func ( tx * bolt . Tx ) { if err := tx . Rollback ( ) ; err != nil && retErr == nil { retErr = err } } var newTx * bolt . Tx var oldTx * bolt . Tx if h == oldHashTree { tx , err := h . Begin ( false ) if err != nil { return err } newTx = tx oldTx = tx defer rollback ( tx ) } else { var err error newTx , err = h . Begin ( false ) if err != nil { return err } defer rollback ( newTx ) oldTx , err = old . Begin ( false ) if err != nil { return err } defer rollback ( oldTx ) } return diff ( newTx , oldTx , newPath , oldPath , recursiveDepth , f ) }
2872	func ( h * dbHashTree ) Serialize ( _w io . Writer ) error { w := pbutil . NewWriter ( _w ) return h . View ( func ( tx * bolt . Tx ) error { for _ , bucket := range buckets { b := tx . Bucket ( b ( bucket ) ) if _ , err := w . Write ( & BucketHeader { Bucket : bucket , } ) ; err != nil { return err } if err := b . ForEach ( func ( k , v [ ] byte ) error { if _ , err := w . WriteBytes ( k ) ; err != nil { return err } _ , err := w . WriteBytes ( v ) return err } ) ; err != nil { return err } if _ , err := w . WriteBytes ( SentinelByte ) ; err != nil { return err } } return nil } ) }
2873	func ( h * dbHashTree ) Deserialize ( _r io . Reader ) error { r := pbutil . NewReader ( _r ) hdr := & BucketHeader { } batchSize := 10000 kvs := make ( chan * keyValue , batchSize / 10 ) eg , copyCtx := errgroup . WithContext ( context . Background ( ) ) eg . Go ( func ( ) error { var bucket [ ] byte for { count := 0 if err := h . Update ( func ( tx * bolt . Tx ) error { if bucket != nil { tx . Bucket ( bucket ) . FillPercent = 1 } for kv := range kvs { if kv . k == nil { bucket = kv . v continue } if err := tx . Bucket ( bucket ) . Put ( kv . k , kv . v ) ; err != nil { return err } count ++ if count >= batchSize { return nil } } return nil } ) ; err != nil || copyCtx . Err ( ) != nil { return err } if count <= 0 { return nil } } } ) eg . Go ( func ( ) error { defer close ( kvs ) for { hdr . Reset ( ) if err := r . Read ( hdr ) ; err != nil { if err == io . EOF { break } return err } bucket := b ( hdr . Bucket ) select { case kvs <- & keyValue { nil , bucket } : case <- copyCtx . Done ( ) : return nil } for { _k , err := r . ReadBytes ( ) if err != nil { return err } if bytes . Equal ( _k , SentinelByte ) { break } k := make ( [ ] byte , len ( _k ) ) copy ( k , _k ) _v , err := r . ReadBytes ( ) if err != nil { return err } v := make ( [ ] byte , len ( _v ) ) copy ( v , _v ) select { case kvs <- & keyValue { k , v } : case <- copyCtx . Done ( ) : return nil } } } return nil } ) return eg . Wait ( ) }
2874	func ( h * dbHashTree ) Copy ( ) ( HashTree , error ) { if err := h . Hash ( ) ; err != nil { return nil , err } r , w := io . Pipe ( ) var eg errgroup . Group eg . Go ( func ( ) ( retErr error ) { defer func ( ) { if err := w . Close ( ) ; err != nil && retErr == nil { retErr = err } } ( ) return h . Serialize ( w ) } ) var result HashTree eg . Go ( func ( ) error { var err error result , err = DeserializeDBHashTree ( pathlib . Dir ( h . Path ( ) ) , r ) return err } ) if err := eg . Wait ( ) ; err != nil { return nil , err } return result , nil }
2875	func ( h * dbHashTree ) Destroy ( ) error { path := h . Path ( ) if err := h . Close ( ) ; err != nil { return err } return os . Remove ( path ) }
2876	func ( h * dbHashTree ) PutFileOverwrite ( path string , objects [ ] * pfs . Object , overwriteIndex * pfs . OverwriteIndex , sizeDelta int64 ) error { return h . putFile ( path , objects , overwriteIndex , sizeDelta , false ) }
2877	func ( h * dbHashTree ) PutDirHeaderFooter ( path string , header , footer * pfs . Object , headerSize , footerSize int64 ) error { path = clean ( path ) return h . Batch ( func ( tx * bolt . Tx ) error { node , err := get ( tx , path ) if err != nil && Code ( err ) != PathNotFound { return errorf ( Internal , "could not get node at %q: %v" , path , err ) } if node != nil && node . nodetype ( ) != directory { return errorf ( PathConflict , "cannot add header to non-directory file " + "at %q; a file of type %s is already there" , path , node . nodetype ( ) ) } var newNode bool if node == nil { newNode = true node = & NodeProto { Name : base ( path ) , DirNode : & DirectoryNodeProto { Shared : & Shared { } , } , SubtreeSize : headerSize + footerSize , } } headerSame := ( node . DirNode . Shared . Header == nil && header == nil ) || ( node . DirNode . Shared . Header != nil && node . DirNode . Shared . Header . Hash == header . Hash ) footerSame := ( node . DirNode . Shared . Footer == nil && footer == nil ) || ( node . DirNode . Shared . Footer != nil && node . DirNode . Shared . Footer . Hash == footer . Hash ) if newNode || ! headerSame || ! footerSame { node . DirNode . Shared = & Shared { Header : header , Footer : footer , HeaderSize : headerSize , FooterSize : footerSize , } return put ( tx , path , node ) } return nil } ) }
2878	func ( h * dbHashTree ) PutFileHeaderFooter ( path string , objects [ ] * pfs . Object , size int64 ) error { return h . putFile ( path , objects , nil , size , true ) }
2879	func deleteDir ( tx * bolt . Tx , path string ) error { c := fs ( tx ) . Cursor ( ) prefix := append ( b ( path ) , nullByte [ 0 ] ) for k , _ := c . Seek ( prefix ) ; bytes . HasPrefix ( k , prefix ) ; k , _ = c . Next ( ) { if err := c . Delete ( ) ; err != nil { return err } } return fs ( tx ) . Delete ( b ( path ) ) }
2880	func NewReader ( r io . Reader , filter Filter ) * Reader { return & Reader { pbr : pbutil . NewReader ( r ) , filter : filter , } }
2881	func ( r * Reader ) Read ( ) ( * MergeNode , error ) { _k , err := r . pbr . ReadBytes ( ) if err != nil { return nil , err } if r . filter != nil { for { if r . filter ( _k ) { break } _ , err = r . pbr . ReadBytes ( ) if err != nil { return nil , err } _k , err = r . pbr . ReadBytes ( ) if err != nil { return nil , err } } } k := make ( [ ] byte , len ( _k ) ) copy ( k , _k ) _v , err := r . pbr . ReadBytes ( ) if err != nil { return nil , err } v := make ( [ ] byte , len ( _v ) ) copy ( v , _v ) return & MergeNode { k : k , v : v , } , nil }
2882	func NewWriter ( w io . Writer ) * Writer { return & Writer { pbw : pbutil . NewWriter ( w ) , } }
2883	func ( w * Writer ) Write ( n * MergeNode ) error { if n . nodeProto != nil { var err error n . v , err = n . nodeProto . Marshal ( ) if err != nil { return err } } if bytes . Equal ( n . k , nullByte ) { if n . nodeProto == nil { n . nodeProto = & NodeProto { } if err := n . nodeProto . Unmarshal ( n . v ) ; err != nil { return err } } w . size = uint64 ( n . nodeProto . SubtreeSize ) } if w . offset > uint64 ( len ( w . idxs ) + 1 ) * IndexSize { w . idxs = append ( w . idxs , & Index { K : n . k , Offset : w . offset , } ) } b , err := w . pbw . WriteBytes ( n . k ) if err != nil { return err } w . offset += uint64 ( b ) b , err = w . pbw . WriteBytes ( n . v ) if err != nil { return err } w . offset += uint64 ( b ) return nil }
2884	func ( w * Writer ) Copy ( r * Reader ) error { for { n , err := r . Read ( ) if err != nil { if err == io . EOF { return nil } return err } if err := w . Write ( n ) ; err != nil { return err } } }
2885	func ( w * Writer ) Index ( ) ( [ ] byte , error ) { buf := & bytes . Buffer { } pbw := pbutil . NewWriter ( buf ) for _ , idx := range w . idxs { if _ , err := pbw . Write ( idx ) ; err != nil { return nil , err } } return buf . Bytes ( ) , nil }
2886	func GetRangeFromIndex ( r io . Reader , prefix string ) ( uint64 , uint64 , error ) { prefix = clean ( prefix ) pbr := pbutil . NewReader ( r ) idx := & Index { } k := b ( prefix ) var lower , upper uint64 iter := func ( f func ( int ) bool ) error { for { if err := pbr . Read ( idx ) ; err != nil { if err == io . EOF { break } return err } var cmp int if len ( k ) < len ( idx . K ) { cmp = bytes . Compare ( k , idx . K [ : len ( k ) ] ) } else { cmp = bytes . Compare ( k [ : len ( idx . K ) ] , idx . K ) } if f ( cmp ) { break } } return nil } low := func ( cmp int ) bool { if cmp > 0 { lower = idx . Offset return false } else if cmp < 0 { upper = idx . Offset } return true } up := func ( cmp int ) bool { if cmp < 0 { upper = idx . Offset return true } return false } iter ( low ) if upper <= 0 { iter ( up ) } if upper <= 0 { return lower , 0 , nil } return lower , upper - lower , nil }
2887	func NewFilter ( numTrees int64 , tree int64 ) Filter { return func ( k [ ] byte ) bool { if pathToTree ( k , numTrees ) == uint64 ( tree ) { return true } return false } }
2888	func PathToTree ( path string , numTrees int64 ) uint64 { path = clean ( path ) return pathToTree ( b ( path ) , numTrees ) }
2889	func Merge ( w * Writer , rs [ ] * Reader ) error { if len ( rs ) == 0 { return nil } mq := & mergePQ { q : make ( [ ] * nodeStream , len ( rs ) + 1 ) } for _ , r := range rs { if err := mq . insert ( & nodeStream { r : r } ) ; err != nil { return err } } for mq . q [ 1 ] != nil { ns , err := mq . next ( ) if err != nil { return err } n , err := merge ( ns ) if err != nil { return err } if err := w . Write ( n ) ; err != nil { return err } } return nil }
2890	func ( h * dbHashTree ) Hash ( ) error { return h . Batch ( func ( tx * bolt . Tx ) error { return canonicalize ( tx , "" ) } ) }
2891	func IsGlob ( pattern string ) bool { pattern = clean ( pattern ) return globRegex . Match ( [ ] byte ( pattern ) ) }
2892	func GlobLiteralPrefix ( pattern string ) string { pattern = clean ( pattern ) idx := globRegex . FindStringIndex ( pattern ) if idx == nil { return pattern } return pattern [ : idx [ 0 ] ] }
2893	func GetHashTreeObject ( pachClient * client . APIClient , storageRoot string , treeRef * pfs . Object ) ( HashTree , error ) { return getHashTree ( storageRoot , func ( w io . Writer ) error { return pachClient . GetObject ( treeRef . Hash , w ) } ) }
2894	func GetHashTreeTag ( pachClient * client . APIClient , storageRoot string , treeRef * pfs . Tag ) ( HashTree , error ) { return getHashTree ( storageRoot , func ( w io . Writer ) error { return pachClient . GetTag ( treeRef . Name , w ) } ) }
2895	func PutHashTree ( pachClient * client . APIClient , tree HashTree , tags ... string ) ( * pfs . Object , error ) { r , w := io . Pipe ( ) var eg errgroup . Group eg . Go ( func ( ) ( retErr error ) { defer func ( ) { if err := w . Close ( ) ; err != nil && retErr == nil { retErr = err } } ( ) return tree . Serialize ( w ) } ) var treeRef * pfs . Object eg . Go ( func ( ) error { var err error treeRef , _ , err = pachClient . PutObject ( r , tags ... ) return err } ) if err := eg . Wait ( ) ; err != nil { return nil , err } return treeRef , nil }
2896	func NewChildCursor ( tx * bolt . Tx , path string ) * ChildCursor { path = clean ( path ) c := fs ( tx ) . Cursor ( ) dir := b ( path ) k , v := c . Seek ( append ( dir , nullByte [ 0 ] ) ) if ! bytes . Equal ( dir , nullByte ) { dir = append ( dir , nullByte [ 0 ] ) } if ! bytes . HasPrefix ( k , dir ) { k , v = nil , nil } return & ChildCursor { c : c , dir : dir , k : k , v : v , } }
2897	func ( d * ChildCursor ) Next ( ) ( [ ] byte , [ ] byte ) { if d . k == nil { return nil , nil } k , v := d . c . Seek ( append ( d . k , 1 ) ) if ! bytes . HasPrefix ( k , d . dir ) { k , v = nil , nil } d . k , d . v = k , v return k , v }
2898	func NewOrdered ( root string ) * Ordered { root = clean ( root ) o := & Ordered { } n := & node { path : "" , nodeProto : & NodeProto { Name : "" , DirNode : & DirectoryNodeProto { } , } , hash : sha256 . New ( ) , } o . fs = append ( o . fs , n ) o . dirStack = append ( o . dirStack , n ) o . MkdirAll ( root ) o . root = root return o }
2899	func ( o * Ordered ) MkdirAll ( path string ) { var paths [ ] string for path != "" { paths = append ( paths , path ) path , _ = split ( path ) } for i := len ( paths ) - 1 ; i >= 0 ; i -- { o . PutDir ( paths [ i ] ) } }
2900	func ( o * Ordered ) PutDir ( path string ) { path = clean ( path ) if path == "" { return } nodeProto := & NodeProto { Name : base ( path ) , DirNode : & DirectoryNodeProto { } , } o . putDir ( path , nodeProto ) }
2901	func ( o * Ordered ) Serialize ( _w io . Writer ) error { w := NewWriter ( _w ) for len ( o . dirStack ) > 1 { child := o . dirStack [ len ( o . dirStack ) - 1 ] child . nodeProto . Hash = child . hash . Sum ( nil ) o . dirStack = o . dirStack [ : len ( o . dirStack ) - 1 ] parent := o . dirStack [ len ( o . dirStack ) - 1 ] parent . hash . Write ( [ ] byte ( fmt . Sprintf ( "%s:%s:" , child . nodeProto . Name , child . nodeProto . Hash ) ) ) parent . nodeProto . SubtreeSize += child . nodeProto . SubtreeSize } o . fs [ 0 ] . nodeProto . Hash = o . fs [ 0 ] . hash . Sum ( nil ) for _ , n := range o . fs { if err := w . Write ( & MergeNode { k : b ( n . path ) , nodeProto : n . nodeProto , } ) ; err != nil { return err } } return nil }
2902	func NewUnordered ( root string ) * Unordered { return & Unordered { fs : make ( map [ string ] * NodeProto ) , root : clean ( root ) , } }
2903	func ( u * Unordered ) Ordered ( ) * Ordered { paths := make ( [ ] string , len ( u . fs ) ) i := 0 for path := range u . fs { paths [ i ] = path i ++ } sort . Strings ( paths ) o := NewOrdered ( "" ) for i := 1 ; i < len ( paths ) ; i ++ { path := paths [ i ] n := u . fs [ path ] if n . DirNode != nil { o . putDir ( path , n ) } else { o . putFile ( path , n ) } } return o }
2904	func revokeUserCredentials ( ctx context . Context , pachdAddress string , userToken string , adminToken string ) error { client , err := pclient . NewFromAddress ( pachdAddress ) if err != nil { return err } defer client . Close ( ) client = client . WithCtx ( ctx ) client . SetAuthToken ( adminToken ) _ , err = client . AuthAPIClient . RevokeAuthToken ( client . Ctx ( ) , & auth . RevokeAuthTokenRequest { Token : userToken , } ) return err }
2905	func NewAPIServer ( version * pb . Version , options APIServerOptions ) pb . APIServer { return newAPIServer ( version , options ) }
2906	func String ( v * pb . Version ) string { return fmt . Sprintf ( "%d.%d.%d%s" , v . Major , v . Minor , v . Micro , v . Additional ) }
2907	func getPipelineInfo ( pachClient * client . APIClient , env * serviceenv . ServiceEnv ) ( * pps . PipelineInfo , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , 30 * time . Second ) defer cancel ( ) resp , err := env . GetEtcdClient ( ) . Get ( ctx , path . Join ( env . PPSEtcdPrefix , "pipelines" , env . PPSPipelineName ) ) if err != nil { return nil , err } if len ( resp . Kvs ) != 1 { return nil , fmt . Errorf ( "expected to find 1 pipeline (%s), got %d: %v" , env . PPSPipelineName , len ( resp . Kvs ) , resp ) } var pipelinePtr pps . EtcdPipelineInfo if err := pipelinePtr . Unmarshal ( resp . Kvs [ 0 ] . Value ) ; err != nil { return nil , err } pachClient . SetAuthToken ( pipelinePtr . AuthToken ) pipelinePtr . SpecCommit . ID = env . PPSSpecCommitID return ppsutil . GetPipelineInfo ( pachClient , & pipelinePtr , true ) }
2908	func removeStr ( ss * [ ] string , s string ) bool { idx := sort . SearchStrings ( * ss , s ) if idx == len ( * ss ) { return false } copy ( ( * ss ) [ idx : ] , ( * ss ) [ idx + 1 : ] ) * ss = ( * ss ) [ : len ( * ss ) - 1 ] return true }
2909	func PublicCertToPEM ( cert * tls . Certificate ) [ ] byte { return pem . EncodeToMemory ( & pem . Block { Type : "CERTIFICATE" , Bytes : cert . Certificate [ 0 ] , } ) }
2910	func GenerateSelfSignedCert ( address string , name * pkix . Name , ipAddresses ... string ) ( * tls . Certificate , error ) { if name == nil { name = & pkix . Name { } } switch { case address == "" && name . CommonName == "" : return nil , errors . New ( "must set either \"address\" or \"name.CommonName\"" ) \" \" \" } \" case address != "" && name . CommonName == "" : name . CommonName = address case address != "" && name . CommonName != "" && name . CommonName != address : return nil , fmt . Errorf ( "set address to \"%s\" but name.CommonName to \"%s\"" , \" , \" ) \" \" address name . CommonName default : parsedIPs := [ ] net . IP { } for _ , strIP := range ipAddresses { nextParsedIP := net . ParseIP ( strIP ) if nextParsedIP == nil { return nil , fmt . Errorf ( "invalid IP: %s" , strIP ) } parsedIPs = append ( parsedIPs , nextParsedIP ) } }
2911	func ActivateCmd ( noMetrics , noPortForwarding * bool ) * cobra . Command { var initialAdmin string activate := & cobra . Command { Short : "Activate Pachyderm's auth system" , Long : `Activate Pachyderm's auth system, and restrict access to existing data to theuser running the command (or the argument to --initial-admin), who will be thefirst cluster admin` [ 1 : ] , Run : cmdutil . Run ( func ( args [ ] string ) error { var token string var err error if ! strings . HasPrefix ( initialAdmin , auth . RobotPrefix ) { token , err = githubLogin ( ) if err != nil { return err } } fmt . Println ( "Retrieving Pachyderm token..." ) c , err := client . NewOnUserMachine ( ! * noMetrics , ! * noPortForwarding , "user" ) if err != nil { return fmt . Errorf ( "could not connect: %v" , err ) } defer c . Close ( ) resp , err := c . Activate ( c . Ctx ( ) , & auth . ActivateRequest { GitHubToken : token , Subject : initialAdmin , } ) if err != nil { return fmt . Errorf ( "error activating Pachyderm auth: %v" , grpcutil . ScrubGRPC ( err ) ) } if err := writePachTokenToCfg ( resp . PachToken ) ; err != nil { return err } if strings . HasPrefix ( initialAdmin , auth . RobotPrefix ) { fmt . Println ( "WARNING: DO NOT LOSE THE ROBOT TOKEN BELOW WITHOUT " + "ADDING OTHER ADMINS.\nIF YOU DO, YOU WILL BE PERMANENTLY LOCKED OUT " + \n ) "OF YOUR CLUSTER!" } fmt . Printf ( "Pachyderm token for \"%s\":\n%s\n" , \" , \" ) } ) , } \n \n }
2912	func DeactivateCmd ( noMetrics , noPortForwarding * bool ) * cobra . Command { deactivate := & cobra . Command { Short : "Delete all ACLs, tokens, and admins, and deactivate Pachyderm auth" , Long : "Deactivate Pachyderm's auth system, which will delete ALL auth " + "tokens, ACLs and admins, and expose all data in the cluster to any " + "user with cluster access. Use with caution." , Run : cmdutil . Run ( func ( args [ ] string ) error { fmt . Println ( "Are you sure you want to delete ALL auth information " + "(ACLs, tokens, and admins) in this cluster, and expose ALL data? yN" ) confirm , err := bufio . NewReader ( os . Stdin ) . ReadString ( '\n' ) if ! strings . Contains ( "yY" , confirm [ : 1 ] ) { return fmt . Errorf ( "operation aborted" ) } c , err := client . NewOnUserMachine ( ! * noMetrics , ! * noPortForwarding , "user" ) if err != nil { return fmt . Errorf ( "could not connect: %v" , err ) } defer c . Close ( ) _ , err = c . Deactivate ( c . Ctx ( ) , & auth . DeactivateRequest { } ) return grpcutil . ScrubGRPC ( err ) } ) , } return cmdutil . CreateAlias ( deactivate , "auth deactivate" ) }
2913	func LoginCmd ( noMetrics , noPortForwarding * bool ) * cobra . Command { var useOTP bool login := & cobra . Command { Short : "Log in to Pachyderm" , Long : "Login to Pachyderm. Any resources that have been restricted to " + "the account you have with your ID provider (e.g. GitHub, Okta) " + "account will subsequently be accessible." , Run : cmdutil . Run ( func ( [ ] string ) error { c , err := client . NewOnUserMachine ( ! * noMetrics , ! * noPortForwarding , "user" ) if err != nil { return fmt . Errorf ( "could not connect: %v" , err ) } defer c . Close ( ) var resp * auth . AuthenticateResponse var authErr error if useOTP { fmt . Println ( "Please enter your Pachyderm One-Time Password:" ) code , err := bufio . NewReader ( os . Stdin ) . ReadString ( '\n' ) if err != nil { return fmt . Errorf ( "error reading One-Time Password: %v" , err ) } code = strings . TrimSpace ( code ) resp , authErr = c . Authenticate ( c . Ctx ( ) , & auth . AuthenticateRequest { OneTimePassword : code } ) } else { token , err := githubLogin ( ) if err != nil { return err } fmt . Println ( "Retrieving Pachyderm token..." ) resp , authErr = c . Authenticate ( c . Ctx ( ) , & auth . AuthenticateRequest { GitHubToken : token } ) } if authErr != nil { if auth . IsErrPartiallyActivated ( authErr ) { return fmt . Errorf ( "%v: if pachyderm is stuck in this state, you " + "can revert by running 'pachctl auth deactivate' or retry by " + "running 'pachctl auth activate' again" , authErr ) } return fmt . Errorf ( "error authenticating with Pachyderm cluster: %v" , grpcutil . ScrubGRPC ( authErr ) ) } return writePachTokenToCfg ( resp . PachToken ) } ) , } login . PersistentFlags ( ) . BoolVarP ( & useOTP , "one-time-password" , "o" , false , "If set, authenticate with a Dash-provided One-Time Password, rather than " + "via GitHub" ) return cmdutil . CreateAlias ( login , "auth login" ) }
2914	func LogoutCmd ( ) * cobra . Command { logout := & cobra . Command { Short : "Log out of Pachyderm by deleting your local credential" , Long : "Log out of Pachyderm by deleting your local credential. Note that " + "it's not necessary to log out before logging in with another account " + "(simply run 'pachctl auth login' twice) but 'logout' can be useful on " + "shared workstations." , Run : cmdutil . Run ( func ( [ ] string ) error { cfg , err := config . Read ( ) if err != nil { return fmt . Errorf ( "error reading Pachyderm config (for cluster " + "address): %v" , err ) } if cfg . V1 == nil { return nil } cfg . V1 . SessionToken = "" return cfg . Write ( ) } ) , } return cmdutil . CreateAlias ( logout , "auth logout" ) }
2915	func WhoamiCmd ( noMetrics , noPortForwarding * bool ) * cobra . Command { whoami := & cobra . Command { Short : "Print your Pachyderm identity" , Long : "Print your Pachyderm identity." , Run : cmdutil . Run ( func ( [ ] string ) error { c , err := client . NewOnUserMachine ( ! * noMetrics , ! * noPortForwarding , "user" ) if err != nil { return fmt . Errorf ( "could not connect: %v" , err ) } defer c . Close ( ) resp , err := c . WhoAmI ( c . Ctx ( ) , & auth . WhoAmIRequest { } ) if err != nil { return fmt . Errorf ( "error: %v" , grpcutil . ScrubGRPC ( err ) ) } fmt . Printf ( "You are \"%s\"\n" , \" ) \" \n resp . Username } ) , } if resp . TTL > 0 { fmt . Printf ( "session expires: %v\n" , \n ) } }
2916	func CheckCmd ( noMetrics , noPortForwarding * bool ) * cobra . Command { check := & cobra . Command { Use : "{{alias}} (none|reader|writer|owner) <repo>" , Short : "Check whether you have reader/writer/etc-level access to 'repo'" , Long : "Check whether you have reader/writer/etc-level access to 'repo'. " + "For example, 'pachctl auth check reader private-data' prints \"true\" " + \" + \" + "if the you have at least \"reader\" access to the repo " + \" , \" , } "\"private-data\" (you could be a reader, writer, or owner). Unlike " }
2917	func GetCmd ( noMetrics , noPortForwarding * bool ) * cobra . Command { get := & cobra . Command { Use : "{{alias}} [<username>] <repo>" , Short : "Get the ACL for 'repo' or the access that 'username' has to 'repo'" , Long : "Get the ACL for 'repo' or the access that 'username' has to " + "'repo'. For example, 'pachctl auth get github-alice private-data' " + "prints \"reader\", \"writer\", \"owner\", or \"none\", depending on " + \" + \" + \" , \" , } \" }
2918	func SetScopeCmd ( noMetrics , noPortForwarding * bool ) * cobra . Command { setScope := & cobra . Command { Use : "{{alias}} <username> (none|reader|writer|owner) <repo>" , Short : "Set the scope of access that 'username' has to 'repo'" , Long : "Set the scope of access that 'username' has to 'repo'. For " + "example, 'pachctl auth set github-alice none private-data' prevents " + "\"github-alice\" from interacting with the \"private-data\" repo in any " + \" + \" + \" + \" + "way (the default). Similarly, 'pachctl auth set github-alice reader " , "private-data' would let \"github-alice\" read from \"private-data\" but " , } \" }
2919	func ListAdminsCmd ( noMetrics , noPortForwarding * bool ) * cobra . Command { listAdmins := & cobra . Command { Short : "List the current cluster admins" , Long : "List the current cluster admins" , Run : cmdutil . Run ( func ( [ ] string ) error { c , err := client . NewOnUserMachine ( ! * noMetrics , ! * noPortForwarding , "user" ) if err != nil { return err } defer c . Close ( ) resp , err := c . GetAdmins ( c . Ctx ( ) , & auth . GetAdminsRequest { } ) if err != nil { return grpcutil . ScrubGRPC ( err ) } for _ , user := range resp . Admins { fmt . Println ( user ) } return nil } ) , } return cmdutil . CreateAlias ( listAdmins , "auth list-admins" ) }
2920	func ModifyAdminsCmd ( noMetrics , noPortForwarding * bool ) * cobra . Command { var add [ ] string var remove [ ] string modifyAdmins := & cobra . Command { Short : "Modify the current cluster admins" , Long : "Modify the current cluster admins. --add accepts a comma-" + "separated list of users to grant admin status, and --remove accepts a " + "comma-separated list of users to revoke admin status" , Run : cmdutil . Run ( func ( [ ] string ) error { c , err := client . NewOnUserMachine ( ! * noMetrics , ! * noPortForwarding , "user" ) if err != nil { return err } defer c . Close ( ) _ , err = c . ModifyAdmins ( c . Ctx ( ) , & auth . ModifyAdminsRequest { Add : add , Remove : remove , } ) if auth . IsErrPartiallyActivated ( err ) { return fmt . Errorf ( "%v: if pachyderm is stuck in this state, you " + "can revert by running 'pachctl auth deactivate' or retry by " + "running 'pachctl auth activate' again" , err ) } return grpcutil . ScrubGRPC ( err ) } ) , } modifyAdmins . PersistentFlags ( ) . StringSliceVar ( & add , "add" , [ ] string { } , "Comma-separated list of users to grant admin status" ) modifyAdmins . PersistentFlags ( ) . StringSliceVar ( & remove , "remove" , [ ] string { } , "Comma-separated list of users revoke admin status" ) return cmdutil . CreateAlias ( modifyAdmins , "auth modify-admins" ) }
2921	func GetAuthTokenCmd ( noMetrics , noPortForwarding * bool ) * cobra . Command { var quiet bool getAuthToken := & cobra . Command { Use : "{{alias}} <username>" , Short : "Get an auth token that authenticates the holder as \"username\"" , \" , \" , } Long : "Get an auth token that authenticates the holder as \"username\"; " + \" \" }
2922	func UseAuthTokenCmd ( ) * cobra . Command { useAuthToken := & cobra . Command { Short : "Read a Pachyderm auth token from stdin, and write it to the " + "current user's Pachyderm config file" , Long : "Read a Pachyderm auth token from stdin, and write it to the " + "current user's Pachyderm config file" , Run : cmdutil . RunFixedArgs ( 0 , func ( args [ ] string ) error { fmt . Println ( "Please paste your Pachyderm auth token:" ) token , err := bufio . NewReader ( os . Stdin ) . ReadString ( '\n' ) if err != nil { return fmt . Errorf ( "error reading token: %v" , err ) } writePachTokenToCfg ( strings . TrimSpace ( token ) ) return nil } ) , } return cmdutil . CreateAlias ( useAuthToken , "auth use-auth-token" ) }
2923	func Cmds ( noMetrics , noPortForwarding * bool ) [ ] * cobra . Command { var commands [ ] * cobra . Command auth := & cobra . Command { Short : "Auth commands manage access to data in a Pachyderm cluster" , Long : "Auth commands manage access to data in a Pachyderm cluster" , } commands = append ( commands , cmdutil . CreateAlias ( auth , "auth" ) ) commands = append ( commands , ActivateCmd ( noMetrics , noPortForwarding ) ) commands = append ( commands , DeactivateCmd ( noMetrics , noPortForwarding ) ) commands = append ( commands , LoginCmd ( noMetrics , noPortForwarding ) ) commands = append ( commands , LogoutCmd ( ) ) commands = append ( commands , WhoamiCmd ( noMetrics , noPortForwarding ) ) commands = append ( commands , CheckCmd ( noMetrics , noPortForwarding ) ) commands = append ( commands , SetScopeCmd ( noMetrics , noPortForwarding ) ) commands = append ( commands , GetCmd ( noMetrics , noPortForwarding ) ) commands = append ( commands , ListAdminsCmd ( noMetrics , noPortForwarding ) ) commands = append ( commands , ModifyAdminsCmd ( noMetrics , noPortForwarding ) ) commands = append ( commands , GetAuthTokenCmd ( noMetrics , noPortForwarding ) ) commands = append ( commands , UseAuthTokenCmd ( ) ) commands = append ( commands , GetConfigCmd ( noPortForwarding ) ) commands = append ( commands , SetConfigCmd ( noPortForwarding ) ) return commands }
2924	func ParseScope ( s string ) ( Scope , error ) { for name , value := range Scope_value { if strings . EqualFold ( s , name ) { return Scope ( value ) , nil } } return Scope_NONE , fmt . Errorf ( "unrecognized scope: %s" , s ) }
2925	func IsErrNotActivated ( err error ) bool { if err == nil { return false } return strings . Contains ( err . Error ( ) , status . Convert ( ErrNotActivated ) . Message ( ) ) }
2926	func IsErrPartiallyActivated ( err error ) bool { if err == nil { return false } return strings . Contains ( err . Error ( ) , status . Convert ( ErrPartiallyActivated ) . Message ( ) ) }
2927	func IsErrNotSignedIn ( err error ) bool { if err == nil { return false } return strings . Contains ( err . Error ( ) , status . Convert ( ErrNotSignedIn ) . Message ( ) ) }
2928	func IsErrBadToken ( err error ) bool { if err == nil { return false } return strings . Contains ( err . Error ( ) , status . Convert ( ErrBadToken ) . Message ( ) ) }
2929	func IsErrNotAuthorized ( err error ) bool { if err == nil { return false } return strings . Contains ( err . Error ( ) , errNotAuthorizedMsg ) }
2930	func IsErrInvalidPrincipal ( err error ) bool { if err == nil { return false } return strings . Contains ( err . Error ( ) , "invalid principal \"" ) && \" }
2931	func IsErrTooShortTTL ( err error ) bool { if err == nil { return false } errMsg := err . Error ( ) return strings . Contains ( errMsg , "provided TTL (" ) && strings . Contains ( errMsg , ") is shorter than token's existing TTL (" ) && strings . Contains ( errMsg , ")" ) }
2932	func NewDatumFactory ( pachClient * client . APIClient , input * pps . Input ) ( DatumFactory , error ) { switch { case input . Pfs != nil : return newPFSDatumFactory ( pachClient , input . Pfs ) case input . Union != nil : return newUnionDatumFactory ( pachClient , input . Union ) case input . Cross != nil : return newCrossDatumFactory ( pachClient , input . Cross ) case input . Cron != nil : return newCronDatumFactory ( pachClient , input . Cron ) case input . Git != nil : return newGitDatumFactory ( pachClient , input . Git ) } return nil , fmt . Errorf ( "unrecognized input type" ) }
2933	func NewCollection ( etcdClient * etcd . Client , prefix string , indexes [ ] * Index , template proto . Message , keyCheck func ( string ) error , valCheck func ( proto . Message ) error ) Collection { if len ( prefix ) > 0 && prefix [ len ( prefix ) - 1 ] != '/' { prefix = prefix + "/" } return & collection { prefix : prefix , etcdClient : etcdClient , indexes : indexes , limit : defaultLimit , template : template , keyCheck : keyCheck , valCheck : valCheck , } }
2934	func ( c * collection ) Path ( key string ) string { return path . Join ( c . prefix , key ) }
2935	func ( c * readWriteCollection ) getIndexPath ( val interface { } , index * Index , key string ) string { reflVal := reflect . ValueOf ( val ) field := reflect . Indirect ( reflVal ) . FieldByName ( index . Field ) . Interface ( ) return c . indexPath ( index , field , key ) }
2936	func ( c * readWriteCollection ) getMultiIndexPaths ( val interface { } , index * Index , key string ) [ ] string { var indexPaths [ ] string field := reflect . Indirect ( reflect . ValueOf ( val ) ) . FieldByName ( index . Field ) for i := 0 ; i < field . Len ( ) ; i ++ { indexPaths = append ( indexPaths , c . indexPath ( index , field . Index ( i ) . Interface ( ) , key ) ) } return indexPaths }
2937	func ( c * readWriteCollection ) Upsert ( key string , val proto . Message , f func ( ) error ) error { if err := watch . CheckType ( c . template , val ) ; err != nil { return err } if err := c . Get ( key , val ) ; err != nil && ! IsErrNotFound ( err ) { return err } if err := f ( ) ; err != nil { return err } return c . Put ( key , val ) }
2938	func ( c * readonlyCollection ) get ( key string , opts ... etcd . OpOption ) ( * etcd . GetResponse , error ) { span , ctx := tracing . AddSpanToAnyExisting ( c . ctx , "etcd.Get" ) defer tracing . FinishAnySpan ( span ) resp , err := c . etcdClient . Get ( ctx , key , opts ... ) return resp , err }
2939	func ( c * readonlyCollection ) List ( val proto . Message , opts * Options , f func ( string ) error ) error { if err := watch . CheckType ( c . template , val ) ; err != nil { return err } return c . list ( c . prefix , & c . limit , opts , func ( kv * mvccpb . KeyValue ) error { if err := proto . Unmarshal ( kv . Value , val ) ; err != nil { return err } return f ( strings . TrimPrefix ( string ( kv . Key ) , c . prefix ) ) } ) }
2940	func ( c * readonlyCollection ) Watch ( opts ... watch . OpOption ) ( watch . Watcher , error ) { return watch . NewWatcher ( c . ctx , c . etcdClient , c . prefix , c . prefix , c . template , opts ... ) }
2941	func ( c * readonlyCollection ) WatchByIndex ( index * Index , val interface { } ) ( watch . Watcher , error ) { eventCh := make ( chan * watch . Event ) done := make ( chan struct { } ) watcher , err := watch . NewWatcher ( c . ctx , c . etcdClient , c . prefix , c . indexDir ( index , val ) , c . template ) if err != nil { return nil , err } go func ( ) ( retErr error ) { defer func ( ) { if retErr != nil { eventCh <- & watch . Event { Type : watch . EventError , Err : retErr , } watcher . Close ( ) } close ( eventCh ) } ( ) for { var ev * watch . Event var ok bool select { case ev , ok = <- watcher . Watch ( ) : case <- done : watcher . Close ( ) return nil } if ! ok { watcher . Close ( ) return nil } var directEv * watch . Event switch ev . Type { case watch . EventError : return ev . Err case watch . EventPut : resp , err := c . get ( c . Path ( path . Base ( string ( ev . Key ) ) ) ) if err != nil { return err } if len ( resp . Kvs ) == 0 { continue } directEv = & watch . Event { Key : [ ] byte ( path . Base ( string ( ev . Key ) ) ) , Value : resp . Kvs [ 0 ] . Value , Type : ev . Type , Template : c . template , } case watch . EventDelete : directEv = & watch . Event { Key : [ ] byte ( path . Base ( string ( ev . Key ) ) ) , Type : ev . Type , Template : c . template , } } eventCh <- directEv } } ( ) return watch . MakeWatcher ( eventCh , done ) , nil }
2942	func ( c * readonlyCollection ) WatchOne ( key string ) ( watch . Watcher , error ) { return watch . NewWatcher ( c . ctx , c . etcdClient , c . prefix , c . Path ( key ) , c . template ) }
2943	func ( c * readonlyCollection ) WatchOneF ( key string , f func ( e * watch . Event ) error ) error { watcher , err := watch . NewWatcher ( c . ctx , c . etcdClient , c . prefix , c . Path ( key ) , c . template ) if err != nil { return err } defer watcher . Close ( ) for { select { case e := <- watcher . Watch ( ) : if err := f ( e ) ; err != nil { if err == errutil . ErrBreak { return nil } return err } case <- c . ctx . Done ( ) : return c . ctx . Err ( ) } } }
2944	func ( c * Cache ) Get ( key string ) ( io . ReadCloser , error ) { c . mu . Lock ( ) defer c . mu . Unlock ( ) if ! c . keys [ key ] { return nil , fmt . Errorf ( "key %v not found in cache" , key ) } f , err := os . Open ( filepath . Join ( c . root , key ) ) if err != nil { return nil , err } return f , nil }
2945	func ( c * Cache ) Keys ( ) [ ] string { c . mu . Lock ( ) defer c . mu . Unlock ( ) var keys [ ] string for key := range c . keys { keys = append ( keys , key ) } sort . Strings ( keys ) return keys }
2946	func ( c * Cache ) Clear ( ) error { c . mu . Lock ( ) defer c . mu . Unlock ( ) defer func ( ) { c . keys = make ( map [ string ] bool ) } ( ) for key := range c . keys { if err := os . Remove ( filepath . Join ( c . root , key ) ) ; err != nil { return err } } return nil }
2947	func NewHTTPServer ( address string ) ( http . Handler , error ) { router := httprouter . New ( ) s := & server { router : router , address : address , httpClient : & http . Client { } , } router . GET ( getFilePath , s . getFileHandler ) router . GET ( servicePath , s . serviceHandler ) router . POST ( loginPath , s . authLoginHandler ) router . POST ( logoutPath , s . authLogoutHandler ) router . POST ( servicePath , s . serviceHandler ) router . NotFound = http . HandlerFunc ( notFound ) return s , nil }
2948	func NewDeployServer ( kubeClient * kube . Clientset , kubeNamespace string ) deploy . APIServer { return & apiServer { kubeClient : kubeClient , kubeNamespace : kubeNamespace , } }
2949	func Export ( opts * assets . AssetOpts , out io . Writer ) error { client , err := docker . NewClientFromEnv ( ) if err != nil { return err } authConfigs , err := docker . NewAuthConfigurationsFromDockerCfg ( ) if err != nil { return fmt . Errorf ( "error parsing auth: %s, try running `docker login`" , err . Error ( ) ) } if len ( authConfigs . Configs ) == 0 { return fmt . Errorf ( "didn't find any valid auth configurations" ) } images := assets . Images ( opts ) for _ , image := range images { repository , tag := docker . ParseRepositoryTag ( image ) pulled := false var loopErr [ ] error for registry , authConfig := range authConfigs . Configs { if err := client . PullImage ( docker . PullImageOptions { Repository : repository , Tag : tag , InactivityTimeout : 5 * time . Second , } , authConfig , ) ; err != nil { loopErr = append ( loopErr , fmt . Errorf ( "error pulling from %s: %v" , registry , err ) ) continue } pulled = true break } if ! pulled { errStr := "" for _ , err := range loopErr { errStr += err . Error ( ) + "\n" } \n } } return fmt . Errorf ( "errors pulling image %s:%s:\n%s" , \n , repository , tag ) }
2950	func Import ( opts * assets . AssetOpts , in io . Reader ) error { client , err := docker . NewClientFromEnv ( ) if err != nil { return err } authConfigs , err := docker . NewAuthConfigurationsFromDockerCfg ( ) if err != nil { return fmt . Errorf ( "error parsing auth: %s, try running `docker login`" , err . Error ( ) ) } if len ( authConfigs . Configs ) == 0 { return fmt . Errorf ( "didn't find any valid auth configurations" ) } if err := client . LoadImage ( docker . LoadImageOptions { InputStream : in , } ) ; err != nil { return err } registry := opts . Registry opts . Registry = "" images := assets . Images ( opts ) opts . Registry = registry for _ , image := range images { repository , tag := docker . ParseRepositoryTag ( image ) registryRepo := assets . AddRegistry ( opts . Registry , repository ) if err := client . TagImage ( image , docker . TagImageOptions { Repo : registryRepo , Tag : tag , } , ) ; err != nil { return fmt . Errorf ( "error tagging image: %v" , err ) } pushed := false var loopErr [ ] error for registry , authConfig := range authConfigs . Configs { if err := client . PushImage ( docker . PushImageOptions { Name : registryRepo , Tag : tag , Registry : opts . Registry , InactivityTimeout : 5 * time . Second , } , authConfig , ) ; err != nil { loopErr = append ( loopErr , fmt . Errorf ( "error pushing to %s: %v" , registry , err ) ) continue } pushed = true break } if ! pushed { errStr := "" for _ , err := range loopErr { errStr += err . Error ( ) + "\n" } \n } } return fmt . Errorf ( "errors pushing image %s:%s:\n%s" , \n , registryRepo , tag ) }
2951	func DatumTagPrefix ( salt string ) string { h := sha256 . New ( ) h . Write ( [ ] byte ( salt ) ) return hex . EncodeToString ( h . Sum ( nil ) ) [ : 4 ] }
2952	func NewPFSInput ( repo string , glob string ) * pps . Input { return & pps . Input { Pfs : & pps . PFSInput { Repo : repo , Glob : glob , } , } }
2953	func NewPFSInputOpts ( name string , repo string , branch string , glob string , lazy bool ) * pps . Input { return & pps . Input { Pfs : & pps . PFSInput { Name : name , Repo : repo , Branch : branch , Glob : glob , Lazy : lazy , } , } }
2954	func NewJobInput ( repoName string , commitID string , glob string ) * pps . JobInput { return & pps . JobInput { Commit : NewCommit ( repoName , commitID ) , Glob : glob , } }
2955	func NewPipelineInput ( repoName string , glob string ) * pps . PipelineInput { return & pps . PipelineInput { Repo : NewRepo ( repoName ) , Glob : glob , } }
2956	func ( c APIClient ) CreateJob ( pipeline string , outputCommit * pfs . Commit ) ( * pps . Job , error ) { job , err := c . PpsAPIClient . CreateJob ( c . Ctx ( ) , & pps . CreateJobRequest { Pipeline : NewPipeline ( pipeline ) , OutputCommit : outputCommit , } , ) return job , grpcutil . ScrubGRPC ( err ) }
2957	func ( c APIClient ) ListJob ( pipelineName string , inputCommit [ ] * pfs . Commit , outputCommit * pfs . Commit ) ( [ ] * pps . JobInfo , error ) { var result [ ] * pps . JobInfo if err := c . ListJobF ( pipelineName , inputCommit , outputCommit , func ( ji * pps . JobInfo ) error { result = append ( result , ji ) return nil } ) ; err != nil { return nil , err } return result , nil }
2958	func ( c APIClient ) ListJobF ( pipelineName string , inputCommit [ ] * pfs . Commit , outputCommit * pfs . Commit , f func ( * pps . JobInfo ) error ) error { var pipeline * pps . Pipeline if pipelineName != "" { pipeline = NewPipeline ( pipelineName ) } client , err := c . PpsAPIClient . ListJobStream ( c . Ctx ( ) , & pps . ListJobRequest { Pipeline : pipeline , InputCommit : inputCommit , OutputCommit : outputCommit , } ) if err != nil { return grpcutil . ScrubGRPC ( err ) } for { ji , err := client . Recv ( ) if err == io . EOF { return nil } else if err != nil { return grpcutil . ScrubGRPC ( err ) } if err := f ( ji ) ; err != nil { if err == errutil . ErrBreak { return nil } return err } } }
2959	func ( c APIClient ) FlushJob ( commits [ ] * pfs . Commit , toPipelines [ ] string , f func ( * pps . JobInfo ) error ) error { req := & pps . FlushJobRequest { Commits : commits , } for _ , pipeline := range toPipelines { req . ToPipelines = append ( req . ToPipelines , NewPipeline ( pipeline ) ) } client , err := c . PpsAPIClient . FlushJob ( c . Ctx ( ) , req ) if err != nil { return grpcutil . ScrubGRPC ( err ) } for { jobInfo , err := client . Recv ( ) if err != nil { if err == io . EOF { return nil } return grpcutil . ScrubGRPC ( err ) } if err := f ( jobInfo ) ; err != nil { return err } } }
2960	func ( c APIClient ) FlushJobAll ( commits [ ] * pfs . Commit , toPipelines [ ] string ) ( [ ] * pps . JobInfo , error ) { var result [ ] * pps . JobInfo if err := c . FlushJob ( commits , toPipelines , func ( ji * pps . JobInfo ) error { result = append ( result , ji ) return nil } ) ; err != nil { return nil , err } return result , nil }
2961	func ( c APIClient ) DeleteJob ( jobID string ) error { _ , err := c . PpsAPIClient . DeleteJob ( c . Ctx ( ) , & pps . DeleteJobRequest { Job : NewJob ( jobID ) , } , ) return grpcutil . ScrubGRPC ( err ) }
2962	func ( c APIClient ) StopJob ( jobID string ) error { _ , err := c . PpsAPIClient . StopJob ( c . Ctx ( ) , & pps . StopJobRequest { Job : NewJob ( jobID ) , } , ) return grpcutil . ScrubGRPC ( err ) }
2963	func ( c APIClient ) RestartDatum ( jobID string , datumFilter [ ] string ) error { _ , err := c . PpsAPIClient . RestartDatum ( c . Ctx ( ) , & pps . RestartDatumRequest { Job : NewJob ( jobID ) , DataFilters : datumFilter , } , ) return grpcutil . ScrubGRPC ( err ) }
2964	func ( c APIClient ) ListDatum ( jobID string , pageSize int64 , page int64 ) ( * pps . ListDatumResponse , error ) { client , err := c . PpsAPIClient . ListDatumStream ( c . Ctx ( ) , & pps . ListDatumRequest { Job : NewJob ( jobID ) , PageSize : pageSize , Page : page , } , ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } resp := & pps . ListDatumResponse { } first := true for { r , err := client . Recv ( ) if err == io . EOF { break } else if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } if first { resp . TotalPages = r . TotalPages resp . Page = r . Page first = false } resp . DatumInfos = append ( resp . DatumInfos , r . DatumInfo ) } return resp , nil }
2965	func ( c APIClient ) ListDatumF ( jobID string , pageSize int64 , page int64 , f func ( di * pps . DatumInfo ) error ) error { client , err := c . PpsAPIClient . ListDatumStream ( c . Ctx ( ) , & pps . ListDatumRequest { Job : NewJob ( jobID ) , PageSize : pageSize , Page : page , } , ) if err != nil { return grpcutil . ScrubGRPC ( err ) } for { resp , err := client . Recv ( ) if err == io . EOF { return nil } else if err != nil { return grpcutil . ScrubGRPC ( err ) } if err := f ( resp . DatumInfo ) ; err != nil { if err == errutil . ErrBreak { return nil } return err } } }
2966	func ( c APIClient ) InspectDatum ( jobID string , datumID string ) ( * pps . DatumInfo , error ) { datumInfo , err := c . PpsAPIClient . InspectDatum ( c . Ctx ( ) , & pps . InspectDatumRequest { Datum : & pps . Datum { ID : datumID , Job : NewJob ( jobID ) , } , } , ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } return datumInfo , nil }
2967	func ( l * LogsIter ) Next ( ) bool { if l . err != nil { l . msg = nil return false } l . msg , l . err = l . logsClient . Recv ( ) if l . err != nil { return false } return true }
2968	func ( c APIClient ) InspectPipeline ( pipelineName string ) ( * pps . PipelineInfo , error ) { pipelineInfo , err := c . PpsAPIClient . InspectPipeline ( c . Ctx ( ) , & pps . InspectPipelineRequest { Pipeline : NewPipeline ( pipelineName ) , } , ) return pipelineInfo , grpcutil . ScrubGRPC ( err ) }
2969	func ( c APIClient ) ListPipeline ( ) ( [ ] * pps . PipelineInfo , error ) { pipelineInfos , err := c . PpsAPIClient . ListPipeline ( c . Ctx ( ) , & pps . ListPipelineRequest { } , ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } return pipelineInfos . PipelineInfo , nil }
2970	func ( c APIClient ) DeletePipeline ( name string , force bool ) error { _ , err := c . PpsAPIClient . DeletePipeline ( c . Ctx ( ) , & pps . DeletePipelineRequest { Pipeline : NewPipeline ( name ) , Force : force , } , ) return grpcutil . ScrubGRPC ( err ) }
2971	func ( c APIClient ) StartPipeline ( name string ) error { _ , err := c . PpsAPIClient . StartPipeline ( c . Ctx ( ) , & pps . StartPipelineRequest { Pipeline : NewPipeline ( name ) , } , ) return grpcutil . ScrubGRPC ( err ) }
2972	func ( c APIClient ) StopPipeline ( name string ) error { _ , err := c . PpsAPIClient . StopPipeline ( c . Ctx ( ) , & pps . StopPipelineRequest { Pipeline : NewPipeline ( name ) , } , ) return grpcutil . ScrubGRPC ( err ) }
2973	func ( c APIClient ) RerunPipeline ( name string , include [ ] * pfs . Commit , exclude [ ] * pfs . Commit ) error { _ , err := c . PpsAPIClient . RerunPipeline ( c . Ctx ( ) , & pps . RerunPipelineRequest { Pipeline : NewPipeline ( name ) , Include : include , Exclude : exclude , } , ) return grpcutil . ScrubGRPC ( err ) }
2974	func ( c APIClient ) CreatePipelineService ( name string , image string , cmd [ ] string , stdin [ ] string , parallelismSpec * pps . ParallelismSpec , input * pps . Input , update bool , internalPort int32 , externalPort int32 , ) error { _ , err := c . PpsAPIClient . CreatePipeline ( c . Ctx ( ) , & pps . CreatePipelineRequest { Pipeline : NewPipeline ( name ) , Transform : & pps . Transform { Image : image , Cmd : cmd , Stdin : stdin , } , ParallelismSpec : parallelismSpec , Input : input , Update : update , Service : & pps . Service { InternalPort : internalPort , ExternalPort : externalPort , } , } , ) return grpcutil . ScrubGRPC ( err ) }
2975	func GetDatumTotalTime ( s * pps . ProcessStats ) time . Duration { totalDuration := time . Duration ( 0 ) duration , _ := types . DurationFromProto ( s . DownloadTime ) totalDuration += duration duration , _ = types . DurationFromProto ( s . ProcessTime ) totalDuration += duration duration , _ = types . DurationFromProto ( s . UploadTime ) totalDuration += duration return totalDuration }
2976	func Mount ( c * client . APIClient , mountPoint string , opts * Options ) error { nfs := pathfs . NewPathNodeFs ( newFileSystem ( c , opts . getCommits ( ) ) , nil ) server , _ , err := nodefs . MountRoot ( mountPoint , nfs . Root ( ) , opts . getFuse ( ) ) if err != nil { return fmt . Errorf ( "nodefs.MountRoot: %v" , err ) } sigChan := make ( chan os . Signal , 1 ) signal . Notify ( sigChan , os . Interrupt ) go func ( ) { select { case <- sigChan : case <- opts . getUnmount ( ) : } server . Unmount ( ) } ( ) server . Serve ( ) return nil }
2977	func NewBufPool ( size int ) * BufPool { return & BufPool { sync . Pool { New : func ( ) interface { } { return make ( [ ] byte , size ) } , } } }
2978	func StorageRootFromEnv ( ) ( string , error ) { storageRoot , ok := os . LookupEnv ( PachRootEnvVar ) if ! ok { return "" , fmt . Errorf ( "%s not found" , PachRootEnvVar ) } storageBackend , ok := os . LookupEnv ( StorageBackendEnvVar ) if ! ok { return "" , fmt . Errorf ( "%s not found" , StorageBackendEnvVar ) } switch storageBackend { case Amazon : fallthrough case Minio : if len ( storageRoot ) > 0 && storageRoot [ 0 ] == '/' { storageRoot = storageRoot [ 1 : ] } } return storageRoot , nil }
2979	func BlockPathFromEnv ( block * pfs . Block ) ( string , error ) { storageRoot , err := StorageRootFromEnv ( ) if err != nil { return "" , err } return filepath . Join ( storageRoot , "block" , block . Hash ) , nil }
2980	func NewGoogleClient ( bucket string , opts [ ] option . ClientOption ) ( Client , error ) { return newGoogleClient ( bucket , opts ) }
2981	func NewGoogleClientFromSecret ( bucket string ) ( Client , error ) { var err error if bucket == "" { bucket , err = readSecretFile ( "/google-bucket" ) if err != nil { return nil , fmt . Errorf ( "google-bucket not found" ) } } cred , err := readSecretFile ( "/google-cred" ) if err != nil { return nil , fmt . Errorf ( "google-cred not found" ) } var opts [ ] option . ClientOption if cred != "" { opts = append ( opts , option . WithCredentialsFile ( secretFile ( "/google-cred" ) ) ) } else { opts = append ( opts , option . WithTokenSource ( google . ComputeTokenSource ( "" ) ) ) } return NewGoogleClient ( bucket , opts ) }
2982	func NewGoogleClientFromEnv ( ) ( Client , error ) { bucket , ok := os . LookupEnv ( GoogleBucketEnvVar ) if ! ok { return nil , fmt . Errorf ( "%s not found" , GoogleBucketEnvVar ) } creds , ok := os . LookupEnv ( GoogleCredEnvVar ) if ! ok { return nil , fmt . Errorf ( "%s not found" , GoogleCredEnvVar ) } opts := [ ] option . ClientOption { option . WithCredentialsJSON ( [ ] byte ( creds ) ) } return NewGoogleClient ( bucket , opts ) }
2983	func NewMicrosoftClientFromSecret ( container string ) ( Client , error ) { var err error if container == "" { container , err = readSecretFile ( "/microsoft-container" ) if err != nil { return nil , fmt . Errorf ( "microsoft-container not found" ) } } id , err := readSecretFile ( "/microsoft-id" ) if err != nil { return nil , fmt . Errorf ( "microsoft-id not found" ) } secret , err := readSecretFile ( "/microsoft-secret" ) if err != nil { return nil , fmt . Errorf ( "microsoft-secret not found" ) } return NewMicrosoftClient ( container , id , secret ) }
2984	func NewMicrosoftClientFromEnv ( ) ( Client , error ) { container , ok := os . LookupEnv ( MicrosoftContainerEnvVar ) if ! ok { return nil , fmt . Errorf ( "%s not found" , MicrosoftContainerEnvVar ) } id , ok := os . LookupEnv ( MicrosoftIDEnvVar ) if ! ok { return nil , fmt . Errorf ( "%s not found" , MicrosoftIDEnvVar ) } secret , ok := os . LookupEnv ( MicrosoftSecretEnvVar ) if ! ok { return nil , fmt . Errorf ( "%s not found" , MicrosoftSecretEnvVar ) } return NewMicrosoftClient ( container , id , secret ) }
2985	func NewMinioClientFromSecret ( bucket string ) ( Client , error ) { var err error if bucket == "" { bucket , err = readSecretFile ( "/minio-bucket" ) if err != nil { return nil , err } } endpoint , err := readSecretFile ( "/minio-endpoint" ) if err != nil { return nil , err } id , err := readSecretFile ( "/minio-id" ) if err != nil { return nil , err } secret , err := readSecretFile ( "/minio-secret" ) if err != nil { return nil , err } secure , err := readSecretFile ( "/minio-secure" ) if err != nil { return nil , err } isS3V2 , err := readSecretFile ( "/minio-signature" ) if err != nil { return nil , err } return NewMinioClient ( endpoint , bucket , id , secret , secure == "1" , isS3V2 == "1" ) }
2986	func NewMinioClientFromEnv ( ) ( Client , error ) { bucket , ok := os . LookupEnv ( MinioBucketEnvVar ) if ! ok { return nil , fmt . Errorf ( "%s not found" , MinioBucketEnvVar ) } endpoint , ok := os . LookupEnv ( MinioEndpointEnvVar ) if ! ok { return nil , fmt . Errorf ( "%s not found" , MinioEndpointEnvVar ) } id , ok := os . LookupEnv ( MinioIDEnvVar ) if ! ok { return nil , fmt . Errorf ( "%s not found" , MinioIDEnvVar ) } secret , ok := os . LookupEnv ( MinioSecretEnvVar ) if ! ok { return nil , fmt . Errorf ( "%s not found" , MinioSecretEnvVar ) } secure , ok := os . LookupEnv ( MinioSecureEnvVar ) if ! ok { return nil , fmt . Errorf ( "%s not found" , MinioSecureEnvVar ) } isS3V2 , ok := os . LookupEnv ( MinioSignatureEnvVar ) if ! ok { return nil , fmt . Errorf ( "%s not found" , MinioSignatureEnvVar ) } return NewMinioClient ( endpoint , bucket , id , secret , secure == "1" , isS3V2 == "1" ) }
2987	func NewAmazonClientFromSecret ( bucket string , reversed ... bool ) ( Client , error ) { region , err := readSecretFile ( "/amazon-region" ) if err != nil { return nil , fmt . Errorf ( "amazon-region not found" ) } if bucket == "" { bucket , err = readSecretFile ( "/amazon-bucket" ) if err != nil { return nil , err } } var creds AmazonCreds creds . ID , err = readSecretFile ( "/amazon-id" ) if err != nil && ! os . IsNotExist ( err ) { return nil , err } creds . Secret , err = readSecretFile ( "/amazon-secret" ) if err != nil && ! os . IsNotExist ( err ) { return nil , err } creds . Token , err = readSecretFile ( "/amazon-token" ) if err != nil && ! os . IsNotExist ( err ) { return nil , err } creds . VaultAddress , err = readSecretFile ( "/amazon-vault-addr" ) if err != nil && ! os . IsNotExist ( err ) { return nil , err } creds . VaultRole , err = readSecretFile ( "/amazon-vault-role" ) if err != nil && ! os . IsNotExist ( err ) { return nil , err } creds . VaultToken , err = readSecretFile ( "/amazon-vault-token" ) if err != nil && ! os . IsNotExist ( err ) { return nil , err } distribution , err := readSecretFile ( "/amazon-distribution" ) return NewAmazonClient ( region , bucket , & creds , distribution , reversed ... ) }
2988	func NewAmazonClientFromEnv ( ) ( Client , error ) { region , ok := os . LookupEnv ( AmazonRegionEnvVar ) if ! ok { return nil , fmt . Errorf ( "%s not found" , AmazonRegionEnvVar ) } bucket , ok := os . LookupEnv ( AmazonBucketEnvVar ) if ! ok { return nil , fmt . Errorf ( "%s not found" , AmazonBucketEnvVar ) } var creds AmazonCreds creds . ID , _ = os . LookupEnv ( AmazonIDEnvVar ) creds . Secret , _ = os . LookupEnv ( AmazonSecretEnvVar ) creds . Token , _ = os . LookupEnv ( AmazonTokenEnvVar ) creds . VaultAddress , _ = os . LookupEnv ( AmazonVaultAddrEnvVar ) creds . VaultRole , _ = os . LookupEnv ( AmazonVaultRoleEnvVar ) creds . VaultToken , _ = os . LookupEnv ( AmazonVaultTokenEnvVar ) distribution , _ := os . LookupEnv ( AmazonDistributionEnvVar ) return NewAmazonClient ( region , bucket , & creds , distribution ) }
2989	func NewClientFromURLAndSecret ( url * ObjectStoreURL , reversed ... bool ) ( c Client , err error ) { switch url . Store { case "s3" : c , err = NewAmazonClientFromSecret ( url . Bucket , reversed ... ) case "gcs" : fallthrough case "gs" : c , err = NewGoogleClientFromSecret ( url . Bucket ) case "as" : fallthrough case "wasb" : c , err = NewMicrosoftClientFromSecret ( url . Bucket ) case "local" : c , err = NewLocalClient ( "/" + url . Bucket ) } switch { case err != nil : return nil , err case c != nil : return TracingObjClient ( url . Store , c ) , nil default : return nil , fmt . Errorf ( "unrecognized object store: %s" , url . Bucket ) } }
2990	func ParseURL ( urlStr string ) ( * ObjectStoreURL , error ) { url , err := url . Parse ( urlStr ) if err != nil { return nil , fmt . Errorf ( "error parsing url %v: %v" , urlStr , err ) } switch url . Scheme { case "s3" , "gcs" , "gs" , "local" : return & ObjectStoreURL { Store : url . Scheme , Bucket : url . Host , Object : strings . Trim ( url . Path , "/" ) , } , nil case "as" , "wasb" : parts := strings . Split ( strings . Trim ( url . Path , "/" ) , "/" ) if len ( parts ) < 1 { return nil , fmt . Errorf ( "malformed Azure URI: %v" , urlStr ) } return & ObjectStoreURL { Store : url . Scheme , Bucket : parts [ 0 ] , Object : strings . Trim ( path . Join ( parts [ 1 : ] ... ) , "/" ) , } , nil } return nil , fmt . Errorf ( "unrecognized object store: %s" , url . Scheme ) }
2991	func NewClientFromEnv ( storageRoot string ) ( c Client , err error ) { storageBackend , ok := os . LookupEnv ( StorageBackendEnvVar ) if ! ok { return nil , fmt . Errorf ( "storage backend environment variable not found" ) } switch storageBackend { case Amazon : c , err = NewAmazonClientFromEnv ( ) case Google : c , err = NewGoogleClientFromEnv ( ) case Microsoft : c , err = NewMicrosoftClientFromEnv ( ) case Minio : c , err = NewMinioClientFromEnv ( ) case Local : c , err = NewLocalClient ( storageRoot ) } switch { case err != nil : return nil , err case c != nil : return TracingObjClient ( storageBackend , c ) , nil default : return nil , fmt . Errorf ( "unrecognized storage backend: %s" , storageBackend ) } }
2992	func NewExponentialBackOffConfig ( ) * backoff . ExponentialBackOff { config := backoff . NewExponentialBackOff ( ) config . InitialInterval = 1 * time . Second config . Multiplier = 2 config . MaxInterval = 15 * time . Minute return config }
2993	func ( b * BackoffReadCloser ) Close ( ) error { span , _ := tracing . AddSpanToAnyExisting ( b . ctx , "obj/BackoffReadCloser.Close" ) defer tracing . FinishAnySpan ( span ) return b . reader . Close ( ) }
2994	func ( b * BackoffWriteCloser ) Close ( ) error { span , _ := tracing . AddSpanToAnyExisting ( b . ctx , "obj/BackoffWriteCloser.Close" ) defer tracing . FinishAnySpan ( span ) err := b . writer . Close ( ) if b . client . IsIgnorable ( err ) { return nil } return err }
2995	func IsRetryable ( client Client , err error ) bool { return isNetRetryable ( err ) || client . IsRetryable ( err ) }
2996	func RunStdin ( stdin io . Reader , args ... string ) error { return RunIO ( IO { Stdin : stdin } , args ... ) }
2997	func RunIODirPath ( ioObj IO , dirPath string , args ... string ) error { var debugStderr io . ReadWriter = bytes . NewBuffer ( nil ) var stderr io . Writer = debugStderr if ioObj . Stderr != nil { stderr = io . MultiWriter ( debugStderr , ioObj . Stderr ) } cmd := exec . Command ( args [ 0 ] , args [ 1 : ] ... ) cmd . Stdin = ioObj . Stdin cmd . Stdout = ioObj . Stdout cmd . Stderr = stderr cmd . Dir = dirPath if err := cmd . Run ( ) ; err != nil { data , _ := ioutil . ReadAll ( debugStderr ) if data != nil && len ( data ) > 0 { return fmt . Errorf ( "%s: %s\n%s" , \n , strings . Join ( args , " " ) , err . Error ( ) ) } string ( data ) } return fmt . Errorf ( "%s: %s" , strings . Join ( args , " " ) , err . Error ( ) ) }
2998	func NewAuthServer ( env * serviceenv . ServiceEnv , etcdPrefix string , public bool ) ( authclient . APIServer , error ) { s := & apiServer { env : env , pachLogger : log . NewLogger ( "authclient.API" ) , adminCache : make ( map [ string ] struct { } ) , tokens : col . NewCollection ( env . GetEtcdClient ( ) , path . Join ( etcdPrefix , tokensPrefix ) , nil , & authclient . TokenInfo { } , nil , nil , ) , authenticationCodes : col . NewCollection ( env . GetEtcdClient ( ) , path . Join ( etcdPrefix , authenticationCodesPrefix ) , nil , & authclient . OTPInfo { } , nil , nil , ) , acls : col . NewCollection ( env . GetEtcdClient ( ) , path . Join ( etcdPrefix , aclsPrefix ) , nil , & authclient . ACL { } , nil , nil , ) , admins : col . NewCollection ( env . GetEtcdClient ( ) , path . Join ( etcdPrefix , adminsPrefix ) , nil , & types . BoolValue { } , nil , nil , ) , members : col . NewCollection ( env . GetEtcdClient ( ) , path . Join ( etcdPrefix , membersPrefix ) , nil , & authclient . Groups { } , nil , nil , ) , groups : col . NewCollection ( env . GetEtcdClient ( ) , path . Join ( etcdPrefix , groupsPrefix ) , nil , & authclient . Users { } , nil , nil , ) , authConfig : col . NewCollection ( env . GetEtcdClient ( ) , path . Join ( etcdPrefix , configKey ) , nil , & authclient . AuthConfig { } , nil , nil , ) , public : public , } go s . retrieveOrGeneratePPSToken ( ) go s . watchAdmins ( path . Join ( etcdPrefix , adminsPrefix ) ) if public { go s . serveSAML ( ) } go s . watchConfig ( ) return s , nil }
2999	func ( a * apiServer ) expiredClusterAdminCheck ( ctx context . Context , username string ) error { state , err := a . getEnterpriseTokenState ( ) if err != nil { return fmt . Errorf ( "error confirming Pachyderm Enterprise token: %v" , err ) } isAdmin , err := a . isAdmin ( ctx , username ) if err != nil { return err } if state != enterpriseclient . State_ACTIVE && ! isAdmin { return errors . New ( "Pachyderm Enterprise is not active in this " + "cluster (until Pachyderm Enterprise is re-activated or Pachyderm " + "auth is deactivated, only cluster admins can perform any operations)" ) } return nil }
3000	func ( a * apiServer ) getOneTimePassword ( ctx context . Context , username string , expiration time . Time ) ( code string , err error ) { otpInfo := & authclient . OTPInfo { Subject : username , } if ! expiration . IsZero ( ) { expirationProto , err := types . TimestampProto ( expiration ) if err != nil { return "" , fmt . Errorf ( "could not create OTP with expiration time %s: %v" , expiration . String ( ) , err ) } otpInfo . SessionExpiration = expirationProto } code = "auth_code:" + uuid . NewWithoutDashes ( ) if _ , err = col . NewSTM ( ctx , a . env . GetEtcdClient ( ) , func ( stm col . STM ) error { return a . authenticationCodes . ReadWrite ( stm ) . PutTTL ( hashToken ( code ) , otpInfo , defaultAuthCodeTTLSecs ) } ) ; err != nil { return "" , err } return code , nil }
3001	func hashToken ( token string ) string { sum := sha256 . Sum256 ( [ ] byte ( token ) ) return fmt . Sprintf ( "%x" , sum ) }
3002	func getAuthToken ( ctx context . Context ) ( string , error ) { md , ok := metadata . FromIncomingContext ( ctx ) if ! ok { return "" , authclient . ErrNoMetadata } if len ( md [ authclient . ContextTokenKey ] ) > 1 { return "" , fmt . Errorf ( "multiple authentication token keys found in context" ) } else if len ( md [ authclient . ContextTokenKey ] ) == 0 { return "" , authclient . ErrNotSignedIn } return md [ authclient . ContextTokenKey ] [ 0 ] , nil }
3003	func ( a * apiServer ) canonicalizeSubjects ( ctx context . Context , subjects [ ] string ) ( [ ] string , error ) { if subjects == nil { return [ ] string { } , nil } eg := & errgroup . Group { } canonicalizedSubjects := make ( [ ] string , len ( subjects ) ) for i , subject := range subjects { i , subject := i , subject eg . Go ( func ( ) error { subject , err := a . canonicalizeSubject ( ctx , subject ) if err != nil { return err } canonicalizedSubjects [ i ] = subject return nil } ) } if err := eg . Wait ( ) ; err != nil { return nil , err } return canonicalizedSubjects , nil }
3004	func Matches ( tb testing . TB , expectedMatch string , actual string , msgAndArgs ... interface { } ) { tb . Helper ( ) r , err := regexp . Compile ( expectedMatch ) if err != nil { fatal ( tb , msgAndArgs , "Match string provided (%v) is invalid" , expectedMatch ) } if ! r . MatchString ( actual ) { fatal ( tb , msgAndArgs , "Actual string (%v) does not match pattern (%v)" , actual , expectedMatch ) } }
3005	func OneOfMatches ( tb testing . TB , expectedMatch string , actuals [ ] string , msgAndArgs ... interface { } ) { tb . Helper ( ) r , err := regexp . Compile ( expectedMatch ) if err != nil { fatal ( tb , msgAndArgs , "Match string provided (%v) is invalid" , expectedMatch ) } for _ , actual := range actuals { if r . MatchString ( actual ) { return } } fatal ( tb , msgAndArgs , "None of actual strings (%v) match pattern (%v)" , actuals , expectedMatch ) }
3006	func Equal ( tb testing . TB , expected interface { } , actual interface { } , msgAndArgs ... interface { } ) { tb . Helper ( ) eV , aV := reflect . ValueOf ( expected ) , reflect . ValueOf ( actual ) if eV . Type ( ) != aV . Type ( ) { fatal ( tb , msgAndArgs , "Not equal: %T(%#v) (expected)\n" + \n , " != %T(%#v) (actual)" , expected , expected , actual ) } actual }
3007	func NotEqual ( tb testing . TB , expected interface { } , actual interface { } , msgAndArgs ... interface { } ) { tb . Helper ( ) if reflect . DeepEqual ( expected , actual ) { fatal ( tb , msgAndArgs , "Equal: %#v (expected)\n" + \n , " == %#v (actual)" , expected ) } }
3008	func oneOfEquals ( sliceName string , slice interface { } , elem interface { } ) ( bool , error ) { e := reflect . ValueOf ( elem ) sl := reflect . ValueOf ( slice ) if slice == nil || sl . IsNil ( ) { sl = reflect . MakeSlice ( reflect . SliceOf ( e . Type ( ) ) , 0 , 0 ) } if sl . Kind ( ) != reflect . Slice { return false , fmt . Errorf ( "\"%s\" must a be a slice, but instead was %s" , \" , \" ) } sliceName sl . Type ( ) . String ( ) if e . Type ( ) != sl . Type ( ) . Elem ( ) { return false , nil } arePtrs := e . Kind ( ) == reflect . Ptr }
3009	func NoneEquals ( tb testing . TB , expected interface { } , actuals interface { } , msgAndArgs ... interface { } ) { tb . Helper ( ) equal , err := oneOfEquals ( "actuals" , actuals , expected ) if err != nil { fatal ( tb , msgAndArgs , err . Error ( ) ) } if equal { fatal ( tb , msgAndArgs , "Equal : %#v (expected)\n == one of %#v (actuals)" , \n , expected ) } }
3010	func NoError ( tb testing . TB , err error , msgAndArgs ... interface { } ) { tb . Helper ( ) if err != nil { fatal ( tb , msgAndArgs , "No error is expected but got %s" , err . Error ( ) ) } }
3011	func NoErrorWithinT ( tb testing . TB , t time . Duration , f func ( ) error , msgAndArgs ... interface { } ) { tb . Helper ( ) errCh := make ( chan error ) go func ( ) { errCh <- f ( ) } ( ) select { case err := <- errCh : if err != nil { fatal ( tb , msgAndArgs , "No error is expected but got %s" , err . Error ( ) ) } case <- time . After ( t ) : fatal ( tb , msgAndArgs , "operation did not finish within %s" , t . String ( ) ) } }
3012	func NoErrorWithinTRetry ( tb testing . TB , t time . Duration , f func ( ) error , msgAndArgs ... interface { } ) { tb . Helper ( ) doneCh := make ( chan struct { } ) timeout := false var err error go func ( ) { for ! timeout { if err = f ( ) ; err == nil { close ( doneCh ) break } } } ( ) select { case <- doneCh : case <- time . After ( t ) : timeout = true fatal ( tb , msgAndArgs , "operation did not finish within %s - last error: %v" , t . String ( ) , err ) } }
3013	func YesError ( tb testing . TB , err error , msgAndArgs ... interface { } ) { tb . Helper ( ) if err == nil { fatal ( tb , msgAndArgs , "Error is expected but got %v" , err ) } }
3014	func NotNil ( tb testing . TB , object interface { } , msgAndArgs ... interface { } ) { tb . Helper ( ) success := true if object == nil { success = false } else { value := reflect . ValueOf ( object ) kind := value . Kind ( ) if kind >= reflect . Chan && kind <= reflect . Slice && value . IsNil ( ) { success = false } } if ! success { fatal ( tb , msgAndArgs , "Expected value not to be nil." ) } }
3015	func Nil ( tb testing . TB , object interface { } , msgAndArgs ... interface { } ) { tb . Helper ( ) if object == nil { return } value := reflect . ValueOf ( object ) kind := value . Kind ( ) if kind >= reflect . Chan && kind <= reflect . Slice && value . IsNil ( ) { return } fatal ( tb , msgAndArgs , "Expected value to be nil, but was %v" , object ) }
3016	func False ( tb testing . TB , value bool , msgAndArgs ... interface { } ) { tb . Helper ( ) if value { fatal ( tb , msgAndArgs , "Should be false." ) } }
3017	func NewSTM ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return newSTMSerializable ( ctx , c , apply , false ) }
3018	func NewDryrunSTM ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) error { _ , err := newSTMSerializable ( ctx , c , apply , true ) return err }
3019	func newSTMRepeatable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { s := & stm { client : c , ctx : ctx , getOpts : [ ] v3 . OpOption { v3 . WithSerializable ( ) } } return runSTM ( s , apply , false ) }
3020	func newSTMSerializable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error , dryrun bool ) ( * v3 . TxnResponse , error ) { s := & stmSerializable { stm : stm { client : c , ctx : ctx } , prefetch : make ( map [ string ] * v3 . GetResponse ) , } return runSTM ( s , apply , dryrun ) }
3021	func newSTMReadCommitted ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { s := & stmReadCommitted { stm { client : c , ctx : ctx , getOpts : [ ] v3 . OpOption { v3 . WithSerializable ( ) } } } return runSTM ( s , apply , true ) }
3022	func ( s * stmReadCommitted ) commit ( ) * v3 . TxnResponse { s . rset = nil return s . stm . commit ( ) }
3023	func Pipelines ( etcdClient * etcd . Client , etcdPrefix string ) col . Collection { return col . NewCollection ( etcdClient , path . Join ( etcdPrefix , pipelinesPrefix ) , nil , & pps . EtcdPipelineInfo { } , nil , nil , ) }
3024	func Jobs ( etcdClient * etcd . Client , etcdPrefix string ) col . Collection { return col . NewCollection ( etcdClient , path . Join ( etcdPrefix , jobsPrefix ) , [ ] * col . Index { JobsPipelineIndex , JobsOutputIndex } , & pps . EtcdJobInfo { } , nil , nil , ) }
3025	func NewTicker ( b BackOff ) * Ticker { c := make ( chan time . Time ) t := & Ticker { C : c , c : c , b : b , stop : make ( chan struct { } ) , } go t . run ( ) runtime . SetFinalizer ( t , ( * Ticker ) . Stop ) return t }
3026	func nodeToMap ( node * etcd . Node , out map [ string ] string ) bool { key := strings . TrimPrefix ( node . Key , "/" ) if ! node . Dir { if node . Value == "" { if _ , ok := out [ key ] ; ok { delete ( out , key ) return true } return false } if value , ok := out [ key ] ; ! ok || value != node . Value { out [ key ] = node . Value return true } return false } changed := false for _ , node := range node . Nodes { changed = nodeToMap ( node , out ) || changed } return changed }
3027	func ServiceAccount ( opts * AssetOpts ) * v1 . ServiceAccount { return & v1 . ServiceAccount { TypeMeta : metav1 . TypeMeta { Kind : "ServiceAccount" , APIVersion : "v1" , } , ObjectMeta : objectMeta ( ServiceAccountName , labels ( "" ) , nil , opts . Namespace ) , } }
3028	func ClusterRole ( opts * AssetOpts ) * rbacv1 . ClusterRole { return & rbacv1 . ClusterRole { TypeMeta : metav1 . TypeMeta { Kind : "ClusterRole" , APIVersion : "rbac.authorization.k8s.io/v1" , } , ObjectMeta : objectMeta ( roleName , labels ( "" ) , nil , opts . Namespace ) , Rules : rolePolicyRules , } }
3029	func RoleBinding ( opts * AssetOpts ) * rbacv1 . RoleBinding { return & rbacv1 . RoleBinding { TypeMeta : metav1 . TypeMeta { Kind : "RoleBinding" , APIVersion : "rbac.authorization.k8s.io/v1" , } , ObjectMeta : objectMeta ( roleBindingName , labels ( "" ) , nil , opts . Namespace ) , Subjects : [ ] rbacv1 . Subject { { Kind : "ServiceAccount" , Name : ServiceAccountName , Namespace : opts . Namespace , } } , RoleRef : rbacv1 . RoleRef { Kind : "Role" , Name : roleName , } , } }
3030	func GetSecretEnvVars ( storageBackend string ) [ ] v1 . EnvVar { var envVars [ ] v1 . EnvVar if storageBackend != "" { envVars = append ( envVars , v1 . EnvVar { Name : obj . StorageBackendEnvVar , Value : storageBackend , } ) } trueVal := true for envVar , secretKey := range obj . EnvVarToSecretKey { envVars = append ( envVars , v1 . EnvVar { Name : envVar , ValueFrom : & v1 . EnvVarSource { SecretKeyRef : & v1 . SecretKeySelector { LocalObjectReference : v1 . LocalObjectReference { Name : client . StorageSecretName , } , Key : secretKey , Optional : & trueVal , } , } , } ) } return envVars }
3031	func PachdService ( opts * AssetOpts ) * v1 . Service { prometheusAnnotations := map [ string ] string { "prometheus.io/scrape" : "true" , "prometheus.io/port" : strconv . Itoa ( PrometheusPort ) , } return & v1 . Service { TypeMeta : metav1 . TypeMeta { Kind : "Service" , APIVersion : "v1" , } , ObjectMeta : objectMeta ( pachdName , labels ( pachdName ) , prometheusAnnotations , opts . Namespace ) , Spec : v1 . ServiceSpec { Type : v1 . ServiceTypeNodePort , Selector : map [ string ] string { "app" : pachdName , } , Ports : [ ] v1 . ServicePort { { Port : 600 , Name : "s3gateway-port" , NodePort : 30600 , } , { Port : 650 , Name : "api-grpc-port" , NodePort : 30650 , } , { Port : 651 , Name : "trace-port" , NodePort : 30651 , } , { Port : 652 , Name : "api-http-port" , NodePort : 30652 , } , { Port : auth . SamlPort , Name : "saml-port" , NodePort : 30000 + auth . SamlPort , } , { Port : githook . GitHookPort , Name : "api-git-port" , NodePort : githook . NodePort ( ) , } , } , } , } }
3032	func GithookService ( namespace string ) * v1 . Service { name := "githook" return & v1 . Service { TypeMeta : metav1 . TypeMeta { Kind : "Service" , APIVersion : "v1" , } , ObjectMeta : objectMeta ( name , labels ( name ) , nil , namespace ) , Spec : v1 . ServiceSpec { Type : v1 . ServiceTypeLoadBalancer , Selector : map [ string ] string { "app" : pachdName , } , Ports : [ ] v1 . ServicePort { { TargetPort : intstr . FromInt ( githook . GitHookPort ) , Name : "api-git-port" , Port : githook . ExternalPort ( ) , } , } , } , } }
3033	func EtcdDeployment ( opts * AssetOpts , hostPath string ) * apps . Deployment { cpu := resource . MustParse ( opts . EtcdCPURequest ) mem := resource . MustParse ( opts . EtcdMemRequest ) var volumes [ ] v1 . Volume if hostPath == "" { volumes = [ ] v1 . Volume { { Name : "etcd-storage" , VolumeSource : v1 . VolumeSource { PersistentVolumeClaim : & v1 . PersistentVolumeClaimVolumeSource { ClaimName : etcdVolumeClaimName , } , } , } , } } else { volumes = [ ] v1 . Volume { { Name : "etcd-storage" , VolumeSource : v1 . VolumeSource { HostPath : & v1 . HostPathVolumeSource { Path : filepath . Join ( hostPath , "etcd" ) , } , } , } , } } resourceRequirements := v1 . ResourceRequirements { Requests : v1 . ResourceList { v1 . ResourceCPU : cpu , v1 . ResourceMemory : mem , } , } if ! opts . NoGuaranteed { resourceRequirements . Limits = v1 . ResourceList { v1 . ResourceCPU : cpu , v1 . ResourceMemory : mem , } } image := etcdImage if opts . Registry != "" { image = AddRegistry ( opts . Registry , etcdImage ) } return & apps . Deployment { TypeMeta : metav1 . TypeMeta { Kind : "Deployment" , APIVersion : "apps/v1beta1" , } , ObjectMeta : objectMeta ( etcdName , labels ( etcdName ) , nil , opts . Namespace ) , Spec : apps . DeploymentSpec { Replicas : replicas ( 1 ) , Selector : & metav1 . LabelSelector { MatchLabels : labels ( etcdName ) , } , Template : v1 . PodTemplateSpec { ObjectMeta : objectMeta ( etcdName , labels ( etcdName ) , nil , opts . Namespace ) , Spec : v1 . PodSpec { Containers : [ ] v1 . Container { { Name : etcdName , Image : image , Command : etcdCmd , Ports : [ ] v1 . ContainerPort { { ContainerPort : 2379 , Name : "client-port" , } , { ContainerPort : 2380 , Name : "peer-port" , } , } , VolumeMounts : [ ] v1 . VolumeMount { { Name : "etcd-storage" , MountPath : "/var/data/etcd" , } , } , ImagePullPolicy : "IfNotPresent" , Resources : resourceRequirements , } , } , Volumes : volumes , ImagePullSecrets : imagePullSecrets ( opts ) , } , } , } , } }
3034	func EtcdStorageClass ( opts * AssetOpts , backend backend ) ( interface { } , error ) { sc := map [ string ] interface { } { "apiVersion" : "storage.k8s.io/v1beta1" , "kind" : "StorageClass" , "metadata" : map [ string ] interface { } { "name" : defaultEtcdStorageClassName , "labels" : labels ( etcdName ) , "namespace" : opts . Namespace , } , } switch backend { case googleBackend : sc [ "provisioner" ] = "kubernetes.io/gce-pd" sc [ "parameters" ] = map [ string ] string { "type" : "pd-ssd" , } case amazonBackend : sc [ "provisioner" ] = "kubernetes.io/aws-ebs" sc [ "parameters" ] = map [ string ] string { "type" : "gp2" , } default : return nil , nil } return sc , nil }
3035	func EtcdVolume ( persistentDiskBackend backend , opts * AssetOpts , hostPath string , name string , size int ) ( * v1 . PersistentVolume , error ) { spec := & v1 . PersistentVolume { TypeMeta : metav1 . TypeMeta { Kind : "PersistentVolume" , APIVersion : "v1" , } , ObjectMeta : objectMeta ( etcdVolumeName , labels ( etcdName ) , nil , opts . Namespace ) , Spec : v1 . PersistentVolumeSpec { Capacity : map [ v1 . ResourceName ] resource . Quantity { "storage" : resource . MustParse ( fmt . Sprintf ( "%vGi" , size ) ) , } , AccessModes : [ ] v1 . PersistentVolumeAccessMode { v1 . ReadWriteOnce } , PersistentVolumeReclaimPolicy : v1 . PersistentVolumeReclaimRetain , } , } switch persistentDiskBackend { case amazonBackend : spec . Spec . PersistentVolumeSource = v1 . PersistentVolumeSource { AWSElasticBlockStore : & v1 . AWSElasticBlockStoreVolumeSource { FSType : "ext4" , VolumeID : name , } , } case googleBackend : spec . Spec . PersistentVolumeSource = v1 . PersistentVolumeSource { GCEPersistentDisk : & v1 . GCEPersistentDiskVolumeSource { FSType : "ext4" , PDName : name , } , } case microsoftBackend : dataDiskURI := name split := strings . Split ( name , "/" ) diskName := split [ len ( split ) - 1 ] spec . Spec . PersistentVolumeSource = v1 . PersistentVolumeSource { AzureDisk : & v1 . AzureDiskVolumeSource { DiskName : diskName , DataDiskURI : dataDiskURI , } , } case minioBackend : fallthrough case localBackend : spec . Spec . PersistentVolumeSource = v1 . PersistentVolumeSource { HostPath : & v1 . HostPathVolumeSource { Path : filepath . Join ( hostPath , "etcd" ) , } , } default : return nil , fmt . Errorf ( "cannot generate volume spec for unknown backend \"%v\"" , \" ) } \" }
3036	func EtcdNodePortService ( local bool , opts * AssetOpts ) * v1 . Service { var clientNodePort int32 if local { clientNodePort = 32379 } return & v1 . Service { TypeMeta : metav1 . TypeMeta { Kind : "Service" , APIVersion : "v1" , } , ObjectMeta : objectMeta ( etcdName , labels ( etcdName ) , nil , opts . Namespace ) , Spec : v1 . ServiceSpec { Type : v1 . ServiceTypeNodePort , Selector : map [ string ] string { "app" : etcdName , } , Ports : [ ] v1 . ServicePort { { Port : 2379 , Name : "client-port" , NodePort : clientNodePort , } , } , } , } }
3037	func EtcdHeadlessService ( opts * AssetOpts ) * v1 . Service { return & v1 . Service { TypeMeta : metav1 . TypeMeta { Kind : "Service" , APIVersion : "v1" , } , ObjectMeta : objectMeta ( etcdHeadlessServiceName , labels ( etcdName ) , nil , opts . Namespace ) , Spec : v1 . ServiceSpec { Selector : map [ string ] string { "app" : etcdName , } , ClusterIP : "None" , Ports : [ ] v1 . ServicePort { { Name : "peer-port" , Port : 2380 , } , } , } , } }
3038	func EtcdStatefulSet ( opts * AssetOpts , backend backend , diskSpace int ) interface { } { mem := resource . MustParse ( opts . EtcdMemRequest ) cpu := resource . MustParse ( opts . EtcdCPURequest ) initialCluster := make ( [ ] string , 0 , opts . EtcdNodes ) for i := 0 ; i < opts . EtcdNodes ; i ++ { url := fmt . Sprintf ( "http://etcd-%d.etcd-headless.${NAMESPACE}.svc.cluster.local:2380" , i ) initialCluster = append ( initialCluster , fmt . Sprintf ( "etcd-%d=%s" , i , url ) ) } etcdCmd := append ( etcdCmd , "--listen-peer-urls=http://0.0.0.0:2380" , "--initial-cluster-token=pach-cluster" , "--initial-advertise-peer-urls=http://${ETCD_NAME}.etcd-headless.${NAMESPACE}.svc.cluster.local:2380" , "--initial-cluster=" + strings . Join ( initialCluster , "," ) , ) for i , str := range etcdCmd { etcdCmd [ i ] = fmt . Sprintf ( "\"%s\"" , \" ) } \" str var pvcTemplates [ ] interface { } switch backend { case googleBackend , amazonBackend : storageClassName := opts . EtcdStorageClassName if storageClassName == "" { storageClassName = defaultEtcdStorageClassName } pvcTemplates = [ ] interface { } { map [ string ] interface { } { "metadata" : map [ string ] interface { } { "name" : etcdVolumeClaimName , "labels" : labels ( etcdName ) , "annotations" : map [ string ] string { "volume.beta.kubernetes.io/storage-class" : storageClassName , } , "namespace" : opts . Namespace , } , "spec" : map [ string ] interface { } { "resources" : map [ string ] interface { } { "requests" : map [ string ] interface { } { "storage" : resource . MustParse ( fmt . Sprintf ( "%vGi" , diskSpace ) ) , } , } , "accessModes" : [ ] string { "ReadWriteOnce" } , } , } , } default : pvcTemplates = [ ] interface { } { map [ string ] interface { } { "metadata" : map [ string ] interface { } { "name" : etcdVolumeClaimName , "labels" : labels ( etcdName ) , "namespace" : opts . Namespace , } , "spec" : map [ string ] interface { } { "resources" : map [ string ] interface { } { "requests" : map [ string ] interface { } { "storage" : resource . MustParse ( fmt . Sprintf ( "%vGi" , diskSpace ) ) , } , } , "accessModes" : [ ] string { "ReadWriteOnce" } , } , } , } } var imagePullSecrets [ ] map [ string ] string if opts . ImagePullSecret != "" { imagePullSecrets = append ( imagePullSecrets , map [ string ] string { "name" : opts . ImagePullSecret } ) } image := etcdImage }
3039	func DashDeployment ( opts * AssetOpts ) * apps . Deployment { return & apps . Deployment { TypeMeta : metav1 . TypeMeta { Kind : "Deployment" , APIVersion : "apps/v1beta1" , } , ObjectMeta : objectMeta ( dashName , labels ( dashName ) , nil , opts . Namespace ) , Spec : apps . DeploymentSpec { Selector : & metav1 . LabelSelector { MatchLabels : labels ( dashName ) , } , Template : v1 . PodTemplateSpec { ObjectMeta : objectMeta ( dashName , labels ( dashName ) , nil , opts . Namespace ) , Spec : v1 . PodSpec { Containers : [ ] v1 . Container { { Name : dashName , Image : AddRegistry ( opts . Registry , opts . DashImage ) , Ports : [ ] v1 . ContainerPort { { ContainerPort : 8080 , Name : "dash-http" , } , } , ImagePullPolicy : "IfNotPresent" , } , { Name : grpcProxyName , Image : AddRegistry ( opts . Registry , grpcProxyImage ) , Ports : [ ] v1 . ContainerPort { { ContainerPort : 8081 , Name : "grpc-proxy-http" , } , } , ImagePullPolicy : "IfNotPresent" , } , } , ImagePullSecrets : imagePullSecrets ( opts ) , } , } , } , } }
3040	func DashService ( opts * AssetOpts ) * v1 . Service { return & v1 . Service { TypeMeta : metav1 . TypeMeta { Kind : "Service" , APIVersion : "v1" , } , ObjectMeta : objectMeta ( dashName , labels ( dashName ) , nil , opts . Namespace ) , Spec : v1 . ServiceSpec { Type : v1 . ServiceTypeNodePort , Selector : labels ( dashName ) , Ports : [ ] v1 . ServicePort { { Port : 8080 , Name : "dash-http" , NodePort : 30080 , } , { Port : 8081 , Name : "grpc-proxy-http" , NodePort : 30081 , } , } , } , } }
3041	func WriteSecret ( encoder Encoder , data map [ string ] [ ] byte , opts * AssetOpts ) error { if opts . DashOnly { return nil } secret := & v1 . Secret { TypeMeta : metav1 . TypeMeta { Kind : "Secret" , APIVersion : "v1" , } , ObjectMeta : objectMeta ( client . StorageSecretName , labels ( client . StorageSecretName ) , nil , opts . Namespace ) , Data : data , } return encoder . Encode ( secret ) }
3042	func GoogleSecret ( bucket string , cred string ) map [ string ] [ ] byte { return map [ string ] [ ] byte { "google-bucket" : [ ] byte ( bucket ) , "google-cred" : [ ] byte ( cred ) , } }
3043	func WriteDashboardAssets ( encoder Encoder , opts * AssetOpts ) error { if err := encoder . Encode ( DashService ( opts ) ) ; err != nil { return err } return encoder . Encode ( DashDeployment ( opts ) ) }
3044	func WriteLocalAssets ( encoder Encoder , opts * AssetOpts , hostPath string ) error { if err := WriteAssets ( encoder , opts , localBackend , localBackend , 1 , hostPath ) ; err != nil { return err } if secretErr := WriteSecret ( encoder , LocalSecret ( ) , opts ) ; secretErr != nil { return secretErr } return nil }
3045	func WriteCustomAssets ( encoder Encoder , opts * AssetOpts , args [ ] string , objectStoreBackend string , persistentDiskBackend string , secure , isS3V2 bool ) error { switch objectStoreBackend { case "s3" : if len ( args ) != s3CustomArgs { return fmt . Errorf ( "Expected %d arguments for disk+s3 backend" , s3CustomArgs ) } volumeSize , err := strconv . Atoi ( args [ 1 ] ) if err != nil { return fmt . Errorf ( "volume size needs to be an integer; instead got %v" , args [ 1 ] ) } switch persistentDiskBackend { case "aws" : if err := WriteAssets ( encoder , opts , minioBackend , amazonBackend , volumeSize , "" ) ; err != nil { return err } case "google" : if err := WriteAssets ( encoder , opts , minioBackend , googleBackend , volumeSize , "" ) ; err != nil { return err } case "azure" : if err := WriteAssets ( encoder , opts , minioBackend , microsoftBackend , volumeSize , "" ) ; err != nil { return err } default : return fmt . Errorf ( "Did not recognize the choice of persistent-disk" ) } return WriteSecret ( encoder , MinioSecret ( args [ 2 ] , args [ 3 ] , args [ 4 ] , args [ 5 ] , secure , isS3V2 ) , opts ) default : return fmt . Errorf ( "Did not recognize the choice of object-store" ) } }
3046	func WriteAmazonAssets ( encoder Encoder , opts * AssetOpts , region string , bucket string , volumeSize int , creds * AmazonCreds , cloudfrontDistro string ) error { if err := WriteAssets ( encoder , opts , amazonBackend , amazonBackend , volumeSize , "" ) ; err != nil { return err } var secret map [ string ] [ ] byte if creds == nil { secret = AmazonIAMRoleSecret ( region , bucket , cloudfrontDistro ) } else if creds . ID != "" { secret = AmazonSecret ( region , bucket , creds . ID , creds . Secret , creds . Token , cloudfrontDistro ) } else if creds . VaultAddress != "" { secret = AmazonVaultSecret ( region , bucket , creds . VaultAddress , creds . VaultRole , creds . VaultToken , cloudfrontDistro ) } return WriteSecret ( encoder , secret , opts ) }
3047	func WriteGoogleAssets ( encoder Encoder , opts * AssetOpts , bucket string , cred string , volumeSize int ) error { if err := WriteAssets ( encoder , opts , googleBackend , googleBackend , volumeSize , "" ) ; err != nil { return err } return WriteSecret ( encoder , GoogleSecret ( bucket , cred ) , opts ) }
3048	func WriteMicrosoftAssets ( encoder Encoder , opts * AssetOpts , container string , id string , secret string , volumeSize int ) error { if err := WriteAssets ( encoder , opts , microsoftBackend , microsoftBackend , volumeSize , "" ) ; err != nil { return err } return WriteSecret ( encoder , MicrosoftSecret ( container , id , secret ) , opts ) }
3049	func Images ( opts * AssetOpts ) [ ] string { return [ ] string { versionedWorkerImage ( opts ) , etcdImage , grpcProxyImage , pauseImage , versionedPachdImage ( opts ) , opts . DashImage , } }
3050	func AddRegistry ( registry string , imageName string ) string { if registry == "" { return imageName } parts := strings . Split ( imageName , "/" ) if len ( parts ) == 3 { parts = parts [ 1 : ] } return path . Join ( registry , parts [ 0 ] , parts [ 1 ] ) }
3051	func ( b * ExponentialBackOff ) withCanonicalRandomizationFactor ( ) * ExponentialBackOff { if b . RandomizationFactor < 0 { b . RandomizationFactor = 0 } else if b . RandomizationFactor > 1 { b . RandomizationFactor = 1 } return b }
3052	func ( b * ExponentialBackOff ) Reset ( ) { b . currentInterval = b . InitialInterval b . startTime = b . Clock . Now ( ) }
3053	func ( b * ExponentialBackOff ) incrementCurrentInterval ( ) { if float64 ( b . currentInterval ) >= float64 ( b . MaxInterval ) / b . Multiplier { b . currentInterval = b . MaxInterval } else { b . currentInterval = time . Duration ( float64 ( b . currentInterval ) * b . Multiplier ) } }
3054	func NewBlockAPIServer ( dir string , cacheBytes int64 , backend string , etcdAddress string ) ( BlockAPIServer , error ) { switch backend { case MinioBackendEnvVar : if len ( dir ) > 0 && dir [ 0 ] == '/' { dir = dir [ 1 : ] } blockAPIServer , err := newMinioBlockAPIServer ( dir , cacheBytes , etcdAddress ) if err != nil { return nil , err } return blockAPIServer , nil case AmazonBackendEnvVar : if len ( dir ) > 0 && dir [ 0 ] == '/' { dir = dir [ 1 : ] } blockAPIServer , err := newAmazonBlockAPIServer ( dir , cacheBytes , etcdAddress ) if err != nil { return nil , err } return blockAPIServer , nil case GoogleBackendEnvVar : blockAPIServer , err := newGoogleBlockAPIServer ( dir , cacheBytes , etcdAddress ) if err != nil { return nil , err } return blockAPIServer , nil case MicrosoftBackendEnvVar : blockAPIServer , err := newMicrosoftBlockAPIServer ( dir , cacheBytes , etcdAddress ) if err != nil { return nil , err } return blockAPIServer , nil case LocalBackendEnvVar : fallthrough default : blockAPIServer , err := newLocalBlockAPIServer ( dir , cacheBytes , etcdAddress ) if err != nil { return nil , err } return blockAPIServer , nil } }
3055	func LocalStorage ( tb testing . TB ) ( obj . Client , * Storage ) { wd , err := os . Getwd ( ) require . NoError ( tb , err ) objC , err := obj . NewLocalClient ( wd ) require . NoError ( tb , err ) return objC , NewStorage ( objC , Prefix ) }
3056	func ( a * APIServer ) deleteJob ( stm col . STM , jobPtr * pps . EtcdJobInfo ) error { pipelinePtr := & pps . EtcdPipelineInfo { } if err := a . pipelines . ReadWrite ( stm ) . Update ( jobPtr . Pipeline . Name , pipelinePtr , func ( ) error { if pipelinePtr . JobCounts == nil { pipelinePtr . JobCounts = make ( map [ int32 ] int32 ) } if pipelinePtr . JobCounts [ int32 ( jobPtr . State ) ] != 0 { pipelinePtr . JobCounts [ int32 ( jobPtr . State ) ] -- } return nil } ) ; err != nil { return err } return a . jobs . ReadWrite ( stm ) . Delete ( jobPtr . Job . ID ) }
3057	func writeXML ( w http . ResponseWriter , r * http . Request , code int , v interface { } ) { w . Header ( ) . Set ( "Content-Type" , "application/xml" ) w . WriteHeader ( code ) encoder := xml . NewEncoder ( w ) if err := encoder . Encode ( v ) ; err != nil { requestLogger ( r ) . Errorf ( "could not encode xml response: %v" , err ) } }
3058	func clean1_7HashtreePath ( p string ) string { if ! strings . HasPrefix ( p , "/" ) { p = "/" + p } return default1_7HashtreeRoot ( pathlib . Clean ( p ) ) }
3059	func NewFromAddress ( addr string , options ... Option ) ( * APIClient , error ) { settings := clientSettings { maxConcurrentStreams : DefaultMaxConcurrentStreams , dialTimeout : DefaultDialTimeout , } for _ , option := range options { if err := option ( & settings ) ; err != nil { return nil , err } } c := & APIClient { addr : addr , caCerts : settings . caCerts , limiter : limit . New ( settings . maxConcurrentStreams ) , } if err := c . connect ( settings . dialTimeout ) ; err != nil { return nil , err } return c , nil }
3060	func getUserMachineAddrAndOpts ( cfg * config . Config ) ( string , [ ] Option , error ) { if envAddr , ok := os . LookupEnv ( "PACHD_ADDRESS" ) ; ok { if ! strings . Contains ( envAddr , ":" ) { envAddr = fmt . Sprintf ( "%s:%s" , envAddr , DefaultPachdNodePort ) } options , err := getCertOptionsFromEnv ( ) if err != nil { return "" , nil , err } return envAddr , options , nil } if cfg != nil && cfg . V1 != nil && cfg . V1 . PachdAddress != "" { if cfg . V1 . ServerCAs != "" { pemBytes , err := base64 . StdEncoding . DecodeString ( cfg . V1 . ServerCAs ) if err != nil { return "" , nil , fmt . Errorf ( "could not decode server CA certs in config: %v" , err ) } return cfg . V1 . PachdAddress , [ ] Option { WithAdditionalRootCAs ( pemBytes ) } , nil } return cfg . V1 . PachdAddress , nil , nil } options , err := getCertOptionsFromEnv ( ) if err != nil { return "" , nil , err } return "" , options , nil }
3061	func NewInCluster ( options ... Option ) ( * APIClient , error ) { host , ok := os . LookupEnv ( "PACHD_SERVICE_HOST" ) if ! ok { return nil , fmt . Errorf ( "PACHD_SERVICE_HOST not set" ) } port , ok := os . LookupEnv ( "PACHD_SERVICE_PORT" ) if ! ok { return nil , fmt . Errorf ( "PACHD_SERVICE_PORT not set" ) } return NewFromAddress ( fmt . Sprintf ( "%s:%s" , host , port ) , options ... ) }
3062	func ( c * APIClient ) Close ( ) error { if err := c . clientConn . Close ( ) ; err != nil { return err } if c . portForwarder != nil { c . portForwarder . Close ( ) } return nil }
3063	func ( c APIClient ) DeleteAll ( ) error { if _ , err := c . AuthAPIClient . Deactivate ( c . Ctx ( ) , & auth . DeactivateRequest { } , ) ; err != nil && ! auth . IsErrNotActivated ( err ) { return grpcutil . ScrubGRPC ( err ) } if _ , err := c . PpsAPIClient . DeleteAll ( c . Ctx ( ) , & types . Empty { } , ) ; err != nil { return grpcutil . ScrubGRPC ( err ) } if _ , err := c . PfsAPIClient . DeleteAll ( c . Ctx ( ) , & types . Empty { } , ) ; err != nil { return grpcutil . ScrubGRPC ( err ) } return nil }
3064	func ( c APIClient ) SetMaxConcurrentStreams ( n int ) { c . limiter = limit . New ( n ) }
3065	func ( c * APIClient ) WithCtx ( ctx context . Context ) * APIClient { result := * c result . ctx = ctx return & result }
3066	func NewDLock ( client * etcd . Client , prefix string ) DLock { return & etcdImpl { client : client , prefix : prefix , } }
3067	func ( a * APIServer ) DatumID ( data [ ] * Input ) string { hash := sha256 . New ( ) for _ , d := range data { hash . Write ( [ ] byte ( d . FileInfo . File . Path ) ) hash . Write ( d . FileInfo . Hash ) } return hex . EncodeToString ( hash . Sum ( nil ) ) }
3068	func ( a * APIServer ) runUserErrorHandlingCode ( ctx context . Context , logger * taggedLogger , environ [ ] string , stats * pps . ProcessStats , rawDatumTimeout * types . Duration ) ( retErr error ) { logger . Logf ( "beginning to run user error handling code" ) defer func ( start time . Time ) { if retErr != nil { logger . Logf ( "errored running user error handling code after %v: %v" , time . Since ( start ) , retErr ) } else { logger . Logf ( "finished running user error handling code after %v" , time . Since ( start ) ) } } ( time . Now ( ) ) cmd := exec . CommandContext ( ctx , a . pipelineInfo . Transform . ErrCmd [ 0 ] , a . pipelineInfo . Transform . ErrCmd [ 1 : ] ... ) if a . pipelineInfo . Transform . ErrStdin != nil { cmd . Stdin = strings . NewReader ( strings . Join ( a . pipelineInfo . Transform . ErrStdin , "\n" ) + \n ) } "\n" \n cmd . Stdout = logger . userLogger ( ) cmd . Stderr = logger . userLogger ( ) cmd . Env = environ if a . uid != nil && a . gid != nil { cmd . SysProcAttr = & syscall . SysProcAttr { Credential : & syscall . Credential { Uid : * a . uid , Gid : * a . gid , } , } } cmd . Dir = a . pipelineInfo . Transform . WorkingDir err := cmd . Start ( ) if err != nil { return fmt . Errorf ( "error cmd.Start: %v" , err ) } state , err := cmd . Process . Wait ( ) if err != nil { return fmt . Errorf ( "error cmd.Wait: %v" , err ) } if isDone ( ctx ) { if err = ctx . Err ( ) ; err != nil { return err } } err = cmd . WaitIO ( state , err ) }
3069	func HashDatum ( pipelineName string , pipelineSalt string , data [ ] * Input ) string { hash := sha256 . New ( ) for _ , datum := range data { hash . Write ( [ ] byte ( datum . Name ) ) hash . Write ( [ ] byte ( datum . FileInfo . File . Path ) ) hash . Write ( datum . FileInfo . Hash ) } hash . Write ( [ ] byte ( pipelineName ) ) hash . Write ( [ ] byte ( pipelineSalt ) ) return client . DatumTagPrefix ( pipelineSalt ) + hex . EncodeToString ( hash . Sum ( nil ) ) }
3070	func HashDatum15 ( pipelineInfo * pps . PipelineInfo , data [ ] * Input ) ( string , error ) { hash := sha256 . New ( ) for _ , datum := range data { hash . Write ( [ ] byte ( datum . Name ) ) hash . Write ( [ ] byte ( datum . FileInfo . File . Path ) ) hash . Write ( datum . FileInfo . Hash ) } env := pipelineInfo . Transform . Env pipelineInfo . Transform . Env = nil defer func ( ) { pipelineInfo . Transform . Env = env } ( ) bytes , err := pipelineInfo . Transform . Marshal ( ) if err != nil { return "" , err } hash . Write ( bytes ) hash . Write ( [ ] byte ( pipelineInfo . Pipeline . Name ) ) hash . Write ( [ ] byte ( pipelineInfo . ID ) ) hash . Write ( [ ] byte ( strconv . Itoa ( int ( pipelineInfo . Version ) ) ) ) return client . DatumTagPrefix ( pipelineInfo . ID ) + hex . EncodeToString ( hash . Sum ( nil ) ) , nil }
3071	func ( a * APIServer ) Status ( ctx context . Context , _ * types . Empty ) ( * pps . WorkerStatus , error ) { a . statusMu . Lock ( ) defer a . statusMu . Unlock ( ) started , err := types . TimestampProto ( a . started ) if err != nil { return nil , err } result := & pps . WorkerStatus { JobID : a . jobID , WorkerID : a . workerName , Started : started , Data : a . datum ( ) , QueueSize : atomic . LoadInt64 ( & a . queueSize ) , } return result , nil }
3072	func ( a * APIServer ) Cancel ( ctx context . Context , request * CancelRequest ) ( * CancelResponse , error ) { a . statusMu . Lock ( ) defer a . statusMu . Unlock ( ) if request . JobID != a . jobID { return & CancelResponse { Success : false } , nil } if ! MatchDatum ( request . DataFilters , a . datum ( ) ) { return & CancelResponse { Success : false } , nil } a . cancel ( ) a . jobID = "" a . data = nil a . started = time . Time { } a . cancel = nil return & CancelResponse { Success : true } , nil }
3073	func mergeStats ( x , y * pps . ProcessStats ) error { var err error if x . DownloadTime , err = plusDuration ( x . DownloadTime , y . DownloadTime ) ; err != nil { return err } if x . ProcessTime , err = plusDuration ( x . ProcessTime , y . ProcessTime ) ; err != nil { return err } if x . UploadTime , err = plusDuration ( x . UploadTime , y . UploadTime ) ; err != nil { return err } x . DownloadBytes += y . DownloadBytes x . UploadBytes += y . UploadBytes return nil }
3074	func ( a * APIServer ) mergeChunk ( logger * taggedLogger , high int64 , result * processResult ) ( retErr error ) { logger . Logf ( "starting to merge chunk" ) defer func ( start time . Time ) { if retErr != nil { logger . Logf ( "errored merging chunk after %v: %v" , time . Since ( start ) , retErr ) } else { logger . Logf ( "finished merging chunk after %v" , time . Since ( start ) ) } } ( time . Now ( ) ) buf := & bytes . Buffer { } if result . datumsFailed <= 0 { if err := a . datumCache . Merge ( hashtree . NewWriter ( buf ) , nil , nil ) ; err != nil { return err } } if err := a . chunkCache . Put ( high , buf ) ; err != nil { return err } if a . pipelineInfo . EnableStats { buf . Reset ( ) if err := a . datumStatsCache . Merge ( hashtree . NewWriter ( buf ) , nil , nil ) ; err != nil { return err } return a . chunkStatsCache . Put ( high , buf ) } return nil }
3075	func IsCommitNotFoundErr ( err error ) bool { if err == nil { return false } return commitNotFoundRe . MatchString ( grpcutil . ScrubGRPC ( err ) . Error ( ) ) }
3076	func IsCommitDeletedErr ( err error ) bool { if err == nil { return false } return commitDeletedRe . MatchString ( grpcutil . ScrubGRPC ( err ) . Error ( ) ) }
3077	func IsCommitFinishedErr ( err error ) bool { if err == nil { return false } return commitFinishedRe . MatchString ( grpcutil . ScrubGRPC ( err ) . Error ( ) ) }
3078	func IsRepoNotFoundErr ( err error ) bool { if err == nil { return false } return repoNotFoundRe . MatchString ( err . Error ( ) ) }
3079	func IsBranchNotFoundErr ( err error ) bool { if err == nil { return false } return branchNotFoundRe . MatchString ( err . Error ( ) ) }
3080	func IsFileNotFoundErr ( err error ) bool { if err == nil { return false } return fileNotFoundRe . MatchString ( err . Error ( ) ) }
3081	func ( c APIClient ) Version ( ) ( string , error ) { v , err := c . VersionAPIClient . GetVersion ( c . Ctx ( ) , & types . Empty { } ) if err != nil { return "" , grpcutil . ScrubGRPC ( err ) } return version . PrettyPrintVersion ( v ) , nil }
3082	func validateRepoName ( name string ) error { match , _ := regexp . MatchString ( "^[a-zA-Z0-9_-]+$" , name ) if ! match { return fmt . Errorf ( "repo name (%v) invalid: only alphanumeric characters, underscores, and dashes are allowed" , name ) } return nil }
3083	func newDriver ( env * serviceenv . ServiceEnv , etcdPrefix string , treeCache * hashtree . Cache , storageRoot string , memoryRequest int64 ) ( * driver , error ) { if treeCache == nil { return nil , fmt . Errorf ( "cannot initialize driver with nil treeCache" ) } etcdClient := env . GetEtcdClient ( ) d := & driver { etcdClient : etcdClient , prefix : etcdPrefix , repos : pfsdb . Repos ( etcdClient , etcdPrefix ) , putFileRecords : pfsdb . PutFileRecords ( etcdClient , etcdPrefix ) , commits : func ( repo string ) col . Collection { return pfsdb . Commits ( etcdClient , etcdPrefix , repo ) } , branches : func ( repo string ) col . Collection { return pfsdb . Branches ( etcdClient , etcdPrefix , repo ) } , openCommits : pfsdb . OpenCommits ( etcdClient , etcdPrefix ) , treeCache : treeCache , storageRoot : storageRoot , memoryLimiter : semaphore . NewWeighted ( memoryRequest / 3 ) , } repo := client . NewRepo ( ppsconsts . SpecRepo ) repoInfo := & pfs . RepoInfo { Repo : repo , Created : now ( ) , } if _ , err := col . NewSTM ( context . Background ( ) , etcdClient , func ( stm col . STM ) error { repos := d . repos . ReadWrite ( stm ) return repos . Create ( repo . Name , repoInfo ) } ) ; err != nil && ! col . IsErrExists ( err ) { return nil , err } return d , nil }
3084	func ( d * driver ) inspectCommit ( pachClient * client . APIClient , commit * pfs . Commit , blockState pfs . CommitState ) ( * pfs . CommitInfo , error ) { ctx := pachClient . Ctx ( ) if commit == nil { return nil , fmt . Errorf ( "cannot inspect nil commit" ) } if err := d . checkIsAuthorized ( pachClient , commit . Repo , auth . Scope_READER ) ; err != nil { return nil , err } var commitInfo * pfs . CommitInfo if _ , err := col . NewSTM ( ctx , d . etcdClient , func ( stm col . STM ) error { var err error commitInfo , err = d . resolveCommit ( stm , commit ) return err } ) ; err != nil { return nil , err } commits := d . commits ( commit . Repo . Name ) . ReadOnly ( ctx ) if blockState == pfs . CommitState_READY { for _ , p := range commitInfo . Provenance { d . inspectCommit ( pachClient , p . Commit , pfs . CommitState_FINISHED ) } } if blockState == pfs . CommitState_FINISHED { if err := func ( ) error { commitInfoWatcher , err := commits . WatchOne ( commit . ID ) if err != nil { return err } defer commitInfoWatcher . Close ( ) for { var commitID string _commitInfo := new ( pfs . CommitInfo ) event := <- commitInfoWatcher . Watch ( ) switch event . Type { case watch . EventError : return event . Err case watch . EventPut : if err := event . Unmarshal ( & commitID , _commitInfo ) ; err != nil { return fmt . Errorf ( "Unmarshal: %v" , err ) } case watch . EventDelete : return pfsserver . ErrCommitDeleted { commit } } if _commitInfo . Finished != nil { commitInfo = _commitInfo break } } return nil } ( ) ; err != nil { return nil , err } } return commitInfo , nil }
3085	func ( d * driver ) scratchCommitPrefix ( commit * pfs . Commit ) string { return path . Join ( commit . Repo . Name , commit . ID ) }
3086	func ( d * driver ) scratchFilePrefix ( file * pfs . File ) ( string , error ) { return path . Join ( d . scratchCommitPrefix ( file . Commit ) , file . Path ) , nil }
3087	func ( d * driver ) getTreeForFile ( pachClient * client . APIClient , file * pfs . File ) ( hashtree . HashTree , error ) { if file . Commit == nil { t , err := hashtree . NewDBHashTree ( d . storageRoot ) if err != nil { return nil , err } return t , nil } commitInfo , err := d . inspectCommit ( pachClient , file . Commit , pfs . CommitState_STARTED ) if err != nil { return nil , err } if commitInfo . Finished != nil { tree , err := d . getTreeForCommit ( pachClient , file . Commit ) if err != nil { return nil , err } return tree , nil } parentTree , err := d . getTreeForCommit ( pachClient , commitInfo . ParentCommit ) if err != nil { return nil , err } return d . getTreeForOpenCommit ( pachClient , file , parentTree ) }
3088	func provenantOnInput ( provenance [ ] * pfs . CommitProvenance ) bool { provenanceCount := len ( provenance ) for _ , p := range provenance { if p . Commit . Repo . Name == ppsconsts . SpecRepo { provenanceCount -- break } } return provenanceCount > 0 }
3089	func nodeToFileInfo ( ci * pfs . CommitInfo , path string , node * hashtree . NodeProto , full bool ) * pfs . FileInfo { fileInfo := & pfs . FileInfo { File : & pfs . File { Commit : ci . Commit , Path : path , } , SizeBytes : uint64 ( node . SubtreeSize ) , Hash : node . Hash , Committed : ci . Finished , } if node . FileNode != nil { fileInfo . FileType = pfs . FileType_FILE if full { fileInfo . Objects = node . FileNode . Objects fileInfo . BlockRefs = node . FileNode . BlockRefs } } else if node . DirNode != nil { fileInfo . FileType = pfs . FileType_DIR if full { fileInfo . Children = node . DirNode . Children } } return fileInfo }
3090	func ( d * driver ) fileHistory ( pachClient * client . APIClient , file * pfs . File , history int64 , f func ( * pfs . FileInfo ) error ) error { var fi * pfs . FileInfo for { _fi , err := d . inspectFile ( pachClient , file ) if err != nil { if _ , ok := err . ( pfsserver . ErrFileNotFound ) ; ok { return f ( fi ) } return err } if fi != nil && bytes . Compare ( fi . Hash , _fi . Hash ) != 0 { if err := f ( fi ) ; err != nil { return err } if history > 0 { history -- if history == 0 { return nil } } } fi = _fi ci , err := d . inspectCommit ( pachClient , file . Commit , pfs . CommitState_STARTED ) if err != nil { return err } if ci . ParentCommit == nil { return f ( fi ) } file . Commit = ci . ParentCommit } }
3091	func ( d * driver ) upsertPutFileRecords ( pachClient * client . APIClient , file * pfs . File , newRecords * pfs . PutFileRecords ) error { prefix , err := d . scratchFilePrefix ( file ) if err != nil { return err } ctx := pachClient . Ctx ( ) _ , err = col . NewSTM ( ctx , d . etcdClient , func ( stm col . STM ) error { commitsCol := d . openCommits . ReadOnly ( ctx ) var commit pfs . Commit err := commitsCol . Get ( file . Commit . ID , & commit ) if err != nil { return err } if commit . ID != file . Commit . ID { return fmt . Errorf ( "commit %v is not open" , file . Commit . ID ) } recordsCol := d . putFileRecords . ReadWrite ( stm ) var existingRecords pfs . PutFileRecords return recordsCol . Upsert ( prefix , & existingRecords , func ( ) error { if newRecords . Tombstone { existingRecords . Tombstone = true existingRecords . Records = nil } existingRecords . Split = newRecords . Split existingRecords . Records = append ( existingRecords . Records , newRecords . Records ... ) existingRecords . Header = newRecords . Header existingRecords . Footer = newRecords . Footer return nil } ) } ) if err != nil { return err } return err }
3092	func ( r * PGDumpReader ) ReadRow ( ) ( [ ] byte , error ) { if len ( r . Header ) == 0 { err := r . readHeader ( ) if err != nil { return nil , err } } endLine := "\\.\n" \\ \n row , err := r . rd . ReadBytes ( '\n' ) if err != nil && err != io . EOF { return nil , fmt . Errorf ( "error reading pgdump row: %v" , err ) } if len ( row ) >= 2 && row [ len ( row ) - 2 ] == '\r' { row [ len ( row ) - 2 ] = '\n' row = row [ : len ( row ) - 1 ] } if string ( row ) == endLine { r . Footer = append ( r . Footer , row ... ) err = r . readFooter ( ) row = nil } }
3093	func NewReporter ( clusterID string , kubeClient * kube . Clientset ) * Reporter { reporter := & Reporter { segmentClient : newPersistentClient ( ) , clusterID : clusterID , kubeClient : kubeClient , } go reporter . reportClusterMetrics ( ) return reporter }
3094	func ReportUserAction ( ctx context . Context , r * Reporter , action string ) func ( time . Time , error ) { if r == nil { return func ( time . Time , error ) { } } r . reportUserAction ( ctx , fmt . Sprintf ( "%vStarted" , action ) , 1 ) return func ( start time . Time , err error ) { if err == nil { r . reportUserAction ( ctx , fmt . Sprintf ( "%vFinished" , action ) , time . Since ( start ) . Seconds ( ) ) } else { r . reportUserAction ( ctx , fmt . Sprintf ( "%vErrored" , action ) , err . Error ( ) ) } } }
3095	func FinishReportAndFlushUserAction ( action string , err error , start time . Time ) func ( ) { var wait func ( ) if err != nil { wait = reportAndFlushUserAction ( fmt . Sprintf ( "%vErrored" , action ) , err ) } else { wait = reportAndFlushUserAction ( fmt . Sprintf ( "%vFinished" , action ) , time . Since ( start ) . Seconds ( ) ) } return wait }
3096	func ( r * Reader ) Read ( data [ ] byte ) ( int , error ) { var totalRead int for len ( data ) > 0 { n , err := r . r . Read ( data ) data = data [ n : ] totalRead += n if err != nil { if len ( r . dataRefs ) == 0 { return totalRead , io . EOF } if r . curr == nil || r . curr . Chunk . Hash != r . dataRefs [ 0 ] . Chunk . Hash { if err := r . readChunk ( r . dataRefs [ 0 ] . Chunk ) ; err != nil { return totalRead , err } } r . curr = r . dataRefs [ 0 ] r . dataRefs = r . dataRefs [ 1 : ] r . r = bytes . NewReader ( r . buf . Bytes ( ) [ r . curr . OffsetBytes : r . curr . OffsetBytes + r . curr . SizeBytes ] ) } } return totalRead , nil }
3097	func ActivateCmd ( noMetrics , noPortForwarding * bool ) * cobra . Command { var expires string activate := & cobra . Command { Use : "{{alias}} <activation-code>" , Short : "Activate the enterprise features of Pachyderm with an activation " + "code" , Long : "Activate the enterprise features of Pachyderm with an activation " + "code" , Run : cmdutil . RunFixedArgs ( 1 , func ( args [ ] string ) error { c , err := client . NewOnUserMachine ( ! * noMetrics , ! * noPortForwarding , "user" ) if err != nil { return fmt . Errorf ( "could not connect: %s" , err . Error ( ) ) } defer c . Close ( ) req := & enterprise . ActivateRequest { } req . ActivationCode = args [ 0 ] if expires != "" { t , err := parseISO8601 ( expires ) if err != nil { return fmt . Errorf ( "could not parse the timestamp \"%s\": %s" , \" , \" ) } expires err . Error ( ) } req . Expires , err = types . TimestampProto ( t ) if err != nil { return fmt . Errorf ( "error converting expiration time \"%s\"; %s" , \" , \" ) } t . String ( ) err . Error ( ) resp , err := c . Enterprise . Activate ( c . Ctx ( ) , req ) if err != nil { return err } } ) , } ts , err := types . TimestampFromProto ( resp . Info . Expires ) if err != nil { return fmt . Errorf ( "Activation request succeeded, but could not " + "convert token expiration time to a timestamp: %s" , err . Error ( ) ) } }
3098	func GetStateCmd ( noMetrics , noPortForwarding * bool ) * cobra . Command { getState := & cobra . Command { Short : "Check whether the Pachyderm cluster has enterprise features " + "activated" , Long : "Check whether the Pachyderm cluster has enterprise features " + "activated" , Run : cmdutil . Run ( func ( args [ ] string ) error { c , err := client . NewOnUserMachine ( ! * noMetrics , ! * noPortForwarding , "user" ) if err != nil { return fmt . Errorf ( "could not connect: %s" , err . Error ( ) ) } defer c . Close ( ) resp , err := c . Enterprise . GetState ( c . Ctx ( ) , & enterprise . GetStateRequest { } ) if err != nil { return err } if resp . State == enterprise . State_NONE { fmt . Println ( "No Pachyderm Enterprise token was found" ) return nil } ts , err := types . TimestampFromProto ( resp . Info . Expires ) if err != nil { return fmt . Errorf ( "Activation request succeeded, but could not " + "convert token expiration time to a timestamp: %s" , err . Error ( ) ) } fmt . Printf ( "Pachyderm Enterprise token state: %s\nExpiration: %s\n" , \n , \n ) resp . State . String ( ) } ) , } ts . String ( ) }
3099	func Cmds ( noMetrics , noPortForwarding * bool ) [ ] * cobra . Command { var commands [ ] * cobra . Command enterprise := & cobra . Command { Short : "Enterprise commands enable Pachyderm Enterprise features" , Long : "Enterprise commands enable Pachyderm Enterprise features" , } commands = append ( commands , cmdutil . CreateAlias ( enterprise , "enterprise" ) ) commands = append ( commands , ActivateCmd ( noMetrics , noPortForwarding ) ) commands = append ( commands , GetStateCmd ( noMetrics , noPortForwarding ) ) return commands }
3100	func NewConfiguration ( config interface { } ) * Configuration { configuration := & Configuration { } switch config . ( type ) { case * GlobalConfiguration : configuration . GlobalConfiguration = config . ( * GlobalConfiguration ) return configuration case * PachdFullConfiguration : configuration . GlobalConfiguration = & config . ( * PachdFullConfiguration ) . GlobalConfiguration configuration . PachdSpecificConfiguration = & config . ( * PachdFullConfiguration ) . PachdSpecificConfiguration return configuration case * WorkerFullConfiguration : configuration . GlobalConfiguration = & config . ( * WorkerFullConfiguration ) . GlobalConfiguration configuration . WorkerSpecificConfiguration = & config . ( * WorkerFullConfiguration ) . WorkerSpecificConfiguration return configuration default : return nil } }
3101	func Repos ( etcdClient * etcd . Client , etcdPrefix string ) col . Collection { return col . NewCollection ( etcdClient , path . Join ( etcdPrefix , reposPrefix ) , nil , & pfs . RepoInfo { } , nil , nil , ) }
3102	func PutFileRecords ( etcdClient * etcd . Client , etcdPrefix string ) col . Collection { return col . NewCollection ( etcdClient , path . Join ( etcdPrefix , putFileRecordsPrefix ) , nil , & pfs . PutFileRecords { } , nil , nil , ) }
3103	func Commits ( etcdClient * etcd . Client , etcdPrefix string , repo string ) col . Collection { return col . NewCollection ( etcdClient , path . Join ( etcdPrefix , commitsPrefix , repo ) , [ ] * col . Index { ProvenanceIndex } , & pfs . CommitInfo { } , nil , nil , ) }
3104	func Branches ( etcdClient * etcd . Client , etcdPrefix string , repo string ) col . Collection { return col . NewCollection ( etcdClient , path . Join ( etcdPrefix , branchesPrefix , repo ) , nil , & pfs . BranchInfo { } , func ( key string ) error { if uuid . IsUUIDWithoutDashes ( key ) { return fmt . Errorf ( "branch name cannot be a UUID V4" ) } return nil } , nil , ) }
3105	func OpenCommits ( etcdClient * etcd . Client , etcdPrefix string ) col . Collection { return col . NewCollection ( etcdClient , path . Join ( etcdPrefix , openCommitsPrefix ) , nil , & pfs . Commit { } , nil , nil , ) }
3106	func NewDAG ( nodes map [ string ] [ ] string ) * DAG { result := & DAG { parents : make ( map [ string ] [ ] string ) , children : make ( map [ string ] [ ] string ) , leaves : make ( map [ string ] bool ) , } for id , parents := range nodes { result . NewNode ( id , parents ) } return result }
3107	func ( d * DAG ) NewNode ( id string , parents [ ] string ) { d . parents [ id ] = parents for _ , parentID := range parents { d . children [ parentID ] = append ( d . children [ parentID ] , id ) d . leaves [ parentID ] = false } if _ , ok := d . leaves [ id ] ; ! ok { d . leaves [ id ] = true } }
3108	func ( d * DAG ) Sorted ( ) [ ] string { seen := make ( map [ string ] bool ) var result [ ] string for id := range d . parents { result = append ( result , dfs ( id , d . parents , seen ) ... ) } return result }
3109	func ( d * DAG ) Leaves ( ) [ ] string { var result [ ] string for id , isLeaf := range d . leaves { if isLeaf { result = append ( result , id ) } } return result }
3110	func ( d * DAG ) Ancestors ( id string , from [ ] string ) [ ] string { seen := make ( map [ string ] bool ) for _ , fromID := range from { seen [ fromID ] = true } return dfs ( id , d . parents , seen ) }
3111	func ( d * DAG ) Descendants ( id string , to [ ] string ) [ ] string { seen := make ( map [ string ] bool ) for _ , toID := range to { seen [ toID ] = true } return bfs ( id , d . children , seen ) }
3112	func ( d * DAG ) Ghosts ( ) [ ] string { var result [ ] string for id := range d . children { if _ , ok := d . parents [ id ] ; ! ok { result = append ( result , id ) } } return result }
3113	func NewPortForwarder ( namespace string ) ( * PortForwarder , error ) { if namespace == "" { namespace = "default" } rules := clientcmd . NewDefaultClientConfigLoadingRules ( ) overrides := & clientcmd . ConfigOverrides { } kubeConfig := clientcmd . NewNonInteractiveDeferredLoadingClientConfig ( rules , overrides ) config , err := kubeConfig . ClientConfig ( ) if err != nil { return nil , err } client , err := kubernetes . NewForConfig ( config ) if err != nil { return nil , err } core := client . CoreV1 ( ) return & PortForwarder { core : core , client : core . RESTClient ( ) , config : config , namespace : namespace , logger : log . StandardLogger ( ) . Writer ( ) , stopChansLock : & sync . Mutex { } , stopChans : [ ] chan struct { } { } , shutdown : false , } , nil }
3114	func ( f * PortForwarder ) Run ( appName string , localPort , remotePort uint16 ) error { podNameSelector := map [ string ] string { "suite" : "pachyderm" , "app" : appName , } podList , err := f . core . Pods ( f . namespace ) . List ( metav1 . ListOptions { LabelSelector : metav1 . FormatLabelSelector ( metav1 . SetAsLabelSelector ( podNameSelector ) ) , TypeMeta : metav1 . TypeMeta { Kind : "ListOptions" , APIVersion : "v1" , } , } ) if err != nil { return err } if len ( podList . Items ) == 0 { return fmt . Errorf ( "No pods found for app %s" , appName ) } podName := podList . Items [ rand . Intn ( len ( podList . Items ) ) ] . Name url := f . client . Post ( ) . Resource ( "pods" ) . Namespace ( f . namespace ) . Name ( podName ) . SubResource ( "portforward" ) . URL ( ) transport , upgrader , err := spdy . RoundTripperFor ( f . config ) if err != nil { return err } dialer := spdy . NewDialer ( upgrader , & http . Client { Transport : transport } , "POST" , url ) ports := [ ] string { fmt . Sprintf ( "%d:%d" , localPort , remotePort ) } readyChan := make ( chan struct { } , 1 ) stopChan := make ( chan struct { } , 1 ) f . stopChansLock . Lock ( ) if f . shutdown { f . stopChansLock . Unlock ( ) return fmt . Errorf ( "port forwarder is shutdown" ) } f . stopChans = append ( f . stopChans , stopChan ) f . stopChansLock . Unlock ( ) fw , err := portforward . New ( dialer , ports , stopChan , readyChan , ioutil . Discard , f . logger ) if err != nil { return err } errChan := make ( chan error , 1 ) go func ( ) { errChan <- fw . ForwardPorts ( ) } ( ) select { case err = <- errChan : return fmt . Errorf ( "port forwarding failed: %v" , err ) case <- fw . Ready : return nil } }
3115	func ( f * PortForwarder ) RunForDaemon ( localPort , remotePort uint16 ) error { if localPort == 0 { localPort = pachdLocalPort } if remotePort == 0 { remotePort = pachdRemotePort } return f . Run ( "pachd" , localPort , remotePort ) }
3116	func ( f * PortForwarder ) RunForSAMLACS ( localPort uint16 ) error { if localPort == 0 { localPort = samlAcsLocalPort } return f . Run ( "pachd" , localPort , 654 ) }
3117	func ( f * PortForwarder ) RunForDashUI ( localPort uint16 ) error { if localPort == 0 { localPort = dashUILocalPort } return f . Run ( "dash" , localPort , 8080 ) }
3118	func ( f * PortForwarder ) RunForDashWebSocket ( localPort uint16 ) error { if localPort == 0 { localPort = dashWebSocketLocalPort } return f . Run ( "dash" , localPort , 8081 ) }
3119	func ( f * PortForwarder ) RunForPFS ( localPort uint16 ) error { if localPort == 0 { localPort = pfsLocalPort } return f . Run ( "pachd" , localPort , 30652 ) }
3120	func ( f * PortForwarder ) RunForS3Gateway ( localPort uint16 ) error { if localPort == 0 { localPort = s3gatewayLocalPort } return f . Run ( "pachd" , localPort , 600 ) }
3121	func ( f * PortForwarder ) Lock ( ) error { pidfile . SetPidfilePath ( path . Join ( os . Getenv ( "HOME" ) , ".pachyderm/port-forward.pid" ) ) return pidfile . Write ( ) }
3122	func ( f * PortForwarder ) Close ( ) { defer f . logger . Close ( ) f . stopChansLock . Lock ( ) defer f . stopChansLock . Unlock ( ) if f . shutdown { panic ( "port forwarder already shutdown" ) } f . shutdown = true for _ , stopChan := range f . stopChans { close ( stopChan ) } }
3123	func ( e * Event ) Unmarshal ( key * string , val proto . Message ) error { if err := CheckType ( e . Template , val ) ; err != nil { return err } * key = string ( e . Key ) return proto . Unmarshal ( e . Value , val ) }
3124	func ( e * Event ) UnmarshalPrev ( key * string , val proto . Message ) error { if err := CheckType ( e . Template , val ) ; err != nil { return err } * key = string ( e . PrevKey ) return proto . Unmarshal ( e . PrevValue , val ) }
3125	func MakeWatcher ( eventCh chan * Event , done chan struct { } ) Watcher { return & watcher { eventCh : eventCh , done : done , } }
3126	func CheckType ( template proto . Message , val interface { } ) error { if template != nil { valType , templateType := reflect . TypeOf ( val ) , reflect . TypeOf ( template ) if valType != templateType { return fmt . Errorf ( "invalid type, got: %s, expected: %s" , valType , templateType ) } } return nil }
3127	func NewPool ( kubeClient * kube . Clientset , namespace string , serviceName string , port int , queueSize int64 , opts ... grpc . DialOption ) ( * Pool , error ) { endpointsInterface := kubeClient . CoreV1 ( ) . Endpoints ( namespace ) watch , err := endpointsInterface . Watch ( metav1 . ListOptions { LabelSelector : metav1 . FormatLabelSelector ( metav1 . SetAsLabelSelector ( map [ string ] string { "app" : serviceName } , ) ) , Watch : true , } ) if err != nil { return nil , err } pool := & Pool { port : port , endpointsWatch : watch , opts : opts , done : make ( chan struct { } ) , queueSize : queueSize , } pool . connsCond = sync . NewCond ( & pool . connsLock ) go pool . watchEndpoints ( ) return pool , nil }
3128	func ( p * Pool ) Do ( ctx context . Context , f func ( cc * grpc . ClientConn ) error ) error { var conn * connCount if err := func ( ) error { p . connsLock . Lock ( ) defer p . connsLock . Unlock ( ) for { for addr , mapConn := range p . conns { if mapConn . cc == nil { cc , err := grpc . DialContext ( ctx , addr , p . opts ... ) if err != nil { return fmt . Errorf ( "failed to connect to %s: %+v" , addr , err ) } mapConn . cc = cc conn = mapConn break } else { mapConnCount := atomic . LoadInt64 ( & mapConn . count ) if mapConnCount < p . queueSize && ( conn == nil || mapConnCount < atomic . LoadInt64 ( & conn . count ) ) { conn = mapConn } } } if conn == nil { p . connsCond . Wait ( ) } else { atomic . AddInt64 ( & conn . count , 1 ) break } } return nil } ( ) ; err != nil { return err } defer p . connsCond . Broadcast ( ) defer atomic . AddInt64 ( & conn . count , - 1 ) return f ( conn . cc ) }
3129	func ( p * Pool ) Close ( ) error { close ( p . done ) var retErr error for _ , conn := range p . conns { if conn . cc != nil { if err := conn . cc . Close ( ) ; err != nil { retErr = err } } } return retErr }
3130	func buildImage ( client * docker . Client , repo string , contextDir string , dockerfile string , destTag string ) error { destImage := fmt . Sprintf ( "%s:%s" , repo , destTag ) fmt . Printf ( "Building %s, this may take a while.\n" , \n ) destImage err := client . BuildImage ( docker . BuildImageOptions { Name : destImage , ContextDir : contextDir , Dockerfile : dockerfile , OutputStream : os . Stdout , } ) if err != nil { return fmt . Errorf ( "could not build docker image: %s" , err ) } }
3131	func pushImage ( client * docker . Client , authConfig docker . AuthConfiguration , repo string , sourceTag string , destTag string ) ( string , error ) { sourceImage := fmt . Sprintf ( "%s:%s" , repo , sourceTag ) destImage := fmt . Sprintf ( "%s:%s" , repo , destTag ) fmt . Printf ( "Tagging/pushing %s, this may take a while.\n" , \n ) destImage if err := client . TagImage ( sourceImage , docker . TagImageOptions { Repo : repo , Tag : destTag , Context : context . Background ( ) , } ) ; err != nil { err = fmt . Errorf ( "could not tag docker image: %s" , err ) return "" , err } if err := client . PushImage ( docker . PushImageOptions { Name : repo , Tag : destTag , } , authConfig , ) ; err != nil { err = fmt . Errorf ( "could not push docker image: %s" , err ) return "" , err } }
3132	func newMinioClient ( endpoint , bucket , id , secret string , secure bool ) ( * minioClient , error ) { mclient , err := minio . New ( endpoint , id , secret , secure ) if err != nil { return nil , err } return & minioClient { bucket : bucket , Client : mclient , } , nil }
3133	func newMinioClientV2 ( endpoint , bucket , id , secret string , secure bool ) ( * minioClient , error ) { mclient , err := minio . NewV2 ( endpoint , id , secret , secure ) if err != nil { return nil , err } return & minioClient { bucket : bucket , Client : mclient , } , nil }
3134	func newMinioWriter ( ctx context . Context , client * minioClient , name string ) * minioWriter { reader , writer := io . Pipe ( ) w := & minioWriter { ctx : ctx , errChan : make ( chan error ) , pipe : writer , } go func ( ) { _ , err := client . PutObject ( client . bucket , name , reader , "application/octet-stream" ) if err != nil { reader . CloseWithError ( err ) } w . errChan <- err } ( ) return w }
3135	func ( w * minioWriter ) Close ( ) error { span , _ := tracing . AddSpanToAnyExisting ( w . ctx , "minioWriter.Close" ) defer tracing . FinishAnySpan ( span ) if err := w . pipe . Close ( ) ; err != nil { return err } return <- w . errChan }
3136	func PipelineRepo ( pipeline * ppsclient . Pipeline ) * pfs . Repo { return & pfs . Repo { Name : pipeline . Name } }
3137	func PipelineRcName ( name string , version uint64 ) string { name = strings . Replace ( name , "_" , "-" , - 1 ) return fmt . Sprintf ( "pipeline-%s-v%d" , strings . ToLower ( name ) , version ) }
3138	func GetRequestsResourceListFromPipeline ( pipelineInfo * pps . PipelineInfo ) ( * v1 . ResourceList , error ) { return getResourceListFromSpec ( pipelineInfo . ResourceRequests , pipelineInfo . CacheSize ) }
3139	func GetLimitsResourceListFromPipeline ( pipelineInfo * pps . PipelineInfo ) ( * v1 . ResourceList , error ) { return getResourceListFromSpec ( pipelineInfo . ResourceLimits , pipelineInfo . CacheSize ) }
3140	func getNumNodes ( kubeClient * kube . Clientset ) ( int , error ) { nodeList , err := kubeClient . CoreV1 ( ) . Nodes ( ) . List ( metav1 . ListOptions { } ) if err != nil { return 0 , fmt . Errorf ( "unable to retrieve node list from k8s to determine parallelism: %v" , err ) } if len ( nodeList . Items ) == 0 { return 0 , fmt . Errorf ( "pachyderm.pps.jobserver: no k8s nodes found" ) } return len ( nodeList . Items ) , nil }
3141	func GetExpectedNumWorkers ( kubeClient * kube . Clientset , spec * ppsclient . ParallelismSpec ) ( int , error ) { if spec == nil || ( spec . Constant == 0 && spec . Coefficient == 0 ) { return 1 , nil } else if spec . Constant > 0 && spec . Coefficient == 0 { return int ( spec . Constant ) , nil } else if spec . Constant == 0 && spec . Coefficient > 0 { numNodes , err := getNumNodes ( kubeClient ) if err != nil { return 0 , err } result := math . Floor ( spec . Coefficient * float64 ( numNodes ) ) return int ( math . Max ( result , 1 ) ) , nil } return 0 , fmt . Errorf ( "Unable to interpret ParallelismSpec %+v" , spec ) }
3142	func GetExpectedNumHashtrees ( spec * ppsclient . HashtreeSpec ) ( int64 , error ) { if spec == nil || spec . Constant == 0 { return 1 , nil } else if spec . Constant > 0 { return int64 ( spec . Constant ) , nil } return 0 , fmt . Errorf ( "unable to interpret HashtreeSpec %+v" , spec ) }
3143	func FailPipeline ( ctx context . Context , etcdClient * etcd . Client , pipelinesCollection col . Collection , pipelineName string , reason string ) error { _ , err := col . NewSTM ( ctx , etcdClient , func ( stm col . STM ) error { pipelines := pipelinesCollection . ReadWrite ( stm ) pipelinePtr := new ( pps . EtcdPipelineInfo ) if err := pipelines . Get ( pipelineName , pipelinePtr ) ; err != nil { return err } pipelinePtr . State = pps . PipelineState_PIPELINE_FAILURE pipelinePtr . Reason = reason pipelines . Put ( pipelineName , pipelinePtr ) return nil } ) return err }
3144	func JobInput ( pipelineInfo * pps . PipelineInfo , outputCommitInfo * pfs . CommitInfo ) * pps . Input { branchToCommit := make ( map [ string ] * pfs . Commit ) key := path . Join for _ , prov := range outputCommitInfo . Provenance { branchToCommit [ key ( prov . Commit . Repo . Name , prov . Branch . Name ) ] = prov . Commit } jobInput := proto . Clone ( pipelineInfo . Input ) . ( * pps . Input ) pps . VisitInput ( jobInput , func ( input * pps . Input ) { if input . Pfs != nil { if commit , ok := branchToCommit [ key ( input . Pfs . Repo , input . Pfs . Branch ) ] ; ok { input . Pfs . Commit = commit . ID } } if input . Cron != nil { if commit , ok := branchToCommit [ key ( input . Cron . Repo , "master" ) ] ; ok { input . Cron . Commit = commit . ID } } if input . Git != nil { if commit , ok := branchToCommit [ key ( input . Git . Name , input . Git . Branch ) ] ; ok { input . Git . Commit = commit . ID } } } ) return jobInput }
3145	func PipelineReqFromInfo ( pipelineInfo * ppsclient . PipelineInfo ) * ppsclient . CreatePipelineRequest { return & ppsclient . CreatePipelineRequest { Pipeline : pipelineInfo . Pipeline , Transform : pipelineInfo . Transform , ParallelismSpec : pipelineInfo . ParallelismSpec , HashtreeSpec : pipelineInfo . HashtreeSpec , Egress : pipelineInfo . Egress , OutputBranch : pipelineInfo . OutputBranch , ScaleDownThreshold : pipelineInfo . ScaleDownThreshold , ResourceRequests : pipelineInfo . ResourceRequests , ResourceLimits : pipelineInfo . ResourceLimits , Input : pipelineInfo . Input , Description : pipelineInfo . Description , CacheSize : pipelineInfo . CacheSize , EnableStats : pipelineInfo . EnableStats , Batch : pipelineInfo . Batch , MaxQueueSize : pipelineInfo . MaxQueueSize , Service : pipelineInfo . Service , ChunkSpec : pipelineInfo . ChunkSpec , DatumTimeout : pipelineInfo . DatumTimeout , JobTimeout : pipelineInfo . JobTimeout , Salt : pipelineInfo . Salt , } }
3146	func NewPipelineManifestReader ( path string ) ( result * PipelineManifestReader , retErr error ) { result = & PipelineManifestReader { } var pipelineReader io . Reader if path == "-" { pipelineReader = io . TeeReader ( os . Stdin , & result . buf ) fmt . Print ( "Reading from stdin.\n" ) } else \n if url , err := url . Parse ( path ) ; err == nil && url . Scheme != "" { resp , err := http . Get ( url . String ( ) ) if err != nil { return nil , err } defer func ( ) { if err := resp . Body . Close ( ) ; err != nil && retErr == nil { retErr = err } } ( ) rawBytes , err := ioutil . ReadAll ( resp . Body ) if err != nil { return nil , err } pipelineReader = io . TeeReader ( strings . NewReader ( string ( rawBytes ) ) , & result . buf ) } else { rawBytes , err := ioutil . ReadFile ( path ) if err != nil { return nil , err } pipelineReader = io . TeeReader ( strings . NewReader ( string ( rawBytes ) ) , & result . buf ) } result . decoder = json . NewDecoder ( pipelineReader ) }
3147	func ( r * PipelineManifestReader ) NextCreatePipelineRequest ( ) ( * ppsclient . CreatePipelineRequest , error ) { var result ppsclient . CreatePipelineRequest if err := jsonpb . UnmarshalNext ( r . decoder , & result ) ; err != nil { if err == io . EOF { return nil , err } return nil , fmt . Errorf ( "malformed pipeline spec: %s" , err ) } return & result , nil }
3148	func DescribeSyntaxError ( originalErr error , parsedBuffer bytes . Buffer ) error { sErr , ok := originalErr . ( * json . SyntaxError ) if ! ok { return originalErr } buffer := make ( [ ] byte , sErr . Offset ) parsedBuffer . Read ( buffer ) lineOffset := strings . LastIndex ( string ( buffer [ : len ( buffer ) - 1 ] ) , "\n" ) \n if lineOffset == - 1 { lineOffset = 0 } lines := strings . Split ( string ( buffer [ : len ( buffer ) - 1 ] ) , "\n" ) \n lineNumber := len ( lines ) }
3149	func UpdateJobState ( pipelines col . ReadWriteCollection , jobs col . ReadWriteCollection , jobPtr * pps . EtcdJobInfo , state pps . JobState , reason string ) error { pipelinePtr := & pps . EtcdPipelineInfo { } if err := pipelines . Get ( jobPtr . Pipeline . Name , pipelinePtr ) ; err != nil { return err } if pipelinePtr . JobCounts == nil { pipelinePtr . JobCounts = make ( map [ int32 ] int32 ) } if pipelinePtr . JobCounts [ int32 ( jobPtr . State ) ] != 0 { pipelinePtr . JobCounts [ int32 ( jobPtr . State ) ] -- } pipelinePtr . JobCounts [ int32 ( state ) ] ++ pipelinePtr . LastJobState = state if err := pipelines . Put ( jobPtr . Pipeline . Name , pipelinePtr ) ; err != nil { return err } var err error if state == pps . JobState_JOB_STARTING { jobPtr . Started , err = types . TimestampProto ( time . Now ( ) ) } else if IsTerminal ( state ) { jobPtr . Finished , err = types . TimestampProto ( time . Now ( ) ) } if err != nil { return err } jobPtr . State = state jobPtr . Reason = reason return jobs . Put ( jobPtr . Job . ID , jobPtr ) }
3150	func New ( ) string { var result string backoff . RetryNotify ( func ( ) error { uuid , err := uuid . NewV4 ( ) if err != nil { return err } result = uuid . String ( ) return nil } , backoff . NewInfiniteBackOff ( ) , func ( err error , d time . Duration ) error { fmt . Printf ( "error from uuid.NewV4: %v" , err ) return nil } ) return result }
3151	func ( h * HTTPError ) Code ( ) int { if h == nil { return http . StatusOK } return h . code }
3152	func NewHTTPError ( code int , formatStr string , args ... interface { } ) * HTTPError { return & HTTPError { code : code , err : fmt . Sprintf ( formatStr , args ... ) , } }
3153	func NewStorage ( objC obj . Client , prefix string ) * Storage { return & Storage { objC : objC , prefix : prefix , } }
3154	func ( s * Storage ) DeleteAll ( ctx context . Context ) error { return s . objC . Walk ( ctx , s . prefix , func ( hash string ) error { return s . objC . Delete ( ctx , hash ) } ) }
3155	func Chunk ( data [ ] byte , chunkSize int ) [ ] [ ] byte { var result [ ] [ ] byte for i := 0 ; i < len ( data ) ; i += chunkSize { end := i + chunkSize if end > len ( data ) { end = len ( data ) } result = append ( result , data [ i : end ] ) } return result }
3156	func ChunkReader ( r io . Reader , f func ( [ ] byte ) error ) ( int , error ) { var total int buf := GetBuffer ( ) defer PutBuffer ( buf ) for { n , err := r . Read ( buf ) if n == 0 && err != nil { if err == io . EOF { return total , nil } return total , err } if err := f ( buf [ : n ] ) ; err != nil { return total , err } total += n } }
3157	func NewStreamingBytesReader ( streamingBytesClient StreamingBytesClient , cancel context . CancelFunc ) io . ReadCloser { return & streamingBytesReader { streamingBytesClient : streamingBytesClient , cancel : cancel } }
3158	func WriteToStreamingBytesServer ( reader io . Reader , streamingBytesServer StreamingBytesServer ) error { buf := GetBuffer ( ) defer PutBuffer ( buf ) _ , err := io . CopyBuffer ( NewStreamingBytesWriter ( streamingBytesServer ) , ReaderWrapper { reader } , buf ) return err }
3159	func WriteFromStreamingBytesClient ( streamingBytesClient StreamingBytesClient , writer io . Writer ) error { for bytesValue , err := streamingBytesClient . Recv ( ) ; err != io . EOF ; bytesValue , err = streamingBytesClient . Recv ( ) { if err != nil { return err } if _ , err = writer . Write ( bytesValue . Value ) ; err != nil { return err } } return nil }
3160	func NewSidecarAPIServer ( env * serviceenv . ServiceEnv , etcdPrefix string , iamRole string , reporter * metrics . Reporter , workerGrpcPort uint16 , pprofPort uint16 , httpPort uint16 , peerPort uint16 , ) ( ppsclient . APIServer , error ) { apiServer := & apiServer { Logger : log . NewLogger ( "pps.API" ) , env : env , etcdPrefix : etcdPrefix , iamRole : iamRole , reporter : reporter , workerUsesRoot : true , pipelines : ppsdb . Pipelines ( env . GetEtcdClient ( ) , etcdPrefix ) , jobs : ppsdb . Jobs ( env . GetEtcdClient ( ) , etcdPrefix ) , workerGrpcPort : workerGrpcPort , pprofPort : pprofPort , httpPort : httpPort , peerPort : peerPort , } return apiServer , nil }
3161	func NewEnterpriseServer ( env * serviceenv . ServiceEnv , etcdPrefix string ) ( ec . APIServer , error ) { s := & apiServer { pachLogger : log . NewLogger ( "enterprise.API" ) , env : env , enterpriseToken : col . NewCollection ( env . GetEtcdClient ( ) , etcdPrefix , nil , & ec . EnterpriseRecord { } , nil , nil , ) , } s . enterpriseExpiration . Store ( time . Time { } ) go s . watchEnterpriseToken ( etcdPrefix ) return s , nil }
3162	func validateActivationCode ( code string ) ( expiration time . Time , err error ) { block , _ := pem . Decode ( [ ] byte ( publicKey ) ) if block == nil { return time . Time { } , fmt . Errorf ( "failed to pem decode public key" ) } pub , err := x509 . ParsePKIXPublicKey ( block . Bytes ) if err != nil { return time . Time { } , fmt . Errorf ( "failed to parse DER encoded public key: %s" , err . Error ( ) ) } rsaPub , ok := pub . ( * rsa . PublicKey ) if ! ok { return time . Time { } , fmt . Errorf ( "public key isn't an RSA key" ) } decodedActivationCode , err := base64 . StdEncoding . DecodeString ( code ) if err != nil { return time . Time { } , fmt . Errorf ( "activation code is not base64 encoded" ) } activationCode := & activationCode { } if err := json . Unmarshal ( decodedActivationCode , & activationCode ) ; err != nil { return time . Time { } , fmt . Errorf ( "activation code is not valid JSON" ) } decodedSignature , err := base64 . StdEncoding . DecodeString ( activationCode . Signature ) if err != nil { return time . Time { } , fmt . Errorf ( "signature is not base64 encoded" ) } hashedToken := sha256 . Sum256 ( [ ] byte ( activationCode . Token ) ) if err := rsa . VerifyPKCS1v15 ( rsaPub , crypto . SHA256 , hashedToken [ : ] , decodedSignature ) ; err != nil { return time . Time { } , fmt . Errorf ( "invalid signature in activation code" ) } token := token { } if err := json . Unmarshal ( [ ] byte ( activationCode . Token ) , & token ) ; err != nil { return time . Time { } , fmt . Errorf ( "token is not valid JSON" ) } expiration , err = time . Parse ( time . RFC3339 , token . Expiry ) if err != nil { return time . Time { } , fmt . Errorf ( "expiration is not valid ISO 8601 string" ) } if time . Now ( ) . After ( expiration ) { return time . Time { } , fmt . Errorf ( "the activation code has expired" ) } return expiration , nil }
3163	func ( a * apiServer ) Activate ( ctx context . Context , req * ec . ActivateRequest ) ( resp * ec . ActivateResponse , retErr error ) { a . LogReq ( req ) defer func ( start time . Time ) { a . pachLogger . Log ( req , resp , retErr , time . Since ( start ) ) } ( time . Now ( ) ) expiration , err := validateActivationCode ( req . ActivationCode ) if err != nil { return nil , fmt . Errorf ( "error validating activation code: %s" , err . Error ( ) ) } if req . Expires != nil { customExpiration , err := types . TimestampFromProto ( req . Expires ) if err == nil && expiration . After ( customExpiration ) { expiration = customExpiration } } expirationProto , err := types . TimestampProto ( expiration ) if err != nil { return nil , fmt . Errorf ( "could not convert expiration time \"%s\" to proto: %s" , \" , \" ) } expiration . String ( ) err . Error ( ) if _ , err := col . NewSTM ( ctx , a . env . GetEtcdClient ( ) , func ( stm col . STM ) error { e := a . enterpriseToken . ReadWrite ( stm ) return e . Put ( enterpriseTokenKey , & ec . EnterpriseRecord { ActivationCode : req . ActivationCode , Expires : expirationProto , } ) } ) ; err != nil { return nil , err } if err := backoff . Retry ( func ( ) error { if t := a . enterpriseExpiration . Load ( ) . ( time . Time ) ; t . IsZero ( ) { return fmt . Errorf ( "enterprise not activated" ) } return nil } , backoff . RetryEvery ( time . Second ) ) ; err != nil { return nil , err } }
3164	func ( a * apiServer ) Deactivate ( ctx context . Context , req * ec . DeactivateRequest ) ( resp * ec . DeactivateResponse , retErr error ) { a . LogReq ( req ) defer func ( start time . Time ) { a . pachLogger . Log ( req , resp , retErr , time . Since ( start ) ) } ( time . Now ( ) ) pachClient := a . env . GetPachClient ( ctx ) if err := pachClient . DeleteAll ( ) ; err != nil { return nil , fmt . Errorf ( "could not delete all pachyderm data: %v" , err ) } if _ , err := col . NewSTM ( ctx , a . env . GetEtcdClient ( ) , func ( stm col . STM ) error { return a . enterpriseToken . ReadWrite ( stm ) . Delete ( enterpriseTokenKey ) } ) ; err != nil { return nil , err } if err := backoff . Retry ( func ( ) error { if t := a . enterpriseExpiration . Load ( ) . ( time . Time ) ; ! t . IsZero ( ) { return fmt . Errorf ( "enterprise still activated" ) } return nil } , backoff . RetryEvery ( time . Second ) ) ; err != nil { return nil , err } time . Sleep ( time . Second ) return & ec . DeactivateResponse { } , nil }
3165	func lookExtensions ( path , dir string ) ( string , error ) { if filepath . Base ( path ) == path { path = filepath . Join ( "." , path ) } if dir == "" { return exec . LookPath ( path ) } if filepath . VolumeName ( path ) != "" { return exec . LookPath ( path ) } if len ( path ) > 1 && os . IsPathSeparator ( path [ 0 ] ) { return exec . LookPath ( path ) } dirandpath := filepath . Join ( dir , path ) lp , err := exec . LookPath ( dirandpath ) if err != nil { return "" , err } ext := strings . TrimPrefix ( lp , dirandpath ) return path + ext , nil }
3166	func ( c * Cmd ) Start ( ) error { if c . lookPathErr != nil { c . closeDescriptors ( c . closeAfterStart ) c . closeDescriptors ( c . closeAfterWait ) return c . lookPathErr } if runtime . GOOS == "windows" { lp , err := lookExtensions ( c . Path , c . Dir ) if err != nil { c . closeDescriptors ( c . closeAfterStart ) c . closeDescriptors ( c . closeAfterWait ) return err } c . Path = lp } if c . Process != nil { return errors . New ( "exec: already started" ) } if c . ctx != nil { select { case <- c . ctx . Done ( ) : c . closeDescriptors ( c . closeAfterStart ) c . closeDescriptors ( c . closeAfterWait ) return c . ctx . Err ( ) default : } } type F func ( * Cmd ) ( * os . File , error ) for _ , setupFd := range [ ] F { ( * Cmd ) . stdin , ( * Cmd ) . stdout , ( * Cmd ) . stderr } { fd , err := setupFd ( c ) if err != nil { c . closeDescriptors ( c . closeAfterStart ) c . closeDescriptors ( c . closeAfterWait ) return err } c . childFiles = append ( c . childFiles , fd ) } c . childFiles = append ( c . childFiles , c . ExtraFiles ... ) var err error c . Process , err = os . StartProcess ( c . Path , c . argv ( ) , & os . ProcAttr { Dir : c . Dir , Files : c . childFiles , Env : dedupEnv ( c . envv ( ) ) , Sys : c . SysProcAttr , } ) if err != nil { c . closeDescriptors ( c . closeAfterStart ) c . closeDescriptors ( c . closeAfterWait ) return err } c . closeDescriptors ( c . closeAfterStart ) c . errch = make ( chan error , len ( c . goroutine ) ) for _ , fn := range c . goroutine { go func ( fn func ( ) error ) { c . errch <- fn ( ) } ( fn ) } if c . ctx != nil { c . waitDone = make ( chan struct { } ) go func ( ) { select { case <- c . ctx . Done ( ) : c . Process . Kill ( ) case <- c . waitDone : } } ( ) } return nil }
3167	func ( c * Cmd ) CombinedOutput ( ) ( [ ] byte , error ) { if c . Stdout != nil { return nil , errors . New ( "exec: Stdout already set" ) } if c . Stderr != nil { return nil , errors . New ( "exec: Stderr already set" ) } var b bytes . Buffer c . Stdout = & b c . Stderr = & b err := c . Run ( ) return b . Bytes ( ) , err }
3168	func ( c * Cmd ) StdinPipe ( ) ( io . WriteCloser , error ) { if c . Stdin != nil { return nil , errors . New ( "exec: Stdin already set" ) } if c . Process != nil { return nil , errors . New ( "exec: StdinPipe after process started" ) } pr , pw , err := os . Pipe ( ) if err != nil { return nil , err } c . Stdin = pr c . closeAfterStart = append ( c . closeAfterStart , pr ) wc := & closeOnce { File : pw } c . closeAfterWait = append ( c . closeAfterWait , closerFunc ( wc . safeClose ) ) return wc , nil }
3169	func ( c * Cmd ) StdoutPipe ( ) ( io . ReadCloser , error ) { if c . Stdout != nil { return nil , errors . New ( "exec: Stdout already set" ) } if c . Process != nil { return nil , errors . New ( "exec: StdoutPipe after process started" ) } pr , pw , err := os . Pipe ( ) if err != nil { return nil , err } c . Stdout = pw c . closeAfterStart = append ( c . closeAfterStart , pw ) c . closeAfterWait = append ( c . closeAfterWait , pr ) return pr , nil }
3170	func dedupEnvCase ( caseInsensitive bool , env [ ] string ) [ ] string { out := make ( [ ] string , 0 , len ( env ) ) saw := map [ string ] int { } for _ , kv := range env { eq := strings . Index ( kv , "=" ) if eq < 0 { out = append ( out , kv ) continue } k := kv [ : eq ] if caseInsensitive { k = strings . ToLower ( k ) } if dupIdx , isDup := saw [ k ] ; isDup { out [ dupIdx ] = kv continue } saw [ k ] = len ( out ) out = append ( out , kv ) } return out }
3171	func InputName ( input * Input ) string { switch { case input == nil : return "" case input . Pfs != nil : return input . Pfs . Name case input . Cross != nil : if len ( input . Cross ) > 0 { return InputName ( input . Cross [ 0 ] ) } case input . Union != nil : if len ( input . Union ) > 0 { return InputName ( input . Union [ 0 ] ) } } return "" }
3172	func SortInput ( input * Input ) { VisitInput ( input , func ( input * Input ) { SortInputs := func ( inputs [ ] * Input ) { sort . SliceStable ( inputs , func ( i , j int ) bool { return InputName ( inputs [ i ] ) < InputName ( inputs [ j ] ) } ) } switch { case input . Cross != nil : SortInputs ( input . Cross ) case input . Union != nil : SortInputs ( input . Union ) } } ) }
3173	func InputBranches ( input * Input ) [ ] * pfs . Branch { var result [ ] * pfs . Branch VisitInput ( input , func ( input * Input ) { if input . Pfs != nil { result = append ( result , & pfs . Branch { Repo : & pfs . Repo { Name : input . Pfs . Repo } , Name : input . Pfs . Branch , } ) } if input . Cron != nil { result = append ( result , & pfs . Branch { Repo : & pfs . Repo { Name : input . Cron . Repo } , Name : "master" , } ) } if input . Git != nil { result = append ( result , & pfs . Branch { Repo : & pfs . Repo { Name : input . Git . Name } , Name : input . Git . Branch , } ) } } ) return result }
3174	func ValidateGitCloneURL ( url string ) error { exampleURL := "https://github.com/org/foo.git" if url == "" { return fmt . Errorf ( "clone URL is missing (example clone URL %v)" , exampleURL ) } o := & git . CloneOptions { URL : url , } if err := o . Validate ( ) ; err != nil { return err } invalidErr := fmt . Errorf ( "clone URL is missing .git suffix (example clone URL %v)" , exampleURL ) if ! strings . HasSuffix ( url , ".git" ) { return invalidErr } if ! strings . HasPrefix ( url , "https://" ) { return invalidErr } return nil }
3175	func containsEmpty ( vals [ ] string ) bool { for _ , val := range vals { if val == "" { return true } } return false }
3176	func NewAPIServer ( address string , storageRoot string , clusterInfo * admin . ClusterInfo ) APIServer { return & apiServer { Logger : log . NewLogger ( "admin.API" ) , address : address , storageRoot : storageRoot , clusterInfo : clusterInfo , } }
3177	func Ago ( timestamp * types . Timestamp ) string { t , _ := types . TimestampFromProto ( timestamp ) if t . Equal ( time . Time { } ) { return "" } return fmt . Sprintf ( "%s ago" , units . HumanDuration ( time . Since ( t ) ) ) }
3178	func TimeDifference ( from * types . Timestamp , to * types . Timestamp ) string { tFrom , _ := types . TimestampFromProto ( from ) tTo , _ := types . TimestampFromProto ( to ) return units . HumanDuration ( tTo . Sub ( tFrom ) ) }
3179	func Duration ( d * types . Duration ) string { duration , _ := types . DurationFromProto ( d ) return units . HumanDuration ( duration ) }
3180	func ( c APIClient ) InspectCluster ( ) ( * admin . ClusterInfo , error ) { clusterInfo , err := c . AdminAPIClient . InspectCluster ( c . Ctx ( ) , & types . Empty { } ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } return clusterInfo , nil }
3181	func ( c APIClient ) Extract ( objects bool , f func ( op * admin . Op ) error ) error { extractClient , err := c . AdminAPIClient . Extract ( c . Ctx ( ) , & admin . ExtractRequest { NoObjects : ! objects } ) if err != nil { return grpcutil . ScrubGRPC ( err ) } for { op , err := extractClient . Recv ( ) if err == io . EOF { break } if err != nil { return grpcutil . ScrubGRPC ( err ) } if err := f ( op ) ; err != nil { return err } } return nil }
3182	func ( c APIClient ) ExtractAll ( objects bool ) ( [ ] * admin . Op , error ) { var result [ ] * admin . Op if err := c . Extract ( objects , func ( op * admin . Op ) error { result = append ( result , op ) return nil } ) ; err != nil { return nil , err } return result , nil }
3183	func ( c APIClient ) ExtractWriter ( objects bool , w io . Writer ) error { writer := pbutil . NewWriter ( w ) return c . Extract ( objects , func ( op * admin . Op ) error { _ , err := writer . Write ( op ) return err } ) }
3184	func ( c APIClient ) ExtractURL ( url string ) error { extractClient , err := c . AdminAPIClient . Extract ( c . Ctx ( ) , & admin . ExtractRequest { URL : url } ) if err != nil { return grpcutil . ScrubGRPC ( err ) } resp , err := extractClient . Recv ( ) if err == nil { return fmt . Errorf ( "unexpected response from extract: %v" , resp ) } if err != io . EOF { return err } return nil }
3185	func ( c APIClient ) ExtractPipeline ( pipelineName string ) ( * pps . CreatePipelineRequest , error ) { op , err := c . AdminAPIClient . ExtractPipeline ( c . Ctx ( ) , & admin . ExtractPipelineRequest { Pipeline : NewPipeline ( pipelineName ) } ) if err != nil { return nil , grpcutil . ScrubGRPC ( err ) } if op . Op1_9 == nil || op . Op1_9 . Pipeline == nil { return nil , fmt . Errorf ( "malformed response is missing pipeline" ) } return op . Op1_9 . Pipeline , nil }
3186	func ( c APIClient ) Restore ( ops [ ] * admin . Op ) ( retErr error ) { restoreClient , err := c . AdminAPIClient . Restore ( c . Ctx ( ) ) if err != nil { return grpcutil . ScrubGRPC ( err ) } defer func ( ) { if _ , err := restoreClient . CloseAndRecv ( ) ; err != nil && retErr == nil { retErr = grpcutil . ScrubGRPC ( err ) } } ( ) for _ , op := range ops { if err := restoreClient . Send ( & admin . RestoreRequest { Op : op } ) ; err != nil { return grpcutil . ScrubGRPC ( err ) } } return nil }
3187	func ( c APIClient ) RestoreReader ( r io . Reader ) ( retErr error ) { restoreClient , err := c . AdminAPIClient . Restore ( c . Ctx ( ) ) if err != nil { return grpcutil . ScrubGRPC ( err ) } defer func ( ) { if _ , err := restoreClient . CloseAndRecv ( ) ; err != nil && retErr == nil { retErr = grpcutil . ScrubGRPC ( err ) } } ( ) reader := pbutil . NewReader ( r ) op := & admin . Op { } for { if err := reader . Read ( op ) ; err != nil { if err == io . EOF { break } return err } if err := restoreClient . Send ( & admin . RestoreRequest { Op : op } ) ; err != nil { return grpcutil . ScrubGRPC ( err ) } } return nil }
3188	func ( c APIClient ) RestoreFrom ( objects bool , otherC * APIClient ) ( retErr error ) { restoreClient , err := c . AdminAPIClient . Restore ( c . Ctx ( ) ) if err != nil { return grpcutil . ScrubGRPC ( err ) } defer func ( ) { if _ , err := restoreClient . CloseAndRecv ( ) ; err != nil && retErr == nil { retErr = grpcutil . ScrubGRPC ( err ) } } ( ) return otherC . Extract ( objects , func ( op * admin . Op ) error { return restoreClient . Send ( & admin . RestoreRequest { Op : op } ) } ) }
3189	func ( c APIClient ) RestoreURL ( url string ) ( retErr error ) { restoreClient , err := c . AdminAPIClient . Restore ( c . Ctx ( ) ) if err != nil { return grpcutil . ScrubGRPC ( err ) } defer func ( ) { if _ , err := restoreClient . CloseAndRecv ( ) ; err != nil && retErr == nil { retErr = grpcutil . ScrubGRPC ( err ) } } ( ) return grpcutil . ScrubGRPC ( restoreClient . Send ( & admin . RestoreRequest { URL : url } ) ) }
3190	func IgnoreTypes ( typs ... interface { } ) cmp . Option { tf := newTypeFilter ( typs ... ) return cmp . FilterPath ( tf . filter , cmp . Ignore ( ) ) }
3191	func ( s * textList ) AppendEllipsis ( ds diffStats ) { hasStats := ds != diffStats { } if len ( * s ) == 0 || ! ( * s ) [ len ( * s ) - 1 ] . Value . Equal ( textEllipsis ) { if hasStats { * s = append ( * s , textRecord { Value : textEllipsis , Comment : ds } ) } else { * s = append ( * s , textRecord { Value : textEllipsis } ) } return } if hasStats { ( * s ) [ len ( * s ) - 1 ] . Comment = ( * s ) [ len ( * s ) - 1 ] . Comment . ( diffStats ) . Append ( ds ) } }
3192	func IsType ( t reflect . Type , ft funcType ) bool { if t == nil || t . Kind ( ) != reflect . Func || t . IsVariadic ( ) { return false } ni , no := t . NumIn ( ) , t . NumOut ( ) switch ft { case tbFunc : if ni == 1 && no == 1 && t . Out ( 0 ) == boolType { return true } case ttbFunc : if ni == 2 && no == 1 && t . In ( 0 ) == t . In ( 1 ) && t . Out ( 0 ) == boolType { return true } case trbFunc : if ni == 2 && no == 1 && t . Out ( 0 ) == boolType { return true } case tibFunc : if ni == 2 && no == 1 && t . In ( 0 ) . AssignableTo ( t . In ( 1 ) ) && t . Out ( 0 ) == boolType { return true } case trFunc : if ni == 1 && no == 1 { return true } } return false }
3193	func NameOf ( v reflect . Value ) string { fnc := runtime . FuncForPC ( v . Pointer ( ) ) if fnc == nil { return "<unknown>" } fullName := fnc . Name ( ) fullName = strings . TrimSuffix ( fullName , "-fm" ) var name string for len ( fullName ) > 0 { inParen := strings . HasSuffix ( fullName , ")" ) fullName = strings . TrimSuffix ( fullName , ")" ) s := lastIdentRx . FindString ( fullName ) if s == "" { break } name = s + "." + name fullName = strings . TrimSuffix ( fullName , s ) if i := strings . LastIndexByte ( fullName , '(' ) ; inParen && i >= 0 { fullName = fullName [ : i ] } fullName = strings . TrimSuffix ( fullName , "." ) } return strings . TrimSuffix ( name , "." ) }
3194	func PointerOf ( v reflect . Value ) Pointer { return Pointer { unsafe . Pointer ( v . Pointer ( ) ) , v . Type ( ) } }
3195	func ( es EditScript ) String ( ) string { b := make ( [ ] byte , len ( es ) ) for i , e := range es { switch e { case Identity : b [ i ] = '.' case UniqueX : b [ i ] = 'X' case UniqueY : b [ i ] = 'Y' case Modified : b [ i ] = 'M' default : panic ( "invalid edit-type" ) } } return string ( b ) }
3196	func ( es EditScript ) stats ( ) ( s struct { NI , NX , NY , NM int } ) { for _ , e := range es { switch e { case Identity : s . NI ++ case UniqueX : s . NX ++ case UniqueY : s . NY ++ case Modified : s . NM ++ default : panic ( "invalid edit-type" ) } } return }
3197	func ( p * path ) connect ( dst point , f EqualFunc ) { if p . dir > 0 { for dst . X > p . X && dst . Y > p . Y { switch r := f ( p . X , p . Y ) ; { case r . Equal ( ) : p . append ( Identity ) case r . Similar ( ) : p . append ( Modified ) case dst . X - p . X >= dst . Y - p . Y : p . append ( UniqueX ) default : p . append ( UniqueY ) } } for dst . X > p . X { p . append ( UniqueX ) } for dst . Y > p . Y { p . append ( UniqueY ) } } else { for p . X > dst . X && p . Y > dst . Y { switch r := f ( p . X - 1 , p . Y - 1 ) ; { case r . Equal ( ) : p . append ( Identity ) case r . Similar ( ) : p . append ( Modified ) case p . Y - dst . Y >= p . X - dst . X : p . append ( UniqueY ) default : p . append ( UniqueX ) } } for p . X > dst . X { p . append ( UniqueX ) } for p . Y > dst . Y { p . append ( UniqueY ) } } }
3198	func EquateNaNs ( ) cmp . Option { return cmp . Options { cmp . FilterValues ( areNaNsF64s , cmp . Comparer ( equateAlways ) ) , cmp . FilterValues ( areNaNsF32s , cmp . Comparer ( equateAlways ) ) , } }
3199	func ( pa Path ) Index ( i int ) PathStep { if i < 0 { i = len ( pa ) + i } if i < 0 || i >= len ( pa ) { return pathStep { } } return pa [ i ] }
3200	func ( si SliceIndex ) Key ( ) int { if si . xkey != si . ykey { return - 1 } return si . xkey }
3201	func ( r * defaultReporter ) String ( ) string { assert ( r . root != nil && r . curr == nil ) if r . root . NumDiff == 0 { return "" } return formatOptions { } . FormatDiff ( r . root ) . String ( ) }
3202	func ( opts formatOptions ) FormatType ( t reflect . Type , s textNode ) textNode { switch opts . TypeMode { case autoType : switch t . Kind ( ) { case reflect . Struct , reflect . Slice , reflect . Array , reflect . Map : if s . Equal ( textNil ) { return s } default : return s } case elideType : return s } typeName := t . String ( ) if t . Name ( ) == "" { switch t . Kind ( ) { case reflect . Chan , reflect . Func , reflect . Ptr : typeName = "(" + typeName + ")" } typeName = strings . Replace ( typeName , "struct {" , "struct{" , - 1 ) typeName = strings . Replace ( typeName , "interface {" , "interface{" , - 1 ) } if s , ok := s . ( textWrap ) ; ok { hasParens := strings . HasPrefix ( s . Prefix , "(" ) && strings . HasSuffix ( s . Suffix , ")" ) hasBraces := strings . HasPrefix ( s . Prefix , "{" ) && strings . HasSuffix ( s . Suffix , "}" ) if hasParens || hasBraces { return textWrap { typeName , s , "" } } } return textWrap { typeName + "(" , s , ")" } }
3203	func formatMapKey ( v reflect . Value ) string { var opts formatOptions opts . TypeMode = elideType opts . AvoidStringer = true opts . ShallowPointers = true s := opts . FormatValue ( v , visitedPointers { } ) . String ( ) return strings . TrimSpace ( s ) }
3204	func formatString ( s string ) string { qs := strconv . Quote ( s ) if len ( qs ) == 1 + len ( s ) + 1 { return qs } rawInvalid := func ( r rune ) bool { return r == '`' || r == '\n' || ! ( unicode . IsPrint ( r ) || r == '\t' ) } if strings . IndexFunc ( s , rawInvalid ) < 0 { return "`" + s + "`" } return qs }
3205	func formatHex ( u uint64 ) string { var f string switch { case u <= 0xff : f = "0x%02x" case u <= 0xffff : f = "0x%04x" case u <= 0xffffff : f = "0x%06x" case u <= 0xffffffff : f = "0x%08x" case u <= 0xffffffffff : f = "0x%010x" case u <= 0xffffffffffff : f = "0x%012x" case u <= 0xffffffffffffff : f = "0x%014x" case u <= 0xffffffffffffffff : f = "0x%016x" } return fmt . Sprintf ( f , u ) }
3206	func formatPointer ( v reflect . Value ) string { p := v . Pointer ( ) if flags . Deterministic { p = 0xdeadf00f } return fmt . Sprintf ( "⟪0x%x⟫", p) , identifier ) }
3207	func ( m visitedPointers ) Visit ( v reflect . Value ) bool { p := value . PointerOf ( v ) _ , visited := m [ p ] m [ p ] = struct { } { } return visited }
3208	func retrieveUnexportedField ( v reflect . Value , f reflect . StructField ) reflect . Value { return reflect . NewAt ( f . Type , unsafe . Pointer ( v . UnsafeAddr ( ) + f . Offset ) ) . Elem ( ) }
3209	func ( ft * fieldTree ) insert ( cname [ ] string ) { if ft . sub == nil { ft . sub = make ( map [ string ] fieldTree ) } if len ( cname ) == 0 { ft . ok = true return } sub := ft . sub [ cname [ 0 ] ] sub . insert ( cname [ 1 : ] ) ft . sub [ cname [ 0 ] ] = sub }
3210	func ( ft fieldTree ) matchPrefix ( p cmp . Path ) bool { for _ , ps := range p { switch ps := ps . ( type ) { case cmp . StructField : ft = ft . sub [ ps . Name ( ) ] if ft . ok { return true } if len ( ft . sub ) == 0 { return false } case cmp . Indirect : default : return false } } return false }
3211	func canonicalName ( t reflect . Type , sel string ) ( [ ] string , error ) { var name string sel = strings . TrimPrefix ( sel , "." ) if sel == "" { return nil , fmt . Errorf ( "name must not be empty" ) } if i := strings . IndexByte ( sel , '.' ) ; i < 0 { name , sel = sel , "" } else { name , sel = sel [ : i ] , sel [ i : ] } if t . Kind ( ) == reflect . Ptr { t = t . Elem ( ) } if t . Kind ( ) != reflect . Struct { return nil , fmt . Errorf ( "%v must be a struct" , t ) } if ! isExported ( name ) { return [ ] string { name } , fmt . Errorf ( "name must be exported" ) } sf , ok := t . FieldByName ( name ) if ! ok { return [ ] string { name } , fmt . Errorf ( "does not exist" ) } var ss [ ] string for i := range sf . Index { ss = append ( ss , t . FieldByIndex ( sf . Index [ : i + 1 ] ) . Name ) } if sel == "" { return ss , nil } ssPost , err := canonicalName ( sf . Type , sel ) return append ( ss , ssPost ... ) , err }
3212	func FilterPath ( f func ( Path ) bool , opt Option ) Option { if f == nil { panic ( "invalid path filter function" ) } if opt := normalizeOption ( opt ) ; opt != nil { return & pathFilter { fnc : f , opt : opt } } return nil }
3213	func normalizeOption ( src Option ) Option { switch opts := flattenOptions ( nil , Options { src } ) ; len ( opts ) { case 0 : return nil case 1 : return opts [ 0 ] default : return opts } }
3214	func flattenOptions ( dst , src Options ) Options { for _ , opt := range src { switch opt := opt . ( type ) { case nil : continue case Options : dst = flattenOptions ( dst , opt ) case coreOption : dst = append ( dst , opt ) default : panic ( fmt . Sprintf ( "invalid option type: %T" , opt ) ) } } return dst }
3215	func ( opts formatOptions ) CanFormatDiffSlice ( v * valueNode ) bool { switch { case opts . DiffMode != diffUnknown : return false case v . NumDiff == 0 : return false case v . NumIgnored + v . NumCompared + v . NumTransformed > 0 : return false case ! v . ValueX . IsValid ( ) || ! v . ValueY . IsValid ( ) : return false } switch t := v . Type ; t . Kind ( ) { case reflect . String : case reflect . Array , reflect . Slice : switch t . Elem ( ) . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 , reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 , reflect . Uintptr , reflect . Bool , reflect . Float32 , reflect . Float64 , reflect . Complex64 , reflect . Complex128 : default : return false } if v . NumDiff > v . NumSame { return true } default : return false } const minLength = 64 return v . ValueX . Len ( ) >= minLength && v . ValueY . Len ( ) >= minLength }
3216	func formatASCII ( s string ) string { b := bytes . Repeat ( [ ] byte { '.' } , len ( s ) ) for i := 0 ; i < len ( s ) ; i ++ { if ' ' <= s [ i ] && s [ i ] <= '~' { b [ i ] = s [ i ] } } return string ( b ) }
3217	func coalesceAdjacentEdits ( name string , es diff . EditScript ) ( groups [ ] diffStats ) { var prevCase int lastStats := func ( i int ) * diffStats { if prevCase != i { groups = append ( groups , diffStats { Name : name } ) prevCase = i } return & groups [ len ( groups ) - 1 ] } for _ , e := range es { switch e { case diff . Identity : lastStats ( 1 ) . NumIdentical ++ case diff . UniqueX : lastStats ( 2 ) . NumRemoved ++ case diff . UniqueY : lastStats ( 2 ) . NumInserted ++ case diff . Modified : lastStats ( 2 ) . NumModified ++ } } return groups }
3218	func SortKeys ( vs [ ] reflect . Value ) [ ] reflect . Value { if len ( vs ) == 0 { return vs } sort . Slice ( vs , func ( i , j int ) bool { return isLess ( vs [ i ] , vs [ j ] ) } ) vs2 := vs [ : 1 ] for _ , v := range vs [ 1 : ] { if isLess ( vs2 [ len ( vs2 ) - 1 ] , v ) { vs2 = append ( vs2 , v ) } } return vs2 }
3219	func ( opts formatOptions ) FormatDiff ( v * valueNode ) textNode { if opts . CanFormatDiffSlice ( v ) { return opts . FormatDiffSlice ( v ) } if v . MaxDepth == 0 { switch opts . DiffMode { case diffUnknown , diffIdentical : if v . NumDiff == 0 { outx := opts . FormatValue ( v . ValueX , visitedPointers { } ) outy := opts . FormatValue ( v . ValueY , visitedPointers { } ) if v . NumIgnored > 0 && v . NumSame == 0 { return textEllipsis } else if outx . Len ( ) < outy . Len ( ) { return outx } else { return outy } } assert ( opts . DiffMode == diffUnknown ) var list textList outx := opts . WithTypeMode ( elideType ) . FormatValue ( v . ValueX , visitedPointers { } ) outy := opts . WithTypeMode ( elideType ) . FormatValue ( v . ValueY , visitedPointers { } ) if outx != nil { list = append ( list , textRecord { Diff : '-' , Value : outx } ) } if outy != nil { list = append ( list , textRecord { Diff : '+' , Value : outy } ) } return opts . WithTypeMode ( emitType ) . FormatType ( v . Type , list ) case diffRemoved : return opts . FormatValue ( v . ValueX , visitedPointers { } ) case diffInserted : return opts . FormatValue ( v . ValueY , visitedPointers { } ) default : panic ( "invalid diff mode" ) } } if v . TransformerName != "" { out := opts . WithTypeMode ( emitType ) . FormatDiff ( v . Value ) out = textWrap { "Inverse(" + v . TransformerName + ", " , out , ")" } return opts . FormatType ( v . Type , out ) } else { switch k := v . Type . Kind ( ) ; k { case reflect . Struct , reflect . Array , reflect . Slice , reflect . Map : return opts . FormatType ( v . Type , opts . formatDiffList ( v . Records , k ) ) case reflect . Ptr : return textWrap { "&" , opts . FormatDiff ( v . Value ) , "" } case reflect . Interface : return opts . WithTypeMode ( emitType ) . FormatDiff ( v . Value ) default : panic ( fmt . Sprintf ( "%v cannot have children" , k ) ) } } }
3220	func coalesceAdjacentRecords ( name string , recs [ ] reportRecord ) ( groups [ ] diffStats ) { var prevCase int lastStats := func ( i int ) * diffStats { if prevCase != i { groups = append ( groups , diffStats { Name : name } ) prevCase = i } return & groups [ len ( groups ) - 1 ] } for _ , r := range recs { switch rv := r . Value ; { case rv . NumIgnored > 0 && rv . NumSame + rv . NumDiff == 0 : lastStats ( 1 ) . NumIgnored ++ case rv . NumDiff == 0 : lastStats ( 1 ) . NumIdentical ++ case rv . NumDiff > 0 && ! rv . ValueY . IsValid ( ) : lastStats ( 2 ) . NumRemoved ++ case rv . NumDiff > 0 && ! rv . ValueX . IsValid ( ) : lastStats ( 2 ) . NumInserted ++ default : lastStats ( 2 ) . NumModified ++ } } return groups }
3221	func Diff ( x , y interface { } , opts ... Option ) string { r := new ( defaultReporter ) eq := Equal ( x , y , Options ( opts ) , Reporter ( r ) ) d := r . String ( ) if ( d == "" ) != eq { panic ( "inconsistent difference and equality results" ) } return d }
3222	func ( s * state ) statelessCompare ( step PathStep ) diff . Result { oldResult , oldReporters := s . result , s . reporters s . result = diff . Result { } s . reporters = nil s . compareAny ( step ) res := s . result s . result , s . reporters = oldResult , oldReporters return res }
3223	func sanitizeValue ( v reflect . Value , t reflect . Type ) reflect . Value { if ! flags . AtLeastGo110 { if v . Kind ( ) == reflect . Interface && v . IsNil ( ) && v . Type ( ) != t { return reflect . New ( t ) . Elem ( ) } } return v }
3224	func ( rc * recChecker ) Check ( p Path ) { const minLen = 1 << 16 if rc . next == 0 { rc . next = minLen } if len ( p ) < rc . next { return } rc . next <<= 1 var ss [ ] string m := map [ Option ] int { } for _ , ps := range p { if t , ok := ps . ( Transform ) ; ok { t := t . Option ( ) if m [ t ] == 1 { tf := t . ( * transformer ) . fnc . Type ( ) ss = append ( ss , fmt . Sprintf ( "%v: %v => %v" , t , tf . In ( 0 ) , tf . Out ( 0 ) ) ) } m [ t ] ++ } } if len ( ss ) > 0 { const warning = "recursive set of Transformers detected" const help = "consider using cmpopts.AcyclicTransformer" set := strings . Join ( ss , "\n\t" ) \n } }
3225	func makeAddressable ( v reflect . Value ) reflect . Value { if v . CanAddr ( ) { return v } vc := reflect . New ( v . Type ( ) ) . Elem ( ) vc . Set ( v ) return vc }
3226	func ( lf Field ) Marshal ( visitor Encoder ) { switch lf . fieldType { case stringType : visitor . EmitString ( lf . key , lf . stringVal ) case boolType : visitor . EmitBool ( lf . key , lf . numericVal != 0 ) case intType : visitor . EmitInt ( lf . key , int ( lf . numericVal ) ) case int32Type : visitor . EmitInt32 ( lf . key , int32 ( lf . numericVal ) ) case int64Type : visitor . EmitInt64 ( lf . key , int64 ( lf . numericVal ) ) case uint32Type : visitor . EmitUint32 ( lf . key , uint32 ( lf . numericVal ) ) case uint64Type : visitor . EmitUint64 ( lf . key , uint64 ( lf . numericVal ) ) case float32Type : visitor . EmitFloat32 ( lf . key , math . Float32frombits ( uint32 ( lf . numericVal ) ) ) case float64Type : visitor . EmitFloat64 ( lf . key , math . Float64frombits ( uint64 ( lf . numericVal ) ) ) case errorType : if err , ok := lf . interfaceVal . ( error ) ; ok { visitor . EmitString ( lf . key , err . Error ( ) ) } else { visitor . EmitString ( lf . key , "<nil>" ) } case objectType : visitor . EmitObject ( lf . key , lf . interfaceVal ) case lazyLoggerType : visitor . EmitLazyLogger ( lf . interfaceVal . ( LazyLogger ) ) case noopType : } }
3227	func ( lf Field ) String ( ) string { return fmt . Sprint ( lf . key , ":" , lf . Value ( ) ) }
3228	func ( t Tag ) Set ( s Span ) { s . SetTag ( t . Key , t . Value ) }
3229	func ( t * TextMapPropagator ) Inject ( spanContext MockSpanContext , carrier interface { } ) error { writer , ok := carrier . ( opentracing . TextMapWriter ) if ! ok { return opentracing . ErrInvalidCarrier } writer . Set ( mockTextMapIdsPrefix + "traceid" , strconv . Itoa ( spanContext . TraceID ) ) writer . Set ( mockTextMapIdsPrefix + "spanid" , strconv . Itoa ( spanContext . SpanID ) ) writer . Set ( mockTextMapIdsPrefix + "sampled" , fmt . Sprint ( spanContext . Sampled ) ) for baggageKey , baggageVal := range spanContext . Baggage { safeVal := baggageVal if t . HTTPHeaders { safeVal = url . QueryEscape ( baggageVal ) } writer . Set ( mockTextMapBaggagePrefix + baggageKey , safeVal ) } return nil }
3230	func ( t * TextMapPropagator ) Extract ( carrier interface { } ) ( MockSpanContext , error ) { reader , ok := carrier . ( opentracing . TextMapReader ) if ! ok { return emptyContext , opentracing . ErrInvalidCarrier } rval := MockSpanContext { 0 , 0 , true , nil } err := reader . ForeachKey ( func ( key , val string ) error { lowerKey := strings . ToLower ( key ) switch { case lowerKey == mockTextMapIdsPrefix + "traceid" : i , err := strconv . Atoi ( val ) if err != nil { return err } rval . TraceID = i case lowerKey == mockTextMapIdsPrefix + "spanid" : i , err := strconv . Atoi ( val ) if err != nil { return err } rval . SpanID = i case lowerKey == mockTextMapIdsPrefix + "sampled" : b , err := strconv . ParseBool ( val ) if err != nil { return err } rval . Sampled = b case strings . HasPrefix ( lowerKey , mockTextMapBaggagePrefix ) : if rval . Baggage == nil { rval . Baggage = make ( map [ string ] string ) } safeVal := val if t . HTTPHeaders { if rawVal , err := url . QueryUnescape ( val ) ; err == nil { safeVal = rawVal } } rval . Baggage [ lowerKey [ len ( mockTextMapBaggagePrefix ) : ] ] = safeVal } return nil } ) if rval . TraceID == 0 || rval . SpanID == 0 { return emptyContext , opentracing . ErrSpanContextNotFound } if err != nil { return emptyContext , err } return rval , nil }
3231	func ( ld * LogData ) ToLogRecord ( ) LogRecord { var literalTimestamp time . Time if ld . Timestamp . IsZero ( ) { literalTimestamp = time . Now ( ) } else { literalTimestamp = ld . Timestamp } rval := LogRecord { Timestamp : literalTimestamp , } if ld . Payload == nil { rval . Fields = [ ] log . Field { log . String ( "event" , ld . Event ) , } } else { rval . Fields = [ ] log . Field { log . String ( "event" , ld . Event ) , log . Object ( "payload" , ld . Payload ) , } } return rval }
3232	func New ( ) * MockTracer { t := & MockTracer { finishedSpans : [ ] * MockSpan { } , injectors : make ( map [ interface { } ] Injector ) , extractors : make ( map [ interface { } ] Extractor ) , } textPropagator := new ( TextMapPropagator ) t . RegisterInjector ( opentracing . TextMap , textPropagator ) t . RegisterExtractor ( opentracing . TextMap , textPropagator ) httpPropagator := & TextMapPropagator { HTTPHeaders : true } t . RegisterInjector ( opentracing . HTTPHeaders , httpPropagator ) t . RegisterExtractor ( opentracing . HTTPHeaders , httpPropagator ) return t }
3233	func ( t * MockTracer ) StartSpan ( operationName string , opts ... opentracing . StartSpanOption ) opentracing . Span { sso := opentracing . StartSpanOptions { } for _ , o := range opts { o . Apply ( & sso ) } return newMockSpan ( t , operationName , sso ) }
3234	func ( t * MockTracer ) RegisterInjector ( format interface { } , injector Injector ) { t . injectors [ format ] = injector }
3235	func ( t * MockTracer ) RegisterExtractor ( format interface { } , extractor Extractor ) { t . extractors [ format ] = extractor }
3236	func ( t * MockTracer ) Inject ( sm opentracing . SpanContext , format interface { } , carrier interface { } ) error { spanContext , ok := sm . ( MockSpanContext ) if ! ok { return opentracing . ErrInvalidCarrier } injector , ok := t . injectors [ format ] if ! ok { return opentracing . ErrUnsupportedFormat } return injector . Inject ( spanContext , carrier ) }
3237	func ( t * MockTracer ) Extract ( format interface { } , carrier interface { } ) ( opentracing . SpanContext , error ) { extractor , ok := t . extractors [ format ] if ! ok { return nil , opentracing . ErrUnsupportedFormat } return extractor . Extract ( carrier ) }
3238	func ContextWithSpan ( ctx context . Context , span Span ) context . Context { return context . WithValue ( ctx , activeSpanKey , span ) }
3239	func ( tag uint32TagName ) Set ( span opentracing . Span , value uint32 ) { span . SetTag ( string ( tag ) , value ) }
3240	func ( tag uint16TagName ) Set ( span opentracing . Span , value uint16 ) { span . SetTag ( string ( tag ) , value ) }
3241	func ( tag boolTagName ) Set ( span opentracing . Span , value bool ) { span . SetTag ( string ( tag ) , value ) }
3242	func ( tag ipv4Tag ) SetString ( span opentracing . Span , value string ) { span . SetTag ( string ( tag ) , value ) }
3243	func ( m * MockKeyValue ) EmitString ( key , value string ) { m . Key = key m . ValueKind = reflect . TypeOf ( value ) . Kind ( ) m . ValueString = fmt . Sprint ( value ) }
3244	func ( m * MockKeyValue ) EmitLazyLogger ( value log . LazyLogger ) { var meta MockKeyValue value ( & meta ) m . Key = meta . Key m . ValueKind = meta . ValueKind m . ValueString = meta . ValueString }
3245	func RunAPIChecks ( t * testing . T , newTracer func ( ) ( tracer opentracing . Tracer , closer func ( ) ) , opts ... APICheckOption , ) { s := & APICheckSuite { newTracer : newTracer } for _ , opt := range opts { opt ( s ) } suite . Run ( t , s ) }
3246	func CheckBaggageValues ( val bool ) APICheckOption { return func ( s * APICheckSuite ) { s . opts . CheckBaggageValues = val } }
3247	func CheckExtract ( val bool ) APICheckOption { return func ( s * APICheckSuite ) { s . opts . CheckExtract = val } }
3248	func CheckInject ( val bool ) APICheckOption { return func ( s * APICheckSuite ) { s . opts . CheckInject = val } }
3249	func CheckEverything ( ) APICheckOption { return func ( s * APICheckSuite ) { s . opts . CheckBaggageValues = true s . opts . CheckExtract = true s . opts . CheckInject = true } }
3250	func UseProbe ( probe APICheckProbe ) APICheckOption { return func ( s * APICheckSuite ) { s . opts . Probe = probe } }
3251	func ( c MockSpanContext ) WithBaggageItem ( key , value string ) MockSpanContext { var newBaggage map [ string ] string if c . Baggage == nil { newBaggage = map [ string ] string { key : value } } else { newBaggage = make ( map [ string ] string , len ( c . Baggage ) + 1 ) for k , v := range c . Baggage { newBaggage [ k ] = v } newBaggage [ key ] = value } return MockSpanContext { c . TraceID , c . SpanID , c . Sampled , newBaggage } }
3252	func ( s * MockSpan ) Tags ( ) map [ string ] interface { } { s . RLock ( ) defer s . RUnlock ( ) tags := make ( map [ string ] interface { } ) for k , v := range s . tags { tags [ k ] = v } return tags }
3253	func ( s * MockSpan ) Tag ( k string ) interface { } { s . RLock ( ) defer s . RUnlock ( ) return s . tags [ k ] }
3254	func ( s * MockSpan ) Logs ( ) [ ] MockLogRecord { s . RLock ( ) defer s . RUnlock ( ) logs := make ( [ ] MockLogRecord , len ( s . logs ) ) copy ( logs , s . logs ) return logs }
3255	func ( s * MockSpan ) Context ( ) opentracing . SpanContext { s . Lock ( ) defer s . Unlock ( ) return s . SpanContext }
3256	func ( s * MockSpan ) SetTag ( key string , value interface { } ) opentracing . Span { s . Lock ( ) defer s . Unlock ( ) if key == string ( ext . SamplingPriority ) { if v , ok := value . ( uint16 ) ; ok { s . SpanContext . Sampled = v > 0 return s } if v , ok := value . ( int ) ; ok { s . SpanContext . Sampled = v > 0 return s } } s . tags [ key ] = value return s }
3257	func ( s * MockSpan ) SetBaggageItem ( key , val string ) opentracing . Span { s . Lock ( ) defer s . Unlock ( ) s . SpanContext = s . SpanContext . WithBaggageItem ( key , val ) return s }
3258	func ( s * MockSpan ) BaggageItem ( key string ) string { s . RLock ( ) defer s . RUnlock ( ) return s . SpanContext . Baggage [ key ] }
3259	func ( s * MockSpan ) Finish ( ) { s . Lock ( ) s . FinishTime = time . Now ( ) s . Unlock ( ) s . tracer . recordSpan ( s ) }
3260	func ( s * MockSpan ) FinishWithOptions ( opts opentracing . FinishOptions ) { s . Lock ( ) s . FinishTime = opts . FinishTime s . Unlock ( ) for _ , lr := range opts . LogRecords { s . logFieldsWithTimestamp ( lr . Timestamp , lr . Fields ... ) } for _ , ld := range opts . BulkLogData { if ld . Payload != nil { s . logFieldsWithTimestamp ( ld . Timestamp , log . String ( "event" , ld . Event ) , log . Object ( "payload" , ld . Payload ) ) } else { s . logFieldsWithTimestamp ( ld . Timestamp , log . String ( "event" , ld . Event ) ) } } s . tracer . recordSpan ( s ) }
3261	func ( s * MockSpan ) String ( ) string { return fmt . Sprintf ( "traceId=%d, spanId=%d, parentId=%d, sampled=%t, name=%s" , s . SpanContext . TraceID , s . SpanContext . SpanID , s . ParentID , s . SpanContext . Sampled , s . OperationName ) }
3262	func ( s * MockSpan ) LogFields ( fields ... log . Field ) { s . logFieldsWithTimestamp ( time . Now ( ) , fields ... ) }
3263	func ( s * MockSpan ) logFieldsWithTimestamp ( ts time . Time , fields ... log . Field ) { lr := MockLogRecord { Timestamp : ts , Fields : make ( [ ] MockKeyValue , len ( fields ) ) , } for i , f := range fields { outField := & ( lr . Fields [ i ] ) f . Marshal ( outField ) } s . Lock ( ) defer s . Unlock ( ) s . logs = append ( s . logs , lr ) }
3264	func ( s * MockSpan ) LogKV ( keyValues ... interface { } ) { if len ( keyValues ) % 2 != 0 { s . LogFields ( log . Error ( fmt . Errorf ( "Non-even keyValues len: %v" , len ( keyValues ) ) ) ) return } fields , err := log . InterleavedKVToFields ( keyValues ... ) if err != nil { s . LogFields ( log . Error ( err ) , log . String ( "function" , "LogKV" ) ) return } s . LogFields ( fields ... ) }
3265	func ( s * MockSpan ) LogEvent ( event string ) { s . LogFields ( log . String ( "event" , event ) ) }
3266	func ( s * MockSpan ) LogEventWithPayload ( event string , payload interface { } ) { s . LogFields ( log . String ( "event" , event ) , log . Object ( "payload" , payload ) ) }
3267	func ( s * MockSpan ) SetOperationName ( operationName string ) opentracing . Span { s . Lock ( ) defer s . Unlock ( ) s . OperationName = operationName return s }
3268	func registriesDirPath ( sys * types . SystemContext ) string { if sys != nil { if sys . RegistriesDirPath != "" { return sys . RegistriesDirPath } if sys . RootForImplicitAbsolutePaths != "" { return filepath . Join ( sys . RootForImplicitAbsolutePaths , systemRegistriesDirPath ) } } return systemRegistriesDirPath }
3269	func loadAndMergeConfig ( dirPath string ) ( * registryConfiguration , error ) { mergedConfig := registryConfiguration { Docker : map [ string ] registryNamespace { } } dockerDefaultMergedFrom := "" nsMergedFrom := map [ string ] string { } dir , err := os . Open ( dirPath ) if err != nil { if os . IsNotExist ( err ) { return & mergedConfig , nil } return nil , err } configNames , err := dir . Readdirnames ( 0 ) if err != nil { return nil , err } for _ , configName := range configNames { if ! strings . HasSuffix ( configName , ".yaml" ) { continue } configPath := filepath . Join ( dirPath , configName ) configBytes , err := ioutil . ReadFile ( configPath ) if err != nil { return nil , err } var config registryConfiguration err = yaml . Unmarshal ( configBytes , & config ) if err != nil { return nil , errors . Wrapf ( err , "Error parsing %s" , configPath ) } if config . DefaultDocker != nil { if mergedConfig . DefaultDocker != nil { return nil , errors . Errorf ( `Error parsing signature storage configuration: "default-docker" defined both in "%s" and "%s"` , dockerDefaultMergedFrom , configPath ) } mergedConfig . DefaultDocker = config . DefaultDocker dockerDefaultMergedFrom = configPath } for nsName , nsConfig := range config . Docker { if _ , ok := mergedConfig . Docker [ nsName ] ; ok { return nil , errors . Errorf ( `Error parsing signature storage configuration: "docker" namespace "%s" defined both in "%s" and "%s"` , nsName , nsMergedFrom [ nsName ] , configPath ) } mergedConfig . Docker [ nsName ] = nsConfig nsMergedFrom [ nsName ] = configPath } } return & mergedConfig , nil }
3270	func ParseReference ( ref string ) ( types . ImageReference , error ) { r , err := reference . ParseNormalizedNamed ( ref ) if err != nil { return nil , errors . Wrapf ( err , "failed to parse image reference %q" , ref ) } tagged , ok := r . ( reference . NamedTagged ) if ! ok { return nil , errors . Errorf ( "invalid image reference %s, expected format: 'hostname/namespace/stream:tag'" , ref ) } return NewReference ( tagged ) }
3271	func NewReference ( dockerRef reference . NamedTagged ) ( types . ImageReference , error ) { r := strings . SplitN ( reference . Path ( dockerRef ) , "/" , 3 ) if len ( r ) != 2 { return nil , errors . Errorf ( "invalid image reference: %s, expected format: 'hostname/namespace/stream:tag'" , reference . FamiliarString ( dockerRef ) ) } return openshiftReference { namespace : r [ 0 ] , stream : r [ 1 ] , dockerReference : dockerRef , } , nil }
3272	func CheckAuth ( ctx context . Context , sys * types . SystemContext , username , password , registry string ) error { client , err := newDockerClient ( sys , registry , registry ) if err != nil { return errors . Wrapf ( err , "error creating new docker client" ) } client . username = username client . password = password resp , err := client . makeRequest ( ctx , "GET" , "/v2/" , nil , nil , v2Auth , nil ) if err != nil { return err } defer resp . Body . Close ( ) switch resp . StatusCode { case http . StatusOK : return nil case http . StatusUnauthorized : return ErrUnauthorizedForCredentials default : return errors . Errorf ( "error occured with status code %d (%s)" , resp . StatusCode , http . StatusText ( resp . StatusCode ) ) } }
3273	func ( c * dockerClient ) doHTTP ( req * http . Request ) ( * http . Response , error ) { tr := tlsclientconfig . NewTransport ( ) tr . TLSClientConfig = c . tlsClientConfig httpClient := & http . Client { Transport : tr } return httpClient . Do ( req ) }
3274	func ( c * dockerClient ) detectPropertiesHelper ( ctx context . Context ) error { if c . scheme != "" { return nil } if c . sys != nil && c . sys . DockerInsecureSkipTLSVerify != types . OptionalBoolUndefined { c . tlsClientConfig . InsecureSkipVerify = c . sys . DockerInsecureSkipTLSVerify == types . OptionalBoolTrue } ping := func ( scheme string ) error { url := fmt . Sprintf ( resolvedPingV2URL , scheme , c . registry ) resp , err := c . makeRequestToResolvedURL ( ctx , "GET" , url , nil , nil , - 1 , noAuth , nil ) if err != nil { logrus . Debugf ( "Ping %s err %s (%#v)" , url , err . Error ( ) , err ) return err } defer resp . Body . Close ( ) logrus . Debugf ( "Ping %s status %d" , url , resp . StatusCode ) if resp . StatusCode != http . StatusOK && resp . StatusCode != http . StatusUnauthorized { return errors . Errorf ( "error pinging registry %s, response code %d (%s)" , c . registry , resp . StatusCode , http . StatusText ( resp . StatusCode ) ) } c . challenges = parseAuthHeader ( resp . Header ) c . scheme = scheme c . supportsSignatures = resp . Header . Get ( "X-Registry-Supports-Signatures" ) == "1" return nil } err := ping ( "https" ) if err != nil && c . tlsClientConfig . InsecureSkipVerify { err = ping ( "http" ) } if err != nil { err = errors . Wrap ( err , "pinging docker registry returned" ) if c . sys != nil && c . sys . DockerDisableV1Ping { return err } pingV1 := func ( scheme string ) bool { url := fmt . Sprintf ( resolvedPingV1URL , scheme , c . registry ) resp , err := c . makeRequestToResolvedURL ( ctx , "GET" , url , nil , nil , - 1 , noAuth , nil ) if err != nil { logrus . Debugf ( "Ping %s err %s (%#v)" , url , err . Error ( ) , err ) return false } defer resp . Body . Close ( ) logrus . Debugf ( "Ping %s status %d" , url , resp . StatusCode ) if resp . StatusCode != http . StatusOK && resp . StatusCode != http . StatusUnauthorized { return false } return true } isV1 := pingV1 ( "https" ) if ! isV1 && c . tlsClientConfig . InsecureSkipVerify { isV1 = pingV1 ( "http" ) } if isV1 { err = ErrV1NotSupported } } return err }
3275	func ( c * dockerClient ) detectProperties ( ctx context . Context ) error { c . detectPropertiesOnce . Do ( func ( ) { c . detectPropertiesError = c . detectPropertiesHelper ( ctx ) } ) return c . detectPropertiesError }
3276	func ( c * dockerClient ) getExtensionsSignatures ( ctx context . Context , ref dockerReference , manifestDigest digest . Digest ) ( * extensionSignatureList , error ) { path := fmt . Sprintf ( extensionsSignaturePath , reference . Path ( ref . ref ) , manifestDigest ) res , err := c . makeRequest ( ctx , "GET" , path , nil , nil , v2Auth , nil ) if err != nil { return nil , err } defer res . Body . Close ( ) if res . StatusCode != http . StatusOK { return nil , errors . Wrapf ( client . HandleErrorResponse ( res ) , "Error downloading signatures for %s in %s" , manifestDigest , ref . ref . Name ( ) ) } body , err := ioutil . ReadAll ( res . Body ) if err != nil { return nil , err } var parsedBody extensionSignatureList if err := json . Unmarshal ( body , & parsedBody ) ; err != nil { return nil , errors . Wrapf ( err , "Error decoding signature list" ) } return & parsedBody , nil }
3277	func NewTransport ( ) * http . Transport { direct := & net . Dialer { Timeout : 30 * time . Second , KeepAlive : 30 * time . Second , DualStack : true , } tr := & http . Transport { Proxy : http . ProxyFromEnvironment , Dial : direct . Dial , TLSHandshakeTimeout : 10 * time . Second , DisableKeepAlives : true , } proxyDialer , err := sockets . DialerFromEnvironment ( direct ) if err == nil { tr . Dial = proxyDialer . Dial } return tr }
3278	func readRegistryConf ( sys * types . SystemContext ) ( [ ] byte , error ) { return ioutil . ReadFile ( RegistriesConfPath ( sys ) ) }
3279	func GetRegistries ( sys * types . SystemContext ) ( [ ] string , error ) { config , err := loadRegistryConf ( sys ) if err != nil { return nil , err } return config . Registries . Search . Registries , nil }
3280	func GetInsecureRegistries ( sys * types . SystemContext ) ( [ ] string , error ) { config , err := loadRegistryConf ( sys ) if err != nil { return nil , err } return config . Registries . Insecure . Registries , nil }
3281	func RegistriesConfPath ( ctx * types . SystemContext ) string { path := systemRegistriesConfPath if ctx != nil { if ctx . SystemRegistriesConfPath != "" { path = ctx . SystemRegistriesConfPath } else if ctx . RootForImplicitAbsolutePaths != "" { path = filepath . Join ( ctx . RootForImplicitAbsolutePaths , systemRegistriesConfPath ) } } return path }
3282	func NewOptionalBool ( b bool ) OptionalBool { o := OptionalBoolFalse if b == true { o = OptionalBoolTrue } return o }
3283	func ( pc * PolicyContext ) changeState ( expected , new policyContextState ) error { if pc . state != expected { return errors . Errorf ( `"Invalid PolicyContext state, expected "%s", found "%s"` , expected , pc . state ) } pc . state = new return nil }
3284	func ( pc * PolicyContext ) Destroy ( ) error { if err := pc . changeState ( pcReady , pcDestroying ) ; err != nil { return err } return pc . changeState ( pcDestroying , pcDestroyed ) }
3285	func policyIdentityLogName ( ref types . ImageReference ) string { return ref . Transport ( ) . Name ( ) + ":" + ref . PolicyConfigurationIdentity ( ) }
3286	func ( pc * PolicyContext ) requirementsForImageRef ( ref types . ImageReference ) PolicyRequirements { transportName := ref . Transport ( ) . Name ( ) if transportScopes , ok := pc . Policy . Transports [ transportName ] ; ok { identity := ref . PolicyConfigurationIdentity ( ) if req , ok := transportScopes [ identity ] ; ok { logrus . Debugf ( ` Using transport "%s" policy section %s` , transportName , identity ) return req } for _ , name := range ref . PolicyConfigurationNamespaces ( ) { if req , ok := transportScopes [ name ] ; ok { logrus . Debugf ( ` Using transport "%s" specific policy section %s` , transportName , name ) return req } } if req , ok := transportScopes [ "" ] ; ok { logrus . Debugf ( ` Using transport "%s" policy section ""` , transportName ) return req } } logrus . Debugf ( " Using default policy section" ) return pc . Policy . Default }
3287	func ParseImageName ( imgName string ) ( types . ImageReference , error ) { parts := strings . SplitN ( imgName , ":" , 2 ) if len ( parts ) != 2 { return nil , errors . Errorf ( `Invalid image name "%s", expected colon-separated transport:reference` , imgName ) } transport := transports . Get ( parts [ 0 ] ) if transport == nil { return nil , errors . Errorf ( `Invalid image name "%s", unknown transport "%s"` , imgName , parts [ 0 ] ) } return transport . ParseReference ( parts [ 1 ] ) }
3288	func BlobInfoFromOCI1Descriptor ( desc imgspecv1 . Descriptor ) types . BlobInfo { return types . BlobInfo { Digest : desc . Digest , Size : desc . Size , URLs : desc . URLs , Annotations : desc . Annotations , MediaType : desc . MediaType , } }
3289	func OCI1FromManifest ( manifest [ ] byte ) ( * OCI1 , error ) { oci1 := OCI1 { } if err := json . Unmarshal ( manifest , & oci1 ) ; err != nil { return nil , err } return & oci1 , nil }
3290	func OCI1FromComponents ( config imgspecv1 . Descriptor , layers [ ] imgspecv1 . Descriptor ) * OCI1 { return & OCI1 { imgspecv1 . Manifest { Versioned : specs . Versioned { SchemaVersion : 2 } , Config : config , Layers : layers , } , } }
3291	func newReference ( ref reference . Named ) ( dockerReference , error ) { if reference . IsNameOnly ( ref ) { return dockerReference { } , errors . Errorf ( "Docker reference %s has neither a tag nor a digest" , reference . FamiliarString ( ref ) ) } _ , isTagged := ref . ( reference . NamedTagged ) _ , isDigested := ref . ( reference . Canonical ) if isTagged && isDigested { return dockerReference { } , errors . Errorf ( "Docker references with both a tag and digest are currently not supported" ) } return dockerReference { ref : ref , } , nil }
3292	func ( ref dockerReference ) tagOrDigest ( ) ( string , error ) { if ref , ok := ref . ref . ( reference . Canonical ) ; ok { return ref . Digest ( ) . String ( ) , nil } if ref , ok := ref . ref . ( reference . NamedTagged ) ; ok { return ref . Tag ( ) , nil } return "" , errors . Errorf ( "Internal inconsistency: Reference %s unexpectedly has neither a digest nor a tag" , reference . FamiliarString ( ref . ref ) ) }
3293	func ( ic * imageCopier ) updateEmbeddedDockerReference ( ) error { if ic . c . dest . IgnoresEmbeddedDockerReference ( ) { return nil } destRef := ic . c . dest . Reference ( ) . DockerReference ( ) if destRef == nil { return nil } if ! ic . src . EmbeddedDockerReferenceConflicts ( destRef ) { return nil } if ! ic . canModifyManifest { return errors . Errorf ( "Copying a schema1 image with an embedded Docker reference to %s (Docker reference %s) would invalidate existing signatures. Explicitly enable signature removal to proceed anyway" , transports . ImageName ( ic . c . dest . Reference ( ) ) , destRef . String ( ) ) } ic . manifestUpdates . EmbeddedDockerReference = destRef return nil }
3294	func isTTY ( w io . Writer ) bool { if f , ok := w . ( * os . File ) ; ok { return terminal . IsTerminal ( int ( f . Fd ( ) ) ) } return false }
3295	func ( ic * imageCopier ) copyUpdatedConfigAndManifest ( ctx context . Context ) ( [ ] byte , error ) { pendingImage := ic . src if ! reflect . DeepEqual ( * ic . manifestUpdates , types . ManifestUpdateOptions { InformationOnly : ic . manifestUpdates . InformationOnly } ) { if ! ic . canModifyManifest { return nil , errors . Errorf ( "Internal error: copy needs an updated manifest but that was known to be forbidden" ) } if ! ic . diffIDsAreNeeded && ic . src . UpdatedImageNeedsLayerDiffIDs ( * ic . manifestUpdates ) { return nil , errors . Errorf ( "Can not convert image to %s, preparing DiffIDs for this case is not supported" , ic . manifestUpdates . ManifestMIMEType ) } pi , err := ic . src . UpdatedImage ( ctx , * ic . manifestUpdates ) if err != nil { return nil , errors . Wrap ( err , "Error creating an updated image manifest" ) } pendingImage = pi } manifest , _ , err := pendingImage . Manifest ( ctx ) if err != nil { return nil , errors . Wrap ( err , "Error reading manifest" ) } if err := ic . c . copyConfig ( ctx , pendingImage ) ; err != nil { return nil , err } ic . c . Printf ( "Writing manifest to image destination\n" ) \n if err := ic . c . dest . PutManifest ( ctx , manifest ) ; err != nil { return nil , errors . Wrap ( err , "Error writing manifest" ) } }
3296	func ( c * copier ) createProgressBar ( pool * mpb . Progress , info types . BlobInfo , kind string , onComplete string ) * mpb . Bar { const shortDigestLen = 12 prefix := fmt . Sprintf ( "Copying %s %s" , kind , info . Digest . Encoded ( ) ) maxPrefixLen := len ( "Copying blob " ) + shortDigestLen if len ( prefix ) > maxPrefixLen { prefix = prefix [ : maxPrefixLen ] } bar := pool . AddBar ( info . Size , mpb . BarClearOnComplete ( ) , mpb . PrependDecorators ( decor . Name ( prefix ) , ) , mpb . AppendDecorators ( decor . OnComplete ( decor . CountersKibiByte ( "%.1f / %.1f" ) , " " + onComplete ) , ) , ) if c . progressOutput == ioutil . Discard { c . Printf ( "Copying %s %s\n" , \n , kind ) } info . Digest }
3297	func ( c * copier ) copyConfig ( ctx context . Context , src types . Image ) error { srcInfo := src . ConfigInfo ( ) if srcInfo . Digest != "" { configBlob , err := src . ConfigBlob ( ctx ) if err != nil { return errors . Wrapf ( err , "Error reading config blob %s" , srcInfo . Digest ) } destInfo , err := func ( ) ( types . BlobInfo , error ) { progressPool , progressCleanup := c . newProgressPool ( ctx ) defer progressCleanup ( ) bar := c . createProgressBar ( progressPool , srcInfo , "config" , "done" ) destInfo , err := c . copyBlobFromStream ( ctx , bytes . NewReader ( configBlob ) , srcInfo , nil , false , true , bar ) if err != nil { return types . BlobInfo { } , err } bar . SetTotal ( int64 ( len ( configBlob ) ) , true ) return destInfo , nil } ( ) if err != nil { return nil } if destInfo . Digest != srcInfo . Digest { return errors . Errorf ( "Internal error: copying uncompressed config blob %s changed digest to %s" , srcInfo . Digest , destInfo . Digest ) } } return nil }
3298	func diffIDComputationGoroutine ( dest chan <- diffIDResult , layerStream io . ReadCloser , decompressor compression . DecompressorFunc ) { result := diffIDResult { digest : "" , err : errors . New ( "Internal error: unexpected panic in diffIDComputationGoroutine" ) , } defer func ( ) { dest <- result } ( ) defer layerStream . Close ( ) result . digest , result . err = computeDiffID ( layerStream , decompressor ) }
3299	func computeDiffID ( stream io . Reader , decompressor compression . DecompressorFunc ) ( digest . Digest , error ) { if decompressor != nil { s , err := decompressor ( stream ) if err != nil { return "" , err } defer s . Close ( ) stream = s } return digest . Canonical . FromReader ( stream ) }
3300	func compressGoroutine ( dest * io . PipeWriter , src io . Reader ) { err := errors . New ( "Internal error: unexpected panic in compressGoroutine" ) defer func ( ) { dest . CloseWithError ( err ) } ( ) zipper := pgzip . NewWriter ( dest ) defer zipper . Close ( ) _ , err = io . Copy ( zipper , src ) }
3301	func newDockerClient ( sys * types . SystemContext ) ( * dockerclient . Client , error ) { host := dockerclient . DefaultDockerHost if sys != nil && sys . DockerDaemonHost != "" { host = sys . DockerDaemonHost } url , err := dockerclient . ParseHostURL ( host ) if err != nil { return nil , err } var httpClient * http . Client if url . Scheme != "unix" { if url . Scheme == "http" { httpClient = httpConfig ( ) } else { hc , err := tlsConfig ( sys ) if err != nil { return nil , err } httpClient = hc } } return dockerclient . NewClient ( host , defaultAPIVersion , httpClient , nil ) }
3302	func defaultPolicyPath ( sys * types . SystemContext ) string { if sys != nil { if sys . SignaturePolicyPath != "" { return sys . SignaturePolicyPath } if sys . RootForImplicitAbsolutePaths != "" { return filepath . Join ( sys . RootForImplicitAbsolutePaths , systemDefaultPolicyPath ) } } return systemDefaultPolicyPath }
3303	func NewPolicyFromFile ( fileName string ) ( * Policy , error ) { contents , err := ioutil . ReadFile ( fileName ) if err != nil { return nil , err } policy , err := NewPolicyFromBytes ( contents ) if err != nil { return nil , errors . Wrapf ( err , "invalid policy in %q" , fileName ) } return policy , nil }
3304	func NewPolicyFromBytes ( data [ ] byte ) ( * Policy , error ) { p := Policy { } if err := json . Unmarshal ( data , & p ) ; err != nil { return nil , InvalidPolicyFormatError ( err . Error ( ) ) } return & p , nil }
3305	func newPolicyRequirementFromJSON ( data [ ] byte ) ( PolicyRequirement , error ) { var typeField prCommon if err := json . Unmarshal ( data , & typeField ) ; err != nil { return nil , err } var res PolicyRequirement switch typeField . Type { case prTypeInsecureAcceptAnything : res = & prInsecureAcceptAnything { } case prTypeReject : res = & prReject { } case prTypeSignedBy : res = & prSignedBy { } case prTypeSignedBaseLayer : res = & prSignedBaseLayer { } default : return nil , InvalidPolicyFormatError ( fmt . Sprintf ( "Unknown policy requirement type \"%s\"" , \" ) ) } \" typeField . Type }
3306	func newPRSignedBy ( keyType sbKeyType , keyPath string , keyData [ ] byte , signedIdentity PolicyReferenceMatch ) ( * prSignedBy , error ) { if ! keyType . IsValid ( ) { return nil , InvalidPolicyFormatError ( fmt . Sprintf ( "invalid keyType \"%s\"" , \" ) ) } \" keyType if len ( keyPath ) > 0 && len ( keyData ) > 0 { return nil , InvalidPolicyFormatError ( "keyType and keyData cannot be used simultaneously" ) } }
3307	func newPRSignedByKeyPath ( keyType sbKeyType , keyPath string , signedIdentity PolicyReferenceMatch ) ( * prSignedBy , error ) { return newPRSignedBy ( keyType , keyPath , nil , signedIdentity ) }
3308	func NewPRSignedByKeyPath ( keyType sbKeyType , keyPath string , signedIdentity PolicyReferenceMatch ) ( PolicyRequirement , error ) { return newPRSignedByKeyPath ( keyType , keyPath , signedIdentity ) }
3309	func newPRSignedByKeyData ( keyType sbKeyType , keyData [ ] byte , signedIdentity PolicyReferenceMatch ) ( * prSignedBy , error ) { return newPRSignedBy ( keyType , "" , keyData , signedIdentity ) }
3310	func NewPRSignedByKeyData ( keyType sbKeyType , keyData [ ] byte , signedIdentity PolicyReferenceMatch ) ( PolicyRequirement , error ) { return newPRSignedByKeyData ( keyType , keyData , signedIdentity ) }
3311	func ( kt sbKeyType ) IsValid ( ) bool { switch kt { case SBKeyTypeGPGKeys , SBKeyTypeSignedByGPGKeys , SBKeyTypeX509Certificates , SBKeyTypeSignedByX509CAs : return true default : return false } }
3312	func newPRSignedBaseLayer ( baseLayerIdentity PolicyReferenceMatch ) ( * prSignedBaseLayer , error ) { if baseLayerIdentity == nil { return nil , InvalidPolicyFormatError ( "baseLayerIdentity not specified" ) } return & prSignedBaseLayer { prCommon : prCommon { Type : prTypeSignedBaseLayer } , BaseLayerIdentity : baseLayerIdentity , } , nil }
3313	func newPolicyReferenceMatchFromJSON ( data [ ] byte ) ( PolicyReferenceMatch , error ) { var typeField prmCommon if err := json . Unmarshal ( data , & typeField ) ; err != nil { return nil , err } var res PolicyReferenceMatch switch typeField . Type { case prmTypeMatchExact : res = & prmMatchExact { } case prmTypeMatchRepoDigestOrExact : res = & prmMatchRepoDigestOrExact { } case prmTypeMatchRepository : res = & prmMatchRepository { } case prmTypeExactReference : res = & prmExactReference { } case prmTypeExactRepository : res = & prmExactRepository { } default : return nil , InvalidPolicyFormatError ( fmt . Sprintf ( "Unknown policy reference match type \"%s\"" , \" ) ) } \" typeField . Type }
3314	func newPRMExactReference ( dockerReference string ) ( * prmExactReference , error ) { ref , err := reference . ParseNormalizedNamed ( dockerReference ) if err != nil { return nil , InvalidPolicyFormatError ( fmt . Sprintf ( "Invalid format of dockerReference %s: %s" , dockerReference , err . Error ( ) ) ) } if reference . IsNameOnly ( ref ) { return nil , InvalidPolicyFormatError ( fmt . Sprintf ( "dockerReference %s contains neither a tag nor digest" , dockerReference ) ) } return & prmExactReference { prmCommon : prmCommon { Type : prmTypeExactReference } , DockerReference : dockerReference , } , nil }
3315	func newPRMExactRepository ( dockerRepository string ) ( * prmExactRepository , error ) { if _ , err := reference . ParseNormalizedNamed ( dockerRepository ) ; err != nil { return nil , InvalidPolicyFormatError ( fmt . Sprintf ( "Invalid format of dockerRepository %s: %s" , dockerRepository , err . Error ( ) ) ) } return & prmExactRepository { prmCommon : prmCommon { Type : prmTypeExactRepository } , DockerRepository : dockerRepository , } , nil }
3316	func newImageSource ( imageRef storageReference ) ( * storageImageSource , error ) { img , err := imageRef . resolveImage ( ) if err != nil { return nil , err } image := & storageImageSource { imageRef : imageRef , image : img , layerPosition : make ( map [ digest . Digest ] int ) , SignatureSizes : [ ] int { } , } if img . Metadata != "" { if err := json . Unmarshal ( [ ] byte ( img . Metadata ) , image ) ; err != nil { return nil , errors . Wrap ( err , "error decoding metadata for source image" ) } } return image , nil }
3317	func ( s * storageImageSource ) getBlobAndLayerID ( info types . BlobInfo ) ( rc io . ReadCloser , n int64 , layerID string , err error ) { var layer storage . Layer var diffOptions * storage . DiffOptions err = info . Digest . Validate ( ) if err != nil { return nil , - 1 , "" , err } layers , err := s . imageRef . transport . store . LayersByUncompressedDigest ( info . Digest ) if len ( layers ) == 0 { b , err := s . imageRef . transport . store . ImageBigData ( s . image . ID , info . Digest . String ( ) ) if err != nil { return nil , - 1 , "" , err } r := bytes . NewReader ( b ) logrus . Debugf ( "exporting opaque data as blob %q" , info . Digest . String ( ) ) return ioutil . NopCloser ( r ) , int64 ( r . Len ( ) ) , "" , nil } s . getBlobMutex . Lock ( ) i := s . layerPosition [ info . Digest ] s . layerPosition [ info . Digest ] = i + 1 s . getBlobMutex . Unlock ( ) if len ( layers ) > 0 { layer = layers [ i % len ( layers ) ] } noCompression := archive . Uncompressed diffOptions = & storage . DiffOptions { Compression : & noCompression , } if layer . UncompressedSize < 0 { n = - 1 } else { n = layer . UncompressedSize } logrus . Debugf ( "exporting filesystem layer %q without compression for blob %q" , layer . ID , info . Digest ) rc , err = s . imageRef . transport . store . Diff ( "" , layer . ID , diffOptions ) if err != nil { return nil , - 1 , "" , err } return rc , n , layer . ID , err }
3318	func ( s * storageImageDestination ) computeID ( m manifest . Manifest ) string { var diffIDs [ ] digest . Digest switch m := m . ( type ) { case * manifest . Schema1 : for i , compat := range m . ExtractedV1Compatibility { if compat . ThrowAway { continue } blobSum := m . FSLayers [ i ] . BlobSum diffID , ok := s . blobDiffIDs [ blobSum ] if ! ok { logrus . Infof ( "error looking up diffID for layer %q" , blobSum . String ( ) ) return "" } diffIDs = append ( [ ] digest . Digest { diffID } , diffIDs ... ) } case * manifest . Schema2 , * manifest . OCI1 : default : return "" } id , err := m . ImageID ( diffIDs ) if err != nil { return "" } return id }
3319	func ( s * storageImageDestination ) PutManifest ( ctx context . Context , manifestBlob [ ] byte ) error { if s . imageRef . named != nil { if digested , ok := s . imageRef . named . ( reference . Digested ) ; ok { matches , err := manifest . MatchesDigest ( manifestBlob , digested . Digest ( ) ) if err != nil { return err } if ! matches { return fmt . Errorf ( "Manifest does not match expected digest %s" , digested . Digest ( ) ) } } } s . manifest = make ( [ ] byte , len ( manifestBlob ) ) copy ( s . manifest , manifestBlob ) return nil }
3320	func ( s * storageImageDestination ) PutSignatures ( ctx context . Context , signatures [ ] [ ] byte ) error { sizes := [ ] int { } sigblob := [ ] byte { } for _ , sig := range signatures { sizes = append ( sizes , len ( sig ) ) newblob := make ( [ ] byte , len ( sigblob ) + len ( sig ) ) copy ( newblob , sigblob ) copy ( newblob [ len ( sigblob ) : ] , sig ) sigblob = newblob } s . signatures = sigblob s . SignatureSizes = sizes return nil }
3321	func newImage ( ctx context . Context , sys * types . SystemContext , s storageReference ) ( types . ImageCloser , error ) { src , err := newImageSource ( s ) if err != nil { return nil , err } img , err := image . FromSource ( ctx , sys , src ) if err != nil { return nil , err } size , err := src . getSize ( ) if err != nil { return nil , err } return & storageImageCloser { ImageCloser : img , size : size } , nil }
3322	func newImageSource ( ctx context . Context , sys * types . SystemContext , ref ociArchiveReference ) ( types . ImageSource , error ) { tempDirRef , err := createUntarTempDir ( ref ) if err != nil { return nil , errors . Wrap ( err , "error creating temp directory" ) } unpackedSrc , err := tempDirRef . ociRefExtracted . NewImageSource ( ctx , sys ) if err != nil { if err := tempDirRef . deleteTempDir ( ) ; err != nil { return nil , errors . Wrapf ( err , "error deleting temp directory %q" , tempDirRef . tempDirectory ) } return nil , err } return & ociArchiveImageSource { ref : ref , unpackedSrc : unpackedSrc , tempDirRef : tempDirRef } , nil }
3323	func LoadManifestDescriptor ( imgRef types . ImageReference ) ( imgspecv1 . Descriptor , error ) { ociArchRef , ok := imgRef . ( ociArchiveReference ) if ! ok { return imgspecv1 . Descriptor { } , errors . Errorf ( "error typecasting, need type ociArchiveReference" ) } tempDirRef , err := createUntarTempDir ( ociArchRef ) if err != nil { return imgspecv1 . Descriptor { } , errors . Wrap ( err , "error creating temp directory" ) } defer tempDirRef . deleteTempDir ( ) descriptor , err := ocilayout . LoadManifestDescriptor ( tempDirRef . ociRefExtracted ) if err != nil { return imgspecv1 . Descriptor { } , errors . Wrap ( err , "error loading index" ) } return descriptor , nil }
3324	func ( s * ociArchiveImageSource ) Close ( ) error { defer s . tempDirRef . deleteTempDir ( ) return s . unpackedSrc . Close ( ) }
3325	func ( os * orderedSet ) append ( s string ) { if _ , ok := os . included [ s ] ; ! ok { os . list = append ( os . list , s ) os . included [ s ] = struct { } { } } }
3326	func isMultiImage ( ctx context . Context , img types . UnparsedImage ) ( bool , error ) { _ , mt , err := img . Manifest ( ctx ) if err != nil { return false , err } return manifest . MIMETypeIsMultiImage ( mt ) , nil }
3327	func lockPath ( path string ) { pl := func ( ) * pathLock { pathLocksMutex . Lock ( ) defer pathLocksMutex . Unlock ( ) pl , ok := pathLocks [ path ] if ok { pl . refCount ++ } else { pl = & pathLock { refCount : 1 , mutex : sync . Mutex { } } pathLocks [ path ] = pl } return pl } ( ) pl . mutex . Lock ( ) }
3328	func unlockPath ( path string ) { pathLocksMutex . Lock ( ) defer pathLocksMutex . Unlock ( ) pl , ok := pathLocks [ path ] if ! ok { panic ( fmt . Sprintf ( "Internal error: unlocking nonexistent lock for path %s" , path ) ) } pl . mutex . Unlock ( ) pl . refCount -- if pl . refCount == 0 { delete ( pathLocks , path ) } }
3329	func ( bdc * cache ) view ( fn func ( tx * bolt . Tx ) error ) ( retErr error ) { if _ , err := os . Lstat ( bdc . path ) ; err != nil && os . IsNotExist ( err ) { return err } lockPath ( bdc . path ) defer unlockPath ( bdc . path ) db , err := bolt . Open ( bdc . path , 0600 , & bolt . Options { ReadOnly : true } ) if err != nil { return err } defer func ( ) { if err := db . Close ( ) ; retErr == nil && err != nil { retErr = err } } ( ) return db . View ( fn ) }
3330	func ( bdc * cache ) update ( fn func ( tx * bolt . Tx ) error ) ( retErr error ) { lockPath ( bdc . path ) defer unlockPath ( bdc . path ) db , err := bolt . Open ( bdc . path , 0600 , nil ) if err != nil { return err } defer func ( ) { if err := db . Close ( ) ; retErr == nil && err != nil { retErr = err } } ( ) return db . Update ( fn ) }
3331	func ( bdc * cache ) uncompressedDigest ( tx * bolt . Tx , anyDigest digest . Digest ) digest . Digest { if b := tx . Bucket ( uncompressedDigestBucket ) ; b != nil { if uncompressedBytes := b . Get ( [ ] byte ( anyDigest . String ( ) ) ) ; uncompressedBytes != nil { d , err := digest . Parse ( string ( uncompressedBytes ) ) if err == nil { return d } } } if b := tx . Bucket ( digestByUncompressedBucket ) ; b != nil { if b = b . Bucket ( [ ] byte ( anyDigest . String ( ) ) ) ; b != nil { c := b . Cursor ( ) if k , _ := c . First ( ) ; k != nil { return anyDigest } } } return "" }
3332	func ( bdc * cache ) appendReplacementCandidates ( candidates [ ] prioritize . CandidateWithTime , scopeBucket * bolt . Bucket , digest digest . Digest ) [ ] prioritize . CandidateWithTime { b := scopeBucket . Bucket ( [ ] byte ( digest . String ( ) ) ) if b == nil { return candidates } _ = b . ForEach ( func ( k , v [ ] byte ) error { t := time . Time { } if err := t . UnmarshalBinary ( v ) ; err != nil { return err } candidates = append ( candidates , prioritize . CandidateWithTime { Candidate : types . BICReplacementCandidate { Digest : digest , Location : types . BICLocationReference { Opaque : string ( k ) } , } , LastSeen : t , } ) return nil } ) return candidates }
3333	func indexExists ( ref ociReference ) bool { _ , err := os . Stat ( ref . indexPath ( ) ) if err == nil { return true } if os . IsNotExist ( err ) { return false } return true }
3334	func ( c * copier ) createSignature ( manifest [ ] byte , keyIdentity string ) ( [ ] byte , error ) { mech , err := signature . NewGPGSigningMechanism ( ) if err != nil { return nil , errors . Wrap ( err , "Error initializing GPG" ) } defer mech . Close ( ) if err := mech . SupportsSigning ( ) ; err != nil { return nil , errors . Wrap ( err , "Signing not supported" ) } dockerReference := c . dest . Reference ( ) . DockerReference ( ) if dockerReference == nil { return nil , errors . Errorf ( "Cannot determine canonical Docker reference for destination %s" , transports . ImageName ( c . dest . Reference ( ) ) ) } c . Printf ( "Signing manifest\n" ) \n newSig , err := signature . SignDockerManifest ( manifest , dockerReference . String ( ) , mech , keyIdentity ) if err != nil { return nil , errors . Wrap ( err , "Error creating signature" ) } }
3335	func ParseReference ( reference string ) ( types . ImageReference , error ) { dir , image := internal . SplitPathAndImage ( reference ) return NewReference ( dir , image ) }
3336	func NewReference ( dir , image string ) ( types . ImageReference , error ) { resolved , err := explicitfilepath . ResolvePathToFullyExplicit ( dir ) if err != nil { return nil , err } if err := internal . ValidateOCIPath ( dir ) ; err != nil { return nil , err } if err = internal . ValidateImageName ( image ) ; err != nil { return nil , err } return ociReference { dir : dir , resolvedDir : resolved , image : image } , nil }
3337	func ( ref ociReference ) getIndex ( ) ( * imgspecv1 . Index , error ) { indexJSON , err := os . Open ( ref . indexPath ( ) ) if err != nil { return nil , err } defer indexJSON . Close ( ) index := & imgspecv1 . Index { } if err := json . NewDecoder ( indexJSON ) . Decode ( index ) ; err != nil { return nil , err } return index , nil }
3338	func LoadManifestDescriptor ( imgRef types . ImageReference ) ( imgspecv1 . Descriptor , error ) { ociRef , ok := imgRef . ( ociReference ) if ! ok { return imgspecv1 . Descriptor { } , errors . Errorf ( "error typecasting, need type ociRef" ) } return ociRef . getManifestDescriptor ( ) }
3339	func ( ref ociReference ) blobPath ( digest digest . Digest , sharedBlobDir string ) ( string , error ) { if err := digest . Validate ( ) ; err != nil { return "" , errors . Wrapf ( err , "unexpected digest reference %s" , digest ) } blobDir := filepath . Join ( ref . dir , "blobs" ) if sharedBlobDir != "" { blobDir = sharedBlobDir } return filepath . Join ( blobDir , digest . Algorithm ( ) . String ( ) , digest . Hex ( ) ) , nil }
3340	func SignDockerManifest ( m [ ] byte , dockerReference string , mech SigningMechanism , keyIdentity string ) ( [ ] byte , error ) { manifestDigest , err := manifest . Digest ( m ) if err != nil { return nil , err } sig := newUntrustedSignature ( manifestDigest , dockerReference ) return sig . sign ( mech , keyIdentity ) }
3341	func VerifyDockerManifestSignature ( unverifiedSignature , unverifiedManifest [ ] byte , expectedDockerReference string , mech SigningMechanism , expectedKeyIdentity string ) ( * Signature , error ) { expectedRef , err := reference . ParseNormalizedNamed ( expectedDockerReference ) if err != nil { return nil , err } sig , err := verifyAndExtractSignature ( mech , unverifiedSignature , signatureAcceptanceRules { validateKeyIdentity : func ( keyIdentity string ) error { if keyIdentity != expectedKeyIdentity { return InvalidSignatureError { msg : fmt . Sprintf ( "Signature by %s does not match expected fingerprint %s" , keyIdentity , expectedKeyIdentity ) } } return nil } , validateSignedDockerReference : func ( signedDockerReference string ) error { signedRef , err := reference . ParseNormalizedNamed ( signedDockerReference ) if err != nil { return InvalidSignatureError { msg : fmt . Sprintf ( "Invalid docker reference %s in signature" , signedDockerReference ) } } if signedRef . String ( ) != expectedRef . String ( ) { return InvalidSignatureError { msg : fmt . Sprintf ( "Docker reference %s does not match %s" , signedDockerReference , expectedDockerReference ) } } return nil } , validateSignedDockerManifestDigest : func ( signedDockerManifestDigest digest . Digest ) error { matches , err := manifest . MatchesDigest ( unverifiedManifest , signedDockerManifestDigest ) if err != nil { return err } if ! matches { return InvalidSignatureError { msg : fmt . Sprintf ( "Signature for docker digest %q does not match" , signedDockerManifestDigest ) } } return nil } , } ) if err != nil { return nil , err } return sig , nil }
3342	func newOpenshiftClient ( ref openshiftReference ) ( * openshiftClient , error ) { cmdConfig := defaultClientConfig ( ) logrus . Debugf ( "cmdConfig: %#v" , cmdConfig ) restConfig , err := cmdConfig . ClientConfig ( ) if err != nil { return nil , err } logrus . Debugf ( "restConfig: %#v" , restConfig ) baseURL , httpClient , err := restClientFor ( restConfig ) if err != nil { return nil , err } logrus . Debugf ( "URL: %#v" , * baseURL ) if httpClient == nil { httpClient = http . DefaultClient } return & openshiftClient { ref : ref , baseURL : baseURL , httpClient : httpClient , bearerToken : restConfig . BearerToken , username : restConfig . Username , password : restConfig . Password , } , nil }
3343	func ( c * openshiftClient ) doRequest ( ctx context . Context , method , path string , requestBody [ ] byte ) ( [ ] byte , error ) { url := * c . baseURL url . Path = path var requestBodyReader io . Reader if requestBody != nil { logrus . Debugf ( "Will send body: %s" , requestBody ) requestBodyReader = bytes . NewReader ( requestBody ) } req , err := http . NewRequest ( method , url . String ( ) , requestBodyReader ) if err != nil { return nil , err } req = req . WithContext ( ctx ) if len ( c . bearerToken ) != 0 { req . Header . Set ( "Authorization" , "Bearer " + c . bearerToken ) } else if len ( c . username ) != 0 { req . SetBasicAuth ( c . username , c . password ) } req . Header . Set ( "Accept" , "application/json, */*" ) req . Header . Set ( "User-Agent" , fmt . Sprintf ( "skopeo/%s" , version . Version ) ) if requestBody != nil { req . Header . Set ( "Content-Type" , "application/json" ) } logrus . Debugf ( "%s %s" , method , url . String ( ) ) res , err := c . httpClient . Do ( req ) if err != nil { return nil , err } defer res . Body . Close ( ) body , err := ioutil . ReadAll ( res . Body ) if err != nil { return nil , err } logrus . Debugf ( "Got body: %s" , body ) logrus . Debugf ( "Got content-type: %s" , res . Header . Get ( "Content-Type" ) ) var status status statusValid := false if err := json . Unmarshal ( body , & status ) ; err == nil && len ( status . Status ) > 0 { statusValid = true } switch { case res . StatusCode == http . StatusSwitchingProtocols : if statusValid && status . Status != "Success" { return nil , errors . New ( status . Message ) } case res . StatusCode >= http . StatusOK && res . StatusCode <= http . StatusPartialContent : default : if statusValid { return nil , errors . New ( status . Message ) } return nil , errors . Errorf ( "HTTP error: status code: %d (%s), body: %s" , res . StatusCode , http . StatusText ( res . StatusCode ) , string ( body ) ) } return body , nil }
3344	func ( c * openshiftClient ) getImage ( ctx context . Context , imageStreamImageName string ) ( * image , error ) { path := fmt . Sprintf ( "/oapi/v1/namespaces/%s/imagestreamimages/%s@%s" , c . ref . namespace , c . ref . stream , imageStreamImageName ) body , err := c . doRequest ( ctx , "GET" , path , nil ) if err != nil { return nil , err } var isi imageStreamImage if err := json . Unmarshal ( body , & isi ) ; err != nil { return nil , err } return & isi . Image , nil }
3345	func ( c * openshiftClient ) convertDockerImageReference ( ref string ) ( string , error ) { parts := strings . SplitN ( ref , "/" , 2 ) if len ( parts ) != 2 { return "" , errors . Errorf ( "Invalid format of docker reference %s: missing '/'" , ref ) } return reference . Domain ( c . ref . dockerReference ) + "/" + parts [ 1 ] , nil }
3346	func ( s * openshiftImageSource ) ensureImageIsResolved ( ctx context . Context ) error { if s . docker != nil { return nil } path := fmt . Sprintf ( "/oapi/v1/namespaces/%s/imagestreams/%s" , s . client . ref . namespace , s . client . ref . stream ) body , err := s . client . doRequest ( ctx , "GET" , path , nil ) if err != nil { return err } var is imageStream if err := json . Unmarshal ( body , & is ) ; err != nil { return err } var te * tagEvent for _ , tag := range is . Status . Tags { if tag . Tag != s . client . ref . dockerReference . Tag ( ) { continue } if len ( tag . Items ) > 0 { te = & tag . Items [ 0 ] break } } if te == nil { return errors . Errorf ( "No matching tag found" ) } logrus . Debugf ( "tag event %#v" , te ) dockerRefString , err := s . client . convertDockerImageReference ( te . DockerImageReference ) if err != nil { return err } logrus . Debugf ( "Resolved reference %#v" , dockerRefString ) dockerRef , err := docker . ParseReference ( "//" + dockerRefString ) if err != nil { return err } d , err := dockerRef . NewImageSource ( ctx , s . sys ) if err != nil { return err } s . docker = d s . imageStreamImageName = te . Image return nil }
3347	func newImageDestination ( ctx context . Context , sys * types . SystemContext , ref openshiftReference ) ( types . ImageDestination , error ) { client , err := newOpenshiftClient ( ref ) if err != nil { return nil , err } dockerRefString := fmt . Sprintf ( "//%s/%s/%s:%s" , reference . Domain ( client . ref . dockerReference ) , client . ref . namespace , client . ref . stream , client . ref . dockerReference . Tag ( ) ) dockerRef , err := docker . ParseReference ( dockerRefString ) if err != nil { return nil , err } docker , err := dockerRef . NewImageDestination ( ctx , sys ) if err != nil { return nil , err } return & openshiftImageDestination { client : client , docker : docker , } , nil }
3348	func newUntrustedSignature ( dockerManifestDigest digest . Digest , dockerReference string ) untrustedSignature { creatorID := "atomic " + version . Version timestamp := time . Now ( ) . Unix ( ) return untrustedSignature { UntrustedDockerManifestDigest : dockerManifestDigest , UntrustedDockerReference : dockerReference , UntrustedCreatorID : & creatorID , UntrustedTimestamp : & timestamp , } }
3349	func ( s untrustedSignature ) MarshalJSON ( ) ( [ ] byte , error ) { if s . UntrustedDockerManifestDigest == "" || s . UntrustedDockerReference == "" { return nil , errors . New ( "Unexpected empty signature content" ) } critical := map [ string ] interface { } { "type" : signatureType , "image" : map [ string ] string { "docker-manifest-digest" : s . UntrustedDockerManifestDigest . String ( ) } , "identity" : map [ string ] string { "docker-reference" : s . UntrustedDockerReference } , } optional := map [ string ] interface { } { } if s . UntrustedCreatorID != nil { optional [ "creator" ] = * s . UntrustedCreatorID } if s . UntrustedTimestamp != nil { optional [ "timestamp" ] = * s . UntrustedTimestamp } signature := map [ string ] interface { } { "critical" : critical , "optional" : optional , } return json . Marshal ( signature ) }
3350	func ( s * untrustedSignature ) UnmarshalJSON ( data [ ] byte ) error { err := s . strictUnmarshalJSON ( data ) if err != nil { if _ , ok := err . ( jsonFormatError ) ; ok { err = InvalidSignatureError { msg : err . Error ( ) } } } return err }
3351	func verifyAndExtractSignature ( mech SigningMechanism , unverifiedSignature [ ] byte , rules signatureAcceptanceRules ) ( * Signature , error ) { signed , keyIdentity , err := mech . Verify ( unverifiedSignature ) if err != nil { return nil , err } if err := rules . validateKeyIdentity ( keyIdentity ) ; err != nil { return nil , err } var unmatchedSignature untrustedSignature if err := json . Unmarshal ( signed , & unmatchedSignature ) ; err != nil { return nil , InvalidSignatureError { msg : err . Error ( ) } } if err := rules . validateSignedDockerManifestDigest ( unmatchedSignature . UntrustedDockerManifestDigest ) ; err != nil { return nil , err } if err := rules . validateSignedDockerReference ( unmatchedSignature . UntrustedDockerReference ) ; err != nil { return nil , err } return & Signature { DockerManifestDigest : unmatchedSignature . UntrustedDockerManifestDigest , DockerReference : unmatchedSignature . UntrustedDockerReference , } , nil }
3352	func ( e * Endpoint ) RewriteReference ( ref reference . Named , prefix string ) ( reference . Named , error ) { if ref == nil { return nil , fmt . Errorf ( "provided reference is nil" ) } if prefix == "" { return ref , nil } refString := ref . String ( ) if refMatchesPrefix ( refString , prefix ) { newNamedRef := strings . Replace ( refString , prefix , e . Location , 1 ) newParsedRef , err := reference . ParseNamed ( newNamedRef ) if newParsedRef != nil { logrus . Debugf ( "reference rewritten from '%v' to '%v'" , refString , newParsedRef . String ( ) ) } if err != nil { return nil , errors . Wrapf ( err , "error rewriting reference" ) } return newParsedRef , nil } return nil , fmt . Errorf ( "invalid prefix '%v' for reference '%v'" , prefix , refString ) }
3353	func getV1Registries ( config * tomlConfig ) ( [ ] Registry , error ) { regMap := make ( map [ string ] * Registry ) registryOrder := [ ] string { } getRegistry := func ( location string ) ( * Registry , error ) { var err error location , err = parseLocation ( location ) if err != nil { return nil , err } reg , exists := regMap [ location ] if ! exists { reg = & Registry { Endpoint : Endpoint { Location : location } , Mirrors : [ ] Endpoint { } , Prefix : location , } regMap [ location ] = reg registryOrder = append ( registryOrder , location ) } return reg , nil } for _ , search := range config . V1TOMLConfig . Search . Registries { reg , err := getRegistry ( search ) if err != nil { return nil , err } reg . Search = true } for _ , blocked := range config . V1TOMLConfig . Block . Registries { reg , err := getRegistry ( blocked ) if err != nil { return nil , err } reg . Blocked = true } for _ , insecure := range config . V1TOMLConfig . Insecure . Registries { reg , err := getRegistry ( insecure ) if err != nil { return nil , err } reg . Insecure = true } registries := [ ] Registry { } for _ , location := range registryOrder { reg := regMap [ location ] registries = append ( registries , * reg ) } return registries , nil }
3354	func getConfigPath ( ctx * types . SystemContext ) string { confPath := systemRegistriesConfPath if ctx != nil { if ctx . SystemRegistriesConfPath != "" { confPath = ctx . SystemRegistriesConfPath } else if ctx . RootForImplicitAbsolutePaths != "" { confPath = filepath . Join ( ctx . RootForImplicitAbsolutePaths , systemRegistriesConfPath ) } } return confPath }
3355	func GetRegistries ( ctx * types . SystemContext ) ( [ ] Registry , error ) { configPath := getConfigPath ( ctx ) configMutex . Lock ( ) defer configMutex . Unlock ( ) if registries , inCache := configCache [ configPath ] ; inCache { return registries , nil } config , err := loadRegistryConf ( configPath ) if err != nil { if os . IsNotExist ( err ) && ( ctx == nil || ctx . SystemRegistriesConfPath == "" ) { return [ ] Registry { } , nil } return nil , err } registries := config . Registries v1Registries , err := getV1Registries ( config ) if err != nil { return nil , err } if len ( v1Registries ) > 0 { if len ( registries ) > 0 { return nil , & InvalidRegistries { s : "mixing sysregistry v1/v2 is not supported" } } registries = v1Registries } registries , err = postProcessRegistries ( registries ) if err != nil { return nil , err } configCache [ configPath ] = registries return registries , err }
3356	func readRegistryConf ( configPath string ) ( [ ] byte , error ) { configBytes , err := ioutil . ReadFile ( configPath ) return configBytes , err }
3357	func ( i * sourcedImage ) Manifest ( ctx context . Context ) ( [ ] byte , string , error ) { return i . manifestBlob , i . manifestMIMEType , nil }
3358	func ( r * tarballReference ) ConfigUpdate ( config imgspecv1 . Image , annotations map [ string ] string ) error { r . config = config if r . annotations == nil { r . annotations = make ( map [ string ] string ) } for k , v := range annotations { r . annotations [ k ] = v } return nil }
3359	func parseImageAndDockerReference ( image types . UnparsedImage , s2 string ) ( reference . Named , reference . Named , error ) { r1 := image . Reference ( ) . DockerReference ( ) if r1 == nil { return nil , nil , PolicyRequirementError ( fmt . Sprintf ( "Docker reference match attempted on image %s with no known Docker reference identity" , transports . ImageName ( image . Reference ( ) ) ) ) } r2 , err := reference . ParseNormalizedNamed ( s2 ) if err != nil { return nil , nil , err } return r1 , r2 , nil }
3360	func parseDockerReferences ( s1 , s2 string ) ( reference . Named , reference . Named , error ) { r1 , err := reference . ParseNormalizedNamed ( s1 ) if err != nil { return nil , nil , err } r2 , err := reference . ParseNormalizedNamed ( s2 ) if err != nil { return nil , nil , err } return r1 , r2 , nil }
3361	func ListNames ( ) [ ] string { kt . mu . Lock ( ) defer kt . mu . Unlock ( ) deprecated := map [ string ] bool { "atomic" : true , } var names [ ] string for _ , transport := range kt . transports { if ! deprecated [ transport . Name ( ) ] { names = append ( names , transport . Name ( ) ) } } sort . Strings ( names ) return names }
3362	func NewReference ( image string , repo string ) ( types . ImageReference , error ) { ostreeImage , err := reference . ParseNormalizedNamed ( image ) if err != nil { return nil , err } if reference . IsNameOnly ( ostreeImage ) { image = image + ":latest" } resolved , err := explicitfilepath . ResolvePathToFullyExplicit ( repo ) if err != nil { if os . IsNotExist ( err ) && repo == defaultOSTreeRepo { resolved = repo } else { return nil , err } } if strings . Contains ( resolved , ":" ) { return nil , errors . Errorf ( "Invalid OSTree reference %s@%s: path %s contains a colon" , image , repo , resolved ) } return ostreeReference { image : image , branchName : encodeOStreeRef ( image ) , repo : resolved , } , nil }
3363	func ( ref ostreeReference ) signaturePath ( index int ) string { return filepath . Join ( "manifest" , fmt . Sprintf ( "signature-%d" , index + 1 ) ) }
3364	func ValidateImageName ( image string ) error { if len ( image ) == 0 { return nil } var err error if ! refRegexp . MatchString ( image ) { err = errors . Errorf ( "Invalid image %s" , image ) } return err }
3365	func SplitPathAndImage ( reference string ) ( string , string ) { if runtime . GOOS == "windows" { return splitPathAndImageWindows ( reference ) } return splitPathAndImageNonWindows ( reference ) }
3366	func ValidateOCIPath ( path string ) error { if runtime . GOOS == "windows" { if strings . Count ( path , ":" ) > 1 { return errors . Errorf ( "Invalid OCI reference: path %s contains more than one colon" , path ) } } else { if strings . Contains ( path , ":" ) { return errors . Errorf ( "Invalid OCI reference: path %s contains a colon" , path ) } } return nil }
3367	func ValidateScope ( scope string ) error { var err error if runtime . GOOS == "windows" { err = validateScopeWindows ( scope ) } else { err = validateScopeNonWindows ( scope ) } if err != nil { return err } cleaned := filepath . Clean ( scope ) if cleaned != scope { return errors . Errorf ( `Invalid scope %s: Uses non-canonical path format, perhaps try with path %s` , scope , cleaned ) } return nil }
3368	func BlobInfoFromSchema2Descriptor ( desc Schema2Descriptor ) types . BlobInfo { return types . BlobInfo { Digest : desc . Digest , Size : desc . Size , URLs : desc . URLs , MediaType : desc . MediaType , } }
3369	func Schema2FromManifest ( manifest [ ] byte ) ( * Schema2 , error ) { s2 := Schema2 { } if err := json . Unmarshal ( manifest , & s2 ) ; err != nil { return nil , err } return & s2 , nil }
3370	func Schema2FromComponents ( config Schema2Descriptor , layers [ ] Schema2Descriptor ) * Schema2 { return & Schema2 { SchemaVersion : 2 , MediaType : DockerV2Schema2MediaType , ConfigDescriptor : config , LayersDescriptors : layers , } }
3371	func SetAuthentication ( sys * types . SystemContext , registry , username , password string ) error { return modifyJSON ( sys , func ( auths * dockerConfigFile ) ( bool , error ) { if ch , exists := auths . CredHelpers [ registry ] ; exists { return false , setAuthToCredHelper ( ch , registry , username , password ) } creds := base64 . StdEncoding . EncodeToString ( [ ] byte ( username + ":" + password ) ) newCreds := dockerAuthConfig { Auth : creds } auths . AuthConfigs [ registry ] = newCreds return true , nil } ) }
3372	func RemoveAuthentication ( sys * types . SystemContext , registry string ) error { return modifyJSON ( sys , func ( auths * dockerConfigFile ) ( bool , error ) { if ch , exists := auths . CredHelpers [ registry ] ; exists { return false , deleteAuthFromCredHelper ( ch , registry ) } if _ , ok := auths . AuthConfigs [ registry ] ; ok { delete ( auths . AuthConfigs , registry ) } else if _ , ok := auths . AuthConfigs [ normalizeRegistry ( registry ) ] ; ok { delete ( auths . AuthConfigs , normalizeRegistry ( registry ) ) } else { return false , ErrNotLoggedIn } return true , nil } ) }
3373	func RemoveAllAuthentication ( sys * types . SystemContext ) error { return modifyJSON ( sys , func ( auths * dockerConfigFile ) ( bool , error ) { auths . CredHelpers = make ( map [ string ] string ) auths . AuthConfigs = make ( map [ string ] dockerAuthConfig ) return true , nil } ) }
3374	func readJSONFile ( path string , legacyFormat bool ) ( dockerConfigFile , error ) { var auths dockerConfigFile raw , err := ioutil . ReadFile ( path ) if err != nil { if os . IsNotExist ( err ) { auths . AuthConfigs = map [ string ] dockerAuthConfig { } return auths , nil } return dockerConfigFile { } , err } if legacyFormat { if err = json . Unmarshal ( raw , & auths . AuthConfigs ) ; err != nil { return dockerConfigFile { } , errors . Wrapf ( err , "error unmarshaling JSON at %q" , path ) } return auths , nil } if err = json . Unmarshal ( raw , & auths ) ; err != nil { return dockerConfigFile { } , errors . Wrapf ( err , "error unmarshaling JSON at %q" , path ) } return auths , nil }
3375	func modifyJSON ( sys * types . SystemContext , editor func ( auths * dockerConfigFile ) ( bool , error ) ) error { path , err := getPathToAuth ( sys ) if err != nil { return err } dir := filepath . Dir ( path ) if _ , err := os . Stat ( dir ) ; os . IsNotExist ( err ) { if err = os . MkdirAll ( dir , 0700 ) ; err != nil { return errors . Wrapf ( err , "error creating directory %q" , dir ) } } auths , err := readJSONFile ( path , false ) if err != nil { return errors . Wrapf ( err , "error reading JSON file %q" , path ) } updated , err := editor ( & auths ) if err != nil { return errors . Wrapf ( err , "error updating %q" , path ) } if updated { newData , err := json . MarshalIndent ( auths , "" , "\t" ) \t if err != nil { return errors . Wrapf ( err , "error marshaling JSON %q" , path ) } } if err = ioutil . WriteFile ( path , newData , 0755 ) ; err != nil { return errors . Wrapf ( err , "error writing to file %q" , path ) } }
3376	func findAuthentication ( registry , path string , legacyFormat bool ) ( string , string , error ) { auths , err := readJSONFile ( path , legacyFormat ) if err != nil { return "" , "" , errors . Wrapf ( err , "error reading JSON file %q" , path ) } if ch , exists := auths . CredHelpers [ registry ] ; exists { return getAuthFromCredHelper ( ch , registry ) } if val , exists := auths . AuthConfigs [ registry ] ; exists { return decodeDockerAuth ( val . Auth ) } registry = normalizeRegistry ( registry ) normalizedAuths := map [ string ] dockerAuthConfig { } for k , v := range auths . AuthConfigs { normalizedAuths [ normalizeRegistry ( k ) ] = v } if val , exists := normalizedAuths [ registry ] ; exists { return decodeDockerAuth ( val . Auth ) } return "" , "" , nil }
3377	func NewDestination ( dest io . Writer , ref reference . NamedTagged ) * Destination { repoTags := [ ] reference . NamedTagged { } if ref != nil { repoTags = append ( repoTags , ref ) } return & Destination { writer : dest , tar : tar . NewWriter ( dest ) , repoTags : repoTags , blobs : make ( map [ digest . Digest ] types . BlobInfo ) , } }
3378	func ( d * Destination ) AddRepoTags ( tags [ ] reference . NamedTagged ) { d . repoTags = append ( d . repoTags , tags ... ) }
3379	func ( d * Destination ) writeLegacyLayerMetadata ( layerDescriptors [ ] manifest . Schema2Descriptor ) ( layerPaths [ ] string , lastLayerID string , err error ) { var chainID digest . Digest lastLayerID = "" for i , l := range layerDescriptors { if chainID == "" { chainID = l . Digest } else { chainID = digest . Canonical . FromString ( chainID . String ( ) + " " + l . Digest . String ( ) ) } layerID := chainID . Hex ( ) physicalLayerPath := l . Digest . Hex ( ) + ".tar" layerPaths = append ( layerPaths , physicalLayerPath ) if err := d . sendSymlink ( filepath . Join ( layerID , legacyLayerFileName ) , filepath . Join ( ".." , physicalLayerPath ) ) ; err != nil { return nil , "" , errors . Wrap ( err , "Error creating layer symbolic link" ) } b := [ ] byte ( "1.0" ) if err := d . sendBytes ( filepath . Join ( layerID , legacyVersionFileName ) , b ) ; err != nil { return nil , "" , errors . Wrap ( err , "Error writing VERSION file" ) } layerConfig := make ( map [ string ] interface { } ) layerConfig [ "id" ] = layerID if lastLayerID != "" { layerConfig [ "parent" ] = lastLayerID } if i == len ( layerDescriptors ) - 1 { var config map [ string ] * json . RawMessage err := json . Unmarshal ( d . config , & config ) if err != nil { return nil , "" , errors . Wrap ( err , "Error unmarshaling config" ) } for _ , attr := range [ 7 ] string { "architecture" , "config" , "container" , "container_config" , "created" , "docker_version" , "os" } { layerConfig [ attr ] = config [ attr ] } } b , err := json . Marshal ( layerConfig ) if err != nil { return nil , "" , errors . Wrap ( err , "Error marshaling layer config" ) } if err := d . sendBytes ( filepath . Join ( layerID , legacyConfigFileName ) , b ) ; err != nil { return nil , "" , errors . Wrap ( err , "Error writing config json file" ) } lastLayerID = layerID } return layerPaths , lastLayerID , nil }
3380	func ( d * Destination ) sendSymlink ( path string , target string ) error { hdr , err := tar . FileInfoHeader ( & tarFI { path : path , size : 0 , isSymlink : true } , target ) if err != nil { return nil } logrus . Debugf ( "Sending as tar link %s -> %s" , path , target ) return d . tar . WriteHeader ( hdr ) }
3381	func ( d * Destination ) sendBytes ( path string , b [ ] byte ) error { return d . sendFile ( path , int64 ( len ( b ) ) , bytes . NewReader ( b ) ) }
3382	func ( d * Destination ) sendFile ( path string , expectedSize int64 , stream io . Reader ) error { hdr , err := tar . FileInfoHeader ( & tarFI { path : path , size : expectedSize } , "" ) if err != nil { return nil } logrus . Debugf ( "Sending as tar file %s" , path ) if err := d . tar . WriteHeader ( hdr ) ; err != nil { return err } size , err := io . Copy ( d . tar , stream ) if err != nil { return err } if size != expectedSize { return errors . Errorf ( "Size mismatch when copying %s, expected %d, got %d" , path , expectedSize , size ) } return nil }
3383	func ( d * Destination ) Commit ( ctx context . Context ) error { return d . tar . Close ( ) }
3384	func imageMatchesRepo ( image * storage . Image , ref reference . Named ) bool { repo := ref . Name ( ) for _ , name := range image . Names { if named , err := reference . ParseNormalizedNamed ( name ) ; err == nil { if named . Name ( ) == repo { return true } } } return false }
3385	func ( s * storageReference ) resolveImage ( ) ( * storage . Image , error ) { var loadedImage * storage . Image if s . id == "" && s . named != nil { image , err := s . transport . store . Image ( s . named . String ( ) ) if image != nil && err == nil { loadedImage = image s . id = image . ID } } if s . id == "" && s . named != nil { if digested , ok := s . named . ( reference . Digested ) ; ok { images , err := s . transport . store . ImagesByDigest ( digested . Digest ( ) ) if err == nil && len ( images ) > 0 { for _ , image := range images { if imageMatchesRepo ( image , s . named ) { loadedImage = image s . id = image . ID break } } } } } if s . id == "" { logrus . Debugf ( "reference %q does not resolve to an image ID" , s . StringWithinTransport ( ) ) return nil , errors . Wrapf ( ErrNoSuchImage , "reference %q does not resolve to an image ID" , s . StringWithinTransport ( ) ) } if loadedImage == nil { img , err := s . transport . store . Image ( s . id ) if err != nil { return nil , errors . Wrapf ( err , "error reading image %q" , s . id ) } loadedImage = img } if s . named != nil { if ! imageMatchesRepo ( loadedImage , s . named ) { logrus . Errorf ( "no image matching reference %q found" , s . StringWithinTransport ( ) ) return nil , ErrNoSuchImage } } if digest , ok := loadedImage . BigDataDigests [ storage . ImageDigestBigDataKey ] ; ok { loadedImage . Digest = digest } if s . named != nil { if digested , ok := s . named . ( reference . Digested ) ; ok { for _ , digest := range loadedImage . Digests { if digest == digested . Digest ( ) { loadedImage . Digest = digest break } } } } return loadedImage , nil }
3386	func ( s storageReference ) Transport ( ) types . ImageTransport { return & storageTransport { store : s . transport . store , defaultUIDMap : s . transport . defaultUIDMap , defaultGIDMap : s . transport . defaultGIDMap , } }
3387	func ( s storageReference ) StringWithinTransport ( ) string { optionsList := "" options := s . transport . store . GraphOptions ( ) if len ( options ) > 0 { optionsList = ":" + strings . Join ( options , "," ) } res := "[" + s . transport . store . GraphDriverName ( ) + "@" + s . transport . store . GraphRoot ( ) + "+" + s . transport . store . RunRoot ( ) + optionsList + "]" if s . named != nil { res = res + s . named . String ( ) } if s . id != "" { res = res + "@" + s . id } return res }
3388	func ( s storageReference ) PolicyConfigurationNamespaces ( ) [ ] string { storeSpec := "[" + s . transport . store . GraphDriverName ( ) + "@" + s . transport . store . GraphRoot ( ) + "]" driverlessStoreSpec := "[" + s . transport . store . GraphRoot ( ) + "]" namespaces := [ ] string { } if s . named != nil { if s . id != "" { namespaces = append ( namespaces , storeSpec + s . named . String ( ) ) } tagged , isTagged := s . named . ( reference . Tagged ) _ , isDigested := s . named . ( reference . Digested ) if isTagged && isDigested { namespaces = append ( namespaces , storeSpec + s . named . Name ( ) + ":" + tagged . Tag ( ) ) } components := strings . Split ( s . named . Name ( ) , "/" ) for len ( components ) > 0 { namespaces = append ( namespaces , storeSpec + strings . Join ( components , "/" ) ) components = components [ : len ( components ) - 1 ] } } namespaces = append ( namespaces , storeSpec ) namespaces = append ( namespaces , driverlessStoreSpec ) return namespaces }
3389	func GzipDecompressor ( r io . Reader ) ( io . ReadCloser , error ) { return pgzip . NewReader ( r ) }
3390	func Bzip2Decompressor ( r io . Reader ) ( io . ReadCloser , error ) { return ioutil . NopCloser ( bzip2 . NewReader ( r ) ) , nil }
3391	func XzDecompressor ( r io . Reader ) ( io . ReadCloser , error ) { r , err := xz . NewReader ( r ) if err != nil { return nil , err } return ioutil . NopCloser ( r ) , nil }
3392	func DetectCompression ( input io . Reader ) ( DecompressorFunc , io . Reader , error ) { buffer := [ 8 ] byte { } n , err := io . ReadAtLeast ( input , buffer [ : ] , len ( buffer ) ) if err != nil && err != io . EOF && err != io . ErrUnexpectedEOF { return nil , nil , err } var decompressor DecompressorFunc for name , algo := range compressionAlgos { if bytes . HasPrefix ( buffer [ : n ] , algo . prefix ) { logrus . Debugf ( "Detected compression format %s" , name ) decompressor = algo . decompressor break } } if decompressor == nil { logrus . Debugf ( "No compression detected" ) } return decompressor , io . MultiReader ( bytes . NewReader ( buffer [ : n ] ) , input ) , nil }
3393	func newImageDestination ( sys * types . SystemContext , ref dockerReference ) ( types . ImageDestination , error ) { c , err := newDockerClientFromRef ( sys , ref , true , "pull,push" ) if err != nil { return nil , err } return & dockerImageDestination { ref : ref , c : c , } , nil }
3394	func ( d * dockerImageDestination ) mountBlob ( ctx context . Context , srcRepo reference . Named , srcDigest digest . Digest , extraScope * authScope ) error { u := url . URL { Path : fmt . Sprintf ( blobUploadPath , reference . Path ( d . ref . ref ) ) , RawQuery : url . Values { "mount" : { srcDigest . String ( ) } , "from" : { reference . Path ( srcRepo ) } , } . Encode ( ) , } mountPath := u . String ( ) logrus . Debugf ( "Trying to mount %s" , mountPath ) res , err := d . c . makeRequest ( ctx , "POST" , mountPath , nil , nil , v2Auth , extraScope ) if err != nil { return err } defer res . Body . Close ( ) switch res . StatusCode { case http . StatusCreated : logrus . Debugf ( "... mount OK" ) return nil case http . StatusAccepted : uploadLocation , err := res . Location ( ) if err != nil { return errors . Wrap ( err , "Error determining upload URL after a mount attempt" ) } logrus . Debugf ( "... started an upload instead of mounting, trying to cancel at %s" , uploadLocation . String ( ) ) res2 , err := d . c . makeRequestToResolvedURL ( ctx , "DELETE" , uploadLocation . String ( ) , nil , nil , - 1 , v2Auth , extraScope ) if err != nil { logrus . Debugf ( "Error trying to cancel an inadvertent upload: %s" , err ) } else { defer res2 . Body . Close ( ) if res2 . StatusCode != http . StatusNoContent { logrus . Debugf ( "Error trying to cancel an inadvertent upload, status %s" , http . StatusText ( res . StatusCode ) ) } } return fmt . Errorf ( "Mounting %s from %s to %s started an upload instead" , srcDigest , srcRepo . Name ( ) , d . ref . ref . Name ( ) ) default : logrus . Debugf ( "Error mounting, response %#v" , * res ) return errors . Wrapf ( client . HandleErrorResponse ( res ) , "Error mounting %s from %s to %s" , srcDigest , srcRepo . Name ( ) , d . ref . ref . Name ( ) ) } }
3395	func bicTransportScope ( ref dockerReference ) types . BICTransportScope { return types . BICTransportScope { Opaque : reference . Domain ( ref . ref ) } }
3396	func newBICLocationReference ( ref dockerReference ) types . BICLocationReference { return types . BICLocationReference { Opaque : ref . ref . Name ( ) } }
3397	func parseBICLocationReference ( lr types . BICLocationReference ) ( reference . Named , error ) { return reference . ParseNormalizedNamed ( lr . Opaque ) }
3398	func NewSourceFromStream ( inputStream io . Reader ) ( * Source , error ) { tarCopyFile , err := ioutil . TempFile ( tmpdir . TemporaryDirectoryForBigFiles ( ) , "docker-tar" ) if err != nil { return nil , errors . Wrap ( err , "error creating temporary file" ) } defer tarCopyFile . Close ( ) succeeded := false defer func ( ) { if ! succeeded { os . Remove ( tarCopyFile . Name ( ) ) } } ( ) uncompressedStream , _ , err := compression . AutoDecompress ( inputStream ) if err != nil { return nil , errors . Wrap ( err , "Error auto-decompressing input" ) } defer uncompressedStream . Close ( ) if _ , err := io . Copy ( tarCopyFile , uncompressedStream ) ; err != nil { return nil , errors . Wrapf ( err , "error copying contents to temporary file %q" , tarCopyFile . Name ( ) ) } succeeded = true return & Source { tarPath : tarCopyFile . Name ( ) , removeTarPathOnClose : true , } , nil }
3399	func ( s * Source ) readTarComponent ( path string ) ( [ ] byte , error ) { file , err := s . openTarComponent ( path ) if err != nil { return nil , errors . Wrapf ( err , "Error loading tar component %s" , path ) } defer file . Close ( ) bytes , err := ioutil . ReadAll ( file ) if err != nil { return nil , err } return bytes , nil }
3400	func ( s * Source ) ensureCachedDataIsPresent ( ) error { s . cacheDataLock . Do ( func ( ) { tarManifest , err := s . loadTarManifest ( ) if err != nil { s . cacheDataResult = err return } if len ( tarManifest ) != 1 { s . cacheDataResult = errors . Errorf ( "Unexpected tar manifest.json: expected 1 item, got %d" , len ( tarManifest ) ) return } configBytes , err := s . readTarComponent ( tarManifest [ 0 ] . Config ) if err != nil { s . cacheDataResult = err return } var parsedConfig manifest . Schema2Image if err := json . Unmarshal ( configBytes , & parsedConfig ) ; err != nil { s . cacheDataResult = errors . Wrapf ( err , "Error decoding tar config %s" , tarManifest [ 0 ] . Config ) return } knownLayers , err := s . prepareLayerData ( & tarManifest [ 0 ] , & parsedConfig ) if err != nil { s . cacheDataResult = err return } s . tarManifest = & tarManifest [ 0 ] s . configBytes = configBytes s . configDigest = digest . FromBytes ( configBytes ) s . orderedDiffIDList = parsedConfig . RootFS . DiffIDs s . knownLayers = knownLayers } ) return s . cacheDataResult }
3401	func ( s * Source ) loadTarManifest ( ) ( [ ] ManifestItem , error ) { bytes , err := s . readTarComponent ( manifestFileName ) if err != nil { return nil , err } var items [ ] ManifestItem if err := json . Unmarshal ( bytes , & items ) ; err != nil { return nil , errors . Wrap ( err , "Error decoding tar manifest.json" ) } return items , nil }
3402	func ( s * Source ) Close ( ) error { if s . removeTarPathOnClose { return os . Remove ( s . tarPath ) } return nil }
3403	func newImageDestination ( ctx context . Context , sys * types . SystemContext , ref daemonReference ) ( types . ImageDestination , error ) { if ref . ref == nil { return nil , errors . Errorf ( "Invalid destination docker-daemon:%s: a destination must be a name:tag" , ref . StringWithinTransport ( ) ) } namedTaggedRef , ok := ref . ref . ( reference . NamedTagged ) if ! ok { return nil , errors . Errorf ( "Invalid destination docker-daemon:%s: a destination must be a name:tag" , ref . StringWithinTransport ( ) ) } var mustMatchRuntimeOS = true if sys != nil && sys . DockerDaemonHost != client . DefaultDockerHost { mustMatchRuntimeOS = false } c , err := newDockerClient ( sys ) if err != nil { return nil , errors . Wrap ( err , "Error initializing docker engine client" ) } reader , writer := io . Pipe ( ) statusChannel := make ( chan error , 1 ) goroutineContext , goroutineCancel := context . WithCancel ( ctx ) go imageLoadGoroutine ( goroutineContext , c , reader , statusChannel ) return & daemonImageDestination { ref : ref , mustMatchRuntimeOS : mustMatchRuntimeOS , Destination : tarfile . NewDestination ( writer , namedTaggedRef ) , goroutineCancel : goroutineCancel , statusChannel : statusChannel , writer : writer , committed : false , } , nil }
3404	func imageLoadGoroutine ( ctx context . Context , c * client . Client , reader * io . PipeReader , statusChannel chan <- error ) { err := errors . New ( "Internal error: unexpected panic in imageLoadGoroutine" ) defer func ( ) { logrus . Debugf ( "docker-daemon: sending done, status %v" , err ) statusChannel <- err } ( ) defer func ( ) { if err == nil { reader . Close ( ) } else { reader . CloseWithError ( err ) } } ( ) resp , err := c . ImageLoad ( ctx , reader , true ) if err != nil { err = errors . Wrap ( err , "Error saving image to docker engine" ) return } defer resp . Body . Close ( ) }
3405	func NewReference ( file , image string ) ( types . ImageReference , error ) { resolved , err := explicitfilepath . ResolvePathToFullyExplicit ( file ) if err != nil { return nil , err } if err := internal . ValidateOCIPath ( file ) ; err != nil { return nil , err } if err := internal . ValidateImageName ( image ) ; err != nil { return nil , err } return ociArchiveReference { file : file , resolvedFile : resolved , image : image } , nil }
3406	func createOCIRef ( image string ) ( tempDirOCIRef , error ) { dir , err := ioutil . TempDir ( tmpdir . TemporaryDirectoryForBigFiles ( ) , "oci" ) if err != nil { return tempDirOCIRef { } , errors . Wrapf ( err , "error creating temp directory" ) } ociRef , err := ocilayout . NewReference ( dir , image ) if err != nil { return tempDirOCIRef { } , err } tempDirRef := tempDirOCIRef { tempDirectory : dir , ociRefExtracted : ociRef } return tempDirRef , nil }
3407	func createUntarTempDir ( ref ociArchiveReference ) ( tempDirOCIRef , error ) { tempDirRef , err := createOCIRef ( ref . image ) if err != nil { return tempDirOCIRef { } , errors . Wrap ( err , "error creating oci reference" ) } src := ref . resolvedFile dst := tempDirRef . tempDirectory if err := archive . UntarPath ( src , dst ) ; err != nil { if err := tempDirRef . deleteTempDir ( ) ; err != nil { return tempDirOCIRef { } , errors . Wrapf ( err , "error deleting temp directory %q" , tempDirRef . tempDirectory ) } return tempDirOCIRef { } , errors . Wrapf ( err , "error untarring file %q" , tempDirRef . tempDirectory ) } return tempDirRef , nil }
3408	func destructivelyPrioritizeReplacementCandidatesWithMax ( cs [ ] CandidateWithTime , primaryDigest , uncompressedDigest digest . Digest , maxCandidates int ) [ ] types . BICReplacementCandidate { sort . Sort ( & candidateSortState { cs : cs , primaryDigest : primaryDigest , uncompressedDigest : uncompressedDigest , } ) resLength := len ( cs ) if resLength > maxCandidates { resLength = maxCandidates } res := make ( [ ] types . BICReplacementCandidate , resLength ) for i := range res { res [ i ] = cs [ i ] . Candidate } return res }
3409	func newImageDestination ( ref ostreeReference , tmpDirPath string ) ( types . ImageDestination , error ) { tmpDirPath = filepath . Join ( tmpDirPath , ref . branchName ) if err := ensureDirectoryExists ( tmpDirPath ) ; err != nil { return nil , err } return & ostreeImageDestination { ref , "" , manifestSchema { } , tmpDirPath , map [ string ] * blobToImport { } , "" , 0 , nil } , nil }
3410	func resolveExistingPathToFullyExplicit ( path string ) ( string , error ) { resolved , err := filepath . Abs ( path ) if err != nil { return "" , err } resolved , err = filepath . EvalSymlinks ( resolved ) if err != nil { return "" , err } return filepath . Clean ( resolved ) , nil }
3411	func newImageDestination ( ref dirReference , compress bool ) ( types . ImageDestination , error ) { d := & dirImageDestination { ref : ref , compress : compress } dirExists , err := pathExists ( d . ref . resolvedPath ) if err != nil { return nil , errors . Wrapf ( err , "error checking for path %q" , d . ref . resolvedPath ) } if dirExists { isEmpty , err := isDirEmpty ( d . ref . resolvedPath ) if err != nil { return nil , err } if ! isEmpty { versionExists , err := pathExists ( d . ref . versionPath ( ) ) if err != nil { return nil , errors . Wrapf ( err , "error checking if path exists %q" , d . ref . versionPath ( ) ) } if versionExists { contents , err := ioutil . ReadFile ( d . ref . versionPath ( ) ) if err != nil { return nil , err } if string ( contents ) != version { return nil , ErrNotContainerImageDir } } else { return nil , ErrNotContainerImageDir } if err = removeDirContents ( d . ref . resolvedPath ) ; err != nil { return nil , errors . Wrapf ( err , "error erasing contents in %q" , d . ref . resolvedPath ) } logrus . Debugf ( "overwriting existing container image directory %q" , d . ref . resolvedPath ) } } else { if err := os . MkdirAll ( d . ref . resolvedPath , 0755 ) ; err != nil { return nil , errors . Wrapf ( err , "unable to create directory %q" , d . ref . resolvedPath ) } } err = ioutil . WriteFile ( d . ref . versionPath ( ) , [ ] byte ( version ) , 0644 ) if err != nil { return nil , errors . Wrapf ( err , "error creating version file %q" , d . ref . versionPath ( ) ) } return d , nil }
3412	func isDirEmpty ( path string ) ( bool , error ) { files , err := ioutil . ReadDir ( path ) if err != nil { return false , err } return len ( files ) == 0 , nil }
3413	func removeDirContents ( path string ) error { files , err := ioutil . ReadDir ( path ) if err != nil { return err } for _ , file := range files { if err := os . RemoveAll ( filepath . Join ( path , file . Name ( ) ) ) ; err != nil { return err } } return nil }
3414	func GetRepositoryTags ( ctx context . Context , sys * types . SystemContext , ref types . ImageReference ) ( [ ] string , error ) { dr , ok := ref . ( dockerReference ) if ! ok { return nil , errors . Errorf ( "ref must be a dockerReference" ) } path := fmt . Sprintf ( tagsPath , reference . Path ( dr . ref ) ) client , err := newDockerClientFromRef ( sys , dr , false , "pull" ) if err != nil { return nil , errors . Wrap ( err , "failed to create client" ) } tags := make ( [ ] string , 0 ) for { res , err := client . makeRequest ( ctx , "GET" , path , nil , nil , v2Auth , nil ) if err != nil { return nil , err } defer res . Body . Close ( ) if res . StatusCode != http . StatusOK { return nil , errors . Errorf ( "Invalid status code returned when fetching tags list %d (%s)" , res . StatusCode , http . StatusText ( res . StatusCode ) ) } var tagsHolder struct { Tags [ ] string } if err = json . NewDecoder ( res . Body ) . Decode ( & tagsHolder ) ; err != nil { return nil , err } tags = append ( tags , tagsHolder . Tags ... ) link := res . Header . Get ( "Link" ) if link == "" { break } linkURLStr := strings . Trim ( strings . Split ( link , ";" ) [ 0 ] , "<>" ) linkURL , err := url . Parse ( linkURLStr ) if err != nil { return tags , err } path = linkURL . Path if linkURL . RawQuery != "" { path += "?" path += linkURL . RawQuery } } return tags , nil }
3415	func DefaultCache ( sys * types . SystemContext ) types . BlobInfoCache { dir , err := blobInfoCacheDir ( sys , getRootlessUID ( ) ) if err != nil { logrus . Debugf ( "Error determining a location for %s, using a memory-only cache" , blobInfoCacheFilename ) return memory . New ( ) } path := filepath . Join ( dir , blobInfoCacheFilename ) if err := os . MkdirAll ( dir , 0700 ) ; err != nil { logrus . Debugf ( "Error creating parent directories for %s, using a memory-only cache: %v" , blobInfoCacheFilename , err ) return memory . New ( ) } logrus . Debugf ( "Using blob info cache at %s" , path ) return boltdb . New ( path ) }
3416	func ( mem * cache ) uncompressedDigestLocked ( anyDigest digest . Digest ) digest . Digest { if d , ok := mem . uncompressedDigests [ anyDigest ] ; ok { return d } if m , ok := mem . digestsByUncompressed [ anyDigest ] ; ok && len ( m ) > 0 { return anyDigest } return "" }
3417	func ( d * ociArchiveImageDestination ) Close ( ) error { defer d . tempDirRef . deleteTempDir ( ) return d . unpackedDest . Close ( ) }
3418	func ( d * ociArchiveImageDestination ) PutManifest ( ctx context . Context , m [ ] byte ) error { return d . unpackedDest . PutManifest ( ctx , m ) }
3419	func ( d * ociArchiveImageDestination ) Commit ( ctx context . Context ) error { if err := d . unpackedDest . Commit ( ctx ) ; err != nil { return errors . Wrapf ( err , "error storing image %q" , d . ref . image ) } src := d . tempDirRef . tempDirectory dst := d . ref . resolvedFile return tarDirectory ( src , dst ) }
3420	func tarDirectory ( src , dst string ) error { input , err := archive . Tar ( src , archive . Uncompressed ) if err != nil { return errors . Wrapf ( err , "error retrieving stream of bytes from %q" , src ) } outFile , err := os . Create ( dst ) if err != nil { return errors . Wrapf ( err , "error creating tar file %q" , dst ) } defer outFile . Close ( ) _ , err = io . Copy ( outFile , input ) return err }
3421	func ( s storageTransport ) ParseStoreReference ( store storage . Store , ref string ) ( * storageReference , error ) { if ref == "" { return nil , errors . Wrapf ( ErrInvalidReference , "%q is an empty reference" , ref ) } if ref [ 0 ] == '[' { closeIndex := strings . IndexRune ( ref , ']' ) if closeIndex < 1 { return nil , errors . Wrapf ( ErrInvalidReference , "store specifier in %q did not end" , ref ) } ref = ref [ closeIndex + 1 : ] } split := strings . LastIndex ( ref , "@" ) id := "" if split != - 1 { possibleID := ref [ split + 1 : ] if possibleID == "" { return nil , errors . Wrapf ( ErrInvalidReference , "empty trailing digest or ID in %q" , ref ) } if _ , err := digest . Parse ( possibleID ) ; err != nil { if idSum , err := digest . Parse ( "sha256:" + possibleID ) ; err == nil && idSum . Validate ( ) == nil { id = possibleID } else if img , err := store . Image ( possibleID ) ; err == nil && img != nil && len ( possibleID ) >= minimumTruncatedIDLength && strings . HasPrefix ( img . ID , possibleID ) { id = img . ID } else { return nil , errors . Wrapf ( ErrInvalidReference , "%q does not look like an image ID or digest" , possibleID ) } ref = ref [ : split ] } } if id == "" && len ( ref ) >= minimumTruncatedIDLength && ! strings . ContainsAny ( ref , "@:" ) { if img , err := store . Image ( ref ) ; err == nil && img != nil && strings . HasPrefix ( img . ID , ref ) { id = img . ID ref = "" } } var named reference . Named if ref != "" { var err error named , err = reference . ParseNormalizedNamed ( ref ) if err != nil { return nil , errors . Wrapf ( err , "error parsing named reference %q" , ref ) } named = reference . TagNameOnly ( named ) } result , err := newReference ( storageTransport { store : store , defaultUIDMap : s . defaultUIDMap , defaultGIDMap : s . defaultGIDMap } , named , id ) if err != nil { return nil , err } logrus . Debugf ( "parsed reference into %q" , result . StringWithinTransport ( ) ) return result , nil }
3422	func chooseDigestFromManifestList ( sys * types . SystemContext , blob [ ] byte ) ( digest . Digest , error ) { wantedArch := runtime . GOARCH if sys != nil && sys . ArchitectureChoice != "" { wantedArch = sys . ArchitectureChoice } wantedOS := runtime . GOOS if sys != nil && sys . OSChoice != "" { wantedOS = sys . OSChoice } list := manifestList { } if err := json . Unmarshal ( blob , & list ) ; err != nil { return "" , err } for _ , d := range list . Manifests { if d . Platform . Architecture == wantedArch && d . Platform . OS == wantedOS { return d . Digest , nil } } return "" , fmt . Errorf ( "no image found in manifest list for architecture %s, OS %s" , wantedArch , wantedOS ) }
3423	func ChooseManifestInstanceFromManifestList ( ctx context . Context , sys * types . SystemContext , src types . UnparsedImage ) ( digest . Digest , error ) { blob , mt , err := src . Manifest ( ctx ) if err != nil { return "" , err } if mt != manifest . DockerV2ListMediaType { return "" , fmt . Errorf ( "Internal error: Trying to select an image from a non-manifest-list manifest type %s" , mt ) } return chooseDigestFromManifestList ( sys , blob ) }
3424	func manifestSchema1FromComponents ( ref reference . Named , fsLayers [ ] manifest . Schema1FSLayers , history [ ] manifest . Schema1History , architecture string ) ( genericManifest , error ) { m , err := manifest . Schema1FromComponents ( ref , fsLayers , history , architecture ) if err != nil { return nil , err } return & manifestSchema1 { m : m } , nil }
3425	func ( s * dockerImageSource ) manifestDigest ( ctx context . Context , instanceDigest * digest . Digest ) ( digest . Digest , error ) { if instanceDigest != nil { return * instanceDigest , nil } if digested , ok := s . ref . ref . ( reference . Digested ) ; ok { d := digested . Digest ( ) if d . Algorithm ( ) == digest . Canonical { return d , nil } } if err := s . ensureManifestIsLoaded ( ctx ) ; err != nil { return "" , err } return manifest . Digest ( s . cachedManifest ) }
3426	func deleteImage ( ctx context . Context , sys * types . SystemContext , ref dockerReference ) error { c , err := newDockerClientFromRef ( sys , ref , true , "*" ) if err != nil { return err } headers := make ( map [ string ] [ ] string ) headers [ "Accept" ] = [ ] string { manifest . DockerV2Schema2MediaType } refTail , err := ref . tagOrDigest ( ) if err != nil { return err } getPath := fmt . Sprintf ( manifestPath , reference . Path ( ref . ref ) , refTail ) get , err := c . makeRequest ( ctx , "GET" , getPath , headers , nil , v2Auth , nil ) if err != nil { return err } defer get . Body . Close ( ) manifestBody , err := ioutil . ReadAll ( get . Body ) if err != nil { return err } switch get . StatusCode { case http . StatusOK : case http . StatusNotFound : return errors . Errorf ( "Unable to delete %v. Image may not exist or is not stored with a v2 Schema in a v2 registry" , ref . ref ) default : return errors . Errorf ( "Failed to delete %v: %s (%v)" , ref . ref , manifestBody , get . Status ) } digest := get . Header . Get ( "Docker-Content-Digest" ) deletePath := fmt . Sprintf ( manifestPath , reference . Path ( ref . ref ) , digest ) delete , err := c . makeRequest ( ctx , "DELETE" , deletePath , headers , nil , v2Auth , nil ) if err != nil { return err } defer delete . Body . Close ( ) body , err := ioutil . ReadAll ( delete . Body ) if err != nil { return err } if delete . StatusCode != http . StatusAccepted { return errors . Errorf ( "Failed to delete %v: %s (%v)" , deletePath , string ( body ) , delete . Status ) } if c . signatureBase != nil { manifestDigest , err := manifest . Digest ( manifestBody ) if err != nil { return err } for i := 0 ; ; i ++ { url := signatureStorageURL ( c . signatureBase , manifestDigest , i ) if url == nil { return errors . Errorf ( "Internal error: signatureStorageURL with non-nil base returned nil" ) } missing , err := c . deleteOneSignature ( url ) if err != nil { return err } if missing { break } } } return nil }
3427	func Schema1FromComponents ( ref reference . Named , fsLayers [ ] Schema1FSLayers , history [ ] Schema1History , architecture string ) ( * Schema1 , error ) { var name , tag string if ref != nil { name = reference . Path ( ref ) if tagged , ok := ref . ( reference . NamedTagged ) ; ok { tag = tagged . Tag ( ) } } s1 := Schema1 { Name : name , Tag : tag , Architecture : architecture , FSLayers : fsLayers , History : history , SchemaVersion : 1 , } if err := s1 . initialize ( ) ; err != nil { return nil , err } return & s1 , nil }
3428	func ( m * Schema1 ) initialize ( ) error { if len ( m . FSLayers ) != len ( m . History ) { return errors . New ( "length of history not equal to number of layers" ) } if len ( m . FSLayers ) == 0 { return errors . New ( "no FSLayers in manifest" ) } m . ExtractedV1Compatibility = make ( [ ] Schema1V1Compatibility , len ( m . History ) ) for i , h := range m . History { if err := json . Unmarshal ( [ ] byte ( h . V1Compatibility ) , & m . ExtractedV1Compatibility [ i ] ) ; err != nil { return errors . Wrapf ( err , "Error parsing v2s1 history entry %d" , i ) } } return nil }
3429	func ( m * Schema1 ) ToSchema2Config ( diffIDs [ ] digest . Digest ) ( [ ] byte , error ) { if len ( m . History ) == 0 { return nil , errors . New ( "image has no layers" ) } s1 := Schema2V1Image { } config := [ ] byte ( m . History [ 0 ] . V1Compatibility ) err := json . Unmarshal ( config , & s1 ) if err != nil { return nil , errors . Wrapf ( err , "error decoding configuration" ) } if s1 . DockerVersion != "" && versions . LessThan ( s1 . DockerVersion , "1.8.3" ) { config , err = json . Marshal ( & s1 ) if err != nil { return nil , errors . Wrapf ( err , "error re-encoding compat image config %#v" , s1 ) } } convertedHistory := [ ] Schema2History { } for _ , compat := range m . ExtractedV1Compatibility { hitem := Schema2History { Created : compat . Created , CreatedBy : strings . Join ( compat . ContainerConfig . Cmd , " " ) , Author : compat . Author , Comment : compat . Comment , EmptyLayer : compat . ThrowAway , } convertedHistory = append ( [ ] Schema2History { hitem } , convertedHistory ... ) } rootFS := & Schema2RootFS { Type : "layers" , DiffIDs : diffIDs , } raw := make ( map [ string ] * json . RawMessage ) err = json . Unmarshal ( config , & raw ) if err != nil { return nil , errors . Wrapf ( err , "error re-decoding compat image config %#v" , s1 ) } delete ( raw , "id" ) delete ( raw , "parent" ) delete ( raw , "parent_id" ) delete ( raw , "layer_id" ) delete ( raw , "throwaway" ) delete ( raw , "Size" ) rootfs , err := json . Marshal ( rootFS ) if err != nil { return nil , errors . Errorf ( "error encoding rootfs information %#v: %v" , rootFS , err ) } rawRootfs := json . RawMessage ( rootfs ) raw [ "rootfs" ] = & rawRootfs history , err := json . Marshal ( convertedHistory ) if err != nil { return nil , errors . Errorf ( "error encoding history information %#v: %v" , convertedHistory , err ) } rawHistory := json . RawMessage ( history ) raw [ "history" ] = & rawHistory config , err = json . Marshal ( raw ) if err != nil { return nil , errors . Errorf ( "error re-encoding compat image config %#v: %v" , s1 , err ) } return config , nil }
3430	func Digest ( manifest [ ] byte ) ( digest . Digest , error ) { if GuessMIMEType ( manifest ) == DockerV2Schema1SignedMediaType { sig , err := libtrust . ParsePrettySignature ( manifest , "signatures" ) if err != nil { return "" , err } manifest , err = sig . Payload ( ) if err != nil { return "" , err } } return digest . FromBytes ( manifest ) , nil }
3431	func MatchesDigest ( manifest [ ] byte , expectedDigest digest . Digest ) ( bool , error ) { actualDigest , err := Digest ( manifest ) if err != nil { return false , err } return expectedDigest == actualDigest , nil }
3432	func NormalizedMIMEType ( input string ) string { switch input { case "application/json" : return DockerV2Schema1SignedMediaType case DockerV2Schema1MediaType , DockerV2Schema1SignedMediaType , imgspecv1 . MediaTypeImageManifest , DockerV2Schema2MediaType , DockerV2ListMediaType : return input default : return DockerV2Schema1SignedMediaType } }
3433	func FromBlob ( manblob [ ] byte , mt string ) ( Manifest , error ) { switch NormalizedMIMEType ( mt ) { case DockerV2Schema1MediaType , DockerV2Schema1SignedMediaType : return Schema1FromManifest ( manblob ) case imgspecv1 . MediaTypeImageManifest : return OCI1FromManifest ( manblob ) case DockerV2Schema2MediaType : return Schema2FromManifest ( manblob ) case DockerV2ListMediaType : return nil , fmt . Errorf ( "Treating manifest lists as individual manifests is not implemented" ) default : return nil , fmt . Errorf ( "Unimplemented manifest MIME type %s" , mt ) } }
3434	func NewReference ( path string ) ( types . ImageReference , error ) { resolved , err := explicitfilepath . ResolvePathToFullyExplicit ( path ) if err != nil { return nil , err } return dirReference { path : path , resolvedPath : resolved } , nil }
3435	func ( ref dirReference ) layerPath ( digest digest . Digest ) string { return filepath . Join ( ref . path , digest . Hex ( ) ) }
3436	func ( ref dirReference ) signaturePath ( index int ) string { return filepath . Join ( ref . path , fmt . Sprintf ( "signature-%d" , index + 1 ) ) }
3437	func New ( n int , ctor func ( ) Worker ) * Pool { p := & Pool { ctor : ctor , reqChan : make ( chan workRequest ) , } p . SetSize ( n ) return p }
3438	func NewFunc ( n int , f func ( interface { } ) interface { } ) * Pool { return New ( n , func ( ) Worker { return & closureWorker { processor : f , } } ) }
3439	func ( p * Pool ) ProcessTimed ( payload interface { } , timeout time . Duration , ) ( interface { } , error ) { atomic . AddInt64 ( & p . queuedJobs , 1 ) defer atomic . AddInt64 ( & p . queuedJobs , - 1 ) tout := time . NewTimer ( timeout ) var request workRequest var open bool select { case request , open = <- p . reqChan : if ! open { return nil , ErrPoolNotRunning } case <- tout . C : return nil , ErrJobTimedOut } select { case request . jobChan <- payload : case <- tout . C : request . interruptFunc ( ) return nil , ErrJobTimedOut } select { case payload , open = <- request . retChan : if ! open { return nil , ErrWorkerClosed } case <- tout . C : request . interruptFunc ( ) return nil , ErrJobTimedOut } tout . Stop ( ) return payload , nil }
3440	func ( p * Pool ) SetSize ( n int ) { p . workerMut . Lock ( ) defer p . workerMut . Unlock ( ) lWorkers := len ( p . workers ) if lWorkers == n { return } for i := lWorkers ; i < n ; i ++ { p . workers = append ( p . workers , newWorkerWrapper ( p . reqChan , p . ctor ( ) ) ) } for i := n ; i < lWorkers ; i ++ { p . workers [ i ] . stop ( ) } for i := n ; i < lWorkers ; i ++ { p . workers [ i ] . join ( ) } p . workers = p . workers [ : n ] }
3441	func ( p * Pool ) GetSize ( ) int { p . workerMut . Lock ( ) defer p . workerMut . Unlock ( ) return len ( p . workers ) }
3442	func ( r * Rect ) TL ( ) Point { return Point { int ( r . x ) , int ( r . y ) } }
3443	func ( r * Rect ) BR ( ) Point { return Point { int ( r . x ) + int ( r . width ) , int ( r . y ) + int ( r . height ) } }
3444	func ( box * Box2D ) CVBox ( ) C . CvBox2D { var cvBox C . CvBox2D cvBox . angle = C . float ( box . angle ) cvBox . center . x = C . float ( box . center . X ) cvBox . center . y = C . float ( box . center . Y ) cvBox . size . width = C . float ( box . size . Width ) cvBox . size . height = C . float ( box . size . Height ) return cvBox }
3445	func ( box * Box2D ) Points ( ) [ ] Point2D32f { var pts [ 4 ] C . CvPoint2D32f C . cvBoxPoints ( box . CVBox ( ) , ( * C . CvPoint2D32f ) ( unsafe . Pointer ( & pts [ 0 ] ) ) , ) outPts := make ( [ ] Point2D32f , 4 ) for i , p := range pts { outPts [ i ] . X = float32 ( p . x ) outPts [ i ] . Y = float32 ( p . y ) } return outPts }
3446	func FOURCC ( c1 , c2 , c3 , c4 int8 ) uint32 { rv := C . GoOpenCV_FOURCC_ ( C . int ( c1 ) , C . int ( c2 ) , C . int ( c3 ) , C . int ( c4 ) ) return uint32 ( rv ) }
3447	func Merge ( imgBlue , imgGreen , imgRed , imgAlpha , dst * IplImage ) { C . cvMerge ( unsafe . Pointer ( imgBlue ) , unsafe . Pointer ( imgGreen ) , unsafe . Pointer ( imgRed ) , unsafe . Pointer ( imgAlpha ) , unsafe . Pointer ( dst ) , ) }
3448	func Split ( src , imgBlue , imgGreen , imgRed , imgAlpha * IplImage ) { C . cvSplit ( unsafe . Pointer ( src ) , unsafe . Pointer ( imgBlue ) , unsafe . Pointer ( imgGreen ) , unsafe . Pointer ( imgRed ) , unsafe . Pointer ( imgAlpha ) , ) }
3449	func AddWeighted ( src1 * IplImage , alpha float64 , src2 * IplImage , beta float64 , gamma float64 , dst * IplImage ) { C . cvAddWeighted ( unsafe . Pointer ( src1 ) , C . double ( alpha ) , unsafe . Pointer ( src2 ) , C . double ( beta ) , C . double ( gamma ) , unsafe . Pointer ( dst ) , ) }
3450	func And ( src1 , src2 , dst * IplImage ) { AndWithMask ( src1 , src2 , dst , nil ) }
3451	func AndWithMask ( src1 , src2 , dst , mask * IplImage ) { C . cvAnd ( unsafe . Pointer ( src1 ) , unsafe . Pointer ( src2 ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) }
3452	func AndScalar ( src * IplImage , value Scalar , dst * IplImage ) { AndScalarWithMask ( src , value , dst , nil ) }
3453	func AndScalarWithMask ( src * IplImage , value Scalar , dst , mask * IplImage ) { C . cvAndS ( unsafe . Pointer ( src ) , ( C . CvScalar ) ( value ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) }
3454	func Or ( src1 , src2 , dst * IplImage ) { OrWithMask ( src1 , src2 , dst , nil ) }
3455	func OrWithMask ( src1 , src2 , dst , mask * IplImage ) { C . cvOr ( unsafe . Pointer ( src1 ) , unsafe . Pointer ( src2 ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) }
3456	func OrScalar ( src * IplImage , value Scalar , dst * IplImage ) { OrScalarWithMask ( src , value , dst , nil ) }
3457	func OrScalarWithMask ( src * IplImage , value Scalar , dst , mask * IplImage ) { C . cvOrS ( unsafe . Pointer ( src ) , ( C . CvScalar ) ( value ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) }
3458	func AddWithMask ( src1 , src2 , dst , mask * IplImage ) { C . cvAdd ( unsafe . Pointer ( src1 ) , unsafe . Pointer ( src2 ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) }
3459	func AddScalar ( src * IplImage , value Scalar , dst * IplImage ) { AddScalarWithMask ( src , value , dst , nil ) }
3460	func AddScalarWithMask ( src * IplImage , value Scalar , dst , mask * IplImage ) { C . cvAddS ( unsafe . Pointer ( src ) , ( C . CvScalar ) ( value ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) }
3461	func Subtract ( src1 , src2 , dst * IplImage ) { SubtractWithMask ( src1 , src2 , dst , nil ) }
3462	func SubtractWithMask ( src1 , src2 , dst , mask * IplImage ) { C . cvSub ( unsafe . Pointer ( src1 ) , unsafe . Pointer ( src2 ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) }
3463	func SubScalar ( src * IplImage , value Scalar , dst * IplImage ) { SubScalarWithMask ( src , value , dst , nil ) }
3464	func SubScalarWithMask ( src * IplImage , value Scalar , dst , mask * IplImage ) { C . cvSubS ( unsafe . Pointer ( src ) , ( C . CvScalar ) ( value ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) }
3465	func SubScalarRev ( value Scalar , src , dst * IplImage ) { SubScalarWithMaskRev ( value , src , dst , nil ) }
3466	func SubScalarWithMaskRev ( value Scalar , src , dst , mask * IplImage ) { C . cvSubRS ( unsafe . Pointer ( src ) , ( C . CvScalar ) ( value ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) }
3467	func AbsDiff ( src1 , src2 , dst * IplImage ) { C . cvAbsDiff ( unsafe . Pointer ( src1 ) , unsafe . Pointer ( src2 ) , unsafe . Pointer ( dst ) , ) }
3468	func AbsDiffScalar ( src * IplImage , value Scalar , dst * IplImage ) { C . cvAbsDiffS ( unsafe . Pointer ( src ) , unsafe . Pointer ( dst ) , ( C . CvScalar ) ( value ) , ) }
3469	func MeanStdDevWithMask ( src , mask * IplImage ) ( Scalar , Scalar ) { var mean , stdDev Scalar C . cvAvgSdv ( unsafe . Pointer ( src ) , ( * C . CvScalar ) ( & mean ) , ( * C . CvScalar ) ( & stdDev ) , unsafe . Pointer ( mask ) , ) return mean , stdDev }
3470	func CreateSeq ( seq_flags , elem_size int ) * Seq { return ( * Seq ) ( C . cvCreateSeq ( C . int ( seq_flags ) , C . size_t ( unsafe . Sizeof ( Seq { } ) ) , C . size_t ( elem_size ) , C . cvCreateMemStorage ( C . int ( 0 ) ) , ) ) }
3471	func ( seq * Seq ) Push ( element unsafe . Pointer ) unsafe . Pointer { return unsafe . Pointer ( C . cvSeqPush ( ( * C . struct_CvSeq ) ( seq ) , element ) ) }
3472	func ( seq * Seq ) Pop ( element unsafe . Pointer ) { C . cvSeqPop ( ( * C . struct_CvSeq ) ( seq ) , element ) }
3473	func ( seq * Seq ) PushFront ( element unsafe . Pointer ) unsafe . Pointer { return unsafe . Pointer ( ( C . cvSeqPushFront ( ( * C . struct_CvSeq ) ( seq ) , element ) ) ) }
3474	func ( seq * Seq ) PopFront ( element unsafe . Pointer ) { C . cvSeqPopFront ( ( * C . struct_CvSeq ) ( seq ) , element ) }
3475	func ( seq * Seq ) GetElemAt ( index int ) unsafe . Pointer { return ( unsafe . Pointer ) ( C . cvGetSeqElem ( ( * C . struct_CvSeq ) ( seq ) , C . int ( index ) , ) ) }
3476	func ( seq * Seq ) RemoveAt ( index int ) { C . cvSeqRemove ( ( * C . struct_CvSeq ) ( seq ) , C . int ( index ) ) }
3477	func Delay ( delay time . Duration ) Option { return func ( c * Config ) { c . delay = delay } }
3478	func BackOffDelay ( n uint , config * Config ) time . Duration { return config . delay * ( 1 << ( n - 1 ) ) }
3479	func ( e Error ) Error ( ) string { logWithNumber := make ( [ ] string , lenWithoutNil ( e ) ) for i , l := range e { if l != nil { logWithNumber [ i ] = fmt . Sprintf ( "#%d: %s" , i + 1 , l . Error ( ) ) } } return fmt . Sprintf ( "All attempts fail:\n%s" , \n ) }
3480	func ( r * RequestBuilder ) Arguments ( args ... string ) * RequestBuilder { r . args = append ( r . args , args ... ) return r }
3481	func ( r * RequestBuilder ) BodyString ( body string ) * RequestBuilder { return r . Body ( strings . NewReader ( body ) ) }
3482	func ( r * RequestBuilder ) BodyBytes ( body [ ] byte ) * RequestBuilder { return r . Body ( bytes . NewReader ( body ) ) }
3483	func ( r * RequestBuilder ) Body ( body io . Reader ) * RequestBuilder { r . body = body return r }
3484	func ( r * RequestBuilder ) Option ( key string , value interface { } ) * RequestBuilder { var s string switch v := value . ( type ) { case bool : s = strconv . FormatBool ( v ) case string : s = v case [ ] byte : s = string ( v ) default : s = fmt . Sprint ( value ) } if r . opts == nil { r . opts = make ( map [ string ] string , 1 ) } r . opts [ key ] = s return r }
3485	func ( r * RequestBuilder ) Header ( name , value string ) * RequestBuilder { if r . headers == nil { r . headers = make ( map [ string ] string , 1 ) } r . headers [ name ] = value return r }
3486	func ( r * RequestBuilder ) Send ( ctx context . Context ) ( * Response , error ) { req := NewRequest ( ctx , r . shell . url , r . command , r . args ... ) req . Opts = r . opts req . Headers = r . headers req . Body = r . body return req . Send ( & r . shell . httpcli ) }
3487	func ( r * RequestBuilder ) Exec ( ctx context . Context , res interface { } ) error { httpRes , err := r . Send ( ctx ) if err != nil { return err } if res == nil { lateErr := httpRes . Close ( ) if httpRes . Error != nil { return httpRes . Error } return lateErr } return httpRes . Decode ( res ) }
3488	func ( s * PubSubSubscription ) Next ( ) ( * Message , error ) { if s . resp . Error != nil { return nil , s . resp . Error } d := json . NewDecoder ( s . resp . Output ) var r struct { From [ ] byte `json:"from,omitempty"` Data [ ] byte `json:"data,omitempty"` Seqno [ ] byte `json:"seqno,omitempty"` TopicIDs [ ] string `json:"topicIDs,omitempty"` } err := d . Decode ( & r ) if err != nil { return nil , err } from , err := peer . IDFromBytes ( r . From ) if err != nil { return nil , err } return & Message { From : from , Data : r . Data , Seqno : r . Seqno , TopicIDs : r . TopicIDs , } , nil }
3489	func ( s * PubSubSubscription ) Cancel ( ) error { if s . resp . Output == nil { return nil } return s . resp . Output . Close ( ) }
3490	func ( s * Shell ) FileList ( path string ) ( * UnixLsObject , error ) { var out lsOutput if err := s . Request ( "file/ls" , path ) . Exec ( context . Background ( ) , & out ) ; err != nil { return nil , err } for _ , object := range out . Objects { return object , nil } return nil , fmt . Errorf ( "no object in results" ) }
3491	func ( s * Shell ) Cat ( path string ) ( io . ReadCloser , error ) { resp , err := s . Request ( "cat" , path ) . Send ( context . Background ( ) ) if err != nil { return nil , err } if resp . Error != nil { return nil , resp . Error } return resp . Output , nil }
3492	func ( s * Shell ) List ( path string ) ( [ ] * LsLink , error ) { var out struct { Objects [ ] LsObject } err := s . Request ( "ls" , path ) . Exec ( context . Background ( ) , & out ) if err != nil { return nil , err } if len ( out . Objects ) != 1 { return nil , errors . New ( "bad response from server" ) } return out . Objects [ 0 ] . Links , nil }
3493	func ( s * Shell ) Pin ( path string ) error { return s . Request ( "pin/add" , path ) . Option ( "recursive" , true ) . Exec ( context . Background ( ) , nil ) }
3494	func ( s * Shell ) Pins ( ) ( map [ string ] PinInfo , error ) { var raw struct { Keys map [ string ] PinInfo } return raw . Keys , s . Request ( "pin/ls" ) . Exec ( context . Background ( ) , & raw ) }
3495	func ( s * Shell ) Version ( ) ( string , string , error ) { ver := struct { Version string Commit string } { } if err := s . Request ( "version" ) . Exec ( context . Background ( ) , & ver ) ; err != nil { return "" , "" , err } return ver . Version , ver . Commit , nil }
3496	func ( s * Shell ) SwarmPeers ( ctx context . Context ) ( * SwarmConnInfos , error ) { v := & SwarmConnInfos { } err := s . Request ( "swarm/peers" ) . Exec ( ctx , & v ) return v , err }
3497	func ( s * Shell ) SwarmConnect ( ctx context . Context , addr ... string ) error { var conn * swarmConnection err := s . Request ( "swarm/connect" ) . Arguments ( addr ... ) . Exec ( ctx , & conn ) return err }
3498	func DagPutOptions ( opts ... DagPutOption ) ( * DagPutSettings , error ) { options := & DagPutSettings { InputEnc : "json" , Kind : "cbor" , Pin : "false" , Hash : "sha2-256" , } for _ , opt := range opts { err := opt ( options ) if err != nil { return nil , err } } return options , nil }
3499	func ( dagOpts ) Pin ( pin string ) DagPutOption { return func ( opts * DagPutSettings ) error { opts . Pin = pin return nil } }
3500	func ( dagOpts ) Kind ( kind string ) DagPutOption { return func ( opts * DagPutSettings ) error { opts . Kind = kind return nil } }
3501	func ( dagOpts ) Hash ( hash string ) DagPutOption { return func ( opts * DagPutSettings ) error { opts . Hash = hash return nil } }
3502	func ( s * Shell ) AddDir ( dir string ) ( string , error ) { stat , err := os . Lstat ( dir ) if err != nil { return "" , err } sf , err := files . NewSerialFile ( dir , false , stat ) if err != nil { return "" , err } slf := files . NewSliceDirectory ( [ ] files . DirEntry { files . FileEntry ( filepath . Base ( dir ) , sf ) } ) reader := files . NewMultiFileReader ( slf , true ) resp , err := s . Request ( "add" ) . Option ( "recursive" , true ) . Body ( reader ) . Send ( context . Background ( ) ) if err != nil { return "" , nil } defer resp . Close ( ) if resp . Error != nil { return "" , resp . Error } dec := json . NewDecoder ( resp . Output ) var final string for { var out object err = dec . Decode ( & out ) if err != nil { if err == io . EOF { break } return "" , err } final = out . Hash } if final == "" { return "" , errors . New ( "no results received" ) } return final , nil }
3503	func ( s * Shell ) Publish ( node string , value string ) error { var pubResp PublishResponse req := s . Request ( "name/publish" ) if node != "" { req . Arguments ( node ) } req . Arguments ( value ) return req . Exec ( context . Background ( ) , & pubResp ) }
3504	func ( s * Shell ) PublishWithDetails ( contentHash , key string , lifetime , ttl time . Duration , resolve bool ) ( * PublishResponse , error ) { var pubResp PublishResponse req := s . Request ( "name/publish" , contentHash ) . Option ( "resolve" , resolve ) if key != "" { req . Option ( "key" , key ) } if lifetime != 0 { req . Option ( "lifetime" , lifetime ) } if ttl . Seconds ( ) > 0 { req . Option ( "ttl" , ttl ) } err := req . Exec ( context . Background ( ) , & pubResp ) if err != nil { return nil , err } return & pubResp , nil }
3505	func ( pv PlanValue ) ResolveValue ( bindVars map [ string ] * querypb . BindVariable ) ( Value , error ) { switch { case pv . Key != "" : bv , err := pv . lookupValue ( bindVars ) if err != nil { return NULL , err } return MakeTrusted ( bv . Type , bv . Value ) , nil case ! pv . Value . IsNull ( ) : return pv . Value , nil case pv . ListKey != "" || pv . Values != nil : return NULL , errors . New ( "a list was supplied where a single value was expected" ) } return NULL , nil }
3506	func ( pq * ParsedQuery ) GenerateQuery ( bindVariables map [ string ] * querypb . BindVariable , extras map [ string ] Encodable ) ( [ ] byte , error ) { if len ( pq . bindLocations ) == 0 { return [ ] byte ( pq . Query ) , nil } buf := bytes . NewBuffer ( make ( [ ] byte , 0 , len ( pq . Query ) ) ) current := 0 for _ , loc := range pq . bindLocations { buf . WriteString ( pq . Query [ current : loc . offset ] ) name := pq . Query [ loc . offset : loc . offset + loc . length ] if encodable , ok := extras [ name [ 1 : ] ] ; ok { encodable . EncodeSQL ( buf ) } else { supplied , _ , err := FetchBindVar ( name , bindVariables ) if err != nil { return nil , err } EncodeValue ( buf , supplied ) } current = loc . offset + loc . length } buf . WriteString ( pq . Query [ current : ] ) return buf . Bytes ( ) , nil }
3507	func EncodeValue ( buf * bytes . Buffer , value * querypb . BindVariable ) { if value . Type != querypb . Type_TUPLE { v , _ := sqltypes . BindVariableToValue ( value ) v . EncodeSQL ( buf ) return } buf . WriteByte ( '(' ) for i , bv := range value . Values { if i != 0 { buf . WriteString ( ", " ) } sqltypes . ProtoToValue ( bv ) . EncodeSQL ( buf ) } buf . WriteByte ( ')' ) }
3508	func ( tkn * Tokenizer ) Lex ( lval * yySymType ) int { typ , val := tkn . Scan ( ) for typ == COMMENT { if tkn . AllowComments { break } typ , val = tkn . Scan ( ) } lval . bytes = val tkn . lastToken = val return typ }
3509	func ( tkn * Tokenizer ) skipStatement ( ) { ch := tkn . lastChar for ch != ';' && ch != eofChar { tkn . next ( ) ch = tkn . lastChar } }
3510	func ( tkn * Tokenizer ) reset ( ) { tkn . ParseTree = nil tkn . partialDDL = nil tkn . specialComment = nil tkn . posVarIndex = 0 tkn . nesting = 0 tkn . ForceEOF = false }
3511	func Preview ( sql string ) int { trimmed := StripLeadingComments ( sql ) firstWord := trimmed if end := strings . IndexFunc ( trimmed , unicode . IsSpace ) ; end != - 1 { firstWord = trimmed [ : end ] } firstWord = strings . TrimLeftFunc ( firstWord , func ( r rune ) bool { return ! unicode . IsLetter ( r ) } ) loweredFirstWord := strings . ToLower ( firstWord ) switch loweredFirstWord { case "select" : return StmtSelect case "stream" : return StmtStream case "insert" : return StmtInsert case "replace" : return StmtReplace case "update" : return StmtUpdate case "delete" : return StmtDelete } trimmedNoComments , _ := SplitMarginComments ( trimmed ) switch strings . ToLower ( trimmedNoComments ) { case "begin" , "start transaction" : return StmtBegin case "commit" : return StmtCommit case "rollback" : return StmtRollback } switch loweredFirstWord { case "create" , "alter" , "rename" , "drop" , "truncate" : return StmtDDL case "set" : return StmtSet case "show" : return StmtShow case "use" : return StmtUse case "analyze" , "describe" , "desc" , "explain" , "repair" , "optimize" : return StmtOther } if strings . Index ( trimmed , "/*!" ) == 0 { return StmtComment } return StmtUnknown }
3512	func NewPlanValue ( node Expr ) ( sqltypes . PlanValue , error ) { switch node := node . ( type ) { case * SQLVal : switch node . Type { case ValArg : return sqltypes . PlanValue { Key : string ( node . Val [ 1 : ] ) } , nil case IntVal : n , err := sqltypes . NewIntegral ( string ( node . Val ) ) if err != nil { return sqltypes . PlanValue { } , fmt . Errorf ( "%v" , err ) } return sqltypes . PlanValue { Value : n } , nil case StrVal : return sqltypes . PlanValue { Value : sqltypes . MakeTrusted ( sqltypes . VarBinary , node . Val ) } , nil case HexVal : v , err := node . HexDecode ( ) if err != nil { return sqltypes . PlanValue { } , fmt . Errorf ( "%v" , err ) } return sqltypes . PlanValue { Value : sqltypes . MakeTrusted ( sqltypes . VarBinary , v ) } , nil } case ListArg : return sqltypes . PlanValue { ListKey : string ( node [ 2 : ] ) } , nil case ValTuple : pv := sqltypes . PlanValue { Values : make ( [ ] sqltypes . PlanValue , 0 , len ( node ) ) , } for _ , val := range node { innerpv , err := NewPlanValue ( val ) if err != nil { return sqltypes . PlanValue { } , err } if innerpv . ListKey != "" || innerpv . Values != nil { return sqltypes . PlanValue { } , errors . New ( "unsupported: nested lists" ) } pv . Values = append ( pv . Values , innerpv ) } return pv , nil case * NullVal : return sqltypes . PlanValue { } , nil } return sqltypes . PlanValue { } , fmt . Errorf ( "expression is too complex '%v'" , String ( node ) ) }
3513	func StringIn ( str string , values ... string ) bool { for _ , val := range values { if str == val { return true } } return false }
3514	func NewTrackedBuffer ( nodeFormatter NodeFormatter ) * TrackedBuffer { return & TrackedBuffer { Buffer : new ( bytes . Buffer ) , nodeFormatter : nodeFormatter , } }
3515	func NewStringArena ( size int ) * StringArena { sa := & StringArena { buf : make ( [ ] byte , 0 , size ) } pbytes := ( * reflect . SliceHeader ) ( unsafe . Pointer ( & sa . buf ) ) pstring := ( * reflect . StringHeader ) ( unsafe . Pointer ( & sa . str ) ) pstring . Data = pbytes . Data pstring . Len = pbytes . Cap return sa }
3516	func ( sa * StringArena ) NewString ( b [ ] byte ) string { if len ( b ) == 0 { return "" } if len ( sa . buf ) + len ( b ) > cap ( sa . buf ) { return string ( b ) } start := len ( sa . buf ) sa . buf = append ( sa . buf , b ... ) return sa . str [ start : start + len ( b ) ] }
3517	func ( sa * StringArena ) SpaceLeft ( ) int { return cap ( sa . buf ) - len ( sa . buf ) }
3518	func ParseStrictDDL ( sql string ) ( Statement , error ) { tokenizer := NewStringTokenizer ( sql ) if yyParse ( tokenizer ) != 0 { return nil , tokenizer . LastError } return tokenizer . ParseTree , nil }
3519	func ParseNext ( tokenizer * Tokenizer ) ( Statement , error ) { if tokenizer . lastChar == ';' { tokenizer . next ( ) tokenizer . skipBlank ( ) } if tokenizer . lastChar == eofChar { return nil , io . EOF } tokenizer . reset ( ) tokenizer . multi = true if yyParse ( tokenizer ) != 0 { if tokenizer . partialDDL != nil { tokenizer . ParseTree = tokenizer . partialDDL return tokenizer . ParseTree , nil } return nil , tokenizer . LastError } return tokenizer . ParseTree , nil }
3520	func Append ( buf * bytes . Buffer , node SQLNode ) { tbuf := & TrackedBuffer { Buffer : buf , } node . Format ( tbuf ) }
3521	func ExprFromValue ( value sqltypes . Value ) ( Expr , error ) { switch { case value . Type ( ) == sqltypes . Null : return & NullVal { } , nil case value . IsIntegral ( ) : return NewIntVal ( value . ToBytes ( ) ) , nil case value . IsFloat ( ) || value . Type ( ) == sqltypes . Decimal : return NewFloatVal ( value . ToBytes ( ) ) , nil case value . IsQuoted ( ) : return NewStrVal ( value . ToBytes ( ) ) , nil default : return nil , fmt . Errorf ( "cannot convert value %v to AST" , value ) } }
3522	func Backtick ( in string ) string { var buf bytes . Buffer buf . WriteByte ( '`' ) for _ , c := range in { buf . WriteRune ( c ) if c == '`' { buf . WriteByte ( '`' ) } } buf . WriteByte ( '`' ) return buf . String ( ) }
3523	func NewValue ( typ querypb . Type , val [ ] byte ) ( v Value , err error ) { switch { case IsSigned ( typ ) : if _ , err := strconv . ParseInt ( string ( val ) , 0 , 64 ) ; err != nil { return NULL , err } return MakeTrusted ( typ , val ) , nil case IsUnsigned ( typ ) : if _ , err := strconv . ParseUint ( string ( val ) , 0 , 64 ) ; err != nil { return NULL , err } return MakeTrusted ( typ , val ) , nil case IsFloat ( typ ) || typ == Decimal : if _ , err := strconv . ParseFloat ( string ( val ) , 64 ) ; err != nil { return NULL , err } return MakeTrusted ( typ , val ) , nil case IsQuoted ( typ ) || typ == Null : return MakeTrusted ( typ , val ) , nil } return NULL , fmt . Errorf ( "invalid type specified for MakeValue: %v" , typ ) }
3524	func ( v Value ) String ( ) string { if v . typ == Null { return "NULL" } if v . IsQuoted ( ) { return fmt . Sprintf ( "%v(%q)" , v . typ , v . val ) } return fmt . Sprintf ( "%v(%s)" , v . typ , v . val ) }
3525	func ( v Value ) EncodeSQL ( b BinWriter ) { switch { case v . typ == Null : b . Write ( nullstr ) case v . IsQuoted ( ) : encodeBytesSQL ( v . val , b ) default : b . Write ( v . val ) } }
3526	func ( iv InsertValues ) EncodeSQL ( buf * bytes . Buffer ) { for i , rows := range iv { if i != 0 { buf . WriteString ( ", " ) } buf . WriteByte ( '(' ) for j , bv := range rows { if j != 0 { buf . WriteString ( ", " ) } bv . EncodeSQL ( buf ) } buf . WriteByte ( ')' ) } }
3527	func ( tpl * TupleEqualityList ) EncodeSQL ( buf * bytes . Buffer ) { if len ( tpl . Columns ) == 1 { tpl . encodeAsIn ( buf ) return } tpl . encodeAsEquality ( buf ) }
3528	func ( nz * normalizer ) WalkStatement ( node SQLNode ) ( bool , error ) { switch node := node . ( type ) { case * Select : _ = Walk ( nz . WalkSelect , node ) return false , nil case * SQLVal : nz . convertSQLVal ( node ) case * ComparisonExpr : nz . convertComparison ( node ) } return true , nil }
3529	func ( nz * normalizer ) WalkSelect ( node SQLNode ) ( bool , error ) { switch node := node . ( type ) { case * SQLVal : nz . convertSQLValDedup ( node ) case * ComparisonExpr : nz . convertComparison ( node ) } return true , nil }
3530	func BindVariablesEqual ( x , y map [ string ] * querypb . BindVariable ) bool { return reflect . DeepEqual ( & querypb . BoundQuery { BindVariables : x } , & querypb . BoundQuery { BindVariables : y } ) }
3531	func New ( options ... Options ) * JWTMiddleware { var opts Options if len ( options ) == 0 { opts = Options { } } else { opts = options [ 0 ] } if opts . UserProperty == "" { opts . UserProperty = "user" } if opts . ErrorHandler == nil { opts . ErrorHandler = OnError } if opts . Extractor == nil { opts . Extractor = FromAuthHeader } return & JWTMiddleware { Options : opts , } }
3532	func ( m * JWTMiddleware ) HandlerWithNext ( w http . ResponseWriter , r * http . Request , next http . HandlerFunc ) { err := m . CheckJWT ( w , r ) if err == nil && next != nil { next ( w , r ) } }
3533	func FromAuthHeader ( r * http . Request ) ( string , error ) { authHeader := r . Header . Get ( "Authorization" ) if authHeader == "" { return "" , nil } authHeaderParts := strings . Split ( authHeader , " " ) if len ( authHeaderParts ) != 2 || strings . ToLower ( authHeaderParts [ 0 ] ) != "bearer" { return "" , errors . New ( "Authorization header format must be Bearer {token}" ) } return authHeaderParts [ 1 ] , nil }
3534	func FromParameter ( param string ) TokenExtractor { return func ( r * http . Request ) ( string , error ) { return r . URL . Query ( ) . Get ( param ) , nil } }
3535	func FromFirst ( extractors ... TokenExtractor ) TokenExtractor { return func ( r * http . Request ) ( string , error ) { for _ , ex := range extractors { token , err := ex ( r ) if err != nil { return "" , err } if token != "" { return token , nil } } return "" , nil } }
3536	func ( p * PubSub ) getHelloPacket ( ) * RPC { var rpc RPC for t := range p . myTopics { as := & pb . RPC_SubOpts { Topicid : proto . String ( t ) , Subscribe : proto . Bool ( true ) , } rpc . Subscriptions = append ( rpc . Subscriptions , as ) } return & rpc }
3537	func NewFloodsubWithProtocols ( ctx context . Context , h host . Host , ps [ ] protocol . ID , opts ... Option ) ( * PubSub , error ) { rt := & FloodSubRouter { protocols : ps , } return NewPubSub ( ctx , h , rt , opts ... ) }
3538	func NewFloodSub ( ctx context . Context , h host . Host , opts ... Option ) ( * PubSub , error ) { return NewFloodsubWithProtocols ( ctx , h , [ ] protocol . ID { FloodSubID } , opts ... ) }
3539	func NewLRUBlacklist ( cap int ) ( Blacklist , error ) { c , err := lru . New ( cap ) if err != nil { return nil , err } b := & LRUBlacklist { lru : c } return b , nil }
3540	func NewRandomSub ( ctx context . Context , h host . Host , opts ... Option ) ( * PubSub , error ) { rt := & RandomSubRouter { peers : make ( map [ peer . ID ] protocol . ID ) , } return NewPubSub ( ctx , h , rt , opts ... ) }
3541	func NewGossipSub ( ctx context . Context , h host . Host , opts ... Option ) ( * PubSub , error ) { rt := & GossipSubRouter { peers : make ( map [ peer . ID ] protocol . ID ) , mesh : make ( map [ string ] map [ peer . ID ] struct { } ) , fanout : make ( map [ string ] map [ peer . ID ] struct { } ) , lastpub : make ( map [ string ] int64 ) , gossip : make ( map [ peer . ID ] [ ] * pb . ControlIHave ) , control : make ( map [ peer . ID ] * pb . ControlMessage ) , mcache : NewMessageCache ( GossipSubHistoryGossip , GossipSubHistoryLength ) , } return NewPubSub ( ctx , h , rt , opts ... ) }
3542	func NewPubSub ( ctx context . Context , h host . Host , rt PubSubRouter , opts ... Option ) ( * PubSub , error ) { ps := & PubSub { host : h , ctx : ctx , rt : rt , signID : h . ID ( ) , signKey : h . Peerstore ( ) . PrivKey ( h . ID ( ) ) , signStrict : true , incoming : make ( chan * RPC , 32 ) , publish : make ( chan * Message ) , newPeers : make ( chan peer . ID ) , newPeerStream : make ( chan inet . Stream ) , newPeerError : make ( chan peer . ID ) , peerDead : make ( chan peer . ID ) , cancelCh : make ( chan * Subscription ) , getPeers : make ( chan * listPeerReq ) , addSub : make ( chan * addSubReq ) , getTopics : make ( chan * topicReq ) , sendMsg : make ( chan * sendReq , 32 ) , addVal : make ( chan * addValReq ) , rmVal : make ( chan * rmValReq ) , validateThrottle : make ( chan struct { } , defaultValidateThrottle ) , eval : make ( chan func ( ) ) , myTopics : make ( map [ string ] map [ * Subscription ] struct { } ) , topics : make ( map [ string ] map [ peer . ID ] struct { } ) , peers : make ( map [ peer . ID ] chan * RPC ) , topicVals : make ( map [ string ] * topicVal ) , blacklist : NewMapBlacklist ( ) , blacklistPeer : make ( chan peer . ID ) , seenMessages : timecache . NewTimeCache ( TimeCacheDuration ) , counter : uint64 ( time . Now ( ) . UnixNano ( ) ) , } for _ , opt := range opts { err := opt ( ps ) if err != nil { return nil , err } } if ps . signStrict && ps . signKey == nil { return nil , fmt . Errorf ( "strict signature verification enabled but message signing is disabled" ) } rt . Attach ( ps ) for _ , id := range rt . Protocols ( ) { h . SetStreamHandler ( id , ps . handleNewStream ) } h . Network ( ) . Notify ( ( * PubSubNotif ) ( ps ) ) go ps . processLoop ( ctx ) return ps , nil }
3543	func WithValidateThrottle ( n int ) Option { return func ( ps * PubSub ) error { ps . validateThrottle = make ( chan struct { } , n ) return nil } }
3544	func WithBlacklist ( b Blacklist ) Option { return func ( p * PubSub ) error { p . blacklist = b return nil } }
3545	func ( p * PubSub ) handleRemoveSubscription ( sub * Subscription ) { subs := p . myTopics [ sub . topic ] if subs == nil { return } sub . err = fmt . Errorf ( "subscription cancelled by calling sub.Cancel()" ) close ( sub . ch ) delete ( subs , sub ) if len ( subs ) == 0 { delete ( p . myTopics , sub . topic ) p . announce ( sub . topic , false ) p . rt . Leave ( sub . topic ) } }
3546	func ( p * PubSub ) handleAddSubscription ( req * addSubReq ) { sub := req . sub subs := p . myTopics [ sub . topic ] if len ( subs ) == 0 { p . announce ( sub . topic , true ) p . rt . Join ( sub . topic ) } if subs == nil { p . myTopics [ sub . topic ] = make ( map [ * Subscription ] struct { } ) subs = p . myTopics [ sub . topic ] } sub . ch = make ( chan * Message , 32 ) sub . cancelCh = p . cancelCh p . myTopics [ sub . topic ] [ sub ] = struct { } { } req . resp <- sub }
3547	func ( p * PubSub ) announce ( topic string , sub bool ) { subopt := & pb . RPC_SubOpts { Topicid : & topic , Subscribe : & sub , } out := rpcWithSubs ( subopt ) for pid , peer := range p . peers { select { case peer <- out : default : log . Infof ( "Can't send announce message to peer %s: queue full; scheduling retry" , pid ) go p . announceRetry ( pid , topic , sub ) } } }
3548	func ( p * PubSub ) notifySubs ( msg * pb . Message ) { for _ , topic := range msg . GetTopicIDs ( ) { subs := p . myTopics [ topic ] for f := range subs { select { case f . ch <- & Message { msg } : default : log . Infof ( "Can't deliver message to subscription for topic %s; subscriber too slow" , topic ) } } } }
3549	func ( p * PubSub ) seenMessage ( id string ) bool { return p . seenMessages . Has ( id ) }
3550	func ( p * PubSub ) subscribedToMsg ( msg * pb . Message ) bool { if len ( p . myTopics ) == 0 { return false } for _ , t := range msg . GetTopicIDs ( ) { if _ , ok := p . myTopics [ t ] ; ok { return true } } return false }
3551	func msgID ( pmsg * pb . Message ) string { return string ( pmsg . GetFrom ( ) ) + string ( pmsg . GetSeqno ( ) ) }
3552	func ( p * PubSub ) pushMsg ( vals [ ] * topicVal , src peer . ID , msg * Message ) { if p . blacklist . Contains ( src ) { log . Warningf ( "dropping message from blacklisted peer %s" , src ) return } if p . blacklist . Contains ( msg . GetFrom ( ) ) { log . Warningf ( "dropping message from blacklisted source %s" , src ) return } if p . signStrict && msg . Signature == nil { log . Debugf ( "dropping unsigned message from %s" , src ) return } id := msgID ( msg . Message ) if p . seenMessage ( id ) { return } if len ( vals ) > 0 || msg . Signature != nil { select { case p . validateThrottle <- struct { } { } : go func ( ) { p . validate ( vals , src , msg ) <- p . validateThrottle } ( ) default : log . Warningf ( "message validation throttled; dropping message from %s" , src ) } return } p . publishMessage ( src , msg . Message ) }
3553	func ( p * PubSub ) validate ( vals [ ] * topicVal , src peer . ID , msg * Message ) { if msg . Signature != nil { if ! p . validateSignature ( msg ) { log . Warningf ( "message signature validation failed; dropping message from %s" , src ) return } } if len ( vals ) > 0 { if ! p . validateTopic ( vals , src , msg ) { log . Warningf ( "message validation failed; dropping message from %s" , src ) return } } p . sendMsg <- & sendReq { from : src , msg : msg , } }
3554	func ( p * PubSub ) validateSingleTopic ( val * topicVal , src peer . ID , msg * Message ) bool { select { case val . validateThrottle <- struct { } { } : ctx , cancel := context . WithCancel ( p . ctx ) defer cancel ( ) res := val . validateMsg ( ctx , src , msg ) <- val . validateThrottle return res default : log . Debugf ( "validation throttled for topic %s" , val . topic ) return false } }
3555	func ( p * PubSub ) getValidators ( msg * Message ) [ ] * topicVal { var vals [ ] * topicVal for _ , topic := range msg . GetTopicIDs ( ) { val , ok := p . topicVals [ topic ] if ! ok { continue } vals = append ( vals , val ) } return vals }
3556	func ( p * PubSub ) Subscribe ( topic string , opts ... SubOpt ) ( * Subscription , error ) { td := pb . TopicDescriptor { Name : & topic } return p . SubscribeByTopicDescriptor ( & td , opts ... ) }
3557	func ( p * PubSub ) SubscribeByTopicDescriptor ( td * pb . TopicDescriptor , opts ... SubOpt ) ( * Subscription , error ) { if td . GetAuth ( ) . GetMode ( ) != pb . TopicDescriptor_AuthOpts_NONE { return nil , fmt . Errorf ( "auth mode not yet supported" ) } if td . GetEnc ( ) . GetMode ( ) != pb . TopicDescriptor_EncOpts_NONE { return nil , fmt . Errorf ( "encryption mode not yet supported" ) } sub := & Subscription { topic : td . GetName ( ) , } for _ , opt := range opts { err := opt ( sub ) if err != nil { return nil , err } } out := make ( chan * Subscription , 1 ) p . addSub <- & addSubReq { sub : sub , resp : out , } return <- out , nil }
3558	func ( p * PubSub ) GetTopics ( ) [ ] string { out := make ( chan [ ] string , 1 ) p . getTopics <- & topicReq { resp : out } return <- out }
3559	func ( p * PubSub ) Publish ( topic string , data [ ] byte ) error { seqno := p . nextSeqno ( ) m := & pb . Message { Data : data , TopicIDs : [ ] string { topic } , From : [ ] byte ( p . host . ID ( ) ) , Seqno : seqno , } if p . signKey != nil { m . From = [ ] byte ( p . signID ) err := signMessage ( p . signID , p . signKey , m ) if err != nil { return err } } p . publish <- & Message { m } return nil }
3560	func ( p * PubSub ) ListPeers ( topic string ) [ ] peer . ID { out := make ( chan [ ] peer . ID ) p . getPeers <- & listPeerReq { resp : out , topic : topic , } return <- out }
3561	func WithValidatorTimeout ( timeout time . Duration ) ValidatorOpt { return func ( addVal * addValReq ) error { addVal . timeout = timeout return nil } }
3562	func WithValidatorConcurrency ( n int ) ValidatorOpt { return func ( addVal * addValReq ) error { addVal . throttle = n return nil } }
3563	func ( p * PubSub ) RegisterTopicValidator ( topic string , val Validator , opts ... ValidatorOpt ) error { addVal := & addValReq { topic : topic , validate : val , resp : make ( chan error , 1 ) , } for _ , opt := range opts { err := opt ( addVal ) if err != nil { return err } } p . addVal <- addVal return <- addVal . resp }
3564	func ( p * PubSub ) UnregisterTopicValidator ( topic string ) error { rmVal := & rmValReq { topic : topic , resp : make ( chan error , 1 ) , } p . rmVal <- rmVal return <- rmVal . resp }
3565	func DefaultMetricPrefix ( name string , tags map [ string ] string ) string { return MetricWithPrefix ( "tchannel." , name , tags ) }
3566	func MetricWithPrefix ( prefix , name string , tags map [ string ] string ) string { buf := bufPool . Get ( ) . ( * bytes . Buffer ) buf . Reset ( ) if prefix != "" { buf . WriteString ( prefix ) } buf . WriteString ( name ) addKeys := make ( [ ] string , 0 , 5 ) switch { case strings . HasPrefix ( name , "outbound" ) : addKeys = append ( addKeys , "service" , "target-service" , "target-endpoint" ) if strings . HasPrefix ( name , "outbound.calls.retries" ) { addKeys = append ( addKeys , "retry-count" ) } case strings . HasPrefix ( name , "inbound" ) : addKeys = append ( addKeys , "calling-service" , "service" , "endpoint" ) } for _ , k := range addKeys { buf . WriteByte ( '.' ) v , ok := tags [ k ] if ok { writeClean ( buf , v ) } else { buf . WriteString ( "no-" ) buf . WriteString ( k ) } } m := buf . String ( ) bufPool . Put ( buf ) return m }
3567	func NewClient ( ch * tchannel . Channel , targetService string , opts * ClientOptions ) * Client { client := & Client { ch : ch , targetService : targetService , } if opts != nil && opts . HostPort != "" { client . hostPort = opts . HostPort } return client }
3568	func ( c * Client ) Call ( ctx Context , method string , arg , resp interface { } ) error { var ( headers = ctx . Headers ( ) respHeaders map [ string ] string respErr ErrApplication errAt string isOK bool ) err := c . ch . RunWithRetry ( ctx , func ( ctx context . Context , rs * tchannel . RequestState ) error { respHeaders , respErr , isOK = nil , nil , false errAt = "connect" call , err := c . startCall ( ctx , method , & tchannel . CallOptions { Format : tchannel . JSON , RequestState : rs , } ) if err != nil { return err } isOK , errAt , err = makeCall ( call , headers , arg , & respHeaders , resp , & respErr ) return err } ) if err != nil { return fmt . Errorf ( "%s: %v" , errAt , err ) } if ! isOK { return respErr } return nil }
3569	func CallPeer ( ctx Context , peer * tchannel . Peer , serviceName , method string , arg , resp interface { } ) error { call , err := peer . BeginCall ( ctx , serviceName , method , & tchannel . CallOptions { Format : tchannel . JSON } ) if err != nil { return err } return wrapCall ( ctx , call , method , arg , resp ) }
3570	func CallSC ( ctx Context , sc * tchannel . SubChannel , method string , arg , resp interface { } ) error { call , err := sc . BeginCall ( ctx , method , & tchannel . CallOptions { Format : tchannel . JSON } ) if err != nil { return err } return wrapCall ( ctx , call , method , arg , resp ) }
3571	func ReadResponse ( call tchannel . ArgReadable ) ( * http . Response , error ) { var arg2 [ ] byte if err := tchannel . NewArgReader ( call . Arg2Reader ( ) ) . Read ( & arg2 ) ; err != nil { return nil , err } rb := typed . NewReadBuffer ( arg2 ) statusCode := rb . ReadUint16 ( ) message := readVarintString ( rb ) response := & http . Response { StatusCode : int ( statusCode ) , Status : fmt . Sprintf ( "%v %v" , statusCode , message ) , Proto : "HTTP/1.1" , ProtoMajor : 1 , ProtoMinor : 1 , Header : make ( http . Header ) , } readHeaders ( rb , response . Header ) if err := rb . Err ( ) ; err != nil { return nil , err } arg3Reader , err := call . Arg3Reader ( ) if err != nil { return nil , err } response . Body = arg3Reader return response , nil }
3572	func ( w * tchanResponseWriter ) writeHeaders ( ) { wb := typed . NewWriteBufferWithSize ( 10000 ) wb . WriteUint16 ( uint16 ( w . statusCode ) ) writeVarintString ( wb , http . StatusText ( w . statusCode ) ) writeHeaders ( wb , w . headers ) arg2Writer , err := w . response . Arg2Writer ( ) if err != nil { w . err = err return } if _ , w . err = wb . FlushTo ( arg2Writer ) ; w . err != nil { return } if w . err = arg2Writer . Close ( ) ; w . err != nil { return } w . arg3Writer , w . err = w . response . Arg3Writer ( ) }
3573	func ResponseWriter ( response tchannel . ArgWritable ) ( http . ResponseWriter , func ( ) error ) { responseWriter := newTChanResponseWriter ( response ) return responseWriter , responseWriter . finish }
3574	func ReadHeaders ( r io . Reader ) ( map [ string ] string , error ) { reader := typed . NewReader ( r ) m , err := readHeaders ( reader ) reader . Release ( ) return m , err }
3575	func NewTCPRawRelay ( dests [ ] string ) ( Relay , error ) { return newTCPRelay ( dests , func ( _ bool , src , dst net . Conn ) { io . Copy ( src , dst ) } ) }
3576	func NewClient ( ch * tchannel . Channel , config Configuration , opts * ClientOptions ) ( * Client , error ) { client := & Client { tchan : ch , quit : make ( chan struct { } ) } if opts != nil { client . opts = * opts } if client . opts . Timeout == 0 { client . opts . Timeout = 3 * time . Second } if client . opts . TimeoutPerAttempt == 0 { client . opts . TimeoutPerAttempt = time . Second } if client . opts . Handler == nil { client . opts . Handler = nullHandler { } } if client . opts . TimeSleep == nil { client . opts . TimeSleep = time . Sleep } if err := parseConfig ( & config ) ; err != nil { return nil , err } for _ , node := range config . InitialNodes { addPeer ( ch , node ) } client . jsonClient = tjson . NewClient ( ch , hyperbahnServiceName , nil ) thriftClient := tthrift . NewClient ( ch , hyperbahnServiceName , nil ) client . hyperbahnClient = htypes . NewTChanHyperbahnClient ( thriftClient ) return client , nil }
3577	func ( c * Client ) Advertise ( otherServices ... tchannel . Registrar ) error { c . getServiceNames ( otherServices ) if err := c . initialAdvertise ( ) ; err != nil { return err } c . opts . Handler . On ( Advertised ) go c . advertiseLoop ( ) return nil }
3578	func ( h * handler ) Handle ( tctx context . Context , call * tchannel . InboundCall ) error { var headers map [ string ] string if err := tchannel . NewArgReader ( call . Arg2Reader ( ) ) . ReadJSON ( & headers ) ; err != nil { return fmt . Errorf ( "arg2 read failed: %v" , err ) } tctx = tchannel . ExtractInboundSpan ( tctx , call , headers , h . tracer ( ) ) ctx := WithHeaders ( tctx , headers ) var arg3 reflect . Value var callArg reflect . Value if h . isArgMap { arg3 = reflect . New ( h . argType ) callArg = arg3 . Elem ( ) } else { arg3 = reflect . New ( h . argType . Elem ( ) ) callArg = arg3 } if err := tchannel . NewArgReader ( call . Arg3Reader ( ) ) . ReadJSON ( arg3 . Interface ( ) ) ; err != nil { return fmt . Errorf ( "arg3 read failed: %v" , err ) } args := [ ] reflect . Value { reflect . ValueOf ( ctx ) , callArg } results := h . handler . Call ( args ) res := results [ 0 ] . Interface ( ) err := results [ 1 ] . Interface ( ) if err != nil { if serr , ok := err . ( tchannel . SystemError ) ; ok { return call . Response ( ) . SendSystemError ( serr ) } call . Response ( ) . SetApplicationError ( ) res = struct { Type string `json:"type"` Message string `json:"message"` } { Type : "error" , Message : err . ( error ) . Error ( ) , } } if err := tchannel . NewArgWriter ( call . Response ( ) . Arg2Writer ( ) ) . WriteJSON ( ctx . ResponseHeaders ( ) ) ; err != nil { return err } return tchannel . NewArgWriter ( call . Response ( ) . Arg3Writer ( ) ) . WriteJSON ( res ) }
3579	func ( s * Server ) Start ( ) error { if s . HostPort == "" { s . HostPort = ":" + common . DefaultServerPort } channelOpts := & tchannel . ChannelOptions { Tracer : s . Tracer , } ch , err := tchannel . NewChannel ( common . DefaultServiceName , channelOpts ) if err != nil { return err } if err := ch . ListenAndServe ( s . HostPort ) ; err != nil { return err } s . HostPort = ch . PeerInfo ( ) . HostPort log . Printf ( "Started tchannel server at %s\n" , \n ) s . HostPort s . Ch = ch }
3580	func ( s * Server ) Port ( ) string { hostPortSplit := strings . Split ( s . HostPort , ":" ) port := hostPortSplit [ len ( hostPortSplit ) - 1 ] return port }
3581	func ( l * PeerList ) SetStrategy ( sc ScoreCalculator ) { l . Lock ( ) defer l . Unlock ( ) l . scoreCalculator = sc for _ , ps := range l . peersByHostPort { newScore := l . scoreCalculator . GetScore ( ps . Peer ) l . updatePeer ( ps , newScore ) } }
3582	func ( l * PeerList ) Add ( hostPort string ) * Peer { if ps , ok := l . exists ( hostPort ) ; ok { return ps . Peer } l . Lock ( ) defer l . Unlock ( ) if p , ok := l . peersByHostPort [ hostPort ] ; ok { return p . Peer } p := l . parent . Add ( hostPort ) p . addSC ( ) ps := newPeerScore ( p , l . scoreCalculator . GetScore ( p ) ) l . peersByHostPort [ hostPort ] = ps l . peerHeap . addPeer ( ps ) return p }
3583	func ( l * PeerList ) GetNew ( prevSelected map [ string ] struct { } ) ( * Peer , error ) { l . Lock ( ) defer l . Unlock ( ) if l . peerHeap . Len ( ) == 0 { return nil , ErrNoPeers } peer := l . choosePeer ( prevSelected , true ) if peer == nil { peer = l . choosePeer ( prevSelected , false ) } if peer == nil { return nil , ErrNoNewPeers } return peer , nil }
3584	func ( l * PeerList ) Get ( prevSelected map [ string ] struct { } ) ( * Peer , error ) { peer , err := l . GetNew ( prevSelected ) if err == ErrNoNewPeers { l . Lock ( ) peer = l . choosePeer ( nil , false ) l . Unlock ( ) } else if err != nil { return nil , err } if peer == nil { return nil , ErrNoPeers } return peer , nil }
3585	func ( l * PeerList ) Remove ( hostPort string ) error { l . Lock ( ) defer l . Unlock ( ) p , ok := l . peersByHostPort [ hostPort ] if ! ok { return ErrPeerNotFound } p . delSC ( ) delete ( l . peersByHostPort , hostPort ) l . peerHeap . removePeer ( p ) return nil }
3586	func ( l * PeerList ) Copy ( ) map [ string ] * Peer { l . RLock ( ) defer l . RUnlock ( ) listCopy := make ( map [ string ] * Peer ) for k , v := range l . peersByHostPort { listCopy [ k ] = v . Peer } return listCopy }
3587	func ( l * PeerList ) Len ( ) int { l . RLock ( ) defer l . RUnlock ( ) return l . peerHeap . Len ( ) }
3588	func ( l * PeerList ) exists ( hostPort string ) ( * peerScore , bool ) { l . RLock ( ) ps , ok := l . peersByHostPort [ hostPort ] l . RUnlock ( ) return ps , ok }
3589	func ( l * PeerList ) getPeerScore ( hostPort string ) ( * peerScore , uint64 , bool ) { ps , ok := l . peersByHostPort [ hostPort ] if ! ok { return nil , 0 , false } return ps , ps . score , ok }
3590	func ( l * PeerList ) onPeerChange ( p * Peer ) { l . RLock ( ) ps , psScore , ok := l . getPeerScore ( p . hostPort ) sc := l . scoreCalculator l . RUnlock ( ) if ! ok { return } newScore := sc . GetScore ( ps . Peer ) if newScore == psScore { return } l . Lock ( ) l . updatePeer ( ps , newScore ) l . Unlock ( ) }
3591	func ( l * PeerList ) updatePeer ( ps * peerScore , newScore uint64 ) { if ps . score == newScore { return } ps . score = newScore l . peerHeap . updatePeer ( ps ) }
3592	func ( p * Peer ) getConn ( i int ) * Connection { inboundLen := len ( p . inboundConnections ) if i < inboundLen { return p . inboundConnections [ i ] } return p . outboundConnections [ i - inboundLen ] }
3593	func ( p * Peer ) GetConnection ( ctx context . Context ) ( * Connection , error ) { if activeConn , ok := p . getActiveConn ( ) ; ok { return activeConn , nil } p . newConnLock . Lock ( ) defer p . newConnLock . Unlock ( ) if activeConn , ok := p . getActiveConn ( ) ; ok { return activeConn , nil } return p . Connect ( ctx ) }
3594	func ( p * Peer ) getConnectionRelay ( timeout time . Duration ) ( * Connection , error ) { if conn , ok := p . getActiveConn ( ) ; ok { return conn , nil } p . newConnLock . Lock ( ) defer p . newConnLock . Unlock ( ) if activeConn , ok := p . getActiveConn ( ) ; ok { return activeConn , nil } ctx , cancel := NewContextBuilder ( timeout ) . HideListeningOnOutbound ( ) . Build ( ) defer cancel ( ) return p . Connect ( ctx ) }
3595	func ( p * Peer ) canRemove ( ) bool { p . RLock ( ) count := len ( p . inboundConnections ) + len ( p . outboundConnections ) + int ( p . scCount ) p . RUnlock ( ) return count == 0 }
3596	func ( p * Peer ) addConnection ( c * Connection , direction connectionDirection ) error { conns := p . connectionsFor ( direction ) if c . readState ( ) != connectionActive { return ErrInvalidConnectionState } p . Lock ( ) * conns = append ( * conns , c ) p . Unlock ( ) p . onStatusChanged ( p ) return nil }
3597	func ( p * Peer ) removeConnection ( connsPtr * [ ] * Connection , changed * Connection ) bool { conns := * connsPtr for i , c := range conns { if c == changed { last := len ( conns ) - 1 conns [ i ] , conns [ last ] = conns [ last ] , nil * connsPtr = conns [ : last ] return true } } return false }
3598	func ( p * Peer ) connectionCloseStateChange ( changed * Connection ) { if changed . IsActive ( ) { return } p . Lock ( ) found := p . removeConnection ( & p . inboundConnections , changed ) if ! found { found = p . removeConnection ( & p . outboundConnections , changed ) } p . Unlock ( ) if found { p . onClosedConnRemoved ( p ) p . onStatusChanged ( p ) } }
3599	func ( p * Peer ) Connect ( ctx context . Context ) ( * Connection , error ) { return p . channel . Connect ( ctx , p . hostPort ) }
3600	func ( p * Peer ) BeginCall ( ctx context . Context , serviceName , methodName string , callOptions * CallOptions ) ( * OutboundCall , error ) { if callOptions == nil { callOptions = defaultCallOptions } callOptions . RequestState . AddSelectedPeer ( p . HostPort ( ) ) if err := validateCall ( ctx , serviceName , methodName , callOptions ) ; err != nil { return nil , err } conn , err := p . GetConnection ( ctx ) if err != nil { return nil , err } call , err := conn . beginCall ( ctx , serviceName , methodName , callOptions ) if err != nil { return nil , err } return call , err }
3601	func ( p * Peer ) NumConnections ( ) ( inbound int , outbound int ) { p . RLock ( ) inbound = len ( p . inboundConnections ) outbound = len ( p . outboundConnections ) p . RUnlock ( ) return inbound , outbound }
3602	func ( p * Peer ) NumPendingOutbound ( ) int { count := 0 p . RLock ( ) for _ , c := range p . outboundConnections { count += c . outbound . count ( ) } for _ , c := range p . inboundConnections { count += c . outbound . count ( ) } p . RUnlock ( ) return count }
3603	func isEphemeralHostPort ( hostPort string ) bool { return hostPort == "" || hostPort == ephemeralHostPort || strings . HasSuffix ( hostPort , ":0" ) }
3604	func ( h * kvHandler ) Get ( ctx thrift . Context , key string ) ( string , error ) { if err := isValidKey ( key ) ; err != nil { return "" , err } h . RLock ( ) defer h . RUnlock ( ) if val , ok := h . vals [ key ] ; ok { return val , nil } return "" , & keyvalue . KeyNotFound { Key : key } }
3605	func ( h * kvHandler ) Set ( ctx thrift . Context , key , value string ) error { if err := isValidKey ( key ) ; err != nil { return err } h . Lock ( ) defer h . Unlock ( ) h . vals [ key ] = value ctx . SetResponseHeaders ( map [ string ] string { "count" : fmt . Sprint ( len ( h . vals ) ) } ) return nil }
3606	func ( h * kvHandler ) ClearAll ( ctx thrift . Context ) error { if ! isAdmin ( ctx ) { return & keyvalue . NotAuthorized { } } h . Lock ( ) defer h . Unlock ( ) h . vals = make ( map [ string ] string ) return nil }
3607	func NewChannel ( serviceName string , opts * ChannelOptions ) ( * Channel , error ) { if serviceName == "" { return nil , ErrNoServiceName } if opts == nil { opts = & ChannelOptions { } } processName := opts . ProcessName if processName == "" { processName = fmt . Sprintf ( "%s[%d]" , filepath . Base ( os . Args [ 0 ] ) , os . Getpid ( ) ) } logger := opts . Logger if logger == nil { logger = NullLogger } statsReporter := opts . StatsReporter if statsReporter == nil { statsReporter = NullStatsReporter } timeNow := opts . TimeNow if timeNow == nil { timeNow = time . Now } timeTicker := opts . TimeTicker if timeTicker == nil { timeTicker = time . NewTicker } chID := _nextChID . Inc ( ) logger = logger . WithFields ( LogField { "serviceName" , serviceName } , LogField { "process" , processName } , LogField { "chID" , chID } , ) if err := opts . validateIdleCheck ( ) ; err != nil { return nil , err } ch := & Channel { channelConnectionCommon : channelConnectionCommon { log : logger , relayLocal : toStringSet ( opts . RelayLocalHandlers ) , statsReporter : statsReporter , subChannels : & subChannelMap { } , timeNow : timeNow , timeTicker : timeTicker , tracer : opts . Tracer , } , chID : chID , connectionOptions : opts . DefaultConnectionOptions . withDefaults ( ) , relayHost : opts . RelayHost , relayMaxTimeout : validateRelayMaxTimeout ( opts . RelayMaxTimeout , logger ) , relayTimerVerify : opts . RelayTimerVerification , closed : make ( chan struct { } ) , } ch . peers = newRootPeerList ( ch , opts . OnPeerStatusChanged ) . newChild ( ) if opts . Handler != nil { ch . handler = opts . Handler } else { ch . handler = channelHandler { ch } } ch . mutable . peerInfo = LocalPeerInfo { PeerInfo : PeerInfo { ProcessName : processName , HostPort : ephemeralHostPort , IsEphemeral : true , Version : PeerVersion { Language : "go" , LanguageVersion : strings . TrimPrefix ( runtime . Version ( ) , "go" ) , TChannelVersion : VersionInfo , } , } , ServiceName : serviceName , } ch . mutable . state = ChannelClient ch . mutable . conns = make ( map [ uint32 ] * Connection ) ch . createCommonStats ( ) if opts . Handler == nil { ch . registerInternal ( ) } registerNewChannel ( ch ) if opts . RelayHost != nil { opts . RelayHost . SetChannel ( ch ) } ch . mutable . idleSweep = startIdleSweep ( ch , opts ) return ch , nil }
3608	func ( ch * Channel ) Serve ( l net . Listener ) error { mutable := & ch . mutable mutable . Lock ( ) defer mutable . Unlock ( ) if mutable . l != nil { return errAlreadyListening } mutable . l = tnet . Wrap ( l ) if mutable . state != ChannelClient { return errInvalidStateForOp } mutable . state = ChannelListening mutable . peerInfo . HostPort = l . Addr ( ) . String ( ) mutable . peerInfo . IsEphemeral = false ch . log = ch . log . WithFields ( LogField { "hostPort" , mutable . peerInfo . HostPort } ) ch . log . Info ( "Channel is listening." ) go ch . serve ( ) return nil }
3609	func ( ch * Channel ) ListenAndServe ( hostPort string ) error { mutable := & ch . mutable mutable . RLock ( ) if mutable . l != nil { mutable . RUnlock ( ) return errAlreadyListening } l , err := net . Listen ( "tcp" , hostPort ) if err != nil { mutable . RUnlock ( ) return err } mutable . RUnlock ( ) return ch . Serve ( l ) }
3610	func ( ch * Channel ) Register ( h Handler , methodName string ) { if _ , ok := ch . handler . ( channelHandler ) ; ! ok { panic ( "can't register handler when channel configured with alternate root handler" ) } ch . GetSubChannel ( ch . PeerInfo ( ) . ServiceName ) . Register ( h , methodName ) }
3611	func ( ch * Channel ) PeerInfo ( ) LocalPeerInfo { ch . mutable . RLock ( ) peerInfo := ch . mutable . peerInfo ch . mutable . RUnlock ( ) return peerInfo }
3612	func ( ch * Channel ) GetSubChannel ( serviceName string , opts ... SubChannelOption ) * SubChannel { sub , added := ch . subChannels . getOrAdd ( serviceName , ch ) if added { for _ , opt := range opts { opt ( sub ) } } return sub }
3613	func ( ch * Channel ) serve ( ) { acceptBackoff := 0 * time . Millisecond for { netConn , err := ch . mutable . l . Accept ( ) if err != nil { if ne , ok := err . ( net . Error ) ; ok && ne . Temporary ( ) { if acceptBackoff == 0 { acceptBackoff = 5 * time . Millisecond } else { acceptBackoff *= 2 } if max := 1 * time . Second ; acceptBackoff > max { acceptBackoff = max } ch . log . WithFields ( ErrField ( err ) , LogField { "backoff" , acceptBackoff } , ) . Warn ( "Accept error, will wait and retry." ) time . Sleep ( acceptBackoff ) continue } else { if ch . State ( ) >= ChannelStartClose { return } ch . log . WithFields ( ErrField ( err ) ) . Fatal ( "Unrecoverable accept error, closing server." ) return } } acceptBackoff = 0 go func ( ) { events := connectionEvents { OnActive : ch . inboundConnectionActive , OnCloseStateChange : ch . connectionCloseStateChange , OnExchangeUpdated : ch . exchangeUpdated , } if _ , err := ch . inboundHandshake ( context . Background ( ) , netConn , events ) ; err != nil { netConn . Close ( ) } } ( ) } }
3614	func ( ch * Channel ) Ping ( ctx context . Context , hostPort string ) error { peer := ch . RootPeers ( ) . GetOrAdd ( hostPort ) conn , err := peer . GetConnection ( ctx ) if err != nil { return err } return conn . ping ( ctx ) }
3615	func ( ch * Channel ) StatsTags ( ) map [ string ] string { m := make ( map [ string ] string ) for k , v := range ch . commonStatsTags { m [ k ] = v } return m }
3616	func ( ch * Channel ) Connect ( ctx context . Context , hostPort string ) ( * Connection , error ) { switch state := ch . State ( ) ; state { case ChannelClient , ChannelListening : break default : ch . log . Debugf ( "Connect rejecting new connection as state is %v" , state ) return nil , errInvalidStateForOp } if params := getTChannelParams ( ctx ) ; params != nil && params . connectTimeout > 0 { var cancel context . CancelFunc ctx , cancel = context . WithTimeout ( ctx , params . connectTimeout ) defer cancel ( ) } events := connectionEvents { OnActive : ch . outboundConnectionActive , OnCloseStateChange : ch . connectionCloseStateChange , OnExchangeUpdated : ch . exchangeUpdated , } if err := ctx . Err ( ) ; err != nil { return nil , GetContextError ( err ) } timeout := getTimeout ( ctx ) tcpConn , err := dialContext ( ctx , hostPort ) if err != nil { if ne , ok := err . ( net . Error ) ; ok && ne . Timeout ( ) { ch . log . WithFields ( LogField { "remoteHostPort" , hostPort } , LogField { "timeout" , timeout } , ) . Info ( "Outbound net.Dial timed out." ) err = ErrTimeout } else if ctx . Err ( ) == context . Canceled { ch . log . WithFields ( LogField { "remoteHostPort" , hostPort } , ) . Info ( "Outbound net.Dial was cancelled." ) err = GetContextError ( ErrRequestCancelled ) } else { ch . log . WithFields ( ErrField ( err ) , LogField { "remoteHostPort" , hostPort } , ) . Info ( "Outbound net.Dial failed." ) } return nil , err } conn , err := ch . outboundHandshake ( ctx , tcpConn , hostPort , events ) if conn != nil { if hostPort != conn . remotePeerInfo . HostPort { conn . log . Debugf ( "Outbound connection host:port mismatch, adding to peer %v" , conn . remotePeerInfo . HostPort ) ch . addConnectionToPeer ( hostPort , conn , outbound ) } } return conn , err }
3617	func ( ch * Channel ) exchangeUpdated ( c * Connection ) { if c . remotePeerInfo . HostPort == "" { return } p , ok := ch . RootPeers ( ) . Get ( c . remotePeerInfo . HostPort ) if ! ok { return } ch . updatePeer ( p ) }
3618	func ( ch * Channel ) updatePeer ( p * Peer ) { ch . peers . onPeerChange ( p ) ch . subChannels . updatePeer ( p ) p . callOnUpdateComplete ( ) }
3619	func ( ch * Channel ) addConnection ( c * Connection , direction connectionDirection ) bool { ch . mutable . Lock ( ) defer ch . mutable . Unlock ( ) if c . readState ( ) != connectionActive { return false } switch state := ch . mutable . state ; state { case ChannelClient , ChannelListening : break default : return false } ch . mutable . conns [ c . connID ] = c return true }
3620	func ( ch * Channel ) removeClosedConn ( c * Connection ) { if c . readState ( ) != connectionClosed { return } ch . mutable . Lock ( ) delete ( ch . mutable . conns , c . connID ) ch . mutable . Unlock ( ) }
3621	func ( ch * Channel ) connectionCloseStateChange ( c * Connection ) { ch . removeClosedConn ( c ) if peer , ok := ch . RootPeers ( ) . Get ( c . remotePeerInfo . HostPort ) ; ok { peer . connectionCloseStateChange ( c ) ch . updatePeer ( peer ) } if c . outboundHP != "" && c . outboundHP != c . remotePeerInfo . HostPort { if peer , ok := ch . RootPeers ( ) . Get ( c . outboundHP ) ; ok { peer . connectionCloseStateChange ( c ) ch . updatePeer ( peer ) } } chState := ch . State ( ) if chState != ChannelStartClose && chState != ChannelInboundClosed { return } ch . mutable . RLock ( ) minState := ch . getMinConnectionState ( ) ch . mutable . RUnlock ( ) var updateTo ChannelState if minState >= connectionClosed { updateTo = ChannelClosed } else if minState >= connectionInboundClosed && chState == ChannelStartClose { updateTo = ChannelInboundClosed } var updatedToState ChannelState if updateTo > 0 { ch . mutable . Lock ( ) if ch . mutable . state == chState { ch . mutable . state = updateTo updatedToState = updateTo } ch . mutable . Unlock ( ) chState = updateTo } c . log . Debugf ( "ConnectionCloseStateChange channel state = %v connection minState = %v" , chState , minState ) if updatedToState == ChannelClosed { ch . onClosed ( ) } }
3622	func ( ch * Channel ) State ( ) ChannelState { ch . mutable . RLock ( ) state := ch . mutable . state ch . mutable . RUnlock ( ) return state }
3623	func NewReader ( reader io . Reader ) * Reader { r := readerPool . Get ( ) . ( * Reader ) r . reader = reader r . err = nil return r }
3624	func ( r * Reader ) ReadUint16 ( ) uint16 { if r . err != nil { return 0 } buf := r . buf [ : 2 ] var readN int readN , r . err = io . ReadFull ( r . reader , buf ) if readN < 2 { return 0 } return binary . BigEndian . Uint16 ( buf ) }
3625	func ( r * Reader ) ReadString ( n int ) string { if r . err != nil { return "" } var buf [ ] byte if n <= maxPoolStringLen { buf = r . buf [ : n ] } else { buf = make ( [ ] byte , n ) } var readN int readN , r . err = io . ReadFull ( r . reader , buf ) if readN < n { return "" } s := string ( buf ) return s }
3626	func ( r * Reader ) ReadLen16String ( ) string { len := r . ReadUint16 ( ) return r . ReadString ( int ( len ) ) }
3627	func ( b * Behavior ) Register ( ch * tchannel . Channel ) { b . registerThrift ( ch ) b . registerJSON ( ch ) }
3628	func ( b * Behavior ) Run ( t crossdock . T ) { logParams ( t ) sampled , err := strconv . ParseBool ( t . Param ( sampledParam ) ) if err != nil { t . Fatalf ( "Malformed param %s: %s" , sampledParam , err ) } baggage := randomBaggage ( ) level1 := & Request { ServerRole : RoleS1 , } server1 := t . Param ( server1NameParam ) level2 := & Downstream { ServiceName : t . Param ( server2NameParam ) , ServerRole : RoleS2 , HostPort : fmt . Sprintf ( "%s:%s" , b . serviceToHost ( t . Param ( server2NameParam ) ) , b . ServerPort , ) , Encoding : t . Param ( server2EncodingParam ) , } level1 . Downstream = level2 level3 := & Downstream { ServiceName : t . Param ( server3NameParam ) , ServerRole : RoleS3 , HostPort : fmt . Sprintf ( "%s:%s" , b . serviceToHost ( t . Param ( server3NameParam ) ) , b . ServerPort , ) , Encoding : t . Param ( server3EncodingParam ) , } level2 . Downstream = level3 resp , err := b . startTrace ( t , level1 , sampled , baggage ) if err != nil { t . Errorf ( "Failed to startTrace in S1(%s): %s" , server1 , err . Error ( ) ) return } log . Printf ( "Response: span=%+v, downstream=%+v" , resp . Span , resp . Downstream ) traceID := resp . Span . TraceID require := crossdock . Require ( t ) require . NotEmpty ( traceID , "Trace ID should not be empty in S1(%s)" , server1 ) if validateTrace ( t , level1 . Downstream , resp , server1 , 1 , traceID , sampled , baggage ) { t . Successf ( "trace checks out" ) log . Println ( "PASS" ) } else { log . Println ( "FAIL" ) } }
3629	func ( tp * relayTimerPool ) Get ( ) * relayTimer { timer , ok := tp . pool . Get ( ) . ( * relayTimer ) if ok { timer . released = false return timer } rt := & relayTimer { pool : tp , } rt . timer = time . AfterFunc ( time . Duration ( math . MaxInt64 ) , rt . OnTimer ) if ! rt . timer . Stop ( ) { panic ( "relayTimer requires timers in stopped state, but failed to stop underlying timer" ) } return rt }
3630	func ( tp * relayTimerPool ) Put ( rt * relayTimer ) { if tp . verify { return } tp . pool . Put ( rt ) }
3631	func ( rt * relayTimer ) Start ( d time . Duration , items * relayItems , id uint32 , isOriginator bool ) { rt . verifyNotReleased ( ) if rt . active { panic ( "Tried to start an already-active timer" ) } rt . active = true rt . items = items rt . id = id rt . isOriginator = isOriginator if wasActive := rt . timer . Reset ( d ) ; wasActive { panic ( "relayTimer's underlying timer was Started multiple times without Stop" ) } }
3632	func ( rt * relayTimer ) Release ( ) { rt . verifyNotReleased ( ) if rt . active { panic ( "only stopped or completed timers can be released" ) } rt . released = true rt . pool . Put ( rt ) }
3633	func NewLogger ( writer io . Writer , fields ... LogField ) Logger { return & writerLogger { writer , fields } }
3634	func NewTCPFrameRelay ( dests [ ] string , modifier func ( bool , * tchannel . Frame ) * tchannel . Frame ) ( Relay , error ) { var err error r := & tcpFrameRelay { modifier : modifier } r . tcpRelay , err = newTCPRelay ( dests , r . handleConnFrameRelay ) if err != nil { return nil , err } return r , nil }
3635	func ( kt knownTags ) tallyTags ( ) map [ string ] string { tallyTags := make ( map [ string ] string , 5 ) if kt . dest != "" { tallyTags [ "dest" ] = kt . dest } if kt . source != "" { tallyTags [ "source" ] = kt . source } if kt . procedure != "" { tallyTags [ "procedure" ] = kt . procedure } if kt . retryCount != "" { tallyTags [ "retry-count" ] = kt . retryCount } return tallyTags }
3636	func Isolated ( s * SubChannel ) { s . Lock ( ) s . peers = s . topChannel . peers . newSibling ( ) s . peers . SetStrategy ( newLeastPendingCalculator ( ) ) s . Unlock ( ) }
3637	func ( c * SubChannel ) Isolated ( ) bool { c . RLock ( ) defer c . RUnlock ( ) return c . topChannel . Peers ( ) != c . peers }
3638	func ( c * SubChannel ) Register ( h Handler , methodName string ) { handlers , ok := c . handler . ( * handlerMap ) if ! ok { panic ( fmt . Sprintf ( "handler for SubChannel(%v) was changed to disallow method registration" , c . ServiceName ( ) , ) ) } handlers . register ( h , methodName ) }
3639	func ( c * SubChannel ) GetHandlers ( ) map [ string ] Handler { handlers , ok := c . handler . ( * handlerMap ) if ! ok { panic ( fmt . Sprintf ( "handler for SubChannel(%v) was changed to disallow method registration" , c . ServiceName ( ) , ) ) } handlers . RLock ( ) handlersMap := make ( map [ string ] Handler , len ( handlers . handlers ) ) for k , v := range handlers . handlers { handlersMap [ k ] = v } handlers . RUnlock ( ) return handlersMap }
3640	func ( c * SubChannel ) StatsTags ( ) map [ string ] string { tags := c . topChannel . StatsTags ( ) tags [ "subchannel" ] = c . serviceName return tags }
3641	func ( subChMap * subChannelMap ) registerNewSubChannel ( serviceName string , ch * Channel ) ( _ * SubChannel , added bool ) { subChMap . Lock ( ) defer subChMap . Unlock ( ) if subChMap . subchannels == nil { subChMap . subchannels = make ( map [ string ] * SubChannel ) } if sc , ok := subChMap . subchannels [ serviceName ] ; ok { return sc , false } sc := newSubChannel ( serviceName , ch ) subChMap . subchannels [ serviceName ] = sc return sc , true }
3642	func ( subChMap * subChannelMap ) get ( serviceName string ) ( * SubChannel , bool ) { subChMap . RLock ( ) sc , ok := subChMap . subchannels [ serviceName ] subChMap . RUnlock ( ) return sc , ok }
3643	func ( subChMap * subChannelMap ) getOrAdd ( serviceName string , ch * Channel ) ( _ * SubChannel , added bool ) { if sc , ok := subChMap . get ( serviceName ) ; ok { return sc , false } return subChMap . registerNewSubChannel ( serviceName , ch ) }
3644	func ( c * Client ) Discover ( serviceName string ) ( [ ] string , error ) { ctx , cancel := thrift . NewContext ( time . Second ) defer cancel ( ) result , err := c . hyperbahnClient . Discover ( ctx , & hyperbahn . DiscoveryQuery { ServiceName : serviceName } ) if err != nil { return nil , err } var hostPorts [ ] string for _ , peer := range result . GetPeers ( ) { hostPorts = append ( hostPorts , servicePeerToHostPort ( peer ) ) } return hostPorts , nil }
3645	func ( c * Client ) Start ( ) error { if err := c . listen ( ) ; err != nil { return err } go func ( ) { http . Serve ( c . listener , c . mux ) } ( ) return nil }
3646	func ( c * Client ) listen ( ) error { c . setDefaultPort ( & c . ClientHostPort , ":" + common . DefaultClientPortHTTP ) c . setDefaultPort ( & c . ServerPort , common . DefaultServerPort ) c . mux = http . NewServeMux ( ) c . mux . Handle ( "/" , crossdock . Handler ( c . Behaviors , true ) ) listener , err := net . Listen ( "tcp" , c . ClientHostPort ) if err != nil { return err } c . listener = listener c . ClientHostPort = listener . Addr ( ) . String ( ) return nil }
3647	func WriteRequest ( call tchannel . ArgWritable , req * http . Request ) error { wb := typed . NewWriteBufferWithSize ( 10000 ) wb . WriteLen8String ( req . Method ) writeVarintString ( wb , req . URL . String ( ) ) writeHeaders ( wb , req . Header ) arg2Writer , err := call . Arg2Writer ( ) if err != nil { return err } if _ , err := wb . FlushTo ( arg2Writer ) ; err != nil { return err } if err := arg2Writer . Close ( ) ; err != nil { return err } arg3Writer , err := call . Arg3Writer ( ) if err != nil { return err } if req . Body != nil { if _ , err = io . Copy ( arg3Writer , req . Body ) ; err != nil { return err } } return arg3Writer . Close ( ) }
3648	func ReadRequest ( call tchannel . ArgReadable ) ( * http . Request , error ) { var arg2 [ ] byte if err := tchannel . NewArgReader ( call . Arg2Reader ( ) ) . Read ( & arg2 ) ; err != nil { return nil , err } rb := typed . NewReadBuffer ( arg2 ) method := rb . ReadLen8String ( ) url := readVarintString ( rb ) r , err := http . NewRequest ( method , url , nil ) if err != nil { return nil , err } readHeaders ( rb , r . Header ) if err := rb . Err ( ) ; err != nil { return nil , err } r . Body , err = call . Arg3Reader ( ) return r , err }
3649	func NewReadBufferWithSize ( size int ) * ReadBuffer { return & ReadBuffer { buffer : make ( [ ] byte , size ) , remaining : nil } }
3650	func ( r * ReadBuffer ) ReadByte ( ) ( byte , error ) { if r . err != nil { return 0 , r . err } if len ( r . remaining ) < 1 { r . err = ErrEOF return 0 , r . err } b := r . remaining [ 0 ] r . remaining = r . remaining [ 1 : ] return b , nil }
3651	func ( r * ReadBuffer ) ReadBytes ( n int ) [ ] byte { if r . err != nil { return nil } if len ( r . remaining ) < n { r . err = ErrEOF return nil } b := r . remaining [ 0 : n ] r . remaining = r . remaining [ n : ] return b }
3652	func ( r * ReadBuffer ) ReadString ( n int ) string { if b := r . ReadBytes ( n ) ; b != nil { return string ( b ) } return "" }
3653	func ( r * ReadBuffer ) ReadUint16 ( ) uint16 { if b := r . ReadBytes ( 2 ) ; b != nil { return binary . BigEndian . Uint16 ( b ) } return 0 }
3654	func ( r * ReadBuffer ) ReadUint32 ( ) uint32 { if b := r . ReadBytes ( 4 ) ; b != nil { return binary . BigEndian . Uint32 ( b ) } return 0 }
3655	func ( r * ReadBuffer ) ReadUint64 ( ) uint64 { if b := r . ReadBytes ( 8 ) ; b != nil { return binary . BigEndian . Uint64 ( b ) } return 0 }
3656	func ( r * ReadBuffer ) ReadUvarint ( ) uint64 { v , _ := binary . ReadUvarint ( r ) return v }
3657	func ( r * ReadBuffer ) ReadLen8String ( ) string { n := r . ReadSingleByte ( ) return r . ReadString ( int ( n ) ) }
3658	func ( r * ReadBuffer ) ReadLen16String ( ) string { n := r . ReadUint16 ( ) return r . ReadString ( int ( n ) ) }
3659	func ( r * ReadBuffer ) FillFrom ( ior io . Reader , n int ) ( int , error ) { if len ( r . buffer ) < n { return 0 , ErrEOF } r . err = nil r . remaining = r . buffer [ : n ] return io . ReadFull ( ior , r . remaining ) }
3660	func ( r * ReadBuffer ) Wrap ( b [ ] byte ) { r . buffer = b r . remaining = b r . err = nil }
3661	func ( w * WriteBuffer ) WriteSingleByte ( n byte ) { if w . err != nil { return } if len ( w . remaining ) == 0 { w . setErr ( ErrBufferFull ) return } w . remaining [ 0 ] = n w . remaining = w . remaining [ 1 : ] }
3662	func ( w * WriteBuffer ) WriteBytes ( in [ ] byte ) { if b := w . reserve ( len ( in ) ) ; b != nil { copy ( b , in ) } }
3663	func ( w * WriteBuffer ) WriteUint16 ( n uint16 ) { if b := w . reserve ( 2 ) ; b != nil { binary . BigEndian . PutUint16 ( b , n ) } }
3664	func ( w * WriteBuffer ) WriteUint32 ( n uint32 ) { if b := w . reserve ( 4 ) ; b != nil { binary . BigEndian . PutUint32 ( b , n ) } }
3665	func ( w * WriteBuffer ) WriteUint64 ( n uint64 ) { if b := w . reserve ( 8 ) ; b != nil { binary . BigEndian . PutUint64 ( b , n ) } }
3666	func ( w * WriteBuffer ) WriteUvarint ( n uint64 ) { buf := make ( [ ] byte , 10 ) varBytes := binary . PutUvarint ( buf , n ) if b := w . reserve ( varBytes ) ; b != nil { copy ( b , buf [ 0 : varBytes ] ) } }
3667	func ( w * WriteBuffer ) WriteString ( s string ) { if b := w . reserve ( len ( s ) ) ; b != nil { copy ( b , s ) } }
3668	func ( w * WriteBuffer ) WriteLen8String ( s string ) { if int ( byte ( len ( s ) ) ) != len ( s ) { w . setErr ( errStringTooLong ) } w . WriteSingleByte ( byte ( len ( s ) ) ) w . WriteString ( s ) }
3669	func ( w * WriteBuffer ) WriteLen16String ( s string ) { if int ( uint16 ( len ( s ) ) ) != len ( s ) { w . setErr ( errStringTooLong ) } w . WriteUint16 ( uint16 ( len ( s ) ) ) w . WriteString ( s ) }
3670	func ( w * WriteBuffer ) DeferByte ( ) ByteRef { if len ( w . remaining ) == 0 { w . setErr ( ErrBufferFull ) return ByteRef ( nil ) } w . remaining [ 0 ] = 0 bufRef := ByteRef ( w . remaining [ 0 : ] ) w . remaining = w . remaining [ 1 : ] return bufRef }
3671	func ( w * WriteBuffer ) DeferBytes ( n int ) BytesRef { return BytesRef ( w . deferred ( n ) ) }
3672	func ( w * WriteBuffer ) FlushTo ( iow io . Writer ) ( int , error ) { dirty := w . buffer [ 0 : w . BytesWritten ( ) ] return iow . Write ( dirty ) }
3673	func ( w * WriteBuffer ) Reset ( ) { w . remaining = w . buffer w . err = nil }
3674	func ( w * WriteBuffer ) Wrap ( b [ ] byte ) { w . buffer = b w . remaining = b }
3675	func ( ref Uint16Ref ) Update ( n uint16 ) { if ref != nil { binary . BigEndian . PutUint16 ( ref , n ) } }
3676	func ( ref Uint32Ref ) Update ( n uint32 ) { if ref != nil { binary . BigEndian . PutUint32 ( ref , n ) } }
3677	func ( ref Uint64Ref ) Update ( n uint64 ) { if ref != nil { binary . BigEndian . PutUint64 ( ref , n ) } }
3678	func ( ref BytesRef ) Update ( b [ ] byte ) { if ref != nil { copy ( ref , b ) } }
3679	func ( ref BytesRef ) UpdateString ( s string ) { if ref != nil { copy ( ref , s ) } }
3680	func ( r * fragmentingReader ) ArgReader ( last bool ) ( ArgReader , error ) { if err := r . BeginArgument ( last ) ; err != nil { return nil , err } return r , nil }
3681	func ( f * writableFragment ) finish ( hasMoreFragments bool ) { f . checksumRef . Update ( f . checksum . Sum ( ) ) if hasMoreFragments { f . flagsRef . Update ( hasMoreFragmentsFlag ) } else { f . checksum . Release ( ) } }
3682	func newWritableChunk ( checksum Checksum , contents * typed . WriteBuffer ) * writableChunk { return & writableChunk { size : 0 , sizeRef : contents . DeferUint16 ( ) , checksum : checksum , contents : contents , } }
3683	func ( c * writableChunk ) writeAsFits ( b [ ] byte ) int { if len ( b ) > c . contents . BytesRemaining ( ) { b = b [ : c . contents . BytesRemaining ( ) ] } c . checksum . Add ( b ) c . contents . WriteBytes ( b ) written := len ( b ) c . size += uint16 ( written ) return written }
3684	func newFragmentingWriter ( logger Logger , sender fragmentSender , checksum Checksum ) * fragmentingWriter { return & fragmentingWriter { logger : logger , sender : sender , checksum : checksum , state : fragmentingWriteStart , } }
3685	func ( w * fragmentingWriter ) ArgWriter ( last bool ) ( ArgWriter , error ) { if err := w . BeginArgument ( last ) ; err != nil { return nil , err } return w , nil }
3686	func ( w * fragmentingWriter ) BeginArgument ( last bool ) error { if w . err != nil { return w . err } switch { case w . state == fragmentingWriteComplete : w . err = errComplete return w . err case w . state . isWritingArgument ( ) : w . err = errAlreadyWritingArgument return w . err } if w . curFragment == nil { initial := w . state == fragmentingWriteStart if w . curFragment , w . err = w . sender . newFragment ( initial , w . checksum ) ; w . err != nil { return w . err } } if w . curFragment . contents . BytesRemaining ( ) <= chunkHeaderSize { panic ( fmt . Errorf ( "attempting to begin an argument in a fragment with only %d bytes available" , w . curFragment . contents . BytesRemaining ( ) ) ) } w . curChunk = newWritableChunk ( w . checksum , w . curFragment . contents ) w . state = fragmentingWriteInArgument if last { w . state = fragmentingWriteInLastArgument } return nil }
3687	func ( w * fragmentingWriter ) Write ( b [ ] byte ) ( int , error ) { if w . err != nil { return 0 , w . err } if ! w . state . isWritingArgument ( ) { w . err = errNotWritingArgument return 0 , w . err } totalWritten := 0 for { bytesWritten := w . curChunk . writeAsFits ( b ) totalWritten += bytesWritten if bytesWritten == len ( b ) { return totalWritten , nil } if w . err = w . Flush ( ) ; w . err != nil { return totalWritten , w . err } b = b [ bytesWritten : ] } }
3688	func ( w * fragmentingWriter ) Flush ( ) error { w . curChunk . finish ( ) w . curFragment . finish ( true ) if w . err = w . sender . flushFragment ( w . curFragment ) ; w . err != nil { return w . err } if w . curFragment , w . err = w . sender . newFragment ( false , w . checksum ) ; w . err != nil { return w . err } w . curChunk = newWritableChunk ( w . checksum , w . curFragment . contents ) return nil }
3689	func ( w * fragmentingWriter ) Close ( ) error { last := w . state == fragmentingWriteInLastArgument if w . err != nil { return w . err } if ! w . state . isWritingArgument ( ) { w . err = errNotWritingArgument return w . err } w . curChunk . finish ( ) if last { w . state = fragmentingWriteComplete w . curFragment . finish ( false ) w . err = w . sender . flushFragment ( w . curFragment ) w . sender . doneSending ( ) return w . err } w . state = fragmentingWriteWaitingForArgument if w . curFragment . contents . BytesRemaining ( ) > chunkHeaderSize { return nil } w . curFragment . finish ( true ) if w . err = w . sender . flushFragment ( w . curFragment ) ; w . err != nil { return w . err } if w . curFragment , w . err = w . sender . newFragment ( false , w . checksum ) ; w . err != nil { return w . err } w . curFragment . contents . WriteUint16 ( 0 ) return nil }
3690	func ( c * Connection ) handleCallRes ( frame * Frame ) bool { if err := c . outbound . forwardPeerFrame ( frame ) ; err != nil { return true } return false }
3691	func ( response * OutboundCallResponse ) Arg2Reader ( ) ( ArgReader , error ) { var method [ ] byte if err := NewArgReader ( response . arg1Reader ( ) ) . Read ( & method ) ; err != nil { return nil , err } return response . arg2Reader ( ) }
3692	func ( c * Connection ) handleError ( frame * Frame ) bool { errMsg := errorMessage { id : frame . Header . ID , } rbuf := typed . NewReadBuffer ( frame . SizedPayload ( ) ) if err := errMsg . read ( rbuf ) ; err != nil { c . log . WithFields ( LogField { "remotePeer" , c . remotePeerInfo } , ErrField ( err ) , ) . Warn ( "Unable to read error frame." ) c . connectionError ( "parsing error frame" , err ) return true } if errMsg . errCode == ErrCodeProtocol { c . log . WithFields ( LogField { "remotePeer" , c . remotePeerInfo } , LogField { "error" , errMsg . message } , ) . Warn ( "Peer reported protocol error." ) c . connectionError ( "received protocol error" , errMsg . AsSystemError ( ) ) return true } if err := c . outbound . forwardPeerFrame ( frame ) ; err != nil { c . log . WithFields ( LogField { "frameHeader" , frame . Header . String ( ) } , LogField { "id" , errMsg . id } , LogField { "errorMessage" , errMsg . message } , LogField { "errorCode" , errMsg . errCode } , ErrField ( err ) , ) . Info ( "Failed to forward error frame." ) return true } return false }
3693	func ( response * OutboundCallResponse ) doneReading ( unexpected error ) { now := response . timeNow ( ) isSuccess := unexpected == nil && ! response . ApplicationError ( ) lastAttempt := isSuccess || ! response . requestState . HasRetries ( unexpected ) if span := response . span ; span != nil { if unexpected != nil { span . LogEventWithPayload ( "error" , unexpected ) } if ! isSuccess && lastAttempt { ext . Error . Set ( span , true ) } span . FinishWithOptions ( opentracing . FinishOptions { FinishTime : now } ) } latency := now . Sub ( response . startedAt ) response . statsReporter . RecordTimer ( "outbound.calls.per-attempt.latency" , response . commonStatsTags , latency ) if lastAttempt { requestLatency := response . requestState . SinceStart ( now , latency ) response . statsReporter . RecordTimer ( "outbound.calls.latency" , response . commonStatsTags , requestLatency ) } if retryCount := response . requestState . RetryCount ( ) ; retryCount > 0 { retryTags := cloneTags ( response . commonStatsTags ) retryTags [ "retry-count" ] = fmt . Sprint ( retryCount ) response . statsReporter . IncCounter ( "outbound.calls.retries" , retryTags , 1 ) } if unexpected != nil { } else if response . ApplicationError ( ) { response . statsReporter . IncCounter ( "outbound.calls.per-attempt.app-errors" , response . commonStatsTags , 1 ) if lastAttempt { response . statsReporter . IncCounter ( "outbound.calls.app-errors" , response . commonStatsTags , 1 ) } } else { response . statsReporter . IncCounter ( "outbound.calls.success" , response . commonStatsTags , 1 ) } response . mex . shutdown ( ) }
3694	func ( w * reqResWriter ) newFragment ( initial bool , checksum Checksum ) ( * writableFragment , error ) { if err := w . mex . checkError ( ) ; err != nil { return nil , w . failed ( err ) } message := w . messageForFragment ( initial ) frame := w . conn . opts . FramePool . Get ( ) frame . Header . ID = w . mex . msgID frame . Header . messageType = message . messageType ( ) wbuf := typed . NewWriteBuffer ( frame . Payload [ : ] ) fragment := new ( writableFragment ) fragment . frame = frame fragment . flagsRef = wbuf . DeferByte ( ) if err := message . write ( wbuf ) ; err != nil { return nil , err } wbuf . WriteSingleByte ( byte ( checksum . TypeCode ( ) ) ) fragment . checksumRef = wbuf . DeferBytes ( checksum . Size ( ) ) fragment . checksum = checksum fragment . contents = wbuf return fragment , wbuf . Err ( ) }
3695	func ( w * reqResWriter ) flushFragment ( fragment * writableFragment ) error { if w . err != nil { return w . err } frame := fragment . frame . ( * Frame ) frame . Header . SetPayloadSize ( uint16 ( fragment . contents . BytesWritten ( ) ) ) if err := w . mex . checkError ( ) ; err != nil { return w . failed ( err ) } select { case <- w . mex . ctx . Done ( ) : return w . failed ( GetContextError ( w . mex . ctx . Err ( ) ) ) case <- w . mex . errCh . c : return w . failed ( w . mex . errCh . err ) case w . conn . sendCh <- frame : return nil } }
3696	func ( w * reqResWriter ) failed ( err error ) error { w . log . Debugf ( "writer failed: %v existing err: %v" , err , w . err ) if w . err != nil { return w . err } w . mex . shutdown ( ) w . err = err return w . err }
3697	func ( r * reqResReader ) arg1Reader ( ) ( ArgReader , error ) { return r . argReader ( false , reqResReaderPreArg1 , reqResReaderPreArg2 ) }
3698	func ( r * reqResReader ) arg2Reader ( ) ( ArgReader , error ) { return r . argReader ( false , reqResReaderPreArg2 , reqResReaderPreArg3 ) }
3699	func ( r * reqResReader ) arg3Reader ( ) ( ArgReader , error ) { return r . argReader ( true , reqResReaderPreArg3 , reqResReaderComplete ) }
3700	func ( r * reqResReader ) argReader ( last bool , inState reqResReaderState , outState reqResReaderState ) ( ArgReader , error ) { if r . state != inState { return nil , r . failed ( errReqResReaderStateMismatch { state : r . state , expectedState : inState } ) } argReader , err := r . contents . ArgReader ( last ) if err != nil { return nil , r . failed ( err ) } r . state = outState return argReader , nil }
3701	func ( r * reqResReader ) recvNextFragment ( initial bool ) ( * readableFragment , error ) { if r . initialFragment != nil { fragment := r . initialFragment r . initialFragment = nil r . previousFragment = fragment return fragment , nil } message := r . messageForFragment ( initial ) frame , err := r . mex . recvPeerFrameOfType ( message . messageType ( ) ) if err != nil { if err , ok := err . ( errorMessage ) ; ok { r . err = err . AsSystemError ( ) return nil , err } return nil , r . failed ( err ) } fragment , err := parseInboundFragment ( r . mex . framePool , frame , message ) if err != nil { return nil , r . failed ( err ) } r . previousFragment = fragment return fragment , nil }
3702	func ( r * reqResReader ) releasePreviousFragment ( ) { fragment := r . previousFragment r . previousFragment = nil if fragment != nil { fragment . done ( ) } }
3703	func ( r * reqResReader ) failed ( err error ) error { r . log . Debugf ( "reader failed: %v existing err: %v" , err , r . err ) if r . err != nil { return r . err } r . mex . shutdown ( ) r . err = err return r . err }
3704	func parseInboundFragment ( framePool FramePool , frame * Frame , message message ) ( * readableFragment , error ) { rbuf := typed . NewReadBuffer ( frame . SizedPayload ( ) ) fragment := new ( readableFragment ) fragment . flags = rbuf . ReadSingleByte ( ) if err := message . read ( rbuf ) ; err != nil { return nil , err } fragment . checksumType = ChecksumType ( rbuf . ReadSingleByte ( ) ) fragment . checksum = rbuf . ReadBytes ( fragment . checksumType . ChecksumSize ( ) ) fragment . contents = rbuf fragment . onDone = func ( ) { framePool . Release ( frame ) } return fragment , rbuf . Err ( ) }
3705	func NewContext ( timeout time . Duration ) ( Context , context . CancelFunc ) { ctx , cancel := tchannel . NewContext ( timeout ) return Wrap ( ctx ) , cancel }
3706	func WithHeaders ( ctx context . Context , headers map [ string ] string ) Context { return tchannel . WrapWithHeaders ( ctx , headers ) }
3707	func ( c * Connection ) healthCheck ( connID uint32 ) { defer close ( c . healthCheckDone ) opts := c . opts . HealthChecks ticker := c . timeTicker ( opts . Interval ) defer ticker . Stop ( ) consecutiveFailures := 0 for { select { case <- ticker . C : case <- c . healthCheckCtx . Done ( ) : return } ctx , cancel := context . WithTimeout ( c . healthCheckCtx , opts . Timeout ) err := c . ping ( ctx ) cancel ( ) c . healthCheckHistory . add ( err == nil ) if err == nil { if c . log . Enabled ( LogLevelDebug ) { c . log . Debug ( "Performed successful active health check." ) } consecutiveFailures = 0 continue } if GetSystemErrorCode ( err ) == ErrCodeCancelled || err == ErrInvalidConnectionState { c . log . WithFields ( ErrField ( err ) ) . Debug ( "Health checker stopped." ) return } consecutiveFailures ++ c . log . WithFields ( LogFields { { "consecutiveFailures" , consecutiveFailures } , ErrField ( err ) , { "failuresToClose" , opts . FailuresToClose } , } ... ) . Warn ( "Failed active health check." ) if consecutiveFailures >= opts . FailuresToClose { c . close ( LogFields { { "reason" , "health check failure" } , ErrField ( err ) , } ... ) return } } }
3708	func ( cb * ContextBuilder ) SetTimeout ( timeout time . Duration ) * ContextBuilder { cb . Timeout = timeout return cb }
3709	func ( cb * ContextBuilder ) AddHeader ( key , value string ) * ContextBuilder { if cb . Headers == nil { cb . Headers = map [ string ] string { key : value } } else { cb . Headers [ key ] = value } return cb }
3710	func ( cb * ContextBuilder ) SetHeaders ( headers map [ string ] string ) * ContextBuilder { cb . Headers = headers cb . replaceParentHeaders = true return cb }
3711	func ( cb * ContextBuilder ) SetConnectTimeout ( d time . Duration ) * ContextBuilder { cb . ConnectTimeout = d return cb }
3712	func ( cb * ContextBuilder ) SetRetryOptions ( retryOptions * RetryOptions ) * ContextBuilder { cb . RetryOptions = retryOptions return cb }
3713	func ( cb * ContextBuilder ) SetTimeoutPerAttempt ( timeoutPerAttempt time . Duration ) * ContextBuilder { if cb . RetryOptions == nil { cb . RetryOptions = & RetryOptions { } } cb . RetryOptions . TimeoutPerAttempt = timeoutPerAttempt return cb }
3714	func ( cb * ContextBuilder ) SetParentContext ( ctx context . Context ) * ContextBuilder { cb . ParentContext = ctx return cb }
3715	func ( cb * ContextBuilder ) Build ( ) ( ContextWithHeaders , context . CancelFunc ) { params := & tchannelCtxParams { options : cb . CallOptions , call : cb . incomingCall , retryOptions : cb . RetryOptions , connectTimeout : cb . ConnectTimeout , hideListeningOnOutbound : cb . hideListeningOnOutbound , tracingDisabled : cb . TracingDisabled , } parent := cb . ParentContext if parent == nil { parent = context . Background ( ) } else if headerCtx , ok := parent . ( headerCtx ) ; ok { parent = headerCtx . Context } var ( ctx context . Context cancel context . CancelFunc ) _ , parentHasDeadline := parent . Deadline ( ) if cb . Timeout == 0 && parentHasDeadline { ctx , cancel = context . WithCancel ( parent ) } else { ctx , cancel = context . WithTimeout ( parent , cb . Timeout ) } ctx = context . WithValue ( ctx , contextKeyTChannel , params ) return WrapWithHeaders ( ctx , cb . getHeaders ( ) ) , cancel }
3716	func ( c * CallOptions ) overrideHeaders ( headers transportHeaders ) { if c . Format != "" { headers [ ArgScheme ] = c . Format . String ( ) } if c . ShardKey != "" { headers [ ShardKey ] = c . ShardKey } if c . RoutingKey != "" { headers [ RoutingKey ] = c . RoutingKey } if c . RoutingDelegate != "" { headers [ RoutingDelegate ] = c . RoutingDelegate } if c . callerName != "" { headers [ CallerName ] = c . callerName } }
3717	func ( r ArgReadHelper ) Read ( bs * [ ] byte ) error { return r . read ( func ( ) error { var err error * bs , err = ioutil . ReadAll ( r . reader ) return err } ) }
3718	func ( r ArgReadHelper ) ReadJSON ( data interface { } ) error { return r . read ( func ( ) error { reader := bufio . NewReader ( r . reader ) if _ , err := reader . Peek ( 1 ) ; err == io . EOF { return nil } else if err != nil { return err } d := json . NewDecoder ( reader ) return d . Decode ( data ) } ) }
3719	func NewArgWriter ( writer io . WriteCloser , err error ) ArgWriteHelper { return ArgWriteHelper { writer , err } }
3720	func ( w ArgWriteHelper ) Write ( bs [ ] byte ) error { return w . write ( func ( ) error { _ , err := w . writer . Write ( bs ) return err } ) }
3721	func ( w ArgWriteHelper ) WriteJSON ( data interface { } ) error { return w . write ( func ( ) error { e := json . NewEncoder ( w . writer ) return e . Encode ( data ) } ) }
3722	func Register ( registrar tchannel . Registrar ) { handler := func ( ctx context . Context , call * tchannel . InboundCall ) { req , err := thttp . ReadRequest ( call ) if err != nil { registrar . Logger ( ) . WithFields ( tchannel . LogField { Key : "err" , Value : err . Error ( ) } , ) . Warn ( "Failed to read HTTP request." ) return } serveHTTP ( req , call . Response ( ) ) } registrar . Register ( tchannel . HandlerFunc ( handler ) , "_pprof" ) }
3723	func ( r * relayItems ) Count ( ) int { r . RLock ( ) n := len ( r . items ) - int ( r . tombs ) r . RUnlock ( ) return n }
3724	func ( r * relayItems ) Get ( id uint32 ) ( relayItem , bool ) { r . RLock ( ) item , ok := r . items [ id ] r . RUnlock ( ) return item , ok }
3725	func ( r * relayItems ) Add ( id uint32 , item relayItem ) { r . Lock ( ) r . items [ id ] = item r . Unlock ( ) }
3726	func ( r * relayItems ) Entomb ( id uint32 , deleteAfter time . Duration ) ( relayItem , bool ) { r . Lock ( ) if r . tombs > _maxRelayTombs { r . Unlock ( ) r . logger . WithFields ( LogField { "id" , id } ) . Warn ( "Too many tombstones, deleting relay item immediately." ) return r . Delete ( id ) } item , ok := r . items [ id ] if ! ok { r . Unlock ( ) r . logger . WithFields ( LogField { "id" , id } ) . Warn ( "Can't find relay item to entomb." ) return item , false } if item . tomb { r . Unlock ( ) r . logger . WithFields ( LogField { "id" , id } ) . Warn ( "Re-entombing a tombstone." ) return item , false } r . tombs ++ item . tomb = true r . items [ id ] = item r . Unlock ( ) time . AfterFunc ( deleteAfter , func ( ) { r . Delete ( id ) } ) return item , true }
3727	func NewRelayer ( ch * Channel , conn * Connection ) * Relayer { r := & Relayer { relayHost : ch . RelayHost ( ) , maxTimeout : ch . relayMaxTimeout , localHandler : ch . relayLocal , outbound : newRelayItems ( conn . log . WithFields ( LogField { "relayItems" , "outbound" } ) ) , inbound : newRelayItems ( conn . log . WithFields ( LogField { "relayItems" , "inbound" } ) ) , peers : ch . RootPeers ( ) , conn : conn , relayConn : & relay . Conn { RemoteAddr : conn . conn . RemoteAddr ( ) . String ( ) , RemoteProcessName : conn . RemotePeerInfo ( ) . ProcessName , IsOutbound : conn . connDirection == outbound , } , logger : conn . log , } r . timeouts = newRelayTimerPool ( r . timeoutRelayItem , ch . relayTimerVerify ) return r }
3728	func ( r * Relayer ) Relay ( f * Frame ) error { if f . messageType ( ) != messageTypeCallReq { err := r . handleNonCallReq ( f ) if err == errUnknownID { if err := r . conn . outbound . forwardPeerFrame ( f ) ; err == nil { return nil } } return err } return r . handleCallReq ( newLazyCallReq ( f ) ) }
3729	func ( r * Relayer ) Receive ( f * Frame , fType frameType ) ( sent bool , failureReason string ) { id := f . Header . ID items := r . receiverItems ( fType ) item , ok := items . Get ( id ) if ! ok { r . logger . WithFields ( LogField { "id" , id } , ) . Warn ( "Received a frame without a RelayItem." ) return false , _relayErrorNotFound } finished := finishesCall ( f ) if item . tomb { return true , "" } if fType == responseFrame { if succeeded , failMsg := determinesCallSuccess ( f ) ; succeeded { item . call . Succeeded ( ) } else if len ( failMsg ) > 0 { item . call . Failed ( failMsg ) } } select { case r . conn . sendCh <- f : default : r . logger . WithFields ( LogField { "id" , id } , ) . Warn ( "Dropping call due to slow connection." ) items := r . receiverItems ( fType ) err := _relayErrorDestConnSlow if fType == responseFrame { err = _relayErrorSourceConnSlow } r . failRelayItem ( items , id , err ) return false , err } if finished { r . finishRelayItem ( items , id ) } return true , "" }
3730	func ( r * Relayer ) handleNonCallReq ( f * Frame ) error { frameType := frameTypeFor ( f ) finished := finishesCall ( f ) items := r . outbound if frameType == responseFrame { items = r . inbound } item , ok := items . Get ( f . Header . ID ) if ! ok { return errUnknownID } if item . tomb { return nil } originalID := f . Header . ID f . Header . ID = item . remapID sent , failure := item . destination . Receive ( f , frameType ) if ! sent { r . failRelayItem ( items , originalID , failure ) return nil } if finished { r . finishRelayItem ( items , originalID ) } return nil }
3731	func ( r * Relayer ) addRelayItem ( isOriginator bool , id , remapID uint32 , destination * Relayer , ttl time . Duration , span Span , call RelayCall ) relayItem { item := relayItem { call : call , remapID : remapID , destination : destination , span : span , } items := r . inbound if isOriginator { items = r . outbound } item . timeout = r . timeouts . Get ( ) items . Add ( id , item ) item . timeout . Start ( ttl , items , id , isOriginator ) return item }
3732	func ( r * Relayer ) failRelayItem ( items * relayItems , id uint32 , failure string ) { item , ok := items . Get ( id ) if ! ok { items . logger . WithFields ( LogField { "id" , id } ) . Warn ( "Attempted to fail non-existent relay item." ) return } if ! item . timeout . Stop ( ) { return } item , ok = items . Entomb ( id , _relayTombTTL ) if ! ok { return } if item . call != nil { if failure != _relayErrorSourceConnSlow { r . conn . SendSystemError ( id , item . span , errFrameNotSent ) } item . call . Failed ( failure ) item . call . End ( ) } r . decrementPending ( ) }
3733	func WriteStruct ( writer io . Writer , s thrift . TStruct ) error { wp := getProtocolWriter ( writer ) err := s . Write ( wp . protocol ) thriftProtocolPool . Put ( wp ) return err }
3734	func ReadStruct ( reader io . Reader , s thrift . TStruct ) error { wp := getProtocolReader ( reader ) err := s . Read ( wp . protocol ) thriftProtocolPool . Put ( wp ) return err }
3735	func EnsureEmpty ( r io . Reader , stage string ) error { buf := _bufPool . Get ( ) . ( * [ ] byte ) defer _bufPool . Put ( buf ) n , err := r . Read ( * buf ) if n > 0 { return fmt . Errorf ( "found unexpected bytes after %s, found (upto 128 bytes): %x" , stage , ( * buf ) [ : n ] ) } if err == io . EOF { return nil } return err }
3736	func NewServer ( optFns ... Option ) Server { opts := getOptions ( optFns ) if opts . external { return newExternalServer ( opts ) } ch , err := tchannel . NewChannel ( opts . svcName , & tchannel . ChannelOptions { Logger : tchannel . NewLevelLogger ( tchannel . NewLogger ( os . Stderr ) , tchannel . LogLevelWarn ) , } ) if err != nil { panic ( "failed to create channel: " + err . Error ( ) ) } if err := ch . ListenAndServe ( "127.0.0.1:0" ) ; err != nil { panic ( "failed to listen on port 0: " + err . Error ( ) ) } s := & internalServer { ch : ch , opts : opts , } tServer := thrift . NewServer ( ch ) tServer . Register ( gen . NewTChanSecondServiceServer ( handler { calls : & s . thriftCalls } ) ) ch . Register ( raw . Wrap ( rawHandler { calls : & s . rawCalls } ) , "echo" ) if len ( opts . advertiseHosts ) > 0 { if err := s . Advertise ( opts . advertiseHosts ) ; err != nil { panic ( "failed to advertise: " + err . Error ( ) ) } } return s }
3737	func ( s * internalServer ) Advertise ( hyperbahnHosts [ ] string ) error { config := hyperbahn . Configuration { InitialNodes : hyperbahnHosts } hc , err := hyperbahn . NewClient ( s . ch , config , nil ) if err != nil { panic ( "failed to setup Hyperbahn client: " + err . Error ( ) ) } return hc . Advertise ( ) }
3738	func ( c * Connection ) handleCallReqContinue ( frame * Frame ) bool { if err := c . inbound . forwardPeerFrame ( frame ) ; err != nil { return true } return false }
3739	func ( c * Connection ) dispatchInbound ( _ uint32 , _ uint32 , call * InboundCall , frame * Frame ) { if call . log . Enabled ( LogLevelDebug ) { call . log . Debugf ( "Received incoming call for %s from %s" , call . ServiceName ( ) , c . remotePeerInfo ) } if err := call . readMethod ( ) ; err != nil { call . log . WithFields ( LogField { "remotePeer" , c . remotePeerInfo } , ErrField ( err ) , ) . Error ( "Couldn't read method." ) c . opts . FramePool . Release ( frame ) return } call . commonStatsTags [ "endpoint" ] = call . methodString call . statsReporter . IncCounter ( "inbound.calls.recvd" , call . commonStatsTags , 1 ) if span := call . response . span ; span != nil { span . SetOperationName ( call . methodString ) } go func ( ) { select { case <- call . mex . ctx . Done ( ) : if call . mex . ctx . Err ( ) != nil { call . mex . inboundExpired ( ) } case <- call . mex . errCh . c : if c . log . Enabled ( LogLevelDebug ) { call . log . Debugf ( "Wait for timeout/cancellation interrupted by error: %v" , call . mex . errCh . err ) } call . response . cancel ( ) call . mex . inboundExpired ( ) } } ( ) c . handler . Handle ( call . mex . ctx , call ) }
3740	func ( call * InboundCall ) CallOptions ( ) * CallOptions { return & CallOptions { callerName : call . CallerName ( ) , Format : call . Format ( ) , ShardKey : call . ShardKey ( ) , RoutingDelegate : call . RoutingDelegate ( ) , RoutingKey : call . RoutingKey ( ) , } }
3741	func ( call * InboundCall ) Response ( ) * InboundCallResponse { if call . err != nil { call . response . err = call . err } return call . response }
3742	func ( response * InboundCallResponse ) SendSystemError ( err error ) error { if response . err != nil { return response . err } response . state = reqResWriterComplete response . systemError = true response . doneSending ( ) response . call . releasePreviousFragment ( ) span := CurrentSpan ( response . mex . ctx ) return response . conn . SendSystemError ( response . mex . msgID , * span , err ) }
3743	func ( response * InboundCallResponse ) SetApplicationError ( ) error { if response . state > reqResWriterPreArg2 { return response . failed ( errReqResWriterStateMismatch { state : response . state , expectedState : reqResWriterPreArg2 , } ) } response . applicationError = true return nil }
3744	func ( response * InboundCallResponse ) Arg2Writer ( ) ( ArgWriter , error ) { if err := NewArgWriter ( response . arg1Writer ( ) ) . Write ( nil ) ; err != nil { return nil , err } return response . arg2Writer ( ) }
3745	func ( response * InboundCallResponse ) doneSending ( ) { now := response . timeNow ( ) if span := response . span ; span != nil { if response . applicationError || response . systemError { ext . Error . Set ( span , true ) } span . FinishWithOptions ( opentracing . FinishOptions { FinishTime : now } ) } latency := now . Sub ( response . calledAt ) response . statsReporter . RecordTimer ( "inbound.calls.latency" , response . commonStatsTags , latency ) if response . systemError { } else if response . applicationError { response . statsReporter . IncCounter ( "inbound.calls.app-errors" , response . commonStatsTags , 1 ) } else { response . statsReporter . IncCounter ( "inbound.calls.success" , response . commonStatsTags , 1 ) } response . cancel ( ) if response . err == nil { response . mex . shutdown ( ) } }
3746	func newState ( v * parser . Thrift , all map [ string ] parseState ) * State { typedefs := make ( map [ string ] * parser . Type ) for k , v := range v . Typedefs { typedefs [ k ] = v . Type } i64Type := & parser . Type { Name : "i64" } for k := range v . Enums { typedefs [ k ] = i64Type } return & State { typedefs , nil , all } }
3747	func ( s * State ) rootType ( thriftType * parser . Type ) * parser . Type { if state , newType , include := s . checkInclude ( thriftType ) ; include != nil { return state . rootType ( newType ) } if v , ok := s . typedefs [ thriftType . Name ] ; ok { return s . rootType ( v ) } return thriftType }
3748	func ( s * State ) checkInclude ( thriftType * parser . Type ) ( * State , * parser . Type , * Include ) { parts := strings . SplitN ( thriftType . Name , "." , 2 ) if len ( parts ) < 2 { return nil , nil , nil } newType := * thriftType newType . Name = parts [ 1 ] include := s . includes [ parts [ 0 ] ] state := s . all [ include . file ] return state . global , & newType , include }
3749	func ( s * State ) isResultPointer ( thriftType * parser . Type ) bool { _ , basicGoType := thriftToGo [ s . rootType ( thriftType ) . Name ] return ! basicGoType }
3750	func ( s * State ) goType ( thriftType * parser . Type ) string { return s . goTypePrefix ( "" , thriftType ) }
3751	func ( s * State ) goTypePrefix ( prefix string , thriftType * parser . Type ) string { switch thriftType . Name { case "binary" : return "[]byte" case "list" : return "[]" + s . goType ( thriftType . ValueType ) case "set" : return "map[" + s . goType ( thriftType . ValueType ) + "]bool" case "map" : return "map[" + s . goType ( thriftType . KeyType ) + "]" + s . goType ( thriftType . ValueType ) } if state , newType , include := s . checkInclude ( thriftType ) ; include != nil { return state . goTypePrefix ( include . Package ( ) + "." , newType ) } if goType , ok := thriftToGo [ thriftType . Name ] ; ok { return goType } goThriftName := goPublicFieldName ( thriftType . Name ) goThriftName = prefix + goThriftName rootType := s . rootType ( thriftType ) if _ , ok := thriftToGo [ rootType . Name ] ; ok { return goThriftName } if rootType . Name == "list" || rootType . Name == "set" || rootType . Name == "map" { return goThriftName } if rootType != thriftType { return goThriftName } return "*" + goThriftName }
3752	func NewContext ( timeout time . Duration ) ( context . Context , context . CancelFunc ) { return NewContextBuilder ( timeout ) . Build ( ) }
3753	func newIncomingContext ( call IncomingCall , timeout time . Duration ) ( context . Context , context . CancelFunc ) { return NewContextBuilder ( timeout ) . setIncomingCall ( call ) . Build ( ) }
3754	func CurrentCall ( ctx context . Context ) IncomingCall { if params := getTChannelParams ( ctx ) ; params != nil { return params . call } return nil }
3755	func New ( seed int64 ) * rand . Rand { return rand . New ( & lockedSource { src : rand . NewSource ( seed ) } ) }
3756	func ( h * metaHandler ) Health ( ctx Context , req * meta . HealthRequest ) ( * meta . HealthStatus , error ) { ok , message := h . healthFn ( ctx , metaReqToReq ( req ) ) if message == "" { return & meta . HealthStatus { Ok : ok } , nil } return & meta . HealthStatus { Ok : ok , Message : & message } , nil }
3757	func ( c headerCtx ) Headers ( ) map [ string ] string { if h := c . headers ( ) ; h != nil { return h . reqHeaders } return nil }
3758	func ( c headerCtx ) ResponseHeaders ( ) map [ string ] string { if h := c . headers ( ) ; h != nil { return h . respHeaders } return nil }
3759	func ( c headerCtx ) SetResponseHeaders ( headers map [ string ] string ) { if h := c . headers ( ) ; h != nil { h . respHeaders = headers return } panic ( "SetResponseHeaders called on ContextWithHeaders not created via WrapWithHeaders" ) }
3760	func ( c headerCtx ) Child ( ) ContextWithHeaders { var headersCopy headersContainer if h := c . headers ( ) ; h != nil { headersCopy = * h } return Wrap ( context . WithValue ( c . Context , contextKeyHeaders , & headersCopy ) ) }
3761	func Wrap ( ctx context . Context ) ContextWithHeaders { hctx := headerCtx { Context : ctx } if h := hctx . headers ( ) ; h != nil { return hctx } return WrapWithHeaders ( ctx , nil ) }
3762	func WrapWithHeaders ( ctx context . Context , headers map [ string ] string ) ContextWithHeaders { h := & headersContainer { reqHeaders : headers , } newCtx := context . WithValue ( ctx , contextKeyHeaders , h ) return headerCtx { Context : newCtx } }
3763	func WithoutHeaders ( ctx context . Context ) context . Context { return context . WithValue ( context . WithValue ( ctx , contextKeyTChannel , nil ) , contextKeyHeaders , nil ) }
3764	func ( e * errNotifier ) Notify ( err error ) error { if err == nil { panic ( "cannot Notify with no error" ) } if ! e . notified . CAS ( false , true ) { return fmt . Errorf ( "cannot broadcast error: %v, already have: %v" , err , e . err ) } e . err = err close ( e . c ) return nil }
3765	func ( mex * messageExchange ) forwardPeerFrame ( frame * Frame ) error { if err := mex . ctx . Err ( ) ; err != nil { return GetContextError ( err ) } select { case mex . recvCh <- frame : return nil case <- mex . ctx . Done ( ) : return GetContextError ( mex . ctx . Err ( ) ) case <- mex . errCh . c : select { case mex . recvCh <- frame : return nil default : } return mex . errCh . err } }
3766	func ( mex * messageExchange ) recvPeerFrame ( ) ( * Frame , error ) { if err := mex . ctx . Err ( ) ; err != nil { return nil , GetContextError ( err ) } select { case frame := <- mex . recvCh : if err := mex . checkFrame ( frame ) ; err != nil { return nil , err } return frame , nil case <- mex . ctx . Done ( ) : return nil , GetContextError ( mex . ctx . Err ( ) ) case <- mex . errCh . c : select { case frame := <- mex . recvCh : if err := mex . checkFrame ( frame ) ; err != nil { return nil , err } return frame , nil default : } return nil , mex . errCh . err } }
3767	func ( mex * messageExchange ) recvPeerFrameOfType ( msgType messageType ) ( * Frame , error ) { frame , err := mex . recvPeerFrame ( ) if err != nil { return nil , err } switch frame . Header . messageType { case msgType : return frame , nil case messageTypeError : defer mex . framePool . Release ( frame ) errMsg := errorMessage { id : frame . Header . ID , } var rbuf typed . ReadBuffer rbuf . Wrap ( frame . SizedPayload ( ) ) if err := errMsg . read ( & rbuf ) ; err != nil { return nil , err } return nil , errMsg default : mex . mexset . log . WithFields ( LogField { "header" , frame . Header } , LogField { "expectedType" , msgType } , LogField { "expectedID" , mex . msgID } , ) . Warn ( "Received unexpected frame." ) return nil , errUnexpectedFrameType } }
3768	func ( mex * messageExchange ) shutdown ( ) { if ! mex . shutdownAtomic . CAS ( false , true ) { return } if mex . errChNotified . CAS ( false , true ) { mex . errCh . Notify ( errMexShutdown ) } mex . mexset . removeExchange ( mex . msgID ) }
3769	func newMessageExchangeSet ( log Logger , name string ) * messageExchangeSet { return & messageExchangeSet { name : name , log : log . WithFields ( LogField { "exchange" , name } ) , exchanges : make ( map [ uint32 ] * messageExchange ) , expiredExchanges : make ( map [ uint32 ] struct { } ) , } }
3770	func ( mexset * messageExchangeSet ) addExchange ( mex * messageExchange ) error { if mexset . shutdown { return errMexSetShutdown } if _ , ok := mexset . exchanges [ mex . msgID ] ; ok { return errDuplicateMex } mexset . exchanges [ mex . msgID ] = mex return nil }
3771	func ( mexset * messageExchangeSet ) newExchange ( ctx context . Context , framePool FramePool , msgType messageType , msgID uint32 , bufferSize int ) ( * messageExchange , error ) { if mexset . log . Enabled ( LogLevelDebug ) { mexset . log . Debugf ( "Creating new %s message exchange for [%v:%d]" , mexset . name , msgType , msgID ) } mex := & messageExchange { msgType : msgType , msgID : msgID , ctx : ctx , recvCh : make ( chan * Frame , bufferSize ) , errCh : newErrNotifier ( ) , mexset : mexset , framePool : framePool , } mexset . Lock ( ) addErr := mexset . addExchange ( mex ) mexset . Unlock ( ) if addErr != nil { logger := mexset . log . WithFields ( LogField { "msgID" , mex . msgID } , LogField { "msgType" , mex . msgType } , LogField { "exchange" , mexset . name } , ) if addErr == errMexSetShutdown { logger . Warn ( "Attempted to create new mex after mexset shutdown." ) } else if addErr == errDuplicateMex { logger . Warn ( "Duplicate msg ID for active and new mex." ) } return nil , addErr } mexset . onAdded ( ) return mex , nil }
3772	func ( mexset * messageExchangeSet ) deleteExchange ( msgID uint32 ) ( found , timedOut bool ) { if _ , found := mexset . exchanges [ msgID ] ; found { delete ( mexset . exchanges , msgID ) return true , false } if _ , expired := mexset . expiredExchanges [ msgID ] ; expired { delete ( mexset . expiredExchanges , msgID ) return false , true } return false , false }
3773	func ( mexset * messageExchangeSet ) removeExchange ( msgID uint32 ) { if mexset . log . Enabled ( LogLevelDebug ) { mexset . log . Debugf ( "Removing %s message exchange %d" , mexset . name , msgID ) } mexset . Lock ( ) found , expired := mexset . deleteExchange ( msgID ) mexset . Unlock ( ) if ! found && ! expired { mexset . log . WithFields ( LogField { "msgID" , msgID } , ) . Error ( "Tried to remove exchange multiple times" ) return } mexset . onRemoved ( ) }
3774	func ( mexset * messageExchangeSet ) expireExchange ( msgID uint32 ) { mexset . log . Debugf ( "Removing %s message exchange %d due to timeout, cancellation or blackhole" , mexset . name , msgID , ) mexset . Lock ( ) found , expired := mexset . deleteExchange ( msgID ) if found || expired { mexset . expiredExchanges [ msgID ] = struct { } { } } mexset . Unlock ( ) if expired { mexset . log . WithFields ( LogField { "msgID" , msgID } ) . Info ( "Exchange expired already" ) } mexset . onRemoved ( ) }
3775	func ( mexset * messageExchangeSet ) forwardPeerFrame ( frame * Frame ) error { if mexset . log . Enabled ( LogLevelDebug ) { mexset . log . Debugf ( "forwarding %s %s" , mexset . name , frame . Header ) } mexset . RLock ( ) mex := mexset . exchanges [ frame . Header . ID ] mexset . RUnlock ( ) if mex == nil { mexset . log . WithFields ( LogField { "frameHeader" , frame . Header . String ( ) } , LogField { "exchange" , mexset . name } , ) . Info ( "Received frame for unknown message exchange." ) return nil } if err := mex . forwardPeerFrame ( frame ) ; err != nil { mexset . log . WithFields ( LogField { "frameHeader" , frame . Header . String ( ) } , LogField { "frameSize" , frame . Header . FrameSize ( ) } , LogField { "exchange" , mexset . name } , ErrField ( err ) , ) . Info ( "Failed to forward frame." ) return err } return nil }
3776	func ( mexset * messageExchangeSet ) copyExchanges ( ) ( shutdown bool , exchanges map [ uint32 ] * messageExchange ) { if mexset . shutdown { return true , nil } exchangesCopy := make ( map [ uint32 ] * messageExchange , len ( mexset . exchanges ) ) for k , mex := range mexset . exchanges { exchangesCopy [ k ] = mex } return false , exchangesCopy }
3777	func ( mexset * messageExchangeSet ) stopExchanges ( err error ) { if mexset . log . Enabled ( LogLevelDebug ) { mexset . log . Debugf ( "stopping %v exchanges due to error: %v" , mexset . count ( ) , err ) } mexset . Lock ( ) shutdown , exchanges := mexset . copyExchanges ( ) mexset . shutdown = true mexset . Unlock ( ) if shutdown { mexset . log . Debugf ( "mexset has already been shutdown" ) return } for _ , mex := range exchanges { if mex . errChNotified . CAS ( false , true ) { mex . errCh . Notify ( err ) } } }
3778	func NewFrame ( payloadCapacity int ) * Frame { f := & Frame { } f . buffer = make ( [ ] byte , payloadCapacity + FrameHeaderSize ) f . Payload = f . buffer [ FrameHeaderSize : ] f . headerBuffer = f . buffer [ : FrameHeaderSize ] return f }
3779	func ( f * Frame ) ReadBody ( header [ ] byte , r io . Reader ) error { copy ( f . buffer , header ) if err := f . Header . read ( typed . NewReadBuffer ( header ) ) ; err != nil { return err } switch payloadSize := f . Header . PayloadSize ( ) ; { case payloadSize > MaxFramePayloadSize : return fmt . Errorf ( "invalid frame size %v" , f . Header . size ) case payloadSize > 0 : _ , err := io . ReadFull ( r , f . SizedPayload ( ) ) return err default : return nil } }
3780	func ( f * Frame ) WriteOut ( w io . Writer ) error { var wbuf typed . WriteBuffer wbuf . Wrap ( f . headerBuffer ) if err := f . Header . write ( & wbuf ) ; err != nil { return err } fullFrame := f . buffer [ : f . Header . FrameSize ( ) ] if _ , err := w . Write ( fullFrame ) ; err != nil { return err } return nil }
3781	func ( r RetryOn ) CanRetry ( err error ) bool { if r == RetryNever { return false } if r == RetryDefault { r = RetryConnectionError } code := getErrCode ( err ) if code == ErrCodeBusy || code == ErrCodeDeclined { return true } if code == ErrCodeBadRequest { return false } switch r { case RetryConnectionError : return code == ErrCodeNetwork case RetryUnexpected : return code == ErrCodeUnexpected case RetryIdempotent : return true } return false }
3782	func ( rs * RequestState ) HasRetries ( err error ) bool { if rs == nil { return false } rOpts := rs . retryOpts return rs . Attempt < rOpts . MaxAttempts && rOpts . RetryOn . CanRetry ( err ) }
3783	func ( rs * RequestState ) SinceStart ( now time . Time , fallback time . Duration ) time . Duration { if rs == nil { return fallback } return now . Sub ( rs . Start ) }
3784	func ( rs * RequestState ) AddSelectedPeer ( hostPort string ) { if rs == nil { return } host := getHost ( hostPort ) if rs . SelectedPeers == nil { rs . SelectedPeers = map [ string ] struct { } { hostPort : { } , host : { } , } } else { rs . SelectedPeers [ hostPort ] = struct { } { } rs . SelectedPeers [ host ] = struct { } { } } }
3785	func ( ch * Channel ) RunWithRetry ( runCtx context . Context , f RetriableFunc ) error { var err error opts := getRetryOptions ( runCtx ) rs := ch . getRequestState ( opts ) defer requestStatePool . Put ( rs ) for i := 0 ; i < opts . MaxAttempts ; i ++ { rs . Attempt ++ if opts . TimeoutPerAttempt == 0 { err = f ( runCtx , rs ) } else { attemptCtx , cancel := context . WithTimeout ( runCtx , opts . TimeoutPerAttempt ) err = f ( attemptCtx , rs ) cancel ( ) } if err == nil { return nil } if ! opts . RetryOn . CanRetry ( err ) { if ch . log . Enabled ( LogLevelInfo ) { ch . log . WithFields ( ErrField ( err ) ) . Info ( "Failed after non-retriable error." ) } return err } ch . log . WithFields ( ErrField ( err ) , LogField { "attempt" , rs . Attempt } , LogField { "maxAttempts" , opts . MaxAttempts } , ) . Info ( "Retrying request after retryable error." ) } return err }
3786	func ( t ChecksumType ) ChecksumSize ( ) int { switch t { case ChecksumTypeNone : return 0 case ChecksumTypeCrc32 , ChecksumTypeCrc32C : return crc32 . Size case ChecksumTypeFarmhash : return 4 default : return 0 } }
3787	func ( t ChecksumType ) New ( ) Checksum { s := t . pool ( ) . Get ( ) . ( Checksum ) s . Reset ( ) return s }
3788	func parseTemplates ( skipTChannel bool , templateFiles [ ] string ) ( [ ] * Template , error ) { var templates [ ] * Template if ! skipTChannel { templates = append ( templates , & Template { name : "tchan" , template : template . Must ( parseTemplate ( tchannelTmpl ) ) , } ) } for _ , f := range templateFiles { t , err := parseTemplateFile ( f ) if err != nil { return nil , err } templates = append ( templates , t ) } return templates , nil }
3789	func NewStringSliceFlag ( name string , usage string ) * [ ] string { var ss stringSliceFlag flag . Var ( & ss , name , usage ) return ( * [ ] string ) ( & ss ) }
3790	func ( t * Template ) withStateFuncs ( td TemplateData ) * template . Template { return t . template . Funcs ( map [ string ] interface { } { "goType" : td . global . goType , } ) }
3791	func ( ch * Channel ) IntrospectOthers ( opts * IntrospectionOptions ) map [ string ] [ ] ChannelInfo { if ! opts . IncludeOtherChannels { return nil } channelMap . Lock ( ) defer channelMap . Unlock ( ) states := make ( map [ string ] [ ] ChannelInfo ) for svc , channels := range channelMap . existing { channelInfos := make ( [ ] ChannelInfo , 0 , len ( channels ) ) for _ , otherChan := range channels { if ch == otherChan { continue } channelInfos = append ( channelInfos , otherChan . ReportInfo ( opts ) ) } states [ svc ] = channelInfos } return states }
3792	func ( ch * Channel ) ReportInfo ( opts * IntrospectionOptions ) ChannelInfo { return ChannelInfo { ID : ch . chID , CreatedStack : ch . createdStack , LocalPeer : ch . PeerInfo ( ) , } }
3793	func ( l * RootPeerList ) IntrospectState ( opts * IntrospectionOptions ) map [ string ] PeerRuntimeState { return fromPeerList ( l , opts ) }
3794	func ( subChMap * subChannelMap ) IntrospectState ( opts * IntrospectionOptions ) map [ string ] SubChannelRuntimeState { m := make ( map [ string ] SubChannelRuntimeState ) subChMap . RLock ( ) for k , sc := range subChMap . subchannels { state := SubChannelRuntimeState { Service : k , Isolated : sc . Isolated ( ) , } if state . Isolated { state . IsolatedPeers = sc . Peers ( ) . IntrospectList ( opts ) } if hmap , ok := sc . handler . ( * handlerMap ) ; ok { state . Handler . Type = methodHandler methods := make ( [ ] string , 0 , len ( hmap . handlers ) ) for k := range hmap . handlers { methods = append ( methods , k ) } sort . Strings ( methods ) state . Handler . Methods = methods } else { state . Handler . Type = overrideHandler } m [ k ] = state } subChMap . RUnlock ( ) return m }
3795	func ( p * Peer ) IntrospectState ( opts * IntrospectionOptions ) PeerRuntimeState { p . RLock ( ) defer p . RUnlock ( ) return PeerRuntimeState { HostPort : p . hostPort , InboundConnections : getConnectionRuntimeState ( p . inboundConnections , opts ) , OutboundConnections : getConnectionRuntimeState ( p . outboundConnections , opts ) , ChosenCount : p . chosenCount . Load ( ) , SCCount : p . scCount , } }
3796	func ( c * Connection ) IntrospectState ( opts * IntrospectionOptions ) ConnectionRuntimeState { c . stateMut . RLock ( ) defer c . stateMut . RUnlock ( ) state := ConnectionRuntimeState { ID : c . connID , ConnectionState : c . state . String ( ) , LocalHostPort : c . conn . LocalAddr ( ) . String ( ) , RemoteHostPort : c . conn . RemoteAddr ( ) . String ( ) , OutboundHostPort : c . outboundHP , RemotePeer : c . remotePeerInfo , InboundExchange : c . inbound . IntrospectState ( opts ) , OutboundExchange : c . outbound . IntrospectState ( opts ) , HealthChecks : c . healthCheckHistory . asBools ( ) , LastActivity : c . lastActivity . Load ( ) , } if c . relay != nil { state . Relayer = c . relay . IntrospectState ( opts ) } return state }
3797	func ( r * Relayer ) IntrospectState ( opts * IntrospectionOptions ) RelayerRuntimeState { count := r . inbound . Count ( ) + r . outbound . Count ( ) return RelayerRuntimeState { Count : count , InboundItems : r . inbound . IntrospectState ( opts , "inbound" ) , OutboundItems : r . outbound . IntrospectState ( opts , "outbound" ) , MaxTimeout : r . maxTimeout , } }
3798	func ( ri * relayItems ) IntrospectState ( opts * IntrospectionOptions , name string ) RelayItemSetState { ri . RLock ( ) defer ri . RUnlock ( ) setState := RelayItemSetState { Name : name , Count : ri . Count ( ) , } if opts . IncludeExchanges { setState . Items = make ( map [ string ] RelayItemState , len ( ri . items ) ) for k , v := range ri . items { if ! opts . IncludeTombstones && v . tomb { continue } state := RelayItemState { ID : k , RemapID : v . remapID , DestinationConnectionID : v . destination . conn . connID , Tomb : v . tomb , } setState . Items [ strconv . Itoa ( int ( k ) ) ] = state } } return setState }
3799	func ( mexset * messageExchangeSet ) IntrospectState ( opts * IntrospectionOptions ) ExchangeSetRuntimeState { mexset . RLock ( ) setState := ExchangeSetRuntimeState { Name : mexset . name , Count : len ( mexset . exchanges ) , } if opts . IncludeExchanges { setState . Exchanges = make ( map [ string ] ExchangeRuntimeState , len ( mexset . exchanges ) ) for k , v := range mexset . exchanges { state := ExchangeRuntimeState { ID : k , MessageType : v . msgType , } setState . Exchanges [ strconv . Itoa ( int ( k ) ) ] = state } } mexset . RUnlock ( ) return setState }
3800	func NewContext ( timeout time . Duration ) ( Context , context . CancelFunc ) { ctx , cancel := tchannel . NewContext ( timeout ) return tchannel . WrapWithHeaders ( ctx , nil ) , cancel }
3801	func WriteResponse ( response * tchannel . InboundCallResponse , resp * Res ) error { if resp . SystemErr != nil { return response . SendSystemError ( resp . SystemErr ) } if resp . IsErr { if err := response . SetApplicationError ( ) ; err != nil { return err } } if err := tchannel . NewArgWriter ( response . Arg2Writer ( ) ) . Write ( resp . Arg2 ) ; err != nil { return err } return tchannel . NewArgWriter ( response . Arg3Writer ( ) ) . Write ( resp . Arg3 ) }
3802	func Wrap ( handler Handler ) tchannel . Handler { return tchannel . HandlerFunc ( func ( ctx context . Context , call * tchannel . InboundCall ) { args , err := ReadArgs ( call ) if err != nil { handler . OnError ( ctx , err ) return } resp , err := handler . Handle ( ctx , args ) response := call . Response ( ) if err != nil { resp = & Res { SystemErr : err , } } if err := WriteResponse ( response , resp ) ; err != nil { handler . OnError ( ctx , err ) } } ) }
3803	func ( s * injectableSpan ) initFromOpenTracing ( span opentracing . Span ) error { return span . Tracer ( ) . Inject ( span . Context ( ) , zipkinSpanFormat , s ) }
3804	func ( c * Connection ) startOutboundSpan ( ctx context . Context , serviceName , methodName string , call * OutboundCall , startTime time . Time ) opentracing . Span { var parent opentracing . SpanContext if s := opentracing . SpanFromContext ( ctx ) ; s != nil { parent = s . Context ( ) } span := c . Tracer ( ) . StartSpan ( methodName , opentracing . ChildOf ( parent ) , opentracing . StartTime ( startTime ) , ) if isTracingDisabled ( ctx ) { ext . SamplingPriority . Set ( span , 0 ) } ext . SpanKindRPCClient . Set ( span ) ext . PeerService . Set ( span , serviceName ) c . setPeerHostPort ( span ) span . SetTag ( "as" , call . callReq . Headers [ ArgScheme ] ) var injectable injectableSpan if err := injectable . initFromOpenTracing ( span ) ; err == nil { call . callReq . Tracing = Span ( injectable ) } else { call . callReq . Tracing . initRandom ( ) } return span }
3805	func intToIP4 ( ip uint32 ) net . IP { return net . IP { byte ( ip >> 24 & 0xff ) , byte ( ip >> 16 & 0xff ) , byte ( ip >> 8 & 0xff ) , byte ( ip & 0xff ) , } }
3806	func servicePeerToHostPort ( peer * hyperbahn . ServicePeer ) string { host := intToIP4 ( uint32 ( * peer . IP . Ipv4 ) ) . String ( ) port := strconv . Itoa ( int ( peer . Port ) ) return net . JoinHostPort ( host , port ) }
3807	func NewStatsdReporter ( addr , prefix string ) ( tchannel . StatsReporter , error ) { client , err := statsd . NewBufferedClient ( addr , prefix , time . Second , 0 ) if err != nil { return nil , err } return NewStatsdReporterClient ( client ) , nil }
3808	func ( r * ToS ) UnmarshalText ( data [ ] byte ) error { if v , ok := _tosNameToValue [ string ( data ) ] ; ok { * r = v return nil } return fmt . Errorf ( "invalid ToS %q" , string ( data ) ) }
3809	func ( ph * peerHeap ) Push ( x interface { } ) { n := len ( ph . peerScores ) item := x . ( * peerScore ) item . index = n ph . peerScores = append ( ph . peerScores , item ) }
3810	func ( ph * peerHeap ) Pop ( ) interface { } { old := * ph n := len ( old . peerScores ) item := old . peerScores [ n - 1 ] item . index = - 1 ph . peerScores = old . peerScores [ : n - 1 ] return item }
3811	func ( ph * peerHeap ) updatePeer ( peerScore * peerScore ) { heap . Fix ( ph , peerScore . index ) }
3812	func ( ph * peerHeap ) removePeer ( peerScore * peerScore ) { heap . Remove ( ph , peerScore . index ) }
3813	func ( ph * peerHeap ) pushPeer ( peerScore * peerScore ) { ph . order ++ newOrder := ph . order randRange := ph . Len ( ) / 2 + 1 peerScore . order = newOrder + uint64 ( ph . rng . Intn ( randRange ) ) heap . Push ( ph , peerScore ) }
3814	func ( ph * peerHeap ) addPeer ( peerScore * peerScore ) { ph . pushPeer ( peerScore ) r := ph . rng . Intn ( ph . Len ( ) ) ph . swapOrder ( peerScore . index , r ) }
3815	func NewClient ( ch * tchannel . Channel , serviceName string , opts * ClientOptions ) TChanClient { client := & client { ch : ch , sc : ch . GetSubChannel ( serviceName ) , serviceName : serviceName , } if opts != nil { client . opts = * opts } return client }
3816	func ( l * RootPeerList ) Add ( hostPort string ) * Peer { l . RLock ( ) if p , ok := l . peersByHostPort [ hostPort ] ; ok { l . RUnlock ( ) return p } l . RUnlock ( ) l . Lock ( ) defer l . Unlock ( ) if p , ok := l . peersByHostPort [ hostPort ] ; ok { return p } var p * Peer p = newPeer ( l . channel , hostPort , l . onPeerStatusChanged , l . onClosedConnRemoved ) l . peersByHostPort [ hostPort ] = p return p }
3817	func ( l * RootPeerList ) Get ( hostPort string ) ( * Peer , bool ) { l . RLock ( ) p , ok := l . peersByHostPort [ hostPort ] l . RUnlock ( ) return p , ok }
3818	func WithTimeout ( timeout time . Duration ) Option { return func ( opts * options ) { opts . timeout = timeout } }
3819	func ( s * Service ) Methods ( ) [ ] * Method { if s . methods != nil { return s . methods } for _ , m := range s . Service . Methods { s . methods = append ( s . methods , & Method { m , s , s . state } ) } sort . Sort ( byMethodName ( s . methods ) ) return s . methods }
3820	func ( s * Service ) InheritedMethods ( ) [ ] string { if s . inheritedMethods != nil { return s . inheritedMethods } for svc := s . ExtendsService ; svc != nil ; svc = svc . ExtendsService { for m := range svc . Service . Methods { s . inheritedMethods = append ( s . inheritedMethods , m ) } } sort . Strings ( s . inheritedMethods ) return s . inheritedMethods }
3821	func ( m * Method ) Arguments ( ) [ ] * Field { var args [ ] * Field for _ , f := range m . Method . Arguments { args = append ( args , & Field { f , m . state } ) } return args }
3822	func ( m * Method ) ArgList ( ) string { args := [ ] string { "ctx " + contextType ( ) } for _ , arg := range m . Arguments ( ) { args = append ( args , arg . Declaration ( ) ) } return strings . Join ( args , ", " ) }
3823	func ( m * Method ) CallList ( reqStruct string ) string { args := [ ] string { "ctx" } for _ , arg := range m . Arguments ( ) { args = append ( args , reqStruct + "." + arg . ArgStructName ( ) ) } return strings . Join ( args , ", " ) }
3824	func ( m * Method ) RetType ( ) string { if ! m . HasReturn ( ) { return "error" } return fmt . Sprintf ( "(%v, %v)" , m . state . goType ( m . Method . ReturnType ) , "error" ) }
3825	func ( m * Method ) WrapResult ( respVar string ) string { if ! m . HasReturn ( ) { panic ( "cannot wrap a return when there is no return mode" ) } if m . state . isResultPointer ( m . ReturnType ) { return respVar } return "&" + respVar }
3826	func ( m * Method ) ReturnWith ( respName string , errName string ) string { if ! m . HasReturn ( ) { return errName } return fmt . Sprintf ( "%v, %v" , respName , errName ) }
3827	func ( a * Field ) Declaration ( ) string { return fmt . Sprintf ( "%s %s" , a . Name ( ) , a . ArgType ( ) ) }
3828	func startIdleSweep ( ch * Channel , opts * ChannelOptions ) * idleSweep { is := & idleSweep { ch : ch , maxIdleTime : opts . MaxIdleTime , idleCheckInterval : opts . IdleCheckInterval , } is . start ( ) return is }
3829	func ( is * idleSweep ) start ( ) { if is . started || is . idleCheckInterval <= 0 { return } is . ch . log . WithFields ( LogField { "idleCheckInterval" , is . idleCheckInterval } , LogField { "maxIdleTime" , is . maxIdleTime } , ) . Info ( "Starting idle connections poller." ) is . started = true is . stopCh = make ( chan struct { } ) go is . pollerLoop ( ) }
3830	func ( is * idleSweep ) Stop ( ) { if ! is . started { return } is . started = false is . ch . log . Info ( "Stopping idle connections poller." ) close ( is . stopCh ) }
3831	func ResolveWithGoPath ( filename string ) ( string , error ) { for _ , file := range goPathCandidates ( filename ) { if _ , err := os . Stat ( file ) ; ! os . IsNotExist ( err ) { return file , nil } } return "" , fmt . Errorf ( "file not found on GOPATH: %q" , filename ) }
3832	func setExtends ( state map [ string ] parseState ) error { for _ , v := range state { for _ , s := range v . services { if s . Extends == "" { continue } var searchServices [ ] * Service var searchFor string parts := strings . SplitN ( s . Extends , "." , 2 ) if len ( parts ) < 2 { searchServices = v . services searchFor = s . Extends } else { include := v . global . includes [ parts [ 0 ] ] s . ExtendsPrefix = include . pkg + "." searchServices = state [ include . file ] . services searchFor = parts [ 1 ] } foundService := sort . Search ( len ( searchServices ) , func ( i int ) bool { return searchServices [ i ] . Name >= searchFor } ) if foundService == len ( searchServices ) { return fmt . Errorf ( "failed to find base service %q for %q" , s . Extends , s . Name ) } s . ExtendsService = searchServices [ foundService ] } } return nil }
3833	func ( hmap * handlerMap ) register ( h Handler , method string ) { hmap . Lock ( ) defer hmap . Unlock ( ) if hmap . handlers == nil { hmap . handlers = make ( map [ string ] Handler ) } hmap . handlers [ method ] = h }
3834	func NewClient ( hosts [ ] string , optFns ... Option ) Client { opts := getOptions ( optFns ) if opts . external { return newExternalClient ( hosts , opts ) } if opts . numClients > 1 { return newInternalMultiClient ( hosts , opts ) } return newClient ( hosts , opts ) }
3835	func ListenIP ( ) ( net . IP , error ) { interfaces , err := net . Interfaces ( ) if err != nil { return nil , err } return listenIP ( interfaces ) }
3836	func ( s * listener ) Close ( ) error { if err := s . Listener . Close ( ) ; err != nil { return err } s . cond . L . Lock ( ) for s . refs > 0 { s . cond . Wait ( ) } s . cond . L . Unlock ( ) return nil }
3837	func ReadArgsV2 ( r tchannel . ArgReadable ) ( [ ] byte , [ ] byte , error ) { var arg2 , arg3 [ ] byte if err := tchannel . NewArgReader ( r . Arg2Reader ( ) ) . Read ( & arg2 ) ; err != nil { return nil , nil , err } if err := tchannel . NewArgReader ( r . Arg3Reader ( ) ) . Read ( & arg3 ) ; err != nil { return nil , nil , err } return arg2 , arg3 , nil }
3838	func WriteArgs ( call * tchannel . OutboundCall , arg2 , arg3 [ ] byte ) ( [ ] byte , [ ] byte , * tchannel . OutboundCallResponse , error ) { if err := tchannel . NewArgWriter ( call . Arg2Writer ( ) ) . Write ( arg2 ) ; err != nil { return nil , nil , nil , err } if err := tchannel . NewArgWriter ( call . Arg3Writer ( ) ) . Write ( arg3 ) ; err != nil { return nil , nil , nil , err } resp := call . Response ( ) var respArg2 [ ] byte if err := tchannel . NewArgReader ( resp . Arg2Reader ( ) ) . Read ( & respArg2 ) ; err != nil { return nil , nil , nil , err } var respArg3 [ ] byte if err := tchannel . NewArgReader ( resp . Arg3Reader ( ) ) . Read ( & respArg3 ) ; err != nil { return nil , nil , nil , err } return respArg2 , respArg3 , resp , nil }
3839	func Call ( ctx context . Context , ch * tchannel . Channel , hostPort string , serviceName , method string , arg2 , arg3 [ ] byte ) ( [ ] byte , [ ] byte , * tchannel . OutboundCallResponse , error ) { call , err := ch . BeginCall ( ctx , hostPort , serviceName , method , nil ) if err != nil { return nil , nil , nil , err } return WriteArgs ( call , arg2 , arg3 ) }
3840	func CallSC ( ctx context . Context , sc * tchannel . SubChannel , method string , arg2 , arg3 [ ] byte ) ( [ ] byte , [ ] byte , * tchannel . OutboundCallResponse , error ) { call , err := sc . BeginCall ( ctx , method , nil ) if err != nil { return nil , nil , nil , err } return WriteArgs ( call , arg2 , arg3 ) }
3841	func CallV2 ( ctx context . Context , sc * tchannel . SubChannel , cArgs CArgs ) ( * CRes , error ) { call , err := sc . BeginCall ( ctx , cArgs . Method , cArgs . CallOptions ) if err != nil { return nil , err } arg2 , arg3 , res , err := WriteArgs ( call , cArgs . Arg2 , cArgs . Arg3 ) if err != nil { return nil , err } return & CRes { Arg2 : arg2 , Arg3 : arg3 , AppError : res . ApplicationError ( ) , } , nil }
3842	func NewRealRelay ( services map [ string ] [ ] string ) ( Relay , error ) { hosts := & fixedHosts { hosts : services } ch , err := tchannel . NewChannel ( "relay" , & tchannel . ChannelOptions { RelayHost : relaytest . HostFunc ( hosts . Get ) , Logger : tchannel . NewLevelLogger ( tchannel . NewLogger ( os . Stderr ) , tchannel . LogLevelWarn ) , } ) if err != nil { return nil , err } if err := ch . ListenAndServe ( "127.0.0.1:0" ) ; err != nil { return nil , err } return & realRelay { ch : ch , hosts : hosts , } , nil }
3843	func NewServer ( registrar tchannel . Registrar ) * Server { metaHandler := newMetaHandler ( ) server := & Server { ch : registrar , log : registrar . Logger ( ) , handlers : make ( map [ string ] handler ) , metaHandler : metaHandler , ctxFn : defaultContextFn , } server . Register ( newTChanMetaServer ( metaHandler ) ) if ch , ok := registrar . ( * tchannel . Channel ) ; ok { NewServer ( ch . GetSubChannel ( "tchannel" ) ) } return server }
3844	func ( s * Server ) RegisterHealthHandler ( f HealthFunc ) { wrapped := func ( ctx Context , r HealthRequest ) ( bool , string ) { return f ( ctx ) } s . metaHandler . setHandler ( wrapped ) }
3845	func ( s * Server ) Handle ( ctx context . Context , call * tchannel . InboundCall ) { op := call . MethodString ( ) service , method , ok := getServiceMethod ( op ) if ! ok { log . Fatalf ( "Handle got call for %s which does not match the expected call format" , op ) } s . RLock ( ) handler , ok := s . handlers [ service ] s . RUnlock ( ) if ! ok { log . Fatalf ( "Handle got call for service %v which is not registered" , service ) } if err := s . handle ( ctx , handler , method , call ) ; err != nil { s . onError ( call , err ) } }
3846	func ( c SystemErrCode ) MetricsKey ( ) string { switch c { case ErrCodeInvalid : return "invalid" case ErrCodeTimeout : return "timeout" case ErrCodeCancelled : return "cancelled" case ErrCodeBusy : return "busy" case ErrCodeDeclined : return "declined" case ErrCodeUnexpected : return "unexpected-error" case ErrCodeBadRequest : return "bad-request" case ErrCodeNetwork : return "network-error" case ErrCodeProtocol : return "protocol-error" default : return c . String ( ) } }
3847	func NewSystemError ( code SystemErrCode , msg string , args ... interface { } ) error { return SystemError { code : code , msg : fmt . Sprintf ( msg , args ... ) } }
3848	func NewWrappedSystemError ( code SystemErrCode , wrapped error ) error { if se , ok := wrapped . ( SystemError ) ; ok { return se } return SystemError { code : code , msg : fmt . Sprint ( wrapped ) , wrapped : wrapped } }
3849	func ( se SystemError ) Error ( ) string { return fmt . Sprintf ( "tchannel error %v: %s" , se . Code ( ) , se . msg ) }
3850	func GetContextError ( err error ) error { if err == context . DeadlineExceeded { return ErrTimeout } if err == context . Canceled { return ErrRequestCancelled } return err }
3851	func GetSystemErrorCode ( err error ) SystemErrCode { if err == nil { return ErrCodeInvalid } if se , ok := err . ( SystemError ) ; ok { return se . Code ( ) } return ErrCodeUnexpected }
3852	func ( c * Connection ) ping ( ctx context . Context ) error { req := & pingReq { id : c . NextMessageID ( ) } mex , err := c . outbound . newExchange ( ctx , c . opts . FramePool , req . messageType ( ) , req . ID ( ) , 1 ) if err != nil { return c . connectionError ( "create ping exchange" , err ) } defer c . outbound . removeExchange ( req . ID ( ) ) if err := c . sendMessage ( req ) ; err != nil { return c . connectionError ( "send ping" , err ) } return c . recvMessage ( ctx , & pingRes { } , mex ) }
3853	func ( c * Connection ) handlePingRes ( frame * Frame ) bool { if err := c . outbound . forwardPeerFrame ( frame ) ; err != nil { c . log . WithFields ( LogField { "response" , frame . Header } ) . Warn ( "Unexpected ping response." ) return true } return false }
3854	func ( c * Connection ) handlePingReq ( frame * Frame ) { if state := c . readState ( ) ; state != connectionActive { c . protocolError ( frame . Header . ID , errConnNotActive { "ping on incoming" , state } ) return } pingRes := & pingRes { id : frame . Header . ID } if err := c . sendMessage ( pingRes ) ; err != nil { c . connectionError ( "send pong" , err ) } }
3855	func ( c * Connection ) SendSystemError ( id uint32 , span Span , err error ) error { frame := c . opts . FramePool . Get ( ) if err := frame . write ( & errorMessage { id : id , errCode : GetSystemErrorCode ( err ) , tracing : span , message : GetSystemErrorMessage ( err ) , } ) ; err != nil { c . log . WithFields ( LogField { "remotePeer" , c . remotePeerInfo } , LogField { "id" , id } , ErrField ( err ) , ) . Warn ( "Couldn't create outbound frame." ) return fmt . Errorf ( "failed to create outbound error frame: %v" , err ) } return c . withStateRLock ( func ( ) error { if c . state == connectionClosed { c . log . WithFields ( LogField { "remotePeer" , c . remotePeerInfo } , LogField { "id" , id } , ) . Info ( "Could not send error frame on closed connection." ) return fmt . Errorf ( "failed to send error frame, connection state %v" , c . state ) } select { case c . sendCh <- frame : return nil default : } c . log . WithFields ( LogField { "remotePeer" , c . remotePeerInfo } , LogField { "id" , id } , ErrField ( err ) , ) . Warn ( "Couldn't send outbound frame." ) return fmt . Errorf ( "failed to send error frame, buffer full" ) } ) }
3856	func ( c * Connection ) connectionError ( site string , err error ) error { var closeLogFields LogFields if err == io . EOF { closeLogFields = LogFields { { "reason" , "network connection EOF" } } } else { closeLogFields = LogFields { { "reason" , "connection error" } , ErrField ( err ) , } } c . stopHealthCheck ( ) err = c . logConnectionError ( site , err ) c . close ( closeLogFields ... ) if c . stoppedExchanges . CAS ( false , true ) { c . outbound . stopExchanges ( err ) c . inbound . stopExchanges ( err ) } c . checkExchanges ( ) return err }
3857	func ( c * Connection ) withStateLock ( f func ( ) error ) error { c . stateMut . Lock ( ) err := f ( ) c . stateMut . Unlock ( ) return err }
3858	func ( c * Connection ) withStateRLock ( f func ( ) error ) error { c . stateMut . RLock ( ) err := f ( ) c . stateMut . RUnlock ( ) return err }
3859	func ( c * Connection ) readFrames ( _ uint32 ) { headerBuf := make ( [ ] byte , FrameHeaderSize ) handleErr := func ( err error ) { if ! c . closeNetworkCalled . Load ( ) { c . connectionError ( "read frames" , err ) } else { c . log . Debugf ( "Ignoring error after connection was closed: %v" , err ) } } for { if _ , err := io . ReadFull ( c . conn , headerBuf ) ; err != nil { handleErr ( err ) return } frame := c . opts . FramePool . Get ( ) if err := frame . ReadBody ( headerBuf , c . conn ) ; err != nil { handleErr ( err ) c . opts . FramePool . Release ( frame ) return } c . updateLastActivity ( frame ) var releaseFrame bool if c . relay == nil { releaseFrame = c . handleFrameNoRelay ( frame ) } else { releaseFrame = c . handleFrameRelay ( frame ) } if releaseFrame { c . opts . FramePool . Release ( frame ) } } }
3860	func ( c * Connection ) writeFrames ( _ uint32 ) { for { select { case f := <- c . sendCh : if c . log . Enabled ( LogLevelDebug ) { c . log . Debugf ( "Writing frame %s" , f . Header ) } c . updateLastActivity ( f ) err := f . WriteOut ( c . conn ) c . opts . FramePool . Release ( f ) if err != nil { c . connectionError ( "write frames" , err ) return } case <- c . stopCh : if len ( c . sendCh ) > 0 { continue } c . closeNetwork ( ) return } } }
3861	func ( c * Connection ) hasPendingCalls ( ) bool { if c . inbound . count ( ) > 0 || c . outbound . count ( ) > 0 { return true } if ! c . relay . canClose ( ) { return true } return false }
3862	func ( c * Connection ) checkExchanges ( ) { c . callOnExchangeChange ( ) moveState := func ( fromState , toState connectionState ) bool { err := c . withStateLock ( func ( ) error { if c . state != fromState { return errors . New ( "" ) } c . state = toState return nil } ) return err == nil } curState := c . readState ( ) origState := curState if curState != connectionClosed && c . stoppedExchanges . Load ( ) { if moveState ( curState , connectionClosed ) { curState = connectionClosed } } if curState == connectionStartClose { if ! c . relay . canClose ( ) { return } if c . inbound . count ( ) == 0 && moveState ( connectionStartClose , connectionInboundClosed ) { curState = connectionInboundClosed } } if curState == connectionInboundClosed { if ! c . relay . canClose ( ) { c . relay . logger . Error ( "Relay can't close even though state is InboundClosed." ) return } if c . outbound . count ( ) == 0 && moveState ( connectionInboundClosed , connectionClosed ) { curState = connectionClosed } } if curState != origState { if curState == connectionClosed { close ( c . stopCh ) } c . log . WithFields ( LogField { "newState" , curState } , ) . Debug ( "Connection state updated during shutdown." ) c . callOnCloseStateChange ( ) } }
3863	func ( c * Connection ) closeNetwork ( ) { c . log . Debugf ( "Closing underlying network connection" ) c . stopHealthCheck ( ) c . closeNetworkCalled . Store ( true ) if err := c . conn . Close ( ) ; err != nil { c . log . WithFields ( LogField { "remotePeer" , c . remotePeerInfo } , ErrField ( err ) , ) . Warn ( "Couldn't close connection to peer." ) } }
3864	func ( c * Connection ) getLastActivityTime ( ) time . Time { return time . Unix ( 0 , c . lastActivity . Load ( ) ) }
3865	func Validate ( svc * parser . Service ) error { for _ , m := range svc . Methods { if err := validateMethod ( svc , m ) ; err != nil { return err } } return nil }
3866	func ( c * Client ) logFailedRegistrationRetry ( errLogger tchannel . Logger , consecutiveFailures uint ) { logFn := errLogger . Info if consecutiveFailures > maxAdvertiseFailures { logFn = errLogger . Warn } logFn ( "Hyperbahn client registration failed, will retry." ) }
3867	func ( c * Client ) initialAdvertise ( ) error { var err error for attempt := uint ( 0 ) ; attempt < maxAdvertiseFailures ; attempt ++ { err = c . sendAdvertise ( ) if err == nil || err == errEphemeralPeer { break } c . tchan . Logger ( ) . WithFields ( tchannel . ErrField ( err ) ) . Info ( "Hyperbahn client initial registration failure, will retry" ) sleepFor := fuzzInterval ( advertiseRetryInterval * time . Duration ( 1 << attempt ) ) c . sleep ( sleepFor ) } return err }
3868	func ( f lazyCallReq ) Service ( ) [ ] byte { l := f . Payload [ _serviceLenIndex ] return f . Payload [ _serviceNameIndex : _serviceNameIndex + l ] }
3869	func ( f lazyCallReq ) TTL ( ) time . Duration { ttl := binary . BigEndian . Uint32 ( f . Payload [ _ttlIndex : _ttlIndex + _ttlLen ] ) return time . Duration ( ttl ) * time . Millisecond }
3870	func ( f lazyCallReq ) SetTTL ( d time . Duration ) { ttl := uint32 ( d / time . Millisecond ) binary . BigEndian . PutUint32 ( f . Payload [ _ttlIndex : _ttlIndex + _ttlLen ] , ttl ) }
3871	func finishesCall ( f * Frame ) bool { switch f . messageType ( ) { case messageTypeError : return true case messageTypeCallRes , messageTypeCallResContinue : flags := f . Payload [ _flagsIndex ] return flags & hasMoreFragmentsFlag == 0 default : return false } }
3872	func ( ps * PlatformStrings ) Flat ( ) [ ] string { unique := make ( map [ string ] struct { } ) for _ , s := range ps . Generic { unique [ s ] = struct { } { } } for _ , ss := range ps . OS { for _ , s := range ss { unique [ s ] = struct { } { } } } for _ , ss := range ps . Arch { for _ , s := range ss { unique [ s ] = struct { } { } } } for _ , ss := range ps . Platform { for _ , s := range ss { unique [ s ] = struct { } { } } } flat := make ( [ ] string , 0 , len ( unique ) ) for s := range unique { flat = append ( flat , s ) } sort . Strings ( flat ) return flat }
3873	func ( ps * PlatformStrings ) Map ( f func ( s string ) ( string , error ) ) ( PlatformStrings , [ ] error ) { var errors [ ] error mapSlice := func ( ss [ ] string ) ( [ ] string , error ) { rs := make ( [ ] string , 0 , len ( ss ) ) for _ , s := range ss { if r , err := f ( s ) ; err != nil { errors = append ( errors , err ) } else if r != "" { rs = append ( rs , r ) } } return rs , nil } result , _ := ps . MapSlice ( mapSlice ) return result , errors }
3874	func ( ps * PlatformStrings ) MapSlice ( f func ( [ ] string ) ( [ ] string , error ) ) ( PlatformStrings , [ ] error ) { var errors [ ] error mapSlice := func ( ss [ ] string ) [ ] string { rs , err := f ( ss ) if err != nil { errors = append ( errors , err ) return nil } return rs } mapStringMap := func ( m map [ string ] [ ] string ) map [ string ] [ ] string { if m == nil { return nil } rm := make ( map [ string ] [ ] string ) for k , ss := range m { ss = mapSlice ( ss ) if len ( ss ) > 0 { rm [ k ] = ss } } if len ( rm ) == 0 { return nil } return rm } mapPlatformMap := func ( m map [ Platform ] [ ] string ) map [ Platform ] [ ] string { if m == nil { return nil } rm := make ( map [ Platform ] [ ] string ) for k , ss := range m { ss = mapSlice ( ss ) if len ( ss ) > 0 { rm [ k ] = ss } } if len ( rm ) == 0 { return nil } return rm } result := PlatformStrings { Generic : mapSlice ( ps . Generic ) , OS : mapStringMap ( ps . OS ) , Arch : mapStringMap ( ps . Arch ) , Platform : mapPlatformMap ( ps . Platform ) , } return result , errors }
3875	func GetProtoConfig ( c * config . Config ) * ProtoConfig { pc := c . Exts [ protoName ] if pc == nil { return nil } return pc . ( * ProtoConfig ) }
3876	func MapExprStrings ( e bzl . Expr , f func ( string ) string ) bzl . Expr { if e == nil { return nil } switch expr := e . ( type ) { case * bzl . StringExpr : s := f ( expr . Value ) if s == "" { return nil } ret := * expr ret . Value = s return & ret case * bzl . ListExpr : var list [ ] bzl . Expr for _ , elem := range expr . List { elem = MapExprStrings ( elem , f ) if elem != nil { list = append ( list , elem ) } } if len ( list ) == 0 && len ( expr . List ) > 0 { return nil } ret := * expr ret . List = list return & ret case * bzl . DictExpr : var cases [ ] bzl . Expr isEmpty := true for _ , kv := range expr . List { keyval , ok := kv . ( * bzl . KeyValueExpr ) if ! ok { log . Panicf ( "unexpected expression in generated imports dict: %#v" , kv ) } value := MapExprStrings ( keyval . Value , f ) if value != nil { cases = append ( cases , & bzl . KeyValueExpr { Key : keyval . Key , Value : value } ) if key , ok := keyval . Key . ( * bzl . StringExpr ) ; ! ok || key . Value != "//conditions:default" { isEmpty = false } } } if isEmpty { return nil } ret := * expr ret . List = cases return & ret case * bzl . CallExpr : if x , ok := expr . X . ( * bzl . Ident ) ; ! ok || x . Name != "select" || len ( expr . List ) != 1 { log . Panicf ( "unexpected call expression in generated imports: %#v" , e ) } arg := MapExprStrings ( expr . List [ 0 ] , f ) if arg == nil { return nil } call := * expr call . List [ 0 ] = arg return & call case * bzl . BinaryExpr : x := MapExprStrings ( expr . X , f ) y := MapExprStrings ( expr . Y , f ) if x == nil { return y } if y == nil { return x } binop := * expr binop . X = x binop . Y = y return & binop default : return nil } }
3877	func FlattenExpr ( e bzl . Expr ) bzl . Expr { ps , err := extractPlatformStringsExprs ( e ) if err != nil { return e } ls := makeListSquasher ( ) addElem := func ( e bzl . Expr ) bool { s , ok := e . ( * bzl . StringExpr ) if ! ok { return false } ls . add ( s ) return true } addList := func ( e bzl . Expr ) bool { l , ok := e . ( * bzl . ListExpr ) if ! ok { return false } for _ , elem := range l . List { if ! addElem ( elem ) { return false } } return true } addDict := func ( d * bzl . DictExpr ) bool { for _ , kv := range d . List { if ! addList ( kv . ( * bzl . KeyValueExpr ) . Value ) { return false } } return true } if ps . generic != nil { if ! addList ( ps . generic ) { return e } } for _ , d := range [ ] * bzl . DictExpr { ps . os , ps . arch , ps . platform } { if d == nil { continue } if ! addDict ( d ) { return e } } return ls . list ( ) }
3878	func makePlatformStringsExpr ( ps platformStringsExprs ) bzl . Expr { makeSelect := func ( dict * bzl . DictExpr ) bzl . Expr { return & bzl . CallExpr { X : & bzl . Ident { Name : "select" } , List : [ ] bzl . Expr { dict } , } } forceMultiline := func ( e bzl . Expr ) { switch e := e . ( type ) { case * bzl . ListExpr : e . ForceMultiLine = true case * bzl . CallExpr : e . List [ 0 ] . ( * bzl . DictExpr ) . ForceMultiLine = true } } var parts [ ] bzl . Expr if ps . generic != nil { parts = append ( parts , ps . generic ) } if ps . os != nil { parts = append ( parts , makeSelect ( ps . os ) ) } if ps . arch != nil { parts = append ( parts , makeSelect ( ps . arch ) ) } if ps . platform != nil { parts = append ( parts , makeSelect ( ps . platform ) ) } if len ( parts ) == 0 { return nil } if len ( parts ) == 1 { return parts [ 0 ] } expr := parts [ 0 ] forceMultiline ( expr ) for _ , part := range parts [ 1 : ] { forceMultiline ( part ) expr = & bzl . BinaryExpr { Op : "+" , X : expr , Y : part , } } return expr }
3879	func ( p Platform ) String ( ) string { switch { case p . OS != "" && p . Arch != "" : return p . OS + "_" + p . Arch case p . OS != "" : return p . OS case p . Arch != "" : return p . Arch default : return "" } }
3880	func Find ( dir string ) ( string , error ) { dir , err := filepath . Abs ( dir ) if err != nil { return "" , err } for { _ , err = os . Stat ( filepath . Join ( dir , workspaceFile ) ) if err == nil { return dir , nil } if ! os . IsNotExist ( err ) { return "" , err } if strings . HasSuffix ( dir , string ( os . PathSeparator ) ) { return "" , os . ErrNotExist } dir = filepath . Dir ( dir ) } }
3881	func runGazelle ( mode mode , dirs [ ] string ) error { if mode == fastMode && len ( dirs ) == 0 { return nil } args := [ ] string { os . Getenv ( "BAZEL_REAL" ) , "run" , * gazelleLabel , "--" , "-args" } args = append ( args , "-index=false" ) if mode == fastMode { args = append ( args , "-r=false" ) args = append ( args , dirs ... ) } cmd := exec . Command ( args [ 0 ] , args [ 1 : ] ... ) cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr log . Printf ( "running gazelle: %s\n" , \n ) strings . Join ( cmd . Args , " " ) }
3882	func restoreBuildFilesInRepo ( ) { err := filepath . Walk ( "." , func ( path string , info os . FileInfo , err error ) error { if err != nil { log . Print ( err ) return nil } restoreBuildFilesInDir ( path ) return nil } ) if err != nil { log . Print ( err ) } }
3883	func FixLoads ( f * rule . File , knownLoads [ ] rule . LoadInfo ) { knownFiles := make ( map [ string ] bool ) knownKinds := make ( map [ string ] string ) for _ , l := range knownLoads { knownFiles [ l . Name ] = true for _ , k := range l . Symbols { knownKinds [ k ] = l . Name } } f . Sync ( ) var loads [ ] * rule . Load otherLoadedKinds := make ( map [ string ] bool ) for _ , l := range f . Loads { if knownFiles [ l . Name ( ) ] { loads = append ( loads , l ) continue } for _ , sym := range l . Symbols ( ) { otherLoadedKinds [ sym ] = true } } usedKinds := make ( map [ string ] map [ string ] bool ) for _ , r := range f . Rules { kind := r . Kind ( ) if file , ok := knownKinds [ kind ] ; ok && ! otherLoadedKinds [ kind ] { if usedKinds [ file ] == nil { usedKinds [ file ] = make ( map [ string ] bool ) } usedKinds [ file ] [ kind ] = true } } for _ , known := range knownLoads { file := known . Name first := true for _ , l := range loads { if l . Name ( ) != file { continue } if first { fixLoad ( l , file , usedKinds [ file ] , knownKinds ) first = false } else { fixLoad ( l , file , nil , knownKinds ) } if l . IsEmpty ( ) { l . Delete ( ) } } if first { load := fixLoad ( nil , file , usedKinds [ file ] , knownKinds ) if load != nil { index := newLoadIndex ( f , known . After ) load . Insert ( f , index ) } } } }
3884	func fixLoad ( load * rule . Load , file string , kinds map [ string ] bool , knownKinds map [ string ] string ) * rule . Load { if load == nil { if len ( kinds ) == 0 { return nil } load = rule . NewLoad ( file ) } for k := range kinds { load . Add ( k ) } for _ , k := range load . Symbols ( ) { if knownKinds [ k ] != "" && ! kinds [ k ] { load . Remove ( k ) } } return load }
3885	func newLoadIndex ( f * rule . File , after [ ] string ) int { if len ( after ) == 0 { return 0 } index := 0 for _ , r := range f . Rules { for _ , a := range after { if r . Kind ( ) == a && r . Index ( ) >= index { index = r . Index ( ) + 1 } } } return index }
3886	func removeLegacyGoRepository ( f * rule . File ) { for _ , l := range f . Loads { if l . Name ( ) == "@io_bazel_rules_go//go:def.bzl" { l . Remove ( "go_repository" ) if l . IsEmpty ( ) { l . Delete ( ) } } } }
3887	func ( x Version ) Compare ( y Version ) int { n := len ( x ) if len ( y ) < n { n = len ( y ) } for i := 0 ; i < n ; i ++ { cmp := x [ i ] - y [ i ] if cmp != 0 { return cmp } } return len ( x ) - len ( y ) }
3888	func ParseVersion ( vs string ) ( Version , error ) { i := strings . IndexByte ( vs , '-' ) if i >= 0 { vs = vs [ : i ] } cstrs := strings . Split ( vs , "." ) v := make ( Version , len ( cstrs ) ) for i , cstr := range cstrs { cn , err := strconv . Atoi ( cstr ) if err != nil { return nil , fmt . Errorf ( "could not parse version string: %q is not an integer" , cstr ) } if cn < 0 { return nil , fmt . Errorf ( "could not parse version string: %q is negative" , cstr ) } v [ i ] = cn } return v , nil }
3889	func EmptyFile ( path , pkg string ) * File { return & File { File : & bzl . File { Path : path , Type : bzl . TypeBuild } , Path : path , Pkg : pkg , } }
3890	func LoadWorkspaceFile ( path , pkg string ) ( * File , error ) { data , err := ioutil . ReadFile ( path ) if err != nil { return nil , err } return LoadWorkspaceData ( path , pkg , data ) }
3891	func LoadMacroFile ( path , pkg , defName string ) ( * File , error ) { data , err := ioutil . ReadFile ( path ) if err != nil { return nil , err } return LoadMacroData ( path , pkg , defName , data ) }
3892	func EmptyMacroFile ( path , pkg , defName string ) ( * File , error ) { _ , err := os . Create ( path ) if err != nil { return nil , err } return LoadMacroData ( path , pkg , defName , nil ) }
3893	func LoadData ( path , pkg string , data [ ] byte ) ( * File , error ) { ast , err := bzl . ParseBuild ( path , data ) if err != nil { return nil , err } return ScanAST ( pkg , ast ) , nil }
3894	func LoadWorkspaceData ( path , pkg string , data [ ] byte ) ( * File , error ) { ast , err := bzl . ParseWorkspace ( path , data ) if err != nil { return nil , err } return ScanAST ( pkg , ast ) , nil }
3895	func LoadMacroData ( path , pkg , defName string , data [ ] byte ) ( * File , error ) { ast , err := bzl . ParseBzl ( path , data ) if err != nil { return nil , err } return ScanASTBody ( pkg , defName , ast ) , nil }
3896	func ScanAST ( pkg string , bzlFile * bzl . File ) * File { return ScanASTBody ( pkg , "" , bzlFile ) }
3897	func ScanASTBody ( pkg , defName string , bzlFile * bzl . File ) * File { f := & File { File : bzlFile , Pkg : pkg , Path : bzlFile . Path , } var defStmt * bzl . DefStmt f . Rules , f . Loads , defStmt = scanExprs ( defName , bzlFile . Stmt ) if defStmt != nil { f . Rules , _ , _ = scanExprs ( "" , defStmt . Body ) f . function = & function { stmt : defStmt , inserted : true , } if len ( defStmt . Body ) == 1 { if v , ok := defStmt . Body [ 0 ] . ( * bzl . BranchStmt ) ; ok && v . Token == "pass" { f . function . hasPass = true } } } else if defName != "" { f . function = & function { stmt : & bzl . DefStmt { Name : defName } , inserted : false , } } f . Directives = ParseDirectives ( bzlFile ) return f }
3898	func MatchBuildFileName ( dir string , names [ ] string , files [ ] os . FileInfo ) string { for _ , name := range names { for _ , fi := range files { if fi . Name ( ) == name && ! fi . IsDir ( ) { return filepath . Join ( dir , name ) } } } return "" }
3899	func ( f * File ) SyncMacroFile ( from * File ) { fromFunc := * from . function . stmt _ , _ , toFunc := scanExprs ( from . function . stmt . Name , f . File . Stmt ) if toFunc != nil { * toFunc = fromFunc } else { f . File . Stmt = append ( f . File . Stmt , & fromFunc ) } }
3900	func ( f * File ) MacroName ( ) string { if f . function != nil && f . function . stmt != nil { return f . function . stmt . Name } return "" }
3901	func ( f * File ) Sync ( ) { var loadInserts , loadDeletes , loadStmts [ ] * stmt var r , w int for r , w = 0 , 0 ; r < len ( f . Loads ) ; r ++ { s := f . Loads [ r ] s . sync ( ) if s . deleted { loadDeletes = append ( loadDeletes , & s . stmt ) continue } if s . inserted { loadInserts = append ( loadInserts , & s . stmt ) s . inserted = false } else { loadStmts = append ( loadStmts , & s . stmt ) } f . Loads [ w ] = s w ++ } f . Loads = f . Loads [ : w ] var ruleInserts , ruleDeletes , ruleStmts [ ] * stmt for r , w = 0 , 0 ; r < len ( f . Rules ) ; r ++ { s := f . Rules [ r ] s . sync ( ) if s . deleted { ruleDeletes = append ( ruleDeletes , & s . stmt ) continue } if s . inserted { ruleInserts = append ( ruleInserts , & s . stmt ) s . inserted = false } else { ruleStmts = append ( ruleStmts , & s . stmt ) } f . Rules [ w ] = s w ++ } f . Rules = f . Rules [ : w ] if f . function == nil { deletes := append ( ruleDeletes , loadDeletes ... ) inserts := append ( ruleInserts , loadInserts ... ) stmts := append ( ruleStmts , loadStmts ... ) updateStmt ( & f . File . Stmt , inserts , deletes , stmts ) } else { updateStmt ( & f . File . Stmt , loadInserts , loadDeletes , loadStmts ) if f . function . hasPass && len ( ruleInserts ) > 0 { f . function . stmt . Body = [ ] bzl . Expr { } f . function . hasPass = false } updateStmt ( & f . function . stmt . Body , ruleInserts , ruleDeletes , ruleStmts ) if len ( f . function . stmt . Body ) == 0 { f . function . stmt . Body = append ( f . function . stmt . Body , & bzl . BranchStmt { Token : "pass" } ) f . function . hasPass = true } if ! f . function . inserted { f . File . Stmt = append ( f . File . Stmt , f . function . stmt ) f . function . inserted = true } } }
3902	func ( f * File ) Format ( ) [ ] byte { f . Sync ( ) return bzl . Format ( f . File ) }
3903	func ( f * File ) Save ( path string ) error { f . Sync ( ) data := bzl . Format ( f . File ) return ioutil . WriteFile ( path , data , 0666 ) }
3904	func ( f * File ) HasDefaultVisibility ( ) bool { for _ , r := range f . Rules { if r . Kind ( ) == "package" && r . Attr ( "default_visibility" ) != nil { return true } } return false }
3905	func NewLoad ( name string ) * Load { return & Load { stmt : stmt { expr : & bzl . LoadStmt { Module : & bzl . StringExpr { Value : name } , ForceCompact : true , } , } , name : name , symbols : make ( map [ string ] identPair ) , } }
3906	func ( l * Load ) Symbols ( ) [ ] string { syms := make ( [ ] string , 0 , len ( l . symbols ) ) for sym := range l . symbols { syms = append ( syms , sym ) } sort . Strings ( syms ) return syms }
3907	func ( l * Load ) Has ( sym string ) bool { _ , ok := l . symbols [ sym ] return ok }
3908	func ( l * Load ) Add ( sym string ) { if _ , ok := l . symbols [ sym ] ; ! ok { i := & bzl . Ident { Name : sym } l . symbols [ sym ] = identPair { to : i , from : i } l . updated = true } }
3909	func ( l * Load ) Remove ( sym string ) { if _ , ok := l . symbols [ sym ] ; ok { delete ( l . symbols , sym ) l . updated = true } }
3910	func ( l * Load ) Insert ( f * File , index int ) { l . index = index l . inserted = true f . Loads = append ( f . Loads , l ) }
3911	func NewRule ( kind , name string ) * Rule { nameAttr := & bzl . AssignExpr { LHS : & bzl . Ident { Name : "name" } , RHS : & bzl . StringExpr { Value : name } , Op : "=" , } r := & Rule { stmt : stmt { expr : & bzl . CallExpr { X : & bzl . Ident { Name : kind } , List : [ ] bzl . Expr { nameAttr } , } , } , kind : kind , attrs : map [ string ] * bzl . AssignExpr { "name" : nameAttr } , private : map [ string ] interface { } { } , } return r }
3912	func ( r * Rule ) SetKind ( kind string ) { r . kind = kind r . updated = true }
3913	func ( r * Rule ) AttrKeys ( ) [ ] string { keys := make ( [ ] string , 0 , len ( r . attrs ) ) for k := range r . attrs { keys = append ( keys , k ) } sort . SliceStable ( keys , func ( i , j int ) bool { if cmp := bt . NamePriority [ keys [ i ] ] - bt . NamePriority [ keys [ j ] ] ; cmp != 0 { return cmp < 0 } return keys [ i ] < keys [ j ] } ) return keys }
3914	func ( r * Rule ) Attr ( key string ) bzl . Expr { attr , ok := r . attrs [ key ] if ! ok { return nil } return attr . RHS }
3915	func ( r * Rule ) AttrString ( key string ) string { attr , ok := r . attrs [ key ] if ! ok { return "" } str , ok := attr . RHS . ( * bzl . StringExpr ) if ! ok { return "" } return str . Value }
3916	func ( r * Rule ) AttrStrings ( key string ) [ ] string { attr , ok := r . attrs [ key ] if ! ok { return nil } list , ok := attr . RHS . ( * bzl . ListExpr ) if ! ok { return nil } strs := make ( [ ] string , 0 , len ( list . List ) ) for _ , e := range list . List { if str , ok := e . ( * bzl . StringExpr ) ; ok { strs = append ( strs , str . Value ) } } return strs }
3917	func ( r * Rule ) DelAttr ( key string ) { delete ( r . attrs , key ) r . updated = true }
3918	func ( r * Rule ) SetAttr ( key string , value interface { } ) { rhs := ExprFromValue ( value ) if attr , ok := r . attrs [ key ] ; ok { attr . RHS = rhs } else { r . attrs [ key ] = & bzl . AssignExpr { LHS : & bzl . Ident { Name : key } , RHS : rhs , Op : "=" , } } r . updated = true }
3919	func ( r * Rule ) PrivateAttrKeys ( ) [ ] string { keys := make ( [ ] string , 0 , len ( r . private ) ) for k := range r . private { keys = append ( keys , k ) } sort . Strings ( keys ) return keys }
3920	func ( r * Rule ) SetPrivateAttr ( key string , value interface { } ) { r . private [ key ] = value }
3921	func ( r * Rule ) Insert ( f * File ) { var stmt [ ] bzl . Expr if f . function == nil { stmt = f . File . Stmt } else { stmt = f . function . stmt . Body } r . index = len ( stmt ) r . inserted = true f . Rules = append ( f . Rules , r ) }
3922	func ( r * Rule ) IsEmpty ( info KindInfo ) bool { if info . NonEmptyAttrs == nil { return false } for k := range info . NonEmptyAttrs { if _ , ok := r . attrs [ k ] ; ok { return false } } return true }
3923	func CheckInternalVisibility ( rel , visibility string ) string { if i := strings . LastIndex ( rel , "/internal/" ) ; i >= 0 { visibility = fmt . Sprintf ( "//%s:__subpackages__" , rel [ : i ] ) } else if strings . HasPrefix ( rel , "internal/" ) { visibility = "//:__subpackages__" } return visibility }
3924	func New ( repo , pkg , name string ) Label { return Label { Repo : repo , Pkg : pkg , Name : name } }
3925	func ( l Label ) Rel ( repo , pkg string ) Label { if l . Relative || l . Repo != repo { return l } if l . Pkg == pkg { return Label { Name : l . Name , Relative : true } } return Label { Pkg : l . Pkg , Name : l . Name } }
3926	func ( l Label ) Equal ( other Label ) bool { return l . Repo == other . Repo && l . Pkg == other . Pkg && l . Name == other . Name && l . Relative == other . Relative }
3927	func ( l Label ) Contains ( other Label ) bool { if l . Relative { log . Panicf ( "l must not be relative: %s" , l ) } if other . Relative { log . Panicf ( "other must not be relative: %s" , other ) } result := l . Repo == other . Repo && pathtools . HasPrefix ( other . Pkg , l . Pkg ) return result }
3928	func generateFromPath ( w io . Writer , rootPath string ) error { return filepath . Walk ( rootPath , func ( path string , info os . FileInfo , err error ) error { if err != nil { return err } if ! strings . HasSuffix ( path , ".proto" ) { return nil } relPath , err := filepath . Rel ( rootPath , path ) if err != nil || strings . HasPrefix ( relPath , ".." ) { log . Panicf ( "file %q not in repository rootPath %q" , path , rootPath ) } relPath = filepath . ToSlash ( relPath ) if strings . HasPrefix ( relPath , "google/api/experimental/" ) { packagePath := "google.golang.org/genproto/googleapis/api" protoLabel , goLabel := protoLabels ( "google/api/x" , "api" ) fmt . Fprintf ( w , "%s,%s,%s,%s\n" , \n , relPath , protoLabel , packagePath ) goLabel } return nil packagePath , packageName , err := loadGoPackage ( path ) if err != nil { log . Print ( err ) return nil } protoLabel , goLabel := protoLabels ( relPath , packageName ) fmt . Fprintf ( w , "%s,%s,%s,%s\n" , \n , relPath , protoLabel , packagePath ) } ) }
3929	func shouldCall ( rel string , mode Mode , updateRels map [ string ] bool ) bool { return mode != UpdateDirsMode || updateRels [ rel ] }
3930	func shouldUpdate ( rel string , mode Mode , updateParent bool , updateRels map [ string ] bool ) bool { return mode == VisitAllUpdateSubdirsMode && updateParent || updateRels [ rel ] }
3931	func shouldVisit ( rel string , mode Mode , updateRels map [ string ] bool ) bool { if mode != UpdateDirsMode { return true } _ , ok := updateRels [ rel ] return ok }
3932	func SquashRules ( src , dst * Rule , filename string ) error { if dst . ShouldKeep ( ) { return nil } for key , srcAttr := range src . attrs { srcValue := srcAttr . RHS if dstAttr , ok := dst . attrs [ key ] ; ! ok { dst . SetAttr ( key , srcValue ) } else if ! ShouldKeep ( dstAttr ) { dstValue := dstAttr . RHS if squashedValue , err := squashExprs ( srcValue , dstValue ) ; err != nil { start , end := dstValue . Span ( ) return fmt . Errorf ( "%s:%d.%d-%d.%d: could not squash expression" , filename , start . Line , start . LineRune , end . Line , end . LineRune ) } else { dst . SetAttr ( key , squashedValue ) } } } dst . expr . Comment ( ) . Before = append ( dst . expr . Comment ( ) . Before , src . expr . Comment ( ) . Before ... ) dst . expr . Comment ( ) . Suffix = append ( dst . expr . Comment ( ) . Suffix , src . expr . Comment ( ) . Suffix ... ) dst . expr . Comment ( ) . After = append ( dst . expr . Comment ( ) . After , src . expr . Comment ( ) . After ... ) return nil }
3933	func runClient ( ) error { startTime := time . Now ( ) conn , err := net . Dial ( "unix" , * socketPath ) if err != nil { if err := startServer ( ) ; err != nil { return fmt . Errorf ( "error starting server: %v" , err ) } for retry := 0 ; retry < 3 ; retry ++ { conn , err = net . Dial ( "unix" , * socketPath ) if err == nil { break } time . Sleep ( 1 * time . Second ) } if err != nil { return fmt . Errorf ( "failed to connect to server: %v" , err ) } } defer conn . Close ( ) if _ , err := io . Copy ( os . Stderr , conn ) ; err != nil { log . Print ( err ) } elapsedTime := time . Since ( startTime ) log . Printf ( "ran gazelle in %.3f s" , elapsedTime . Seconds ( ) ) return nil }
3934	func UpdateRepo ( rc * RemoteCache , importPath string ) ( Repo , error ) { root , name , err := rc . Root ( importPath ) if err != nil { return Repo { } , err } remote , vcs , err := rc . Remote ( root ) if err != nil { return Repo { } , err } commit , tag , err := rc . Head ( remote , vcs ) if err != nil { return Repo { } , err } repo := Repo { Name : name , GoPrefix : root , Commit : commit , Tag : tag , Remote : remote , VCS : vcs , } return repo , nil }
3935	func NewRemoteCache ( knownRepos [ ] Repo ) ( r * RemoteCache , cleanup func ( ) error ) { r = & RemoteCache { RepoRootForImportPath : vcs . RepoRootForImportPath , HeadCmd : defaultHeadCmd , root : remoteCacheMap { cache : make ( map [ string ] * remoteCacheEntry ) } , remote : remoteCacheMap { cache : make ( map [ string ] * remoteCacheEntry ) } , head : remoteCacheMap { cache : make ( map [ string ] * remoteCacheEntry ) } , mod : remoteCacheMap { cache : make ( map [ string ] * remoteCacheEntry ) } , } r . ModInfo = func ( importPath string ) ( string , error ) { return defaultModInfo ( r , importPath ) } for _ , repo := range knownRepos { r . root . cache [ repo . GoPrefix ] = & remoteCacheEntry { value : rootValue { root : repo . GoPrefix , name : repo . Name , } , } if repo . Remote != "" { r . remote . cache [ repo . GoPrefix ] = & remoteCacheEntry { value : remoteValue { remote : repo . Remote , vcs : repo . VCS , } , } } r . mod . cache [ repo . GoPrefix ] = & remoteCacheEntry { value : modValue { path : repo . GoPrefix , name : repo . Name , known : true , } , } } return r , r . cleanup }
3936	func ( r * RemoteCache ) Remote ( root string ) ( remote , vcs string , err error ) { v , err := r . remote . ensure ( root , func ( ) ( interface { } , error ) { repo , err := r . RepoRootForImportPath ( root , false ) if err != nil { return nil , err } return remoteValue { remote : repo . Repo , vcs : repo . VCS . Cmd } , nil } ) if err != nil { return "" , "" , err } value := v . ( remoteValue ) return value . remote , value . vcs , nil }
3937	func ( m * remoteCacheMap ) get ( key string ) ( value interface { } , ok bool , err error ) { m . mu . Lock ( ) e , ok := m . cache [ key ] m . mu . Unlock ( ) if ! ok { return nil , ok , nil } if e . ready != nil { <- e . ready } return e . value , ok , e . err }
3938	func ( m * remoteCacheMap ) ensure ( key string , load func ( ) ( interface { } , error ) ) ( interface { } , error ) { m . mu . Lock ( ) e , ok := m . cache [ key ] if ! ok { e = & remoteCacheEntry { ready : make ( chan struct { } ) } m . cache [ key ] = e m . mu . Unlock ( ) e . value , e . err = load ( ) close ( e . ready ) } else { m . mu . Unlock ( ) if e . ready != nil { <- e . ready } } return e . value , e . err }
3939	func RelBaseName ( rel , prefix , root string ) string { base := path . Base ( rel ) if base == "." || base == "/" { base = path . Base ( prefix ) } if base == "." || base == "/" { base = filepath . Base ( root ) } if base == "." || base == "/" { base = "root" } return base }
3940	func ( c * Config ) Clone ( ) * Config { cc := * c cc . Exts = make ( map [ string ] interface { } ) for k , v := range c . Exts { cc . Exts [ k ] = v } cc . KindMap = make ( map [ string ] MappedKind ) for k , v := range c . KindMap { cc . KindMap [ k ] = v } return & cc }
3941	func ( c * Config ) IsValidBuildFileName ( name string ) bool { for _ , n := range c . ValidBuildFileNames { if name == n { return true } } return false }
3942	func ( l tagLine ) check ( c * config . Config , os , arch string ) bool { if len ( l ) == 0 { return false } for _ , g := range l { if g . check ( c , os , arch ) { return true } } return false }
3943	func fileNameInfo ( path_ string ) fileInfo { name := filepath . Base ( path_ ) var ext ext switch path . Ext ( name ) { case ".go" : ext = goExt case ".c" , ".cc" , ".cpp" , ".cxx" , ".m" , ".mm" : ext = cExt case ".h" , ".hh" , ".hpp" , ".hxx" : ext = hExt case ".s" : ext = sExt case ".S" : ext = csExt case ".proto" : ext = protoExt default : ext = unknownExt } if strings . HasPrefix ( name , "." ) || strings . HasPrefix ( name , "_" ) { ext = unknownExt } var isTest bool var goos , goarch string l := strings . Split ( name [ : len ( name ) - len ( path . Ext ( name ) ) ] , "_" ) if len ( l ) >= 2 && l [ len ( l ) - 1 ] == "test" { isTest = ext == goExt l = l [ : len ( l ) - 1 ] } switch { case len ( l ) >= 3 && rule . KnownOSSet [ l [ len ( l ) - 2 ] ] && rule . KnownArchSet [ l [ len ( l ) - 1 ] ] : goos = l [ len ( l ) - 2 ] goarch = l [ len ( l ) - 1 ] case len ( l ) >= 2 && rule . KnownOSSet [ l [ len ( l ) - 1 ] ] : goos = l [ len ( l ) - 1 ] case len ( l ) >= 2 && rule . KnownArchSet [ l [ len ( l ) - 1 ] ] : goarch = l [ len ( l ) - 1 ] } return fileInfo { path : path_ , name : name , ext : ext , isTest : isTest , goos : goos , goarch : goarch , } }
3944	func otherFileInfo ( path string ) fileInfo { info := fileNameInfo ( path ) if info . ext == unknownExt { return info } tags , err := readTags ( info . path ) if err != nil { log . Printf ( "%s: error reading file: %v" , info . path , err ) return info } info . tags = tags return info }
3945	func protoFileInfo ( path_ string , protoInfo proto . FileInfo ) fileInfo { info := fileNameInfo ( path_ ) for _ , opt := range protoInfo . Options { if opt . Key != "go_package" { continue } if strings . LastIndexByte ( opt . Value , '/' ) == - 1 { info . packageName = opt . Value } else { if i := strings . LastIndexByte ( opt . Value , ';' ) ; i != - 1 { info . importPath = opt . Value [ : i ] info . packageName = opt . Value [ i + 1 : ] } else { info . importPath = opt . Value info . packageName = path . Base ( opt . Value ) } } } if info . packageName == "" && protoInfo . PackageName != "" { info . packageName = strings . Replace ( protoInfo . PackageName , "." , "_" , - 1 ) } info . imports = protoInfo . Imports info . hasServices = protoInfo . HasServices return info }
3946	func ( ix * RuleIndex ) AddRule ( c * config . Config , r * rule . Rule , f * rule . File ) { var imps [ ] ImportSpec if rslv := ix . mrslv ( r , f . Pkg ) ; rslv != nil { imps = rslv . Imports ( c , r , f ) } if imps == nil { return } record := & ruleRecord { rule : r , label : label . New ( c . RepoName , f . Pkg , r . Name ( ) ) , file : f , importedAs : imps , } if _ , ok := ix . labelMap [ record . label ] ; ok { log . Printf ( "multiple rules found with label %s" , record . label ) return } ix . rules = append ( ix . rules , record ) ix . labelMap [ record . label ] = record }
3947	func ( ix * RuleIndex ) Finish ( ) { for _ , r := range ix . rules { ix . collectEmbeds ( r ) } ix . buildImportIndex ( ) }
3948	func ( ix * RuleIndex ) buildImportIndex ( ) { ix . importMap = make ( map [ ImportSpec ] [ ] * ruleRecord ) for _ , r := range ix . rules { if r . embedded { continue } indexed := make ( map [ ImportSpec ] bool ) for _ , imp := range r . importedAs { if indexed [ imp ] { continue } indexed [ imp ] = true ix . importMap [ imp ] = append ( ix . importMap [ imp ] , r ) } } }
3949	func ( r FindResult ) IsSelfImport ( from label . Label ) bool { if from . Equal ( r . Label ) { return true } for _ , e := range r . Embeds { if from . Equal ( e ) { return true } } return false }
3950	func applyKindMappings ( mappedKinds [ ] config . MappedKind , loads [ ] rule . LoadInfo ) [ ] rule . LoadInfo { if len ( mappedKinds ) == 0 { return loads } mappedLoads := make ( [ ] rule . LoadInfo , len ( loads ) ) copy ( mappedLoads , loads ) for _ , mappedKind := range mappedKinds { mappedLoads = appendOrMergeKindMapping ( mappedLoads , mappedKind ) } return mappedLoads }
3951	func appendOrMergeKindMapping ( mappedLoads [ ] rule . LoadInfo , mappedKind config . MappedKind ) [ ] rule . LoadInfo { for _ , load := range mappedLoads { if load . Name == mappedKind . KindLoad { load . Symbols = append ( load . Symbols , mappedKind . KindName ) return mappedLoads } } return append ( mappedLoads , rule . LoadInfo { Name : mappedKind . KindLoad , Symbols : [ ] string { mappedKind . KindName } , } ) }
3952	func RuleName ( names ... string ) string { base := "root" for _ , name := range names { notIdent := func ( c rune ) bool { return ! ( 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || '0' <= c && c <= '9' || c == '_' ) } if i := strings . LastIndexFunc ( name , notIdent ) ; i >= 0 { name = name [ i + 1 : ] } if name != "" { base = name break } } return base + "_proto" }
3953	func buildPackages ( pc * ProtoConfig , dir , rel string , protoFiles , genFiles [ ] string ) [ ] * Package { packageMap := make ( map [ string ] * Package ) for _ , name := range protoFiles { info := protoFileInfo ( dir , name ) key := info . PackageName if pc . groupOption != "" { for _ , opt := range info . Options { if opt . Key == pc . groupOption { key = opt . Value break } } } if packageMap [ key ] == nil { packageMap [ key ] = newPackage ( info . PackageName ) } packageMap [ key ] . addFile ( info ) } switch pc . Mode { case DefaultMode : pkg , err := selectPackage ( dir , rel , packageMap ) if err != nil { log . Print ( err ) } if pkg == nil { return nil } for _ , name := range genFiles { pkg . addGenFile ( dir , name ) } return [ ] * Package { pkg } case PackageMode : pkgs := make ( [ ] * Package , 0 , len ( packageMap ) ) for _ , pkg := range packageMap { pkgs = append ( pkgs , pkg ) } return pkgs default : return nil } }
3954	func selectPackage ( dir , rel string , packageMap map [ string ] * Package ) ( * Package , error ) { if len ( packageMap ) == 0 { return nil , nil } if len ( packageMap ) == 1 { for _ , pkg := range packageMap { return pkg , nil } } defaultPackageName := strings . Replace ( rel , "/" , "_" , - 1 ) for _ , pkg := range packageMap { if pkgName := goPackageName ( pkg ) ; pkgName != "" && pkgName == defaultPackageName { return pkg , nil } } return nil , fmt . Errorf ( "%s: directory contains multiple proto packages. Gazelle can only generate a proto_library for one package." , dir ) }
3955	func generateProto ( pc * ProtoConfig , rel string , pkg * Package , shouldSetVisibility bool ) * rule . Rule { var name string if pc . Mode == DefaultMode { name = RuleName ( goPackageName ( pkg ) , pc . GoPrefix , rel ) } else { name = RuleName ( pkg . Options [ pc . groupOption ] , pkg . Name , rel ) } r := rule . NewRule ( "proto_library" , name ) srcs := make ( [ ] string , 0 , len ( pkg . Files ) ) for f := range pkg . Files { srcs = append ( srcs , f ) } sort . Strings ( srcs ) if len ( srcs ) > 0 { r . SetAttr ( "srcs" , srcs ) } r . SetPrivateAttr ( PackageKey , * pkg ) imports := make ( [ ] string , 0 , len ( pkg . Imports ) ) for i := range pkg . Imports { imports = append ( imports , i ) } sort . Strings ( imports ) r . SetPrivateAttr ( config . GazelleImportsKey , imports ) for k , v := range pkg . Options { r . SetPrivateAttr ( k , v ) } if shouldSetVisibility { vis := rule . CheckInternalVisibility ( rel , "//visibility:public" ) r . SetAttr ( "visibility" , [ ] string { vis } ) } if pc . stripImportPrefix != "" { r . SetAttr ( "strip_import_prefix" , pc . stripImportPrefix ) } if pc . importPrefix != "" { r . SetAttr ( "import_prefix" , pc . importPrefix ) } return r }
3956	func generateEmpty ( f * rule . File , regularFiles , genFiles [ ] string ) [ ] * rule . Rule { if f == nil { return nil } knownFiles := make ( map [ string ] bool ) for _ , f := range regularFiles { knownFiles [ f ] = true } for _ , f := range genFiles { knownFiles [ f ] = true } var empty [ ] * rule . Rule outer : for _ , r := range f . Rules { if r . Kind ( ) != "proto_library" { continue } srcs := r . AttrStrings ( "srcs" ) if len ( srcs ) == 0 && r . Attr ( "srcs" ) != nil { continue } for _ , src := range r . AttrStrings ( "srcs" ) { if knownFiles [ src ] { continue outer } } empty = append ( empty , rule . NewRule ( "proto_library" , r . Name ( ) ) ) } return empty }
3957	func ImportRepoRules ( filename string , repoCache * RemoteCache ) ( [ ] * rule . Rule , error ) { format := getLockFileFormat ( filename ) if format == unknownFormat { return nil , fmt . Errorf ( `%s: unrecognized lock file format. Expected "Gopkg.lock", "go.mod", or "Godeps.json"` , filename ) } parser := lockFileParsers [ format ] repos , err := parser ( filename , repoCache ) if err != nil { return nil , fmt . Errorf ( "error parsing %q: %v" , filename , err ) } sort . Stable ( byName ( repos ) ) rules := make ( [ ] * rule . Rule , 0 , len ( repos ) ) for _ , repo := range repos { rules = append ( rules , GenerateRule ( repo ) ) } return rules , nil }
3958	func MergeRules ( genRules [ ] * rule . Rule , existingRules map [ * rule . File ] [ ] string , destFile * rule . File , kinds map [ string ] rule . KindInfo ) [ ] * rule . File { sort . Stable ( byRuleName ( genRules ) ) repoMap := make ( map [ string ] * rule . File ) for file , repoNames := range existingRules { if file . Path == destFile . Path && file . MacroName ( ) != "" && file . MacroName ( ) == destFile . MacroName ( ) { file = destFile } for _ , name := range repoNames { repoMap [ name ] = file } } rulesByFile := make ( map [ * rule . File ] [ ] * rule . Rule ) for _ , rule := range genRules { dest := destFile if file , ok := repoMap [ rule . Name ( ) ] ; ok { dest = file } rulesByFile [ dest ] = append ( rulesByFile [ dest ] , rule ) } updatedFiles := make ( map [ string ] * rule . File ) for f , rules := range rulesByFile { merger . MergeFile ( f , nil , rules , merger . PreResolve , kinds ) f . Sync ( ) if uf , ok := updatedFiles [ f . Path ] ; ok { uf . SyncMacroFile ( f ) } else { updatedFiles [ f . Path ] = f } } files := make ( [ ] * rule . File , 0 , len ( updatedFiles ) ) for _ , f := range updatedFiles { files = append ( files , f ) } return files }
3959	func GenerateRule ( repo Repo ) * rule . Rule { r := rule . NewRule ( "go_repository" , repo . Name ) if repo . Commit != "" { r . SetAttr ( "commit" , repo . Commit ) } if repo . Tag != "" { r . SetAttr ( "tag" , repo . Tag ) } r . SetAttr ( "importpath" , repo . GoPrefix ) if repo . Remote != "" { r . SetAttr ( "remote" , repo . Remote ) } if repo . VCS != "" { r . SetAttr ( "vcs" , repo . VCS ) } if repo . Version != "" { r . SetAttr ( "version" , repo . Version ) } if repo . Sum != "" { r . SetAttr ( "sum" , repo . Sum ) } if repo . Replace != "" { r . SetAttr ( "replace" , repo . Replace ) } return r }
3960	func FindExternalRepo ( repoRoot , name string ) ( string , error ) { externalPath := strings . Join ( [ ] string { repoRoot , "bazel-out" , ".." , ".." , ".." , "external" , name } , string ( os . PathSeparator ) ) cleanPath , err := filepath . EvalSymlinks ( externalPath ) if err != nil { return "" , err } st , err := os . Stat ( cleanPath ) if err != nil { return "" , err } if ! st . IsDir ( ) { return "" , fmt . Errorf ( "%s: not a directory" , externalPath ) } return cleanPath , nil }
3961	func ListRepositories ( workspace * rule . File ) ( repos [ ] Repo , repoNamesByFile map [ * rule . File ] [ ] string , err error ) { repoNamesByFile = make ( map [ * rule . File ] [ ] string ) repos , repoNamesByFile [ workspace ] = getRepos ( workspace . Rules ) for _ , d := range workspace . Directives { switch d . Key { case "repository_macro" : f , defName , err := parseRepositoryMacroDirective ( d . Value ) if err != nil { return nil , nil , err } f = filepath . Join ( filepath . Dir ( workspace . Path ) , filepath . Clean ( f ) ) macroFile , err := rule . LoadMacroFile ( f , "" , defName ) if err != nil { return nil , nil , err } currRepos , names := getRepos ( macroFile . Rules ) repoNamesByFile [ macroFile ] = names repos = append ( repos , currRepos ... ) } } return repos , repoNamesByFile , nil }
3962	func migrateLibraryEmbed ( c * config . Config , f * rule . File ) { for _ , r := range f . Rules { if ! isGoRule ( r . Kind ( ) ) { continue } libExpr := r . Attr ( "library" ) if libExpr == nil || rule . ShouldKeep ( libExpr ) || r . Attr ( "embed" ) != nil { continue } r . DelAttr ( "library" ) r . SetAttr ( "embed" , & bzl . ListExpr { List : [ ] bzl . Expr { libExpr } } ) } }
3963	func migrateGrpcCompilers ( c * config . Config , f * rule . File ) { for _ , r := range f . Rules { if r . Kind ( ) != "go_grpc_library" || r . ShouldKeep ( ) || r . Attr ( "compilers" ) != nil { continue } r . SetKind ( "go_proto_library" ) r . SetAttr ( "compilers" , [ ] string { grpcCompilerLabel } ) } }
3964	func squashCgoLibrary ( c * config . Config , f * rule . File ) { var cgoLibrary , goLibrary * rule . Rule for _ , r := range f . Rules { if r . Kind ( ) == "cgo_library" && r . Name ( ) == "cgo_default_library" && ! r . ShouldKeep ( ) { if cgoLibrary != nil { log . Printf ( "%s: when fixing existing file, multiple cgo_library rules with default name found" , f . Path ) continue } cgoLibrary = r continue } if r . Kind ( ) == "go_library" && r . Name ( ) == defaultLibName { if goLibrary != nil { log . Printf ( "%s: when fixing existing file, multiple go_library rules with default name referencing cgo_library found" , f . Path ) } goLibrary = r continue } } if cgoLibrary == nil { return } if ! c . ShouldFix { log . Printf ( "%s: cgo_library is deprecated. Run 'gazelle fix' to squash with go_library." , f . Path ) return } if goLibrary == nil { cgoLibrary . SetKind ( "go_library" ) cgoLibrary . SetName ( defaultLibName ) cgoLibrary . SetAttr ( "cgo" , true ) return } if err := rule . SquashRules ( cgoLibrary , goLibrary , f . Path ) ; err != nil { log . Print ( err ) return } goLibrary . DelAttr ( "embed" ) goLibrary . SetAttr ( "cgo" , true ) cgoLibrary . Delete ( ) }
3965	func removeLegacyProto ( c * config . Config , f * rule . File ) { if pcMode := getProtoMode ( c ) ; pcMode != proto . DefaultMode { return } var protoLoads [ ] * rule . Load for _ , l := range f . Loads { if l . Name ( ) == "@io_bazel_rules_go//proto:go_proto_library.bzl" { protoLoads = append ( protoLoads , l ) } } var protoFilegroups , protoRules [ ] * rule . Rule for _ , r := range f . Rules { if r . Kind ( ) == "filegroup" && r . Name ( ) == legacyProtoFilegroupName { protoFilegroups = append ( protoFilegroups , r ) } if r . Kind ( ) == "go_proto_library" { protoRules = append ( protoRules , r ) } } if len ( protoLoads ) + len ( protoFilegroups ) == 0 { return } if ! c . ShouldFix { log . Printf ( "%s: go_proto_library.bzl is deprecated. Run 'gazelle fix' to replace old rules." , f . Path ) return } for _ , l := range protoLoads { l . Delete ( ) } for _ , r := range protoFilegroups { r . Delete ( ) } if len ( protoLoads ) > 0 { for _ , r := range protoRules { r . Delete ( ) } } }
3966	func removeLegacyGazelle ( c * config . Config , f * rule . File ) { for _ , l := range f . Loads { if l . Name ( ) == "@io_bazel_rules_go//go:def.bzl" && l . Has ( "gazelle" ) { l . Remove ( "gazelle" ) if l . IsEmpty ( ) { l . Delete ( ) } } } }
3967	func selectPackage ( c * config . Config , dir string , packageMap map [ string ] * goPackage ) ( * goPackage , error ) { buildablePackages := make ( map [ string ] * goPackage ) for name , pkg := range packageMap { if pkg . isBuildable ( c ) { buildablePackages [ name ] = pkg } } if len ( buildablePackages ) == 0 { return nil , & build . NoGoError { Dir : dir } } if len ( buildablePackages ) == 1 { for _ , pkg := range buildablePackages { return pkg , nil } } if pkg , ok := buildablePackages [ defaultPackageName ( c , dir ) ] ; ok { return pkg , nil } err := & build . MultiplePackageError { Dir : dir } for name , pkg := range buildablePackages { err . Packages = append ( err . Packages , name ) err . Files = append ( err . Files , pkg . firstGoFile ( ) ) } return nil , err }
3968	func ( mr * metaResolver ) AddBuiltin ( kindName string , resolver resolve . Resolver ) { mr . builtins [ kindName ] = resolver }
3969	func ( mr * metaResolver ) MappedKind ( pkgRel string , kind config . MappedKind ) { mr . mappedKinds [ pkgRel ] = append ( mr . mappedKinds [ pkgRel ] , kind ) }
3970	func ( mr metaResolver ) Resolver ( r * rule . Rule , pkgRel string ) resolve . Resolver { for _ , mappedKind := range mr . mappedKinds [ pkgRel ] { if mappedKind . KindName == r . Kind ( ) { return mr . builtins [ mappedKind . FromKind ] } } return mr . builtins [ r . Kind ( ) ] }
3971	func sortExprLabels ( e bzl . Expr , _ [ ] bzl . Expr ) { list , ok := e . ( * bzl . ListExpr ) if ! ok || len ( list . List ) == 0 { return } keys := make ( [ ] stringSortKey , len ( list . List ) ) for i , elem := range list . List { s , ok := elem . ( * bzl . StringExpr ) if ! ok { return } keys [ i ] = makeSortKey ( i , s ) } before := keys [ 0 ] . x . Comment ( ) . Before keys [ 0 ] . x . Comment ( ) . Before = nil sort . Sort ( byStringExpr ( keys ) ) keys [ 0 ] . x . Comment ( ) . Before = append ( before , keys [ 0 ] . x . Comment ( ) . Before ... ) for i , k := range keys { list . List [ i ] = k . x } }
3972	func checkRulesGoVersion ( repoRoot string ) { const message = `Gazelle may not be compatible with this version of rules_go.Update io_bazel_rules_go to a newer version in your WORKSPACE file.` rulesGoPath , err := repo . FindExternalRepo ( repoRoot , config . RulesGoRepoName ) if err != nil { return } defBzlPath := filepath . Join ( rulesGoPath , "go" , "def.bzl" ) defBzlContent , err := ioutil . ReadFile ( defBzlPath ) if err != nil { return } versionRe := regexp . MustCompile ( `(?m)^RULES_GO_VERSION = ['"]([0-9.]*)['"]` ) match := versionRe . FindSubmatch ( defBzlContent ) if match == nil { log . Printf ( "RULES_GO_VERSION not found in @%s//go:def.bzl.\n%s" , \n , config . RulesGoRepoName ) message } return vstr := string ( match [ 1 ] ) v , err := version . ParseVersion ( vstr ) if err != nil { log . Printf ( "RULES_GO_VERSION %q could not be parsed in @%s//go:def.bzl.\n%s" , \n , vstr , config . RulesGoRepoName ) } }
3973	func ( gc * goConfig ) preprocessTags ( ) { if gc . genericTags == nil { gc . genericTags = make ( map [ string ] bool ) } gc . genericTags [ "gc" ] = true }
3974	func ( gc * goConfig ) setBuildTags ( tags string ) error { if tags == "" { return nil } for _ , t := range strings . Split ( tags , "," ) { if strings . HasPrefix ( t , "!" ) { return fmt . Errorf ( "build tags can't be negated: %s" , t ) } gc . genericTags [ t ] = true } return nil }
3975	func splitValue ( value string ) [ ] string { parts := strings . Split ( value , "," ) values := make ( [ ] string , 0 , len ( parts ) ) for _ , part := range parts { values = append ( values , strings . TrimSpace ( part ) ) } return values }
3976	func copyGoModToTemp ( filename string ) ( tempDir string , err error ) { goModOrig , err := os . Open ( filename ) if err != nil { return "" , err } defer goModOrig . Close ( ) tempDir , err = ioutil . TempDir ( "" , "gazelle-temp-gomod" ) if err != nil { return "" , err } goModCopy , err := os . Create ( filepath . Join ( tempDir , "go.mod" ) ) if err != nil { os . Remove ( tempDir ) return "" , err } defer func ( ) { if cerr := goModCopy . Close ( ) ; err == nil && cerr != nil { err = cerr } } ( ) _ , err = io . Copy ( goModCopy , goModOrig ) if err != nil { os . RemoveAll ( tempDir ) return "" , err } return tempDir , err }
3977	func findGoTool ( ) string { path := "go" if goroot , ok := os . LookupEnv ( "GOROOT" ) ; ok { path = filepath . Join ( goroot , "bin" , "go" ) } if runtime . GOOS == "windows" { path += ".exe" } return path }
3978	func ( pkg * goPackage ) isBuildable ( c * config . Config ) bool { return pkg . firstGoFile ( ) != "" || ! pkg . proto . sources . isEmpty ( ) }
3979	func startServer ( ) error { exe , err := os . Executable ( ) if err != nil { return err } args := [ ] string { "-server" } args = append ( args , os . Args [ 1 : ] ... ) cmd := exec . Command ( exe , args ... ) log . Printf ( "starting server: %s" , strings . Join ( cmd . Args , " " ) ) if err := cmd . Start ( ) ; err != nil { return err } if err := cmd . Process . Release ( ) ; err != nil { return err } return nil }
3980	func watchDir ( root string , record func ( string ) ) ( cancel func ( ) , err error ) { w , err := fsnotify . NewWatcher ( ) if err != nil { return nil , err } dirs , errs := listDirs ( root ) for _ , err := range errs { log . Print ( err ) } gitDir := filepath . Join ( root , ".git" ) for _ , dir := range dirs { if dir == gitDir { continue } if err := w . Add ( dir ) ; err != nil { log . Print ( err ) } } done := make ( chan struct { } ) go func ( ) { for { select { case ev := <- w . Events : if shouldIgnore ( ev . Name ) { continue } if ev . Op == fsnotify . Create { if st , err := os . Lstat ( ev . Name ) ; err != nil { log . Print ( err ) } else if st . IsDir ( ) { dirs , errs := listDirs ( ev . Name ) for _ , err := range errs { log . Print ( err ) } for _ , dir := range dirs { if err := w . Add ( dir ) ; err != nil { log . Print ( err ) } recordWrite ( dir ) } } } else { recordWrite ( filepath . Dir ( ev . Name ) ) } case err := <- w . Errors : log . Print ( err ) case <- done : if err := w . Close ( ) ; err != nil { log . Print ( err ) } return } } } ( ) return func ( ) { close ( done ) } , nil }
3981	func listDirs ( dir string ) ( [ ] string , [ ] error ) { var dirs [ ] string var errs [ ] error err := filepath . Walk ( dir , func ( path string , info os . FileInfo , err error ) error { if err != nil { errs = append ( errs , err ) return nil } if info . IsDir ( ) { dirs = append ( dirs , path ) } return nil } ) if err != nil { errs = append ( errs , err ) } return dirs , errs }
3982	func shouldIgnore ( p string ) bool { p = strings . TrimPrefix ( filepath . ToSlash ( p ) , "./" ) base := path . Base ( p ) return strings . HasPrefix ( p , "tools/" ) || base == ".git" || base == "BUILD" || base == "BUILD.bazel" }
3983	func recordWrite ( path string ) { dirSetMutex . Lock ( ) defer dirSetMutex . Unlock ( ) dirSet [ path ] = true }
3984	func getAndClearWrittenDirs ( ) [ ] string { dirSetMutex . Lock ( ) defer dirSetMutex . Unlock ( ) dirs := make ( [ ] string , 0 , len ( dirSet ) ) for d := range dirSet { dirs = append ( dirs , d ) } dirSet = make ( map [ string ] bool ) return dirs }
3985	func CombineHandlers ( handlers ... http . HandlerFunc ) http . HandlerFunc { return func ( w http . ResponseWriter , req * http . Request ) { for _ , handler := range handlers { handler ( w , req ) } } }
3986	func VerifyContentType ( contentType string ) http . HandlerFunc { return func ( w http . ResponseWriter , req * http . Request ) { Expect ( req . Header . Get ( "Content-Type" ) ) . Should ( Equal ( contentType ) ) } }
3987	func VerifyMimeType ( mimeType string ) http . HandlerFunc { return func ( w http . ResponseWriter , req * http . Request ) { Expect ( strings . Split ( req . Header . Get ( "Content-Type" ) , ";" ) [ 0 ] ) . Should ( Equal ( mimeType ) ) } }
3988	func VerifyBasicAuth ( username string , password string ) http . HandlerFunc { return func ( w http . ResponseWriter , req * http . Request ) { auth := req . Header . Get ( "Authorization" ) Expect ( auth ) . ShouldNot ( Equal ( "" ) , "Authorization header must be specified" ) decoded , err := base64 . StdEncoding . DecodeString ( auth [ 6 : ] ) Expect ( err ) . ShouldNot ( HaveOccurred ( ) ) Expect ( string ( decoded ) ) . Should ( Equal ( fmt . Sprintf ( "%s:%s" , username , password ) ) , "Authorization mismatch" ) } }
3989	func VerifyJSONRepresenting ( object interface { } ) http . HandlerFunc { data , err := json . Marshal ( object ) Expect ( err ) . ShouldNot ( HaveOccurred ( ) ) return CombineHandlers ( VerifyContentType ( "application/json" ) , VerifyJSON ( string ( data ) ) , ) }
3990	func VerifyFormKV ( key string , values ... string ) http . HandlerFunc { return VerifyForm ( url . Values { key : values } ) }
3991	func RespondWithProto ( statusCode int , message proto . Message , optionalHeader ... http . Header ) http . HandlerFunc { return func ( w http . ResponseWriter , req * http . Request ) { data , err := proto . Marshal ( message ) Expect ( err ) . ShouldNot ( HaveOccurred ( ) ) var headers http . Header if len ( optionalHeader ) == 1 { headers = optionalHeader [ 0 ] } else { headers = make ( http . Header ) } if _ , found := headers [ "Content-Type" ] ; ! found { headers [ "Content-Type" ] = [ ] string { "application/x-protobuf" } } copyHeader ( headers , w . Header ( ) ) w . WriteHeader ( statusCode ) w . Write ( data ) } }
3992	func RegisterFailHandlerWithT ( t types . TWithHelper , handler types . GomegaFailHandler ) { if handler == nil { globalFailWrapper = nil return } globalFailWrapper = & types . GomegaFailWrapper { Fail : handler , TWithHelper : t , } }
3993	func EventuallyWithOffset ( offset int , actual interface { } , intervals ... interface { } ) AsyncAssertion { if globalFailWrapper == nil { panic ( nilFailHandlerPanic ) } timeoutInterval := defaultEventuallyTimeout pollingInterval := defaultEventuallyPollingInterval if len ( intervals ) > 0 { timeoutInterval = toDuration ( intervals [ 0 ] ) } if len ( intervals ) > 1 { pollingInterval = toDuration ( intervals [ 1 ] ) } return asyncassertion . New ( asyncassertion . AsyncAssertionTypeEventually , actual , globalFailWrapper , timeoutInterval , pollingInterval , offset ) }
3994	func ConsistentlyWithOffset ( offset int , actual interface { } , intervals ... interface { } ) AsyncAssertion { if globalFailWrapper == nil { panic ( nilFailHandlerPanic ) } timeoutInterval := defaultConsistentlyDuration pollingInterval := defaultConsistentlyPollingInterval if len ( intervals ) > 0 { timeoutInterval = toDuration ( intervals [ 0 ] ) } if len ( intervals ) > 1 { pollingInterval = toDuration ( intervals [ 1 ] ) } return asyncassertion . New ( asyncassertion . AsyncAssertionTypeConsistently , actual , globalFailWrapper , timeoutInterval , pollingInterval , offset ) }
3995	func ( g * WithT ) Expect ( actual interface { } , extra ... interface { } ) Assertion { return assertion . New ( actual , testingtsupport . BuildTestingTGomegaFailWrapper ( g . t ) , 0 , extra ... ) }
3996	func ( g * WithT ) Eventually ( actual interface { } , intervals ... interface { } ) AsyncAssertion { timeoutInterval := defaultEventuallyTimeout pollingInterval := defaultEventuallyPollingInterval if len ( intervals ) > 0 { timeoutInterval = toDuration ( intervals [ 0 ] ) } if len ( intervals ) > 1 { pollingInterval = toDuration ( intervals [ 1 ] ) } return asyncassertion . New ( asyncassertion . AsyncAssertionTypeEventually , actual , testingtsupport . BuildTestingTGomegaFailWrapper ( g . t ) , timeoutInterval , pollingInterval , 0 ) }
3997	func ( g * WithT ) Consistently ( actual interface { } , intervals ... interface { } ) AsyncAssertion { timeoutInterval := defaultConsistentlyDuration pollingInterval := defaultConsistentlyPollingInterval if len ( intervals ) > 0 { timeoutInterval = toDuration ( intervals [ 0 ] ) } if len ( intervals ) > 1 { pollingInterval = toDuration ( intervals [ 1 ] ) } return asyncassertion . New ( asyncassertion . AsyncAssertionTypeConsistently , actual , testingtsupport . BuildTestingTGomegaFailWrapper ( g . t ) , timeoutInterval , pollingInterval , 0 ) }
3998	func TimeoutCloser ( c io . Closer , timeout time . Duration ) io . Closer { return timeoutReaderWriterCloser { c : c , d : timeout } }
3999	func TimeoutReader ( r io . Reader , timeout time . Duration ) io . Reader { return timeoutReaderWriterCloser { r : r , d : timeout } }
4000	func TimeoutWriter ( w io . Writer , timeout time . Duration ) io . Writer { return timeoutReaderWriterCloser { w : w , d : timeout } }
4001	func Nest ( path string , err error ) error { if ag , ok := err . ( AggregateError ) ; ok { var errs AggregateError for _ , e := range ag { errs = append ( errs , Nest ( path , e ) ) } return errs } if ne , ok := err . ( * NestedError ) ; ok { return & NestedError { Path : path + ne . Path , Err : ne . Err , } } return & NestedError { Path : path , Err : err , } }
4002	func SetMockService ( m * MockService ) { m . Cache = & cache . MockAppCacheService { } m . Plan = & app . MockPlanService { } m . Platform = & app . MockPlatformService { } m . PlatformImage = & image . MockPlatformImageService { } m . Team = & auth . MockTeamService { } m . UserQuota = & quota . MockQuotaService { } m . AppQuota = & quota . MockQuotaService { } m . Cluster = & provision . MockClusterService { } m . ServiceBroker = & service . MockServiceBrokerService { } m . ServiceBrokerCatalogCache = & service . MockServiceBrokerCatalogCacheService { } servicemanager . AppCache = m . Cache servicemanager . Plan = m . Plan servicemanager . Platform = m . Platform servicemanager . PlatformImage = m . PlatformImage servicemanager . Team = m . Team servicemanager . UserQuota = m . UserQuota servicemanager . AppQuota = m . AppQuota servicemanager . Cluster = m . Cluster servicemanager . ServiceBroker = m . ServiceBroker servicemanager . ServiceBrokerCatalogCache = m . ServiceBrokerCatalogCache }
4003	func FindMachineByIdOrAddress ( id string , address string ) ( Machine , error ) { coll , err := collection ( ) if err != nil { return Machine { } , err } defer coll . Close ( ) var result Machine query := bson . M { } if id != "" { query [ "_id" ] = id } else { query [ "address" ] = address } err = coll . Find ( query ) . One ( & result ) if err == mgo . ErrNotFound { err = ErrMachineNotFound } return result , err }
4004	func ( w * FlushingWriter ) Write ( data [ ] byte ) ( written int , err error ) { w . writeMutex . Lock ( ) defer w . writeMutex . Unlock ( ) w . wrote = true written , err = w . ResponseWriter . Write ( data ) if err != nil { return } if f , ok := w . ResponseWriter . ( http . Flusher ) ; ok { defer func ( ) { if r := recover ( ) ; r != nil { msg := fmt . Sprintf ( "Error recovered on flushing writer: %#v" , r ) log . Debugf ( msg ) err = errors . Errorf ( msg ) } } ( ) f . Flush ( ) } return }
4005	func ( w * FlushingWriter ) Hijack ( ) ( net . Conn , * bufio . ReadWriter , error ) { if hijacker , ok := w . ResponseWriter . ( http . Hijacker ) ; ok { return hijacker . Hijack ( ) } return nil , nil , errors . New ( "cannot hijack connection" ) }
4006	func ListDeploys ( filter * Filter , skip , limit int ) ( [ ] DeployData , error ) { appsList , err := List ( filter ) if err != nil { return nil , err } apps := make ( [ ] string , len ( appsList ) ) for i , a := range appsList { apps [ i ] = a . GetName ( ) } evts , err := event . List ( & event . Filter { Target : event . Target { Type : event . TargetTypeApp } , Raw : bson . M { "target.value" : bson . M { "$in" : apps } } , KindNames : [ ] string { permission . PermAppDeploy . FullName ( ) } , KindType : event . KindTypePermission , Limit : limit , Skip : skip , } ) if err != nil { return nil , err } validImages , err := findValidImages ( appsList ... ) if err != nil { return nil , err } list := make ( [ ] DeployData , len ( evts ) ) for i := range evts { list [ i ] = * eventToDeployData ( & evts [ i ] , validImages , false ) } return list , nil }
4007	func ( r * DelayedRouter ) AddAll ( version , path string , h http . Handler ) * mux . Route { return r . addRoute ( version , path , h , "GET" , "POST" , "PUT" , "DELETE" ) }
4008	func samlRequestTimeout ( schemeData map [ string ] string ) int { p := schemeData [ "request_timeout" ] timeout , _ := strconv . Atoi ( p ) return timeout }
4009	func RegisterHandler ( path string , method string , h http . Handler ) { RegisterHandlerVersion ( "1.0" , path , method , h ) }
4010	func RegisterHandlerVersion ( version , path , method string , h http . Handler ) { var th TsuruHandler th . version = version th . path = path th . method = method th . h = h tsuruHandlerList = append ( tsuruHandlerList , th ) }
4011	func Check ( names ... string ) [ ] Result { results := make ( [ ] Result , 0 , len ( checkers ) ) nameSet := set . FromSlice ( names ) isAll := nameSet . Includes ( "all" ) for _ , checker := range checkers { if ! isAll && ! nameSet . Includes ( checker . name ) { continue } startTime := time . Now ( ) if err := checker . check ( ) ; err != nil && err != ErrDisabledComponent { results = append ( results , Result { Name : checker . name , Status : "fail - " + err . Error ( ) , Duration : time . Since ( startTime ) , } ) } else if err == nil { results = append ( results , Result { Name : checker . name , Status : HealthCheckOK , Duration : time . Since ( startTime ) , } ) } } return results }
4012	func DiscoverRepositoryPath ( dir string ) ( string , error ) { _ , err := os . Stat ( dir ) if os . IsNotExist ( err ) { return "" , ErrRepositoryNotFound } dir = filepath . Join ( dir , ".git" ) for dir != "/.git" { fi , err := os . Stat ( dir ) if err == nil && fi . IsDir ( ) { return dir , nil } dir = filepath . Join ( dir , ".." , ".." , ".git" ) } return "" , ErrRepositoryNotFound }
4013	func OpenRepository ( p string ) ( * Repository , error ) { if ! strings . HasSuffix ( p , ".git" ) && ! strings . HasSuffix ( p , ".git/" ) { p = filepath . Join ( p , ".git" ) } p = strings . TrimRight ( p , "/" ) fi , err := os . Stat ( filepath . Join ( p , "config" ) ) if err == nil && ! fi . IsDir ( ) { return & Repository { path : p } , nil } return nil , ErrRepositoryNotFound }
4014	func ( r * Repository ) RemoteURL ( name string ) ( string , error ) { config , err := os . Open ( filepath . Join ( r . path , "config" ) ) if err != nil { return "" , err } defer config . Close ( ) line := fmt . Sprintf ( "[remote %q]" , name ) scanner := bufio . NewScanner ( config ) scanner . Split ( bufio . ScanLines ) for scanner . Scan ( ) { if scanner . Text ( ) == line { scanner . Scan ( ) return strings . Split ( scanner . Text ( ) , " = " ) [ 1 ] , nil } } return "" , errRemoteNotFound { name } }
4015	func ( s * appLister ) List ( selector labels . Selector ) ( ret [ ] * v1 . App , err error ) { err = cache . ListAll ( s . indexer , selector , func ( m interface { } ) { ret = append ( ret , m . ( * v1 . App ) ) } ) return ret , err }
4016	func ( s * appLister ) Apps ( namespace string ) AppNamespaceLister { return appNamespaceLister { indexer : s . indexer , namespace : namespace } }
4017	func ( s appNamespaceLister ) List ( selector labels . Selector ) ( ret [ ] * v1 . App , err error ) { err = cache . ListAllByNamespace ( s . indexer , s . namespace , selector , func ( m interface { } ) { ret = append ( ret , m . ( * v1 . App ) ) } ) return ret , err }
4018	func StreamJSONResponse ( w io . Writer , response * http . Response ) error { if response == nil { return errors . New ( "response cannot be nil" ) } defer response . Body . Close ( ) var err error output := tsuruio . NewStreamWriter ( w , nil ) for n := int64 ( 1 ) ; n > 0 && err == nil ; n , err = io . Copy ( output , response . Body ) { } if err != nil { return err } unparsed := output . Remaining ( ) if len ( unparsed ) > 0 { return errors . Errorf ( "unparsed message error: %s" , string ( unparsed ) ) } return nil }
4019	func ( s * Storage ) DropDatabase ( name string ) error { return s . session . DB ( name ) . DropDatabase ( ) }
4020	func ( s * Storage ) Collection ( name string ) * Collection { return & Collection { Collection : s . session . DB ( s . dbname ) . C ( name ) } }
4021	func ( t * Target ) SetLogger ( l Logger ) { t . mut . Lock ( ) defer t . mut . Unlock ( ) t . logger = l }
4022	func ( t * Target ) Error ( v error ) { t . mut . RLock ( ) defer t . mut . RUnlock ( ) if t . logger != nil { t . logger . Errorf ( "%+v" , v ) } }
4023	func ( t * Target ) Errorf ( format string , v ... interface { } ) { t . mut . RLock ( ) defer t . mut . RUnlock ( ) if t . logger != nil { t . logger . Errorf ( format , v ... ) for _ , item := range v { if _ , hasStack := item . ( withStack ) ; hasStack { t . logger . Errorf ( "stack for error: %+v" , item ) } } } }
4024	func ( t * Target ) Fatal ( v string ) { t . mut . RLock ( ) defer t . mut . RUnlock ( ) if t . logger != nil { t . logger . Fatal ( v ) } }
4025	func ( t * Target ) Debugf ( format string , v ... interface { } ) { t . mut . RLock ( ) defer t . mut . RUnlock ( ) if t . logger != nil { t . logger . Debugf ( format , v ... ) } }
4026	func ( t * Target ) GetStdLogger ( ) * log . Logger { t . mut . RLock ( ) defer t . mut . RUnlock ( ) if t . logger != nil { return t . logger . GetStdLogger ( ) } return nil }
4027	func ( c * ClusterClient ) Namespace ( ) string { if c . CustomData != nil && c . CustomData [ namespaceClusterKey ] != "" { return c . CustomData [ namespaceClusterKey ] } return "tsuru" }
4028	func recreateContainers ( p DockerProvisioner , w io . Writer , nodes ... cluster . Node ) error { return ensureContainersStarted ( p , w , true , nil , nodes ... ) }
4029	func checkProvisioner ( ) error { if value , _ := config . Get ( "provisioner" ) ; value == defaultProvisionerName || value == "" { return checkDocker ( ) } return nil }
4030	func checkDocker ( ) error { if _ , err := config . Get ( "docker" ) ; err != nil { return errors . New ( "Config error: you should configure docker." ) } err := checkDockerBasicConfig ( ) if err != nil { return err } err = checkScheduler ( ) if err != nil { return err } err = checkRouter ( ) if err != nil { return err } return checkCluster ( ) }
4031	func checkScheduler ( ) error { if servers , err := config . Get ( "docker:servers" ) ; err == nil && servers != nil { return errors . Errorf ( `Using docker:servers is deprecated, please remove it your config and use "tsuru docker-node-add" do add docker nodes.` ) } isSegregate , err := config . GetBool ( "docker:segregate" ) if err == nil { if isSegregate { return config . NewWarning ( `Setting "docker:segregate" is not necessary anymore, this is the default behavior from now on.` ) } else { return errors . Errorf ( `You must remove "docker:segregate" from your config.` ) } } return nil }
4032	func checkRouter ( ) error { defaultRouter , _ := config . GetString ( "docker:router" ) if defaultRouter == "" { return errors . Errorf ( `You must configure a default router in "docker:router".` ) } isHipacheOld := false if defaultRouter == "hipache" { hipacheOld , _ := config . Get ( "hipache" ) isHipacheOld = hipacheOld != nil } routerConf , _ := config . Get ( "routers:" + defaultRouter ) if isHipacheOld { return config . NewWarning ( `Setting "hipache:*" config entries is deprecated. You should configure your router with "routers:*". See http://docs.tsuru.io/en/latest/reference/config.html#routers for more details.` ) } if routerConf == nil { return errors . Errorf ( `You must configure your default router %q in "routers:%s".` , defaultRouter , defaultRouter ) } routerType , _ := config . Get ( "routers:" + defaultRouter + ":type" ) if routerType == nil { return errors . Errorf ( `You must configure your default router type in "routers:%s:type".` , defaultRouter ) } return nil }
4033	func ( u * Unit ) Available ( ) bool { return u . Status == StatusStarted || u . Status == StatusStarting || u . Status == StatusError }
4034	func Get ( name string ) ( Provisioner , error ) { pFunc , ok := provisioners [ name ] if ! ok { return nil , errors . Errorf ( "unknown provisioner: %q" , name ) } return pFunc ( ) }
4035	func Registry ( ) ( [ ] Provisioner , error ) { registry := make ( [ ] Provisioner , 0 , len ( provisioners ) ) for _ , pFunc := range provisioners { p , err := pFunc ( ) if err != nil { return nil , err } registry = append ( registry , p ) } return registry , nil }
4036	func ( e * Error ) Error ( ) string { var err string if e . Err != nil { err = e . Err . Error ( ) + ": " + e . Reason } else { err = e . Reason } return err }
4037	func validateVersion ( supported , current string ) bool { if supported == "" { return true } vSupported , err := goVersion . NewVersion ( supported ) if err != nil { return false } vCurrent , err := goVersion . NewVersion ( current ) if err != nil { return false } return vCurrent . Compare ( vSupported ) >= 0 }
4038	func ReadTarget ( ) ( string , error ) { if target := os . Getenv ( "TSURU_TARGET" ) ; target != "" { targets , err := getTargets ( ) if err == nil { if val , ok := targets [ target ] ; ok { return val , nil } } return target , nil } targetPath := JoinWithUserDir ( ".tsuru" , "target" ) target , err := readTarget ( targetPath ) if err == errUndefinedTarget { copyTargetFiles ( ) target , err = readTarget ( JoinWithUserDir ( ".tsuru_target" ) ) } return target , err }
4039	func WriteTarget ( t string ) error { targetPath := JoinWithUserDir ( ".tsuru" , "target" ) targetFile , err := filesystem ( ) . OpenFile ( targetPath , syscall . O_WRONLY | syscall . O_CREAT | syscall . O_TRUNC , 0600 ) if err != nil { return err } defer targetFile . Close ( ) n , err := targetFile . WriteString ( t ) if n != len ( t ) || err != nil { return errors . New ( "Failed to write the target file" ) } return nil }
4040	func WriteOnTargetList ( label , target string ) error { label = strings . TrimSpace ( label ) target = strings . TrimSpace ( target ) targetExist , err := CheckIfTargetLabelExists ( label ) if err != nil { return err } if targetExist { return errors . New ( "Target label provided already exists" ) } targetsPath := JoinWithUserDir ( ".tsuru" , "targets" ) targetsFile , err := filesystem ( ) . OpenFile ( targetsPath , syscall . O_RDWR | syscall . O_CREAT | syscall . O_APPEND , 0600 ) if err != nil { return err } defer targetsFile . Close ( ) content := label + "\t" + \t + target "\n" \n n , err := targetsFile . WriteString ( content ) }
4041	func Conn ( ) ( * Storage , error ) { var ( strg Storage err error ) url , dbname := DbConfig ( "" ) strg . Storage , err = storage . Open ( url , dbname ) return & strg , err }
4042	func ( s * Storage ) Apps ( ) * storage . Collection { nameIndex := mgo . Index { Key : [ ] string { "name" } , Unique : true } c := s . Collection ( "apps" ) c . EnsureIndex ( nameIndex ) return c }
4043	func ( s * Storage ) PoolsConstraints ( ) * storage . Collection { poolConstraintIndex := mgo . Index { Key : [ ] string { "poolexpr" , "field" } , Unique : true } c := s . Collection ( "pool_constraints" ) c . EnsureIndex ( poolConstraintIndex ) return c }
4044	func ( s * Storage ) Users ( ) * storage . Collection { emailIndex := mgo . Index { Key : [ ] string { "email" } , Unique : true } c := s . Collection ( "users" ) c . EnsureIndex ( emailIndex ) return c }
4045	func ( s * Storage ) SAMLRequests ( ) * storage . Collection { id := mgo . Index { Key : [ ] string { "id" } } coll := s . Collection ( "saml_requests" ) coll . EnsureIndex ( id ) return coll }
4046	func ( s * LogStorage ) AppLogCollection ( appName string ) * storage . Collection { if appName == "" { return nil } return s . Collection ( "logs_" + appName ) }
4047	func ( s * LogStorage ) CreateAppLogCollection ( appName string ) ( * storage . Collection , error ) { c := s . AppLogCollection ( appName ) err := c . Create ( & logCappedInfo ) return c , err }
4048	func ( s * LogStorage ) LogsCollections ( ) ( [ ] * storage . Collection , error ) { var names [ ] struct { Name string } conn , err := Conn ( ) if err != nil { return nil , err } defer conn . Close ( ) err = conn . Apps ( ) . Find ( nil ) . All ( & names ) if err != nil { return nil , err } var colls [ ] * storage . Collection for _ , name := range names { colls = append ( colls , s . Collection ( "logs_" + name . Name ) ) } return colls , nil }
4049	func ArchiveBuildCmds ( app provision . App , archiveURL string ) [ ] string { return buildCmds ( app , "build" , "archive" , archiveURL ) }
4050	func ArchiveDeployCmds ( app provision . App , archiveURL string ) [ ] string { return buildCmds ( app , "deploy" , "archive" , archiveURL ) }
4051	func DeployCmds ( app provision . App ) [ ] string { uaCmds := unitAgentCmds ( app ) uaCmds = append ( uaCmds , "deploy-only" ) finalCmd := strings . Join ( uaCmds , " " ) return [ ] string { "/bin/sh" , "-lc" , finalCmd } }
4052	func runWithAgentCmds ( app provision . App ) ( [ ] string , error ) { runCmd , err := config . GetString ( "docker:run-cmd:bin" ) if err != nil { runCmd = "/var/lib/tsuru/start" } host , _ := config . GetString ( "host" ) token := app . Envs ( ) [ "TSURU_APP_TOKEN" ] . Value return [ ] string { "tsuru_unit_agent" , host , token , app . GetName ( ) , runCmd } , nil }
4053	func newApps ( c * TsuruV1Client , namespace string ) * apps { return & apps { client : c . RESTClient ( ) , ns : namespace , } }
4054	func ( c * Container ) Commit ( client provision . BuilderDockerClient , limiter provision . ActionLimiter , writer io . Writer , isDeploy bool ) ( string , error ) { log . Debugf ( "committing container %s" , c . ID ) repository , tag := image . SplitImageName ( c . BuildingImage ) opts := docker . CommitContainerOptions { Container : c . ID , Repository : repository , Tag : tag } done := limiter . Start ( c . HostAddr ) image , err := client . CommitContainer ( opts ) done ( ) if err != nil { return "" , log . WrapError ( errors . Wrapf ( err , "error in commit container %s" , c . ID ) ) } tags := [ ] string { tag } if isDeploy && tag != "latest" { tags = append ( tags , "latest" ) err = client . TagImage ( fmt . Sprintf ( "%s:%s" , repository , tag ) , docker . TagImageOptions { Repo : repository , Tag : "latest" , Force : true , } ) if err != nil { return "" , log . WrapError ( errors . Wrapf ( err , "error in tag container %s" , c . ID ) ) } } imgHistory , err := client . ImageHistory ( c . BuildingImage ) imgSize := "" if err == nil && len ( imgHistory ) > 0 { fullSize := imgHistory [ 0 ] . Size if len ( imgHistory ) > 1 && strings . Contains ( imgHistory [ 1 ] . CreatedBy , "tail -f /dev/null" ) { fullSize += imgHistory [ 1 ] . Size } imgSize = fmt . Sprintf ( "(%.02fMB)" , float64 ( fullSize ) / 1024 / 1024 ) } fmt . Fprintf ( writer , " - , \n ) imgSize log . Debugf ( "image %s generated from container %s" , image . ID , c . ID ) for _ , tag := range tags { maxTry , _ := config . GetInt ( "docker:registry-max-try" ) if maxTry <= 0 { maxTry = 3 } for i := 0 ; i < maxTry ; i ++ { err = dockercommon . PushImage ( client , repository , tag , dockercommon . RegistryAuthConfig ( repository ) ) if err != nil { fmt . Fprintf ( writer , "Could not send image, trying again. Original error: %s\n" , \n ) err . Error ( ) log . Errorf ( "error in push image %s: %s" , c . BuildingImage , err ) time . Sleep ( time . Second ) } continue } break } }
4055	func processTags ( tags [ ] string ) [ ] string { if tags == nil { return nil } processedTags := [ ] string { } usedTags := make ( map [ string ] bool ) for _ , tag := range tags { tag = strings . TrimSpace ( tag ) if len ( tag ) > 0 && ! usedTags [ tag ] { processedTags = append ( processedTags , tag ) usedTags [ tag ] = true } } return processedTags }
4056	func ( s * segregatedScheduler ) aggregateContainersBy ( matcher bson . M ) ( map [ string ] int , error ) { coll := s . provisioner . Collection ( ) defer coll . Close ( ) pipe := coll . Pipe ( [ ] bson . M { matcher , { "$group" : bson . M { "_id" : "$hostaddr" , "count" : bson . M { "$sum" : 1 } } } , } ) var results [ ] nodeAggregate err := pipe . All ( & results ) if err != nil { return nil , err } countMap := make ( map [ string ] int ) for _ , result := range results { countMap [ result . HostAddr ] = result . Count } return countMap , nil }
4057	func ( s * segregatedScheduler ) chooseNodeToAdd ( nodes [ ] cluster . Node , contName string , appName , process string ) ( string , error ) { log . Debugf ( "[scheduler] Possible nodes for container %s: %#v" , contName , nodes ) s . hostMutex . Lock ( ) defer s . hostMutex . Unlock ( ) chosenNode , _ , err := s . minMaxNodes ( nodes , appName , process ) if err != nil { return "" , err } log . Debugf ( "[scheduler] Chosen node for container %s: %#v" , contName , chosenNode ) if contName != "" { coll := s . provisioner . Collection ( ) defer coll . Close ( ) err = coll . Update ( bson . M { "name" : contName } , bson . M { "$set" : bson . M { "hostaddr" : net . URLToHost ( chosenNode ) } } ) } return chosenNode , err }
4058	func ( s * segregatedScheduler ) chooseContainerToRemove ( nodes [ ] cluster . Node , appName , process string ) ( string , error ) { _ , chosenNode , err := s . minMaxNodes ( nodes , appName , process ) if err != nil { return "" , err } log . Debugf ( "[scheduler] Chosen node for remove a container: %#v" , chosenNode ) containerID , err := s . getContainerPreferablyFromHost ( chosenNode , appName , process ) if err != nil { return "" , err } return containerID , err }
4059	func Get ( name string ) ( Router , error ) { routerType , prefix , err := Type ( name ) if err != nil { return nil , & ErrRouterNotFound { Name : name } } factory , ok := routers [ routerType ] if ! ok { return nil , errors . Errorf ( "unknown router: %q." , routerType ) } r , err := factory ( name , prefix ) if err != nil { return nil , err } return r , nil }
4060	func Default ( ) ( string , error ) { plans , err := List ( ) if err != nil { return "" , err } if len ( plans ) == 0 { return "" , ErrDefaultRouterNotFound } if len ( plans ) == 1 { return plans [ 0 ] . Name , nil } for _ , p := range plans { if p . Default { return p . Name , nil } } return "" , ErrDefaultRouterNotFound }
4061	func Store ( appName , routerName , kind string ) error { coll , err := collection ( ) if err != nil { return err } defer coll . Close ( ) data := routerAppEntry { App : appName , Router : routerName , Kind : kind , } _ , err = coll . Upsert ( bson . M { "app" : appName } , data ) return err }
4062	func ( c * Clientset ) TsuruV1 ( ) tsuruv1 . TsuruV1Interface { return & faketsuruv1 . FakeTsuruV1 { Fake : & c . Fake } }
4063	func ( c * Clientset ) Tsuru ( ) tsuruv1 . TsuruV1Interface { return & faketsuruv1 . FakeTsuruV1 { Fake : & c . Fake } }
4064	func NewAppInformer ( client versioned . Interface , namespace string , resyncPeriod time . Duration , indexers cache . Indexers ) cache . SharedIndexInformer { return NewFilteredAppInformer ( client , namespace , resyncPeriod , indexers , nil ) }
4065	func NewFilteredAppInformer ( client versioned . Interface , namespace string , resyncPeriod time . Duration , indexers cache . Indexers , tweakListOptions internalinterfaces . TweakListOptionsFunc ) cache . SharedIndexInformer { return cache . NewSharedIndexInformer ( & cache . ListWatch { ListFunc : func ( options meta_v1 . ListOptions ) ( runtime . Object , error ) { if tweakListOptions != nil { tweakListOptions ( & options ) } return client . TsuruV1 ( ) . Apps ( namespace ) . List ( options ) } , WatchFunc : func ( options meta_v1 . ListOptions ) ( watch . Interface , error ) { if tweakListOptions != nil { tweakListOptions ( & options ) } return client . TsuruV1 ( ) . Apps ( namespace ) . Watch ( options ) } , } , & tsuru_v1 . App { } , resyncPeriod , indexers , ) }
4066	func ( c * FakeApps ) Watch ( opts v1 . ListOptions ) ( watch . Interface , error ) { return c . Fake . InvokesWatch ( testing . NewWatchAction ( appsResource , c . ns , opts ) ) }
4067	func ( c * FakeApps ) Patch ( name string , pt types . PatchType , data [ ] byte , subresources ... string ) ( result * tsuru_v1 . App , err error ) { obj , err := c . Fake . Invokes ( testing . NewPatchSubresourceAction ( appsResource , c . ns , name , data , subresources ... ) , & tsuru_v1 . App { } ) if obj == nil { return nil , err } return obj . ( * tsuru_v1 . App ) , err }
4068	func NewSharedInformerFactory ( client versioned . Interface , defaultResync time . Duration ) SharedInformerFactory { return NewFilteredSharedInformerFactory ( client , defaultResync , v1 . NamespaceAll , nil ) }
4069	func NewFilteredSharedInformerFactory ( client versioned . Interface , defaultResync time . Duration , namespace string , tweakListOptions internalinterfaces . TweakListOptionsFunc ) SharedInformerFactory { return & sharedInformerFactory { client : client , namespace : namespace , tweakListOptions : tweakListOptions , defaultResync : defaultResync , informers : make ( map [ reflect . Type ] cache . SharedIndexInformer ) , startedInformers : make ( map [ reflect . Type ] bool ) , } }
4070	func ( b * brokerClient ) Proxy ( path string , evt * event . Event , requestID string , w http . ResponseWriter , r * http . Request ) error { return fmt . Errorf ( "service proxy is not available for broker services" ) }
4071	func ( b * brokerClient ) UnbindUnit ( instance * ServiceInstance , app bind . App , unit bind . Unit ) error { return nil }
4072	func ( s * planService ) Create ( plan appTypes . Plan ) error { if plan . Name == "" { return appTypes . PlanValidationError { Field : "name" } } if plan . CpuShare < 2 { return appTypes . ErrLimitOfCpuShare } if plan . Memory > 0 && plan . Memory < 4194304 { return appTypes . ErrLimitOfMemory } return s . storage . Insert ( plan ) }
4073	func ( s * planService ) Remove ( planName string ) error { return s . storage . Delete ( appTypes . Plan { Name : planName } ) }
4074	func ( s * planService ) ensureDefault ( ) error { plans , err := s . storage . FindAll ( ) if err != nil { return err } if len ( plans ) > 0 { return nil } configMemory , _ := config . GetInt ( "docker:memory" ) configSwap , _ := config . GetInt ( "docker:swap" ) dp := appTypes . Plan { Name : "autogenerated" , Memory : int64 ( configMemory ) * 1024 * 1024 , Swap : int64 ( configSwap - configMemory ) * 1024 * 1024 , CpuShare : 100 , Default : true , } return s . storage . Insert ( dp ) }
4075	func DeleteInstance ( si * ServiceInstance , evt * event . Event , requestID string ) error { if len ( si . Apps ) > 0 { return ErrServiceInstanceBound } s , err := Get ( si . ServiceName ) if err != nil { return err } endpoint , err := s . getClient ( "production" ) if err == nil { endpoint . Destroy ( si , evt , requestID ) } conn , err := db . Conn ( ) if err != nil { return err } defer conn . Close ( ) return conn . ServiceInstances ( ) . Remove ( bson . M { "name" : si . Name , "service_name" : si . ServiceName } ) }
4076	func ( si * ServiceInstance ) ToInfo ( ) ( ServiceInstanceWithInfo , error ) { info , err := si . Info ( "" ) if err != nil { info = nil } return ServiceInstanceWithInfo { Id : si . Id , Name : si . Name , Teams : si . Teams , PlanName : si . PlanName , Apps : si . Apps , ServiceName : si . ServiceName , Info : info , TeamOwner : si . TeamOwner , } , nil }
4077	func ( si * ServiceInstance ) Update ( service Service , updateData ServiceInstance , evt * event . Event , requestID string ) error { err := validateServiceInstanceTeamOwner ( updateData ) if err != nil { return err } conn , err := db . Conn ( ) if err != nil { return err } defer conn . Close ( ) tags := processTags ( updateData . Tags ) if tags == nil { updateData . Tags = si . Tags } else { updateData . Tags = tags } actions := [ ] * action . Action { & updateServiceInstance , & notifyUpdateServiceInstance } pipeline := action . NewPipeline ( actions ... ) return pipeline . Execute ( service , * si , updateData , evt , requestID ) }
4078	func ( si * ServiceInstance ) BindApp ( app bind . App , params BindAppParameters , shouldRestart bool , writer io . Writer , evt * event . Event , requestID string ) error { args := bindPipelineArgs { serviceInstance : si , app : app , writer : writer , shouldRestart : shouldRestart , params : params , event : evt , requestID : requestID , } actions := [ ] * action . Action { bindAppDBAction , bindAppEndpointAction , setBoundEnvsAction , bindUnitsAction , } pipeline := action . NewPipeline ( actions ... ) return pipeline . Execute ( & args ) }
4079	func ( si * ServiceInstance ) BindUnit ( app bind . App , unit bind . Unit ) error { s , err := Get ( si . ServiceName ) if err != nil { return err } endpoint , err := s . getClient ( "production" ) if err != nil { return err } conn , err := db . Conn ( ) if err != nil { return err } updateOp := bson . M { "$addToSet" : bson . M { "bound_units" : bson . D ( [ ] bson . DocElem { { Name : "appname" , Value : app . GetName ( ) } , { Name : "id" , Value : unit . GetID ( ) } , { Name : "ip" , Value : unit . GetIp ( ) } , } ) , } , } err = conn . ServiceInstances ( ) . Update ( bson . M { "name" : si . Name , "service_name" : si . ServiceName , "bound_units.id" : bson . M { "$ne" : unit . GetID ( ) } } , updateOp ) conn . Close ( ) if err != nil { if err == mgo . ErrNotFound { return nil } return err } err = endpoint . BindUnit ( si , app , unit ) if err != nil { updateOp = bson . M { "$pull" : bson . M { "bound_units" : bson . D ( [ ] bson . DocElem { { Name : "appname" , Value : app . GetName ( ) } , { Name : "id" , Value : unit . GetID ( ) } , { Name : "ip" , Value : unit . GetIp ( ) } , } ) , } , } rollbackErr := si . updateData ( updateOp ) if rollbackErr != nil { log . Errorf ( "[bind unit] could not remove stil unbound unit from db after failure: %s" , rollbackErr ) } return err } return nil }
4080	func ( si * ServiceInstance ) UnbindApp ( unbindArgs UnbindAppArgs ) error { if si . FindApp ( unbindArgs . App . GetName ( ) ) == - 1 { return ErrAppNotBound } args := bindPipelineArgs { serviceInstance : si , app : unbindArgs . App , writer : unbindArgs . Event , shouldRestart : unbindArgs . Restart , event : unbindArgs . Event , requestID : unbindArgs . RequestID , forceRemove : unbindArgs . ForceRemove , } actions := [ ] * action . Action { & unbindUnits , & unbindAppDB , & unbindAppEndpoint , & removeBoundEnvs , } pipeline := action . NewPipeline ( actions ... ) return pipeline . Execute ( & args ) }
4081	func ( si * ServiceInstance ) Status ( requestID string ) ( string , error ) { s , err := Get ( si . ServiceName ) if err != nil { return "" , err } endpoint , err := s . getClient ( "production" ) if err != nil { return "" , err } return endpoint . Status ( si , requestID ) }
4082	func ProxyInstance ( instance * ServiceInstance , path string , evt * event . Event , requestID string , w http . ResponseWriter , r * http . Request ) error { service , err := Get ( instance . ServiceName ) if err != nil { return err } endpoint , err := service . getClient ( "production" ) if err != nil { return err } prefix := fmt . Sprintf ( "/resources/%s/" , instance . GetIdentifier ( ) ) path = strings . Trim ( strings . TrimPrefix ( path + "/" , prefix ) , "/" ) for _ , reserved := range reservedProxyPaths { if path == reserved && r . Method != "GET" { return & tsuruErrors . ValidationError { Message : fmt . Sprintf ( "proxy request %s %q is forbidden" , r . Method , path ) , } } } return endpoint . Proxy ( fmt . Sprintf ( "%s%s" , prefix , path ) , evt , requestID , w , r ) }
4083	func ( s * QuotaService ) Inc ( appName string , quantity int ) error { quota , err := s . Storage . Get ( appName ) if err != nil { return err } err = s . checkLimit ( quota , quantity ) if err != nil { return err } return s . Storage . Inc ( appName , quantity ) }
4084	func ( s * QuotaService ) SetLimit ( appName string , limit int ) error { q , err := s . Storage . Get ( appName ) if err != nil { return err } if limit < 0 { limit = - 1 } else if limit < q . InUse { return quota . ErrLimitLowerThanAllocated } return s . Storage . SetLimit ( appName , limit ) }
4085	func ( s * QuotaService ) Set ( appName string , inUse int ) error { q , err := s . Storage . Get ( appName ) if err != nil { return err } if inUse < 0 { return quota . ErrLessThanZero } if ! q . IsUnlimited ( ) && inUse > q . Limit { return & quota . QuotaExceededError { Requested : uint ( inUse ) , Available : uint ( q . Limit ) , } } return s . Storage . Set ( appName , inUse ) }
4086	func ( s * QuotaService ) Get ( appName string ) ( * quota . Quota , error ) { return s . Storage . Get ( appName ) }
4087	func RemoveImage ( imageName string ) error { registry , image , tag := parseImage ( imageName ) if registry == "" { registry , _ = config . GetString ( "docker:registry" ) } if registry == "" { return nil } if image == "" { return errors . Errorf ( "empty image after parsing %q" , imageName ) } r := & dockerRegistry { server : registry } digest , err := r . getDigest ( image , tag ) if err != nil { return errors . Wrapf ( err , "failed to get digest for image %s/%s:%s on registry" , r . server , image , tag ) } err = r . removeImage ( image , digest ) if err != nil { return errors . Wrapf ( err , "failed to remove image %s/%s:%s/%s on registry" , r . server , image , tag , digest ) } return nil }
4088	func RemoveAppImages ( appName string ) error { registry , _ := config . GetString ( "docker:registry" ) if registry == "" { return nil } r := & dockerRegistry { server : registry } image := fmt . Sprintf ( "tsuru/app-%s" , appName ) tags , err := r . getImageTags ( image ) if err != nil { return err } multi := tsuruErrors . NewMultiError ( ) for _ , tag := range tags { digest , err := r . getDigest ( image , tag ) if err != nil { multi . Add ( errors . Wrapf ( err , "failed to get digest for image %s/%s:%s on registry" , r . server , image , tag ) ) continue } err = r . removeImage ( image , digest ) if err != nil { multi . Add ( errors . Wrapf ( err , "failed to remove image %s/%s:%s/%s on registry" , r . server , image , tag , digest ) ) if errors . Cause ( err ) == ErrDeleteDisabled { break } } } return multi . ToError ( ) }
4089	func ( s * platformService ) Create ( opts appTypes . PlatformOptions ) error { p := appTypes . Platform { Name : opts . Name } if err := s . validate ( p ) ; err != nil { return err } err := s . storage . Insert ( p ) if err != nil { return err } opts . ImageName , err = servicemanager . PlatformImage . NewImage ( opts . Name ) if err != nil { return err } err = builder . PlatformAdd ( opts ) if err != nil { if imgErr := servicemanager . PlatformImage . DeleteImages ( opts . Name ) ; imgErr != nil { log . Errorf ( "unable to remove platform images: %s" , imgErr ) } dbErr := s . storage . Delete ( p ) if dbErr != nil { return tsuruErrors . NewMultiError ( errors . Wrapf ( dbErr , "unable to rollback platform add" ) , errors . Wrapf ( err , "original platform add error" ) , ) } return err } return servicemanager . PlatformImage . AppendImage ( opts . Name , opts . ImageName ) }
4090	func ( s * platformService ) List ( enabledOnly bool ) ( [ ] appTypes . Platform , error ) { if enabledOnly { return s . storage . FindEnabled ( ) } return s . storage . FindAll ( ) }
4091	func ( s * platformService ) FindByName ( name string ) ( * appTypes . Platform , error ) { p , err := s . storage . FindByName ( name ) if err != nil { return nil , appTypes . ErrInvalidPlatform } return p , nil }
4092	func ( s * platformService ) Update ( opts appTypes . PlatformOptions ) error { if opts . Name == "" { return appTypes . ErrPlatformNameMissing } conn , err := db . Conn ( ) if err != nil { return err } defer conn . Close ( ) _ , err = s . FindByName ( opts . Name ) if err != nil { return err } if opts . Input != nil { data , err := ioutil . ReadAll ( opts . Input ) if err != nil { return err } if len ( data ) == 0 { return appTypes . ErrMissingFileContent } opts . Data = data opts . ImageName , err = servicemanager . PlatformImage . NewImage ( opts . Name ) if err != nil { return err } err = builder . PlatformUpdate ( opts ) if err != nil { return err } err = servicemanager . PlatformImage . AppendImage ( opts . Name , opts . ImageName ) if err != nil { return err } var apps [ ] App err = conn . Apps ( ) . Find ( bson . M { "framework" : opts . Name } ) . All ( & apps ) if err != nil { return err } for _ , app := range apps { app . SetUpdatePlatform ( true ) } } if opts . Args [ "disabled" ] != "" { disableBool , err := strconv . ParseBool ( opts . Args [ "disabled" ] ) if err != nil { return err } return s . storage . Update ( appTypes . Platform { Name : opts . Name , Disabled : disableBool } ) } return nil }
4093	func ( s * platformService ) Remove ( name string ) error { if name == "" { return appTypes . ErrPlatformNameMissing } conn , err := db . Conn ( ) if err != nil { return err } defer conn . Close ( ) apps , _ := conn . Apps ( ) . Find ( bson . M { "framework" : name } ) . Count ( ) if apps > 0 { return appTypes . ErrDeletePlatformWithApps } err = builder . PlatformRemove ( name ) if err != nil { log . Errorf ( "Failed to remove platform from builder: %s" , err ) } images , err := servicemanager . PlatformImage . ListImagesOrDefault ( name ) if err == nil { for _ , img := range images { if regErr := registry . RemoveImage ( img ) ; regErr != nil { log . Errorf ( "Failed to remove platform image from registry: %s" , regErr ) } } } else { log . Errorf ( "Failed to retrieve platform images from storage: %s" , err ) } err = servicemanager . PlatformImage . DeleteImages ( name ) if err != nil { log . Errorf ( "Failed to remove platform images from storage: %s" , err ) } return s . storage . Delete ( appTypes . Platform { Name : name } ) }
4094	func ( s * platformService ) Rollback ( opts appTypes . PlatformOptions ) error { if opts . Name == "" { return appTypes . ErrPlatformNameMissing } if opts . ImageName == "" { return appTypes . ErrPlatformImageMissing } _ , err := s . FindByName ( opts . Name ) if err != nil { return err } image , err := servicemanager . PlatformImage . FindImage ( opts . Name , opts . ImageName ) if err != nil { return err } if image == "" { return fmt . Errorf ( "Image %s not found in platform %q" , opts . ImageName , opts . Name ) } opts . Data = [ ] byte ( "FROM " + image ) opts . ImageName , err = servicemanager . PlatformImage . NewImage ( opts . Name ) if err != nil { return err } err = builder . PlatformUpdate ( opts ) if err != nil { return err } err = servicemanager . PlatformImage . AppendImage ( opts . Name , opts . ImageName ) if err != nil { return err } conn , err := db . Conn ( ) if err != nil { return err } defer conn . Close ( ) var apps [ ] App err = conn . Apps ( ) . Find ( bson . M { "framework" : opts . Name } ) . All ( & apps ) if err != nil { return err } for _ , app := range apps { app . SetUpdatePlatform ( true ) } return nil }
4095	func GetPoolByName ( name string ) ( * Pool , error ) { conn , err := db . Conn ( ) if err != nil { return nil , err } defer conn . Close ( ) var p Pool err = conn . Pools ( ) . FindId ( name ) . One ( & p ) if err != nil { if err == mgo . ErrNotFound { return nil , ErrPoolNotFound } return nil , err } return & p , nil }
4096	func Manager ( ) RepositoryManager { managerName , err := config . GetString ( "repo-manager" ) if err != nil { managerName = defaultManager } if _ , ok := managers [ managerName ] ; ! ok { managerName = "nop" } return managers [ managerName ] }
4097	func Register ( name string , manager RepositoryManager ) { if managers == nil { managers = make ( map [ string ] RepositoryManager ) } managers [ name ] = manager }
4098	func ( b * bindSyncer ) start ( ) error { if b . started { return errors . New ( "syncer already started" ) } if b . appLister == nil { return errors . New ( "must set app lister function" ) } if b . interval == 0 { b . interval = 5 * time . Minute } b . shutdown = make ( chan struct { } , 1 ) b . done = make ( chan struct { } ) b . started = true log . Debugf ( "[bind-syncer] starting. Running every %s.\n" , \n ) b . interval go func ( d time . Duration ) { for { select { case <- time . After ( d ) : start := time . Now ( ) log . Debug ( "[bind-syncer] starting run" ) apps , err := b . appLister ( ) if err != nil { log . Errorf ( "[bind-syncer] error listing apps: %v. Aborting sync." , err ) syncDuration . Set ( time . Since ( start ) . Seconds ( ) ) break } for _ , a := range apps { err = b . sync ( a ) if err != nil { log . Errorf ( "[bind-syncer] error syncing app %q: %v" , a . GetName ( ) , err ) } if len ( b . shutdown ) > 0 { break } } log . Debugf ( "[bind-syncer] finished running. Synced %d apps." , len ( apps ) ) d = b . interval syncDuration . Set ( time . Since ( start ) . Seconds ( ) ) case <- b . shutdown : b . done <- struct { } { } return } } } ( time . Millisecond * 100 ) }
4099	func ( b * bindSyncer ) Shutdown ( ctx context . Context ) error { if ! b . started { return nil } b . shutdown <- struct { } { } select { case <- b . done : case <- ctx . Done ( ) : } b . started = false return ctx . Err ( ) }
4100	func GetForProvisioner ( p provision . Provisioner ) ( Builder , error ) { builder , err := get ( p . GetName ( ) ) if err != nil { if _ , ok := p . ( provision . BuilderDeployDockerClient ) ; ok { return get ( "docker" ) } else if _ , ok := p . ( provision . BuilderDeployKubeClient ) ; ok { return get ( "kubernetes" ) } } return builder , err }
4101	func get ( name string ) ( Builder , error ) { b , ok := builders [ name ] if ! ok { return nil , errors . Errorf ( "unknown builder: %q" , name ) } return b , nil }
4102	func Registry ( ) ( [ ] Builder , error ) { registry := make ( [ ] Builder , 0 , len ( builders ) ) for _ , b := range builders { registry = append ( registry , b ) } return registry , nil }
4103	func RegisterQueueTask ( p DockerProvisioner ) error { q , err := queue . Queue ( ) if err != nil { return err } return q . RegisterTask ( & runBs { provisioner : p } ) }
4104	func ( v * version ) Apps ( ) AppInformer { return & appInformer { factory : v . factory , namespace : v . namespace , tweakListOptions : v . tweakListOptions } }
4105	func ( in * App ) DeepCopy ( ) * App { if in == nil { return nil } out := new ( App ) in . DeepCopyInto ( out ) return out }
4106	func ( in * AppList ) DeepCopy ( ) * AppList { if in == nil { return nil } out := new ( AppList ) in . DeepCopyInto ( out ) return out }
4107	func ( in * AppSpec ) DeepCopy ( ) * AppSpec { if in == nil { return nil } out := new ( AppSpec ) in . DeepCopyInto ( out ) return out }
4108	func ( w * LogWriter ) Write ( data [ ] byte ) ( int , error ) { w . finLk . RLock ( ) defer w . finLk . RUnlock ( ) if w . closed { return len ( data ) , nil } if w . msgCh == nil { return len ( data ) , w . write ( data ) } copied := make ( [ ] byte , len ( data ) ) copy ( copied , data ) w . msgCh <- copied return len ( data ) , nil }
4109	func ( s NativeScheme ) ResetPassword ( user * auth . User , resetToken string ) error { if resetToken == "" { return auth . ErrInvalidToken } conn , err := db . Conn ( ) if err != nil { return err } defer conn . Close ( ) passToken , err := getPasswordToken ( resetToken ) if err != nil { return err } if passToken . UserEmail != user . Email { return auth . ErrInvalidToken } password := generatePassword ( 12 ) user . Password = password hashPassword ( user ) go sendNewPassword ( user , password ) passToken . Used = true conn . PasswordTokens ( ) . UpdateId ( passToken . Token , passToken ) return user . Update ( ) }
4110	func addKnownTypes ( scheme * runtime . Scheme ) error { scheme . AddKnownTypes ( SchemeGroupVersion , & App { } , & AppList { } , ) scheme . AddKnownTypes ( SchemeGroupVersion , & metav1 . Status { } , ) metav1 . AddToGroupVersion ( scheme , SchemeGroupVersion ) return nil }
4111	func Register ( s Shutdownable ) { lock . Lock ( ) defer lock . Unlock ( ) registered = append ( registered , s ) }
4112	func Do ( ctx context . Context , w io . Writer ) error { lock . Lock ( ) defer lock . Unlock ( ) done := make ( chan bool ) wg := sync . WaitGroup { } for _ , h := range registered { wg . Add ( 1 ) go func ( h Shutdownable ) { defer wg . Done ( ) var name string if _ , ok := h . ( fmt . Stringer ) ; ok { name = fmt . Sprintf ( "%s" , h ) } else { name = fmt . Sprintf ( "%T" , h ) } fmt . Fprintf ( w , "[shutdown] running shutdown for %s...\n" , \n ) name err := h . Shutdown ( ctx ) if err != nil { fmt . Fprintf ( w , "[shutdown] running shutdown for %s. ERROED: %v" , name , err ) return } } fmt . Fprintf ( w , "[shutdown] running shutdown for %s. DONE.\n" , \n ) } name ( h ) go func ( ) { wg . Wait ( ) close ( done ) } ( ) }
4113	func ( s * platformImageService ) ListImagesOrDefault ( platformName string ) ( [ ] string , error ) { imgs , err := s . ListImages ( platformName ) if err != nil && err == imageTypes . ErrPlatformImageNotFound { return [ ] string { platformBasicImageName ( platformName ) } , nil } return imgs , err }
4114	func MigrateAppsCRDs ( ) error { config . Set ( "kubernetes:use-pool-namespaces" , false ) defer config . Unset ( "kubernetes:use-pool-namespaces" ) prov := kubernetes . GetProvisioner ( ) pools , err := pool . ListAllPools ( ) if err != nil { return errors . Wrap ( err , "failed to list pools" ) } var kubePools [ ] string for _ , p := range pools { if p . Provisioner == prov . GetName ( ) { kubePools = append ( kubePools , p . Name ) } } apps , err := app . List ( & app . Filter { Pools : kubePools } ) if err != nil { return errors . Wrap ( err , "failed to list apps" ) } multiErr := tsuruerrors . NewMultiError ( ) for _ , a := range apps { errProv := prov . Provision ( & a ) if errProv != nil { multiErr . Add ( errProv ) } } return multiErr . ToError ( ) }
4115	func Register ( name string , fn MigrateFunc ) error { return register ( name , false , fn ) }
4116	func RegisterOptional ( name string , fn MigrateFunc ) error { return register ( name , true , fn ) }
4117	func Run ( args RunArgs ) error { if args . Name != "" { return runOptional ( args ) } if args . Force { return ErrCannotForceMandatory } return run ( args ) }
4118	func ( app * App ) Units ( ) ( [ ] provision . Unit , error ) { prov , err := app . getProvisioner ( ) if err != nil { return [ ] provision . Unit { } , err } units , err := prov . Units ( app ) if units == nil { units = [ ] provision . Unit { } } return units , err }
4119	func ( app * App ) MarshalJSON ( ) ( [ ] byte , error ) { repo , _ := repository . Manager ( ) . GetRepository ( app . Name ) result := make ( map [ string ] interface { } ) result [ "name" ] = app . Name result [ "platform" ] = app . Platform if version := app . GetPlatformVersion ( ) ; version != "latest" { result [ "platform" ] = fmt . Sprintf ( "%s:%s" , app . Platform , version ) } result [ "teams" ] = app . Teams units , err := app . Units ( ) result [ "units" ] = units var errMsgs [ ] string if err != nil { errMsgs = append ( errMsgs , fmt . Sprintf ( "unable to list app units: %+v" , err ) ) } result [ "repository" ] = repo . ReadWriteURL plan := map [ string ] interface { } { "name" : app . Plan . Name , "memory" : app . Plan . Memory , "swap" : app . Plan . Swap , "cpushare" : app . Plan . CpuShare , } routers , err := app . GetRoutersWithAddr ( ) if err != nil { errMsgs = append ( errMsgs , fmt . Sprintf ( "unable to get app addresses: %+v" , err ) ) } if len ( routers ) > 0 { result [ "ip" ] = routers [ 0 ] . Address plan [ "router" ] = routers [ 0 ] . Name result [ "router" ] = routers [ 0 ] . Name result [ "routeropts" ] = routers [ 0 ] . Opts } result [ "cname" ] = app . CName result [ "owner" ] = app . Owner result [ "pool" ] = app . Pool result [ "description" ] = app . Description result [ "deploys" ] = app . Deploys result [ "teamowner" ] = app . TeamOwner result [ "plan" ] = plan result [ "lock" ] = app . Lock result [ "tags" ] = app . Tags result [ "routers" ] = routers if len ( errMsgs ) > 0 { result [ "error" ] = strings . Join ( errMsgs , "\n" ) } \n }
4120	func AcquireApplicationLockWait ( appName string , owner string , reason string , timeout time . Duration ) ( bool , error ) { timeoutChan := time . After ( timeout ) for { appLock := appTypes . AppLock { Locked : true , Reason : reason , Owner : owner , AcquireDate : time . Now ( ) . In ( time . UTC ) , } conn , err := db . Conn ( ) if err != nil { return false , err } err = conn . Apps ( ) . Update ( bson . M { "name" : appName , "lock.locked" : bson . M { "$in" : [ ] interface { } { false , nil } } } , bson . M { "$set" : bson . M { "lock" : appLock } } ) conn . Close ( ) if err == nil { return true , nil } if err != mgo . ErrNotFound { return false , err } select { case <- timeoutChan : return false , nil case <- time . After ( 300 * time . Millisecond ) : } } }
4121	func ReleaseApplicationLock ( appName string ) { var err error retries := 3 for i := 0 ; i < retries ; i ++ { err = releaseApplicationLockOnce ( appName ) if err == nil { return } time . Sleep ( time . Second * time . Duration ( i + 1 ) ) } log . Error ( err ) }
4122	func GetByName ( name string ) ( * App , error ) { var app App conn , err := db . Conn ( ) if err != nil { return nil , err } defer conn . Close ( ) err = conn . Apps ( ) . Find ( bson . M { "name" : name } ) . One ( & app ) if err == mgo . ErrNotFound { return nil , appTypes . ErrAppNotFound } return & app , err }
4123	func ( app * App ) AddUnits ( n uint , process string , w io . Writer ) error { if n == 0 { return errors . New ( "Cannot add zero units." ) } units , err := app . Units ( ) if err != nil { return err } for _ , u := range units { if ( u . Status == provision . StatusAsleep ) || ( u . Status == provision . StatusStopped ) { return errors . New ( "Cannot add units to an app that has stopped or sleeping units" ) } } w = app . withLogWriter ( w ) err = action . NewPipeline ( & reserveUnitsToAdd , & provisionAddUnits , ) . Execute ( app , n , w , process ) rebuild . RoutesRebuildOrEnqueue ( app . Name ) quotaErr := app . fixQuota ( ) if err != nil { return err } return quotaErr }
4124	func ( app * App ) SetUnitStatus ( unitName string , status provision . Status ) error { units , err := app . Units ( ) if err != nil { return err } for _ , unit := range units { if strings . HasPrefix ( unit . ID , unitName ) { prov , err := app . getProvisioner ( ) if err != nil { return err } unitProv , ok := prov . ( provision . UnitStatusProvisioner ) if ! ok { return nil } return unitProv . SetUnitStatus ( unit , status ) } } return & provision . UnitNotFoundError { ID : unitName } }
4125	func UpdateNodeStatus ( nodeData provision . NodeStatusData ) ( [ ] UpdateUnitsResult , error ) { node , findNodeErr := findNodeForNodeData ( nodeData ) var nodeAddresses [ ] string if findNodeErr == nil { nodeAddresses = [ ] string { node . Address ( ) } } else { nodeAddresses = nodeData . Addrs } if healer . HealerInstance != nil { err := healer . HealerInstance . UpdateNodeData ( nodeAddresses , nodeData . Checks ) if err != nil { log . Errorf ( "[update node status] unable to set node status in healer: %s" , err ) } } if findNodeErr == provision . ErrNodeNotFound { counterNodesNotFound . Inc ( ) log . Errorf ( "[update node status] node not found with nodedata: %#v" , nodeData ) result := make ( [ ] UpdateUnitsResult , len ( nodeData . Units ) ) for i , unitData := range nodeData . Units { result [ i ] = UpdateUnitsResult { ID : unitData . ID , Found : false } } return result , nil } if findNodeErr != nil { return nil , findNodeErr } unitProv , ok := node . Provisioner ( ) . ( provision . UnitStatusProvisioner ) if ! ok { return [ ] UpdateUnitsResult { } , nil } result := make ( [ ] UpdateUnitsResult , len ( nodeData . Units ) ) for i , unitData := range nodeData . Units { unit := provision . Unit { ID : unitData . ID , Name : unitData . Name } err := unitProv . SetUnitStatus ( unit , unitData . Status ) _ , isNotFound := err . ( * provision . UnitNotFoundError ) if err != nil && ! isNotFound { return nil , err } result [ i ] = UpdateUnitsResult { ID : unitData . ID , Found : ! isNotFound } } return result , nil }
4126	func ( app * App ) available ( ) bool { units , err := app . Units ( ) if err != nil { return false } for _ , unit := range units { if unit . Available ( ) { return true } } return false }
4127	func ( app * App ) Grant ( team * authTypes . Team ) error { if _ , found := app . findTeam ( team ) ; found { return ErrAlreadyHaveAccess } app . Teams = append ( app . Teams , team . Name ) conn , err := db . Conn ( ) if err != nil { return err } defer conn . Close ( ) err = conn . Apps ( ) . Update ( bson . M { "name" : app . Name } , bson . M { "$addToSet" : bson . M { "teams" : team . Name } } ) if err != nil { return err } users , err := auth . ListUsersWithPermissions ( permission . Permission { Scheme : permission . PermAppDeploy , Context : permission . Context ( permTypes . CtxTeam , team . Name ) , } ) if err != nil { conn . Apps ( ) . Update ( bson . M { "name" : app . Name } , bson . M { "$pull" : bson . M { "teams" : team . Name } } ) return err } for _ , user := range users { err = repository . Manager ( ) . GrantAccess ( app . Name , user . Email ) if err != nil { conn . Apps ( ) . Update ( bson . M { "name" : app . Name } , bson . M { "$pull" : bson . M { "teams" : team . Name } } ) return err } } return nil }
4128	func ( app * App ) Revoke ( team * authTypes . Team ) error { if len ( app . Teams ) == 1 { return ErrCannotOrphanApp } index , found := app . findTeam ( team ) if ! found { return ErrNoAccess } last := len ( app . Teams ) - 1 app . Teams [ index ] = app . Teams [ last ] app . Teams = app . Teams [ : last ] conn , err := db . Conn ( ) if err != nil { return err } defer conn . Close ( ) err = conn . Apps ( ) . Update ( bson . M { "name" : app . Name } , bson . M { "$pull" : bson . M { "teams" : team . Name } } ) if err != nil { return err } users , err := auth . ListUsersWithPermissions ( permission . Permission { Scheme : permission . PermAppDeploy , Context : permission . Context ( permTypes . CtxTeam , team . Name ) , } ) if err != nil { conn . Apps ( ) . Update ( bson . M { "name" : app . Name } , bson . M { "$addToSet" : bson . M { "teams" : team . Name } } ) return err } for _ , user := range users { perms , err := user . Permissions ( ) if err != nil { conn . Apps ( ) . Update ( bson . M { "name" : app . Name } , bson . M { "$addToSet" : bson . M { "teams" : team . Name } } ) return err } canDeploy := permission . CheckFromPermList ( perms , permission . PermAppDeploy , append ( permission . Contexts ( permTypes . CtxTeam , app . Teams ) , permission . Context ( permTypes . CtxApp , app . Name ) , permission . Context ( permTypes . CtxPool , app . Pool ) , ) ... , ) if canDeploy { continue } err = repository . Manager ( ) . RevokeAccess ( app . Name , user . Email ) if err != nil { conn . Apps ( ) . Update ( bson . M { "name" : app . Name } , bson . M { "$addToSet" : bson . M { "teams" : team . Name } } ) return err } } return nil }
4129	func ( app * App ) GetTeams ( ) [ ] authTypes . Team { t , _ := servicemanager . Team . FindByNames ( app . Teams ) return t }
4130	func ( app * App ) setEnv ( env bind . EnvVar ) { if app . Env == nil { app . Env = make ( map [ string ] bind . EnvVar ) } app . Env [ env . Name ] = env if env . Public { app . Log ( fmt . Sprintf ( "setting env %s with value %s" , env . Name , env . Value ) , "tsuru" , "api" ) } }
4131	func ( app * App ) getEnv ( name string ) ( bind . EnvVar , error ) { if env , ok := app . Env [ name ] ; ok { return env , nil } return bind . EnvVar { } , errors . New ( "Environment variable not declared for this app." ) }
4132	func ( app * App ) validateNew ( ) error { if app . Name == InternalAppName || ! validation . ValidateName ( app . Name ) { msg := "Invalid app name, your app should have at most 40 " + "characters, containing only lower case letters, numbers or dashes, " + "starting with a letter." return & tsuruErrors . ValidationError { Message : msg } } return app . validate ( ) }
4133	func ( app * App ) validate ( ) error { err := app . validatePool ( ) if err != nil { return err } return app . validatePlan ( ) }
4134	func ( app * App ) InstanceEnvs ( serviceName , instanceName string ) map [ string ] bind . EnvVar { envs := make ( map [ string ] bind . EnvVar ) for _ , env := range app . ServiceEnvs { if env . ServiceName == serviceName && env . InstanceName == instanceName { envs [ env . Name ] = env . EnvVar } } return envs }
4135	func ( app * App ) Run ( cmd string , w io . Writer , args provision . RunArgs ) error { if ! args . Isolated && ! app . available ( ) { return errors . New ( "App must be available to run non-isolated commands" ) } app . Log ( fmt . Sprintf ( "running '%s'" , cmd ) , "tsuru" , "api" ) logWriter := LogWriter { App : app , Source : "app-run" } logWriter . Async ( ) defer logWriter . Close ( ) return app . run ( cmd , io . MultiWriter ( w , & logWriter ) , args ) }
4136	func ( app * App ) GetUnits ( ) ( [ ] bind . Unit , error ) { provUnits , err := app . Units ( ) if err != nil { return nil , err } units := make ( [ ] bind . Unit , len ( provUnits ) ) for i := range provUnits { units [ i ] = & provUnits [ i ] } return units , nil }
4137	func ( app * App ) GetUUID ( ) ( string , error ) { if app . UUID != "" { return app . UUID , nil } uuidV4 , err := uuid . NewV4 ( ) if err != nil { return "" , errors . WithMessage ( err , "failed to generate uuid v4" ) } conn , err := db . Conn ( ) if err != nil { return "" , err } defer conn . Close ( ) err = conn . Apps ( ) . Update ( bson . M { "name" : app . Name } , bson . M { "$set" : bson . M { "uuid" : uuidV4 . String ( ) } } ) if err != nil { return "" , err } app . UUID = uuidV4 . String ( ) return app . UUID , nil }
4138	func ( app * App ) Envs ( ) map [ string ] bind . EnvVar { mergedEnvs := make ( map [ string ] bind . EnvVar , len ( app . Env ) + len ( app . ServiceEnvs ) + 1 ) for _ , e := range app . Env { mergedEnvs [ e . Name ] = e } for _ , e := range app . ServiceEnvs { mergedEnvs [ e . Name ] = e . EnvVar } mergedEnvs [ TsuruServicesEnvVar ] = serviceEnvsFromEnvVars ( app . ServiceEnvs ) return mergedEnvs }
4139	func ( app * App ) SetEnvs ( setEnvs bind . SetEnvArgs ) error { if len ( setEnvs . Envs ) == 0 { return nil } for _ , env := range setEnvs . Envs { err := validateEnv ( env . Name ) if err != nil { return err } } if setEnvs . Writer != nil { fmt . Fprintf ( setEnvs . Writer , "---- Setting %d new environment variables ----\n" , \n ) } len ( setEnvs . Envs ) for _ , env := range setEnvs . Envs { app . setEnv ( env ) } conn , err := db . Conn ( ) if err != nil { return err } defer conn . Close ( ) err = conn . Apps ( ) . Update ( bson . M { "name" : app . Name } , bson . M { "$set" : bson . M { "env" : app . Env } } ) if err != nil { return err } if setEnvs . ShouldRestart { return app . restartIfUnits ( setEnvs . Writer ) } }
4140	func ( app * App ) UnsetEnvs ( unsetEnvs bind . UnsetEnvArgs ) error { if len ( unsetEnvs . VariableNames ) == 0 { return nil } if unsetEnvs . Writer != nil { fmt . Fprintf ( unsetEnvs . Writer , "---- Unsetting %d environment variables ----\n" , \n ) } len ( unsetEnvs . VariableNames ) for _ , name := range unsetEnvs . VariableNames { delete ( app . Env , name ) } conn , err := db . Conn ( ) if err != nil { return err } defer conn . Close ( ) err = conn . Apps ( ) . Update ( bson . M { "name" : app . Name } , bson . M { "$set" : bson . M { "env" : app . Env } } ) if err != nil { return err } if unsetEnvs . ShouldRestart { return app . restartIfUnits ( unsetEnvs . Writer ) } }
4141	func ( app * App ) AddCName ( cnames ... string ) error { actions := [ ] * action . Action { & validateNewCNames , & setNewCNamesToProvisioner , & saveCNames , & updateApp , } err := action . NewPipeline ( actions ... ) . Execute ( app , cnames ) rebuild . RoutesRebuildOrEnqueue ( app . Name ) return err }
4142	func ( app * App ) Log ( message , source , unit string ) error { messages := strings . Split ( message , "\n" ) \n logs := make ( [ ] interface { } , 0 , len ( messages ) ) for _ , msg := range messages { if msg != "" { l := Applog { Date : time . Now ( ) . In ( time . UTC ) , Message : msg , Source : source , AppName : app . Name , Unit : unit , } logs = append ( logs , l ) } } if len ( logs ) > 0 { conn , err := db . LogConn ( ) if err != nil { return err } defer conn . Close ( ) return conn . AppLogCollection ( app . Name ) . Insert ( logs ... ) } }
4143	func ( app * App ) LastLogs ( lines int , filterLog Applog ) ( [ ] Applog , error ) { return app . lastLogs ( lines , filterLog , false ) }
4144	func List ( filter * Filter ) ( [ ] App , error ) { apps := [ ] App { } query := filter . Query ( ) conn , err := db . Conn ( ) if err != nil { return nil , err } err = conn . Apps ( ) . Find ( query ) . All ( & apps ) conn . Close ( ) if err != nil { return nil , err } if filter != nil && len ( filter . Statuses ) > 0 { appsProvisionerMap := make ( map [ string ] [ ] provision . App ) var prov provision . Provisioner for i := range apps { a := & apps [ i ] prov , err = a . getProvisioner ( ) if err != nil { return nil , err } appsProvisionerMap [ prov . GetName ( ) ] = append ( appsProvisionerMap [ prov . GetName ( ) ] , a ) } var provisionApps [ ] provision . App for provName , apps := range appsProvisionerMap { prov , err = provision . Get ( provName ) if err != nil { return nil , err } if filterProv , ok := prov . ( provision . AppFilterProvisioner ) ; ok { apps , err = filterProv . FilterAppsByUnitStatus ( apps , filter . Statuses ) if err != nil { return nil , err } } provisionApps = append ( provisionApps , apps ... ) } for i := range provisionApps { apps [ i ] = * ( provisionApps [ i ] . ( * App ) ) } apps = apps [ : len ( provisionApps ) ] } err = loadCachedAddrsInApps ( apps ) if err != nil { return nil , err } return apps , nil }
4145	func Swap ( app1 , app2 * App , cnameOnly bool ) error { a1Routers := app1 . GetRouters ( ) a2Routers := app2 . GetRouters ( ) if len ( a1Routers ) != 1 || len ( a2Routers ) != 1 { return errors . New ( "swapping apps with multiple routers is not supported" ) } r1 , err := router . Get ( a1Routers [ 0 ] . Name ) if err != nil { return err } r2 , err := router . Get ( a2Routers [ 0 ] . Name ) if err != nil { return err } defer func ( app1 , app2 * App ) { rebuild . RoutesRebuildOrEnqueue ( app1 . Name ) rebuild . RoutesRebuildOrEnqueue ( app2 . Name ) app1 . GetRoutersWithAddr ( ) app2 . GetRoutersWithAddr ( ) } ( app1 , app2 ) err = r1 . Swap ( app1 . Name , app2 . Name , cnameOnly ) if err != nil { return err } conn , err := db . Conn ( ) if err != nil { return err } defer conn . Close ( ) app1 . CName , app2 . CName = app2 . CName , app1 . CName updateCName := func ( app * App , r router . Router ) error { return conn . Apps ( ) . Update ( bson . M { "name" : app . Name } , bson . M { "$set" : bson . M { "cname" : app . CName } } , ) } err = updateCName ( app1 , r1 ) if err != nil { return err } return updateCName ( app2 , r2 ) }
4146	func ( app * App ) Start ( w io . Writer , process string ) error { w = app . withLogWriter ( w ) msg := fmt . Sprintf ( "\n - , \n ) process if process == "" { msg = fmt . Sprintf ( "\n - , \n ) } app . Name fmt . Fprintf ( w , "%s\n" , \n ) msg prov , err := app . getProvisioner ( ) if err != nil { return err } err = prov . Start ( app , process ) }
4147	func GetDbDriver ( name string ) ( * DbDriver , error ) { driver , ok := dbDrivers [ name ] if ! ok { return nil , errors . Errorf ( "Unknown database driver: %q." , name ) } return & driver , nil }
4148	func GetCurrentDbDriver ( ) ( * DbDriver , error ) { driverLock . RLock ( ) if currentDbDriver != nil { driverLock . RUnlock ( ) return currentDbDriver , nil } driverLock . RUnlock ( ) driverLock . Lock ( ) defer driverLock . Unlock ( ) if currentDbDriver != nil { return currentDbDriver , nil } dbDriverName , err := config . GetString ( "database:driver" ) if err != nil || dbDriverName == "" { dbDriverName = DefaultDbDriverName } currentDbDriver , err = GetDbDriver ( dbDriverName ) if err != nil { return nil , err } return currentDbDriver , nil }
4149	func NewForConfig ( c * rest . Config ) ( * Clientset , error ) { configShallowCopy := * c if configShallowCopy . RateLimiter == nil && configShallowCopy . QPS > 0 { configShallowCopy . RateLimiter = flowcontrol . NewTokenBucketRateLimiter ( configShallowCopy . QPS , configShallowCopy . Burst ) } var cs Clientset var err error cs . tsuruV1 , err = tsuruv1 . NewForConfig ( & configShallowCopy ) if err != nil { return nil , err } cs . DiscoveryClient , err = discovery . NewDiscoveryClientForConfig ( & configShallowCopy ) if err != nil { glog . Errorf ( "failed to create the DiscoveryClient: %v" , err ) return nil , err } return & cs , nil }
4150	func ( p * dockerProvisioner ) GetAppFromUnitID ( unitID string ) ( provision . App , error ) { cnt , err := p . GetContainer ( unitID ) if err != nil { return nil , err } a , err := app . GetByName ( cnt . AppName ) if err != nil { return nil , err } return a , nil }
4151	func NewPipeline ( actions ... * Action ) * Pipeline { newActions := make ( [ ] * Action , len ( actions ) ) for i , action := range actions { newAction := & Action { Name : action . Name , Forward : action . Forward , Backward : action . Backward , MinParams : action . MinParams , OnError : action . OnError , } newActions [ i ] = newAction } return & Pipeline { actions : newActions } }
4152	func ( p * Pipeline ) Result ( ) Result { action := p . actions [ len ( p . actions ) - 1 ] action . rMutex . Lock ( ) defer action . rMutex . Unlock ( ) return action . result }
4153	func ( r * Request ) DecodeJsonPayload ( v interface { } ) error { content , err := ioutil . ReadAll ( r . Body ) r . Body . Close ( ) if err != nil { return err } if len ( content ) == 0 { return ErrJsonPayloadEmpty } err = json . Unmarshal ( content , v ) if err != nil { return err } return nil }
4154	func ( r * Request ) UrlFor ( path string , queryParams map [ string ] [ ] string ) * url . URL { baseUrl := r . BaseUrl ( ) baseUrl . Path = path if queryParams != nil { query := url . Values { } for k , v := range queryParams { for _ , vv := range v { query . Add ( k , vv ) } } baseUrl . RawQuery = query . Encode ( ) } return baseUrl }
4155	func ( r * Request ) GetCorsInfo ( ) * CorsInfo { origin := r . Header . Get ( "Origin" ) var originUrl * url . URL var isCors bool if origin == "" { isCors = false } else if origin == "null" { isCors = true } else { var err error originUrl , err = url . ParseRequestURI ( origin ) isCors = err == nil && r . Host != originUrl . Host } reqMethod := r . Header . Get ( "Access-Control-Request-Method" ) reqHeaders := [ ] string { } rawReqHeaders := r . Header [ http . CanonicalHeaderKey ( "Access-Control-Request-Headers" ) ] for _ , rawReqHeader := range rawReqHeaders { if len ( rawReqHeader ) == 0 { continue } for _ , reqHeader := range strings . Split ( rawReqHeader , "," ) { reqHeaders = append ( reqHeaders , http . CanonicalHeaderKey ( strings . TrimSpace ( reqHeader ) ) ) } } isPreflight := isCors && r . Method == "OPTIONS" && reqMethod != "" return & CorsInfo { IsCors : isCors , IsPreflight : isPreflight , Origin : origin , OriginUrl : originUrl , AccessControlRequestMethod : strings . ToUpper ( reqMethod ) , AccessControlRequestHeaders : reqHeaders , } }
4156	func ( mw * CorsMiddleware ) MiddlewareFunc ( handler HandlerFunc ) HandlerFunc { mw . allowedMethods = map [ string ] bool { } normedMethods := [ ] string { } for _ , allowedMethod := range mw . AllowedMethods { normed := strings . ToUpper ( allowedMethod ) mw . allowedMethods [ normed ] = true normedMethods = append ( normedMethods , normed ) } mw . allowedMethodsCsv = strings . Join ( normedMethods , "," ) mw . allowedHeaders = map [ string ] bool { } normedHeaders := [ ] string { } for _ , allowedHeader := range mw . AllowedHeaders { normed := http . CanonicalHeaderKey ( allowedHeader ) mw . allowedHeaders [ normed ] = true normedHeaders = append ( normedHeaders , normed ) } mw . allowedHeadersCsv = strings . Join ( normedHeaders , "," ) return func ( writer ResponseWriter , request * Request ) { corsInfo := request . GetCorsInfo ( ) if ! corsInfo . IsCors { if mw . RejectNonCorsRequests { Error ( writer , "Non CORS request" , http . StatusForbidden ) return } handler ( writer , request ) return } if mw . OriginValidator ( corsInfo . Origin , request ) == false { Error ( writer , "Invalid Origin" , http . StatusForbidden ) return } if corsInfo . IsPreflight { if mw . allowedMethods [ corsInfo . AccessControlRequestMethod ] == false { Error ( writer , "Invalid Preflight Request" , http . StatusForbidden ) return } for _ , requestedHeader := range corsInfo . AccessControlRequestHeaders { if mw . allowedHeaders [ requestedHeader ] == false { Error ( writer , "Invalid Preflight Request" , http . StatusForbidden ) return } } writer . Header ( ) . Set ( "Access-Control-Allow-Methods" , mw . allowedMethodsCsv ) writer . Header ( ) . Set ( "Access-Control-Allow-Headers" , mw . allowedHeadersCsv ) writer . Header ( ) . Set ( "Access-Control-Allow-Origin" , corsInfo . Origin ) if mw . AccessControlAllowCredentials == true { writer . Header ( ) . Set ( "Access-Control-Allow-Credentials" , "true" ) } writer . Header ( ) . Set ( "Access-Control-Max-Age" , strconv . Itoa ( mw . AccessControlMaxAge ) ) writer . WriteHeader ( http . StatusOK ) return } for _ , exposed := range mw . AccessControlExposeHeaders { writer . Header ( ) . Add ( "Access-Control-Expose-Headers" , exposed ) } writer . Header ( ) . Set ( "Access-Control-Allow-Origin" , corsInfo . Origin ) if mw . AccessControlAllowCredentials == true { writer . Header ( ) . Set ( "Access-Control-Allow-Credentials" , "true" ) } handler ( writer , request ) return } }
4157	func ( mw * RecorderMiddleware ) MiddlewareFunc ( h HandlerFunc ) HandlerFunc { return func ( w ResponseWriter , r * Request ) { writer := & recorderResponseWriter { w , 0 , false , 0 } h ( writer , r ) r . Env [ "STATUS_CODE" ] = writer . statusCode r . Env [ "BYTES_WRITTEN" ] = writer . bytesWritten } }
4158	func ( w * recorderResponseWriter ) WriteHeader ( code int ) { w . ResponseWriter . WriteHeader ( code ) if w . wroteHeader { return } w . statusCode = code w . wroteHeader = true }
4159	func MakeRouter ( routes ... * Route ) ( App , error ) { r := & router { Routes : routes , } err := r . start ( ) if err != nil { return nil , err } return r , nil }
4160	func ( rt * router ) AppFunc ( ) HandlerFunc { return func ( writer ResponseWriter , request * Request ) { route , params , pathMatched := rt . findRouteFromURL ( request . Method , request . URL ) if route == nil { if pathMatched { Error ( writer , "Method not allowed" , http . StatusMethodNotAllowed ) return } NotFound ( writer , request ) return } request . PathParams = params handler := route . Func handler ( writer , request ) } }
4161	func escapedPath ( urlObj * url . URL ) string { parts := strings . SplitN ( urlObj . RequestURI ( ) , "?" , 2 ) return parts [ 0 ] }
4162	func escapedPathExp ( pathExp string ) ( string , error ) { if pathExp == "" { return "" , errors . New ( "empty PathExp" ) } if pathExp [ 0 ] != '/' { return "" , errors . New ( "PathExp must start with /" ) } if strings . Contains ( pathExp , "?" ) { return "" , errors . New ( "PathExp must not contain the query string" ) } pathExp = preEscape . Replace ( pathExp ) urlObj , err := url . Parse ( pathExp ) if err != nil { return "" , err } pathExp = urlObj . RequestURI ( ) pathExp = postEscape . Replace ( pathExp ) return pathExp , nil }
4163	func ( rt * router ) start ( ) error { rt . trie = trie . New ( ) rt . index = map [ * Route ] int { } for i , route := range rt . Routes { pathExp , err := escapedPathExp ( route . PathExp ) if err != nil { return err } err = rt . trie . AddRoute ( strings . ToUpper ( route . HttpMethod ) , pathExp , route , ) if err != nil { return err } rt . index [ route ] = i } if rt . disableTrieCompression == false { rt . trie . Compress ( ) } return nil }
4164	func ( rt * router ) ofFirstDefinedRoute ( matches [ ] * trie . Match ) * trie . Match { minIndex := - 1 var bestMatch * trie . Match for _ , result := range matches { route := result . Route . ( * Route ) routeIndex := rt . index [ route ] if minIndex == - 1 || routeIndex < minIndex { minIndex = routeIndex bestMatch = result } } return bestMatch }
4165	func ( rt * router ) findRouteFromURL ( httpMethod string , urlObj * url . URL ) ( * Route , map [ string ] string , bool ) { matches , pathMatched := rt . trie . FindRoutesAndPathMatched ( strings . ToUpper ( httpMethod ) , escapedPath ( urlObj ) , ) if len ( matches ) == 0 { return nil , nil , pathMatched } if len ( matches ) == 1 { return matches [ 0 ] . Route . ( * Route ) , matches [ 0 ] . Params , pathMatched } result := rt . ofFirstDefinedRoute ( matches ) return result . Route . ( * Route ) , result . Params , pathMatched }
4166	func ( mw * ContentTypeCheckerMiddleware ) MiddlewareFunc ( handler HandlerFunc ) HandlerFunc { return func ( w ResponseWriter , r * Request ) { mediatype , params , _ := mime . ParseMediaType ( r . Header . Get ( "Content-Type" ) ) charset , ok := params [ "charset" ] if ! ok { charset = "UTF-8" } if r . ContentLength > 0 && ! ( mediatype == "application/json" && strings . ToUpper ( charset ) == "UTF-8" ) { Error ( w , "Bad Content-Type or charset, expected 'application/json'" , http . StatusUnsupportedMediaType , ) return } handler ( w , r ) } }
4167	func ( w * responseWriter ) CloseNotify ( ) <- chan bool { notifier := w . ResponseWriter . ( http . CloseNotifier ) return notifier . CloseNotify ( ) }
4168	func ( mw * AccessLogApacheMiddleware ) MiddlewareFunc ( h HandlerFunc ) HandlerFunc { if mw . Logger == nil { mw . Logger = log . New ( os . Stderr , "" , 0 ) } if mw . Format == "" { mw . Format = DefaultLogFormat } mw . convertFormat ( ) return func ( w ResponseWriter , r * Request ) { h ( w , r ) util := & accessLogUtil { w , r } mw . Logger . Print ( mw . executeTextTemplate ( util ) ) } }
4169	func ( mw * AccessLogApacheMiddleware ) executeTextTemplate ( util * accessLogUtil ) string { buf := bytes . NewBufferString ( "" ) err := mw . textTemplate . Execute ( buf , util ) if err != nil { panic ( err ) } return buf . String ( ) }
4170	func ( u * accessLogUtil ) RemoteUser ( ) string { if u . R . Env [ "REMOTE_USER" ] != nil { return u . R . Env [ "REMOTE_USER" ] . ( string ) } return "" }
4171	func ( u * accessLogUtil ) ApacheQueryString ( ) string { if u . R . URL . RawQuery != "" { return "?" + u . R . URL . RawQuery } return "" }
4172	func ( u * accessLogUtil ) StartTime ( ) * time . Time { if u . R . Env [ "START_TIME" ] != nil { return u . R . Env [ "START_TIME" ] . ( * time . Time ) } return nil }
4173	func ( u * accessLogUtil ) ApacheRemoteAddr ( ) string { remoteAddr := u . R . RemoteAddr if remoteAddr != "" { if ip , _ , err := net . SplitHostPort ( remoteAddr ) ; err == nil { return ip } } return "" }
4174	func ( u * accessLogUtil ) ResponseTime ( ) * time . Duration { if u . R . Env [ "ELAPSED_TIME" ] != nil { return u . R . Env [ "ELAPSED_TIME" ] . ( * time . Duration ) } return nil }
4175	func ( mw * JsonIndentMiddleware ) MiddlewareFunc ( handler HandlerFunc ) HandlerFunc { if mw . Indent == "" { mw . Indent = " " } return func ( w ResponseWriter , r * Request ) { writer := & jsonIndentResponseWriter { w , false , mw . Prefix , mw . Indent } handler ( writer , r ) } }
4176	func ( w * jsonIndentResponseWriter ) EncodeJson ( v interface { } ) ( [ ] byte , error ) { b , err := json . MarshalIndent ( v , w . prefix , w . indent ) if err != nil { return nil , err } return b , nil }
4177	func ( w * jsonIndentResponseWriter ) WriteHeader ( code int ) { w . ResponseWriter . WriteHeader ( code ) w . wroteHeader = true }
4178	func ( route * Route ) MakePath ( pathParams map [ string ] string ) string { path := route . PathExp for paramName , paramValue := range pathParams { paramPlaceholder := ":" + paramName relaxedPlaceholder := "#" + paramName splatPlaceholder := "*" + paramName r := strings . NewReplacer ( paramPlaceholder , paramValue , splatPlaceholder , paramValue , relaxedPlaceholder , paramValue ) path = r . Replace ( path ) } return path }
4179	func ( mw * RecoverMiddleware ) MiddlewareFunc ( h HandlerFunc ) HandlerFunc { if mw . Logger == nil { mw . Logger = log . New ( os . Stderr , "" , 0 ) } return func ( w ResponseWriter , r * Request ) { defer func ( ) { if reco := recover ( ) ; reco != nil { trace := debug . Stack ( ) message := fmt . Sprintf ( "%s\n%s" , \n , reco ) trace mw . logError ( message ) } } if mw . EnableResponseStackTrace { Error ( w , message , http . StatusInternalServerError ) } else { Error ( w , "Internal Server Error" , http . StatusInternalServerError ) } ( ) } }
4180	func WrapMiddlewares ( middlewares [ ] Middleware , handler HandlerFunc ) HandlerFunc { wrapped := handler for i := len ( middlewares ) - 1 ; i >= 0 ; i -- { wrapped = middlewares [ i ] . MiddlewareFunc ( wrapped ) } return wrapped }
4181	func ( mw * GzipMiddleware ) MiddlewareFunc ( h HandlerFunc ) HandlerFunc { return func ( w ResponseWriter , r * Request ) { canGzip := strings . Contains ( r . Header . Get ( "Accept-Encoding" ) , "gzip" ) writer := & gzipResponseWriter { w , false , canGzip , nil } defer func ( ) { if writer . gzipWriter != nil { writer . gzipWriter . Close ( ) } } ( ) h ( writer , r ) } }
4182	func ( w * gzipResponseWriter ) WriteHeader ( code int ) { w . Header ( ) . Add ( "Vary" , "Accept-Encoding" ) if w . canGzip { w . Header ( ) . Set ( "Content-Encoding" , "gzip" ) } w . ResponseWriter . WriteHeader ( code ) w . wroteHeader = true }
4183	func ( w * gzipResponseWriter ) Hijack ( ) ( net . Conn , * bufio . ReadWriter , error ) { hijacker := w . ResponseWriter . ( http . Hijacker ) return hijacker . Hijack ( ) }
4184	func ( w * gzipResponseWriter ) Write ( b [ ] byte ) ( int , error ) { if ! w . wroteHeader { w . WriteHeader ( http . StatusOK ) } writer := w . ResponseWriter . ( http . ResponseWriter ) if w . canGzip { if w . gzipWriter == nil { w . gzipWriter = gzip . NewWriter ( writer ) } count , errW := w . gzipWriter . Write ( b ) errF := w . gzipWriter . Flush ( ) if errW != nil { return count , errW } if errF != nil { return count , errF } return count , nil } return writer . Write ( b ) }
4185	func ( mw * AuthBasicMiddleware ) MiddlewareFunc ( handler HandlerFunc ) HandlerFunc { if mw . Realm == "" { log . Fatal ( "Realm is required" ) } if mw . Authenticator == nil { log . Fatal ( "Authenticator is required" ) } if mw . Authorizator == nil { mw . Authorizator = func ( userId string , request * Request ) bool { return true } } return func ( writer ResponseWriter , request * Request ) { authHeader := request . Header . Get ( "Authorization" ) if authHeader == "" { mw . unauthorized ( writer ) return } providedUserId , providedPassword , err := mw . decodeBasicAuthHeader ( authHeader ) if err != nil { Error ( writer , "Invalid authentication" , http . StatusBadRequest ) return } if ! mw . Authenticator ( providedUserId , providedPassword ) { mw . unauthorized ( writer ) return } if ! mw . Authorizator ( providedUserId , request ) { mw . unauthorized ( writer ) return } request . Env [ "REMOTE_USER" ] = providedUserId handler ( writer , request ) } }
4186	func ( n * node ) printDebug ( level int ) { level ++ if n . SplatChild != nil { printFPadding ( level , "*splat\n" ) \n } n . SplatChild . printDebug ( level ) if n . ParamChild != nil { printFPadding ( level , ":param\n" ) \n } n . ParamChild . printDebug ( level ) }
4187	func ( t * Trie ) AddRoute ( httpMethod , pathExp string , route interface { } ) error { return t . root . addRoute ( httpMethod , pathExp , route , [ ] string { } ) }
4188	func ( t * Trie ) printDebug ( ) { fmt . Print ( "<trie>\n" ) \n t . root . printDebug ( 0 ) }
4189	func ( t * Trie ) FindRoutes ( httpMethod , path string ) [ ] * Match { context := newFindContext ( ) matches := [ ] * Match { } context . matchFunc = func ( httpMethod , path string , node * node ) { if node . HttpMethodToRoute [ httpMethod ] != nil { matches = append ( matches , & Match { Route : node . HttpMethodToRoute [ httpMethod ] , Params : context . paramsAsMap ( ) , } , ) } } t . root . find ( httpMethod , path , context ) return matches }
4190	func ( t * Trie ) FindRoutesAndPathMatched ( httpMethod , path string ) ( [ ] * Match , bool ) { context := newFindContext ( ) pathMatched := false matches := [ ] * Match { } context . matchFunc = func ( httpMethod , path string , node * node ) { pathMatched = true if node . HttpMethodToRoute [ httpMethod ] != nil { matches = append ( matches , & Match { Route : node . HttpMethodToRoute [ httpMethod ] , Params : context . paramsAsMap ( ) , } , ) } } t . root . find ( httpMethod , path , context ) return matches , pathMatched }
4191	func ( t * Trie ) FindRoutesForPath ( path string ) [ ] * Match { context := newFindContext ( ) matches := [ ] * Match { } context . matchFunc = func ( httpMethod , path string , node * node ) { params := context . paramsAsMap ( ) for _ , route := range node . HttpMethodToRoute { matches = append ( matches , & Match { Route : route , Params : params , } , ) } } t . root . find ( "" , path , context ) return matches }
4192	func ( api * Api ) Use ( middlewares ... Middleware ) { api . stack = append ( api . stack , middlewares ... ) }
4193	func ( api * Api ) MakeHandler ( ) http . Handler { var appFunc HandlerFunc if api . app != nil { appFunc = api . app . AppFunc ( ) } else { appFunc = func ( w ResponseWriter , r * Request ) { } } return http . HandlerFunc ( adapterFunc ( WrapMiddlewares ( api . stack , appFunc ) , ) , ) }
4194	func ( mw * PoweredByMiddleware ) MiddlewareFunc ( h HandlerFunc ) HandlerFunc { poweredBy := xPoweredByDefault if mw . XPoweredBy != "" { poweredBy = mw . XPoweredBy } return func ( w ResponseWriter , r * Request ) { w . Header ( ) . Add ( "X-Powered-By" , poweredBy ) h ( w , r ) } }
4195	func ( mw * StatusMiddleware ) MiddlewareFunc ( h HandlerFunc ) HandlerFunc { mw . start = time . Now ( ) mw . pid = os . Getpid ( ) mw . responseCounts = map [ string ] int { } mw . totalResponseTime = time . Time { } return func ( w ResponseWriter , r * Request ) { h ( w , r ) if r . Env [ "STATUS_CODE" ] == nil { log . Fatal ( "StatusMiddleware: Env[\"STATUS_CODE\"] is nil, " + \" ) } \" "RecorderMiddleware may not be in the wrapped Middlewares." statusCode := r . Env [ "STATUS_CODE" ] . ( int ) if r . Env [ "ELAPSED_TIME" ] == nil { log . Fatal ( "StatusMiddleware: Env[\"ELAPSED_TIME\"] is nil, " + \" ) } \" "TimerMiddleware may not be in the wrapped Middlewares." responseTime := r . Env [ "ELAPSED_TIME" ] . ( * time . Duration ) } }
4196	func ( mw * StatusMiddleware ) GetStatus ( ) * Status { mw . lock . RLock ( ) now := time . Now ( ) uptime := now . Sub ( mw . start ) totalCount := 0 for _ , count := range mw . responseCounts { totalCount += count } totalResponseTime := mw . totalResponseTime . Sub ( time . Time { } ) averageResponseTime := time . Duration ( 0 ) if totalCount > 0 { avgNs := int64 ( totalResponseTime ) / int64 ( totalCount ) averageResponseTime = time . Duration ( avgNs ) } status := & Status { Pid : mw . pid , UpTime : uptime . String ( ) , UpTimeSec : uptime . Seconds ( ) , Time : now . String ( ) , TimeUnix : now . Unix ( ) , StatusCodeCount : mw . responseCounts , TotalCount : totalCount , TotalResponseTime : totalResponseTime . String ( ) , TotalResponseTimeSec : totalResponseTime . Seconds ( ) , AverageResponseTime : averageResponseTime . String ( ) , AverageResponseTimeSec : averageResponseTime . Seconds ( ) , } mw . lock . RUnlock ( ) return status }
4197	func ( mw * JsonpMiddleware ) MiddlewareFunc ( h HandlerFunc ) HandlerFunc { if mw . CallbackNameKey == "" { mw . CallbackNameKey = "callback" } return func ( w ResponseWriter , r * Request ) { callbackName := r . URL . Query ( ) . Get ( mw . CallbackNameKey ) if callbackName != "" { writer := & jsonpResponseWriter { w , false , callbackName } h ( writer , r ) } else { h ( w , r ) } } }
4198	func ( w * jsonpResponseWriter ) Flush ( ) { if ! w . wroteHeader { w . WriteHeader ( http . StatusOK ) } flusher := w . ResponseWriter . ( http . Flusher ) flusher . Flush ( ) }
4199	func ( mw * AccessLogJsonMiddleware ) MiddlewareFunc ( h HandlerFunc ) HandlerFunc { if mw . Logger == nil { mw . Logger = log . New ( os . Stderr , "" , 0 ) } return func ( w ResponseWriter , r * Request ) { h ( w , r ) mw . Logger . Printf ( "%s" , makeAccessLogJsonRecord ( r ) . asJson ( ) ) } }
4200	func ( s * S3 ) Fetch ( ) ( io . Reader , error ) { if s . delay { time . Sleep ( s . Interval ) } s . delay = true head , err := s . client . HeadObject ( & s3 . HeadObjectInput { Bucket : & s . Bucket , Key : & s . Key } ) if err != nil { return nil , fmt . Errorf ( "HEAD request failed (%s)" , err ) } if s . lastETag == * head . ETag { return nil , nil } s . lastETag = * head . ETag get , err := s . client . GetObject ( & s3 . GetObjectInput { Bucket : & s . Bucket , Key : & s . Key } ) if err != nil { return nil , fmt . Errorf ( "GET request failed (%s)" , err ) } if strings . HasSuffix ( s . Key , ".gz" ) && aws . StringValue ( get . ContentEncoding ) != "gzip" { return gzip . NewReader ( get . Body ) } return get . Body , nil }
4201	func sanityCheck ( ) bool { if token := os . Getenv ( envBinCheck ) ; token != "" { fmt . Fprint ( os . Stdout , token ) return true } if token := os . Getenv ( envBinCheckLegacy ) ; token != "" { fmt . Fprint ( os . Stdout , token ) return true } return false }
4202	func ( l * overseerListener ) release ( timeout time . Duration ) { l . closeError = l . Listener . Close ( ) waited := make ( chan bool ) go func ( ) { l . wg . Wait ( ) waited <- true } ( ) go func ( ) { select { case <- time . After ( timeout ) : close ( l . closeByForce ) case <- waited : } } ( ) }
4203	func ( mp * master ) fetchLoop ( ) { min := mp . Config . MinFetchInterval time . Sleep ( min ) for { t0 := time . Now ( ) mp . fetch ( ) diff := time . Now ( ) . Sub ( t0 ) if diff < min { delay := min - diff time . Sleep ( delay ) } } }
4204	func ( mp * master ) forkLoop ( ) error { for { if err := mp . fork ( ) ; err != nil { return err } } }
4205	func ( f * File ) Init ( ) error { if f . Path == "" { return fmt . Errorf ( "Path required" ) } if f . Interval < 1 * time . Second { f . Interval = 1 * time . Second } if err := f . updateHash ( ) ; err != nil { return err } return nil }
4206	func ( f * File ) Fetch ( ) ( io . Reader , error ) { if f . delay { time . Sleep ( f . Interval ) } f . delay = true lastHash := f . hash if err := f . updateHash ( ) ; err != nil { return nil , err } if lastHash == f . hash { return nil , nil } file , err := os . Open ( f . Path ) if err != nil { return nil , err } const rate = 250 * time . Millisecond const total = int ( 5 * time . Second / rate ) attempt := 1 for { if attempt == total { file . Close ( ) return nil , errors . New ( "file is currently being changed" ) } attempt ++ time . Sleep ( rate ) if err := f . updateHash ( ) ; err != nil { file . Close ( ) return nil , err } if lastHash == f . hash { break } lastHash = f . hash } return file , nil }
4207	func ( h * HTTP ) Fetch ( ) ( io . Reader , error ) { if h . delay { time . Sleep ( h . Interval ) } h . delay = true resp , err := http . Head ( h . URL ) if err != nil { return nil , fmt . Errorf ( "HEAD request failed (%s)" , err ) } resp . Body . Close ( ) if resp . StatusCode != http . StatusOK { return nil , fmt . Errorf ( "HEAD request failed (status code %d)" , resp . StatusCode ) } matches , total := 0 , 0 for _ , header := range h . CheckHeaders { if curr := resp . Header . Get ( header ) ; curr != "" { if last , ok := h . lasts [ header ] ; ok && last == curr { matches ++ } h . lasts [ header ] = curr total ++ } } if matches == total { return nil , nil } resp , err = http . Get ( h . URL ) if err != nil { return nil , fmt . Errorf ( "GET request failed (%s)" , err ) } if resp . StatusCode != http . StatusOK { return nil , fmt . Errorf ( "GET request failed (status code %d)" , resp . StatusCode ) } if strings . HasSuffix ( h . URL , ".gz" ) && resp . Header . Get ( "Content-Encoding" ) != "gzip" { return gzip . NewReader ( resp . Body ) } return resp . Body , nil }
4208	func NewConfig ( ) * Config { c := & Config { Config : * sarama . NewConfig ( ) , } c . Group . PartitionStrategy = StrategyRange c . Group . Offsets . Retry . Max = 3 c . Group . Offsets . Synchronization . DwellTime = c . Consumer . MaxProcessingTime c . Group . Session . Timeout = 30 * time . Second c . Group . Heartbeat . Interval = 3 * time . Second c . Config . Version = minVersion return c }
4209	func ( c * Config ) Validate ( ) error { if c . Group . Heartbeat . Interval % time . Millisecond != 0 { sarama . Logger . Println ( "Group.Heartbeat.Interval only supports millisecond precision; nanoseconds will be truncated." ) } if c . Group . Session . Timeout % time . Millisecond != 0 { sarama . Logger . Println ( "Group.Session.Timeout only supports millisecond precision; nanoseconds will be truncated." ) } if c . Group . PartitionStrategy != StrategyRange && c . Group . PartitionStrategy != StrategyRoundRobin { sarama . Logger . Println ( "Group.PartitionStrategy is not supported; range will be assumed." ) } if ! c . Version . IsAtLeast ( minVersion ) { sarama . Logger . Println ( "Version is not supported; 0.9. will be assumed." ) c . Version = minVersion } if err := c . Config . Validate ( ) ; err != nil { return err } switch { case c . Group . Offsets . Retry . Max < 0 : return sarama . ConfigurationError ( "Group.Offsets.Retry.Max must be >= 0" ) case c . Group . Offsets . Synchronization . DwellTime <= 0 : return sarama . ConfigurationError ( "Group.Offsets.Synchronization.DwellTime must be > 0" ) case c . Group . Offsets . Synchronization . DwellTime > 10 * time . Minute : return sarama . ConfigurationError ( "Group.Offsets.Synchronization.DwellTime must be <= 10m" ) case c . Group . Heartbeat . Interval <= 0 : return sarama . ConfigurationError ( "Group.Heartbeat.Interval must be > 0" ) case c . Group . Session . Timeout <= 0 : return sarama . ConfigurationError ( "Group.Session.Timeout must be > 0" ) case ! c . Metadata . Full && c . Group . Topics . Whitelist != nil : return sarama . ConfigurationError ( "Metadata.Full must be enabled when Group.Topics.Whitelist is used" ) case ! c . Metadata . Full && c . Group . Topics . Blacklist != nil : return sarama . ConfigurationError ( "Metadata.Full must be enabled when Group.Topics.Blacklist is used" ) } switch c . Consumer . Offsets . Initial { case sarama . OffsetOldest , sarama . OffsetNewest : default : return sarama . ConfigurationError ( "Consumer.Offsets.Initial must be either OffsetOldest or OffsetNewest" ) } return nil }
4210	func NewClient ( addrs [ ] string , config * Config ) ( * Client , error ) { if config == nil { config = NewConfig ( ) } if err := config . Validate ( ) ; err != nil { return nil , err } client , err := sarama . NewClient ( addrs , & config . Config ) if err != nil { return nil , err } return & Client { Client : client , config : * config } , nil }
4211	func ( c * partitionConsumer ) AsyncClose ( ) { c . closeOnce . Do ( func ( ) { c . closeErr = c . PartitionConsumer . Close ( ) close ( c . dying ) } ) }
4212	func ( c * partitionConsumer ) Close ( ) error { c . AsyncClose ( ) <- c . dead return c . closeErr }
4213	func ( c * partitionConsumer ) MarkOffset ( offset int64 , metadata string ) { c . mu . Lock ( ) if next := offset + 1 ; next > c . state . Info . Offset { c . state . Info . Offset = next c . state . Info . Metadata = metadata c . state . Dirty = true } c . mu . Unlock ( ) }
4214	func NewConsumer ( addrs [ ] string , groupID string , topics [ ] string , config * Config ) ( * Consumer , error ) { client , err := NewClient ( addrs , config ) if err != nil { return nil , err } consumer , err := NewConsumerFromClient ( client , groupID , topics ) if err != nil { return nil , err } consumer . ownClient = true return consumer , nil }
4215	func ( c * Consumer ) MarkOffsets ( s * OffsetStash ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) for tp , info := range s . offsets { if sub := c . subs . Fetch ( tp . Topic , tp . Partition ) ; sub != nil { sub . MarkOffset ( info . Offset , info . Metadata ) } delete ( s . offsets , tp ) } }
4216	func ( c * Consumer ) ResetOffset ( msg * sarama . ConsumerMessage , metadata string ) { if sub := c . subs . Fetch ( msg . Topic , msg . Partition ) ; sub != nil { sub . ResetOffset ( msg . Offset , metadata ) } }
4217	func ( c * Consumer ) Close ( ) ( err error ) { c . closeOnce . Do ( func ( ) { close ( c . dying ) <- c . dead if e := c . release ( ) ; e != nil { err = e } if e := c . consumer . Close ( ) ; e != nil { err = e } close ( c . messages ) close ( c . errors ) if e := c . leaveGroup ( ) ; e != nil { err = e } close ( c . partitions ) close ( c . notifications ) for range c . messages { } for range c . errors { } for p := range c . partitions { _ = p . Close ( ) } for range c . notifications { } c . client . release ( ) if c . ownClient { if e := c . client . Close ( ) ; e != nil { err = e } } } ) return }
4218	func ( c * Consumer ) hbLoop ( stopped <- chan none ) { ticker := time . NewTicker ( c . client . config . Group . Heartbeat . Interval ) defer ticker . Stop ( ) for { select { case <- ticker . C : switch err := c . heartbeat ( ) ; err { case nil , sarama . ErrNoError : case sarama . ErrNotCoordinatorForConsumer , sarama . ErrRebalanceInProgress : return default : c . handleError ( & Error { Ctx : "heartbeat" , error : err } ) return } case <- stopped : return case <- c . dying : return } } }
4219	func ( c * Consumer ) twLoop ( stopped <- chan none ) { ticker := time . NewTicker ( c . client . config . Metadata . RefreshFrequency / 2 ) defer ticker . Stop ( ) for { select { case <- ticker . C : topics , err := c . client . Topics ( ) if err != nil { c . handleError ( & Error { Ctx : "topics" , error : err } ) return } for _ , topic := range topics { if ! c . isKnownCoreTopic ( topic ) && ! c . isKnownExtraTopic ( topic ) && c . isPotentialExtraTopic ( topic ) { return } } case <- stopped : return case <- c . dying : return } } }
4220	func ( c * Consumer ) cmLoop ( stopped <- chan none ) { ticker := time . NewTicker ( c . client . config . Consumer . Offsets . CommitInterval ) defer ticker . Stop ( ) for { select { case <- ticker . C : if err := c . commitOffsetsWithRetry ( c . client . config . Group . Offsets . Retry . Max ) ; err != nil { c . handleError ( & Error { Ctx : "commit" , error : err } ) return } case <- stopped : return case <- c . dying : return } } }
4221	func ( c * Consumer ) fetchOffsets ( subs map [ string ] [ ] int32 ) ( map [ string ] map [ int32 ] offsetInfo , error ) { offsets := make ( map [ string ] map [ int32 ] offsetInfo , len ( subs ) ) req := & sarama . OffsetFetchRequest { Version : 1 , ConsumerGroup : c . groupID , } for topic , partitions := range subs { offsets [ topic ] = make ( map [ int32 ] offsetInfo , len ( partitions ) ) for _ , partition := range partitions { offsets [ topic ] [ partition ] = offsetInfo { Offset : - 1 } req . AddPartition ( topic , partition ) } } broker , err := c . client . Coordinator ( c . groupID ) if err != nil { c . closeCoordinator ( broker , err ) return nil , err } resp , err := broker . FetchOffset ( req ) if err != nil { c . closeCoordinator ( broker , err ) return nil , err } for topic , partitions := range subs { for _ , partition := range partitions { block := resp . GetBlock ( topic , partition ) if block == nil { return nil , sarama . ErrIncompleteResponse } if block . Err == sarama . ErrNoError { offsets [ topic ] [ partition ] = offsetInfo { Offset : block . Offset , Metadata : block . Metadata } } else { return nil , block . Err } } } return offsets , nil }
4222	func ( s * OffsetStash ) MarkOffset ( msg * sarama . ConsumerMessage , metadata string ) { s . MarkPartitionOffset ( msg . Topic , msg . Partition , msg . Offset , metadata ) }
4223	func ( s * OffsetStash ) ResetOffset ( msg * sarama . ConsumerMessage , metadata string ) { s . ResetPartitionOffset ( msg . Topic , msg . Partition , msg . Offset , metadata ) }
4224	func ( s * OffsetStash ) Offsets ( ) map [ string ] int64 { s . mu . Lock ( ) defer s . mu . Unlock ( ) res := make ( map [ string ] int64 , len ( s . offsets ) ) for tp , info := range s . offsets { res [ tp . String ( ) ] = info . Offset } return res }
4225	func ( r * InstanceGroup ) Actual ( immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( "instanceGroup.Actual" ) if r . CachedActual != nil { logger . Debug ( "Using cached instance [actual]" ) return immutable , r . CachedActual , nil } newResource := & InstanceGroup { Shared : Shared { Name : r . Name , CloudID : r . ServerPool . Identifier , } , } project , err := Sdk . Service . Projects . Get ( immutable . ProviderConfig ( ) . CloudId ) . Do ( ) if err != nil && project != nil { instances , err := Sdk . Service . Instances . List ( immutable . ProviderConfig ( ) . CloudId , immutable . ProviderConfig ( ) . Location ) . Do ( ) if err != nil { return nil , nil , err } count := len ( instances . Items ) if count > 0 { newResource . Count = count instance := instances . Items [ 0 ] newResource . Name = instance . Name newResource . CloudID = string ( instance . Id ) newResource . Size = instance . Kind newResource . Image = r . Image newResource . Location = instance . Zone } } newResource . BootstrapScripts = r . ServerPool . BootstrapScripts newResource . SSHFingerprint = immutable . ProviderConfig ( ) . SSH . PublicKeyFingerprint newResource . Name = r . Name r . CachedActual = newResource return immutable , newResource , nil }
4226	func ( r * InstanceGroup ) Expected ( immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( "instanceGroup.Expected" ) if r . CachedExpected != nil { logger . Debug ( "Using instance subnet [expected]" ) return immutable , r . CachedExpected , nil } expected := & InstanceGroup { Shared : Shared { Name : r . Name , CloudID : r . ServerPool . Identifier , } , Size : r . ServerPool . Size , Location : immutable . ProviderConfig ( ) . Location , Image : r . ServerPool . Image , Count : r . ServerPool . MaxCount , SSHFingerprint : immutable . ProviderConfig ( ) . SSH . PublicKeyFingerprint , BootstrapScripts : r . ServerPool . BootstrapScripts , } r . CachedExpected = expected return immutable , expected , nil }
4227	func ( r * InstanceGroup ) Delete ( actual cloud . Resource , immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( "instanceGroup.Delete" ) deleteResource := actual . ( * InstanceGroup ) if deleteResource . Name == "" { return nil , nil , fmt . Errorf ( "Unable to delete instance resource without Name [%s]" , deleteResource . Name ) } logger . Success ( "Deleting InstanceGroup manager [%s]" , r . ServerPool . Name ) _ , err := Sdk . Service . InstanceGroupManagers . Get ( immutable . ProviderConfig ( ) . CloudId , immutable . ProviderConfig ( ) . Location , strings . ToLower ( r . ServerPool . Name ) ) . Do ( ) if err == nil { _ , err := Sdk . Service . InstanceGroupManagers . Delete ( immutable . ProviderConfig ( ) . CloudId , immutable . ProviderConfig ( ) . Location , strings . ToLower ( r . ServerPool . Name ) ) . Do ( ) if err != nil { return nil , nil , err } } _ , err = Sdk . Service . InstanceTemplates . Get ( immutable . ProviderConfig ( ) . CloudId , strings . ToLower ( r . ServerPool . Name ) ) . Do ( ) if err == nil { err := r . retryDeleteInstanceTemplate ( immutable ) if err != nil { return nil , nil , err } } providerConfig := immutable . ProviderConfig ( ) providerConfig . KubernetesAPI . Endpoint = "" immutable . SetProviderConfig ( providerConfig ) renderedCluster , err := r . immutableRender ( actual , immutable ) if err != nil { return nil , nil , err } return renderedCluster , actual , nil }
4228	func GetReconciler ( known * cluster . Cluster , runtimeParameters * RuntimeParameters ) ( reconciler cloud . Reconciler , err error ) { switch known . ProviderConfig ( ) . Cloud { case cluster . CloudGoogle : sdk , err := googleSDK . NewSdk ( ) if err != nil { return nil , err } gr . Sdk = sdk return cloud . NewAtomicReconciler ( known , compute . NewGoogleComputeModel ( known ) ) , nil case cluster . CloudDigitalOcean : sdk , err := godoSdk . NewSdk ( ) if err != nil { return nil , err } dr . Sdk = sdk return cloud . NewAtomicReconciler ( known , droplet . NewDigitalOceanDropletModel ( known ) ) , nil case cluster . CloudAmazon : awsProfile := "" if runtimeParameters != nil { awsProfile = runtimeParameters . AwsProfile } sdk , err := awsSdkGo . NewSdk ( known . ProviderConfig ( ) . Location , awsProfile ) if err != nil { return nil , err } ar . Sdk = sdk return cloud . NewAtomicReconciler ( known , awspub . NewAmazonPublicModel ( known ) ) , nil case cluster . CloudAzure : sdk , err := azureSDK . NewSdk ( ) if err != nil { return nil , err } azr . Sdk = sdk return cloud . NewAtomicReconciler ( known , azpub . NewAzurePublicModel ( known ) ) , nil case cluster . CloudOVH : sdk , err := openstackSdk . NewSdk ( known . ProviderConfig ( ) . Location ) if err != nil { return nil , err } osr . Sdk = sdk return cloud . NewAtomicReconciler ( known , osovh . NewOvhPublicModel ( known ) ) , nil case cluster . CloudPacket : sdk , err := packetSDK . NewSdk ( ) if err != nil { return nil , err } packetr . Sdk = sdk return cloud . NewAtomicReconciler ( known , packetpub . NewPacketPublicModel ( known ) ) , nil case cluster . CloudECS : sdk , err := openstackSdk . NewSdk ( known . ProviderConfig ( ) . Location ) if err != nil { return nil , err } osr . Sdk = sdk return cloud . NewAtomicReconciler ( known , osecs . NewEcsPublicModel ( known ) ) , nil default : return nil , fmt . Errorf ( "Invalid cloud type: %s" , known . ProviderConfig ( ) . Cloud ) } }
4229	func GetVersion ( ) * Version { return & Version { Version : KubicornVersion , GitCommit : GitSha , BuildDate : time . Now ( ) . UTC ( ) . String ( ) , GoVersion : runtime . Version ( ) , GOOS : runtime . GOOS , GOArch : runtime . GOARCH , } }
4230	func GetVersionJSON ( ) string { verBytes , err := json . Marshal ( GetVersion ( ) ) if err != nil { logger . Critical ( "Unable to marshal version struct: %v" , err ) } return string ( verBytes ) }
4231	func ( r * ResourceGroup ) Actual ( immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( "resourcegroup.Actual" ) newResource := & ResourceGroup { Shared : Shared { Name : r . Name , Tags : r . Tags , Identifier : immutable . ProviderConfig ( ) . GroupIdentifier , } , Location : r . Location , } if r . Identifier != "" { group , err := Sdk . ResourceGroup . Get ( immutable . Name ) if err != nil { return nil , nil , err } newResource . Location = * group . Location newResource . Name = * group . Name newResource . Identifier = * group . ID } newCluster := r . immutableRender ( newResource , immutable ) return newCluster , newResource , nil }
4232	func ( r * ResourceGroup ) Expected ( immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( "resourcegroup.Expected" ) newResource := & ResourceGroup { Shared : Shared { Name : immutable . Name , Tags : r . Tags , Identifier : immutable . ProviderConfig ( ) . GroupIdentifier , } , Location : immutable . ProviderConfig ( ) . Location , } newCluster := r . immutableRender ( newResource , immutable ) return newCluster , newResource , nil }
4233	func CreateCmd ( ) * cobra . Command { var co = & cli . CreateOptions { } var createCmd = & cobra . Command { Use : "create [NAME] [-p|--profile PROFILENAME] [-c|--cloudid CLOUDID]" , Short : "Create a Kubicorn API model from a profile" , Long : `Use this command to create a Kubicorn API model in a defined state store. This command will create a cluster API model as a YAML manifest in a state store. Once the API model has been created, a user can optionally change the model to their liking. After a model is defined and configured properly, the user can then apply the model.` , Run : func ( cmd * cobra . Command , args [ ] string ) { switch len ( args ) { case 0 : co . Name = viper . GetString ( keyKubicornName ) if co . Name == "" { co . Name = namer . RandomName ( ) } case 1 : co . Name = args [ 0 ] default : logger . Critical ( "Too many arguments." ) os . Exit ( 1 ) } if err := RunCreate ( co ) ; err != nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs := createCmd . Flags ( ) bindCommonStateStoreFlags ( & co . StateStoreOptions , fs ) bindCommonAwsFlags ( & co . AwsOptions , fs ) fs . StringVarP ( & co . Profile , keyProfile , "p" , viper . GetString ( keyProfile ) , descProfile ) fs . StringVarP ( & co . CloudID , keyCloudID , "c" , viper . GetString ( keyCloudID ) , descCloudID ) fs . StringVar ( & co . KubeConfigLocalFile , keyKubeConfigLocalFile , viper . GetString ( keyKubeConfigLocalFile ) , descKubeConfigLocalFile ) fs . StringArrayVarP ( & co . Set , keySet , "C" , viper . GetStringSlice ( keySet ) , descSet ) fs . StringArrayVarP ( & co . MasterSet , keyMasterSet , "M" , viper . GetStringSlice ( keyMasterSet ) , descMasterSet ) fs . StringArrayVarP ( & co . NodeSet , keyNodeSet , "N" , viper . GetStringSlice ( keyNodeSet ) , descNodeSet ) fs . StringVarP ( & co . GitRemote , keyGitConfig , "g" , viper . GetString ( keyGitConfig ) , descGitConfig ) fs . StringArrayVar ( & co . AwsOptions . PolicyAttachments , keyPolicyAttachments , co . AwsOptions . PolicyAttachments , descPolicyAttachments ) flagApplyAnnotations ( createCmd , "profile" , "__kubicorn_parse_profiles" ) flagApplyAnnotations ( createCmd , "cloudid" , "__kubicorn_parse_cloudid" ) createCmd . SetUsageTemplate ( cli . UsageTemplate ) return createCmd }
4234	func NewUbuntuCluster ( name string ) * cluster . Cluster { controlPlaneProviderConfig := & cluster . ControlPlaneProviderConfig { Cloud : cluster . CloudAzure , Location : "eastus" , SSH : & cluster . SSH { PublicKeyPath : "~/.ssh/id_rsa.pub" , User : "root" , } , KubernetesAPI : & cluster . KubernetesAPI { Port : "443" , } , Values : & cluster . Values { ItemMap : map [ string ] string { "INJECTEDTOKEN" : kubeadm . GetRandomToken ( ) , } , } , } machineSetsProviderConfigs := [ ] * cluster . MachineProviderConfig { { ServerPool : & cluster . ServerPool { Type : cluster . ServerPoolTypeMaster , Name : fmt . Sprintf ( "%s-master" , name ) , MaxCount : 1 , Image : "UbuntuServer" , Size : "Standard_DS3_v2 " , BootstrapScripts : [ ] string { } , Firewalls : [ ] * cluster . Firewall { { Name : fmt . Sprintf ( "%s-master" , name ) , IngressRules : [ ] * cluster . IngressRule { { IngressToPort : "22" , IngressSource : "0.0.0.0/0" , IngressProtocol : "tcp" , } , { IngressToPort : "443" , IngressSource : "0.0.0.0/0" , IngressProtocol : "tcp" , } , { IngressToPort : "1194" , IngressSource : "0.0.0.0/0" , IngressProtocol : "udp" , } , } , EgressRules : [ ] * cluster . EgressRule { { EgressToPort : "all" , EgressDestination : "0.0.0.0/0" , EgressProtocol : "tcp" , } , { EgressToPort : "all" , EgressDestination : "0.0.0.0/0" , EgressProtocol : "udp" , } , } , } , } , } , } , { ServerPool : & cluster . ServerPool { Type : cluster . ServerPoolTypeNode , Name : fmt . Sprintf ( "%s-node" , name ) , MaxCount : 1 , Image : "UbuntuServer" , Size : "Standard_DS3_v2 " , BootstrapScripts : [ ] string { } , Firewalls : [ ] * cluster . Firewall { { Name : fmt . Sprintf ( "%s-node" , name ) , IngressRules : [ ] * cluster . IngressRule { { IngressToPort : "22" , IngressSource : "0.0.0.0/0" , IngressProtocol : "tcp" , } , { IngressToPort : "1194" , IngressSource : "0.0.0.0/0" , IngressProtocol : "udp" , } , } , EgressRules : [ ] * cluster . EgressRule { { EgressToPort : "all" , EgressDestination : "0.0.0.0/0" , EgressProtocol : "tcp" , } , { EgressToPort : "all" , EgressDestination : "0.0.0.0/0" , EgressProtocol : "udp" , } , } , } , } , } , } , } c := cluster . NewCluster ( name ) c . SetProviderConfig ( controlPlaneProviderConfig ) c . NewMachineSetsFromProviderConfigs ( machineSetsProviderConfigs ) return c }
4235	func ( c * Cluster ) ProviderConfig ( ) * ControlPlaneProviderConfig { raw := c . ClusterAPI . Spec . ProviderConfig providerConfig := & ControlPlaneProviderConfig { } err := json . Unmarshal ( [ ] byte ( raw ) , providerConfig ) if err != nil { logger . Critical ( "Unable to unmarshal provider config: %v" , err ) } return providerConfig }
4236	func ( c * Cluster ) SetProviderConfig ( config * ControlPlaneProviderConfig ) error { bytes , err := json . Marshal ( config ) if err != nil { logger . Critical ( "Unable to marshal provider config: %v" , err ) return err } str := string ( bytes ) c . ClusterAPI . Spec . ProviderConfig = str return nil }
4237	func ( c * Cluster ) MachineProviderConfigs ( ) [ ] * MachineProviderConfig { var providerConfigs [ ] * MachineProviderConfig for _ , machineSet := range c . MachineSets { raw := machineSet . Spec . Template . Spec . ProviderConfig providerConfig := & MachineProviderConfig { } err := json . Unmarshal ( [ ] byte ( raw ) , providerConfig ) if err != nil { logger . Critical ( "Unable to unmarshal provider config: %v" , err ) } providerConfigs = append ( providerConfigs , providerConfig ) } return providerConfigs }
4238	func ( c * Cluster ) SetMachineProviderConfigs ( providerConfigs [ ] * MachineProviderConfig ) { for _ , providerConfig := range providerConfigs { name := providerConfig . ServerPool . Name found := false for _ , machineSet := range c . MachineSets { if machineSet . Name == name { bytes , err := json . Marshal ( providerConfig ) if err != nil { logger . Critical ( "unable to marshal machine provider config: %v" ) continue } str := string ( bytes ) machineSet . Spec . Template . Spec . ProviderConfig = str found = true } } if ! found { logger . Warning ( "Unable to match provider config to machine set: %s" , name ) } } }
4239	func NewCluster ( name string ) * Cluster { return & Cluster { Name : name , ClusterAPI : & clusterv1 . Cluster { ObjectMeta : metav1 . ObjectMeta { Name : name , } , Spec : clusterv1 . ClusterSpec { } , } , ControlPlane : & clusterv1 . MachineSet { } , } }
4240	func DeployControllerCmd ( ) * cobra . Command { var dco = & cli . DeployControllerOptions { } var deployControllerCmd = & cobra . Command { Use : "deploycontroller <NAME>" , Short : "Deploy a controller for a given cluster" , Long : `Use this command to deploy a controller for a given cluster.As long as a controller is defined, this will create the deployment and the namespace.` , Run : func ( cmd * cobra . Command , args [ ] string ) { switch len ( args ) { case 0 : dco . Name = viper . GetString ( keyKubicornName ) case 1 : dco . Name = args [ 0 ] default : logger . Critical ( "Too many arguments." ) os . Exit ( 1 ) } if err := runDeployController ( dco ) ; err != nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs := deployControllerCmd . Flags ( ) bindCommonStateStoreFlags ( & dco . StateStoreOptions , fs ) bindCommonAwsFlags ( & dco . AwsOptions , fs ) fs . StringVar ( & dco . GitRemote , keyGitConfig , viper . GetString ( keyGitConfig ) , descGitConfig ) return deployControllerCmd }
4241	func NewRetrier ( retries , sleepSeconds int , retryable Retryable ) * Retrier { return & Retrier { retries : retries , sleepSeconds : sleepSeconds , retryable : retryable , } }
4242	func ( r * Retrier ) RunRetry ( ) error { sigHandler := signals . NewSignalHandler ( 10 ) go sigHandler . Register ( ) finish := make ( chan bool , 1 ) go func ( ) { select { case <- finish : return case <- time . After ( 10 * time . Second ) : return default : for { if sigHandler . GetState ( ) != 0 { logger . Critical ( "detected signal. retry failed." ) os . Exit ( 1 ) } } } } ( ) for i := 0 ; i < r . retries ; i ++ { err := r . retryable . Try ( ) if err != nil { logger . Info ( "Retryable error: %v" , err ) time . Sleep ( time . Duration ( r . sleepSeconds ) * time . Second ) continue } finish <- true return nil } finish <- true return fmt . Errorf ( "unable to succeed at retry after %d attempts at %d seconds" , r . retries , r . sleepSeconds ) }
4243	func MustGenerateRandomBytes ( length int ) [ ] byte { res , err := GenerateRandomBytes ( length ) if err != nil { panic ( "Could not generate random bytes" ) } return res }
4244	func ExplainCmd ( ) * cobra . Command { var exo = & cli . ExplainOptions { } var cmd = & cobra . Command { Use : "explain" , Short : "Explain cluster" , Long : `Output expected and actual state of the given cluster` , Run : func ( cmd * cobra . Command , args [ ] string ) { switch len ( args ) { case 0 : exo . Name = viper . GetString ( keyKubicornName ) case 1 : exo . Name = args [ 0 ] default : logger . Critical ( "Too many arguments." ) os . Exit ( 1 ) } if err := runExplain ( exo ) ; err != nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs := cmd . Flags ( ) bindCommonStateStoreFlags ( & exo . StateStoreOptions , fs ) bindCommonAwsFlags ( & exo . AwsOptions , fs ) fs . StringVarP ( & exo . Output , keyOutput , "o" , viper . GetString ( keyOutput ) , descOutput ) fs . StringVar ( & exo . GitRemote , keyGitConfig , viper . GetString ( keyGitConfig ) , descGitConfig ) return cmd }
4245	func TimeOrderedUUID ( ) string { unixTime := uint32 ( time . Now ( ) . UTC ( ) . Unix ( ) ) return fmt . Sprintf ( "%08x-%04x-%04x-%04x-%04x%08x" , unixTime , rand . MustGenerateRandomBytes ( 2 ) , rand . MustGenerateRandomBytes ( 2 ) , rand . MustGenerateRandomBytes ( 2 ) , rand . MustGenerateRandomBytes ( 2 ) , rand . MustGenerateRandomBytes ( 4 ) ) }
4246	func GetConfigCmd ( ) * cobra . Command { var cro = & cli . GetConfigOptions { } var getConfigCmd = & cobra . Command { Use : "getconfig <NAME>" , Short : "Manage Kubernetes configuration" , Long : `Use this command to pull a kubeconfig file from a cluster so you can use kubectl. This command will attempt to find a cluster, and append a local kubeconfig file with a kubeconfig ` , Run : func ( cmd * cobra . Command , args [ ] string ) { switch len ( args ) { case 0 : cro . Name = viper . GetString ( keyKubicornName ) case 1 : cro . Name = args [ 0 ] default : logger . Critical ( "Too many arguments." ) os . Exit ( 1 ) } if err := runGetConfig ( cro ) ; err != nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs := getConfigCmd . Flags ( ) bindCommonStateStoreFlags ( & cro . StateStoreOptions , fs ) bindCommonAwsFlags ( & cro . AwsOptions , fs ) fs . StringVar ( & cro . GitRemote , keyGitConfig , viper . GetString ( keyGitConfig ) , descGitConfig ) return getConfigCmd }
4247	func RunAnnotated ( task Task , description string , symbol string , options ... interface { } ) error { doneCh := make ( chan bool ) errCh := make ( chan error ) l := logger . Log t := DefaultTicker for _ , o := range options { if value , ok := o . ( logger . Logger ) ; ok { l = value } else if value , ok := o . ( * time . Ticker ) ; ok { t = value } } go func ( ) { errCh <- task ( ) } ( ) l ( description ) logActivity ( symbol , l , t , doneCh ) err := <- errCh doneCh <- true return err }
4248	func ListCmd ( ) * cobra . Command { var lo = & cli . ListOptions { } var cmd = & cobra . Command { Use : "list" , Short : "List available states" , Long : `List the states available in the _state directory` , Run : func ( cmd * cobra . Command , args [ ] string ) { if err := runList ( lo ) ; err != nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs := cmd . Flags ( ) bindCommonStateStoreFlags ( & lo . StateStoreOptions , fs ) bindCommonAwsFlags ( & lo . AwsOptions , fs ) fs . BoolVarP ( & noHeaders , keyNoHeaders , "n" , viper . GetBool ( keyNoHeaders ) , desNoHeaders ) return cmd }
4249	func NewUbuntuCluster ( name string ) * cluster . Cluster { controlPlaneProviderConfig := & cluster . ControlPlaneProviderConfig { Cloud : cluster . CloudPacket , Project : & cluster . Project { Name : fmt . Sprintf ( "kubicorn-%s" , name ) , } , Location : "ewr1" , SSH : & cluster . SSH { PublicKeyPath : "~/.ssh/id_rsa.pub" , User : "root" , } , KubernetesAPI : & cluster . KubernetesAPI { Port : "443" , } , Values : & cluster . Values { ItemMap : map [ string ] string { "INJECTEDTOKEN" : kubeadm . GetRandomToken ( ) , } , } , } machineSetsProviderConfigs := [ ] * cluster . MachineProviderConfig { { ServerPool : & cluster . ServerPool { Type : cluster . ServerPoolTypeMaster , Name : fmt . Sprintf ( "%s.master" , name ) , MaxCount : 1 , MinCount : 1 , Image : "ubuntu_16_04" , Size : "baremetal_1" , BootstrapScripts : [ ] string { "bootstrap/packet_k8s_ubuntu_16.04_master.sh" , } , } , } , { ServerPool : & cluster . ServerPool { Type : cluster . ServerPoolTypeNode , Name : fmt . Sprintf ( "%s.node" , name ) , MaxCount : 1 , MinCount : 1 , Image : "ubuntu_16_04" , Size : "baremetal_2" , BootstrapScripts : [ ] string { "bootstrap/packet_k8s_ubuntu_16.04_node.sh" , } , } , } , } c := cluster . NewCluster ( name ) c . SetProviderConfig ( controlPlaneProviderConfig ) c . NewMachineSetsFromProviderConfigs ( machineSetsProviderConfigs ) return c }
4250	func EditCmd ( ) * cobra . Command { var eo = & cli . EditOptions { } var editCmd = & cobra . Command { Use : "edit <NAME>" , Short : "Edit a cluster state" , Long : `Use this command to edit a state.` , Run : func ( cmd * cobra . Command , args [ ] string ) { switch len ( args ) { case 0 : eo . Name = viper . GetString ( keyKubicornName ) case 1 : eo . Name = args [ 0 ] default : logger . Critical ( "Too many arguments." ) os . Exit ( 1 ) } if err := runEdit ( eo ) ; err != nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs := editCmd . Flags ( ) bindCommonStateStoreFlags ( & eo . StateStoreOptions , fs ) bindCommonAwsFlags ( & eo . AwsOptions , fs ) fs . StringVarP ( & eo . Editor , keyEditor , "e" , viper . GetString ( keyEditor ) , descEditor ) fs . StringVar ( & eo . GitRemote , keyGitConfig , viper . GetString ( keyGitConfig ) , descGitConfig ) return editCmd }
4251	func ( k * Keyring ) RemoveKey ( key ssh . PublicKey ) error { return k . Agent . Remove ( key ) }
4252	func ( k * Keyring ) RemoveKeyUsingFile ( pubkey string ) error { p , err := ioutil . ReadFile ( pubkey ) if err != nil { return err } key , _ , _ , _ , _ := ssh . ParseAuthorizedKey ( p ) if err != nil { return err } return k . RemoveKey ( key ) }
4253	func ( r * Firewall ) Actual ( immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( "firewall.Actual" ) newResource := defaultFirewallStruct ( ) firewalls , _ , err := Sdk . Client . Firewalls . List ( context . TODO ( ) , & godo . ListOptions { } ) if err != nil { return nil , nil , fmt . Errorf ( "failed to get firwalls info" ) } for _ , firewall := range firewalls { if firewall . Name == r . Name { firewallBytes , err := json . Marshal ( firewall ) if err != nil { return nil , nil , fmt . Errorf ( "failed to marshal DO firewall details err: %v" , err ) } if err := json . Unmarshal ( firewallBytes , newResource ) ; err != nil { return nil , nil , fmt . Errorf ( "failed to unmarhal DO firewall details err: %v" , err ) } for i := 0 ; i < len ( newResource . OutboundRules ) ; i ++ { if newResource . OutboundRules [ i ] . PortRange == "0" { newResource . OutboundRules [ i ] . PortRange = "all" } } for i := 0 ; i < len ( newResource . InboundRules ) ; i ++ { if newResource . InboundRules [ i ] . PortRange == "0" { newResource . InboundRules [ i ] . PortRange = "all" } } } } newCluster := r . immutableRender ( newResource , immutable ) return newCluster , newResource , nil }
4254	func ( r * Firewall ) Expected ( immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( "firewall.Expected" ) newResource := & Firewall { Shared : Shared { Name : r . Name , CloudID : r . ServerPool . Identifier , } , InboundRules : r . InboundRules , OutboundRules : r . OutboundRules , DropletIDs : r . DropletIDs , Tags : r . Tags , FirewallID : r . FirewallID , Status : r . Status , Created : r . Created , } newCluster := r . immutableRender ( newResource , immutable ) return newCluster , newResource , nil }
4255	func ( r * Firewall ) Apply ( actual , expected cloud . Resource , immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( "firewall.Apply" ) expectedResource := expected . ( * Firewall ) actualResource := actual . ( * Firewall ) isEqual , err := compare . IsEqual ( actualResource , expectedResource ) if err != nil { return nil , nil , err } if isEqual { return immutable , expected , nil } firewallRequest := godo . FirewallRequest { Name : expectedResource . Name , InboundRules : convertInRuleType ( expectedResource . InboundRules ) , OutboundRules : convertOutRuleType ( expectedResource . OutboundRules ) , DropletIDs : expectedResource . DropletIDs , Tags : expectedResource . Tags , } machineProviderConfigs := immutable . MachineProviderConfigs ( ) for _ , machineProviderConfig := range machineProviderConfigs { for i := 0 ; i <= TagsGetAttempts ; i ++ { active := true droplets , _ , err := Sdk . Client . Droplets . ListByTag ( context . TODO ( ) , machineProviderConfig . ServerPool . Name , & godo . ListOptions { } ) if err != nil { logger . Debug ( "Hanging for droplets to get created.. (%v)" , err ) time . Sleep ( time . Duration ( TagsGetTimeout ) * time . Second ) continue } if len ( droplets ) == 0 { continue } for _ , d := range droplets { if d . Status != "active" { active = false break } } if ! active { logger . Debug ( "Waiting for droplets to become active.." ) time . Sleep ( time . Duration ( TagsGetTimeout ) * time . Second ) continue } break } } firewall , _ , err := Sdk . Client . Firewalls . Create ( context . TODO ( ) , & firewallRequest ) if err != nil { return nil , nil , fmt . Errorf ( "failed to create the firewall err: %v" , err ) } logger . Success ( "Created Firewall [%s]" , firewall . ID ) newResource := & Firewall { Shared : Shared { CloudID : firewall . ID , Name : r . Name , Tags : r . Tags , } , DropletIDs : r . DropletIDs , FirewallID : firewall . ID , InboundRules : r . InboundRules , OutboundRules : r . OutboundRules , Created : r . Created , } newCluster := r . immutableRender ( newResource , immutable ) return newCluster , newResource , nil }
4256	func ( r * Firewall ) Delete ( actual cloud . Resource , immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( "firewall.Delete" ) deleteResource , ok := actual . ( * Firewall ) if ! ok { return nil , nil , fmt . Errorf ( "failed to type convert actual Firewall type " ) } if deleteResource . Name == "" { return immutable , nil , nil return nil , nil , fmt . Errorf ( "Unable to delete firewall resource without Name [%s]" , deleteResource . Name ) } if _ , err := Sdk . Client . Firewalls . Delete ( context . TODO ( ) , deleteResource . FirewallID ) ; err != nil { return nil , nil , fmt . Errorf ( "failed to delete firewall [%s] err: %v" , deleteResource . Name , err ) } logger . Success ( "Deleted firewall [%s]" , deleteResource . FirewallID ) newResource := & Firewall { Shared : Shared { Name : r . Name , Tags : r . Tags , } , InboundRules : r . InboundRules , OutboundRules : r . OutboundRules , Created : r . Created , } newCluster := r . immutableRender ( newResource , immutable ) return newCluster , newResource , nil }
4257	func DeleteCmd ( ) * cobra . Command { var do = & cli . DeleteOptions { } var deleteCmd = & cobra . Command { Use : "delete <NAME>" , Short : "Delete a Kubernetes cluster" , Long : `Use this command to delete cloud resources. This command will attempt to build the resource graph based on an API model. Once the graph is built, the delete will attempt to delete the resources from the cloud. After the delete is complete, the state store will be left in tact and could potentially be applied later. To delete the resource AND the API model in the state store, use --purge.` , Run : func ( cmd * cobra . Command , args [ ] string ) { switch len ( args ) { case 0 : do . Name = viper . GetString ( keyKubicornName ) case 1 : do . Name = args [ 0 ] default : logger . Critical ( "Too many arguments." ) os . Exit ( 1 ) } if err := runDelete ( do ) ; err != nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs := deleteCmd . Flags ( ) bindCommonStateStoreFlags ( & do . StateStoreOptions , fs ) bindCommonAwsFlags ( & do . AwsOptions , fs ) fs . StringVar ( & do . AwsProfile , keyAwsProfile , viper . GetString ( keyAwsProfile ) , descAwsProfile ) fs . StringVar ( & do . GitRemote , keyGitConfig , viper . GetString ( keyGitConfig ) , descGitConfig ) fs . BoolVarP ( & do . Purge , keyPurge , "p" , viper . GetBool ( keyPurge ) , descPurge ) return deleteCmd }
4258	func ( options Options ) NewStateStore ( ) ( state . ClusterStorer , error ) { var stateStore state . ClusterStorer switch options . StateStore { case "fs" : logger . Info ( "Selected [fs] state store" ) stateStore = fs . NewFileSystemStore ( & fs . FileSystemStoreOptions { BasePath : options . StateStorePath , ClusterName : options . Name , } ) case "crd" : logger . Info ( "Selected [crd] state store" ) stateStore = crd . NewCRDStore ( & crd . CRDStoreOptions { BasePath : options . StateStorePath , ClusterName : options . Name , } ) case "git" : logger . Info ( "Selected [git] state store" ) if options . GitRemote == "" { return nil , errors . New ( "empty GitRemote url. Must specify the link to the remote git repo" ) } user , _ := gg . Global ( "user.name" ) email , _ := gg . Email ( ) stateStore = git . NewJSONGitStore ( & git . JSONGitStoreOptions { BasePath : options . StateStorePath , ClusterName : options . Name , CommitConfig : & git . JSONGitCommitConfig { Name : user , Email : email , Remote : options . GitRemote , } , } ) case "jsonfs" : logger . Info ( "Selected [jsonfs] state store" ) stateStore = jsonfs . NewJSONFileSystemStore ( & jsonfs . JSONFileSystemStoreOptions { BasePath : options . StateStorePath , ClusterName : options . Name , } ) case "s3" : logger . Info ( "Selected [s3] state store" ) client , err := minio . New ( options . BucketEndpointURL , options . S3AccessKey , options . S3SecretKey , options . BucketSSL ) if err != nil { return nil , err } stateStore = s3 . NewJSONFS3Store ( & s3 . JSONS3StoreOptions { BasePath : options . StateStorePath , ClusterName : options . Name , Client : client , BucketOptions : & s3 . S3BucketOptions { EndpointURL : options . BucketEndpointURL , BucketName : options . BucketName , } , } ) default : return nil , fmt . Errorf ( "state store [%s] has an invalid type [%s]" , options . Name , options . StateStore ) } return stateStore , nil }
4259	func ( git * JSONGitStore ) Commit ( c * cluster . Cluster ) error { if c == nil { return fmt . Errorf ( "Nil cluster spec" ) } bytes , err := json . Marshal ( c ) if err != nil { return err } git . Write ( state . ClusterJSONFile , bytes ) r , err := g . NewFilesystemRepository ( state . ClusterJSONFile ) if err != nil { return err } _ , err = r . CreateRemote ( & config . RemoteConfig { Name : git . ClusterName , URL : git . options . CommitConfig . Remote , } ) _ , err = r . Commits ( ) if err != nil { return err } return nil }
4260	func ApplyCmd ( ) * cobra . Command { var ao = & cli . ApplyOptions { } var applyCmd = & cobra . Command { Use : "apply <NAME>" , Short : "Apply a cluster resource to a cloud" , Long : `Use this command to apply an API model in a cloud. This command will attempt to find an API model in a defined state store, and then apply any changes needed directly to a cloud. The apply will run once, and ultimately time out if something goes wrong.` , Run : func ( cmd * cobra . Command , args [ ] string ) { switch len ( args ) { case 0 : ao . Name = viper . GetString ( keyKubicornName ) case 1 : ao . Name = args [ 0 ] default : logger . Critical ( "Too many arguments." ) os . Exit ( 1 ) } if err := runApply ( ao ) ; err != nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs := applyCmd . Flags ( ) bindCommonStateStoreFlags ( & ao . StateStoreOptions , fs ) bindCommonAwsFlags ( & ao . AwsOptions , fs ) fs . StringArrayVarP ( & ao . Set , keyKubicornSet , "e" , viper . GetStringSlice ( keyKubicornSet ) , descSet ) fs . StringVar ( & ao . AwsProfile , keyAwsProfile , viper . GetString ( keyAwsProfile ) , descAwsProfile ) fs . StringVar ( & ao . GitRemote , keyGitConfig , viper . GetString ( keyGitConfig ) , descGitConfig ) return applyCmd }
4261	func ExpandPath ( path string ) string { switch path { case "." : wd , err := os . Getwd ( ) if err != nil { logger . Critical ( "Unable to get current working directory: %v" , err ) return "" } path = wd case "~" : homeVar := os . Getenv ( "HOME" ) if homeVar == "" { homeUser , err := user . Current ( ) if err != nil { logger . Critical ( "Unable to use user.Current() for user. Maybe a cross compile issue: %v" , err ) return "" } path = homeUser . HomeDir } } return path }
4262	func CompletionCmd ( ) * cobra . Command { return & cobra . Command { Use : "completion" , Short : "Generate completion code for bash and zsh shells." , Long : `completion is used to output completion code for bash and zsh shells. Before using completion features, you have to source completion code from your .profile. This is done by adding following line to one of above files: source <(kubicorn completion SHELL) Valid arguments for SHELL are: "bash" and "zsh". Notes: 1) zsh completions requires zsh 5.2 or newer. 2) macOS users have to install bash-completion framework to utilize completion features. This can be done using homebrew: brew install bash-completion Once installed, you must load bash_completion by adding following line to your .profile or .bashrc/.zshrc: source $(brew --prefix)/etc/bash_completion` , RunE : func ( cmd * cobra . Command , args [ ] string ) error { if logger . Fabulous { cmd . SetOutput ( logger . FabulousWriter ) } if viper . GetString ( keyTrueColor ) != "" { cmd . SetOutput ( logger . FabulousWriter ) } switch len ( args ) { case 0 : return fmt . Errorf ( "shell argument is not specified" ) default : switch args [ 0 ] { case "bash" : return runBashGeneration ( ) case "zsh" : return runZshGeneration ( ) default : return fmt . Errorf ( "invalid shell argument" ) } } } , } }
4263	func AdoptCmd ( ) * cobra . Command { return & cobra . Command { Use : "adopt" , Short : "Adopt a Kubernetes cluster into a Kubicorn state store" , Long : `Use this command to audit and adopt a Kubernetes cluster into a Kubicorn state store. This command will query cloud resources and attempt to build a representation of the cluster in the Kubicorn API model. Once the cluster has been adopted, a user can manage and scale their Kubernetes cluster with Kubicorn.` , Run : func ( cmd * cobra . Command , args [ ] string ) { fmt . Println ( "adopt called" ) } , } }
4264	func StrEnvDef ( env string , def string ) string { val := os . Getenv ( env ) if val == "" { return def } return val }
4265	func IntEnvDef ( env string , def int ) int { val := os . Getenv ( env ) if val == "" { return def } ival , err := strconv . Atoi ( val ) if err != nil { return def } return ival }
4266	func BoolEnvDef ( env string , def bool ) bool { val := os . Getenv ( env ) if val == "" { return def } b , err := strconv . ParseBool ( val ) if err != nil { return def } return b }
4267	func readFromFS ( sourcePath string ) ( string , error ) { if strings . HasPrefix ( sourcePath , "~" ) { homeDir := os . Getenv ( "HOME" ) if homeDir == "" { return "" , fmt . Errorf ( "Could not find $HOME" ) } sourcePath = filepath . Join ( homeDir , sourcePath [ 1 : ] ) } bytes , err := ioutil . ReadFile ( sourcePath ) if err != nil { return "" , err } return string ( bytes ) , nil }
4268	func VersionCmd ( ) * cobra . Command { return & cobra . Command { Use : "version" , Short : "Verify Kubicorn version" , Long : `Use this command to check the version of Kubicorn. This command will return the version of the Kubicorn binary.` , Run : func ( cmd * cobra . Command , args [ ] string ) { fmt . Printf ( "%s\n" , \n ) } , } }
4269	func NewSignalHandler ( timeoutSeconds int ) * Handler { signals := make ( chan os . Signal ) signal . Notify ( signals , os . Interrupt , os . Kill ) return & Handler { timeoutSeconds : timeoutSeconds , signals : signals , signalReceived : 0 , } }
4270	func ( h * Handler ) Register ( ) { go func ( ) { h . timer = time . NewTimer ( time . Duration ( h . timeoutSeconds ) * time . Second ) for { select { case s := <- h . signals : switch { case s == os . Interrupt : if h . signalReceived == 0 { h . signalReceived = 1 logger . Debug ( "SIGINT Received" ) continue } h . signalReceived = signalTerminate debug . PrintStack ( ) os . Exit ( 130 ) break case s == syscall . SIGQUIT : h . signalReceived = signalAbort break case s == syscall . SIGTERM : h . signalReceived = signalTerminate os . Exit ( 3 ) break } case <- h . timer . C : os . Exit ( 4 ) break } } } ( ) }
4271	func NewUbuntuCluster ( name string ) * cluster . Cluster { var ( masterName = fmt . Sprintf ( "%s-master" , name ) nodeName = fmt . Sprintf ( "%s-node" , name ) ) controlPlaneProviderConfig := & cluster . ControlPlaneProviderConfig { Cloud : cluster . CloudECS , Location : "nl-ams1" , SSH : & cluster . SSH { PublicKeyPath : "~/.ssh/id_rsa.pub" , User : "ubuntu" , } , Values : & cluster . Values { ItemMap : map [ string ] string { "INJECTEDTOKEN" : kubeadm . GetRandomToken ( ) , } , } , KubernetesAPI : & cluster . KubernetesAPI { Port : "443" , } , Network : & cluster . Network { Type : cluster . NetworkTypePublic , InternetGW : & cluster . InternetGW { Name : "default" , } , } , } machineSetsProviderConfigs := [ ] * cluster . MachineProviderConfig { { ServerPool : & cluster . ServerPool { Type : cluster . ServerPoolTypeMaster , Name : masterName , MaxCount : 1 , Image : "GNU/Linux Ubuntu Server 16.04 Xenial Xerus x64" , Size : "e3standard.x3" , BootstrapScripts : [ ] string { "bootstrap/ecs_k8s_ubuntu_16.04_master.sh" , } , Subnets : [ ] * cluster . Subnet { { Name : "internal" , CIDR : "192.168.200.0/24" , } , } , Firewalls : [ ] * cluster . Firewall { { Name : masterName , IngressRules : [ ] * cluster . IngressRule { { IngressFromPort : "22" , IngressToPort : "22" , IngressSource : "0.0.0.0/0" , IngressProtocol : "tcp" , } , { IngressFromPort : "443" , IngressToPort : "443" , IngressSource : "0.0.0.0/0" , IngressProtocol : "tcp" , } , { IngressSource : "192.168.200.0/24" , } , } , } , } , } , } , { ServerPool : & cluster . ServerPool { Type : cluster . ServerPoolTypeNode , Name : nodeName , MaxCount : 2 , Image : "GNU/Linux Ubuntu Server 16.04 Xenial Xerus x64" , Size : "e3standard.x3" , BootstrapScripts : [ ] string { "bootstrap/ecs_k8s_ubuntu_16.04_node.sh" , } , Firewalls : [ ] * cluster . Firewall { { Name : nodeName , IngressRules : [ ] * cluster . IngressRule { { IngressFromPort : "22" , IngressToPort : "22" , IngressSource : "0.0.0.0/0" , IngressProtocol : "tcp" , } , { IngressSource : "192.168.200.0/24" , } , } , } , } , } , } , } c := cluster . NewCluster ( name ) c . SetProviderConfig ( controlPlaneProviderConfig ) c . NewMachineSetsFromProviderConfigs ( machineSetsProviderConfigs ) return c }
4272	func ( now * Now ) BeginningOfHour ( ) time . Time { y , m , d := now . Date ( ) return time . Date ( y , m , d , now . Time . Hour ( ) , 0 , 0 , 0 , now . Time . Location ( ) ) }
4273	func ( now * Now ) BeginningOfDay ( ) time . Time { y , m , d := now . Date ( ) return time . Date ( y , m , d , 0 , 0 , 0 , 0 , now . Time . Location ( ) ) }
4274	func ( now * Now ) BeginningOfWeek ( ) time . Time { t := now . BeginningOfDay ( ) weekday := int ( t . Weekday ( ) ) if WeekStartDay != time . Sunday { weekStartDayInt := int ( WeekStartDay ) if weekday < weekStartDayInt { weekday = weekday + 7 - weekStartDayInt } else { weekday = weekday - weekStartDayInt } } return t . AddDate ( 0 , 0 , - weekday ) }
4275	func ( now * Now ) BeginningOfMonth ( ) time . Time { y , m , _ := now . Date ( ) return time . Date ( y , m , 1 , 0 , 0 , 0 , 0 , now . Location ( ) ) }
4276	func ( now * Now ) BeginningOfQuarter ( ) time . Time { month := now . BeginningOfMonth ( ) offset := ( int ( month . Month ( ) ) - 1 ) % 3 return month . AddDate ( 0 , - offset , 0 ) }
4277	func ( now * Now ) BeginningOfYear ( ) time . Time { y , _ , _ := now . Date ( ) return time . Date ( y , time . January , 1 , 0 , 0 , 0 , 0 , now . Location ( ) ) }
4278	func ( now * Now ) EndOfMinute ( ) time . Time { return now . BeginningOfMinute ( ) . Add ( time . Minute - time . Nanosecond ) }
4279	func ( now * Now ) EndOfHour ( ) time . Time { return now . BeginningOfHour ( ) . Add ( time . Hour - time . Nanosecond ) }
4280	func ( now * Now ) EndOfDay ( ) time . Time { y , m , d := now . Date ( ) return time . Date ( y , m , d , 23 , 59 , 59 , int ( time . Second - time . Nanosecond ) , now . Location ( ) ) }
4281	func ( now * Now ) EndOfWeek ( ) time . Time { return now . BeginningOfWeek ( ) . AddDate ( 0 , 0 , 7 ) . Add ( - time . Nanosecond ) }
4282	func ( now * Now ) EndOfMonth ( ) time . Time { return now . BeginningOfMonth ( ) . AddDate ( 0 , 1 , 0 ) . Add ( - time . Nanosecond ) }
4283	func ( now * Now ) EndOfQuarter ( ) time . Time { return now . BeginningOfQuarter ( ) . AddDate ( 0 , 3 , 0 ) . Add ( - time . Nanosecond ) }
4284	func ( now * Now ) EndOfYear ( ) time . Time { return now . BeginningOfYear ( ) . AddDate ( 1 , 0 , 0 ) . Add ( - time . Nanosecond ) }
4285	func ( now * Now ) MustParse ( strs ... string ) ( t time . Time ) { t , err := now . Parse ( strs ... ) if err != nil { panic ( err ) } return t }
4286	func ( now * Now ) Between ( begin , end string ) bool { beginTime := now . MustParse ( begin ) endTime := now . MustParse ( end ) return now . After ( beginTime ) && now . Before ( endTime ) }
4287	func ParseInLocation ( loc * time . Location , strs ... string ) ( time . Time , error ) { return New ( time . Now ( ) . In ( loc ) ) . Parse ( strs ... ) }
4288	func MustParse ( strs ... string ) time . Time { return New ( time . Now ( ) ) . MustParse ( strs ... ) }
4289	func MustParseInLocation ( loc * time . Location , strs ... string ) time . Time { return New ( time . Now ( ) . In ( loc ) ) . MustParse ( strs ... ) }
4290	func Between ( time1 , time2 string ) bool { return New ( time . Now ( ) ) . Between ( time1 , time2 ) }
4291	func NewChannelMemoryBackend ( size int ) * ChannelMemoryBackend { backend := & ChannelMemoryBackend { maxSize : size , incoming : make ( chan * Record , 1024 ) , events : make ( chan event ) , } backend . Start ( ) return backend }
4292	func ( b * ChannelMemoryBackend ) Start ( ) { b . mu . Lock ( ) defer b . mu . Unlock ( ) if b . running != true { b . running = true b . stopWg . Add ( 1 ) go b . process ( ) } }
4293	func ( b * ChannelMemoryBackend ) Flush ( ) { b . flushWg . Add ( 1 ) b . events <- eventFlush b . flushWg . Wait ( ) }
4294	func ( b * ChannelMemoryBackend ) Stop ( ) { b . mu . Lock ( ) if b . running == true { b . running = false b . events <- eventStop } b . mu . Unlock ( ) b . stopWg . Wait ( ) }
4295	func ( r * Record ) Formatted ( calldepth int ) string { if r . formatted == "" { var buf bytes . Buffer r . formatter . Format ( calldepth + 1 , r , & buf ) r . formatted = buf . String ( ) } return r . formatted }
4296	func ( r * Record ) Message ( ) string { if r . message == nil { for i , arg := range r . Args { if redactor , ok := arg . ( Redactor ) ; ok == true { r . Args [ i ] = redactor . Redacted ( ) } } var buf bytes . Buffer if r . fmt != nil { fmt . Fprintf ( & buf , * r . fmt , r . Args ... ) } else { fmt . Fprintln ( & buf , r . Args ... ) buf . Truncate ( buf . Len ( ) - 1 ) } msg := buf . String ( ) r . message = & msg } return * r . message }
4297	func ( l * Logger ) SetBackend ( backend LeveledBackend ) { l . backend = backend l . haveBackend = true }
4298	func MustGetLogger ( module string ) * Logger { logger , err := GetLogger ( module ) if err != nil { panic ( "logger: " + module + ": " + err . Error ( ) ) } return logger }
4299	func Reset ( ) { sequenceNo = 0 b := SetBackend ( NewLogBackend ( os . Stderr , "" , log . LstdFlags ) ) b . SetLevel ( DEBUG , "" ) SetFormatter ( DefaultFormatter ) timeNow = time . Now }
4300	func ( l * Logger ) IsEnabledFor ( level Level ) bool { return defaultBackend . IsEnabledFor ( level , l . Module ) }
4301	func ( l * Logger ) Criticalf ( format string , args ... interface { } ) { l . log ( CRITICAL , & format , args ... ) }
4302	func ( l * Logger ) Warningf ( format string , args ... interface { } ) { l . log ( WARNING , & format , args ... ) }
4303	func ( l * Logger ) Noticef ( format string , args ... interface { } ) { l . log ( NOTICE , & format , args ... ) }
4304	func ( l * Logger ) Infof ( format string , args ... interface { } ) { l . log ( INFO , & format , args ... ) }
4305	func SetFormatter ( f Formatter ) { formatter . Lock ( ) defer formatter . Unlock ( ) formatter . def = f }
4306	func MustStringFormatter ( format string ) Formatter { f , err := NewStringFormatter ( format ) if err != nil { panic ( "Failed to initialized string formatter: " + err . Error ( ) ) } return f }
4307	func formatFuncName ( v fmtVerb , f string ) string { i := strings . LastIndex ( f , "/" ) j := strings . Index ( f [ i + 1 : ] , "." ) if j < 1 { return "???" } pkg , fun := f [ : i + j + 1 ] , f [ i + j + 2 : ] switch v { case fmtVerbLongpkg : return pkg case fmtVerbShortpkg : return path . Base ( pkg ) case fmtVerbLongfunc : return fun case fmtVerbShortfunc : i = strings . LastIndex ( fun , "." ) return fun [ i + 1 : ] } panic ( "unexpected func formatter" ) }
4308	func ( bf * backendFormatter ) Log ( level Level , calldepth int , r * Record ) error { r2 := * r r2 . formatter = bf . f return bf . b . Log ( level , calldepth + 1 , & r2 ) }
4309	func LogLevel ( level string ) ( Level , error ) { for i , name := range levelNames { if strings . EqualFold ( name , level ) { return Level ( i ) , nil } } return ERROR , ErrInvalidLogLevel }
4310	func AddModuleLevel ( backend Backend ) LeveledBackend { var leveled LeveledBackend var ok bool if leveled , ok = backend . ( LeveledBackend ) ; ! ok { leveled = & moduleLeveled { levels : make ( map [ string ] Level ) , backend : backend , } } return leveled }
4311	func ( l * moduleLeveled ) GetLevel ( module string ) Level { level , exists := l . levels [ module ] if exists == false { level , exists = l . levels [ "" ] if exists == false { level = DEBUG } } return level }
4312	func ( l * moduleLeveled ) SetLevel ( level Level , module string ) { l . levels [ module ] = level }
4313	func ( l * moduleLeveled ) IsEnabledFor ( level Level , module string ) bool { return level <= l . GetLevel ( module ) }
4314	func MultiLogger ( backends ... Backend ) LeveledBackend { var leveledBackends [ ] LeveledBackend for _ , backend := range backends { leveledBackends = append ( leveledBackends , AddModuleLevel ( backend ) ) } return & multiLogger { leveledBackends } }
4315	func ( b * multiLogger ) Log ( level Level , calldepth int , rec * Record ) ( err error ) { for _ , backend := range b . backends { if backend . IsEnabledFor ( level , rec . Module ) { r2 := * rec if e := backend . Log ( level , calldepth + 1 , & r2 ) ; e != nil { err = e } } } return }
4316	func ( b * multiLogger ) GetLevel ( module string ) Level { var level Level for _ , backend := range b . backends { if backendLevel := backend . GetLevel ( module ) ; backendLevel > level { level = backendLevel } } return level }
4317	func ( b * multiLogger ) SetLevel ( level Level , module string ) { for _ , backend := range b . backends { backend . SetLevel ( level , module ) } }
4318	func ( b * multiLogger ) IsEnabledFor ( level Level , module string ) bool { for _ , backend := range b . backends { if backend . IsEnabledFor ( level , module ) { return true } } return false }
4319	func ConvertColors ( colors [ ] int , bold bool ) [ ] string { converted := [ ] string { } for _ , i := range colors { if bold { converted = append ( converted , ColorSeqBold ( color ( i ) ) ) } else { converted = append ( converted , ColorSeq ( color ( i ) ) ) } } return converted }
4320	func NewSyslogBackend ( prefix string ) ( b * SyslogBackend , err error ) { var w * syslog . Writer w , err = syslog . New ( syslog . LOG_CRIT , prefix ) return & SyslogBackend { w } , err }
4321	func NewSyslogBackendPriority ( prefix string , priority syslog . Priority ) ( b * SyslogBackend , err error ) { var w * syslog . Writer w , err = syslog . New ( priority , prefix ) return & SyslogBackend { w } , err }
4322	func SetBackend ( backends ... Backend ) LeveledBackend { var backend Backend if len ( backends ) == 1 { backend = backends [ 0 ] } else { backend = MultiLogger ( backends ... ) } defaultBackend = AddModuleLevel ( backend ) return defaultBackend }
4323	func NewCommander ( topLevelFlags * flag . FlagSet , name string ) * Commander { cdr := & Commander { topFlags : topLevelFlags , name : name , Output : os . Stdout , Error : os . Stderr , } topLevelFlags . Usage = func ( ) { cdr . explain ( cdr . Error ) } return cdr }
4324	func ( cdr * Commander ) Execute ( ctx context . Context , args ... interface { } ) ExitStatus { if cdr . topFlags . NArg ( ) < 1 { cdr . topFlags . Usage ( ) return ExitUsageError } name := cdr . topFlags . Arg ( 0 ) for _ , group := range cdr . commands { for _ , cmd := range group . commands { if name != cmd . Name ( ) { continue } f := flag . NewFlagSet ( name , flag . ContinueOnError ) f . Usage = func ( ) { explain ( cdr . Error , cmd ) } cmd . SetFlags ( f ) if f . Parse ( cdr . topFlags . Args ( ) [ 1 : ] ) != nil { return ExitUsageError } return cmd . Execute ( ctx , f , args ... ) } } cdr . topFlags . Usage ( ) return ExitUsageError }
4325	func ( cdr * Commander ) explain ( w io . Writer ) { fmt . Fprintf ( w , "Usage: %s <flags> <subcommand> <subcommand args>\n\n" , \n ) \n cdr . name sort . Sort ( byGroupName ( cdr . commands ) ) for _ , group := range cdr . commands { explainGroup ( w , group ) } if cdr . topFlags == nil { fmt . Fprintln ( w , "\nNo top level flags." ) \n } return }
4326	func explainGroup ( w io . Writer , group * commandGroup ) { if len ( group . commands ) == 0 { return } if group . name == "" { fmt . Fprintf ( w , "Subcommands:\n" ) } else \n { fmt . Fprintf ( w , "Subcommands for %s:\n" , \n ) } group . name sort . Sort ( group ) aliases := make ( map [ string ] [ ] string ) for _ , cmd := range group . commands { if alias , ok := cmd . ( * aliaser ) ; ok { root := dealias ( alias ) . Name ( ) if _ , ok := aliases [ root ] ; ! ok { aliases [ root ] = [ ] string { } } aliases [ root ] = append ( aliases [ root ] , alias . Name ( ) ) } } }
4327	func explain ( w io . Writer , cmd Command ) { fmt . Fprintf ( w , "%s" , cmd . Usage ( ) ) subflags := flag . NewFlagSet ( cmd . Name ( ) , flag . PanicOnError ) subflags . SetOutput ( w ) cmd . SetFlags ( subflags ) subflags . PrintDefaults ( ) }
4328	func dealias ( cmd Command ) Command { if alias , ok := cmd . ( * aliaser ) ; ok { return dealias ( alias . Command ) } return cmd }
4329	func Execute ( ctx context . Context , args ... interface { } ) ExitStatus { return DefaultCommander . Execute ( ctx , args ... ) }
4330	func LoadFromData ( data [ ] byte ) ( c * ConfigFile , err error ) { tmpName := path . Join ( os . TempDir ( ) , "goconfig" , fmt . Sprintf ( "%d" , time . Now ( ) . Nanosecond ( ) ) ) if err = os . MkdirAll ( path . Dir ( tmpName ) , os . ModePerm ) ; err != nil { return nil , err } if err = ioutil . WriteFile ( tmpName , data , 0655 ) ; err != nil { return nil , err } c = newConfigFile ( [ ] string { tmpName } ) err = c . read ( bytes . NewBuffer ( data ) ) return c , err }
4331	func LoadFromReader ( in io . Reader ) ( c * ConfigFile , err error ) { c = newConfigFile ( [ ] string { "" } ) err = c . read ( in ) return c , err }
4332	func ( c * ConfigFile ) ReloadData ( in io . Reader ) ( err error ) { var cfg * ConfigFile if len ( c . fileNames ) != 1 { return fmt . Errorf ( "Multiple files loaded, unable to mix in-memory and file data" ) } cfg , err = LoadFromReader ( in ) if err == nil { * c = * cfg } return err }
4333	func ( c * ConfigFile ) AppendFiles ( files ... string ) error { if len ( c . fileNames ) == 1 && c . fileNames [ 0 ] == "" { return fmt . Errorf ( "Cannot append file data to in-memory data" ) } c . fileNames = append ( c . fileNames , files ... ) return c . Reload ( ) }
4334	func ( c * ConfigFile ) GetKeyList ( section string ) [ ] string { if len ( section ) == 0 { section = DEFAULT_SECTION } if c . BlockMode { c . lock . RLock ( ) defer c . lock . RUnlock ( ) } if _ , ok := c . data [ section ] ; ! ok { return nil } list := make ( [ ] string , 0 , len ( c . keyList [ section ] ) ) for _ , key := range c . keyList [ section ] { if key != " " { list = append ( list , key ) } } return list }
4335	func SaveConfigData ( c * ConfigFile , out io . Writer ) ( err error ) { equalSign := "=" if PrettyFormat { equalSign = " = " } buf := bytes . NewBuffer ( nil ) for _ , section := range c . sectionList { if len ( c . GetSectionComments ( section ) ) > 0 { if _ , err = buf . WriteString ( c . GetSectionComments ( section ) + LineBreak ) ; err != nil { return err } } if section != DEFAULT_SECTION { if _ , err = buf . WriteString ( "[" + section + "]" + LineBreak ) ; err != nil { return err } } for _ , key := range c . keyList [ section ] { if key != " " { if len ( c . GetKeyComments ( section , key ) ) > 0 { if _ , err = buf . WriteString ( c . GetKeyComments ( section , key ) + LineBreak ) ; err != nil { return err } } keyName := key if keyName [ 0 ] == '#' { keyName = "-" } if strings . Contains ( keyName , `=` ) || strings . Contains ( keyName , `:` ) { if strings . Contains ( keyName , "`" ) { if strings . Contains ( keyName , `"` ) { keyName = `"""` + keyName + `"""` } else { keyName = `"` + keyName + `"` } } else { keyName = "`" + keyName + "`" } } value := c . data [ section ] [ key ] if strings . Contains ( value , "`" ) { if strings . Contains ( value , `"` ) { value = `"""` + value + `"""` } else { value = `"` + value + `"` } } if _ , err = buf . WriteString ( keyName + equalSign + value + LineBreak ) ; err != nil { return err } } } if _ , err = buf . WriteString ( LineBreak ) ; err != nil { return err } } if _ , err := buf . WriteTo ( out ) ; err != nil { return err } return nil }
4336	func SaveConfigFile ( c * ConfigFile , filename string ) ( err error ) { var f * os . File if f , err = os . Create ( filename ) ; err != nil { return err } if err := SaveConfigData ( c , f ) ; err != nil { return err } return f . Close ( ) }
4337	func ( s * selectable ) Find ( selector string ) * Selection { return newSelection ( s . session , s . selectors . Append ( target . CSS , selector ) . Single ( ) ) }
4338	func ( s * selectable ) FindByXPath ( selector string ) * Selection { return newSelection ( s . session , s . selectors . Append ( target . XPath , selector ) . Single ( ) ) }
4339	func ( s * selectable ) FindByLink ( text string ) * Selection { return newSelection ( s . session , s . selectors . Append ( target . Link , text ) . Single ( ) ) }
4340	func ( s * selectable ) FindByLabel ( text string ) * Selection { return newSelection ( s . session , s . selectors . Append ( target . Label , text ) . Single ( ) ) }
4341	func ( s * selectable ) FindByName ( name string ) * Selection { return newSelection ( s . session , s . selectors . Append ( target . Name , name ) . Single ( ) ) }
4342	func ( s * selectable ) FindByClass ( text string ) * Selection { return newSelection ( s . session , s . selectors . Append ( target . Class , text ) . Single ( ) ) }
4343	func ( s * selectable ) FindByID ( id string ) * Selection { return newSelection ( s . session , s . selectors . Append ( target . ID , id ) . Single ( ) ) }
4344	func ( s * selectable ) First ( selector string ) * Selection { return newSelection ( s . session , s . selectors . Append ( target . CSS , selector ) . At ( 0 ) ) }
4345	func ( s * selectable ) FirstByXPath ( selector string ) * Selection { return newSelection ( s . session , s . selectors . Append ( target . XPath , selector ) . At ( 0 ) ) }
4346	func ( s * selectable ) FirstByLink ( text string ) * Selection { return newSelection ( s . session , s . selectors . Append ( target . Link , text ) . At ( 0 ) ) }
4347	func ( s * selectable ) FirstByLabel ( text string ) * Selection { return newSelection ( s . session , s . selectors . Append ( target . Label , text ) . At ( 0 ) ) }
4348	func ( s * selectable ) FirstByName ( name string ) * Selection { return newSelection ( s . session , s . selectors . Append ( target . Name , name ) . At ( 0 ) ) }
4349	func ( s * selectable ) All ( selector string ) * MultiSelection { return newMultiSelection ( s . session , s . selectors . Append ( target . CSS , selector ) ) }
4350	func ( s * selectable ) AllByXPath ( selector string ) * MultiSelection { return newMultiSelection ( s . session , s . selectors . Append ( target . XPath , selector ) ) }
4351	func ( s * selectable ) AllByLink ( text string ) * MultiSelection { return newMultiSelection ( s . session , s . selectors . Append ( target . Link , text ) ) }
4352	func ( s * selectable ) AllByLabel ( text string ) * MultiSelection { return newMultiSelection ( s . session , s . selectors . Append ( target . Label , text ) ) }
4353	func ( s * selectable ) AllByName ( name string ) * MultiSelection { return newMultiSelection ( s . session , s . selectors . Append ( target . Name , name ) ) }
4354	func ( s * selectable ) AllByClass ( text string ) * MultiSelection { return newMultiSelection ( s . session , s . selectors . Append ( target . Class , text ) ) }
4355	func ( s * selectable ) AllByID ( text string ) * MultiSelection { return newMultiSelection ( s . session , s . selectors . Append ( target . ID , text ) ) }
4356	func ( s * selectable ) FindForAppium ( selectorType string , text string ) * Selection { return newSelection ( s . session , s . selectors . Append ( target . Class , text ) . At ( 0 ) ) }
4357	func Timeout ( seconds int ) Option { return func ( c * config ) { c . Timeout = time . Duration ( seconds ) * time . Second } }
4358	func ChromeOptions ( opt string , value interface { } ) Option { return func ( c * config ) { if c . ChromeOptions == nil { c . ChromeOptions = make ( map [ string ] interface { } ) } c . ChromeOptions [ opt ] = value } }
4359	func JoinPage ( url string , options ... Option ) * Page { pageOptions := config { } . Merge ( options ) session := api . NewWithClient ( url , pageOptions . HTTPClient ) return newPage ( session ) }
4360	func ( p * Page ) Destroy ( ) error { if err := p . session . Delete ( ) ; err != nil { return fmt . Errorf ( "failed to destroy session: %s" , err ) } return nil }
4361	func ( p * Page ) Reset ( ) error { p . ConfirmPopup ( ) url , err := p . URL ( ) if err != nil { return err } if url == "about:blank" { return nil } if err := p . ClearCookies ( ) ; err != nil { return err } if err := p . session . DeleteLocalStorage ( ) ; err != nil { if err := p . RunScript ( "localStorage.clear();" , nil , nil ) ; err != nil { return err } } if err := p . session . DeleteSessionStorage ( ) ; err != nil { if err := p . RunScript ( "sessionStorage.clear();" , nil , nil ) ; err != nil { return err } } return p . Navigate ( "about:blank" ) }
4362	func ( p * Page ) Navigate ( url string ) error { if err := p . session . SetURL ( url ) ; err != nil { return fmt . Errorf ( "failed to navigate: %s" , err ) } return nil }
4363	func ( p * Page ) GetCookies ( ) ( [ ] * http . Cookie , error ) { apiCookies , err := p . session . GetCookies ( ) if err != nil { return nil , fmt . Errorf ( "failed to get cookies: %s" , err ) } cookies := [ ] * http . Cookie { } for _ , apiCookie := range apiCookies { expSeconds := int64 ( apiCookie . Expiry ) expNano := int64 ( apiCookie . Expiry - float64 ( expSeconds ) ) * 1000000000 cookie := & http . Cookie { Name : apiCookie . Name , Value : apiCookie . Value , Path : apiCookie . Path , Domain : apiCookie . Domain , Secure : apiCookie . Secure , HttpOnly : apiCookie . HTTPOnly , Expires : time . Unix ( expSeconds , expNano ) , } cookies = append ( cookies , cookie ) } return cookies , nil }
4364	func ( p * Page ) SetCookie ( cookie * http . Cookie ) error { if cookie == nil { return errors . New ( "nil cookie is invalid" ) } var expiry int64 if ! cookie . Expires . IsZero ( ) { expiry = cookie . Expires . Unix ( ) } apiCookie := & api . Cookie { Name : cookie . Name , Value : cookie . Value , Path : cookie . Path , Domain : cookie . Domain , Secure : cookie . Secure , HTTPOnly : cookie . HttpOnly , Expiry : float64 ( expiry ) , } if err := p . session . SetCookie ( apiCookie ) ; err != nil { return fmt . Errorf ( "failed to set cookie: %s" , err ) } return nil }
4365	func ( p * Page ) DeleteCookie ( name string ) error { if err := p . session . DeleteCookie ( name ) ; err != nil { return fmt . Errorf ( "failed to delete cookie %s: %s" , name , err ) } return nil }
4366	func ( p * Page ) ClearCookies ( ) error { if err := p . session . DeleteCookies ( ) ; err != nil { return fmt . Errorf ( "failed to clear cookies: %s" , err ) } return nil }
4367	func ( p * Page ) URL ( ) ( string , error ) { url , err := p . session . GetURL ( ) if err != nil { return "" , fmt . Errorf ( "failed to retrieve URL: %s" , err ) } return url , nil }
4368	func ( p * Page ) Size ( width , height int ) error { window , err := p . session . GetWindow ( ) if err != nil { return fmt . Errorf ( "failed to retrieve window: %s" , err ) } if err := window . SetSize ( width , height ) ; err != nil { return fmt . Errorf ( "failed to set window size: %s" , err ) } return nil }
4369	func ( p * Page ) Screenshot ( filename string ) error { absFilePath , err := filepath . Abs ( filename ) if err != nil { return fmt . Errorf ( "failed to find absolute path for filename: %s" , err ) } screenshot , err := p . session . GetScreenshot ( ) if err != nil { return fmt . Errorf ( "failed to retrieve screenshot: %s" , err ) } if err := ioutil . WriteFile ( absFilePath , screenshot , 0666 ) ; err != nil { return fmt . Errorf ( "failed to save screenshot: %s" , err ) } return nil }
4370	func ( p * Page ) Title ( ) ( string , error ) { title , err := p . session . GetTitle ( ) if err != nil { return "" , fmt . Errorf ( "failed to retrieve page title: %s" , err ) } return title , nil }
4371	func ( p * Page ) HTML ( ) ( string , error ) { html , err := p . session . GetSource ( ) if err != nil { return "" , fmt . Errorf ( "failed to retrieve page HTML: %s" , err ) } return html , nil }
4372	func ( p * Page ) PopupText ( ) ( string , error ) { text , err := p . session . GetAlertText ( ) if err != nil { return "" , fmt . Errorf ( "failed to retrieve popup text: %s" , err ) } return text , nil }
4373	func ( p * Page ) EnterPopupText ( text string ) error { if err := p . session . SetAlertText ( text ) ; err != nil { return fmt . Errorf ( "failed to enter popup text: %s" , err ) } return nil }
4374	func ( p * Page ) ConfirmPopup ( ) error { if err := p . session . AcceptAlert ( ) ; err != nil { return fmt . Errorf ( "failed to confirm popup: %s" , err ) } return nil }
4375	func ( p * Page ) CancelPopup ( ) error { if err := p . session . DismissAlert ( ) ; err != nil { return fmt . Errorf ( "failed to cancel popup: %s" , err ) } return nil }
4376	func ( p * Page ) SwitchToParentFrame ( ) error { if err := p . session . FrameParent ( ) ; err != nil { return fmt . Errorf ( "failed to switch to parent frame: %s" , err ) } return nil }
4377	func ( p * Page ) SwitchToRootFrame ( ) error { if err := p . session . Frame ( nil ) ; err != nil { return fmt . Errorf ( "failed to switch to original page frame: %s" , err ) } return nil }
4378	func ( p * Page ) NextWindow ( ) error { windows , err := p . session . GetWindows ( ) if err != nil { return fmt . Errorf ( "failed to find available windows: %s" , err ) } var windowIDs [ ] string for _ , window := range windows { windowIDs = append ( windowIDs , window . ID ) } sort . Strings ( windowIDs ) activeWindow , err := p . session . GetWindow ( ) if err != nil { return fmt . Errorf ( "failed to find active window: %s" , err ) } for position , windowID := range windowIDs { if windowID == activeWindow . ID { activeWindow . ID = windowIDs [ ( position + 1 ) % len ( windowIDs ) ] break } } if err := p . session . SetWindow ( activeWindow ) ; err != nil { return fmt . Errorf ( "failed to change active window: %s" , err ) } return nil }
4379	func ( p * Page ) CloseWindow ( ) error { if err := p . session . DeleteWindow ( ) ; err != nil { return fmt . Errorf ( "failed to close active window: %s" , err ) } return nil }
4380	func ( p * Page ) WindowCount ( ) ( int , error ) { windows , err := p . session . GetWindows ( ) if err != nil { return 0 , fmt . Errorf ( "failed to find available windows: %s" , err ) } return len ( windows ) , nil }
4381	func ( p * Page ) LogTypes ( ) ( [ ] string , error ) { types , err := p . session . GetLogTypes ( ) if err != nil { return nil , fmt . Errorf ( "failed to retrieve log types: %s" , err ) } return types , nil }
4382	func ( p * Page ) MoveMouseBy ( xOffset , yOffset int ) error { if err := p . session . MoveTo ( nil , api . XYOffset { X : xOffset , Y : yOffset } ) ; err != nil { return fmt . Errorf ( "failed to move mouse: %s" , err ) } return nil }
4383	func ( p * Page ) DoubleClick ( ) error { if err := p . session . DoubleClick ( ) ; err != nil { return fmt . Errorf ( "failed to double click: %s" , err ) } return nil }
4384	func ( p * Page ) Click ( event Click , button Button ) error { var err error switch event { case SingleClick : err = p . session . Click ( api . Button ( button ) ) case HoldClick : err = p . session . ButtonDown ( api . Button ( button ) ) case ReleaseClick : err = p . session . ButtonUp ( api . Button ( button ) ) default : err = errors . New ( "invalid touch event" ) } if err != nil { return fmt . Errorf ( "failed to %s %s: %s" , event , button , err ) } return nil }
4385	func ( s * Selection ) Click ( ) error { return s . forEachElement ( func ( selectedElement element . Element ) error { if err := selectedElement . Click ( ) ; err != nil { return fmt . Errorf ( "failed to click on %s: %s" , s , err ) } return nil } ) }
4386	func ( s * Selection ) DoubleClick ( ) error { return s . forEachElement ( func ( selectedElement element . Element ) error { if err := s . session . MoveTo ( selectedElement . ( * api . Element ) , nil ) ; err != nil { return fmt . Errorf ( "failed to move mouse to %s: %s" , s , err ) } if err := s . session . DoubleClick ( ) ; err != nil { return fmt . Errorf ( "failed to double-click on %s: %s" , s , err ) } return nil } ) }
4387	func ( s * Selection ) Fill ( text string ) error { return s . forEachElement ( func ( selectedElement element . Element ) error { if err := selectedElement . Clear ( ) ; err != nil { return fmt . Errorf ( "failed to clear %s: %s" , s , err ) } if err := selectedElement . Value ( text ) ; err != nil { return fmt . Errorf ( "failed to enter text into %s: %s" , s , err ) } return nil } ) }
4388	func ( s * Selection ) Tap ( event Tap ) error { var touchFunc func ( * api . Element ) error switch event { case SingleTap : touchFunc = s . session . TouchClick case DoubleTap : touchFunc = s . session . TouchDoubleClick case LongTap : touchFunc = s . session . TouchLongClick default : return fmt . Errorf ( "failed to %s on %s: invalid tap event" , event , s ) } return s . forEachElement ( func ( selectedElement element . Element ) error { if err := touchFunc ( selectedElement . ( * api . Element ) ) ; err != nil { return fmt . Errorf ( "failed to %s on %s: %s" , event , s , err ) } return nil } ) }
4389	func ( s * Selection ) Touch ( event Touch ) error { var touchFunc func ( x , y int ) error switch event { case HoldFinger : touchFunc = s . session . TouchDown case ReleaseFinger : touchFunc = s . session . TouchUp case MoveFinger : touchFunc = s . session . TouchMove default : return fmt . Errorf ( "failed to %s on %s: invalid touch event" , event , s ) } return s . forEachElement ( func ( selectedElement element . Element ) error { x , y , err := selectedElement . GetLocation ( ) if err != nil { return fmt . Errorf ( "failed to retrieve location of %s: %s" , s , err ) } if err := touchFunc ( x , y ) ; err != nil { return fmt . Errorf ( "failed to flick finger on %s: %s" , s , err ) } return nil } ) }
4390	func ( s * Selection ) FlickFinger ( xOffset , yOffset int , speed uint ) error { selectedElement , err := s . elements . GetExactlyOne ( ) if err != nil { return fmt . Errorf ( "failed to select element from %s: %s" , s , err ) } if err := s . session . TouchFlick ( selectedElement . ( * api . Element ) , api . XYOffset { X : xOffset , Y : yOffset } , api . ScalarSpeed ( speed ) ) ; err != nil { return fmt . Errorf ( "failed to flick finger on %s: %s" , s , err ) } return nil }
4391	func ( s * Selection ) ScrollFinger ( xOffset , yOffset int ) error { selectedElement , err := s . elements . GetExactlyOne ( ) if err != nil { return fmt . Errorf ( "failed to select element from %s: %s" , s , err ) } if err := s . session . TouchScroll ( selectedElement . ( * api . Element ) , api . XYOffset { X : xOffset , Y : yOffset } ) ; err != nil { return fmt . Errorf ( "failed to scroll finger on %s: %s" , s , err ) } return nil }
4392	func NewCapabilities ( features ... string ) Capabilities { c := Capabilities { } for _ , feature := range features { c . With ( feature ) } return c }
4393	func ( c Capabilities ) JSON ( ) ( string , error ) { capabilitiesJSON , err := json . Marshal ( c ) return string ( capabilitiesJSON ) , err }
4394	func HaveTitle ( title string ) types . GomegaMatcher { return & internal . ValueMatcher { Method : "Title" , Property : "title" , Expected : title } }
4395	func HaveURL ( url string ) types . GomegaMatcher { return & internal . ValueMatcher { Method : "URL" , Property : "URL" , Expected : url } }
4396	func HavePopupText ( text string ) types . GomegaMatcher { return & internal . ValueMatcher { Method : "PopupText" , Property : "popup text" , Expected : text } }
4397	func HaveLoggedError ( messages ... string ) types . GomegaMatcher { return & internal . LogMatcher { ExpectedMessages : messages , Levels : [ ] string { "WARNING" , "SEVERE" } , Name : "error" , Type : "browser" , } }
4398	func ( s * Selection ) Text ( ) ( string , error ) { selectedElement , err := s . elements . GetExactlyOne ( ) if err != nil { return "" , fmt . Errorf ( "failed to select element from %s: %s" , s , err ) } text , err := selectedElement . GetText ( ) if err != nil { return "" , fmt . Errorf ( "failed to retrieve text for %s: %s" , s , err ) } return text , nil }
4399	func ( s * Selection ) Active ( ) ( bool , error ) { selectedElement , err := s . elements . GetExactlyOne ( ) if err != nil { return false , fmt . Errorf ( "failed to select element from %s: %s" , s , err ) } activeElement , err := s . session . GetActiveElement ( ) if err != nil { return false , fmt . Errorf ( "failed to retrieve active element: %s" , err ) } equal , err := selectedElement . IsEqualTo ( activeElement ) if err != nil { return false , fmt . Errorf ( "failed to compare selection to active element: %s" , err ) } return equal , nil }
4400	func ( s * Selection ) Attribute ( attribute string ) ( string , error ) { return s . hasProperty ( element . Element . GetAttribute , attribute , "attribute" ) }
4401	func ( s * Selection ) CSS ( property string ) ( string , error ) { return s . hasProperty ( element . Element . GetCSS , property , "CSS property" ) }
4402	func ( s * Selection ) Selected ( ) ( bool , error ) { return s . hasState ( element . Element . IsSelected , "selected" ) }
4403	func ( s * Selection ) Visible ( ) ( bool , error ) { return s . hasState ( element . Element . IsDisplayed , "visible" ) }
4404	func ( s * Selection ) Enabled ( ) ( bool , error ) { return s . hasState ( element . Element . IsEnabled , "enabled" ) }
4405	func HaveCount ( count int ) types . GomegaMatcher { return & internal . ValueMatcher { Method : "Count" , Property : "element count" , Expected : count } }
4406	func HaveAttribute ( attribute string , value string ) types . GomegaMatcher { return & internal . HaveAttributeMatcher { ExpectedAttribute : attribute , ExpectedValue : value } }
4407	func EdgeDriver ( options ... Option ) * WebDriver { var binaryName string if runtime . GOOS == "windows" { binaryName = "MicrosoftWebDriver.exe" } else { return nil } command := [ ] string { binaryName , "--port={{.Port}}" } return NewWebDriver ( "http://localhost:{{.Port}}" , command , options ... ) }
4408	func Selendroid ( jarFile string , options ... Option ) * WebDriver { absJARPath , err := filepath . Abs ( jarFile ) if err != nil { return nil } command := [ ] string { "java" , "-jar" , absJARPath , "-port" , "{{.Port}}" , } options = append ( [ ] Option { Timeout ( 90 ) , Browser ( "android" ) } , options ... ) return NewWebDriver ( "http://{{.Address}}/wd/hub" , command , options ... ) }
4409	func ( s * Selection ) SwitchToFrame ( ) error { selectedElement , err := s . elements . GetExactlyOne ( ) if err != nil { return fmt . Errorf ( "failed to select element from %s: %s" , s , err ) } if err := s . session . Frame ( selectedElement . ( * api . Element ) ) ; err != nil { return fmt . Errorf ( "failed to switch to frame referred to by %s: %s" , s , err ) } return nil }
4410	func ( s * Selection ) Count ( ) ( int , error ) { elements , err := s . elements . Get ( ) if err != nil { return 0 , fmt . Errorf ( "failed to select elements from %s: %s" , s , err ) } return len ( elements ) , nil }
4411	func ( s * Selection ) EqualsElement ( other interface { } ) ( bool , error ) { otherSelection , ok := other . ( * Selection ) if ! ok { multiSelection , ok := other . ( * MultiSelection ) if ! ok { return false , fmt . Errorf ( "must be *Selection or *MultiSelection" ) } otherSelection = & multiSelection . Selection } selectedElement , err := s . elements . GetExactlyOne ( ) if err != nil { return false , fmt . Errorf ( "failed to select element from %s: %s" , s , err ) } otherElement , err := otherSelection . elements . GetExactlyOne ( ) if err != nil { return false , fmt . Errorf ( "failed to select element from %s: %s" , other , err ) } equal , err := selectedElement . IsEqualTo ( otherElement . ( * api . Element ) ) if err != nil { return false , fmt . Errorf ( "failed to compare %s to %s: %s" , s , other , err ) } return equal , nil }
4412	func ( s * Selection ) MouseToElement ( ) error { selectedElement , err := s . elements . GetExactlyOne ( ) if err != nil { return fmt . Errorf ( "failed to select element from %s: %s" , s , err ) } if err := s . session . MoveTo ( selectedElement . ( * api . Element ) , nil ) ; err != nil { return fmt . Errorf ( "failed to move mouse to element for %s: %s" , s , err ) } return nil }
4413	func loggingMiddleware ( next http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { log . Printf ( "[DEBUG] http reverse proxy received connection from %s on path %s\n" , \n , r . RemoteAddr ) r . RequestURI } ) }
4414	func chainHandlers ( mw ... Middleware ) Middleware { return func ( final http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { last := final for i := len ( mw ) - 1 ; i >= 0 ; i -- { last = mw [ i ] ( last ) } last . ServeHTTP ( w , r ) } ) } }
4415	func HTTPReverseProxy ( options Options ) ( int , error ) { port := options . ProxyPort var err error proxy := httputil . NewSingleHostReverseProxy ( & url . URL { Scheme : options . TargetScheme , Host : options . TargetAddress , } ) if port == 0 { port , err = utils . GetFreePort ( ) if err != nil { log . Println ( "[ERROR] unable to start reverse proxy server:" , err ) return 0 , err } } wrapper := chainHandlers ( append ( options . Middleware , loggingMiddleware ) ... ) log . Println ( "[DEBUG] starting reverse proxy on port" , port ) go http . ListenAndServe ( fmt . Sprintf ( ":%d" , port ) , wrapper ( proxy ) ) return port , nil }
4416	func ( i * Installer ) CheckInstallation ( ) error { for binary , versionRange := range versionMap { log . Println ( "[INFO] checking" , binary , "within range" , versionRange ) version , err := i . GetVersionForBinary ( binary ) if err != nil { return err } if err = i . CheckVersion ( binary , version ) ; err != nil { return err } } return nil }
4417	func ( i * Installer ) CheckVersion ( binary , version string ) error { log . Println ( "[DEBUG] checking version for binary" , binary , "version" , version ) v , err := goversion . NewVersion ( version ) if err != nil { log . Println ( "[DEBUG] err" , err ) return err } versionRange , ok := versionMap [ binary ] if ! ok { return fmt . Errorf ( "unable to find version range for binary %s" , binary ) } log . Println ( "[DEBUG] checking if version" , v , "within semver range" , versionRange ) constraints , err := goversion . NewConstraint ( versionRange ) if constraints . Check ( v ) { log . Println ( "[DEBUG]" , v , "satisfies constraints" , v , constraints ) return nil } return fmt . Errorf ( "version %s of %s does not match constraint %s" , version , binary , versionRange ) }
4418	func ( i * Installer ) GetVersionForBinary ( binary string ) ( version string , err error ) { log . Println ( "[DEBUG] running binary" , binary ) content , err := i . commander . Output ( binary , "version" ) elements := strings . Split ( strings . TrimSpace ( string ( content ) ) , "\n" ) \n version = strings . TrimSpace ( elements [ len ( elements ) - 1 ] ) }
4419	func ( c * Client ) getUser ( id string ) ( * ex . User , error ) { u := fmt . Sprintf ( "%s/users/%s" , c . Host , id ) req , err := http . NewRequest ( "GET" , u , nil ) req . Header . Set ( "Content-Type" , "application/json" ) req . Header . Set ( "Authorization" , c . token ) res , err := http . DefaultClient . Do ( req ) if res . StatusCode != 200 || err != nil { return nil , fmt . Errorf ( "get user failed" ) } data , err := ioutil . ReadAll ( res . Body ) if err != nil { return nil , err } var response ex . User err = json . Unmarshal ( data , & response ) if err != nil { return nil , err } return & response , err }
4420	func ( c * Client ) login ( username string , password string ) ( * ex . User , error ) { loginRequest := fmt . Sprintf ( ` { "username":"%s", "password": "%s" }` , username , password ) res , err := http . Post ( fmt . Sprintf ( "%s/login/10?foo=anything" , c . Host ) , "application/json; charset=utf-8" , bytes . NewReader ( [ ] byte ( loginRequest ) ) ) if res . StatusCode != 200 || err != nil { return nil , fmt . Errorf ( "login failed" ) } data , err := ioutil . ReadAll ( res . Body ) if err != nil { return nil , err } var response loginResponse err = json . Unmarshal ( data , & response ) if err != nil { return nil , err } return & response . User , err }
4421	func ( c * Client ) loginHandler ( w http . ResponseWriter , r * http . Request ) { username := r . FormValue ( "username" ) password := r . FormValue ( "password" ) user , err := c . login ( username , password ) if err == nil && user != nil { c . user = user c . err = nil http . Redirect ( w , r , "/" , http . StatusFound ) return } c . err = fmt . Errorf ( "Invalid username/password" ) http . Redirect ( w , r , "/" , http . StatusFound ) return }
4422	func ( c * Client ) logoutHandler ( w http . ResponseWriter , r * http . Request ) { c . user = nil c . err = nil http . Redirect ( w , r , "/" , http . StatusFound ) return }
4423	func ( c * Client ) viewHandler ( w http . ResponseWriter , r * http . Request ) { data := templateData { User : c . user , Error : c . err , } renderTemplate ( w , "login" , data ) }
4424	func ( c * Client ) Run ( ) { http . HandleFunc ( "/login" , c . loginHandler ) http . HandleFunc ( "/logout" , c . logoutHandler ) http . HandleFunc ( "/" , c . viewHandler ) fmt . Println ( "User svc client running on port 8081" ) http . ListenAndServe ( ":8081" , nil ) }
4425	func ( i * Interaction ) WithRequest ( request Request ) * Interaction { i . Request = request if isJSONFormattedObject ( request . Body ) { log . Println ( "[WARN] request body appears to be a JSON formatted object, " + "no structural matching will occur. Support for structured strings has been" + "deprecated as of 0.13.0" ) } return i }
4426	func ( i * Interaction ) WillRespondWith ( response Response ) * Interaction { i . Response = response return i }
4427	func isJSONFormattedObject ( stringOrObject interface { } ) bool { switch content := stringOrObject . ( type ) { case [ ] byte : case string : var obj interface { } err := json . Unmarshal ( [ ] byte ( content ) , & obj ) if err != nil { return false } if _ , ok := obj . ( map [ string ] interface { } ) ; ok { return true } } return false }
4428	func ( u * UserRepository ) ByUsername ( username string ) ( * User , error ) { if user , ok := u . Users [ username ] ; ok { return user , nil } return nil , ErrNotFound }
4429	func ( u * UserRepository ) ByID ( ID int ) ( * User , error ) { for _ , user := range u . Users { if user . ID == ID { return user , nil } } return nil , ErrNotFound }
4430	func UserLogin ( w http . ResponseWriter , r * http . Request ) { var login types . LoginRequest w . Header ( ) . Set ( "Content-Type" , "application/json; charset=utf-8" ) w . Header ( ) . Set ( "X-Api-Correlation-Id" , "1234" ) body , err := ioutil . ReadAll ( r . Body ) defer r . Body . Close ( ) if err != nil { w . WriteHeader ( http . StatusServiceUnavailable ) return } err = json . Unmarshal ( body , & login ) if err != nil { w . WriteHeader ( http . StatusServiceUnavailable ) return } user , err := userRepository . ByUsername ( login . Username ) if err != nil { w . WriteHeader ( http . StatusNotFound ) } else if user . Username != login . Username || user . Password != login . Password { w . WriteHeader ( http . StatusUnauthorized ) } else { w . Header ( ) . Set ( "X-Auth-Token" , getAuthToken ( ) ) w . WriteHeader ( http . StatusOK ) res := types . LoginResponse { User : user } resBody , _ := json . Marshal ( res ) w . Write ( resBody ) } }
4431	func newClient ( MockServiceManager client . Service , verificationServiceManager client . Service , messageServiceManager client . Service , publishServiceManager client . Service ) * PactClient { MockServiceManager . Setup ( ) verificationServiceManager . Setup ( ) messageServiceManager . Setup ( ) publishServiceManager . Setup ( ) return & PactClient { pactMockSvcManager : MockServiceManager , verificationSvcManager : verificationServiceManager , messageSvcManager : messageServiceManager , publishSvcManager : publishServiceManager , TimeoutDuration : 10 * time . Second , } }
4432	func NewClient ( ) * PactClient { return newClient ( & client . MockService { } , & client . VerificationService { } , & client . MessageService { } , & client . PublishService { } ) }
4433	func ( p * PactClient ) ListServers ( ) [ ] * types . MockServer { log . Println ( "[DEBUG] client: starting a server" ) var servers [ ] * types . MockServer for port , s := range p . pactMockSvcManager . List ( ) { servers = append ( servers , & types . MockServer { Pid : s . Process . Pid , Port : port , } ) } return servers }
4434	func ( p * PactClient ) UpdateMessagePact ( request types . PactMessageRequest ) error { log . Println ( "[DEBUG] client: adding pact message..." ) err := request . Validate ( ) if err != nil { return err } svc := p . messageSvcManager . NewService ( request . Args ) cmd := svc . Command ( ) stdOutPipe , err := cmd . StdoutPipe ( ) if err != nil { return err } stdErrPipe , err := cmd . StderrPipe ( ) if err != nil { return err } err = cmd . Start ( ) if err != nil { return err } stdOut , err := ioutil . ReadAll ( stdOutPipe ) if err != nil { return err } stdErr , err := ioutil . ReadAll ( stdErrPipe ) if err != nil { return err } err = cmd . Wait ( ) if err == nil { return nil } return fmt . Errorf ( "error creating message: %s\n\nSTDERR:\n%s\n\nSTDOUT:\n%s" , \n , \n , \n ) }
4435	func ( p * PactClient ) PublishPacts ( request types . PublishRequest ) error { svc := p . publishSvcManager . NewService ( request . Args ) log . Println ( "[DEBUG] about to publish pacts" ) cmd := svc . Start ( ) log . Println ( "[DEBUG] waiting for response" ) err := cmd . Wait ( ) log . Println ( "[DEBUG] response from publish" , err ) return err }
4436	func getPort ( rawURL string ) int { parsedURL , err := url . Parse ( rawURL ) if err == nil { splitHost := strings . Split ( parsedURL . Host , ":" ) if len ( splitHost ) == 2 { port , err := strconv . Atoi ( splitHost [ 1 ] ) if err == nil { return port } } if parsedURL . Scheme == "https" { return 443 } return 80 } return - 1 }
4437	func getAddress ( rawURL string ) string { parsedURL , err := url . Parse ( rawURL ) if err != nil { return "" } splitHost := strings . Split ( parsedURL . Host , ":" ) return splitHost [ 0 ] }
4438	func sanitiseRubyResponse ( response string ) string { log . Println ( "[TRACE] response from Ruby process pre-sanitisation:" , response ) r := regexp . MustCompile ( "(?m)^\\s*#.*$" ) \\ s := r . ReplaceAllString ( response , "" ) r = regexp . MustCompile ( "(?m).*bundle exec rake pact:verify.*$" ) s = r . ReplaceAllString ( s , "" ) r = regexp . MustCompile ( "\\n+" ) \\ }
4439	func ( p * Publisher ) Publish ( request types . PublishRequest ) error { log . Println ( "[DEBUG] pact publisher: publish pact" ) if p . pactClient == nil { c := NewClient ( ) p . pactClient = c } err := request . Validate ( ) if err != nil { return err } return p . pactClient . PublishPacts ( request ) }
4440	func FindPortInRange ( s string ) ( int , error ) { if ! strings . Contains ( s , "-" ) { ports := strings . Split ( strings . TrimSpace ( s ) , "," ) for _ , p := range ports { i , err := strconv . Atoi ( p ) if err != nil { return 0 , err } err = checkPort ( i ) if err != nil { continue } return i , nil } return 0 , errors . New ( "all passed ports are unusable" ) } ports := strings . Split ( strings . TrimSpace ( s ) , "-" ) if len ( ports ) != 2 { return 0 , errors . New ( "invalid range passed" ) } lower , err := strconv . Atoi ( ports [ 0 ] ) if err != nil { return 0 , err } upper , err := strconv . Atoi ( ports [ 1 ] ) if err != nil { return 0 , err } if upper < lower { return 0 , errors . New ( "invalid range passed" ) } for i := lower ; i <= upper ; i ++ { err = checkPort ( i ) if err != nil { continue } return i , nil } return 0 , errors . New ( "all passed ports are unusable" ) }
4441	func EachLike ( content interface { } , minRequired int ) Matcher { return eachLike { Contents : content , Min : minRequired , } }
4442	func Term ( generate string , matcher string ) Matcher { return term { Data : termData { Generate : generate , Matcher : termMatcher { Type : "Regexp" , O : 0 , Regex : matcher , } , } , } }
4443	func ( m * MapMatcher ) UnmarshalJSON ( bytes [ ] byte ) ( err error ) { sk := make ( map [ string ] string ) err = json . Unmarshal ( bytes , & sk ) if err != nil { return } * m = make ( map [ string ] Matcher ) for k , v := range sk { ( * m ) [ k ] = String ( v ) } return }
4444	func objectToString ( obj interface { } ) string { switch content := obj . ( type ) { case string : return content default : jsonString , err := json . Marshal ( obj ) if err != nil { log . Println ( "[DEBUG] objectToString: error unmarshaling object into string:" , err . Error ( ) ) return "" } return string ( jsonString ) } }
4445	func match ( srcType reflect . Type , params params ) Matcher { switch kind := srcType . Kind ( ) ; kind { case reflect . Ptr : return match ( srcType . Elem ( ) , params ) case reflect . Slice , reflect . Array : return EachLike ( match ( srcType . Elem ( ) , getDefaults ( ) ) , params . slice . min ) case reflect . Struct : result := StructMatcher { } for i := 0 ; i < srcType . NumField ( ) ; i ++ { field := srcType . Field ( i ) result [ field . Tag . Get ( "json" ) ] = match ( field . Type , pluckParams ( field . Type , field . Tag . Get ( "pact" ) ) ) } return result case reflect . String : if params . str . regEx != "" { return Term ( params . str . example , params . str . regEx ) } if params . str . example != "" { return Like ( params . str . example ) } return Like ( "string" ) case reflect . Bool : return Like ( true ) case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 , reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : return Like ( 1 ) case reflect . Float32 , reflect . Float64 : return Like ( 1.1 ) default : panic ( fmt . Sprintf ( "match: unhandled type: %v" , srcType ) ) } }
4446	func ( p * Pact ) AddMessage ( ) * Message { log . Println ( "[DEBUG] pact add message" ) m := & Message { } p . MessageInteractions = append ( p . MessageInteractions , m ) return m }
4447	func ( p * Pact ) AddInteraction ( ) * Interaction { p . Setup ( true ) log . Println ( "[DEBUG] pact add interaction" ) i := & Interaction { } p . Interactions = append ( p . Interactions , i ) return i }
4448	func ( p * Pact ) Teardown ( ) * Pact { log . Println ( "[DEBUG] teardown" ) if p . Server != nil { server , err := p . pactClient . StopServer ( p . Server ) if err != nil { log . Println ( "error:" , err ) } p . Server = server } return p }
4449	func ( p * Pact ) Verify ( integrationTest func ( ) error ) error { p . Setup ( true ) log . Println ( "[DEBUG] pact verify" ) if len ( p . Interactions ) == 0 { return errors . New ( "there are no interactions to be verified" ) } mockServer := & MockService { BaseURL : fmt . Sprintf ( "http://%s:%d" , p . Host , p . Server . Port ) , Consumer : p . Consumer , Provider : p . Provider , } for _ , interaction := range p . Interactions { err := mockServer . AddInteraction ( interaction ) if err != nil { return err } } err := integrationTest ( ) if err != nil { return err } err = mockServer . Verify ( ) if err != nil { return err } p . Interactions = make ( [ ] * Interaction , 0 ) return mockServer . DeleteInteractions ( ) }
4450	func stateHandlerMiddleware ( stateHandlers types . StateHandlers ) proxy . Middleware { return func ( next http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { if r . URL . Path == "/__setup" { var s * types . ProviderState decoder := json . NewDecoder ( r . Body ) decoder . Decode ( & s ) for _ , state := range s . States { sf , stateFound := stateHandlers [ state ] if ! stateFound { log . Printf ( "[WARN] state handler not found for state: %v" , state ) } else { if err := sf ( ) ; err != nil { log . Printf ( "[ERROR] state handler for '%v' errored: %v" , state , err ) w . WriteHeader ( http . StatusInternalServerError ) return } } } w . WriteHeader ( http . StatusOK ) return } log . Println ( "[DEBUG] skipping state handler for request" , r . RequestURI ) next . ServeHTTP ( w , r ) } ) } }
4451	func ( p * Pact ) VerifyMessageProviderRaw ( request VerifyMessageRequest ) ( types . ProviderVerifierResponse , error ) { p . Setup ( false ) response := types . ProviderVerifierResponse { } mux := http . NewServeMux ( ) port , err := utils . GetFreePort ( ) if err != nil { return response , fmt . Errorf ( "unable to allocate a port for verification: %v" , err ) } verificationRequest := types . VerifyRequest { ProviderBaseURL : fmt . Sprintf ( "http://localhost:%d" , port ) , PactURLs : request . PactURLs , BrokerURL : request . BrokerURL , Tags : request . Tags , BrokerUsername : request . BrokerUsername , BrokerPassword : request . BrokerPassword , BrokerToken : request . BrokerToken , PublishVerificationResults : request . PublishVerificationResults , ProviderVersion : request . ProviderVersion , Provider : p . Provider , } mux . HandleFunc ( "/" , messageVerificationHandler ( request . MessageHandlers , request . StateHandlers ) ) ln , err := net . Listen ( "tcp" , fmt . Sprintf ( ":%d" , port ) ) if err != nil { log . Fatal ( err ) } defer ln . Close ( ) log . Printf ( "[DEBUG] API handler starting: port %d (%s)" , port , ln . Addr ( ) ) go http . Serve ( ln , mux ) portErr := waitForPort ( port , "tcp" , "localhost" , p . ClientTimeout , fmt . Sprintf ( `Timed out waiting for pact proxy on port %d - check for errors` , port ) ) if portErr != nil { log . Fatal ( "Error:" , err ) return response , portErr } log . Println ( "[DEBUG] pact provider verification" ) return p . pactClient . VerifyProvider ( verificationRequest ) }
4452	func ( p * Pact ) VerifyMessageConsumerRaw ( message * Message , handler MessageConsumer ) error { log . Printf ( "[DEBUG] verify message" ) p . Setup ( false ) reified , err := p . pactClient . ReifyMessage ( & types . PactReificationRequest { Message : message . Content , } ) if err != nil { return fmt . Errorf ( "unable to convert consumer test to a valid JSON representation: %v" , err ) } t := reflect . TypeOf ( message . Type ) if t != nil && t . Name ( ) != "interface" { log . Println ( "[DEBUG] narrowing type to" , t . Name ( ) ) err = json . Unmarshal ( reified . ResponseRaw , & message . Type ) if err != nil { return fmt . Errorf ( "unable to narrow type to %v: %v" , t . Name ( ) , err ) } } generatedMessage := Message { Content : message . Type , States : message . States , Description : message . Description , Metadata : message . Metadata , } err = handler ( generatedMessage ) if err != nil { return err } return p . pactClient . UpdateMessagePact ( types . PactMessageRequest { Message : message , Consumer : p . Consumer , Provider : p . Provider , PactDir : p . PactDir , } ) }
4453	func ( p * mockClient ) VerifyProvider ( request types . VerifyRequest ) ( types . ProviderVerifierResponse , error ) { return p . VerifyProviderResponse , p . VerifyProviderError }
4454	func ( m * MockService ) NewService ( args [ ] string ) Service { m . Args = [ ] string { "service" , } m . Args = append ( m . Args , args ... ) m . Cmd = getMockServiceCommandPath ( ) return m }
4455	func ( s * ServiceManager ) Setup ( ) { log . Println ( "[DEBUG] setting up a service manager" ) s . commandCreatedChan = make ( chan * exec . Cmd ) s . commandCompleteChan = make ( chan * exec . Cmd ) s . processMap = processMap { processes : make ( map [ int ] * exec . Cmd ) } go s . addServiceMonitor ( ) go s . removeServiceMonitor ( ) }
4456	func ( s * ServiceManager ) addServiceMonitor ( ) { log . Println ( "[DEBUG] starting service creation monitor" ) for { select { case p := <- s . commandCreatedChan : if p != nil && p . Process != nil { s . processMap . Set ( p . Process . Pid , p ) } } } }
4457	func ( s * ServiceManager ) removeServiceMonitor ( ) { log . Println ( "[DEBUG] starting service removal monitor" ) var p * exec . Cmd for { select { case p = <- s . commandCompleteChan : if p != nil && p . Process != nil { p . Process . Signal ( os . Interrupt ) s . processMap . Delete ( p . Process . Pid ) } } } }
4458	func ( s * ServiceManager ) List ( ) map [ int ] * exec . Cmd { log . Println ( "[DEBUG] listing services" ) return s . processMap . processes }
4459	func ( s * ServiceManager ) Command ( ) * exec . Cmd { cmd := exec . Command ( s . Cmd , s . Args ... ) env := os . Environ ( ) env = append ( env , s . Env ... ) cmd . Env = env return cmd }
4460	func ( m * MockService ) call ( method string , url string , content interface { } ) error { body , err := json . Marshal ( content ) if err != nil { fmt . Println ( err ) return err } client := & http . Client { } var req * http . Request if method == "POST" { req , err = http . NewRequest ( method , url , bytes . NewReader ( body ) ) } else { req , err = http . NewRequest ( method , url , nil ) } if err != nil { return err } req . Header . Set ( "X-Pact-Mock-Service" , "true" ) req . Header . Set ( "Content-Type" , "application/json" ) res , err := client . Do ( req ) if err != nil { return err } responseBody , err := ioutil . ReadAll ( res . Body ) res . Body . Close ( ) if res . StatusCode < 200 || res . StatusCode >= 300 { return errors . New ( string ( responseBody ) ) } return err }
4461	func ( m * MockService ) DeleteInteractions ( ) error { log . Println ( "[DEBUG] mock service delete interactions" ) url := fmt . Sprintf ( "%s/interactions" , m . BaseURL ) return m . call ( "DELETE" , url , nil ) }
4462	func ( m * MockService ) AddInteraction ( interaction * Interaction ) error { log . Println ( "[DEBUG] mock service add interaction" ) url := fmt . Sprintf ( "%s/interactions" , m . BaseURL ) return m . call ( "POST" , url , interaction ) }
4463	func ( m * MockService ) WritePact ( ) error { log . Println ( "[DEBUG] mock service write pact" ) if m . Consumer == "" || m . Provider == "" { return errors . New ( "Consumer and Provider name need to be provided" ) } if m . PactFileWriteMode == "" { m . PactFileWriteMode = "overwrite" } pact := map [ string ] interface { } { "consumer" : map [ string ] string { "name" : m . Consumer , } , "provider" : map [ string ] string { "name" : m . Provider , } , "pactFileWriteMode" : m . PactFileWriteMode , } url := fmt . Sprintf ( "%s/pact" , m . BaseURL ) return m . call ( "POST" , url , pact ) }
4464	func ( p * Message ) ExpectsToReceive ( description string ) * Message { p . Description = description return p }
4465	func ( p * Message ) WithMetadata ( metadata MapMatcher ) * Message { p . Metadata = metadata return p }
4466	func ( p * Message ) AsType ( t interface { } ) * Message { fmt . Println ( "[DEBUG] setting Message decoding to type:" , reflect . TypeOf ( t ) ) p . Type = t return p }
4467	func UserLogin ( c * gin . Context ) { c . Header ( "X-Api-Correlation-Id" , "1234" ) var json Login if c . BindJSON ( & json ) == nil { user , err := userRepository . ByUsername ( json . User ) if err != nil { c . JSON ( http . StatusNotFound , gin . H { "status" : "file not found" } ) } else if user . Username != json . User || user . Password != json . Password { c . JSON ( http . StatusUnauthorized , gin . H { "status" : "unauthorized" } ) } else { c . Header ( "X-Auth-Token" , getAuthToken ( ) ) c . JSON ( http . StatusOK , types . LoginResponse { User : user } ) } } }
4468	func ( s * S3 ) Region ( ) string { region := os . Getenv ( "AWS_REGION" ) switch s . Domain { case "s3.amazonaws.com" , "s3-external-1.amazonaws.com" : return "us-east-1" case "s3-accelerate.amazonaws.com" : if region == "" { panic ( "can't find endpoint region" ) } return region default : regions := regionMatcher . FindStringSubmatch ( s . Domain ) if len ( regions ) < 2 { if region == "" { panic ( "can't find endpoint region" ) } return region } return regions [ 1 ] } }
4469	func New ( domain string , keys Keys ) * S3 { if domain == "" { domain = DefaultDomain } return & S3 { domain , keys } }
4470	func ( s * S3 ) Bucket ( name string ) * Bucket { return & Bucket { S3 : s , Name : name , Config : DefaultConfig , } }
4471	func ( b * Bucket ) PutWriter ( path string , h http . Header , c * Config ) ( w io . WriteCloser , err error ) { if c == nil { c = b . conf ( ) } u , err := b . url ( path , c ) if err != nil { return nil , err } return newPutter ( * u , h , c , b ) }
4472	func ( b * Bucket ) url ( bPath string , c * Config ) ( * url . URL , error ) { purl , err := url . Parse ( bPath ) if err != nil { return nil , err } var vals url . Values if v := purl . Query ( ) . Get ( versionParam ) ; v != "" { vals = make ( url . Values ) vals . Add ( versionParam , v ) bPath = strings . Split ( bPath , "?" ) [ 0 ] } if strings . Contains ( b . Name , "." ) || c . PathStyle { return & url . URL { Host : b . S3 . Domain , Scheme : c . Scheme , Path : path . Clean ( fmt . Sprintf ( "/%s/%s" , b . Name , bPath ) ) , RawQuery : vals . Encode ( ) , } , nil } else { return & url . URL { Scheme : c . Scheme , Path : path . Clean ( fmt . Sprintf ( "/%s" , bPath ) ) , Host : path . Clean ( fmt . Sprintf ( "%s.%s" , b . Name , b . S3 . Domain ) ) , RawQuery : vals . Encode ( ) , } , nil } }
4473	func SetLogger ( out io . Writer , prefix string , flag int , debug bool ) { logger = internalLogger { log . New ( out , prefix , flag ) , debug , } }
4474	func InstanceKeys ( ) ( keys Keys , err error ) { rolePath := "http://169.254.169.254/latest/meta-data/iam/security-credentials/" var creds mdCreds resp , err := ClientWithTimeout ( 2 * time . Second ) . Get ( rolePath ) if err != nil { return } defer checkClose ( resp . Body , err ) if resp . StatusCode != 200 { err = newRespError ( resp ) return } role , err := ioutil . ReadAll ( resp . Body ) if err != nil { return } resp , err = http . Get ( rolePath + string ( role ) ) if err != nil { return } defer checkClose ( resp . Body , err ) if resp . StatusCode != 200 { err = newRespError ( resp ) return } metadata , err := ioutil . ReadAll ( resp . Body ) if err != nil { return } if err = json . Unmarshal ( [ ] byte ( metadata ) , & creds ) ; err != nil { return } keys = Keys { AccessKey : creds . AccessKeyID , SecretKey : creds . SecretAccessKey , SecurityToken : creds . Token , } return }
4475	func EnvKeys ( ) ( keys Keys , err error ) { keys = Keys { AccessKey : os . Getenv ( "AWS_ACCESS_KEY_ID" ) , SecretKey : os . Getenv ( "AWS_SECRET_ACCESS_KEY" ) , SecurityToken : os . Getenv ( "AWS_SECURITY_TOKEN" ) , } if keys . AccessKey == "" || keys . SecretKey == "" { err = fmt . Errorf ( "keys not set in environment: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY" ) } return }
4476	func ( b * Bucket ) Sign ( req * http . Request ) { if req . Header == nil { req . Header = http . Header { } } if b . S3 . Keys . SecurityToken != "" { req . Header . Set ( "X-Amz-Security-Token" , b . S3 . Keys . SecurityToken ) } req . Header . Set ( "User-Agent" , "S3Gof3r" ) s := & signer { Time : time . Now ( ) , Request : req , Region : b . S3 . Region ( ) , Keys : b . S3 . Keys , } s . sign ( ) }
4477	func getAWSKeys ( ) ( keys s3gof3r . Keys , err error ) { keys , err = s3gof3r . EnvKeys ( ) if err == nil { return } keys , err = s3gof3r . InstanceKeys ( ) if err == nil { return } err = errors . New ( "no AWS keys found" ) return }
4478	func homeDir ( ) ( string , error ) { if h := os . Getenv ( "HOME" ) ; h != "" { return h , nil } h , err := exec . Command ( "sh" , "-c" , "eval echo ~$USER" ) . Output ( ) if err == nil && len ( h ) > 0 { return strings . TrimSpace ( string ( h ) ) , nil } return "" , fmt . Errorf ( "home directory not found for current user" ) }
4479	func ACL ( h http . Header , acl string ) http . Header { if acl != "" { h . Set ( "x-amz-acl" , acl ) } return h }
4480	func ( p * putter ) putPart ( part * part ) error { v := url . Values { } v . Set ( "partNumber" , strconv . Itoa ( part . PartNumber ) ) v . Set ( "uploadId" , p . UploadID ) if _ , err := part . r . Seek ( 0 , 0 ) ; err != nil { return err } req , err := http . NewRequest ( "PUT" , p . url . String ( ) + "?" + v . Encode ( ) , part . r ) if err != nil { return err } req . ContentLength = part . len req . Header . Set ( md5Header , part . md5 ) req . Header . Set ( sha256Header , part . sha256 ) p . b . Sign ( req ) resp , err := p . c . Client . Do ( req ) if err != nil { return err } defer checkClose ( resp . Body , err ) if resp . StatusCode != 200 { return newRespError ( resp ) } s := resp . Header . Get ( "etag" ) if len ( s ) < 2 { return fmt . Errorf ( "Got Bad etag:%s" , s ) } s = s [ 1 : len ( s ) - 1 ] if part . ETag != s { return fmt . Errorf ( "Response etag does not match. Remote:%s Calculated:%s" , s , p . ETag ) } return nil }
4481	func ( p * putter ) abort ( ) { v := url . Values { } v . Set ( "uploadId" , p . UploadID ) s := p . url . String ( ) + "?" + v . Encode ( ) resp , err := p . retryRequest ( "DELETE" , s , nil , nil ) if err != nil { logger . Printf ( "Error aborting multipart upload: %v\n" , \n ) err } return defer checkClose ( resp . Body , err ) if resp . StatusCode != 204 { logger . Printf ( "Error aborting multipart upload: %v" , newRespError ( resp ) ) } }
4482	func growPartSize ( partIndex int , partSize , putsz int64 ) bool { return ( maxObjSize - putsz ) / ( maxNPart - int64 ( partIndex ) ) > partSize }
4483	func CheckDisallowed ( prefix string , spec interface { } ) error { infos , err := gatherInfo ( prefix , spec ) if err != nil { return err } vars := make ( map [ string ] struct { } ) for _ , info := range infos { vars [ info . Key ] = struct { } { } } if prefix != "" { prefix = strings . ToUpper ( prefix ) + "_" } for _ , env := range os . Environ ( ) { if ! strings . HasPrefix ( env , prefix ) { continue } v := strings . SplitN ( env , "=" , 2 ) [ 0 ] if _ , found := vars [ v ] ; ! found { return fmt . Errorf ( "unknown environment variable %s" , v ) } } return nil }
4484	func Process ( prefix string , spec interface { } ) error { infos , err := gatherInfo ( prefix , spec ) for _ , info := range infos { value , ok := lookupEnv ( info . Key ) if ! ok && info . Alt != "" { value , ok = lookupEnv ( info . Alt ) } def := info . Tags . Get ( "default" ) if def != "" && ! ok { value = def } req := info . Tags . Get ( "required" ) if ! ok && def == "" { if isTrue ( req ) { return fmt . Errorf ( "required key %s missing value" , info . Key ) } continue } err = processField ( value , info . Field ) if err != nil { return & ParseError { KeyName : info . Key , FieldName : info . Name , TypeName : info . Field . Type ( ) . String ( ) , Value : value , Err : err , } } } return err }
4485	func MustProcess ( prefix string , spec interface { } ) { if err := Process ( prefix , spec ) ; err != nil { panic ( err ) } }
4486	func toTypeDescription ( t reflect . Type ) string { switch t . Kind ( ) { case reflect . Array , reflect . Slice : return fmt . Sprintf ( "Comma-separated list of %s" , toTypeDescription ( t . Elem ( ) ) ) case reflect . Map : return fmt . Sprintf ( "Comma-separated list of %s:%s pairs" , toTypeDescription ( t . Key ( ) ) , toTypeDescription ( t . Elem ( ) ) , ) case reflect . Ptr : return toTypeDescription ( t . Elem ( ) ) case reflect . Struct : if implementsInterface ( t ) && t . Name ( ) != "" { return t . Name ( ) } return "" case reflect . String : name := t . Name ( ) if name != "" && name != "string" { return name } return "String" case reflect . Bool : name := t . Name ( ) if name != "" && name != "bool" { return name } return "True or False" case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : name := t . Name ( ) if name != "" && ! strings . HasPrefix ( name , "int" ) { return name } return "Integer" case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : name := t . Name ( ) if name != "" && ! strings . HasPrefix ( name , "uint" ) { return name } return "Unsigned Integer" case reflect . Float32 , reflect . Float64 : name := t . Name ( ) if name != "" && ! strings . HasPrefix ( name , "float" ) { return name } return "Float" } return fmt . Sprintf ( "%+v" , t ) }
4487	func Usage ( prefix string , spec interface { } ) error { tabs := tabwriter . NewWriter ( os . Stdout , 1 , 0 , 4 , ' ' , 0 ) err := Usagef ( prefix , spec , tabs , DefaultTableFormat ) tabs . Flush ( ) return err }
4488	func Usagef ( prefix string , spec interface { } , out io . Writer , format string ) error { functions := template . FuncMap { "usage_key" : func ( v varInfo ) string { return v . Key } , "usage_description" : func ( v varInfo ) string { return v . Tags . Get ( "desc" ) } , "usage_type" : func ( v varInfo ) string { return toTypeDescription ( v . Field . Type ( ) ) } , "usage_default" : func ( v varInfo ) string { return v . Tags . Get ( "default" ) } , "usage_required" : func ( v varInfo ) ( string , error ) { req := v . Tags . Get ( "required" ) if req != "" { reqB , err := strconv . ParseBool ( req ) if err != nil { return "" , err } if reqB { req = "true" } } return req , nil } , } tmpl , err := template . New ( "envconfig" ) . Funcs ( functions ) . Parse ( format ) if err != nil { return err } return Usaget ( prefix , spec , out , tmpl ) }
4489	func Usaget ( prefix string , spec interface { } , out io . Writer , tmpl * template . Template ) error { infos , err := gatherInfo ( prefix , spec ) if err != nil { return err } return tmpl . Execute ( out , infos ) }
4490	func ( t * Time ) Scan ( value interface { } ) error { var err error switch x := value . ( type ) { case time . Time : t . Time = x case nil : t . Valid = false return nil default : err = fmt . Errorf ( "null: cannot scan type %T into null.Time: %v" , value , value ) } t . Valid = err == nil return err }
4491	func ( t Time ) Value ( ) ( driver . Value , error ) { if ! t . Valid { return nil , nil } return t . Time , nil }
4492	func NewTime ( t time . Time , valid bool ) Time { return Time { Time : t , Valid : valid , } }
4493	func TimeFromPtr ( t * time . Time ) Time { if t == nil { return NewTime ( time . Time { } , false ) } return NewTime ( * t , true ) }
4494	func ( t Time ) ValueOrZero ( ) time . Time { if ! t . Valid { return time . Time { } } return t . Time }
4495	func ( t Time ) MarshalJSON ( ) ( [ ] byte , error ) { if ! t . Valid { return [ ] byte ( "null" ) , nil } return t . Time . MarshalJSON ( ) }
4496	func ( t * Time ) SetValid ( v time . Time ) { t . Time = v t . Valid = true }
4497	func ( t Time ) Ptr ( ) * time . Time { if ! t . Valid { return nil } return & t . Time }
4498	func NewBool ( b bool , valid bool ) Bool { return Bool { NullBool : sql . NullBool { Bool : b , Valid : valid , } , } }
4499	func BoolFromPtr ( b * bool ) Bool { if b == nil { return NewBool ( false , false ) } return NewBool ( * b , true ) }
4500	func ( b * Bool ) UnmarshalJSON ( data [ ] byte ) error { var err error var v interface { } if err = json . Unmarshal ( data , & v ) ; err != nil { return err } switch x := v . ( type ) { case bool : b . Bool = x case map [ string ] interface { } : err = json . Unmarshal ( data , & b . NullBool ) case nil : b . Valid = false return nil default : err = fmt . Errorf ( "json: cannot unmarshal %v into Go value of type null.Bool" , reflect . TypeOf ( v ) . Name ( ) ) } b . Valid = err == nil return err }
4501	func ( b * Bool ) UnmarshalText ( text [ ] byte ) error { str := string ( text ) switch str { case "" , "null" : b . Valid = false return nil case "true" : b . Bool = true case "false" : b . Bool = false default : b . Valid = false return errors . New ( "invalid input:" + str ) } b . Valid = true return nil }
4502	func ( b Bool ) MarshalJSON ( ) ( [ ] byte , error ) { if ! b . Valid { return [ ] byte ( "null" ) , nil } if ! b . Bool { return [ ] byte ( "false" ) , nil } return [ ] byte ( "true" ) , nil }
4503	func ( b * Bool ) SetValid ( v bool ) { b . Bool = v b . Valid = true }
4504	func NewString ( s string , valid bool ) String { return String { NullString : sql . NullString { String : s , Valid : valid , } , } }
4505	func ( s * String ) UnmarshalJSON ( data [ ] byte ) error { var err error var v interface { } if err = json . Unmarshal ( data , & v ) ; err != nil { return err } switch x := v . ( type ) { case string : s . String = x case map [ string ] interface { } : err = json . Unmarshal ( data , & s . NullString ) case nil : s . Valid = false return nil default : err = fmt . Errorf ( "json: cannot unmarshal %v into Go value of type zero.String" , reflect . TypeOf ( v ) . Name ( ) ) } s . Valid = ( err == nil ) && ( s . String != "" ) return err }
4506	func ( s String ) MarshalText ( ) ( [ ] byte , error ) { if ! s . Valid { return [ ] byte { } , nil } return [ ] byte ( s . String ) , nil }
4507	func ( s * String ) UnmarshalText ( text [ ] byte ) error { s . String = string ( text ) s . Valid = s . String != "" return nil }
4508	func ( s * String ) SetValid ( v string ) { s . String = v s . Valid = true }
4509	func StringFromPtr ( s * string ) String { if s == nil { return NewString ( "" , false ) } return NewString ( * s , true ) }
4510	func ( s String ) MarshalJSON ( ) ( [ ] byte , error ) { if ! s . Valid { return [ ] byte ( "null" ) , nil } return json . Marshal ( s . String ) }
4511	func NewInt ( i int64 , valid bool ) Int { return Int { NullInt64 : sql . NullInt64 { Int64 : i , Valid : valid , } , } }
4512	func IntFromPtr ( i * int64 ) Int { if i == nil { return NewInt ( 0 , false ) } n := NewInt ( * i , true ) return n }
4513	func ( i * Int ) UnmarshalJSON ( data [ ] byte ) error { var err error var v interface { } if err = json . Unmarshal ( data , & v ) ; err != nil { return err } switch x := v . ( type ) { case float64 : err = json . Unmarshal ( data , & i . Int64 ) case string : str := string ( x ) if len ( str ) == 0 { i . Valid = false return nil } i . Int64 , err = strconv . ParseInt ( str , 10 , 64 ) case map [ string ] interface { } : err = json . Unmarshal ( data , & i . NullInt64 ) case nil : i . Valid = false return nil default : err = fmt . Errorf ( "json: cannot unmarshal %v into Go value of type zero.Int" , reflect . TypeOf ( v ) . Name ( ) ) } i . Valid = ( err == nil ) && ( i . Int64 != 0 ) return err }
4514	func ( i Int ) MarshalText ( ) ( [ ] byte , error ) { n := i . Int64 if ! i . Valid { n = 0 } return [ ] byte ( strconv . FormatInt ( n , 10 ) ) , nil }
4515	func ( i * Int ) SetValid ( n int64 ) { i . Int64 = n i . Valid = true }
4516	func ( i * Int ) UnmarshalText ( text [ ] byte ) error { str := string ( text ) if str == "" || str == "null" { i . Valid = false return nil } var err error i . Int64 , err = strconv . ParseInt ( string ( text ) , 10 , 64 ) i . Valid = err == nil return err }
4517	func ( b Bool ) MarshalText ( ) ( [ ] byte , error ) { if ! b . Valid || ! b . Bool { return [ ] byte ( "false" ) , nil } return [ ] byte ( "true" ) , nil }
4518	func ( f * Float ) SetValid ( v float64 ) { f . Float64 = v f . Valid = true }
4519	func ( t Time ) MarshalJSON ( ) ( [ ] byte , error ) { if ! t . Valid { return ( time . Time { } ) . MarshalJSON ( ) } return t . Time . MarshalJSON ( ) }
4520	func ( f * Float ) UnmarshalJSON ( data [ ] byte ) error { var err error var v interface { } if err = json . Unmarshal ( data , & v ) ; err != nil { return err } switch x := v . ( type ) { case float64 : f . Float64 = float64 ( x ) case string : str := string ( x ) if len ( str ) == 0 { f . Valid = false return nil } f . Float64 , err = strconv . ParseFloat ( str , 64 ) case map [ string ] interface { } : err = json . Unmarshal ( data , & f . NullFloat64 ) case nil : f . Valid = false return nil default : err = fmt . Errorf ( "json: cannot unmarshal %v into Go value of type null.Float" , reflect . TypeOf ( v ) . Name ( ) ) } f . Valid = err == nil return err }
4521	func ( f * Float ) UnmarshalText ( text [ ] byte ) error { str := string ( text ) if str == "" || str == "null" { f . Valid = false return nil } var err error f . Float64 , err = strconv . ParseFloat ( string ( text ) , 64 ) f . Valid = err == nil return err }
4522	func ( f Float ) MarshalJSON ( ) ( [ ] byte , error ) { if ! f . Valid { return [ ] byte ( "null" ) , nil } if math . IsInf ( f . Float64 , 0 ) || math . IsNaN ( f . Float64 ) { return nil , & json . UnsupportedValueError { Value : reflect . ValueOf ( f . Float64 ) , Str : strconv . FormatFloat ( f . Float64 , 'g' , - 1 , 64 ) , } } return [ ] byte ( strconv . FormatFloat ( f . Float64 , 'f' , - 1 , 64 ) ) , nil }
4523	func newGossipChannel ( channelName string , ourself * localPeer , r * routes , g Gossiper , logger Logger ) * gossipChannel { return & gossipChannel { name : channelName , ourself : ourself , routes : r , gossiper : g , logger : logger , } }
4524	func ( c * gossipChannel ) GossipUnicast ( dstPeerName PeerName , msg [ ] byte ) error { return c . relayUnicast ( dstPeerName , gobEncode ( c . name , c . ourself . Name , dstPeerName , msg ) ) }
4525	func ( c * gossipChannel ) GossipBroadcast ( update GossipData ) { c . relayBroadcast ( c . ourself . Name , update ) }
4526	func ( c * gossipChannel ) Send ( data GossipData ) { c . relay ( c . ourself . Name , data ) }
4527	func ( c * gossipChannel ) SendDown ( conn Connection , data GossipData ) { c . senderFor ( conn ) . Send ( data ) }
4528	func gobEncode ( items ... interface { } ) [ ] byte { buf := new ( bytes . Buffer ) enc := gob . NewEncoder ( buf ) for _ , i := range items { if err := enc . Encode ( i ) ; err != nil { panic ( err ) } } return buf . Bytes ( ) }
4529	func newTokenBucket ( capacity int64 , tokenInterval time . Duration ) * tokenBucket { tb := tokenBucket { capacity : capacity , tokenInterval : tokenInterval , refillDuration : tokenInterval * time . Duration ( capacity ) } tb . earliestUnspentToken = tb . capacityToken ( ) return & tb }
4530	func ( tb * tokenBucket ) wait ( ) { time . Sleep ( time . Until ( tb . earliestUnspentToken ) ) capacityToken := tb . capacityToken ( ) if tb . earliestUnspentToken . Before ( capacityToken ) { tb . earliestUnspentToken = capacityToken } tb . earliestUnspentToken = tb . earliestUnspentToken . Add ( tb . tokenInterval ) }
4531	func ( tb * tokenBucket ) capacityToken ( ) time . Time { return time . Now ( ) . Add ( - tb . refillDuration ) . Truncate ( tb . tokenInterval ) }
4532	func PrefixRangeEnd ( prefix [ ] byte ) [ ] byte { end := make ( [ ] byte , len ( prefix ) ) copy ( end , prefix ) for i := len ( end ) - 1 ; i >= 0 ; i -- { if end [ i ] < 0xff { end [ i ] = end [ i ] + 1 end = end [ : i + 1 ] return end } } return [ ] byte { 0 } }
4533	func newLocalPeer ( name PeerName , nickName string , router * Router ) * localPeer { actionChan := make ( chan localPeerAction , ChannelSize ) peer := & localPeer { Peer : newPeer ( name , nickName , randomPeerUID ( ) , 0 , randomPeerShortID ( ) ) , router : router , actionChan : actionChan , } go peer . actorLoop ( actionChan ) return peer }
4534	func ( peer * localPeer ) getConnections ( ) connectionSet { connections := make ( connectionSet ) peer . RLock ( ) defer peer . RUnlock ( ) for _ , conn := range peer . connections { connections [ conn ] = struct { } { } } return connections }
4535	func ( peer * localPeer ) createConnection ( localAddr string , peerAddr string , acceptNewPeer bool , logger Logger ) error { if err := peer . checkConnectionLimit ( ) ; err != nil { return err } localTCPAddr , err := net . ResolveTCPAddr ( "tcp" , localAddr ) if err != nil { return err } remoteTCPAddr , err := net . ResolveTCPAddr ( "tcp" , peerAddr ) if err != nil { return err } tcpConn , err := net . DialTCP ( "tcp" , localTCPAddr , remoteTCPAddr ) if err != nil { return err } connRemote := newRemoteConnection ( peer . Peer , nil , peerAddr , true , false ) startLocalConnection ( connRemote , tcpConn , peer . router , acceptNewPeer , logger ) return nil }
4536	func ( peer * localPeer ) doAddConnection ( conn ourConnection , isRestartedPeer bool ) error { resultChan := make ( chan error ) peer . actionChan <- func ( ) { resultChan <- peer . handleAddConnection ( conn , isRestartedPeer ) } return <- resultChan }
4537	func startLocalConnection ( connRemote * remoteConnection , tcpConn * net . TCPConn , router * Router , acceptNewPeer bool , logger Logger ) { if connRemote . local != router . Ourself . Peer { panic ( "attempt to create local connection from a peer which is not ourself" ) } errorChan := make ( chan error , 1 ) finished := make ( chan struct { } ) conn := & LocalConnection { remoteConnection : * connRemote , router : router , tcpConn : tcpConn , trustRemote : router . trusts ( connRemote ) , uid : randUint64 ( ) , errorChan : errorChan , finished : finished , logger : logger , } conn . senders = newGossipSenders ( conn , finished ) go conn . run ( errorChan , finished , acceptNewPeer ) }
4538	func ( conn * LocalConnection ) SendProtocolMsg ( m protocolMsg ) error { if err := conn . sendProtocolMsg ( m ) ; err != nil { conn . shutdown ( err ) return err } return nil }
4539	func NewStatus ( router * Router ) * Status { return & Status { Protocol : Protocol , ProtocolMinVersion : int ( router . ProtocolMinVersion ) , ProtocolMaxVersion : ProtocolMaxVersion , Encryption : router . usingPassword ( ) , PeerDiscovery : router . PeerDiscovery , Name : router . Ourself . Name . String ( ) , NickName : router . Ourself . NickName , Port : router . Port , Peers : makePeerStatusSlice ( router . Peers ) , UnicastRoutes : makeUnicastRouteStatusSlice ( router . Routes ) , BroadcastRoutes : makeBroadcastRouteStatusSlice ( router . Routes ) , Connections : makeLocalConnectionStatusSlice ( router . ConnectionMaker ) , TerminationCount : router . ConnectionMaker . terminationCount , Targets : router . ConnectionMaker . Targets ( false ) , OverlayDiagnostics : router . Overlay . Diagnostics ( ) , TrustedSubnets : makeTrustedSubnetsSlice ( router . TrustedSubnets ) , } }
4540	func makePeerStatusSlice ( peers * Peers ) [ ] PeerStatus { var slice [ ] PeerStatus peers . forEach ( func ( peer * Peer ) { var connections [ ] connectionStatus if peer == peers . ourself . Peer { for conn := range peers . ourself . getConnections ( ) { connections = append ( connections , makeConnectionStatus ( conn ) ) } } else { for _ , conn := range peer . connections { connections = append ( connections , makeConnectionStatus ( conn ) ) } } slice = append ( slice , PeerStatus { peer . Name . String ( ) , peer . NickName , peer . UID , peer . ShortID , peer . Version , connections , } ) } ) return slice }
4541	func makeUnicastRouteStatusSlice ( r * routes ) [ ] unicastRouteStatus { r . RLock ( ) defer r . RUnlock ( ) var slice [ ] unicastRouteStatus for dest , via := range r . unicast { slice = append ( slice , unicastRouteStatus { dest . String ( ) , via . String ( ) } ) } return slice }
4542	func makeBroadcastRouteStatusSlice ( r * routes ) [ ] broadcastRouteStatus { r . RLock ( ) defer r . RUnlock ( ) var slice [ ] broadcastRouteStatus for source , via := range r . broadcast { var hops [ ] string for _ , hop := range via { hops = append ( hops , hop . String ( ) ) } slice = append ( slice , broadcastRouteStatus { source . String ( ) , hops } ) } return slice }
4543	func makeLocalConnectionStatusSlice ( cm * connectionMaker ) [ ] LocalConnectionStatus { resultChan := make ( chan [ ] LocalConnectionStatus ) cm . actionChan <- func ( ) bool { var slice [ ] LocalConnectionStatus for conn := range cm . connections { state := "pending" if conn . isEstablished ( ) { state = "established" } lc , _ := conn . ( * LocalConnection ) attrs := lc . OverlayConn . Attrs ( ) name , ok := attrs [ "name" ] if ! ok { name = "none" } info := fmt . Sprintf ( "%-6v %v" , name , conn . Remote ( ) ) if lc . router . usingPassword ( ) { if lc . untrusted ( ) { info = fmt . Sprintf ( "%-11v %v" , "encrypted" , info ) if attrs != nil { attrs [ "encrypted" ] = true } } else { info = fmt . Sprintf ( "%-11v %v" , "unencrypted" , info ) } } slice = append ( slice , LocalConnectionStatus { conn . remoteTCPAddress ( ) , conn . isOutbound ( ) , state , info , attrs } ) } for address , target := range cm . targets { add := func ( state , info string ) { slice = append ( slice , LocalConnectionStatus { address , true , state , info , nil } ) } switch target . state { case targetWaiting : until := "never" if ! target . tryAfter . IsZero ( ) { until = target . tryAfter . String ( ) } if target . lastError == nil { add ( "waiting" , "until: " + until ) } else { add ( "failed" , target . lastError . Error ( ) + ", retry: " + until ) } case targetAttempting : if target . lastError == nil { add ( "connecting" , "" ) } else { add ( "retrying" , target . lastError . Error ( ) ) } case targetConnected : case targetSuspended : } } resultChan <- slice return false } return <- resultChan }
4544	func makeTrustedSubnetsSlice ( trustedSubnets [ ] * net . IPNet ) [ ] string { trustedSubnetStrs := [ ] string { } for _ , trustedSubnet := range trustedSubnets { trustedSubnetStrs = append ( trustedSubnetStrs , trustedSubnet . String ( ) ) } return trustedSubnetStrs }
4545	func ( s * etcdStore ) Range ( ctx context . Context , req * etcdserverpb . RangeRequest ) ( * etcdserverpb . RangeResponse , error ) { ireq := etcdserverpb . InternalRaftRequest { ID : <- s . idgen , Range : req } msgc , errc , err := s . proposeInternalRaftRequest ( ireq ) if err != nil { return nil , err } select { case <- ctx . Done ( ) : s . cancelInternalRaftRequest ( ireq ) return nil , ctx . Err ( ) case msg := <- msgc : return msg . ( * etcdserverpb . RangeResponse ) , nil case err := <- errc : return nil , err case <- s . quitc : return nil , errStopped } }
4546	func ( s * etcdStore ) Put ( ctx context . Context , req * etcdserverpb . PutRequest ) ( * etcdserverpb . PutResponse , error ) { ireq := etcdserverpb . InternalRaftRequest { ID : <- s . idgen , Put : req } msgc , errc , err := s . proposeInternalRaftRequest ( ireq ) if err != nil { return nil , err } select { case <- ctx . Done ( ) : s . cancelInternalRaftRequest ( ireq ) return nil , ctx . Err ( ) case msg := <- msgc : return msg . ( * etcdserverpb . PutResponse ) , nil case err := <- errc : return nil , err case <- s . quitc : return nil , errStopped } }
4547	func ( s * etcdStore ) DeleteRange ( ctx context . Context , req * etcdserverpb . DeleteRangeRequest ) ( * etcdserverpb . DeleteRangeResponse , error ) { ireq := etcdserverpb . InternalRaftRequest { ID : <- s . idgen , DeleteRange : req } msgc , errc , err := s . proposeInternalRaftRequest ( ireq ) if err != nil { return nil , err } select { case <- ctx . Done ( ) : s . cancelInternalRaftRequest ( ireq ) return nil , ctx . Err ( ) case msg := <- msgc : return msg . ( * etcdserverpb . DeleteRangeResponse ) , nil case err := <- errc : return nil , err case <- s . quitc : return nil , errStopped } }
4548	func ( s * etcdStore ) Txn ( ctx context . Context , req * etcdserverpb . TxnRequest ) ( * etcdserverpb . TxnResponse , error ) { ireq := etcdserverpb . InternalRaftRequest { ID : <- s . idgen , Txn : req } msgc , errc , err := s . proposeInternalRaftRequest ( ireq ) if err != nil { return nil , err } select { case <- ctx . Done ( ) : s . cancelInternalRaftRequest ( ireq ) return nil , ctx . Err ( ) case msg := <- msgc : return msg . ( * etcdserverpb . TxnResponse ) , nil case err := <- errc : return nil , err case <- s . quitc : return nil , errStopped } }
4549	func ( s * etcdStore ) Compact ( ctx context . Context , req * etcdserverpb . CompactionRequest ) ( * etcdserverpb . CompactionResponse , error ) { return nil , errors . New ( "not implemented" ) }
4550	func ( s * etcdStore ) proposeInternalRaftRequest ( req etcdserverpb . InternalRaftRequest ) ( <- chan proto . Message , <- chan error , error ) { data , err := req . Marshal ( ) if err != nil { return nil , nil , err } if len ( data ) > maxRequestBytes { return nil , nil , errTooBig } msgc , errc , err := s . registerPending ( req . ID ) if err != nil { return nil , nil , err } s . proposalc <- data return msgc , errc , nil }
4551	func applyCompare ( kv mvcc . KV , c * etcdserverpb . Compare ) ( int64 , bool ) { ckvs , rev , err := kv . Range ( c . Key , nil , 1 , 0 ) if err != nil { if err == mvcc . ErrTxnIDMismatch { panic ( "unexpected txn ID mismatch error" ) } return rev , false } var ckv mvccpb . KeyValue if len ( ckvs ) != 0 { ckv = ckvs [ 0 ] } else { if c . Target == etcdserverpb . Compare_VALUE { return rev , false } } var result int switch c . Target { case etcdserverpb . Compare_VALUE : tv , _ := c . TargetUnion . ( * etcdserverpb . Compare_Value ) if tv != nil { result = bytes . Compare ( ckv . Value , tv . Value ) } case etcdserverpb . Compare_CREATE : tv , _ := c . TargetUnion . ( * etcdserverpb . Compare_CreateRevision ) if tv != nil { result = compareInt64 ( ckv . CreateRevision , tv . CreateRevision ) } case etcdserverpb . Compare_MOD : tv , _ := c . TargetUnion . ( * etcdserverpb . Compare_ModRevision ) if tv != nil { result = compareInt64 ( ckv . ModRevision , tv . ModRevision ) } case etcdserverpb . Compare_VERSION : tv , _ := c . TargetUnion . ( * etcdserverpb . Compare_Version ) if tv != nil { result = compareInt64 ( ckv . Version , tv . Version ) } } switch c . Result { case etcdserverpb . Compare_EQUAL : if result != 0 { return rev , false } case etcdserverpb . Compare_GREATER : if result != 1 { return rev , false } case etcdserverpb . Compare_LESS : if result != - 1 { return rev , false } } return rev , true }
4552	func ( peers * Peers ) Descriptions ( ) [ ] PeerDescription { peers . RLock ( ) defer peers . RUnlock ( ) descriptions := make ( [ ] PeerDescription , 0 , len ( peers . byName ) ) for _ , peer := range peers . byName { descriptions = append ( descriptions , PeerDescription { Name : peer . Name , NickName : peer . peerSummary . NickName , UID : peer . UID , Self : peer . Name == peers . ourself . Name , NumConnections : len ( peer . connections ) , } ) } return descriptions }
4553	func ( peers * Peers ) OnGC ( callback func ( * Peer ) ) { peers . Lock ( ) defer peers . Unlock ( ) peers . onGC = append ( peers . onGC , callback ) }
4554	func ( peers * Peers ) OnInvalidateShortIDs ( callback func ( ) ) { peers . Lock ( ) defer peers . Unlock ( ) peers . onInvalidateShortIDs = append ( peers . onInvalidateShortIDs , callback ) }
4555	func ( peers * Peers ) chooseShortID ( ) ( PeerShortID , bool ) { rng := rand . New ( rand . NewSource ( int64 ( randUint64 ( ) ) ) ) for i := 0 ; i < 10 ; i ++ { shortID := PeerShortID ( rng . Intn ( 1 << peerShortIDBits ) ) if peers . byShortID [ shortID ] . peer == nil { return shortID , true } } available := int ( 1 << peerShortIDBits ) for _ , entry := range peers . byShortID { if entry . peer != nil { available -- } } if available == 0 { return 0 , false } n := rng . Intn ( available ) var i PeerShortID for { if peers . byShortID [ i ] . peer == nil { if n == 0 { return i , true } n -- } i ++ } }
4556	func ( peers * Peers ) fetchWithDefault ( peer * Peer ) * Peer { peers . Lock ( ) var pending peersPendingNotifications defer peers . unlockAndNotify ( & pending ) if existingPeer , found := peers . byName [ peer . Name ] ; found { existingPeer . localRefCount ++ return existingPeer } peers . byName [ peer . Name ] = peer peers . addByShortID ( peer , & pending ) peer . localRefCount ++ return peer }
4557	func ( peers * Peers ) Fetch ( name PeerName ) * Peer { peers . RLock ( ) defer peers . RUnlock ( ) return peers . byName [ name ] }
4558	func ( peers * Peers ) fetchAndAddRef ( name PeerName ) * Peer { peers . Lock ( ) defer peers . Unlock ( ) peer := peers . byName [ name ] if peer != nil { peer . localRefCount ++ } return peer }
4559	func ( peers * Peers ) FetchByShortID ( shortID PeerShortID ) * Peer { peers . RLock ( ) defer peers . RUnlock ( ) return peers . byShortID [ shortID ] . peer }
4560	func ( peers * Peers ) GarbageCollect ( ) { peers . Lock ( ) var pending peersPendingNotifications defer peers . unlockAndNotify ( & pending ) peers . garbageCollect ( & pending ) }
4561	func newRoutes ( ourself * localPeer , peers * Peers ) * routes { recalculate := make ( chan * struct { } , 1 ) wait := make ( chan chan struct { } ) action := make ( chan func ( ) ) r := & routes { ourself : ourself , peers : peers , unicast : unicastRoutes { ourself . Name : UnknownPeerName } , unicastAll : unicastRoutes { ourself . Name : UnknownPeerName } , broadcast : broadcastRoutes { ourself . Name : [ ] PeerName { } } , broadcastAll : broadcastRoutes { ourself . Name : [ ] PeerName { } } , recalc : recalculate , wait : wait , action : action , } go r . run ( recalculate , wait , action ) return r }
4562	func ( r * routes ) OnChange ( callback func ( ) ) { r . Lock ( ) defer r . Unlock ( ) r . onChange = append ( r . onChange , callback ) }
4563	func ( r * routes ) Unicast ( name PeerName ) ( PeerName , bool ) { r . RLock ( ) defer r . RUnlock ( ) hop , found := r . unicast [ name ] return hop , found }
4564	func ( r * routes ) UnicastAll ( name PeerName ) ( PeerName , bool ) { r . RLock ( ) defer r . RUnlock ( ) hop , found := r . unicastAll [ name ] return hop , found }
4565	func ( r * routes ) Broadcast ( name PeerName ) [ ] PeerName { return r . lookupOrCalculate ( name , & r . broadcast , true ) }
4566	func ( r * routes ) BroadcastAll ( name PeerName ) [ ] PeerName { return r . lookupOrCalculate ( name , & r . broadcastAll , false ) }
4567	func NewPeer ( name mesh . PeerName , uid mesh . PeerUID , logger mesh . Logger ) * Peer { p := & Peer { name : name , uid : uid , gossip : nil , recv : make ( chan pkt ) , actions : make ( chan func ( ) ) , quit : make ( chan struct { } ) , logger : logger , } go p . loop ( ) return p }
4568	func ( p * Peer ) Register ( gossip mesh . Gossip ) { p . actions <- func ( ) { p . gossip = gossip } }
4569	func ( p * Peer ) ReadFrom ( b [ ] byte ) ( n int , remote net . Addr , err error ) { c := make ( chan struct { } ) p . actions <- func ( ) { go func ( ) { defer close ( c ) select { case pkt := <- p . recv : n = copy ( b , pkt . Buf ) remote = MeshAddr { PeerName : pkt . SrcName , PeerUID : pkt . SrcUID } if n < len ( pkt . Buf ) { err = ErrShortRead } case <- p . quit : err = ErrPeerClosed } } ( ) } <- c return n , remote , err }
4570	func ( p * Peer ) WriteTo ( b [ ] byte , dst net . Addr ) ( n int , err error ) { c := make ( chan struct { } ) p . actions <- func ( ) { defer close ( c ) if p . gossip == nil { err = ErrGossipNotRegistered return } meshAddr , ok := dst . ( MeshAddr ) if ! ok { err = ErrNotMeshAddr return } pkt := pkt { SrcName : p . name , SrcUID : p . uid , Buf : b } if meshAddr . PeerName == p . name { p . recv <- pkt return } buf := pkt . encode ( ) n = len ( buf ) err = p . gossip . GossipUnicast ( meshAddr . PeerName , buf ) } <- c return n , err }
4571	func ( p * Peer ) LocalAddr ( ) net . Addr { return MeshAddr { PeerName : p . name , PeerUID : p . uid } }
4572	func ( p * Peer ) OnGossip ( buf [ ] byte ) ( delta mesh . GossipData , err error ) { return pktSlice { makePkt ( buf ) } , nil }
4573	func ( p * Peer ) OnGossipBroadcast ( _ mesh . PeerName , buf [ ] byte ) ( received mesh . GossipData , err error ) { pkt := makePkt ( buf ) p . recv <- pkt return pktSlice { pkt } , nil }
4574	func ( p * Peer ) OnGossipUnicast ( _ mesh . PeerName , buf [ ] byte ) error { pkt := makePkt ( buf ) p . recv <- pkt return nil }
4575	func NewDefaultServer ( minPeerCount int , terminatec <- chan struct { } , terminatedc chan <- error , logger mesh . Logger , ) Server { var ( peerName = mustPeerName ( ) nickName = mustHostname ( ) host = "0.0.0.0" port = 6379 password = "" channel = "metcd" ) router := mesh . NewRouter ( mesh . Config { Host : host , Port : port , ProtocolMinVersion : mesh . ProtocolMinVersion , Password : [ ] byte ( password ) , ConnLimit : 64 , PeerDiscovery : true , TrustedSubnets : [ ] * net . IPNet { } , } , peerName , nickName , mesh . NullOverlay { } , logger ) peer := meshconn . NewPeer ( router . Ourself . Peer . Name , router . Ourself . UID , logger ) gossip := router . NewGossip ( channel , peer ) peer . Register ( gossip ) router . Start ( ) return NewServer ( router , peer , minPeerCount , terminatec , terminatedc , logger ) }
4576	func PeerNameFromUserInput ( userInput string ) ( PeerName , error ) { nameByteAry := sha256 . Sum256 ( [ ] byte ( userInput ) ) return PeerNameFromBin ( nameByteAry [ : NameSize ] ) , nil }
4577	func ( name PeerName ) bytes ( ) [ ] byte { res , err := hex . DecodeString ( string ( name ) ) if err != nil { panic ( "unable to decode name to bytes: " + name ) } return res }
4578	func NewRouter ( config Config , name PeerName , nickName string , overlay Overlay , logger Logger ) ( * Router , error ) { router := & Router { Config : config , gossipChannels : make ( gossipChannels ) } if overlay == nil { overlay = NullOverlay { } } router . Overlay = overlay router . Ourself = newLocalPeer ( name , nickName , router ) router . Peers = newPeers ( router . Ourself ) router . Peers . OnGC ( func ( peer * Peer ) { logger . Printf ( "Removed unreachable peer %s" , peer ) } ) router . Routes = newRoutes ( router . Ourself , router . Peers ) router . ConnectionMaker = newConnectionMaker ( router . Ourself , router . Peers , net . JoinHostPort ( router . Host , "0" ) , router . Port , router . PeerDiscovery , logger ) router . logger = logger gossip , err := router . NewGossip ( "topology" , router ) if err != nil { return nil , err } router . topologyGossip = gossip router . acceptLimiter = newTokenBucket ( acceptMaxTokens , acceptTokenDelay ) return router , nil }
4579	func ( router * Router ) sendAllGossip ( ) { for channel := range router . gossipChannelSet ( ) { if gossip := channel . gossiper . Gossip ( ) ; gossip != nil { channel . Send ( gossip ) } } }
4580	func ( router * Router ) sendAllGossipDown ( conn Connection ) { for channel := range router . gossipChannelSet ( ) { if gossip := channel . gossiper . Gossip ( ) ; gossip != nil { channel . SendDown ( conn , gossip ) } } }
4581	func ( router * Router ) broadcastTopologyUpdate ( update [ ] * Peer ) { names := make ( peerNameSet ) for _ , p := range update { names [ p . Name ] = struct { } { } } router . topologyGossip . GossipBroadcast ( & topologyGossipData { peers : router . Peers , update : names } ) }
4582	func ( router * Router ) OnGossipUnicast ( sender PeerName , msg [ ] byte ) error { return fmt . Errorf ( "unexpected topology gossip unicast: %v" , msg ) }
4583	func ( router * Router ) OnGossipBroadcast ( _ PeerName , update [ ] byte ) ( GossipData , error ) { origUpdate , _ , err := router . applyTopologyUpdate ( update ) if err != nil || len ( origUpdate ) == 0 { return nil , err } return & topologyGossipData { peers : router . Peers , update : origUpdate } , nil }
4584	func ( router * Router ) Gossip ( ) GossipData { return & topologyGossipData { peers : router . Peers , update : router . Peers . names ( ) } }
4585	func ( router * Router ) OnGossip ( update [ ] byte ) ( GossipData , error ) { _ , newUpdate , err := router . applyTopologyUpdate ( update ) if err != nil || len ( newUpdate ) == 0 { return nil , err } return & topologyGossipData { peers : router . Peers , update : newUpdate } , nil }
4586	func ( d * topologyGossipData ) Encode ( ) [ ] [ ] byte { return [ ] [ ] byte { d . peers . encodePeers ( d . update ) } }
4587	func newState ( self mesh . PeerName ) * state { return & state { set : map [ mesh . PeerName ] int { } , self : self , } }
4588	func ( st * state ) Merge ( other mesh . GossipData ) ( complete mesh . GossipData ) { return st . mergeComplete ( other . ( * state ) . copy ( ) . set ) }
4589	func ( st * state ) mergeReceived ( set map [ mesh . PeerName ] int ) ( received mesh . GossipData ) { st . mtx . Lock ( ) defer st . mtx . Unlock ( ) for peer , v := range set { if v <= st . set [ peer ] { delete ( set , peer ) continue } st . set [ peer ] = v } return & state { set : set , } }
4590	func ( st * state ) mergeComplete ( set map [ mesh . PeerName ] int ) ( complete mesh . GossipData ) { st . mtx . Lock ( ) defer st . mtx . Unlock ( ) for peer , v := range set { if v > st . set [ peer ] { st . set [ peer ] = v } } return & state { set : st . set , } }
4591	func ( * surrogateGossiper ) OnGossipBroadcast ( _ PeerName , update [ ] byte ) ( GossipData , error ) { return newSurrogateGossipData ( update ) , nil }
4592	func ( s * surrogateGossiper ) OnGossip ( update [ ] byte ) ( GossipData , error ) { hash := fnv . New64a ( ) _ , _ = hash . Write ( update ) updateHash := hash . Sum64 ( ) s . Lock ( ) defer s . Unlock ( ) for _ , p := range s . prevUpdates { if updateHash == p . hash && bytes . Equal ( update , p . update ) { return nil , nil } } updateTime := now ( ) deleteBefore := updateTime . Add ( - gossipInterval ) keepFrom := len ( s . prevUpdates ) for i , p := range s . prevUpdates { if p . t . After ( deleteBefore ) { keepFrom = i break } } s . prevUpdates = append ( s . prevUpdates [ keepFrom : ] , prevUpdate { update , updateHash , updateTime } ) return newSurrogateGossipData ( update ) , nil }
4593	func generateKeyPair ( ) ( publicKey , privateKey * [ 32 ] byte , err error ) { return box . GenerateKey ( rand . Reader ) }
4594	func formSessionKey ( remotePublicKey , localPrivateKey * [ 32 ] byte , secretKey [ ] byte ) * [ 32 ] byte { var sharedKey [ 32 ] byte box . Precompute ( & sharedKey , remotePublicKey , localPrivateKey ) sharedKeySlice := sharedKey [ : ] sharedKeySlice = append ( sharedKeySlice , secretKey ... ) sessionKey := sha256 . Sum256 ( sharedKeySlice ) return & sessionKey }
4595	func newTCPCryptoState ( sessionKey * [ 32 ] byte , outbound bool ) * tcpCryptoState { s := & tcpCryptoState { sessionKey : sessionKey } if outbound { s . nonce [ 0 ] |= ( 1 << 7 ) } s . nonce [ 0 ] |= ( 1 << 6 ) return s }
4596	func ( sender * gobTCPSender ) Send ( msg [ ] byte ) error { return sender . encoder . Encode ( msg ) }
4597	func ( sender * lengthPrefixTCPSender ) Send ( msg [ ] byte ) error { l := len ( msg ) if l > maxTCPMsgSize { return fmt . Errorf ( "outgoing message exceeds maximum size: %d > %d" , l , maxTCPMsgSize ) } prefixedMsg := make ( [ ] byte , 4 + l ) binary . BigEndian . PutUint32 ( prefixedMsg , uint32 ( l ) ) copy ( prefixedMsg [ 4 : ] , msg ) _ , err := sender . writer . Write ( prefixedMsg ) return err }
4598	func ( sender * encryptedTCPSender ) Send ( msg [ ] byte ) error { sender . Lock ( ) defer sender . Unlock ( ) encodedMsg := secretbox . Seal ( nil , msg , & sender . state . nonce , sender . state . sessionKey ) sender . state . advance ( ) return sender . sender . Send ( encodedMsg ) }
4599	func ( receiver * gobTCPReceiver ) Receive ( ) ( [ ] byte , error ) { var msg [ ] byte err := receiver . decoder . Decode ( & msg ) return msg , err }
4600	func ( receiver * lengthPrefixTCPReceiver ) Receive ( ) ( [ ] byte , error ) { lenPrefix := make ( [ ] byte , 4 ) if _ , err := io . ReadFull ( receiver . reader , lenPrefix ) ; err != nil { return nil , err } l := binary . BigEndian . Uint32 ( lenPrefix ) if l > maxTCPMsgSize { return nil , fmt . Errorf ( "incoming message exceeds maximum size: %d > %d" , l , maxTCPMsgSize ) } msg := make ( [ ] byte , l ) _ , err := io . ReadFull ( receiver . reader , msg ) return msg , err }
4601	func ( receiver * encryptedTCPReceiver ) Receive ( ) ( [ ] byte , error ) { msg , err := receiver . receiver . Receive ( ) if err != nil { return nil , err } decodedMsg , success := secretbox . Open ( nil , msg , & receiver . state . nonce , receiver . state . sessionKey ) if ! success { return nil , fmt . Errorf ( "Unable to decrypt TCP msg" ) } receiver . state . advance ( ) return decodedMsg , nil }
4602	func newPeer ( self mesh . PeerName , logger * log . Logger ) * peer { actions := make ( chan func ( ) ) p := & peer { st : newState ( self ) , send : nil , actions : actions , quit : make ( chan struct { } ) , logger : logger , } go p . loop ( actions ) return p }
4603	func ( p * peer ) incr ( ) ( result int ) { c := make ( chan struct { } ) p . actions <- func ( ) { defer close ( c ) st := p . st . incr ( ) if p . send != nil { p . send . GossipBroadcast ( st ) } else { p . logger . Printf ( "no sender configured; not broadcasting update right now" ) } result = st . get ( ) } <- c return result }
4604	func ( p * peer ) Gossip ( ) ( complete mesh . GossipData ) { complete = p . st . copy ( ) p . logger . Printf ( "Gossip => complete %v" , complete . ( * state ) . set ) return complete }
4605	func ( p * peer ) OnGossipUnicast ( src mesh . PeerName , buf [ ] byte ) error { var set map [ mesh . PeerName ] int if err := gob . NewDecoder ( bytes . NewReader ( buf ) ) . Decode ( & set ) ; err != nil { return err } complete := p . st . mergeComplete ( set ) p . logger . Printf ( "OnGossipUnicast %s %v => complete %v" , src , set , complete ) return nil }
4606	func makeRaftPeer ( addr net . Addr ) raft . Peer { return raft . Peer { ID : uint64 ( addr . ( meshconn . MeshAddr ) . PeerUID ) , Context : nil , } }
4607	func ( peer * Peer ) String ( ) string { return fmt . Sprint ( peer . Name , "(" , peer . NickName , ")" ) }
4608	func ( peer * Peer ) forEachConnectedPeer ( establishedAndSymmetric bool , exclude map [ PeerName ] PeerName , f func ( * Peer ) ) { for remoteName , conn := range peer . connections { if establishedAndSymmetric && ! conn . isEstablished ( ) { continue } if _ , found := exclude [ remoteName ] ; found { continue } remotePeer := conn . Remote ( ) if remoteConn , found := remotePeer . connections [ peer . Name ] ; ! establishedAndSymmetric || ( found && remoteConn . isEstablished ( ) ) { f ( remotePeer ) } } }
4609	func parsePeerUID ( s string ) ( PeerUID , error ) { uid , err := strconv . ParseUint ( s , 10 , 64 ) return PeerUID ( uid ) , err }
4610	func ( lop listOfPeers ) Swap ( i , j int ) { lop [ i ] , lop [ j ] = lop [ j ] , lop [ i ] }
4611	func ( lop listOfPeers ) Less ( i , j int ) bool { return lop [ i ] . Name < lop [ j ] . Name }
4612	func ( params protocolIntroParams ) doIntro ( ) ( res protocolIntroResults , err error ) { if err = params . Conn . SetDeadline ( time . Now ( ) . Add ( headerTimeout ) ) ; err != nil { return } if res . Version , err = params . exchangeProtocolHeader ( ) ; err != nil { return } var pubKey , privKey * [ 32 ] byte if params . Password != nil { if pubKey , privKey , err = generateKeyPair ( ) ; err != nil { return } } if err = params . Conn . SetWriteDeadline ( time . Time { } ) ; err != nil { return } if err = params . Conn . SetReadDeadline ( time . Now ( ) . Add ( tcpHeartbeat * 2 ) ) ; err != nil { return } switch res . Version { case 1 : err = res . doIntroV1 ( params , pubKey , privKey ) case 2 : err = res . doIntroV2 ( params , pubKey , privKey ) default : panic ( "unhandled protocol version" ) } return }
4613	func filterV1Features ( intro map [ string ] string ) map [ string ] string { safe := make ( map [ string ] string ) for _ , k := range protocolV1Features { if val , ok := intro [ k ] ; ok { safe [ k ] = val } } return safe }
4614	func newConnectionMaker ( ourself * localPeer , peers * Peers , localAddr string , port int , discovery bool , logger Logger ) * connectionMaker { actionChan := make ( chan connectionMakerAction , ChannelSize ) cm := & connectionMaker { ourself : ourself , peers : peers , localAddr : localAddr , port : port , discovery : discovery , directPeers : peerAddrs { } , targets : make ( map [ string ] * target ) , connections : make ( map [ Connection ] struct { } ) , actionChan : actionChan , logger : logger , } go cm . queryLoop ( actionChan ) return cm }
4615	func ( cm * connectionMaker ) connectionAborted ( address string , err error ) { cm . actionChan <- func ( ) bool { target := cm . targets [ address ] target . state = targetWaiting target . lastError = err target . nextTryLater ( ) return true } }
4616	func newGossipSender ( makeMsg func ( msg [ ] byte ) protocolMsg , makeBroadcastMsg func ( srcName PeerName , msg [ ] byte ) protocolMsg , sender protocolSender , stop <- chan struct { } , ) * gossipSender { more := make ( chan struct { } , 1 ) flush := make ( chan chan <- bool ) s := & gossipSender { makeMsg : makeMsg , makeBroadcastMsg : makeBroadcastMsg , sender : sender , broadcasts : make ( map [ PeerName ] GossipData ) , more : more , flush : flush , } go s . run ( stop , more , flush ) return s }
4617	func ( s * gossipSender ) Send ( data GossipData ) { s . Lock ( ) defer s . Unlock ( ) if s . empty ( ) { defer s . prod ( ) } if s . gossip == nil { s . gossip = data } else { s . gossip = s . gossip . Merge ( data ) } }
4618	func ( s * gossipSender ) Broadcast ( srcName PeerName , data GossipData ) { s . Lock ( ) defer s . Unlock ( ) if s . empty ( ) { defer s . prod ( ) } d , found := s . broadcasts [ srcName ] if ! found { s . broadcasts [ srcName ] = data } else { s . broadcasts [ srcName ] = d . Merge ( data ) } }
4619	func ( s * gossipSender ) Flush ( ) bool { ch := make ( chan bool ) s . flush <- ch return <- ch }
4620	func ( gs * gossipSenders ) Sender ( channelName string , makeGossipSender func ( sender protocolSender , stop <- chan struct { } ) * gossipSender ) * gossipSender { gs . Lock ( ) defer gs . Unlock ( ) s , found := gs . senders [ channelName ] if ! found { s = makeGossipSender ( gs . sender , gs . stop ) gs . senders [ channelName ] = s } return s }
4621	func ( gs * gossipSenders ) Flush ( ) bool { sent := false gs . Lock ( ) defer gs . Unlock ( ) for _ , sender := range gs . senders { sent = sender . Flush ( ) || sent } return sent }
4622	func findMainPath ( ) string { pc := make ( [ ] uintptr , 100 ) n := runtime . Callers ( 2 , pc ) frames := runtime . CallersFrames ( pc [ : n ] ) for { frame , more := frames . Next ( ) if frame . Function == "main.main" || frame . Function == "testing.tRunner" { return frame . File } if ! more { break } } return "" }
4623	func Create ( c context . Context , clientID string ) ( token string , err error ) { req := & pb . CreateChannelRequest { ApplicationKey : & clientID , } resp := & pb . CreateChannelResponse { } err = internal . Call ( c , service , "CreateChannel" , req , resp ) token = resp . GetToken ( ) return token , remapError ( err ) }
4624	func Send ( c context . Context , clientID , message string ) error { req := & pb . SendMessageRequest { ApplicationKey : & clientID , Message : & message , } resp := & basepb . VoidProto { } return remapError ( internal . Call ( c , service , "SendChannelMessage" , req , resp ) ) }
4625	func SendJSON ( c context . Context , clientID string , value interface { } ) error { m , err := json . Marshal ( value ) if err != nil { return err } return Send ( c , clientID , string ( m ) ) }
4626	func remapError ( err error ) error { if e , ok := err . ( * internal . APIError ) ; ok { if e . Service == "xmpp" { e . Service = "channel" } } return err }
4627	func NamespacedContext ( ctx netcontext . Context , namespace string ) netcontext . Context { return withNamespace ( ctx , namespace ) }
4628	func protoToItem ( p * pb . MemcacheGetResponse_Item ) * Item { return & Item { Key : string ( p . Key ) , Value : p . Value , Flags : p . GetFlags ( ) , casID : p . GetCasId ( ) , } }
4629	func singleError ( err error ) error { if me , ok := err . ( appengine . MultiError ) ; ok { return me [ 0 ] } return err }
4630	func Get ( c context . Context , key string ) ( * Item , error ) { m , err := GetMulti ( c , [ ] string { key } ) if err != nil { return nil , err } if _ , ok := m [ key ] ; ! ok { return nil , ErrCacheMiss } return m [ key ] , nil }
4631	func GetMulti ( c context . Context , key [ ] string ) ( map [ string ] * Item , error ) { if len ( key ) == 0 { return nil , nil } keyAsBytes := make ( [ ] [ ] byte , len ( key ) ) for i , k := range key { keyAsBytes [ i ] = [ ] byte ( k ) } req := & pb . MemcacheGetRequest { Key : keyAsBytes , ForCas : proto . Bool ( true ) , } res := & pb . MemcacheGetResponse { } if err := internal . Call ( c , "memcache" , "Get" , req , res ) ; err != nil { return nil , err } m := make ( map [ string ] * Item , len ( res . Item ) ) for _ , p := range res . Item { t := protoToItem ( p ) m [ t . Key ] = t } return m , nil }
4632	func Delete ( c context . Context , key string ) error { return singleError ( DeleteMulti ( c , [ ] string { key } ) ) }
4633	func DeleteMulti ( c context . Context , key [ ] string ) error { if len ( key ) == 0 { return nil } req := & pb . MemcacheDeleteRequest { Item : make ( [ ] * pb . MemcacheDeleteRequest_Item , len ( key ) ) , } for i , k := range key { req . Item [ i ] = & pb . MemcacheDeleteRequest_Item { Key : [ ] byte ( k ) } } res := & pb . MemcacheDeleteResponse { } if err := internal . Call ( c , "memcache" , "Delete" , req , res ) ; err != nil { return err } if len ( res . DeleteStatus ) != len ( key ) { return ErrServerError } me , any := make ( appengine . MultiError , len ( key ) ) , false for i , s := range res . DeleteStatus { switch s { case pb . MemcacheDeleteResponse_DELETED : case pb . MemcacheDeleteResponse_NOT_FOUND : me [ i ] = ErrCacheMiss any = true default : me [ i ] = ErrServerError any = true } } if any { return me } return nil }
4634	func Increment ( c context . Context , key string , delta int64 , initialValue uint64 ) ( newValue uint64 , err error ) { return incr ( c , key , delta , & initialValue ) }
4635	func IncrementExisting ( c context . Context , key string , delta int64 ) ( newValue uint64 , err error ) { return incr ( c , key , delta , nil ) }
4636	func set ( c context . Context , item [ ] * Item , value [ ] [ ] byte , policy pb . MemcacheSetRequest_SetPolicy ) error { if len ( item ) == 0 { return nil } req := & pb . MemcacheSetRequest { Item : make ( [ ] * pb . MemcacheSetRequest_Item , len ( item ) ) , } for i , t := range item { p := & pb . MemcacheSetRequest_Item { Key : [ ] byte ( t . Key ) , } if value == nil { p . Value = t . Value } else { p . Value = value [ i ] } if t . Flags != 0 { p . Flags = proto . Uint32 ( t . Flags ) } if t . Expiration != 0 { if t . Expiration < time . Second { p . ExpirationTime = proto . Uint32 ( uint32 ( time . Now ( ) . Unix ( ) ) - 5 ) } else if t . Expiration >= thirtyYears { p . ExpirationTime = proto . Uint32 ( uint32 ( time . Now ( ) . Unix ( ) ) + uint32 ( t . Expiration / time . Second ) ) } else { p . ExpirationTime = proto . Uint32 ( uint32 ( t . Expiration / time . Second ) ) } } if t . casID != 0 { p . CasId = proto . Uint64 ( t . casID ) p . ForCas = proto . Bool ( true ) } p . SetPolicy = policy . Enum ( ) req . Item [ i ] = p } res := & pb . MemcacheSetResponse { } if err := internal . Call ( c , "memcache" , "Set" , req , res ) ; err != nil { return err } if len ( res . SetStatus ) != len ( item ) { return ErrServerError } me , any := make ( appengine . MultiError , len ( item ) ) , false for i , st := range res . SetStatus { var err error switch st { case pb . MemcacheSetResponse_STORED : case pb . MemcacheSetResponse_NOT_STORED : err = ErrNotStored case pb . MemcacheSetResponse_EXISTS : err = ErrCASConflict default : err = ErrServerError } if err != nil { me [ i ] = err any = true } } if any { return me } return nil }
4637	func ( cd Codec ) Get ( c context . Context , key string , v interface { } ) ( * Item , error ) { i , err := Get ( c , key ) if err != nil { return nil , err } if err := cd . Unmarshal ( i . Value , v ) ; err != nil { return nil , err } return i , nil }
4638	func Stats ( c context . Context ) ( * Statistics , error ) { req := & pb . MemcacheStatsRequest { } res := & pb . MemcacheStatsResponse { } if err := internal . Call ( c , "memcache" , "Stats" , req , res ) ; err != nil { return nil , err } if res . Stats == nil { return nil , ErrNoStats } return & Statistics { Hits : * res . Stats . Hits , Misses : * res . Stats . Misses , ByteHits : * res . Stats . ByteHits , Items : * res . Stats . Items , Bytes : * res . Stats . Bytes , Oldest : int64 ( * res . Stats . OldestItemAge ) , } , nil }
4639	func Flush ( c context . Context ) error { req := & pb . MemcacheFlushRequest { } res := & pb . MemcacheFlushResponse { } return internal . Call ( c , "memcache" , "FlushAll" , req , res ) }
4640	func RunInBackground ( c context . Context , f func ( c context . Context ) ) error { req := & pb . StartBackgroundRequestRequest { } res := & pb . StartBackgroundRequestResponse { } if err := internal . Call ( c , "system" , "StartBackgroundRequest" , req , res ) ; err != nil { return err } sendc <- send { res . GetRequestId ( ) , f } return nil }
4641	func List ( c context . Context ) ( [ ] string , error ) { req := & pb . GetModulesRequest { } res := & pb . GetModulesResponse { } err := internal . Call ( c , "modules" , "GetModules" , req , res ) return res . Module , err }
4642	func SetNumInstances ( c context . Context , module , version string , instances int ) error { req := & pb . SetNumInstancesRequest { } if module != "" { req . Module = & module } if version != "" { req . Version = & version } req . Instances = proto . Int64 ( int64 ( instances ) ) res := & pb . SetNumInstancesResponse { } return internal . Call ( c , "modules" , "SetNumInstances" , req , res ) }
4643	func Versions ( c context . Context , module string ) ( [ ] string , error ) { req := & pb . GetVersionsRequest { } if module != "" { req . Module = & module } res := & pb . GetVersionsResponse { } err := internal . Call ( c , "modules" , "GetVersions" , req , res ) return res . GetVersion ( ) , err }
4644	func DefaultVersion ( c context . Context , module string ) ( string , error ) { req := & pb . GetDefaultVersionRequest { } if module != "" { req . Module = & module } res := & pb . GetDefaultVersionResponse { } err := internal . Call ( c , "modules" , "GetDefaultVersion" , req , res ) return res . GetVersion ( ) , err }
4645	func Start ( c context . Context , module , version string ) error { req := & pb . StartModuleRequest { } if module != "" { req . Module = & module } if version != "" { req . Version = & version } res := & pb . StartModuleResponse { } return internal . Call ( c , "modules" , "StartModule" , req , res ) }
4646	func Stop ( c context . Context , module , version string ) error { req := & pb . StopModuleRequest { } if module != "" { req . Module = & module } if version != "" { req . Version = & version } res := & pb . StopModuleResponse { } return internal . Call ( c , "modules" , "StopModule" , req , res ) }
4647	func ( q * Query ) Ancestor ( ancestor * Key ) * Query { q = q . clone ( ) if ancestor == nil { q . err = errors . New ( "datastore: nil query ancestor" ) return q } q . ancestor = ancestor return q }
4648	func ( q * Query ) EventualConsistency ( ) * Query { q = q . clone ( ) q . eventual = true return q }
4649	func ( q * Query ) Project ( fieldNames ... string ) * Query { q = q . clone ( ) q . projection = append ( [ ] string ( nil ) , fieldNames ... ) return q }
4650	func ( q * Query ) Distinct ( ) * Query { q = q . clone ( ) q . distinct = true return q }
4651	func ( q * Query ) DistinctOn ( fieldNames ... string ) * Query { q = q . clone ( ) q . distinctOn = fieldNames return q }
4652	func ( q * Query ) KeysOnly ( ) * Query { q = q . clone ( ) q . keysOnly = true return q }
4653	func ( q * Query ) Limit ( limit int ) * Query { q = q . clone ( ) if limit < math . MinInt32 || limit > math . MaxInt32 { q . err = errors . New ( "datastore: query limit overflow" ) return q } q . limit = int32 ( limit ) return q }
4654	func ( q * Query ) Offset ( offset int ) * Query { q = q . clone ( ) if offset < 0 { q . err = errors . New ( "datastore: negative query offset" ) return q } if offset > math . MaxInt32 { q . err = errors . New ( "datastore: query offset overflow" ) return q } q . offset = int32 ( offset ) return q }
4655	func ( q * Query ) BatchSize ( size int ) * Query { q = q . clone ( ) if size <= 0 || size > math . MaxInt32 { q . err = errors . New ( "datastore: query batch size overflow" ) return q } q . count = int32 ( size ) return q }
4656	func ( q * Query ) Start ( c Cursor ) * Query { q = q . clone ( ) if c . cc == nil { q . err = errors . New ( "datastore: invalid cursor" ) return q } q . start = c . cc return q }
4657	func ( q * Query ) End ( c Cursor ) * Query { q = q . clone ( ) if c . cc == nil { q . err = errors . New ( "datastore: invalid cursor" ) return q } q . end = c . cc return q }
4658	func ( q * Query ) Count ( c context . Context ) ( int , error ) { if q . err != nil { return 0 , q . err } newQ := q . clone ( ) newQ . keysOnly = len ( newQ . projection ) == 0 newQ . limit = 0 if q . limit < 0 { newQ . offset = math . MaxInt32 } else { newQ . offset = q . offset + q . limit if newQ . offset < 0 { newQ . offset = math . MaxInt32 } } req := & pb . Query { } if err := newQ . toProto ( req , internal . FullyQualifiedAppID ( c ) ) ; err != nil { return 0 , err } res := & pb . QueryResult { } if err := internal . Call ( c , "datastore_v3" , "RunQuery" , req , res ) ; err != nil { return 0 , err } var n int32 for { if len ( res . Result ) != 0 { return 0 , errors . New ( "datastore: internal error: Count request returned too much data" ) } n += res . GetSkippedResults ( ) if ! res . GetMoreResults ( ) { break } if err := callNext ( c , res , newQ . offset - n , q . count ) ; err != nil { return 0 , err } } n -= q . offset if n < 0 { n = 0 } return int ( n ) , nil }
4659	func ( q * Query ) Run ( c context . Context ) * Iterator { if q . err != nil { return & Iterator { err : q . err } } t := & Iterator { c : c , limit : q . limit , count : q . count , q : q , prevCC : q . start , } var req pb . Query if err := q . toProto ( & req , internal . FullyQualifiedAppID ( c ) ) ; err != nil { t . err = err return t } if err := internal . Call ( c , "datastore_v3" , "RunQuery" , & req , & t . res ) ; err != nil { t . err = err return t } offset := q . offset - t . res . GetSkippedResults ( ) var count int32 if t . count > 0 && ( t . limit < 0 || t . count < t . limit ) { count = t . count } else { count = t . limit } for offset > 0 && t . res . GetMoreResults ( ) { t . prevCC = t . res . CompiledCursor if err := callNext ( t . c , & t . res , offset , count ) ; err != nil { t . err = err break } skip := t . res . GetSkippedResults ( ) if skip < 0 { t . err = errors . New ( "datastore: internal error: negative number of skipped_results" ) break } offset -= skip } if offset < 0 { t . err = errors . New ( "datastore: internal error: query offset was overshot" ) } return t }
4660	func ( t * Iterator ) Next ( dst interface { } ) ( * Key , error ) { k , e , err := t . next ( ) if err != nil { return nil , err } if dst != nil && ! t . q . keysOnly { err = loadEntity ( dst , e ) } return k , err }
4661	func ( t * Iterator ) Cursor ( ) ( Cursor , error ) { if t . err != nil && t . err != Done { return Cursor { } , t . err } skipped := t . res . GetSkippedResults ( ) if t . i == 0 && skipped == 0 { if t . prevCC == nil { return Cursor { & zeroCC } , nil } return Cursor { t . prevCC } , nil } if t . i == len ( t . res . Result ) { return Cursor { t . res . CompiledCursor } , nil } q := t . q . clone ( ) q . start = t . prevCC q . offset = skipped + int32 ( t . i ) q . limit = 0 q . keysOnly = len ( q . projection ) == 0 t1 := q . Run ( t . c ) _ , _ , err := t1 . next ( ) if err != Done { if err == nil { err = fmt . Errorf ( "datastore: internal error: zero-limit query did not have zero results" ) } return Cursor { } , err } return Cursor { t1 . res . CompiledCursor } , nil }
4662	func ( c Cursor ) String ( ) string { if c . cc == nil { return "" } b , err := proto . Marshal ( c . cc ) if err != nil { panic ( fmt . Sprintf ( "datastore: internal error: malformed cursor: %v" , err ) ) } return strings . TrimRight ( base64 . URLEncoding . EncodeToString ( b ) , "=" ) }
4663	func DecodeCursor ( s string ) ( Cursor , error ) { if s == "" { return Cursor { & zeroCC } , nil } if n := len ( s ) % 4 ; n != 0 { s += strings . Repeat ( "=" , 4 - n ) } b , err := base64 . URLEncoding . DecodeString ( s ) if err != nil { return Cursor { } , err } cc := & pb . CompiledCursor { } if err := proto . Unmarshal ( b , cc ) ; err != nil { return Cursor { } , err } return Cursor { cc } , nil }
4664	func saveEntity ( defaultAppID string , key * Key , src interface { } ) ( * pb . EntityProto , error ) { var err error var props [ ] Property if e , ok := src . ( PropertyLoadSaver ) ; ok { props , err = e . Save ( ) } else { props , err = SaveStruct ( src ) } if err != nil { return nil , err } return propertiesToProto ( defaultAppID , key , props ) }
4665	func Namespace ( c context . Context , namespace string ) ( context . Context , error ) { if ! validNamespace . MatchString ( namespace ) { return nil , fmt . Errorf ( "appengine: namespace %q does not match /%s/" , namespace , validNamespace ) } return internal . NamespacedContext ( c , namespace ) , nil }
4666	func ( cfg * TypeConfig ) typeof ( name string ) string { if cfg . Var != nil { if t := cfg . Var [ name ] ; t != "" { return t } } if cfg . Func != nil { if t := cfg . Func [ name ] ; t != "" { return "func()" + t } } return "" }
4667	func ( typ * Type ) dot ( cfg * TypeConfig , name string ) string { if typ . Field != nil { if t := typ . Field [ name ] ; t != "" { return t } } if typ . Method != nil { if t := typ . Method [ name ] ; t != "" { return t } } for _ , e := range typ . Embed { etyp := cfg . Type [ e ] if etyp != nil { if t := etyp . dot ( cfg , name ) ; t != "" { return t } } } return "" }
4668	func joinFunc ( in , out [ ] string ) string { outs := "" if len ( out ) == 1 { outs = " " + out [ 0 ] } else if len ( out ) > 1 { outs = " (" + join ( out ) + ")" } return "func(" + join ( in ) + ")" + outs }
4669	func validPropertyName ( name string ) bool { if name == "" { return false } for _ , s := range strings . Split ( name , "." ) { if s == "" { return false } first := true for _ , c := range s { if first { first = false if c != '_' && ! unicode . IsLetter ( c ) { return false } } else { if c != '_' && ! unicode . IsLetter ( c ) && ! unicode . IsDigit ( c ) { return false } } } } return true }
4670	func getStructCodec ( t reflect . Type ) ( * structCodec , error ) { structCodecsMutex . Lock ( ) defer structCodecsMutex . Unlock ( ) return getStructCodecLocked ( t ) }
4671	func LoadStruct ( dst interface { } , p [ ] Property ) error { x , err := newStructPLS ( dst ) if err != nil { return err } return x . Load ( p ) }
4672	func SaveStruct ( src interface { } ) ( [ ] Property , error ) { x , err := newStructPLS ( src ) if err != nil { return nil , err } return x . Save ( ) }
4673	func ServingURL ( c context . Context , key appengine . BlobKey , opts * ServingURLOptions ) ( * url . URL , error ) { req := & pb . ImagesGetUrlBaseRequest { BlobKey : ( * string ) ( & key ) , } if opts != nil && opts . Secure { req . CreateSecureUrl = & opts . Secure } res := & pb . ImagesGetUrlBaseResponse { } if err := internal . Call ( c , "images" , "GetUrlBase" , req , res ) ; err != nil { return nil , err } u := * res . Url if opts != nil && opts . Size > 0 { u += fmt . Sprintf ( "=s%d" , opts . Size ) if opts . Crop { u += "-c" } } return url . Parse ( u ) }
4674	func DeleteServingURL ( c context . Context , key appengine . BlobKey ) error { req := & pb . ImagesDeleteUrlBaseRequest { BlobKey : ( * string ) ( & key ) , } res := & pb . ImagesDeleteUrlBaseResponse { } return internal . Call ( c , "images" , "DeleteUrlBase" , req , res ) }
4675	func CurrentOAuth ( c context . Context , scopes ... string ) ( * User , error ) { req := & pb . GetOAuthUserRequest { } if len ( scopes ) != 1 || scopes [ 0 ] != "" { req . Scopes = scopes } res := & pb . GetOAuthUserResponse { } err := internal . Call ( c , "user" , "GetOAuthUser" , req , res ) if err != nil { return nil , err } return & User { Email : * res . Email , AuthDomain : * res . AuthDomain , Admin : res . GetIsAdmin ( ) , ID : * res . UserId , ClientID : res . GetClientId ( ) , } , nil }
4676	func OAuthConsumerKey ( c context . Context ) ( string , error ) { req := & pb . CheckOAuthSignatureRequest { } res := & pb . CheckOAuthSignatureResponse { } err := internal . Call ( c , "user" , "CheckOAuthSignature" , req , res ) if err != nil { return "" , err } return * res . OauthConsumerKey , err }
4677	func ( u * User ) String ( ) string { if u . AuthDomain != "" && strings . HasSuffix ( u . Email , "@" + u . AuthDomain ) { return u . Email [ : len ( u . Email ) - len ( "@" + u . AuthDomain ) ] } if u . FederatedIdentity != "" { return u . FederatedIdentity } return u . Email }
4678	func LoginURL ( c context . Context , dest string ) ( string , error ) { return LoginURLFederated ( c , dest , "" ) }
4679	func LoginURLFederated ( c context . Context , dest , identity string ) ( string , error ) { req := & pb . CreateLoginURLRequest { DestinationUrl : proto . String ( dest ) , } if identity != "" { req . FederatedIdentity = proto . String ( identity ) } res := & pb . CreateLoginURLResponse { } if err := internal . Call ( c , "user" , "CreateLoginURL" , req , res ) ; err != nil { return "" , err } return * res . LoginUrl , nil }
4680	func LogoutURL ( c context . Context , dest string ) ( string , error ) { req := & pb . CreateLogoutURLRequest { DestinationUrl : proto . String ( dest ) , } res := & pb . CreateLogoutURLResponse { } if err := internal . Call ( c , "user" , "CreateLogoutURL" , req , res ) ; err != nil { return "" , err } return * res . LogoutUrl , nil }
4681	func insertContext ( f * ast . File , call * ast . CallExpr , ctx * ast . Ident ) { if ctx == nil { ctx = ast . NewIdent ( "ctx" ) } else { ctx = ast . NewIdent ( ctx . Name ) } call . Args = append ( [ ] ast . Expr { ctx } , call . Args ... ) }
4682	func NewClient ( host string , client * http . Client ) ( * Client , error ) { wrapClient := new ( http . Client ) * wrapClient = * client t := client . Transport if t == nil { t = http . DefaultTransport } wrapClient . Transport = & headerAddingRoundTripper { t } url := url . URL { Scheme : "https" , Host : host , Path : "/_ah/remote_api" , } if host == "localhost" || strings . HasPrefix ( host , "localhost:" ) { url . Scheme = "http" } u := url . String ( ) appID , err := getAppID ( wrapClient , u ) if err != nil { return nil , fmt . Errorf ( "unable to contact server: %v" , err ) } return & Client { hc : wrapClient , url : u , appID : appID , } , nil }
4683	func ( c * Client ) NewContext ( parent context . Context ) context . Context { ctx := internal . WithCallOverride ( parent , c . call ) ctx = internal . WithLogOverride ( ctx , c . logf ) ctx = internal . WithAppIDOverride ( ctx , c . appID ) return ctx }
4684	func NewRemoteContext ( host string , client * http . Client ) ( context . Context , error ) { c , err := NewClient ( host , client ) if err != nil { return nil , err } return c . NewContext ( context . Background ( ) ) , nil }
4685	func Debugf ( ctx context . Context , format string , args ... interface { } ) { internal . Logf ( ctx , 0 , format , args ... ) }
4686	func guestbookKey ( ctx context . Context ) * datastore . Key { return datastore . NewKey ( ctx , "Guestbook" , "default_guestbook" , 0 , nil ) }
4687	func ( opt * RetryOptions ) toRetryParameters ( ) * pb . TaskQueueRetryParameters { params := & pb . TaskQueueRetryParameters { } if opt . RetryLimit > 0 { params . RetryLimit = proto . Int32 ( opt . RetryLimit ) } if opt . AgeLimit > 0 { params . AgeLimitSec = proto . Int64 ( int64 ( opt . AgeLimit . Seconds ( ) ) ) } if opt . MinBackoff > 0 { params . MinBackoffSec = proto . Float64 ( opt . MinBackoff . Seconds ( ) ) } if opt . MaxBackoff > 0 { params . MaxBackoffSec = proto . Float64 ( opt . MaxBackoff . Seconds ( ) ) } if opt . MaxDoublings > 0 || ( opt . MaxDoublings == 0 && opt . ApplyZeroMaxDoublings ) { params . MaxDoublings = proto . Int32 ( opt . MaxDoublings ) } return params }
4688	func NewPOSTTask ( path string , params url . Values ) * Task { h := make ( http . Header ) h . Set ( "Content-Type" , "application/x-www-form-urlencoded" ) return & Task { Path : path , Payload : [ ] byte ( params . Encode ( ) ) , Header : h , Method : "POST" , } }
4689	func ParseRequestHeaders ( h http . Header ) * RequestHeaders { ret := & RequestHeaders { QueueName : h . Get ( "X-AppEngine-QueueName" ) , TaskName : h . Get ( "X-AppEngine-TaskName" ) , } ret . TaskRetryCount , _ = strconv . ParseInt ( h . Get ( "X-AppEngine-TaskRetryCount" ) , 10 , 64 ) ret . TaskExecutionCount , _ = strconv . ParseInt ( h . Get ( "X-AppEngine-TaskExecutionCount" ) , 10 , 64 ) etaSecs , _ := strconv . ParseInt ( h . Get ( "X-AppEngine-TaskETA" ) , 10 , 64 ) if etaSecs != 0 { ret . TaskETA = time . Unix ( etaSecs , 0 ) } ret . TaskPreviousResponse , _ = strconv . Atoi ( h . Get ( "X-AppEngine-TaskPreviousResponse" ) ) ret . TaskRetryReason = h . Get ( "X-AppEngine-TaskRetryReason" ) if h . Get ( "X-AppEngine-FailFast" ) != "" { ret . FailFast = true } return ret }
4690	func Add ( c context . Context , task * Task , queueName string ) ( * Task , error ) { req , err := newAddReq ( c , task , queueName ) if err != nil { return nil , err } res := & pb . TaskQueueAddResponse { } if err := internal . Call ( c , "taskqueue" , "Add" , req , res ) ; err != nil { apiErr , ok := err . ( * internal . APIError ) if ok && alreadyAddedErrors [ pb . TaskQueueServiceError_ErrorCode ( apiErr . Code ) ] { return nil , ErrTaskAlreadyAdded } return nil , err } resultTask := * task resultTask . Method = task . method ( ) if task . Name == "" { resultTask . Name = string ( res . ChosenTaskName ) } return & resultTask , nil }
4691	func AddMulti ( c context . Context , tasks [ ] * Task , queueName string ) ( [ ] * Task , error ) { req := & pb . TaskQueueBulkAddRequest { AddRequest : make ( [ ] * pb . TaskQueueAddRequest , len ( tasks ) ) , } me , any := make ( appengine . MultiError , len ( tasks ) ) , false for i , t := range tasks { req . AddRequest [ i ] , me [ i ] = newAddReq ( c , t , queueName ) any = any || me [ i ] != nil } if any { return nil , me } res := & pb . TaskQueueBulkAddResponse { } if err := internal . Call ( c , "taskqueue" , "BulkAdd" , req , res ) ; err != nil { return nil , err } if len ( res . Taskresult ) != len ( tasks ) { return nil , errors . New ( "taskqueue: server error" ) } tasksOut := make ( [ ] * Task , len ( tasks ) ) for i , tr := range res . Taskresult { tasksOut [ i ] = new ( Task ) * tasksOut [ i ] = * tasks [ i ] tasksOut [ i ] . Method = tasksOut [ i ] . method ( ) if tasksOut [ i ] . Name == "" { tasksOut [ i ] . Name = string ( tr . ChosenTaskName ) } if * tr . Result != pb . TaskQueueServiceError_OK { if alreadyAddedErrors [ * tr . Result ] { me [ i ] = ErrTaskAlreadyAdded } else { me [ i ] = & internal . APIError { Service : "taskqueue" , Code : int32 ( * tr . Result ) , } } any = true } } if any { return tasksOut , me } return tasksOut , nil }
4692	func Delete ( c context . Context , task * Task , queueName string ) error { err := DeleteMulti ( c , [ ] * Task { task } , queueName ) if me , ok := err . ( appengine . MultiError ) ; ok { return me [ 0 ] } return err }
4693	func DeleteMulti ( c context . Context , tasks [ ] * Task , queueName string ) error { taskNames := make ( [ ] [ ] byte , len ( tasks ) ) for i , t := range tasks { taskNames [ i ] = [ ] byte ( t . Name ) } if queueName == "" { queueName = "default" } req := & pb . TaskQueueDeleteRequest { QueueName : [ ] byte ( queueName ) , TaskName : taskNames , } res := & pb . TaskQueueDeleteResponse { } if err := internal . Call ( c , "taskqueue" , "Delete" , req , res ) ; err != nil { return err } if a , b := len ( req . TaskName ) , len ( res . Result ) ; a != b { return fmt . Errorf ( "taskqueue: internal error: requested deletion of %d tasks, got %d results" , a , b ) } me , any := make ( appengine . MultiError , len ( res . Result ) ) , false for i , ec := range res . Result { if ec != pb . TaskQueueServiceError_OK { me [ i ] = & internal . APIError { Service : "taskqueue" , Code : int32 ( ec ) , } any = true } } if any { return me } return nil }
4694	func Lease ( c context . Context , maxTasks int , queueName string , leaseTime int ) ( [ ] * Task , error ) { return lease ( c , maxTasks , queueName , leaseTime , false , nil ) }
4695	func LeaseByTag ( c context . Context , maxTasks int , queueName string , leaseTime int , tag string ) ( [ ] * Task , error ) { return lease ( c , maxTasks , queueName , leaseTime , true , [ ] byte ( tag ) ) }
4696	func Purge ( c context . Context , queueName string ) error { if queueName == "" { queueName = "default" } req := & pb . TaskQueuePurgeQueueRequest { QueueName : [ ] byte ( queueName ) , } res := & pb . TaskQueuePurgeQueueResponse { } return internal . Call ( c , "taskqueue" , "PurgeQueue" , req , res ) }
4697	func ModifyLease ( c context . Context , task * Task , queueName string , leaseTime int ) error { if queueName == "" { queueName = "default" } req := & pb . TaskQueueModifyTaskLeaseRequest { QueueName : [ ] byte ( queueName ) , TaskName : [ ] byte ( task . Name ) , EtaUsec : proto . Int64 ( task . ETA . UnixNano ( ) / 1e3 ) , LeaseSeconds : proto . Float64 ( float64 ( leaseTime ) ) , } res := & pb . TaskQueueModifyTaskLeaseResponse { } if err := internal . Call ( c , "taskqueue" , "ModifyTaskLease" , req , res ) ; err != nil { return err } task . ETA = time . Unix ( 0 , * res . UpdatedEtaUsec * 1e3 ) return nil }
4698	func QueueStats ( c context . Context , queueNames [ ] string ) ( [ ] QueueStatistics , error ) { req := & pb . TaskQueueFetchQueueStatsRequest { QueueName : make ( [ ] [ ] byte , len ( queueNames ) ) , } for i , q := range queueNames { if q == "" { q = "default" } req . QueueName [ i ] = [ ] byte ( q ) } res := & pb . TaskQueueFetchQueueStatsResponse { } if err := internal . Call ( c , "taskqueue" , "FetchQueueStats" , req , res ) ; err != nil { return nil , err } qs := make ( [ ] QueueStatistics , len ( res . Queuestats ) ) for i , qsg := range res . Queuestats { qs [ i ] = QueueStatistics { Tasks : int ( * qsg . NumTasks ) , } if eta := * qsg . OldestEtaUsec ; eta > - 1 { qs [ i ] . OldestETA = time . Unix ( 0 , eta * 1e3 ) } if si := qsg . ScannerInfo ; si != nil { qs [ i ] . Executed1Minute = int ( * si . ExecutedLastMinute ) qs [ i ] . InFlight = int ( si . GetRequestsInFlight ( ) ) qs [ i ] . EnforcedRate = si . GetEnforcedRate ( ) } } return qs , nil }
4699	func IsTimeoutError ( err error ) bool { if err == context . DeadlineExceeded { return true } if t , ok := err . ( interface { IsTimeout ( ) bool } ) ; ok { return t . IsTimeout ( ) } return false }
4700	func Func ( key string , i interface { } ) * Function { f := & Function { fv : reflect . ValueOf ( i ) } _ , file , _ , _ := runtime . Caller ( 1 ) fk , err := fileKey ( file ) if err != nil { stdlog . Printf ( "delay: %v" , err ) } f . key = fk + ":" + key t := f . fv . Type ( ) if t . Kind ( ) != reflect . Func { f . err = errors . New ( "not a function" ) return f } if t . NumIn ( ) == 0 || ! isContext ( t . In ( 0 ) ) { f . err = errFirstArg return f } for i := 0 ; i < t . NumIn ( ) ; i ++ { if t . In ( i ) . Kind ( ) == reflect . Interface { continue } gob . Register ( reflect . Zero ( t . In ( i ) ) . Interface ( ) ) } if old := funcs [ f . key ] ; old != nil { old . err = fmt . Errorf ( "multiple functions registered for %s in %s" , key , file ) } funcs [ f . key ] = f return f }
4701	func ( f * Function ) Task ( args ... interface { } ) ( * taskqueue . Task , error ) { if f . err != nil { return nil , fmt . Errorf ( "delay: func is invalid: %v" , f . err ) } nArgs := len ( args ) + 1 ft := f . fv . Type ( ) minArgs := ft . NumIn ( ) if ft . IsVariadic ( ) { minArgs -- } if nArgs < minArgs { return nil , fmt . Errorf ( "delay: too few arguments to func: %d < %d" , nArgs , minArgs ) } if ! ft . IsVariadic ( ) && nArgs > minArgs { return nil , fmt . Errorf ( "delay: too many arguments to func: %d > %d" , nArgs , minArgs ) } for i := 1 ; i < nArgs ; i ++ { at := reflect . TypeOf ( args [ i - 1 ] ) var dt reflect . Type if i < minArgs { dt = ft . In ( i ) } else { dt = ft . In ( minArgs ) . Elem ( ) } if at == nil { switch dt . Kind ( ) { case reflect . Chan , reflect . Func , reflect . Interface , reflect . Map , reflect . Ptr , reflect . Slice : continue } return nil , fmt . Errorf ( "delay: argument %d has wrong type: %v is not nilable" , i , dt ) } switch at . Kind ( ) { case reflect . Chan , reflect . Func , reflect . Interface , reflect . Map , reflect . Ptr , reflect . Slice : av := reflect . ValueOf ( args [ i - 1 ] ) if av . IsNil ( ) { args [ i - 1 ] = nil } } if ! at . AssignableTo ( dt ) { return nil , fmt . Errorf ( "delay: argument %d has wrong type: %v is not assignable to %v" , i , at , dt ) } } inv := invocation { Key : f . key , Args : args , } buf := new ( bytes . Buffer ) if err := gob . NewEncoder ( buf ) . Encode ( inv ) ; err != nil { return nil , fmt . Errorf ( "delay: gob encoding failed: %v" , err ) } return & taskqueue . Task { Path : path , Payload : buf . Bytes ( ) , } , nil }
4702	func RequestHeaders ( c context . Context ) ( * taskqueue . RequestHeaders , error ) { if ret , ok := c . Value ( headersContextKey ) . ( * taskqueue . RequestHeaders ) ; ok { return ret , nil } return nil , errOutsideDelayFunc }
4703	func WithContext ( parent context . Context , req * http . Request ) context . Context { return internal . WithContext ( parent , req ) }
4704	func WithAPICallFunc ( ctx context . Context , f APICallFunc ) context . Context { return internal . WithCallOverride ( ctx , internal . CallOverrideFunc ( f ) ) }
4705	func APICall ( ctx context . Context , service , method string , in , out proto . Message ) error { return internal . Call ( ctx , service , method , in , out ) }
4706	func ModuleHostname ( c context . Context , module , version , instance string ) ( string , error ) { req := & modpb . GetHostnameRequest { } if module != "" { req . Module = & module } if version != "" { req . Version = & version } if instance != "" { req . Instance = & instance } res := & modpb . GetHostnameResponse { } if err := internal . Call ( c , "modules" , "GetHostname" , req , res ) ; err != nil { return "" , err } return * res . Hostname , nil }
4707	func AccessToken ( c context . Context , scopes ... string ) ( token string , expiry time . Time , err error ) { req := & pb . GetAccessTokenRequest { Scope : scopes } res := & pb . GetAccessTokenResponse { } err = internal . Call ( c , "app_identity_service" , "GetAccessToken" , req , res ) if err != nil { return "" , time . Time { } , err } return res . GetAccessToken ( ) , time . Unix ( res . GetExpirationTime ( ) , 0 ) , nil }
4708	func PublicCertificates ( c context . Context ) ( [ ] Certificate , error ) { req := & pb . GetPublicCertificateForAppRequest { } res := & pb . GetPublicCertificateForAppResponse { } if err := internal . Call ( c , "app_identity_service" , "GetPublicCertificatesForApp" , req , res ) ; err != nil { return nil , err } var cs [ ] Certificate for _ , pc := range res . PublicCertificateList { cs = append ( cs , Certificate { KeyName : pc . GetKeyName ( ) , Data : [ ] byte ( pc . GetX509CertificatePem ( ) ) , } ) } return cs , nil }
4709	func ServiceAccount ( c context . Context ) ( string , error ) { req := & pb . GetServiceAccountNameRequest { } res := & pb . GetServiceAccountNameResponse { } err := internal . Call ( c , "app_identity_service" , "GetServiceAccountName" , req , res ) if err != nil { return "" , err } return res . GetServiceAccountName ( ) , err }
4710	func SignBytes ( c context . Context , bytes [ ] byte ) ( keyName string , signature [ ] byte , err error ) { req := & pb . SignForAppRequest { BytesToSign : bytes } res := & pb . SignForAppResponse { } if err := internal . Call ( c , "app_identity_service" , "SignForApp" , req , res ) ; err != nil { return "" , nil , err } return res . GetKeyName ( ) , res . GetSignatureBytes ( ) , nil }
4711	func ( r * reader ) fetch ( off int64 ) error { req := & blobpb . FetchDataRequest { BlobKey : proto . String ( string ( r . blobKey ) ) , StartIndex : proto . Int64 ( off ) , EndIndex : proto . Int64 ( off + readBufferSize - 1 ) , } res := & blobpb . FetchDataResponse { } if err := internal . Call ( r . c , "blobstore" , "FetchData" , req , res ) ; err != nil { return err } if len ( res . Data ) == 0 { return io . EOF } r . buf , r . r , r . off = res . Data , 0 , off return nil }
4712	func ( r * reader ) seek ( off int64 ) ( int64 , error ) { delta := off - r . off if delta >= 0 && delta < int64 ( len ( r . buf ) ) { r . r = int ( delta ) return off , nil } r . buf , r . r , r . off = nil , 0 , off return off , nil }
4713	func multiKeyToProto ( appID string , key [ ] * Key ) [ ] * pb . Reference { ret := make ( [ ] * pb . Reference , len ( key ) ) for i , k := range key { ret [ i ] = keyToProto ( appID , k ) } return ret }
4714	func referenceValueToKey ( r * pb . PropertyValue_ReferenceValue ) ( k * Key , err error ) { appID := r . GetApp ( ) namespace := r . GetNameSpace ( ) for _ , e := range r . Pathelement { k = & Key { kind : e . GetType ( ) , stringID : e . GetName ( ) , intID : e . GetId ( ) , parent : k , appID : appID , namespace : namespace , } if ! k . valid ( ) { return nil , ErrInvalidKey } } return }
4715	func keyToReferenceValue ( defaultAppID string , k * Key ) * pb . PropertyValue_ReferenceValue { ref := keyToProto ( defaultAppID , k ) pe := make ( [ ] * pb . PropertyValue_ReferenceValue_PathElement , len ( ref . Path . Element ) ) for i , e := range ref . Path . Element { pe [ i ] = & pb . PropertyValue_ReferenceValue_PathElement { Type : e . Type , Id : e . Id , Name : e . Name , } } return & pb . PropertyValue_ReferenceValue { App : ref . App , NameSpace : ref . NameSpace , Pathelement : pe , } }
4716	func Put ( c context . Context , key * Key , src interface { } ) ( * Key , error ) { k , err := PutMulti ( c , [ ] * Key { key } , [ ] interface { } { src } ) if err != nil { if me , ok := err . ( appengine . MultiError ) ; ok { return nil , me [ 0 ] } return nil , err } return k [ 0 ] , nil }
4717	func PutMulti ( c context . Context , key [ ] * Key , src interface { } ) ( [ ] * Key , error ) { v := reflect . ValueOf ( src ) multiArgType , _ := checkMultiArg ( v ) if multiArgType == multiArgTypeInvalid { return nil , errors . New ( "datastore: src has invalid type" ) } if len ( key ) != v . Len ( ) { return nil , errors . New ( "datastore: key and src slices have different length" ) } if len ( key ) == 0 { return nil , nil } appID := internal . FullyQualifiedAppID ( c ) if err := multiValid ( key ) ; err != nil { return nil , err } req := & pb . PutRequest { } for i := range key { elem := v . Index ( i ) if multiArgType == multiArgTypePropertyLoadSaver || multiArgType == multiArgTypeStruct { elem = elem . Addr ( ) } sProto , err := saveEntity ( appID , key [ i ] , elem . Interface ( ) ) if err != nil { return nil , err } req . Entity = append ( req . Entity , sProto ) } res := & pb . PutResponse { } if err := internal . Call ( c , "datastore_v3" , "Put" , req , res ) ; err != nil { return nil , err } if len ( key ) != len ( res . Key ) { return nil , errors . New ( "datastore: internal error: server returned the wrong number of keys" ) } ret := make ( [ ] * Key , len ( key ) ) for i := range ret { var err error ret [ i ] , err = protoToKey ( res . Key [ i ] ) if err != nil || ret [ i ] . Incomplete ( ) { return nil , errors . New ( "datastore: internal error: server returned an invalid key" ) } } return ret , nil }
4718	func Delete ( c context . Context , key * Key ) error { err := DeleteMulti ( c , [ ] * Key { key } ) if me , ok := err . ( appengine . MultiError ) ; ok { return me [ 0 ] } return err }
4719	func DeleteMulti ( c context . Context , key [ ] * Key ) error { if len ( key ) == 0 { return nil } if err := multiValid ( key ) ; err != nil { return err } req := & pb . DeleteRequest { Key : multiKeyToProto ( internal . FullyQualifiedAppID ( c ) , key ) , } res := & pb . DeleteResponse { } return internal . Call ( c , "datastore_v3" , "Delete" , req , res ) }
4720	func deploy ( ) error { vlogf ( "Running command %v" , flag . Args ( ) ) cmd := exec . Command ( flag . Arg ( 0 ) , flag . Args ( ) [ 1 : ] ... ) cmd . Stdin , cmd . Stdout , cmd . Stderr = os . Stdin , os . Stdout , os . Stderr if err := cmd . Run ( ) ; err != nil { return fmt . Errorf ( "unable to run %q: %v" , strings . Join ( flag . Args ( ) , " " ) , err ) } return nil }
4721	func ( qr * Result ) Next ( ) ( * Record , error ) { if qr . err != nil { return nil , qr . err } if len ( qr . logs ) > 0 { lr := qr . logs [ 0 ] qr . logs = qr . logs [ 1 : ] return lr , nil } if qr . request . Offset == nil && qr . resultsSeen { return nil , Done } if err := qr . run ( ) ; err != nil { return nil , err } return qr . Next ( ) }
4722	func protoToAppLogs ( logLines [ ] * pb . LogLine ) [ ] AppLog { appLogs := make ( [ ] AppLog , len ( logLines ) ) for i , line := range logLines { appLogs [ i ] = AppLog { Time : time . Unix ( 0 , * line . Time * 1e3 ) , Level : int ( * line . Level ) , Message : * line . LogMessage , } } return appLogs }
4723	func protoToRecord ( rl * pb . RequestLog ) * Record { offset , err := proto . Marshal ( rl . Offset ) if err != nil { offset = nil } return & Record { AppID : * rl . AppId , ModuleID : rl . GetModuleId ( ) , VersionID : * rl . VersionId , RequestID : rl . RequestId , Offset : offset , IP : * rl . Ip , Nickname : rl . GetNickname ( ) , AppEngineRelease : string ( rl . GetAppEngineRelease ( ) ) , StartTime : time . Unix ( 0 , * rl . StartTime * 1e3 ) , EndTime : time . Unix ( 0 , * rl . EndTime * 1e3 ) , Latency : time . Duration ( * rl . Latency ) * time . Microsecond , MCycles : * rl . Mcycles , Method : * rl . Method , Resource : * rl . Resource , HTTPVersion : * rl . HttpVersion , Status : * rl . Status , ResponseSize : * rl . ResponseSize , Referrer : rl . GetReferrer ( ) , UserAgent : rl . GetUserAgent ( ) , URLMapEntry : * rl . UrlMapEntry , Combined : * rl . Combined , Host : rl . GetHost ( ) , Cost : rl . GetCost ( ) , TaskQueueName : rl . GetTaskQueueName ( ) , TaskName : rl . GetTaskName ( ) , WasLoadingRequest : rl . GetWasLoadingRequest ( ) , PendingTime : time . Duration ( rl . GetPendingTime ( ) ) * time . Microsecond , Finished : rl . GetFinished ( ) , AppLogs : protoToAppLogs ( rl . Line ) , InstanceID : string ( rl . GetCloneKey ( ) ) , } }
4724	func ( params * Query ) Run ( c context . Context ) * Result { req , err := makeRequest ( params , internal . FullyQualifiedAppID ( c ) , appengine . VersionID ( c ) ) return & Result { context : c , request : req , err : err , } }
4725	func ( r * Result ) run ( ) error { res := & pb . LogReadResponse { } if err := internal . Call ( r . context , "logservice" , "Read" , r . request , res ) ; err != nil { return err } r . logs = make ( [ ] * Record , len ( res . Log ) ) r . request . Offset = res . Offset r . resultsSeen = true for i , log := range res . Log { r . logs [ i ] = protoToRecord ( log ) } return nil }
4726	func Current ( c context . Context ) * User { h := internal . IncomingHeaders ( c ) u := & User { Email : h . Get ( "X-AppEngine-User-Email" ) , AuthDomain : h . Get ( "X-AppEngine-Auth-Domain" ) , ID : h . Get ( "X-AppEngine-User-Id" ) , Admin : h . Get ( "X-AppEngine-User-Is-Admin" ) == "1" , FederatedIdentity : h . Get ( "X-AppEngine-Federated-Identity" ) , FederatedProvider : h . Get ( "X-AppEngine-Federated-Provider" ) , } if u . Email == "" && u . FederatedIdentity == "" { return nil } return u }
4727	func IsAdmin ( c context . Context ) bool { h := internal . IncomingHeaders ( c ) return h . Get ( "X-AppEngine-User-Is-Admin" ) == "1" }
4728	func isErrFieldMismatch ( err error ) bool { _ , ok := err . ( * datastore . ErrFieldMismatch ) return ok }
4729	func Stat ( c context . Context , blobKey appengine . BlobKey ) ( * BlobInfo , error ) { c , _ = appengine . Namespace ( c , "" ) dskey := datastore . NewKey ( c , blobInfoKind , string ( blobKey ) , 0 , nil ) bi := & BlobInfo { BlobKey : blobKey , } if err := datastore . Get ( c , dskey , bi ) ; err != nil && ! isErrFieldMismatch ( err ) { return nil , err } return bi , nil }
4730	func Send ( response http . ResponseWriter , blobKey appengine . BlobKey ) { hdr := response . Header ( ) hdr . Set ( "X-AppEngine-BlobKey" , string ( blobKey ) ) if hdr . Get ( "Content-Type" ) == "" { hdr . Set ( "Content-Type" , "application/vnd.google.appengine.auto" ) } }
4731	func UploadURL ( c context . Context , successPath string , opts * UploadURLOptions ) ( * url . URL , error ) { req := & blobpb . CreateUploadURLRequest { SuccessPath : proto . String ( successPath ) , } if opts != nil { if n := opts . MaxUploadBytes ; n != 0 { req . MaxUploadSizeBytes = & n } if n := opts . MaxUploadBytesPerBlob ; n != 0 { req . MaxUploadSizePerBlobBytes = & n } if s := opts . StorageBucket ; s != "" { req . GsBucketName = & s } } res := & blobpb . CreateUploadURLResponse { } if err := internal . Call ( c , "blobstore" , "CreateUploadURL" , req , res ) ; err != nil { return nil , err } return url . Parse ( * res . Url ) }
4732	func Delete ( c context . Context , blobKey appengine . BlobKey ) error { return DeleteMulti ( c , [ ] appengine . BlobKey { blobKey } ) }
4733	func DeleteMulti ( c context . Context , blobKey [ ] appengine . BlobKey ) error { s := make ( [ ] string , len ( blobKey ) ) for i , b := range blobKey { s [ i ] = string ( b ) } req := & blobpb . DeleteBlobRequest { BlobKey : s , } res := & basepb . VoidProto { } if err := internal . Call ( c , "blobstore" , "DeleteBlob" , req , res ) ; err != nil { return err } return nil }
4734	func NewReader ( c context . Context , blobKey appengine . BlobKey ) Reader { return openBlob ( c , blobKey ) }
4735	func Handle ( f func ( c context . Context , m * Message ) ) { http . HandleFunc ( "/_ah/xmpp/message/chat/" , func ( _ http . ResponseWriter , r * http . Request ) { f ( appengine . NewContext ( r ) , & Message { Sender : r . FormValue ( "from" ) , To : [ ] string { r . FormValue ( "to" ) } , Body : r . FormValue ( "body" ) , } ) } ) }
4736	func ( m * Message ) Send ( c context . Context ) error { req := & pb . XmppMessageRequest { Jid : m . To , Body : & m . Body , RawXml : & m . RawXML , } if m . Type != "" && m . Type != "chat" { req . Type = & m . Type } if m . Sender != "" { req . FromJid = & m . Sender } res := & pb . XmppMessageResponse { } if err := internal . Call ( c , "xmpp" , "SendMessage" , req , res ) ; err != nil { return err } if len ( res . Status ) != len ( req . Jid ) { return fmt . Errorf ( "xmpp: sent message to %d JIDs, but only got %d statuses back" , len ( req . Jid ) , len ( res . Status ) ) } me , any := make ( appengine . MultiError , len ( req . Jid ) ) , false for i , st := range res . Status { if st != pb . XmppMessageResponse_NO_ERROR { me [ i ] = errors . New ( st . String ( ) ) any = true } } if any { return me } return nil }
4737	func Invite ( c context . Context , to , from string ) error { req := & pb . XmppInviteRequest { Jid : & to , } if from != "" { req . FromJid = & from } res := & pb . XmppInviteResponse { } return internal . Call ( c , "xmpp" , "SendInvite" , req , res ) }
4738	func ( p * Presence ) Send ( c context . Context ) error { req := & pb . XmppSendPresenceRequest { Jid : & p . To , } if p . State != "" { req . Show = & p . State } if p . Type != "" { req . Type = & p . Type } if p . Sender != "" { req . FromJid = & p . Sender } if p . Status != "" { req . Status = & p . Status } res := & pb . XmppSendPresenceResponse { } return internal . Call ( c , "xmpp" , "SendPresence" , req , res ) }
4739	func GetPresence ( c context . Context , to string , from string ) ( string , error ) { req := & pb . PresenceRequest { Jid : & to , } if from != "" { req . FromJid = & from } res := & pb . PresenceResponse { } if err := internal . Call ( c , "xmpp" , "GetPresence" , req , res ) ; err != nil { return "" , err } if ! * res . IsAvailable || res . Presence == nil { return "" , ErrPresenceUnavailable } presence , ok := presenceMap [ * res . Presence ] if ok { return presence , nil } return "" , fmt . Errorf ( "xmpp: unknown presence %v" , * res . Presence ) }
4740	func GetPresenceMulti ( c context . Context , to [ ] string , from string ) ( [ ] string , error ) { req := & pb . BulkPresenceRequest { Jid : to , } if from != "" { req . FromJid = & from } res := & pb . BulkPresenceResponse { } if err := internal . Call ( c , "xmpp" , "BulkGetPresence" , req , res ) ; err != nil { return nil , err } presences := make ( [ ] string , 0 , len ( res . PresenceResponse ) ) errs := appengine . MultiError { } addResult := func ( presence string , err error ) { presences = append ( presences , presence ) errs = append ( errs , err ) } anyErr := false for _ , subres := range res . PresenceResponse { if ! subres . GetValid ( ) { anyErr = true addResult ( "" , ErrInvalidJID ) continue } if ! * subres . IsAvailable || subres . Presence == nil { anyErr = true addResult ( "" , ErrPresenceUnavailable ) continue } presence , ok := presenceMap [ * subres . Presence ] if ok { addResult ( presence , nil ) } else { anyErr = true addResult ( "" , fmt . Errorf ( "xmpp: unknown presence %q" , * subres . Presence ) ) } } if anyErr { return presences , errs } return presences , nil }
4741	func newStructFLS ( p interface { } ) ( FieldLoadSaver , error ) { v := reflect . ValueOf ( p ) if v . Kind ( ) != reflect . Ptr || v . IsNil ( ) || v . Elem ( ) . Kind ( ) != reflect . Struct { return nil , ErrInvalidDocumentType } codec , err := loadCodec ( v . Elem ( ) . Type ( ) ) if err != nil { return nil , err } return structFLS { v . Elem ( ) , codec } , nil }
4742	func SaveStruct ( src interface { } ) ( [ ] Field , error ) { f , _ , err := saveStructWithMeta ( src ) return f , err }
4743	func Namespaces ( ctx context . Context ) ( [ ] string , error ) { q := NewQuery ( namespaceKind ) . KeysOnly ( ) keys , err := q . GetAll ( ctx , nil ) if err != nil { return nil , err } return keyNames ( keys ) , nil }
4744	func Kinds ( ctx context . Context ) ( [ ] string , error ) { q := NewQuery ( kindKind ) . KeysOnly ( ) keys , err := q . GetAll ( ctx , nil ) if err != nil { return nil , err } return keyNames ( keys ) , nil }
4745	func RunInTransaction ( c context . Context , f func ( tc context . Context ) error , opts * TransactionOptions ) error { xg := false if opts != nil { xg = opts . XG } readOnly := false if opts != nil { readOnly = opts . ReadOnly } attempts := 3 if opts != nil && opts . Attempts > 0 { attempts = opts . Attempts } var t * pb . Transaction var err error for i := 0 ; i < attempts ; i ++ { if t , err = internal . RunTransactionOnce ( c , f , xg , readOnly , t ) ; err != internal . ErrConcurrentTransaction { return err } } return ErrConcurrentTransaction }
4746	func imports ( f * ast . File , path string ) bool { return importSpec ( f , path ) != nil }
4747	func importSpec ( f * ast . File , path string ) * ast . ImportSpec { for _ , s := range f . Imports { if importPath ( s ) == path { return s } } return nil }
4748	func declImports ( gen * ast . GenDecl , path string ) bool { if gen . Tok != token . IMPORT { return false } for _ , spec := range gen . Specs { impspec := spec . ( * ast . ImportSpec ) if importPath ( impspec ) == path { return true } } return false }
4749	func isPkgDot ( t ast . Expr , pkg , name string ) bool { sel , ok := t . ( * ast . SelectorExpr ) return ok && isTopName ( sel . X , pkg ) && sel . Sel . String ( ) == name }
4750	func isTopName ( n ast . Expr , name string ) bool { id , ok := n . ( * ast . Ident ) return ok && id . Name == name && id . Obj == nil }
4751	func isName ( n ast . Expr , name string ) bool { id , ok := n . ( * ast . Ident ) return ok && id . String ( ) == name }
4752	func isCall ( t ast . Expr , pkg , name string ) bool { call , ok := t . ( * ast . CallExpr ) return ok && isPkgDot ( call . Fun , pkg , name ) }
4753	func refersTo ( n ast . Node , x * ast . Ident ) bool { id , ok := n . ( * ast . Ident ) return ok && id . Obj == x . Obj && id . Name == x . Name }
4754	func isEmptyString ( n ast . Expr ) bool { lit , ok := n . ( * ast . BasicLit ) return ok && lit . Kind == token . STRING && len ( lit . Value ) == 2 }
4755	func countUses ( x * ast . Ident , scope [ ] ast . Stmt ) int { count := 0 ff := func ( n interface { } ) { if n , ok := n . ( ast . Node ) ; ok && refersTo ( n , x ) { count ++ } } for _ , n := range scope { walk ( n , ff ) } return count }
4756	func assignsTo ( x * ast . Ident , scope [ ] ast . Stmt ) bool { assigned := false ff := func ( n interface { } ) { if assigned { return } switch n := n . ( type ) { case * ast . UnaryExpr : if n . Op == token . AND && refersTo ( n . X , x ) { assigned = true return } case * ast . AssignStmt : for _ , l := range n . Lhs { if refersTo ( l , x ) { assigned = true return } } } } for _ , n := range scope { if assigned { break } walk ( n , ff ) } return assigned }
4757	func newPkgDot ( pos token . Pos , pkg , name string ) ast . Expr { return & ast . SelectorExpr { X : & ast . Ident { NamePos : pos , Name : pkg , } , Sel : & ast . Ident { NamePos : pos , Name : name , } , } }
4758	func renameTop ( f * ast . File , old , new string ) bool { var fixed bool for _ , s := range f . Imports { if s . Name != nil { if s . Name . Name == old { s . Name . Name = new fixed = true } } else { _ , thisName := path . Split ( importPath ( s ) ) if thisName == old { s . Name = ast . NewIdent ( new ) fixed = true } } } for _ , d := range f . Decls { switch d := d . ( type ) { case * ast . FuncDecl : if d . Recv == nil && d . Name . Name == old { d . Name . Name = new d . Name . Obj . Name = new fixed = true } case * ast . GenDecl : for _ , s := range d . Specs { switch s := s . ( type ) { case * ast . TypeSpec : if s . Name . Name == old { s . Name . Name = new s . Name . Obj . Name = new fixed = true } case * ast . ValueSpec : for _ , n := range s . Names { if n . Name == old { n . Name = new n . Obj . Name = new fixed = true } } } } } } walk ( f , func ( n interface { } ) { id , ok := n . ( * ast . Ident ) if ok && isTopName ( id , old ) { id . Name = new fixed = true } if ok && id . Obj != nil && id . Name == old && id . Obj . Name == new { id . Name = id . Obj . Name fixed = true } } ) return fixed }
4759	func matchLen ( x , y string ) int { i := 0 for i < len ( x ) && i < len ( y ) && x [ i ] == y [ i ] { i ++ } return i }
4760	func deleteImport ( f * ast . File , path string ) ( deleted bool ) { oldImport := importSpec ( f , path ) for i , decl := range f . Decls { gen , ok := decl . ( * ast . GenDecl ) if ! ok || gen . Tok != token . IMPORT { continue } for j , spec := range gen . Specs { impspec := spec . ( * ast . ImportSpec ) if oldImport != impspec { continue } deleted = true copy ( gen . Specs [ j : ] , gen . Specs [ j + 1 : ] ) gen . Specs = gen . Specs [ : len ( gen . Specs ) - 1 ] if len ( gen . Specs ) == 0 { copy ( f . Decls [ i : ] , f . Decls [ i + 1 : ] ) f . Decls = f . Decls [ : len ( f . Decls ) - 1 ] } else if len ( gen . Specs ) == 1 { gen . Lparen = token . NoPos } if j > 0 { gen . Specs [ j - 1 ] . ( * ast . ImportSpec ) . EndPos = impspec . End ( ) } break } } for i , imp := range f . Imports { if imp == oldImport { copy ( f . Imports [ i : ] , f . Imports [ i + 1 : ] ) f . Imports = f . Imports [ : len ( f . Imports ) - 1 ] break } } return }
4761	func rewriteImport ( f * ast . File , oldPath , newPath string ) ( rewrote bool ) { for _ , imp := range f . Imports { if importPath ( imp ) == oldPath { rewrote = true imp . EndPos = imp . End ( ) imp . Path . Value = strconv . Quote ( newPath ) } } return }
4762	func DefaultTicket ( ) string { defaultTicketOnce . Do ( func ( ) { if IsDevAppServer ( ) { defaultTicket = "testapp" + defaultTicketSuffix return } appID := partitionlessAppID ( ) escAppID := strings . Replace ( strings . Replace ( appID , ":" , "_" , - 1 ) , "." , "_" , - 1 ) majVersion := VersionID ( nil ) if i := strings . Index ( majVersion , "." ) ; i > 0 { majVersion = majVersion [ : i ] } defaultTicket = fmt . Sprintf ( "%s/%s.%s.%s" , escAppID , ModuleName ( nil ) , majVersion , InstanceID ( ) ) } ) return defaultTicket }
4763	func ( c * context ) flushLog ( force bool ) ( flushed bool ) { c . pendingLogs . Lock ( ) n , rem := 0 , 30 << 20 for ; n < len ( c . pendingLogs . lines ) ; n ++ { ll := c . pendingLogs . lines [ n ] nb := proto . Size ( ll ) + 3 if nb > rem { break } rem -= nb } lines := c . pendingLogs . lines [ : n ] c . pendingLogs . lines = c . pendingLogs . lines [ n : ] c . pendingLogs . Unlock ( ) if len ( lines ) == 0 && ! force { return false } rescueLogs := false defer func ( ) { if rescueLogs { c . pendingLogs . Lock ( ) c . pendingLogs . lines = append ( lines , c . pendingLogs . lines ... ) c . pendingLogs . Unlock ( ) } } ( ) buf , err := proto . Marshal ( & logpb . UserAppLogGroup { LogLine : lines , } ) if err != nil { log . Printf ( "internal.flushLog: marshaling UserAppLogGroup: %v" , err ) rescueLogs = true return false } req := & logpb . FlushRequest { Logs : buf , } res := & basepb . VoidProto { } c . pendingLogs . Lock ( ) c . pendingLogs . flushes ++ c . pendingLogs . Unlock ( ) if err := Call ( toContext ( c ) , "logservice" , "Flush" , req , res ) ; err != nil { log . Printf ( "internal.flushLog: Flush RPC: %v" , err ) rescueLogs = true return false } return true }
4764	func withDeadline ( parent context . Context , deadline time . Time ) ( context . Context , context . CancelFunc ) { if deadline . IsZero ( ) { return parent , func ( ) { } } return context . WithDeadline ( parent , deadline ) }
4765	func ( cn * Conn ) KeepAlive ( ) error { req := & pb . GetSocketNameRequest { SocketDescriptor : & cn . desc , } res := & pb . GetSocketNameReply { } return internal . Call ( cn . ctx , "remote_socket" , "GetSocketName" , req , res ) }
4766	func applyTransaction ( pb proto . Message , t * pb . Transaction ) { v := reflect . ValueOf ( pb ) if f , ok := transactionSetters [ v . Type ( ) ] ; ok { f . Call ( [ ] reflect . Value { v , reflect . ValueOf ( t ) } ) } }
4767	func analyze ( tags [ ] string ) ( * app , error ) { ctxt := buildContext ( tags ) hasMain , appFiles , err := checkMain ( ctxt ) if err != nil { return nil , err } gopath := filepath . SplitList ( ctxt . GOPATH ) im , err := imports ( ctxt , * rootDir , gopath ) return & app { hasMain : hasMain , appFiles : appFiles , imports : im , } , err }
4768	func buildContext ( tags [ ] string ) * build . Context { return & build . Context { GOARCH : build . Default . GOARCH , GOOS : build . Default . GOOS , GOROOT : build . Default . GOROOT , GOPATH : build . Default . GOPATH , Compiler : build . Default . Compiler , BuildTags : append ( build . Default . BuildTags , tags ... ) , } }
4769	func synthesizeMain ( tw * tar . Writer , appFiles [ ] string ) error { appMap := make ( map [ string ] bool ) for _ , f := range appFiles { appMap [ f ] = true } var f string for i := 0 ; i < 100 ; i ++ { f = fmt . Sprintf ( "app_main%d.go" , i ) if ! appMap [ filepath . Join ( * rootDir , f ) ] { break } } if appMap [ filepath . Join ( * rootDir , f ) ] { return fmt . Errorf ( "unable to find unique name for %v" , f ) } hdr := & tar . Header { Name : f , Mode : 0644 , Size : int64 ( len ( newMain ) ) , } if err := tw . WriteHeader ( hdr ) ; err != nil { return fmt . Errorf ( "unable to write header for %v: %v" , f , err ) } if _ , err := tw . Write ( [ ] byte ( newMain ) ) ; err != nil { return fmt . Errorf ( "unable to write %v to tar file: %v" , f , err ) } return nil }
4770	func findInGopath ( dir string , gopath [ ] string ) ( string , error ) { for _ , v := range gopath { dst := filepath . Join ( v , "src" , dir ) if _ , err := os . Stat ( dst ) ; err == nil { return dst , nil } } return "" , fmt . Errorf ( "unable to find package %v in gopath %v" , dir , gopath ) }
4771	func copyTree ( tw * tar . Writer , dstDir , srcDir string ) error { entries , err := ioutil . ReadDir ( srcDir ) if err != nil { return fmt . Errorf ( "unable to read dir %v: %v" , srcDir , err ) } for _ , entry := range entries { n := entry . Name ( ) if skipFiles [ n ] { continue } s := filepath . Join ( srcDir , n ) d := filepath . Join ( dstDir , n ) if entry . IsDir ( ) { if err := copyTree ( tw , d , s ) ; err != nil { return fmt . Errorf ( "unable to copy dir %v to %v: %v" , s , d , err ) } continue } if err := copyFile ( tw , d , s ) ; err != nil { return fmt . Errorf ( "unable to copy dir %v to %v: %v" , s , d , err ) } } return nil }
4772	func copyFile ( tw * tar . Writer , dst , src string ) error { s , err := os . Open ( src ) if err != nil { return fmt . Errorf ( "unable to open %v: %v" , src , err ) } defer s . Close ( ) fi , err := s . Stat ( ) if err != nil { return fmt . Errorf ( "unable to stat %v: %v" , src , err ) } hdr , err := tar . FileInfoHeader ( fi , dst ) if err != nil { return fmt . Errorf ( "unable to create tar header for %v: %v" , dst , err ) } hdr . Name = dst if err := tw . WriteHeader ( hdr ) ; err != nil { return fmt . Errorf ( "unable to write header for %v: %v" , dst , err ) } _ , err = io . Copy ( tw , s ) if err != nil { return fmt . Errorf ( "unable to copy %v to %v: %v" , src , dst , err ) } return nil }
4773	func checkMain ( ctxt * build . Context ) ( bool , [ ] string , error ) { pkg , err := ctxt . ImportDir ( * rootDir , 0 ) if err != nil { return false , nil , fmt . Errorf ( "unable to analyze source: %v" , err ) } if ! pkg . IsCommand ( ) { errorf ( "Your app's package needs to be changed from %q to \"main\".\n" , \" ) } \" \n pkg . Name var hasMain bool }
4774	func isMain ( f * ast . FuncDecl ) bool { ft := f . Type return f . Name . Name == "main" && f . Recv == nil && ft . Params . NumFields ( ) == 0 && ft . Results . NumFields ( ) == 0 }
4775	func readFile ( filename string ) ( hasMain bool , err error ) { var src [ ] byte src , err = ioutil . ReadFile ( filename ) if err != nil { return } fset := token . NewFileSet ( ) file , err := parser . ParseFile ( fset , filename , src , 0 ) for _ , decl := range file . Decls { funcDecl , ok := decl . ( * ast . FuncDecl ) if ! ok { continue } if ! isMain ( funcDecl ) { continue } hasMain = true break } return }
4776	func initField ( val reflect . Value , index [ ] int ) reflect . Value { for _ , i := range index [ : len ( index ) - 1 ] { val = val . Field ( i ) if val . Kind ( ) == reflect . Ptr { if val . IsNil ( ) { val . Set ( reflect . New ( val . Type ( ) . Elem ( ) ) ) } val = val . Elem ( ) } } return val . Field ( index [ len ( index ) - 1 ] ) }
4777	func loadEntity ( dst interface { } , src * pb . EntityProto ) ( err error ) { ent , err := protoToEntity ( src ) if err != nil { return err } if e , ok := dst . ( PropertyLoadSaver ) ; ok { return e . Load ( ent . Properties ) } return LoadStruct ( dst , ent . Properties ) }
4778	func validIndexNameOrDocID ( s string ) bool { if strings . HasPrefix ( s , "!" ) { return false } for _ , c := range s { if c < 0x21 || 0x7f <= c { return false } } return true }
4779	func Open ( name string ) ( * Index , error ) { if ! validIndexNameOrDocID ( name ) { return nil , fmt . Errorf ( "search: invalid index name %q" , name ) } return & Index { spec : pb . IndexSpec { Name : & name , } , } , nil }
4780	func ( x * Index ) Put ( c context . Context , id string , src interface { } ) ( string , error ) { ids , err := x . PutMulti ( c , [ ] string { id } , [ ] interface { } { src } ) if err != nil { return "" , err } return ids [ 0 ] , nil }
4781	func ( x * Index ) Get ( c context . Context , id string , dst interface { } ) error { if id == "" || ! validIndexNameOrDocID ( id ) { return fmt . Errorf ( "search: invalid ID %q" , id ) } req := & pb . ListDocumentsRequest { Params : & pb . ListDocumentsParams { IndexSpec : & x . spec , StartDocId : proto . String ( id ) , Limit : proto . Int32 ( 1 ) , } , } res := & pb . ListDocumentsResponse { } if err := internal . Call ( c , "search" , "ListDocuments" , req , res ) ; err != nil { return err } if res . Status == nil || res . Status . GetCode ( ) != pb . SearchServiceError_OK { return fmt . Errorf ( "search: %s: %s" , res . Status . GetCode ( ) , res . Status . GetErrorDetail ( ) ) } if len ( res . Document ) != 1 || res . Document [ 0 ] . GetId ( ) != id { return ErrNoSuchDocument } return loadDoc ( dst , res . Document [ 0 ] , nil ) }
4782	func ( x * Index ) Delete ( c context . Context , id string ) error { return x . DeleteMulti ( c , [ ] string { id } ) }
4783	func ( x * Index ) DeleteMulti ( c context . Context , ids [ ] string ) error { if len ( ids ) > maxDocumentsPerPutDelete { return ErrTooManyDocuments } req := & pb . DeleteDocumentRequest { Params : & pb . DeleteDocumentParams { DocId : ids , IndexSpec : & x . spec , } , } res := & pb . DeleteDocumentResponse { } if err := internal . Call ( c , "search" , "DeleteDocument" , req , res ) ; err != nil { return err } if len ( res . Status ) != len ( ids ) { return fmt . Errorf ( "search: internal error: wrong number of results (%d, expected %d)" , len ( res . Status ) , len ( ids ) ) } multiErr , hasErr := make ( appengine . MultiError , len ( ids ) ) , false for i , s := range res . Status { if s . GetCode ( ) != pb . SearchServiceError_OK { multiErr [ i ] = fmt . Errorf ( "search: %s: %s" , s . GetCode ( ) , s . GetErrorDetail ( ) ) hasErr = true } } if hasErr { return multiErr } return nil }
4784	func ( x * Index ) Search ( c context . Context , query string , opts * SearchOptions ) * Iterator { t := & Iterator { c : c , index : x , searchQuery : query , more : moreSearch , } if opts != nil { if opts . Cursor != "" { if opts . Offset != 0 { return errIter ( "at most one of Cursor and Offset may be specified" ) } t . searchCursor = proto . String ( string ( opts . Cursor ) ) } t . limit = opts . Limit t . fields = opts . Fields t . idsOnly = opts . IDsOnly t . sort = opts . Sort t . exprs = opts . Expressions t . refinements = opts . Refinements t . facetOpts = opts . Facets t . searchOffset = opts . Offset t . countAccuracy = opts . CountAccuracy } return t }
4785	func ( t * Iterator ) fetchMore ( ) { if t . err == nil && len ( t . listRes ) + len ( t . searchRes ) == 0 && t . more != nil { t . err = t . more ( t ) } }
4786	func ( t * Iterator ) Next ( dst interface { } ) ( string , error ) { t . fetchMore ( ) if t . err != nil { return "" , t . err } var doc * pb . Document var exprs [ ] * pb . Field switch { case len ( t . listRes ) != 0 : doc = t . listRes [ 0 ] t . listRes = t . listRes [ 1 : ] case len ( t . searchRes ) != 0 : doc = t . searchRes [ 0 ] . Document exprs = t . searchRes [ 0 ] . Expression t . searchCursor = t . searchRes [ 0 ] . Cursor t . searchRes = t . searchRes [ 1 : ] default : return "" , Done } if doc == nil { return "" , errors . New ( "search: internal error: no document returned" ) } if ! t . idsOnly && dst != nil { if err := loadDoc ( dst , doc , exprs ) ; err != nil { return "" , err } } return doc . GetId ( ) , nil }
4787	func ( t * Iterator ) Facets ( ) ( [ ] [ ] FacetResult , error ) { t . fetchMore ( ) if t . err != nil && t . err != Done { return nil , t . err } var facets [ ] [ ] FacetResult for _ , f := range t . facetRes { fres := make ( [ ] FacetResult , 0 , len ( f . Value ) ) for _ , v := range f . Value { ref := v . Refinement facet := FacetResult { Facet : Facet { Name : ref . GetName ( ) } , Count : int ( v . GetCount ( ) ) , } if ref . Value != nil { facet . Value = Atom ( * ref . Value ) } else { facet . Value = protoToRange ( ref . Range ) } fres = append ( fres , facet ) } facets = append ( facets , fres ) } return facets , nil }
4788	func DefaultBucketName ( c context . Context ) ( string , error ) { req := & aipb . GetDefaultGcsBucketNameRequest { } res := & aipb . GetDefaultGcsBucketNameResponse { } err := internal . Call ( c , "app_identity_service" , "GetDefaultGcsBucketName" , req , res ) if err != nil { return "" , fmt . Errorf ( "file: no default bucket name returned in RPC response: %v" , res ) } return res . GetDefaultGcsBucketName ( ) , nil }
4789	func ( k * Key ) valid ( ) bool { if k == nil { return false } for ; k != nil ; k = k . parent { if k . kind == "" || k . appID == "" { return false } if k . stringID != "" && k . intID != 0 { return false } if k . parent != nil { if k . parent . Incomplete ( ) { return false } if k . parent . appID != k . appID || k . parent . namespace != k . namespace { return false } } } return true }
4790	func ( k * Key ) Equal ( o * Key ) bool { for k != nil && o != nil { if k . kind != o . kind || k . stringID != o . stringID || k . intID != o . intID || k . appID != o . appID || k . namespace != o . namespace { return false } k , o = k . parent , o . parent } return k == o }
4791	func ( k * Key ) root ( ) * Key { for k . parent != nil { k = k . parent } return k }
4792	func ( k * Key ) marshal ( b * bytes . Buffer ) { if k . parent != nil { k . parent . marshal ( b ) } b . WriteByte ( '/' ) b . WriteString ( k . kind ) b . WriteByte ( ',' ) if k . stringID != "" { b . WriteString ( k . stringID ) } else { b . WriteString ( strconv . FormatInt ( k . intID , 10 ) ) } }
4793	func ( k * Key ) String ( ) string { if k == nil { return "" } b := bytes . NewBuffer ( make ( [ ] byte , 0 , 512 ) ) k . marshal ( b ) return b . String ( ) }
4794	func ( k * Key ) Encode ( ) string { ref := keyToProto ( "" , k ) b , err := proto . Marshal ( ref ) if err != nil { panic ( err ) } return strings . TrimRight ( base64 . URLEncoding . EncodeToString ( b ) , "=" ) }
4795	func DecodeKey ( encoded string ) ( * Key , error ) { if m := len ( encoded ) % 4 ; m != 0 { encoded += strings . Repeat ( "=" , 4 - m ) } b , err := base64 . URLEncoding . DecodeString ( encoded ) if err != nil { return nil , err } ref := new ( pb . Reference ) if err := proto . Unmarshal ( b , ref ) ; err != nil { return nil , err } return protoToKey ( ref ) }
4796	func NewIncompleteKey ( c context . Context , kind string , parent * Key ) * Key { return NewKey ( c , kind , "" , 0 , parent ) }
4797	func NewKey ( c context . Context , kind , stringID string , intID int64 , parent * Key ) * Key { var namespace string if parent != nil { namespace = parent . namespace } else { namespace = internal . NamespaceFromContext ( c ) } return & Key { kind : kind , stringID : stringID , intID : intID , parent : parent , appID : internal . FullyQualifiedAppID ( c ) , namespace : namespace , } }
4798	func AllocateIDs ( c context . Context , kind string , parent * Key , n int ) ( low , high int64 , err error ) { if kind == "" { return 0 , 0 , errors . New ( "datastore: AllocateIDs given an empty kind" ) } if n < 0 { return 0 , 0 , fmt . Errorf ( "datastore: AllocateIDs given a negative count: %d" , n ) } if n == 0 { return 0 , 0 , nil } req := & pb . AllocateIdsRequest { ModelKey : keyToProto ( "" , NewIncompleteKey ( c , kind , parent ) ) , Size : proto . Int64 ( int64 ( n ) ) , } res := & pb . AllocateIdsResponse { } if err := internal . Call ( c , "datastore_v3" , "AllocateIds" , req , res ) ; err != nil { return 0 , 0 , err } low = res . GetStart ( ) high = res . GetEnd ( ) + 1 if low + int64 ( n ) != high { return 0 , 0 , fmt . Errorf ( "datastore: internal error: could not allocate %d IDs" , n ) } return low , high , nil }
4799	func IsOverQuota ( err error ) bool { callErr , ok := err . ( * internal . CallError ) return ok && callErr . Code == 4 }
4800	func ClassicContextFromContext ( ctx netcontext . Context ) ( appengine . Context , error ) { c := fromContext ( ctx ) if c == nil { return nil , errNotAppEngineContext } return c , nil }
4801	func Send ( c context . Context , msg * Message ) error { return send ( c , "Send" , msg ) }
4802	func SendToAdmins ( c context . Context , msg * Message ) error { return send ( c , "SendToAdmins" , msg ) }
4803	func ( r * Report ) Failures ( ) int { count := 0 for _ , p := range r . Packages { for _ , t := range p . Tests { if t . Result == FAIL { count ++ } } } return count }
4804	func decodeFieldNumberAndTyp3 ( bz [ ] byte ) ( num uint32 , typ Typ3 , n int , err error ) { var value64 = uint64 ( 0 ) value64 , n , err = DecodeUvarint ( bz ) if err != nil { return } typ = Typ3 ( value64 & 0x07 ) var num64 uint64 num64 = value64 >> 3 if num64 > ( 1 << 29 - 1 ) { err = fmt . Errorf ( "invalid field num %v" , num64 ) return } num = uint32 ( num64 ) return }
4805	func checkTyp3 ( rt reflect . Type , typ Typ3 , fopts FieldOptions ) ( err error ) { typWanted := typeToTyp3 ( rt , fopts ) if typ != typWanted { err = fmt . Errorf ( "unexpected Typ3. want %v, got %v" , typWanted , typ ) } return }
4806	func decodeTyp3 ( bz [ ] byte ) ( typ Typ3 , n int , err error ) { if len ( bz ) == 0 { err = fmt . Errorf ( "EOF while reading typ3 byte" ) return } if bz [ 0 ] & 0xF8 != 0 { err = fmt . Errorf ( "invalid typ3 byte: %v" , Typ3 ( bz [ 0 ] ) . String ( ) ) return } typ = Typ3 ( bz [ 0 ] ) n = 1 return }
4807	func NewPrefixBytes ( prefixBytes [ ] byte ) PrefixBytes { pb := PrefixBytes { } copy ( pb [ : ] , prefixBytes ) return pb }
4808	func getLengthStr ( info * TypeInfo ) string { switch info . Type . Kind ( ) { case reflect . Array , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 , reflect . Float32 , reflect . Float64 , reflect . Complex64 , reflect . Complex128 : s := info . Type . Size ( ) return fmt . Sprintf ( "0x%X" , s ) default : return "variable" } }
4809	func ( cdc * Codec ) collectImplementers_nolock ( info * TypeInfo ) { for _ , cinfo := range cdc . concreteInfos { if cinfo . PtrToType . Implements ( info . Type ) { info . Implementers [ cinfo . Prefix ] = append ( info . Implementers [ cinfo . Prefix ] , cinfo ) } } }
4810	func ( cdc * Codec ) checkConflictsInPrio_nolock ( iinfo * TypeInfo ) error { for _ , cinfos := range iinfo . Implementers { if len ( cinfos ) < 2 { continue } for _ , cinfo := range cinfos { var inPrio = false for _ , disfix := range iinfo . InterfaceInfo . Priority { if cinfo . GetDisfix ( ) == disfix { inPrio = true } } if ! inPrio { return fmt . Errorf ( "%v conflicts with %v other(s). Add it to the priority list for %v." , cinfo . Type , len ( cinfos ) , iinfo . Type ) } } } return nil }
4811	func constructConcreteType ( cinfo * TypeInfo ) ( crv , irvSet reflect . Value ) { if cinfo . PointerPreferred { cPtrRv := reflect . New ( cinfo . Type ) crv = cPtrRv . Elem ( ) irvSet = cPtrRv } else { crv = reflect . New ( cinfo . Type ) . Elem ( ) irvSet = crv } return }
4812	func ( cdc * Codec ) MarshalBinaryLengthPrefixedWriter ( w io . Writer , o interface { } ) ( n int64 , err error ) { var bz , _n = [ ] byte ( nil ) , int ( 0 ) bz , err = cdc . MarshalBinaryLengthPrefixed ( o ) if err != nil { return 0 , err } _n , err = w . Write ( bz ) n = int64 ( _n ) return }
4813	func ( cdc * Codec ) MarshalBinaryBare ( o interface { } ) ( [ ] byte , error ) { var rv , _ , isNilPtr = derefPointers ( reflect . ValueOf ( o ) ) if isNilPtr { panic ( "MarshalBinaryBare cannot marshal a nil pointer directly. Try wrapping in a struct?" ) } var bz [ ] byte buf := new ( bytes . Buffer ) rt := rv . Type ( ) info , err := cdc . getTypeInfo_wlock ( rt ) if err != nil { return nil , err } err = cdc . encodeReflectBinary ( buf , info , rv , FieldOptions { BinFieldNum : 1 } , true ) if err != nil { return nil , err } bz = buf . Bytes ( ) if info . Registered { pb := info . Prefix . Bytes ( ) bz = append ( pb , bz ... ) } return bz , nil }
4814	func ( cdc * Codec ) UnmarshalBinaryLengthPrefixed ( bz [ ] byte , ptr interface { } ) error { if len ( bz ) == 0 { return errors . New ( "UnmarshalBinaryLengthPrefixed cannot decode empty bytes" ) } u64 , n := binary . Uvarint ( bz ) if n < 0 { return fmt . Errorf ( "Error reading msg byte-length prefix: got code %v" , n ) } if u64 > uint64 ( len ( bz ) - n ) { return fmt . Errorf ( "Not enough bytes to read in UnmarshalBinaryLengthPrefixed, want %v more bytes but only have %v" , u64 , len ( bz ) - n ) } else if u64 < uint64 ( len ( bz ) - n ) { return fmt . Errorf ( "Bytes left over in UnmarshalBinaryLengthPrefixed, should read %v more bytes but have %v" , u64 , len ( bz ) - n ) } bz = bz [ n : ] return cdc . UnmarshalBinaryBare ( bz , ptr ) }
4815	func ( cdc * Codec ) UnmarshalBinaryBare ( bz [ ] byte , ptr interface { } ) error { rv := reflect . ValueOf ( ptr ) if rv . Kind ( ) != reflect . Ptr { panic ( "Unmarshal expects a pointer" ) } rv = rv . Elem ( ) rt := rv . Type ( ) info , err := cdc . getTypeInfo_wlock ( rt ) if err != nil { return err } if info . Registered { pb := info . Prefix . Bytes ( ) if len ( bz ) < 4 { return fmt . Errorf ( "UnmarshalBinaryBare expected to read prefix bytes %X (since it is registered concrete) but got %X" , pb , bz ) } else if ! bytes . Equal ( bz [ : 4 ] , pb ) { return fmt . Errorf ( "UnmarshalBinaryBare expected to read prefix bytes %X (since it is registered concrete) but got %X..." , pb , bz [ : 4 ] ) } bz = bz [ 4 : ] } n , err := cdc . decodeReflectBinary ( bz , info , rv , FieldOptions { BinFieldNum : 1 } , true ) if err != nil { return fmt . Errorf ( "unmarshal to %v failed after %d bytes (%v): %X" , info . Type , n , err , bz ) } if n != len ( bz ) { return fmt . Errorf ( "unmarshal to %v didn't read all bytes. Expected to read %v, only read %v: %X" , info . Type , len ( bz ) , n , bz ) } return nil }
4816	func ( cdc * Codec ) MustMarshalJSON ( o interface { } ) [ ] byte { bz , err := cdc . MarshalJSON ( o ) if err != nil { panic ( err ) } return bz }
4817	func ( cdc * Codec ) MustUnmarshalJSON ( bz [ ] byte , ptr interface { } ) { if err := cdc . UnmarshalJSON ( bz , ptr ) ; err != nil { panic ( err ) } }
4818	func ( cdc * Codec ) MarshalJSONIndent ( o interface { } , prefix , indent string ) ( [ ] byte , error ) { bz , err := cdc . MarshalJSON ( o ) if err != nil { return nil , err } var out bytes . Buffer err = json . Indent ( & out , bz , prefix , indent ) if err != nil { return nil , err } return out . Bytes ( ) , nil }
4819	func newDataReader ( r io . Reader ) * internalDataReader { buffered := bufio . NewReader ( r ) reader := internalDataReader { wrapped : r , buffered : buffered , } return & reader }
4820	func ( r * internalDataReader ) Read ( data [ ] byte ) ( n int , err error ) { const IAC = 255 const SB = 250 const SE = 240 const WILL = 251 const WONT = 252 const DO = 253 const DONT = 254 p := data for len ( p ) > 0 { var b byte b , err = r . buffered . ReadByte ( ) if nil != err { return n , err } if IAC == b { var peeked [ ] byte peeked , err = r . buffered . Peek ( 1 ) if nil != err { return n , err } switch peeked [ 0 ] { case WILL , WONT , DO , DONT : _ , err = r . buffered . Discard ( 2 ) if nil != err { return n , err } case IAC : p [ 0 ] = IAC n ++ p = p [ 1 : ] _ , err = r . buffered . Discard ( 1 ) if nil != err { return n , err } case SB : for { var b2 byte b2 , err = r . buffered . ReadByte ( ) if nil != err { return n , err } if IAC == b2 { peeked , err = r . buffered . Peek ( 1 ) if nil != err { return n , err } if IAC == peeked [ 0 ] { _ , err = r . buffered . Discard ( 1 ) if nil != err { return n , err } } if SE == peeked [ 0 ] { _ , err = r . buffered . Discard ( 1 ) if nil != err { return n , err } break } } } case SE : _ , err = r . buffered . Discard ( 1 ) if nil != err { return n , err } default : err = errCorrupted return n , err } } else { p [ 0 ] = b n ++ p = p [ 1 : ] } } return n , nil }
4821	func ( server * Server ) ListenAndServeTLS ( certFile string , keyFile string ) error { addr := server . Addr if "" == addr { addr = ":telnets" } listener , err := net . Listen ( "tcp" , addr ) if nil != err { return err } var tlsConfig * tls . Config = nil if nil == server . TLSConfig { tlsConfig = & tls . Config { } } else { tlsConfig = & tls . Config { Rand : server . TLSConfig . Rand , Time : server . TLSConfig . Time , Certificates : server . TLSConfig . Certificates , NameToCertificate : server . TLSConfig . NameToCertificate , GetCertificate : server . TLSConfig . GetCertificate , RootCAs : server . TLSConfig . RootCAs , NextProtos : server . TLSConfig . NextProtos , ServerName : server . TLSConfig . ServerName , ClientAuth : server . TLSConfig . ClientAuth , ClientCAs : server . TLSConfig . ClientCAs , InsecureSkipVerify : server . TLSConfig . InsecureSkipVerify , CipherSuites : server . TLSConfig . CipherSuites , PreferServerCipherSuites : server . TLSConfig . PreferServerCipherSuites , SessionTicketsDisabled : server . TLSConfig . SessionTicketsDisabled , SessionTicketKey : server . TLSConfig . SessionTicketKey , ClientSessionCache : server . TLSConfig . ClientSessionCache , MinVersion : server . TLSConfig . MinVersion , MaxVersion : server . TLSConfig . MaxVersion , CurvePreferences : server . TLSConfig . CurvePreferences , } } tlsConfigHasCertificate := len ( tlsConfig . Certificates ) > 0 || nil != tlsConfig . GetCertificate if "" == certFile || "" == keyFile || ! tlsConfigHasCertificate { tlsConfig . Certificates = make ( [ ] tls . Certificate , 1 ) var err error tlsConfig . Certificates [ 0 ] , err = tls . LoadX509KeyPair ( certFile , keyFile ) if nil != err { return err } } tlsListener := tls . NewListener ( listener , tlsConfig ) return server . Serve ( tlsListener ) }
4822	func ( fn ProducerFunc ) Produce ( ctx telnet . Context , name string , args ... string ) Handler { return fn ( ctx , name , args ... ) }
4823	func PromoteHandlerFunc ( fn HandlerFunc , args ... string ) Handler { stdin , stdinPipe := io . Pipe ( ) stdoutPipe , stdout := io . Pipe ( ) stderrPipe , stderr := io . Pipe ( ) argsCopy := make ( [ ] string , len ( args ) ) for i , datum := range args { argsCopy [ i ] = datum } handler := internalPromotedHandlerFunc { err : nil , fn : fn , stdin : stdin , stdout : stdout , stderr : stderr , stdinPipe : stdinPipe , stdoutPipe : stdoutPipe , stderrPipe : stderrPipe , args : argsCopy , } return & handler }
4824	func Serve ( listener net . Listener , handler Handler ) error { server := & Server { Handler : handler } return server . Serve ( listener ) }
4825	func ( server * Server ) Serve ( listener net . Listener ) error { defer listener . Close ( ) logger := server . logger ( ) handler := server . Handler if nil == handler { logger . Debug ( "Defaulted handler to EchoHandler." ) handler = EchoHandler } for { logger . Debugf ( "Listening at %q." , listener . Addr ( ) ) conn , err := listener . Accept ( ) if err != nil { return err } logger . Debugf ( "Received new connection from %q." , conn . RemoteAddr ( ) ) go server . handle ( conn , handler ) logger . Debugf ( "Spawned handler to handle connection from %q." , conn . RemoteAddr ( ) ) } }
4826	func ( p * Parser ) Fail ( msg string ) { p . WriteUsage ( os . Stderr ) fmt . Fprintln ( os . Stderr , "error:" , msg ) os . Exit ( - 1 ) }
4827	func ( p * Parser ) WriteUsage ( w io . Writer ) { var positionals , options [ ] * spec for _ , spec := range p . specs { if spec . positional { positionals = append ( positionals , spec ) } else { options = append ( options , spec ) } } if p . version != "" { fmt . Fprintln ( w , p . version ) } fmt . Fprintf ( w , "Usage: %s" , p . config . Program ) for _ , spec := range options { fmt . Fprint ( w , " " ) if ! spec . required { fmt . Fprint ( w , "[" ) } fmt . Fprint ( w , synopsis ( spec , "--" + spec . long ) ) if ! spec . required { fmt . Fprint ( w , "]" ) } } for _ , spec := range positionals { fmt . Fprint ( w , " " ) up := strings . ToUpper ( spec . long ) if spec . multiple { if ! spec . required { fmt . Fprint ( w , "[" ) } fmt . Fprintf ( w , "%s [%s ...]" , up , up ) if ! spec . required { fmt . Fprint ( w , "]" ) } } else { fmt . Fprint ( w , up ) } } fmt . Fprint ( w , "\n" ) }
4828	func ( p * Parser ) WriteHelp ( w io . Writer ) { var positionals , options [ ] * spec for _ , spec := range p . specs { if spec . positional { positionals = append ( positionals , spec ) } else { options = append ( options , spec ) } } if p . description != "" { fmt . Fprintln ( w , p . description ) } p . WriteUsage ( w ) if len ( positionals ) > 0 { fmt . Fprint ( w , "\nPositional arguments:\n" ) \n } \n for _ , spec := range positionals { left := " " + strings . ToUpper ( spec . long ) fmt . Fprint ( w , left ) if spec . help != "" { if len ( left ) + 2 < colWidth { fmt . Fprint ( w , strings . Repeat ( " " , colWidth - len ( left ) ) ) } else { fmt . Fprint ( w , "\n" + \n ) } strings . Repeat ( " " , colWidth ) } fmt . Fprint ( w , spec . help ) } fmt . Fprint ( w , "\n" ) \n }
4829	func MustParse ( dest ... interface { } ) * Parser { p , err := NewParser ( Config { } , dest ... ) if err != nil { fmt . Println ( err ) os . Exit ( - 1 ) } err = p . Parse ( flags ( ) ) if err == ErrHelp { p . WriteHelp ( os . Stdout ) os . Exit ( 0 ) } if err == ErrVersion { fmt . Println ( p . version ) os . Exit ( 0 ) } if err != nil { p . Fail ( err . Error ( ) ) } return p }
4830	func Parse ( dest ... interface { } ) error { p , err := NewParser ( Config { } , dest ... ) if err != nil { return err } return p . Parse ( flags ( ) ) }
4831	func walkFields ( v reflect . Value , visit func ( field reflect . StructField , val reflect . Value , owner reflect . Type ) bool ) { t := v . Type ( ) for i := 0 ; i < t . NumField ( ) ; i ++ { field := t . Field ( i ) val := v . Field ( i ) expand := visit ( field , val , t ) if expand && field . Type . Kind ( ) == reflect . Struct { walkFields ( val , visit ) } } }
4832	func ( p * Parser ) Parse ( args [ ] string ) error { for _ , arg := range args { if arg == "-h" || arg == "--help" { return ErrHelp } if arg == "--version" { return ErrVersion } if arg == "--" { break } } return process ( p . specs , args ) }
4833	func setSlice ( dest reflect . Value , values [ ] string , trunc bool ) error { if ! dest . CanSet ( ) { return fmt . Errorf ( "field is not writable" ) } var ptr bool elem := dest . Type ( ) . Elem ( ) if elem . Kind ( ) == reflect . Ptr && ! elem . Implements ( textUnmarshalerType ) { ptr = true elem = elem . Elem ( ) } if trunc && ! dest . IsNil ( ) { dest . SetLen ( 0 ) } for _ , s := range values { v := reflect . New ( elem ) if err := scalar . ParseValue ( v . Elem ( ) , s ) ; err != nil { return err } if ! ptr { v = v . Elem ( ) } dest . Set ( reflect . Append ( dest , v ) ) } return nil }
4834	func canParse ( t reflect . Type ) ( parseable , boolean , multiple bool ) { parseable = scalar . CanParse ( t ) boolean = isBoolean ( t ) if parseable { return } if t . Kind ( ) == reflect . Ptr { t = t . Elem ( ) } if t . Kind ( ) == reflect . Slice { multiple = true t = t . Elem ( ) } parseable = scalar . CanParse ( t ) boolean = isBoolean ( t ) if parseable { return } if t . Kind ( ) == reflect . Ptr { t = t . Elem ( ) } parseable = scalar . CanParse ( t ) boolean = isBoolean ( t ) if parseable { return } return false , false , false }
4835	func isBoolean ( t reflect . Type ) bool { switch { case t . Implements ( textUnmarshalerType ) : return false case t . Kind ( ) == reflect . Bool : return true case t . Kind ( ) == reflect . Ptr && t . Elem ( ) . Kind ( ) == reflect . Bool : return true default : return false } }
4836	func NewFromMap ( m map [ string ] interface { } ) * Tree { t := & Tree { root : & node { } } for k , v := range m { t . Insert ( k , v ) } return t }
4837	func ( t * Tree ) Insert ( s string , v interface { } ) ( interface { } , bool ) { var parent * node n := t . root search := s for { if len ( search ) == 0 { if n . isLeaf ( ) { old := n . leaf . val n . leaf . val = v return old , true } n . leaf = & leafNode { key : s , val : v , } t . size ++ return nil , false } parent = n n = n . getEdge ( search [ 0 ] ) if n == nil { e := edge { label : search [ 0 ] , node : & node { leaf : & leafNode { key : s , val : v , } , prefix : search , } , } parent . addEdge ( e ) t . size ++ return nil , false } commonPrefix := longestPrefix ( search , n . prefix ) if commonPrefix == len ( n . prefix ) { search = search [ commonPrefix : ] continue } t . size ++ child := & node { prefix : search [ : commonPrefix ] , } parent . updateEdge ( search [ 0 ] , child ) child . addEdge ( edge { label : n . prefix [ commonPrefix ] , node : n , } ) n . prefix = n . prefix [ commonPrefix : ] leaf := & leafNode { key : s , val : v , } search = search [ commonPrefix : ] if len ( search ) == 0 { child . leaf = leaf return nil , false } child . addEdge ( edge { label : search [ 0 ] , node : & node { leaf : leaf , prefix : search , } , } ) return nil , false } }
4838	func ( t * Tree ) Delete ( s string ) ( interface { } , bool ) { var parent * node var label byte n := t . root search := s for { if len ( search ) == 0 { if ! n . isLeaf ( ) { break } goto DELETE } parent = n label = search [ 0 ] n = n . getEdge ( label ) if n == nil { break } if strings . HasPrefix ( search , n . prefix ) { search = search [ len ( n . prefix ) : ] } else { break } } return nil , false DELETE : leaf := n . leaf n . leaf = nil t . size -- if parent != nil && len ( n . edges ) == 0 { parent . delEdge ( label ) } if n != t . root && len ( n . edges ) == 1 { n . mergeChild ( ) } if parent != nil && parent != t . root && len ( parent . edges ) == 1 && ! parent . isLeaf ( ) { parent . mergeChild ( ) } return leaf . val , true }
4839	func ( t * Tree ) DeletePrefix ( s string ) int { return t . deletePrefix ( nil , t . root , s ) }
4840	func ( t * Tree ) deletePrefix ( parent , n * node , prefix string ) int { if len ( prefix ) == 0 { subTreeSize := 0 recursiveWalk ( n , func ( s string , v interface { } ) bool { subTreeSize ++ return false } ) if n . isLeaf ( ) { n . leaf = nil } n . edges = nil if parent != nil && parent != t . root && len ( parent . edges ) == 1 && ! parent . isLeaf ( ) { parent . mergeChild ( ) } t . size -= subTreeSize return subTreeSize } label := prefix [ 0 ] child := n . getEdge ( label ) if child == nil || ( ! strings . HasPrefix ( child . prefix , prefix ) && ! strings . HasPrefix ( prefix , child . prefix ) ) { return 0 } if len ( child . prefix ) > len ( prefix ) { prefix = prefix [ len ( prefix ) : ] } else { prefix = prefix [ len ( child . prefix ) : ] } return t . deletePrefix ( n , child , prefix ) }
4841	func ( t * Tree ) Get ( s string ) ( interface { } , bool ) { n := t . root search := s for { if len ( search ) == 0 { if n . isLeaf ( ) { return n . leaf . val , true } break } n = n . getEdge ( search [ 0 ] ) if n == nil { break } if strings . HasPrefix ( search , n . prefix ) { search = search [ len ( n . prefix ) : ] } else { break } } return nil , false }
4842	func ( t * Tree ) LongestPrefix ( s string ) ( string , interface { } , bool ) { var last * leafNode n := t . root search := s for { if n . isLeaf ( ) { last = n . leaf } if len ( search ) == 0 { break } n = n . getEdge ( search [ 0 ] ) if n == nil { break } if strings . HasPrefix ( search , n . prefix ) { search = search [ len ( n . prefix ) : ] } else { break } } if last != nil { return last . key , last . val , true } return "" , nil , false }
4843	func ( t * Tree ) Minimum ( ) ( string , interface { } , bool ) { n := t . root for { if n . isLeaf ( ) { return n . leaf . key , n . leaf . val , true } if len ( n . edges ) > 0 { n = n . edges [ 0 ] . node } else { break } } return "" , nil , false }
4844	func ( t * Tree ) WalkPrefix ( prefix string , fn WalkFn ) { n := t . root search := prefix for { if len ( search ) == 0 { recursiveWalk ( n , fn ) return } n = n . getEdge ( search [ 0 ] ) if n == nil { break } if strings . HasPrefix ( search , n . prefix ) { search = search [ len ( n . prefix ) : ] } else if strings . HasPrefix ( n . prefix , search ) { recursiveWalk ( n , fn ) return } else { break } } }
4845	func recursiveWalk ( n * node , fn WalkFn ) bool { if n . leaf != nil && fn ( n . leaf . key , n . leaf . val ) { return true } for _ , e := range n . edges { if recursiveWalk ( e . node , fn ) { return true } } return false }
4846	func ( t * Tree ) ToMap ( ) map [ string ] interface { } { out := make ( map [ string ] interface { } , t . size ) t . Walk ( func ( k string , v interface { } ) bool { out [ k ] = v return false } ) return out }
4847	func checkip ( ip string ) ( iptype uint32 , ipnum * big . Int , ipindex uint32 ) { iptype = 0 ipnum = big . NewInt ( 0 ) ipnumtmp := big . NewInt ( 0 ) ipindex = 0 ipaddress := net . ParseIP ( ip ) if ipaddress != nil { v4 := ipaddress . To4 ( ) if v4 != nil { iptype = 4 ipnum . SetBytes ( v4 ) } else { v6 := ipaddress . To16 ( ) if v6 != nil { iptype = 6 ipnum . SetBytes ( v6 ) } } } if iptype == 4 { if meta . ipv4indexbaseaddr > 0 { ipnumtmp . Rsh ( ipnum , 16 ) ipnumtmp . Lsh ( ipnumtmp , 3 ) ipindex = uint32 ( ipnumtmp . Add ( ipnumtmp , big . NewInt ( int64 ( meta . ipv4indexbaseaddr ) ) ) . Uint64 ( ) ) } } else if iptype == 6 { if meta . ipv6indexbaseaddr > 0 { ipnumtmp . Rsh ( ipnum , 112 ) ipnumtmp . Lsh ( ipnumtmp , 3 ) ipindex = uint32 ( ipnumtmp . Add ( ipnumtmp , big . NewInt ( int64 ( meta . ipv6indexbaseaddr ) ) ) . Uint64 ( ) ) } } return }
4848	func readuint32 ( pos uint32 ) uint32 { pos2 := int64 ( pos ) var retval uint32 data := make ( [ ] byte , 4 ) _ , err := f . ReadAt ( data , pos2 - 1 ) if err != nil { fmt . Println ( "File read failed:" , err ) } buf := bytes . NewReader ( data ) err = binary . Read ( buf , binary . LittleEndian , & retval ) if err != nil { fmt . Println ( "Binary read failed:" , err ) } return retval }
4849	func readuint128 ( pos uint32 ) * big . Int { pos2 := int64 ( pos ) retval := big . NewInt ( 0 ) data := make ( [ ] byte , 16 ) _ , err := f . ReadAt ( data , pos2 - 1 ) if err != nil { fmt . Println ( "File read failed:" , err ) } for i , j := 0 , len ( data ) - 1 ; i < j ; i , j = i + 1 , j - 1 { data [ i ] , data [ j ] = data [ j ] , data [ i ] } retval . SetBytes ( data ) return retval }
4850	func loadmessage ( mesg string ) IP2Locationrecord { var x IP2Locationrecord x . Country_short = mesg x . Country_long = mesg x . Region = mesg x . City = mesg x . Isp = mesg x . Domain = mesg x . Zipcode = mesg x . Timezone = mesg x . Netspeed = mesg x . Iddcode = mesg x . Areacode = mesg x . Weatherstationcode = mesg x . Weatherstationname = mesg x . Mcc = mesg x . Mnc = mesg x . Mobilebrand = mesg x . Usagetype = mesg return x }
4851	func Printrecord ( x IP2Locationrecord ) { fmt . Printf ( "country_short: %s\n" , \n ) x . Country_short fmt . Printf ( "country_long: %s\n" , \n ) x . Country_long fmt . Printf ( "region: %s\n" , \n ) x . Region fmt . Printf ( "city: %s\n" , \n ) x . City fmt . Printf ( "isp: %s\n" , \n ) x . Isp fmt . Printf ( "latitude: %f\n" , \n ) x . Latitude fmt . Printf ( "longitude: %f\n" , \n ) x . Longitude fmt . Printf ( "domain: %s\n" , \n ) x . Domain fmt . Printf ( "zipcode: %s\n" , \n ) x . Zipcode fmt . Printf ( "timezone: %s\n" , \n ) x . Timezone }
4852	func Main ( gc draw2d . GraphicContext , ext string ) ( string , error ) { gc . Save ( ) gc . Scale ( 0.5 , 0.5 ) Draw ( gc ) gc . Restore ( ) return samples . Output ( "gopher" , ext ) , nil }
4853	func SaveToPdfFile ( filePath string , pdf * gofpdf . Fpdf ) error { return pdf . OutputFileAndClose ( filePath ) }
4854	func ( p * Path ) CubicCurveTo ( cx1 , cy1 , cx2 , cy2 , x , y float64 ) { if len ( p . Components ) == 0 { p . MoveTo ( x , y ) } else { p . appendToPath ( CubicCurveToCmp , cx1 , cy1 , cx2 , cy2 , x , y ) } p . x = x p . y = y }
4855	func ( p * Path ) ArcTo ( cx , cy , rx , ry , startAngle , angle float64 ) { endAngle := startAngle + angle clockWise := true if angle < 0 { clockWise = false } if clockWise { for endAngle < startAngle { endAngle += math . Pi * 2.0 } } else { for startAngle < endAngle { startAngle += math . Pi * 2.0 } } startX := cx + math . Cos ( startAngle ) * rx startY := cy + math . Sin ( startAngle ) * ry if len ( p . Components ) > 0 { p . LineTo ( startX , startY ) } else { p . MoveTo ( startX , startY ) } p . appendToPath ( ArcToCmp , cx , cy , rx , ry , startAngle , angle ) p . x = cx + math . Cos ( endAngle ) * rx p . y = cy + math . Sin ( endAngle ) * ry }
4856	func ( p * Path ) String ( ) string { s := "" j := 0 for _ , cmd := range p . Components { switch cmd { case MoveToCmp : s += fmt . Sprintf ( "MoveTo: %f, %f\n" , \n , p . Points [ j ] ) p . Points [ j + 1 ] j = j + 2 case LineToCmp : s += fmt . Sprintf ( "LineTo: %f, %f\n" , \n , p . Points [ j ] ) p . Points [ j + 1 ] j = j + 2 case QuadCurveToCmp : s += fmt . Sprintf ( "QuadCurveTo: %f, %f, %f, %f\n" , \n , p . Points [ j ] , p . Points [ j + 1 ] , p . Points [ j + 2 ] ) p . Points [ j + 3 ] j = j + 4 } } case CubicCurveToCmp : s += fmt . Sprintf ( "CubicCurveTo: %f, %f, %f, %f, %f, %f\n" , \n , p . Points [ j ] , p . Points [ j + 1 ] , p . Points [ j + 2 ] , p . Points [ j + 3 ] , p . Points [ j + 4 ] ) p . Points [ j + 5 ] }
4857	func ( path * Path ) VerticalFlip ( ) * Path { p := path . Copy ( ) j := 0 for _ , cmd := range p . Components { switch cmd { case MoveToCmp , LineToCmp : p . Points [ j + 1 ] = - p . Points [ j + 1 ] j = j + 2 case QuadCurveToCmp : p . Points [ j + 1 ] = - p . Points [ j + 1 ] p . Points [ j + 3 ] = - p . Points [ j + 3 ] j = j + 4 case CubicCurveToCmp : p . Points [ j + 1 ] = - p . Points [ j + 1 ] p . Points [ j + 3 ] = - p . Points [ j + 3 ] p . Points [ j + 5 ] = - p . Points [ j + 5 ] j = j + 6 case ArcToCmp : p . Points [ j + 1 ] = - p . Points [ j + 1 ] p . Points [ j + 3 ] = - p . Points [ j + 3 ] p . Points [ j + 4 ] = - p . Points [ j + 4 ] p . Points [ j + 5 ] = - p . Points [ j + 5 ] j = j + 6 case CloseCmp : } } p . y = - p . y return p }
4858	func NewGlyphCache ( ) * GlyphCacheImp { glyphs := make ( map [ string ] map [ rune ] * Glyph ) return & GlyphCacheImp { glyphs : glyphs , } }
4859	func ( glyphCache * GlyphCacheImp ) Fetch ( gc draw2d . GraphicContext , fontName string , chr rune ) * Glyph { if glyphCache . glyphs [ fontName ] == nil { glyphCache . glyphs [ fontName ] = make ( map [ rune ] * Glyph , 60 ) } if glyphCache . glyphs [ fontName ] [ chr ] == nil { glyphCache . glyphs [ fontName ] [ chr ] = renderGlyph ( gc , fontName , chr ) } return glyphCache . glyphs [ fontName ] [ chr ] . Copy ( ) }
4860	func renderGlyph ( gc draw2d . GraphicContext , fontName string , chr rune ) * Glyph { gc . Save ( ) defer gc . Restore ( ) gc . BeginPath ( ) width := gc . CreateStringPath ( string ( chr ) , 0 , 0 ) path := gc . GetPath ( ) return & Glyph { Path : & path , Width : width , } }
4861	func ( g * Glyph ) Copy ( ) * Glyph { return & Glyph { Path : g . Path . Copy ( ) , Width : g . Width , } }
4862	func ( g * Glyph ) Fill ( gc draw2d . GraphicContext , x , y float64 ) float64 { gc . Save ( ) gc . BeginPath ( ) gc . Translate ( x , y ) gc . Fill ( g . Path ) gc . Restore ( ) return g . Width }
4863	func Main ( gc draw2d . GraphicContext , ext string ) ( string , error ) { gc . SetFillRule ( draw2d . FillRuleWinding ) gc . Clear ( ) for x := 5.0 ; x < 297 ; x += 10 { Draw ( gc , x , 0 , x , 210 ) } gc . ClearRect ( 100 , 75 , 197 , 135 ) draw2dkit . Ellipse ( gc , 148.5 , 105 , 35 , 25 ) gc . SetFillColor ( color . RGBA { 0xff , 0xff , 0x44 , 0xff } ) gc . FillStroke ( ) return samples . Output ( "line" , ext ) , nil }
4864	func Draw ( gc draw2d . GraphicContext , x0 , y0 , x1 , y1 float64 ) { gc . MoveTo ( x0 , y0 ) gc . LineTo ( x1 , y1 ) gc . Stroke ( ) }
4865	func ( p * Painter ) Paint ( ss [ ] raster . Span , done bool ) { sslen := len ( ss ) clenrequired := sslen * 8 vlenrequired := sslen * 4 if clenrequired >= ( cap ( p . colors ) - len ( p . colors ) ) { p . Flush ( ) if clenrequired >= cap ( p . colors ) { p . vertices = make ( [ ] int32 , 0 , vlenrequired + ( vlenrequired / 2 ) ) p . colors = make ( [ ] uint8 , 0 , clenrequired + ( clenrequired / 2 ) ) } } vi := len ( p . vertices ) ci := len ( p . colors ) p . vertices = p . vertices [ 0 : vi + vlenrequired ] p . colors = p . colors [ 0 : ci + clenrequired ] var ( colors [ ] uint8 vertices [ ] int32 ) for _ , s := range ss { a := uint8 ( ( s . Alpha * p . ca / M16 ) >> 8 ) colors = p . colors [ ci : ] colors [ 0 ] = p . cr colors [ 1 ] = p . cg colors [ 2 ] = p . cb colors [ 3 ] = a colors [ 4 ] = p . cr colors [ 5 ] = p . cg colors [ 6 ] = p . cb colors [ 7 ] = a ci += 8 vertices = p . vertices [ vi : ] vertices [ 0 ] = int32 ( s . X0 ) vertices [ 1 ] = int32 ( s . Y ) vertices [ 2 ] = int32 ( s . X1 ) vertices [ 3 ] = int32 ( s . Y ) vi += 4 } }
4866	func ( p * Painter ) SetColor ( c color . Color ) { r , g , b , a := c . RGBA ( ) if a == 0 { p . cr = 0 p . cg = 0 p . cb = 0 p . ca = a } else { p . cr = uint8 ( ( r * M16 / a ) >> 8 ) p . cg = uint8 ( ( g * M16 / a ) >> 8 ) p . cb = uint8 ( ( b * M16 / a ) >> 8 ) p . ca = a } }
4867	func NewPainter ( ) * Painter { p := new ( Painter ) p . vertices = make ( [ ] int32 , 0 , 1024 ) p . colors = make ( [ ] uint8 , 0 , 1024 ) return p }
4868	func ( gc * GraphicContext ) GetStringBounds ( s string ) ( left , top , right , bottom float64 ) { f , err := gc . loadCurrentFont ( ) if err != nil { log . Println ( err ) return 0 , 0 , 0 , 0 } top , left , bottom , right = 10e6 , 10e6 , - 10e6 , - 10e6 cursor := 0.0 prev , hasPrev := truetype . Index ( 0 ) , false for _ , rune := range s { index := f . Index ( rune ) if hasPrev { cursor += fUnitsToFloat64 ( f . Kern ( fixed . Int26_6 ( gc . Current . Scale ) , prev , index ) ) } if err := gc . glyphBuf . Load ( gc . Current . Font , fixed . Int26_6 ( gc . Current . Scale ) , index , font . HintingNone ) ; err != nil { log . Println ( err ) return 0 , 0 , 0 , 0 } e0 := 0 for _ , e1 := range gc . glyphBuf . Ends { ps := gc . glyphBuf . Points [ e0 : e1 ] for _ , p := range ps { x , y := pointToF64Point ( p ) top = math . Min ( top , y ) bottom = math . Max ( bottom , y ) left = math . Min ( left , x + cursor ) right = math . Max ( right , x + cursor ) } } cursor += fUnitsToFloat64 ( f . HMetric ( fixed . Int26_6 ( gc . Current . Scale ) , index ) . AdvanceWidth ) prev , hasPrev = index , true } return left , top , right , bottom }
4869	func ( gc * GraphicContext ) recalc ( ) { gc . Current . Scale = gc . Current . FontSize * float64 ( gc . DPI ) * ( 64.0 / 72.0 ) }
4870	func ( gc * GraphicContext ) SetFont ( font * truetype . Font ) { gc . Current . Font = font }
4871	func ( gc * GraphicContext ) ClearRect ( x1 , y1 , x2 , y2 int ) { mask := gc . newMask ( x1 , y1 , x2 - x1 , y2 - y1 ) newGroup := & Group { Groups : gc . svg . Groups , Mask : "url(#" + mask . Id + ")" , } gc . svg . Groups = [ ] * Group { newGroup } }
4872	func ( gc * GraphicContext ) drawString ( text string , drawType drawType , x , y float64 ) float64 { switch gc . svg . FontMode { case PathFontMode : w := gc . CreateStringPath ( text , x , y ) gc . drawPaths ( drawType ) gc . Current . Path . Clear ( ) return w case SvgFontMode : gc . embedSvgFont ( text ) } svgText := Text { } group := gc . newGroup ( drawType ) svgText . Text = text svgText . FontSize = gc . Current . FontSize svgText . X = x svgText . Y = y svgText . FontFamily = gc . Current . FontData . Name group . Texts = [ ] * Text { & svgText } left , _ , right , _ := gc . GetStringBounds ( text ) return right - left }
4873	func ( gc * GraphicContext ) newGroup ( drawType drawType ) * Group { group := Group { } if drawType & stroked == stroked { group . Stroke = toSvgRGBA ( gc . Current . StrokeColor ) group . StrokeWidth = toSvgLength ( gc . Current . LineWidth ) group . StrokeLinecap = gc . Current . Cap . String ( ) group . StrokeLinejoin = gc . Current . Join . String ( ) if len ( gc . Current . Dash ) > 0 { group . StrokeDasharray = toSvgArray ( gc . Current . Dash ) group . StrokeDashoffset = toSvgLength ( gc . Current . DashOffset ) } } if drawType & filled == filled { group . Fill = toSvgRGBA ( gc . Current . FillColor ) group . FillRule = toSvgFillRule ( gc . Current . FillRule ) } group . Transform = toSvgTransform ( gc . Current . Tr ) gc . svg . Groups = append ( gc . svg . Groups , & group ) return & group }
4874	func ( gc * GraphicContext ) newMask ( x , y , width , height int ) * Mask { mask := & Mask { } mask . X = float64 ( x ) mask . Y = float64 ( y ) mask . Width = toSvgLength ( float64 ( width ) ) mask . Height = toSvgLength ( float64 ( height ) ) gc . svg . Masks = append ( gc . svg . Masks , mask ) mask . Id = "mask-" + strconv . Itoa ( len ( gc . svg . Masks ) ) return mask }
4875	func ( gc * GraphicContext ) embedSvgFont ( text string ) * Font { fontName := gc . Current . FontData . Name gc . loadCurrentFont ( ) svgFont := ( * Font ) ( nil ) for _ , font := range gc . svg . Fonts { if font . Name == fontName { svgFont = font break } } if svgFont == nil { svgFont = & Font { } gc . svg . Fonts = append ( gc . svg . Fonts , svgFont ) } gc . Save ( ) defer gc . Restore ( ) gc . SetFontSize ( 2048 ) defer gc . SetDPI ( gc . GetDPI ( ) ) gc . SetDPI ( 92 ) filling : for _ , rune := range text { for _ , g := range svgFont . Glyphs { if g . Rune == Rune ( rune ) { continue filling } } glyph := gc . glyphCache . Fetch ( gc , gc . GetFontName ( ) , rune ) glypPath := glyph . Path . VerticalFlip ( ) svgFont . Glyphs = append ( svgFont . Glyphs , & Glyph { Rune : Rune ( rune ) , Desc : toSvgPathDesc ( glypPath ) , HorizAdvX : glyph . Width , } ) } svgFont . Id = "font-" + strconv . Itoa ( len ( gc . svg . Fonts ) ) svgFont . Name = fontName svgFont . Face = & Face { Family : fontName , Units : 2048 , HorizAdvX : 2048 } return svgFont }
4876	func TraceQuad ( t Liner , quad [ ] float64 , flatteningThreshold float64 ) error { if len ( quad ) < 6 { return errors . New ( "quad length must be >= 6" ) } var curves [ CurveRecursionLimit * 6 ] float64 copy ( curves [ 0 : 6 ] , quad [ 0 : 6 ] ) i := 0 var c [ ] float64 var dx , dy , d float64 for i >= 0 { c = curves [ i : ] dx = c [ 4 ] - c [ 0 ] dy = c [ 5 ] - c [ 1 ] d = math . Abs ( ( ( c [ 2 ] - c [ 4 ] ) * dy - ( c [ 3 ] - c [ 5 ] ) * dx ) ) if ( d * d ) <= flatteningThreshold * ( dx * dx + dy * dy ) || i == len ( curves ) - 6 { t . LineTo ( c [ 4 ] , c [ 5 ] ) i -= 6 } else { SubdivideQuad ( c , curves [ i + 6 : ] , curves [ i : ] ) i += 6 } } return nil }
4877	func ( cs * ContextStack ) GetFontName ( ) string { fontData := cs . FontData return fmt . Sprintf ( "%s:%d:%d:%9.2f" , fontData . Name , fontData . Family , fontData . Style , cs . FontSize ) }
4878	func NewStackGraphicContext ( ) * StackGraphicContext { gc := & StackGraphicContext { } gc . Current = new ( ContextStack ) gc . Current . Tr = draw2d . NewIdentityMatrix ( ) gc . Current . Path = new ( draw2d . Path ) gc . Current . LineWidth = 1.0 gc . Current . StrokeColor = image . Black gc . Current . FillColor = image . White gc . Current . Cap = draw2d . RoundCap gc . Current . FillRule = draw2d . FillRuleEvenOdd gc . Current . Join = draw2d . RoundJoin gc . Current . FontSize = 10 gc . Current . FontData = DefaultFontData return gc }
4879	func NewFolderFontCache ( folder string ) * FolderFontCache { return & FolderFontCache { fonts : make ( map [ string ] * truetype . Font ) , folder : folder , namer : FontFileName , } }
4880	func NewSyncFolderFontCache ( folder string ) * SyncFolderFontCache { return & SyncFolderFontCache { fonts : make ( map [ string ] * truetype . Font ) , folder : folder , namer : FontFileName , } }
4881	func Main ( gc draw2d . GraphicContext , ext string ) ( string , error ) { gc . SetStrokeColor ( image . Black ) gc . SetFillColor ( image . White ) gc . Save ( ) gc . Translate ( - 60 , 65 ) gc . Rotate ( - 30 * ( math . Pi / 180.0 ) ) Draw ( gc , 48 , 48 , 240 , 72 ) gc . Restore ( ) return samples . Output ( "gopher2" , ext ) , nil }
4882	func NewPdf ( orientationStr , unitStr , sizeStr string ) * gofpdf . Fpdf { pdf := gofpdf . New ( orientationStr , unitStr , sizeStr , draw2d . GetFontFolder ( ) ) pdf . SetMargins ( 0 , 0 , 0 ) pdf . SetDrawColor ( 0 , 0 , 0 ) pdf . SetFillColor ( 255 , 255 , 255 ) pdf . SetLineCapStyle ( "round" ) pdf . SetLineJoinStyle ( "round" ) pdf . SetLineWidth ( 1 ) pdf . AddPage ( ) return pdf }
4883	func clearRect ( gc * GraphicContext , x1 , y1 , x2 , y2 float64 ) { f := gc . Current . FillColor x , y := gc . pdf . GetXY ( ) gc . SetFillColor ( white ) draw2dkit . Rectangle ( gc , x1 , y1 , x2 , y2 ) gc . Fill ( ) gc . SetFillColor ( f ) gc . pdf . MoveTo ( x , y ) }
4884	func NewGraphicContext ( pdf * gofpdf . Fpdf ) * GraphicContext { gc := & GraphicContext { draw2dbase . NewStackGraphicContext ( ) , pdf , DPI } gc . SetDPI ( DPI ) return gc }
4885	func ( gc * GraphicContext ) Clear ( ) { width , height := gc . pdf . GetPageSize ( ) clearRect ( gc , 0 , 0 , width , height ) }
4886	func ( gc * GraphicContext ) GetStringBounds ( s string ) ( left , top , right , bottom float64 ) { _ , h := gc . pdf . GetFontSize ( ) d := gc . pdf . GetFontDesc ( "" , "" ) if d . Ascent == 0 { top = 0.81 * h } else { top = - float64 ( d . Ascent ) * h / float64 ( d . Ascent - d . Descent ) } return 0 , top , gc . pdf . GetStringWidth ( s ) , top + h }
4887	func ( gc * GraphicContext ) CreateStringPath ( text string , x , y float64 ) ( cursor float64 ) { left , top , right , bottom := gc . GetStringBounds ( text ) w := right - left h := bottom - top margin := gc . pdf . GetCellMargin ( ) gc . pdf . MoveTo ( x - left - margin , y + top ) gc . pdf . CellFormat ( w , h , text , "" , 0 , "BL" , false , 0 , "" ) return w }
4888	func ( gc * GraphicContext ) FillStringAt ( text string , x , y float64 ) ( cursor float64 ) { return gc . CreateStringPath ( text , x , y ) }
4889	func ( gc * GraphicContext ) SetStrokeColor ( c color . Color ) { gc . StackGraphicContext . SetStrokeColor ( c ) gc . pdf . SetDrawColor ( rgb ( c ) ) }
4890	func ( gc * GraphicContext ) SetFillColor ( c color . Color ) { gc . StackGraphicContext . SetFillColor ( c ) gc . pdf . SetFillColor ( rgb ( c ) ) gc . pdf . SetTextColor ( rgb ( c ) ) }
4891	func ( gc * GraphicContext ) SetLineDash ( Dash [ ] float64 , DashOffset float64 ) { gc . StackGraphicContext . SetLineDash ( Dash , DashOffset ) gc . pdf . SetDashPattern ( Dash , DashOffset ) }
4892	func ( gc * GraphicContext ) SetLineWidth ( LineWidth float64 ) { gc . StackGraphicContext . SetLineWidth ( LineWidth ) gc . pdf . SetLineWidth ( LineWidth ) }
4893	func Main ( gc draw2d . GraphicContext , ext string ) ( string , error ) { Draw ( gc , fmt . Sprintf ( "Hello World %d dpi" , gc . GetDPI ( ) ) ) return samples . Output ( "helloworld" , ext ) , nil }
4894	func Draw ( gc draw2d . GraphicContext , text string ) { draw2dkit . RoundedRectangle ( gc , 5 , 5 , 135 , 95 , 10 , 10 ) gc . FillStroke ( ) gc . SetFontData ( draw2d . FontData { Name : "luxi" , Family : draw2d . FontFamilyMono , Style : draw2d . FontStyleBold | draw2d . FontStyleItalic } ) gc . SetFillColor ( image . Black ) gc . SetFontSize ( 14 ) gc . FillStringAt ( "Hello World" , 8 , 52 ) }
4895	func SaveToPngFile ( filePath string , m image . Image ) error { f , err := os . Create ( filePath ) if err != nil { return err } defer f . Close ( ) b := bufio . NewWriter ( f ) err = png . Encode ( b , m ) if err != nil { return err } err = b . Flush ( ) if err != nil { return err } return nil }
4896	func LoadFromPngFile ( filePath string ) ( image . Image , error ) { f , err := os . OpenFile ( filePath , 0 , 0 ) if err != nil { return nil , err } defer f . Close ( ) b := bufio . NewReader ( f ) img , err := png . Decode ( b ) if err != nil { return nil , err } return img , nil }
4897	func Resource ( folder , filename , ext string ) string { var root string if ext == "pdf" || ext == "svg" { root = "../" } return fmt . Sprintf ( "%sresource/%s/%s" , root , folder , filename ) }
4898	func Output ( name , ext string ) string { var root string if ext == "pdf" || ext == "svg" { root = "../" } return fmt . Sprintf ( "%soutput/samples/%s.%s" , root , name , ext ) }
4899	func Main ( gc draw2d . GraphicContext , ext string ) ( string , error ) { gc . Save ( ) gc . Translate ( 0 , 200 ) gc . Scale ( 0.35 , - 0.35 ) gc . Translate ( 70 , - 200 ) tiger := samples . Resource ( "image" , "tiger.ps" , ext ) Draw ( gc , tiger ) gc . Restore ( ) return samples . Output ( "postscript" , ext ) , nil }
4900	func Draw ( gc draw2d . GraphicContext , filename string ) { src , err := os . OpenFile ( filename , 0 , 0 ) if err != nil { panic ( err ) } defer src . Close ( ) bytes , err := ioutil . ReadAll ( src ) reader := strings . NewReader ( string ( bytes ) ) interpreter := ps . NewInterpreter ( gc ) interpreter . Execute ( reader ) }
4901	func Main ( gc draw2d . GraphicContext , ext string ) ( string , error ) { Draw ( gc , 297 , 210 ) return samples . Output ( "geometry" , ext ) , nil }
4902	func Bubble ( gc draw2d . GraphicContext , x , y , width , height float64 ) { sx , sy := width / 100 , height / 100 gc . MoveTo ( x + sx * 50 , y ) gc . QuadCurveTo ( x , y , x , y + sy * 37.5 ) gc . QuadCurveTo ( x , y + sy * 75 , x + sx * 25 , y + sy * 75 ) gc . QuadCurveTo ( x + sx * 25 , y + sy * 95 , x + sx * 5 , y + sy * 100 ) gc . QuadCurveTo ( x + sx * 35 , y + sy * 95 , x + sx * 40 , y + sy * 75 ) gc . QuadCurveTo ( x + sx * 100 , y + sy * 75 , x + sx * 100 , y + sy * 37.5 ) gc . QuadCurveTo ( x + sx * 100 , y , x + sx * 50 , y ) gc . Stroke ( ) }
4903	func Dash ( gc draw2d . GraphicContext , x , y , width , height float64 ) { sx , sy := width / 162 , height / 205 gc . SetStrokeColor ( image . Black ) gc . SetLineDash ( [ ] float64 { height / 10 , height / 50 , height / 50 , height / 50 } , - 50.0 ) gc . SetLineCap ( draw2d . ButtCap ) gc . SetLineJoin ( draw2d . RoundJoin ) gc . SetLineWidth ( height / 50 ) gc . MoveTo ( x + sx * 60.0 , y ) gc . LineTo ( x + sx * 60.0 , y ) gc . LineTo ( x + sx * 162 , y + sy * 205 ) rLineTo ( gc , sx * - 102.4 , 0 ) gc . CubicCurveTo ( x + sx * - 17 , y + sy * 205 , x + sx * - 17 , y + sy * 103 , x + sx * 60.0 , y + sy * 103.0 ) gc . Stroke ( ) gc . SetLineDash ( nil , 0.0 ) }
4904	func CubicCurve ( gc draw2d . GraphicContext , x , y , width , height float64 ) { sx , sy := width / 162 , height / 205 x0 , y0 := x , y + sy * 100.0 x1 , y1 := x + sx * 75 , y + sy * 205 x2 , y2 := x + sx * 125 , y x3 , y3 := x + sx * 205 , y + sy * 100 gc . SetStrokeColor ( image . Black ) gc . SetFillColor ( color . NRGBA { 0xAA , 0xAA , 0xAA , 0xFF } ) gc . SetLineWidth ( width / 10 ) gc . MoveTo ( x0 , y0 ) gc . CubicCurveTo ( x1 , y1 , x2 , y2 , x3 , y3 ) gc . Stroke ( ) gc . SetStrokeColor ( color . NRGBA { 0xFF , 0x33 , 0x33 , 0x88 } ) gc . SetLineWidth ( width / 20 ) gc . MoveTo ( x0 , y0 ) gc . LineTo ( x1 , y1 ) gc . LineTo ( x2 , y2 ) gc . LineTo ( x3 , y3 ) gc . Stroke ( ) }
4905	func FillStroke ( gc draw2d . GraphicContext , x , y , width , height float64 ) { sx , sy := width / 210 , height / 215 gc . MoveTo ( x + sx * 113.0 , y ) gc . LineTo ( x + sx * 215.0 , y + sy * 215 ) rLineTo ( gc , sx * - 100 , 0 ) gc . CubicCurveTo ( x + sx * 35 , y + sy * 215 , x + sx * 35 , y + sy * 113 , x + sx * 113.0 , y + sy * 113 ) gc . Close ( ) gc . MoveTo ( x + sx * 50.0 , y ) rLineTo ( gc , sx * 51.2 , sy * 51.2 ) rLineTo ( gc , sx * - 51.2 , sy * 51.2 ) rLineTo ( gc , sx * - 51.2 , sy * - 51.2 ) gc . Close ( ) gc . SetLineWidth ( width / 20.0 ) gc . SetFillColor ( color . NRGBA { 0 , 0 , 0xFF , 0xFF } ) gc . SetStrokeColor ( image . Black ) gc . FillStroke ( ) }
4906	func FillStyle ( gc draw2d . GraphicContext , x , y , width , height float64 ) { sx , sy := width / 232 , height / 220 gc . SetLineWidth ( width / 40 ) draw2dkit . Rectangle ( gc , x + sx * 0 , y + sy * 12 , x + sx * 232 , y + sy * 70 ) var wheel1 , wheel2 draw2d . Path wheel1 . ArcTo ( x + sx * 52 , y + sy * 70 , sx * 40 , sy * 40 , 0 , 2 * math . Pi ) wheel2 . ArcTo ( x + sx * 180 , y + sy * 70 , sx * 40 , sy * 40 , 0 , - 2 * math . Pi ) gc . SetFillRule ( draw2d . FillRuleEvenOdd ) gc . SetFillColor ( color . NRGBA { 0 , 0xB2 , 0 , 0xFF } ) gc . SetStrokeColor ( image . Black ) gc . FillStroke ( & wheel1 , & wheel2 ) draw2dkit . Rectangle ( gc , x , y + sy * 140 , x + sx * 232 , y + sy * 198 ) wheel1 . Clear ( ) wheel1 . ArcTo ( x + sx * 52 , y + sy * 198 , sx * 40 , sy * 40 , 0 , 2 * math . Pi ) wheel2 . Clear ( ) wheel2 . ArcTo ( x + sx * 180 , y + sy * 198 , sx * 40 , sy * 40 , 0 , - 2 * math . Pi ) gc . SetFillRule ( draw2d . FillRuleWinding ) gc . SetFillColor ( color . NRGBA { 0 , 0 , 0xE5 , 0xFF } ) gc . FillStroke ( & wheel1 , & wheel2 ) }
4907	func PathTransform ( gc draw2d . GraphicContext , x , y , width , height float64 ) { gc . Save ( ) gc . SetLineWidth ( width / 10 ) gc . Translate ( x + width / 2 , y + height / 2 ) gc . Scale ( 1 , 4 ) gc . ArcTo ( 0 , 0 , width / 8 , height / 8 , 0 , math . Pi * 2 ) gc . Close ( ) gc . Stroke ( ) gc . Restore ( ) }
4908	func Star ( gc draw2d . GraphicContext , x , y , width , height float64 ) { gc . Save ( ) gc . Translate ( x + width / 2 , y + height / 2 ) gc . SetLineWidth ( width / 40 ) for i := 0.0 ; i < 360 ; i = i + 10 { gc . Save ( ) gc . Rotate ( i * ( math . Pi / 180.0 ) ) gc . MoveTo ( 0 , 0 ) gc . LineTo ( width / 2 , 0 ) gc . Stroke ( ) gc . Restore ( ) } gc . Restore ( ) }
4909	func Draw ( gc draw2d . GraphicContext , width , height float64 ) { mx , my := width * 0.025 , height * 0.025 dx , dy := ( width - 2 * mx ) / 4 , ( height - 2 * my ) / 3 w , h := dx - 2 * mx , dy - 2 * my x0 , y := 2 * mx , 2 * my x := x0 Bubble ( gc , x , y , w , h ) x += dx CurveRectangle ( gc , x , y , w , h , color . NRGBA { 0x80 , 0 , 0 , 0x80 } , color . NRGBA { 0x80 , 0x80 , 0xFF , 0xFF } ) x += dx Dash ( gc , x , y , w , h ) x += dx Arc ( gc , x , y , w , h ) x = x0 y += dy ArcNegative ( gc , x , y , w , h ) x += dx CubicCurve ( gc , x , y , w , h ) x += dx FillString ( gc , x , y , w , h ) x += dx FillStroke ( gc , x , y , w , h ) x = x0 y += dy FillStyle ( gc , x , y , w , h ) x += dx PathTransform ( gc , x , y , w , h ) x += dx Star ( gc , x , y , w , h ) x += dx gopher2 . Draw ( gc , x , y , w , h / 2 ) }
4910	func ConvertPath ( path * draw2d . Path , pdf Vectorizer ) { var startX , startY float64 = 0 , 0 i := 0 for _ , cmp := range path . Components { switch cmp { case draw2d . MoveToCmp : startX , startY = path . Points [ i ] , path . Points [ i + 1 ] pdf . MoveTo ( startX , startY ) i += 2 case draw2d . LineToCmp : pdf . LineTo ( path . Points [ i ] , path . Points [ i + 1 ] ) i += 2 case draw2d . QuadCurveToCmp : pdf . CurveTo ( path . Points [ i ] , path . Points [ i + 1 ] , path . Points [ i + 2 ] , path . Points [ i + 3 ] ) i += 4 case draw2d . CubicCurveToCmp : pdf . CurveBezierCubicTo ( path . Points [ i ] , path . Points [ i + 1 ] , path . Points [ i + 2 ] , path . Points [ i + 3 ] , path . Points [ i + 4 ] , path . Points [ i + 5 ] ) i += 6 case draw2d . ArcToCmp : pdf . ArcTo ( path . Points [ i ] , path . Points [ i + 1 ] , path . Points [ i + 2 ] , path . Points [ i + 3 ] , 0 , path . Points [ i + 4 ] * deg , ( path . Points [ i + 4 ] - path . Points [ i + 5 ] ) * deg ) i += 6 case draw2d . CloseCmp : pdf . LineTo ( startX , startY ) pdf . ClosePath ( ) } } }
4911	func Main ( gc draw2d . GraphicContext , ext string ) ( string , error ) { const offset = 75.0 x := 35.0 caps := [ ] draw2d . LineCap { draw2d . ButtCap , draw2d . SquareCap , draw2d . RoundCap } joins := [ ] draw2d . LineJoin { draw2d . BevelJoin , draw2d . MiterJoin , draw2d . RoundJoin } for i := range caps { Draw ( gc , caps [ i ] , joins [ i ] , x , 50 , x , 160 , offset ) x += offset } return samples . Output ( "linecapjoin" , ext ) , nil }
4912	func Draw ( gc draw2d . GraphicContext , cap draw2d . LineCap , join draw2d . LineJoin , x0 , y0 , x1 , y1 , offset float64 ) { gc . SetLineCap ( cap ) gc . SetLineJoin ( join ) gc . SetStrokeColor ( color . NRGBA { 0x33 , 0x33 , 0x33 , 0xFF } ) gc . SetLineWidth ( 30.0 ) gc . MoveTo ( x0 , y0 ) gc . LineTo ( ( x0 + x1 ) / 2 + offset , ( y0 + y1 ) / 2 ) gc . LineTo ( x1 , y1 ) gc . Stroke ( ) gc . SetStrokeColor ( color . NRGBA { 0xFF , 0x33 , 0x33 , 0xFF } ) gc . SetLineWidth ( 2.56 ) gc . MoveTo ( x0 , y0 ) gc . LineTo ( ( x0 + x1 ) / 2 + offset , ( y0 + y1 ) / 2 ) gc . LineTo ( x1 , y1 ) gc . Stroke ( ) }
4913	func DrawContour ( path draw2d . PathBuilder , ps [ ] truetype . Point , dx , dy float64 ) { if len ( ps ) == 0 { return } startX , startY := pointToF64Point ( ps [ 0 ] ) path . MoveTo ( startX + dx , startY + dy ) q0X , q0Y , on0 := startX , startY , true for _ , p := range ps [ 1 : ] { qX , qY := pointToF64Point ( p ) on := p . Flags & 0x01 != 0 if on { if on0 { path . LineTo ( qX + dx , qY + dy ) } else { path . QuadCurveTo ( q0X + dx , q0Y + dy , qX + dx , qY + dy ) } } else { if on0 { } else { midX := ( q0X + qX ) / 2 midY := ( q0Y + qY ) / 2 path . QuadCurveTo ( q0X + dx , q0Y + dy , midX + dx , midY + dy ) } } q0X , q0Y , on0 = qX , qY , on } if on0 { path . LineTo ( startX + dx , startY + dy ) } else { path . QuadCurveTo ( q0X + dx , q0Y + dy , startX + dx , startY + dy ) } }
4914	func Flatten ( path * draw2d . Path , flattener Flattener , scale float64 ) { var startX , startY float64 = 0 , 0 var x , y float64 = 0 , 0 i := 0 for _ , cmp := range path . Components { switch cmp { case draw2d . MoveToCmp : x , y = path . Points [ i ] , path . Points [ i + 1 ] startX , startY = x , y if i != 0 { flattener . End ( ) } flattener . MoveTo ( x , y ) i += 2 case draw2d . LineToCmp : x , y = path . Points [ i ] , path . Points [ i + 1 ] flattener . LineTo ( x , y ) flattener . LineJoin ( ) i += 2 case draw2d . QuadCurveToCmp : TraceQuad ( flattener , path . Points [ i - 2 : ] , 0.5 ) x , y = path . Points [ i + 2 ] , path . Points [ i + 3 ] flattener . LineTo ( x , y ) i += 4 case draw2d . CubicCurveToCmp : TraceCubic ( flattener , path . Points [ i - 2 : ] , 0.5 ) x , y = path . Points [ i + 4 ] , path . Points [ i + 5 ] flattener . LineTo ( x , y ) i += 6 case draw2d . ArcToCmp : x , y = TraceArc ( flattener , path . Points [ i ] , path . Points [ i + 1 ] , path . Points [ i + 2 ] , path . Points [ i + 3 ] , path . Points [ i + 4 ] , path . Points [ i + 5 ] , scale ) flattener . LineTo ( x , y ) i += 6 case draw2d . CloseCmp : flattener . LineTo ( startX , startY ) flattener . Close ( ) } } flattener . End ( ) }
4915	func ( gc * GraphicContext ) Clear ( ) { width , height := gc . img . Bounds ( ) . Dx ( ) , gc . img . Bounds ( ) . Dy ( ) gc . ClearRect ( 0 , 0 , width , height ) }
4916	func ( gc * GraphicContext ) ClearRect ( x1 , y1 , x2 , y2 int ) { imageColor := image . NewUniform ( gc . Current . FillColor ) draw . Draw ( gc . img , image . Rect ( x1 , y1 , x2 , y2 ) , imageColor , image . ZP , draw . Over ) }
4917	func DrawImage ( src image . Image , dest draw . Image , tr draw2d . Matrix , op draw . Op , filter ImageFilter ) { var transformer draw . Transformer switch filter { case LinearFilter : transformer = draw . NearestNeighbor case BilinearFilter : transformer = draw . BiLinear case BicubicFilter : transformer = draw . CatmullRom } transformer . Transform ( dest , f64 . Aff3 { tr [ 0 ] , tr [ 1 ] , tr [ 4 ] , tr [ 2 ] , tr [ 3 ] , tr [ 5 ] } , src , src . Bounds ( ) , op , nil ) }
4918	func Main ( gc draw2d . GraphicContext , ext string ) ( string , error ) { const margin = 30 const lineWidth = 3 gopher := samples . Resource ( "image" , "gopher.png" , ext ) err := Draw ( gc , gopher , 297 , 210 , margin , lineWidth ) return samples . Output ( "frameimage" , ext ) , err }
4919	func Draw ( gc draw2d . GraphicContext , png string , dw , dh , margin , lineWidth float64 ) error { draw2dkit . RoundedRectangle ( gc , lineWidth , lineWidth , dw - lineWidth , dh - lineWidth , 100 , 100 ) gc . SetLineWidth ( lineWidth ) gc . FillStroke ( ) source , err := draw2dimg . LoadFromPngFile ( png ) if err != nil { return err } sw , sh := float64 ( source . Bounds ( ) . Dx ( ) ) , float64 ( source . Bounds ( ) . Dy ( ) ) scale := math . Min ( ( dw - margin * 2 ) / sw , ( dh - margin * 2 ) / sh ) gc . Save ( ) gc . Translate ( ( dw - sw * scale ) / 2 , ( dh - sh * scale ) / 2 ) gc . Scale ( scale , scale ) gc . Rotate ( 0.2 ) gc . DrawImage ( source ) gc . Restore ( ) return nil }
4920	func Draw ( gc draw2d . GraphicContext , x , y float64 ) { gc . SetFillColor ( color . RGBA { 0x44 , 0xff , 0x44 , 0xff } ) gc . SetStrokeColor ( color . RGBA { 0x44 , 0x44 , 0x44 , 0xff } ) gc . SetLineCap ( draw2d . RoundCap ) gc . SetLineWidth ( 5 ) gc . MoveTo ( x + 30 , y + 70 ) gc . ArcTo ( x + 80 , y + 70 , 50 , 50 , 180 * ( math . Pi / 180 ) , 180 * ( math . Pi / 180 ) ) gc . Close ( ) gc . FillStroke ( ) gc . MoveTo ( x + 60 , y + 25 ) gc . LineTo ( x + 50 , y + 10 ) gc . MoveTo ( x + 100 , y + 25 ) gc . LineTo ( x + 110 , y + 10 ) gc . Stroke ( ) draw2dkit . Circle ( gc , x + 60 , y + 45 , 5 ) gc . FillStroke ( ) draw2dkit . Circle ( gc , x + 100 , y + 45 , 5 ) gc . FillStroke ( ) draw2dkit . RoundedRectangle ( gc , x + 30 , y + 75 , x + 30 + 100 , y + 75 + 90 , 10 , 10 ) gc . FillStroke ( ) draw2dkit . Rectangle ( gc , x + 30 , y + 75 , x + 30 + 100 , y + 75 + 80 ) gc . FillStroke ( ) draw2dkit . RoundedRectangle ( gc , x + 5 , y + 80 , x + 5 + 20 , y + 80 + 70 , 10 , 10 ) gc . FillStroke ( ) draw2dkit . RoundedRectangle ( gc , x + 135 , y + 80 , x + 135 + 20 , y + 80 + 70 , 10 , 10 ) gc . FillStroke ( ) draw2dkit . RoundedRectangle ( gc , x + 50 , y + 150 , x + 50 + 20 , y + 150 + 50 , 10 , 10 ) gc . FillStroke ( ) draw2dkit . RoundedRectangle ( gc , x + 90 , y + 150 , x + 90 + 20 , y + 150 + 50 , 10 , 10 ) gc . FillStroke ( ) }
4921	func ChecksumString32S ( s string , seed uint32 ) uint32 { if len ( s ) == 0 { return Checksum32S ( nil , seed ) } ss := ( * reflect . StringHeader ) ( unsafe . Pointer ( & s ) ) return Checksum32S ( ( * [ maxInt32 ] byte ) ( unsafe . Pointer ( ss . Data ) ) [ : len ( s ) : len ( s ) ] , seed ) }
4922	func ChecksumString64S ( s string , seed uint64 ) uint64 { if len ( s ) == 0 { return Checksum64S ( nil , seed ) } ss := ( * reflect . StringHeader ) ( unsafe . Pointer ( & s ) ) return Checksum64S ( ( * [ maxInt32 ] byte ) ( unsafe . Pointer ( ss . Data ) ) [ : len ( s ) : len ( s ) ] , seed ) }
4923	func NewS32 ( seed uint32 ) ( xx * XXHash32 ) { xx = & XXHash32 { seed : seed , } xx . Reset ( ) return }
4924	func NewS64 ( seed uint64 ) ( xx * XXHash64 ) { xx = & XXHash64 { seed : seed , } xx . Reset ( ) return }
4925	func round64 ( h , v uint64 ) uint64 { h += v * prime64x2 h = rotl64_31 ( h ) h *= prime64x1 return h }
4926	func Checksum32S ( in [ ] byte , seed uint32 ) ( h uint32 ) { var i int if len ( in ) > 15 { var ( v1 = seed + prime32x1 + prime32x2 v2 = seed + prime32x2 v3 = seed + 0 v4 = seed - prime32x1 ) for ; i < len ( in ) - 15 ; i += 16 { in := in [ i : i + 16 : len ( in ) ] v1 += u32 ( in [ 0 : 4 : len ( in ) ] ) * prime32x2 v1 = rotl32_13 ( v1 ) * prime32x1 v2 += u32 ( in [ 4 : 8 : len ( in ) ] ) * prime32x2 v2 = rotl32_13 ( v2 ) * prime32x1 v3 += u32 ( in [ 8 : 12 : len ( in ) ] ) * prime32x2 v3 = rotl32_13 ( v3 ) * prime32x1 v4 += u32 ( in [ 12 : 16 : len ( in ) ] ) * prime32x2 v4 = rotl32_13 ( v4 ) * prime32x1 } h = rotl32_1 ( v1 ) + rotl32_7 ( v2 ) + rotl32_12 ( v3 ) + rotl32_18 ( v4 ) } else { h = seed + prime32x5 } h += uint32 ( len ( in ) ) for ; i <= len ( in ) - 4 ; i += 4 { in := in [ i : i + 4 : len ( in ) ] h += u32 ( in [ 0 : 4 : len ( in ) ] ) * prime32x3 h = rotl32_17 ( h ) * prime32x4 } for ; i < len ( in ) ; i ++ { h += uint32 ( in [ i ] ) * prime32x5 h = rotl32_11 ( h ) * prime32x1 } h ^= h >> 15 h *= prime32x2 h ^= h >> 13 h *= prime32x3 h ^= h >> 16 return }
4927	func Checksum64S ( in [ ] byte , seed uint64 ) uint64 { if len ( in ) == 0 && seed == 0 { return 0xef46db3751d8e999 } if len ( in ) > 31 { return checksum64 ( in , seed ) } return checksum64Short ( in , seed ) }
4928	func getStage ( ) ( stage int , advanceStage func ( ) error , resetEnv func ( ) error ) { var origValue string stage = 0 daemonStage := os . Getenv ( stageVar ) stageTag := strings . SplitN ( daemonStage , ":" , 2 ) stageInfo := strings . SplitN ( stageTag [ 0 ] , "/" , 3 ) if len ( stageInfo ) == 3 { stageStr , tm , check := stageInfo [ 0 ] , stageInfo [ 1 ] , stageInfo [ 2 ] hash := sha1 . New ( ) hash . Write ( [ ] byte ( stageStr + "/" + tm + "/" ) ) if check != hex . EncodeToString ( hash . Sum ( [ ] byte { } ) ) { origValue = daemonStage } else { stage , _ = strconv . Atoi ( stageStr ) if len ( stageTag ) == 2 { origValue = stageTag [ 1 ] } } } else { origValue = daemonStage } advanceStage = func ( ) error { base := fmt . Sprintf ( "%d/%09d/" , stage + 1 , time . Now ( ) . Nanosecond ( ) ) hash := sha1 . New ( ) hash . Write ( [ ] byte ( base ) ) tag := base + hex . EncodeToString ( hash . Sum ( [ ] byte { } ) ) if err := os . Setenv ( stageVar , tag + ":" + origValue ) ; err != nil { return fmt . Errorf ( "can't set %s: %s" , stageVar , err ) } return nil } resetEnv = func ( ) error { return os . Setenv ( stageVar , origValue ) } return stage , advanceStage , resetEnv }
4929	func New ( ) * Glg { g := & Glg { levelCounter : new ( uint32 ) , buffer : sync . Pool { New : func ( ) interface { } { return bytes . NewBuffer ( make ( [ ] byte , 0 , bufferSize ) ) } , } , } atomic . StoreUint32 ( g . levelCounter , uint32 ( FATAL ) ) for lev , log := range map [ LEVEL ] * logger { PRINT : { std : os . Stdout , color : Colorless , isColor : true , mode : STD , } , LOG : { std : os . Stdout , color : Colorless , isColor : true , mode : STD , } , INFO : { std : os . Stdout , color : Green , isColor : true , mode : STD , } , DEBG : { std : os . Stdout , color : Purple , isColor : true , mode : STD , } , OK : { std : os . Stdout , color : Cyan , isColor : true , mode : STD , } , WARN : { std : os . Stdout , color : Orange , isColor : true , mode : STD , } , ERR : { std : os . Stderr , color : Red , isColor : true , mode : STD , } , FAIL : { std : os . Stderr , color : Red , isColor : true , mode : STD , } , FATAL : { std : os . Stderr , color : Red , isColor : true , mode : STD , } , } { log . tag = lev . String ( ) log . updateMode ( ) g . logger . Store ( lev , log ) } return g }
4930	func Get ( ) * Glg { once . Do ( func ( ) { fastime . SetFormat ( timeFormat ) glg = New ( ) } ) return glg }
4931	func ( g * Glg ) SetMode ( mode MODE ) * Glg { g . logger . Range ( func ( key , val interface { } ) bool { l := val . ( * logger ) l . mode = mode l . updateMode ( ) g . logger . Store ( key . ( LEVEL ) , l ) return true } ) return g }
4932	func ( g * Glg ) SetPrefix ( pref string ) * Glg { v , ok := g . logger . Load ( PRINT ) if ok { value := v . ( * logger ) value . tag = pref g . logger . Store ( PRINT , value ) } return g }
4933	func ( g * Glg ) GetCurrentMode ( level LEVEL ) MODE { l , ok := g . logger . Load ( level ) if ok { return l . ( * logger ) . mode } return NONE }
4934	func ( g * Glg ) InitWriter ( ) * Glg { g . logger . Range ( func ( key , val interface { } ) bool { l := val . ( * logger ) l . writer = nil l . updateMode ( ) g . logger . Store ( key . ( LEVEL ) , l ) return true } ) return g }
4935	func ( g * Glg ) SetWriter ( writer io . Writer ) * Glg { if writer == nil { return g } g . logger . Range ( func ( key , val interface { } ) bool { l := val . ( * logger ) l . writer = writer l . updateMode ( ) g . logger . Store ( key . ( LEVEL ) , l ) return true } ) return g }
4936	func ( g * Glg ) SetLevelColor ( level LEVEL , color func ( string ) string ) * Glg { lev , ok := g . logger . Load ( level ) if ok { l := lev . ( * logger ) l . color = color g . logger . Store ( level , l ) } return g }
4937	func ( g * Glg ) SetLevelWriter ( level LEVEL , writer io . Writer ) * Glg { if writer == nil { return g } lev , ok := g . logger . Load ( level ) if ok { l := lev . ( * logger ) l . writer = writer l . updateMode ( ) g . logger . Store ( level , l ) } return g }
4938	func ( g * Glg ) AddStdLevel ( tag string , mode MODE , isColor bool ) * Glg { atomic . AddUint32 ( g . levelCounter , 1 ) lev := LEVEL ( atomic . LoadUint32 ( g . levelCounter ) ) g . levelMap . Store ( tag , lev ) l := & logger { writer : nil , std : os . Stdout , color : Colorless , isColor : isColor , mode : mode , tag : tag , } l . updateMode ( ) g . logger . Store ( lev , l ) return g }
4939	func ( g * Glg ) EnableColor ( ) * Glg { g . logger . Range ( func ( key , val interface { } ) bool { l := val . ( * logger ) l . isColor = true l . updateMode ( ) g . logger . Store ( key . ( LEVEL ) , l ) return true } ) return g }
4940	func ( g * Glg ) EnableLevelColor ( lv LEVEL ) * Glg { ins , ok := g . logger . Load ( lv ) if ok { l := ins . ( * logger ) l . isColor = true l . updateMode ( ) g . logger . Store ( lv , l ) } return g }
4941	func ( g * Glg ) DisableLevelColor ( lv LEVEL ) * Glg { ins , ok := g . logger . Load ( lv ) if ok { l := ins . ( * logger ) l . isColor = false l . updateMode ( ) g . logger . Store ( lv , l ) } return g }
4942	func ( g * Glg ) RawString ( data [ ] byte ) string { str := * ( * string ) ( unsafe . Pointer ( & data ) ) return str [ strings . Index ( str , sep ) + sepl : len ( str ) - rcl ] }
4943	func ( g * Glg ) TagStringToLevel ( tag string ) LEVEL { l , ok := g . levelMap . Load ( tag ) if ! ok { return 255 } return l . ( LEVEL ) }
4944	func Println ( val ... interface { } ) error { return glg . out ( PRINT , blankFormat ( len ( val ) ) , val ... ) }
4945	func ( g * Glg ) Fatal ( val ... interface { } ) { err := g . out ( FATAL , blankFormat ( len ( val ) ) , val ... ) if err != nil { err = g . Error ( err . Error ( ) ) if err != nil { panic ( err ) } } exit ( 1 ) }
4946	func ( g * Glg ) Fatalf ( format string , val ... interface { } ) { err := g . out ( FATAL , format , val ... ) if err != nil { err = g . Error ( err . Error ( ) ) if err != nil { panic ( err ) } } exit ( 1 ) }
4947	func ( g * Glg ) isModeEnable ( l LEVEL ) bool { return g . GetCurrentMode ( l ) != NONE }
4948	func CaptureMetrics ( hnd http . Handler , w http . ResponseWriter , r * http . Request ) Metrics { return CaptureMetricsFn ( w , func ( ww http . ResponseWriter ) { hnd . ServeHTTP ( ww , r ) } ) }
4949	func ( da * cedar ) get ( key [ ] byte , from , pos int ) * int { for ; pos < len ( key ) ; pos ++ { if value := da . Array [ from ] . Value ; value >= 0 && value != ValueLimit { to := da . follow ( from , 0 ) da . Array [ to ] . Value = value } from = da . follow ( from , key [ pos ] ) } to := from if da . Array [ from ] . Value < 0 { to = da . follow ( from , 0 ) } return & da . Array [ to ] . Value }
4950	func ( da * Cedar ) Save ( out io . Writer , dataType string ) error { switch dataType { case "gob" , "GOB" : dataEecoder := gob . NewEncoder ( out ) return dataEecoder . Encode ( da . cedar ) case "json" , "JSON" : dataEecoder := json . NewEncoder ( out ) return dataEecoder . Encode ( da . cedar ) } return ErrInvalidDataType }
4951	func ( da * Cedar ) SaveToFile ( fileName string , dataType string ) error { file , err := os . OpenFile ( fileName , os . O_CREATE | os . O_WRONLY , 0666 ) if err != nil { return err } defer file . Close ( ) out := bufio . NewWriter ( file ) defer out . Flush ( ) da . Save ( out , dataType ) return nil }
4952	func ( da * Cedar ) Load ( in io . Reader , dataType string ) error { switch dataType { case "gob" , "GOB" : dataDecoder := gob . NewDecoder ( in ) return dataDecoder . Decode ( da . cedar ) case "json" , "JSON" : dataDecoder := json . NewDecoder ( in ) return dataDecoder . Decode ( da . cedar ) } return ErrInvalidDataType }
4953	func ( da * Cedar ) LoadFromFile ( fileName string , dataType string ) error { file , err := os . OpenFile ( fileName , os . O_RDONLY , 0600 ) defer file . Close ( ) if err != nil { return err } in := bufio . NewReader ( file ) return da . Load ( in , dataType ) }
4954	func ( da * Cedar ) Key ( id int ) ( key [ ] byte , err error ) { for id > 0 { from := da . Array [ id ] . Check if from < 0 { return nil , ErrNoPath } if char := byte ( da . Array [ from ] . base ( ) ^ id ) ; char != 0 { key = append ( key , char ) } id = from } if id != 0 || len ( key ) == 0 { return nil , ErrInvalidKey } for i := 0 ; i < len ( key ) / 2 ; i ++ { key [ i ] , key [ len ( key ) - i - 1 ] = key [ len ( key ) - i - 1 ] , key [ i ] } return key , nil }
4955	func ( da * Cedar ) Value ( id int ) ( value int , err error ) { value = da . Array [ id ] . Value if value >= 0 { return value , nil } to := da . Array [ id ] . base ( ) if da . Array [ to ] . Check == id && da . Array [ to ] . Value >= 0 { return da . Array [ to ] . Value , nil } return 0 , ErrNoValue }
4956	func ( da * Cedar ) Delete ( key [ ] byte ) error { to , err := da . Jump ( key , 0 ) if err != nil { return ErrNoPath } if da . Array [ to ] . Value < 0 { base := da . Array [ to ] . base ( ) if da . Array [ base ] . Check == to { to = base } } for to > 0 { from := da . Array [ to ] . Check base := da . Array [ from ] . base ( ) label := byte ( to ^ base ) if da . Ninfos [ to ] . Sibling != 0 || da . Ninfos [ from ] . Child != label { da . popSibling ( from , base , label ) da . pushEnode ( to ) break } da . pushEnode ( to ) to = from } return nil }
4957	func ( v * Version ) Set ( version string ) error { metadata := splitOff ( & version , "+" ) preRelease := PreRelease ( splitOff ( & version , "-" ) ) dotParts := strings . SplitN ( version , "." , 3 ) if len ( dotParts ) != 3 { return fmt . Errorf ( "%s is not in dotted-tri format" , version ) } if err := validateIdentifier ( string ( preRelease ) ) ; err != nil { return fmt . Errorf ( "failed to validate pre-release: %v" , err ) } if err := validateIdentifier ( metadata ) ; err != nil { return fmt . Errorf ( "failed to validate metadata: %v" , err ) } parsed := make ( [ ] int64 , 3 , 3 ) for i , v := range dotParts [ : 3 ] { val , err := strconv . ParseInt ( v , 10 , 64 ) parsed [ i ] = val if err != nil { return err } } v . Metadata = metadata v . PreRelease = preRelease v . Major = parsed [ 0 ] v . Minor = parsed [ 1 ] v . Patch = parsed [ 2 ] return nil }
4958	func ( v Version ) Compare ( versionB Version ) int { if cmp := recursiveCompare ( v . Slice ( ) , versionB . Slice ( ) ) ; cmp != 0 { return cmp } return preReleaseCompare ( v , versionB ) }
4959	func ( v Version ) Slice ( ) [ ] int64 { return [ ] int64 { v . Major , v . Minor , v . Patch } }
4960	func ( v * Version ) BumpMajor ( ) { v . Major += 1 v . Minor = 0 v . Patch = 0 v . PreRelease = PreRelease ( "" ) v . Metadata = "" }
4961	func ( v * Version ) BumpMinor ( ) { v . Minor += 1 v . Patch = 0 v . PreRelease = PreRelease ( "" ) v . Metadata = "" }
4962	func ( v * Version ) BumpPatch ( ) { v . Patch += 1 v . PreRelease = PreRelease ( "" ) v . Metadata = "" }
4963	func validateIdentifier ( id string ) error { if id != "" && ! reIdentifier . MatchString ( id ) { return fmt . Errorf ( "%s is not a valid semver identifier" , id ) } return nil }
4964	func newStream ( bufsize int , replay bool ) * Stream { return & Stream { AutoReplay : replay , subscribers : make ( [ ] * Subscriber , 0 ) , register : make ( chan * Subscriber ) , deregister : make ( chan * Subscriber ) , event : make ( chan * Event , bufsize ) , quit : make ( chan bool ) , Eventlog : make ( EventLog , 0 ) , } }
4965	func ( str * Stream ) addSubscriber ( eventid string ) * Subscriber { sub := & Subscriber { eventid : eventid , quit : str . deregister , connection : make ( chan * Event , 64 ) , } str . register <- sub return sub }
4966	func New ( ) * Server { return & Server { BufferSize : DefaultBufferSize , AutoStream : false , AutoReplay : true , Streams : make ( map [ string ] * Stream ) , } }
4967	func ( s * Server ) Close ( ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) for id := range s . Streams { s . Streams [ id ] . quit <- true delete ( s . Streams , id ) } }
4968	func ( s * Server ) CreateStream ( id string ) * Stream { s . mu . Lock ( ) defer s . mu . Unlock ( ) if s . Streams [ id ] != nil { return s . Streams [ id ] } str := newStream ( s . BufferSize , s . AutoReplay ) str . run ( ) s . Streams [ id ] = str return str }
4969	func ( s * Server ) RemoveStream ( id string ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) if s . Streams [ id ] != nil { s . Streams [ id ] . close ( ) delete ( s . Streams , id ) } }
4970	func ( s * Server ) StreamExists ( id string ) bool { s . mu . Lock ( ) defer s . mu . Unlock ( ) return s . Streams [ id ] != nil }
4971	func ( s * Server ) Publish ( id string , event * Event ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) if s . Streams [ id ] != nil { s . Streams [ id ] . event <- s . process ( event ) } }
4972	func NewClient ( url string ) * Client { return & Client { URL : url , Connection : & http . Client { } , Headers : make ( map [ string ] string ) , subscribed : make ( map [ chan * Event ] chan bool ) , } }
4973	func ( c * Client ) Subscribe ( stream string , handler func ( msg * Event ) ) error { operation := func ( ) error { resp , err := c . request ( stream ) if err != nil { return err } defer resp . Body . Close ( ) reader := NewEventStreamReader ( resp . Body ) for { event , err := reader . ReadEvent ( ) if err != nil { if err == io . EOF { return nil } if c . disconnectcb != nil { c . disconnectcb ( c ) } return err } if msg , err := c . processEvent ( event ) ; err == nil { if len ( msg . ID ) > 0 { c . EventID = string ( msg . ID ) } else { msg . ID = [ ] byte ( c . EventID ) } handler ( msg ) } } } return backoff . Retry ( operation , backoff . NewExponentialBackOff ( ) ) }
4974	func ( c * Client ) SubscribeChan ( stream string , ch chan * Event ) error { var connected bool errch := make ( chan error ) c . mu . Lock ( ) c . subscribed [ ch ] = make ( chan bool ) c . mu . Unlock ( ) go func ( ) { operation := func ( ) error { resp , err := c . request ( stream ) if err != nil { c . cleanup ( resp , ch ) return err } if resp . StatusCode != 200 { c . cleanup ( resp , ch ) return errors . New ( "could not connect to stream" ) } if ! connected { errch <- nil connected = true } reader := NewEventStreamReader ( resp . Body ) for { event , err := reader . ReadEvent ( ) if err != nil { if err == io . EOF { c . cleanup ( resp , ch ) return nil } if c . disconnectcb != nil { c . disconnectcb ( c ) } return err } if msg , err := c . processEvent ( event ) ; err == nil { if len ( msg . ID ) > 0 { c . EventID = string ( msg . ID ) } else { msg . ID = [ ] byte ( c . EventID ) } select { case <- c . subscribed [ ch ] : c . cleanup ( resp , ch ) return nil case ch <- msg : } } } } err := backoff . Retry ( operation , backoff . NewExponentialBackOff ( ) ) if err != nil && ! connected { errch <- err } } ( ) err := <- errch close ( errch ) return err }
4975	func ( c * Client ) SubscribeRaw ( handler func ( msg * Event ) ) error { return c . Subscribe ( "" , handler ) }
4976	func ( c * Client ) Unsubscribe ( ch chan * Event ) { c . mu . Lock ( ) defer c . mu . Unlock ( ) if c . subscribed [ ch ] != nil { c . subscribed [ ch ] <- true } }
4977	func NewEventStreamReader ( eventStream io . Reader ) * EventStreamReader { scanner := bufio . NewScanner ( eventStream ) split := func ( data [ ] byte , atEOF bool ) ( int , [ ] byte , error ) { if atEOF && len ( data ) == 0 { return 0 , nil , nil } if i := bytes . Index ( data , [ ] byte ( "\r\n\r\n" ) ) ; \r \n \r \n i >= 0 { return i + 1 , data [ 0 : i ] , nil } } if i := bytes . Index ( data , [ ] byte ( "\r\r" ) ) ; \r \r i >= 0 }
4978	func ( e * EventStreamReader ) ReadEvent ( ) ( [ ] byte , error ) { if e . scanner . Scan ( ) { event := e . scanner . Bytes ( ) return event , nil } if err := e . scanner . Err ( ) ; err != nil { return nil , err } return nil , io . EOF }
4979	func ( s * Server ) HTTPHandler ( w http . ResponseWriter , r * http . Request ) { flusher , err := w . ( http . Flusher ) if ! err { http . Error ( w , "Streaming unsupported!" , http . StatusInternalServerError ) return } w . Header ( ) . Set ( "Content-Type" , "text/event-stream" ) w . Header ( ) . Set ( "Cache-Control" , "no-cache" ) w . Header ( ) . Set ( "Connection" , "keep-alive" ) w . Header ( ) . Set ( "Access-Control-Allow-Origin" , "*" ) streamID := r . URL . Query ( ) . Get ( "stream" ) if streamID == "" { http . Error ( w , "Please specify a stream!" , http . StatusInternalServerError ) return } stream := s . getStream ( streamID ) if stream == nil && ! s . AutoStream { http . Error ( w , "Stream not found!" , http . StatusInternalServerError ) return } else if stream == nil && s . AutoStream { stream = s . CreateStream ( streamID ) } eventid := r . Header . Get ( "Last-Event-ID" ) if eventid == "" { eventid = "0" } sub := stream . addSubscriber ( eventid ) defer sub . close ( ) notify := w . ( http . CloseNotifier ) . CloseNotify ( ) go func ( ) { <- notify sub . close ( ) } ( ) for { select { case ev , ok := <- sub . connection : if ! ok { return } if len ( ev . Data ) == 0 { break } if s . EventTTL != 0 && time . Now ( ) . After ( ev . timestamp . Add ( s . EventTTL ) ) { continue } fmt . Fprintf ( w , "id: %s\n" , \n ) ev . ID fmt . Fprintf ( w , "data: %s\n" , \n ) ev . Data if len ( ev . Event ) > 0 { fmt . Fprintf ( w , "event: %s\n" , \n ) } ev . Event } } }
4980	func ( e * EventLog ) Add ( ev * Event ) { ev . ID = [ ] byte ( e . currentindex ( ) ) ev . timestamp = time . Now ( ) ( * e ) = append ( ( * e ) , ev ) }
4981	func ( e * EventLog ) Replay ( s * Subscriber ) { for i := 0 ; i < len ( ( * e ) ) ; i ++ { if string ( ( * e ) [ i ] . ID ) >= s . eventid { s . connection <- ( * e ) [ i ] } } }
4982	func readKey ( path string ) ( crypto . Signer , error ) { b , err := ioutil . ReadFile ( path ) if err != nil { return nil , err } d , _ := pem . Decode ( b ) if d == nil { return nil , fmt . Errorf ( "no block found in %q" , path ) } switch d . Type { case rsaPrivateKey : return x509 . ParsePKCS1PrivateKey ( d . Bytes ) case ecPrivateKey : return x509 . ParseECPrivateKey ( d . Bytes ) default : return nil , fmt . Errorf ( "%q is unsupported" , d . Type ) } }
4983	func writeKey ( path string , k * ecdsa . PrivateKey ) error { f , err := os . OpenFile ( path , os . O_WRONLY | os . O_CREATE | os . O_TRUNC , 0600 ) if err != nil { return err } bytes , err := x509 . MarshalECPrivateKey ( k ) if err != nil { return err } b := & pem . Block { Type : ecPrivateKey , Bytes : bytes } if err := pem . Encode ( f , b ) ; err != nil { f . Close ( ) return err } return f . Close ( ) }
4984	func anyKey ( filename string , gen bool ) ( crypto . Signer , error ) { k , err := readKey ( filename ) if err == nil { return k , nil } if ! os . IsNotExist ( err ) || ! gen { return nil , err } ecKey , err := ecdsa . GenerateKey ( elliptic . P256 ( ) , rand . Reader ) if err != nil { return nil , err } return ecKey , writeKey ( filename , ecKey ) }
4985	func sameDir ( existing , filename string ) string { return filepath . Join ( filepath . Dir ( existing ) , filename ) }
4986	func printAccount ( w io . Writer , a * acme . Account , kp string ) { tw := tabwriter . NewWriter ( w , 0 , 8 , 0 , '\t' , 0 ) fmt . Fprintln ( tw , "URI:\t" , \t ) a . URI fmt . Fprintln ( tw , "Key:\t" , \t ) kp fmt . Fprintln ( tw , "Contact:\t" , \t ) strings . Join ( a . Contact , ", " ) fmt . Fprintln ( tw , "Terms:\t" , \t ) a . CurrentTerms }
4987	func tmpl ( w io . Writer , text string , data interface { } ) { t := template . New ( "top" ) t . Funcs ( template . FuncMap { "trim" : strings . TrimSpace , "capitalize" : capitalize , } ) template . Must ( t . Parse ( text ) ) ew := & errWriter { w : w } err := t . Execute ( ew , data ) if ew . err != nil { if strings . Contains ( ew . err . Error ( ) , "pipe" ) { os . Exit ( 1 ) } fatalf ( "writing output: %v" , ew . err ) } if err != nil { panic ( err ) } }
4988	func printUsage ( w io . Writer ) { bw := bufio . NewWriter ( w ) tmpl ( bw , usageTemplate , commands ) bw . Flush ( ) }
4989	func FromRequest ( r * http . Request ) string { xRealIP := r . Header . Get ( "X-Real-Ip" ) xForwardedFor := r . Header . Get ( "X-Forwarded-For" ) if xRealIP == "" && xForwardedFor == "" { var remoteIP string if strings . ContainsRune ( r . RemoteAddr , ':' ) { remoteIP , _ , _ = net . SplitHostPort ( r . RemoteAddr ) } else { remoteIP = r . RemoteAddr } return remoteIP } for _ , address := range strings . Split ( xForwardedFor , "," ) { address = strings . TrimSpace ( address ) isPrivate , err := isPrivateAddress ( address ) if ! isPrivate && err == nil { return address } } return xRealIP }
4990	func ( p * ClearParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandClear , p , nil ) }
4991	func ( p * DisableParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDisable , nil , nil ) }
4992	func ( p * RemoveDOMStorageItemParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandRemoveDOMStorageItem , p , nil ) }
4993	func ( p * SetDOMStorageItemParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetDOMStorageItem , p , nil ) }
4994	func ( p * DeliverPushMessageParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDeliverPushMessage , p , nil ) }
4995	func ( p * DispatchSyncEventParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDispatchSyncEvent , p , nil ) }
4996	func ( p * InspectWorkerParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandInspectWorker , p , nil ) }
4997	func ( p * SetForceUpdateOnPageLoadParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetForceUpdateOnPageLoad , p , nil ) }
4998	func ( p * SkipWaitingParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSkipWaiting , p , nil ) }
4999	func ( p * StartWorkerParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStartWorker , p , nil ) }
5000	func ( p * StopAllWorkersParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStopAllWorkers , nil , nil ) }
5001	func ( p * StopWorkerParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStopWorker , p , nil ) }
5002	func ( p * UnregisterParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandUnregister , p , nil ) }
5003	func ( p * UpdateRegistrationParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandUpdateRegistration , p , nil ) }
5004	func ( p * BindParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandBind , p , nil ) }
5005	func ( p * UnbindParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandUnbind , p , nil ) }
5006	func ( e * ExceptionDetails ) Error ( ) string { return fmt . Sprintf ( "encountered exception '%s' (%d:%d)" , e . Text , e . LineNumber , e . ColumnNumber ) }
5007	func ( p * ReleaseAnimationsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandReleaseAnimations , p , nil ) }
5008	func ( p * SeekAnimationsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSeekAnimations , p , nil ) }
5009	func ( p * SetPausedParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetPaused , p , nil ) }
5010	func ( p * SetPlaybackRateParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetPlaybackRate , p , nil ) }
5011	func ( p * SetTimingParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetTiming , p , nil ) }
5012	func ( p * PrepareForLeakDetectionParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandPrepareForLeakDetection , nil , nil ) }
5013	func ( p * ForciblyPurgeJavaScriptMemoryParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandForciblyPurgeJavaScriptMemory , nil , nil ) }
5014	func ( p * SetPressureNotificationsSuppressedParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetPressureNotificationsSuppressed , p , nil ) }
5015	func ( p * SimulatePressureNotificationParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSimulatePressureNotification , p , nil ) }
5016	func ( p StartSamplingParams ) WithSamplingInterval ( samplingInterval int64 ) * StartSamplingParams { p . SamplingInterval = samplingInterval return & p }
5017	func ( p StartSamplingParams ) WithSuppressRandomness ( suppressRandomness bool ) * StartSamplingParams { p . SuppressRandomness = suppressRandomness return & p }
5018	func ( p * StartSamplingParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStartSampling , p , nil ) }
5019	func ( p * StopSamplingParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStopSampling , nil , nil ) }
5020	func ( p * ClearDeviceOrientationOverrideParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandClearDeviceOrientationOverride , nil , nil ) }
5021	func ( p * SetDeviceOrientationOverrideParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetDeviceOrientationOverride , p , nil ) }
5022	func ( p * StartViolationsReportParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStartViolationsReport , p , nil ) }
5023	func ( p * StopViolationsReportParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStopViolationsReport , nil , nil ) }
5024	func ( t Modifier ) String ( ) string { switch t { case ModifierNone : return "None" case ModifierAlt : return "Alt" case ModifierCtrl : return "Ctrl" case ModifierMeta : return "Meta" case ModifierShift : return "Shift" } return fmt . Sprintf ( "Modifier(%d)" , t ) }
5025	func ( p GetPartialAXTreeParams ) WithNodeID ( nodeID cdp . NodeID ) * GetPartialAXTreeParams { p . NodeID = nodeID return & p }
5026	func ( p GetPartialAXTreeParams ) WithBackendNodeID ( backendNodeID cdp . BackendNodeID ) * GetPartialAXTreeParams { p . BackendNodeID = backendNodeID return & p }
5027	func ( p GetPartialAXTreeParams ) WithObjectID ( objectID runtime . RemoteObjectID ) * GetPartialAXTreeParams { p . ObjectID = objectID return & p }
5028	func ( p GetPartialAXTreeParams ) WithFetchRelatives ( fetchRelatives bool ) * GetPartialAXTreeParams { p . FetchRelatives = fetchRelatives return & p }
5029	func ( p * SetTimeDomainParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetTimeDomain , p , nil ) }
5030	func ( p ProfileSnapshotParams ) WithClipRect ( clipRect * dom . Rect ) * ProfileSnapshotParams { p . ClipRect = clipRect return & p }
5031	func ( p * ReleaseSnapshotParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandReleaseSnapshot , p , nil ) }
5032	func ( p * ClearObjectStoreParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandClearObjectStore , p , nil ) }
5033	func ( p * DeleteDatabaseParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDeleteDatabase , p , nil ) }
5034	func ( p * DeleteObjectStoreEntriesParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDeleteObjectStoreEntries , p , nil ) }
5035	func ( p RequestDataParams ) WithKeyRange ( keyRange * KeyRange ) * RequestDataParams { p . KeyRange = keyRange return & p }
5036	func ( p * SetSamplingIntervalParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetSamplingInterval , p , nil ) }
5037	func ( p * StartParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStart , nil , nil ) }
5038	func ( p StartPreciseCoverageParams ) WithCallCount ( callCount bool ) * StartPreciseCoverageParams { p . CallCount = callCount return & p }
5039	func ( p StartPreciseCoverageParams ) WithDetailed ( detailed bool ) * StartPreciseCoverageParams { p . Detailed = detailed return & p }
5040	func ( p * StartPreciseCoverageParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStartPreciseCoverage , p , nil ) }
5041	func ( p * StartTypeProfileParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStartTypeProfile , nil , nil ) }
5042	func ( p * StopPreciseCoverageParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStopPreciseCoverage , nil , nil ) }
5043	func ( p * StopTypeProfileParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStopTypeProfile , nil , nil ) }
5044	func ( p * SetIgnoreCertificateErrorsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetIgnoreCertificateErrors , p , nil ) }
5045	func ( p * AddInspectedHeapObjectParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandAddInspectedHeapObject , p , nil ) }
5046	func ( p * CollectGarbageParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandCollectGarbage , nil , nil ) }
5047	func ( p StartSamplingParams ) WithSamplingInterval ( samplingInterval float64 ) * StartSamplingParams { p . SamplingInterval = samplingInterval return & p }
5048	func ( p * StartTrackingHeapObjectsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStartTrackingHeapObjects , p , nil ) }
5049	func ( p StopTrackingHeapObjectsParams ) WithReportProgress ( reportProgress bool ) * StopTrackingHeapObjectsParams { p . ReportProgress = reportProgress return & p }
5050	func ( p * StopTrackingHeapObjectsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStopTrackingHeapObjects , p , nil ) }
5051	func ( p TakeHeapSnapshotParams ) WithReportProgress ( reportProgress bool ) * TakeHeapSnapshotParams { p . ReportProgress = reportProgress return & p }
5052	func ( p * TakeHeapSnapshotParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandTakeHeapSnapshot , p , nil ) }
5053	func ( p GrantPermissionsParams ) WithBrowserContextID ( browserContextID target . BrowserContextID ) * GrantPermissionsParams { p . BrowserContextID = browserContextID return & p }
5054	func ( p * GrantPermissionsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandGrantPermissions , p , nil ) }
5055	func ( p ResetPermissionsParams ) WithBrowserContextID ( browserContextID target . BrowserContextID ) * ResetPermissionsParams { p . BrowserContextID = browserContextID return & p }
5056	func ( p * ResetPermissionsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandResetPermissions , p , nil ) }
5057	func ( p * CrashParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandCrash , nil , nil ) }
5058	func ( p * CrashGpuProcessParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandCrashGpuProcess , nil , nil ) }
5059	func ( p GetHistogramsParams ) WithQuery ( query string ) * GetHistogramsParams { p . Query = query return & p }
5060	func ( p GetWindowForTargetParams ) WithTargetID ( targetID target . ID ) * GetWindowForTargetParams { p . TargetID = targetID return & p }
5061	func ( p * SetWindowBoundsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetWindowBounds , p , nil ) }
5062	func ( p SetDockTileParams ) WithImage ( image string ) * SetDockTileParams { p . Image = image return & p }
5063	func ( p * SetDockTileParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetDockTile , p , nil ) }
5064	func ( p * DeleteCacheParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDeleteCache , p , nil ) }
5065	func ( p * DeleteEntryParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDeleteEntry , p , nil ) }
5066	func ( p RequestEntriesParams ) WithPathFilter ( pathFilter string ) * RequestEntriesParams { p . PathFilter = pathFilter return & p }
5067	func ( p * DiscardSearchResultsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDiscardSearchResults , p , nil ) }
5068	func ( p * FocusParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandFocus , p , nil ) }
5069	func ( p * MarkUndoableStateParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandMarkUndoableState , nil , nil ) }
5070	func ( p PerformSearchParams ) WithIncludeUserAgentShadowDOM ( includeUserAgentShadowDOM bool ) * PerformSearchParams { p . IncludeUserAgentShadowDOM = includeUserAgentShadowDOM return & p }
5071	func ( p * RedoParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandRedo , nil , nil ) }
5072	func ( p * RemoveAttributeParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandRemoveAttribute , p , nil ) }
5073	func ( p * RemoveNodeParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandRemoveNode , p , nil ) }
5074	func ( p * RequestChildNodesParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandRequestChildNodes , p , nil ) }
5075	func ( p ResolveNodeParams ) WithNodeID ( nodeID cdp . NodeID ) * ResolveNodeParams { p . NodeID = nodeID return & p }
5076	func ( p ResolveNodeParams ) WithBackendNodeID ( backendNodeID cdp . BackendNodeID ) * ResolveNodeParams { p . BackendNodeID = backendNodeID return & p }
5077	func ( p ResolveNodeParams ) WithExecutionContextID ( executionContextID runtime . ExecutionContextID ) * ResolveNodeParams { p . ExecutionContextID = executionContextID return & p }
5078	func ( p * SetAttributeValueParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetAttributeValue , p , nil ) }
5079	func ( p SetAttributesAsTextParams ) WithName ( name string ) * SetAttributesAsTextParams { p . Name = name return & p }
5080	func ( p * SetAttributesAsTextParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetAttributesAsText , p , nil ) }
5081	func ( p * SetFileInputFilesParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetFileInputFiles , p , nil ) }
5082	func ( p * SetInspectedNodeParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetInspectedNode , p , nil ) }
5083	func ( p * SetNodeValueParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetNodeValue , p , nil ) }
5084	func ( p * SetOuterHTMLParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetOuterHTML , p , nil ) }
5085	func ( p * UndoParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandUndo , nil , nil ) }
5086	func ( p * ForcePseudoStateParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandForcePseudoState , p , nil ) }
5087	func ( p * SetEffectivePropertyValueForNodeParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetEffectivePropertyValueForNode , p , nil ) }
5088	func ( p * StartRuleUsageTrackingParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStartRuleUsageTracking , nil , nil ) }
5089	func ( p * CloseParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandClose , p , nil ) }
5090	func ( p * ClearDataForOriginParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandClearDataForOrigin , p , nil ) }
5091	func ( p * TrackCacheStorageForOriginParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandTrackCacheStorageForOrigin , p , nil ) }
5092	func ( p * TrackIndexedDBForOriginParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandTrackIndexedDBForOrigin , p , nil ) }
5093	func ( p * UntrackCacheStorageForOriginParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandUntrackCacheStorageForOrigin , p , nil ) }
5094	func ( p * UntrackIndexedDBForOriginParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandUntrackIndexedDBForOrigin , p , nil ) }
5095	func ( p * HideHighlightParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandHideHighlight , nil , nil ) }
5096	func ( p * HighlightFrameParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandHighlightFrame , p , nil ) }
5097	func ( p HighlightNodeParams ) WithNodeID ( nodeID cdp . NodeID ) * HighlightNodeParams { p . NodeID = nodeID return & p }
5098	func ( p HighlightNodeParams ) WithBackendNodeID ( backendNodeID cdp . BackendNodeID ) * HighlightNodeParams { p . BackendNodeID = backendNodeID return & p }
5099	func ( p HighlightNodeParams ) WithObjectID ( objectID runtime . RemoteObjectID ) * HighlightNodeParams { p . ObjectID = objectID return & p }
5100	func ( p HighlightNodeParams ) WithSelector ( selector string ) * HighlightNodeParams { p . Selector = selector return & p }
5101	func ( p * HighlightNodeParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandHighlightNode , p , nil ) }
5102	func ( p * HighlightQuadParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandHighlightQuad , p , nil ) }
5103	func ( p * HighlightRectParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandHighlightRect , p , nil ) }
5104	func ( p SetInspectModeParams ) WithHighlightConfig ( highlightConfig * HighlightConfig ) * SetInspectModeParams { p . HighlightConfig = highlightConfig return & p }
5105	func ( p * SetInspectModeParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetInspectMode , p , nil ) }
5106	func ( p * SetShowAdHighlightsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetShowAdHighlights , p , nil ) }
5107	func ( p SetPausedInDebuggerMessageParams ) WithMessage ( message string ) * SetPausedInDebuggerMessageParams { p . Message = message return & p }
5108	func ( p * SetPausedInDebuggerMessageParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetPausedInDebuggerMessage , p , nil ) }
5109	func ( p * SetShowDebugBordersParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetShowDebugBorders , p , nil ) }
5110	func ( p * SetShowFPSCounterParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetShowFPSCounter , p , nil ) }
5111	func ( p * SetShowPaintRectsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetShowPaintRects , p , nil ) }
5112	func ( p * SetShowScrollBottleneckRectsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetShowScrollBottleneckRects , p , nil ) }
5113	func ( p * SetShowHitTestBordersParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetShowHitTestBorders , p , nil ) }
5114	func ( p * SetShowViewportSizeOnResizeParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetShowViewportSizeOnResize , p , nil ) }
5115	func ( p * ClearBrowserCacheParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandClearBrowserCache , nil , nil ) }
5116	func ( p * ClearBrowserCookiesParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandClearBrowserCookies , nil , nil ) }
5117	func ( p ContinueInterceptedRequestParams ) WithErrorReason ( errorReason ErrorReason ) * ContinueInterceptedRequestParams { p . ErrorReason = errorReason return & p }
5118	func ( p ContinueInterceptedRequestParams ) WithRawResponse ( rawResponse string ) * ContinueInterceptedRequestParams { p . RawResponse = rawResponse return & p }
5119	func ( p ContinueInterceptedRequestParams ) WithURL ( url string ) * ContinueInterceptedRequestParams { p . URL = url return & p }
5120	func ( p ContinueInterceptedRequestParams ) WithMethod ( method string ) * ContinueInterceptedRequestParams { p . Method = method return & p }
5121	func ( p ContinueInterceptedRequestParams ) WithPostData ( postData string ) * ContinueInterceptedRequestParams { p . PostData = postData return & p }
5122	func ( p ContinueInterceptedRequestParams ) WithHeaders ( headers Headers ) * ContinueInterceptedRequestParams { p . Headers = headers return & p }
5123	func ( p ContinueInterceptedRequestParams ) WithAuthChallengeResponse ( authChallengeResponse * AuthChallengeResponse ) * ContinueInterceptedRequestParams { p . AuthChallengeResponse = authChallengeResponse return & p }
5124	func ( p * ContinueInterceptedRequestParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandContinueInterceptedRequest , p , nil ) }
5125	func ( p DeleteCookiesParams ) WithURL ( url string ) * DeleteCookiesParams { p . URL = url return & p }
5126	func ( p DeleteCookiesParams ) WithDomain ( domain string ) * DeleteCookiesParams { p . Domain = domain return & p }
5127	func ( p DeleteCookiesParams ) WithPath ( path string ) * DeleteCookiesParams { p . Path = path return & p }
5128	func ( p * DeleteCookiesParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDeleteCookies , p , nil ) }
5129	func ( p EmulateNetworkConditionsParams ) WithConnectionType ( connectionType ConnectionType ) * EmulateNetworkConditionsParams { p . ConnectionType = connectionType return & p }
5130	func ( p * EmulateNetworkConditionsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandEmulateNetworkConditions , p , nil ) }
5131	func ( p * EnableParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandEnable , p , nil ) }
5132	func ( p GetCookiesParams ) WithUrls ( urls [ ] string ) * GetCookiesParams { p . Urls = urls return & p }
5133	func ( p * ReplayXHRParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandReplayXHR , p , nil ) }
5134	func ( p * SetBlockedURLSParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetBlockedURLS , p , nil ) }
5135	func ( p * SetBypassServiceWorkerParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetBypassServiceWorker , p , nil ) }
5136	func ( p * SetCacheDisabledParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetCacheDisabled , p , nil ) }
5137	func ( p SetCookieParams ) WithURL ( url string ) * SetCookieParams { p . URL = url return & p }
5138	func ( p SetCookieParams ) WithDomain ( domain string ) * SetCookieParams { p . Domain = domain return & p }
5139	func ( p SetCookieParams ) WithPath ( path string ) * SetCookieParams { p . Path = path return & p }
5140	func ( p SetCookieParams ) WithSecure ( secure bool ) * SetCookieParams { p . Secure = secure return & p }
5141	func ( p SetCookieParams ) WithHTTPOnly ( httpOnly bool ) * SetCookieParams { p . HTTPOnly = httpOnly return & p }
5142	func ( p SetCookieParams ) WithSameSite ( sameSite CookieSameSite ) * SetCookieParams { p . SameSite = sameSite return & p }
5143	func ( p SetCookieParams ) WithExpires ( expires * cdp . TimeSinceEpoch ) * SetCookieParams { p . Expires = expires return & p }
5144	func ( p * SetCookiesParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetCookies , p , nil ) }
5145	func ( p * SetDataSizeLimitsForTestParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetDataSizeLimitsForTest , p , nil ) }
5146	func ( p * SetExtraHTTPHeadersParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetExtraHTTPHeaders , p , nil ) }
5147	func ( p * SetRequestInterceptionParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetRequestInterception , p , nil ) }
5148	func ( p * ClearDeviceMetricsOverrideParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandClearDeviceMetricsOverride , nil , nil ) }
5149	func ( p * ClearGeolocationOverrideParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandClearGeolocationOverride , nil , nil ) }
5150	func ( p * ResetPageScaleFactorParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandResetPageScaleFactor , nil , nil ) }
5151	func ( p * SetFocusEmulationEnabledParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetFocusEmulationEnabled , p , nil ) }
5152	func ( p * SetCPUThrottlingRateParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetCPUThrottlingRate , p , nil ) }
5153	func ( p SetDefaultBackgroundColorOverrideParams ) WithColor ( color * cdp . RGBA ) * SetDefaultBackgroundColorOverrideParams { p . Color = color return & p }
5154	func ( p * SetDefaultBackgroundColorOverrideParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetDefaultBackgroundColorOverride , p , nil ) }
5155	func ( p SetDeviceMetricsOverrideParams ) WithScale ( scale float64 ) * SetDeviceMetricsOverrideParams { p . Scale = scale return & p }
5156	func ( p SetDeviceMetricsOverrideParams ) WithDontSetVisibleSize ( dontSetVisibleSize bool ) * SetDeviceMetricsOverrideParams { p . DontSetVisibleSize = dontSetVisibleSize return & p }
5157	func ( p SetDeviceMetricsOverrideParams ) WithScreenOrientation ( screenOrientation * ScreenOrientation ) * SetDeviceMetricsOverrideParams { p . ScreenOrientation = screenOrientation return & p }
5158	func ( p * SetDeviceMetricsOverrideParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetDeviceMetricsOverride , p , nil ) }
5159	func ( p * SetScrollbarsHiddenParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetScrollbarsHidden , p , nil ) }
5160	func ( p * SetDocumentCookieDisabledParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetDocumentCookieDisabled , p , nil ) }
5161	func ( p * SetEmitTouchEventsForMouseParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetEmitTouchEventsForMouse , p , nil ) }
5162	func ( p * SetEmulatedMediaParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetEmulatedMedia , p , nil ) }
5163	func ( p SetGeolocationOverrideParams ) WithLatitude ( latitude float64 ) * SetGeolocationOverrideParams { p . Latitude = latitude return & p }
5164	func ( p SetGeolocationOverrideParams ) WithLongitude ( longitude float64 ) * SetGeolocationOverrideParams { p . Longitude = longitude return & p }
5165	func ( p SetGeolocationOverrideParams ) WithAccuracy ( accuracy float64 ) * SetGeolocationOverrideParams { p . Accuracy = accuracy return & p }
5166	func ( p * SetGeolocationOverrideParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetGeolocationOverride , p , nil ) }
5167	func ( p * SetPageScaleFactorParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetPageScaleFactor , p , nil ) }
5168	func ( p * SetScriptExecutionDisabledParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetScriptExecutionDisabled , p , nil ) }
5169	func ( p SetTouchEmulationEnabledParams ) WithMaxTouchPoints ( maxTouchPoints int64 ) * SetTouchEmulationEnabledParams { p . MaxTouchPoints = maxTouchPoints return & p }
5170	func ( p * SetTouchEmulationEnabledParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetTouchEmulationEnabled , p , nil ) }
5171	func ( p SetVirtualTimePolicyParams ) WithBudget ( budget float64 ) * SetVirtualTimePolicyParams { p . Budget = budget return & p }
5172	func ( p SetVirtualTimePolicyParams ) WithMaxVirtualTimeTaskStarvationCount ( maxVirtualTimeTaskStarvationCount int64 ) * SetVirtualTimePolicyParams { p . MaxVirtualTimeTaskStarvationCount = maxVirtualTimeTaskStarvationCount return & p }
5173	func ( p SetVirtualTimePolicyParams ) WithWaitForNavigation ( waitForNavigation bool ) * SetVirtualTimePolicyParams { p . WaitForNavigation = waitForNavigation return & p }
5174	func ( p SetUserAgentOverrideParams ) WithAcceptLanguage ( acceptLanguage string ) * SetUserAgentOverrideParams { p . AcceptLanguage = acceptLanguage return & p }
5175	func ( p SetUserAgentOverrideParams ) WithPlatform ( platform string ) * SetUserAgentOverrideParams { p . Platform = platform return & p }
5176	func ( p * SetUserAgentOverrideParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetUserAgentOverride , p , nil ) }
5177	func ( p * DispatchKeyEventParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDispatchKeyEvent , p , nil ) }
5178	func ( p * InsertTextParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandInsertText , p , nil ) }
5179	func ( p DispatchMouseEventParams ) WithButtons ( buttons int64 ) * DispatchMouseEventParams { p . Buttons = buttons return & p }
5180	func ( p * DispatchMouseEventParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDispatchMouseEvent , p , nil ) }
5181	func ( p * DispatchTouchEventParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDispatchTouchEvent , p , nil ) }
5182	func ( p * EmulateTouchFromMouseEventParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandEmulateTouchFromMouseEvent , p , nil ) }
5183	func ( p * SetIgnoreInputEventsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetIgnoreInputEvents , p , nil ) }
5184	func ( p * SynthesizePinchGestureParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSynthesizePinchGesture , p , nil ) }
5185	func ( p SynthesizeScrollGestureParams ) WithXOverscroll ( xOverscroll float64 ) * SynthesizeScrollGestureParams { p . XOverscroll = xOverscroll return & p }
5186	func ( p SynthesizeScrollGestureParams ) WithYOverscroll ( yOverscroll float64 ) * SynthesizeScrollGestureParams { p . YOverscroll = yOverscroll return & p }
5187	func ( p * SynthesizeScrollGestureParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSynthesizeScrollGesture , p , nil ) }
5188	func ( p * SynthesizeTapGestureParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSynthesizeTapGesture , p , nil ) }
5189	func ( t MethodType ) Domain ( ) string { return string ( t [ : strings . IndexByte ( string ( t ) , '.' ) ] ) }
5190	func ( p GetEventListenersParams ) WithDepth ( depth int64 ) * GetEventListenersParams { p . Depth = depth return & p }
5191	func ( p * RemoveDOMBreakpointParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandRemoveDOMBreakpoint , p , nil ) }
5192	func ( p RemoveEventListenerBreakpointParams ) WithTargetName ( targetName string ) * RemoveEventListenerBreakpointParams { p . TargetName = targetName return & p }
5193	func ( p * RemoveEventListenerBreakpointParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandRemoveEventListenerBreakpoint , p , nil ) }
5194	func ( p * RemoveInstrumentationBreakpointParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandRemoveInstrumentationBreakpoint , p , nil ) }
5195	func ( p * RemoveXHRBreakpointParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandRemoveXHRBreakpoint , p , nil ) }
5196	func ( p * SetDOMBreakpointParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetDOMBreakpoint , p , nil ) }
5197	func ( p * SetEventListenerBreakpointParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetEventListenerBreakpoint , p , nil ) }
5198	func ( p * SetInstrumentationBreakpointParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetInstrumentationBreakpoint , p , nil ) }
5199	func ( p * SetXHRBreakpointParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetXHRBreakpoint , p , nil ) }
5200	func WithExecutor ( parent context . Context , executor Executor ) context . Context { return context . WithValue ( parent , executorKey , executor ) }
5201	func Execute ( ctx context . Context , method string , params easyjson . Marshaler , res easyjson . Unmarshaler ) error { if executor := ctx . Value ( executorKey ) ; executor != nil { return executor . ( Executor ) . Execute ( ctx , method , params , res ) } return ErrInvalidContext }
5202	func ( n * Node ) AttributeValue ( name string ) string { n . RLock ( ) defer n . RUnlock ( ) for i := 0 ; i < len ( n . Attributes ) ; i += 2 { if n . Attributes [ i ] == name { return n . Attributes [ i + 1 ] } } return "" }
5203	func ( n * Node ) xpath ( stopAtDocument , stopAtID bool ) string { n . RLock ( ) defer n . RUnlock ( ) p := "" pos := "" id := n . AttributeValue ( "id" ) switch { case n . Parent == nil : return n . LocalName case stopAtDocument && n . NodeType == NodeTypeDocument : return "" case stopAtID && id != "" : p = "/" pos = `[@id='` + id + `']` case n . Parent != nil : var i int var found bool n . Parent . RLock ( ) for j := 0 ; j < len ( n . Parent . Children ) ; j ++ { if n . Parent . Children [ j ] . LocalName == n . LocalName { i ++ } if n . Parent . Children [ j ] . NodeID == n . NodeID { found = true break } } n . Parent . RUnlock ( ) if found { pos = "[" + strconv . Itoa ( i ) + "]" } p = n . Parent . xpath ( stopAtDocument , stopAtID ) } return p + "/" + n . LocalName + pos }
5204	func ( t NodeType ) String ( ) string { switch t { case NodeTypeElement : return "Element" case NodeTypeAttribute : return "Attribute" case NodeTypeText : return "Text" case NodeTypeCDATA : return "CDATA" case NodeTypeEntityReference : return "EntityReference" case NodeTypeEntity : return "Entity" case NodeTypeProcessingInstruction : return "ProcessingInstruction" case NodeTypeComment : return "Comment" case NodeTypeDocument : return "Document" case NodeTypeDocumentType : return "DocumentType" case NodeTypeDocumentFragment : return "DocumentFragment" case NodeTypeNotation : return "Notation" } return fmt . Sprintf ( "NodeType(%d)" , t ) }
5205	func ( p * SetSinkToUseParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetSinkToUse , p , nil ) }
5206	func ( p * StartTabMirroringParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStartTabMirroring , p , nil ) }
5207	func ( p * StopCastingParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStopCasting , p , nil ) }
5208	func ( p * StartObservingParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStartObserving , p , nil ) }
5209	func ( p * StopObservingParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStopObserving , p , nil ) }
5210	func ( p * SetRecordingParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetRecording , p , nil ) }
5211	func ( p * ClearEventsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandClearEvents , p , nil ) }
5212	func ( p CallFunctionOnParams ) WithObjectID ( objectID RemoteObjectID ) * CallFunctionOnParams { p . ObjectID = objectID return & p }
5213	func ( p CallFunctionOnParams ) WithArguments ( arguments [ ] * CallArgument ) * CallFunctionOnParams { p . Arguments = arguments return & p }
5214	func ( p CallFunctionOnParams ) WithExecutionContextID ( executionContextID ExecutionContextID ) * CallFunctionOnParams { p . ExecutionContextID = executionContextID return & p }
5215	func ( p CallFunctionOnParams ) WithObjectGroup ( objectGroup string ) * CallFunctionOnParams { p . ObjectGroup = objectGroup return & p }
5216	func ( p * DiscardConsoleEntriesParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDiscardConsoleEntries , nil , nil ) }
5217	func ( p EvaluateParams ) WithContextID ( contextID ExecutionContextID ) * EvaluateParams { p . ContextID = contextID return & p }
5218	func ( p GetPropertiesParams ) WithOwnProperties ( ownProperties bool ) * GetPropertiesParams { p . OwnProperties = ownProperties return & p }
5219	func ( p GetPropertiesParams ) WithGeneratePreview ( generatePreview bool ) * GetPropertiesParams { p . GeneratePreview = generatePreview return & p }
5220	func ( p GlobalLexicalScopeNamesParams ) WithExecutionContextID ( executionContextID ExecutionContextID ) * GlobalLexicalScopeNamesParams { p . ExecutionContextID = executionContextID return & p }
5221	func ( p QueryObjectsParams ) WithObjectGroup ( objectGroup string ) * QueryObjectsParams { p . ObjectGroup = objectGroup return & p }
5222	func ( p * ReleaseObjectParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandReleaseObject , p , nil ) }
5223	func ( p * ReleaseObjectGroupParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandReleaseObjectGroup , p , nil ) }
5224	func ( p * RunIfWaitingForDebuggerParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandRunIfWaitingForDebugger , nil , nil ) }
5225	func ( p * SetCustomObjectFormatterEnabledParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetCustomObjectFormatterEnabled , p , nil ) }
5226	func ( p * SetMaxCallStackSizeToCaptureParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetMaxCallStackSizeToCapture , p , nil ) }
5227	func ( p * TerminateExecutionParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandTerminateExecution , nil , nil ) }
5228	func ( p * AddBindingParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandAddBinding , p , nil ) }
5229	func ( p * RemoveBindingParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandRemoveBinding , p , nil ) }
5230	func ( p * EndParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandEnd , nil , nil ) }
5231	func ( p * RecordClockSyncMarkerParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandRecordClockSyncMarker , p , nil ) }
5232	func ( p StartParams ) WithBufferUsageReportingInterval ( bufferUsageReportingInterval float64 ) * StartParams { p . BufferUsageReportingInterval = bufferUsageReportingInterval return & p }
5233	func ( p BeginFrameParams ) WithNoDisplayUpdates ( noDisplayUpdates bool ) * BeginFrameParams { p . NoDisplayUpdates = noDisplayUpdates return & p }
5234	func ( p BeginFrameParams ) WithScreenshot ( screenshot * ScreenshotParams ) * BeginFrameParams { p . Screenshot = screenshot return & p }
5235	func ( p * BringToFrontParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandBringToFront , nil , nil ) }
5236	func ( p CaptureScreenshotParams ) WithClip ( clip * Viewport ) * CaptureScreenshotParams { p . Clip = clip return & p }
5237	func ( p CaptureScreenshotParams ) WithFromSurface ( fromSurface bool ) * CaptureScreenshotParams { p . FromSurface = fromSurface return & p }
5238	func ( p CreateIsolatedWorldParams ) WithWorldName ( worldName string ) * CreateIsolatedWorldParams { p . WorldName = worldName return & p }
5239	func ( p CreateIsolatedWorldParams ) WithGrantUniveralAccess ( grantUniveralAccess bool ) * CreateIsolatedWorldParams { p . GrantUniveralAccess = grantUniveralAccess return & p }
5240	func ( p * ResetNavigationHistoryParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandResetNavigationHistory , nil , nil ) }
5241	func ( p HandleJavaScriptDialogParams ) WithPromptText ( promptText string ) * HandleJavaScriptDialogParams { p . PromptText = promptText return & p }
5242	func ( p * HandleJavaScriptDialogParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandHandleJavaScriptDialog , p , nil ) }
5243	func ( p NavigateParams ) WithReferrer ( referrer string ) * NavigateParams { p . Referrer = referrer return & p }
5244	func ( p NavigateParams ) WithTransitionType ( transitionType TransitionType ) * NavigateParams { p . TransitionType = transitionType return & p }
5245	func ( p NavigateParams ) WithFrameID ( frameID cdp . FrameID ) * NavigateParams { p . FrameID = frameID return & p }
5246	func ( p * NavigateToHistoryEntryParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandNavigateToHistoryEntry , p , nil ) }
5247	func ( p PrintToPDFParams ) WithLandscape ( landscape bool ) * PrintToPDFParams { p . Landscape = landscape return & p }
5248	func ( p PrintToPDFParams ) WithDisplayHeaderFooter ( displayHeaderFooter bool ) * PrintToPDFParams { p . DisplayHeaderFooter = displayHeaderFooter return & p }
5249	func ( p PrintToPDFParams ) WithPrintBackground ( printBackground bool ) * PrintToPDFParams { p . PrintBackground = printBackground return & p }
5250	func ( p PrintToPDFParams ) WithScale ( scale float64 ) * PrintToPDFParams { p . Scale = scale return & p }
5251	func ( p PrintToPDFParams ) WithPaperWidth ( paperWidth float64 ) * PrintToPDFParams { p . PaperWidth = paperWidth return & p }
5252	func ( p PrintToPDFParams ) WithPaperHeight ( paperHeight float64 ) * PrintToPDFParams { p . PaperHeight = paperHeight return & p }
5253	func ( p PrintToPDFParams ) WithIgnoreInvalidPageRanges ( ignoreInvalidPageRanges bool ) * PrintToPDFParams { p . IgnoreInvalidPageRanges = ignoreInvalidPageRanges return & p }
5254	func ( p PrintToPDFParams ) WithFooterTemplate ( footerTemplate string ) * PrintToPDFParams { p . FooterTemplate = footerTemplate return & p }
5255	func ( p PrintToPDFParams ) WithPreferCSSPageSize ( preferCSSPageSize bool ) * PrintToPDFParams { p . PreferCSSPageSize = preferCSSPageSize return & p }
5256	func ( p ReloadParams ) WithScriptToEvaluateOnLoad ( scriptToEvaluateOnLoad string ) * ReloadParams { p . ScriptToEvaluateOnLoad = scriptToEvaluateOnLoad return & p }
5257	func ( p * ReloadParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandReload , p , nil ) }
5258	func ( p * RemoveScriptToEvaluateOnNewDocumentParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandRemoveScriptToEvaluateOnNewDocument , p , nil ) }
5259	func ( p * ScreencastFrameAckParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandScreencastFrameAck , p , nil ) }
5260	func ( p * SetAdBlockingEnabledParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetAdBlockingEnabled , p , nil ) }
5261	func ( p * SetBypassCSPParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetBypassCSP , p , nil ) }
5262	func ( p * SetFontFamiliesParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetFontFamilies , p , nil ) }
5263	func ( p * SetFontSizesParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetFontSizes , p , nil ) }
5264	func ( p * SetDocumentContentParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetDocumentContent , p , nil ) }
5265	func ( p SetDownloadBehaviorParams ) WithDownloadPath ( downloadPath string ) * SetDownloadBehaviorParams { p . DownloadPath = downloadPath return & p }
5266	func ( p * SetDownloadBehaviorParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetDownloadBehavior , p , nil ) }
5267	func ( p * SetLifecycleEventsEnabledParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetLifecycleEventsEnabled , p , nil ) }
5268	func ( p StartScreencastParams ) WithFormat ( format ScreencastFormat ) * StartScreencastParams { p . Format = format return & p }
5269	func ( p StartScreencastParams ) WithMaxWidth ( maxWidth int64 ) * StartScreencastParams { p . MaxWidth = maxWidth return & p }
5270	func ( p StartScreencastParams ) WithMaxHeight ( maxHeight int64 ) * StartScreencastParams { p . MaxHeight = maxHeight return & p }
5271	func ( p StartScreencastParams ) WithEveryNthFrame ( everyNthFrame int64 ) * StartScreencastParams { p . EveryNthFrame = everyNthFrame return & p }
5272	func ( p * StartScreencastParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStartScreencast , p , nil ) }
5273	func ( p * StopLoadingParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStopLoading , nil , nil ) }
5274	func ( p * SetWebLifecycleStateParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetWebLifecycleState , p , nil ) }
5275	func ( p * StopScreencastParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStopScreencast , nil , nil ) }
5276	func ( p * SetProduceCompilationCacheParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetProduceCompilationCache , p , nil ) }
5277	func ( p * AddCompilationCacheParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandAddCompilationCache , p , nil ) }
5278	func ( p * ClearCompilationCacheParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandClearCompilationCache , nil , nil ) }
5279	func ( p GenerateTestReportParams ) WithGroup ( group string ) * GenerateTestReportParams { p . Group = group return & p }
5280	func ( p * WaitForDebuggerParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandWaitForDebugger , nil , nil ) }
5281	func ( p * ActivateTargetParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandActivateTarget , p , nil ) }
5282	func ( p ExposeDevToolsProtocolParams ) WithBindingName ( bindingName string ) * ExposeDevToolsProtocolParams { p . BindingName = bindingName return & p }
5283	func ( p * ExposeDevToolsProtocolParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandExposeDevToolsProtocol , p , nil ) }
5284	func ( p CreateTargetParams ) WithBrowserContextID ( browserContextID BrowserContextID ) * CreateTargetParams { p . BrowserContextID = browserContextID return & p }
5285	func ( p DetachFromTargetParams ) WithSessionID ( sessionID SessionID ) * DetachFromTargetParams { p . SessionID = sessionID return & p }
5286	func ( p * DetachFromTargetParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDetachFromTarget , p , nil ) }
5287	func ( p * DisposeBrowserContextParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandDisposeBrowserContext , p , nil ) }
5288	func ( p SendMessageToTargetParams ) WithSessionID ( sessionID SessionID ) * SendMessageToTargetParams { p . SessionID = sessionID return & p }
5289	func ( p * SendMessageToTargetParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSendMessageToTarget , p , nil ) }
5290	func ( p * SetAutoAttachParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetAutoAttach , p , nil ) }
5291	func ( p * SetDiscoverTargetsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetDiscoverTargets , p , nil ) }
5292	func ( p * SetRemoteLocationsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetRemoteLocations , p , nil ) }
5293	func ( p EnableParams ) WithPatterns ( patterns [ ] * RequestPattern ) * EnableParams { p . Patterns = patterns return & p }
5294	func ( p EnableParams ) WithHandleAuthRequests ( handleAuthRequests bool ) * EnableParams { p . HandleAuthRequests = handleAuthRequests return & p }
5295	func ( p * FailRequestParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandFailRequest , p , nil ) }
5296	func ( p FulfillRequestParams ) WithBody ( body string ) * FulfillRequestParams { p . Body = body return & p }
5297	func ( p FulfillRequestParams ) WithResponsePhrase ( responsePhrase string ) * FulfillRequestParams { p . ResponsePhrase = responsePhrase return & p }
5298	func ( p * FulfillRequestParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandFulfillRequest , p , nil ) }
5299	func ( p ContinueRequestParams ) WithURL ( url string ) * ContinueRequestParams { p . URL = url return & p }
5300	func ( p ContinueRequestParams ) WithMethod ( method string ) * ContinueRequestParams { p . Method = method return & p }
5301	func ( p ContinueRequestParams ) WithPostData ( postData string ) * ContinueRequestParams { p . PostData = postData return & p }
5302	func ( p ContinueRequestParams ) WithHeaders ( headers [ ] * HeaderEntry ) * ContinueRequestParams { p . Headers = headers return & p }
5303	func ( p * ContinueRequestParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandContinueRequest , p , nil ) }
5304	func ( p * ContinueWithAuthParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandContinueWithAuth , p , nil ) }
5305	func ( p * ContinueToLocationParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandContinueToLocation , p , nil ) }
5306	func ( p EvaluateOnCallFrameParams ) WithIncludeCommandLineAPI ( includeCommandLineAPI bool ) * EvaluateOnCallFrameParams { p . IncludeCommandLineAPI = includeCommandLineAPI return & p }
5307	func ( p * PauseParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandPause , nil , nil ) }
5308	func ( p * PauseOnAsyncCallParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandPauseOnAsyncCall , p , nil ) }
5309	func ( p * RemoveBreakpointParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandRemoveBreakpoint , p , nil ) }
5310	func ( p * ResumeParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandResume , nil , nil ) }
5311	func ( p * SetAsyncCallStackDepthParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetAsyncCallStackDepth , p , nil ) }
5312	func ( p * SetBlackboxPatternsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetBlackboxPatterns , p , nil ) }
5313	func ( p * SetBlackboxedRangesParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetBlackboxedRanges , p , nil ) }
5314	func ( p SetBreakpointByURLParams ) WithURL ( url string ) * SetBreakpointByURLParams { p . URL = url return & p }
5315	func ( p SetBreakpointByURLParams ) WithURLRegex ( urlRegex string ) * SetBreakpointByURLParams { p . URLRegex = urlRegex return & p }
5316	func ( p SetBreakpointByURLParams ) WithScriptHash ( scriptHash string ) * SetBreakpointByURLParams { p . ScriptHash = scriptHash return & p }
5317	func ( p SetBreakpointByURLParams ) WithColumnNumber ( columnNumber int64 ) * SetBreakpointByURLParams { p . ColumnNumber = columnNumber return & p }
5318	func ( p SetBreakpointOnFunctionCallParams ) WithCondition ( condition string ) * SetBreakpointOnFunctionCallParams { p . Condition = condition return & p }
5319	func ( p * SetBreakpointsActiveParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetBreakpointsActive , p , nil ) }
5320	func ( p * SetPauseOnExceptionsParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetPauseOnExceptions , p , nil ) }
5321	func ( p * SetReturnValueParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetReturnValue , p , nil ) }
5322	func ( p SetScriptSourceParams ) WithDryRun ( dryRun bool ) * SetScriptSourceParams { p . DryRun = dryRun return & p }
5323	func ( p * SetSkipAllPausesParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetSkipAllPauses , p , nil ) }
5324	func ( p * SetVariableValueParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandSetVariableValue , p , nil ) }
5325	func ( p StepIntoParams ) WithBreakOnAsyncCall ( breakOnAsyncCall bool ) * StepIntoParams { p . BreakOnAsyncCall = breakOnAsyncCall return & p }
5326	func ( p * StepIntoParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStepInto , p , nil ) }
5327	func ( p * StepOutParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStepOut , nil , nil ) }
5328	func ( p * StepOverParams ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , CommandStepOver , nil , nil ) }
5329	func ( nb * NotifyBundle ) Listen ( n Network , a ma . Multiaddr ) { if nb . ListenF != nil { nb . ListenF ( n , a ) } }
5330	func ( nb * NotifyBundle ) ListenClose ( n Network , a ma . Multiaddr ) { if nb . ListenCloseF != nil { nb . ListenCloseF ( n , a ) } }
5331	func ( nb * NotifyBundle ) Connected ( n Network , c Conn ) { if nb . ConnectedF != nil { nb . ConnectedF ( n , c ) } }
5332	func ( nb * NotifyBundle ) Disconnected ( n Network , c Conn ) { if nb . DisconnectedF != nil { nb . DisconnectedF ( n , c ) } }
5333	func ( nb * NotifyBundle ) OpenedStream ( n Network , s Stream ) { if nb . OpenedStreamF != nil { nb . OpenedStreamF ( n , s ) } }
5334	func ( nb * NotifyBundle ) ClosedStream ( n Network , s Stream ) { if nb . ClosedStreamF != nil { nb . ClosedStreamF ( n , s ) } }
5335	func WithNoDial ( ctx context . Context , reason string ) context . Context { return context . WithValue ( ctx , noDial , reason ) }
5336	func GetNoDial ( ctx context . Context ) ( nodial bool , reason string ) { v := ctx . Value ( noDial ) if v != nil { return true , v . ( string ) } return false , "" }
5337	func WithDialPeerTimeout ( ctx context . Context , timeout time . Duration ) context . Context { return context . WithValue ( ctx , dialPeerTimeoutCtxKey { } , timeout ) }
5338	func ( drv * Driver ) Open ( name string ) ( driver . Conn , error ) { conn , err := drv . Driver . Open ( name ) if err != nil { return conn , err } wrapped := & Conn { conn , drv . hooks } if isExecer ( conn ) && isQueryer ( conn ) && isSessionResetter ( conn ) { return & ExecerQueryerContextWithSessionResetter { wrapped , & ExecerContext { wrapped } , & QueryerContext { wrapped } , & SessionResetter { wrapped } } , nil } else if isExecer ( conn ) && isQueryer ( conn ) { return & ExecerQueryerContext { wrapped , & ExecerContext { wrapped } , & QueryerContext { wrapped } } , nil } else if isExecer ( conn ) { return & ExecerContext { wrapped } , nil } else if isQueryer ( conn ) { return & QueryerContext { wrapped } , nil } return wrapped , nil }
5339	func ( f * FixedSizeRingBuf ) Prevpos ( from int ) int { if from >= f . N || from < 0 { return - 2 } if f . Readable == 0 { return - 1 } if from == f . Beg { return - 1 } a0 , a1 , b0 , b1 := f . LegalPos ( ) switch { case from == a0 : return - 1 case from > a0 && from <= a1 : return from - 1 case from == b0 : return a1 case from > b0 && from <= b1 : return from - 1 } return - 1 }
5340	func ( f * FixedSizeRingBuf ) Last ( ) int { if f . Readable == 0 { return - 1 } last := f . Beg + f . Readable - 1 if last < f . N { return last } return last % f . N }
5341	func ( f * FixedSizeRingBuf ) DeleteMostRecentBytes ( n int ) { if n <= 0 { return } if n >= f . Readable { f . Readable = 0 return } f . Readable -= n }
5342	func NewFloat64RingBuf ( maxViewItems int ) * Float64RingBuf { n := maxViewItems r := & Float64RingBuf { N : n , Beg : 0 , Readable : 0 , } r . A = make ( [ ] float64 , n , n ) return r }
5343	func ( b * Float64RingBuf ) TwoContig ( makeCopy bool ) ( first [ ] float64 , second [ ] float64 ) { extent := b . Beg + b . Readable if extent <= b . N { return b . A [ b . Beg : ( b . Beg + b . Readable ) ] , second } return b . A [ b . Beg : b . N ] , b . A [ 0 : ( extent % b . N ) ] }
5344	func ( b * Float64RingBuf ) Earliest ( ) ( v float64 , ok bool ) { if b . Readable == 0 { return } return b . A [ b . Beg ] , true }
5345	func ( b * Float64RingBuf ) Values ( ) [ ] float64 { first , second := b . TwoContig ( false ) if len ( first ) == 0 { return second } if len ( second ) == 0 { return first } out := make ( [ ] float64 , len ( first ) + len ( second ) ) copy ( out , first ) copy ( out [ len ( first ) : ] , second ) return out }
5346	func NewAtomicFixedSizeRingBuf ( maxViewInBytes int ) * AtomicFixedSizeRingBuf { n := maxViewInBytes r := & AtomicFixedSizeRingBuf { Use : 0 , N : n , Beg : 0 , readable : 0 , } r . A [ 0 ] = make ( [ ] byte , n , n ) r . A [ 1 ] = make ( [ ] byte , n , n ) return r }
5347	func ( b * AtomicFixedSizeRingBuf ) Reset ( ) { b . tex . Lock ( ) defer b . tex . Unlock ( ) b . Beg = 0 b . readable = 0 b . Use = 0 }
5348	func NewPointerRingBuf ( sliceN int ) * PointerRingBuf { n := sliceN r := & PointerRingBuf { N : n , Beg : 0 , Readable : 0 , } r . A = make ( [ ] interface { } , n , n ) return r }
5349	func ( b * PointerRingBuf ) TwoContig ( ) ( first [ ] interface { } , second [ ] interface { } ) { extent := b . Beg + b . Readable if extent <= b . N { return b . A [ b . Beg : ( b . Beg + b . Readable ) ] , second } return b . A [ b . Beg : b . N ] , b . A [ 0 : ( extent % b . N ) ] }
5350	func ( r * Reader ) NumPage ( ) int { return int ( r . Trailer ( ) . Key ( "Root" ) . Key ( "Pages" ) . Key ( "Count" ) . Int64 ( ) ) }
5351	func ( p Page ) Font ( name string ) Font { return Font { p . Resources ( ) . Key ( "Font" ) . Key ( name ) } }
5352	func ( f Font ) Width ( code int ) float64 { first := f . FirstChar ( ) last := f . LastChar ( ) if code < first || last < code { return 0 } return f . V . Key ( "Widths" ) . Index ( code - first ) . Float64 ( ) }
5353	func ( f Font ) Encoder ( ) TextEncoding { enc := f . V . Key ( "Encoding" ) switch enc . Kind ( ) { case Name : switch enc . Name ( ) { case "WinAnsiEncoding" : return & byteEncoder { & winAnsiEncoding } case "MacRomanEncoding" : return & byteEncoder { & macRomanEncoding } case "Identity-H" : return & nopEncoder { } default : println ( "unknown encoding" , enc . Name ( ) ) return & nopEncoder { } } case Dict : return & dictEncoder { enc . Key ( "Differences" ) } case Null : default : println ( "unexpected encoding" , enc . String ( ) ) return & nopEncoder { } } toUnicode := f . V . Key ( "ToUnicode" ) if toUnicode . Kind ( ) == Dict { m := readCmap ( toUnicode ) if m == nil { return & nopEncoder { } } return m } return & byteEncoder { & pdfDocEncoding } }
5354	func Interpret ( strm Value , do func ( stk * Stack , op string ) ) { rd := strm . Reader ( ) b := newBuffer ( rd , 0 ) b . allowEOF = true b . allowObjptr = false b . allowStream = false var stk Stack var dicts [ ] dict Reading : for { tok := b . readToken ( ) if tok == io . EOF { break } if kw , ok := tok . ( keyword ) ; ok { switch kw { case "null" , "[" , "]" , "<<" , ">>" : break default : for i := len ( dicts ) - 1 ; i >= 0 ; i -- { if v , ok := dicts [ i ] [ name ( kw ) ] ; ok { stk . Push ( Value { nil , objptr { } , v } ) continue Reading } } do ( & stk , string ( kw ) ) continue case "dict" : stk . Pop ( ) stk . Push ( Value { nil , objptr { } , make ( dict ) } ) continue case "currentdict" : if len ( dicts ) == 0 { panic ( "no current dictionary" ) } stk . Push ( Value { nil , objptr { } , dicts [ len ( dicts ) - 1 ] } ) continue case "begin" : d := stk . Pop ( ) if d . Kind ( ) != Dict { panic ( "cannot begin non-dict" ) } dicts = append ( dicts , d . data . ( dict ) ) continue case "end" : if len ( dicts ) <= 0 { panic ( "mismatched begin/end" ) } dicts = dicts [ : len ( dicts ) - 1 ] continue case "def" : if len ( dicts ) <= 0 { panic ( "def without open dict" ) } val := stk . Pop ( ) key , ok := stk . Pop ( ) . data . ( name ) if ! ok { panic ( "def of non-name" ) } dicts [ len ( dicts ) - 1 ] [ key ] = val . data continue case "pop" : stk . Pop ( ) continue } } b . unreadToken ( tok ) obj := b . readObject ( ) stk . Push ( Value { nil , objptr { } , obj } ) } }
5355	func Open ( file string ) ( * Reader , error ) { f , err := os . Open ( file ) if err != nil { return nil , err } fi , err := f . Stat ( ) if err != nil { f . Close ( ) return nil , err } return NewReader ( f , fi . Size ( ) ) }
5356	func NewReader ( f io . ReaderAt , size int64 ) ( * Reader , error ) { return NewReaderEncrypted ( f , size , nil ) }
5357	func NewReaderEncrypted ( f io . ReaderAt , size int64 , pw func ( ) string ) ( * Reader , error ) { buf := make ( [ ] byte , 10 ) f . ReadAt ( buf , 0 ) if ! bytes . HasPrefix ( buf , [ ] byte ( "%PDF-1." ) ) || buf [ 7 ] < '0' || buf [ 7 ] > '7' || buf [ 8 ] != '\r' && buf [ 8 ] != '\n' { return nil , fmt . Errorf ( "not a PDF file: invalid header" ) } end := size const endChunk = 100 buf = make ( [ ] byte , endChunk ) f . ReadAt ( buf , end - endChunk ) for len ( buf ) > 0 && buf [ len ( buf ) - 1 ] == '\n' || buf [ len ( buf ) - 1 ] == '\r' { buf = buf [ : len ( buf ) - 1 ] } buf = bytes . TrimRight ( buf , "\r\n\t " ) \r \n \t if ! bytes . HasSuffix ( buf , [ ] byte ( "%%EOF" ) ) { return nil , fmt . Errorf ( "not a PDF file: missing %%%%EOF" ) } i := findLastLine ( buf , "startxref" ) if i < 0 { return nil , fmt . Errorf ( "malformed PDF file: missing final startxref" ) } r := & Reader { f : f , end : end , } pos := end - endChunk + int64 ( i ) b := newBuffer ( io . NewSectionReader ( f , pos , end - pos ) , pos ) if b . readToken ( ) != keyword ( "startxref" ) { return nil , fmt . Errorf ( "malformed PDF file: missing startxref" ) } startxref , ok := b . readToken ( ) . ( int64 ) if ! ok { return nil , fmt . Errorf ( "malformed PDF file: startxref not followed by integer" ) } b = newBuffer ( io . NewSectionReader ( r . f , startxref , r . end - startxref ) , startxref ) xref , trailerptr , trailer , err := readXref ( r , b ) if err != nil { return nil , err } r . xref = xref r . trailer = trailer r . trailerptr = trailerptr if trailer [ "Encrypt" ] == nil { return r , nil } err = r . initEncrypt ( "" ) if err == nil { return r , nil } }
5358	func ( r * Reader ) Trailer ( ) Value { return Value { r , r . trailerptr , r . trailer } }
5359	func ( v Value ) Kind ( ) ValueKind { switch v . data . ( type ) { default : return Null case bool : return Bool case int64 : return Integer case float64 : return Real case string : return String case name : return Name case dict : return Dict case array : return Array case stream : return Stream } }
5360	func newBuffer ( r io . Reader , offset int64 ) * buffer { return & buffer { r : r , offset : offset , buf : make ( [ ] byte , 0 , 4096 ) , allowObjptr : true , allowStream : true , } }
5361	func ( r * ResultSet ) Paginate ( perPage , page int ) ( * PaginationInfo , error ) { info := new ( PaginationInfo ) sess := r . Collection . Connection . Session . Copy ( ) count , err := sess . DB ( r . Collection . Database ) . C ( r . Collection . Name ) . Find ( r . Params ) . Count ( ) sess . Close ( ) if err != nil { return info , err } totalPages := int ( math . Ceil ( float64 ( count ) / float64 ( perPage ) ) ) if page < 1 { page = 1 } else if page > totalPages { page = totalPages } skip := ( page - 1 ) * perPage r . Query . Skip ( skip ) . Limit ( perPage ) info . TotalPages = totalPages info . PerPage = perPage info . Current = page info . TotalRecords = count if info . Current < info . TotalPages { info . RecordsOnPage = info . PerPage } else { info . RecordsOnPage = int ( math . Mod ( float64 ( count ) , float64 ( perPage ) ) ) if info . RecordsOnPage == 0 && count > 0 { info . RecordsOnPage = perPage } } return info , nil }
5362	func CascadeDelete ( collection * Collection , doc interface { } ) { if conv , ok := doc . ( interface { GetCascade ( * Collection ) [ ] * CascadeConfig } ) ; ok { toCascade := conv . GetCascade ( collection ) for _ , conf := range toCascade { if len ( conf . ReferenceQuery ) == 0 { id , err := reflections . GetField ( doc , "Id" ) if err != nil { panic ( err ) } conf . ReferenceQuery = [ ] * ReferenceField { & ReferenceField { "_id" , id } } } cascadeDeleteWithConfig ( conf ) } } }
5363	func cascadeDeleteWithConfig ( conf * CascadeConfig ) ( * mgo . ChangeInfo , error ) { switch conf . RelType { case REL_ONE : update := map [ string ] map [ string ] interface { } { "$set" : map [ string ] interface { } { } , } if len ( conf . ThroughProp ) > 0 { update [ "$set" ] [ conf . ThroughProp ] = nil } else { for _ , p := range conf . Properties { update [ "$set" ] [ p ] = nil } } return conf . Collection . Collection ( ) . UpdateAll ( conf . Query , update ) case REL_MANY : update := map [ string ] map [ string ] interface { } { "$pull" : map [ string ] interface { } { } , } q := bson . M { } for _ , f := range conf . ReferenceQuery { q [ f . BsonName ] = f . Value } update [ "$pull" ] [ conf . ThroughProp ] = q return conf . Collection . Collection ( ) . UpdateAll ( conf . Query , update ) } return & mgo . ChangeInfo { } , errors . New ( "Invalid relation type" ) }
5364	func cascadeSaveWithConfig ( conf * CascadeConfig , doc Document ) ( * mgo . ChangeInfo , error ) { data := conf . Data switch conf . RelType { case REL_ONE : if len ( conf . OldQuery ) > 0 { update1 := map [ string ] map [ string ] interface { } { "$set" : map [ string ] interface { } { } , } if len ( conf . ThroughProp ) > 0 { update1 [ "$set" ] [ conf . ThroughProp ] = nil } else { for _ , p := range conf . Properties { update1 [ "$set" ] [ p ] = nil } } ret , err := conf . Collection . Collection ( ) . UpdateAll ( conf . OldQuery , update1 ) if conf . RemoveOnly { return ret , err } } update := make ( map [ string ] interface { } ) if len ( conf . ThroughProp ) > 0 { m := bson . M { } m [ conf . ThroughProp ] = data update [ "$set" ] = m } else { update [ "$set" ] = data } return conf . Collection . Collection ( ) . UpdateAll ( conf . Query , update ) case REL_MANY : update1 := map [ string ] map [ string ] interface { } { "$pull" : map [ string ] interface { } { } , } q := bson . M { } for _ , f := range conf . ReferenceQuery { q [ f . BsonName ] = f . Value } update1 [ "$pull" ] [ conf . ThroughProp ] = q if len ( conf . OldQuery ) > 0 { ret , err := conf . Collection . Collection ( ) . UpdateAll ( conf . OldQuery , update1 ) if conf . RemoveOnly { return ret , err } } conf . Collection . Collection ( ) . UpdateAll ( conf . Query , update1 ) update2 := map [ string ] map [ string ] interface { } { "$push" : map [ string ] interface { } { } , } update2 [ "$push" ] [ conf . ThroughProp ] = data return conf . Collection . Collection ( ) . UpdateAll ( conf . Query , update2 ) } return & mgo . ChangeInfo { } , errors . New ( "Invalid relation type" ) }
5365	func MapFromCascadeProperties ( properties [ ] string , doc Document ) map [ string ] interface { } { data := make ( map [ string ] interface { } ) for _ , prop := range properties { split := strings . Split ( prop , "." ) if len ( split ) == 1 { data [ prop ] , _ = dotaccess . Get ( doc , prop ) } else { actualProp := split [ len ( split ) - 1 ] split := append ( [ ] string { } , split [ : len ( split ) - 1 ] ... ) curData := data for _ , s := range split { if _ , ok := curData [ s ] ; ok { if mapped , ok := curData [ s ] . ( map [ string ] interface { } ) ; ok { curData = mapped } else { panic ( "Cannot access non-map property via dot notation" ) } } else { curData [ s ] = make ( map [ string ] interface { } ) if mapped , ok := curData [ s ] . ( map [ string ] interface { } ) ; ok { curData = mapped } else { panic ( "Cannot access non-map property via dot notation" ) } } } val , _ := dotaccess . Get ( doc , prop ) curData [ actualProp ] = val } } return data }
5366	func ( m * Connection ) Connect ( ) ( err error ) { defer func ( ) { if r := recover ( ) ; r != nil { if e , ok := r . ( error ) ; ok { err = e } else if e , ok := r . ( string ) ; ok { err = errors . New ( e ) } else { err = errors . New ( fmt . Sprint ( r ) ) } } } ( ) if m . Config . DialInfo == nil { if m . Config . DialInfo , err = mgo . ParseURL ( m . Config . ConnectionString ) ; err != nil { panic ( fmt . Sprintf ( "cannot parse given URI %s due to error: %s" , m . Config . ConnectionString , err . Error ( ) ) ) } } session , err := mgo . DialWithInfo ( m . Config . DialInfo ) if err != nil { return err } m . Session = session m . Session . SetMode ( mgo . Monotonic , true ) return nil }
5367	func lowerInitial ( str string ) string { for i , v := range str { return string ( unicode . ToLower ( v ) ) + str [ i + 1 : ] } return "" }
5368	func ( c * Collection ) Find ( query interface { } ) * ResultSet { col := c . Collection ( ) q := col . Find ( query ) resultset := new ( ResultSet ) resultset . Query = q resultset . Params = query resultset . Collection = c return resultset }
5369	func ( c * Client ) RawInformationQuery ( from , to , id , iqType , requestNamespace , body string ) ( string , error ) { const xmlIQ = "<iq from='%s' to='%s' id='%s' type='%s'><query xmlns='%s'>%s</query></iq>" _ , err := fmt . Fprintf ( c . conn , xmlIQ , xmlEscape ( from ) , xmlEscape ( to ) , id , iqType , requestNamespace , body ) return id , err }
5370	func ( o Options ) NewClient ( ) ( * Client , error ) { host := o . Host c , err := connect ( host , o . User , o . Password ) if err != nil { return nil , err } if strings . LastIndex ( o . Host , ":" ) > 0 { host = host [ : strings . LastIndex ( o . Host , ":" ) ] } client := new ( Client ) if o . NoTLS { client . conn = c } else { var tlsconn * tls . Conn if o . TLSConfig != nil { tlsconn = tls . Client ( c , o . TLSConfig ) } else { DefaultConfig . ServerName = host newconfig := DefaultConfig newconfig . ServerName = host tlsconn = tls . Client ( c , & newconfig ) } if err = tlsconn . Handshake ( ) ; err != nil { return nil , err } insecureSkipVerify := DefaultConfig . InsecureSkipVerify if o . TLSConfig != nil { insecureSkipVerify = o . TLSConfig . InsecureSkipVerify } if ! insecureSkipVerify { if err = tlsconn . VerifyHostname ( host ) ; err != nil { return nil , err } } client . conn = tlsconn } if err := client . init ( & o ) ; err != nil { client . Close ( ) return nil , err } return client , nil }
5371	func ( c * Client ) Close ( ) error { if c . conn != ( * tls . Conn ) ( nil ) { return c . conn . Close ( ) } return nil }
5372	func ( c * Client ) startTLSIfRequired ( f * streamFeatures , o * Options , domain string ) ( * streamFeatures , error ) { switch { case f . StartTLS == nil : return f , nil case ! o . StartTLS && f . StartTLS . Required == nil : return f , nil case f . StartTLS . Required != nil : case ! o . StartTLS : } var err error fmt . Fprintf ( c . conn , "<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\n" ) \n var k tlsProceed if err = c . p . DecodeElement ( & k , nil ) ; err != nil { return f , errors . New ( "unmarshal <proceed>: " + err . Error ( ) ) } tc := o . TLSConfig if tc == nil { tc = new ( tls . Config ) * tc = DefaultConfig tc . ServerName = domain } t := tls . Client ( c . conn , tc ) if err = t . Handshake ( ) ; err != nil { return f , errors . New ( "starttls handshake: " + err . Error ( ) ) } c . conn = t tf , err := c . startStream ( o , domain ) if err != nil { return f , err } }
5373	func ( c * Client ) startStream ( o * Options , domain string ) ( * streamFeatures , error ) { if o . Debug { c . p = xml . NewDecoder ( tee { c . conn , DebugWriter } ) } else { c . p = xml . NewDecoder ( c . conn ) } _ , err := fmt . Fprintf ( c . conn , "<?xml version='1.0'?>\n" + \n + "<stream:stream to='%s' xmlns='%s'\n" , \n , " xmlns:stream='%s' version='1.0'>\n" , \n ) xmlEscape ( domain ) nsClient nsStream if err != nil { return nil , err } se , err := nextStart ( c . p ) if err != nil { return nil , err } if se . Name . Space != nsStream || se . Name . Local != "stream" { return nil , fmt . Errorf ( "expected <stream> but got <%v> in %v" , se . Name . Local , se . Name . Space ) } }
5374	func ( c * Client ) IsEncrypted ( ) bool { _ , ok := c . conn . ( * tls . Conn ) return ok }
5375	func ( c * Client ) Recv ( ) ( stanza interface { } , err error ) { for { _ , val , err := next ( c . p ) if err != nil { return Chat { } , err } switch v := val . ( type ) { case * clientMessage : stamp , _ := time . Parse ( "2006-01-02T15:04:05Z" , v . Delay . Stamp , ) chat := Chat { Remote : v . From , Type : v . Type , Text : v . Body , Subject : v . Subject , Thread : v . Thread , Other : v . OtherStrings ( ) , OtherElem : v . Other , Stamp : stamp , } return chat , nil case * clientQuery : var r Roster for _ , item := range v . Item { r = append ( r , Contact { item . Jid , item . Name , item . Group } ) } return Chat { Type : "roster" , Roster : r } , nil case * clientPresence : return Presence { v . From , v . To , v . Type , v . Show , v . Status } , nil case * clientIQ : if bytes . Equal ( bytes . TrimSpace ( v . Query ) , [ ] byte ( `<ping xmlns='urn:xmpp:ping'/>` ) ) || bytes . Equal ( bytes . TrimSpace ( v . Query ) , [ ] byte ( `<ping xmlns="urn:xmpp:ping"/>` ) ) { err := c . SendResultPing ( v . ID , v . From ) if err != nil { return Chat { } , err } } return IQ { ID : v . ID , From : v . From , To : v . To , Type : v . Type , Query : v . Query } , nil } } }
5376	func ( c * Client ) Send ( chat Chat ) ( n int , err error ) { var subtext = `` var thdtext = `` if chat . Subject != `` { subtext = `<subject>` + xmlEscape ( chat . Subject ) + `</subject>` } if chat . Thread != `` { thdtext = `<thread>` + xmlEscape ( chat . Thread ) + `</thread>` } stanza := "<message to='%s' type='%s' id='%s' xml:lang='en'>" + subtext + "<body>%s</body>" + thdtext + "</message>" return fmt . Fprintf ( c . conn , stanza , xmlEscape ( chat . Remote ) , xmlEscape ( chat . Type ) , cnonce ( ) , xmlEscape ( chat . Text ) ) }
5377	func ( c * Client ) SendOrg ( org string ) ( n int , err error ) { return fmt . Fprint ( c . conn , org ) }
5378	func ( c * Client ) SendKeepAlive ( ) ( n int , err error ) { return fmt . Fprintf ( c . conn , " " ) }
5379	func ( c * Client ) SendHtml ( chat Chat ) ( n int , err error ) { return fmt . Fprintf ( c . conn , "<message to='%s' type='%s' xml:lang='en'>" + "<body>%s</body>" + "<html xmlns='http://jabber.org/protocol/xhtml-im'><body xmlns='http://www.w3.org/1999/xhtml'>%s</body></html></message>" , xmlEscape ( chat . Remote ) , xmlEscape ( chat . Type ) , xmlEscape ( chat . Text ) , chat . Text ) }
5380	func nextStart ( p * xml . Decoder ) ( xml . StartElement , error ) { for { t , err := p . Token ( ) if err != nil || t == nil { return xml . StartElement { } , err } switch t := t . ( type ) { case xml . StartElement : return t , nil } } }
5381	func ( c * Client ) JoinProtectedMUC ( jid , nick string , password string , history_type , history int , history_date * time . Time ) ( n int , err error ) { if nick == "" { nick = c . jid } switch history_type { case NoHistory : return fmt . Fprintf ( c . conn , "<presence to='%s/%s'>\n" + \n + "<x xmlns='%s'>\n" + \n + "<password>%s</password>" , "</x>\n" , \n , "</presence>" , xmlEscape ( jid ) ) xmlEscape ( nick ) nsMUC xmlEscape ( password ) case CharHistory : return fmt . Fprintf ( c . conn , "<presence to='%s/%s'>\n" + \n + "<x xmlns='%s'>\n" + \n + "<password>%s</password>\n" , \n , "<history maxchars='%d'/></x>\n" , \n , "</presence>" , xmlEscape ( jid ) ) } xmlEscape ( nick ) }
5382	func ( c * Client ) LeaveMUC ( jid string ) ( n int , err error ) { return fmt . Fprintf ( c . conn , "<presence from='%s' to='%s' type='unavailable' />" , c . jid , xmlEscape ( jid ) ) }
5383	func ( m * Message ) AttachBuffer ( filename string , buf [ ] byte , inline bool ) error { m . Attachments [ filename ] = & Attachment { Filename : filename , Data : buf , Inline : inline , } return nil }
5384	func ( m * Message ) Attach ( file string ) error { return m . attach ( file , false ) }
5385	func ( m * Message ) Inline ( file string ) error { return m . attach ( file , true ) }
5386	func ( m * Message ) AddHeader ( key string , value string ) Header { newHeader := Header { Key : key , Value : value } m . Headers = append ( m . Headers , newHeader ) return newHeader }
5387	func ( m * Message ) Tolist ( ) [ ] string { tolist := m . To for _ , cc := range m . Cc { tolist = append ( tolist , cc ) } for _ , bcc := range m . Bcc { tolist = append ( tolist , bcc ) } return tolist }
5388	func ( m * Message ) Bytes ( ) [ ] byte { buf := bytes . NewBuffer ( nil ) buf . WriteString ( "From: " + m . From . String ( ) + "\r\n" ) \r \n t := time . Now ( ) buf . WriteString ( "Date: " + t . Format ( time . RFC1123Z ) + "\r\n" ) \r \n buf . WriteString ( "To: " + strings . Join ( m . To , "," ) + "\r\n" ) \r \n if len ( m . Cc ) > 0 { buf . WriteString ( "Cc: " + strings . Join ( m . Cc , "," ) + "\r\n" ) } \r \n var coder = base64 . StdEncoding var subject = "=?UTF-8?B?" + coder . EncodeToString ( [ ] byte ( m . Subject ) ) + "?=" buf . WriteString ( "Subject: " + subject + "\r\n" ) \r \n }
5389	func Send ( addr string , auth smtp . Auth , m * Message ) error { return smtp . SendMail ( addr , auth , m . From . Address , m . Tolist ( ) , m . Bytes ( ) ) }
5390	func ( e * Envelope ) GetHeader ( name string ) string { if e . header == nil { return "" } return decodeHeader ( e . header . Get ( name ) ) }
5391	func ( e * Envelope ) GetHeaderValues ( name string ) [ ] string { if e . header == nil { return [ ] string { } } rawValues := ( * e . header ) [ textproto . CanonicalMIMEHeaderKey ( name ) ] var values [ ] string for _ , v := range rawValues { values = append ( values , decodeHeader ( v ) ) } return values }
5392	func ( e * Envelope ) SetHeader ( name string , value [ ] string ) error { if name == "" { return fmt . Errorf ( "Provide non-empty header name" ) } for i , v := range value { if i == 0 { e . header . Set ( name , mime . BEncoding . Encode ( "utf-8" , v ) ) continue } e . header . Add ( name , mime . BEncoding . Encode ( "utf-8" , v ) ) } return nil }
5393	func ( e * Envelope ) AddHeader ( name string , value string ) error { if name == "" { return fmt . Errorf ( "Provide non-empty header name" ) } e . header . Add ( name , mime . BEncoding . Encode ( "utf-8" , value ) ) return nil }
5394	func ( e * Envelope ) DeleteHeader ( name string ) error { if name == "" { return fmt . Errorf ( "Provide non-empty header name" ) } e . header . Del ( name ) return nil }
5395	func ( e * Envelope ) AddressList ( key string ) ( [ ] * mail . Address , error ) { if e . header == nil { return nil , fmt . Errorf ( "No headers available" ) } if ! AddressHeaders [ strings . ToLower ( key ) ] { return nil , fmt . Errorf ( "%s is not an address header" , key ) } str := decodeToUTF8Base64Header ( e . header . Get ( key ) ) if str == "" { return nil , mail . ErrHeaderNotPresent } ret , err := mail . ParseAddressList ( str ) switch { case err == nil : case err . Error ( ) == "mail: expected comma" : ret , err = mail . ParseAddressList ( ensureCommaDelimitedAddresses ( str ) ) if err != nil { return nil , err } default : return nil , err } return ret , nil }
5396	func ( e * Envelope ) Clone ( ) * Envelope { if e == nil { return nil } newEnvelope := & Envelope { e . Text , e . HTML , e . Root . Clone ( nil ) , e . Attachments , e . Inlines , e . OtherParts , e . Errors , e . header , } return newEnvelope }
5397	func ReadEnvelope ( r io . Reader ) ( * Envelope , error ) { root , err := ReadParts ( r ) if err != nil { return nil , errors . WithMessage ( err , "Failed to ReadParts" ) } return EnvelopeFromPart ( root ) }
5398	func EnvelopeFromPart ( root * Part ) ( * Envelope , error ) { e := & Envelope { Root : root , header : & root . Header , } if detectMultipartMessage ( root ) { if err := parseMultiPartBody ( root , e ) ; err != nil { return nil , err } } else { if detectBinaryBody ( root ) { if root . Disposition == cdInline { e . Inlines = append ( e . Inlines , root ) } else { e . Attachments = append ( e . Attachments , root ) } } else { if err := parseTextOnlyBody ( root , e ) ; err != nil { return nil , err } } } if e . Text == "" && e . HTML != "" { e . Root . addWarning ( ErrorPlainTextFromHTML , "Message did not contain a text/plain part" ) var err error if e . Text , err = html2text . FromString ( e . HTML ) ; err != nil { e . Text = "" p := e . Root . BreadthMatchFirst ( matchHTMLBodyPart ) p . addError ( ErrorPlainTextFromHTML , "Failed to downconvert HTML: %v" , err ) } } if e . Root != nil { _ = e . Root . DepthMatchAll ( func ( part * Part ) bool { for i := range part . Errors { e . Errors = append ( e . Errors , part . Errors [ i ] ) } return false } ) } return e , nil }
5399	func parseTextOnlyBody ( root * Part , e * Envelope ) error { var charset string var isHTML bool if ctype := root . Header . Get ( hnContentType ) ; ctype != "" { if mediatype , mparams , _ , err := parseMediaType ( ctype ) ; err == nil { isHTML = ( mediatype == ctTextHTML ) if mparams [ hpCharset ] != "" { charset = mparams [ hpCharset ] } } } if isHTML { rawHTML := string ( root . Content ) e . HTML = rawHTML if charset == "" { if charset = coding . FindCharsetInHTML ( rawHTML ) ; charset != "" { if convHTML , err := coding . ConvertToUTF8String ( charset , root . Content ) ; err == nil { e . HTML = convHTML } else { root . addWarning ( ErrorCharsetConversion , err . Error ( ) ) } } return nil } } else { e . Text = string ( root . Content ) } return nil }
5400	func parseMultiPartBody ( root * Part , e * Envelope ) error { ctype := root . Header . Get ( hnContentType ) mediatype , params , _ , err := parseMediaType ( ctype ) if err != nil { return fmt . Errorf ( "Unable to parse media type: %v" , err ) } if ! strings . HasPrefix ( mediatype , ctMultipartPrefix ) { return fmt . Errorf ( "Unknown mediatype: %v" , mediatype ) } boundary := params [ hpBoundary ] if boundary == "" { return fmt . Errorf ( "Unable to locate boundary param in Content-Type header" ) } if mediatype == ctMultipartAltern { p := root . BreadthMatchFirst ( func ( p * Part ) bool { return p . ContentType == ctTextPlain && p . Disposition != cdAttachment } ) if p != nil { e . Text = string ( p . Content ) } } else { parts := root . DepthMatchAll ( func ( p * Part ) bool { return p . ContentType == ctTextPlain && p . Disposition != cdAttachment } ) for i , p := range parts { if i > 0 { e . Text += "\n--\n" } \n } } \n e . Text += string ( p . Content ) p := root . BreadthMatchFirst ( matchHTMLBodyPart ) if p != nil { e . HTML += string ( p . Content ) } e . Attachments = root . BreadthMatchAll ( func ( p * Part ) bool { return p . Disposition == cdAttachment || p . ContentType == ctAppOctetStream } ) e . Inlines = root . BreadthMatchAll ( func ( p * Part ) bool { return p . Disposition == cdInline && ! strings . HasPrefix ( p . ContentType , ctMultipartPrefix ) } ) }
5401	func matchHTMLBodyPart ( p * Part ) bool { return p . ContentType == ctTextHTML && p . Disposition != cdAttachment }
5402	func ensureCommaDelimitedAddresses ( s string ) string { s = strings . Join ( strings . Fields ( s ) , " " ) inQuotes := false inDomain := false escapeSequence := false sb := strings . Builder { } for _ , r := range s { if escapeSequence { escapeSequence = false sb . WriteRune ( r ) continue } if r == '"' { inQuotes = ! inQuotes sb . WriteRune ( r ) continue } if inQuotes { if r == '\\' { escapeSequence = true sb . WriteRune ( r ) continue } } else { if r == '@' { inDomain = true sb . WriteRune ( r ) continue } if inDomain { if r == ';' { sb . WriteRune ( r ) break } if r == ',' { inDomain = false sb . WriteRune ( r ) continue } if r == ' ' { inDomain = false sb . WriteRune ( ',' ) sb . WriteRune ( r ) continue } } } sb . WriteRune ( r ) } return sb . String ( ) }
5403	func ( p MailBuilder ) Date ( date time . Time ) MailBuilder { p . date = date return p }
5404	func ( p MailBuilder ) From ( name , addr string ) MailBuilder { p . from = mail . Address { Name : name , Address : addr } return p }
5405	func ( p MailBuilder ) Subject ( subject string ) MailBuilder { p . subject = subject return p }
5406	func ( p MailBuilder ) To ( name , addr string ) MailBuilder { p . to = append ( p . to , mail . Address { Name : name , Address : addr } ) return p }
5407	func ( p MailBuilder ) ToAddrs ( to [ ] mail . Address ) MailBuilder { p . to = to return p }
5408	func ( p MailBuilder ) CC ( name , addr string ) MailBuilder { p . cc = append ( p . cc , mail . Address { Name : name , Address : addr } ) return p }
5409	func ( p MailBuilder ) CCAddrs ( cc [ ] mail . Address ) MailBuilder { p . cc = cc return p }
5410	func ( p MailBuilder ) ReplyTo ( name , addr string ) MailBuilder { p . replyTo = mail . Address { Name : name , Address : addr } return p }
5411	func ( p MailBuilder ) Header ( name , value string ) MailBuilder { h := textproto . MIMEHeader { } for k , v := range p . header { h [ k ] = v } h . Add ( name , value ) p . header = h return p }
5412	func ( p MailBuilder ) AddAttachment ( b [ ] byte , contentType string , fileName string ) MailBuilder { part := NewPart ( contentType ) part . Content = b part . FileName = fileName part . Disposition = cdAttachment p . attachments = append ( p . attachments , part ) return p }
5413	func ( p MailBuilder ) AddFileAttachment ( path string ) MailBuilder { if p . err != nil { return p } f , err := os . Open ( path ) if err != nil { p . err = err return p } b , err := ioutil . ReadAll ( f ) if err != nil { p . err = err return p } name := filepath . Base ( path ) ctype := mime . TypeByExtension ( filepath . Ext ( name ) ) return p . AddAttachment ( b , ctype , name ) }
5414	func ( p MailBuilder ) AddInline ( b [ ] byte , contentType string , fileName string , contentID string , ) MailBuilder { part := NewPart ( contentType ) part . Content = b part . FileName = fileName part . Disposition = cdInline part . ContentID = contentID p . inlines = append ( p . inlines , part ) return p }
5415	func ( p MailBuilder ) Equals ( o MailBuilder ) bool { return reflect . DeepEqual ( p , o ) }
5416	func ( p * Part ) Encode ( writer io . Writer ) error { if p . Header == nil { p . Header = make ( textproto . MIMEHeader ) } cte := p . setupMIMEHeaders ( ) b := bufio . NewWriter ( writer ) p . encodeHeader ( b ) if len ( p . Content ) > 0 { b . Write ( crnl ) if err := p . encodeContent ( b , cte ) ; err != nil { return err } } if p . FirstChild == nil { return b . Flush ( ) } endMarker := [ ] byte ( "\r\n--" + \r + \n ) p . Boundary "--" marker := endMarker [ : len ( endMarker ) - 2 ] c := p . FirstChild for c != nil { b . Write ( marker ) b . Write ( crnl ) if err := c . Encode ( b ) ; err != nil { return err } c = c . NextSibling } b . Write ( endMarker ) }
5417	func ( p * Part ) encodeHeader ( b * bufio . Writer ) { keys := make ( [ ] string , 0 , len ( p . Header ) ) for k := range p . Header { keys = append ( keys , k ) } sort . Strings ( keys ) for _ , k := range keys { for _ , v := range p . Header [ k ] { encv := v switch selectTransferEncoding ( [ ] byte ( v ) , true ) { case teBase64 : encv = mime . BEncoding . Encode ( utf8 , v ) case teQuoted : encv = mime . QEncoding . Encode ( utf8 , v ) } wb := stringutil . Wrap ( 76 , k , ":_" , encv , "\r\n" ) \r \n } } }
5418	func ( p * Part ) encodeContent ( b * bufio . Writer , cte transferEncoding ) ( err error ) { switch cte { case teBase64 : enc := base64 . StdEncoding text := make ( [ ] byte , enc . EncodedLen ( len ( p . Content ) ) ) base64 . StdEncoding . Encode ( text , p . Content ) lineLen := 76 for len ( text ) > 0 { if lineLen > len ( text ) { lineLen = len ( text ) } if _ , err = b . Write ( text [ : lineLen ] ) ; err != nil { return err } b . Write ( crnl ) text = text [ lineLen : ] } case teQuoted : qp := quotedprintable . NewWriter ( b ) if _ , err = qp . Write ( p . Content ) ; err != nil { return err } err = qp . Close ( ) default : _ , err = b . Write ( p . Content ) } return err }
5419	func selectTransferEncoding ( content [ ] byte , quoteLineBreaks bool ) transferEncoding { if len ( content ) == 0 { return te7Bit } threshold := b64Percent * len ( content ) / 100 bincount := 0 for _ , b := range content { if ( b < ' ' || '~' < b ) && b != '\t' { if ! quoteLineBreaks && ( b == '\r' || b == '\n' ) { continue } bincount ++ if bincount >= threshold { return teBase64 } } } if bincount == 0 { return te7Bit } return teQuoted }
5420	func setParamValue ( p map [ string ] string , k , v string ) { if v != "" { p [ k ] = v } }
5421	func NewBase64Cleaner ( r io . Reader ) * Base64Cleaner { return & Base64Cleaner { Errors : make ( [ ] error , 0 ) , r : r , } }
5422	func decodeToUTF8Base64Header ( input string ) string { if ! strings . Contains ( input , "=?" ) { return input } tokens := strings . FieldsFunc ( input , whiteSpaceRune ) output := make ( [ ] string , len ( tokens ) ) for i , token := range tokens { if len ( token ) > 4 && strings . Contains ( token , "=?" ) { prefix := "" suffix := "" if token [ 0 ] == '(' { prefix = "(" token = token [ 1 : ] } if token [ len ( token ) - 1 ] == ')' { suffix = ")" token = token [ : len ( token ) - 1 ] } output [ i ] = prefix + mime . BEncoding . Encode ( "UTF-8" , decodeHeader ( token ) ) + suffix } else { output [ i ] = token } } return strings . Join ( output , " " ) }
5423	func parseMediaType ( ctype string ) ( mtype string , params map [ string ] string , invalidParams [ ] string , err error ) { mtype , params , err = mime . ParseMediaType ( ctype ) if err != nil { mctype := fixMangledMediaType ( ctype , ";" ) mtype , params , err = mime . ParseMediaType ( mctype ) if err != nil { mctype := fixMangledMediaType ( ctype , " " ) if strings . Contains ( mctype , `name=""` ) { mctype = strings . Replace ( mctype , `name=""` , `name=" "` , - 1 ) } mtype , params , err = mime . ParseMediaType ( mctype ) if err != nil { mtype , params , err = mime . ParseMediaType ( fixUnquotedSpecials ( mctype ) ) if err != nil { return "" , nil , nil , errors . WithStack ( err ) } } } } if mtype == ctPlaceholder { mtype = "" } for name , value := range params { if value != pvPlaceholder { continue } invalidParams = append ( invalidParams , name ) delete ( params , name ) } return mtype , params , invalidParams , err }
5424	func fixMangledMediaType ( mtype , sep string ) string { if mtype == "" { return "" } parts := strings . Split ( mtype , sep ) mtype = "" for i , p := range parts { switch i { case 0 : if p == "" { p = ctPlaceholder } default : if ! strings . Contains ( p , "=" ) { p = p + "=" + pvPlaceholder } p = rfc2047AttributeName ( p ) pair := strings . Split ( p , "=" ) if strings . Contains ( mtype , pair [ 0 ] + "=" ) { continue } if strings . ContainsAny ( pair [ 0 ] , "()<>@,;:\"\\/[]?" ) \" } \\ { continue } } mtype += p if i != len ( parts ) - 1 && ! strings . HasSuffix ( mtype , ";" ) { mtype += ";" } }
5425	func detectMultipartMessage ( root * Part ) bool { ctype := root . Header . Get ( hnContentType ) mediatype , _ , _ , err := parseMediaType ( ctype ) if err != nil { return false } return strings . HasPrefix ( mediatype , ctMultipartPrefix ) }
5426	func detectBinaryBody ( root * Part ) bool { if detectTextHeader ( root . Header , true ) { return false } isBin := detectAttachmentHeader ( root . Header ) if ! isBin { mediatype , _ , _ , _ := parseMediaType ( root . Header . Get ( hnContentType ) ) mediatype = strings . ToLower ( mediatype ) if mediatype != ctTextPlain && mediatype != ctTextHTML { return true } } return isBin }
5427	func ( p * Part ) BreadthMatchFirst ( matcher PartMatcher ) * Part { q := list . New ( ) q . PushBack ( p ) for q . Len ( ) > 0 { e := q . Front ( ) p := e . Value . ( * Part ) if matcher ( p ) { return p } q . Remove ( e ) c := p . FirstChild for c != nil { q . PushBack ( c ) c = c . NextSibling } } return nil }
5428	func ( p * Part ) BreadthMatchAll ( matcher PartMatcher ) [ ] * Part { q := list . New ( ) q . PushBack ( p ) matches := make ( [ ] * Part , 0 , 10 ) for q . Len ( ) > 0 { e := q . Front ( ) p := e . Value . ( * Part ) if matcher ( p ) { matches = append ( matches , p ) } q . Remove ( e ) c := p . FirstChild for c != nil { q . PushBack ( c ) c = c . NextSibling } } return matches }
5429	func ( p * Part ) DepthMatchFirst ( matcher PartMatcher ) * Part { root := p for { if matcher ( p ) { return p } c := p . FirstChild if c != nil { p = c } else { for p . NextSibling == nil { if p == root { return nil } p = p . Parent } p = p . NextSibling } } }
5430	func ( p * Part ) DepthMatchAll ( matcher PartMatcher ) [ ] * Part { root := p matches := make ( [ ] * Part , 0 , 10 ) for { if matcher ( p ) { matches = append ( matches , p ) } c := p . FirstChild if c != nil { p = c } else { for p . NextSibling == nil { if p == root { return matches } p = p . Parent } p = p . NextSibling } } }
5431	func ToASCII ( s string ) string { tr := transform . Chain ( norm . NFD , runes . Remove ( runes . In ( unicode . Mn ) ) , runes . Map ( mapLatinSpecial ) , norm . NFC ) r , _ , _ := transform . String ( tr , s ) return r }
5432	func NewPart ( contentType string ) * Part { return & Part { Header : make ( textproto . MIMEHeader ) , ContentType : contentType , } }
5433	func ( p * Part ) AddChild ( child * Part ) { if p == child { return } if p != nil { if p . FirstChild == nil { p . FirstChild = child } else { current := p . FirstChild for current . NextSibling != nil { current = current . NextSibling } if current == child { return } current . NextSibling = child } } for c := child ; c != nil ; c = c . NextSibling { if c == c . NextSibling { return } c . Parent = p } }
5434	func ( p * Part ) TextContent ( ) bool { if p . ContentType == "" { return true } return strings . HasPrefix ( p . ContentType , "text/" ) || strings . HasPrefix ( p . ContentType , ctMultipartPrefix ) }
5435	func ( p * Part ) setupHeaders ( r * bufio . Reader , defaultContentType string ) error { header , err := readHeader ( r , p ) if err != nil { return err } p . Header = header ctype := header . Get ( hnContentType ) if ctype == "" { if defaultContentType == "" { p . addWarning ( ErrorMissingContentType , "MIME parts should have a Content-Type header" ) return nil } ctype = defaultContentType } mtype , mparams , minvalidParams , err := parseMediaType ( ctype ) if err != nil { return err } if mtype == "" && len ( mparams ) > 0 { p . addWarning ( ErrorMissingContentType , "Content-Type header has parameters but no content type" ) } for i := range minvalidParams { p . addWarning ( ErrorMalformedHeader , "Content-Type header has malformed parameter %q" , minvalidParams [ i ] ) } p . ContentType = mtype p . setupContentHeaders ( mparams ) p . Boundary = mparams [ hpBoundary ] p . ContentID = coding . FromIDHeader ( header . Get ( hnContentID ) ) return nil }
5436	func ( p * Part ) setupContentHeaders ( mediaParams map [ string ] string ) { disposition , dparams , _ , err := parseMediaType ( p . Header . Get ( hnContentDisposition ) ) if err == nil { p . Disposition = disposition p . FileName = decodeHeader ( dparams [ hpFilename ] ) } if p . FileName == "" && mediaParams [ hpName ] != "" { p . FileName = decodeHeader ( mediaParams [ hpName ] ) } if p . FileName == "" && mediaParams [ hpFile ] != "" { p . FileName = decodeHeader ( mediaParams [ hpFile ] ) } if p . Charset == "" { p . Charset = mediaParams [ hpCharset ] } if p . FileModDate . IsZero ( ) { p . FileModDate , _ = time . Parse ( time . RFC822 , mediaParams [ hpModDate ] ) } }
5437	func ( p * Part ) convertFromDetectedCharset ( r io . Reader ) ( io . Reader , error ) { var cd * chardet . Detector switch p . ContentType { case "text/html" : cd = chardet . NewHtmlDetector ( ) default : cd = chardet . NewTextDetector ( ) } buf , err := ioutil . ReadAll ( r ) if err != nil { return nil , errors . WithStack ( err ) } cs , err := cd . DetectBest ( buf ) switch err { case nil : case chardet . NotDetectedError : p . addWarning ( ErrorCharsetDeclaration , "charset could not be detected: %v" , err ) default : return nil , errors . WithStack ( err ) } r = bytes . NewReader ( buf ) if cs == nil || cs . Confidence < minCharsetConfidence { return p . convertFromStatedCharset ( r ) , nil } if p . Charset != "" && ! strings . EqualFold ( cs . Charset , p . Charset ) { p . addWarning ( ErrorCharsetDeclaration , "declared charset %q, detected %q, confidence %d" , p . Charset , cs . Charset , cs . Confidence ) } reader , err := coding . NewCharsetReader ( cs . Charset , r ) if err != nil { p . addWarning ( ErrorCharsetConversion , err . Error ( ) ) } else { r = reader p . OrigCharset = p . Charset p . Charset = cs . Charset } return r , nil }
5438	func ( p * Part ) Clone ( parent * Part ) * Part { if p == nil { return nil } newPart := & Part { PartID : p . PartID , Header : p . Header , Parent : parent , Boundary : p . Boundary , ContentID : p . ContentID , ContentType : p . ContentType , Disposition : p . Disposition , FileName : p . FileName , Charset : p . Charset , Errors : p . Errors , Content : p . Content , Epilogue : p . Epilogue , } newPart . FirstChild = p . FirstChild . Clone ( newPart ) newPart . NextSibling = p . NextSibling . Clone ( parent ) return newPart }
5439	func ReadParts ( r io . Reader ) ( * Part , error ) { br := bufio . NewReader ( r ) root := & Part { PartID : "0" } err := root . setupHeaders ( br , `text/plain; charset="us-ascii"` ) if err != nil { return nil , err } if strings . HasPrefix ( root . ContentType , ctMultipartPrefix ) { err = parseParts ( root , br ) if err != nil { return nil , err } } else { if err := root . decodeContent ( br ) ; err != nil { return nil , err } } return root , nil }
5440	func parseParts ( parent * Part , reader * bufio . Reader ) error { firstRecursion := parent . Parent == nil br := newBoundaryReader ( reader , parent . Boundary ) for indexPartID := 1 ; true ; indexPartID ++ { next , err := br . Next ( ) if err != nil && errors . Cause ( err ) != io . EOF { return err } if ! next { break } p := & Part { } if firstRecursion { p . PartID = strconv . Itoa ( indexPartID ) } else { p . PartID = parent . PartID + "." + strconv . Itoa ( indexPartID ) } bbr := bufio . NewReader ( br ) err = p . setupHeaders ( bbr , "" ) if errors . Cause ( err ) == errEmptyHeaderBlock { if _ , err = br . Next ( ) ; err != nil { if errors . Cause ( err ) == io . EOF || strings . HasSuffix ( err . Error ( ) , "EOF" ) { parent . addWarning ( ErrorMissingBoundary , "Boundary %q was not closed correctly" , parent . Boundary ) break } return errors . WithMessage ( err , fmt . Sprintf ( "error at boundary %v" , parent . Boundary ) ) } } else if err != nil { return err } parent . AddChild ( p ) if p . Boundary == "" { if err := p . decodeContent ( bbr ) ; err != nil { return err } } else { err = parseParts ( p , bbr ) if err != nil { return err } } } epilogue , err := ioutil . ReadAll ( reader ) if err != nil { return errors . WithStack ( err ) } parent . Epilogue = epilogue if ! firstRecursion { parent . PartID += ".0" } return nil }
5441	func UUID ( ) string { uuid := make ( [ ] byte , 16 ) uuidMutex . Lock ( ) _ , _ = uuidRand . Read ( uuid ) uuidMutex . Unlock ( ) uuid [ 8 ] = uuid [ 8 ] &^ 0xc0 | 0x80 uuid [ 6 ] = uuid [ 6 ] &^ 0xf0 | 0x40 return fmt . Sprintf ( "%x-%x-%x-%x-%x" , uuid [ 0 : 4 ] , uuid [ 4 : 6 ] , uuid [ 6 : 8 ] , uuid [ 8 : 10 ] , uuid [ 10 : ] ) }
5442	func NewQPCleaner ( r io . Reader ) * QPCleaner { return & QPCleaner { in : bufio . NewReader ( r ) , } }
5443	func ( e * Error ) Error ( ) string { sev := "W" if e . Severe { sev = "E" } return fmt . Sprintf ( "[%s] %s: %s" , sev , e . Name , e . Detail ) }
5444	func ( p * Part ) addError ( name string , detailFmt string , args ... interface { } ) { p . Errors = append ( p . Errors , & Error { name , fmt . Sprintf ( detailFmt , args ... ) , true , } ) }
5445	func ( p * Part ) addWarning ( name string , detailFmt string , args ... interface { } ) { p . Errors = append ( p . Errors , & Error { name , fmt . Sprintf ( detailFmt , args ... ) , false , } ) }
5446	func Wrap ( max int , strs ... string ) [ ] byte { input := make ( [ ] byte , 0 ) output := make ( [ ] byte , 0 ) for _ , s := range strs { input = append ( input , [ ] byte ( s ) ... ) } if len ( input ) < max { return input } ls := - 1 lw := - 1 ll := 0 for i := 0 ; i < len ( input ) ; i ++ { ll ++ switch input [ i ] { case ' ' , '\t' : ls = i } if ll >= max { if ls >= 0 { output = append ( output , input [ lw + 1 : ls ] ... ) output = append ( output , '\r' , '\n' , ' ' ) lw = ls ll = 1 i = lw + 1 ls = - 1 } } } return append ( output , input [ lw + 1 : ] ... ) }
5447	func ConvertToUTF8String ( charset string , textBytes [ ] byte ) ( string , error ) { if strings . ToLower ( charset ) == utf8 { return string ( textBytes ) , nil } csentry , ok := encodings [ strings . ToLower ( charset ) ] if ! ok { return "" , fmt . Errorf ( "Unsupported charset %q" , charset ) } input := bytes . NewReader ( textBytes ) reader := transform . NewReader ( input , csentry . e . NewDecoder ( ) ) output , err := ioutil . ReadAll ( reader ) if err != nil { return "" , err } return string ( output ) , nil }
5448	func JoinAddress ( addrs [ ] mail . Address ) string { if len ( addrs ) == 0 { return "" } buf := & bytes . Buffer { } for i , a := range addrs { if i > 0 { _ , _ = buf . WriteString ( ", " ) } _ , _ = buf . WriteString ( a . String ( ) ) } return buf . String ( ) }
5449	func ( md * markdown ) Printf ( format string , args ... interface { } ) { fmt . Fprintf ( md , format , args ... ) }
5450	func EnvelopeToMarkdown ( w io . Writer , e * enmime . Envelope , name string ) error { md := & markdown { bufio . NewWriter ( w ) } md . H1 ( name ) md . H2 ( "Header" ) if e . Root != nil && e . Root . Header != nil { keys := make ( [ ] string , 0 , len ( e . Root . Header ) ) for k := range e . Root . Header { switch strings . ToLower ( k ) { case "from" , "to" , "cc" , "bcc" , "reply-to" , "subject" : continue } keys = append ( keys , k ) } sort . Strings ( keys ) for _ , k := range keys { md . Printf ( " %v: %v\n" , \n , k ) } } e . GetHeader ( k ) md . Println ( ) md . H2 ( "Envelope" ) for _ , hkey := range addressHeaders { addrlist , err := e . AddressList ( hkey ) if err != nil { if err == mail . ErrHeaderNotPresent { continue } return err } md . H3 ( hkey ) for _ , addr := range addrlist { md . Printf ( "- %v `<%v>`\n" , \n , addr . Name ) } addr . Address } md . Println ( ) md . H3 ( "Subject" ) md . Println ( e . GetHeader ( "Subject" ) ) md . Println ( ) md . H2 ( "Body Text" ) md . Println ( e . Text ) md . Println ( ) md . H2 ( "Body HTML" ) md . Println ( e . HTML ) md . Println ( ) md . H2 ( "Attachment List" ) for _ , a := range e . Attachments { md . Printf ( "- %v (%v)\n" , \n , a . FileName ) a . ContentType } if a . ContentID != "" { md . Printf ( " Content-ID: %s\n" , \n ) } a . ContentID md . Println ( ) md . H2 ( "Inline List" ) for _ , a := range e . Inlines { md . Printf ( "- %v (%v)\n" , \n , a . FileName ) a . ContentType } if a . ContentID != "" { md . Printf ( " Content-ID: %s\n" , \n ) } a . ContentID md . Println ( ) md . H2 ( "Other Part List" ) }
5451	func FormatPart ( w io . Writer , p * enmime . Part , indent string ) { if p == nil { return } sibling := p . NextSibling child := p . FirstChild myindent := indent + "`-- " childindent := indent + " " if sibling != nil { myindent = indent + "|-- " childindent = indent + "| " } if p . Parent == nil { myindent = indent childindent = indent } ctype := "MISSING TYPE" if p . ContentType != "" { ctype = p . ContentType } disposition := "" if p . Disposition != "" { disposition = fmt . Sprintf ( ", disposition: %s" , p . Disposition ) } filename := "" if p . FileName != "" { filename = fmt . Sprintf ( ", filename: %q" , p . FileName ) } errors := "" if len ( p . Errors ) > 0 { errors = fmt . Sprintf ( " (errors: %v)" , len ( p . Errors ) ) } fmt . Fprintf ( w , "%s%s%s%s%s\n" , \n , myindent , ctype , disposition , filename ) errors FormatPart ( w , child , childindent ) }
5452	func newBoundaryReader ( reader * bufio . Reader , boundary string ) * boundaryReader { fullBoundary := [ ] byte ( "\n--" + \n + boundary ) "--" }
5453	func ( b * boundaryReader ) Read ( dest [ ] byte ) ( n int , err error ) { if b . buffer . Len ( ) >= len ( dest ) { return b . buffer . Read ( dest ) } peek , err := b . r . Peek ( peekBufferSize ) peekEOF := ( err == io . EOF ) if err != nil && ! peekEOF && err != bufio . ErrBufferFull { return 0 , errors . WithStack ( err ) } var nCopy int idx , complete := locateBoundary ( peek , b . nlPrefix ) if idx != - 1 { nCopy = idx if ! complete && nCopy == 0 { nCopy = 1 } } else { if nCopy = len ( peek ) - len ( b . nlPrefix ) - 1 ; nCopy <= 0 { nCopy = 0 if peekEOF { return 0 , errors . WithStack ( io . ErrUnexpectedEOF ) } } } if nCopy > 0 { if _ , err = io . CopyN ( b . buffer , b . r , int64 ( nCopy ) ) ; err != nil { return 0 , errors . WithStack ( err ) } } n , err = b . buffer . Read ( dest ) if err == io . EOF && ! complete { return n , nil } return n , err }
5454	func ( b * boundaryReader ) Next ( ) ( bool , error ) { if b . finished { return false , nil } if b . partsRead > 0 { _ , _ = io . Copy ( ioutil . Discard , b ) } for { line , err := b . r . ReadSlice ( '\n' ) if err != nil && err != io . EOF { return false , errors . WithStack ( err ) } if len ( line ) > 0 && ( line [ 0 ] == '\r' || line [ 0 ] == '\n' ) { continue } if b . isTerminator ( line ) { b . finished = true return false , nil } if err != io . EOF && b . isDelimiter ( line ) { b . partsRead ++ return true , nil } if err == io . EOF { return false , io . EOF } if b . partsRead == 0 { continue } b . finished = true return false , errors . Errorf ( "expecting boundary %q, got %q" , string ( b . prefix ) , string ( line ) ) } }
5455	func Parse ( buf [ ] byte , offset int ) ( interface { } , error ) { obj , _ , err := parseReturningOffset ( buf , offset ) return obj , err }
5456	func Assign ( symbol string , value interface { } ) ( [ ] byte , error ) { switch value . ( type ) { case [ ] float64 : return assignDoubleArray ( symbol , value . ( [ ] float64 ) ) case [ ] int32 : return assignIntArray ( symbol , value . ( [ ] int32 ) ) case [ ] string : return assignStrArray ( symbol , value . ( [ ] string ) ) case [ ] byte : return assignByteArray ( symbol , value . ( [ ] byte ) ) case string : return assignStr ( symbol , value . ( string ) ) case int32 : return assignInt ( symbol , value . ( int32 ) ) case float64 : return assignDouble ( symbol , value . ( float64 ) ) default : return nil , errors . New ( "session assign: type is not supported" ) } }
5457	func NewRClient ( host string , port int64 ) ( RClient , error ) { return NewRClientWithAuth ( host , port , "" , "" ) }
5458	func NewRClientWithAuth ( host string , port int64 , user , password string ) ( RClient , error ) { addr , err := net . ResolveTCPAddr ( "tcp" , host + ":" + strconv . FormatInt ( port , 10 ) ) if err != nil { return nil , err } rClient := & roger { address : addr , user : user , password : password , } if _ , err = rClient . Eval ( "'Test session connection'" ) ; err != nil { return nil , err } return rClient , nil }
5459	func Register ( identifier string , generator func ( ) string ) { fakeType := inflect . Camelize ( identifier ) customGenerators [ fakeType ] = generator }
5460	func Fuzz ( e interface { } ) { ty := reflect . TypeOf ( e ) if ty . Kind ( ) == reflect . Ptr { ty = ty . Elem ( ) } if ty . Kind ( ) == reflect . Struct { value := reflect . ValueOf ( e ) . Elem ( ) for i := 0 ; i < ty . NumField ( ) ; i ++ { field := value . Field ( i ) if field . CanSet ( ) { field . Set ( fuzzValueFor ( field . Kind ( ) ) ) } } } }
5461	func findFakeFunctionFor ( fako string ) func ( ) string { result := func ( ) string { return "" } for kind , function := range allGenerators ( ) { if fako == kind { result = function break } } return result }
5462	func ( opts * Options ) Apply ( options ... Option ) error { for _ , o := range options { if err := o ( opts ) ; err != nil { return err } } return nil }
5463	func ( opts * Options ) ToOption ( ) Option { return func ( nopts * Options ) error { * nopts = * opts if opts . Other != nil { nopts . Other = make ( map [ interface { } ] interface { } , len ( opts . Other ) ) for k , v := range opts . Other { nopts . Other [ k ] = v } } return nil } }
5464	func ( e * eventChannel ) waitThenClose ( ) { <- e . ctx . Done ( ) e . mu . Lock ( ) close ( e . ch ) e . ch = nil e . mu . Unlock ( ) }
5465	func ( e * eventChannel ) send ( ctx context . Context , ev * QueryEvent ) { e . mu . Lock ( ) if e . ch == nil { e . mu . Unlock ( ) return } select { case e . ch <- ev : case <- e . ctx . Done ( ) : case <- ctx . Done ( ) : } e . mu . Unlock ( ) }
5466	func NewMovingAverage ( age ... float64 ) MovingAverage { if len ( age ) == 0 || age [ 0 ] == AVG_METRIC_AGE { return new ( SimpleEWMA ) } return & VariableEWMA { decay : 2 / ( age [ 0 ] + 1 ) , } }
5467	func ( e * VariableEWMA ) Set ( value float64 ) { e . value = value if e . count <= WARMUP_SAMPLES { e . count = WARMUP_SAMPLES + 1 } }
5468	func calcKeys50 ( pass , salt [ ] byte , kdfCount int ) [ ] [ ] byte { if len ( salt ) > maxPbkdf2Salt { salt = salt [ : maxPbkdf2Salt ] } keys := make ( [ ] [ ] byte , 3 ) if len ( keys ) == 0 { return keys } prf := hmac . New ( sha256 . New , pass ) prf . Write ( salt ) prf . Write ( [ ] byte { 0 , 0 , 0 , 1 } ) t := prf . Sum ( nil ) u := append ( [ ] byte ( nil ) , t ... ) kdfCount -- for i , iter := range [ ] int { kdfCount , 16 , 16 } { for iter > 0 { prf . Reset ( ) prf . Write ( u ) u = prf . Sum ( u [ : 0 ] ) for j := range u { t [ j ] ^= u [ j ] } iter -- } keys [ i ] = append ( [ ] byte ( nil ) , t ... ) } pwcheck := keys [ 2 ] for i , v := range pwcheck [ pwCheckSize : ] { pwcheck [ i & ( pwCheckSize - 1 ) ] ^= v } keys [ 2 ] = pwcheck [ : pwCheckSize ] return keys }
5469	func ( a * archive50 ) getKeys ( b * readBuf ) ( keys [ ] [ ] byte , err error ) { if len ( * b ) < 17 { return nil , errCorruptEncrypt } kdfCount := int ( b . byte ( ) ) if kdfCount > maxKdfCount { return nil , errCorruptEncrypt } kdfCount = 1 << uint ( kdfCount ) salt := b . bytes ( 16 ) for _ , v := range a . keyCache { if kdfCount == v . kdfCount && bytes . Equal ( salt , v . salt ) { return v . keys , nil } } keys = calcKeys50 ( a . pass , salt , kdfCount ) copy ( a . keyCache [ 1 : ] , a . keyCache [ : ] ) a . keyCache [ 0 ] . kdfCount = kdfCount a . keyCache [ 0 ] . salt = append ( [ ] byte ( nil ) , salt ... ) a . keyCache [ 0 ] . keys = keys return keys , nil }
5470	func checkPassword ( b * readBuf , keys [ ] [ ] byte ) error { if len ( * b ) < 12 { return nil } pwcheck := b . bytes ( 8 ) sum := b . bytes ( 4 ) csum := sha256 . Sum256 ( pwcheck ) if bytes . Equal ( sum , csum [ : len ( sum ) ] ) && ! bytes . Equal ( pwcheck , keys [ 2 ] ) { return errBadPassword } return nil }
5471	func ( a * archive50 ) parseFileEncryptionRecord ( b readBuf , f * fileBlockHeader ) error { if ver := b . uvarint ( ) ; ver != 0 { return errUnknownEncMethod } flags := b . uvarint ( ) keys , err := a . getKeys ( & b ) if err != nil { return err } f . key = keys [ 0 ] if len ( b ) < 16 { return errCorruptEncrypt } f . iv = b . bytes ( 16 ) if flags & file5EncCheckPresent > 0 { if err := checkPassword ( & b , keys ) ; err != nil { return err } } if flags & file5EncUseMac > 0 { a . checksum . key = keys [ 1 ] } return nil }
5472	func ( a * archive50 ) parseEncryptionBlock ( b readBuf ) error { if ver := b . uvarint ( ) ; ver != 0 { return errUnknownEncMethod } flags := b . uvarint ( ) keys , err := a . getKeys ( & b ) if err != nil { return err } if flags & enc5CheckPresent > 0 { if err := checkPassword ( & b , keys ) ; err != nil { return err } } a . blockKey = keys [ 0 ] return nil }
5473	func newArchive50 ( r * bufio . Reader , password string ) fileBlockReader { a := new ( archive50 ) a . v = r a . pass = [ ] byte ( password ) a . buf = make ( [ ] byte , 100 ) return a }
5474	func ( cr * cipherBlockReader ) Read ( p [ ] byte ) ( n int , err error ) { for { if cr . n < len ( cr . outbuf ) { n = copy ( p , cr . outbuf [ cr . n : ] ) cr . n += n return n , nil } if cr . err != nil { err = cr . err cr . err = nil return 0 , err } if len ( p ) >= cap ( cr . outbuf ) { break } n , cr . err = cr . read ( cr . outbuf [ : cap ( cr . outbuf ) ] ) cr . outbuf = cr . outbuf [ : n ] cr . n = 0 } return cr . read ( p ) }
5475	func ( cr * cipherBlockReader ) ReadByte ( ) ( byte , error ) { for { if cr . n < len ( cr . outbuf ) { c := cr . outbuf [ cr . n ] cr . n ++ return c , nil } if cr . err != nil { err := cr . err cr . err = nil return 0 , err } var n int n , cr . err = cr . read ( cr . outbuf [ : cap ( cr . outbuf ) ] ) cr . outbuf = cr . outbuf [ : n ] cr . n = 0 } }
5476	func newCipherBlockReader ( r io . Reader , mode cipher . BlockMode ) * cipherBlockReader { cr := & cipherBlockReader { r : r , mode : mode } cr . outbuf = make ( [ ] byte , 0 , mode . BlockSize ( ) ) cr . inbuf = make ( [ ] byte , 0 , mode . BlockSize ( ) ) return cr }
5477	func newAesDecryptReader ( r io . Reader , key , iv [ ] byte ) * cipherBlockReader { block , err := aes . NewCipher ( key ) if err != nil { panic ( err ) } mode := cipher . NewCBCDecrypter ( block , iv ) return newCipherBlockReader ( r , mode ) }
5478	func limitByteReader ( r byteReader , n int64 ) * limitedByteReader { return & limitedByteReader { limitedReader { r , n , io . ErrUnexpectedEOF } , r } }
5479	func ( f * FileHeader ) Mode ( ) os . FileMode { var m os . FileMode if f . IsDir { m = os . ModeDir } if f . HostOS == HostOSWindows { if f . IsDir { m |= 0777 } else if f . Attributes & 1 > 0 { m |= 0444 } else { m |= 0666 } return m } m |= os . FileMode ( f . Attributes ) & os . ModePerm if f . HostOS != HostOSUnix { return m } if f . Attributes & 0x200 != 0 { m |= os . ModeSticky } if f . Attributes & 0x400 != 0 { m |= os . ModeSetgid } if f . Attributes & 0x800 != 0 { m |= os . ModeSetuid } if f . Attributes & 0xF000 == 0xA000 { m |= os . ModeSymlink } return m }
5480	func ( f * packedFileReader ) nextBlockInFile ( ) error { h , err := f . r . next ( ) if err != nil { if err == io . EOF { return errUnexpectedArcEnd } return err } if h . first || h . Name != f . h . Name { return errInvalidFileBlock } f . h = h return nil }
5481	func ( f * packedFileReader ) next ( ) ( * fileBlockHeader , error ) { if f . h != nil { for ! f . h . last { if _ , err := io . Copy ( ioutil . Discard , f . r ) ; err != nil { return nil , err } if err := f . nextBlockInFile ( ) ; err != nil { return nil , err } } if _ , err := io . Copy ( ioutil . Discard , f . r ) ; err != nil { return nil , err } } var err error f . h , err = f . r . next ( ) if err != nil { if err == errArchiveEnd { return nil , io . EOF } return nil , err } if ! f . h . first { return nil , errInvalidFileBlock } return f . h , nil }
5482	func ( f * packedFileReader ) Read ( p [ ] byte ) ( int , error ) { n , err := f . r . Read ( p ) for err == io . EOF { if n > 0 { return n , nil } if f . h == nil || f . h . last { return 0 , io . EOF } if err := f . nextBlockInFile ( ) ; err != nil { return 0 , err } n , err = f . r . Read ( p ) } return n , err }
5483	func ( r * Reader ) Read ( p [ ] byte ) ( int , error ) { n , err := r . r . Read ( p ) if err == io . EOF && r . cksum != nil && ! r . cksum . valid ( ) { return n , errBadFileChecksum } return n , err }
5484	func ( r * Reader ) Next ( ) ( * FileHeader , error ) { if r . solidr != nil { if _ , err := io . Copy ( ioutil . Discard , r . solidr ) ; err != nil { return nil , err } } h , err := r . pr . next ( ) if err != nil { return nil , err } r . solidr = nil br := byteReader ( & r . pr ) if len ( h . key ) > 0 && len ( h . iv ) > 0 { br = newAesDecryptReader ( br , h . key , h . iv ) } r . r = br if h . decoder != nil { err = r . dr . init ( br , h . decoder , h . winSize , ! h . solid ) if err != nil { return nil , err } r . r = & r . dr if r . pr . r . isSolid ( ) { r . solidr = r . r } } if h . UnPackedSize >= 0 && ! h . UnKnownSize { r . r = & limitedReader { r . r , h . UnPackedSize , errShortFile } } r . cksum = h . cksum if r . cksum != nil { r . r = io . TeeReader ( r . r , h . cksum ) } fh := new ( FileHeader ) * fh = h . FileHeader return fh , nil }
5485	func NewReader ( r io . Reader , password string ) ( * Reader , error ) { br , ok := r . ( * bufio . Reader ) if ! ok { br = bufio . NewReader ( r ) } fbr , err := newFileBlockReader ( br , password ) if err != nil { return nil , err } rr := new ( Reader ) rr . init ( fbr ) return rr , nil }
5486	func OpenReader ( name , password string ) ( * ReadCloser , error ) { v , err := openVolume ( name , password ) if err != nil { return nil , err } rc := new ( ReadCloser ) rc . v = v rc . Reader . init ( v ) return rc , nil }
5487	func getV3Filter ( code [ ] byte ) ( v3Filter , error ) { c := crc32 . ChecksumIEEE ( code ) for _ , f := range standardV3Filters { if f . crc == c && f . len == len ( code ) { return f . f , nil } } f := new ( vmFilter ) r := newRarBitReader ( bytes . NewReader ( code [ 1 : ] ) ) n , err := r . readBits ( 1 ) if err != nil { return nil , err } if n > 0 { m , err := r . readUint32 ( ) if err != nil { return nil , err } f . static = make ( [ ] byte , m + 1 ) err = r . readFull ( f . static ) if err != nil { return nil , err } } f . code , err = readCommands ( r ) if err == io . EOF { err = nil } return f . execute , err }
5488	func ( d * decoder29 ) init ( r io . ByteReader , reset bool ) error { if d . br == nil { d . br = newRarBitReader ( r ) } else { d . br . reset ( r ) } d . eof = false if reset { d . initFilters ( ) d . lz . reset ( ) d . ppm . reset ( ) d . decode = nil } if d . decode == nil { return d . readBlockHeader ( ) } return nil }
5489	func ( d * decoder29 ) readBlockHeader ( ) error { d . br . alignByte ( ) n , err := d . br . readBits ( 1 ) if err == nil { if n > 0 { d . decode = d . ppm . decode err = d . ppm . init ( d . br ) } else { d . decode = d . lz . decode err = d . lz . init ( d . br ) } } if err == io . EOF { err = errDecoderOutOfData } return err }
5490	func readCodeLengthTable ( br bitReader , codeLength [ ] byte , addOld bool ) error { var bitlength [ 20 ] byte for i := 0 ; i < len ( bitlength ) ; i ++ { n , err := br . readBits ( 4 ) if err != nil { return err } if n == 0xf { cnt , err := br . readBits ( 4 ) if err != nil { return err } if cnt > 0 { i += cnt + 1 continue } } bitlength [ i ] = byte ( n ) } var bl huffmanDecoder bl . init ( bitlength [ : ] ) for i := 0 ; i < len ( codeLength ) ; i ++ { l , err := bl . readSym ( br ) if err != nil { return err } if l < 16 { if addOld { codeLength [ i ] = ( codeLength [ i ] + byte ( l ) ) & 0xf } else { codeLength [ i ] = byte ( l ) } continue } var count int var value byte switch l { case 16 , 18 : count , err = br . readBits ( 3 ) count += 3 default : count , err = br . readBits ( 7 ) count += 11 } if err != nil { return err } if l < 18 { if i == 0 { return errInvalidLengthTable } value = codeLength [ i - 1 ] } for ; count > 0 && i < len ( codeLength ) ; i ++ { codeLength [ i ] = value count -- } i -- } return nil }
5491	func ( c * context ) shrinkStates ( states [ ] state , size int ) [ ] state { i1 := units2Index [ ( len ( states ) + 1 ) >> 1 ] i2 := units2Index [ ( size + 1 ) >> 1 ] if size == 1 { n := c . statesIndex ( ) c . s [ 1 ] = states [ 0 ] states = c . s [ 1 : ] c . a . addFreeBlock ( n , i1 ) } else if i1 != i2 { if n := c . a . removeFreeBlock ( i2 ) ; n > 0 { copy ( c . a . states [ n : ] , states [ : size ] ) states = c . a . states [ n : ] c . a . addFreeBlock ( c . statesIndex ( ) , i1 ) c . setStatesIndex ( n ) } else { n = c . statesIndex ( ) + index2Units [ i2 ] << 1 u := index2Units [ i1 ] - index2Units [ i2 ] c . a . freeUnits ( n , u ) } } c . setNumStates ( size ) return states [ : size ] }
5492	func ( c * context ) expandStates ( ) [ ] state { states := c . states ( ) ns := len ( states ) if ns == 1 { s := states [ 0 ] n := c . a . allocUnits ( 1 ) if n == 0 { return nil } c . setStatesIndex ( n ) states = c . a . states [ n : ] states [ 0 ] = s } else if ns & 0x1 == 0 { u := ns >> 1 i1 := units2Index [ u ] i2 := units2Index [ u + 1 ] if i1 != i2 { n := c . a . allocUnits ( i2 ) if n == 0 { return nil } copy ( c . a . states [ n : ] , states ) c . a . addFreeBlock ( c . statesIndex ( ) , i1 ) c . setStatesIndex ( n ) states = c . a . states [ n : ] } } c . setNumStates ( ns + 1 ) return states [ : ns + 1 ] }
5493	func ( a * subAllocator ) pushByte ( c byte ) int32 { si := a . heap1Lo / 6 oi := a . heap1Lo % 6 switch oi { case 0 : a . states [ si ] . sym = c case 1 : a . states [ si ] . freq = c default : n := ( uint ( oi ) - 2 ) * 8 mask := ^ ( uint32 ( 0xFF ) << n ) succ := uint32 ( a . states [ si ] . succ ) & mask succ |= uint32 ( c ) << n a . states [ si ] . succ = int32 ( succ ) } a . heap1Lo ++ if a . heap1Lo >= a . heap1Hi { return 0 } return - a . heap1Lo }
5494	func ( a * subAllocator ) succByte ( i int32 ) byte { i = - i si := i / 6 oi := i % 6 switch oi { case 0 : return a . states [ si ] . sym case 1 : return a . states [ si ] . freq default : n := ( uint ( oi ) - 2 ) * 8 succ := uint32 ( a . states [ si ] . succ ) >> n return byte ( succ & 0xff ) } }
5495	func ( a * subAllocator ) succContext ( i int32 ) * context { if i <= 0 { return nil } return & context { i : i , s : a . states [ i : i + 2 : i + 2 ] , a : a } }
5496	func calcAes30Params ( pass [ ] uint16 , salt [ ] byte ) ( key , iv [ ] byte ) { p := make ( [ ] byte , 0 , len ( pass ) * 2 + len ( salt ) ) for _ , v := range pass { p = append ( p , byte ( v ) , byte ( v >> 8 ) ) } p = append ( p , salt ... ) hash := sha1 . New ( ) iv = make ( [ ] byte , 16 ) s := make ( [ ] byte , 0 , hash . Size ( ) ) for i := 0 ; i < hashRounds ; i ++ { hash . Write ( p ) hash . Write ( [ ] byte { byte ( i ) , byte ( i >> 8 ) , byte ( i >> 16 ) } ) if i % ( hashRounds / 16 ) == 0 { s = hash . Sum ( s [ : 0 ] ) iv [ i / ( hashRounds / 16 ) ] = s [ 4 * 4 + 3 ] } } key = hash . Sum ( s [ : 0 ] ) key = key [ : 16 ] for k := key ; len ( k ) >= 4 ; k = k [ 4 : ] { k [ 0 ] , k [ 1 ] , k [ 2 ] , k [ 3 ] = k [ 3 ] , k [ 2 ] , k [ 1 ] , k [ 0 ] } return key , iv }
5497	func parseDosTime ( t uint32 ) time . Time { n := int ( t ) sec := n & 0x1f << 1 min := n >> 5 & 0x3f hr := n >> 11 & 0x1f day := n >> 16 & 0x1f mon := time . Month ( n >> 21 & 0x0f ) yr := n >> 25 & 0x7f + 1980 return time . Date ( yr , mon , day , hr , min , sec , 0 , time . Local ) }
5498	func decodeName ( buf [ ] byte ) string { i := bytes . IndexByte ( buf , 0 ) if i < 0 { return string ( buf ) } name := buf [ : i ] encName := readBuf ( buf [ i + 1 : ] ) if len ( encName ) < 2 { return "" } highByte := uint16 ( encName . byte ( ) ) << 8 flags := encName . byte ( ) flagBits := 8 var wchars [ ] uint16 for len ( wchars ) < len ( name ) && len ( encName ) > 0 { if flagBits == 0 { flags = encName . byte ( ) flagBits = 8 if len ( encName ) == 0 { break } } switch flags >> 6 { case 0 : wchars = append ( wchars , uint16 ( encName . byte ( ) ) ) case 1 : wchars = append ( wchars , uint16 ( encName . byte ( ) ) | highByte ) case 2 : if len ( encName ) < 2 { break } wchars = append ( wchars , encName . uint16 ( ) ) case 3 : n := encName . byte ( ) b := name [ len ( wchars ) : ] if l := int ( n & 0x7f ) + 2 ; l < len ( b ) { b = b [ : l ] } if n & 0x80 > 0 { if len ( encName ) < 1 { break } ec := encName . byte ( ) for _ , c := range b { wchars = append ( wchars , uint16 ( c + ec ) | highByte ) } } else { for _ , c := range b { wchars = append ( wchars , uint16 ( c ) ) } } } flags <<= 2 flagBits -= 2 } return string ( utf16 . Decode ( wchars ) ) }
5499	func readExtTimes ( f * fileBlockHeader , b * readBuf ) { if len ( * b ) < 2 { return } flags := b . uint16 ( ) ts := [ ] * time . Time { & f . ModificationTime , & f . CreationTime , & f . AccessTime } for i , t := range ts { n := flags >> uint ( ( 3 - i ) * 4 ) if n & 0x8 == 0 { continue } if i != 0 { if len ( * b ) < 4 { return } * t = parseDosTime ( b . uint32 ( ) ) } if n & 0x4 > 0 { * t = t . Add ( time . Second ) } n &= 0x3 if n == 0 { continue } if len ( * b ) < int ( n ) { return } d := time . Duration ( 0 ) for j := 3 - n ; j < n ; j ++ { d |= time . Duration ( b . byte ( ) ) << ( j * 8 ) } d *= 100 * t = t . Add ( d ) } }
5500	func ( a * archive15 ) readBlockHeader ( ) ( * blockHeader15 , error ) { var err error b := a . buf [ : 7 ] r := io . Reader ( a . v ) if a . encrypted { salt := a . buf [ : saltSize ] _ , err = io . ReadFull ( r , salt ) if err != nil { return nil , err } key , iv := a . getKeys ( salt ) r = newAesDecryptReader ( r , key , iv ) err = readFull ( r , b ) } else { _ , err = io . ReadFull ( r , b ) } if err != nil { return nil , err } crc := b . uint16 ( ) hash := crc32 . NewIEEE ( ) hash . Write ( b ) h := new ( blockHeader15 ) h . htype = b . byte ( ) h . flags = b . uint16 ( ) size := b . uint16 ( ) if size < 7 { return nil , errCorruptHeader } size -= 7 if int ( size ) > cap ( a . buf ) { a . buf = readBuf ( make ( [ ] byte , size ) ) } h . data = a . buf [ : size ] if err := readFull ( r , h . data ) ; err != nil { return nil , err } hash . Write ( h . data ) if crc != uint16 ( hash . Sum32 ( ) ) { return nil , errBadHeaderCrc } if h . flags & blockHasData > 0 { if len ( h . data ) < 4 { return nil , errCorruptHeader } h . dataSize = int64 ( h . data . uint32 ( ) ) } if ( h . htype == blockService || h . htype == blockFile ) && h . flags & fileLargeData > 0 { if len ( h . data ) < 25 { return nil , errCorruptHeader } b := h . data [ 21 : 25 ] h . dataSize |= int64 ( b . uint32 ( ) ) << 32 } return h , nil }
5501	func newArchive15 ( r * bufio . Reader , password string ) fileBlockReader { a := new ( archive15 ) a . v = r a . pass = utf16 . Encode ( [ ] rune ( password ) ) a . checksum . Hash32 = crc32 . NewIEEE ( ) a . buf = readBuf ( make ( [ ] byte , 100 ) ) return a }
5502	func readFilter5Data ( br bitReader ) ( int , error ) { bytes , err := br . readBits ( 2 ) if err != nil { return 0 , err } bytes ++ var data int for i := 0 ; i < bytes ; i ++ { n , err := br . readBits ( 8 ) if err != nil { return 0 , err } data |= n << ( uint ( i ) * 8 ) } return data , nil }
5503	func ( w * window ) writeByte ( c byte ) { w . buf [ w . w ] = c w . w = ( w . w + 1 ) & w . mask }
5504	func ( w * window ) copyBytes ( len , off int ) { len &= w . mask n := w . available ( ) if len > n { w . l = len - n w . o = off len = n } i := ( w . w - off ) & w . mask for ; len > 0 ; len -- { w . buf [ w . w ] = w . buf [ i ] w . w = ( w . w + 1 ) & w . mask i = ( i + 1 ) & w . mask } }
5505	func ( w * window ) read ( p [ ] byte ) ( n int ) { if w . r > w . w { n = copy ( p , w . buf [ w . r : ] ) w . r = ( w . r + n ) & w . mask p = p [ n : ] } if w . r < w . w { l := copy ( p , w . buf [ w . r : w . w ] ) w . r += l n += l } if w . l > 0 && n > 0 { l := w . l w . l = 0 w . copyBytes ( l , w . o ) } return n }
5506	func ( d * decodeReader ) queueFilter ( f * filterBlock ) error { if f . reset { d . filters = nil } if len ( d . filters ) >= maxQueuedFilters { return errTooManyFilters } f . offset &= d . win . mask f . length &= d . win . mask for _ , fb := range d . filters { if f . offset < fb . offset { return errInvalidFilter } f . offset -= fb . offset } d . filters = append ( d . filters , f ) return nil }
5507	func ( d * decodeReader ) processFilters ( ) ( err error ) { f := d . filters [ 0 ] if f . offset > 0 { return nil } d . filters = d . filters [ 1 : ] if d . win . buffered ( ) < f . length { err = d . readErr ( ) if err == nil || err == io . EOF { return errInvalidFilter } return err } if cap ( d . buf ) < f . length { d . buf = make ( [ ] byte , f . length ) } d . outbuf = d . buf [ : f . length ] n := d . win . read ( d . outbuf ) for { d . outbuf , err = f . filter ( d . outbuf , d . tot ) if err != nil { return err } if cap ( d . outbuf ) > cap ( d . buf ) { d . buf = d . outbuf } if len ( d . filters ) == 0 { return nil } f = d . filters [ 0 ] if f . offset != 0 { f . offset -= n return nil } if f . length != len ( d . outbuf ) { return errInvalidFilter } d . filters = d . filters [ 1 : ] if cap ( d . outbuf ) < cap ( d . buf ) { d . outbuf = append ( d . buf [ : 0 ] , d . outbuf ... ) } } }
5508	func ( d * decodeReader ) fill ( ) { if d . err != nil { return } var fl [ ] * filterBlock fl , d . err = d . dec . fill ( & d . win ) for _ , f := range fl { err := d . queueFilter ( f ) if err != nil { d . err = err return } } }
5509	func ( d * decodeReader ) Read ( p [ ] byte ) ( n int , err error ) { if len ( d . outbuf ) == 0 { if d . win . buffered ( ) == 0 { d . fill ( ) if d . win . buffered ( ) == 0 { return 0 , d . readErr ( ) } } else if len ( d . filters ) > 0 { f := d . filters [ 0 ] if f . offset == 0 && f . length > d . win . buffered ( ) { d . fill ( ) } } if len ( d . filters ) > 0 { if err := d . processFilters ( ) ; err != nil { return 0 , err } } } if len ( d . outbuf ) > 0 { n = copy ( p , d . outbuf ) d . outbuf = d . outbuf [ n : ] } else if len ( d . filters ) > 0 { f := d . filters [ 0 ] if f . offset < len ( p ) { p = p [ : f . offset ] } n = d . win . read ( p ) f . offset -= n } else { n = d . win . read ( p ) } d . tot += int64 ( n ) return n , nil }
5510	func readFull ( r io . Reader , buf [ ] byte ) error { _ , err := io . ReadFull ( r , buf ) if err == io . EOF { return io . ErrUnexpectedEOF } return err }
5511	func findSig ( br * bufio . Reader ) ( int , error ) { for n := 0 ; n <= maxSfxSize ; { b , err := br . ReadSlice ( sigPrefix [ 0 ] ) n += len ( b ) if err == bufio . ErrBufferFull { continue } else if err != nil { if err == io . EOF { err = errNoSig } return 0 , err } b , err = br . Peek ( len ( sigPrefix [ 1 : ] ) + 2 ) if err != nil { if err == io . EOF { err = errNoSig } return 0 , err } if ! bytes . HasPrefix ( b , [ ] byte ( sigPrefix [ 1 : ] ) ) { continue } b = b [ len ( sigPrefix ) - 1 : ] var ver int switch { case b [ 0 ] == 0 : ver = fileFmt15 case b [ 0 ] == 1 && b [ 1 ] == 0 : ver = fileFmt50 default : continue } _ , _ = br . ReadSlice ( '\x00' ) return ver , nil } return 0 , errNoSig }
5512	func ( v * vm ) execute ( cmd [ ] command ) { v . ip = 0 for n := 0 ; n < maxCommands ; n ++ { ip := v . ip if ip >= uint32 ( len ( cmd ) ) { return } ins := cmd [ ip ] ins . f ( v , ins . bm , ins . op ) if v . ipMod { v . ipMod = false } else { v . ip ++ } } }
5513	func newVM ( mem [ ] byte ) * vm { v := new ( vm ) if cap ( mem ) < vmSize + 4 { v . m = make ( [ ] byte , vmSize + 4 ) copy ( v . m , mem ) } else { v . m = mem [ : vmSize + 4 ] for i := len ( mem ) ; i < len ( v . m ) ; i ++ { v . m [ i ] = 0 } } v . r [ 7 ] = vmSize return v }
5514	func limitBitReader ( br bitReader , n int , err error ) bitReader { return & limitedBitReader { br , n , err } }
5515	func ( r * rarBitReader ) readUint32 ( ) ( uint32 , error ) { n , err := r . readBits ( 2 ) if err != nil { return 0 , err } if n != 1 { n , err = r . readBits ( 4 << uint ( n ) ) return uint32 ( n ) , err } n , err = r . readBits ( 4 ) if err != nil { return 0 , err } if n == 0 { n , err = r . readBits ( 8 ) n |= - 1 << 8 return uint32 ( n ) , err } nlow , err := r . readBits ( 4 ) n = n << 4 | nlow return uint32 ( n ) , err }
5516	func step3 ( word * snowballword . SnowballWord ) bool { suffix , _ := word . RemoveFirstSuffixIn ( word . R2start , "ост", " о ть") ) т if suffix != "" { return true } }
5517	func Stem ( word string , stemStopwWords bool ) string { word = strings . ToLower ( strings . TrimSpace ( word ) ) if len ( word ) <= 2 || ( stemStopwWords == false && isStopWord ( word ) ) { return word } if specialVersion := stemSpecialWord ( word ) ; specialVersion != "" { word = specialVersion return word } w := snowballword . New ( word ) preprocess ( w ) step0 ( w ) step1a ( w ) step1b ( w ) step1c ( w ) step2 ( w ) step3 ( w ) step4 ( w ) step5 ( w ) postprocess ( w ) return w . String ( ) }
5518	func step6 ( word * snowballword . SnowballWord ) bool { numNonVowels := 0 for i := len ( word . RS ) - 1 ; i >= 0 ; i -- { r := word . RS [ i ] if isLowerVowel ( r ) == false { numNonVowels += 1 } else { if ( r == 233 || r == 232 ) && numNonVowels > 0 { word . RS [ i ] = 101 return true } return false } } return false }
5519	func step5 ( word * snowballword . SnowballWord ) bool { suffix , _ := word . FirstSuffix ( "enn" , "onn" , "ett" , "ell" , "eill" ) if suffix != "" { word . RemoveLastNRunes ( 1 ) } return false }
5520	func step2a ( word * snowballword . SnowballWord ) bool { suffix , suffixRunes := word . FirstSuffixIn ( word . RVstart , len ( word . RS ) , "ya" , "ye" , "yan" , "yen" , "yeron" , "yendo" , "yo" , "yó", , yas", y , yes", y ) , }
5521	func step4 ( word * snowballword . SnowballWord ) bool { if word . HasSuffixRunes ( [ ] rune ( "нн")) ) { { word . RemoveLastNRunes ( 1 ) return true } suffix , _ := word . RemoveFirstSuffix ( "ейше", "е е й ) ") if suffix != "" { if word . HasSuffixRunes ( [ ] rune ( "нн")) ) { { word . RemoveLastNRunes ( 1 ) } } }
5522	func Stem ( word , language string , stemStopWords bool ) ( stemmed string , err error ) { var f func ( string , bool ) string switch language { case "english" : f = english . Stem case "spanish" : f = spanish . Stem case "french" : f = french . Stem case "russian" : f = russian . Stem case "swedish" : f = swedish . Stem case "norwegian" : f = norwegian . Stem default : err = fmt . Errorf ( "Unknown language: %s" , language ) return } stemmed = f ( word , stemStopWords ) return }
5523	func step1c ( w * snowballword . SnowballWord ) bool { rsLen := len ( w . RS ) if len ( w . RS ) > 2 && ( w . RS [ rsLen - 1 ] == 121 || w . RS [ rsLen - 1 ] == 89 ) && ! isLowerVowel ( w . RS [ rsLen - 2 ] ) { w . RS [ rsLen - 1 ] = 105 return true } return false }
5524	func step3 ( w * snowballword . SnowballWord ) bool { suffix , suffixRunes := w . FirstSuffix ( "ational" , "tional" , "alize" , "icate" , "ative" , "iciti" , "ical" , "ful" , "ness" , ) if suffix == "" || len ( suffixRunes ) > len ( w . RS ) - w . R1start { return false } if suffix == "ative" { if len ( w . RS ) - w . R2start >= 5 { w . RemoveLastNRunes ( len ( suffixRunes ) ) return true } return false } var repl string switch suffix { case "ational" : repl = "ate" case "tional" : repl = "tion" case "alize" : repl = "al" case "icate" , "iciti" , "ical" : repl = "ic" case "ful" , "ness" : repl = "" } w . ReplaceSuffixRunes ( suffixRunes , [ ] rune ( repl ) , true ) return true }
5525	func isStopWord ( word string ) bool { switch word { case "au" , "aux" , "avec" , "ce" , "ces" , "dans" , "de" , "des" , "du" , "elle" , "en" , "et" , "eux" , "il" , "je" , "la" , "le" , "leur" , "lui" , "ma" , "mais" , "me" , "même", , mes", m , moi", m , , , , mon", , m , , , , ne", , n , , , "nos" , "notre" , "nous" , "on" , "ou" , "par" , "pas" , "pour" , "qu" , "que" , "qui" , "sa" , "se" , "ses" , "son" , "sur" , "ta" , "te" , "tes" , "toi" , "ton" , "tu" , "un" "une" "vos" "votre" "vous" "c" "d" "j" "l" "à", , m", , m , n", n , s", s , t", t , , , , y", , y , , été", é "étée", , , " , tées", "é , t , é , t , s", "éta , s , a , n , ", "étan n t , ", "étant t s , "étante , e s , , "suis" "es" "est" "sommes" , "êtes", , , , , sont", , s , , , , serai", , s , "seras" "sera" "serons" "serez" "seront" "serais" "serait" , "serions" , "seriez" , "seraient" , "étais", , , , , était", , é , "étions", , , , , étiez", , é , , " , taient", " , t , f , s", " , s , f , t", " , t , f , mes", "f , m , f , û , es", , e "furent" "sois" "soit" "soyons" "soyez" "soient" "fusse" "fusses" , "fût", , , , , fussions", , f , , , , fussiez", , f , , : } fussent", }
5526	func capitalizeYUI ( word * snowballword . SnowballWord ) { vowelPreviously := false vowelNext := func ( j int ) bool { return ( j + 1 < len ( word . RS ) && isLowerVowel ( word . RS [ j + 1 ] ) ) } for i := 0 ; i < len ( word . RS ) ; i ++ { if isLowerVowel ( word . RS [ i ] ) == false { vowelPreviously = false continue } vowelHere := true switch word . RS [ i ] { case 121 : if vowelPreviously || vowelNext ( i ) { word . RS [ i ] = 89 vowelHere = false } case 117 : if ( vowelPreviously && vowelNext ( i ) ) || ( i >= 1 && word . RS [ i - 1 ] == 113 ) { word . RS [ i ] = 85 vowelHere = false } case 105 : if vowelPreviously && vowelNext ( i ) { word . RS [ i ] = 73 vowelHere = false } } vowelPreviously = vowelHere } }
5527	func step2 ( w * snowballword . SnowballWord ) bool { suffix , suffixRunes := w . FirstSuffix ( "ational" , "fulness" , "iveness" , "ization" , "ousness" , "biliti" , "lessli" , "tional" , "alism" , "aliti" , "ation" , "entli" , "fulli" , "iviti" , "ousli" , "anci" , "abli" , "alli" , "ator" , "enci" , "izer" , "bli" , "ogi" , "li" , ) if suffix == "" || len ( suffixRunes ) > len ( w . RS ) - w . R1start { return false } switch suffix { case "li" : rsLen := len ( w . RS ) if rsLen >= 3 { switch w . RS [ rsLen - 3 ] { case 99 , 100 , 101 , 103 , 104 , 107 , 109 , 110 , 114 , 116 : w . RemoveLastNRunes ( len ( suffixRunes ) ) return true } } return false case "ogi" : rsLen := len ( w . RS ) if rsLen >= 4 && w . RS [ rsLen - 4 ] == 108 { w . ReplaceSuffixRunes ( suffixRunes , [ ] rune ( "og" ) , true ) } return true } var repl string switch suffix { case "tional" : repl = "tion" case "enci" : repl = "ence" case "anci" : repl = "ance" case "abli" : repl = "able" case "entli" : repl = "ent" case "izer" , "ization" : repl = "ize" case "ational" , "ation" , "ator" : repl = "ate" case "alism" , "aliti" , "alli" : repl = "al" case "fulness" : repl = "ful" case "ousli" , "ousness" : repl = "ous" case "iveness" , "iviti" : repl = "ive" case "biliti" , "bli" : repl = "ble" case "fulli" : repl = "ful" case "lessli" : repl = "less" } w . ReplaceSuffixRunes ( suffixRunes , [ ] rune ( repl ) , true ) return true }
5528	func step3 ( word * snowballword . SnowballWord ) bool { suffix , suffixRunes := word . FirstSuffixIfIn ( word . RVstart , len ( word . RS ) , "os" , "a" , "o" , "á", , í", í " ", " e , ) , " , é , }
5529	func step0 ( w * snowballword . SnowballWord ) bool { suffix , suffixRunes := w . FirstSuffix ( "'s'" , "'s" , "'" ) if suffix == "" { return false } w . RemoveLastNRunes ( len ( suffixRunes ) ) return true }
5530	func VnvSuffix ( word * snowballword . SnowballWord , f isVowelFunc , start int ) int { for i := 1 ; i < len ( word . RS [ start : ] ) ; i ++ { j := start + i if f ( word . RS [ j - 1 ] ) && ! f ( word . RS [ j ] ) { return j + 1 } } return len ( word . RS ) }
5531	func step1 ( w * snowballword . SnowballWord ) bool { suffixes := [ ] string { "heterna" , "hetens" , "anden" , "heten" , "heter" , "arnas" , "ernas" , "ornas" , "andes" , "arens" , "andet" , "arna" , "erna" , "orna" , "ande" , "arne" , "aste" , "aren" , "ades" , "erns" , "ade" , "are" , "ern" , "ens" , "het" , "ast" , "ad" , "en" , "ar" , "er" , "or" , "as" , "es" , "at" , "a" , "e" , "s" , } suffix , suffixRunes := w . FirstSuffixIn ( w . R1start , len ( w . RS ) , suffixes ... ) if suffix == "" || len ( suffixRunes ) > len ( w . RS ) - w . R1start { return false } if suffix == "s" { rsLen := len ( w . RS ) if rsLen >= 2 { switch w . RS [ rsLen - 2 ] { case 'b' , 'c' , 'd' , 'f' , 'g' , 'h' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'r' , 't' , 'v' , 'y' : w . RemoveLastNRunes ( len ( suffixRunes ) ) return true } } return false } w . RemoveLastNRunes ( len ( suffixRunes ) ) return true }
5532	func step2a ( word * snowballword . SnowballWord ) bool { suffix , suffixRunes := word . FirstSuffixIn ( word . RVstart , len ( word . RS ) , "issantes" , "issaIent" , "issions" , "issants" , "issante" , "iraIent" , "issons" , "issiez" , "issent" , "issant" , "issait" , "issais" , "irions" , "issez" , "isses" , "iront" , "irons" , "iriez" , "irent" , "irait" , "irais" , "îtes", , îmes", î " , sse", , s , , " , rez", r "iras" "irai" "ira" "ies" "ît", , it", i , ) , }
5533	func removePerfectiveGerundEnding ( word * snowballword . SnowballWord ) bool { suffix , suffixRunes := word . FirstSuffixIn ( word . RVstart , len ( word . RS ) , "ившись", "ывш ш и ь", "вшись", " ь и ши", "ывши", , ш , interpreted_string_literal , interpreted_string_literal , interpreted_string_literal , interpreted_string_literal , ) , вши", "ив" }
5534	func removeAdjectivalEnding ( word * snowballword . SnowballWord ) bool { suffix , _ := word . RemoveFirstSuffixIn ( word . RVstart , "ими", " ы и", "его и о " "ого", " му", "ом , interpreted_string_literal , interpreted_string_literal , м м у , "ее", , , " е", е "ые", , , interpreted_string_literal , interpreted_string_literal , " е", "е е е й , , "ий" , "ый", " , й", "е , interpreted_string_literal , interpreted_string_literal , ) й е }
5535	func step2b ( word * snowballword . SnowballWord ) bool { suffix , suffixRunes := word . FirstSuffixIn ( word . RVstart , len ( word . RS ) , "iésemos", , iéramos", i " ríamos", " r e íamos", "a , í a r amos", "ás a s e os", o "áramos", , , , ábamos", á " steis", s " ríais", " , r i emos", " e i seis", s "ierais" "eríais", , eremos", e , , , , asteis", , a , aríais", a " , remos", r "íamos", , irías", i " rían", " r i éis", "i , é i e es", "i e i e en", "i e i e on", o "ieras" "ieran" , "iendo" "erías", , erían", e " réis", " r a eis", e "arías", , , arían", a " réis", " r a ais", " a a ais", " a í is", "i , i , i , s e", e "iría", , irás", i " rán", " r interpreted_string_literal , i , os", " o i se", " s i ra", " r i os", " o i as", a "ería", , , , , erás", e " rán", " r a te", " t a es", " e a en", " e , a , ía", "a , í , a , r , ) s", s }
5536	func step4 ( word * snowballword . SnowballWord ) bool { hadChange := false if word . String ( ) == "voudrion" { log . Println ( "..." , word ) } if idx := len ( word . RS ) - 1 ; idx >= 1 && word . RS [ idx ] == 115 { switch word . RS [ idx - 1 ] { case 97 , 105 , 111 , 117 , 232 , 115 : return false default : word . RemoveLastNRunes ( 1 ) hadChange = true } } suffix , suffixRunes := word . FirstSuffixIn ( word . RVstart , len ( word . RS ) , "Ière", , ière", i " er", e " er", e , ) " }
5537	func step5 ( w * snowballword . SnowballWord ) bool { lri := len ( w . RS ) - 1 if w . R1start > lri { return false } if w . RS [ lri ] == 101 { if w . R2start <= lri || ! endsShortSyllable ( w , lri ) { w . ReplaceSuffix ( "e" , "" , true ) return true } return false } else if w . R2start <= lri && w . RS [ lri ] == 108 && lri - 1 >= 0 && w . RS [ lri - 1 ] == 108 { w . ReplaceSuffix ( "l" , "" , true ) return true } return false }
5538	func Stem ( word string , stemStopwWords bool ) string { word = strings . ToLower ( strings . TrimSpace ( word ) ) if len ( word ) <= 2 || ( stemStopwWords == false && isStopWord ( word ) ) { return word } w := snowballword . New ( word ) preprocess ( w ) step0 ( w ) changeInStep1 := step1 ( w ) if changeInStep1 == false { changeInStep2a := step2a ( w ) if changeInStep2a == false { step2b ( w ) } } step3 ( w ) postprocess ( w ) return w . String ( ) }
5539	func Stem ( word string , stemStopwWords bool ) string { word = strings . ToLower ( strings . TrimSpace ( word ) ) w := snowballword . New ( word ) if len ( w . RS ) <= 2 || ( stemStopwWords == false && isStopWord ( word ) ) { return word } preprocess ( w ) step1 ( w ) step2 ( w ) step3 ( w ) step4 ( w ) return w . String ( ) }
5540	func isStopWord ( word string ) bool { switch word { case "ut" , "få", , hadde", h , hva", h , tilbake", t , vil", v , han", h , , , , meget", , m , , , , men", , m , vi", v , , en", e , før", f "samme" "stille" "inn" "er" "kan" "makt" "ved" "forsøke", , hvis", h , part", p , , , rett", , r , , , "måte", , , , , denne", , d , , , , mer", , m , , , i", i , lang", l , ny", n , hans", h , , hvilken", h , tid", t , vite", v , her", h , opp", o , "var" "navn" , "mye" , "om" , "sant" , "tilstand" "der" "ikke" "mest" "punkt" "hvem" "skulle" "mange" "over" "vårt", , alle", a , arbeid", , a , , lik", l , like", l , gå", g " år", " å s den", d "å", , , begge", b , bruke", b , eller", e , og", o , til", t , da", d , , et", , e , , , , hvorfor", , h , nå", n " ist", i " lutt", l "deres" "det" : "hennes" } "så", }
5541	func isStopWord ( word string ) bool { switch word { case "och" , "det" , "att" , "i" , "en" , "jag" , "hon" , "som" , "han" , "på", , den", d , med", m , var", v , sig", s , , för", , f , , " , å", " , å , t , ll", " , l , ä , ", "m , m , e , ", , "ett" , "om" , "hade" , "de" , "av" "icke" "mig" "du" "henne" "då", , "sin" "nu" "har" "inte" "hans" "honom" "skulle" "hennes" "där", , , min", m , man", m , ej", e , vid", v , , kunde", , k , , , något", n " rån", " r u ", "när", , , , efter", , e , , , , upp", , u , , vi", v , dem", d , vara", v , vad", v , över", , ö , , " , n", n "dig" "kan" "sina" "här", , ha", , h , , , mot", m , alla", a , under", u , , någon", n "eller" "allt" "mycket" "sedan" "ju" "denna" "själv", , , detta", , d , "åt", , utan", u , varit", v , , , , hur", : h } , }
5542	func New ( in string ) ( word * SnowballWord ) { word = & SnowballWord { RS : [ ] rune ( in ) } word . R1start = len ( word . RS ) word . R2start = len ( word . RS ) word . RVstart = len ( word . RS ) return }
5543	func ( w * SnowballWord ) RemoveLastNRunes ( n int ) { w . RS = w . RS [ : len ( w . RS ) - n ] w . resetR1R2 ( ) }
5544	func ( w * SnowballWord ) resetR1R2 ( ) { rsLen := len ( w . RS ) if w . R1start > rsLen { w . R1start = rsLen } if w . R2start > rsLen { w . R2start = rsLen } if w . RVstart > rsLen { w . RVstart = rsLen } }
5545	func ( w * SnowballWord ) slice ( start , stop int ) [ ] rune { startMin := 0 if start < startMin { start = startMin } max := len ( w . RS ) - 1 if start > max { start = max } if stop > max { stop = max } return w . RS [ start : stop ] }
5546	func ( w * SnowballWord ) FitsInR1 ( x int ) bool { return w . R1start <= len ( w . RS ) - x }
5547	func ( w * SnowballWord ) FitsInR2 ( x int ) bool { return w . R2start <= len ( w . RS ) - x }
5548	func ( w * SnowballWord ) FitsInRV ( x int ) bool { return w . RVstart <= len ( w . RS ) - x }
5549	func ( w * SnowballWord ) FirstPrefix ( prefixes ... string ) ( foundPrefix string , foundPrefixRunes [ ] rune ) { found := false rsLen := len ( w . RS ) for _ , prefix := range prefixes { prefixRunes := [ ] rune ( prefix ) if len ( prefixRunes ) > rsLen { continue } found = true for i , r := range prefixRunes { if i > rsLen - 1 || ( w . RS ) [ i ] != r { found = false break } } if found { foundPrefix = prefix foundPrefixRunes = prefixRunes break } } return }
5550	func ( w * SnowballWord ) HasSuffixRunes ( suffixRunes [ ] rune ) bool { return w . HasSuffixRunesIn ( 0 , len ( w . RS ) , suffixRunes ) }
5551	func ( w * SnowballWord ) FirstSuffixIfIn ( startPos , endPos int , suffixes ... string ) ( suffix string , suffixRunes [ ] rune ) { for _ , suffix := range suffixes { suffixRunes := [ ] rune ( suffix ) if w . HasSuffixRunesIn ( 0 , endPos , suffixRunes ) { if endPos - len ( suffixRunes ) >= startPos { return suffix , suffixRunes } else { suffixRunes = suffixRunes [ : 0 ] return "" , suffixRunes } } } suffixRunes = suffixRunes [ : 0 ] return "" , suffixRunes }
5552	func ( w * SnowballWord ) RemoveFirstSuffixIfIn ( startPos int , suffixes ... string ) ( suffix string , suffixRunes [ ] rune ) { suffix , suffixRunes = w . FirstSuffixIfIn ( startPos , len ( w . RS ) , suffixes ... ) if suffix != "" { w . RemoveLastNRunes ( len ( suffixRunes ) ) } return }
5553	func ( w * SnowballWord ) RemoveFirstSuffix ( suffixes ... string ) ( suffix string , suffixRunes [ ] rune ) { return w . RemoveFirstSuffixIn ( 0 , suffixes ... ) }
5554	func ( w * SnowballWord ) FirstSuffix ( suffixes ... string ) ( suffix string , suffixRunes [ ] rune ) { return w . FirstSuffixIfIn ( 0 , len ( w . RS ) , suffixes ... ) }
5555	func preprocess ( word * snowballword . SnowballWord ) { normalizeApostrophes ( word ) trimLeftApostrophes ( word ) capitalizeYs ( word ) r1start , r2start := r1r2 ( word ) word . R1start = r1start word . R2start = r2start }
5556	func step0 ( word * snowballword . SnowballWord ) bool { suffix1 , suffix1Runes := word . FirstSuffixIn ( word . RVstart , len ( word . RS ) , "selas" , "selos" , "sela" , "selo" , "las" , "les" , "los" , "nos" , "me" , "se" , "la" , "le" , "lo" , ) if suffix1 == "" { return false } suffix2 , suffix2Runes := word . FirstSuffixIn ( word . RVstart , len ( word . RS ) - len ( suffix1 ) , "iéndo", , iendo", i , yendo", y , , ando", a , ándo", á "ár", , , ) ér", é }
5557	func step1b ( w * snowballword . SnowballWord ) bool { suffix , suffixRunes := w . FirstSuffix ( "eedly" , "ingly" , "edly" , "ing" , "eed" , "ed" ) switch suffix { case "" : return false case "eed" , "eedly" : if len ( suffixRunes ) <= len ( w . RS ) - w . R1start { w . ReplaceSuffixRunes ( suffixRunes , [ ] rune ( "ee" ) , true ) } return true case "ed" , "edly" , "ing" , "ingly" : hasLowerVowel := false for i := 0 ; i < len ( w . RS ) - len ( suffixRunes ) ; i ++ { if isLowerVowel ( w . RS [ i ] ) { hasLowerVowel = true break } } if hasLowerVowel { originalR1start := w . R1start originalR2start := w . R2start w . RemoveLastNRunes ( len ( suffixRunes ) ) newSuffix , newSuffixRunes := w . FirstSuffix ( "at" , "bl" , "iz" , "bb" , "dd" , "ff" , "gg" , "mm" , "nn" , "pp" , "rr" , "tt" ) switch newSuffix { case "" : if isShortWord ( w ) { w . RS = append ( w . RS , [ ] rune ( "e" ) ... ) w . R1start = len ( w . RS ) w . R2start = len ( w . RS ) return true } case "at" , "bl" , "iz" : w . ReplaceSuffixRunes ( newSuffixRunes , [ ] rune ( newSuffix + "e" ) , true ) case "bb" , "dd" , "ff" , "gg" , "mm" , "nn" , "pp" , "rr" , "tt" : w . RemoveLastNRunes ( 1 ) } rsLen := len ( w . RS ) if originalR1start < rsLen { w . R1start = originalR1start } else { w . R1start = rsLen } if originalR2start < rsLen { w . R2start = originalR2start } else { w . R2start = rsLen } return true } } return false }
5558	func step2b ( word * snowballword . SnowballWord ) bool { suffix , suffixRunes := word . FirstSuffixIn ( word . RVstart , len ( word . RS ) , "eraIent" , "assions" , "erions" , "assiez" , "assent" , "èrent", , eront", e , erons", e , , eriez", , e , , , erait", e , , erais", , e , , , "asses" , "antes" , "aIent" , "âtes", , , , , âmes", , â , , " ons", o "erez" "eras" , "erai" , "asse" , "ants" , "ante" , "ées", , "iez" , ) "era" "ant" }
5559	func capitalizeYs ( word * snowballword . SnowballWord ) ( numCapitalizations int ) { for i , r := range word . RS { if r == 121 && ( i == 0 || isLowerVowel ( word . RS [ i - 1 ] ) ) { word . RS [ i ] = 89 numCapitalizations += 1 } } return }
5560	func uncapitalizeYs ( word * snowballword . SnowballWord ) { for i , r := range word . RS { if r == 89 { word . RS [ i ] = 121 } } return }
5561	func stemSpecialWord ( word string ) ( stemmed string ) { switch word { case "skis" : stemmed = "ski" case "skies" : stemmed = "sky" case "dying" : stemmed = "die" case "lying" : stemmed = "lie" case "tying" : stemmed = "tie" case "idly" : stemmed = "idl" case "gently" : stemmed = "gentl" case "ugly" : stemmed = "ugli" case "early" : stemmed = "earli" case "only" : stemmed = "onli" case "singly" : stemmed = "singl" case "sky" : stemmed = "sky" case "news" : stemmed = "news" case "howe" : stemmed = "howe" case "atlas" : stemmed = "atlas" case "cosmos" : stemmed = "cosmos" case "bias" : stemmed = "bias" case "andes" : stemmed = "andes" case "inning" : stemmed = "inning" case "innings" : stemmed = "inning" case "outing" : stemmed = "outing" case "outings" : stemmed = "outing" case "canning" : stemmed = "canning" case "cannings" : stemmed = "canning" case "herring" : stemmed = "herring" case "herrings" : stemmed = "herring" case "earring" : stemmed = "earring" case "earrings" : stemmed = "earring" case "proceed" : stemmed = "proceed" case "proceeds" : stemmed = "proceed" case "proceeded" : stemmed = "proceed" case "proceeding" : stemmed = "proceed" case "exceed" : stemmed = "exceed" case "exceeds" : stemmed = "exceed" case "exceeded" : stemmed = "exceed" case "exceeding" : stemmed = "exceed" case "succeed" : stemmed = "succeed" case "succeeds" : stemmed = "succeed" case "succeeded" : stemmed = "succeed" case "succeeding" : stemmed = "succeed" } return }
5562	func isShortWord ( w * snowballword . SnowballWord ) ( isShort bool ) { if w . R1start < len ( w . RS ) { return } return endsShortSyllable ( w , len ( w . RS ) ) }
5563	func step1a ( w * snowballword . SnowballWord ) bool { suffix , suffixRunes := w . FirstSuffix ( "sses" , "ied" , "ies" , "us" , "ss" , "s" ) switch suffix { case "sses" : w . ReplaceSuffixRunes ( suffixRunes , [ ] rune ( "ss" ) , true ) return true case "ies" , "ied" : var repl string if len ( w . RS ) > 4 { repl = "i" } else { repl = "ie" } w . ReplaceSuffixRunes ( suffixRunes , [ ] rune ( repl ) , true ) return true case "us" , "ss" : return false case "s" : for i := 0 ; i < len ( w . RS ) - 2 ; i ++ { if isLowerVowel ( w . RS [ i ] ) { w . RemoveLastNRunes ( len ( suffixRunes ) ) return true } } } return false }
5564	func Set ( key string , value interface { } ) { gid := curGoroutineID ( ) dataLock . Lock ( ) if data [ gid ] == nil { data [ gid ] = Values { } } data [ gid ] [ key ] = value dataLock . Unlock ( ) }
5565	func Get ( key string ) interface { } { gid := curGoroutineID ( ) dataLock . RLock ( ) if data [ gid ] == nil { dataLock . RUnlock ( ) return nil } value := data [ gid ] [ key ] dataLock . RUnlock ( ) return value }
5566	func Cleanup ( ) { gid := curGoroutineID ( ) dataLock . Lock ( ) delete ( data , gid ) dataLock . Unlock ( ) }
5567	func getValues ( ) Values { gid := curGoroutineID ( ) dataLock . Lock ( ) values := data [ gid ] dataLock . Unlock ( ) return values }
5568	func linkGRs ( parentData Values ) { childID := curGoroutineID ( ) dataLock . Lock ( ) data [ childID ] = parentData dataLock . Unlock ( ) }
5569	func unlinkGRs ( ) { childID := curGoroutineID ( ) dataLock . Lock ( ) delete ( data , childID ) dataLock . Unlock ( ) }
5570	func AppUri ( appName , path string , config helpersinternal . CurlConfig ) string { uriCreator := & helpersinternal . AppUriCreator { CurlConfig : config } return uriCreator . AppUri ( appName , path ) }
5571	func CurlAppWithTimeout ( cfg helpersinternal . CurlConfig , appName , path string , timeout time . Duration , args ... string ) string { appCurler := helpersinternal . NewAppCurler ( Curl , cfg ) return appCurler . CurlAndWait ( cfg , appName , path , timeout , args ... ) }
5572	func CurlApp ( cfg helpersinternal . CurlConfig , appName , path string , args ... string ) string { appCurler := helpersinternal . NewAppCurler ( Curl , cfg ) return appCurler . CurlAndWait ( cfg , appName , path , CURL_TIMEOUT , args ... ) }
5573	func CurlAppRoot ( cfg helpersinternal . CurlConfig , appName string ) string { appCurler := helpersinternal . NewAppCurler ( Curl , cfg ) return appCurler . CurlAndWait ( cfg , appName , "/" , CURL_TIMEOUT ) }
5574	func GetTags ( prefix rune , str string , terminator ... rune ) ( tags [ ] Tag ) { if len ( terminator ) == 0 { terminator = [ ] rune ( " " ) } termIndexes := [ ] int { - 1 } for i , char := range str { if isTerminator ( char , terminator ... ) { termIndexes = append ( termIndexes , i ) } } termIndexes = append ( termIndexes , len ( str ) ) for i , t := range termIndexes { if t >= ( len ( str ) - 1 ) { break } if str [ t + 1 ] == byte ( prefix ) { tagText := strings . TrimLeft ( str [ t + 2 : termIndexes [ i + 1 ] ] , string ( prefix ) ) if tagText == "" { continue } index := t + 1 tags = append ( tags , Tag { prefix , tagText , index } ) } } return }
5575	func GetTagsAsUniqueStrings ( prefix rune , str string , terminator ... rune ) ( strs [ ] string ) { tags := GetTags ( prefix , str , terminator ... ) for _ , tag := range tags { strs = append ( strs , tag . Tag ) } return uniquify ( strs ) }
5576	func isTerminator ( r rune , terminator ... rune ) bool { for _ , t := range terminator { if r == t { return true } } return unicode . IsSpace ( r ) || ! unicode . IsPrint ( r ) }
5577	func uniquify ( in [ ] string ) ( out [ ] string ) { for _ , i := range in { if i == "" { continue } for _ , o := range out { if i == o { continue } } out = append ( out , i ) } return }
5578	func New ( config Config ) gin . HandlerFunc { location := newLocation ( config ) return func ( c * gin . Context ) { location . applyToContext ( c ) } }
5579	func Get ( c * gin . Context ) * url . URL { v , ok := c . Get ( key ) if ! ok { return nil } vv , ok := v . ( * url . URL ) if ! ok { return nil } return vv }
5580	func GenerateRSAKeyPair ( bits int , src io . Reader ) ( PrivKey , PubKey , error ) { if bits < 512 { return nil , nil , ErrRsaKeyTooSmall } priv , err := rsa . GenerateKey ( src , bits ) if err != nil { return nil , nil , err } pk := & priv . PublicKey return & RsaPrivateKey { sk : priv } , & RsaPublicKey { pk } , nil }
5581	func ( pk * RsaPublicKey ) Verify ( data , sig [ ] byte ) ( bool , error ) { hashed := sha256 . Sum256 ( data ) err := rsa . VerifyPKCS1v15 ( pk . k , crypto . SHA256 , hashed [ : ] , sig ) if err != nil { return false , err } return true , nil }
5582	func ( pk * RsaPublicKey ) Encrypt ( b [ ] byte ) ( [ ] byte , error ) { return rsa . EncryptPKCS1v15 ( rand . Reader , pk . k , b ) }
5583	func ( sk * RsaPrivateKey ) Sign ( message [ ] byte ) ( [ ] byte , error ) { hashed := sha256 . Sum256 ( message ) return rsa . SignPKCS1v15 ( rand . Reader , sk . sk , crypto . SHA256 , hashed [ : ] ) }
5584	func ( sk * RsaPrivateKey ) GetPublic ( ) PubKey { if sk . pk == nil { sk . pk = & sk . sk . PublicKey } return & RsaPublicKey { sk . pk } }
5585	func ( sk * RsaPrivateKey ) Decrypt ( b [ ] byte ) ( [ ] byte , error ) { return rsa . DecryptPKCS1v15 ( rand . Reader , sk . sk , b ) }
5586	func UnmarshalRsaPrivateKey ( b [ ] byte ) ( PrivKey , error ) { sk , err := x509 . ParsePKCS1PrivateKey ( b ) if err != nil { return nil , err } if sk . N . BitLen ( ) < 512 { return nil , ErrRsaKeyTooSmall } return & RsaPrivateKey { sk : sk } , nil }
5587	func GenerateKeyPair ( typ , bits int ) ( PrivKey , PubKey , error ) { return GenerateKeyPairWithReader ( typ , bits , rand . Reader ) }
5588	func GenerateKeyPairWithReader ( typ , bits int , src io . Reader ) ( PrivKey , PubKey , error ) { switch typ { case RSA : return GenerateRSAKeyPair ( bits , src ) case Ed25519 : return GenerateEd25519Key ( src ) case Secp256k1 : return GenerateSecp256k1Key ( src ) case ECDSA : return GenerateECDSAKeyPair ( src ) default : return nil , nil , ErrBadKeyType } }
5589	func GenerateEKeyPair ( curveName string ) ( [ ] byte , GenSharedKey , error ) { var curve elliptic . Curve switch curveName { case "P-256" : curve = elliptic . P256 ( ) case "P-384" : curve = elliptic . P384 ( ) case "P-521" : curve = elliptic . P521 ( ) } priv , x , y , err := elliptic . GenerateKey ( curve , rand . Reader ) if err != nil { return nil , nil , err } pubKey := elliptic . Marshal ( curve , x , y ) done := func ( theirPub [ ] byte ) ( [ ] byte , error ) { x , y := elliptic . Unmarshal ( curve , theirPub ) if x == nil { return nil , fmt . Errorf ( "malformed public key: %d %v" , len ( theirPub ) , theirPub ) } if ! curve . IsOnCurve ( x , y ) { return nil , errors . New ( "invalid public key" ) } secret , _ := curve . ScalarMult ( x , y , priv ) return secret . Bytes ( ) , nil } return pubKey , done , nil }
5590	func UnmarshalPublicKey ( data [ ] byte ) ( PubKey , error ) { pmes := new ( pb . PublicKey ) err := proto . Unmarshal ( data , pmes ) if err != nil { return nil , err } um , ok := PubKeyUnmarshallers [ pmes . GetType ( ) ] if ! ok { return nil , ErrBadKeyType } return um ( pmes . GetData ( ) ) }
5591	func MarshalPublicKey ( k PubKey ) ( [ ] byte , error ) { pbmes := new ( pb . PublicKey ) pbmes . Type = k . Type ( ) data , err := k . Raw ( ) if err != nil { return nil , err } pbmes . Data = data return proto . Marshal ( pbmes ) }
5592	func UnmarshalPrivateKey ( data [ ] byte ) ( PrivKey , error ) { pmes := new ( pb . PrivateKey ) err := proto . Unmarshal ( data , pmes ) if err != nil { return nil , err } um , ok := PrivKeyUnmarshallers [ pmes . GetType ( ) ] if ! ok { return nil , ErrBadKeyType } return um ( pmes . GetData ( ) ) }
5593	func MarshalPrivateKey ( k PrivKey ) ( [ ] byte , error ) { pbmes := new ( pb . PrivateKey ) pbmes . Type = k . Type ( ) data , err := k . Raw ( ) if err != nil { return nil , err } pbmes . Data = data return proto . Marshal ( pbmes ) }
5594	func KeyEqual ( k1 , k2 Key ) bool { if k1 == k2 { return true } b1 , err1 := k1 . Bytes ( ) b2 , err2 := k2 . Bytes ( ) return bytes . Equal ( b1 , b2 ) && err1 == err2 }
5595	func GenerateECDSAKeyPair ( src io . Reader ) ( PrivKey , PubKey , error ) { return GenerateECDSAKeyPairWithCurve ( ECDSACurve , src ) }
5596	func GenerateECDSAKeyPairWithCurve ( curve elliptic . Curve , src io . Reader ) ( PrivKey , PubKey , error ) { priv , err := ecdsa . GenerateKey ( curve , src ) if err != nil { return nil , nil , err } return & ECDSAPrivateKey { priv } , & ECDSAPublicKey { & priv . PublicKey } , nil }
5597	func ECDSAKeyPairFromKey ( priv * ecdsa . PrivateKey ) ( PrivKey , PubKey , error ) { if priv == nil { return nil , nil , ErrNilPrivateKey } return & ECDSAPrivateKey { priv } , & ECDSAPublicKey { & priv . PublicKey } , nil }
5598	func UnmarshalECDSAPrivateKey ( data [ ] byte ) ( PrivKey , error ) { priv , err := x509 . ParseECPrivateKey ( data ) if err != nil { return nil , err } return & ECDSAPrivateKey { priv } , nil }
5599	func UnmarshalECDSAPublicKey ( data [ ] byte ) ( PubKey , error ) { pubIfc , err := x509 . ParsePKIXPublicKey ( data ) if err != nil { return nil , err } pub , ok := pubIfc . ( * ecdsa . PublicKey ) if ! ok { return nil , ErrNotECDSAPubKey } return & ECDSAPublicKey { pub } , nil }
5600	func ( ePriv * ECDSAPrivateKey ) Equals ( o Key ) bool { oPriv , ok := o . ( * ECDSAPrivateKey ) if ! ok { return false } return ePriv . priv . D . Cmp ( oPriv . priv . D ) == 0 }
5601	func ( ePriv * ECDSAPrivateKey ) Sign ( data [ ] byte ) ( [ ] byte , error ) { hash := sha256 . Sum256 ( data ) r , s , err := ecdsa . Sign ( rand . Reader , ePriv . priv , hash [ : ] ) if err != nil { return nil , err } return asn1 . Marshal ( ECDSASig { R : r , S : s , } ) }
5602	func ( ePub * ECDSAPublicKey ) Equals ( o Key ) bool { oPub , ok := o . ( * ECDSAPublicKey ) if ! ok { return false } return ePub . pub . X != nil && ePub . pub . Y != nil && oPub . pub . X != nil && oPub . pub . Y != nil && 0 == ePub . pub . X . Cmp ( oPub . pub . X ) && 0 == ePub . pub . Y . Cmp ( oPub . pub . Y ) }
5603	func ( ePub * ECDSAPublicKey ) Verify ( data , sigBytes [ ] byte ) ( bool , error ) { sig := new ( ECDSASig ) if _ , err := asn1 . Unmarshal ( sigBytes , sig ) ; err != nil { return false , err } if sig == nil { return false , ErrNilSig } hash := sha256 . Sum256 ( data ) return ecdsa . Verify ( ePub . pub , hash [ : ] , sig . R , sig . S ) , nil }
5604	func GenerateSecp256k1Key ( src io . Reader ) ( PrivKey , PubKey , error ) { privk , err := btcec . NewPrivateKey ( btcec . S256 ( ) ) if err != nil { return nil , nil , err } k := ( * Secp256k1PrivateKey ) ( privk ) return k , k . GetPublic ( ) , nil }
5605	func UnmarshalSecp256k1PrivateKey ( data [ ] byte ) ( PrivKey , error ) { if len ( data ) != btcec . PrivKeyBytesLen { return nil , fmt . Errorf ( "expected secp256k1 data size to be %d" , btcec . PrivKeyBytesLen ) } privk , _ := btcec . PrivKeyFromBytes ( btcec . S256 ( ) , data ) return ( * Secp256k1PrivateKey ) ( privk ) , nil }
5606	func UnmarshalSecp256k1PublicKey ( data [ ] byte ) ( PubKey , error ) { k , err := btcec . ParsePubKey ( data , btcec . S256 ( ) ) if err != nil { return nil , err } return ( * Secp256k1PublicKey ) ( k ) , nil }
5607	func ( k * Secp256k1PrivateKey ) Equals ( o Key ) bool { sk , ok := o . ( * Secp256k1PrivateKey ) if ! ok { return false } return k . D . Cmp ( sk . D ) == 0 }
5608	func ( k * Secp256k1PrivateKey ) Sign ( data [ ] byte ) ( [ ] byte , error ) { hash := sha256 . Sum256 ( data ) sig , err := ( * btcec . PrivateKey ) ( k ) . Sign ( hash [ : ] ) if err != nil { return nil , err } return sig . Serialize ( ) , nil }
5609	func ( k * Secp256k1PublicKey ) Equals ( o Key ) bool { sk , ok := o . ( * Secp256k1PublicKey ) if ! ok { return false } return ( * btcec . PublicKey ) ( k ) . IsEqual ( ( * btcec . PublicKey ) ( sk ) ) }
5610	func ( k * Secp256k1PublicKey ) Verify ( data [ ] byte , sigStr [ ] byte ) ( bool , error ) { sig , err := btcec . ParseDERSignature ( sigStr , btcec . S256 ( ) ) if err != nil { return false , err } hash := sha256 . Sum256 ( data ) return sig . Verify ( hash [ : ] , ( * btcec . PublicKey ) ( k ) ) , nil }
5611	func ( k * Ed25519PrivateKey ) Raw ( ) ( [ ] byte , error ) { buf := make ( [ ] byte , len ( k . k ) ) copy ( buf , k . k ) return buf , nil }
5612	func ( k * Ed25519PrivateKey ) Sign ( msg [ ] byte ) ( [ ] byte , error ) { return ed25519 . Sign ( k . k , msg ) , nil }
5613	func ( k * Ed25519PublicKey ) Equals ( o Key ) bool { edk , ok := o . ( * Ed25519PublicKey ) if ! ok { return false } return bytes . Equal ( k . k , edk . k ) }
5614	func ( k * Ed25519PublicKey ) Verify ( data [ ] byte , sig [ ] byte ) ( bool , error ) { return ed25519 . Verify ( k . k , data , sig ) , nil }
5615	func UnmarshalEd25519PublicKey ( data [ ] byte ) ( PubKey , error ) { if len ( data ) != 32 { return nil , errors . New ( "expect ed25519 public key data size to be 32" ) } return & Ed25519PublicKey { k : ed25519 . PublicKey ( data ) , } , nil }
5616	func UnmarshalEd25519PrivateKey ( data [ ] byte ) ( PrivKey , error ) { switch len ( data ) { case ed25519 . PrivateKeySize + ed25519 . PublicKeySize : redundantPk := data [ ed25519 . PrivateKeySize : ] pk := data [ ed25519 . PrivateKeySize - ed25519 . PublicKeySize : ed25519 . PrivateKeySize ] if ! bytes . Equal ( pk , redundantPk ) { return nil , errors . New ( "expected redundant ed25519 public key to be redundant" ) } newKey := make ( [ ] byte , ed25519 . PrivateKeySize ) copy ( newKey , data [ : ed25519 . PrivateKeySize ] ) data = newKey case ed25519 . PrivateKeySize : default : return nil , fmt . Errorf ( "expected ed25519 data size to be %d or %d, got %d" , ed25519 . PrivateKeySize , ed25519 . PrivateKeySize + ed25519 . PublicKeySize , len ( data ) , ) } return & Ed25519PrivateKey { k : ed25519 . PrivateKey ( data ) , } , nil }
5617	func EditScriptForStrings ( source [ ] rune , target [ ] rune , op Options ) EditScript { return backtrace ( len ( source ) , len ( target ) , MatrixForStrings ( source , target , op ) , op ) }
5618	func EditScriptForMatrix ( matrix [ ] [ ] int , op Options ) EditScript { return backtrace ( len ( matrix ) - 1 , len ( matrix [ 0 ] ) - 1 , matrix , op ) }
5619	func WriteMatrix ( source [ ] rune , target [ ] rune , matrix [ ] [ ] int , writer io . Writer ) { fmt . Fprintf ( writer , " " ) for _ , targetRune := range target { fmt . Fprintf ( writer , " %c" , targetRune ) } fmt . Fprintf ( writer , "\n" ) \n fmt . Fprintf ( writer , " %2d" , matrix [ 0 ] [ 0 ] ) for j , _ := range target { fmt . Fprintf ( writer , " %2d" , matrix [ 0 ] [ j + 1 ] ) } fmt . Fprintf ( writer , "\n" ) }
5620	func New ( path string ) ( Lockfile , error ) { if ! filepath . IsAbs ( path ) { return Lockfile ( "" ) , ErrNeedAbsPath } return Lockfile ( path ) , nil }
5621	func ( l Lockfile ) GetOwner ( ) ( * os . Process , error ) { name := string ( l ) content , err := ioutil . ReadFile ( name ) if err != nil { return nil , err } pid , err := scanPidLine ( content ) if err != nil { return nil , err } running , err := isRunning ( pid ) if err != nil { return nil , err } if running { proc , err := os . FindProcess ( pid ) if err != nil { return nil , err } return proc , nil } return nil , ErrDeadOwner }
5622	func ( l Lockfile ) TryLock ( ) error { name := string ( l ) if ! filepath . IsAbs ( name ) { panic ( ErrNeedAbsPath ) } tmplock , err := ioutil . TempFile ( filepath . Dir ( name ) , filepath . Base ( name ) + "." ) if err != nil { return err } cleanup := func ( ) { _ = tmplock . Close ( ) _ = os . Remove ( tmplock . Name ( ) ) } defer cleanup ( ) if err := writePidLine ( tmplock , os . Getpid ( ) ) ; err != nil { return err } if err := os . Link ( tmplock . Name ( ) , name ) ; err != nil { if ! os . IsExist ( err ) { return err } } fiTmp , err := os . Lstat ( tmplock . Name ( ) ) if err != nil { return err } fiLock , err := os . Lstat ( name ) if err != nil { if os . IsNotExist ( err ) { return ErrNotExist } return err } if os . SameFile ( fiTmp , fiLock ) { return nil } proc , err := l . GetOwner ( ) switch err { default : return err case nil : if proc . Pid != os . Getpid ( ) { return ErrBusy } case ErrDeadOwner , ErrInvalidPid : } err = os . Remove ( name ) if err != nil { if ! os . IsNotExist ( err ) { return err } } return l . TryLock ( ) }
5623	func ( l Lockfile ) Unlock ( ) error { proc , err := l . GetOwner ( ) switch err { case ErrInvalidPid , ErrDeadOwner : return ErrRogueDeletion case nil : if proc . Pid == os . Getpid ( ) { return os . Remove ( string ( l ) ) } return ErrRogueDeletion default : if os . IsNotExist ( err ) { return ErrRogueDeletion } return err } }
5624	func NewBase ( configs ... baseConfigFunc ) * Base { b := & Base { clock : glock . NewRealClock ( ) , config : NewConfig ( ) , logLevel : LevelDebug , sequence : 0 , BaseAttrs : NewAttrs ( ) , loggers : make ( [ ] Logger , 0 ) , hookPreQueue : make ( [ ] HookPreQueue , 0 ) , } for _ , f := range configs { f ( b ) } return b }
5625	func ( b * Base ) SetFallbackLogger ( logger Logger ) error { if logger == nil { if b . fallbackLogger != nil && b . fallbackLogger . IsInitialized ( ) { b . fallbackLogger . ShutdownLogger ( ) } b . fallbackLogger = nil return nil } if ! logger . IsInitialized ( ) { err := logger . InitLogger ( ) if err != nil { return err } } if b . fallbackLogger != nil && b . fallbackLogger . IsInitialized ( ) { b . fallbackLogger . ShutdownLogger ( ) } b . fallbackLogger = logger return nil }
5626	func ( b * Base ) AddLogger ( logger Logger ) error { if b . IsInitialized ( ) && ! logger . IsInitialized ( ) { err := logger . InitLogger ( ) if err != nil { return err } } else if ! b . IsInitialized ( ) && logger . IsInitialized ( ) { err := logger . ShutdownLogger ( ) if err != nil { return err } } b . loggers = append ( b . loggers , logger ) if hook , ok := logger . ( HookPreQueue ) ; ok { b . hookPreQueue = append ( b . hookPreQueue , hook ) } logger . SetBase ( b ) return nil }
5627	func ( b * Base ) LogWithTime ( level LogLevel , ts time . Time , m * Attrs , msg string , a ... interface { } ) error { if ! b . shouldLog ( level ) { return nil } if ! b . isInitialized { return ErrNotInitialized } if len ( b . config . FilenameAttr ) > 0 || len ( b . config . LineNumberAttr ) > 0 { file , line := getCallerInfo ( ) if m == nil { m = NewAttrs ( ) } if len ( b . config . FilenameAttr ) > 0 { m . SetAttr ( b . config . FilenameAttr , file ) } if len ( b . config . LineNumberAttr ) > 0 { m . SetAttr ( b . config . LineNumberAttr , line ) } } if len ( b . config . SequenceAttr ) > 0 { if m == nil { m = NewAttrs ( ) } seq := atomic . AddUint64 ( & b . sequence , 1 ) m . SetAttr ( b . config . SequenceAttr , seq ) } nm := newMessage ( ts , b , level , m , msg , a ... ) for _ , hook := range b . hookPreQueue { err := hook . PreQueue ( nm ) if err != nil { return err } } return b . queue . queueMessage ( nm ) }
5628	func ( b * Base ) Log ( level LogLevel , m * Attrs , msg string , a ... interface { } ) error { return b . LogWithTime ( level , b . clock . Now ( ) , m , msg , a ... ) }
5629	func ( b * Base ) Warnm ( m * Attrs , msg string , a ... interface { } ) error { return b . Warningm ( m , msg , a ... ) }
5630	func NewTemplateWithFuncMap ( tpl string , funcMap template . FuncMap ) ( * Template , error ) { var levels = [ ] LogLevel { LevelNone , LevelDebug , LevelInfo , LevelWarning , LevelError , LevelFatal } tpls := make ( map [ LogLevel ] * template . Template , 0 ) for _ , level := range levels { _ , forceReset := funcMap [ "color" ] fMap := getFuncMap ( level , forceReset ) for name , f := range funcMap { fMap [ name ] = f } parsedTpl , err := template . New ( getLevelName ( level ) ) . Funcs ( fMap ) . Parse ( tpl ) if err != nil { return nil , err } tpls [ level ] = parsedTpl } newTpl := & Template { tpls : tpls , } return newTpl , nil }
5631	func ( t * Template ) Execute ( msg * TemplateMsg , colorize bool ) ( string , error ) { tplLevel := msg . Level if ! colorize { tplLevel = LevelNone } var buf bytes . Buffer execTpl := t . tpls [ tplLevel ] if execTpl == nil { return "" , ErrUnknownLevel } err := execTpl . Execute ( & buf , msg ) if err != nil { return "" , err } return buf . String ( ) , nil }
5632	func NewTemplateMsg ( timestamp time . Time , level LogLevel , m map [ string ] interface { } , msg string ) * TemplateMsg { msgAttrs := m if msgAttrs == nil { msgAttrs = make ( map [ string ] interface { } ) } tplMsg := & TemplateMsg { Timestamp : timestamp , Message : msg , Level : level , LevelName : level . String ( ) , Attrs : msgAttrs , } return tplMsg }
5633	func NewLogAdapterFor ( base WrappableLogger , attrs * Attrs ) * LogAdapter { if attrs == nil { attrs = NewAttrs ( ) } return & LogAdapter { base : base , attrs : attrs , } }
5634	func ( la * LogAdapter ) SetAttr ( key string , value interface { } ) { la . attrs . SetAttr ( key , value ) }
5635	func ( la * LogAdapter ) LogWithTime ( level LogLevel , ts time . Time , attrs * Attrs , msg string , a ... interface { } ) error { if la . logLevel != nil && level > * la . logLevel { return nil } mergedAttrs := la . attrs . clone ( ) mergedAttrs . MergeAttrs ( attrs ) return la . base . LogWithTime ( level , ts , mergedAttrs , msg , a ... ) }
5636	func ( la * LogAdapter ) Log ( level LogLevel , attrs * Attrs , msg string , a ... interface { } ) error { if la . logLevel != nil && level > * la . logLevel { return nil } mergedAttrs := la . attrs . clone ( ) mergedAttrs . MergeAttrs ( attrs ) return la . base . Log ( level , mergedAttrs , msg , a ... ) }
5637	func ( la * LogAdapter ) Dbgm ( m * Attrs , msg string , a ... interface { } ) error { return la . Debugm ( m , msg , a ... ) }
5638	func NewAttrsFromMap ( attrs map [ string ] interface { } ) * Attrs { newAttrs := NewAttrs ( ) for attrKey , attrVal := range attrs { newAttrs . SetAttr ( attrKey , attrVal ) } return newAttrs }
5639	func NewAttrsFromAttrs ( attrs ... * Attrs ) * Attrs { newAttrs := NewAttrs ( ) for _ , attr := range attrs { newAttrs . MergeAttrs ( attr ) } return newAttrs }
5640	func ( a * Attrs ) MergeAttrs ( attrs * Attrs ) { if attrs == nil { return } a . attrsLock . Lock ( ) defer a . attrsLock . Unlock ( ) for hash , val := range attrs . attrs { a . attrs [ hash ] = val } }
5641	func ( a * Attrs ) SetAttr ( key string , value interface { } ) * Attrs { a . attrsLock . Lock ( ) defer a . attrsLock . Unlock ( ) valVal := reflect . ValueOf ( value ) switch valVal . Kind ( ) { case reflect . Func : value = valVal . Type ( ) . String ( ) } hash := getAttrHash ( key ) a . attrs [ hash ] = value return a }
5642	func ( a * Attrs ) GetAttr ( key string ) interface { } { a . attrsLock . RLock ( ) defer a . attrsLock . RUnlock ( ) return a . attrs [ getAttrHash ( key ) ] }
5643	func ( a * Attrs ) RemoveAttr ( key string ) { a . attrsLock . Lock ( ) defer a . attrsLock . Unlock ( ) delete ( a . attrs , getAttrHash ( key ) ) }
5644	func ( a * Attrs ) Attrs ( ) map [ string ] interface { } { a . attrsLock . RLock ( ) defer a . attrsLock . RUnlock ( ) attrs := make ( map [ string ] interface { } ) for hash , val := range a . attrs { key , _ := getHashAttr ( hash ) attrs [ key ] = val } return attrs }
5645	func Debugm ( m * Attrs , msg string , a ... interface { } ) error { return curDefault . Debugm ( m , msg , a ... ) }
5646	func Infom ( m * Attrs , msg string , a ... interface { } ) error { return curDefault . Infom ( m , msg , a ... ) }
5647	func Warningm ( m * Attrs , msg string , a ... interface { } ) error { return curDefault . Warningm ( m , msg , a ... ) }
5648	func Errm ( m * Attrs , msg string , a ... interface { } ) error { return Errorm ( m , msg , a ... ) }
5649	func Errorm ( m * Attrs , msg string , a ... interface { } ) error { return curDefault . Errorm ( m , msg , a ... ) }
5650	func Fatalm ( m * Attrs , msg string , a ... interface { } ) error { return curDefault . Fatalm ( m , msg , a ... ) }
5651	func Dief ( exitCode int , msg string , a ... interface { } ) { curDefault . Dief ( exitCode , msg , a ... ) }
5652	func Diem ( exitCode int , m * Attrs , msg string , a ... interface { } ) { curDefault . Diem ( exitCode , m , msg , a ... ) }
5653	func ToLogLevel ( level string ) ( LogLevel , error ) { lowLevel := strings . ToLower ( level ) switch lowLevel { case "dbg" : fallthrough case "debug" : return LevelDebug , nil case "info" : return LevelInfo , nil case "warn" : fallthrough case "warning" : return LevelWarning , nil case "err" : fallthrough case "error" : return LevelError , nil case "fatal" : return LevelFatal , nil case "none" : return LevelNone , nil } return 0 , ErrUnknownLevel }
5654	func CallErr ( f func ( ) error ) error { checkRun ( ) errChan := make ( chan error ) callQueue <- func ( ) { errChan <- f ( ) } return <- errChan }
5655	func New ( opts ... Option ) ( * StackdriverHook , error ) { var err error sh := & StackdriverHook { levels : logrus . AllLevels , } for _ , o := range opts { err = o ( sh ) if err != nil { return nil , err } } if sh . service == nil && sh . agentClient == nil { return nil , errors . New ( "no stackdriver service was provided" ) } if sh . resource == nil && sh . agentClient == nil { return nil , errors . New ( "the monitored resource was not provided" ) } if sh . projectID == "" && sh . agentClient == nil { return nil , errors . New ( "the project id was not provided" ) } if sh . logName == "" { err = LogName ( DefaultName ) ( sh ) if err != nil { return nil , err } } if sh . errorReportingLogName == "" { sh . errorReportingLogName = sh . logName + "_errors" } return sh , nil }
5656	func ( sh * StackdriverHook ) Fire ( entry * logrus . Entry ) error { sh . waitGroup . Add ( 1 ) go func ( entry * logrus . Entry ) { defer sh . waitGroup . Done ( ) var httpReq * logging . HttpRequest labels := make ( map [ string ] string , len ( entry . Data ) ) for k , v := range entry . Data { switch x := v . ( type ) { case string : labels [ k ] = x case * http . Request : httpReq = & logging . HttpRequest { Referer : x . Referer ( ) , RemoteIp : x . RemoteAddr , RequestMethod : x . Method , RequestUrl : x . URL . String ( ) , UserAgent : x . UserAgent ( ) , } case * logging . HttpRequest : httpReq = x default : labels [ k ] = fmt . Sprintf ( "%v" , v ) } } if sh . agentClient != nil { sh . sendLogMessageViaAgent ( entry , labels , httpReq ) } else { sh . sendLogMessageViaAPI ( entry , labels , httpReq ) } } ( sh . copyEntry ( entry ) ) return nil }
5657	func Levels ( levels ... logrus . Level ) Option { return func ( sh * StackdriverHook ) error { sh . levels = levels return nil } }
5658	func ProjectID ( projectID string ) Option { return func ( sh * StackdriverHook ) error { sh . projectID = projectID return nil } }
5659	func EntriesService ( service * logging . EntriesService ) Option { return func ( sh * StackdriverHook ) error { sh . service = service return nil } }
5660	func LoggingService ( service * logging . Service ) Option { return func ( sh * StackdriverHook ) error { sh . service = service . Entries return nil } }
5661	func ErrorService ( errorService * errorReporting . Service ) Option { return func ( sh * StackdriverHook ) error { sh . errorService = errorService return nil } }
5662	func HTTPClient ( client * http . Client ) Option { return func ( sh * StackdriverHook ) error { l , err := logging . New ( client ) if err != nil { return err } e , err := errorReporting . New ( client ) if err != nil { return err } else { ErrorService ( e ) } return LoggingService ( l ) ( sh ) } }
5663	func MonitoredResource ( resource * logging . MonitoredResource ) Option { return func ( sh * StackdriverHook ) error { sh . resource = resource return nil } }
5664	func ErrorReportingLogName ( name string ) Option { return func ( sh * StackdriverHook ) error { sh . errorReportingLogName = name return nil } }
5665	func Labels ( labels map [ string ] string ) Option { return func ( sh * StackdriverHook ) error { sh . labels = labels return nil } }
5666	func PartialSuccess ( enabled bool ) Option { return func ( sh * StackdriverHook ) error { sh . partialSuccess = enabled return nil } }
5667	func GoogleComputeCredentials ( serviceAccount string ) Option { return func ( sh * StackdriverHook ) error { var err error scopes , err := metadata . Scopes ( serviceAccount ) if err != nil { return err } for _ , s := range requiredScopes { if ! sliceContains ( scopes , s ) { return fmt . Errorf ( "missing required scope %s in compute metadata" , s ) } } return HTTPClient ( & http . Client { Transport : & oauth2 . Transport { Source : google . ComputeTokenSource ( serviceAccount ) , } , } ) ( sh ) } }
5668	func ( c Codec ) NewEncoder ( w io . Writer ) * Encoder { return NewEncoder ( c . NewEmitter ( w ) ) }
5669	func ( c Codec ) NewDecoder ( r io . Reader ) * Decoder { return NewDecoder ( c . NewParser ( r ) ) }
5670	func ( c Codec ) NewStreamEncoder ( w io . Writer ) * StreamEncoder { return NewStreamEncoder ( c . NewEmitter ( w ) ) }
5671	func ( c Codec ) NewStreamDecoder ( r io . Reader ) * StreamDecoder { return NewStreamDecoder ( c . NewParser ( r ) ) }
5672	func ( reg * Registry ) Register ( mimetype string , codec Codec ) { defer reg . mutex . Unlock ( ) reg . mutex . Lock ( ) if reg . codecs == nil { reg . codecs = make ( map [ string ] Codec ) } reg . codecs [ mimetype ] = codec }
5673	func ( reg * Registry ) Unregister ( mimetype string ) { defer reg . mutex . Unlock ( ) reg . mutex . Lock ( ) delete ( reg . codecs , mimetype ) }
5674	func ( reg * Registry ) Lookup ( mimetype string ) ( codec Codec , ok bool ) { reg . mutex . RLock ( ) codec , ok = reg . codecs [ mimetype ] reg . mutex . RUnlock ( ) return }
5675	func ( reg * Registry ) Codecs ( ) ( codecs map [ string ] Codec ) { codecs = make ( map [ string ] Codec ) reg . mutex . RLock ( ) for mimetype , codec := range reg . codecs { codecs [ mimetype ] = codec } reg . mutex . RUnlock ( ) return }
5676	func ( e * Error ) Type ( ) string { s := e . Error ( ) if i := strings . IndexByte ( s , ' ' ) ; i < 0 { s = "" } else { s = s [ : i ] for _ , c := range s { if ! unicode . IsUpper ( c ) { s = "" break } } } return s }
5677	func Install ( typ reflect . Type , adapter Adapter ) { if adapter . Encode == nil { panic ( "objconv: the encoder function of an adapter cannot be nil" ) } if adapter . Decode == nil { panic ( "objconv: the decoder function of an adapter cannot be nil" ) } adapterMutex . Lock ( ) adapterStore [ typ ] = adapter adapterMutex . Unlock ( ) structCache . clear ( ) }
5678	func AdapterOf ( typ reflect . Type ) ( a Adapter , ok bool ) { adapterMutex . RLock ( ) a , ok = adapterStore [ typ ] adapterMutex . RUnlock ( ) return }
5679	func AppendDuration ( b [ ] byte , d time . Duration ) [ ] byte { var buf [ 32 ] byte w := len ( buf ) u := uint64 ( d ) neg := d < 0 if neg { u = - u } if u < uint64 ( time . Second ) { var prec int w -- buf [ w ] = 's' w -- switch { case u == 0 : return append ( b , '0' , 's' ) case u < uint64 ( time . Microsecond ) : prec = 0 buf [ w ] = 'n' case u < uint64 ( time . Millisecond ) : prec = 3 w -- copy ( buf [ w : ] , "µ") ) ) } default : prec = 6 buf [ w ] = 'm' w , u = fmtFrac ( buf [ : w ] , u , prec ) } else w = fmtInt ( buf [ : w ] , u ) { w -- buf [ w ] = 's' w , u = fmtFrac ( buf [ : w ] , u , 9 ) w = fmtInt ( buf [ : w ] , u % 60 ) u /= 60 if u > 0 { w -- buf [ w ] = 'm' w = fmtInt ( buf [ : w ] , u % 60 ) u /= 60 if u > 0 { w -- buf [ w ] = 'h' w = fmtInt ( buf [ : w ] , u ) } } } if neg { w -- buf [ w ] = '-' } }
5680	func fmtInt ( buf [ ] byte , v uint64 ) int { w := len ( buf ) if v == 0 { w -- buf [ w ] = '0' } else { for v > 0 { w -- buf [ w ] = byte ( v % 10 ) + '0' v /= 10 } } return w }
5681	func NewDecoder ( r io . Reader ) * objconv . Decoder { return objconv . NewDecoder ( NewParser ( r ) ) }
5682	func NewStreamDecoder ( r io . Reader ) * objconv . StreamDecoder { return objconv . NewStreamDecoder ( NewParser ( r ) ) }
5683	func Unmarshal ( b [ ] byte , v interface { } ) error { u := unmarshalerPool . Get ( ) . ( * unmarshaler ) u . reset ( b ) err := ( objconv . Decoder { Parser : u } ) . Decode ( v ) u . reset ( nil ) unmarshalerPool . Put ( u ) return err }
5684	func ( t Type ) String ( ) string { switch t { case Nil : return "nil" case Bool : return "bool" case Int : return "int" case Uint : return "uint" case Float : return "float" case String : return "string" case Bytes : return "bytes" case Time : return "time" case Duration : return "duration" case Error : return "error" case Array : return "array" case Map : return "map" default : return "<type>" } }
5685	func zeroValueOf ( t reflect . Type ) reflect . Value { zeroMutex . RLock ( ) v , ok := zeroCache [ t ] zeroMutex . RUnlock ( ) if ! ok { v = reflect . Zero ( t ) zeroMutex . Lock ( ) zeroCache [ t ] = v zeroMutex . Unlock ( ) } return v }
5686	func NewValueParser ( v interface { } ) * ValueParser { return & ValueParser { stack : [ ] reflect . Value { reflect . ValueOf ( v ) } , } }
5687	func ParseTag ( s string ) Tag { var name string var omitzero bool var omitempty bool name , s = parseNextTagToken ( s ) for len ( s ) != 0 { var token string switch token , s = parseNextTagToken ( s ) ; token { case "omitempty" : omitempty = true case "omitzero" : omitzero = true } } return Tag { Name : name , Omitempty : omitempty , Omitzero : omitzero , } }
5688	func NewEncoder ( w io . Writer ) * objconv . Encoder { return objconv . NewEncoder ( NewEmitter ( w ) ) }
5689	func NewStreamEncoder ( w io . Writer ) * objconv . StreamEncoder { return objconv . NewStreamEncoder ( NewEmitter ( w ) ) }
5690	func NewPrettyEncoder ( w io . Writer ) * objconv . Encoder { return objconv . NewEncoder ( NewPrettyEmitter ( w ) ) }
5691	func NewPrettyStreamEncoder ( w io . Writer ) * objconv . StreamEncoder { return objconv . NewStreamEncoder ( NewPrettyEmitter ( w ) ) }
5692	func Marshal ( v interface { } ) ( b [ ] byte , err error ) { m := marshalerPool . Get ( ) . ( * marshaler ) m . b . Truncate ( 0 ) if err = ( objconv . Encoder { Emitter : m } ) . Encode ( v ) ; err == nil { b = make ( [ ] byte , m . b . Len ( ) ) copy ( b , m . b . Bytes ( ) ) } marshalerPool . Put ( m ) return }
5693	func NewEncoder ( e Emitter ) * Encoder { if e == nil { panic ( "objconv: the emitter is nil" ) } return & Encoder { Emitter : e } }
5694	func ( e Encoder ) EncodeArray ( n int , f func ( Encoder ) error ) ( err error ) { if e . key { if e . key , err = false , e . Emitter . EmitMapValue ( ) ; err != nil { return } } if err = e . Emitter . EmitArrayBegin ( n ) ; err != nil { return } encodeArray : for i := 0 ; n < 0 || i < n ; i ++ { if i != 0 { if e . Emitter . EmitArrayNext ( ) ; err != nil { return } } switch err = f ( e ) ; err { case nil : case End : break encodeArray default : return } } return e . Emitter . EmitArrayEnd ( ) }
5695	func ( e Encoder ) EncodeMap ( n int , f func ( Encoder , Encoder ) error ) ( err error ) { if e . key { if e . key , err = false , e . Emitter . EmitMapValue ( ) ; err != nil { return } } if err = e . Emitter . EmitMapBegin ( n ) ; err != nil { return } encodeMap : for i := 0 ; n < 0 || i < n ; i ++ { if i != 0 { if err = e . Emitter . EmitMapNext ( ) ; err != nil { return } } e . key = true err = f ( Encoder { Emitter : e . Emitter , SortMapKeys : e . SortMapKeys } , Encoder { Emitter : e . Emitter , SortMapKeys : e . SortMapKeys , key : true } , ) e . key = false switch err { case nil : case End : break encodeMap default : return } } return e . Emitter . EmitMapEnd ( ) }
5696	func NewStreamEncoder ( e Emitter ) * StreamEncoder { if e == nil { panic ( "objconv.NewStreamEncoder: the emitter is nil" ) } return & StreamEncoder { Emitter : e } }
5697	func ( e * StreamEncoder ) Open ( n int ) error { if err := e . err ; err != nil { return err } if e . closed { return io . ErrClosedPipe } if ! e . opened { e . max = n e . opened = true if ! e . oneshot { e . err = e . Emitter . EmitArrayBegin ( n ) } } return e . err }
5698	func ( e * StreamEncoder ) Close ( ) error { if ! e . closed { if err := e . Open ( - 1 ) ; err != nil { return err } e . closed = true if ! e . oneshot { e . err = e . Emitter . EmitArrayEnd ( ) } } return e . err }
5699	func ( e * StreamEncoder ) Encode ( v interface { } ) error { if err := e . Open ( - 1 ) ; err != nil { return err } if e . max >= 0 && e . cnt >= e . max { return fmt . Errorf ( "objconv: too many values sent to a stream encoder exceed the configured limit of %d" , e . max ) } if ! e . oneshot && e . cnt != 0 { e . err = e . Emitter . EmitArrayNext ( ) } if e . err == nil { e . err = ( Encoder { Emitter : e . Emitter , SortMapKeys : e . SortMapKeys , } ) . Encode ( v ) if e . cnt ++ ; e . max >= 0 && e . cnt >= e . max { e . Close ( ) } } return e . err }
5700	func newStructType ( t reflect . Type , c map [ reflect . Type ] * structType ) * structType { if s := c [ t ] ; s != nil { return s } n := t . NumField ( ) s := & structType { fields : make ( [ ] structField , 0 , n ) , fieldsByName : make ( map [ string ] * structField ) , } c [ t ] = s for i := 0 ; i != n ; i ++ { ft := t . Field ( i ) if ft . Anonymous || len ( ft . PkgPath ) != 0 { continue } sf := makeStructField ( ft , c ) if sf . name == "-" { continue } s . fields = append ( s . fields , sf ) s . fieldsByName [ sf . name ] = & s . fields [ len ( s . fields ) - 1 ] } return s }
5701	func ( cache * structTypeCache ) lookup ( t reflect . Type ) ( s * structType ) { cache . mutex . RLock ( ) s = cache . store [ t ] cache . mutex . RUnlock ( ) if s == nil { s = newStructType ( t , map [ reflect . Type ] * structType { } ) cache . mutex . Lock ( ) cache . store [ t ] = s cache . mutex . Unlock ( ) } return }
5702	func ( cache * structTypeCache ) clear ( ) { cache . mutex . Lock ( ) for typ := range cache . store { delete ( cache . store , typ ) } cache . mutex . Unlock ( ) }
5703	func CheckUint64Bounds ( v uint64 , max uint64 , t reflect . Type ) ( err error ) { if v > max { err = fmt . Errorf ( "objconv: %d overflows the maximum value of %d for %s" , v , max , t ) } return }
5704	func CheckInt64Bounds ( v int64 , min int64 , max uint64 , t reflect . Type ) ( err error ) { if v < min { err = fmt . Errorf ( "objconv: %d overflows the minimum value of %d for %s" , v , min , t ) } if v > 0 && uint64 ( v ) > max { err = fmt . Errorf ( "objconv: %d overflows the maximum value of %d for %s" , v , max , t ) } return }
5705	func NewDecoder ( p Parser ) * Decoder { if p == nil { panic ( "objconv: the parser is nil" ) } return & Decoder { Parser : p } }
5706	func ( d Decoder ) Decode ( v interface { } ) error { to := reflect . ValueOf ( v ) if d . off != 0 { var err error if d . off , err = 0 , d . Parser . ParseMapValue ( d . off - 1 ) ; err != nil { return err } } if ! to . IsValid ( ) { _ , err := d . decodeInterface ( to ) return err } switch x := v . ( type ) { case ValueDecoder : return x . DecodeValue ( d ) } if to . Kind ( ) == reflect . Ptr { to = to . Elem ( ) } _ , err := d . decode ( to ) return err }
5707	func ( d Decoder ) DecodeArray ( f func ( Decoder ) error ) ( err error ) { var typ Type if d . off != 0 { if d . off , err = 0 , d . Parser . ParseMapValue ( d . off - 1 ) ; err != nil { return } } if typ , err = d . Parser . ParseType ( ) ; err != nil { return } err = d . decodeArrayImpl ( typ , f ) return }
5708	func ( d Decoder ) DecodeMap ( f func ( Decoder , Decoder ) error ) ( err error ) { var typ Type if d . off != 0 { if d . off , err = 0 , d . Parser . ParseMapValue ( d . off - 1 ) ; err != nil { return } } if typ , err = d . Parser . ParseType ( ) ; err != nil { return } err = d . decodeMapImpl ( typ , f ) return }
5709	func NewStreamDecoder ( p Parser ) * StreamDecoder { if p == nil { panic ( "objconv: the parser is nil" ) } return & StreamDecoder { Parser : p } }
5710	func ( d * StreamDecoder ) Len ( ) int { if d . err != nil { return 0 } if d . typ == Unknown { if d . init ( ) != nil { return 0 } } return d . max - d . cnt }
5711	func ( d * StreamDecoder ) Err ( ) error { if d . err == End { return nil } return d . err }
5712	func ( d * StreamDecoder ) Decode ( v interface { } ) error { if d . err != nil { return d . err } err := error ( nil ) cnt := d . cnt max := d . max dec := Decoder { Parser : d . Parser , MapType : d . MapType , } switch d . typ { case Unknown : err = d . init ( ) max = d . max case Array : if cnt == max { err = dec . Parser . ParseArrayEnd ( cnt ) } else if cnt != 0 { err = dec . Parser . ParseArrayNext ( cnt ) } } if err == nil { if cnt == max { err = End } else { switch err = dec . Decode ( v ) ; err { case nil : cnt ++ case End : cnt ++ max = cnt default : if max < 0 && dec . Parser . ParseArrayEnd ( cnt ) == nil { err = End } } } } d . err = err d . cnt = cnt d . max = max return err }
5713	func ( d * StreamDecoder ) Encoder ( e Emitter ) ( enc * StreamEncoder , err error ) { var typ Type if typ , err = d . Parser . ParseType ( ) ; err == nil { enc = NewStreamEncoder ( e ) enc . oneshot = typ != Array } return }
5714	func init ( ) { for _ , f := range strings . Split ( os . Getenv ( "LOGFLAGS" ) , "," ) { switch f { case "longfile" : defaultFlags |= Llongfile case "shortfile" : defaultFlags |= Lshortfile } } }
5715	func LevelFromString ( s string ) ( l Level , ok bool ) { switch strings . ToLower ( s ) { case "trace" , "trc" : return LevelTrace , true case "debug" , "dbg" : return LevelDebug , true case "info" , "inf" : return LevelInfo , true case "warn" , "wrn" : return LevelWarn , true case "error" , "err" : return LevelError , true case "critical" , "crt" : return LevelCritical , true case "off" : return LevelOff , true default : return LevelInfo , false } }
5716	func NewBackend ( w io . Writer , opts ... BackendOption ) * Backend { b := & Backend { w : w , flag : defaultFlags } for _ , o := range opts { o ( b ) } return b }
5717	func callsite ( flag uint32 ) ( string , int ) { _ , file , line , ok := runtime . Caller ( calldepth ) if ! ok { return "???" , 0 } if flag & Lshortfile != 0 { short := file for i := len ( file ) - 1 ; i > 0 ; i -- { if os . IsPathSeparator ( file [ i ] ) { short = file [ i + 1 : ] break } } file = short } return file , line }
5718	func ( b * Backend ) print ( lvl , tag string , args ... interface { } ) { t := time . Now ( ) bytebuf := buffer ( ) var file string var line int if b . flag & ( Lshortfile | Llongfile ) != 0 { file , line = callsite ( b . flag ) } formatHeader ( bytebuf , t , lvl , tag , file , line ) buf := bytes . NewBuffer ( * bytebuf ) fmt . Fprintln ( buf , args ... ) * bytebuf = buf . Bytes ( ) b . mu . Lock ( ) b . w . Write ( * bytebuf ) b . mu . Unlock ( ) recycleBuffer ( bytebuf ) }
5719	func ( b * Backend ) Logger ( subsystemTag string ) Logger { return & slog { LevelInfo , subsystemTag , b } }
5720	func ( l * slog ) Trace ( args ... interface { } ) { lvl := l . Level ( ) if lvl <= LevelTrace { l . b . print ( "TRC" , l . tag , args ... ) } }
5721	func ( l * slog ) Tracef ( format string , args ... interface { } ) { lvl := l . Level ( ) if lvl <= LevelTrace { l . b . printf ( "TRC" , l . tag , format , args ... ) } }
5722	func ( l * slog ) Debug ( args ... interface { } ) { lvl := l . Level ( ) if lvl <= LevelDebug { l . b . print ( "DBG" , l . tag , args ... ) } }
5723	func ( l * slog ) Debugf ( format string , args ... interface { } ) { lvl := l . Level ( ) if lvl <= LevelDebug { l . b . printf ( "DBG" , l . tag , format , args ... ) } }
5724	func ( l * slog ) Info ( args ... interface { } ) { lvl := l . Level ( ) if lvl <= LevelInfo { l . b . print ( "INF" , l . tag , args ... ) } }
5725	func ( l * slog ) Infof ( format string , args ... interface { } ) { lvl := l . Level ( ) if lvl <= LevelInfo { l . b . printf ( "INF" , l . tag , format , args ... ) } }
5726	func ( l * slog ) Warn ( args ... interface { } ) { lvl := l . Level ( ) if lvl <= LevelWarn { l . b . print ( "WRN" , l . tag , args ... ) } }
5727	func ( l * slog ) Warnf ( format string , args ... interface { } ) { lvl := l . Level ( ) if lvl <= LevelWarn { l . b . printf ( "WRN" , l . tag , format , args ... ) } }
5728	func ( l * slog ) Error ( args ... interface { } ) { lvl := l . Level ( ) if lvl <= LevelError { l . b . print ( "ERR" , l . tag , args ... ) } }
5729	func ( l * slog ) Errorf ( format string , args ... interface { } ) { lvl := l . Level ( ) if lvl <= LevelError { l . b . printf ( "ERR" , l . tag , format , args ... ) } }
5730	func ( l * slog ) Critical ( args ... interface { } ) { lvl := l . Level ( ) if lvl <= LevelCritical { l . b . print ( "CRT" , l . tag , args ... ) } }
5731	func ( l * slog ) Criticalf ( format string , args ... interface { } ) { lvl := l . Level ( ) if lvl <= LevelCritical { l . b . printf ( "CRT" , l . tag , format , args ... ) } }
5732	func ( l * slog ) Level ( ) Level { return Level ( atomic . LoadUint32 ( ( * uint32 ) ( & l . lvl ) ) ) }
5733	func ( l * slog ) SetLevel ( level Level ) { atomic . StoreUint32 ( ( * uint32 ) ( & l . lvl ) , uint32 ( level ) ) }
5734	func ( permission * Permission ) Concat ( newPermission * Permission ) * Permission { var result = Permission { Role : Global , AllowedRoles : map [ PermissionMode ] [ ] string { } , DeniedRoles : map [ PermissionMode ] [ ] string { } , } var appendRoles = func ( p * Permission ) { if p != nil { result . Role = p . Role for mode , roles := range p . DeniedRoles { result . DeniedRoles [ mode ] = append ( result . DeniedRoles [ mode ] , roles ... ) } for mode , roles := range p . AllowedRoles { result . AllowedRoles [ mode ] = append ( result . AllowedRoles [ mode ] , roles ... ) } } } appendRoles ( newPermission ) appendRoles ( permission ) return & result }
5735	func ( permission Permission ) HasPermission ( mode PermissionMode , roles ... interface { } ) bool { var roleNames [ ] string for _ , role := range roles { if r , ok := role . ( string ) ; ok { roleNames = append ( roleNames , r ) } else if roler , ok := role . ( Roler ) ; ok { roleNames = append ( roleNames , roler . GetRoles ( ) ... ) } else { fmt . Printf ( "invalid role %#v\n" , \n ) role } } return false if len ( permission . DeniedRoles ) != 0 { if DeniedRoles := permission . DeniedRoles [ mode ] ; DeniedRoles != nil { if includeRoles ( DeniedRoles , roleNames ) { return false } } } if len ( permission . AllowedRoles ) == 0 { return true } if AllowedRoles := permission . AllowedRoles [ mode ] ; AllowedRoles != nil { if includeRoles ( AllowedRoles , roleNames ) { return true } } }
5736	func ConcatPermissioner ( ps ... Permissioner ) Permissioner { var newPS [ ] Permissioner for _ , p := range ps { if p != nil { newPS = append ( newPS , p ) } } return permissioners ( newPS ) }
5737	func ( ps permissioners ) HasPermission ( mode PermissionMode , roles ... interface { } ) bool { for _ , p := range ps { if p != nil && ! p . HasPermission ( mode , roles ) { return false } } return true }
5738	func ( role * Role ) Register ( name string , fc Checker ) { if role . definitions == nil { role . definitions = map [ string ] Checker { } } definition := role . definitions [ name ] if definition != nil { fmt . Printf ( "Role `%v` already defined, overwrited it!\n" , \n ) } name }
5739	func ( role * Role ) NewPermission ( ) * Permission { return & Permission { Role : role , AllowedRoles : map [ PermissionMode ] [ ] string { } , DeniedRoles : map [ PermissionMode ] [ ] string { } , } }
5740	func ( role * Role ) Get ( name string ) ( Checker , bool ) { fc , ok := role . definitions [ name ] return fc , ok }
5741	func ( p * Process ) isPtrFromHeap ( a core . Address ) bool { return p . findHeapInfo ( a ) . IsPtr ( a , p . proc . PtrSize ( ) ) }
5742	func ( p * Process ) IsPtr ( a core . Address ) bool { h := p . findHeapInfo ( a ) if h != nil { return h . IsPtr ( a , p . proc . PtrSize ( ) ) } for _ , m := range p . modules { for _ , s := range [ 2 ] string { "data" , "bss" } { min := core . Address ( m . r . Field ( s ) . Uintptr ( ) ) max := core . Address ( m . r . Field ( "e" + s ) . Uintptr ( ) ) if a < min || a >= max { continue } gc := m . r . Field ( "gc" + s + "mask" ) . Field ( "bytedata" ) . Address ( ) i := a . Sub ( min ) return p . proc . ReadUint8 ( gc . Add ( i / 8 ) ) >> uint ( i % 8 ) != 0 } } return false }
5743	func ( p * Process ) FindObject ( a core . Address ) ( Object , int64 ) { h := p . findHeapInfo ( a ) if h == nil { return 0 , 0 } x := h . base . Add ( a . Sub ( h . base ) / h . size * h . size ) h = p . findHeapInfo ( x ) if h . mark >> ( uint64 ( x ) % heapInfoSize / 8 ) & 1 == 0 { return 0 , 0 } return Object ( x ) , a . Sub ( x ) }
5744	func ( p * Process ) ForEachObject ( fn func ( x Object ) bool ) { for _ , k := range p . pages { pt := p . pageTable [ k ] for i := range pt { h := & pt [ i ] m := h . mark for m != 0 { j := bits . TrailingZeros64 ( m ) m &= m - 1 x := Object ( k ) * pageTableSize * heapInfoSize + Object ( i ) * heapInfoSize + Object ( j ) * 8 if ! fn ( x ) { return } } } } }
5745	func ( p * Process ) ForEachRoot ( fn func ( r * Root ) bool ) { for _ , r := range p . globals { if ! fn ( r ) { return } } for _ , g := range p . goroutines { for _ , f := range g . frames { for _ , r := range f . roots { if ! fn ( r ) { return } } } } }
5746	func ( p * Process ) Addr ( x Object ) core . Address { return core . Address ( x ) }
5747	func ( p * Process ) Size ( x Object ) int64 { return p . findHeapInfo ( core . Address ( x ) ) . size }
5748	func ( p * Process ) Type ( x Object ) ( * Type , int64 ) { p . typeHeap ( ) i , _ := p . findObjectIndex ( core . Address ( x ) ) return p . types [ i ] . t , p . types [ i ] . r }
5749	func ( p * Process ) ForEachRootPtr ( r * Root , fn func ( int64 , Object , int64 ) bool ) { edges1 ( p , r , 0 , r . Type , fn ) }
5750	func edges1 ( p * Process , r * Root , off int64 , t * Type , fn func ( int64 , Object , int64 ) bool ) bool { switch t . Kind { case KindBool , KindInt , KindUint , KindFloat , KindComplex : case KindIface , KindEface : a := r . Addr . Add ( off ) if r . Frame == nil || r . Frame . Live [ a ] { dst , off2 := p . FindObject ( p . proc . ReadPtr ( a ) ) if dst != 0 { if ! fn ( off , dst , off2 ) { return false } } } off += p . proc . PtrSize ( ) fallthrough case KindPtr , KindString , KindSlice , KindFunc : a := r . Addr . Add ( off ) if r . Frame == nil || r . Frame . Live [ a ] { dst , off2 := p . FindObject ( p . proc . ReadPtr ( a ) ) if dst != 0 { if ! fn ( off , dst , off2 ) { return false } } } case KindArray : s := t . Elem . Size for i := int64 ( 0 ) ; i < t . Count ; i ++ { if ! edges1 ( p , r , off + i * s , t . Elem , fn ) { return false } } case KindStruct : for _ , f := range t . Fields { if ! edges1 ( p , r , off + f . Off , f . Type , fn ) { return false } } } return true }
5751	func ( p * Process ) setHeapPtr ( a core . Address ) { h := p . allocHeapInfo ( a ) if p . proc . PtrSize ( ) == 8 { i := uint ( a % heapInfoSize ) / 8 h . ptr [ 0 ] |= uint64 ( 1 ) << i return } i := a % heapInfoSize / 4 h . ptr [ i / 64 ] |= uint64 ( 1 ) << ( i % 64 ) }
5752	func ( p * Process ) findHeapInfo ( a core . Address ) * heapInfo { k := a / heapInfoSize / pageTableSize i := a / heapInfoSize % pageTableSize t := p . pageTable [ k ] if t == nil { return nil } h := & t [ i ] if h . base == 0 { return nil } return h }
5753	func ( p * Process ) allocHeapInfo ( a core . Address ) * heapInfo { k := a / heapInfoSize / pageTableSize i := a / heapInfoSize % pageTableSize t := p . pageTable [ k ] if t == nil { t = new ( pageTableEntry ) for j := 0 ; j < pageTableSize ; j ++ { t [ j ] . firstIdx = - 1 } p . pageTable [ k ] = t p . pages = append ( p . pages , k ) } return & t [ i ] }
5754	func runtimeName ( dt dwarf . Type ) string { switch x := dt . ( type ) { case * dwarf . PtrType : if _ , ok := x . Type . ( * dwarf . VoidType ) ; ok { return "unsafe.Pointer" } return "*" + runtimeName ( x . Type ) case * dwarf . ArrayType : return fmt . Sprintf ( "[%d]%s" , x . Count , runtimeName ( x . Type ) ) case * dwarf . StructType : if ! strings . HasPrefix ( x . StructName , "struct {" ) { return stripPackagePath ( x . StructName ) } var anon [ ] bool for _ , f := range strings . Split ( x . StructName [ 8 : len ( x . StructName ) - 1 ] , ";" ) { f = strings . TrimSpace ( f ) anon = append ( anon , ! strings . Contains ( f , " " ) ) } for len ( anon ) < len ( x . Field ) { anon = append ( anon , false ) } s := "struct {" first := true for _ , f := range x . Field { if ! first { s += ";" } name := f . Name if i := strings . Index ( name , "." ) ; i >= 0 { name = name [ i + 1 : ] } if anon [ 0 ] { s += fmt . Sprintf ( " %s" , runtimeName ( f . Type ) ) } else { s += fmt . Sprintf ( " %s %s" , name , runtimeName ( f . Type ) ) } first = false anon = anon [ 1 : ] } s += " }" return s default : return stripPackagePath ( dt . String ( ) ) } }
5755	func ( p * Process ) readRuntimeConstants ( ) { p . rtConstants = map [ string ] int64 { } m := p . rtConstants m [ "_MSpanDead" ] = 0 m [ "_MSpanInUse" ] = 1 m [ "_MSpanManual" ] = 2 m [ "_MSpanFree" ] = 3 m [ "_Gidle" ] = 0 m [ "_Grunnable" ] = 1 m [ "_Grunning" ] = 2 m [ "_Gsyscall" ] = 3 m [ "_Gwaiting" ] = 4 m [ "_Gdead" ] = 6 m [ "_Gscan" ] = 0x1000 m [ "_PCDATA_StackMapIndex" ] = 0 m [ "_FUNCDATA_LocalsPointerMaps" ] = 1 m [ "_FUNCDATA_ArgsPointerMaps" ] = 0 m [ "tflagExtraStar" ] = 1 << 1 m [ "kindGCProg" ] = 1 << 6 m [ "kindDirectIface" ] = 1 << 5 m [ "_PageSize" ] = 1 << 13 m [ "_KindSpecialFinalizer" ] = 1 d , _ := p . proc . DWARF ( ) r := d . Reader ( ) for e , err := r . Next ( ) ; e != nil && err == nil ; e , err = r . Next ( ) { if e . Tag != dwarf . TagConstant { continue } f := e . AttrField ( dwarf . AttrName ) if f == nil { continue } name := f . Val . ( string ) if ! strings . HasPrefix ( name , "runtime." ) { continue } name = name [ 8 : ] c := e . AttrField ( dwarf . AttrConstValue ) if c == nil { continue } p . rtConstants [ name ] = c . Val . ( int64 ) } }
5756	func ( t * funcTab ) add ( min , max core . Address , f * Func ) { t . entries = append ( t . entries , funcTabEntry { min : min , max : max , f : f } ) }
5757	func ( t * funcTab ) sort ( ) { sort . Slice ( t . entries , func ( i , j int ) bool { return t . entries [ i ] . min < t . entries [ j ] . min } ) }
5758	func ( t * funcTab ) find ( pc core . Address ) * Func { n := sort . Search ( len ( t . entries ) , func ( i int ) bool { return t . entries [ i ] . max > pc } ) if n == len ( t . entries ) || pc < t . entries [ n ] . min || pc >= t . entries [ n ] . max { return nil } return t . entries [ n ] . f }
5759	func ( t * pcTab ) read ( core * core . Process , data core . Address ) { var pcQuantum int64 switch core . Arch ( ) { case "386" , "amd64" , "amd64p32" : pcQuantum = 1 case "s390x" : pcQuantum = 2 case "arm" , "arm64" , "mips" , "mipsle" , "mips64" , "mips64le" , "ppc64" , "ppc64le" : pcQuantum = 4 default : panic ( "unknown architecture " + core . Arch ( ) ) } val := int64 ( - 1 ) first := true for { v , n := readVarint ( core , data ) if v == 0 && ! first { return } data = data . Add ( n ) if v & 1 != 0 { val += ^ ( v >> 1 ) } else { val += v >> 1 } v , n = readVarint ( core , data ) data = data . Add ( n ) t . entries = append ( t . entries , pcTabEntry { bytes : v * pcQuantum , val : val } ) first = false } }
5760	func readVarint ( core * core . Process , a core . Address ) ( val , n int64 ) { for { b := core . ReadUint8 ( a ) val |= int64 ( b & 0x7f ) << uint ( n * 7 ) n ++ a ++ if b & 0x80 == 0 { return } } }
5761	func useLine ( c * cobra . Command ) string { var useline string if c . HasParent ( ) { useline = commandPath ( c . Parent ( ) ) + " " + c . Use } else { useline = c . Use } if c . DisableFlagsInUseLine { return useline } if c . HasAvailableFlags ( ) && ! strings . Contains ( useline , "[flags]" ) { useline += " [flags]" } return useline }
5762	func commandPath ( c * cobra . Command ) string { if c . HasParent ( ) { return commandPath ( c ) + " " + c . Name ( ) } return c . Use }
5763	func readCore ( ) ( * core . Process , * gocore . Process , error ) { cc := coreCache if cc . cfg == cfg { return cc . coreP , cc . gocoreP , cc . err } c , err := core . Core ( cfg . corefile , cfg . base , cfg . exePath ) if err != nil { return nil , nil , err } p , err := gocore . Core ( c ) if os . IsNotExist ( err ) && cfg . exePath == "" { return nil , nil , fmt . Errorf ( "%v; consider specifying the --exe flag" , err ) } if err != nil { return nil , nil , err } for _ , w := range c . Warnings ( ) { fmt . Fprintf ( os . Stderr , "WARNING: %s\n" , \n ) } w cc . cfg = cfg cc . coreP = c cc . gocoreP = p cc . err = nil }
5764	func typeName ( c * gocore . Process , x gocore . Object ) string { size := c . Size ( x ) typ , repeat := c . Type ( x ) if typ == nil { return fmt . Sprintf ( "unk%d" , size ) } name := typ . String ( ) n := size / typ . Size if n > 1 { if repeat < n { name = fmt . Sprintf ( "[%d+%d?]%s" , repeat , n - repeat , name ) } else { name = fmt . Sprintf ( "[%d]%s" , repeat , name ) } } return name }
5765	func fieldName ( c * gocore . Process , x gocore . Object , off int64 ) string { size := c . Size ( x ) typ , repeat := c . Type ( x ) if typ == nil { return fmt . Sprintf ( "f%d" , off ) } n := size / typ . Size i := off / typ . Size if i == 0 && repeat == 1 { return typeFieldName ( typ , off ) } if i >= n { return fmt . Sprintf ( "f%d" , off ) } q := "" if i >= repeat { q = "?" } return fmt . Sprintf ( "[%d]%s%s" , i , typeFieldName ( typ , off - i * typ . Size ) , q ) }
5766	func typeFieldName ( t * gocore . Type , off int64 ) string { switch t . Kind { case gocore . KindBool , gocore . KindInt , gocore . KindUint , gocore . KindFloat : return "" case gocore . KindComplex : if off == 0 { return ".real" } return ".imag" case gocore . KindIface , gocore . KindEface : if off == 0 { return ".type" } return ".data" case gocore . KindPtr , gocore . KindFunc : return "" case gocore . KindString : if off == 0 { return ".ptr" } return ".len" case gocore . KindSlice : if off == 0 { return ".ptr" } if off <= t . Size / 2 { return ".len" } return ".cap" case gocore . KindArray : s := t . Elem . Size i := off / s return fmt . Sprintf ( "[%d]%s" , i , typeFieldName ( t . Elem , off - i * s ) ) case gocore . KindStruct : for _ , f := range t . Fields { if f . Off <= off && off < f . Off + f . Type . Size { return "." + f . Name + typeFieldName ( f . Type , off - f . Off ) } } } return ".???" }
5767	func ( p * Process ) FindFunc ( pc core . Address ) * Func { return p . funcTab . find ( pc ) }
5768	func Core ( proc * core . Process ) ( p * Process , err error ) { if _ , err := proc . DWARF ( ) ; err != nil { return nil , err } p = & Process { proc : proc , runtimeMap : map [ core . Address ] * Type { } , dwarfMap : map [ dwarf . Type ] * Type { } , } p . readDWARFTypes ( ) p . readRuntimeConstants ( ) p . readGlobals ( ) p . rtGlobals = map [ string ] region { } for _ , g := range p . globals { if strings . HasPrefix ( g . Name , "runtime." ) { p . rtGlobals [ g . Name [ 8 : ] ] = region { p : p , a : g . Addr , typ : g . Type } } } p . buildVersion = p . rtGlobals [ "buildVersion" ] . String ( ) p . readModules ( ) p . readHeap ( ) p . readGs ( ) p . readStackVars ( ) p . markObjects ( ) return p , nil }
5769	func ( r region ) Address ( ) core . Address { if r . typ . Kind != KindPtr { panic ( "can't ask for the Address of a non-pointer " + r . typ . Name ) } return r . p . proc . ReadPtr ( r . a ) }
5770	func ( r region ) Int ( ) int64 { if r . typ . Kind != KindInt || r . typ . Size != r . p . proc . PtrSize ( ) { panic ( "not an int: " + r . typ . Name ) } return r . p . proc . ReadInt ( r . a ) }
5771	func ( r region ) Uintptr ( ) uint64 { if r . typ . Kind != KindUint || r . typ . Size != r . p . proc . PtrSize ( ) { panic ( "not a uintptr: " + r . typ . Name ) } return r . p . proc . ReadUintptr ( r . a ) }
5772	func ( r region ) Cast ( typ string ) region { return region { p : r . p , a : r . a , typ : r . p . findType ( typ ) } }
5773	func ( r region ) Deref ( ) region { if r . typ . Kind != KindPtr { panic ( "can't deref on non-pointer: " + r . typ . Name ) } if r . typ . Elem == nil { panic ( "can't deref unsafe.Pointer" ) } p := r . p . proc . ReadPtr ( r . a ) return region { p : r . p , a : p , typ : r . typ . Elem } }
5774	func ( r region ) Uint64 ( ) uint64 { if r . typ . Kind != KindUint || r . typ . Size != 8 { panic ( "bad uint64 type " + r . typ . Name ) } return r . p . proc . ReadUint64 ( r . a ) }
5775	func ( r region ) Uint32 ( ) uint32 { if r . typ . Kind != KindUint || r . typ . Size != 4 { panic ( "bad uint32 type " + r . typ . Name ) } return r . p . proc . ReadUint32 ( r . a ) }
5776	func ( r region ) Int32 ( ) int32 { if r . typ . Kind != KindInt || r . typ . Size != 4 { panic ( "bad int32 type " + r . typ . Name ) } return r . p . proc . ReadInt32 ( r . a ) }
5777	func ( r region ) Uint16 ( ) uint16 { if r . typ . Kind != KindUint || r . typ . Size != 2 { panic ( "bad uint16 type " + r . typ . Name ) } return r . p . proc . ReadUint16 ( r . a ) }
5778	func ( r region ) Uint8 ( ) uint8 { if r . typ . Kind != KindUint || r . typ . Size != 1 { panic ( "bad uint8 type " + r . typ . Name ) } return r . p . proc . ReadUint8 ( r . a ) }
5779	func ( r region ) String ( ) string { if r . typ . Kind != KindString { panic ( "bad string type " + r . typ . Name ) } p := r . p . proc . ReadPtr ( r . a ) n := r . p . proc . ReadUintptr ( r . a . Add ( r . p . proc . PtrSize ( ) ) ) b := make ( [ ] byte , n ) r . p . proc . ReadAt ( b , p ) return string ( b ) }
5780	func ( r region ) SlicePtr ( ) region { if r . typ . Kind != KindSlice { panic ( "can't Ptr a non-slice" ) } return region { p : r . p , a : r . a , typ : & Type { Name : "*" + r . typ . Name [ 2 : ] , Size : r . p . proc . PtrSize ( ) , Kind : KindPtr , Elem : r . typ . Elem } } }
5781	func ( r region ) SliceLen ( ) int64 { if r . typ . Kind != KindSlice { panic ( "can't len a non-slice" ) } return r . p . proc . ReadInt ( r . a . Add ( r . p . proc . PtrSize ( ) ) ) }
5782	func ( r region ) Field ( f string ) region { finfo := r . typ . field ( f ) if finfo == nil { panic ( "can't find field " + r . typ . Name + "." + f ) } return region { p : r . p , a : r . a . Add ( finfo . Off ) , typ : finfo . Type } }
5783	func ( p * Process ) ReadUint8 ( a Address ) uint8 { m := p . findMapping ( a ) if m == nil { panic ( fmt . Errorf ( "address %x is not mapped in the core file" , a ) ) } return m . contents [ a . Sub ( m . min ) ] }
5784	func ( p * Process ) ReadUint16 ( a Address ) uint16 { m := p . findMapping ( a ) if m == nil { panic ( fmt . Errorf ( "address %x is not mapped in the core file" , a ) ) } b := m . contents [ a . Sub ( m . min ) : ] if len ( b ) < 2 { var buf [ 2 ] byte b = buf [ : ] p . ReadAt ( b , a ) } if p . littleEndian { return binary . LittleEndian . Uint16 ( b ) } return binary . BigEndian . Uint16 ( b ) }
5785	func ( p * Process ) ReadUint32 ( a Address ) uint32 { m := p . findMapping ( a ) if m == nil { panic ( fmt . Errorf ( "address %x is not mapped in the core file" , a ) ) } b := m . contents [ a . Sub ( m . min ) : ] if len ( b ) < 4 { var buf [ 4 ] byte b = buf [ : ] p . ReadAt ( b , a ) } if p . littleEndian { return binary . LittleEndian . Uint32 ( b ) } return binary . BigEndian . Uint32 ( b ) }
5786	func ( p * Process ) ReadUint64 ( a Address ) uint64 { m := p . findMapping ( a ) if m == nil { panic ( fmt . Errorf ( "address %x is not mapped in the core file" , a ) ) } b := m . contents [ a . Sub ( m . min ) : ] if len ( b ) < 8 { var buf [ 8 ] byte b = buf [ : ] p . ReadAt ( b , a ) } if p . littleEndian { return binary . LittleEndian . Uint64 ( b ) } return binary . BigEndian . Uint64 ( b ) }
5787	func ( p * Process ) ReadInt8 ( a Address ) int8 { return int8 ( p . ReadUint8 ( a ) ) }
5788	func ( p * Process ) ReadInt16 ( a Address ) int16 { return int16 ( p . ReadUint16 ( a ) ) }
5789	func ( p * Process ) ReadInt32 ( a Address ) int32 { return int32 ( p . ReadUint32 ( a ) ) }
5790	func ( p * Process ) ReadInt64 ( a Address ) int64 { return int64 ( p . ReadUint64 ( a ) ) }
5791	func ( p * Process ) ReadUintptr ( a Address ) uint64 { if p . ptrSize == 4 { return uint64 ( p . ReadUint32 ( a ) ) } return p . ReadUint64 ( a ) }
5792	func ( p * Process ) ReadPtr ( a Address ) Address { return Address ( p . ReadUintptr ( a ) ) }
5793	func ( p * Process ) ReadCString ( a Address ) string { for n := int64 ( 0 ) ; ; n ++ { if p . ReadUint8 ( a . Add ( n ) ) == 0 { b := make ( [ ] byte , n ) p . ReadAt ( b , a ) return string ( b ) } } }
5794	func ( m * Mapping ) Source ( ) ( string , int64 ) { if m . f == nil { return "" , 0 } return m . f . Name ( ) , m . off }
5795	func ( p * Process ) findMapping ( a Address ) * Mapping { t3 := p . pageTable [ a >> 52 ] if t3 == nil { return nil } t2 := t3 [ a >> 42 % ( 1 << 10 ) ] if t2 == nil { return nil } t1 := t2 [ a >> 32 % ( 1 << 10 ) ] if t1 == nil { return nil } t0 := t1 [ a >> 22 % ( 1 << 10 ) ] if t0 == nil { return nil } return t0 [ a >> 12 % ( 1 << 10 ) ] }
5796	func ( a Address ) Max ( b Address ) Address { if a > b { return a } return b }
5797	func ( a Address ) Min ( b Address ) Address { if a < b { return a } return b }
5798	func ( a Address ) Align ( x int64 ) Address { return ( a + Address ( x ) - 1 ) & ^ ( Address ( x ) - 1 ) }
5799	func ( d * ltDom ) initialize ( ) { type workItem struct { name vName parentName vName } i := 0 d . p . ForEachObject ( func ( x Object ) bool { d . objs [ i ] = x i ++ return true } ) d . semis [ pseudoRoot ] = 0 d . parents [ pseudoRoot ] = - 1 d . vertices [ 0 ] = pseudoRoot var work [ ] workItem for i := 1 ; i < 1 + d . nRoots ; i ++ { work = append ( work , workItem { name : vName ( i ) , parentName : 0 } ) } n := vNumber ( 1 ) for len ( work ) != 0 { item := work [ len ( work ) - 1 ] work = work [ : len ( work ) - 1 ] if d . semis [ item . name ] != - 1 { continue } d . semis [ item . name ] = n d . parents [ item . name ] = item . parentName d . vertices [ n ] = item . name n ++ visitChild := func ( _ int64 , child Object , _ int64 ) bool { childIdx , _ := d . p . findObjectIndex ( d . p . Addr ( child ) ) work = append ( work , workItem { name : vName ( childIdx + d . nRoots + 1 ) , parentName : item . name } ) return true } root , object := d . findVertexByName ( item . name ) if root != nil { d . p . ForEachRootPtr ( root , visitChild ) } else { d . p . ForEachPtr ( object , visitChild ) } } }
5800	func ( d * ltDom ) calculate ( ) { buckets := make ( [ ] vName , d . nVertices ) for i := range buckets { buckets [ i ] = vName ( i ) } for i := vNumber ( len ( d . vertices ) ) - 1 ; i > 0 ; i -- { w := d . vertices [ i ] for v := buckets [ w ] ; v != w ; v = buckets [ v ] { u := d . eval ( v ) if d . semis [ u ] < d . semis [ v ] { d . idom [ v ] = u } else { d . idom [ v ] = w } } root , obj := d . findVertexByName ( w ) if root != nil { u := d . eval ( pseudoRoot ) if d . semis [ u ] < d . semis [ w ] { d . semis [ w ] = d . semis [ u ] } } else { d . p . ForEachReversePtr ( obj , func ( x Object , r * Root , _ , _ int64 ) bool { var v int if r != nil { v = d . p . findRootIndex ( r ) + 1 } else { v , _ = d . p . findObjectIndex ( d . p . Addr ( x ) ) v += d . nRoots + 1 } u := d . eval ( vName ( v ) ) if d . semis [ u ] < d . semis [ w ] { d . semis [ w ] = d . semis [ u ] } return true } ) } d . link ( d . parents [ w ] , w ) if d . parents [ w ] == d . vertices [ d . semis [ w ] ] { d . idom [ w ] = d . parents [ w ] } else { buckets [ w ] = buckets [ d . vertices [ d . semis [ w ] ] ] buckets [ d . vertices [ d . semis [ w ] ] ] = w } } for v := buckets [ pseudoRoot ] ; v != pseudoRoot ; v = buckets [ v ] { d . idom [ v ] = pseudoRoot } for _ , w := range d . vertices [ 1 : ] { if d . idom [ w ] != d . vertices [ d . semis [ w ] ] { d . idom [ w ] = d . idom [ d . idom [ w ] ] } } }
5801	func ( d * ltDom ) eval ( v vName ) vName { if d . ancestor [ v ] == - 1 { return v } d . compress ( v ) return d . labels [ v ] }
5802	func ( d * ltDom ) compress ( v vName ) { var stackBuf [ 20 ] vName stack := stackBuf [ : 0 ] for d . ancestor [ d . ancestor [ v ] ] != - 1 { stack = append ( stack , v ) v = d . ancestor [ v ] } for len ( stack ) != 0 { v := stack [ len ( stack ) - 1 ] stack = stack [ : len ( stack ) - 1 ] if d . semis [ d . labels [ d . ancestor [ v ] ] ] < d . semis [ d . labels [ v ] ] { d . labels [ v ] = d . labels [ d . ancestor [ v ] ] } d . ancestor [ v ] = d . ancestor [ d . ancestor [ v ] ] } }
5803	func ( d * ltDom ) link ( v , w vName ) { d . ancestor [ w ] = v }
5804	func ( d * dominators ) reverse ( ) { cnt := make ( [ ] int , len ( d . idom ) + 2 ) tmp := cnt [ 2 : ] for _ , idom := range d . idom { tmp [ idom ] ++ } var n int for idx , c := range tmp { n += c tmp [ idx ] = n } redge := make ( [ ] vName , len ( d . idom ) ) tmp = cnt [ 1 : ] for i , idom := range d . idom { redge [ tmp [ idom ] ] = vName ( i ) tmp [ idom ] ++ } d . redge , d . ridx = redge , cnt [ : len ( cnt ) - 1 ] }
5805	func ( d * dominators ) calcSize ( p * Process ) { d . size = make ( [ ] int64 , len ( d . idom ) ) type workItem struct { v vName mode dfsMode } work := [ ] workItem { { pseudoRoot , down } } for len ( work ) > 0 { item := & work [ len ( work ) - 1 ] kids := d . redge [ d . ridx [ item . v ] : d . ridx [ item . v + 1 ] ] if item . mode == down && len ( kids ) != 0 { item . mode = up for _ , w := range kids { if w == 0 { continue } work = append ( work , workItem { w , down } ) } continue } work = work [ : len ( work ) - 1 ] root , obj := d . findVertexByName ( item . v ) var size int64 switch { case item . v == pseudoRoot : break case root != nil : size += root . Type . Size default : size += p . Size ( obj ) } for _ , w := range kids { size += d . size [ w ] } d . size [ item . v ] = size } }
5806	func objField ( c * gocore . Process , x gocore . Object , off int64 ) string { t , r := c . Type ( x ) if t == nil { return fmt . Sprintf ( "f%d" , off ) } s := "" if r > 1 { s = fmt . Sprintf ( "[%d]" , off / t . Size ) off %= t . Size } return s + typeFieldName ( t , off ) }
5807	func ( p * Process ) Readable ( a Address ) bool { return p . findMapping ( a ) != nil }
5808	func ( p * Process ) ReadableN ( a Address , n int64 ) bool { for { m := p . findMapping ( a ) if m == nil || m . perm & Read == 0 { return false } c := m . max . Sub ( a ) if n <= c { return true } n -= c a = a . Add ( c ) } }
5809	func ( p * Process ) splitMappingsAt ( a Address ) { for _ , m := range p . memory . mappings { if a < m . min || a > m . max { continue } if a == m . min || a == m . max { return } m2 := new ( Mapping ) * m2 = * m m . max = a m2 . min = a if m2 . f != nil { m2 . off += m . Size ( ) } if m2 . origF != nil { m2 . origOff += m . Size ( ) } p . memory . mappings = append ( p . memory . mappings , m2 ) return } }
5810	func ( p * Process ) DynamicType ( t * Type , a core . Address ) * Type { switch t . Kind { default : panic ( "asking for the dynamic type of a non-interface" ) case KindEface : x := p . proc . ReadPtr ( a ) if x == 0 { return nil } return p . runtimeType2Type ( x ) case KindIface : x := p . proc . ReadPtr ( a ) if x == 0 { return nil } x = p . proc . ReadPtr ( x . Add ( p . proc . PtrSize ( ) ) ) return p . runtimeType2Type ( x ) } }
5811	func ( fs * BtrfsFilesystem ) Create ( bytes uint64 ) error { idempotent := exec . Command ( "bash" , "-e" , "-x" , "-c" , ` if [ ! -e $IMAGE_PATH ] || [ "$(stat --printf="%s" $IMAGE_PATH)" != "$SIZE_IN_BYTES" ]; then touch $IMAGE_PATH truncate -s ${SIZE_IN_BYTES} $IMAGE_PATH fi lo="$(losetup -j $IMAGE_PATH | cut -d':' -f1)" if [ -z "$lo" ]; then lo="$(losetup -f --show $IMAGE_PATH)" fi if ! file $IMAGE_PATH | grep BTRFS; then ` + fs . mkfsBin + ` --nodiscard $IMAGE_PATH fi mkdir -p $MOUNT_PATH if ! mountpoint -q $MOUNT_PATH; then mount -t btrfs $lo $MOUNT_PATH fi ` ) idempotent . Env = [ ] string { "PATH=" + os . Getenv ( "PATH" ) , "MOUNT_PATH=" + fs . mountPath , "IMAGE_PATH=" + fs . imagePath , fmt . Sprintf ( "SIZE_IN_BYTES=%d" , bytes ) , } _ , err := fs . run ( idempotent ) return err }
5812	func Resolve ( u * url . URL ) ( * net . IPAddr , error ) { host , _ , err := SplitHostPort ( u ) if err != nil { return nil , err } addr , err := net . ResolveIPAddr ( "ip" , host ) if err != nil { return nil , err } return addr , nil }
5813	func ( a * Token ) Equal ( b * Token ) bool { if a == nil || b == nil { return false } if a . tokenType != b . tokenType { return false } return a . value == b . value }
5814	func newDefaultClassifier ( ) tokenClassifier { t := tokenClassifier { } t . addRuneClass ( spaceRunes , spaceRuneClass ) t . addRuneClass ( escapingQuoteRunes , escapingQuoteRuneClass ) t . addRuneClass ( nonEscapingQuoteRunes , nonEscapingQuoteRuneClass ) t . addRuneClass ( escapeRunes , escapeRuneClass ) t . addRuneClass ( commentRunes , commentRuneClass ) return t }
5815	func ( l * Lexer ) Next ( ) ( string , error ) { for { token , err := ( * Tokenizer ) ( l ) . Next ( ) if err != nil { return "" , err } switch token . tokenType { case WordToken : return token . value , nil case CommentToken : default : return "" , fmt . Errorf ( "Unknown token type: %v" , token . tokenType ) } } }
5816	func NewTokenizer ( r io . Reader ) * Tokenizer { input := bufio . NewReader ( r ) classifier := newDefaultClassifier ( ) return & Tokenizer { input : * input , classifier : classifier } }
5817	func Split ( s string ) ( [ ] string , error ) { l := NewLexer ( strings . NewReader ( s ) ) subStrings := make ( [ ] string , 0 ) for { word , err := l . Next ( ) if err != nil { if err == io . EOF { return subStrings , nil } return subStrings , err } subStrings = append ( subStrings , word ) } }
5818	func Between ( s , left , right string ) string { l := len ( left ) startPos := strings . Index ( s , left ) if startPos < 0 { return "" } endPos := IndexOf ( s , right , startPos + l ) if endPos < 0 { return "" } else if right == "" { return s [ endPos : ] } else { return s [ startPos + l : endPos ] } }
5819	func BetweenF ( left , right string ) func ( string ) string { return func ( s string ) string { return Between ( s , left , right ) } }
5820	func Camelize ( s string ) string { return camelizeRe . ReplaceAllStringFunc ( s , func ( val string ) string { val = strings . ToUpper ( val ) val = camelizeRe2 . ReplaceAllString ( val , "" ) return val } ) }
5821	func Capitalize ( s string ) string { return strings . ToUpper ( s [ 0 : 1 ] ) + strings . ToLower ( s [ 1 : ] ) }
5822	func CharAt ( s string , index int ) string { l := len ( s ) shortcut := index < 0 || index > l - 1 || l == 0 if shortcut { return "" } return s [ index : index + 1 ] }
5823	func CharAtF ( index int ) func ( string ) string { return func ( s string ) string { return CharAt ( s , index ) } }
5824	func ChompLeft ( s , prefix string ) string { if strings . HasPrefix ( s , prefix ) { return s [ len ( prefix ) : ] } return s }
5825	func ChompLeftF ( prefix string ) func ( string ) string { return func ( s string ) string { return ChompLeft ( s , prefix ) } }
5826	func ChompRight ( s , suffix string ) string { if strings . HasSuffix ( s , suffix ) { return s [ : len ( s ) - len ( suffix ) ] } return s }
5827	func ChompRightF ( suffix string ) func ( string ) string { return func ( s string ) string { return ChompRight ( s , suffix ) } }
5828	func ClassifyF ( s string ) func ( string ) string { return func ( s string ) string { return Classify ( s ) } }
5829	func Clean ( s string ) string { s = spacesRe . ReplaceAllString ( s , " " ) s = beginEndSpacesRe . ReplaceAllString ( s , "" ) return s }
5830	func Dasherize ( s string ) string { s = strings . TrimSpace ( s ) s = spaceUnderscoreRe . ReplaceAllString ( s , "-" ) s = capitalsRe . ReplaceAllString ( s , "-$1" ) s = dashesRe . ReplaceAllString ( s , "-" ) s = strings . ToLower ( s ) return s }
5831	func EscapeHTML ( s string ) string { if Verbose { fmt . Println ( "Use html.EscapeString instead of EscapeHTML" ) } return html . EscapeString ( s ) }
5832	func DecodeHTMLEntities ( s string ) string { if Verbose { fmt . Println ( "Use html.UnescapeString instead of DecodeHTMLEntities" ) } return html . UnescapeString ( s ) }
5833	func EnsurePrefixF ( prefix string ) func ( string ) string { return func ( s string ) string { return EnsurePrefix ( s , prefix ) } }
5834	func EnsureSuffixF ( suffix string ) func ( string ) string { return func ( s string ) string { return EnsureSuffix ( s , suffix ) } }
5835	func Humanize ( s string ) string { if s == "" { return s } s = Underscore ( s ) var humanizeRe = regexp . MustCompile ( `_id$` ) s = humanizeRe . ReplaceAllString ( s , "" ) s = strings . Replace ( s , "_" , " " , - 1 ) s = strings . TrimSpace ( s ) s = Capitalize ( s ) return s }
5836	func Iif ( condition bool , truthy string , falsey string ) string { if condition { return truthy } return falsey }
5837	func IndexOf ( s string , needle string , start int ) int { l := len ( s ) if needle == "" { if start < 0 { return 0 } else if start < l { return start } else { return l } } if start < 0 || start > l - 1 { return - 1 } pos := strings . Index ( s [ start : ] , needle ) if pos == - 1 { return - 1 } return start + pos }
5838	func IsLower ( s string ) bool { return IsAlpha ( s ) && s == strings . ToLower ( s ) }
5839	func IsUpper ( s string ) bool { return IsAlpha ( s ) && s == strings . ToUpper ( s ) }
5840	func Left ( s string , n int ) string { if n < 0 { return Right ( s , - n ) } return Substr ( s , 0 , n ) }
5841	func LeftF ( n int ) func ( string ) string { return func ( s string ) string { return Left ( s , n ) } }
5842	func Letters ( s string ) [ ] string { result := [ ] string { } for _ , r := range s { result = append ( result , string ( r ) ) } return result }
5843	func Lines ( s string ) [ ] string { s = strings . Replace ( s , "\r\n" , \r , \n ) "\n" }
5844	func Map ( arr [ ] string , iterator func ( string ) string ) [ ] string { r := [ ] string { } for _ , item := range arr { r = append ( r , iterator ( item ) ) } return r }
5845	func Match ( s , pattern string ) bool { r := regexp . MustCompile ( pattern ) return r . MatchString ( s ) }
5846	func tasks ( p * do . Project ) { p . Task ( "default" , do . S { "readme" } , nil ) p . Task ( "install" , nil , func ( c * do . Context ) { c . Run ( "go get github.com/robertkrimen/godocdown/godocdown" ) } ) p . Task ( "lint" , nil , func ( c * do . Context ) { c . Run ( "golint ." ) c . Run ( "gofmt -w -s ." ) c . Run ( "go vet ." ) c . Run ( "go test" ) } ) p . Task ( "readme" , nil , func ( c * do . Context ) { c . Run ( "godocdown -output README.md" ) packageName , _ := util . PackageName ( "doc.go" ) goa . Pipe ( f . Load ( "./README.md" ) , f . Str ( str . ReplaceF ( "--" , "\n[godoc](https://godoc.org/" + \n + packageName , ")\n" ) ) , \n , ) } ) . 1 f . Write ( ) Src }
5847	func Pad ( s , c string , n int ) string { L := len ( s ) if L >= n { return s } n -= L left := strings . Repeat ( c , int ( math . Ceil ( float64 ( n ) / 2 ) ) ) right := strings . Repeat ( c , int ( math . Floor ( float64 ( n ) / 2 ) ) ) return left + s + right }
5848	func PadF ( c string , n int ) func ( string ) string { return func ( s string ) string { return Pad ( s , c , n ) } }
5849	func PadLeft ( s , c string , n int ) string { L := len ( s ) if L > n { return s } return strings . Repeat ( c , ( n - L ) ) + s }
5850	func PadLeftF ( c string , n int ) func ( string ) string { return func ( s string ) string { return PadLeft ( s , c , n ) } }
5851	func PadRightF ( c string , n int ) func ( string ) string { return func ( s string ) string { return PadRight ( s , c , n ) } }
5852	func Pipe ( s string , funcs ... func ( string ) string ) string { for _ , fn := range funcs { s = fn ( s ) } return s }
5853	func QuoteItems ( arr [ ] string ) [ ] string { return Map ( arr , func ( s string ) string { return strconv . Quote ( s ) } ) }
5854	func ReplaceF ( old , new string , n int ) func ( string ) string { return func ( s string ) string { return strings . Replace ( s , old , new , n ) } }
5855	func ReplacePatternF ( pattern , repl string ) func ( string ) string { return func ( s string ) string { return ReplacePattern ( s , pattern , repl ) } }
5856	func Reverse ( s string ) string { cs := make ( [ ] rune , utf8 . RuneCountInString ( s ) ) i := len ( cs ) for _ , c := range s { i -- cs [ i ] = c } return string ( cs ) }
5857	func RightF ( n int ) func ( string ) string { return func ( s string ) string { return Right ( s , n ) } }
5858	func Slice ( s string , start , end int ) string { if end > - 1 { return s [ start : end ] } L := len ( s ) if L + end > 0 { return s [ start : L - end ] } return s [ start : ] }
5859	func SliceF ( start , end int ) func ( string ) string { return func ( s string ) string { return Slice ( s , start , end ) } }
5860	func SliceContains ( slice [ ] string , val string ) bool { if slice == nil { return false } for _ , it := range slice { if it == val { return true } } return false }
5861	func SliceIndexOf ( slice [ ] string , val string ) int { if slice == nil { return - 1 } for i , it := range slice { if it == val { return i } } return - 1 }
5862	func Slugify ( s string ) string { sl := slugifyRe . ReplaceAllString ( s , "" ) sl = strings . ToLower ( sl ) sl = Dasherize ( sl ) return sl }
5863	func StripPunctuation ( s string ) string { s = stripPuncRe . ReplaceAllString ( s , "" ) s = nWhitespaceRe . ReplaceAllString ( s , " " ) return s }
5864	func StripTags ( s string , tags ... string ) string { if len ( tags ) == 0 { tags = append ( tags , "" ) } for _ , tag := range tags { stripTagsRe := regexp . MustCompile ( `(?i)<\/?` + tag + `[^<>]*>` ) s = stripTagsRe . ReplaceAllString ( s , "" ) } return s }
5865	func Substr ( s string , index int , n int ) string { L := len ( s ) if index < 0 || index >= L || s == "" { return "" } end := index + n if end >= L { end = L } if end <= index { return "" } return s [ index : end ] }
5866	func SubstrF ( index , n int ) func ( string ) string { return func ( s string ) string { return Substr ( s , index , n ) } }
5867	func TemplateWithDelimiters ( s string , values map [ string ] interface { } , opening , closing string ) string { escapeDelimiter := func ( delim string ) string { result := templateRe . ReplaceAllString ( delim , "\\$1" ) \\ } return templateRe2 . ReplaceAllString ( result , "\\$" ) \\ openingDelim := escapeDelimiter ( opening ) closingDelim := escapeDelimiter ( closing ) r := regexp . MustCompile ( openingDelim + `(.+?)` + closingDelim ) matches := r . FindAllStringSubmatch ( s , - 1 ) }
5868	func ToArgv ( s string ) [ ] string { const ( InArg = iota InArgQuote OutOfArg ) currentState := OutOfArg currentQuoteChar := "\x00" \x00 currentArg := "" argv := [ ] string { } isQuote := func ( c string ) bool { return c == `"` || c == `'` } isEscape := func ( c string ) bool { return c == `\` } isWhitespace := func ( c string ) bool { return c == " " || c == "\t" } \t L := len ( s ) for i := 0 ; i < L ; i ++ { c := s [ i : i + 1 ] if isQuote ( c ) { switch currentState { case OutOfArg : currentArg = "" fallthrough case InArg : currentState = InArgQuote currentQuoteChar = c case InArgQuote : if c == currentQuoteChar { currentState = InArg } else { currentArg += c } } } else if isWhitespace ( c ) { switch currentState { case InArg : argv = append ( argv , currentArg ) currentState = OutOfArg case InArgQuote : currentArg += c case OutOfArg : } } else if isEscape ( c ) { switch currentState { case OutOfArg : currentArg = "" currentState = InArg fallthrough case InArg : fallthrough case InArgQuote : if i == L - 1 { if runtime . GOOS == "windows" { currentArg += c } else { panic ( "Escape character at end string" ) } } else { if runtime . GOOS == "windows" { peek := s [ i + 1 : i + 2 ] if peek != `"` { currentArg += c } } else { i ++ c = s [ i : i + 1 ] currentArg += c } } } } else { switch currentState { case InArg , InArgQuote : currentArg += c case OutOfArg : currentArg = "" currentArg += c currentState = InArg } } } }
5869	func ToBool ( s string ) bool { s = strings . ToLower ( s ) return s == "true" || s == "yes" || s == "on" || s == "1" }
5870	func ToBoolOr ( s string , defaultValue bool ) bool { b , err := strconv . ParseBool ( s ) if err != nil { return defaultValue } return b }
5871	func ToIntOr ( s string , defaultValue int ) int { n , err := strconv . Atoi ( s ) if err != nil { return defaultValue } return n }
5872	func ToFloat32Or ( s string , defaultValue float32 ) float32 { f , err := strconv . ParseFloat ( s , 32 ) if err != nil { return defaultValue } return float32 ( f ) }
5873	func ToFloat64Or ( s string , defaultValue float64 ) float64 { f , err := strconv . ParseFloat ( s , 64 ) if err != nil { return defaultValue } return f }
5874	func UnescapeHTML ( s string ) string { if Verbose { fmt . Println ( "Use html.UnescapeString instead of UnescapeHTML" ) } return html . UnescapeString ( s ) }
5875	func WrapHTML ( s string , tag string , attrs map [ string ] string ) string { escapeHTMLAttributeQuotes := func ( v string ) string { v = strings . Replace ( v , "<" , "&lt;" , - 1 ) v = strings . Replace ( v , "&" , "&amp;" , - 1 ) v = strings . Replace ( v , "\"" , \" , "&quot;" ) - 1 } return v if tag == "" { tag = "div" } el := "<" + tag for name , val := range attrs { el += " " + name + "=\"" + \" + escapeHTMLAttributeQuotes ( val ) } "\"" }
5876	func WrapHTMLF ( tag string , attrs map [ string ] string ) func ( string ) string { return func ( s string ) string { return WrapHTML ( s , tag , attrs ) } }
5877	func ReapChildren ( pids PidCh , errors ErrorCh , done chan struct { } , reapLock * sync . RWMutex ) { c := make ( chan os . Signal , 1 ) signal . Notify ( c , unix . SIGCHLD ) for { select { case <- c : case <- done : return } func ( ) { if reapLock != nil { reapLock . Lock ( ) defer reapLock . Unlock ( ) } POLL : var status unix . WaitStatus pid , err := unix . Wait4 ( - 1 , & status , unix . WNOHANG , nil ) switch err { case nil : if pid > 0 { if pids != nil { pids <- pid } goto POLL } return case unix . ECHILD : return case unix . EINTR : goto POLL default : if errors != nil { errors <- err } return } } ( ) } }
5878	func SdNotify ( state string ) error { name := os . Getenv ( "NOTIFY_SOCKET" ) if name == "" { return ErrSdNotifyNoSocket } conn , err := net . DialUnix ( "unixgram" , nil , & net . UnixAddr { Name : name , Net : "unixgram" } ) if err != nil { return err } defer conn . Close ( ) _ , err = conn . Write ( [ ] byte ( state ) ) return err }
5879	func NewAuthenticator ( store * coal . Store , policy * Policy ) * Authenticator { coal . Init ( policy . Token ) for _ , model := range policy . Clients { coal . Init ( model ) } return & Authenticator { store : store , policy : policy , } }
5880	func ( a * Authenticator ) Endpoint ( prefix string ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { tracer := fire . NewTracerFromRequest ( r , "flame/Authenticator.Endpoint" ) tracer . Tag ( "prefix" , prefix ) defer tracer . Finish ( true ) defer stack . Resume ( func ( err error ) { if oauth2Error , ok := err . ( * oauth2 . Error ) ; ok { _ = oauth2 . WriteError ( w , oauth2Error ) return } tracer . Tag ( "error" , true ) tracer . Log ( "error" , err . Error ( ) ) tracer . Log ( "stack" , stack . Trace ( ) ) if a . Reporter != nil { a . Reporter ( err ) } _ = oauth2 . WriteError ( w , oauth2 . ServerError ( "" ) ) } ) s := strings . Split ( strings . Trim ( strings . TrimPrefix ( r . URL . Path , prefix ) , "/" ) , "/" ) if len ( s ) != 1 || ( s [ 0 ] != "authorize" && s [ 0 ] != "token" && s [ 0 ] != "revoke" ) { w . WriteHeader ( http . StatusNotFound ) return } store := a . store . Copy ( ) defer store . Close ( ) state := & state { request : r , writer : w , store : store , tracer : tracer , } switch s [ 0 ] { case "authorize" : a . authorizationEndpoint ( state ) case "token" : a . tokenEndpoint ( state ) case "revoke" : a . revocationEndpoint ( state ) } } ) }
5881	func Unique ( ids [ ] bson . ObjectId ) [ ] bson . ObjectId { m := make ( map [ bson . ObjectId ] bool ) l := make ( [ ] bson . ObjectId , 0 , len ( ids ) ) for _ , id := range ids { if _ , ok := m [ id ] ; ! ok { m [ id ] = true l = append ( l , id ) } } return l }
5882	func Contains ( list [ ] bson . ObjectId , id bson . ObjectId ) bool { for _ , item := range list { if item == id { return true } } return false }
5883	func Includes ( all , subset [ ] bson . ObjectId ) bool { for _ , item := range subset { if ! Contains ( all , item ) { return false } } return true }
5884	func Require ( m Model , flags ... string ) { for _ , f := range flags { L ( m , f , true ) } }
5885	func Enqueue ( store * coal . SubStore , name string , data Model , delay time . Duration ) ( * Job , error ) { if data == nil { data = bson . M { } } now := time . Now ( ) job := coal . Init ( & Job { Name : name , Status : StatusEnqueued , Created : now , Available : now . Add ( delay ) , } ) . ( * Job ) raw , err := bson . Marshal ( data ) if err != nil { return nil , err } err = bson . Unmarshal ( raw , & job . Data ) if err != nil { return nil , err } err = store . C ( job ) . Insert ( job ) if err != nil { return nil , err } return job , nil }
5886	func A ( name string , m fire . Matcher , h Handler ) * Authorizer { if m == nil || h == nil { panic ( "ash: missing matcher or handler" ) } return & Authorizer { Matcher : m , Handler : func ( ctx * fire . Context ) ( [ ] * Enforcer , error ) { ctx . Tracer . Push ( name ) enforcers , err := h ( ctx ) if err != nil { return nil , err } ctx . Tracer . Pop ( ) return enforcers , nil } , } }
5887	func Run ( enforcers ... * Enforcer ) * Authorizer { return A ( "ash/Run" , fire . All ( ) , func ( ctx * fire . Context ) ( [ ] * Enforcer , error ) { return enforcers , nil } ) }
5888	func And ( a , b * Authorizer ) * Authorizer { return A ( "ash/And" , func ( ctx * fire . Context ) bool { return a . Matcher ( ctx ) && b . Matcher ( ctx ) } , func ( ctx * fire . Context ) ( [ ] * Enforcer , error ) { enforcers1 , err := a . Handler ( ctx ) if err != nil { return nil , err } else if enforcers1 == nil { return nil , nil } enforcers2 , err := b . Handler ( ctx ) if err != nil { return nil , err } else if enforcers2 == nil { return nil , nil } enforcers := append ( S { } , enforcers1 ... ) enforcers = append ( enforcers , enforcers2 ... ) return enforcers , nil } ) }
5889	func Or ( a , b * Authorizer ) * Authorizer { return A ( "ash/Or" , func ( ctx * fire . Context ) bool { return a . Matcher ( ctx ) || b . Matcher ( ctx ) } , func ( ctx * fire . Context ) ( [ ] * Enforcer , error ) { if a . Matcher ( ctx ) { enforcers , err := a . Handler ( ctx ) if err != nil { return nil , err } if enforcers != nil { return enforcers , nil } } if b . Matcher ( ctx ) { enforcers , err := b . Handler ( ctx ) if err != nil { return nil , err } if enforcers != nil { return enforcers , nil } } return nil , nil } ) }
5890	func ( q * Queue ) Enqueue ( name string , data Model , delay time . Duration ) ( * Job , error ) { store := q . store . Copy ( ) defer store . Close ( ) job , err := Enqueue ( store , name , data , delay ) if err != nil { return nil , err } return job , nil }
5891	func ( q * Queue ) Callback ( name string , delay time . Duration , matcher fire . Matcher , cb func ( ctx * fire . Context ) Model ) * fire . Callback { return fire . C ( "axe/Queue.Callback" , matcher , func ( ctx * fire . Context ) error { ctx . Tracer . Tag ( "task" , name ) var data Model if cb != nil { data = cb ( ctx ) } if q . store == ctx . Controller . Store { _ , err := Enqueue ( ctx . Store , name , data , delay ) if err != nil { return err } } else { _ , err := q . Enqueue ( name , data , delay ) if err != nil { return err } } if ctx . Operation . Action ( ) { err := ctx . Respond ( fire . Map { } ) if err != nil { return err } } return nil } ) }
5892	func NewWatcher ( ) * Watcher { w := & Watcher { streams : make ( map [ string ] * Stream ) , } w . manager = newManager ( w ) return w }
5893	func ( w * Watcher ) Add ( stream * Stream ) { coal . Init ( stream . Model ) if w . streams [ stream . Name ( ) ] != nil { panic ( fmt . Sprintf ( `spark: stream with name "%s" already exists` , stream . Name ( ) ) ) } w . streams [ stream . Name ( ) ] = stream coal . OpenStream ( stream . Store , stream . Model , nil , func ( e coal . Event , id bson . ObjectId , m coal . Model , token [ ] byte ) { if stream . SoftDelete && e == coal . Deleted { return } if stream . SoftDelete && e == coal . Updated { softDeleteField := coal . L ( stream . Model , "fire-soft-delete" , true ) t := m . MustGet ( softDeleteField ) . ( * time . Time ) if t != nil && ! t . IsZero ( ) { e = coal . Deleted } } evt := & Event { Type : e , ID : id , Model : m , Stream : stream , } w . manager . broadcast ( evt ) } , nil , func ( err error ) bool { w . Reporter ( err ) return true } ) }
5894	func ( w * Watcher ) Action ( ) * fire . Action { return & fire . Action { Methods : [ ] string { "GET" } , Callback : fire . C ( "spark/Watcher.Action" , fire . All ( ) , func ( ctx * fire . Context ) error { w . manager . handle ( ctx ) return nil } ) , } }
5895	func ( o Operation ) Write ( ) bool { return o == Create || o == Update || o == Delete }
5896	func ( o Operation ) String ( ) string { switch o { case List : return "List" case Find : return "Find" case Create : return "Create" case Update : return "Update" case Delete : return "Delete" case CollectionAction : return "CollectionAction" case ResourceAction : return "ResourceAction" } return "" }
5897	func ( c * Context ) Query ( ) bson . M { return bson . M { "$and" : append ( [ ] bson . M { c . Selector } , c . Filters ... ) } }
5898	func ( c * Context ) Respond ( value interface { } ) error { bytes , err := json . Marshal ( value ) if err != nil { return err } _ , err = c . ResponseWriter . Write ( bytes ) if err != nil { return err } return nil }
5899	func EnsureApplication ( store * coal . Store , name , key , secret string ) ( string , error ) { s := store . Copy ( ) defer s . Close ( ) var apps [ ] Application err := s . C ( & Application { } ) . Find ( bson . M { coal . F ( & Application { } , "Name" ) : name , } ) . All ( & apps ) if err != nil { return "" , err } if len ( apps ) > 1 { return "" , errors . New ( "to many applications with that name" ) } else if len ( apps ) == 1 { return apps [ 0 ] . Key , nil } app := coal . Init ( & Application { } ) . ( * Application ) app . Key = key app . Name = name app . Secret = secret err = app . Validate ( ) if err != nil { return "" , err } err = s . C ( app ) . Insert ( app ) if err != nil { return "" , err } return app . Key , nil }
5900	func EnsureFirstUser ( store * coal . Store , name , email , password string ) error { s := store . Copy ( ) defer s . Close ( ) n , err := s . C ( & User { } ) . Count ( ) if err != nil { return err } else if n > 0 { return nil } user := coal . Init ( & User { } ) . ( * User ) user . Name = name user . Email = email user . Password = password err = user . Validate ( ) if err != nil { return err } err = s . C ( user ) . Insert ( user ) if err != nil { return err } return nil }
5901	func ( s * Strategy ) Callback ( ) * fire . Callback { if s . CollectionAction == nil { s . CollectionAction = make ( map [ string ] [ ] * Authorizer ) } if s . ResourceAction == nil { s . ResourceAction = make ( map [ string ] [ ] * Authorizer ) } return fire . C ( "ash/Strategy.Callback" , fire . All ( ) , func ( ctx * fire . Context ) ( err error ) { switch ctx . Operation { case fire . List : err = s . call ( ctx , s . List , s . Read , s . All ) case fire . Find : err = s . call ( ctx , s . Find , s . Read , s . All ) case fire . Create : err = s . call ( ctx , s . Create , s . Write , s . All ) case fire . Update : err = s . call ( ctx , s . Update , s . Write , s . All ) case fire . Delete : err = s . call ( ctx , s . Delete , s . Write , s . All ) case fire . CollectionAction : err = s . call ( ctx , s . CollectionAction [ ctx . JSONAPIRequest . CollectionAction ] , s . CollectionActions , s . Actions , s . All ) case fire . ResourceAction : err = s . call ( ctx , s . ResourceAction [ ctx . JSONAPIRequest . ResourceAction ] , s . ResourceActions , s . Actions , s . All ) } return err } ) }
5902	func OpenStream ( store * Store , model Model , token [ ] byte , receiver Receiver , opened func ( ) , manager func ( error ) bool ) * Stream { var resumeToken * bson . Raw if token != nil { resumeToken = & bson . Raw { Kind : bson . ElementDocument , Data : token , } } s := & Stream { store : store , model : model , token : resumeToken , receiver : receiver , opened : opened , manager : manager , } go s . open ( ) return s }
5903	func ( s * Stream ) Close ( ) { s . mutex . Lock ( ) defer s . mutex . Unlock ( ) s . closed = true if s . current != nil { _ = s . current . Close ( ) } }
5904	func AddTokenIndexes ( i * coal . Indexer , autoExpire bool ) { i . Add ( & Token { } , false , 0 , "Type" ) i . Add ( & Token { } , false , 0 , "Application" ) i . Add ( & Token { } , false , 0 , "User" ) if autoExpire { i . Add ( & Token { } , false , time . Minute , "ExpiresAt" ) } }
5905	func ( t * Token ) GetTokenData ( ) ( TokenType , [ ] string , time . Time , bson . ObjectId , * bson . ObjectId ) { return t . Type , t . Scope , t . ExpiresAt , t . Application , t . User }
5906	func ( t * Token ) SetTokenData ( typ TokenType , scope [ ] string , expiresAt time . Time , client Client , resourceOwner ResourceOwner ) { t . Type = typ t . Scope = scope t . ExpiresAt = expiresAt t . Application = client . ID ( ) if resourceOwner != nil { t . User = coal . P ( resourceOwner . ID ( ) ) } }
5907	func ( a * Application ) ValidSecret ( secret string ) bool { return bcrypt . CompareHashAndPassword ( a . SecretHash , [ ] byte ( secret ) ) == nil }
5908	func ( a * Application ) HashSecret ( ) error { if len ( a . Secret ) == 0 { return nil } hash , err := bcrypt . GenerateFromPassword ( [ ] byte ( a . Secret ) , bcrypt . DefaultCost ) if err != nil { return err } a . SecretHash = hash a . Secret = "" return nil }
5909	func ( u * User ) ValidPassword ( password string ) bool { return bcrypt . CompareHashAndPassword ( u . PasswordHash , [ ] byte ( password ) ) == nil }
5910	func ( u * User ) HashPassword ( ) error { if len ( u . Password ) == 0 { return nil } hash , err := bcrypt . GenerateFromPassword ( [ ] byte ( u . Password ) , bcrypt . DefaultCost ) if err != nil { return err } u . PasswordHash = hash u . Password = "" return nil }
5911	func MustCreateStore ( uri string ) * Store { store , err := CreateStore ( uri ) if err != nil { panic ( err ) } return store }
5912	func CreateStore ( uri string ) ( * Store , error ) { session , err := mgo . Dial ( uri ) if err != nil { return nil , err } return NewStore ( session ) , nil }
5913	func ( s * SubStore ) C ( model Model ) * mgo . Collection { return s . DB ( ) . C ( C ( model ) ) }
5914	func NewAssetServer ( prefix , directory string ) http . Handler { prefix = "/" + strings . Trim ( prefix , "/" ) dir := http . Dir ( directory ) fs := http . FileServer ( dir ) h := func ( w http . ResponseWriter , r * http . Request ) { f , err := dir . Open ( r . URL . Path ) if err != nil { r . URL . Path = "/" } else if f != nil { _ = f . Close ( ) } fs . ServeHTTP ( w , r ) } return http . StripPrefix ( prefix , http . HandlerFunc ( h ) ) }
5915	func DefaultGrantStrategy ( scope oauth2 . Scope , _ Client , _ ResourceOwner ) ( oauth2 . Scope , error ) { if ! scope . Empty ( ) { return nil , ErrInvalidScope } return scope , nil }
5916	func DefaultTokenData ( _ Client , ro ResourceOwner , _ GenericToken ) map [ string ] interface { } { if ro != nil { return map [ string ] interface { } { "user" : ro . ID ( ) , } } return nil }
5917	func ( p * Policy ) GenerateToken ( id bson . ObjectId , issuedAt , expiresAt time . Time , client Client , resourceOwner ResourceOwner , token GenericToken ) ( string , error ) { claims := & TokenClaims { } claims . Id = id . Hex ( ) claims . IssuedAt = issuedAt . Unix ( ) claims . ExpiresAt = expiresAt . Unix ( ) if p . TokenData != nil { claims . Data = p . TokenData ( client , resourceOwner , token ) } tkn := jwt . NewWithClaims ( jwt . SigningMethodHS256 , claims ) str , err := tkn . SignedString ( p . Secret ) if err != nil { return "" , nil } return str , nil }
5918	func ( p * Policy ) ParseToken ( str string ) ( * TokenClaims , bool , error ) { var claims TokenClaims _ , err := jwt . ParseWithClaims ( str , & claims , func ( _ * jwt . Token ) ( interface { } , error ) { return p . Secret , nil } ) if valErr , ok := err . ( * jwt . ValidationError ) ; ok && valErr . Errors == jwt . ValidationErrorExpired { return nil , true , err } else if err != nil { return nil , false , err } else if ! bson . IsObjectIdHex ( claims . Id ) { return nil , false , errors . New ( "invalid id" ) } return & claims , false , nil }
5919	func E ( name string , m fire . Matcher , h fire . Handler ) * Enforcer { return fire . C ( name , m , h ) }
5920	func ( b * Base ) MustGet ( name string ) interface { } { field := b . meta . Fields [ name ] if field == nil { panic ( fmt . Sprintf ( `coal: field "%s" not found on "%s"` , name , b . meta . Name ) ) } structField := reflect . ValueOf ( b . model ) . Elem ( ) . Field ( field . index ) return structField . Interface ( ) }
5921	func ( b * Base ) MustSet ( name string , value interface { } ) { field := b . meta . Fields [ name ] if field == nil { panic ( fmt . Sprintf ( `coal: field "%s" not found on "%s"` , name , b . meta . Name ) ) } reflect . ValueOf ( b . model ) . Elem ( ) . Field ( field . index ) . Set ( reflect . ValueOf ( value ) ) }
5922	func NewGroup ( ) * Group { return & Group { controllers : make ( map [ string ] * Controller ) , actions : make ( map [ string ] * GroupAction ) , } }
5923	func ( g * Group ) Add ( controllers ... * Controller ) { for _ , controller := range controllers { controller . prepare ( ) name := controller . Model . Meta ( ) . PluralName if g . controllers [ name ] != nil { panic ( fmt . Sprintf ( `fire: controller with name "%s" already exists` , name ) ) } g . controllers [ name ] = controller } }
5924	func ( g * Group ) Endpoint ( prefix string ) http . Handler { prefix = strings . Trim ( prefix , "/" ) return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { tracer := NewTracerFromRequest ( r , "fire/Group.Endpoint" ) defer tracer . Finish ( true ) defer stack . Resume ( func ( err error ) { if jsonapiError , ok := err . ( * jsonapi . Error ) ; ok { _ = jsonapi . WriteError ( w , jsonapiError ) return } tracer . Tag ( "error" , true ) tracer . Log ( "error" , err . Error ( ) ) tracer . Log ( "stack" , stack . Trace ( ) ) if g . Reporter != nil { g . Reporter ( err ) } _ = jsonapi . WriteError ( w , jsonapi . InternalServerError ( "" ) ) } ) path := strings . Trim ( r . URL . Path , "/" ) path = strings . TrimPrefix ( path , prefix ) path = strings . Trim ( path , "/" ) if path == "" { stack . Abort ( jsonapi . NotFound ( "resource not found" ) ) } s := strings . Split ( path , "/" ) ctx := & Context { Data : Map { } , HTTPRequest : r , ResponseWriter : w , Group : g , Tracer : tracer , } controller , ok := g . controllers [ s [ 0 ] ] if ok { ctx . Controller = controller controller . generalHandler ( prefix , ctx ) return } action , ok := g . actions [ s [ 0 ] ] if ok { if Contains ( action . Action . Methods , r . Method ) { if action . Action . Callback . Matcher ( ctx ) { for _ , cb := range action . Authorizers { if ! cb . Matcher ( ctx ) { continue } err := cb . Handler ( ctx ) if IsSafe ( err ) { stack . Abort ( & jsonapi . Error { Status : http . StatusUnauthorized , Detail : err . Error ( ) , } ) } else if err != nil { stack . Abort ( err ) } } LimitBody ( ctx . ResponseWriter , ctx . HTTPRequest , int64 ( action . Action . BodyLimit ) ) stack . AbortIf ( action . Action . Callback . Handler ( ctx ) ) return } } } stack . Abort ( jsonapi . NotFound ( "resource not found" ) ) } ) }
5925	func ( i * Indexer ) Add ( model Model , unique bool , expireAfter time . Duration , fields ... string ) { var key [ ] string for _ , f := range fields { key = append ( key , F ( model , f ) ) } i . AddRaw ( C ( model ) , mgo . Index { Key : key , Unique : unique , ExpireAfter : expireAfter , Background : true , } ) }
5926	func ( i * Indexer ) AddRaw ( coll string , idx mgo . Index ) { i . indexes = append ( i . indexes , index { coll : coll , index : idx , } ) }
5927	func ( i * Indexer ) Ensure ( store * Store ) error { s := store . Copy ( ) defer s . Close ( ) for _ , i := range i . indexes { err := s . DB ( ) . C ( i . coll ) . EnsureIndex ( i . index ) if err != nil { return err } } return nil }
5928	func NewCatalog ( models ... Model ) * Catalog { c := & Catalog { models : make ( map [ string ] Model ) , } c . Add ( models ... ) return c }
5929	func ( c * Catalog ) Add ( models ... Model ) { for _ , model := range models { name := Init ( model ) . Meta ( ) . PluralName if c . models [ name ] != nil { panic ( fmt . Sprintf ( `coal: model with name "%s" already exists in catalog` , name ) ) } c . models [ name ] = model } }
5930	func ( c * Catalog ) All ( ) [ ] Model { models := make ( [ ] Model , 0 , len ( c . models ) ) for _ , model := range c . models { models = append ( models , model ) } return models }
5931	func ( c * Catalog ) Visualize ( title string ) string { var out bytes . Buffer out . WriteString ( "graph G {\n" ) \n out . WriteString ( " rankdir=\"LR\";\n" ) \" \" \n out . WriteString ( " sep=\"0.3\";\n" ) \" \" \n out . WriteString ( " ranksep=\"0.5\";\n" ) \" \" \n out . WriteString ( " nodesep=\"0.4\";\n" ) \" \" \n out . WriteString ( " pad=\"0.4,0.4\";\n" ) \" \" \n out . WriteString ( " margin=\"0,0\";\n" ) \" \" \n out . WriteString ( " labelloc=\"t\";\n" ) \" \" }
5932	func NewErrorReporter ( out io . Writer ) func ( error ) { return func ( err error ) { _ , _ = fmt . Fprintf ( out , "===> Begin Error: %s\n" , \n ) err . Error ( ) _ , _ = out . Write ( debug . Stack ( ) ) } }
5933	func EnsureIndexes ( store * coal . Store ) error { err := indexer . Ensure ( store ) if err != nil { return err } return nil }
5934	func E ( format string , a ... interface { } ) error { return Safe ( fmt . Errorf ( format , a ... ) ) }
5935	func Compose ( chain ... interface { } ) http . Handler { if len ( chain ) < 2 { panic ( "fire: expected chain to have at least two items" ) } h , ok := chain [ len ( chain ) - 1 ] . ( http . Handler ) if ! ok { panic ( `fire: expected last chain item to be a "http.Handler"` ) } for i := len ( chain ) - 2 ; i >= 0 ; i -- { m , ok := chain [ i ] . ( func ( http . Handler ) http . Handler ) if ! ok { panic ( `fire: expected intermediary chain item to be a "func(http.handler) http.Handler"` ) } h = m ( h ) } return h }
5936	func Includes ( all , subset [ ] string ) bool { for _ , item := range subset { if ! Contains ( all , item ) { return false } } return true }
5937	func Intersect ( listA , listB [ ] string ) [ ] string { list := make ( [ ] string , 0 , len ( listA ) ) for _ , item := range listA { if Contains ( listB , item ) { list = append ( list , item ) } } return list }
5938	func E ( reason string , retry bool ) * Error { return & Error { Reason : reason , Retry : retry , } }
5939	func RootTracer ( ) func ( http . Handler ) http . Handler { return func ( next http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { segments := strings . Split ( r . URL . Path , "/" ) for i , s := range segments { if bson . IsObjectIdHex ( s ) { segments [ i ] = ":id" } } path := strings . Join ( segments , "/" ) name := fmt . Sprintf ( "%s %s" , r . Method , path ) tracer := NewTracerFromRequest ( r , name ) tracer . Tag ( "peer.address" , r . RemoteAddr ) tracer . Tag ( "http.proto" , r . Proto ) tracer . Tag ( "http.method" , r . Method ) tracer . Tag ( "http.host" , r . Host ) tracer . Log ( "http.url" , r . URL . String ( ) ) tracer . Log ( "http.length" , r . ContentLength ) tracer . Log ( "http.header" , r . Header ) r = r . WithContext ( tracer . Context ( r . Context ( ) ) ) defer tracer . Finish ( true ) next . ServeHTTP ( w , r ) } ) } }
5940	func NewTracerFromRequest ( r * http . Request , name string ) * Tracer { span , _ := opentracing . StartSpanFromContext ( r . Context ( ) , name ) return NewTracer ( span ) }
5941	func NewTracer ( root opentracing . Span ) * Tracer { return & Tracer { root : root , spans : make ( [ ] opentracing . Span , 0 , 32 ) , } }
5942	func ( t * Tracer ) Push ( name string ) { var ctx opentracing . SpanContext if len ( t . spans ) > 0 { ctx = t . Last ( ) . Context ( ) } else { ctx = t . root . Context ( ) } span := opentracing . StartSpan ( name , opentracing . ChildOf ( ctx ) ) t . spans = append ( t . spans , span ) }
5943	func ( t * Tracer ) Last ( ) opentracing . Span { if len ( t . spans ) == 0 { return t . root } return t . spans [ len ( t . spans ) - 1 ] }
5944	func ( t * Tracer ) Tag ( key string , value interface { } ) { t . Last ( ) . SetTag ( key , value ) }
5945	func ( t * Tracer ) Log ( key string , value interface { } ) { t . Last ( ) . LogKV ( key , value ) }
5946	func ( t * Tracer ) Context ( ctx context . Context ) context . Context { return opentracing . ContextWithSpan ( ctx , t . Last ( ) ) }
5947	func ( t * Tracer ) Pop ( ) { if len ( t . spans ) == 0 { return } t . Last ( ) . Finish ( ) t . spans = t . spans [ : len ( t . spans ) - 1 ] }
5948	func ( t * Tracer ) Finish ( root bool ) { for _ , span := range t . spans { span . Finish ( ) } if root { t . root . Finish ( ) } }
5949	func NewPool ( ) * Pool { return & Pool { tasks : make ( map [ string ] * Task ) , queues : make ( map [ * Queue ] bool ) , closed : make ( chan struct { } ) , } }
5950	func ( p * Pool ) Add ( task * Task ) { if p . tasks [ task . Name ] != nil { panic ( fmt . Sprintf ( `axe: task with name "%s" already exists` , task . Name ) ) } p . tasks [ task . Name ] = task task . Queue . tasks = append ( task . Queue . tasks , task . Name ) p . queues [ task . Queue ] = true }
5951	func ( p * Pool ) Run ( ) { for queue := range p . queues { queue . start ( p ) } for _ , task := range p . tasks { task . start ( p ) } }
5952	func NewBodyLimiter ( w http . ResponseWriter , r * http . Request , n int64 ) * BodyLimiter { return & BodyLimiter { Original : r . Body , ReadCloser : http . MaxBytesReader ( w , r . Body , n ) , } }
5953	func LimitBody ( w http . ResponseWriter , r * http . Request , n int64 ) { if bl , ok := r . Body . ( * BodyLimiter ) ; ok { r . Body = bl . Original } r . Body = NewBodyLimiter ( w , r , n ) }
5954	func C ( name string , m Matcher , h Handler ) * Callback { if m == nil || h == nil { panic ( "fire: missing matcher or handler" ) } return & Callback { Matcher : m , Handler : func ( ctx * Context ) error { ctx . Tracer . Push ( name ) err := h ( ctx ) if err != nil { return err } ctx . Tracer . Pop ( ) return nil } , } }
5955	func Only ( ops ... Operation ) Matcher { return func ( ctx * Context ) bool { for _ , op := range ops { if op == ctx . Operation { return true } } return false } }
5956	func BasicAuthorizer ( credentials map [ string ] string ) * Callback { return C ( "fire/BasicAuthorizer" , All ( ) , func ( ctx * Context ) error { user , password , ok := ctx . HTTPRequest . BasicAuth ( ) if ! ok { return ErrAccessDenied } if val , ok := credentials [ user ] ; ! ok || val != password { return ErrAccessDenied } return nil } ) }
5957	func ModelValidator ( ) * Callback { return C ( "fire/ModelValidator" , Only ( Create , Update ) , func ( ctx * Context ) error { m , ok := ctx . Model . ( ValidatableModel ) if ! ok { return fmt . Errorf ( "model is not validatable" ) } err := m . Validate ( ) if err != nil { return err } return nil } ) }
5958	func TimestampValidator ( ) * Callback { return C ( "fire/TimestampValidator" , Only ( Create , Update ) , func ( ctx * Context ) error { now := time . Now ( ) ctf := coal . L ( ctx . Model , "fire-created-timestamp" , false ) utf := coal . L ( ctx . Model , "fire-updated-timestamp" , false ) if ctf != "" { if ctx . Operation == Create { ctx . Model . MustSet ( ctf , now ) } else if t := ctx . Model . MustGet ( ctf ) . ( time . Time ) ; t . IsZero ( ) { ctx . Model . MustSet ( ctf , ctx . Model . ID ( ) . Time ( ) ) } } if utf != "" { ctx . Model . MustSet ( utf , now ) } return nil } ) }
5959	func RelationshipValidator ( model coal . Model , catalog * coal . Catalog , excludedFields ... string ) * Callback { dependentResources := make ( map [ coal . Model ] string ) references := make ( map [ string ] coal . Model ) for _ , field := range coal . Init ( model ) . Meta ( ) . Relationships { if Contains ( excludedFields , field . Name ) { continue } if field . HasOne || field . HasMany { relatedModel := catalog . Find ( field . RelType ) if relatedModel == nil { panic ( fmt . Sprintf ( `fire: missing model in catalog: "%s"` , field . RelType ) ) } bsonField := "" for _ , relatedField := range relatedModel . Meta ( ) . Relationships { if relatedField . RelName == field . RelInverse { bsonField = relatedField . Name } } if bsonField == "" { panic ( fmt . Sprintf ( `fire: missing field for inverse relationship: "%s"` , field . RelInverse ) ) } dependentResources [ relatedModel ] = bsonField } if field . ToOne || field . ToMany { relatedModel := catalog . Find ( field . RelType ) if relatedModel == nil { panic ( fmt . Sprintf ( `fire: missing model in catalog: "%s"` , field . RelType ) ) } references [ field . Name ] = relatedModel } } cb1 := DependentResourcesValidator ( dependentResources ) cb2 := VerifyReferencesValidator ( references ) return C ( "RelationshipValidator" , func ( ctx * Context ) bool { return cb1 . Matcher ( ctx ) || cb2 . Matcher ( ctx ) } , func ( ctx * Context ) error { if cb1 . Matcher ( ctx ) { err := cb1 . Handler ( ctx ) if err != nil { return err } } if cb2 . Matcher ( ctx ) { err := cb2 . Handler ( ctx ) if err != nil { return err } } return nil } ) }
5960	func ( s * Seekret ) Inspect ( Nworkers int ) { jobs := make ( chan workerJob ) results := make ( chan workerResult ) for w := 1 ; w <= Nworkers ; w ++ { go inspect_worker ( w , jobs , results ) } objectGroupMap := s . GroupObjectsByPrimaryKeyHash ( ) go func ( ) { for _ , objectGroup := range objectGroupMap { jobs <- workerJob { objectGroup : objectGroup , ruleList : s . ruleList , exceptionList : s . exceptionList , } } close ( jobs ) } ( ) for i := 0 ; i < len ( objectGroupMap ) ; i ++ { result := <- results s . secretList = append ( s . secretList , result . secretList ... ) } }
5961	func NewRule ( name string , match string ) ( * Rule , error ) { matchRegexp , err := regexp . Compile ( "(?i)" + match ) if err != nil { return nil , err } if err != nil { fmt . Println ( err ) } r := & Rule { Enabled : false , Name : name , Match : matchRegexp , } return r , nil }
5962	func ( r * Rule ) AddUnmatch ( unmatch string ) error { unmatchRegexp , err := regexp . Compile ( "(?i)" + unmatch ) if err != nil { return err } r . Unmatch = append ( r . Unmatch , unmatchRegexp ) return nil }
5963	func ( r * Rule ) Run ( content [ ] byte ) [ ] RunResult { var results [ ] RunResult b := bufio . NewScanner ( bytes . NewReader ( content ) ) nLine := 0 for b . Scan ( ) { nLine = nLine + 1 line := b . Text ( ) if r . Match . MatchString ( line ) { unmatch := false for _ , Unmatch := range r . Unmatch { if Unmatch . MatchString ( line ) { unmatch = true } } if ! unmatch { results = append ( results , RunResult { Line : line , Nline : nLine , } ) } } } return results }
5964	func NewSecret ( object * Object , rule * Rule , nLine int , line string ) * Secret { s := & Secret { Object : object , Rule : rule , Nline : nLine , Line : line , } return s }
5965	func NewObject ( name string , t string , st string , content [ ] byte ) * Object { if len ( content ) > MaxObjectContentLen { content = content [ : MaxObjectContentLen ] } o := & Object { Type : t , SubType : st , Name : name , Content : content , Metadata : make ( map [ string ] MetadataData ) , PrimaryKeyHash : nil , } return o }
5966	func ( o * Object ) SetMetadata ( key string , value string , attr MetadataAttributes ) error { o . Metadata [ key ] = MetadataData { value : value , attr : attr , } if attr . PrimaryKey { o . updatePrimaryKeyHash ( ) } return nil }
5967	func ( o * Object ) GetMetadata ( key string ) ( string , error ) { data , ok := o . Metadata [ key ] if ! ok { return "" , fmt . Errorf ( "%s unexistent key" , key ) } return data . value , nil }
5968	func ( o * Object ) GetMetadataAll ( attr bool ) map [ string ] string { metadataAll := make ( map [ string ] string ) for k , v := range o . Metadata { metadataAll [ k ] = v . value } return metadataAll }
5969	func ( x * Exception ) SetRule ( rule string ) error { ruleRegexp , err := regexp . Compile ( "(?i)" + rule ) if err != nil { return err } x . Rule = ruleRegexp return nil }
5970	func ( x * Exception ) SetObject ( object string ) error { objectRegexp , err := regexp . Compile ( "(?i)" + object ) if err != nil { return err } x . Object = objectRegexp return nil }
5971	func ( x * Exception ) SetNline ( nLine int ) error { x . Nline = & nLine return nil }
5972	func ( x * Exception ) SetContent ( content string ) error { contentRegexp , err := regexp . Compile ( "(?i)" + content ) if err != nil { return err } x . Content = contentRegexp return nil }
5973	func ( x * Exception ) Run ( s * Secret ) bool { match := true if match && x . Rule != nil && ! x . Rule . MatchString ( s . Rule . Name ) { match = false } if match && x . Object != nil && ! x . Object . MatchString ( s . Object . Name ) { match = false } if match && x . Nline != nil && * x . Nline != s . Nline { match = false } if match && x . Content != nil && ! x . Content . MatchString ( s . Line ) { match = false } return match }
5974	func ( s * Seekret ) AddRule ( rule models . Rule , enabled bool ) { if enabled { rule . Enable ( ) } s . ruleList = append ( s . ruleList , rule ) }
5975	func ( s * Seekret ) LoadRulesFromFile ( file string , defaulEnabled bool ) error { var ruleYamlMap map [ string ] ruleYaml if file == "" { return nil } filename , _ := filepath . Abs ( file ) ruleBase := filepath . Base ( filename ) if filepath . Ext ( ruleBase ) == ".rule" { ruleBase = ruleBase [ 0 : len ( ruleBase ) - 5 ] } yamlData , err := ioutil . ReadFile ( filename ) if err != nil { return err } err = yaml . Unmarshal ( yamlData , & ruleYamlMap ) if err != nil { return err } for k , v := range ruleYamlMap { rule , err := models . NewRule ( ruleBase + "." + k , v . Match ) if err != nil { return err } for _ , e := range v . Unmatch { rule . AddUnmatch ( e ) } s . AddRule ( * rule , defaulEnabled ) } return nil }
5976	func ( s * Seekret ) LoadRulesFromDir ( dir string , defaulEnabled bool ) error { fi , err := os . Stat ( dir ) if err != nil { return err } if ! fi . IsDir ( ) { err := fmt . Errorf ( "%s is not a directory" , dir ) return err } fileList , err := filepath . Glob ( dir + "/*" ) if err != nil { return err } for _ , file := range fileList { if strings . HasSuffix ( file , ".rule" ) { err := s . LoadRulesFromFile ( file , defaulEnabled ) if err != nil { return err } } } return nil }
5977	func DefaultRulesPath ( ) string { rulesPath := os . Getenv ( "SEEKRET_RULES_PATH" ) if rulesPath == "" { rulesPath = os . ExpandEnv ( defaultRulesDir ) } return rulesPath }
5978	func ( s * Seekret ) EnableRule ( name string ) error { return setRuleEnabled ( s . ruleList , name , true ) }
5979	func ( s * Seekret ) DisableRule ( name string ) error { return setRuleEnabled ( s . ruleList , name , false ) }
5980	func ( s * Seekret ) EnableRuleByRegexp ( name string ) int { return setRuleEnabledByRegexp ( s . ruleList , name , true ) }
5981	func ( s * Seekret ) DisableRuleByRegexp ( name string ) int { return setRuleEnabledByRegexp ( s . ruleList , name , false ) }
5982	func ( s * Seekret ) LoadObjects ( st SourceType , source string , opt LoadOptions ) error { objectList , err := st . LoadObjects ( source , opt ) if err != nil { return err } s . objectList = append ( s . objectList , objectList ... ) return nil }
5983	func ( s * Seekret ) GroupObjectsByMetadata ( k string ) map [ string ] [ ] models . Object { return models . GroupObjectsByMetadata ( s . objectList , k ) }
5984	func ( s * Seekret ) GroupObjectsByPrimaryKeyHash ( ) map [ string ] [ ] models . Object { return models . GroupObjectsByPrimaryKeyHash ( s . objectList ) }
5985	func ( s * Seekret ) AddException ( exception models . Exception ) { s . exceptionList = append ( s . exceptionList , exception ) }
5986	func ( s * Seekret ) LoadExceptionsFromFile ( file string ) error { var exceptionYamlList [ ] exceptionYaml if file == "" { return nil } filename , _ := filepath . Abs ( file ) yamlData , err := ioutil . ReadFile ( filename ) if err != nil { return err } err = yaml . Unmarshal ( yamlData , & exceptionYamlList ) if err != nil { return err } for _ , v := range exceptionYamlList { x := models . NewException ( ) if v . Rule != nil { err := x . SetRule ( * v . Rule ) if err != nil { return err } } if v . Object != nil { err := x . SetObject ( * v . Object ) if err != nil { return err } } if v . Line != nil { err := x . SetNline ( * v . Line ) if err != nil { return err } } if v . Content != nil { err := x . SetContent ( * v . Content ) if err != nil { return err } } s . AddException ( * x ) } return nil }
5987	func printPlainResults ( results Results ) error { for _ , res := range results { fmt . Printf ( "Source = %s\n" , \n ) res . origString fmt . Printf ( " String = %s\n" , \n ) res . String if res . Error != "" { fmt . Printf ( " Error = %s\n" , \n ) res . Error } continue typ := reflect . TypeOf ( * res ) } val := reflect . ValueOf ( * res ) }
5988	func printJsonResults ( results Results ) error { data , err := json . MarshalIndent ( results , "" , " " ) if err != nil { return fmt . Errorf ( "Failed to convert results to JSON: %s" , err . Error ( ) ) } if _ , err = io . Copy ( os . Stdout , bytes . NewReader ( data ) ) ; err != nil { return fmt . Errorf ( "Failed to write json output: %s" , err . Error ( ) ) } fmt . Print ( "\n" ) \n }
5989	func NewXor64Source ( seed int64 ) * Xor64Source { var s Xor64Source s . Seed ( seed ) return & s }
5990	func xor64 ( x uint64 ) uint64 { x ^= x << 13 x ^= x >> 7 x ^= x << 17 return x }
5991	func ( s * Xor64Source ) next ( ) uint64 { x := xor64 ( uint64 ( * s ) ) * s = Xor64Source ( x ) return x }
5992	func ( s * Xor64Source ) Seed ( seed int64 ) { if seed == 0 { seed = seed0 } * s = Xor64Source ( seed ) }
5993	func NewFrameSet ( frange string ) ( * FrameSet , error ) { matches , err := frameRangeMatches ( frange ) if err != nil { return nil , err } frameSet := & FrameSet { frange , & ranges . InclusiveRanges { } } for _ , match := range matches { if err = frameSet . handleMatch ( match ) ; err != nil { return nil , err } } return frameSet , nil }
5994	func ( s * FrameSet ) handleMatch ( match [ ] string ) error { switch len ( match ) { case 1 : f , err := parseInt ( match [ 0 ] ) if err != nil { return err } s . rangePtr . AppendUnique ( f , f , 1 ) case 2 : start , err := parseInt ( match [ 0 ] ) if err != nil { return err } end , err := parseInt ( match [ 1 ] ) if err != nil { return err } var inc int if start > end { inc = - 1 } else { inc = 1 } s . rangePtr . AppendUnique ( start , end , inc ) case 4 : var ( err error mod string start , end , chunk int ) chunk , err = parseInt ( match [ 3 ] ) if err != nil { return err } if chunk == 0 { return fmt . Errorf ( "Failed to parse part of range %v. " + "Encountered invalid 0 value" , match [ 3 ] ) } if start , err = parseInt ( match [ 0 ] ) ; err != nil { return err } if end , err = parseInt ( match [ 1 ] ) ; err != nil { return err } if mod = match [ 2 ] ; ! isModifier ( mod ) { return fmt . Errorf ( "%q is not one of the valid modifier 'xy:'" , mod ) } switch mod { case `x` : s . rangePtr . AppendUnique ( start , end , chunk ) case `y` : skip := start aRange := ranges . NewInclusiveRange ( start , end , 1 ) var val int for it := aRange . IterValues ( ) ; ! it . IsDone ( ) ; { val = it . Next ( ) if val == skip { skip += chunk continue } s . rangePtr . AppendUnique ( val , val , 1 ) } case `:` : for ; chunk > 0 ; chunk -- { s . rangePtr . AppendUnique ( start , end , chunk ) } } default : return fmt . Errorf ( "Unexpected match []string size: %v" , match ) } return nil }
5995	func ( s * FrameSet ) Index ( frame int ) int { return s . rangePtr . Index ( frame ) }
5996	func ( s * FrameSet ) Frame ( index int ) ( int , error ) { return s . rangePtr . Value ( index ) }
5997	func ( s * FrameSet ) HasFrame ( frame int ) bool { return s . rangePtr . Contains ( frame ) }
5998	func ( s * FrameSet ) FrameRangePadded ( pad int ) string { return PadFrameRange ( s . frange , pad ) }
5999	func ( s * FrameSet ) Normalize ( ) * FrameSet { ptr := s . rangePtr . Normalized ( ) return & FrameSet { ptr . String ( ) , ptr } }
6000	func FramesToFrameRange ( frames [ ] int , sorted bool , zfill int ) string { count := len ( frames ) if count == 0 { return "" } if count == 1 { return zfillInt ( frames [ 0 ] , zfill ) } if sorted { sort . Ints ( frames ) } var i , frame , step int var start , end string var buf strings . Builder for len ( frames ) > 0 { count = len ( frames ) if count <= 2 { for _ , frame = range frames { if buf . Len ( ) > 0 { buf . WriteString ( "," ) } buf . WriteString ( zfillInt ( frame , zfill ) ) } break } step = frames [ 1 ] - frames [ 0 ] for i = 0 ; i < len ( frames ) - 1 ; i ++ { if ( frames [ i + 1 ] - frames [ i ] ) != step { break } } if buf . Len ( ) > 0 { buf . WriteString ( "," ) } if i == 0 { buf . WriteString ( zfillInt ( frames [ 0 ] , zfill ) ) frames = frames [ 1 : ] continue } if i == 1 && count > 3 { if ( frames [ 2 ] - frames [ 1 ] ) == ( frames [ 3 ] - frames [ 2 ] ) { buf . WriteString ( zfillInt ( frames [ 0 ] , zfill ) ) frames = frames [ 1 : ] continue } } start = zfillInt ( frames [ 0 ] , zfill ) end = zfillInt ( frames [ i ] , zfill ) buf . WriteString ( fmt . Sprintf ( "%s-%s" , start , end ) ) if step > 1 { buf . WriteString ( fmt . Sprintf ( "x%d" , step ) ) } frames = frames [ i + 1 : ] } return buf . String ( ) }
6001	func frameRangeMatches ( frange string ) ( [ ] [ ] string , error ) { for _ , k := range defaultPadding . AllChars ( ) { frange = strings . Replace ( frange , k , "" , - 1 ) } var ( matched bool match [ ] string rx * regexp . Regexp ) frange = strings . Replace ( frange , " " , "" , - 1 ) parts := strings . Split ( frange , "," ) size := len ( parts ) matches := make ( [ ] [ ] string , size , size ) for i , part := range parts { matched = false for _ , rx = range rangePatterns { if match = rx . FindStringSubmatch ( part ) ; match == nil { continue } matched = true matches [ i ] = match [ 1 : ] } if ! matched { err := fmt . Errorf ( "Failed to parse frame range: %s on part %q" , frange , part ) return nil , err } } return matches , nil }
6002	func toRange ( start , end , step int ) [ ] int { nums := [ ] int { } if step < 1 { step = 1 } if start <= end { for i := start ; i <= end ; { nums = append ( nums , i ) i += step } } else { for i := start ; i >= end ; { nums = append ( nums , i ) i -= step } } return nums }
6003	func NewWorkManager ( ) * workManager { var fileopts [ ] fileseq . FileOption if Options . AllFiles { fileopts = append ( fileopts , fileseq . HiddenFiles ) } if ! Options . SeqsOnly { fileopts = append ( fileopts , fileseq . SingleFiles ) } s := & workManager { inDirs : make ( chan string ) , inSeqs : make ( chan * fileseq . FileSequence ) , outSeqs : make ( chan fileseq . FileSequences ) , fileOpts : fileopts , } return s }
6004	func ( w * workManager ) processSources ( ) { var ( ok bool path string seq * fileseq . FileSequence ) fileopts := w . fileOpts inDirs := w . inDirs inSeqs := w . inSeqs outSeqs := w . outSeqs isDone := func ( ) bool { return ( inDirs == nil && inSeqs == nil ) } for ! isDone ( ) { select { case path , ok = <- inDirs : if ! ok { inDirs = nil continue } seqs , err := fileseq . FindSequencesOnDisk ( path , fileopts ... ) if err != nil { fmt . Fprintf ( errOut , "%s %q: %s\n" , \n , ErrorPath , path ) err } continue outSeqs <- seqs } } }
6005	func ( w * workManager ) isInputDone ( ) bool { if w . inDirs != nil { return false } if w . inSeqs != nil { return false } return true }
6006	func ( w * workManager ) closeInputs ( ) { if w . inDirs != nil { close ( w . inDirs ) } if w . inSeqs != nil { close ( w . inSeqs ) } }
6007	func ( w * workManager ) load ( paths [ ] string ) { dirs , seqs := preparePaths ( paths ) for _ , s := range seqs { w . inSeqs <- s } for _ , r := range dirs { w . inDirs <- r } }
6008	func ( w * workManager ) loadRecursive ( paths [ ] string ) { walkFn := func ( path string , info os . FileInfo , err error ) error { if err != nil { return nil } var isDir bool if info . IsDir ( ) { isDir = true } else if info , err = os . Stat ( path ) ; err == nil && info . IsDir ( ) { isDir = true } if isDir { if ! Options . AllFiles { if len ( info . Name ( ) ) > 1 && strings . HasPrefix ( info . Name ( ) , "." ) { return walk . SkipDir } } w . inDirs <- path } return nil } dirs , seqs := preparePaths ( paths ) for _ , s := range seqs { w . inSeqs <- s } for _ , r := range dirs { r := r if err := walk . Walk ( r , walkFn ) ; err != nil { if err != walk . SkipDir { fmt . Fprintf ( errOut , "%s %q: %s\n" , \n , ErrorPath , r ) } } } }
6009	func preparePaths ( paths [ ] string ) ( [ ] string , fileseq . FileSequences ) { var ( fi os . FileInfo err error ) dirs := make ( [ ] string , 0 ) seqs := make ( fileseq . FileSequences , 0 ) previous := make ( map [ string ] struct { } ) for _ , p := range paths { p := strings . TrimSpace ( filepath . Clean ( p ) ) if p == "" { continue } if _ , seen := previous [ p ] ; seen { continue } previous [ p ] = struct { } { } if fi , err = os . Stat ( p ) ; err != nil { if seq , err := fileseq . NewFileSequence ( p ) ; err == nil { seqs = append ( seqs , seq ) continue } fmt . Fprintf ( errOut , "%s %q: %s\n" , \n , ErrorPath , p ) err } continue if ! fi . IsDir ( ) { continue } } dirs = append ( dirs , p ) }
6010	func PadFrameRange ( frange string , pad int ) string { if pad < 2 { return frange } size := strings . Count ( frange , "," ) + 1 parts := make ( [ ] string , size , size ) for i , part := range strings . Split ( frange , "," ) { didMatch := false for _ , rx := range rangePatterns { matched := rx . FindStringSubmatch ( part ) if len ( matched ) == 0 { continue } matched = matched [ 1 : ] size = len ( matched ) switch size { case 1 : parts [ i ] = zfillString ( matched [ 0 ] , pad ) case 2 : parts [ i ] = fmt . Sprintf ( "%s-%s" , zfillString ( matched [ 0 ] , pad ) , zfillString ( matched [ 1 ] , pad ) ) case 4 : parts [ i ] = fmt . Sprintf ( "%s-%s%s%s" , zfillString ( matched [ 0 ] , pad ) , zfillString ( matched [ 1 ] , pad ) , matched [ 2 ] , matched [ 3 ] ) default : continue } didMatch = true break } if ! didMatch { parts = append ( parts , part ) } } return strings . Join ( parts , "," ) }
6011	func zfillString ( src string , z int ) string { size := len ( src ) if size >= z { return src } fill := strings . Repeat ( "0" , z - size ) if strings . HasPrefix ( src , "-" ) { return fmt . Sprintf ( "-%s%s" , fill , src [ 1 : ] ) } return fmt . Sprintf ( "%s%s" , fill , src ) }
6012	func zfillInt ( src int , z int ) string { if z < 2 { return strconv . Itoa ( src ) } return fmt . Sprintf ( fmt . Sprintf ( "%%0%dd" , z ) , src ) }
6013	func NewInclusiveRange ( start , end , step int ) * InclusiveRange { if step == 0 { if start <= end { step = 1 } else { step = - 1 } } r := & InclusiveRange { start : start , end : end , step : step , } return r }
6014	func ( r * InclusiveRange ) String ( ) string { var buf strings . Builder buf . WriteString ( strconv . Itoa ( r . Start ( ) ) ) if r . End ( ) != r . Start ( ) { buf . WriteString ( `-` ) buf . WriteString ( strconv . Itoa ( r . End ( ) ) ) step := r . Step ( ) if step > 1 || step < - 1 { buf . WriteString ( `x` ) buf . WriteString ( strconv . Itoa ( r . Step ( ) ) ) } } return buf . String ( ) }
6015	func ( r * InclusiveRange ) End ( ) int { if r . isEndCached { return r . cachedEnd } r . isEndCached = true if r . step == 1 || r . step == - 1 || r . start == r . end { r . cachedEnd = r . end return r . cachedEnd } if ( r . end < r . start ) && r . step < ( r . end - r . start ) { r . cachedEnd = r . start return r . cachedEnd } else if ( r . end > r . start ) && r . step > ( r . end - r . start ) { r . cachedEnd = r . start return r . cachedEnd } r . cachedEnd = r . closestInRange ( r . end , r . start , r . end , r . step ) return r . cachedEnd }
6016	func ( r * InclusiveRange ) Len ( ) int { if r . isLenCached { return r . cachedLen } diff := math . Abs ( float64 ( r . end - r . start ) ) + 1 r . cachedLen = int ( math . Ceil ( diff / math . Abs ( float64 ( r . step ) ) ) ) r . isLenCached = true return r . cachedLen }
6017	func ( r * InclusiveRange ) Min ( ) int { start := r . Start ( ) end := r . End ( ) if start < end { return start } return end }
6018	func ( r * InclusiveRange ) Max ( ) int { start := r . Start ( ) end := r . End ( ) if start > end { return start } return end }
6019	func ( r * InclusiveRange ) Contains ( value int ) bool { closest := r . closestInRange ( value , r . start , r . End ( ) , r . step ) return closest == value }
6020	func ( * InclusiveRange ) closestInRange ( value , start , end , step int ) int { if end >= start { if value < start { return start } else if value > end { return end } } else { if value > start { return start } else if value < end { return end } } if step == 1 || step == - 1 { return value } return ( ( ( value - start ) / step ) * step ) + start }
6021	func ( f * InclusiveRange ) Index ( value int ) int { closest := f . closestInRange ( value , f . start , f . End ( ) , f . step ) if closest != value { return - 1 } idx := ( value - f . start ) / f . step if idx < 0 { idx *= - 1 } return idx }
6022	func ( l * InclusiveRanges ) String ( ) string { var buf strings . Builder for i , b := range l . blocks { if i > 0 { buf . WriteString ( `,` ) } buf . WriteString ( b . String ( ) ) } return buf . String ( ) }
6023	func ( l * InclusiveRanges ) Len ( ) int { var totalLen int for _ , b := range l . blocks { totalLen += b . Len ( ) } return totalLen }
6024	func ( l * InclusiveRanges ) Start ( ) int { for _ , b := range l . blocks { return b . Start ( ) } return 0 }
6025	func ( l * InclusiveRanges ) End ( ) int { if l . blocks == nil { return 0 } return l . blocks [ len ( l . blocks ) - 1 ] . End ( ) }
6026	func ( l * InclusiveRanges ) Min ( ) int { val := l . Start ( ) for _ , aRange := range l . blocks { next := aRange . Min ( ) if next < val { val = next } } return val }
6027	func ( l * InclusiveRanges ) Max ( ) int { val := l . End ( ) for _ , aRange := range l . blocks { next := aRange . Max ( ) if next > val { val = next } } return val }
6028	func ( l * InclusiveRanges ) numRanges ( ) int { if l . blocks == nil { return 0 } return len ( l . blocks ) }
6029	func ( l * InclusiveRanges ) rangeAt ( idx int ) * InclusiveRange { if idx < 0 || idx >= l . numRanges ( ) { return nil } return l . blocks [ idx ] }
6030	func ( l * InclusiveRanges ) Append ( start , end , step int ) { block := NewInclusiveRange ( start , end , step ) l . blocks = append ( l . blocks , block ) }
6031	func ( l * InclusiveRanges ) AppendUnique ( start , end , step int ) { if step == 0 { return } subStart := start subEnd := start subStep := step last := start pending := 0 var pred func ( ) bool if start <= end { if step < 0 { step *= - 1 } pred = func ( ) bool { return subEnd <= end } } else { if step > 0 { step *= - 1 } pred = func ( ) bool { return subEnd >= end } } if len ( l . blocks ) == 0 { l . Append ( start , end , step ) return } for ; pred ( ) ; subEnd += step { if ! l . Contains ( subEnd ) { last = subEnd if pending == 0 { subStart = last } pending ++ continue } if pending == 0 { continue } l . Append ( subStart , last , subStep ) subStart = subEnd + step pending = 0 } if pending > 0 { l . Append ( subStart , last , subStep ) } }
6032	func ( l * InclusiveRanges ) Contains ( value int ) bool { for _ , b := range l . blocks { if b . Contains ( value ) { return true } } return false }
6033	func ( l * InclusiveRanges ) Index ( value int ) int { var idx , n int for _ , b := range l . blocks { if idx = b . Index ( value ) ; idx >= 0 { return idx + n } n += b . Len ( ) } return - 1 }
6034	func ( s * FileSequence ) FrameRange ( ) string { if s . frameSet == nil { return "" } return s . frameSet . FrameRange ( ) }
6035	func ( s * FileSequence ) FrameRangePadded ( ) string { if s . frameSet == nil { return "" } return s . frameSet . FrameRangePadded ( s . zfill ) }
6036	func ( s * FileSequence ) Index ( idx int ) string { if s . frameSet == nil { return s . String ( ) } frame , err := s . frameSet . Frame ( idx ) if err != nil { return "" } path , err := s . Frame ( frame ) if err != nil { return "" } return path }
6037	func ( s * FileSequence ) SetDirname ( dir string ) { if ! strings . HasSuffix ( dir , string ( filepath . Separator ) ) { dir = dir + string ( filepath . Separator ) } s . dir = dir }
6038	func ( s * FileSequence ) SetPadding ( padChars string ) { s . padChar = padChars s . zfill = s . padMapper . PaddingCharsSize ( padChars ) }
6039	func ( s * FileSequence ) SetPaddingStyle ( style PadStyle ) { s . padMapper = padders [ style ] s . SetPadding ( s . padMapper . PaddingChars ( s . ZFill ( ) ) ) }
6040	func ( s * FileSequence ) SetExt ( ext string ) { if ! strings . HasPrefix ( ext , "." ) { ext = "." + ext } s . ext = ext }
6041	func ( s * FileSequence ) SetFrameRange ( frameRange string ) error { frameSet , err := NewFrameSet ( frameRange ) if err != nil { return err } s . frameSet = frameSet return nil }
6042	func ( s * FileSequence ) Len ( ) int { if s . frameSet == nil { return 1 } return s . frameSet . Len ( ) }
6043	func ( s * FileSequence ) String ( ) string { var fs string if s . frameSet != nil { fs = s . frameSet . String ( ) } buf := bytes . NewBufferString ( s . dir ) buf . WriteString ( s . basename ) buf . WriteString ( fs ) buf . WriteString ( s . padChar ) buf . WriteString ( s . ext ) return buf . String ( ) }
6044	func ( s * FileSequence ) Copy ( ) * FileSequence { seq , _ := NewFileSequence ( s . String ( ) ) return seq }
6045	func NewClient ( url string , tls bool , header interface { } ) * Client { return & Client { url : url , tls : tls , header : header , } }
6046	func ( h * Header ) UnmarshalXML ( d * xml . Decoder , start xml . StartElement ) error { var ( token xml . Token err error ) Loop : for { if token , err = d . Token ( ) ; err != nil { return err } if token == nil { break } switch se := token . ( type ) { case xml . StartElement : if err = d . DecodeElement ( h . Content , & se ) ; err != nil { return err } case xml . EndElement : break Loop } } return nil }
6047	func ( b * Body ) UnmarshalXML ( d * xml . Decoder , start xml . StartElement ) error { if b . Content == nil { return xml . UnmarshalError ( "Content must be a pointer to a struct" ) } var ( token xml . Token err error consumed bool ) Loop : for { if token , err = d . Token ( ) ; err != nil { return err } if token == nil { break } envelopeNameSpace := "http://schemas.xmlsoap.org/soap/envelope/" switch se := token . ( type ) { case xml . StartElement : if consumed { return xml . UnmarshalError ( "Found multiple elements inside SOAP body; not wrapped-document/literal WS-I compliant" ) } else if se . Name . Space == envelopeNameSpace && se . Name . Local == "Fault" { b . Fault = & Fault { } b . Content = nil err = d . DecodeElement ( b . Fault , & se ) if err != nil { return err } consumed = true } else { if err = d . DecodeElement ( b . Content , & se ) ; err != nil { return err } consumed = true } case xml . EndElement : break Loop } } return nil }
6048	func ( s * Client ) Call ( soapAction string , request , response , header interface { } ) error { var envelope Envelope if s . header != nil { envelope = Envelope { Header : & Header { Content : s . header , } , Body : Body { Content : request , } , } } else { envelope = Envelope { Body : Body { Content : request , } , } } buffer := new ( bytes . Buffer ) encoder := xml . NewEncoder ( buffer ) encoder . Indent ( " " , " " ) if err := encoder . Encode ( envelope ) ; err != nil { return errors . Wrap ( err , "failed to encode envelope" ) } if err := encoder . Flush ( ) ; err != nil { return errors . Wrap ( err , "failed to flush encoder" ) } req , err := http . NewRequest ( "POST" , s . url , buffer ) if err != nil { return errors . Wrap ( err , "failed to create POST request" ) } req . Header . Add ( "Content-Type" , "text/xml; charset=\"utf-8\"" ) \" \" req . Header . Set ( "SOAPAction" , soapAction ) req . Header . Set ( "User-Agent" , s . userAgent ) req . Close = true tr := & http . Transport { TLSClientConfig : & tls . Config { InsecureSkipVerify : s . tls , } , Dial : dialTimeout , } client := & http . Client { Transport : tr } res , err := client . Do ( req ) if err != nil { return errors . Wrap ( err , "failed to send SOAP request" ) } defer res . Body . Close ( ) if res . StatusCode != http . StatusOK { soapFault , err := ioutil . ReadAll ( res . Body ) if err != nil { return errors . Wrap ( err , "failed to read SOAP fault response body" ) } msg := fmt . Sprintf ( "HTTP Status Code: %d, SOAP Fault: \n%s" , \n , res . StatusCode ) string ( soapFault ) } return errors . New ( msg ) rawbody , err := ioutil . ReadAll ( res . Body ) if err != nil { return errors . Wrap ( err , "failed to read SOAP body" ) } if len ( rawbody ) == 0 { return nil } respEnvelope := Envelope { } respEnvelope . Body = Body { Content : response } }
6049	func JSONDoc ( path string ) ( json . RawMessage , error ) { data , err := swag . LoadFromFileOrHTTP ( path ) if err != nil { return nil , err } return json . RawMessage ( data ) , nil }
6050	func AddLoader ( predicate DocMatcher , load DocLoader ) { prev := loaders loaders = & loader { Match : predicate , Fn : load , Next : prev , } spec . PathLoader = loaders . Fn }
6051	func JSONSpec ( path string ) ( * Document , error ) { data , err := JSONDoc ( path ) if err != nil { return nil , err } return Analyzed ( data , "" ) }
6052	func Embedded ( orig , flat json . RawMessage ) ( * Document , error ) { var origSpec , flatSpec spec . Swagger if err := json . Unmarshal ( orig , & origSpec ) ; err != nil { return nil , err } if err := json . Unmarshal ( flat , & flatSpec ) ; err != nil { return nil , err } return & Document { raw : orig , origSpec : & origSpec , spec : & flatSpec , } , nil }
6053	func Spec ( path string ) ( * Document , error ) { specURL , err := url . Parse ( path ) if err != nil { return nil , err } var lastErr error for l := loaders . Next ; l != nil ; l = l . Next { if loaders . Match ( specURL . Path ) { b , err2 := loaders . Fn ( path ) if err2 != nil { lastErr = err2 continue } doc , err3 := Analyzed ( b , "" ) if err3 != nil { return nil , err3 } if doc != nil { doc . specFilePath = path } return doc , nil } } if lastErr != nil { return nil , lastErr } b , err := defaultLoader . Fn ( path ) if err != nil { return nil , err } document , err := Analyzed ( b , "" ) if document != nil { document . specFilePath = path } return document , err }
6054	func Analyzed ( data json . RawMessage , version string ) ( * Document , error ) { if version == "" { version = "2.0" } if version != "2.0" { return nil , fmt . Errorf ( "spec version %q is not supported" , version ) } raw := data trimmed := bytes . TrimSpace ( data ) if len ( trimmed ) > 0 { if trimmed [ 0 ] != '{' && trimmed [ 0 ] != '[' { yml , err := swag . BytesToYAMLDoc ( trimmed ) if err != nil { return nil , fmt . Errorf ( "analyzed: %v" , err ) } d , err := swag . YAMLToJSON ( yml ) if err != nil { return nil , fmt . Errorf ( "analyzed: %v" , err ) } raw = d } } swspec := new ( spec . Swagger ) if err := json . Unmarshal ( raw , swspec ) ; err != nil { return nil , err } origsqspec , err := cloneSpec ( swspec ) if err != nil { return nil , err } d := & Document { Analyzer : analysis . New ( swspec ) , schema : spec . MustLoadSwagger20Schema ( ) , spec : swspec , raw : raw , origSpec : origsqspec , } return d , nil }
6055	func ( d * Document ) Expanded ( options ... * spec . ExpandOptions ) ( * Document , error ) { swspec := new ( spec . Swagger ) if err := json . Unmarshal ( d . raw , swspec ) ; err != nil { return nil , err } var expandOptions * spec . ExpandOptions if len ( options ) > 0 { expandOptions = options [ 0 ] } else { expandOptions = & spec . ExpandOptions { RelativeBase : d . specFilePath , } } if err := spec . ExpandSpec ( swspec , expandOptions ) ; err != nil { return nil , err } dd := & Document { Analyzer : analysis . New ( swspec ) , spec : swspec , specFilePath : d . specFilePath , schema : spec . MustLoadSwagger20Schema ( ) , raw : d . raw , origSpec : d . origSpec , } return dd , nil }
6056	func ( d * Document ) ResetDefinitions ( ) * Document { defs := make ( map [ string ] spec . Schema , len ( d . origSpec . Definitions ) ) for k , v := range d . origSpec . Definitions { defs [ k ] = v } d . spec . Definitions = defs return d }
6057	func ( d * Document ) Pristine ( ) * Document { dd , _ := Analyzed ( d . Raw ( ) , d . Version ( ) ) return dd }
6058	func OpenDb ( files [ ] string , flag int ) ( * GeoIP , error ) { if len ( files ) == 0 { files = [ ] string { "/usr/share/GeoIP/GeoIP.dat" , "/usr/share/local/GeoIP/GeoIP.dat" , "/usr/local/share/GeoIP/GeoIP.dat" , "/opt/local/share/GeoIP/GeoIP.dat" , "/usr/share/GeoIP/GeoIP.dat" , } } g := & GeoIP { } runtime . SetFinalizer ( g , ( * GeoIP ) . free ) var err error for _ , file := range files { if _ , err := os . Stat ( file ) ; err != nil { if os . IsExist ( err ) { log . Println ( err ) } continue } cbase := C . CString ( file ) defer C . free ( unsafe . Pointer ( cbase ) ) g . db , err = C . GeoIP_open ( cbase , C . int ( flag ) ) if g . db != nil && err != nil { break } } if err != nil { return nil , fmt . Errorf ( "Error opening GeoIP database (%s): %s" , files , err ) } if g . db == nil { return nil , fmt . Errorf ( "Didn't open GeoIP database (%s)" , files ) } C . GeoIP_set_charset ( g . db , C . GEOIP_CHARSET_UTF8 ) return g , nil }
6059	func ( gi * GeoIP ) GetOrg ( ip string ) string { name , _ := gi . GetName ( ip ) return name }
6060	func ( gi * GeoIP ) GetRegion ( ip string ) ( string , string ) { if gi . db == nil { return "" , "" } cip := C . CString ( ip ) defer C . free ( unsafe . Pointer ( cip ) ) gi . mu . Lock ( ) region := C . GeoIP_region_by_addr ( gi . db , cip ) gi . mu . Unlock ( ) if region == nil { return "" , "" } countryCode := C . GoString ( & region . country_code [ 0 ] ) regionCode := C . GoString ( & region . region [ 0 ] ) defer C . free ( unsafe . Pointer ( region ) ) return countryCode , regionCode }
6061	func GetRegionName ( countryCode , regionCode string ) string { cc := C . CString ( countryCode ) defer C . free ( unsafe . Pointer ( cc ) ) rc := C . CString ( regionCode ) defer C . free ( unsafe . Pointer ( rc ) ) region := C . GeoIP_region_name_by_code ( cc , rc ) if region == nil { return "" } regionName := C . GoString ( region ) return regionName }
6062	func ( gi * GeoIP ) GetCountry ( ip string ) ( cc string , netmask int ) { if gi . db == nil { return } gi . mu . Lock ( ) defer gi . mu . Unlock ( ) cip := C . CString ( ip ) defer C . free ( unsafe . Pointer ( cip ) ) ccountry := C . GeoIP_country_code_by_addr ( gi . db , cip ) if ccountry != nil { cc = C . GoString ( ccountry ) netmask = int ( C . GeoIP_last_netmask ( gi . db ) ) return } return }
6063	func NewRotatingFileHandler ( fileName string , maxBytes int , backupCount int ) ( * RotatingFileHandler , error ) { dir := path . Dir ( fileName ) os . MkdirAll ( dir , 0777 ) h := new ( RotatingFileHandler ) if maxBytes <= 0 { return nil , fmt . Errorf ( "invalid max bytes" ) } h . fileName = fileName h . maxBytes = maxBytes h . backupCount = backupCount var err error h . fd , err = os . OpenFile ( fileName , os . O_CREATE | os . O_WRONLY | os . O_APPEND , 0666 ) if err != nil { return nil , err } f , err := h . fd . Stat ( ) if err != nil { return nil , err } h . curBytes = int ( f . Size ( ) ) return h , nil }
6064	func ( h * RotatingFileHandler ) Close ( ) error { if h . fd != nil { return h . fd . Close ( ) } return nil }
6065	func ( l Level ) String ( ) string { switch l { case LevelTrace : return "trace" case LevelDebug : return "debug" case LevelInfo : return "info" case LevelWarn : return "warn" case LevelError : return "error" case LevelFatal : return "fatal" } return "info" }
6066	func New ( handler Handler , flag int ) * Logger { var l = new ( Logger ) l . level = LevelInfo l . handler = handler l . flag = flag l . bufs = sync . Pool { New : func ( ) interface { } { return make ( [ ] byte , 0 , 1024 ) } , } return l }
6067	func ( l * Logger ) Close ( ) { l . hLock . Lock ( ) defer l . hLock . Unlock ( ) l . handler . Close ( ) }
6068	func ( l * Logger ) SetLevelByName ( name string ) { level := LevelInfo switch strings . ToLower ( name ) { case "trace" : level = LevelTrace case "debug" : level = LevelDebug case "warn" , "warning" : level = LevelWarn case "error" : level = LevelError case "fatal" : level = LevelFatal default : level = LevelInfo } l . SetLevel ( level ) }
6069	func ( l * Logger ) Output ( callDepth int , level Level , msg string ) { if l . level > level { return } buf := l . bufs . Get ( ) . ( [ ] byte ) buf = buf [ 0 : 0 ] defer l . bufs . Put ( buf ) if l . flag & Ltime > 0 { now := time . Now ( ) . Format ( timeFormat ) buf = append ( buf , '[' ) buf = append ( buf , now ... ) buf = append ( buf , "] " ... ) } if l . flag & Llevel > 0 { buf = append ( buf , '[' ) buf = append ( buf , level . String ( ) ... ) buf = append ( buf , "] " ... ) } if l . flag & Lfile > 0 { _ , file , line , ok := runtime . Caller ( callDepth ) if ! ok { file = "???" line = 0 } else { for i := len ( file ) - 1 ; i > 0 ; i -- { if file [ i ] == '/' { file = file [ i + 1 : ] break } } } buf = append ( buf , file ... ) buf = append ( buf , ':' ) buf = strconv . AppendInt ( buf , int64 ( line ) , 10 ) buf = append ( buf , ' ' ) } buf = append ( buf , msg ... ) if len ( msg ) == 0 || msg [ len ( msg ) - 1 ] != '\n' { buf = append ( buf , '\n' ) } l . hLock . Lock ( ) l . handler . Write ( buf ) l . hLock . Unlock ( ) }
6070	func ( l * Logger ) OutputJson ( callDepth int , level Level , body interface { } ) { if l . level > level { return } buf := l . bufs . Get ( ) . ( [ ] byte ) buf = buf [ 0 : 0 ] defer l . bufs . Put ( buf ) type JsonLog struct { Time string `json:"log_time"` Level string `json:"log_level"` File string `json:"log_file"` Line string `json:"log_line"` Body interface { } `json:"log_body"` } var jsonlog JsonLog if l . flag & Ltime > 0 { now := time . Now ( ) . Format ( timeFormat ) jsonlog . Time = now } if l . flag & Llevel > 0 { jsonlog . Level = level . String ( ) } if l . flag & Lfile > 0 { _ , file , line , ok := runtime . Caller ( callDepth ) if ! ok { file = "???" line = 0 } else { for i := len ( file ) - 1 ; i > 0 ; i -- { if file [ i ] == '/' { file = file [ i + 1 : ] break } } } jsonlog . File = file jsonlog . Line = string ( strconv . AppendInt ( buf , int64 ( line ) , 10 ) ) } jsonlog . Body = body msg , _ := json . Marshal ( jsonlog ) msg = append ( msg , '\n' ) l . hLock . Lock ( ) l . handler . Write ( msg ) l . hLock . Unlock ( ) }
6071	func ( l * Logger ) Print ( args ... interface { } ) { l . Output ( 2 , LevelTrace , fmt . Sprint ( args ... ) ) }
6072	func ( l * Logger ) Println ( args ... interface { } ) { l . Output ( 2 , LevelTrace , fmt . Sprintln ( args ... ) ) }
6073	func ( l * Logger ) Debug ( args ... interface { } ) { l . Output ( 2 , LevelDebug , fmt . Sprint ( args ... ) ) }
6074	func ( l * Logger ) Debugln ( args ... interface { } ) { l . Output ( 2 , LevelDebug , fmt . Sprintln ( args ... ) ) }
6075	func ( l * Logger ) Error ( args ... interface { } ) { l . Output ( 2 , LevelError , fmt . Sprint ( args ... ) ) }
6076	func ( l * Logger ) Errorln ( args ... interface { } ) { l . Output ( 2 , LevelError , fmt . Sprintln ( args ... ) ) }
6077	func ( l * Logger ) Info ( args ... interface { } ) { l . Output ( 2 , LevelInfo , fmt . Sprint ( args ... ) ) }
6078	func ( l * Logger ) Infoln ( args ... interface { } ) { l . Output ( 2 , LevelInfo , fmt . Sprintln ( args ... ) ) }
6079	func ( l * Logger ) Warn ( args ... interface { } ) { l . Output ( 2 , LevelWarn , fmt . Sprint ( args ... ) ) }
6080	func ( l * Logger ) Warnln ( args ... interface { } ) { l . Output ( 2 , LevelWarn , fmt . Sprintln ( args ... ) ) }
6081	func NewStreamHandler ( w io . Writer ) ( * StreamHandler , error ) { h := new ( StreamHandler ) h . w = w return h , nil }
6082	func Right ( str string , length int , pad string ) string { return str + times ( pad , length - len ( str ) ) }
6083	func New ( h string , a rsapi . Authenticator ) * API { api := rsapi . New ( h , a ) api . Metadata = GenMetadata return & API { API : api } }
6084	func setupMetadata ( ) ( result map [ string ] * metadata . Resource ) { result = make ( map [ string ] * metadata . Resource ) for n , r := range ssd . GenMetadata { result [ n ] = r for _ , a := range r . Actions { for _ , p := range a . PathPatterns { p . Regexp = removePrefixes ( p . Regexp , 2 ) } } } for n , r := range ssc . GenMetadata { result [ n ] = r for _ , a := range r . Actions { for _ , p := range a . PathPatterns { p . Regexp = removePrefixes ( p . Regexp , 2 ) } } } for n , r := range ssm . GenMetadata { result [ n ] = r for _ , a := range r . Actions { for _ , p := range a . PathPatterns { p . Regexp = removePrefixes ( p . Regexp , 2 ) } } } return }
6085	func ( p * ParamAnalyzer ) recordTypes ( root gen . DataType ) { if o , ok := root . ( * gen . ObjectDataType ) ; ok { if _ , found := p . ParamTypes [ o . TypeName ] ; ! found { p . ParamTypes [ o . TypeName ] = o for _ , f := range o . Fields { p . recordTypes ( f . Type ) } } } else if a , ok := root . ( * gen . ArrayDataType ) ; ok { p . recordTypes ( a . ElemType . Type ) } }
6086	func appendSorted ( params [ ] * gen . ActionParam , param * gen . ActionParam ) [ ] * gen . ActionParam { params = append ( params , param ) sort . Sort ( gen . ByName ( params ) ) return params }
6087	func ( p * ParamAnalyzer ) parseDataType ( path string , child * gen . ActionParam ) gen . DataType { param := p . rawParams [ path ] . ( map [ string ] interface { } ) class := "String" if c , ok := param [ "class" ] . ( string ) ; ok { class = c } var res gen . DataType switch class { case "Integer" : i := gen . BasicDataType ( "int" ) res = & i case "String" : s := gen . BasicDataType ( "string" ) res = & s case "Array" : if child != nil { res = & gen . ArrayDataType { child } } else { s := gen . BasicDataType ( "string" ) p := p . newParam ( fmt . Sprintf ( "%s[item]" , path ) , map [ string ] interface { } { } , & s ) res = & gen . ArrayDataType { p } } case "SourceUpload" : res = new ( gen . SourceUploadDataType ) case "FileUpload" , "Tempfile" : res = & gen . UploadDataType { TypeName : "FileUpload" } case "Enumerable" : res = new ( gen . EnumerableDataType ) case "Hash" : if current , ok := p . parsed [ path ] ; ok { res = current . Type o := res . ( * gen . ObjectDataType ) o . Fields = appendSorted ( o . Fields , child ) } else { oname := p . typeName ( path ) res = & gen . ObjectDataType { oname , [ ] * gen . ActionParam { child } } } } return res }
6088	func ( p * ParamAnalyzer ) parseParam ( path string , param map [ string ] interface { } , child * gen . ActionParam ) * gen . ActionParam { dType := p . parseDataType ( path , child ) return p . newParam ( path , param , dType ) }
6089	func ( p * ParamAnalyzer ) newParam ( path string , param map [ string ] interface { } , dType gen . DataType ) * gen . ActionParam { var description , regexp string var mandatory , nonBlank bool var validValues [ ] interface { } if d , ok := param [ "description" ] ; ok { description = d . ( string ) } if m , ok := param [ "mandatory" ] ; ok { mandatory = m . ( bool ) } if n , ok := param [ "non_blank" ] ; ok { nonBlank = n . ( bool ) } if r , ok := param [ "regexp" ] ; ok { regexp = r . ( string ) } if v , ok := param [ "valid_values" ] ; ok { validValues = v . ( [ ] interface { } ) } native := nativeNameFromPath ( path ) isLeaf := false if _ , ok := dType . ( * gen . EnumerableDataType ) ; ok { isLeaf = true } else { for _ , l := range p . leafParamNames { if path == l { isLeaf = true break } } } queryName := path if _ , ok := dType . ( * gen . ArrayDataType ) ; ok { queryName += "[]" } actionParam := & gen . ActionParam { Name : native , QueryName : queryName , Description : removeBlankLines ( description ) , VarName : parseParamName ( native ) , Type : dType , Mandatory : mandatory , NonBlank : nonBlank , Regexp : regexp , ValidValues : validValues , } if isLeaf { p . LeafParams = append ( p . LeafParams , actionParam ) } return actionParam }
6090	func toGoReturnTypeName ( name string , slice bool ) string { slicePrefix := "" if slice { slicePrefix = "[]" } return fmt . Sprintf ( "%s*%s" , slicePrefix , toGoTypeName ( name ) ) }
6091	func toGoTypeName ( name string ) string { switch name { case "String" , "Symbol" : return "string" case "Integer" : return "int" case "Boolean" : return "bool" case "Struct" , "Collection" : panic ( "Uh oh, trying to infer a go type name for a unnamed struct or collection (" + name + ")" ) default : if strings . Contains ( name , "::" ) { elems := strings . Split ( name , "::" ) return strings . Join ( elems [ 2 : len ( elems ) ] , "" ) } return name } }
6092	func prettify ( o interface { } ) string { s , err := json . MarshalIndent ( o , "" , " " ) if err != nil { return fmt . Sprintf ( "%+v" , o ) } return string ( s ) }
6093	func isBuiltInType ( name string ) bool { for _ , n := range BuiltInTypes { if name == n { return true } } return false }
6094	func ( a * Action ) MatchHref ( href string ) bool { hrefs := [ ] string { href , href + "/" } for _ , pattern := range a . PathPatterns { for _ , href := range hrefs { indices := pattern . Regexp . FindStringIndex ( href ) if indices != nil && indices [ 0 ] == 0 && indices [ 1 ] == len ( href ) { return true } } } return false }
6095	func ( p * PathPattern ) Substitute ( vars [ ] * PathVariable ) ( string , [ ] string ) { values := make ( [ ] interface { } , len ( p . Variables ) ) var missing [ ] string var used [ ] string for i , n := range p . Variables { for _ , v := range vars { if v . Name == n { values [ i ] = v . Value used = append ( used , n ) break } } if values [ i ] == nil { missing = append ( missing , n ) } } if len ( missing ) > 0 { return "" , missing } return fmt . Sprintf ( p . Pattern , values ... ) , used }
6096	func ( f * FileUpload ) MarshalJSON ( ) ( [ ] byte , error ) { b , err := ioutil . ReadAll ( f . Reader ) if err != nil { return nil , err } return json . Marshal ( string ( b ) ) }
6097	func writeMultipartParams ( w * multipart . Writer , payload APIParams , prefix string ) error { for k , v := range payload { fieldName := k if prefix != "" { fieldName = fmt . Sprintf ( "%s[%s]" , prefix , k ) } switch v . ( type ) { case string : err := w . WriteField ( fieldName , v . ( string ) ) if err != nil { return err } case APIParams : err := writeMultipartParams ( w , v . ( APIParams ) , fieldName ) if err != nil { return err } default : return fmt . Errorf ( "Unknown type for multipart form section %s: %#v" , fieldName , v ) } } return nil }
6098	func ( a * API ) PerformRequest ( req * http . Request ) ( * http . Response , error ) { if a . Auth != nil { if err := a . Auth . Sign ( req ) ; err != nil { return nil , err } } resp , err := a . Client . Do ( req ) if err != nil { return nil , err } return resp , err }
6099	func ( a * API ) PerformRequestWithContext ( ctx context . Context , req * http . Request ) ( * http . Response , error ) { if a . Auth != nil { if err := a . Auth . Sign ( req ) ; err != nil { return nil , err } } resp , err := a . Client . DoWithContext ( ctx , req ) if err != nil { return nil , err } return resp , err }
6100	func ( a * API ) LoadResponse ( resp * http . Response ) ( interface { } , error ) { defer resp . Body . Close ( ) var respBody interface { } jsonResp , err := ioutil . ReadAll ( resp . Body ) if err != nil { return nil , fmt . Errorf ( "Failed to read response (%s)" , err ) } if len ( jsonResp ) > 0 { err = json . Unmarshal ( jsonResp , & respBody ) if err != nil { return nil , fmt . Errorf ( "Failed to load response (%s)" , err ) } } loc := resp . Header . Get ( "Location" ) if len ( loc ) > 0 { var bodyMap = make ( map [ string ] interface { } ) bodyMap [ "Location" ] = loc respBody = interface { } ( bodyMap ) } return respBody , err }
6101	func ( api * API ) ScheduleLocator ( href string ) * ScheduleLocator { return & ScheduleLocator { Href ( href ) , api } }
6102	func ( api * API ) TemplateLocator ( href string ) * TemplateLocator { return & TemplateLocator { Href ( href ) , api } }
6103	func fetchDetails ( client * cm15 . API , envName string , envDetail EnvironmentDetail , sshConfig * [ ] SSHConfig ) { for nickname , name := range envDetail . ServerArrays { instances := serverArray ( client , name ) for _ , instance := range instances { ipAddress := instance . PublicIpAddresses [ 0 ] number := getInstanceNumber ( instance . Name ) * sshConfig = append ( * sshConfig , SSHConfig { Name : envName + "_" + nickname + number , IPAddress : ipAddress } ) } } for nickname , name := range envDetail . Servers { instance := server ( client , name ) ipAddress := instance . PublicIpAddresses [ 0 ] * sshConfig = append ( * sshConfig , SSHConfig { Name : envName + "_" + nickname , IPAddress : ipAddress } ) } }
6104	func buildAliases ( sshConfig [ ] SSHConfig , sshOptions , sshUser string ) string { var aliases string for _ , conf := range sshConfig { aliases = aliases + fmt . Sprintf ( "alias %v='ssh %v %v@%v'\n" , \n , conf . Name , sshOptions , sshUser ) } conf . IPAddress }
6105	func serverArray ( client * cm15 . API , name string ) [ ] * cm15 . Instance { serverArrayLocator := client . ServerArrayLocator ( "/api/server_arrays" ) serverArrays , err := serverArrayLocator . Index ( rsapi . APIParams { "view" : "default" , "filter" : [ ] string { "name==" + name } } ) if err != nil { fail ( "Failed to retrieve server array: %v\n" , \n ) } err . Error ( ) if len ( serverArrays ) == 0 { fail ( "Could not find server array with name: %v\n" , \n ) } else name if len ( serverArrays ) != 1 { fail ( "More than one server array found with name: %v\n" , \n ) } name array := serverArrays [ 0 ] var instancesHref string for _ , l := range array . Links { if l [ "rel" ] == "current_instances" { instancesHref = l [ "href" ] break } } instanceLocator := client . InstanceLocator ( instancesHref ) instances , err := instanceLocator . Index ( rsapi . APIParams { } ) }
6106	func server ( client * cm15 . API , name string ) * cm15 . Instance { serverLocator := client . ServerLocator ( "/api/servers" ) servers , err := serverLocator . Index ( rsapi . APIParams { "view" : "instance_detail" , "filter" : [ ] string { "name==" + name } } ) if err != nil { fail ( "Failed to retrieve server: %v\n" , \n ) } err . Error ( ) if len ( servers ) == 0 { fail ( "Could not find server with name: %v\n" , \n ) } else name }
6107	func toPackageName ( version string ) string { if version == "unversioned" { return "v0" } parts := strings . Split ( version , "." ) i := 1 p := parts [ len ( parts ) - i ] for p == "0" && i <= len ( parts ) { i ++ p = parts [ len ( parts ) - i ] } version = strings . Join ( parts , "_" ) return fmt . Sprintf ( "v%s" , version ) }
6108	func loadFile ( file string ) ( [ ] byte , error ) { if _ , err := os . Stat ( file ) ; err != nil { return nil , fmt . Errorf ( "Cannot find '%s'" , file ) } js , err := ioutil . ReadFile ( file ) if err != nil { return nil , fmt . Errorf ( "Cannot read '%s': %s" , file , err ) } return js , nil }
6109	func main ( ) { app := kingpin . New ( "rsc" , "A RightScale API client" ) app . Writer ( os . Stdout ) app . Version ( VV ) cmdLine , err := ParseCommandLine ( app ) if err != nil { line := strings . Join ( os . Args , " " ) PrintFatal ( "%s: %s" , line , err . Error ( ) ) } resp , err := ExecuteCommand ( app , cmdLine ) if err != nil { PrintFatal ( "%s" , err . Error ( ) ) } if resp == nil { return } var notExactlyOneError bool displayer , err := NewDisplayer ( resp ) if err != nil { PrintFatal ( "%s" , err . Error ( ) ) } if resp . StatusCode < 200 || resp . StatusCode > 299 { fmt . Fprintln ( errOut , resp . Status ) if len ( displayer . body ) > 0 { fmt . Fprintln ( errOut , displayer . body ) } } else if cmdLine . ExtractOneSelect != "" { err = displayer . ApplySingleExtract ( cmdLine . ExtractOneSelect ) if err != nil { notExactlyOneError = strings . Contains ( err . Error ( ) , "instead of one value" ) PrintError ( err . Error ( ) ) } fmt . Fprint ( out , displayer . Output ( ) ) } else { if cmdLine . ExtractSelector != "" { err = displayer . ApplyExtract ( cmdLine . ExtractSelector , false ) } else if cmdLine . ExtractSelectorJSON != "" { err = displayer . ApplyExtract ( cmdLine . ExtractSelectorJSON , true ) } else if cmdLine . ExtractHeader != "" { err = displayer . ApplyHeaderExtract ( cmdLine . ExtractHeader ) } if err != nil { PrintFatal ( "%s" , err . Error ( ) ) } else if cmdLine . Pretty { displayer . Pretty ( ) } fmt . Fprint ( out , displayer . Output ( ) ) } exitStatus := 0 switch { case notExactlyOneError : exitStatus = 6 case resp . StatusCode == 401 : exitStatus = 1 case resp . StatusCode == 403 : exitStatus = 3 case resp . StatusCode == 404 : exitStatus = 4 case resp . StatusCode > 399 && resp . StatusCode < 500 : exitStatus = 2 case resp . StatusCode > 499 : exitStatus = 5 } osExit ( exitStatus ) }
6110	func runCommand ( client cmd . CommandClient , cmdLine * cmd . CommandLine ) ( resp * http . Response , err error ) { cmds := strings . Split ( cmdLine . Command , " " ) if cmdLine . ShowHelp { err = client . ShowCommandHelp ( cmdLine . Command ) } else if len ( cmds ) > 1 && cmds [ 1 ] == "actions" { err = client . ShowAPIActions ( cmdLine . Command ) } else { resp , err = client . RunCommand ( cmdLine . Command ) } return }
6111	func CreateJSONResponse ( b [ ] byte ) ( resp * http . Response ) { b = bytes . TrimPrefix ( b , [ ] byte { 0xef , 0xbb , 0xbf } ) resp = & http . Response { StatusCode : 200 , Body : ioutil . NopCloser ( bytes . NewBuffer ( b ) ) , } return resp }
6112	func ( api * API ) AccountLocator ( href string ) * AccountLocator { return & AccountLocator { Href ( href ) , api } }
6113	func ( api * API ) AccountGroupLocator ( href string ) * AccountGroupLocator { return & AccountGroupLocator { Href ( href ) , api } }
6114	func ( api * API ) AlertLocator ( href string ) * AlertLocator { return & AlertLocator { Href ( href ) , api } }
6115	func ( api * API ) AlertSpecLocator ( href string ) * AlertSpecLocator { return & AlertSpecLocator { Href ( href ) , api } }
6116	func ( api * API ) AuditEntryLocator ( href string ) * AuditEntryLocator { return & AuditEntryLocator { Href ( href ) , api } }
6117	func ( api * API ) BackupLocator ( href string ) * BackupLocator { return & BackupLocator { Href ( href ) , api } }
6118	func ( api * API ) ChildAccountLocator ( href string ) * ChildAccountLocator { return & ChildAccountLocator { Href ( href ) , api } }
6119	func ( api * API ) CloudLocator ( href string ) * CloudLocator { return & CloudLocator { Href ( href ) , api } }
6120	func ( api * API ) CloudAccountLocator ( href string ) * CloudAccountLocator { return & CloudAccountLocator { Href ( href ) , api } }
6121	func ( api * API ) CookbookLocator ( href string ) * CookbookLocator { return & CookbookLocator { Href ( href ) , api } }
6122	func ( api * API ) CookbookAttachmentLocator ( href string ) * CookbookAttachmentLocator { return & CookbookAttachmentLocator { Href ( href ) , api } }
6123	func ( api * API ) CredentialLocator ( href string ) * CredentialLocator { return & CredentialLocator { Href ( href ) , api } }
6124	func ( api * API ) DatacenterLocator ( href string ) * DatacenterLocator { return & DatacenterLocator { Href ( href ) , api } }
6125	func ( api * API ) DeploymentLocator ( href string ) * DeploymentLocator { return & DeploymentLocator { Href ( href ) , api } }
6126	func ( api * API ) HealthCheckLocator ( href string ) * HealthCheckLocator { return & HealthCheckLocator { Href ( href ) , api } }
6127	func ( api * API ) IdentityProviderLocator ( href string ) * IdentityProviderLocator { return & IdentityProviderLocator { Href ( href ) , api } }
6128	func ( api * API ) ImageLocator ( href string ) * ImageLocator { return & ImageLocator { Href ( href ) , api } }
6129	func ( api * API ) InputLocator ( href string ) * InputLocator { return & InputLocator { Href ( href ) , api } }
6130	func ( api * API ) InstanceLocator ( href string ) * InstanceLocator { return & InstanceLocator { Href ( href ) , api } }
6131	func ( api * API ) InstanceTypeLocator ( href string ) * InstanceTypeLocator { return & InstanceTypeLocator { Href ( href ) , api } }
6132	func ( api * API ) IpAddressLocator ( href string ) * IpAddressLocator { return & IpAddressLocator { Href ( href ) , api } }
6133	func ( api * API ) IpAddressBindingLocator ( href string ) * IpAddressBindingLocator { return & IpAddressBindingLocator { Href ( href ) , api } }
6134	func ( api * API ) MonitoringMetricLocator ( href string ) * MonitoringMetricLocator { return & MonitoringMetricLocator { Href ( href ) , api } }
6135	func ( api * API ) MultiCloudImageLocator ( href string ) * MultiCloudImageLocator { return & MultiCloudImageLocator { Href ( href ) , api } }
6136	func ( api * API ) MultiCloudImageMatcherLocator ( href string ) * MultiCloudImageMatcherLocator { return & MultiCloudImageMatcherLocator { Href ( href ) , api } }
6137	func ( api * API ) MultiCloudImageSettingLocator ( href string ) * MultiCloudImageSettingLocator { return & MultiCloudImageSettingLocator { Href ( href ) , api } }
6138	func ( api * API ) NetworkLocator ( href string ) * NetworkLocator { return & NetworkLocator { Href ( href ) , api } }
6139	func ( api * API ) NetworkGatewayLocator ( href string ) * NetworkGatewayLocator { return & NetworkGatewayLocator { Href ( href ) , api } }
6140	func ( api * API ) NetworkOptionGroupLocator ( href string ) * NetworkOptionGroupLocator { return & NetworkOptionGroupLocator { Href ( href ) , api } }
6141	func ( api * API ) NetworkOptionGroupAttachmentLocator ( href string ) * NetworkOptionGroupAttachmentLocator { return & NetworkOptionGroupAttachmentLocator { Href ( href ) , api } }
6142	func ( api * API ) Oauth2Locator ( href string ) * Oauth2Locator { return & Oauth2Locator { Href ( href ) , api } }
6143	func ( api * API ) PermissionLocator ( href string ) * PermissionLocator { return & PermissionLocator { Href ( href ) , api } }
6144	func ( api * API ) PlacementGroupLocator ( href string ) * PlacementGroupLocator { return & PlacementGroupLocator { Href ( href ) , api } }
6145	func ( api * API ) PreferenceLocator ( href string ) * PreferenceLocator { return & PreferenceLocator { Href ( href ) , api } }
6146	func ( api * API ) PublicationLocator ( href string ) * PublicationLocator { return & PublicationLocator { Href ( href ) , api } }
6147	func ( api * API ) PublicationLineageLocator ( href string ) * PublicationLineageLocator { return & PublicationLineageLocator { Href ( href ) , api } }
6148	func ( api * API ) RecurringVolumeAttachmentLocator ( href string ) * RecurringVolumeAttachmentLocator { return & RecurringVolumeAttachmentLocator { Href ( href ) , api } }
6149	func ( api * API ) RepositoryLocator ( href string ) * RepositoryLocator { return & RepositoryLocator { Href ( href ) , api } }
6150	func ( api * API ) RepositoryAssetLocator ( href string ) * RepositoryAssetLocator { return & RepositoryAssetLocator { Href ( href ) , api } }
6151	func ( api * API ) ResourceGroupLocator ( href string ) * ResourceGroupLocator { return & ResourceGroupLocator { Href ( href ) , api } }
6152	func ( api * API ) RightScriptLocator ( href string ) * RightScriptLocator { return & RightScriptLocator { Href ( href ) , api } }
6153	func ( api * API ) RightScriptAttachmentLocator ( href string ) * RightScriptAttachmentLocator { return & RightScriptAttachmentLocator { Href ( href ) , api } }
6154	func ( api * API ) RouteLocator ( href string ) * RouteLocator { return & RouteLocator { Href ( href ) , api } }
6155	func ( api * API ) RouteTableLocator ( href string ) * RouteTableLocator { return & RouteTableLocator { Href ( href ) , api } }
6156	func ( api * API ) RunnableBindingLocator ( href string ) * RunnableBindingLocator { return & RunnableBindingLocator { Href ( href ) , api } }
6157	func ( api * API ) SchedulerLocator ( href string ) * SchedulerLocator { return & SchedulerLocator { Href ( href ) , api } }
6158	func ( api * API ) SecurityGroupLocator ( href string ) * SecurityGroupLocator { return & SecurityGroupLocator { Href ( href ) , api } }
6159	func ( api * API ) SecurityGroupRuleLocator ( href string ) * SecurityGroupRuleLocator { return & SecurityGroupRuleLocator { Href ( href ) , api } }
6160	func ( api * API ) ServerLocator ( href string ) * ServerLocator { return & ServerLocator { Href ( href ) , api } }
6161	func ( api * API ) ServerArrayLocator ( href string ) * ServerArrayLocator { return & ServerArrayLocator { Href ( href ) , api } }
6162	func ( api * API ) ServerTemplateLocator ( href string ) * ServerTemplateLocator { return & ServerTemplateLocator { Href ( href ) , api } }
6163	func ( api * API ) ServerTemplateMultiCloudImageLocator ( href string ) * ServerTemplateMultiCloudImageLocator { return & ServerTemplateMultiCloudImageLocator { Href ( href ) , api } }
6164	func ( api * API ) SessionLocator ( href string ) * SessionLocator { return & SessionLocator { Href ( href ) , api } }
6165	func ( api * API ) SshKeyLocator ( href string ) * SshKeyLocator { return & SshKeyLocator { Href ( href ) , api } }
6166	func ( api * API ) SubnetLocator ( href string ) * SubnetLocator { return & SubnetLocator { Href ( href ) , api } }
6167	func ( api * API ) TagLocator ( href string ) * TagLocator { return & TagLocator { Href ( href ) , api } }
6168	func ( api * API ) TaskLocator ( href string ) * TaskLocator { return & TaskLocator { Href ( href ) , api } }
6169	func ( api * API ) UserLocator ( href string ) * UserLocator { return & UserLocator { Href ( href ) , api } }
6170	func ( api * API ) UserDataLocator ( href string ) * UserDataLocator { return & UserDataLocator { Href ( href ) , api } }
6171	func ( api * API ) VolumeLocator ( href string ) * VolumeLocator { return & VolumeLocator { Href ( href ) , api } }
6172	func ( api * API ) VolumeAttachmentLocator ( href string ) * VolumeAttachmentLocator { return & VolumeAttachmentLocator { Href ( href ) , api } }
6173	func ( api * API ) VolumeSnapshotLocator ( href string ) * VolumeSnapshotLocator { return & VolumeSnapshotLocator { Href ( href ) , api } }
6174	func ( api * API ) VolumeTypeLocator ( href string ) * VolumeTypeLocator { return & VolumeTypeLocator { Href ( href ) , api } }
6175	func RegisterCommands ( registrar rsapi . APICommandRegistrar ) { commandValues = rsapi . ActionCommands { } registrar . RegisterActionCommands ( APIName , GenMetadata , commandValues ) }
6176	func ( a * API ) ShowCommandHelp ( cmd string ) error { return a . ShowHelp ( cmd , "/rll" , commandValues ) }
6177	func ( a * API ) ShowAPIActions ( cmd string ) error { return a . ShowActions ( cmd , "/rll" , commandValues ) }
6178	func ( a * API ) ShowHelp ( cmd , hrefPrefix string , values ActionCommands ) error { target , _ , err := a . ParseCommandAndFlags ( cmd , hrefPrefix , values ) if err != nil { return err } _ , action , href := target . Resource , target . Action , target . Href if len ( action . CommandFlags ) == 0 { fmt . Printf ( "usage: rsc [<FLAGS>] %s %s %s\n\n%s\n" , \n , \n , \n , strings . Split ( cmd , " " ) [ 0 ] ) action . Name } href action . Description return nil flagHelp := make ( [ ] string , len ( action . CommandFlags ) ) for i , f := range action . CommandFlags { var attrs string if f . Mandatory { attrs = "required" } else { attrs = "optional" } if len ( f . ValidValues ) > 0 { attrs += ", [" + strings . Join ( f . ValidValues , "|" ) + "]" } if f . Regexp != nil { attrs += ", /" + f . Regexp . String ( ) + "/" } flagHelp [ i ] = fmt . Sprintf ( "%s=%s\n <%s> %s" , \n , f . Name , f . Type , attrs ) } }
6179	func ( a * API ) ParseCommandAndFlags ( cmd , hrefPrefix string , values ActionCommands ) ( * CommandTarget , [ ] string , error ) { resource , vars , err := a . parseResource ( cmd , hrefPrefix , values ) if err != nil { return nil , nil , err } var action * metadata . Action elems := strings . Split ( cmd , " " ) actionName := elems [ len ( elems ) - 1 ] for _ , a := range resource . Actions { if a . Name == actionName { action = a break } } if action == nil { supported := make ( [ ] string , len ( resource . Actions ) ) for i , a := range resource . Actions { supported [ i ] = a . Name } return nil , nil , fmt . Errorf ( "Unknown %s action '%s'. Supported actions are: %s" , resource . Name , actionName , strings . Join ( supported , ", " ) ) } path , err := action . URL ( vars ) if err != nil { return nil , nil , err } flags := values [ cmd ] return & CommandTarget { resource , action , path , flags . Href } , flags . Params , nil }
6180	func validateFlagValue ( value string , param * metadata . ActionParam ) error { if param . Regexp != nil { if ! param . Regexp . MatchString ( value ) { return fmt . Errorf ( "Invalid value '%s' for '%s', value must validate /%s/" , value , param . Name , param . Regexp . String ( ) ) } } if param . NonBlank && value == "" { return fmt . Errorf ( "Invalid value for '%s', value must not be blank" , param . Name ) } if len ( param . ValidValues ) > 0 && param . Name != "filter[]" { found := false for _ , v := range param . ValidValues { if v == value { found = true break } } if ! found { return fmt . Errorf ( "Invalid value for '%s', value must be one of %s, value provided was '%s'" , param . Name , strings . Join ( param . ValidValues , ", " ) , value ) } } return nil }
6181	func buildQuery ( values [ ] APIParams ) ( APIParams , error ) { query := APIParams { } for _ , value := range values { for name , param := range value { if q , ok := query [ name ] ; ok { if a , ok := q . ( [ ] interface { } ) ; ok { query [ name ] = append ( a , param ) } else { query [ name ] = [ ] interface { } { q , param } } } else { query [ name ] = param } } } return query , nil }
6182	func buildPayload ( values [ ] APIParams ) ( APIParams , error ) { payload := APIParams { } for _ , value := range values { for name , param := range value { if _ , err := Normalize ( payload , name , param ) ; err != nil { return nil , err } } } return payload , nil }
6183	func shortenPattern ( res * metadata . Resource , pattern , suffix string ) ( string , bool ) { if strings . HasSuffix ( pattern , suffix ) { pat := strings . TrimSuffix ( pattern , suffix ) for _ , action := range res . Actions { for _ , pattern2 := range action . PathPatterns { vars := pattern2 . Variables ivars := make ( [ ] interface { } , len ( vars ) ) for i , v := range vars { ivars [ i ] = interface { } ( ":" + v ) } subPattern := pattern2 . Pattern pat2 := fmt . Sprintf ( subPattern , ivars ... ) if pat == pat2 { return pat , true } } } } return pattern , false }
6184	func cleanDescription ( doc string ) string { docBits := strings . Split ( doc , "Required security scope" ) doc = docBits [ 0 ] lines := strings . Split ( doc , "\n" ) \n fullLines := make ( [ ] string , len ( lines ) ) i := 0 for _ , line := range lines { if len ( line ) > 0 && ! blankRegexp . MatchString ( line ) { fullLines [ i ] = line i ++ } } }
6185	func fileExists ( file string ) bool { _ , err := os . Stat ( file ) return err == nil }
6186	func ( api * API ) AnalysisSnapshotLocator ( href string ) * AnalysisSnapshotLocator { return & AnalysisSnapshotLocator { Href ( href ) , api } }
6187	func ( api * API ) BudgetAlertLocator ( href string ) * BudgetAlertLocator { return & BudgetAlertLocator { Href ( href ) , api } }
6188	func ( api * API ) CloudBillLocator ( href string ) * CloudBillLocator { return & CloudBillLocator { Href ( href ) , api } }
6189	func ( api * API ) CloudBillMetricLocator ( href string ) * CloudBillMetricLocator { return & CloudBillMetricLocator { Href ( href ) , api } }
6190	func ( api * API ) CurrentUserLocator ( href string ) * CurrentUserLocator { return & CurrentUserLocator { Href ( href ) , api } }
6191	func ( api * API ) InstanceCombinationLocator ( href string ) * InstanceCombinationLocator { return & InstanceCombinationLocator { Href ( href ) , api } }
6192	func ( api * API ) InstanceMetricLocator ( href string ) * InstanceMetricLocator { return & InstanceMetricLocator { Href ( href ) , api } }
6193	func ( api * API ) InstanceUsagePeriodLocator ( href string ) * InstanceUsagePeriodLocator { return & InstanceUsagePeriodLocator { Href ( href ) , api } }
6194	func ( api * API ) PatternLocator ( href string ) * PatternLocator { return & PatternLocator { Href ( href ) , api } }
6195	func ( api * API ) ReservedInstanceLocator ( href string ) * ReservedInstanceLocator { return & ReservedInstanceLocator { Href ( href ) , api } }
6196	func ( api * API ) ReservedInstancePurchaseLocator ( href string ) * ReservedInstancePurchaseLocator { return & ReservedInstancePurchaseLocator { Href ( href ) , api } }
6197	func ( api * API ) ScenarioLocator ( href string ) * ScenarioLocator { return & ScenarioLocator { Href ( href ) , api } }
6198	func ( api * API ) ScheduledReportLocator ( href string ) * ScheduledReportLocator { return & ScheduledReportLocator { Href ( href ) , api } }
6199	func ( api * API ) TempInstancePriceLocator ( href string ) * TempInstancePriceLocator { return & TempInstancePriceLocator { Href ( href ) , api } }
6200	func ( api * API ) UserSettingLocator ( href string ) * UserSettingLocator { return & UserSettingLocator { Href ( href ) , api } }
6201	func readAllAsync ( f io . ReadCloser ) ( * [ ] byte , chan struct { } ) { done := make ( chan struct { } , 1 ) var buf [ ] byte go func ( ) { var err error buf , err = ioutil . ReadAll ( f ) if err != nil { buf = make ( [ ] byte , 0 ) } f . Close ( ) done <- struct { } { } } ( ) return & buf , done }
6202	func extractArg ( name string , args [ ] string ) ( string , [ ] string ) { var val string var newArgs [ ] string var skip bool for i , a := range args { if skip { skip = false continue } if strings . Contains ( a , "=" ) { elems := strings . SplitN ( a , "=" , 2 ) if elems [ 0 ] == name { val = elems [ 1 ] } else { newArgs = append ( newArgs , a ) } } else if a == name && len ( args ) > ( i + 1 ) { val = args [ i + 1 ] skip = true } else { newArgs = append ( newArgs , a ) } } return val , newArgs }
6203	func write ( b [ ] byte ) { f , err := os . OpenFile ( output , os . O_APPEND | os . O_WRONLY | os . O_CREATE , 0644 ) if err != nil { fail ( "failed to open output file" ) } f . Write ( b ) f . WriteString ( "\n" ) \n }
6204	func ( api * API ) AppliedPolicyLocator ( href string ) * AppliedPolicyLocator { return & AppliedPolicyLocator { Href ( href ) , api } }
6205	func ( api * API ) ApprovalLocator ( href string ) * ApprovalLocator { return & ApprovalLocator { Href ( href ) , api } }
6206	func ( api * API ) IncidentLocator ( href string ) * IncidentLocator { return & IncidentLocator { Href ( href ) , api } }
6207	func ( api * API ) PolicyTemplateLocator ( href string ) * PolicyTemplateLocator { return & PolicyTemplateLocator { Href ( href ) , api } }
6208	func ( api * API ) PublishedTemplateLocator ( href string ) * PublishedTemplateLocator { return & PublishedTemplateLocator { Href ( href ) , api } }
6209	func ( api * API ) DebugCookbookPathLocator ( href string ) * DebugCookbookPathLocator { return & DebugCookbookPathLocator { Href ( href ) , api } }
6210	func ( api * API ) DockerControlLocator ( href string ) * DockerControlLocator { return & DockerControlLocator { Href ( href ) , api } }
6211	func ( api * API ) EnvLocator ( href string ) * EnvLocator { return & EnvLocator { Href ( href ) , api } }
6212	func ( api * API ) LoginControlLocator ( href string ) * LoginControlLocator { return & LoginControlLocator { Href ( href ) , api } }
6213	func ( api * API ) ProcLocator ( href string ) * ProcLocator { return & ProcLocator { Href ( href ) , api } }
6214	func ( api * API ) Rl10Locator ( href string ) * Rl10Locator { return & Rl10Locator { Href ( href ) , api } }
6215	func ( api * API ) TSSLocator ( href string ) * TSSLocator { return & TSSLocator { Href ( href ) , api } }
6216	func ( api * API ) TSSControlLocator ( href string ) * TSSControlLocator { return & TSSControlLocator { Href ( href ) , api } }
6217	func ( api * API ) TSSPluginLocator ( href string ) * TSSPluginLocator { return & TSSPluginLocator { Href ( href ) , api } }
6218	func NewAngularWriter ( ) ( * AngularWriter , error ) { funcMap := template . FuncMap { "comment" : comment , "commandLine" : commandLine , "path" : path , "mandatory" : mandatory , } resourceT , err := template . New ( "resource-client" ) . Funcs ( funcMap ) . Parse ( angularTmpl ) if err != nil { return nil , err } return & AngularWriter { angularTmpl : resourceT , } , nil }
6219	func ( c * AngularWriter ) WriteResource ( resource * gen . Resource , w io . Writer ) error { return c . angularTmpl . Execute ( w , resource ) }
6220	func path ( a * gen . Action ) string { pattern := a . PathPatterns [ 0 ] vars := pattern . Variables ivars := make ( [ ] interface { } , len ( vars ) ) for i , v := range vars { ivars [ i ] = interface { } ( ":" + v ) } return fmt . Sprintf ( pattern . Pattern , ivars ... ) }
6221	func mandatory ( a gen . Action , param string ) bool { for _ , p := range a . Params { if p . Name == param { return p . Mandatory } } panic ( "praxisgen bug: Unknown param " + param + " for action " + a . Name ) }
6222	func New ( host string , auth Authenticator ) * API { client := httpclient . New ( ) if strings . HasPrefix ( host , "http://" ) { host = host [ 7 : ] } else if strings . HasPrefix ( host , "https://" ) { host = host [ 8 : ] } a := & API { Auth : auth , Host : host , Client : client , } if auth != nil { auth . SetHost ( host ) } return a }
6223	func FromCommandLine ( cmdLine * cmd . CommandLine ) ( * API , error ) { var client * API ss := strings . HasPrefix ( cmdLine . Command , "ss" ) if cmdLine . RL10 { var err error if client , err = NewRL10 ( ) ; err != nil { return nil , err } } else if cmdLine . OAuthToken != "" { auth := NewOAuthAuthenticator ( cmdLine . OAuthToken , cmdLine . Account ) if ss { auth = NewSSAuthenticator ( auth , cmdLine . Account ) } client = New ( cmdLine . Host , auth ) } else if cmdLine . OAuthAccessToken != "" { auth := NewTokenAuthenticator ( cmdLine . OAuthAccessToken , cmdLine . Account ) if ss { auth = NewSSAuthenticator ( auth , cmdLine . Account ) } client = New ( cmdLine . Host , auth ) } else if cmdLine . APIToken != "" { auth := NewInstanceAuthenticator ( cmdLine . APIToken , cmdLine . Account ) if ss { auth = NewSSAuthenticator ( auth , cmdLine . Account ) } client = New ( cmdLine . Host , auth ) } else if cmdLine . Username != "" && cmdLine . Password != "" { auth := NewBasicAuthenticator ( cmdLine . Username , cmdLine . Password , cmdLine . Account ) if ss { auth = NewSSAuthenticator ( auth , cmdLine . Account ) } client = New ( cmdLine . Host , auth ) } else { client = New ( cmdLine . Host , nil ) httpclient . Insecure = true } if ! cmdLine . ShowHelp && ! cmdLine . NoAuth { if cmdLine . OAuthToken == "" && cmdLine . OAuthAccessToken == "" && cmdLine . APIToken == "" && cmdLine . Username == "" && ! cmdLine . RL10 { return nil , fmt . Errorf ( "Missing authentication information, use '--email EMAIL --password PWD', '--token TOKEN' or 'setup'" ) } if cmdLine . Verbose || cmdLine . Dump == "debug" { httpclient . DumpFormat = httpclient . Debug } if cmdLine . Dump == "json" { httpclient . DumpFormat = httpclient . JSON } if cmdLine . Dump == "record" { httpclient . DumpFormat = httpclient . JSON | httpclient . Record } if cmdLine . Verbose { httpclient . DumpFormat |= httpclient . Verbose } client . FetchLocationResource = cmdLine . FetchResource } return client , nil }
6224	func ( a * API ) CanAuthenticate ( ) error { res := a . Auth . CanAuthenticate ( a . Host ) return res }
6225	func Encrypt ( text string ) ( string , error ) { bytes := [ ] byte ( text ) key := seekret ( ) block , err := aes . NewCipher ( key ) if err != nil { return "" , err } b := encodeBase64 ( bytes ) ciphertext := make ( [ ] byte , aes . BlockSize + len ( b ) ) iv := ciphertext [ : aes . BlockSize ] if _ , err := io . ReadFull ( rand . Reader , iv ) ; err != nil { return "" , err } cfb := cipher . NewCFBEncrypter ( block , iv ) cfb . XORKeyStream ( ciphertext [ aes . BlockSize : ] , b ) return string ( encodeBase64 ( ciphertext ) ) , nil }
6226	func Decrypt ( text string ) ( string , error ) { if text == "" { return "" , nil } key := seekret ( ) bytes := decodeBase64 ( [ ] byte ( text ) ) block , err := aes . NewCipher ( key ) if err != nil { return "" , err } if len ( bytes ) < aes . BlockSize { return "" , errors . New ( "ciphertext too short" ) } iv := bytes [ : aes . BlockSize ] bytes = bytes [ aes . BlockSize : ] cfb := cipher . NewCFBDecrypter ( block , iv ) cfb . XORKeyStream ( bytes , bytes ) return string ( decodeBase64 ( bytes ) ) , nil }
6227	func ( a * APIAnalyzer ) guessType ( ec EvalCtx , d * Definition , refID string ) string { if t , ok := a . TypeOverrides [ refID ] ; ok { return t } var name , view string if strings . Contains ( refID , "RequestBody" ) { bits := strings . Split ( refID , "RequestBody" ) name = bits [ 0 ] if len ( bits ) > 1 { view = strings . ToLower ( bits [ 1 ] ) } } else if strings . Contains ( refID , "ResponseBody" ) { bits := strings . Split ( refID , "ResponseBody" ) name = bits [ 0 ] if len ( bits ) > 1 { view = strings . ToLower ( bits [ 1 ] ) } } else { name = refID } if mt := mediaType ( d . Title ) ; mt != "" { if strings . Contains ( mt , "application" ) { bits := strings . Split ( mt , "." ) name := bits [ len ( bits ) - 1 ] attrs := mediaTypeAttrs ( d . Title ) if attrs [ "type" ] != "" { name += "_" + attrs [ "type" ] } if attrs [ "view" ] != "" && attrs [ "view" ] != "default" { name += "_" + attrs [ "view" ] } else if view != "" { name += "_" + view } dbg ( "DEBUG media type refID:%#v title:%#v name:%#v view:%#v -> type:%#v\n" , \n , refID , d . Title , name , view ) name } else return toTypeName ( name ) } if strings . Contains ( mt , "text/" ) { return "string" } else { fail ( "Don't know how to handle media type %s" , mt ) } if view != "" { return name + "_" + view } }
6228	func ( a * APIAnalyzer ) addType ( ec EvalCtx , dt * gen . ObjectDataType , r Ref ) { a . api . NeedJSON = true if a . refByType [ dt . TypeName ] == r . ID ( ) { return } if other , ok := a . api . Types [ dt . TypeName ] ; ok { if ! ec . IsResult { dt . TypeName += "Param" if a . refByType [ dt . TypeName ] == r . ID ( ) { return } } oldFields := [ ] string { } newFields := [ ] string { } for _ , f := range other . Fields { oldFields = append ( oldFields , f . Name ) } for _ , f := range dt . Fields { newFields = append ( newFields , f . Name ) } use := "Old" if len ( newFields ) > len ( oldFields ) { use = "New" } if strings . Join ( oldFields , "," ) != strings . Join ( newFields , "," ) { warn ( "Warning: Type collision when adding new type %s!\n New: id %s fields %v\n Old: id %s fields %v\n Using %s, which has more fields\n" , \n , \n , \n , \n , dt . TypeName , r . ID ( ) ) } newFields } a . refByType [ dt . TypeName ] oldFields use }
6229	func extractCmdLineParams ( a * gen . ActionParam , root string , seen map [ string ] * [ ] * gen . ActionParam , parentNotMandatory bool ) [ ] * gen . ActionParam { switch t := a . Type . ( type ) { case * gen . BasicDataType , * gen . EnumerableDataType , * gen . UploadDataType : dup := gen . ActionParam { Name : a . Name , QueryName : root , Description : a . Description , VarName : a . VarName , Location : a . Location , Type : a . Type , Mandatory : a . Mandatory && ! parentNotMandatory , NonBlank : a . NonBlank , Regexp : a . Regexp , ValidValues : a . ValidValues , Min : a . Min , Max : a . Max , } return [ ] * gen . ActionParam { & dup } case * gen . ArrayDataType : p := t . ElemType eq , ok := seen [ p . Name ] if ! ok { eq = & [ ] * gen . ActionParam { } seen [ p . Name ] = eq * eq = extractCmdLineParams ( p , root + "[]" , seen , parentNotMandatory || ! a . Mandatory ) } return * eq case * gen . ObjectDataType : params := [ ] * gen . ActionParam { } for _ , f := range t . Fields { eq , ok := seen [ f . Name ] if ! ok { eq = & [ ] * gen . ActionParam { } seen [ f . Name ] = eq * eq = extractCmdLineParams ( f , fmt . Sprintf ( "%s[%s]" , root , f . Name ) , seen , parentNotMandatory || ! a . Mandatory ) } params = append ( params , * eq ... ) } return params } return nil }
6230	func NewMetadataWriter ( ) ( * MetadataWriter , error ) { funcMap := template . FuncMap { "comment" : comment , "join" : strings . Join , "commandLine" : commandLine , "toStringArray" : toStringArray , "flagType" : flagType , "location" : location , "escapeBackticks" : escapeBackticks , } headerT , err := template . New ( "header-metadata" ) . Funcs ( funcMap ) . Parse ( headerMetadataTmpl ) if err != nil { return nil , err } resourceT , err := template . New ( "resource-metadata" ) . Funcs ( funcMap ) . Parse ( resourceMetadataTmpl ) if err != nil { return nil , err } return & MetadataWriter { headerTmpl : headerT , resourceTmpl : resourceT , } , nil }
6231	func ( c * MetadataWriter ) WriteHeader ( pkg string , w io . Writer ) error { return c . headerTmpl . Execute ( w , pkg ) }
6232	func ( c * MetadataWriter ) WriteMetadata ( d * gen . APIDescriptor , w io . Writer ) error { resources := make ( [ ] * gen . Resource , len ( d . ResourceNames ) ) for i , n := range d . ResourceNames { resources [ i ] = d . Resources [ n ] } return c . resourceTmpl . Execute ( w , resources ) }
6233	func location ( p * gen . ActionParam ) string { switch p . Location { case gen . PathParam : return "metadata.PathParam" case gen . QueryParam : return "metadata.QueryParam" case gen . PayloadParam : return "metadata.PayloadParam" default : return "" } }
6234	func New ( host string , auth rsapi . Authenticator ) * API { return fromAPI ( rsapi . New ( host , auth ) ) }
6235	func fromAPI ( api * rsapi . API ) * API { api . Metadata = GenMetadata return & API { api } }
6236	func ( a * API ) BuildRequest ( resource , action , href string , params rsapi . APIParams ) ( * http . Request , error ) { res , ok := GenMetadata [ resource ] if ! ok { return nil , fmt . Errorf ( "No resource with name '%s'" , resource ) } act := res . GetAction ( action ) if act == nil { return nil , fmt . Errorf ( "No action with name '%s' on %s" , action , resource ) } vars , err := res . ExtractVariables ( href ) if err != nil { return nil , err } actionURL , err := act . URL ( vars ) if err != nil { return nil , err } _ , queryParams := rsapi . IdentifyParams ( act , params ) return a . BuildHTTPRequest ( "GET" , actionURL . Path , "1.6" , queryParams , nil ) }
6237	func setupMetadata ( ) ( result map [ string ] * metadata . Resource ) { result = make ( map [ string ] * metadata . Resource ) for n , r := range cac . GenMetadata { result [ n ] = r } return }
6238	func NewDisplayer ( resp * http . Response ) ( * Displayer , error ) { defer resp . Body . Close ( ) js , err := ioutil . ReadAll ( resp . Body ) if err != nil { return nil , fmt . Errorf ( "Failed to read response (%s)" , err ) } disp := Displayer { response : resp , body : string ( js ) } if len ( js ) > 2 { err = json . Unmarshal ( js , & disp . RawOutput ) if err != nil { disp . RawOutput = string ( js ) } } return & disp , nil }
6239	func ( d * Displayer ) ApplySingleExtract ( extract string ) error { if err := d . ApplyExtract ( extract , true ) ; err != nil { return err } outputs := d . RawOutput . ( [ ] interface { } ) if len ( outputs ) != 1 { d . RawOutput = nil return fmt . Errorf ( "JSON selector '%s' returned %d instead of one value" , extract , len ( outputs ) ) } if len ( outputs ) == 0 { d . RawOutput = "" } else { switch v := outputs [ 0 ] . ( type ) { case nil : d . RawOutput = "" case float64 , bool : d . RawOutput = fmt . Sprint ( v ) case string : d . RawOutput = v default : d . RawOutput = v } d . RawOutput = outputs [ 0 ] } return nil }
6240	func ( d * Displayer ) ApplyExtract ( selector string , js bool ) error { parser , err := jsonselect . CreateParserFromString ( d . body ) if err != nil { return fmt . Errorf ( "Failed to load response JSON: %s, JSON was:\n%s" , \n , err ) } d . body outputs , err := parser . GetValues ( selector ) if ! js { out := "" for _ , o := range outputs { b , _ := json . Marshal ( o ) out += string ( b ) + "\n" } \n } else d . RawOutput = out { d . RawOutput = outputs } }
6241	func ( d * Displayer ) ApplyHeaderExtract ( header string ) error { d . RawOutput = d . response . Header . Get ( header ) if d . RawOutput == "" { return fmt . Errorf ( "Response does not contain the '%s' header" , header ) } return nil }
6242	func ( d * Displayer ) Output ( ) string { output := d . RawOutput if output == nil { return "" } if outputStr , ok := d . RawOutput . ( string ) ; ok { suffix := "" if d . prettify { suffix = "\n" } \n } return outputStr + suffix var out string var err error if d . prettify { var b [ ] byte b , err = json . MarshalIndent ( output , "" , " " ) if err == nil { out = string ( b ) + "\n" } } else \n { var b [ ] byte b , err = json . Marshal ( output ) out = string ( b ) } }
6243	func NewAPIAnalyzer ( resources map [ string ] interface { } , attributeTypes map [ string ] string ) * APIAnalyzer { return & APIAnalyzer { rawResources : resources , attributeTypes : attributeTypes , rawTypes : make ( map [ string ] [ ] * gen . ObjectDataType ) , } }
6244	func ( a * APIAnalyzer ) Analyze ( ) * gen . APIDescriptor { a . AnalyzeAliases ( ) var descriptor = & gen . APIDescriptor { Resources : make ( map [ string ] * gen . Resource ) , Types : make ( map [ string ] * gen . ObjectDataType ) , } var rawResourceNames = make ( [ ] string , len ( a . rawResources ) ) var idx = 0 for n := range a . rawResources { rawResourceNames [ idx ] = n idx ++ } sort . Strings ( rawResourceNames ) for _ , name := range rawResourceNames { var resource = a . rawResources [ name ] a . AnalyzeResource ( name , resource , descriptor ) } descriptor . FinalizeTypeNames ( a . rawTypes ) return descriptor }
6245	func ( a * APIAnalyzer ) AnalyzeAliases ( ) { for from , to := range aliases { splits := strings . SplitN ( from , "#" , 2 ) fromResName := splits [ 0 ] fromActionName := splits [ 1 ] splits = strings . SplitN ( to , "#" , 2 ) toResName := splits [ 0 ] toActionName := splits [ 1 ] fromRes := a . rawResources [ fromResName ] fromAct := fromRes . ( map [ string ] interface { } ) [ "methods" ] . ( map [ string ] interface { } ) [ fromActionName ] . ( map [ string ] interface { } ) toRes := a . rawResources [ toResName ] toAct := toRes . ( map [ string ] interface { } ) [ "methods" ] . ( map [ string ] interface { } ) [ toActionName ] . ( map [ string ] interface { } ) fromAct [ "parameters" ] = toAct [ "parameters" ] fromAct [ "status_code" ] = toAct [ "status_code" ] fromAct [ "access_rules" ] = toAct [ "access_rules" ] } }
6246	func LocatorFunc ( attributes [ ] * gen . Attribute , name string ) string { hasLinks := false for _ , a := range attributes { if a . FieldName == "Links" { hasLinks = true break } } if ! hasLinks { return "" } return `for _, l := range r.Links { if l["rel"] == "self" { return api.` + name + `Locator(l["href"]) } } return nil` }
6247	func ParseRoute ( moniker string , routes [ ] string ) ( pathPatterns [ ] * gen . PathPattern ) { var paths [ ] string var method string switch moniker { case "Deployments#servers" : method , paths = "GET" , [ ] string { "/api/deployments/:id/servers" } case "ServerArrays#current_instances" : method , paths = "GET" , [ ] string { "/api/server_arrays/:id/current_instances" } case "ServerArrays#launch" : method , paths = "POST" , [ ] string { "/api/server_arrays/:id/launch" } case "ServerArrays#multi_run_executable" : method , paths = "POST" , [ ] string { "/api/server_arrays/:id/multi_run_executable" } case "ServerArrays#multi_terminate" : method , paths = "POST" , [ ] string { "/api/server_arrays/:id/multi_terminate" } case "Servers#launch" : method , paths = "POST" , [ ] string { "/api/servers/:id/launch" } case "Servers#terminate" : method , paths = "POST" , [ ] string { "/api/servers/:id/terminate" } default : for _ , route := range routes { bound := routeRegexp . FindStringIndex ( route ) match := route [ 0 : bound [ 0 ] ] method = strings . TrimRight ( match [ 0 : 7 ] , " " ) path := strings . TrimRight ( match [ 7 : ] , " " ) path = strings . TrimSuffix ( path , "(.:format)?" ) if isDeprecated ( path ) || isCustom ( method , path ) { continue } paths = append ( paths , path ) } } pathPatterns = make ( [ ] * gen . PathPattern , len ( paths ) ) for i , p := range paths { rx := routeVariablesRegexp . ReplaceAllLiteralString ( regexp . QuoteMeta ( p ) , `/([^/]+)` ) rx = fmt . Sprintf ( "^%s$" , rx ) pattern := gen . PathPattern { HTTPMethod : method , Path : p , Pattern : routeVariablesRegexp . ReplaceAllLiteralString ( p , "/%s" ) , Regexp : rx , } matches := routeVariablesRegexp . FindAllStringSubmatch ( p , - 1 ) if len ( matches ) > 0 { pattern . Variables = make ( [ ] string , len ( matches ) ) for i , m := range matches { pattern . Variables [ i ] = m [ 1 ] } } pathPatterns [ i ] = & pattern } return }
6248	func isDeprecated ( path string ) bool { return strings . Contains ( path , "/api/session" ) && ! strings . Contains ( path , "/api/sessions" ) }
6249	func isQueryParam ( a , n string ) bool { return n == "view" || n == "filter" || ( a == "index" && ( n == "with_deleted" || n == "with_inherited" || n == "latest_only" || n == "lineage" ) ) }
6250	func isPathParam ( p string , pathPatterns [ ] * gen . PathPattern ) bool { for _ , pattern := range pathPatterns { for _ , v := range pattern . Variables { if p == v { return true } } } return false }
6251	func fetchAuditEntries ( client * cm15 . API , filterEmail string ) ( [ ] * cm15 . AuditEntry , error ) { auditLocator := client . AuditEntryLocator ( "/api/audit_entries" ) var apiParams = rsapi . APIParams { "filter" : [ ] string { "user_email==" + filterEmail } } auditEntries , err := auditLocator . Index ( tomorrow ( ) , "100" , yesterday ( ) , apiParams , ) if err != nil { return auditEntries , err } return auditEntries , nil }
6252	func formatTime ( tm time . Time ) string { year , month , date := tm . Date ( ) return time . Date ( year , month , date , 0 , 0 , 0 , 0 , time . UTC ) . Format ( "2006/01/02 15:04:05 -0700" ) }
6253	func printAudits ( entries [ ] * cm15 . AuditEntry ) { for _ , a := range entries { fmt . Printf ( "[%v] <%v>: %v\n" , \n , a . UpdatedAt , a . UserEmail ) } }
6254	func extractUnique ( oldEntries , newEntries [ ] * cm15 . AuditEntry ) [ ] * cm15 . AuditEntry { var uniqueEntries = make ( [ ] * cm15 . AuditEntry , 0 ) var oldHrefs = make ( [ ] string , len ( oldEntries ) ) for i , e := range oldEntries { oldHrefs [ i ] = getHref ( e ) } for _ , newEntry := range newEntries { if ! stringInSlice ( getHref ( newEntry ) , oldHrefs ) { uniqueEntries = append ( uniqueEntries , newEntry ) } } return uniqueEntries }
6255	func getHref ( entry * cm15 . AuditEntry ) string { var href string for _ , link := range entry . Links { if link [ "rel" ] == "self" { href = link [ "href" ] break } } return href }
6256	func fail ( format string , v ... interface { } ) { if ! strings . HasSuffix ( format , "\n" ) \n { format += "\n" } \n }
6257	func parameters ( a * gen . Action ) string { var m = a . MandatoryParams ( ) var hasOptional = a . HasOptionalParams ( ) var countParams = len ( m ) if hasOptional { countParams ++ } var params = make ( [ ] string , countParams ) for i , param := range m { params [ i ] = fmt . Sprintf ( "%s %s" , fixReserved ( param . VarName ) , param . Signature ( ) ) } if hasOptional { params [ countParams - 1 ] = "options rsapi.APIParams" } return strings . Join ( params , ", " ) }
6258	func paramsInitializer ( action * gen . Action , location int , varName string ) string { var fields [ ] string var optionals [ ] * gen . ActionParam varName = fixReserved ( varName ) for _ , param := range action . Params { if param . Location != location { continue } if param . Mandatory { name := param . Name if location == 1 { name = param . QueryName } fields = append ( fields , fmt . Sprintf ( "\"%s\": %s," , \" , \" ) ) } else name } fixReserved ( param . VarName ) { optionals = append ( optionals , param ) } if len ( fields ) == 0 && len ( optionals ) == 0 { return "" } var paramsDecl = fmt . Sprintf ( "rsapi.APIParams{\n%s\n}" , \n ) \n strings . Join ( fields , "\n\t" ) \n }
6259	func commandLine ( ) string { return fmt . Sprintf ( "$ %s %s" , os . Args [ 0 ] , strings . Join ( os . Args [ 1 : ] , " " ) ) }
6260	func toVerb ( text string ) ( res string ) { res = strings . ToUpper ( string ( text [ 0 ] ) ) + strings . ToLower ( text [ 1 : ] ) if text == "GET" || text == "POST" { res += "Raw" } return }
6261	func escapeBackticks ( d string ) string { elems := strings . Split ( d , "`" ) return strings . Join ( elems , "` + `" ) }
6262	func ( api * API ) AccountPreferenceLocator ( href string ) * AccountPreferenceLocator { return & AccountPreferenceLocator { Href ( href ) , api } }
6263	func ( api * API ) ApplicationLocator ( href string ) * ApplicationLocator { return & ApplicationLocator { Href ( href ) , api } }
6264	func ( api * API ) EndUserLocator ( href string ) * EndUserLocator { return & EndUserLocator { Href ( href ) , api } }
6265	func ( api * API ) NotificationRuleLocator ( href string ) * NotificationRuleLocator { return & NotificationRuleLocator { Href ( href ) , api } }
6266	func ( api * API ) UserPreferenceLocator ( href string ) * UserPreferenceLocator { return & UserPreferenceLocator { Href ( href ) , api } }
6267	func ( api * API ) UserPreferenceInfoLocator ( href string ) * UserPreferenceInfoLocator { return & UserPreferenceInfoLocator { Href ( href ) , api } }
6268	func LoadConfig ( path string ) ( * ClientConfig , error ) { content , err := ioutil . ReadFile ( path ) if err != nil { return nil , err } var config ClientConfig err = json . Unmarshal ( content , & config ) if err != nil { return nil , err } config . Password , err = Decrypt ( config . Password ) if err != nil { return nil , err } config . RefreshToken , err = Decrypt ( config . RefreshToken ) return & config , err }
6269	func CreateConfig ( path string ) error { config , _ := LoadConfig ( path ) var emailDef , passwordDef , accountDef , hostDef , refreshTokenDef string if config != nil { yn := PromptConfirmation ( "Found existing configuration file %v, overwrite? (y/N): " , path ) if yn != "y" { PrintSuccess ( "Exiting" ) return nil } emailDef = fmt . Sprintf ( " (%v)" , config . Email ) accountDef = fmt . Sprintf ( " (%v)" , config . Account ) passwordDef = " (leave blank to leave unchanged)" if config . LoginHost == "" { config . LoginHost = "my.rightscale.com" } hostDef = fmt . Sprintf ( " (%v)" , config . LoginHost ) refreshTokenDef = " (leave blank to leave unchanged)" } else { config = & ClientConfig { } } fmt . Fprintf ( out , "Account ID%v: " , accountDef ) var newAccount string fmt . Fscanln ( in , & newAccount ) if newAccount != "" { a , err := strconv . Atoi ( newAccount ) if err != nil { return fmt . Errorf ( "Account ID must be an integer, got '%s'." , newAccount ) } config . Account = a } fmt . Fprintf ( out , "Login email%v: " , emailDef ) var newEmail string fmt . Fscanln ( in , & newEmail ) if newEmail != "" { config . Email = newEmail } fmt . Fprintf ( out , "Login password%v: " , passwordDef ) var newPassword string fmt . Fscanln ( in , & newPassword ) if newPassword != "" { config . Password = newPassword } fmt . Fprintf ( out , "API Login host%v: " , hostDef ) var newLoginHost string fmt . Fscanln ( in , & newLoginHost ) if newLoginHost != "" { config . LoginHost = newLoginHost } fmt . Fprintf ( out , "API Refresh Token%v: " , refreshTokenDef ) var newRefreshToken string fmt . Fscanln ( in , & newRefreshToken ) if newRefreshToken != "" { config . RefreshToken = newRefreshToken } err := config . Save ( path ) if err != nil { return fmt . Errorf ( "Failed to save config: %s" , err ) } return nil }
6270	func fromAPI ( api * rsapi . API ) * API { api . FileEncoding = rsapi . FileEncodingJSON api . Host = HostFromLogin ( api . Host ) api . Metadata = GenMetadata api . VersionHeader = "Api-Version" return & API { api } }
6271	func HostFromLogin ( host string ) string { urlElems := strings . Split ( host , "." ) hostPrefix := urlElems [ 0 ] elems := strings . Split ( hostPrefix , "-" ) if len ( elems ) == 1 && elems [ 0 ] == "cm" { elems [ 0 ] = "governance" } else if len ( elems ) < 2 { return host } else { elems [ len ( elems ) - 2 ] = "governance" } policyHostPrefix := strings . Join ( elems , "-" ) return strings . Join ( append ( [ ] string { policyHostPrefix } , urlElems [ 1 : ] ... ) , "." ) }
6272	func ( a * APIAnalyzer ) AnalyzeParam ( ec EvalCtx , p * Parameter ) * gen . ActionParam { location , ok := loc [ p . In ] if ! ok { location = - 1 } ap := & gen . ActionParam { Name : p . Name , QueryName : p . Name , Description : cleanDescription ( p . Description ) , VarName : toVarName ( p . Name ) , Location : location , Mandatory : p . Required , NonBlank : p . Required || p . Pattern != "" , Regexp : p . Pattern , ValidValues : p . Enum , } if p . Schema != nil { ap . Type = a . typeForRef ( ec , p . Schema ) } else { ap . Type = basicType ( p . Type ) } return ap }
6273	func ( a * APIAnalyzer ) AnalyzeAttribute ( name , query string , attr map [ string ] interface { } ) ( * gen . ActionParam , error ) { param := gen . ActionParam { Name : name , QueryName : query , VarName : toVarName ( name ) } if d , ok := attr [ "description" ] ; ok { param . Description = removeBlankLines ( d . ( string ) ) } if r , ok := attr [ "required" ] ; ok { if r . ( bool ) { param . Mandatory = true } } if options , ok := attr [ "options" ] ; ok { opts , ok := options . ( map [ string ] interface { } ) if ok { for n , o := range opts { switch n { case "max" : param . Max = int ( o . ( float64 ) ) case "min" : param . Min = int ( o . ( float64 ) ) case "regexp" : param . Regexp = o . ( string ) } } } } if values , ok := attr [ "values" ] ; ok { param . ValidValues = values . ( [ ] interface { } ) } t := attr [ "type" ] . ( map [ string ] interface { } ) dataType , err := a . AnalyzeType ( t , query ) if err != nil { return nil , err } param . Type = dataType switch dataType . ( type ) { case * gen . ArrayDataType : param . QueryName += "[]" } return & param , nil }
6274	func ( a * APIAnalyzer ) AnalyzeType ( typeDef map [ string ] interface { } , query string ) ( gen . DataType , error ) { n , ok := typeDef [ "name" ] . ( string ) if ! ok { n = "Struct" } if strings . HasSuffix ( n , "FileUpload" ) { t , ok := a . RawTypes [ n ] if ! ok { return nil , fmt . Errorf ( "Unknown type %s for %s" , n , prettify ( typeDef ) ) } attrs , ok := t [ "attributes" ] if ! ok { return nil , fmt . Errorf ( "Invalid file upload type %s for %s: no attributes" , n , prettify ( typeDef ) ) } mattrs , ok := attrs . ( map [ string ] interface { } ) if ! ok { return nil , fmt . Errorf ( "Invalid file upload type %s for %s: basic type" , n , prettify ( typeDef ) ) } _ , ok = mattrs [ "name" ] if ! ok { return nil , fmt . Errorf ( "Invalid file upload type %s for %s: no name" , n , prettify ( typeDef ) ) } _ , ok = mattrs [ "filename" ] if ! ok { return nil , fmt . Errorf ( "Invalid file upload type %s for %s: no filename" , n , prettify ( typeDef ) ) } return & gen . UploadDataType { TypeName : n } , nil } if isBuiltInType ( n ) { n = "String" } var dataType gen . DataType switch n { case "Integer" : i := gen . BasicDataType ( "int" ) dataType = & i case "Float" : f := gen . BasicDataType ( "float64" ) dataType = & f case "String" : s := gen . BasicDataType ( "string" ) dataType = & s case "Boolean" : b := gen . BasicDataType ( "bool" ) dataType = & b case "Object" : o := gen . BasicDataType ( "interface{}" ) dataType = & o case "DateTime" : t := gen . BasicDataType ( "*time.Time" ) a . descriptor . NeedTime = true dataType = & t case "Collection" , "Ids" : member , ok := typeDef [ "member_attribute" ] . ( map [ string ] interface { } ) if ! ok { return nil , fmt . Errorf ( "Missing \"member_attribute\" for %s" , \" ) } \" prettify ( typeDef ) elemType , err := a . AnalyzeAttribute ( n + "Member" , query + "[]" , member ) if err != nil { return nil , fmt . Errorf ( "Failed to compute type of \"member_attribute\": %s" , \" ) } \" err } dataType = & gen . ArrayDataType { elemType } }
6275	func ( a * APIAnalyzer ) CreateType ( query string , attributes map [ string ] interface { } ) ( * gen . ObjectDataType , error ) { name := inflect . Camelize ( bracketRegexp . ReplaceAllLiteralString ( query , "_" ) + "_struct" ) obj := a . Registry . CreateInlineType ( name ) obj . Fields = make ( [ ] * gen . ActionParam , len ( attributes ) ) for idx , an := range sortedKeys ( attributes ) { at := attributes [ an ] var childQ string if query == "payload" { childQ = an } else { childQ = fmt . Sprintf ( "%s[%s]" , query , an ) } att , err := a . AnalyzeAttribute ( an , childQ , at . ( map [ string ] interface { } ) ) if err != nil { return nil , fmt . Errorf ( "Failed to compute type of attribute %s: %s" , an , err ) } obj . Fields [ idx ] = att } return obj , nil }
6276	func ( d * Doc ) Ref ( r Ref ) * Definition { if refIF , ok := r [ "$ref" ] ; ok { refKey := strings . TrimPrefix ( refIF . ( string ) , "#/definitions/" ) return d . Definitions [ refKey ] } return nil }
6277	func ( r Ref ) Type ( ) string { if _ , ok := r [ "$ref" ] ; ok { return "object" } if refIF , ok := r [ "type" ] ; ok { return refIF . ( string ) } return "" }
6278	func ( r Ref ) Required ( ) [ ] string { if refIF , ok := r [ "required" ] ; ok { return refIF . ( [ ] string ) } return [ ] string { } }
6279	func ( r Ref ) ID ( ) string { if refIF , ok := r [ "$ref" ] ; ok { return strings . TrimPrefix ( refIF . ( string ) , "#/definitions/" ) } return "" }
6280	func ( ep * Endpoint ) Service ( ) string { if len ( ep . Tags ) > 0 { return ep . Tags [ 0 ] } if len ( ep . OperationID ) > 0 { return strings . Split ( ep . OperationID , "#" ) [ 0 ] } return "" }
6281	func ( ep * Endpoint ) Method ( ) string { if strings . Contains ( ep . OperationID , "#" ) { return strings . Split ( ep . OperationID , "#" ) [ 1 ] } return "" }
6282	func NewTypeRegistry ( ) * TypeRegistry { return & TypeRegistry { NamedTypes : make ( map [ string ] * gen . ObjectDataType ) , InlineTypes : make ( map [ string ] [ ] * gen . ObjectDataType ) , } }
6283	func ( reg * TypeRegistry ) GetNamedType ( name string ) * gen . ObjectDataType { return reg . NamedTypes [ toGoTypeName ( name ) ] }
6284	func ( reg * TypeRegistry ) CreateNamedType ( name string ) * gen . ObjectDataType { goName := toGoTypeName ( name ) obj := gen . ObjectDataType { TypeName : goName } if _ , ok := reg . NamedTypes [ goName ] ; ok { panic ( "BUG: Can't create two named types with same name...." ) } reg . NamedTypes [ goName ] = & obj return & obj }
6285	func ( reg * TypeRegistry ) CreateInlineType ( name string ) * gen . ObjectDataType { goName := toGoTypeName ( name ) obj := gen . ObjectDataType { TypeName : goName } reg . InlineTypes [ goName ] = append ( reg . InlineTypes [ goName ] , & obj ) return & obj }
6286	func ( reg * TypeRegistry ) FinalizeTypeNames ( d * gen . APIDescriptor ) { for n , named := range reg . NamedTypes { reg . InlineTypes [ n ] = append ( reg . InlineTypes [ n ] , named ) } d . FinalizeTypeNames ( reg . InlineTypes ) }
6287	func ( d * APIDescriptor ) Merge ( other * APIDescriptor ) error { if d . Version != other . Version { return fmt . Errorf ( "Can't merge API descriptors with different versions" ) } for _ , name := range d . ResourceNames { for _ , otherName := range other . ResourceNames { if name == otherName { return fmt . Errorf ( "%s is a resource that exists in multiple APIs, generate separate clients" , name ) } } } for _ , name := range d . TypeNames { for i , otherName := range other . TypeNames { if name == otherName { newName := MakeUniq ( otherName , append ( d . TypeNames , other . TypeNames ... ) ) first := other . TypeNames [ : i ] last := append ( [ ] string { newName } , other . TypeNames [ i + 1 : ] ... ) other . TypeNames = append ( first , last ... ) typ := other . Types [ name ] delete ( other . Types , name ) typ . TypeName = newName other . Types [ newName ] = typ } } } for name , resource := range other . Resources { d . Resources [ name ] = resource } for name , typ := range other . Types { d . Types [ name ] = typ } d . ResourceNames = append ( d . ResourceNames , other . ResourceNames ... ) d . TypeNames = append ( d . TypeNames , other . TypeNames ... ) return nil }
6288	func ( d * APIDescriptor ) FinalizeTypeNames ( rawTypes map [ string ] [ ] * ObjectDataType ) { rawTypeNames := make ( [ ] string , len ( rawTypes ) ) idx := 0 for n := range rawTypes { rawTypeNames [ idx ] = n idx ++ } sort . Strings ( rawTypeNames ) for _ , tn := range rawTypeNames { types := rawTypes [ tn ] for rn := range d . Resources { if tn == rn { oldTn := tn if strings . HasSuffix ( tn , "Param" ) { tn = fmt . Sprintf ( "%s2" , tn ) } else { tn = fmt . Sprintf ( "%sParam" , tn ) } for _ , ty := range types { ty . TypeName = tn } rawTypes [ tn ] = types delete ( rawTypes , oldTn ) } } } idx = 0 for n := range rawTypes { rawTypeNames [ idx ] = n idx ++ } sort . Strings ( rawTypeNames ) for _ , tn := range rawTypeNames { types := rawTypes [ tn ] first := types [ 0 ] d . Types [ tn ] = first if len ( types ) > 1 { for i , ty := range types [ 1 : ] { found := false for j := 0 ; j < i + 1 ; j ++ { if ty . IsEquivalent ( types [ j ] ) { found = true break } } if ! found { newName := d . uniqueTypeName ( tn ) ty . TypeName = newName d . Types [ newName ] = ty d . TypeNames = append ( d . TypeNames , newName ) } } } } idx = 0 resourceNames := make ( [ ] string , len ( d . Resources ) ) for n := range d . Resources { resourceNames [ idx ] = n idx ++ } sort . Strings ( resourceNames ) d . ResourceNames = resourceNames typeNames := make ( [ ] string , len ( d . Types ) ) idx = 0 for tn := range d . Types { typeNames [ idx ] = tn idx ++ } sort . Strings ( typeNames ) d . TypeNames = typeNames }
6289	func ( d * APIDescriptor ) uniqueTypeName ( prefix string ) string { u := fmt . Sprintf ( "%s%d" , prefix , 2 ) taken := false for _ , tn := range d . TypeNames { if tn == u { taken = true break } } idx := 3 for taken { u = fmt . Sprintf ( "%s%d" , prefix , idx ) taken = false for _ , tn := range d . TypeNames { if tn == u { taken = true break } } if taken { idx ++ } } return u }
6290	func ( a * Action ) MandatoryParams ( ) [ ] * ActionParam { m := make ( [ ] * ActionParam , len ( a . Params ) ) i := 0 for _ , p := range a . Params { if p . Mandatory { m [ i ] = p i ++ } } return m [ : i ] }
6291	func ( a * Action ) HasOptionalParams ( ) bool { for _ , param := range a . Params { if ! param . Mandatory { return true } } return false }
6292	func MakeUniq ( base string , taken [ ] string ) string { idx := 1 uniq := base inuse := true for inuse { inuse = false for _ , gn := range taken { if gn == uniq { inuse = true break } } if inuse { idx ++ uniq = base + strconv . Itoa ( idx ) } } return uniq }
6293	func NewClientWriter ( ) ( * ClientWriter , error ) { funcMap := template . FuncMap { "comment" : comment , "commandLine" : commandLine , "parameters" : parameters , "paramsInitializer" : paramsInitializer , "blankCondition" : blankCondition , "stripStar" : stripStar , } headerT , err := template . New ( "header-client" ) . Funcs ( funcMap ) . Parse ( headerTmpl ) if err != nil { return nil , err } resourceT , err := template . New ( "resource-client" ) . Funcs ( funcMap ) . Parse ( resourceTmpl ) if err != nil { return nil , err } return & ClientWriter { headerTmpl : headerT , resourceTmpl : resourceT , } , nil }
6294	func ( c * ClientWriter ) WriteHeader ( pkg , version string , needTime , needJSON bool , w io . Writer ) error { ctx := map [ string ] interface { } { "Pkg" : pkg , "APIVersion" : version , "NeedTime" : needTime , "NeedJSON" : needJSON , } return c . headerTmpl . Execute ( w , ctx ) }
6295	func ( c * ClientWriter ) WriteResourceHeader ( name string , w io . Writer ) { fmt . Fprintf ( w , "/****** %s ******/\n\n" , \n ) }
6296	func ( c * ClientWriter ) WriteType ( o * gen . ObjectDataType , w io . Writer ) { fields := make ( [ ] string , len ( o . Fields ) ) for i , f := range o . Fields { fields [ i ] = fmt . Sprintf ( "%s %s `json:\"%s,omitempty\"`" , \" , \" , strings . Title ( f . VarName ) ) } f . Signature ( ) f . Name }
6297	func ( c * ClientWriter ) WriteResource ( resource * gen . Resource , w io . Writer ) error { return c . resourceTmpl . Execute ( w , resource ) }
6298	func ( ec EvalCtx ) WithTrail ( t string ) EvalCtx { newEC := ec trailCopy := make ( [ ] string , 0 , len ( ec . Trail ) + 1 ) for _ , val := range ec . Trail { trailCopy = append ( trailCopy , val ) } newEC . Trail = append ( trailCopy , t ) return newEC }
6299	func ( a * APIAnalyzer ) AnalyzeEndpoint ( verb string , path string , ep * Endpoint ) error { path = joinPath ( a . Doc . BasePath , path ) dbg ( "\n------\nDEBUG AnalyzeEndpoint %s %s %+v\n" , \n , \n , \n ) verb path ep pattern := toPattern ( verb , path ) dbg ( "DEBUG AnalyzeEndpoint pattern %v\n" , \n ) pattern svc := ep . Service ( ) res := a . api . Resources [ svc ] if res == nil { res = & gen . Resource { Name : svc , ClientName : a . ClientName , Actions : [ ] * gen . Action { } , } a . api . Resources [ svc ] = res } action := & gen . Action { Name : ep . Method ( ) , MethodName : toMethodName ( ep . Method ( ) ) , Description : cleanDescription ( ep . Description ) , ResourceName : svc , PathPatterns : [ ] * gen . PathPattern { pattern } , } res . Actions = append ( res . Actions , action ) var returnDT gen . DataType var hasLocation bool for code , response := range ep . Responses { if code >= 300 { continue } if response . Headers != nil { if _ , ok := response . Headers [ "Location" ] ; ok { hasLocation = true } } if response . Schema == nil { dbg ( "DEBUG MISSING SCHEMA SKIP!\n" ) \n } break dbg ( "DEBUG AnalyzeEndpoint %d RESPONSE %#v\n" , \n , code ) response returnDef := a . Doc . Ref ( response . Schema ) } if returnDef != nil { ec := EvalCtx { IsResult : true , Trail : nil , Svc : res , Method : action } if mediaType ( returnDef . Title ) == "" { warn ( "Warning: AnalyzeEndpoint: MediaType not set for %s, will be hard to guess the result type\n" , \n ) response . Schema . ID ( ) } continue returnDT = a . AnalyzeDefinition ( ec , returnDef , response . Schema . ID ( ) ) } else if returnObj , ok := returnDT . ( * gen . ObjectDataType ) ; ok { isResourceType := verb == "get" && returnObj . TypeName == svc dbg ( "DEBUG AnalyzeEndpoint Path %s Verb %s returnTypeName %s svc %s\n" , \n , path , verb , returnObj . TypeName ) svc if isResourceType { res . Description = cleanDescription ( ep . Description ) res . Identifier = mediaType ( returnDef . Title ) } } }
6300	func ( api * API ) NetworkInterfaceLocator ( href string ) * NetworkInterfaceLocator { return & NetworkInterfaceLocator { Href ( href ) , api } }
6301	func ( api * API ) NetworkInterfaceAttachmentLocator ( href string ) * NetworkInterfaceAttachmentLocator { return & NetworkInterfaceAttachmentLocator { Href ( href ) , api } }
6302	func ( r * RubyTime ) UnmarshalJSON ( b [ ] byte ) ( err error ) { s := string ( b ) t , err := time . Parse ( "2006/01/02 15:04:05 -0700" , s [ 1 : len ( s ) - 1 ] ) if err != nil { return err } r . Time = t return nil }
6303	func ( api * API ) ExecutionLocator ( href string ) * ExecutionLocator { return & ExecutionLocator { Href ( href ) , api } }
6304	func ( api * API ) NotificationLocator ( href string ) * NotificationLocator { return & NotificationLocator { Href ( href ) , api } }
6305	func ( api * API ) OperationLocator ( href string ) * OperationLocator { return & OperationLocator { Href ( href ) , api } }
6306	func ( api * API ) ScheduledActionLocator ( href string ) * ScheduledActionLocator { return & ScheduledActionLocator { Href ( href ) , api } }
6307	func NewBasicAuthenticator ( username , password string , accountID int ) Authenticator { builder := basicLoginRequestBuilder { username : username , password : password , accountID : accountID } return newCookieSigner ( & builder , accountID ) }
6308	func NewSSAuthenticator ( auther Authenticator , accountID int ) Authenticator { if _ , ok := auther . ( * ssAuthenticator ) ; ok { return auther } return & ssAuthenticator { auther : auther , accountID : accountID , refreshAt : time . Now ( ) . Add ( - 2 * time . Minute ) , client : httpclient . NewNoRedirect ( ) , } }
6309	func newCookieSigner ( builder loginRequestBuilder , accountID int ) Authenticator { return & cookieSigner { builder : builder , accountID : accountID , refreshAt : time . Now ( ) . Add ( - 2 * time . Minute ) , client : httpclient . NewNoRedirect ( ) , } }
6310	func ( s * cookieSigner ) Sign ( req * http . Request ) error { if time . Now ( ) . After ( s . refreshAt ) { authReq , authErr := s . builder . BuildLoginRequest ( s . host ) if authErr != nil { return authErr } resp , err := s . client . DoHidden ( authReq ) if err != nil { return err } url , err := extractRedirectURL ( resp ) if err != nil { return err } if url != nil { authReq , authErr = s . builder . BuildLoginRequest ( url . Host ) if authErr != nil { return authErr } s . host = url . Host req . Host = url . Host req . URL . Host = url . Host resp , err = s . client . DoHidden ( authReq ) } if err != nil { return fmt . Errorf ( "Authentication failed: %s" , err ) } if err := s . refresh ( resp ) ; err != nil { return err } } for _ , c := range s . cookies { req . AddCookie ( c ) } req . Header . Set ( "X-Account" , strconv . Itoa ( s . accountID ) ) return nil }
6311	func ( s * cookieSigner ) CanAuthenticate ( host string ) error { _ , instance := s . builder . ( * instanceLoginRequestBuilder ) return testAuth ( s , s . client , host , instance ) }
6312	func ( s * cookieSigner ) refresh ( resp * http . Response ) error { if resp . StatusCode != 204 { return fmt . Errorf ( "Authentication failed: %s" , resp . Status ) } s . cookies = resp . Cookies ( ) s . refreshAt = time . Now ( ) . Add ( time . Duration ( 2 ) * time . Hour ) return nil }
6313	func ( t * tokenAuthenticator ) Sign ( r * http . Request ) error { r . Header . Set ( "Authorization" , "Bearer " + t . token ) if t . accountID != 0 { r . Header . Set ( "X-Account" , strconv . Itoa ( t . accountID ) ) } return nil }
6314	func ( a * rl10Authenticator ) Sign ( r * http . Request ) error { r . Header . Set ( "X-RLL-Secret" , a . secret ) return nil }
6315	func ( a * ssAuthenticator ) Sign ( r * http . Request ) error { if time . Now ( ) . After ( a . refreshAt ) { u := buildURL ( a . host , "api/catalog/new_session" ) u += "?account_id=" + strconv . Itoa ( a . accountID ) authReq , err := http . NewRequest ( "GET" , u , nil ) if err != nil { return err } if err := a . auther . Sign ( authReq ) ; err != nil { return err } if ca , ok := a . auther . ( * cookieSigner ) ; ok { a . SetHost ( ca . host ) authReq . Host = a . host authReq . URL . Host = a . host } authReq . Header . Set ( "Content-Type" , "application/json" ) resp , err := a . client . DoHidden ( authReq ) if err != nil { return fmt . Errorf ( "Authentication failed: %s" , err ) } if resp . StatusCode != 303 { body , err := ioutil . ReadAll ( resp . Body ) var msg string if err != nil { msg = " - <failed to read body>" } if len ( body ) > 0 { msg = " - " + string ( body ) } return fmt . Errorf ( "Authentication failed: %s%s" , resp . Status , msg ) } a . refreshAt = time . Now ( ) . Add ( 2 * time . Hour ) } a . auther . Sign ( r ) r . Header . Set ( "X-Api-Version" , "1.0" ) r . Host = a . host r . URL . Host = a . host return nil }
6316	func ( a * ssAuthenticator ) SetHost ( host string ) { a . auther . SetHost ( host ) urlElems := strings . Split ( host , "." ) hostPrefix := urlElems [ 0 ] elems := strings . Split ( hostPrefix , "-" ) if len ( elems ) == 1 && elems [ 0 ] == "cm" { elems [ 0 ] = "selfservice" } else if len ( elems ) < 2 { a . host = host return } else { elems [ len ( elems ) - 2 ] = "selfservice" } ssLoginHostPrefix := strings . Join ( elems , "-" ) a . host = strings . Join ( append ( [ ] string { ssLoginHostPrefix } , urlElems [ 1 : ] ... ) , "." ) }
6317	func ( a * ssAuthenticator ) CanAuthenticate ( host string ) error { url := fmt . Sprintf ( "api/catalog/accounts/%d/user_preferences" , a . accountID ) req , err := http . NewRequest ( "GET" , buildURL ( host , url ) , nil ) if err != nil { return err } req . Header . Set ( "X-Api-Version" , "1.0" ) if err := a . Sign ( req ) ; err != nil { return err } resp , err := a . client . DoHidden ( req ) if err != nil { return err } if resp . StatusCode != 200 { var body string if b , err := ioutil . ReadAll ( resp . Body ) ; err != nil { body = ": " + string ( b ) } return fmt . Errorf ( "%s%s" , resp . Status , body ) } return nil }
6318	func extractRedirectURL ( resp * http . Response ) ( * url . URL , error ) { var u * url . URL if resp . StatusCode > 299 && resp . StatusCode < 399 { loc := resp . Header . Get ( "Location" ) if loc != "" { var err error u , err = url . Parse ( loc ) if err != nil { return nil , fmt . Errorf ( "invalid Location header '%s': %s" , loc , err ) } } } return u , nil }
6319	func buildURL ( host , path string ) string { scheme := "https" if httpclient . Insecure { scheme = "http" } u := url . URL { Scheme : scheme , Host : host , Path : path , } return u . String ( ) }
6320	func ( r * Resource ) GetAction ( name string ) * Action { for _ , a := range r . Actions { if a . Name == name { return a } } return nil }
6321	func ( r * Resource ) HasLink ( name string ) bool { for n , _ := range r . Links { if n == name { return true } } return false }
6322	func ( r * Resource ) findMatches ( href string ) [ ] * PathPattern { var matches [ ] * PathPattern for _ , action := range r . Actions { for _ , pattern := range action . PathPatterns { if pattern . Regexp . MatchString ( href ) || pattern . Regexp . MatchString ( href + "/" ) { matches = append ( matches , pattern ) } } } return matches }
6323	func NewPB ( pb * ParamBlock ) HTTPClient { responseHeaderTimeout := pb . ResponseHeaderTimeout if responseHeaderTimeout == 0 { responseHeaderTimeout = defaultResponseHeaderTimeout } dumpFormat := pb . DumpFormat if dumpFormat == 0 { dumpFormat = NoDump } hiddenHeaders := pb . HiddenHeaders if hiddenHeaders == nil { hiddenHeaders = defaultHiddenHeaders } else { hiddenHeaders = copyHiddenHeaders ( hiddenHeaders ) } dc := & dumpClient { Client : newRawClient ( pb . NoRedirect , pb . NoCertCheck , pb . DisableKeepAlives , responseHeaderTimeout ) } dc . isInsecure = func ( ) bool { return pb . Insecure } dc . dumpFormat = func ( ) Format { return dumpFormat } dc . hiddenHeaders = func ( ) map [ string ] bool { return hiddenHeaders } return dc }
6324	func newVariableDumpClient ( c * http . Client ) HTTPClient { dc := & dumpClient { Client : c } dc . isInsecure = func ( ) bool { return Insecure } dc . dumpFormat = func ( ) Format { return DumpFormat } dc . hiddenHeaders = func ( ) map [ string ] bool { return HiddenHeaders } return dc }
6325	func newRawClient ( noRedirect , noCertCheck , disableKeepAlives bool , responseHeaderTimeout time . Duration ) * http . Client { tr := http . Transport { DisableKeepAlives : disableKeepAlives , ResponseHeaderTimeout : responseHeaderTimeout , Proxy : http . ProxyFromEnvironment , } tr . TLSClientConfig = & tls . Config { InsecureSkipVerify : noCertCheck } c := http . Client { Transport : & tr } if noRedirect { c . CheckRedirect = func ( * http . Request , [ ] * http . Request ) error { return fmt . Errorf ( noRedirectError ) } } return & c }
6326	func ( d * dumpClient ) DoHidden ( req * http . Request ) ( * http . Response , error ) { return d . doImp ( req , true , nil ) }
6327	func ( d * dumpClient ) Do ( req * http . Request ) ( * http . Response , error ) { return d . doImp ( req , false , nil ) }
6328	func ( d * dumpClient ) doImp ( req * http . Request , hidden bool , ctx context . Context ) ( * http . Response , error ) { if req . URL . Scheme == "" { if d . isInsecure ( ) { req . URL . Scheme = "http" } else { req . URL . Scheme = "https" } } ua := req . Header . Get ( "User-Agent" ) if ua == "" { req . Header . Set ( "User-Agent" , UA ) } var reqBody [ ] byte startedAt := time . Now ( ) id := req . Header . Get ( requestIdHeader ) if id == "" { id = ShortToken ( ) } log . Info ( "started" , "id" , id , req . Method , req . URL . String ( ) ) df := d . dumpFormat ( ) hide := ( df == NoDump ) || ( hidden && ! df . IsVerbose ( ) ) if ! hide { startedAt = time . Now ( ) reqBody = d . dumpRequest ( req ) } var resp * http . Response var err error if ctx == nil { resp , err = d . Client . Do ( req ) } else { resp , err = ctxhttpDo ( ctx , d . getClientWithoutTimeout ( ) , req ) } if urlError , ok := err . ( * url . Error ) ; ok { if urlError . Err . Error ( ) == noRedirectError { err = nil } } if err != nil { return nil , err } if ! hide { d . dumpResponse ( resp , req , reqBody ) } log . Info ( "completed" , "id" , id , "status" , resp . Status , "time" , time . Since ( startedAt ) . String ( ) ) return resp , nil }
6329	func ( d * dumpClient ) getClientWithoutTimeout ( ) * http . Client { client := * d . Client tr , ok := client . Transport . ( * http . Transport ) if ok { trCopy := & http . Transport { Proxy : tr . Proxy , DialContext : tr . DialContext , Dial : tr . Dial , DialTLS : tr . DialTLS , TLSClientConfig : tr . TLSClientConfig , TLSHandshakeTimeout : tr . TLSHandshakeTimeout , DisableKeepAlives : tr . DisableKeepAlives , DisableCompression : tr . DisableCompression , MaxIdleConns : tr . MaxIdleConns , MaxIdleConnsPerHost : tr . MaxIdleConnsPerHost , IdleConnTimeout : tr . IdleConnTimeout , ResponseHeaderTimeout : 0 , ExpectContinueTimeout : tr . ExpectContinueTimeout , TLSNextProto : tr . TLSNextProto , MaxResponseHeaderBytes : tr . MaxResponseHeaderBytes , } tr = trCopy } else { tr = & http . Transport { Proxy : http . ProxyFromEnvironment } tr . TLSClientConfig = & tls . Config { InsecureSkipVerify : NoCertCheck } } client . Transport = tr return & client }
6330	func ( d * dumpClient ) dumpRequest ( req * http . Request ) [ ] byte { df := d . dumpFormat ( ) if df == NoDump { return nil } reqBody , err := dumpReqBody ( req ) if err != nil { log . Error ( "Failed to load request body for dump" , "error" , err . Error ( ) ) } if df . IsDebug ( ) { var buffer bytes . Buffer buffer . WriteString ( req . Method + " " + req . URL . String ( ) + "\n" ) \n d . writeHeaders ( & buffer , req . Header ) if reqBody != nil { buffer . WriteString ( "\n" ) \n buffer . Write ( reqBody ) } } else buffer . WriteString ( "\n" ) \n }
6331	func ( d * dumpClient ) writeHeaders ( buffer * bytes . Buffer , headers http . Header ) { filterHeaders ( d . dumpFormat ( ) , d . hiddenHeaders ( ) , headers , func ( name string , value [ ] string ) { buffer . WriteString ( name ) buffer . WriteString ( ": " ) buffer . WriteString ( strings . Join ( value , ", " ) ) buffer . WriteString ( "\n" ) } ) }
6332	func copyHiddenHeaders ( from map [ string ] bool ) ( to map [ string ] bool ) { to = make ( map [ string ] bool ) for k , v := range from { to [ k ] = v } return }
6333	func validateCommandLine ( cmdLine * cmd . CommandLine ) { if cmdLine . Command == "setup" || cmdLine . Command == "actions" || cmdLine . Command == "json" || cmdLine . ShowHelp || cmdLine . RL10 { return } if cmdLine . Account == 0 && cmdLine . OAuthToken == "" && cmdLine . OAuthAccessToken == "" && cmdLine . APIToken == "" && ! cmdLine . NoAuth { kingpin . Fatalf ( "missing --account option" ) } if cmdLine . Host == "" { kingpin . Fatalf ( "missing --host option" ) } if cmdLine . Password == "" && cmdLine . OAuthToken == "" && cmdLine . OAuthAccessToken == "" && cmdLine . APIToken == "" && ! cmdLine . NoAuth { kingpin . Fatalf ( "missing login info, use --email and --pwd or use --key, --apiToken or --rl10" ) } }
6334	func APIClient ( name string , cmdLine * cmd . CommandLine ) ( cmd . CommandClient , error ) { switch name { case Cm15Command : return cm15 . FromCommandLine ( cmdLine ) case Cm16Command : return cm16 . FromCommandLine ( cmdLine ) case SsCommand : return ss . FromCommandLine ( cmdLine ) case Rl10Command : return rl10 . FromCommandLine ( cmdLine ) case CaCommand : return ca . FromCommandLine ( cmdLine ) case PolicyCommand : return policy . FromCommandLine ( cmdLine ) default : return nil , fmt . Errorf ( "No client for '%s'" , name ) } }
6335	func RegisterClientCommands ( app * kingpin . Application ) { cm15Cmd := app . Command ( Cm15Command , cm15 . APIName ) registrar := rsapi . Registrar { APICmd : cm15Cmd } cm15 . RegisterCommands ( & registrar ) cm16Cmd := app . Command ( Cm16Command , cm16 . APIName ) registrar = rsapi . Registrar { APICmd : cm16Cmd } cm16 . RegisterCommands ( & registrar ) ssCmd := app . Command ( SsCommand , ss . APIName ) registrar = rsapi . Registrar { APICmd : ssCmd } ss . RegisterCommands ( & registrar ) rl10Cmd := app . Command ( Rl10Command , rl10 . APIName ) registrar = rsapi . Registrar { APICmd : rl10Cmd } rl10 . RegisterCommands ( & registrar ) caCmd := app . Command ( CaCommand , ca . APIName ) registrar = rsapi . Registrar { APICmd : caCmd } ca . RegisterCommands ( & registrar ) policyCmd := app . Command ( PolicyCommand , policy . APIName ) registrar = rsapi . Registrar { APICmd : policyCmd } policy . RegisterCommands ( & registrar ) }
6336	func Interactive ( ) { Logger . SetHandler ( log15 . MultiHandler ( log15 . LvlFilterHandler ( log15 . LvlError , log15 . StderrHandler ) ) ) }
6337	func toPattern ( verb , path string ) * gen . PathPattern { pattern := gen . PathPattern { HTTPMethod : verb , Path : path , Pattern : pathVariablesRegexp . ReplaceAllLiteralString ( path , "/%s" ) , Regexp : pathVariablesRegexp . ReplaceAllLiteralString ( regexp . QuoteMeta ( path ) , `/([^/]+)` ) , } matches := pathVariablesRegexp . FindAllStringSubmatch ( path , - 1 ) if len ( matches ) > 0 { pattern . Variables = make ( [ ] string , len ( matches ) ) for i , m := range matches { pattern . Variables [ i ] = m [ 1 ] } } return & pattern }
6338	func WithClientIP ( ctx context . Context , ip net . IP ) context . Context { if ip == nil { return ctx } return context . WithValue ( ctx , clientIPKey { } , ip ) }
6339	func ClientIP ( ctx context . Context ) net . IP { ip , _ := ctx . Value ( clientIPKey { } ) . ( net . IP ) return ip }
6340	func NewProducer ( config ProducerConfig ) ( p * Producer , err error ) { config . defaults ( ) p = & Producer { reqs : make ( chan ProducerRequest , config . MaxConcurrency ) , done : make ( chan struct { } ) , address : config . Address , topic : config . Topic , dialTimeout : config . DialTimeout , readTimeout : config . ReadTimeout , writeTimeout : config . WriteTimeout , } return }
6341	func StartProducer ( config ProducerConfig ) ( p * Producer , err error ) { p , err = NewProducer ( config ) if err != nil { return } p . Start ( ) return }
6342	func ( p * Producer ) Start ( ) { if p . started { panic ( "(*Producer).Start has already been called" ) } concurrency := cap ( p . reqs ) p . join . Add ( concurrency ) for i := 0 ; i != concurrency ; i ++ { go p . run ( ) } p . started = true }
6343	func ( p * Producer ) Stop ( ) { p . once . Do ( p . stop ) err := errors . New ( "publishing to a producer that was already stopped" ) for req := range p . reqs { req . complete ( err ) } p . join . Wait ( ) }
6344	func ( p * Producer ) Publish ( message [ ] byte ) ( err error ) { return p . PublishTo ( p . topic , message ) }
6345	func ( p * Producer ) PublishTo ( topic string , message [ ] byte ) ( err error ) { defer func ( ) { if recover ( ) != nil { err = errors . New ( "publishing to a producer that was already stopped" ) } } ( ) if len ( topic ) == 0 { return errors . New ( "no topic set for publishing message" ) } response := make ( chan error , 1 ) deadline := time . Now ( ) . Add ( p . dialTimeout + p . readTimeout + p . writeTimeout ) p . reqs <- ProducerRequest { Topic : topic , Message : message , Response : response , Deadline : deadline , } err = <- response return }
6346	func NewLocalEngine ( config LocalConfig ) * LocalEngine { if config . NodeTimeout == 0 { config . NodeTimeout = DefaultLocalEngineNodeTimeout } if config . TombstoneTimeout == 0 { config . TombstoneTimeout = DefaultLocalEngineTombstoneTimeout } e := & LocalEngine { nodeTimeout : config . NodeTimeout , tombTimeout : config . TombstoneTimeout , done : make ( chan struct { } ) , join : make ( chan struct { } ) , nodes : make ( map [ string ] * LocalNode ) , } go e . run ( ) return e }
6347	func ( c * ConsumerConfig ) validate ( ) error { if len ( c . Topic ) == 0 { return errors . New ( "creating a new consumer requires a non-empty topic" ) } if len ( c . Channel ) == 0 { return errors . New ( "creating a new consumer requires a non-empty channel" ) } return nil }
6348	func ( c * ConsumerConfig ) defaults ( ) { if c . MaxInFlight == 0 { c . MaxInFlight = DefaultMaxInFlight } if c . DialTimeout == 0 { c . DialTimeout = DefaultDialTimeout } if c . ReadTimeout == 0 { c . ReadTimeout = DefaultReadTimeout } if c . WriteTimeout == 0 { c . WriteTimeout = DefaultWriteTimeout } }
6349	func NewConsumer ( config ConsumerConfig ) ( c * Consumer , err error ) { if err = config . validate ( ) ; err != nil { return } config . defaults ( ) c = & Consumer { msgs : make ( chan Message , config . MaxInFlight ) , done : make ( chan struct { } ) , topic : config . Topic , channel : config . Channel , address : config . Address , lookup : append ( [ ] string { } , config . Lookup ... ) , maxInFlight : config . MaxInFlight , identify : setIdentifyDefaults ( config . Identify ) , dialTimeout : config . DialTimeout , readTimeout : config . ReadTimeout , writeTimeout : config . WriteTimeout , conns : make ( map [ string ] ( chan <- Command ) ) , } return }
6350	func StartConsumer ( config ConsumerConfig ) ( c * Consumer , err error ) { c , err = NewConsumer ( config ) if err != nil { return } c . Start ( ) return }
6351	func ( c * Consumer ) Start ( ) { if c . started { panic ( "(*Consumer).Start has already been called" ) } go c . run ( ) c . started = true }
6352	func RateLimit ( limit int , messages <- chan Message ) <- chan Message { if limit <= 0 { return messages } output := make ( chan Message ) go func ( ) { ticker := time . NewTicker ( 1 * time . Second ) defer ticker . Stop ( ) defer close ( output ) input := messages count := 0 for { select { case <- ticker . C : count = 0 input = messages case msg , ok := <- input : if ! ok { return } output <- msg if count ++ ; count >= limit { input = nil } } } } ( ) return output }
6353	func ( r RawResponse ) Write ( w * bufio . Writer ) error { return writeResponse ( w , [ ] byte ( r ) ) }
6354	func ReadResponse ( r * bufio . Reader ) ( res Response , err error ) { var data [ ] byte var size int32 if err = binary . Read ( r , binary . BigEndian , & size ) ; err != nil { return } data = make ( [ ] byte , int ( size ) ) if _ , err = io . ReadFull ( r , data ) ; err != nil { return } switch { case bytes . Equal ( data , [ ] byte ( "OK" ) ) : res = OK { } case bytes . HasPrefix ( data , [ ] byte ( "E_" ) ) : res = readError ( data ) default : res = RawResponse ( data ) } return }
6355	func backoff ( rand * rand . Rand , attempt int , min , max time . Duration ) time . Duration { if attempt <= 0 { panic ( "tube.Backoff: attempt <= 0" ) } if min > max { panic ( "tube.Backoff: min > max" ) } const coeff = 2.0 return jitteredBackoff ( rand , attempt , min , max , coeff ) }
6356	func ( t FrameType ) String ( ) string { switch t { case FrameTypeResponse : return "response" case FrameTypeError : return "error" case FrameTypeMessage : return "message" default : return "frame <" + strconv . Itoa ( int ( t ) ) + ">" } }
6357	func NewConsulEngine ( config ConsulConfig ) * ConsulEngine { if len ( config . Address ) == 0 { config . Address = DefaultConsulAddress } if len ( config . Namespace ) == 0 { config . Namespace = DefaultConsulNamespace } if config . NodeTimeout == 0 { config . NodeTimeout = DefaultLocalEngineNodeTimeout } if config . TombstoneTimeout == 0 { config . TombstoneTimeout = DefaultLocalEngineTombstoneTimeout } if ! strings . Contains ( config . Address , "://" ) { config . Address = "http://" + config . Address } return & ConsulEngine { client : http . Client { Transport : config . Transport } , address : config . Address , namespace : config . Namespace , nodeTimeout : config . NodeTimeout , tombTimeout : config . TombstoneTimeout , } }
6358	func ParseMessageID ( s string ) ( id MessageID , err error ) { var v uint64 v , err = strconv . ParseUint ( s , 16 , 64 ) id = MessageID ( v ) return }
6359	func ( id MessageID ) WriteTo ( w io . Writer ) ( int64 , error ) { a := [ 16 ] byte { } b := strconv . AppendUint ( a [ : 0 ] , uint64 ( id ) , 16 ) n := len ( a ) - len ( b ) copy ( a [ n : ] , b ) for i := 0 ; i != n ; i ++ { a [ i ] = '0' } c , e := w . Write ( a [ : ] ) return int64 ( c ) , e }
6360	func NewMessage ( id MessageID , body [ ] byte , cmdChan chan <- Command ) * Message { return & Message { ID : id , Body : body , cmdChan : cmdChan , } }
6361	func ( m * Message ) Finish ( ) { if m . Complete ( ) { panic ( "(*Message).Finish or (*Message).Requeue has already been called" ) } defer func ( ) { recover ( ) } ( ) m . cmdChan <- Fin { MessageID : m . ID } m . cmdChan = nil }
6362	func ( m * Message ) Requeue ( timeout time . Duration ) { if m . Complete ( ) { panic ( "(*Message).Finish or (*Message).Requeue has already been called" ) } defer func ( ) { recover ( ) } ( ) m . cmdChan <- Req { MessageID : m . ID , Timeout : timeout } m . cmdChan = nil }
6363	func ReadCommand ( r * bufio . Reader ) ( cmd Command , err error ) { var line string if line , err = r . ReadString ( '\n' ) ; err != nil { return } parts := strings . Split ( strings . TrimSpace ( line ) , " " ) if len ( parts ) == 0 { err = makeErrInvalid ( "invalid empty command" ) return } switch name , args := parts [ 0 ] , parts [ 1 : ] ; name { case "PING" : return readPing ( args ... ) case "IDENTIFY" : return readIdentify ( r , args ... ) case "REGISTER" : return readRegister ( args ... ) case "UNREGISTER" : return readUnregister ( args ... ) default : err = makeErrInvalid ( "invalid command %s" , name ) return } }
6364	func ( tmpl * Template ) funcMapMaker ( req * http . Request , writer http . ResponseWriter ) template . FuncMap { var funcMap = template . FuncMap { } for key , fc := range tmpl . render . funcMaps { funcMap [ key ] = fc } if tmpl . render . Config . FuncMapMaker != nil { for key , fc := range tmpl . render . Config . FuncMapMaker ( tmpl . render , req , writer ) { funcMap [ key ] = fc } } for key , fc := range tmpl . funcMap { funcMap [ key ] = fc } return funcMap }
6365	func ( tmpl * Template ) Funcs ( funcMap template . FuncMap ) * Template { tmpl . funcMap = funcMap return tmpl }
6366	func ( tmpl * Template ) Execute ( templateName string , obj interface { } , req * http . Request , w http . ResponseWriter ) error { result , err := tmpl . Render ( templateName , obj , req , w ) if err == nil { if w . Header ( ) . Get ( "Content-Type" ) == "" { w . Header ( ) . Set ( "Content-Type" , "text/html" ) } _ , err = w . Write ( [ ] byte ( result ) ) } return err }
6367	func ( fs * AssetFileSystem ) RegisterPath ( pth string ) error { if _ , err := os . Stat ( pth ) ; ! os . IsNotExist ( err ) { var existing bool for _ , p := range fs . paths { if p == pth { existing = true break } } if ! existing { fs . paths = append ( fs . paths , pth ) } return nil } return errors . New ( "not found" ) }
6368	func ( fs * AssetFileSystem ) Asset ( name string ) ( [ ] byte , error ) { for _ , pth := range fs . paths { if _ , err := os . Stat ( filepath . Join ( pth , name ) ) ; err == nil { return ioutil . ReadFile ( filepath . Join ( pth , name ) ) } } return [ ] byte { } , fmt . Errorf ( "%v not found" , name ) }
6369	func ( fs * AssetFileSystem ) Glob ( pattern string ) ( matches [ ] string , err error ) { for _ , pth := range fs . paths { if results , err := filepath . Glob ( filepath . Join ( pth , pattern ) ) ; err == nil { for _ , result := range results { matches = append ( matches , strings . TrimPrefix ( result , pth ) ) } } } return }
6370	func ( fs * AssetFileSystem ) NameSpace ( nameSpace string ) Interface { if fs . nameSpacedFS == nil { fs . nameSpacedFS = map [ string ] Interface { } } fs . nameSpacedFS [ nameSpace ] = & AssetFileSystem { } return fs . nameSpacedFS [ nameSpace ] }
6371	func New ( config * Config , viewPaths ... string ) * Render { if config == nil { config = & Config { } } if config . DefaultLayout == "" { config . DefaultLayout = DefaultLayout } if config . AssetFileSystem == nil { config . AssetFileSystem = assetfs . AssetFS ( ) . NameSpace ( "views" ) } config . ViewPaths = append ( append ( config . ViewPaths , viewPaths ... ) , DefaultViewPath ) render := & Render { funcMaps : map [ string ] interface { } { } , Config : config } for _ , viewPath := range config . ViewPaths { render . RegisterViewPath ( viewPath ) } return render }
6372	func ( render * Render ) RegisterViewPath ( paths ... string ) { for _ , pth := range paths { if filepath . IsAbs ( pth ) { render . ViewPaths = append ( render . ViewPaths , pth ) render . AssetFileSystem . RegisterPath ( pth ) } else { if absPath , err := filepath . Abs ( pth ) ; err == nil && isExistingDir ( absPath ) { render . ViewPaths = append ( render . ViewPaths , absPath ) render . AssetFileSystem . RegisterPath ( absPath ) } else if isExistingDir ( filepath . Join ( utils . AppRoot , "vendor" , pth ) ) { render . AssetFileSystem . RegisterPath ( filepath . Join ( utils . AppRoot , "vendor" , pth ) ) } else { for _ , gopath := range utils . GOPATH ( ) { if p := filepath . Join ( gopath , "src" , pth ) ; isExistingDir ( p ) { render . ViewPaths = append ( render . ViewPaths , p ) render . AssetFileSystem . RegisterPath ( p ) } } } } } }
6373	func ( render * Render ) SetAssetFS ( assetFS assetfs . Interface ) { for _ , viewPath := range render . ViewPaths { assetFS . RegisterPath ( viewPath ) } render . AssetFileSystem = assetFS }
6374	func ( render * Render ) Layout ( name string ) * Template { return & Template { render : render , layout : name } }
6375	func ( render * Render ) Funcs ( funcMap template . FuncMap ) * Template { tmpl := & Template { render : render , usingDefaultLayout : true } return tmpl . Funcs ( funcMap ) }
6376	func ( render * Render ) Execute ( name string , context interface { } , request * http . Request , writer http . ResponseWriter ) error { tmpl := & Template { render : render , usingDefaultLayout : true } return tmpl . Execute ( name , context , request , writer ) }
6377	func ( render * Render ) RegisterFuncMap ( name string , fc interface { } ) { if render . funcMaps == nil { render . funcMaps = template . FuncMap { } } render . funcMaps [ name ] = fc }
6378	func ( render * Render ) Asset ( name string ) ( [ ] byte , error ) { return render . AssetFileSystem . Asset ( name ) }
6379	func NewPlainClient ( identity , username , password string ) Client { return & plainClient { identity , username , password } }
6380	func Create ( url string , h http . Header , c * Config ) ( io . WriteCloser , error ) { if c == nil { c = DefaultConfig } return newUploader ( url , h , c ) }
6381	func Open ( url string , c * Config ) ( io . ReadCloser , error ) { if c == nil { c = DefaultConfig } r , _ := http . NewRequest ( "GET" , url , nil ) r . Header . Set ( "Date" , time . Now ( ) . UTC ( ) . Format ( http . TimeFormat ) ) c . Sign ( r , * c . Keys ) client := c . Client if client == nil { client = http . DefaultClient } resp , err := client . Do ( r ) if err != nil { return nil , err } if resp . StatusCode != 200 { return nil , newRespError ( resp ) } return resp . Body , nil }
6382	func Sign ( r * http . Request , k Keys ) { DefaultService . Sign ( r , k ) }
6383	func ( s * Service ) Sign ( r * http . Request , k Keys ) { if k . SecurityToken != "" { r . Header . Set ( "X-Amz-Security-Token" , k . SecurityToken ) } h := hmac . New ( sha1 . New , [ ] byte ( k . SecretKey ) ) s . writeSigData ( h , r ) sig := make ( [ ] byte , base64 . StdEncoding . EncodedLen ( h . Size ( ) ) ) base64 . StdEncoding . Encode ( sig , h . Sum ( nil ) ) r . Header . Set ( "Authorization" , "AWS " + k . AccessKey + ":" + string ( sig ) ) }
6384	func ( f * File ) Readdir ( n int ) ( [ ] os . FileInfo , error ) { if f . result != nil && ! f . result . IsTruncated { return make ( [ ] os . FileInfo , 0 ) , io . EOF } reader , err := f . sendRequest ( n ) if err != nil { return nil , err } defer reader . Close ( ) return f . parseResponse ( reader ) }
6385	func Find ( x tree . Node , p pathexpr . PathExpr ) [ ] tree . Node { ret := [ ] tree . Node { } if p . Axis == "" { findChild ( x , & p , & ret ) return ret } f := findMap [ p . Axis ] f ( x , & p , & ret ) return ret }
6386	func Lex ( xpath string ) chan XItem { l := & Lexer { input : xpath , items : make ( chan XItem ) , } go l . run ( ) return l . items }
6387	func MustParseXML ( r io . Reader , op ... ParseSettings ) tree . Node { ret , err := ParseXML ( r , op ... ) if err != nil { panic ( err ) } return ret }
6388	func ParseXML ( r io . Reader , op ... ParseSettings ) ( tree . Node , error ) { ov := ParseOptions { Strict : true , XMLRoot : xmlele . Root , } for _ , i := range op { i ( & ov ) } dec := xml . NewDecoder ( r ) dec . CharsetReader = charset . NewReaderLabel dec . Strict = ov . Strict ordrPos := 1 xmlTree := ov . XMLRoot ( ) t , err := dec . Token ( ) if err != nil { return nil , err } if head , ok := t . ( xml . ProcInst ) ; ok && head . Target == "xml" { t , err = dec . Token ( ) } opts := xmlbuilder . BuilderOpts { Dec : dec , } for err == nil { switch xt := t . ( type ) { case xml . StartElement : setEle ( & opts , xmlTree , xt , & ordrPos ) xmlTree = xmlTree . CreateNode ( & opts ) case xml . CharData : setNode ( & opts , xmlTree , xt , tree . NtChd , & ordrPos ) xmlTree = xmlTree . CreateNode ( & opts ) case xml . Comment : setNode ( & opts , xmlTree , xt , tree . NtComm , & ordrPos ) xmlTree = xmlTree . CreateNode ( & opts ) case xml . ProcInst : setNode ( & opts , xmlTree , xt , tree . NtPi , & ordrPos ) xmlTree = xmlTree . CreateNode ( & opts ) case xml . EndElement : xmlTree = xmlTree . EndElem ( ) case xml . Directive : if dp , ok := xmlTree . ( DirectiveParser ) ; ok { dp . Directive ( xt . Copy ( ) , dec ) } } t , err = dec . Token ( ) } if err == io . EOF { err = nil } return xmlTree , err }
6389	func ( w Wrap ) Call ( c Ctx , args ... Result ) ( Result , error ) { switch w . LastArgOpt { case Optional : if len ( args ) == w . NArgs || len ( args ) == w . NArgs - 1 { return w . Fn ( c , args ... ) } case Variadic : if len ( args ) >= w . NArgs - 1 { return w . Fn ( c , args ... ) } default : if len ( args ) == w . NArgs { return w . Fn ( c , args ... ) } } return nil , fmt . Errorf ( "Invalid number of arguments" ) }
6390	func Parse ( xp string ) ( XPathExec , error ) { n , err := parser . Parse ( xp ) return XPathExec { n : n } , err }
6391	func MustParse ( xp string ) XPathExec { ret , err := Parse ( xp ) if err != nil { panic ( err ) } return ret }
6392	func ( xp XPathExec ) Exec ( t tree . Node , opts ... FuncOpts ) ( tree . Result , error ) { o := & Opts { NS : make ( map [ string ] string ) , Funcs : make ( map [ xml . Name ] tree . Wrap ) , Vars : make ( map [ string ] tree . Result ) , } for _ , i := range opts { i ( o ) } return execxp . Exec ( xp . n , t , o . NS , o . Funcs , o . Vars ) }
6393	func ( xp XPathExec ) ExecBool ( t tree . Node , opts ... FuncOpts ) ( bool , error ) { res , err := xp . Exec ( t , opts ... ) if err != nil { return false , err } b , ok := res . ( tree . IsBool ) if ! ok { return false , fmt . Errorf ( "Cannot convert result to a boolean" ) } return bool ( b . Bool ( ) ) , nil }
6394	func ( xp XPathExec ) ExecNum ( t tree . Node , opts ... FuncOpts ) ( float64 , error ) { res , err := xp . Exec ( t , opts ... ) if err != nil { return 0 , err } n , ok := res . ( tree . IsNum ) if ! ok { return 0 , fmt . Errorf ( "Cannot convert result to a number" ) } return float64 ( n . Num ( ) ) , nil }
6395	func ( xp XPathExec ) ExecNode ( t tree . Node , opts ... FuncOpts ) ( tree . NodeSet , error ) { res , err := xp . Exec ( t , opts ... ) if err != nil { return nil , err } n , ok := res . ( tree . NodeSet ) if ! ok { return nil , fmt . Errorf ( "Cannot convert result to a node-set" ) } return n , nil }
6396	func ( xp XPathExec ) MustExec ( t tree . Node , opts ... FuncOpts ) tree . Result { res , err := xp . Exec ( t , opts ... ) if err != nil { panic ( err ) } return res }
6397	func ParseExec ( xpstr string , t tree . Node , opts ... FuncOpts ) ( tree . Result , error ) { xp , err := Parse ( xpstr ) if err != nil { return nil , err } return xp . Exec ( t , opts ... ) }
6398	func ( x * XMLEle ) CreateNode ( opts * xmlbuilder . BuilderOpts ) xmlbuilder . XMLBuilder { if opts . NodeType == tree . NtElem { ele := & XMLEle { StartElement : opts . Tok . ( xml . StartElement ) , NSBuilder : tree . NSBuilder { NS : opts . NS } , Attrs : make ( [ ] tree . Node , len ( opts . Attrs ) ) , Parent : x , NodePos : tree . NodePos ( opts . NodePos ) , NodeType : opts . NodeType , } for i := range opts . Attrs { ele . Attrs [ i ] = xmlnode . XMLNode { Token : opts . Attrs [ i ] , NodePos : tree . NodePos ( opts . AttrStartPos + i ) , NodeType : tree . NtAttr , Parent : ele , } } x . Children = append ( x . Children , ele ) return ele } node := xmlnode . XMLNode { Token : opts . Tok , NodePos : tree . NodePos ( opts . NodePos ) , NodeType : opts . NodeType , Parent : x , } x . Children = append ( x . Children , node ) return x }
6399	func ( x * XMLEle ) GetChildren ( ) [ ] tree . Node { ret := make ( [ ] tree . Node , len ( x . Children ) ) for i := range x . Children { ret [ i ] = x . Children [ i ] } return ret }
6400	func ( x * XMLEle ) GetAttrs ( ) [ ] tree . Node { ret := make ( [ ] tree . Node , len ( x . Attrs ) ) for i := range x . Attrs { ret [ i ] = x . Attrs [ i ] } return ret }
6401	func ( x * XMLEle ) ResValue ( ) string { ret := "" for i := range x . Children { switch x . Children [ i ] . GetNodeType ( ) { case tree . NtChd , tree . NtElem , tree . NtRoot : ret += x . Children [ i ] . ResValue ( ) } } return ret }
6402	func Parse ( xp string ) ( * Node , error ) { var err error c := lexer . Lex ( xp ) n := & Node { } p := & parseStack { cur : n } for next := range c { if next . Typ != lexer . XItemError { parseMap [ next . Typ ] ( p , next ) } else if err == nil { err = fmt . Errorf ( next . Val ) } } return n , err }
6403	func ( a XMLNode ) GetToken ( ) xml . Token { if a . NodeType == tree . NtAttr { ret := a . Token . ( * xml . Attr ) return * ret } return a . Token }
6404	func ( a XMLNode ) ResValue ( ) string { switch a . NodeType { case tree . NtAttr : return a . Token . ( * xml . Attr ) . Value case tree . NtChd : return string ( a . Token . ( xml . CharData ) ) case tree . NtComm : return string ( a . Token . ( xml . Comment ) ) } return string ( a . Token . ( xml . ProcInst ) . Inst ) }
6405	func Exec ( n * parser . Node , t tree . Node , ns map [ string ] string , fns map [ xml . Name ] tree . Wrap , v map [ string ] tree . Result ) ( tree . Result , error ) { f := xpFilt { t : t , ns : ns , ctx : tree . NodeSet { t } , fns : fns , variables : v , } return exec ( & f , n ) }
6406	func ( n Num ) String ( ) string { if math . IsInf ( float64 ( n ) , 0 ) { if math . IsInf ( float64 ( n ) , 1 ) { return "Infinity" } return "-Infinity" } return fmt . Sprintf ( "%g" , float64 ( n ) ) }
6407	func ( s String ) Num ( ) Num { num , err := strconv . ParseFloat ( strings . TrimSpace ( string ( s ) ) , 64 ) if err != nil { return Num ( math . NaN ( ) ) } return Num ( num ) }
6408	func BuildNS ( t Elem ) ( ret [ ] NS ) { vals := make ( map [ xml . Name ] string ) if nselem , ok := t . ( NSElem ) ; ok { buildNS ( nselem , vals ) ret = make ( [ ] NS , 0 , len ( vals ) ) i := 1 for k , v := range vals { if ! ( k . Local == "xmlns" && k . Space == "" && v == "" ) { ret = append ( ret , NS { Attr : xml . Attr { Name : k , Value : v } , Parent : t , NodeType : NtNs , } ) i ++ } } sort . Sort ( nsValueSort ( ret ) ) for i := range ret { ret [ i ] . NodePos = NodePos ( t . Pos ( ) + i + 1 ) } } return ret }
6409	func GetAttribute ( n Elem , local , space string ) ( xml . Attr , bool ) { attrs := n . GetAttrs ( ) for _ , i := range attrs { attr := i . GetToken ( ) . ( xml . Attr ) if local == attr . Name . Local && space == attr . Name . Space { return attr , true } } return xml . Attr { } , false }
6410	func GetAttributeVal ( n Elem , local , space string ) ( string , bool ) { attr , ok := GetAttribute ( n , local , space ) return attr . Value , ok }
6411	func GetAttrValOrEmpty ( n Elem , local , space string ) string { val , ok := GetAttributeVal ( n , local , space ) if ! ok { return "" } return val }
6412	func FindNodeByPos ( n Node , pos int ) Node { if n . Pos ( ) == pos { return n } if elem , ok := n . ( Elem ) ; ok { chldrn := elem . GetChildren ( ) for i := 1 ; i < len ( chldrn ) ; i ++ { if chldrn [ i - 1 ] . Pos ( ) <= pos && chldrn [ i ] . Pos ( ) > pos { return FindNodeByPos ( chldrn [ i - 1 ] , pos ) } } if len ( chldrn ) > 0 { if chldrn [ len ( chldrn ) - 1 ] . Pos ( ) <= pos { return FindNodeByPos ( chldrn [ len ( chldrn ) - 1 ] , pos ) } } attrs := elem . GetAttrs ( ) for _ , i := range attrs { if i . Pos ( ) == pos { return i } } ns := BuildNS ( elem ) for _ , i := range ns { if i . Pos ( ) == pos { return i } } } return nil }
6413	func Marshal ( n tree . Node , w io . Writer ) error { return marshal ( n , w ) }
6414	func MarshalStr ( n tree . Node ) ( string , error ) { ret := bytes . NewBufferString ( "" ) err := marshal ( n , ret ) return ret . String ( ) , err }
6415	func NewLexer ( r io . Reader , posix , whitespacesplit bool ) * Lexer { return & Lexer { reader : bufio . NewReader ( r ) , tokenizer : & DefaultTokenizer { } , posix : posix , whitespacesplit : whitespacesplit , } }
6416	func NewLexerString ( s string , posix , whitespacesplit bool ) * Lexer { return NewLexer ( strings . NewReader ( s ) , posix , whitespacesplit ) }
6417	func Split ( s string , posix bool ) ( [ ] string , error ) { return NewLexerString ( s , posix , true ) . Split ( ) }
6418	func ( r * registry ) Register ( err * ErrDescriptor ) { r . Lock ( ) defer r . Unlock ( ) if err . Code == NoCode { panic ( fmt . Errorf ( "No code defined in error descriptor (message: `%s`)" , err . MessageFormat ) ) } if r . byCode [ err . Code ] != nil { panic ( fmt . Errorf ( "errors: Duplicate error code %v registered" , err . Code ) ) } err . registered = true r . byCode [ err . Code ] = err }
6419	func ( r * registry ) Get ( code Code ) * ErrDescriptor { r . RLock ( ) defer r . RUnlock ( ) return r . byCode [ code ] }
6420	func ( r * registry ) GetAll ( ) [ ] * ErrDescriptor { r . RLock ( ) defer r . RUnlock ( ) res := make ( [ ] * ErrDescriptor , 0 , len ( r . byCode ) ) for _ , d := range r . byCode { res = append ( res , d ) } return res }
6421	func From ( in error ) Error { if err , ok := in . ( Error ) ; ok { return err } return FromGRPC ( in ) }
6422	func Descriptor ( in error ) ( desc * ErrDescriptor ) { err := From ( in ) descriptor := Get ( err . Code ( ) ) if descriptor != nil { return descriptor } return & ErrDescriptor { MessageFormat : err . Error ( ) , Type : err . Type ( ) , Code : err . Code ( ) , } }
6423	func GetAttributes ( err error ) Attributes { e , ok := err . ( Error ) if ok { return e . Attributes ( ) } return Attributes { } }
6424	func ( t Type ) HTTPStatusCode ( ) int { switch t { case Canceled : return http . StatusRequestTimeout case InvalidArgument : return http . StatusBadRequest case OutOfRange : return http . StatusBadRequest case NotFound : return http . StatusNotFound case Conflict : return http . StatusConflict case AlreadyExists : return http . StatusConflict case Unauthorized : return http . StatusUnauthorized case PermissionDenied : return http . StatusForbidden case Timeout : return http . StatusRequestTimeout case NotImplemented : return http . StatusNotImplemented case TemporarilyUnavailable : return http . StatusBadGateway case PermanentlyUnavailable : return http . StatusGone case ResourceExhausted : return http . StatusForbidden case Internal : return http . StatusInternalServerError case Unknown : return http . StatusInternalServerError } return http . StatusInternalServerError }
6425	func HTTPStatusCode ( err error ) int { e , ok := err . ( Error ) if ok { return e . Type ( ) . HTTPStatusCode ( ) } return http . StatusInternalServerError }
6426	func HTTPStatusToType ( status int ) Type { switch status { case http . StatusBadRequest : return InvalidArgument case http . StatusNotFound : return NotFound case http . StatusConflict : return Conflict case http . StatusUnauthorized : return Unauthorized case http . StatusForbidden : return PermissionDenied case http . StatusRequestTimeout : return Timeout case http . StatusNotImplemented : return NotImplemented case http . StatusBadGateway : case http . StatusServiceUnavailable : return TemporarilyUnavailable case http . StatusGone : return PermanentlyUnavailable case http . StatusTooManyRequests : return ResourceExhausted case http . StatusInternalServerError : return Unknown } return Unknown }
6427	func ToHTTP ( in error , w http . ResponseWriter ) error { w . Header ( ) . Set ( "Content-Type" , "application/json" ) if err , ok := in . ( Error ) ; ok { w . Header ( ) . Set ( CodeHeader , err . Code ( ) . String ( ) ) w . WriteHeader ( err . Type ( ) . HTTPStatusCode ( ) ) return json . NewEncoder ( w ) . Encode ( toJSON ( err ) ) } w . WriteHeader ( http . StatusInternalServerError ) return json . NewEncoder ( w ) . Encode ( & jsonError { Message : in . Error ( ) , Type : Unknown , } ) }
6428	func toImpl ( err Error ) * impl { if i , ok := err . ( * impl ) ; ok { return i } return & impl { message : err . Error ( ) , code : err . Code ( ) , typ : err . Type ( ) , attributes : err . Attributes ( ) , } }
6429	func MetadataFromIncomingContext ( ctx context . Context ) metadata . MD { md , _ := metadata . FromIncomingContext ( ctx ) return md }
6430	func MetadataFromOutgoingContext ( ctx context . Context ) metadata . MD { md , _ := metadata . FromOutgoingContext ( ctx ) return md }
6431	func TokenFromMetadata ( md metadata . MD ) ( string , error ) { token , ok := md [ "token" ] if ! ok || len ( token ) == 0 { return "" , ErrNoToken } return token [ 0 ] , nil }
6432	func TokenFromIncomingContext ( ctx context . Context ) ( string , error ) { md := MetadataFromIncomingContext ( ctx ) return TokenFromMetadata ( md ) }
6433	func OutgoingContextWithToken ( ctx context . Context , token string ) context . Context { return outgoingContextWithMergedMetadata ( ctx , "token" , token ) }
6434	func KeyFromMetadata ( md metadata . MD ) ( string , error ) { key , ok := md [ "key" ] if ! ok || len ( key ) == 0 { return "" , ErrNoKey } return key [ 0 ] , nil }
6435	func KeyFromIncomingContext ( ctx context . Context ) ( string , error ) { md := MetadataFromIncomingContext ( ctx ) return KeyFromMetadata ( md ) }
6436	func OutgoingContextWithKey ( ctx context . Context , key string ) context . Context { return outgoingContextWithMergedMetadata ( ctx , "key" , key ) }
6437	func IDFromMetadata ( md metadata . MD ) ( string , error ) { id , ok := md [ "id" ] if ! ok || len ( id ) == 0 { return "" , ErrNoID } return id [ 0 ] , nil }
6438	func IDFromIncomingContext ( ctx context . Context ) ( string , error ) { md := MetadataFromIncomingContext ( ctx ) return IDFromMetadata ( md ) }
6439	func OutgoingContextWithID ( ctx context . Context , id string ) context . Context { return outgoingContextWithMergedMetadata ( ctx , "id" , id ) }
6440	func ServiceInfoFromMetadata ( md metadata . MD ) ( serviceName , serviceVersion , netAddress string , err error ) { serviceNameL , ok := md [ "service-name" ] if ok && len ( serviceNameL ) > 0 { serviceName = serviceNameL [ 0 ] } serviceVersionL , ok := md [ "service-version" ] if ok && len ( serviceVersionL ) > 0 { serviceVersion = serviceVersionL [ 0 ] } netAddressL , ok := md [ "net-address" ] if ok && len ( netAddressL ) > 0 { netAddress = netAddressL [ 0 ] } return }
6441	func ServiceInfoFromIncomingContext ( ctx context . Context ) ( serviceName , serviceVersion , netAddress string , err error ) { md := MetadataFromIncomingContext ( ctx ) return ServiceInfoFromMetadata ( md ) }
6442	func OutgoingContextWithServiceInfo ( ctx context . Context , serviceName , serviceVersion , netAddress string ) context . Context { return outgoingContextWithMergedMetadata ( ctx , "service-name" , serviceName , "service-version" , serviceVersion , "net-address" , netAddress ) }
6443	func LimitFromMetadata ( md metadata . MD ) ( uint64 , error ) { limit , ok := md [ "limit" ] if ! ok || len ( limit ) == 0 { return 0 , nil } return strconv . ParseUint ( limit [ 0 ] , 10 , 64 ) }
6444	func OffsetFromMetadata ( md metadata . MD ) ( uint64 , error ) { offset , ok := md [ "offset" ] if ! ok || len ( offset ) == 0 { return 0 , nil } return strconv . ParseUint ( offset [ 0 ] , 10 , 64 ) }
6445	func LimitAndOffsetFromIncomingContext ( ctx context . Context ) ( limit , offset uint64 , err error ) { md := MetadataFromIncomingContext ( ctx ) limit , err = LimitFromMetadata ( md ) if err != nil { return 0 , 0 , err } offset , err = OffsetFromMetadata ( md ) if err != nil { return 0 , 0 , err } return limit , offset , nil }
6446	func OutgoingContextWithLimitAndOffset ( ctx context . Context , limit , offset uint64 ) context . Context { var pairs [ ] string if limit != 0 { pairs = append ( pairs , "limit" , strconv . FormatUint ( limit , 10 ) ) } if offset != 0 { pairs = append ( pairs , "offset" , strconv . FormatUint ( offset , 10 ) ) } if len ( pairs ) == 0 { return ctx } return outgoingContextWithMergedMetadata ( ctx , pairs ... ) }
6447	func before ( i , j ScheduleItem ) bool { iEnd := i . Time ( ) . UnixNano ( ) + i . Duration ( ) . Nanoseconds ( ) jStart := j . Time ( ) . UnixNano ( ) if i , ok := i . ( ScheduleItemWithTimestamp ) ; ok { if j , ok := j . ( ScheduleItemWithTimestamp ) ; ok { iEnd = i . Timestamp ( ) + i . Duration ( ) . Nanoseconds ( ) jStart = j . Timestamp ( ) } } return iEnd < jStart }
6448	func ( err * ErrDescriptor ) New ( attributes Attributes ) Error { if err . Code != NoCode && ! err . registered { panic ( fmt . Errorf ( "Error descriptor with code %v was not registered" , err . Code ) ) } return & impl { message : Format ( err . MessageFormat , attributes ) , code : err . Code , typ : err . Type , attributes : attributes , } }
6449	func WithNamespace ( namespace string , ctx log . Interface ) log . Interface { return ctx . WithField ( NamespaceKey , namespace ) }
6450	func Wrap ( ctx log . Interface , namespaces ... string ) * Namespaced { return & Namespaced { Interface : ctx , namespaces : & ns { namespaces : namespaces , } , } }
6451	func ( n * Namespaced ) WithField ( k string , v interface { } ) log . Interface { if k == NamespaceKey { if str , ok := v . ( string ) ; ok { return & Namespaced { Interface : n . Interface , namespaces : n . namespaces , namespace : str , } } } return & Namespaced { Interface : n . Interface . WithField ( k , v ) , namespaces : n . namespaces , namespace : n . namespace , } }
6452	func ( n * Namespaced ) WithFields ( fields log . Fields ) log . Interface { return & Namespaced { Interface : n . Interface . WithFields ( fields ) , namespaces : n . namespaces , namespace : n . namespace , } }
6453	func Format ( format string , values Attributes ) string { formatter , err := messageformat . New ( ) if err != nil { return format } fm , err := formatter . Parse ( format ) if err != nil { return format } fixed := make ( map [ string ] interface { } , len ( values ) ) for k , v := range values { fixed [ k ] = fix ( v ) } res , err := fm . FormatMap ( fixed ) if err != nil { fmt . Println ( "err" , err ) return format } return res }
6454	func fix ( v interface { } ) interface { } { if v == nil { return "<nil>" } switch reflect . TypeOf ( v ) . Kind ( ) { case reflect . Bool : case reflect . Int : case reflect . Int8 : case reflect . Int16 : case reflect . Int32 : case reflect . Int64 : case reflect . Uint : case reflect . Uint8 : case reflect . Uint16 : case reflect . Uint32 : case reflect . Uint64 : case reflect . Uintptr : case reflect . Float32 : case reflect . Float64 : return v case reflect . Ptr : return fix ( reflect . ValueOf ( v ) . Elem ( ) ) } return fmt . Sprintf ( "%v" , v ) }
6455	func ( t Type ) GRPCCode ( ) codes . Code { switch t { case InvalidArgument : return codes . InvalidArgument case OutOfRange : return codes . OutOfRange case NotFound : return codes . NotFound case Conflict : case AlreadyExists : return codes . AlreadyExists case Unauthorized : return codes . Unauthenticated case PermissionDenied : return codes . PermissionDenied case Timeout : return codes . DeadlineExceeded case NotImplemented : return codes . Unimplemented case TemporarilyUnavailable : return codes . Unavailable case PermanentlyUnavailable : return codes . FailedPrecondition case Canceled : return codes . Canceled case ResourceExhausted : return codes . ResourceExhausted case Internal : case Unknown : return codes . Unknown } return codes . Unknown }
6456	func GRPCCodeToType ( code codes . Code ) Type { switch code { case codes . InvalidArgument : return InvalidArgument case codes . OutOfRange : return OutOfRange case codes . NotFound : return NotFound case codes . AlreadyExists : return AlreadyExists case codes . Unauthenticated : return Unauthorized case codes . PermissionDenied : return PermissionDenied case codes . DeadlineExceeded : return Timeout case codes . Unimplemented : return NotImplemented case codes . Unavailable : return TemporarilyUnavailable case codes . FailedPrecondition : return PermanentlyUnavailable case codes . Canceled : return Canceled case codes . ResourceExhausted : return ResourceExhausted case codes . Unknown : return Unknown } return Unknown }
6457	func GRPCCode ( err error ) codes . Code { e , ok := err . ( Error ) if ok { return e . Type ( ) . GRPCCode ( ) } return grpc . Code ( err ) }
6458	func FromGRPC ( in error ) Error { out := & impl { message : grpc . ErrorDesc ( in ) , typ : GRPCCodeToType ( grpc . Code ( in ) ) , code : NoCode , } matches := grpcMessageFormat . FindStringSubmatch ( in . Error ( ) ) if len ( matches ) < 4 { return out } out . message = matches [ 1 ] out . code = parseCode ( matches [ 2 ] ) _ = json . Unmarshal ( [ ] byte ( matches [ 3 ] ) , & out . attributes ) got := Get ( Code ( out . code ) ) if got == nil { return out } return got . New ( out . attributes ) }
6459	func ToGRPC ( in error ) error { if err , ok := in . ( Error ) ; ok { attrs , _ := json . Marshal ( err . Attributes ( ) ) return grpc . Errorf ( err . Type ( ) . GRPCCode ( ) , format , err . Error ( ) , err . Code ( ) , attrs ) } return grpc . Errorf ( codes . Unknown , in . Error ( ) ) }
6460	func ( n * ns ) IsEnabled ( namespace string ) bool { n . RLock ( ) defer n . RUnlock ( ) if namespace == "" { return true } hasStar := false included := false for _ , ns := range n . namespaces { if ns == negate ( namespace ) { return false } if ns == namespace { included = true } if ns == "*" { hasStar = true } } return hasStar || included }
6461	func ( n * ns ) Set ( namespaces [ ] string ) { n . Lock ( ) defer n . Unlock ( ) n . namespaces = namespaces }
6462	func Cause ( err Error ) error { attributes := err . Attributes ( ) if attributes == nil { return nil } cause , ok := attributes [ causeKey ] if ! ok { return nil } switch v := cause . ( type ) { case error : return v case string : return errors . New ( v ) default : return nil } }
6463	func parseCode ( str string ) Code { code , err := strconv . Atoi ( str ) if err != nil { return Code ( 0 ) } return Code ( code ) }
6464	func UnaryServerInterceptor ( fn ConvertFunc ) grpc . UnaryServerInterceptor { return func ( ctx context . Context , req interface { } , info * grpc . UnaryServerInfo , handler grpc . UnaryHandler ) ( resp interface { } , err error ) { resp , err = handler ( ctx , req ) return resp , fn ( err ) } }
6465	func StreamServerInterceptor ( fn ConvertFunc ) grpc . StreamServerInterceptor { return func ( srv interface { } , ss grpc . ServerStream , info * grpc . StreamServerInfo , handler grpc . StreamHandler ) ( err error ) { return fn ( handler ( srv , ss ) ) } }
6466	func UnaryClientInterceptor ( fn ConvertFunc ) grpc . UnaryClientInterceptor { return func ( ctx context . Context , method string , req , reply interface { } , cc * grpc . ClientConn , invoker grpc . UnaryInvoker , opts ... grpc . CallOption ) ( err error ) { return fn ( invoker ( ctx , method , req , reply , cc , opts ... ) ) } }
6467	func StreamClientInterceptor ( fn ConvertFunc ) grpc . StreamClientInterceptor { return func ( ctx context . Context , desc * grpc . StreamDesc , cc * grpc . ClientConn , method string , streamer grpc . Streamer , opts ... grpc . CallOption ) ( stream grpc . ClientStream , err error ) { stream , err = streamer ( ctx , desc , cc , method , opts ... ) return stream , fn ( err ) } }
6468	func Interceptor ( settings Settings ) grpc . StreamClientInterceptor { return func ( ctx context . Context , desc * grpc . StreamDesc , cc * grpc . ClientConn , method string , streamer grpc . Streamer , opts ... grpc . CallOption ) ( stream grpc . ClientStream , err error ) { s := & restartingStream { log : log . Get ( ) . WithField ( "method" , method ) , ctx : ctx , desc : desc , cc : cc , method : method , streamer : streamer , opts : opts , retryableCodes : settings . RetryableCodes , backoff : settings . Backoff , retries : - 1 , } err = s . start ( ) stream = s return } }
6469	func Wrap ( logger * logrus . Logger ) log . Interface { return & logrusEntryWrapper { logrus . NewEntry ( logger ) } }
6470	func NewCounter ( bucketSize , retention time . Duration ) Counter { return & counter { bucketSize : bucketSize , retention : retention , buckets : make ( [ ] uint64 , 2 * retention / bucketSize ) , } }
6471	func NewRedisCounter ( client * redis . Client , key string , bucketSize , retention time . Duration ) Counter { return & redisCounter { client : client , key : key , bucketSize : bucketSize , retention : retention , } }
6472	func NewLimiter ( counter Counter , duration time . Duration , limit uint64 ) Limiter { return & limiter { Counter : counter , duration : duration , limit : limit , } }
6473	func ( c * TokenCredentials ) WithInsecure ( ) * TokenCredentials { return & TokenCredentials { token : c . token , tokenFunc : c . tokenFunc , allowInsecure : true } }
6474	func WithTokenFunc ( k string , tokenFunc func ( v string ) string ) * TokenCredentials { return & TokenCredentials { tokenFunc : tokenFunc , tokenFuncKey : k , } }
6475	func ( c * TokenCredentials ) GetRequestMetadata ( ctx context . Context , uri ... string ) ( map [ string ] string , error ) { md := ttnctx . MetadataFromOutgoingContext ( ctx ) token , _ := ttnctx . TokenFromMetadata ( md ) if token != "" { return map [ string ] string { tokenKey : token } , nil } if c . tokenFunc != nil { var k string if v , ok := md [ c . tokenFuncKey ] ; ok && len ( v ) > 0 { k = v [ 0 ] } return map [ string ] string { tokenKey : c . tokenFunc ( k ) } , nil } if c . token != "" { return map [ string ] string { tokenKey : c . token } , nil } return map [ string ] string { tokenKey : "" } , nil }
6476	func FieldsFromIncomingContext ( ctx context . Context ) ttnlog . Fields { fields := make ( fieldMap ) if peer , ok := peer . FromContext ( ctx ) ; ok { fields . addFromPeer ( peer ) } if md , ok := metadata . FromIncomingContext ( ctx ) ; ok { fields . addFromMD ( md ) } return fields . LogFields ( ) }
6477	func ( t Type ) String ( ) string { switch t { case Unknown : return "Unknown" case Internal : return "Internal" case InvalidArgument : return "Invalid argument" case OutOfRange : return "Out of range" case NotFound : return "Not found" case Conflict : return "Conflict" case AlreadyExists : return "Already exists" case Unauthorized : return "Unauthorized" case PermissionDenied : return "Permission denied" case Timeout : return "Timeout" case NotImplemented : return "Not implemented" case TemporarilyUnavailable : return "Temporarily unavailable" case PermanentlyUnavailable : return "Permanently unavailable" case Canceled : return "Canceled" case ResourceExhausted : return "Resource exhausted" default : return "Unknown" } }
6478	func ( t * Type ) UnmarshalText ( text [ ] byte ) error { e , err := fromString ( string ( text ) ) if err != nil { return err } * t = e return nil }
6479	func fromString ( str string ) ( Type , error ) { enum := strings . ToLower ( str ) switch enum { case "unknown" : return Unknown , nil case "internal" : return Internal , nil case "invalid argument" : return InvalidArgument , nil case "out of range" : return OutOfRange , nil case "not found" : return NotFound , nil case "conflict" : return Conflict , nil case "already exists" : return AlreadyExists , nil case "unauthorized" : return Unauthorized , nil case "permission denied" : return PermissionDenied , nil case "timeout" : return Timeout , nil case "not implemented" : return NotImplemented , nil case "temporarily unavailable" : return TemporarilyUnavailable , nil case "permanently unavailable" : return PermanentlyUnavailable , nil case "canceled" : return Canceled , nil case "resource exhausted" : return ResourceExhausted , nil default : return Unknown , fmt . Errorf ( "Invalid error type" ) } }
6480	func Start ( ctx log . Interface , interval time . Duration ) { ctx . WithField ( "interval" , interval ) . Debug ( "starting stats loop" ) go func ( ) { memstats := new ( runtime . MemStats ) for range time . Tick ( interval ) { runtime . ReadMemStats ( memstats ) ctx . WithFields ( log . Fields { "goroutines" : runtime . NumGoroutine ( ) , "memory" : float64 ( memstats . Alloc ) / megaByte , } ) . Debugf ( "memory stats" ) } } ( ) }
6481	func NewSimple ( ) Simple { q := & simpleQueue { queue : make ( [ ] interface { } , 0 ) , } q . available = sync . NewCond ( & q . mu ) return q }
6482	func Wrap ( logger log . Interface , filters ... Filter ) * Filtered { return & Filtered { Interface : logger , filters : filters , } }
6483	func ( f * Filtered ) WithFilters ( filters ... Filter ) * Filtered { return & Filtered { Interface : f . Interface , filters : append ( f . filters , filters ... ) , } }
6484	func ( f * Filtered ) WithField ( k string , v interface { } ) log . Interface { val := v for _ , filter := range f . filters { val = filter . Filter ( k , val ) } return & Filtered { Interface : f . Interface . WithField ( k , val ) , filters : f . filters , } }
6485	func ( f * Filtered ) WithFields ( fields log . Fields ) log . Interface { res := make ( map [ string ] interface { } , len ( fields ) ) for k , v := range fields { val := v for _ , filter := range f . filters { val = filter . Filter ( k , val ) } res [ k ] = val } return & Filtered { Interface : f . Interface . WithFields ( res ) , filters : f . filters , } }
6486	func FilterSensitive ( sensitive [ ] string , elided interface { } ) Filter { return FilterFunc ( func ( key string , v interface { } ) interface { } { lower := strings . ToLower ( key ) for _ , s := range sensitive { if lower == s { return elided } } return v } ) }
6487	func SliceFilter ( filter Filter ) Filter { return FilterFunc ( func ( k string , v interface { } ) interface { } { r := reflect . ValueOf ( v ) if r . Kind ( ) == reflect . Slice { res := make ( [ ] interface { } , 0 , r . Len ( ) ) for i := 0 ; i < r . Len ( ) ; i ++ { el := r . Index ( i ) . Interface ( ) res = append ( res , filter . Filter ( k , el ) ) } return res } return filter . Filter ( k , v ) } ) }
6488	func MapFilter ( filter Filter ) Filter { return FilterFunc ( func ( k string , v interface { } ) interface { } { r := reflect . ValueOf ( v ) if r . Kind ( ) == reflect . Map { res := make ( map [ string ] interface { } , r . Len ( ) ) for _ , key := range r . MapKeys ( ) { str := key . String ( ) val := r . MapIndex ( key ) . Interface ( ) res [ str ] = filter . Filter ( str , val ) } return res } return v } ) }
6489	func RestrictFilter ( fieldName string , filter Filter ) Filter { return FilterFunc ( func ( k string , v interface { } ) interface { } { if fieldName == k { return filter . Filter ( k , v ) } return v } ) }
6490	func LowerCaseFilter ( filter Filter ) Filter { return FilterFunc ( func ( k string , v interface { } ) interface { } { return filter . Filter ( strings . ToLower ( k ) , v ) } ) }
6491	func newBatchPoints ( bpConf influxdb . BatchPointsConfig ) influxdb . BatchPoints { bp , err := influxdb . NewBatchPoints ( bpConf ) if err != nil { panic ( fmt . Errorf ( "Invalid batch point configuration: %s" , err ) ) } return bp }
6492	func NewSinglePointWriter ( log ttnlog . Interface , w BatchPointsWriter ) * SinglePointWriter { return & SinglePointWriter { log : log , writer : w , } }
6493	func ( w * SinglePointWriter ) Write ( bpConf influxdb . BatchPointsConfig , p * influxdb . Point ) error { bp := newBatchPoints ( bpConf ) bp . AddPoint ( p ) return w . writer . Write ( bp ) }
6494	func WithScalingInterval ( v time . Duration ) BatchingWriterOption { return func ( w * BatchingWriter ) { w . scalingInterval = v } }
6495	func NewBatchingWriter ( log ttnlog . Interface , w BatchPointsWriter , opts ... BatchingWriterOption ) * BatchingWriter { bw := & BatchingWriter { log : log , writer : w , scalingInterval : DefaultScalingInterval , limit : DefaultInstanceLimit , pointChans : make ( map [ influxdb . BatchPointsConfig ] chan * batchPoint ) , } for _ , opt := range opts { opt ( bw ) } bw . log = bw . log . WithFields ( ttnlog . Fields { "limit" : bw . limit , "scalingInterval" : bw . scalingInterval , } ) return bw }
6496	func ( w * BatchingWriter ) Write ( bpConf influxdb . BatchPointsConfig , p * influxdb . Point ) error { log := w . log . WithField ( "config" , bpConf ) w . pointChanMutex . RLock ( ) ch , ok := w . pointChans [ bpConf ] w . pointChanMutex . RUnlock ( ) if ! ok { w . pointChanMutex . Lock ( ) ch , ok = w . pointChans [ bpConf ] if ! ok { w . mutex . Lock ( ) w . active ++ w . limit ++ w . mutex . Unlock ( ) ch = make ( chan * batchPoint ) w . pointChans [ bpConf ] = ch go writeInBatches ( log , w . writer , bpConf , w . scalingInterval , ch , true ) } w . pointChanMutex . Unlock ( ) } point := & batchPoint { Point : p , errch : make ( chan error , 1 ) , } select { case ch <- point : case <- time . After ( w . scalingInterval ) : w . mutex . Lock ( ) if w . active < w . limit { w . active ++ go writeInBatches ( w . log , w . writer , bpConf , w . scalingInterval , ch , false ) } w . mutex . Unlock ( ) ch <- point } return <- point . errch }
6497	func ( w * apexInterfaceWrapper ) MustParseLevel ( s string ) { level , err := ParseLevel ( s ) if err != nil { w . WithError ( err ) . WithField ( "level" , s ) . Fatal ( "Could not parse log level" ) } w . Level = level }
6498	func New ( bufferSize int , setup func ( ) ( grpc . ClientStream , error ) ) * Stream { return & Stream { setupFunc : setup , sendBuffer : make ( chan interface { } , bufferSize ) , log : ttnlog . Get ( ) , } }
6499	func ( s * Stream ) SetLogger ( log ttnlog . Interface ) { s . mu . Lock ( ) s . log = log s . mu . Unlock ( ) }
6500	func ( s * Stream ) CloseRecv ( ) { s . mu . Lock ( ) if s . recvBuffer != nil { close ( s . recvBuffer ) s . recvBuffer = nil } s . mu . Unlock ( ) }
6501	func ( s * Stream ) Stats ( ) ( sent , dropped uint64 ) { return atomic . LoadUint64 ( & s . sent ) , atomic . LoadUint64 ( & s . dropped ) }
6502	func ( s * Stream ) Run ( ) ( err error ) { s . mu . RLock ( ) defer s . mu . RUnlock ( ) defer func ( ) { if err != nil { if grpc . Code ( err ) == codes . Canceled { s . log . Debug ( "streambuffer: context canceled" ) err = context . Canceled return } if grpc . Code ( err ) == codes . DeadlineExceeded { s . log . Debug ( "streambuffer: context deadline exceeded" ) err = context . DeadlineExceeded return } } } ( ) stream , err := s . setupFunc ( ) if err != nil { s . log . WithError ( err ) . Debug ( "streambuffer: setup returned error" ) return err } recvErr := make ( chan error ) defer func ( ) { go func ( ) { <- recvErr } ( ) } ( ) go func ( ) { for { var r interface { } if s . recvFunc != nil { r = s . recvFunc ( ) } else { r = new ( empty . Empty ) } err := stream . RecvMsg ( r ) if err != nil { s . log . WithError ( err ) . Debug ( "streambuffer: error from stream.RecvMsg" ) recvErr <- err close ( recvErr ) return } if s . recvFunc != nil { s . recvMsg ( r ) } } } ( ) defer stream . CloseSend ( ) for { select { case err := <- recvErr : return err case <- stream . Context ( ) . Done ( ) : s . log . WithError ( stream . Context ( ) . Err ( ) ) . Debug ( "streambuffer: context done" ) return stream . Context ( ) . Err ( ) case msg := <- s . sendBuffer : if err = stream . SendMsg ( msg ) ; err != nil { s . log . WithError ( err ) . Debug ( "streambuffer: error from stream.SendMsg" ) return err } atomic . AddUint64 ( & s . sent , 1 ) } } }
6503	func ServerOptions ( log ttnlog . Interface ) [ ] grpc . ServerOption { return [ ] grpc . ServerOption { grpc . UnaryInterceptor ( UnaryServerInterceptor ( log ) ) , grpc . StreamInterceptor ( StreamServerInterceptor ( log ) ) , } }
6504	func ClientOptions ( log ttnlog . Interface ) [ ] grpc . DialOption { return [ ] grpc . DialOption { grpc . WithUnaryInterceptor ( UnaryClientInterceptor ( log ) ) , grpc . WithStreamInterceptor ( StreamClientInterceptor ( log ) ) , } }
6505	func UnaryServerInterceptor ( log ttnlog . Interface ) grpc . UnaryServerInterceptor { return func ( ctx context . Context , req interface { } , info * grpc . UnaryServerInfo , handler grpc . UnaryHandler ) ( resp interface { } , err error ) { log := getLog ( log ) . WithField ( "method" , info . FullMethod ) log = log . WithFields ( FieldsFromIncomingContext ( ctx ) ) start := time . Now ( ) resp , err = handler ( ctx , req ) log = log . WithField ( "duration" , time . Since ( start ) ) if err != nil { log . WithError ( err ) . Debug ( "rpc-server: call failed" ) return } log . Debug ( "rpc-server: call done" ) return } }
6506	func StreamServerInterceptor ( log ttnlog . Interface ) grpc . StreamServerInterceptor { return func ( srv interface { } , ss grpc . ServerStream , info * grpc . StreamServerInfo , handler grpc . StreamHandler ) ( err error ) { log := getLog ( log ) . WithField ( "method" , info . FullMethod ) log = log . WithFields ( FieldsFromIncomingContext ( ss . Context ( ) ) ) start := time . Now ( ) log . Debug ( "rpc-server: stream starting" ) err = handler ( srv , ss ) log = log . WithField ( "duration" , time . Since ( start ) ) if err != nil { if err == context . Canceled || grpc . Code ( err ) == codes . Canceled { log . Debug ( "rpc-server: stream canceled" ) return } log . WithError ( err ) . Debug ( "rpc-server: stream failed" ) return } log . Debug ( "rpc-server: stream done" ) return } }
6507	func UnaryClientInterceptor ( log ttnlog . Interface ) grpc . UnaryClientInterceptor { return func ( ctx context . Context , method string , req , reply interface { } , cc * grpc . ClientConn , invoker grpc . UnaryInvoker , opts ... grpc . CallOption ) ( err error ) { log := getLog ( log ) . WithField ( "method" , method ) log = log . WithFields ( FieldsFromOutgoingContext ( ctx ) ) start := time . Now ( ) err = invoker ( ctx , method , req , reply , cc , opts ... ) log = log . WithField ( "duration" , time . Since ( start ) ) if err != nil { log . WithError ( err ) . Debug ( "rpc-client: call failed" ) return } log . Debug ( "rpc-client: call done" ) return } }
6508	func StreamClientInterceptor ( log ttnlog . Interface ) grpc . StreamClientInterceptor { return func ( ctx context . Context , desc * grpc . StreamDesc , cc * grpc . ClientConn , method string , streamer grpc . Streamer , opts ... grpc . CallOption ) ( stream grpc . ClientStream , err error ) { log := getLog ( log ) . WithField ( "method" , method ) log = log . WithFields ( FieldsFromOutgoingContext ( ctx ) ) log . Debug ( "rpc-client: stream starting" ) stream , err = streamer ( ctx , desc , cc , method , opts ... ) if err != nil { if err == context . Canceled || grpc . Code ( err ) == codes . Canceled { log . Debug ( "rpc-client: stream canceled" ) return } log . WithError ( err ) . Debug ( "rpc-client: stream failed" ) return } go func ( ) { <- stream . Context ( ) . Done ( ) if err := stream . Context ( ) . Err ( ) ; err != nil { log = log . WithError ( err ) } log . Debug ( "rpc-client: stream done" ) } ( ) return } }
6509	func ( c * Config ) defaults ( ) { if c . BufferSize == 0 { c . BufferSize = 100 } if c . Prefix == "" { c . Prefix = "logs" } }
6510	func ( h * Handler ) Flush ( ) { h . mu . Lock ( ) defer h . mu . Unlock ( ) if h . batch != nil { go h . flush ( h . batch ) h . batch = nil } }
6511	func New ( w io . Writer ) * Handler { var useColor bool if os . Getenv ( "COLORTERM" ) != "" { useColor = true } if term := os . Getenv ( "TERM" ) ; term != "" { for _ , substring := range colorTermSubstrings { if strings . Contains ( term , substring ) { useColor = true break } } } return & Handler { Writer : w , UseColor : useColor , } }
6512	func ( h * Handler ) HandleLog ( e * log . Entry ) error { color := Colors [ e . Level ] level := Strings [ e . Level ] var fields [ ] field for k , v := range e . Fields { fields = append ( fields , field { k , v } ) } sort . Sort ( byName ( fields ) ) h . mu . Lock ( ) defer h . mu . Unlock ( ) if h . UseColor { fmt . Fprintf ( h . Writer , "\033[%dm%6s\033[0m %-40s" , \033 , \033 , color ) } else level e . Message { fmt . Fprintf ( h . Writer , "%6s %-40s" , level , e . Message ) } for _ , f := range fields { var value interface { } switch t := f . Value . ( type ) { case [ ] byte : value = fmt . Sprintf ( "%X" , t ) case [ 21 ] byte : value = fmt . Sprintf ( "%X-%X-%X-%X" , t [ 0 ] , t [ 1 : 9 ] , t [ 9 : 17 ] , t [ 17 : ] ) default : value = f . Value } if h . UseColor { fmt . Fprintf ( h . Writer , " \033[%dm%s\033[0m=%v" , \033 , \033 , color ) } else f . Name } }
6513	func New ( seed int64 ) random . Interface { return & TTNRandom { Interface : & random . TTNRandom { Source : rand . New ( rand . NewSource ( seed ) ) , } , } }
6514	func ( self * UriTemplate ) Names ( ) [ ] string { names := make ( [ ] string , 0 , len ( self . parts ) ) for _ , p := range self . parts { if len ( p . raw ) > 0 || len ( p . terms ) == 0 { continue } for _ , term := range p . terms { names = append ( names , term . name ) } } return names }
6515	func ( p PerfDatum ) String ( ) string { val := fmtPerfFloat ( p . value ) value := fmt . Sprintf ( "%s=%s%s" , p . label , val , p . unit ) value += fmt . Sprintf ( ";%s;%s" , fmtThreshold ( p . warn ) , fmtThreshold ( p . crit ) ) value += fmt . Sprintf ( ";%s;%s" , fmtThreshold ( p . min ) , fmtThreshold ( p . max ) ) return value }
6516	func RenderPerfdata ( perfdata [ ] PerfDatum ) string { value := "" if len ( perfdata ) == 0 { return value } value += " |" for _ , datum := range perfdata { value += fmt . Sprintf ( " %v" , datum ) } return value }
6517	func Exit ( status Status , message string ) { fmt . Printf ( "%v: %s\n" , \n , status ) message }
6518	func NewCheckWithOptions ( options CheckOptions ) * Check { c := NewCheck ( ) if options . StatusPolicy != nil { c . statusPolicy = options . StatusPolicy } return c }
6519	func ( c * Check ) AddResult ( status Status , message string ) { var result Result result . status = status result . message = message c . results = append ( c . results , result ) if ( * c . statusPolicy ) [ result . status ] > ( * c . statusPolicy ) [ c . status ] { c . status = result . status } }
6520	func ( c * Check ) AddResultf ( status Status , format string , v ... interface { } ) { msg := fmt . Sprintf ( format , v ... ) c . AddResult ( status , msg ) }
6521	func ( c Check ) String ( ) string { value := fmt . Sprintf ( "%v: %s" , c . status , c . exitInfoText ( ) ) value += RenderPerfdata ( c . perfdata ) return value }
6522	func ( c * Check ) Exitf ( status Status , format string , v ... interface { } ) { info := fmt . Sprintf ( format , v ... ) c . AddResult ( status , info ) c . Finish ( ) }
6523	func ( c * Check ) Criticalf ( format string , v ... interface { } ) { c . Exitf ( CRITICAL , format , v ... ) }
6524	func ( c * Check ) Unknownf ( format string , v ... interface { } ) { c . Exitf ( UNKNOWN , format , v ... ) }
6525	func NewDefaultStatusPolicy ( ) * statusPolicy { return & statusPolicy { OK : statusSeverity ( OK ) , WARNING : statusSeverity ( WARNING ) , CRITICAL : statusSeverity ( CRITICAL ) , UNKNOWN : statusSeverity ( UNKNOWN ) , } }
6526	func NewStatusPolicy ( statuses [ ] Status ) ( * statusPolicy , error ) { newPol := make ( statusPolicy ) for i , status := range statuses { newPol [ status ] = statusSeverity ( i ) } defaultPol := NewDefaultStatusPolicy ( ) for status := range * defaultPol { _ , ok := newPol [ status ] if ! ok { return nil , fmt . Errorf ( "missing status: %v" , status ) } } return & newPol , nil }
6527	func ParseRange ( rangeStr string ) ( * Range , error ) { t := & Range { Start : 0 , End : math . Inf ( 1 ) , AlertOnInside : false , } rangeStr = strings . Trim ( rangeStr , " \n\r" ) \n \r if rangeStr [ 0 ] == '@' { t . AlertOnInside = true rangeStr = rangeStr [ 1 : ] } endPos := strings . Index ( rangeStr , ":" ) if endPos > - 1 { if rangeStr [ 0 ] == '~' { t . Start = math . Inf ( - 1 ) } else { min , err := strconv . ParseFloat ( rangeStr [ 0 : endPos ] , 64 ) if err != nil { return nil , fmt . Errorf ( "failed to parse lower limit: %v" , err ) } t . Start = min } rangeStr = rangeStr [ endPos + 1 : ] } if len ( rangeStr ) > 0 { max , err := strconv . ParseFloat ( rangeStr , 64 ) if err != nil { return nil , fmt . Errorf ( "failed to parse upper limit: %v" , err ) } t . End = max } }
6528	func ( r * Range ) Check ( value float64 ) bool { if r . Start <= value && value <= r . End { return r . AlertOnInside } return ! r . AlertOnInside }
6529	func ( r * Range ) CheckInt ( val int ) bool { return r . Check ( float64 ( val ) ) }
6530	func ( r * Range ) CheckUint64 ( val uint64 ) bool { return r . Check ( float64 ( val ) ) }
6531	func NewClient ( config * ClientConfig ) ( * Client , error ) { t := & http . Transport { TLSClientConfig : & tls . Config { InsecureSkipVerify : config . AllowUnverifiedSSL , } , } httpClient := & http . Client { Transport : t , } apiPath , _ := url . Parse ( "api/13/" ) baseURL , err := url . Parse ( config . BaseURL ) if err != nil { return nil , fmt . Errorf ( "invalid base URL: %s" , err . Error ( ) ) } apiURL := baseURL . ResolveReference ( apiPath ) return & Client { httpClient : httpClient , apiURL : apiURL , authToken : config . AuthToken , } , nil }
6532	func ( c * Client ) GetKeyMeta ( path string ) ( * KeyMeta , error ) { k := & KeyMeta { } err := c . get ( [ ] string { "storage" , "keys" , path } , nil , k ) return k , err }
6533	func ( c * Client ) GetKeysInDirMeta ( path string ) ( [ ] KeyMeta , error ) { r := & keyMetaListContents { } err := c . get ( [ ] string { "storage" , "keys" , path } , nil , r ) if err != nil { return nil , err } return r . Keys , nil }
6534	func ( c * Client ) GetKeyContent ( path string ) ( string , error ) { return c . rawGet ( [ ] string { "storage" , "keys" , path } , nil , "application/pgp-keys" ) }
6535	func ( c * Client ) GetJobSummariesForProject ( projectName string ) ( [ ] JobSummary , error ) { jobList := & jobSummaryList { } err := c . get ( [ ] string { "project" , projectName , "jobs" } , nil , jobList ) return jobList . Jobs , err }
6536	func ( c * Client ) GetJobsForProject ( projectName string ) ( [ ] JobDetail , error ) { jobList := & jobDetailList { } err := c . get ( [ ] string { "jobs" , "export" } , map [ string ] string { "project" : projectName } , jobList ) if err != nil { return nil , err } return jobList . Jobs , nil }
6537	func ( c * Client ) GetJob ( id string ) ( * JobDetail , error ) { jobList := & jobDetailList { } err := c . get ( [ ] string { "job" , id } , nil , jobList ) if err != nil { return nil , err } return & jobList . Jobs [ 0 ] , nil }
6538	func ( c * Client ) CreateJob ( job * JobDetail ) ( * JobSummary , error ) { return c . importJob ( job , "create" ) }
6539	func ( c * Client ) CreateOrUpdateJob ( job * JobDetail ) ( * JobSummary , error ) { return c . importJob ( job , "update" ) }
6540	func ( c * Client ) DeleteJob ( id string ) error { return c . delete ( [ ] string { "job" , id } ) }
6541	func ( r * jobImportResult ) JobSummary ( ) * JobSummary { return & JobSummary { ID : r . ID , Name : r . Name , GroupName : r . GroupName , ProjectName : r . ProjectName , } }
6542	func ( c * Client ) GetSystemInfo ( ) ( * SystemInfo , error ) { sysInfo := & SystemInfo { } err := c . get ( [ ] string { "system" , "info" } , nil , sysInfo ) return sysInfo , err }
6543	func ( ts * SystemTimestamp ) DateTime ( ) time . Time { t , _ := time . Parse ( time . RFC3339 , ts . DateTimeStr ) return t }
6544	func ( c * Client ) GetAllProjects ( ) ( [ ] ProjectSummary , error ) { p := & projects { } err := c . get ( [ ] string { "projects" } , nil , p ) return p . Projects , err }
6545	func ( c * Client ) GetProject ( name string ) ( * Project , error ) { p := & Project { } err := c . get ( [ ] string { "project" , name } , nil , p ) return p , err }
6546	func ( c * Client ) CreateProject ( project * Project ) ( * Project , error ) { p := & Project { } err := c . post ( [ ] string { "projects" } , nil , project , p ) return p , err }
6547	func ( c * Client ) DeleteProject ( name string ) error { return c . delete ( [ ] string { "project" , name } ) }
6548	func ( c * Client ) SetProjectConfig ( projectName string , config ProjectConfig ) error { return c . put ( [ ] string { "project" , projectName , "config" } , config , nil , ) }
6549	func NewClient ( username , password string ) * Client { c := newPBRestClient ( username , password , "" , "" , true ) return & Client { userName : c . username , password : c . password , client : c , } }
6550	func NewClientbyToken ( token string ) * Client { c := newPBRestClientbyToken ( token , "" , "" , true ) return & Client { token : c . token , client : c , } }
6551	func ( c * Client ) SetDepth ( depth int ) { c . client . depth = strconv . Itoa ( depth ) }
6552	func ( c * Client ) ListDatacenters ( ) ( * Datacenters , error ) { url := dcColPath ( ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Datacenters { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6553	func ( c * Client ) CreateDatacenter ( dc Datacenter ) ( * Datacenter , error ) { url := dcColPath ( ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Datacenter { } err := c . client . Post ( url , dc , ret , http . StatusAccepted ) return ret , err }
6554	func ( c * Client ) GetDatacenter ( dcid string ) ( * Datacenter , error ) { url := dcPath ( dcid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Datacenter { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6555	func ( c * Client ) UpdateDataCenter ( dcid string , obj DatacenterProperties ) ( * Datacenter , error ) { url := dcPath ( dcid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Datacenter { } err := c . client . Patch ( url , obj , ret , http . StatusAccepted ) return ret , err }
6556	func ( c * Client ) DeleteDatacenter ( dcid string ) ( * http . Header , error ) { url := dcPath ( dcid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & http . Header { } return ret , c . client . Delete ( url , ret , http . StatusAccepted ) }
6557	func ( c * Client ) WaitTillProvisioned ( path string ) error { waitCount := 300 for i := 0 ; i < waitCount ; i ++ { request , err := c . GetRequestStatus ( path ) if err != nil { return err } if request . Metadata . Status == "DONE" { return nil } time . Sleep ( 1 * time . Second ) i ++ } return fmt . Errorf ( "timeout expired while waiting for request to complete" ) }
6558	func ( c * Client ) ListFirewallRules ( dcID string , serverID string , nicID string ) ( * FirewallRules , error ) { url := fwruleColPath ( dcID , serverID , nicID ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & FirewallRules { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6559	func ( c * Client ) GetFirewallRule ( dcID string , serverID string , nicID string , fwID string ) ( * FirewallRule , error ) { url := fwrulePath ( dcID , serverID , nicID , fwID ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & FirewallRule { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6560	func ( c * Client ) CreateFirewallRule ( dcID string , serverID string , nicID string , fw FirewallRule ) ( * FirewallRule , error ) { url := fwruleColPath ( dcID , serverID , nicID ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & FirewallRule { } err := c . client . Post ( url , fw , ret , http . StatusAccepted ) return ret , err }
6561	func ( c * Client ) UpdateFirewallRule ( dcID string , serverID string , nicID string , fwID string , obj FirewallruleProperties ) ( * FirewallRule , error ) { url := fwrulePath ( dcID , serverID , nicID , fwID ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & FirewallRule { } err := c . client . Patch ( url , obj , ret , http . StatusAccepted ) return ret , err }
6562	func ( c * Client ) DeleteFirewallRule ( dcID string , serverID string , nicID string , fwID string ) ( * http . Header , error ) { url := fwrulePath ( dcID , serverID , nicID , fwID ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & http . Header { } err := c . client . Delete ( url , ret , http . StatusAccepted ) return ret , err }
6563	func ( c * Client ) ListLoadbalancers ( dcid string ) ( * Loadbalancers , error ) { url := lbalColPath ( dcid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Loadbalancers { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6564	func ( c * Client ) GetLoadbalancer ( dcid , lbalid string ) ( * Loadbalancer , error ) { url := lbalPath ( dcid , lbalid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Loadbalancer { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6565	func ( c * Client ) UpdateLoadbalancer ( dcid string , lbalid string , obj LoadbalancerProperties ) ( * Loadbalancer , error ) { url := lbalPath ( dcid , lbalid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Loadbalancer { } err := c . client . Patch ( url , obj , ret , http . StatusAccepted ) return ret , err }
6566	func ( c * Client ) DeleteLoadbalancer ( dcid , lbalid string ) ( * http . Header , error ) { url := lbalPath ( dcid , lbalid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & http . Header { } err := c . client . Delete ( url , ret , http . StatusAccepted ) return ret , err }
6567	func ( c * Client ) ListBalancedNics ( dcid , lbalid string ) ( * Nics , error ) { url := balnicColPath ( dcid , lbalid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Nics { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6568	func ( c * Client ) AssociateNic ( dcid string , lbalid string , nicid string ) ( * Nic , error ) { sm := map [ string ] string { "id" : nicid } url := balnicColPath ( dcid , lbalid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Nic { } err := c . client . Post ( url , sm , ret , http . StatusAccepted ) return ret , err }
6569	func ( c * Client ) GetBalancedNic ( dcid , lbalid , balnicid string ) ( * Nic , error ) { url := balnicPath ( dcid , lbalid , balnicid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Nic { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6570	func ( c * Client ) DeleteBalancedNic ( dcid , lbalid , balnicid string ) ( * http . Header , error ) { url := balnicPath ( dcid , lbalid , balnicid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & http . Header { } err := c . client . Delete ( url , ret , http . StatusAccepted ) return ret , err }
6571	func ( c * Client ) ListLans ( dcid string ) ( * Lans , error ) { url := lanColPath ( dcid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Lans { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6572	func ( c * Client ) GetLan ( dcid , lanid string ) ( * Lan , error ) { url := lanPath ( dcid , lanid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Lan { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6573	func ( c * Client ) DeleteLan ( dcid , lanid string ) ( * http . Header , error ) { url := lanPath ( dcid , lanid ) ret := & http . Header { } err := c . client . Delete ( url , ret , http . StatusAccepted ) return ret , err }
6574	func ( c * Client ) ListNics ( dcid , srvid string ) ( * Nics , error ) { url := nicColPath ( dcid , srvid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Nics { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6575	func ( c * Client ) CreateNic ( dcid string , srvid string , nic Nic ) ( * Nic , error ) { url := nicColPath ( dcid , srvid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Nic { } err := c . client . Post ( url , nic , ret , http . StatusAccepted ) return ret , err }
6576	func ( c * Client ) GetNic ( dcid , srvid , nicid string ) ( * Nic , error ) { url := nicPath ( dcid , srvid , nicid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Nic { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6577	func ( c * Client ) UpdateNic ( dcid string , srvid string , nicid string , obj NicProperties ) ( * Nic , error ) { url := nicPath ( dcid , srvid , nicid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Nic { } err := c . client . Patch ( url , obj , ret , http . StatusAccepted ) return ret , err }
6578	func ( c * Client ) DeleteNic ( dcid , srvid , nicid string ) ( * http . Header , error ) { url := nicPath ( dcid , srvid , nicid ) ret := & http . Header { } err := c . client . Delete ( url , ret , http . StatusAccepted ) return ret , err }
6579	func ( c * Client ) ListSnapshots ( ) ( * Snapshots , error ) { url := snapshotColPath ( ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Snapshots { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6580	func ( c * Client ) GetSnapshot ( snapshotID string ) ( * Snapshot , error ) { url := snapshotColPath ( ) + slash ( snapshotID ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Snapshot { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6581	func ( c * Client ) DeleteSnapshot ( snapshotID string ) ( * http . Header , error ) { url := snapshotColPath ( ) + slash ( snapshotID ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & http . Header { } err := c . client . Delete ( url , ret , http . StatusAccepted ) return ret , err }
6582	func ( c * Client ) UpdateSnapshot ( snapshotID string , request SnapshotProperties ) ( * Snapshot , error ) { url := snapshotColPath ( ) + slash ( snapshotID ) ret := & Snapshot { } err := c . client . Patch ( url , request , ret , http . StatusAccepted ) return ret , err }
6583	func ( c * Client ) ListIPBlocks ( ) ( * IPBlocks , error ) { url := ipblockColPath ( ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & IPBlocks { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6584	func ( c * Client ) ReserveIPBlock ( request IPBlock ) ( * IPBlock , error ) { url := ipblockColPath ( ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & IPBlock { } err := c . client . Post ( url , request , ret , http . StatusAccepted ) return ret , err }
6585	func ( c * Client ) GetIPBlock ( ipblockid string ) ( * IPBlock , error ) { url := ipblockPath ( ipblockid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & IPBlock { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6586	func ( c * Client ) UpdateIPBlock ( ipblockid string , props IPBlockProperties ) ( * IPBlock , error ) { url := ipblockPath ( ipblockid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & IPBlock { } err := c . client . Patch ( url , props , ret , http . StatusAccepted ) return ret , err }
6587	func ( c * Client ) ReleaseIPBlock ( ipblockid string ) ( * http . Header , error ) { url := ipblockPath ( ipblockid ) ret := & http . Header { } err := c . client . Delete ( url , ret , http . StatusAccepted ) return ret , err }
6588	func ( c * Client ) ListVolumes ( dcid string ) ( * Volumes , error ) { url := volumeColPath ( dcid ) + `?depth=` + c . client . depth ret := & Volumes { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6589	func ( c * Client ) GetVolume ( dcid string , volumeID string ) ( * Volume , error ) { url := volumePath ( dcid , volumeID ) + `?depth=` + c . client . depth ret := & Volume { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6590	func ( c * Client ) UpdateVolume ( dcid string , volid string , request VolumeProperties ) ( * Volume , error ) { url := volumePath ( dcid , volid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Volume { } err := c . client . Patch ( url , request , ret , http . StatusAccepted ) return ret , err }
6591	func ( c * Client ) CreateVolume ( dcid string , request Volume ) ( * Volume , error ) { url := volumeColPath ( dcid ) + `?depth=` + c . client . depth ret := & Volume { } err := c . client . Post ( url , request , ret , http . StatusAccepted ) return ret , err }
6592	func ( c * Client ) DeleteVolume ( dcid , volid string ) ( * http . Header , error ) { url := volumePath ( dcid , volid ) ret := & http . Header { } err := c . client . Delete ( url , ret , http . StatusAccepted ) return ret , err }
6593	func ( c * Client ) CreateSnapshot ( dcid string , volid string , name string , description string ) ( * Snapshot , error ) { path := volumePath ( dcid , volid ) + "/create-snapshot" data := url . Values { } data . Set ( "name" , name ) data . Add ( "description" , description ) ret := & Snapshot { } err := c . client . Post ( path , data , ret , http . StatusAccepted ) return ret , err }
6594	func ( c * Client ) RestoreSnapshot ( dcid string , volid string , snapshotID string ) ( * http . Header , error ) { path := volumePath ( dcid , volid ) + "/restore-snapshot" data := url . Values { } data . Set ( "snapshotId" , snapshotID ) ret := & http . Header { } err := c . client . Post ( path , data , ret , http . StatusAccepted ) return ret , err }
6595	func ( c * Client ) ListServers ( dcid string ) ( * Servers , error ) { url := serverColPath ( dcid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Servers { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6596	func ( c * Client ) GetServer ( dcid , srvid string ) ( * Server , error ) { url := serverPath ( dcid , srvid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Server { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6597	func ( c * Client ) DeleteServer ( dcid , srvid string ) ( * http . Header , error ) { ret := & http . Header { } err := c . client . Delete ( serverPath ( dcid , srvid ) , ret , http . StatusAccepted ) return ret , err }
6598	func ( c * Client ) ListAttachedCdroms ( dcid , srvid string ) ( * Images , error ) { url := serverCdromColPath ( dcid , srvid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Images { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6599	func ( c * Client ) AttachCdrom ( dcid string , srvid string , cdid string ) ( * Image , error ) { data := struct { ID string `json:"id,omitempty"` } { cdid , } url := serverCdromColPath ( dcid , srvid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Image { } err := c . client . Post ( url , data , ret , http . StatusAccepted ) return ret , err }
6600	func ( c * Client ) GetAttachedCdrom ( dcid , srvid , cdid string ) ( * Image , error ) { url := serverCdromPath ( dcid , srvid , cdid ) ret := & Image { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6601	func ( c * Client ) DetachCdrom ( dcid , srvid , cdid string ) ( * http . Header , error ) { url := serverCdromPath ( dcid , srvid , cdid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & http . Header { } err := c . client . Delete ( url , ret , http . StatusAccepted ) return ret , err }
6602	func ( c * Client ) ListAttachedVolumes ( dcid , srvid string ) ( * Volumes , error ) { url := serverVolumeColPath ( dcid , srvid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Volumes { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6603	func ( c * Client ) AttachVolume ( dcid string , srvid string , volid string ) ( * Volume , error ) { data := struct { ID string `json:"id,omitempty"` } { volid , } url := serverVolumeColPath ( dcid , srvid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Volume { } err := c . client . Post ( url , data , ret , http . StatusAccepted ) return ret , err }
6604	func ( c * Client ) GetAttachedVolume ( dcid , srvid , volid string ) ( * Volume , error ) { url := serverVolumePath ( dcid , srvid , volid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Volume { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6605	func ( c * Client ) DetachVolume ( dcid , srvid , volid string ) ( * http . Header , error ) { url := serverVolumePath ( dcid , srvid , volid ) ret := & http . Header { } err := c . client . Delete ( url , ret , http . StatusAccepted ) return ret , err }
6606	func ( c * Client ) StartServer ( dcid , srvid string ) ( * http . Header , error ) { url := serverPath ( dcid , srvid ) + "/start" ret := & http . Header { } err := c . client . Post ( url , nil , ret , http . StatusAccepted ) return ret , err }
6607	func ( c * Client ) ListLocations ( ) ( * Locations , error ) { url := locationColPath ( ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Locations { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6608	func ( c * Client ) GetRegionalLocations ( regid string ) ( * Locations , error ) { url := locationRegPath ( regid ) + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Locations { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6609	func ( c * Client ) GetLocation ( locid string ) ( * Location , error ) { url := locationPath ( locid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Location { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6610	func ( c * Client ) GetContractResources ( ) ( * ContractResources , error ) { url := contractResourcePath ( ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & ContractResources { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6611	func ( c * Client ) ListImages ( ) ( * Images , error ) { url := imageColPath ( ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Images { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6612	func ( c * Client ) GetImage ( imageid string ) ( * Image , error ) { url := imagePath ( imageid ) ret := & Image { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6613	func ( r * Resp ) PrintHeaders ( ) { for key , value := range r . Headers { fmt . Println ( key , " : " , value [ 0 ] ) } }
6614	func ( c * Client ) ListGroups ( ) ( * Groups , error ) { url := umGroups ( ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Groups { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6615	func ( c * Client ) GetGroup ( groupid string ) ( * Group , error ) { url := umGroupPath ( groupid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Group { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6616	func ( c * Client ) CreateGroup ( grp Group ) ( * Group , error ) { url := umGroups ( ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Group { } err := c . client . Post ( url , grp , ret , http . StatusAccepted ) return ret , err }
6617	func ( c * Client ) UpdateGroup ( groupid string , obj Group ) ( * Group , error ) { url := umGroupPath ( groupid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Group { } err := c . client . Put ( url , obj , ret , http . StatusAccepted ) return ret , err }
6618	func ( c * Client ) DeleteGroup ( groupid string ) ( * http . Header , error ) { url := umGroupPath ( groupid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & http . Header { } err := c . client . Delete ( url , ret , http . StatusAccepted ) return ret , err }
6619	func ( c * Client ) ListShares ( grpid string ) ( * Shares , error ) { url := umGroupShares ( grpid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Shares { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6620	func ( c * Client ) GetShare ( groupid string , resourceid string ) ( * Share , error ) { url := umGroupSharePath ( groupid , resourceid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Share { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6621	func ( c * Client ) AddShare ( groupid string , resourceid string , share Share ) ( * Share , error ) { url := umGroupSharePath ( groupid , resourceid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Share { } err := c . client . Post ( url , share , ret , http . StatusAccepted ) return ret , err }
6622	func ( c * Client ) UpdateShare ( groupid string , resourceid string , obj Share ) ( * Share , error ) { url := umGroupSharePath ( groupid , resourceid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Share { } err := c . client . Put ( url , obj , ret , http . StatusAccepted ) return ret , err }
6623	func ( c * Client ) DeleteShare ( groupid string , resourceid string ) ( * http . Header , error ) { url := umGroupSharePath ( groupid , resourceid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & http . Header { } err := c . client . Delete ( url , ret , http . StatusAccepted ) return ret , err }
6624	func ( c * Client ) ListGroupUsers ( groupid string ) ( * Users , error ) { url := umGroupUsers ( groupid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Users { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6625	func ( c * Client ) AddUserToGroup ( groupid string , userid string ) ( * User , error ) { var usr User usr . ID = userid url := umGroupUsers ( groupid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & User { } err := c . client . Post ( url , usr , ret , http . StatusAccepted ) return ret , err }
6626	func ( c * Client ) DeleteUserFromGroup ( groupid string , userid string ) ( * http . Header , error ) { url := umGroupUsersPath ( groupid , userid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & http . Header { } err := c . client . Delete ( url , ret , http . StatusAccepted ) return ret , err }
6627	func ( c * Client ) ListUsers ( ) ( * Users , error ) { url := umUsers ( ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Users { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6628	func ( c * Client ) GetUser ( usrid string ) ( * User , error ) { url := umUsersPath ( usrid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & User { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6629	func ( c * Client ) CreateUser ( usr User ) ( * User , error ) { url := umUsers ( ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & User { } err := c . client . Post ( url , usr , ret , http . StatusAccepted ) return ret , err }
6630	func ( c * Client ) UpdateUser ( userid string , obj User ) ( * User , error ) { url := umUsersPath ( userid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & User { } err := c . client . Put ( url , obj , ret , http . StatusAccepted ) return ret , err }
6631	func ( c * Client ) DeleteUser ( userid string ) ( * http . Header , error ) { url := umUsersPath ( userid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & http . Header { } err := c . client . Delete ( url , ret , http . StatusAccepted ) return ret , err }
6632	func ( c * Client ) ListResources ( ) ( * Resources , error ) { url := umResources ( ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Resources { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6633	func ( c * Client ) GetResourceByType ( resourcetype string , resourceid string ) ( * Resource , error ) { url := umResourcesTypePath ( resourcetype , resourceid ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Resource { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6634	func ( c * Client ) ListResourcesByType ( resourcetype string ) ( * Resources , error ) { url := umResourcesType ( resourcetype ) + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Resources { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6635	func ( c * Client ) ListRequests ( ) ( * Requests , error ) { url := "/requests" + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Requests { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6636	func ( c * Client ) GetRequest ( reqID string ) ( * Request , error ) { url := "/requests/" + reqID + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & Request { } err := c . client . Get ( url , ret , http . StatusOK ) return ret , err }
6637	func ( c * Client ) GetRequestStatus ( path string ) ( * RequestStatus , error ) { url := path + `?depth=` + c . client . depth + `&pretty=` + strconv . FormatBool ( c . client . pretty ) ret := & RequestStatus { } err := c . client . GetRequestStatus ( url , ret , http . StatusOK ) return ret , err }
6638	func ( l * Writer ) Close ( ) error { l . mutex . Lock ( ) defer l . mutex . Unlock ( ) return l . file . Close ( ) }
6639	func ( serialize * SerializableMeta ) GetSerializableArgument ( serializableMetaInterface SerializableMetaInterface ) interface { } { if serialize . Value . OriginalValue != nil { return serialize . Value . OriginalValue } if res := serializableMetaInterface . GetSerializableArgumentResource ( ) ; res != nil { value := res . NewStruct ( ) json . Unmarshal ( [ ] byte ( serialize . Value . SerializedValue ) , value ) return value } return nil }
6640	func BoolVar ( p * bool , name string , value bool , usage string ) { EnvironmentFlags . BoolVar ( p , name , value , usage ) }
6641	func Bool ( name string , value bool , usage string ) * bool { return EnvironmentFlags . Bool ( name , value , usage ) }
6642	func IntVar ( p * int , name string , value int , usage string ) { EnvironmentFlags . IntVar ( p , name , value , usage ) }
6643	func Int ( name string , value int , usage string ) * int { return EnvironmentFlags . Int ( name , value , usage ) }
6644	func Int64Var ( p * int64 , name string , value int64 , usage string ) { EnvironmentFlags . Int64Var ( p , name , value , usage ) }
6645	func Int64 ( name string , value int64 , usage string ) * int64 { return EnvironmentFlags . Int64 ( name , value , usage ) }
6646	func UintVar ( p * uint , name string , value uint , usage string ) { EnvironmentFlags . UintVar ( p , name , value , usage ) }
6647	func Uint ( name string , value uint , usage string ) * uint { return EnvironmentFlags . Uint ( name , value , usage ) }
6648	func Uint64Var ( p * uint64 , name string , value uint64 , usage string ) { EnvironmentFlags . Uint64Var ( p , name , value , usage ) }
6649	func Uint64 ( name string , value uint64 , usage string ) * uint64 { return EnvironmentFlags . Uint64 ( name , value , usage ) }
6650	func StringVar ( p * string , name string , value string , usage string ) { EnvironmentFlags . StringVar ( p , name , value , usage ) }
6651	func String ( name string , value string , usage string ) * string { return EnvironmentFlags . String ( name , value , usage ) }
6652	func Float64Var ( p * float64 , name string , value float64 , usage string ) { EnvironmentFlags . Float64Var ( p , name , value , usage ) }
6653	func Float64 ( name string , value float64 , usage string ) * float64 { return EnvironmentFlags . Float64 ( name , value , usage ) }
6654	func DurationVar ( p * time . Duration , name string , value time . Duration , usage string ) { EnvironmentFlags . DurationVar ( p , name , value , usage ) }
6655	func Duration ( name string , value time . Duration , usage string ) * time . Duration { return EnvironmentFlags . Duration ( name , value , usage ) }
6656	func Parse ( ) { env := os . Environ ( ) args := make ( [ ] string , 0 , len ( env ) ) for _ , value := range env { if Lookup ( value [ : strings . Index ( value , "=" ) ] ) == nil { continue } args = append ( args , fmt . Sprintf ( "-%s" , value ) ) } EnvironmentFlags . Parse ( args ) }
6657	func WriteStringToFile ( text , path string ) error { f , err := os . OpenFile ( path , os . O_CREATE | os . O_WRONLY , 0644 ) defer f . Close ( ) if err != nil { return err } f . WriteString ( text ) return nil }
6658	func ReadFileToString ( path string ) ( string , error ) { f , err := os . Open ( path ) if err != nil { return "" , err } defer f . Close ( ) scanner := bufio . NewScanner ( f ) scanner . Scan ( ) return scanner . Text ( ) , nil }
6659	func LineReader ( r io . Reader ) ( <- chan string , error ) { return lineReader ( func ( ) ( io . Reader , func ( ) , error ) { return r , nil , nil } ) }
6660	func LineReaderFrom ( path string ) ( <- chan string , error ) { return lineReader ( func ( ) ( io . Reader , func ( ) , error ) { if ! FileExists ( path ) { return nil , nil , nil } f , err := os . Open ( path ) if err != nil { return nil , nil , err } return f , func ( ) { f . Close ( ) } , nil } ) }
6661	func FileExists ( filePath string ) bool { if _ , err := os . Stat ( filePath ) ; ! os . IsNotExist ( err ) { return true } return false }
6662	func FileExistsInPath ( fileName string ) bool { _ , err := exec . LookPath ( fileName ) return err == nil }
6663	func GetPathParts ( path string ) ( dirPath , fileName , absPath string ) { lookup , lookupErr := exec . LookPath ( path ) if lookupErr == nil { path = lookup } absPath , _ = filepath . Abs ( path ) dirPath = filepath . Dir ( absPath ) fileName = filepath . Base ( absPath ) return }
6664	func GetThisPathParts ( ) ( dirPath , fileName , absPath string ) { exeFile , _ := osext . Executable ( ) return GetPathParts ( exeFile ) }
6665	func RandomString ( length int ) string { src := rand . NewSource ( time . Now ( ) . UnixNano ( ) ) b := make ( [ ] byte , length ) for i , cache , remain := length - 1 , src . Int63 ( ) , letterIndexMax ; i >= 0 ; { if remain == 0 { cache , remain = src . Int63 ( ) , letterIndexMax } if idx := int ( cache & letterIndexMask ) ; idx < len ( letterBytes ) { b [ i ] = letterBytes [ idx ] i -- } cache >>= letterIndexBits remain -- } return string ( b ) }
6666	func ParseAddress ( addr string ) ( proto string , path string , err error ) { m := netAddrRx . FindStringSubmatch ( addr ) if m == nil { return "" , "" , goof . WithField ( "address" , addr , "invalid address" ) } return m [ 1 ] , m [ 2 ] , nil }
6667	func HomeDir ( ) string { if homeDirSet { return homeDir } if user , err := user . Current ( ) ; err == nil { homeDir = user . HomeDir } homeDirSet = true return homeDir }
6668	func IsTCPPortAvailable ( port int ) bool { if port < minTCPPort || port > maxTCPPort { return false } conn , err := net . Listen ( "tcp" , fmt . Sprintf ( "127.0.0.1:%d" , port ) ) if err != nil { return false } conn . Close ( ) return true }
6669	func RandomTCPPort ( ) int { for i := maxReservedTCPPort ; i < maxTCPPort ; i ++ { p := tcpPortRand . Intn ( maxRandTCPPort ) + maxReservedTCPPort + 1 if IsTCPPortAvailable ( p ) { return p } } return - 1 }
6670	func HashString ( key string , numBuckets int ) int32 { k := Hash ( Sum64 ( key ) , numBuckets ) return k }
6671	func ( sm * sessionManager ) Context ( ctx context . Context , req * empty . Empty ) ( * mnemosynerpc . ContextResponse , error ) { md , ok := metadata . FromIncomingContext ( ctx ) if ! ok { return nil , status . Errorf ( codes . InvalidArgument , "missing metadata in context, access token cannot be retrieved" ) } if len ( md [ mnemosyne . AccessTokenMetadataKey ] ) == 0 { return nil , status . Errorf ( codes . InvalidArgument , "missing access token in metadata" ) } at := md [ mnemosyne . AccessTokenMetadataKey ] [ 0 ] res , err := sm . Get ( ctx , & mnemosynerpc . GetRequest { AccessToken : at } ) if err != nil { return nil , err } return & mnemosynerpc . ContextResponse { Session : res . Session , } , nil }
6672	func ( s * Session ) Token ( ) ( * oauth2 . Token , error ) { var ( err error expireAt time . Time ) if s . ExpireAt != nil { expireAt , err = ptypes . Timestamp ( s . ExpireAt ) if err != nil { return nil , err } } token := & oauth2 . Token { AccessToken : string ( s . AccessToken ) , Expiry : expireAt , } if s . Bag != nil && len ( s . Bag ) > 0 { token = token . WithExtra ( bagToURLValues ( s . Bag ) ) } return token , nil }
6673	func NewDaemon ( opts * DaemonOpts ) ( * Daemon , error ) { d := & Daemon { done : make ( chan struct { } ) , opts : opts , logger : opts . Logger , serverOptions : opts . RPCOptions , rpcListener : opts . RPCListener , debugListener : opts . DebugListener , } if err := d . setPostgresConnectionParameters ( ) ; err != nil { return nil , err } if d . opts . SessionTTL == 0 { d . opts . SessionTTL = storage . DefaultTTL } if d . opts . SessionTTC == 0 { d . opts . SessionTTC = storage . DefaultTTC } if d . opts . Storage == "" { d . opts . Storage = storage . EnginePostgres } if d . opts . PostgresTable == "" { d . opts . PostgresTable = "session" } if d . opts . PostgresSchema == "" { d . opts . PostgresSchema = "mnemosyne" } return d , nil }
6674	func ( d * Daemon ) Close ( ) ( err error ) { d . done <- struct { } { } d . server . GracefulStop ( ) if d . postgres != nil { if err = d . postgres . Close ( ) ; err != nil { return } } if d . debugListener != nil { if err = d . debugListener . Close ( ) ; err != nil { return } } if d . tracerCloser != nil { if err = d . tracerCloser . Close ( ) ; err != nil { return } } return nil }
6675	func NewAccessTokenContext ( ctx context . Context , at string ) context . Context { return context . WithValue ( ctx , accessTokenContextKey , at ) }
6676	func AccessTokenFromContext ( ctx context . Context ) ( string , bool ) { at , ok := ctx . Value ( accessTokenContextKey ) . ( string ) return at , ok }
6677	func RandomAccessToken ( ) ( string , error ) { buf , err := generateRandomBytes ( 128 ) if err != nil { return "" , err } hash := make ( [ ] byte , 64 ) sha3 . ShakeSum256 ( hash , buf ) hash2 := make ( [ ] byte , hex . EncodedLen ( len ( hash ) ) ) hex . Encode ( hash2 , hash ) return string ( hash2 ) , nil }
6678	func Init ( opts Opts ) ( logger * zap . Logger , err error ) { var ( cfg zap . Config options [ ] zap . Option lvl zapcore . Level ) switch opts . Environment { case "production" : cfg = zap . NewProductionConfig ( ) case "stackdriver" : cfg = NewStackdriverConfig ( ) options = append ( options , zap . Fields ( zap . Object ( "serviceContext" , & ServiceContext { Service : "mnemosyned" , Version : opts . Version , } ) ) ) case "development" : cfg = zap . NewDevelopmentConfig ( ) default : cfg = zap . NewProductionConfig ( ) } if err = lvl . Set ( opts . Level ) ; err != nil { return nil , err } cfg . Level . SetLevel ( lvl ) logger , err = cfg . Build ( options ... ) if err != nil { return nil , err } logger . Info ( "logger has been initialized" , zap . String ( "environment" , opts . Environment ) ) return logger , nil }
6679	func Load ( path string ) ( d * Dic , err error ) { d = new ( Dic ) r , err := zip . OpenReader ( path ) if err != nil { return d , err } defer r . Close ( ) for _ , f := range r . File { if err = func ( ) error { rc , e := f . Open ( ) if e != nil { return e } defer rc . Close ( ) switch f . Name { case "morph.dic" : if e = d . loadMorphDicPart ( rc ) ; e != nil { return e } case "pos.dic" : if e = d . loadPOSDicPart ( rc ) ; e != nil { return e } case "content.dic" : if e = d . loadContentDicPart ( rc ) ; e != nil { return e } case "index.dic" : if e = d . loadIndexDicPart ( rc ) ; e != nil { return e } case "connection.dic" : if e = d . loadConnectionDicPart ( rc ) ; e != nil { return e } case "chardef.dic" : if e = d . loadCharDefDicPart ( rc ) ; e != nil { return e } case "unk.dic" : if e = d . loadUnkDicPart ( rc ) ; e != nil { return e } } return nil } ( ) ; err != nil { return } } return }
6680	func ( s * Storage ) Start ( ctx context . Context , accessToken , refreshToken , sid , sc string , b map [ string ] string ) ( * mnemosynerpc . Session , error ) { span , ctx := opentracing . StartSpanFromContext ( ctx , "postgres.storage.start" ) defer span . Finish ( ) ent := & sessionEntity { AccessToken : accessToken , RefreshToken : refreshToken , SubjectID : sid , SubjectClient : sc , Bag : model . Bag ( b ) , } if err := s . save ( ctx , ent ) ; err != nil { return nil , err } return ent . session ( ) }
6681	func ( s * Storage ) Get ( ctx context . Context , accessToken string ) ( * mnemosynerpc . Session , error ) { span , ctx := opentracing . StartSpanFromContext ( ctx , "postgres.storage.get" ) defer span . Finish ( ) var entity sessionEntity start := time . Now ( ) labels := prometheus . Labels { "query" : "get" } err := s . db . QueryRowContext ( ctx , s . queryGet , accessToken ) . Scan ( & entity . RefreshToken , & entity . SubjectID , & entity . SubjectClient , & entity . Bag , & entity . ExpireAt , ) s . incQueries ( labels , start ) if err != nil { s . incError ( labels ) if err == sql . ErrNoRows { return nil , storage . ErrSessionNotFound } return nil , err } expireAt , err := ptypes . TimestampProto ( entity . ExpireAt ) if err != nil { return nil , err } return & mnemosynerpc . Session { AccessToken : accessToken , RefreshToken : entity . RefreshToken , SubjectId : entity . SubjectID , SubjectClient : entity . SubjectClient , Bag : entity . Bag , ExpireAt : expireAt , } , nil }
6682	func ( s * Storage ) List ( ctx context . Context , offset , limit int64 , expiredAtFrom , expiredAtTo * time . Time ) ( [ ] * mnemosynerpc . Session , error ) { span , ctx := opentracing . StartSpanFromContext ( ctx , "postgres.storage.list" ) defer span . Finish ( ) if limit == 0 { return nil , errors . New ( "cannot retrieve list of sessions, limit needs to be higher than 0" ) } args := [ ] interface { } { offset , limit } query := "SELECT access_token, refresh_token, subject_id, subject_client, bag, expire_at FROM " + s . schema + "." + s . table + " " if expiredAtFrom != nil || expiredAtTo != nil { query += " WHERE " } switch { case expiredAtFrom != nil && expiredAtTo == nil : query += "expire_at > $3" args = append ( args , expiredAtFrom ) case expiredAtFrom == nil && expiredAtTo != nil : query += "expire_at < $3" args = append ( args , expiredAtTo ) case expiredAtFrom != nil && expiredAtTo != nil : query += "expire_at > $3 AND expire_at < $4" args = append ( args , expiredAtFrom , expiredAtTo ) } query += " OFFSET $1 LIMIT $2" labels := prometheus . Labels { "query" : "list" } start := time . Now ( ) rows , err := s . db . QueryContext ( ctx , query , args ... ) s . incQueries ( labels , start ) if err != nil { s . incError ( labels ) return nil , err } defer rows . Close ( ) sessions := make ( [ ] * mnemosynerpc . Session , 0 , limit ) for rows . Next ( ) { var ent sessionEntity err = rows . Scan ( & ent . AccessToken , & ent . RefreshToken , & ent . SubjectID , & ent . SubjectClient , & ent . Bag , & ent . ExpireAt , ) if err != nil { s . incError ( labels ) return nil , err } expireAt , err := ptypes . TimestampProto ( ent . ExpireAt ) if err != nil { return nil , err } sessions = append ( sessions , & mnemosynerpc . Session { AccessToken : ent . AccessToken , RefreshToken : ent . RefreshToken , SubjectId : ent . SubjectID , SubjectClient : ent . SubjectClient , Bag : ent . Bag , ExpireAt : expireAt , } ) } if rows . Err ( ) != nil { s . incError ( labels ) return nil , rows . Err ( ) } return sessions , nil }
6683	func ( s * Storage ) Exists ( ctx context . Context , accessToken string ) ( exists bool , err error ) { span , ctx := opentracing . StartSpanFromContext ( ctx , "postgres.storage.exists" ) defer span . Finish ( ) start := time . Now ( ) labels := prometheus . Labels { "query" : "exists" } err = s . db . QueryRowContext ( ctx , s . queryExists , accessToken ) . Scan ( & exists , ) s . incQueries ( labels , start ) if err != nil { s . incError ( labels ) } return }
6684	func ( s * Storage ) Abandon ( ctx context . Context , accessToken string ) ( bool , error ) { span , ctx := opentracing . StartSpanFromContext ( ctx , "postgres.storage.abandon" ) defer span . Finish ( ) start := time . Now ( ) labels := prometheus . Labels { "query" : "abandon" } result , err := s . db . ExecContext ( ctx , s . queryAbandon , accessToken ) s . incQueries ( labels , start ) if err != nil { s . incError ( labels ) return false , err } affected , err := result . RowsAffected ( ) if err != nil { return false , err } if affected == 0 { return false , storage . ErrSessionNotFound } return true , nil }
6685	func ( s * Storage ) SetValue ( ctx context . Context , accessToken string , key , value string ) ( map [ string ] string , error ) { span , ctx := opentracing . StartSpanFromContext ( ctx , "postgres.storage.set-value" ) defer span . Finish ( ) var err error if accessToken == "" { return nil , storage . ErrMissingAccessToken } entity := & sessionEntity { AccessToken : accessToken , } selectQuery := ` SELECT bag FROM ` + s . schema + `.` + s . table + ` WHERE access_token = $1 FOR UPDATE ` updateQuery := ` UPDATE ` + s . schema + `.` + s . table + ` SET bag = $2 WHERE access_token = $1 ` tx , err := s . db . BeginTx ( ctx , nil ) if err != nil { tx . Rollback ( ) return nil , err } startSelect := time . Now ( ) err = tx . QueryRowContext ( ctx , selectQuery , accessToken ) . Scan ( & entity . Bag , ) s . incQueries ( prometheus . Labels { "query" : "set_value_select" } , startSelect ) if err != nil { s . incError ( prometheus . Labels { "query" : "set_value_select" } ) tx . Rollback ( ) if err == sql . ErrNoRows { return nil , storage . ErrSessionNotFound } return nil , err } entity . Bag . Set ( key , value ) startUpdate := time . Now ( ) _ , err = tx . ExecContext ( ctx , updateQuery , accessToken , entity . Bag ) s . incQueries ( prometheus . Labels { "query" : "set_value_update" } , startUpdate ) if err != nil { s . incError ( prometheus . Labels { "query" : "set_value_update" } ) tx . Rollback ( ) return nil , err } tx . Commit ( ) return entity . Bag , nil }
6686	func ( s * Storage ) Delete ( ctx context . Context , subjectID , accessToken , refreshToken string , expiredAtFrom , expiredAtTo * time . Time ) ( int64 , error ) { span , ctx := opentracing . StartSpanFromContext ( ctx , "postgres.storage.delete" ) defer span . Finish ( ) where , args := s . where ( subjectID , accessToken , refreshToken , expiredAtFrom , expiredAtTo ) if where . Len ( ) == 0 { return 0 , fmt . Errorf ( "session cannot be deleted, no where parameter provided: %s" , where . String ( ) ) } query := "DELETE FROM " + s . schema + "." + s . table + " WHERE " + where . String ( ) labels := prometheus . Labels { "query" : "delete" } start := time . Now ( ) result , err := s . db . Exec ( query , args ... ) s . incQueries ( labels , start ) if err != nil { s . incError ( labels ) return 0 , err } return result . RowsAffected ( ) }
6687	func ( s * Storage ) Setup ( ) error { query := fmt . Sprintf ( ` CREATE SCHEMA IF NOT EXISTS %s; CREATE TABLE IF NOT EXISTS %s.%s ( access_token BYTEA PRIMARY KEY, refresh_token BYTEA, subject_id TEXT NOT NULL, subject_client TEXT, bag bytea NOT NULL, expire_at TIMESTAMPTZ NOT NULL DEFAULT (NOW() + '%d seconds') ); CREATE INDEX ON %s.%s (refresh_token); CREATE INDEX ON %s.%s (subject_id); CREATE INDEX ON %s.%s (expire_at DESC); ` , s . schema , s . schema , s . table , int64 ( s . ttl . Seconds ( ) ) , s . schema , s . table , s . schema , s . table , s . schema , s . table , ) _ , err := s . db . Exec ( query ) return err }
6688	func ( s * Storage ) TearDown ( ) error { _ , err := s . db . Exec ( `DROP SCHEMA IF EXISTS ` + s . schema + ` CASCADE` ) return err }
6689	func initJaeger ( service , node , agentAddress string , log * zap . Logger ) ( opentracing . Tracer , io . Closer , error ) { cfg := & config . Configuration { Sampler : & config . SamplerConfig { Type : "const" , Param : 1 , } , Tags : [ ] opentracing . Tag { { Key : constant . Subsystem + ".listen" , Value : node , } } , Reporter : & config . ReporterConfig { LogSpans : true , LocalAgentHostPort : agentAddress , } , } tracer , closer , err := cfg . New ( service , config . Logger ( zapjaeger . NewLogger ( log ) ) ) if err != nil { return nil , nil , err } return tracer , closer , nil }
6690	func Usage ( ) { fmt . Fprintf ( errorWriter , "Japanese Morphological Analyzer -- github.com/ikawaha/kagome.ipadic\n" ) \n }
6691	func Build ( keywords [ ] string ) ( DoubleArray , error ) { s := len ( keywords ) if s == 0 { return DoubleArray { } , nil } ids := make ( [ ] int , s , s ) for i := range ids { ids [ i ] = i + 1 } return BuildWithIDs ( keywords , ids ) }
6692	func Read ( r io . Reader ) ( DoubleArray , error ) { var sz int64 if e := binary . Read ( r , binary . LittleEndian , & sz ) ; e != nil { return DoubleArray { } , e } d := make ( DoubleArray , sz , sz ) for i := range d { if e := binary . Read ( r , binary . LittleEndian , & d [ i ] . Base ) ; e != nil { return d , e } if e := binary . Read ( r , binary . LittleEndian , & d [ i ] . Check ) ; e != nil { return d , e } } return d , nil }
6693	func ( c * Cluster ) Get ( k int32 ) ( * Node , bool ) { if len ( c . nodes ) == 0 { return nil , false } if len ( c . nodes ) - 1 < int ( k ) { return nil , false } return c . nodes [ k ] , true }
6694	func ( c * Cluster ) ExternalNodes ( ) ( res [ ] * Node ) { for _ , n := range c . nodes { if n . Addr != c . listen { res = append ( res , n ) } } return }
6695	func ( c * Cluster ) GetOther ( accessToken string ) ( * Node , bool ) { if c == nil { return nil , false } if c . Len ( ) == 1 { return nil , false } if node , ok := c . Get ( jump . HashString ( accessToken , c . Len ( ) ) ) ; ok { if node . Addr != c . listen { if node . Client != nil { return node , true } } } return nil , false }
6696	func ( c * Cluster ) GoString ( ) string { buf , _ := json . Marshal ( map [ string ] interface { } { "listen" : c . listen , "nodes" : c . nodes , "buckets" : strconv . FormatInt ( int64 ( c . buckets ) , 10 ) , } ) return string ( buf ) }
6697	func ( b * Bag ) Scan ( src interface { } ) ( err error ) { switch t := src . ( type ) { case [ ] byte : err = gob . NewDecoder ( bytes . NewReader ( t ) ) . Decode ( b ) default : return errors . New ( "unsupported data source type" ) } return }
6698	func ( b Bag ) Value ( ) ( driver . Value , error ) { buf := bytes . NewBuffer ( nil ) err := gob . NewEncoder ( buf ) . Encode ( b ) if err != nil { return nil , err } return buf . Bytes ( ) , nil }
6699	func ( b * Bag ) Has ( key string ) bool { _ , ok := ( * b ) [ key ] return ok }
6700	func ( idx IndexTable ) WriteTo ( w io . Writer ) ( n int64 , err error ) { n , err = idx . Da . WriteTo ( w ) var b bytes . Buffer enc := gob . NewEncoder ( & b ) if err = enc . Encode ( idx . Dup ) ; err != nil { return } x , err := b . WriteTo ( w ) if err != nil { return } n += x return }
6701	func ReadIndexTable ( r io . Reader ) ( IndexTable , error ) { idx := IndexTable { } d , err := da . Read ( r ) if err != nil { return idx , fmt . Errorf ( "read index error, %v" , err ) } idx . Da = d dec := gob . NewDecoder ( r ) if e := dec . Decode ( & idx . Dup ) ; e != nil { return idx , fmt . Errorf ( "read index dup table error, %v" , e ) } return idx , nil }
6702	func New ( admin * admin . Admin ) * ActionBar { bar := & ActionBar { Admin : admin } ctr := & controller { ActionBar : bar } admin . GetRouter ( ) . Get ( "/action_bar/switch_mode" , ctr . SwitchMode ) admin . GetRouter ( ) . Get ( "/action_bar/inline_edit" , ctr . InlineEdit ) return bar }
6703	func ( bar * ActionBar ) RegisterAction ( action ActionInterface ) { bar . GlobalActions = append ( bar . GlobalActions , action ) bar . actions = bar . GlobalActions }
6704	func ( bar * ActionBar ) Actions ( actions ... ActionInterface ) * ActionBar { newBar := & ActionBar { Admin : bar . Admin , actions : bar . GlobalActions } newBar . actions = append ( newBar . actions , actions ... ) return newBar }
6705	func ( bar * ActionBar ) Render ( w http . ResponseWriter , r * http . Request ) template . HTML { var ( actions , inlineActions [ ] ActionInterface context = bar . Admin . NewContext ( w , r ) ) for _ , action := range bar . actions { if action . InlineAction ( ) { inlineActions = append ( inlineActions , action ) } else { actions = append ( actions , action ) } } context . Context . CurrentUser = bar . Admin . Auth . GetCurrentUser ( context ) result := map [ string ] interface { } { "EditMode" : bar . EditMode ( w , r ) , "Auth" : bar . Admin . Auth , "CurrentUser" : context . Context . CurrentUser , "Actions" : actions , "InlineActions" : inlineActions , "RouterPrefix" : bar . Admin . GetRouter ( ) . Prefix , } return context . Render ( "action_bar/action_bar" , result ) }
6706	func ( bar * ActionBar ) FuncMap ( w http . ResponseWriter , r * http . Request ) template . FuncMap { funcMap := template . FuncMap { } funcMap [ "render_edit_button" ] = func ( value interface { } , resources ... * admin . Resource ) template . HTML { return bar . RenderEditButtonWithResource ( w , r , value , resources ... ) } return funcMap }
6707	func ( bar * ActionBar ) EditMode ( w http . ResponseWriter , r * http . Request ) bool { return isEditMode ( bar . Admin . NewContext ( w , r ) ) }
6708	func ( controller ) SwitchMode ( context * admin . Context ) { utils . SetCookie ( http . Cookie { Name : "qor-action-bar" , Value : context . Request . URL . Query ( ) . Get ( "checked" ) } , context . Context ) referrer := context . Request . Referer ( ) if referrer == "" { referrer = "/" } http . Redirect ( context . Writer , context . Request , referrer , http . StatusFound ) }
6709	func ( controller ) InlineEdit ( context * admin . Context ) { context . Writer . Write ( [ ] byte ( context . Render ( "action_bar/inline_edit" ) ) ) }
6710	func ( e * Error ) Error ( ) string { return fmt . Sprintf ( "%s:%d: %s" , e . Filename , e . LineNum , e . Msg ) }
6711	func ParseFile ( filename string ) ( [ ] * Machine , Macros , error ) { fd , err := os . Open ( filename ) if err != nil { return nil , nil , err } defer fd . Close ( ) return parse ( fd , & filePos { filename , 1 } ) }
6712	func FindMachine ( filename , name string ) ( * Machine , error ) { mach , _ , err := ParseFile ( filename ) if err != nil { return nil , err } var def * Machine for _ , m := range mach { if m . Name == name { return m , nil } if m . Name == "" { def = m } } if def == nil { return nil , errors . New ( "no machine found" ) } return def , nil }
6713	func New ( initialisms map [ string ] bool ) ( * Kace , error ) { ci := initialisms if ci == nil { ci = map [ string ] bool { } } ci = sanitizeCI ( ci ) t , err := ktrie . NewKTrie ( ci ) if err != nil { return nil , fmt . Errorf ( "kace: cannot create trie: %s" , err ) } k := & Kace { t : t , } return k , nil }
6714	func ( k * Kace ) Camel ( s string ) string { return camelCase ( k . t , s , false ) }
6715	func ( k * Kace ) Pascal ( s string ) string { return camelCase ( k . t , s , true ) }
6716	func ( k * Kace ) Snake ( s string ) string { return delimitedCase ( s , snakeDelim , false ) }
6717	func ( k * Kace ) SnakeUpper ( s string ) string { return delimitedCase ( s , snakeDelim , true ) }
6718	func ( k * Kace ) Kebab ( s string ) string { return delimitedCase ( s , kebabDelim , false ) }
6719	func ( k * Kace ) KebabUpper ( s string ) string { return delimitedCase ( s , kebabDelim , true ) }
6720	func isPathSafe ( s string ) error { u , err := url . Parse ( s ) if err != nil { return err } e , err := url . PathUnescape ( u . Path ) if err != nil { return err } if strings . Contains ( e , ".." ) { return fmt . Errorf ( errorMessage ) } if ! whitelistPattern . MatchString ( e ) { return fmt . Errorf ( errorMessage ) } return nil }
6721	func ( t * WriterTracer ) Start ( r * http . Request ) { t . StartTime = time . Now ( ) . UTC ( ) t . Request . URL = r . URL . String ( ) t . Request . Method = r . Method }
6722	func ParseAuthHeaders ( r * http . Request ) ( * AuthCreds , error ) { if r . URL . Query ( ) . Get ( AccessTokenQueryParam ) != "" { return & AuthCreds { Type : AuthBearer , Password : r . URL . Query ( ) . Get ( AccessTokenQueryParam ) , } , nil } authHeader := r . Header . Get ( "Authorization" ) if authHeader == "" { return nil , trace . Wrap ( & AccessDeniedError { Message : "unauthorized" } ) } auth := strings . SplitN ( authHeader , " " , 2 ) if len ( auth ) != 2 { return nil , trace . Wrap ( & ParameterError { Name : "Authorization" , Message : "invalid auth header" } ) } switch auth [ 0 ] { case AuthBasic : payload , err := base64 . StdEncoding . DecodeString ( auth [ 1 ] ) if err != nil { return nil , trace . Wrap ( & ParameterError { Name : "Authorization" , Message : err . Error ( ) } ) } pair := strings . SplitN ( string ( payload ) , ":" , 2 ) if len ( pair ) != 2 { return nil , trace . Wrap ( & ParameterError { Name : "Authorization" , Message : "bad header" } ) } return & AuthCreds { Type : AuthBasic , Username : pair [ 0 ] , Password : pair [ 1 ] } , nil case AuthBearer : return & AuthCreds { Type : AuthBearer , Password : auth [ 1 ] } , nil } return nil , trace . Wrap ( & ParameterError { Name : "Authorization" , Message : "unsupported auth scheme" } ) }
6723	func Tracer ( newTracer NewTracer ) ClientParam { return func ( c * Client ) error { c . newTracer = newTracer return nil } }
6724	func HTTPClient ( h * http . Client ) ClientParam { return func ( c * Client ) error { c . client = h return nil } }
6725	func BasicAuth ( username , password string ) ClientParam { return func ( c * Client ) error { c . auth = & basicAuth { username : username , password : password } return nil } }
6726	func BearerAuth ( token string ) ClientParam { return func ( c * Client ) error { c . auth = & bearerAuth { token : token } return nil } }
6727	func CookieJar ( jar http . CookieJar ) ClientParam { return func ( c * Client ) error { c . jar = jar return nil } }
6728	func SanitizerEnabled ( sanitizerEnabled bool ) ClientParam { return func ( c * Client ) error { c . sanitizerEnabled = sanitizerEnabled return nil } }
6729	func ( c * Client ) OpenFile ( ctx context . Context , endpoint string , params url . Values ) ( ReadSeekCloser , error ) { if c . sanitizerEnabled { err := isPathSafe ( endpoint ) if err != nil { return nil , err } } u , err := url . Parse ( endpoint ) if err != nil { return nil , err } u . RawQuery = params . Encode ( ) return newSeeker ( c , ctx , u . String ( ) ) }
6730	func ( c * Client ) RoundTrip ( fn RoundTripFn ) ( * Response , error ) { re , err := fn ( ) if err != nil { return nil , err } defer re . Body . Close ( ) buf := & bytes . Buffer { } _ , err = io . Copy ( buf , re . Body ) if err != nil { return nil , err } return & Response { code : re . StatusCode , headers : re . Header , body : buf , cookies : re . Cookies ( ) , } , nil }
6731	func ( c * Client ) SetAuthHeader ( h http . Header ) { if c . auth != nil { h . Set ( "Authorization" , c . auth . String ( ) ) } }
6732	func ( r * FileResponse ) FileName ( ) string { value := r . headers . Get ( "Content-Disposition" ) if len ( value ) == 0 { return "" } _ , params , err := mime . ParseMediaType ( value ) if err != nil { return "" } return params [ "filename" ] }
6733	func newBuffersFromFiles ( files [ ] File ) [ ] fileBuffer { buffers := make ( [ ] fileBuffer , 0 , len ( files ) ) for _ , file := range files { buffers = append ( buffers , newFileBuffer ( file ) ) } return buffers }
6734	func newFileBuffer ( file File ) fileBuffer { buf := & bytes . Buffer { } return fileBuffer { Reader : io . TeeReader ( file . Reader , buf ) , File : file , cache : buf , } }
6735	func ( r * fileBuffer ) rewind ( ) { r . Reader = io . MultiReader ( r . cache , r . File . Reader ) }
6736	func ConvertResponse ( re * Response , err error ) ( * Response , error ) { if err != nil { if uerr , ok := err . ( * url . Error ) ; ok && uerr != nil && uerr . Err != nil { return nil , trace . Wrap ( uerr . Err ) } return nil , trace . Wrap ( err ) } return re , trace . ReadError ( re . Code ( ) , re . Bytes ( ) ) }
6737	func ( o * BoolOption ) Set ( s string ) error { err := convertString ( s , & o . Value ) if err != nil { return err } o . Source = "override" o . Defined = true return nil }
6738	func ( o * BoolOption ) WriteAnswer ( name string , value interface { } ) error { if v , ok := value . ( bool ) ; ok { o . Value = v o . Defined = true o . Source = "prompt" return nil } return fmt . Errorf ( "Got %T expected %T type: %v" , value , o . Value , value ) }
6739	func ( o BoolOption ) String ( ) string { if StringifyValue { return fmt . Sprintf ( "%v" , o . Value ) } return fmt . Sprintf ( "{Source:%s Defined:%t Value:%v}" , o . Source , o . Defined , o . Value ) }
6740	func TriggerIncidentKey ( description string , key string ) ( incidentKey string , err error ) { return trigger ( description , key , map [ string ] interface { } { } ) }
6741	func TriggerWithDetails ( description string , details map [ string ] interface { } ) ( incidentKey string , err error ) { return trigger ( description , "" , details ) }
6742	func TriggerIncidentKeyWithDetails ( description string , key string , details map [ string ] interface { } ) ( incidentKey string , err error ) { return trigger ( description , key , details ) }
6743	func Merge ( dst , src interface { } ) { m := NewMerger ( ) m . mergeStructs ( reflect . ValueOf ( dst ) , reflect . ValueOf ( src ) ) }
6744	func ( m * Merger ) setSource ( v reflect . Value ) { if v . Kind ( ) == reflect . Ptr { v = v . Elem ( ) } switch v . Kind ( ) { case reflect . Map : for _ , key := range v . MapKeys ( ) { keyval := v . MapIndex ( key ) if keyval . Kind ( ) == reflect . Struct && keyval . FieldByName ( "Source" ) . IsValid ( ) { newval := reflect . New ( keyval . Type ( ) ) newval . Elem ( ) . Set ( keyval ) m . setSource ( newval ) v . SetMapIndex ( key , newval . Elem ( ) ) } } case reflect . Struct : if v . CanAddr ( ) { if option , ok := v . Addr ( ) . Interface ( ) . ( option ) ; ok { if option . IsDefined ( ) { option . SetSource ( m . sourceFile ) } return } } for i := 0 ; i < v . NumField ( ) ; i ++ { structField := v . Type ( ) . Field ( i ) if structField . PkgPath != "" { continue } m . setSource ( v . Field ( i ) ) } case reflect . Array : fallthrough case reflect . Slice : for i := 0 ; i < v . Len ( ) ; i ++ { m . setSource ( v . Index ( i ) ) } } }
6745	func convertString ( src string , dst interface { } ) ( err error ) { switch v := dst . ( type ) { case * bool : * v , err = strconv . ParseBool ( src ) case * string : * v = src case * int : var tmp int64 tmp , err = strconv . ParseInt ( src , 10 , 32 ) * v = int ( tmp ) case * int8 : var tmp int64 tmp , err = strconv . ParseInt ( src , 10 , 8 ) * v = int8 ( tmp ) case * int16 : var tmp int64 tmp , err = strconv . ParseInt ( src , 10 , 16 ) * v = int16 ( tmp ) case * int32 : var tmp int64 tmp , err = strconv . ParseInt ( src , 10 , 32 ) * v = int32 ( tmp ) case * int64 : var tmp int64 tmp , err = strconv . ParseInt ( src , 10 , 64 ) * v = int64 ( tmp ) case * uint : var tmp uint64 tmp , err = strconv . ParseUint ( src , 10 , 32 ) * v = uint ( tmp ) case * uint8 : var tmp uint64 tmp , err = strconv . ParseUint ( src , 10 , 8 ) * v = uint8 ( tmp ) case * uint16 : var tmp uint64 tmp , err = strconv . ParseUint ( src , 10 , 16 ) * v = uint16 ( tmp ) case * uint32 : var tmp uint64 tmp , err = strconv . ParseUint ( src , 10 , 32 ) * v = uint32 ( tmp ) case * uint64 : var tmp uint64 tmp , err = strconv . ParseUint ( src , 10 , 64 ) * v = uint64 ( tmp ) case * float32 : var tmp float64 tmp , err = strconv . ParseFloat ( src , 32 ) * v = float32 ( tmp ) case * float64 : var tmp float64 tmp , err = strconv . ParseFloat ( src , 64 ) * v = float64 ( tmp ) default : err = fmt . Errorf ( "Cannot convert string %q to type %T" , src , dst ) } if err != nil { return err } return nil }
6746	func Do ( d DB , f func ( t Tx ) error ) error { t , err := d . TxBegin ( ) if err != nil { return err } defer t . TxFinish ( ) err = f ( t ) if err != nil { return err } return t . TxCommit ( ) }
6747	func NewFile ( filename string ) io . Writer { if err , _ := os . Open ( filename ) ; err != nil { os . Remove ( filename ) } file , _ := os . Create ( filename ) return file }
6748	func ( b * Bench ) internalRun ( showProgress bool ) results . ResultSet { startTime := time . Now ( ) endTime := startTime . Add ( b . duration ) sem := semaphore . NewSemaphore ( b . threads , b . rampUp ) out := make ( chan results . Result ) resultsChan := make ( chan [ ] results . Result ) go handleResult ( showProgress , out , resultsChan ) for run := true ; run ; run = ( time . Now ( ) . Before ( endTime ) ) { sem . Lock ( ) go doRequest ( b . request , b . timeout , sem , out ) } fmt . Print ( "\nWaiting for threads to finish " ) \n for i := sem . Length ( ) ; i != 0 ; i = sem . Length ( ) { time . Sleep ( 200 * time . Millisecond ) } fmt . Println ( " OK" ) fmt . Println ( "" ) close ( out ) }
6749	func ( r Row ) String ( ) string { rStr := fmt . Sprintf ( "Start Time: %v\n" , \n ) r . StartTime . UTC ( ) rStr = fmt . Sprintf ( "%vElapsed Time: %v\n" , \n , rStr ) r . ElapsedTime rStr = fmt . Sprintf ( "%vThreads: %v\n" , \n , rStr ) r . Threads rStr = fmt . Sprintf ( "%vTotal Requests: %v\n" , \n , rStr ) r . TotalRequests }
6750	func ( t * TabularResults ) Tabulate ( results [ ] ResultSet ) [ ] Row { var rows [ ] Row startTime := time . Unix ( 0 , 0 ) for _ , bucket := range results { if len ( bucket ) > 0 { var elapsedTime time . Duration if startTime == time . Unix ( 0 , 0 ) { startTime = bucket [ 0 ] . Timestamp } elapsedTime = bucket [ 0 ] . Timestamp . Sub ( startTime ) row := Row { StartTime : bucket [ 0 ] . Timestamp , ElapsedTime : elapsedTime , Threads : 0 , TotalRequests : 0 , TotalFailures : 0 , TotalSuccess : 0 , TotalTimeouts : 0 , AvgRequestTime : 0 , } totalRequestTime := 0 * time . Second maxThreads := 0 for _ , r := range bucket { row . TotalRequests ++ if r . Error != nil { if _ , ok := r . Error . ( errors . Timeout ) ; ok { row . TotalTimeouts ++ } row . TotalFailures ++ } else { row . TotalSuccess ++ totalRequestTime += r . RequestTime } if r . Threads > maxThreads { maxThreads = r . Threads row . Threads = maxThreads } } if totalRequestTime != 0 && row . TotalSuccess != 0 { avgTime := int64 ( totalRequestTime ) / int64 ( row . TotalSuccess ) row . AvgRequestTime = time . Duration ( avgTime ) } rows = append ( rows , row ) } } return rows }
6751	func AmazonRequest ( ) error { resp , err := http . Get ( "http://www.amazon.co.uk/" ) defer func ( response * http . Response ) { if response != nil && response . Body != nil { response . Body . Close ( ) } } ( resp ) if err != nil || resp . StatusCode != 200 { return err } return nil }
6752	func WriteTabularData ( interval time . Duration , r results . ResultSet , w io . Writer ) { set := r . Reduce ( interval ) t := results . TabularResults { } rows := t . Tabulate ( set ) for _ , row := range rows { w . Write ( [ ] byte ( row . String ( ) ) ) w . Write ( [ ] byte ( "\n" ) ) } }
6753	func ( r ResultSet ) Reduce ( interval time . Duration ) [ ] ResultSet { sort . Sort ( r ) start := r [ 0 ] . Timestamp end := r [ len ( r ) - 1 ] . Timestamp bucketCount := getBucketCount ( start , end , interval ) buckets := make ( [ ] ResultSet , bucketCount ) for _ , result := range r { currentBucket := getBucketNumber ( result . Timestamp , start , end , interval , bucketCount ) buckets [ currentBucket ] = append ( buckets [ currentBucket ] , result ) } return buckets }
6754	func NewSemaphore ( capacity int , rampUp time . Duration ) * Semaphore { s := Semaphore { lockDone : make ( chan struct { } ) , lockLock : make ( chan struct { } ) , rampUp : rampUp , } if rampUp < 1 { s . s = make ( chan struct { } , capacity ) } else { s . s = make ( chan struct { } , 1 ) go s . rampUpThreads ( capacity , rampUp ) } s . resizeUnlock ( ) return & s }
6755	func ( t * Semaphore ) Release ( ) { t . waitIfResizing ( ) t . readMutex . RLock ( ) defer t . readMutex . RUnlock ( ) if len ( t . s ) == 0 { return } <- t . s }
6756	func ( t * Semaphore ) Resize ( capacity int ) { t . resizeMutex . Lock ( ) if capacity == cap ( t . s ) { t . resizeMutex . Unlock ( ) return } t . resizeLock ( ) t . readMutex . Lock ( ) defer t . resizeUnlock ( ) defer t . resizeMutex . Unlock ( ) defer t . readMutex . Unlock ( ) new := make ( chan struct { } , capacity ) for n := len ( t . s ) ; n != 0 ; n = len ( t . s ) { new <- <- t . s } t . s = new }
6757	func ( b * Bench ) AddOutput ( interval time . Duration , writer io . Writer , output output . OutputFunc ) { o := outputContainer { interval : interval , writer : writer , function : output , } b . outputs = append ( b . outputs , o ) }
6758	func ( b * Bench ) RunBenchmarks ( r RequestFunc ) { b . request = r results := b . internalRun ( b . showProgress ) b . processResults ( results ) }
6759	func parseBool ( bytes [ ] byte ) ( ret bool , err error ) { if len ( bytes ) != 1 { err = asn1 . SyntaxError { Msg : "invalid boolean" } return } switch bytes [ 0 ] { case 0 : ret = false case 0xff : ret = true default : err = asn1 . SyntaxError { Msg : "invalid boolean" } } return }
6760	func checkInteger ( bytes [ ] byte ) error { if len ( bytes ) == 0 { return asn1 . StructuralError { Msg : "empty integer" } } if len ( bytes ) == 1 { return nil } if ( bytes [ 0 ] == 0 && bytes [ 1 ] & 0x80 == 0 ) || ( bytes [ 0 ] == 0xff && bytes [ 1 ] & 0x80 == 0x80 ) { return asn1 . StructuralError { Msg : "integer not minimally-encoded" } } return nil }
6761	func parseInt64 ( bytes [ ] byte ) ( ret int64 , err error ) { err = checkInteger ( bytes ) if err != nil { return } if len ( bytes ) > 8 { err = asn1 . StructuralError { Msg : "integer too large" } return } for bytesRead := 0 ; bytesRead < len ( bytes ) ; bytesRead ++ { ret <<= 8 ret |= int64 ( bytes [ bytesRead ] ) } ret <<= 64 - uint8 ( len ( bytes ) ) * 8 ret >>= 64 - uint8 ( len ( bytes ) ) * 8 return }
6762	func parseInt32 ( bytes [ ] byte ) ( int32 , error ) { if err := checkInteger ( bytes ) ; err != nil { return 0 , err } ret64 , err := parseInt64 ( bytes ) if err != nil { return 0 , err } if ret64 != int64 ( int32 ( ret64 ) ) { return 0 , asn1 . StructuralError { Msg : "integer too large" } } return int32 ( ret64 ) , nil }
6763	func parseBigInt ( bytes [ ] byte ) ( * big . Int , error ) { if err := checkInteger ( bytes ) ; err != nil { return nil , err } ret := new ( big . Int ) if len ( bytes ) > 0 && bytes [ 0 ] & 0x80 == 0x80 { notBytes := make ( [ ] byte , len ( bytes ) ) for i := range notBytes { notBytes [ i ] = ^ bytes [ i ] } ret . SetBytes ( notBytes ) ret . Add ( ret , bigOne ) ret . Neg ( ret ) return ret , nil } ret . SetBytes ( bytes ) return ret , nil }
6764	func parseBitString ( bytes [ ] byte ) ( ret asn1 . BitString , err error ) { if len ( bytes ) == 0 { err = asn1 . SyntaxError { Msg : "zero length BIT STRING" } return } paddingBits := int ( bytes [ 0 ] ) if paddingBits > 7 || len ( bytes ) == 1 && paddingBits > 0 || bytes [ len ( bytes ) - 1 ] & ( ( 1 << bytes [ 0 ] ) - 1 ) != 0 { err = asn1 . SyntaxError { Msg : "invalid padding bits in BIT STRING" } return } ret . BitLength = ( len ( bytes ) - 1 ) * 8 - paddingBits ret . Bytes = bytes [ 1 : ] return }
6765	func parseObjectIdentifier ( bytes [ ] byte ) ( s [ ] int , err error ) { if len ( bytes ) == 0 { err = asn1 . SyntaxError { Msg : "zero length OBJECT IDENTIFIER" } return } s = make ( [ ] int , len ( bytes ) + 1 ) v , offset , err := _parseBase128Int ( bytes , 0 ) if err != nil { return } if v < 80 { s [ 0 ] = v / 40 s [ 1 ] = v % 40 } else { s [ 0 ] = 2 s [ 1 ] = v - 80 } i := 2 for ; offset < len ( bytes ) ; i ++ { v , offset , err = _parseBase128Int ( bytes , offset ) if err != nil { return } s [ i ] = v } s = s [ 0 : i ] return }
6766	func parseBase128Int ( bytes [ ] byte , initOffset int ) ( ret , offset int , err error ) { ret , offset , err = _parseBase128Int ( bytes , initOffset ) if offset - initOffset >= 4 { err = asn1 . StructuralError { Msg : "base 128 integer too large" } return } return }
6767	func parseGeneralizedTime ( bytes [ ] byte ) ( ret time . Time , err error ) { const formatStr = "20060102150405Z0700" s := string ( bytes ) if ret , err = time . Parse ( formatStr , s ) ; err != nil { return } if serialized := ret . Format ( formatStr ) ; serialized != s { err = fmt . Errorf ( "asn1: time did not serialize back to the original value and may be invalid: given %q, but serialized as %q" , s , serialized ) } return }
6768	func parsePrintableString ( bytes [ ] byte ) ( ret string , err error ) { for _ , b := range bytes { if ! isPrintable ( b ) { err = asn1 . SyntaxError { Msg : "PrintableString contains invalid character" } return } } ret = string ( bytes ) return }
6769	func isPrintable ( b byte ) bool { return 'a' <= b && b <= 'z' || 'A' <= b && b <= 'Z' || '0' <= b && b <= '9' || '\'' <= b && b <= ')' || '+' <= b && b <= '/' || b == ' ' || b == ':' || b == '=' || b == '?' || b == '*' }
6770	func parseSequenceOf ( bytes [ ] byte , sliceType reflect . Type , elemType reflect . Type ) ( ret reflect . Value , err error ) { expectedTag , compoundType , ok := getUniversalType ( elemType ) if ! ok { err = asn1 . StructuralError { Msg : "unknown Go type for slice" } return } numElements := 0 for offset := 0 ; offset < len ( bytes ) ; { var t tagAndLength t , offset , err = parseTagAndLength ( bytes , offset ) if err != nil { return } switch t . tag { case tagIA5String , tagGeneralString , tagT61String , tagUTF8String : t . tag = tagPrintableString case tagGeneralizedTime , tagUTCTime : t . tag = tagUTCTime } if t . class != classUniversal || t . isCompound != compoundType || t . tag != expectedTag { err = asn1 . StructuralError { Msg : "sequence tag mismatch" } return } if invalidLength ( offset , t . length , len ( bytes ) ) { err = asn1 . SyntaxError { Msg : "truncated sequence" } return } offset += t . length numElements ++ } ret = reflect . MakeSlice ( sliceType , numElements , numElements ) params := fieldParameters { } offset := 0 for i := 0 ; i < numElements ; i ++ { offset , err = parseField ( ret . Index ( i ) , bytes , offset , params ) if err != nil { return } } return }
6771	func invalidLength ( offset , length , sliceLength int ) bool { return offset + length < offset || offset + length > sliceLength }
6772	func setDefaultValue ( v reflect . Value , params fieldParameters ) ( ok bool ) { if ! params . optional { return } ok = true if params . defaultValue == nil { return } if canHaveDefaultValue ( v . Kind ( ) ) { v . SetInt ( * params . defaultValue ) } return }
6773	func UnmarshalWithParams ( b [ ] byte , val interface { } , params string ) ( rest [ ] byte , err error ) { v := reflect . ValueOf ( val ) . Elem ( ) offset , err := parseField ( v , b , 0 , parseFieldParameters ( params ) ) if err != nil { return nil , err } return b [ offset : ] , nil }
6774	func parseFieldParameters ( str string ) ( ret fieldParameters ) { for _ , part := range strings . Split ( str , "," ) { switch { case part == "optional" : ret . optional = true case part == "explicit" : ret . explicit = true if ret . tag == nil { ret . tag = new ( int ) } case part == "generalized" : ret . timeType = tagGeneralizedTime case part == "utc" : ret . timeType = tagUTCTime case part == "ia5" : ret . stringType = tagIA5String case part == "printable" : ret . stringType = tagPrintableString case part == "utf8" : ret . stringType = tagUTF8String case strings . HasPrefix ( part , "default:" ) : i , err := strconv . ParseInt ( part [ 8 : ] , 10 , 64 ) if err == nil { ret . defaultValue = new ( int64 ) * ret . defaultValue = i } case strings . HasPrefix ( part , "tag:" ) : i , err := strconv . Atoi ( part [ 4 : ] ) if err == nil { ret . tag = new ( int ) * ret . tag = i } case part == "set" : ret . set = true case part == "application" : ret . application = true if ret . tag == nil { ret . tag = new ( int ) } case part == "omitempty" : ret . omitEmpty = true } } return }
6775	func getUniversalType ( t reflect . Type ) ( tagNumber int , isCompound , ok bool ) { switch t { case objectIdentifierType : return tagOID , false , true case bitStringType : return tagBitString , false , true case timeType : return tagUTCTime , false , true case enumeratedType : return tagEnum , false , true case bigIntType : return tagInteger , false , true } switch t . Kind ( ) { case reflect . Bool : return tagBoolean , false , true case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : return tagInteger , false , true case reflect . Struct : return tagSequence , true , true case reflect . Slice : if t . Elem ( ) . Kind ( ) == reflect . Uint8 { return tagOctetString , false , true } if strings . HasSuffix ( t . Name ( ) , "SET" ) { return tagSet , true , true } return tagSequence , true , true case reflect . String : return tagPrintableString , false , true } return 0 , false , false }
6776	func DecodeString ( raw string ) ( [ ] byte , error ) { pad := 8 - ( len ( raw ) % 8 ) nb := [ ] byte ( raw ) if pad != 8 { nb = make ( [ ] byte , len ( raw ) + pad ) copy ( nb , raw ) for i := 0 ; i < pad ; i ++ { nb [ len ( raw ) + i ] = '=' } } return lowerBase32 . DecodeString ( string ( nb ) ) }
6777	func ( m MongoDb ) MailNotifier ( ctxt string ) ( models . MailNotifier , error ) { c := m . Connect ( models . COLL_NAME_MAIL_NOTIFIER ) defer m . Close ( c ) var notifier [ ] models . MailNotifier if err := c . Find ( nil ) . All ( & notifier ) ; err != nil || len ( notifier ) == 0 { logger . Get ( ) . Error ( "%s-Unable to read MailNotifier from DB: %v" , ctxt , err ) return models . MailNotifier { } , ErrMissingNotifier } else { return notifier [ 0 ] , nil } }
6778	func ( m MongoDb ) SaveMailNotifier ( ctxt string , notifier models . MailNotifier ) error { c := m . Connect ( models . COLL_NAME_MAIL_NOTIFIER ) defer m . Close ( c ) _ , err := c . Upsert ( bson . M { } , bson . M { "$set" : notifier } ) if err != nil { logger . Get ( ) . Error ( "%s-Error Updating the mail notifier info for: %s Error: %v" , ctxt , notifier . MailId , err ) return errors . New ( fmt . Sprintf ( "Error Updating the mail notifier info for: %s Error: %v" , notifier . MailId , err ) ) } return nil }
6779	func RegisterProvider ( name string , factory ProvidersFactory ) { providersMutex . Lock ( ) defer providersMutex . Unlock ( ) if _ , found := providers [ name ] ; found { logger . Get ( ) . Critical ( "Auth provider %s was registered twice" , name ) } providers [ name ] = factory }
6780	func ( m MongoDb ) InitDb ( ) error { if err := m . InitUser ( ) ; err != nil { logger . Get ( ) . Error ( "Error Initilaizing User Table" , err ) return err } return nil }
6781	func Until ( f func ( ) , period time . Duration , stopCh <- chan struct { } ) { for { select { case <- stopCh : return default : } func ( ) { defer HandleCrash ( ) f ( ) } ( ) time . Sleep ( period ) } }
6782	func logPanic ( r interface { } ) { callers := "" for i := 0 ; true ; i ++ { _ , file , line , ok := runtime . Caller ( i ) if ! ok { break } callers = callers + fmt . Sprintf ( "%v:%v\n" , \n , file ) } line }
6783	func ( m MongoDb ) User ( username string ) ( user models . User , e error ) { c := m . Connect ( models . COLL_NAME_USER ) defer m . Close ( c ) err := c . Find ( bson . M { "username" : username } ) . One ( & user ) if err != nil { return user , ErrMissingUser } return user , nil }
6784	func ( m MongoDb ) Users ( filter interface { } ) ( us [ ] models . User , e error ) { c := m . Connect ( models . COLL_NAME_USER ) defer m . Close ( c ) err := c . Find ( filter ) . All ( & us ) if err != nil { logger . Get ( ) . Error ( "Error getting record from DB. error: %v" , err ) return us , mkmgoerror ( err . Error ( ) ) } return us , nil }
6785	func ( m MongoDb ) SaveUser ( user models . User ) error { c := m . Connect ( models . COLL_NAME_USER ) defer m . Close ( c ) _ , err := c . Upsert ( bson . M { "username" : user . Username } , bson . M { "$set" : user } ) if err != nil { logger . Get ( ) . Error ( "Error deleting record from DB for user: %s. error: %v" , user . Username , err ) return mkmgoerror ( err . Error ( ) ) } return nil }
6786	func ( m MongoDb ) DeleteUser ( username string ) error { c := m . Connect ( models . COLL_NAME_USER ) defer m . Close ( c ) err := c . Remove ( bson . M { "username" : username } ) if err != nil { logger . Get ( ) . Error ( "Error deleting record from DB for user: %s. error: %v" , username , err ) return mkmgoerror ( err . Error ( ) ) } return err }
6787	func LoadCACertFile ( cert string ) ( * x509 . CertPool , error ) { ca , err := ioutil . ReadFile ( cert ) if err != nil { return nil , fmt . Errorf ( "could not load CA Certificate: %s " , err . Error ( ) ) } certPool := x509 . NewCertPool ( ) if err := certPool . AppendCertsFromPEM ( ca ) ; ! err { return nil , errors . New ( "could not append CA Certificate to CertPool" ) } return certPool , nil }
6788	func NewAuth ( opts ... Options ) * Auth { o := Options { } if len ( opts ) != 0 { o = opts [ 0 ] } h := defaultAuthErrorHandler if o . AuthErrorHandler != nil { h = o . AuthErrorHandler } return & Auth { opt : o , authErrHandler : http . HandlerFunc ( h ) , } }
6789	func ( a * Auth ) ValidateRequest ( r * http . Request ) error { if r . TLS == nil || r . TLS . VerifiedChains == nil { return errors . New ( "no cert chain detected" ) } if r . TLS . PeerCertificates != nil { if ! bytes . Equal ( r . TLS . PeerCertificates [ 0 ] . Raw , r . TLS . VerifiedChains [ 0 ] [ 0 ] . Raw ) { return errors . New ( "first peer certificate not first verified chain leaf" ) } } return nil }
6790	func ( a * Auth ) Process ( w http . ResponseWriter , r * http . Request ) error { if err := a . ValidateRequest ( r ) ; err != nil { return err } if len ( a . opt . AllowedOUs ) > 0 { err := a . ValidateOU ( r . TLS . VerifiedChains [ 0 ] [ 0 ] ) if err != nil { a . authErrHandler . ServeHTTP ( w , r ) return err } } if len ( a . opt . AllowedCNs ) > 0 { err := a . ValidateCN ( r . TLS . VerifiedChains [ 0 ] [ 0 ] ) if err != nil { a . authErrHandler . ServeHTTP ( w , r ) return err } } return nil }
6791	func ( a * Auth ) ValidateCN ( verifiedCert * x509 . Certificate ) error { var failed [ ] string for _ , cn := range a . opt . AllowedCNs { if cn == verifiedCert . Subject . CommonName { return nil } failed = append ( failed , verifiedCert . Subject . CommonName ) } return fmt . Errorf ( "cert failed CN validation for %v, Allowed: %v" , failed , a . opt . AllowedCNs ) }
6792	func ( a * Auth ) ValidateOU ( verifiedCert * x509 . Certificate ) error { var failed [ ] string for _ , ou := range a . opt . AllowedOUs { for _ , clientOU := range verifiedCert . Subject . OrganizationalUnit { if ou == clientOU { return nil } failed = append ( failed , clientOU ) } } return fmt . Errorf ( "cert failed OU validation for %v, Allowed: %v" , failed , a . opt . AllowedOUs ) }
6793	func KeyLen ( x uint64 ) int { n := 1 if x >= 1 << 32 { x >>= 32 n += 4 } if x >= 1 << 16 { x >>= 16 n += 2 } if x >= 1 << 8 { x >>= 8 n += 1 } return n }
6794	func DefaultConfig ( ) Config { newClientConfig := vaultclient . DefaultConfig ( ) newClientConfig . Address = "http://127.0.0.1:8200" newVaultClient , err := vaultclient . NewClient ( newClientConfig ) if err != nil { panic ( err ) } newConfig := Config { VaultClient : newVaultClient , } return newConfig }
6795	func New ( config Config ) ( spec . CertSigner , error ) { newCertSigner := & certSigner { Config : config , } if newCertSigner . VaultClient == nil { return nil , microerror . Maskf ( invalidConfigError , "Vault client must not be empty" ) } return newCertSigner , nil }
6796	func New ( config Config ) ( spec . VaultFactory , error ) { newVaultFactory := & vaultFactory { Config : config , } if newVaultFactory . Address == "" { return nil , microerror . Maskf ( invalidConfigError , "Vault address must not be empty" ) } if newVaultFactory . AdminToken == "" { return nil , microerror . Maskf ( invalidConfigError , "Vault admin token must not be empty" ) } return newVaultFactory , nil }
6797	func DefaultServiceConfig ( ) ServiceConfig { newClientConfig := vaultclient . DefaultConfig ( ) newClientConfig . Address = "http://127.0.0.1:8200" newVaultClient , err := vaultclient . NewClient ( newClientConfig ) if err != nil { panic ( err ) } newConfig := ServiceConfig { VaultClient : newVaultClient , } return newConfig }
6798	func NewService ( config ServiceConfig ) ( Service , error ) { if config . VaultClient == nil { return nil , microerror . Maskf ( invalidConfigError , "Vault client must not be empty" ) } newService := & service { ServiceConfig : config , } return newService , nil }
6799	func ( s * service ) Delete ( clusterID string ) error { sysBackend := s . VaultClient . Sys ( ) mounted , err := s . IsMounted ( clusterID ) if err != nil { return microerror . Mask ( err ) } if mounted { err = sysBackend . Unmount ( s . MountPKIPath ( clusterID ) ) if err != nil { return microerror . Mask ( err ) } } return nil }
6800	func IsNoVaultHandlerDefined ( err error ) bool { cause := microerror . Cause ( err ) if cause != nil && strings . Contains ( cause . Error ( ) , "no handler for route" ) { return true } return false }
6801	func New ( config Config ) ( Service , error ) { if config . VaultClient == nil { return nil , microerror . Maskf ( invalidConfigError , "Vault client must not be empty" ) } if config . PKIMountpoint == "" { return nil , microerror . Maskf ( invalidConfigError , "PKIMountpoint must not be empty" ) } service := & service { vaultClient : config . VaultClient , pkiMountpoint : config . PKIMountpoint , } return service , nil }
6802	func ( s * service ) Create ( params CreateParams ) error { logicalStore := s . vaultClient . Logical ( ) data := map [ string ] interface { } { "allowed_domains" : params . AllowedDomains , "allow_subdomains" : params . AllowSubdomains , "ttl" : params . TTL , "allow_bare_domains" : params . AllowBareDomains , "organization" : params . Organizations , } _ , err := logicalStore . Write ( fmt . Sprintf ( "%s/roles/%s" , s . pkiMountpoint , params . Name ) , data ) if err != nil { return microerror . Mask ( err ) } return nil }
6803	func CreateJob ( ) Config { return Config { LockProvider : nil , RuntimeProcessor : nil , ResultProcessor : nil , RuntimeProcessingFrequency : 200 * time . Millisecond , SummaryBuffer : 1 , } }
6804	func ( config * Config ) Run ( ) { err := config . ensureLock ( ) if err != nil { panic ( err ) } err = config . runWorker ( ) if err != nil { panic ( err ) } }
6805	func newWatcher ( dir_notify bool , initpaths ... string ) ( w * Watcher ) { w = new ( Watcher ) w . auto_watch = dir_notify w . paths = make ( map [ string ] * watchItem , 0 ) var paths [ ] string for _ , path := range initpaths { matches , err := filepath . Glob ( path ) if err != nil { continue } paths = append ( paths , matches ... ) } if dir_notify { w . syncAddPaths ( paths ... ) } else { for _ , path := range paths { w . paths [ path ] = watchPath ( path ) } } return }
6806	func ( w * Watcher ) Start ( ) <- chan * Notification { if w . notify_chan != nil { return w . notify_chan } if w . auto_watch { w . add_chan = make ( chan * watchItem , NotificationBufLen ) go w . watchItemListener ( ) } w . notify_chan = make ( chan * Notification , NotificationBufLen ) go w . watch ( w . notify_chan ) return w . notify_chan }
6807	func ( w * Watcher ) Stop ( ) { if w . notify_chan != nil { close ( w . notify_chan ) } if w . add_chan != nil { close ( w . add_chan ) } }
6808	func ( w * Watcher ) Active ( ) bool { return w . paths != nil && len ( w . paths ) > 0 }
6809	func ( w * Watcher ) Add ( inpaths ... string ) { var paths [ ] string for _ , path := range inpaths { matches , err := filepath . Glob ( path ) if err != nil { continue } paths = append ( paths , matches ... ) } if w . auto_watch && w . notify_chan != nil { for _ , path := range paths { wi := watchPath ( path ) w . addPaths ( wi ) } } else if w . auto_watch { w . syncAddPaths ( paths ... ) } else { for _ , path := range paths { w . paths [ path ] = watchPath ( path ) } } }
6810	func ( w * Watcher ) watch ( sndch chan <- * Notification ) { defer func ( ) { recover ( ) } ( ) for { <- time . After ( WatchDelay ) for _ , wi := range w . paths { if wi . Update ( ) && w . shouldNotify ( wi ) { sndch <- wi . Notification ( ) } if wi . LastEvent == NOEXIST && w . auto_watch { delete ( w . paths , wi . Path ) } if len ( w . paths ) == 0 { w . Stop ( ) } } } }
6811	func ( w * Watcher ) Watching ( ) ( paths [ ] string ) { paths = make ( [ ] string , 0 ) for path , _ := range w . paths { paths = append ( paths , path ) } return }
6812	func ( w * Watcher ) State ( ) ( state [ ] Notification ) { state = make ( [ ] Notification , 0 ) if w . paths == nil { return } for _ , wi := range w . paths { state = append ( state , * wi . Notification ( ) ) } return }
6813	func Store ( r * http . Request , err error ) { errptr , ok := r . Context ( ) . Value ( errorKey ) . ( * error ) if ! ok { panic ( "hatpear: request not configured to store errors" ) } if err != nil { * errptr = err } }
6814	func Get ( r * http . Request ) error { errptr , ok := r . Context ( ) . Value ( errorKey ) . ( * error ) if ! ok { return nil } return * errptr }
6815	func Catch ( h func ( w http . ResponseWriter , r * http . Request , err error ) ) Middleware { return func ( next http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { var err error ctx := context . WithValue ( r . Context ( ) , errorKey , & err ) next . ServeHTTP ( w , r . WithContext ( ctx ) ) if err != nil { h ( w , r , err ) } } ) } }
6816	func Try ( h Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { err := h . ServeHTTP ( w , r ) Store ( r , err ) } ) }
6817	func Recover ( ) Middleware { return func ( next http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { defer func ( ) { if v := recover ( ) ; v != nil { Store ( r , PanicError { value : v , stack : stack ( 1 ) , } ) } } ( ) next . ServeHTTP ( w , r ) } ) } }
6818	func main ( ) { req , _ := http . NewRequest ( "GET" , "http://localhost:7070/sync" , nil ) req . Header . Set ( "Accept" , "text/event-stream" ) resp , err := http . DefaultClient . Do ( req ) if err != nil { log . Fatalf ( "request: %s" , err ) } r := resp . Body i := 0 buff := make ( [ ] byte , 32 * 1024 ) for { n , err := r . Read ( buff ) if err != nil { break } i ++ log . Printf ( "#%d: %s" , i , sizestr . ToString ( int64 ( n ) ) ) } r . Close ( ) log . Printf ( "closed" ) }
6819	func SyncHandler ( gostruct interface { } ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { if conn , err := Sync ( gostruct , w , r ) ; err != nil { log . Printf ( "[velox] sync handler error: %s" , err ) } else { conn . Wait ( ) } } ) }
6820	func ( c * conn ) connect ( w http . ResponseWriter , r * http . Request ) error { if r . Header . Get ( "Accept" ) == "text/event-stream" { c . transport = & eventSourceTransport { writeTimeout : c . state . WriteTimeout } } else if r . Header . Get ( "Upgrade" ) == "websocket" { c . transport = & websocketsTransport { writeTimeout : c . state . WriteTimeout } } else { return fmt . Errorf ( "Invalid sync request" ) } if err := c . transport . connect ( w , r ) ; err != nil { return err } if err := c . send ( & update { Ping : true } ) ; err != nil { return fmt . Errorf ( "Failed to send initial event" ) } c . connected = true c . waiter . Add ( 1 ) go func ( ) { for { select { case <- time . After ( c . state . PingInterval ) : if err := c . send ( & update { Ping : true } ) ; err != nil { goto disconnected } case <- c . connectedCh : goto disconnected } } disconnected : c . connected = false c . Close ( ) c . waiter . Done ( ) } ( ) go func ( ) { if err := c . transport . wait ( ) ; err != nil { } close ( c . connectedCh ) } ( ) return nil }
6821	func ( c * conn ) send ( upd * update ) error { c . sendingMut . Lock ( ) defer c . sendingMut . Unlock ( ) return c . transport . send ( upd ) }
6822	func ( s * State ) NumConnections ( ) int { s . connMut . Lock ( ) n := len ( s . conns ) s . connMut . Unlock ( ) return n }
6823	func ( s * State ) Push ( ) bool { if atomic . CompareAndSwapUint32 ( & s . push . ing , 0 , 1 ) { go s . gopush ( ) return true } atomic . StoreUint32 ( & s . push . queued , 1 ) return false }
6824	func ( s * State ) gopush ( ) { s . push . mut . Lock ( ) t0 := time . Now ( ) defer func ( ) { tdelta := time . Now ( ) . Sub ( t0 ) if t := s . Throttle - tdelta ; t > 0 { time . Sleep ( t ) } s . push . mut . Unlock ( ) atomic . StoreUint32 ( & s . push . ing , 0 ) if atomic . CompareAndSwapUint32 ( & s . push . queued , 1 , 0 ) { s . Push ( ) } } ( ) l , hasLock := s . gostruct . ( sync . Locker ) if hasLock { l . Lock ( ) } newBytes , err := json . Marshal ( s . gostruct ) if hasLock { l . Unlock ( ) } if err != nil { log . Printf ( "velox: marshal failed: %s" , err ) return } if ! bytes . Equal ( s . data . bytes , newBytes ) { ops , _ := jsonpatch . CreatePatch ( s . data . bytes , newBytes ) if len ( s . data . bytes ) > 0 && len ( ops ) > 0 { s . data . mut . Lock ( ) s . data . delta , _ = json . Marshal ( ops ) s . data . bytes = newBytes s . data . version ++ s . data . mut . Unlock ( ) } } s . connMut . Lock ( ) for _ , c := range s . conns { if c . version != s . data . version { go c . push ( ) } } s . connMut . Unlock ( ) }
6825	func NewOutForward ( configServers [ ] * ConfigServer ) ( * OutForward , error ) { loggers := make ( [ ] * fluent . Fluent , len ( configServers ) ) for i , server := range configServers { logger , err := fluent . New ( fluent . Config { Server : server . Address ( ) } ) if err != nil { log . Println ( "[warning]" , err ) } else { log . Println ( "[info] Server" , server . Address ( ) , "connected" ) } loggers [ i ] = logger logger . Send ( [ ] byte { } ) } return & OutForward { loggers : loggers , sent : 0 , } , nil }
6826	func ( t * InTail ) Run ( c * Context ) { c . InputProcess . Add ( 1 ) defer c . InputProcess . Done ( ) t . messageCh = c . MessageCh t . monitorCh = c . MonitorCh c . StartProcess . Done ( ) if t . eventCh == nil { err := t . TailStdin ( c ) if err != nil { if _ , ok := err . ( Signal ) ; ok { log . Println ( "[info]" , err ) } else { log . Println ( "[error]" , err ) } return } } log . Println ( "[info] Trying trail file" , t . filename ) f , err := t . newTrailFile ( SEEK_TAIL , c ) if err != nil { if _ , ok := err . ( Signal ) ; ok { log . Println ( "[info]" , err ) } else { log . Println ( "[error]" , err ) } return } for { for { err := t . watchFileEvent ( f , c ) if err != nil { if _ , ok := err . ( Signal ) ; ok { log . Println ( "[info]" , err ) return } else { log . Println ( "[warning]" , err ) break } } } var err error f , err = t . newTrailFile ( SEEK_HEAD , c ) if err != nil { if _ , ok := err . ( Signal ) ; ok { log . Println ( "[info]" , err ) } else { log . Println ( "[error]" , err ) } return } } }
6827	func New ( config Config ) ( f * Fluent , err error ) { if config . Server == "" { config . Server = defaultServer } if config . Timeout == 0 { config . Timeout = defaultTimeout } if config . RetryWait == 0 { config . RetryWait = defaultRetryWait } if config . MaxRetry == 0 { config . MaxRetry = defaultMaxRetry } f = & Fluent { Config : config , reconnecting : false , cancelReconnect : make ( chan bool ) , } err = f . connect ( ) return }
6828	func ( f * Fluent ) Close ( ) ( err error ) { if f . conn != nil { f . mu . Lock ( ) defer f . mu . Unlock ( ) } else { return } if f . conn != nil { f . conn . Close ( ) f . conn = nil } return }
6829	func ( f * Fluent ) IsReconnecting ( ) bool { f . mu . Lock ( ) defer f . mu . Unlock ( ) return f . reconnecting }
6830	func ( f * Fluent ) connect ( ) ( err error ) { host , port , err := net . SplitHostPort ( f . Server ) if err != nil { return err } addrs , err := net . LookupHost ( host ) if err != nil || len ( addrs ) == 0 { return err } n := Rand . Intn ( len ( addrs ) ) addr := addrs [ n ] var format string if strings . Contains ( addr , ":" ) { format = "[%s]:%s" } else { format = "%s:%s" } resolved := fmt . Sprintf ( format , addr , port ) log . Printf ( "[info] Connect to %s (%s)" , f . Server , resolved ) f . conn , err = net . DialTimeout ( "tcp" , resolved , f . Config . Timeout ) f . recordError ( err ) return }
6831	func Notification ( title , message string ) GNotifier { config := & Config { title , message , 5000 , "" } n := & notifier { Config : config } return n }
6832	func NullNotification ( title , message string ) GNotifier { config := & Config { title , message , 5000 , "" } n := & nullNotifier { Config : config } return n }
6833	func New ( opts ... Option ) * Identity { c := & configuration { } for _ , opt := range opts { option ( opt ) ( c ) } return c . generate ( ) }
6834	func ( id * Identity ) Issue ( opts ... Option ) * Identity { opts = append ( opts , Issuer ( id ) ) return New ( opts ... ) }
6835	func Subject ( value pkix . Name ) Option { return func ( c * configuration ) { c . subject = & value } }
6836	func PrivateKey ( value crypto . Signer ) Option { return func ( c * configuration ) { c . priv = & value } }
6837	func NotBefore ( value time . Time ) Option { return func ( c * configuration ) { c . notBefore = & value } }
6838	func NotAfter ( value time . Time ) Option { return func ( c * configuration ) { c . notAfter = & value } }
6839	func IssuingCertificateURL ( value ... string ) Option { return func ( c * configuration ) { c . issuingCertificateURL = append ( c . issuingCertificateURL , value ... ) } }
6840	func OCSPServer ( value ... string ) Option { return func ( c * configuration ) { c . ocspServer = append ( c . ocspServer , value ... ) } }
6841	func New ( apiKey string ) ( * TelegramBotAPI , error ) { toReturn := TelegramBotAPI { Updates : make ( chan BotUpdate ) , baseURIs : createEndpoints ( fmt . Sprintf ( apiBaseURI , apiKey ) ) , closed : make ( chan struct { } ) , c : newClient ( fmt . Sprintf ( apiBaseURI , apiKey ) ) , updateC : newClient ( fmt . Sprintf ( apiBaseURI , apiKey ) ) , } user , err := toReturn . GetMe ( ) if err != nil { return nil , err } toReturn . ID = user . User . ID toReturn . Name = user . User . FirstName toReturn . Username = * user . User . Username err = toReturn . removeWebhook ( ) if err != nil { return nil , err } toReturn . wg . Add ( 1 ) go toReturn . updateLoop ( ) return & toReturn , nil }
6842	func NewWithWebhook ( apiKey , webhookURL , certificate string ) ( * TelegramBotAPI , http . HandlerFunc , error ) { toReturn := TelegramBotAPI { Updates : make ( chan BotUpdate ) , baseURIs : createEndpoints ( fmt . Sprintf ( apiBaseURI , apiKey ) ) , closed : make ( chan struct { } ) , c : newClient ( fmt . Sprintf ( apiBaseURI , apiKey ) ) , updateC : newClient ( fmt . Sprintf ( apiBaseURI , apiKey ) ) , } user , err := toReturn . GetMe ( ) if err != nil { return nil , nil , err } toReturn . ID = user . User . ID toReturn . Name = user . User . FirstName toReturn . Username = * user . User . Username file , err := os . Open ( certificate ) if err != nil { return nil , nil , err } err = toReturn . setWebhook ( webhookURL , certificate , file ) if err != nil { return nil , nil , err } updateFunc := func ( w http . ResponseWriter , r * http . Request ) { bytes , err := ioutil . ReadAll ( r . Body ) if err != nil { toReturn . Updates <- BotUpdate { err : err } return } update := & Update { } err = json . Unmarshal ( bytes , update ) if err != nil { toReturn . Updates <- BotUpdate { err : err } return } toReturn . Updates <- BotUpdate { update : * update } } return & toReturn , updateFunc , nil }
6843	func ( api * TelegramBotAPI ) Close ( ) { select { case <- api . closed : return default : } close ( api . closed ) api . wg . Wait ( ) }
6844	func ( api * TelegramBotAPI ) GetMe ( ) ( * UserResponse , error ) { resp := & UserResponse { } _ , err := api . c . get ( getMe , resp ) if err != nil { return nil , err } err = check ( & resp . baseResponse ) if err != nil { return nil , err } return resp , nil }
6845	func RunBot ( apiKey string , bot BotFunc , name , description string ) { closing := make ( chan struct { } ) fmt . Printf ( "%s: %s\n" , \n , name ) description fmt . Println ( "Starting..." ) api , err := tbotapi . New ( apiKey ) if err != nil { log . Fatal ( err ) } fmt . Printf ( "User ID: %d\n" , \n ) api . ID fmt . Printf ( "Bot Name: %s\n" , \n ) api . Name fmt . Printf ( "Bot Username: %s\n" , \n ) api . Username closed := make ( chan struct { } ) wg := & sync . WaitGroup { } wg . Add ( 1 ) go func ( ) { defer wg . Done ( ) for { select { case <- closed : return case update := <- api . Updates : if update . Error ( ) != nil { fmt . Printf ( "Update error: %s\n" , \n ) update . Error ( ) } continue } } } bot ( update . Update ( ) , api ) ( ) shutdown := make ( chan os . Signal ) signal . Notify ( shutdown , syscall . SIGINT , syscall . SIGTERM ) go func ( ) { <- shutdown close ( closing ) } ( ) fmt . Println ( "Bot started. Press CTRL-C to close..." ) }
6846	func RunBotOnWebhook ( apiKey string , bot BotFunc , name , description , webhookHost string , webhookPort uint16 , pubkey , privkey string ) { closing := make ( chan struct { } ) fmt . Printf ( "%s: %s\n" , \n , name ) description fmt . Println ( "Starting..." ) u := url . URL { Host : webhookHost + ":" + fmt . Sprint ( webhookPort ) , Scheme : "https" , Path : apiKey , } api , handler , err := tbotapi . NewWithWebhook ( apiKey , u . String ( ) , pubkey ) if err != nil { log . Fatal ( err ) } fmt . Printf ( "User ID: %d\n" , \n ) api . ID fmt . Printf ( "Bot Name: %s\n" , \n ) api . Name fmt . Printf ( "Bot Username: %s\n" , \n ) api . Username closed := make ( chan struct { } ) wg := & sync . WaitGroup { } wg . Add ( 1 ) go func ( ) { defer wg . Done ( ) for { select { case <- closed : return case update := <- api . Updates : if update . Error ( ) != nil { fmt . Printf ( "Update error: %s\n" , \n ) update . Error ( ) } continue } } } bot ( update . Update ( ) , api ) ( ) http . HandleFunc ( "/" + apiKey , handler ) fmt . Println ( "Starting webhook..." ) go func ( ) { log . Fatal ( http . ListenAndServeTLS ( "0.0.0.0:" + fmt . Sprint ( webhookPort ) , pubkey , privkey , nil ) ) } ( ) shutdown := make ( chan os . Signal ) signal . Notify ( shutdown , syscall . SIGINT , syscall . SIGTERM ) go func ( ) { <- shutdown close ( closing ) } ( ) fmt . Println ( "Bot started. Press CTRL-C to close..." ) }
6847	func ( api * TelegramBotAPI ) NewOutgoingMessage ( recipient Recipient , text string ) * OutgoingMessage { return & OutgoingMessage { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , Text : text , ParseMode : ModeDefault , } }
6848	func ( api * TelegramBotAPI ) NewOutgoingLocation ( recipient Recipient , latitude , longitude float32 ) * OutgoingLocation { return & OutgoingLocation { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , Latitude : latitude , Longitude : longitude , } }
6849	func ( api * TelegramBotAPI ) NewOutgoingVenue ( recipient Recipient , latitude , longitude float32 , title , address string ) * OutgoingVenue { return & OutgoingVenue { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , Latitude : latitude , Longitude : longitude , Title : title , Address : address , } }
6850	func ( api * TelegramBotAPI ) NewOutgoingVideo ( recipient Recipient , fileName string , reader io . Reader ) * OutgoingVideo { return & OutgoingVideo { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , outgoingFileBase : outgoingFileBase { fileName : fileName , r : reader , } , } }
6851	func ( api * TelegramBotAPI ) NewOutgoingVideoResend ( recipient Recipient , fileID string ) * OutgoingVideo { return & OutgoingVideo { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , outgoingFileBase : outgoingFileBase { fileID : fileID , } , } }
6852	func ( api * TelegramBotAPI ) NewOutgoingPhoto ( recipient Recipient , fileName string , reader io . Reader ) * OutgoingPhoto { return & OutgoingPhoto { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , outgoingFileBase : outgoingFileBase { fileName : fileName , r : reader , } , } }
6853	func ( api * TelegramBotAPI ) NewOutgoingPhotoResend ( recipient Recipient , fileID string ) * OutgoingPhoto { return & OutgoingPhoto { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , outgoingFileBase : outgoingFileBase { fileID : fileID , } , } }
6854	func ( api * TelegramBotAPI ) NewOutgoingSticker ( recipient Recipient , fileName string , reader io . Reader ) * OutgoingSticker { return & OutgoingSticker { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , outgoingFileBase : outgoingFileBase { fileName : fileName , r : reader , } , } }
6855	func ( api * TelegramBotAPI ) NewOutgoingStickerResend ( recipient Recipient , fileID string ) * OutgoingSticker { return & OutgoingSticker { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , outgoingFileBase : outgoingFileBase { fileID : fileID , } , } }
6856	func ( api * TelegramBotAPI ) NewOutgoingVoice ( recipient Recipient , fileName string , reader io . Reader ) * OutgoingVoice { return & OutgoingVoice { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , outgoingFileBase : outgoingFileBase { fileName : fileName , r : reader , } , } }
6857	func ( api * TelegramBotAPI ) NewOutgoingVoiceResend ( recipient Recipient , fileID string ) * OutgoingVoice { return & OutgoingVoice { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , outgoingFileBase : outgoingFileBase { fileID : fileID , } , } }
6858	func ( api * TelegramBotAPI ) NewOutgoingAudio ( recipient Recipient , fileName string , reader io . Reader ) * OutgoingAudio { return & OutgoingAudio { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , outgoingFileBase : outgoingFileBase { fileName : fileName , r : reader , } , } }
6859	func ( api * TelegramBotAPI ) NewOutgoingAudioResend ( recipient Recipient , fileID string ) * OutgoingAudio { return & OutgoingAudio { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , outgoingFileBase : outgoingFileBase { fileID : fileID , } , } }
6860	func ( api * TelegramBotAPI ) NewOutgoingDocument ( recipient Recipient , fileName string , reader io . Reader ) * OutgoingDocument { return & OutgoingDocument { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , outgoingFileBase : outgoingFileBase { fileName : fileName , r : reader , } , } }
6861	func ( api * TelegramBotAPI ) NewOutgoingDocumentResend ( recipient Recipient , fileID string ) * OutgoingDocument { return & OutgoingDocument { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , outgoingFileBase : outgoingFileBase { fileID : fileID , } , } }
6862	func ( api * TelegramBotAPI ) NewOutgoingForward ( recipient Recipient , origin Chat , messageID int ) * OutgoingForward { return & OutgoingForward { outgoingMessageBase : outgoingMessageBase { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , } , FromChatID : NewRecipientFromChat ( origin ) , MessageID : messageID , } }
6863	func ( api * TelegramBotAPI ) NewOutgoingChatAction ( recipient Recipient , action ChatAction ) * OutgoingChatAction { return & OutgoingChatAction { outgoingBase : outgoingBase { api : api , Recipient : recipient , } , Action : action , } }
6864	func ( api * TelegramBotAPI ) NewOutgoingUserProfilePhotosRequest ( userID int ) * OutgoingUserProfilePhotosRequest { return & OutgoingUserProfilePhotosRequest { api : api , UserID : userID , } }
6865	func ( api * TelegramBotAPI ) NewOutgoingKickChatMember ( chat Recipient , userID int ) * OutgoingKickChatMember { return & OutgoingKickChatMember { api : api , Recipient : chat , UserID : userID , } }
6866	func ( api * TelegramBotAPI ) NewOutgoingUnbanChatMember ( chat Recipient , userID int ) * OutgoingUnbanChatMember { return & OutgoingUnbanChatMember { api : api , Recipient : chat , UserID : userID , } }
6867	func ( api * TelegramBotAPI ) NewOutgoingCallbackQueryResponse ( queryID string ) * OutgoingCallbackQueryResponse { return & OutgoingCallbackQueryResponse { api : api , CallbackQueryID : queryID , } }
6868	func ( api * TelegramBotAPI ) NewInlineQueryAnswer ( queryID string , results [ ] InlineQueryResult ) * InlineQueryAnswer { return & InlineQueryAnswer { api : api , QueryID : queryID , Results : results , } }
6869	func ( m * Message ) Type ( ) MessageType { if m . Text != nil { return TextMessage } else if m . Audio != nil { return AudioMessage } else if m . Document != nil { return DocumentMessage } else if m . Photo != nil { return PhotoMessage } else if m . Sticker != nil { return StickerMessage } else if m . Video != nil { return VideoMessage } else if m . Voice != nil { return VoiceMessage } else if m . Contact != nil { return ContactMessage } else if m . Location != nil { return LocationMessage } else if m . NewChatMember != nil { return NewChatMember } else if m . LeftChatMember != nil { return LeftChatMember } else if m . NewChatTitle != nil { return NewChatTitle } else if m . NewChatPhoto != nil { return NewChatPhoto } else if m . DeleteChatPhoto { return DeletedChatPhoto } else if m . GroupChatCreated { return GroupChatCreated } else if m . SupergroupChatCreated { return SupergroupChatCreated } else if m . ChannelChatCreated { return ChannelChatCreated } else if m . MigrateToChatID != nil { return MigrationToSupergroup } else if m . MigrateFromChatID != nil { return MigrationFromGroup } else if m . Venue != nil { return VenueMessage } else if m . PinnedMessage != nil { return PinnedMessage } return UnknownMessage }
6870	func ( u * Update ) Type ( ) UpdateType { if u . Message != nil { return MessageUpdate } else if u . InlineQuery != nil { return InlineQueryUpdate } else if u . ChosenInlineResult != nil { return ChosenInlineResultUpdate } return UnknownUpdate }
6871	func ( r Recipient ) MarshalJSON ( ) ( [ ] byte , error ) { toReturn := "" if r . isChannel ( ) { toReturn = fmt . Sprintf ( "\"%s\"" , \" ) } else \" * r . ChannelID }
6872	func ( ow * outgoingSetWebhook ) querystring ( ) querystring { toReturn := make ( map [ string ] string ) if ow . URL != "" { toReturn [ "url" ] = ow . URL } return querystring ( toReturn ) }
6873	func ( op * outgoingBase ) getBaseQueryString ( ) querystring { toReturn := map [ string ] string { } if op . Recipient . isChannel ( ) { toReturn [ "chat_id" ] = fmt . Sprint ( * op . Recipient . ChannelID ) } else { toReturn [ "chat_id" ] = fmt . Sprint ( * op . Recipient . ChatID ) } return querystring ( toReturn ) }
6874	func ( op * outgoingMessageBase ) getBaseQueryString ( ) querystring { toReturn := map [ string ] string { } if op . Recipient . isChannel ( ) { toReturn [ "chat_id" ] = fmt . Sprint ( * op . Recipient . ChannelID ) } else { toReturn [ "chat_id" ] = fmt . Sprint ( * op . Recipient . ChatID ) } if op . replyToMessageIDSet { toReturn [ "reply_to_message_id" ] = fmt . Sprint ( op . ReplyToMessageID ) } if op . replyMarkupSet { b , err := json . Marshal ( op . ReplyMarkup ) if err != nil { panic ( err ) } toReturn [ "reply_markup" ] = string ( b ) } if op . DisableNotification { toReturn [ "disable_notification" ] = fmt . Sprint ( op . DisableNotification ) } return querystring ( toReturn ) }
6875	func ( oa * OutgoingAudio ) querystring ( ) querystring { toReturn := map [ string ] string ( oa . getBaseQueryString ( ) ) if oa . Duration != 0 { toReturn [ "duration" ] = fmt . Sprint ( oa . Duration ) } if oa . Performer != "" { toReturn [ "performer" ] = oa . Performer } if oa . Title != "" { toReturn [ "title" ] = oa . Title } return querystring ( toReturn ) }
6876	func ( op * OutgoingPhoto ) querystring ( ) querystring { toReturn := map [ string ] string ( op . getBaseQueryString ( ) ) if op . Caption != "" { toReturn [ "caption" ] = op . Caption } return querystring ( toReturn ) }
6877	func ( op * OutgoingUserProfilePhotosRequest ) querystring ( ) querystring { toReturn := map [ string ] string { } toReturn [ "user_id" ] = fmt . Sprint ( op . UserID ) if op . Offset != 0 { toReturn [ "offset" ] = fmt . Sprint ( op . Offset ) } if op . Limit != 0 { toReturn [ "limit" ] = fmt . Sprint ( op . Limit ) } return querystring ( toReturn ) }
6878	func ( ov * OutgoingVideo ) querystring ( ) querystring { toReturn := map [ string ] string ( ov . getBaseQueryString ( ) ) if ov . Caption != "" { toReturn [ "caption" ] = ov . Caption } if ov . Duration != 0 { toReturn [ "duration" ] = fmt . Sprint ( ov . Duration ) } return querystring ( toReturn ) }
6879	func ( ov * OutgoingVoice ) querystring ( ) querystring { toReturn := map [ string ] string ( ov . getBaseQueryString ( ) ) if ov . Duration != 0 { toReturn [ "duration" ] = fmt . Sprint ( ov . Duration ) } return querystring ( toReturn ) }
6880	func NewInlineQueryResultArticle ( id , title , text string ) * InlineQueryResultArticle { return & InlineQueryResultArticle { InlineQueryResultBase : InlineQueryResultBase { Type : ArticleResult , ID : id , } , Title : title , Text : text , } }
6881	func NewInlineQueryResultPhoto ( id , photoURL , thumbURL string ) * InlineQueryResultPhoto { return & InlineQueryResultPhoto { InlineQueryResultBase : InlineQueryResultBase { Type : PhotoResult , ID : id , } , PhotoURL : photoURL , ThumbURL : thumbURL , } }
6882	func NewInlineQueryResultGif ( id , gifURL , thumbURL string ) * InlineQueryResultGif { return & InlineQueryResultGif { InlineQueryResultBase : InlineQueryResultBase { Type : GifResult , ID : id , } , GifURL : gifURL , ThumbURL : thumbURL , } }
6883	func NewInlineQueryResultMpeg4Gif ( id , mpeg4URL , thumbURL string ) * InlineQueryResultMpeg4Gif { return & InlineQueryResultMpeg4Gif { InlineQueryResultBase : InlineQueryResultBase { Type : PhotoResult , ID : id , } , Mpeg4URL : mpeg4URL , ThumbURL : thumbURL , } }
6884	func NewInlineQueryResultVideo ( id , videoURL , thumbURL , title , text string , mimeType MIMEType ) * InlineQueryResultVideo { return & InlineQueryResultVideo { InlineQueryResultBase : InlineQueryResultBase { Type : PhotoResult , ID : id , } , VideoURL : videoURL , MIMEType : mimeType , ThumbURL : thumbURL , Title : title , Text : text , } }
6885	func ( op * OutgoingUserProfilePhotosRequest ) Send ( ) ( * UserProfilePhotosResponse , error ) { resp := & UserProfilePhotosResponse { } _ , err := op . api . c . postJSON ( getUserProfilePhotos , resp , op ) if err != nil { return nil , err } err = check ( & resp . baseResponse ) if err != nil { return nil , err } return resp , nil }
6886	func ( oc * OutgoingChatAction ) Send ( ) error { resp := & baseResponse { } _ , err := oc . api . c . postJSON ( sendChatAction , resp , oc ) if err != nil { return err } return check ( resp ) }
6887	func ( ia * InlineQueryAnswer ) Send ( ) error { resp := & baseResponse { } _ , err := ia . api . c . postJSON ( answerInlineQuery , resp , ia ) if err != nil { return err } return check ( resp ) }
6888	func ( kr * OutgoingKickChatMember ) Send ( ) error { resp := & baseResponse { } _ , err := kr . api . c . postJSON ( kickChatMember , resp , kr ) if err != nil { return err } return check ( resp ) }
6889	func ( ub * OutgoingUnbanChatMember ) Send ( ) error { resp := & baseResponse { } _ , err := ub . api . c . postJSON ( unbanChatMember , resp , ub ) if err != nil { return err } return check ( resp ) }
6890	func ( cbr * OutgoingCallbackQueryResponse ) Send ( ) error { resp := & baseResponse { } _ , err := cbr . api . c . postJSON ( answerCallbackQuery , resp , cbr ) if err != nil { return err } return check ( resp ) }
6891	func NewAPIClient ( cfg * Configuration ) * APIClient { if cfg . HTTPClient == nil { cfg . HTTPClient = http . DefaultClient } c := & APIClient { } c . cfg = cfg c . common . client = c c . ServiceProviderConfigApi = ( * ServiceProviderConfigApiService ) ( & c . common ) c . UserApi = ( * UserApiService ) ( & c . common ) return c }
6892	func ( ts * TimeStamp ) BeforeInsert ( ) error { n := now ( ) ts . CreatedAt = n ts . UpdatedAt = n return nil }
6893	func ColumnName ( d Dialect , tname , cname string ) string { if cname != "*" { cname = d . Quote ( cname ) } if tname == "" { return cname } return fmt . Sprintf ( "%s.%s" , d . Quote ( tname ) , cname ) }
6894	func New ( dialect Dialect , dsn string ) ( * DB , error ) { db , err := sql . Open ( dialect . Name ( ) , dsn ) if err != nil { return nil , err } return & DB { db : db , dialect : dialect , logger : defaultLogger } , nil }
6895	func ( db * DB ) From ( arg interface { } ) * From { t := reflect . Indirect ( reflect . ValueOf ( arg ) ) . Type ( ) if t . Kind ( ) != reflect . Struct { panic ( fmt . Errorf ( "From: argument must be struct (or that pointer) type, got %v" , t ) ) } return & From { TableName : db . tableName ( t ) } }
6896	func ( db * DB ) Where ( cond interface { } , args ... interface { } ) * Condition { return newCondition ( db ) . Where ( cond , args ... ) }
6897	func ( db * DB ) OrderBy ( table interface { } , column interface { } , order ... interface { } ) * Condition { return newCondition ( db ) . OrderBy ( table , column , order ... ) }
6898	func ( db * DB ) Limit ( lim int ) * Condition { return newCondition ( db ) . Limit ( lim ) }
6899	func ( db * DB ) Offset ( offset int ) * Condition { return newCondition ( db ) . Offset ( offset ) }
6900	func ( db * DB ) Join ( table interface { } ) * JoinCondition { return ( & JoinCondition { db : db } ) . Join ( table ) }
6901	func ( db * DB ) Count ( column ... interface { } ) * Function { switch len ( column ) { case 0 , 1 : default : panic ( fmt . Errorf ( "Count: a number of argument must be 0 or 1, got %v" , len ( column ) ) ) } return & Function { Name : "COUNT" , Args : column , } }
6902	func ( db * DB ) Update ( obj interface { } ) ( affected int64 , err error ) { rv , rtype , tableName , err := db . tableValueOf ( "Update" , obj ) if err != nil { return - 1 , err } if hook , ok := obj . ( BeforeUpdater ) ; ok { if err := hook . BeforeUpdate ( ) ; err != nil { return - 1 , err } } fieldIndexes := db . collectFieldIndexes ( rtype , nil ) pkIdx := db . findPKIndex ( rtype , nil ) if len ( pkIdx ) < 1 { return - 1 , fmt . Errorf ( `Update: fields of struct doesn't have primary key: "pk" struct tag must be specified for update` ) } sets := make ( [ ] string , len ( fieldIndexes ) ) var args [ ] interface { } for i , index := range fieldIndexes { col := db . columnFromTag ( rtype . FieldByIndex ( index ) ) sets [ i ] = fmt . Sprintf ( "%s = %s" , db . dialect . Quote ( col ) , db . dialect . PlaceHolder ( i ) ) args = append ( args , rv . FieldByIndex ( index ) . Interface ( ) ) } query := fmt . Sprintf ( "UPDATE %s SET %s WHERE %s = %s" , db . dialect . Quote ( tableName ) , strings . Join ( sets , ", " ) , db . dialect . Quote ( db . columnFromTag ( rtype . FieldByIndex ( pkIdx ) ) ) , db . dialect . PlaceHolder ( len ( fieldIndexes ) ) ) args = append ( args , rv . FieldByIndex ( pkIdx ) . Interface ( ) ) stmt , err := db . prepare ( query , args ... ) if err != nil { return - 1 , err } defer stmt . Close ( ) result , err := stmt . Exec ( args ... ) if err != nil { return - 1 , err } affected , _ = result . RowsAffected ( ) if hook , ok := obj . ( AfterUpdater ) ; ok { if err := hook . AfterUpdate ( ) ; err != nil { return affected , err } } return affected , nil }
6903	func ( db * DB ) Delete ( obj interface { } ) ( affected int64 , err error ) { objs , rtype , tableName , err := db . tableObjs ( "Delete" , obj ) if err != nil { return - 1 , err } if len ( objs ) < 1 { return 0 , nil } for _ , obj := range objs { if hook , ok := obj . ( BeforeDeleter ) ; ok { if err := hook . BeforeDelete ( ) ; err != nil { return - 1 , err } } } pkIdx := db . findPKIndex ( rtype , nil ) if len ( pkIdx ) < 1 { return - 1 , fmt . Errorf ( `Delete: fields of struct doesn't have primary key: "pk" struct tag must be specified for delete` ) } var args [ ] interface { } for _ , obj := range objs { rv := reflect . Indirect ( reflect . ValueOf ( obj ) ) args = append ( args , rv . FieldByIndex ( pkIdx ) . Interface ( ) ) } holders := make ( [ ] string , len ( args ) ) for i := 0 ; i < len ( holders ) ; i ++ { holders [ i ] = db . dialect . PlaceHolder ( i ) } query := fmt . Sprintf ( "DELETE FROM %s WHERE %s IN (%s)" , db . dialect . Quote ( tableName ) , db . dialect . Quote ( db . columnFromTag ( rtype . FieldByIndex ( pkIdx ) ) ) , strings . Join ( holders , ", " ) ) stmt , err := db . prepare ( query , args ... ) if err != nil { return - 1 , err } defer stmt . Close ( ) result , err := stmt . Exec ( args ... ) if err != nil { return - 1 , err } affected , _ = result . RowsAffected ( ) for _ , obj := range objs { if hook , ok := obj . ( AfterDeleter ) ; ok { if err := hook . AfterDelete ( ) ; err != nil { return affected , err } } } return affected , nil }
6904	func ( db * DB ) Begin ( ) error { tx , err := db . db . Begin ( ) if err != nil { return err } db . m . Lock ( ) defer db . m . Unlock ( ) db . tx = tx return nil }
6905	func ( db * DB ) Commit ( ) error { db . m . Lock ( ) defer db . m . Unlock ( ) if db . tx == nil { return ErrTxDone } err := db . tx . Commit ( ) db . tx = nil return err }
6906	func ( db * DB ) Quote ( s string ) string { return db . dialect . Quote ( s ) }
6907	func ( db * DB ) SetLogOutput ( w io . Writer ) { if w == nil { db . logger = defaultLogger } else { db . logger = & templateLogger { w : w , t : defaultLoggerTemplate } } }
6908	func ( db * DB ) selectToSlice ( rows * sql . Rows , t reflect . Type ) ( reflect . Value , error ) { columns , err := rows . Columns ( ) if err != nil { return reflect . Value { } , err } t = t . Elem ( ) ptrN := 0 for ; t . Kind ( ) == reflect . Ptr ; ptrN ++ { t = t . Elem ( ) } fieldIndexes := make ( [ ] [ ] int , len ( columns ) ) for i , column := range columns { index := db . fieldIndexByName ( t , column , nil ) if len ( index ) < 1 { return reflect . Value { } , fmt . Errorf ( "`%v` field isn't defined in %v or embedded struct" , stringutil . ToUpperCamelCase ( column ) , t ) } fieldIndexes [ i ] = index } dest := make ( [ ] interface { } , len ( columns ) ) var result [ ] reflect . Value for rows . Next ( ) { v := reflect . New ( t ) . Elem ( ) for i , index := range fieldIndexes { field := v . FieldByIndex ( index ) dest [ i ] = field . Addr ( ) . Interface ( ) } if err := rows . Scan ( dest ... ) ; err != nil { return reflect . Value { } , err } result = append ( result , v ) } if err := rows . Err ( ) ; err != nil { return reflect . Value { } , err } for i := 0 ; i < ptrN ; i ++ { t = reflect . PtrTo ( t ) } slice := reflect . MakeSlice ( reflect . SliceOf ( t ) , len ( result ) , len ( result ) ) for i , v := range result { for j := 0 ; j < ptrN ; j ++ { v = v . Addr ( ) } slice . Index ( i ) . Set ( v ) } return slice , nil }
6909	func ( db * DB ) selectToValue ( rows * sql . Rows , t reflect . Type ) ( reflect . Value , error ) { ptrN := 0 for ; t . Kind ( ) == reflect . Ptr ; ptrN ++ { t = t . Elem ( ) } dest := reflect . New ( t ) . Elem ( ) if rows . Next ( ) { if err := rows . Scan ( dest . Addr ( ) . Interface ( ) ) ; err != nil { return reflect . Value { } , err } } for i := 0 ; i < ptrN ; i ++ { dest = dest . Addr ( ) } return dest , nil }
6910	func ( db * DB ) fieldIndexByName ( t reflect . Type , name string , index [ ] int ) [ ] int { for i := 0 ; i < t . NumField ( ) ; i ++ { field := t . Field ( i ) if candidate := db . columnFromTag ( field ) ; candidate == name { return append ( index , i ) } if field . Anonymous { if idx := db . fieldIndexByName ( field . Type , name , append ( index , i ) ) ; len ( idx ) > 0 { return append ( index , idx ... ) } } } return nil }
6911	func ( db * DB ) columns ( tableName string , columns [ ] interface { } ) string { if len ( columns ) == 0 { return ColumnName ( db . dialect , tableName , "*" ) } names := make ( [ ] string , len ( columns ) ) for i , col := range columns { switch c := col . ( type ) { case Raw : names [ i ] = fmt . Sprint ( * c ) case string : names [ i ] = ColumnName ( db . dialect , tableName , c ) case * Distinct : names [ i ] = fmt . Sprintf ( "DISTINCT %s" , db . columns ( tableName , ToInterfaceSlice ( c . columns ) ) ) default : panic ( fmt . Errorf ( "column name must be string, Raw or *Distinct, got %T" , c ) ) } } return strings . Join ( names , ", " ) }
6912	func ( db * DB ) tagsFromField ( field * reflect . StructField ) ( options [ ] string ) { if db . hasSkipTag ( field ) { return nil } for _ , tag := range strings . Split ( field . Tag . Get ( dbTag ) , "," ) { if t := strings . ToLower ( strings . TrimSpace ( tag ) ) ; t != "" { options = append ( options , t ) } } return options }
6913	func ( db * DB ) hasSkipTag ( field * reflect . StructField ) bool { if field . Tag . Get ( dbTag ) == skipTag { return true } return false }
6914	func ( db * DB ) hasPKTag ( field * reflect . StructField ) bool { for _ , tag := range db . tagsFromField ( field ) { if tag == "pk" { return true } } return false }
6915	func ( db * DB ) isAutoIncrementable ( field * reflect . StructField ) bool { switch field . Type . Kind ( ) { case reflect . Int , reflect . Int16 , reflect . Int32 , reflect . Int64 , reflect . Uint , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : return true } return false }
6916	func ( db * DB ) collectFieldIndexes ( typ reflect . Type , index [ ] int ) ( indexes [ ] [ ] int ) { for i := 0 ; i < typ . NumField ( ) ; i ++ { field := typ . Field ( i ) if IsUnexportedField ( field ) { continue } if ! ( db . hasSkipTag ( & field ) || ( db . hasPKTag ( & field ) && db . isAutoIncrementable ( & field ) ) ) { tmp := make ( [ ] int , len ( index ) + 1 ) copy ( tmp , index ) tmp [ len ( tmp ) - 1 ] = i if field . Anonymous { indexes = append ( indexes , db . collectFieldIndexes ( field . Type , tmp ) ... ) } else { indexes = append ( indexes , tmp ) } } } return indexes }
6917	func ( db * DB ) findPKIndex ( typ reflect . Type , index [ ] int ) [ ] int { for i := 0 ; i < typ . NumField ( ) ; i ++ { field := typ . Field ( i ) if IsUnexportedField ( field ) { continue } if field . Anonymous { if idx := db . findPKIndex ( field . Type , append ( index , i ) ) ; idx != nil { return append ( index , idx ... ) } continue } if db . hasPKTag ( & field ) { return append ( index , i ) } } return nil }
6918	func ( db * DB ) sizeFromTag ( field * reflect . StructField ) ( size uint64 , err error ) { if s := field . Tag . Get ( dbSizeTag ) ; s != "" { size , err = strconv . ParseUint ( s , 10 , 64 ) } return size , err }
6919	func ( db * DB ) columnFromTag ( field reflect . StructField ) string { col := field . Tag . Get ( dbColumnTag ) if col == "" { return stringutil . ToSnakeCase ( field . Name ) } return col }
6920	func ( db * DB ) defaultFromTag ( field * reflect . StructField ) ( string , error ) { def := field . Tag . Get ( dbDefaultTag ) if def == "" { return "" , nil } switch field . Type . Kind ( ) { case reflect . Bool : b , err := strconv . ParseBool ( def ) if err != nil { return "" , err } return fmt . Sprintf ( "DEFAULT %v" , db . dialect . FormatBool ( b ) ) , nil } return fmt . Sprintf ( "DEFAULT %v" , def ) , nil }
6921	func ( c * Condition ) Where ( cond interface { } , args ... interface { } ) * Condition { return c . appendQueryByCondOrExpr ( "Where" , 0 , Where , cond , args ... ) }
6922	func ( c * Condition ) And ( cond interface { } , args ... interface { } ) * Condition { return c . appendQueryByCondOrExpr ( "And" , 100 , And , cond , args ... ) }
6923	func ( c * Condition ) Or ( cond interface { } , args ... interface { } ) * Condition { return c . appendQueryByCondOrExpr ( "Or" , 100 , Or , cond , args ... ) }
6924	func ( c * Condition ) Like ( arg string ) * Condition { return c . appendQuery ( 100 , Like , arg ) }
6925	func ( c * Condition ) Between ( from , to interface { } ) * Condition { return c . appendQuery ( 100 , Between , & between { from , to } ) }
6926	func ( c * Condition ) OrderBy ( table , col interface { } , order ... interface { } ) * Condition { order = append ( [ ] interface { } { table , col } , order ... ) orderbys := make ( [ ] orderBy , 0 , 1 ) for len ( order ) > 0 { o , rest := order [ 0 ] , order [ 1 : ] if _ , ok := o . ( string ) ; ok { if len ( rest ) < 1 { panic ( fmt . Errorf ( "OrderBy: few arguments" ) ) } orderbys = append ( orderbys , c . orderBy ( nil , o , rest [ 0 ] ) ) order = rest [ 1 : ] continue } if len ( rest ) < 2 { panic ( fmt . Errorf ( "OrderBy: few arguments" ) ) } orderbys = append ( orderbys , c . orderBy ( o , rest [ 0 ] , rest [ 1 ] ) ) order = rest [ 2 : ] } return c . appendQuery ( 300 , OrderBy , orderbys ) }
6927	func ( c * Condition ) Limit ( lim int ) * Condition { return c . appendQuery ( 500 , Limit , lim ) }
6928	func ( c * Condition ) Offset ( offset int ) * Condition { return c . appendQuery ( 700 , Offset , offset ) }
6929	func ( l * templateLogger ) SetFormat ( format string ) error { l . m . Lock ( ) defer l . m . Unlock ( ) t , err := template . New ( "genmai" ) . Parse ( format ) if err != nil { return err } l . t = t return nil }
6930	func ( l * templateLogger ) Print ( start time . Time , query string , args ... interface { } ) error { if len ( args ) > 0 { values := make ( [ ] string , len ( args ) ) for i , arg := range args { values [ i ] = fmt . Sprintf ( "%#v" , arg ) } query = fmt . Sprintf ( "%v; [%v]" , query , strings . Join ( values , ", " ) ) } else { query = fmt . Sprintf ( "%s;" , query ) } data := map [ string ] interface { } { "time" : start , "duration" : fmt . Sprintf ( "%.2fms" , now ( ) . Sub ( start ) . Seconds ( ) * float64 ( time . Microsecond ) ) , "query" : query , } var buf bytes . Buffer if err := l . t . Execute ( & buf , data ) ; err != nil { return err } l . m . Lock ( ) defer l . m . Unlock ( ) if _ , err := fmt . Fprintln ( l . w , strings . TrimSuffix ( buf . String ( ) , "\n" ) ) ; \n err != nil { return err } }
6931	func ( l * nullLogger ) Print ( start time . Time , query string , args ... interface { } ) error { return nil }
6932	func ( d * MySQLDialect ) Quote ( s string ) string { return fmt . Sprintf ( "`%s`" , strings . Replace ( s , "`" , "``" , - 1 ) ) }
6933	func ( d * PostgresDialect ) SQLType ( v interface { } , autoIncrement bool , size uint64 ) ( name string , allowNull bool ) { switch v . ( type ) { case bool : return "boolean" , false case * bool , sql . NullBool : return "boolean" , true case int8 , int16 , uint8 , uint16 : return d . smallint ( autoIncrement ) , false case * int8 , * int16 , * uint8 , * uint16 : return d . smallint ( autoIncrement ) , true case int , int32 , uint , uint32 : return d . integer ( autoIncrement ) , false case * int , * int32 , * uint , * uint32 : return d . integer ( autoIncrement ) , true case int64 , uint64 : return d . bigint ( autoIncrement ) , false case * int64 , * uint64 , sql . NullInt64 : return d . bigint ( autoIncrement ) , true case string : return d . varchar ( size ) , false case * string , sql . NullString : return d . varchar ( size ) , true case [ ] byte : return "bytea" , true case time . Time : return "timestamp with time zone" , false case * time . Time : return "timestamp with time zone" , true case Rat : return fmt . Sprintf ( "numeric(%d, %d)" , decimalPrecision , decimalScale ) , false case * Rat : return fmt . Sprintf ( "numeric(%d, %d)" , decimalPrecision , decimalScale ) , true case Float32 , Float64 : return "double precision" , false case * Float32 , * Float64 : return "double precision" , true case float32 , * float32 , float64 , * float64 , sql . NullFloat64 : panic ( ErrUsingFloatType ) } panic ( fmt . Errorf ( "PostgresDialect: unsupported SQL type: %T" , v ) ) }
6934	func New ( file * os . File ) Archive { if filepath . Ext ( file . Name ( ) ) == ".zip" { return zip . New ( file ) } return tar . New ( file ) }
6935	func ( h * Host ) Disconnect ( ) { if h . handle == C . VIX_E_CANCELLED { return } if & h . handle != nil && h . handle != C . VIX_INVALID_HANDLE { C . VixHost_Disconnect ( h . handle ) h . handle = C . VIX_INVALID_HANDLE } }
6936	func ( v * VM ) nextNetworkAdapterID ( vmx map [ string ] string ) int { var nextID int prefix := "ethernet" for key := range vmx { if strings . HasPrefix ( key , prefix ) { ethN := strings . Split ( key , "." ) [ 0 ] number , _ := strconv . Atoi ( strings . Split ( ethN , prefix ) [ 1 ] ) if vmx [ ethN + ".present" ] == "FALSE" { return number } if number > nextID { nextID = number } } } nextID ++ return nextID }
6937	func ( v * VM ) totalNetworkAdapters ( vmx map [ string ] string ) int { var total int prefix := "ethernet" for key := range vmx { if strings . HasPrefix ( key , prefix ) { ethN := strings . Split ( key , "." ) [ 0 ] number , _ := strconv . Atoi ( strings . Split ( ethN , prefix ) [ 1 ] ) if number > total { total = number } } } return total }
6938	func ( v * VM ) RemoveAllNetworkAdapters ( ) error { vmxPath , err := v . VmxPath ( ) if err != nil { return err } vmx , err := readVmx ( vmxPath ) if err != nil { return err } for key := range vmx { if strings . HasPrefix ( key , "ethernet" ) { delete ( vmx , key ) } } return writeVmx ( vmxPath , vmx ) }
6939	func ( v * VM ) RemoveNetworkAdapter ( adapter * NetworkAdapter ) error { isVMRunning , err := v . IsRunning ( ) if err != nil { return err } if isVMRunning { return & Error { Operation : "vm.RemoveNetworkAdapter" , Code : 100000 , Text : "The VM has to be powered off in order to change its vmx settings" , } } vmxPath , err := v . VmxPath ( ) if err != nil { return err } vmx , err := readVmx ( vmxPath ) if err != nil { return err } device := "ethernet" + adapter . ID for key := range vmx { if strings . HasPrefix ( key , device ) { delete ( vmx , key ) } } vmx [ device + ".present" ] = "FALSE" err = writeVmx ( vmxPath , vmx ) if err != nil { return err } return nil }
6940	func ( v * VM ) NetworkAdapters ( ) ( [ ] * NetworkAdapter , error ) { vmxPath , err := v . VmxPath ( ) if err != nil { return nil , err } vmx , err := readVmx ( vmxPath ) if err != nil { return nil , err } var adapters [ ] * NetworkAdapter for i := 1 ; i <= v . totalNetworkAdapters ( vmx ) ; i ++ { id := strconv . Itoa ( i ) prefix := "ethernet" + id if vmx [ prefix + ".present" ] == "FALSE" { continue } wakeOnPckRcv , _ := strconv . ParseBool ( vmx [ prefix + ".wakeOnPcktRcv" ] ) lnkStateProp , _ := strconv . ParseBool ( vmx [ prefix + ".linkStatePropagation.enable" ] ) present , _ := strconv . ParseBool ( vmx [ prefix + ".present" ] ) startConnected , _ := strconv . ParseBool ( vmx [ prefix + ".startConnected" ] ) address , _ := net . ParseMAC ( vmx [ prefix + ".address" ] ) genAddress , _ := net . ParseMAC ( vmx [ prefix + ".generatedAddress" ] ) vswitch , _ := GetVSwitch ( vmx [ prefix + ".vnet" ] ) adapter := & NetworkAdapter { ID : id , present : present , ConnType : NetworkType ( vmx [ prefix + ".connectionType" ] ) , Vdevice : VNetDevice ( vmx [ prefix + ".virtualDev" ] ) , WakeOnPcktRcv : wakeOnPckRcv , LinkStatePropagation : lnkStateProp , MacAddrType : MacAddressType ( vmx [ prefix + ".addressType" ] ) , MacAddress : address , VSwitch : vswitch , StartConnected : startConnected , GeneratedMacAddress : genAddress , GeneratedMacAddressOffset : vmx [ prefix + ".generatedAddressOffset" ] , PciSlotNumber : vmx [ prefix + ".pciSlotNumber" ] , } adapters = append ( adapters , adapter ) } return adapters , nil }
6941	func newArchive ( path string , password * string ) ( * Archive , error ) { err := detect7zCached ( ) if err != nil { return nil , err } cmd := exec . Command ( "7z" , "l" , "-slt" , "-sccUTF-8" , path ) out , err := cmd . CombinedOutput ( ) if err != nil { return nil , err } entries , err := parse7zListOutput ( out ) if err != nil { return nil , err } return & Archive { Path : path , Entries : entries , password : password , } , nil }
6942	func ( a * Archive ) GetFileReader ( name string ) ( io . ReadCloser , error ) { found := false for _ , e := range a . Entries { if e . Path == name { found = true break } } if ! found { return nil , errors . New ( "file not in the archive" ) } params := [ ] string { "x" , "-so" } if a . password != nil { params = append ( params , fmt . Sprintf ( "-p%s" , * a . password ) ) } params = append ( params , a . Path , name ) cmd := exec . Command ( "7z" , params ... ) stdout , err := cmd . StdoutPipe ( ) rc := & readCloser { rc : stdout , cmd : cmd , } err = cmd . Start ( ) if err != nil { stdout . Close ( ) return nil , err } return rc , nil }
6943	func ( a * Archive ) ExtractToWriter ( dst io . Writer , name string ) error { r , err := a . GetFileReader ( name ) if err != nil { return err } _ , err = io . Copy ( dst , r ) err2 := r . Close ( ) if err != nil { return err } return err2 }
6944	func ( a * Archive ) ExtractToFile ( dstPath string , name string ) error { f , err := os . Create ( dstPath ) if err != nil { return err } defer f . Close ( ) return a . ExtractToWriter ( f , name ) }
6945	func ( g * Guest ) SharedFoldersParentDir ( ) ( string , error ) { var err C . VixError = C . VIX_OK var path * C . char err = C . get_property ( g . handle , C . VIX_PROPERTY_GUEST_SHAREDFOLDERS_SHARES_PATH , unsafe . Pointer ( & path ) ) defer C . Vix_FreeBuffer ( unsafe . Pointer ( path ) ) if C . VIX_OK != err { return "" , & Error { Operation : "guest.SharedFoldersParentDir" , Code : int ( err & 0xFFFF ) , Text : C . GoString ( C . Vix_GetErrorText ( err , nil ) ) , } } return C . GoString ( path ) , nil }
6946	func ( s * Snapshot ) Name ( ) ( string , error ) { var err C . VixError = C . VIX_OK var name * C . char err = C . get_property ( s . handle , C . VIX_PROPERTY_SNAPSHOT_DISPLAYNAME , unsafe . Pointer ( & name ) ) defer C . Vix_FreeBuffer ( unsafe . Pointer ( name ) ) if C . VIX_OK != err { return "" , & Error { Operation : "snapshot.Name" , Code : int ( err & 0xFFFF ) , Text : C . GoString ( C . Vix_GetErrorText ( err , nil ) ) , } } return C . GoString ( name ) , nil }
6947	func ( s * Snapshot ) Description ( ) ( string , error ) { var err C . VixError = C . VIX_OK var desc * C . char err = C . get_property ( s . handle , C . VIX_PROPERTY_SNAPSHOT_DESCRIPTION , unsafe . Pointer ( & desc ) ) defer C . Vix_FreeBuffer ( unsafe . Pointer ( desc ) ) if C . VIX_OK != err { return "" , & Error { Operation : "snapshot.Description" , Code : int ( err & 0xFFFF ) , Text : C . GoString ( C . Vix_GetErrorText ( err , nil ) ) , } } return C . GoString ( desc ) , nil }
6948	func cleanupSnapshot ( s * Snapshot ) { if s . handle != C . VIX_INVALID_HANDLE { C . Vix_ReleaseHandle ( s . handle ) s . handle = C . VIX_INVALID_HANDLE } }
6949	func BusTypeFromID ( ID string ) vmx . BusType { var bus vmx . BusType switch { case strings . HasPrefix ( ID , string ( vmx . IDE ) ) : bus = vmx . IDE case strings . HasPrefix ( ID , string ( vmx . SCSI ) ) : bus = vmx . SCSI case strings . HasPrefix ( ID , string ( vmx . SATA ) ) : bus = vmx . SATA } return bus }
6950	func ( vmxfile * VMXFile ) Read ( ) error { data , err := ioutil . ReadFile ( vmxfile . path ) if err != nil { return err } model := new ( vmx . VirtualMachine ) err = vmx . Unmarshal ( data , model ) if err != nil { return err } vmxfile . model = model return nil }
6951	func ( vmxfile * VMXFile ) Write ( ) error { file , err := os . Create ( vmxfile . path ) if err != nil { return err } defer file . Close ( ) data , err := vmx . Marshal ( vmxfile . model ) if err != nil { return err } _ , err = file . Write ( data ) if err != nil { return err } return nil }
6952	func NewVirtualMachine ( handle C . VixHandle , vmxpath string ) ( * VM , error ) { vmxfile := & VMXFile { path : vmxpath , } err := vmxfile . Read ( ) if err != nil { return nil , err } vm := & VM { handle : handle , vmxfile : vmxfile , } runtime . SetFinalizer ( vm , cleanupVM ) return vm , nil }
6953	func ( v * VM ) Vcpus ( ) ( uint8 , error ) { var err C . VixError = C . VIX_OK vcpus := C . VIX_PROPERTY_NONE err = C . get_property ( v . handle , C . VIX_PROPERTY_VM_NUM_VCPUS , unsafe . Pointer ( & vcpus ) ) if C . VIX_OK != err { return 0 , & Error { Operation : "vm.Vcpus" , Code : int ( err & 0xFFFF ) , Text : C . GoString ( C . Vix_GetErrorText ( err , nil ) ) , } } return uint8 ( vcpus ) , nil }
6954	func ( v * VM ) VmxPath ( ) ( string , error ) { var err C . VixError = C . VIX_OK var path * C . char err = C . get_property ( v . handle , C . VIX_PROPERTY_VM_VMX_PATHNAME , unsafe . Pointer ( & path ) ) defer C . Vix_FreeBuffer ( unsafe . Pointer ( path ) ) if C . VIX_OK != err { return "" , & Error { Operation : "vm.VmxPath" , Code : int ( err & 0xFFFF ) , Text : C . GoString ( C . Vix_GetErrorText ( err , nil ) ) , } } return C . GoString ( path ) , nil }
6955	func ( v * VM ) MemorySize ( ) ( uint , error ) { var err C . VixError = C . VIX_OK memsize := C . VIX_PROPERTY_NONE err = C . get_property ( v . handle , C . VIX_PROPERTY_VM_MEMORY_SIZE , unsafe . Pointer ( & memsize ) ) if C . VIX_OK != err { return 0 , & Error { Operation : "vm.MemorySize" , Code : int ( err & 0xFFFF ) , Text : C . GoString ( C . Vix_GetErrorText ( err , nil ) ) , } } return uint ( memsize ) , nil }
6956	func ( v * VM ) ReadOnly ( ) ( bool , error ) { var err C . VixError = C . VIX_OK readonly := C . VIX_PROPERTY_NONE err = C . get_property ( v . handle , C . VIX_PROPERTY_VM_READ_ONLY , unsafe . Pointer ( & readonly ) ) if C . VIX_OK != err { return false , & Error { Operation : "vm.ReadOnly" , Code : int ( err & 0xFFFF ) , Text : C . GoString ( C . Vix_GetErrorText ( err , nil ) ) , } } if readonly == 0 { return false , nil } return true , nil }
6957	func ( v * VM ) InVMTeam ( ) ( bool , error ) { var err C . VixError = C . VIX_OK inTeam := C . VIX_PROPERTY_NONE err = C . get_property ( v . handle , C . VIX_PROPERTY_VM_IN_VMTEAM , unsafe . Pointer ( & inTeam ) ) if C . VIX_OK != err { return false , & Error { Operation : "vm.InVmTeam" , Code : int ( err & 0xFFFF ) , Text : C . GoString ( C . Vix_GetErrorText ( err , nil ) ) , } } if inTeam == 0 { return false , nil } return true , nil }
6958	func ( v * VM ) PowerState ( ) ( VMPowerState , error ) { var err C . VixError = C . VIX_OK var state C . VixPowerState = 0x0 err = C . get_property ( v . handle , C . VIX_PROPERTY_VM_POWER_STATE , unsafe . Pointer ( & state ) ) if C . VIX_OK != err { return VMPowerState ( 0x0 ) , & Error { Operation : "vm.PowerState" , Code : int ( err & 0xFFFF ) , Text : C . GoString ( C . Vix_GetErrorText ( err , nil ) ) , } } return VMPowerState ( state ) , nil }
6959	func ( v * VM ) ToolsState ( ) ( GuestToolsState , error ) { var err C . VixError = C . VIX_OK state := C . VIX_TOOLSSTATE_UNKNOWN err = C . get_property ( v . handle , C . VIX_PROPERTY_VM_TOOLS_STATE , unsafe . Pointer ( & state ) ) if C . VIX_OK != err { return TOOLSSTATE_UNKNOWN , & Error { Operation : "vm.ToolsState" , Code : int ( err & 0xFFFF ) , Text : C . GoString ( C . Vix_GetErrorText ( err , nil ) ) , } } return GuestToolsState ( state ) , nil }
6960	func ( v * VM ) IsRunning ( ) ( bool , error ) { var err C . VixError = C . VIX_OK running := C . VIX_PROPERTY_NONE err = C . get_property ( v . handle , C . VIX_PROPERTY_VM_IS_RUNNING , unsafe . Pointer ( & running ) ) if C . VIX_OK != err { return false , & Error { Operation : "vm.IsRunning" , Code : int ( err & 0xFFFF ) , Text : C . GoString ( C . Vix_GetErrorText ( err , nil ) ) , } } if running == 0 { return false , nil } return true , nil }
6961	func ( v * VM ) GuestOS ( ) ( string , error ) { var err C . VixError = C . VIX_OK var os * C . char err = C . get_property ( v . handle , C . VIX_PROPERTY_VM_GUESTOS , unsafe . Pointer ( & os ) ) defer C . Vix_FreeBuffer ( unsafe . Pointer ( os ) ) if C . VIX_OK != err { return "" , & Error { Operation : "vm.GuestOS" , Code : int ( err & 0xFFFF ) , Text : C . GoString ( C . Vix_GetErrorText ( err , nil ) ) , } } return C . GoString ( os ) , nil }
6962	func cleanupVM ( v * VM ) { if v . handle != C . VIX_INVALID_HANDLE { C . Vix_ReleaseHandle ( v . handle ) v . handle = C . VIX_INVALID_HANDLE } }
6963	func ( v * VM ) updateVMX ( updateFunc func ( model * vmx . VirtualMachine ) error ) error { isVMRunning , err := v . IsRunning ( ) if err != nil { return err } if isVMRunning { return & Error { Operation : "vm.updateVMX" , Code : 100000 , Text : "The VM has to be powered off in order to change its vmx settings" , } } err = v . vmxfile . Read ( ) if err != nil { return & Error { Operation : "vm.updateVMX" , Code : 300001 , Text : fmt . Sprintf ( "Error reading vmx file: %s" , err ) , } } err = updateFunc ( v . vmxfile . model ) if err != nil { return & Error { Operation : "vm.updateVMX" , Code : 300002 , Text : fmt . Sprintf ( "Error changing vmx value: %s" , err ) , } } err = v . vmxfile . Write ( ) if err != nil { return & Error { Operation : "vm.updateVMX" , Code : 300003 , Text : fmt . Sprintf ( "Error writing vmx file: %s" , err ) , } } return nil }
6964	func ( v * VM ) SetMemorySize ( size uint ) error { if size == 0 { size = 4 } if size % 4 != 0 { size = uint ( math . Floor ( float64 ( ( size / 4 ) * 4 ) ) ) } return v . updateVMX ( func ( model * vmx . VirtualMachine ) error { model . Memsize = size return nil } ) }
6965	func ( v * VM ) SetNumberVcpus ( vcpus uint ) error { if vcpus < 1 { vcpus = 1 } return v . updateVMX ( func ( model * vmx . VirtualMachine ) error { model . NumvCPUs = vcpus return nil } ) }
6966	func ( v * VM ) SetDisplayName ( name string ) error { return v . updateVMX ( func ( model * vmx . VirtualMachine ) error { model . DisplayName = name return nil } ) }
6967	func ( v * VM ) SetAnnotation ( text string ) error { return v . updateVMX ( func ( model * vmx . VirtualMachine ) error { model . Annotation = text return nil } ) }
6968	func ( v * VM ) SetVirtualHwVersion ( version string ) error { return v . updateVMX ( func ( model * vmx . VirtualMachine ) error { version , err := strconv . ParseInt ( version , 10 , 32 ) if err != nil { return err } model . Vhardware . Compat = "hosted" model . Vhardware . Version = int ( version ) return nil } ) }
6969	func ( e * Error ) Error ( ) string { return fmt . Sprintf ( "VIX Error: %s, code: %d, operation: %s" , e . Text , e . Code , e . Operation ) }
6970	func Errorf ( message string , a ... interface { } ) error { return wrap ( fmt . Errorf ( message , a ... ) ) }
6971	func ( t * traceableError ) Error ( ) string { str := t . err . Error ( ) for _ , frame := range t . stack { str += fmt . Sprintf ( "\n at %s" , \n ) } frame . string ( ) }
6972	func ( s * stackFrame ) string ( ) string { return fmt . Sprintf ( "%s (%s:%d)" , s . function , s . file , s . line ) }
6973	func newStackFrame ( pc uintptr ) * stackFrame { fn := runtime . FuncForPC ( pc ) file , line := fn . FileLine ( pc ) packagePath , funcSignature := parseFuncName ( fn . Name ( ) ) _ , fileName := filepath . Split ( file ) return & stackFrame { file : filepath . Join ( packagePath , fileName ) , line : line , function : funcSignature , } }
6974	func captureStack ( skip , maxDepth int ) [ ] * stackFrame { pcs := make ( [ ] uintptr , maxDepth ) count := runtime . Callers ( skip + 1 , pcs ) frames := make ( [ ] * stackFrame , count ) for i , pc := range pcs [ 0 : count ] { frames [ i ] = newStackFrame ( pc ) } return frames }
6975	func parseFuncName ( fnName string ) ( packagePath , signature string ) { regEx := regexp . MustCompile ( "([^\\(]*)\\.(.*)" ) \\ \\ parts := regEx . FindStringSubmatch ( fnName ) packagePath = parts [ 1 ] }
6976	func Stack ( err interface { } ) { stack := make ( [ ] byte , 64 << 10 ) stack = stack [ : runtime . Stack ( stack , false ) ] log . Printf ( "%v\n%s" , \n , err ) }
6977	func StackWithCaller ( err interface { } ) { stack := make ( [ ] byte , 64 << 10 ) stack = stack [ : runtime . Stack ( stack , false ) ] if pack , ok := callerPackage ( ) ; ok { log . Printf ( "%s: %v\n%s" , \n , pack , err ) } else stack }
6978	func ( w responseWriterBinder ) Write ( p [ ] byte ) ( int , error ) { for _ , f := range w . before { f ( p ) } return w . Writer . Write ( p ) }
6979	func ResponseStatus ( w http . ResponseWriter ) int { return int ( httpResponseStruct ( reflect . ValueOf ( w ) ) . FieldByName ( "status" ) . Int ( ) ) }
6980	func httpResponseStruct ( v reflect . Value ) reflect . Value { if v . Kind ( ) == reflect . Ptr { v = v . Elem ( ) } if v . Type ( ) . String ( ) == "http.response" { return v } return httpResponseStruct ( v . FieldByName ( "ResponseWriter" ) . Elem ( ) ) }
6981	func SetDetectedContentType ( w http . ResponseWriter , p [ ] byte ) string { ct := w . Header ( ) . Get ( "Content-Type" ) if ct == "" { ct = http . DetectContentType ( p ) w . Header ( ) . Set ( "Content-Type" , ct ) } return ct }
6982	func ( e * ServerError ) New ( message string ) * ServerError { e . HTTPCode = http . StatusInternalServerError e . Errno = 0 e . Message = message return e }
6983	func ( e * DBError ) New ( dbName string , message string ) * DBError { e . HTTPCode = http . StatusInternalServerError e . Errno = 0 e . Message = message e . DBName = dbName return e }
6984	func ( e * ValidationError ) New ( message string ) * ValidationError { e . HTTPCode = http . StatusBadRequest e . Errno = 0 e . Message = message return e }
6985	func ( e * NotFoundError ) New ( message string ) * NotFoundError { e . HTTPCode = http . StatusNotFound e . Errno = 0 e . Message = message return e }
6986	func ( c * Controller ) StrLength ( fieldName string , p interface { } , n int ) string { if p == nil { p = "" } v , ok := p . ( string ) if ok == false { panic ( ( & ValidationError { } ) . New ( fieldName + "长度应该为" + strconv v I ) ) } oa(n))) . field_identifier ( identifier ) b := c . Validate . Length ( v , n ) if b == false { panic ( ( & ValidationError { } ) . New ( fieldName + "长度应该为" + strconv v I ) ) } }
6987	func ( c * Controller ) StrLenIn ( fieldName string , p interface { } , l ... int ) string { if p == nil { p = "" } v , ok := p . ( string ) if ok == false { panic ( ( & ValidationError { } ) . New ( fieldName + "格式错误")) ) ) } length := utf8 . RuneCountInString ( v ) b := false for i := 0 ; i < len ( l ) ; i ++ { if l [ i ] == length { b = true } } if b == false { panic ( ( & ValidationError { } ) . New ( fieldName + "值的长度应该在" + strings.Rep p a + interpreted_string_literal ) ) } e(strin g s.Trim( f mt.Spri n t(l) , "[ ] "), " " , " ", - - 1 ) + " + , 中 ) }
6988	func ( c * Controller ) StrIn ( fieldName string , p interface { } , l ... string ) string { if p == nil { p = "" } v , ok := p . ( string ) if ok == false { panic ( ( & ValidationError { } ) . New ( fieldName + "格式错误")) ) ) } b := false for i := 0 ; i < len ( l ) ; i ++ { if l [ i ] == v { b = true } } if b == false { panic ( ( & ValidationError { } ) . New ( fieldName + "值应该在" + strin n s + interpreted_string_literal ) ) } Replace ( strings . Trim(fm t .Spr i nt( l ), "[] " ) , ", , " , - , - ) }
6989	func ( c * Controller ) GetEmail ( fieldName string , p interface { } ) string { if p == nil { p = "" } v , ok := p . ( string ) if ok == false { panic ( ( & ValidationError { } ) . New ( fieldName + "格式错误")) ) ) } b := c . Validate . Email ( v ) if b == false { panic ( ( & ValidationError { } ) . New ( fieldName + "格式错误")) ) ) } return v }
6990	func MostSpecificType ( types [ ] string ) ( string , error ) { if len ( types ) == 0 { return "" , errors . New ( "no types supplied" ) } sorted , err := SortTypes ( types ) if err != nil { return "" , err } return sorted [ len ( sorted ) - 1 ] , nil }
6991	func FullTypeHierarchy ( highestLevelType string ) [ ] string { var typeHierarchy [ ] string t := strings . Split ( highestLevelType , "/" ) typeToCheck := t [ len ( t ) - 1 ] for { typeHierarchy = append ( typeHierarchy , typeToCheck ) parentType := ParentType ( typeToCheck ) if parentType != "" { typeToCheck = parentType } else { return TypeURIs ( typeHierarchy ) } } }
6992	func SortTypes ( types [ ] string ) ( [ ] string , error ) { ts := & typeSorter { types : make ( [ ] string , len ( types ) ) } copy ( ts . types , types ) sort . Sort ( ts ) if ts . invalid { return types , ErrNotHierarchy } return ts . types , nil }
6993	func ( rs * redisStore ) Delete ( key string ) error { delete ( rs . Values , key ) err := provider . refresh ( rs ) return err }
6994	func ( rp * redisProvider ) Set ( key string , values map [ string ] string ) ( * redisStore , error ) { rs := & redisStore { SID : key , Values : values } err := provider . refresh ( rs ) return rs , err }
6995	func ( rp * redisProvider ) refresh ( rs * redisStore ) error { var err error redisPool . Exec ( func ( c * redis . Client ) { err = c . HMSet ( rs . SID , rs . Values ) . Err ( ) if err != nil { return } err = c . Expire ( rs . SID , sessExpire ) . Err ( ) } ) return nil }
6996	func ( rp * redisProvider ) Get ( sid string ) ( * redisStore , error ) { var rs = & redisStore { } var val map [ string ] string var err error redisPool . Exec ( func ( c * redis . Client ) { val , err = c . HGetAll ( sid ) . Result ( ) rs . Values = val } ) return rs , err }
6997	func ( rp * redisProvider ) Destroy ( sid string ) error { var err error redisPool . Exec ( func ( c * redis . Client ) { err = c . Del ( sid ) . Err ( ) } ) return err }
6998	func ( rp * redisProvider ) UpExpire ( sid string ) error { var err error redisPool . Exec ( func ( c * redis . Client ) { err = c . Expire ( sid , sessExpire ) . Err ( ) } ) return err }
6999	func ( hs * HandlersStack ) Use ( h RouterHandler ) { hs . Handlers = append ( hs . Handlers , h ) }
7000	func ( hs * HandlersStack ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { c := getContext ( w , r ) c . ResponseWriter . Header ( ) . Set ( "Cache-Control" , "no-cache" ) c . ResponseWriter . Header ( ) . Set ( "Content-Type" , "application/json" ) c . ResponseWriter . Header ( ) . Set ( "Connection" , "keep-alive" ) c . ResponseWriter . Header ( ) . Set ( "Vary" , "Accept-Encoding" ) c . ResponseWriter . Header ( ) . Set ( "Access-Control-Allow-Headers" , "X-Requested-With" ) c . ResponseWriter . Header ( ) . Set ( "Access-Control-Allow-Methods" , "PUT,POST,GET,DELETE,OPTIONS" ) defer c . Recover ( ) c . Next ( ) putContext ( c ) }
7001	func ( group * RouterGroup ) Use ( middleware ... RouterHandler ) IRoutes { group . Handlers = append ( group . Handlers , middleware ... ) return group . returnObj ( ) }
7002	func ( group * RouterGroup ) Group ( relativePath string , handlers ... RouterHandler ) * RouterGroup { return & RouterGroup { Handlers : group . combineHandlers ( handlers ) , basePath : group . calculateAbsolutePath ( relativePath ) , engine : group . engine , } }
7003	func Run ( ) { for _ , f := range beforeRun { f ( ) } if OpenCommandLine { flag . StringVar ( & Address , "address" , ":8080" , "-address=:8080" ) flag . BoolVar ( & Production , "production" , false , "-production=false" ) flag . Parse ( ) } log . Warnln ( fmt . Sprintf ( "Serving %s with pid %d. Production is %t." , Address , os . Getpid ( ) , Production ) ) Use ( Routers . handlers ) srv := & graceful . Server { ListenLimit : ListenLimit , ConnState : func ( conn net . Conn , state http . ConnState ) { } , Server : & http . Server { Addr : Address , Handler : defaultHandlersStack , ReadTimeout : ReadTimeout , WriteTimeout : WriteTimeout , IdleTimeout : IdleTimeout , MaxHeaderBytes : MaxHeaderBytes , } , } err := srv . ListenAndServe ( ) if err != nil { log . Fatalln ( err ) } log . Warnln ( "Server stoped." ) }
7004	func create ( ) * Engine { engine := & Engine { RouterGroup : RouterGroup { Handlers : nil , basePath : "/" , root : true , } , trees : make ( methodTrees , 0 , 9 ) , } engine . RouterGroup . engine = engine return engine }
7005	func ( ctx * Context ) Redirect ( url string , code int ) { http . Redirect ( ctx . ResponseWriter , ctx . Request , url , code ) }
7006	func ( ctx * Context ) Ok ( data interface { } ) { if ctx . written == true { log . WithFields ( log . Fields { "path" : ctx . Request . URL . Path } ) . Warnln ( "Context.Success: request has been writed" ) return } ctx . written = true var json = jsoniter . ConfigCompatibleWithStandardLibrary b , _ := json . Marshal ( & ResFormat { Ok : true , Data : data } ) ctx . ResponseWriter . WriteHeader ( http . StatusOK ) ctx . ResponseWriter . Write ( b ) }
7007	func ( ctx * Context ) Fail ( err error ) { if err == nil { log . WithFields ( log . Fields { "path" : ctx . Request . URL . Path } ) . Warnln ( "Context.Fail: err is nil" ) ctx . ResponseWriter . WriteHeader ( http . StatusInternalServerError ) ctx . ResponseWriter . Write ( nil ) return } if ctx . written == true { log . WithFields ( log . Fields { "path" : ctx . Request . URL . Path } ) . Warnln ( "Context.Fail: request has been writed" ) return } errno := 0 errCore , ok := err . ( ICoreError ) if ok == true { errno = errCore . GetErrno ( ) } ctx . written = true if Production == false { log . WithFields ( log . Fields { "path" : ctx . Request . URL . Path } ) . Warnln ( err . Error ( ) ) } else if _ , ok := err . ( * ServerError ) ; ok == true { log . WithFields ( log . Fields { "path" : ctx . Request . URL . Path } ) . Warnln ( err . Error ( ) ) } var json = jsoniter . ConfigCompatibleWithStandardLibrary b , _ := json . Marshal ( & ResFormat { Ok : false , Message : err . Error ( ) , Errno : errno } ) coreErr , ok := err . ( ICoreError ) if ok == true { ctx . ResponseWriter . WriteHeader ( coreErr . GetHTTPCode ( ) ) } else { ctx . ResponseWriter . WriteHeader ( http . StatusInternalServerError ) } ctx . ResponseWriter . Write ( b ) }
7008	func ( ctx * Context ) ResStatus ( code int ) ( int , error ) { if ctx . written == true { return 0 , errors . New ( "Context.ResStatus: request has been writed" ) } ctx . written = true ctx . ResponseWriter . WriteHeader ( code ) return fmt . Fprint ( ctx . ResponseWriter , http . StatusText ( code ) ) }
7009	func ( ctx * Context ) Next ( ) { if ! ctx . Written ( ) && ctx . index < len ( ctx . handlersStack . Handlers ) - 1 { ctx . index ++ ctx . handlersStack . Handlers [ ctx . index ] ( ctx ) } }
7010	func ( ctx * Context ) GetSession ( ) IStore { store := ctx . Data [ "session" ] if store == nil { return nil } st , ok := store . ( IStore ) if ok == false { return nil } return st }
7011	func ( ctx * Context ) GetBodyJSON ( ) { var reqJSON map [ string ] interface { } body , _ := ioutil . ReadAll ( ctx . Request . Body ) defer ctx . Request . Body . Close ( ) cType := ctx . Request . Header . Get ( "Content-Type" ) a := strings . Split ( cType , ";" ) if a [ 0 ] == "application/x-www-form-urlencoded" { reqJSON = make ( map [ string ] interface { } ) reqStr := string ( body ) reqArr := strings . Split ( reqStr , "&" ) for _ , v := range reqArr { param := strings . Split ( v , "=" ) reqJSON [ param [ 0 ] ] , _ = url . QueryUnescape ( param [ 1 ] ) } } else { json . Unmarshal ( body , & reqJSON ) } ctx . BodyJSON = reqJSON }
7012	func ( ctx * Context ) SetSession ( key string , values map [ string ] string ) error { sid := ctx . genSid ( key ) values [ "Sid" ] = sid timestamp := strconv . FormatInt ( time . Now ( ) . Unix ( ) , 10 ) token := ctx . genSid ( key + timestamp ) values [ "Token" ] = token store , err := provider . Set ( sid , values ) if err != nil { return err } cookie := httpCookie cookie . Value = sid ctx . Data [ "session" ] = store respCookie := ctx . ResponseWriter . Header ( ) . Get ( "Set-Cookie" ) if strings . HasPrefix ( respCookie , cookie . Name ) { ctx . ResponseWriter . Header ( ) . Del ( "Set-Cookie" ) } http . SetCookie ( ctx . ResponseWriter , & cookie ) return nil }
7013	func ( ctx * Context ) FreshSession ( key string ) error { err := provider . UpExpire ( key ) if err != nil { return err } return nil }
7014	func ( ctx * Context ) DeleteSession ( ) error { sid := ctx . Data [ "Sid" ] . ( string ) ctx . Data [ "session" ] = nil provider . Destroy ( sid ) cookie := httpCookie cookie . MaxAge = - 1 http . SetCookie ( ctx . ResponseWriter , & cookie ) return nil }
7015	func ( w contextWriter ) Write ( p [ ] byte ) ( int , error ) { w . context . written = true return w . ResponseWriter . Write ( p ) }
7016	func ( w contextWriter ) WriteHeader ( code int ) { w . context . written = true w . ResponseWriter . WriteHeader ( code ) }
7017	func New ( pemPath string , options ... func ( * Client ) error ) * Client { c := Client { pemPath : pemPath , RequestTimeout : defaultRequestTimeout , } c . PrintDebug = false for _ , option := range options { err := option ( & c ) if err != nil { return nil } } return & c }
7018	func ( c * Client ) setAllowLargeResults ( shouldAllow bool , tempTableName string , flattenResults bool ) error { c . allowLargeResults = shouldAllow c . tempTableName = tempTableName c . flattenResults = flattenResults return nil }
7019	func ( c * Client ) connect ( ) ( * bigquery . Service , error ) { if c . token != nil { if ! c . token . Valid ( ) && c . service != nil { return c . service , nil } } pemKeyBytes , err := ioutil . ReadFile ( c . pemPath ) if err != nil { panic ( err ) } t , err := google . JWTConfigFromJSON ( pemKeyBytes , "https://www.googleapis.com/auth/bigquery" ) client := t . Client ( oauth2 . NoContext ) service , err := bigquery . New ( client ) if err != nil { return nil , err } c . service = service return service , nil }
7020	func ( c * Client ) InsertRow ( projectID , datasetID , tableID string , rowData map [ string ] interface { } ) error { service , err := c . connect ( ) if err != nil { return err } insertRequest := buildBigQueryInsertRequest ( [ ] map [ string ] interface { } { rowData } ) result , err := service . Tabledata . InsertAll ( projectID , datasetID , tableID , insertRequest ) . Do ( ) if err != nil { c . printDebug ( "Error inserting row: " , err ) return err } if len ( result . InsertErrors ) > 0 { return errors . New ( "Error inserting row" ) } return nil }
7021	func ( c * Client ) AsyncQuery ( pageSize int , dataset , project , queryStr string , dataChan chan Data ) { c . pagedQuery ( pageSize , dataset , project , queryStr , dataChan ) }
7022	func ( c * Client ) Query ( dataset , project , queryStr string ) ( [ ] [ ] interface { } , [ ] string , error ) { return c . pagedQuery ( defaultPageSize , dataset , project , queryStr , nil ) }
7023	func ( c * Client ) stdPagedQuery ( service * bigquery . Service , pageSize int , dataset , project , queryStr string , dataChan chan Data ) ( [ ] [ ] interface { } , [ ] string , error ) { c . printDebug ( "std paged query" ) datasetRef := & bigquery . DatasetReference { DatasetId : dataset , ProjectId : project , } query := & bigquery . QueryRequest { DefaultDataset : datasetRef , MaxResults : int64 ( pageSize ) , Kind : "json" , Query : queryStr , } qr , err := service . Jobs . Query ( project , query ) . Do ( ) headers , rows := c . headersAndRows ( qr . Schema , qr . Rows ) if err != nil { c . printDebug ( "Error loading query: " , err ) if dataChan != nil { dataChan <- Data { Err : err } } return nil , nil , err } return c . processPagedQuery ( qr . JobReference , qr . PageToken , dataChan , headers , rows ) }
7024	func ( c * Client ) largeDataPagedQuery ( service * bigquery . Service , pageSize int , dataset , project , queryStr string , dataChan chan Data ) ( [ ] [ ] interface { } , [ ] string , error ) { c . printDebug ( "largeDataPagedQuery starting" ) ts := time . Now ( ) tableRef := bigquery . TableReference { DatasetId : dataset , ProjectId : project , TableId : c . tempTableName } jobConfigQuery := bigquery . JobConfigurationQuery { } datasetRef := & bigquery . DatasetReference { DatasetId : dataset , ProjectId : project , } jobConfigQuery . AllowLargeResults = true jobConfigQuery . Query = queryStr jobConfigQuery . DestinationTable = & tableRef jobConfigQuery . DefaultDataset = datasetRef if ! c . flattenResults { c . printDebug ( "setting FlattenResults to false" ) f := false jobConfigQuery . FlattenResults = & f } jobConfigQuery . WriteDisposition = "WRITE_TRUNCATE" jobConfigQuery . CreateDisposition = "CREATE_IF_NEEDED" jobConfig := bigquery . JobConfiguration { } jobConfig . Query = & jobConfigQuery job := bigquery . Job { } job . Configuration = & jobConfig jobInsert := service . Jobs . Insert ( project , & job ) runningJob , jerr := jobInsert . Do ( ) if jerr != nil { c . printDebug ( "Error inserting job!" , jerr ) if dataChan != nil { dataChan <- Data { Err : jerr } } return nil , nil , jerr } var qr * bigquery . GetQueryResultsResponse var rows [ ] [ ] interface { } var headers [ ] string var err error for i := 1 ; ; i ++ { r := service . Jobs . GetQueryResults ( project , runningJob . JobReference . JobId ) r . TimeoutMs ( c . RequestTimeout ) qr , err = r . Do ( ) headers , rows = c . headersAndRows ( qr . Schema , qr . Rows ) if i >= maxRequestRetry || qr . JobReference != nil || err != nil { if i > 1 { c . printDebug ( "Took %v tries to get a job reference" , i ) } break } } if err == nil && qr . JobReference == nil { err = fmt . Errorf ( "missing job reference" ) } if err != nil { c . printDebug ( "Error loading query: " , err ) if dataChan != nil { dataChan <- Data { Err : err } } return nil , nil , err } rows , headers , err = c . processPagedQuery ( qr . JobReference , qr . PageToken , dataChan , headers , rows ) c . printDebug ( "largeDataPagedQuery completed in " , time . Now ( ) . Sub ( ts ) . Seconds ( ) , "s" ) return rows , headers , err }
7025	func ( c * Client ) pagedQuery ( pageSize int , dataset , project , queryStr string , dataChan chan Data ) ( [ ] [ ] interface { } , [ ] string , error ) { service , err := c . connect ( ) if err != nil { if dataChan != nil { dataChan <- Data { Err : err } } return nil , nil , err } if c . allowLargeResults && len ( c . tempTableName ) > 0 { return c . largeDataPagedQuery ( service , pageSize , dataset , project , queryStr , dataChan ) } return c . stdPagedQuery ( service , pageSize , dataset , project , queryStr , dataChan ) }
7026	func ( c * Client ) pageOverJob ( rowCount int , jobRef * bigquery . JobReference , pageToken string , resultChan chan [ ] [ ] interface { } , headersChan chan [ ] string ) error { service , err := c . connect ( ) if err != nil { return err } qrc := service . Jobs . GetQueryResults ( jobRef . ProjectId , jobRef . JobId ) if len ( pageToken ) > 0 { qrc . PageToken ( pageToken ) } qr , err := qrc . Do ( ) if err != nil { c . printDebug ( "Error loading additional data: " , err ) close ( resultChan ) return err } if qr . JobComplete { c . printDebug ( "qr.JobComplete" ) headers , rows := c . headersAndRows ( qr . Schema , qr . Rows ) if headersChan != nil { headersChan <- headers close ( headersChan ) } c . printDebug ( "sending rows" ) resultChan <- rows rowCount = rowCount + len ( rows ) c . printDebug ( "Total rows: " , rowCount ) } if qr . TotalRows > uint64 ( rowCount ) || ! qr . JobComplete { c . printDebug ( "!qr.JobComplete" ) if qr . JobReference == nil { c . pageOverJob ( rowCount , jobRef , pageToken , resultChan , headersChan ) } else { c . pageOverJob ( rowCount , qr . JobReference , qr . PageToken , resultChan , nil ) } } else { close ( resultChan ) return nil } return nil }
7027	func ( c * Client ) Count ( dataset , project , datasetTable string ) int64 { qstr := fmt . Sprintf ( "select count(*) from [%s]" , datasetTable ) res , err := c . SyncQuery ( dataset , project , qstr , 1 ) if err == nil { if len ( res ) > 0 { val , _ := strconv . ParseInt ( res [ 0 ] [ 0 ] . ( string ) , 10 , 64 ) return val } } return 0 }
7028	func work ( args ... interface { } ) interface { } { url := args [ 0 ] . ( string ) depth := args [ 1 ] . ( int ) fetcher := args [ 2 ] . ( Fetcher ) if depth <= 0 { return crawlResult { } } body , urls , err := fetcher . Fetch ( url ) return crawlResult { body , urls , err } }
7029	func ( pool * Pool ) subworker ( job * Job ) { defer func ( ) { if err := recover ( ) ; err != nil { log . Println ( "panic while running job:" , err ) job . Result = nil job . Err = fmt . Errorf ( err . ( string ) ) } } ( ) job . Result = job . F ( job . Args ... ) }
7030	func ( pool * Pool ) worker ( worker_id uint ) { job_pipe := make ( chan * Job ) WORKER_LOOP : for { pool . job_wanted_pipe <- job_pipe job := <- job_pipe if job == nil { time . Sleep ( pool . interval * time . Millisecond ) } else { job . Worker_id = worker_id pool . subworker ( job ) pool . done_pipe <- job } select { case <- pool . worker_kill_pipe : break WORKER_LOOP default : } } pool . worker_wg . Done ( ) }
7031	func ( pool * Pool ) supervisor ( ) { SUPERVISOR_LOOP : for { select { case job := <- pool . add_pipe : pool . jobs_ready_to_run . PushBack ( job ) pool . num_jobs_submitted ++ job . added <- true case job_pipe := <- pool . job_wanted_pipe : element := pool . jobs_ready_to_run . Front ( ) var job * Job = nil if element != nil { job = element . Value . ( * Job ) pool . num_jobs_running ++ pool . jobs_ready_to_run . Remove ( element ) } job_pipe <- job case job := <- pool . done_pipe : pool . num_jobs_running -- pool . jobs_completed . PushBack ( job ) pool . num_jobs_completed ++ case result_pipe := <- pool . result_wanted_pipe : close_pipe := false job := ( * Job ) ( nil ) element := pool . jobs_completed . Front ( ) if element != nil { job = element . Value . ( * Job ) pool . jobs_completed . Remove ( element ) } else { if pool . num_jobs_running == 0 && pool . num_jobs_completed == pool . num_jobs_submitted { close_pipe = true } } if close_pipe { close ( result_pipe ) } else { result_pipe <- job } case working_pipe := <- pool . working_wanted_pipe : working := true if pool . jobs_ready_to_run . Len ( ) == 0 && pool . num_jobs_running == 0 { working = false } working_pipe <- working case stats_pipe := <- pool . stats_wanted_pipe : pool_stats := stats { pool . num_jobs_submitted , pool . num_jobs_running , pool . num_jobs_completed } stats_pipe <- pool_stats case <- pool . supervisor_kill_pipe : break SUPERVISOR_LOOP } } pool . supervisor_wg . Done ( ) }
7032	func ( pool * Pool ) Run ( ) { if pool . workers_started { panic ( "trying to start a pool that's already running" ) } for i := uint ( 0 ) ; i < uint ( pool . num_workers ) ; i ++ { pool . worker_wg . Add ( 1 ) go pool . worker ( i ) } pool . workers_started = true if ! pool . supervisor_started { pool . startSupervisor ( ) } }
7033	func ( pool * Pool ) Add ( f func ( ... interface { } ) interface { } , args ... interface { } ) { job := & Job { f , args , nil , nil , make ( chan bool ) , 0 , pool . getNextJobId ( ) } pool . add_pipe <- job <- job . added }
7034	func ( pool * Pool ) Wait ( ) { working_pipe := make ( chan bool ) for { pool . working_wanted_pipe <- working_pipe if ! <- working_pipe { break } time . Sleep ( pool . interval * time . Millisecond ) } }
7035	func ( pool * Pool ) Results ( ) ( res [ ] * Job ) { res = make ( [ ] * Job , pool . jobs_completed . Len ( ) ) i := 0 for e := pool . jobs_completed . Front ( ) ; e != nil ; e = e . Next ( ) { res [ i ] = e . Value . ( * Job ) i ++ } pool . jobs_completed = list . New ( ) return }
7036	func ( pool * Pool ) WaitForJob ( ) * Job { result_pipe := make ( chan * Job ) var job * Job var ok bool for { pool . result_wanted_pipe <- result_pipe job , ok = <- result_pipe if ! ok { return nil } if job == ( * Job ) ( nil ) { time . Sleep ( pool . interval * time . Millisecond ) } else { break } } return job }
7037	func ( pool * Pool ) Status ( ) stats { stats_pipe := make ( chan stats ) if pool . supervisor_started { pool . stats_wanted_pipe <- stats_pipe return <- stats_pipe } return stats { } }
7038	func WrapHTTPHandlerFunc ( f http . HandlerFunc ) HandlerFunc { newF := func ( ctx * Context ) error { f ( ctx . Response , ctx . Request ) return nil } return newF }
7039	func WebSocketHandlerFunc ( f func ( ws * websocket . Conn ) ) HandlerFunc { h := websocket . Handler ( f ) return WrapHTTPHandlerFunc ( h . ServeHTTP ) }
7040	func StaticFile ( filename string , contentType string ) staticFile { if contentType == "" { contentType = mime . TypeByExtension ( path . Ext ( filename ) ) } header := make ( http . Header ) header . Set ( "Content-Type" , contentType ) return staticFile { filename , header } }
7041	func PreloadFile ( filename string , contentType string ) ( preloadFile , error ) { body , err := ioutil . ReadFile ( filename ) if err != nil { return preloadFile { } , err } if contentType == "" { contentType = mime . TypeByExtension ( path . Ext ( filename ) ) } header := make ( http . Header ) header . Set ( "Content-Type" , contentType ) return preloadFile { body , header } , nil }
7042	func InitHtmlTemplates ( pattern string ) ( err error ) { htmlTemp . Template , err = html . ParseGlob ( pattern ) return }
7043	func InitTextTemplates ( pattern string ) ( err error ) { textTemp . Template , err = text . ParseGlob ( pattern ) return nil }
7044	func Html ( name , contentType , charSet string ) template { if htmlTemp . Template == nil { panic ( "Function `InitHtmlTemplates` should be called first." ) } if contentType == "" { contentType = ContentTypeHTML } if charSet == "" { charSet = CharSetUTF8 } header := make ( http . Header ) header . Set ( "Content-Type" , fmt . Sprintf ( "%s; charset=%s" , contentType , charSet ) ) return template { & htmlTemp , name , header } }
7045	func Text ( name , contentType , charSet string ) template { if textTemp . Template == nil { panic ( "Function `InitTextTemplates` should be called first." ) } if contentType == "" { contentType = ContentTypePlain } if charSet == "" { charSet = CharSetUTF8 } header := make ( http . Header ) header . Set ( "Content-Type" , fmt . Sprintf ( "%s; charset=%s" , contentType , charSet ) ) return template { & textTemp , name , header } }
7046	func InitWatcher ( pattern string , f func ( string ) error , ef func ( error ) ) ( err error ) { if err = f ( pattern ) ; err != nil { return } if watcher . Watcher == nil { watcher . Watcher , err = fsnotify . NewWatcher ( ) if err != nil { return } watcher . closer = make ( chan bool ) } go func ( ) { atomic . AddUint32 ( & watcher . count , 1 ) for { select { case <- watcher . Events : if err := f ( pattern ) ; err != nil { ef ( err ) } case err := <- watcher . Errors : if ef != nil { ef ( err ) } case <- watcher . closer : break } } } ( ) var matches [ ] string matches , err = filepath . Glob ( pattern ) if err != nil { return } for _ , v := range matches { if err = watcher . Add ( v ) ; err != nil { return } } return }
7047	func CloseWatcher ( ) error { for i := uint32 ( 0 ) ; i < watcher . count ; i ++ { watcher . closer <- true } return watcher . Close ( ) }
7048	func ( rs * Routers ) Find ( path string ) ( url . Values , HandlerFunc , view . View ) { defer rs . RUnlock ( ) rs . RLock ( ) if s , ok := rs . s [ path ] ; ok { return nil , s . h , s . v } for e := rs . l . Front ( ) ; e != nil ; e = e . Next ( ) { s := e . Value . ( struct { r router . Router v view . View h HandlerFunc } ) if params , ok := s . r . Match ( path ) ; ok { return params , s . h , s . v } } return nil , nil , nil }
7049	func ( rs * Routers ) Add ( r router . Router , h HandlerFunc , v view . View ) { defer rs . Unlock ( ) rs . Lock ( ) s := struct { r router . Router v view . View h HandlerFunc } { r , v , h } if sr , ok := r . ( * router . Base ) ; ok { rs . s [ sr . Path ] = s return } rs . l . PushFront ( s ) }
7050	func NewRouters ( ) * Routers { return & Routers { s : make ( map [ string ] struct { r router . Router v view . View h HandlerFunc } ) , l : list . New ( ) , } }
7051	func NewServerMux ( ) ( mux * ServerMux ) { nf := struct { View view . View Handler HandlerFunc } { view . Simple ( view . ContentTypePlain , view . CharSetUTF8 ) , defaultNotFound } return & ServerMux { NewRouters ( ) , nil , nil , nil , nf } }
7052	func ( mux * ServerMux ) err ( err error ) { if mux . ErrorHandle != nil { mux . ErrorHandle ( err ) } }
7053	func ( mux * ServerMux ) HandleFunc ( r router . Router , h HandlerFunc , v view . View ) { mux . routers . Add ( r , h , v ) }
7054	func ( mux * ServerMux ) handleError ( ctx * Context , err error ) bool { if err == nil { return false } if e , ok := err . ( Error ) ; ok { ctx . Response . Status = e . Status ctx . Response . Data = e return true } if ctx . Response . Status == http . StatusOK { ctx . Response . Status = http . StatusInternalServerError } ctx . Response . Data = err . Error ( ) mux . err ( err ) return true }
7055	func ( ctx * Context ) Redirect ( code int , url string ) { ctx . Response . Status = code ctx . Response . Data = url }
7056	func ( mux * ServerMux ) InitPProf ( prefix string ) { if prefix == "" { prefix = "/debug/pprof" } mux . HandleFunc ( router . Wildcard ( fmt . Sprintf ( "%s/*" , prefix ) ) , WrapHTTPHandlerFunc ( pprofIndex ( prefix ) ) , nil ) mux . HandleFunc ( router . Simple ( fmt . Sprintf ( "%s/cmdline" , prefix ) ) , WrapHTTPHandlerFunc ( http . HandlerFunc ( pprof . Cmdline ) ) , nil ) mux . HandleFunc ( router . Simple ( fmt . Sprintf ( "%s/profile" , prefix ) ) , WrapHTTPHandlerFunc ( http . HandlerFunc ( pprof . Profile ) ) , nil ) mux . HandleFunc ( router . Simple ( fmt . Sprintf ( "%s/symbol" , prefix ) ) , WrapHTTPHandlerFunc ( http . HandlerFunc ( pprof . Symbol ) ) , nil ) }
7057	func ( ctx * Context ) StartSession ( f session . FactoryFunc ) ( err error ) { ctx . Session , err = f ( ctx . Response , ctx . Request ) return }
7058	func combinations ( list [ ] int , select_num , buf int ) ( c chan [ ] int ) { c = make ( chan [ ] int , buf ) go func ( ) { defer close ( c ) switch { case select_num == 0 : c <- [ ] int { } case select_num == len ( list ) : c <- list case len ( list ) < select_num : return default : for i := 0 ; i < len ( list ) ; i ++ { for sub_comb := range combinations ( list [ i + 1 : ] , select_num - 1 , buf ) { c <- append ( [ ] int { list [ i ] } , sub_comb ... ) } } } } ( ) return }
7059	func repeated_combinations ( list [ ] int , select_num , buf int ) ( c chan [ ] int ) { c = make ( chan [ ] int , buf ) go func ( ) { defer close ( c ) if select_num == 1 { for v := range list { c <- [ ] int { v } } return } for i := 0 ; i < len ( list ) ; i ++ { for sub_comb := range repeated_combinations ( list [ i : ] , select_num - 1 , buf ) { c <- append ( [ ] int { list [ i ] } , sub_comb ... ) } } } ( ) return }
7060	func permutations ( list [ ] int , select_num , buf int ) ( c chan [ ] int ) { c = make ( chan [ ] int , buf ) go func ( ) { defer close ( c ) switch select_num { case 1 : for _ , v := range list { c <- [ ] int { v } } return case 0 : return case len ( list ) : for i := 0 ; i < len ( list ) ; i ++ { top , sub_list := pop ( list , i ) for perm := range permutations ( sub_list , select_num - 1 , buf ) { c <- append ( [ ] int { top } , perm ... ) } } default : for comb := range combinations ( list , select_num , buf ) { for perm := range permutations ( comb , select_num , buf ) { c <- perm } } } } ( ) return }
7061	func repeated_permutations ( list [ ] int , select_num , buf int ) ( c chan [ ] int ) { c = make ( chan [ ] int , buf ) go func ( ) { defer close ( c ) switch select_num { case 1 : for _ , v := range list { c <- [ ] int { v } } default : for i := 0 ; i < len ( list ) ; i ++ { for perm := range repeated_permutations ( list , select_num - 1 , buf ) { c <- append ( [ ] int { list [ i ] } , perm ... ) } } } } ( ) return }
7062	func gformat ( format string , args map [ string ] interface { } ) ( string , [ ] interface { } ) { var new_format = make ( [ ] rune , 0 , len ( format ) ) var in_format = false var in_args = false var previousChar rune var current_name_runes = make ( [ ] rune , 0 , 10 ) var current_args_runes = make ( [ ] rune , 0 , 10 ) var new_format_params [ ] interface { } for i , ch := range format { if i > 0 { previousChar = rune ( format [ i - 1 ] ) } switch ch { case '{' : if in_format && previousChar == '{' { in_format = false new_format = append ( new_format , ch ) break } in_format = true case '}' : if ! in_format { if previousChar == '}' { new_format = append ( new_format , ch ) break } break } if in_format { if len ( current_args_runes ) > 0 { new_format = append ( new_format , current_args_runes ... ) } else { new_format = append ( new_format , defaultFormat ... ) } current_args_runes = current_args_runes [ 0 : 0 ] } var name string if len ( current_name_runes ) == 0 { name = "EMPTY_PLACEHOLDER" } else { name = string ( current_name_runes ) } current_name_runes = current_name_runes [ 0 : 0 ] val , ok := args [ name ] if ! ok { val = fmt . Sprintf ( "%%MISSING=%s" , name ) } new_format_params = append ( new_format_params , val ) in_format = false in_args = false case ':' : if in_format { in_args = true } default : if in_format { if in_args { current_args_runes = append ( current_args_runes , ch ) } else { current_name_runes = append ( current_name_runes , ch ) } } else { new_format = append ( new_format , ch ) } } } return string ( new_format ) , new_format_params }
7063	func Errorm ( format string , args map [ string ] interface { } ) error { f , a := gformat ( format , args ) return fmt . Errorf ( f , a ... ) }
7064	func Fprintm ( w io . Writer , format string , args map [ string ] interface { } ) ( n int , err error ) { f , a := gformat ( format , args ) return fmt . Fprintf ( w , f , a ... ) }
7065	func Printm ( format string , args map [ string ] interface { } ) ( n int , err error ) { f , a := gformat ( format , args ) return fmt . Printf ( f , a ... ) }
7066	func Sprintm ( format string , args map [ string ] interface { } ) string { f , a := gformat ( format , args ) return fmt . Sprintf ( f , a ... ) }
7067	func ( p * PasswordStrengthRequirements ) Validate ( password string ) ( bool , string ) { reqs := MakeRequirements ( password ) if p . MaximumTotalLength > 0 && reqs . MaximumTotalLength > p . MaximumTotalLength { return false , "password is too long" } if reqs . MinimumTotalLength < p . MinimumTotalLength { return false , "password is too short" } if reqs . Digits < p . Digits { return false , "password has too few digits" } if reqs . Punctuation < p . Punctuation { return false , "password has too few punctuation characters" } if reqs . Uppercase < p . Uppercase { return false , "password has too few uppercase characters" } return true , "" }
7068	func MakeRequirements ( password string ) PasswordStrengthRequirements { pwd := [ ] byte ( password ) reqs := PasswordStrengthRequirements { } reqs . MaximumTotalLength = len ( password ) reqs . MinimumTotalLength = len ( password ) for i := range pwd { switch { case unicode . IsDigit ( rune ( pwd [ i ] ) ) : reqs . Digits ++ case unicode . IsUpper ( rune ( pwd [ i ] ) ) : reqs . Uppercase ++ case unicode . IsPunct ( rune ( pwd [ i ] ) ) : reqs . Punctuation ++ } } return reqs }
7069	func ( p * PasswordStrengthRequirements ) sanityCheck ( ) ( bool , string ) { if p . MaximumTotalLength == 0 { return true , "" } if p . MaximumTotalLength < p . MinimumTotalLength { return false , "maximum total length is less than minimum total length" } if p . MaximumTotalLength < p . Digits { return false , "maximum required digits is more than maximum total length" } if p . MaximumTotalLength < p . Punctuation { return false , "maximum required punctuation is more than maximum total length" } if p . MaximumTotalLength < p . Uppercase { return false , "maximum required uppercase characters is more than maximum total length" } if p . MaximumTotalLength < p . Digits + p . Uppercase + p . Punctuation { return false , "maximum required digits + uppercase + punctuation is more than maximum total length" } return true , "" }
7070	func ( g Garbler ) password ( req PasswordStrengthRequirements ) ( string , error ) { letters := 0 mustGarble := 0 switch { case req . MaximumTotalLength > 0 && req . MaximumTotalLength > 6 : letters = req . MaximumTotalLength - req . Digits - req . Punctuation case req . MaximumTotalLength > 0 && req . MaximumTotalLength <= 6 : letters = req . MaximumTotalLength - req . Punctuation mustGarble = req . Digits case req . MinimumTotalLength > req . Digits + req . Punctuation + 6 : letters = req . MinimumTotalLength - req . Digits - req . Punctuation default : letters = req . MinimumTotalLength } if req . Uppercase > letters { letters = req . Uppercase } password := g . garbledSequence ( letters , mustGarble ) password = g . uppercase ( password , req . Uppercase ) password = g . addNums ( password , req . Digits - mustGarble ) password = g . punctuate ( password , req . Punctuation ) return password , nil }
7071	func NewPassword ( reqs * PasswordStrengthRequirements ) ( string , error ) { if reqs == nil { reqs = & Medium } if ok , problems := reqs . sanityCheck ( ) ; ! ok { return "" , errors . New ( "requirements failed validation: " + problems ) } e := Garbler { } return e . password ( * reqs ) }
7072	func NewPasswords ( reqs * PasswordStrengthRequirements , n int ) ( [ ] string , error ) { var err error if reqs == nil { reqs = & Medium } if ok , problems := reqs . sanityCheck ( ) ; ! ok { return nil , errors . New ( "requirements failed validation: " + problems ) } e := Garbler { } passes := make ( [ ] string , n , n ) for i := 0 ; i < n ; i ++ { passes [ i ] , err = e . password ( * reqs ) if err != nil { return nil , err } } return passes , nil }
7073	func ( g Garbler ) addNums ( p string , numDigits int ) string { if numDigits <= 0 { return p } ret := p remaining := numDigits for remaining > 10 { ret += fmt . Sprintf ( "%d" , pow ( 10 , 9 ) + randInt ( pow ( 10 , 10 ) - pow ( 10 , 9 ) ) ) remaining -= 10 } ret += fmt . Sprintf ( "%d" , pow ( 10 , remaining - 1 ) + randInt ( pow ( 10 , remaining ) - pow ( 10 , remaining - 1 ) ) ) return ret }
7074	func ( g Garbler ) punctuate ( p string , numPunc int ) string { if numPunc <= 0 { return p } ret := p for i := 0 ; i < numPunc ; i ++ { if i % 2 == 0 { ret += string ( Punctuation [ randInt ( len ( Punctuation ) ) ] ) } else { ret = string ( Punctuation [ randInt ( len ( Punctuation ) ) ] ) + ret } } return ret }
7075	func deprecated_init ( ) { stat , _ := os . Stdin . Stat ( ) if ( stat . Mode ( ) & os . ModeCharDevice ) == 0 { return } for i , argv := range os . Args { if argv == "--" { arg := os . Args [ i + 1 ] buf := bytes . NewBufferString ( arg ) Stdin = NewParamSet ( buf ) return } } if len ( os . Args ) > 1 { buf := bytes . NewBufferString ( os . Args [ 1 ] ) Stdin = NewParamSet ( buf ) } }
7076	func ( p ParamSet ) Param ( name string , value interface { } ) { p . params [ name ] = value }
7077	func ( p ParamSet ) Parse ( ) error { raw := map [ string ] json . RawMessage { } err := json . NewDecoder ( p . reader ) . Decode ( & raw ) if err != nil { return err } for key , val := range p . params { data , ok := raw [ key ] if ! ok { continue } err := json . Unmarshal ( data , val ) if err != nil { return fmt . Errorf ( "Unable to unarmshal %s. %s" , key , err ) } } return nil }
7078	func ( p ParamSet ) Unmarshal ( v interface { } ) error { return json . NewDecoder ( p . reader ) . Decode ( v ) }
7079	func GetDefaultHTTPClient ( timeout time . Duration ) IHTTPClient { client := http . Client { Timeout : timeout , } return IHTTPClient ( & client ) }
7080	func ( p Pushy ) DeviceInfo ( deviceID string ) ( * DeviceInfo , * Error , error ) { url := fmt . Sprintf ( "%s/devices/%s?api_key=%s" , p . APIEndpoint , deviceID , p . APIToken ) var errResponse * Error var info * DeviceInfo err := get ( p . httpClient , url , & info , & errResponse ) return info , errResponse , err }
7081	func ( p * Pushy ) DevicePresence ( deviceID ... string ) ( * DevicePresenceResponse , * Error , error ) { url := fmt . Sprintf ( "%s/devices/presence?api_key=%s" , p . APIEndpoint , p . APIToken ) var devicePresenceResponse * DevicePresenceResponse var pushyErr * Error err := post ( p . httpClient , url , DevicePresenceRequest { Tokens : deviceID } , & devicePresenceResponse , & pushyErr ) return devicePresenceResponse , pushyErr , err }
7082	func ( p * Pushy ) NotificationStatus ( pushID string ) ( * NotificationStatus , * Error , error ) { url := fmt . Sprintf ( "%s/pushes/%s?api_key=%s" , p . APIEndpoint , pushID , p . APIToken ) var errResponse * Error var status * NotificationStatus err := get ( p . httpClient , url , & status , & errResponse ) return status , errResponse , err }
7083	func ( p * Pushy ) DeleteNotification ( pushID string ) ( * SimpleSuccess , * Error , error ) { url := fmt . Sprintf ( "%s/pushes/%s?api_key=%s" , p . APIEndpoint , pushID , p . APIToken ) var success * SimpleSuccess var pushyErr * Error err := del ( p . httpClient , url , & success , & pushyErr ) return success , pushyErr , err }
7084	func ( p * Pushy ) NotifyDevice ( request SendNotificationRequest ) ( * NotificationResponse , * Error , error ) { url := fmt . Sprintf ( "%s/push?api_key=%s" , p . APIEndpoint , p . APIToken ) var success * NotificationResponse var pushyErr * Error err := post ( p . httpClient , url , request , & success , & pushyErr ) return success , pushyErr , err }
7085	func Assert ( t Tester , b bool , message ... interface { } ) { if ! b { pc , file , line , _ := runtime . Caller ( 1 ) caller_func_info := runtime . FuncForPC ( pc ) error_string := fmt . Sprintf ( "\n\rASSERT:\tfunc (%s) 0x%x\n\r\tFile %s:%d" , \n , \r , \t , \n ) \r \t caller_func_info . Name ( ) } }
7086	func CreateFile ( filename string , size int64 ) error { buf := make ( [ ] byte , size ) fp , err := os . Create ( filename ) if err != nil { return err } _ , err = fp . Write ( buf ) fp . Close ( ) return err }
7087	func ( f * FormErrors ) AddError ( e string ) { f . Errors = append ( f . Errors , e ) }
7088	func ( f * FormErrors ) AddFieldError ( field , e string ) { if f . FieldErrors == nil { f . FieldErrors = map [ string ] [ ] string { } } if _ , ok := f . FieldErrors [ field ] ; ! ok { f . FieldErrors [ field ] = [ ] string { } } f . FieldErrors [ field ] = append ( f . FieldErrors [ field ] , e ) }
7089	func ( f FormErrors ) HasErrors ( ) bool { if len ( f . Errors ) > 0 { return true } for _ , v := range f . FieldErrors { if len ( v ) > 0 { return true } } return false }
7090	func NewError ( e string ) FormErrors { errors := FormErrors { } errors . AddError ( e ) return errors }
7091	func NewFieldError ( field , e string ) FormErrors { errors := FormErrors { } errors . AddFieldError ( field , e ) return errors }
7092	func ChainHandlers ( handlers ... func ( http . Handler ) http . Handler ) ( h http . Handler ) { for i := len ( handlers ) - 1 ; i >= 0 ; i -- { h = handlers [ i ] ( h ) } return }
7093	func FinalHandler ( h http . Handler ) func ( http . Handler ) http . Handler { return func ( _ http . Handler ) http . Handler { return h } }
7094	func ( s MD5Hasher ) Hash ( reader io . Reader ) ( string , error ) { hash := md5 . New ( ) if _ , err := io . Copy ( hash , reader ) ; err != nil { return "" , err } h := hash . Sum ( nil ) if len ( h ) < s . HashLength { return "" , nil } return strings . TrimRight ( hex . EncodeToString ( h ) [ : s . HashLength ] , "=" ) , nil }
7095	func ( s MD5Hasher ) IsHash ( h string ) bool { if len ( h ) != s . HashLength { return false } var found bool for _ , c := range h { found = false for _ , m := range hexChars { if c == m { found = true break } } if ! found { return false } } return true }
7096	func WithBaseDir ( dir string ) Option { return func ( o * Options ) { o . fileFindFunc = func ( f string ) string { return filepath . Join ( dir , f ) } } }
7097	func WithFileFindFunc ( fn func ( filename string ) string ) Option { return func ( o * Options ) { o . fileFindFunc = fn } }
7098	func WithTemplateFromFiles ( name string , files ... string ) Option { return func ( o * Options ) { o . files [ name ] = files } }
7099	func WithTemplatesFromFiles ( ts map [ string ] [ ] string ) Option { return func ( o * Options ) { for name , files := range ts { o . files [ name ] = files } } }
7100	func WithTemplateFromStrings ( name string , strings ... string ) Option { return func ( o * Options ) { o . strings [ name ] = strings } }
7101	func WithTemplatesFromStrings ( ts map [ string ] [ ] string ) Option { return func ( o * Options ) { for name , strings := range ts { o . strings [ name ] = strings } } }
7102	func WithFunction ( name string , fn interface { } ) Option { return func ( o * Options ) { o . functions [ name ] = fn } }
7103	func WithFunctions ( fns template . FuncMap ) Option { return func ( o * Options ) { for name , fn := range fns { o . functions [ name ] = fn } } }
7104	func WithDelims ( open , close string ) Option { return func ( o * Options ) { o . delimOpen = open o . delimClose = close } }
7105	func New ( opts ... Option ) ( t * Templates , err error ) { functions := template . FuncMap { } for name , fn := range defaultFunctions { functions [ name ] = fn } o := & Options { fileFindFunc : func ( f string ) string { return f } , fileReadFunc : ioutil . ReadFile , files : map [ string ] [ ] string { } , functions : functions , delimOpen : "{{" , delimClose : "}}" , logf : log . Printf , } for _ , opt := range opts { opt ( o ) } t = & Templates { templates : map [ string ] * template . Template { } , contentType : o . contentType , logf : o . logf , } for name , strings := range o . strings { tpl , err := parseStrings ( template . New ( "" ) . Funcs ( o . functions ) . Delims ( o . delimOpen , o . delimClose ) , strings ... ) if err != nil { return nil , err } t . templates [ name ] = tpl } for name , files := range o . files { fs := [ ] string { } for _ , f := range files { fs = append ( fs , o . fileFindFunc ( f ) ) } tpl , err := parseFiles ( o . fileReadFunc , template . New ( "" ) . Funcs ( o . functions ) . Delims ( o . delimOpen , o . delimClose ) , fs ... ) if err != nil { return nil , err } t . templates [ name ] = tpl } return }
7106	func ( t Templates ) RespondWithStatus ( w http . ResponseWriter , name string , data interface { } , status int ) { buf := bytes . Buffer { } tpl , ok := t . templates [ name ] if ! ok { panic ( & Error { Err : ErrUnknownTemplate , Template : name } ) } if err := tpl . Execute ( & buf , data ) ; err != nil { panic ( err ) } if t . contentType != "" { w . Header ( ) . Set ( "Content-Type" , t . contentType ) } if status > 0 { w . WriteHeader ( status ) } if _ , err := buf . WriteTo ( w ) ; err != nil { t . logf ( "respond %q: %v" , name , err ) } }
7107	func ( t Templates ) RespondTemplate ( w http . ResponseWriter , name , templateName string , data interface { } ) { t . RespondTemplateWithStatus ( w , name , templateName , data , 0 ) }
7108	func ( t Templates ) Respond ( w http . ResponseWriter , name string , data interface { } ) { t . RespondWithStatus ( w , name , data , 0 ) }
7109	func ( t Templates ) RenderTemplate ( name , templateName string , data interface { } ) ( s string , err error ) { buf := bytes . Buffer { } tpl , ok := t . templates [ name ] if ! ok { return "" , & Error { Err : ErrUnknownTemplate , Template : name } } if err := tpl . ExecuteTemplate ( & buf , templateName , data ) ; err != nil { return "" , err } return buf . String ( ) , nil }
7110	func New ( handler http . Handler , opts ... Option ) ( s * Server ) { o := & Options { } for _ , opt := range opts { opt ( o ) } s = & Server { Server : & h2quic . Server { Server : & http . Server { Handler : handler , TLSConfig : o . tlsConfig , } , } , } return }
7111	func ( s * Server ) ServeUDP ( conn * net . UDPConn ) ( err error ) { s . Server . Server . Addr = conn . LocalAddr ( ) . String ( ) return s . Server . Serve ( conn ) }
7112	func ( s * Server ) Shutdown ( _ context . Context ) ( err error ) { return s . Server . Close ( ) }
7113	func ( s * Server ) QuicHeadersHandler ( h http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { s . SetQuicHeaders ( w . Header ( ) ) h . ServeHTTP ( w , r ) } ) }
7114	func GetRequestIPs ( r * http . Request ) string { ip , _ , err := net . SplitHostPort ( r . RemoteAddr ) if err != nil { ip = r . RemoteAddr } ips := [ ] string { ip } xfr := r . Header . Get ( "X-Forwarded-For" ) if xfr != "" { ips = append ( ips , xfr ) } xri := r . Header . Get ( "X-Real-Ip" ) if xri != "" { ips = append ( ips , xri ) } return strings . Join ( ips , ", " ) }
7115	func DomainRedirectHandler ( h http . Handler , domain , httpsPort string ) http . Handler { if domain == "" && httpsPort == "" { return h } scheme := "http" port := "" if httpsPort != "" { if _ , err := strconv . Atoi ( httpsPort ) ; err == nil { scheme = "https" port = httpsPort } if _ , p , err := net . SplitHostPort ( httpsPort ) ; err == nil { scheme = "https" port = p } } if port == "443" { port = "" } var altDomain string if strings . HasPrefix ( "www." , domain ) { altDomain = strings . TrimPrefix ( domain , "www." ) } else { altDomain = "www." + domain } return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { d , p , err := net . SplitHostPort ( r . Host ) if err != nil { d = r . Host } rs := r . URL . Scheme if fs := r . Header . Get ( "X-Forwarded-Proto" ) ; fs != "" { rs = strings . ToLower ( fs ) } s := scheme if rs == "https" { s = "https" } if d == domain && rs == s { h . ServeHTTP ( w , r ) return } switch { case s == "http" && p == "80" : p = "" case s == "https" && p == "443" : p = "" case port != "" : p = ":" + port case p != "" : p = ":" + p } if d == altDomain { http . Redirect ( w , r , strings . Join ( [ ] string { s , "://" , domain , p , r . RequestURI } , "" ) , http . StatusMovedPermanently ) return } http . Redirect ( w , r , strings . Join ( [ ] string { s , "://" , domain , p , r . RequestURI } , "" ) , http . StatusFound ) } ) }
7116	func New ( opts ... Option ) ( s * Servers ) { s = & Servers { logger : stdLogger { } , recover : func ( ) { } , } for _ , opt := range opts { opt ( s ) } return }
7117	func ( s * Servers ) Add ( name , address string , srv Server ) { s . mu . Lock ( ) s . servers = append ( s . servers , & server { Server : srv , name : name , address : address , } ) s . mu . Unlock ( ) }
7118	func ( s * Servers ) TCPAddr ( name string ) ( a * net . TCPAddr ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) for _ , srv := range s . servers { if srv . name == name { return srv . tcpAddr } } return nil }
7119	func ( s * Servers ) UDPAddr ( name string ) ( a * net . UDPAddr ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) for _ , srv := range s . servers { if srv . name == name { return srv . udpAddr } } return nil }
7120	func ( s * Servers ) Close ( ) { wg := & sync . WaitGroup { } for _ , srv := range s . servers { wg . Add ( 1 ) go func ( srv * server ) { defer s . recover ( ) defer wg . Done ( ) s . logger . Infof ( "%s closing" , srv . label ( ) ) if err := srv . Close ( ) ; err != nil { s . logger . Errorf ( "%s close: %v" , srv . label ( ) , err ) } } ( srv ) } wg . Wait ( ) return }
7121	func ( s * Servers ) Shutdown ( ctx context . Context ) { wg := & sync . WaitGroup { } for _ , srv := range s . servers { wg . Add ( 1 ) go func ( srv * server ) { defer s . recover ( ) defer wg . Done ( ) s . logger . Infof ( "%s shutting down" , srv . label ( ) ) if err := srv . Shutdown ( ctx ) ; err != nil { s . logger . Errorf ( "%s shutdown: %v" , srv . label ( ) , err ) } } ( srv ) } wg . Wait ( ) return }
7122	func ( l TLSListener ) Accept ( ) ( net . Conn , error ) { c , err := l . AcceptTCP ( ) if err != nil { return nil , err } c . SetKeepAlive ( true ) c . SetKeepAlivePeriod ( 3 * time . Minute ) b := make ( [ ] byte , 1 ) _ , err = c . Read ( b ) if err != nil { c . Close ( ) if err != io . EOF { return nil , err } } con := & conn { Conn : c , b : b [ 0 ] , e : err , f : true , } if b [ 0 ] == 22 { return tls . Server ( con , l . TLSConfig ) , nil } return con , nil }
7123	func NewStaticFilesHandler ( h http . Handler , prefix string , fs http . FileSystem ) http . Handler { fileserver := http . StripPrefix ( prefix , http . FileServer ( fs ) ) return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { filename := strings . TrimPrefix ( r . URL . Path , prefix ) _ , err := fs . Open ( filename ) if err != nil { h . ServeHTTP ( w , r ) return } fileserver . ServeHTTP ( w , r ) } ) }
7124	func ( h AuthHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { valid , entity , err := h . authenticate ( r ) if err != nil { h . error ( w , r , err ) return } if h . PostAuthFunc != nil { rr , err := h . PostAuthFunc ( w , r , valid , entity ) if err != nil { h . error ( w , r , err ) return } if rr != nil { r = rr } } if ! valid { h . unauthorized ( w , r ) return } if h . Handler != nil { h . Handler . ServeHTTP ( w , r ) } }
7125	func ( o Options ) MarshalJSON ( ) ( [ ] byte , error ) { return json . Marshal ( optionsJSON { Timeout : marshal . Duration ( o . Timeout ) , KeepAlive : marshal . Duration ( o . KeepAlive ) , TLSHandshakeTimeout : marshal . Duration ( o . TLSHandshakeTimeout ) , TLSSkipVerify : o . TLSSkipVerify , RetryTimeMax : marshal . Duration ( o . RetryTimeMax ) , RetrySleepMax : marshal . Duration ( o . RetrySleepMax ) , RetrySleepBase : marshal . Duration ( o . RetrySleepBase ) , } ) }
7126	func ( o * Options ) UnmarshalJSON ( data [ ] byte ) error { v := & optionsJSON { } if err := json . Unmarshal ( data , v ) ; err != nil { return err } * o = Options { Timeout : v . Timeout . Duration ( ) , KeepAlive : v . KeepAlive . Duration ( ) , TLSHandshakeTimeout : v . TLSHandshakeTimeout . Duration ( ) , TLSSkipVerify : v . TLSSkipVerify , RetryTimeMax : v . RetryTimeMax . Duration ( ) , RetrySleepMax : v . RetrySleepMax . Duration ( ) , RetrySleepBase : v . RetrySleepBase . Duration ( ) , } return nil }
7127	func ( o Options ) MarshalYAML ( ) ( interface { } , error ) { return optionsJSON { Timeout : marshal . Duration ( o . Timeout ) , KeepAlive : marshal . Duration ( o . KeepAlive ) , TLSHandshakeTimeout : marshal . Duration ( o . TLSHandshakeTimeout ) , TLSSkipVerify : o . TLSSkipVerify , RetryTimeMax : marshal . Duration ( o . RetryTimeMax ) , RetrySleepMax : marshal . Duration ( o . RetrySleepMax ) , RetrySleepBase : marshal . Duration ( o . RetrySleepBase ) , } , nil }
7128	func ( o * Options ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { v := & optionsJSON { } if err := unmarshal ( v ) ; err != nil { return err } * o = Options { Timeout : v . Timeout . Duration ( ) , KeepAlive : v . KeepAlive . Duration ( ) , TLSHandshakeTimeout : v . TLSHandshakeTimeout . Duration ( ) , TLSSkipVerify : v . TLSSkipVerify , RetryTimeMax : v . RetryTimeMax . Duration ( ) , RetrySleepMax : v . RetrySleepMax . Duration ( ) , RetrySleepBase : v . RetrySleepBase . Duration ( ) , } return nil }
7129	func NewHandler ( h http . Handler , logger * logging . Logger ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { startTime := time . Now ( ) rl := & responseLogger { w , 0 , 0 } h . ServeHTTP ( rl , r ) referrer := r . Referer ( ) if referrer == "" { referrer = "-" } userAgent := r . UserAgent ( ) if userAgent == "" { userAgent = "-" } ips := [ ] string { } xfr := r . Header . Get ( "X-Forwarded-For" ) if xfr != "" { ips = append ( ips , xfr ) } xri := r . Header . Get ( "X-Real-Ip" ) if xri != "" { ips = append ( ips , xri ) } xips := "-" if len ( ips ) > 0 { xips = strings . Join ( ips , ", " ) } var level logging . Level switch { case rl . status >= 500 : level = logging . ERROR case rl . status >= 400 : level = logging . WARNING case rl . status >= 300 : level = logging . INFO case rl . status >= 200 : level = logging . INFO default : level = logging . DEBUG } logger . Logf ( level , "%s \"%s\" \"%v %s %v\" %d %d %f \"%s\" \"%s\"" , \" , \" , \" , \" , \" , \" , \" , \" , r . RemoteAddr , xips ) } ) }
7130	func WithPanicResponse ( body , contentType string ) Option { return func ( o * Handler ) { o . panicBody = body o . panicContentType = contentType } }
7131	func WithPanicResponseHandler ( h http . Handler ) Option { return func ( o * Handler ) { o . panicResponseHandler = h } }
7132	func New ( handler http . Handler , options ... Option ) ( h * Handler ) { h = & Handler { handler : handler , logf : log . Printf , } for _ , option := range options { option ( h ) } return }
7133	func ( h Handler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { defer func ( ) { if err := recover ( ) ; err != nil { debugMsg := fmt . Sprintf ( "%s\n\n%#v\n\n%#v" , \n , \n , \n , ) \n debug . Stack ( ) r . URL r . Header if h . label != "" { debugMsg = h . label + "\n\n" + \n } \n debugMsg } } h . logf ( "http recovery handler: %s %s: %s\n%s" , \n , r . Method , r . URL . String ( ) , err ) debugMsg }
7134	func NewContextFunc ( m map [ string ] interface { } ) func ( string ) interface { } { return func ( key string ) interface { } { if value , ok := m [ key ] ; ok { return value } return nil } }
7135	func NewMapErrorRegistry ( errors map [ int ] error , handlers map [ int ] func ( body [ ] byte ) error ) * MapErrorRegistry { if errors == nil { errors = map [ int ] error { } } if handlers == nil { handlers = map [ int ] func ( body [ ] byte ) error { } } return & MapErrorRegistry { errors : errors , handlers : handlers , } }
7136	func ( r * MapErrorRegistry ) AddError ( code int , err error ) error { if _ , ok := r . errors [ code ] ; ok { return ErrErrorAlreadyRegistered } if _ , ok := r . handlers [ code ] ; ok { return ErrErrorAlreadyRegistered } r . errors [ code ] = err return nil }
7137	func ( r * MapErrorRegistry ) AddMessageError ( code int , message string ) ( * Error , error ) { if _ , ok := r . errors [ code ] ; ok { return nil , ErrErrorAlreadyRegistered } if _ , ok := r . handlers [ code ] ; ok { return nil , ErrErrorAlreadyRegistered } err := & Error { Message : message , Code : code , } r . errors [ code ] = err return err , nil }
7138	func ( r * MapErrorRegistry ) MustAddError ( code int , err error ) { if e := r . AddError ( code , err ) ; e != nil { panic ( e ) } }
7139	func ( r * MapErrorRegistry ) MustAddMessageError ( code int , message string ) * Error { err , e := r . AddMessageError ( code , message ) if e != nil { panic ( e ) } return err }
7140	func ( r * MapErrorRegistry ) AddHandler ( code int , handler func ( body [ ] byte ) error ) error { if _ , ok := r . errors [ code ] ; ok { return ErrErrorAlreadyRegistered } if _ , ok := r . handlers [ code ] ; ok { return ErrErrorAlreadyRegistered } r . handlers [ code ] = handler return nil }
7141	func ( r * MapErrorRegistry ) MustAddHandler ( code int , handler func ( body [ ] byte ) error ) { if err := r . AddHandler ( code , handler ) ; err != nil { panic ( err ) } }
7142	func ( r MapErrorRegistry ) Handler ( code int ) func ( body [ ] byte ) error { return r . handlers [ code ] }
7143	func New ( endpoint string , errorRegistry ErrorRegistry ) * Client { return & Client { Endpoint : endpoint , ErrorRegistry : errorRegistry , KeyHeader : DefaultKeyHeader , HTTPClient : http . DefaultClient , } }
7144	func ( c Client ) Request ( method , path string , query url . Values , body io . Reader , accept [ ] string ) ( resp * http . Response , err error ) { return c . RequestContext ( nil , method , path , query , body , accept ) }
7145	func ( c Client ) JSONContext ( ctx context . Context , method , path string , query url . Values , body io . Reader , response interface { } ) ( err error ) { resp , err := c . RequestContext ( ctx , method , path , query , body , [ ] string { "application/json" } ) if err != nil { return } defer func ( ) { io . Copy ( ioutil . Discard , resp . Body ) resp . Body . Close ( ) } ( ) if response != nil { if resp . ContentLength == 0 { return errors . New ( "empty response body" ) } contentType := resp . Header . Get ( "Content-Type" ) if ! strings . Contains ( contentType , "application/json" ) { return fmt . Errorf ( "unsupported content type: %s" , contentType ) } var body [ ] byte body , err = ioutil . ReadAll ( resp . Body ) if err != nil { return } if err = JSONUnmarshal ( body , & response ) ; err != nil { return } } return }
7146	func ( c Client ) StreamContext ( ctx context . Context , method , path string , query url . Values , body io . Reader , accept [ ] string ) ( data io . ReadCloser , contentType string , err error ) { resp , err := c . RequestContext ( ctx , method , path , query , body , accept ) if err != nil { return } contentType = resp . Header . Get ( "Content-Type" ) data = resp . Body return }
7147	func ( c Client ) Stream ( method , path string , query url . Values , body io . Reader , accept [ ] string ) ( data io . ReadCloser , contentType string , err error ) { return c . StreamContext ( nil , method , path , query , body , accept ) }
7148	func JSONUnmarshal ( data [ ] byte , v interface { } ) error { if err := json . Unmarshal ( data , v ) ; err != nil { switch e := err . ( type ) { case * json . SyntaxError : line , col := getLineColFromOffset ( data , e . Offset ) return fmt . Errorf ( "json %s, line: %d, column: %d" , e , line , col ) case * json . UnmarshalTypeError : line , col := getLineColFromOffset ( data , e . Offset ) return fmt . Errorf ( "expected json %s value but got %s, line: %d, column: %d" , e . Type , e . Value , line , col ) } return err } return nil }
7149	func ( s * Server ) ServeTCP ( ln net . Listener ) ( err error ) { if l , ok := ln . ( * net . TCPListener ) ; ok { ln = tcpKeepAliveListener { TCPListener : l } } if s . TLSConfig != nil { ln = tls . NewListener ( ln , s . TLSConfig ) } err = s . Server . Serve ( ln ) if err == http . ErrServerClosed { return nil } return }
7150	func ( s * Server ) ServeTCP ( ln net . Listener ) ( err error ) { return s . Server . Serve ( ln ) }
7151	func ( s * Server ) Shutdown ( ctx context . Context ) ( err error ) { s . Server . GracefulStop ( ) return }
7152	func HandleMethods ( methods map [ string ] http . Handler , body string , contentType string , w http . ResponseWriter , r * http . Request ) { if handler , ok := methods [ r . Method ] ; ok { handler . ServeHTTP ( w , r ) } else { allow := [ ] string { } for k := range methods { allow = append ( allow , k ) } sort . Strings ( allow ) w . Header ( ) . Set ( "Allow" , strings . Join ( allow , ", " ) ) if r . Method == "OPTIONS" { w . WriteHeader ( http . StatusOK ) } else { w . Header ( ) . Set ( "Content-Type" , contentType ) w . WriteHeader ( http . StatusMethodNotAllowed ) fmt . Fprintln ( w , body ) } } }
7153	func NewSetHeadersHandler ( h http . Handler , headers map [ string ] string ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { for header , value := range headers { w . Header ( ) . Set ( header , value ) } h . ServeHTTP ( w , r ) } ) }
7154	func New ( root , dir string , options * Options ) * Server { if options == nil { options = & Options { } } return & Server { Options : * options , root : root , dir : dir , hashes : map [ string ] string { } , mu : & sync . RWMutex { } , } }
7155	func ( s * Server ) HashedPath ( p string ) ( string , error ) { if s . Hasher == nil { return path . Join ( s . root , p ) , nil } h , cont , err := s . hash ( p ) if err != nil { if cont { h , _ , err = s . hashFromFilename ( p ) } if err != nil { return "" , err } } return path . Join ( s . root , s . hashedPath ( p , h ) ) , nil }
7156	func New ( options ... Option ) ( s * Service ) { s = & Service { logger : stdLogger { } , } for _ , option := range options { option ( s ) } if s . store == nil { s . store = NewMemoryStore ( ) } return }
7157	func ( s Service ) HTMLHandler ( h http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { on , err := s . store . Status ( ) if err != nil { s . logger . Errorf ( "maintenance status: %v" , err ) } if on || err != nil { if s . HTML . Handler != nil { s . HTML . Handler . ServeHTTP ( w , r ) return } w . Header ( ) . Set ( "Content-Type" , HTMLContentType ) w . WriteHeader ( http . StatusServiceUnavailable ) fmt . Fprintln ( w , s . HTML . Body ) return } h . ServeHTTP ( w , r ) } ) }
7158	func ( s Service ) Status ( ) ( on bool , err error ) { return s . store . Status ( ) }
7159	func ( s Service ) StatusHandler ( w http . ResponseWriter , r * http . Request ) { on , err := s . store . Status ( ) if err != nil { s . logger . Errorf ( "maintenance status: %s" , err ) jsonInternalServerErrorResponse ( w ) return } jsonStatusResponse ( w , on ) }
7160	func ( s Service ) OnHandler ( w http . ResponseWriter , r * http . Request ) { changed , err := s . store . On ( ) if err != nil { s . logger . Errorf ( "maintenance on: %s" , err ) jsonInternalServerErrorResponse ( w ) return } if changed { s . logger . Infof ( "maintenance on" ) jsonCreatedResponse ( w ) return } jsonOKResponse ( w ) }
7161	func ( s Service ) OffHandler ( w http . ResponseWriter , r * http . Request ) { changed , err := s . store . Off ( ) if err != nil { s . logger . Errorf ( "maintenance off: %s" , err ) jsonInternalServerErrorResponse ( w ) return } if changed { s . logger . Infof ( "maintenance off" ) } jsonOKResponse ( w ) }
7162	func ( this * PostIRCMessageRequest ) MarshalJSON ( ) ( [ ] byte , error ) { x := json . RawMessage ( * this ) return ( & x ) . MarshalJSON ( ) }
7163	func ( this * PostArtifactRequest ) MarshalJSON ( ) ( [ ] byte , error ) { x := json . RawMessage ( * this ) return ( & x ) . MarshalJSON ( ) }
7164	func ( this * PostArtifactResponse ) MarshalJSON ( ) ( [ ] byte , error ) { x := json . RawMessage ( * this ) return ( & x ) . MarshalJSON ( ) }
7165	func ( this * HookChangedMessage ) MarshalJSON ( ) ( [ ] byte , error ) { x := json . RawMessage ( * this ) return ( & x ) . MarshalJSON ( ) }
7166	func ( this * TriggerHookRequest ) MarshalJSON ( ) ( [ ] byte , error ) { x := json . RawMessage ( * this ) return ( & x ) . MarshalJSON ( ) }
7167	func ( this * TriggerHookResponse ) MarshalJSON ( ) ( [ ] byte , error ) { x := json . RawMessage ( * this ) return ( & x ) . MarshalJSON ( ) }
7168	func ( this * TriggerHookResponse ) UnmarshalJSON ( data [ ] byte ) error { if this == nil { return errors . New ( "TriggerHookResponse: UnmarshalJSON on nil pointer" ) } * this = append ( ( * this ) [ 0 : 0 ] , data ... ) return nil }
7169	func ( this * LaunchInfo ) MarshalJSON ( ) ( [ ] byte , error ) { x := json . RawMessage ( * this ) return ( & x ) . MarshalJSON ( ) }
7170	func ( this * Var ) MarshalJSON ( ) ( [ ] byte , error ) { x := json . RawMessage ( * this ) return ( & x ) . MarshalJSON ( ) }
7171	func ( this * Var1 ) MarshalJSON ( ) ( [ ] byte , error ) { x := json . RawMessage ( * this ) return ( & x ) . MarshalJSON ( ) }
7172	func ( this * Var3 ) MarshalJSON ( ) ( [ ] byte , error ) { x := json . RawMessage ( * this ) return ( & x ) . MarshalJSON ( ) }
7173	func ( t Time ) MarshalJSON ( ) ( [ ] byte , error ) { if y := time . Time ( t ) . Year ( ) ; y < 0 || y >= 10000 { return nil , errors . New ( "queue.Time.MarshalJSON: year outside of range [0,9999]" ) } return [ ] byte ( `"` + t . String ( ) + `"` ) , nil }
7174	func ( t * Time ) UnmarshalJSON ( data [ ] byte ) ( err error ) { x := new ( time . Time ) * x , err = time . Parse ( `"` + time . RFC3339 + `"` , string ( data ) ) * t = Time ( * x ) return }
7175	func ( rws * ReadWriteSeeker ) Write ( p [ ] byte ) ( n int , err error ) { minCap := rws . pos + len ( p ) if minCap > cap ( rws . buf ) { buf2 := make ( [ ] byte , len ( rws . buf ) , minCap + len ( p ) ) copy ( buf2 , rws . buf ) rws . buf = buf2 } if minCap > len ( rws . buf ) { rws . buf = rws . buf [ : minCap ] } copy ( rws . buf [ rws . pos : ] , p ) rws . pos += len ( p ) return len ( p ) , nil }
7176	func ( rws * ReadWriteSeeker ) Seek ( offset int64 , whence int ) ( int64 , error ) { newPos , offs := 0 , int ( offset ) switch whence { case io . SeekStart : newPos = offs case io . SeekCurrent : newPos = rws . pos + offs case io . SeekEnd : newPos = len ( rws . buf ) + offs } if newPos < 0 { return 0 , errors . New ( "negative result pos" ) } rws . pos = newPos return int64 ( newPos ) , nil }
7177	func ( rws * ReadWriteSeeker ) Read ( b [ ] byte ) ( n int , err error ) { if rws . pos >= len ( rws . buf ) { return 0 , io . EOF } n = copy ( b , rws . buf [ rws . pos : ] ) rws . pos += n return }
7178	func ( this * LaunchSpecsResponse ) MarshalJSON ( ) ( [ ] byte , error ) { x := json . RawMessage ( * this ) return ( & x ) . MarshalJSON ( ) }
7179	func ( this * RegionLaunchSpec ) MarshalJSON ( ) ( [ ] byte , error ) { x := json . RawMessage ( * this ) return ( & x ) . MarshalJSON ( ) }
7180	func ( apiDefs APIDefinitions ) GenerateCode ( goOutputDir , modelData string , downloaded time . Time ) { downloadedTime = downloaded for i := range apiDefs { apiDefs [ i ] . PackageName = "tc" + strings . ToLower ( apiDefs [ i ] . Data . Name ( ) ) apiDefs [ i ] . ExampleVarName = strings . ToLower ( string ( apiDefs [ i ] . Data . Name ( ) [ 0 ] ) ) + apiDefs [ i ] . Data . Name ( ) [ 1 : ] if apiDefs [ i ] . ExampleVarName == apiDefs [ i ] . Data . Name ( ) || apiDefs [ i ] . ExampleVarName == apiDefs [ i ] . PackageName { apiDefs [ i ] . ExampleVarName = "my" + apiDefs [ i ] . Data . Name ( ) } apiDefs [ i ] . PackagePath = filepath . Join ( goOutputDir , apiDefs [ i ] . PackageName ) err = os . MkdirAll ( apiDefs [ i ] . PackagePath , 0755 ) exitOnFail ( err ) fmt . Printf ( "Generating go types for %s\n" , \n ) apiDefs [ i ] . PackageName job := & jsonschema2go . Job { Package : apiDefs [ i ] . PackageName , URLs : apiDefs [ i ] . schemaURLs , ExportTypes : true , TypeNameBlacklist : apiDefs [ i ] . members , DisableNestedStructs : true , } result , err := job . Execute ( ) exitOnFail ( err ) apiDefs [ i ] . schemas = result . SchemaSet typesSourceFile := filepath . Join ( apiDefs [ i ] . PackagePath , "types.go" ) FormatSourceAndSave ( typesSourceFile , result . SourceCode ) fmt . Printf ( "Generating functions and methods for %s\n" , \n ) job . Package content := `// The following code is AUTO-GENERATED. Please DO NOT edit.// To update this generated code, run the following command:// in the /codegenerator/model subdirectory of this project,// making sure that ` + "`${GOPATH}/bin` is in your `PATH`" + `://// go install && go generate//// This package was generated from the schema defined at// ` + apiDefs [ i ] . URL + `` content += apiDefs [ i ] . generateAPICode ( ) } sourceFile := filepath . Join ( apiDefs [ i ] . PackagePath , apiDefs [ i ] . PackageName + ".go" ) FormatSourceAndSave ( sourceFile , [ ] byte ( content ) ) content := "Generated: " + strconv . FormatInt ( downloadedTime . Unix ( ) , 10 ) + "\n" \n content += "The following file is an auto-generated static dump of the API models at time of code generation.\n" \n }
7181	func ( entry * APIEntry ) postPopulate ( apiDef * APIDefinition ) { if x := & entry . Parent . apiDef . schemaURLs ; entry . Input != "" { entry . InputURL = tcurls . Schema ( tcclient . RootURLFromEnvVars ( ) , entry . Parent . ServiceName , entry . Input ) * x = append ( * x , entry . InputURL ) } if x := & entry . Parent . apiDef . schemaURLs ; entry . Output != "" { entry . OutputURL = tcurls . Schema ( tcclient . RootURLFromEnvVars ( ) , entry . Parent . ServiceName , entry . Output ) * x = append ( * x , entry . OutputURL ) } }
7182	func ( permaCreds * Credentials ) CreateTemporaryCredentials ( duration time . Duration , scopes ... string ) ( tempCreds * Credentials , err error ) { return permaCreds . CreateNamedTemporaryCredentials ( "" , duration , scopes ... ) }
7183	func setURL ( client * Client , route string , query url . Values ) ( u * url . URL , err error ) { URL := client . BaseURL if strings . HasSuffix ( URL , "/" ) { URL = URL [ : len ( URL ) - 1 ] } URL += route u , err = url . Parse ( URL ) if err != nil { return nil , fmt . Errorf ( "Cannot parse url: '%v', is BaseURL (%v) set correctly?\n%v\n" , \n , \n , URL ) } client . BaseURL err }
7184	func ( c * Credentials ) SignRequest ( req * http . Request ) ( err error ) { credentials := & hawk . Credentials { ID : c . ClientID , Key : c . AccessToken , Hash : sha256 . New , } reqAuth := hawk . NewRequestAuth ( req , credentials , 0 ) reqAuth . Ext , err = getExtHeader ( c ) if err != nil { return fmt . Errorf ( "Internal error: was not able to generate hawk ext header from provided credentials:\n%s\n%s" , \n , \n ) } c err }
7185	func ( client * Client ) APICall ( payload interface { } , method , route string , result interface { } , query url . Values ) ( interface { } , * CallSummary , error ) { rawPayload := [ ] byte { } var err error if reflect . ValueOf ( payload ) . IsValid ( ) && ! reflect . ValueOf ( payload ) . IsNil ( ) { rawPayload , err = json . Marshal ( payload ) if err != nil { cs := & CallSummary { HTTPRequestObject : payload , } return result , cs , & APICallException { CallSummary : cs , RootCause : err , } } } callSummary , err := client . Request ( rawPayload , method , route , query ) callSummary . HTTPRequestObject = payload if err != nil { if client . Context != nil && client . Context . Err ( ) != nil { return result , callSummary , client . Context . Err ( ) } return result , callSummary , & APICallException { CallSummary : callSummary , RootCause : err , } } if reflect . ValueOf ( result ) . IsValid ( ) && ! reflect . ValueOf ( result ) . IsNil ( ) { err = json . Unmarshal ( [ ] byte ( callSummary . HTTPResponseBody ) , & result ) } if err != nil { return result , callSummary , & APICallException { CallSummary : callSummary , RootCause : err , } } return result , callSummary , nil }
7186	func ( client * Client ) SignedURL ( route string , query url . Values , duration time . Duration ) ( u * url . URL , err error ) { u , err = setURL ( client , route , query ) if err != nil { return } credentials := & hawk . Credentials { ID : client . Credentials . ClientID , Key : client . Credentials . AccessToken , Hash : sha256 . New , } reqAuth , err := hawk . NewURLAuth ( u . String ( ) , credentials , duration ) if err != nil { return } reqAuth . Ext , err = getExtHeader ( client . Credentials ) if err != nil { return } bewitSignature := reqAuth . Bewit ( ) if query == nil { query = url . Values { } } query . Set ( "bewit" , bewitSignature ) u . RawQuery = query . Encode ( ) return }
7187	func ( this * HawkSignatureAuthenticationResponse ) MarshalJSON ( ) ( [ ] byte , error ) { x := json . RawMessage ( * this ) return ( & x ) . MarshalJSON ( ) }
7188	func bmw256 ( input [ ] byte ) [ ] byte { b := new ( type_identifier ) buf := make ( [ ] byte , 64 ) copy ( buf , input ) buf [ len ( input ) ] = 0x80 bitLen := uint64 ( len ( input ) ) << 3 binary . LittleEndian . PutUint64 ( buf [ 56 : ] , bitLen ) for i := 0 ; i < 16 ; i ++ { b . m [ i ] = binary . LittleEndian . Uint32 ( buf [ i * 4 : ] ) } b . compress ( b . m ) b . h , b . h2 = b . h2 , b . h copy ( b . h , final ) b . compress ( b . h2 ) output := make ( [ ] byte , 32 ) outlen := len ( output ) >> 2 for i := 0 ; i < outlen ; i ++ { j := 16 - outlen + i binary . LittleEndian . PutUint32 ( output [ 4 * i : ] , b . h [ j ] ) } return output }
7189	func NewCubeHash ( ) * CubeHash { c := & CubeHash { } c . x0 = iv [ 0 ] c . x1 = iv [ 1 ] c . x2 = iv [ 2 ] c . x3 = iv [ 3 ] c . x4 = iv [ 4 ] c . x5 = iv [ 5 ] c . x6 = iv [ 6 ] c . x7 = iv [ 7 ] c . x8 = iv [ 8 ] c . x9 = iv [ 9 ] c . xa = iv [ 10 ] c . xb = iv [ 11 ] c . xc = iv [ 12 ] c . xd = iv [ 13 ] c . xe = iv [ 14 ] c . xf = iv [ 15 ] c . xg = iv [ 16 ] c . xh = iv [ 17 ] c . xi = iv [ 18 ] c . xj = iv [ 19 ] c . xk = iv [ 20 ] c . xl = iv [ 21 ] c . xm = iv [ 22 ] c . xn = iv [ 23 ] c . xo = iv [ 24 ] c . xp = iv [ 25 ] c . xq = iv [ 26 ] c . xr = iv [ 27 ] c . xs = iv [ 28 ] c . xt = iv [ 29 ] c . xu = iv [ 30 ] c . xv = iv [ 31 ] return c }
7190	func cubehash256 ( data [ ] byte ) [ ] byte { c := NewCubeHash ( ) buf := make ( [ ] byte , 32 ) buf [ 0 ] = 0x80 c . inputBlock ( data ) c . sixteenRounds ( ) c . inputBlock ( buf ) c . sixteenRounds ( ) c . xv ^= 1 for j := 0 ; j < 10 ; j ++ { c . sixteenRounds ( ) } out := make ( [ ] byte , 32 ) binary . LittleEndian . PutUint32 ( out [ 0 : ] , c . x0 ) binary . LittleEndian . PutUint32 ( out [ 4 : ] , c . x1 ) binary . LittleEndian . PutUint32 ( out [ 8 : ] , c . x2 ) binary . LittleEndian . PutUint32 ( out [ 12 : ] , c . x3 ) binary . LittleEndian . PutUint32 ( out [ 16 : ] , c . x4 ) binary . LittleEndian . PutUint32 ( out [ 20 : ] , c . x5 ) binary . LittleEndian . PutUint32 ( out [ 24 : ] , c . x6 ) binary . LittleEndian . PutUint32 ( out [ 28 : ] , c . x7 ) return out }
7191	func Sum ( data [ ] byte ) ( [ ] byte , error ) { blake := blake256 . New ( ) if _ , err := blake . Write ( data ) ; err != nil { return nil , err } resultBlake := blake . Sum ( nil ) keccak := sha3 . NewKeccak256 ( ) if _ , err := keccak . Write ( resultBlake ) ; err != nil { return nil , err } resultkeccak := keccak . Sum ( nil ) resultcube := cubehash256 ( resultkeccak ) lyra2result := make ( [ ] byte , 32 ) lyra2 ( lyra2result , resultcube , resultcube , 1 , 4 , 4 ) var skeinresult [ 32 ] byte skein . Sum256 ( & skeinresult , lyra2result , nil ) resultcube2 := cubehash256 ( skeinresult [ : ] ) resultbmw := bmw256 ( resultcube2 ) return resultbmw , nil }
7192	func squeeze ( state [ ] uint64 , out [ ] byte ) { tmp := make ( [ ] byte , blockLenBytes ) for j := 0 ; j < len ( out ) / blockLenBytes + 1 ; j ++ { for i := 0 ; i < blockLenInt64 ; i ++ { binary . LittleEndian . PutUint64 ( tmp [ i * 8 : ] , state [ i ] ) } copy ( out [ j * blockLenBytes : ] , tmp ) blake2bLyra ( state ) } }
7193	func reducedSqueezeRow0 ( state [ ] uint64 , rowOut [ ] uint64 , nCols int ) { ptr := ( nCols - 1 ) * blockLenInt64 for i := 0 ; i < nCols ; i ++ { ptrWord := rowOut [ ptr : ] ptrWord [ 0 ] = state [ 0 ] ptrWord [ 1 ] = state [ 1 ] ptrWord [ 2 ] = state [ 2 ] ptrWord [ 3 ] = state [ 3 ] ptrWord [ 4 ] = state [ 4 ] ptrWord [ 5 ] = state [ 5 ] ptrWord [ 6 ] = state [ 6 ] ptrWord [ 7 ] = state [ 7 ] ptrWord [ 8 ] = state [ 8 ] ptrWord [ 9 ] = state [ 9 ] ptrWord [ 10 ] = state [ 10 ] ptrWord [ 11 ] = state [ 11 ] ptr -= blockLenInt64 reducedBlake2bLyra ( state ) } }
7194	func reducedDuplexRow1 ( state [ ] uint64 , rowIn [ ] uint64 , rowOut [ ] uint64 , nCols int ) { ptrIn := 0 ptrOut := ( nCols - 1 ) * blockLenInt64 for i := 0 ; i < nCols ; i ++ { ptrWordIn := rowIn [ ptrIn : ] ptrWordOut := rowOut [ ptrOut : ] state [ 0 ] ^= ( ptrWordIn [ 0 ] ) state [ 1 ] ^= ( ptrWordIn [ 1 ] ) state [ 2 ] ^= ( ptrWordIn [ 2 ] ) state [ 3 ] ^= ( ptrWordIn [ 3 ] ) state [ 4 ] ^= ( ptrWordIn [ 4 ] ) state [ 5 ] ^= ( ptrWordIn [ 5 ] ) state [ 6 ] ^= ( ptrWordIn [ 6 ] ) state [ 7 ] ^= ( ptrWordIn [ 7 ] ) state [ 8 ] ^= ( ptrWordIn [ 8 ] ) state [ 9 ] ^= ( ptrWordIn [ 9 ] ) state [ 10 ] ^= ( ptrWordIn [ 10 ] ) state [ 11 ] ^= ( ptrWordIn [ 11 ] ) reducedBlake2bLyra ( state ) ptrWordOut [ 0 ] = ptrWordIn [ 0 ] ^ state [ 0 ] ptrWordOut [ 1 ] = ptrWordIn [ 1 ] ^ state [ 1 ] ptrWordOut [ 2 ] = ptrWordIn [ 2 ] ^ state [ 2 ] ptrWordOut [ 3 ] = ptrWordIn [ 3 ] ^ state [ 3 ] ptrWordOut [ 4 ] = ptrWordIn [ 4 ] ^ state [ 4 ] ptrWordOut [ 5 ] = ptrWordIn [ 5 ] ^ state [ 5 ] ptrWordOut [ 6 ] = ptrWordIn [ 6 ] ^ state [ 6 ] ptrWordOut [ 7 ] = ptrWordIn [ 7 ] ^ state [ 7 ] ptrWordOut [ 8 ] = ptrWordIn [ 8 ] ^ state [ 8 ] ptrWordOut [ 9 ] = ptrWordIn [ 9 ] ^ state [ 9 ] ptrWordOut [ 10 ] = ptrWordIn [ 10 ] ^ state [ 10 ] ptrWordOut [ 11 ] = ptrWordIn [ 11 ] ^ state [ 11 ] ptrIn += blockLenInt64 ptrOut -= blockLenInt64 } }
7195	func NewReaderByteCodeLoader ( p parser . Parser , c compiler . Compiler ) * ReaderByteCodeLoader { return & ReaderByteCodeLoader { NewFlags ( ) , p , c } }
7196	func ( l * ReaderByteCodeLoader ) LoadReader ( name string , rdr io . Reader ) ( * vm . ByteCode , error ) { ast , err := l . Parser . ParseReader ( name , rdr ) if err != nil { return nil , err } if l . ShouldDumpAST ( ) { fmt . Fprintf ( os . Stderr , "AST:\n%s\n" , \n ) } \n ast bc , err := l . Compiler . Compile ( ast ) }
7197	func NewV3 ( namespace * UUID , name [ ] byte ) * UUID { uuid := newByHash ( md5 . New ( ) , namespace , name ) uuid [ 6 ] = ( uuid [ 6 ] & 0x0f ) | 0x30 return uuid }
7198	func txLiteral ( st * State ) { st . sa = st . CurrentOp ( ) . Arg ( ) st . Advance ( ) }
7199	func txFetchSymbol ( st * State ) { key := st . CurrentOp ( ) . Arg ( ) vars := st . Vars ( ) if v , ok := vars . Get ( key ) ; ok { st . sa = v } else { st . sa = nil } st . Advance ( ) }
7200	func txMarkRaw ( st * State ) { if reflect . ValueOf ( st . sa ) . Type ( ) != rawStringType { st . sa = rawString ( interfaceToString ( st . sa ) ) } st . Advance ( ) }
7201	func txUnmarkRaw ( st * State ) { if reflect . ValueOf ( st . sa ) . Type ( ) == rawStringType { st . sa = string ( interfaceToString ( st . sa ) ) } st . Advance ( ) }
7202	func txPrint ( st * State ) { arg := st . sa if arg == nil { st . Warnf ( "Use of nil to print\n" ) } else \n if reflect . ValueOf ( st . sa ) . Type ( ) != rawStringType { st . AppendOutputString ( html . EscapeString ( interfaceToString ( arg ) ) ) } else { st . AppendOutputString ( interfaceToString ( arg ) ) } }
7203	func txPrintRaw ( st * State ) { arg := st . sa if arg == nil { st . Warnf ( "Use of nil to print\n" ) } else \n { st . AppendOutputString ( interfaceToString ( arg ) ) } }
7204	func NewLoopVar ( idx int , array reflect . Value ) * LoopVar { lv := & LoopVar { Index : idx , Count : idx + 1 , Body : array , Size : array . Len ( ) , MaxIndex : array . Len ( ) - 1 , PeekNext : nil , PeekPrev : nil , IsFirst : false , IsLast : false , } return lv }
7205	func txMakeArray ( st * State ) { start := st . CurrentMark ( ) end := st . StackTip ( ) if end <= start { panic ( fmt . Sprintf ( "MakeArray: list start (%d) >= end (%d)" , start , end ) ) } list := make ( [ ] interface { } , end - start + 1 ) for i := end ; i >= start ; i -- { list [ i - start ] = st . StackPop ( ) } st . sa = list st . Advance ( ) }
7206	func txFunCallOmni ( st * State ) { t := reflect . ValueOf ( st . sa ) switch t . Kind ( ) { case reflect . Int : txMacroCall ( st ) case reflect . Func : txFunCall ( st ) default : st . Warnf ( "Unknown variable as function call: %s\n" , \n ) st . sa st . sa = nil } }
7207	func ( f * Flags ) DumpAST ( b bool ) { if b { f . flags |= MaskDumpAST } else { f . flags &= ^ MaskDumpAST } }
7208	func ( f * Flags ) DumpByteCode ( b bool ) { if b { f . flags |= MaskDumpByteCode } else { f . flags &= ^ MaskDumpByteCode } }
7209	func ( o * NaiveOptimizer ) Optimize ( bc * vm . ByteCode ) error { for i := 0 ; i < bc . Len ( ) ; i ++ { op := bc . Get ( i ) if op == nil { return errors . New ( "failed to fetch op '" + op . String ( ) + "'" ) } switch op . Type ( ) { case vm . TXOPLiteral : if i + 1 < bc . Len ( ) && bc . Get ( i + 1 ) . Type ( ) == vm . TXOPPrintRaw { bc . OpList [ i ] = vm . NewOp ( vm . TXOPPrintRawConst , op . ArgString ( ) ) bc . OpList [ i + 1 ] = vm . NewOp ( vm . TXOPNoop ) i ++ } } } return nil }
7210	func NewFuncDepot ( namespace string ) * FuncDepot { return & FuncDepot { namespace , make ( map [ string ] reflect . Value ) } }
7211	func ( fc * FuncDepot ) Get ( key string ) ( reflect . Value , bool ) { f , ok := fc . depot [ key ] return f , ok }
7212	func ( fc * FuncDepot ) Set ( key string , v interface { } ) { fc . depot [ key ] = reflect . ValueOf ( v ) }
7213	func NewFileTemplateFetcher ( paths [ ] string ) ( * FileTemplateFetcher , error ) { l := & FileTemplateFetcher { Paths : make ( [ ] string , len ( paths ) ) , } for k , v := range paths { abs , err := filepath . Abs ( v ) if err != nil { return nil , err } l . Paths [ k ] = abs } return l , nil }
7214	func ( s * FileSource ) LastModified ( ) ( time . Time , error ) { if time . Since ( s . LastStat ) < time . Second { return s . LastStatResult . ModTime ( ) , nil } fi , err := os . Stat ( s . Path ) if err != nil { return time . Time { } , err } s . LastStat = time . Now ( ) s . LastStatResult = fi return s . LastStatResult . ModTime ( ) , nil }
7215	func ( s * FileSource ) Reader ( ) ( io . Reader , error ) { fh , err := os . Open ( s . Path ) if err != nil { return nil , err } return fh , nil }
7216	func ( s * FileSource ) Bytes ( ) ( [ ] byte , error ) { rdr , err := s . Reader ( ) if err != nil { return nil , err } return ioutil . ReadAll ( rdr ) }
7217	func NewState ( ) * State { st := & State { opidx : 0 , pc : NewByteCode ( ) , stack : stack . New ( 5 ) , markstack : stack . New ( 5 ) , framestack : stack . New ( 5 ) , frames : stack . New ( 5 ) , vars : make ( Vars ) , warn : os . Stderr , MaxLoopCount : 1000 , } st . Pushmark ( ) st . PushFrame ( ) return st }
7218	func ( st * State ) PushFrame ( ) * frame . Frame { f := frame . New ( st . framestack ) st . frames . Push ( f ) f . SetMark ( st . frames . Size ( ) ) return f }
7219	func ( st * State ) PopFrame ( ) * frame . Frame { x := st . frames . Pop ( ) if x == nil { return nil } f := x . ( * frame . Frame ) for i := st . framestack . Size ( ) ; i > f . Mark ( ) ; i -- { st . framestack . Pop ( ) } return f }
7220	func ( st * State ) CurrentFrame ( ) * frame . Frame { x , err := st . frames . Top ( ) if err != nil { return nil } return x . ( * frame . Frame ) }
7221	func ( st * State ) Warnf ( format string , args ... interface { } ) { st . warn . Write ( [ ] byte ( fmt . Sprintf ( format , args ... ) ) ) }
7222	func ( st * State ) AppendOutputString ( o string ) { st . output . Write ( [ ] byte ( o ) ) }
7223	func ( st * State ) Popmark ( ) int { x := st . markstack . Pop ( ) return x . ( int ) }
7224	func ( st * State ) CurrentMark ( ) int { x , err := st . markstack . Top ( ) if err != nil { x = 0 } return x . ( int ) }
7225	func ( st * State ) LoadByteCode ( key string ) ( * ByteCode , error ) { return st . Loader . Load ( key ) }
7226	func ( st * State ) Reset ( ) { st . opidx = 0 st . sa = nil st . sb = nil st . stack . Reset ( ) st . markstack . Reset ( ) st . frames . Reset ( ) st . framestack . Reset ( ) st . Pushmark ( ) st . PushFrame ( ) }
7227	func ( f * Frame ) DeclareVar ( v interface { } ) int { f . stack . Push ( v ) return f . stack . Size ( ) - 1 }
7228	func ( f * Frame ) GetLvar ( i int ) ( interface { } , error ) { v , err := f . stack . Get ( i ) if err != nil { return nil , errors . Wrap ( err , "failed to get local variable at " + strconv . Itoa ( i + f . mark ) ) } return v , nil }
7229	func ( f * Frame ) SetLvar ( i int , v interface { } ) { f . stack . Set ( i , v ) }
7230	func NewByteCode ( ) * ByteCode { return & ByteCode { GeneratedOn : time . Now ( ) , Name : "" , OpList : nil , Version : 1.0 , } }
7231	func ( b * ByteCode ) Append ( op Op ) { b . OpList = append ( b . OpList , op ) }
7232	func ( b * ByteCode ) AppendOp ( o OpType , args ... interface { } ) Op { x := NewOp ( o , args ... ) b . Append ( x ) return x }
7233	func ( b * ByteCode ) String ( ) string { buf := rbpool . Get ( ) defer rbpool . Release ( buf ) fmt . Fprintf ( buf , "// Bytecode for '%s'\n// Generated On: %s\n" , \n , \n , ) b . Name b . GeneratedOn }
7234	func NewCachedByteCodeLoader ( cache Cache , cacheLevel CacheStrategy , fetcher TemplateFetcher , parser parser . Parser , compiler compiler . Compiler , ) * CachedByteCodeLoader { return & CachedByteCodeLoader { NewStringByteCodeLoader ( parser , compiler ) , NewReaderByteCodeLoader ( parser , compiler ) , fetcher , [ ] Cache { MemoryCache { } , cache } , cacheLevel , } }
7235	func ( l * CachedByteCodeLoader ) Load ( key string ) ( bc * vm . ByteCode , err error ) { defer func ( ) { if bc != nil && err == nil && l . ShouldDumpByteCode ( ) { fmt . Fprintf ( os . Stderr , "%s\n" , \n ) } } bc . String ( ) ( ) var source TemplateSource if l . CacheLevel > CacheNone { var entity * CacheEntity for _ , cache := range l . Caches { entity , err = cache . Get ( key ) if err == nil { break } } if err == nil { if l . CacheLevel == CacheNoVerify { return entity . ByteCode , nil } t , err := entity . Source . LastModified ( ) if err != nil { return nil , errors . Wrap ( err , "failed to get last-modified from source" ) } if t . Before ( entity . ByteCode . GeneratedOn ) { return entity . ByteCode , nil } source = entity . Source } } if source == nil { source , err = l . Fetcher . FetchTemplate ( key ) if err != nil { return nil , errors . Wrap ( err , "failed to fetch template" ) } } rdr , err := source . Reader ( ) if err != nil { return nil , errors . Wrap ( err , "failed to get the reader" ) } bc , err = l . LoadReader ( key , rdr ) if err != nil { return nil , errors . Wrap ( err , "failed to read byte code" ) } entity := & CacheEntity { bc , source } for _ , cache := range l . Caches { cache . Set ( key , entity ) } }
7236	func NewFileCache ( dir string ) ( * FileCache , error ) { f := & FileCache { dir } return f , nil }
7237	func ( c * FileCache ) GetCachePath ( key string ) string { key = filepath . Clean ( key ) key = strings . TrimPrefix ( key , "/" ) return filepath . Join ( c . Dir , key ) }
7238	func ( c * FileCache ) Get ( key string ) ( * CacheEntity , error ) { path := c . GetCachePath ( key ) file , err := os . Open ( path ) if err != nil { return nil , errors . Wrap ( err , "failed to open cache file '" + path + "'" ) } defer file . Close ( ) var entity CacheEntity dec := gob . NewDecoder ( file ) if err = dec . Decode ( & entity ) ; err != nil { return nil , errors . Wrap ( err , "failed to gob decode from cache file '" + path + "'" ) } return & entity , nil }
7239	func ( c * FileCache ) Set ( key string , entity * CacheEntity ) error { path := c . GetCachePath ( key ) if err := os . MkdirAll ( filepath . Dir ( path ) , 0777 ) ; err != nil { return errors . Wrap ( err , "failed to create directory for cache file" ) } file , err := os . OpenFile ( path , os . O_WRONLY | os . O_CREATE , 0666 ) if err != nil { return errors . Wrap ( err , "failed to open/create a cache file" ) } defer file . Close ( ) f := bufio . NewWriter ( file ) defer f . Flush ( ) enc := gob . NewEncoder ( f ) if err = enc . Encode ( entity ) ; err != nil { return errors . Wrap ( err , "failed to encode Entity via gob" ) } return nil }
7240	func ( c * FileCache ) Delete ( key string ) error { return errors . Wrap ( os . Remove ( c . GetCachePath ( key ) ) , "failed to remove file cache file" ) }
7241	func ( c MemoryCache ) Get ( key string ) ( * CacheEntity , error ) { bc , ok := c [ key ] if ! ok { return nil , errors . New ( "cache miss" ) } return bc , nil }
7242	func ( c MemoryCache ) Set ( key string , bc * CacheEntity ) error { c [ key ] = bc return nil }
7243	func ( c MemoryCache ) Delete ( key string ) error { delete ( c , key ) return nil }
7244	func NewStringLexer ( template string ) * parser . Lexer { l := parser . NewStringLexer ( template , SymbolSet ) l . SetTagStart ( "[%" ) l . SetTagEnd ( "%]" ) return l }
7245	func NewReaderLexer ( rdr io . Reader ) * parser . Lexer { l := parser . NewReaderLexer ( rdr , SymbolSet ) l . SetTagStart ( "[%" ) l . SetTagEnd ( "%]" ) return l }
7246	func NewV4 ( ) * UUID { buf := make ( [ ] byte , 16 ) rand . Read ( buf ) buf [ 6 ] = ( buf [ 6 ] & 0x0f ) | 0x40 var uuid UUID copy ( uuid [ : ] , buf [ : ] ) uuid . variantRFC4122 ( ) return & uuid }
7247	func ( p * Kolonish ) Parse ( name string , template [ ] byte ) ( * parser . AST , error ) { return p . ParseString ( name , string ( template ) ) }
7248	func ( p * Kolonish ) ParseReader ( name string , rdr io . Reader ) ( * parser . AST , error ) { b := parser . NewBuilder ( ) lex := NewReaderLexer ( rdr ) return b . Parse ( name , lex ) }
7249	func ( ast * AST ) Visit ( ) <- chan node . Node { c := make ( chan node . Node ) go func ( ) { defer close ( c ) ast . Root . Visit ( c ) } ( ) return c }
7250	func ( ast * AST ) String ( ) string { buf := rbpool . Get ( ) defer rbpool . Release ( buf ) c := ast . Visit ( ) k := 0 for v := range c { k ++ fmt . Fprintf ( buf , "%03d. %s\n" , \n , k ) } v }
7251	func ( vm * VM ) Run ( bc * ByteCode , vars Vars , output io . Writer ) { if ! vm . IsSupportedByteCodeVersion ( bc ) { panic ( fmt . Sprintf ( "error: ByteCode version %f no supported" , bc . Version , ) ) } st := vm . st if _ , ok := output . ( * bufio . Writer ) ; ! ok { output = bufio . NewWriter ( output ) defer output . ( * bufio . Writer ) . Flush ( ) } st . Reset ( ) st . pc = bc st . output = output newvars := Vars ( rvpool . Get ( ) ) defer rvpool . Release ( newvars ) defer newvars . Reset ( ) st . vars = newvars if fc := vm . functions ; fc != nil { for k , v := range vm . functions { st . vars [ k ] = v } } if vars != nil { for k , v := range vars { st . vars [ k ] = v } } st . Loader = vm . Loader for op := st . CurrentOp ( ) ; op . Type ( ) != TXOPEnd ; op = st . CurrentOp ( ) { op . Call ( st ) } }
7252	func DefaultParser ( tx * Xslate , args Args ) error { syntax , ok := args . Get ( "Syntax" ) if ! ok { syntax = "TTerse" } switch syntax { case "TTerse" : tx . Parser = tterse . New ( ) case "Kolon" , "Kolonish" : tx . Parser = kolonish . New ( ) default : return errors . New ( "sytanx '" + syntax . ( string ) + "' is not available" ) } return nil }
7253	func DefaultLoader ( tx * Xslate , args Args ) error { var tmp interface { } tmp , ok := args . Get ( "CacheDir" ) if ! ok { tmp , _ = ioutil . TempDir ( "" , "go-xslate-cache-" ) } cacheDir := tmp . ( string ) tmp , ok = args . Get ( "LoadPaths" ) if ! ok { cwd , _ := os . Getwd ( ) tmp = [ ] string { cwd } } paths := tmp . ( [ ] string ) cache , err := loader . NewFileCache ( cacheDir ) if err != nil { return err } fetcher , err := loader . NewFileTemplateFetcher ( paths ) if err != nil { return err } tmp , ok = args . Get ( "CacheLevel" ) if ! ok { tmp = 1 } cacheLevel := tmp . ( int ) tx . Loader = loader . NewCachedByteCodeLoader ( cache , loader . CacheStrategy ( cacheLevel ) , fetcher , tx . Parser , tx . Compiler ) return nil }
7254	func DefaultVM ( tx * Xslate , args Args ) error { dvm := vm . NewVM ( ) dvm . Loader = tx . Loader tx . VM = dvm return nil }
7255	func ( args Args ) Get ( key string ) ( interface { } , bool ) { ret , ok := args [ key ] return ret , ok }
7256	func NewHTTPSource ( r * http . Response ) ( * HTTPSource , error ) { body , err := ioutil . ReadAll ( r . Body ) if err != nil { return nil , err } s := & HTTPSource { bytes . NewBuffer ( body ) , time . Time { } , } if lastmodStr := r . Header . Get ( "Last-Modified" ) ; lastmodStr != "" { t , err := time . Parse ( http . TimeFormat , lastmodStr ) if err != nil { fmt . Printf ( "failed to parse: %s\n" , \n ) err } t = time . Now ( ) } else s . LastModifiedTime = t { s . LastModifiedTime = time . Now ( ) } }
7257	func NewStringByteCodeLoader ( p parser . Parser , c compiler . Compiler ) * StringByteCodeLoader { return & StringByteCodeLoader { NewFlags ( ) , p , c } }
7258	func ( l * StringByteCodeLoader ) LoadString ( name string , template string ) ( * vm . ByteCode , error ) { ast , err := l . Parser . ParseString ( name , template ) if err != nil { return nil , err } if l . ShouldDumpAST ( ) { fmt . Fprintf ( os . Stderr , "AST:\n%s\n" , \n ) } \n ast bc , err := l . Compiler . Compile ( ast ) if err != nil { return nil , err } }
7259	func ( v Vars ) Get ( k interface { } ) ( interface { } , bool ) { key , ok := k . ( string ) if ! ok { key = fmt . Sprintf ( "%s" , k ) } x , ok := v [ key ] return x , ok }
7260	func NewOp ( o OpType , args ... interface { } ) Op { h := optypeToHandler ( o ) var arg interface { } if len ( args ) > 0 { arg = args [ 0 ] } return & op { OpType : o , OpHandler : h , uArg : arg , } }
7261	func ( o op ) MarshalBinary ( ) ( [ ] byte , error ) { buf := rbpool . Get ( ) defer rbpool . Release ( buf ) if err := binary . Write ( buf , binary . LittleEndian , int64 ( o . OpType ) ) ; err != nil { return nil , errors . Wrap ( err , "failed to marshal op to binary" ) } tArg := reflect . TypeOf ( o . uArg ) hasArg := tArg != nil if hasArg { binary . Write ( buf , binary . LittleEndian , int8 ( 1 ) ) } else { binary . Write ( buf , binary . LittleEndian , int8 ( 0 ) ) } if hasArg { switch tArg . Kind ( ) { case reflect . Int : binary . Write ( buf , binary . LittleEndian , int64 ( 2 ) ) binary . Write ( buf , binary . LittleEndian , int64 ( o . uArg . ( int ) ) ) case reflect . Int64 : binary . Write ( buf , binary . LittleEndian , int64 ( 2 ) ) binary . Write ( buf , binary . LittleEndian , int64 ( o . uArg . ( int64 ) ) ) case reflect . Slice : if tArg . Elem ( ) . Kind ( ) != reflect . Uint8 { panic ( "Slice of what?" ) } binary . Write ( buf , binary . LittleEndian , int64 ( 5 ) ) binary . Write ( buf , binary . LittleEndian , int64 ( len ( o . uArg . ( [ ] byte ) ) ) ) for _ , v := range o . uArg . ( [ ] byte ) { binary . Write ( buf , binary . LittleEndian , v ) } case reflect . String : binary . Write ( buf , binary . LittleEndian , int64 ( 6 ) ) binary . Write ( buf , binary . LittleEndian , int64 ( len ( o . uArg . ( string ) ) ) ) for _ , v := range [ ] byte ( o . uArg . ( string ) ) { binary . Write ( buf , binary . LittleEndian , v ) } default : panic ( "Unknown type " + tArg . String ( ) ) } } v := o . comment hasComment := v != "" if hasComment { binary . Write ( buf , binary . LittleEndian , int8 ( 1 ) ) binary . Write ( buf , binary . LittleEndian , v ) } else { binary . Write ( buf , binary . LittleEndian , int8 ( 0 ) ) } return buf . Bytes ( ) , nil }
7262	func ( o * op ) UnmarshalBinary ( data [ ] byte ) error { buf := bytes . NewReader ( data ) var t int64 if err := binary . Read ( buf , binary . LittleEndian , & t ) ; err != nil { return errors . Wrap ( err , "optype check failed during UnmarshalBinary" ) } o . OpType = OpType ( t ) o . OpHandler = optypeToHandler ( o . OpType ) var hasArg int8 if err := binary . Read ( buf , binary . LittleEndian , & hasArg ) ; err != nil { return errors . Wrap ( err , "hasArg check failed during UnmarshalBinary" ) } if hasArg == 1 { var tArg int64 if err := binary . Read ( buf , binary . LittleEndian , & tArg ) ; err != nil { return errors . Wrap ( err , "failed to read argument from buffer during UnmarshalBinary" ) } switch tArg { case 2 : var i int64 if err := binary . Read ( buf , binary . LittleEndian , & i ) ; err != nil { return errors . Wrap ( err , "failed to read integer argument during UnmarshalBinary" ) } o . uArg = i case 5 : var l int64 if err := binary . Read ( buf , binary . LittleEndian , & l ) ; err != nil { return errors . Wrap ( err , "failed to read length argument during UnmarshalBinary" ) } b := make ( [ ] byte , l ) for i := int64 ( 0 ) ; i < l ; i ++ { if err := binary . Read ( buf , binary . LittleEndian , & b [ i ] ) ; err != nil { return errors . Wrap ( err , "failed to read bytes from buffer during UnmarshalBinary" ) } } o . uArg = b default : panic ( fmt . Sprintf ( "Unknown tArg: %d" , tArg ) ) } } var hasComment int8 if err := binary . Read ( buf , binary . LittleEndian , & hasComment ) ; err != nil { return errors . Wrap ( err , "hasComment check failed during UnmarshalBinary" ) } if hasComment == 1 { if err := binary . Read ( buf , binary . LittleEndian , & o . comment ) ; err != nil { return errors . Wrap ( err , "failed to read comment bytes during UnmarshalBinary" ) } } return nil }
7263	func ( o op ) ArgInt ( ) int { v := interfaceToNumeric ( o . uArg ) return int ( v . Int ( ) ) }
7264	func ( o op ) ArgString ( ) string { if v , ok := o . uArg . ( string ) ; ok { return v } return interfaceToString ( o . uArg ) }
7265	func ( ctx * context ) AppendOp ( o vm . OpType , args ... interface { } ) vm . Op { return ctx . ByteCode . AppendOp ( o , args ... ) }
7266	func ( c * BasicCompiler ) Compile ( ast * parser . AST ) ( * vm . ByteCode , error ) { ctx := & context { ByteCode : vm . NewByteCode ( ) , } for _ , n := range ast . Root . Nodes { compile ( ctx , n ) } ctx . ByteCode . AppendOp ( vm . TXOPEnd ) opt := & NaiveOptimizer { } opt . Optimize ( ctx . ByteCode ) ctx . ByteCode . Name = ast . Name return ctx . ByteCode , nil }
7267	func NewV5 ( namespaceUUID * UUID , name [ ] byte ) * UUID { uuid := newByHash ( sha1 . New ( ) , namespaceUUID , name ) uuid [ 6 ] = ( uuid [ 6 ] & 0x0f ) | 0x50 return uuid }
7268	func ( list LexSymbolList ) Sort ( ) LexSymbolList { sorter := LexSymbolSorter { list : list , } sort . Sort ( sorter ) return sorter . list }
7269	func ( s LexSymbolSorter ) Less ( i , j int ) bool { return s . list [ i ] . Priority > s . list [ j ] . Priority }
7270	func ( s LexSymbolSorter ) Swap ( i , j int ) { s . list [ i ] , s . list [ j ] = s . list [ j ] , s . list [ i ] }
7271	func ( l * LexSymbolSet ) Copy ( ) * LexSymbolSet { c := NewLexSymbolSet ( ) for k , v := range l . Map { c . Map [ k ] = LexSymbol { v . Name , v . Type , v . Priority } } return c }
7272	func ( l * LexSymbolSet ) Set ( name string , typ lex . ItemType , prio ... float32 ) { var x float32 if len ( prio ) < 1 { x = 1.0 } else { x = prio [ 0 ] } l . Map [ name ] = LexSymbol { name , typ , x } l . SortedList = nil }
7273	func ( l * LexSymbolSet ) GetSortedList ( ) LexSymbolList { if l . SortedList != nil { return l . SortedList } num := len ( l . Map ) list := make ( LexSymbolList , num ) i := 0 for _ , v := range l . Map { list [ i ] = v i ++ } l . SortedList = list . Sort ( ) return l . SortedList }
7274	func ( s * Stack ) Top ( ) ( interface { } , error ) { if len ( * s ) == 0 { return nil , errors . New ( "nothing on stack" ) } return ( * s ) [ len ( * s ) - 1 ] , nil }
7275	func ( s * Stack ) Resize ( size int ) { newl := make ( [ ] interface { } , len ( * s ) , size ) copy ( newl , * s ) * s = newl }
7276	func ( s * Stack ) Extend ( extendBy int ) { s . Resize ( s . Size ( ) + extendBy ) }
7277	func ( s * Stack ) Grow ( min int ) { if min <= s . BufferSize ( ) { return } s . Resize ( calcNewSize ( min ) ) }
7278	func ( s * Stack ) Get ( i int ) ( interface { } , error ) { if i < 0 || i >= len ( * s ) { return nil , errors . New ( strconv . Itoa ( i ) + " is out of range" ) } return ( * s ) [ i ] , nil }
7279	func ( s * Stack ) Set ( i int , v interface { } ) error { if i < 0 { return errors . New ( "invalid index into stack" ) } if i >= s . BufferSize ( ) { s . Resize ( calcNewSize ( i ) ) } for len ( * s ) < i + 1 { * s = append ( * s , nil ) } ( * s ) [ i ] = v return nil }
7280	func ( s * Stack ) Push ( v interface { } ) { if len ( * s ) >= s . BufferSize ( ) { s . Resize ( calcNewSize ( cap ( * s ) ) ) } * s = append ( * s , v ) }
7281	func ( s * Stack ) Pop ( ) interface { } { l := len ( * s ) if l == 0 { return nil } v := ( * s ) [ l - 1 ] * s = ( * s ) [ : l - 1 ] return v }
7282	func ( s * Stack ) String ( ) string { buf := bytes . Buffer { } for k , v := range * s { fmt . Fprintf ( & buf , "%03d: %q\n" , \n , k ) } v }
7283	func GetHostIPs ( ) ( [ ] net . IP , error ) { ifaces , err := net . Interfaces ( ) if err != nil { return nil , err } var ips [ ] net . IP for _ , iface := range ifaces { if strings . HasPrefix ( iface . Name , "docker" ) { continue } addrs , err := iface . Addrs ( ) if err != nil { continue } for _ , addr := range addrs { if ipnet , ok := addr . ( * net . IPNet ) ; ok { ips = append ( ips , ipnet . IP ) } } } return ips , nil }
7284	func GetPrivateHostIPs ( ) ( [ ] net . IP , error ) { ips , err := GetHostIPs ( ) if err != nil { return nil , err } var privateIPs [ ] net . IP for _ , ip := range ips { if ip . IsLoopback ( ) || ip . To4 ( ) == nil || ! IsPrivate ( ip ) { continue } privateIPs = append ( privateIPs , ip ) } return privateIPs , nil }
7285	func IsPrivate ( ip net . IP ) bool { for _ , ipnet := range privateNets { if ipnet . Contains ( ip ) { return true } } return false }
7286	func Environ ( ) [ ] string { s := make ( [ ] string , 0 ) FlagSet . VisitAll ( func ( f * flag . Flag ) { if value , ok := getenv ( f . Name ) ; ok { s = append ( s , flagAsEnv ( f . Name ) + "=" + value ) } } ) return s }
7287	func getenv ( name string ) ( s string , ok bool ) { m := make ( map [ string ] bool ) for _ , keyVal := range os . Environ ( ) { split := strings . Split ( keyVal , "=" ) m [ split [ 0 ] ] = true } name = flagAsEnv ( name ) if _ , ok = m [ name ] ; ok { s = os . Getenv ( name ) } return }
7288	func flagAsEnv ( name string ) string { name = strings . ToUpper ( EnvPrefix + name ) name = strings . Replace ( name , "." , "_" , - 1 ) name = strings . Replace ( name , "-" , "_" , - 1 ) return name }
7289	func NewPolicy ( ) Policy { p := Policy { MinLength : 6 , MaxLength : 16 , MinLowers : 0 , MinUppers : 0 , MinDigits : 0 , MinSpclChars : 0 , LowerPool : "abcdefghijklmnopqrstuvwxyz" , UpperPool : "ABCDEFGHIJKLMNOPQRSTUVWXYZ" , DigitPool : "0123456789" , SpclCharPool : "!@#$%^&*()-_=+,.?/:;{}[]~" , } return p }
7290	func CreateRandom ( bs [ ] byte , length int ) [ ] byte { filled := make ( [ ] byte , length ) max := len ( bs ) for i := 0 ; i < length ; i ++ { Shuffle ( bs ) filled [ i ] = bs [ random ( 0 , max ) ] } return filled }
7291	func Shuffle ( bs [ ] byte ) { n := len ( bs ) for i := n - 1 ; i > 0 ; i -- { rand . Seed ( time . Now ( ) . UnixNano ( ) ) j := rand . Intn ( i + 1 ) bs [ i ] , bs [ j ] = bs [ j ] , bs [ i ] } }
7292	func Generate ( p Policy ) ( string , error ) { if p . MinLength < 0 || p . MaxLength < 0 || p . MinUppers < 0 || p . MinLowers < 0 || p . MinDigits < 0 || p . MinSpclChars < 0 { return "" , ErrNegativeLengthNotAllowed } collectiveMinLength := p . MinUppers + p . MinLowers + p . MinDigits + p . MinSpclChars if collectiveMinLength > p . MinLength { p . MinLength = collectiveMinLength } if p . MinLength > p . MaxLength { return "" , ErrMaxLengthExceeded } if p . MaxLength == 0 { return "" , nil } capsAlpha := [ ] byte ( p . UpperPool ) smallAlpha := [ ] byte ( p . LowerPool ) digits := [ ] byte ( p . DigitPool ) spclChars := [ ] byte ( p . SpclCharPool ) allChars := [ ] byte ( p . UpperPool + p . LowerPool + p . DigitPool + p . SpclCharPool ) passwd := CreateRandom ( capsAlpha , p . MinUppers ) passwd = append ( passwd , CreateRandom ( smallAlpha , p . MinLowers ) ... ) passwd = append ( passwd , CreateRandom ( digits , p . MinDigits ) ... ) passwd = append ( passwd , CreateRandom ( spclChars , p . MinSpclChars ) ... ) passLen := len ( passwd ) if passLen < p . MaxLength { randLength := random ( p . MinLength , p . MaxLength ) passwd = append ( passwd , CreateRandom ( allChars , randLength - passLen ) ... ) } Shuffle ( passwd ) return string ( passwd ) , nil }
7293	func ExecutableFolder ( ) ( string , error ) { p , err := Executable ( ) if err != nil { return "" , err } folder , _ := filepath . Split ( p ) return folder , nil }
7294	func Ignore ( ignore ... func ( error ) bool ) Option { return func ( s * Sentinel ) error { s . Lock ( ) defer s . Unlock ( ) if s . started { return ErrAlreadyStarted } s . ignoreErrors = append ( s . ignoreErrors , ignore ... ) return nil } }
7295	func Sigs ( sigs ... os . Signal ) Option { return func ( s * Sentinel ) error { s . Lock ( ) defer s . Unlock ( ) if s . started { return ErrAlreadyStarted } s . shutdownSigs = sigs return nil } }
7296	func Logf ( f func ( string , ... interface { } ) ) Option { return func ( s * Sentinel ) error { s . logf = f return nil } }
7297	func Errorf ( f func ( string , ... interface { } ) ) Option { return func ( s * Sentinel ) error { s . errf = f return nil } }
7298	func New ( opts ... Option ) ( * Sentinel , error ) { s := & Sentinel { shutdownDuration : DefaultShutdownDuration , logf : func ( string , ... interface { } ) { } , } var err error for _ , o := range opts { if err = o ( s ) ; err != nil { return nil , err } } if s . shutdownSigs == nil { s . shutdownSigs = [ ] os . Signal { os . Interrupt } } if s . errf == nil { s . errf = func ( str string , v ... interface { } ) { s . logf ( "ERROR: " + str , v ... ) } } return s , nil }
7299	func ( s * Sentinel ) Run ( ctxt context . Context ) error { s . Lock ( ) if s . started { defer s . Unlock ( ) return ErrAlreadyStarted } s . started = true s . Unlock ( ) eg , ctxt := errgroup . WithContext ( ctxt ) for _ , f := range s . serverFuncs { eg . Go ( func ( f func ( context . Context ) error ) func ( ) error { return func ( ) error { return f ( ctxt ) } } ( f ) ) } eg . Go ( func ( ) func ( ) error { s . sig = make ( chan os . Signal , 1 ) signal . Notify ( s . sig , s . shutdownSigs ... ) return func ( ) error { s . logf ( "received signal: %v" , <- s . sig ) return s . Shutdown ( ) } } ( ) ) if err := eg . Wait ( ) ; err != nil && ! s . ShutdownIgnore ( err ) { return err } return nil }
7300	func ( s * Sentinel ) Shutdown ( ) error { var firstErr error for i , f := range s . shutdownFuncs { ctxt , cancel := context . WithTimeout ( context . Background ( ) , s . shutdownDuration ) defer cancel ( ) if err := f ( ctxt ) ; err != nil { s . errf ( "could not shutdown %d: %v" , i , err ) if firstErr == nil { firstErr = err } } } return firstErr }
7301	func ( s * Sentinel ) ShutdownIgnore ( err error ) bool { if err == nil { return true } for _ , f := range s . ignoreErrors { if z := f ( err ) ; z { return true } } return false }
7302	func ( s * Sentinel ) Register ( server , shutdown interface { } , ignore ... func ( error ) bool ) error { var err error s . serverFuncs , err = convertAndAppendContextFuncs ( s . serverFuncs , server ) if err != nil { return err } s . shutdownFuncs , err = convertAndAppendContextFuncs ( s . shutdownFuncs , shutdown ) if err != nil { return err } s . ignoreErrors = append ( s . ignoreErrors , ignore ... ) return nil }
7303	func ( s * Sentinel ) Mux ( listener net . Listener , opts ... netmux . Option ) ( * netmux . Netmux , error ) { s . Lock ( ) defer s . Unlock ( ) if s . started { return nil , ErrAlreadyStarted } mux , err := netmux . New ( listener , opts ... ) if err != nil { return nil , err } if err = s . Register ( mux , mux , IgnoreListenerClosed , IgnoreNetOpError ) ; err != nil { return nil , err } return mux , nil }
7304	func ( s * Sentinel ) HTTP ( listener net . Listener , handler http . Handler , opts ... ServerOption ) error { s . Lock ( ) defer s . Unlock ( ) if s . started { return ErrAlreadyStarted } var err error server := & http . Server { Handler : handler , } for _ , o := range opts { if err = o ( server ) ; err != nil { return err } } return s . Register ( func ( ) error { return server . Serve ( listener ) } , server . Shutdown , IgnoreServerClosed , IgnoreNetOpError ) }
7305	func IgnoreError ( err error ) func ( error ) bool { return func ( e error ) bool { return err == e } }
7306	func IgnoreNetOpError ( err error ) bool { if opErr , ok := err . ( * net . OpError ) ; ok { return opErr . Err . Error ( ) == "use of closed network connection" } return false }
7307	func convertAndAppendContextFuncs ( o [ ] func ( context . Context ) error , v ... interface { } ) ( [ ] func ( context . Context ) error , error ) { for _ , z := range v { var t func ( context . Context ) error switch f := z . ( type ) { case func ( context . Context ) error : t = f case func ( ) : t = func ( context . Context ) error { f ( ) return nil } case func ( ) error : t = func ( context . Context ) error { return f ( ) } } if t == nil { return nil , ErrInvalidType } o = append ( o , t ) } return o , nil }
7308	func router ( apiData [ ] byte , services map [ string ] Service , healthHandler func ( http . ResponseWriter , * http . Request ) ) * mux . Router { m := mux . NewRouter ( ) gtgChecker := make ( [ ] gtg . StatusChecker , 0 ) for path , service := range services { handlers := httpHandlers { service } m . HandleFunc ( fmt . Sprintf ( "/%s/__count" , path ) , handlers . countHandler ) . Methods ( "GET" ) m . HandleFunc ( fmt . Sprintf ( "/%s/__ids" , path ) , handlers . idsHandler ) . Methods ( "GET" ) m . HandleFunc ( fmt . Sprintf ( "/%s/{uuid}" , path ) , handlers . getHandler ) . Methods ( "GET" ) m . HandleFunc ( fmt . Sprintf ( "/%s/{uuid}" , path ) , handlers . putHandler ) . Methods ( "PUT" ) m . HandleFunc ( fmt . Sprintf ( "/%s/{uuid}" , path ) , handlers . deleteHandler ) . Methods ( "DELETE" ) gtgChecker = append ( gtgChecker , func ( ) gtg . Status { if err := service . Check ( ) ; err != nil { return gtg . Status { GoodToGo : false , Message : err . Error ( ) } } return gtg . Status { GoodToGo : true } } ) } if apiData != nil && len ( apiData ) != 0 { endpoint , err := api . NewAPIEndpointForYAML ( apiData ) if err != nil { log . Warn ( "Failed to serve API endpoint, please check whether the OpenAPI file is valid" ) } else { m . HandleFunc ( api . DefaultPath , endpoint . ServeHTTP ) } } m . HandleFunc ( "/__health" , healthHandler ) m . HandleFunc ( status . PingPath , status . PingHandler ) m . HandleFunc ( status . PingPathDW , status . PingHandler ) m . HandleFunc ( status . BuildInfoPath , status . BuildInfoHandler ) m . HandleFunc ( status . BuildInfoPathDW , status . BuildInfoHandler ) m . HandleFunc ( status . GTGPath , status . NewGoodToGoHandler ( gtg . FailFastParallelCheck ( gtgChecker ) ) ) return m }
7309	func buildInfoHandler ( w http . ResponseWriter , req * http . Request ) { fmt . Fprintf ( w , "build-info" ) }
7310	func ( _ JsonEncoder ) Encode ( v ... interface { } ) ( [ ] byte , error ) { var data interface { } = v var result interface { } if v == nil { data = [ ] interface { } { } } else if len ( v ) == 1 { data = v [ 0 ] } t := reflect . TypeOf ( data ) if t . Kind ( ) == reflect . Ptr { t = t . Elem ( ) } if t . Kind ( ) == reflect . Struct { result = copyStruct ( reflect . ValueOf ( data ) , t ) . Interface ( ) } else { result = data } b , err := json . Marshal ( result ) return b , err }
7311	func Json ( jsonStruct interface { } , ifacePtr ... interface { } ) martini . Handler { return func ( context martini . Context , req * http . Request ) { ensureNotPointer ( jsonStruct ) jsonStruct := reflect . New ( reflect . TypeOf ( jsonStruct ) ) errors := newErrors ( ) if req . Body != nil { defer req . Body . Close ( ) } if err := json . NewDecoder ( req . Body ) . Decode ( jsonStruct . Interface ( ) ) ; err != nil { errors . Overall [ DeserializationError ] = err . Error ( ) } validateAndMap ( jsonStruct , context , errors , ifacePtr ... ) } }
7312	func validateAndMap ( obj reflect . Value , context martini . Context , errors * Errors , ifacePtr ... interface { } ) { context . Invoke ( Validate ( obj . Interface ( ) ) ) errors . combine ( getErrors ( context ) ) context . Map ( * errors ) context . Map ( obj . Elem ( ) . Interface ( ) ) if len ( ifacePtr ) > 0 { context . MapTo ( obj . Elem ( ) . Interface ( ) , ifacePtr [ 0 ] ) } }
7313	func ( self Errors ) Count ( ) int { return len ( self . Overall ) + len ( self . Fields ) }
7314	func ( o * Options ) Header ( origin string ) ( headers map [ string ] string ) { headers = make ( map [ string ] string ) if ! o . AllowAllOrigins && ! o . IsOriginAllowed ( origin ) { return } if o . AllowAllOrigins { headers [ headerAllowOrigin ] = "*" } else { headers [ headerAllowOrigin ] = origin } headers [ headerAllowCredentials ] = strconv . FormatBool ( o . AllowCredentials ) if len ( o . AllowMethods ) > 0 { headers [ headerAllowMethods ] = strings . Join ( o . AllowMethods , "," ) } if len ( o . AllowHeaders ) > 0 { headers [ headerAllowHeaders ] = strings . Join ( o . AllowHeaders , "," ) } if len ( o . ExposeHeaders ) > 0 { headers [ headerExposeHeaders ] = strings . Join ( o . ExposeHeaders , "," ) } if o . MaxAge > time . Duration ( 0 ) { headers [ headerMaxAge ] = strconv . FormatInt ( int64 ( o . MaxAge / time . Second ) , 10 ) } return }
7315	func ( o * Options ) PreflightHeader ( origin , rMethod , rHeaders string ) ( headers map [ string ] string ) { headers = make ( map [ string ] string ) if ! o . AllowAllOrigins && ! o . IsOriginAllowed ( origin ) { return } for _ , method := range o . AllowMethods { if method == rMethod { headers [ headerAllowMethods ] = strings . Join ( o . AllowMethods , "," ) break } } var allowed [ ] string for _ , rHeader := range strings . Split ( rHeaders , "," ) { lookupLoop : for _ , allowedHeader := range o . AllowHeaders { if rHeader == allowedHeader { allowed = append ( allowed , rHeader ) break lookupLoop } } } if len ( allowed ) > 0 { headers [ headerAllowHeaders ] = strings . Join ( allowed , "," ) } if len ( o . ExposeHeaders ) > 0 { headers [ headerExposeHeaders ] = strings . Join ( o . ExposeHeaders , "," ) } if o . MaxAge > time . Duration ( 0 ) { headers [ headerMaxAge ] = strconv . FormatInt ( int64 ( o . MaxAge / time . Second ) , 10 ) } return }
7316	func ( o * Options ) IsOriginAllowed ( origin string ) ( allowed bool ) { for _ , pattern := range o . AllowOrigins { allowed , _ = regexp . MatchString ( pattern , origin ) if allowed { return } } return }
7317	func Allow ( opts * Options ) http . HandlerFunc { return func ( res http . ResponseWriter , req * http . Request ) { var ( origin = req . Header . Get ( headerOrigin ) requestedMethod = req . Header . Get ( headerRequestMethod ) requestedHeaders = req . Header . Get ( headerRequestHeaders ) headers map [ string ] string ) if req . Method == "OPTIONS" && ( requestedMethod != "" || requestedHeaders != "" ) { headers = opts . PreflightHeader ( origin , requestedMethod , requestedHeaders ) } else { headers = opts . Header ( origin ) } for key , value := range headers { res . Header ( ) . Set ( key , value ) } } }
7318	func Renderer ( options ... Options ) martini . Handler { opt := prepareOptions ( options ) cs := prepareCharset ( opt . Charset ) t := compile ( opt ) return func ( res http . ResponseWriter , req * http . Request , c martini . Context ) { if martini . Env == martini . Dev { t = compile ( opt ) } tc , _ := t . Clone ( ) c . MapTo ( & renderer { res , req , tc , opt , cs } , ( * Render ) ( nil ) ) } }
7319	func ( al AcceptLanguages ) String ( ) string { output := bytes . NewBufferString ( "" ) for i , language := range al { output . WriteString ( fmt . Sprintf ( "%s (%1.1f)" , language . Language , language . Quality ) ) if i != len ( al ) - 1 { output . WriteString ( ", " ) } } if output . Len ( ) == 0 { output . WriteString ( "[]" ) } return output . String ( ) }
7320	func Languages ( ) martini . Handler { return func ( context martini . Context , request * http . Request ) { header := request . Header . Get ( acceptLanguageHeader ) if header != "" { acceptLanguageHeaderValues := strings . Split ( header , "," ) acceptLanguages := make ( AcceptLanguages , len ( acceptLanguageHeaderValues ) ) for i , languageRange := range acceptLanguageHeaderValues { if qualifiedRange := strings . Split ( languageRange , ";q=" ) ; len ( qualifiedRange ) == 2 { quality , error := strconv . ParseFloat ( qualifiedRange [ 1 ] , 32 ) if error != nil { acceptLanguages [ i ] = AcceptLanguage { trimLanguage ( qualifiedRange [ 0 ] ) , 1 } } else { acceptLanguages [ i ] = AcceptLanguage { trimLanguage ( qualifiedRange [ 0 ] ) , float32 ( quality ) } } } else { acceptLanguages [ i ] = AcceptLanguage { trimLanguage ( languageRange ) , 1 } } } sort . Sort ( acceptLanguages ) context . Map ( acceptLanguages ) } else { context . Map ( make ( AcceptLanguages , 0 ) ) } } }
7321	func Prefix ( prefix string ) martini . Handler { return func ( w http . ResponseWriter , r * http . Request ) { if prefix == "" { return } if p := strings . TrimPrefix ( r . URL . Path , prefix ) ; len ( p ) < len ( r . URL . Path ) { r . URL . Path = p } else { http . NotFound ( w , r ) } } }
7322	func Basic ( username string , password string ) http . HandlerFunc { var siteAuth = base64 . StdEncoding . EncodeToString ( [ ] byte ( username + ":" + password ) ) return func ( res http . ResponseWriter , req * http . Request ) { auth := req . Header . Get ( "Authorization" ) if ! SecureCompare ( auth , "Basic " + siteAuth ) { res . Header ( ) . Set ( "WWW-Authenticate" , "Basic realm=\"Authorization Required\"" ) \" } } }
7323	func UpdateUser ( s sessions . Session , user User ) error { s . Set ( SessionKey , user . UniqueId ( ) ) return nil }
7324	func ( u * MyUserModel ) GetById ( id interface { } ) error { err := dbmap . SelectOne ( u , "SELECT * FROM users WHERE id = $1" , id ) if err != nil { return err } return nil }
7325	func AddressToAccountId ( address string ) ( result xdr . AccountId , err error ) { bytes , err := strkey . Decode ( strkey . VersionByteAccountID , address ) if err != nil { return } var raw xdr . Uint256 copy ( raw [ : ] , bytes ) pk , err := xdr . NewPublicKey ( xdr . CryptoKeyTypeKeyTypeEd25519 , raw ) if err != nil { return } result = xdr . AccountId ( pk ) return }
7326	func ( m Asset ) MutateChangeTrust ( o * xdr . ChangeTrustOp ) ( err error ) { if m . Native { return errors . New ( "Native asset not allowed" ) } o . Line , err = m . ToXdrObject ( ) return }
7327	func ( m Limit ) MutateChangeTrust ( o * xdr . ChangeTrustOp ) ( err error ) { o . Limit , err = amount . Parse ( string ( m ) ) return }
7328	func Trust ( code , issuer string , args ... interface { } ) ( result ChangeTrustBuilder ) { mutators := [ ] interface { } { CreditAsset ( code , issuer ) , } limitSet := false for _ , mut := range args { mutators = append ( mutators , mut ) _ , isLimit := mut . ( Limit ) if isLimit { limitSet = true } } if ! limitSet { mutators = append ( mutators , MaxLimit ) } return ChangeTrust ( mutators ... ) }
7329	func RemoveTrust ( code , issuer string , args ... interface { } ) ( result ChangeTrustBuilder ) { mutators := [ ] interface { } { CreditAsset ( code , issuer ) , Limit ( "0" ) , } for _ , mut := range args { mutators = append ( mutators , mut ) } return ChangeTrust ( mutators ... ) }
7330	func ( m CreditAmount ) MutatePayment ( o interface { } ) ( err error ) { switch o := o . ( type ) { default : err = errors . New ( "Unexpected operation type" ) case * xdr . PaymentOp : o . Amount , err = amount . Parse ( m . Amount ) if err != nil { return } o . Asset , err = createAlphaNumAsset ( m . Code , m . Issuer ) case * xdr . PathPaymentOp : o . DestAmount , err = amount . Parse ( m . Amount ) if err != nil { return } o . DestAsset , err = createAlphaNumAsset ( m . Code , m . Issuer ) } return }
7331	func ( m Destination ) MutatePayment ( o interface { } ) error { switch o := o . ( type ) { default : return errors . New ( "Unexpected operation type" ) case * xdr . PaymentOp : return setAccountId ( m . AddressOrSeed , & o . Destination ) case * xdr . PathPaymentOp : return setAccountId ( m . AddressOrSeed , & o . Destination ) } return nil }
7332	func ( m NativeAmount ) MutatePayment ( o interface { } ) ( err error ) { switch o := o . ( type ) { default : err = errors . New ( "Unexpected operation type" ) case * xdr . PaymentOp : o . Amount , err = amount . Parse ( m . Amount ) if err != nil { return } o . Asset , err = xdr . NewAsset ( xdr . AssetTypeAssetTypeNative , nil ) case * xdr . PathPaymentOp : o . DestAmount , err = amount . Parse ( m . Amount ) if err != nil { return } o . DestAsset , err = xdr . NewAsset ( xdr . AssetTypeAssetTypeNative , nil ) } return }
7333	func ( m PayWithPath ) MutatePayment ( o interface { } ) ( err error ) { var pathPaymentOp * xdr . PathPaymentOp var ok bool if pathPaymentOp , ok = o . ( * xdr . PathPaymentOp ) ; ! ok { return errors . New ( "Unexpected operation type" ) } pathPaymentOp . SendMax , err = amount . Parse ( m . MaxAmount ) if err != nil { return } var path [ ] xdr . Asset var xdrAsset xdr . Asset for _ , asset := range m . Path { xdrAsset , err = asset . ToXdrObject ( ) if err != nil { return err } path = append ( path , xdrAsset ) } pathPaymentOp . Path = path pathPaymentOp . SendAsset , err = m . Asset . ToXdrObject ( ) return }
7334	func ( m Destination ) MutateAccountMerge ( o * AccountMergeBuilder ) error { return setAccountId ( m . AddressOrSeed , & o . Destination ) }
7335	func MustParse ( v string ) xdr . Int64 { ret , err := Parse ( v ) if err != nil { panic ( err ) } return ret }
7336	func Parse ( v string ) ( xdr . Int64 , error ) { var f , o , r big . Rat _ , ok := f . SetString ( v ) if ! ok { return xdr . Int64 ( 0 ) , fmt . Errorf ( "cannot parse amount: %s" , v ) } o . SetInt64 ( One ) r . Mul ( & f , & o ) is := r . FloatString ( 0 ) i , err := strconv . ParseInt ( is , 10 , 64 ) if err != nil { return xdr . Int64 ( 0 ) , err } return xdr . Int64 ( i ) , nil }
7337	func String ( v xdr . Int64 ) string { var f , o , r big . Rat f . SetInt64 ( int64 ( v ) ) o . SetInt64 ( One ) r . Quo ( & f , & o ) return r . FloatString ( 7 ) }
7338	func CreateOffer ( rate Rate , amount Amount ) ( result ManageOfferBuilder ) { return ManageOffer ( false , rate , amount ) }
7339	func CreatePassiveOffer ( rate Rate , amount Amount ) ( result ManageOfferBuilder ) { return ManageOffer ( true , rate , amount ) }
7340	func UpdateOffer ( rate Rate , amount Amount , offerID OfferID ) ( result ManageOfferBuilder ) { return ManageOffer ( false , rate , amount , offerID ) }
7341	func DeleteOffer ( rate Rate , offerID OfferID ) ( result ManageOfferBuilder ) { return ManageOffer ( false , rate , Amount ( "0" ) , offerID ) }
7342	func ManageOffer ( passiveOffer bool , muts ... interface { } ) ( result ManageOfferBuilder ) { result . PassiveOffer = passiveOffer result . Mutate ( muts ... ) return }
7343	func ( b * ManageOfferBuilder ) Mutate ( muts ... interface { } ) { for _ , m := range muts { var err error switch mut := m . ( type ) { case ManageOfferMutator : if b . PassiveOffer { err = mut . MutateManageOffer ( & b . PO ) } else { err = mut . MutateManageOffer ( & b . MO ) } case OperationMutator : err = mut . MutateOperation ( & b . O ) default : err = errors . New ( "Mutator type not allowed" ) } if err != nil { b . Err = err return } } }
7344	func ( m Amount ) MutateManageOffer ( o interface { } ) ( err error ) { switch o := o . ( type ) { default : err = errors . New ( "Unexpected operation type" ) case * xdr . ManageOfferOp : o . Amount , err = amount . Parse ( string ( m ) ) case * xdr . CreatePassiveOfferOp : o . Amount , err = amount . Parse ( string ( m ) ) } return }
7345	func ( m OfferID ) MutateManageOffer ( o interface { } ) ( err error ) { switch o := o . ( type ) { default : err = errors . New ( "Unexpected operation type" ) case * xdr . ManageOfferOp : o . OfferId = xdr . Uint64 ( m ) } return }
7346	func ( m Rate ) MutateManageOffer ( o interface { } ) ( err error ) { switch o := o . ( type ) { default : err = errors . New ( "Unexpected operation type" ) case * xdr . ManageOfferOp : o . Selling , err = m . Selling . ToXdrObject ( ) if err != nil { return } o . Buying , err = m . Buying . ToXdrObject ( ) if err != nil { return } o . Price , err = price . Parse ( string ( m . Price ) ) case * xdr . CreatePassiveOfferOp : o . Selling , err = m . Selling . ToXdrObject ( ) if err != nil { return } o . Buying , err = m . Buying . ToXdrObject ( ) if err != nil { return } o . Price , err = price . Parse ( string ( m . Price ) ) } return }
7347	func ( m SourceAccount ) MutateOperation ( o * xdr . Operation ) error { o . SourceAccount = & xdr . AccountId { } return setAccountId ( m . AddressOrSeed , o . SourceAccount ) }
7348	func ( p * Price ) String ( ) string { return big . NewRat ( int64 ( p . N ) , int64 ( p . D ) ) . FloatString ( 7 ) }
7349	func Transaction ( muts ... TransactionMutator ) ( result * TransactionBuilder ) { result = & TransactionBuilder { } result . Mutate ( muts ... ) result . Mutate ( Defaults { } ) return }
7350	func ( b * TransactionBuilder ) Mutate ( muts ... TransactionMutator ) { if b . TX == nil { b . TX = & xdr . Transaction { } } for _ , m := range muts { err := m . MutateTransaction ( b ) if err != nil { b . Err = err return } } }
7351	func ( b * TransactionBuilder ) Hash ( ) ( [ 32 ] byte , error ) { var txBytes bytes . Buffer _ , err := fmt . Fprintf ( & txBytes , "%s" , b . NetworkID ) if err != nil { return [ 32 ] byte { } , err } _ , err = xdr . Marshal ( & txBytes , xdr . EnvelopeTypeEnvelopeTypeTx ) if err != nil { return [ 32 ] byte { } , err } _ , err = xdr . Marshal ( & txBytes , b . TX ) if err != nil { return [ 32 ] byte { } , err } return hash . Hash ( txBytes . Bytes ( ) ) , nil }
7352	func ( b * TransactionBuilder ) HashHex ( ) ( string , error ) { hash , err := b . Hash ( ) if err != nil { return "" , err } return hex . EncodeToString ( hash [ : ] ) , nil }
7353	func ( b * TransactionBuilder ) Sign ( signers ... string ) ( result TransactionEnvelopeBuilder ) { result . Mutate ( b ) for _ , s := range signers { result . Mutate ( Sign { s } ) } return }
7354	func ( m AllowTrustBuilder ) MutateTransaction ( o * TransactionBuilder ) error { if m . Err != nil { return m . Err } m . O . Body , m . Err = xdr . NewOperationBody ( xdr . OperationTypeAllowTrust , m . AT ) o . TX . Operations = append ( o . TX . Operations , m . O ) return m . Err }
7355	func ( m ChangeTrustBuilder ) MutateTransaction ( o * TransactionBuilder ) error { if m . Err != nil { return m . Err } m . O . Body , m . Err = xdr . NewOperationBody ( xdr . OperationTypeChangeTrust , m . CT ) o . TX . Operations = append ( o . TX . Operations , m . O ) return m . Err }
7356	func ( m CreateAccountBuilder ) MutateTransaction ( o * TransactionBuilder ) error { if m . Err != nil { return m . Err } m . O . Body , m . Err = xdr . NewOperationBody ( xdr . OperationTypeCreateAccount , m . CA ) o . TX . Operations = append ( o . TX . Operations , m . O ) return m . Err }
7357	func ( m Defaults ) MutateTransaction ( o * TransactionBuilder ) error { if o . TX . Fee == 0 { o . TX . Fee = xdr . Uint32 ( 100 * len ( o . TX . Operations ) ) } if o . NetworkID == [ 32 ] byte { } { o . NetworkID = DefaultNetwork . ID ( ) } return nil }
7358	func ( m InflationBuilder ) MutateTransaction ( o * TransactionBuilder ) error { if m . Err != nil { return m . Err } m . O . Body , m . Err = xdr . NewOperationBody ( xdr . OperationTypeInflation , nil ) o . TX . Operations = append ( o . TX . Operations , m . O ) return m . Err }
7359	func ( m ManageDataBuilder ) MutateTransaction ( o * TransactionBuilder ) error { if m . Err != nil { return m . Err } m . O . Body , m . Err = xdr . NewOperationBody ( xdr . OperationTypeManageData , m . MD ) o . TX . Operations = append ( o . TX . Operations , m . O ) return m . Err }
7360	func ( m ManageOfferBuilder ) MutateTransaction ( o * TransactionBuilder ) error { if m . Err != nil { return m . Err } if m . PassiveOffer { m . O . Body , m . Err = xdr . NewOperationBody ( xdr . OperationTypeCreatePassiveOffer , m . PO ) o . TX . Operations = append ( o . TX . Operations , m . O ) } else { m . O . Body , m . Err = xdr . NewOperationBody ( xdr . OperationTypeManageOffer , m . MO ) o . TX . Operations = append ( o . TX . Operations , m . O ) } return m . Err }
7361	func ( m MemoHash ) MutateTransaction ( o * TransactionBuilder ) ( err error ) { o . TX . Memo , err = xdr . NewMemo ( xdr . MemoTypeMemoHash , m . Value ) return }
7362	func ( m MemoID ) MutateTransaction ( o * TransactionBuilder ) ( err error ) { o . TX . Memo , err = xdr . NewMemo ( xdr . MemoTypeMemoId , xdr . Uint64 ( m . Value ) ) return }
7363	func ( m MemoReturn ) MutateTransaction ( o * TransactionBuilder ) ( err error ) { o . TX . Memo , err = xdr . NewMemo ( xdr . MemoTypeMemoReturn , m . Value ) return }
7364	func ( m MemoText ) MutateTransaction ( o * TransactionBuilder ) ( err error ) { if len ( [ ] byte ( m . Value ) ) > MemoTextMaxLength { err = errors . New ( "Memo too long; over 28 bytes" ) return } o . TX . Memo , err = xdr . NewMemo ( xdr . MemoTypeMemoText , m . Value ) return }
7365	func ( m Network ) MutateTransaction ( o * TransactionBuilder ) error { o . NetworkID = m . ID ( ) return nil }
7366	func ( m PaymentBuilder ) MutateTransaction ( o * TransactionBuilder ) error { if m . Err != nil { return m . Err } if m . PathPayment { m . O . Body , m . Err = xdr . NewOperationBody ( xdr . OperationTypePathPayment , m . PP ) o . TX . Operations = append ( o . TX . Operations , m . O ) return m . Err } m . O . Body , m . Err = xdr . NewOperationBody ( xdr . OperationTypePayment , m . P ) o . TX . Operations = append ( o . TX . Operations , m . O ) return m . Err }
7367	func ( m SetOptionsBuilder ) MutateTransaction ( o * TransactionBuilder ) error { if m . Err != nil { return m . Err } m . O . Body , m . Err = xdr . NewOperationBody ( xdr . OperationTypeSetOptions , m . SO ) o . TX . Operations = append ( o . TX . Operations , m . O ) return m . Err }
7368	func ( m Sequence ) MutateTransaction ( o * TransactionBuilder ) error { o . TX . SeqNum = xdr . SequenceNumber ( m . Sequence ) return nil }
7369	func ( m SourceAccount ) MutateTransaction ( o * TransactionBuilder ) error { return setAccountId ( m . AddressOrSeed , & o . TX . SourceAccount ) }
7370	func ( t * Int64 ) Scan ( src interface { } ) error { val , ok := src . ( int64 ) if ! ok { return errors . New ( "Invalid value for xdr.Int64" ) } * t = Int64 ( val ) return nil }
7371	func ( b * Bundle ) InitialState ( key xdr . LedgerKey ) ( * xdr . LedgerEntry , error ) { all := b . Changes ( key ) if len ( all ) == 0 { return nil , ErrMetaNotFound } first := all [ 0 ] if first . Type != xdr . LedgerEntryChangeTypeLedgerEntryState { return nil , nil } result := first . MustState ( ) return & result , nil }
7372	func ( b * Bundle ) Changes ( target xdr . LedgerKey ) ( ret [ ] xdr . LedgerEntryChange ) { return b . changes ( target , math . MaxInt32 ) }
7373	func ( b * Bundle ) StateAfter ( key xdr . LedgerKey , opidx int ) ( * xdr . LedgerEntry , error ) { all := b . changes ( key , opidx ) if len ( all ) == 0 { return nil , ErrMetaNotFound } change := all [ len ( all ) - 1 ] switch change . Type { case xdr . LedgerEntryChangeTypeLedgerEntryCreated : entry := change . MustCreated ( ) return & entry , nil case xdr . LedgerEntryChangeTypeLedgerEntryRemoved : return nil , nil case xdr . LedgerEntryChangeTypeLedgerEntryUpdated : entry := change . MustUpdated ( ) return & entry , nil case xdr . LedgerEntryChangeTypeLedgerEntryState : panic ( fmt . Errorf ( "Unexpected 'state' entry" ) ) default : panic ( fmt . Errorf ( "Unknown change type: %v" , change . Type ) ) } }
7374	func ( b * Bundle ) changes ( target xdr . LedgerKey , maxOp int ) ( ret [ ] xdr . LedgerEntryChange ) { for _ , change := range b . FeeMeta { key := change . LedgerKey ( ) if ! key . Equals ( target ) { continue } ret = append ( ret , change ) } for i , op := range b . TransactionMeta . MustOperations ( ) { if i > maxOp { break } for _ , change := range op . Changes { key := change . LedgerKey ( ) if ! key . Equals ( target ) { continue } ret = append ( ret , change ) } } return }
7375	func MustDecode ( expected VersionByte , src string ) [ ] byte { d , err := Decode ( expected , src ) if err != nil { panic ( err ) } return d }
7376	func Encode ( version VersionByte , src [ ] byte ) ( string , error ) { if err := checkValidVersionByte ( version ) ; err != nil { return "" , err } var raw bytes . Buffer if err := binary . Write ( & raw , binary . LittleEndian , version ) ; err != nil { return "" , err } if _ , err := raw . Write ( src ) ; err != nil { return "" , err } checksum := crc16 . Checksum ( raw . Bytes ( ) ) if _ , err := raw . Write ( checksum ) ; err != nil { return "" , err } result := base32 . StdEncoding . EncodeToString ( raw . Bytes ( ) ) return result , nil }
7377	func MustEncode ( version VersionByte , src [ ] byte ) string { e , err := Encode ( version , src ) if err != nil { panic ( err ) } return e }
7378	func checkValidVersionByte ( version VersionByte ) error { if version == VersionByteAccountID { return nil } if version == VersionByteSeed { return nil } return ErrInvalidVersionByte }
7379	func Checksum ( data [ ] byte ) [ ] byte { var crc uint16 var out bytes . Buffer for _ , b := range data { crc = ( ( crc << 8 ) & 0xffff ) ^ crc16tab [ ( ( crc >> 8 ) ^ uint16 ( b ) ) & 0x00FF ] } err := binary . Write ( & out , binary . LittleEndian , crc ) if err != nil { panic ( err ) } return out . Bytes ( ) }
7380	func Validate ( data [ ] byte , expected [ ] byte ) error { actual := Checksum ( data ) if ! bytes . Equal ( actual , expected ) { return ErrInvalidChecksum } return nil }
7381	func ( change * LedgerEntryChange ) LedgerKey ( ) LedgerKey { switch change . Type { case LedgerEntryChangeTypeLedgerEntryCreated : change := change . MustCreated ( ) return change . LedgerKey ( ) case LedgerEntryChangeTypeLedgerEntryRemoved : return change . MustRemoved ( ) case LedgerEntryChangeTypeLedgerEntryUpdated : change := change . MustUpdated ( ) return change . LedgerKey ( ) case LedgerEntryChangeTypeLedgerEntryState : change := change . MustState ( ) return change . LedgerKey ( ) default : panic ( fmt . Errorf ( "Unknown change type: %v" , change . Type ) ) } }
7382	func checkPlausible ( ) { for _ , r := range prefix { if ! strings . ContainsRune ( alphabet , r ) { fmt . Printf ( "Invalid prefix: %s is not in the base32 alphabet\n" , \n ) strconv . QuoteRune ( r ) } } }
7383	func ( aid * AccountId ) Address ( ) string { if aid == nil { return "" } switch aid . Type { case CryptoKeyTypeKeyTypeEd25519 : ed := aid . MustEd25519 ( ) raw := make ( [ ] byte , 32 ) copy ( raw , ed [ : ] ) return strkey . MustEncode ( strkey . VersionByteAccountID , raw ) default : panic ( fmt . Errorf ( "Unknown account id type: %v" , aid . Type ) ) } }
7384	func ( aid * AccountId ) Equals ( other AccountId ) bool { if aid . Type != other . Type { return false } switch aid . Type { case CryptoKeyTypeKeyTypeEd25519 : l := aid . MustEd25519 ( ) r := other . MustEd25519 ( ) return l == r default : panic ( fmt . Errorf ( "Unknown account id type: %v" , aid . Type ) ) } }
7385	func ( aid * AccountId ) SetAddress ( address string ) error { if aid == nil { return nil } raw , err := strkey . Decode ( strkey . VersionByteAccountID , address ) if err != nil { return err } if len ( raw ) != 32 { return errors . New ( "invalid address" ) } var ui Uint256 copy ( ui [ : ] , raw ) * aid , err = NewAccountId ( CryptoKeyTypeKeyTypeEd25519 , ui ) return err }
7386	func ( a Asset ) ToXdrObject ( ) ( xdr . Asset , error ) { if a . Native { return xdr . NewAsset ( xdr . AssetTypeAssetTypeNative , nil ) } var issuer xdr . AccountId err := setAccountId ( a . Issuer , & issuer ) if err != nil { return xdr . Asset { } , err } length := len ( a . Code ) switch { case length >= 1 && length <= 4 : var codeArray [ 4 ] byte byteArray := [ ] byte ( a . Code ) copy ( codeArray [ : ] , byteArray [ 0 : length ] ) asset := xdr . AssetAlphaNum4 { codeArray , issuer } return xdr . NewAsset ( xdr . AssetTypeAssetTypeCreditAlphanum4 , asset ) case length >= 5 && length <= 12 : var codeArray [ 12 ] byte byteArray := [ ] byte ( a . Code ) copy ( codeArray [ : ] , byteArray [ 0 : length ] ) asset := xdr . AssetAlphaNum12 { codeArray , issuer } return xdr . NewAsset ( xdr . AssetTypeAssetTypeCreditAlphanum12 , asset ) default : return xdr . Asset { } , errors . New ( "Asset code length is invalid" ) } }
7387	func ( pathSend PayWithPath ) Through ( asset Asset ) PayWithPath { pathSend . Path = append ( pathSend . Path , asset ) return pathSend }
7388	func PayWith ( sendAsset Asset , maxAmount string ) PayWithPath { return PayWithPath { Asset : sendAsset , MaxAmount : maxAmount , } }
7389	func continuedFraction ( price string ) ( xdrPrice xdr . Price , err error ) { number := & big . Rat { } maxInt32 := & big . Rat { } zero := & big . Rat { } one := & big . Rat { } _ , ok := number . SetString ( price ) if ! ok { return xdrPrice , fmt . Errorf ( "cannot parse price: %s" , price ) } maxInt32 . SetInt64 ( int64 ( math . MaxInt32 ) ) zero . SetInt64 ( int64 ( 0 ) ) one . SetInt64 ( int64 ( 1 ) ) fractions := [ ] [ 2 ] * big . Rat { { zero , one } , { one , zero } , } i := 2 for { if number . Cmp ( maxInt32 ) == 1 { break } f := & big . Rat { } h := & big . Rat { } k := & big . Rat { } a := floor ( number ) f . Sub ( number , a ) h . Mul ( a , fractions [ i - 1 ] [ 0 ] ) h . Add ( h , fractions [ i - 2 ] [ 0 ] ) k . Mul ( a , fractions [ i - 1 ] [ 1 ] ) k . Add ( k , fractions [ i - 2 ] [ 1 ] ) if h . Cmp ( maxInt32 ) == 1 || k . Cmp ( maxInt32 ) == 1 { break } fractions = append ( fractions , [ 2 ] * big . Rat { h , k } ) if f . Cmp ( zero ) == 0 { break } number . Quo ( one , f ) i ++ } n , d := fractions [ len ( fractions ) - 1 ] [ 0 ] , fractions [ len ( fractions ) - 1 ] [ 1 ] if n . Cmp ( zero ) == 0 || d . Cmp ( zero ) == 0 { return xdrPrice , errors . New ( "Couldn't find approximation" ) } return xdr . Price { N : xdr . Int32 ( n . Num ( ) . Int64 ( ) ) , D : xdr . Int32 ( d . Num ( ) . Int64 ( ) ) , } , nil }
7390	func ( b * TransactionEnvelopeBuilder ) Mutate ( muts ... TransactionEnvelopeMutator ) { b . Init ( ) for _ , m := range muts { err := m . MutateTransactionEnvelope ( b ) if err != nil { b . Err = err return } } }
7391	func ( b * TransactionEnvelopeBuilder ) MutateTX ( muts ... TransactionMutator ) { b . Init ( ) if b . Err != nil { return } b . child . Mutate ( muts ... ) b . Err = b . child . Err }
7392	func ( b * TransactionEnvelopeBuilder ) Bytes ( ) ( [ ] byte , error ) { if b . Err != nil { return nil , b . Err } var txBytes bytes . Buffer _ , err := xdr . Marshal ( & txBytes , b . E ) if err != nil { return nil , err } return txBytes . Bytes ( ) , nil }
7393	func ( b * TransactionEnvelopeBuilder ) Base64 ( ) ( string , error ) { bs , err := b . Bytes ( ) return base64 . StdEncoding . EncodeToString ( bs ) , err }
7394	func ( m * TransactionBuilder ) MutateTransactionEnvelope ( txe * TransactionEnvelopeBuilder ) error { if m . Err != nil { return m . Err } txe . E . Tx = * m . TX newChild := * m txe . child = & newChild m . TX = & txe . E . Tx return nil }
7395	func ( m HomeDomain ) MutateSetOptions ( o * xdr . SetOptionsOp ) ( err error ) { if len ( m ) > 32 { return errors . New ( "HomeDomain is too long" ) } value := xdr . String32 ( m ) o . HomeDomain = & value return }
7396	func ( m InflationDest ) MutateSetOptions ( o * xdr . SetOptionsOp ) ( err error ) { o . InflationDest = & xdr . AccountId { } err = setAccountId ( string ( m ) , o . InflationDest ) return }
7397	func ( m MasterWeight ) MutateSetOptions ( o * xdr . SetOptionsOp ) ( err error ) { val := xdr . Uint32 ( m ) o . MasterWeight = & val return }
7398	func ( m Signer ) MutateSetOptions ( o * xdr . SetOptionsOp ) ( err error ) { var signer xdr . Signer signer . Weight = xdr . Uint32 ( m . Weight ) err = setAccountId ( m . PublicKey , & signer . PubKey ) o . Signer = & signer return }
7399	func SetThresholds ( low , medium , high uint32 ) Thresholds { return Thresholds { Low : & low , Medium : & medium , High : & high , } }
7400	func ( m Thresholds ) MutateSetOptions ( o * xdr . SetOptionsOp ) ( err error ) { if m . Low != nil { val := xdr . Uint32 ( * m . Low ) o . LowThreshold = & val } if m . Medium != nil { val := xdr . Uint32 ( * m . Medium ) o . MedThreshold = & val } if m . High != nil { val := xdr . Uint32 ( * m . High ) o . HighThreshold = & val } return }
7401	func ( m SetFlag ) MutateSetOptions ( o * xdr . SetOptionsOp ) ( err error ) { if ! isFlagValid ( xdr . AccountFlags ( m ) ) { return errors . New ( "Unknown flag in SetFlag mutator" ) } var val xdr . Uint32 if o . SetFlags == nil { val = xdr . Uint32 ( m ) } else { val = xdr . Uint32 ( m ) | * o . SetFlags } o . SetFlags = & val return }
7402	func ( m ClearFlag ) MutateSetOptions ( o * xdr . SetOptionsOp ) ( err error ) { if ! isFlagValid ( xdr . AccountFlags ( m ) ) { return errors . New ( "Unknown flag in SetFlag mutator" ) } var val xdr . Uint32 if o . ClearFlags == nil { val = xdr . Uint32 ( m ) } else { val = xdr . Uint32 ( m ) | * o . ClearFlags } o . ClearFlags = & val return }
7403	func ( m Destination ) MutateCreateAccount ( o * xdr . CreateAccountOp ) error { return setAccountId ( m . AddressOrSeed , & o . Destination ) }
7404	func ( m NativeAmount ) MutateCreateAccount ( o * xdr . CreateAccountOp ) ( err error ) { o . StartingBalance , err = amount . Parse ( m . Amount ) return }
7405	func Random ( ) ( * Full , error ) { var rawSeed [ 32 ] byte _ , err := io . ReadFull ( rand . Reader , rawSeed [ : ] ) if err != nil { return nil , err } kp , err := FromRawSeed ( rawSeed ) if err != nil { return nil , err } return kp , nil }
7406	func Master ( networkPassphrase string ) KP { kp , err := FromRawSeed ( network . ID ( networkPassphrase ) ) if err != nil { panic ( err ) } return kp }
7407	func Parse ( addressOrSeed string ) ( KP , error ) { _ , err := strkey . Decode ( strkey . VersionByteAccountID , addressOrSeed ) if err == nil { return & FromAddress { addressOrSeed } , nil } if err != strkey . ErrInvalidVersionByte { return nil , err } _ , err = strkey . Decode ( strkey . VersionByteSeed , addressOrSeed ) if err == nil { return & Full { addressOrSeed } , nil } return nil , err }
7408	func MustParse ( addressOrSeed string ) KP { kp , err := Parse ( addressOrSeed ) if err != nil { panic ( err ) } return kp }
7409	func ( m Authorize ) MutateAllowTrust ( o * xdr . AllowTrustOp ) error { o . Authorize = m . Value return nil }
7410	func ( m AllowTrustAsset ) MutateAllowTrust ( o * xdr . AllowTrustOp ) ( err error ) { length := len ( m . Code ) switch { case length >= 1 && length <= 4 : var code [ 4 ] byte byteArray := [ ] byte ( m . Code ) copy ( code [ : ] , byteArray [ 0 : length ] ) o . Asset , err = xdr . NewAllowTrustOpAsset ( xdr . AssetTypeAssetTypeCreditAlphanum4 , code ) case length >= 5 && length <= 12 : var code [ 12 ] byte byteArray := [ ] byte ( m . Code ) copy ( code [ : ] , byteArray [ 0 : length ] ) o . Asset , err = xdr . NewAllowTrustOpAsset ( xdr . AssetTypeAssetTypeCreditAlphanum12 , code ) default : err = errors . New ( "Asset code length is invalid" ) } return }
7411	func ( m Trustor ) MutateAllowTrust ( o * xdr . AllowTrustOp ) error { return setAccountId ( m . Address , & o . Trustor ) }
7412	func ( a AllowTrustOpAsset ) ToAsset ( issuer AccountId ) ( ret Asset ) { var err error switch a . Type { case AssetTypeAssetTypeCreditAlphanum4 : ret , err = NewAsset ( AssetTypeAssetTypeCreditAlphanum4 , AssetAlphaNum4 { AssetCode : a . MustAssetCode4 ( ) , Issuer : issuer , } ) case AssetTypeAssetTypeCreditAlphanum12 : ret , err = NewAsset ( AssetTypeAssetTypeCreditAlphanum12 , AssetAlphaNum12 { AssetCode : a . MustAssetCode12 ( ) , Issuer : issuer , } ) default : err = fmt . Errorf ( "Unexpected type for AllowTrustOpAsset: %d" , a . Type ) } if err != nil { panic ( err ) } return }
7413	func ( a * Asset ) SetNative ( ) error { newa , err := NewAsset ( AssetTypeAssetTypeNative , nil ) if err != nil { return err } * a = newa return nil }
7414	func ( a Asset ) String ( ) string { var t , c , i string a . MustExtract ( & t , & c , & i ) if a . Type == AssetTypeAssetTypeNative { return t } return fmt . Sprintf ( "%s/%s/%s" , t , c , i ) }
7415	func ( a Asset ) Equals ( other Asset ) bool { if a . Type != other . Type { return false } switch a . Type { case AssetTypeAssetTypeNative : return true case AssetTypeAssetTypeCreditAlphanum4 : l := a . MustAlphaNum4 ( ) r := other . MustAlphaNum4 ( ) return l . AssetCode == r . AssetCode && l . Issuer . Equals ( r . Issuer ) case AssetTypeAssetTypeCreditAlphanum12 : l := a . MustAlphaNum12 ( ) r := other . MustAlphaNum12 ( ) return l . AssetCode == r . AssetCode && l . Issuer . Equals ( r . Issuer ) default : panic ( fmt . Errorf ( "Unknown asset type: %v" , a . Type ) ) } }
7416	func ( a Asset ) MustExtract ( typ interface { } , code interface { } , issuer interface { } ) { err := a . Extract ( typ , code , issuer ) if err != nil { panic ( err ) } }
7417	func Unmarshal ( r io . Reader , v interface { } ) ( int , error ) { return xdr . Unmarshal ( r , v ) }
7418	func Marshal ( w io . Writer , v interface { } ) ( int , error ) { return xdr . Marshal ( w , v ) }
7419	func ( e CryptoKeyType ) ValidEnum ( v int32 ) bool { _ , ok := cryptoKeyTypeMap [ v ] return ok }
7420	func NewPublicKey ( aType CryptoKeyType , value interface { } ) ( result PublicKey , err error ) { result . Type = aType switch CryptoKeyType ( aType ) { case CryptoKeyTypeKeyTypeEd25519 : tv , ok := value . ( Uint256 ) if ! ok { err = fmt . Errorf ( "invalid value, must be Uint256" ) return } result . Ed25519 = & tv } return }
7421	func ( u PublicKey ) MustEd25519 ( ) Uint256 { val , ok := u . GetEd25519 ( ) if ! ok { panic ( "arm Ed25519 is not set" ) } return val }
7422	func NewNodeId ( aType CryptoKeyType , value interface { } ) ( result NodeId , err error ) { u , err := NewPublicKey ( aType , value ) result = NodeId ( u ) return }
7423	func NewAccountId ( aType CryptoKeyType , value interface { } ) ( result AccountId , err error ) { u , err := NewPublicKey ( aType , value ) result = AccountId ( u ) return }
7424	func ( e AssetType ) ValidEnum ( v int32 ) bool { _ , ok := assetTypeMap [ v ] return ok }
7425	func ( u Asset ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch AssetType ( sw ) { case AssetTypeAssetTypeNative : return "" , true case AssetTypeAssetTypeCreditAlphanum4 : return "AlphaNum4" , true case AssetTypeAssetTypeCreditAlphanum12 : return "AlphaNum12" , true } return "-" , false }
7426	func NewAsset ( aType AssetType , value interface { } ) ( result Asset , err error ) { result . Type = aType switch AssetType ( aType ) { case AssetTypeAssetTypeNative : case AssetTypeAssetTypeCreditAlphanum4 : tv , ok := value . ( AssetAlphaNum4 ) if ! ok { err = fmt . Errorf ( "invalid value, must be AssetAlphaNum4" ) return } result . AlphaNum4 = & tv case AssetTypeAssetTypeCreditAlphanum12 : tv , ok := value . ( AssetAlphaNum12 ) if ! ok { err = fmt . Errorf ( "invalid value, must be AssetAlphaNum12" ) return } result . AlphaNum12 = & tv } return }
7427	func ( u Asset ) MustAlphaNum4 ( ) AssetAlphaNum4 { val , ok := u . GetAlphaNum4 ( ) if ! ok { panic ( "arm AlphaNum4 is not set" ) } return val }
7428	func ( u Asset ) GetAlphaNum4 ( ) ( result AssetAlphaNum4 , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "AlphaNum4" { result = * u . AlphaNum4 ok = true } return }
7429	func ( u Asset ) MustAlphaNum12 ( ) AssetAlphaNum12 { val , ok := u . GetAlphaNum12 ( ) if ! ok { panic ( "arm AlphaNum12 is not set" ) } return val }
7430	func ( u Asset ) GetAlphaNum12 ( ) ( result AssetAlphaNum12 , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "AlphaNum12" { result = * u . AlphaNum12 ok = true } return }
7431	func ( e ThresholdIndexes ) ValidEnum ( v int32 ) bool { _ , ok := thresholdIndexesMap [ v ] return ok }
7432	func ( e LedgerEntryType ) ValidEnum ( v int32 ) bool { _ , ok := ledgerEntryTypeMap [ v ] return ok }
7433	func ( e AccountFlags ) ValidEnum ( v int32 ) bool { _ , ok := accountFlagsMap [ v ] return ok }
7434	func NewAccountEntryExt ( v int32 , value interface { } ) ( result AccountEntryExt , err error ) { result . V = v switch int32 ( v ) { case 0 : } return }
7435	func ( e TrustLineFlags ) ValidEnum ( v int32 ) bool { _ , ok := trustLineFlagsMap [ v ] return ok }
7436	func NewTrustLineEntryExt ( v int32 , value interface { } ) ( result TrustLineEntryExt , err error ) { result . V = v switch int32 ( v ) { case 0 : } return }
7437	func ( e OfferEntryFlags ) ValidEnum ( v int32 ) bool { _ , ok := offerEntryFlagsMap [ v ] return ok }
7438	func NewOfferEntryExt ( v int32 , value interface { } ) ( result OfferEntryExt , err error ) { result . V = v switch int32 ( v ) { case 0 : } return }
7439	func NewDataEntryExt ( v int32 , value interface { } ) ( result DataEntryExt , err error ) { result . V = v switch int32 ( v ) { case 0 : } return }
7440	func NewLedgerEntryData ( aType LedgerEntryType , value interface { } ) ( result LedgerEntryData , err error ) { result . Type = aType switch LedgerEntryType ( aType ) { case LedgerEntryTypeAccount : tv , ok := value . ( AccountEntry ) if ! ok { err = fmt . Errorf ( "invalid value, must be AccountEntry" ) return } result . Account = & tv case LedgerEntryTypeTrustline : tv , ok := value . ( TrustLineEntry ) if ! ok { err = fmt . Errorf ( "invalid value, must be TrustLineEntry" ) return } result . TrustLine = & tv case LedgerEntryTypeOffer : tv , ok := value . ( OfferEntry ) if ! ok { err = fmt . Errorf ( "invalid value, must be OfferEntry" ) return } result . Offer = & tv case LedgerEntryTypeData : tv , ok := value . ( DataEntry ) if ! ok { err = fmt . Errorf ( "invalid value, must be DataEntry" ) return } result . Data = & tv } return }
7441	func NewLedgerEntryExt ( v int32 , value interface { } ) ( result LedgerEntryExt , err error ) { result . V = v switch int32 ( v ) { case 0 : } return }
7442	func ( e EnvelopeType ) ValidEnum ( v int32 ) bool { _ , ok := envelopeTypeMap [ v ] return ok }
7443	func ( e OperationType ) ValidEnum ( v int32 ) bool { _ , ok := operationTypeMap [ v ] return ok }
7444	func ( u AllowTrustOpAsset ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch AssetType ( sw ) { case AssetTypeAssetTypeCreditAlphanum4 : return "AssetCode4" , true case AssetTypeAssetTypeCreditAlphanum12 : return "AssetCode12" , true } return "-" , false }
7445	func NewAllowTrustOpAsset ( aType AssetType , value interface { } ) ( result AllowTrustOpAsset , err error ) { result . Type = aType switch AssetType ( aType ) { case AssetTypeAssetTypeCreditAlphanum4 : tv , ok := value . ( [ 4 ] byte ) if ! ok { err = fmt . Errorf ( "invalid value, must be [4]byte" ) return } result . AssetCode4 = & tv case AssetTypeAssetTypeCreditAlphanum12 : tv , ok := value . ( [ 12 ] byte ) if ! ok { err = fmt . Errorf ( "invalid value, must be [12]byte" ) return } result . AssetCode12 = & tv } return }
7446	func ( u AllowTrustOpAsset ) MustAssetCode4 ( ) [ 4 ] byte { val , ok := u . GetAssetCode4 ( ) if ! ok { panic ( "arm AssetCode4 is not set" ) } return val }
7447	func ( u AllowTrustOpAsset ) GetAssetCode4 ( ) ( result [ 4 ] byte , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "AssetCode4" { result = * u . AssetCode4 ok = true } return }
7448	func ( u AllowTrustOpAsset ) MustAssetCode12 ( ) [ 12 ] byte { val , ok := u . GetAssetCode12 ( ) if ! ok { panic ( "arm AssetCode12 is not set" ) } return val }
7449	func ( u AllowTrustOpAsset ) GetAssetCode12 ( ) ( result [ 12 ] byte , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "AssetCode12" { result = * u . AssetCode12 ok = true } return }
7450	func NewOperationBody ( aType OperationType , value interface { } ) ( result OperationBody , err error ) { result . Type = aType switch OperationType ( aType ) { case OperationTypeCreateAccount : tv , ok := value . ( CreateAccountOp ) if ! ok { err = fmt . Errorf ( "invalid value, must be CreateAccountOp" ) return } result . CreateAccountOp = & tv case OperationTypePayment : tv , ok := value . ( PaymentOp ) if ! ok { err = fmt . Errorf ( "invalid value, must be PaymentOp" ) return } result . PaymentOp = & tv case OperationTypePathPayment : tv , ok := value . ( PathPaymentOp ) if ! ok { err = fmt . Errorf ( "invalid value, must be PathPaymentOp" ) return } result . PathPaymentOp = & tv case OperationTypeManageOffer : tv , ok := value . ( ManageOfferOp ) if ! ok { err = fmt . Errorf ( "invalid value, must be ManageOfferOp" ) return } result . ManageOfferOp = & tv case OperationTypeCreatePassiveOffer : tv , ok := value . ( CreatePassiveOfferOp ) if ! ok { err = fmt . Errorf ( "invalid value, must be CreatePassiveOfferOp" ) return } result . CreatePassiveOfferOp = & tv case OperationTypeSetOptions : tv , ok := value . ( SetOptionsOp ) if ! ok { err = fmt . Errorf ( "invalid value, must be SetOptionsOp" ) return } result . SetOptionsOp = & tv case OperationTypeChangeTrust : tv , ok := value . ( ChangeTrustOp ) if ! ok { err = fmt . Errorf ( "invalid value, must be ChangeTrustOp" ) return } result . ChangeTrustOp = & tv case OperationTypeAllowTrust : tv , ok := value . ( AllowTrustOp ) if ! ok { err = fmt . Errorf ( "invalid value, must be AllowTrustOp" ) return } result . AllowTrustOp = & tv case OperationTypeAccountMerge : tv , ok := value . ( AccountId ) if ! ok { err = fmt . Errorf ( "invalid value, must be AccountId" ) return } result . Destination = & tv case OperationTypeInflation : case OperationTypeManageData : tv , ok := value . ( ManageDataOp ) if ! ok { err = fmt . Errorf ( "invalid value, must be ManageDataOp" ) return } result . ManageDataOp = & tv } return }
7451	func ( u OperationBody ) MustCreateAccountOp ( ) CreateAccountOp { val , ok := u . GetCreateAccountOp ( ) if ! ok { panic ( "arm CreateAccountOp is not set" ) } return val }
7452	func ( u OperationBody ) GetCreateAccountOp ( ) ( result CreateAccountOp , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "CreateAccountOp" { result = * u . CreateAccountOp ok = true } return }
7453	func ( u OperationBody ) MustPaymentOp ( ) PaymentOp { val , ok := u . GetPaymentOp ( ) if ! ok { panic ( "arm PaymentOp is not set" ) } return val }
7454	func ( u OperationBody ) GetPaymentOp ( ) ( result PaymentOp , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "PaymentOp" { result = * u . PaymentOp ok = true } return }
7455	func ( u OperationBody ) MustPathPaymentOp ( ) PathPaymentOp { val , ok := u . GetPathPaymentOp ( ) if ! ok { panic ( "arm PathPaymentOp is not set" ) } return val }
7456	func ( u OperationBody ) GetPathPaymentOp ( ) ( result PathPaymentOp , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "PathPaymentOp" { result = * u . PathPaymentOp ok = true } return }
7457	func ( u OperationBody ) MustManageOfferOp ( ) ManageOfferOp { val , ok := u . GetManageOfferOp ( ) if ! ok { panic ( "arm ManageOfferOp is not set" ) } return val }
7458	func ( u OperationBody ) GetManageOfferOp ( ) ( result ManageOfferOp , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "ManageOfferOp" { result = * u . ManageOfferOp ok = true } return }
7459	func ( u OperationBody ) MustCreatePassiveOfferOp ( ) CreatePassiveOfferOp { val , ok := u . GetCreatePassiveOfferOp ( ) if ! ok { panic ( "arm CreatePassiveOfferOp is not set" ) } return val }
7460	func ( u OperationBody ) GetCreatePassiveOfferOp ( ) ( result CreatePassiveOfferOp , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "CreatePassiveOfferOp" { result = * u . CreatePassiveOfferOp ok = true } return }
7461	func ( u OperationBody ) MustSetOptionsOp ( ) SetOptionsOp { val , ok := u . GetSetOptionsOp ( ) if ! ok { panic ( "arm SetOptionsOp is not set" ) } return val }
7462	func ( u OperationBody ) GetSetOptionsOp ( ) ( result SetOptionsOp , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "SetOptionsOp" { result = * u . SetOptionsOp ok = true } return }
7463	func ( u OperationBody ) MustChangeTrustOp ( ) ChangeTrustOp { val , ok := u . GetChangeTrustOp ( ) if ! ok { panic ( "arm ChangeTrustOp is not set" ) } return val }
7464	func ( u OperationBody ) GetChangeTrustOp ( ) ( result ChangeTrustOp , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "ChangeTrustOp" { result = * u . ChangeTrustOp ok = true } return }
7465	func ( u OperationBody ) MustAllowTrustOp ( ) AllowTrustOp { val , ok := u . GetAllowTrustOp ( ) if ! ok { panic ( "arm AllowTrustOp is not set" ) } return val }
7466	func ( u OperationBody ) GetAllowTrustOp ( ) ( result AllowTrustOp , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "AllowTrustOp" { result = * u . AllowTrustOp ok = true } return }
7467	func ( u OperationBody ) MustDestination ( ) AccountId { val , ok := u . GetDestination ( ) if ! ok { panic ( "arm Destination is not set" ) } return val }
7468	func ( u OperationBody ) GetDestination ( ) ( result AccountId , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Destination" { result = * u . Destination ok = true } return }
7469	func ( u OperationBody ) MustManageDataOp ( ) ManageDataOp { val , ok := u . GetManageDataOp ( ) if ! ok { panic ( "arm ManageDataOp is not set" ) } return val }
7470	func ( u OperationBody ) GetManageDataOp ( ) ( result ManageDataOp , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "ManageDataOp" { result = * u . ManageDataOp ok = true } return }
7471	func ( e MemoType ) ValidEnum ( v int32 ) bool { _ , ok := memoTypeMap [ v ] return ok }
7472	func ( u Memo ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch MemoType ( sw ) { case MemoTypeMemoNone : return "" , true case MemoTypeMemoText : return "Text" , true case MemoTypeMemoId : return "Id" , true case MemoTypeMemoHash : return "Hash" , true case MemoTypeMemoReturn : return "RetHash" , true } return "-" , false }
7473	func NewMemo ( aType MemoType , value interface { } ) ( result Memo , err error ) { result . Type = aType switch MemoType ( aType ) { case MemoTypeMemoNone : case MemoTypeMemoText : tv , ok := value . ( string ) if ! ok { err = fmt . Errorf ( "invalid value, must be string" ) return } result . Text = & tv case MemoTypeMemoId : tv , ok := value . ( Uint64 ) if ! ok { err = fmt . Errorf ( "invalid value, must be Uint64" ) return } result . Id = & tv case MemoTypeMemoHash : tv , ok := value . ( Hash ) if ! ok { err = fmt . Errorf ( "invalid value, must be Hash" ) return } result . Hash = & tv case MemoTypeMemoReturn : tv , ok := value . ( Hash ) if ! ok { err = fmt . Errorf ( "invalid value, must be Hash" ) return } result . RetHash = & tv } return }
7474	func ( u Memo ) MustText ( ) string { val , ok := u . GetText ( ) if ! ok { panic ( "arm Text is not set" ) } return val }
7475	func ( u Memo ) GetText ( ) ( result string , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Text" { result = * u . Text ok = true } return }
7476	func ( u Memo ) MustId ( ) Uint64 { val , ok := u . GetId ( ) if ! ok { panic ( "arm Id is not set" ) } return val }
7477	func ( u Memo ) GetId ( ) ( result Uint64 , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Id" { result = * u . Id ok = true } return }
7478	func ( u Memo ) MustHash ( ) Hash { val , ok := u . GetHash ( ) if ! ok { panic ( "arm Hash is not set" ) } return val }
7479	func ( u Memo ) GetHash ( ) ( result Hash , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Hash" { result = * u . Hash ok = true } return }
7480	func ( u Memo ) MustRetHash ( ) Hash { val , ok := u . GetRetHash ( ) if ! ok { panic ( "arm RetHash is not set" ) } return val }
7481	func NewTransactionExt ( v int32 , value interface { } ) ( result TransactionExt , err error ) { result . V = v switch int32 ( v ) { case 0 : } return }
7482	func ( e CreateAccountResultCode ) ValidEnum ( v int32 ) bool { _ , ok := createAccountResultCodeMap [ v ] return ok }
7483	func ( u CreateAccountResult ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch CreateAccountResultCode ( sw ) { case CreateAccountResultCodeCreateAccountSuccess : return "" , true default : return "" , true } }
7484	func NewCreateAccountResult ( code CreateAccountResultCode , value interface { } ) ( result CreateAccountResult , err error ) { result . Code = code switch CreateAccountResultCode ( code ) { case CreateAccountResultCodeCreateAccountSuccess : default : } return }
7485	func ( e PaymentResultCode ) ValidEnum ( v int32 ) bool { _ , ok := paymentResultCodeMap [ v ] return ok }
7486	func ( u PaymentResult ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch PaymentResultCode ( sw ) { case PaymentResultCodePaymentSuccess : return "" , true default : return "" , true } }
7487	func NewPaymentResult ( code PaymentResultCode , value interface { } ) ( result PaymentResult , err error ) { result . Code = code switch PaymentResultCode ( code ) { case PaymentResultCodePaymentSuccess : default : } return }
7488	func ( e PathPaymentResultCode ) ValidEnum ( v int32 ) bool { _ , ok := pathPaymentResultCodeMap [ v ] return ok }
7489	func ( u PathPaymentResult ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch PathPaymentResultCode ( sw ) { case PathPaymentResultCodePathPaymentSuccess : return "Success" , true case PathPaymentResultCodePathPaymentNoIssuer : return "NoIssuer" , true default : return "" , true } }
7490	func NewPathPaymentResult ( code PathPaymentResultCode , value interface { } ) ( result PathPaymentResult , err error ) { result . Code = code switch PathPaymentResultCode ( code ) { case PathPaymentResultCodePathPaymentSuccess : tv , ok := value . ( PathPaymentResultSuccess ) if ! ok { err = fmt . Errorf ( "invalid value, must be PathPaymentResultSuccess" ) return } result . Success = & tv case PathPaymentResultCodePathPaymentNoIssuer : tv , ok := value . ( Asset ) if ! ok { err = fmt . Errorf ( "invalid value, must be Asset" ) return } result . NoIssuer = & tv default : } return }
7491	func ( u PathPaymentResult ) MustNoIssuer ( ) Asset { val , ok := u . GetNoIssuer ( ) if ! ok { panic ( "arm NoIssuer is not set" ) } return val }
7492	func ( u PathPaymentResult ) GetNoIssuer ( ) ( result Asset , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Code ) ) if armName == "NoIssuer" { result = * u . NoIssuer ok = true } return }
7493	func ( e ManageOfferResultCode ) ValidEnum ( v int32 ) bool { _ , ok := manageOfferResultCodeMap [ v ] return ok }
7494	func ( e ManageOfferEffect ) ValidEnum ( v int32 ) bool { _ , ok := manageOfferEffectMap [ v ] return ok }
7495	func ( u ManageOfferSuccessResultOffer ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch ManageOfferEffect ( sw ) { case ManageOfferEffectManageOfferCreated : return "Offer" , true case ManageOfferEffectManageOfferUpdated : return "Offer" , true default : return "" , true } }
7496	func NewManageOfferSuccessResultOffer ( effect ManageOfferEffect , value interface { } ) ( result ManageOfferSuccessResultOffer , err error ) { result . Effect = effect switch ManageOfferEffect ( effect ) { case ManageOfferEffectManageOfferCreated : tv , ok := value . ( OfferEntry ) if ! ok { err = fmt . Errorf ( "invalid value, must be OfferEntry" ) return } result . Offer = & tv case ManageOfferEffectManageOfferUpdated : tv , ok := value . ( OfferEntry ) if ! ok { err = fmt . Errorf ( "invalid value, must be OfferEntry" ) return } result . Offer = & tv default : } return }
7497	func ( u ManageOfferResult ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch ManageOfferResultCode ( sw ) { case ManageOfferResultCodeManageOfferSuccess : return "Success" , true default : return "" , true } }
7498	func NewManageOfferResult ( code ManageOfferResultCode , value interface { } ) ( result ManageOfferResult , err error ) { result . Code = code switch ManageOfferResultCode ( code ) { case ManageOfferResultCodeManageOfferSuccess : tv , ok := value . ( ManageOfferSuccessResult ) if ! ok { err = fmt . Errorf ( "invalid value, must be ManageOfferSuccessResult" ) return } result . Success = & tv default : } return }
7499	func ( e SetOptionsResultCode ) ValidEnum ( v int32 ) bool { _ , ok := setOptionsResultCodeMap [ v ] return ok }
7500	func ( u SetOptionsResult ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch SetOptionsResultCode ( sw ) { case SetOptionsResultCodeSetOptionsSuccess : return "" , true default : return "" , true } }
7501	func NewSetOptionsResult ( code SetOptionsResultCode , value interface { } ) ( result SetOptionsResult , err error ) { result . Code = code switch SetOptionsResultCode ( code ) { case SetOptionsResultCodeSetOptionsSuccess : default : } return }
7502	func ( e ChangeTrustResultCode ) ValidEnum ( v int32 ) bool { _ , ok := changeTrustResultCodeMap [ v ] return ok }
7503	func ( u ChangeTrustResult ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch ChangeTrustResultCode ( sw ) { case ChangeTrustResultCodeChangeTrustSuccess : return "" , true default : return "" , true } }
7504	func NewChangeTrustResult ( code ChangeTrustResultCode , value interface { } ) ( result ChangeTrustResult , err error ) { result . Code = code switch ChangeTrustResultCode ( code ) { case ChangeTrustResultCodeChangeTrustSuccess : default : } return }
7505	func ( e AllowTrustResultCode ) ValidEnum ( v int32 ) bool { _ , ok := allowTrustResultCodeMap [ v ] return ok }
7506	func ( u AllowTrustResult ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch AllowTrustResultCode ( sw ) { case AllowTrustResultCodeAllowTrustSuccess : return "" , true default : return "" , true } }
7507	func NewAllowTrustResult ( code AllowTrustResultCode , value interface { } ) ( result AllowTrustResult , err error ) { result . Code = code switch AllowTrustResultCode ( code ) { case AllowTrustResultCodeAllowTrustSuccess : default : } return }
7508	func ( e AccountMergeResultCode ) ValidEnum ( v int32 ) bool { _ , ok := accountMergeResultCodeMap [ v ] return ok }
7509	func ( u AccountMergeResult ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch AccountMergeResultCode ( sw ) { case AccountMergeResultCodeAccountMergeSuccess : return "SourceAccountBalance" , true default : return "" , true } }
7510	func NewAccountMergeResult ( code AccountMergeResultCode , value interface { } ) ( result AccountMergeResult , err error ) { result . Code = code switch AccountMergeResultCode ( code ) { case AccountMergeResultCodeAccountMergeSuccess : tv , ok := value . ( Int64 ) if ! ok { err = fmt . Errorf ( "invalid value, must be Int64" ) return } result . SourceAccountBalance = & tv default : } return }
7511	func ( u AccountMergeResult ) MustSourceAccountBalance ( ) Int64 { val , ok := u . GetSourceAccountBalance ( ) if ! ok { panic ( "arm SourceAccountBalance is not set" ) } return val }
7512	func ( u AccountMergeResult ) GetSourceAccountBalance ( ) ( result Int64 , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Code ) ) if armName == "SourceAccountBalance" { result = * u . SourceAccountBalance ok = true } return }
7513	func ( e InflationResultCode ) ValidEnum ( v int32 ) bool { _ , ok := inflationResultCodeMap [ v ] return ok }
7514	func ( u InflationResult ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch InflationResultCode ( sw ) { case InflationResultCodeInflationSuccess : return "Payouts" , true default : return "" , true } }
7515	func NewInflationResult ( code InflationResultCode , value interface { } ) ( result InflationResult , err error ) { result . Code = code switch InflationResultCode ( code ) { case InflationResultCodeInflationSuccess : tv , ok := value . ( [ ] InflationPayout ) if ! ok { err = fmt . Errorf ( "invalid value, must be []InflationPayout" ) return } result . Payouts = & tv default : } return }
7516	func ( u InflationResult ) MustPayouts ( ) [ ] InflationPayout { val , ok := u . GetPayouts ( ) if ! ok { panic ( "arm Payouts is not set" ) } return val }
7517	func ( u InflationResult ) GetPayouts ( ) ( result [ ] InflationPayout , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Code ) ) if armName == "Payouts" { result = * u . Payouts ok = true } return }
7518	func ( e ManageDataResultCode ) ValidEnum ( v int32 ) bool { _ , ok := manageDataResultCodeMap [ v ] return ok }
7519	func ( u ManageDataResult ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch ManageDataResultCode ( sw ) { case ManageDataResultCodeManageDataSuccess : return "" , true default : return "" , true } }
7520	func NewManageDataResult ( code ManageDataResultCode , value interface { } ) ( result ManageDataResult , err error ) { result . Code = code switch ManageDataResultCode ( code ) { case ManageDataResultCodeManageDataSuccess : default : } return }
7521	func ( e OperationResultCode ) ValidEnum ( v int32 ) bool { _ , ok := operationResultCodeMap [ v ] return ok }
7522	func ( u OperationResultTr ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch OperationType ( sw ) { case OperationTypeCreateAccount : return "CreateAccountResult" , true case OperationTypePayment : return "PaymentResult" , true case OperationTypePathPayment : return "PathPaymentResult" , true case OperationTypeManageOffer : return "ManageOfferResult" , true case OperationTypeCreatePassiveOffer : return "CreatePassiveOfferResult" , true case OperationTypeSetOptions : return "SetOptionsResult" , true case OperationTypeChangeTrust : return "ChangeTrustResult" , true case OperationTypeAllowTrust : return "AllowTrustResult" , true case OperationTypeAccountMerge : return "AccountMergeResult" , true case OperationTypeInflation : return "InflationResult" , true case OperationTypeManageData : return "ManageDataResult" , true } return "-" , false }
7523	func NewOperationResultTr ( aType OperationType , value interface { } ) ( result OperationResultTr , err error ) { result . Type = aType switch OperationType ( aType ) { case OperationTypeCreateAccount : tv , ok := value . ( CreateAccountResult ) if ! ok { err = fmt . Errorf ( "invalid value, must be CreateAccountResult" ) return } result . CreateAccountResult = & tv case OperationTypePayment : tv , ok := value . ( PaymentResult ) if ! ok { err = fmt . Errorf ( "invalid value, must be PaymentResult" ) return } result . PaymentResult = & tv case OperationTypePathPayment : tv , ok := value . ( PathPaymentResult ) if ! ok { err = fmt . Errorf ( "invalid value, must be PathPaymentResult" ) return } result . PathPaymentResult = & tv case OperationTypeManageOffer : tv , ok := value . ( ManageOfferResult ) if ! ok { err = fmt . Errorf ( "invalid value, must be ManageOfferResult" ) return } result . ManageOfferResult = & tv case OperationTypeCreatePassiveOffer : tv , ok := value . ( ManageOfferResult ) if ! ok { err = fmt . Errorf ( "invalid value, must be ManageOfferResult" ) return } result . CreatePassiveOfferResult = & tv case OperationTypeSetOptions : tv , ok := value . ( SetOptionsResult ) if ! ok { err = fmt . Errorf ( "invalid value, must be SetOptionsResult" ) return } result . SetOptionsResult = & tv case OperationTypeChangeTrust : tv , ok := value . ( ChangeTrustResult ) if ! ok { err = fmt . Errorf ( "invalid value, must be ChangeTrustResult" ) return } result . ChangeTrustResult = & tv case OperationTypeAllowTrust : tv , ok := value . ( AllowTrustResult ) if ! ok { err = fmt . Errorf ( "invalid value, must be AllowTrustResult" ) return } result . AllowTrustResult = & tv case OperationTypeAccountMerge : tv , ok := value . ( AccountMergeResult ) if ! ok { err = fmt . Errorf ( "invalid value, must be AccountMergeResult" ) return } result . AccountMergeResult = & tv case OperationTypeInflation : tv , ok := value . ( InflationResult ) if ! ok { err = fmt . Errorf ( "invalid value, must be InflationResult" ) return } result . InflationResult = & tv case OperationTypeManageData : tv , ok := value . ( ManageDataResult ) if ! ok { err = fmt . Errorf ( "invalid value, must be ManageDataResult" ) return } result . ManageDataResult = & tv } return }
7524	func ( u OperationResultTr ) MustCreateAccountResult ( ) CreateAccountResult { val , ok := u . GetCreateAccountResult ( ) if ! ok { panic ( "arm CreateAccountResult is not set" ) } return val }
7525	func ( u OperationResultTr ) GetCreateAccountResult ( ) ( result CreateAccountResult , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "CreateAccountResult" { result = * u . CreateAccountResult ok = true } return }
7526	func ( u OperationResultTr ) MustPaymentResult ( ) PaymentResult { val , ok := u . GetPaymentResult ( ) if ! ok { panic ( "arm PaymentResult is not set" ) } return val }
7527	func ( u OperationResultTr ) GetPaymentResult ( ) ( result PaymentResult , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "PaymentResult" { result = * u . PaymentResult ok = true } return }
7528	func ( u OperationResultTr ) MustPathPaymentResult ( ) PathPaymentResult { val , ok := u . GetPathPaymentResult ( ) if ! ok { panic ( "arm PathPaymentResult is not set" ) } return val }
7529	func ( u OperationResultTr ) GetPathPaymentResult ( ) ( result PathPaymentResult , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "PathPaymentResult" { result = * u . PathPaymentResult ok = true } return }
7530	func ( u OperationResultTr ) MustManageOfferResult ( ) ManageOfferResult { val , ok := u . GetManageOfferResult ( ) if ! ok { panic ( "arm ManageOfferResult is not set" ) } return val }
7531	func ( u OperationResultTr ) GetManageOfferResult ( ) ( result ManageOfferResult , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "ManageOfferResult" { result = * u . ManageOfferResult ok = true } return }
7532	func ( u OperationResultTr ) MustCreatePassiveOfferResult ( ) ManageOfferResult { val , ok := u . GetCreatePassiveOfferResult ( ) if ! ok { panic ( "arm CreatePassiveOfferResult is not set" ) } return val }
7533	func ( u OperationResultTr ) MustSetOptionsResult ( ) SetOptionsResult { val , ok := u . GetSetOptionsResult ( ) if ! ok { panic ( "arm SetOptionsResult is not set" ) } return val }
7534	func ( u OperationResultTr ) GetSetOptionsResult ( ) ( result SetOptionsResult , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "SetOptionsResult" { result = * u . SetOptionsResult ok = true } return }
7535	func ( u OperationResultTr ) MustChangeTrustResult ( ) ChangeTrustResult { val , ok := u . GetChangeTrustResult ( ) if ! ok { panic ( "arm ChangeTrustResult is not set" ) } return val }
7536	func ( u OperationResultTr ) GetChangeTrustResult ( ) ( result ChangeTrustResult , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "ChangeTrustResult" { result = * u . ChangeTrustResult ok = true } return }
7537	func ( u OperationResultTr ) MustAllowTrustResult ( ) AllowTrustResult { val , ok := u . GetAllowTrustResult ( ) if ! ok { panic ( "arm AllowTrustResult is not set" ) } return val }
7538	func ( u OperationResultTr ) GetAllowTrustResult ( ) ( result AllowTrustResult , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "AllowTrustResult" { result = * u . AllowTrustResult ok = true } return }
7539	func ( u OperationResultTr ) MustAccountMergeResult ( ) AccountMergeResult { val , ok := u . GetAccountMergeResult ( ) if ! ok { panic ( "arm AccountMergeResult is not set" ) } return val }
7540	func ( u OperationResultTr ) GetAccountMergeResult ( ) ( result AccountMergeResult , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "AccountMergeResult" { result = * u . AccountMergeResult ok = true } return }
7541	func ( u OperationResultTr ) MustInflationResult ( ) InflationResult { val , ok := u . GetInflationResult ( ) if ! ok { panic ( "arm InflationResult is not set" ) } return val }
7542	func ( u OperationResultTr ) GetInflationResult ( ) ( result InflationResult , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "InflationResult" { result = * u . InflationResult ok = true } return }
7543	func ( u OperationResultTr ) MustManageDataResult ( ) ManageDataResult { val , ok := u . GetManageDataResult ( ) if ! ok { panic ( "arm ManageDataResult is not set" ) } return val }
7544	func ( u OperationResultTr ) GetManageDataResult ( ) ( result ManageDataResult , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "ManageDataResult" { result = * u . ManageDataResult ok = true } return }
7545	func ( u OperationResult ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch OperationResultCode ( sw ) { case OperationResultCodeOpInner : return "Tr" , true default : return "" , true } }
7546	func NewOperationResult ( code OperationResultCode , value interface { } ) ( result OperationResult , err error ) { result . Code = code switch OperationResultCode ( code ) { case OperationResultCodeOpInner : tv , ok := value . ( OperationResultTr ) if ! ok { err = fmt . Errorf ( "invalid value, must be OperationResultTr" ) return } result . Tr = & tv default : } return }
7547	func ( u OperationResult ) MustTr ( ) OperationResultTr { val , ok := u . GetTr ( ) if ! ok { panic ( "arm Tr is not set" ) } return val }
7548	func ( u OperationResult ) GetTr ( ) ( result OperationResultTr , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Code ) ) if armName == "Tr" { result = * u . Tr ok = true } return }
7549	func ( e TransactionResultCode ) ValidEnum ( v int32 ) bool { _ , ok := transactionResultCodeMap [ v ] return ok }
7550	func ( u TransactionResultResult ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch TransactionResultCode ( sw ) { case TransactionResultCodeTxSuccess : return "Results" , true case TransactionResultCodeTxFailed : return "Results" , true default : return "" , true } }
7551	func NewTransactionResultResult ( code TransactionResultCode , value interface { } ) ( result TransactionResultResult , err error ) { result . Code = code switch TransactionResultCode ( code ) { case TransactionResultCodeTxSuccess : tv , ok := value . ( [ ] OperationResult ) if ! ok { err = fmt . Errorf ( "invalid value, must be []OperationResult" ) return } result . Results = & tv case TransactionResultCodeTxFailed : tv , ok := value . ( [ ] OperationResult ) if ! ok { err = fmt . Errorf ( "invalid value, must be []OperationResult" ) return } result . Results = & tv default : } return }
7552	func ( u TransactionResultResult ) MustResults ( ) [ ] OperationResult { val , ok := u . GetResults ( ) if ! ok { panic ( "arm Results is not set" ) } return val }
7553	func ( u TransactionResultResult ) GetResults ( ) ( result [ ] OperationResult , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Code ) ) if armName == "Results" { result = * u . Results ok = true } return }
7554	func NewTransactionResultExt ( v int32 , value interface { } ) ( result TransactionResultExt , err error ) { result . V = v switch int32 ( v ) { case 0 : } return }
7555	func NewStellarValueExt ( v int32 , value interface { } ) ( result StellarValueExt , err error ) { result . V = v switch int32 ( v ) { case 0 : } return }
7556	func NewLedgerHeaderExt ( v int32 , value interface { } ) ( result LedgerHeaderExt , err error ) { result . V = v switch int32 ( v ) { case 0 : } return }
7557	func ( e LedgerUpgradeType ) ValidEnum ( v int32 ) bool { _ , ok := ledgerUpgradeTypeMap [ v ] return ok }
7558	func ( u LedgerUpgrade ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch LedgerUpgradeType ( sw ) { case LedgerUpgradeTypeLedgerUpgradeVersion : return "NewLedgerVersion" , true case LedgerUpgradeTypeLedgerUpgradeBaseFee : return "NewBaseFee" , true case LedgerUpgradeTypeLedgerUpgradeMaxTxSetSize : return "NewMaxTxSetSize" , true } return "-" , false }
7559	func NewLedgerUpgrade ( aType LedgerUpgradeType , value interface { } ) ( result LedgerUpgrade , err error ) { result . Type = aType switch LedgerUpgradeType ( aType ) { case LedgerUpgradeTypeLedgerUpgradeVersion : tv , ok := value . ( Uint32 ) if ! ok { err = fmt . Errorf ( "invalid value, must be Uint32" ) return } result . NewLedgerVersion = & tv case LedgerUpgradeTypeLedgerUpgradeBaseFee : tv , ok := value . ( Uint32 ) if ! ok { err = fmt . Errorf ( "invalid value, must be Uint32" ) return } result . NewBaseFee = & tv case LedgerUpgradeTypeLedgerUpgradeMaxTxSetSize : tv , ok := value . ( Uint32 ) if ! ok { err = fmt . Errorf ( "invalid value, must be Uint32" ) return } result . NewMaxTxSetSize = & tv } return }
7560	func ( u LedgerUpgrade ) MustNewLedgerVersion ( ) Uint32 { val , ok := u . GetNewLedgerVersion ( ) if ! ok { panic ( "arm NewLedgerVersion is not set" ) } return val }
7561	func ( u LedgerUpgrade ) GetNewLedgerVersion ( ) ( result Uint32 , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "NewLedgerVersion" { result = * u . NewLedgerVersion ok = true } return }
7562	func ( u LedgerUpgrade ) MustNewBaseFee ( ) Uint32 { val , ok := u . GetNewBaseFee ( ) if ! ok { panic ( "arm NewBaseFee is not set" ) } return val }
7563	func ( u LedgerUpgrade ) GetNewBaseFee ( ) ( result Uint32 , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "NewBaseFee" { result = * u . NewBaseFee ok = true } return }
7564	func ( u LedgerUpgrade ) MustNewMaxTxSetSize ( ) Uint32 { val , ok := u . GetNewMaxTxSetSize ( ) if ! ok { panic ( "arm NewMaxTxSetSize is not set" ) } return val }
7565	func ( u LedgerUpgrade ) GetNewMaxTxSetSize ( ) ( result Uint32 , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "NewMaxTxSetSize" { result = * u . NewMaxTxSetSize ok = true } return }
7566	func ( u LedgerKey ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch LedgerEntryType ( sw ) { case LedgerEntryTypeAccount : return "Account" , true case LedgerEntryTypeTrustline : return "TrustLine" , true case LedgerEntryTypeOffer : return "Offer" , true case LedgerEntryTypeData : return "Data" , true } return "-" , false }
7567	func NewLedgerKey ( aType LedgerEntryType , value interface { } ) ( result LedgerKey , err error ) { result . Type = aType switch LedgerEntryType ( aType ) { case LedgerEntryTypeAccount : tv , ok := value . ( LedgerKeyAccount ) if ! ok { err = fmt . Errorf ( "invalid value, must be LedgerKeyAccount" ) return } result . Account = & tv case LedgerEntryTypeTrustline : tv , ok := value . ( LedgerKeyTrustLine ) if ! ok { err = fmt . Errorf ( "invalid value, must be LedgerKeyTrustLine" ) return } result . TrustLine = & tv case LedgerEntryTypeOffer : tv , ok := value . ( LedgerKeyOffer ) if ! ok { err = fmt . Errorf ( "invalid value, must be LedgerKeyOffer" ) return } result . Offer = & tv case LedgerEntryTypeData : tv , ok := value . ( LedgerKeyData ) if ! ok { err = fmt . Errorf ( "invalid value, must be LedgerKeyData" ) return } result . Data = & tv } return }
7568	func ( e BucketEntryType ) ValidEnum ( v int32 ) bool { _ , ok := bucketEntryTypeMap [ v ] return ok }
7569	func ( u BucketEntry ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch BucketEntryType ( sw ) { case BucketEntryTypeLiveentry : return "LiveEntry" , true case BucketEntryTypeDeadentry : return "DeadEntry" , true } return "-" , false }
7570	func NewBucketEntry ( aType BucketEntryType , value interface { } ) ( result BucketEntry , err error ) { result . Type = aType switch BucketEntryType ( aType ) { case BucketEntryTypeLiveentry : tv , ok := value . ( LedgerEntry ) if ! ok { err = fmt . Errorf ( "invalid value, must be LedgerEntry" ) return } result . LiveEntry = & tv case BucketEntryTypeDeadentry : tv , ok := value . ( LedgerKey ) if ! ok { err = fmt . Errorf ( "invalid value, must be LedgerKey" ) return } result . DeadEntry = & tv } return }
7571	func ( u BucketEntry ) MustLiveEntry ( ) LedgerEntry { val , ok := u . GetLiveEntry ( ) if ! ok { panic ( "arm LiveEntry is not set" ) } return val }
7572	func ( u BucketEntry ) GetLiveEntry ( ) ( result LedgerEntry , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "LiveEntry" { result = * u . LiveEntry ok = true } return }
7573	func ( u BucketEntry ) MustDeadEntry ( ) LedgerKey { val , ok := u . GetDeadEntry ( ) if ! ok { panic ( "arm DeadEntry is not set" ) } return val }
7574	func ( u BucketEntry ) GetDeadEntry ( ) ( result LedgerKey , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "DeadEntry" { result = * u . DeadEntry ok = true } return }
7575	func NewTransactionHistoryEntryExt ( v int32 , value interface { } ) ( result TransactionHistoryEntryExt , err error ) { result . V = v switch int32 ( v ) { case 0 : } return }
7576	func ( u TransactionHistoryResultEntryExt ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch int32 ( sw ) { case 0 : return "" , true } return "-" , false }
7577	func NewTransactionHistoryResultEntryExt ( v int32 , value interface { } ) ( result TransactionHistoryResultEntryExt , err error ) { result . V = v switch int32 ( v ) { case 0 : } return }
7578	func NewLedgerHeaderHistoryEntryExt ( v int32 , value interface { } ) ( result LedgerHeaderHistoryEntryExt , err error ) { result . V = v switch int32 ( v ) { case 0 : } return }
7579	func NewScpHistoryEntry ( v int32 , value interface { } ) ( result ScpHistoryEntry , err error ) { result . V = v switch int32 ( v ) { case 0 : tv , ok := value . ( ScpHistoryEntryV0 ) if ! ok { err = fmt . Errorf ( "invalid value, must be ScpHistoryEntryV0" ) return } result . V0 = & tv } return }
7580	func ( e LedgerEntryChangeType ) ValidEnum ( v int32 ) bool { _ , ok := ledgerEntryChangeTypeMap [ v ] return ok }
7581	func ( u LedgerEntryChange ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch LedgerEntryChangeType ( sw ) { case LedgerEntryChangeTypeLedgerEntryCreated : return "Created" , true case LedgerEntryChangeTypeLedgerEntryUpdated : return "Updated" , true case LedgerEntryChangeTypeLedgerEntryRemoved : return "Removed" , true case LedgerEntryChangeTypeLedgerEntryState : return "State" , true } return "-" , false }
7582	func NewLedgerEntryChange ( aType LedgerEntryChangeType , value interface { } ) ( result LedgerEntryChange , err error ) { result . Type = aType switch LedgerEntryChangeType ( aType ) { case LedgerEntryChangeTypeLedgerEntryCreated : tv , ok := value . ( LedgerEntry ) if ! ok { err = fmt . Errorf ( "invalid value, must be LedgerEntry" ) return } result . Created = & tv case LedgerEntryChangeTypeLedgerEntryUpdated : tv , ok := value . ( LedgerEntry ) if ! ok { err = fmt . Errorf ( "invalid value, must be LedgerEntry" ) return } result . Updated = & tv case LedgerEntryChangeTypeLedgerEntryRemoved : tv , ok := value . ( LedgerKey ) if ! ok { err = fmt . Errorf ( "invalid value, must be LedgerKey" ) return } result . Removed = & tv case LedgerEntryChangeTypeLedgerEntryState : tv , ok := value . ( LedgerEntry ) if ! ok { err = fmt . Errorf ( "invalid value, must be LedgerEntry" ) return } result . State = & tv } return }
7583	func ( u LedgerEntryChange ) MustCreated ( ) LedgerEntry { val , ok := u . GetCreated ( ) if ! ok { panic ( "arm Created is not set" ) } return val }
7584	func ( u LedgerEntryChange ) GetCreated ( ) ( result LedgerEntry , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Created" { result = * u . Created ok = true } return }
7585	func ( u LedgerEntryChange ) MustUpdated ( ) LedgerEntry { val , ok := u . GetUpdated ( ) if ! ok { panic ( "arm Updated is not set" ) } return val }
7586	func ( u LedgerEntryChange ) GetUpdated ( ) ( result LedgerEntry , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Updated" { result = * u . Updated ok = true } return }
7587	func ( u LedgerEntryChange ) MustRemoved ( ) LedgerKey { val , ok := u . GetRemoved ( ) if ! ok { panic ( "arm Removed is not set" ) } return val }
7588	func ( u LedgerEntryChange ) GetRemoved ( ) ( result LedgerKey , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Removed" { result = * u . Removed ok = true } return }
7589	func ( u LedgerEntryChange ) MustState ( ) LedgerEntry { val , ok := u . GetState ( ) if ! ok { panic ( "arm State is not set" ) } return val }
7590	func ( u LedgerEntryChange ) GetState ( ) ( result LedgerEntry , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "State" { result = * u . State ok = true } return }
7591	func NewTransactionMeta ( v int32 , value interface { } ) ( result TransactionMeta , err error ) { result . V = v switch int32 ( v ) { case 0 : tv , ok := value . ( [ ] OperationMeta ) if ! ok { err = fmt . Errorf ( "invalid value, must be []OperationMeta" ) return } result . Operations = & tv } return }
7592	func ( u TransactionMeta ) MustOperations ( ) [ ] OperationMeta { val , ok := u . GetOperations ( ) if ! ok { panic ( "arm Operations is not set" ) } return val }
7593	func ( u TransactionMeta ) GetOperations ( ) ( result [ ] OperationMeta , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . V ) ) if armName == "Operations" { result = * u . Operations ok = true } return }
7594	func ( e ErrorCode ) ValidEnum ( v int32 ) bool { _ , ok := errorCodeMap [ v ] return ok }
7595	func ( e IpAddrType ) ValidEnum ( v int32 ) bool { _ , ok := ipAddrTypeMap [ v ] return ok }
7596	func ( u PeerAddressIp ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch IpAddrType ( sw ) { case IpAddrTypeIPv4 : return "Ipv4" , true case IpAddrTypeIPv6 : return "Ipv6" , true } return "-" , false }
7597	func NewPeerAddressIp ( aType IpAddrType , value interface { } ) ( result PeerAddressIp , err error ) { result . Type = aType switch IpAddrType ( aType ) { case IpAddrTypeIPv4 : tv , ok := value . ( [ 4 ] byte ) if ! ok { err = fmt . Errorf ( "invalid value, must be [4]byte" ) return } result . Ipv4 = & tv case IpAddrTypeIPv6 : tv , ok := value . ( [ 16 ] byte ) if ! ok { err = fmt . Errorf ( "invalid value, must be [16]byte" ) return } result . Ipv6 = & tv } return }
7598	func ( u PeerAddressIp ) MustIpv4 ( ) [ 4 ] byte { val , ok := u . GetIpv4 ( ) if ! ok { panic ( "arm Ipv4 is not set" ) } return val }
7599	func ( u PeerAddressIp ) GetIpv4 ( ) ( result [ 4 ] byte , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Ipv4" { result = * u . Ipv4 ok = true } return }
7600	func ( u PeerAddressIp ) MustIpv6 ( ) [ 16 ] byte { val , ok := u . GetIpv6 ( ) if ! ok { panic ( "arm Ipv6 is not set" ) } return val }
7601	func ( u PeerAddressIp ) GetIpv6 ( ) ( result [ 16 ] byte , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Ipv6" { result = * u . Ipv6 ok = true } return }
7602	func ( e MessageType ) ValidEnum ( v int32 ) bool { _ , ok := messageTypeMap [ v ] return ok }
7603	func ( u StellarMessage ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch MessageType ( sw ) { case MessageTypeErrorMsg : return "Error" , true case MessageTypeHello : return "Hello" , true case MessageTypeAuth : return "Auth" , true case MessageTypeDontHave : return "DontHave" , true case MessageTypeGetPeers : return "" , true case MessageTypePeers : return "Peers" , true case MessageTypeGetTxSet : return "TxSetHash" , true case MessageTypeTxSet : return "TxSet" , true case MessageTypeTransaction : return "Transaction" , true case MessageTypeGetScpQuorumset : return "QSetHash" , true case MessageTypeScpQuorumset : return "QSet" , true case MessageTypeScpMessage : return "Envelope" , true case MessageTypeGetScpState : return "GetScpLedgerSeq" , true } return "-" , false }
7604	func NewStellarMessage ( aType MessageType , value interface { } ) ( result StellarMessage , err error ) { result . Type = aType switch MessageType ( aType ) { case MessageTypeErrorMsg : tv , ok := value . ( Error ) if ! ok { err = fmt . Errorf ( "invalid value, must be Error" ) return } result . Error = & tv case MessageTypeHello : tv , ok := value . ( Hello ) if ! ok { err = fmt . Errorf ( "invalid value, must be Hello" ) return } result . Hello = & tv case MessageTypeAuth : tv , ok := value . ( Auth ) if ! ok { err = fmt . Errorf ( "invalid value, must be Auth" ) return } result . Auth = & tv case MessageTypeDontHave : tv , ok := value . ( DontHave ) if ! ok { err = fmt . Errorf ( "invalid value, must be DontHave" ) return } result . DontHave = & tv case MessageTypeGetPeers : case MessageTypePeers : tv , ok := value . ( [ ] PeerAddress ) if ! ok { err = fmt . Errorf ( "invalid value, must be []PeerAddress" ) return } result . Peers = & tv case MessageTypeGetTxSet : tv , ok := value . ( Uint256 ) if ! ok { err = fmt . Errorf ( "invalid value, must be Uint256" ) return } result . TxSetHash = & tv case MessageTypeTxSet : tv , ok := value . ( TransactionSet ) if ! ok { err = fmt . Errorf ( "invalid value, must be TransactionSet" ) return } result . TxSet = & tv case MessageTypeTransaction : tv , ok := value . ( TransactionEnvelope ) if ! ok { err = fmt . Errorf ( "invalid value, must be TransactionEnvelope" ) return } result . Transaction = & tv case MessageTypeGetScpQuorumset : tv , ok := value . ( Uint256 ) if ! ok { err = fmt . Errorf ( "invalid value, must be Uint256" ) return } result . QSetHash = & tv case MessageTypeScpQuorumset : tv , ok := value . ( ScpQuorumSet ) if ! ok { err = fmt . Errorf ( "invalid value, must be ScpQuorumSet" ) return } result . QSet = & tv case MessageTypeScpMessage : tv , ok := value . ( ScpEnvelope ) if ! ok { err = fmt . Errorf ( "invalid value, must be ScpEnvelope" ) return } result . Envelope = & tv case MessageTypeGetScpState : tv , ok := value . ( Uint32 ) if ! ok { err = fmt . Errorf ( "invalid value, must be Uint32" ) return } result . GetScpLedgerSeq = & tv } return }
7605	func ( u StellarMessage ) MustError ( ) Error { val , ok := u . GetError ( ) if ! ok { panic ( "arm Error is not set" ) } return val }
7606	func ( u StellarMessage ) GetError ( ) ( result Error , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Error" { result = * u . Error ok = true } return }
7607	func ( u StellarMessage ) MustHello ( ) Hello { val , ok := u . GetHello ( ) if ! ok { panic ( "arm Hello is not set" ) } return val }
7608	func ( u StellarMessage ) GetHello ( ) ( result Hello , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Hello" { result = * u . Hello ok = true } return }
7609	func ( u StellarMessage ) MustAuth ( ) Auth { val , ok := u . GetAuth ( ) if ! ok { panic ( "arm Auth is not set" ) } return val }
7610	func ( u StellarMessage ) GetAuth ( ) ( result Auth , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Auth" { result = * u . Auth ok = true } return }
7611	func ( u StellarMessage ) MustDontHave ( ) DontHave { val , ok := u . GetDontHave ( ) if ! ok { panic ( "arm DontHave is not set" ) } return val }
7612	func ( u StellarMessage ) GetDontHave ( ) ( result DontHave , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "DontHave" { result = * u . DontHave ok = true } return }
7613	func ( u StellarMessage ) MustPeers ( ) [ ] PeerAddress { val , ok := u . GetPeers ( ) if ! ok { panic ( "arm Peers is not set" ) } return val }
7614	func ( u StellarMessage ) GetPeers ( ) ( result [ ] PeerAddress , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Peers" { result = * u . Peers ok = true } return }
7615	func ( u StellarMessage ) MustTxSetHash ( ) Uint256 { val , ok := u . GetTxSetHash ( ) if ! ok { panic ( "arm TxSetHash is not set" ) } return val }
7616	func ( u StellarMessage ) GetTxSetHash ( ) ( result Uint256 , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "TxSetHash" { result = * u . TxSetHash ok = true } return }
7617	func ( u StellarMessage ) MustTxSet ( ) TransactionSet { val , ok := u . GetTxSet ( ) if ! ok { panic ( "arm TxSet is not set" ) } return val }
7618	func ( u StellarMessage ) GetTxSet ( ) ( result TransactionSet , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "TxSet" { result = * u . TxSet ok = true } return }
7619	func ( u StellarMessage ) MustTransaction ( ) TransactionEnvelope { val , ok := u . GetTransaction ( ) if ! ok { panic ( "arm Transaction is not set" ) } return val }
7620	func ( u StellarMessage ) GetTransaction ( ) ( result TransactionEnvelope , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Transaction" { result = * u . Transaction ok = true } return }
7621	func ( u StellarMessage ) MustQSetHash ( ) Uint256 { val , ok := u . GetQSetHash ( ) if ! ok { panic ( "arm QSetHash is not set" ) } return val }
7622	func ( u StellarMessage ) GetQSetHash ( ) ( result Uint256 , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "QSetHash" { result = * u . QSetHash ok = true } return }
7623	func ( u StellarMessage ) MustQSet ( ) ScpQuorumSet { val , ok := u . GetQSet ( ) if ! ok { panic ( "arm QSet is not set" ) } return val }
7624	func ( u StellarMessage ) GetQSet ( ) ( result ScpQuorumSet , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "QSet" { result = * u . QSet ok = true } return }
7625	func ( u StellarMessage ) MustEnvelope ( ) ScpEnvelope { val , ok := u . GetEnvelope ( ) if ! ok { panic ( "arm Envelope is not set" ) } return val }
7626	func ( u StellarMessage ) GetEnvelope ( ) ( result ScpEnvelope , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Envelope" { result = * u . Envelope ok = true } return }
7627	func ( u StellarMessage ) MustGetScpLedgerSeq ( ) Uint32 { val , ok := u . GetGetScpLedgerSeq ( ) if ! ok { panic ( "arm GetScpLedgerSeq is not set" ) } return val }
7628	func ( u StellarMessage ) GetGetScpLedgerSeq ( ) ( result Uint32 , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "GetScpLedgerSeq" { result = * u . GetScpLedgerSeq ok = true } return }
7629	func ( u AuthenticatedMessage ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch Uint32 ( sw ) { case 0 : return "V0" , true } return "-" , false }
7630	func NewAuthenticatedMessage ( v Uint32 , value interface { } ) ( result AuthenticatedMessage , err error ) { result . V = v switch Uint32 ( v ) { case 0 : tv , ok := value . ( AuthenticatedMessageV0 ) if ! ok { err = fmt . Errorf ( "invalid value, must be AuthenticatedMessageV0" ) return } result . V0 = & tv } return }
7631	func ( e ScpStatementType ) ValidEnum ( v int32 ) bool { _ , ok := scpStatementTypeMap [ v ] return ok }
7632	func ( u ScpStatementPledges ) ArmForSwitch ( sw int32 ) ( string , bool ) { switch ScpStatementType ( sw ) { case ScpStatementTypeScpStPrepare : return "Prepare" , true case ScpStatementTypeScpStConfirm : return "Confirm" , true case ScpStatementTypeScpStExternalize : return "Externalize" , true case ScpStatementTypeScpStNominate : return "Nominate" , true } return "-" , false }
7633	func NewScpStatementPledges ( aType ScpStatementType , value interface { } ) ( result ScpStatementPledges , err error ) { result . Type = aType switch ScpStatementType ( aType ) { case ScpStatementTypeScpStPrepare : tv , ok := value . ( ScpStatementPrepare ) if ! ok { err = fmt . Errorf ( "invalid value, must be ScpStatementPrepare" ) return } result . Prepare = & tv case ScpStatementTypeScpStConfirm : tv , ok := value . ( ScpStatementConfirm ) if ! ok { err = fmt . Errorf ( "invalid value, must be ScpStatementConfirm" ) return } result . Confirm = & tv case ScpStatementTypeScpStExternalize : tv , ok := value . ( ScpStatementExternalize ) if ! ok { err = fmt . Errorf ( "invalid value, must be ScpStatementExternalize" ) return } result . Externalize = & tv case ScpStatementTypeScpStNominate : tv , ok := value . ( ScpNomination ) if ! ok { err = fmt . Errorf ( "invalid value, must be ScpNomination" ) return } result . Nominate = & tv } return }
7634	func ( u ScpStatementPledges ) MustPrepare ( ) ScpStatementPrepare { val , ok := u . GetPrepare ( ) if ! ok { panic ( "arm Prepare is not set" ) } return val }
7635	func ( u ScpStatementPledges ) GetPrepare ( ) ( result ScpStatementPrepare , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Prepare" { result = * u . Prepare ok = true } return }
7636	func ( u ScpStatementPledges ) MustConfirm ( ) ScpStatementConfirm { val , ok := u . GetConfirm ( ) if ! ok { panic ( "arm Confirm is not set" ) } return val }
7637	func ( u ScpStatementPledges ) GetConfirm ( ) ( result ScpStatementConfirm , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Confirm" { result = * u . Confirm ok = true } return }
7638	func ( u ScpStatementPledges ) MustExternalize ( ) ScpStatementExternalize { val , ok := u . GetExternalize ( ) if ! ok { panic ( "arm Externalize is not set" ) } return val }
7639	func ( u ScpStatementPledges ) GetExternalize ( ) ( result ScpStatementExternalize , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Externalize" { result = * u . Externalize ok = true } return }
7640	func ( u ScpStatementPledges ) MustNominate ( ) ScpNomination { val , ok := u . GetNominate ( ) if ! ok { panic ( "arm Nominate is not set" ) } return val }
7641	func ( u ScpStatementPledges ) GetNominate ( ) ( result ScpNomination , ok bool ) { armName , _ := u . ArmForSwitch ( int32 ( u . Type ) ) if armName == "Nominate" { result = * u . Nominate ok = true } return }
7642	func SafeUnmarshalBase64 ( data string , dest interface { } ) error { count := & countWriter { } l := len ( data ) b64 := io . TeeReader ( strings . NewReader ( data ) , count ) raw := base64 . NewDecoder ( base64 . StdEncoding , b64 ) _ , err := Unmarshal ( raw , dest ) if err != nil { return err } if count . Count != l { return fmt . Errorf ( "input not fully consumed. expected to read: %d, actual: %d" , l , count . Count ) } return nil }
7643	func SafeUnmarshal ( data [ ] byte , dest interface { } ) error { r := bytes . NewReader ( data ) n , err := Unmarshal ( r , dest ) if err != nil { return err } if n != len ( data ) { return fmt . Errorf ( "input not fully consumed. expected to read: %d, actual: %d" , len ( data ) , n ) } return nil }
7644	func ( pr * PathPaymentResult ) SendAmount ( ) Int64 { s , ok := pr . GetSuccess ( ) if ! ok { return 0 } if len ( s . Offers ) == 0 { return s . Last . Amount } sa := s . Offers [ 0 ] . AssetBought var ret Int64 for _ , o := range s . Offers { if o . AssetBought . String ( ) != sa . String ( ) { break } ret += o . AmountBought } return ret }
7645	func ( c * Client ) LoadAccount ( accountID string ) ( account Account , err error ) { c . initHTTPClient ( ) resp , err := c . Client . Get ( c . URL + "/accounts/" + accountID ) if err != nil { return } err = decodeResponse ( resp , & account ) return }
7646	func ( c * Client ) SequenceForAccount ( accountID string , ) ( xdr . SequenceNumber , error ) { a , err := c . LoadAccount ( accountID ) if err != nil { return 0 , err } seq , err := strconv . ParseUint ( a . Sequence , 10 , 64 ) if err != nil { return 0 , err } return xdr . SequenceNumber ( seq ) , nil }
7647	func ( c * Client ) SubmitTransaction ( transactionEnvelopeXdr string ) ( response TransactionSuccess , err error ) { v := url . Values { } v . Set ( "tx" , transactionEnvelopeXdr ) c . initHTTPClient ( ) resp , err := c . Client . PostForm ( c . URL + "/transactions" , v ) if err != nil { return } err = decodeResponse ( resp , & response ) return }
7648	func ( key * LedgerKey ) Equals ( other LedgerKey ) bool { if key . Type != other . Type { return false } switch key . Type { case LedgerEntryTypeAccount : l := key . MustAccount ( ) r := other . MustAccount ( ) return l . AccountId . Equals ( r . AccountId ) case LedgerEntryTypeData : l := key . MustData ( ) r := other . MustData ( ) return l . AccountId . Equals ( r . AccountId ) && l . DataName == r . DataName case LedgerEntryTypeOffer : l := key . MustOffer ( ) r := other . MustOffer ( ) return l . SellerId . Equals ( r . SellerId ) && l . OfferId == r . OfferId case LedgerEntryTypeTrustline : l := key . MustTrustLine ( ) r := other . MustTrustLine ( ) return l . AccountId . Equals ( r . AccountId ) && l . Asset . Equals ( r . Asset ) default : panic ( fmt . Errorf ( "Unknown ledger key type: %v" , key . Type ) ) } }
7649	func ( key * LedgerKey ) SetAccount ( account AccountId ) error { data := LedgerKeyAccount { account } nkey , err := NewLedgerKey ( LedgerEntryTypeAccount , data ) if err != nil { return err } * key = nkey return nil }
7650	func ( key * LedgerKey ) SetData ( account AccountId , name string ) error { data := LedgerKeyData { account , String64 ( name ) } nkey , err := NewLedgerKey ( LedgerEntryTypeData , data ) if err != nil { return err } * key = nkey return nil }
7651	func ( key * LedgerKey ) SetOffer ( account AccountId , id uint64 ) error { data := LedgerKeyOffer { account , Uint64 ( id ) } nkey , err := NewLedgerKey ( LedgerEntryTypeOffer , data ) if err != nil { return err } * key = nkey return nil }
7652	func ( key * LedgerKey ) SetTrustline ( account AccountId , line Asset ) error { data := LedgerKeyTrustLine { account , line } nkey , err := NewLedgerKey ( LedgerEntryTypeTrustline , data ) if err != nil { return err } * key = nkey return nil }
7653	func ( b * CHDBuilder ) Add ( key [ ] byte , value [ ] byte ) { b . keys = append ( b . keys , key ) b . values = append ( b . values , value ) }
7654	func tryHash ( hasher * chdHasher , seen map [ uint64 ] bool , keys [ ] [ ] byte , values [ ] [ ] byte , indices [ ] uint16 , bucket * bucket , ri uint16 , r uint64 ) bool { duplicate := make ( map [ uint64 ] bool ) hashes := make ( [ ] uint64 , len ( bucket . keys ) ) for i , k := range bucket . keys { h := hasher . Table ( r , k ) hashes [ i ] = h if seen [ h ] { return false } if duplicate [ h ] { return false } duplicate [ h ] = true } for _ , h := range hashes { seen [ h ] = true } indices [ bucket . index ] = ri for i , h := range hashes { keys [ h ] = bucket . keys [ i ] values [ h ] = bucket . values [ i ] } return true }
7655	func ( h * chdHasher ) HashIndexFromKey ( b [ ] byte ) uint64 { return ( hasher ( b ) ^ h . r [ 0 ] ) % h . buckets }
7656	func ( b * sliceReader ) ReadInt ( ) uint64 { return uint64 ( binary . LittleEndian . Uint32 ( b . Read ( 4 ) ) ) }
7657	func Read ( r io . Reader ) ( * CHD , error ) { b , err := ioutil . ReadAll ( r ) if err != nil { return nil , err } return Mmap ( b ) }
7658	func ( c * CHD ) Get ( key [ ] byte ) [ ] byte { r0 := c . r [ 0 ] h := hasher ( key ) ^ r0 i := h % uint64 ( len ( c . indices ) ) ri := c . indices [ i ] if ri >= uint16 ( len ( c . r ) ) { return nil } r := c . r [ ri ] ti := ( h ^ r ) % uint64 ( len ( c . keys ) ) k := c . keys [ ti ] if bytes . Compare ( k , key ) != 0 { return nil } v := c . values [ ti ] return v }
7659	func ( c * CHD ) Iterate ( ) * Iterator { if len ( c . keys ) == 0 { return nil } return & Iterator { c : c } }
7660	func ( c * CHD ) Write ( w io . Writer ) error { write := func ( nd ... interface { } ) error { for _ , d := range nd { if err := binary . Write ( w , binary . LittleEndian , d ) ; err != nil { return err } } return nil } data := [ ] interface { } { uint32 ( len ( c . r ) ) , c . r , uint32 ( len ( c . indices ) ) , c . indices , uint32 ( len ( c . keys ) ) , } if err := write ( data ... ) ; err != nil { return err } for i := range c . keys { k , v := c . keys [ i ] , c . values [ i ] if err := write ( uint32 ( len ( k ) ) , uint32 ( len ( v ) ) ) ; err != nil { return err } if _ , err := w . Write ( k ) ; err != nil { return err } if _ , err := w . Write ( v ) ; err != nil { return err } } return nil }
7661	func RegisterDatasources ( path string ) error { cs := C . CString ( path ) defer C . free ( unsafe . Pointer ( cs ) ) if C . mapnik_register_datasources ( cs ) == 0 { e := C . GoString ( C . mapnik_register_last_error ( ) ) if e != "" { return errors . New ( "registering datasources: " + e ) } return errors . New ( "error while registering datasources" ) } return nil }
7662	func RegisterFonts ( path string ) error { cs := C . CString ( path ) defer C . free ( unsafe . Pointer ( cs ) ) if C . mapnik_register_fonts ( cs ) == 0 { e := C . GoString ( C . mapnik_register_last_error ( ) ) if e != "" { return errors . New ( "registering fonts: " + e ) } return errors . New ( "error while registering fonts" ) } return nil }
7663	func New ( ) * Map { return & Map { m : C . mapnik_map ( C . uint ( 800 ) , C . uint ( 600 ) ) , width : 800 , height : 600 , } }
7664	func NewSized ( width , height int ) * Map { return & Map { m : C . mapnik_map ( C . uint ( width ) , C . uint ( height ) ) , width : width , height : height , } }
7665	func ( m * Map ) Load ( stylesheet string ) error { cs := C . CString ( stylesheet ) defer C . free ( unsafe . Pointer ( cs ) ) if C . mapnik_map_load ( m . m , cs ) != 0 { return m . lastError ( ) } return nil }
7666	func ( m * Map ) Resize ( width , height int ) { C . mapnik_map_resize ( m . m , C . uint ( width ) , C . uint ( height ) ) m . width = width m . height = height }
7667	func ( m * Map ) Free ( ) { C . mapnik_map_free ( m . m ) m . m = nil }
7668	func ( m * Map ) SRS ( ) string { return C . GoString ( C . mapnik_map_get_srs ( m . m ) ) }
7669	func ( m * Map ) ZoomAll ( ) error { if C . mapnik_map_zoom_all ( m . m ) != 0 { return m . lastError ( ) } return nil }
7670	func ( m * Map ) ZoomTo ( minx , miny , maxx , maxy float64 ) { bbox := C . mapnik_bbox ( C . double ( minx ) , C . double ( miny ) , C . double ( maxx ) , C . double ( maxy ) ) defer C . mapnik_bbox_free ( bbox ) C . mapnik_map_zoom_to_box ( m . m , bbox ) }
7671	func ( m * Map ) Render ( opts RenderOpts ) ( [ ] byte , error ) { scaleFactor := opts . ScaleFactor if scaleFactor == 0.0 { scaleFactor = 1.0 } i := C . mapnik_map_render_to_image ( m . m , C . double ( opts . Scale ) , C . double ( scaleFactor ) ) if i == nil { return nil , m . lastError ( ) } defer C . mapnik_image_free ( i ) if opts . Format == "raw" { size := 0 raw := C . mapnik_image_to_raw ( i , ( * C . size_t ) ( unsafe . Pointer ( & size ) ) ) return C . GoBytes ( unsafe . Pointer ( raw ) , C . int ( size ) ) , nil } var format * C . char if opts . Format != "" { format = C . CString ( opts . Format ) } else { format = C . CString ( "png256" ) } b := C . mapnik_image_to_blob ( i , format ) if b == nil { return nil , errors . New ( "mapnik: " + C . GoString ( C . mapnik_image_last_error ( i ) ) ) } C . free ( unsafe . Pointer ( format ) ) defer C . mapnik_image_blob_free ( b ) return C . GoBytes ( unsafe . Pointer ( b . ptr ) , C . int ( b . len ) ) , nil }
7672	func ( m * Map ) RenderImage ( opts RenderOpts ) ( * image . NRGBA , error ) { scaleFactor := opts . ScaleFactor if scaleFactor == 0.0 { scaleFactor = 1.0 } i := C . mapnik_map_render_to_image ( m . m , C . double ( opts . Scale ) , C . double ( scaleFactor ) ) if i == nil { return nil , m . lastError ( ) } defer C . mapnik_image_free ( i ) size := 0 raw := C . mapnik_image_to_raw ( i , ( * C . size_t ) ( unsafe . Pointer ( & size ) ) ) b := C . GoBytes ( unsafe . Pointer ( raw ) , C . int ( size ) ) img := & image . NRGBA { Pix : b , Stride : int ( m . width * 4 ) , Rect : image . Rect ( 0 , 0 , int ( m . width ) , int ( m . height ) ) , } return img , nil }
7673	func ( m * Map ) RenderToFile ( opts RenderOpts , path string ) error { scaleFactor := opts . ScaleFactor if scaleFactor == 0.0 { scaleFactor = 1.0 } cs := C . CString ( path ) defer C . free ( unsafe . Pointer ( cs ) ) var format * C . char if opts . Format != "" { format = C . CString ( opts . Format ) } else { format = C . CString ( "png256" ) } defer C . free ( unsafe . Pointer ( format ) ) if C . mapnik_map_render_to_file ( m . m , cs , C . double ( opts . Scale ) , C . double ( scaleFactor ) , format ) != 0 { return m . lastError ( ) } return nil }
7674	func ( m * Map ) SetBufferSize ( s int ) { C . mapnik_map_set_buffer_size ( m . m , C . int ( s ) ) }
7675	func Search ( st string , mx time . Duration ) ( [ ] SearchResponse , error ) { conn , err := listenForSearchResponses ( ) if err != nil { return nil , err } defer conn . Close ( ) searchBytes , broadcastAddr := buildSearchRequest ( st , mx ) _ , err = conn . WriteTo ( searchBytes , broadcastAddr ) if err != nil { return nil , err } return readSearchResponses ( conn , mx ) }
7676	func ( p * blockingPool ) Get ( ) ( net . Conn , error ) { conns := p . conns if conns == nil { return nil , ErrClosed } select { case conn := <- conns : if time . Since ( conn . start ) > p . livetime { if conn . Conn != nil { conn . Conn . Close ( ) conn . Conn = nil } } if conn . Conn == nil { var err error conn . Conn , err = p . factory ( ) if err != nil { conn . start = time . Now ( ) p . put ( conn ) return nil , err } } conn . unusable = false return conn , nil case <- time . After ( time . Second * p . timeout ) : return nil , ErrTimeout } }
7677	func ( p * blockingPool ) put ( conn * WrappedConn ) error { conns := p . conns if conns == nil { if conn . Conn != nil { conn . Conn . Close ( ) conn . Conn = nil } return ErrClosed } if conn . unusable { if conn . Conn != nil { conn . Conn . Close ( ) conn . Conn = nil } } conns <- conn return nil }
7678	func MonoToStereoF32 ( buf * audio . Float32Buffer ) error { if buf == nil || buf . Format == nil || buf . Format . NumChannels != 1 { return audio . ErrInvalidBuffer } stereoData := make ( [ ] float32 , len ( buf . Data ) * 2 ) var j int for i := 0 ; i < len ( buf . Data ) ; i ++ { stereoData [ j ] = buf . Data [ i ] j ++ stereoData [ j ] = buf . Data [ i ] j ++ } buf . Data = stereoData buf . Format . NumChannels = 2 return nil }
7679	func BitCrush ( buf * audio . FloatBuffer , factor float64 ) { stepSize := crusherStepSize * factor for i := 0 ; i < len ( buf . Data ) ; i ++ { frac , exp := math . Frexp ( buf . Data [ i ] ) frac = signum ( frac ) * math . Floor ( math . Abs ( frac ) / stepSize + 0.5 ) * stepSize buf . Data [ i ] = math . Ldexp ( frac , exp ) } }
7680	func NormalizeMax ( buf * audio . FloatBuffer ) { if buf == nil { return } max := 0.0 for i := 0 ; i < len ( buf . Data ) ; i ++ { if math . Abs ( buf . Data [ i ] ) > max { max = math . Abs ( buf . Data [ i ] ) } } if max != 0.0 { for i := 0 ; i < len ( buf . Data ) ; i ++ { buf . Data [ i ] /= max } } }
7681	func Gain ( buf * audio . FloatBuffer , multiplier float64 ) error { if buf == nil { return audio . ErrInvalidBuffer } for i := 0 ; i < len ( buf . Data ) ; i ++ { buf . Data [ i ] *= multiplier } return nil }
7682	func MonoDownmix ( buf * audio . FloatBuffer ) error { if buf == nil || buf . Format == nil { return audio . ErrInvalidBuffer } nChans := buf . Format . NumChannels if nChans < 2 { return nil } nChansF := float64 ( nChans ) frameCount := buf . NumFrames ( ) newData := make ( [ ] float64 , frameCount ) for i := 0 ; i < frameCount ; i ++ { newData [ i ] = 0 for j := 0 ; j < nChans ; j ++ { newData [ i ] += buf . Data [ i * nChans + j ] } newData [ i ] /= nChansF } buf . Data = newData buf . Format . NumChannels = 1 return nil }
7683	func Quantize ( buf * audio . FloatBuffer , bitDepth int ) { if buf == nil { return } max := math . Pow ( 2 , float64 ( bitDepth ) ) - 1 bufLen := len ( buf . Data ) for i := 0 ; i < bufLen ; i ++ { buf . Data [ i ] = round ( ( buf . Data [ i ] + 1 ) * max ) / max - 1.0 } }
7684	func PCMScale ( buf * audio . FloatBuffer , bitDepth int ) error { if buf == nil || buf . Format == nil { return audio . ErrInvalidBuffer } factor := math . Pow ( 2 , 8 * float64 ( bitDepth / 8 ) - 1 ) for i := 0 ; i < len ( buf . Data ) ; i ++ { buf . Data [ i ] *= factor } return nil }
7685	func StereoPan ( buf * audio . FloatBuffer , pan float64 ) error { if buf == nil || buf . Format == nil || buf . Format . NumChannels != 2 { return audio . ErrInvalidBuffer } if pan < 0 || pan > 1 { return errors . New ( "invalid pan value, should be betwen 0 and 1" ) } if pan == 0.5 { return nil } if pan < 0.5 { for i := 0 ; i + 2 <= len ( buf . Data ) ; i += 2 { buf . Data [ i + 1 ] *= ( pan * 2 ) } } else { for i := 0 ; i + 2 <= len ( buf . Data ) ; i += 2 { buf . Data [ i ] *= ( ( 1 - pan ) * 2 ) } } return nil }
7686	func ( f * Follower ) Leader ( ) string { f . lock . Lock ( ) defer f . lock . Unlock ( ) return f . leader }
7687	func ( c * Candidate ) IsLeader ( ) bool { c . lock . Lock ( ) defer c . lock . Unlock ( ) return c . leader }
7688	func NewResponse ( clientID , redirectURI , userID , exp , code string ) Response { return Response { ClientID : clientID , RedirectURI : redirectURI , UserID : userID , Exp : exp , Code : code } }
7689	func GetRequestID ( ctx context . Context ) ( string , error ) { if ctx == nil { return "" , errors . New ( "nil context" ) } reqID , ok := ctx . Value ( contextRequestID ) . ( string ) if ! ok { return "" , errors . New ( "unexpected type" ) } if len ( reqID ) == 0 { return "" , errors . New ( "empty value in context" ) } return reqID , nil }
7690	func ( m * monitorableWriter ) Log ( ) { duration := time . Now ( ) . Sub ( m . t0 ) if m . Code == 0 { m . Code = 200 } if m . opts . Filter != nil && ! m . opts . Filter ( m . r , m . Code , duration , m . Size ) { return } cc := m . colorCode ( ) size := "" if m . Size > 0 { size = sizestr . ToString ( m . Size ) } buff := bytes . Buffer { } m . opts . formatTmpl . Execute ( & buff , & struct { * Colors Timestamp , Method , Path , CodeColor string Code int Duration , Size , IP string } { m . opts . Colors , m . t0 . Format ( m . opts . TimeFormat ) , m . method , m . path , cc , m . Code , fmtDuration ( duration ) , size , m . ip , } ) fmt . Fprint ( m . opts . Writer , buff . String ( ) ) }
7691	func SendMailSSL ( addr string , a smtp . Auth , from string , to [ ] string , msg [ ] byte ) error { conn , err := tls . Dial ( "tcp" , addr , & tls . Config { InsecureSkipVerify : true } ) if err != nil { log . Println ( "Error Dialing" , err ) return err } h , _ , _ := net . SplitHostPort ( addr ) c , err := smtp . NewClient ( conn , h ) if err != nil { log . Println ( "Error SMTP connection" , err ) return err } defer c . Close ( ) if a != nil { if ok , _ := c . Extension ( "AUTH" ) ; ok { if err = c . Auth ( a ) ; err != nil { log . Printf ( "Authentication error: %v" , err ) return err } } } if err = c . Mail ( from ) ; err != nil { log . Printf ( "From error: %v" , err ) return err } for _ , addr := range to { if err = c . Rcpt ( addr ) ; err != nil { log . Printf ( "Recipient error: %v" , err ) return err } } w , err := c . Data ( ) if err != nil { return err } w . Write ( msg ) w . Close ( ) return c . Quit ( ) }
7692	func ( m * MailService ) Send ( message string , subject string , from string , to string ) ( err error ) { t := [ ] string { to } msg := [ ] byte ( "From: " + from + "\r\n" + \r + \n + "To: " + to + "\r\n" + \r + \n + "Subject: " + subject ) "\r\n" \r }
7693	func WaitForIt ( fullConn , host string , port , timeout int ) error { conn := buildConn ( host , port , fullConn ) if conn == nil { return errors . New ( "Invalid connection" ) } log . Debug ( "Waiting " + strconv . Itoa ( timeout ) + " seconds" ) if err := pingTCP ( conn , timeout ) ; err != nil { return err } if conn . Scheme != "http" && conn . Scheme != "https" { return nil } if err := pingHTTP ( conn , timeout ) ; err != nil { return err } return nil }
7694	func Get ( source interface { } , environment string , configEnv Environment ) ( conf interface { } , err error ) { if filename , ok := source . ( string ) ; ok { source , err = ioutil . ReadFile ( filename ) if err != nil { log . Printf ( "Fatal: %v" , err ) return } } err = yaml . Unmarshal ( source . ( [ ] byte ) , configEnv ) if err != nil { log . Printf ( "Fatal: bad config : %v" , err ) return } conf = configEnv . GetEnvironment ( environment ) if conf == nil { err = errors . New ( "No configuration" ) return } return }
7695	func initConfig ( ) { if cfgFile != "" { Viper . SetConfigFile ( cfgFile ) } Viper . SetConfigName ( "config" ) Viper . AddConfigPath ( "$HOME" ) Viper . AddConfigPath ( "./" ) Viper . AutomaticEnv ( ) if err := Viper . ReadInConfig ( ) ; err == nil { fmt . Println ( "Using config file:" , Viper . ConfigFileUsed ( ) ) } }
7696	func WritePluginResultsToDatabase ( results map [ string ] interface { } ) { session , err := r . Connect ( r . ConnectOpts { Address : fmt . Sprintf ( "%s:28015" , utils . Getopt ( "MALICE_RETHINKDB" , "rethink" ) ) , Timeout : 5 * time . Second , Database : "malice" , } ) if err != nil { log . Debug ( err ) return } defer session . Close ( ) res , err := r . Table ( "samples" ) . Get ( results [ "ID" ] ) . Run ( session ) utils . Assert ( err ) defer res . Close ( ) if res . IsNil ( ) { resp , err := r . Table ( "samples" ) . Insert ( results , r . InsertOpts { Conflict : "replace" } ) . RunWrite ( session ) utils . Assert ( err ) log . Debug ( resp ) } else { resp , err := r . Table ( "samples" ) . Get ( results [ "ID" ] ) . Update ( map [ string ] interface { } { "plugins" : map [ string ] interface { } { category : map [ string ] interface { } { name : results [ "Data" ] , } , } , } ) . RunWrite ( session ) utils . Assert ( err ) log . Debug ( resp ) } }
7697	func NewAuthController ( um UserManager , cnf web . Config ) * AuthController { authController := AuthController { UserManager : um , cnf : cnf } return & authController }
7698	func ( c * AuthController ) Authenticate ( w http . ResponseWriter , r * http . Request ) { decoder := json . NewDecoder ( r . Body ) var user User var data map [ string ] string err := decoder . Decode ( & user ) if err != nil { http . Error ( w , fmt . Sprintf ( "%v" , err ) , 400 ) return } user , _ = c . UserManager . Get ( user . Username , user . Password ) if user . Username != "" { token := jwt . New ( jwt . GetSigningMethod ( "HS256" ) ) claims := token . Claims . ( jwt . MapClaims ) claims [ "username" ] = user . Username claims [ "email" ] = user . Email claims [ "exp" ] = time . Now ( ) . Add ( time . Minute * 10 ) . Unix ( ) tokenString , _ := token . SignedString ( [ ] byte ( c . cnf . Jwt . Key ) ) data = map [ string ] string { "id_token" : tokenString , } } js , _ := json . Marshal ( data ) w . Write ( js ) }
7699	func NewOAuth2Controller ( am ApplicationManager , cnf web . Config ) * OAuth2Controller { oAuth2Controller := OAuth2Controller { cnf : cnf , ApplicationManager : am } return & oAuth2Controller }
7700	func ( c * OAuth2Controller ) Refresh ( w http . ResponseWriter , r * http . Request ) { grantType := r . URL . Query ( ) . Get ( "grant_type" ) refreshToken := r . URL . Query ( ) . Get ( "refresh_token" ) if strings . Compare ( grantType , "refresh_token" ) != 0 { http . Error ( w , errors . New ( "Parameter grant_type is required" ) . Error ( ) , http . StatusBadRequest ) return } if strings . Compare ( refreshToken , "" ) == 0 { http . Error ( w , errors . New ( "Parameter refreshToken is required" ) . Error ( ) , http . StatusBadRequest ) return } token , err := jwt . Parse ( refreshToken , func ( token * jwt . Token ) ( interface { } , error ) { if _ , ok := token . Method . ( * jwt . SigningMethodHMAC ) ; ! ok { return nil , fmt . Errorf ( "Unexpected signing method: %v" , token . Header [ "alg" ] ) } return [ ] byte ( c . cnf . Jwt . Key ) , nil } ) if err == nil && token . Valid { token := jwt . New ( jwt . GetSigningMethod ( "HS256" ) ) claims := token . Claims . ( jwt . MapClaims ) claims [ "exp" ] = time . Now ( ) . Add ( time . Hour * 1 ) . Unix ( ) tokenString , _ := token . SignedString ( [ ] byte ( c . cnf . Jwt . Key ) ) data := map [ string ] string { "access_token" : tokenString , "token_type" : "bearer" , "expires_in" : "3600" , } js , _ := json . Marshal ( data ) w . Write ( js ) } }
7701	func ( c * OAuth2Controller ) Token ( w http . ResponseWriter , r * http . Request ) { grantType := r . URL . Query ( ) . Get ( "grant_type" ) code := r . URL . Query ( ) . Get ( "code" ) if strings . Compare ( grantType , "authorization_code" ) != 0 { http . Error ( w , errors . New ( "Parameter grant_type is required" ) . Error ( ) , http . StatusBadRequest ) return } if strings . Compare ( code , "" ) == 0 { http . Error ( w , errors . New ( "Parameter code is required" ) . Error ( ) , http . StatusBadRequest ) return } response , err := DecodeOAuth2Code ( code , c . cnf . Jwt . Key ) if err != nil { http . Error ( w , err . Error ( ) , http . StatusBadRequest ) return } i , err := strconv . ParseInt ( response . Exp , 10 , 64 ) exp := time . Unix ( i , 0 ) if exp . After ( time . Now ( ) ) { log . Printf ( "Code is expired" ) } else { token := jwt . New ( jwt . GetSigningMethod ( "HS256" ) ) claims := token . Claims . ( jwt . MapClaims ) claims [ "exp" ] = time . Now ( ) . Add ( time . Hour * 1 ) . Unix ( ) tokenString , _ := token . SignedString ( [ ] byte ( c . cnf . Jwt . Key ) ) refreshToken := jwt . New ( jwt . GetSigningMethod ( "HS256" ) ) refreshClaims := refreshToken . Claims . ( jwt . MapClaims ) refreshClaims [ "exp" ] = 0 refreshTokenString , _ := refreshToken . SignedString ( [ ] byte ( c . cnf . Jwt . Key ) ) data := map [ string ] string { "access_token" : tokenString , "token_type" : "bearer" , "refresh_token" : refreshTokenString , "expires_in" : "3600" , } js , _ := json . Marshal ( data ) w . Write ( js ) } }
7702	func Logging ( next http . Handler , log * logrus . Logger ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { srw := StatusResponseWriter { w , 0 , 0 } start := time . Now ( ) next . ServeHTTP ( & srw , r ) end := time . Now ( ) latency := end . Sub ( start ) log . WithField ( "client" , r . RemoteAddr ) . WithField ( "latency" , latency ) . WithField ( "length" , srw . Length ( ) ) . WithField ( "code" , srw . Status ( ) ) . Printf ( "%s %s %s" , r . Method , r . URL , r . Proto ) } ) }
7703	func SingleFile ( filename string ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { http . ServeFile ( w , r , filename ) } ) }
7704	func ( w * StatusResponseWriter ) Write ( data [ ] byte ) ( int , error ) { w . length = len ( data ) return w . ResponseWriter . Write ( data ) }
7705	func ( w * StatusResponseWriter ) Hijack ( ) ( net . Conn , * bufio . ReadWriter , error ) { if hj , ok := w . ResponseWriter . ( http . Hijacker ) ; ok { return hj . Hijack ( ) } return nil , nil , errors . New ( "Not a Hijacker" ) }
7706	func NewMongo ( filename string , environment string ) ( * Mongo , error ) { ctx := context . Background ( ) cnf , err := GetMongo ( filename , environment ) if err != nil { return nil , err } var uri string if len ( cnf . Username ) > 0 && len ( cnf . Password ) > 0 { uri = fmt . Sprintf ( `mongodb://%s:%s@%s:%d/%s` , cnf . Username , cnf . Password , cnf . Host , cnf . Port , cnf . Database , ) } else { uri = fmt . Sprintf ( `mongodb://%s:%d/%s` , cnf . Host , cnf . Port , cnf . Database , ) } client , err := mongo . NewClient ( uri ) if err != nil { log . Printf ( "L'URI du serveur MongoDB est incorrect: %s" , uri ) return nil , err } err = client . Connect ( ctx ) if err != nil { log . Print ( "Impossible d'utiliser ce context" ) return nil , err } db := client . Database ( cnf . Database ) err = client . Ping ( ctx , nil ) if err != nil { log . Printf ( "Impossible de contacter %v sur le port %d" , cnf . Host , cnf . Port ) return nil , err } return & Mongo { Client : client , Database : db , context : ctx } , nil }
7707	func ( m * Mongo ) Disconnect ( ) error { err := m . Client . Disconnect ( m . context ) if err != nil { log . Printf ( "Impossible de fermer la connexion" ) return err } return nil }
7708	func New ( fields [ ] string ) * Table { return & Table { Fields : fields , Rows : make ( [ ] map [ string ] string , 0 ) , fieldSizes : make ( map [ string ] int ) , } }
7709	func PrintTable ( fields [ ] string , rows [ ] map [ string ] interface { } ) { table := New ( fields ) for _ , r := range rows { table . AddRow ( r ) } table . Print ( ) }
7710	func PrintHorizontal ( m map [ string ] interface { } ) { table := New ( [ ] string { "Key" , "Value" } ) rows := mapToRows ( m ) for _ , row := range rows { table . AddRow ( row ) } table . HideHead = true table . Print ( ) }
7711	func PrintRow ( fields [ ] string , row map [ string ] interface { } ) { table := New ( fields ) table . AddRow ( row ) table . Print ( ) }
7712	func ( t * Table ) AddRow ( row map [ string ] interface { } ) { newRow := make ( map [ string ] string ) for _ , k := range t . Fields { v := row [ k ] var val string if v == nil { val = "" } else { val = fmt . Sprintf ( "%v" , v ) } newRow [ k ] = val } t . calculateSizes ( newRow ) if len ( newRow ) > 0 { t . Rows = append ( t . Rows , newRow ) } }
7713	func ( t * Table ) Print ( ) { if len ( t . Rows ) == 0 && t . Footer == nil { return } t . calculateSizes ( t . Footer ) if ! t . Markdown { t . printDash ( ) } if ! t . HideHead { fmt . Println ( t . getHead ( ) ) t . printTableDash ( ) } for _ , r := range t . Rows { fmt . Println ( t . rowString ( r ) ) if ! t . Markdown { t . printDash ( ) } } if t . Footer != nil { t . printTableDash ( ) fmt . Println ( t . rowString ( t . Footer ) ) if ! t . Markdown { t . printTableDash ( ) } } }
7714	func ( t * Table ) String ( title string ) string { tableString := [ ] string { } if len ( t . Rows ) == 0 && t . Footer == nil { return "" } tableString = append ( tableString , "### " + title ) t . calculateSizes ( t . Footer ) if ! t . Markdown { tableString = append ( tableString , t . stringDash ( ) ) } if ! t . HideHead { tableString = append ( tableString , t . getHead ( ) ) tableString = append ( tableString , t . stringTableDash ( ) ) } for _ , r := range t . Rows { tableString = append ( tableString , t . rowString ( r ) ) if ! t . Markdown { tableString = append ( tableString , t . stringDash ( ) ) } } if t . Footer != nil { tableString = append ( tableString , t . stringTableDash ( ) ) tableString = append ( tableString , t . rowString ( t . Footer ) ) if ! t . Markdown { tableString = append ( tableString , t . stringDash ( ) ) } } return strings . Join ( tableString [ : ] , "\n" ) }
7715	func ( t * Table ) getHead ( ) string { s := "|" for _ , name := range t . Fields { s += t . fieldString ( name , strings . Title ( name ) ) + "|" } return s }
7716	func ( t * Table ) rowString ( row map [ string ] string ) string { s := "|" for _ , name := range t . Fields { value := row [ name ] s += t . fieldString ( name , value ) + "|" } return s }
7717	func ( t * Table ) fieldString ( name , value string ) string { value = fmt . Sprintf ( " %s " , value ) spacesLeft := t . fieldSizes [ name ] - runewidth . StringWidth ( value ) if spacesLeft > 0 { for i := 0 ; i < spacesLeft ; i ++ { value += " " } } return value }
7718	func ( t * Table ) stringTableDash ( ) string { if t . Markdown { return t . stringMarkdownDash ( ) } return t . stringDash ( ) }
7719	func ( t * Table ) printMarkdownDash ( ) { r := make ( map [ string ] string ) for _ , name := range t . Fields { r [ name ] = strings . Repeat ( "-" , t . fieldSizes [ name ] - 2 ) } fmt . Println ( t . rowString ( r ) ) }
7720	func ( t * Table ) stringMarkdownDash ( ) string { r := make ( map [ string ] string ) for _ , name := range t . Fields { r [ name ] = strings . Repeat ( "-" , t . fieldSizes [ name ] - 2 ) } return t . rowString ( r ) }
7721	func HashPassword ( password [ ] byte , salt [ ] byte ) ( hash [ ] byte , err error ) { hash , err = scrypt . Key ( password , salt , N , R , P , KEYLENGTH ) if err != nil { return nil , err } return }
7722	func EncodeOAuth2Code ( clientID , redirectURI , userID , sharedKey string ) ( code string , err error ) { rand := RandStringBytesMaskImprSrc ( 20 ) exp := time . Now ( ) . Add ( time . Minute * 10 ) . String ( ) response := NewResponse ( clientID , redirectURI , userID , exp , rand ) jresponse , err := json . Marshal ( response ) if err != nil { log . Printf ( "Error: %v" , err ) } j64response := base64 . StdEncoding . EncodeToString ( jresponse ) signer , err := jose . NewSigner ( jose . SigningKey { Algorithm : jose . HS512 , Key : [ ] byte ( sharedKey ) } , nil ) if err != nil { log . Printf ( "Error: %v" , err ) } object , err := signer . Sign ( [ ] byte ( j64response ) ) if err != nil { log . Printf ( "Error: %v" , err ) } code , err = object . CompactSerialize ( ) return }
7723	func DecodeOAuth2Code ( code , sharedKey string ) ( response Response , err error ) { object , err := jose . ParseSigned ( code ) if err != nil { return } output , err := object . Verify ( [ ] byte ( sharedKey ) ) if err != nil { return } base64Text := make ( [ ] byte , base64 . StdEncoding . DecodedLen ( len ( output ) ) ) l , err := base64 . StdEncoding . Decode ( base64Text , output ) if err != nil { return } response = Response { } err = json . Unmarshal ( base64Text [ : l ] , & response ) return }
7724	func NewServer ( filename string , environment string ) ( server * Server , err error ) { conf , err := GetConfig ( filename , environment ) logFile , err := os . OpenFile ( conf . Log . File + logFilename , os . O_WRONLY | os . O_CREATE | os . O_APPEND , 0666 ) if err != nil { log . SetOutput ( os . Stderr ) log . Warningf ( "Can't open logfile: %v" , err ) } else { log . SetOutput ( logFile ) } level := log . ErrorLevel if strings . Compare ( conf . Log . Level , "" ) != 0 { level , _ = log . ParseLevel ( conf . Log . Level ) } else { log . Infof ( "Log Level: %v" , level ) } log . SetLevel ( level ) server = & Server { Config : conf , Done : make ( chan bool , 1 ) , Error : make ( chan error , 1 ) , Server : http . Server { Handler : NewLoggingServeMux ( conf ) } , quit : make ( chan bool ) , isStarted : false } return }
7725	func ( s * Server ) Start ( ) ( err error ) { log . Infof ( "Lunarc is starting on port :%d" , s . Config . Port ) var l net . Listener go func ( ) { l , err = net . Listen ( "tcp" , fmt . Sprintf ( ":%d" , s . Config . Port ) ) if err != nil { log . Errorf ( "Error: %v" , err ) s . Error <- err return } s . isStarted = true if len ( s . Config . SSL . Certificate ) > 0 && len ( s . Config . SSL . Key ) > 0 { err = s . ServeTLS ( l , s . Config . SSL . Certificate , s . Config . SSL . Key ) if err != nil && err != http . ErrServerClosed { log . Errorf ( "%v" , err ) l . Close ( ) s . Error <- err s . quit <- true } close ( s . quit ) } else { err = s . Serve ( l ) if err != nil && err != http . ErrServerClosed { log . Errorf ( "%v" , err ) s . Error <- err s . quit <- true } close ( s . quit ) } } ( ) <- s . quit if err = s . Shutdown ( context . Background ( ) ) ; err != nil { log . Errorf ( "%v" , err ) s . Error <- err } <- s . quit l = nil log . Info ( "Lunarc terminated." ) s . isStarted = false s . Done <- true return }
7726	func ( s * Server ) Stop ( ) { if s . isStarted && s . quit != nil { log . Info ( "Lunarc is stopping..." ) s . quit <- true } else { log . Info ( "Lunarc is not running" ) s . Error <- errors . New ( "Lunarc is not running" ) s . Done <- false } }
7727	func NewLoggingServeMux ( conf Config ) * LoggingServeMux { serveMux := http . NewServeMux ( ) return & LoggingServeMux { serveMux , conf } }
7728	func ( mux * LoggingServeMux ) Handler ( r * http . Request ) ( h http . Handler , pattern string ) { return mux . serveMux . Handler ( r ) }
7729	func ( mux * LoggingServeMux ) Handle ( pattern string , handler http . Handler ) { var log = logrus . New ( ) logFile , err := os . OpenFile ( mux . conf . Log . File + aFilename , os . O_WRONLY | os . O_CREATE | os . O_APPEND , 0666 ) if err != nil { log . Out = os . Stderr log . Warningf ( "Can't open logfile: %v" , err ) } else { log . Out = logFile } mux . serveMux . Handle ( pattern , Logging ( handler , log ) ) }
7730	func ( mux * LoggingServeMux ) HandleFunc ( pattern string , handler func ( http . ResponseWriter , * http . Request ) ) { mux . serveMux . Handle ( pattern , http . HandlerFunc ( handler ) ) }
7731	func ( db * Database ) Init ( ) error { db . getURL ( ) err := db . TestConnection ( ) if err != nil { return errors . Wrap ( err , "failed to connect to database" ) } client , err := elastic . NewSimpleClient ( elastic . SetURL ( db . URL ) , elastic . SetBasicAuth ( utils . Getopts ( db . Username , "MALICE_ELASTICSEARCH_USERNAME" , "" ) , utils . Getopts ( db . Password , "MALICE_ELASTICSEARCH_PASSWORD" , "" ) , ) , ) if err != nil { return errors . Wrap ( err , "failed to create elasticsearch simple client" ) } exists , err := client . IndexExists ( db . Index ) . Do ( context . Background ( ) ) if err != nil { return errors . Wrap ( err , "failed to check if index exists" ) } if ! exists { createIndex , err := client . CreateIndex ( db . Index ) . BodyString ( mapping ) . Do ( context . Background ( ) ) if err != nil { return errors . Wrapf ( err , "failed to create index: %s" , db . Index ) } if ! createIndex . Acknowledged { log . Error ( "index creation not acknowledged" ) } else { log . Debugf ( "created index %s" , db . Index ) } } else { log . Debugf ( "index %s already exists" , db . Index ) } return nil }
7732	func ( db * Database ) WaitForConnection ( ctx context . Context , timeout int ) error { var err error secondsWaited := 0 connCtx , cancel := context . WithTimeout ( ctx , time . Duration ( timeout ) * time . Second ) defer cancel ( ) log . Debug ( "===> trying to connect to elasticsearch" ) for { select { case <- connCtx . Done ( ) : return errors . Wrapf ( err , "connecting to elasticsearch timed out after %d seconds" , secondsWaited ) default : err = db . TestConnection ( ) if err == nil { log . Debugf ( "elasticsearch came online after %d seconds" , secondsWaited ) return nil } secondsWaited ++ log . Debug ( " * could not connect to elasticsearch (sleeping for 1 second)" ) time . Sleep ( 1 * time . Second ) } } }
7733	func ( db * Database ) StoreFileInfo ( sample map [ string ] interface { } ) ( elastic . IndexResponse , error ) { if len ( db . Plugins ) == 0 { return elastic . IndexResponse { } , errors . New ( "Database.Plugins is empty (you must set this field to use this function)" ) } err := db . TestConnection ( ) if err != nil { return elastic . IndexResponse { } , errors . Wrap ( err , "failed to connect to database" ) } client , err := elastic . NewSimpleClient ( elastic . SetURL ( db . URL ) , elastic . SetBasicAuth ( utils . Getopts ( db . Username , "MALICE_ELASTICSEARCH_USERNAME" , "" ) , utils . Getopts ( db . Password , "MALICE_ELASTICSEARCH_PASSWORD" , "" ) , ) , ) if err != nil { return elastic . IndexResponse { } , errors . Wrap ( err , "failed to create elasticsearch simple client" ) } fInfo := map [ string ] interface { } { "file" : sample , "plugins" : db . Plugins , "scan_date" : time . Now ( ) . Format ( time . RFC3339Nano ) , } newScan , err := client . Index ( ) . Index ( db . Index ) . Type ( db . Type ) . OpType ( "index" ) . BodyJson ( fInfo ) . Do ( context . Background ( ) ) if err != nil { return elastic . IndexResponse { } , errors . Wrap ( err , "failed to index file info" ) } log . WithFields ( log . Fields { "id" : newScan . Id , "index" : newScan . Index , "type" : newScan . Type , } ) . Debug ( "indexed sample" ) return * newScan , nil }
7734	func ( db * Database ) StorePluginResults ( results database . PluginResults ) error { err := db . TestConnection ( ) if err != nil { return errors . Wrap ( err , "failed to connect to database" ) } client , err := elastic . NewSimpleClient ( elastic . SetURL ( db . URL ) , elastic . SetBasicAuth ( utils . Getopts ( db . Username , "MALICE_ELASTICSEARCH_USERNAME" , "" ) , utils . Getopts ( db . Password , "MALICE_ELASTICSEARCH_PASSWORD" , "" ) , ) , ) if err != nil { return errors . Wrap ( err , "failed to create elasticsearch simple client" ) } getSample , err := client . Get ( ) . Index ( db . Index ) . Type ( db . Type ) . Id ( results . ID ) . Do ( context . Background ( ) ) if err != nil && ! elastic . IsNotFound ( err ) { return errors . Wrapf ( err , "failed to get sample with id: %s" , results . ID ) } if getSample != nil && getSample . Found { log . Debugf ( "got document %s in version %d from index %s, type %s\n" , \n , getSample . Id , getSample . Version , getSample . Index ) getSample . Type updateScan := map [ string ] interface { } { "scan_date" : time . Now ( ) . Format ( time . RFC3339Nano ) , "plugins" : map [ string ] interface { } { results . Category : map [ string ] interface { } { results . Name : results . Data , } , } , } update , err := client . Update ( ) . Index ( db . Index ) . Type ( db . Type ) . Id ( getSample . Id ) . Doc ( updateScan ) . Do ( context . Background ( ) ) if err != nil { return errors . Wrapf ( err , "failed to update sample with id: %s" , results . ID ) } } else log . Debugf ( "updated version of sample %q is now %d\n" , \n , update . Id ) update . Version }
7735	func CamelCase ( src string ) string { byteSrc := [ ] byte ( src ) chunks := camelingRegex . FindAll ( byteSrc , - 1 ) for idx , val := range chunks { if idx > 0 { chunks [ idx ] = bytes . Title ( val ) } } return string ( bytes . Join ( chunks , nil ) ) }
7736	func Getopt ( name , dfault string ) string { value := os . Getenv ( name ) if value == "" { value = dfault } return value }
7737	func Getopts ( userInput , envVar , dfault string ) string { if len ( strings . TrimSpace ( userInput ) ) > 0 { return userInput } value := os . Getenv ( envVar ) if value == "" { value = dfault } return value }
7738	func GetSHA256 ( name string ) string { dat , err := ioutil . ReadFile ( name ) Assert ( err ) h256 := sha256 . New ( ) _ , err = h256 . Write ( dat ) Assert ( err ) return fmt . Sprintf ( "%x" , h256 . Sum ( nil ) ) }
7739	func RunCommand ( ctx context . Context , cmd string , args ... string ) ( string , error ) { var c * exec . Cmd if ctx != nil { c = exec . CommandContext ( ctx , cmd , args ... ) } else { c = exec . Command ( cmd , args ... ) } output , err := c . Output ( ) if err != nil { return string ( output ) , err } if ctx != nil { if ctx . Err ( ) == context . DeadlineExceeded { return "" , fmt . Errorf ( "command %s timed out" , cmd ) } } return string ( output ) , nil }
7740	func RemoveDuplicates ( elements [ ] string ) [ ] string { encountered := map [ string ] bool { } result := [ ] string { } for v := range elements { if encountered [ elements [ v ] ] == true { } else { encountered [ elements [ v ] ] = true result = append ( result , elements [ v ] ) } } return result }
7741	func Unzip ( archive , target string ) error { reader , err := zip . OpenReader ( archive ) if err != nil { return err } defer reader . Close ( ) for _ , file := range reader . File { filePath := filepath . Join ( target , file . Name ) if file . FileInfo ( ) . IsDir ( ) { os . MkdirAll ( filePath , file . Mode ( ) ) continue } fileReader , err := file . Open ( ) if err != nil { return err } defer fileReader . Close ( ) targetFile , err := os . OpenFile ( filePath , os . O_WRONLY | os . O_CREATE | os . O_TRUNC , file . Mode ( ) ) if err != nil { return err } defer targetFile . Close ( ) if _ , err := io . Copy ( targetFile , fileReader ) ; err != nil { return err } } return nil }
7742	func SliceContainsString ( a string , list [ ] string ) bool { for _ , b := range list { if strings . Contains ( b , a ) { return true } } return false }
7743	func NewSMTP ( filename string , environment string ) ( s * SMTP , err error ) { conf , err := GetSMTP ( filename , environment ) if err != nil { return } auth := smtp . PlainAuth ( "" , conf . Auth . User , conf . Auth . Password , conf . Host ) f := smtp . SendMail if conf . SSL { f = SendMailSSL } s = & SMTP { auth : auth , send : f , addr : fmt . Sprintf ( "%s:%d" , conf . Host , conf . Port ) } return }
7744	func ( s * SMTP ) SendMail ( from string , to [ ] string , msg [ ] byte ) ( err error ) { err = s . send ( s . addr , s . auth , from , to , msg ) return }
7745	func ( se * SMTPEnvironment ) GetEnvironment ( environment string ) interface { } { for env , conf := range se . Env { if strings . Compare ( environment , env ) == 0 { return conf } } return nil }
7746	func GetSMTP ( source interface { } , environment string ) ( smtp Config , err error ) { var smtpEnvironment SMTPEnvironment i , err := config . Get ( source , environment , & smtpEnvironment ) smtp = i . ( Config ) return }
7747	func GetConfig ( source interface { } , environment string ) ( server Config , err error ) { var serverEnvironment ServerEnvironment i , err := config . Get ( source , environment , & serverEnvironment ) server = i . ( Config ) return }
7748	func ( m * Environment ) GetEnvironment ( environment string ) interface { } { for env , conf := range m . Env { if strings . Compare ( environment , env ) == 0 { return conf } } return nil }
7749	func GetMongo ( source interface { } , environment string ) ( mongo Config , err error ) { var env Environment i , err := config . Get ( source , environment , & env ) mongo = i . ( Config ) return }
7750	func TokenHandler ( next http . Handler , cnf web . Config ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { token , err := request . ParseFromRequest ( r , request . AuthorizationHeaderExtractor , func ( token * jwt . Token ) ( interface { } , error ) { if _ , ok := token . Method . ( * jwt . SigningMethodHMAC ) ; ! ok { return nil , fmt . Errorf ( "Unexpected signing method: %v" , token . Header [ "alg" ] ) } return [ ] byte ( cnf . Jwt . Key ) , nil } ) if err == nil && token . Valid { next . ServeHTTP ( w , r ) } else { if r . URL . String ( ) == "/" { next . ServeHTTP ( w , r ) } else { w . WriteHeader ( http . StatusUnauthorized ) } } } ) }
7751	func ( c * Conn ) Receive ( ) ( * InMsg , error ) { stanza , err := c . xmppConn . Recv ( ) if err != nil { return nil , err } if c . debug { log . Printf ( "Incoming raw CCS stanza: %+v\n" , \n ) } stanza chat , ok := stanza . ( xmpp . Chat ) if ! ok { return nil , nil } if chat . Type == "error" { return nil , errors . New ( "CCS returned an XMPP error (can be a stanza or JSON error or anything else)" ) } var m InMsg if err = json . Unmarshal ( [ ] byte ( chat . Other [ 0 ] ) , & m ) ; err != nil { return nil , errors . New ( "unknow message from CCS" ) } switch m . MessageType { case "ack" : return & m , nil case "nack" : return & m , nil case "receipt" : return & m , nil case "control" : return & m , nil case "" : ack := & OutMsg { MessageType : "ack" , To : m . From , ID : m . ID } if _ , err = c . Send ( ack ) ; err != nil { return nil , fmt . Errorf ( "failed to send ack message to CCS with error: %v" , err ) } return & m , nil default : } }
7752	func ( c * Conn ) Send ( m * OutMsg ) ( n int , err error ) { if m . ID == "" { if m . ID , err = getMsgID ( ) ; err != nil { return 0 , err } } mb , err := json . Marshal ( m ) if err != nil { return 0 , err } ms := string ( mb ) res := fmt . Sprintf ( gcmMessageStanza , ms ) return c . xmppConn . SendOrg ( res ) }
7753	func ( d pivnetReleaseDiffer ) allBoshReleaseNames ( ) [ ] string { boshReleaseNamesMap := make ( map [ string ] string ) var addReleaseNames = func ( br map [ string ] * release . BoshRelease ) { for brname := range br { boshReleaseNamesMap [ brname ] = brname } } addReleaseNames ( d . release1 . BoshRelease ) addReleaseNames ( d . release2 . BoshRelease ) var releaseNames [ ] string for brname := range boshReleaseNamesMap { releaseNames = append ( releaseNames , brname ) } return releaseNames }
7754	func ( dj * DeltaJob ) AddedProperty ( name string , p * enaml . JobManifestProperty ) { dj . AddedProperties [ name ] = * p }
7755	func ( dj * DeltaJob ) RemovedProperty ( name string , p * enaml . JobManifestProperty ) { dj . RemovedProperties [ name ] = * p }
7756	func ( r * Result ) AddDeltaJob ( dj * DeltaJob ) { r . DeltaJob = append ( r . DeltaJob , * dj ) }
7757	func ( r * Result ) Concat ( other * Result ) { for _ , dj := range other . DeltaJob { r . DeltaJob = append ( r . DeltaJob , dj ) } }
7758	func ( r * Release ) Read ( releaseLocation string ) ( io . ReadCloser , error ) { local , err := r . Pull ( releaseLocation ) if err != nil { return nil , err } rr , err := os . Open ( local ) if err != nil { return nil , err } return rr , nil }
7759	func ( r * Release ) Pull ( releaseLocation string ) ( filename string , err error ) { u , uerr := url . Parse ( releaseLocation ) if uerr != nil || ! ( u . Scheme == "http" || u . Scheme == "https" ) { if _ , ferr := os . Stat ( releaseLocation ) ; os . IsNotExist ( ferr ) { err = fmt . Errorf ( "Could not pull %s. The file doesn't exist or isn't a valid http(s) URL" , releaseLocation ) return } filename = releaseLocation } else { filename = r . CacheDir + "/" + path . Base ( releaseLocation ) if _ , err = os . Stat ( filename ) ; os . IsNotExist ( err ) { fmt . Println ( "Could not find release in local cache. Downloading now." ) err = r . download ( releaseLocation , filename ) } } return }
7760	func BuildJob ( jobMeta BoshJobMeta , dest string ) error { b , err := json . Marshal ( jobMeta ) if err != nil { return err } fmt . Println ( "building job: " , string ( b ) ) monitFile , specFile , err := createJobFiles ( dest , jobMeta . Name ) if err != nil { return err } defer monitFile . Close ( ) defer specFile . Close ( ) err = writeMonitFile ( monitFile , jobMeta . Name , jobMeta . PIDFile ) if err != nil { return err } err = writeSpecFile ( specFile , jobMeta . Name , jobMeta . JobProperties , jobMeta . Packages ) return err }
7761	func LoadBoshRelease ( releaseRepo pull . Release , path string ) ( release * BoshRelease , err error ) { var rr io . ReadCloser rr , err = releaseRepo . Read ( path ) if err != nil { return } defer func ( ) { if cerr := rr . Close ( ) ; cerr != nil { err = cerr } } ( ) release , err = readBoshRelease ( rr ) return }
7762	func readBoshRelease ( rr io . Reader ) ( * BoshRelease , error ) { release := & BoshRelease { JobManifests : make ( map [ string ] enaml . JobManifest ) , } err := release . readBoshRelease ( rr ) return release , err }
7763	func ( r * BoshRelease ) readBoshRelease ( rr io . Reader ) error { w := pkg . NewTgzWalker ( rr ) w . OnMatch ( "release.MF" , func ( file pkg . FileEntry ) error { return decodeYaml ( file . Reader , & r . ReleaseManifest ) } ) w . OnMatch ( "/jobs/" , func ( file pkg . FileEntry ) error { job , jerr := r . readBoshJob ( file . Reader ) if jerr == nil { r . JobManifests [ job . Name ] = job } return jerr } ) err := w . Walk ( ) return err }
7764	func ( r * BoshRelease ) readBoshJob ( jr io . Reader ) ( enaml . JobManifest , error ) { var job enaml . JobManifest jw := pkg . NewTgzWalker ( jr ) jw . OnMatch ( "job.MF" , func ( file pkg . FileEntry ) error { return decodeYaml ( file . Reader , & job ) } ) err := jw . Walk ( ) return job , err }
7765	func ( s * Client ) NewRequest ( method , url string , body io . Reader ) ( * http . Request , error ) { req , err := http . NewRequest ( method , url , body ) if err != nil { return nil , err } setAuth ( s , req ) return req , nil }
7766	func ( s * Client ) PushCloudConfig ( manifest [ ] byte ) error { ccm := enaml . NewCloudConfigManifest ( manifest ) req , err := s . newCloudConfigRequest ( * ccm ) if err != nil { return err } res , err := s . http . Do ( req ) if err != nil { return err } defer res . Body . Close ( ) if res . StatusCode >= 400 { body , err := ioutil . ReadAll ( res . Body ) if err != nil { return err } return fmt . Errorf ( "%s error pushing cloud config to BOSH: %s" , res . Status , string ( body ) ) } return nil }
7767	func Generate ( packagename string , fileBytes [ ] byte , outputDir string ) { b := preprocessJobManifest ( fileBytes ) objects := make ( map [ string ] map [ string ] ObjectField ) var properties [ ] string for _ , v := range b . recs { properties = append ( properties , v . Orig ) } for i := 0 ; i < b . max ; i ++ { for _ , v := range b . recs { if v . Length - 1 >= i { var structname = v . StructName ( i , packagename , properties ) var typeName = v . TypeName ( i , properties ) elementName := v . Slice [ i ] attributeName := FormatName ( elementName ) if _ , ok := objects [ structname ] ; ! ok { objects [ structname ] = make ( map [ string ] ObjectField ) } if previousElement , ok := objects [ structname ] [ attributeName ] ; ! ok { lo . G . Debug ( "Adding" , attributeName , "to" , structname , "with type" , typeName ) objects [ structname ] [ attributeName ] = ObjectField { ElementName : attributeName , ElementType : typeName , ElementAnnotation : createElementAnnotation ( elementName ) , Meta : v . Yaml , } } else { if previousElement . ElementAnnotation != createElementAnnotation ( elementName ) { lo . G . Warning ( "******** Recommended creating custom yaml marshaller on" , structname , "for" , attributeName , " ********" ) previousElement . ElementAnnotation = "`yaml:\"-\"`" \" } } } } } \" objects [ structname ] [ attributeName ] = previousElement }
7768	func CreateNewRecord ( property string , yaml enaml . JobManifestProperty ) ( record Record ) { elementArray := strings . Split ( property , "." ) record = Record { Length : len ( elementArray ) , Orig : property , Slice : elementArray , Yaml : yaml , } return }
7769	func NewShowCmd ( releaseRepo pull . Release , release string ) * ShowCmd { return & ShowCmd { releaseRepo : releaseRepo , release : release , } }
7770	func ( s * ShowCmd ) All ( w io . Writer ) error { if filepath . Ext ( s . release ) == ".pivotal" { pivnetRelease , err := release . LoadPivnetRelease ( s . releaseRepo , s . release ) if err != nil { return err } for _ , br := range pivnetRelease . BoshRelease { s . printBoshRelease ( w , br ) } return nil } boshRelease , err := release . LoadBoshRelease ( s . releaseRepo , s . release ) if err != nil { return err } s . printBoshRelease ( w , boshRelease ) return nil }
7771	func ( s * ConcoursePipeline ) GetDefaultTaskImageResource ( ) atc . ImageResource { return atc . ImageResource { Type : s . defaultImageType , Source : atc . Source { "repository" : s . defaultImageRepository , } , } }
7772	func ( s * ConcoursePipeline ) AddRawJob ( job atc . JobConfig ) { s . Jobs = append ( s . Jobs , job ) }
7773	func ( s * ConcoursePipeline ) AddGroup ( name string , jobs ... string ) { s . Groups = append ( s . Groups , atc . GroupConfig { Name : name , Jobs : jobs , } ) }
7774	func ( s * ConcoursePipeline ) GetResourceByName ( name string ) * atc . ResourceConfig { for i , v := range s . Resources { if v . Name == name { return & s . Resources [ i ] } } return nil }
7775	func ( s * ConcoursePipeline ) AddRawResource ( rawResource atc . ResourceConfig ) { s . Resources = append ( s . Resources , rawResource ) }
7776	func ( s * ConcoursePipeline ) AddResource ( name string , typename string , source map [ string ] interface { } ) { s . Resources = append ( s . Resources , atc . ResourceConfig { Name : name , Type : typename , Source : source , } ) }
7777	func ( s * ConcoursePipeline ) AddGithubResource ( name string , source map [ string ] interface { } ) { s . AddResource ( name , GithubResourceName , source ) }
7778	func ( s * ConcoursePipeline ) AddBoshIOResource ( name string , source map [ string ] interface { } ) { s . AddResource ( name , BoshIOResourceName , source ) }
7779	func ( s * ConcoursePipeline ) AddBoshDeploymentResource ( name string , source map [ string ] interface { } ) { s . AddResource ( name , BoshDeploymentResourceName , source ) }
7780	func ( s * ConcoursePipeline ) AddGitResource ( name string , source map [ string ] interface { } ) { s . AddResource ( name , GitResourceName , source ) }
7781	func ( d boshReleaseDiffer ) allJobNames ( ) [ ] string { jobNamesMap := make ( map [ string ] string ) var addJobNames = func ( br * release . BoshRelease ) { if br != nil { for jbname := range br . JobManifests { jobNamesMap [ jbname ] = jbname } } } addJobNames ( d . release1 ) addJobNames ( d . release2 ) var jobNames [ ] string for jname := range jobNamesMap { jobNames = append ( jobNames , jname ) } return jobNames }
7782	func NewDeploymentManifestFromFile ( f * os . File ) * DeploymentManifest { var b [ ] byte fi , _ := f . Stat ( ) if fi . Size ( ) > 0 { b , _ = ioutil . ReadAll ( f ) } return NewDeploymentManifest ( b ) }
7783	func NewDeploymentManifest ( b [ ] byte ) * DeploymentManifest { dm := new ( DeploymentManifest ) yaml . Unmarshal ( b , dm ) return dm }
7784	func ( s * DeploymentManifest ) AddRemoteRelease ( releaseName , ver , url , sha1 string ) ( err error ) { s . Releases = append ( s . Releases , Release { Name : releaseName , URL : url , SHA1 : sha1 , Version : ver , } ) return }
7785	func ( s * DeploymentManifest ) AddRemoteStemcell ( os , alias , ver , url , sha1 string ) { s . Stemcells = append ( s . Stemcells , Stemcell { OS : os , Alias : alias , Version : ver , URL : url , SHA1 : sha1 , } ) }
7786	func ( s * DeploymentManifest ) Tag ( key string ) string { if s . Tags == nil { return "" } return s . Tags [ key ] }
7787	func ( s * DeploymentManifest ) RemoveTag ( key string ) { if s . Tags != nil { delete ( s . Tags , key ) } }
7788	func LoadPivnetRelease ( releaseRepo pull . Release , path string ) ( release * PivnetRelease , err error ) { release = & PivnetRelease { } var localPath string localPath , err = releaseRepo . Pull ( path ) if err != nil { return } release = & PivnetRelease { BoshRelease : make ( map [ string ] * BoshRelease ) , } err = release . readPivnetRelease ( localPath ) return }
7789	func ( r * PivnetRelease ) BoshReleaseOrEmpty ( name string ) * BoshRelease { br := r . BoshRelease [ name ] if br == nil { br = emptyBoshRelease } return br }
7790	func ( r * PivnetRelease ) readPivnetRelease ( path string ) error { walker := pkg . NewZipWalker ( path ) walker . OnMatch ( "releases/" , func ( file pkg . FileEntry ) error { br , berr := readBoshRelease ( file . Reader ) if berr != nil { return berr } r . BoshRelease [ br . ReleaseManifest . Name ] = br return nil } ) return walker . Walk ( ) }
7791	func decodeYaml ( r io . Reader , v interface { } ) error { bytes , err := ioutil . ReadAll ( r ) if err == nil { yaml . Unmarshal ( bytes , v ) } return err }
7792	func NewZipWalker ( zipFile string ) Walker { return zipWalker { zipPath : zipFile , callbacks : make ( map [ * regexp . Regexp ] WalkFunc ) , } }
7793	func NewDiffCmd ( releaseRepo pull . Release , release1 , release2 string ) * DiffCmd { return & DiffCmd { releaseRepo : releaseRepo , release1 : release1 , release2 : release2 , } }
7794	func ( s * DiffCmd ) All ( w io . Writer ) error { differ , err := diff . New ( s . releaseRepo , s . release1 , s . release2 ) if err != nil { return err } d , err := differ . Diff ( ) if err != nil { return err } s . printDiffResult ( w , d ) return nil }
7795	func ( s * DiffCmd ) Job ( job string , w io . Writer ) error { differ , err := diff . New ( s . releaseRepo , s . release1 , s . release2 ) if err != nil { return err } d , err := differ . DiffJob ( job ) if err != nil { return err } s . printDiffResult ( w , d ) return nil }
7796	func New ( releaseRepo pull . Release , r1Path , r2Path string ) ( differ Differ , err error ) { if filepath . Ext ( r1Path ) != filepath . Ext ( r2Path ) { err = fmt . Errorf ( "The specified releases didn't have matching file extensions, " + "assuming different release types." ) return } if filepath . Ext ( r1Path ) == ".pivotal" { var r1 , r2 * release . PivnetRelease if r1 , err = release . LoadPivnetRelease ( releaseRepo , r1Path ) ; err == nil { if r2 , err = release . LoadPivnetRelease ( releaseRepo , r2Path ) ; err == nil { differ = pivnetReleaseDiffer { release1 : r1 , release2 : r2 , } } } } else { var r1 , r2 * release . BoshRelease if r1 , err = release . LoadBoshRelease ( releaseRepo , r1Path ) ; err == nil { if r2 , err = release . LoadBoshRelease ( releaseRepo , r2Path ) ; err == nil { differ = boshReleaseDiffer { release1 : r1 , release2 : r2 , } } } } return }
7797	func ( v * Record ) StructName ( i int , packagename string , properties [ ] string ) ( structname string ) { if i > 0 { currentNode := v . Slice [ i - 1 ] structname = FormatName ( currentNode ) if i > 1 { parentNames := v . FindAllParentsOfSameNamedElement ( currentNode , properties ) if len ( parentNames ) > 1 { structname = FormatName ( v . Slice [ i - 2 ] + "_" + currentNode ) } } } else { structname = FormatName ( packagename + "_job" ) } return }
7798	func ( v * Record ) TypeName ( i int , properties [ ] string ) ( typename string ) { if i + 1 < v . Length { currentNode := v . Slice [ i ] typename = "*" + FormatName ( currentNode ) if i >= 1 { parentNames := v . FindAllParentsOfSameNamedElement ( currentNode , properties ) if len ( parentNames ) > 1 { typename = "*" + FormatName ( v . Slice [ i - 1 ] + "_" + currentNode ) } } } else { typename = "interface{}" } return }
7799	func NewTgzWalker ( pkgReader io . Reader ) Walker { return tgzWalker { pkgReader : pkgReader , callbacks : make ( map [ * regexp . Regexp ] WalkFunc ) , } }
7800	func NewBackoff ( strategy BackoffStrategy , start time . Duration , limit time . Duration ) * Backoff { backoff := Backoff { strategy : strategy , start : start , limit : limit } backoff . Reset ( ) return & backoff }
7801	func ( b * Backoff ) Reset ( ) { b . count = 0 b . LastDuration = 0 b . NextDuration = b . getNextDuration ( ) }
7802	func NewExponential ( start time . Duration , limit time . Duration ) * Backoff { return NewBackoff ( exponential { } , start , limit ) }
7803	func NewExponentialFullJitter ( start time . Duration , limit time . Duration ) * Backoff { return NewBackoff ( exponentialFullJitter { limit : limit } , start , limit ) }
7804	func NewLinear ( start time . Duration , limit time . Duration ) * Backoff { return NewBackoff ( linear { } , start , limit ) }
7805	func ( s * Sapin ) GetLineSize ( floor , line int ) int { return 1 + line * 2 + floor * 4 + int ( floor / 2 * 2 ) * int ( ( floor + 1 ) / 2 ) }
7806	func ( s * Sapin ) GetMaxSize ( ) int { return s . GetLineSize ( s . Size - 1 , s . Size + 3 ) }
7807	func ( s * Sapin ) compute ( ) { if s . output != "" { return } maxSize := s . GetMaxSize ( ) for floor := 0 ; floor < s . Size ; floor ++ { for line := 0 ; line < floor + 4 ; line ++ { lineSize := s . GetLineSize ( floor , line ) for i := ( maxSize - lineSize ) / 2 - 1 ; i > 0 ; i -- { s . putchar ( " " ) } for i := 0 ; i < lineSize ; i ++ { s . putchar ( "*" ) } s . putchar ( "\n" ) } } \n }
7808	func ( o * PostAppsParams ) WithTimeout ( timeout time . Duration ) * PostAppsParams { o . SetTimeout ( timeout ) return o }
7809	func ( o * PostAppsParams ) WithContext ( ctx context . Context ) * PostAppsParams { o . SetContext ( ctx ) return o }
7810	func ( o * PostAppsParams ) WithHTTPClient ( client * http . Client ) * PostAppsParams { o . SetHTTPClient ( client ) return o }
7811	func ( o * PostAppsParams ) WithBody ( body * models . AppWrapper ) * PostAppsParams { o . SetBody ( body ) return o }
7812	func ( o * GetAppsAppParams ) WithTimeout ( timeout time . Duration ) * GetAppsAppParams { o . SetTimeout ( timeout ) return o }
7813	func ( o * GetAppsAppParams ) WithContext ( ctx context . Context ) * GetAppsAppParams { o . SetContext ( ctx ) return o }
7814	func ( o * GetAppsAppParams ) WithHTTPClient ( client * http . Client ) * GetAppsAppParams { o . SetHTTPClient ( client ) return o }
7815	func ( o * GetAppsAppParams ) WithApp ( app string ) * GetAppsAppParams { o . SetApp ( app ) return o }
7816	func ( m * RouteWrapper ) UnmarshalBinary ( b [ ] byte ) error { var res RouteWrapper if err := swag . ReadJSON ( b , & res ) ; err != nil { return err } * m = res return nil }
7817	func ( o * GetAppsParams ) WithTimeout ( timeout time . Duration ) * GetAppsParams { o . SetTimeout ( timeout ) return o }
7818	func ( o * GetAppsParams ) WithContext ( ctx context . Context ) * GetAppsParams { o . SetContext ( ctx ) return o }
7819	func ( o * GetAppsParams ) WithHTTPClient ( client * http . Client ) * GetAppsParams { o . SetHTTPClient ( client ) return o }
7820	func ( o * DeleteAppsAppParams ) WithTimeout ( timeout time . Duration ) * DeleteAppsAppParams { o . SetTimeout ( timeout ) return o }
7821	func ( o * DeleteAppsAppParams ) WithContext ( ctx context . Context ) * DeleteAppsAppParams { o . SetContext ( ctx ) return o }
7822	func ( o * DeleteAppsAppParams ) WithHTTPClient ( client * http . Client ) * DeleteAppsAppParams { o . SetHTTPClient ( client ) return o }
7823	func ( o * DeleteAppsAppParams ) WithApp ( app string ) * DeleteAppsAppParams { o . SetApp ( app ) return o }
7824	func ( o * PatchAppsAppRoutesRouteParams ) WithTimeout ( timeout time . Duration ) * PatchAppsAppRoutesRouteParams { o . SetTimeout ( timeout ) return o }
7825	func ( o * PatchAppsAppRoutesRouteParams ) WithContext ( ctx context . Context ) * PatchAppsAppRoutesRouteParams { o . SetContext ( ctx ) return o }
7826	func ( o * PatchAppsAppRoutesRouteParams ) WithHTTPClient ( client * http . Client ) * PatchAppsAppRoutesRouteParams { o . SetHTTPClient ( client ) return o }
7827	func ( o * PatchAppsAppRoutesRouteParams ) WithApp ( app string ) * PatchAppsAppRoutesRouteParams { o . SetApp ( app ) return o }
7828	func ( o * PatchAppsAppRoutesRouteParams ) WithBody ( body * models . RouteWrapper ) * PatchAppsAppRoutesRouteParams { o . SetBody ( body ) return o }
7829	func ( o * PatchAppsAppRoutesRouteParams ) WithRoute ( route string ) * PatchAppsAppRoutesRouteParams { o . SetRoute ( route ) return o }
7830	func ( o * PostAppsAppRoutesParams ) WithTimeout ( timeout time . Duration ) * PostAppsAppRoutesParams { o . SetTimeout ( timeout ) return o }
7831	func ( o * PostAppsAppRoutesParams ) WithContext ( ctx context . Context ) * PostAppsAppRoutesParams { o . SetContext ( ctx ) return o }
7832	func ( o * PostAppsAppRoutesParams ) WithHTTPClient ( client * http . Client ) * PostAppsAppRoutesParams { o . SetHTTPClient ( client ) return o }
7833	func ( o * PostAppsAppRoutesParams ) WithApp ( app string ) * PostAppsAppRoutesParams { o . SetApp ( app ) return o }
7834	func ( o * PostAppsAppRoutesParams ) WithBody ( body * models . RouteWrapper ) * PostAppsAppRoutesParams { o . SetBody ( body ) return o }
7835	func ( o * PutAppsAppRoutesRouteParams ) WithTimeout ( timeout time . Duration ) * PutAppsAppRoutesRouteParams { o . SetTimeout ( timeout ) return o }
7836	func ( o * PutAppsAppRoutesRouteParams ) WithContext ( ctx context . Context ) * PutAppsAppRoutesRouteParams { o . SetContext ( ctx ) return o }
7837	func ( o * PutAppsAppRoutesRouteParams ) WithApp ( app string ) * PutAppsAppRoutesRouteParams { o . SetApp ( app ) return o }
7838	func ( o * PutAppsAppRoutesRouteParams ) WithBody ( body * models . RouteWrapper ) * PutAppsAppRoutesRouteParams { o . SetBody ( body ) return o }
7839	func ( o * PutAppsAppRoutesRouteParams ) WithRoute ( route string ) * PutAppsAppRoutesRouteParams { o . SetRoute ( route ) return o }
7840	func ( o * GetAppsAppRoutesParams ) WithTimeout ( timeout time . Duration ) * GetAppsAppRoutesParams { o . SetTimeout ( timeout ) return o }
7841	func ( o * GetAppsAppRoutesParams ) WithContext ( ctx context . Context ) * GetAppsAppRoutesParams { o . SetContext ( ctx ) return o }
7842	func ( o * GetAppsAppRoutesParams ) WithHTTPClient ( client * http . Client ) * GetAppsAppRoutesParams { o . SetHTTPClient ( client ) return o }
7843	func ( o * GetAppsAppRoutesParams ) WithApp ( app string ) * GetAppsAppRoutesParams { o . SetApp ( app ) return o }
7844	func ( o * PatchAppsAppParams ) WithTimeout ( timeout time . Duration ) * PatchAppsAppParams { o . SetTimeout ( timeout ) return o }
7845	func ( o * PatchAppsAppParams ) WithContext ( ctx context . Context ) * PatchAppsAppParams { o . SetContext ( ctx ) return o }
7846	func ( o * PatchAppsAppParams ) WithHTTPClient ( client * http . Client ) * PatchAppsAppParams { o . SetHTTPClient ( client ) return o }
7847	func ( o * PatchAppsAppParams ) WithApp ( app string ) * PatchAppsAppParams { o . SetApp ( app ) return o }
7848	func ( o * PatchAppsAppParams ) WithBody ( body * models . AppWrapper ) * PatchAppsAppParams { o . SetBody ( body ) return o }
7849	func ( o * PutAppsAppParams ) WithTimeout ( timeout time . Duration ) * PutAppsAppParams { o . SetTimeout ( timeout ) return o }
7850	func ( o * PutAppsAppParams ) WithContext ( ctx context . Context ) * PutAppsAppParams { o . SetContext ( ctx ) return o }
7851	func ( o * PutAppsAppParams ) WithApp ( app string ) * PutAppsAppParams { o . SetApp ( app ) return o }
7852	func ( o * PutAppsAppParams ) WithBody ( body * models . AppWrapper ) * PutAppsAppParams { o . SetBody ( body ) return o }
7853	func ( m * Task ) UnmarshalJSON ( raw [ ] byte ) error { var aO0 NewTask if err := swag . ReadJSON ( raw , & aO0 ) ; err != nil { return err } m . NewTask = aO0 var aO1 TaskAllOf1 if err := swag . ReadJSON ( raw , & aO1 ) ; err != nil { return err } m . TaskAllOf1 = aO1 return nil }
7854	func ( m Task ) MarshalJSON ( ) ( [ ] byte , error ) { var _parts [ ] [ ] byte aO0 , err := swag . WriteJSON ( m . NewTask ) if err != nil { return nil , err } _parts = append ( _parts , aO0 ) aO1 , err := swag . WriteJSON ( m . TaskAllOf1 ) if err != nil { return nil , err } _parts = append ( _parts , aO1 ) return swag . ConcatJSON ( _parts ... ) , nil }
7855	func ( m * Task ) Validate ( formats strfmt . Registry ) error { var res [ ] error if err := m . NewTask . Validate ( formats ) ; err != nil { res = append ( res , err ) } if err := m . TaskAllOf1 . Validate ( formats ) ; err != nil { res = append ( res , err ) } if len ( res ) > 0 { return errors . CompositeValidationError ( res ... ) } return nil }
7856	func GetRanges ( ips [ ] string , ip4_cidr string , ip6_cidr string ) ( [ ] net . IPNet , error ) { net_out := make ( [ ] net . IPNet , 0 ) for _ , ip := range ips { cidr := "" if strings . Contains ( ip , ":" ) { cidr = ip6_cidr if cidr == "" { cidr = "128" } if c , err := strconv . ParseInt ( cidr , 10 , 16 ) ; err != nil || c < 0 || c > 128 { return nil , & PermError { "Invalid IPv6 CIDR length: " + cidr } } } else { cidr = ip4_cidr if cidr == "" { cidr = "32" } if c , err := strconv . ParseInt ( cidr , 10 , 16 ) ; err != nil || c < 0 || c > 32 { return nil , & PermError { "Invalid IPv4 CIDR length: " + cidr } } } ip += "/" + cidr _ , ipnet , err := net . ParseCIDR ( ip ) if err != nil { return nil , err } net_out = append ( net_out , * ipnet ) } return net_out , nil }
7857	func ( o * GetAppsAppRoutesRouteParams ) WithTimeout ( timeout time . Duration ) * GetAppsAppRoutesRouteParams { o . SetTimeout ( timeout ) return o }
7858	func ( o * GetAppsAppRoutesRouteParams ) WithContext ( ctx context . Context ) * GetAppsAppRoutesRouteParams { o . SetContext ( ctx ) return o }
7859	func ( o * GetAppsAppRoutesRouteParams ) WithHTTPClient ( client * http . Client ) * GetAppsAppRoutesRouteParams { o . SetHTTPClient ( client ) return o }
7860	func ( o * GetAppsAppRoutesRouteParams ) WithApp ( app string ) * GetAppsAppRoutesRouteParams { o . SetApp ( app ) return o }
7861	func ( o * GetAppsAppRoutesRouteParams ) WithRoute ( route string ) * GetAppsAppRoutesRouteParams { o . SetRoute ( route ) return o }
7862	func New ( transport runtime . ClientTransport , formats strfmt . Registry ) * Functions { cli := new ( Functions ) cli . Transport = transport cli . Apps = apps . New ( transport , formats ) cli . Routes = routes . New ( transport , formats ) cli . Tasks = tasks . New ( transport , formats ) cli . Version = version . New ( transport , formats ) return cli }
7863	func ( c * Functions ) SetTransport ( transport runtime . ClientTransport ) { c . Transport = transport c . Apps . SetTransport ( transport ) c . Routes . SetTransport ( transport ) c . Tasks . SetTransport ( transport ) c . Version . SetTransport ( transport ) }
7864	func ( o * DeleteAppsAppRoutesRouteParams ) WithTimeout ( timeout time . Duration ) * DeleteAppsAppRoutesRouteParams { o . SetTimeout ( timeout ) return o }
7865	func ( o * DeleteAppsAppRoutesRouteParams ) WithContext ( ctx context . Context ) * DeleteAppsAppRoutesRouteParams { o . SetContext ( ctx ) return o }
7866	func ( o * DeleteAppsAppRoutesRouteParams ) WithHTTPClient ( client * http . Client ) * DeleteAppsAppRoutesRouteParams { o . SetHTTPClient ( client ) return o }
7867	func ( o * DeleteAppsAppRoutesRouteParams ) WithApp ( app string ) * DeleteAppsAppRoutesRouteParams { o . SetApp ( app ) return o }
7868	func ( o * DeleteAppsAppRoutesRouteParams ) WithRoute ( route string ) * DeleteAppsAppRoutesRouteParams { o . SetRoute ( route ) return o }
7869	func ( o * GetTasksParams ) WithTimeout ( timeout time . Duration ) * GetTasksParams { o . SetTimeout ( timeout ) return o }
7870	func ( o * GetTasksParams ) WithContext ( ctx context . Context ) * GetTasksParams { o . SetContext ( ctx ) return o }
7871	func ( o * GetTasksParams ) WithHTTPClient ( client * http . Client ) * GetTasksParams { o . SetHTTPClient ( client ) return o }
7872	func NewValueStore ( addr string , concurrency int , ftlsConfig * ftls . Config , opts ... grpc . DialOption ) ( store . ValueStore , error ) { stor := & valueStore { addr : addr , ftlsc : ftlsConfig , opts : opts , handlersDoneChan : make ( chan struct { } ) , } stor . pendingLookupReqChan = make ( chan * asyncValueLookupRequest , concurrency ) stor . freeLookupReqChan = make ( chan * asyncValueLookupRequest , concurrency ) stor . freeLookupResChan = make ( chan * asyncValueLookupResponse , concurrency ) for i := 0 ; i < cap ( stor . freeLookupReqChan ) ; i ++ { stor . freeLookupReqChan <- & asyncValueLookupRequest { resChan : make ( chan * asyncValueLookupResponse , 1 ) } } for i := 0 ; i < cap ( stor . freeLookupResChan ) ; i ++ { stor . freeLookupResChan <- & asyncValueLookupResponse { } } go stor . handleLookupStream ( ) stor . pendingReadReqChan = make ( chan * asyncValueReadRequest , concurrency ) stor . freeReadReqChan = make ( chan * asyncValueReadRequest , concurrency ) stor . freeReadResChan = make ( chan * asyncValueReadResponse , concurrency ) for i := 0 ; i < cap ( stor . freeReadReqChan ) ; i ++ { stor . freeReadReqChan <- & asyncValueReadRequest { resChan : make ( chan * asyncValueReadResponse , 1 ) } } for i := 0 ; i < cap ( stor . freeReadResChan ) ; i ++ { stor . freeReadResChan <- & asyncValueReadResponse { } } go stor . handleReadStream ( ) stor . pendingWriteReqChan = make ( chan * asyncValueWriteRequest , concurrency ) stor . freeWriteReqChan = make ( chan * asyncValueWriteRequest , concurrency ) stor . freeWriteResChan = make ( chan * asyncValueWriteResponse , concurrency ) for i := 0 ; i < cap ( stor . freeWriteReqChan ) ; i ++ { stor . freeWriteReqChan <- & asyncValueWriteRequest { resChan : make ( chan * asyncValueWriteResponse , 1 ) } } for i := 0 ; i < cap ( stor . freeWriteResChan ) ; i ++ { stor . freeWriteResChan <- & asyncValueWriteResponse { } } go stor . handleWriteStream ( ) stor . pendingDeleteReqChan = make ( chan * asyncValueDeleteRequest , concurrency ) stor . freeDeleteReqChan = make ( chan * asyncValueDeleteRequest , concurrency ) stor . freeDeleteResChan = make ( chan * asyncValueDeleteResponse , concurrency ) for i := 0 ; i < cap ( stor . freeDeleteReqChan ) ; i ++ { stor . freeDeleteReqChan <- & asyncValueDeleteRequest { resChan : make ( chan * asyncValueDeleteResponse , 1 ) } } for i := 0 ; i < cap ( stor . freeDeleteResChan ) ; i ++ { stor . freeDeleteResChan <- & asyncValueDeleteResponse { } } go stor . handleDeleteStream ( ) return stor , nil }
7873	func ( stor * valueStore ) Close ( ) { stor . lock . Lock ( ) stor . shutdown ( ) close ( stor . handlersDoneChan ) stor . lock . Unlock ( ) }
7874	func ( o * Server ) SetBackend ( backend OortService ) { o . Lock ( ) o . backend = backend o . Unlock ( ) }
7875	func ( o * Server ) Ring ( ) ring . Ring { o . RLock ( ) defer o . RUnlock ( ) return o . ring }
7876	func ( o * Server ) GetLocalID ( ) uint64 { o . RLock ( ) defer o . RUnlock ( ) return o . localID }
7877	func ( o * Server ) GetListenAddr ( ) string { o . RLock ( ) defer o . RUnlock ( ) return o . ring . LocalNode ( ) . Address ( 2 ) }
7878	func ( rs * ReplGroupStore ) Startup ( ctx context . Context ) error { rs . ringLock . Lock ( ) if rs . ringServerExitChan == nil { rs . ringServerExitChan = make ( chan struct { } ) go rs . ringServerConnector ( rs . ringServerExitChan ) } rs . ringLock . Unlock ( ) return nil }
7879	func ( o * Server ) shutdownFinished ( ) { time . Sleep ( 10 * time . Millisecond ) close ( o . ShutdownComplete ) }
7880	func ( o * Server ) Stop ( ) error { o . cmdCtrlLock . Lock ( ) defer o . cmdCtrlLock . Unlock ( ) if o . stopped { return fmt . Errorf ( "Service already stopped" ) } close ( o . ch ) o . backend . StopListenAndServe ( ) o . backend . Wait ( ) o . backend . Stop ( ) o . stopped = true return nil }
7881	func ( o * Server ) Exit ( ) error { o . cmdCtrlLock . Lock ( ) defer o . cmdCtrlLock . Unlock ( ) if o . stopped { o . backend . Stop ( ) defer o . shutdownFinished ( ) return nil } close ( o . ch ) o . backend . StopListenAndServe ( ) o . backend . Wait ( ) o . backend . Stop ( ) o . stopped = true defer o . shutdownFinished ( ) return nil }
7882	func ( o * Server ) SelfUpgrade ( version string , bindiff , checksum [ ] byte ) ( bool , string ) { o . cmdCtrlLock . Lock ( ) defer o . cmdCtrlLock . Unlock ( ) err := o . binaryUpgrade . Upgrade ( version ) if err != nil { return false , err . Error ( ) } return true , "" }
7883	func ( o * Server ) SoftwareVersion ( ) string { o . cmdCtrlLock . RLock ( ) defer o . cmdCtrlLock . RUnlock ( ) return o . binaryUpgrade . GetCurrentVersion ( ) }
7884	func ( stor * groupStore ) Shutdown ( ctx context . Context ) error { stor . lock . Lock ( ) err := stor . shutdown ( ) stor . lock . Unlock ( ) return err }
7885	func ( c * Client ) Rant ( rantId int ) ( RantModel , [ ] CommentModel , error ) { url := fmt . Sprintf ( RANT_PATH , API , rantId , APP_VERSION ) res , err := http . Get ( url ) if err != nil { return RantModel { } , nil , err } var data RantResponse json . NewDecoder ( res . Body ) . Decode ( & data ) if ! data . Success && data . Error != "" { return RantModel { } , nil , errors . New ( data . Error ) } return data . Rant , data . Comments , nil }
7886	func ( c * Client ) Profile ( username string ) ( UserModel , ContentModel , error ) { userId , err := getUserId ( username ) if err != nil { return UserModel { } , ContentModel { } , err } url := fmt . Sprintf ( USER_PATH , API , userId , APP_VERSION ) res , err := http . Get ( url ) if err != nil { return UserModel { } , ContentModel { } , err } var data UserResponse json . NewDecoder ( res . Body ) . Decode ( & data ) if ! data . Success && data . Error != "" { return UserModel { } , ContentModel { } , errors . New ( data . Error ) } return data . Profile , data . Profile . Content . Content , nil }
7887	func ( c * Client ) Search ( term string ) ( [ ] RantModel , error ) { url := fmt . Sprintf ( SEARCH_PATH , API , term , APP_VERSION ) res , err := http . Get ( url ) if err != nil { return nil , err } var data SearchResponse json . NewDecoder ( res . Body ) . Decode ( & data ) if ! data . Success && data . Error != "" { return nil , errors . New ( data . Error ) } return data . Rants , nil }
7888	func ( c * Client ) Surprise ( ) ( RantModel , error ) { url := fmt . Sprintf ( SURPRISE_PATH , API , APP_VERSION ) res , err := http . Get ( url ) if err != nil { return RantModel { } , err } var data RantResponse json . NewDecoder ( res . Body ) . Decode ( & data ) if ! data . Success && data . Error != "" { return RantModel { } , errors . New ( data . Error ) } return data . Rant , nil }
7889	func ( c * Client ) WeeklyRants ( ) ( [ ] RantModel , error ) { url := fmt . Sprintf ( WEEKLY_PATH , API , APP_VERSION ) res , err := http . Get ( url ) if err != nil { return nil , err } var data RantsResponse json . NewDecoder ( res . Body ) . Decode ( & data ) if ! data . Success && data . Error != "" { return nil , errors . New ( data . Error ) } return data . Rants , nil }
7890	func getUserId ( username string ) ( int , error ) { url := fmt . Sprintf ( USER_ID_PATH , API , username , APP_VERSION ) res , err := http . Get ( url ) if err != nil { return 0 , err } var data GetUserIdResponse json . NewDecoder ( res . Body ) . Decode ( & data ) if ! data . Success && data . Error != "" { return 0 , errors . New ( data . Error ) } return data . UserId , nil }
7891	func ( rs * ReplValueStore ) Shutdown ( ctx context . Context ) error { rs . ringLock . Lock ( ) if rs . ringServerExitChan != nil { close ( rs . ringServerExitChan ) rs . ringServerExitChan = nil } rs . storesLock . Lock ( ) for addr , stc := range rs . stores { if err := stc . store . Shutdown ( ctx ) ; err != nil { rs . logDebug ( "replValueStore: error during shutdown of store %s: %s" , addr , err ) } delete ( rs . stores , addr ) select { case <- ctx . Done ( ) : rs . storesLock . Unlock ( ) return ctx . Err ( ) default : } } rs . storesLock . Unlock ( ) rs . ringLock . Unlock ( ) return nil }
7892	func FExists ( name string ) bool { if _ , err := os . Stat ( name ) ; os . IsNotExist ( err ) { return false } return true }
7893	func ( m * MessageStream ) outbound ( ) { for { select { case <- m . Shutdown : log . Infof ( "Closing OpenFlow message stream." ) m . conn . Close ( ) return case msg := <- m . Outbound : data , _ := msg . MarshalBinary ( ) if _ , err := m . conn . Write ( data ) ; err != nil { log . Warnln ( "OutboundError:" , err ) m . Error <- err m . Shutdown <- true } log . Debugf ( "Sent(%d): %v" , len ( data ) , data ) } } }
7894	func ( m * MessageStream ) parse ( ) { for { b := <- m . pool . Full log . Debugf ( "Rcvd: %v" , b . Bytes ( ) ) msg , err := m . parser . Parse ( b . Bytes ( ) ) if err != nil { log . Print ( err ) } m . Inbound <- msg b . Reset ( ) m . pool . Empty <- b } }
7895	func ( dom * Domain ) Group ( name string , members [ ] * Account ) * Group { return & Group { Domain : dom , Name : name , Members : members } }
7896	func ( dom * Domain ) Groups ( ) ( [ ] * Group , error ) { var vl valueList err := dom . cgp . request ( listGroups { Domain : dom . Name } , & vl ) if err != nil { return [ ] * Group { } , err } vals := vl . compact ( ) grps := make ( [ ] * Group , len ( vals ) ) for i , v := range vals { g , err := dom . GetGroup ( v ) if err != nil { return grps , err } grps [ i ] = g } return grps , nil }
7897	func ( dom * Domain ) GetGroup ( name string ) ( * Group , error ) { var d dictionary err := dom . cgp . request ( getGroup { Name : fmt . Sprintf ( "%s@%s" , name , dom . Name ) } , & d ) if err != nil { return & Group { } , err } memStr := d . toMap ( ) [ "Members" ] var mems [ ] * Account dec := xml . NewDecoder ( bytes . NewBufferString ( memStr ) ) for { var a string err := dec . Decode ( & a ) if err == io . EOF { break } if err != nil { return dom . Group ( name , mems ) , err } if a == "" { continue } mems = append ( mems , dom . Account ( a ) ) } return dom . Group ( name , mems ) , nil }
7898	func Reticence ( str string , length int ) string { if length > len ( str ) { return str } var i int F : for i = len ( str ) - 1 ; i >= 0 ; i -- { switch str [ i ] { case ' ' , ',' , '?' , ';' , ':' , '\'' , '"' , '!' : if i <= length { break F } case '.' : if i - 2 >= 0 { s := str [ i - 2 : i ] if s == ".." { i = i - 2 if i <= length { break F } } } if i <= length { break F } } } if i - 1 > 0 { switch str [ i - 1 ] { case ' ' , ',' , '?' , ';' , ':' , '\'' , '"' , '!' : i -- case '.' : if i - 2 > 0 && str [ i - 2 : i ] == ".." { i -= 3 } } } if i >= 2 { if i + 3 >= len ( str ) { return str } return str [ : i ] + "..." } if length >= 2 && length < len ( str ) { if length + 3 >= len ( str ) { return str } return str [ : length ] + "..." } return str }
7899	func CheckPassword ( pass string , min , max int ) error { if len ( pass ) < min || len ( pass ) > max { return e . New ( ErrInvalidPassLength ) } for _ , r := range pass { if ! unicode . IsGraphic ( r ) { return e . New ( ErrInvalidPassChar ) } } return nil }
7900	func CleanUrl ( rawurl string , min , max int ) ( string , error ) { err := CheckUrl ( rawurl , min , max ) if err != nil { return "" , e . Forward ( err ) } u , err := url . Parse ( rawurl ) if err != nil { return "" , e . Push ( e . New ( ErrInvUrl ) , err ) } if u . Scheme == "" { return u . String ( ) , e . New ( ErrNoScheme ) } return u . String ( ) , nil }
7901	func NewParameter ( name string , value reflect . Value ) * Parameter { parameter := Parameter { Name : name , Value : value , } return & parameter }
7902	func MakeParams ( fieldCount int ) * Params { return & Params { make ( map [ string ] * Parameter ) , make ( [ ] * Parameter , 0 , fieldCount ) , } }
7903	func ( p * Params ) Parse ( pvalue * reflect . Value ) error { vtype := pvalue . Type ( ) . Elem ( ) for idx := 0 ; idx < vtype . NumField ( ) ; idx ++ { field := vtype . Field ( idx ) value := pvalue . Elem ( ) . Field ( idx ) if value . Kind ( ) == reflect . Slice { value . Set ( reflect . MakeSlice ( value . Type ( ) , 0 , 0 ) ) } parameter := NewParameter ( field . Name , value ) if err := parameter . DiscoverProperties ( field . Tag ) ; err != nil { return err } if err := p . Set ( parameter . Name , parameter ) ; err != nil { return err } if parameter . Alias != "" { if err := p . Set ( parameter . Alias , parameter ) ; err != nil { return err } } p . Listing = append ( p . Listing , parameter ) } return nil }
7904	func ( f Forwarder ) Email ( ) string { return fmt . Sprintf ( "%s@%s" , f . Name , f . Domain . Name ) }
7905	func ( dom * Domain ) Forwarder ( name , to string ) * Forwarder { return & Forwarder { Domain : dom , Name : name , To : to } }
7906	func ( dom * Domain ) Forwarders ( ) ( [ ] * Forwarder , error ) { var vl valueList err := dom . cgp . request ( listForwarders { Param : dom . Name } , & vl ) if err != nil { return [ ] * Forwarder { } , err } vals := vl . compact ( ) fs := make ( [ ] * Forwarder , len ( vals ) ) for i , v := range vals { f , err := dom . GetForwarder ( v ) if err != nil { return fs , err } fs [ i ] = f } return fs , err }
7907	func ( dom * Domain ) GetForwarder ( name string ) ( * Forwarder , error ) { var f string err := dom . cgp . request ( getForwarder { Param : fmt . Sprintf ( "%s@%s" , name , dom . Name ) } , & f ) if err != nil { return & Forwarder { } , err } return & Forwarder { Domain : dom , Name : name , To : f } , nil }
7908	func New ( url , user , pass string ) * CGP { return & CGP { url : url , user : user , pass : pass } }
7909	func EscapeCommaSeparated ( in ... string ) string { var out string for i , str := range in { escaped := strings . Replace ( url . QueryEscape ( str ) , "%2F" , "%252F" , - 1 ) escaped = strings . Replace ( escaped , "\"" , \" , "%22" ) - 1 escaped = strings . Replace ( escaped , " " , "%20" , - 1 ) out += escaped } if i < len ( in ) - 1 { out += "," } }
7910	func ( acc * Account ) Alias ( name string ) * Alias { return & Alias { account : acc , Name : name } }
7911	func ( a Alias ) Email ( ) string { return fmt . Sprintf ( "%s@%s" , a . Name , a . account . Domain . Name ) }
7912	func ( acc * Account ) Aliases ( ) ( [ ] * Alias , error ) { var vl valueList err := acc . Domain . cgp . request ( listAliases { Param : fmt . Sprintf ( "%s@%s" , acc . Name , acc . Domain . Name ) } , & vl ) if err != nil { return [ ] * Alias { } , err } vals := vl . compact ( ) as := make ( [ ] * Alias , len ( vals ) ) for i , v := range vals { as [ i ] = acc . Alias ( v ) } return as , nil }
7913	func ( a Account ) RealName ( ) ( string , error ) { var d dictionary err := a . Domain . cgp . request ( getAccountSettings { Account : a . Email ( ) } , & d ) if err != nil { return "" , err } return d . toMap ( ) [ "RealName" ] , nil }
7914	func ( a Account ) Email ( ) string { return fmt . Sprintf ( "%s@%s" , a . Name , a . Domain . Name ) }
7915	func ( dom * Domain ) Account ( name string ) * Account { return & Account { Domain : dom , Name : name } }
7916	func ( dom * Domain ) Accounts ( ) ( [ ] * Account , error ) { var al accountList err := dom . cgp . request ( listAccounts { Domain : dom . Name } , & al ) if err != nil { return [ ] * Account { } , err } keys := al . SubKeys as := make ( [ ] * Account , len ( keys ) ) for i , k := range keys { as [ i ] = dom . Account ( k . Name ) } return as , nil }
7917	func ( dom Domain ) Exists ( ) ( bool , error ) { var d dictionary err := dom . cgp . request ( getDomainSettings { Domain : dom . Name } , & d ) if _ , ok := err . ( SOAPNotFoundError ) ; ok { return false , nil } if err != nil { return false , err } return true , nil }
7918	func ( dom Domain ) Aliases ( ) ( [ ] string , error ) { var vl valueList err := dom . cgp . request ( getDomainAliases { Domain : dom . Name } , & vl ) if err != nil { return [ ] string { } , err } return vl . compact ( ) , nil }
7919	func ( cgp * CGP ) Domain ( name string ) * Domain { return & Domain { cgp : cgp , Name : name } }
7920	func ( cgp * CGP ) Domains ( ) ( [ ] * Domain , error ) { var vl valueList err := cgp . request ( listDomains { } , & vl ) if err != nil { return [ ] * Domain { } , err } vals := vl . SubValues ds := make ( [ ] * Domain , len ( vals ) ) for i , d := range vals { ds [ i ] = cgp . Domain ( d ) } return ds , nil }
7921	func New ( info Info , publicMsg ... interface { } ) Err { return newErr ( debug . Stack ( ) , nil , false , info , publicMsg ) }
7922	func Wrap ( wrapErr error , info Info , publicMsg ... interface { } ) Err { if wrapErr == nil { return nil } if info == nil { info = Info { } } if errsErr , isErr := IsErr ( wrapErr ) ; isErr { if errStructErr , isErrsErr := errsErr . ( * err ) ; isErrsErr { errStructErr . mergeIn ( info , publicMsg ) return errStructErr } return errsErr } return newErr ( debug . Stack ( ) , wrapErr , false , info , publicMsg ) }
7923	func ( e * err ) mergeIn ( info Info , publicMsgParts [ ] interface { } ) { for key , val := range info { for e . info [ key ] != nil { key = key + "_duplicate" } e . info [ key ] = val } publicMsgPrefix := concatArgs ( publicMsgParts ... ) if publicMsgPrefix == "" { } else if e . publicMsg == "" { e . publicMsg = publicMsgPrefix } else { e . publicMsg = publicMsgPrefix + " - " + e . publicMsg } }
7924	func ( e * err ) wrappedErrStr ( ) string { if e == nil { return "" } if e . wrappedErr == nil { return "" } return e . wrappedErr . Error ( ) }
7925	func concatArgs ( args ... interface { } ) string { res := fmt . Sprintln ( args ... ) return res [ 0 : len ( res ) - 1 ] }
7926	func ( dom * Domain ) MailingList ( name string ) * MailingList { return & MailingList { Domain : dom , Name : name } }
7927	func ( ml * MailingList ) Subscriber ( email , name string ) * Subscriber { return & Subscriber { MailingList : ml , Email : email , RealName : name } }
7928	func ( ml * MailingList ) Subscribers ( ) ( [ ] * Subscriber , error ) { var res readSubscribersResponse err := ml . Domain . cgp . request ( readSubscribers { Name : fmt . Sprintf ( "%s@%s" , ml . Name , ml . Domain . Name ) } , & res ) if err != nil { return [ ] * Subscriber { } , err } ds := res . SubValues [ 1 ] . SubValues subs := make ( [ ] * Subscriber , len ( ds ) ) for i , d := range ds { m := d . toMap ( ) subs [ i ] = ml . Subscriber ( m [ "Sub" ] , m [ "RealName" ] ) } return subs , nil }
7929	func ( dom * Domain ) MailingLists ( ) ( [ ] * MailingList , error ) { var vl valueList err := dom . cgp . request ( listLists { Domain : dom . Name } , & vl ) if err != nil { return [ ] * MailingList { } , err } vals := vl . compact ( ) mls := make ( [ ] * MailingList , len ( vals ) ) for i , v := range vals { mls [ i ] = dom . MailingList ( v ) } return mls , nil }
7930	func NewByteKeyItem ( k [ ] byte ) unsafe . Pointer { itm := byteKeyItem ( k ) return unsafe . Pointer ( & itm ) }
7931	func CompareBytes ( this , that unsafe . Pointer ) int { thisItem := ( * byteKeyItem ) ( this ) thatItem := ( * byteKeyItem ) ( that ) return bytes . Compare ( [ ] byte ( * thisItem ) , [ ] byte ( * thatItem ) ) }
7932	func CompareInt ( this , that unsafe . Pointer ) int { thisItem := ( * intKeyItem ) ( this ) thatItem := ( * intKeyItem ) ( that ) return int ( * thisItem - * thatItem ) }
7933	func Malloc ( l int ) unsafe . Pointer { if Debug { atomic . AddUint64 ( & stats . allocs , 1 ) } return C . mm_malloc ( C . size_t ( l ) ) }
7934	func Free ( p unsafe . Pointer ) { if Debug { atomic . AddUint64 ( & stats . frees , 1 ) } C . mm_free ( p ) }
7935	func Stats ( ) string { mu . Lock ( ) defer mu . Unlock ( ) buf := C . mm_stats ( ) s := "==== Stats ====\n" \n if Debug { s += fmt . Sprintf ( "Mallocs = %d\n" + \n , "Frees = %d\n" , \n ) } stats . allocs }
7936	func FreeOSMemory ( ) error { errCode := int ( C . mm_free2os ( ) ) if errCode != 0 { return fmt . Errorf ( "status: %d" , errCode ) } return nil }
7937	func ( s * Segment ) Add ( itm unsafe . Pointer ) { itemLevel := s . builder . store . NewLevel ( s . rand . Float32 ) x := s . builder . store . newNode ( itm , itemLevel ) s . sts . AddInt64 ( & s . sts . nodeAllocs , 1 ) s . sts . AddInt64 ( & s . sts . levelNodesCount [ itemLevel ] , 1 ) s . sts . AddInt64 ( & s . sts . usedBytes , int64 ( s . builder . store . Size ( x ) ) ) for l := 0 ; l <= itemLevel ; l ++ { if s . tail [ l ] != nil { s . tail [ l ] . setNext ( l , x , false ) } else { s . head [ l ] = x } s . tail [ l ] = x } if s . callb != nil { s . callb ( x ) } }
7938	func ( b * Builder ) NewSegment ( ) * Segment { seg := & Segment { tail : make ( [ ] * Node , MaxLevel + 1 ) , head : make ( [ ] * Node , MaxLevel + 1 ) , builder : b , rand : rand . New ( rand . NewSource ( int64 ( rand . Int ( ) ) ) ) , } seg . sts . IsLocal ( true ) return seg }
7939	func ( b * Builder ) Assemble ( segments ... * Segment ) * Skiplist { tail := make ( [ ] * Node , MaxLevel + 1 ) head := make ( [ ] * Node , MaxLevel + 1 ) for _ , seg := range segments { for l := 0 ; l <= MaxLevel ; l ++ { if tail [ l ] != nil && seg . head [ l ] != nil { tail [ l ] . setNext ( l , seg . head [ l ] , false ) } else if head [ l ] == nil && seg . head [ l ] != nil { head [ l ] = seg . head [ l ] } if seg . tail [ l ] != nil { tail [ l ] = seg . tail [ l ] } } } for l := 0 ; l <= MaxLevel ; l ++ { if head [ l ] != nil { b . store . head . setNext ( l , head [ l ] , false ) } if tail [ l ] != nil { tail [ l ] . setNext ( l , b . store . tail , false ) } } for _ , seg := range segments { b . store . Stats . Merge ( & seg . sts ) } return b . store }
7940	func CompareNodeTable ( a , b unsafe . Pointer ) int { return int ( uintptr ( a ) ) - int ( uintptr ( b ) ) }
7941	func New ( hfn HashFn , kfn EqualKeyFn ) * NodeTable { nt := & NodeTable { fastHT : make ( map [ uint32 ] uint64 ) , slowHT : make ( map [ uint32 ] [ ] uint64 ) , hash : hfn , keyEqual : kfn , } buf := dbInstances . MakeBuf ( ) defer dbInstances . FreeBuf ( buf ) dbInstances . Insert ( unsafe . Pointer ( nt ) , CompareNodeTable , buf , & dbInstances . Stats ) return nt }
7942	func ( nt * NodeTable ) Stats ( ) string { return fmt . Sprintf ( "\nFastHTCount = %d\n" + \n + \n + "SlowHTCount = %d\n" , \n , "Conflicts = %d\n" , \n , "MemoryInUse = %d\n" ) }
7943	func ( nt * NodeTable ) MemoryInUse ( ) int64 { return int64 ( approxItemSize * ( nt . fastHTCount + nt . slowHTCount ) ) }
7944	func ( nt * NodeTable ) Get ( key [ ] byte ) unsafe . Pointer { res := nt . find ( key ) if res . status & ntFoundMask == ntFoundMask { if res . status == ntFoundInFast { return decodePointer ( res . fastHTValue ) } return decodePointer ( res . slowHTValues [ res . slowHTPos ] ) } return nil }
7945	func ( nt * NodeTable ) Update ( key [ ] byte , nptr unsafe . Pointer ) ( updated bool , oldPtr unsafe . Pointer ) { res := nt . find ( key ) if res . status & ntFoundMask == ntFoundMask { updated = true if res . status == ntFoundInFast { oldPtr = decodePointer ( res . fastHTValue ) nt . fastHT [ res . hash ] = encodePointer ( nptr , res . hasConflict ) } else { oldPtr = decodePointer ( res . slowHTValues [ res . slowHTPos ] ) res . slowHTValues [ res . slowHTPos ] = encodePointer ( nptr , true ) } } else { updated = false newSlowValue := res . fastHTHasEntry && ! res . hasConflict if res . hasConflict || newSlowValue { slowHTValues := nt . slowHT [ res . hash ] slowHTValues = append ( slowHTValues , encodePointer ( nptr , false ) ) nt . slowHT [ res . hash ] = slowHTValues if newSlowValue { nt . fastHT [ res . hash ] = encodePointer ( decodePointer ( nt . fastHT [ res . hash ] ) , true ) nt . conflicts ++ } nt . slowHTCount ++ } else { nt . fastHT [ res . hash ] = encodePointer ( nptr , false ) nt . fastHTCount ++ } } return }
7946	func ( nt * NodeTable ) Remove ( key [ ] byte ) ( success bool , nptr unsafe . Pointer ) { res := nt . find ( key ) if res . status & ntFoundMask == ntFoundMask { success = true if res . status == ntFoundInFast { nptr = decodePointer ( res . fastHTValue ) if res . hasConflict { slowHTValues := nt . slowHT [ res . hash ] v := slowHTValues [ 0 ] slowHTValues = append ( [ ] uint64 ( nil ) , slowHTValues [ 1 : ] ... ) nt . slowHTCount -- var conflict bool if len ( slowHTValues ) == 0 { delete ( nt . slowHT , res . hash ) nt . conflicts -- } else { conflict = true nt . slowHT [ res . hash ] = slowHTValues } nt . fastHT [ res . hash ] = encodePointer ( decodePointer ( v ) , conflict ) } else { delete ( nt . fastHT , res . hash ) nt . fastHTCount -- } } else { nptr = decodePointer ( res . slowHTValues [ res . slowHTPos ] ) newSlowValue := append ( [ ] uint64 ( nil ) , res . slowHTValues [ : res . slowHTPos ] ... ) if res . slowHTPos + 1 != len ( res . slowHTValues ) { newSlowValue = append ( newSlowValue , res . slowHTValues [ res . slowHTPos + 1 : ] ... ) } nt . slowHTCount -- if len ( newSlowValue ) == 0 { delete ( nt . slowHT , res . hash ) nt . fastHT [ res . hash ] = encodePointer ( decodePointer ( nt . fastHT [ res . hash ] ) , false ) nt . conflicts -- } else { nt . slowHT [ res . hash ] = newSlowValue } } } return }
7947	func ( nt * NodeTable ) Close ( ) { nt . fastHTCount = 0 nt . slowHTCount = 0 nt . conflicts = 0 nt . fastHT = make ( map [ uint32 ] uint64 ) nt . slowHT = make ( map [ uint32 ] [ ] uint64 ) buf := dbInstances . MakeBuf ( ) defer dbInstances . FreeBuf ( buf ) dbInstances . Delete ( unsafe . Pointer ( nt ) , CompareNodeTable , buf , & dbInstances . Stats ) }
7948	func MemoryInUse ( ) ( sz int64 ) { buf := dbInstances . MakeBuf ( ) defer dbInstances . FreeBuf ( buf ) iter := dbInstances . NewIterator ( CompareNodeTable , buf ) for iter . SeekFirst ( ) ; iter . Valid ( ) ; iter . Next ( ) { db := ( * NodeTable ) ( iter . Get ( ) ) sz += db . MemoryInUse ( ) } return }
7949	func debugMarkFree ( n * Node ) { var block [ ] byte l := int ( nodeTypes [ n . level ] . Size ( ) ) sh := ( * reflect . SliceHeader ) ( unsafe . Pointer ( & block ) ) sh . Data = uintptr ( unsafe . Pointer ( n ) ) sh . Len = l sh . Cap = l copy ( block , freeBlockContent ) }
7950	func ( it * Iterator ) Seek ( bs [ ] byte ) { itm := it . snap . db . newItem ( bs , false ) it . iter . Seek ( unsafe . Pointer ( itm ) ) it . skipUnwanted ( ) }
7951	func ( it * Iterator ) Next ( ) { it . iter . Next ( ) it . count ++ it . skipUnwanted ( ) if it . refreshRate > 0 && it . count > it . refreshRate { it . Refresh ( ) it . count = 0 } }
7952	func ( it * Iterator ) Refresh ( ) { if it . Valid ( ) { itm := it . snap . db . ptrToItem ( it . GetNode ( ) . Item ( ) ) it . iter . Close ( ) it . iter = it . snap . db . store . NewIterator ( it . snap . db . iterCmp , it . buf ) it . iter . Seek ( unsafe . Pointer ( itm ) ) } }
7953	func ( it * Iterator ) Close ( ) { it . snap . Close ( ) it . snap . db . store . FreeBuf ( it . buf ) it . iter . Close ( ) }
7954	func ( m * Nitro ) NewIterator ( snap * Snapshot ) * Iterator { if ! snap . Open ( ) { return nil } buf := snap . db . store . MakeBuf ( ) return & Iterator { snap : snap , iter : m . store . NewIterator ( m . iterCmp , buf ) , buf : buf , } }
7955	func ( mit * MergeIterator ) SeekFirst ( ) { for _ , it := range mit . iters { it . SeekFirst ( ) if it . Valid ( ) { n := it . GetNode ( ) mit . h = append ( mit . h , heapItem { iter : it , n : n } ) } } heap . Init ( & mit . h ) mit . Next ( ) }
7956	func ( mit * MergeIterator ) Next ( ) { mit . curr = nil if mit . h . Len ( ) == 0 { return } o := heap . Pop ( & mit . h ) hi := o . ( heapItem ) mit . curr = hi . n hi . iter . Next ( ) if hi . iter . Valid ( ) { hi . n = hi . iter . GetNode ( ) heap . Push ( & mit . h , hi ) } }
7957	func ( mit * MergeIterator ) Seek ( itm unsafe . Pointer ) bool { var found bool for _ , it := range mit . iters { if it . Seek ( itm ) { found = true } if it . Valid ( ) { n := it . GetNode ( ) mit . h = append ( mit . h , heapItem { iter : it , n : n } ) } } heap . Init ( & mit . h ) mit . Next ( ) return found }
7958	func ( l * NodeList ) Keys ( ) ( keys [ ] [ ] byte ) { node := l . head for node != nil { key := ( * Item ) ( node . Item ( ) ) . Bytes ( ) keys = append ( keys , key ) node = node . GetLink ( ) } return }
7959	func ( l * NodeList ) Remove ( key [ ] byte ) * skiplist . Node { var prev * skiplist . Node node := l . head for node != nil { nodeKey := ( * Item ) ( node . Item ( ) ) . Bytes ( ) if bytes . Equal ( nodeKey , key ) { if prev == nil { l . head = node . GetLink ( ) return node } prev . SetLink ( node . GetLink ( ) ) return node } prev = node node = node . GetLink ( ) } return nil }
7960	func ( l * NodeList ) Add ( node * skiplist . Node ) { node . SetLink ( l . head ) l . head = node }
7961	func NewWithConfig ( cfg Config ) * Skiplist { if runtime . GOARCH != "amd64" { cfg . UseMemoryMgmt = false } s := & Skiplist { Config : cfg , barrier : newAccessBarrier ( cfg . UseMemoryMgmt , cfg . BarrierDestructor ) , } s . newNode = func ( itm unsafe . Pointer , level int ) * Node { return allocNode ( itm , level , cfg . Malloc ) } if cfg . UseMemoryMgmt { s . freeNode = func ( n * Node ) { if Debug { debugMarkFree ( n ) } cfg . Free ( unsafe . Pointer ( n ) ) } } else { s . freeNode = func ( * Node ) { } } head := allocNode ( minItem , MaxLevel , nil ) tail := allocNode ( maxItem , MaxLevel , nil ) for i := 0 ; i <= MaxLevel ; i ++ { head . setNext ( i , tail , false ) } s . head = head s . tail = tail return s }
7962	func ( s * Skiplist ) FreeNode ( n * Node , sts * Stats ) { s . freeNode ( n ) sts . AddInt64 ( & sts . nodeFrees , 1 ) }
7963	func ( s * Skiplist ) MakeBuf ( ) * ActionBuffer { return & ActionBuffer { preds : make ( [ ] * Node , MaxLevel + 1 ) , succs : make ( [ ] * Node , MaxLevel + 1 ) , } }
7964	func ( s * Skiplist ) Size ( n * Node ) int { return s . ItemSize ( n . Item ( ) ) + n . Size ( ) }
7965	func ( s * Skiplist ) NewLevel ( randFn func ( ) float32 ) int { var nextLevel int for ; randFn ( ) < p ; nextLevel ++ { } if nextLevel > MaxLevel { nextLevel = MaxLevel } level := int ( atomic . LoadInt32 ( & s . level ) ) if nextLevel > level { if atomic . CompareAndSwapInt32 ( & s . level , int32 ( level ) , int32 ( level + 1 ) ) { nextLevel = level + 1 } else { nextLevel = level } } return nextLevel }
7966	func ( s * Skiplist ) Insert ( itm unsafe . Pointer , cmp CompareFn , buf * ActionBuffer , sts * Stats ) ( success bool ) { _ , success = s . Insert2 ( itm , cmp , nil , buf , rand . Float32 , sts ) return }
7967	func ( s * Skiplist ) Insert2 ( itm unsafe . Pointer , inscmp CompareFn , eqCmp CompareFn , buf * ActionBuffer , randFn func ( ) float32 , sts * Stats ) ( * Node , bool ) { itemLevel := s . NewLevel ( randFn ) return s . Insert3 ( itm , inscmp , eqCmp , buf , itemLevel , false , sts ) }
7968	func ( s * Skiplist ) Insert3 ( itm unsafe . Pointer , insCmp CompareFn , eqCmp CompareFn , buf * ActionBuffer , itemLevel int , skipFindPath bool , sts * Stats ) ( * Node , bool ) { token := s . barrier . Acquire ( ) defer s . barrier . Release ( token ) x := s . newNode ( itm , itemLevel ) retry : if skipFindPath { skipFindPath = false } else { if s . findPath ( itm , insCmp , buf , sts ) != nil || eqCmp != nil && compare ( eqCmp , itm , buf . preds [ 0 ] . Item ( ) ) == 0 { s . freeNode ( x ) return nil , false } } for i := 0 ; i <= int ( itemLevel ) ; i ++ { x . setNext ( i , buf . succs [ i ] , false ) } if ! buf . preds [ 0 ] . dcasNext ( 0 , buf . succs [ 0 ] , x , false , false ) { sts . AddUint64 ( & sts . insertConflicts , 1 ) goto retry } for i := 1 ; i <= int ( itemLevel ) ; i ++ { fixThisLevel : for { nodeNext , deleted := x . getNext ( i ) next := buf . succs [ i ] if deleted || ( nodeNext != next && ! x . dcasNext ( i , nodeNext , next , false , false ) ) { goto finished } if buf . preds [ i ] . dcasNext ( i , next , x , false , false ) { break fixThisLevel } s . findPath ( itm , insCmp , buf , sts ) } } finished : sts . AddInt64 ( & sts . nodeAllocs , 1 ) sts . AddInt64 ( & sts . levelNodesCount [ itemLevel ] , 1 ) sts . AddInt64 ( & sts . usedBytes , int64 ( s . Size ( x ) ) ) return x , true }
7969	func ( s * Skiplist ) Delete ( itm unsafe . Pointer , cmp CompareFn , buf * ActionBuffer , sts * Stats ) bool { token := s . barrier . Acquire ( ) defer s . barrier . Release ( token ) found := s . findPath ( itm , cmp , buf , sts ) != nil if ! found { return false } delNode := buf . succs [ 0 ] return s . deleteNode ( delNode , cmp , buf , sts ) }
7970	func ( s * Skiplist ) DeleteNode ( n * Node , cmp CompareFn , buf * ActionBuffer , sts * Stats ) bool { token := s . barrier . Acquire ( ) defer s . barrier . Release ( token ) return s . deleteNode ( n , cmp , buf , sts ) }
7971	func ( s * Skiplist ) GetRangeSplitItems ( nways int ) [ ] unsafe . Pointer { var deleted bool repeat : var itms [ ] unsafe . Pointer var finished bool l := int ( atomic . LoadInt32 ( & s . level ) ) for ; l >= 0 ; l -- { c := int ( atomic . LoadInt64 ( & s . Stats . levelNodesCount [ l ] ) + 1 ) if c >= nways { perSplit := c / nways node := s . head for j := 0 ; node != s . tail && ! finished ; j ++ { if j == perSplit { j = - 1 itms = append ( itms , node . Item ( ) ) finished = len ( itms ) == nways - 1 } node , deleted = node . getNext ( l ) if deleted { goto repeat } } break } } return itms }
7972	func ( itm * Item ) Bytes ( ) ( bs [ ] byte ) { l := itm . dataLen dataOffset := uintptr ( unsafe . Pointer ( itm ) ) + itemHeaderSize hdr := ( * reflect . SliceHeader ) ( unsafe . Pointer ( & bs ) ) hdr . Data = dataOffset hdr . Len = int ( l ) hdr . Cap = hdr . Len return }
7973	func ItemSize ( p unsafe . Pointer ) int { itm := ( * Item ) ( p ) return int ( itemHeaderSize + uintptr ( itm . dataLen ) ) }
7974	func KVFromBytes ( bs [ ] byte ) ( k , v [ ] byte ) { klen := int ( binary . LittleEndian . Uint16 ( bs [ 0 : 2 ] ) ) return bs [ 2 : 2 + klen ] , bs [ 2 + klen : ] }
7975	func CompareKV ( a [ ] byte , b [ ] byte ) int { la := int ( binary . LittleEndian . Uint16 ( a [ 0 : 2 ] ) ) lb := int ( binary . LittleEndian . Uint16 ( b [ 0 : 2 ] ) ) return bytes . Compare ( a [ 2 : 2 + la ] , b [ 2 : 2 + lb ] ) }
7976	func ( e * EventController ) Emit ( b EventBody ) ( int , error ) { var i int event := Event { Header : generateHeader ( ) , Body : b } for _ , h := range e . Handlers { i ++ go h . HandleGomitEvent ( event ) } return i , nil }
7977	func ( e * EventController ) UnregisterHandler ( n string ) error { e . handlerMutex . Lock ( ) delete ( e . Handlers , n ) e . handlerMutex . Unlock ( ) return nil }
7978	func ( e * EventController ) IsHandlerRegistered ( n string ) bool { _ , x := e . Handlers [ n ] return x }
7979	func CompareNitro ( this unsafe . Pointer , that unsafe . Pointer ) int { thisItem := ( * Nitro ) ( this ) thatItem := ( * Nitro ) ( that ) return int ( thisItem . id - thatItem . id ) }
7980	func DefaultConfig ( ) Config { var cfg Config cfg . SetKeyComparator ( defaultKeyCmp ) cfg . fileType = RawdbFile cfg . useMemoryMgmt = false cfg . refreshRate = defaultRefreshRate return cfg }
7981	func ( w * Writer ) Delete ( bs [ ] byte ) ( success bool ) { _ , success = w . Delete2 ( bs ) return }
7982	func ( w * Writer ) GetNode ( bs [ ] byte ) * skiplist . Node { iter := w . store . NewIterator ( w . iterCmp , w . buf ) defer iter . Close ( ) x := w . newItem ( bs , false ) x . bornSn = w . getCurrSn ( ) if found := iter . SeekWithCmp ( unsafe . Pointer ( x ) , w . insCmp , w . existCmp ) ; found { return iter . GetNode ( ) } return nil }
7983	func ( cfg * Config ) SetKeyComparator ( cmp KeyCompare ) { cfg . keyCmp = cmp cfg . insCmp = newInsertCompare ( cmp ) cfg . iterCmp = newIterCompare ( cmp ) cfg . existCmp = newExistCompare ( cmp ) }
7984	func ( cfg * Config ) UseMemoryMgmt ( malloc skiplist . MallocFn , free skiplist . FreeFn ) { if runtime . GOARCH == "amd64" { cfg . useMemoryMgmt = true cfg . mallocFun = malloc cfg . freeFun = free } }
7985	func NewWithConfig ( cfg Config ) * Nitro { m := & Nitro { snapshots : skiplist . New ( ) , gcsnapshots : skiplist . New ( ) , currSn : 1 , Config : cfg , gcchan : make ( chan * skiplist . Node , gcchanBufSize ) , id : int ( atomic . AddInt64 ( & dbInstancesCount , 1 ) ) , } m . freechan = make ( chan * skiplist . Node , gcchanBufSize ) m . store = skiplist . NewWithConfig ( m . newStoreConfig ( ) ) m . initSizeFuns ( ) buf := dbInstances . MakeBuf ( ) defer dbInstances . FreeBuf ( buf ) dbInstances . Insert ( unsafe . Pointer ( m ) , CompareNitro , buf , & dbInstances . Stats ) return m }
7986	func ( m * Nitro ) MemoryInUse ( ) int64 { storeStats := m . aggrStoreStats ( ) return storeStats . Memory + m . snapshots . MemoryInUse ( ) + m . gcsnapshots . MemoryInUse ( ) }
7987	func ( m * Nitro ) Close ( ) { for s := m . snapshots . GetStats ( ) ; int ( s . NodeCount ) != 0 ; s = m . snapshots . GetStats ( ) { time . Sleep ( time . Millisecond ) } m . hasShutdown = true for ! atomic . CompareAndSwapInt32 ( & m . isGCRunning , 0 , 1 ) { time . Sleep ( time . Millisecond ) } close ( m . gcchan ) buf := dbInstances . MakeBuf ( ) defer dbInstances . FreeBuf ( buf ) dbInstances . Delete ( unsafe . Pointer ( m ) , CompareNitro , buf , & dbInstances . Stats ) if m . useMemoryMgmt { buf := m . snapshots . MakeBuf ( ) defer m . snapshots . FreeBuf ( buf ) m . shutdownWg1 . Wait ( ) close ( m . freechan ) m . shutdownWg2 . Wait ( ) iter := m . store . NewIterator ( m . iterCmp , buf ) defer iter . Close ( ) var lastNode * skiplist . Node iter . SeekFirst ( ) if iter . Valid ( ) { lastNode = iter . GetNode ( ) iter . Next ( ) } for lastNode != nil { m . freeItem ( ( * Item ) ( lastNode . Item ( ) ) ) m . store . FreeNode ( lastNode , & m . store . Stats ) lastNode = nil if iter . Valid ( ) { lastNode = iter . GetNode ( ) iter . Next ( ) } } } }
7988	func ( m * Nitro ) NewWriter ( ) * Writer { w := m . newWriter ( ) w . next = m . wlist m . wlist = w w . dwrCtx . Init ( ) m . shutdownWg1 . Add ( 1 ) go m . collectionWorker ( w ) if m . useMemoryMgmt { m . shutdownWg2 . Add ( 1 ) go m . freeWorker ( w ) } return w }
7989	func SnapshotSize ( p unsafe . Pointer ) int { s := ( * Snapshot ) ( p ) return int ( unsafe . Sizeof ( s . sn ) + unsafe . Sizeof ( s . refCount ) + unsafe . Sizeof ( s . db ) + unsafe . Sizeof ( s . count ) + unsafe . Sizeof ( s . gclist ) ) }
7990	func ( s * Snapshot ) Encode ( buf [ ] byte , w io . Writer ) error { l := 4 if len ( buf ) < l { return errNotEnoughSpace } binary . BigEndian . PutUint32 ( buf [ 0 : 4 ] , s . sn ) if _ , err := w . Write ( buf [ 0 : 4 ] ) ; err != nil { return err } return nil }
7991	func ( s * Snapshot ) Decode ( buf [ ] byte , r io . Reader ) error { if _ , err := io . ReadFull ( r , buf [ 0 : 4 ] ) ; err != nil { return err } s . sn = binary . BigEndian . Uint32 ( buf [ 0 : 4 ] ) return nil }
7992	func ( s * Snapshot ) Open ( ) bool { if atomic . LoadInt32 ( & s . refCount ) == 0 { return false } atomic . AddInt32 ( & s . refCount , 1 ) return true }
7993	func CompareSnapshot ( this , that unsafe . Pointer ) int { thisItem := ( * Snapshot ) ( this ) thatItem := ( * Snapshot ) ( that ) return int ( thisItem . sn ) - int ( thatItem . sn ) }
7994	func ( m * Nitro ) GC ( ) { if atomic . CompareAndSwapInt32 ( & m . isGCRunning , 0 , 1 ) { m . collectDead ( ) atomic . CompareAndSwapInt32 ( & m . isGCRunning , 1 , 0 ) } }
7995	func ( m * Nitro ) GetSnapshots ( ) [ ] * Snapshot { var snaps [ ] * Snapshot buf := m . snapshots . MakeBuf ( ) defer m . snapshots . FreeBuf ( buf ) iter := m . snapshots . NewIterator ( CompareSnapshot , buf ) iter . SeekFirst ( ) for ; iter . Valid ( ) ; iter . Next ( ) { snaps = append ( snaps , ( * Snapshot ) ( iter . Get ( ) ) ) } return snaps }
7996	func MemoryInUse ( ) ( sz int64 ) { buf := dbInstances . MakeBuf ( ) defer dbInstances . FreeBuf ( buf ) iter := dbInstances . NewIterator ( CompareNitro , buf ) for iter . SeekFirst ( ) ; iter . Valid ( ) ; iter . Next ( ) { db := ( * Nitro ) ( iter . Get ( ) ) sz += db . MemoryInUse ( ) } return }
7997	func CompareBS ( this , that unsafe . Pointer ) int { thisItm := ( * BarrierSession ) ( this ) thatItm := ( * BarrierSession ) ( that ) return int ( thisItm . seqno ) - int ( thatItm . seqno ) }
7998	func ( ab * AccessBarrier ) Acquire ( ) * BarrierSession { if ab . active { retry : bs := ( * BarrierSession ) ( atomic . LoadPointer ( & ab . session ) ) liveCount := atomic . AddInt32 ( bs . liveCount , 1 ) if liveCount > barrierFlushOffset { ab . Release ( bs ) goto retry } return bs } return nil }
7999	func ( ab * AccessBarrier ) Release ( bs * BarrierSession ) { if ab . active { liveCount := atomic . AddInt32 ( bs . liveCount , - 1 ) if liveCount == barrierFlushOffset { buf := ab . freeq . MakeBuf ( ) defer ab . freeq . FreeBuf ( buf ) if atomic . AddInt32 ( & bs . closed , 1 ) == 1 { ab . freeq . Insert ( unsafe . Pointer ( bs ) , CompareBS , buf , & ab . freeq . Stats ) if atomic . CompareAndSwapInt32 ( & ab . isDestructorRunning , 0 , 1 ) { ab . doCleanup ( ) atomic . CompareAndSwapInt32 ( & ab . isDestructorRunning , 1 , 0 ) } } } } }
8000	func ( ab * AccessBarrier ) FlushSession ( ref unsafe . Pointer ) { if ab . active { ab . Lock ( ) defer ab . Unlock ( ) bsPtr := atomic . LoadPointer ( & ab . session ) newBsPtr := unsafe . Pointer ( newBarrierSession ( ) ) atomic . CompareAndSwapPointer ( & ab . session , bsPtr , newBsPtr ) bs := ( * BarrierSession ) ( bsPtr ) bs . objectRef = ref ab . activeSeqno ++ bs . seqno = ab . activeSeqno atomic . AddInt32 ( bs . liveCount , barrierFlushOffset + 1 ) ab . Release ( bs ) } }
8001	func ( report * StatsReport ) Apply ( s * Stats ) { var totalNextPtrs int var totalNodes int report . ReadConflicts += s . readConflicts report . InsertConflicts += s . insertConflicts for i , c := range s . levelNodesCount { report . NodeDistribution [ i ] += c nodesAtlevel := report . NodeDistribution [ i ] totalNodes += int ( nodesAtlevel ) totalNextPtrs += ( i + 1 ) * int ( nodesAtlevel ) } report . SoftDeletes += s . softDeletes report . NodeCount = totalNodes report . NextPointersPerNode = float64 ( totalNextPtrs ) / float64 ( totalNodes ) report . NodeAllocs += s . nodeAllocs report . NodeFrees += s . nodeFrees report . Memory += s . usedBytes }
8002	func ( s * Stats ) AddInt64 ( src * int64 , val int64 ) { if s . isLocal { * src += val } else { atomic . AddInt64 ( src , val ) } }
8003	func ( s * Stats ) AddUint64 ( src * uint64 , val uint64 ) { if s . isLocal { * src += val } else { atomic . AddUint64 ( src , val ) } }
8004	func ( s * Stats ) Merge ( sts * Stats ) { atomic . AddUint64 ( & s . insertConflicts , sts . insertConflicts ) sts . insertConflicts = 0 atomic . AddUint64 ( & s . readConflicts , sts . readConflicts ) sts . readConflicts = 0 atomic . AddInt64 ( & s . softDeletes , sts . softDeletes ) sts . softDeletes = 0 atomic . AddInt64 ( & s . nodeAllocs , sts . nodeAllocs ) sts . nodeAllocs = 0 atomic . AddInt64 ( & s . nodeFrees , sts . nodeFrees ) sts . nodeFrees = 0 atomic . AddInt64 ( & s . usedBytes , sts . usedBytes ) sts . usedBytes = 0 for i , val := range sts . levelNodesCount { if val != 0 { atomic . AddInt64 ( & s . levelNodesCount [ i ] , val ) sts . levelNodesCount [ i ] = 0 } } }
8005	func ( s * Skiplist ) GetStats ( ) StatsReport { var report StatsReport report . Apply ( & s . Stats ) return report }
8006	func ( s * Skiplist ) NewIterator ( cmp CompareFn , buf * ActionBuffer ) * Iterator { return & Iterator { cmp : cmp , s : s , buf : buf , bs : s . barrier . Acquire ( ) , } }
8007	func ( it * Iterator ) SeekFirst ( ) { it . prev = it . s . head it . curr , _ = it . s . head . getNext ( 0 ) it . valid = true }
8008	func ( it * Iterator ) SeekWithCmp ( itm unsafe . Pointer , cmp CompareFn , eqCmp CompareFn ) bool { var found bool if found = it . s . findPath ( itm , cmp , it . buf , & it . s . Stats ) != nil ; found { it . prev = it . buf . preds [ 0 ] it . curr = it . buf . succs [ 0 ] } else { if found = eqCmp != nil && compare ( eqCmp , itm , it . buf . preds [ 0 ] . Item ( ) ) == 0 ; found { it . prev = nil it . curr = it . buf . preds [ 0 ] } } return found }
8009	func ( it * Iterator ) Seek ( itm unsafe . Pointer ) bool { it . valid = true found := it . s . findPath ( itm , it . cmp , it . buf , & it . s . Stats ) != nil it . prev = it . buf . preds [ 0 ] it . curr = it . buf . succs [ 0 ] return found }
8010	func ( it * Iterator ) Valid ( ) bool { if it . valid && it . curr == it . s . tail { it . valid = false } return it . valid }
8011	func ( it * Iterator ) Delete ( ) { it . s . softDelete ( it . curr , & it . s . Stats ) it . Next ( ) it . deleted = true }
8012	func ( it * Iterator ) Next ( ) { if it . deleted { it . deleted = false return } retry : it . valid = true next , deleted := it . curr . getNext ( 0 ) if deleted { if it . s . helpDelete ( 0 , it . prev , it . curr , next , & it . s . Stats ) { it . curr = next } else { atomic . AddUint64 ( & it . s . Stats . readConflicts , 1 ) found := it . s . findPath ( it . curr . Item ( ) , it . cmp , it . buf , & it . s . Stats ) != nil last := it . curr it . prev = it . buf . preds [ 0 ] it . curr = it . buf . succs [ 0 ] if found && last == it . curr { goto retry } } } else { it . prev = it . curr it . curr = next } }
8013	func Init ( ) { s := new ( SkuM1SmallBuilder ) s . Client , _ = new ( SkuM1Small ) . GetInnkeeperClient ( ) skurepo . Register ( SkuName , s ) }
8014	func FromURL ( url string ) string { result := url for _ , replace := range replaces { result = strings . Replace ( result , replace . a , replace . b , - 1 ) } return result }
8015	func ToURL ( folder string ) string { result := folder for _ , replace := range replaces { result = strings . Replace ( result , replace . b , replace . a , - 1 ) } return result }
8016	func ( t * TupleHeader ) Size ( ) int { return VersionOneTupleHeaderSize + int ( t . FieldSize ) * int ( t . FieldCount ) }
8017	func ( t * TupleHeader ) WriteTo ( w io . Writer ) ( int64 , error ) { if len ( t . Offsets ) != int ( t . FieldCount ) { return 0 , errors . New ( "Invalid Header: Field count does not equal number of field offsets" ) } dst := make ( [ ] byte , t . Size ( ) ) dst [ 0 ] = byte ( t . TupleVersion ) binary . LittleEndian . PutUint32 ( dst [ 1 : ] , t . NamespaceHash ) binary . LittleEndian . PutUint32 ( dst [ 5 : ] , t . Hash ) binary . LittleEndian . PutUint32 ( dst [ 9 : ] , t . FieldCount ) pos := int64 ( 13 ) switch t . FieldSize { case 1 : for _ , offset := range t . Offsets { dst [ pos ] = byte ( offset ) pos ++ } case 2 : dst [ 0 ] |= 64 for _ , offset := range t . Offsets { binary . LittleEndian . PutUint16 ( dst [ pos : ] , uint16 ( offset ) ) pos += 2 } case 4 : dst [ 0 ] |= 128 for _ , offset := range t . Offsets { binary . LittleEndian . PutUint32 ( dst [ pos : ] , uint32 ( offset ) ) pos += 4 } case 8 : dst [ 0 ] |= 192 for _ , offset := range t . Offsets { binary . LittleEndian . PutUint64 ( dst [ pos : ] , offset ) pos += 8 } default : return pos , errors . New ( "Invalid Header: Field size must be 1,2,4 or 8 bytes" ) } n , err := w . Write ( dst ) return int64 ( n ) , err }
8018	func Static ( directory string , staticOpt ... StaticOptions ) Handler { if ! path . IsAbs ( directory ) { directory = path . Join ( Root , directory ) } dir := http . Dir ( directory ) opt := prepareStaticOptions ( staticOpt ) return func ( res http . ResponseWriter , req * http . Request , log * log . Logger ) { if req . Method != "GET" && req . Method != "HEAD" { return } file := req . URL . Path if opt . Prefix != "" { if ! strings . HasPrefix ( file , opt . Prefix ) { return } file = file [ len ( opt . Prefix ) : ] if file != "" && file [ 0 ] != '/' { return } } f , err := dir . Open ( file ) if err != nil { return } defer f . Close ( ) fi , err := f . Stat ( ) if err != nil { return } if fi . IsDir ( ) { if ! strings . HasSuffix ( req . URL . Path , "/" ) { http . Redirect ( res , req , req . URL . Path + "/" , http . StatusFound ) return } file = path . Join ( file , opt . IndexFile ) f , err = dir . Open ( file ) if err != nil { return } defer f . Close ( ) fi , err = f . Stat ( ) if err != nil || fi . IsDir ( ) { return } } if ! opt . SkipLogging { log . Println ( "[Static] Serving " + file ) } if opt . Expires != nil { res . Header ( ) . Set ( "Expires" , opt . Expires ( ) ) } http . ServeContent ( res , req , file , fi . ModTime ( ) , f ) } }
8019	func ( c * Config ) Read ( ) error { in , err := os . Open ( c . filename ) if err != nil { return err } defer in . Close ( ) scanner := bufio . NewScanner ( in ) line := "" section := "" for scanner . Scan ( ) { if scanner . Text ( ) == "" { continue } if line == "" { sec , ok := checkSection ( scanner . Text ( ) ) if ok { section = sec continue } } if checkComment ( scanner . Text ( ) ) { continue } line += scanner . Text ( ) if strings . HasSuffix ( line , "\\" ) \\ { line = line [ : len ( line ) - 1 ] continue } key , value , ok := checkLine ( line ) if ! ok { return errors . New ( "WRONG: " + line ) } c . Set ( section , key , value ) } line = "" }
8020	func ( c * Config ) Del ( section string , key string ) { _ , ok := c . config [ section ] if ok { delete ( c . config [ section ] , key ) if len ( c . config [ section ] ) == 0 { delete ( c . config , section ) } } }
8021	func ( c * Config ) WriteTo ( filename string ) error { content := "" for k , v := range c . config { format := "%v = %v\n" \n if k != "" { content += fmt . Sprintf ( "[%v]\n" , \n ) k } } format = "\t" + \t }
8022	func checkSection ( line string ) ( string , bool ) { line = strings . TrimSpace ( line ) lineLen := len ( line ) if lineLen < 2 { return "" , false } if line [ 0 ] == '[' && line [ lineLen - 1 ] == ']' { return line [ 1 : lineLen - 1 ] , true } return "" , false }
8023	func checkLine ( line string ) ( string , string , bool ) { key := "" value := "" sp := strings . SplitN ( line , "=" , 2 ) if len ( sp ) != 2 { return key , value , false } key = strings . TrimSpace ( sp [ 0 ] ) value = strings . TrimSpace ( sp [ 1 ] ) return key , value , true }
8024	func checkComment ( line string ) bool { line = strings . TrimSpace ( line ) for p := range commentPrefix { if strings . HasPrefix ( line , commentPrefix [ p ] ) { return true } } return false }
8025	func NewResponseWrapper ( w http . ResponseWriter ) * ResponseWrapper { return & ResponseWrapper { ResponseRecorder : httptest . NewRecorder ( ) , writer : w } }
8026	func ( w * ResponseWrapper ) Hijack ( ) ( net . Conn , * bufio . ReadWriter , error ) { if hijacker , ok := w . writer . ( http . Hijacker ) ; ok { c , rw , err := hijacker . Hijack ( ) if err == nil { w . Hijacked = true } return c , rw , err } return nil , nil , errors . New ( "Wrapped ResponseWriter is not a Hijacker" ) }
8027	func ( w * ResponseWrapper ) CloseNotify ( ) <- chan bool { if notifier , ok := w . writer . ( http . CloseNotifier ) ; ok { c := notifier . CloseNotify ( ) return c } return make ( chan bool ) }
8028	func DateFormat ( f string ) Option { return Option { func ( o * options ) { o . dateFormat = f } } }
8029	func Logger ( next http . Handler ) http . HandlerFunc { stdlogger := log . New ( os . Stdout , "" , 0 ) return func ( w http . ResponseWriter , r * http . Request ) { start := time . Now ( ) writer := statusWriter { w , 0 } next . ServeHTTP ( & writer , r ) end := time . Now ( ) latency := end . Sub ( start ) clientIP := r . RemoteAddr method := r . Method statusCode := writer . status statusColor := colorForStatus ( statusCode ) methodColor := colorForMethod ( method ) stdlogger . Printf ( "[HTTP] %v |%s %3d %s| %12v | %s |%s %s %-7s %s\n" , \n , end . Format ( "2006/01/02 - 15:04:05" ) , statusColor , statusCode , reset , latency , clientIP , methodColor , reset , method , ) } }
8030	func GetAvailableInventory ( taskCollection integrations . Collection ) ( inventory map [ string ] skurepo . SkuBuilder ) { inventory = skurepo . GetRegistry ( ) onceLoadInventoryPoller . Do ( func ( ) { startTaskPollingForRegisteredSkus ( taskCollection ) } ) return }
8031	func Expiration ( e time . Duration ) TokenOpt { return TokenOpt { func ( o * options ) { o . expiration = e } } }
8032	func Claimer ( c func ( claims * jwt . StandardClaims ) jwt . Claims ) TokenOpt { return TokenOpt { func ( o * options ) { o . claimer = c } } }
8033	func Issuer ( issuer string ) TokenOpt { return TokenOpt { func ( o * options ) { o . issuer = issuer } } }
8034	func User ( user string ) TokenOpt { return TokenOpt { func ( o * options ) { o . user = user } } }
8035	func Password ( password string ) TokenOpt { return TokenOpt { func ( o * options ) { o . password = password } } }
8036	func Extractor ( e request . Extractor ) TokenOpt { return TokenOpt { func ( o * options ) { o . extractor = e } } }
8037	func TokenGenerator ( h http . Handler , auth Authenticator , secret [ ] byte , opts ... TokenOpt ) http . Handler { o := options { logger : handler . NopLogger ( ) , claimer : func ( c * jwt . StandardClaims ) jwt . Claims { return c } , expiration : time . Hour * 24 * 15 , user : "user" , password : "password" , } o . apply ( opts ) return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { var err error if strings . HasPrefix ( r . Header . Get ( "Content-Type" ) , "multipart/form-data" ) { err = r . ParseMultipartForm ( 0 ) } else { err = r . ParseForm ( ) } if err != nil { o . logger . Print ( "Invalid request form: " , err ) http . Error ( w , err . Error ( ) , http . StatusBadRequest ) return } user := r . FormValue ( o . user ) password := r . FormValue ( o . password ) if user == "" || password == "" || ! auth . Authenticate ( user , password ) { w . WriteHeader ( http . StatusUnauthorized ) return } expiration := time . Now ( ) . Add ( o . expiration ) t := jwt . NewWithClaims ( jwt . SigningMethodHS512 , o . claimer ( & jwt . StandardClaims { Subject : user , ExpiresAt : expiration . Unix ( ) , Issuer : o . issuer , } ) ) if token , err := t . SignedString ( secret ) ; err == nil { if h == nil { w . Header ( ) . Add ( "Authorization" , "Bearer " + token ) w . Write ( [ ] byte ( token ) ) return } r = r . WithContext ( context . WithValue ( r . Context ( ) , TokenKey , token ) ) h . ServeHTTP ( w , r ) } else { o . logger . Print ( "Error authenticating user:" , err ) w . WriteHeader ( http . StatusInternalServerError ) return } } ) }
8038	func Token ( r * http . Request ) string { if token , ok := r . Context ( ) . Value ( TokenKey ) . ( string ) ; ok { return token } return "" }
8039	func Claims ( r * http . Request ) jwt . Claims { if claims , ok := r . Context ( ) . Value ( ClaimsKey ) . ( jwt . Claims ) ; ok { return claims } return nil }
8040	func ( t Token ) String ( ) string { switch t . Type { case TokenEOF : return "EOF" case TokenError : return t . Value } if len ( t . Value ) > 10 { return fmt . Sprintf ( "%.25q..." , t . Value ) } return fmt . Sprintf ( "%q" , t . Value ) }
8041	func NewLexer ( name , input string , h Handler ) * Lexer { return & Lexer { Name : name , input : input + "\n" , \n , state : lexText , } }
8042	func ( l * Lexer ) run ( ) { for state := lexText ; state != nil ; { state = state ( l ) } }
8043	func ( l * Lexer ) emit ( t TokenType ) { if l . Pos == l . Start { return } tok := Token { t , l . input [ l . Start : l . Pos ] } l . handler ( tok ) l . Start = l . Pos }
8044	func ( l * Lexer ) skipWhitespace ( ) { for unicode . Is ( unicode . White_Space , l . next ( ) ) { } l . backup ( ) l . ignore ( ) }
8045	func ( l * Lexer ) next ( ) ( r rune ) { if l . Pos >= len ( l . input ) { l . Width = 0 return eof } r , l . Width = utf8 . DecodeRuneInString ( l . remaining ( ) ) l . advance ( l . Width ) return }
8046	func ( l * Lexer ) LineNum ( ) int { return strings . Count ( l . input [ : l . Pos ] , "\n" ) }
8047	func ( l * Lexer ) Offset ( ) int { lineoffset := strings . LastIndex ( l . input [ : l . Pos ] , "\n" ) \n if lineoffset != - 1 { return l . Pos - lineoffset } }
8048	func ( l * Lexer ) errorf ( format string , args ... interface { } ) stateFn { l . handler ( Token { TokenError , fmt . Sprintf ( fmt . Sprintf ( "%s[%d:%d] " , l . Name , l . LineNum ( ) , l . Offset ( ) ) + format , args ... ) } ) return nil }
8049	func lexText ( l * Lexer ) stateFn { OUTER : for { l . skipWhitespace ( ) remaining := l . remaining ( ) if strings . HasPrefix ( remaining , comment ) { return lexComment } else if strings . HasPrefix ( remaining , pkg ) { return lexPackage } else if strings . HasPrefix ( remaining , from ) { return lexFrom } else if strings . HasPrefix ( remaining , typeDef ) { return lexTypeDef } else if strings . HasPrefix ( remaining , version ) { return lexVersion } else if strings . HasPrefix ( remaining , required ) { l . Pos += len ( required ) l . emit ( TokenRequired ) l . skipWhitespace ( ) return lexType } else if strings . HasPrefix ( remaining , optional ) { l . Pos += len ( optional ) l . emit ( TokenOptional ) l . skipWhitespace ( ) return lexType } else if strings . HasPrefix ( remaining , openScope ) { l . Pos += len ( openScope ) l . emit ( TokenOpenCurlyBracket ) } else if strings . HasPrefix ( remaining , closeScope ) { l . Pos += len ( closeScope ) l . emit ( TokenCloseCurlyBracket ) } else { switch r := l . next ( ) ; { case r == eof : l . emit ( TokenEOF ) break OUTER default : l . errorf ( "unknown token: %#v" , string ( r ) ) } } } return nil }
8050	func lexComment ( l * Lexer ) stateFn { l . skipWhitespace ( ) l . Pos += len ( comment ) if index := strings . Index ( l . remaining ( ) , "\n" ) ; \n index > 0 else { l . Pos += index } { l . Pos += len ( l . remaining ( ) ) } l . emit ( TokenComment ) l . skipWhitespace ( ) }
8051	func New ( namespace string , name string ) ( t TupleType ) { hash := syncHash . Hash ( [ ] byte ( name ) ) ns_hash := syncHash . Hash ( [ ] byte ( namespace ) ) t = TupleType { namespace , name , ns_hash , hash , make ( [ ] [ ] Field , 0 ) , make ( map [ string ] int ) } return }
8052	func ( t * TupleType ) AddVersion ( fields ... Field ) { t . versions = append ( t . versions , fields ) for _ , field := range fields { t . fields [ field . Name ] = len ( t . fields ) } }
8053	func ( t * TupleType ) Contains ( field string ) bool { _ , exists := t . fields [ field ] return exists }
8054	func ( t * TupleType ) Offset ( field string ) ( offset int , exists bool ) { offset , exists = t . fields [ field ] return }
8055	func ( t * TupleType ) Versions ( ) ( vers [ ] Version ) { vers = make ( [ ] Version , t . NumVersions ( ) ) for i := 0 ; i < t . NumVersions ( ) ; i ++ { vers [ i ] = Version { uint8 ( i + 1 ) , t . versions [ i ] } } return }
8056	func ( s * Task ) SetPrivateMeta ( name string , value interface { } ) { if s . PrivateMetaData == nil { s . PrivateMetaData = make ( map [ string ] interface { } ) } s . PrivateMetaData [ name ] = value }
8057	func ( s * Task ) SetPublicMeta ( name string , value interface { } ) { if s . MetaData == nil { s . MetaData = make ( map [ string ] interface { } ) } s . MetaData [ name ] = value }
8058	func ( s * Task ) GetRedactedVersion ( ) RedactedTask { s . mutex . RLock ( ) rt := RedactedTask { ID : s . ID , Timestamp : s . Timestamp , Expires : s . Expires , Status : s . Status , Profile : s . Profile , CallerName : s . CallerName , MetaData : s . MetaData , } s . mutex . RUnlock ( ) return rt }
8059	func ( s Task ) Equal ( b Task ) bool { return ( s . ID == b . ID && s . Timestamp == b . Timestamp && s . Expires == b . Expires && s . Status == b . Status && s . Profile == b . Profile && s . CallerName == b . CallerName ) }
8060	func HTTP ( h http . Handler , verb Verb , verbs ... Verb ) http . Handler { verbSet := map [ Verb ] struct { } { verb : struct { } { } } for _ , v := range verbs { verbSet [ v ] = struct { } { } } return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { if _ , ok := verbSet [ Verb ( r . Method ) ] ; ok { h . ServeHTTP ( w , r ) } else { w . WriteHeader ( http . StatusBadRequest ) } } ) }
8061	func ( b * TupleBuilder ) PutUint8 ( field string , value uint8 ) ( wrote uint64 , err error ) { if err = b . typeCheck ( field , Uint8Field ) ; err != nil { return 0 , err } if b . available ( ) < 2 { return 0 , xbinary . ErrOutOfRange } b . buffer [ b . pos ] = byte ( UnsignedInt8Code . OpCode ) b . buffer [ b . pos + 1 ] = byte ( value ) b . offsets [ field ] = b . pos b . pos += 2 return 2 , nil }
8062	func ( b * TupleBuilder ) PutInt8 ( field string , value int8 ) ( wrote uint64 , err error ) { if err = b . typeCheck ( field , Int8Field ) ; err != nil { return 0 , err } if b . available ( ) < 2 { return 0 , xbinary . ErrOutOfRange } b . buffer [ b . pos ] = byte ( Int8Code . OpCode ) b . buffer [ b . pos + 1 ] = byte ( value ) b . offsets [ field ] = b . pos b . pos += 2 return 2 , nil }
8063	func ( b * TupleBuilder ) PutUint16 ( field string , value uint16 ) ( wrote uint64 , err error ) { if err = b . typeCheck ( field , Uint16Field ) ; err != nil { return 0 , err } if value < math . MaxUint8 { if b . available ( ) < 2 { return 0 , xbinary . ErrOutOfRange } b . buffer [ b . pos ] = byte ( UnsignedShort8Code . OpCode ) b . buffer [ b . pos + 1 ] = byte ( value ) b . offsets [ field ] = b . pos b . pos += 2 return 2 , nil } wrote , err = xbinary . LittleEndian . PutUint16 ( b . buffer , b . pos + 1 , value ) if err != nil { return 0 , err } b . buffer [ b . pos ] = byte ( UnsignedShort16Code . OpCode ) b . offsets [ field ] = b . pos b . pos += 3 return 3 , nil }
8064	func ( b * TupleBuilder ) PutInt16 ( field string , value int16 ) ( wrote uint64 , err error ) { if err = b . typeCheck ( field , Int16Field ) ; err != nil { return 0 , err } if uint16 ( value ) < math . MaxUint8 { if b . available ( ) < 2 { return 0 , xbinary . ErrOutOfRange } b . buffer [ b . pos ] = byte ( Short8Code . OpCode ) b . buffer [ b . pos + 1 ] = byte ( value ) b . offsets [ field ] = b . pos b . pos += 2 return 2 , nil } wrote , err = xbinary . LittleEndian . PutInt16 ( b . buffer , b . pos + 1 , value ) if err != nil { return 0 , err } b . buffer [ b . pos ] = byte ( Short16Code . OpCode ) b . offsets [ field ] = b . pos b . pos += 3 return 3 , nil }
8065	func ( b * TupleBuilder ) PutUint32 ( field string , value uint32 ) ( wrote uint64 , err error ) { if err = b . typeCheck ( field , Uint32Field ) ; err != nil { return 0 , err } if value < math . MaxUint8 { if b . available ( ) < 2 { return 0 , xbinary . ErrOutOfRange } b . buffer [ b . pos ] = byte ( UnsignedInt8Code . OpCode ) b . buffer [ b . pos + 1 ] = byte ( value ) b . offsets [ field ] = b . pos b . pos += 2 return 2 , nil } else if value < math . MaxUint16 { wrote , err = xbinary . LittleEndian . PutUint16 ( b . buffer , b . pos + 1 , uint16 ( value ) ) if err != nil { return 0 , err } b . buffer [ b . pos ] = byte ( UnsignedInt16Code . OpCode ) b . offsets [ field ] = b . pos b . pos += 3 return 3 , nil } wrote , err = xbinary . LittleEndian . PutUint32 ( b . buffer , b . pos + 1 , value ) if err != nil { return 0 , err } b . buffer [ b . pos ] = byte ( UnsignedInt32Code . OpCode ) b . offsets [ field ] = b . pos b . pos += 5 return 5 , nil }
8066	func ( b * TupleBuilder ) PutInt32 ( field string , value int32 ) ( wrote uint64 , err error ) { if err = b . typeCheck ( field , Int32Field ) ; err != nil { return 0 , err } unsigned := uint32 ( value ) if unsigned < math . MaxUint8 { if b . available ( ) < 2 { return 0 , xbinary . ErrOutOfRange } b . buffer [ b . pos ] = byte ( Int8Code . OpCode ) b . buffer [ b . pos + 1 ] = byte ( value ) b . offsets [ field ] = b . pos b . pos += 2 return 2 , nil } else if unsigned < math . MaxUint16 { wrote , err = xbinary . LittleEndian . PutInt16 ( b . buffer , b . pos + 1 , int16 ( value ) ) if err != nil { return 0 , err } b . buffer [ b . pos ] = byte ( Int16Code . OpCode ) b . offsets [ field ] = b . pos b . pos += 3 return 3 , nil } wrote , err = xbinary . LittleEndian . PutInt32 ( b . buffer , b . pos + 1 , value ) if err != nil { return 0 , err } b . buffer [ b . pos ] = byte ( Int32Code . OpCode ) b . offsets [ field ] = b . pos b . pos += 5 return 5 , nil }
8067	func ( b * TupleBuilder ) PutUint64 ( field string , value uint64 ) ( wrote uint64 , err error ) { if err = b . typeCheck ( field , Uint64Field ) ; err != nil { return 0 , err } if value < math . MaxUint8 { if b . available ( ) < 2 { return 0 , xbinary . ErrOutOfRange } b . buffer [ b . pos ] = byte ( UnsignedLong8Code . OpCode ) b . buffer [ b . pos + 1 ] = byte ( value ) b . offsets [ field ] = b . pos b . pos += 2 return 2 , nil } else if value < math . MaxUint16 { wrote , err = xbinary . LittleEndian . PutUint16 ( b . buffer , b . pos + 1 , uint16 ( value ) ) if err != nil { return 0 , err } b . buffer [ b . pos ] = byte ( UnsignedLong16Code . OpCode ) b . offsets [ field ] = b . pos b . pos += 3 return 3 , nil } else if value < math . MaxUint32 { wrote , err = xbinary . LittleEndian . PutUint32 ( b . buffer , b . pos + 1 , uint32 ( value ) ) if err != nil { return 0 , err } b . buffer [ b . pos ] = byte ( UnsignedLong32Code . OpCode ) b . offsets [ field ] = b . pos b . pos += 5 return 5 , nil } wrote , err = xbinary . LittleEndian . PutUint64 ( b . buffer , b . pos + 1 , value ) if err != nil { return 0 , err } b . buffer [ b . pos ] = byte ( UnsignedLong64Code . OpCode ) b . offsets [ field ] = b . pos b . pos += 9 return 9 , nil }
8068	func ( b * TupleBuilder ) PutInt64 ( field string , value int64 ) ( wrote uint64 , err error ) { if err = b . typeCheck ( field , Int64Field ) ; err != nil { return 0 , err } unsigned := uint64 ( value ) if unsigned < math . MaxUint8 { if b . available ( ) < 2 { return 0 , xbinary . ErrOutOfRange } b . buffer [ b . pos ] = byte ( Long8Code . OpCode ) b . buffer [ b . pos + 1 ] = byte ( value ) b . offsets [ field ] = b . pos b . pos += 2 return 2 , nil } else if unsigned < math . MaxUint16 { wrote , err = xbinary . LittleEndian . PutInt16 ( b . buffer , b . pos + 1 , int16 ( value ) ) if err != nil { return 0 , err } b . buffer [ b . pos ] = byte ( Long16Code . OpCode ) b . offsets [ field ] = b . pos b . pos += 3 return 3 , nil } else if unsigned < math . MaxUint32 { wrote , err = xbinary . LittleEndian . PutInt32 ( b . buffer , b . pos + 1 , int32 ( value ) ) if err != nil { return 0 , err } b . buffer [ b . pos ] = byte ( Long32Code . OpCode ) b . offsets [ field ] = b . pos b . pos += 5 return 5 , nil } wrote , err = xbinary . LittleEndian . PutInt64 ( b . buffer , b . pos + 1 , value ) if err != nil { return 0 , err } b . buffer [ b . pos ] = byte ( Long64Code . OpCode ) b . offsets [ field ] = b . pos b . pos += 9 return 9 , nil }
8069	func NewPackageList ( ) PackageList { var lock sync . Mutex return & packageList { make ( map [ string ] Package ) , lock } }
8070	func ( b * TupleBuilder ) PutFloat32 ( field string , value float32 ) ( wrote uint64 , err error ) { if err = b . typeCheck ( field , Float32Field ) ; err != nil { return 0 , err } wrote , err = xbinary . LittleEndian . PutFloat32 ( b . buffer , b . pos + 1 , value ) if err != nil { return 0 , err } b . buffer [ b . pos ] = byte ( FloatCode . OpCode ) b . offsets [ field ] = b . pos b . pos += 5 return 5 , nil }
8071	func Classic ( ) * ClassicMartini { r := NewRouter ( ) m := New ( ) m . Use ( Logger ( ) ) m . Use ( Recovery ( ) ) m . Use ( Static ( "static" ) ) m . Use ( ContextRender ( "" , RenderOptions { Extensions : [ ] string { ".html" , ".tmpl" , "tpl" } , } ) ) m . MapTo ( r , ( * Routes ) ( nil ) ) m . Action ( r . Handle ) return & ClassicMartini { m , r } }
8072	func Languages ( tags [ ] xlang . Tag ) Option { return Option { func ( o * options ) { o . languages = tags } } }
8073	func Session ( s handler . Session ) Option { return Option { func ( o * options ) { o . session = s } } }
8074	func Data ( r * http . Request ) ContextValue { if v , ok := r . Context ( ) . Value ( ContextKey ) . ( ContextValue ) ; ok { return v } return ContextValue { } }
8075	func URL ( url , prefix string , data ContextValue ) string { if data . Current . IsRoot ( ) { return url } if prefix == "" { prefix = "/" } else if prefix [ len ( prefix ) - 1 ] != '/' { prefix += "/" } if url == "" { url = "/" } if url [ 0 ] != '/' { url = "/" + url } return prefix + data . Current . String ( ) + url }
8076	func Size ( ) ( w , h int , err error ) { if ! IsInit { err = errors . New ( "termsize not yet iniitialied" ) return } return get_size ( ) }
8077	func GetRequestIDFromTaskResponse ( taskResponse TaskResponse ) ( requestID string , err error ) { var provisionHostInfoBytes [ ] byte firstRecordIndex := 0 meta := taskResponse . MetaData provisionHostInfo := ProvisionHostInfo { } lo . G . Debug ( "taskResponse: " , taskResponse ) lo . G . Debug ( "metadata: " , meta ) if provisionHostInfoBytes , err = json . Marshal ( meta [ ProvisionHostInformationFieldname ] ) ; err == nil { if err = json . Unmarshal ( provisionHostInfoBytes , & provisionHostInfo ) ; err == nil { if len ( provisionHostInfo . Data ) > firstRecordIndex { requestID = provisionHostInfo . Data [ firstRecordIndex ] . RequestID } else { lo . G . Error ( "no request id found in: " , provisionHostInfo ) } } else { lo . G . Error ( "error unmarshalling: " , err , meta ) lo . G . Error ( "metadata: " , meta ) } } else { lo . G . Error ( "error marshalling: " , err ) } return }
8078	func ( b * TupleBuilder ) PutString ( field string , value string ) ( wrote int , err error ) { if err = b . typeCheck ( field , StringField ) ; err != nil { return 0 , err } size := len ( value ) if size < math . MaxUint8 { if b . available ( ) < size + 2 { return 0 , xbinary . ErrOutOfRange } xbinary . LittleEndian . PutString ( b . buffer , b . pos + 2 , value ) b . buffer [ b . pos ] = byte ( String8Code . OpCode ) b . buffer [ b . pos + 1 ] = byte ( size ) wrote += size + 2 } else if size < math . MaxUint16 { if b . available ( ) < size + 3 { return 0 , xbinary . ErrOutOfRange } xbinary . LittleEndian . PutUint16 ( b . buffer , b . pos + 1 , uint16 ( size ) ) xbinary . LittleEndian . PutString ( b . buffer , b . pos + 3 , value ) b . buffer [ b . pos ] = byte ( String16Code . OpCode ) wrote += 3 + size } else if size < math . MaxUint32 { if b . available ( ) < size + 5 { return 0 , xbinary . ErrOutOfRange } xbinary . LittleEndian . PutUint32 ( b . buffer , b . pos + 1 , uint32 ( size ) ) xbinary . LittleEndian . PutString ( b . buffer , b . pos + 5 , value ) b . buffer [ b . pos ] = byte ( String32Code . OpCode ) wrote += 5 + size } else { if b . available ( ) < size + 9 { return 0 , xbinary . ErrOutOfRange } xbinary . LittleEndian . PutUint64 ( b . buffer , b . pos + 1 , uint64 ( size ) ) xbinary . LittleEndian . PutString ( b . buffer , b . pos + 9 , value ) b . buffer [ b . pos ] = byte ( String64Code . OpCode ) wrote += 9 + size } b . offsets [ field ] = b . pos b . pos += wrote return }
8079	func LoadDirectory ( dir string , parser Parser ) ( err error ) { d , err := os . Open ( dir ) if err != nil { return } for { if fis , err := d . Readdir ( 128 ) ; err == nil { for _ , fi := range fis { switch fi . IsDir ( ) { case true : if err := LoadDirectory ( fi . Name ( ) , parser ) ; err != nil { return err } case false : if ! strings . HasSuffix ( fi . Name ( ) , ".ent" ) { break } if _ , err := LoadFile ( filepath . Join ( dir , fi . Name ( ) ) , parser ) ; err != nil { return err } } } } else if err == io . EOF { break } else { return err } } return nil }
8080	func LoadFile ( filename string , parser Parser ) ( Package , error ) { file , err := os . Open ( filename ) if err != nil { return Package { } , err } defer file . Close ( ) bytes , err := ioutil . ReadAll ( file ) if err != nil { return Package { } , err } return parser . Parse ( file . Name ( ) , string ( bytes ) ) }
8081	func LoadPackage ( parser Parser , name , text string ) ( Package , error ) { return parser . Parse ( name , text ) }
8082	func NewDecoder ( reg Registry , r io . Reader ) Decoder { var buf [ ] byte return decoder { reg , DefaultMaxSize , bytes . NewBuffer ( buf ) , bufio . NewReader ( r ) } }
8083	func NewDecoderSize ( reg Registry , maxSize uint64 , r io . Reader ) Decoder { var buf [ ] byte return decoder { reg , maxSize , bytes . NewBuffer ( buf ) , bufio . NewReader ( r ) } }
8084	func Panic ( h http . Handler , opts ... Option ) http . Handler { o := options { logger : handler . ErrLogger ( ) , dateFormat : PanicDateFormat } o . apply ( opts ) return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { defer func ( ) { if rec := recover ( ) ; rec != nil { stack := debug . Stack ( ) timestamp := time . Now ( ) . Format ( o . dateFormat ) message := fmt . Sprintf ( "%s - %s\n%s\n" , \n , \n , timestamp ) rec stack o . logger . Print ( message ) w . WriteHeader ( http . StatusInternalServerError ) } } if ! o . showStack { message = "Internal Server Error" } w . Write ( [ ] byte ( message ) ) } ) }
8085	func ( s * FakeVCDClient ) DeployVApp ( templateName , templateHref , vcdHref string ) ( vapp * vcloudclient . VApp , err error ) { return s . FakeVApp , s . ErrUnDeployFake }
8086	func ( s * FakeVCDClient ) UnDeployVApp ( vappID string ) ( task * vcloudclient . TaskElem , err error ) { return & s . FakeVApp . Tasks . Task , s . ErrDeployFake }
8087	func ( s * FakeVCDClient ) Auth ( username , password string ) ( err error ) { return s . ErrAuthFake }
8088	func ( s * FakeVCDClient ) QueryTemplate ( templateName string ) ( vappTemplate * vcloudclient . VAppTemplateRecord , err error ) { return s . FakeVAppTemplateRecord , s . ErrDeployFake }
8089	func NewEncoder ( w io . Writer ) Encoder { return versionOneEncoder { w , make ( [ ] byte , 9 ) , bytes . NewBuffer ( make ( [ ] byte , 0 , 4096 ) ) } }
8090	func Getter ( g NonceGetter ) Option { return Option { func ( o * options ) { o . getter = g } } }
8091	func Setter ( s NonceSetter ) Option { return Option { func ( o * options ) { o . setter = s } } }
8092	func Age ( age time . Duration ) Option { return Option { func ( o * options ) { o . age = age } } }
8093	func Nonce ( h http . Handler , opts ... Option ) http . Handler { headerStorage := nonceHeaderStorage { } o := options { logger : handler . OutLogger ( ) , generator : timeRandomGenerator , getter : headerStorage , setter : headerStorage , age : 45 * time . Second , } o . apply ( opts ) store := nonceStore { } opChan := make ( chan func ( nonceStore ) ) go func ( ) { for op := range opChan { op ( store ) } } ( ) go func ( ) { for { select { case <- time . After ( 5 * time . Minute ) : cleanup ( o . age , opChan ) } } } ( ) setter := func ( w http . ResponseWriter , r * http . Request ) error { nonce , err := generateAndStore ( o . age , o . generator , opChan ) if err != nil { return err } return o . setter . SetNonce ( nonce , w , r ) } return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { ctx := r . Context ( ) nonce := o . getter . GetNonce ( r ) if nonce != "" { if validateAndRemoveNonce ( nonce , o . age , opChan ) { ctx = context . WithValue ( ctx , nonceValueKey , NonceStatus { NonceValid } ) } else { ctx = context . WithValue ( ctx , nonceValueKey , NonceStatus { NonceInvalid } ) } } h . ServeHTTP ( w , r . WithContext ( context . WithValue ( ctx , nonceSetterKey , setter ) ) ) } ) }
8094	func NonceValueFromRequest ( r * http . Request ) NonceStatus { if c := r . Context ( ) . Value ( nonceValueKey ) ; c != nil { if v , ok := c . ( NonceStatus ) ; ok { return v } } return NonceStatus { NonceNotRequested } }
8095	func StoreNonce ( w http . ResponseWriter , r * http . Request ) ( err error ) { if c := r . Context ( ) . Value ( nonceSetterKey ) ; c != nil { if setter , ok := c . ( func ( http . ResponseWriter , * http . Request ) error ) ; ok { err = setter ( w , r ) } } return err }
8096	func ( b * TupleBuilder ) PutFloat32Array ( field string , value [ ] float32 ) ( wrote int , err error ) { if err = b . typeCheck ( field , Float32ArrayField ) ; err != nil { return 0 , err } size := len ( value ) if size < math . MaxUint8 { if b . available ( ) < size * 4 + 2 { return 0 , xbinary . ErrOutOfRange } xbinary . LittleEndian . PutFloat32Array ( b . buffer , b . pos + 2 , value ) b . buffer [ b . pos ] = byte ( FloatArray8Code . OpCode ) b . buffer [ b . pos + 1 ] = byte ( size ) wrote += size + 2 } else if size < math . MaxUint16 { if b . available ( ) < size * 4 + 3 { return 0 , xbinary . ErrOutOfRange } xbinary . LittleEndian . PutUint16 ( b . buffer , b . pos + 1 , uint16 ( size ) ) xbinary . LittleEndian . PutFloat32Array ( b . buffer , b . pos + 3 , value ) b . buffer [ b . pos ] = byte ( FloatArray16Code . OpCode ) wrote += 3 + size } else if size < math . MaxUint32 { if b . available ( ) < size * 4 + 5 { return 0 , xbinary . ErrOutOfRange } xbinary . LittleEndian . PutUint32 ( b . buffer , b . pos + 1 , uint32 ( size ) ) xbinary . LittleEndian . PutFloat32Array ( b . buffer , b . pos + 5 , value ) b . buffer [ b . pos ] = byte ( FloatArray32Code . OpCode ) wrote += 5 + size } else { if b . available ( ) < size * 4 + 9 { return 0 , xbinary . ErrOutOfRange } xbinary . LittleEndian . PutUint64 ( b . buffer , b . pos + 1 , uint64 ( size ) ) xbinary . LittleEndian . PutFloat32Array ( b . buffer , b . pos + 9 , value ) b . buffer [ b . pos ] = byte ( FloatArray64Code . OpCode ) wrote += 9 + size } b . offsets [ field ] = b . pos b . pos += wrote return }
8097	func ( b * TupleBuilder ) PutFloat64Array ( field string , value [ ] float64 ) ( wrote int , err error ) { if err = b . typeCheck ( field , Float64ArrayField ) ; err != nil { return 0 , err } size := len ( value ) if size < math . MaxUint8 { if b . available ( ) < size * 8 + 2 { return 0 , xbinary . ErrOutOfRange } xbinary . LittleEndian . PutFloat64Array ( b . buffer , b . pos + 2 , value ) b . buffer [ b . pos ] = byte ( DoubleArray8Code . OpCode ) b . buffer [ b . pos + 1 ] = byte ( size ) wrote += size + 2 } else if size < math . MaxUint16 { if b . available ( ) < size * 8 + 3 { return 0 , xbinary . ErrOutOfRange } xbinary . LittleEndian . PutUint16 ( b . buffer , b . pos + 1 , uint16 ( size ) ) xbinary . LittleEndian . PutFloat64Array ( b . buffer , b . pos + 3 , value ) b . buffer [ b . pos ] = byte ( DoubleArray16Code . OpCode ) wrote += 3 + size } else if size < math . MaxUint32 { if b . available ( ) < size * 8 + 5 { return 0 , xbinary . ErrOutOfRange } xbinary . LittleEndian . PutUint32 ( b . buffer , b . pos + 1 , uint32 ( size ) ) xbinary . LittleEndian . PutFloat64Array ( b . buffer , b . pos + 5 , value ) b . buffer [ b . pos ] = byte ( DoubleArray32Code . OpCode ) wrote += 5 + size } else { if b . available ( ) < size * 8 + 9 { return 0 , xbinary . ErrOutOfRange } xbinary . LittleEndian . PutUint64 ( b . buffer , b . pos + 1 , uint64 ( size ) ) xbinary . LittleEndian . PutFloat64Array ( b . buffer , b . pos + 9 , value ) b . buffer [ b . pos ] = byte ( DoubleArray64Code . OpCode ) wrote += 9 + size } b . offsets [ field ] = b . pos b . pos += wrote return }
8098	func ( s * ClientDoer ) Do ( req * http . Request ) ( resp * http . Response , err error ) { s . SpyRequest = * req return s . Response , s . Error }
8099	func NewLease ( taskCollection integrations . Collection , availableSkus map [ string ] skurepo . SkuBuilder ) * Lease { return & Lease { taskCollection : taskCollection , taskManager : taskmanager . NewTaskManager ( taskCollection ) , availableSkus : availableSkus , Task : taskmanager . RedactedTask { } , } }
8100	func ( s * Lease ) Delete ( logger * log . Logger , req * http . Request ) ( statusCode int , response interface { } ) { var ( err error ) statusCode = http . StatusNotFound s . taskCollection . Wake ( ) if err = s . InitFromHTTPRequest ( req ) ; err == nil { logger . Println ( "restocking inventory..." ) s . ReStock ( ) statusCode = http . StatusAccepted response = s . Task } else { response = map [ string ] string { "error" : err . Error ( ) } } return }
8101	func ( s * Lease ) Post ( logger * log . Logger , req * http . Request ) ( statusCode int , response interface { } ) { var ( err error ) statusCode = http . StatusNotFound s . taskCollection . Wake ( ) logger . Println ( "collection dialed successfully" ) if err = s . InitFromHTTPRequest ( req ) ; err == nil { logger . Println ( "obtaining lease..." , s ) s . Procurement ( ) statusCode = http . StatusCreated response = s . Task } else { response = map [ string ] string { "error" : err . Error ( ) } } return }
8102	func ( s * Lease ) ReStock ( ) ( skuTask * taskmanager . Task ) { if skuConstructor , ok := s . availableSkus [ s . Sku ] ; ok { leaseMap := structs . Map ( s ) sku := skuConstructor . New ( s . taskManager , leaseMap ) skuTask = sku . ReStock ( ) s . Task = skuTask . GetRedactedVersion ( ) } else { s . Task . Status = TaskStatusUnavailable } return }
8103	func ( s * Lease ) Procurement ( ) ( skuTask * taskmanager . Task ) { if skuConstructor , ok := s . availableSkus [ s . Sku ] ; ok { leaseMap := structs . Map ( s ) sku := skuConstructor . New ( s . taskManager , leaseMap ) GLogger . Println ( "here is my sku: " , sku ) skuTask = sku . Procurement ( ) tt := skuTask . Read ( func ( t * taskmanager . Task ) interface { } { tt := * t return tt } ) GLogger . Println ( "here is my task after procurement: " , tt ) s . Task = skuTask . GetRedactedVersion ( ) } else { GLogger . Println ( "No Sku Match: " , s . Sku , s . availableSkus ) s . Task . Status = TaskStatusUnavailable } return }
8104	func ( s * Lease ) InitFromHTTPRequest ( req * http . Request ) ( err error ) { if req . Body != nil { if body , err := ioutil . ReadAll ( req . Body ) ; err == nil { if err = json . Unmarshal ( body , s ) ; err != nil { GLogger . Println ( err ) } } } else { err = ErrEmptyBody } if s . ProcurementMeta == nil { s . ProcurementMeta = make ( map [ string ] interface { } ) } return }
8105	func ( t * Tuple ) Is ( tupleType TupleType ) bool { return t . Header . Hash == tupleType . Hash && t . Header . NamespaceHash == tupleType . NamespaceHash }
8106	func ( t * Tuple ) Offset ( field string ) ( int , error ) { index , exists := t . Header . Type . Offset ( field ) if ! exists { return 0 , ErrFieldDoesNotExist } if index < 0 || index >= int ( t . Header . FieldCount ) { return 0 , ErrInvalidFieldIndex } return int ( t . Header . Offsets [ index ] ) , nil }
8107	func ( t Tuple ) WriteTo ( w io . Writer ) ( n int , err error ) { wrote , err := t . Header . WriteTo ( w ) if err != nil { return int ( wrote ) , nil } n , err = w . Write ( t . data ) if err != nil { return int ( n ) , err } return int ( wrote ) + n , nil }
8108	func ( b * TupleBuilder ) PutTuple ( field string , value Tuple ) ( wrote int , err error ) { if err = b . typeCheck ( field , TupleField ) ; err != nil { return 0 , err } size := value . Size ( ) + value . Header . Size ( ) if size < math . MaxUint8 { if b . available ( ) < size + 2 { return 0 , xbinary . ErrOutOfRange } b . buffer [ b . pos ] = byte ( Tuple8Code . OpCode ) b . buffer [ b . pos + 1 ] = byte ( size ) wrote += 2 n , err := b . writeTuple ( value , b . pos + wrote , size ) wrote += int ( n ) if err != nil { return 0 , err } } else if size < math . MaxUint16 { if b . available ( ) < size + 3 { return 0 , xbinary . ErrOutOfRange } b . buffer [ b . pos ] = byte ( Tuple16Code . OpCode ) xbinary . LittleEndian . PutUint16 ( b . buffer , b . pos + 1 , uint16 ( size ) ) wrote += 3 n , err := b . writeTuple ( value , b . pos + wrote , size ) wrote += int ( n ) if err != nil { return 0 , err } } else if size < math . MaxUint32 { if b . available ( ) < size + 5 { return 0 , xbinary . ErrOutOfRange } b . buffer [ b . pos ] = byte ( Tuple32Code . OpCode ) xbinary . LittleEndian . PutUint32 ( b . buffer , b . pos + 1 , uint32 ( size ) ) wrote += 5 n , err := b . writeTuple ( value , b . pos + wrote , size ) wrote += int ( n ) if err != nil { return 0 , err } } else { if b . available ( ) < size + 9 { return 0 , xbinary . ErrOutOfRange } b . buffer [ b . pos ] = byte ( Tuple64Code . OpCode ) xbinary . LittleEndian . PutUint64 ( b . buffer , b . pos + 1 , uint64 ( size ) ) wrote += 9 n , err := b . writeTuple ( value , b . pos + wrote , size ) wrote += int ( n ) if err != nil { return 0 , err } } b . offsets [ field ] = b . pos b . pos += wrote return }
8109	func ( ctx * Cotex ) WriteString ( content string ) { ctx . ResponseWriter . Write ( [ ] byte ( content ) ) }
8110	func ( ctx * Cotex ) NotFound ( message string ) { ctx . ResponseWriter . WriteHeader ( 404 ) ctx . ResponseWriter . Write ( [ ] byte ( message ) ) }
8111	func ( s * Agent ) Run ( process func ( * Agent ) error ) { s . task . Update ( func ( t * Task ) interface { } { t . taskManager = s . taskManager t . Status = AgentTaskStatusRunning return t } ) s . statusEmitter <- AgentTaskStatusRunning go s . startTaskPoller ( ) go s . listenForPoll ( ) go func ( agent Agent ) { s := & agent s . processExitHanderlDecorate ( process ) <- s . processComplete } ( * s ) }
8112	func NewWaitGroup ( throttle int ) * WaitGroup { return & WaitGroup { outstanding : 0 , throttle : throttle , completed : make ( chan bool , throttle ) , } }
8113	func ( w * WaitGroup ) Add ( ) { w . outstanding ++ if w . outstanding > w . throttle { select { case <- w . completed : w . outstanding -- return } } }
8114	func ( w * WaitGroup ) Wait ( ) { if w . outstanding == 0 { return } for w . outstanding > 0 { select { case <- w . completed : w . outstanding -- } } }
8115	func Gzip ( h http . Handler , opts ... Option ) http . Handler { o := options { logger : handler . OutLogger ( ) } o . apply ( opts ) return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { if ! strings . Contains ( r . Header . Get ( "Accept-Encoding" ) , "gzip" ) { h . ServeHTTP ( w , r ) return } wrapper := handler . NewResponseWrapper ( w ) h . ServeHTTP ( wrapper , r ) for k , v := range wrapper . Header ( ) { w . Header ( ) [ k ] = v } w . Header ( ) . Set ( "Vary" , "Accept-Encoding" ) w . Header ( ) . Set ( "Content-Encoding" , "gzip" ) if w . Header ( ) . Get ( "Content-Type" ) == "" { w . Header ( ) . Set ( "Content-Type" , http . DetectContentType ( wrapper . Body . Bytes ( ) ) ) } w . Header ( ) . Del ( "Content-Length" ) if wrapper . Code != http . StatusOK { w . WriteHeader ( wrapper . Code ) } gz := gzip . NewWriter ( w ) gz . Flush ( ) if _ , err := gz . Write ( wrapper . Body . Bytes ( ) ) ; err != nil { o . logger . Print ( "gzip handler: " + err . Error ( ) ) http . Error ( w , "Internal Server Error" , http . StatusInternalServerError ) return } gz . Close ( ) } ) }
8116	func New ( uri string , user string , password string ) InnkeeperClient { return & IkClient { URI : uri , User : user , Password : password , } }
8117	func ( r * Render ) Error ( status int , message ... string ) { r . WriteHeader ( status ) if len ( message ) > 0 { r . Write ( [ ] byte ( message [ 0 ] ) ) } }
8118	func Renderer ( options ... RenderOptions ) Handler { opt := prepareRenderOptions ( options ) cs := prepareCharset ( opt . Charset ) t := compile ( opt ) return func ( res http . ResponseWriter , req * http . Request , c Context ) { var tc * template . Template if Env == Dev { tc = compile ( opt ) } else { tc , _ = t . Clone ( ) } c . Map ( & Render { res , req , tc , opt , cs , Data } ) } }
8119	func NewClient ( apiKey string , url string , client clientDoer ) * PDClient { return & PDClient { APIKey : apiKey , client : client , URL : url , } }
8120	func ( s * PDClient ) GetTask ( taskID string ) ( task TaskResponse , res * http . Response , err error ) { req , _ := s . createRequest ( "GET" , fmt . Sprintf ( "%s/v1/task/%s" , s . URL , taskID ) , bytes . NewBufferString ( `` ) ) if res , err = s . client . Do ( req ) ; err == nil && res . StatusCode == http . StatusOK { resBodyBytes , _ := ioutil . ReadAll ( res . Body ) json . Unmarshal ( resBodyBytes , & task ) } else { lo . G . Error ( "client Do Error: " , err ) lo . G . Error ( "client Res: " , res ) err = ErrInvalidDispenserResponse } return }
8121	func WriteImageToHTTP ( w http . ResponseWriter , img image . Image ) error { buffer := new ( bytes . Buffer ) if err := png . Encode ( buffer , img ) ; err != nil { return err } w . Header ( ) . Set ( "Content-Type" , "image/png" ) w . Header ( ) . Set ( "Content-Length" , strconv . Itoa ( len ( buffer . Bytes ( ) ) ) ) if _ , err := w . Write ( buffer . Bytes ( ) ) ; err != nil { return err } return nil }
